<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>WPF 入门笔记 - 05 - 依赖属性 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="WPF 入门笔记 - 05 - 依赖属性" />
<meta property="og:description" content="WPF属性系统 这一部分是中途加的，直接依赖属性有点迷糊😪，正好有了绑定的基础，理解起来还一些。
WPF提供一组服务，这些服务可用于扩展公共语言运行时 (CLR) 属性的功能。这些服务通常统称为WPF属性系统。 由WPF属性系统支持的属性称为依赖属性。
在WPF中，属性可以分为以下几类：
CLR属性（CLR Properties）：CLR属性是指使用C#或其他.NET语言在代码中定义的普通属性，通常用于表示类的内部状态或行为，并不具备依赖属性的高级特性。
相关属性（Related Properties）：相关属性指的是一组彼此关联的属性，它们一起控制某个方面的控件或元素的外观或行为。例如，FontSize和FontFamily、Background是相关属性，它们一起定义了文本的字体大小和字体系列，具体内容可查阅WPF 入门笔记 - 03 - 样式基础及模板 - 相关属性章节。
&lt;DockPanel Background=&#34;White&#34;&gt; … &lt;/ DockPanel&gt; 附加属性（Attached Properties）：附加属性是一种特殊类型的依赖属性，它可以附加到任何元素上，而不仅仅是它所属的类型。附加属性允许在不修改元素的原始类型定义的情况下，为元素添加额外的属性。常见的例子是Grid.Row和Grid.Column属性，它们用于指定元素在Grid布局中所在的行和列。
&lt;Grid Name=&#34;MyGrid&#34; Background=&#34;Wheat&#34; ShowGridLines=&#34;False&#34;&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;TextBox Name =&#34;InputText&#34; Grid.Column =&#34;0&#34; Grid.Row =&#34;0&#34; Grid.ColumnSpan =&#34;9&#34; FontSize =&#34;12&#34; FontWeight = &#34;DemiBold&#34; Margin =&#34;5,2,10,3&#34;/&gt; &lt;Button Name=&#34;B7&#34; Click=&#34;DigitBtn_Click&#34; Grid.Column=&#34;1&#34; Grid.Row=&#34;2&#34; Margin =&#34;2&#34;&gt;7&lt;/Button&gt; &lt;Button Name=&#34;B8&#34; Click=&#34;DigitBtn_Click&#34; Grid.Column=&#34;1&#34; Grid.Row=&#34;2&#34; Margin =&#34;2&#34;&gt;8&lt;/Button&gt; &lt;Button Name=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/90158d52b4a879914d775c2f10105c87/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-19T12:19:02+08:00" />
<meta property="article:modified_time" content="2023-06-19T12:19:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">WPF 入门笔记 - 05 - 依赖属性</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="wpf属性系统" style="margin-left:0;"><strong><span style="color:#303133;"><span style="background-color:#ffffff;">WPF属性系统</span></span></strong></h3> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">这一部分是中途加的，直接依赖属性有点迷糊😪，正好有了绑定的基础，理解起来还一些。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;"><code>WPF</code>提供一组服务，这些服务可用于扩展公共语言运行时 (CLR) 属性的功能。这些服务通常统称为<code>WPF</code>属性系统。 由<code>WPF</code>属性系统支持的属性称为依赖属性。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">在<code>WPF</code>中，属性可以分为以下几类：</span></span></p> 
<ol><li> <p style="margin-left:auto;"><code>CLR</code>属性（CLR Properties）：<code>CLR</code>属性是指使用<code>C#</code>或其他<code>.NET</code>语言在代码中定义的<strong>普通属性</strong>，通常用于表示类的内部状态或行为，并不具备依赖属性的高级特性。</p> </li><li> <p style="margin-left:auto;">相关属性（Related Properties）：相关属性指的是一组彼此关联的属性，它们一起控制某个方面的控件或元素的外观或行为。例如，<code>FontSize</code>和<code>FontFamily</code>、<code>Background</code>是相关属性，它们一起定义了文本的字体大小和字体系列，具体内容可查阅<a href="https://www.cnblogs.com/BoiledYakult/p/17478282.html#%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7" rel="nofollow" title="WPF 入门笔记 - 03 - 样式基础及模板 - 相关属性章节">WPF 入门笔记 - 03 - 样式基础及模板 - 相关属性章节</a>。</p> <pre class="code-theme-dark highlighter-hljs"></pre> 
  <table cellspacing="0" style="margin-left:-16px;"><tbody><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">&lt;DockPanel Background="White"&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">…</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">&lt;/ DockPanel&gt;</code></td></tr></tbody></table></li><li> <p style="margin-left:auto;">附加属性（Attached Properties）：附加属性是一种特殊类型的依赖属性，它可以附加到任何元素上，而不仅仅是它所属的类型。附加属性允许在不修改元素的原始类型定义的情况下，为元素添加额外的属性。常见的例子是<code>Grid.Row</code>和<code>Grid.Column</code>属性，它们用于指定元素在Grid布局中所在的行和列。</p> <pre class="code-theme-dark highlighter-hljs"></pre> 
  <table cellspacing="0" style="margin-left:-16px;"><tbody><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">&lt;Grid Name="MyGrid" Background="Wheat"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">ShowGridLines="False"&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">&lt;Grid.ColumnDefinitions&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">&lt;ColumnDefinition/&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">&lt;ColumnDefinition/&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">&lt;ColumnDefinition/&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">&lt;/Grid.ColumnDefinitions&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">&lt;Grid.RowDefinitions&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">&lt;RowDefinition/&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">&lt;RowDefinition/&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">&lt;RowDefinition/&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">&lt;/Grid.RowDefinitions&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">&lt;TextBox Name ="InputText" Grid.Column ="0" Grid.Row ="0"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">Grid.ColumnSpan ="9" FontSize ="12" FontWeight =</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">"DemiBold" Margin ="5,2,10,3"/&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">&lt;Button Name="B7" Click="DigitBtn_Click" Grid.Column="1"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">Grid.Row="2" Margin ="2"&gt;7&lt;/Button&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">&lt;Button Name="B8" Click="DigitBtn_Click" Grid.Column="1"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">Grid.Row="2" Margin ="2"&gt;8&lt;/Button&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">&lt;Button Name="B9" Click="DigitBtn_Click" Grid.Column="1"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">Grid.Row="2" Margin ="2"&gt;9&lt;/Button&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
      <div></div> </td><td><code class="language-xaml">&lt;/Grid&gt;</code></td></tr></tbody></table></li><li> <p style="margin-left:auto;">依赖属性（Dependency Properties）：依赖属性是<code>WPF</code>中的一种特殊类型的属性，具有依赖项对象和依赖项属性的特性。它们支持数据绑定、样式、动画、值继承等高级特性，并具有属性系统提供的更强大的功能。依赖属性在<code>WPF</code>中广泛使用，用于控件的布局、外观、行为等方面。</p> </li></ol> 
<h3 id="依赖属性" style="margin-left:0;"><strong><span style="color:#303133;"><span style="background-color:#ffffff;">依赖属性</span></span></strong></h3> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">依赖属性（Dependency Properties）是<code>WPF</code>中的一项关键特性，它具有一些附加的功能和特性，使其在<strong>数据绑定</strong>、<strong>样式应用</strong>、<strong>动画</strong>和<strong>属性值继承</strong>等方面更加强大和灵活。<strong>它被视为一种具有依赖关系的属性，可以在没有明确值的情况下依赖于其他对象或数据源。</strong>当使用数据绑定时，依赖属性可以从数据源获取值，并在数据源值发生变化时自动更新。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">依赖属性的依赖关系和值的改变过程很复杂，尤其在涉及多个依赖属性之间的相互依赖时。但是<code>WPF</code>的属性系统提供了强大的机制和框架，以管理和处理这些依赖关系，确保属性值的正确传递和更新，这些功能都包含在强大的<code>DependencyProperty</code>类中。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">需要注意的是，依赖属性的存在并不意味着所有属性都具有依赖关系，<strong>只有通过属性注册和属性元数据定义为依赖属性的属性才具有这种特性</strong>。但是，依赖属性<strong>基本</strong>应用在了<code>WPF</code>的**所有需要设置属性的元素。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;"><strong>所谓依赖，主要应用在以下地方：</strong></span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">1、双向绑定。有了这个，依赖项属性不用写额外的代码，也不用实现什么接口，它本身就俱备双向绑定的特性，比如把员工对象的姓名绑定到文本框，一旦绑定，只要文本框中的值发生改变，依赖项属性员工姓名也会跟着变化，反之亦然；</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">2、触发器。比如一个按钮背景是红色，我想让它在鼠标停留在它上面是背景变成绿色，而鼠标一旦移开，按钮恢复红色。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">在传统的<code>Windows</code>编程中，你一定会想办法弄一些事件，或者委托来处理，还要写一堆代码。但是有了依赖项属性，你将一行代码都不用写，所有的处理均由<code>WPF</code>属性系统自动处理，而且触发器只是临时改变属性的值，当触完成时，属性值自动被“<strong>还原</strong>”。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">3、附加属性。附加属性也是依赖项属性，它可以把A类型的的某些属性推迟到运行时根据B类型的具体情况来进行设置，而且可以同时被多个类型对象同时维护同一个属性值，但每个实例的属性值是独立的。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">4、A属性改变时，也同时改变其它属性的值，比如<code>TogleButton</code>按下的同时，弹出下拉框。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;"><strong>与传统的<code>CLR</code>属性和面向对象相比依赖属性有很多新颖之处，其中包括：</strong></span></span></p> 
<ul style="margin-left:0px;"><li> <p style="margin-left:auto;"><em>新功能</em>：加入了属性变化通知，限制、验证等等功能，这样就可以使我们更方便的实现我们的应用，同时也使代码量大大减少了，许多之前不可能的功能都可以轻松的实现了。</p> </li><li> <p style="margin-left:auto;"><em>节约内存</em>：在<code>WinForm</code>中，我们知道控件的属性很多并且通常都必须有初始值的，在新建控件对象时为每一个属性存储一个字段将是对内存的巨大浪费。<code>WPF</code>依赖属性很好地解决了这个问题，它内部使用高效的稀疏存储系统，仅仅存储改变了的属性，即默认值在依赖属性中只存储一次。【依赖属性最终会存放在一个静态的全局<code>HashTable</code>中】</p> </li><li> <p style="margin-left:auto;"><em>支持多个提供对象</em>：我们可以通过多种方式来设置依赖属性的值。同时其内部可以储存多个值，配合<code>Expression</code>、<code>Style</code>、<code>Animation</code>等可以给我们带来很强的开发体验.</p> </li></ul> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">说了这么多到底怎么理解依赖属性呢？</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">依赖属性就好比家庭通讯录中每个成员的联系方式。每当有人的联系方式发生变化时，你需要通知其他家庭成员告诉他们有人更换了联系方式，让他们可以更新他们的通讯录，以保持信息一致。</span></span></p> 
<h4 id="初识依赖属性" style="margin-left:0;"><strong><span style="color:#303133;"><span style="background-color:#ffffff;">初识依赖属性</span></span></strong></h4> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">回到正题，我们来看个小例子，上篇笔记中有提到过绑定中的目标属性必须是依赖属性，就举个绑定的例子顺便回顾一下绑定：</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">以<code>TextBox</code>控件的<code>Text</code>属性为例，依赖属性的特点是可以通过数据绑定与其他对象进行绑定，实现属性值的自动更新和同步。下面是一个简单的例子：</span></span></p> 
<pre class="code-theme-dark highlighter-hljs" style="margin-left:auto;"></pre> 
<table cellspacing="0" style="margin-left:-16px;"><tbody><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;StackPanel&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;TextBox x:Name="textBox" Text="Hello" /&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;TextBlock Text="{Binding ElementName=textBox, Path=Text}" /&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/StackPanel&gt;</code></td></tr></tbody></table> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">在这个例子中，我们有一个<code>TextBox</code>控件和一个<code>TextBlock</code>控件。<code>TextBox</code>的<code>Text</code>属性被设置为"Hello"，而<code>TextBlock</code>的<code>Text</code>属性通过数据绑定与<code>TextBox</code>的<code>Text</code>属性绑定。这意味着当<code>TextBox</code>的文本发生变化时，<code>TextBlock</code>的文本也会自动更新。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">这种绑定关系是通过依赖属性的特性实现的，转到<code>Text</code>属性的定义，可以发现有一个名为<code>TextProperty</code>的静态只读字段，字段类型是<code>DependencyProperty</code>。该字段是用来标识<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.textbox.text?view=windowsdesktop-7.0#system-windows-controls-textbox-text" rel="nofollow" title="Text">Text</a>依赖项属性的，<code>DependencyProperty</code>是<code>WPF</code>中用于定义依赖属性的类，它包含了属性的元数据信息以及属性的访问方法。</span></span></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c7/7e/DWbGYcKc_o.png"></p> 
<blockquote style="margin-left:0px;"> 
 <p style="margin-left:auto;">❗❗❗需要注意的是，依赖属性是一个类的静态字段，只能是<code>DependencyProperty</code>类型的字段</p> 
</blockquote> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">看一个不是依赖属性的例子，出于安全考虑，在<code>WPF</code>中，<code>PasswordBox</code>控件的<code>Password</code>属性不支持数据绑定的，查看<code>PasswordBox</code>的定义可以看到并没有类型是<code>DependencyProperty</code>的<code>PasswordProperty</code>字段，写个例子看一下是不是不支持绑定，为了好理解，我们在绑定里把科技和狠活都整上：</span></span></p> 
<pre class="code-theme-dark highlighter-hljs" style="margin-left:auto;"></pre> 
<table cellspacing="0" style="margin-left:-16px;"><tbody><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;StackPanel&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;StackPanel&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;TextBox x:Name="textBox" Text="Hello" /&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;TextBox Text="{Binding ElementName=passWD, Path=Password, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" /&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;PasswordBox x:Name="passWD" Password="7355608" /&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/StackPanel&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/StackPanel&gt;</code></td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6b/1a/IRZvet1Y_o.gif"></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;"><code>XAML</code>中数据绑定模式是双向的，默认情况下，当源对象的值发生变化时，会自动更新目标对象的值，但实际上<code>PasswordBox</code>的<code>Password</code>属性本身不是依赖属性，因此它不支持直接的数据绑定。因此，当你修改第一个<code>TextBox</code>的文本时，会将新的文本值传递给<code>passWD</code>的<code>Password</code>属性，反过来，<code>TextBox</code>的文本是不能响应<code>Password</code>属性的变化的。</span></span></p> 
<blockquote style="margin-left:0px;"> 
 <p style="margin-left:auto;">💬我猜啊，大家可能会有疑惑，为什么<code>Password</code>属性会响应<code>TextBox</code>的文本变化呢？</p> 
 <p style="margin-left:auto;">这就要看你有没有把绑定的概念搞通透了，<code>Password</code>属性会响应<code>TextBox</code>的文本变化时在绑定中做的是什么？是不是<strong>源对象属性</strong>，它的目标对象是<code>TextBox</code>的<code>Text</code>属性对吧🧐</p> 
</blockquote> 
<h4 id="自定义依赖属性" style="margin-left:0;"><strong><span style="color:#303133;"><span style="background-color:#ffffff;">自定义依赖属性</span></span></strong></h4> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;"><strong>自定义的依赖属性通常定义在自定义的依赖对象（继承自<code>DependencyObject</code>）中</strong>，并与其他依赖属性或相关的对象建立依赖关系。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">🔖常用的普通属性定义方法：</span></span></p> 
<pre class="code-theme-dark highlighter-hljs" style="margin-left:auto;"></pre> 
<table cellspacing="0" style="margin-left:-16px;"><tbody><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#"><span style="color:#c678dd;">class</span> <span style="color:#e6c07b;">BaseClass</span></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">{<!-- --></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">private <span style="color:#d19a66;">int</span> age;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">public <span style="color:#d19a66;">int</span> Age </code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">{ </code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">get { <span style="color:#c678dd;">return</span> age; }</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#"><span style="color:#e6c07b;">set</span> { age = value; }</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">}</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">}</code></td></tr></tbody></table> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">🔖再来看看依赖属性：</span></span></p> 
<blockquote style="margin-left:0px;"> 
 <p style="margin-left:auto;">📌在VS中快速创建依赖属性的方法：键入<code>propdp</code>，连续按两下<code>Tab</code>健。</p> 
</blockquote> 
<pre class="code-theme-dark highlighter-hljs" style="margin-left:auto;"></pre> 
<table cellspacing="0" style="margin-left:-16px;"><tbody><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#"><span style="color:#c678dd;">class</span> <span style="color:#e6c07b;">CustomTextBox</span>:TextBox</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">{<!-- --></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">public <span style="color:#d19a66;">bool</span> IsEmpty</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">{<!-- --></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">get { <span style="color:#c678dd;">return</span> (<span style="color:#d19a66;">bool</span>)GetValue(IsEmptyProperty); }</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#"><span style="color:#e6c07b;">set</span> { SetValue(IsEmptyProperty, value); }</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">}</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">public <span style="color:#d19a66;">static</span> readonly DependencyProperty IsEmptyProperty = DependencyProperty.Register(</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#"><span style="color:#98c379;">"IsEmpty"</span>, <span style="color:#5c6370;"><em>// name</em></span></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">typeof(<span style="color:#d19a66;">bool</span>), <span style="color:#5c6370;"><em>// propertyType</em></span></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">typeof(CustomTextBox), <span style="color:#5c6370;"><em>// ownerType</em></span></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">new PropertyMetadata(<span style="color:#56b6c2;">false</span>) <span style="color:#5c6370;"><em>// typeMetadata (defaultValue) </em></span></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">);</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">}</code></td></tr></tbody></table> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">依赖属性的定义通常通过以下几个步骤定义：</span></span></p> 
<ol><li> <p style="margin-left:auto;">在自定义依赖对象的类中继承<code>DependencyObject</code>，使得该类具有支持依赖属性的功能。</p> <p style="margin-left:auto;">示例中的<code>CustomTextBox</code>继承自<code>TextBox</code>类，显然<code>TextBox</code>类已经完成了这项工作。</p> </li><li> <p style="margin-left:auto;">声明一个静态只读的<code>DependencyProperty</code>字段，用于标识依赖属性，<strong>这个字段才是真正的依赖属性</strong>。该字段通常使用<code>public static readonly</code>修饰符，命名方式一般为<code>PropertyNameProperty</code>。</p> <p style="margin-left:auto;">示例中的<code>IsEmptyProperty</code>字段。</p> </li><li> <p style="margin-left:auto;">使用<code>DependencyProperty.Register</code>方法进行属性注册，将依赖属性与相应的元数据关联起来。该方法接受参数包括<strong>属性名称、属性类型、拥有者类型以及可选的属性元数据</strong>。</p> </li><li> <p style="margin-left:auto;">定义公共属性（通常为<code>CLR</code>属性） - 属性封装器，用于封装依赖属性的获取和设置逻辑。在属性的<code>get</code>和<code>set</code>访问器中，使用<code>GetValue</code>和<code>SetValue</code>方法来操作依赖属性的值。该项不是必要的，我们也可以直接通过使用<code>GetValue</code>和<code>SetValue</code>方法来操作依赖属性的值，但是为了代码的简洁，一般通过所定义的属性进行操作。</p> <p style="margin-left:auto;">示例中的<code>IsEmpty</code>属性。</p> </li><li> <p style="margin-left:auto;">可选：根据需要，可以为依赖属性添加属性元数据，如默认值（实例中传递的<code>false</code>）、属性改变回调函数等，以控制依赖属性的行为和特性。</p> </li></ol> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">自定义依赖属性的步骤中，最重要的就是依赖属性的注册，定义的公共属性仅仅提供我们访问依赖属性的便捷方法，不写也是可以的，只不过我们得在每次使用依赖属性的时候都调用<code>GetValue</code>和<code>SetValue</code>方法完成对于依赖属性的操作。一个依赖属性的注册最全的形式是下面这样子的：</span></span></p> 
<pre class="code-theme-dark highlighter-hljs" style="margin-left:auto;"></pre> 
<table cellspacing="0" style="margin-left:-16px;"><tbody><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">public <span style="color:#d19a66;">static</span> DependencyProperty <span style="color:#61aeee;">Register</span>(<span style="color:#e6c07b;">string</span> name, </code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">Type propertyType,</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">Type ownerType, </code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">PropertyMetadata typeMetadata,</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">ValidateValueCallback validateValueCallback);</code></td></tr></tbody></table> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">　第一个参数是该依赖属性的名字，第二个参数是依赖属性的类型，第三个参数是该依赖属性的所有者的类型，第五个参数是一个验证值的回调委托，第四个<code>PropertyMetadata</code>是我们上面提到的属性的<strong>元数据</strong>，上面示例中我们将<code>PropertyMetadata</code>作为依赖属性的初值，事实上它还有很多可以实现强大功能的重载，转到定义可以看到：</span></span></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/49/45/nRmRzQHh_o.png"></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">其他的<code>PropertyChangedCallback</code>和<code>CoerceValueCallback</code>是<code>PropertyMetadata</code>构造函数中的两个回调参数，它们分别用于属性值变化和值强制转换时的回调操作：</span></span></p> 
<ul style="margin-left:0px;"><li> <p style="margin-left:auto;"><code>PropertyChangedCallback</code>：</p> 
  <ul style="margin-left:0px;"><li> <p style="margin-left:auto;">当依赖属性的值发生变化时，<code>PropertyChangedCallback</code>会被调用。这个回调函数允许我们在属性值发生变化时执行一些自定义的逻辑或操作。</p> </li><li> <p style="margin-left:auto;">通过在回调函数中编写逻辑，我们可以根据新的属性值执行一些特定的行为，例如更新界面上的相关元素、触发其他事件或通知其他对象。</p> </li><li> <p style="margin-left:auto;">这个回调函数的签名通常是<code>void MyPropertyChangedCallback(DependencyObject d, DependencyPropertyChangedEventArgs e)</code>，其中参数<code>d</code>表示拥有该属性的对象，参数<code>e</code>包含了旧值和新值等相关信息。</p> </li></ul></li><li> <p style="margin-left:auto;"><code>CoerceValueCallback</code>：</p> 
  <ul style="margin-left:0px;"><li>当依赖属性的值需要强制转换时，<code>CoerceValueCallback</code>会被调用。这个回调函数允许我们在属性值被设置之前对其进行强制转换或限制。</li><li>通过在回调函数中编写逻辑，我们可以对属性值进行验证、限制范围、自动修正或其他转换操作。</li><li>这个回调函数的签名通常是<code>object MyCoerceValueCallback(DependencyObject d, object baseValue)</code>，其中参数<code>d</code>表示拥有该属性的对象，参数<code>baseValue</code>表示属性的基本值（还未进行强制转换的值），回调函数应该返回经过转换后的值。</li></ul></li></ul> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">这两个回调函数在自定义依赖属性时非常有用，它们使我们能够在属性值变化和强制转换时进行自定义操作，以满足特定的需求，如验证、更新界面、修正值等。</span></span></p> 
<blockquote style="margin-left:0px;"> 
 <p style="margin-left:auto;">📌普通属性是直接对类的一个私有字段进行封装，读取值的时候，直接读取这个字段；</p> 
</blockquote> 
<blockquote style="margin-left:0px;"> 
 <p style="margin-left:auto;">📌依赖属性则是通过调用继承自<code>DependencyObject</code>的<code>GetValue()</code>和<code>SetValue()</code>来进行操作，这也是为什么依赖属性只能是<code>DependencyProperty</code>类型的原因。它实际存储在<code>DependencyProperty</code>的一个<code>HashTable</code>中，键(Key)就是该属性的<code>HashCode</code>值，值(Value)是我们注册的<code>DependencyProperty</code>。</p> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/69/91/Nnbh5W2x_o.png"></p> 
</blockquote> 
<blockquote style="margin-left:0px;"> 
 <p style="margin-left:auto;">📌属性封装器不应该是验证数据或引发事件的正确位置，它仅仅提供对依赖属性的便捷访问；进行验证数据或引发事件应使用依赖项属性的回调函数。</p> 
</blockquote> 
<p><strong><span style="color:#303133;"><span style="background-color:#ffffff;">只读依赖属性</span></span></strong></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">在定义普通属性时，我们可以设置属性为只读的来防止外界对属性的恶意更改。同样在<code>WPF</code>中也可以设置只读的依赖属性，比如我们常见的<code>IsMouseOver</code>就是一个只读的依赖属性。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">如何创建一个只读的依赖属性呢？定义方式和一般依赖属性的定义方式差不多，只不过需要用<code>DependencyProperty.RegisterReadonly</code>替换<code>DependencyProperty.Register</code>：</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">比如我们把上面的<code>IsEmpty</code>定义成一个只读的依赖属性，用于标识<code>TextBox</code>输入框是否为空：</span></span></p> 
<pre class="code-theme-dark highlighter-hljs" style="margin-left:auto;"></pre> 
<table cellspacing="0" style="margin-left:-16px;"><tbody><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#"><span style="color:#c678dd;">class</span> <span style="color:#e6c07b;">CustomTextBox</span> : TextBox</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">{<!-- --></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">public <span style="color:#d19a66;">bool</span> IsEmpty</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">{<!-- --></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">get { <span style="color:#c678dd;">return</span> (<span style="color:#d19a66;">bool</span>)GetValue(IsEmptyProperty); }</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">}</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">public <span style="color:#d19a66;">static</span> readonly DependencyProperty IsEmptyProperty;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">public <span style="color:#d19a66;">static</span> readonly DependencyPropertyKey IsEmptyPropertyKey;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#"><span style="color:#d19a66;">static</span> <span style="color:#61aeee;">CustomTextBox</span>()</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">{<!-- --></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">IsEmptyPropertyKey=DependencyProperty.RegisterReadOnly(</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#"><span style="color:#98c379;">"IsEmpty"</span>,</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">typeof(<span style="color:#d19a66;">bool</span>),</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">typeof(TextBox),</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">new PropertyMetadata(<span style="color:#56b6c2;">false</span>)</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">);</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">IsEmptyProperty = IsEmptyPropertyKey.DependencyProperty;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">}</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">}</code></td></tr></tbody></table> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">定义只读的依赖属性与可以读写的依赖属性主要有以下几处不同：</span></span></p> 
<ul style="margin-left:0px;"><li>注册方法是<code>RegisterReadOnly</code>,且返回值类型是<code>DependencyPropertyKey</code></li><li>为了保证取值的一致性，需要同时创建一个静态公开<code>DependencyProperty</code>字段<code>IsEmptyProperty</code>(注意名称符合依赖属性的规范)，其值是<code>IsEmptyPropertyKey.DependencyProperty</code>,</li><li>如果需要开放<code>CLR</code>属性的包装器，需要限制<code>set</code>的访问权限。</li></ul> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">示例中的注册写在了自定义类的静态无参构造函数里，当然也可以不这么写，直接在类里面实现。</span></span></p> 
<h4 id="使用依赖属性" style="margin-left:0;"><strong><span style="color:#303133;"><span style="background-color:#ffffff;">使用依赖属性</span></span></strong></h4> 
<blockquote style="margin-left:0px;"> 
 <p style="margin-left:auto;"><strong>实际开发场景中，<span style="color:#000000;">依赖属性</span>应该在当你需要单独创建控件时, 并且希望控件的某个部分能够支持数据绑定时使用。</strong></p> 
</blockquote> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">学会定义依赖属性后该怎么去用呢？回到我们上边定义的<code>CustomBoxText</code>类，我们在<code>Xaml</code>里声明一下看看：</span></span></p> 
<pre class="code-theme-dark highlighter-hljs" style="margin-left:auto;"></pre> 
<table cellspacing="0" style="margin-left:-16px;"><tbody><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;Window x:Class="WPFDemo.MainWindow"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">xmlns:d="http://schemas.microsoft.com/expression/blend/2008"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">xmlns:local="clr-namespace:WPFDemo"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">mc:Ignorable="d"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">Title="MainWindow" Height="450" Width="800"&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;Grid&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;StackPanel&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;local:CustomTextBox Text="Casstiel" IsEmpty="True" /&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/StackPanel&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/Grid&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/Window&gt;</code></td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/70/2a/xckt9Rwo_o.png"></p> 
<blockquote style="margin-left:0px;"> 
 <p style="margin-left:auto;">只读的依赖属性在<code>Xaml</code>中是不能访问到的。</p> 
</blockquote> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">以上内容就是实现一个简单的依赖属性的方法演示。大家可以发现，我们定义的依赖属性其实没有任何作用，我们仅仅是在<code>TextBox</code>中给它新增了一个<code>IsEmpty</code>的依赖属性，它除了多出来的一个<code>IsEmpty</code>的配置项就和普通的<code>TextBox</code>就没别的区别了。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">如果我们想要让<code>IsEmpty</code>成为一个货真价实的依赖属性，可以实实在在地告诉我们文本框是否为空，并根据不同情况做出不同地反应该怎么做呢❓</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">改内容请查看下文：<a href="https://www.cnblogs.com/BoiledYakult/p/17490567.html#%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7%E7%9A%84%E8%A7%A6%E5%8F%91%E5%8F%8A%E6%9B%B4%E6%96%B0" rel="nofollow" title="依赖属性的触发及更新">依赖属性的触发及更新</a></span></span></p> 
<h3 id="附加属性" style="margin-left:0;"><strong><span style="color:#303133;"><span style="background-color:#ffffff;">附加属性</span></span></strong></h3> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">附加属性（Attached Properties）是一种特殊类型的依赖属性，它可以附加到其他对象上并为其提供额外的属性。与普通的依赖属性不同，附加属性没有直接的所有者对象，而是通过"附加"到其他对象上。这使得你可以在不修改对象类定义的情况下，为其添加额外的属性。最常见的附加属性地例子就是<code>Grid.Row</code>和<code>Grid.Column</code>属性，用于指定元素在<code>Grid</code>布局中所在的行和列。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">相较于依赖属性，附加属性有以下优势：</span></span></p> 
<ol><li>扩展性：附加属性允许我们为任何类添加额外的属性，即使这些类不是直接派生自<code>DependencyObject</code>。这使得我们可以为现有的类添加自定义的属性，而无需修改它们的源代码。</li><li>无侵入性：使用附加属性可以避免对现有类进行修改，从而避免破坏现有代码或增加额外的复杂性。我们可以通过外部扩展属性的方式，为类添加新的功能和数据。</li><li>可重用性：附加属性可以在不同的类之间共享和重复使用。例如，可以为多个控件添加相同的附加属性，以实现一致的行为或外观。</li></ol> 
<blockquote style="margin-left:0px;"> 
 <p style="margin-left:auto;">📌在VS中快速创建依赖属性的方法：键入<code>propa</code>，连续按两下<code>Tab</code>健。</p> 
</blockquote> 
<pre class="code-theme-dark highlighter-hljs" style="margin-left:auto;"></pre> 
<table cellspacing="0" style="margin-left:-16px;"><tbody><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#"><span style="color:#c678dd;">class</span> <span style="color:#e6c07b;">MyAttachedProperty</span></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">{<!-- --></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">public <span style="color:#d19a66;">static</span> <span style="color:#d19a66;">bool</span> <span style="color:#61aeee;">GetIsHighlighted</span>(DependencyObject obj)</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">{<!-- --></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#"><span style="color:#c678dd;">return</span> (<span style="color:#d19a66;">bool</span>)obj.GetValue(IsHighlightedProperty);</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">}</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">public <span style="color:#d19a66;">static</span> <span style="color:#d19a66;">void</span> <span style="color:#61aeee;">SetIsHighlighted</span>(DependencyObject obj, <span style="color:#d19a66;">bool</span> value)</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">{<!-- --></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">obj.SetValue(IsHighlightedProperty, value);</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">}</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">public <span style="color:#d19a66;">static</span> readonly DependencyProperty IsHighlightedProperty =</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">DependencyProperty.RegisterAttached(</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#"><span style="color:#98c379;">"IsHighlighted"</span>,</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">typeof(<span style="color:#d19a66;">bool</span>),</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">typeof(MyAttachedProperty),</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">new PropertyMetadata(<span style="color:#56b6c2;">false</span>)</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">);</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">}</code></td></tr></tbody></table> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">在这个例子中，我们定义了一个名为<code>IsHighlighted</code>的附加属性，它是一个<code>bool</code>类型的属性。可以看出，创建附加属性其实和普通的依赖属性是差不多的，只不过所有者类型的限制和属性获取/设置方法不同：</span></span></p> 
<ul style="margin-left:0px;"><li>属性的所有者类型可以是任何类，包括非派生自<code>DependencyObject</code>的类。</li><li>使用<code>DependencyProperty.RegisterAttached</code>方法来注册附加属性，并通过该方法返回的<code>DependencyProperty</code>对象来获取和设置属性值。</li><li>附加属性的获取和设置方法需要显式地定义为静态方法，并接受一个<code>DependencyObject</code>参数。</li></ul> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">假设我们有一个<code>TextBlock</code>控件，我们想要将<code>IsHighlighted</code>属性附加到其子元素上，以指示是否要突出显示该子元素。我们可以在<code>XAML</code>中使用附加属性语法来设置和获取该属性的值，如下所示：</span></span></p> 
<pre class="code-theme-dark highlighter-hljs" style="margin-left:auto;"></pre> 
<table cellspacing="0" style="margin-left:-16px;"><tbody><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;Window x:Class="WPFDemo.MainWindow"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">xmlns:d="http://schemas.microsoft.com/expression/blend/2008"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">xmlns:local="clr-namespace:WPFDemo"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">mc:Ignorable="d"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">Title="MainWindow" Height="450" Width="800"&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;Grid&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;StackPanel&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;TextBlock local:MyAttachedProperty.IsHighlighted="False" Text="{Binding RelativeSource={RelativeSource Self},Path=(local:MyAttachedProperty.IsHighlighted)}"/&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/StackPanel&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/Grid&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/Window&gt;</code></td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/de/40/dyHu82A0_o.png"></p> 
<h3 id="依赖属性-or-附加属性" style="margin-left:0;"><strong><span style="color:#303133;"><span style="background-color:#ffffff;">依赖属性 or 附加属性</span></span></strong></h3> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">依赖属性和附加属性在<code>WPF</code>中都是用于为对象添加自定义属性的机制，它们有着不同的用途和适用场景。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">依赖属性适用于为自定义控件或自定义数据对象定义属性，并允许这些属性具备数据绑定、样式化、动画等功能。依赖属性通常定义在继承自<code>DependencyObject</code>的类中，并且可以通过属性元数据和属性注册进行进一步的配置。使用依赖属性可以使对象具备更强大的属性系统，允许属性值的变化通知其他对象进行相应的更新。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">附加属性则用于向现有的<code>WPF</code>控件添加自定义属性，扩展其功能，而无需修改原始控件的类定义。附加属性可以附加到任何对象上，而不仅仅是<code>DependencyObject</code>的子类。通过附加属性，我们可以为控件添加额外的属性，以满足特定的需求，例如布局、样式、行为等。附加属性通常定义在静态类中，并使用<code>RegisterAttached</code>方法进行注册。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">选择使用依赖属性还是附加属性取决于你的需求和场景：</span></span></p> 
<ul style="margin-left:0px;"><li>如果你需要为自定义控件或数据对象定义属性，并希望能够使用数据绑定、样式化、动画等功能，那么应该选择依赖属性。</li><li>如果你想向现有的<code>WPF</code>控件添加自定义属性，扩展其功能，并在<code>XAML</code>中进行配置，而不修改原始控件的类定义，那么应该选择附加属性。</li></ul> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">在实际开发中，需要根据具体的需求来选择合适的属性机制。有时候，依赖属性和附加属性可以结合使用，以实现更复杂的功能和交互。</span></span></p> 
<h3 id="依赖属性的触发及更新" style="margin-left:0;"><strong><span style="color:#303133;"><span style="background-color:#ffffff;">依赖属性的触发及更新</span></span></strong></h3> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">这里提供几种可行思路，大家可以自行探索：</span></span></p> 
<ul style="margin-left:0px;"><li>比较简单的通过样式（Style）和触发器（Triggers）完成</li><li>在注册依赖属性时添加属性的回调方法</li><li>在使用定义的依赖属性的控件注册相应的事件进而做出处理</li><li>。。。。。。</li></ul> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">用我们之前的<code>IsEmpty</code>做一个演示，首先，在<code>CustomTextBox</code>类中定义<code>IsEmpty</code>依赖属性和属性更改回调方法：</span></span></p> 
<pre class="code-theme-dark highlighter-hljs" style="margin-left:auto;"></pre> 
<table cellspacing="0" style="margin-left:-16px;"><tbody><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">public <span style="color:#c678dd;">class</span> <span style="color:#e6c07b;">CustomTextBox</span> : TextBox</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">{<!-- --></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">public <span style="color:#d19a66;">static</span> readonly DependencyProperty IsEmptyProperty =</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">DependencyProperty.Register(<span style="color:#98c379;">"IsEmpty"</span>, typeof(<span style="color:#d19a66;">bool</span>), typeof(CustomTextBox),</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">new PropertyMetadata(<span style="color:#56b6c2;">true</span>,OnIsEmptyChanged));</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">public <span style="color:#d19a66;">bool</span> IsEmpty</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">{<!-- --></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">get { <span style="color:#c678dd;">return</span> (<span style="color:#d19a66;">bool</span>)GetValue(IsEmptyProperty); }</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#"><span style="color:#e6c07b;">set</span> { SetValue(IsEmptyProperty, value); }</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">}</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">private <span style="color:#d19a66;">static</span> <span style="color:#d19a66;">void</span> <span style="color:#61aeee;">OnIsEmptyChanged</span>(DependencyObject d, DependencyPropertyChangedEventArgs e)</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">{<!-- --></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">CustomTextBox textBox = (CustomTextBox)d;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">textBox.UpdateTextBoxStyle();</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">}</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">private <span style="color:#d19a66;">void</span> <span style="color:#61aeee;">UpdateTextBoxStyle</span>()</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">{<!-- --></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#"><span style="color:#c678dd;">if</span> (IsEmpty)</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">{<!-- --></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#"><span style="color:#5c6370;"><em>// 设置默认样式</em></span></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">Style = null;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">}</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#"><span style="color:#c678dd;">else</span></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">{<!-- --></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#"><span style="color:#5c6370;"><em>// 设置绿色背景样式</em></span></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">Style = FindResource(<span style="color:#98c379;">"GreenTextBoxStyle"</span>) as Style;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">}</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">}</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">}</code></td></tr></tbody></table> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">注册依赖属性的时候，元数据我们加一个<code>PropertyMetadata</code>属性变化的回调，在回调里调整样式。接下来，在<code>XAML</code>中定义<code>CustomTextBox</code>控件，并为其创建背景变化样式：</span></span></p> 
<pre class="code-theme-dark highlighter-hljs" style="margin-left:auto;"></pre> 
<table cellspacing="0" style="margin-left:-16px;"><tbody><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;Window.Resources&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;Style x:Key="ColorTextBoxStyle" TargetType="local:CustomTextBox"&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;Setter Property="Background" Value="Green"/&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;Setter Property="Foreground" Value="AntiqueWhite"/&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/Style&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/Window.Resources&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;Grid&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;local:CustomTextBox x:Name="customTextBox" Width="200" Height="30" TextChanged="customTextBox_TextChanged"/&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/Grid&gt;</code></td></tr></tbody></table> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">最后，通过注册<code>TextBox TextChanged</code>事件，根据文本框的内容更新<code>IsEmpty</code>属性的值：</span></span></p> 
<pre class="code-theme-dark highlighter-hljs" style="margin-left:auto;"></pre> 
<table cellspacing="0" style="margin-left:-16px;"><tbody><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">private <span style="color:#d19a66;">void</span> <span style="color:#61aeee;">customTextBox_TextChanged</span>(object sender, TextChangedEventArgs e)</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">{<!-- --></code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">CustomTextBox textBox = (CustomTextBox)sender;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">textBox.IsEmpty = <span style="color:#e6c07b;">string</span>.IsNullOrEmpty(textBox.Text);</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-C language-C#">}</code></td></tr></tbody></table> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">这样，根据<code>IsEmpty</code>属性的值的变化，就可以动态地改变<code>CustomTextBox</code>的样式了：</span></span></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/19/e5/dVYcaKHW_o.gif"></p> 
<h3 id="属性的优先级" style="margin-left:0;"><strong><span style="color:#303133;"><span style="background-color:#ffffff;">属性的优先级</span></span></strong></h3> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">在WPF中，属性设置的优先级由以下顺序决定（从高到低）：</span></span></p> 
<ol><li>直接设置值：如果属性通过直接赋值方式进行设置，优先级最高。例如，通过在<code>XAML</code>中显式设置属性值或通过代码为属性赋值。</li><li>样式（Style）：样式可以通过Setter元素为属性设置值，并且可以将样式应用于多个元素。在应用样式时，<code>Setter</code>元素中的属性值将覆盖直接设置的值。</li><li>模板（Template）：模板可以通过控件的外观定义，包括属性的默认值。如果在模板中为属性设置了值，它将覆盖直接设置的值和样式中的值。</li><li>数据绑定（Data Binding）：使用数据绑定可以将属性绑定到数据源，以实现动态更新属性值的功能。如果属性被绑定到数据源，数据源提供的值将覆盖直接设置的值、样式中的值和模板中的值。</li><li>触发器（Triggers）：触发器可以根据特定的条件来改变属性的值。当满足触发器中定义的条件时，属性将使用触发器中指定的值进行设置。触发器可以覆盖直接设置的值、样式中的值、模板中的值和数据绑定的值。</li><li>继承（Inheritance）：一些属性可以从父元素继承其值。如果属性没有在当前元素上设置值，它将继承自父元素。如果没有父元素设置该属性的值，则将使用属性的默认值。</li><li>默认值（Default Value）：每个属性都有一个默认值，在没有其他方式设置属性值时将使用默认值。</li></ol> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">注意：这只是属性设置优先级的一般规则，实际情况可能会因控件类型、继承关系、样式和模板等因素而有所不同。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">这部分需要在实际开发过程中理解了，比如下面的这段<code>xaml</code>代码：</span></span></p> 
<pre class="code-theme-dark highlighter-hljs" style="margin-left:auto;"></pre> 
<table cellspacing="0" style="margin-left:-16px;"><tbody><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;Window x:Class="WpfApp2.MainWindow"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">xmlns:d="http://schemas.microsoft.com/expression/blend/2008"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">xmlns:local="clr-namespace:WpfApp2"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">Title="WPFDemo"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">Width="800"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">Height="450"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">Loaded="Window_Loaded"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">WindowStartupLocation="CenterScreen"</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">mc:Ignorable="d"&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;Grid&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;Button x:Name="myButton" Background="#007acc"&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;Button.Style&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;Style TargetType="{x:Type Button}"&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;Setter Property="Background" Value="Black" /&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;Style.Triggers&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;Trigger Property="IsMouseOver" Value="True"&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;Setter Property="Background" Value="Red" /&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/Trigger&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/Style.Triggers&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/Style&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/Button.Style&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">Click</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/Button&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/Grid&gt;</code></td></tr><tr><td style="text-align:center;vertical-align:top;"> 
    <div></div> </td><td><code class="language-xaml">&lt;/Window&gt;</code></td></tr></tbody></table> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">大家觉得<code>Button</code>在鼠标悬停的时候会不会变成红色呢？</span></span></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e2/7f/KkW4J0NZ_o.gif"></p> 
<h3 id="done" style="margin-left:0;"><strong><span style="color:#303133;"><span style="background-color:#ffffff;">Done</span></span></strong></h3> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;"><code>WPF</code>的依赖属性是一项强大的功能，它允许我们创建可扩展、灵活和可重用的<code>UI</code>组件。通过依赖属性，我们可以实现属性的数据绑定、样式化、动画化以及属性值的有效验证和转换。在本文中，我们介绍了几个关键概念和用法，包括初始依赖属性、自定义依赖属性、只读依赖属性以及附加属性。<code>WPF</code>为我们提供了一组丰富的预定义的依赖属性，它们可以直接应用于<code>WPF</code>控件，并具有默认的行为和特性。这些初始依赖属性涵盖了常见的属性需求，例如宽度、高度、可见性等，可以极大地简化开发过程。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">自定义依赖属性需要我们根据特定需求创建的属性，通过继承<code>DependencyObject</code>和使用<code>DependencyProperty</code>类进行声明和注册。自定义依赖属性使我们能够为自定义控件或现有控件添加额外的属性，并利用<code>WPF</code>的数据绑定和其他功能。附加属性是一种特殊的依赖属性，它允许将属性附加到其他对象上。通过附加属性，我们可以在不修改对象继承层次结构的情况下，向对象添加额外的属性。附加属性通常用于为特定控件或面板指定特定的行为或属性设置。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">在使用依赖属性时，可以利用数据绑定、样式、触发器和动画等特性，实现属性值的自动同步、响应式行为和动态交互。属性的优先级机制确保了属性之间的正确顺序和生效顺序，从而实现属性的继承、覆盖和合成。</span></span></p> 
<p style="margin-left:auto;"><span style="color:#303133;"><span style="background-color:#ffffff;">希望本文能为你提供有关依赖属性的基本内容和指导为你提供帮助。</span></span></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d046aba08a244153e362667305f4eb4c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">记录工作中使用easyExcel实现复杂一对多excel表格导出及多sheet页导出</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/823f3a925316a10c663da004561ec958/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">个人财务管理系统的设计与实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>