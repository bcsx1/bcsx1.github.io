<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android 5.0 新特性和功能，系统和 API 行为变更 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android 5.0 新特性和功能，系统和 API 行为变更" />
<meta property="og:description" content="Android 5.0 API 变更（Android L、API Level 21） 用户界面 Material Design 支持
Android 5.0 添加了对 Android 的新 Material Design 样式的支持。您可以创建具有 Material Design 功能的应用，实现动态视觉效果，利用其中的 UI 元素转换赋予用户自然的感觉。此支持包括：
Material Design 主题视图阴影RecyclerView 小部件可绘制动画和造型效果Material Design 动画和 Activity 转换效果针对基于视图状态的视图属性的动画生成器可自定义的 UI 小部件和具有可由您控制的调色板的应用栏基于 XML 矢量图形的动画和非动画可绘制对象
要详细了解如何为您的应用添加 Material Design 功能，请参阅 Material Design。 最近使用的应用屏幕中的并发文档和 Activity
在之前的版本中，最近使用的应用屏幕只能为最近与用户交互过的每个应用显示一项任务。现在，您的应用可以根据需要为其他并发文档 Activity 打开更多任务。此功能简化了多任务处理，通过在所有应用中提供一致的切换体验，让用户能够在最近使用的应用屏幕中的各个 Activity 和文档之间快速切换。此类并行任务示例可能包括：网络浏览器应用中打开的标签页、效率类应用中的文档、游戏中的并行对局或信息应用中的聊天。您的应用可以通过 ActivityManager.AppTask 类管理它的任务。
为插入逻辑换行符以便系统将您的 Activity 视为新任务，请在使用 startActivity() 启动 Activity 时使用 FLAG_ACTIVITY_NEW_DOCUMENT。您还可以通过在清单中将 元素的 documentLaunchMode 属性设置为 “intoExisting” 或 “always” 来获得此行为。
为避免使最近使用的应用屏幕变得混乱，您可以在应用中设置该屏幕中可显示的任务数上限。要实现此目的，请设置 属性 android:maxRecents。目前可指定的上限为每位用户 50 个任务（RAM 较低设备为 25 个）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/8e7eee93be3378dc1fca5e3a0ad9428a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-02-03T09:44:12+08:00" />
<meta property="article:modified_time" content="2019-02-03T09:44:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android 5.0 新特性和功能，系统和 API 行为变更</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Android_50_API__Android_LAPI_Level_21_0"></a>Android 5.0 API 变更（Android L、API Level 21）</h3> 
<h4><a id="_1"></a>用户界面</h4> 
<p>Material Design 支持</p> 
<p>Android 5.0 添加了对 Android 的新 Material Design 样式的支持。您可以创建具有 Material Design 功能的应用，实现动态视觉效果，利用其中的 UI 元素转换赋予用户自然的感觉。此支持包括：</p> 
<ul><li>Material Design 主题</li><li>视图阴影</li><li>RecyclerView 小部件</li><li>可绘制动画和造型效果</li><li>Material Design 动画和 Activity 转换效果</li><li>针对基于视图状态的视图属性的动画生成器</li><li>可自定义的 UI 小部件和具有可由您控制的调色板的应用栏</li><li>基于 XML 矢量图形的动画和非动画可绘制对象<br> 要详细了解如何为您的应用添加 Material Design 功能，请参阅 Material Design。</li></ul> 
<p>最近使用的应用屏幕中的并发文档和 Activity</p> 
<p>在之前的版本中，最近使用的应用屏幕只能为最近与用户交互过的每个应用显示一项任务。现在，您的应用可以根据需要为其他并发文档 Activity 打开更多任务。此功能简化了多任务处理，通过在所有应用中提供一致的切换体验，让用户能够在最近使用的应用屏幕中的各个 Activity 和文档之间快速切换。此类并行任务示例可能包括：网络浏览器应用中打开的标签页、效率类应用中的文档、游戏中的并行对局或信息应用中的聊天。您的应用可以通过 ActivityManager.AppTask 类管理它的任务。</p> 
<p>为插入逻辑换行符以便系统将您的 Activity 视为新任务，请在使用 startActivity() 启动 Activity 时使用 FLAG_ACTIVITY_NEW_DOCUMENT。您还可以通过在清单中将 元素的 documentLaunchMode 属性设置为 “intoExisting” 或 “always” 来获得此行为。</p> 
<p>为避免使最近使用的应用屏幕变得混乱，您可以在应用中设置该屏幕中可显示的任务数上限。要实现此目的，请设置 属性 android:maxRecents。目前可指定的上限为每位用户 50 个任务（RAM 较低设备为 25 个）。</p> 
<p>可将最近使用的应用屏幕中的任务设置为在重启后保留。要控制持久化行为，请使用 android:persistableMode 属性。您还可以通过调用 setTaskDescription() 方法，更改 Activity 在最近使用的应用屏幕中的视觉属性，如 Activity 的颜色、标签和图标。</p> 
<p>WebView 更新</p> 
<p>Android 5.0 将 WebView 实现更新至 Chromium M37，增强了安全性和稳定性，并修复了一些问题。运行在 Android 5.0 上的 WebView 的默认用户代理字符串已更新，以纳入 37.0.0.0 作为版本号。</p> 
<p>此版本引入了 PermissionRequest 类，让您的应用可以通过 getUserMedia() 等网络 API 授予 WebView 访问相机和麦克风之类受保护资源的权限。您的应用必须对这些资源拥有相应的 Android 权限，才能向 WebView 授予权限。</p> 
<p>借助新的 onShowFileChooser() 方法，您现在可以在 WebView 中使用输入表单字段，然后启动文件选择器从 Android 设备中选择图像和文件。</p> 
<p>此外，此版本还提供了对 WebAudio、WebGL 和 WebRTC 开放标准的支持。要详细了解此版本包含的新功能，请参阅 WebView for Android。</p> 
<p>屏幕采集和共享</p> 
<p>Android 5.0 引入了新的 android.media.projection API，让您可以为应用添加屏幕采集和屏幕共享功能。例如，如果您想在视频会议应用中启用屏幕共享，便可使用此功能。</p> 
<p>新增的 createVirtualDisplay() 方法允许您的应用将主屏幕（默认显示）的内容采集到一个 Surface 对象中，然后您的应用便可将其发送至整个网络。该 API 只允许采集非安全屏幕内容，不允许采集系统音频。要开始采集屏幕，您的应用必须先使用通过 createScreenCaptureIntent() 方法获得的 Intent 启动屏幕采集对话框，请求用户授予权限。</p> 
<p>如需查看新 API 使用方法的示例，请参阅示例项目中的 MediaProjectionDemo 类。</p> 
<h4><a id="_44"></a>通知</h4> 
<p>锁定屏幕通知</p> 
<p>Android 5.0 中的锁定屏幕可以显示通知。用户可以通过“Settings” 选择是否允许在安全的锁定屏幕上显示敏感的通知内容。</p> 
<p>您的应用可以控制在安全锁定屏幕上显示的通知中可见信息的详细程度。要控制可见性级别，请调用 setVisibility()，然后指定以下值之一：</p> 
<p>VISIBILITY_PRIVATE：显示通知图标等基本信息，但隐藏通知的完整内容。<br> VISIBILITY_PUBLIC：显示通知的完整内容。<br> VISIBILITY_SECRET：不显示任何内容，甚至不显示通知图标。<br> 当可视性级别为 VISIBILITY_PRIVATE 时，您还可以提供隐藏个人详情的删减版通知内容。例如，短信应用可能会显示一条通知，指出“您有3 条新短信”，但是隐藏了短信内容和发件人。要提供此替换版本的通知，请先使用 Notification.Builder 创建替换通知。创建专用通知对象时，请通过 setPublicVersion() 方法为其附加替换通知。</p> 
<p>通知元数据</p> 
<p>Android 5.0 使用与您的应用通知关联的元数据，以更智能的方式对通知排序。要设置元数据，请在构建通知时调用 Notification.Builder 中的下列方法：</p> 
<p>setCategory()：当设备处于“优先”模式时，指示系统如何处理应用通知（例如，通知代表来电、即时通讯还是闹铃）。<br> setPriority()：标记通知的重要性是高于还是低于普通通知。如果优先级字段设置为 PRIORITY_MAX 或PRIORITY_HIGH 的通知还有声音或振动，则会将其显示在小型浮动窗口中。<br> addPerson()：让您可以添加一名或多名与通知有关的人员。您的应用可以使用此名单指示系统将指定人员发出的通知归成一组，或者将这些人员发出的通知视为更重要的通知。</p> 
<h4><a id="_OpenGL_ES_31__65"></a>对 OpenGL ES 3.1 的支持</h4> 
<p>Android 5.0 添加了 Java 接口和对 OpenGLES 3.1 的原生支持。OpenGL ES 3.1 中提供的主要新功能包括：</p> 
<ul><li>计算着色器</li><li>单独的着色器对象</li><li>间接绘制命令</li><li>多重采样和模具纹理</li><li>着色语言改进</li><li>高级混合模式和调试专用扩展</li><li>向后兼容 OpenGL ES 2.0 和 3.0</li><li>Android 上 OpenGL ES 3.1 的 Java 接口随 GLES31 提供。使用 OpenGL ES 3.1 时，请务必在清单文件中使用 标记和 android:glEsVersion 属性对其进行声明。例如：</li></ul> ... 如需了解有关如何使用 OpenGL ES（包括如何在运行时检查设备支持的 OpenGL ES 版本）的详细信息，请参阅 OpenGL ES API 指南。 
<p>Android 扩展包</p> 
<p>除了 OpenGL ES 3.1 外，此版本还提供了一个扩展包，其中包括 Java 接口和对高级图形功能的原生支持。Android 将这些扩展视作单个软件包。（如果存在 ANDROID_extension_pack_es31a 扩展，您的应用可以假定扩展包中的所有扩展都存在，只需使用一条 #extension 语句便可启用着色语言功能。）</p> 
<p>该扩展包支持：</p> 
<p>有保证的着色器存储缓冲区、图像和原子 Fragment 着色器支持（在 OpenGL ES 3.1 中，Fragment 着色器支持为可选支持）。<br> 镶嵌和几何着色器<br> ASTC (LDR) 纹理压缩格式<br> 每采样内插和着色<br> 帧缓冲区中每个颜色附件采用不同混合模式<br> 该扩展包的 Java 接口随 GLES31Ext 提供。在您的应用清单中，您可以将应用声明为必须安装在支持该扩展包的设备上。例如：</p> ... 
<h4><a id="_103"></a>媒体</h4> 
<p>用于高级相机功能的 Camera API</p> 
<p>Android 5.0 引入了新的 android.hardware.camera2 API 来简化精细照片采集和图像处理。您现在可以使用 getCameraIdList() 通过编程方式访问可供系统使用的相机设备，以及使用 openCamera() 通过编程方式连接特定设备。要开始采集图像，请创建一个 CameraCaptureSession 并指定用于发送已采集图像的 Surface 对象。可将 CameraCaptureSession 配置为进行单张拍摄或多张连拍。</p> 
<p>要在采集新图像时得到通知，请实现 CameraCaptureSession.CaptureCallback 侦听器，并在您的采集请求中进行设置。现在，当系统完成图像采集请求时，您的 CameraCaptureSession.CaptureCallback 侦听器会收到对 onCaptureCompleted() 的调用，并在 CaptureResult 中为您提供图像采集元数据。</p> 
<p>CameraCharacteristics 类可让您的应用检测到设备上可用的相机功能。该对象的 INFO_SUPPORTED_HARDWARE_LEVEL 属性代表相机的功能级别。</p> 
<p>所有设备都至少支持 INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY 硬件级别，该级别具有的能力大致与弃用的 Camera API 相当。<br> 支持 INFO_SUPPORTED_HARDWARE_LEVEL_FULL 硬件级别的设备可手动控制采集和后期处理，以及以高帧速率采集高分辨率图像。<br> 要了解如何使用更新后的 Camera API，请参阅此版本中的 Camera2Basic 和 Camera2Video 实现示例。</p> 
<p>音频回放</p> 
<p>此版本加入了对 AudioTrack 的下列更改：</p> 
<p>您的应用现在可以提供浮点格式 (ENCODING_PCM_FLOAT) 的音频数据。这可以实现更大的动态范围、更一致的精度和更多的动态余量。浮点算法在进行中间计算时特别有用。回放端点为音频数据使用位深度更低的整型格式。（在Android 5.0中，部分内部管道尚未采用浮点格式。）<br> 您的应用现在可以提供音频数据作为 ByteBuffer，数据使用的格式与 MediaCodec 提供的格式相同。<br> WRITE_NON_BLOCKING 选项可简化某些应用的缓冲和多线程处理。<br> 媒体回放控制</p> 
<p>使用新增的通知和媒体 API 可确保系统 UI 了解您的媒体回放情况，并可提取和显示专辑封面。现在，可以利用新增的 MediaSession 类和 MediaController 类更轻松地在整个 UI 和服务范围内控制媒体回放。</p> 
<p>新增的 MediaSession 类替代了弃用的 RemoteControlClient 类，仅提供一套回调方法来处理传输控制和媒体按钮。如果您的应用提供媒体回放，并运行在 Android TV 或 Wear 平台上，请使用 MediaSession 类，通过同样的回调方法来处理您的传输控制。</p> 
<p>现在，您可以使用新增的 MediaController 类开发自己的媒体控制器应用。该类可通过您的应用的 UI 进程，以线程安全方式监控和控制媒体回放。请在创建控制器时指定一个 MediaSession.Token 对象，以便您的应用可与给定 MediaSession 交互。您可以利用 MediaController.TransportControls 方法，通过发送 play()、stop()、skipToNext() 和 setRating() 等命令来控制该会话上的媒体回放。对于控制器，您还可以注册一个 MediaController.Callback 对象来侦听该会话上的元数据和状态变化。</p> 
<p>此外，您还可以利用新增的 Notification.MediaStyle 类创建允许将回放控制与媒体会话绑定的丰富通知。</p> 
<p>媒体浏览</p> 
<p>Android 5.0 引入了通过新增的 android.media.browse API 让应用能够浏览其他应用媒体内容库的功能。要公开您应用内的媒体内容，请扩展 MediaBrowserService 类。您实现的 MediaBrowserService 应提供对 MediaSession.Token 的访问权限，以便应用能播放通过您的服务提供的媒体内容。</p> 
<p>要与媒体浏览器服务交互，请使用 MediaBrowser 类。在您创建 MediaBrowser 实例时为 MediaSession 指定组件名称。然后，您的应用便可利用该浏览器实例连接到关联的服务并获得 MediaSession.Token 对象，以播放通过该服务公开的内容。</p> 
<h4><a id="_140"></a>存储</h4> 
<p>目录选择</p> 
<p>Android 5.0 扩展了存储访问框架，允许用户选择整个目录子树，从而授予应用对所含全部文档的读/写权限，无需用户逐项确认。</p> 
<p>要选择目录子树，请生成并发送一个 OPEN_DOCUMENT_TREE intent。系统会显示所有支持子树选择的 DocumentsProvider 实例，并允许用户浏览和选择目录。返回的 URI 代表对所选子树的访问权限。然后，您就可以使用 buildChildDocumentsUriUsingTree() 和 buildDocumentUriUsingTree() 以及 query() 来探索子树。</p> 
<p>新增的 createDocument() 方法允许您在该子树下的任何位置新建文档或目录。要管理现有文档，请使用 renameDocument() 和 deleteDocument()。检查 COLUMN_FLAGS 以验证提供程序是否支持这些调用，然后再发出调用。</p> 
<p>如果您要实现 DocumentsProvider 并想支持子树选择，请实现 isChildDocument() 并在您的 COLUMN_FLAGS 中加入 FLAG_SUPPORTS_IS_CHILD。</p> 
<p>Android 5.0 还在共享的存储空间上引入了新的软件包专属目录，您的应用可在其中放置供加入到 MediaStore 中的媒体文件。新增的 getExternalMediaDirs() 返回所有共享存储设备上这些目录的路径。您的应用无需额外权限便可访问返回的路径，这与 getExternalFilesDir() 类似。平台会定期扫描这些目录中的新媒体，但您也可利用 MediaScannerConnection 显式扫描新内容。</p> 
<h4><a id="_154"></a>无线和连接</h4> 
<p>多个网络连接</p> 
<p>Android 5.0 提供了新的多网络 API，允许您的应用动态扫描具有特定能力的可用网络，并与它们建立连接。当您的应用需要 SUPL、彩信或运营商计费网络等专业化网络时，或者您想使用特定类型的传输协议发送数据时，就可以使用此功能。</p> 
<p>要从您的应用以动态方式选择并连接网络，请执行以下步骤：</p> 
<p>创建一个 ConnectivityManager。<br> 使用 NetworkRequest.Builder 类创建一个 NetworkRequest 对象，并指定您的应用感兴趣的网络功能和传输类型。<br> 要扫描合适的网络，请调用 requestNetwork() 或 registerNetworkCallback()，并传入 NetworkRequest 对象和 ConnectivityManager.NetworkCallback 的实现。如果您想在检测到合适的网络时主动切换到该网络，请使用 requestNetwork() 方法；如果只是接收已扫描网络的通知而不需要主动切换，请改用 registerNetworkCallback() 方法。<br> 当系统检测到合适的网络时，它会连接到该网络并调用 onAvailable() 回调。您可以使用回调中的 Network 对象来获取有关网络的更多信息，或者引导通信使用所选网络。</p> 
<p>蓝牙低功耗</p> 
<p>Android 4.3 为发挥核心作用的蓝牙低功耗（蓝牙 LE）引入了平台支持。在 Android 5.0 中，Android 设备现在可以发挥蓝牙 LE 外围设备的作用。应用可以利用此功能让附近设备发现它。例如，您可以开发这样的应用：让设备发挥计步器或健康监测仪的作用，并与其他蓝牙 LE 设备进行数据通信。</p> 
<p>新增的 android.bluetooth.le API 让您的应用可以发布广告、扫描响应以及与附近的蓝牙 LE 设备建立连接。要使用新增的广告和扫描功能，请在您的清单中添加 BLUETOOTH_ADMIN 权限。当用户更新您的应用或从 Play 商店下载您的应用时，会被要求向您的应用授予以下权限：“Bluetooth connection information:Allows the app to control Bluetooth, including broadcasting to or getting information about nearby Bluetooth devices.”</p> 
<p>要启动蓝牙 LE 广播，以便其他设备能发现您的应用，请调用 startAdvertising()，并传入 AdvertiseCallback 类的实现。回调对象会收到广播操作成功或失败的报告。</p> 
<p>Android 5.0 引入了 ScanFilter 类，让您的应用可以只扫描其感兴趣的特定类型设备。要开始扫描蓝牙 LE 设备，请调用 startScan()，并传入筛选器列表。在方法调用中，您还必须提供 ScanCallback 的实现，以便在发现蓝牙 LE 广播时进行报告。</p> 
<p>NFC 增强功能</p> 
<p>Android 5.0 添加这些增强功能是为了扩大 NFC 的使用范围和提高 NFC 的使用灵活性：</p> 
<p>Android Beam 现已出现在 share 菜单中。<br> 您的应用可通过调用 invokeBeam() 来调用用户设备上的 Android Beam 进行数据分享。这样一来，用户不必手动用设备接触另一台具有 NFC 功能的设备，便可完成数据传送。<br> 您可以使用新增的 createTextRecord() 方法来创建一条包含 UTF-8 文本数据的 NDEF 记录。<br> 如果您要开发支付应用，现在可以通过调用 registerAidsForService() 动态注册 NFC 应用 ID (AID)。您还可以使用 setPreferredService() 来设置应在特定 Activity 位于前台时使用的首选卡模拟服务。</p> 
<h4><a id="Volta__186"></a>Volta 项目</h4> 
<p>除了提供新功能外，Android 5.0 还重视电池寿命的改善。可以利用新增的 API 和工具来了解和优化您的应用的功耗。</p> 
<p>计划排定作业</p> 
<p>Android 5.0 新增了一个 JobScheduler API，允许您定义一些系统在稍后或指定条件下（如设备充电时）以异步方式运行的作业，从而优化电池寿命。下列情形下，作业计划排定功能很有用：</p> 
<p>应用具有不面向用户并且可以推迟的作业<br> 应用具有您更愿意在设备插入电源时再进行的作业<br> 应用具有一项需要接入网络或连接 WLAN 的任务。<br> 应用具有多项您希望定期以批处理方式运行的任务。<br> 一个作业单位由一个 JobInfo 对象封装。该对象指定计划排定标准。</p> 
<p>使用 JobInfo.Builder 类可配置应如何运行已排计划的任务。您可以安排任务在特定条件下运行，例如：</p> 
<p>在设备充电时启动<br> 在设备连入无限流量网络时启动<br> 在设备空闲时启动<br> 在特定期限前或以最低延迟完成<br> 例如，您可以添加一段如下代码，在无限流量网络上运行您的任务：</p> 
<p>JobInfo uploadTask = new JobInfo.Builder(mJobId,<br> mServiceComponent /* JobService component */)<br> .setRequiredNetworkCapabilities(JobInfo.NetworkType.UNMETERED)<br> .build();<br> JobScheduler jobScheduler =<br> (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);<br> jobScheduler.schedule(uploadTask);<br> 如果设备有稳定的电源（也就是说，设备已插入电源超过 2 分钟，并且电池处于健康水平），系统将运行任何已做好运行准备的计划作业，无论作业期限是否已过。</p> 
<p>要查看如何使用 JobScheduler API 的示例，请参阅此版本中的 JobSchedulerSample 实现示例。</p> 
<p>电池使用开发者工具</p> 
<p>新增的 dumpsys batterystats 命令可生成值得关注的设备电池使用情况统计数据，这些数据按唯一身份用户 ID (UID) 加以组织。统计数据包括：</p> 
<p>电池相关事件的历史记录<br> 设备的全局统计数据<br> 每个 UID 和系统组件的近似耗电情况<br> 每个应用的每数据包移动 ms<br> 系统 UID 汇总统计数据<br> 应用 UID 汇总统计数据<br> 可使用 --help 选项来了解各种输出定制选项的相关信息。例如，要打印设备上次充电后某个给定应用软件包的电池使用情况统计信息，请运行以下命令：</p> 
<p>$ adb shell dumpsys batterystats --charged <br> 您可以使用电池耗电历史工具对 dumpsys 命令输出的数据进行处理，根据日志生成用电相关事件的 HTML 可视化形式。这些信息可方便您了解和诊断任何电池相关问题。</p> 
<h4><a id="_Android_234"></a>工作场所和教育领域中的 Android</h4> 
<p>托管配置</p> 
<p>Android 5.0 提供了用于在企业环境内运行应用的新功能。如果用户已有个人帐户，则设备管理员可启动托管配置进程，向设备添加共存但独立的托管配置文件。与托管配置文件关联的应用与非托管应用一并出现在用户的启动器、最近使用的应用屏幕和通知中。</p> 
<p>要启动托管配置进程，请通过 Intent 发送 ACTION_PROVISION_MANAGED_PROFILE。如果调用成功，系统会触发 onProfileProvisioningComplete() 回调。然后您就可以调用 setProfileEnabled() 来启用此托管配置文件。</p> 
<p>默认情况下，托管配置文件中只启用了一小部分应用。您可以通过调用 enableSystemApp() 在托管配置文件中安装更多应用。</p> 
<p>如果您要开发启动器应用，可以使用新增的 LauncherApps 类获取可为当前用户启动的 Activity 以及任何关联托管配置文件的列表。您的启动器可通过向可绘制图标追加工作徽章，以醒目方式显示托管应用。要检索带徽章的图标，请调用 getUserBadgedIcon()。</p> 
<p>要查看如何使用新功能，请参阅此版本中的 BasicManagedProfile 实现示例。</p> 
<p>设备所有者</p> 
<p>Android 5.0 引入了部署设备所有者应用的功能。设备所有者是一种专业化类型的设备管理员，额外拥有在设备上创建和移除二级用户以及配置全局设置的能力。您的设备所有者应用可以使用 DevicePolicyManager 类中的方法对托管设备上的配置、安全性和应用进行精细控制。一台设备在同一时间只能有一名活动的设备所有者。</p> 
<p>要部署和激活设备所有者，您必须在设备处于未配置状态时执行从编程应用到设备的 NFC 数据传送。此数据传送发送的信息与托管配置中所述配置 intent 中发送的信息相同。</p> 
<p>固定屏幕</p> 
<p>Android 5.0 引入了一个全新的固定屏幕 API，可让您暂时限制用户离开您的任务或被通知打断。举例来说，如果您要开发一款教育应用来支持 Android 上的高风险评估要求，或者您要开发单一用途或信息亭模式下的应用，便可使用此 API。您的应用激活固定屏幕后，在其退出该模式前，用户将无法看到通知，无法访问其他应用，也无法返回主屏幕。</p> 
<p>激活固定屏幕的方式有两种：</p> 
<p>手动方式：用户可以在 Settings &gt; Security &gt; Screen Pinning 中启用固定屏幕，然后通过触摸最近使用的应用屏幕中的绿色大头针图标选择其想固定的任务。<br> 编程方式：要以编程方式激活固定屏幕，请在您的应用内调用 startLockTask()。如果请求应用不是设备所有者，系统会提示用户进行确认。设备所有者应用可以调用 setLockTaskPackages() 方法，无需执行用户确认步骤便可使应用变为可固定应用。<br> 激活任务锁定时，会发生以下行为：</p> 
<p>状态栏空白，并隐藏用户通知和状态信息。<br> “主屏幕”按钮和“最近用过的应用”按钮处于隐藏状态。<br> 其他应用无法启动新 Activity<br> 当前应用可以启动新 Activity，前提是这样做不会创建新任务。<br> 当设备所有者调用固定屏幕时，用户将一直锁定于您的应用，直至应用调用 stopLockTask()。<br> 如果固定屏幕是由并非设备所有者的其他应用启动的 Activity，或者是由用户直接启动，则用户可通过同时按住“Back”按钮和“Recent”按钮退出。</p> 
<h4><a id="_271"></a>打印框架</h4> 
<p>将 PDF 渲染成位图</p> 
<p>您现在可以利用新增的 PdfRenderer 类，将 PDF 文档页面渲染成位图图像后进行打印。您必须指定一个可查找（即内容可随机访问的） ParcelFileDescriptor，系统会在其上写入可打印内容。您的应用可通过 openPage() 获得要渲染的页面，然后调用 render() 将打开的 PdfRenderer.Page 转换成位图。如果您只想将文档的一部分转换成位图图像（例如，为了实现平铺渲染以便放大文档），还可以设置其他参数。</p> 
<p>要查看新 API 使用方法的示例，请参阅 PdfRendererBasic 示例。</p> 
<h4><a id="_280"></a>系统</h4> 
<p>应用使用情况统计信息</p> 
<p>现在可以利用新增的 android.app.usage API 访问 Android 设备上的应用使用历史记录。此 API 提供比已弃用的 getRecentTasks() 方法更为详细的使用信息。要使用此 API，您必须先在清单中声明 “android.permission.PACKAGE_USAGE_STATS” 权限。用户还必须通过 Settings &gt; Security &gt; Apps 为该应用启用访问使用情况的权限。</p> 
<p>系统以应用为单位收集使用数据，按天、周、月和年汇总数据。系统保留这些数据的最长持续时间如下：</p> 
<p>每日数据：7 天<br> 每周数据：4 周<br> 每月数据：6 个月<br> 每年数据：2 年<br> 系统会为每个应用记录以下数据：</p> 
<p>最后一次使用应用的时间<br> 在该时间间隔（以天、周、月或年为单位）内应用位于前台的总时长<br> 一天之中当组件（以软件包和 Activity 名称标识）转入前台或后台时记录的时间戳<br> 设备配置发生变化（如设备屏幕方向因旋转而发生变化）时记录的时间戳</p> 
<h4><a id="_299"></a>测试与辅助工具</h4> 
<p>测试与辅助工具改进</p> 
<p>Android 5.0 添加了以下测试与无障碍功能支持：</p> 
<p>新增的 getWindowAnimationFrameStats()和 getWindowContentFrameStats()方法可采集窗口动画和内容的帧统计信息。这些方法让您可以编写仪器测试，以评估应用渲染帧时的刷新频率是否足以提供流畅的用户体验。<br> 新增的 executeShellCommand() 方法让您可以在仪器测试中执行 shell 命令。命令的执行方式与从已连接到设备的主机运行 adb shell 类似，允许您使用 dumpsys、am、content 和 pm 等基于 shell 的工具。<br> 使用无障碍功能 API 的无障碍服务和测试工具（如 UiAutomator）现在可以检索视力健全的用户可与之交互的屏幕上各窗口属性的相关详细信息。要检索 AccessibilityWindowInfo 对象列表，请调用新增的 getWindows() 方法。<br> 新增的 AccessibilityNodeInfo.AccessibilityAction 类允许您定义要在 AccessibilityNodeInfo 上执行的标准或自定义操作。新增的 AccessibilityNodeInfo.AccessibilityAction 类取代了以前在 AccessibilityNodeInfo 中提供的与操作有关的 API。<br> Android 5.0 可对您应用内的文本语音转换合成进行更精细的控制。新增的 Voice 类允许您的应用使用关联了特定语言区域、质量和延时评级以及文本语音转换引擎专属参数的语音配置文件。</p> 
<h4><a id="IME_311"></a>IME</h4> 
<p>更方便的输入语言切换</p> 
<p>从 Android 5.0 开始，用户可以更方便地在平台支持的所有输入法编辑器 (IME) 之间切换。执行指定的切换操作（通常是触摸软键盘上的地球图标）可在所有此类 IME 中循环切换。此行为变更是由 shouldOfferSwitchingToNextInputMethod() 方法实现的。</p> 
<p>此外，框架现在会检查下一个 IME 是否具有切换机制（并进而检查该 IME 是否支持切换到其后的 IME）。具有切换机制的 IME 将不会循环切换到不具有该机制的 IME。此行为变更是由 switchToNextInputMethod() 方法实现的。</p> 
<p>要查看如何使用更新后的 IME 切换 API 的示例，请参阅此版本中更新后的软键盘实现示例。要详细了解如何实现 IME 切换，请参阅创建输入法。</p> 
<h4><a id="_321"></a>清单声明</h4> 
<p>可声明的必备功能</p> 
<p>现在支持在 元素中使用以下值，以便您确保只在提供应用所需功能的设备上安装您的应用。</p> 
<p>FEATURE_AUDIO_OUTPUT<br> FEATURE_CAMERA_CAPABILITY_MANUAL_POST_PROCESSING<br> FEATURE_CAMERA_CAPABILITY_MANUAL_SENSOR<br> FEATURE_CAMERA_CAPABILITY_RAW<br> FEATURE_CAMERA_LEVEL_FULL<br> FEATURE_GAMEPAD<br> FEATURE_LIVE_TV<br> FEATURE_MANAGED_USERS<br> FEATURE_LEANBACK<br> FEATURE_OPENGLES_EXTENSION_PACK<br> FEATURE_SECURELY_REMOVES_USERS<br> FEATURE_SENSOR_AMBIENT_TEMPERATURE<br> FEATURE_SENSOR_HEART_RATE_ECG<br> FEATURE_SENSOR_RELATIVE_HUMIDITY<br> FEATURE_VERIFIED_BOOT<br> FEATURE_WEBVIEW</p> 
<h4><a id="_344"></a>用户权限</h4> 
<p>现在， 元素中支持以下权限，以声明您的应用访问特定 API 所需的权限。</p> 
<p>BIND_DREAM_SERVICE：如果针对的是 API 级别 21 及更高级别，则互动屏保服务必须获得该权限才能确保只有系统可与其绑定。</p> 
<h3><a id="Android_51_API__Android_LAPI_Level_22_351"></a>Android 5.1 API 变更（Android L、API Level 22）</h3> 
<h4><a id="_SIM__353"></a>多 SIM 卡支持</h4> 
<p>Android 5.1 添加了对同时使用多个蜂窝运营商 SIM 卡的支持。有了此功能，用户可以在具有两个或多个 SIM 卡插槽的设备上激活和使用额外的 SIM。</p> 
<p>您可以通过 SubscriptionManager 类获取有关当前激活的 SIM 的信息，包括设备是否被认为在当前网络上漫游。对于希望为对数据访问费用敏感的设备用户减少或关闭应用数据访问的开发者而言，这些信息非常有用。可以通过请求 READ_PHONE_STATE 权限和对 SubscriptionManager 对象设置 SubscriptionManager.OnSubscriptionsChangedListener，提醒您的应用注意设备当前网络连接的状态变化。</p> 
<h4><a id="_HTTP__359"></a>已弃用的 HTTP 类</h4> 
<p>Android 5.1 中已弃用 org.apache.http 类和 android.net.http.AndroidHttpClient 类。这些类将不再保留，您应尽快将使用这些 API 的任何应用代码迁移至 URLConnection 类。</p> 
<h4><a id="_363"></a>运营商服务</h4> 
<p>Android 5.1 支持通信服务提供商创建可以在 Android 设备上执行运营商配置任务的应用。利用这些 API，运营商开发的应用可以安全、灵活地执行这些任务和通过 Google Play 发布。使用这些功能的应用必须获得证书的签名，此证书和设备的通用集成电路卡 (UICC) 中的证书相匹配。</p> 
<p>运营商服务 API 已添加到 TelephonyManager 类、SmsManager 类和新增的 CarrierMessagingService 类。应用可以通过调用 hasCarrierPrivileges() 方法，检查是否可以访问这些 API。可以调用但无法访问这些 API 的应用将收到 SecurityException。</p> 
<h3><a id="Android_50__369"></a>Android 5.0 系统行为变更</h3> 
<h4><a id="Android_RuntimeART_371"></a>Android Runtime（ART）</h4> 
<p>在 Android 5.0 中，ART 运行时取代 Dalvik 成为平台默认设置。Android 4.4 中已引入处于实验阶段的 ART 运行时。<br> 部分主要的新功能包括：</p> 
<ul><li>预先 (AOT) 编译</li><li>改进的垃圾回收 (GC)</li><li>改进的调试支持</li></ul> 
<p>大多数 Android 应用无需任何更改就可以在 ART 下工作。不过，部分适合 Dalvik 的技术并不适用于 ART。如需了解有关最重要问题的信息，请参阅在 Android Runtime (ART) 上验证应用行为。如存在以下情况，应特别注意：</p> 
<ul><li>您的应用使用 Java 原生接口 (JNI) 运行 C/C++ 代码。</li><li>您使用生成非标准代码的开发工具（例如，一些代码混淆工具）。</li><li>您使用与压缩垃圾回收不兼容的技术。</li></ul> 
<h4><a id="_383"></a>通知</h4> 
<p>Material Design 样式</p> 
<p>在白色（或非常浅）的背景上使用深色文本绘制通知，以便与新的 Material Design 小部件匹配。请确保您的所有通知都与新的配色方案协调一致。如果您的通知看上去不协调，请进行修正：</p> 
<p>使用 setColor() 在您的图标图像后面的圆形中设置重点色彩。<br> 更新或移除使用色彩的资源。系统在操作图标和主要通知图标中忽略所有非阿尔法通道。您应假设这些图标仅支持阿尔法通道。系统用白色绘制通知图标，用深灰色绘制操作图标。</p> 
<p>声音和振动</p> 
<p>如果您当前使用 Ringtone、MediaPlayer 或 Vibrator 类向通知中添加声音和振动，则移除此代码，以便系统可以在“优先”模式中正确显示通知。取而代之的是，使用 Notification.Builder 方法添加声音和振动。</p> 
<p>将设备设为 RINGER_MODE_SILENT 可使设备进入新的优先模式。如果您将设备设为 RINGER_MODE_NORMAL 或 RINGER_MODE_VIBRATE，则设备将退出优先模式。</p> 
<p>以前，Android 使用 STREAM_MUSIC 作为主流式传输来控制平板电脑设备上的音量。在 Android 5.0 中，手机和平板电脑设备的主音量流式传输现已合并，由 STREAM_RING 或 STREAM_NOTIFICATION 进行控制。</p> 
<p>锁定屏幕可见性</p> 
<p>默认情况下，在 Android 5.0 中，通知现在显示在用户的锁定屏幕上。用户可以选择保护敏感信息不被公开，在此情况下，系统会自动删减通知显示的文本。要自定义此删减的通知，请使用 setPublicVersion()。</p> 
<p>如果通知不包含个人信息，或者您想允许媒体播放控件显示在通知上，则调用 setVisibility() 方法并将通知的可见性级别设为 VISIBILITY_PUBLIC。</p> 
<p>媒体播放</p> 
<p>如果您要实现显示媒体播放状态或传输控件的通知，请考虑使用新的 Notification.MediaStyle 模板，而不是自定义 RemoteViews.RemoteView 对象。无论您选择使用哪个方法，请务必将通知的可见性设为 VISIBILITY_PUBLIC，以便可通过锁定屏幕访问您的控件。请注意，从 Android 5.0 开始，系统不再将 RemoteControlClient 对象显示在锁定屏幕上。如需了解详细信息，请参阅如果您的应用使用 RemoteControlClient。</p> 
<p>浮动通知</p> 
<p>现在，当设备处于活动状态时（即，设备未锁定且其屏幕已打开），通知可以显示在小型浮动窗口中（也称为“浮动通知”）。这些通知看上去类似于精简版的通知，只是浮动通知还显示操作按钮。用户可以在不离开当前应用的情况下处理或清除浮动通知。</p> 
<p>可能触发浮动通知的条件示例包括：</p> 
<p>用户的 Activity 处于全屏模式中（应用使用 fullScreenIntent）<br> 通知具有较高的优先级并使用铃声或振动<br> 如果您的应用在以上任何情形下实现通知，请确保系统正确显示浮动通知。</p> 
<p>媒体控件和 RemoteControlClient</p> 
<p>RemoteControlClient 类现已弃用。请尽快切换到新的 MediaSession API。</p> 
<p>Android 5.0 中的锁定屏幕不会为 MediaSession 或 RemoteControlClient 显示传输控件。不过，您的应用可以通过一个通知从锁定屏幕提供媒体播放控件。这让您的应用可以对媒体按钮的显示进行更多控制，同时为使用锁定设备和未锁定设备的用户提供一致的体验。</p> 
<p>为实现此目的，Android 5.0 引入了一个新的 Notification.MediaStyle 模板。Notification.MediaStyle 将您使用 Notification.Builder.addAction() 添加的通知操作转换为精简按钮，嵌入到应用的媒体播放通知中。将您的会话令牌传递到 setSession() 方法以告知系统该通知控制进行中的媒体会话。</p> 
<p>请务必将通知的可见性设为 VISIBILITY_PUBLIC，以将通知标记为安全，从而显示在任何锁定屏幕上（以安全方式或其他方式）。如需了解详细信息，请参阅锁定屏幕通知。</p> 
<p>要让应用在 Android TV 或 Wear 平台上运行时显示媒体播放控件，则实现 MediaSession 类。如果您的应用需要在 Android 设备上接收媒体按钮事件，您还应实现 MediaSession。</p> 
<h4><a id="getRecentTasks_431"></a>getRecentTasks()</h4> 
<p>Android 5.0 中引入新的“并发文档和 Activity 任务”功能后（请参阅下文最近使用的应用屏幕中的并发文档和 Activity），为提升用户隐私的安全性，现已弃用 ActivityManager.getRecentTasks() 方法。对于向后兼容性，此方法仍会返回它的一小部分数据，包括调用应用自己的任务和可能的一些其他非敏感任务（如首页）。如果您的应用使用此方法检索它自己的任务，则改用 getAppTasks() 检索该信息。</p> 
<h4><a id="Android_NDK__64__435"></a>Android NDK 中的 64 位支持</h4> 
<p>Android 5.0 引入了对 64 位系统的支持。64 位增强功能可增加地址空间和提升性能，同时仍完全支持现有的 32 位应用。64 位支持也可改进用于加密的 OpenSSL 的性能。此外，该版本还引入了新的原生媒体 NDK API，以及原生 OpenGL ES (GLES) 3.1 支持。</p> 
<h4><a id="_439"></a>绑定到服务</h4> 
<p>Context.bindService() 方法现在需要显式 Intent，如果提供隐式 intent，将引发异常。为确保应用的安全性，请使用显式 intent 启动或绑定 Service，且不要为服务声明 intent 过滤器。</p> 
<h4><a id="WebView_443"></a>WebView</h4> 
<p>Android 5.0 更改了应用的默认行为。</p> 
<p>如果您的应用是面向 API 级别 21 或更高级别：<br> 默认情况下，系统会阻止混合内容和第三方 Cookie。要允许混合内容和第三方 Cookie，请分别使用 setMixedContentMode() 和 setAcceptThirdPartyCookies() 方法。<br> 系统现在可以智能地选择要绘制的 HTML 文档部分。这个新的默认行为有助于减少内存占用和提升性能。如果您要一次渲染整个文档，可通过调用 enableSlowWholeDocumentDraw() 停用此优化。<br> 如果您的应用是面向低于 21 的 API 级别：系统允许混合内容和第三方 Cookie，并始终一次渲染整个文档。</p> 
<h4><a id="_452"></a>自定义权限唯一性要求</h4> 
<p>根据权限概述中所述，Android 应用可以定义以专有方式管理组件访问权限的自定义权限，无需使用平台预定义的系统权限。应用在其清单文件中声明的 元素中定义自定义权限。</p> 
<p>少数情况下定义自定义权限是合规且安全的方法。不过，创建自定义权限有时并无必要，甚至可能会给应用带来潜在风险，具体取决于分配给权限的保护级别。</p> 
<p>Android 5.0 其中一项行为变更确保只有一个应用可以定义给定自定义权限，除非使用与定义权限的其他应用相同的密钥进行签名。</p> 
<h4><a id="_460"></a>您的应用需要注意的事项</h4> 
<p>在 Android 5.0 和更新的版本中，应用可以和以前一样继续定义自己的自定义权限，并通过 机制请求其他应用的自定义权限。不过，对于 Android 5.0 中引入的新要求，您应仔细评估可能给您的应用带来的影响。</p> 
<p>下面是一些需要考虑的因素：</p> 
<p>您的应用是否在其清单文件中声明任何 元素？如果是，那么这些权限是否确实是您的应用或服务正常运行不可或缺的？或者，能否使用系统默认权限代替它们？<br> 如果您的应用中具有 元素，您是否知道它们来自哪里？<br> 您实际上是否打算让其他应用通过 请求您的自定义权限？<br> 您是否在您包含 元素的应用中使用样板文件或示例代码？那些权限元素确实是不可或缺的吗？<br> 您的自定义权限使用的名称是简单名称还是基于其他应用可能共享的通用术语？<br> 新安装和更新</p> 
<p>如上所述，在运行 Android 4.4 或更早版本的设备上新安装和更新您的应用不会受影响，且行为没有任何变化。在运行 Android 5.0 或更新版本的设备上进行新安装和更新时，如果应用定义一个已由现有驻留应用定义的自定义权限，则系统会阻止安装您的应用。</p> 
<p>使用 Android 5.0 系统更新的现有安装</p> 
<p>如果您的应用使用自定义更新且已广泛分发和安装，那么，当用户收到将设备升级到 Android 5.0 的更新时，您的应用可能会受影响。在安装系统更新后，系统重新验证已安装的应用，包括检查它们的自定义权限。如果您的应用定义一个已由另一个通过验证的应用定义的自定义权限，且您的应用没有使用与该应用相同的密钥签名，则系统不会重新安装您的应用。</p> 
<p>建议</p> 
<p>在运行 Android 5.0 或更新版本的设备上，我们建议您立即检查您的应用，进行任何所需的调整，并尽快向您的用户发布更新版本。</p> 
<p>如果您在应用中使用自定义权限，则考虑它们的来源以及您是否确实需要它们。从您的应用中移除所有 元素，除非您确定它们是应用正常运行所必需的元素。<br> 尽可能考虑使用系统默认权限替代您的自定义权限。<br> 如果您的应用需要自定义权限，则重命名您的自定义权限，使其成为您的应用独有的权限，例如，将它们追加到应用的完整软件包名称。<br> 如果您有一组使用不同密钥签名的应用，且这些应用通过自定义权限访问共享组件，则确保此自定义权限在共享组件中仅定义一次。使用共享组件的应用不应自己定义自定义权限，而应通过 机制请求访问权限。<br> 如果您有一组使用相同密钥签名的应用，则每个应用都可以根据需要定义相同的 自定义权限， 系统允许以常规方式安装这些应用。</p> 
<h4><a id="TLSSSL__489"></a>TLS/SSL 默认配置变更</h4> 
<p>Android 5.0 针对 HTTPS 和其他 TLS/SSL 通信引入了对应用使用的默认 TLS/SSL 配置的变更：</p> 
<p>TLSv1.2 和 TLSv1.1 协议现已启用，<br> AES-GCM (AEAD) 加密套件现已启用，<br> MD5、3DES、导出和静态密钥 ECDH 加密套件现已停用，<br> 首选使用 Forward Secrecy 加密套件（ECDHE 和 DHE）。<br> 在下面列出的少数情况下，这些变更可能会导致 HTTPS 或 TLS/SSL 连接断开。</p> 
<p>请注意，来自 Google Play 服务的安全性 ProviderInstaller 自 Android 2.3 开始就已在 Android 平台版本上提供这些变更。</p> 
<p>服务器不支持任何已启用的加密套件</p> 
<p>例如，服务器可能仅支持 3DES 或 MD5 加密套件。首选的修复方法是改进服务器的配置，以启用更强更现代的加密套件和协议。理想情况下，应启用 TLSv1.2 和 AES-GCM 以及 Forward Secrecy 加密套件（ECDHE、DHE），且最好使用后者。</p> 
<p>也可以修改应用以使用自定义 SSLSocketFactory 与服务器通信。出厂时应精心设计以创建 SSLSocket 实例，除默认加密套件外，此实例还应启用服务器所需的部分加密套件。</p> 
<p>应用对用于连接服务器的加密套件做出错误的假设</p> 
<p>例如，某些应用包含中断的自定义 X509TrustManager，因为它预计 authType 参数将成为 RSA，但出现了 ECDHE_RSA 或 DHE_RSA。</p> 
<p>服务器不支持 TLSv1.1、TLSv1.2 或新的 TLS 扩展</p> 
<p>例如，与服务器握手的 TLS/SSL 被错误地拒绝或出现停顿。首选的修复方法是升级服务器以符合 TLS/SSL 协议。这使服务器可以成功地协商这些更新的协议或协商 TLSv1 或更早的协议，并忽略它不理解的传输层安全协议扩展程序。在某些情况下，在服务器上禁用 TLSv1.1 和 TLSv1.2 可以作为权宜之计，直到升级服务器软件。</p> 
<p>也可以修改应用以使用自定义 SSLSocketFactory 与服务器通信。出厂时应精心设计以创建 SSLSocket 实例，该实例仅包含已启用且服务器可以正确为其提供支持的协议。</p> 
<h4><a id="_517"></a>支持托管配置文件</h4> 
<p>设备管理员可以向设备添加托管配置文件。此配置文件由管理员所有，让管理员控制托管配置文件的同时，允许由用户控制其自己的个人配置文件及其存储空间。此变更会通过下列方式影响您的现有应用的行为。</p> 
<h4><a id="_Intent_521"></a>处理 Intent</h4> 
<p>设备管理员可以从托管配置文件限制对系统应用的访问权限。在此情况下，如果应用从托管文件触发一个通常由该应用处理的 intent，且托管文件上没有适合此 intent 的处理程序，则此 intent 会引发异常。例如，设备管理员可以限制托管配置文件上的应用访问系统的相机应用。如果您的应用在托管配置文件上运行，并为 MediaStore.ACTION_IMAGE_CAPTURE 调用 startActivityForResult()，且托管配置文件上没有可以处理此 intent 的应用，则会导致 ActivityNotFoundException。</p> 
<p>为防止出现此情况，您可以在触发任何 intent 之前检查是否至少有一个适合此 intent 的处理程序。要检查是否存在有效的处理程序，请调用 Intent.resolveActivity()。您可以在轻松拍照：使用相机应用拍摄照片中查看执行上述操作的示例。</p> 
<h4><a id="_527"></a>在各个配置文件中共享文件</h4> 
<p>每个配置文件都有自己的文件存储空间。文件 URI 指的是文件存储空间中的特定位置，这意味着在一个配置文件上有效的文件 URI 在另一个文件上是无效的。对于只访问自己创建的文件的应用而言，这通常不是什么问题。不过，如果应用向某个 intent 附加文件，则附加文件 URI 并不安全，因为在某些情况下，可能会在其他配置文件上处理该 intent。例如，设备管理员可能会指定图像采集事件应由个人配置文件上的相机应用处理。如果此 intent 由托管配置文件上的应用触发，则相机需要能够将图像写入托管配置文件的应用可以读取的位置。</p> 
<p>为安全起见，如果您需要将文件附加到某个可能会从一个配置文件移动到另一个配置文件的 intent，您应为该文件创建并使用内容 URI。有关共享文件及内容 URI 的更多信息，请参阅共享文件。例如，设备管理员可能会制定将由个人配置文件中的相机处理的 ACTION_IMAGE_CAPTURE 白名单。触发的 intent 的 EXTRA_OUTPUT 应包含指定照片应存储在何处的内容 URI。相机应用可以将图像写入该 URI 指定的位置，触发 intent 的应用将能够读取该文件，即使应用位于其他配置文件上。</p> 
<h4><a id="_533"></a>已移除锁定屏幕小部件支持</h4> 
<p>Android 5.0 移除了对锁定屏幕小部件的支持；它继续为主屏幕上的小组件提供支持。</p> 
<p>文章转载自 <a href="https://developer.android.com/about/versions/android-5.0-changes?hl=zh-cn" rel="nofollow">https://developer.android.com/about/versions/android-5.0-changes?hl=zh-cn</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c653b7239b626a4b8ca18b1c5ac92eb3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">约瑟夫问题(c&#43;&#43;)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8d01ce931aa62feb4ae89135ace16a9e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用Jquery向一个空白网页动态创建一个iframe 及嵌入页面 和向嵌入页面传参</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>