<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Linux网络（C&#43;&#43;)】——网络套接字（TCP/UDP编程模型）多进程，多线程，线程池服务器开发（画图解析） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Linux网络（C&#43;&#43;)】——网络套接字（TCP/UDP编程模型）多进程，多线程，线程池服务器开发（画图解析）" />
<meta property="og:description" content="目录
一. 套接字基本概念
📚 IP地址
📚 TCP和UDP协议 📚 端口号
📚 端口号vs 进程pid
📚 网络字节序
本地字节序转换成网络字节序
网络字节序转换为本地字节序
二. 套接字的基本操作
📚 socket的创建
域(domain)
类型（type）
协议（Protcol）
返回值
📚 struct socketaddr地址结构
struct sockaddr 结构
struct sockaddr_in 结构
📚 socket绑定地址（bind函数）
📚 Socket监听连接（listen函数）
📚 Socket请求连接(connect函数）
📚 Socket接受连接（accept函数）
📚 Socket接受数据 （recvfrom函数）
📚 Socket发送数据（sendto函数）
📚 Socket关闭
三. UDP编程模型
四. Tcp编程模型
多进程服务器
多线程服务器
线程池服务器
五. netstate命令
一. 套接字基本概念 所谓套接字(Socket)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象，一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制
📚 IP地址 IP地址是在IP协议中，主要功能是用来标识网络上不同主机的地址。
IP地址是由32位组成，主要由三部分：地址类别，网络号和主机号：
📚 TCP和UDP协议 TCP/IP协议传输层使用最广泛的两个协议分别是TCP协议和UDP协议，UDP套接口是数据报套接字的一种，而TCP套接口是字节流套接字的一种。
TCP/IP协议传输层的 主要任务是向位于不同的（有时候位于同一主机）上的应用程序提供端到端的通信服务，为了区分应用程序，TCP和UDP引入了端口号的概念，端口本质是一个16位的整数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/effb39ab3bc3f8f518e666d4b236cd27/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-22T11:24:29+08:00" />
<meta property="article:modified_time" content="2022-02-22T11:24:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Linux网络（C&#43;&#43;)】——网络套接字（TCP/UDP编程模型）多进程，多线程，线程池服务器开发（画图解析）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">一. 套接字基本概念</a></p> 
<p id="%C2%A0IP%E5%9C%B0%E5%9D%80-toc" style="margin-left:40px;"><a href="#%C2%A0IP%E5%9C%B0%E5%9D%80" rel="nofollow">📚  IP地址</a></p> 
<p id="TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE%C2%A0-toc" style="margin-left:40px;"><a href="#TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE%C2%A0" rel="nofollow">📚 TCP和UDP协议 </a></p> 
<p id="%E7%AB%AF%E5%8F%A3%E5%8F%B7-toc" style="margin-left:40px;"><a href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7" rel="nofollow">📚 端口号</a></p> 
<p id="%E7%AB%AF%E5%8F%A3%E5%8F%B7vs%20%E8%BF%9B%E7%A8%8Bpid-toc" style="margin-left:40px;"><a href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7vs%20%E8%BF%9B%E7%A8%8Bpid" rel="nofollow"> 📚 端口号vs 进程pid</a></p> 
<p id="%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F" rel="nofollow">📚 网络字节序</a></p> 
<p id="%E6%9C%AC%E5%9C%B0%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F-toc" style="margin-left:80px;"><a href="#%E6%9C%AC%E5%9C%B0%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F" rel="nofollow">本地字节序转换成网络字节序</a></p> 
<p id="%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9C%AC%E5%9C%B0%E5%AD%97%E8%8A%82%E5%BA%8F-toc" style="margin-left:80px;"><a href="#%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9C%AC%E5%9C%B0%E5%AD%97%E8%8A%82%E5%BA%8F" rel="nofollow">网络字节序转换为本地字节序</a></p> 
<p id="%E4%BA%8C.%20%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%20%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" rel="nofollow">二. 套接字的基本操作</a></p> 
<p id="socket%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:40px;"><a href="#socket%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">📚 socket的创建</a></p> 
<p id="%E5%9F%9F(domain)-toc" style="margin-left:80px;"><a href="#%E5%9F%9F%28domain%29" rel="nofollow">域(domain)</a></p> 
<p id="%E7%B1%BB%E5%9E%8B%EF%BC%88type%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E7%B1%BB%E5%9E%8B%EF%BC%88type%EF%BC%89" rel="nofollow">类型（type）</a></p> 
<p id="%C2%A0%E5%8D%8F%E8%AE%AE%EF%BC%88Protcol%EF%BC%89-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%8D%8F%E8%AE%AE%EF%BC%88Protcol%EF%BC%89" rel="nofollow"> 协议（Protcol）</a></p> 
<p id="%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:80px;"><a href="#%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow">返回值</a></p> 
<p id="struct%20socketaddr%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#struct%20socketaddr%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84" rel="nofollow">📚 struct socketaddr地址结构</a></p> 
<p id="struct%20sockaddr%C2%A0%20%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#struct%20sockaddr%C2%A0%20%E7%BB%93%E6%9E%84" rel="nofollow">struct sockaddr  结构</a></p> 
<p id="%C2%A0struct%20sockaddr_in%20%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#%C2%A0struct%20sockaddr_in%20%E7%BB%93%E6%9E%84" rel="nofollow"> struct sockaddr_in 结构</a></p> 
<p id="socket%E7%BB%91%E5%AE%9A%E5%9C%B0%E5%9D%80%EF%BC%88bind%E5%87%BD%E6%95%B0%EF%BC%89-toc" style="margin-left:40px;"><a href="#socket%E7%BB%91%E5%AE%9A%E5%9C%B0%E5%9D%80%EF%BC%88bind%E5%87%BD%E6%95%B0%EF%BC%89" rel="nofollow">📚 socket绑定地址（bind函数）</a></p> 
<p id="Socket%E7%9B%91%E5%90%AC%E8%BF%9E%E6%8E%A5%EF%BC%88listen%E5%87%BD%E6%95%B0%EF%BC%89-toc" style="margin-left:40px;"><a href="#Socket%E7%9B%91%E5%90%AC%E8%BF%9E%E6%8E%A5%EF%BC%88listen%E5%87%BD%E6%95%B0%EF%BC%89" rel="nofollow">📚 Socket监听连接（listen函数）</a></p> 
<p id="Socket%E8%AF%B7%E6%B1%82%E8%BF%9E%E6%8E%A5(connect%E5%87%BD%E6%95%B0%EF%BC%89-toc" style="margin-left:40px;"><a href="#Socket%E8%AF%B7%E6%B1%82%E8%BF%9E%E6%8E%A5%28connect%E5%87%BD%E6%95%B0%EF%BC%89" rel="nofollow"> 📚 Socket请求连接(connect函数）</a></p> 
<p id="Socket%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5%EF%BC%88accept%E5%87%BD%E6%95%B0%EF%BC%89-toc" style="margin-left:40px;"><a href="#Socket%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5%EF%BC%88accept%E5%87%BD%E6%95%B0%EF%BC%89" rel="nofollow">📚 Socket接受连接（accept函数）</a></p> 
<p id="Socket%E6%8E%A5%E5%8F%97%E6%95%B0%E6%8D%AE%20%EF%BC%88recvfrom%E5%87%BD%E6%95%B0%EF%BC%89-toc" style="margin-left:40px;"><a href="#Socket%E6%8E%A5%E5%8F%97%E6%95%B0%E6%8D%AE%20%EF%BC%88recvfrom%E5%87%BD%E6%95%B0%EF%BC%89" rel="nofollow">📚 Socket接受数据 （recvfrom函数）</a></p> 
<p id="Socket%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%EF%BC%88sendto%E5%87%BD%E6%95%B0%EF%BC%89-toc" style="margin-left:40px;"><a href="#Socket%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%EF%BC%88sendto%E5%87%BD%E6%95%B0%EF%BC%89" rel="nofollow">📚 Socket发送数据（sendto函数）</a></p> 
<p id="Socket%E5%85%B3%E9%97%AD-toc" style="margin-left:40px;"><a href="#Socket%E5%85%B3%E9%97%AD" rel="nofollow">📚 Socket关闭</a></p> 
<p id="UDP%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B-toc" style="margin-left:0px;"><a href="#UDP%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B" rel="nofollow">三. UDP编程模型</a></p> 
<p id="Tcp%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:0px;"><a href="#Tcp%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow">四. Tcp编程模型</a></p> 
<p id="%C2%A0%E5%A4%9A%E8%BF%9B%E7%A8%8Btcp%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%A4%9A%E8%BF%9B%E7%A8%8Btcp%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow"> 多进程服务器</a></p> 
<p id="%C2%A0%E5%A4%9A%E7%BA%BF%E7%A8%8Btcp%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%A4%9A%E7%BA%BF%E7%A8%8Btcp%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow"> 多线程服务器</a></p> 
<p id="%E7%BA%BF%E7%A8%8B%E6%B1%A0Tcp%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0Tcp%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow">线程池服务器</a></p> 
<p id="netstate%E5%91%BD%E4%BB%A4-toc" style="margin-left:0px;"><a href="#netstate%E5%91%BD%E4%BB%A4" rel="nofollow">五. netstate命令</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">一. 套接字基本概念</h2> 
<p></p> 
<blockquote> 
 <p>所谓套接字(Socket)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象，一个套接字就是网络上<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=60847&amp;ss_c=ssc.citiao.link" rel="nofollow" title="进程通信">进程通信</a>的一端，提供了<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=16954&amp;ss_c=ssc.citiao.link" rel="nofollow" title="应用层">应用层</a>进程利用网络协议交换数据的机制</p> 
</blockquote> 
<h3 id="%C2%A0IP%E5%9C%B0%E5%9D%80"><strong>📚 </strong> IP地址</h3> 
<p>IP地址是在IP协议中，主要功能是用来标识网络上不同主机的地址。</p> 
<p>IP地址是由32位组成，主要由三部分：地址类别，网络号和主机号：</p> 
<p><img alt="" height="130" src="https://images2.imgbox.com/48/e5/vVD47uEW_o.png" width="732"></p> 
<h3 id="TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE%C2%A0"><strong>📚 </strong>TCP和UDP协议 </h3> 
<p>TCP/IP协议传输层使用最广泛的两个协议分别是TCP协议和UDP协议，UDP套接口是数据报套接字的一种，而TCP套接口是字节流套接字的一种。</p> 
<p>TCP/IP协议传输层的 主要任务是向位于不同的（有时候位于同一主机）上的应用程序提供端到端的通信服务，为了区分应用程序，TCP和UDP引入了端口号的概念，端口本质是一个16位的整数</p> 
<h3 id="%E7%AB%AF%E5%8F%A3%E5%8F%B7"><strong>📚 </strong>端口号</h3> 
<p>端口号（port）是传输层协议的内容</p> 
<ul><li>是一个<strong>2字节的16位整数</strong>。</li><li>端口号是用来表示进程的，告诉操作系统，当前的数据要交给哪一个进程处理</li><li><strong>ip地址+端口号能够标识网络上一台主机上的一个进程。</strong></li><li>一个端口号只能标识一个进程</li></ul> 
<p>任何的网络服务与网络客户端，如果要进行正常的数据通信，必须使用端口号，来唯一标识进程。</p> 
<p>公网ip：唯一的标识全网唯一的一台主机</p> 
<p>socket通信，本质是进程间通信，跨网络的进程进通信。</p> 
<h3 id="%E7%AB%AF%E5%8F%A3%E5%8F%B7vs%20%E8%BF%9B%E7%A8%8Bpid"> <strong>📚 </strong>端口号vs 进程pid</h3> 
<p>在linux操作系统内，进程pid也是唯一标识进程，端口号跟进程pid之间有什么区别？举个例子：<br> 在国家的社会中，每个人都有一个身份证号用来唯一标识一个人，在大学中，每个学生都有一个学生号来唯一标识一个学生，为什么学校不用身份证号来唯一区分一个学生呢？因为使用身份证号的人数多，有14亿左右，并不是每个人都在这个大学中读书，而一个大学中只有几千个人，那么为了能够方便管理和查找，学校再使用一个学号来唯一标识学校中学生的身份。</p> 
<p>而进程pid就好比进程的身份证号，而端口号就好比学号，在一台机器上，假设有50个进程在运行，但是只有5个进程进行网络通信，这时候我们只要给这5个进程分配端口号即可。</p> 
<h3 id="%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><strong>📚 </strong>网络字节序</h3> 
<p>   由于<strong>不同计算机系统采用不同的字节序存储数据</strong>，同样一个4字节的32位整数在内存中存储的方式是不同的，这称为本地字节序。字节序列分为大端字节序和小端字节序，Intel处理器大多使用大端字节序，Motoro大多使用小端字节序。小端字节序是指低位字节存放内存的低地址处，大端字节序指的是高位字节存储在内存的低地址处。</p> 
<p>     如果进程只在单机环境下运行，并且不和其他进程打交道，我们完全可以忽略字节序的存在，但是，如果进程需要跟其他计算机上的进程进行交换，我们必须考虑字节序的问题。</p> 
<p>    1的字节序分别在大端机器和小端机器存储情况，如果大端机器将内存中的数据通过网络传给小端机器，那么小端机器从网络获得的数据放进内存中的数据是相反的。这就是网络字节序问题。</p> 
<p><img alt="" height="452" src="https://images2.imgbox.com/07/5d/So1yAnu2_o.png" width="874"></p> 
<p>      TCP/IP协议进行网络数据传输时，规定一种数据表示格式，它与具体的cpu和操作系统无关，保证了数据在不同主机传输时能够被正确解释，这就是网络字节序，<strong>网络字节序统一采用大端字节序。 </strong></p> 
<p>因此，当两台机器进行通信时，必须先将本地字节序转换为网络字节序转化为网络字节序在进行发送，当收到数据之后，应当将网络字节序转化为本地字节序再进行后续使用。</p> 
<h4 id="%E6%9C%AC%E5%9C%B0%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F">本地字节序转换成网络字节序</h4> 
<pre><code class="language-cpp">       #include &lt;arpa/inet.h&gt;

       //将32位的整型数据从本地转换为网络字节序
       uint32_t htonl(uint32_t hostlong);
       //将16位的整形数据从本地转换为网络字节序
       uint16_t htons(uint16_t hostshort);

</code></pre> 
<h4 id="%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9C%AC%E5%9C%B0%E5%AD%97%E8%8A%82%E5%BA%8F">网络字节序转换为本地字节序</h4> 
<pre><code class="language-cpp">       #include &lt;arpa/inet.h&gt;

       //将32位的整形网络序列转换为本地序列
       uint32_t ntohl(uint32_t netlong);
       //将16位的整形网络序列转换为本地序列
       uint16_t ntohs(uint16_t netshort);
</code></pre> 
<h2 id="%E4%BA%8C.%20%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">二. 套接字的基本操作</h2> 
<h3 id="socket%E7%9A%84%E5%88%9B%E5%BB%BA"><strong>📚 </strong>socket的创建</h3> 
<pre><code class="language-cpp">       #include &lt;sys/types.h&gt;          /* See NOTES */
       #include &lt;sys/socket.h&gt;

       int socket(int domain, int type, int protocol);
</code></pre> 
<h4 id="%E5%9F%9F(domain)">域(domain)</h4> 
<p>域指定了Socket编成模型的地址族，其类型为int,常见的取值如下表所示：<br><img alt="" height="478" src="https://images2.imgbox.com/62/ea/0O0fcj61_o.png" width="715"></p> 
<p> 网络编程中最常用的socket域取值是AF_INET和AF_INET6协议，其中AF_INET6协议是下一代互联网的协议，客服目前IPv4存在可用地址有限的问题，但AF_INET6协议还没有被实际运用，在写代码时一般使用AF_INET.</p> 
<h4 id="%E7%B1%BB%E5%9E%8B%EF%BC%88type%EF%BC%89"><br> 类型（type）</h4> 
<p>类型主要指定了通信双方的<strong>数据传输格式</strong>，比较常见的数据格式类型有三种:</p> 
<p><img alt="" height="433" src="https://images2.imgbox.com/c9/b7/DkPv4TJc_o.png" width="871"></p> 
<p></p> 
<h4 id="%C2%A0%E5%8D%8F%E8%AE%AE%EF%BC%88Protcol%EF%BC%89"> 协议（Protcol）</h4> 
<p>协议主要指通信双方的约定，如<strong>TCP协议</strong>和<strong>UDP协议</strong>，但正常情况下，当<strong>双方的域（domain）和通信数据类型（type）</strong>确定以后，协议就会被唯一确定l，传0表示根据domain和type类型推出协议。所以该<strong>参数一般传0即可</strong>。</p> 
<h4 id="%E8%BF%94%E5%9B%9E%E5%80%BC"><strong>返回值</strong></h4> 
<p>函数socket()的返回值是一个文件描述符。套接字的建立本质是一个进程在内存中打开一个文件，并且这个文件中的数据与网卡互相连接，然后将打开的文件描述符返回给进程，然后进程可以对这个文件可以进行读写数据。</p> 
<p>成功返回一个文件描述符（socket描述符），失败返回-1，同时errno被设置成相应的值。</p> 
<p></p> 
<p><img alt="" height="670" src="https://images2.imgbox.com/28/90/vK76PVJL_o.png" width="1200"></p> 
<p><strong> 创建socket本质是一个进程在内存中打开一个文件缓冲区</strong>，然后这个文件缓冲区与网卡进行数据交互。</p> 
<h3 id="struct%20socketaddr%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><strong>📚 </strong>struct socketaddr地址结构</h3> 
<p>在各种底层网络协议中，如IPv4和IPv6,以及UNIX DOMAIN socket,这些底层网络协议地址格式不同，所以为了兼容这些底层网络协议，Socket API定义了一个通用的struct socketaddr，这使得不同的地址结构可以被bind(),connect,revfrom,sendto()等函数调用。</p> 
<h4 id="struct%20sockaddr%C2%A0%20%E7%BB%93%E6%9E%84">struct sockaddr  结构</h4> 
<pre><code class="language-cpp">          struct sockaddr {
               sa_family_t sa_family; //地址族 16位
               char        sa_data[14]; //14个字节，包括目标地址和端口号
           }
</code></pre> 
<h4 id="%C2%A0struct%20sockaddr_in%20%E7%BB%93%E6%9E%84"> struct sockaddr_in 结构</h4> 
<pre><code class="language-cpp">struct sockaddr_in {    
  __kernel_sa_family_t  sin_family;   // 地址族 16位
  __be16    sin_port;    //端口号，16位,可以看成一个int类型
  struct in_addr  sin_addr;  //ip地址 32位
    
   //填充信息，一般不需要管
  unsigned char   __pad[__SOCK_SIZE__ - sizeof(short int) -    
      sizeof(unsigned short int) - sizeof(struct in_addr)];    
};  

//以整数的形式指定套接字的网络地址
struct in_addr {
  __be32  s_addr; //存放32位ip地址
};
</code></pre> 
<p>IPv4地址使用sockaddr_in结构体表示，包括16位地址类型，16位端口号和32位ip地址。</p> 
<div> 
 <strong><span style="color:#777777;">IPv4</span><span style="color:#777777;">和</span><span style="color:#777777;">IPv6</span><span style="color:#777777;">的地址格式定义在</span><span style="color:#777777;">netinet/in.h头文件</span></strong> 
 <span style="color:#777777;"><strong>中</strong>,IPv4地址用</span> 
 <span style="color:#777777;">sockaddr_in</span> 
 <span style="color:#777777;">结构体表示</span> 
 <span style="color:#777777;">,</span> 
 <span style="color:#777777;">包括</span> 
 <span style="color:#777777;">16</span> 
 <span style="color:#777777;">位地址类型</span> 
 <span style="color:#777777;">, 16 位端口号和32</span> 
 <span style="color:#777777;">位</span> 
 <span style="color:#777777;">IP地址.</span> 
</div> 
<p></p> 
<h3 id="socket%E7%BB%91%E5%AE%9A%E5%9C%B0%E5%9D%80%EF%BC%88bind%E5%87%BD%E6%95%B0%EF%BC%89"><strong>📚 </strong>socket绑定地址（bind函数）</h3> 
<p>若要使socket也可以被其他进程使用，服务器必须给socket绑定<strong>ip地址</strong>和<strong>端口号</strong>。</p> 
<pre><code class="language-cpp">       #include &lt;sys/types.h&gt;          /* See NOTES */
       #include &lt;sys/socket.h&gt;

       int bind(int sockfd, const struct sockaddr *addr,
                socklen_t addrlen);
</code></pre> 
<p>参数sockfd为待绑定的socket描述符，参数addr是本地sockaddr地址结构指针，addrlen为本地sockaddr地址结构的大小。执行成功返回0，失败返回-1.`</p> 
<blockquote> 
 <p> 对于绑定IP4套接字，我们不会直接去创建一个struct sockaddr变量，而是直接定义一个struct sockaddr_in变量，然后将ip地址和端口号填充进struct sockaddr_in变量中，最后在传参的时候将struct sockaddr_in*变量强制转换为struct sockaddr*类型，其他套接字也是一样。  </p> 
</blockquote> 
<p>绑定IP4套接字过程如下： </p> 
<pre><code class="language-cpp">          struct sockaddr_in s;      //创建IP4网套接字地址数据结构
          memset(&amp;s,'\0',sizeof(s));   //将s置为0
          s.sin_family=AF_INET;      //设置TCP/IP地址族
          s.sin_port=htons(port);    //设置端口号
          s.sin_addr.s_addr=0;       //系统自动填入本机IP地址
          bind(fd,(struct sockaddr*)&amp;s,sizeof(s) //绑定套接字</code></pre> 
<ul><li>创建struct soaddr_in对象时，首先需要用bzero()函数或memset()函数将其置为0. </li><li>在调用bind()函数时一般不要将端口号设置为小于1024的值，因为1~1024是保留端口号，用户可以选择大于1024中任何一个没有被占用的端口号。</li><li>在使用bind(）函数时，需要将sin_port转换为网络字节序，而sin_addr则不需要转换。</li><li>在主机上定义的IP地址一般是“ 112.233.111.111”这种点分式字符串IP，但我们需要将这种字符串IP转换为整数IP填充进in_addr对象中的s_addr中。IP转换函数如下：</li></ul> 
<pre><code class="language-cpp">     //将字符型IP转换为32位整数型ip
    in_addr_t inet_addr(const char *cp);
     
    //将网络地址转换为字符串
    char *inet_ntoa(struct in_addr in)
</code></pre> 
<p>  IP地址也可以不用直接填充，使用INADDR_ANY变量，可以直接填入本机IP地址，推荐使用这种方法。在我们的云服务器中，一般使用这种操作填充IP地址，因为云服务器的IP是由云厂商提供的，这个云服务器IP不能直接被绑定。</p> 
<pre><code class="language-cpp">
my_addr.sin_addr.s_addr=INADDR_ANY;   //填入本机IP地址</code></pre> 
<p>一般只有服务器才会去绑定IP地址和端口号 ，客户端不需要绑定IP地址和端口号。因为服务器需要不断的监听客户端的请求，服务器的IP地址和端口号它不可以一直改变，而客户端在连接服务器或者给服务器发送数据时，系统会给客户端随机分配一个端口，这个端口号和ip地址会发送给服务器，接下来服务器根据ip地址和端口号就可以给客户回应消息。</p> 
<h3 id="Socket%E7%9B%91%E5%90%AC%E8%BF%9E%E6%8E%A5%EF%BC%88listen%E5%87%BD%E6%95%B0%EF%BC%89"><strong>📚 </strong>Socket监听连接（listen函数）</h3> 
<p>在成功建立Socket并完成与本地地址绑定后。使用listen()函数来监听客户的连接请求。调用函数listen()函数会创建一个等待队列，在其中存放未处理的客户端请求，其函数原型如下：</p> 
<pre><code class="language-cpp">       #include &lt;sys/types.h&gt;          
       #include &lt;sys/socket.h&gt;

       int listen(int sockfd, int backlog);</code></pre> 
<p> 参数为Socket描述符，参数为backlog为请求队列中允许的最大请求数，系统默认为5。函数listen()执行成功返回0，若执行失败返回-1.同时errno被设置成相应的值。</p> 
<h3 id="Socket%E8%AF%B7%E6%B1%82%E8%BF%9E%E6%8E%A5(connect%E5%87%BD%E6%95%B0%EF%BC%89"> <strong>📚 </strong>Socket请求连接(connect函数）</h3> 
<p>Tcp协议中，函数connect()用于客户端向服务器发起连接请求；UDP协议是面向无连接的，因此无需使用connect()，其函数原型如下：<br>         </p> 
<pre><code class="language-cpp">       #include &lt;sys/types.h&gt;          /* See NOTES */
       #include &lt;sys/socket.h&gt;

       int connect(int sockfd, const struct sockaddr *addr,
                   socklen_t addrlen);
</code></pre> 
<p>sockfd为待绑定Socket的描述符：参数addr是服务器Socket地址结构指针，参数addrlen为addr的大小。</p> 
<p>    函数执行成功返回0，失败返回-1，同时errno被设置成相应的值。 </p> 
<h3 id="Socket%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5%EF%BC%88accept%E5%87%BD%E6%95%B0%EF%BC%89"><strong>📚 </strong>Socket接受连接（accept函数）</h3> 
<p>服务器进程调用函数listen()创建等待队列之后，调用accept()函数等待并接受客户端的连接请求，函数accept通常从连接等待队列中取出一个未处理的连接请求，其函数</p> 
<pre><code class="language-cpp">       #include &lt;sys/types.h&gt;          
       #include &lt;sys/socket.h&gt;

       int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
</code></pre> 
<p>其中，参数sockfd为Socket的描述符；参数addr为存放客户端Sock地址结构指针，参数addrlen用于存放客户端Socket地址结构指针。</p> 
<p>函数accept()执行成功，返回客户端新的套接字描述符；若执行失败，返回-1，同时errno被设置成相应的值。 </p> 
<h3 id="Socket%E6%8E%A5%E5%8F%97%E6%95%B0%E6%8D%AE%20%EF%BC%88recvfrom%E5%87%BD%E6%95%B0%EF%BC%89"><strong>📚 </strong>Socket接受数据 （recvfrom函数）</h3> 
<pre><code class="language-cpp">ssize_t recv(int sockfd, void *buf, size_t len, int flags);
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                        struct sockaddr *src_addr, socklen_t *addrlen);</code></pre> 
<p>参数sockfd是Socket描述符,buf指定接受数据存放的缓冲区，len用于指定接受数据的大小，参数用于指定接受数据的标志，一般设置为0.</p> 
<p>函数recvfrom中，参数src_addr用于存放数据发送方的网络地址结构（ip4是由sockaddr_in填充对象强转为sockaddr类型），参数addrlen是src_addr的大小。</p> 
<p>recv和recvfrom执行成功，返回实际接受的字节数，执行失败，返回-1.</p> 
<h3 id="Socket%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%EF%BC%88sendto%E5%87%BD%E6%95%B0%EF%BC%89"><strong>📚 </strong>Socket发送数据（sendto函数）</h3> 
<p>函数send（）和sendto（）向socket连接中发送数据，函数原型如下：</p> 
<pre><code class="language-cpp">   ssize_t send(int sockfd, const void *buf, size_t len, int flags);

   ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                      const struct sockaddr *dest_addr, socklen_t addrlen);
</code></pre> 
<p>sockfd是Socket描述符，参数buf用于指定发送数据的缓冲区，参数len是指定发送数据的大小，参数flags用于指定发送数据标志，一般设置为0.</p> 
<p>函数sendto（），dest_addr用于指定接受方的网络地址结构（ip4是由sockaddr_in填充对象强转为sockaddr类型），addrlen是dest_addr的大小。 </p> 
<p>函数send（）和sendto()发送数据成功，返回实际发送出数据的大小，失败返回-1.</p> 
<h3 id="Socket%E5%85%B3%E9%97%AD"><strong>📚 </strong>Socket关闭</h3> 
<p>因为socketfd是文件描述符，所以用户也可以用close（）函数来终止服务器与客户端的套接字的连接。</p> 
<pre><code class="language-cpp">       #include &lt;unistd.h&gt;
       int close(int fd);
</code></pre> 
<p>close函数执行成功，返回0，失败返回-1.</p> 
<h2 id="UDP%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B">三. UDP编程模型</h2> 
<blockquote> 
 <p>UDP编程是不需要连接的，它是面向数据报。UDP socket是不可靠的，报文可能会丢失，重复或达到的顺序与它发送时的顺序不同；第二，当UDP上的socket填满的数据时，再发送数据时则报文会丢弃。</p> 
</blockquote> 
<p><img alt="" height="981" src="https://images2.imgbox.com/0d/b7/yRGZ7Iig_o.png" width="851"></p> 
<p>代码:</p> 
<p>server.hpp文件</p> 
<pre><code class="language-cpp"> #include&lt;iostream&gt;
  #include&lt;string&gt;
  #include&lt;sys/types.h&gt;
  #include&lt;sys/socket.h&gt;
  #include&lt;netinet/in.h&gt;
  #include&lt;arpa/inet.h&gt;
  #include&lt;string.h&gt;
  using namespace std;
  
  class server                                                                                         
  {
    private:
      int port;
      string ip;
      int fd;
    public:
      server(string _ip,int _port)
W&gt;      :ip(_ip),port(_port)
      {}
  
      bool initUdpServer()
      {
          //创建套接字
          fd=socket(AF_INET,SOCK_DGRAM,0);
          if(fd&lt;0)
          {
            cout&lt;&lt;"socket fail\n"&lt;&lt;endl;
            return false;
          }
          cout&lt;&lt;"socket success"&lt;&lt;endl;
          //绑定套接字
          struct sockaddr_in s;
          memset(&amp;s,'\0',sizeof(s));
          s.sin_family=AF_INET;
          s.sin_port=htons(port);
          s.sin_addr.s_addr=0; 
          if(bind(fd,(struct sockaddr*)&amp;s,sizeof(s))&lt;0)
          {
              cerr&lt;&lt;"bind error"&lt;&lt;endl;
              return false;
          }
          cout&lt;&lt;"bind success"&lt;&lt;endl;
          return true;
      }
  
      void Start()
      {
        for(;;)
        {
  #define NUM 32
          char buf[NUM];
          struct sockaddr_in peer;
          socklen_t len=0;                                                                             
          ssize_t sz=recvfrom(fd,(void*)buf,sizeof(buf)-1,0,(struct sockaddr*)&amp;peer,&amp;len);
          if(sz&gt;0)
        {
             buf[sz]='\0';
             int _port=ntohs(peer.sin_port);
             string s=inet_ntoa(peer.sin_addr);
             cout&lt;&lt;s&lt;&lt;":"&lt;&lt; _port&lt;&lt;"#"&lt;&lt;buf&lt;&lt;endl;
          }
          else{
          cerr&lt;&lt;"recvfrom error"&lt;&lt;endl;
          }
        }
      }
  };                                                                                                   
 
</code></pre> 
<p>server.cc文件</p> 
<pre><code class="language-cpp">#include"server.hpp"    
#include&lt;stdlib.h&gt;    
int main(int argc,char* argv[])    
{    
  if(argc!=2)    
  {    
    cout&lt;&lt;"Usage :"&lt;&lt;argv[0]&lt;&lt; "port"&lt;&lt;endl;    
  }    
  string ip="127.0.1";//127.0.1表示本地环回    
  int port=atoi(argv[1]);    
  server* s=new server(ip,port);    
  s-&gt;initUdpServer();    
  s-&gt;Start();    
  return 0;                                                                                            
}    
</code></pre> 
<p> </p> 
<p>client.hpp文件</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;                                                                                     
#include&lt;string&gt;    
#include&lt;sys/types.h&gt;    
#include&lt;sys/socket.h&gt;    
#include&lt;stdlib.h&gt;    
#include&lt;netinet/in.h&gt;    
#include&lt;string.h&gt;    
#include&lt;arpa/inet.h&gt;    
using namespace std;    
    
class client    
{    
  private:    
    int sockfd;    
    int sev_port;    
    string sev_ip;    
  public:    
    client(string _sev_ip,int _sev_port)    
      :sev_port(_sev_port)    
      ,sev_ip(_sev_ip)    
    {    
    
    }    
    
    bool InitClient()    
    {    
      sockfd=socket(AF_INET,SOCK_DGRAM,0);    
      if(sockfd&lt;0)    
      {    
        cout&lt;&lt;"socket error"&lt;&lt;endl;    
        return false;    
      }    
     return true;
    }

    void start()
    {
      struct sockaddr_in dest;
      memset(&amp;dest,'0',sizeof(dest));
      dest.sin_family=AF_INET;
      dest.sin_port=htons(sev_port);
      dest.sin_addr.s_addr=inet_addr(sev_ip.c_str());
      string buf;
      for(;;)
      {
        cout&lt;&lt;"Please Enter#"&lt;&lt;endl;
        cin&gt;&gt;buf;
        sendto(sockfd,(void*)buf.c_str(),(size_t)buf.size(),0,(struct sockaddr*)&amp;dest,sizeof(dest));
      }
    }
};        </code></pre> 
<p>client.cc文件</p> 
<pre><code class="language-cpp">#include"client.hpp"    
    
//./client "127.0.0.1" 8081    
int main(int argc,char* argv[])    
{    
  if(argc!=3)    
  {    
    cout&lt;&lt;"Usuage"&lt;&lt;"server_ip server_port"&lt;&lt;endl;    
    
  }    
  char* ip=argv[1];    
  int port=atoi(argv[2]);    
  client* c=new client(ip,port);    
  c-&gt;InitClient();    
  c-&gt;start();                                                                                          
  return 0;    
}  </code></pre> 
<p> </p> 
<h2 id="Tcp%E6%9C%8D%E5%8A%A1%E5%99%A8">四. Tcp编程模型</h2> 
<p>Tcp协议再两个端点（即应用程序）之间提供了可靠的，面向连接的，双向字节流的通信管道。</p> 
<p><img alt="" height="484" src="https://images2.imgbox.com/ea/74/cTC1pgCu_o.png" width="1200"></p> 
<p> </p> 
<p>Tcp协议提供了客户端和服务器之间的连接。Tcp客户端首先给某个定服务器建立一个连接，然后再通过连接与服务器进行数据交换，最后终止这个连接。</p> 
<p>Tcp协议保证了数据传输的可靠性，当Tcp一端向另一端发送数据时，它要求另一端返回一个“确认”，如果没有收到“确认”，Tcp就会自动多次传送数据，在数次重传失败后才会放弃。</p> 
<p>Tcp协议提供的<strong>连接是全双工的，这意味着在一个给定的连接上，一个Tcp端点可以在同一时刻发送数据又接受数据</strong>。</p> 
<p>Tcp协议</p> 
<ul><li>传输层协议</li><li>有链接</li><li>可靠传输</li><li>面向字节流</li></ul> 
<p>Tcp服务器模型</p> 
<p><img alt="" height="728" src="https://images2.imgbox.com/ce/fa/oc2P2ZjE_o.png" width="1200"></p> 
<p>Tcp服务器和客户端接收和发送数据可以用read和write，首先，前面socket描述符本质是文件描述符，所以可以用文件的操作接口， 其次，服务器在accept()后连接客户端就可以拿到客户端的IP和端口号信息。所以服务器和客户端接收数据和发送数据正常使用read()函数和write()函数。</p> 
<p>read()如果大于0，说明读到了信息。如果等于0，说明对端已关闭。</p> 
<p id="makefile%E6%96%87%E4%BB%B6"><strong>makefile文件</strong></p> 
<pre><code class="language-cpp">.PHONY:all    
all:tcp_client tcp_server    
    
tcp_client:tcp_client.cc    
  g++ $^ -o $@    
    
tcp_server:tcp_server.cc    
  g++ $^ -o $@    
    
clean:                                                                             
  rm -f tcp_client tcp_server   </code></pre> 
<p id="%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%B4%E6%96%87%E4%BB%B6"><strong>服务器头文件</strong></p> 
<p>下面是单线程单进程的服务器，一次只能连接一个客户端。</p> 
<p><img alt="" height="242" src="https://images2.imgbox.com/b9/42/hsp4Lj6d_o.png" width="976"></p> 
<p> </p> 
<p> </p> 
<pre><code class="language-cpp">#pragma once                                                                       
#include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;arpa/inet.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;netinet/in.h&gt;
#include&lt;unistd.h&gt;
#include&lt;string&gt;
#include&lt;stdlib.h&gt;
class TcpServer
{
  private:
    int port;//端口号
    int listen_sock;//监听套接字描述符
  public:
    TcpServer(int _port=8081)
      :port(_port)
      ,listen_sock(-1)
    {

    }

    void InitServer()
    {
      listen_sock=socket(AF_INET,SOCK_STREAM,0);//创建套接字
      if(listen_sock&lt;0)
      {
        std::cerr&lt;&lt;"socket fail"&lt;&lt;std::endl;
        return;
      }
      std::cout&lt;&lt;"socket success"&lt;&lt;std::endl;
      struct sockaddr_in s;
      memset(&amp;s,'\0',sizeof(s));
      s.sin_family=AF_INET;
      s.sin_port=htons(port);                                                      
      s.sin_addr.s_addr=INADDR_ANY;
      //绑定套接字
      if(bind(listen_sock,(struct sockaddr*)&amp;s,sizeof(s))&lt;0)
      {
        std::cerr&lt;&lt;"bind failing"&lt;&lt;std::endl;
        return;
      }  
      //让套接字去监听连接
      if(listen(listen_sock,5)&lt;0)
      {
        std::cerr&lt;&lt;"listen failing"&lt;&lt;std::endl;
      }
    }

    void Loop()
    {
      struct sockaddr_in sockaddr;                                                 
      for(;;)
      {
        socklen_t len=sizeof(sockaddr); 
        //接受监听套接字其中的一个连接，然后在创建新的套接字给这个连接
        //新的套接字进行数据通信
        int sockfd=accept(listen_sock,(struct sockaddr*)&amp;sockaddr,&amp;len);
        if(sockfd&lt;0)
        {
          std::cerr&lt;&lt;"accept fail"&lt;&lt;std::endl;
          continue;
        }
 
        std::string ip=inet_ntoa(sockaddr.sin_addr);
        int port=ntohs(sockaddr.sin_port);
        std::cout&lt;&lt;"get new link..["&lt;&lt;ip&lt;&lt;"]:"&lt;&lt;port&lt;&lt;std::endl;
        //对新的套接字进行服务
        Server(sockfd,ip,port);
      }         
    }

    void Server(int sock,std::string ip,int port)//服务功能
    {
      char buffer[1024];
      while(true)
      {
        ssize_t size=read(sock,buffer,sizeof(buffer)-1);
        if(size&gt;0)
        {
          buffer[size]='\0';
          std::cout&lt;&lt;ip&lt;&lt;":"&lt;&lt;port&lt;&lt;"#"&lt;&lt;buffer&lt;&lt;std::endl;
          write(sock,buffer,size);
        }
        else if(size==0)
        {             
          std::cout&lt;&lt;ip&lt;&lt;":"&lt;&lt;port&lt;&lt;"close"&lt;&lt;std::endl;
          break;
        }
        else{
          std::cout&lt;&lt;"port error!!"&lt;&lt;std::endl;
        }
      }
         //新的套接字使用完后，需要关闭文件描述符，防止文件描述符泄漏
        close(sock);
    }                                                                              
};
</code></pre> 
<p>服务器.cc文件</p> 
<pre><code class="language-cpp">#include"tcp_server.hpp"    
using namespace std;    
//启动服务器的方式：./tcp_server port    
int main(int argv,char* argc[])    
{                                                                                  
  if(argv!=2)    
  {                    
    cout&lt;&lt;"Usage: tcp_server port"&lt;&lt;endl;    
    exit(-1);                                
  }                    
                       
  TcpServer* ts=new TcpServer(atoi(argc[1]));//创建服务器    
  ts-&gt;InitServer();//初始化服务器                                   
  ts-&gt;Loop();//启动服务器                                           
  return 0;                                                         
}         </code></pre> 
<p>客户端头文件</p> 
<pre><code class="language-cpp">#pragma once
#include&lt;iostream&gt;
#include&lt;netinet/in.h&gt;
#include&lt;arpa/inet.h&gt;
#include&lt;string.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;string&gt;
#include&lt;sys/socket.h&gt;
#include&lt;unistd.h&gt;

class TcpClient
{
  private:
    int ser_port;//服务器端口号
    std::string ser_ip;//服务器的ip地址
    int sockfd;//本地套接字描述符
  public:
    TcpClient(std::string _ser_ip,int _ser_port):
      ser_port(_ser_port)                                                          
      ,ser_ip(_ser_ip)
      ,sockfd(-1)
  {

  }

    void InitTcpClient()
    {
      sockfd=socket(AF_INET,SOCK_STREAM,0);//创建套接字
      if(sockfd&lt;0)
      {
        std::cerr&lt;&lt;"socket failing"&lt;&lt;std::endl;
        return;
      }
    }

      void Start()
      {
          struct sockaddr_in peer;
          memset(&amp;peer,'\0',sizeof(peer));
          peer.sin_family=AF_INET;
          peer.sin_port=htons(ser_port);
          peer.sin_addr.s_addr=inet_addr(ser_ip.c_str());
          //本地套接字去连接服务器
          if(connect(sockfd,(struct sockaddr*)&amp;peer,sizeof(peer))==0)
          {
            //连接成功，请求服务
            std::cout&lt;&lt;"connect success..."&lt;&lt;std::endl;
            Request(sockfd);
          }
          else{
            //fail
            std::cout&lt;&lt;"connect fail"&lt;&lt;std::endl;
          }
      }
      //请求服务任务接口
      void Request(int sockfd)
      {
        std::string message;
        char buffer[1024];
        while(true)
        {
          std::cout&lt;&lt;"Please Enter#";
          std::cin&gt;&gt;message;
          //往套接字中输入数据
          write(sockfd,message.c_str(),message.size());

          ssize_t size=read(sockfd,buffer,sizeof(buffer));
          if(size&gt;0)
          {
            buffer[size]='\0';
            std::cout&lt;&lt;"server # "&lt;&lt;buffer&lt;&lt;std::endl;
          }
        }
      }

      ~TcpClient()
      {                                                                            
        if(sockfd&gt;0)
          close(sockfd);
      }
};

</code></pre> 
<p>客户端.cc文件</p> 
<pre><code class="language-cpp">#include"tcp_client.hpp"    
using namespace std;    
#include&lt;stdlib.h&gt;    
// 启动客户端的方式：./tcp_client ip port    
    
int main(int argv,char* argc[])    
{    
  if(argv!=3)    
  {    
    cout&lt;&lt;"Usage : ./tcp_client ip port"&lt;&lt;endl;    
    exit(-1);    
  }    
      
  TcpClient* tc=new TcpClient(argc[1],atoi(argc[2]));    
  tc-&gt;InitTcpClient();    
  tc-&gt;Start();//开始运行服务端                                                     
  return 0;                            
}  </code></pre> 
<p> 运行结果：</p> 
<p>    <img alt="" height="207" src="https://images2.imgbox.com/50/15/u5vExu39_o.png" width="856"></p> 
<p> 因为这是单线程单进程的服务器，所以服务器每次只能接受一个客户端的连接。        </p> 
<p><img alt="" height="748" src="https://images2.imgbox.com/42/90/gCNrzUaq_o.png" width="1200"></p> 
<h3 id="%C2%A0%E5%A4%9A%E8%BF%9B%E7%A8%8Btcp%E6%9C%8D%E5%8A%A1%E5%99%A8"> 多进程服务器</h3> 
<p><img alt="" height="642" src="https://images2.imgbox.com/cc/7e/V2MkaQu7_o.png" width="1200"></p> 
<p> </p> 
<p>多进程服务器只需要在server.hpp文件改Loop()函数，其他文件不用改。     </p> 
<p>主线程是爷爷进程，爷爷进程不断的去等待队列中接受新连接，接受到一个新连接，就去创建一个爸爸进程，再创建一个儿子进程去服务客户端的连接请求，再退出爸爸进程，如果有多个连接，爷爷进程就会创建多个儿子进程去服务多个连接。为什么要创建儿子进程？如果只创建爸爸进程，那么爸爸进程再退出前，爷爷进程需要去回收爸爸进程的资源，爷爷进程就会阻塞等待，如果再创建一个儿子进程，再退出爸爸进程，那么儿子进程就会被操作系统给“领养",当儿子系统退出时，操作系统会自动释放儿子进程的资源，此时爷爷进程就不会被阻塞，继续去接收新的连接。</p> 
<p><img alt="" height="736" src="https://images2.imgbox.com/05/1e/wQVsMwWO_o.png" width="817"></p> 
<p> </p> 
<p>         </p> 
<p> 当创建儿子进程去服务新链接后，<strong>爷爷进程就需要关闭新连接的sock描述符</strong>，防止爷爷进程的文件描述符表泄漏。</p> 
<p>运行结果</p> 
<p><img alt="" height="683" src="https://images2.imgbox.com/b9/17/p9A6LFwd_o.png" width="1200"></p> 
<h3 id="%C2%A0%E5%A4%9A%E7%BA%BF%E7%A8%8Btcp%E6%9C%8D%E5%8A%A1%E5%99%A8"> 多线程服务器</h3> 
<p><img alt="" height="823" src="https://images2.imgbox.com/ea/e1/GbNzs0vf_o.png" width="1200"></p> 
<p>多线程服务器代码 </p> 
<pre><code class="language-cpp"> class Pragma
  {
    public:
      int sockfd;
      std::string ip;
      int port;
    public:
      Pragma(int _sockfd,std::string _ip,int _port)
        :sockfd(_sockfd)
        ,ip(_ip)
        ,port(_port)
    { 
    }
  };
 class TcpServer
  {
    private:
      int port;
      int listen_sock;
    public:
      TcpServer(int _port)
        :port(_port)
        ,listen_sock(-1)
      {
  
      }
  
      void InitTcpServer()
      {
        listen_sock=socket(AF_INET,SOCK_STREAM,0);
        if(listen_sock&lt;0)
        {
          std::cerr&lt;&lt;"socket failing"&lt;&lt;std::endl;
          exit(2);
        }
       
        struct sockaddr_in lock;
        lock.sin_family=AF_INET;
        lock.sin_port=htons(port);
        lock.sin_addr.s_addr=INADDR_ANY;
       if(bind(listen_sock,(struct sockaddr*)&amp;lock,sizeof(lock))&lt;0)
        {
          std::cerr&lt;&lt;"bind failing"&lt;&lt;std::endl;
          exit(2);
        }
  
        if(listen(listen_sock,5)&lt;0)
        {
          std::cerr&lt;&lt;"listen failing"&lt;&lt;std::endl;
          exit(3);
        }
        std::cout&lt;&lt;"listen success....."&lt;&lt;std::endl;
      }
  
      void Loop()
      {
        struct sockaddr_in peer;
        socklen_t len=sizeof(peer);
        for(;;)
        {
          int sockfd=accept(listen_sock,(struct sockaddr*)&amp;peer,&amp;len);
          if(sockfd&lt;0)
          {                                                                                            
            continue;
          }
          std::string ip=inet_ntoa(peer.sin_addr);
          int port=ntohs(peer.sin_port);
          std::cout&lt;&lt;"get new link ["&lt;&lt;ip&lt;&lt;"] :"&lt;&lt;port&lt;&lt;std::endl;
          pthread_t id;
          Pragma* p=new Pragma(sockfd,ip,port);
          pthread_create(&amp;id,NULL,Routine,p);
        }
      }
  
      static void* Routine(void* arg)
      {
          Pragma* p=(Pragma*)arg;
          pthread_detach(pthread_self());
          Server(p-&gt;sockfd,p-&gt;ip,p-&gt;port);
          close(p-&gt;sockfd);
          delete p;
W&gt;    }                                                                                                
      static void Server(int sockfd,std::string ip,int port)
      {                                                     
        char buffer[1024];
        while(true)       
        {          
          buffer[0]='0';
        int sz=read(sockfd,buffer,sizeof(buffer)-1);
       if(sz&gt;0){
          buffer[sz]='\0';
          std::cout&lt;&lt;ip&lt;&lt;":"&lt;&lt;port&lt;&lt;"#"&lt;&lt;buffer&lt;&lt;std::endl;
        }
        else if(sz==0){
          std::cerr&lt;&lt;"client close"&lt;&lt;std::endl;
          break;
        }
        else{
          break;                                                                                       
        }
        }
        close(sockfd);
      }
      ~TcpServer()
          ~TcpServer()
      {
        if(listen_sock&gt;0)
          close(listen_sock);
      }
  };   


</code></pre> 
<p> </p> 
<p><img alt="" height="1134" src="https://images2.imgbox.com/a7/10/L8VcKViS_o.png" width="928"></p> 
<p> </p> 
<p>多线程服务器，当主线程接受连接多少个客户端时，主线程会创建相应的子线程去服务客户端，同时主线程和客户端不能随便关闭socket描述符，因为主线程和子线程使用的同一文件描述符表。 </p> 
<h3 id="%E7%BA%BF%E7%A8%8B%E6%B1%A0Tcp%E6%9C%8D%E5%8A%A1%E5%99%A8">线程池服务器</h3> 
<p><strong>线程池Tcp服务器在服务器内创建一个线程池</strong>，初始化线程池后，服务器的主线程不断的往线程池中的任务队列中塞连接请求任务，线程池中的线程不断在任务队列中取出连接请求任务，通过客户端的套接字描述符，线程池中的线程就可以跟客户端进行通信。</p> 
<p>线程池Tcp服务器处理客户端的连接请求的线程是固定的，不会随着连接请求的增多而导致线程不断的增多。</p> 
<p><a class="link-info" href="https://blog.csdn.net/sjp11/article/details/122914857?spm=1001.2014.3001.5501" title="线程池的实现">线程池的实现</a></p> 
<p><img alt="" height="640" src="https://images2.imgbox.com/c3/75/kM0ELx3X_o.png" width="1200"></p> 
<p>Task.hpp文件</p> 
<pre><code class="language-cpp">#pragma once
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;unistd.h&gt;

class Handler{
    public:
      Handler()
      {}
    void operator()(int sockfd,std::string ip,int port)
    {
      char buffer[1024];                                                                                  
      while(true)
      {
        buffer[0]='0';
      int sz=read(sockfd,buffer,sizeof(buffer)-1);
      if(sz&gt;0){
        buffer[sz]='\0';
        std::cout&lt;&lt;ip&lt;&lt;":"&lt;&lt;port&lt;&lt;"#"&lt;&lt;buffer&lt;&lt;std::endl;
      }
      else if(sz==0){
        std::cerr&lt;&lt;"client close"&lt;&lt;std::endl;
        break;
      }
      else{
        break;
      }
      }
      close(sockfd);
    }
};
</code></pre> 
<p>threadpool.hpp头文件（线程池） </p> 
<pre><code class="language-cpp">#pragma once    
#include&lt;iostream&gt;    
#include&lt;queue&gt;    
#include&lt;pthread.h&gt;    
#include&lt;unistd.h&gt;    
using namespace std;    
     
#define NUM 2                                                                                             
template&lt;class T&gt;    
class ThreadPool    
{    
  private:    
    queue&lt;T&gt; q;//任务队列    
    int thread_num;//线程池的线程数量    
    pthread_mutex_t lock;//互斥锁    
    pthread_cond_t cond;//条件变量    
  public:    
    ThreadPool(int num=NUM)//构造函数    
      :thread_num(num){    
        pthread_mutex_init(&amp;lock,NULL);    
        pthread_cond_init(&amp;cond,NULL);    
    }    
    
    bool Empty()    
    {    
      return q.size()==0?true:false;    
    }    

   static  void* Routine(void* arg)//线程执行流
    {
      pthread_detach(pthread_self());//线程分离
      ThreadPool* self=(ThreadPool*)arg;
      while(1)
      {
        self-&gt;LockQueue();
        while(self-&gt;Empty())//任务队列是否为空
        {
          self-&gt;Wait();
        }
        T data;
        self-&gt;Pop(data);//取出任务
        self-&gt;UnlockQueue();
        cout&lt;&lt;pthread_self()&lt;&lt;"# "; 
        //处理任务
        data.Run();//处理任务
        sleep(1);
      }
    }
   void ThreadPoolInit()
    {
      pthread_t tid;
      for(int i=0;i&lt;thread_num;i++)
      {
        pthread_create(&amp;tid,NULL,Routine,(void*)this);
      }
    }

    void Wait()
    {
      pthread_cond_wait(&amp;cond,&amp;lock);
    }

    void LockQueue()
    {
      pthread_mutex_lock(&amp;lock);
    }

    void UnlockQueue()
    {
      pthread_mutex_unlock(&amp;lock);
    }     
    void Push(const T&amp; in)//将任务推进任务队列中
    {                                           
      LockQueue();
      q.push(in); 
      UnlockQueue();
      SignalThread();
    }                
     
    void SignalThread()
    {                  
      pthread_cond_signal(&amp;cond);
    }                            
     
    void Pop( T&amp; out)//将任务从队列中删除
    {                                    
      out=q.front();
      q.pop();      
    }         
     
    ~ThreadPool()
    {            
      pthread_mutex_destroy(&amp;lock);
      pthread_cond_destroy(&amp;cond); 
    }                             
};   
                                  
</code></pre> 
<p> tcp_server.hpp</p> 
<pre><code class="language-cpp"> #pragma once                                                                                            
  #include&lt;iostream&gt;    
  #include&lt;string.h&gt;    
  #include&lt;arpa/inet.h&gt;    
  #include&lt;netinet/in.h&gt;    
  #include&lt;sys/types.h&gt;    
  #include&lt;sys/socket.h&gt;    
  #include&lt;unistd.h&gt;    
  #include&lt;pthread.h&gt;    
  #include"threadpool.hpp"    
  #include"Task.hpp"    
  class TcpServer    
  {    
    private:    
      int port;    
      int listen_sock;    
      ThreadPool&lt;Task&gt;* pool;    
    public:    
      TcpServer(int _port)    
        :port(_port)    
        ,listen_sock(-1)    
        ,pool(nullptr)    
      {    
      
      }    

    void InitTcpServer()
    {
      listen_sock=socket(AF_INET,SOCK_STREAM,0);//创建监听套接字
      if(listen_sock&lt;0)
      {
        std::cerr&lt;&lt;"socket failing"&lt;&lt;std::endl;
        exit(2);
      }
      
      struct sockaddr_in lock;
      lock.sin_family=AF_INET;
      lock.sin_port=htons(port);
      lock.sin_addr.s_addr=INADDR_ANY;

      //绑定监听套接字
      if(bind(listen_sock,(struct sockaddr*)&amp;lock,sizeof(lock))&lt;0)
      {
        std::cerr&lt;&lt;"bind failing"&lt;&lt;std::endl;
        exit(2);
      }
      
      //监听连接
      if(listen(listen_sock,5)&lt;0)
      {
        std::cerr&lt;&lt;"listen failing"&lt;&lt;std::endl;
        exit(3);                                                                                       
      }
     std::cout&lt;&lt;"listen success....."&lt;&lt;std::endl;
     pool= new ThreadPool&lt;Task&gt;();//创建线程池
    }

    void Loop()
    {
      pool-&gt;ThreadPoolInit();//初始化线程池
      struct sockaddr_in peer;
      socklen_t len=sizeof(peer);
      for(;;)
      {
        //主线程接受客户端的连接
        int sockfd=accept(listen_sock,(struct sockaddr*)&amp;peer,&amp;len);
        if(sockfd&lt;0)
        {
          continue;
        }

        std::string ip=inet_ntoa(peer.sin_addr);
        int port=ntohs(peer.sin_port);
        std::cout&lt;&lt;"get new link ["&lt;&lt;ip&lt;&lt;"] :"&lt;&lt;port&lt;&lt;std::endl;
        Task t(sockfd,ip,port);//创建任务
        pool-&gt;Push(t);//将任务推到线程池中
      }
    }

    ~TcpServer()
    {
      if(listen_sock&gt;0)                                                                                
        close(listen_sock);
    }
};

</code></pre> 
<h2 id="netstate%E5%91%BD%E4%BB%A4">五. netstate命令</h2> 
<p>netstate 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。</p> 
<ul><li>-a:显示所有选项，默认不显示LISTEN</li><li>-t(tcp)：仅显示tcp相关选项</li><li>-u(udp):仅显示udp相关选项</li><li>-n:拒绝显示别名，能显示成数字就显示成数字</li><li>-p:显示建立相关链接的程序名</li><li>-r:显示路由信息，路由表</li><li>-e：显示扩展信息</li><li>-s:按各个协议进行统计</li><li>-c：每隔一段时间，执行该netstate命令</li><li>-l:拒绝显示别名，能显示成数字就显示成数字</li></ul> 
<p> </p> 
<p> </p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ad8f8eb0c92099516e4a88440aecc010/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android DataUsage</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bdc84222ca1a2668de7de81e5dd20409/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">转载：模吧即将关站的说明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>