<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言基础入门——保姆式教程（2022版最全最新整理） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言基础入门——保姆式教程（2022版最全最新整理）" />
<meta property="og:description" content="文章目录 一. 前言二. 第一个C语言程序三. 数据类型四. 变量和常量a）变量1）局部变量2）全局变量 b）常量1）字面常量（相当于直接写）2）const修饰的常量3）#define定义的标识符常量4）枚举常量 五. 字符串&#43;转义字符&#43;注释a）字符串1）字符数组 b）转义字符c）注释 六. 选择语句（分支语句）a）if语句b）switch语句1）default 七. 循环语句a）while语句b）for语句c）do ... while语句d）goto语句 八. 函数a）函数分类1）库函数2）自定义函数 b）函数参数1）实际参数（实参）2）形式参数（形参） c）函数调用1）传值调用2）传址调用 d）函数的嵌套调用和链式访问1）嵌套调用2）链式访问 e）函数的声明和定义1）函数声明2）函数定义 f）函数递归 九. 数组a）一维数组1）一维数组的创建2）一维数组的初始化 b）二维数组1）二维数组的创建2）二维数组的初始化 c）数组越界d）数组作为函数参数e）数组名 十. 操作符a）算术操作符b）移位操作符1）左移2）右移x1）逻辑移位x2）算术移位 c）位操作符1）&amp;:按位与2）|:按位或3）^:按位异或 d）赋值操作符e）单目操作符1）！逻辑反操作2）sizeof3）~ 按（二进制）位取法4）&#43;&#43; 前置、后置&#43;&#43;5）-- 前置、后置 --6）（类型）强制类型转换7）&amp; 取地址操作符 * 解引用操作符 f）关系操作符g）逻辑操作符h）条件操作符i）逗号表达式j）下标引用、函数调用和结构成员1）下标引用[]2）函数调用() k）表达式求值1）隐式类型转换x1）整形提升 2）算术转换3）操作符的属性 十一. 常见关键字a）autob）externc）registerd）signede）unsignedf）static1）static修饰局部变量2）static修饰全局变量3）static修饰函数 g）unionh）voidi）typedef 十二. define定义常量和宏a）define定义常量b）define定义宏 十三. 指针a）指针的基本认识b）指针的意义c）野指针1）指针未初始化2）指针越界访问3）指针指向的空间释放 d)如何规避野指针1）指针初始化2）小心指针越界3）指针指向空间释放即使置NULL4）避免返回局部变量的地址5）指针使用之前检查有效性 e）指针运算1）指针&#43;-整数2）指针-指针3）指针的关系运算 f）指针和数组g）二级指针h）指针数组 十四. 结构体十五. 补充a）scanf函数b）调试1）调试的基本步骤2）快捷键x1）内存x2）调用堆栈x3）打断点x4）常用快捷键 3）常用的调试技巧x1）使用assertx2）尽量使用constx3）养成良好的编码风格x4）添加必要的注释x5）避免编码的陷阱 4）编译常见的错误x1）编译型错误x2）链接型错误x3）运行时错误 一. 前言 本文是作者初学C语言的笔记整理哦，已进行6次更新（还会不断更新，结束会说明哦），小伙伴们注意接收哦，另外有什么问题可以留下你的邮箱，我会及时查看哦，另外制作不易，一键三连哦~本文现已结束初阶C语言，接下来将进入进阶C语言 二. 第一个C语言程序 #include &lt;stdio.h&gt; int main() { printf(&#34;初学C语言&#34;); return 0; } 这里说明下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/e738d57bd3f8a5751fa18aa4a450f02a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-27T22:03:55+08:00" />
<meta property="article:modified_time" content="2022-08-27T22:03:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言基础入门——保姆式教程（2022版最全最新整理）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#__1" rel="nofollow">一. 前言</a></li><li><a href="#_C_4" rel="nofollow">二. 第一个C语言程序</a></li><li><a href="#__23" rel="nofollow">三. 数据类型</a></li><li><a href="#__57" rel="nofollow">四. 变量和常量</a></li><li><ul><li><a href="#a_58" rel="nofollow">a）变量</a></li><li><ul><li><a href="#1_62" rel="nofollow">1）局部变量</a></li><li><a href="#2_66" rel="nofollow">2）全局变量</a></li></ul> 
   </li><li><a href="#b_78" rel="nofollow">b）常量</a></li><li><ul><li><a href="#1_81" rel="nofollow">1）字面常量（相当于直接写）</a></li><li><a href="#2const_85" rel="nofollow">2）const修饰的常量</a></li><li><a href="#3define_91" rel="nofollow">3）#define定义的标识符常量</a></li><li><a href="#4_96" rel="nofollow">4）枚举常量</a></li></ul> 
  </li></ul> 
  </li><li><a href="#__102" rel="nofollow">五. 字符串+转义字符+注释</a></li><li><ul><li><a href="#a_103" rel="nofollow">a）字符串</a></li><li><ul><li><a href="#1_108" rel="nofollow">1）字符数组</a></li></ul> 
   </li><li><a href="#b_123" rel="nofollow">b）转义字符</a></li><li><a href="#c_143" rel="nofollow">c）注释</a></li></ul> 
  </li><li><a href="#__151" rel="nofollow">六. 选择语句（分支语句）</a></li><li><ul><li><a href="#aif_152" rel="nofollow">a）if语句</a></li><li><a href="#bswitch_178" rel="nofollow">b）switch语句</a></li><li><ul><li><a href="#1default_187" rel="nofollow">1）default</a></li></ul> 
  </li></ul> 
  </li><li><a href="#__190" rel="nofollow">七. 循环语句</a></li><li><ul><li><a href="#awhile_191" rel="nofollow">a）while语句</a></li><li><a href="#bfor_216" rel="nofollow">b）for语句</a></li><li><a href="#cdo__while_225" rel="nofollow">c）do ... while语句</a></li><li><a href="#dgoto_231" rel="nofollow">d）goto语句</a></li></ul> 
  </li><li><a href="#__237" rel="nofollow">八. 函数</a></li><li><ul><li><a href="#a_239" rel="nofollow">a）函数分类</a></li><li><ul><li><a href="#1_240" rel="nofollow">1）库函数</a></li><li><a href="#2_255" rel="nofollow">2）自定义函数</a></li></ul> 
   </li><li><a href="#b_260" rel="nofollow">b）函数参数</a></li><li><ul><li><a href="#1_261" rel="nofollow">1）实际参数（实参）</a></li><li><a href="#2_265" rel="nofollow">2）形式参数（形参）</a></li></ul> 
   </li><li><a href="#c_269" rel="nofollow">c）函数调用</a></li><li><ul><li><a href="#1_270" rel="nofollow">1）传值调用</a></li><li><a href="#2_273" rel="nofollow">2）传址调用</a></li></ul> 
   </li><li><a href="#d_276" rel="nofollow">d）函数的嵌套调用和链式访问</a></li><li><ul><li><a href="#1_278" rel="nofollow">1）嵌套调用</a></li><li><a href="#2_282" rel="nofollow">2）链式访问</a></li></ul> 
   </li><li><a href="#e_293" rel="nofollow">e）函数的声明和定义</a></li><li><ul><li><a href="#1_294" rel="nofollow">1）函数声明</a></li><li><a href="#2_302" rel="nofollow">2）函数定义</a></li></ul> 
   </li><li><a href="#f_306" rel="nofollow">f）函数递归</a></li></ul> 
  </li><li><a href="#__315" rel="nofollow">九. 数组</a></li><li><ul><li><a href="#a_326" rel="nofollow">a）一维数组</a></li><li><ul><li><a href="#1_329" rel="nofollow">1）一维数组的创建</a></li><li><a href="#2_337" rel="nofollow">2）一维数组的初始化</a></li></ul> 
   </li><li><a href="#b_340" rel="nofollow">b）二维数组</a></li><li><ul><li><a href="#1_342" rel="nofollow">1）二维数组的创建</a></li><li><a href="#2_345" rel="nofollow">2）二维数组的初始化</a></li></ul> 
   </li><li><a href="#c_348" rel="nofollow">c）数组越界</a></li><li><a href="#d_353" rel="nofollow">d）数组作为函数参数</a></li><li><a href="#e_356" rel="nofollow">e）数组名</a></li></ul> 
  </li><li><a href="#__375" rel="nofollow">十. 操作符</a></li><li><ul><li><a href="#a_376" rel="nofollow">a）算术操作符</a></li><li><a href="#b_382" rel="nofollow">b）移位操作符</a></li><li><ul><li><a href="#1_385" rel="nofollow">1）左移</a></li><li><a href="#2_388" rel="nofollow">2）右移</a></li><li><ul><li><a href="#x1_390" rel="nofollow">x1）逻辑移位</a></li><li><a href="#x2_392" rel="nofollow">x2）算术移位</a></li></ul> 
   </li></ul> 
   </li><li><a href="#c_400" rel="nofollow">c）位操作符</a></li><li><ul><li><a href="#1_401" rel="nofollow">1）&amp;:按位与</a></li><li><a href="#2_403" rel="nofollow">2）|:按位或</a></li><li><a href="#3_405" rel="nofollow">3）^:按位异或</a></li></ul> 
   </li><li><a href="#d_411" rel="nofollow">d）赋值操作符</a></li><li><a href="#e_414" rel="nofollow">e）单目操作符</a></li><li><ul><li><a href="#1_416" rel="nofollow">1）！逻辑反操作</a></li><li><a href="#2sizeof_418" rel="nofollow">2）sizeof</a></li><li><a href="#3__426" rel="nofollow">3）~ 按（二进制）位取法</a></li><li><a href="#4__436" rel="nofollow">4）++ 前置、后置++</a></li><li><a href="#5___443" rel="nofollow">5）-- 前置、后置 --</a></li><li><a href="#6_445" rel="nofollow">6）（类型）强制类型转换</a></li><li><a href="#7________447" rel="nofollow">7）&amp; 取地址操作符 * 解引用操作符</a></li></ul> 
   </li><li><a href="#f_451" rel="nofollow">f）关系操作符</a></li><li><a href="#g_456" rel="nofollow">g）逻辑操作符</a></li><li><a href="#h_463" rel="nofollow">h）条件操作符</a></li><li><a href="#i_467" rel="nofollow">i）逗号表达式</a></li><li><a href="#j_474" rel="nofollow">j）下标引用、函数调用和结构成员</a></li><li><ul><li><a href="#1_476" rel="nofollow">1）下标引用[]</a></li><li><a href="#2_481" rel="nofollow">2）函数调用()</a></li></ul> 
   </li><li><a href="#k_485" rel="nofollow">k）表达式求值</a></li><li><ul><li><a href="#1_487" rel="nofollow">1）隐式类型转换</a></li><li><ul><li><a href="#x1_489" rel="nofollow">x1）整形提升</a></li></ul> 
    </li><li><a href="#2_505" rel="nofollow">2）算术转换</a></li><li><a href="#3_513" rel="nofollow">3）操作符的属性</a></li></ul> 
  </li></ul> 
  </li><li><a href="#__532" rel="nofollow">十一. 常见关键字</a></li><li><ul><li><a href="#aauto_537" rel="nofollow">a）auto</a></li><li><a href="#bextern_539" rel="nofollow">b）extern</a></li><li><a href="#cregister_547" rel="nofollow">c）register</a></li><li><a href="#dsigned_552" rel="nofollow">d）signed</a></li><li><a href="#eunsigned_554" rel="nofollow">e）unsigned</a></li><li><a href="#fstatic_556" rel="nofollow">f）static</a></li><li><ul><li><a href="#1static_558" rel="nofollow">1）static修饰局部变量</a></li><li><a href="#2static_562" rel="nofollow">2）static修饰全局变量</a></li><li><a href="#3static_568" rel="nofollow">3）static修饰函数</a></li></ul> 
   </li><li><a href="#gunion_573" rel="nofollow">g）union</a></li><li><a href="#hvoid_575" rel="nofollow">h）void</a></li><li><a href="#itypedef_577" rel="nofollow">i）typedef</a></li></ul> 
  </li><li><a href="#_define_585" rel="nofollow">十二. define定义常量和宏</a></li><li><ul><li><a href="#adefine_586" rel="nofollow">a）define定义常量</a></li><li><a href="#bdefine_589" rel="nofollow">b）define定义宏</a></li></ul> 
  </li><li><a href="#__592" rel="nofollow">十三. 指针</a></li><li><ul><li><a href="#a_593" rel="nofollow">a）指针的基本认识</a></li><li><a href="#b_622" rel="nofollow">b）指针的意义</a></li><li><a href="#c_626" rel="nofollow">c）野指针</a></li><li><ul><li><a href="#1_627" rel="nofollow">1）指针未初始化</a></li><li><a href="#2_630" rel="nofollow">2）指针越界访问</a></li><li><a href="#3_633" rel="nofollow">3）指针指向的空间释放</a></li></ul> 
   </li><li><a href="#d_636" rel="nofollow">d)如何规避野指针</a></li><li><ul><li><a href="#1_637" rel="nofollow">1）指针初始化</a></li><li><a href="#2_638" rel="nofollow">2）小心指针越界</a></li><li><a href="#3NULL_639" rel="nofollow">3）指针指向空间释放即使置NULL</a></li><li><a href="#4_648" rel="nofollow">4）避免返回局部变量的地址</a></li><li><a href="#5_649" rel="nofollow">5）指针使用之前检查有效性</a></li></ul> 
   </li><li><a href="#e_650" rel="nofollow">e）指针运算</a></li><li><ul><li><a href="#1_653" rel="nofollow">1）指针+-整数</a></li><li><a href="#2_656" rel="nofollow">2）指针-指针</a></li><li><a href="#3_658" rel="nofollow">3）指针的关系运算</a></li></ul> 
   </li><li><a href="#f_665" rel="nofollow">f）指针和数组</a></li><li><a href="#g_668" rel="nofollow">g）二级指针</a></li><li><a href="#h_671" rel="nofollow">h）指针数组</a></li></ul> 
  </li><li><a href="#__676" rel="nofollow">十四. 结构体</a></li><li><a href="#__701" rel="nofollow">十五. 补充</a></li><li><ul><li><a href="#ascanf_702" rel="nofollow">a）scanf函数</a></li><li><a href="#b_713" rel="nofollow">b）调试</a></li><li><ul><li><a href="#1_714" rel="nofollow">1）调试的基本步骤</a></li><li><a href="#2_720" rel="nofollow">2）快捷键</a></li><li><ul><li><a href="#x1_721" rel="nofollow">x1）内存</a></li><li><a href="#x2_724" rel="nofollow">x2）调用堆栈</a></li><li><a href="#x3_727" rel="nofollow">x3）打断点</a></li><li><a href="#x4_730" rel="nofollow">x4）常用快捷键</a></li></ul> 
    </li><li><a href="#3_734" rel="nofollow">3）常用的调试技巧</a></li><li><ul><li><a href="#x1assert_735" rel="nofollow">x1）使用assert</a></li><li><a href="#x2const_741" rel="nofollow">x2）尽量使用const</a></li><li><a href="#x3_748" rel="nofollow">x3）养成良好的编码风格</a></li><li><a href="#x4_749" rel="nofollow">x4）添加必要的注释</a></li><li><a href="#x5_750" rel="nofollow">x5）避免编码的陷阱</a></li></ul> 
    </li><li><a href="#4_751" rel="nofollow">4）编译常见的错误</a></li><li><ul><li><a href="#x1_752" rel="nofollow">x1）编译型错误</a></li><li><a href="#x2_754" rel="nofollow">x2）链接型错误</a></li><li><a href="#x3_756" rel="nofollow">x3）运行时错误</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="__1"></a>一. 前言</h2> 
<ul><li><strong>本文是作者初学C语言的笔记整理哦，已进行6次更新（还会不断更新，结束会说明哦），小伙伴们注意接收哦，另外有什么问题可以留下你的邮箱，我会及时查看哦，另外制作不易，一键三连哦~</strong></li><li><strong>本文现已结束初阶C语言，接下来将进入进阶C语言</strong></li></ul> 
<h2><a id="_C_4"></a>二. 第一个C语言程序</h2> 
<pre><code>#include &lt;stdio.h&gt;

int main()
{
	printf("初学C语言");
	return 0;
}
</code></pre> 
<p><em>这里说明下：</em></p> 
<ul><li> <p>由于<strong>printf的使用</strong>，需要引入头文件#include &lt;stdio.h&gt;。头文件就是为了这个printf函数的实现</p> </li><li> <p>在运行程序的时候，如果使用的是<strong>VS2013版本</strong>的，会发现反应很快，输出一闪而过，这时候就需要设置一下为了看到代码运行的结果。如果用的是VS2013以上的版本，则不需要设置，都已经配置好了。将其子系统那块改成控制台即可。<br> <img src="https://images2.imgbox.com/64/1e/QoUPgn2s_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>一个工程中有且仅有一个main函数</strong></p> 
  <ol><li>一个工程中可以有多个.c文件</li><li>多个.c文件只能有一个main函数</li></ol> </li></ul> 
<h2><a id="__23"></a>三. 数据类型</h2> 
<table><thead><tr><th>代码</th><th>数据类型</th></tr></thead><tbody><tr><td>char</td><td>字符数据类型</td></tr><tr><td>short</td><td>短整型</td></tr><tr><td>int</td><td>整型</td></tr><tr><td>long</td><td>长整型</td></tr><tr><td>long long</td><td>更长的整型</td></tr><tr><td>float</td><td>单精度浮点数</td></tr><tr><td>double</td><td>双精度浮点数</td></tr></tbody></table> 
<ul><li> <p>每种类型的大小（用sizeof来计算，单位byte）<br> <img src="https://images2.imgbox.com/2f/3b/fnj7RcCM_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>注：C语言标准：sizeof(long) &gt;= sizeof(int)</strong></p> </li><li> <p><strong>注：sizeof 是关键字，操作符，不是函数</strong></p> </li><li> <p><em>计算机中的单位</em></p> </li></ul> 
<table><thead><tr><th>English</th><th>名称</th><th>换算</th></tr></thead><tbody><tr><td>bit</td><td>比特</td><td></td></tr><tr><td>byte</td><td>字节</td><td>1 byte = 8 bit</td></tr><tr><td>KB</td><td>千字节</td><td>1 KB = 1024 byte</td></tr><tr><td>MB</td><td>兆字节</td><td>1 MB = 1024 KB</td></tr><tr><td>GB</td><td>吉字节</td><td>1 GB = 1024 MB</td></tr><tr><td>TB</td><td>太字节</td><td>1 TB = 1024 GB</td></tr><tr><td>PB</td><td>Petabyte</td><td>1 PB = 1024 TB</td></tr></tbody></table> 
<ul><li>计算机中识别二进制 - 0和1</li><li>识别八进制 - 0-7</li><li>识别十进制 - 0-9</li></ul> 
<h2><a id="__57"></a>四. 变量和常量</h2> 
<h3><a id="a_58"></a>a）变量</h3> 
<ul><li>定义：有些数据一定可变：工资、年龄、体重</li><li><strong>变量的生命周期指的是变量的创建到变量的销毁之间的一个时间段</strong></li></ul> 
<h4><a id="1_62"></a>1）局部变量</h4> 
<ul><li><strong>局部变量的作用域是变量所在的局部范围</strong></li><li><strong>局部变量的生命周期是：进入作用域生命周期开始，出作用域生命周期结束</strong></li></ul> 
<h4><a id="2_66"></a>2）全局变量</h4> 
<ul><li><strong>全局变量的作用域是整个工程</strong></li><li><strong>全局变量的生命周期是：整个程序的生命周期</strong></li></ul> 
<p><strong>注意：</strong><br> <img src="https://images2.imgbox.com/a8/76/6lGWVuv0_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>局部变量global变量的定义没有什么问题</strong></li><li><strong>当局部变量和全局变量同名的时候，局部变量优先使用</strong></li></ul> 
<h3><a id="b_78"></a>b）常量</h3> 
<ul><li>定义：有些数据一定不变：血型、性别、圆周率</li></ul> 
<h4><a id="1_81"></a>1）字面常量（相当于直接写）</h4> 
<p><img src="https://images2.imgbox.com/e5/1a/X9g1n5ZU_o.png" alt="List item"></p> 
<h4><a id="2const_85"></a>2）const修饰的常量</h4> 
<p><img src="https://images2.imgbox.com/e0/b6/4UOrzuAo_o.png" alt="List item"></p> 
<ul><li><strong>const修饰的常变量不能被修改</strong>，因为const定义的基本类型的变量保存的是实际的内存地址, 内存地址不能动</li><li>pai 被称为 const 修饰的常变量， const 修饰的常变量 在C语言中只是在语法层面限制了变量 pai 不能直接被 改变，但是 pai 本质上还是一个变量的，所以叫常变量</li></ul> 
<h4><a id="3define_91"></a>3）#define定义的标识符常量</h4> 
<p><img src="https://images2.imgbox.com/1d/f7/yHicNowS_o.png" alt="在这里插入图片描述"></p> 
<ul><li>#define定义的标识符不占内存，只是一个临时 的符号，预编译后这个符号就不存在了</li></ul> 
<h4><a id="4_96"></a>4）枚举常量</h4> 
<p><img src="https://images2.imgbox.com/ac/d4/NCPEpU6J_o.png" alt="在这里插入图片描述"></p> 
<ul><li>枚举常量的默认是从0开始，依次向下递增1的</li></ul> 
<h2><a id="__102"></a>五. 字符串+转义字符+注释</h2> 
<h3><a id="a_103"></a>a）字符串</h3> 
<ul><li>定义：一串字符，用双引号括起来的一串字符</li><li><strong>字符串的结束标志是\0的转义字符</strong></li><li><strong>计算字符串长度的时候，\0是结束标志，不算作字符串的内容</strong></li></ul> 
<h4><a id="1_108"></a>1）字符数组</h4> 
<ul><li>定义： 字符数组是一组相同类型的元素<br> <img src="https://images2.imgbox.com/90/64/cKkmagWw_o.png" alt="在这里插入图片描述"></li><li><strong>当方括号里面不写这个数组有几个元素的时候， 会根据后面数据的大小自动分配</strong></li><li><strong>\0是隐藏的</strong><br> <img src="https://images2.imgbox.com/04/76/Fi2lroNa_o.png" alt="在这里插入图片描述"></li><li><strong>arr2的后面的内存是未知的，而arr1后面有着字 符串结束标志\0</strong></li><li><strong>注：对于字符串来说，\0是至关重要的，后面一定要 有\0，不然后面的空间识别不出，当运行后就会 显示乱码</strong></li></ul> 
<p><em><strong>计算字符串的长度</strong></em><br> <img src="https://images2.imgbox.com/e3/29/MRKwsEwB_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>注：由于arr2后面没有\0字符串结束标志，则arr2是不会结束的，会一直走下去，而走下去是未知的，直到碰到结束标志才会停止，所以arr2打印出来的长度是一个随机值</strong><br> <img src="https://images2.imgbox.com/a2/7e/6BObyeRL_o.png" alt="在这里插入图片描述"></li><li><strong>这个警告出来，是因为没有引入头文件&lt;string.h&gt;，引入就可以安全的使用strlen了</strong></li></ul> 
<h3><a id="b_123"></a>b）转义字符</h3> 
<p><img src="https://images2.imgbox.com/7d/a9/NAGeDtzg_o.png" alt="在这里插入图片描述"></p> 
<ul><li><em>计算长度</em><br> <img src="https://images2.imgbox.com/4f/60/5JONREjj_o.png" alt="在这里插入图片描述"></li><li><strong>这里输出14是因为，\328看上去应该是一个八进制的数据，那应该算一个字符，可以\328的个位是8，而八进制里面只有0-7，没有8.所以\328看成\32转义字符和8，算两个字符</strong></li><li><em>打印一个单引号</em>（\c是打印单个字符）</li></ul> 
<pre><code class="prism language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> <span class="token char">'\''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li><em>打印一个字符串，字符串内容是双引号</em></li></ul> 
<pre><code class="prism language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token string">"\""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li><em><strong>ASCII码值</strong></em><br> <img src="https://images2.imgbox.com/ec/29/bzOu6p7C_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/da/e3/K9QDcS1C_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="c_143"></a>c）注释</h3> 
<p>推荐一本书《高质量C/C++编程指南》林锐PDF</p> 
<ul><li>定义：用来解释复杂代码</li><li>//是C++的注释风格</li><li>/**/是C语言的注释风格 - 但不支持嵌套注释</li><li><strong>一般来说，习惯用//</strong><br> <img src="https://images2.imgbox.com/f3/c5/WlymR8X2_o.png" alt="在这里插入图片描述"></li></ul> 
<h2><a id="__151"></a>六. 选择语句（分支语句）</h2> 
<h3><a id="aif_152"></a>a）if语句</h3> 
<ul><li><strong>语法结构：</strong></li></ul> 
<pre><code class="prism language-c"><span class="token comment">//第一种：</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span>
	语句<span class="token punctuation">;</span>

<span class="token comment">//第二种：</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span>
	语句<span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">else</span>
	语句<span class="token number">2</span><span class="token punctuation">;</span>

<span class="token comment">//第三种：多分支</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token number">1</span><span class="token punctuation">)</span>
	语句<span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token number">2</span><span class="token punctuation">)</span>
	语句<span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">else</span>
	语句<span class="token number">3</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>C语言是如何表示真和假你？ - <strong>非0就是真，0就是假</strong></li><li><strong>注：if、else这些语句都默认只控制一行，若想控制多行，就用{}包起来</strong></li><li><strong>注：else和它离得最近的if匹配，不看缩进对齐</strong></li></ul> 
<h3><a id="bswitch_178"></a>b）switch语句</h3> 
<ul><li>常常用于多分支的情况<br> <img src="https://images2.imgbox.com/c7/38/IvWaY3Fk_o.png" alt="在这里插入图片描述"></li><li>注意：<strong>switch和case后面一定要整型的，而且case后面 还需要是常量或者常量表达式</strong></li><li><strong>字符也可以，因为字符底层存储的是ASCII码 值，值必须要是整型和常量</strong><br> <img src="https://images2.imgbox.com/b4/6e/WODwx9wA_o.png" alt="在这里插入图片描述"></li><li><strong>这种情况是因为没人阻止case的时候，就会一直跑下去输入几，就从哪个入口进去，前面的不执行</strong></li><li><strong>因此，在每一个case后面都要加上break</strong></li><li><strong>break语句的实际效果就是把语句列表划分为不同的分支部分</strong></li></ul> 
<h4><a id="1default_187"></a>1）default</h4> 
<ul><li><strong>所有case语句都不符合，但不会执行任何操作，为了看到是否正确，就可以加default，直接在下面写代码，若输入不符 合case语句，就执行default语句</strong></li><li><strong>同时default没有顺序问题，放哪都行，默认放后面， 只要满足需求，想怎么写就怎么写</strong></li></ul> 
<h2><a id="__190"></a>七. 循环语句</h2> 
<h3><a id="awhile_191"></a>a）while语句</h3> 
<p><img src="https://images2.imgbox.com/b2/40/nGH9P3gA_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p>执行流程<br> <img src="https://images2.imgbox.com/65/ea/5p6fCv9Z_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>在while循环中，break用于永久的终止循环在while循环中，continue的作用是跳过本次循环continue 后面的代码直接去判断部分，看是否进行下一次循环</strong></p> </li><li> <p><strong>例子，打印0-100之间的奇数</strong></p> </li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> i <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		i<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="bfor_216"></a>b）for语句</h3> 
<p><img src="https://images2.imgbox.com/85/06/3pWm3eRO_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>表达式1为初始化部分，用于初始化循环变量的</strong></li><li><strong>表达式2为条件判断部分，用于判断循环时候终止</strong></li><li><strong>表达式3为调整部分，用于循环条件的调整</strong></li></ul> 
<p>执行流程<br> <img src="https://images2.imgbox.com/1b/bf/VqTRQ65F_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>for循环特点：初始化只有一次</strong></li></ul> 
<h3><a id="cdo__while_225"></a>c）do … while语句</h3> 
<p><img src="https://images2.imgbox.com/6c/c5/osC7SA7C_o.png" alt="在这里插入图片描述"></p> 
<p>执行流程<br> <img src="https://images2.imgbox.com/5f/51/Y0BvxT7x_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>do…while循环是肯定要执行一次的，先不关三七二十一，先执行，再来判断是否要继续循环，另外循环语句可能是一段代码，用{}包起来</strong></li></ul> 
<h3><a id="dgoto_231"></a>d）goto语句</h3> 
<ul><li><strong>C语言中提供了可以随意滥用的 goto语句和标记跳转的标号。从理论上 goto语句是没有必要的，实践中没有goto语句也可以很容易的写出代码</strong></li><li><strong>但是某些场合下goto语句还是用得着的，最常见的用法就是终止程序在某些深度嵌套的结构的处 理过程</strong></li><li><strong>比如：一次跳出两个循环或多个循环</strong><br> <img src="https://images2.imgbox.com/1d/ef/2O1KygO8_o.png" alt="在这里插入图片描述"></li><li><strong>另外注意：goto语句只能在一个函数范围内跳转，不能跨函数</strong></li></ul> 
<h2><a id="__237"></a>八. 函数</h2> 
<ul><li><strong>特点：简化代码，代码复用</strong></li></ul> 
<h3><a id="a_239"></a>a）函数分类</h3> 
<h4><a id="1_240"></a>1）库函数</h4> 
<ul><li><strong>IO函数 printf scanf getchar putchar</strong></li><li><strong>字符串操作函数 strcmp strlen</strong></li><li><strong>字符操作函数 toupper小写转大写</strong></li><li><strong>内存操作函数 memcpy memcmp mesmset</strong></li><li><strong>时间/日期函数 time</strong></li><li><strong>数学函数 sqrt pow</strong></li><li><strong>其他库函数</strong></li></ul> 
<p><strong>注意：库函数的使用必须调用头文件</strong><br> <img src="https://images2.imgbox.com/58/ea/Dzbpog8P_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>使用库函数的参考工具（如上）</strong><br> <img src="https://images2.imgbox.com/8c/80/O0Yvufrr_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="2_255"></a>2）自定义函数</h4> 
<ul><li><strong>自定义函数和库函数一样，有函数名，返回值类型和函数参数。但是不一样的是这些都是我们自己来设计</strong></li></ul> 
<p><img src="https://images2.imgbox.com/17/04/vCxB8Iaz_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="b_260"></a>b）函数参数</h3> 
<h4><a id="1_261"></a>1）实际参数（实参）</h4> 
<p><img src="https://images2.imgbox.com/94/96/uQUW16tx_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>实参其实就需要传入地址，若改变，原来的值也会改变，因为是同地址</strong></li></ul> 
<h4><a id="2_265"></a>2）形式参数（形参）</h4> 
<p><img src="https://images2.imgbox.com/79/58/CSYvO83F_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>形参只需要传入数值，不会改变原先的值</strong></li></ul> 
<h3><a id="c_269"></a>c）函数调用</h3> 
<h4><a id="1_270"></a>1）传值调用</h4> 
<p><img src="https://images2.imgbox.com/fa/11/0OnfhsST_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_273"></a>2）传址调用</h4> 
<p><img src="https://images2.imgbox.com/0f/0d/C2Udsx1S_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="d_276"></a>d）函数的嵌套调用和链式访问</h3> 
<ul><li><strong>函数和函数之间可以根据实际的需求 进行组合的，也就是互相调用的</strong></li></ul> 
<h4><a id="1_278"></a>1）嵌套调用</h4> 
<p><img src="https://images2.imgbox.com/1e/f3/BS0as54w_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>注意：函数可以嵌套调用，但不能嵌套定义</strong></li></ul> 
<h4><a id="2_282"></a>2）链式访问</h4> 
<p><img src="https://images2.imgbox.com/e7/12/IPgiPVGF_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>把一个函数的返回值作为另外一个函数的参数</strong></li></ul> 
<p><strong>例如：</strong><br> <img src="https://images2.imgbox.com/e8/74/p0A45pSg_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ea/8b/orLxLDwL_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>答案为4321</strong></li><li><strong>由于printf返回的是打印在屏幕上的字符的个数</strong></li></ul> 
<h3><a id="e_293"></a>e）函数的声明和定义</h3> 
<h4><a id="1_294"></a>1）函数声明</h4> 
<ol><li><strong>告诉编译器有一个函数叫什么，参数是什么，返回类型是什么。 但是具体是不是存在，函数声明决定不了</strong></li><li><strong>函数的声明一般出现在函数的使用之前。要满足先声明后使用</strong></li><li><strong>函数的声明一般要放在头文件中的</strong><br> <img src="https://images2.imgbox.com/6c/ee/yfTkXxAf_o.png" alt="在这里插入图片描述"></li></ol> 
<h4><a id="2_302"></a>2）函数定义</h4> 
<ul><li><strong>函数的定义是指函数的具体实现，交待函数的功能实现</strong><br> <img src="https://images2.imgbox.com/56/84/tp861hsT_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="f_306"></a>f）函数递归</h3> 
<ul><li>一个过程或函数在其定义或说明中有直接或间接调用自身的，一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。</li><li>只需少量的程序就可描述出解题过程所需要的多 次重复计算，大大地减少了程序的代码量</li><li><strong>递归的主要思考方式在于：把大事化小</strong></li></ul> 
<p><strong>递归的两个必要条件</strong></p> 
<ol><li><strong>存在限制条件，当满足这个限制条件的时候，递归便不再继续。</strong></li><li><strong>每次递归调用之后越来越接近这个限制条件</strong></li></ol> 
<h2><a id="__315"></a>九. 数组</h2> 
<ul><li>C语言中给了数组的定义：一组相同类型元素的集合</li><li>C语言规定：数组的每个元素都有一个下标，下标是从0开始的</li><li>因此，数组可以通过下标进行访问<br> <img src="https://images2.imgbox.com/65/2a/2d8JLDyP_o.png" alt="在这里插入图片描述"></li><li><strong>数组的大小可以通过计算得到，用sizeof，总大小 / 首元素大小</strong></li><li><strong>不能用strlen来求，因为strlen求的是字符串的大 小，而字符串是有结束符号的，而数组里是没有 字符串结束符号\0</strong></li></ul> 
<p><img src="https://images2.imgbox.com/9c/50/vdfQ9mEv_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>不完全初始化，剩余默认为0</strong></li><li><strong>除号两端都是整数，执行整数除法，如果有一端是小数，执行小数除法</strong></li></ul> 
<h3><a id="a_326"></a>a）一维数组</h3> 
<ol><li><strong>一维数组在内存中是连续存放的</strong></li><li><strong>随着数组下标的增长，地址是由低到高的</strong></li></ol> 
<h4><a id="1_329"></a>1）一维数组的创建</h4> 
<p><img src="https://images2.imgbox.com/1f/74/uQHiQNA2_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/aa/f2/73HNzdtP_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>注意：一定要用常量表达式</strong></li><li><strong>这种变量的表达式dev C++支持，C99也支持，VS不支持变长数组</strong></li><li><strong>变长数组 - 数组的大小是变量</strong></li><li><strong>数组创建，在C99标准之前， [] 中要给一个常量才可以，不能使用变量。在C99标准支持了变长数组的概念</strong></li></ul> 
<h4><a id="2_337"></a>2）一维数组的初始化</h4> 
<p><img src="https://images2.imgbox.com/4f/c5/a38DgyMO_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="b_340"></a>b）二维数组</h3> 
<ul><li><strong>二维数组随着数组下标的增长，地址也是由低到高的</strong></li></ul> 
<h4><a id="1_342"></a>1）二维数组的创建</h4> 
<p><img src="https://images2.imgbox.com/d2/77/ImSSDZYB_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_345"></a>2）二维数组的初始化</h4> 
<p><img src="https://images2.imgbox.com/ea/cd/0Px25UA7_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>二维数组如果可以初始化，行可以省略，但列不能省略</strong></li></ul> 
<h3><a id="c_348"></a>c）数组越界</h3> 
<ul><li><strong>数组的下标是有范围限制的</strong></li><li><strong>数组的下规定是从0开始的，如果数组有n个元素，最后一个元素的下标就是n-1</strong></li><li><strong>所以数组的下标如果小于0，或者大于n-1，就是数组越界访问了，超出了数组合法空间的访问</strong></li><li><strong>注意：C语言本身是不做数组下标的越界检查，编译器也不一定报错，但是编译器不报错，并不意味着程序就是正确的</strong></li></ul> 
<h3><a id="d_353"></a>d）数组作为函数参数</h3> 
<ul><li><strong>数组传参的时候，传递的其实是数组首元素的地址</strong></li><li><strong>数组传参一般也要传入总大小，即sizeof。因此sizeof需要在主函数里创建</strong></li></ul> 
<h3><a id="e_356"></a>e）数组名</h3> 
<ul><li><strong>数组名是数组首元素地址</strong></li></ul> 
<p><img src="https://images2.imgbox.com/89/50/AwZM48u4_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>&amp;arr[0]与arr的返回值相同，两者的意思相同，而&amp;arr和arr的返回值相同，但表达的意思不同</strong></li><li><strong>arr取出来的是首元素的地址</strong></li><li><strong>&amp;arr取出来的是整个数组的地址，而整个数组的 地址，也是从首元素开始，所以地址就是首元素 的地址</strong></li></ul> 
<p><strong>但也有两个例外</strong></p> 
<ol><li><strong>sizeof(数组名)，计算整个数组的大小，sizeof内部单独放一个数组名，数组名表示整个数组</strong></li><li><strong>&amp;数组名，取出的是数组的地址。&amp;数组名，数组名表示整个数组</strong></li></ol> 
<p><img src="https://images2.imgbox.com/8d/16/6TQ7KG8f_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>arr+1取出来的地址与arr只相差4</strong></li><li><strong>&amp;arr+1取出来的地址与&amp;arr相差了40，即相差整个数组</strong></li></ul> 
<h2><a id="__375"></a>十. 操作符</h2> 
<h3><a id="a_376"></a>a）算术操作符</h3> 
<ul><li>加 减 乘 除 取余（+ - * / %）<br> <img src="https://images2.imgbox.com/3a/57/v96KJ4XS_o.png" alt="在这里插入图片描述"></li></ul> 
<ol><li><strong>除了 % 操作符之外，其他的几个操作符可以作用于整数和浮点数</strong></li><li><strong>对于 / 操作符如果两个操作数都为整数，执行整数 除法。而只要有一边是浮点数执行的就是浮点数除法</strong></li><li><strong>% 操作符的两个操作数必须为整数。返回的是整除之后的余数</strong></li></ol> 
<h3><a id="b_382"></a>b）移位操作符</h3> 
<ul><li>右移 左移（&gt;&gt; &lt;&lt;）</li></ul> 
<h4><a id="1_385"></a>1）左移</h4> 
<ul><li><strong>二进制移动位数，总体移，左移：左边抛弃、右边补0</strong><br> <img src="https://images2.imgbox.com/8f/a8/HtF1yquf_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="2_388"></a>2）右移</h4> 
<ul><li><strong>编译器中一般采用算术移位</strong></li></ul> 
<h5><a id="x1_390"></a>x1）逻辑移位</h5> 
<ul><li><strong>左边用0填充，右边丢弃</strong></li></ul> 
<h5><a id="x2_392"></a>x2）算术移位</h5> 
<ul><li><strong>左边用原该值的符号位填充，右边丢弃</strong></li></ul> 
<p><strong>注意点：</strong></p> 
<ol><li><strong>移位操作符的操作数只能是整</strong>数</li><li><strong>参与左移或者右移的操作符，在没被赋值的情况下，不会改变原先的值，即b = a &lt;&lt; 1。a的值不变</strong></li><li><strong>不管左移还是右移，都是补码在移动，因此要注意负数先将其转换成补码，再来运算</strong></li></ol> 
<h3><a id="c_400"></a>c）位操作符</h3> 
<h4><a id="1_401"></a>1）&amp;:按位与</h4> 
<ul><li>参与运算的两数各对应的二进位相与。只要对应的二个二进位都为1时，结果位就为1</li></ul> 
<h4><a id="2_403"></a>2）|:按位或</h4> 
<ul><li>参与运算的两数各对应的二进位相或。只要对应的二个二进位有一个为1时，结果位就为1</li></ul> 
<h4><a id="3_405"></a>3）^:按位异或</h4> 
<ul><li>两个相应的二进制位值不同则为1,否则为0</li></ul> 
<p><strong>注意点：</strong></p> 
<ul><li><strong>都以补码的形式出现，即用补码来进行按位操作，如果是负数，还要考虑第一位，要转换成补码在来运算</strong></li><li><strong>他们的操作数必须是整数</strong></li></ul> 
<h3><a id="d_411"></a>d）赋值操作符</h3> 
<p><img src="https://images2.imgbox.com/56/e9/OjpunCWA_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="e_414"></a>e）单目操作符</h3> 
<p><img src="https://images2.imgbox.com/c8/fb/OqysNZ4H_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1_416"></a>1）！逻辑反操作</h4> 
<ul><li>0表示假，1表示真，把真变成假，把假变成真</li></ul> 
<h4><a id="2sizeof_418"></a>2）sizeof</h4> 
<ul><li>是一个操作符，不是函数，用来计算类型或者变量的大小</li><li><strong>函数后面的括号不能删去，而操作符后面的括号 可以省去（判别是否为函数的方法）</strong></li><li><strong>一个数组的大小为4byte（字节）</strong><br> <img src="https://images2.imgbox.com/39/0d/0Xje5Pg3_o.png" alt="在这里插入图片描述"></li><li><strong>short的单位为2字节</strong></li><li><strong>sizeof括号里是不进行运算的</strong></li></ul> 
<h4><a id="3__426"></a>3）~ 按（二进制）位取法</h4> 
<ul><li>把所有二进制中数字，1变成0，0变成1</li><li>0的二进制：0000000000000000000000000000000</li><li>按位取法转换后：11111111111111111111111111111111</li></ul> 
<p><strong>补充：整数在内存中存储的是补码~，所以要将其转换成原码</strong></p> 
<ul><li><strong>一个整数的二进制表示有三种：原码、反码、补码</strong></li><li><strong>因为一个数组大小为4个字节，也就是32bit，转换成二进制就是32位</strong><br> <img src="https://images2.imgbox.com/4b/e8/HO4TH4Sr_o.png" alt="在这里插入图片描述"></li><li><strong>注：正整数：原码、反码、补码相同</strong></li></ul> 
<h4><a id="4__436"></a>4）++ 前置、后置++</h4> 
<ul><li> <p><em><strong>前置++ 先++，后使用</strong></em><br> <img src="https://images2.imgbox.com/dd/3b/SAf5Eny3_o.png" alt="在这里插入图片描述"></p> </li><li> <p><em><strong>后置++ 先使用，后++</strong></em><br> <img src="https://images2.imgbox.com/68/d2/cMACsLho_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h4><a id="5___443"></a>5）-- 前置、后置 –</h4> 
<ul><li>同理于4）++前置、后置++</li></ul> 
<h4><a id="6_445"></a>6）（类型）强制类型转换</h4> 
<p><img src="https://images2.imgbox.com/a4/63/ngsS5UFc_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="7________447"></a>7）&amp; 取地址操作符 * 解引用操作符</h4> 
<p><img src="https://images2.imgbox.com/b7/cc/uC3yGoO9_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="f_451"></a>f）关系操作符</h3> 
<p><img src="https://images2.imgbox.com/bf/49/5JTPijrm_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>个等号是赋值，两个等号是判断</strong></li><li><strong>字符串的相等需要用到strcmp函数，不能用两个等号判断</strong></li></ul> 
<h3><a id="g_456"></a>g）逻辑操作符</h3> 
<p><img src="https://images2.imgbox.com/30/86/xNjwRNfc_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>逻辑操作符（0为假，1为真）</strong></li></ul> 
<ol><li><strong>&amp;&amp; - 逻辑与（只有两个都为真时才为真）</strong></li></ol> 
<ul><li><strong>当逻辑与已经判断为假时，后面的就不用在进行了</strong></li></ul> 
<ol start="2"><li><strong>|| - 逻辑或（只有两个都为假才为假）</strong></li></ol> 
<ul><li><strong>当逻辑或为真时，后面就不用在进行了</strong></li></ul> 
<h3><a id="h_463"></a>h）条件操作符</h3> 
<p><img src="https://images2.imgbox.com/d2/b4/vfmyW9Jm_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>exp1 成立，exp2表达式计算，整个表达式的结果是：exp2的结果</strong></li><li><strong>exp1不成立，exp3表达式计算，整个表达式的结果是：exp3的结果</strong></li></ul> 
<h3><a id="i_467"></a>i）逗号表达式</h3> 
<p><img src="https://images2.imgbox.com/02/d8/rN7YOesP_o.png" alt="在这里插入图片描述"></p> 
<ul><li>逗号隔开的一串表达式<br> <img src="https://images2.imgbox.com/a9/1d/TSGlLvEf_o.png" alt="在这里插入图片描述"></li><li><strong>从左到右依此计算的</strong></li><li><strong>整个表达式的结果是最后一个表达式的结果</strong></li><li><strong>有些时候可能前面的表达式并没有作用，但是还是要注意看</strong></li></ul> 
<h3><a id="j_474"></a>j）下标引用、函数调用和结构成员</h3> 
<p><img src="https://images2.imgbox.com/48/2d/PTzi2w5v_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1_476"></a>1）下标引用[]</h4> 
<p><img src="https://images2.imgbox.com/59/02/RSoOxVOV_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>操作数：一个数组名 + 一个索引值</strong><br> <img src="https://images2.imgbox.com/47/44/E94YzIQI_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="2_481"></a>2）函数调用()</h4> 
<p><img src="https://images2.imgbox.com/cf/f3/Pa3SDFoC_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>接受一个或者多个操作数：第一个操作数是函数名，剩余的操作数就是传递给函数的参数</strong><br> <img src="https://images2.imgbox.com/55/25/2GuTyKOi_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="k_485"></a>k）表达式求值</h3> 
<ul><li><strong>在使用这些操作符的时候，需要注意各种运算顺序</strong></li></ul> 
<h4><a id="1_487"></a>1）隐式类型转换</h4> 
<ul><li><strong>C的整型算术运算总是至少以缺省整型类型的精度来进行的。为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升</strong></li></ul> 
<h5><a id="x1_489"></a>x1）整形提升</h5> 
<ul><li><strong>整形提升是按照变量的数据类型的符号位来提升的</strong></li></ul> 
<p><img src="https://images2.imgbox.com/c0/6c/4VRSoPZq_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>按照符号位来提升，符号位为0就全为0， 符号为1，就高位补充1</strong></li><li><strong>都是用补码进行整型提升，因此负数要格外注意</strong></li><li><strong>只有当自身的大小不足int类型的大小（4个字节）才需要进行整形提升</strong></li><li><strong>比int大的不需要整形提升</strong></li><li><strong>而需要整形提升的只有char类型和short类型，因为char类型是1个字节，short类型是2个字节</strong></li></ul> 
<p><img src="https://images2.imgbox.com/02/39/Lwu9OnkD_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>+c和-c是参与运算的，因此需要整型提升</strong></li><li><strong>%u就是打印一个无符号数</strong></li><li><strong>%d是打印有符号整数</strong></li></ul> 
<h4><a id="2_505"></a>2）算术转换</h4> 
<ul><li><strong>如果某个操作符的各个操作数属于不同的类型， 那么除非其中一个操作数的转换为另一个操作数的类型，否则操作就无法进行</strong></li></ul> 
<p><img src="https://images2.imgbox.com/84/ae/GEFh40LF_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>这个是向上转换的，比如int和float进行组合，就需要将int转换成float类型</strong></li><li><strong>如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运算</strong></li></ul> 
<h4><a id="3_513"></a>3）操作符的属性</h4> 
<p><strong>复杂表达式的求值有三个影响的因素</strong></p> 
<ol><li><strong>操作符的优先级</strong></li><li><strong>操作符的结合性</strong></li><li><strong>是否控制求值顺序</strong></li></ol> 
<ul><li><strong>两个相邻的操作符先执行哪个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。操作符优先级</strong></li></ul> 
<p><img src="https://images2.imgbox.com/82/a9/yUXqpB3P_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>从上往下，优先级是从高到低</strong></li><li><strong>结合性</strong></li></ul> 
<ol><li><strong>N/A：说明无结合性，不需要考虑结合性</strong></li><li><strong>L-R：从左向右结合</strong></li><li><strong>R-L：从右向左结合</strong></li></ol> 
<ul><li><strong>是否控制求值顺序：就是当前面的判断可以代表 全部时，后面的就可以不需要进行</strong></li><li><strong>有4个：逻辑与、逻辑或、条件操作符、逗号操作符</strong></li></ul> 
<h2><a id="__532"></a>十一. 常见关键字</h2> 
<ul><li><strong>C语言提供的，不能自己创建关键字</strong></li><li><strong>关键字不能做变量名</strong></li></ul> 
<p><img src="https://images2.imgbox.com/1f/12/3bFf5erB_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="aauto_537"></a>a）auto</h3> 
<ul><li>自动的 - 每个局部变量都是auto修饰的</li></ul> 
<h3><a id="bextern_539"></a>b）extern</h3> 
<ul><li>用来声明外部符号的</li><li>声明不需要指定的值</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">extern</span> <span class="token keyword">int</span> g_val<span class="token punctuation">;</span>
</code></pre> 
<h3><a id="cregister_547"></a>c）register</h3> 
<ul><li>寄存器关键字<br> <img src="https://images2.imgbox.com/dd/a2/frDvHcWs_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/df/66/IEoQLwtZ_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="dsigned_552"></a>d）signed</h3> 
<ul><li>有符号的，比如10，-20</li></ul> 
<h3><a id="eunsigned_554"></a>e）unsigned</h3> 
<ul><li>无符号的</li></ul> 
<h3><a id="fstatic_556"></a>f）static</h3> 
<ul><li>静态的</li></ul> 
<h4><a id="1static_558"></a>1）static修饰局部变量</h4> 
<ul><li><strong>改变了局部变量的生命周期（本质上改变了变量的存储类型）</strong></li><li><strong>本身局部变量在所在范围结束后，就会自动销毁，而static修饰局部变量后，就不会销毁，直到程序结束</strong></li><li><strong>让静态局部变量出了作用域依然存在，到程序结束，生命周期才结束</strong></li></ul> 
<h4><a id="2static_562"></a>2）static修饰全局变量</h4> 
<ul><li><strong>使得整个全局变量只能在自己所在的源文件(.c) 内部可以使用，而其他源文件不能使用</strong><br> <img src="https://images2.imgbox.com/1a/5d/1saLDQiv_o.png" alt="在这里插入图片描述"></li><li>经过static修饰后<br> <img src="https://images2.imgbox.com/a9/17/KCONPSZL_o.png" alt="在这里插入图片描述"></li><li><strong>全局变量，在其他源文件内部可以被使用。是因为全局变量具有外部链接属性，但是被static修饰后，就变成了内部链接属性，其他源文件就不能链接到整个静态的全局变量了</strong></li></ul> 
<h4><a id="3static_568"></a>3）static修饰函数</h4> 
<p><img src="https://images2.imgbox.com/01/da/jOifWsRL_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>使得函数只能在自己所在的源文件内部使用，不能在其他源文件内部使用</strong></li><li><strong>本质上，static是将函数的外部链接属性变成了内部链接属性！（和static修饰全局变量一样）</strong></li></ul> 
<h3><a id="gunion_573"></a>g）union</h3> 
<ul><li>联合体（共用体）</li></ul> 
<h3><a id="hvoid_575"></a>h）void</h3> 
<ul><li>无-空</li></ul> 
<h3><a id="itypedef_577"></a>i）typedef</h3> 
<ul><li>类型定义（类型重命名）<br> <img src="https://images2.imgbox.com/34/ea/00ClFeI7_o.png" alt="在这里插入图片描述"></li><li><strong>将 unsigned int 重命名为 u_int</strong></li></ul> 
<p><em><strong>补充：</strong></em></p> 
<ul><li><strong>define - 是不是关键字？NO - 预处理指令</strong></li><li><strong>include - 是不是关键字？NO - 预处理指令</strong></li></ul> 
<h2><a id="_define_585"></a>十二. define定义常量和宏</h2> 
<h3><a id="adefine_586"></a>a）define定义常量</h3> 
<p><img src="https://images2.imgbox.com/53/d0/OpyLIZb1_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="bdefine_589"></a>b）define定义宏</h3> 
<p><img src="https://images2.imgbox.com/8f/c6/PnW76St2_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="__592"></a>十三. 指针</h2> 
<h3><a id="a_593"></a>a）指针的基本认识</h3> 
<ul><li><strong>内存怎么编号？</strong><br> <strong>32位 - 32根地址线 - 物理线 - 通电 - 正电1/负电0<br> 64位同理</strong></li><li><strong>一个这样的内存单元多大</strong><br> <img src="https://images2.imgbox.com/26/91/GpBYitGN_o.png" alt="在这里插入图片描述"></li><li><strong>指针都是4个字节（32位）</strong></li><li><strong>一个内存单元是一个字节，然后分配地址</strong><br> <img src="https://images2.imgbox.com/d6/f1/7GBAFhMV_o.png" alt="在这里插入图片描述"></li><li>打印地址<br> <img src="https://images2.imgbox.com/3c/02/LV6Y10ap_o.png" alt="在这里插入图片描述"></li><li><strong>取出变量地址：a有4个字节，每一个字节代表一个地址，取出来的是较小的地址（第一个地址）</strong></li><li><strong>%p专门用来打印地址</strong></li><li><strong>pa用来存放地址，在C语言中叫pa是指针变量</strong></li><li>*<strong>说明pa是指针变量</strong></li><li><strong>int 说明pa指向的对象是int类型的</strong></li></ul> 
<p>储存地址，需要定义指针变量<br> <img src="https://images2.imgbox.com/e8/cd/cldwMMeZ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/14/db/Cdyuv5I5_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>指针还可以解引用，可以间接改变数值</strong></li></ul> 
<p><strong>总结：</strong></p> 
<ul><li> <p><strong>指针的大小是相同的！，32位系统是4， 64位系统是8</strong></p> </li><li> <p><strong>指针是用来存放地址的</strong></p> </li><li> <p><strong>指针需要多大空间，取决于地址的存储需要多大空间<br> 32位 32bit - 4byte <br> 64位 64bit - 8byte</strong></p> <h3><a id="b_622"></a>b）指针的意义</h3> 
  <ol><li><strong>指针类型决定了：指针解引用的权限有多大，char - 1个字节，int - 4个字节， double - 8个字节</strong></li><li><strong>指针类型决定了,指针走一步，能走多远（步长）</strong></li></ol> </li><li> <p><strong>char</strong>* 的指针解引用就只能访问一个字节，而 int* 的指针的解引用就能访问四个字节**</p> <h3><a id="c_626"></a>c）野指针</h3> <h4><a id="1_627"></a>1）指针未初始化</h4> <p><img src="https://images2.imgbox.com/7b/6c/CtKcgDgd_o.png" alt="在这里插入图片描述"></p> <h4><a id="2_630"></a>2）指针越界访问</h4> <p><img src="https://images2.imgbox.com/f4/ed/ZPMjVGlx_o.png" alt="在这里插入图片描述"></p> <h4><a id="3_633"></a>3）指针指向的空间释放</h4> <p><img src="https://images2.imgbox.com/b5/f5/pUks4xXy_o.png" alt="在这里插入图片描述"></p> 
  <ul><li><strong>当a被使用后，退出函数后a会被回收，因此在使用*p的时候</strong>，*<strong>p就不能变化了，因为a消失了</strong></li></ul> </li></ul> 
<h3><a id="d_636"></a>d)如何规避野指针</h3> 
<h4><a id="1_637"></a>1）指针初始化</h4> 
<h4><a id="2_638"></a>2）小心指针越界</h4> 
<h4><a id="3NULL_639"></a>3）指针指向空间释放即使置NULL</h4> 
<p><img src="https://images2.imgbox.com/8f/58/gig6Fak2_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/92/b9/3Ah2sJVd_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>当他指向的空间被释放的时候，也指向空指针指向有效空间，就给有效地址</strong></li><li><strong>因此要么空指针，要么有效地址</strong></li><li><strong>因此给他一个if判断，判断是不是空指针，不是空指针的时候才是有效地址</strong><br> <img src="https://images2.imgbox.com/1c/24/mPe3WYMM_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="4_648"></a>4）避免返回局部变量的地址</h4> 
<h4><a id="5_649"></a>5）指针使用之前检查有效性</h4> 
<h3><a id="e_650"></a>e）指针运算</h3> 
<h4><a id="1_653"></a>1）指针±整数</h4> 
<p><img src="https://images2.imgbox.com/52/c6/DN3vkm3s_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_656"></a>2）指针-指针</h4> 
<p><img src="https://images2.imgbox.com/14/c4/KGrgskdR_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_658"></a>3）指针的关系运算</h4> 
<p><img src="https://images2.imgbox.com/85/89/tEQMcyKw_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>实际在绝大部分的编译器上是可以顺利完成任务的，然而我们还是应该避免这样写，因为标准并不保证它可行</strong></li><li><strong>标准规定：允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较</strong><br> <img src="https://images2.imgbox.com/f5/d6/JLaS80Fh_o.png" alt="在这里插入图片描述"></li><li><strong>指针往前越界不合适 往后越界时为了拿到地址</strong></li></ul> 
<h3><a id="f_665"></a>f）指针和数组</h3> 
<p><img src="https://images2.imgbox.com/ba/66/V3nshH57_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="g_668"></a>g）二级指针</h3> 
<p><img src="https://images2.imgbox.com/71/19/06sxFbkt_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="h_671"></a>h）指针数组</h3> 
<p><img src="https://images2.imgbox.com/61/6a/OHefdHFG_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="__676"></a>十四. 结构体</h2> 
<ul><li>使得C语言有能力描述复杂对象<br> <img src="https://images2.imgbox.com/cb/af/ryiqYZRv_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/27/71/enUcrmId_o.png" alt="在这里插入图片描述"><br> <strong>说明：</strong></li><li><strong>打印单精度就%f , 打印双精度就%lf， 这是字母L，不是数字1</strong></li></ul> 
<p><img src="https://images2.imgbox.com/5d/32/HOvMOIjY_o.png" alt="在这里插入图片描述"><br> <strong>结构的声明</strong><br> <img src="https://images2.imgbox.com/3a/dd/TjZcwnCM_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>struck是固定的语法结构 注意后面还有分号；定义创建了一个自定义的类型</strong><br> <img src="https://images2.imgbox.com/9e/7a/fVwVnPis_o.png" alt="在这里插入图片描述"></li><li><strong>结构的成员可以是标量、数组、指针，甚至是其他结构体</strong><br> <img src="https://images2.imgbox.com/bc/06/f0WGODps_o.png" alt="在这里插入图片描述"></li><li><strong>print1是传值调用 print2是传址调用 print2更好</strong></li><li><strong>print1传入是实参传给形参，s有多大，t就要有多大空间</strong></li><li><strong>print1的改变不会影响s，改变不了s</strong></li><li><strong>而print2传址，就是传入地址，没有开多大的空 间，因为地址一般为4个字节</strong></li><li><strong>而print2还可以改变s的各种值</strong></li><li><strong>函数传参的时候，参数是需要压栈的，如果传递一个结构体对象的时候，结构体过大，参数压栈的系统开销比较大，所以会导致性能的下降。</strong></li><li><strong>因此结构体传参的时候，要传结构体的地址，即传址调用</strong></li></ul> 
<p><strong>压栈</strong><br> <img src="https://images2.imgbox.com/a7/87/HSAa2mUw_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="__701"></a>十五. 补充</h2> 
<h3><a id="ascanf_702"></a>a）scanf函数</h3> 
<ul><li>在VS中，直接使用会报错<br> <img src="https://images2.imgbox.com/aa/f0/9SQjd2bI_o.png" alt="在这里插入图片描述"></li><li><strong>这个提示要求我们使用scanf_s函数，然而scanf_s函数由VS编译提供，而不是C语言标准规定的</strong></li><li><strong>要想使用scanf函数不报错，就得在源文件的第一行加上：</strong></li><li><code>#define _CRT_SECURE_NO_WARNINGS 1</code></li><li><strong>而为了方便，直接将这个代码放入在创建源文件时就自动生成</strong><br> <img src="https://images2.imgbox.com/6c/13/ZeaQXxIW_o.png" alt="在这里插入图片描述"></li><li><strong>找到newc++ file.cpp这个文件，将代码放入即可，若必须管理员才能修改，就将其复制出来在外部修改，在粘贴回去替换。修改完后就会发现创建源文件就会自带上这个代码。找不到这个文件可以使用everything软件查找</strong></li><li><strong>注：一般在后面的参数+&amp;，因为对于scanf函数，它将参数视为地址</strong></li></ul> 
<h3><a id="b_713"></a>b）调试</h3> 
<h4><a id="1_714"></a>1）调试的基本步骤</h4> 
<ol><li><strong>发现程序错误的存在</strong></li><li><strong>以隔离、消除等方式对错误进行定位</strong></li><li><strong>确定错误产生的原因</strong></li><li><strong>提出纠正错误的解决办法</strong></li><li><strong>对程序错误予以改正，重新测试</strong></li></ol> 
<h4><a id="2_720"></a>2）快捷键</h4> 
<h5><a id="x1_721"></a>x1）内存</h5> 
<p><img src="https://images2.imgbox.com/83/70/TTEmEW7r_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="x2_724"></a>x2）调用堆栈</h5> 
<p><img src="https://images2.imgbox.com/4f/a1/gWK3u1iZ_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="x3_727"></a>x3）打断点</h5> 
<p><img src="https://images2.imgbox.com/2f/c5/yNi5DJ22_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>设置条件，F5调试直接跳到此步</strong></li></ul> 
<h5><a id="x4_730"></a>x4）常用快捷键</h5> 
<p><img src="https://images2.imgbox.com/cc/47/lfGOuAwg_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_734"></a>3）常用的调试技巧</h4> 
<h5><a id="x1assert_735"></a>x1）使用assert</h5> 
<ul><li><strong>断言 - 就是判断条件，为假就报错，为真什么事都没有</strong></li><li><strong>就是添加限制条件，触发就报错</strong></li><li><strong>比如说strcpy就不能copy空指针</strong><br> <img src="https://images2.imgbox.com/70/40/8JVa2Yv0_o.png" alt="在这里插入图片描述"></li></ul> 
<h5><a id="x2const_741"></a>x2）尽量使用const</h5> 
<ul><li><strong>const修饰指针变量</strong></li></ul> 
<ol><li><strong>const如果放在*的左边，修饰的是指针指向的内容，保证指针指向的内容不能通过指针来改变。但是指针变量本身的内容可变</strong><br> <img src="https://images2.imgbox.com/48/e1/GvyAM5re_o.png" alt="在这里插入图片描述"></li><li><strong>const如果放在*的右边，修饰的是指针变量本身，保证了指针变量的内容不能修改，但是指针指向的内容，可以通过指针改变</strong><br> <img src="https://images2.imgbox.com/65/b7/x3gWbfhx_o.png" alt=""></li></ol> 
<h5><a id="x3_748"></a>x3）养成良好的编码风格</h5> 
<h5><a id="x4_749"></a>x4）添加必要的注释</h5> 
<h5><a id="x5_750"></a>x5）避免编码的陷阱</h5> 
<h4><a id="4_751"></a>4）编译常见的错误</h4> 
<h5><a id="x1_752"></a>x1）编译型错误</h5> 
<ul><li><strong>直接看错误提示信息（双击），解决问题。或者凭借经验就可以搞定。相对来说简单</strong></li></ul> 
<h5><a id="x2_754"></a>x2）链接型错误</h5> 
<ul><li><strong>看错误提示信息，主要在代码中找到错误信息中的标识符，然后定位问题所在。一般是标识符名不存在或者拼写错误</strong></li></ul> 
<h5><a id="x3_756"></a>x3）运行时错误</h5> 
<ul><li><strong>借助调试，逐步定位问题。最难搞</strong></li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/30d12ec8d51dd1b30aa2c59cd1038bd9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">list集合 去重的3个方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f359709502e56e0cc62afe8eac62d930/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43; Protobuf</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>