<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>PYTHON --类-- 总结 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="PYTHON --类-- 总结" />
<meta property="og:description" content="0. OOP-Python面向对象 Python的面向对象面向对象编程 基础公有私有继承组合，Mixin 魔法函数 魔法函数概述构造类魔法函数运算类魔法函数 1. 面向对象概述（ObjectOriented，OO） OOP思想 接触到任意一个任务，首先想到的是任务这个世界的构成，是由模型构成的 几个名词 OO:面向对象OOA：面向对象的分析OOD：面向对象的设计OOI：xxx的实现OOP：xxx的编程OOA-&gt;OOD-&gt;OOI: 面向对象的实现过程 类和对象的概念 类：抽象名词，代表一个集合，共性的事物对象：具象的事物，单个个体类跟对象的关系 一个具象，代表一类事物的某一个个体一个是抽象，代表的是一大类事物 类中的内容，应该具有两个内容 表明事物的特征，叫做属性(变量)表明事物功能或动作， 称为成员方法(函数) 2. 类的基本实现 类的命名
遵守变量命名的规范大驼峰（由一个或者多个单词构成，每个单词首字母大写，单词跟单词直接相连）尽量避开跟系统命名相似的命名 你如何声明一个类
必须用class关键字类由属性和方法构成，其他不允许出现成员属性定义可以直接使用变量赋值，如果没有纸，许使用None案例 01.py 实例化类
变量 = 类名() #实例化了一个对象 访问对象成员
使用点操作符
obj.成员属性名称 obj.成员方法 可以通过默认内置变量检查类和对象的所有成员
对象所有成员检查
# dict前后各有两个下划线 obj.__dict__ 类所有的成员
# dict前后各有两个下划线 class_name.__dict__ class A(): name = &#34;dana&#34; age = 18 # 注意say的写法，参数由一个self def say(self): self.name = &#34;aaaa&#34; self.age = 200 # 此案例说明 # 类实例的属性和其对象的实例的属性在不对对象的实例属性赋值的前提下， # 指向同一个变量 # 此时，A称为类实例 print(A." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/0a361364ead4a2ba8caf37a1943df832/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-29T10:40:07+08:00" />
<meta property="article:modified_time" content="2019-01-29T10:40:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">PYTHON --类-- 总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="0_OOPPython_0"></a>0. OOP-Python面向对象</h2> 
<ul><li>Python的面向对象</li><li>面向对象编程 
  <ul><li>基础</li><li>公有私有</li><li>继承</li><li>组合，Mixin</li></ul> </li><li>魔法函数 
  <ul><li>魔法函数概述</li><li>构造类魔法函数</li><li>运算类魔法函数</li></ul> </li></ul> 
<h2><a id="1_ObjectOrientedOO_12"></a>1. 面向对象概述（ObjectOriented，OO）</h2> 
<ul><li>OOP思想 
  <ul><li>接触到任意一个任务，首先想到的是任务这个世界的构成，是由模型构成的</li></ul> </li><li>几个名词 
  <ul><li>OO:面向对象</li><li>OOA：面向对象的分析</li><li>OOD：面向对象的设计</li><li>OOI：xxx的实现</li><li>OOP：xxx的编程</li><li>OOA-&gt;OOD-&gt;OOI: 面向对象的实现过程</li></ul> </li><li>类和对象的概念 
  <ul><li>类：抽象名词，代表一个集合，共性的事物</li><li>对象：具象的事物，单个个体</li><li>类跟对象的关系 
    <ul><li>一个具象，代表一类事物的某一个个体</li><li>一个是抽象，代表的是一大类事物</li></ul> </li></ul> </li><li>类中的内容，应该具有两个内容 
  <ul><li>表明事物的特征，叫做属性(变量)</li><li>表明事物功能或动作， 称为成员方法(函数)</li></ul> </li></ul> 
<h2><a id="2__32"></a>2. 类的基本实现</h2> 
<ul><li> <p>类的命名</p> 
  <ul><li>遵守变量命名的规范</li><li>大驼峰（由一个或者多个单词构成，每个单词首字母大写，单词跟单词直接相连）</li><li>尽量避开跟系统命名相似的命名</li></ul> </li><li> <p>你如何声明一个类</p> 
  <ul><li>必须用class关键字</li><li>类由属性和方法构成，其他不允许出现</li><li>成员属性定义可以直接使用变量赋值，如果没有纸，许使用None</li><li>案例 <a href="http://01.py" rel="nofollow">01.py</a></li></ul> </li><li> <p>实例化类</p> <pre><code>  变量 = 类名() #实例化了一个对象
</code></pre> </li><li> <p>访问对象成员</p> 
  <ul><li> <p>使用点操作符</p> <pre><code>   obj.成员属性名称
   obj.成员方法 
</code></pre> </li></ul> </li><li> <p>可以通过默认内置变量检查类和对象的所有成员</p> 
  <ul><li> <p>对象所有成员检查</p> <pre><code>  # dict前后各有两个下划线
  obj.__dict__ 
</code></pre> </li><li> <p>类所有的成员</p> <pre><code>  # dict前后各有两个下划线
 class_name.__dict__
</code></pre> </li></ul> </li></ul> 
<pre><code>class A():
    name = "dana"
    age = 18
    
    # 注意say的写法，参数由一个self
    def say(self):
        self.name = "aaaa"
        self.age = 200

# 此案例说明
# 类实例的属性和其对象的实例的属性在不对对象的实例属性赋值的前提下，
# 指向同一个变量
        
# 此时，A称为类实例
print(A.name)
print(A.age)

print("*" * 20)

# id可以鉴别一个变量是否和另一个变量是同一变量
print(id(A.name))
print(id(A.age))

print("*" * 20)
a = A()

print(a.name)
print(a.age)
print(id(a.name))
print(id(a.age))
        
</code></pre> 
<pre><code># 私有变量案例

class Person():
                # name是共有的成员 
                name = "liuying"
                # __age就是私有成员
                __age = 18
                
p = Person()
# name是公有变量
print(p.name)
# __age是私有变量
print(p.__age)

# name mangling技术
print(Person.__dict__)

p._Person__age = 19
print(p._Person__age)
</code></pre> 
<h2><a id="3_anaconda_117"></a>3. anaconda基本使用</h2> 
<ul><li>anaconda主要是一个虚拟环境管理器</li><li>还是一个安装包管理器</li><li>conda list： 显示anaconda安装的包</li><li>conda env list:显示anaconda的虚拟环境列表</li><li>conda create -n xxx python=3.6: 创建python版本为3.6的虚拟环境，名称为xxx</li></ul> 
<h2><a id="4__124"></a>4. 类和对象的成员分析</h2> 
<ul><li>类和对象都可以存储成员，成员可以归类所有，也可以归对象所有</li><li>类存储成员时使用的是与类关联的一个对象</li><li>独享存储成员是是存储在当前对象中</li><li>对象访问一个成员时，如果对象中没有该成员，尝试访问类中的同名成员，<br> 如果对象中有此成员，一定使用对象中的成员</li><li>创建对象的时候，类中的成员不会放入对象当中，而是得到一个空对象，没有成员</li><li>通过对象对类中成员重新赋值或者通过对象添加成员时，对应成员会保存在对象中，而不会修改类成员</li></ul> 
<pre><code>class Student():
    name = "dana"
    age = 18
    
    # 注意say的写法，参数由一个self
    def say(self):
        self.name = "aaaa"
        self.age = 200
        print("My name is {0}".format(self.name))
        print("My age is {0}".format(self.age))
        
    def sayAgain(s):
      
        print("My name is {0}".format(s.name))
        print("My age is {0}".format(s.age))
          
yueyue = Student()
yueyue.say()
yueyue.sayAgain()

</code></pre> 
<h2><a id="5_self_156"></a>5. 关于self</h2> 
<ul><li>self在对象的方法中表示当前对象本身，如果通过对象调用一个方法，那么该对象会自动传入到当前方法<br> 的第一个参数中</li><li>self并不是关键字，只是一个用于接受对象的普通参数，理论上可以用任何一个普通变量名代替</li><li>方法中有self形参的方法成为非绑定类的方法，可以通过对象访问， 没有self的是绑定类的方法，<br> 只能通过类访问</li><li>使用类访问绑定类的方法时， 如果类方法中需要访问当前类的成员，可以通过 __class__成员名来访问</li></ul> 
<pre><code># 关于self的案例

class A():
    name = " liuying"
    age = 18
    
    def __init__(self):
        self.name = "aaaa"
        self.age = 200
        
    def say(self):
        print(self.name)
        print(self.age)
        
class B():
    name = "bbbb"
    age = 90
    
a = A()
# 此时，系统会默认把a作为第一个参数传入函数
a.say()
   
# 此时，self被a替换
A.say(a)
# 同样可以把A作为参数传入
A.say(A)

# 此时，传入的是类实例B，因为B具有name和age属性，所以不会报错
A.say(B)

# 以上代码，利用了鸭子模型
</code></pre> 
<pre><code>class Teacher():
    name = "dana"
    age = 19
    
    def say(self):
        self.name = "yaona"
        self.age = 17
        print("My name is {0}".format(self.name))
        # 调用类的成员变量需要用 __class__
        print("My age is {0}".format(__class__.age))
    def sayAgain():
        print(__class__.name)
        print(__class__.age )
        print("Hello, nice to see you again")
        
t = Teacher()
t.say()
# 调用绑定类函数使用类名
Teacher.sayAgain()
</code></pre> 
<h2><a id="6__220"></a>6. 面向对象的三大特性</h2> 
<ul><li>封装</li><li>继承</li><li>多态</li></ul> 
<h3><a id="61__225"></a>6.1 封装</h3> 
<ul><li>封装就是对对象的成员进行访问限制</li><li>封装的三个级别： 
  <ul><li>公开，public</li><li>受保护的，protected</li><li>私有的，private</li><li>public，private，protected不是关键字</li></ul> </li><li>判别对象的位置 
  <ul><li>对象内部</li><li>对象外部</li><li>子类中</li></ul> </li><li><a href="http://blog.csdn.net/handsomekang/article/details/40303207">python中下划线使用</a></li><li>私有 
  <ul><li> <p>私有成员是最高级别的封装，只能在当前类或对象中访问</p> </li><li> <p>在成员前面添加两个两个下划线即可</p> <pre><code>  class Person():
      # name是共有的成员 
      name = "liuying"
      # __age就是私有成员
      __age = 18
</code></pre> </li><li> <p>Python的私有不是真私有，是一种成为name mangling的改名策略<br> 可以使用对象._classname_attributename访问</p> </li></ul> </li><li>受保护的封装 protected 
  <ul><li>受保护的封装是将对象成员进行一定级别的封装，然后，在类中或者子类中都<br> 可以进行访问，但是在外部不可以</li><li>封装方法： 在成员名称前天机爱一个下划线即可</li></ul> </li><li>公开的，公共的 public 
  <ul><li>公共的封装实际对成员没有任何操作，任何地方都可以访问</li></ul> </li></ul> 
<h3><a id="62__255"></a>6.2 继承</h3> 
<ul><li>继承就是一个类可以获得另外一个类中的成员属性和成员方法</li><li>作用： 减少代码，增加代码的复用功能， 同时可以设置类与类直接的关系</li><li>继承与被继承的概念： 
  <ul><li>被继承的类叫父类，也叫基类，也叫超类</li><li>用于继承的类，叫子类，也叫派生类</li><li>继承与被继承一定存在一个 is-a 关系</li></ul> </li><li>继承的语法，参见oop-2.ipynb</li></ul> 
<pre><code># 继承的语法
# 在python中，任何类都有一个共同的父类叫object

class Person():
    name = "NoName"
    age = 18
    __score = 0 # 考试成绩是秘密，只要自己知道
    _petname = "sec" #小名，是保护的，子类可以用，但不能公用
    def sleep(self):
        print("Sleeping ... ...")
        
#父类写在括号内
class Teacher(Person):
    teacher_id = "9527"
    def make_test(self):
        print("attention")
    
t = Teacher()
print(t.name)
# 受保护不能外部访问，为啥这里可以
print(t._petname)

# 私有访问问题
# 公开访问私有变量，报错
#print(t.__score)

t.sleep()
print(t.teacher_id)
t.make_test()

</code></pre> 
<ul><li>继承的特征 
  <ul><li>所有的类都继承自object类，即所有的类都是object类的子类</li><li>子类一旦继承父类，则可以使用父类中除私有成员外的所有内容</li><li>子类继承父类后并没有将父类成员完全赋值到子类中，而是通过引用关系访问调用</li><li>子类中可以定义独有的成员属性和方法</li><li>子类中定义的成员和父类成员如果相同，则优先使用子类成员</li></ul> </li></ul> 
<pre><code># 子类和父类定义同一个名称变量，则优先使用子类本身
class Person():
    name = "NoName"
    age = 18
    __score = 0 # 考试成绩是秘密，只要自己知道
    _petname = "sec" #小名，是保护的，子类可以用，但不能公用
    def sleep(self):
        print("Sleeping ... ...")
 
        
#父类写在括号内
class Teacher(Person):
    teacher_id = "9527"
    name = "DaNa"
    def make_test(self):
        print("attention")
        
t = Teacher()
print(t.name)
</code></pre> 
<ul><li>子类如果想扩充父类的方法，可以在定义新方法的同时访问父类成员来进行代码重用，<br> 可以使用 [父类名.父类成员] 的格式来调用父类成员，也可以使用super().父类成员的<br> 格式来调用</li></ul> 
<pre><code># 子类扩充父类功能的案例
# 人由工作的函数， 老师也由工作的函数，但老师的工作需要讲课
class Person():
    name = "NoName"
    age = 18
    __score = 0 # 考试成绩是秘密，只要自己知道
    _petname = "sec" #小名，是保护的，子类可以用，但不能公用
    def sleep(self):
        print("Sleeping ... ...")
    def work(self):
        print("make some money")
        
#父类写在括号内
class Teacher(Person):
    teacher_id = "9527"
    name = "DaNa"
    def make_test(self):
        print("attention")
        
    def work(self):
        # 扩充父类的功能只需要调用父类相应的函数
        #Person.work(self)
        # 扩充父类的另一种方法
        # super代表得到父类
        super().work()
        self.make_test()
        
t = Teacher()
t.work()
</code></pre> 
<ul><li> <p>继承变量函数的查找顺序问题</p> 
  <ul><li>优先查找自己的变量</li><li>没有则查找父类</li><li>构造函数如果本类中没有定义，则自动查找调用父类构造函数</li><li>如果本类有定义，则不在继续向上查找</li></ul> </li><li> <p>构造函数</p> 
  <ul><li>是一类特殊的函数，在类进行实例化之前进行调用</li></ul> </li></ul> 
<pre><code># 构造函数的概念

class Dog():
    # __init__就是构造函数
    # 每次实例化的时候，第一个被自动的调用
    # 因为主要工作是进行初始化，所以得名
    def __init__(self):
        print("I am init in dog")

# 实例话的时候，括号内的参数需要跟构造函数参数匹配
kaka = Dog()
</code></pre> 
<ul><li>如果定义了构造函数，则实例化时使用构造函数，不查找父类构造函数</li><li>如果没定义，则自动查找父类构造函数</li></ul> 
<pre><code># 继承中的构造函数 - 1

class Animel():
    pass

class PaxingAni(Animel):
    pass

class Dog(PaxingAni):
    # __init__就是构造函数
    # 每次实例化的时候，第一个被自动的调用
    # 因为主要工作是进行初始化，所以得名
    def __init__(self):
        print("I am init in dog")
# 实例话的时候，自动调用了Dog的构造函数
kaka = Dog()
</code></pre> 
<ul><li>如果子类没定义，父类的构造函数带参数，则构造对象时的参数应该按父类参数构造</li></ul> 
<pre><code># 继承中的构造函数 - 2

class Animel():
    def __init__(self):
        print("Animel")

class PaxingAni(Animel):
    def __init__(self):
        print(" Paxing Dongwu")

class Dog(PaxingAni):
    # __init__就是构造函数
    # 每次实例化的时候，第一个被自动的调用
    # 因为主要工作是进行初始化，所以得名
    def __init__(self):
        print("I am init in dog")
        
# 实例话的时候，自动调用了Dog的构造函数
# 因为找到了构造函数，则不在查找父类的构造函数
kaka = Dog()

# 猫没有写构造函数
class Cat(PaxingAni):
    pass

# 此时应该自动调用构造函数，因为Cat没有构造函数，所以查找父类构造函数
# 在PaxingAni中查找到了构造函数，则停止向上查找
c = Cat()
</code></pre> 
<ul><li> <p>super</p> 
  <ul><li>super不是关键字， 而是一个类</li><li>super的作用是获取MRO（MethodResolustionOrder）列表中的第一个类</li><li>super于父类直接没任何实质性关系，但通过super可以调用到父类</li><li>super使用两个方,参见在构造函数中调用父类的构造函数</li></ul> </li><li> <p>单继承和多继承</p> 
  <ul><li>单继承：每个类只能继承一个类</li><li>多继承，每个类允许继承多个类</li></ul> </li></ul> 
<pre><code># 多继承的例子
# 子类可以直接拥有父类的属性和方法，私有属性和方法除外
class Fish():
    def __init__(self,name):
        self.name = name
    def swim(self):
        print("i am swimming......")
        
class Bird():
    def __init__(self, name):
        self.name = name
        
    def fly(self):
        print("I am flying.....")

class Person():
    def __init__(self, name):
        self.name = name
        
    def work(self):
        print("Working........")
        
        

        
# 单继承的例子      
class Student(Person):
    def __init__(self, name):
        self.name = name
stu = Student("yueyue")
stu.work()
        
        
# 多继承的例子  
class SuperMan(Person, Bird, Fish):
    def __init__(self, name):
        self.name = name


class SwimMan(Person, Fish):
    def __init__(self, name):
        self.name = name
        
s = SuperMan("yueyue")
s.fly()
s.swim()




</code></pre> 
<ul><li> <p>单继承和多继承的优缺点</p> 
  <ul><li>单继承： 
    <ul><li>传承有序逻辑清晰语法简单隐患少呀</li><li>功能不能无限扩展，只能在当前唯一的继承链中扩展</li></ul> </li><li>多继承： 
    <ul><li>优点：类的功能扩展方便</li><li>缺点：继承关系混乱</li></ul> </li></ul> </li><li> <p>菱形继承/钻石继承问题</p> 
  <ul><li>多个子类继承自同一个父类，这些子类由被同一个类继承，于是继承关系图形成一个菱形图谱</li><li><a href="https://www.cnblogs.com/whatisfantasy/p/6046991.html" rel="nofollow">MRO</a></li><li>关于多继承的MRO 
    <ul><li>MRO就是多继承中，用于保存继承顺序的一个列表</li><li>python本身采用C3算法来多多继承的菱形继承进行计算的结果</li><li>MRO列表的计算原则： 
      <ul><li>子类永远在父类前面</li><li>如果多个父类，则根据继承语法中括号内类的书写顺序存放</li><li>如果多个类继承了同一个父类，孙子类中只会选取继承语法括号中第一个父类的父类</li></ul> </li></ul> </li></ul> </li></ul> 
<pre><code># 多继承的例子
# 子类可以直接拥有父类的属性和方法，私有属性和方法除外
class Fish():
    def __init__(self,name):
        self.name = name
    def swim(self):
        print("i am swimming......")
        
class Bird():
    def __init__(self, name):
        self.name = name
        
    def fly(self):
        print("I am flying.....")

class Person():
    def __init__(self, name):
        self.name = name
        
    def work(self):
        print("Working........")
        
        

        
# 单继承的例子      
class Student(Person):
    def __init__(self, name):
        self.name = name
stu = Student("yueyue")
stu.work()
        
        
# 多继承的例子  
class SuperMan(Person, Bird, Fish):
    def __init__(self, name):
        self.name = name


class SwimMan(Person, Fish):
    def __init__(self, name):
        self.name = name
        
s = SuperMan("yueyue")
s.fly()
s.swim()




</code></pre> 
<ul><li>构造函数 
  <ul><li>在对象进行实例化的时候，系统自动调用的一个函数叫构造函数，通常此函数用来对实例对象进行初始化，顾名</li></ul> </li></ul> 
<pre><code># 构造函数例子

class Person():
    # 对Person类进行实例化的时候
    # 姓名要确定
    # 年龄得确定
    # 地址肯定有
    def __init__(self):
        self.name = "NoNmae"
        self.age = 18
        self.address = "Studentwhonheim"
        print("In init func")

# 实例化一个人
p = Person()
</code></pre> 
<pre><code>- 构造函数一定要有，如果没有，则自动向上查找，按照MRO顺序，直到找到为止
</code></pre> 
<pre><code># 构造函数的调用顺序 - 1
# 如果子类没有写构造函数，则自动向上查找，知道找到位置
class A():
    def __init__(self):
        print("A")

class B(A):
    def __init__(self):
        print("B")
        
class C(B):
    pass

# 此时，首先查找C的构造函数
# 如果没有，则向上按照MRO顺序查找父类的构造函数，知道找到为止
c = C()


</code></pre> 
<pre><code># # 构造函数的调用顺序 - 2
class A():
    def __init__(self):
        print("A")

class B(A):
    def __init__(self, name):
        print("B")
        print(name)
        
class C(B):
    pass

# 此时，首先查找C的构造函数
# 如果没有，则向上按照MRO顺序查找父类的构造函数，知道找到为止
# 此时，会出现参数结构不对应错误
c = C()
</code></pre> 
<pre><code># # 构造函数的调用顺序 - 3
class A():
    def __init__(self):
        print("A")

class B(A):
    def __init__(self, name):
        print("B")
        print(name)
        
class C(B):
    # c中想扩展B的构造函数，
    # 即调用B的构造函数后在添加一些功能
    # 由两种方法实现
    
    '''
    # 第一种是通过父类名调用
    def __init__(self, name):
        # 首先调用父类构造函数
        B.__init__(self, name)
        # 其次，再增加自己的功能
        print("这是C中附加的功能")
    '''  
        
    # 第二种，使用super调用
    def __init__(self, name):
        # 首先调用父类构造函数
        super(C, self).__init__(name)
        # 其次，再增加自己的功能
        print("这是C中附加的功能")
        

# 此时，首先查找C的构造函数
# 如果没有，则向上按照MRO顺序查找父类的构造函数，知道找到为止
# 此时，会出现参数结构不对应错误
c = C("我是C")
</code></pre> 
<pre><code>在这里插入代码片
</code></pre> 
<h3><a id="63__674"></a>6.3 多态</h3> 
<ul><li> <p>多态就是同一个对象在不同情况下有不同的状态出现</p> </li><li> <p>多态不是语法，是一种设计思想</p> </li><li> <p>多态性： 一种调用方式，不同的执行效果</p> </li><li> <p>多态： 同一事物的多种形态，动物分为人类，狗类，猪类</p> </li><li> <p><a href="https://www.cnblogs.com/luchuangao/p/6739557.html" rel="nofollow">多态和多态性</a></p> </li><li> <p>Mixin设计模式</p> 
  <ul><li>主要采用多继承方式对类的功能进行扩展</li><li><a href="https://www.zhihu.com/question/20778853" rel="nofollow">Mixin概念</a></li><li><a href="http://blog.csdn.net/robinjwong/article/details/48375833">MRO and Mixin</a></li><li><a href="https://www.cnblogs.com/xybaby/p/6484262.html" rel="nofollow">Mixin模式</a></li><li><a href="http://runforever.github.io/2014-07-19/2014-07-19-python-mixin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="nofollow">Mixin MRO</a></li><li><a href="http://xiaocong.github.io/blog/2012/06/13/python-mixin-and-mro/" rel="nofollow">MRO</a></li></ul> </li><li> <p>我们使用多继承语法来实现Minxin</p> </li><li> <p>使用Mixin实现多继承的时候非常小心</p> 
  <ul><li>首先他必须表示某一单一功能，而不是某个物品</li><li>职责必须单一，如果由多个功能，则写多个Mixin</li><li>Mixin不能依赖于子类的实现</li><li>子类即使没有继承这个Mixin类， 也能照样工作，只是缺少了某个功能</li></ul> </li><li> <p>优点</p> 
  <ul><li>使用Mixin可以在不对类进行任何修改的情况下，扩充功能</li><li>可以方便的组织和维护不同功能组件的划分</li><li>可以根据需要任意调整功能类的组合</li><li>可以避免创建很多新的类，导致类的继承混乱</li></ul> </li></ul> 
<pre><code># Mixin案例
class Person():
                name = "liuying"
                age = 18

                def eat(self):
                    print("EAT.......")
                    
                def drink(self):
                    print("DRINK......")
                    
                def sleep(self):
                    print("SLEEP.....")
                
class Teacher(Person):
                def work(self):
                    print("Work")

class Student(Person):
                def study(self):
                    print("Study")
                    

class Tutor(Teacher, Student):
                pass

t = Tutor()
             
print(Tutor.__mro__)
print(t.__dict__)
print(Tutor.__dict__)

print("*"*20)
class TeacherMixin():
                def work(self):
                    print("Work")

class StudentMixin():
                def study(self):
                    print("Study")
                    
class TutorM(Person, TeacherMixin, StudentMixin):
                pass

tt = TutorM()
print(TutorM.__mro__)
print(tt.__dict__)
print(TutorM.__dict__)

</code></pre> 
<h2><a id="7__753"></a>7 类相关函数</h2> 
<ul><li>issubclass:检测一个类是否是另一个类的子类</li></ul> 
<pre><code># issubclass
class A():
    pass

class B(A):
    pass

class C():
    pass

print( issubclass(B, A))
print( issubclass(C, A))
print( issubclass(B, object))
</code></pre> 
<ul><li>isinstance:检测一个对象是否是一个类的实例</li></ul> 
<pre><code># isinstance
class A():
    pass

a = A()

print(isinstance(a, A))
print(isinstance(A, A))
</code></pre> 
<ul><li>hasattr:检测一个对象是否由成员xxx</li></ul> 
<pre><code># hasattr
class A():
    name = "NoName"
    
a = A()
print(hasattr(a, "name" ))
print(hasattr(a, "age" ))
</code></pre> 
<ul><li>getattr: get attribute</li><li>setattr: set attribute</li><li>delattr: delete attribute</li><li>dir: 获取对象的成员列表</li></ul> 
<pre><code># dir 案例
class A():
    pass

#dir(A)
a = A()
dir(a)
</code></pre> 
<h2><a id="8__812"></a>8. 类的成员描述符（属性）</h2> 
<pre><code># 属性案例
# 创建Student类，描述学生类
# 学生具有Student.name属性
# 但name格式并不统一
# 可以用增加一个函数，然后自动调用的方式，但很蠢
class Student():
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
        # 如果不想修改代码
        self.setName(name)
        
    # 介绍下自己
    def intro(self):
        print("Hai, my name is {0}".format(self.name))
        
    def setName(self, name):
        self.name = name.upper()
        
s1 = Student("LIU Ying", 19.8)
s2 = Student("michi stangle", 24.0)

s1.intro()
s2.intro()


</code></pre> 
<ul><li>类的成员描述符是为了在类中对类的成员属性进行相关操作而创建的一种方式 
  <ul><li>get： 获取属性的操作</li><li>set：修改或者添加属性操作</li><li>delete： 删除属性的操作</li></ul> </li><li>如果想使用类的成员描述符，大概有三种方法 
  <ul><li>使用类实现描述器</li><li>使用属性修饰符</li><li>使用property函数 
    <ul><li>property函数很简单</li><li>property(fget, fset, fdel, doc)</li></ul> </li><li>案例参看notebook</li></ul> </li></ul> 
<pre><code># peroperty案例
# 定义一个Person类，具有name，age属性
# 对于任意输入的姓名，我们希望都用大写方式保存
# 年龄，我们希望内部统一用整数保存
# x = property(fget, fset, fdel, doc)
class Person():
    '''
    这是一个人，一个高尚的人，一个脱离了低级趣味的人
    他还他妈的有属性
    '''
    # 函数的名称可以任意
    def fget(self):
        return self._name * 2
    
    def fset(self, name):
        # 所有输入的姓名以大写形式保存
        self._name = name.upper()
        
    def fdel(self):
        self._name = "NoName"
    
    name = property(fget, fset, fdel, "对name进行下下操作啦")
    
# 作业：
# 1. 在用户输入年龄的时候，可以输入整数，小数，浮点数
# 2. 但内部为了数据清洁，我们统一需要保存整数，直接舍去小数点
</code></pre> 
<ul><li>无论哪种修饰符都是为了对成员属性进行相应的控制 
  <ul><li>类的方式： 适合多个类中的多个属性共用用一个描述符</li><li>property：使用当前类中使用，可以控制一个类中多个属性</li><li>属性修饰符： 使用于当前类中使用，控制一个类中的一个属性</li></ul> </li></ul> 
<pre><code># 类属性 property
# 应用场景：
# 对变量除了普通的三种操作，还想增加一些附加的操作，那么可以通过property完成
class A():
    def __init__(self):
        self.name = "haha"
        self.age =18
    # 此功能，是对类变量进行读取操作的时候应该执行的函数功能
    def fget(self):
        print("我被读取了")
        return self.name
    # 模拟的是对变量进行写操作的时候执行的功能
    def fset(self, name):
        print("我被写入了，但是还可以左好多事情")
        self.name = "图灵学院：" + name 
        
    # fdel模拟的是删除变量的时候进行的操作
    def fdel(self):
        pass
        
    # property的四个参数顺序是固定的
    # 第一个参数代表读取的时候需要调用的函数
    # 第二个参数代表写入的时候需要调用的函数
    # 第三个是删除
    name2 = property(fget, fset, fdel, "这是一个property的例子")
    
a = A()
print(a.name)

print(a.name2)
</code></pre> 
<h2><a id="9__921"></a>9. 类的内置属性</h2> 
<pre><code>    __dict__:以字典的方式显示类的成员组成
    __doc__: 获取类的文档信息
    __name__:获取类的名称，如果在模块中使用，获取模块的名称
    __bases__: 获取某个类的所有父类，以元组的方式显示
</code></pre> 
<pre><code># 类的内置属性举例
print(Person.__dict__)
print(Person.__doc__)
print(Person.__name__)
print(Person.__bases__)
</code></pre> 
<h2><a id="10__936"></a>10. 类的常用魔术方法</h2> 
<ul><li>魔术方法就是<mark>不需要人为调用的方法</mark>，基本是在特定的时刻自动触发</li><li>魔术方法的统一的特征，<mark>方法名被前后各两个下滑线包裹</mark></li><li>操作类 
  <ul><li><code>__init__</code>: 构造函数</li></ul> </li></ul> 
<pre><code># init 举例
class A():
    def __init__(self, name = 0):
        print("哈哈，我被调用了")
        
a = A()
</code></pre> 
<ul><li><code>__new__</code>: 对象实例化方法，此函数较特殊，一般不需要使用</li><li><code>__call__</code>: 对象当函数使用的时候触发</li></ul> 
<pre><code># __call__举例
class A():
    def __init__(self, name = 0):
        print("哈哈，我被调用了")
        
    def __call__(self):
        print("我被调用了again")
        
a = A()
a()
</code></pre> 
<ul><li><code>__str__</code>: 当对象被当做字符串使用的时候调用</li></ul> 
<pre><code># __str__举例
class A():
    def __init__(self, name = 0):
        print("哈哈，我被调用了")
        
    def __call__(self):
        print("我被调用了again")
       
    def __str__(self):
        return "图灵学院的例子"
a = A()
print(a)
</code></pre> 
<ul><li><code>__repr__</code>: 返回字符串，跟<code>__str__</code>具体区别请百度</li><li>描述符相关 
  <ul><li><code>__set__</code></li><li><code>__get__</code></li><li><code>__delete__</code></li></ul> </li><li>属性操作相关 
  <ul><li><code>__getattr__</code>: 访问一个不存在的属性时触发</li></ul> </li></ul> 
<pre><code># __getattr__

class A():
    name = "NoName"
    age = 18
   
    def __getattr__(self, name):
        print("没找到呀没找到")
        print(name)
        
a = A()
print(a.name)
print(a.addr)  
# 作业：
# 为什么会打印第四句话，而且第四句话是打印的 None
</code></pre> 
<ul><li><code>__setattr__</code>: 对成员属性进行设置的时候触发 
  <ul><li>参数： 
    <ul><li>self用来获取当前对象</li><li>被设置的属性名称，以字符串形式出现</li><li>需要对属性名称设置的值</li></ul> </li><li>作用：进行属性设置的时候进行验证或者修改</li><li>注意： 在该方法中不能对属性直接进行赋值操作，否则死循环</li><li>参看案例</li></ul> </li></ul> 
<pre><code># __setattr__案例
class Person():
    def __init__(self):
        pass
    
    def __setattr__(self, name, value):
        print("设置属性： {0}".format(name))
        # 下面语句会导致问题，死循环
        #self.name = value
        # 此种情况，为了避免死循环，规定统一调用父类魔法函数
        super().__setattr__(name, value)
        
p = Person()
print(p.__dict__)
p.age = 18
</code></pre> 
<ul><li>运算分类相关魔术方法 
  <ul><li><code>__gt__</code>: 进行大于判断的时候触发的函数 
    <ul><li>参数： 
      <ul><li>self</li><li>第二个参数是第二个对象</li><li>返回值可以是任意值，推荐返回布尔值</li><li>案例</li></ul> </li></ul> </li></ul> </li></ul> 
<pre><code># __gt__

class Student():
    def __init__(self, name):
        self._name = name
    
   
    def __gt__(self, obj):
        print("哈哈， {0} 会比 {1} 大吗？".format(self, obj))
        return self._name &gt; obj._name
    
# 作业：
# 字符串的比较是按什么规则
stu1 = Student("one")
stu2 = Student("two")

print(stu1 &gt; stu2)


# 作业：
# 下面显示结果不太美观，能否改成形如  "哈哈， one 会比 two 大吗？“
</code></pre> 
<h2><a id="11__1067"></a>11. 类和对象的三种方法</h2> 
<ul><li>实例方法 
  <ul><li>需要实例化对象才能使用的方法，使用过程中可能需要截止对象的其他对象的方法完成</li></ul> </li><li>静态方法 
  <ul><li>不需要实例化，通过类直接访问</li></ul> </li><li>类方法 
  <ul><li>不需要实例化</li></ul> </li><li>参看案例</li></ul> 
<pre><code># 三种方法的案例
class Person:
    # 实例方法
    def eat(self):
        print(self)
        print("Eating.....")
    
    #类方法
    # 类方法的第一个参数，一般命名为cls，区别于self
    @classmethod
    def play(cls):
        print(cls)
        print("Playing.....")
        
    # 静态方法
    # 不需要用第一个参数表示自身或者类
    @staticmethod
    def say():
    
        print("Saying....")
        
yueyue = Person()

# 实例方法
yueyue.eat()
# 类方法
Person.play()
yueyue.play()
#静态方法
Person.say()
yueyue.say()

# 作业：
# 自行查找三种方法内存使用方面的区别
</code></pre> 
<ul><li>三个方法具体区别自行百度</li></ul> 
<h2><a id="12__1115"></a>12. 所用软件</h2> 
<ul><li>画图软件是Faststone capture</li><li>有问题加群 158184562</li><li>官网地址 <a href="http://www.tulingxueyuan.com" rel="nofollow">www.tulingxueyuan.com</a></li></ul> 
<h2><a id="13__1120"></a>13. 抽象类</h2> 
<pre><code># 抽象

class Animel():
  
   
    def sayHello(self):
        pass
 
    
class Dog(Animel):
    pass


class Person(Animel):
    
    def sayHello(self):
        print("Kiss me")
    
d = Dog()
d.sayHello()

p = Person()
p.sayHello()
</code></pre> 
<ul><li> <p>抽象方法： 没有具体实现内容的方法成为抽象方法</p> </li><li> <p>抽象方法的主要意义是规范了子类的行为和接口</p> </li><li> <p><mark>抽象类的使用需要借助abc模块</mark></p> <pre><code>  import abc
</code></pre> </li><li> <p>抽象类：<mark>包含抽象方法的类叫抽象类，通常称为ABC类</mark></p> </li></ul> 
<pre><code># 抽象类的实现

import abc

#声明一个类并且指定当前类的元类
class Human(metaclass=abc.ABCMeta):

    # 定义一个抽象的方法
    @abc.abstractmethod
    def smoking(self):
        pass
    
    # 定义类抽象方法
    @abc.abstractclassmethod
    def drink():
        pass
    
    # 定义静态抽象方法
    @abc.abstractstaticmethod
    def play():
        pass
    
    def sleep(self):
        print("Sleeping.......")
</code></pre> 
<ul><li>抽象类的使用 
  <ul><li>抽象类可以包含抽象方法，也可以包含具体方法</li><li>抽象类中可以有方法也可以有属性</li><li>抽象类不允许直接实例化</li><li>必须继承才可以使用，且继承的子类必须实现所有继承来的抽象方法</li><li>假定子类没有是现实所有继承的抽象方法，则子类也不能实例化</li><li>抽象类的主要作用是设定类的标准，以便于开发的时候具有统一的规范</li></ul> </li></ul> 
<h2><a id="14__1191"></a>14. 自定义类</h2> 
<ul><li>类其实是一个<mark>类定义和各种方法的自由组合</mark></li></ul> 
<pre><code># 自己组装一个类

class A():
    pass

def say(self):
    print("Saying... ...")
    
    
class B():
    def say(self):
        print("Saying......")
        
say(9)
A.say = say

a = A()
a.say()

b = B()
b.say()
</code></pre> 
<ul><li>可以定义类和函数，然后自己通过类直接赋值</li><li>可以借助于MethodType实现</li></ul> 
<pre><code># 组装类例子 2
# 自己组装一个类
from types import MethodType

class A():
    pass

def say(self):
    print("Saying... ...")
    
a = A()
a.say = MethodType(say, A)
a.say()
</code></pre> 
<ul><li>借助于type实现</li></ul> 
<pre><code># 利用type造一个类

# 先定义类应该具有的成员函数
def say(self):
    print("Saying.....")
    
def talk(self):
    print("Talking .....")
    
#用type来创建一个类
A = type("AName", (object, ), {"class_say":say, "class_talk":talk})

# 然后可以像正常访问一样使用类
a = A()

a.class_say()
a.class_talk()
</code></pre> 
<h3><a id="14__MetaClass_1259"></a>14 利用元类实现- MetaClass</h3> 
<ul><li>元类是类</li><li>备用来创造别的类</li></ul> 
<pre><code># 元类演示

# 元类写法是固定的，必须继承自type
# 元类一般命名以MetaClass结尾
class TulingMetaClass(type):
    # 注意以下写法
    def __new__(cls, name, bases, attrs):
        #自己的业务处理
        print("哈哈，我是元类呀")
        attrs['id'] = '000000'
        attrs['addr'] = "北京海淀区公主坟西翠路12号"
        return type.__new__(cls, name, bases, attrs)
    
# 元类定义完就可以使用，使用注意写法
class Teacher(object, metaclass=TulingMetaClass):
    pass

t = Teacher()

t.id
</code></pre> 
<ul><li>元类写法是固定的，<mark>必须继承自type</mark></li><li>元类一般命名以<mark>MetaClass结尾</mark></li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/705a84fffcdbba40884748b209b6d2d9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">通俗易懂的虚短、虚断的使用条件?</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3822abacf64ee443b91416fff65fcd8d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">git clone ssh 需要输入密码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>