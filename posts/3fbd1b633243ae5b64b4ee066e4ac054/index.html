<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>webrtc-nat 穿越及相关协议 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="webrtc-nat 穿越及相关协议" />
<meta property="og:description" content="文章目录 WebRTC nat 穿越及相关协议Nat 类型Full cone NAT（完全锥形NAT）Restricted Cone NAT（地址受限锥形NAT）Port Restricted Cone NAT（端口受限锥形NAT）Symetric NAT（对称NAT） Session Traversal Utilities for NAT (STUN)-NAT会话遍历工具协议文档 RFC 3489 和 RFC 5389相关概念STUN Message HeaderSTUN MethodsBinding Request(0x0001): UDP 传输Shared Secret Request(0x0002): (Reserved; was SharedSecret): TCP 的 TLS 传输 STUN AttributesMAPPED-ADDRESS(0x0001)USERNAME(0x0006)MESSAGE-INTEGRITY(0x0008)ERROR-CODE(0x0009)UNKNOWN-ATTRIBUTES(0x000A)REALM(0x0014)Nonce(0x0015)XOR-MAPPED-ADDRESS(0x0020)SOFTWARE attribute(0x8022)FINGERPRINT(0x8028) Traversal Using Relays around NAT (TURN)协议文档 RFC 5766Relay Extensions to Session Traversal Utilities for NAT (STUN)相关概念Transports：传输方式Allocations:client 请求 server 分配中继地址exchange application data：数据交换Send Mechanism: Send and Data methodsChannels New STUN Methods0x0003 : Allocate (only request/response semantics defined)0x0004 : Refresh (only request/response semantics defined)0x0006 : Send (only indication semantics defined): 将数据从 client 传递 server0x0007 : Data (only indication semantics defined): 将数据从 server 传递 client0x0008 : CreatePermission (only request/response semantics defined0x0009 : ChannelBind (only request/response semantics defined) New STUN AttributesCHANNEL-NUMBER(0x000C)LIFETIME(0x000D)XOR-PEER-ADDRESS(0x0012)DATA(0x0013)XOR-RELAYED-ADDRESS(0x0016)EVEN-PORT(0x0018)：偶数端口REQUESTED-TRANSPORT(0x0019)DONT-FRAGMENT(0x001A)RESERVATION-TOKEN(0x0022) New STUN Error Response Codes Interactive Connectivity Establishment (ICE)协议文档 RFC 5245A Protocol for Network Address Translator (NAT) Traversal for相关概念Controlling Agent：控制方Controlled Agent：被控制方 Gathering Candidate Addresses：收集候选者Sending the Initial Offerfull implementationslite implementationsEncoding the SDP STUN Extensions:four new attributesPRIORITY(0x0024)USECANDIDATE(0x0025)ICE-CONTROLLED(64 位网络字节序无符号整)ICE-CONTROLLING(64 位网络字节序无符号整数) STUN Extensions:New Error Response Codes: 487 (Role Conflict) b 站抓包分析Binding Request to STUN ServerBinding success respose from STUN ServerBinding Request to a PeerBinding Request from a PeerBinding success respose from a ClientBinding success respose from a Peer mediasoup webrtc stun 源码分析接收 stunData解析 stunData：获取 attributeICE Server 处理 参考文献 WebRTC nat 穿越及相关协议 Nat 类型 Full cone NAT（完全锥形NAT） 所有从同一个内网的（IP，端口）发送出来的请求都会被映射到同一个外网（IP，端口），且任何一个外网主机都可以通过访问映射后的公网地址，实现访问位于内网的主机设备功能。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/3fbd1b633243ae5b64b4ee066e4ac054/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-02T10:42:46+08:00" />
<meta property="article:modified_time" content="2022-10-02T10:42:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">webrtc-nat 穿越及相关协议</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#WebRTC_nat__3" rel="nofollow">WebRTC nat 穿越及相关协议</a></li><li><ul><li><a href="#Nat__5" rel="nofollow">Nat 类型</a></li><li><ul><li><a href="#Full_cone_NATNAT_7" rel="nofollow">Full cone NAT（完全锥形NAT）</a></li><li><a href="#Restricted_Cone_NATNAT_13" rel="nofollow">Restricted Cone NAT（地址受限锥形NAT）</a></li><li><a href="#Port_Restricted_Cone_NATNAT_19" rel="nofollow">Port Restricted Cone NAT（端口受限锥形NAT）</a></li><li><a href="#Symetric_NATNAT_25" rel="nofollow">Symetric NAT（对称NAT）</a></li></ul> 
    </li><li><a href="#Session_Traversal_Utilities_for_NAT_STUNNAT_29" rel="nofollow">Session Traversal Utilities for NAT (STUN)-NAT会话遍历工具</a></li><li><ul><li><a href="#_RFC_3489__RFC_5389_31" rel="nofollow">协议文档 RFC 3489 和 RFC 5389</a></li><li><ul><li><a href="#_57" rel="nofollow">相关概念</a></li><li><a href="#STUN_Message_Header_60" rel="nofollow">STUN Message Header</a></li><li><a href="#STUN_Methods_172" rel="nofollow">STUN Methods</a></li><li><ul><li><a href="#Binding_Request0x0001_UDP__174" rel="nofollow">Binding Request(0x0001): UDP 传输</a></li><li><a href="#Shared_Secret_Request0x0002_Reserved_was_SharedSecret_TCP__TLS__180" rel="nofollow">Shared Secret Request(0x0002): (Reserved; was SharedSecret): TCP 的 TLS 传输</a></li></ul> 
      </li><li><a href="#STUN_Attributes_185" rel="nofollow">STUN Attributes</a></li><li><ul><li><a href="#MAPPEDADDRESS0x0001_241" rel="nofollow">MAPPED-ADDRESS(0x0001)</a></li><li><a href="#USERNAME0x0006_273" rel="nofollow">USERNAME(0x0006)</a></li><li><a href="#MESSAGEINTEGRITY0x0008_278" rel="nofollow">MESSAGE-INTEGRITY(0x0008)</a></li><li><a href="#ERRORCODE0x0009_309" rel="nofollow">ERROR-CODE(0x0009)</a></li><li><a href="#UNKNOWNATTRIBUTES0x000A_332" rel="nofollow">UNKNOWN-ATTRIBUTES(0x000A)</a></li><li><a href="#REALM0x0014_336" rel="nofollow">REALM(0x0014)</a></li><li><a href="#Nonce0x0015_341" rel="nofollow">Nonce(0x0015)</a></li><li><a href="#XORMAPPEDADDRESS0x0020_367" rel="nofollow">XOR-MAPPED-ADDRESS(0x0020)</a></li><li><a href="#SOFTWARE_attribute0x8022_371" rel="nofollow">SOFTWARE attribute(0x8022)</a></li><li><a href="#FINGERPRINT0x8028_381" rel="nofollow">FINGERPRINT(0x8028)</a></li></ul> 
     </li></ul> 
    </li></ul> 
    </li><li><a href="#Traversal_Using_Relays_around_NAT_TURN_386" rel="nofollow">Traversal Using Relays around NAT (TURN)</a></li><li><ul><li><a href="#_RFC_5766_388" rel="nofollow">协议文档 RFC 5766</a></li><li><a href="#Relay_Extensions_to_Session_Traversal_Utilities_for_NAT_STUN_389" rel="nofollow">Relay Extensions to Session Traversal Utilities for NAT (STUN)</a></li><li><ul><li><a href="#_429" rel="nofollow">相关概念</a></li><li><a href="#Transports_432" rel="nofollow">Transports：传输方式</a></li><li><a href="#Allocationsclient__server__450" rel="nofollow">Allocations:client 请求 server 分配中继地址</a></li><li><a href="#exchange_application_data_531" rel="nofollow">exchange application data：数据交换</a></li><li><ul><li><a href="#Send_Mechanism_Send_and_Data_methods_538" rel="nofollow">Send Mechanism: Send and Data methods</a></li><li><a href="#Channels_616" rel="nofollow">Channels</a></li></ul> 
      </li><li><a href="#New_STUN_Methods_737" rel="nofollow">New STUN Methods</a></li><li><ul><li><a href="#0x0003__Allocate_only_requestresponse_semantics_defined_740" rel="nofollow">0x0003 : Allocate (only request/response semantics defined)</a></li><li><a href="#0x0004__Refresh_only_requestresponse_semantics_defined_742" rel="nofollow">0x0004 : Refresh (only request/response semantics defined)</a></li><li><a href="#0x0006__Send_only_indication_semantics_defined__client__server_744" rel="nofollow">0x0006 : Send (only indication semantics defined): 将数据从 client 传递 server</a></li><li><a href="#0x0007__Data_only_indication_semantics_defined__server__client_746" rel="nofollow">0x0007 : Data (only indication semantics defined): 将数据从 server 传递 client</a></li><li><a href="#0x0008__CreatePermission_only_requestresponse_semantics_defined_748" rel="nofollow">0x0008 : CreatePermission (only request/response semantics defined</a></li><li><a href="#0x0009__ChannelBind_only_requestresponse_semantics_defined_750" rel="nofollow">0x0009 : ChannelBind (only request/response semantics defined)</a></li></ul> 
      </li><li><a href="#New_STUN_Attributes_753" rel="nofollow">New STUN Attributes</a></li><li><ul><li><a href="#CHANNELNUMBER0x000C_769" rel="nofollow">CHANNEL-NUMBER(0x000C)</a></li><li><a href="#LIFETIME0x000D_781" rel="nofollow">LIFETIME(0x000D)</a></li><li><a href="#XORPEERADDRESS0x0012_785" rel="nofollow">XOR-PEER-ADDRESS(0x0012)</a></li><li><a href="#DATA0x0013_790" rel="nofollow">DATA(0x0013)</a></li><li><a href="#XORRELAYEDADDRESS0x0016_794" rel="nofollow">XOR-RELAYED-ADDRESS(0x0016)</a></li><li><a href="#EVENPORT0x0018_811" rel="nofollow">EVEN-PORT(0x0018)：偶数端口</a></li><li><a href="#REQUESTEDTRANSPORT0x0019_834" rel="nofollow">REQUESTED-TRANSPORT(0x0019)</a></li><li><a href="#DONTFRAGMENT0x001A_859" rel="nofollow">DONT-FRAGMENT(0x001A)</a></li><li><a href="#RESERVATIONTOKEN0x0022_864" rel="nofollow">RESERVATION-TOKEN(0x0022)</a></li></ul> 
      </li><li><a href="#New_STUN_Error_Response_Codes_869" rel="nofollow">New STUN Error Response Codes</a></li></ul> 
    </li></ul> 
    </li><li><a href="#Interactive_Connectivity_Establishment_ICE_879" rel="nofollow">Interactive Connectivity Establishment (ICE)</a></li><li><ul><li><a href="#_RFC_5245_881" rel="nofollow">协议文档 RFC 5245</a></li><li><a href="#A_Protocol_for_Network_Address_Translator_NAT_Traversal_for_883" rel="nofollow">A Protocol for Network Address Translator (NAT) Traversal for</a></li><li><ul><li><a href="#_926" rel="nofollow">相关概念</a></li><li><ul><li><a href="#Controlling_Agent_927" rel="nofollow">Controlling Agent：控制方</a></li><li><a href="#Controlled_Agent_931" rel="nofollow">Controlled Agent：被控制方</a></li></ul> 
      </li><li><a href="#Gathering_Candidate_Addresses_935" rel="nofollow">Gathering Candidate Addresses：收集候选者</a></li><li><a href="#Sending_the_Initial_Offer_942" rel="nofollow">Sending the Initial Offer</a></li><li><ul><li><a href="#full_implementations_952" rel="nofollow">full implementations</a></li><li><a href="#lite_implementations_954" rel="nofollow">lite implementations</a></li><li><a href="#Encoding_the_SDP_958" rel="nofollow">Encoding the SDP</a></li></ul> 
      </li><li><a href="#STUN_Extensionsfour_new_attributes_988" rel="nofollow">STUN Extensions:four new attributes</a></li><li><ul><li><a href="#PRIORITY0x0024_995" rel="nofollow">PRIORITY(0x0024)</a></li><li><a href="#USECANDIDATE0x0025_999" rel="nofollow">USECANDIDATE(0x0025)</a></li><li><a href="#ICECONTROLLED64__1003" rel="nofollow">ICE-CONTROLLED(64 位网络字节序无符号整)</a></li><li><a href="#ICECONTROLLING64__1007" rel="nofollow">ICE-CONTROLLING(64 位网络字节序无符号整数)</a></li></ul> 
      </li><li><a href="#STUN_ExtensionsNew_Error_Response_Codes_487_Role_Conflict_1012" rel="nofollow">STUN Extensions:New Error Response Codes: 487 (Role Conflict)</a></li></ul> 
    </li></ul> 
    </li><li><a href="#b__1014" rel="nofollow">b 站抓包分析</a></li><li><ul><li><a href="#Binding_Request_to_STUN_Server_1015" rel="nofollow">Binding Request to STUN Server</a></li><li><a href="#Binding_success_respose_from__STUN_Server_1018" rel="nofollow">Binding success respose from STUN Server</a></li><li><a href="#Binding_Request_to_a_Peer_1020" rel="nofollow">Binding Request to a Peer</a></li><li><a href="#Binding_Request_from_a_Peer_1024" rel="nofollow">Binding Request from a Peer</a></li><li><a href="#Binding_success_respose_from_a_Client_1026" rel="nofollow">Binding success respose from a Client</a></li><li><a href="#Binding_success_respose_from_a_Peer_1029" rel="nofollow">Binding success respose from a Peer</a></li></ul> 
    </li><li><a href="#mediasoup_webrtc_stun__1031" rel="nofollow">mediasoup webrtc stun 源码分析</a></li><li><ul><li><a href="#_stunData_1033" rel="nofollow">接收 stunData</a></li><li><a href="#_stunData_attribute_1056" rel="nofollow">解析 stunData：获取 attribute</a></li><li><a href="#ICE_Server__1392" rel="nofollow">ICE Server 处理</a></li></ul> 
    </li><li><a href="#_1609" rel="nofollow">参考文献</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="WebRTC_nat__3"></a>WebRTC nat 穿越及相关协议</h3> 
<h4><a id="Nat__5"></a>Nat 类型</h4> 
<h5><a id="Full_cone_NATNAT_7"></a>Full cone NAT（完全锥形NAT）</h5> 
<p>所有从同一个内网的（IP，端口）发送出来的请求都会被映射到同一个外网（IP，端口），且任何一个外网主机都可以通过访问映射后的公网地址，实现访问位于内网的主机设备功能。</p> 
<p>外网主机可以主动连接内网主机</p> 
<h5><a id="Restricted_Cone_NATNAT_13"></a>Restricted Cone NAT（地址受限锥形NAT）</h5> 
<p>所有从同一个内网的（IP，端口）发送出来的请求都会被映射到通过一个外网（IP，端口），但与全锥形不同点在于：生成的映射表项与目的IP有关，只有符合要求的目的IP(要访问的公网服务器IP)才可以通讯。此NAT还有个特点：不能主动连接内网中的主机地址，连接必须由内网地址发起。</p> 
<p>限制比全锥形NAT多了：IP地址限制。</p> 
<h5><a id="Port_Restricted_Cone_NATNAT_19"></a>Port Restricted Cone NAT（端口受限锥形NAT）</h5> 
<p>所有从同一个内网的（IP，端口）发送出来的请求都会被映射到通过一个外网（IP，端口），但是在地址受限锥形NAT基础上增加了端口的限制。地址受限锥形NAT时，只有内网主机主动连接的公网主机才可与之进行通讯，而不用担心端口号是否与请求的端口相同。</p> 
<p>端口受限锥形NAT除了IP限制外，增加了端口限制。</p> 
<h5><a id="Symetric_NATNAT_25"></a>Symetric NAT（对称NAT）</h5> 
<p>所有从同一个内网（IP，端口）发送到同一个目的IP和端口的请求都会被映射到同一个IP和端口。换句话说（SIP，Sport, DIP, Dport）只要有一个发生变化都会使用不同的映射条目，即此NAT映射与报文四元组绑定。</p> 
<h4><a id="Session_Traversal_Utilities_for_NAT_STUNNAT_29"></a>Session Traversal Utilities for NAT (STUN)-NAT会话遍历工具</h4> 
<h5><a id="_RFC_3489__RFC_5389_31"></a>协议文档 RFC 3489 和 RFC 5389</h5> 
<ul><li>STUN，首先在 RFC3489 中定义，作为一个完整的 NAT 穿透解决方案，英文全称是 Simple Traversal of UDP Through NATs，即简单的用 UDP 穿透 NAT。</li><li>在 RFC5389 修订中把 STUN 协议定位于为穿透 NAT 提供工具，而不是一个完整的解决方案，英文全称是 Session Traversal Utilities for NAT，即 NAT 会话穿透效用。</li></ul> 
<p>RFC5389与RFC3489的不同点如下：</p> 
<ul><li>去掉STUN是一种完整的NAT穿透方案的概念，现在是一种用于提供NAT穿透解决方案的工具。因而，协议的名称变为NAT会话穿透效用；</li><li>定义了STUN的用途；</li><li>去掉了STUN关于NAT类型检测和绑定生命期发现的用法，去掉了RESPONSE-ADDRESS、CHANGED-ADDRESS、CHANGE-REQUEST、SOURCE-ADDRESS和REFLECTED-FROM属性；</li><li>增加了一个固定的32位的魔术字字段，事务ID字段减少了32位长度；</li><li>增加了XOR-MAPPED-ADDRESS属性，若魔术字在捆绑请求中出现时，该属性包括在捆绑响应中。否则，RFC3489中的行为是保留的（换句话说，捆绑响应中包括MAPPED-ADDRESS）；</li><li>介绍了消息类型字段的正式结构，带有一对明确的位来标识Request、Response、Error-Response或Indication消息。因此，消息类型字段被划分为类别和方法两部分；</li><li>明确的指出了STUN的最高2位是0b00，当用于ICE时可以简单的与RTP包区分开来；</li><li>增加指纹属性来提供一种明确的方法来检测当STUN协议多路复用时，STUN与其他协议之间的差异；</li><li>增加支持IPv6，IPv4客户端可以获取一个IPv6映射地址，反之亦然；</li><li>增加一个long-term-credential-based认证机制；</li><li>增加了SOFTWARE、REALM、NONCE和ALTERNATE-SERVER属性；</li><li>去掉了共享密匙方法，因此PASSWORD属性也去掉了；</li><li>去掉了使用连续10秒侦听STUN响应来识别一个攻击的做法；</li><li>改变事务计时器来增加TCP友好性；</li><li>去掉了STUN例子如集中分离控制和媒体面，代替的，在使用STUN协议时提供了更多的信息；</li><li>定义了一类填充机制来改变长度属性的说明；</li><li>REALM、SERVER、原因语句和NONCE限制在127个字符，USERNAME限制在513个字节以内；</li><li>为TCP和TLS改变了DNS SRV规程，UDP仍然和以前保持一致；</li></ul> 
<h6><a id="_57"></a>相关概念</h6> 
<h6><a id="STUN_Message_Header_60"></a>STUN Message Header</h6> 
<p>stun 消息由 stun 消息头和 stun 属性构成，stun 消息头为 20 固定字节：</p> 
<pre><code> 0                  1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0|     STUN Message Type     |         Message Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Magic Cookie                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                      Transaction ID (96 bits)                 |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          Figure 2: Format of STUN Message Header
</code></pre> 
<ol><li>STUN Message Type 和 class</li></ol> 
<pre><code>/*
The message type field is decomposed further into the following structure:

	 0                 1
	 2  3  4 5 6 7 8 9 0 1 2 3 4 5
	+--+--+-+-+-+-+-+-+-+-+-+-+-+-+
	|M |M |M|M|M|C|M|M|M|C|M|M|M|M|
	|11|10|9|8|7|1|6|5|4|0|3|2|1|0|
	+--+--+-+-+-+-+-+-+-+-+-+-+-+-+

Figure 3: Format of STUN Message Type Field

Here the bits in the message type field are shown as most significant
(M11) through least significant (M0).  M11 through M0 represent a 12-
bit encoding of the method.  C1 and C0 represent a 2-bit encoding of
the class.
*/
</code></pre> 
<p>C1 and C0 represent a 2-bit encoding of the class</p> 
<ul><li>0b00 is a request：client --&gt; server</li><li>0b01 is an indication：client 或者 server 发起不需要响应回复</li><li>0b10 is a success response：server-&gt;client</li><li>0b11 is an error response：server-&gt;client</li></ul> 
<ol start="2"><li>message length</li></ol> 
<p>The message length MUST contain the size, in bytes, of the message<br> not including the 20-byte STUN header.</p> 
<ol start="3"><li> <p>magic cookie<br> The magic cookie field MUST contain the fixed value <code>0x2112A442</code>in<br> network byte order.</p> </li><li> <p>The transaction ID is a 96-bit identifier, used to uniquely identify<br> STUN transactions.</p> </li><li> <p>STUN methods:The initial STUN methods are:</p> </li></ol> 
<ul><li>0x000: (Reserved)</li><li>0x001: Binding</li><li>0x002: (Reserved; was SharedSecret)</li></ul> 
<p>STUN methods in the range 0x000 - 0x7FF are assigned by IETF Review<br> [RFC5226]. STUN methods in the range 0x800 - 0xFFF are assigned by<br> Designated Expert [RFC5226]</p> 
<pre><code>/* Class variables. */

const uint8_t StunPacket::magicCookie[] = { 0x21, 0x12, 0xA4, 0x42 };
	
static bool IsStun(const uint8_t* data, size_t len)
		{
			// clang-format off
			return (
				// STUN headers are 20 bytes.
				(len &gt;= 20) &amp;&amp;
				// DOC: https://tools.ietf.org/html/draft-ietf-avtcore-rfc5764-mux-fixes
				(data[0] &lt; 3) &amp;&amp;
				// Magic cookie must match.
				(data[4] == StunPacket::magicCookie[0]) &amp;&amp; (data[5] == StunPacket::magicCookie[1]) &amp;&amp;
				(data[6] == StunPacket::magicCookie[2]) &amp;&amp; (data[7] == StunPacket::magicCookie[3])
			);
			// clang-format on
		}
</code></pre> 
<pre><code>// Get type field.
		uint16_t msgType = Utils::Byte::Get2Bytes(data, 0);

		// Get length field.
		uint16_t msgLength = Utils::Byte::Get2Bytes(data, 2);

		// length field must be total size minus header's 20 bytes, and must be multiple of 4 Bytes.
		if ((static_cast&lt;size_t&gt;(msgLength) != len - 20) || ((msgLength &amp; 0x03) != 0))
		{
			MS_WARN_TAG(
			  ice,
			  "length field + 20 does not match total size (or it is not multiple of 4 bytes), "
			  "packet discarded");

			return nullptr;
		}

		// Get STUN method : 
		uint16_t msgMethod = (msgType &amp; 0x000f) | ((msgType &amp; 0x00e0) &gt;&gt; 1) | ((msgType &amp; 0x3E00) &gt;&gt; 2);

		// Get STUN class: C1C0
		uint16_t msgClass = ((data[0] &amp; 0x01) &lt;&lt; 1) | ((data[1] &amp; 0x10) &gt;&gt; 4);
</code></pre> 
<h6><a id="STUN_Methods_172"></a>STUN Methods</h6> 
<h6><a id="Binding_Request0x0001_UDP__174"></a>Binding Request(0x0001): UDP 传输</h6> 
<ul><li>Binding Request 用于确定 nat 分配的绑定，客户端通过 udp 发送 Binding Request 到服务器，服务器获取到发送源的ip地址和端口，并将其复制到 Binding Response 中发送回客户端。在 Binding Request 消息中有一些参数设置使得客户端可以要求服务器在其他地方，或者用不同的 ip 和端口发送 Binding Response 。有一些属性用于提供消息完整性和身份验证。</li><li>在stun客户端和服务器端之间，Binding Request 可能会通过一层或多层 NAT 。最终的结果是，服务器接收到的请求消息的源 IP 地址和端口，是最靠近 stun 服务器的那一层 NAT 映射后的公网地址。服务器将映射后的IP地址和端口复制并填写到 Binding Response 消息中发送给客户端</li><li>当客户端接收到 Binding Response 后，将解析出来的IP地址和端口与本地 IP 地址和端口进行比较，如果不匹配，则表明 stun 客户端处于一层或多层 NAT 之后。此时只是表明 stun 客户端处于 NAT 之后，还无法判断 NAT 的类型，为了进一步决定 NAT 的类型，客户端会发送第二个 Binding Request ，这一次是往不同的 ip 地址发送，如果 Binding Response 中的 IP 地址和端口和第一次的 Binding Response 的 IP 地址和端口不一样，那么 stun 客户端处于对称型锥的 NAT 之后，为了判断是否是完全型锥的 NAT ，客户端可以发送一个 Binding Request 并要求服务端用一个不同的 IP 和端口发送 Binding Response ，换句话说，如果客户但使用 IP 为 X 端口为 Y 向 IP 为 A 端口为 B 的主机发送请求， stun 服务器使用 IP 为 C 端口为 D 向客户端发送回应，如果客户端能收到回应则表明其处于完全型锥。客户端也可以要求服务器使用相同的IP地址但端口不同来发送回应，以此来判断是处于端口限制型锥还是限制型锥。</li></ul> 
<h6><a id="Shared_Secret_Request0x0002_Reserved_was_SharedSecret_TCP__TLS__180"></a>Shared Secret Request(0x0002): (Reserved; was SharedSecret): TCP 的 TLS 传输</h6> 
<ul><li>Shared Secret Request 要求服务器返回一个临时的 username 和 password，这个 username 和 password 用于后续的 Binding Request 和 Binding Response ，保证身份认证和消息完整。</li></ul> 
<h6><a id="STUN_Attributes_185"></a>STUN Attributes</h6> 
<p>由 0~N个消息属性构成</p> 
<pre><code>/*
		    STUN Attributes

		    After the STUN header are zero or more attributes.  Each attribute
		    MUST be TLV encoded, with a 16-bit type, 16-bit length, and value.
		    Each STUN attribute MUST end on a 32-bit boundary.  As mentioned
		    above, all fields in an attribute are transmitted most significant
		    bit first.

		        0                   1                   2                   3
		        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		       |         Type                  |            Length             |
		       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		       |                         Value (variable)                ....
		       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		 */

		// Start looking for attributes after STUN header (Byte #20).
</code></pre> 
<ol><li>Type</li></ol> 
<p>类型值介于 0x0000 和 0x7FFF 之间的属性是需要理解的属性，这意味着 STUN 代理无法成功处理消息，除非它理解该属性。类型值介于 0x8000 和 0xFFFF 之间的属性是可选属性，这意味着如果 STUN 代理不理解这些属性，则可以忽略这些属性。</p> 
<pre><code>Comprehension-required range (0x0000-0x7FFF):
0x0000: (Reserved)
0x0001: MAPPED-ADDRESS
0x0002: (Reserved; was RESPONSE-ADDRESS)
0x0003: (Reserved; was CHANGE-ADDRESS)
0x0004: (Reserved; was SOURCE-ADDRESS)
0x0005: (Reserved; was CHANGED-ADDRESS)
0x0006: USERNAME
0x0007: (Reserved; was PASSWORD)
0x0008: MESSAGE-INTEGRITY
0x0009: ERROR-CODE
0x000A: UNKNOWN-ATTRIBUTES
0x000B: (Reserved; was REFLECTED-FROM)
0x0014: REALM
0x0015: NONCE
0x0020: XOR-MAPPED-ADDRESS

Comprehension-optional range (0x8000-0xFFFF)
0x8022: SOFTWARE
0x8023: ALTERNATE-SERVER
0x8028: FINGERPRINT     #FINGERPRINT must be the last attribute
</code></pre> 
<ol start="2"><li>Length<br> lenght 字段的值只表示 TLV 中 V(Value) 的长度，既不包括 T(Type) 和 L(length)，又不包括 padding 填充数据的长度</li></ol> 
<h6><a id="MAPPEDADDRESS0x0001_241"></a>MAPPED-ADDRESS(0x0001)</h6> 
<p>MAPPED-ADDRESS 属性表示客户端的映射传输地址。它由一个8位地址族和一个16位端口组成，后跟一个表示IP地址的固定长度值。如果地址族为IPv4，则地址必须为32位。如果地址族为IPv6，则地址必须为128位。所有字段必须按网络字节顺序排列。</p> 
<pre><code>   The format of the MAPPED-ADDRESS attribute is:

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 0 0 0 0 0|    Family     |           Port                |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      |                 Address (32 bits or 128 bits)                 |
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

               Figure 5: Format of MAPPED-ADDRESS Attribute

   The address family can take on the following values:

   0x01:IPv4
   0x02:IPv6

   The first 8 bits of the MAPPED-ADDRESS MUST be set to 0 and MUST be
   ignored by receivers.  These bits are present for aligning parameters
   on natural 32-bit boundaries.

   This attribute is used only by servers for achieving backwards
   compatibility with RFC 3489 [RFC3489] clients.
</code></pre> 
<h6><a id="USERNAME0x0006_273"></a>USERNAME(0x0006)</h6> 
<p>USERNAME 属性用于消息的完整性检查，用于消息完整性检查中标识共享私密。USERNAME 通常出现在共享私密响应中，与 PASSWORD 一起。当使用消息完整性检查时，可有选择地出现在捆绑请求中。</p> 
<h6><a id="MESSAGEINTEGRITY0x0008_278"></a>MESSAGE-INTEGRITY(0x0008)</h6> 
<p>MESSAGE-INTEGRITY 属性包含 STUN 消息的 HMAC-SHA1，它可以出现在捆绑请求或捆绑响应中；MESSAGE-INTEGRITY 属性必须是任何 STUN 消息的最后一个属性。它的内容决定了 HMAC 输入的 Key 值。</p> 
<pre><code>   The key for the HMAC depends on whether long-term or short-term
   credentials are in use.  For long-term credentials, the key is 16
   bytes:

            key = MD5(username ":" realm ":" SASLprep(password))

   That is, the 16-byte key is formed by taking the MD5 hash of the
   result of concatenating the following five fields: (1) the username,
   with any quotes and trailing nulls removed, as taken from the
   USERNAME attribute (in which case SASLprep has already been applied);
   (2) a single colon; (3) the realm, with any quotes and trailing nulls
   removed; (4) a single colon; and (5) the password, with any trailing
   nulls removed and after processing using SASLprep.  For example, if
   the username was 'user', the realm was 'realm', and the password was
   'pass', then the 16-byte HMAC key would be the result of performing
   an MD5 hash on the string 'user:realm:pass', the resulting hash being
   0x8493fbc53ba582fb4c044c456bdc40eb.

   For short-term credentials:

                          key = SASLprep(password)

   where MD5 is defined in RFC 1321 [RFC1321] and SASLprep() is defined
   in RFC 4013 [RFC4013].
</code></pre> 
<h6><a id="ERRORCODE0x0009_309"></a>ERROR-CODE(0x0009)</h6> 
<p>ERROR-CODE 属性出现在捆绑错误响应或共享私密错误响应中。它的响应号数值范围从 100 到 699，目前定义如下：</p> 
<pre><code>       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |           Reserved, should be 0         |Class|     Number    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      Reason Phrase (variable)                                ..
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Figure 7: ERROR-CODE Attribute

300（尝试备用）：客户端应为此请求联系备用服务器。只有当请求包含USERNAME属性和有效的MESSAGEINTEGRITY属性时，才能发送此错误响应；否则，不得发送
400（错误请求）：请求变形了。客户在修改先前的尝试前不应该重试该请求。
401（未授权）：捆绑请求没有包含MESSAGE-INTERITY属性。
420（未知属性）：服务器不认识请求中的强制属性。
438（过时的Nonce）:客户端使用的Nonce不再有效
500（服务器错误）：服务器遇到临时错误，客户应该再次尝试。
</code></pre> 
<h6><a id="UNKNOWNATTRIBUTES0x000A_332"></a>UNKNOWN-ATTRIBUTES(0x000A)</h6> 
<p>UNKNOWN-ATTRIBUTES 属性只在错误代码为420的的错误响应中出现。</p> 
<h6><a id="REALM0x0014_336"></a>REALM(0x0014)</h6> 
<p>REALM 属性可能出现在请求和响应中。请求中存在 REALM 属性表示正在使用长期凭据进行身份验证。当在错误响应中出现表明服务器希望客户端使用长期凭据进行身份验证。</p> 
<h6><a id="Nonce0x0015_341"></a>Nonce(0x0015)</h6> 
<p>Number used once</p> 
<ol><li> <p>在密码学中Nonce是一个只被使用一次的任意或非重复的随机数值，在加密技术中的初始向量和加密散列函数都发挥着重要作用，在各类验证协议的通信应用中确保验证信息不被重复使用以对抗重放攻击(Replay Attack)。在信息安全中，Nonce是一个在加密通信只能使用一次的数字。在认证协议中，它往往是一个随机或伪随机数，以避免重放攻击。Nonce也用于流密码以确保安全。如果需要使用相同的密钥加密一个以上的消息，就需要Nonce来确保不同的消息与该密钥加密的密钥流不同。</p> </li><li> <p>具体应用:在摘要认证中服务器让客户选一个随机数（称作”nonce“），然后浏览器使用一个单向的加密函数生成一个消息摘要（message digest），该摘要是关于用户名、密码、给定的nonce值、HTTP方法，以及所请求的URL。</p> </li></ol> 
<ul><li>一个典型的基于 nonce 的验证协议如下：<br> 这里的 cnonce 为 client nonce（后面将讨论为什么需要 cnonce）。Client 并不直接发送密码（或者密码直接加密后的密文）用以避免攻击者直接窃取密码（或者密码直接加密后的密文）并冒充用户进行身份验证。先不考虑 Client nonce。Server 首先发送 nonce 到 Client，Client 将密码和 nonce 通过 hash 运算再提交到 Server 进行身份验证，这样我们可以认为（而非绝对）每次用于身份验证的 hash 值都不相同，即使攻击者窃取了前一次用于身份验证的 hash 值也无法冒充用户进行登录。公式如下：</li></ul> 
<pre><code>A = Hash(nonce, password)；
</code></pre> 
<p>在不安全的网络环境中，A、nonce、Hash 算法都可以被攻击者获取，如果能够满足以下条件：</p> 
<pre><code>nonce 仅仅被使用一次
Hash 运算不出现冲突
攻击者则在理论上无法实施 Replay attack
</code></pre> 
<p>因此 nonce 在特定上下文中仅仅被使用一次以及 Hash 算法尽量避免冲突是安全的关键。为了确保 nonce 在特定上下文中仅仅被使用一次，可以使用以下策略生成 nonce ：nonce 可以是一个时间相关变量，nonce 可以是一个通过足够随机算法生成的足够长的 bits。</p> 
<ol start="3"><li>stun 应用：客户端初始发送一个请求，没有提供任何证书和任何完整性检测。服务器拒绝这个请求，并提供给用户一个范围（用于指导用户或代理选择 username 和 password ）和一个 nonce 。这个 nonce 提供重放保护。它是一个 cookie ，由服务器选择，以这样一种方式来标示有效时间或客户端身份是有效的。客户端重试这个请求，这次包括它的 username 和 realm 和服务器提供的 nonce 来回应。服务器确认这个 nonce 和检查这 message integrity 。如果它们匹配，请求则通过认证。如果这个 nonce 不再有效，即过期了，服务器就拒绝该请求，并提供一个新的nonce。在随后的到同一服务器的请求，客户端重新使用这个 nonce、username 和 realm，和先前使用的 password 。这样，随后的请求不会被拒绝直到这个 nonce 变成无效的。</li></ol> 
<h6><a id="XORMAPPEDADDRESS0x0020_367"></a>XOR-MAPPED-ADDRESS(0x0020)</h6> 
<p>XOR-MAPPED-ADDRESS 属性与 MAPPED-ADDDRESS 属性相同，只是反射传输地址通过 XOR 函数进行模糊处理</p> 
<h6><a id="SOFTWARE_attribute0x8022_371"></a>SOFTWARE attribute(0x8022)</h6> 
<p>包含软件的文本描述并由发送消息的代理使用。客户和服务器都可以使用，其值应包括制造商和版本。该属性对协议的操作没有影响，并且仅用作诊断和调试目的的工具。SOFTWARE的值是可变长度。它必须是UTF-8[RFC3629]少于128个字符的编码序列（可以长达763字节）</p> 
<pre><code>If the agent is sending a request, it SHOULD add a SOFTWARE attribute
to the request. Agents MAY include a SOFTWARE attribute in
indications, depending on the method. Extensions to STUN should
discuss whether SOFTWARE is useful in new indications
</code></pre> 
<h6><a id="FINGERPRINT0x8028_381"></a>FINGERPRINT(0x8028)</h6> 
<p>FINGERPRINT 属性可能存在于所有STUN消息中。这个属性值计算 STUN 消息的 CRC-32，直到（但不包括）FINGERPRINT 属性本身，用 32 位值 0x5354554e 进行异或运算（如果应用程序数据包中也使用CRC-32）。</p> 
<h4><a id="Traversal_Using_Relays_around_NAT_TURN_386"></a>Traversal Using Relays around NAT (TURN)</h4> 
<h5><a id="_RFC_5766_388"></a>协议文档 RFC 5766</h5> 
<h5><a id="Relay_Extensions_to_Session_Traversal_Utilities_for_NAT_STUN_389"></a>Relay Extensions to Session Traversal Utilities for NAT (STUN)</h5> 
<p>STUN 的中继扩展。TURN 与 STUN 的共同点都是通过修改应用层中的私网地址达到 NAT 穿透的效果，异同点是 TURN 是通过两方通讯的“中间人”方式实现穿透。如果一个主机位于 NAT 的后面，在某些情况下它不能够与其他主机点对点直接连接（对称 NAT）。在这些情况下，它需要使用中间网点提供的中继连接服务。TURN 协议就是用来允许主机控制中继的操作并且使用中继与对端交换数据。TURN 与其他中继控制协议不同的是它能够允许一个客户端使用一个中继地址与多个对端连接。</p> 
<pre><code>
                                        Peer A
                                        Server-Reflexive    +---------+
                                        Transport Address   |         |
                                        192.0.2.150:32102   |         |
                                            |              /|         |
                          TURN              |            / ^|  Peer A |
    Client's              Server            |           /  ||         |
    Host Transport        Transport         |         //   ||         |
    Address               Address           |       //     |+---------+
   10.1.1.2:49721       192.0.2.15:3478     |+-+  //     Peer A
            |               |               ||N| /       Host Transport
            |   +-+         |               ||A|/        Address
            |   | |         |               v|T|     192.168.100.2:49582
            |   | |         |               /+-+
 +---------+|   | |         |+---------+   /              +---------+
 |         ||   |N|         ||         | //               |         |
 | TURN    |v   | |         v| TURN    |/                 |         |
 | Client  |----|A|----------| Server  |------------------|  Peer B |
 |         |    | |^         |         |^                ^|         |
 |         |    |T||         |         ||                ||         |
 +---------+    | ||         +---------+|                |+---------+
                | ||                    |                |
                | ||                    |                |
                +-+|                    |                |
                   |                    |                |
                   |                    |                |
             Client's                   |            Peer B
             Server-Reflexive    Relayed             Transport
             Transport Address   Transport Address   Address
             192.0.2.1:7000      192.0.2.15:50000     192.0.2.210:49191

                    Figure 1： shows a typical deployment. 
</code></pre> 
<h6><a id="_429"></a>相关概念</h6> 
<h6><a id="Transports_432"></a>Transports：传输方式</h6> 
<pre><code>   TURN, as defined in this specification, always uses UDP between the
   server and the peer.  However, this specification allows the use of
   any one of UDP, TCP, or Transport Layer Security (TLS) over TCP to
   carry the TURN messages between the client and the server.

           +----------------------------+---------------------+
           | TURN client to TURN server | TURN server to peer |
           +----------------------------+---------------------+
           |             UDP            |         UDP         |
           |             TCP            |         UDP         |
           |        TLS over TCP        |         UDP         |
           +----------------------------+---------------------+
</code></pre> 
<h6><a id="Allocationsclient__server__450"></a>Allocations:client 请求 server 分配中继地址</h6> 
<p>客户端在没有凭据的情况下向服务器发送 Allocate 请求。由于服务器要求使用 STUN 的长期凭据机制对所有请求进行身份验证，因此服务器拒绝请求，并返回 401（未授权）错误代码。然后客户端再次尝试，这次包括凭据（未显示）。这一次，服务器接受 Allocate 请求并返回一个 Allocate success 响应，其中包含分配给中继传输地址。一旦分配了中继传输地址，客户端必须保留分配活动。为此，客户端定期向服务器发送刷新请求。TURN 故意使用不同的方法（刷新而不是分配）进行刷新，以确保在分配因某种原因消失时通知客户端。刷新事务的频率由分配的生存期决定，分配的默认生存期为 10 分钟——该值被选择为足够长，这样刷新通常不会给客户端带来负担，而在客户端意外及时退出的情况下，分配将过期。但是，客户机可以在 Allocate 请求中请求更长的生存期，也可以在 Refresh 请求中修改其请求，并且服务器总是在响应中指示实际的生存期。客户端必须在“生存期”秒内发出新的刷新事务。</p> 
<pre><code>  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |-- Allocate request ---------------&gt;|             |             |
    |                                    |             |             |
    |&lt;--------------- Allocate failure --|             |             |
    |                 (401 Unauthorized) |             |             |
    |                                    |             |             |
    |-- Allocate request ---------------&gt;|             |             |
    |                                    |             |             |
    |&lt;---------- Allocate success resp --|             |             |
    |            (192.0.2.15:50000)      |             |             |
    //                                   //            //            //
    |                                    |             |             |
    |-- Refresh request ----------------&gt;|             |             |
    |                                    |             |             |
    |&lt;----------- Refresh success resp --|             |             |
    |                                    |             |             |

                                 Figure 2
</code></pre> 
<ol><li>client Allocate request 相关属性：</li></ol> 
<ul><li>MUST include a REQUESTED-TRANSPORT attribute：指明传输方式，目前只支持 UDP</li><li>MAY include a LIFETIME attribute：请求过期时间（默认 10 分钟），低于此值服务器忽略，高于根据服务器实际响应确定</li><li>MAY include a DONT-FRAGMENT attribute：ip 报文分片不启用</li><li>MAY include a EVEN-PORT attribute：期望分配偶数端口</li><li>MAY include a RESERVATION-TOKEN attribute：请求服务器分配一个预先保留的端口</li></ul> 
<ol start="2"><li>Receiving an Allocate request success response</li></ol> 
<ul><li>An XOR-RELAYED-ADDRESS attribute： containing the relayed transport address.</li><li>A LIFETIME attribute： 目前的过期时间</li><li>A RESERVATION-TOKEN attribute： (if a second relayed transport address was reserved).</li><li>An XOR-MAPPED-ADDRESS attribute： client’s IP address and port (from the 5-tuple).</li></ul> 
<p>具体的例子如下：</p> 
<pre><code>  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |                                    |             |             |
    |--- Allocate request --------------&gt;|             |             |
    |    Transaction-Id=0xA56250D3F17ABE679422DE85     |             |
    |    SOFTWARE="Example client, version 1.03"       |             |
    |    LIFETIME=3600 (1 hour)          |             |             |
    |    REQUESTED-TRANSPORT=17 (UDP)    |             |             |
    |    DONT-FRAGMENT                   |             |             |
    |                                    |             |             |
    |&lt;-- Allocate error response --------|             |             |
    |    Transaction-Id=0xA56250D3F17ABE679422DE85     |             |
    |    SOFTWARE="Example server, version 1.17"       |             |
    |    ERROR-CODE=401 (Unauthorized)   |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |                                    |             |             |
    |--- Allocate request --------------&gt;|             |             |
    |    Transaction-Id=0xC271E932AD7446A32C234492     |             |// 重新分配 Transaction-Id
    |    SOFTWARE="Example client 1.03"  |             |             |
    |    LIFETIME=3600 (1 hour)          |             |             |// 请求过期时间 3600s
    |    REQUESTED-TRANSPORT=17 (UDP)    |             |             |
    |    DONT-FRAGMENT                   |             |             |
    |    USERNAME="George"               |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
    |                                    |             |             |
    |&lt;-- Allocate success response ------|             |             |
    |    Transaction-Id=0xC271E932AD7446A32C234492     |             |
    |    SOFTWARE="Example server, version 1.17"       |             |
    |    LIFETIME=1200 (20 minutes)      |             |             |// 以实际为准：1200s
    |    XOR-RELAYED-ADDRESS=192.0.2.15:50000          |             |// 中继 ip:port
    |    XOR-MAPPED-ADDRESS=192.0.2.1:7000             |             |// client nat 映射的 ip:port
    |    MESSAGE-INTEGRITY=...           |             |             |
</code></pre> 
<h6><a id="exchange_application_data_531"></a>exchange application data：数据交换</h6> 
<p>client 和 peer 方有两种应用程序数据交换机制使用TURN服务器:</p> 
<ul><li>Send Mechanism: Send and Data methods</li><li>Channels</li></ul> 
<h6><a id="Send_Mechanism_Send_and_Data_methods_538"></a>Send Mechanism: Send and Data methods</h6> 
<pre><code>  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |                                    |             |             |
    |-- CreatePermission req (Peer A) --&gt;|             |             |
    |&lt;-- CreatePermission success resp --|             |             |
    |                                    |             |             |
    |--- Send ind (Peer A)--------------&gt;|             |             |
    |                                    |=== data ===&gt;|             |
    |                                    |             |             |
    |                                    |&lt;== data ====|             |
    |&lt;-------------- Data ind (Peer A) --|             |             |
    |                                    |             |             |
    |                                    |             |             |
    |--- Send ind (Peer B)--------------&gt;|             |             |
    |                                    | dropped     |             |
    |                                    |             |             |
    |                                    |&lt;== data ==================|
    |                            dropped |             |             |
    |                                    |             |             |

                                 Figure 3
</code></pre> 
<ol><li>CreatePermission request</li></ol> 
<ul><li>MUST include at least one XOR-PEER-ADDRESS attribute, and MAY include more than one such attribute：XOR-PEER-ADDRESS 属性的 IP 地址部分包含应安装或刷新权限的 IP 地址。每个 XOR-PEER-ADDRESS 属性的端口部分将被忽略，可以是任意值。各种 XOR-PEER-ADDRESS 属性可以以任何顺序出现。</li></ul> 
<ol start="2"><li>Receiving a CreatePermission Response</li></ol> 
<ul><li>如果客户端收到有效的 CreatePermission 成功响应，则客户端会更新其数据结构，以指示已安装或刷新权限</li></ul> 
<pre><code>
  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- CreatePermission request ------&gt;|             |             |
    |    Transaction-Id=0xE5913A8F460956CA277D3319     |             |
    |    XOR-PEER-ADDRESS=192.0.2.150:0  |             |             |// peer 端的 ip,port 可为任意值
    |    USERNAME="George"               |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
    |                                    |             |             |
    |&lt;-- CreatePermission success resp.--|             |             |
    |    Transaction-Id=0xE5913A8F460956CA277D3319     |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
</code></pre> 
<ol start="3"><li>Send indication</li></ol> 
<ul><li>MUST include an XOR-PEERADDRESS attribute</li><li>MUST include a DATA attribute</li><li>MAY include a DONT-FRAGMENT attribute</li></ul> 
<ol start="4"><li>Data Indication</li></ol> 
<ul><li>MUST include an XOR-PEERADDRESS attribute</li><li>MUST include a DATA attribute</li></ul> 
<pre><code>  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- Send indication ---------------&gt;|             |             |
    |    Transaction-Id=0x1278E9ACA2711637EF7D3328     |             |
    |    XOR-PEER-ADDRESS=192.0.2.150:32102            |             |// peer nat 映射 ip:port
    |    DONT-FRAGMENT                   |             |             |
    |    DATA=...                        |             |             |
    |                                    |-- UDP dgm -&gt;|             |
    |                                    |  data=...   |             |
    |                                    |             |             |
    |                                    |&lt;- UDP dgm --|             |
    |                                    |  data=...   |             |
    |&lt;-- Data indication ----------------|             |             |
    |    Transaction-Id=0x8231AE8F9242DA9FF287FEFF     |             |
    |    XOR-PEER-ADDRESS=192.0.2.150:32102            |             |
    |    DATA=...                        |             |             |

     client sends application data to Peer A using a Send indication.
</code></pre> 
<h6><a id="Channels_616"></a>Channels</h6> 
<ol><li>ChannelData Message: 封装 client 和 server 之间的 application data</li></ol> 
<ul><li>Channel Number：2 字节：</li></ul> 
<pre><code>0x0000 through 0x3FFF: These values can never be used for channel numbers.
0x4000 through 0x7FFF: These values are the allowed channel numbers (16,383 possible values).
0x8000 through 0xFFFF: These values are reserved for future use.
</code></pre> 
<p>从上面的划分可以前两位的值来区分 STUN-formatted message 和 ChannelData message：</p> 
<pre><code>0b00: STUN-formatted message (since the first two bits of a STUN-formatted message are always zero).
0b01: ChannelData message (since the channel number is the first field in the ChannelData message 
      and channel numbers fall in the range 0x4000 - 0x7FFF).
</code></pre> 
<pre><code>    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Channel Number        |            Length             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   /                       Application Data                        /
   /                                                               /
   |                                                               |
   |                               +-------------------------------+
   |                               |
   +-------------------------------+

   The Channel Number field specifies the number of the channel on which
   the data is traveling, and thus the address of the peer that is
   sending or is to receive the data.

   The Length field specifies the length in bytes of the application
   data field (i.e., it does not include the size of the ChannelData
   header).  Note that 0 is a valid length.

   The Application Data field carries the data the client is trying to
   send to the peer, or that the peer is sending to the client.
</code></pre> 
<pre><code>  client                               server          A             B
    |                                    |             |             |
    |-- ChannelBind req ----------------&gt;|             |             |
    | (Peer A to 0x4001)                 |             |             |
    |                                    |             |             |
    |&lt;---------- ChannelBind succ resp --|             |             |
    |                                    |             |             |
    |-- [0x4001] data ------------------&gt;|             |             |
    |                                    |=== data ===&gt;|             |
    |                                    |             |             |
    |                                    |&lt;== data ====|             |
    |&lt;------------------ [0x4001] data --|             |             |
    |                                    |             |             |
    |--- Send ind (Peer A)--------------&gt;|             |             |
    |                                    |=== data ===&gt;|             |
    |                                    |             |             |
    |                                    |&lt;== data ====|             |
    |&lt;------------------ [0x4001] data --|             |             |
    |                                    |             |             |

                                 Figure 4
</code></pre> 
<ol start="2"><li>Sending a ChannelBind Request</li></ol> 
<ul><li>MUST include a CHANNEL-NUMBER attribute</li><li>MUST include an XOR-PEER-ADDRESS attribute : the peer’s transport address</li></ul> 
<ol start="3"><li>Receiving a ChannelBind Response</li></ol> 
<ul><li>当客户端收到 ChannelBind 成功响应时，它会更新其数据结构，以记录通道绑定现在处于活动状态。它还更新其数据结构，以记录已安装或刷新了相应的权限。</li></ul> 
<pre><code>  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- ChannelBind request -----------&gt;|             |             |
    |    Transaction-Id=0x6490D3BC175AFF3D84513212     |             |
    |    CHANNEL-NUMBER=0x4000           |             |             |
    |    XOR-PEER-ADDRESS=192.0.2.210:49191            |             |
    |    USERNAME="George"               |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
    |                                    |             |             |
    |&lt;-- ChannelBind success response ---|             |             |
    |    Transaction-Id=0x6490D3BC175AFF3D84513212     |             |
    |    MESSAGE-INTEGRITY=...           |             |             |

   The client now binds a channel to Peer B, specifying a free channel
   number (0x4000) in the CHANNEL-NUMBER attribute, and Peer B's
   transport address in the XOR-PEER-ADDRESS attribute.  As before, the
   client re-uses the username, realm, and nonce from its last request
   in the message.

   Upon receipt of the request, the server binds the channel number to
   the peer, installs a permission for Peer B's IP address, and then
   replies with ChannelBind success response.
</code></pre> 
<pre><code> TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- ChannelData -------------------&gt;|             |             |
    |    Channel-number=0x4000           |--- UDP datagram ---------&gt;|
    |    Data=...                        |    Data=...               |
    |                                    |             |             |
    |                                    |&lt;-- UDP datagram ----------|
    |                                    |    Data=... |             |
    |&lt;-- ChannelData --------------------|             |             |
    |    Channel-number=0x4000           |             |             |
    |    Data=...                        |             |             |

   The client now sends a ChannelData message to the server with data
   destined for Peer B.  The ChannelData message is not a STUN message,
   and thus has no transaction id.  Instead, it has only three fields: a
   channel number, data, and data length
</code></pre> 
<h6><a id="New_STUN_Methods_737"></a>New STUN Methods</h6> 
<h6><a id="0x0003__Allocate_only_requestresponse_semantics_defined_740"></a>0x0003 : Allocate (only request/response semantics defined)</h6> 
<h6><a id="0x0004__Refresh_only_requestresponse_semantics_defined_742"></a>0x0004 : Refresh (only request/response semantics defined)</h6> 
<h6><a id="0x0006__Send_only_indication_semantics_defined__client__server_744"></a>0x0006 : Send (only indication semantics defined): 将数据从 client 传递 server</h6> 
<h6><a id="0x0007__Data_only_indication_semantics_defined__server__client_746"></a>0x0007 : Data (only indication semantics defined): 将数据从 server 传递 client</h6> 
<h6><a id="0x0008__CreatePermission_only_requestresponse_semantics_defined_748"></a>0x0008 : CreatePermission (only request/response semantics defined</h6> 
<h6><a id="0x0009__ChannelBind_only_requestresponse_semantics_defined_750"></a>0x0009 : ChannelBind (only request/response semantics defined)</h6> 
<h6><a id="New_STUN_Attributes_753"></a>New STUN Attributes</h6> 
<pre><code>0x000C: CHANNEL-NUMBER
0x000D: LIFETIME
0x0010: Reserved (was BANDWIDTH)
0x0012: XOR-PEER-ADDRESS
0x0013: DATA
0x0016: XOR-RELAYED-ADDRESS
0x0018: EVEN-PORT
0x0019: REQUESTED-TRANSPORT
0x001A: DONT-FRAGMENT
0x0021: Reserved (was TIMER-VAL)
0x0022: RESERVATION-TOKEN
</code></pre> 
<h6><a id="CHANNELNUMBER0x000C_769"></a>CHANNEL-NUMBER(0x000C)</h6> 
<p>CHANNEL-NUMBER 属性包含通道的号码。属性长 4 字节，包含 16 比特的无符号整数和2字节的 RFFU（Reserved For Future Use）字段，该字段必须设为 0 且在接收时被忽略。</p> 
<pre><code>      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |        Channel Number         |         RFFU = 0              |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre> 
<h6><a id="LIFETIME0x000D_781"></a>LIFETIME(0x000D)</h6> 
<p>LIFETIME 属性表示服务器在没有收到 refresh 时维持一个 allocation 的持续时间。属性长 4 字节，包含一个 32 比特的无符号整数值，表示剩余多少秒终止。</p> 
<h6><a id="XORPEERADDRESS0x0012_785"></a>XOR-PEER-ADDRESS(0x0012)</h6> 
<p>XOR-PEER-ADDRESS 指明从 TURN 服务器侧看到的对等方的地址和端口。（例如，如果对等方位于 NAT 之后，则值为对等方的服务器反射传输地址。）它的编码方式与 XOR-MAPPED-ADDRESS 相同。</p> 
<h6><a id="DATA0x0013_790"></a>DATA(0x0013)</h6> 
<p>DATA 属性存在于所有的 Send 和 Data indications 消息中。属性的值是可变长度的，包括应用数据。如果属性的长度不上4字节的倍数，必须进行填充。</p> 
<h6><a id="XORRELAYEDADDRESS0x0016_794"></a>XOR-RELAYED-ADDRESS(0x0016)</h6> 
<p>XOR-RELAYED-ADDRESS 存在于所有的 Allocate 响应中。它指定了服务器分配给客户端的地址和端口。和 XOR-MAPPED-ADDRESS 属性编码方式相同：</p> 
<pre><code>       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 0 0 0 0 0|    Family     |           Port                |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      |                 Address (32 bits or 128 bits)                 |
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre> 
<h6><a id="EVENPORT0x0018_811"></a>EVEN-PORT(0x0018)：偶数端口</h6> 
<p>此属性允许客户端请求中继传输地址中的端口为偶数，并且（可选）服务器保留下一个更高的端口号。此属性的值部分长度为 1 字节。其格式为：</p> 
<pre><code>      0 1 2 3 4 5 6 7
     +-+-+-+-+-+-+-+-+
     |R|    RFFU     |
     +-+-+-+-+-+-+-+-+

   The value contains a single 1-bit flag:

   R: If 1, the server is requested to reserve the next-higher port
      number (on the same IP address) for a subsequent allocation.  If
      0, no such reservation is requested.

   The other 7 bits of the attribute's value must be set to zero on
   transmission and ignored on reception.

   Since the length of this attribute is not a multiple of 4, padding
   must immediately follow this attribute.
</code></pre> 
<h6><a id="REQUESTEDTRANSPORT0x0019_834"></a>REQUESTED-TRANSPORT(0x0019)</h6> 
<p>client 发出 Allocation 请求指定传输类型：</p> 
<ul><li>Protocol：指定需求的协议。可以取自 IPv4 报头中的协议字段的值或 IPv6 报头的下一个报头字段的协议号。目前仅允许设置为 17 ，即UDP。</li><li>RFFU 字段在传输时必须设置为0，并在接收时被忽略。保留用于未来使用。</li></ul> 
<pre><code>   This attribute is used by the client to request a specific transport
   protocol for the allocated transport address.  The value of this
   attribute is 4 bytes with the following format:
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |    Protocol   |                    RFFU                       |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The Protocol field specifies the desired protocol.  The codepoints
   used in this field are taken from those allowed in the Protocol field
   in the IPv4 header and the NextHeader field in the IPv6 header
   [Protocol-Numbers].  This specification only allows the use of
   codepoint 17 (User Datagram Protocol).

   The RFFU field MUST be set to zero on transmission and MUST be
   ignored on reception.  It is reserved for future uses.
</code></pre> 
<h6><a id="DONTFRAGMENT0x001A_859"></a>DONT-FRAGMENT(0x001A)</h6> 
<p>客户端使用该属性来请求服务器设置 IP 报头中的 DF（不要分片）位，当中继应用数据到对端时。该属性没有值，因此属性长度字段为 0。</p> 
<h6><a id="RESERVATIONTOKEN0x0022_864"></a>RESERVATION-TOKEN(0x0022)</h6> 
<p>RESERVATION-TOKEN 属性包含一个 token 来唯一的标识一个中继传输地址已经被服务器保留。服务器在一个成功响应中包含该属性来告诉客户端这个 token，客户端在接下来的 Allocate 请求中包括该属性来请求服务器为这个 allocation 使用那个中继传输地址。属性值是8字节长。</p> 
<h6><a id="New_STUN_Error_Response_Codes_869"></a>New STUN Error Response Codes</h6> 
<ul><li>403（Forbidden）：请求是有效的，但因管理或类似的规定而不能被执行。</li><li>437（Allocation Mismatch）：服务器接收到请求，要求在适当的位置的allocation，但没有allocation存在，或者一个收到的请求不指定任何allocation，但是一个allocation存在。</li><li>441（Wrong Credentials）：请求中的证书没有匹配那些用来创建allocation的证书</li><li>442（不支持的传输协议）：Allocate请求要求服务器使用一个用于服务器和对端的传输协议但是该服务器不支持该传输协议。</li><li>486（Allocation Quota Reached）：目前没有更多的allocations资源使用相同的用户名可被创建。</li><li>508（Insufficient Capacity）：服务器不能够完成请求因为一些性能限制已经达到上限。在一个Allocate响应中，这可能因为服务器此时已经没有更多的中继传输地址资源了，没有更多的被请求的性能，或者相当于特定的保留的token不可用。</li></ul> 
<h4><a id="Interactive_Connectivity_Establishment_ICE_879"></a>Interactive Connectivity Establishment (ICE)</h4> 
<h5><a id="_RFC_5245_881"></a>协议文档 RFC 5245</h5> 
<h5><a id="A_Protocol_for_Network_Address_Translator_NAT_Traversal_for_883"></a>A Protocol for Network Address Translator (NAT) Traversal for</h5> 
<p>Offer/Answer Protocols</p> 
<pre><code>                              +-------+
                              | SIP   |
           +-------+          | Srvr  |          +-------+
           | STUN  |          |       |          | STUN  |
           | Srvr  |          +-------+          | Srvr  |
           |       |         /         \         |       |
           +-------+        /           \        +-------+
                           /             \
                          /               \
                         /                 \
                        /                   \
                       /  &lt;-  Signaling  -&gt;  \
                      /                       \
                     /                         \
               +--------+                   +--------+
               |  NAT   |                   |  NAT   |
               +--------+                   +--------+
                 /                                \
                /                                  \
               /                                    \
           +-------+                             +-------+
           | Agent |                             | Agent |
           |   L   |                             |   R   |
           |       |                             |       |
           +-------+                             +-------+

                     Figure 1: ICE Deployment Scenario

</code></pre> 
<p>ICE 的基本想法是：两端要进行连接时，每一端都会提供多个候选者：</p> 
<ul><li>直接连接网络接口上的传输地址：如一端有两块网卡，那么每块网卡的不同端口都对应一个候选者</li><li>NAT公共端的转换传输地址（“服务器反射”地址）</li><li>从TURN服务器分配的传输地址（“中继地址”）。</li></ul> 
<p>潜在地，L 的任何候选传输地址都可以用于与R的任何候选传送地址通信。然而在实践中，许多组合都不起作用。例如，如果L和R都在NAT之后，它们直接连接的接口地址就不太可能直接通信（这就是为什么需要ICE的原因！）。ICE的目的是发现哪些地址对可以工作。ICE这样做的方式是系统地尝试所有可能的配对（按仔细排序的顺序），直到找到一个或多个有效的配对。</p> 
<h6><a id="_926"></a>相关概念</h6> 
<h6><a id="Controlling_Agent_927"></a>Controlling Agent：控制方</h6> 
<p>负责选择最终候选配对并通过STUN和更新 offer</p> 
<h6><a id="Controlled_Agent_931"></a>Controlled Agent：被控制方</h6> 
<p>等待控制代理选择最终候选对的ICE代理</p> 
<h6><a id="Gathering_Candidate_Addresses_935"></a>Gathering Candidate Addresses：收集候选者</h6> 
<ol><li>Host Candidates：本机内网的 IP 和 Port;</li></ol> 
<ul><li>候选主机是通过绑定到连接到主机上接口（物理或虚拟，包括VPN接口）的 IP 地址上的端口（通常是临时的）获得的</li></ul> 
<ol start="2"><li>Server Reflexive Candidates:本机 NAT 映射后的外网的 IP 和 Port</li><li>Server Relayed Candidates:中继服务器的 IP 和 Port</li></ol> 
<h6><a id="Sending_the_Initial_Offer_942"></a>Sending the Initial Offer</h6> 
<p>client 需要执行以下5个步骤，并提供了全量（full implementations）和轻量（lite implementations）两种方式：</p> 
<ol><li>gather candidates</li><li>prioritize them</li><li>eliminate redundant candidates</li><li>choose default candidates</li><li>formulate and send the SDP offer</li></ol> 
<h6><a id="full_implementations_952"></a>full implementations</h6> 
<h6><a id="lite_implementations_954"></a>lite implementations</h6> 
<p>lite 实现仅使用候选主机，必须为每个媒体流分配零个或一个 IPv4 候选者。它可以为主机使用的每个 IPv6 地址分配零个或多个 IPv6 候选者。由于每个媒体流的每个组件最多只能有一个 IPv4 候选地址，因此如果代理具有多个 IPv6 地址，则必须选择一个地址来分配候选地址。如果主机是双堆栈，建议它分配一个 IPv4 候选地址和一个全局 IPv6 地址。在精简实现中，ICE不能用于动态选择候选者。</p> 
<h6><a id="Encoding_the_SDP_958"></a>Encoding the SDP</h6> 
<p>对SDP进行编码的过程在full和lite之间是相同的实现。</p> 
<ul><li>ice-ufrag：username fragment：用户名片段</li><li>ice-pwd attributes：password</li><li>lite implementation: MUST include an “a=ice-lite”</li><li>utilizing RTCP: MUST encode the RTCP candidate using the a=rtcp attribute</li><li>RTCP is not in use: MUST signal that using b=RS:0 and b=RR:0</li><li>与 non-ICE peers通信时，作为媒体默认目的，传输地址也必须作为候选地址出现在一个或多个a=候选行中</li></ul> 
<p>SDP message that includes ICE attributes:</p> 
<pre><code>       v=0
       o=jdoe 2890844526 2890842807 IN IP4 10.0.1.1
       s=
       c=IN IP4 192.0.2.3
       t=0 0
       a=ice-pwd:asd88fgpdd777uzjYhagZg
       a=ice-ufrag:8hhY
       m=audio 45664 RTP/AVP 0
       b=RS:0
       b=RR:0
       a=rtpmap:0 PCMU/8000
       a=candidate:1 1 UDP 2130706431 10.0.1.1 8998 typ host
       a=candidate:2 1 UDP 1694498815 192.0.2.3 45664 typ srflx raddr 10.0.1.1 rport 8998
</code></pre> 
<h6><a id="STUN_Extensionsfour_new_attributes_988"></a>STUN Extensions:four new attributes</h6> 
<ul><li>PRIORITY :0x0024</li><li>USECANDIDATE :0x0025</li><li>ICE-CONTROLLED</li><li>ICE-CONTROLLING</li></ul> 
<h6><a id="PRIORITY0x0024_995"></a>PRIORITY(0x0024)</h6> 
<p>指明了 a peer reflexive candidate 的优先级，其值为一个 32 位无符号整数。</p> 
<h6><a id="USECANDIDATE0x0025_999"></a>USECANDIDATE(0x0025)</h6> 
<p>表示此检查产生的候选对应该要用于媒体传输，该属性没有内容（该属性的“长度”字段为零）</p> 
<h6><a id="ICECONTROLLED64__1003"></a>ICE-CONTROLLED(64 位网络字节序无符号整)</h6> 
<p>在 Binding request 和 indicates 使用此属性，表明 client 信任 controlled role</p> 
<h6><a id="ICECONTROLLING64__1007"></a>ICE-CONTROLLING(64 位网络字节序无符号整数)</h6> 
<p>在 Binding request 和 indicates 使用此属性，表明 client 信任 controlling role</p> 
<h6><a id="STUN_ExtensionsNew_Error_Response_Codes_487_Role_Conflict_1012"></a>STUN Extensions:New Error Response Codes: 487 (Role Conflict)</h6> 
<h4><a id="b__1014"></a>b 站抓包分析</h4> 
<h5><a id="Binding_Request_to_STUN_Server_1015"></a>Binding Request to STUN Server</h5> 
<p><img src="https://images2.imgbox.com/be/66/IhsrAC0P_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Binding_success_respose_from__STUN_Server_1018"></a>Binding success respose from STUN Server</h5> 
<p><img src="https://images2.imgbox.com/03/3a/aI2reXO8_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Binding_Request_to_a_Peer_1020"></a>Binding Request to a Peer</h5> 
<ol><li>当两端角色都为controlling或者controlled角色冲突时，在连通性检查阶段，要求发送binding request消息里必须要带上tie-breaker属性。</li><li>当出现冲突时，比较tie-breaker大小，值比较大的则被认为是controlling，同时回应487错误给对端，对端收到487错误后切换角色。<br> <img src="https://images2.imgbox.com/33/12/KM3fz4c9_o.png" alt="在这里插入图片描述"></li></ol> 
<h5><a id="Binding_Request_from_a_Peer_1024"></a>Binding Request from a Peer</h5> 
<p><img src="https://images2.imgbox.com/d7/46/330b8UC4_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Binding_success_respose_from_a_Client_1026"></a>Binding success respose from a Client</h5> 
<p>the Peer Host Condition<br> <img src="https://images2.imgbox.com/8c/be/R25g4bNm_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Binding_success_respose_from_a_Peer_1029"></a>Binding success respose from a Peer</h5> 
<p><img src="https://images2.imgbox.com/0c/4b/M0C1kJMk_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="mediasoup_webrtc_stun__1031"></a>mediasoup webrtc stun 源码分析</h4> 
<h5><a id="_stunData_1033"></a>接收 stunData</h5> 
<pre><code>inline void WebRtcTransport::OnStunDataReceived(
	  RTC::TransportTuple* tuple, const uint8_t* data, size_t len)
	{
		MS_TRACE();

		RTC::StunPacket* packet = RTC::StunPacket::Parse(data, len);

		if (!packet)
		{
			MS_WARN_DEV("ignoring wrong STUN packet received");

			return;
		}

		// Pass it to the IceServer.
		this-&gt;iceServer-&gt;ProcessStunPacket(packet, tuple);

		delete packet;
	}
</code></pre> 
<h5><a id="_stunData_attribute_1056"></a>解析 stunData：获取 attribute</h5> 
<pre><code>private:
		// Passed by argument.
		Class klass;                             // 2 bytes.
		Method method;                           // 2 bytes.
		const uint8_t* transactionId{ nullptr }; // 12 bytes.
		uint8_t* data{ nullptr };                // Pointer to binary data.
		size_t size{ 0u };                       // The full message size (including header).
		// STUN attributes.
		std::string username;          // Less than 513 bytes.
		uint32_t priority{ 0u };       // 4 bytes unsigned integer.
		uint64_t iceControlling{ 0u }; // 8 bytes unsigned integer.
		uint64_t iceControlled{ 0u };  // 8 bytes unsigned integer.
		bool hasNomination{ false };
		uint32_t nomination{ 0u };                          // 4 bytes unsigned integer.
		bool hasUseCandidate{ false };                      // 0 bytes.
		const uint8_t* messageIntegrity{ nullptr };         // 20 bytes.
		bool hasFingerprint{ false };                       // 4 bytes.
		const struct sockaddr* xorMappedAddress{ nullptr }; // 8 or 20 bytes.
		uint16_t errorCode{ 0u };                           // 4 bytes (no reason phrase).
		std::string password;
</code></pre> 
<pre><code>StunPacket* StunPacket::Parse(const uint8_t* data, size_t len)
	{
		MS_TRACE();

		if (!StunPacket::IsStun(data, len))
			return nullptr;

		/*
		  The message type field is decomposed further into the following
		    structure:

		    0                 1
		    2  3  4 5 6 7 8 9 0 1 2 3 4 5
		       +--+--+-+-+-+-+-+-+-+-+-+-+-+-+
		       |M |M |M|M|M|C|M|M|M|C|M|M|M|M|
		       |11|10|9|8|7|1|6|5|4|0|3|2|1|0|
		       +--+--+-+-+-+-+-+-+-+-+-+-+-+-+

		    Figure 3: Format of STUN Message Type Field

		   Here the bits in the message type field are shown as most significant
		   (M11) through least significant (M0).  M11 through M0 represent a 12-
		   bit encoding of the method.  C1 and C0 represent a 2-bit encoding of
		   the class.
		 */

		// Get type field.
		uint16_t msgType = Utils::Byte::Get2Bytes(data, 0);

		// Get length field.
		uint16_t msgLength = Utils::Byte::Get2Bytes(data, 2);

		// length field must be total size minus header's 20 bytes, and must be multiple of 4 Bytes.
		if ((static_cast&lt;size_t&gt;(msgLength) != len - 20) || ((msgLength &amp; 0x03) != 0))
		{
			MS_WARN_TAG(
			  ice,
			  "length field + 20 does not match total size (or it is not multiple of 4 bytes), "
			  "packet discarded");

			return nullptr;
		}

		// Get STUN method.
		uint16_t msgMethod = (msgType &amp; 0x000f) | ((msgType &amp; 0x00e0) &gt;&gt; 1) | ((msgType &amp; 0x3E00) &gt;&gt; 2);

		// Get STUN class.
		uint16_t msgClass = ((data[0] &amp; 0x01) &lt;&lt; 1) | ((data[1] &amp; 0x10) &gt;&gt; 4);

		// Create a new StunPacket (data + 8 points to the received TransactionID field).
		auto* packet = new StunPacket(
		  static_cast&lt;Class&gt;(msgClass), static_cast&lt;Method&gt;(msgMethod), data + 8, data, len);

		/*
		    STUN Attributes

		    After the STUN header are zero or more attributes.  Each attribute
		    MUST be TLV encoded, with a 16-bit type, 16-bit length, and value.
		    Each STUN attribute MUST end on a 32-bit boundary.  As mentioned
		    above, all fields in an attribute are transmitted most significant
		    bit first.

		        0                   1                   2                   3
		        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		       |         Type                  |            Length             |
		       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		       |                         Value (variable)                ....
		       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		 */

		// Start looking for attributes after STUN header (Byte #20).
		size_t pos{ 20 };
		// Flags (positions) for special MESSAGE-INTEGRITY and FINGERPRINT attributes.
		bool hasMessageIntegrity{ false };
		bool hasFingerprint{ false };
		size_t fingerprintAttrPos; // Will point to the beginning of the attribute.
		uint32_t fingerprint;      // Holds the value of the FINGERPRINT attribute.

		// Ensure there are at least 4 remaining bytes (attribute with 0 length).
		while (pos + 4 &lt;= len)
		{
			// Get the attribute type.
			auto attrType = static_cast&lt;Attribute&gt;(Utils::Byte::Get2Bytes(data, pos));

			// Get the attribute length.
			uint16_t attrLength = Utils::Byte::Get2Bytes(data, pos + 2);

			// Ensure the attribute length is not greater than the remaining size.
			if ((pos + 4 + attrLength) &gt; len)
			{
				MS_WARN_TAG(ice, "the attribute length exceeds the remaining size, packet discarded");

				delete packet;
				return nullptr;
			}

			// FINGERPRINT must be the last attribute.
			if (hasFingerprint)
			{
				MS_WARN_TAG(ice, "attribute after FINGERPRINT is not allowed, packet discarded");

				delete packet;
				return nullptr;
			}

			// After a MESSAGE-INTEGRITY attribute just FINGERPRINT is allowed.
			if (hasMessageIntegrity &amp;&amp; attrType != Attribute::FINGERPRINT)
			{
				MS_WARN_TAG(
				  ice,
				  "attribute after MESSAGE-INTEGRITY other than FINGERPRINT is not allowed, "
				  "packet discarded");

				delete packet;
				return nullptr;
			}

			const uint8_t* attrValuePos = data + pos + 4;

			switch (attrType)
			{
				case Attribute::USERNAME:
				{
					packet-&gt;SetUsername(
					  reinterpret_cast&lt;const char*&gt;(attrValuePos), static_cast&lt;size_t&gt;(attrLength));

					break;
				}

				case Attribute::PRIORITY:
				{
					// Ensure attribute length is 4 bytes.
					if (attrLength != 4)
					{
						MS_WARN_TAG(ice, "attribute PRIORITY must be 4 bytes length, packet discarded");

						delete packet;
						return nullptr;
					}

					packet-&gt;SetPriority(Utils::Byte::Get4Bytes(attrValuePos, 0));

					break;
				}

				case Attribute::ICE_CONTROLLING:
				{
					// Ensure attribute length is 8 bytes.
					if (attrLength != 8)
					{
						MS_WARN_TAG(ice, "attribute ICE-CONTROLLING must be 8 bytes length, packet discarded");

						delete packet;
						return nullptr;
					}

					packet-&gt;SetIceControlling(Utils::Byte::Get8Bytes(attrValuePos, 0));

					break;
				}

				case Attribute::ICE_CONTROLLED:
				{
					// Ensure attribute length is 8 bytes.
					if (attrLength != 8)
					{
						MS_WARN_TAG(ice, "attribute ICE-CONTROLLED must be 8 bytes length, packet discarded");

						delete packet;
						return nullptr;
					}

					packet-&gt;SetIceControlled(Utils::Byte::Get8Bytes(attrValuePos, 0));

					break;
				}

				case Attribute::USE_CANDIDATE:
				{
					// Ensure attribute length is 0 bytes.
					if (attrLength != 0)
					{
						MS_WARN_TAG(ice, "attribute USE-CANDIDATE must be 0 bytes length, packet discarded");

						delete packet;
						return nullptr;
					}

					packet-&gt;SetUseCandidate();

					break;
				}

				case Attribute::NOMINATION:
				{
					// Ensure attribute length is 4 bytes.
					if (attrLength != 4)
					{
						MS_WARN_TAG(ice, "attribute NOMINATION must be 4 bytes length, packet discarded");

						delete packet;
						return nullptr;
					}

					packet-&gt;SetHasNomination();
					packet-&gt;SetNomination(Utils::Byte::Get4Bytes(attrValuePos, 0));

					break;
				}

				case Attribute::MESSAGE_INTEGRITY:
				{
					// Ensure attribute length is 20 bytes.
					if (attrLength != 20)
					{
						MS_WARN_TAG(ice, "attribute MESSAGE-INTEGRITY must be 20 bytes length, packet discarded");

						delete packet;
						return nullptr;
					}

					hasMessageIntegrity = true;
					packet-&gt;SetMessageIntegrity(attrValuePos);

					break;
				}

				case Attribute::FINGERPRINT:
				{
					// Ensure attribute length is 4 bytes.
					if (attrLength != 4)
					{
						MS_WARN_TAG(ice, "attribute FINGERPRINT must be 4 bytes length, packet discarded");

						delete packet;
						return nullptr;
					}

					hasFingerprint     = true;
					fingerprintAttrPos = pos;
					fingerprint        = Utils::Byte::Get4Bytes(attrValuePos, 0);
					packet-&gt;SetFingerprint();

					break;
				}

				case Attribute::ERROR_CODE:
				{
					// Ensure attribute length &gt;= 4bytes.
					if (attrLength &lt; 4)
					{
						MS_WARN_TAG(ice, "attribute ERROR-CODE must be &gt;= 4bytes length, packet discarded");

						delete packet;
						return nullptr;
					}

					uint8_t errorClass  = Utils::Byte::Get1Byte(attrValuePos, 2);
					uint8_t errorNumber = Utils::Byte::Get1Byte(attrValuePos, 3);
					auto errorCode      = static_cast&lt;uint16_t&gt;(errorClass * 100 + errorNumber);

					packet-&gt;SetErrorCode(errorCode);

					break;
				}

				default:;
			}

			// Set next attribute position.
			pos =
			  static_cast&lt;size_t&gt;(Utils::Byte::PadTo4Bytes(static_cast&lt;uint16_t&gt;(pos + 4 + attrLength)));
		}

		// Ensure current position matches the total length.
		if (pos != len)
		{
			MS_WARN_TAG(ice, "computed packet size does not match total size, packet discarded");

			delete packet;
			return nullptr;
		}

		// If it has FINGERPRINT attribute then verify it.
		if (hasFingerprint)
		{
			// Compute the CRC32 of the received packet up to (but excluding) the
			// FINGERPRINT attribute and XOR it with 0x5354554e.
			uint32_t computedFingerprint = Utils::Crypto::GetCRC32(data, fingerprintAttrPos) ^ 0x5354554e;

			// Compare with the FINGERPRINT value in the packet.
			if (fingerprint != computedFingerprint)
			{
				MS_WARN_TAG(
				  ice,
				  "computed FINGERPRINT value does not match the value in the packet, "
				  "packet discarded");

				delete packet;
				return nullptr;
			}
		}

		return packet;
	}
</code></pre> 
<h5><a id="ICE_Server__1392"></a>ICE Server 处理</h5> 
<pre><code>void IceServer::ProcessStunPacket(RTC::StunPacket* packet, RTC::TransportTuple* tuple)
	{
		MS_TRACE();

		// Must be a Binding method.
		if (packet-&gt;GetMethod() != RTC::StunPacket::Method::BINDING)
		{
			if (packet-&gt;GetClass() == RTC::StunPacket::Class::REQUEST)
			{
				MS_WARN_TAG(
				  ice,
				  "unknown method %#.3x in STUN Request =&gt; 400",
				  static_cast&lt;unsigned int&gt;(packet-&gt;GetMethod()));

				// Reply 400.
				RTC::StunPacket* response = packet-&gt;CreateErrorResponse(400);

				response-&gt;Serialize(StunSerializeBuffer);
				this-&gt;listener-&gt;OnIceServerSendStunPacket(this, response, tuple);

				delete response;
			}
			else
			{
				MS_WARN_TAG(
				  ice,
				  "ignoring STUN Indication or Response with unknown method %#.3x",
				  static_cast&lt;unsigned int&gt;(packet-&gt;GetMethod()));
			}

			return;
		}

		// Must use FINGERPRINT (optional for ICE STUN indications).
		if (!packet-&gt;HasFingerprint() &amp;&amp; packet-&gt;GetClass() != RTC::StunPacket::Class::INDICATION)
		{
			if (packet-&gt;GetClass() == RTC::StunPacket::Class::REQUEST)
			{
				MS_WARN_TAG(ice, "STUN Binding Request without FINGERPRINT =&gt; 400");

				// Reply 400.
				RTC::StunPacket* response = packet-&gt;CreateErrorResponse(400);

				response-&gt;Serialize(StunSerializeBuffer);
				this-&gt;listener-&gt;OnIceServerSendStunPacket(this, response, tuple);

				delete response;
			}
			else
			{
				MS_WARN_TAG(ice, "ignoring STUN Binding Response without FINGERPRINT");
			}

			return;
		}

		switch (packet-&gt;GetClass())
		{
			case RTC::StunPacket::Class::REQUEST:
			{
				// USERNAME, MESSAGE-INTEGRITY and PRIORITY are required.
				if (!packet-&gt;HasMessageIntegrity() || (packet-&gt;GetPriority() == 0u) || packet-&gt;GetUsername().empty())
				{
					MS_WARN_TAG(ice, "mising required attributes in STUN Binding Request =&gt; 400");

					// Reply 400.
					RTC::StunPacket* response = packet-&gt;CreateErrorResponse(400);

					response-&gt;Serialize(StunSerializeBuffer);
					this-&gt;listener-&gt;OnIceServerSendStunPacket(this, response, tuple);

					delete response;

					return;
				}

				// Check authentication.
				switch (packet-&gt;CheckAuthentication(this-&gt;usernameFragment, this-&gt;password))
				{
					case RTC::StunPacket::Authentication::OK:
					{
						if (!this-&gt;oldPassword.empty())
						{
							MS_DEBUG_TAG(ice, "new ICE credentials applied");

							this-&gt;oldUsernameFragment.clear();
							this-&gt;oldPassword.clear();
						}

						break;
					}

					case RTC::StunPacket::Authentication::UNAUTHORIZED:
					{
						// We may have changed our usernameFragment and password, so check
						// the old ones.
						// clang-format off
						if (
							!this-&gt;oldUsernameFragment.empty() &amp;&amp;
							!this-&gt;oldPassword.empty() &amp;&amp;
							packet-&gt;CheckAuthentication(this-&gt;oldUsernameFragment, this-&gt;oldPassword) == RTC::StunPacket::Authentication::OK
						)
						// clang-format on
						{
							MS_DEBUG_TAG(ice, "using old ICE credentials");

							break;
						}

						MS_WARN_TAG(ice, "wrong authentication in STUN Binding Request =&gt; 401");

						// Reply 401.
						RTC::StunPacket* response = packet-&gt;CreateErrorResponse(401);

						response-&gt;Serialize(StunSerializeBuffer);
						this-&gt;listener-&gt;OnIceServerSendStunPacket(this, response, tuple);

						delete response;

						return;
					}

					case RTC::StunPacket::Authentication::BAD_REQUEST:
					{
						MS_WARN_TAG(ice, "cannot check authentication in STUN Binding Request =&gt; 400");

						// Reply 400.
						RTC::StunPacket* response = packet-&gt;CreateErrorResponse(400);

						response-&gt;Serialize(StunSerializeBuffer);
						this-&gt;listener-&gt;OnIceServerSendStunPacket(this, response, tuple);

						delete response;

						return;
					}
				}

				// The remote peer must be ICE controlling.
				if (packet-&gt;GetIceControlled())
				{
					MS_WARN_TAG(ice, "peer indicates ICE-CONTROLLED in STUN Binding Request =&gt; 487");

					// Reply 487 (Role Conflict).
					RTC::StunPacket* response = packet-&gt;CreateErrorResponse(487);

					response-&gt;Serialize(StunSerializeBuffer);
					this-&gt;listener-&gt;OnIceServerSendStunPacket(this, response, tuple);

					delete response;

					return;
				}

				MS_DEBUG_DEV(
				  "processing STUN Binding Request [Priority:%" PRIu32 ", UseCandidate:%s]",
				  static_cast&lt;uint32_t&gt;(packet-&gt;GetPriority()),
				  packet-&gt;HasUseCandidate() ? "true" : "false");

				// Create a success response.
				RTC::StunPacket* response = packet-&gt;CreateSuccessResponse();

				// Add XOR-MAPPED-ADDRESS.
				response-&gt;SetXorMappedAddress(tuple-&gt;GetRemoteAddress());

				// Authenticate the response.
				if (this-&gt;oldPassword.empty())
					response-&gt;Authenticate(this-&gt;password);
				else
					response-&gt;Authenticate(this-&gt;oldPassword);

				// Send back.
				response-&gt;Serialize(StunSerializeBuffer);
				this-&gt;listener-&gt;OnIceServerSendStunPacket(this, response, tuple);

				delete response;

				uint32_t nomination{ 0u };

				if (packet-&gt;HasNomination())
					nomination = packet-&gt;GetNomination();

				// Handle the tuple.
				HandleTuple(tuple, packet-&gt;HasUseCandidate(), packet-&gt;HasNomination(), nomination);

				break;
			}

			case RTC::StunPacket::Class::INDICATION:
			{
				MS_DEBUG_TAG(ice, "STUN Binding Indication processed");

				break;
			}

			case RTC::StunPacket::Class::SUCCESS_RESPONSE:
			{
				MS_DEBUG_TAG(ice, "STUN Binding Success Response processed");

				break;
			}

			case RTC::StunPacket::Class::ERROR_RESPONSE:
			{
				MS_DEBUG_TAG(ice, "STUN Binding Error Response processed");

				break;
			}
		}
	}
</code></pre> 
<h4><a id="_1609"></a>参考文献</h4> 
<ol><li><a href="https://www.rfc-editor.org/retrieve/" rel="nofollow">rfc5389-2008-stun.pdf、rfc5766-2010-turn.pdf、rfc5245-2010-ice.pdf</a></li><li><a href="https://blog.csdn.net/s2603898260/article/details/118755474?spm=1001.2014.3001.5506">NAT的四种分类：全锥形NAT,地址受限锥形NAT,端口受限锥形NAT,对称NAT</a></li><li><a href="https://github.com/versatica/mediasoup">mediasoup webrtc 源码分析</a></li><li><a href="https://zhuanlan.zhihu.com/p/395368185" rel="nofollow">技术解码 | WebRTC ICE 模块剖析</a></li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0a55cc70df83357764f59acbe3539a62/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">窗口函数OVER(PARTITION BY)详细用法——语法&#43;函数&#43;开窗范围ROWS和RANGE</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4b3419c52655e2a589c1f7624ae49b8e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OSS文件上传</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>