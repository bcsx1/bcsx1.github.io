<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>verilog基本语法总结 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="verilog基本语法总结" />
<meta property="og:description" content="最近学习了verilog基本语法，总结如下
数值表示 Verilog HDL 有下列四种基本的值来表示硬件电路中的电平逻辑：
0：逻辑 0 或 “假”1：逻辑 1 或 “真”x 或 X：未知z 或 Z：高阻 整数数值表示方法
十进制(&#39;d 或 &#39;D)，十六进制(&#39;h 或 &#39;H)，二进制（&#39;b 或 &#39;B），八进制（&#39;o 或 &#39;O）
指明位宽
4&#39;b1011 // 4bit 数值 32&#39;h3022_c0de // 32bit 的数值 下划线 _ 是为了增强代码的可读性。
不指明位宽
counter = &#39;d100 ; //一般会根据编译器自动分频位宽，常见的为32bit counter = 100 ; counter = 32&#39;h64 ; 数据类型 wire 表示硬件单元间的物理连线
reg 存储单元，保持数据原有的值直到被改写（寄存器）
integer 整数
real 实数
time 时间
parameter 常量/参数
数组：在 Verilog 中允许声明 reg, wire, integer, time, real 及其向量类型的数组。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/fea745134f1b60d343799ac3aed52c06/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-10T22:14:09+08:00" />
<meta property="article:modified_time" content="2023-05-10T22:14:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">verilog基本语法总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>最近学习了verilog基本语法，总结如下</p> 
<h3><a id="_1"></a>数值表示</h3> 
<p>Verilog HDL 有下列四种基本的值来表示硬件电路中的电平逻辑：</p> 
<ul><li>0：逻辑 0 或 “假”</li><li>1：逻辑 1 或 “真”</li><li>x 或 X：未知</li><li>z 或 Z：高阻</li></ul> 
<p>整数数值表示方法<br> 十进制('d 或 'D)，十六进制('h 或 'H)，二进制（'b 或 'B），八进制（'o 或 'O）<br> 指明位宽</p> 
<pre><code class="prism language-verilog">4'b1011         // 4bit 数值  
32'h3022_c0de   // 32bit 的数值
</code></pre> 
<p>下划线<code> _</code> 是为了增强代码的可读性。<br> 不指明位宽</p> 
<pre><code class="prism language-verilog">counter = 'd100 ; //一般会根据编译器自动分频位宽，常见的为32bit  
counter = 100 ;  
counter = 32'h64 ;
</code></pre> 
<h3><a id="_24"></a>数据类型</h3> 
<p><code>wire</code> 表示硬件单元间的物理连线<br> <code>reg</code> 存储单元，保持数据原有的值直到被改写（寄存器）<br> <code>integer</code> 整数<br> <code>real</code> 实数<br> <code>time</code> 时间<br> <code>parameter</code> 常量/参数</p> 
<p>数组：在 Verilog 中允许声明 <code>reg</code>, <code>wire</code>, <code>integer</code>, <code>time</code>, <code>real</code> 及其向量类型的数组。</p> 
<pre><code class="prism language-verilog">integer          flag [7:0] ; //8个整数组成的数组  
reg  [3:0]       counter [3:0] ; //由4个4bit计数器组成的数组  
wire [7:0]       addr_bus [3:0] ; //由4个8bit wire型变量组成的数组  
wire             data_bit[7:0][5:0] ; //声明1bit wire型变量的二维数组  
reg [31:0]       data_4d[11:0][3:0][3:0][255:0] ; //声明4维的32bit数据变量数组
</code></pre> 
<p><code>reg</code> 数组构成存储器</p> 
<pre><code class="prism language-verilog">reg               membit[0:255] ;  //256bit的1bit存储器  
reg  [7:0]        mem[0:1023] ;    //1Kbyte存储器，位宽8bit  
mem[511] = 8'b0 ;                  //令第512个8bit的存储单元值为0
</code></pre> 
<h4><a id="_48"></a>字符串</h4> 
<p>字符串保存在 reg 类型的变量中，每个字符占用一个字节（8bit）。因此寄存器变量的宽度应该足够大，以保证不会溢出。</p> 
<pre><code class="prism language-verilog">reg [0: 14*8-1]       str ;  
initial begin  
    str = "run.runoob.com";  
end
</code></pre> 
<h3><a id="_59"></a>表达式</h3> 
<table class="reference"><thead><tr><th>操作符</th><th>操作符号</th><th>优先级</th></tr></thead><tbody><tr><td>单目运算</td><td>+ - ! ~</td><td>最高</td></tr><tr><td>乘、除、取模</td><td>* / %</td><td> </td></tr><tr><td>加减</td><td>+ -</td><td> </td></tr><tr><td>移位</td><td>&lt;&lt;  &gt;&gt;</td><td> </td></tr><tr><td>关系</td><td>&lt;  &lt;=  &gt;  &gt;=</td><td> </td></tr><tr><td>等价</td><td>==  !=  ===  !===</td><td> </td></tr><tr><td>归约</td><td>&amp; ~&amp;</td><td> </td></tr><tr><td> </td><td>^ ~^</td><td> </td></tr><tr><td> </td><td>| ~|</td><td> </td></tr><tr><td>逻辑</td><td>&amp;&amp;</td><td> </td></tr><tr><td> </td><td>||</td><td> </td></tr><tr><td>条件</td><td>?:</td><td>最低</td></tr></tbody></table> 
<h4><a id="_63"></a>算数操作符</h4> 
<ul><li>单目操作符</li><li>双目操作符</li></ul> 
<h4><a id="_67"></a>双目操作符</h4> 
<p>乘（*）、除（/）、加（+）、减（-）、求幂（**）、取模（%）。<br> <em>注意不要溢出</em></p> 
<h4><a id="_71"></a>关系操作符</h4> 
<p>大于（&gt;），小于（&lt;），大于等于（&gt;=），小于等于（&lt;=）<br> 如果操作数中有一位为 x 或 z，则关系表达式的结果为 x。</p> 
<pre><code class="prism language-verilog">A = 4 ;  
B = 3 ;  
X = 3'b1xx ;  
     
A &gt; B     //为真  
A &lt;= B    //为假  
A &gt;= Z    //为X，不确定
</code></pre> 
<h4><a id="_84"></a>等价操作符</h4> 
<p>逻辑相等（==），逻辑不等（!=），全等（===），非全等（!==）</p> 
<p>逻辑相等/不等操作符不能比较 x 或 z，当操作数包含一个 x 或 z，则结果为不确定值。</p> 
<p><mark>全等比较时，如果按位比较有相同的 x 或 z，返回结果也可以为 1，即全等比较可比较 x 或 z。所以，全等比较的结果一定不包含 x</mark></p> 
<pre><code class="prism language-verilog">A = 4 ;  
B = 8'h04 ;  
C = 4'bxxxx ;  
D = 4'hx ;  
A == B        //为真  
A == (B + 1)  //为假  
A == C        //为X，不确定  
A === C       //为假，返回值为0  
C === D       //为真，返回值为1
</code></pre> 
<h4><a id="_103"></a>逻辑操作符</h4> 
<p>&amp;&amp;（逻辑与）, ||（逻辑或），!（逻辑非）。</p> 
<p>逻辑操作符的<mark>计算结果是一个 1bit 的值</mark>，0 表示假，1 表示真，x 表示不确定。</p> 
<p>如果一个操作数不为 0，它等价于逻辑 1；如果一个操作数等于 0，它等价于逻辑 0。如果它任意一位为 x 或 z，它等价于 x。</p> 
<pre><code class="prism language-verilog">A = 3;  
B = 0;  
C = 2'b1x ;  
     
A &amp;&amp; B    //     为假  
A || B    //     为真  
! A       //     为假  
! B       //     为真  
A &amp;&amp; C    //     为X，不确定  
A || C    //     为真，因为A为真  
(A==2) &amp;&amp; (! B)  //为真，此时第一个操作数为表达式
</code></pre> 
<h4><a id="_124"></a>按位操作符</h4> 
<p>取反（<sub>），与（&amp;），或（|），异或（^），同或（</sub>^）<br> 按位操作符对 2 个操作数的每 1bit 数据进行按位操作。<br> 如果 2 个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。<br> 取反操作符只有一个操作数，它对操作数的每 1bit 数据进行取反操作。</p> 
<pre><code class="prism language-verilog">A = 4'b0101 ;  
B = 4'b1001 ;  
C = 4'bx010 ;  
     
~A        //4'b1010  
A &amp; B     //4'b0001  
A | B     //4'b1101  
A^B       //4'b1100  
A ~^ B    //4'b0011  
B | C     //4'b1011  
B&amp;C       //4'bx000
</code></pre> 
<h4><a id="_144"></a>归约操作符</h4> 
<p>归约与（&amp;），归约与非（<sub>&amp;），归约或（|），归约或非（</sub>|），归约异或（<sup>），归约同或（~</sup>）<br> 归约操作符只有一个操作数，它对这个向量操作数逐位进行操作，最终产生一个 1bit 结果。</p> 
<pre><code class="prism language-verilog">A = 4'b1010 ;
&amp;A ;      //结果为 1 &amp; 0 &amp; 1 &amp; 0 = 1'b0，可用来判断变量A是否全1
~|A ;     //结果为 ~(1 | 0 | 1 | 0) = 1'b0, 可用来判断变量A是否为全0
^A ;      //结果为 1 ^ 0 ^ 1 ^ 0 = 1'b0
</code></pre> 
<h4><a id="_156"></a>移位操作符</h4> 
<p>移位操作符包括左移（&lt;&lt;），右移（&gt;&gt;），算术左移（&lt;&lt;&lt;），算术右移（&gt;&gt;&gt;）。</p> 
<p>移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。</p> 
<p>算术左移和逻辑左移时，右边低位会补 0。</p> 
<p>逻辑右移时，左边高位会补 0；而算术右移时，左边高位会补充符号位(正/负)，以保证数据缩小后值的正确性。</p> 
<pre><code class="prism language-verilog">A = 4'b1100 ;  
B = 4'b0010 ;  
A = A &gt;&gt; 2 ;        //结果为 4'b0011  
A = A &lt;&lt; 1;         //结果为 4'b1000  
A = A &lt;&lt;&lt; 1 ;       //结果为 4'b1000  
C = B + (A&gt;&gt;&gt;2);    //结果为 2 + (-4/4) = 1, 4'b0001
</code></pre> 
<h4><a id="_175"></a>拼接操作符</h4> 
<p>用大括号 {，} 来表示，用于将多个操作数（向量）拼接成新的操作数（向量），信号间用逗号隔开。</p> 
<pre><code class="prism language-verilog">A = 4'b1010 ;  
B = 1'b1 ;  
Y1 = {B, A[3:2], A[0], 4'h3 };  //结果为Y1='b1100_0011  
Y2 = {4{B}, 3'd4};  //结果为 Y2=7'b111_1100  
Y3 = {32{1'b0}};  //结果为 Y3=32h0，常用作寄存器初始化时匹配位宽的赋初值
</code></pre> 
<h4><a id="_186"></a>条件操作符</h4> 
<p><code>condition_expression ? true_expression : false_expression</code></p> 
<h4><a id="_193"></a>编译指令</h4> 
<pre><code class="prism language-verilog">//define
`define
// ifdef ... 
// else
// endif
`ifndef     WINDOW  
    parameter DATA_DW = 32 ;    
 `else  
    parameter DATA_DW = 64 ;  
 `endif
 //include
`include         "../../param.v"
`include         "header.v"
</code></pre> 
<p><code>timescale</code><br> 在 Verilog 模型中，时延有具体的单位时间表述，并用 `timescale 编译指令将时间单位与实际时间相关联。</p> 
<p>该指令用于定义时延、仿真的单位和精度，格式为：</p> 
<pre><code class="prism language-verilog">`timescale      time_unit / time_precision
</code></pre> 
<p>time_unit 表示时间单位，time_precision 表示时间精度，它们均是由数字以及单位 s（秒），ms（毫秒），us（微妙），ns（纳秒），ps（皮秒）和 fs（飞秒）组成。时间精度可以和时间单位一样，但是时间精度大小不能超过时间单位大小</p> 
<pre><code class="prism language-verilog">`timescale 1ns/100ps    //时间单位为1ns，精度为100ps，合法  
//`timescale 100ps/1ns  //不合法  
module AndFunc(Z, A, B);  
    output Z;  
    input A, B ;  
    assign #5.207 Z = A &amp; B  
endmodule
</code></pre> 
<p><mark>ATTITION</mark></p> 
<p>在编译过程中，`timescale 指令会影响后面所有模块中的时延值，直至遇到另一个 `timescale 指令或 `resetall 指令。</p> 
<p>由于在 Verilog 中没有默认的 `timescale，如果没有指定 `timescale，Verilog 模块就有会继承前面编译模块的 `timescale 参数。有可能导致设计出错。</p> 
<h3><a id="_238"></a>过程结构</h3> 
<p>过程结构语句有 2 种，initial 与 always 语句。它们是行为级建模的 2 种基本语句。<br> 一个模块中可以包含多个 initial 和 always 语句，但 2 种语句不能嵌套使用。<br> 这些语句在模块间并行执行，与其在模块的前后顺序没有关系。<br> 但是 initial 语句或 always 语句内部可以理解为是顺序执行的（非阻塞赋值除外）。<br> 每个 initial 语句或 always 语句都会产生一个独立的控制流，执行时间都是从 0 时刻开始。</p> 
<h4><a id="initial_244"></a>initial</h4> 
<p>initial 语句从 0 时刻开始执行，只执行一次，多个 initial 块之间是相互独立的。<br> 如果 initial 块内包含多个语句，需要使用关键字 begin 和 end 组成一个块语句。<br> 如果 initial 块内只要一条语句，关键字 begin 和 end 可使用也可不使用。<br> initial 理论上来讲是不可综合的，多用于初始化、信号检测等。</p> 
<pre><code class="prism language-verilog">`timescale 1ns/1ns  
   
module test ;  
    reg  ai, bi ;  
   
    initial begin  
        ai         = 0 ;  
        #25 ;      ai        = 1 ;  
        #35 ;      ai        = 0 ;        //absolute 60ns  
        #40 ;      ai        = 1 ;        //absolute 100ns  
        #10 ;      ai        = 0 ;        //absolute 110ns  
    end  
   
    initial begin  
        bi         = 1 ;  
        #70 ;      bi        = 0 ;        //absolute 70ns  
        #20 ;      bi        = 1 ;        //absolute 90ns  
    end  
   
    //at proper time stop the simulation  
    initial begin  
        forever begin  
            #100;  
            //$display("---gyc---%d", $time);  
            if ($time &gt;= 1000) begin  
                $finish ;  
            end  
        end  
   end  
   
endmodule
</code></pre> 
<h4><a id="always_284"></a>always</h4> 
<p>always 语句是重复执行的。always 语句块从 0 时刻开始执行其中的行为语句；当执行完最后一条语句后，便再次执行语句块中的第一条语句，如此循环反复。<br> <mark>不同always块同步执行</mark><br> 由于循环执行的特点，always 语句多用于仿真时钟的产生，信号行为的检测等。<br> 下面用 always 产生一个 100MHz 时钟源，并在 1010ns 时停止仿真代码如下。</p> 
<pre><code class="prism language-verilog">`timescale 1ns/1ns  
   
module test ;  
   
    parameter CLK_FREQ   = 100 ; //100MHz  
    parameter CLK_CYCLE  = 1e9 / (CLK_FREQ * 1e6) ;   //switch to ns  
   
    reg  clk ;  
    initial      clk = 1'b0 ;      //clk is initialized to "0"  
    always     # (CLK_CYCLE/2) clk = ~clk ;       //generating a real clock by reversing  
   
    always begin  
        #10;  
        if ($time &gt;= 1000) begin  
            $finish ;  
        end  
    end  
   
endmodule
</code></pre> 
<h3><a id="_316"></a>连续赋值</h3> 
<h4><a id="assign_318"></a>assign</h4> 
<p>#组合逻辑 #阻塞赋值<br> 连续赋值语句是 Verilog 数据流建模的基本语句，用于对 <code>wire</code> 型变量进行赋值。：<br> <code>assign LHS_target = RHS_expression;</code><br> 特点</p> 
<ul><li>LHS_target 必须是一个标量或者线型向量，而不能是寄存器类型。</li><li>RHS_expression 的类型没有要求，可以是标量或线型或存器向量，也可以是函数调用。</li><li>只要 RHS_expression 表达式的操作数有事件发生（值的变化）时，RHS_expression 就会立刻重新计算，同时赋值给 LHS_target。</li></ul> 
<pre><code class="prism language-verilog">wire      Cout, A, B ;
assign    Cout  = A &amp; B ;     //实现计算A与B的功能
</code></pre> 
<p>设计全加器</p> 
<pre><code class="prism language-verilog">module full_adder1(  
    input    Ai, Bi, Ci  
    output   So, Co);  
   
    assign {Co, So} = Ai + Bi + Ci ;  
endmodule
</code></pre> 
<h4><a id="_342"></a>过程赋值</h4> 
<p>#并行 #非阻塞赋值</p> 
<p>非阻塞赋值属于<mark>并行</mark>执行语句，即下一条语句的执行和当前语句的执行是<mark>同时进行</mark>的，它不会阻塞位于同一个语句块中后面语句的执行。</p> 
<p>非阻塞赋值语句使用小于等于号 <code>&lt;=</code>作为赋值符。</p> 
<p>对比</p> 
<pre><code class="prism language-verilog">`timescale 1ns/1ns  
   
module test ;  
    reg [3:0]   ai, bi ;  
    reg [3:0]   ai2, bi2 ;  
    reg [3:0]   value_blk ;  
    reg [3:0]   value_non ;  
    reg [3:0]   value_non2 ;  
   
    initial begin  
        ai            = 4'd1 ;   //(1)  
        bi            = 4'd2 ;   //(2)  
        ai2           = 4'd7 ;   //(3)  
        bi2           = 4'd8 ;   //(4)  
        #20 ;                    //(5)  
   
        //non-block-assigment with block-assignment  
        ai            = 4'd3 ;     //(6)  
        bi            = 4'd4 ;     //(7)  
        value_blk     = ai + bi ;  //(8)  
        value_non     &lt;= ai + bi ; //(9)  
   
        //non-block-assigment itself  
        ai2           &lt;= 4'd5 ;           //(10)  
        bi2           &lt;= 4'd6 ;           //(11)  
        value_non2    &lt;= ai2 + bi2 ;      //(12)  
    end  
   
   //stop the simulation  
    always begin  
        #10 ;  
        if ($time &gt;= 1000) $finish ;  
    end  
   
endmodule
</code></pre> 
<p>对比</p> 
<pre><code class="prism language-verilog">always @(posedge clk) begin  
    a = b ;  
end  
   
always @(posedge clk) begin  
    b = a;  
end
</code></pre> 
<pre><code class="prism language-verilog">always @(posedge clk) begin  
    a &lt;= b ;  
end  
   
always @(posedge clk) begin  
    b &lt;= a;  
end
</code></pre> 
<h3><a id="_410"></a>时序控制</h3> 
<h4><a id="_412"></a>时延</h4> 
<p><strong>常规时延</strong><br> 语句需要等待一定时间，然后将计算结果赋值给目标信号。</p> 
<p>格式为：<code>#delay procedural_statement;</code></p> 
<pre><code class="prism language-verilog">reg  value_test ;
reg  value_general ;
#10  value_general    = value_test ;
</code></pre> 
<p><strong>内嵌时延</strong></p> 
<p>遇到内嵌延时时，该语句先将计算结果保存，然后等待一定的时间后赋值给目标信号。</p> 
<pre><code class="prism language-verilog">reg  value_test ;
reg  value_embed ;
value_embed        = #10 value_test ;
</code></pre> 
<h4><a id="_433"></a>边沿触发事件</h4> 
<p>在 Verilog 中，事件是指某一个 reg 或 wire 型变量发生了值的变化。</p> 
<p>基于事件触发的时序控制又主要分为以下几种。</p> 
<p><strong>一般事件控制</strong></p> 
<p>事件控制用符号 `@ 表示。</p> 
<p>语句执行的条件是信号的值发生特定的变化。</p> 
<p>关键字 <code>posedge</code> 指信号发生边沿正向跳变，<code>negedge</code> 指信号发生负向边沿跳变，未指明跳变方向时，则 2 种情况的边沿变化都会触发相关事件。</p> 
<pre><code class="prism language-verilog">//信号clk只要发生变化，就执行q&lt;=d，双边沿D触发器模型  
always @(clk) q &lt;= d ;                  
//在信号clk上升沿时刻，执行q&lt;=d，正边沿D触发器模型  
always @(posedge clk) q &lt;= d ;    
//在信号clk下降沿时刻，执行q&lt;=d，负边沿D触发器模型  
always @(negedge clk) q &lt;= d ;  
//立刻计算d的值，并在clk上升沿时刻赋值给q，不推荐这种写法  
q = @(posedge clk) d ;
</code></pre> 
<p><strong>命名事件控制</strong></p> 
<p>用户可以声明 event（事件）类型的变量，并触发该变量来识别该事件是否发生。命名事件用关键字 event 来声明，触发信号用 <code>-&gt;</code> 表示。</p> 
<pre><code class="prism language-verilog">event     start_receiving ;  
always @( posedge clk_samp) begin  
        -&gt; start_receiving ;       //采样时钟上升沿作为时间触发时刻  
end  
   
always @(start_receiving) begin  
    data_buf = {data_if[0], data_if[1]} ; //触发时刻，对多维数据整合  
end
</code></pre> 
<p><strong>敏感列表</strong></p> 
<p>当多个信号或事件中任意一个发生变化都能够触发语句的执行时，Verilog 中使用"或"表达式来描述这种情况，用关键字 <code>or</code> 连接多个事件或信号。这些事件或信号组成的列表称为"敏感列表"。当然，<code>or</code> 也可以用逗号<code>,</code> 来代替。例如：</p> 
<pre><code class="prism language-verilog">//带有低有效复位端的D触发器模型  
always @(posedge clk or negedge rstn)    begin        
//always @(posedge clk , negedge rstn)    begin        
//也可以使用逗号陈列多个事件触发  
    if（! rstn）begin  
        q &lt;= 1'b ;        
    end  
    else begin  
        q &lt;= d ;  
    end  
end
</code></pre> 
<h4><a id="_491"></a>电平敏感事件控制</h4> 
<p>电平作为敏感信号来控制时序，即后面语句的执行需要等待某个条件为真。Verilog 中使用关键字 <code>wait</code> 来表示这种电平敏感情况。例如：</p> 
<pre><code class="prism language-verilog">initial begin  
    wait (start_enable) ;      //等待 start 信号  
    forever begin  
        //start信号使能后，在clk_samp上升沿，对数据进行整合  
        @(posedge clk_samp)  ;  
        data_buf = {data_if[0], data_if[1]} ;        
    end  
end
</code></pre> 
<h3><a id="_506"></a>语句块</h3> 
<h4><a id="_508"></a>顺序块</h4> 
<p><code>begin end</code><br> 顺序块用关键字 <code>begin</code> 和 <code>end</code> 来表示。<br> 顺序块中的语句是一条条执行的。当然，非阻塞赋值除外。<br> 顺序块中每条语句的时延总是与其前面语句执行的时间相关。</p> 
<h4><a id="_514"></a>并行块</h4> 
<p><code>fork join</code><br> 并行块有关键字 <code>fork</code> 和 <code>join</code> 来表示<br> 并行块中的语句是<mark>并行执行</mark>的，即便是阻塞形式的赋值。<br> 并行块中每条语句的时延都是<mark>与块语句开始执行</mark>的时间相关。</p> 
<h4><a id="_520"></a>命名块</h4> 
<p>我们可以给块语句结构命名。<br> 命名的块中可以声明局部变量，<mark>通过层次名引用的方法对变量进行访问。</mark></p> 
<pre><code class="prism language-verilog">`timescale 1ns/1ns  
   
module test;  
   
    initial begin: runoob   //命名模块名字为runoob，分号不能少  
        integer    i ;       //此变量可以通过test.runoob.i 被其他模块使用  
        i = 0 ;  
        forever begin  
            #10 i = i + 10 ;        
        end  
    end  
   
    reg stop_flag ;  
    initial stop_flag = 1'b0 ;  
    always begin : detect_stop  
        if ( test.runoob.i == 100) begin //i累加10次，即100ns时停止仿真  
            $display("Now you can stop the simulation!!!");  
            stop_flag = 1'b1 ;  
        end  
        #10 ;  
    end  
   
endmodule
</code></pre> 
<p>命名的块也可以被禁用，用关键字 disable 来表示。</p> 
<p>disable 可以终止命名块的执行，可以用来从循环中退出、处理错误等。</p> 
<p>与 C 语言中 break 类似，但是 break 只能退出当前所在循环，而 disable 可以禁用设计中任何一个命名的块。</p> 
<pre><code class="prism language-verilog">`timescale 1ns/1ns  
   
module test;  
   
    initial begin: runoob_d //命名模块名字为runoob_d  
        integer    i_d ;  
        i_d = 0 ;  
        while(i_d&lt;=100) begin: runoob_d2  
            # 10 ;  
            if (i_d &gt;= 50) begin       //累加5次停止累加  
                disable runoob_d3.clk_gen ;//stop 外部block: clk_gen  
                disable runoob_d2 ;       //stop 当前block: runoob_d2  
            end  
            i_d = i_d + 10 ;  
        end  
    end  
   
    reg clk ;  
    initial begin: runoob_d3  
        while (1) begin: clk_gen  //时钟产生模块  
            clk=1 ;      #10 ;  
            clk=0 ;      #10 ;  
        end  
    end  
   
endmodule
</code></pre> 
<h3><a id="_585"></a>逻辑语句</h3> 
<h5><a id="_587"></a>条件语句</h5> 
<p><code>if...else</code> 结合 <code>begin...end</code></p> 
<pre><code class="prism language-verilog">if(en) begin  
    if(sel == 2'b1) begin  
        sout = p1s ;  
    end  
    else begin  
        sout = p0 ;  
    end  
end
</code></pre> 
<p><code>case</code></p> 
<pre><code class="prism language-verilog">case(case_expr)
    condition1     :             true_statement1 ;
    condition2     :             true_statement2 ;
    ……
    default        :             default_statement ;
endcase
</code></pre> 
<p>四路选择器</p> 
<pre><code class="prism language-verilog">module mux4to1(  
    input [1:0]     sel ,  
    input [1:0]     p0 ,  
    input [1:0]     p1 ,  
    input [1:0]     p2 ,  
    input [1:0]     p3 ,  
    output [1:0]    sout);  
   
    reg [1:0]     sout_t ;  
    always @(*)  
        case(sel)  
            2'b00:   begin        
                    sout_t = p0 ;  
                end  
            2'b01:       sout_t = p1 ;  
            2'b10:       sout_t = p2 ;  
            default:     sout_t = p3 ;  
        endcase  
    assign sout = sout_t ;  
   
endmodule
</code></pre> 
<h5><a id="_638"></a>循环语句</h5> 
<p>包含 while，for，repeat，和 forever 循环。循环语句只能在 always 或 initial 块中使用，但可以包含延迟表达式。</p> 
<pre><code class="prism language-verilog">//while 循环中止条件为 condition 为假。
//如果开始执行到 while 循环时 condition 已经为假，那么循环语句一次也不会执行。
while (condition) begin
    …
end

//initial_assignment 为初始条件。
//condition 为终止条件，condition 为假时，立即跳出循环。
//step_assignment 为改变控制变量的过程赋值语句，通常为增加或减少循环变量计数。
for(initial_assignment; condition ; step_assignment)  begin
    …
end

//repeat 的功能是执行固定次数的循环，它不能像 while 循环那样用一个逻辑表达式来确定循环是否继续执行。repeat 循环的次数必须是一个常量、变量或信号。如果循环次数是变量信号，则循环次数是开始执行 repeat 循环时变量信号的值。即便执行期间，循环次数代表的变量信号值发生了变化，repeat 执行次数也不会改变。
repeat (loop_times) begin
    …
end

//forever 语句表示永久循环，不包含任何条件表达式，一旦执行便无限的执行下去，系统函数 $finish 可退出 forever。
//forever 相当于 while(1) 。
forever begin
    …
end
</code></pre> 
<h3><a id="_668"></a>模块与端口</h3> 
<h4><a id="_670"></a>模块</h4> 
<pre><code class="prism language-verilog">module module_name 
#(parameter_list)
(port_list) ;
              Declarations_and_Statements ;
endmodule
</code></pre> 
<p>![[Pasted image 20230510212756.png]]</p> 
<h4><a id="_681"></a>端口</h4> 
<p>端口是模块与外界交互的接口。对于外部环境来说，模块内部是不可见的，对模块的调用只能通过端口连接进行。</p> 
<p><strong>端口列表</strong><br> 模块的定义中包含一个可选的端口列表，一般将不带类型、不带位宽的信号变量罗列在模块声明里。</p> 
<pre><code class="prism language-verilog">module pad(
    DIN, OEN, PULL,
    DOUT, PAD);
</code></pre> 
<p><strong>端口声明</strong></p> 
<p>端口信号在端口列表中罗列出来以后，就可以在模块实体中进行声明了。<br> 端口类型有 3 种： 输入（input），输出（output）和双向端口（inout）。<br> input、inout 类型不能声明为 reg 数据类型，因为 reg 类型是用于保存数值的，而输入端口只能反映与其相连的外部信号的变化，不能保存这些信号的值。<br> output 可以声明为 wire 或 reg 数据类型。<br> eg:</p> 
<pre><code class="prism language-verilog">module pad(  
    input        DIN, OEN ,  
    input [1:0]  PULL ,  
    inout        PAD ,  
    output reg   DOUT  
    );  
   
module pad(  
    input        DIN, OEN ,  
    input [1:0]  PULL ,  
    inout        PAD ,  
    output       DOUT  
    );  
   
    reg        DOUT ;
</code></pre> 
<h4><a id="_719"></a>模块例化</h4> 
<p>eg</p> 
<pre><code class="prism language-verilog">module full_adder1(  
    input    Ai, Bi, Ci  
    output   So, Co);  
   
    assign {Co, So} = Ai + Bi + Ci ;  
endmodule

//例化
full_adder1  u_adder0(  
    .Ai     (a[0]),  
    .Bi     (b[0]),  
    .Ci     (c==1'b1 ? 1'b0 : 1'b1),  
    .So     (so_bit0),  
    .Co     (co_temp[0]));

//输出端口可悬空或删除
//output 端口 Co 悬空  
full_adder1  u_adder0(  
    .Ai     (a[0]),  
    .Bi     (b[0]),  
    .Ci     (c==1'b1 ? 1'b0 : 1'b1),  
    .So     (so_bit0),  
    .Co     ());  
   
//output 端口 Co 删除  
full_adder1  u_adder0(  
    .Ai     (a[0]),  
    .Bi     (b[0]),  
    .Ci     (c==1'b1 ? 1'b0 : 1'b1),  
    .So     (so_bit0));
//顺序实例化，需一一对应
full_adder1  u_adder1(
    a[1], b[1], co_temp[0], so_bit1, co_temp[1]);

</code></pre> 
<h4><a id="_759"></a>带参实例化</h4> 
<p>例化模块时，将新的参数值写入模块例化语句，以此来改写原有 module 的（<code>parameter</code>）参数值。<br> eg:</p> 
<pre><code class="prism language-verilog">module  ram  
    #(  parameter       AW = 2 ,  
        parameter       DW = 3 )  
    (  
        input                   CLK ,  
        input [AW-1:0]          A ,  
        input [DW-1:0]          D ,  
        input                   EN ,  
        input                   WR ,    //1 for write and 0 for read  
        output reg [DW-1:0]     Q  
     );  
   
    reg [DW-1:0]         mem [0:(1&lt;&lt;AW)-1] ;  
    always @(posedge CLK) begin  
        if (EN &amp;&amp; WR) begin  
            mem[A]  &lt;= D ;  
        end  
        else if (EN &amp;&amp; !WR) begin  
            Q       &lt;= mem[A] ;  
        end  
    end  
   
endmodule

//带参数例化，改变parameter从而改变位宽和字节

ram #(.AW(4), .DW(4))  
    u_ram  
    (  
        .CLK    (clk),  
        .A      (a[AW-1:0]),  
        .D      (d),  
        .EN     (en),  
        .WR     (wr),    //1 for write and 0 for read  
        .Q      (q)  
     );
</code></pre> 
<h3><a id="_802"></a>函数</h3> 
<p>函数只能在模块中定义，位置任意，并在模块的任何地方引用，作用范围也局限于此模块。函数主要有以下几个特点：</p> 
<ul><li>1）不含有任何延迟、时序或时序控制逻辑</li><li>2）至少有一个输入变量</li><li>3）只有一个返回值，且没有输出</li><li>4）不含有非阻塞赋值语句</li><li>5）函数可以调用其他函数，但是不能调用任务</li></ul> 
<pre><code class="prism language-verilog">function [range-1:0]     function_id ;
input_declaration ;
 other_declaration ;
procedural_statement ;
endfunction
</code></pre> 
<p>函数的返回值通过这个<code>function_id</code>变量进行传递。(有点像matlab的函数)</p> 
<p>eg：数据大小端转换</p> 
<pre><code class="prism language-verilog">module endian_rvs  
    #(parameter N = 4)  
        (  
            input             en,     //enable control  
            input [N-1:0]     a ,  
            output [N-1:0]    b  
    );  
           
        reg [N-1:0]          b_temp ;  
        always @(*) begin  
        if (en) begin  
                b_temp =  data_rvs(a);  
            end  
            else begin  
                b_temp = 0 ;  
            end  
    end  
        assign b = b_temp ;  
           
    //function entity  
        function [N-1:0]     data_rvs ;  
            input     [N-1:0] data_in ;  
            parameter         MASK = 32'h3 ;  
            integer           k ;  
            begin  
                for(k=0; k&lt;N; k=k+1) begin  
                    data_rvs[N-k-1]  = data_in[k] ;    
                end  
            end  
    endfunction  
           
endmodule
</code></pre> 
<h3><a id="_856"></a>任务</h3> 
<p><code>module</code> 里的<code>module</code>？</p> 
<h3><a id="_859"></a>状态机</h3> 
<p>有限状态机（Finite-State Machine，FSM），简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。状态机不仅是一种电路的描述工具，而且也是一种思想方法，在电路设计的系统级和 RTL 级有着广泛的应用。</p> 
<h4><a id="_861"></a>状态机类型</h4> 
<p>Verilog 中状态机主要用于同步时序逻辑的设计，能够在有限个状态之间按一定要求和规律切换时序电路的状态。状态的切换方向不但取决于各个输入值，还取决于当前所在状态。 状态机可分为 2 类：Moore 状态机和 Mealy 状态机。<br> <strong>Moore 型状态机</strong></p> 
<p>Moore 型状态机的输出只与当前状态有关，与当前输入无关。</p> 
<p>输出会在一个完整的时钟周期内保持稳定，即使此时输入信号有变化，输出也不会变化。输入对输出的影响要到下一个时钟周期才能反映出来。这也是 Moore 型状态机的一个重要特点：输入与输出是隔离开来的。</p> 
<p><strong>Mealy 型状态机</strong></p> 
<p>Mealy 型状态机的输出，不仅与当前状态有关，还取决于当前的输入信号。</p> 
<p>Mealy 型状态机的输出是在输入信号变化以后立刻发生变化，且输入变化可能出现在任何状态的时钟周期内。因此，同种逻辑下，Mealy 型状态机输出对输入的响应会比 Moore 型状态机早一个时钟周期。</p> 
<h4><a id="3__876"></a>状态机设计：3 段式（推荐）</h4> 
<p><strong>状态机设计如下：</strong></p> 
<ul><li>(0) 首先，根据状态机的个数确定状态机编码。利用编码给状态寄存器赋值，代码可读性更好。</li><li>(1) 状态机第一段，时序逻辑，非阻塞赋值，传递寄存器的状态。</li><li>(2) 状态机第二段，组合逻辑，阻塞赋值，根据当前状态和当前输入，确定下一个状态机的状态。</li><li>(3) 状态机第三段，时序逻辑，非阻塞赋值，因为是 Mealy 型状态机，根据当前状态和当前输入，确定输出信号。</li></ul> 
<p>eg：<br> 自动售卖机<br> <strong>自动售卖机的功能描述如下：</strong></p> 
<p>饮料单价 2 元，该售卖机只能接受 0.5 元、1 元的硬币。考虑找零和出货。投币和出货过程都是一次一次的进行，不会出现一次性投入多币或一次性出货多瓶饮料的现象。每一轮售卖机接受投币、出货、找零完成后，才能进入到新的自动售卖状态。</p> 
<pre><code class="prism language-verilog">// vending-machine  
// 2 yuan for a bottle of drink  
// only 2 coins supported: 5 jiao and 1 yuan  
// finish the function of selling and changing  
  
module  vending_machine_p3  (  
    input           clk ,  
    input           rstn ,  
    input [1:0]     coin ,     //01 for 0.5 jiao, 10 for 1 yuan  
  
    output [1:0]    change ,  
    output          sell    //output the drink  
    );  
  
    //machine state decode  
    parameter            IDLE   = 3'd0 ;  
    parameter            GET05  = 3'd1 ;  
    parameter            GET10  = 3'd2 ;  
    parameter            GET15  = 3'd3 ;  
  
    //machine variable  
    reg [2:0]            st_next ;  
    reg [2:0]            st_cur ;  
  
    //(1) state transfer  
    always @(posedge clk or negedge rstn) begin  
        if (!rstn) begin  
            st_cur      &lt;= 'b0 ;  
        end  
        else begin  
            st_cur      &lt;= st_next ;  
        end  
    end  
  
    //(2) state switch, using block assignment for combination-logic  
    //all case items need to be displayed completely      
    always @(*) begin  
        //st_next = st_cur ;//如果条件选项考虑不全，可以赋初值消除latch  
        case(st_cur)  
            IDLE:  
                case (coin)  
                    2'b01:     st_next = GET05 ;  
                    2'b10:     st_next = GET10 ;  
                    default:   st_next = IDLE ;  
                endcase  
            GET05:  
                case (coin)  
                    2'b01:     st_next = GET10 ;  
                    2'b10:     st_next = GET15 ;  
                    default:   st_next = GET05 ;  
                endcase  
  
            GET10:  
                case (coin)  
                    2'b01:     st_next = GET15 ;  
                    2'b10:     st_next = IDLE ;  
                    default:   st_next = GET10 ;  
                endcase  
            GET15:  
                case (coin)  
                    2'b01,2'b10:  
                               st_next = IDLE ;  
                    default:   st_next = GET15 ;  
                endcase  
            default:    st_next = IDLE ;  
        endcase  
    end  
  
    //(3) output logic, using non-block assignment  
    reg  [1:0]   change_r ;  
    reg          sell_r ;  
    always @(posedge clk or negedge rstn) begin  
        if (!rstn) begin  
            change_r       &lt;= 2'b0 ;  
            sell_r         &lt;= 1'b0 ;  
        end  
        else if ((st_cur == GET15 &amp;&amp; coin ==2'h1)  
               || (st_cur == GET10 &amp;&amp; coin ==2'd2)) begin  
            change_r       &lt;= 2'b0 ;  
            sell_r         &lt;= 1'b1 ;  
        end  
        else if (st_cur == GET15 &amp;&amp; coin == 2'h2) begin  
            change_r       &lt;= 2'b1 ;  
            sell_r         &lt;= 1'b1 ;  
        end  
        else begin  
            change_r       &lt;= 2'b0 ;  
            sell_r         &lt;= 1'b0 ;  
        end  
    end  
    assign       sell    = sell_r ;  
    assign       change  = change_r ;  
  
endmodule
</code></pre> 
<p>参考文献<br> https://www.runoob.com/w3cnote_genre/verilog</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8f97fa4bae8c9808610cfd2d645e8159/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue中跳转界面</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/60943325588456ecc469a9b6270e877b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【python】pandas追加写入excel</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>