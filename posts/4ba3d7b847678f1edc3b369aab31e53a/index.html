<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>应用层HTTP数据包的截获与还原技术的实现 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="应用层HTTP数据包的截获与还原技术的实现" />
<meta property="og:description" content="摘要：在因特网日益发展壮大的今天，万维网在其上的通信量已经超过90%，万维网信息的安全问题已经越来越被人们所重视，而作为万维网应用层核心协议的http协议是基础。当网络发生异常时，对网络上传输的数据进行监视和分析，是网管人员解决网络故障的一种常用方法。
本文介绍应用层HTTP数据包的截获与还原技术的实现,并简要介绍其中所涉及的数据包截获、数据包分析、应用数据重组以及数据包解码等关键技术。该系统可以监听网管人员感兴趣的数据包，通过对其进行分析和研究，分析出其遵守的协议以及其应用层数据，恢复到被监视用户所看到数据的格式。该系统的实现，为网管人员有效地管理网络提供了一种直观的工具。
关键词：http数据包； 截获； 还原
Abstract: With the increasing development and expansion of Internet, the traffic of World-Wide-Web has occupied more than 90 percent on Internet at present. Therefore, people have attached more and more importance to the security of the WWW information. While HTTP (Hypertext Transfer Protocol) as the central protocol of WWW’s application layer forms the foundation of it. Monitoring and analysing the data transferred on network is the daily works for network manager" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/4ba3d7b847678f1edc3b369aab31e53a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-11-26T14:41:21+08:00" />
<meta property="article:modified_time" content="2012-11-26T14:41:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">应用层HTTP数据包的截获与还原技术的实现</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="color:rgb(51,51,51)">摘要：在因特网日益发展壮大的今天，万维网在其上的通信量已经超过90%，万维网信息的安全问题已经越来越被人们所重视，而作为万维网应用层核心协议的http协议是基础。当网络发生异常时，对网络上传输的数据进行监视和分析，是网管人员解决网络故障的一种常用方法。<br> 本文介绍应用层HTTP数据包的截获与还原技术的实现,并简要介绍其中所涉及的数据包截获、数据包分析、应用数据重组以及数据包解码等关键技术。该系统可以监听网管人员感兴趣的数据包，通过对其进行分析和研究，分析出其遵守的协议以及其应用层数据，恢复到被监视用户所看到数据的格式。该系统的实现，为网管人员有效地管理网络提供了一种直观的工具。<br> <br> 关键词：http数据包； 截获； 还原</p> 
<p style="color:rgb(51,51,51)">Abstract: With the increasing development and expansion of Internet, the traffic of World-Wide-Web has occupied more than 90 percent on Internet at present. Therefore, people have attached more and more importance to the security of the WWW information. While HTTP (Hypertext Transfer Protocol) as the central protocol of WWW’s application layer forms the foundation of it. Monitoring and analysing the data transferred on network is the daily works for network manager<br> The writer of this paper introduced the design and implementation for capturing a part of http data packets, recovering the captured http data packets，and analyzed some key technologies about capturing data packet brief，packet analyzing, reconstructing application data and packet decoding and so on．This system can monitor the packages which network manager is interested in，analyze the protocols which the packet uses，recover the format which the end user see．The implementation of the system provides a visual tool for network managers. <br> <br> Key Words: http packets；capture；recover<br> 目 录<br> 前言 1<br> 第一章 HTTP网络数据包截获与还原的理论基础 2<br> 1.1 网络体系结构 2<br> 1.1.1 网络参考模型概述 2<br> 1.1.2 TCP/IP协议族 3<br> 1.2 HTTP协议概述 4<br> 1.2.1 http协议的几个重要概念 5<br> 1.2.2 http协议结构 6<br> 1.2.3 http协议的运作方式 12<br> 1.3 基于HTTP协议的网络行为监视 16<br> 1.3.1 http协议的安全因素 16<br> 1.3.2 基于http协议监视的实现 17<br> 第二章 开发工具与环境配置 19<br> 2.1 JAVA语言介绍 19<br> 2.1.1 平台无关性 19<br> 2.1.2 面向对象 20<br> 2.1.3 安全稳定 21<br> 2.1.4 支持多线程 22<br> 2.2 JDK概述 22<br> 2.2.1 Java开发工具JDK 介绍 22<br> 2.2.2 开发环境配置 23<br> 第三章 HTTP数据包截获 24<br> 3.1 HTTP数据包截获模块设计 24<br> 3.1.1 体系结构设计 24<br> 3.1.2 WinPcap工具 25<br> 3.1.3 Packet.dll 26<br> 3.1.4 Jpcap类库 28<br> 3.2 数据包的存储 29<br> 3.3 数据包捕获和存储流程图 32<br> 3.4 数据包捕获和存储程序片断 32<br> 第四章 HTTP数据包信息的分析与还原 35<br> 4.1 字符编码的信息概述 35<br> 4.1.1 ASCALL字符编码 35<br> 4.1.2 GB2312字符编码 36<br> 4.1.3 BIG5字符编码 36<br> 4.1.4 UNICODE(UTF-8)字符编码 36<br> 4.2 捕获数据包信息的分析 38<br> 4.2.1 捕获数据数据包的重组分析 38<br> 4.2.2 捕获数据包编码格式的分析 40<br> 4.2.3 捕获数据的分析的程序片段 40<br> 4.3 对捕获数据包信息的部分还原 41<br> 4.3.1 捕获数据包信息还原的流程图 41<br> 4.3.2 捕获数据包的信息还原算法 42<br> 第五章 总结 52<br> 参 考 文 献 54<br> 谢 辞 55<br> <br> 前言<br> 在短短的二十几年时间里,万维网(Word Wide Web)从一种发布高能物理数据的方式演变为如今人们头脑中的因特网,它之所以如此流行是由于它有一个丰富多彩的界面,初学者很容易使用,并且提供了大量的信息资源,几乎涉及人们所能想象的所有主题。<br> HTTP是一个属于应用层的面向对象的协议，而http协议作为www的主要协议,由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(NextGenerationofHTTP)的建议已经提出。<br> 但HTTP协议存在许多安全漏洞，比如说允许远程用户向远程服务器请求连接,并且执行远程命令.这个安全漏洞可以以许多方式损坏Web服务器和客户机，这些危害信息还包括对远程请求的武断认证；破坏请求和应答的保密性；滥用服务器功能和资源等。而在网络上传送的不良信息，也影响人们的身心健康，包括色情、迷信和暴力等信息。对危害信息和不良信息在应用层的还原可以很明确的知道该信息传送的具体信息，具有很直观的效果，可以帮助网络管理人员较好的监视网络。对于网络数据包的截获和还原是网络行为监视的一部分，本文主要介绍HTTP数据包的截获与还原技术，该技术涉及到数据包截获、数据包分析、应用数据重组和字符编码解码等关键技术。该技术的实现可以帮助网管人员监听感兴趣的HTTP数据包，分析出其遵守的协议以及其应用层数据，同时将应用层数据进行重组，恢复到原始的数据格式，达到与被监视用户相同的显示效果。该系统的实现，为网管人员有效地管理网络提供了一种直观的工具。<br> 本文所介绍的基于HTTP协议的截获和还原信息主要是万维网信息，而这些信息包括文本、图象和声音等，本文主要是针对文本信息的还原，而大多数的嗅探器并不支持的数据在应用层的还原。本文所提出的应用层数据的还原技术是针对大多数嗅探器的局限性提出来的。<br> 第一章 http网络数据包截获与还原的理论基础<br> 1.1 网络体系结构<br> 1.1.1 网络参考模型概述<br> OSI的七层协议体系结构既复杂又不实用，但其概念清楚，体系结构理论较完整。TCP/IP的协议现在得到了广泛的应用，但它原先并没有一个明确的体系结构。TCP/IP是一个四层的体系结构，它包含应用层、运输层、网际层和网络结构层。不过从实质上讲，TCP/IP只有三层，即应用层、运输层和网际层，因为最下面的网络接口层并没有什么具体内容。<br> 下面的图片反应了两台计算机进行通信时的各层数据流结构。<br> <br> 图1.1<br> 应用层 应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为相互作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。在因特网中的应用层协议很多，如支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传输的FTP协议等等。<br> 运输层 运输层的任务就是负责主机中两个进程之间的通信。<br> 因特网的运输层可使用两种不同协议。即面向连接的传输控制协议TCP，和无连接的用户数据报协议UDP。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，各有其优缺点。<br> 在分组交换网内的各个交换接点机都没有运输层。运输层只能存在于分组交换网外面的主机之中。运输层以上的各层就不再关心信息传输的问题了。正因为如此，运输层就成为计算机网络体系结构中非常重要的一层。<br> 网络层 网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，分组也叫作IP数据报，或简称为数据报。<br> 因特网是一个很大的互联网，它由大量的异构网络通过路由器相互连接起来。因特网主要的网络协议是无连接的网际协议IP和许多路由选择协议，因此因特网的网络层也叫网际层或IP层。<br> 数据链路层 在发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻接点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息。控制信息使接受端能够知道一个帧从哪个比特开始和到哪个比特结束。控制信息还使接受端能够检测到所收到的帧中有无差错。如发现有差错，数据链路层就丢弃这个出了差错的帧。<br> 物理层 物理层的任务是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆，并不在物理层之内而是在物理层的下面。<br> 1.1.2 TCP/IP协议族<br> TCP/IP协议族（如下图所示），它的特点是上下两头大而中间小：应用层和网络接口层都有多种协议，而中间的IP层很小，上层的各种协议都向下汇聚到一个IP协议中。这种很象沙漏计时器形状的TCP/IP协议族表明：TCP/IP可以为各式各样的应用提供服务，同时也可以连接到各式各样的网络上。正因为如此，因特网才会发展到今天的这种全球规模。<br> <br> <br> 图1.2<br> 整个通信网络的任务，可以划分成不同的功能块，即抽象成所谓的 ” 层” 。用于互联网的协议可以比照TCP/IP参考模型进行分类。TCP/IP协议栈起始于第三层协议IP(互联网协议) 。所有这些协议都在相应的RFC文档中讨论及标准化。重要的协议在相应的RFC文档中均标记了状态: “必须“ (required) ，“推荐“ (recommended) ，“可选“ (elective) 。其它的协议还可能有“ 试验“(experimental) 或“ 历史“(historic) 的状态。<br> <br> <br> 1.2 http协议概述<br> 我们在浏览器的地址栏里输入的网站地址叫做URL(UniformResourceLocator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。<br> Internet的基本协议是TCP/IP协议，然而在TCP/IP模型最上层的是应用层(Applicationlayer)，它包含所有高层的协议。高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等。<br> 　　HTTP协议(Hypertext　Transfer　Protocol，超文本传输协议)是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。这就是你为什么在浏览器中看到的网页地址都是以“http://”开头的原因。<br> 　　自WWW诞生以来，一个多姿多彩的资讯和虚拟的世界便出现在我们眼前，可是我们怎么能够更加容易地找到我们需要的资讯呢？当决定使用超文本作为WWW文档的标准格式后，于是在1990年，科学家们立即制定了能够快速查找这些超文本文档的协议，即HTTP协议。经过几年的使用与发展，得到不断的完善和扩展，目前在WWW中使用的是HTTP/1.0的第六版。<br> <br> 1.2.1 http协议的几个重要概念<br> 1.连接(Connection)：一个传输层的实际环流，它是建立在两个相互通讯的应用程序之间。<br> 　　2.消息(Message)：HTTP通讯的基本单位，包括一个结构化的八元组序列并通过连接传输。<br> 　　3.请求(Request)：一个从客户端到服务器的请求信息包括应用于资源的方法、资源的标识符和协议的版本号<br> 　　4.响应(Response)：一个从服务器返回的信息包括HTTP协议的版本号、请求的状态(例如“成功”或“没找到”)和文档的MIME类型。<br> 　　5.资源(Resource)：由URI标识的网络数据对象或服务。<br> 　　6.实体(Entity)：数据资源或来自服务资源的回映的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容。<br> 　　7.客户机(Client)：一个为发送请求目的而建立连接的应用程序。<br> 　　8.用户代理(Useragent)：初始化一个请求的客户机。它们是浏览器、编辑器或其它用户工具。<br> 　　9.服务器(Server)：一个接受连接并对请求返回信息的应用程序。<br> 　　10.源服务器(Originserver)：是一个给定资源可以在其上驻留或被创建的服务器。<br> 　　11.代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。<br> 　　代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。<br> 　　12.网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。<br> 　　网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。<br> 　　13.通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。<br> 　　14.缓存(Cache)：反应信息的局域存储。<br> <br> 1.2.2 http协议结构<br> HTTP报文由从客户机到服务器的请求和从服务器到客户机的响应构成。 <br> 请求报文格式如下：<br> 请求行 通用信息头 请求头 实体头 报文主体<br> 表3.1<br> 请求行以方法字段开始，后面分别是 URL 字段和 HTTP 协议版本字段，并以 CRLF 结尾。SP 是分隔符。除了在最后的 CRLF序列中 CF 和 LF 是必需的之外，其他都可以不要。有关通用信息头，请求头和实体头方面的具体内容可以参照相关文件。<br> 响应报文格式如下：<br> 状态行 通用信息头 请求头 实体头 报文主体<br> 表3.2<br> 状态码元由3位数字组成，表示请求是否被理解或被满足。原因分析是对原文的状态码作简短的描述，状态码用来支持自动操作，而原因分析用来供用户使用。客户机无需用来检查或显示语法。有关通用信息头，响应头和实体头方面的具体内容可以参照相关文件。<br> HTTP（HyperTextTransferProtocol）<br> HTTP（HyperTextTransferProtocol）是超文本传输协议的缩写，它用于传送WWW方式的数据，关于HTTP协议的详细内容请参考RFC2616。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求，请求头包含请求的方法、URI、协议版本、以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，相应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。<br> 通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。这两种类型的消息由一个起始行，一个或者多个头域，一个只是头域结束的空行和可选的消息体组成。HTTP的头域包括通用头，请求头，响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。<br> 通用头域<br> 通用头域包含请求和响应消息都支持的头域，通用头域包含Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via。对通用头域的扩展要求通讯双方都支持此扩展，如果存在不支持的通用头域，一般将会作为实体头域处理。下面简单介绍几个在UPnP消息中使用的通用头域。<br> Cache-Control头域<br> Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下：<br> Public指示响应可被任何缓存区缓存。<br> Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。<br> no-cache指示请求或响应消息不能缓存<br> no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。<br> max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。<br> min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。<br> max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale<br> 息的值，那么客户机可以接收超出超时期指定值之内的响应消息。<br> Date头域<br> Date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。<br> Pragma头域<br> Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache-Control:no-cache相同。<br> 请求消息<br> 请求消息的第一行为下面的格式：<br> MethodSPRequest-URISPHTTP-VersionCRLFMethod表示对于Request-URI完成的方法，这个字段是大小写敏感的，包括OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE。方法GET和HEAD应该被所有的通用WEB服务器支持，其他所有方法的实现是可选的。GET方法取回由Request-URI标识的信息。HEAD方法也是取回由Request-URI标识的信息，只是可以在响应时，不返回消息体。POST方法可以请求服务器接收包含在请求中的实体信息，可以用于提交表单，向新闻组、BBS、邮件群组和数据库发送消息。<br> SP表示空格。Request-URI遵循URI格式，在此字段为星号（*）时，说明请求并不用于某个特定的资源地址，而是用于服务器本身。HTTP-Version表示支持的HTTP版本，例如为HTTP/1.1。CRLF表示换行回车符。请求头域允许客户端向服务器传递关于请求或者关于客户机的附加信息。<br> 请求头域可能包含下列字段Accept、Accept-Charset、Accept-Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If-Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、Proxy-Authorization、Range、Referer、User-Agent。对请求头域的扩展要求通讯双方都支持，如果存在不支持的请求头域，一般将会作为实体头域处理。<br> 典型的请求消息：<br> GEThttp://class/download.microtool.de:80/somedata.exe<br> Host:download.microtool.de<br> Accept:*/*<br> Pragma:no-cache<br> Cache-Control:no-cache<br> Referer:http://class/download.microtool.de/<br> User-Agent:Mozilla/4.04[en](Win95;I;Nav)<br> Range:bytes=554554-<br> Host头域<br> Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。<br> Referer头域<br> Referer头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个相对地址。<br> Range头域<br> Range头域可以请求实体的一个或者多个子范围。例如，<br> 表示头500个字节：bytes=0-499<br> 表示第二个500字节：bytes=500-999<br> 表示最后500个字节：bytes=-500<br> 表示500字节以后的范围：bytes=500-<br> 第一个和最后一个字节：bytes=0-0,-1<br> 同时指定几个范围：bytes=500-600,601-999<br> 但是服务器可以忽略此请求头，如果无条件GET包含Range请求头，响应会以状态码206（PartialContent）返回而不是以200（OK）。<br> User-Agent头域<br> User-Agent头域的内容包含发出请求的用户信息。<br> 响应消息<br> 响应消息的第一行为下面的格式：<br> HTTP-VersionSPStatus-CodeSPReason-PhraseCRLF<br> HTTP-Version表示支持的HTTP版本，例如为HTTP/1.1。Status-Code是一个三个数字的结果代码。Reason-Phrase给Status-Code提供一个简单的文本描述。Status-Code主要用于机器自动识别，Reason-Phrase主要用于帮助用户理解。Status-Code的第一个数字定义响应的类别，后两个数字没有分类的作用。第一个数字可能取5个不同的值：<br> 1xx:信息响应类，表示接收到请求并且继续处理<br> 2xx:处理成功响应类，表示动作被成功接收、理解和接受<br> 3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理<br> 4xx:客户端错误，客户请求包含语法错误或者是不能正确执行<br> 5xx:服务端错误，服务器不能正确执行一个正确的请求<br> 响应头域允许服务器传递不能放在状态行的附加信息，这些域主要描述服务器的信息和Request-URI进一步的信息。响应头域包含Age、Location、Proxy-Authenticate、Public、Retry-After、Server、Vary、Warning、WWW-Authenticate。对响应头域的扩展要求通讯双方都支持，如果存在不支持的响应头域，一般将会作为实体头域处理。<br> 典型的响应消息：<br> HTTP/1.0200OK<br> Date:Mon,31Dec200104:25:57GMT<br> Server:Apache/1.3.14(Unix)<br> Content-type:text/html<br> Last-modified:Tue,17Apr200106:46:28GMT<br> Etag:"a030f020ac7c01:1e9f"<br> Content-length:39725426<br> Content-range:bytes554554-40279979/40279980<br> Location响应头<br> Location响应头用于重定向接收者到一个新URI地址。<br> Server响应头<br> Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。<br> 实体<br> 请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法未接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定义，它的长度由Content-Length或Content-Range定义。<br> Content-Type实体头<br> Content-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型Content-Range实体头Content-Range实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：<br> Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth<br> 例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。<br> Last-modified实体头<br> Last-modified实体头指定服务器上保存内容的最后修订时间。<br> 1.2.3 http协议的运作方式<br> HTTP协议是基于请求／响应范式的。一个客户机与服务器建立连接后，发送一个请求给服务器，请求方式的格式为，统一资源标识符、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。服务器接到请求后，给予相应的响应信息，其格式为一个状态行包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。<br> 　　许多HTTP通讯是由一个用户代理初始化的并且包括一个申请在源服务器上资源的请求。最简单的情况可能是在用户代理(UA)和源服务器(O)之间通过一个单独的连接来完成(见图1.1)。<br> <br> <br> 图1.1<br> 　　当一个或多个中介出现在请求／响应链中时，情况就变得复杂一些。中介由三种：代理(Proxy)、网关(Gateway)和通道(Tunnel)。一个代理根据URI的绝对格式来接受请求，重写全部或部分消息，通过URI的标识把已格式化过的请求发送到服务器。网关是一个接收代理，作为一些其它服务器的上层，并且如果必须的话，可以把请求翻译给下层的服务器协议。一个通道作为不改变消息的两个连接之间的中继点。当通讯需要通过一个中介(例如：防火墙等)或者是中介不能识<br> 别消息的内容时，通道经常被使用。<br> <br> <br> 图1.2<br> 　　上面的图1.2表明了在用户代理(UA)和源服务器(O)之间有三个中介(A,B和C)。一个通过整个链的请求或响应消息必须经过四个连接段。这个区别是重要的，因为一些HTTP通讯选择可能应用于最近的连接、没有通道的邻居，应用于链的终点或应用于沿链的所有连接。尽管图1.2是线性的，每个参与者都可能从事多重的、并发的通讯。例如，B可能从许多客户机接收请求而不通过A，并且／或者不通过C把请求送到A，在同时它还可能处理A的请求。<br> 　　任何针对不作为通道的汇聚可能为处理请求启用一个内部缓存。缓存的效果是请求／响应链被缩短，条件是沿链的参与者之一具有一个缓存的响应作用于那个请求。下图说明结果链，其条件是针对一个未被UA或A加缓存的请求，B有一个经过C来自O的一个前期响应的缓存拷贝。<br> <br> <br> 图1.3<br> 　　在Internet上，HTTP通讯通常发生在TCP/IP连接之上。缺省端口是TCP80，但其它的端口也是可用的。但这并不预示着HTTP协议在Internet或其它网络的其它协议之上才能完成。HTTP只预示着一个可靠的传输。<br> 　　以上简要介绍了HTTP协议的宏观运作方式，下面介绍一下HTTP协议的内部操作过程。<br> 　　首先，简单介绍基于HTTP协议的客户/服务器模式的信息交换过程，如图1.4所示，它分四个过程，建立连接、发送请求信息、发送响应信息、关闭连接。<br> 图1.4 <br> <br> 图1.4<br> 在WWW中，“客户”与“服务器”是一个相对的概念，只存在于一个特定的连接期间，即在某个连接中的客户在另一个连接中可能作为服务器。WWW服务器运行时，一直在TCP80端口(WWW的缺省端口)监听，等待连接的出现。<br> 　　下面，讨论HTTP协议下客户/服务器模式中信息交换的实现。　　<br> 1.建立连接　　连接的建立是通过申请套接字(Socket)实现的。客户打开一个套接字并把它约束在一个端口上，如果成功，就相当于建立了一个虚拟文件。以后就可以在该虚拟文件上写数据并通过网络向外传送。<br> 　　2.发送请求<br> 　　打开一个连接后，客户机把请求消息送到服务器的停留端口上，完成提出请求动作。<br> 　　HTTP/1.0　　请求消息的格式为：<br> 　　请求消息=请求行(通用信息|请求头|实体头)CRLF[实体内容]<br> 　　请求　行=方法　请求URL　HTTP版本号　CRLF<br> 　　方　　法=GET|HEAD|POST|扩展方法<br> 　　U　R　L=协议名称+宿主名+目录与文件名<br> 　　请求行中的方法描述指定资源中应该执行的动作，常用的方法有GET、HEAD和POST。不同的请求对象对应GET的结果是不同的，对应关系如下：<br> 　　对象　　　　　　GET的结果<br> 　　文件　　　　　　文件的内容<br> 　　程序　　　　　　该程序的执行结果<br> 　　数据库查询　　　查询结果<br> 　　HEAD——要求服务器查找某对象的元信息，而不是对象本身。<br> 　　POST——从客户机向服务器传送数据，在要求服务器和CGI做进一步处理时会用到POST方法。POST主要用于发送HTML文本中FORM的内容，让CGI程序处理。<br> 　　一个请求的例子为：<br> 　　GEThttp://networking.zju.edu.cn/zju/index.htmHTTP/1.0<br> 　　头信息又称为元信息，即信息的信息，利用元信息可以实现有条件的请求或应答。<br> 　　请求头——告诉服务器怎样解释本次请求，主要包括用户可以接受的数据类型、压缩方法和语言等。<br> 　　实体头——实体信息类型、长度、压缩方法、最后一次修改时间、数据有效期等。<br> 　　实体——请求或应答对象本身。<br> 　　3.发送响应<br> 　　服务器在处理完客户的请求之后，要向客户机发送响应消息。<br> 　　HTTP/1.0的响应消息格式如下：<br> 　　响应消息=状态行(通用信息头|响应头|实体头)　CRLF　〔实体内容〕<br> 　　状态行=HTTP版本号　状态码　原因叙述<br> 　　状态码表示响应类型<br> 　　1××　　保留<br> 　　2××　　表示请求成功地接收<br> 　　3××　　为完成请求客户需进一步细化请求<br> 　　4××　　客户错误<br> 　　5××　　服务器错误<br> 　　响应头的信息包括：服务程序名，通知客户请求的URL需要认证，请求的资源何时能使用。<br> 　　4.关闭连接<br> 　　客户和服务器双方都可以通过关闭套接字来结束TCP/IP对话<br> <br> 1.3 基于http协议的网络行为监视<br> 1.3.1 http协议的安全因素<br> HTTP协议存在许多的安全漏洞，这些安全漏洞之一就是允许远程用户向远程服务器请求连接，并且执行远程命令。这个安全漏洞可以以许多方式损坏web服务器和客户机，包括但不局限于如下这些：<br> 对远程请求的武断认证。<br> 对web服务器的武断认证。<br> 破坏请求和应答的保密性。<br> 滥用服务器功能和资源。<br> 通过搜索它的程序错误和安全漏洞，滥用服务器。<br> 滥用日志信息（提取IP地址、域名和文件名等等）。<br> 许多这样的安全漏洞是众所周知的，一些应用程序，如Netscape的SSL和NCSA的SHTTP XE“S-HTTP”试图解决这些问题，但仅仅是其中的一部分问题。问题是，在internet上，web服务器对客户的行为显得很脆弱。因此需要对其监视。<br> 1.3.2 基于http协议监视的实现<br> 在CSMA／CD(Carrier Sense Multiple Access/Collision Detection，载波侦听多路访问冲突检测)网络下，监视网络上流动的数据包，捕捉我们感兴趣的数据包，对感兴趣的数据包进行分析和研究，分析出其所遵守的协议，进一步得到其应用层数据，并在需要的情况下将其数据进行重组，恢复到被监视用户所看到的格式，为进行更深一步的分析和研究打下基础。<br> 网络监视器实现的一个前提条件是必须能够“听到”网路上所有的数据包，假如网卡仅能接收到属于自己的数据包，也就无法实现监视功能了。<br> 因此，其实现的网络应当是基于共享式的，而在CSMA／CD网络上是可以使网卡接受到所有的数据包，所以我们将实现的网络环境暂时局限于以太网上。在系统结构设计上，网络监视器可以从下向上分为三层，分别实现不同的功能，位于最下层的为捕获层，该层完成的功能是在基于CSMA／CD的网络上截获网络上传输的数据包，这一部分是与平台相关的，这是因为针对不同的操作系统平台，其网络的软件体系结构也大不相同，无论是DOS下的PktDrv驱动程序模型，还Windows下NDIS(Network Driver Interface Specification)结构模型，其处理的过程以及驱动程序的结构都不一样，因此想为它们设计一个通用的捕获包组件是不太可能的，必须针对不同操作系统的不同特点设计不同的组件，以满足它们特有的需要。为了能够在添加新的操作系统支持时不影响原有系统的实现，在该层的实现时，采用了Bridge的设计模式 ，它将Capturer(捕获类)抽象和它的实现部分分别放在独立的类层次结构中，其中一个类层次结构针对Capturer接口，另外一个独立的类层次结构针对平台相关的捕获器实现部分，这个类层次结构的根类为Capturerlmp；位于捕获层之上的为分析层，该层主要是对数据包所包含的内容进行分析，获知其所用的协议和所包括的数据，这一部分只与特定的协议组有关，而和操作系统平台无关，事实上，对于TCP／IP协议，无论是在Unix或DOS，还是在Windows下，它们的分析和重组都是完全一样的，所以，这部分可以设计为一个通用组件；最上面一层为重组层，该层对一些常用的协议进行会话恢复，以得知会话的全过程，这一部分同第二部分一样也是与平台无关的。<br> 关键技术将在下面的章节做详细介绍，包括数据包的捕获、重组、分析、解码还原等过程。</p> 
<p style="color:rgb(51,51,51)"><br> 第二章 开发工具与环境配置<br> 2.1 JAVA语言介绍<br> Java是当今流行的新兴网络编程语言，它的面向对象、跨平台、分布应用等特点给编程人员带来了一种崭新的计算概念，使WWW从最初的单纯提供静态信息发展到现在的提供各样的动态服务，发生了巨大的变化。Java不仅能够编写小应用程序，其强大的网络功能把整个Internet作为一个统一的运行平台，极大地拓展了传统单机或Client/Server模式应用程序的外延和内涵。<br> Java是定位于网络计算的计算机语言，它几乎所有的特点也是围绕着这一中心展开的并为之服务的，这些特点使得Java语言特别适合于用来开发网络上的应用程序；另外，作为一种面世较晚的语言，Java也集中体现和充分利用了若干当代软件技术新成果，如面向对象、多线程等，这些也都在它的特点中有所反映。<br> 2.1.1 平台无关性<br> 如前所述，Java语言独特的运行机制使得它具有良好的二进制的可移植性、利用Java，开发人员可以编写出与平台无关、普遍适用的应用程序，大大降低了开发、维护和管理的开销。<br> Java主要靠Java虚拟机（JVM）在目标码级实现平台无关性。JVM是一种抽象机器，它附着在具体操作系统之上，本身具有一套虚机器指令，并有自己的栈、寄存器组等。但JVM通常是在软件上而不是在硬件上实现。（目前，SUN系统公司已经设计实现了Java芯片，主要使用在网络计算机NC上。另外，Java芯片的出现也会使Java更容易嵌入到家用电器中。）JVM是Java平台无关的基础，在JVM上，有一个Java解释器用来解释Java编译器编译后的程序。Java编程人员在编写完软件后，通过Java编译器将Java源程序编译为JVM的字节代码。任何一台机器只要配备了Java解释器，就可以运行这个程序，而不管这种字节码是在何种平台上生成的（过程如图1所示）。另外，Java采用的是基于IEEE标准的数据类型。通过JVM保证数据类型的一致性，也确保了Java的平台无关性。<br> Java的平台无关性具有深远意义。首先，它使得编程人员所梦寐以求的事情（开发一次软件在任意平台上运行）变成事实，这将大大加快和促进软件产品的开发。其次Java的平台无关性正好迎合了“网络计算机”思想。如果大量常用的应用软件（如字处理软件等）都用Java重新编写，并且放在某个Internet服务器上，那么具有NC的用户将不需要占用大量空间安装软件，他们只需要一个Java解释器，每当需要使用某种应用软件时，下载该软件的字节代码即可，运行结果也可以发回服务器。目前，已有数家公司开始使用这种新型的计算模式构筑自己的企业信息系统。<br> 2.1.2 面向对象　<br> 面向对象其实是现实世界模型的自然延伸。现实世界中任何实体都可以看作是对象。对象之间通过消息相互作用。另外，现实世界中任何实体都可归属于某类事物，任何对象都是某一类事物的实例。如果说传统的过程式编程语言是以过程为中心以算法为驱动的话，面向对象的编程语言则是以对象为中心以消息为驱动。用公式表示，过程式编程语言为：程序=算法+数据；面向对象编程语言为：程序=对象+消息。<br> 　　所有面向对象编程语言都支持三个概念：封装、多态性和继承，Java也不例外。现实世界中的对象均有属性和行为，映射到计算机程序上，属性则表示对象的数据，行为表示对象的方法（其作用是处理数据或同外界交互）。所谓封装，就是用一个自主式框架把对象的数据和方法联在一起形成一个整体。可以说，对象是支持封装的手段，是封装的基本单位。Java语言的封装性较强，因为Java无全程变量，无主函数，在Java中绝大部分成员是对象，只有简单的数字类型、字符类型和布尔类型除外。而对于这些类型，Java也提供了相应的对象类型以便与其他对象交互操作。<br> 　　多态性就是多种表现形式，具体来说，可以用“一个对外接口，多个内在实现方法”表示。举一个例子，计算机中的堆栈可以存储各种格式的数据，包括整型，浮点或字符。不管存储的是何种数据，堆栈的算法实现是一样的。针对不同的数据类型，编程人员不必手工选择，只需使用统一接口名，系统可自动选择。运算符重载（operator overload)一直被认为是一种优秀的多态机制体现，但由于考虑到它会使程序变得难以理解，所以Java最后还是把它取消了。　<br> 　　继承是指一个对象直接使用另一对象的属性和方法。事实上，我们遇到的很多实体都有继承的含义。例如，若把汽车看成一个实体，它可以分成多个子实体，如：卡车、公共汽车等。这些子实体都具有汽车的特性，因此，汽车是它们的“父亲”，而这些子实体则是汽车的“孩子”。Java提供给用户一系列类（class），Java的类有层次结构，子类可以继承父类的属性和方法。与另外一些面向对象编程语言不同，Java只支持单一继承。<br> 2.1.3 安全稳定<br> 对网络上应用程序的另一个需求是较高的安全可靠性。用户通过网络获取并在本地运行的应用程序是可信赖的，不会充当病毒或其他恶意操作的传播者而攻击用户本地资源；同时还应该是稳定的，轻易不会产生死机等错误，使得用户乐于使用。Java特有的“沙箱”机制是其安全性的保障，同时它去除了C++中易造成错误的指针，增加了自动内存管理等措施，保证了Java程序运行的可靠性。<br> 由于Java主要用于网络应用程序开发，因此对安全性有较高的要求。如果没有安全保证，用户从网络下载程序执行就非常危险。Java通过自己的安全机制防止了病毒程序的产生和下载程序对本地系统的威胁破坏。当Java字节码进入解释器时，首先必须经过字节码校验器的检查，然后，Java解释器将决定程序中类的内存布局，随后，类装载器负责把来自网络的类装载到单独的内存区域，避免应用程序之间相互干扰破坏。最后，客户端用户还可以限制从网络上装载的类只能访问某些文件系统。上述几种机制结合起来，使得Java成为安全的编程语言。<br> 2.1.4 支持多线程<br> 多线程是当今软件技术的又一重要成果，已成功应用在操作系统、应用开发等多个领域。多线程技术允许同一个程序有两个执行线索，即同时做两件事情，满足了一些复杂软件的需求。Java不但内置多线程功能，而且提供语言级的多线程支持，即定义了一些用于建立、管理多线程的类和方法，使得开发具有多线程功能的程序变成简单、容易和有效。<br> Java在两方面支持多线程。一方面，Java环境本身就是多线程的。若干个系统线程运行负责必要的无用单元回收，系统维护等系统级操作；另一方面，Java语言内置多线程控制，可以大大简化多线程应用程序开发。Java提供了一个类Thread，由它负责启动运行，终止线程，并可检查线程状态。Java的线程还包括一组同步原语。这些原语负责对线程实行并发控制。利用Java的多线程编程接口，开发人员可以方便得写出支持多线程的应用程序，提高程序执行效率。必须注意地是，Java的多线程支持在一定程度上受运行时支持平台的限制。例如，如果操作系统本身不支持多线程，Java的多线程特性可能就表现不出来。<br> <br> 2.2 JDK概述<br> 2.2.1 Java开发工具JDK 介绍<br> Java Develop Kit 简称为JDK，是Java的发明者Sun公司免费发行的Java开发工具。JDK由一个标准类库和一组建立，测试及建立文档的Java实用程序组成。其核心Java API是一些预定义的类库，开发人员需要用这些类来访问Java语言的功能。Java API包括一些重要的语言结构以及基本图形，网络和文件I/O。一般来说，Java API的非I/O部分对于运行Java的所有平台是相同的，而I/O部分则仅在通用Java环境中实现。 <br> 作为JDK实用程序，工具库中有七种主要程序。<br> 　　Javac：Java编译器，将Java源代码转换成字节码。<br> 　　Java：Java解释器，直接从类文件执行Java应用程序字节代码。<br> 　　appletviewer：小程序浏览器，一种执行HTML文件上的Java小程序的Java浏览器。<br> 　　Javadoc：根据Java源码及说明语句生成HTML文档。<br> 　　Jdb：Java调试器，可以逐行执行程序，设置断点和检查变量。<br> 　　Javah：产生可以调用Java过程的C过程，或建立能被Java程序调用的C过程的头文件。<br> 　　Javap：Java反汇编器，显示编译类文件中的可访问功能和数据，同时显示字节代码含义。<br> 环境描述<br> 软件环境：Windows，Uniux，Linux操作系统，JDK1.4.1，WinPcap3.0，Jcreator，Jpcap<br> 硬件环境：<br> CPU：奔腾II<br> 内存：64M以上<br> 硬盘：10M<br> 2.2.2 开发环境配置<br> 1． 安装JDK1.4.2<br> 2． 配置JDK1.4.2<br> 3． 安装WinPcap（第三方类库）<br> 4． 安装软件Jcreator, 配置JDK profiles<br> 5． 配置jar文件<br> 把Jpcap.jar和Jpcapdumper.jar放入C:/JDK1.4.2/jre/lib/ext/<br> 6． 完成配置<br> <br> <br> <br> <br> <br> 第三章 http数据包截获<br> 3.1 http数据包截获模块设计<br> 3.1.1 体系结构设计<br> 本方案采用Jpcap.dll在数据链路层下进行数据包捕获。Jpcap提供了在Windows或UNIX系统上进行这种访问的Java API，它可以访问底层的网络数据。但Jpcap不是一种纯粹的Java解决方案；它需要依赖本地库的使用。因此，在Windows 或UNIX上，要使用必要的第三方库，分别是WinPcap或libpcap。<br> 利用专门用于网络监听的一个函数库Jpcap.lib提供的函数完成抓包工作，由于该库提供的函数抓到的包是数据链路层下的帧，因此，它可以被用来基于数据链路层下的流量捕获。其体系结构如下图所示。<br> <br> 图4.1<br> 在最底层是网络适配器（网卡），为了监听所有的包，它被设置为混杂模式（promiscuous mode）工作。这可调用库函数实现。<br> Packet Capture driver是较低层的捕获堆栈的软件模块。它和网络接口卡相互作用抓包，它提供了应用程序一系列函数可以读写数据链路层上的数据。<br> Packet.dll从捕获程序里分离出来，工作在用户层，它是一个动态链路库，使捕获程序从提供系统独立的捕获界面的驱动程序中独立出来，它提供了一系列具有捕获能力的函数供上层调用，从而避免了对驱动器的直接操作，并允许应用程序可以不经过重新编译就可以执行在不同操作系统的环境中。<br> Winpcap 是一个第三方类库，为Jpcap提供基础类。<br> Jpcap是一个静态库，可以被包捕获程序直接调用，它应用Packet.dll导出的服务向上层应用程序提供强有力的捕获界面。它是应用程序的一部分。<br> 3.1.2 WinPcap工具<br> WinPcap(windows packet capture)是windows平台下一个免费，公共的网络访问系统。它是由意大利人Fulvio Risso和Loris Degioanni等人提出并实现的。开发winpcap这个项目的目的在于为win32应用程序提供访问网络底层的能力。它提供了以下的各项功能：<br> 1&gt; 捕获原始数据报，包括在共享网络上各主机发送/接收的以及相互之间交换的数据报；<br> 2&gt; 在数据报发往应用程序之前，按照自定义的规则将某些特殊的数据报过滤掉；<br> 3&gt; 在网络上发送原始的数据报；<br> 4&gt; 收集网络通信过程中的统计信息。<br> WinPcap的主要功能在于独立于主机协议（如TCP-IP）而发送和接收原始数据报。也就是说，WinPcap不能阻塞，过滤或控制其他应用程序数据报的发收，它仅仅只是监听共享网络上传送的数据报。因此，它不能用于QoS调度程序或个人防火墙。<br> 目前，WinPcap开发的主要对象是Windows NT/2000/XP，这主要是因为在使用WinPcap的用户中只有一小部分是仅使用Windows 95/98/Me，并且M$也已经放弃了对win9x的开发。因此本文相关的程序T-ARP也是面向NT/2000/XP用户的。其实WinPcap中的面向9x系统的概念和NT系统的非常相似，只是在某些实现上有点差异，比如说9x只支持ANSI编码，而NT系统则提倡使用Unicode编码。<br> 3.1.3 Packet.dll<br> Packet.dll是从捕获程序中分离出来，工作在用户层。它是一个动态链接库，使捕获程序从提供系统独立的捕获界面的驱动程序中孤立出来。它提供了一系列的具有捕获能力的函数供上层调用，从而避免了对驱动器的直接操作。并允许应用程序可以不经过重新编译就可以执行在不同的Windows环境中。<br> 首先介绍一些相关的数据结构：<br> 1. typedef struct _ADAPTER ADAPTER //描述一个网络适配器；<br> 2. typedef struct _PACKET PACKET //描述一组网络数据报的结构；<br> 3. typedef struct NetType NetType //描述网络类型的数据结构；<br> 4. typedef struct npf_if_addr npf_if_addr //描述一个网络适配器的ip地址；<br> 5. struct bpf_hdr //数据报头部；<br> 6. struct bpf_stat //当前捕获数据报的统计信息。<br> <br> 下面是Packet.dll的一些主要的函数方法。<br> 1．LPPACKET PacketAllocatePacket(void)<br> 如果运行成功，返回一个_PACKET结构的指针，否则返回NULL。成功返回的结果将 会传送到PacketReceivePacket()函数，接收来自驱动的网络数据报。<br> 2．VOID PacketCloseAdapter(LPADAPTER lpAdapter)<br> 关闭参数中提供的网络适配器，释放相关的ADAPTER结构。<br> 3．VOID PacketFreePacket(LPPACKET lpPacket)<br> 释放参数提供的_PACKET结构。<br> 4．BOOLEAN PacketGetAdapterNames(LPSTR pStr,PULONG BufferSize)<br> 返回可以得到的网络适配器列表及描述。<br> 5．BOOLEAN PacketGetNetInfoEx(LPTSTR AdapterNames,npf_ip_addr *buff, PLONG Nentries)<br> 返回某个网络适配器的全面地址信息。<br> 其中npf_ip_addr结构包含：IPAddress,SubnetMask,Broadcast<br> IPAddress: ip地址<br> SubnetMask: 子网掩码<br> Broadcast: 广播地址<br> 6． BOOLEAN PacketGetNetType(LPADAPTER AdapterObject, NetType *type)<br> 返回某个网络适配器的MAC类型。<br> NetType结构里包含了LinkSpeed(速度)和LinkType(类型)。其中LinkType包含 以下几种情况：<br> NdisMedium802_3: Ethernet(802.3)<br> NdisMediumWan: WAN<br> NdisMedium802_5: Token Ring(802.5)<br> NdisMediumFddi: FDDI<br> NdisMediumAtm: ATM<br> NdisMediumArcnet878_2: ARCNET(878.2)<br> 7．BOOLEAN PacketGetStats(LPADAPTER AdapterObject,struct bpf_stat *s)<br> 返回几个关于当前捕获报告的统计信息。<br> 其中bpf_stat结构包含：bs_recv, bs_drop,ps_ifdrop,bs_capt<br> bs_recv: 从网络适配器开始捕获数据报开始所接收到的所有数据报的数目，包括丢失的数据报；<br> bs_drop: 丢失的数据报数目。在驱动缓冲区已经满时，就会发生数据报丢失的情况。<br> 8．PCHAR PacketGetVersion()<br> 返回关于dll的版本信息。<br> 9． VOID PacketInitPacket(LPPACKET lpPacket, PVOID Buffer, UINT Length)<br> 初始化一个_PACKET结构。<br> 10．LPADAPTER PacketOpetAdapter(LPTSTR AdapterName)<br> 打开一个网络适配器。<br> 11．BOOLEAN PacketReceivePacket(LPADAPTER AdapterObject,LPPACKET lpPacket,BOOLEAN Sync)<br> 从NPF驱动程序读取网络数据报及统计信息。<br> 数据报编码结构： |bpf_hdr|data|Padding|bpf_hdr|data|Padding|<br> 12．BOOLEAN PacketSendPacket(LPADAPTER AdapterObject,LPPACKET lpPacket, BOOLEAN Sync)<br> 发送一个或多个数据报的副本。<br> 13． BOOLEAN PacketSetBuff(LPADAPTER AdapterObject,int dim)<br> 设置捕获数据报的内核级缓冲区大小。<br> 14． BOOLEAN PacketSetHwFilter(LPADAPTER AdapterObject,ULONG Filter)<br> 为接收到的数据报设置硬件过滤规则。<br> <br> 以下为一些典型的过滤规则：<br> NDIS_PACKET_TYPE_PROMISCUOUS: 设置为混杂模式，接收所有流过的数据报；<br> NDIS_PACKET_TYPE_DIRECTED: 只有目的地为本地主机网络适配器的数据报才会被接收；<br> NDIS_PACKET_TYPE_BROADCAST: 只有广播数据报才会被接收；<br> NDIS_PACKET_TYPE_MULTICAST: 只有与本地主机网络适配器相对应的多播数据报才会被接收；<br> NDIS_PACKET_TYPE_ALL_MULTICAST: 所有多播数据报均被接收；<br> NDIS_PACKET_TYPE_ALL_LOCAL: 所有本地数据报均被接收。<br> 15．BOOLEAN PacketSetNumWrites(LPADAPTER AdapterObject,int nwrites)<br> 设置调用PacketSendPacket()函数发送一个数据报副本所重复的次数。<br> 16．BOOLEAN PacketSetReadTimeout(LPADAPTER AdapterObject,int timeout)<br> 设置在接收到一个数据报后“休息”的时间。<br> 3.1.4 Jpcap类库<br> Jpcap 是一个Java类集合，它为网络数据包的捕获提供接口和系统。包括一个可视化网络事件的协议库和工具。它不是一种纯粹的Java解决方案；它依赖本地库的使用。在Windows 或 UNIX上，你必须有必要的第三方库，分别是WinPcap或libpcap。<br> <br> 下面为Jpcap中一些重要的方法：<br> 1.openedvice()，第一个参数为string,指定要打开的设备名；第二个参数为int，指定每个包返回数据的长度；第三个参数为混杂标志，如果设为1，将网卡设置为混杂模式，监听全网段。第四个参数为以毫秒计超时时限。 <br> 2.getdevicelist(),用来返回可用来抓包的接口列表。<br> 3.ProcessPacket()，此用来不间断地抓取指定数量的包，第一个参数为int，指定所须抓包的数量，第二个参数为Jpcaphandler,指明用来分析被抓包的一个对象。<br> 4. setFilter(),此函数用来设置一个过滤器。第一个参数为string ,指明过滤的条件；第二个参数为boolean,如果为真，则过滤器有效。<br> 5.getpacket(),得到一个包。<br> 3.2 数据包的存储<br> 数据的存储主要包括两部分，一部分是TCP包头的信息，另一部分是TCP包的数据部分，TCP包头含有很多的控制信息，包括源端口、目的端口、顺序号、确认号、校验和、窗口大小等，采用数据库access保存，而对于数据部分将采用记事本进行存储，因为研究表明及时存储在记事本，数据的丢失率会小一点。<br> TCP包的头部格式如图所示：<br> <br> 图4.2<br> 在jbcap的javadoc帮助文档中已经有关于报头信息的函数了，我们只须调用即可，而且上一层的类可以继承下一层的，定义在TCP层的对象可以引用IP层和数据链路层的函数，这些函数已经编写好了， 如下图所示：<br> Class TCPPacket<br> <br> java.lang.Object<br> |<br> +-jpcap.Packet<br> |<br> +-jpcap.IPPacket<br> |<br> +-jpcap.TCPPacket<br> 图4.3<br> <br> 在程序的编写过程我用到了如下jpcap中的函数：<br> 定义包的长度：<br> public int len<br> Length of this packet <br> 定义包的数据部分<br> public byte[] data<br> Packet data (excluding the header) <br> 定义IP包的版本<br> public byte version<br> IP version (v4/v6) <br> 定义IP协议的类型<br> public byte priority<br> Priority (class) (v4/v6) <br> 定义IP数据包的标记<br> public boolean d_flag<br> IP flag bit: [D]elay (v4) <br> 定义IP数据包的偏移量<br> public short offset<br> Fragment offset (v4) <br> 定义数据包的目的IP地址<br> public IPAddress dst_ip<br> Destination IP address <br> 定义数据包的源IP地址<br> public IPAddress src_ip<br> Source IP address <br> 定义TCP数据包的源端口号<br> public int src_port<br> Source port number <br> 定义TCP数据包的目的端口号<br> public int dst_port<br> Destination port number<br> 定义TCP包的确认序号<br> public long sequence<br> Sequence number <br> 3.3 数据包捕获和存储流程图<br> 数据包的截获是通过jpcap对网卡的监听实现的，这需要用到WinPcap等第三方库，Jpcap使用一个事件模型来让你处理包。Jpcap.dll在数据链路层下进行数据包捕获，Jpcap提供了能够在Windows或UNIX系统上数据链路层下进行数据包捕获的Java API，它可以访问底层的网络数据。具体流程见下图<br> <br> <br> 图4.4<br> <br> <br> 3.4 数据包捕获和存储程序片断<br> ……………<br> if (packet instanceof TCPPacket) //选择经过网卡的的TCP包，网卡本身不能判断，是借助jpcap的自带函数实现<br> {<!-- --><br> tcp=(TCPPacket)packet;<br> if(tcp.src_port==80||tcp.dst_port==80) //定义为80号端口，确定为HTTP数据包<br> { <br> TCPPacket tcpPacket = (TCPPacket)packet;<br> countlen=countlen+tcpPacket.len;<br> ………………<br> mainFrame.label1.setText("Capturing on Device "+ i+" "+lists<em>);<br> Jpcap jpcap=Jpcap.openDevice(Jpcap.getDeviceList(),1000,true,20); //true,the inferface becomes promiscuous mode(混杂模式)<br> jpcap.loopPacket( -1, new Tcpdump()); //循环抓包，'-1'表示无限次数<br> ……………<br> </em>try<br> {<!-- --><br> // byte[] b=result.getBytes();<br> //FileOutputStream fout=new FileOutputStream(myFile);<br> RandomAccessFile fout=new RandomAccessFile("result.txt","rw"); //保存在记事本文件中<br> fout.seek(fout.length());<br> fout.writeBytes(result);<br> fout.close(); <br> }<br> catch(FileNotFoundException e)<br> {<!-- --><br> System.err.println(e);<br> }<br> catch(IOException e)<br> {<!-- --><br> System.err.println(e);<br> } //异常情况的处理<br> System.out.println("The Decode result is :/n"+result);<br> <br> String temp="insert into bao values("+count+","+tcpPacket.version+","+tcpPacket.rsv_tos+","+<br> tcpPacket.length+","+ ID2+","+tcpPacket.d_flag+","+tcpPacket.offset+","+ tcpPacket.hop_limit+","+tcpPacket.protocol+",'"+tcpPacket.src_ip+"','"+ //定义存储在数据库中的各字段tcpPacket.dst_ip+"',"+tcpPacket.sequence+",'"+msg+"')";<br> System.out.println(tcpPacket.src_ip); <br> //定义连接数据的语句<br> Con=DriverManager.getConnection("jdbc:odbc:bao","bao","123");<br> Stmt.executeQuery(temp);<br> // Con.close();<br> rs=Stmt.executeQuery("SELECT * FROM bao");<br> /* while(rs.next())<br> { <br> id=rs.getString(5);<br> System.out.print("id:"+id+" ");<br> }*/<br> Con.close();<br> 第四章 http数据包信息的分析与还原<br> 4.1 字符编码的信息概述<br> 4.1.1 ASCALL字符编码<br> 在最初的时候，美国人制定了第一张编码表 《美国标准信息交换码》，简称 ASCII，它总共规定了 128 个符号所对应的数字代号，使用了 7 位二进制的位来表示这些数字。其中包含了英文的大小写字母、数字、标点符号等常用的字符，数字代号从 0 至 127，ASCII 的表示内容如下：<br> 0 – 31 控制符号<br> 32 空格<br> 33-47 常用符号<br> 48-57 数字<br> 58-64 符号<br> 65-90 大写字母<br> 91-96 符号<br> 97-127 小写字母<br> 表4.1<br> 注意，32 表示空格，虽然我们再纸上写字时，只要手腕动一下，就可以流出一个空格，但是，在计算机上，空格与普通得字符一样也需要用一个编码来表示，33-127 共95个编码用来表示符号，数字和英文的大写和小写字母。比如数字 1 所对应的数字代号为 49，大写字母 A 对应的代号为 65, 小写字母 a 对应的代号为 97。所以，我们所写的代码 hello, world 保存在文件中时，实际上是保存了一组数字 104 101 108 108 111 44 32 119 111 114 108 100。我们再程序中比较英文字符串的大小时，实际上也是比较字符对应的 ASCII 的编码大小。 <br> 由于 ASCII 出现最早，因此各种编码实际上都受到了它的影响，并尽量与其相兼容。 <br> <br> 4.1.2 GB2312字符编码<br> GB2312又称国标码，由国家标准总局发布，1981年5月1日实施，通行于大陆。新加坡等地也使用此编码。它是一个简化字的编码规范，当然也包括其他的符号、字母、日文假名等，共7445个图形字符，其中汉字占6763个。我们平时说6768个汉字，实际上里边有5个编码为空白，所以总共有6763个汉字。<br> GB2312规定“对任意一个图形字符都采用两个字节表示，每个字节均采用七位编码表示”，习惯上称第一个字节为“高字节”，第二个字节为“低字节”。GB2312中汉字的编码范围为，第一字节0xB0-0xF7(对应十进制为176-247)，第二个字节0xA0-0xFE（对应十进制为160-254）。<br> GB2312将代码表分为94个区，对应第一字节（0xa1-0xfe）；每个区94个位（0xa1-0xfe），对应第二字节，两个字节的值分别为区号值和位号值加32（2OH），因此也称为区位码。01-09区为符号、数字区，16-87区为汉字区（0xb0-0xf7），10-15区、88-94区是有待进一步标准化的空白区。<br> 4.1.3 BIG5字符编码<br> 2、Big5又称大五码，主要为香港与台湾使用，即是一个繁体字编码。每个汉字由两个字节构成，第一个字节的范围从0X81－0XFE（即129-255），共126种。第二个字节的范围不连续，分别为0X40－0X7E（即64-126），0XA1－0XFE（即161-254），共157种。<br> 它的范围为：高字节从0x81到0xFE，低字节从0x40到0x7E，和0xA1到0xFE两部分。判断一个汉字是否是BIG5编码，可以如上对字符的编码范围判断即可。<br> 4.1.4 UNICODE(UTF-8)字符编码<br> UTF-8是UNICODE的一种变长字符编码，由Ken Thompson于1992年创建。现在已经标准化为RFC 3629。UTF-8用1到6个字节编码UNICODE字符。如果UNICODE字符由2个字节表示，则编码成UTF-8很可能需要3个字节，而如果UNICODE字符由4个字节表示，则编码成UTF-8可能需要6个字节。用4个或6个字节去编码一个UNICODE字符可能太多了，但很少会遇到那样的UNICODE字符。<br> 实际表示ASCII字符的UNICODE字符，将会编码成1个字节，并且UTF-8表示与ASCII字符表示是一样的。所有其他的UNCODE字符转化成UTF-8将需要至少2个字节。每个字节由一个换码序列开始。第一个字节由唯一的换码序列，由n位1加一位0组成。n位1表示字符编码所需的字节数。<br> <br> UTF-8编码的优点： <br> UTF-8编码可以通过屏蔽位和移位操作快速读写。字符串比较时strcmp()和wcscmp()的返回结果相同，因此使排序变得更加容易。字节FF和FE在UTF-8编码中永远不会出现，因此他们可以用来表明UTF-16或UTF-32文本（见BOM） UTF-8 是字节顺序无关的。它的字节顺序在所有系统中都是一样的，因此它实际上并不需要BOM。 <br> <br> UTF-8编码的缺点： <br> 你无法从UNICODE字符数判断出UTF-8文本的字节数，因为UTF-8是一种变长编码它需要用2个字节编码那些用扩展ASCII字符集只需1个字节的字符 ISO Latin-1 是UNICODE的子集，但不是UTF-8的子集 8位字符的UTF-8编码会被email网关过滤，因为internet信息最初设计为7为ASCII码。因此产生了UTF-7编码。 UTF-8 在它的表示中使用值100xxxxx的几率超过50%， 而现存的实现如ISO 2022， 4873， 6429， 和8859系统，会把它错认为是C1 控制码。因此产生了UTF-7.5编码。 <br> <br> 修正的UTF-8： <br> java使用UTF-16表示内部文本，并支持用于字符串串行化的非标准的修正UTF-8编码。标准UTF-8和修正的UTF-8有两点不同：修正的UTF-8中，null字符编码成2个字节（11000000 00000000） 而不是标准的1个字节（00000000），这样作可以保证编码后的字符串中不会嵌入null字符。因此如果在类C语言中处理字符串，文本不会在第一个null字符时截断（C字符串以null结尾）。在标准UTF-8编码中，超出基本多语言范围（BMP - Basic Multilingual Plain）的字符被编码为4字节格式，但是在修正的UTF-8编码中，他们由代理编码对（surrogate pairs）表示，然后这些代理编码对在序列中分别重新编码。结果标准UTF-8编码中需要4个字节的字符，在修正后的UTF-8编码中将需要6个字节。<br> 4.2 捕获数据包信息的分析<br> 4.2.1 捕获数据数据包的重组分析<br> 用户的一个有意义的数据经常分布在几个数据片中，其原因很简单，这就如同当PDU大小超过子网限制时，将一个数据片分割成若干个小的数据片段 ，由于底层软件对网络数据包大小的限制，应用软件也经常将一个有意义的数据分割在若干个数据包中。因此，也需要将若干个数据包合并在一起，组合成一个有意义的数据。这部分在重组时，它的一个重要依据就是数据片中的序号，数据片中的序号表明了该数据片在数据流中的位置，亦即表明了该数据片在应用数据的位置，因此，可以根据数据片中的序号将数据片重新组合成为一个应用数据。<br> 在进行数据片重组时，需要考虑以下几个方面的问题：<br> (1)如何将无序的数据片流有序化<br> 当数据片传到信宿机后，表现为一个无序的数据片流。众所周知，序号表明了信源机发出该数据片的先后顺序，然而，由于Internet网络是基于分组交换的，因此，数据片到达信宿机的先后顺序与序号之间没有直接关系，即序号在前的数据片反而有可能在序号在后的数据片之后到达，因此数据片传到信宿机时，在对其进行排序处理之前，到达的数据表现为一个无序的数据片流。<br> 为了方便应用数据的恢复，需要将无序的数据片流有序化，使其表现为一个有序的数据片流(或者说是数据流)。在软件实现数据片有序化时。可以设置一个缓冲队列，该缓冲队列的最大空间可设为滑动窗口的最大值。当接收到一个数据片段时。首先比较其数据片序号和应获得的数据片序号，假如两者相同，则将其归人已收的数据行列，并从缓冲队列中将满足出队条件的数据出队。若没有，将其纳人缓冲队列中，并比较应获得的数据片序号和已获得的数据片，判断还需要何种数据片。<br> <br> <br> (2)如何判断应用数据的起始数据片<br> 在前面已经提到。信源机传来的数据在信宿机表现为一个数据片流。因此。必须将这个流切割开来，才能确定一个应用数据的起点和终点。在日常的应用中，整个数据传输都处于应用程序的控制之下，数据的发送是由应用程序主动发起的。而数据的接收常常是一个请求的响应。所以，可以预期到数据的到来和结束，应用数据起点和终点的确定也就不成什么问题。但是，在网络监视器中，数据的发送者和接收者(真正的)都是第三方，并且对其的监视可能是任何时候发起的，也许在开始对某一主机进行监视之前，其数据传输早已开始，或者在开始对某一主机进行监视之后，其数据传输还迟迟不开始，因此，为了获得一个完整的应用数据，必须准确地确定其起点和终点并抛弃掉不完整的应用数据。<br> 为了确定一个应用数据的起点和终点，必须研究其应用层数据 。对于HTTP数据，其有两种数据内容，一种为请求数据(Request)，一种为响应数据(Response)。对于请求数据来说，可以认为数据内容以“GET”、“POST”、“HEAD”、“HTTP”开头的即为起始数据片。对于请求信息结束的判定方法有两种情况：若请求信息中含有Content—Length域，则可根据其值依次取出规定数目的内容，即可确定结束数据片；若请求信息中不含有Content—Length域，则可以以两个CRLF作为结束标志。对于响应数据来说，在设计时可以认为数据内容为“HTTP”的即为起始数据片。对于响应信息结束的判定方法同样也有两种情况：若响应信息中含有Content—Length域，则可根据其值依次取出规定数目的内容，即可确定结束数据片；若响应信息中不含有Content—Length域，则可根据该数据片是否是FIN片来确定。<br> <br> 4.2.2 捕获数据包编码格式的分析<br> 对于捕获的数据分析，捕获的数据就是一大堆的二进制数据，为了便于存储，转化为十六进制数据。我们首先必须找到方法来确定那些编码是用来传送文字信息的；那些是用来传送图片信息的；那些是用来传送声音信息的，这里我们主要探讨传送的文字信息。<br> 而对于文字信息的解码需要根据文字的编码信息才能确定，这里我们主要考虑中文和英文信息的编码，对于英文信息的编码一般采用ASCALL编码；中文信息的编码一般采用gb2312（简体中文），big5（繁体中文），unicode（utf-8）。<br> 在判断一段数据包的数据采用那种编码，一般首先用ASCALL码去还原要<br> 判断信息，从中找到一些关于编码的信息，在根据编码信息去还原要还原的信息，<br> 4.2.3 捕获数据的分析的程序片段<br> if(method=="")<br> {<!-- --><br> for(int j=0;j&lt;num;j++)<br> {<!-- --><br> result=result+d.DecodeAscII(hex[j]);<br> }<br> }<br> ASCALL码解码算法的流程图如下图所示：<br> <br> 图4.1<br> 4.3 对捕获数据包信息的部分还原<br> 4.3.1 捕获数据包信息还原的流程图<br> 首先我们把要还原的数据包进行初始化，通过采用ASCALL判码方式对十六进制数据信息进行还原，我们将通过观察“Content-Type”“charset”等特殊字符，我们可判断该数据包是否传送的是文本信息，采用什么编码方式，诸如：“Content-Type: text/html; charset=gb2312”，这样可以确认为文本信息，采用的是gb2312检体中文编码方式，接下来我们将采用gb2312编码的解码算法对这段信息进行还原，如果是其它信息的编码，我们将采用其它编码方式进行解码还原。还原的大致流程图如下：<br> <br> <br> 图4.2<br> 4.3.2 捕获数据包的信息还原算法<br> 在通过对数据包的分析得到还原文本信息所采用的编码方法后，根据得到的编码方法信息去解码当前要还原的信息。<br> 1.当获得的编码方法是GB2312时<br> 由于gb2312规定“对任意一个图形字符都采用两个字节表示，每个字节均采用七位编码表示”。GB2312中汉字的编码范围为，第一字节0xB0-0xF7(对应十进制为176-247)，第二个字节0xA0-0xFE（对应十进制为160-254）。<br> GB2312将代码表分为94个区，对应第一字节（0xa1-0xfe）；每个区94个位（0xa1-0xfe），对应第二字节，两个字节的值分别为区号值和位号值加32（2OH），因此也称为区位码。01-09区为符号、数字区，16-87区为汉字区（0xb0-0xf7），10-15区、88-94区是有待进一步标准化的空白区。<br> 在编写gb2312解码算法的时候，算法思想是这样的，首先对转换后的前两位16进制数据进行判断，如果这两位十六进制数落在0xa1-0xfe内，则可以判断该编码是汉字编码的第一个字节，那么编码的第二个字节将是接下来的连续两个十六进制，因为汉字在gb2312编码标准中是采用两个字节编码的，根据这四个十六进制数位，我们就可以调用操作系统字库中gb2312编码表中对应的汉字；如果这两位十六进制数没有落在这样的范围内，则可判断是ASCALL码字符， ASCALL码是采用一个字节来编码的，这主要是英文、数字和常用字符，其解码程序很简单，在大部分编码标准都是固定的。将解码后的字符保存在字符串变量中，然后继续根据以上方法把所有编码转化为相应的字符，这样捕获的数据包的部分数据就全部可以还原为原始信息。<br> 在程序实现算法时，为了让程序尽量简单，对于十六进制数的判断并没有在每个细节上去照顾，通过大量的实验数据表明，程序只是对与极个别的编码不能正确的识别，下图给出算法的流程图：<br> <br> 图4.3<br> 下面给出部分核心程序： <br> if(method=="gb2312")<br> {<!-- --><br> for(int j=0;j&lt;NUM;J++)<br> {<!-- --><br> char c=hex[j].charAt(0);//数组hex[]中每一个变量代//表两个十六进制的数位，在这之前已经初始化<br> switch(c)<br> { <br> case 'A':<br> case 'B':<br> case 'C':<br> case 'D':<br> case 'E':<br> case 'F':<br> {<!-- --><br> count++;<br> if((count%2)!=0) //如果在汉字字符范围则多取//一个字节<br> {<!-- --><br> if(j&lt;NUM-1)<br> {<!-- --><br> String str=hex[j]+hex[j+1];//两个字节16位， <br> result=result+d.DecodeGB2312(str);<br> //调用程序的另一部分，这部分将调用字库中gb2312表中的响应字符<br> } <br> } <br> } break; default:result=result+d.DecodeAscII(hex[j]);break;<br> //调用ASCALL解码程序，对编码进行解码还原<br> } <br> }<br> }<br> 下图是gb2312编码字符解码还原结果：<br> <br> 图4.4<br> 2.当获得的编码方法是utf-8时<br> UNICODE是一种国际通用编码，UNICODE是为了处理包括中文，日文等字符而提出的一种通用的字符集。最初的UNICODE为双字节字符集，即16位编码，能够包括65，536个字符。但这样的容量并不能满足所有需要，因此，现在的UNICODE已经扩展到4个字节，能够容纳1,112,064 个字符，而这些在16位之后的扩展背称为增补字符。<br> <br> 编码字符集是一个字符集，它为每一个字符分配一个唯一数字。Unicode 标准的核心是一个编码字符集，字母“A”的编码为0041 和字符“?”的编码为 20AC。Unicode 标准始终使用十六进制数字，而且在书写时在前面加上前缀“U+”，所以“A”的编码书写为“U+0041”。<br> <br> 代码点是指可用于编码字符集的数字。编码字符集定义一个有效的代码点范围，但是并不一定将字符分配给所有这些代码点。有效的 Unicode 代码点范围是 U+0000 至 U+10FFFF。Unicode 4.0 将字符分配给一百多万个代码点中的 96,382 代码点。<br> 增补字符是代码点在 U+10000 至 U+10FFFF 范围之间的字符，也就是那些使用原始的 Unicode 的 16 位设计无法表示的字符。从 U+0000 至 U+FFFF 之间的字符集有时候被称为基本多语言面 (BMP)。因此，每一个 Unicode 字符要么属于BMP，要么属于增补字符。<br> 字符编码方案是从一个或多个编码字符集到一个或多个固定宽度代码单元序列的映射。最常用的代码单元是字节，但是 16位或 32 位整数也可用于内部处理。UTF-32、UTF-16 和 UTF-8 是 Unicode 标准的编码字符集的字符编码方案。(所谓编码方案可以视为具体的实现方案，即计算机内部的具体实现方案)<br> UTF-8是能够兼容所有的客户访问端，是发展的方向，所以很多网站都开始采用了UTF-8编码规则进行编码。 UTF-8使用一至四个字节的序列对编码 Unicode 代码点进行编码。U+0000 至 U+007F 使用一个字节编码，U+0080 至 U+07FF 使用两个字节，U+0800 至 U+FFFF 使用三个字节，而 U+10000 至 U+10FFFF 使用四个字节。UTF-8 设计原理为：字节值 0x00 至 0x7F 始终表示代码点 U+0000 至 U+007F（Basic Latin 字符子集，它对应 ASCII 字符集）。这些字节值永远不会表示其他代码点，这一特性使 UTF-8 可以很方便地在软件中将特殊的含义赋予某些 ASCII 字符。UFT-8转换表表示如下：<br> <br> UNICODE编码 UTF-8编码<br> 00000000 - 0000007F 0xxxxxxx<br> 00000080 - 000007FF 110xxxxx 10xxxxxx<br> 00000800 - 0000FFFF 1110xxxx 10xxxxxx 10xxxxxx<br> 00010000 - 001FFFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br> 00200000 - 03FFFFFF 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx<br> 04000000 - 7FFFFFFF 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx<br> 表4.2<br> <br> 由于UTF-8中汉字的编码集中采用三个字节编码，所以在解码的时候我们可以根据上面的三个字节编码规则对UTF-8编码进行解码。在解码的时候我们首先将十六进制转化为二进制，然后判断第一个字节编码，如果是以“1110”字符开始，那么可以确定该字节将是某一汉字编码的第一个字节的编码，再将接下来的四个连续十六进制数据一起传递到utf-8解码函数里，就可以在操作系统字库中能找到相应的汉字字符；如果转化后的二进制第一字节不是以“1110”开始，那么我们就默认采用ASCALL编码规则解码为英文字符等。在具体的程序编码时，为了简洁，就没有在对汉字编码字符的第二、三个字节给以判断。算法的流程图如下图所示：<br> <br> 图4.5<br> <br> 以下是UTF-8部分解码核心程序。<br> if(method=="utf-8")<br> {<!-- --><br> for(int j=0;j&lt;NUM;J++)<br> {<!-- --><br> char a=hex[j].charAt(0);<br> char b=hex[j].charAt(1); <br> switch(a)<br> { //将十六进制转化为二进制<br> case'0':h="0000";break;<br> case'1':h="0001";break;<br> case'2':h="0010";break;<br> ………………//省略了部分转化代码<br> case'F':h="1111";break;<br> }<br> <br> if(h.startsWith("1110"))<br> {<!-- --><br> String str=hex[j]+hex[j+1]+hex[j+2];<br> result=result+d.DecodeUTF(str); //调用UTF-8解码函数<br> j+=2; <br> }<br> <br> else<br> result=result+d.DecodeAscII(hex[j]);//调用ASCALL解码函数<br> }<br> } <br> 下图是UTF-8编码字符解码还原结果：<br> <br> 图4.6<br> 3.当获得的编码方法是big5时，<br> big5编码即繁体中文编码，每个汉字由两个字节构成，第一个字节的范围从0X81－0XFE（即129-255），共126种。第二个字节的范围不连续，分别为0X40－0X7E（即64-126），0XA1－0XFE（即161-254），共157种。<br> 在对big5编码进行解码的时候，首先需要对编码的第一个十六进制位，如果其范围是“8到F”；第二个范围是“1到E”；第三个范围是“4到7”或是“A到F”；第四个范围是“0到E”或是“0到E”，则可判断该编码是汉字字符，即可以采用big5解码程序调用字库中汉字字符。如果不满足汉字编码的范围将视为ASCALL编码字符，采用ASCALL解码程序解码。在具体的程序编写时，考虑到程序的简洁性，重点对第一字节的高四位和第二字节的高四位进行判断。算法的流程图如下图所示：<br> <br> 图4.7<br> 下面给出big5解码的部分核心程序。<br> if(method=="big5")<br> {<!-- --><br> for(int j=0;j<br> {<!-- --><br> <br> char c=hex[j].charAt(0);<br> char e=hex[j].charAt(1);<br> <br> switch(c)<br> { <br> case '8':<br> case '9':<br> case 'A':<br> case 'B':<br> case 'C':<br> case 'D':<br> case 'E':<br> case 'F':<br> //对第一字节的高四位进行判断<br> {<!-- --><br> int i=j+1;<br> char u=hex.charAt(0);<br> char v=hex.charAt(1); <br> if(u&gt;='4'&amp;&amp;u&lt;='7'||u&gt;='A'&amp;&amp;u&lt;='F')<br> //对第二字节的高四位进行判断<br> {<!-- --><br> String str=hex[j]+hex; result=result+d.Decodebig5(str);<br> 调用UTF-8解码函数 <br> } <br> else <br> {<!-- --><br> result=result+d.DecodeAscII(hex[j]);<br> result=result+d.DecodeAscII(hex);<br> }<br> ++j; <br> } break; default:result=result+d.DecodeAscII(hex[j]);break; //调用ASCALL解码函数<br> <br> } <br> }<br> }<br> 下图是big5编码字符解码还原结果：<br> <br> 图4.8<br> <br> <br> <br> <br> <br> 第五章 总结<br> 通过做这次毕业设计，我学到更多关于网络、JAVA程序设计和数据编码方面的知识，极大的开拓了我的视野。在整个开发过程中遇到了很多问题，在老师的教导和自己的努力下最终都被一一解决，对其中比较主要的几点体会总结如下。<br> （1）在学计算机网络课时，学的更多的是理论知识，对网络中的分层次的模型只是有那样一个模糊的概念，对每层的具体功能的实现并不清楚，也很难去理解它。通过这次毕业设计，我真正感受到了TCP/IP协议模型的网络层次，现在已经变成了很具体的东西了，理解了每一层在网络通信中的功能，数据是怎样在<br> 两台主机之间进行通信的。<br> （2）学到了JAVA面向对象编程技术在处理网络编程上的强大功能，JAVA本身并不能访问底层的网络数据，但是它能利用其它一些工具来访问，在本文中就利用了Jpcap，Jpcap是一种提供在Windows或UNIX系统上进行这种访问的Java API。Jpcap不是一种纯粹的Java解决方案；它依赖本地库的使用。在Windows 或 UNIX上，你必须有必要的第三方库，分别是WinPcap或libpcap，同样这体现了JAVA语言的可移植性。<br> （3）学到了一些字符编码解码相关技术，由于各个国家的语言不尽相同，甚至同一国家也有几种语言，为了让计算机能识别这些语言，并能传播这些语言，那么对每种语言的进行合理的编码就显得特别重要，遗憾的是到目前为趾并没有一种编码技术能容纳全世界所有的语言，不过已经有这样的机构开始这样的努力了，当然这存在一个问题，如果这种编码技术实现所有语言的编码，那么每一个字符所站用的字节数势必会更大，这样就要有更大存储空间，也降低了运行速度。涉及到中文编码的主要编码技术有，检体中文GB2312编码，繁体中文BIG5，统一编码UNICODE（UTF-8），当然对于最初的ASCALL编码是很重要的，后来发展的编码技术大多沿用了这种编码。<br> 总之经过几个月的努力，我最终完成了本软件的开发。在整个开发过程中，我不仅学会了java, 体验了开发的苦与乐，而且也达到了锻炼自己的目的，同时进一步加深了对软件开发的认识和理解。<br> 对于数据包信息的分析技术主要是讨论数据包的是那种类型文件，本文只讨论了对于文本信息的分析技术， 对于语音、图象等类型的文件没有找到识别方法，在进一步的工作中可以去探讨。还有本文讨论的全是经过基于TCP80号端口的HTTP数据包，但是在其它端口也有可能出现HTTP数据包，在进一步的工作中可以去监视更多的端口，发现更多的HTTP数据包。<br> 对于本文实现的对于文本内容的还原，首先采用的是对数据包的数据用ASCALL码解码，再观察出是定义的字符编码是什么，然后通过这种编码的解码程序对这段数据包进行还原，在进一步的工作看能否找到更好的办法去解码还原文本字符。<br> 本文集中探讨了通过TCP80号端口的HTTP数据包的文本字符的还原，基本上是网页的信息，在进一步的工作中看能否去还原更多的实时通信信息。<br> <br> 参 考 文 献<br> [1] 宋波 东晓梅．Java应用设计[M]．北京：人民邮电出版社．2002.6<br> [2] 喻莉 石冰心．基于HTTP的网络服务性能建模与分析[J]．电子与信息学报 2001.23(1) 53～59<br> [3] 陈志军 王丹．支持内容分析的网络监视器的设计与实现[J]．沈阳航空工业学院学报．2OO4.21(5) 53～55 <br> [4] 徐 健 王 涛．HTTP／1．1的分析[J]．西南师范大学学报 2004.29(2) 315～319 <br> [5] W.Richard Stevens．TCP/IP Illustracted Volume 1:The Protocols[M]．Addison Wesley/Pearson．2OO4.l <br> [6] 蔡剑 景楠．Java Web 应用开发：J2EE和Tomcat[M]．北京:清华大学出版社 2005.1<br> [7] 朱巧明、李培峰、吴娴、朱晓旭．中文信息处理技术教程[M]．北京：清华大学出版社 2004.9<br> [8]Behrauz A．Forouzan／sophia．TCP／IP protocol suite．Second version[M]．McGrow—hil1．2003<br> [9] 谢希仁.计算机网络[M].北京：电子工业出版社 2005.6<br> [10]熊桂喜 王小虎 译.计算机网络[M]. 清华大学出版社 2003.7</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3dceb6070d958516595fc4072564ebc7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java程序中使用XXXX-XX-XX XX:XX:XX格式的日期</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/81fe129f186e17f0e7f2af30022803cc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">UIPanGestureRecognizer学习笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>