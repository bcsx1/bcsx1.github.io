<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中常见的数据结构以及Java集合框架的使用 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java中常见的数据结构以及Java集合框架的使用" />
<meta property="og:description" content="常见的数据结构 数组 数组是多个相同类型数据按一定顺序排列的集合。
结构特点：
数组是有序排列的。数组属于引用数据类型的变量。数组的元素既可以是基本数据类型，也可以是引用数据类型。创建数组对象会在内存中开辟一整块连续的空间。数组的长度一旦确定，就不能修改。 功能特点：可以根据下标进行随机访问，查找快但增删慢
链表 链表是物理存储单元上非连续的、非顺序的存储结构。
链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。
特点：增删快，查找慢
栈 栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。
栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。
队列 队列只允许在表的一端进行插入操作，而在另一端进行删除操作。也就是类似于常见的排队。
一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。
树 树是典型的非线性结构，是n(n&gt;=0)个节点的有限集。n=0时称为空树。n&gt;0时，有限集的元素构成一个具有层次感的数据结构。
区别于线性表一对一的元素关系，树中的节点是一对多的关系。树具有以下特点：
n&gt;0时，根节点是唯一的，不可能存在多个根节点。每个节点有零个至多个子节点；除了根节点外，每个节点有且仅有一个父节点。根节点没有父节点。 堆 堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。
哈希 哈希表（Hash Table）是一种特殊的数据结构，它最大的特点就是可以快速实现查找、插入和删除。
哈希表（Hash Table）：也叫散列表，是根据关键码值（key-value）而直接进行访问的数据结构，也就是我们常用到的map。
哈希函数：也称为是散列函数，是Hash表的映射函数，它可以把任意长度的输入变换成固定长度的输出，该输出就是哈希值。哈希函数能使对一个数据序列的访问过程变得更加迅速有效，通过哈希函数，数据元素能够被很快的进行定位。
图 在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。
和线性表，树的差异:
线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点(Vertex)。线性表可以没有元素，称为空表；树中可以没有节点，称为空树；但是，在图中不允许没有顶点(有穷非空性)。线性表中的各元素是线性关系，树中的各元素是层次关系，而图中各顶点的关系是用边来表示(边集可以为空)。 小结 一般来说，数组、栈、队列、链表、哈希表这几个数据结构是用得比较多的，在具体的项目开发中，一般使用的是Java集合框架中的各种集合接口，如List 接口、set接口以及map接口等等。
Java集合 集合、数组都是对多个数据（对象）进行存储操作的结构，简称Java容器。
数组的缺点 初始化数组时要指定长度 , 且长度不可修改
数组采用连续的地址存储 , 添加和删除效率低下
数组无法直接保存映射关系
数组提供的方法有限
Java集合就像一种容器，可以动态地把多个对象的引用放入容器中集合的元素必须是对象类型，不能是基本数据类型，如果是基本数据类型，此时使用的是包装类（(自动装箱/拆箱） 如 : coll.add(12); == coll.add(Integer.valueOf(12)); 容器分类 容器主要包括Collection 和Map两种，Collection存储着对象的集合，而Map存储着键值对的映射表。
单列集合框架概述 /----Collection接口 : 单列集合 ; 用来存储一个一个的对象 /----List接口 : 元素 有序 可重复; ---&gt;&#34;动态数组&#34; /----ArrayList , LinkedList , Vector /----Set接口 : 元素 无序且不可重复; ---&gt;高中&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/6b4c8943db743c402fdd952e6ada5a5c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-16T15:21:00+08:00" />
<meta property="article:modified_time" content="2022-08-16T15:21:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中常见的数据结构以及Java集合框架的使用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>常见的数据结构</h2> 
<p><img alt="" height="561" src="https://images2.imgbox.com/b3/c9/5sTN09ks_o.png" width="832"></p> 
<h3> 数组</h3> 
<p>        数组是多个相同类型数据按一定顺序排列的集合。</p> 
<blockquote> 
 <p>结构特点：</p> 
 <ol><li>数组是有序排列的。</li><li>数组属于引用数据类型的变量。数组的元素既可以是基本数据类型，也可以是引用数据类型。</li><li>创建数组对象会在内存中开辟一整块连续的空间。</li><li>数组的长度一旦确定，就不能修改。</li></ol> 
 <p>功能特点：可以根据下标进行随机访问，查找快但增删慢</p> 
</blockquote> 
<p class="img-center"><img alt="" height="164" src="https://images2.imgbox.com/f7/95/Vt21EvKj_o.png" width="510"></p> 
<h3> </h3> 
<h3>链表</h3> 
<p>        链表是物理存储单元上非连续的、非顺序的存储结构。</p> 
<blockquote> 
 <p>链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。</p> 
 <p></p> 
 <p>特点：增删快，查找慢</p> 
</blockquote> 
<h3><img alt="" height="111" src="https://images2.imgbox.com/ef/df/QqGZgOys_o.png" width="696"></h3> 
<h3>栈</h3> 
<p>        栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。</p> 
<blockquote> 
 <p>栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="346" src="https://images2.imgbox.com/bf/5b/GEVz8z2v_o.png" width="692"></p> 
<h3> 队列</h3> 
<p>        队列只允许在表的一端进行插入操作，而在另一端进行删除操作。也就是类似于常见的排队。</p> 
<blockquote> 
 <p>一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="609" src="https://images2.imgbox.com/f4/1e/87aqBaHJ_o.png" width="594"></p> 
<h3> 树</h3> 
<p>        树是典型的非线性结构，是n(n&gt;=0)个节点的有限集。n=0时称为空树。n&gt;0时，有限集的元素构成一个具有层次感的数据结构。</p> 
<blockquote> 
 <p>区别于线性表一对一的元素关系，树中的节点是一对多的关系。树具有以下特点：</p> 
 <ol><li>n&gt;0时，根节点是唯一的，不可能存在多个根节点。</li><li>每个节点有零个至多个子节点；除了根节点外，每个节点有且仅有一个父节点。根节点没有父节点。</li></ol> 
</blockquote> 
<p class="img-center"><img alt="" height="368" src="https://images2.imgbox.com/78/26/RtsvoKpU_o.png" width="717"></p> 
<h3> 堆</h3> 
<p>        堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。</p> 
<p class="img-center"><img alt="" height="172" src="https://images2.imgbox.com/13/8b/ggjo4pjk_o.png" width="402"></p> 
<p> </p> 
<h3>哈希</h3> 
<p>        哈希表（Hash Table）是一种特殊的数据结构，它最大的特点就是可以快速实现查找、插入和删除。</p> 
<blockquote> 
 <p>哈希表（Hash Table）：也叫散列表，是根据关键码值（key-value）而直接进行访问的数据结构，也就是我们常用到的map。</p> 
 <p></p> 
 <p>哈希函数：也称为是散列函数，是Hash表的映射函数，它可以把任意长度的输入变换成固定长度的输出，该输出就是哈希值。哈希函数能使对一个数据序列的访问过程变得更加迅速有效，通过哈希函数，数据元素能够被很快的进行定位。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="355" src="https://images2.imgbox.com/ed/9f/pPG7YDVS_o.png" width="324"></p> 
<h3> 图</h3> 
<p>        在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。</p> 
<blockquote> 
 <p>和线性表，树的差异:</p> 
 <ul><li>线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点(Vertex)。</li><li>线性表可以没有元素，称为空表；树中可以没有节点，称为空树；但是，在图中不允许没有顶点(有穷非空性)。</li><li>线性表中的各元素是线性关系，树中的各元素是层次关系，而图中各顶点的关系是用边来表示(边集可以为空)。</li></ul> 
</blockquote> 
<p class="img-center"><img alt="" height="236" src="https://images2.imgbox.com/46/5f/F0NBLGIe_o.png" width="463"></p> 
<h3> 小结</h3> 
<blockquote> 
 <p>        一般来说，数组、栈、队列、链表、哈希表这几个数据结构是用得比较多的，在具体的项目开发中，一般使用的是Java集合框架中的各种集合接口，如List 接口、set接口以及map接口等等。</p> 
</blockquote> 
<p></p> 
<h2>Java集合</h2> 
<p>        集合、数组都是对多个数据（对象）进行存储操作的结构，简称Java容器。</p> 
<ul><li>数组的缺点</li></ul> 
<blockquote> 
 <p>初始化数组时要指定长度 , 且长度不可修改</p> 
 <p>数组采用连续的地址存储 , 添加和删除效率低下</p> 
 <p>数组无法直接保存映射关系</p> 
 <p>数组提供的方法有限</p> 
</blockquote> 
<ul><li>Java集合就像一种容器，可以动态地把多个对象的引用放入容器中</li><li><strong>集合的元素必须是对象类型，不能是基本数据类型，如果是基本数据类型，此时使用的是包装类（(自动装箱/拆箱）</strong></li></ul> 
<pre><code>如 : coll.add(12); == coll.add(Integer.valueOf(12));</code></pre> 
<h3>容器分类</h3> 
<blockquote> 
 <p>容器主要包括Collection 和Map两种，Collection存储着对象的集合，而Map存储着键值对的映射表。</p> 
</blockquote> 
<h3>单列集合框架概述</h3> 
<pre><code>/----Collection接口 : 单列集合 ; 用来存储一个一个的对象
        /----List接口 : 元素 有序 可重复; ---&gt;"动态数组"
                /----ArrayList , LinkedList , Vector
        /----Set接口 : 元素 无序且不可重复; ---&gt;高中"集合"概念
                /----HashSet , LinkedHashSet , TreeSet</code></pre> 
<p><img alt="" height="384" src="https://images2.imgbox.com/0a/06/EZyjZ9F3_o.png" width="743"></p> 
<h3>Collection接口常用方法</h3> 
<pre><code class="language-java">1、添加
    add(Object obj)
    addAll(Collection coll)
2、获取有效元素的个数
    int size()
3、清空集合
     void clear()
4、是否是空集合  
    boolean isEmpty()
5、是否包含某个元素
     boolean contains(Object obj)：是通过元素的equals方法来判断是否是同一个对象
     boolean containsAll(Collection c)：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。
6、删除  
     boolean remove(Object obj) ：通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素
     boolean removeAll(Collection coll)：取当前集合的差集
7、取两个集合的交集
     boolean retainAll(Collection c)：把交集的结果存在当前集合中，不影响c 
8、集合是否相等
     boolean equals(Object obj)
9、转成对象数组
     Object[] toArray()
10、获取集合对象的哈希值
     hashCode()
11、遍历
     iterator()：返回迭代器对象，用于集合
</code></pre> 
<p>Collection集合与数组间的转换: </p> 
<pre><code class="language-java">//集合 ---&gt;数组：toArray()
Object[] arr = coll.toArray();
for(int i = 0;i &lt; arr.length;i++){
System.out.println(arr[i]);
}
//拓展：数组 ---&gt;集合:调用Arrays类的静态方法asList(T ... t)
List&lt;String&gt; list = Arrays.asList(new String[]{"AA", "BB", "CC"});//长度确定的List数组, 不属                                                                                    
于List接口的任何实现类
System.out.println(list);
List arr1 = Arrays.asList(new int[]{123, 456});
System.out.println(arr1.size());//1
List arr2 = Arrays.asList(new Integer[]{123, 456});
System.out.println(arr2.size());//2</code></pre> 
<h3>迭代器Iterator 和 foreach循环</h3> 
<p>        Iterator对象称为迭代器(设计模式的一种)，<strong>主要用于遍历 Collection 集合中的元素。</strong></p> 
<p>遍历的代码实现：</p> 
<pre><code class="language-java">//每次调用coll.iterator() 都会生成一个新的迭代器对象
//相对于定义了一个指针指向集合首元素的上方
Iterator iterator = coll.iterator();
//hasNext():判断是否还下一个元素
while(iterator.hasNext()){
//next():①指针下移 ②将下移以后集合位置上的元素返回
System.out.println(iterator.next());
</code></pre> 
<p>foreach 循环 : 可用于 遍历 集合 和数组 (内部仍然调用了迭代器。)</p> 
<pre><code class="language-java">
@Test
public void test1(){
Collection coll = new ArrayList();
coll.add(123);
coll.add(456);
coll.add(new Person("Jerry",20));
coll.add(new String("Tom"));
coll.add(false);


//for(集合元素的类型 局部变量 : 集合对象)
for(Object obj : coll){
System.out.println(obj);
}
}
遍历数组举例：
@Test
public void test2(){
int[] arr = new int[]{1,2,3,4,5,6};
//for(数组元素的类型 局部变量 : 数组对象)
for(int i : arr){
System.out.println(i);
}
}
说明：
内部仍然调用了迭代器。
</code></pre> 
<h3>List接口</h3> 
<ul><li>数据特点 : <strong>有序 , 可重复</strong></li><li>主要实现类</li></ul> 
<pre><code>/----List接口 : 元素 有序 可重复; ---&gt;"动态数组"
    /----ArrayList :作为List接口的主要实现类;线程不安全的,效率高;底层使用一个Object[]进行存储
    /----LinkedList :适用于频繁进行插入,删除操作的集合;底层使用双向链表实现.
    /----Vector : 古老实现类,jdk1.0时就有了;线程安全的,效率低.底层也使用Object[]进行存储</code></pre> 
<ul><li>常用方法(记住): 相比较与Collection接口, List 是有序的, 所以增加了有关索引的方法</li></ul> 
<pre><code class="language-java">增: add(Object obj)
删: remove(int index) / remove(Object obj)
改: set(int index , Object obj)
查: get(int index)
插入: add(int index , Object obj)
长度: size()
遍历: Iterator迭代器
foreach循环
for循环</code></pre> 
<h4><span style="color:#333333;"><strong>ArrayList：数组实现----查找快，增删慢</strong></span></h4> 
<blockquote> 
 <div> 
  <div> 
   <span style="color:#000000;">ArrayList</span> 
   <span style="color:#000000;">底层就是一个长度可变的</span> 
   <span style="color:#000000;">Object</span> 
   <span style="color:#000000;">数组</span> 
   <span style="color:#333333;">. </span> 
  </div> 
  <div> 
   <span style="color:#000000;">ArrayList</span> 
   <span style="color:#000000;">底层使用了一个 </span> 
   <span style="color:#008855;">Object</span> 
   <span style="color:#333333;">[] </span> 
   <span style="color:#000000;">来存储数据</span> 
   <span style="color:#333333;">,</span> 
   <span style="color:#000000;">还定义了一个</span> 
   <span style="color:#000000;">int</span> 
   <span style="color:#000000;">型 </span> 
   <span style="color:#000000;">size</span> 
   <span style="color:#000000;">来记录集合中元 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">素的个数</span> 
   <span style="color:#333333;">. </span> 
  </div> 
  <div> 
   <span style="color:#000000;">在</span> 
   <span style="color:#000000;">jdk1</span> 
   <span style="color:#333333;">.</span> 
   <span style="color:#116644;">7</span> 
   <span style="color:#000000;">中</span> 
   <span style="color:#333333;">,</span> 
   <span style="color:#000000;">使用无参构造方法创建</span> 
   <span style="color:#000000;">ArrayList</span> 
   <span style="color:#000000;">对象时</span> 
   <span style="color:#333333;">, </span> 
   <span style="color:#000000;">底层</span> 
   <span style="color:#000000;">Object</span> 
   <span style="color:#333333;">[]</span> 
   <span style="color:#000000;">的默认长度为</span> 
   <span style="color:#000000;">10</span> 
   <span style="color:#333333;">; </span> 
  </div> 
  <div> 
   <span style="color:#000000;">ArrayList list </span> 
   <span style="color:#981a1a;">= </span> 
   <span style="color:#770088;">new </span> 
   <span style="color:#000000;">ArrayList</span> 
   <span style="color:#333333;">();</span> 
   <span style="color:#aa5500;">//</span> 
   <span style="color:#aa5500;">底层创建了长度是</span> 
   <span style="color:#aa5500;">10</span> 
   <span style="color:#aa5500;">的</span> 
   <span style="color:#aa5500;">Object[]</span> 
   <span style="color:#aa5500;">数组 </span> 
  </div> 
  <div> 
   <span style="color:#aa5500;">elementData </span> 
  </div> 
  <div> 
   <span style="color:#000000;">而在</span> 
   <span style="color:#000000;">jdk1</span> 
   <span style="color:#333333;">.</span> 
   <span style="color:#116644;">8</span> 
   <span style="color:#000000;">中</span> 
   <span style="color:#333333;">,</span> 
   <span style="color:#000000;">使用使用无参构造方法创建</span> 
   <span style="color:#000000;">ArrayList</span> 
   <span style="color:#000000;">对象时</span> 
   <span style="color:#333333;">, </span> 
   <span style="color:#000000;">底层</span> 
   <span style="color:#000000;">Object</span> 
   <span style="color:#333333;">[]</span> 
   <span style="color:#000000;">的默认长度为</span> 
   <span style="color:#000000;">0</span> 
   <span style="color:#333333;">; </span> 
  </div> 
  <div> 
   <span style="color:#000000;">在第一次添加数据的时候</span> 
   <span style="color:#333333;">,</span> 
   <span style="color:#000000;">底层才创建了长度</span> 
   <span style="color:#000000;">10</span> 
   <span style="color:#000000;">的数组， </span> 
  </div> 
  <div> 
   <span style="color:#000000;">ArrayList list </span> 
   <span style="color:#981a1a;">= </span> 
   <span style="color:#770088;">new </span> 
   <span style="color:#000000;">ArrayList</span> 
   <span style="color:#333333;">();</span> 
   <span style="color:#aa5500;">//</span> 
   <span style="color:#aa5500;">底层</span> 
   <span style="color:#aa5500;">Object[] elementData</span> 
   <span style="color:#aa5500;">初始化为</span> 
   <span style="color:#aa5500;">{}.</span> 
   <span style="color:#aa5500;">并没 </span> 
  </div> 
  <div> 
   <span style="color:#aa5500;">创建长度为</span> 
   <span style="color:#aa5500;">10</span> 
   <span style="color:#aa5500;">的数组 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">ArrayList</span> 
   <span style="color:#000000;">中的扩容操作 </span> 
   <span style="color:#333333;">: </span> 
   <span style="color:#008855;">int </span> 
   <span style="color:#000000;">newCapacity </span> 
   <span style="color:#981a1a;">= </span> 
   <span style="color:#000000;">oldCapacity </span> 
   <span style="color:#981a1a;">+ </span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#000000;">oldCapacity </span> 
   <span style="color:#981a1a;">&gt;&gt; </span> 
   <span style="color:#116644;">1</span> 
   <span style="color:#333333;">); </span> 
  </div> 
  <div> 
   <span style="color:#000000;">默认情况下，扩容为原来的容量的</span> 
   <span style="color:#000000;">1</span> 
   <span style="color:#333333;">.</span> 
   <span style="color:#116644;">5</span> 
   <span style="color:#000000;">倍，同时需要将原有数组中的数据复制到新的数组中</span> 
  </div> 
 </div> 
</blockquote> 
<h4>LinkedList: 双向链表实现-----增删快，查找慢</h4> 
<blockquote> 
 <div> 
  <span style="color:#000000;">LinkedList</span> 
  <span style="color:#000000;">：双向链表，内部没有声明数组，而是定义了</span> 
  <span style="color:#000000;">Node</span> 
  <span style="color:#000000;">类型的</span> 
  <span style="color:#000000;">first</span> 
  <span style="color:#000000;">和</span> 
  <span style="color:#000000;">last</span> 
  <span style="color:#000000;">，用于记录 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">首末元素</span> 
  <span style="color:#333333;">. </span> 
 </div> 
 <div> 
  <span style="color:#000000;">LinkedList </span> 
  <span style="color:#000000;">类中定义了一个结点类</span> 
  <span style="color:#000000;">Node</span> 
  <span style="color:#333333;">;</span> 
  <span style="color:#000000;">用来保存数据和指针域</span> 
  <span style="color:#333333;">; </span> 
 </div> 
</blockquote> 
<h4>Vector：线程安全的，效率低</h4> 
<blockquote> 
 <p>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。 在扩容方面，默认扩容为原来的数组长度的2倍。</p> 
</blockquote> 
<h3>Set接口  </h3> 
<ul><li><span style="color:#333333;"><strong>数据特点</strong></span><span style="color:#333333;"><strong>: </strong></span><strong><span style="color:#333333;">无序 </span><span style="color:#333333;">, </span><span style="color:#333333;">不可重复 </span></strong></li></ul> 
<blockquote> 
 <p><span style="color:#333333;">具体体现: </span></p> 
 <div> 
  <span style="color:#333333;"><strong>1.</strong></span> 
  <span style="color:#333333;"><strong>无序性：指元素存储位置的无序性</strong></span> 
  <span style="color:#333333;"><strong>,</strong></span> 
  <span style="color:#333333;"><strong>不等于随机性。存储的数据在底层数组中并非照数组索引 </strong></span> 
  <span style="color:#333333;"><strong>的顺序添加，而是根据数据的哈希值决定的。 </strong></span> 
 </div> 
 <div> 
  <span style="color:#333333;"><strong>2.</strong></span> 
  <span style="color:#333333;"><strong>不可重复性：相同的元素只能添加一个</strong></span> 
  <span style="color:#333333;"><strong>;</strong></span> 
  <span style="color:#333333;"><strong>比较时调用的方法是</strong></span> 
  <span style="color:#333333;"><strong>equals()</strong></span> 
  <span style="color:#333333;"><strong>方法 </strong></span> 
 </div> 
</blockquote> 
<ul><li> <span style="color:#333333;">主要实现类</span></li></ul> 
<pre><code>/----Set接口 : 元素 无序 且 不可重复; ----&gt;高中"集合"概念 
        /----HashSet : 作为Set接口的主要实现类 ; 线程不安全的 ;可以存储null值 
        /----LinkedHashSet : 作为HashSet的子类; 遍历数据时,可以按照添加的顺序遍历; 在添加数据的同时 , 每个数据还维护了两个引用,记录此数据的前一个数据和后一个数据 (双向链表); 对于频繁遍历的操作,LinkedHashSet的效率比HashSet的效率要高. 
        /TreeSet : 底层采用红黑树实现; 可以按照添加对象的指定属性,进行排序</code></pre> 
<ul><li><span style="color:#fe2c24;"><strong>HashSet 和 LinkedHashSet 底层 都是用 哈希表来实现的 </strong>。</span></li><li> 
  <div> 
   <span style="color:#333333;">常用方法 </span> 
   <span style="color:#333333;">: </span> 
  </div> 
  <div> 
   <span style="color:#333333;">Set</span> 
   <span style="color:#333333;">接口中没额外定义新的方法，使用的都是</span> 
   <span style="color:#333333;">Collection</span> 
   <span style="color:#333333;">中声明过的方法。 </span> 
  </div> </li><li> 
  <div> 
   <div> 
    <span style="color:#333333;">存储对象所在类的要求： </span> 
   </div> 
   <div> 
    <span style="color:#333333;">HashSet/LinkedHashSet: </span> 
   </div> 
   <div> 
    <span style="color:#333333;"><strong>要求：向</strong></span> 
    <span style="color:#333333;"><strong>Set(</strong></span> 
    <span style="color:#333333;"><strong>主要指：</strong></span> 
    <span style="color:#333333;"><strong>HashSet</strong></span> 
    <span style="color:#333333;"><strong>、</strong></span> 
    <span style="color:#333333;"><strong>LinkedHashSet)</strong></span> 
    <span style="color:#333333;"><strong>中添加的数据，其所在的类一定要重写 </strong></span> 
   </div> 
   <div> 
    <span style="color:#333333;"><strong>hashCode()</strong></span> 
    <span style="color:#333333;"><strong>和</strong></span> 
    <span style="color:#333333;"><strong>equals()</strong></span> 
   </div> 
  </div> </li></ul> 
<p> </p> 
<h3><span style="color:#333333;"><strong>双列集合框架</strong></span><span style="color:#333333;"><strong>Map</strong></span> </h3> 
<pre><code>/----Map接口: 双列集合 , 存储具有映射关系的键值对数据(key - value) --类似函数:y=f(x)
    /----HashMap : 作为 Map接口的主要实现类; 线程不安全的 效率高;可以存储 null的key和
value.
        /----LinkedHashMap : 可以按照添加的顺序对集合进行遍历;(原因 : 在原HashMap底层结构基础上,添加了一个双向链表;指向前一个和后一个元素)
    /----TreeMap : 可以对添加的元素进行排序 ;此时考虑 key的自然排序或定制排序(和value无
关)
    /----HashTable : 古老的实现类; 线程安全的,效率低; 不能存储 null的key和value
        /----properties : 常用来处理配置文件. key 和value 都是String 类型的.
</code></pre> 
<h4><span style="color:#333333;">Map</span><span style="color:#333333;">接口常用方法 </span></h4> 
<blockquote> 
 <div> 
  <span style="color:#981a1a;">* </span> 
  <span style="color:#000000;">添加：</span> 
  <span style="color:#000000;">put</span> 
  <span style="color:#333333;">(</span> 
  <span style="color:#008855;">Object </span> 
  <span style="color:#000000;">key</span> 
  <span style="color:#333333;">,</span> 
  <span style="color:#008855;">Object </span> 
  <span style="color:#000000;">value</span> 
  <span style="color:#333333;">) </span> 
 </div> 
 <div> 
  <span style="color:#981a1a;">* </span> 
  <span style="color:#000000;">删除：</span> 
  <span style="color:#000000;">remove</span> 
  <span style="color:#333333;">(</span> 
  <span style="color:#008855;">Object </span> 
  <span style="color:#000000;">key</span> 
  <span style="color:#333333;">) </span> 
 </div> 
 <div> 
  <span style="color:#981a1a;">* </span> 
  <span style="color:#000000;">修改：</span> 
  <span style="color:#000000;">put</span> 
  <span style="color:#333333;">(</span> 
  <span style="color:#008855;">Object </span> 
  <span style="color:#000000;">key</span> 
  <span style="color:#333333;">,</span> 
  <span style="color:#008855;">Object </span> 
  <span style="color:#000000;">value</span> 
  <span style="color:#333333;">) </span> 
 </div> 
 <div> 
  <span style="color:#981a1a;">* </span> 
  <span style="color:#000000;">查询：</span> 
  <span style="color:#000000;">get</span> 
  <span style="color:#333333;">(</span> 
  <span style="color:#008855;">Object </span> 
  <span style="color:#000000;">key</span> 
  <span style="color:#333333;">) </span> 
 </div> 
 <div> 
  <span style="color:#981a1a;">* </span> 
  <span style="color:#000000;">长度：</span> 
  <span style="color:#000000;">size</span> 
  <span style="color:#333333;">() </span> 
 </div> 
 <div> 
  <span style="color:#981a1a;">* </span> 
  <span style="color:#000000;">遍历：</span> 
  <span style="color:#000000;">keySet</span> 
  <span style="color:#333333;">() </span> 
  <span style="color:#981a1a;">/ </span> 
  <span style="color:#000000;">values</span> 
  <span style="color:#333333;">() </span> 
  <span style="color:#981a1a;">/ </span> 
  <span style="color:#000000;">entrySet</span> 
  <span style="color:#333333;">()</span> 
 </div> 
</blockquote> 
<h4>HashMap底层</h4> 
<blockquote> 
 <div> 
  <span style="color:#333333;">HashMap</span> 
  <span style="color:#333333;">是</span> 
  <span style="color:#333333;">Map</span> 
  <span style="color:#333333;">接口的主要实现类</span> 
  <span style="color:#333333;">;</span> 
  <span style="color:#333333;">是线程不安全的</span> 
  <span style="color:#333333;">;</span> 
  <span style="color:#333333;">它存储的是</span> 
  <span style="color:#333333;">key-value</span> 
  <span style="color:#333333;">形式的键值对数据,</span> 
  <span style="color:#333333;">而且允许存储</span> 
  <span style="color:#333333;">null</span> 
  <span style="color:#333333;">的</span> 
  <span style="color:#333333;">key</span> 
  <span style="color:#333333;">和</span> 
  <span style="color:#333333;">value. </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#333333;">hashmap</span> 
  <span style="color:#333333;">的底层结构是哈希表</span> 
  <span style="color:#333333;">;</span> 
  <span style="color:#333333;">也就是数组</span> 
  <span style="color:#333333;">+</span> 
  <span style="color:#333333;">链表</span> 
  <span style="color:#333333;">;</span> 
  <span style="color:#333333;">但在</span> 
  <span style="color:#333333;">jdk1.8</span> 
  <span style="color:#333333;">之后就变成了数 组+</span> 
  <span style="color:#333333;">链表</span> 
  <span style="color:#333333;">+</span> 
  <span style="color:#333333;">红黑树</span> 
  <span style="color:#333333;">;hashmap</span> 
  <span style="color:#333333;">底层数组的默认长度为</span> 
  <span style="color:#333333;">16;</span> 
  <span style="color:#333333;">默认的加载因子为</span> 
  <span style="color:#333333;">0.75; 底层使用一个Node</span> 
  <span style="color:#333333;">内部类来封装</span> 
  <span style="color:#333333;">key-value</span> 
  <span style="color:#333333;">数据</span> 
  <span style="color:#333333;">;node</span> 
  <span style="color:#333333;">实例对象在数组中以单链表的形式存在. </span> 
 </div> 
 <div> 
  <span style="color:#333333;">在</span> 
  <span style="color:#333333;">HashMap</span> 
  <span style="color:#333333;">中，</span> 
  <span style="color:#333333;">hashCode()</span> 
  <span style="color:#333333;">方法决定了对象会被放到哪个</span> 
  <span style="color:#333333;">bucket</span> 
  <span style="color:#333333;">里，当多个 对象的哈希值冲突时，equals()</span> 
  <span style="color:#333333;">方法决定了这些对象是否是</span> 
  <span style="color:#333333;">“</span> 
  <span style="color:#333333;">同一个对象</span> 
  <span style="color:#333333;">”</span> 
  <span style="color:#333333;">。 当我们使用put(key,value)</span> 
  <span style="color:#333333;">方法添加数据时</span> 
  <span style="color:#333333;">,</span> 
  <span style="color:#333333;">首先会对</span> 
  <span style="color:#333333;">key</span> 
  <span style="color:#333333;">进行</span> 
  <span style="color:#333333;">hash</span> 
  <span style="color:#333333;">计算</span> 
  <span style="color:#333333;">,</span> 
  <span style="color:#333333;">得到在数组中的存放位置;</span> 
  <span style="color:#333333;">如果该位置上为空</span> 
  <span style="color:#333333;">,</span> 
  <span style="color:#333333;">那就新建一个</span> 
  <span style="color:#333333;">node</span> 
  <span style="color:#333333;">对象</span> 
  <span style="color:#333333;">,</span> 
  <span style="color:#333333;">保存</span> 
  <span style="color:#333333;">key-value到该数组位置上</span> 
  <span style="color:#333333;">;</span> 
  <span style="color:#333333;">如果计算出来的数组位置上有元素的话</span> 
  <span style="color:#333333;">;</span> 
  <span style="color:#333333;">就沿着此数组位 置对应的单链表上的结点一个个比较，如果遇到相同的key</span> 
  <span style="color:#333333;">，就用新的</span> 
  <span style="color:#333333;">value</span> 
  <span style="color:#333333;">替换掉旧的value</span> 
  <span style="color:#333333;">，如果找不到相同的</span> 
  <span style="color:#333333;">key</span> 
  <span style="color:#333333;">，就新建一个</span> 
  <span style="color:#333333;">node</span> 
  <span style="color:#333333;">结点，保存</span> 
  <span style="color:#333333;">hash值，key</span> 
  <span style="color:#333333;">和</span> 
  <span style="color:#333333;">value</span> 
  <span style="color:#333333;">，然后插入到此单链表的尾部。 插入之后</span> 
  <span style="color:#333333;">,</span> 
  <span style="color:#333333;">如果链表的长度大 于8</span> 
  <span style="color:#333333;">且数组的长度大于</span> 
  <span style="color:#333333;">64,</span> 
  <span style="color:#333333;">那么链表就会转为红黑树</span> 
  <span style="color:#333333;">.</span> 
  <span style="color:#333333;">这样做的目的是为了提高get（</span> 
  <span style="color:#333333;">key</span> 
  <span style="color:#333333;">）的速度。由时间复杂度原来的</span> 
  <span style="color:#333333;">O</span> 
  <span style="color:#333333;">（</span> 
  <span style="color:#333333;">n</span> 
  <span style="color:#333333;">）变成了</span> 
  <span style="color:#333333;">O</span> 
  <span style="color:#333333;">（</span> 
  <span style="color:#333333;">logn</span> 
  <span style="color:#333333;">）</span> 
  <span style="color:#333333;">; </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#333333;">插入数据的时候，如果</span> 
  <span style="color:#333333;">HashMap</span> 
  <span style="color:#333333;">的装载量（全部键值对的个数）超过阈值</span> 
  <span style="color:#333333;">,</span> 
  <span style="color:#333333;">那么 就会调用resize()</span> 
  <span style="color:#333333;">方法进行扩容</span> 
  <span style="color:#333333;">,</span> 
  <span style="color:#333333;">数组长度为原来的两倍</span> 
  <span style="color:#333333;">. </span> 
 </div> 
</blockquote> 
<h4>Collections工具类：操作Collection和Map的工具类 </h4> 
<pre><code class="language-java">reverse(List)：反转 List 中元素的顺序
shuffle(List)：对 List 集合元素进行随机排序
sort(List)：根据元素的自然顺序对指定 List 集合元素升序排序
sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序
swap(List，int i， int j)：将指定 list 集合中的 i 处元素和 j 处元素进行交换
Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素
Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素
Object min(Collection)
Object min(Collection，Comparator)
int frequency(Collection，Object)：返回指定集合中指定元素的出现次数
void copy(List dest,List src)：将src中的内容复制到dest中
boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换List 对象的所有旧值</code></pre> 
<ul><li>ArrayList和HashMap都是线程不安全的，如果程序要求线程安全，我们可以将ArrayList、 HashMap转换为线程安全的。 使用synchronizedList(List list） 和 synchronizedMap(Map map）</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3b29304ddb77e4078a231dfcf7e63720/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NeRF神经辐射场学习笔记（六）— NeRF&#43;&#43;论文要点解读</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e00c0e2ed16018e39f0e262931ae4c0b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DApp简介</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>