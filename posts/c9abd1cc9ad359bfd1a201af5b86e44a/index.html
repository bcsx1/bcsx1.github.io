<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C/C&#43;&#43; Linux Socket网络编程 TCP 与 UDP - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C/C&#43;&#43; Linux Socket网络编程 TCP 与 UDP" />
<meta property="og:description" content="之前已经学习了QT的socket编程 和 C/C&#43;&#43;在window环境的socket编程，现在再来学习一波C/C&#43;&#43;在Linux环境下的socket编程，为以后学习C&#43;&#43; Linux 服务器开发做准备。
目录
一、Socket简介
二、Socket编程基础
1. 网络字节序
2. sockaddr数据结构
3. IP地址转换函数
三、TCP编程函数
1. socket函数
2. bind 函数
3. listen 函数
4. accept 函数
5. connect 函数
6. read 函数
7. write 函数
8. close 函数
四、TCP回声服务器案例
1. 服务器
2. 客户端
3. 运行测试
五、UDP网络编程
1. UDP编程函数
1). sendto
2). recvfrom
3). recv
2. 案例一
3. 案例二，UDP回声服务器
七、TCP分包和粘包问题 六、总结
一、Socket简介 既然是socket，那必然有TCP 和 UDP之分，本文所记录的是TCP协议的socket编程。
socket编程分为TCP和UDP两个模块，其中TCP是可靠的、安全的，常用于发送文件等，而UDP是不可靠的、不安全的，常用作视频通话等。
如下图：
Socket通信3要素：
通信的目的地址；使用的端口号；使用的传输层协议（如TCP、UDP） Socket通信模型" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/c9abd1cc9ad359bfd1a201af5b86e44a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-23T17:44:36+08:00" />
<meta property="article:modified_time" content="2023-11-23T17:44:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C/C&#43;&#43; Linux Socket网络编程 TCP 与 UDP</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>之前已经学习了QT的socket编程 和 C/C++在window环境的socket编程，现在再来学习一波C/C++在Linux环境下的socket编程，为以后学习C++ Linux 服务器开发做准备。</p> 
<p></p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81Socket%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81Socket%E7%AE%80%E4%BB%8B" rel="nofollow">一、Socket简介</a></p> 
<p id="%E4%BA%8C%E3%80%81Socket%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81Socket%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80" rel="nofollow">二、Socket编程基础</a></p> 
<p id="%C2%A01.%20%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%C2%A01.%20%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F" rel="nofollow">1. 网络字节序</a></p> 
<p id="2.%20sockaddr%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#2.%20sockaddr%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">2. sockaddr数据结构</a></p> 
<p id="3.%20IP%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#3.%20IP%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0" rel="nofollow">3. IP地址转换函数</a></p> 
<p id="%E4%B8%89%E3%80%81Socket%E7%BC%96%E7%A8%8B%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81Socket%E7%BC%96%E7%A8%8B%E5%87%BD%E6%95%B0" rel="nofollow">三、TCP编程函数</a></p> 
<p id="1.%20socket%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#1.%20socket%E5%87%BD%E6%95%B0" rel="nofollow">1. socket函数</a></p> 
<p id="2.%C2%A0bind%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#2.%C2%A0bind%20%E5%87%BD%E6%95%B0" rel="nofollow">2. bind 函数</a></p> 
<p id="3.%C2%A0listen%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#3.%C2%A0listen%20%E5%87%BD%E6%95%B0" rel="nofollow">3. listen 函数</a></p> 
<p id="4.%C2%A0accept%C2%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.%C2%A0accept%C2%A0%E5%87%BD%E6%95%B0" rel="nofollow">4. accept 函数</a></p> 
<p id="5.%C2%A0connect%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#5.%C2%A0connect%20%E5%87%BD%E6%95%B0" rel="nofollow">5. connect 函数</a></p> 
<p id="6.%20read%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#6.%20read%20%E5%87%BD%E6%95%B0" rel="nofollow">6. read 函数</a></p> 
<p id="7.%20write%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#7.%20write%20%E5%87%BD%E6%95%B0" rel="nofollow">7. write 函数</a></p> 
<p id="8.%20close%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#8.%20close%20%E5%87%BD%E6%95%B0" rel="nofollow">8. close 函数</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%9B%9E%E5%A3%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%88%E4%BE%8B-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%9B%9E%E5%A3%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%88%E4%BE%8B" rel="nofollow">四、TCP回声服务器案例</a></p> 
<p id="1.%20%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:40px;"><a href="#1.%20%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow">1. 服务器</a></p> 
<p id="2.%20%E5%AE%A2%E6%88%B7%E7%AB%AF-toc" style="margin-left:40px;"><a href="#2.%20%E5%AE%A2%E6%88%B7%E7%AB%AF" rel="nofollow">2. 客户端</a></p> 
<p id="3.%20%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#3.%20%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95" rel="nofollow">3. 运行测试</a></p> 
<p id="%E4%BA%94%E3%80%81UDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81UDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B" rel="nofollow">五、UDP网络编程</a></p> 
<p id="1.%20UDP%E7%BC%96%E7%A8%8B%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#1.%20UDP%E7%BC%96%E7%A8%8B%E5%87%BD%E6%95%B0" rel="nofollow">1. UDP编程函数</a></p> 
<p id="1).%20sendto-toc" style="margin-left:80px;"><a href="#1%29.%20sendto" rel="nofollow">1). sendto</a></p> 
<p id="2).%20recvfrom-toc" style="margin-left:80px;"><a href="#2%29.%20recvfrom" rel="nofollow">2). recvfrom</a></p> 
<p id="3).%20recv-toc" style="margin-left:80px;"><a href="#3%29.%20recv" rel="nofollow">3). recv</a></p> 
<p id="4).%20%E6%A1%88%E4%BE%8B%E4%B8%80-toc" style="margin-left:40px;"><a href="#4%29.%20%E6%A1%88%E4%BE%8B%E4%B8%80" rel="nofollow">2. 案例一</a></p> 
<p id="5).%20%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%8CUDP%E5%9B%9E%E5%A3%B0%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:40px;"><a href="#5%29.%20%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%8CUDP%E5%9B%9E%E5%A3%B0%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow">3. 案例二，UDP回声服务器</a></p> 
<p id="%E4%B8%83%E3%80%81TCP%E5%88%86%E5%8C%85%E5%92%8C%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81TCP%E5%88%86%E5%8C%85%E5%92%8C%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%C2%A0" rel="nofollow">七、TCP分包和粘包问题 </a></p> 
<p id="%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">六、总结</a></p> 
<p></p> 
<hr> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81Socket%E7%AE%80%E4%BB%8B">一、Socket简介</h2> 
<p></p> 
<p>既然是socket，那必然有TCP 和 UDP之分，本文所记录的是TCP协议的socket编程。</p> 
<p>socket编程分为TCP和UDP两个模块，其中TCP是可靠的、安全的，常用于发送文件等，而UDP是不可靠的、不安全的，常用作视频通话等。</p> 
<p><strong>如下图</strong>：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5d/a5/hOY41CSN_o.jpg"></p> 
<p> Socket通信3要素：</p> 
<ol><li>通信的目的地址；</li><li>使用的端口号；</li><li>使用的传输层协议（如TCP、UDP）</li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong>Socket</strong><strong>通信模型</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c9/08/MGcZAI0V_o.png"></p> 
<p><span style="color:#faa572;"> Socket</span>被称之为<span style="color:#faa572;">套接字。</span></p> 
<p>在Linux环境中，Socket编程都是以<span style="color:#ed7976;">伪文件</span>的形式运行着；既然是文件，我们可以使用文件描述符引用套接字。（<span style="background-color:#f3f3f4;">Linux一切皆文件</span>）</p> 
<p style="margin-left:.0001pt;text-align:justify;">Linux系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是文件主要应用于本地持久化数据的读写，而套接字多应用于网络进程间数据的传递。</p> 
<p style="margin-left:.0001pt;text-align:justify;">在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。</p> 
<p style="margin-left:.0001pt;text-align:justify;">套接字通信原理如下图所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4e/96/vn3zJaU4_o.png"></p> 
<p>在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符来发送缓冲区和接收缓冲区。</p> 
<p></p> 
<p><span style="color:#be191c;"><strong><span style="background-color:#cbe0f1;">Socket TCP通信创建流程图</span></strong></span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/77/fe/740Zj0HN_o.png"></p> 
<p></p> 
<hr> 
<h2 id="%E4%BA%8C%E3%80%81Socket%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80">二、Socket编程基础</h2> 
<h3 id="%C2%A01.%20%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F">1. 网络字节序</h3> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;">在计算机世界里，有两种字节序：</p> 
<p style="margin-left:.0001pt;text-align:justify;">        大端字节序 --- 低地址高字节,高地址低字节</p> 
<p style="margin-left:.0001pt;text-align:justify;">        小端字节序 --- 低地址低字节,高地址高字节</p> 
<p><img alt="" src="https://images2.imgbox.com/99/be/iUCArkHG_o.png"></p> 
<p></p> 
<p>内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分，网络数据流同样有大端小端之分。</p> 
<p style="margin-left:.0001pt;text-align:justify;">网络数据流的地址有这样规定：先发出的数据是低地址，后发出的数据是高地址。</p> 
<p style="margin-left:.0001pt;text-align:justify;">TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。</p> 
<p>所以，我们在代码中必须要将ip地址和端口号做相应的转换，转换为网络字节序才可以进行通讯。</p> 
<p style="margin-left:.0001pt;text-align:justify;">大多数使用 htonl 和 htons 。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#be191c;"><strong>为什么需要转换呢？</strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#eaf4fc;">假设本地主机使用的是小端字节序，而对方主机使用的是大端字节序；你发送数据过去的地址顺序是：0x06b3，而对方接受到的却是：0xb306；这样数据就乱了，所以需要进行转换！</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>需要通过以下接口进行转换：</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#ad720d;"><span style="background-color:#d7d8d9;">#include &lt;arpa/inet.h&gt;</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#d7d8d9;">uint32_t <span style="color:#be191c;">htonl</span> (uint32_t hostlong);</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#d7d8d9;">uint16_t <span style="color:#be191c;">htons</span> (uint16_t hostshort);</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#d7d8d9;">uint32_t </span><span style="color:#be191c;"><span style="background-color:#d7d8d9;">ntohl </span></span><span style="background-color:#d7d8d9;">(uint32_t netlong);</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#d7d8d9;">uint16_t <span style="color:#be191c;">ntohs</span> (uint16_t netshort);</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">h表示host，n表示network，l表示32位长整数，s表示16位短整数。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#faa572;">l 结尾的函数用于ip地址转换，s 结尾的函数用于端口号的转换。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<hr> 
<h3 id="2.%20sockaddr%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">2. sockaddr数据结构</h3> 
<p>我们在使用socket中，需要使用结构体sockaddr_in将IP地址和端口号等保存，然后用于绑定socket；</p> 
<p>但进行绑定时，我们却要将结构体sockaddr_in强制类型转换为结构体sockaddr，这是为什么呢？</p> 
<p><img alt="" src="https://images2.imgbox.com/d8/c1/aEOUWNA3_o.png"></p> 
<p>由于历史原因，一开始是没有结构体sockaddr_in，只有结构体sockaddr。</p> 
<p>后来为了适配ipv4的到来，将结构体sockaddr细化为结构体sockaddr_in，如上图。</p> 
<p></p> 
<p>两个结构体如下：</p> 
<pre><code class="language-cpp">struct sockaddr {
	sa_family_t sa_family; 		/* address family, AF_xxx */
	char sa_data[14];			/* 14 bytes of protocol address */
};

struct sockaddr_in {
    sa_family_t    sin_family; /* address family: AF_INET */
    in_port_t      sin_port;   /* port in network byte order */
    struct in_addr sin_addr;   /* internet address */
};

/* Internet address. */
struct in_addr {
    uint32_t       s_addr;     /* address in network byte order */
};
</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">IPv4的地址格式定义在netinet/in.h中，IPv4地址用sockaddr_in结构体表示，包括16位端口号和32位IP地址，但是sock API的实现早于ANSI C标准化，那时还没有void *类型，因此这些像bind 、accept函数的参数都用struct sockaddr *类型表示，在传递参数之前要强制类型转换一下，</p> 
<p style="margin-left:.0001pt;text-align:justify;">例如：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#fbd4d0;">struct sockaddr_in</span><span style="background-color:#d7d8d9;"> servaddr;</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#d7d8d9;">bind(listen_fd, </span><span style="background-color:#fbd4d0;">(struct sockaddr *)</span><span style="background-color:#d7d8d9;">&amp;servaddr, sizeof(servaddr));        /* initialize servaddr */</span></p> 
<p></p> 
<hr> 
<h3 id="3.%20IP%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0">3. IP地址转换函数</h3> 
<p>上面<strong>网络字节序</strong>中我们使用了htonl 和 ntohl 两个函数进行ip地址的转换，但只能将<span style="background-color:#d7d8d9;">uint32_t</span>类型的地址进行转换，例如：INADDR_ANY ==&gt; 0.0.0.0</p> 
<p>但是实际项目中我们设置ip地址大多数都是字符串，所以得使用特定的函数去进行转换。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ad720d;"><strong><span style="background-color:#d7d8d9;">#include &lt;arpa/inet.h&gt;</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#d7d8d9;">int <span style="color:#be191c;">inet_pton</span> (int af, const char *src, void *dst);</span>        // “本地ip转换为网络ip”</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#d7d8d9;">const char *<span style="color:#be191c;">inet_ntop</span> (int af, const void *src, char *dst, socklen_t size);</span>        // “网络ip转换为本地ip”</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">af</span></strong></span> 取值可选为 AF_INET 和 AF_INET6 ，即和 ipv4 和ipv6对应支持IPv4和IPv6；</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">src</span></strong></span> 是转换前ip，<strong><span style="color:#b95514;"><span style="background-color:#c7e6ea;">dst</span></span> </strong>是转换后ip；</p> 
<p style="margin-left:.0001pt;text-align:justify;">其中inet_pton和inet_ntop不仅可以转换IPv4的in_addr，还可以转换IPv6的in6_addr。</p> 
<p><strong>例</strong>：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;arpa/inet.h&gt;

int main(int argc, char *argv[]) {
	
	char ip[] = "6.7.8.9";
	char server_ip[64];
	
	struct sockaddr_in server_addr;
	
	inet_pton(AF_INET, ip, &amp;server_addr.sin_addr.s_addr);
	
	printf("s_addr : %x\n", server_addr.sin_addr.s_addr);
	
	printf("s_addr from net to host : %x \n", ntohl(server_addr.sin_addr.s_addr));
	
	inet_ntop(AF_INET, &amp;server_addr.sin_addr.s_addr, server_ip, sizeof(server_ip));
	
	printf("server_ip : %s \n", server_ip);
	
	printf("INADDR_ANY: %d \n", INADDR_ANY);
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	inet_ntop(AF_INET, &amp;server_addr.sin_addr.s_addr, server_ip, sizeof(server_ip));
	printf("INADDR_ANY ip : %s\n", server_ip);
	
	return 0;
}</code></pre> 
<p> 运行结果：</p> 
<pre><code class="language-cpp">s_addr : 9080706
s_addr from net to host : 6070809
server_ip : 6.7.8.9
INADDR_ANY: 0
INADDR_ANY ip : 0.0.0.0</code></pre> 
<p>ip地址：6.7.8.9</p> 
<p>因为网络上使用的是大端字节序，所以通过inet_pton函数转换后的ip地址输出为：9080706</p> 
<p>当通过ntohl函数转换回主机ip地址后输出为：6070809</p> 
<p>因为我的本地主机使用的是小段字节序，所以转换后的循序和ip地址顺序一致，大端字节序则反过来了；</p> 
<p>如果需要将网络的ip地址转换为字符串，则需要使用inet_ntop函数；</p> 
<p>如果需要将字符串ip地址转换为网络ip地址，则需要使用inet_pton函数。</p> 
<p></p> 
<p>在服务器中，如果有多个网络，一般我们都会绑定所有网卡，会进行如下设置：</p> 
<pre><code class="language-cpp">server_addr.sin_addr.s_addr = htonl(INADDR_ANY);	// 监听本地所有IP地址</code></pre> 
<p>INADDR_ANY是一个宏，即为0的宏，他转换后赋值给结构体实际上是：0.0.0.0这个ip地址。</p> 
<p></p> 
<hr> 
<h2 id="%E4%B8%89%E3%80%81Socket%E7%BC%96%E7%A8%8B%E5%87%BD%E6%95%B0">三、TCP编程函数</h2> 
<p></p> 
<h3 id="1.%20socket%E5%87%BD%E6%95%B0">1. socket函数</h3> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#d7d8d9;"><strong><span style="color:#ad720d;">#include &lt;sys/types.h&gt;</span></strong> /* See NOTES */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ad720d;"><strong><span style="background-color:#d7d8d9;">#include &lt;sys/socket.h&gt;</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#d7d8d9;">int <span style="color:#be191c;">socket </span>(int domain, int type, int protocol);</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#b95514;"><strong><span style="background-color:#cbe0f1;">domain:</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#1a439c;">AF_INET</span> 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址。</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#1a439c;">AF_INET6</span> 与上面类似，不过是来用IPv6的地址。</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#1a439c;">AF_UNIX </span>本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#b95514;"><span style="background-color:#c7e6ea;">type:</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#1a439c;">SOCK_STREAM</span> 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#1a439c;">SOCK_DGRAM</span> 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#1a439c;">SOCK_SEQPACKET </span>该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#1a439c;">SOCK_RAW </span>socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#1a439c;">SOCK_RDM</span> 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">protocol:</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">    传 <span style="color:#be191c;">0</span> 表示使用默认协议。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#b95514;"><span style="background-color:#c7e6ea;">返回值：</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="background-color:#e0e0e0;">成功：</span>返回指向新创建的socket的文件描述符，<span style="background-color:#e0e0e0;">失败：</span>返回 <span style="color:#be191c;">-1</span>，<span style="background-color:#e0e0e0;">设置errno</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">可以使用以下方式进行打印输出失败报错信息：</p> 
<pre><code class="language-cpp">fprintf(stderr, " errno：%s\n", strerror(errno));</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">socket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据，如果socket()调用出错则返回-1。</p> 
<p style="margin-left:.0001pt;text-align:justify;">对于IPv4，domain 参数指定为AF_INET。</p> 
<p style="margin-left:.0001pt;text-align:justify;">对于TCP协议，type 参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。</p> 
<p style="margin-left:.0001pt;text-align:justify;">protocol 参数的介绍 - 略，指定为0即可。</p> 
<p><strong>例：</strong></p> 
<pre><code class="language-cpp">int sock;
sock = socket(AF_INET, SOCK_STREAM, 0);</code></pre> 
<p></p> 
<h3 id="2.%C2%A0bind%20%E5%87%BD%E6%95%B0">2. bind 函数</h3> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#e0e0e0;"><strong><span style="color:#ad720d;">#include &lt;sys/types.h&gt; </span></strong>/* See NOTES */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ad720d;"><strong><span style="background-color:#e0e0e0;">#include &lt;sys/socket.h&gt;</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#e0e0e0;">int <span style="color:#be191c;">bind </span>(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#b95514;"><span style="background-color:#c7e6ea;">sockfd：</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">    socket文件描述符</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">addr:</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">    构造出IP地址加端口号的结构体</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">addrlen:</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">    sizeof(addr)长度</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">返回值：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="background-color:#d7d8d9;">成功</span> 返回 <span style="color:#be191c;">0</span>，<span style="background-color:#d7d8d9;">失败</span> 返回 <span style="color:#be191c;">-1</span>, <span style="background-color:#d7d8d9;">设置 errno</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"> 可以使用以下方式进行打印输出失败报错信息：</p> 
<pre><code class="language-cpp">fprintf(stderr, " errno：%s\n", strerror(errno));</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">    服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。</p> 
<p>bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。</p> 
<p><strong>例：</strong></p> 
<pre><code class="language-cpp">struct sockaddr_in servaddr;            // 定义结构体
bzero(&amp;servaddr, sizeof(servaddr));     // 将整个结构体清零

// 设置地址类型为AF_INET（IPv4）
servaddr.sin_family = AF_INET;          

/* 网络地址为INADDR_ANY，这个宏表示本地的任意IP地址，因为服务器可能有多个网卡，
   每个网卡也可能绑定多个IP地址，这样设置可以在所有的IP地址上监听，
   直到与某个客户端建立了连接时才确定下来到底用哪个IP地址. */
servaddr.sin_addr.s_addr = htonl(INADDR_ANY);

// 设置端口号为5000
servaddr.sin_port = htons(5000);

// 绑定
bind(sock, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));</code></pre> 
<p></p> 
<h3 id="3.%C2%A0listen%20%E5%87%BD%E6%95%B0">3. listen 函数</h3> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#e0e0e0;"><span style="color:#ad720d;"><strong>#include &lt;sys/types.h&gt; </strong></span>/* See NOTES */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ad720d;"><strong><span style="background-color:#e0e0e0;">#include &lt;sys/socket.h&gt;</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#e0e0e0;">int <span style="color:#be191c;">listen</span> (int sockfd, int backlog);</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">sockfd:</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">    socket 文件描述符</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">backlog:</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">    在Linux 系统中，它是指排队等待建立3次握手队列长度。（客户端同时进行连接服务器的个数）</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">返回值：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="background-color:#d7d8d9;">成功</span> 返回 <span style="color:#be191c;">0</span>，<span style="background-color:#d7d8d9;">失败</span> 返回 <span style="color:#be191c;">-1</span>, <span style="background-color:#d7d8d9;">设置 errno</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"> 可以使用以下方式进行打印输出失败报错信息：</p> 
<pre><code class="language-cpp">fprintf(stderr, " errno：%s\n", strerror(errno));</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#be191c;"><strong>查看</strong></span>一下系统默认backlog</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#e0e0e0;">cat /proc/sys/net/ipv4/tcp_max_syn_backlog</span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2e/c6/ijhMdr4q_o.jpg"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#be191c;"><strong>改变</strong></span> 系统限制的backlog 大小</p> 
<p style="margin-left:.0001pt;text-align:justify;">1. 打开文件</p> 
<p style="margin-left:.0001pt;text-align:justify;">        <span style="background-color:#e0e0e0;">vim /etc/sysctl.conf</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><br> 2. 在文件<span style="background-color:#e0e0e0;">最后添加</span><br>         <span style="background-color:#e0e0e0;">net.core.somaxconn = 1024</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">        <span style="background-color:#e0e0e0;">net.ipv4.tcp_max_syn_backlog = 1024</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><br> 3. 保存，然后执行<br>         <span style="background-color:#e0e0e0;">sysctl -p</span></p> 
<p>如下图：(修改系统默认backlog为1024)</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f7/ba/FTOZmcY1_o.jpg"></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/f7/48/De2eJNEU_o.png"></p> 
<p> <span style="color:#be191c;"><strong>为什么要修改呢？</strong></span>如果不修改，即使我们在代码里设置10240（<span style="background-color:#cccccc;">listen(sock, 10240);</span>），它也还是按照系统默认的值来设置的！</p> 
<p></p> 
<p>典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。</p> 
<p></p> 
<p><strong>例：</strong></p> 
<pre><code class="language-cpp">// 监听，同时监听128个请求
listen(sock, 128);</code></pre> 
<p></p> 
<h3 id="4.%C2%A0accept%C2%A0%E5%87%BD%E6%95%B0">4. accept 函数</h3> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#d7d8d9;"><strong><span style="color:#ad720d;">#include &lt;sys/types.h&gt;</span></strong>      /* See NOTES */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ad720d;"><strong><span style="background-color:#d7d8d9;">#include &lt;sys/socket.h&gt;</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#d7d8d9;">int <span style="color:#b95514;">accept </span>(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">sockdf:</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">    socket文件描述符</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">addr:</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">    传出参数，返回连接客户端地址信息，含IP地址和端口号</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#b95514;"><span style="background-color:#c7e6ea;">addrlen:</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">    传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">返回值：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">    <span style="color:#be191c;">成功返回一个新的socket文件描述符，用于和客户端通信</span>，失败返回 <span style="color:#be191c;">-1</span>，设置errno</p> 
<p style="margin-left:.0001pt;text-align:justify;"> 可以使用以下方式进行打印输出失败报错信息：</p> 
<pre><code class="language-cpp">fprintf(stderr, " errno：%s\n", strerror(errno));</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">三次握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。</p> 
<p style="margin-left:.0001pt;text-align:justify;">addr 是一个传出参数，accept()返回时传出客户端的地址和端口号；如果给addr参数传NULL，表示不关心客户端的地址。</p> 
<p style="margin-left:.0001pt;text-align:justify;">addrlen 参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。</p> 
<p><strong>例：</strong></p> 
<pre><code class="language-cpp">struct sockaddr_in client;
int client_sock;
		
socklen_t client_addr_len;		
client_addr_len = sizeof(client);
// 接受
client_sock = accept(sock, (struct sockaddr *)&amp;client, &amp;client_addr_len);</code></pre> 
<p></p> 
<h3 id="5.%C2%A0connect%20%E5%87%BD%E6%95%B0">5. connect 函数</h3> 
<p>客户端使用！</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#d7d8d9;"><span style="color:#ad720d;"><strong>#include &lt;sys/types.h&gt; </strong></span>                /* See NOTES */</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ad720d;"><strong><span style="background-color:#d7d8d9;">#include &lt;sys/socket.h&gt;</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#d7d8d9;">int <span style="color:#be191c;">connect </span>(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">sockdf:</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">    socket文件描述符</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">addr:</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">    传入参数，指定服务器端地址信息，含IP地址和端口号</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">addrlen:</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">    传入参数,传入sizeof(addr)大小</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">返回值：</span></strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">   </p> 
<p style="margin-left:.0001pt;text-align:justify;">  <span style="background-color:#d7d8d9;">成功</span> 返回 <span style="color:#be191c;">0</span>，<span style="background-color:#d7d8d9;">失败</span> 返回 <span style="color:#be191c;">-1</span>, <span style="background-color:#d7d8d9;">设置 errno</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"> 可以使用以下方式进行打印输出失败报错信息：</p> 
<pre><code class="language-cpp">fprintf(stderr, " errno：%s\n", strerror(errno));</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">客户端需要调用connect()连接服务器，connect和bind的参数形式一致，区别在于bind的参数是自己的地址，而connect的参数是对方的地址。</p> 
<p></p> 
<p><strong>例：</strong></p> 
<pre><code class="language-cpp">int sockfd = 0;
struct sockaddr_in serveraddr;

sockfd = socket(AF_INET, SOCK_STREAM, 0);

serveraddr.sin_family = AF_INET;
inet_pton(AF_INET, "127.0.0.1", &amp;serveraddr.sin_addr);
serveraddr.sin_port = htons(5000);

// 连接服务器
connect(sockfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr));</code></pre> 
<p></p> 
<h3 id="6.%20read%20%E5%87%BD%E6%95%B0">6. read 函数</h3> 
<p><span style="color:#ad720d;"><strong><span style="background-color:#d7d8d9;">#include &lt;unistd.h&gt;</span></strong></span></p> 
<p><span style="background-color:#d7d8d9;">ssize_t <span style="color:#be191c;">read </span>(int fd, void *buf, size_t count);</span><br>  </p> 
<p><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">fd:</span></strong></span></p> 
<p>    socket文件描述符；</p> 
<p><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">buf:</span></strong></span></p> 
<p>    存储读取到的数据，一般传char *类型或字符数组；</p> 
<p><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">count：</span></strong></span></p> 
<p>    指定最多读取的大小。</p> 
<p><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">返回值：</span></strong></span></p> 
<p>    读取成功返回读取到的字节数，读取失败返回 <span style="color:#be191c;">-1</span>，设置errno</p> 
<p style="margin-left:.0001pt;text-align:justify;"> 可以使用以下方式进行打印输出失败报错信息：</p> 
<pre><code class="language-cpp">fprintf(stderr, " errno：%s\n", strerror(errno));</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">从socket文件符中，读取count指定的大小以内的数据存储到buf中。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>例：</strong></p> 
<pre><code class="language-cpp">int client_sock;
char buf[256];
// 对client_sock的赋值这里省略...

len = read(client_sock, buf, sizeof(buf)-1);</code></pre> 
<p></p> 
<h3 id="7.%20write%20%E5%87%BD%E6%95%B0">7. write 函数</h3> 
<p><span style="color:#ad720d;"><strong><span style="background-color:#d7d8d9;">#include &lt;unistd.h&gt;</span></strong></span></p> 
<p><span style="background-color:#d7d8d9;">ssize_t <span style="color:#be191c;">write </span>(int fd, const void *buf, size_t count);</span></p> 
<p><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">fd:</span></strong></span></p> 
<p>    socket文件描述符；</p> 
<p><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">buf:</span></strong></span></p> 
<p>    需要发送(写入)的数据；</p> 
<p><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">count：</span></strong></span></p> 
<p>    指定最多发送(写入)的大小。</p> 
<p><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">返回值：</span></strong></span></p> 
<p>    发送(写入)成功返回写入的字节数，发送(写入)失败返回 <span style="color:#be191c;">-1</span>，设置errno</p> 
<p style="margin-left:.0001pt;text-align:justify;"> 可以使用以下方式进行打印输出失败报错信息：</p> 
<pre><code class="language-cpp">fprintf(stderr, " errno：%s\n", strerror(errno));</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>例：</strong></p> 
<pre><code class="language-cpp">int client_sock;
char buf[256];
// 对client_sock的赋值这里省略...

len = write(client_sock, buf, sizeof(buf)-1);</code></pre> 
<p></p> 
<h3 id="8.%20close%20%E5%87%BD%E6%95%B0">8. close 函数</h3> 
<p><span style="color:#ad720d;"><strong><span style="background-color:#d7d8d9;">#include &lt;unistd.h&gt;</span></strong></span></p> 
<p><span style="background-color:#d7d8d9;">int <span style="color:#be191c;">close </span>(int fd);</span></p> 
<p><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">fd:</span></strong></span></p> 
<p>    socket文件描述符；</p> 
<p><span style="color:#b95514;"><strong><span style="background-color:#c7e6ea;">返回值：</span></strong></span></p> 
<p>    成功返回 <span style="color:#be191c;">0</span>，失败返回 <span style="color:#be191c;">-1</span>，并适当设置errno。</p> 
<p style="margin-left:.0001pt;text-align:justify;"> 可以使用以下方式进行打印输出失败报错信息：</p> 
<pre><code class="language-cpp">fprintf(stderr, " errno：%s\n", strerror(errno));</code></pre> 
<p>close()关闭一个文件描述符。</p> 
<p></p> 
<p><strong>例：</strong></p> 
<pre><code class="language-cpp">int client_sock;
// client_sock= socket(AF_INET, SOCK_STREAM, 0);

close(client_sock);</code></pre> 
<p></p> 
<hr> 
<h2 id="%E5%9B%9B%E3%80%81%E5%9B%9E%E5%A3%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%88%E4%BE%8B">四、TCP回声服务器案例</h2> 
<p>描述：</p> 
<p>客户端连接服务器，给服务器发送“hello world！”，服务器接收到后，将信息打印输出后，原封不动的给客户端发送回去，客户端接收到到后，也就数据打印输出，程序结束。</p> 
<p></p> 
<h3 id="1.%20%E6%9C%8D%E5%8A%A1%E5%99%A8">1. 服务器</h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;string.h&gt;        // strerror
#include &lt;ctype.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;

#define SERVER_PORT 5000


int main(void) {
	
	int ret = 0;
	int sock;	// 通信套接字
	struct sockaddr_in server_addr;
	
	// 1.创建通信套接字
	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (-1 == sock) {
		fprintf(stderr, "create socket error, reason: %s\n", strerror(errno));
		exit(-1);
	}
	
	// 2.清空标签，写上地址和端口号
	bzero(&amp;server_addr, sizeof(server_addr));
	
	server_addr.sin_family = AF_INET;	// 选择协议组ipv4
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);	// 监听本地所有IP地址
	server_addr.sin_port = htons(SERVER_PORT);			// 绑定端口号
	
	// 3.绑定
	ret = bind(sock, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));
	if (-1 == ret) {
		fprintf(stderr, "socket bind error, reason: %s\n", strerror(errno));
		close(sock);
		exit(-2);
	}
	
	// 4.监听，同时监听128个请求
	ret = listen(sock, 128);
	if (-1 == ret) {
		fprintf(stderr, "listen error, reason: %s\n", strerror(errno));
		close(sock);
		exit(-2);
	}
	
	printf("等待客户端的链接\n");
	
	int done = 1;
	
	while (done) {
		
		struct sockaddr_in client;
		int client_sock;
		char client_ip[64];
		int len = 0;
		char buf[256];
		
		socklen_t client_addr_len;		
		client_addr_len = sizeof(client);
		// 5.接受
		client_sock = accept(sock, (struct sockaddr *)&amp;client, &amp;client_addr_len);
		if (-1 == client_sock) {
			perror("accept error");
			close(sock);
			exit(-3);
		}
		
		// 打印客户端IP地址和端口号
		printf("client ip: %s\t port: %d\n",
				inet_ntop(AF_INET, &amp;client.sin_addr.s_addr, client_ip, sizeof(client_ip)),
				ntohs(client.sin_port));
		
		
		// 6.读取客户端发送的数据
		len = read(client_sock, buf, sizeof(buf)-1);
		if (-1 == len) {
			perror("read error");
			close(sock);
			close(client_sock);
			exit(-4);
		}
		
		buf[len] = '\0';
		printf("recive[%d]: %s\n", len, buf);
		
		// 7.给客户端发送数据
		len = write(client_sock, buf, len);
		if (-1 == len) {
			perror("write error");
			close(sock);
			close(client_sock);
			exit(-5);
		}
		
		printf("write finished. len: %d\n", len);
		// 8.关闭客户端套接字
		close(client_sock);
	}
	
	// 9.关闭服务器套接字
	close(sock);
	
	return 0;
}</code></pre> 
<p></p> 
<h3 id="2.%20%E5%AE%A2%E6%88%B7%E7%AB%AF">2. 客户端</h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;errno.h&gt;



#define SERVER_PORT		5000
#define SERVER_IP		"127.0.0.1"


int main(int argc, char *argv[]) {
	
	int ret = 0;
	int sockfd = 0;			// 通信套接字
	char *message = NULL;
	struct sockaddr_in serveraddr;
	int n = 0;
	char buff[64];
	
	if (2 != argc) {	
		fprintf(stderr, "Usage: ./echo_client message \n");
		exit(1);
	}
	
	// 获取第二个参数的字符串
	message = argv[1];
	printf("message: %s\n", message);
	
		// 1.创建通信套接字
	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (-1 == sockfd) {
		perror("create sockfd error");
		exit(-1);
	}
	
	// 2.清空标签，写上地址和端口号
	bzero(&amp;serveraddr, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;							// IPv4
	inet_pton(AF_INET, SERVER_IP, &amp;serveraddr.sin_addr);		// 服务器地址
	serveraddr.sin_port = htons(SERVER_PORT);					// 服务器端口号
	
	// 3.连接服务器
	ret = connect(sockfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr));
	if (-1 == ret) {
		perror("connect error");
		close(sockfd);
		exit(-2);
	}
	
	// 4.给服务器发送数据
	ret = write(sockfd, message, strlen(message));
	if (-1 == ret) {
		perror("write error");
		close(sockfd);
		exit(-3);
	}
	
	// 5.接受服务器发送过来的数据
	n = read(sockfd, buff, sizeof(buff)-1);
	if (-1 == n) {
		perror("read error");
		close(sockfd);
		exit(-4);
	}
	
	if (n &gt; 0) {
		buff[n] = '\0';
		printf("receive: %s\n", buff);
	} else {
		perror("error!!!\n");
	}
	
	printf("client finished.\n");
	// 6.关闭套接字
	close(sockfd);
	
	return 0;
}</code></pre> 
<p></p> 
<h3 id="3.%20%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95">3. 运行测试</h3> 
<p>1. 服务器</p> 
<pre><code class="language-cpp">ygt@YGT:~/echo_server$ gcc echo_server.c -o echo_server
ygt@YGT:~/echo_server$ ./echo_server
等待客户端的链接
client ip: 127.0.0.1     port: 41168
recive[12]: hello world!
write finished. len: 12
</code></pre> 
<p>这里打印客户端的IP地址是127.0.0.1，是因为我是在同一台Linux系统中进行测试的，所以打印的是这个本地地址。</p> 
<p>2. 客户端</p> 
<pre><code class="language-cpp">root@YGT:/home/ygt/echo_server# gcc echo_client.c -o echo_client
root@YGT:/home/ygt/echo_server# ./echo_client "hello world!"
message: hello world!
receive: hello world!
client finished.</code></pre> 
<p>再来测试一下，在Linux中运行服务器程序，然后再window环境使用cmd控制台敲命令telnet去连接服务器。</p> 
<p>才cmd中，telnet 后面接 服务器的ip地址 和 端口号</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/07/b8/dyftufFj_o.jpg"></p> 
<p> 当按下回车键后，就连接上服务器了，服务器也接受到了客户端的IP地址和端口号，并将其打印出来；然后客户端将字符 ‘h’ 发送给了服务器，服务器接收到后将其打印出来，然后给客户端也发送字符 'h'，但是我们在cmd上是没有接收功能的，所以就没有接收到服务器发送过来的消息；最后服务器发送完成后就close断开了和客户端的连接，cmd这边就提示“遗失对主机的连接”。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/24/18/w80UEwFe_o.jpg"></p> 
<p></p> 
<hr> 
<p></p> 
<h2 id="%E4%BA%94%E3%80%81UDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">五、UDP网络编程</h2> 
<p>2023年3月9日15:11分新增 .</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>1. TCP与UDP</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">    当使用网络套接字通信时，</p> 
<p style="margin-left:.0001pt;text-align:justify;">    套接字的“域”都取AF_INET;</p> 
<p style="margin-left:.0001pt;text-align:justify;">    套接字的type：</p> 
<p style="margin-left:.0001pt;text-align:justify;">          SOCK_STREAM   此时，默认使用TCP协议进行通信。</p> 
<p style="margin-left:.0001pt;text-align:justify;">          SOCK_DGRAM    此时，默认使用UDP协议进行通信。</p> 
<p style="margin-left:.0001pt;text-align:justify;">   </p> 
<p style="margin-left:.0001pt;text-align:justify;">    TCP通信，是一个有序的、可靠的、面向连接的</p> 
<p style="margin-left:.0001pt;text-align:justify;">    UDP通信，是不保证有序到达的数据报服务。（在局域网内，使用UDP已很可靠）</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>2. 使用UDP通信</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">    与TCP通信使用上的区别：</p> 
<p style="margin-left:.0001pt;text-align:justify;">    1）创建套接字时的type(参数2）不同。</p> 
<p style="margin-left:.0001pt;text-align:justify;">         TCP通信，使用SOCK_STREAM</p> 
<p style="margin-left:.0001pt;text-align:justify;">         UDP通信，使用SOCK_DGRAM</p> 
<p style="margin-left:.0001pt;text-align:justify;">   </p> 
<p style="margin-left:.0001pt;text-align:justify;">    2）发送数据和接收数据时，使用的接口不同</p> 
<p style="margin-left:.0001pt;text-align:justify;">         TCP通信，发送数据，使用write（或send）</p> 
<p style="margin-left:.0001pt;text-align:justify;">                       接收数据，使用read（或recv）</p> 
<p style="margin-left:.0001pt;text-align:justify;">         UDP特性，发送数据，使用sendto     </p> 
<p style="margin-left:.0001pt;text-align:justify;">                  接收数据，服务器端使用recvfrom  </p> 
<p style="margin-left:.0001pt;text-align:justify;">                             客户端使用recv</p> 
<p style="margin-left:.0001pt;text-align:justify;">                      </p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>   3）不需要使用listen</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>   4）不需要先建立连接(TCP客户端和服务器端分别使用connect和receive建立连接)</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">  </p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>步骤总结：</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">             基于UDP的网络套接字通信</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>        a. 服务器端</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">                (1) 创建一个网络套接字</p> 
<p style="margin-left:.0001pt;text-align:justify;">                (2) 设置服务器地址</p> 
<p style="margin-left:.0001pt;text-align:justify;">                (3) 绑定该套接字，使得该套接字和对应的端口关联起来    </p> 
<p style="margin-left:.0001pt;text-align:justify;">                (4) 循环处理客户端请求</p> 
<p style="margin-left:.0001pt;text-align:justify;">                      使用recvfrom等待接收客户端发送的数据</p> 
<p style="margin-left:.0001pt;text-align:justify;">                      使用sendto发送数据至客户端</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>        b. 客户端</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">               (1) 创建一个套接字</p> 
<p style="margin-left:.0001pt;text-align:justify;">               (2) 设置服务器地址</p> 
<p style="margin-left:.0001pt;text-align:justify;">               (3) 使用sendto向服务器端（接收端）发送数据</p> 
<p style="margin-left:.0001pt;text-align:justify;">               (4) 使用recv接受数据</p> 
<p></p> 
<p><strong>UDP通讯流程图 </strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/96/54/kqwv0PXh_o.png"></p> 
<p></p> 
<h3 id="1.%20UDP%E7%BC%96%E7%A8%8B%E5%87%BD%E6%95%B0">1. UDP编程函数</h3> 
<h4 id="1).%20sendto">1). sendto</h4> 
<p><span style="color:#ad720d;"><strong>#include &lt;sys/types.h&gt;<br> #include &lt;sys/socket.h&gt;</strong></span></p> 
<p><span style="background-color:#f3f3f4;"><span style="color:#511b78;">ssize_t </span><span style="color:#be191c;">sendto</span>(<span style="color:#1a439c;">int </span><span style="color:#b95514;">sockfd</span>, <span style="color:#1a439c;">const void *</span><span style="color:#b95514;">buf</span>, <span style="color:#1a439c;">size_t</span> <span style="color:#b95514;">len</span>, <span style="color:#1a439c;">int </span><span style="color:#b95514;">flags</span>,  <span style="color:#1a439c;">const struct sockaddr *</span><span style="color:#b95514;">dest_addr</span>, <span style="color:#1a439c;">socklen_t </span><span style="color:#b95514;">addrlen</span>);</span></p> 
<p><span style="color:#1c7892;">描述：</span><span style="color:#0d0016;">UDP服务器或者客户端用法发送数据；</span></p> 
<p><span style="color:#be191c;"><strong>参数</strong></span></p> 
<p>        <span style="color:#b95514;">sockfd</span></p> 
<p>                套接字；</p> 
<p>        <span style="color:#b95514;">buf</span></p> 
<p>                发送缓冲区，即要发送的数据；</p> 
<p>        <span style="color:#b95514;">len</span></p> 
<p>                发送缓冲区的长度；</p> 
<p>        <span style="color:#b95514;">flags</span></p> 
<p>                标志，一般取0；</p> 
<p>        <span style="color:#b95514;">dest_addr</span></p> 
<p>                目标主机地址；</p> 
<p>        <span style="color:#b95514;">addrlen</span></p> 
<p>                目标主机地址长度；</p> 
<p><span style="color:#1c7331;"><strong>返回值</strong></span></p> 
<p>       <span style="color:#fe2c24;"> 成功：</span>返回实际发送数据的字节数；</p> 
<p>       <span style="color:#fe2c24;"> 失败：</span>返回-1，并设置错误标志errno；</p> 
<p></p> 
<h4 id="2).%20recvfrom">2). recvfrom</h4> 
<p><span style="color:#ad720d;"><strong>#include &lt;sys/types.h&gt;<br> #include &lt;sys/socket.h&gt;</strong></span></p> 
<p><span style="background-color:#f3f3f4;"><span style="color:#511b78;">ssize_t </span><span style="color:#be191c;">recvfrom</span>(<span style="color:#1a439c;">int </span><span style="color:#b95514;">sockfd</span>, <span style="color:#1a439c;">void *</span><span style="color:#b95514;">buf</span>, <span style="color:#1a439c;">size_t </span><span style="color:#b95514;">len</span>, <span style="color:#1a439c;">int </span><span style="color:#b95514;">flags</span>, <span style="color:#1a439c;">struct sockaddr *</span><span style="color:#b95514;">src_addr</span>, <span style="color:#1a439c;">socklen_t </span>*<span style="color:#b95514;">addrlen</span>);</span></p> 
<p><span style="color:#1c7892;">描述：</span><span style="color:#0d0016;">UDP服务器用于接收数据；</span></p> 
<p><span style="color:#be191c;"><strong>参数</strong></span></p> 
<p>        <span style="color:#b95514;">sockfd</span></p> 
<p>                套接字</p> 
<p><span style="color:#b95514;">        buf</span></p> 
<p>                接收缓冲区；</p> 
<p>        <span style="color:#b95514;">len</span></p> 
<p>                接收缓冲区的长度；</p> 
<p>        <span style="color:#b95514;">flags</span></p> 
<p>                标志，一般取0；</p> 
<p>        <span style="color:#b95514;">src_addr</span></p> 
<p>                源主机地址；</p> 
<p>        <span style="color:#b95514;">addrlen</span></p> 
<p>                源主机地址长度；</p> 
<p><span style="color:#fe2c24;">注意：参数6必须要初始化为对应地址的长度！</span></p> 
<p><span style="color:#1c7331;"><strong>返回值</strong></span></p> 
<p>      <span style="color:#fe2c24;">  成功：</span>返回实际接收到的字节数；</p> 
<p>       <span style="color:#fe2c24;"> 失败：</span>返回-1，并设置错误标志；</p> 
<p></p> 
<h4 id="3).%20recv">3). recv</h4> 
<p><span style="color:#ad720d;"><strong>#include &lt;sys/types.h&gt;<br> #include &lt;sys/socket.h&gt;</strong></span></p> 
<p><span style="background-color:#f3f3f4;"><span style="color:#511b78;">ssize_t </span><span style="color:#be191c;">recv</span>(<span style="color:#1a439c;">int </span><span style="color:#b95514;">sockfd</span>, <span style="color:#1a439c;">void *</span><span style="color:#b95514;">buf</span>, <span style="color:#1a439c;">size_t </span><span style="color:#b95514;">len</span>, <span style="color:#1a439c;">int </span><span style="color:#b95514;">flags</span>);</span></p> 
<p><span style="color:#1c7892;">描述：</span><span style="color:#0d0016;">UDP客户端用于接收数据；</span></p> 
<p><span style="color:#be191c;"><strong>参数</strong></span></p> 
<p>        <span style="color:#b95514;">sockfd</span></p> 
<p>                套接字；</p> 
<p><span style="color:#b95514;">        buf</span></p> 
<p>                接收缓冲区；</p> 
<p>        <span style="color:#b95514;">len</span></p> 
<p>                接收缓冲区的长度；</p> 
<p>        <span style="color:#b95514;">flags</span></p> 
<p>                标志，一般取0；</p> 
<p>注意：该调用的参数不需要指定地址；因为当使用udp时，对应的套接字被自动绑定在一个短暂的动态的端口上。</p> 
<p><span style="color:#1c7331;"><strong>返回值</strong></span></p> 
<p>      <span style="color:#fe2c24;">  成功：</span>返回实际接收到的字节数；</p> 
<p>       <span style="color:#fe2c24;"> 失败：</span>返回-1，并设置错误标志；</p> 
<p>      </p> 
<h3 id="4).%20%E6%A1%88%E4%BE%8B%E4%B8%80">2. 案例一</h3> 
<p><strong>client1.c</strong></p> 
<pre><code class="language-cpp">#include &lt;sys/un.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;errno.h&gt;


#define BUFF_SIZE       1024


int main(void) {
    int sockfd;
    struct sockaddr_in server_addr;
    int ret;
    int c;
    char buff[BUFF_SIZE] = { '\0' };

    // 创建一个套接字
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);

    // 设置服务器地址
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    server_addr.sin_port = htons(8888);


    // 向服务器发送数据
    strcpy(buff, "hello world");
    ret = sendto(sockfd, buff, strlen(buff) + 1, 0, (struct sockaddr*)&amp;server_addr, sizeof(server_addr));
    if (-1 == ret) {
        perror("sendto");
        exit(errno);
    }

    printf("ret = %d\n", ret);

    return 0;
}
</code></pre> 
<p><strong>server1.c</strong></p> 
<pre><code class="language-cpp">#include &lt;sys/un.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;errno.h&gt;


#define BUFF_SIZE       1024


int main(void) {
    int server_sockfd;
    int client_sockfd;
    char ch;
    int ret;
    int recv_len;
    char buff[BUFF_SIZE] = { '\0' };


    // 用于Linux系统内部通讯的地址， struct sockaddr_un
    struct sockaddr_in server_addr;
    struct sockaddr_in client_addr;
    int client_addr_len = sizeof(struct sockaddr_in);

    server_sockfd = socket(AF_INET, SOCK_DGRAM, 0);


    // 设置服务器地址
    server_addr.sin_family = AF_INET;   // 地址的域，相当于地址的类型，AF_UNIX表示地址位于UNIX系统内部

    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8888);

    // 绑定该套接字，使得该套接字和对应的系统套接字文件关联起来
    ret = bind(server_sockfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));
    if (-1 == ret) {
        perror("bind");
        exit(1);
    }

    // 循环处理客户端请求
    while (1) {
        printf("server waiting\n");

        recv_len = recvfrom(server_sockfd, buff, sizeof(buff), 0, (struct sockaddr *)&amp;client_addr, &amp;client_addr_len);
        if (recv_len &lt; 0) {
            perror("recvfrom");
            exit(errno);
        }

        printf("received: %s\n", buff);
    }

    close(server_sockfd);

    return 0;
}
                    </code></pre> 
<p></p> 
<h3 id="5).%20%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%8CUDP%E5%9B%9E%E5%A3%B0%E6%9C%8D%E5%8A%A1%E5%99%A8">3. 案例二，UDP回声服务器</h3> 
<p>客户端给服务器发送一条数据，服务器接收后，将数据转换成大写字母，再发送回给客户端！</p> 
<p><strong>client2.c</strong></p> 
<pre><code class="language-cpp">#include &lt;sys/un.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;


#define BUFF_SIZE       1024


int main(int argc, char **argv) {
    int sockfd;
    struct sockaddr_in server_addr;
    int ret = 0;
    int c = 0;
    char buff[BUFF_SIZE] = { '\0' };
    socklen_t addr_len;


    if (argc &lt; 2) {
        fprintf(stderr, "missing parameter!\n");
        exit(1);
    }


    // 创建一个套接字
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);

    // 设置服务器地址
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    server_addr.sin_port = htons(8888);

    // 向服务器发送数据
    //strcpy(buff, "hello world");
    char *message = argv[1];
    ret = sendto(sockfd, message, strlen(message) + 1, 0, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));
    if (-1 == ret) {
        perror("sendto");
        exit(errno);
    }

    printf("send %d bytes\n", ret);

    // 接收服务器发送的数据
    ret = recv(sockfd, buff, sizeof(buff), 0);
    if (-1 == ret) {
        perror("recvfrom");
        exit(errno);
    }

    printf("received %d bytes\n", ret);
    printf("recevied: %s\n", buff);


    return 0;
}
</code></pre> 
<p><strong>server2.c</strong></p> 
<pre><code class="language-cpp">#include &lt;sys/un.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;errno.h&gt;


#define BUFF_SIZE       1024



// 英文小写转换成大写
static void str2up(char *str) {
    while (*str) {
        if (*str &gt;= 'a' &amp;&amp; *str &lt;= 'z') {
            *str = *str - 'a' + 'A';
        }

        str++;
    }
}



int main(void) {
    int server_sockfd;
    int client_sockfd;
    char ch = '\0';
    int ret = 0;
    int recv_len = 0;
    int send_len = 0;
    char buff[BUFF_SIZE] = { '\0' };

    // 用于UNIX系统内部通信的地址， struct sockaddr_un
    struct sockaddr_in server_addr;
    struct sockaddr_in client_addr;
    int client_addr_len = sizeof(struct sockaddr_in);

    server_sockfd = socket(AF_INET, SOCK_DGRAM, 0);

    // 设置服务器地址
    server_addr.sin_family = AF_INET;   // 地址的域， 相当于地址的类型， AF_UNIX 表示地址位于UNIX系统内部
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8888);

    // 绑定该套接字，使得该套接字和对应的系统套接字文件关联起来
    ret = bind(server_sockfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));
    if (-1 == ret) {
        perror("bind");
        exit(1);
    }

    // 循环处理客户端请求
    while (1) {
        printf("server waiting\n");


        recv_len = recvfrom(server_sockfd, buff, sizeof(buff), 0, (struct sockaddr *)&amp;client_addr, &amp;client_addr_len);
        if (recv_len &lt; 0) {
            perror("recvfrom");
            exit(errno);
        }

        printf("received: %s\n", buff);

        str2up(buff);
        send_len = sendto(server_sockfd, buff, strlen(buff) + 1, 0, (struct sockaddr *)&amp;client_addr, client_addr_len);
        if (-1 == send_len) {
            perror("sendto");
            exit(errno);
        }
    }

    close(server_sockfd);
    return 0;
}
</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9b/bd/fhHjlzzM_o.gif"></p> 
<hr> 
<p></p> 
<h2 id="%E4%B8%83%E3%80%81TCP%E5%88%86%E5%8C%85%E5%92%8C%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%C2%A0" style="background-color:transparent;">七、TCP分包和粘包问题 </h2> 
<p><a class="link-info" href="https://blog.csdn.net/cpp_learner/article/details/129405399?spm=1001.2014.3001.5501" title="TCP分包和粘包问题">TCP分包和粘包问题</a></p> 
<p></p> 
<hr> 
<p></p> 
<h2 id="%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93">六、总结</h2> 
<p>Linux环境中的C/C++ socket 与Window环境中的C/C++ socket类似。</p> 
<p>创建服务器时需要按照指定流程来创建，根据上面图<span style="color:#be191c;"><strong><span style="background-color:#cbe0f1;">Socket 通信创建流程图</span></strong></span>来创建即可。</p> 
<p>注意调用系统函数失败时，可以打印失败原因帮助我们定位问题。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d351891f94abf2d739dfff3be60917c8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">springboot多数据源集成</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a17d94fdd5a46afaddcd6c2cc0282d42/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;常用软件分析工具从入门到精通案例集锦汇总</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>