<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>谈谈SpringBoot（二） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="谈谈SpringBoot（二）" />
<meta property="og:description" content="1. Spring Boot缓存 1.1 JSR-107 Spring从3.1开始定义了org.springframework.cache.Cache
和org.springframework.cache.CacheManager接口来统一不同的缓存技术；
并支持使用JCache（JSR-107）注解简化我们开发。
Cache接口为缓存的组件规范定义，包含缓存的各种操作集合；Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache， ConcurrentMapCache等；每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取；使用Spring缓存抽象时我们需要关注以下两点：
1、确定方法需要被缓存以及他们的缓存策略
2、从缓存中读取之前缓存存储的数据 1.2 Springboot缓存抽象的缓存注解 Cache缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等CacheManager缓存管理器，管理各种缓存（Cache）组件@Cacheable主要针对方法配置，能够根据方法的请求参数对其结果进行缓存@CacheEvict清空缓存@CachePut保证方法被调用，又希望结果被缓存@EnableCaching开启基于注解的缓存keyGenerator缓存数据时key生成策略serialize缓存数据时value序列化策略 @Cacheable/@CachePut/@CacheEvict 主要的参数
value缓存的名称，在spring 配置文件中定义，必须指定至少一个例如：@Cacheable(value=”mycache”) 或者@Cacheable(value={”cache1”,”cache2”}key缓存的key，可以为空，如果指定要按照SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合例如：@Cacheable(value=”testcache”,key=”#userName”)condition缓存的条件，可以为空，使用SpEL 编写，返回true 或者false，只有为true 才进行缓存/清除缓存例如：@Cacheable(value=”testcache”,condition=”#userName.length()&gt;2”)allEntries
(@CacheEvict )是否清空所有缓存内容，缺省为false，如果指定为true，则方法调用后将立即清空所有缓存例如：@CachEvict(value=”testcache”,allEntries=true)beforeInvocation
(@CacheEvict)是否在方法执行前就清空，缺省为false，如果指定为true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存例如：
@CachEvict(value=”testcache”，beforeInvocation=true) 1.3 Springboot缓存注解的使用 1.3.1 创建工程 参照：谈谈SpringBoot（一）9. SpringBoot与数据访问
/resources/application.properties
#开启驼峰命名 #mybatis.configuration.map-underscore-to-camel-case=true #将日志级别设置为debug logging.level.com.zmj.springboot.mapper=debug #打开自动配置报告 debug=true pom.xml依赖 &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;project xmlns=&#34;http://maven.apache.org/POM/4.0.0&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:schemaLocation=&#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&#34;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.12.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.zmj&lt;/groupId&gt; &lt;artifactId&gt;springboot-cache&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-cache&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/283ca109233b52a008eead28d3f047c0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-09T13:45:36+08:00" />
<meta property="article:modified_time" content="2023-02-09T13:45:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">谈谈SpringBoot（二）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="main-toc">1. Spring Boot缓存</h2> 
<h3 id="1.1%C2%A0JSR-107">1.1 JSR-107</h3> 
<blockquote> 
 <p>Spring从3.1开始定义了org.springframework.cache.Cache<br> 和org.springframework.cache.CacheManager接口来统一不同的缓存技术；<br> 并支持使用JCache（JSR-107）注解简化我们开发。</p> 
 <ul><li>Cache接口为缓存的组件规范定义，包含缓存的各种操作集合；</li><li>Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache， ConcurrentMapCache等；</li><li>每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取；</li><li>使用Spring缓存抽象时我们需要关注以下两点：<br> 1、确定方法需要被缓存以及他们的缓存策略<br> 2、从缓存中读取之前缓存存储的数据</li></ul> 
</blockquote> 
<h3 id="%C2%A01.2%C2%A0Springboot%E7%BC%93%E5%AD%98%E6%8A%BD%E8%B1%A1%E7%9A%84%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3"> 1.2 Springboot缓存抽象的缓存注解</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:549px;"><tbody><tr><td>Cache</td><td style="width:419px;">缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等</td></tr><tr><td>CacheManager</td><td style="width:419px;">缓存管理器，管理各种缓存（Cache）组件</td></tr><tr><td>@Cacheable</td><td style="width:419px;">主要针对方法配置，能够根据方法的请求参数对其结果进行缓存</td></tr><tr><td>@CacheEvict</td><td style="width:419px;">清空缓存</td></tr><tr><td>@CachePut</td><td style="width:419px;">保证方法被调用，又希望结果被缓存</td></tr><tr><td>@EnableCaching</td><td style="width:419px;">开启基于注解的缓存</td></tr><tr><td>keyGenerator</td><td style="width:419px;">缓存数据时key生成策略</td></tr><tr><td>serialize</td><td style="width:419px;">缓存数据时value序列化策略</td></tr></tbody></table> 
<p>    @Cacheable/@CachePut/@CacheEvict 主要的参数</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>value</td><td>缓存的名称，在spring 配置文件中定义，必须指定至少一个</td><td>例如：@Cacheable(value=”mycache”) 或者@Cacheable(value={”cache1”,”cache2”}</td></tr><tr><td>key</td><td>缓存的key，可以为空，如果指定要按照SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td>例如：@Cacheable(value=”testcache”,key=”#userName”)</td></tr><tr><td>condition</td><td>缓存的条件，可以为空，使用SpEL 编写，返回true 或者false，只有为true 才进行缓存/清除缓存</td><td>例如：@Cacheable(value=”testcache”,condition=”#userName.length()&gt;2”)</td></tr><tr><td>allEntries<br> (@CacheEvict )</td><td>是否清空所有缓存内容，缺省为false，如果指定为true，则方法调用后将立即清空所有缓存</td><td>例如：@CachEvict(value=”testcache”,allEntries=true)</td></tr><tr><td>beforeInvocation<br> (@CacheEvict)</td><td>是否在方法执行前就清空，缺省为false，如果指定为true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存</td><td>例如：<br> @CachEvict(value=”testcache”，beforeInvocation=true)</td></tr></tbody></table> 
<h3 id="1.3%C2%A0Springboot%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8">1.3 Springboot缓存注解的使用</h3> 
<h4 id="1.3.1%20%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B">1.3.1 创建工程</h4> 
<p>参照：<a href="https://blog.csdn.net/qq_30426943/article/details/128512665?spm=1001.2014.3001.5502" title="谈谈SpringBoot（一）">谈谈SpringBoot（一）</a><a href="https://blog.csdn.net/qq_30426943/article/details/128512665?spm=1001.2014.3001.5502#t75" title="9. SpringBoot与数据访问">9. SpringBoot与数据访问</a></p> 
<p><span style="color:#fe2c24;">/resources/application.properties</span></p> 
<pre><code class="language-bash">#开启驼峰命名
#mybatis.configuration.map-underscore-to-camel-case=true
#将日志级别设置为debug
logging.level.com.zmj.springboot.mapper=debug
#打开自动配置报告
debug=true</code></pre> 
<p><span style="color:#956fe7;">pom.xml依赖</span><code class="language-XML"> </code></p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;1.5.12.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.zmj&lt;/groupId&gt;
    &lt;artifactId&gt;springboot-cache&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;springboot-cache&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.2.15&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.log4j&lt;/groupId&gt;
            &lt;artifactId&gt;com.springsource.org.apache.log4j&lt;/artifactId&gt;
            &lt;version&gt;1.2.16&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre> 
<p><img alt="" height="102" src="https://images2.imgbox.com/fa/ec/LpmNatPD_o.png" width="614"></p> 
<p>​​不使用时，每次查询都要进入数据库</p> 
<p><img alt="" height="113" src="https://images2.imgbox.com/a4/10/0HrcyJXK_o.png" width="630">​​</p> 
<h4 id="1.3.2%C2%A0%C2%A0%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98">1.3.2  使用缓存</h4> 
<pre><code class="language-java">@Service
public class EmployeeService {
    @Autowired
    private EmployeeMapper employeeMapper;

    @Cacheable(cacheNames = {"emp"})//缓存组件名称为emp
    public Employee getEmpById(Integer id){
        Employee emp = employeeMapper.getEmpById(id);
        return emp;
    }
}</code></pre> 
<pre><code class="language-java">@RestController
public class EmployeeController {
    @Autowired
    private EmployeeService employeeService;

    @GetMapping("/emp/{id}")
    public Employee queryEmp(@PathVariable("id") Integer id){
        return employeeService.getEmpById(id);
    }
}</code></pre> 
<pre><code class="language-java">@EnableCaching //开启缓存
@MapperScan("com.zmj.springboot.mapper")
@SpringBootApplication
public class SpringbootCacheApplication {
    public static void main(String[] args) {
        SpringApplication.run(SpringbootCacheApplication.class, args);
    }
}</code></pre> 
<p>使用缓存后，第一次查询进入数据库，后面如果是相同的数据，直接从缓存中获取</p> 
<p></p> 
<h3 id="1.4%20%40Cacheable%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E7%A8%8B">1.4 @Cacheable的工作原理和流程</h3> 
<p>1.4.1） 服务启动，执行SpringApplication.run方法</p> 
<p>1.4.2） 首先找到缓存的自动配置类，根据命名规范可知是<code class="language-java">CacheAutoConfiguration</code></p> 
<pre><code class="language-java">@Configuration
@ConditionalOnClass({CacheManager.class})
@ConditionalOnBean({CacheAspectSupport.class})
@ConditionalOnMissingBean(
    value = {CacheManager.class},
    name = {"cacheResolver"}
)
@EnableConfigurationProperties({CacheProperties.class})
@AutoConfigureBefore({HibernateJpaAutoConfiguration.class})
@AutoConfigureAfter({CouchbaseAutoConfiguration.class, HazelcastAutoConfiguration.class, RedisAutoConfiguration.class})
@Import({CacheAutoConfiguration.CacheConfigurationImportSelector.class})
public class CacheAutoConfiguration {
}</code></pre> 
<p>1.4.3） 通过@Import得知，需要导入CacheConfigurationImportSelector类</p> 
<pre><code class="language-java">@Import({CacheAutoConfiguration.CacheConfigurationImportSelector.class})
public class CacheAutoConfiguration {
    static class CacheConfigurationImportSelector implements ImportSelector {
        CacheConfigurationImportSelector() {
        }
        public String[] selectImports(AnnotationMetadata importingClassMetadata) {
            CacheType[] types = CacheType.values();
            String[] imports = new String[types.length];

            for(int i = 0; i &lt; types.length; ++i) {
                imports[i] = CacheConfigurations.getConfigurationClass(types[i]);
            }

            return imports;
        }
    }
}</code></pre> 
<p><img alt="" height="338" src="https://images2.imgbox.com/8f/92/tovcbJzo_o.png" width="676"></p> 
<p>​1.4.4） 缓存的自动配置类中，默认SimpleCacheConfiguration类生效</p> 
<blockquote> 
 <p>----通过打印出来的自动配置报告获得   </p> 
 <p>SimpleCacheConfiguration matched:<br>       - Cache org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration automatic cache type (CacheCondition)<br>       - @ConditionalOnMissingBean (types: org.springframework.cache.CacheManager; SearchStrategy: all) did not find any beans (OnBeanCondition)</p> 
</blockquote> 
<pre><code class="language-java">@Configuration
@ConditionalOnMissingBean({CacheManager.class})
@Conditional({CacheCondition.class})
class SimpleCacheConfiguration {

    @Bean
    public ConcurrentMapCacheManager cacheManager() {
        ConcurrentMapCacheManager cacheManager = new ConcurrentMapCacheManager();
        List&lt;String&gt; cacheNames = this.cacheProperties.getCacheNames();
        if (!cacheNames.isEmpty()) {
            cacheManager.setCacheNames(cacheNames);
        }
        return (ConcurrentMapCacheManager)this.customizerInvoker.customize(cacheManager);
    }
}</code></pre> 
<p>1.4.5） SimpleCacheConfiguration的ConcurrentMapCacheManager</p> 
<p>ConcurrentMapCacheManager中有一个cacheMap，后来的缓存数据就是保存到这里</p> 
<pre><code class="language-java">public class ConcurrentMapCacheManager implements CacheManager, BeanClassLoaderAware {
    private final ConcurrentMap&lt;String, Cache&gt; cacheMap = new ConcurrentHashMap(16);
}</code></pre> 
<p></p> 
<p>1.4.6）浏览器发送第一次请求</p> 
<p><a href="http://localhost:8080/emp/1" rel="nofollow" title="http://localhost:8080/emp/1">http://localhost:8080/emp/1</a></p> 
<div> 
 <pre><code class="language-java">public class ConcurrentMapCacheManager implements CacheManager, BeanClassLoaderAware {
    private final ConcurrentMap&lt;String, Cache&gt; cacheMap = new ConcurrentHashMap(16);
    public Cache getCache(String name) {
        Cache cache = (Cache)this.cacheMap.get(name);//name=emp
        if (cache == null &amp;&amp; this.dynamic) {//第一次请求缓存为null且this.dynamic为true
            synchronized(this.cacheMap) {
                cache = (Cache)this.cacheMap.get(name);
                if (cache == null) {//再次检测，还是为null
                    cache = this.createConcurrentMapCache(name);//创建新缓存
                    this.cacheMap.put(name, cache);
                }
            }
        }
        return cache;
    }
}</code></pre> 
</div> 
<p> 1.4.7）创建新缓存对象</p> 
<div> 
 <pre><code class="language-java">public class ConcurrentMapCacheManager implements CacheManager, BeanClassLoaderAware {
    protected Cache createConcurrentMapCache(String name) {
        SerializationDelegate actualSerialization = this.isStoreByValue() ? this.serialization : null;
        return new ConcurrentMapCache(name, new ConcurrentHashMap(256), this.isAllowNullValues(), actualSerialization);
    }
}</code></pre> 
</div> 
<p> 1.4.8）生成key和value（cache对象）</p> 
<p>key是默认按照keyGenerator策略生成的，默认是使用SimpleKeyGenerator生成key</p> 
<p>value是通过回调函数，调用EmployeeService.getEmpById()拿到实例对象</p> 
<div> 
 <pre><code class="language-java">public abstract class CacheAspectSupport extends AbstractCacheInvoker implements BeanFactoryAware, InitializingBean, SmartInitializingSingleton {
    private Object execute(final CacheOperationInvoker invoker, Method method, CacheAspectSupport.CacheOperationContexts contexts) {
        if (contexts.isSynchronized()) {
            CacheAspectSupport.CacheOperationContext context = (CacheAspectSupport.CacheOperationContext)contexts.get(CacheableOperation.class).iterator().next();
            if (this.isConditionPassing(context, CacheOperationExpressionEvaluator.NO_RESULT)) {
                Object key = this.generateKey(context, CacheOperationExpressionEvaluator.NO_RESULT);
                Cache cache = (Cache)context.getCaches().iterator().next();

                try {
                    return this.wrapCacheValue(method, cache.get(key, new Callable&lt;Object&gt;() {
                        public Object call() throws Exception {
                            return CacheAspectSupport.this.unwrapReturnValue(CacheAspectSupport.this.invokeOperation(invoker));
                        }
                    }));
                } catch (ValueRetrievalException var10) {
                    throw (ThrowableWrapper)var10.getCause();
                }
            } else {
                return this.invokeOperation(invoker);
            }
        } else {
            this.processCacheEvicts(contexts.get(CacheEvictOperation.class), true, CacheOperationExpressionEvaluator.NO_RESULT);
            ValueWrapper cacheHit = this.findCachedItem(contexts.get(CacheableOperation.class));
            List&lt;CacheAspectSupport.CachePutRequest&gt; cachePutRequests = new LinkedList();
            if (cacheHit == null) {
                this.collectPutRequests(contexts.get(CacheableOperation.class), CacheOperationExpressionEvaluator.NO_RESULT, cachePutRequests);
            }

            Object cacheValue;
            Object returnValue;
            if (cacheHit != null &amp;&amp; cachePutRequests.isEmpty() &amp;&amp; !this.hasCachePut(contexts)) {
                cacheValue = cacheHit.get();
                returnValue = this.wrapCacheValue(method, cacheValue);
            } else {
                returnValue = this.invokeOperation(invoker);
                cacheValue = this.unwrapReturnValue(returnValue);
            }

            this.collectPutRequests(contexts.get(CachePutOperation.class), cacheValue, cachePutRequests);
            Iterator var8 = cachePutRequests.iterator();

            while(var8.hasNext()) {
                CacheAspectSupport.CachePutRequest cachePutRequest = (CacheAspectSupport.CachePutRequest)var8.next();
                cachePutRequest.apply(cacheValue);
            }

            this.processCacheEvicts(contexts.get(CacheEvictOperation.class), false, cacheValue);
            return returnValue;
        }
    }
    protected class CacheOperationContext implements CacheOperationInvocationContext&lt;CacheOperation&gt; {
        public CacheOperationContext(CacheAspectSupport.CacheOperationMetadata metadata, Object[] args, Object target) {
        protected Object generateKey(Object result) {
            if (StringUtils.hasText(this.metadata.operation.getKey())) {
                EvaluationContext evaluationContext = this.createEvaluationContext(result);
                return CacheAspectSupport.this.evaluator.key(this.metadata.operation.getKey(), this.methodCacheKey, evaluationContext);
            } else {
                return this.metadata.keyGenerator.generate(this.target, this.metadata.method, this.args);
            }
        }
    }
}</code></pre> 
</div> 
<p> 1.4.9）浏览器发送第二次请求</p> 
<p><a href="http://localhost:8080/emp/1" rel="nofollow" title="http://localhost:8080/emp/1">http://localhost:8080/emp/1</a></p> 
<div> 
 <pre><code class="language-java">public class ConcurrentMapCacheManager implements CacheManager, BeanClassLoaderAware {
    public Cache getCache(String name) {
        Cache cache = (Cache)this.cacheMap.get(name);//name=emp
        if (cache == null &amp;&amp; this.dynamic) {//此时cache不为空，条件不成立
            synchronized(this.cacheMap) {
                cache = (Cache)this.cacheMap.get(name);
                if (cache == null) {
                    cache = this.createConcurrentMapCache(name);
                    this.cacheMap.put(name, cache);
                }
            }
        }
        return cache;//直接返回缓存数据
    }
}</code></pre> 
</div> 
<h3 id="1.5%20%40Cacheable%E7%9A%84%E5%85%B6%E4%BB%96%E5%B1%9E%E6%80%A7">1.5 @Cacheable的其他属性</h3> 
<h4 id="1.5.1%20%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F">1.5.1 第一种方式</h4> 
<div> 
 <pre><code class="language-java">@Service
public class EmployeeService {
    @Autowired
    private EmployeeMapper employeeMapper;

    //@Cacheable(cacheNames = {"emp"})//缓存组件名称为emp
    //@Cacheable(cacheNames = {"emp"},condition = "#id &gt; 0")//缓存的条件是id &gt; 0
    @Cacheable(cacheNames = {"emp"},key="#root.methodName+'['+#id+']'")//key=方法名+id
    public Employee getEmpById(Integer id){
        Employee emp = employeeMapper.getEmpById(id);
        return emp;
    }
}</code></pre> 
</div> 
<h4 id="1.5.2%C2%A0%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F">1.5.2 第二种方式</h4> 
<div> 
 <pre><code class="language-java">@Configuration
public class MyCacheConfig {

    @Bean("myKeyGenerator")
    public KeyGenerator keyGenerator() {//自定义key的生成策略
        return new KeyGenerator(){
            @Override
            public Object generate(Object target, Method method, Object... params) {
                return method.getName()+ "["+Arrays.asList(params).toString()+"]";
            }
        };
    }
}</code></pre> 
</div> 
<div> 
 <pre><code class="language-java">@Service
public class EmployeeService {
    @Autowired
    private EmployeeMapper employeeMapper;

    @Cacheable(cacheNames = {"emp"},keyGenerator = "myKeyGenerator")//key为自定义策略
    //@Cacheable(cacheNames = {"emp"},keyGenerator="myKeyGenerator",condition = "#id &gt; 1")
    //@Cacheable(cacheNames = {"emp"},keyGenerator = "myKeyGenerator",condition = "#id &gt; 1",unless = "#a0==2")
    public Employee getEmpById(Integer id){
        Employee emp = employeeMapper.getEmpById(id);
        return emp;
    }
}</code></pre> 
</div> 
<h3 id="1.6%20%E5%85%B6%E4%BB%96%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3">1.6 其他缓存注解</h3> 
<div> 
 <pre><code class="language-java">@CacheConfig(cacheNames = {"emp"})//全局配置缓存名字都是emp
@Service
public class EmployeeService {
    @Autowired
    private EmployeeMapper employeeMapper;

    @Cacheable()
    //@Cacheable(cacheNames = {"emp"},keyGenerator = "myKeyGenerator",condition = "#id &gt; 1",unless = "#a0==2")
    public Employee getEmpById(Integer id){
        Employee emp = employeeMapper.getEmpById(id);
        return emp;
    }
    //更新缓存，key为员工ID
    @CachePut(key = "#employee.id")
    public Employee updateEmp(Employee employee) {
        employeeMapper.updateEmp(employee);
        return employee;
    }

    //@CacheEvict(allEntries = true)//清除所有缓存
    @CacheEvict(key = "#id")//清除缓存，key为员工ID
    @CacheEvict(key = "#id")
    public void deleteEmp(Integer id) {
        employeeMapper.deleteEmp(id);
    }

    //@Caching定义复杂的缓存规则
    @Caching(
            cacheable = {
                    @Cacheable(key = "#lastName")
            },
            put = {
                   @CachePut(key = "#result.id"),
                   @CachePut(key = "#result.email")
            }
    )
    public Employee getEmpByLastName(String lastName){
        Employee emp = employeeMapper.getEmpByLastName(lastName);
        return emp;
    }
}</code></pre> 
</div> 
<p></p> 
<h3 id="1.7%20Springboot%E6%95%B4%E5%90%88Redis">1.7 Springboot整合Redis</h3> 
<h4 id="1.7.1%20Docker%E4%B8%AD%E5%90%AF%E5%8A%A8Redis">1.7.1 Docker中启动Redis</h4> 
<p>参照：<a href="https://blog.csdn.net/qq_30426943/article/details/127839536?spm=1001.2014.3001.5502" title="谈谈Docker">谈谈Docker</a><a class="link-info" href="https://blog.csdn.net/qq_30426943/article/details/127839536?spm=1001.2014.3001.5502" title="12. Docker安装Redis">12. Docker安装Redis</a><a href="https://blog.csdn.net/qq_30426943/article/details/127839536?spm=1001.2014.3001.5502" title="谈谈Docker">谈谈Docker</a></p> 
<pre><code class="language-bash">docker run -d -p 16379:6379 --name myredis8 16ecd2772934</code></pre> 
<h4 id="1.7.2%C2%A0%20%E4%BE%9D%E8%B5%96%E5%92%8C%E9%85%8D%E7%BD%AE">1.7.2  依赖和配置</h4> 
<p><span style="color:#956fe7;">在缓存的基础上添加pom.xml依赖</span></p> 
<pre><code class="language-XML">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;</code></pre> 
<p><span style="color:#511b78;">在application.properties里面追加</span> </p> 
<pre><code class="language-bash">spring.redis.host=192.168.1.200
spring.redis.port=16379</code></pre> 
<pre><code class="language-java">@Configuration
public class MyRedisConfig {
    @Bean
    public RedisTemplate&lt;Object, Object&gt; redisTemplate(
            RedisConnectionFactory redisConnectionFactory){
        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(redisConnectionFactory);
        Jackson2JsonRedisSerializer&lt;Object&gt; ser = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);
        template.setDefaultSerializer(ser);//序列化器
        return template;
    }
}</code></pre> 
<h4 id="1.7.3%20%E5%9C%A8%E6%B5%8B%E8%AF%95%E7%B1%BB%E4%B8%AD%E9%AA%8C%E8%AF%81redis">1.7.3 在测试类中验证redis</h4> 
<pre><code class="language-java">@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringbootCacheApplicationTests {
    @Autowired
    private StringRedisTemplate stringRedisTemplate;
    @Autowired
    RedisTemplate&lt;Object, Object&gt; redisTemplate;
    @Autowired
    private EmployeeMapper employeeMapper;

    @Test
    public void stringRedisTemplateTest() {
        stringRedisTemplate.opsForValue().set("str","1");//设置key=str,value=1
        stringRedisTemplate.opsForValue().append("str","2");//key=str的value追加2
        String str = stringRedisTemplate.opsForValue().get("str");//获取key=str的value
        System.out.println(str);//结果为12

        stringRedisTemplate.opsForList().leftPush("myList","a");//为集合myList左边放一个a
        stringRedisTemplate.opsForList().leftPush("myList","b");//为集合myList左边放一个b
        String pop1 = stringRedisTemplate.opsForList().leftPop("myList");
        System.out.println("pop1="+pop1);//pop1=b
        String pop2 = stringRedisTemplate.opsForList().leftPop("myList");
        System.out.println("pop2="+pop2);//pop2=a
    }

    @Test
    public void redisTemplateTest() {
        Integer id = 1;
        Employee emp = employeeMapper.getEmpById(id);//emp.lastName=张三
        redisTemplate.opsForValue().set(String.valueOf(id),emp);
        LinkedHashMap linkedHashMap = (LinkedHashMap) redisTemplate.opsForValue().get(String.valueOf(id));
        System.out.println(linkedHashMap.get("lastName"));//张三
    }
}</code></pre> 
<h4 id="1.7.4%20%E9%A1%B5%E9%9D%A2%E8%AE%BF%E9%97%AE">1.7.4 页面访问</h4> 
<pre><code class="language-java">@RestController
public class DeptController {
    @Autowired
    private DeptService deptService;
 
    @GetMapping("/dept/{id}")
    public Department queryDepartment(@PathVariable("id") Integer id){
        return deptService.getDeptById(id);
    }
}</code></pre> 
<pre><code class="language-java">@CacheConfig(cacheNames = {"dept"})//全局配置缓存名字都是dept
@Service
public class DeptService {
    @Autowired
    private DepartmentMapper departmentMapper;

    @Cacheable()
    public Department getDeptById(Integer id){
        Department dept = departmentMapper.getDeptById(id);
        return dept;
    }
}</code></pre> 
<pre><code class="language-java">@Configuration
public class MyRedisConfig {
   // 配置Jackson2JsonRedisSerializer
    // 避免出现获取缓存时出现的类型转换错误
    private Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer() {
        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer =
                new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        objectMapper.configure(MapperFeature.USE_ANNOTATIONS, false);
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);

        // 此项必须配置
        //否则会报java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to XXX
        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);
        return jackson2JsonRedisSerializer;
    }

    @Bean
    @ConditionalOnMissingBean(
            name = {"redisTemplate"}
    )
    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2RedisSerializer = jackson2JsonRedisSerializer();
        //默认使用jdk序列化
        template.setDefaultSerializer(jackson2RedisSerializer);
        return template;
    }
}</code></pre> 
<p><span style="color:#be191c;">除了第一次访问，后面几次都不会请求数据库，直接查询Redis缓存数据 </span></p> 
<p><img alt="" height="115" src="https://images2.imgbox.com/03/d8/fwtAbhbe_o.png" width="463"></p> 
<p></p> 
<h2 id="2.%20Spring%20Boot%E4%B8%8E%E6%B6%88%E6%81%AF">2. Spring Boot与消息</h2> 
<h3 id="2.1%20%E6%A6%82%E8%BF%B0">2.1 概述</h3> 
<blockquote> 
 <p>1. 在大多应用中，我们系统之间需要进行异步通信，即异步消息</p> 
 <p><br> 2. 异步消息中两个重要概念：<br>         消息代理（message broker）和目的地（destination）<br> 当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定目的地</p> 
 <p><br> 3. 异步消息主要有两种形式的目的地<br> a.队列（queue）：点对点消息通信（point-to-point）<br> b.主题（topic）：发布（publish）/订阅（subscribe）消息通信</p> 
 <p></p> 
 <p>4.点对点式：<br> –消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列<br> –消息只有唯一的发送者和接受者，但并不是说只能有一个接收者</p> 
 <p><br> 5.发布订阅式：<br> –发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息</p> 
 <p><br> 6.JMS（Java Message Service）java消息服务：<br> –基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现</p> 
 <p><br> 7.AMQP（Advanced Message Queuing Protocol）<br> –高级消息队列协议，也是一个消息代理的规范，兼容JMS<br> –RabbitMQ是AMQP的实现</p> 
 <p></p> 
 <p>8.Spring支持<br> –spring-jms提供了对JMS的支持<br> –spring-rabbit提供了对AMQP的支持<br> –需要ConnectionFactory的实现来连接消息代理<br> –提供JmsTemplate、RabbitTemplate来发送消息<br> –@JmsListener（JMS）、@RabbitListener（AMQP）注解在方法上监听消息代理发布的消息<br> –@EnableJms、@EnableRabbit开启支持</p> 
 <p><br> 9.Spring Boot自动配置<br> –JmsAutoConfiguration<br> –RabbitAutoConfiguration</p> 
</blockquote> 
<h3 id="2.2%C2%A0%E5%BC%80%E5%90%AFRabbitMQ%E6%9C%8D%E5%8A%A1">2.2 开启RabbitMQ服务</h3> 
<p>参照：<a href="https://blog.csdn.net/qq_30426943/article/details/127839536?spm=1001.2014.3001.5502" title="21.Docker安装RabbitMQ">21.Docker安装RabbitMQ</a></p> 
<h3 id="2.3%20%E6%90%AD%E5%BB%BA%E5%B7%A5%E7%A8%8B">2.3 搭建工程</h3> 
<p><img alt="" height="223" src="https://images2.imgbox.com/a9/99/YGK8VecW_o.png" width="662"></p> 
<p><img alt="" height="415" src="https://images2.imgbox.com/c9/20/xGudbKkn_o.png" width="662"></p> 
<p><img alt="" height="218" src="https://images2.imgbox.com/67/6a/8uxgpljS_o.png" width="660"></p> 
<p><span style="background-color:#a2e043;">application.properties</span><span style="background-color:#fbd4d0;">配置信息</span></p> 
<pre><code class="language-bash">spring.rabbitmq.host=192.168.1.200
spring.rabbitmq.username=admin
spring.rabbitmq.password=admin</code></pre> 
<h3></h3> 
<h3 id="2.4%20%E6%B5%8B%E8%AF%95%E5%8D%95%E6%92%AD%E6%A8%A1%E5%BC%8F">2.4 测试单播模式</h3> 
<pre><code class="language-java">@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringbootAmqpApplicationTests {

    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    @Test
    public void unicastMode() {//单播模式（点对点）
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        map.put("msg","idea:helloworld");
        map.put("data", Arrays.asList("nihao",123,true));
        String exchange = "exchage.direct";//交换器
        String routingKey = "zmj.news";//路由键
        rabbitTemplate.convertAndSend(exchange,routingKey,map);
    }
}</code></pre> 
<p> 1）<span style="color:#ed7976;">运行测试类后，结果如下。说明数据是被序列化后发送的</span></p> 
<p><img alt="" height="251" src="https://images2.imgbox.com/b1/6a/5bbbo1LC_o.png" width="642"></p> 
<pre><code class="language-java">@Configuration
public class MyAMQPConfig {

    @Bean
    public MessageConverter messageConverter() {
        return new Jackson2JsonMessageConverter();//数据转为JSON格式
    }
}</code></pre> 
<p>2）<span style="color:#ed7976;">再次运行测试类后，结果已经变为了JSON格式</span></p> 
<p><img alt="" height="530" src="https://images2.imgbox.com/a7/d8/9Jbdtf5V_o.png" width="527"></p> 
<p> 3）接收数据</p> 
<pre><code class="language-java">@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringbootAmqpApplicationTests {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Test
    public void receiveMsg() {//接收消息
        Object obj = rabbitTemplate.receiveAndConvert("zmj.news");
        System.out.println(obj);
        //{msg=idea:helloworld, data=[nihao, 123, true]}
    }
}</code></pre> 
<h3 id="2.5%C2%A0%E6%B5%8B%E8%AF%95%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F">2.5 测试广播模式</h3> 
<pre><code class="language-java">    @Test
    public void broadcastMode() {//广播模式
        String exchange = "exchage.fanout";//交换器
        String routingKey = "";//路由键，广播模式不用指定
        rabbitTemplate.convertAndSend(exchange,routingKey,new Book("西游记","吴承恩"));
    }</code></pre> 
<p><img alt="" height="333" src="https://images2.imgbox.com/7f/27/N6dwNQSF_o.png" width="530"></p> 
<h3></h3> 
<h3 id="2.6%C2%A0%E7%9B%91%E5%90%AC">2.6 监听</h3> 
<pre><code class="language-java">@EnableRabbit //开启基于注解的RabbitMQ
@SpringBootApplication
public class SpringbootAmqpApplication {
    public static void main(String[] args) {
        SpringApplication.run(SpringbootAmqpApplication.class, args);
    }
}</code></pre> 
<pre><code class="language-java">@Service
public class BookService {
    //只要队列zmj.news里面收到消息，就会打印
    @RabbitListener(queues = "zmj.news")
    public void receive(Book book) {
        System.out.println("收到消息，Book:"+book);
    }
}</code></pre> 
<p><span style="background-color:#ed7976;">比如 服务启动后，先运行下测试类的广播模式，这样zmj.news肯定会收到消息</span></p> 
<pre><code class="language-java">    @Test
    public void broadcastMode() {//广播模式
        String exchange = "exchage.fanout";//交换器
        String routingKey = "";//路由键，广播模式不用指定
        rabbitTemplate.convertAndSend(exchange,routingKey,new Book("三国演义","罗贯中"));
    }</code></pre> 
<p><span style="color:#a2e043;"><span style="background-color:#f3f3f4;">控制台在</span></span><span style="color:#ed7976;"><span style="background-color:#f3f3f4;">zmj.news</span></span><span style="color:#a2e043;"><span style="background-color:#f3f3f4;">队列收到消息后，打印结果</span></span></p> 
<blockquote> 
 <p>收到消息，Book:Book{name='三国演义', author='罗贯中'}</p> 
</blockquote> 
<pre><code class="language-java">  @RabbitListener(queues = "zmj")
  public void receiveMsg(Message message) {
      System.out.println(message.getBody());//[B@64d6df90
      System.out.println(message.getMessageProperties());
      //MessageProperties [headers={__TypeId__=com.zmj.springboot.entity.Book}, contentType=application/json, contentEncoding=UTF-8, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, redelivered=true, receivedExchange=exchage.fanout, receivedRoutingKey=, deliveryTag=1, consumerTag=amq.ctag-h1nXe1GQmX1C4-KCRzAAug, consumerQueue=zmj]
  }</code></pre> 
<h3 id="2.7%C2%A0AmqpAdmin%E7%AE%A1%E7%90%86%E7%BB%84%E4%BB%B6">2.7 AmqpAdmin管理组件</h3> 
<pre><code class="language-java">    @Test
    public void create() {
        String exchangeName = "amqpadmin.directexchange";//交换器名称
        DirectExchange directExchange = new DirectExchange(exchangeName);//direct交换器
        amqpAdmin.declareExchange(directExchange);//创建direct交换器

        String queueName = "amqpadmin.queue";//队列名称
        Queue durableQueue = new Queue(queueName, true);//持久化类型的队列
        amqpAdmin.declareQueue(durableQueue);//创建队列

        String routingKeyName = "amqpadmin.routingkey";//路由键名称
        Binding binding = new Binding(queueName, Binding.DestinationType.QUEUE, exchangeName, routingKeyName, null);
        amqpAdmin.declareBinding(binding);//创建绑定规则
    }</code></pre> 
<h2 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="320" src="https://images2.imgbox.com/ae/dd/1mDCKgj4_o.png" width="587"></h2> 
<p></p> 
<h2 id="3.%20Spring%20Boot%E4%B8%8E%E6%A3%80%E7%B4%A2%C2%A0">3. Spring Boot与检索 </h2> 
<h3 id="3.1%C2%A0Elasticsearch%E7%AE%80%E4%BB%8B">3.1 Elasticsearch简介</h3> 
<blockquote> 
 <p style="margin-left:0in;text-align:left;"><span style="color:#000000;">        我们的应用经常需要添加检索功能，开源的 </span><u><span style="color:#000000;"><a href="https://www.elastic.co/" rel="nofollow" title="ElasticSearch">ElasticSearch</a></span></u> <span style="color:#000000;">是</span><span style="color:#000000;">目前全文</span><span style="color:#000000;">搜索引擎</span><span style="color:#000000;">的首选</span><span style="color:#000000;">。</span><span style="color:#000000;">他</span><span style="color:#000000;">可以快速的存储、搜索和分析海量数据。</span><span style="color:#000000;">Spring </span><span style="color:#000000;">Boot</span><span style="color:#000000;">通过整合</span><span style="color:#000000;">Spring Data </span><span style="color:#000000;">ElasticSearch</span><span style="color:#000000;">为我们提供了非常便捷的检索功能支持；</span></p> 
 <p style="margin-left:0in;text-align:left;"><span style="color:#000000;">        Elasticsearch是一个分布式搜索服务，提供</span><span style="color:#000000;">Restful API</span><span style="color:#000000;">，底层基于</span><span style="color:#000000;">Lucene</span><span style="color:#000000;">，采用多</span><span style="color:#000000;">shard</span><span style="color:#000000;">（分片）的</span><span style="color:#000000;">方式保证数据安全，并且提供自动</span><span style="color:#000000;">resharding</span><span style="color:#000000;">的功能，</span><span style="color:#000000;">github</span><span style="color:#000000;">等大型的站点也是采用了</span><span style="color:#000000;">ElasticSearch</span><span style="color:#000000;">作为其搜索服务</span></p> 
 <p style="margin-left:0in;text-align:left;">        <span style="color:#000000;">以</span> <span style="color:#ff0000;"><em>员工文档</em></span><span style="color:#000000;"> 的形式存储为例：一个</span><span style="color:#ff0000;">文档</span><span style="color:#000000;">代表一个员工数据。存储数据到 </span><span style="color:#000000;">ElasticSearch</span> <span style="color:#000000;">的行为叫做 </span><span style="color:#ff0000;"><em>索引</em></span><span style="color:#000000;"> ，但在索引一个文档之前，需要确定将文档存储在哪里。</span></p> 
 <p style="margin-left:0in;text-align:left;"><span style="color:#000000;">        一个 ElasticSearch</span> <span style="color:#000000;">集群可以 包含多个 </span><span style="color:#ff0000;"><em>索引</em></span><span style="color:#000000;"> ，相应的每个索引可以包含多个 </span><span style="color:#ff0000;"><em>类型</em></span><span style="color:#000000;"> 。 这些不同的类型存储着多个 </span><span style="color:#ff0000;"><em>文档</em></span><span style="color:#000000;"> ，每个文档又有 多个 </span><span style="color:#ff0000;"><em>属性</em></span> 。</p> 
 <p style="margin-left:0in;text-align:left;"><span style="color:#000000;">        类似关系（对比MySQL）：</span></p> 
 <div style="margin-left:.81in;text-align:left;"> 
  <span style="color:#000000;">索引 &lt;===&gt; </span> 
  <span style="color:#000000;">数据库</span> 
 </div> 
 <div style="margin-left:.81in;text-align:left;"> 
  <span style="color:#000000;">类型 &lt;===&gt; 表</span> 
 </div> 
 <div style="margin-left:.81in;text-align:left;"> 
  <span style="color:#000000;">文档 &lt;===&gt; 表中的记录</span> 
 </div> 
 <div style="margin-left:.81in;text-align:left;"> 
  <span style="color:#000000;">属性 &lt;===&gt; 列</span> 
 </div> 
</blockquote> 
<p><img alt="" height="289" src="https://images2.imgbox.com/72/97/SIZqd8u5_o.png" width="672"></p> 
<p>参考： <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" rel="nofollow" title="Elasticsearch: 权威指南 | Elastic">Elasticsearch: 权威指南 | Elastic</a></p> 
<p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_indexing_employee_documents.html" rel="nofollow" title="索引员工文档 | Elasticsearch: 权威指南 | Elastic">索引员工文档 | Elasticsearch: 权威指南 | Elastic</a></p> 
<h2 id="3.2%20Docker%20%E5%90%AF%E5%8A%A8Elasticsearch">3.2 Docker 启动Elasticsearch</h2> 
<p>参考：<a href="https://blog.csdn.net/qq_30426943/article/details/127839536?spm=1001.2014.3001.5502" title="22. Docker安装Elasticsearch">22. Docker安装Elasticsearch</a></p> 
<h3 id="3.3%20%E6%90%AD%E5%BB%BA%E5%B7%A5%E7%A8%8B">3.3 搭建工程</h3> 
<p><img alt="" height="225" src="https://images2.imgbox.com/82/00/252LEJiF_o.png" width="633"></p> 
<p><img alt="" height="472" src="https://images2.imgbox.com/c5/16/NOt0xzfl_o.png" width="637"></p> 
<p> <img alt="" height="191" src="https://images2.imgbox.com/6b/c5/tDjCvFyj_o.png" width="633"></p> 
<p></p> 
<h2 id="4.%20Spring%20Boot%E4%B8%8E%E4%BB%BB%E5%8A%A1%C2%A0">4. Spring Boot与任务 </h2> 
<h3 id="4.1%C2%A0%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B">4.1 新建工程</h3> 
<p><img alt="" height="191" src="https://images2.imgbox.com/15/4d/DIVjpG8m_o.png" width="580"></p> 
<p><img alt="" height="343" src="https://images2.imgbox.com/c6/86/Tp9gEPRz_o.png" width="581"></p> 
<p> <img alt="" height="144" src="https://images2.imgbox.com/1b/67/4cnnGFhw_o.png" width="574"></p> 
<h3 id="4.2%20%E5%90%8C%E6%AD%A5%E8%B0%83%E7%94%A8%C2%A0">4.2 同步调用 </h3> 
<p><span style="color:#fe2c24;">如果同步访问hello，那么需要等待5秒钟才会返回结果</span></p> 
<pre><code class="language-java">@Service
public class AsyncService {
    public void hello() {
        try {
            Thread.sleep(5000);//模拟处理业务，耗时5秒
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("处理数据中。。。。");
    }
}</code></pre> 
<pre><code class="language-java">@RestController
public class AsyncController {

    @Autowired
    private AsyncService asyncService;

    @RequestMapping("/hello")
    public String hello(){
        asyncService.hello();
        return "success";
    }
}</code></pre> 
<h3 id="4.3%C2%A0%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%C2%A0">4.3 异步调用 </h3> 
<p><span style="color:#fe2c24;">如果异步访问hello，那么不需要等待那5秒钟，直接返回结果</span></p> 
<pre><code class="language-java">public class AsyncService {
    
    @Async //异步调用
    public void hello() {
        try {
            Thread.sleep(5000);//模拟处理业务，耗时5秒
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("处理数据中。。。。");
    }
}</code></pre> 
<pre><code class="language-java">@EnableAsync //开启异步注解功能
@SpringBootApplication
public class SpringbootTaskApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootTaskApplication.class, args);
    }
}</code></pre> 
<p></p> 
<h3 id="4.4%C2%A0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1">4.4 定时任务</h3> 
<h4 id="4.4.1%20%E7%AE%80%E4%BB%8B">4.4.1 简介</h4> 
<blockquote> 
 <p>       项目开发中经常需要执行一些定时任务，比如需要在每天凌晨时候，分析一次前一天的日志信息。Spring为我们提供了异步执行任务调度的方式，提供TaskExecutor、TaskScheduler接口。</p> 
 <p>       两个注解：@EnableScheduling、@Scheduled</p> 
</blockquote> 
<h4 id="4.4.2%C2%A0cron%E8%A1%A8%E8%BE%BE%E5%BC%8F">4.4.2 cron表达式</h4> 
<blockquote> 
 <p><span style="color:#1a439c;"><strong>字段            允许值                                            允许的特殊字符 </strong></span><br><span style="color:#ed7976;">秒               0-59                                                    , - * / </span><br><span style="color:#a2e043;">分               0-59                                          , - * /</span><span style="color:#98c091;"> </span><br><span style="color:#ed7976;">小时            0-23                               , - * / </span><br><span style="color:#a2e043;">日期            1-31                                                    , - * ? / L W C </span><br><span style="color:#faa572;">月份            1-12 或者 JAN-DEC              , - * / </span><br><span style="color:#4da8ee;">星期            0-7或SUN-SAT，0和7都是SUN          , - * ? / L C # </span><br><span style="color:#ed7976;">年（可选） 留空, 1970-2099                   , - * / </span></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#98c091;">*   表示所有值</span><br><span style="color:#ed7976;">?  表示不关心它为何值。一般用于日和星期冲突。确定日是几，则星期为?。确定是星期几，则日为？</span><br><span style="color:#98c091;">-   表示区间</span><br><span style="color:#ed7976;">,   表示枚举 </span><br><span style="color:#98c091;">/   符号前表示开始时间，符号后表示每次递增的值</span><br><span style="color:#ed7976;">L   最后</span> <br><span style="color:#1c7331;">W 工作日</span><br><span style="color:#ed7976;">C 指和calendar联系后计算过的值</span></p> 
</blockquote> 
<pre><code class="language-java">@Service
public class ScheduledService {
    /**
     * second minute hour dayOfMonth month dayOfWeek
     * 秒       分    时      日       月     周几
     *  0 0/5 14,18 * * ?    每天14点整和18点整，每隔5分钟执行一次
     *  0 15 10 ? * 1-6      每个月的周一至周六10:15分执行一次
     *  0 0 2 ? * 6L         每个月的最后一个周六凌晨2点执行一次
     *  0 0 2 LW * ?         每个月的最后一个工作日凌晨2点执行一次
     *  0 0 2-4 ? * 1#1      每个月的第一个周一凌晨2点到4点期间，每个整点都执行一次
     *  0/4 * * * * MON-SAT  周一到周六每隔4秒执行一次
     */
    @Scheduled(cron = "0 * * * * MON-FRI")
    public void hello(){
        System.out.println("周一到周五每分钟就执行一次......");
    }
}</code></pre> 
<h3 id="4.5%20%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1">4.5 邮件服务</h3> 
<pre><code class="language-XML">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;
        &lt;/dependency&gt;</code></pre> 
<p><span style="background-color:#fef2f0;">application.properties</span></p> 
<pre><code class="language-bash">spring.mail.username=1074005204@qq.com
spring.mail.password=odaptjcssvpnhgch
spring.mail.host=smtp.qq.com</code></pre> 
<pre><code class="language-java">@SpringBootTest
public class SpringbootApplicationTests {

    @Autowired
    private JavaMailSenderImpl mailSender;

    @Test
    public void sendSimpleMail() {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setSubject("通知-今晚开会");
        message.setText("今晚19：30开会");
        message.setTo("dream98job@126.com");
        message.setFrom("1074005204@qq.com");
        mailSender.send(message);
    }

    @Test
    public void sendMimeMail() throws MessagingException {
        MimeMessage mimeMessage = mailSender.createMimeMessage();
        MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);
        helper.setSubject("通知-今晚开会");

        helper.setText("&lt;b style='color:red'&gt;今晚19：30开会&lt;/b&gt;",true);
        helper.setTo("dream98job@126.com");
        helper.setFrom("1074005204@qq.com");
        helper.addAttachment("a.jpg",new File("E:\\MySelfPic\\P80204-150655.jpg"));
        mailSender.send(mimeMessage);
    }
}</code></pre> 
<h2></h2> 
<h2 id="5.%20Spring%20Boot%E4%B8%8E%E5%AE%89%E5%85%A8">5. Spring Boot与安全</h2> 
<h3 id="5.1%20Spring%20Security%E7%AE%80%E4%BB%8B"><span style="color:#333333;">5.1 Spring Security简介</span></h3> 
<blockquote> 
 <p><span style="color:#ff0000;">        Spring Security</span><span style="color:#000000;">是针对</span><span style="color:#000000;">Spring</span><span style="color:#000000;">项目的安全框架，也是</span><span style="color:#000000;">Spring Boot</span><span style="color:#000000;">底层安全模块默认的技术选型。他可以实现强大的</span><span style="color:#000000;">web</span><span style="color:#000000;">安全控制。对于安全控制，我们仅需</span><span style="color:#ff0000;">引入</span><span style="color:#ff0000;">spring-boot-starter-security</span><span style="color:#000000;">模块，进行少量的配置，即可实现强大的安全管理。</span></p> 
 <p><span style="color:#000000;">        应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。这两个主要区域是Spring Security 的两个目标。</span></p> 
 <p><span style="color:#000000;">        “认证”（Authentication），是建立一个他声明的主体的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统）。你是谁？</span></p> 
 <p><span style="color:#000000;">        “授权”（Authorization）指确定一个主体是否允许在你的应用程序执行一个动作的过程。你有什么权限？</span></p> 
</blockquote> 
<h3 id="5.2%20%E6%90%AD%E5%BB%BA%E5%B7%A5%E7%A8%8B">5.2 搭建工程</h3> 
<p><img alt="" height="179" src="https://images2.imgbox.com/55/ca/QpiaOLDs_o.png" width="671"></p> 
<p></p> 
<h2 id="6.%20Spring%20Boot%E4%B8%8ESpring%20Cloud">6. Spring Boot与Spring Cloud</h2> 
<h3 id="6.1%20Spring%20Cloud%E7%AE%80%E4%BB%8B">6.1 Spring Cloud简介</h3> 
<blockquote> 
 <p style="margin-left:0in;text-align:left;"><span style="color:#000000;">Spring Cloud是一个分布式的整体解决方案。</span><span style="color:#000000;">Spring Cloud </span><span style="color:#000000;">为开发者提供了</span><span style="color:#000000;"><strong>在分布式系统（配置管理，服务发现，熔断，路由，微代理，控制总线，一次性</strong></span><span style="color:#000000;"><strong>token</strong></span><span style="color:#000000;"><strong>，全局琐，</strong></span><span style="color:#000000;"><strong>leader</strong></span><span style="color:#000000;"><strong>选举，分布式</strong></span><span style="color:#000000;"><strong>session</strong></span><span style="color:#000000;"><strong>，集群状态）中快速构建的工具</strong></span><span style="color:#000000;">，使用</span><span style="color:#000000;">Spring Cloud</span><span style="color:#000000;">的开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。</span></p> 
 <p style="margin-left:0in;text-align:left;"><span style="color:#000000;"><strong>SpringCloud</strong></span><span style="color:#000000;"><strong>分布式开发五大常用组件</strong></span></p> 
 <p style="margin-left:0in;text-align:left;"><span style="color:#000000;">        服务发现——Netflix Eureka</span></p> 
 <p style="margin-left:0in;text-align:left;"><span style="color:#000000;">        客服端负载均衡——Netflix Ribbon</span></p> 
 <p style="margin-left:0in;text-align:left;"><span style="color:#000000;">        断路器——Netflix Hystrix</span></p> 
 <p style="margin-left:0in;text-align:left;"><span style="color:#000000;">        服务网关——Netflix Zuul</span></p> 
 <p style="margin-left:0in;text-align:left;"><span style="color:#000000;">        分布式配置——Spring Cloud Config</span></p> 
</blockquote> 
<h3 id="6.2%20%E6%90%AD%E5%BB%BA%E5%B7%A5%E7%A8%8B">6.2 搭建工程</h3> 
<h4 id="6.2.1%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-Eureka">6.2.1 注册中心-<span style="color:#000000;">Eureka</span></h4> 
<p><img alt="" height="206" src="https://images2.imgbox.com/72/81/AuvKbCJr_o.png" width="639"></p> 
<p> <img alt="" height="389" src="https://images2.imgbox.com/4b/ce/6rFgdqxk_o.png" width="636"></p> 
<p><img alt="" height="161" src="https://images2.imgbox.com/d6/1c/vUpEP1D7_o.png" width="635"></p> 
<p> <span style="color:#fe2c24;"><span style="background-color:#e7fafa;">application.yml</span></span></p> 
<pre><code class="language-bash">server:
  port: 8761
eureka:
  instance:
    hostname: eureka-server #eureka实例的主机名
  client:
    register-with-eureka: false #不把自己注册到eureka上
    fetch-registry: false #不从eureka上来获取服务的注册信息
    service-url:
      defaultZone: http://localhost:8761/eureka/</code></pre> 
<pre><code class="language-java">@EnableEurekaServer
@SpringBootApplication
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}</code></pre> 
<p>登录 <a class="link-info" href="http://localhost:8761" rel="nofollow" title="http://localhost:8761">http://localhost:8761</a> </p> 
<p><span style="color:#ed7976;">目前显示还没有服务注册进来</span> </p> 
<p><img alt="" height="284" src="https://images2.imgbox.com/0f/03/wF7QBrg9_o.png" width="656"></p> 
<h4 id="6.2.2%C2%A0%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85">6.2.2 服务提供者</h4> 
<p><img alt="" height="390" src="https://images2.imgbox.com/9c/c5/9F79L6MX_o.png" width="628"></p> 
<p><img alt="" height="161" src="https://images2.imgbox.com/f0/a2/53p67Zn5_o.png" width="614"></p> 
<pre><code class="language-java">@Service
public class TicketService {
    public String getTicket() {
        return "《敲代码的人真帅》";
    }
}</code></pre> 
<pre><code class="language-java">@RestController
public class TicketController {

    @Autowired
    private TicketService ticketService;

    @GetMapping("/ticket")
    public String getTicket(){
        return ticketService.getTicket();
    }
}</code></pre> 
<p><span style="color:#fe2c24;"><span style="background-color:#d4e9d5;">application.yml</span></span></p> 
<pre><code class="language-bash">server:
  port: 8001
spring:
  application:
    name: provider-ticket
eureka:
  instance:
    prefer-ip-address: true #注册服务时 使用服务的IP
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/</code></pre> 
<p>  <span style="color:#ed7976;">分别设置不同端口，打成两个jar包</span> </p> 
<p><img alt="" height="60" src="https://images2.imgbox.com/98/78/XOUlbZ2M_o.png" width="681"></p> 
<pre><code class="language-bash">java -jar  provider-ticket-0.0.1-SNAPSHOT-8001.jar
java -jar  provider-ticket-0.0.1-SNAPSHOT-8002.jar</code></pre> 
<p><img alt="" height="91" src="https://images2.imgbox.com/9f/82/ZVgvYlWZ_o.png" width="418"></p> 
<p><span style="color:#ed7976;">此时服务被注册进来</span></p> 
<p><img alt="" height="19" src="https://images2.imgbox.com/d2/41/J537r4C9_o.png" width="621"></p> 
<p></p> 
<h4 id="%C2%A06.2.3%C2%A0%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85"> 6.2.3 服务消费者</h4> 
<p><img alt="" height="375" src="https://images2.imgbox.com/e1/18/RrSuf8fP_o.png" width="604"></p> 
<p><img alt="" height="251" src="https://images2.imgbox.com/e1/18/VzgsRYs5_o.png" width="670"></p> 
<p> <span style="color:#fe2c24;"><span style="background-color:#d4e9d5;">application.yml</span></span></p> 
<pre><code class="language-bash">server:
  port: 8200
spring:
  application:
    name: consumer-user
eureka:
  instance:
    prefer-ip-address: true #注册服务时 使用服务的IP
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/</code></pre> 
<pre><code class="language-java">@EnableDiscoveryClient //开启发现服务功能
@SpringBootApplication
public class ConsumerUserApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConsumerUserApplication.class, args);
    }

    @LoadBalanced //使用负载均衡机制
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}</code></pre> 
<pre><code class="language-java">@RestController
public class UserController {
    @Autowired
    private RestTemplate restTemplate;

    @GetMapping("/buy")
    public String buyTicket(String name) {
        String str = restTemplate.getForObject("http://PROVIDER-TICKET/ticket", String.class);
        return "购买了"+str;
    }
}</code></pre> 
<p> 启动后</p> 
<p><img alt="" height="65" src="https://images2.imgbox.com/7e/19/ucFwQalC_o.png" width="637"></p> 
<p> <img alt="" height="117" src="https://images2.imgbox.com/a3/7e/2T9EwiRM_o.png" width="480"></p> 
<h2 id="%C2%A07.%C2%A0Spring%20Boot%E4%B8%8E%E5%BC%80%E5%8F%91%E7%83%AD%E9%83%A8%E7%BD%B2"> 7. <span style="color:#000000;">Spring Boot</span><span style="color:#000000;">与开发热部署</span></h2> 
<h3 id="7.1%20%E6%8C%89%E7%85%A76%E7%9A%84%E5%86%85%E5%AE%B9%E7%BB%A7%E7%BB%AD%E5%B0%86%2Fbuy%E6%94%B9%E4%B8%BA%2Fbuy2"><span style="color:#000000;">7.1 按照6的内容继续将/buy改为/buy2</span></h3> 
<pre><code class="language-java">@RestController
public class UserController {
    @Autowired
    private RestTemplate restTemplate;

    @GetMapping("/buy2")
    public String buyTicket(String name) {
        String str = restTemplate.getForObject("http://PROVIDER-TICKET/ticket", String.class);
        return "购买了"+str;
    }
}</code></pre> 
<p> <img alt="" height="194" src="https://images2.imgbox.com/76/7a/kRtbc6J5_o.png" width="646"></p> 
<h3 id="%C2%A07.2%20%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%E5%B9%B6%E9%87%8D%E5%90%AF%C2%A0"> 7.2 引入依赖并重启 </h3> 
<pre><code class="language-XML">&lt;dependency&gt;  
       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  
       &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;   
&lt;/dependency&gt; 
</code></pre> 
<h3 id="%C2%A07.3%20%E5%B0%86%2Fbuy2%E6%94%B9%E4%B8%BA%2FbuyTicket"> 7.3 <span style="color:#000000;">将/buy2改为/buyTicket</span></h3> 
<pre><code class="language-java">@RestController
public class UserController {
    @Autowired
    private RestTemplate restTemplate;

    @GetMapping("/buyTicket")
    public String buyTicket(String name) {
        String str = restTemplate.getForObject("http://PROVIDER-TICKET/ticket", String.class);
        return name + "购买了"+str;
    }
}</code></pre> 
<p><span style="color:#fe2c24;">按 <strong><span style="background-color:#d4e9d5;">Ctrl + F9</span></strong>让代码生效</span> </p> 
<p><img alt="" height="120" src="https://images2.imgbox.com/14/9e/6Yvr8onH_o.png" width="530"></p> 
<p></p> 
<h2 id="8.Spring%20Boot%E4%B8%8E%E7%9B%91%E6%8E%A7%E7%AE%A1%E7%90%86">8.<span style="color:#000000;">Spring Boot</span><span style="color:#000000;">与监控管理</span></h2> 
<h3 id="8.1%20%E7%AE%80%E4%BB%8B"><span style="color:#000000;">8.1 简介</span></h3> 
<blockquote> 
 <p style="margin-left:0in;text-align:left;"><span style="color:#000000;">        通过引入</span><span style="color:#000000;">spring-boot-starter-actuator</span><span style="color:#000000;">，可以使用</span><span style="color:#000000;">Spring Boot</span><span style="color:#000000;">为我们提供的准生产环境下的应用监控和管理功能。我们可以</span><span style="color:#000000;">通过</span><span style="color:#000000;">HTTP</span><span style="color:#000000;">，</span><span style="color:#000000;">JMX</span><span style="color:#000000;">，</span><span style="color:#000000;">SSH</span><span style="color:#000000;">协议来进行操作，自动得到审计、健康及指标信息等</span></p> 
 <p style="margin-left:0in;text-align:left;"><span style="color:#000000;">        步骤：</span></p> 
 <p style="margin-left:0in;text-align:left;"><span style="color:#000000;">                引入spring-boot-starter-actuator</span></p> 
 <p style="margin-left:0in;text-align:left;"><span style="color:#000000;">                通过http</span><span style="color:#000000;">方式访问监控端点</span></p> 
 <p style="margin-left:0in;text-align:left;"><span style="color:#000000;">                </span><span style="color:#000000;">可进行</span><span style="color:#000000;">shutdown</span><span style="color:#000000;">（</span><span style="color:#000000;">POST 提交，此端点默认关闭）</span></p> 
</blockquote> 
<h3 id="8.2%20%E6%90%AD%E5%BB%BA%E5%B7%A5%E7%A8%8B">8.2 搭建工程</h3> 
<p><img alt="" height="221" src="https://images2.imgbox.com/ed/c4/PaFMvg8I_o.png" width="665"></p> 
<p></p> 
<p><img alt="" height="384" src="https://images2.imgbox.com/00/f6/QFEbsmqc_o.png" width="659"></p> 
<p><img alt="" height="219" src="https://images2.imgbox.com/52/60/kzypoT15_o.png" width="659"></p> 
<p><a href="http://localhost:8080/actuator/" rel="nofollow" title="localhost:8080/actuator/">localhost:8080/actuator/</a></p> 
<p><img alt="" height="290" src="https://images2.imgbox.com/86/66/aydKecFp_o.png" width="659"></p> 
<p> <span style="color:#ed7976;">相关内容</span>：<a href="https://blog.csdn.net/qq_30426943/article/details/128512665?spm=1001.2014.3001.5502" title="谈谈SpringBoot（一）">谈谈SpringBoot（一）</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ad18b09e7291129c73084d4c9eaebb2b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网线直连NUC调试并使用VSCode实现X11转发（Jetson，树莓派适用）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf45b1a63b9af6086e88189e39c6ac55/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;：拷贝构造函数之指针悬挂（深拷贝与浅拷贝）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>