<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux基础知识笔记 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux基础知识笔记" />
<meta property="og:description" content="韩顺平2021Linux课程，视频地址：【小白入门 通俗易懂】2021韩顺平 一周学会Linux_哔哩哔哩_bilibili
文章目录 Linux 基础知识
目录结构（一切皆为文件）
vim的使用
关机&amp;重启命令
用户管理
指定运行级别
帮助指令
文件目录类
时间日期类
搜索查找类
压缩和解压缩
组权限和权限管理
crond任务调度
磁盘分区，挂载
网络配置
进程管理
服务管理
包管理工具
系统设置
Shell脚本
Linux运维知识
日志
备份与恢复
Linux 可视化管理
Linux面试题
统计访问量和连接数
找回Mysql root密码
访问量排名和tcpdump
系统权限划分
ssh连接虚拟机
Linux 基础知识 目录结构（一切皆为文件） 常用：
/bin （/usr /bin,/usr/local/bin） ：存放常用命令。
/home ：存放普通用户的主目录。
/root ：系统管理员主目录。
/etc ：所有系统管理所需要的配置文件和子目录，比如mysql中的my.conf。
/usr ：用户应用程序都放在该目录，类似windows中的program files。
/boot ：存放启动linux时使用的一些核心文件，包括一些连接文件以及镜像文件 [勿动]。
/media ：linux会自动识别一些设备，例如U盘，识别后，将识别的设备挂载到该目录。
/mnt ：系统提供该目录是为了让用户临时挂载别的文件系统，可以把外部的存储挂载在/mnt/上，然后进入该目录查看内容，如虚拟机与主机共享的文件夹。
/usr/local：用户级的程序目录，可以理解为C:/Progrem Files/。用户自己编译的软件默认会安装到这个目录下。
/usr/src：系统级的源码目录。
/usr/local/src：用户级的源码目录。
/var ：存放不断扩充修改的文件，包括各种日志文件。
了解：
/opt ：给主机额外安装软件所摆放的目录，如安装oracle数据库就可放到该目录，默认为空。可以理解为D:/Software，opt有可选的意思，当你不需要时，直接rm -rf掉即可。在硬盘容量不够时，也可将/opt单独挂载到其他磁盘上使用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/54d9ec5ec2a488809647737a729bbb1a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-06T15:06:37+08:00" />
<meta property="article:modified_time" content="2022-07-06T15:06:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux基础知识笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>韩顺平2021Linux课程，视频地址：<a href="https://www.bilibili.com/video/BV1Sv411r7vd" rel="nofollow" title="【小白入门 通俗易懂】2021韩顺平 一周学会Linux_哔哩哔哩_bilibili">【小白入门 通俗易懂】2021韩顺平 一周学会Linux_哔哩哔哩_bilibili</a></p> 
</blockquote> 
<div> 
 <h4 id="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">文章目录</h4> 
 <ul><li> <p id="Linux%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-toc" style="margin-left:0px;"><a href="#Linux%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" rel="nofollow">Linux 基础知识</a></p> <p id="%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%E5%88%87%E7%9A%86%E4%B8%BA%E6%96%87%E4%BB%B6%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%E5%88%87%E7%9A%86%E4%B8%BA%E6%96%87%E4%BB%B6%EF%BC%89" rel="nofollow">目录结构（一切皆为文件）</a></p> <p id="vim%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#vim%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">vim的使用</a></p> <p id="%E5%85%B3%E6%9C%BA%26%E9%87%8D%E5%90%AF%E5%91%BD%E4%BB%A4-toc" style="margin-left:80px;"><a href="#%E5%85%B3%E6%9C%BA%26%E9%87%8D%E5%90%AF%E5%91%BD%E4%BB%A4" rel="nofollow">关机&amp;重启命令</a></p> <p id="%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><a href="#%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86" rel="nofollow">用户管理</a></p> <p id="%E6%8C%87%E5%AE%9A%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB-toc" style="margin-left:80px;"><a href="#%E6%8C%87%E5%AE%9A%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB" rel="nofollow">指定运行级别</a></p> <p id="%E5%B8%AE%E5%8A%A9%E6%8C%87%E4%BB%A4-toc" style="margin-left:80px;"><a href="#%E5%B8%AE%E5%8A%A9%E6%8C%87%E4%BB%A4" rel="nofollow">帮助指令</a></p> <p id="%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%B1%BB" rel="nofollow">文件目录类</a></p> <p id="%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BB" rel="nofollow">时间日期类</a></p> <p id="%E6%90%9C%E7%B4%A2%E6%9F%A5%E6%89%BE%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%E6%90%9C%E7%B4%A2%E6%9F%A5%E6%89%BE%E7%B1%BB" rel="nofollow">搜索查找类</a></p> <p id="%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9-toc" style="margin-left:80px;"><a href="#%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9" rel="nofollow">压缩和解压缩</a></p> <p id="%E7%BB%84%E6%9D%83%E9%99%90%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><a href="#%E7%BB%84%E6%9D%83%E9%99%90%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86" rel="nofollow">组权限和权限管理</a></p> <p id="crond%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6-toc" style="margin-left:80px;"><a href="#crond%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6" rel="nofollow">crond任务调度</a></p> <p id="%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%EF%BC%8C%E6%8C%82%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%EF%BC%8C%E6%8C%82%E8%BD%BD" rel="nofollow">磁盘分区，挂载</a></p> <p id="%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE" rel="nofollow">网络配置</a></p> <p id="%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><a href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86" rel="nofollow">进程管理</a></p> <p id="%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><a href="#%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86" rel="nofollow">服务管理</a></p> <p id="%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-toc" style="margin-left:80px;"><a href="#%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7" rel="nofollow">包管理工具</a></p> <p id="%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE-toc" style="margin-left:80px;"><a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE" rel="nofollow">系统设置</a></p> <p id="Shell%E8%84%9A%E6%9C%AC-toc" style="margin-left:80px;"><a href="#Shell%E8%84%9A%E6%9C%AC" rel="nofollow">Shell脚本</a></p> <p id="Linux%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86-toc" style="margin-left:0px;"><a href="#Linux%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86" rel="nofollow">Linux运维知识</a></p> <p id="%E6%97%A5%E5%BF%97-toc" style="margin-left:80px;"><a href="#%E6%97%A5%E5%BF%97" rel="nofollow">日志</a></p> <p id="%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D-toc" style="margin-left:80px;"><a href="#%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D" rel="nofollow">备份与恢复</a></p> <p id="Linux%20%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><a href="#Linux%20%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86" rel="nofollow">Linux 可视化管理</a></p> <p id="Linux%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:0px;"><a href="#Linux%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">Linux面试题</a></p> <p id="%E7%BB%9F%E8%AE%A1%E8%AE%BF%E9%97%AE%E9%87%8F%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E7%BB%9F%E8%AE%A1%E8%AE%BF%E9%97%AE%E9%87%8F%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%95%B0" rel="nofollow">统计访问量和连接数</a></p> <p id="%E6%89%BE%E5%9B%9EMysql%20root%E5%AF%86%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E6%89%BE%E5%9B%9EMysql%20root%E5%AF%86%E7%A0%81" rel="nofollow">找回Mysql root密码</a></p> <p id="%E8%AE%BF%E9%97%AE%E9%87%8F%E6%8E%92%E5%90%8D%E5%92%8Ctcpdump-toc" style="margin-left:80px;"><a href="#%E8%AE%BF%E9%97%AE%E9%87%8F%E6%8E%92%E5%90%8D%E5%92%8Ctcpdump" rel="nofollow">访问量排名和tcpdump</a></p> <p id="%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E5%88%92%E5%88%86-toc" style="margin-left:80px;"><a href="#%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E5%88%92%E5%88%86" rel="nofollow">系统权限划分</a></p> <p id="ssh%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA-toc" style="margin-left:40px;"><a href="#ssh%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA" rel="nofollow">ssh连接虚拟机</a></p> 
   <hr id="hr-toc"><p></p> </li></ul> 
</div> 
<hr> 
<h2><a id="_7"></a></h2> 
<h2 id="Linux%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">Linux 基础知识</h2> 
<h4 id="%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%E5%88%87%E7%9A%86%E4%B8%BA%E6%96%87%E4%BB%B6%EF%BC%89">目录结构（一切皆为文件）</h4> 
<p>常用：</p> 
<p>/bin （/usr /bin,/usr/local/bin） ：存放<u><em>常用命令</em></u>。</p> 
<p>/home ：存放<u><em>普通用户的主目录</em></u>。</p> 
<p>/root ：<u><em>系统管理员主目录</em></u>。</p> 
<p>/etc ：所有系统管理所需要的<u><em>配置文件和子目录</em></u>，比如mysql中的my.conf。</p> 
<p>/usr ：<u><em>用户应用程序</em></u>都放在该目录，类似windows中的program files。</p> 
<p>/boot ：存放<u><em>启动linux时使用的一些核心文件</em></u>，包括一些连接文件以及镜像文件 [勿动]。</p> 
<p>/media ：linux会自动识别一些设备，例如U盘，识别后，将<em><u>识别的设备挂载到该目录</u></em>。</p> 
<p>/mnt ：系统提供该目录是为了让<u><em>用户临时挂载别的文件系统</em></u>，可以把外部的存储挂载在/mnt/上，然后进入该目录查看内容，如虚拟机与主机共享的文件夹。</p> 
<p>/usr/local：<em><u>用户级的程序目录</u></em>，可以理解为C:/Progrem Files/。用户自己编译的软件默认会安装到这个目录下。</p> 
<p>/usr/src：<u><em>系统级的源码目录</em></u>。</p> 
<p>/usr/local/src：<u><em>用户级的源码目录</em></u>。</p> 
<p>/var ：<u><em>存放不断扩充修改的文件</em></u>，包括各种日志文件。</p> 
<p>了解：</p> 
<p>/opt ：给主机额外<u><em>安装软件所摆放的目录</em></u>，如安装oracle数据库就可放到该目录，默认为空。可以理解为D:/Software，opt有可选的意思，当你不需要时，直接rm -rf掉即可。在硬盘容量不够时，也可将/opt单独挂载到其他磁盘上使用。</p> 
<p>/dev ：类似windows的设备管理器，把所有<u><em>硬件用文件的形式</em></u>存储。</p> 
<p>/lib ：<u><em>系统开机所需要最基本的动态连接共享库</em></u>，类似windows里的DLL文件，几乎所有应用程序都需要这些共享库。</p> 
<p>/sbin ：系统管理员使用的<u><em>系统管理程序</em></u>。</p> 
<p>/lost+found ：一般是空目录，当系统非法关机后就存放一些文件。</p> 
<p>/proc ：虚拟目录，系统内存的映射，<u><em>访问该目录来获取系统信息</em></u>[勿动]。</p> 
<p>/srv (service缩写) ：存放一些服务启动之后需要提取的数据[勿动]。</p> 
<p>/sys ：存放<u><em>文件系统sysfs</em></u> [勿动]。</p> 
<p>/tmp ：存放临时文件 。</p> 
<p>/selinux ：一种<u><em>安全子系统</em></u>，控制程序只能访问特定文件，有三种工作模式。</p> 
<hr> 
<h4 id="vim%E7%9A%84%E4%BD%BF%E7%94%A8">vim的使用</h4> 
<p>打开： <code>vim/vi 文件名</code></p> 
<p><strong>正常模式</strong>，可以复制粘贴</p> 
<p>复制：<code>yy</code>（复制当前行），<code>5yy</code>复制当前行开始向下5行</p> 
<p>删除：<code>dd</code>（删除当前行），<code>5dd</code>删除当前行开始向下5行</p> 
<p>粘贴：<code>p</code> 粘贴</p> 
<p>编辑：<code>i/I</code> 进入<strong>插入模式</strong></p> 
<p>跳转最后一行：<code>G</code></p> 
<p>跳转第一行：<code>gg</code></p> 
<p>跳转到某一行：<code>行数，shift+g</code></p> 
<p>撤销输入：<code>u</code></p> 
<p>恢复撤销： <code>ctrl+r</code></p> 
<p><strong>命令模式</strong>：</p> 
<p>保存：编辑结束后按Esc退出，按冒号 ：或 / 斜杠进入命令模式，输入 wq（保存退出）或q（退出）或 q!（强制退出，不保存）</p> 
<p>文字查找：<code>/关键字 按n选中下一个</code></p> 
<p>显示行号： <code>:set nu</code></p> 
<p>不显示行号： <code>:set nonu</code></p> 
<hr> 
<h4 id="%E5%85%B3%E6%9C%BA%26%E9%87%8D%E5%90%AF%E5%91%BD%E4%BB%A4">关机&amp;重启命令</h4> 
<p><code>shutdown -h now</code> 立刻关机</p> 
<p><code>shutdown -h 1</code> 一分钟之后关机</p> 
<p><code>shutdown -r now</code> 重启计算机</p> 
<p><code>halt</code> 关机</p> 
<p><code>reboot</code> 立刻重启</p> 
<p><code>sync</code> 把内存的数据同步到磁盘</p> 
<p><strong>tip</strong> :目前所有关机&amp;重启命令都已经在关机前进行sync，但仍要小心。</p> 
<hr> 
<h4 id="%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86">用户管理</h4> 
<p>切换用户：<code>su - 用户名</code> / <code>su 用户名</code></p> 
<p>显示用户信息：<code>id 用户名</code></p> 
<p><strong>注销</strong> :在shell界面中（运行级别为3）输入<code>logout</code>/<code>exit</code>，root ——&gt;用户</p> 
<p></p> 
<p>默认添加（/home）：<code>useradd 用户名</code></p> 
<p>指定目录添加：<code>useradd -d /home/目录 用户名</code></p> 
<p>新增用户并分组：<code>useradd -g 用户组 用户名</code></p> 
<p></p> 
<p>修改用户分组：<code>usermod -g 新组名 用户名</code></p> 
<p>修改用户分组并更改登录初始目录：<code>usermod -d 目录名 用户名 改变该用户登陆的初始目录</code> <strong>tip</strong>:用户需要有进入新目录的权限</p> 
<p>将用户添加到某一个组中：<code>usermod -aG 新组名 用户名</code></p> 
<p>修改当前用户密码：<code>passwd</code>（通用）</p> 
<p>修改某一个用户密码：<code>passwd 用户名</code></p> 
<p></p> 
<p>删除用户，保留家目录：<code>userdel 用户名</code></p> 
<p>删除用户，不保留主目录：<code>userdel -r 用户名</code></p> 
<p></p> 
<p>查看当前登录用户：<code>whoami</code> / <code>who am I</code> （切换用户后仍显示连接时登录的用户）</p> 
<p>用户组 group</p> 
<p>——类似角色</p> 
<p>新增组：<code>groupadd 组名</code></p> 
<p>删除组：<code>groupdel 组名</code></p> 
<p>修改组名：<code>groupmod -n 新组名 原组名</code></p> 
<ul><li> <p>没有指定组时（默认生成root用户相同的组）</p> </li></ul> 
<p></p> 
<p>用户和组相关文件</p> 
<p>/etc/passwd</p> 
<ul><li> <p>用户(user)配置文件，记录用户的各种信息</p> </li><li> <p>每行的含义：用户名：口令：用户标识号：注释性描述：主目录：登录shell</p> </li></ul> 
<p>/etc/shadow</p> 
<ul><li> <p>口令的配置文件</p> </li><li> <p>每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</p> </li></ul> 
<p>/etc/group</p> 
<ul><li> <p>组的配置文件，记录Linux包含的组的信息</p> </li><li> <p>每行含义：组名：口令：组标识号：组内用户列表</p> </li></ul> 
<hr> 
<h4 id="%E6%8C%87%E5%AE%9A%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB">指定运行级别</h4> 
<ul><li> <p>指定运行级别（7个级别）</p> 
  <ol><li> <p>关机，系统停机状态，默认运行级别不能设置为0，否则不能正常启动</p> </li><li> <p>单用户【找回丢失密码】，root权限，用于系统维护，禁止远程登录</p> </li><li> <p>多用户状态没有网络服务（NFS），不支持网络</p> </li><li> <p>完全的多用户状态有网络服务，（multi-user.target）登陆后进入控制台命令行模式</p> </li><li> <p>系统未使用保留给用户</p> </li><li> <p>X11控制台，图形界面（终端界面，shell界面），（graphical.target）登录后进入GUI模式</p> </li><li> <p>系统正常关闭并重启，默认运行级别不能设置为6，否则不能正常启动</p> </li></ol></li><li> <p>系统的运行级别配置文件：/etc/inittab</p> </li><li> <p>切换到指定运行级别的指令：init [012356]</p> </li></ul> 
<p>获取当前运行级别：<code>systemctl get-default</code></p> 
<p>设置运行级别：<code>systemctl set-default 级别名称</code></p> 
<hr> 
<h4 id="%E5%B8%AE%E5%8A%A9%E6%8C%87%E4%BB%A4">帮助指令</h4> 
<ul><li> <p><code>man [命令或配置文件]</code>（功能描述：获得帮助信息）</p> </li><li> <p><code>help 命令</code> （功能描述：获得shell内置命令的帮助信息）</p> </li></ul> 
<hr> 
<h4 id="%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%B1%BB">文件目录类</h4> 
<ul><li> <p><code>pwd</code> （功能描述：显示当前工作目录的绝对路径）</p> </li><li> <p><code>ls [选项] [目录或是文件]</code></p> <p>-a ： 显示当前目录所有的文件和目录，包括隐藏的</p> <p>-l ： 以列表的方式显示信息</p> 
  <ul><li> <p><code>ls -l</code>命令，输出文件/目录的 10 位基本信息字符串 (0 - 9 位)</p> <pre>#其中第 0 位为此文件/目录的文件类型
#d / l / c / b --&gt; 目录（文件夹） / 链接 (快捷方式) / 字符设备 (键盘、鼠标等) / 块设备 (硬盘等)</pre> </li><li> <p><code>lsattr -a</code>命令，同样查看输出字符串的第 0 位，规则同 ls -l 指令的输出</p> </li></ul></li><li> <p><code>ll</code> 以列表的方式显示信息，包括隐藏文件</p> </li><li> <p><code>cd [参数]</code>（功能描述：切换到指定的目录）</p> <p>cd ~ 或者cd 回到自己的家目录</p> <p>cd .. 回到当前目录的上一级目录</p> </li><li> <p><code>mkdir [选项] 目录名称</code></p> <p>-p：创建多级目录。</p> <p><code>mkdir -pv /home/{*.txt,*.sql}</code>：创建多个目录或文件</p> <p><code>mkdir -pv /home/fd /home/df</code>：创建多个目录</p> </li><li> <p><code>rmdir 目录名称</code>：删除空目录。</p> </li><li> <p><code>touch 文件名称</code> （功能描述：创建空文件。可以一次性创建多个文件）</p> </li><li> <p><code>cp [选项] 资源路径 目标目录路径/</code> ：拷贝文件到指定目录；</p> <p>-r：递归复制整个文件夹。</p> <p>强制覆盖不提示的方法：cp命令改为\cp</p> </li><li> <p><code>rm [选项] 资源名称</code>：移除文件或目录；rm -rf 目录名称（可删除非空目录）</p> <p>-r：递归删除整个文件夹；</p> <p>-f：强制删除不提示。</p> </li><li> <p>mv：移动文件与目录或重命名</p> <p><code>mv oldfilename newfilename</code>（功能描述：同目录下为重命名）<code>mv pig.txt ca.txt</code></p> <p><code>mv 源资源路径 目标资源目录</code>（功能描述：不同目录下为移动文件）</p> <p><code>mv /home/pig.txt /root/</code>（只移动文件）</p> <p><code>mv /home/pig.txt /root/ca.txt</code> （移动文件并改名）</p> <p><code>mv /home/ca.txt /home/</code>（移动整个目录）</p> </li><li> <p><code>cat [选项] 要查看的文件</code></p> <p>-n :显示行号</p> <p>使用细节：cat<strong><u>只能浏览文件</u></strong>，而不能修改文件，为了浏览方便，一般会带上管道命令 | more</p> <p><code>cat -n /etc/profile | more</code></p> </li><li> <p><code>more</code>指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more指令中内置了若干快捷键（交互的指令）</p> </li></ul> 
<table><thead><tr><th>操作</th><th>功能说明</th></tr></thead><tbody><tr><td>空白键（Space）</td><td>向下翻一页</td></tr><tr><td>Enter</td><td>向下翻一行</td></tr><tr><td>q</td><td>立刻离开more，不再显示该文件内容</td></tr><tr><td>Ctrl + F</td><td>向下滚动一屏</td></tr><tr><td>Ctrl + B</td><td>返回上一屏</td></tr><tr><td>=</td><td>输出当前行的行号</td></tr><tr><td>：f</td><td>输出文件名和当前行的行号</td></tr></tbody></table> 
<ul><li> <p><code>less</code>指令用于分屏插卡文件内容，它的功能与<code>more</code>指令类似，但是比<code>more</code>指令更强大，支持各种显示终端。<code>less</code>指令在显示文件内容时，会根据显示需要加载内容，对于大型文件阅览具有较高的效率。</p> </li></ul> 
<table><thead><tr><th>操作</th><th>功能说明</th></tr></thead><tbody><tr><td>空格：</td><td>下一页</td></tr><tr><td>pagedown：</td><td>同上，下一页</td></tr><tr><td>pageup：</td><td>上一页</td></tr><tr><td>/XXX：</td><td>向下搜寻字符XXX，n=向下查找，N=向上查找</td></tr><tr><td>?XXX：</td><td>向上搜寻字符XXX，n=向上查找，N=向下查找</td></tr><tr><td>q：</td><td>退出</td></tr></tbody></table> 
<ul><li> <p><code>echo [选项] [要输出的内容]</code> 输出内容到控制台</p> <p><code>echo $HOSTNAME</code> / <code>echo "helloword"</code></p> <p>使用细节:要输出的内容可以是其他指令的执行结果，<code>echo</code>指令可配合其他指令使用</p> </li><li> <p><code>head [选项] [要输出的内容]</code> 默认显示文件头10行的内容</p> <p>显示文件的开头部分。-n 5：看前面5行内容。</p> </li><li> <p><code>tail [选项] [要输出的内容]</code>默认显示文件中尾10行的内容</p> <p>-n 5 ：看后面5行内容。</p> <p>-f ：<strong>实时追踪该文档的所有更新</strong>。</p> </li><li> <p><code>&gt;</code>/<code>&gt;&gt;</code> 输出重定向：覆写/追加，没有该文件则会创建</p> <p>指令<code>&gt;</code> 指令执行结果覆盖到的文件 指令 <code>&gt;&gt;</code> 指令执行结果追加到文件</p> <p><code>ls -l &gt; AAA</code>将当前工作目录下的文件列表覆盖写入 AAA 文件中 <code>ls -al &gt;&gt; AAA</code> 将当前工作目录下的所有文件列表追加到 AAA 文件的末尾 <code>cat 文件1 &gt; 文件2</code> 将 文件1 的内容覆盖写入 文件2 中 <code>echo 内容 &gt;&gt; 文件</code></p> </li><li> <p><code>ln -s</code> 创建软连接也称为符号链接(类似快捷方式)</p> <p><code>ln -s [原文件/目录路径] [软链接名]</code>在当前工作目录下创建软链接 <code>ln -s [原文件/目录路径] [指定目录+软链接名]</code>在指定目录下创建软链接</p> <p><strong>tip</strong> :<code>pwd</code>指令显示的路径为软链接所在路径</p> </li><li> <p><code>history</code> 指令历史记录</p> </li><li> <p>显示所有的历史命令 <code>history</code></p> </li><li> <p>显示最近 10 条历史指令 <code>history 10</code></p> </li><li> <p>执行历史编号为 5 的指令</p> <p><code>!5</code></p> </li><li> <p><code>wc</code> 计数指令</p> <p><code>wc [参数] [文件]</code></p> <p><code>-l</code> line：计算行数 <code>-c</code> 计算字节数 <code>-m</code> 计算字符数 <code>-w</code> 计算单词数</p> <p><strong>tip</strong>:若不加文件，则通常使用管道分隔符<code>|</code>，计算其他指令输出的计数</p> <p><em>计算 ls -l 输出中，以“d”开头的记录条数</em>: <code>ls -l /opt/ | grep "d" | wc -l</code></p> </li></ul> 
<hr> 
<h4 id="%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BB">时间日期类</h4> 
<ul><li> <p>date 显示当前时间</p> <p><code>date</code> 显示当前时间 <code>date +%Y</code> 显示当前年份 <code>data +%m</code> 显示当前月份 <code>date +%d</code> 显示当前日 <code>date "+%Y-%m-%d %H:%M:%S"</code> 显示”年-月-日 时:分:秒“ <code>date -R</code> 显示UTC标准时间格式 <code>date +%c</code> 根据当前时区地区设置显示的完整时间(中国显示：XX年XX月XX日 星期X XX时XX分XX秒) <code>date +%D</code> 显示“年/月/日” <code>date +%T</code> 显示“时:分:秒”</p> </li><li> <p>date -s 设置当前日期</p> <p><code>date -s 时间字符串</code></p> 
  <ol><li> <p>时间字符串格式 a. <code>Sun, 29 Feb 2004 16:21:42 -0800</code> b. <code>2004-02-29 16:21:42</code> c. <code>next Thursday</code></p> </li><li> <p>时间字符串要加双引号 “ ”</p> </li></ol></li><li> <p>cal 显示日历</p> <p><code>cal [选项] [日 月 年]</code></p> <p><code>cal 2022</code></p> </li></ul> 
<hr> 
<h4 id="%E6%90%9C%E7%B4%A2%E6%9F%A5%E6%89%BE%E7%B1%BB">搜索查找类</h4> 
<ul><li> <p><code>find</code>指令将从指定目录下递归的便利各个子目录，将满足条件的文件或者目录显示在终端</p> <p><code>find [搜索范围] [选项]</code></p> <p><code>find -name 名称表达式查找内容</code> 名称表达式：</p> 
  <ul><li> <p>可用通配符：*</p> </li><li> <p>可用正则表达式</p> <p>使用正则表达式时，单独使用 -regex 参数，不加 -name/uer/size等单数) 可有多个表达式，并用逻辑运算符连接(-and/-or/-not)</p> </li></ul><p><code>find -user 用户名文件所有者</code></p> <p><code>find -size 大小表达式文件大小</code></p> 
  <ul><li> <p>+aG大小大于a GB</p> </li><li> <p>-bM大小小于b MB</p> </li><li> <p>cK大小等于c KB</p> </li></ul></li><li> <p>locate 根据索引快速检索文件</p> <p><code>locate</code>指令可以快速定位文件路径</p> <p><code>locate</code>指令利用事先创建的文件和目录索引数据库实现文件快速搜索。</p> <p><code>locate</code>指令无需遍历查找文件，只需要查询索引数据库，因此速度较快。 <strong>但为保证查询结果的准确度，管理员必须要定期更新 locat数据库。</strong></p> <p><code>locate 文件名</code></p> <p><strong>tip</strong>在第一次运行locate指令前，需要使用updatedb指令创建locate索引数据库</p> </li><li> <p>grep：过滤查找，表示将前一个命令的处理结果输出传递给后面的命令处理。经常跟管道一起使用。</p> 
  <ul><li> <p><code>grep [选项] 查找内容 源文件</code></p> </li><li> <p><code>-n</code>：显示匹配行及行号。</p> </li><li> <p><code>-i</code>：忽略大小写字母。</p> </li><li> <p><code>-v</code>：只选中不匹配的行</p> </li><li> <p><code>cat hello.txt | grep "yes"</code></p> </li></ul></li><li> <p>which 查看指令所在目录 <code>which +指令名</code></p> </li></ul> 
<hr> 
<h4 id="%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9">压缩和解压缩</h4> 
<ul><li> <p><code>gzip</code>/<code>gunzip</code>指令</p> <p><code>gzip +文件名</code> 功能描述：压缩文件，智能将文件压缩为 *.gz 文件 <code>gunzip +文件名</code> 功能描述：解压缩.gz压缩文件</p> </li><li> <p><code>zip</code>/<code>unzip</code> 指令</p> </li><li> <p>zip用于压缩文件为zip 格式，unzip 用于将zip格式文件解压 压缩zip文件和目录：<code>zip [选项] XXX.zip 要压缩的文件/目录</code> 解压缩zip文件：<code>unzip [选项] XXX.zip</code> zip常用选项</p> 
  <ul><li> <p>-r 递归压缩，用于压缩整个目录</p> </li></ul><p>unzip常用选项</p> 
  <ul><li> <p>-d [目录] :解压到指定目录</p> </li></ul></li><li> <p>tar 指令 打包指令，打包后的文件是.tar.gz的文件 <code>tar [选项] +要打包的文件/目录(可有多个文件/目录)</code></p> </li></ul> 
<table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>产生.tar打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后的文件名</td></tr><tr><td>-z</td><td>打包同时压缩</td></tr><tr><td>-x</td><td>解包.tar文件</td></tr></tbody></table> 
<p><code>tar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt</code></p> 
<p><code>tar -zxvf myhome.tar.gz /opt/tmp2/</code></p> 
<hr> 
<h4 id="%E7%BB%84%E6%9D%83%E9%99%90%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86">组权限和权限管理</h4> 
<p>linux中的每个用户，必须属于一个组，不能独立于组外。 linux中的每个文件/目录，都有且仅有一个所有者。</p> 
<ul><li> <p>在liunx中有 <strong>所有者、所在组、其他组</strong> 等概念</p> 
  <ul><li> <p>所有者：文件/目录的所有者，一般来说文件/目录由谁创建则所有者就是谁，可以修改。</p> </li><li> <p>所在组：用于多个相同权限用户的管理，用户必须属于至少一个组，一个用户可以属于多个组，一个组可以包含多个用户。</p> </li><li> <p>其他组：对一个文件而言，除了所有者所属用户组以外的其他用户组，成为其他组，其他组对此文件也可设定一定权限。</p> </li></ul></li><li> <p><code>ll</code> 查看文件的所有者</p> <p><code>ls -alh</code> 列表显示、显示所有文件、按常见单位显示 列表显示的内容(从左往右)：</p> <p>权限、包含的文件/目录总数、所有者、所在组、文件大小（字节）、修改时间、名称</p> </li></ul> 
<p>修改所有者和所在组</p> 
<ul><li> <p>chown 修改文件/目录的所有者/所在组</p> <p><code>chown [选项] 新用户名：新用户组 文件名/目录名</code></p> <p><code>chown 新用户名 文件名/目录名</code> 将文件/目录所有者修改为对应用户，所在组不变 <code>chown :新用户组 文件名/目录名</code> 将文件/目录所在组更改，所有者不变 <code>chown 新用户名AAA:新组名BBB 文件名/目录名</code> 将文件/目录所有者/所在组 修改为 AAA/BBB</p> <p><code>-R</code> <strong>修改目录及其子文件、子目录的所有者和所在组</strong> <code>-h</code> 修改子文件中的软链接，而不是修改软链接指向的文件 <code>-v</code> 显示详细操作</p> </li><li> <p>chgrp修改文件/目录所在组</p> <p><code>chgrp [参数] 新组名 文件/目录名</code></p> <p><code>-R</code> 修改此目录下所有子目录/子文件的所在组 <code>-h</code> 修改此目录下软链接的所在组，而不是修改软链接指向的文件的所在组</p> <p></p> </li></ul> 
<p>权限介绍</p> 
<p>权限示例：<u>drwxr-xr-x</u> 2 hcx hcx 4096 7月 1 22:18 Videos/</p> 
<p>前边包含 r/w/x/- 等字符的部分，有 10 位。为文件类型、对应文件/目录的权限。</p> 
<ul><li> <p>第 0 位：文件类型(d, -, l, c, b) d：目录（directory，即文件夹） -：普通文件 l：链接（link，即快捷方式） c：字符设备(character devices)，如鼠标、键盘 b：块设备(block devices)，如硬盘等</p> </li><li> <p>第 1-3 位：所有者(Owner)的权限</p> </li><li> <p>第 4-6 位：所在组(Group)的权限</p> </li><li> <p>第 7-9 位：其他组(Other)的权限</p> </li></ul> 
<p>权限介绍(rwx的含义)</p> 
<ul><li> <p>对文件的 rwx <code>r</code>：可读(read)——可以读取、查看文件内容 <code>w</code>：可写(write)——可以修改，<u>只有同时对文件所在目录具备写权限才能删除文件。</u> <code>x</code>：可执行(execute)——可以执行 <code>-</code>：不具备此权限</p> </li><li> <p>对目录的 rwx <code>r</code>：可读(read)——可以查看此目录包含的内容，可用ls指令 <code>w</code>：可写(write)——可以创建，修改，重命名目录，可在此目录内新建、重命名、删除子文件/子目录，但不一定能进入文件或修改文件内容 <code>x</code>：可执行(execute)——可以进入此目录 <code>-</code>：不具备此权限</p> </li></ul> 
<p>修改权限</p> 
<p><code>chmod [选项] 权限表达式 文件/目录名</code></p> 
<p><code>-R</code> 递归的修改权限，同时修改目录、子目录、子文件的权限 <code>-v</code> 权限修改的详细信息</p> 
<ul><li> <p>字母形式详解 u=rwx,g+rw,o-r u，g，o三者顺序任意，省略不写则权限不变，逗号前后不能有间隔 u = 所有者 (用户，user) 权限，g = 所在组 (组，group) 权限，o = 其他组 (others) 权限 a = 所有组（包括以上全部 3 者）的权限 r，w，x三者顺序任意，省略不写则认为无此权限 r = 可读 (read)，w = 可写 (write)，x = 可执行 (execute) <strong>=</strong>，<strong>+</strong>，<strong>-</strong>为权限的设置模式</p> </li></ul> 
<ul><li> <p>数字形式详解</p> <p><code>chmod 751 文件/目录名</code>: 所有者：7 = 111 = rwx，所在组：5 = 101 = r-x，其他组：1= 001= --x</p> <p>3 位 10 进制数字，分别表示：所有者、所在组、其他组的权限</p> </li></ul> 
<hr> 
<h4 id="crond%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6">crond任务调度</h4> 
<p>crond是linux下用来<u>周期性</u>的<u>执行某种任务或等待处理某些事件</u>的一个<u>守护进程</u>，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。Linux下的任务调度分为两类，系统任务调度和用户任务调度。</p> 
<ul><li> <p>任务调度：系统定时、按照一定周期或规则，执行特定的命令或程序</p> </li><li> <p>任务调度分类：</p> 
  <ol><li> <p>系统任务：某些重要的任务需要周而复始的执行，如病毒扫描等</p> </li><li> <p>个别用户任务：个别用户希望执行的任务，如对 mysql 数据库的备份</p> </li></ol></li></ul> 
<p>crontab定时任务（周期性）</p> 
<p><code>crontab [选项]</code></p> 
<p><code>-e</code> 编辑 crontab 定时任务 ​ <code>-l</code> 查询 crontab 任务/列出当前有那些任务调度 ​ <code>-r</code> 删除当前用户所有的 crontab 任务/终止任务调度 ​ <code>service crond restart</code>重启任务调度</p> 
<ul><li> <p>示例</p> <p>设置任务调度文件：/etc/crontab</p> <p>设置个人任务调度，执行<code>crontab -e</code>命令</p> <p>输入任务到调度文件中</p> <p>如：<code>*/1 * * * * ls -l /etc/ &gt; /tmp/to.txt</code>（每小时每分钟执行该命令）</p> </li><li> <p>参数说明</p> </li></ul> 
<table><thead><tr><th>项目</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>第一个“*”</td><td>一小时当中的第几分钟</td><td>0-59</td></tr><tr><td>第二个“*”</td><td>一天当中的第几小时</td><td>0-23</td></tr><tr><td>第三个“*”</td><td>一个月当中的第几天</td><td>1-31</td></tr><tr><td>第四个“*”</td><td>一年当中的第几月</td><td>1-12</td></tr><tr><td>第五个“*”</td><td>一周当中的星期几</td><td>0-7（0和7都代表星期日）</td></tr></tbody></table> 
<ul><li> <p>特殊符号说明</p> 
  <ul><li> <p><code>*</code>：代表任何时间。比如第一个<code>*</code>就代表一小时中每分钟都执行一次的意思。</p> </li><li> <p><code>,</code>：代表不连续的时间。比如“0 8,12,16 * * *命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令。</p> </li><li> <p><code>-</code>：代表连续的时间范围。比如“0 5 * * 1-6命令”，代表在周一到周六的凌晨5点0分执行命令。</p> </li><li> <p><code>/n</code>：代表每隔多久执行一次。比如“*/10 * * * * 命令”，代表每隔10分钟就执行一遍命令。</p> </li></ul></li><li> <p>定时Shell脚本举例</p> <p><code>vim *.sh</code> ，编辑任务，给*.sh增加执行权限<code>chmod u+x *.sh</code>，<code>crontab -e</code> ，执行shell脚本</p> </li></ul> 
<p>at定时任务（一次性）</p> 
<ol><li> <p>at命令时一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列并运行</p> </li><li> <p>默认情况下，atd守护进程每 <strong>60</strong> 秒检查作业队列。队列有作业时，检查作业运行时间，若计划时间与当前时间匹配，则运行此作业。</p> </li><li> <p>at定时任务的最小间隔为 1 分钟</p> </li><li> <p>at命令是一次性定时计划任务，一个作业执行后不再执行该计划 在使用at命令时，一定要保证atd进程启动，可使用相关指令查看</p> <p><strong><code>ps -ef | grep atd</code></strong>（检测atd是否在运行）</p> </li></ol> 
<p>at命令格式：<code>at [选项] [时间]</code>，输入命令，Ctrl+D结束命令</p> 
<ul><li> <p>守护进程 atd 查看状态 <code>service atd status</code> <code>systemctl status atd</code> <code>ps -ef | grep "atd"</code> <code>ps -aux | grep "atd"</code></p> </li><li> <p>守护进程 atd 启动/停止/重启/查看进程状态 <code>service atd start/stop/restart/status</code> <code>systemctl start/stop/restart/status atd</code></p> </li></ul> 
<ul><li> <p>at命令选项</p> </li></ul> 
<table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-m</td><td>当指定的任务被完成后，将给用户发送邮件，即使没有标准输出</td></tr><tr><td>-I</td><td><code>atq</code>的别名，查看系统中没有执行的工作任务</td></tr><tr><td>-d</td><td><code>atrm</code>的别名，删除已经设置的任务</td></tr><tr><td>-v</td><td>显示任务将被执行的时间</td></tr><tr><td>-c</td><td>打印任务的内容到标准输出</td></tr><tr><td>-V</td><td>显示版本信息</td></tr><tr><td>-q &lt;队列&gt;</td><td>使用指定队列</td></tr><tr><td>-f &lt;文件&gt;</td><td>从指定文件读入任务而不是从标准输入读入</td></tr><tr><td>-t &lt;时间参数&gt;</td><td>以时间参数的形式提交要运行的任务</td></tr></tbody></table> 
<ul><li> <p>at时间定义</p> </li></ul> 
<table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>hh:mm</td><td>小时：分钟，加入该时间已经过去，放在第二天执行，Eg: at 04:00</td></tr><tr><td>midnight</td><td>晚上12点</td></tr><tr><td>noon</td><td>中午12点</td></tr><tr><td>teatime</td><td>下午4点</td></tr><tr><td>12小时制</td><td>在时间后加am或pm,Eg: at 05:00 pm，指定日期需要在指定时间后</td></tr><tr><td>month day</td><td>(月 日)</td></tr><tr><td>mm/dd/yy</td><td>(月/日/年)</td></tr><tr><td>dd.mm.yy</td><td>(日.月.年)</td></tr><tr><td>相对计时法</td><td>now + cout time-units,Eg: now + 5 minutes</td></tr><tr><td>today,tomorrow</td><td>直接指定</td></tr></tbody></table> 
<hr> 
<h4 id="%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%EF%BC%8C%E6%8C%82%E8%BD%BD">磁盘分区，挂载</h4> 
<p>磁盘分区与Linux文件系统</p> 
<ol><li> <p>Linux 系统中的文件系统的总体结构是一定的：只有一个根目录，根目录下的目录结构独立且唯一（如 /boot、/dev、/bin、/etc 目录等都是唯一的），Linux 中的磁盘分区都是文件系统中的一部分</p> </li><li> <p>Linux采用”载入“的方法，它的整个文件系统中包含一整套的文件和目录，且将一个分区和一个目录联系起来，此时要载入的一个分区将使它的存储空间在一个目录下获得。</p> </li><li> <p>任何目录或其父目录都要<strong>挂载</strong>到硬盘的某个分区下。如需要将某一分区<strong>挂载</strong>到根目录下，Linux 系统才能正常工作</p> </li><li> <p>某个分区所挂载的目录，称为此分区的<strong>挂载点</strong></p> </li><li> <p>磁盘的不同分区可以<strong>挂载</strong>到 Linux 文件系统的不同分区下，但不能同时<strong>挂载</strong>到一个相同的目录</p> </li></ol> 
<p>驱动器标识</p> 
<p>在 linux 系统中，会将硬盘和分区进行标识，表达不同分区的功能：</p> 
<p>Linux 硬盘有两种：IDE 硬盘 和 SCSI 硬盘（大部分）</p> 
<ul><li> <p>IDE 硬盘： 驱动器标识为：<code>hdx~</code> <code>hd</code>表示分区所在设备的类型，这里<code>hd</code>= IDE 硬盘 <code>x</code>为盘号，区分不同硬盘间的功能</p> 
  <table><thead><tr><th>标识</th><th>功能</th></tr></thead><tbody><tr><td>a</td><td>基本盘</td></tr><tr><td>b</td><td>基本从属盘</td></tr><tr><td>c</td><td>辅助主盘</td></tr><tr><td>d</td><td>辅助从属盘</td></tr></tbody></table><p><code>~</code>为分区号，区分同一硬盘上不同分区的功能</p> 
  <table><thead><tr><th>标识</th><th>功能</th></tr></thead><tbody><tr><td>1-4</td><td>主分区 或 扩展分区</td></tr><tr><td>5开始</td><td>逻辑分区</td></tr></tbody></table></li><li> <p>SCSI 硬盘： 驱动器标识为：<code>sdx~</code> <code>sd</code> 表示分区所在设备的类型，这里<code>sd</code>= SCSI 硬盘 <code>x</code>为盘号，区分不同硬盘间的功能 （盘号功能标识同 IDE 硬盘） <code>~</code> 为分区号，区分同一硬盘上不同分区的功能 （分区号功能标识同 IDE 硬盘）</p> </li></ul> 
<p>查看所有设备挂载情况</p> 
<p><code>lsblk [选项]</code></p> 
<p><code>-a</code> 查看所有设备(包括空设备) <code>-f</code> 查看文件系统信息 <code>-m</code> 查看设备权限 <code>-t</code> 查看分区详细信息</p> 
<ul><li> <p>查看基本信息：lsblk 和 lsblk -a</p> </li></ul> 
<p><code>NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT</code></p> 
<table><thead><tr><th>字符</th><th>类型</th></tr></thead><tbody><tr><td>NAME</td><td>驱动器标识</td></tr><tr><td>MAJ</td><td>主-设备号</td></tr><tr><td>MIN</td><td>次-设备号</td></tr><tr><td>RM</td><td>可热插拔设备</td></tr><tr><td>SIZE</td><td>分区/硬盘大小（默认使用易读的格式：K/M/G/T 等）</td></tr><tr><td>RO</td><td>只读设备</td></tr><tr><td>TYPE</td><td>分区所在的设备类型(同NAME中的类型)</td></tr><tr><td>MOUNTPOINT</td><td>挂载点</td></tr></tbody></table> 
<ul><li> <p>查看 Linux 文件系统信息：lsblk -f</p> </li></ul> 
<p><code>NAME FSTYPE LABEL UUID MOUNTPOINT</code></p> 
<table><thead><tr><th>字符</th><th>类型</th></tr></thead><tbody><tr><td>NAME</td><td>驱动器标识</td></tr><tr><td>FSTYPE</td><td>文件系统类型</td></tr><tr><td>LABLE</td><td>文件系统 LABLE</td></tr><tr><td>UUID</td><td>分区唯一标识符</td></tr><tr><td>MOUNTPOINT</td><td>挂载点</td></tr></tbody></table> 
<p>若仅分区，没有格式化，则FSTYPE和UUID均为空白</p> 
<ul><li> <p>查看分区权限信息：lsblk -m</p> </li></ul> 
<p><code>NAME SIZE OWNER GROUP MODE</code></p> 
<table><thead><tr><th>字符</th><th>类型</th></tr></thead><tbody><tr><td>NAME</td><td>驱动器标识</td></tr><tr><td>SIZE</td><td>分区/硬盘大小（默认使用易读的格式：K/M/G/T 等）</td></tr><tr><td>OWNER</td><td>分区所有者</td></tr><tr><td>GROUP</td><td>分区所在组</td></tr><tr><td>MODE</td><td>分区权限（英文字符模式，类似ls -l指令的显示样式）</td></tr></tbody></table> 
<p>fdisk MBR-硬盘分区</p> 
<ul><li> <p>硬件设备路径在<code>/dev/</code>目录下。硬盘设备不包含分区号，如<code>sdb</code>，<code>hda</code>等</p> </li><li> <p>虚拟机添加硬盘</p> </li><li> <p>分区</p> 
  <ul><li> <p><code>fdisk /dev/sdb</code></p> <p><code>fdisk [选项] 硬盘</code></p> <p><code>-l</code> list：列出所有硬盘的分区信息</p> </li><li> <p>fdisk 命令菜单（常用指令）</p> </li></ul> 
  <table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>m</td><td>显示 fdisk 命令菜单帮助</td></tr><tr><td>p</td><td>显示磁盘分区（功能同fdisk -l +硬盘路径 ）</td></tr><tr><td>n</td><td>新增分区</td></tr><tr><td>d</td><td>删除分区</td></tr><tr><td>q</td><td>放弃更改并退出 fdisk 指令</td></tr><tr><td>w</td><td>保存更改并退出 fdisk 指令</td></tr></tbody></table></li><li> <p>格式化</p> 
  <ul><li> <p><code>mkfs -t ext4 /dev/sdb1</code> <code>ext4</code>为分区类型</p> </li><li> <p><code>mkfs [选项] [-t &lt;分区格式&gt;] &lt;设备分区路径&gt;</code>选项： <code>-v</code> verbose：显示详情</p> </li><li> <p>分区格式（文件系统类型）</p> 
    <ul><li> <p>Linux 下的文件系统格式</p> 
      <table><thead><tr><th>分区类型</th><th>描述</th></tr></thead><tbody><tr><td>swap</td><td>交换文件。用于实现虚拟内存的功能</td></tr><tr><td>ext2</td><td>具有极快的速度和极小的CPU占用率，可用于硬盘和移动存储设备。默认格式，若不填写分区格式，则格式化为ext2格式</td></tr><tr><td>ext3</td><td>ext2 格式的升级版。增加日志功能，可回溯追踪</td></tr><tr><td>ext4</td><td>ext3 格式的升级版。日志式文件系统，支持1EB（1024*1024TB），最大单文件16TB，支持连续写入可减少文件碎片。</td></tr><tr><td>xfs</td><td>可以管理500T的硬盘。</td></tr><tr><td>brtfs</td><td>针对固态盘做优化</td></tr><tr><td>vfat</td><td>即 Windows 系统的 FAT32 格式</td></tr></tbody></table></li><li> <p>扩展知识：Windows 下的文件系统格式</p> 
      <table><thead><tr><th>标识</th><th>描述</th></tr></thead><tbody><tr><td>FAT16</td><td>MS—DOS和win95采用的磁盘分区格式，采用16位的文件分配表，只支持2GB的磁盘分区，最大单文件2GB，且磁盘利用率低</td></tr><tr><td>FAT32</td><td>采用32位的文件分配表，支持最大分区128GB，最大文件4GB</td></tr><tr><td>NTFS</td><td>支持最大分区2TB，最大文件2TB，安全性和稳定性非常好，不易出现文件碎片</td></tr></tbody></table></li></ul></li></ul></li><li> <p>命令行挂载，重启后失效</p> 
  <ul><li> <p><code>mount /dev/sdb1 /newdisk/</code></p> </li><li> <p><code>mount 硬盘分区 目录</code></p> </li><li> <p>卸载：<code>mount 待卸载的硬盘分区</code>或<code>mount 待卸载的目录</code></p> </li></ul></li><li> <p>设置自动挂载</p> <p><strong>挂载</strong>：将分区与 Linux 系统的文件目录做映射。映射的目录成为此分区的挂载点。</p> <p><strong>卸载</strong>：将分区从挂载点分离，卸载后的分区才能执行重新格式化、重新分区等操作，卸载后的分区可重新挂载到新的挂载点。</p> 
  <ul><li> <p>修改/etc/fstab实现挂载</p> </li><li> <p>添加后执行<code>mount -a</code>即刻生效</p> </li></ul></li></ul> 
<p>磁盘情况查询</p> 
<ul><li> <p>查询系统整体磁盘使用情况：<code>df -h</code></p> </li><li> <p>查询指定目录的磁盘占用情况（默认当前目录）：</p> <p><code>du [选项] [目录]</code></p> <p><code>-s</code> summary：只显示目录总的大小 <code>-a</code> all：所有内容的大小 (若不使用这个选项，则只显示子目录的大小，不显示文件的大小) <code>-h</code> 易读的大小单位（K/M/G 等) <code>--max-depth=XX</code>显示的子目录深度（若不指定，则默认显示所有深度） <code>-c</code> 列出所有子目录大小的同时，也显示目录的总大小</p> </li></ul> 
<p>磁盘实用指令</p> 
<ol><li> <p>统计/home文件夹下文件的个数：<code>ls -l /home | grep "^-" | wc -l</code></p> </li><li> <p>统计/home文件夹下目录的个数：<code>ls -l /home | grep "^d" | wc -l</code></p> </li><li> <p>统计/home文件夹下文件的个数，包括子文件夹里的：<code>ls -lR /home | grep "^-" | wc -l</code></p> </li><li> <p>统计文件夹下目录的个数，包括子文件夹里的：<code>ls -lR /home | grep "^d" | wc -l</code></p> </li><li> <p>以树状显示目录结构：<code>tree [目录]</code></p> </li></ol> 
<hr> 
<h4 id="%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE">网络配置</h4> 
<ul><li> <p><code>ifconfig</code>查询网络信息</p> </li><li> <p><code>ping [参数] 主机名称/IP地址/主机网址</code></p> <p><code>-c &lt;次数&gt;</code> count：完成次数。ping 通对应次数后，命令自动退出 <code>-I &lt;网络界面名&gt;</code> interface：网络界面。ping 指令使用的网卡 <code>-R</code> route：输出路由过程 <code>-4</code> ipv4：只使用 ipv4 网络 <code>-6</code> ipv6：只使用 ipv6 网络</p> 
  <ul><li> <p><em>使用网卡 ens33 ，测试 5 次，测试与 192.168.5.20 的连接性</em><code>ping -c 5 -I ens33 192.168.5.20</code></p> </li></ul></li></ul> 
<p>指定IP</p> 
<ul><li> <p>直接修改配置文件来指定IP,Ubuntu20</p> 
  <ul><li> <p><code>cd /etc/netplan</code></p> </li><li> <p>备份旧配置文件内容</p> </li><li> <p>编辑配置文件 network: version: 2 renderer: NetworkManager ethernets: enp0s5: # 网卡名称 dhcp4: no # 关闭dhcp dhcp6: no addresses: [10.211.55.10/24] # 静态ip gateway4: 10.211.55.1 # 网关 nameservers: addresses: [8.8.8.8, 114.114.114.114] #dns</p> </li><li> <p><code>sudo netplan apply</code> 配置生效</p> </li></ul></li><li> <p>直接修改配置文件来指定IP,并可以连接到外网(程序员推荐)</p> <p>编辑<code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code> 要求：将ip 地址配置的静态的，比如: ip 地址为192.168.200.130</p> <p>ifcfg-ens33 文件说明</p> <pre>DEVICE=eth0 #接口名（设备,网卡）
​
HWADDR=00:0C:2x:6x:0x:xx #MAC 地址
​
TYPE=Ethernet #网络类型（通常是Ethemet）
​
UUID=926a57ba-92c6-4231-bacb-f27e5e6a9f44 #随机id
​
\#系统启动的时候网络接口是否有效（yes/no）
ONBOOT=yes
​
\#IP 的配置方法[none|static|bootp|dhcp]（引导时不使用协议|静态分配IP|BOOTP 协议|DHCP 协议）
BOOTPROTO=static
\#IP 地址
IPADDR=192.168.200.130
\#网关
GATEWAY=192.168.200.2
\#域名解析器
DNS1=192.168.200.2</pre> <p>重启网络服务或者重启系统生效 <code>service network restart 、reboot</code></p> </li><li> <p>查看主机名称<code>hostname</code></p> <p><code>hostname [参数]</code></p> <p><code>-I</code> 显示当前系统的 IP 地址</p> </li></ul> 
<p>更改主机名：<code>vim /etc/hostname</code>，编辑后重启</p> 
<p>systemctl 指令来修改主机名：<code>systemctl set-hostname lilixxs-test</code></p> 
<p>设置hosts映射</p> 
<ul><li> <p>在 Windows 中修改 hosts 映射，可通过<code>ping +虚拟机主机名</code> 检测与虚拟机的连接 Wnidows 中 hosts 映射文件的地址 <code>C:\Windows\System32\drivers\etc\hosts</code> Windows 中 hosts 映射文件的格式</p> <p>设置 hosts 映射：IP 地址为 192.168.3.20，主机名为 lilixxs-centos <code>192.168.3.20 lilixxs-centos</code></p> </li><li> <p>在 Linux 中修改 hosts 映射，可通过 ping +虚拟机主机名 检测与主机的连接</p> <p>打开 /etc/hosts 设置 hosts 映射：IP 地址为 192.168.3.30，主机名为 lilixxs-pc <code>192.168.3.30 lilixxs-pc</code> 可见 <strong>Linxu 与 Windows 的 hosts 映射文件格式相同</strong></p> </li></ul> 
<p>Windows 系统下，本机 DNS 缓存的查询/清理 查询本机的 DNS 缓存</p> 
<pre>ipconfig /displaydns</pre> 
<p>清空本机的 DNS 缓存</p> 
<pre>ipconfig /flushdns</pre> 
<hr> 
<h4 id="%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">进程管理</h4> 
<ul><li> <p>基本介绍</p> 
  <ul><li> <p>在 Linux 中，每个执行的程序都成为一个进程，系统对每一个进程都会分配一个 ID 标识号 (PID)，用于查找、识别和控制此进程</p> </li><li> <p>进程有两种存在形式：前台、后台 前台：用户在屏幕上能看到并操作的进程，处于前台模式 后台：进程在运行，但屏幕上不显示的形式</p> </li><li> <p>服务器的进程/服务，大多都以后台的形式运行(前台程序一般为命令行程序)，而且会常驻在系统中(不自动结束进程，保持一直运行)。如 tomcat，nginx，mysql 等程序</p> </li></ul></li></ul> 
<p>ps指令</p> 
<p><code>ps</code>用于查看当前系统、当前时刻，有哪些程序正在执行，以及各个程序的执行状况</p> 
<ul><li> <p><code>ps</code>指令输出的结果，是指令执行瞬间的结果，不能自动刷新 要使用自动刷新的进程查看器，指令为：<code>top</code></p> </li><li> <p><code>ps [参数]</code>或<code>ps [常见组合]</code></p> </li><li> <p>常用参数</p> 
  <table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td>-a</td><td>显示当前系统有shell控制的进程</td></tr><tr><td>-u</td><td>显示执行进程的用户信息</td></tr><tr><td>-x</td><td>显示没有shell控制的进程，通常配合-a参数使用</td></tr><tr><td>-e</td><td>显示所有进程信息，等同于-A参数</td></tr><tr><td>-l</td><td>列表形式，显示更详细的信息</td></tr><tr><td>-f</td><td>unix形式，显示所有信息</td></tr><tr><td>-p &lt;PID&gt;</td><td>显示对应PID的进程</td></tr></tbody></table></li><li> <p>常见组合：</p> 
  <table><thead><tr><th>指令</th><th>意义</th></tr></thead><tbody><tr><td>ps -ef</td><td>按照基本格式，显示系统的所有进程信息</td></tr><tr><td>ps -aux</td><td>按照 BSD 格式的指令，显示系统的所有进程信息</td></tr><tr><td>ps -axjf</td><td>按照 BSD 格式的指令，显示系统的所有进程信息和进程数</td></tr><tr><td>ps -ejH</td><td>按照 Unix 格式的指令，显示系统的所有进程信息和进程数</td></tr></tbody></table><p>推荐用 BSD 格式，信息丰富、结果显示易懂</p> </li><li> <p>BSD 系统格式输出如下 <code>ps aux</code>：</p> </li><li> <p>USER：启动进程的用户名 PID：进程分配的 ID 标识号，可用于进程搜索、控制 %CPU：此进程当前的 CPU 占用率 %MEM：此进程当前的物理内存占用率 VSZ：此进程占用的虚拟内存大小 RSS：此进程占用的物理内存大小 TTY：由启动此进程的 shell 控制的参数，终端名称 STAT：此进程的状态(英文缩写形式)</p> 
  <ul><li> 
    <table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td>D</td><td>短期等待 uninterruptible sleep (usually IO)</td></tr><tr><td>R</td><td>正在运行 running or runnable (on run queue)</td></tr><tr><td>S</td><td>睡眠 interruptible sleep (waiting for an event to complete)</td></tr><tr><td>T</td><td>停止stopped by job control signal</td></tr><tr><td>t</td><td>调试跟踪时停止stopped by debugger during the tracing</td></tr><tr><td>s</td><td>表示该进程是会话的先导进程</td></tr><tr><td>X</td><td>dead (should never be seen)</td></tr><tr><td>Z</td><td>僵死进程 defunct ("zombie") process, terminated but not reaped by its parent</td></tr></tbody></table></li></ul><p>START：此进程的启动时间，时间格式：月日(MmmDD) TIME：累计占用的 CPU 时间 (仅计算使用CPU时的时间累计，空闲不占用CPU时不算占用时间)，时间格式：HH:MM(小时:分) COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</p> </li></ul> 
<ul><li> <p><code>ps -ef</code></p> 
  <ul><li> <p>UID：启动进程的用户 ID，对应/etc/passwd文件和id命令中的UID PID：进程分配的 ID 标识号，可用于进程搜索、控制 <strong>PPID：父进程的 ID 标识号，与进程数父子进程关系对应</strong> C：此进程当前的 CPU 占用率 STIME：此进程的启动时间，时间格式：月日(MmmDD) TTY：由启动此进程的 shell 控制的参数 TIME：累计占用的 CPU 时间 (仅计算使用CPU时的时间累计，空闲不占用CPU时不算占用时间)，时间格式：HH:MM(小时:分) CMD：进程的执行指令 (完整路径 + 参数)</p> </li></ul></li></ul> 
<p>kill/kill all终止进程</p> 
<p>若某个指令执行中需要人为停止，或处于异常状态占用大量资源，可以考虑终止该进程。</p> 
<ul><li> <p>kill 通过进程 ID (PID) 终止进程 <code>kill [参数] PID</code></p> </li><li> <p>killall 通过进程名 (NAME) 终止进程</p> <p><code>killall [参数] 进程名</code></p> 
  <ol><li> <p>killall 进程名支持通配符</p> </li><li> <p>killall 指令可将满足条件的所有进程一并终止</p> </li></ol></li><li> <p>参数</p> <p>-l 信号，如果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称（如-9） -a 当处理当前进程时，不限制命令名和进程号的对应关系 -p 指定kill 命令只打印相关进程的进程号，而不发送任何信号 -s 指定发送信号 -u 指定用户</p> </li></ul> 
<p><code>-9</code>：强制终止进程(无视 Linux 系统的保护机制)</p> 
<p><code>-2</code>：即Ctrl+C结束前台程序的kill命令</p> 
<p>默认情况下，如果不指定信号，kill 等价于 kill -15 。 kill -15 执行时，系统向对应的程序发送SIGTERM（15）信号，该信号是可以被执行、阻塞和忽略的，所以应用程序接收到信号后，可以做一些准备工作，再进行程序终止。</p> 
<ul><li> <p>示例</p> 
  <ol><li> <p>踢掉某个用户</p> 
    <ul><li> <p><code>ps -aux | grep sshd</code>，找到该进程的PID（root启动的进程），<code>kill 进程号</code></p> </li></ul></li><li> <p>终止sshd服务，在适当时候开启</p> 
    <ul><li> <p><code>kill 进程号</code>，打开：<code>/bin/systemctl start sshd.service</code></p> </li></ul></li><li> <p>终止多个文本编辑器 gedit，<code>killall gedit</code></p> </li><li> <p>强制终止一个终端,<em>终端 shell 是一种受系统保护的进程，若要强制终止，需要增加参数 -9</em></p> 
    <ul><li> <p><code>ps -aux | grep bash</code>，<code>kill -9 进程号</code></p> </li></ul></li></ol></li><li> <p>查看进程树<code>ptree [参数]</code></p> 
  <ul><li> <p><code>-u</code> user：显示启动进程的用户名 <code>-p</code> pid：显示进程的 ID (PID)</p> </li></ul></li></ul> 
<hr> 
<h4 id="%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86">服务管理</h4> 
<p>开机流程</p> 
<p>开机——&gt;BIOS——&gt;/boot——&gt;systemd进程1——&gt;运行级别——&gt;运行级别对应服务</p> 
<ul><li> <p>服务 (Services) 是一种特殊的进程，以后台的形式运行。通常监听某些端口、等待其他程序的请求等。<strong>服务是管理进程的特殊进程</strong>，因此服务也被称为“守护进程”。 常见的服务如 firewalld Linxu 系统防火墙、mysqld(MySQL 的守护进程)、sshd等</p> </li><li> <p>服务的命名通常由软件厂商决定。一般来说，“进程名 + d”作为此进程服务(守护进程)的名称。如 MySQL 进程名为 mysql，则其服务(守护进程)名为 mysqld</p> </li><li> <p><code>systemctl</code>命令相对<code>service</code>命令更加强大，不仅能控制服务，还可修改系统设置、提供高级的控制选项</p> </li><li> <p>service 服务管理(即将要废除的命令) 基本语法 <code>service 服务名 [操作]</code> 常见操作1：服务的启动/停止/重启/重载/状态查询 <code>service 服务名 start/stop/restart/reload/status</code> 常见操作2：查看所有服务状态 <code>service --status-all</code></p> 
  <ul><li> <p>只有部分服务可被service命令管理，可被service命令管理的用户定义的部分服务。 此部分服务所在目录：/etc/init.d/ 系统定义的服务(Systemd 服务)可被service命令管理。 但这里实际是系统智能识别service指令，将其转换为systemctl命令，以保证兼容性 系统服务详见：setup命令 --&gt; 系统服务 setup命令使用 TAB 键进行菜单切换，使用空格键进行选择/取消选择 系统服务所在目录：/usr/lib/systemd/system/</p> </li><li> <p><code>reload</code> 与 <code>restart</code> 的区别 相同点：都会刷新配置，重新加载配置文件 <code>reload</code>：重新加载配置文件，但服务不会中断。不对已建立连接的服务造成影响，若配置出错，则使用之前的配置。又称为“平滑重启” <code>restart</code>：重新加载配置文件，服务会有短时的中断。若配置出错，则会导致服务的长时间中断</p> </li></ul></li><li> <p><code>chkconfig</code>服务管理，重启机器后才能生效，可管理服务同service</p> <p>查询 / 设定一个服务在不同运行级别能否启用</p> <p>查询所有服务的运行级别 <code>chkconfig --list</code> 查询某一服务的运行级别，不知道完整的服务名(需要配合 grep 指令进行筛选) <code>chkconfig --list | grep "服务名"</code> 知道完整的服务名 <code>chkconfig 服务名 --list</code> 设置服务在 级别 X 下自动启动/停止 <code>chkconfig --level X 服务名 on/off</code> 加入自定义服务 test <code>chkconfig --add test</code> 删除服务 test <code>chkconfig --del test</code></p> </li></ul> 
<p><strong>systemctl管理</strong></p> 
<p><code>systemctl</code>命令可控制 Linux 系统中的所有服务</p> 
<ul><li> <p>服务启动/停止/重启/重载/查看状态 <code>systemctl start/stop/restart/reload/status 服务名</code></p> </li><li> <p><code>systemctl</code>管理的服务在/usr/lib/systemd/system查看</p> </li><li> <p>查看所有服务的自启动状态</p> <p><code>systemctl list-unit-files [|grep 服务名]</code> 服务的状态如下： <code>masked</code> 此服务禁止自启动 <code>static</code> 该服务无法自启动，只能作为其他文件的依赖 <code>enabled</code> 已配置为自启动 <code>disabled</code> 未配置为自启动</p> </li><li> <p><code>systemctl is-enabled</code> 服务名，查看某一服务是否自启动。</p> 
  <ul><li> <p>使用<code>systemctl</code>命令，设置自启动状态，会同时设置服务级别3、5的自启动状态</p> </li><li> <p><code>systemctl enable 服务名</code>（设置服务开机自启动）</p> </li><li> <p><code>systemctal disable 服务名</code>（关闭服务开机自启动）</p> </li></ul></li><li> <p>加入自定义服务 test：<code>systemctl load test</code></p> </li><li> <p>查看服务状态<code>systemctl status 服务名</code></p> </li><li> <p>使用 start/stop 参数，立刻生效，但重启后会根据自启动配置重新停止/启动服务</p> 
  <table><thead><tr><th>动作</th><th>Systemd 指令(systemctl)</th><th>SysV Init 指令(service &amp; chkconfig)</th></tr></thead><tbody><tr><td>启动服务</td><td>systemctl start 服务名</td><td><code>service 服务名 start</code></td></tr><tr><td>停止某服务</td><td>systemctl stop 服务名</td><td><code>service 服务名 stop</code></td></tr><tr><td>加入自定义服务</td><td>systemctl load 服务名</td><td><code>chkconfig --add 服务名</code></td></tr><tr><td>删除服务</td><td>删除在systemd目录下的配置文件</td><td><code>chkconfig --del 服务名</code></td></tr><tr><td>查询所有服务的自启动情况(运行级别)</td><td>systemctl is-enabled 服务名</td><td><code>chkconfig --list | grep 服务名</code></td></tr><tr><td>查询服务是否开机启动</td><td>systemctl is-enabled 服务名</td><td><code>chkconfig list-unit-files | grep 服务名</code></td></tr><tr><td>设置服务开机启动(服务级别3、5)</td><td>systemctl enable 服务名</td><td><code>chkconfig --level 5 服务名 on</code> <code>chkconfig --level 3 服务名 on</code></td></tr><tr><td>设置服务开机禁用(服务级别3、5)</td><td>systemctl disable 服务名</td><td><code>chkconfig --level 5 服务off</code> <code>chkconfig --level 3 服务名 off</code></td></tr></tbody></table></li></ul> 
<p><strong>防火墙（端口控制）</strong></p> 
<ul><li> <p>关闭或启用防火墙，立即生效，但只是临时生效，重启系统后，回归默认设置。</p> </li><li> <p>打开端口/允许协议 <code>firewall-cmd --permanent --add-port=端口号/协议</code> 关闭端口/禁用协议 <code>firewall-cmd --permanent --remove-port=端口号/协议</code> 查询端口/协议是否开启 <code>firewall-cmd --query-port=端口/协议</code> 查询防火墙所有端口/协议配置 <code>firewall-cmd --list-ports</code> 重载防火墙 <code>firewall-cmd --reload</code> 也可考虑使用systemctl或service命令重载 firewalld 服务 <code>systemctl reload firewalld</code>或<code>service firewalld reload</code></p> </li><li> <p>使用防火墙指令前，需要启用防火墙 <code>systemctl start firewalld</code>或 <code>service firewalld start</code> 为保证防火墙持续工作，应设置防火墙服务为开机自启动 <code>systemctl enanble firewalld</code> 或 <code>chkconfig --level 3/5 firewalld on</code> 打开、关闭端口的操作需要重载防火墙才能生效 使用 防火墙指令 重载 <code>firewall-cmd --reload</code> permanent参数 表明永久设置。若不使用此参数，则重启后设置将被清除</p> </li></ul> 
<p>动态监控进程</p> 
<p><code>top</code>命令与<code>ps</code>命令相似。两者都能显示系统中的进程信息。 但<code>top</code>命令输出的结果一直保持置顶且可以动态刷新。类似于 Windows 系统中的 任务管理器 <code>top [参数]</code></p> 
<p><code>-d 秒数</code> delay-time：指定动态刷新的周期秒数。默认为刷新周期=3s <code>-i</code>：不显示闲置或僵死的进程 <code>-p 进程PID</code>：指定显示对应进程 ID (PID) 的进程</p> 
<ul><li> <p>全局选项： h : 界面帮助 Z : 改变配色 B : 标题显示为粗体 E或e : 改变计量单位(KB/MB/GB/PB/EB) d : 设置自动刷新时间 (同top -d命令) q : 退出 top 界面</p> </li><li> <p>汇总显示： l : 平均负载 t : CPU总占用率 m :内存总信息 分项调整 : F或f进入 空格 : 选中/不选中 &lt;–&gt; 显示/不显示 左右 : 显示设定 &lt;–&gt; 排序设定 q : 保存并退出</p> </li><li> <p><strong><u>排序</u></strong> P : 以 CPU 占用率排序。这是显示的默认排序选项 M : 以内存占用率排序 N : 以进程 ID (PID) 排序 R : 改变升序/倒序</p> </li><li> <p><u><strong>进程控制</strong></u> k kill：终止进程 (要指定 PID 和信号量，强制结束的信号量 = 9) u user：监控特定用户的进程 (要指定用户名)</p> </li></ul> 
<p>监控网络状态</p> 
<p><code>netstat [参数]</code></p> 
<ul><li> <p>常用参数 <code>-a</code> all：显示所有端口 (默认只显示已连接的端口) <code>-n</code> numeric：不解析端口号 (直接输出端口号结果，默认输出端口对应的进程) <code>-p</code> 显示端口与进程调用 (PID) 的关系</p> </li><li> <p>常用组合： <code>-an</code> 输出所有端口号信息 <code>-ap</code> 输出所有端口与 PID 间的信息</p> </li><li> <p>内容解析</p> 
  <ul><li> <p>Proto protocol：协议，常见的如 tcp、udp 等 Recv-Q 网络接收队列。表示收到的数据已经在本地接收缓冲，但是还有多少没有被进程取走。若接收队列一直处于阻塞状态，可能是遭受了拒绝服务攻击，或系统响应进程出现问题、系统负载过大。 Send-Q 网络发送队列。对方没有收到的数据 或 还没有返回 Ack 确认的数据。如果发送队列不能很快的清零，可能是有应用向外发送数据包过快，或者是对方接收数据包不够快。 Local Address 本机地址。格式：IP地址/主机名:端口/使用此连接的进程名 Foreign Address 外部地址。格式：IP地址/主机名:端口/使用此连接的进程名 PID 进程 ID。仅在-p选项时输出 State 状态。共有12种可能，对应 TCP/IP 协议</p> </li></ul> 
  <table><thead><tr><th>STATE</th><th>状态</th></tr></thead><tbody><tr><td>LISTEN</td><td>正在侦听来自远方的连接请求</td></tr><tr><td>SYN_SENT</td><td>在发送连接请求后等待匹配的连接请求</td></tr><tr><td>SYN_RECV</td><td>在收到和发送一个连接请求后等待对连接请求的确认</td></tr><tr><td>ESTABLISHED</td><td>连接已建立，数据可以传送给用户</td></tr><tr><td>FIN_WAIT1</td><td>等待远程TCP的连接中断请求，或先前的连接中断请求的确认</td></tr><tr><td>CLOSE_WAIT</td><td>等待从本地用户发来的连接中断请求</td></tr><tr><td>FIN_WAIT2</td><td>从远程TCP等待连接中断请求</td></tr><tr><td>LAST_ACK</td><td>等待原来发向远程TCP的连接中断请求的确认</td></tr><tr><td>TIME_WAIT</td><td>等待足够的时间以确保远程TCP接收到连接中断请求的确认</td></tr><tr><td>CLOSING</td><td>等待远程TCP对连接中断的确认</td></tr><tr><td>CLOSED</td><td>无连接</td></tr><tr><td>UNKNOWN</td><td>未知状态</td></tr></tbody></table></li></ul> 
<p>监听TCP端口-tcpdump</p> 
<p>Linux tcpdump命令用于倾倒网络传输数据。</p> 
<p>执行tcpdump指令可列出经过指定网络界面的数据包文件头，在Linux操作系统中，你必须是系统管理员。</p> 
<pre>tcpdump [-adeflnNOpqStvx][-c&lt;数据包数目&gt;][-dd][-ddd][-F&lt;表达文件&gt;][-i&lt;网络界面&gt;][-r&lt;数据包文件&gt;][-s&lt;数据包大小&gt;][-tt][-T&lt;数据包类型&gt;][-vv][-w&lt;数据包文件&gt;][输出数据栏位]</pre> 
<ul><li> <p>-a 尝试将网络和广播地址转换成名称。</p> </li><li> <p>-c&lt;数据包数目&gt; 收到指定的数据包数目后，就停止进行倾倒操作。</p> </li><li> <p>-d 把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出。</p> </li><li> <p>-dd 把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出。</p> </li><li> <p>-ddd 把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出。</p> </li><li> <p>-e 在每列倾倒资料上显示连接层级的文件头。</p> </li><li> <p>-f 用数字显示网际网络地址。</p> </li><li> <p>-F&lt;表达文件&gt; 指定内含表达方式的文件。</p> </li><li> <p>-i&lt;网络界面&gt; 使用指定的网络截面送出数据包。</p> </li><li> <p>-l 使用标准输出列的缓冲区。</p> </li><li> <p>-n 不把主机的网络地址转换成名字。</p> </li><li> <p>-N 不列出域名。</p> </li><li> <p>-O 不将数据包编码最佳化。</p> </li><li> <p>-p 不让网络界面进入混杂模式。</p> </li><li> <p>-q 快速输出，仅列出少数的传输协议信息。</p> </li><li> <p>-r&lt;数据包文件&gt; 从指定的文件读取数据包数据。</p> </li><li> <p>-s&lt;数据包大小&gt; 设置每个数据包的大小。</p> </li><li> <p>-S 用绝对而非相对数值列出TCP关联数。</p> </li><li> <p>-t 在每列倾倒资料上不显示时间戳记。</p> </li><li> <p>-tt 在每列倾倒资料上显示未经格式化的时间戳记。</p> </li><li> <p>-T&lt;数据包类型&gt; 强制将表达方式所指定的数据包转译成设置的数据包类型。</p> </li><li> <p>-v 详细显示指令执行过程。</p> </li><li> <p>-vv 更详细显示指令执行过程。</p> </li><li> <p>-x 用十六进制字码列出数据包资料。</p> </li><li> <p>-w&lt;数据包文件&gt; 把数据包数据写入指定的文件。</p> </li></ul> 
<hr> 
<h4 id="%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7">包管理工具</h4> 
<p>rpm/yum适用于Redhat、CentOS、Suse等平台；apt-get/dpkg适用于Debian、Ubuntu等平台；zypper适合于Suse平台。</p> 
<p>rpm</p> 
<ul><li> <p>常用指令</p> 
  <ul><li> <p>查询 <code>rpm -qa</code> 列出所有在本机上安装的程序 <code>rpm -qa | grep 软件名关键词</code> 查询某一软件是否安装 <code>rpm -q 软件名</code> 查询某一软件是否安装 <code>rpm -qi 软件名</code>查询一个软件包的具体信息 <code>rpm -ql 软件名</code> 查询软件包中包含的文件 <code>rpm -qf 完整文件路径</code>查询某一文件所属的包 卸载 rpm 软件包：<code>rpm -e RPM包的名称</code> 强制卸载，不论其他软件是否依赖此软件，增加参数<code>--nodeps</code> 安装 rpm 软件包：<code>rpm -ivh rpm包完整路径</code></p> </li><li> <p>参数详解： <code>-i</code> install：安装 <code>-v</code> verbose：显示安装详细信息 <code>-h</code> hash：显示安装进度条 升级软件：<code>rpm -Fvh rpm包完整路径</code> <code>F</code> freshen：安装/升级。若已经安装则升级 <code>-v</code>verbose：显示安装详细信息 <code>-h</code> hash：显示安装进度条 初始化 rpm 数据库：<code>rpm --initdb</code> 重建 rpm 数据库：<code>rpm --rebuilddb</code> rpm 命令、yum 命令都依赖 rpm 数据库进行本机软件管理。若 rpm 数据库损坏，可尝试重建 rpm 数据库</p> </li></ul></li></ul> 
<p>yum</p> 
<p><code>yum</code>是一个底层基于<code>rpm</code>，连接软件源，实现软件安装、管理的高层次前端软件包管理工具。 <code>yum</code>可自动从指定的软件源(服务器/本地)下载 rpm 安装包并自动安装，自动处理依赖关系，并自动安装需要的依赖包。</p> 
<ul><li> <p>查询 搜索软件包：<code>yum search [参数] 模糊软件名</code> 常用参数：<code>installed/all/updates</code> &lt;–&gt; 已安装的/全部(默认值)/可升级的 软件名可模糊查询</p> 
  <ul><li> <p>查询软件包：<code>yum list [参数] 精确软件名</code> 常用参数：<code>installed/all/updates</code> &lt;–&gt; 已安装的/全部(默认值)/可升级的 软件名需要精确名称</p> </li><li> <p><code>yum list (all) | grep软件名</code> 搜索所有软件。all 可以不输入</p> </li><li> <p>查询软件包的具体信息：<code>yum info 软件包名</code> 软件包名需要精确名称</p> </li><li> <p>查看软件源(仓库)：<code>yum repolist [参数]</code> 常用参数：all/enabled/disabled &lt;–&gt; 所有仓库/启用的仓库(默认值)/禁用的仓库</p> </li></ul></li><li> <p>根据软件源(仓库)管理 安装指定的软件包 <code>yum install 软件名1 软件名2 ...</code></p> 
  <ul><li> <p>重新安装软件包 <code>yum reinstall 软件名1 软件名2 ...</code></p> </li><li> <p>升级软件包</p> </li></ul><p>升级到最新版本：<code>yum update 软件名1 软件名2 ...</code></p> 
  <ul><li> <p>查询可安装的版本：<code>yum search --showduplicate 模糊软件名</code> 或 <code>yum list --showduplicate 精确软件名</code></p> </li><li> <p>升级到指定版本：<code>yum update-to 软件名-版本</code> 删除软件包 <code>yum remove 软件名1 软件名2 ...</code></p> </li><li> <p>检测可升级的软件包 <code>yum check-update</code></p> </li></ul></li><li> <p>根据本地 rpm 数据库管理</p> 
  <ul><li> <p>安装本地 rpm 软件包 <code>yum localinstall rpm包完整路径</code> 常用选项：<code>--nogpgcheck</code>免除gpg秘钥检验</p> </li><li> <p>升级本地 rpm 软件包 <code>yum localupdate rpm包完整路径</code> 常用选项：<code>--nogpgcheck</code>免除gpg秘钥检验</p> </li></ul></li></ul> 
<p>apt-get</p> 
<p><code>apt-get [参数]</code></p> 
<ul><li> <p>升级</p> <p>apt-get update // 更新源文件，并不会做任何安装升级操作</p> <p>apt-get upgrade // 升级所有已安装的包</p> <p>apt-get install packagename // 安装指定的包</p> <p>apt-get install packagename --only-upgrade // 仅升级指定的包</p> <p>apt-get install packagename --reinstall // 重新安装包</p> <p>apt-get -f install // 修复安装</p> <p>apt-get build-dep packagename // 安装相关的编译环境</p> <p>apt-get source packagename // 下载该包的源代码</p> <p>apt-get dist-upgrade // 升级系统</p> <p>apt-get dselect-upgrade // 使用 dselect 升级</p> </li><li> <p>查询&amp;显示</p> <p>apt-cache search packagename // 查询指定的包 　　</p> <p>apt-cache show packagename // 显示包的相关信息，如说明、大小、版本等</p> <p>apt-cache depends packagename // 了解使用该包依赖哪些包</p> <p>apt-cache rdepends packagename // 查看该包被哪些包依赖</p> </li><li> <p>删除</p> <p>apt-get remove packagename // 删除包 　　</p> <p>apt-get remove packagename -- purge // 删除包，包括删除配置文件等</p> <p>apt-get autoremove packagename --purge // 删除包及其依赖的软件包+配置文件等（只对6.10有效，推荐使用）</p> </li><li> <p>清理</p> <p>apt-get clean // 清理无用的包</p> <p>apt-get autoclean // 清理无用的包</p> <p>apt-get check // 检查是否有损坏的依赖</p> </li><li> <p>apt-get upgrade更新时忽略指定包 // 使用这个命令可以将指定的包的版本hold住，这样在更新的时候就会忽略掉这个包。</p> <p><code>apt-mark hold packagename</code> // 将 hold 替换为 unhold 就可以取消对这个包版本的锁定了。</p> <p><code>apt-mark unhold packagename</code></p> </li></ul> 
<hr> 
<h4 id="%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE">系统设置</h4> 
<ul><li> <p>环境变量，能使系统在任意位置均能访问到对应的文件</p> </li><li> <p>环境变量地址：/etc/profile文件</p> </li><li> <p>添加环境变量：export $环境变量名=环境变量指向的完整路径</p> </li><li> <p>应用环境变量： 保存profile文件 输入source /etc/profile</p> </li><li> <p>查看当前环境变量：$环境变量名</p> </li></ul> 
<hr> 
<h4 id="Shell%E8%84%9A%E6%9C%AC">Shell脚本</h4> 
<p>Shell 是一个命令行解释器，它为用户提供了一个系统级程序：向 Linux 内核发送请求以便运行程序。用户可用 Shell 来启动、挂起、停止，甚至是编写一些处理程序</p> 
<p>Shell 脚本是一种脚本语言，Shell 脚本时一种解释性的脚本语言，执行前不需要额外编译，执行时逐语句编译，但效率低一些</p> 
<ul><li> <p>脚本格式要求</p> 
  <ul><li> <p>开头-指定使用的 Shell</p> 
    <ul><li> <p>通常指定 bash (root 权限下)：<code>#!/bin/bash</code></p> </li><li> <p>通常指定 bash (非 root 权限下)：<code>#!/usr/bin/bash</code></p> </li></ul></li><li> <p>Shell 操作相关指令 看系统中的 Shell：<code>chsh -l</code> 切换到新 Shell：<code>exec Shell名称</code> 为某用户设定默认 Shell：<code>chsh -s 新Shell完整路径 [用户名]</code></p> </li></ul></li><li> <p>脚本常用的执行方式</p> 
  <ul><li> <p>赋予脚本可执行权限(x)，然后直接访问脚本文件</p> </li><li> <p>使用<code>sh</code>命令,脚本文件不需要执行权限(x)，不论所有者和所在组是谁，脚本都能运行</p> </li></ul></li><li> <p>Shell 变量介绍</p> <p>Shell 变量有 4 种：系统变量、用户自定义变量、位置参数变量、预定义变量</p> 
  <ul><li> <p>用户自定义变量：用户自定义的变量，可在脚本 / shell 中定义，变量名、变量值都可自定义，只能在此 bash 中使用；</p> </li><li> <p>环境变量：主要保存与系统操作环境相关的数据，在系统中可被全局调用的变量。可以自定义，但有部分系统预设的环境变量更改可能导致问题；</p> </li><li> <p>位置参数变量：主要用于向脚本当中传递参数或数据，脚本可通过对应指令获取传入的变量数据</p> </li><li> <p>预定义变量：预先设置好的可用于脚本的变量，类似于脚本专用的环境变量，变量名、变量的作用均是固定的。</p> </li></ul></li><li> <p>显示shell中所有变量：set</p> </li></ul> 
<p>环境变量</p> 
<ul><li> <p>查看某一环境变量： <code>set | grep 环境变量名</code> <code>echo $环境变量名</code></p> </li><li> <p>设置某一环境变量：<code>export 环境变量名=值</code></p> 
  <ul><li> <p>打开对应环境变量文件，在对应的环境变量文件中进行操作</p> </li><li> <p>利用<code>&gt;&gt;</code>输出重定向将指令添加到对应的环境变量文件</p> </li></ul></li><li> <p>格式注意事项：</p> 
  <ol><li> <p>等号(=)两侧不能有空格</p> </li><li> <p>等号左边的环境变量名：不能有美元符号($)</p> </li><li> <p>等号右边的表达式：若引用其他环境变量，要加美元符号($)</p> </li></ol></li><li> <p>更新环境变量：<code>source 环境变量所在文件夹</code> 修改环境变量文件后，要更新环境变量，才能正确调用此变量</p> </li></ul> 
<p>用户自定义变量</p> 
<ul><li> <p>在脚本 或 Shell 中定义的变量，可被此 脚本/Shell 及其子 Shell 调用。有两种自定义变量：普通变量、静态变量。</p> </li><li> <p>定义/更改变量：<code>变量名=值</code></p> </li><li> <p>撤销变量：<code>unset 变量名</code></p> </li><li> <p>声明静态变量：<code>readonly 变量名=值</code>，静态变量相当与常量，不能改值，也不能撤销。</p> </li><li> <p>将指令的返回结果交给变量，<code>C=`date`</code>或<code>C=$(date)</code>（推荐）</p> </li><li> <p>shell的多行注释：</p> <pre>:&lt;&lt;!   #需要换行
内容
!</pre> </li></ul> 
<p>位置参数变量（传入实参）</p> 
<ul><li> <p>在执行一个 Shell 脚本时，如果希望获取到输入命令行中时，一同输入的参数的信息，就可使用位置参数变量</p> </li><li> <p><code>$n</code>选择对应位置的参数 n为数字，<code>$0</code>为脚本文件路径(myshell)，<code>$1-$9</code>代表第1-9个参数，<code>${25}</code>代表第25个参数(10以上的参数，数字需要用大括号{}包含) <code>$#</code>返回输入的命令中的参数个数 <code>$*</code>选择命令行中的所有参数，并将所有参数看做一个参数返回 <code>$@</code>选择命令行中的所有参数，并将每个参数区别对待(返回值类似数组)</p> </li></ul> 
<p>预定义变量</p> 
<p>shell设计者已经定义好的变量，只能在脚本中使用的变量</p> 
<ul><li> <p>语法 <code>$$</code> 当前进程的进程 ID (PID)，即执行此脚本时的进程 ID <code>$!</code> 最近运行的进行的 ID (最近运行的进程 PID) <code>$?</code> 上一次执行的命令的返回状态</p> 
  <ul><li> <p><code>0</code> = 上一指令正常执行</p> </li><li> <p><code>其他数字</code> = 上个指令执行有问题，具体返回值可由命令自己决定</p> </li></ul></li></ul> 
<p><strong>tip</strong> ：<code>*.sh &amp;</code>以后台方式运行脚本</p> 
<hr> 
<p>运算符</p> 
<ul><li> <p>语法</p> 
  <ul><li> <p>除法默认为整除</p> </li><li> <p><code>$((表达式))</code>或<code>$[表达式]</code>（推荐）</p> </li><li> <p><code>$(expr 表达式)</code>或<code>expr 表达式</code>：只能实现 两个操作数 的计算</p> <pre>#!/bin/bash
#计算（2+3）*4
rs1=$(((2+3)*4))
rs2=$[(2+3)*4]
temp=expr 2 + 3
rs3=expr temp \* 4 #expr中的乘法需加转义字符</pre> </li></ul></li></ul> 
<hr> 
<p>条件判断</p> 
<ul><li> <p>语法</p> 
  <ul><li> <p>单独使用条件表达式 <code>test 条件表达式</code> 若条件满足，则返回 TRUE (= 0)；若条件不满足，则返回 FALSE (&gt; 0)</p> </li><li> <p>配合其他语句实现选择分支、循环逻辑 <code>[ 条件表达式 ]</code>：条件表达式与两边 [] 括号必须有空格间隔，运算符与两边的参数页要有空格 若条件满足，则返回 TRUE (= 0)；若条件不满足，则返回 FALSE (&gt; 0)</p> </li><li> <p>与if语句配合</p> </li><li> <p>二元运算符 <code>[ 条件表达式 ] &amp;&amp; 满足条件执行语句 || 不满足条件执行语句</code> 类似其他语言中的<code>条件?满足执行语句:不满足执行语句</code></p> <p>条件表达式与两边 [] 括号必须有空格间隔，</p> </li></ul></li><li> <p>条件表达式</p> 
  <ul><li> <p>字符串比较 <code>-z 字符串</code> ：字符串是否为空。可用于判断变量是否存在、用户是否有输入等 <code>-n 字符串</code> ：字符串是否为非空 <code>字符串1 == 字符串2</code> 两字符串是否相等 (将两变量转换为字符串进行比较) <code>字符串1 = 字符串2</code> 同上，但为避免与赋值混淆，通常不这样写 <code>字符串1 != 字符串2</code> 两字符串是否不相等</p> </li><li> <p>整数比较 <code>整数1 -gt 整数2</code>：&gt; ，大于 (greater than) <code>整数1 -ge 整数2</code>：≥ ，大于等于 (greater equal) <code>整数1 -lt 整数2</code>：&lt; ，小于 (less than) <code>整数1 -le 整数2</code>：≤ ，小于等于 (little equal) <code>整数1 -eq 整数2</code>：= ，等于 (equal) <code>整数1 -ne 整数2</code>：≠ ，不等于 (not equal)</p> </li><li> <p>文件权限判断</p> 
    <ul><li> <p>根据文件权限进行判断 <code>-r 文件完整路径</code> readable：可读 <code>-w 文件完整路径</code> writable：可写 <code>-x 文件完整路径</code> executable：可执行</p> </li><li> <p>判断主要事项：文件的权限与文件的所在组、所有者、当前用户的所在组均有关系</p> </li></ul></li><li> <p>文件类型判断</p> 
    <ul><li> <p>根据文件类型进行判断 <code>-f 文件完整路径</code> file：文件存在且是常规文件 <code>-e 文件完整路径</code> exist：文件存在 <code>-d 文件完整路径</code> directory：文件存在并是个目录</p> 
      <ul><li> <p>注意：这里的判断并不精确，不论 所有者、所在组、其他组，只要其中任意一个有对应权限，就会判断为TRUE (输出 = 0)</p> </li></ul></li></ul></li><li> <p>两个文件进行比较 <code>文件1完整路径 -nt 文件2完整路径</code> newer than：文件1 比 文件2 新(修改时间新) <code>文件1完整路径 -ot 文件2完整路径</code> older than：文件1 比 文件2 旧(修改时间旧) <code>文件1完整路径 -ef 文件2完整路径</code> equal file：文件1 与 文件2 是否为同一个文件(Inode 号是否相同)可用于判断硬链接</p> </li><li> <p>多重条件判断 <code>条件1 -o 条件2</code> OR：逻辑或。条件1 或 条件2 满足，则为 TRUE <code>条件1 -a 条件2</code> AND：逻辑与。条件1 与 条件2 满足，则为TRUE <code>! 条件1</code> 逻辑非。条件1 不满足，则为真</p> </li></ul></li><li> <p>if语句</p> <pre>if [ 条件表达式1 ]; then
    满足 条件表达式1 时执行的条件
elif [ 条件表达式2 ]; then
    满足 条件表达式2 时执行的条件
else
    以上所有条件都不满足时的
fi</pre> <p>类似其他语言中的if条件语句，但注意最后的结束语句是fi 可省略elif和else部分 也可将then至于下一行，此时[]后不需要分号;</p> <pre>if [ 条件表达式 ]
then
    满足 条件表达式1 时执行的条件
elif [ 条件表达式2 ]
then
    满足 条件表达式2 时执行的条件
else
    以上所有条件都不满足时的
fi</pre> 
  <ul><li> <p>细节</p> 
    <ul><li> <p>if指令中的 条件表达式，遵从前文 Shell 的运算符的相关规则</p> 
      <ul><li> <p>有 4 种运算符：字符串比较、整数值比较、文件权限比较、文件类型比较</p> </li><li> <p>条件表达式 与两侧的 []中括号 要有空格</p> </li><li> <p>条件表达式中的运算符两侧要有空格</p> </li></ul></li><li> <p>if指令中，除了if...then...fi部分一定要有，elif...then...和else...部分可以没有</p> </li><li> <p>exit指令，类似于其他语言的break指令</p> 
      <ul><li> <p>若不使用此指令，则程序会按顺序执行所有判断</p> </li><li> <p>若使用此指令，则程序在执行此指令时会立即突出脚本，并返回对应的返回值(返回值可用 $? 进行查询，可用于报错和异常状态返回)</p> </li></ul></li></ul></li></ul></li></ul> 
<hr> 
<p>case语句</p> 
<ul><li> <pre>case $变量名 in
"值1")
    若变量值 = 值1，则执行此处语句
;;
"值2")
    若变量值 = 值2，则执行此处语句
;;
(...可有多个 case ...)
*)
    若以上变量值都不满足，则执行此处语句
;;
esac</pre> 
  <ul><li> <p>case 中的语句后，;;相当于其他语句中的break语句的作用，;;可另起一行，也可紧跟指令</p> </li><li> <p>每个条件判断语句中，"值XX"与)之间可有空格，也可无空格 其他语言常用的default分支，这里写法是*)</p> </li><li> <p>这里比较的实质是将所有变量转换为字符串，因此比较值要用 双引号""括起来</p> </li><li> <p>分支结束以esac结尾</p> </li></ul></li></ul> 
<hr> 
<p>for循环</p> 
<ul><li> <p>枚举：类似其他语言中的<code>foreach</code>语句，变量<code>i</code>相当于枚举变量</p> <pre># 1. 对变量的枚举：循环变量 依次等于 值1、值2、...、值n
for 循环变量 in 值1 值2 ... 值n   
do
    循环执行的程序代码
done

# 2. 对指令执行输出的枚举：循环变量依次等于变量执行输出结果中的每一个
for 循环变量 in $(指令)
do
    循环执行的程序代码
done
</pre> 
  <ul><li> <p>对变量的枚举</p> 
    <ol><li> <p>对传入参数(位置参数变量)的枚举：使用 <code>"$@"</code>，要使用 双引号""，否则输出不正确</p> </li></ol></li><li> <p>对指令执行输出的枚举</p> 
    <ol><li> <p>指令格式：<code>$(指令)</code> 或 <code>指令</code></p> </li><li> <p>指令输出中的间隔：制表符、换行符等。枚举根据这些符号进行变量的依次输出</p> </li></ol></li></ul></li><li> <p>循环：类似其他语言中的for语句，变量相当于计数变量</p> <pre>for (( 初始值;循环控制条件;每次循环变量的变化 ))   # 这里：变量值 = 初始值 + 循环次数 * 每次循环变化量
do
    循环执行的程序代码
done</pre> <p>循环的条件写法 初始值、循环控制条件、每次循环量的变化 之间，用 分号;来分隔，可加空格，也可不加空格</p> </li></ul> 
<p>while循环</p> 
<p>当条件满足时，一直循环运行语句；直到条件不满足时，退出循环</p> 
<pre>while [ 条件表达式 ]
do 
    满足条件所执行的语句
done
# 1+……+n
i=0
while [ $i -le $1]
do 
    SUM=$[ $SUM + $i]
    $i=$[ $i + 1]
done</pre> 
<p>until循环</p> 
<p>与<code>while</code>语句相反，若不满足条件，则一直循环执行指令；直到满足条件后，退出指令</p> 
<pre>until [ 条件表达式 ]
do
    不满足条件所执行的语句
done</pre> 
<p>read 读取控制台输入</p> 
<p>通过控制台，与用户实现交互并获取用户输入的数据。</p> 
<ul><li> <p><code>read [参数] [变量1 变量2 变量3]</code></p> </li><li> <p>常用参数 <code>-p "提示文字"</code> 指定提示的文字(用户看到文字后输入对应的数据) <code>-t 时间(整数)</code> 设定读取用户输入值的等待时间，单位秒(s)。若超时用户仍未输入，则不再等待直接执行指令</p> </li><li> <p>变量：存储用户输入的变量名</p> 
  <ol><li> <p>若输入多个变量，则根据分隔符将变量依次存放到变量中</p> </li><li> <p>若只输入一个变量，则将用户所有输入(除了换行符)都存入此变量中</p> </li><li> <p>若未输入变量，则用户的所有输入默认存放于<code>$REPLY</code>变量中</p> </li><li> <p>若输入变量个数 &gt; read 指令的变量数，则最后一个变量将用户输入的所有值存入此变量</p> </li></ol></li><li> <p>若输入变量个数 &lt; read 指令的变量数，则未被赋值的变量为空值 (可用<code>[ -n -z ]</code>判断表达式进行判断)</p> <pre>#交互方式读取用户输入的参数，并限时 10s
read -p "input a value in 10s please: " -t 10 USER_INPUT2</pre> </li></ul> 
<p>函数</p> 
<p><strong>Shell 中的函数有两种：系统函数、自定义函数</strong></p> 
<ul><li> <p>系统函数</p> 
  <ul><li> <p>basename 获取文件名</p> <p>去掉文件完整路径的多级路径 (和后缀名），返回文件名 (去掉后缀的文件名)</p> <pre># 可以在shell或cmd执行
basename 文件的完整路径 [文件后缀]
basename [pathname] [suffix]
basename [string] [suffix]
basename /home/aaa/test.txt .txt #test</pre> </li><li> <p>dirname 获取路径（与上面相反</p> <p>去掉文件完整路径中的文件名和后缀，返回文件路径</p> <pre># 可以在shell或cmd执行
dirname 文件的绝对路径
dirname /home/aaa/test.txt #/home/aaa</pre> <p></p> </li></ul></li><li> <p>自定义函数</p> 
  <ul><li> <pre>[function] 函数名 [()]
{
	函数指令;
	[return 返回值;]
}
示例：
function getSum()
{
	SUM=$[$n1+$n2]
	echo"SUM"
}
read -p "输入n1" n1
read -p "输入n2" n2
getSum $n1 $n2</pre> 
    <ul><li> <p>建议函数开头的省略写法 <code>function 函数名{}</code> <code>函数名() {}</code></p> </li><li> <p>返回值：整数值，范围 0-255。若不需要返回值可省略，默认返回值 = 0，返回值只能使用预定义变量<code>$?</code>来获取</p> </li><li> <p>指令 和 return 语句最后的双引号<code>;</code>均可省略</p> </li><li> <p>函数定义可在调用的语句之前，也可在调用的语句之后</p> </li></ul></li><li> <p>调用函数</p> 
    <ul><li> <p><code>函数名 [传入参数1 传入参数2 ... 传入参数n]</code>，不需要括号</p> </li><li> <p>若函数不需要传入参数，则传入参数部分可以省略</p> </li><li> <p>在函数中调用传入参数，使用位置参数变量<code>$1</code>、<code>$2</code>等。注意当传入参数大于等于 10 个后，要用 {} 将数字括起来，如第 11 个参数 ${11}</p> </li></ul></li></ul></li></ul> 
<hr> 
<p>备份数据库</p> 
<pre>#!/bin/bash 
#*.sh存放在/usr/sbin/
BACK_UP=/data/backup/db
DATA_TIME=${date +%Y-%m-%d_%H:%M:%S}
echo $DATA_TIME
HOST=localhost
USER=root
PASS_WD=root
DATABASE=testdb
# 判断是否存在该目录，否则创建目录
[ ! -d "${BACK_UP}/${DATA_TIME}" ] &amp;&amp; mkdir -p "${BACK_UP}/${DATA_TIME}"
mysqldump -u${USER} -p${PASS_WD} --host=${HOST} --databases ${DATABASE} | gzip &gt; ${BACK_UP}/${DATA_TIME}/$DATA_TIME.sql.gz
#将文件处理成tar.gz
cd ${BACK_UP}
tar -zcvf $DATA_TIME.tar.gz ${DATA_TIME}
#删除对应备份目录
rm -rf ${BACKUP}/${DATA_TIME}
#删除10天前的备份文件
find ${BACK_UP} -atime +10 -name "*.tar.gz" -exec rm -rf {} \;
echo "备份数据库${DATABASE}完成"</pre> 
<pre>crontab -e 
#编辑定时任务，每天凌晨2：30
30 2 * * * /usr/sbin/*.sh #光标要移回前面</pre> 
<hr> 
<h2 id="Linux%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86">Linux运维知识</h2> 
<h4 id="%E6%97%A5%E5%BF%97">日志</h4> 
<ul><li> <p>日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统 的安全信息、邮件相关信息、各种服务相关信息等。</p> </li><li> <p>日志对于安全来说也很重要，它记录了系统每天发生的各种事情，通过日志来检查错误发生的原因，或者受到攻击 时攻击者留下的痕迹。</p> </li><li> <p>可以这样理解日志是用来记录重大事件的工具</p> </li></ul> 
<p>/var/log/目录就是系统日志文件的保存位置</p> 
<table><thead><tr><th>日志文件</th><th>说明</th></tr></thead><tbody><tr><td><u>/var/log/boot.log</u></td><td><u>系统启动日志</u></td></tr><tr><td><u>/var/log/cron</u></td><td><u>记录与系统定时任务相关的日志</u></td></tr><tr><td>/var/log/cups/</td><td>记录打印信息的日志</td></tr><tr><td>/var/log/dmesg</td><td>记录了系统在开机时内核自检的信总，也可以使用dmesg目录直接查看内核自检信息</td></tr><tr><td>/var/log/btmp</td><td>记录错误登录的日志，这个文件是二进制文件，不能直接用VI查看，而要使用lastb命令查看，命令如下：<code>sudo lastb</code></td></tr><tr><td><u>/var/log/lasllog</u></td><td><u>记录系统中所有用户最后一次的登录时间的日志，这个文件也是二进制文件，要使用lastlog命令查看</u></td></tr><tr><td><u>/var/log/mailog</u></td><td><u>记录邮件信息的日志</u></td></tr><tr><td><u>/var/log/message</u></td><td><u>记录系统重要消息的日志，这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题，首先要检查这个日志文件</u></td></tr><tr><td><u>/var/log/secure</u></td><td><u>记录验证和授权方面的信息，只要涉及账户和密码的程序都会记录，比如系统登录，ssh的登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中</u></td></tr><tr><td>/var/log/wtmp</td><td>永久记录所有用户的登录，注销信息，同时记录系统的后动，重启，关机事件，是二进制文件，使用last命令查看</td></tr><tr><td><u>/var/log/ulmp</u></td><td><u>记录当前已经登录的用户的信息，这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息，这个文件不能用Vi查看，而要使用w,who,users等命令查看</u></td></tr></tbody></table> 
<p>由日志服务rsyslogd记录的日志文件，日志文件的格式包含以下4列：</p> 
<ul><li> <p>事件产生的时间</p> </li><li> <p>产生事件的服务器的主机名</p> </li><li> <p>产生事件的服务名或程序名</p> </li><li> <p>事件的具体信息</p> </li></ul> 
<hr> 
<p>日志管理服务 rsyslogd</p> 
<ul><li> <p>查询Linux中的rsyslogd服务是否启动</p> 
  <ul><li> <p>ps aux | grep "rsyslog" | grep -v "grep"</p> </li></ul></li><li> <p>查询rsyslogd服务的自启动状态</p> 
  <ul><li> <p>systemctl list-unit-files | grep rsyslog</p> </li></ul></li><li> <p>配置文件：/etc/rsyslog.conf</p> </li><li> <p>编辑文件时的格式为：*.* 存放日志文件，第一个*表示日志类型，第二个*表示日志级别</p> 
  <ul><li> 
    <table><thead><tr><th>日志类型</th><th>含义</th></tr></thead><tbody><tr><td>auth</td><td>pam产生的日志</td></tr><tr><td>authpriv</td><td>ssh.ftp等登录信息的验证信息</td></tr><tr><td>corn</td><td>时间任务相关</td></tr><tr><td>kern</td><td>内核</td></tr><tr><td>lpr</td><td>打印</td></tr><tr><td>mail</td><td>邮件</td></tr><tr><td>mark(syslog)-rsyslog</td><td>服务内部的信息，时间标识</td></tr><tr><td>news</td><td>新闻组</td></tr><tr><td>user</td><td>用户程序产生的相关信息</td></tr><tr><td>uucp</td><td>unix to nuix copy主机之间相关的</td></tr><tr><td>local 1-7</td><td>自定义的日志设备</td></tr></tbody></table></li><li> 
    <table><thead><tr><th>日志级别</th><th>意义</th></tr></thead><tbody><tr><td>debug</td><td>有调试信息的，日志通信最多</td></tr><tr><td>info</td><td>一般信息日志，最常用</td></tr><tr><td>notice</td><td>最具有重要性的普通条件的信息</td></tr><tr><td>warning</td><td>警告级别</td></tr><tr><td>err</td><td>错误级别，阻止某个功能或者模块不能正常工作的信息</td></tr><tr><td>crit</td><td>严重级别，阻止整个系统或者整个软件不能正常工作的信息</td></tr><tr><td>alert</td><td>需要立刻修改的信息</td></tr><tr><td>emerg</td><td>内核崩溃等重要信息</td></tr><tr><td>none</td><td>什么都不记录</td></tr></tbody></table><p>从上到下，级别从低到高，记录信息越来越少</p> </li></ul></li></ul> 
<hr> 
<p>日志轮替</p> 
<p>——把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后，就会进行删除</p> 
<ul><li> <p>日志轮替文件命名</p> 
  <ul><li> <p>使用logrotate（全局的日志轮替策略/规则）进行日志轮替管理，要想改变日志轮替文件名字，通过/etc/logrotate/conf配置文件中"dateext"参数</p> </li><li> <p>如果配置文件中有"dateext"参数，那么日志会用日期来作为日志文件的后缀，例如"secure-20201010"，这样日志文件名不会重叠，也就不需要日志文件的改名，只需要指定保存日志个数，删除多余的日志文件</p> </li><li> <p>如果配置文件中没有"dateext"参数，日志文件就需要进行改名，当第一次进行日志轮替时，当前的"secure"日志会自动改名为"secure.1"，然后新建"secure"日志，用来保存新的日志。当第二次进行日志轮替时，"secure.1"会自动改名，当前的"secure"日志会自动改名为"secure.1"，然后新建"secure"日志，用来保存新的日志，以此类推</p> </li></ul></li><li> <p>logrotate配置文件</p> <pre># rotate log files weekly, 每周对日志文件进行一次轮替
weekly
# keep 4 weeks worth of backlogs, 共保存4 份日志文件，当建立新的日志文件时，旧的将会被删除
rotate 4
# create new (empty) log files after rotating old ones, 创建新的空的日志文件，在日志轮替后
create
# use date as a suffix of the rotated file, 使用日期作为日志轮替文件的后缀
dateext
# uncomment this if you want your log files compressed, 日志文件是否压缩。如果取消注释，则日志会在转储的同时进
行压缩
#compress
#RPM packages drop log rotation information into this directory
include /etc/logrotate.d
# 包含/etc/logrotate.d/ 目录中所有的子配置文件。也就是说会把这个目录中所有子配置文件读取进来，
​
#下面是单独设置，优先级更高。
# no packages own wtmp and btmp -- we'll rotate them here
/var/log/wtmp {
monthly # 每月对日志文件进行一次轮替
create 0664 root utmp # 建立的新日志文件，权限是0664 ，所有者是root ，所属组是utmp 组
minsize 1M # 日志文件最小轮替大小是1MB 。也就是日志一定要超过1MB 才会轮替，否则就算时间达到
一个月，也不进行日志转储
rotate 1 # 仅保留一个日志备份。也就是只有wtmp 和wtmp.1 日志保留而已
}
/var/log/btmp {
missingok # 如果日志不存在，则忽略该日志的警告信息
monthly
create 0600 root utmp
rotate 1
}</pre> <p>参数说明</p> <pre>daily ：日志的轮替周期是每天
weekly ：日志的轮替周期是每周
monthly ：日志的轮替周期是每月
rotate 数字 ：保留的日志文件的个数。0 指没有备份
compress ：日志轮替时，旧的日志进行压缩
create mode owner group ：建立新日志，同时指定新日志的权限与所有者和所属组。
mail address ：当日志轮替时，输出内容通过邮件发送到指定的邮件地址。
missingok ：如果日志不存在，则忽略该日志的警告信息
notifempty ：如果日志为空文件，则不进行日志轮替
minsize ：大小日志轮替的最小值。也就是日志一定要达到这个最小值才会轮替，否则就算时间达到也不轮替
size ：大小日志只有大于指定大小才进行日志轮替，而不是按照时间轮替。
dateext ：使用日期作为日志轮替文件的后缀。
sharedscripts ：在此关键字之后的脚本只执行一次。
prerotate/endscript ：在日志轮替之前执行脚本命令。
postrotate/endscript ：在日志轮替之后执行脚本命令。</pre> 
  <ul><li> <p>把自己的日志加入日志轮替</p> 
    <ul><li> <p>第一种方法是直接在/etc/logrotate.conf 配置文件中写入该日志的轮替策略（如上）</p> </li><li> <p>第二种方法是在/etc/logrotate.d/目录中新建立该日志的轮替文件，在该轮替文件中写入正确的轮替策略，因为该目录 中的文件都会被“include”到主配置文件中，所以也可以把日志加入轮替。（推荐）</p> </li></ul></li></ul></li><li> <p>日志轮替机制原理</p> 
  <ul><li> <p>日志轮替之所以可以在指定的时间备份日志，是依赖系统定时任务。在/etc/cron.daily/目录，就会发现这个目录中是有logrotate 文件(可执行)，logrotate 通过这个文件依赖定时任务执行的。</p> </li></ul></li><li> <p>查看内存日志</p> 
  <ul><li> <p><code>journalctl</code> 可以查看内存日志, 这里我们看看常用的指令 <code>journalctl</code>##查看全部 <code>journalctl -n 3</code> ##查看最新3 条 <code>journalctl –since 19:00 –until 19:10:10</code> #查看起始时间到结束时间的日志可加日期 <code>journalctl -p err</code> ##报错日志 <code>journalctl -o verbose</code> ##日志详细内容 <code>journalctl _PID=1245 _COMM=sshd</code> ##查看包含这些参数的日志（在详细日志查看） 或者<code>journalctl | grep sshd</code></p> <p>注意: journalctl 查看的是内存日志, 重启清空</p> </li></ul></li><li> <p>制作minLinux系统</p> 
  <ul><li> <p>启动流程介绍：</p> 
    <ul><li> <p>制作Linux 小系统之前，再了解一下Linux 的启动流程： 1、首先Linux 要通过自检，检查硬件设备有没有故障 2、如果有多块启动盘的话，需要在BIOS 中选择启动磁盘 3、启动MBR 中的bootloader 引导程序 4、加载内核文件 5、执行所有进程的父进程、老祖宗systemd 6、欢迎界面</p> </li><li> <p>在Linux 的启动流程中，加载内核文件时关键文件： 1）kernel 文件: vmlinuz-3.10.0-957.el7.x86_64 2）initrd 文件: initramfs-3.10.0-957.el7.x86_64.img</p> </li></ul></li></ul></li></ul> 
<hr> 
<p>内核源码阅读介绍</p> 
<ul><li> <p>介绍</p> 
  <ul><li> <p>/boot ：和系统引擎相关的代码</p> </li><li> <p>/fs ：存放linux支持的文件系统代码</p> </li><li> <p>/init ：存储了 Linux 内核的初始化 相关代码 ; 该 初始化代码 关联到了 内存的各个组件 的入口 ;</p> 
    <ul><li> <p>time_init();#初始化运行时间</p> </li><li> <p>tty_init();#tty（终端）初始化</p> </li><li> <p>trap_init();#陷阱门（硬件中断向量）初始化</p> </li><li> <p>sched_init();#调度程序初始化</p> </li><li> <p>buffer_init();#缓存管理初始化</p> </li><li> <p>hd_init();#硬盘初始化</p> </li><li> <p>sti();#所有初始化工作完后，开启中断</p> </li><li> <p>move_to_user_mode();切换到用户模式</p> </li></ul></li><li> <p>/include ：存放linux核心需要的头文件，比如：asm，linux，sys</p> </li><li> <p>/kernel ：和系统内核相关的源码</p> </li><li> <p>/lib ：存放库代码</p> </li><li> <p>/mm ：和内存管理相关的代码</p> </li><li> <p>/tools ：工具相关代码</p> </li></ul></li></ul> 
<hr> 
<p>内核升级</p> 
<ul><li> <p>下载&amp;解压最新版</p> 
  <ul><li> <p><code>wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.11.2.tar.gz</code> <code>tar -zxvf linux-5.8.16.tar.gz</code></p> </li></ul></li><li> <p>升级步骤</p> 
  <ul><li> <p><code>uname -a</code> // 查看当前的内核版本 <code>yum info kernel -q</code> //检测内核版本，显示可以升级的内核 <code>yum update kernel</code> //升级内核 <code>yum list kernel -q</code> //查看已经安装的内核</p> </li></ul></li></ul> 
<hr> 
<h4 id="%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D">备份与恢复</h4> 
<p>实体机无法做快照，如果系统出现异常或者数据损坏，后果严重， 要重做系统，还会造成数据丢失。所以我们可 以使用备份和恢复技术 linux 的备份和恢复很简单， 有两种方式：</p> 
<ol><li> <p>把需要的文件(或者分区)用TAR 打包就行，下次需要恢复的时候，再解压开覆盖即可</p> </li><li> <p>使用dump 和restore 命令</p> </li></ol> 
<p>如果linux 上没有dump 和restore 指令，需要先按照 <code>yum -y install dump</code> <code>yum -y install restore</code></p> 
<ul><li> <p>dump 支持分卷和增量备份（所谓增量备份是指备份上次备份后修改/增加过的文件，也称差异备份）。</p> <p><code>dump [ -cu] [-123456789] [ -f &lt;备份后文件名&gt;] [-T &lt;日期&gt;] [ 目录或文件系统]</code> <code>dump []-wW</code> <code>-c</code> ： 创建新的归档文件，并将由一个或多个文件参数所指定的内容写入归档文件的开头。</p> 
  <ul><li> <p><code>-0123456789</code>： 备份的层级。0 为最完整备份，会备份所有文件。若指定0 以上的层级，则备份至上一次备份以来 修改或新增的文件, 到9 后，可以再次轮替.</p> </li></ul><p><code>-f</code>： &lt;备份后文件名&gt;： 指定备份后文件名 <code>-j</code> : 调用bzlib 库压缩备份文件，也就是将备份后的文件压缩成bz2 格式，让文件更小 <code>-T &lt;日期&gt;</code>： 指定开始备份的时间与日期 <code>-u</code> ： 备份完毕后，在/etc/dumpdares 中记录备份的文件系统，层级，日期与时间等。 <code>-t</code> ： 指定文件名，若该文件已存在备份文件中，则列出名称 <code>-W</code> ：显示需要备份的文件及其最后一次备份的层级，时间，日期。 <code>-w</code> ：与-W 类似，但仅显示需要备份的文件。</p> 
  <ul><li> <p>应用案例1</p> </li></ul><p>将/boot 分区所有内容备份到/opt/boot.bak0.bz2 文件中，备份层级为“0” <code>dump -0uj -f /opt/boot.bak0.bz2 /boot</code></p> 
  <ul><li> <p>应用案例2</p> </li></ul><p>在/boot 目录下增加新文件，备份层级为“1”(只备份上次使用层次“0”备份后发生过改变的数据), 注意比较看看 这次生成的备份文件boot1.bak 有多大 <code>dump -1uj -f /opt/boot.bak1.bz2 /boot</code> 通过dump 命令在配合crontab 可以实现无人值守备份。</p> <p>只有分区支持增量备份，备份文件或目录，不再支持增量备份，即只能使用0级别备份。</p> </li><li> <p>使用restore 完成恢复</p> <p>restore 命令用来恢复已备份的文件，可以从dump 生成的备份文件中恢复原文件</p> <p>restore [模式选项] [选项]</p> 
  <ul><li> <p>说明下面四个模式， 不能混用，在一次命令中， 只能指定一种。 -C ：使用对比模式，将备份的文件与已存在的文件相互对比。 -i：使用交互模式，在进行还原操作时，restors 指令将依序询问用户 -r：进行还原模式 -t : 查看模式，看备份文件有哪些文件</p> </li><li> <p>选项 -f &lt;备份设备&gt;：从指定的文件中读取备份数据，进行还原操作</p> </li><li> <p>应用案例1</p> 
    <ul><li> <p>restore 命令比较模式，比较备份文件和原文件的区别 <code>restore -C -f boot.bak1.bz2</code> //注意和最新的文件比较</p> </li></ul></li><li> <p>应用案例2</p> 
    <ul><li> <p>restore 命令查看模式，看备份文件有哪些数据/文件 <code>restore -t -f boot.bak0.bz2</code></p> </li></ul></li><li> <p>应用案例3</p> 
    <ul><li> <p>restore 命令还原模式, 注意细节： 如果你有增量备份，需要把增量备份文件也进行恢复， 有几个增量备份文件，就要恢复几个，按顺序来恢复即可。 mkdir /opt/boottmp cd /opt/boottmp restore -r -f /opt/boot.bak0.bz2 //恢复到第1 次完全备份状态 restore -r -f /opt/boot.bak1.bz2 //恢复到第2 次增量备份状态</p> </li></ul></li><li> <p>应用案例4</p> 
    <ul><li> <p>restore 命令恢复备份的文件，或者整个目录的文件 基本语法： <code>restore -r -f 备份好的文件</code> <code>mkdir etctmp</code> <code>cd etctmp/</code> <code>restore -r -f /opt/etc.bak0.bz2</code></p> </li></ul></li></ul></li></ul> 
<hr> 
<h4 id="Linux%20%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86">Linux 可视化管理</h4> 
<p>Webmin 是功能强大的基于Web 的Unix/linux 系统管理工具。管理员通过浏览器访问Webmin 的各种管理功能并完 成相应的管理操作。除了各版本的linux 以外还可用于：AIX、HPUX、Solaris、Unixware、Irix 和FreeBSD 等系统</p> 
<p>安装webmin&amp;配置</p> 
<ul><li> <p>下载地址: <a href="http://download.webmin.com/download/yum/" rel="nofollow" title="Index of /download/yum">Index of /download/yum</a> , 用下载工具下载即可</p> </li></ul> 
<p>也可以使用wget <a href="http://download.webmin.com/download/yum/webmin-1.700-1.noarch.rpm" rel="nofollow" title="http://download.webmin.com/download/yum/webmin-1.700-1.noarch.rpm">http://download.webmin.com/download/yum/webmin-1.700-1.noarch.rpm</a></p> 
<ul><li> <p>安装：<code>rpm -ivh webmin-1.700-1.noarch.rpm</code></p> <p>重置密码<code>/usr/libexec/webmin/changepass.pl /etc/webmin root test</code> root 是webmin 的用户名，不是OS 的, 这里就是把webmin 的root 用户密码改成了test</p> <p>修改webmin 服务的端口号（默认是10000 出于安全目的） <code>vim /etc/webmin/miniserv.conf # 修改端口</code></p> <p>将port=10000 修改为其他端口号，如port=6666</p> <p>重启webmin <code>/etc/webmin/restart # 重启 /etc/webmin/start # 启动 /etc/webmin/stop # 停止</code></p> <p>防火墙放开6666 端口 <code>firewall-cmd –zone=public –add-port=6666/tcp –permanent # 配置防火墙开放6666 端口 firewall-cmd –reload # 更新防火墙配置 firewall-cmd –zone=public –list-ports # 查看已经开放的端口号</code></p> </li><li> <p>登录webmin <a href="http://ip:6666/" rel="nofollow" title="http://ip:6666">http://ip:6666</a> 可以访问了 用root 账号和重置的新密码test</p> </li></ul> 
<p>bt宝塔</p> 
<p>bt 宝塔Linux 面板是提升运维效率的服务器管理软件，支持一键LAMP/LNMP/集群/监控/网站/FTP/数据库/JAVA 等 多项服务器管理功能。</p> 
<ul><li> <p>安装和使用</p> </li></ul> 
<ol><li> <p>安装:<code>yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</code></p> </li><li> <p>安装成功后控制台会显示登录地址，账户密码，复制浏览器打开登录，</p> </li></ol> 
<ul><li> <p>使用介绍， 比如可以登录终端, 配置，快捷安装运行环境和系统工具, 添加计划任务脚本</p> </li><li> <p>如果bt 的用户名，密码忘记了，使用bt default 可以查看</p> </li></ul> 
<hr> 
<h2 id="Linux%E9%9D%A2%E8%AF%95%E9%A2%98">Linux面试题</h2> 
<h4 id="%E7%BB%9F%E8%AE%A1%E8%AE%BF%E9%97%AE%E9%87%8F%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%95%B0">统计访问量和连接数</h4> 
<ul><li> <p><strong>分析日志t.log(访问量)，将各个ip 地址截取，并统计出现次数,并按从大到小排序(腾讯)</strong></p> <p><a href="http://192.168.200.10/index1.html" rel="nofollow" title="http://192.168.200.10/index1.html">http://192.168.200.10/index1.html</a> <a href="http://192.168.200.10/index2.html" rel="nofollow" title="http://192.168.200.10/index2.html">http://192.168.200.10/index2.html</a> <a href="http://192.168.200.20/index1.html" rel="nofollow" title="http://192.168.200.20/index1.html">http://192.168.200.20/index1.html</a> <a href="http://192.168.200.30/index1.html" rel="nofollow" title="http://192.168.200.30/index1.html">http://192.168.200.30/index1.html</a> <a href="http://192.168.200.40/index1.html" rel="nofollow" title="http://192.168.200.40/index1.html">http://192.168.200.40/index1.html</a> <a href="http://192.168.200.30/order.html" rel="nofollow" title="http://192.168.200.30/order.html">http://192.168.200.30/order.html</a> <a href="http://192.168.200.10/order.html" rel="nofollow" title="http://192.168.200.10/order.html">http://192.168.200.10/order.html</a> <code>cat t.txt | cut -d ‘/‘ -f 3 | sort | uniq -c | sort -nr</code></p> <p><strong>cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出</strong>。如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。</p> <p><code>cut [-bn] [file] cut [-c] [file] cut [-df] [file]</code></p> <p><strong>参数:</strong></p> 
  <ul><li> <p>-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。</p> </li><li> <p>-c ：以字符为单位进行分割。</p> </li><li> <p>-d ：自定义分隔符，默认为制表符。</p> </li><li> <p>-f ：与-d一起使用，指定显示哪个区域。</p> </li><li> <p>-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的 范围之内，该字符将被写出；否则，该字符将被排除</p> </li></ul><p><strong>uniq 可检查文本文件中重复出现的行列。</strong></p> <p><code>uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][--help][--version][输入文件][输出文件]</code></p> <p><strong>参数</strong>：</p> 
  <ul><li> <p>-c或--count 在每列旁边显示该行重复出现的次数。</p> </li><li> <p>-d或--repeated 仅显示重复出现的行列。</p> </li><li> <p>-f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt; 忽略比较指定的栏位。</p> </li><li> <p>-s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt; 忽略比较指定的字符。</p> </li><li> <p>-u或--unique 仅显示出一次的行列。</p> </li><li> <p>-w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt; 指定要比较的字符。</p> </li><li> <p>--help 显示帮助。</p> </li><li> <p>--version 显示版本信息。</p> </li><li> <p>[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；</p> </li><li> <p>[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。</p> </li></ul><p><strong>sort 可针对文本文件的内容，以行为单位来排序。</strong></p> <p><code>sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][--help][--verison][文件][-k field1[,field2]]</code></p> <p><strong>参数说明</strong>：</p> 
  <ul><li> <p>-b 忽略每行前面开始出的空格字符。</p> </li><li> <p>-c 检查文件是否已经按照顺序排序。</p> </li><li> <p>-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。</p> </li><li> <p>-f 排序时，将小写字母视为大写字母。</p> </li><li> <p>-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。</p> </li><li> <p>-m 将几个排序好的文件进行合并。</p> </li><li> <p>-M 将前面3个字母依照月份的缩写进行排序。</p> </li><li> <p>-n 依照数值的大小排序。</p> </li><li> <p>-u 意味着是唯一的(unique)，输出的结果是去完重了的。</p> </li><li> <p>-o&lt;输出文件&gt; 将排序后的结果存入指定的文件。</p> </li><li> <p>-r 以相反的顺序来排序。</p> </li><li> <p>-t&lt;分隔字符&gt; 指定排序时所用的栏位分隔字符。</p> </li><li> <p>+&lt;起始栏位&gt;-&lt;结束栏位&gt; 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</p> </li><li> <p>--help 显示帮助。</p> </li><li> <p>--version 显示版本信息。</p> </li><li> <p>[-k field1[,field2]] 按指定的列进行排序。</p> </li></ul></li></ul> 
<p><strong>统计连接到服务器的各个ip 情况，并按连接数从大到小排序(腾讯)</strong></p> 
<p><code>netstat -an | grep ESTABLISHED | awk -F "" '{print $5}' | cut -d “:” -f 1 | sort | uniq -c| sort -nr</code></p> 
<p><code>awk -F " " '{print $5}'</code>：以" "作为分隔符，打印第5行</p> 
<h4 id="%E6%89%BE%E5%9B%9EMysql%20root%E5%AF%86%E7%A0%81">找回Mysql root密码</h4> 
<ol><li> <p>在/etc/my.cnf中添加语句：<code>skip-grant-tables #跳过权限表</code></p> </li><li> <p>重启服务：<code>service mysqld restart</code></p> </li><li> <p>重新登录，进入mysql Database；查看user表中的字段，<code>authentication_string</code></p> </li><li> <p>更新密码（使用password函数加密）：<code>update user set authentication_string=password("123456") where user='root';</code></p> </li><li> <p>刷新：<code>flush privileges;</code></p> </li><li> <p>退出Mysql，删除/etc/my.cnf中添加的语句</p> </li><li> <p>重启服务</p> </li></ol> 
<h4 id="%E8%AE%BF%E9%97%AE%E9%87%8F%E6%8E%92%E5%90%8D%E5%92%8Ctcpdump">访问量排名和tcpdump</h4> 
<ul><li> <p>统计日志访问量排名前两个的IP访问情况</p> 
  <ul><li> <p><code>cat acces.log | awk -F " " '{print $1}' | sort | uniq -c | sort -nr | head -2</code></p> </li></ul></li></ul> 
<ul><li> <p>使用tcpdump监听本机，将来自某一个IP和端口的数据，保存到日志中</p> 
  <ul><li> <p><code>tcpdump -i ens33 host 192.168.88.140 and port 22 &gt;&gt; /opt/interview/tcpdump.log</code></p> </li></ul></li></ul> 
<ul><li> <p>常用的Nginx模块，用来做什么</p> <p>rewrite模块：实现重写功能</p> <p>access模块：来源控制</p> <p>ssl模块：安全加密</p> <p>ngx_http_gzip_module：网络传输压缩模块</p> <p>ngx_http_proxy_module模块实现代理</p> <p>ngx_http_upstream_module模块实现定义后端服务器列表</p> <p>ngx_cache_putge实现缓存清除功能</p> </li></ul> 
<h4 id="%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E5%88%92%E5%88%86">系统权限划分</h4> 
<p style="text-align:center;"><img alt="" height="486" src="https://images2.imgbox.com/b2/e0/OBxMNKsW_o.png" width="634"> </p> 
<p style="text-align:center;"><img alt="" height="319" src="https://images2.imgbox.com/90/b3/1P3sM14d_o.png" width="634"> </p> 
<p> </p> 
<ul><li> <p>chattr命令用于改变文件属性。</p> 
  <ol><li> <p>a：让文件或目录仅供附加用途。</p> </li><li> <p>b：不更新文件或目录的最后存取时间。</p> </li><li> <p>c：将文件或目录压缩后存放。</p> </li><li> <p>d：将文件或目录排除在倾倒操作之外。</p> </li><li> <p>i：不得任意更动文件或目录。</p> </li><li> <p>s：保密性删除文件或目录。</p> </li><li> <p>S：即时更新文件或目录。</p> </li><li> <p>u：预防意外删除。</p> </li></ol></li><li> <p>这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式：</p> </li><li> <pre>chattr [-RV][-v&lt;版本编号&gt;][+/-/=&lt;属性&gt;][文件或目录...]</pre> </li></ul> 
<ul><li> <p>-R 递归处理，将指定目录下的所有文件及子目录一并处理。</p> <p>　　-v&lt;版本编号&gt; 设置文件或目录版本。</p> <p>　　-V 显示指令执行过程。</p> <p>　　+&lt;属性&gt; 开启文件或目录的该项属性。</p> <p>　　-&lt;属性&gt; 关闭文件或目录的该项属性。</p> <p>　　=&lt;属性&gt; 指定文件或目录的该项属性。</p> </li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a05ea30e882106eb252d2e77653d988e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CSDN开发者云平台体验</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d3e8d40b752af9f5168c63cf948825f9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CREStereo： Practical Stereo Matching via Cascaded Recurrent Networkwith Adaptive Correlation-论文阅读</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>