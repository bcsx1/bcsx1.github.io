<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GPIO子系统（三） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GPIO子系统（三）" />
<meta property="og:description" content="1，简述 GPIO 资源是相对来说较为简单，而且比较通用（比如 LED 灯），而 Linux 的 GPIO 驱动属于 Linux Driver 中较为容易上手的部分，但是简单归简单，在 Linux 系统中，要使用 GPIO 资源，还是需要了解一些内容。
Linux Kernel 中对 GPIO 资源进行了抽象，抽象出一个叫做 Gpiolib 的东东，这个东东作为 GPIO 资源的管理核心存在：
中间层是 Gpiolib，用于管理系统中的 GPIO。Gpiolib 汇总了 GPIO 的通用操作，根据 GPIO 的特性，Gpiolib 对上（其他 Drivers）提供的一套统一通用的操作 GPIO 的软件接口，屏蔽了不同芯片的具体实现。对下，Gpiolib 提供了针对不同芯片操作的一套 framework，针对不同芯片，只需要实现 Specific Chip Driver ，然后使用 Gpiolib 提供的注册函数，将其挂接到 Gpiolib 上，这样就完成了这一套东西。
对于其他驱动来说，比如 LED 灯驱动，就需要用到通用的 Gpiolib 的函数来进行 I/O 口的操作。
2，Gpiolib相关数据结构分析 先分析数据结构，Gpiolib 其实就是围绕几个数据结构在做文章，数据结构以及抽象层次清楚了，代码自然很快。
数据结构主要定义在 include/linux/gpio/driver.h 和 /drivers/gpio/gpiolib.h 中
首先看一个数据结构，叫 struct gpio_chip （include/linux/gpio/driver.h）：
struct gpio_chip { const char *label; struct gpio_device *gpiodev; struct device *parent; struct module *owner; int (*request)(struct gpio_chip *gc, unsigned int offset); void (*free)(struct gpio_chip *gc, unsigned int offset); int (*get_direction)(struct gpio_chip *gc, unsigned int offset); int (*direction_input)(struct gpio_chip *gc, unsigned int offset); int (*direction_output)(struct gpio_chip *gc, unsigned int offset, int value); int (*get)(struct gpio_chip *gc, unsigned int offset); int (*get_multiple)(struct gpio_chip *gc, unsigned long *mask, unsigned long *bits); void (*set)(struct gpio_chip *gc, unsigned int offset, int value); void (*set_multiple)(struct gpio_chip *gc, unsigned long *mask, unsigned long *bits); int (*set_config)(struct gpio_chip *gc, unsigned int offset, unsigned long config); int (*to_irq)(struct gpio_chip *gc, unsigned int offset); void (*dbg_show)(struct seq_file *s, struct gpio_chip *gc); int (*init_valid_mask)(struct gpio_chip *gc, unsigned long *valid_mask, unsigned int ngpios); int (*add_pin_ranges)(struct gpio_chip *gc); int base; u16 ngpio; const char *const *names; bool can_sleep; #if IS_ENABLED(CONFIG_GPIO_GENERIC) unsigned long (*read_reg)(void __iomem *reg); void (*write_reg)(void __iomem *reg, unsigned long data); bool be_bits; void __iomem *reg_dat; void __iomem *reg_set; void __iomem *reg_clr; void __iomem *reg_dir_out; void __iomem *reg_dir_in; bool bgpio_dir_unreadable; int bgpio_bits; spinlock_t bgpio_lock; unsigned long bgpio_data; unsigned long bgpio_dir; #endif /* CONFIG_GPIO_GENERIC */ #ifdef CONFIG_GPIOLIB_IRQCHIP /* * With CONFIG_GPIOLIB_IRQCHIP we get an irqchip inside the gpiolib * to handle IRQs for most practical cases." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/cd73fc06aa40cc9f2fac9cc17740b6a0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-13T21:31:22+08:00" />
<meta property="article:modified_time" content="2023-10-13T21:31:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GPIO子系统（三）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>1，简述</h4> 
<p>GPIO 资源是相对来说较为简单，而且比较通用（比如 LED 灯），而 Linux 的 GPIO 驱动属于 Linux Driver 中较为容易上手的部分，但是简单归简单，在 Linux 系统中，要使用 GPIO 资源，还是需要了解一些内容。</p> 
<p>Linux Kernel 中对 GPIO 资源进行了抽象，抽象出一个叫做 Gpiolib 的东东，这个东东作为 GPIO 资源的管理核心存在：</p> 
<p><img alt="" height="424" src="https://images2.imgbox.com/f4/f5/xBnXyfpa_o.png" width="247"></p> 
<p>中间层是 Gpiolib，用于管理系统中的 GPIO。Gpiolib 汇总了 GPIO 的通用操作，根据 GPIO 的特性，Gpiolib 对上（其他 Drivers）提供的一套统一通用的操作 GPIO 的软件接口，屏蔽了不同芯片的具体实现。对下，Gpiolib 提供了针对不同芯片操作的一套 framework，针对不同芯片，只需要实现 Specific Chip Driver ，然后使用 Gpiolib 提供的注册函数，将其挂接到 Gpiolib 上，这样就完成了这一套东西。</p> 
<p>对于其他驱动来说，比如 LED 灯驱动，就需要用到通用的 Gpiolib 的函数来进行 I/O 口的操作。</p> 
<h4>2，Gpiolib相关数据结构分析</h4> 
<p>先分析数据结构，Gpiolib 其实就是围绕几个数据结构在做文章，数据结构以及抽象层次清楚了，代码自然很快。</p> 
<p>数据结构主要定义在 include/linux/gpio/driver.h 和 /drivers/gpio/gpiolib.h 中</p> 
<p>首先看一个数据结构，叫 struct gpio_chip （include/linux/gpio/driver.h）：</p> 
<pre><code class="language-cpp">struct gpio_chip {
    const char        *label;
    struct gpio_device    *gpiodev;
    struct device        *parent;
    struct module        *owner;

    int            (*request)(struct gpio_chip *gc,
                        unsigned int offset);
    void            (*free)(struct gpio_chip *gc,
                        unsigned int offset);
    int            (*get_direction)(struct gpio_chip *gc,
                        unsigned int offset);
    int            (*direction_input)(struct gpio_chip *gc,
                        unsigned int offset);
    int            (*direction_output)(struct gpio_chip *gc,
                        unsigned int offset, int value);
    int            (*get)(struct gpio_chip *gc,
                        unsigned int offset);
    int            (*get_multiple)(struct gpio_chip *gc,
                        unsigned long *mask,
                        unsigned long *bits);
    void            (*set)(struct gpio_chip *gc,
                        unsigned int offset, int value);
    void            (*set_multiple)(struct gpio_chip *gc,
                        unsigned long *mask,
                        unsigned long *bits);
    int            (*set_config)(struct gpio_chip *gc,
                          unsigned int offset,
                          unsigned long config);
    int            (*to_irq)(struct gpio_chip *gc,
                        unsigned int offset);


    void            (*dbg_show)(struct seq_file *s,
                        struct gpio_chip *gc);

    int            (*init_valid_mask)(struct gpio_chip *gc,
                           unsigned long *valid_mask,
                           unsigned int ngpios);

    int            (*add_pin_ranges)(struct gpio_chip *gc);

    int            base;
    u16            ngpio;
    const char        *const *names;
    bool            can_sleep;

#if IS_ENABLED(CONFIG_GPIO_GENERIC)
    unsigned long (*read_reg)(void __iomem *reg);
    void (*write_reg)(void __iomem *reg, unsigned long data);
    bool be_bits;
    void __iomem *reg_dat;
    void __iomem *reg_set;
    void __iomem *reg_clr;
    void __iomem *reg_dir_out;
    void __iomem *reg_dir_in;
    bool bgpio_dir_unreadable;
    int bgpio_bits;
    spinlock_t bgpio_lock;
    unsigned long bgpio_data;
    unsigned long bgpio_dir;
#endif /* CONFIG_GPIO_GENERIC */

#ifdef CONFIG_GPIOLIB_IRQCHIP
    /*
     * With CONFIG_GPIOLIB_IRQCHIP we get an irqchip inside the gpiolib
     * to handle IRQs for most practical cases.
     */

    /**
     * @irq:
     *
     * Integrates interrupt chip functionality with the GPIO chip. Can be
     * used to handle IRQs for most practical cases.
     */
    struct gpio_irq_chip irq;
#endif /* CONFIG_GPIOLIB_IRQCHIP */

    /**
     * @valid_mask:
     *
     * If not %NULL holds bitmask of GPIOs which are valid to be used
     * from the chip.
     */
    unsigned long *valid_mask;

#if defined(CONFIG_OF_GPIO)
    /*
     * If CONFIG_OF is enabled, then all GPIO controllers described in the
     * device tree automatically may have an OF translation
     */

    /**
     * @of_node:
     *
     * Pointer to a device tree node representing this GPIO controller.
     */
    struct device_node *of_node;

    /**
     * @of_gpio_n_cells:
     *
     * Number of cells used to form the GPIO specifier.
     */
    unsigned int of_gpio_n_cells;

    /**
     * @of_xlate:
     *
     * Callback to translate a device tree GPIO specifier into a chip-
     * relative GPIO number and flags.
     */
    int (*of_xlate)(struct gpio_chip *gc,
            const struct of_phandle_args *gpiospec, u32 *flags);
#endif /* CONFIG_OF_GPIO */

    ANDROID_KABI_RESERVE(1);
    ANDROID_KABI_RESERVE(2);
};
</code></pre> 
<p>gpio_chip 这个数据结构一看，很多函数指针结构，明眼人秒懂，此结构是为了抽象 GPIO 的所有操作，同时适配不同芯片的一个 common 的结构，所以，这个结构是要开出去给其他芯片进行特定的操作赋值的，比如你是 Qcom 的芯片，那么你需要实现你的这些 gpio_chip 的内容。</p> 
<p></p> 
<h5>2.1 gpio_chip 结构</h5> 
<p>一般的，在一个芯片中，针对所有的 I/O 口都会有配置，默认状态有些是 I/O 口全部默认 GPIO 输入（稳当）。一般芯片会提供管脚复用的功能（后期的 Linux 版本中，使用 pin control 来抽象），要使用 GPIO ，则首先需要配置他为 GPIO 功能，而不是其他的复用功能。</p> 
<p>而针对 GPIO 呢，有一些通用的特性，比如设置 GPIO 的方向，读 GPIO 的电平（输入的时候），写 GPIO 的电平（输出的时候），GPIO 作为外部中断输入，等等。</p> 
<p>gpio_chip 的抽象，其实是对 GPIO 一组 Bank 的抽象，通常在硬件上，一个芯片对 IO 口来说，分为了很多个 Bank，每个 Bank 分为了 N 组 GPIO。</p> 
<p>比如：1 个 SoC 将 I/O 分为了 4 个 Bank：</p> 
<pre><code class="language-cpp">Bank 1：GPIOA ～ GPIOB
Bank 2：GPIOC ～ GPIOD
Bank 3：GPIOE ～ GPIOF
Bank 4：GPIOG ～ GPIOH</code></pre> 
<p>然鹅，每个 Bank 都有 N 组寄存器来表示 GPIO 的操作，比如：</p> 
<p>Bank 1 中，针对 GPIO A：</p> 
<pre><code class="language-cpp">GPIOA_CFG 来表示对 GPIO A 的配置
GPIOA_PULL 来表示对 GPIO A 的上下拉的配置
GPIOA_DIR 来表示对 GPIO A 配置成为输入或者输出
GPIOA_DATA 来表示 GPIO A 设置为输出的时候设置为高低或者输入的时候读高低</code></pre> 
<p>当然，Bank 1 中 针对 GPIO B，也是一样的操作：</p> 
<pre><code class="language-cpp">GPIOB_CFG 来表示对 GPIO B 的配置
GPIOB_PULL 来表示对 GPIO B 的上下拉的配置
GPIOB_DIR 来表示对 GPIO B 配置成为输入或者输出
GPIOB_DATA 来表示 GPIO B 设置为输出的时候设置为高低或者输入的时候读高低</code></pre> 
<p>上面说的是一个 Bank 的情况，那么芯片有好几个 Bank，所以它们都是类似的，这里不在赘述。</p> 
<p>所以整体结构是如下所示（这里只是打个比方，有的芯片 Bank 很多，寄存器也很多）：</p> 
<p><img alt="" height="372" src="https://images2.imgbox.com/fd/ea/xa3XI2Qx_o.png" width="559"></p> 
<p>Linux Driver Gpiolib 对他们的抽象，使用 gpio_chip 对应了一组 Bank 描述，比如 Bank ·1，用一个 gpio_chip 来抽象：</p> 
<p><img alt="" height="144" src="https://images2.imgbox.com/2c/48/yatVRxm1_o.png" width="561"></p> 
<p>那么多个 Bank ，就用指针，或者数组来表示咯。当然这里可能说得有点不准确，gpio_chip 只是抽象了一组 Bank 的统一的接口而已。</p> 
<p>那么对于一颗芯片底层来说，需要根据芯片手册 Datasheet，来实现这些结构的接口。</p> 
<p></p> 
<h5>2.2 gpio_desc结构</h5> 
<p>既然系统分为多个 Bank，每个 Bank 又由几组组成，那么每个 GPIO 实体就由一个 gpio_desc 来描述：</p> 
<pre><code class="language-cpp">struct gpio_desc {
    struct gpio_device    *gdev;
    unsigned long        flags;
/* flag symbols are bit numbers */
#define FLAG_REQUESTED    0
#define FLAG_IS_OUT    1
#define FLAG_EXPORT    2    /* protected by sysfs_lock */
#define FLAG_SYSFS    3    /* exported via /sys/class/gpio/control */
#define FLAG_ACTIVE_LOW    6    /* value has active low */
#define FLAG_OPEN_DRAIN    7    /* Gpio is open drain type */
#define FLAG_OPEN_SOURCE 8    /* Gpio is open source type */
#define FLAG_USED_AS_IRQ 9    /* GPIO is connected to an IRQ */
#define FLAG_IRQ_IS_ENABLED 10    /* GPIO is connected to an enabled IRQ */
#define FLAG_IS_HOGGED    11    /* GPIO is hogged */
#define FLAG_TRANSITORY 12    /* GPIO may lose value in sleep or reset */
#define FLAG_PULL_UP    13    /* GPIO has pull up enabled */
#define FLAG_PULL_DOWN  14    /* GPIO has pull down enabled */
#define FLAG_BIAS_DISABLE    15    /* GPIO has pull disabled */
#define FLAG_EDGE_RISING     16    /* GPIO CDEV detects rising edge events */
#define FLAG_EDGE_FALLING    17    /* GPIO CDEV detects falling edge events */

    /* Connection label */
    const char        *label;
    /* Name of the GPIO */
    const char        *name;
#ifdef CONFIG_OF_DYNAMIC
    struct device_node    *hog;
#endif
#ifdef CONFIG_GPIO_CDEV
    /* debounce period in microseconds */
    unsigned int        debounce_period_us;
#endif
};</code></pre> 
<p>这个结构比较简单，可以看到，他包含了一个 gpio_device 的结构和 flag，以及 lable 和 name；</p> 
<p>gdev 指针指向了这个 gpio_desc 所属的 gpio_device（马上描述），flag 代表了这个 GPIO 的属性状态；</p> 
<p><img alt="" height="279" src="https://images2.imgbox.com/2b/99/GqOryD1j_o.png" width="536"></p> 
<p>看起来 gpio_chip 和 gpio_desc 应该是包含关系，但是 Kernel 中并没有直接将其两个结构联系上，而是通过另外一个结构将其联系在一起，这个结构就是 gpio_device。</p> 
<p></p> 
<h5>2.3 gpio_device结构</h5> 
<p>gpio_device 应该算是大内总管了（最新的内核有，Linux 3 版本的内核没有这个），如果说 gpio_chip 是对一个 Bank 的 GPIO 的硬件的具体抽象的话，那么 gpio_device 就是软件层面上对一个 Bank 的 GPIO 进行管理的单元，它的数据结构是：</p> 
<pre><code class="language-cpp">struct gpio_device {
    int            id;
    struct device        dev;
    struct cdev        chrdev;
    struct device        *mockdev;
    struct module        *owner;
    struct gpio_chip    *chip;
    struct gpio_desc    *descs;
    int            base;
    u16            ngpio;
    const char        *label;
    void            *data;
    struct list_head        list;
    struct blocking_notifier_head notifier;

#ifdef CONFIG_PINCTRL
    /*
     * If CONFIG_PINCTRL is enabled, then gpio controllers can optionally
     * describe the actual pin range which they serve in an SoC. This
     * information would be used by pinctrl subsystem to configure
     * corresponding pins for gpio usage.
     */
    struct list_head pin_ranges;
#endif
};</code></pre> 
<p><span style="color:#fe2c24;">在这个 gpio_device 结构中，包含了 gpio_chip（对接芯片的操作集），gpio_desc（一些 GPIO 的描述）；这个结构贯穿了整个 Gpiolib，因为 gpio_device 代表的是一个 Bank，一般的 GPIO 有多个 Bank，所以 Kernel 中，对这 gpio_device 的组织是由一个 gpio_devices 的链表构成（此处是多个 device，所以后面加了 s），在 gpiolib.c：</span></p> 
<pre><code class="language-cpp">LIST_HEAD(gpio_devices);</code></pre> 
<p><img alt="" height="545" src="https://images2.imgbox.com/b6/e5/s4LZ5SbI_o.png" width="1024"></p> 
<h5>2.4 gpio_chip/gpio_desc/gpio_device 结构体之间的关系</h5> 
<p><img alt="" height="791" src="https://images2.imgbox.com/ca/f5/hQtAnd4o_o.png" width="1049"></p> 
<h4>3，Gpiolib对接芯片底层</h4> 
<p>先聊聊 Gpiolib 是怎么对接到底层实际的驱动的。在前面的 2.1 部分讲过，底层需要对接的，其实对接的部分只有那些通用的操作，其实也就是 gpio_chip 这个玩意，所以，对接底层的部分，主要关心的是这个结构体，并且对这个结构体进行赋值的过程。</p> 
<p>在底层对接到 Gpiolib 的时候，主要是对 gpio_chip 进行实现，然后调用 gpiochip_add 的接口，向 Gpiolib 注册你的 GPIO 。</p> 
<p>实现的过程，主要是根据芯片手册，实现对应的 GPIO 的操作，也就是说，把寄存器操作编程成为函数，对接到这个 gpio_chip 结构体上。</p> 
<h5>3.1 gpio_chip具体芯片操作函数的填充 - 一个gpio controller驱动gpio-pl061.c</h5> 
<p>代码路径：drivers/gpio/gpio-pl061.c</p> 
<p>寄存器手册：<a href="http://access.ee.ntu.edu.tw/course/SOC%E5%AF%A6%E9%A9%97%E6%95%99%E6%9D%90/Version%203/Lab05_External%20IO%20Control/Doc/Ref/ddi0190_gpio_trm.pdf" rel="nofollow" title="http://access.ee.ntu.edu.tw/course/SOC%E5%AF%A6%E9%A9%97%E6%95%99%E6%9D%90/Version%203/Lab05_External%20IO%20Control/Doc/Ref/ddi0190_gpio_trm.pdf">http://access.ee.ntu.edu.tw/course/SOC%E5%AF%A6%E9%A9%97%E6%95%99%E6%9D%90/Version%203/Lab05_External%20IO%20Control/Doc/Ref/ddi0190_gpio_trm.pdf</a></p> 
<p>pl061是通过AMBA总线连接在SOC上的片上gpio controller，arm架构的芯片经过授权之后可以直接使用。</p> 
<p><img alt="" height="106" src="https://images2.imgbox.com/fc/52/AKStJbFy_o.png" width="699"></p> 
<p>部分寄存器描述：</p> 
<p><img alt="" height="1113" src="https://images2.imgbox.com/0d/eb/2D49gGrg_o.png" width="1108"></p> 
<p><img alt="" height="665" src="https://images2.imgbox.com/0b/7a/zhF4mRf5_o.png" width="1084"></p> 
<p>suspend/resume操作：</p> 
<pre><code class="language-cpp">#ifdef CONFIG_PM
//suspend函数中保存当前所有gpio pin寄存器状态
static int pl061_suspend(struct device *dev)
{
    struct pl061 *pl061 = dev_get_drvdata(dev);
    int offset;

    pl061-&gt;csave_regs.gpio_data = 0;
    pl061-&gt;csave_regs.gpio_dir = readb(pl061-&gt;base + GPIODIR);
    pl061-&gt;csave_regs.gpio_is = readb(pl061-&gt;base + GPIOIS);
    pl061-&gt;csave_regs.gpio_ibe = readb(pl061-&gt;base + GPIOIBE);
    pl061-&gt;csave_regs.gpio_iev = readb(pl061-&gt;base + GPIOIEV);
    pl061-&gt;csave_regs.gpio_ie = readb(pl061-&gt;base + GPIOIE);

    for (offset = 0; offset &lt; PL061_GPIO_NR; offset++) {
        if (pl061-&gt;csave_regs.gpio_dir &amp; (BIT(offset)))
            pl061-&gt;csave_regs.gpio_data |=
                pl061_get_value(&amp;pl061-&gt;gc, offset) &lt;&lt; offset;
    }

    return 0;
}

//resume函数中将gpio pin的寄存器状态恢复
static int pl061_resume(struct device *dev)
{
    struct pl061 *pl061 = dev_get_drvdata(dev);
    int offset;

    for (offset = 0; offset &lt; PL061_GPIO_NR; offset++) {
        if (pl061-&gt;csave_regs.gpio_dir &amp; (BIT(offset)))
            pl061_direction_output(&amp;pl061-&gt;gc, offset,
                    pl061-&gt;csave_regs.gpio_data &amp;
                    (BIT(offset)));
        else
            pl061_direction_input(&amp;pl061-&gt;gc, offset);
    }

    writeb(pl061-&gt;csave_regs.gpio_is, pl061-&gt;base + GPIOIS);
    writeb(pl061-&gt;csave_regs.gpio_ibe, pl061-&gt;base + GPIOIBE);
    writeb(pl061-&gt;csave_regs.gpio_iev, pl061-&gt;base + GPIOIEV);
    writeb(pl061-&gt;csave_regs.gpio_ie, pl061-&gt;base + GPIOIE);

    return 0;
}</code></pre> 
<p>probe函数流程：</p> 
<pre><code class="language-cpp">static int pl061_probe(struct amba_device *adev, const struct amba_id *id)
{
    struct device *dev = &amp;adev-&gt;dev;
    struct pl061 *pl061;
    struct gpio_irq_chip *girq;
    int ret, irq;

    pl061 = devm_kzalloc(dev, sizeof(*pl061), GFP_KERNEL);
    if (pl061 == NULL)
        return -ENOMEM;

    pl061-&gt;base = devm_ioremap_resource(dev, &amp;adev-&gt;res);
    if (IS_ERR(pl061-&gt;base))
        return PTR_ERR(pl061-&gt;base);

    //填充gpio_chip中的回调函数
    raw_spin_lock_init(&amp;pl061-&gt;lock);
    pl061-&gt;gc.request = gpiochip_generic_request;
    pl061-&gt;gc.free = gpiochip_generic_free;
    pl061-&gt;gc.base = -1;
    pl061-&gt;gc.get_direction = pl061_get_direction;
    pl061-&gt;gc.direction_input = pl061_direction_input;
    pl061-&gt;gc.direction_output = pl061_direction_output;
    pl061-&gt;gc.get = pl061_get_value;
    pl061-&gt;gc.set = pl061_set_value;
    pl061-&gt;gc.ngpio = PL061_GPIO_NR; //8
    pl061-&gt;gc.label = dev_name(dev);
    pl061-&gt;gc.parent = dev;
    pl061-&gt;gc.owner = THIS_MODULE;

    /*
     * irq_chip support
     */
    pl061-&gt;irq_chip.name = dev_name(dev);
    pl061-&gt;irq_chip.irq_ack    = pl061_irq_ack;
    pl061-&gt;irq_chip.irq_mask = pl061_irq_mask;
    pl061-&gt;irq_chip.irq_unmask = pl061_irq_unmask;
    pl061-&gt;irq_chip.irq_set_type = pl061_irq_type;
    pl061-&gt;irq_chip.irq_set_wake = pl061_irq_set_wake;

    writeb(0, pl061-&gt;base + GPIOIE); /* disable irqs */
    irq = adev-&gt;irq[0];
    if (!irq)
        dev_warn(&amp;adev-&gt;dev, "IRQ support disabled\n");
    pl061-&gt;parent_irq = irq;

    girq = &amp;pl061-&gt;gc.irq;
    girq-&gt;chip = &amp;pl061-&gt;irq_chip;
    girq-&gt;parent_handler = pl061_irq_handler;
    girq-&gt;num_parents = 1;
    girq-&gt;parents = devm_kcalloc(dev, 1, sizeof(*girq-&gt;parents),
                     GFP_KERNEL);
    if (!girq-&gt;parents)
        return -ENOMEM;
    girq-&gt;parents[0] = irq;
    girq-&gt;default_type = IRQ_TYPE_NONE;
    girq-&gt;handler = handle_bad_irq;

    //注册gpio资源
    ret = devm_gpiochip_add_data(dev, &amp;pl061-&gt;gc, pl061);
    if (ret)
        return ret;

    amba_set_drvdata(adev, pl061);
    dev_info(dev, "PL061 GPIO chip registered\n");

    return 0;
}</code></pre> 
<p>几个gpio_chip函数的实现 - pl061_get_direction</p> 
<pre><code class="language-cpp">static int pl061_get_direction(struct gpio_chip *gc, unsigned offset)
{
    //per-instance data assigned by the driver， return gc-&gt;gpiodev-&gt;data
    struct pl061 *pl061 = gpiochip_get_data(gc);

    //读取GPIODIR寄存器判断是输入或者输出并返回结果
    if (readb(pl061-&gt;base + GPIODIR) &amp; BIT(offset))
        return GPIO_LINE_DIRECTION_OUT;

    return GPIO_LINE_DIRECTION_IN;
}</code></pre> 
<p>几个gpio_chip函数的实现 -pl061_set_value</p> 
<pre><code class="language-cpp">static void pl061_set_value(struct gpio_chip *gc, unsigned offset, int value)
{
    struct pl061 *pl061 = gpiochip_get_data(gc);

    //设置GPIODATA寄存器
    writeb(!!value &lt;&lt; offset, pl061-&gt;base + (BIT(offset + 2)));
}</code></pre> 
<h5>3.2 gpiochip_add_data_with_key</h5> 
<p>1）</p> 
<pre><code class="language-cpp">int gpiochip_add_data_with_key(struct gpio_chip *gc, void *data,
                   struct lock_class_key *lock_key,
                   struct lock_class_key *request_key)
{
    struct fwnode_handle *fwnode = gc-&gt;parent ? dev_fwnode(gc-&gt;parent) : NULL;
    unsigned long    flags;
    int        ret = 0;
    unsigned    i;
    int        base = gc-&gt;base;
    struct gpio_device *gdev;
    bool        block_gpio_read = false;

    /*
     * First: allocate and populate the internal stat container, and
     * set up the struct device.
     */
    gdev = kzalloc(sizeof(*gdev), GFP_KERNEL);
    if (!gdev)
        return -ENOMEM;
    gdev-&gt;dev.bus = &amp;gpio_bus_type;
    gdev-&gt;chip = gc;
    gc-&gt;gpiodev = gdev;
    if (gc-&gt;parent) {
        gdev-&gt;dev.parent = gc-&gt;parent;
        gdev-&gt;dev.of_node = gc-&gt;parent-&gt;of_node;
    }

    of_gpio_dev_init(gc, gdev);

    /*
     * Assign fwnode depending on the result of the previous calls,
     * if none of them succeed, assign it to the parent's one.
     */
    gdev-&gt;dev.fwnode = dev_fwnode(&amp;gdev-&gt;dev) ?: fwnode;
    
    //给chip分配唯一的ID
    gdev-&gt;id = ida_alloc(&amp;gpio_ida, GFP_KERNEL);
    if (gdev-&gt;id &lt; 0) {
        ret = gdev-&gt;id;
        goto err_free_gdev;
    }

    ret = dev_set_name(&amp;gdev-&gt;dev, GPIOCHIP_NAME "%d", gdev-&gt;id);
    if (ret)
        goto err_free_ida;

    device_initialize(&amp;gdev-&gt;dev);
    if (gc-&gt;parent &amp;&amp; gc-&gt;parent-&gt;driver)
        gdev-&gt;owner = gc-&gt;parent-&gt;driver-&gt;owner;
    else if (gc-&gt;owner)
        /* TODO: remove chip-&gt;owner */
        gdev-&gt;owner = gc-&gt;owner;
    else
        gdev-&gt;owner = THIS_MODULE;</code></pre> 
<p>因为传入的结构是 gpio_chip，他代表了是一个 Bank，但是并没有 gpio_device 的结构，所以，在这个函数中，首先分配一个 gpio_device 的结构，并将其结构体成员的 chip ，等等进行赋值，建立起相关的结构联系。</p> 
<p>2）</p> 
<pre><code class="language-cpp"> gdev-&gt;descs = kcalloc(gc-&gt;ngpio, sizeof(gdev-&gt;descs[0]), GFP_KERNEL);
    if (!gdev-&gt;descs) {
        ret = -ENOMEM;
        goto err_free_dev_name;
    }

    if (gc-&gt;ngpio == 0) {
        chip_err(gc, "tried to insert a GPIO chip with zero lines\n");
        ret = -EINVAL;
        goto err_free_descs;
    }

    if (gc-&gt;ngpio &gt; FASTPATH_NGPIO)
        chip_warn(gc, "line cnt %u is greater than fast path cnt %u\n",
              gc-&gt;ngpio, FASTPATH_NGPIO);

    gdev-&gt;label = kstrdup_const(gc-&gt;label ?: "unknown", GFP_KERNEL);
    if (!gdev-&gt;label) {
        ret = -ENOMEM;
        goto err_free_descs;
    }

    gdev-&gt;ngpio = gc-&gt;ngpio;
    gdev-&gt;data = data;</code></pre> 
<p><span style="color:#fe2c24;">由于 1 个 Bank不仅仅只有一个 GPIO，所以 gpio_chip-&gt;ngpio 的结构表示了这个 Bank 一共的 GPIO 个数，每一个 GPIO 使用一个 gpio_desc 表示，所以，这里分配了 ngpio 个 descs；</span></p> 
<p> 3）</p> 
<pre><code class="language-cpp"> spin_lock_irqsave(&amp;gpio_lock, flags);

    /*
     * TODO: this allocates a Linux GPIO number base in the global
     * GPIO numberspace for this chip. In the long run we want to
     * get *rid* of this numberspace and use only descriptors, but
     * it may be a pipe dream. It will not happen before we get rid
     * of the sysfs interface anyways.
     */
    if (base &lt; 0) {
        base = gpiochip_find_base(gc-&gt;ngpio);
        if (base &lt; 0) {
            ret = base;
            spin_unlock_irqrestore(&amp;gpio_lock, flags);
            goto err_free_label;
        }
        /*
         * TODO: it should not be necessary to reflect the assigned
         * base outside of the GPIO subsystem. Go over drivers and
         * see if anyone makes use of this, else drop this and assign
         * a poison instead.
         */
        gc-&gt;base = base;
    }
    gdev-&gt;base = base;

    ret = gpiodev_add_to_list(gdev);
    if (ret) {
        spin_unlock_irqrestore(&amp;gpio_lock, flags);
        goto err_free_label;
    }

    for (i = 0; i &lt; gc-&gt;ngpio; i++)
        gdev-&gt;descs[i].gdev = gdev;

    spin_unlock_irqrestore(&amp;gpio_lock, flags);

    BLOCKING_INIT_NOTIFIER_HEAD(&amp;gdev-&gt;notifier);

#ifdef CONFIG_PINCTRL
    INIT_LIST_HEAD(&amp;gdev-&gt;pin_ranges);
#endif

    if (gc-&gt;names)
        ret = gpiochip_set_desc_names(gc);
    else
        ret = devprop_gpiochip_set_names(gc);
    if (ret)
        goto err_remove_from_list;

    ret = gpiochip_alloc_valid_mask(gc);
    if (ret)
        goto err_remove_from_list;

    ret = of_gpiochip_add(gc);
    if (ret)
        goto err_free_gpiochip_mask;

    ret = gpiochip_init_valid_mask(gc);
    if (ret)
        goto err_remove_of_chip;

    trace_android_vh_gpio_block_read(gdev, &amp;block_gpio_read);
    if (!block_gpio_read) {
        for (i = 0; i &lt; gc-&gt;ngpio; i++) {
            struct gpio_desc *desc = &amp;gdev-&gt;descs[i];

            if (gc-&gt;get_direction &amp;&amp; gpiochip_line_is_valid(gc, i)) {
                assign_bit(FLAG_IS_OUT,
                       &amp;desc-&gt;flags, !gc-&gt;get_direction(gc, i));
            } else {
                assign_bit(FLAG_IS_OUT,
                       &amp;desc-&gt;flags, !gc-&gt;direction_input);
            }
        }
    }

    ret = gpiochip_add_pin_ranges(gc);
    if (ret)
        goto err_remove_of_chip;

    acpi_gpiochip_add(gc);

    machine_gpiochip_add(gc);

    ret = gpiochip_irqchip_init_valid_mask(gc);
    if (ret)
        goto err_remove_acpi_chip;

    ret = gpiochip_irqchip_init_hw(gc);
    if (ret)
        goto err_remove_acpi_chip;

    ret = gpiochip_add_irqchip(gc, lock_key, request_key);
    if (ret)
        goto err_remove_irqchip_mask;

    /*
     * By first adding the chardev, and then adding the device,
     * we get a device node entry in sysfs under
     * /sys/bus/gpio/devices/gpiochipN/dev that can be used for
     * coldplug of device nodes and other udev business.
     * We can do this only if gpiolib has been initialized.
     * Otherwise, defer until later.
     */
    if (gpiolib_initialized) {
        ret = gpiochip_setup_dev(gdev);
        if (ret)
            goto err_remove_irqchip;
    }
    return 0;

err_remove_irqchip:
    gpiochip_irqchip_remove(gc);
err_remove_irqchip_mask:
    gpiochip_irqchip_free_valid_mask(gc);
err_remove_acpi_chip:
    acpi_gpiochip_remove(gc);
err_remove_of_chip:
    gpiochip_free_hogs(gc);
    of_gpiochip_remove(gc);
err_free_gpiochip_mask:
    gpiochip_remove_pin_ranges(gc);
    gpiochip_free_valid_mask(gc);
err_remove_from_list:
    spin_lock_irqsave(&amp;gpio_lock, flags);
    list_del(&amp;gdev-&gt;list);
    spin_unlock_irqrestore(&amp;gpio_lock, flags);
err_free_label:
    kfree_const(gdev-&gt;label);
err_free_descs:
    kfree(gdev-&gt;descs);
err_free_dev_name:
    kfree(dev_name(&amp;gdev-&gt;dev));
err_free_ida:
    ida_free(&amp;gpio_ida, gdev-&gt;id);
err_free_gdev:
    /* failures here can mean systems won't boot... */
    pr_err("%s: GPIOs %d..%d (%s) failed to register, %d\n", __func__,
           gdev-&gt;base, gdev-&gt;base + gdev-&gt;ngpio - 1,
           gc-&gt;label ? : "generic", ret);
    kfree(gdev);
    return ret;
}
EXPORT_SYMBOL_GPL(gpiochip_add_data_with_key);</code></pre> 
<p>base 代表了每个 Bank 的编号，将其赋值；然后通过 gpiodev_add_to_list(gdev) 将这个 gdev 挂到全局的 gpio_devices ：</p> 
<pre><code class="language-cpp">/*
* Add a new chip to the global chips list, keeping the list of chips sorted
* by range(means [base, base + ngpio - 1]) order.
*
* Return -EBUSY if the new chip overlaps with some other chip's integer
* space.
*/
static int gpiodev_add_to_list(struct gpio_device *gdev)
{
    struct gpio_device *prev, *next;

    if (list_empty(&amp;gpio_devices)) {
        /* initial entry in list */
        list_add_tail(&amp;gdev-&gt;list, &amp;gpio_devices);
        return 0;
    }

    next = list_entry(gpio_devices.next, struct gpio_device, list);
    if (gdev-&gt;base + gdev-&gt;ngpio &lt;= next-&gt;base) {
        /* add before first entry */
        list_add(&amp;gdev-&gt;list, &amp;gpio_devices);
        return 0;
    }

    prev = list_entry(gpio_devices.prev, struct gpio_device, list);
    if (prev-&gt;base + prev-&gt;ngpio &lt;= gdev-&gt;base) {
        /* add behind last entry */
        list_add_tail(&amp;gdev-&gt;list, &amp;gpio_devices);
        return 0;
    }

    list_for_each_entry_safe(prev, next, &amp;gpio_devices, list) {
        /* at the end of the list */
        if (&amp;next-&gt;list == &amp;gpio_devices)
            break;

        /* add between prev and next */
        if (prev-&gt;base + prev-&gt;ngpio &lt;= gdev-&gt;base
                &amp;&amp; gdev-&gt;base + gdev-&gt;ngpio &lt;= next-&gt;base) {
            list_add(&amp;gdev-&gt;list, &amp;prev-&gt;list);
            return 0;
        }
    }

    dev_err(&amp;gdev-&gt;dev, "GPIO integer space overlap, cannot add chip\n");
    return -EBUSY;
}</code></pre> 
<p>接着就是设置一些 name 字段，配置中断之类的，初始化每个 desc[] 结构的 flags，最后调用：</p> 
<pre><code class="language-cpp">    if (gpiolib_initialized) {
        ret = gpiochip_setup_dev(gdev);
        if (ret)
            goto err_remove_irqchip;
    }</code></pre> 
<p>然后，不出意外的话，返回 0；</p> 
<p></p> 
<p>这里说一下 gpiochip_setup_dev 调用，这个是在 Gpiolib init 的时候调用 gpiochip_setup_devs：</p> 
<pre><code class="language-cpp">static int __init gpiolib_dev_init(void)
{
    int ret;

    /* Register GPIO sysfs bus */
    ret = bus_register(&amp;gpio_bus_type);
    if (ret &lt; 0) {
        pr_err("gpiolib: could not register GPIO bus type\n");
        return ret;
    }

    ret = driver_register(&amp;gpio_stub_drv);
    if (ret &lt; 0) {
        pr_err("gpiolib: could not register GPIO stub driver\n");
        bus_unregister(&amp;gpio_bus_type);
        return ret;
    }

    ret = alloc_chrdev_region(&amp;gpio_devt, 0, GPIO_DEV_MAX, GPIOCHIP_NAME);
    if (ret &lt; 0) {
        pr_err("gpiolib: failed to allocate char dev region\n");
        driver_unregister(&amp;gpio_stub_drv);
        bus_unregister(&amp;gpio_bus_type);
        return ret;
    }

    gpiolib_initialized = true;
    gpiochip_setup_devs();

#if IS_ENABLED(CONFIG_OF_DYNAMIC) &amp;&amp; IS_ENABLED(CONFIG_OF_GPIO)
    WARN_ON(of_reconfig_notifier_register(&amp;gpio_of_notifier));
#endif /* CONFIG_OF_DYNAMIC &amp;&amp; CONFIG_OF_GPIO */

    return ret;
}
core_initcall(gpiolib_dev_init);</code></pre> 
<p>而这个 gpiochip_setup_devs 对每一个 gpio_devicecs 节点调用：gpiochip_setup_dev：</p> 
<pre><code class="language-cpp">static void gpiochip_setup_devs(void)
{
    struct gpio_device *gdev;
    int ret;

    list_for_each_entry(gdev, &amp;gpio_devices, list) {
        ret = gpiochip_setup_dev(gdev);
        if (ret)
            dev_err(&amp;gdev-&gt;dev,
                "Failed to initialize gpio device (%d)\n", ret);
    }
}</code></pre> 
<p>最后到：</p> 
<pre><code class="language-cpp">static int gpiochip_setup_dev(struct gpio_device *gdev)
{
    int ret;

    ret = gcdev_register(gdev, gpio_devt);
    if (ret)
        return ret;

    ret = gpiochip_sysfs_register(gdev);
    if (ret)
        goto err_remove_device;

    /* From this point, the .release() function cleans up gpio_device */
    gdev-&gt;dev.release = gpiodevice_release;
    dev_dbg(&amp;gdev-&gt;dev, "registered GPIOs %d to %d on %s\n", gdev-&gt;base,
        gdev-&gt;base + gdev-&gt;ngpio - 1, gdev-&gt;chip-&gt;label ? : "generic");

    return 0;

err_remove_device:
    gcdev_unregister(gdev);
    return ret;
}
</code></pre> 
<p>其实就是注册了字符设备，并且添加到了 sysfs；</p> 
<p>debug logs：</p> 
<pre><code class="language-cpp">char dev节点：/sys/bus/gpio/devices
ls -l /sys/bus/gpio/devices
total 0
lrwxrwxrwx 1 root root 0 2023-09-21 06:52 gpiochip0 -&gt; ../../../devices/platform/soc/f000000.pinctrl/gpiochip0
lrwxrwxrwx 1 root root 0 2023-09-21 06:52 gpiochip1 -&gt; ../../../devices/platform/soc/c42d000.qcom,spmi/spmi-0/0-00/c42d000.qcom,spmi:qcom,pmk8350@0:pinctrl@b000/gpiochip1
lrwxrwxrwx 1 root root 0 2023-09-21 06:52 gpiochip2 -&gt; ../../../devices/platform/soc/c42d000.qcom,spmi/spmi-0/0-02/c42d000.qcom,spmi:qcom,pm8350c@2:pinctrl@8800/gpiochip2
lrwxrwxrwx 1 root root 0 2023-09-21 06:52 gpiochip3 -&gt; ../../../devices/platform/soc/c42d000.qcom,spmi/spmi-0/0-01/c42d000.qcom,spmi:qcom,pm7325@1:pinctrl@8800/gpiochip3
lrwxrwxrwx 1 root root 0 2023-09-21 06:52 gpiochip4 -&gt; ../../../devices/platform/soc/c42d000.qcom,spmi/spmi-0/0-03/c42d000.qcom,spmi:qcom,pm8350b@3:pinctrl@8800/gpiochip4
lrwxrwxrwx 1 root root 0 2023-09-21 06:52 gpiochip5 -&gt; ../../../devices/platform/soc/soc:spf_core_platform/soc:spf_core_platform:lpi_pinctrl@3440000/gpiochip5

sysfs节点 /sys/class/gpio
ls -l /sys/class/gpio/
total 0
--w------- 1 root root 4096 2023-09-21 06:53 export
lrwxrwxrwx 1 root root    0 2023-09-21 06:53 gpiochip287 -&gt; ../../devices/platform/soc/soc:spf_core_platform/soc:spf_core_platform:lpi_pinctrl@3440000/gpio/gpiochip287
lrwxrwxrwx 1 root root    0 2023-09-21 06:53 gpiochip310 -&gt; ../../devices/platform/soc/c42d000.qcom,spmi/spmi-0/0-03/c42d000.qcom,spmi:qcom,pm8350b@3:pinctrl@8800/gpio/gpiochip310
lrwxrwxrwx 1 root root    0 2023-09-21 06:53 gpiochip318 -&gt; ../../devices/platform/soc/c42d000.qcom,spmi/spmi-0/0-01/c42d000.qcom,spmi:qcom,pm7325@1:pinctrl@8800/gpio/gpiochip318
lrwxrwxrwx 1 root root    0 2023-09-21 06:53 gpiochip328 -&gt; ../../devices/platform/soc/c42d000.qcom,spmi/spmi-0/0-02/c42d000.qcom,spmi:qcom,pm8350c@2:pinctrl@8800/gpio/gpiochip328
lrwxrwxrwx 1 root root    0 2023-09-21 06:53 gpiochip337 -&gt; ../../devices/platform/soc/c42d000.qcom,spmi/spmi-0/0-00/c42d000.qcom,spmi:qcom,pmk8350@0:pinctrl@b000/gpio/gpiochip337
lrwxrwxrwx 1 root root    0 2023-09-21 06:53 gpiochip341 -&gt; ../../devices/platform/soc/f000000.pinctrl/gpio/gpiochip341
--w------- 1 root root 4096 2023-09-21 06:53 unexport</code></pre> 
<pre><code class="language-cpp">dev_dbg(&amp;gdev-&gt;dev, "registered GPIOs %d to %d on %s\n", gdev-&gt;base, gdev-&gt;base + gdev-&gt;ngpio - 1, gdev-&gt;chip-&gt;label ? : "generic");

05-23 16:18:33.460     1     1 E gpiochip0: (f000000.pinctrl): william_gpio added GPIO chardev (254:0)
05-23 16:18:33.460     1     1 E gpiochip0: william_gpio registered GPIOs 341 to 511 on f000000.pinctrl
05-23 16:18:35.347   357   357 E gpiochip1: (c42d000.qcom,spmi:qcom,pmk8350@0:pinctrl@b000): william_gpio added GPIO chardev (254:1)
05-23 16:18:35.347   357   357 E gpiochip1: william_gpio registered GPIOs 337 to 340 on c42d000.qcom,spmi:qcom,pmk8350@0:pinctrl@b000
05-23 16:18:35.351   357   357 E gpiochip2: (c42d000.qcom,spmi:qcom,pm8350c@2:pinctrl@8800): william_gpio added GPIO chardev (254:2)
05-23 16:18:35.351   357   357 E gpiochip2: william_gpio registered GPIOs 328 to 336 on c42d000.qcom,spmi:qcom,pm8350c@2:pinctrl@8800
05-23 16:18:35.361   357   357 E gpiochip3: (c42d000.qcom,spmi:qcom,pm7325@1:pinctrl@8800): william_gpio added GPIO chardev (254:3)
05-23 16:18:35.361   357   357 E gpiochip3: william_gpio registered GPIOs 318 to 327 on c42d000.qcom,spmi:qcom,pm7325@1:pinctrl@8800
05-23 16:18:35.362   357   357 E gpiochip4: (c42d000.qcom,spmi:qcom,pm8350b@3:pinctrl@8800): william_gpio added GPIO chardev (254:4)
05-23 16:18:35.362   357   357 E gpiochip4: william_gpio registered GPIOs 310 to 317 on c42d000.qcom,spmi:qcom,pm8350b@3:pinctrl@8800
09-21 01:52:25.519   758   758 E gpiochip5: (soc:spf_core_platform:lpi_pinctrl@3440000): william_gpio added GPIO chardev (254:5)
09-21 01:52:25.519   758   758 E gpiochip5: william_gpio registered GPIOs 287 to 309 on soc:spf_core_platform:lpi_pinctrl@3440000


chip       base  ngpio  gdev-&gt;chip-&gt;label
gpiochip0  341   170    f000000.pinctrl
gpiochip1  337   3      pmk8350@0:pinctrl@b000
gpiochip2  328   8      pm8350c@2:pinctrl@8800
gpiochip3  318   9      pm7325@1:pinctrl@8800
gpiochip4  310   7      pm8350b@3:pinctrl@8800
gpiochip5  287   22     lpi_pinctrl@3440000</code></pre> 
<p>个人理解，因为不知道这个 init 和我们的对接底层的驱动的 init 谁先执行到，所以用了一个变量 gpiolib_initialized 来表示当前的 Gpiolib 是不是已经完成了相关的字符设备的注册，如果是 Gpiolib 先去 init 的话，那么 gpiolib_initialized  ture，芯片对接底层的部分错过 gpio_chip setup 的机会，所以需要重新调用这个 gpiochip_setup_dev 接口，反之 OK；</p> 
<p></p> 
<p>到这里，对接底层驱动的部分基本上 OK 了，小伙伴们需要按照自己芯片的 Specific 去做自己的 gpio_chip 结构并最终通过 gpiochip_add_data 添加到 Gpiolib 子系统中；</p> 
<p></p> 
<p>还有一点需要注意到的是，小伙伴们需要自行定义一些结构，来获得并表示自己 Bank 的虚拟地址等等，这样才能操作到实际的硬件寄存器；</p> 
<h4>4，gpiolib 向上提供的操作接口</h4> 
<p>两种不同的gpio框架:</p> 
<p> * descriptor-based interface: 基于描述符的接口, 新框架, 官方推荐;</p> 
<p> * legacy integer-based interface: 基于整数的接口;</p> 
<p></p> 
<h5>4.1 基于描述符的gpio在dts中使用</h5> 
<p>参考:</p> 
<p>Documentation/gpio/board.txt</p> 
<pre><code class="language-cpp">#include &lt;linux/gpio/consumer.h&gt;

foo_device {
    compatible = "acme,foo";
    ...
    led-gpios = &lt;&amp;gpio 15 GPIO_ACTIVE_HIGH&gt;, /* red */
                &lt;&amp;gpio 16 GPIO_ACTIVE_HIGH&gt;, /* green */
                &lt;&amp;gpio 17 GPIO_ACTIVE_HIGH&gt;; /* blue */

    power-gpio = &lt;&amp;gpio 18 GPIO_ACTIVE_LOW&gt;;
};

struct gpio_desc *red, *green, *blue, *power;

red = gpiod_get_index(dev, "led", 0);
green = gpiod_get_index(dev, "led", 1);
blue = gpiod_get_index(dev, "led", 2);
power = gpiod_get(dev, "power");

gpiod_direction_output(red, 1);
gpiod_direction_output(green, 1);
gpiod_direction_output(blue, 1);
gpiod_direction_output(power, 1);

gpiod_put(red);    //释放gpio口;</code></pre> 
<p>dts中gpio label的写法: name-gpios, 其中name是gpiod_get*()函数里的第二个参数;</p> 
<p>The led GPIOs will be active-high, while the power GPIO will be active-low;</p> 
<p>gpiod_is_active_low(power); 为true;</p> 
<p></p> 
<h5>4.2 基于整数的gpio在dts中使用</h5> 
<pre><code class="language-cpp">device_node {
    ...
    gpio_name = &lt;&amp;tlmm 99 0&gt;;
    ...
}

int gpio_99 = of_get_named_gpio_flags(dev-&gt;of_node, "gpio_name", 0, NULL);
gpio_request(gpio_99, "gpio_name");                //通过gpio号申请gpio
gpio_direction_output(gpio_99, 1);                //设置gpio_99输出，初始值为1
gpio_set_value(gpio_99, 0);                        //设置gpio_99值为0
gpio_free(gpio_99);                             

gpio_get_value(gpio_99, 0);                        //获取gpio_99的值</code></pre> 
<p>这种方法目前最常用;</p> 
<p>gpio_request()流程：</p> 
<pre><code class="language-cpp">gpio_request()
    *desc = gpio_to_desc(gpio);
    gpiod_request(desc, label);
        gpiod_request_commit(desc, label);
            offset = gpio_chip_hwgpio(desc);
            gc-&gt;request(gc, offset);
                pl061-&gt;gc.request = gpiochip_generic_request;
                    pinctrl_gpio_request(gc-&gt;gpiodev-&gt;base + offset); //drivers/pinctrl/core.c
                        pin = gpio_to_pin(range, gpio);
                        pinmux_request_gpio(pctldev, range, pin, gpio);
                            pin_request(pctldev, pin, owner, range);
                                ops-&gt;gpio_request_enable(pctldev, gpio_range, pin);</code></pre> 
<p>可以看到GPIO子系统是通过pinctrl子系统来实现的。</p> 
<p>gpio_direction_output()流程：</p> 
<pre><code class="language-cpp">gpio_direction_output()
    gpiod_direction_output_raw(gpio_to_desc(gpio), value);
        gpiod_direction_output_raw_commit(desc, value);
            *gc = desc-&gt;gdev-&gt;chip;
            gc-&gt;direction_output(gc, gpio_chip_hwgpio(desc), val);
                pl061-&gt;gc.direction_output = pl061_direction_output;</code></pre> 
<h5>4.3 Device-managed variants函数</h5> 
<p>代码路径：drivers/gpio/gpiolib-devres.c</p> 
<pre><code class="language-cpp">struct gpio_desc *devm_gpiod_get(struct device *dev, const char *con_id,
                     enum gpiod_flags flags)

struct gpio_desc *devm_gpiod_get_index(struct device *dev,
                       const char *con_id,
                       unsigned int idx,
                       enum gpiod_flags flags)

struct gpio_desc *devm_gpiod_get_optional(struct device *dev,
                      const char *con_id,
                      enum gpiod_flags flags)

struct gpio_desc * devm_gpiod_get_index_optional(struct device *dev,
                        const char *con_id,
                        unsigned int index,
                        enum gpiod_flags flags)</code></pre> 
<p>释放gpio:</p> 
<pre><code class="language-cpp">void gpiod_put(struct gpio_desc *desc);
void devm_gpiod_put(struct device *dev, struct gpio_desc *desc);      </code></pre> 
<h5>4.4 新旧框架的相互转换</h5> 
<pre><code class="language-cpp">gpio与gpio_desc结构体的相互转换:
static struct gpio_desc gpio_desc[ARCH_NR_GPIOS];    //gpiolib.c
gpio_to_desc(unsigned gpio)    
    &amp;gpio_desc[gpio]    //这里的gpio_desc是同名结构体的数组;
    
int desc_to_gpio(const struct gpio_desc *desc)    //gpiolib.c
    return desc - &amp;gpio_desc[0];</code></pre> 
<p></p> 
<p>参考链接：</p> 
<p><a href="https://blog.csdn.net/zhoutaopower/article/details/98082006" title="Linux GPIO 驱动 （gpiolib）_devm_gpiochip_add_data-CSDN博客">Linux GPIO 驱动 （gpiolib）_devm_gpiochip_add_data-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/verdicty/article/details/122673438" title="linux gpio学习笔记(gpiolib)_devm_gpiod_get_verdicty的博客-CSDN博客">linux gpio学习笔记(gpiolib)_devm_gpiod_get_verdicty的博客-CSDN博客</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5c80d6510ed309a73bb4dd6669542803/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java基础学习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d245870ccd6996258de40d9c47e79b92/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MATLAB online</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>