<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA 进程线程详解 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JAVA 进程线程详解" />
<meta property="og:description" content="线程和进程 一、进程 进程是指运行中的程序，比如我们使用QQ，就启动该进程分配内存空间.进程是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自升的产生，存在和消亡的过程 二、线程 线程是由进程创建的，是进程的一个实体一个进程可以拥有多个线程 一个想线程还可以创建它的子线程 三、其他概念 单线程：同时允许执行一个线程
多线程：同一个时刻，可以执行多个线程
比如：QQ可以打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件 并发：同一个时刻，多个任务交替执行，造成&#34;貌似同时&#34;的错觉，简单的说，单核CPU实现的多任务就是并发
并行：同一个时刻，多个任务同时执行。多核CPU可以同时执行
也可能出现：并行和并发，并存在的情况 四、线程的基本使用 在Java中线程来使用有两种方法
基础Thread类，重写run方法
实现Runnable接口，重写run方法
案例一 ![image-20220327105831422](!
)
package com.hspedu.threaduse; /** * @author DL5O * @version 1.0 * 通过继承Thread 类创建线程 */ public class Thread01 { public static void main(String[] args) throws InterruptedException { //创建Cat对象，可以当做线程使用 Cat cat = new Cat(); //启动线程，调用start的时候还调用run方法 cat.start();//最终执行 -&gt; cat的run方法 //cat.run(); //如果这样写，run方法就是一个普通的方法， // 是由主线程调用了，并没有真正的开线程， // 会阻塞在这里，执行完毕后才会继续执行下面的代码 //说明：当main线程启动一个子线程thread-0，主线程不会阻塞, // 即不会等待cat.start执行完毕后再往下执行 //主线程中如果后面还有代码的话，还会继续执行 //这时我们的主线程和主线程 是交替执行的 System.out.println(&#34;继续执行~~,&#34;&#43;Thread.currentThread().getName()); for (int i = 0; i &lt; 60; i&#43;&#43;) { System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/1c5158a83fc3fd110716384214d3db29/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-09T19:24:34+08:00" />
<meta property="article:modified_time" content="2022-04-09T19:24:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA 进程线程详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>线程和进程</h3> 
<h3>一、进程</h3> 
<ol><li>进程是指运行中的程序，比如我们使用QQ，就启动该进程分配内存空间.</li><li>进程是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自升的产生，存在和消亡的过程</li></ol> 
<h3>二、线程</h3> 
<ol><li>线程是由进程创建的，是进程的一个实体</li><li>一个进程可以拥有多个线程 
  <ul><li>一个想线程还可以创建它的子线程</li></ul></li></ol> 
<h3>三、其他概念</h3> 
<ol><li> <p>单线程：同时允许执行一个线程</p> </li><li> <p>多线程：同一个时刻，可以执行多个线程</p> 
  <ul><li>比如：QQ可以打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件</li></ul></li><li> <p>并发：同一个时刻，多个任务交替执行，造成"貌似同时"的错觉，简单的说，单核CPU实现的多任务就是并发</p> </li><li> <p>并行：同一个时刻，多个任务同时执行。多核CPU可以同时执行</p> 
  <ul><li>也可能出现：并行和并发，并存在的情况</li></ul></li></ol> 
<h3>四、线程的基本使用</h3> 
<p>在Java中线程来使用有两种方法</p> 
<ol><li> <p>基础Thread类，重写run方法</p> </li><li> <p>实现Runnable接口，重写run方法</p> </li></ol> 
<h4>案例一</h4> 
<p>![image-20220327105831422](!</p> 
<p>)</p> 
<pre>package com.hspedu.threaduse;

/**
 * @author DL5O
 * @version 1.0
 * 通过继承Thread 类创建线程
 */

public class Thread01 {
    public static void main(String[] args) throws InterruptedException {
        //创建Cat对象，可以当做线程使用
        Cat cat = new Cat();
        //启动线程，调用start的时候还调用run方法
        cat.start();//最终执行 -&gt; cat的run方法
        //cat.run();
        //如果这样写，run方法就是一个普通的方法，
        // 是由主线程调用了，并没有真正的开线程，
        // 会阻塞在这里，执行完毕后才会继续执行下面的代码


        //说明：当main线程启动一个子线程thread-0，主线程不会阻塞,
        // 即不会等待cat.start执行完毕后再往下执行
        //主线程中如果后面还有代码的话，还会继续执行
        //这时我们的主线程和主线程 是交替执行的
        System.out.println("继续执行~~,"+Thread.currentThread().getName());
        for (int i = 0; i &lt; 60; i++) {
            System.out.println("主线程 i=" + i);
            //休眠1秒
            Thread. sleep(1000);
        }
    }
}

//1.当一个类继承了Thread 类，该类就可以当做一个线程使用
//2.我们会重写run方法，写上自己的业务逻辑
//3.run方法在Thread也是实现了Runnable 接口的run方法
class Cat extends Thread {
    int times = 0;

    @Override
    public void run() {//重写run方法，写上自己的业务逻辑
        while (true) {
            //每隔一秒钟，输出"喵喵，我是小猫咪"
            System.out.println("喵喵，我是小猫咪" + (++times)
                    + ",线程名称=" + Thread.currentThread().getName());
            //让线程休眠1秒钟
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            if (times == 80) {
                break;//当times 等于80就退出这个while循环，这时线程就退出了
            }
        }
    }
}</pre> 
<ol><li>当运行这个程序代码的时候，会创建一个进程并给他分配空间</li><li>会先执行main方法，开启一个main线程</li><li>当执行到 <code>car.start()</code> 方法时会开启一个新的线程，这个线程是mian线程的子线程 
  <ul><li>注意： 
    <ul><li>这个 <code>car.start()</code> 是非阻塞的，即不会等到这个方法执行完后才继续往下执行</li><li><code>car.start()</code> 线程开启后，会去调用run方法！！ 
      <ul><li>但是如果直接写car.run()，这个时候则是用的主线程main线程去调用的，并没有开启新线程，执行玩这个方法后才会往下继续执行</li></ul></li></ul></li></ul></li></ol> 
<p>执行过程</p> 
<pre>(1)
public synchronized void start() {
    start0();
}
(2)
//start0() 是本地方法，是JVM调用，底层是c/c++实现的
//真正实现多线程的是start0(),而不是run方法
 private native void start0();</pre> 
<h4>案例二</h4> 
<p>实现runnable接口</p> 
<p>说明：</p> 
<pre>Runnalb
</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a3/c6/JreFqw7W_o.png"></p> 
<pre>package com.hspedu.threaduse;

/**
 * @author DL5O
 * @version 1.0
 * 通过实现接口Runnable 来开发线程
 */
public class Thread02 {
    public static void main(String[] args){
        Dog dog = new Dog();
        //dog.start(); 这里不能调用start
        //创建了Thread对象，把 dog对象,实现了Runnable,放入thread
        Thread thread = new Thread(dog);
        thread.start();

        /*Tiger tiger = new Tiger();//实现了runnable接口
        ThreadProxy threadProxy = new ThreadProxy(tiger);
        threadProxy.start();
        System.out.println("哈哈哈哈");*/
        System.out.println("哈哈哈");
    }
}

class Animal{}

class Tiger extends Animal implements Runnable{

    @Override
    public void run() {
        System.out.println("老虎嗷嗷叫...");
    }
}

//模拟了最简的Thread类
class ThreadProxy implements Runnable{//可以当做ThreadProxy ,线程代理

    private Runnable target = null;//属性，类型是Runnable

    @Override
    public void run() {
        if(target != null){
            target.run();//进行动态绑定 运行类型是tiger，即实现了Runnable的类
        }
    }

    public ThreadProxy(Runnable target) {
        this.target = target;
    }

    public void start(){
        start0();//这个方法是真正实现多线程的方法
    }

    private void start0() {
        run();
    }

}

class Dog implements Runnable{

    int count = 0;
    @Override
    public void run() {//普通方法，并没有启动线程
        while(true){
            System.out.println("小狗汪汪叫..hi" + (++count) + Thread.currentThread().getName());
            //休眠一秒
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            if(count == 10){
                break;
            }
        }

    }
}</pre> 
<ul><li>把实现了runnable接口的对象传入到thread类，进行静态代理，调用start方法时，会去调用start0方法，start0方法还会调用对应该类的run方法，run方法又会去调用传入的对象的run方法，进行动态绑定</li></ul> 
<h4>案例三</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2a/45/RtVsol2s_o.png"></p> 
<pre>package com.hspedu.threaduse;

/**
 * @author DL5O
 * @version 1.0
 * main 线程启动两个子线程
 */
public class Thread03 {
    public static void main(String[] args) {
        T1 t1 = new T1();
        T2 t2 = new T2();
        Thread thread1 = new Thread(t1);//创建t1线程，用于输出hello,world
        Thread thread2 = new Thread(t2);//创建t2线程，用于输出hi

        thread1.start();
        thread2.start();

    }
}

class T1 implements Runnable {
    int count = 0;

    @Override
    public void run() {
        while (true) {
            System.out.println("hello,world " + (++count) + " "+Thread.currentThread().getName());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            if (count == 10) {
                break;
            }
        }
    }
}

class T2 implements Runnable {
    int count = 0;
    @Override
    public void run() {
        while (true) {
            System.out.println("hi " + (++count) + " " + Thread.currentThread().getName());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (count == 5) {
                break;
            }
        }
    }
}</pre> 
<ul><li>若还有线程没有执行完毕，那么主进程就不会退出</li></ul> 
<h3>五、继承Thread vs 实现Runnable有什么区别</h3> 
<ol><li>从java的设计来看，通过继承Thread或者实现Runnable接口来创建线程本<br> 质上没有区别,从jdk帮助文档我们可以看到Thread类本身就实现了Runnable接口</li><li>实现 <strong>Runnable接口方式更加适合多个线程共享一个资源的情况</strong> ，并且避免了<br> 单继承的限制,建议使用 <strong>Runnable</strong></li></ol> 
<pre>package com.hspedu.ticket;

/**
 * @author DL5O
 * @version 1.0
 * 使用多线程，模拟三个窗口同时售票
 * 总票数 100 张
 */
public class SellTicket {
    public static void main(String[] args) {
        //第一种方式
        //测试
        /*SellTicket01 sellTicket01 = new SellTicket01();
        SellTicket01 sellTicket02 = new SellTicket01();
        SellTicket01 sellTicket03 = new SellTicket01();

        sellTicket01.start();
        sellTicket02.start();
        sellTicket03.start();*/

        System.out.println("===使用接口的方式来售票===");
        SellTicket02 sellTicket02 = new SellTicket02();
        Thread thread1 = new Thread(sellTicket02);
        Thread thread2 = new Thread(sellTicket02);
        Thread thread3 = new Thread(sellTicket02);
        thread1.start();//第一个线程-窗口
        thread2.start();//第二个线程-窗口
        thread3.start();//第三个线程-窗口
    }
}


//使用第一种继承thread的方式
class SellTicket01 extends Thread{
    private static int ticketNum = 100;//让多个线程共享 ticketNum
    @Override
    public void run() {
        while (true){
            if (ticketNum &lt;= 0){
                System.out.println("售票结束..");
                break;
            }
            //休眠50毫秒
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("窗口 " + Thread.currentThread().getName()
                    + " 售出一张票" + "剩余票数=" + (--ticketNum));
        }
    }
}

//实现接口的方式
class SellTicket02 implements Runnable{
    private int ticketNum = 100;

    @Override
    public void run() {
        while (true){
            if (ticketNum &lt;= 0){
                System.out.println("售票结束..");
                break;
            }
            //休眠50毫秒
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("窗口 " + Thread.currentThread().getName()
                    + " 售出一张票" + "剩余票数=" + (--ticketNum));
        }
    }
}</pre> 
<ul><li>会出现超卖，和票数对不上的情况，这时候程序就会存在很大的问题=&gt; 引出互斥等概念</li></ul> 
<h3>六、线程的退出</h3> 
<p>基本说明：</p> 
<ol><li>当线程完成任务后，会自动退出</li><li>还可以通过变量来控制 <strong>run方法</strong> 退出的方式停止线程，即 <strong>通知方式</strong></li></ol> 
<pre>package com.hspedu.exit_;

/**
 * @author DL5O
 * @version 1.0
 */
public class ThreadExitTest_ {
    public static void main(String[] args) throws InterruptedException {
        Test test = new Test();
        test.start();

        Thread.sleep(10*1000);
        test.setLoop(false);
    }
}
class Test extends Thread{
    private boolean loop = true;
    private int cnt = 0;
    @Override
    public void run() {
        while(loop){
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Test 执行中" + (++cnt));
        }
        System.out.println("Test 运行结束");
    }

    public boolean isLoop() {
        return loop;
    }

    public void setLoop(boolean loop) {
        this.loop = loop;
    }

    public int getCnt() {
        return cnt;
    }

    public void setCnt(int cnt) {
        this.cnt = cnt;
    }
}</pre> 
<h3>七、线程常用方法</h3> 
<h4>常用方法第一组</h4> 
<ol><li>setName：给线程设置名称</li><li>getName：返回线程的名称</li><li>start：使线程开始执行</li><li>run：线程调用的run方法</li><li>setPriority：设置线程的优先级</li><li>getPriority：获取线程的优先级</li><li>sleep：让正在执行的线程休眠几秒</li><li>interrupt：中断线程</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/23/e1/mBp7duRS_o.png"></p> 
<ol><li>start底层会创建新的线程，会调用run，run本身不会启动新线程，不会启动新线程</li><li>线程优先级的范围</li><li><strong>interrupt</strong> ，中断线程，但并没有真正结束线程。所以一般用于中断正在休眠线程</li><li><strong>sleep</strong> ：线程的静态方法，使当前线程休眠</li></ol> 
<p>案例：</p> 
<p>ThreadMethod01</p> 
<pre>package com.hspedu.method;

/**
 * @author DL5O
 * @version 1.0
 */
public class ThreadMethod01 {
    public static void main(String[] args) throws InterruptedException {
        T t = new T();
        t.setName("大龙");
        t.setPriority(Thread.MIN_PRIORITY);//设置最小的优先级
        t.start();//启动子线程

        //主线程打印5 个hi, 然后我就中断 子线程的休眠
        for (int i = 0; i &lt; 5; i++) {
            Thread.sleep(1000);
            System.out.println("hi " + (i+1));
        }

        System.out.println(t.getName() + " 线程的优先级 = " + t.getPriority());//1
        t.interrupt();//中断该线程，当执行到这里，就会中断，t线程的休眠

    }
}

class T extends Thread {//自定义的线程类

    @Override
    public void run() {
        while (true) {
            for (int i = 0; i &lt; 100; i++) {
                System.out.println(Thread.currentThread().getName() + " 吃包子~~~" + (i + 1));

            }
            try {
                System.out.println("大龙休息中~~");
                Thread.sleep(20 * 1000);
            } catch (InterruptedException e) {
                //InterruptedException 是捕获到一个终端异常
                System.out.println(Thread.currentThread().getName() + "被 interrupt了");
            }
        }
    }
}</pre> 
<h4>常用方法第二组</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/50/38/UghB2GZw_o.png"></p> 
<p>注意：</p> 
<ul><li>在某一个线程后使用了类名.join方法，那么会cpu会全部去执行 这个插队的线程，并且当这个线程全部执行完后，才会继续执行原来的线程</li></ul> 
<pre>package com.hspedu.method;

/**
 * @author DL5O
 * @version 1.0
 */
public class ThreadMethod02 {
    public static void main(String[] args) throws InterruptedException {
        int count = 0;
        Test test = new Test();
        test.start();
        while (true){
            System.out.println("hello " + (++count));
            Thread.sleep(1000);
            if(count == 5){
                System.out.println("让test 线程先执行");
//                test.join();//线程插队一定会成功
                Thread.yield();//线程礼让

                //让test 线程先执行，执行后可以看到，当执行join后，主线程就不再执行，
                // 当这个test线程执行完毕后，主线程才继续执行
            }
            if(count == 20){
                break;
            }
        }


    }
}

class Test extends Thread{
    private int count = 0;
    @Override
    public void run() {
        while(true){
            System.out.println("hi " + (++count));
            try {
                Thread.sleep( 1000);//休眠1秒
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (count == 20){
                break;
            }
        }

    }
}</pre> 
<h3>课堂练习</h3> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ff/60/Q7rQodji_o.png"></p> 
<pre>package com.hspedu.method;

/**
 * @author DL5O
 * @version 1.0
 */
public class ThreadMethodExercise {
    public static void main(String[] args) throws InterruptedException {
        T01 t01 = new T01();
        for (int i = 1; i &lt;= 10; i++) {
            System.out.println("hi " + i);
            if (i == 5) {
                Thread thread = new Thread(t01);
                thread.start();
                thread.join();
                System.out.println("子线程结束...");
            }
            Thread.sleep(1000);
        }
        System.out.println("主线程结束...");
    }
}

class T01 implements Runnable{

    @Override
    public void run() {

        for (int i = 1; i &lt;= 10 ; i++) {
            System.out.println("hello " + i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}</pre> 
<h3>八、用户线程和守护线程</h3> 
<ol><li><strong>用户线程：</strong> 也叫 <strong>工作线程</strong> ，当线程的任务执行完或通知方式结束</li><li><strong>守护线程：</strong> 一般是为工作线程服务的， <strong>当所有的用户线程结束，守护线程自动结束</strong></li><li><strong>常见的守护线程：</strong> 垃圾回收机制</li></ol> 
<pre>package com.hspedu.method;

/**
 * @author DL5O
 * @version 1.0
 * 守护线程的设置
 */
public class ThreadMethod03 {
    public static void main(String[] args) throws InterruptedException {
        MyDaemonThread myDaemonThread = new MyDaemonThread();
        Test01 test01 = new Test01();
        myDaemonThread.setDaemon(true);
        //如果我们希望当main线程结束后，子线程可以自动退出
        //只需将子线程设为守护线程即可
        myDaemonThread.start();
        test01.start();

        for (int i = 1; i &lt;= 10; i++) {
            System.out.println("我是主线程 " + i);
            Thread.sleep(1000);
        }

    }
}

class MyDaemonThread extends Thread {
    @Override
    public void run() {
        for (int i = 1; ; i++ ) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("我是MyDaemonThread 守护线程 " + i);
        }
    }
}

class Test01 extends Thread {
    @Override
    public void run() {
        for (int i = 1; i &lt;= 15 ; i++ ) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("我是Test01 用户线程 " + i);
        }
    }
}</pre> 
<p>总结：</p> 
<pre>对象名.setDaemon(true)
</pre> 
<p>九、 线程的生命周期</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3c/3f/yz8uwwkO_o.png"></p> 
<p>线程状态转换图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a1/ad/ESWach43_o.png"></p> 
<h3>九、线程同步机制</h3> 
<p>关键字：Synchronized</p> 
<ol><li>在多线程编程，一些 <strong>敏感数据不允许被多少个线程同时访问</strong> ，此时就使用 <strong>同步访问技术</strong> ， 保证数据在任何同一时刻，最多有一个线程访问，以保证数据的完整性 。</li><li>也可以这里理解：线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作</li></ol> 
<h4>同步具体方法-Synchronized</h4> 
<ol><li> <p>同步代码块</p> <pre>synchronized(对象){//获得对象的锁，才能操作同步代码
    //需要被同步代码;
}</pre> </li><li> <p>synchronized还可以放在方法声明中，表示整个方法-为同步方法</p> <pre>public synchronized void m(String name){
    //需要被同步的代码
}</pre> </li><li> <p>如何理解：</p> 
  <ul><li>就好像某个人要上厕所，上厕所前需要把门关上(上锁)，完事之后再出来(解锁)，那么其他小伙伴就可以在使用厕所了</li></ul></li><li> <p>使用 <code>synchronized</code> 解决售票</p> </li></ol> 
<pre>package com.hspedu.syn;

/**
 * @author DL5O
 * @version 1.0
 * 使用多线程，模拟三个窗口同时售票
 * 总票数 100 张
 */
public class SellTicket {
    public static void main(String[] args) {
        //第一种方式
        //测试
        /*SellTicket01 sellTicket01 = new SellTicket01();
        SellTicket01 sellTicket02 = new SellTicket01();
        SellTicket01 sellTicket03 = new SellTicket01();

        sellTicket01.start();
        sellTicket02.start();
        sellTicket03.start();*/

        /*System.out.println("===使用接口的方式来售票===");
        SellTicket02 sellTicket02 = new SellTicket02();
        Thread thread1 = new Thread(sellTicket02);
        Thread thread2 = new Thread(sellTicket02);
        Thread thread3 = new Thread(sellTicket02);
        thread1.start();//第一个线程-窗口
        thread2.start();//第二个线程-窗口
        thread3.start();//第三个线程-窗口*/

        //测试
        SellTicket03 sellTicket03 = new SellTicket03();
        Thread thread1 = new Thread(sellTicket03);
        Thread thread2 = new Thread(sellTicket03);
        Thread thread3 = new Thread(sellTicket03);
        thread1.start();//第一个线程-窗口
        thread2.start();//第二个线程-窗口
        thread3.start();//第三个线程-窗口
    }
}


//实现接口的方式,使用synchronized 实现线程同步
class SellTicket03 implements Runnable {
    private int ticketNum = 100;
    private boolean loop = true;

    public synchronized void sell() {
        //同步方法，在同一个时刻只能有一个线程来执行我们的run方法
        if (ticketNum &lt;= 0) {
            loop = false;
            System.out.println("票已售空，售票结束..");
            return;
        }

        //休眠50毫秒
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("窗口 " + Thread.currentThread().getName()
                + " 售出一张票," + "剩余票数=" + (--ticketNum));
    }


    @Override
    public void run() {

        while (loop) {
            sell();
        }
    }
}


//使用第一种继承thread的方式
class SellTicket01 extends Thread {
    private static int ticketNum = 100;//让多个线程共享 ticketNum

    @Override
    public void run() {
        while (true) {
            if (ticketNum &lt;= 0) {
                System.out.println("售票结束..");
                break;
            }
            //休眠50毫秒
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("窗口 " + Thread.currentThread().getName()
                    + " 售出一张票" + "剩余票数=" + (--ticketNum));
        }
    }
}

//实现接口的方式
class SellTicket02 implements Runnable {
    private int ticketNum = 100;

    @Override
    public void run() {
        while (true) {
            if (ticketNum &lt;= 0) {
                System.out.println("售票结束..");
                break;
            }
            //休眠50毫秒
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("窗口 " + Thread.currentThread().getName()
                    + " 售出一张票" + "剩余票数=" + (--ticketNum));
        }
    }
}</pre> 
<h3>十、互斥锁</h3> 
<p>基本介绍：</p> 
<ol><li> <p>Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。</p> </li><li> <p>每个对象都对应于一个可称为 <strong>“互斥锁”</strong> 的标记，这个标记用来保证在任一时刻 <strong>，只能有一个线程访问该对象</strong> 。</p> </li><li> <p>关键字 <code>synchronized</code> 来与对象的互斥锁联系。当某个对象用 <strong>synchronized修饰</strong> 时, <strong>表明该对象在任一时刻只能由一个线程访问</strong></p> </li><li> <p>同步的局限性： <strong>导致程序的执行效率要降低</strong></p> </li><li> <p>同步方法（ <strong>非静态的</strong> )的锁可以是this,也可以是其他对象(要求是同一个对象)</p> 
  <ul><li><strong>非静态的这个锁是加在当前对象的</strong></li></ul></li><li> <p>同步方法( <strong>静态的</strong> ）的锁为当前类本身。</p> 
  <ul><li><strong>静态方法的是加载当前类的</strong></li></ul></li></ol> 
<p>注意事项：</p> 
<ol><li><strong>同步方法如果没有使用static修饰：</strong> 默认锁对象是： <strong>this</strong></li><li><strong>如果方法使用了static修饰：</strong> 默认是锁对象是： <strong>当前类.class</strong></li><li>实现的落地步骤： 
  <ul><li>需要先分析上锁的代码</li><li>选择 <strong>同步代码块</strong> 或同步方法</li><li><strong>要求多个线程的锁对象为同一个即可！！！！</strong> 
    <ul><li>即共享的资源上</li><li>线程同步只会发生在共享同一个资源时</li></ul></li></ul></li></ol> 
<pre>package com.hspedu.syn;

/**
 * @author DL5O
 * @version 1.0
 * 使用多线程，模拟三个窗口同时售票
 * 总票数 100 张
 */
public class SellTicket {
    public static void main(String[] args) {
        //第一种方式
        //测试
        /*SellTicket01 sellTicket01 = new SellTicket01();
        SellTicket01 sellTicket02 = new SellTicket01();
        SellTicket01 sellTicket03 = new SellTicket01();

        sellTicket01.start();
        sellTicket02.start();
        sellTicket03.start();*/

        /*System.out.println("===使用接口的方式来售票===");
        SellTicket02 sellTicket02 = new SellTicket02();
        Thread thread1 = new Thread(sellTicket02);
        Thread thread2 = new Thread(sellTicket02);
        Thread thread3 = new Thread(sellTicket02);
        thread1.start();//第一个线程-窗口
        thread2.start();//第二个线程-窗口
        thread3.start();//第三个线程-窗口*/

        //测试
        SellTicket03 sellTicket03 = new SellTicket03();
        Thread thread1 = new Thread(sellTicket03);
        Thread thread2 = new Thread(sellTicket03);
        Thread thread3 = new Thread(sellTicket03);
        thread1.start();//第一个线程-窗口
        thread2.start();//第二个线程-窗口
        thread3.start();//第三个线程-窗口
    }
}


//实现接口的方式,使用synchronized 实现线程同步
class SellTicket03 implements Runnable {
    private int ticketNum = 100;
    private boolean loop = true;
    Object obj =new Object();//都是同一个对象

    //同步方法(静态的) 的锁为当前类
    //1.他的锁是加载我们这个类上的 SellTicket03.Class 上
    //2.如果要在静态方法中实现一个同步代码块.
    //      synchronized (SellTicket03.class)
    public synchronized static void m1(){

    }
    public static void m2(){
        synchronized (SellTicket03.class){
            System.out.println("m2");
        }
    }

    //是在方法上加的锁
    //说明
    //1.public synchronized void sell()就是一个同步方法
    //2.这时锁是在this对象
    //3.也可以在代码块上写 synchronized,同步代码块,互斥锁还是在this对象
    public /*synchronized*/ void sell() {//同步方法，在同一个时刻只能有一个线程来执行我们的run方法
        synchronized (/*this*/obj){
            if (ticketNum &lt;= 0) {
                loop = false;
                System.out.println("票已售空，售票结束..");
                return;
            }

            //休眠50毫秒
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("窗口 " + Thread.currentThread().getName()
                    + " 售出一张票," + "剩余票数=" + (--ticketNum));
        }
    }


    @Override
    public void run() {

        while (loop) {
            sell();
        }
    }
}


//使用第一种继承thread的方式
//new SellTicket01().start()
//new SellTicket01().start() this只对当前的对象有效
class SellTicket01 extends Thread {
    private static int ticketNum = 100;//让多个线程共享 ticketNum

    //锁一般用于共享的只有
    public void m1(){
        synchronized (this){
            System.out.println("hello");
        }
    }

    @Override
    public void run() {
        while (true) {
            if (ticketNum &lt;= 0) {
                System.out.println("售票结束..");
                break;
            }
            //休眠50毫秒
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("窗口 " + Thread.currentThread().getName()
                    + " 售出一张票" + "剩余票数=" + (--ticketNum));
        }
    }
}

//实现接口的方式
class SellTicket02 implements Runnable {
    private int ticketNum = 100;

    @Override
    public void run() {
        while (true) {
            if (ticketNum &lt;= 0) {
                System.out.println("售票结束..");
                break;
            }
            //休眠50毫秒
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("窗口 " + Thread.currentThread().getName()
                    + " 售出一张票" + "剩余票数=" + (--ticketNum));
        }
    }
}</pre> 
<h3>十一、线程的死锁</h3> 
<p>基本介绍：</p> 
<p>多个线程都占用了对方的锁资源，但不肯相让，导致了死锁，在编程时一定要避免死锁的发生</p> 
<pre>package com.hspedu.syn;

/**
 * @author DL5O
 * @version 1.0
 * 模拟线程死锁
 */

public class DeadLock {
    public static void main(String[] args) {
        DeadLockDemo A = new DeadLockDemo(true);
        A.setName("A线程");
        DeadLockDemo B = new DeadLockDemo(false);
        B.setName("B线程");
        A.start();
        B.start();
    }
}

//线程
class DeadLockDemo extends Thread{
    static Object o1 = new Object();
    static Object o2 = new Object();
    boolean flag;

    public DeadLockDemo(boolean flag){
        this.flag = flag;
    }

    @Override
    public void run() {
        //1.如果flag为T，线程就会先得到/持有 o1的对象锁，然后会尝试去得到o2的对先生
        //  当持有到 o2的对象锁时，才会继续往下执行
        //2.如果线程A 得不到o2的对象锁，就会Blocked
        //3.如果flag 为 false，线程会去得到o2的对象锁，
        //4.如果线程B 拿不到o1的对象锁，就会block
        if(flag){
            synchronized(o1){//对象互斥锁
                System.out.println(Thread.currentThread().getName()+"进入1");
                //拿到o1的锁之后会阻塞在这里，直到拿到o2的锁，
                // 此时第二个线程thread2进入，拿到o2的锁，进入堵塞状态，因为一直拿不到o1的锁，
                // o1又因为拿不到o2锁，释放不了，故成为了死锁
                synchronized (o2){
                    System.out.println(Thread.currentThread().getName()+"进行2");
                }
            }
        }else{
            synchronized (o2){

                //第二个线程 o1的锁已经被拿了，
                //这时，又想去拿o1的锁，但是o1在第36行阻塞到了，没有拿到o2的锁，没有释放，故这里也会被阻塞
                //那么这时就会产生一种死锁的情况，要避免
                System.out.println(Thread.currentThread().getName()+"进入3");
                synchronized (o1){
                    System.out.println(Thread.currentThread().getName()+"进行4");
                }
            }
        }
    }
}</pre> 
<h3>十二、释放锁</h3> 
<p>下面操作会释放锁</p> 
<ol><li>当线程的同步方法、同步代码块 <strong>执行结束</strong></li><li>当前线程在同步代码块、同步方法中遇到 <strong>break、return</strong></li><li>当前线程在同步代码块、同步方法中出现了 <strong>未处理的error</strong> 或 <strong>Exception</strong> ，导致 <strong>异常结束</strong></li><li>当前线程在同步代码块、同步方法中执行了线程对象的 <strong>wait()</strong> 方法， <strong>当前线程暂停</strong> ，也会释放锁</li></ol> 
<p>下面操作不会释放锁</p> 
<ol><li> <p>线程执行同步代码块或同步方法时，程序调用 <code>Thread.sleep()</code> 、 <code>Thread.yield()</code> 暂停当前线程的执行，不会释放锁</p> </li><li> <p>线程执行同步代码块时，其他线程调用了该线程的 <code>suspend()</code> 方法将会被挂起，该现场不会释放锁</p> <p>提示：应尽量避免使用 <code>suspend()</code> 和 <code>resume()</code> 来控制线程，方法不再推荐使用了</p> </li></ol> 
<h4>作业</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/71/cc/DyZlpvWV_o.png"></p> 
<pre>package com.hspedu.homework;

import java.util.Random;
import java.util.Scanner;

/**
 * @author DL5O
 * @version 1.0
 */
public class Homework01 {
    public static void main(String[] args) {
        A a = new A();
        B b = new B(a);
        a.setName("A");
        b.setName("B");
//        a.setDaemon(true);
        a.start();
        b.start();

    }
}

class A extends Thread {
    private int num;
    static boolean loop = true;
    private Random random;

    public A() {
        random = new Random();
    }

    public void showNum() {
        //nextInt(int bound)
        //返回伪随机的，均匀分布 int值介于0（含）和指定值（不包括），从该随机数生成器的序列绘制。
        num = random.nextInt(101);//生成0~100的随机数
        //num = (int)Math.random()*(100-0+1)+0;
        System.out.println("随机数：" + num);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }


    @Override
    public void run() {
        while (loop){
            showNum();
        }
    }
}

//用来控制A线程退出的线程B
class B extends Thread {
    private String str;
    private A a;
    Scanner scanner;

    public B(A a) {
        this.a = a;
        scanner = new Scanner(System.in);
    }

    @Override
    public void run() {
        synchronized (B.class) {
            while (true) {
                str = scanner.next();
                if (str.equals("Q")) {
                    a.loop = false;
                    break;
                }
            }
        }
    }
}</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/dc/37/GQVtcn9t_o.png"></p> 
<pre>package com.hspedu.homework;

/**
 * @author DL5O
 * @version 1.0
 */
public class Homework02 {
    public static void main(String[] args) {
        Withdraw withdraw = new Withdraw();
        Thread A = new Thread(withdraw);
        Thread B = new Thread(withdraw);
        A.setName("A");
        B.setName("B");
        A.start();
        B.start();
    }
}

class Withdraw  implements Runnable {
    private int money = 10000;
    private boolean loop = true;

    public void deal() {

        //1.这里使用了synchronized 实现了线程同步
        //2.当多个线程执行到这里的时候，就回去争夺 this对象锁
        //3.那个线程执行到 this对象锁，就执行这个代码块，执行玩后，会释放这个锁，准备继续争夺
        //4.争夺不到就阻塞到这里，就blocked
        //5.this 是一个非公平锁

        synchronized (/*Withdraw.class*/this){
            if (money &lt;= 0) {
                loop = false;
                System.out.println("余额不足");
                return;
            }
            money -= 1000;
            System.out.println(Thread.currentThread().getName() + "取走了1000，剩余" + money);
        }
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void run() {
        while (loop) {
            deal();
        }
    }
}</pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/91fdcde11f5c3e7454f146c6c65a1acb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【定量分析、量化金融与统计学】统计推断基础（5）---一类错误与二类错误</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac5d3c5acb1be9a14e70e20d23eeca5c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">BP神经网络的学习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>