<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java基础加强 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java基础加强" />
<meta property="og:description" content="1.类加载器 1.1类加载器【理解】 作用
负责将.class文件（存储的物理文件）加载在到内存中
1.2类加载的过程【理解】 类加载时机
创建类的实例（对象）
调用类的类方法
访问类或者接口的类变量，或者为该类变量赋值
使用反射方式来强制创建某个类或接口对应的java.lang.Class对象
初始化某个类的子类
直接使用java.exe命令来运行某个主类
类加载过程
加载
通过包名 &#43; 类名，获取这个类，准备用流进行传输
在这个类加载到内存中
加载完毕创建一个class对象
链接
验证
确保Class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全
(文件中的信息是否符合虚拟机规范有没有安全隐患)
准备
负责为类的类变量（被static修饰的变量）分配内存，并设置默认初始化值
(初始化静态变量)
解析
将类的二进制数据流中的符号引用替换为直接引用
(本类中如果用到了其他类，此时就需要找到对应的类)
初始化
根据程序员通过程序制定的主观计划去初始化类变量和其他资源
(静态变量赋值以及初始化其他资源)
小结
当一个类被使用的时候，才会加载到内存
类加载的过程: 加载、验证、准备、解析、初始化
1.3类加载的分类【理解】 分类
Bootstrap class loader：虚拟机的内置类加载器，通常表示为null ，并且没有父null
Platform class loader：平台类加载器,负责加载JDK中一些特殊的模块
System class loader：系统类加载器,负责加载用户类路径上所指定的类库
类加载器的继承关系
System的父加载器为Platform
Platform的父加载器为Bootstrap
代码演示
public class ClassLoaderDemo1 { public static void main(String[] args) { //获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); ​ //获取系统类加载器的父加载器 --- 平台类加载器 ClassLoader classLoader1 = systemClassLoader." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/f730c9684f05a309fa6bb504f638cd7d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-15T16:22:44+08:00" />
<meta property="article:modified_time" content="2022-10-15T16:22:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java基础加强</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1.类加载器</h3> 
<h4>1.1类加载器【理解】</h4> 
<ul><li> <p>作用</p> <p>负责将.class文件（存储的物理文件）加载在到内存中</p> <p><img alt="" height="369" src="https://images2.imgbox.com/d1/ee/SkzwPt5x_o.png" width="969"></p> </li></ul> 
<h4>1.2类加载的过程【理解】</h4> 
<ul><li> <p>类加载时机</p> 
  <ul><li> <p>创建类的实例（对象）</p> </li><li> <p>调用类的类方法</p> </li><li> <p>访问类或者接口的类变量，或者为该类变量赋值</p> </li><li> <p>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</p> </li><li> <p>初始化某个类的子类</p> </li><li> <p>直接使用java.exe命令来运行某个主类</p> </li></ul></li><li> <p>类加载过程</p> 
  <ol><li> <p>加载</p> 
    <ul><li> <p>通过包名 + 类名，获取这个类，准备用流进行传输</p> </li><li> <p>在这个类加载到内存中</p> </li><li> <p>加载完毕创建一个class对象</p> </li></ul><p><img alt="" height="314" src="https://images2.imgbox.com/1b/ed/D33tXYV5_o.png" width="921"></p> </li><li> <p>链接</p> 
    <ul><li> <p>验证</p> <p>确保Class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全</p> <p>(文件中的信息是否符合虚拟机规范有没有安全隐患)</p> </li></ul><p><img alt="" height="262" src="https://images2.imgbox.com/d9/8c/nYOy89LA_o.png" width="974"></p> 
    <ul><li> <p>准备</p> <p>负责为类的类变量（被static修饰的变量）分配内存，并设置默认初始化值</p> <p>(初始化静态变量)</p> </li></ul><p><img alt="" height="325" src="https://images2.imgbox.com/fa/42/6g7d8uHZ_o.png" width="961"></p> 
    <ul><li> <p>解析</p> <p>将类的二进制数据流中的符号引用替换为直接引用</p> <p>(本类中如果用到了其他类，此时就需要找到对应的类)</p> </li></ul><p><img alt="" height="263" src="https://images2.imgbox.com/4f/10/kokPH8Gu_o.png" width="932"></p> </li><li> <p>初始化</p> <p>根据程序员通过程序制定的主观计划去初始化类变量和其他资源</p> <p>(静态变量赋值以及初始化其他资源)</p> <p><img alt="" height="269" src="https://images2.imgbox.com/5d/20/KB4dWMMM_o.png" width="927"></p> </li></ol></li><li> <p>小结</p> 
  <ul><li> <p>当一个类被使用的时候，才会加载到内存</p> </li><li> <p>类加载的过程: 加载、验证、准备、解析、初始化</p> </li></ul></li></ul> 
<h4>1.3类加载的分类【理解】</h4> 
<ul><li> <p>分类</p> 
  <ul><li> <p>Bootstrap class loader：虚拟机的内置类加载器，通常表示为null ，并且没有父null</p> </li><li> <p>Platform class loader：平台类加载器,负责加载JDK中一些特殊的模块</p> </li><li> <p>System class loader：系统类加载器,负责加载用户类路径上所指定的类库</p> </li></ul></li><li> <p>类加载器的继承关系</p> 
  <ul><li> <p>System的父加载器为Platform</p> </li><li> <p>Platform的父加载器为Bootstrap</p> </li></ul></li><li> <p>代码演示</p> <pre><code class="language-java">public class ClassLoaderDemo1 {
    public static void main(String[] args) {
        //获取系统类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
​
        //获取系统类加载器的父加载器 --- 平台类加载器
        ClassLoader classLoader1 = systemClassLoader.getParent();
​
        //获取平台类加载器的父加载器 --- 启动类加载器
        ClassLoader classLoader2 = classLoader1.getParent();
​
        System.out.println("系统类加载器" + systemClassLoader);
        System.out.println("平台类加载器" + classLoader1);
        System.out.println("启动类加载器" + classLoader2);
​
    }
}</code></pre> <p></p> </li></ul> 
<h4>1.4双亲委派模型【理解】</h4> 
<ul><li> <p>介绍</p> <p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式</p> <p><img alt="" height="581" src="https://images2.imgbox.com/71/46/OBisAeuf_o.png" width="887"></p> </li></ul> 
<h4>1.5ClassLoader 中的两个方法【应用】</h4> 
<ul><li> <p>方法介绍</p> 
  <table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static ClassLoader getSystemClassLoader()</td><td>获取系统类加载器</td></tr><tr><td>public InputStream getResourceAsStream(String name)</td><td>加载某一个资源文件</td></tr></tbody></table></li><li> <p>示例代码</p> <pre><code class="language-java">public class ClassLoaderDemo2 {
    public static void main(String[] args) throws IOException {
        //static ClassLoader getSystemClassLoader() 获取系统类加载器
        //InputStream getResourceAsStream(String name)  加载某一个资源文件
​
        //获取系统类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
​
        //利用加载器去加载一个指定的文件
        //参数：文件的路径（放在src的根目录下，默认去那里加载）
        //返回值：字节流。
        InputStream is = systemClassLoader.getResourceAsStream("prop.properties");
​
        Properties prop = new Properties();
        prop.load(is);
​
        System.out.println(prop);
​
        is.close();
    }
}</code></pre> <p></p> </li></ul> 
<h3>2.反射</h3> 
<h4>2.1反射的概述【理解】</h4> 
<ul><li> <p>反射机制</p> <p>是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意属性和方法； 这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。</p> </li></ul> 
<h4>2.2获取Class类对象的三种方式【应用】</h4> 
<ul><li> <p>三种方式分类</p> 
  <ul><li> <p>类名.class属性</p> </li><li> <p>对象名.getClass()方法</p> </li><li> <p>Class.forName(全类名)方法</p> <p></p> </li></ul><p><img alt="" height="425" src="https://images2.imgbox.com/da/8a/6qi4kY7k_o.png" width="995"></p> </li><li> <p>示例代码</p> <pre><code class="language-java">public class Student {
    private String name;
    private int age;
​
    public Student() {
    }
​
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
​
    public String getName() {
        return name;
    }
​
    public void setName(String name) {
        this.name = name;
    }
​
    public int getAge() {
        return age;
    }
​
    public void setAge(int age) {
        this.age = age;
    }
​
    public void study(){
        System.out.println("学生在学习");
    }
​
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
public class ReflectDemo1 {
    public static void main(String[] args) throws ClassNotFoundException {
        //1.Class类中的静态方法forName("全类名")
            //全类名:包名 + 类名
        Class clazz = Class.forName("com.itheima.myreflect2.Student");
        System.out.println(clazz);
​
        //2.通过class属性来获取
        Class clazz2 = Student.class;
        System.out.println(clazz2);
​
        //3.利用对象的getClass方法来获取class对象
        //getClass方法是定义在Object类中.
        Student s = new Student();
        Class clazz3 = s.getClass();
        System.out.println(clazz3);
​
        System.out.println(clazz == clazz2);
        System.out.println(clazz2 == clazz3);
    }
}</code></pre> <p></p> </li></ul> 
<h4>2.3反射获取构造方法并使用【应用】</h4> 
<p>2.3.1Class类获取构造方法对象的方法</p> 
<ul><li> <p>方法介绍</p> 
  <table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Constructor&lt;?&gt;[] getConstructors()</td><td>返回所有公共构造方法对象的数组</td></tr><tr><td>Constructor&lt;?&gt;[] getDeclaredConstructors()</td><td>返回所有构造方法对象的数组</td></tr><tr><td>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</td><td>返回单个公共构造方法对象</td></tr><tr><td>Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</td><td>返回单个构造方法对象</td></tr></tbody></table></li><li> <p>示例代码</p> <pre><code class="language-java">public class Student {
    private String name;
    private int age;
​
    //私有的有参构造方法
    private Student(String name) {
        System.out.println("name的值为:" + name);
        System.out.println("private...Student...有参构造方法");
    }
​
    //公共的无参构造方法
    public Student() {
        System.out.println("public...Student...无参构造方法");
    }
​
    //公共的有参构造方法
    public Student(String name, int age) {
        System.out.println("name的值为:" + name + "age的值为:" + age);
        System.out.println("public...Student...有参构造方法");
    }
}
public class ReflectDemo1 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {
        //method1();
        //method2();
        //method3();
        //method4();
    }
​
    private static void method4() throws ClassNotFoundException, NoSuchMethodException {
        //        Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)：
//                                      返回单个构造方法对象
        //1.获取Class对象
        Class clazz = Class.forName("com.itheima.myreflect3.Student");
        Constructor constructor = clazz.getDeclaredConstructor(String.class);
        System.out.println(constructor);
    }
​
    private static void method3() throws ClassNotFoundException, NoSuchMethodException {
        //        Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)：
//                                      返回单个公共构造方法对象
        //1.获取Class对象
        Class clazz = Class.forName("com.itheima.myreflect3.Student");
        //小括号中,一定要跟构造方法的形参保持一致.
        Constructor constructor1 = clazz.getConstructor();
        System.out.println(constructor1);
​
        Constructor constructor2 = clazz.getConstructor(String.class, int.class);
        System.out.println(constructor2);
​
        //因为Student类中,没有只有一个int的构造,所以这里会报错.
        Constructor constructor3 = clazz.getConstructor(int.class);
        System.out.println(constructor3);
    }
​
    private static void method2() throws ClassNotFoundException {
        //        Constructor&lt;?&gt;[] getDeclaredConstructors()：
//                                      返回所有构造方法对象的数组
        //1.获取Class对象
        Class clazz = Class.forName("com.itheima.myreflect3.Student");
​
        Constructor[] constructors = clazz.getDeclaredConstructors();
        for (Constructor constructor : constructors) {
            System.out.println(constructor);
        }
    }
​
    private static void method1() throws ClassNotFoundException {
        //        Constructor&lt;?&gt;[] getConstructors()：
//                                      返回所有公共构造方法对象的数组
        //1.获取Class对象
        Class clazz = Class.forName("com.itheima.myreflect3.Student");
        Constructor[] constructors = clazz.getConstructors();
        for (Constructor constructor : constructors) {
            System.out.println(constructor);
        }
    }
}</code></pre> </li></ul> 
<p>2.3.2Constructor类用于创建对象的方法</p> 
<ul><li> <p>方法介绍</p> 
  <table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>T newInstance(Object...initargs)</td><td>根据指定的构造方法创建对象</td></tr><tr><td>setAccessible(boolean flag)</td><td>设置为true,表示取消访问检查</td></tr></tbody></table></li><li> <p>示例代码</p> <pre><code class="language-java">// Student类同上一个示例,这里就不在重复提供了
public class ReflectDemo2 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        //T newInstance(Object... initargs)：根据指定的构造方法创建对象
        //method1();
        //method2();
        //method3();
        //method4();
​
    }
​
    private static void method4() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        //获取一个私有的构造方法并创建对象
        //1.获取class对象
        Class clazz = Class.forName("com.itheima.myreflect3.Student");
​
        //2.获取一个私有化的构造方法.
        Constructor constructor = clazz.getDeclaredConstructor(String.class);
​
        //被private修饰的成员,不能直接使用的
        //如果用反射强行获取并使用,需要临时取消访问检查
        constructor.setAccessible(true);
​
        //3.直接创建对象
        Student student = (Student) constructor.newInstance("zhangsan");
​
        System.out.println(student);
    }
​
    private static void method3() throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        //简写格式
        //1.获取class对象
        Class clazz = Class.forName("com.itheima.myreflect3.Student");
​
        //2.在Class类中,有一个newInstance方法,可以利用空参直接创建一个对象
        Student student = (Student) clazz.newInstance();//这个方法现在已经过时了,了解一下
​
        System.out.println(student);
    }
​
    private static void method2() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        //1.获取class对象
        Class clazz = Class.forName("com.itheima.myreflect3.Student");
​
        //2.获取构造方法对象
        Constructor constructor = clazz.getConstructor();
​
        //3.利用空参来创建Student的对象
        Student student = (Student) constructor.newInstance();
​
        System.out.println(student);
    }
​
    private static void method1() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        //1.获取class对象
        Class clazz = Class.forName("com.itheima.myreflect3.Student");
​
        //2.获取构造方法对象
        Constructor constructor = clazz.getConstructor(String.class, int.class);
​
        //3.利用newInstance创建Student的对象
        Student student = (Student) constructor.newInstance("zhangsan", 23);
​
        System.out.println(student);
    }
}</code></pre> </li></ul> 
<p>2.3.3小结</p> 
<ul><li> <p>获取class对象</p> <p>三种方式: Class.forName(“全类名”), 类名.class, 对象名.getClass()</p> </li><li> <p>获取里面的构造方法对象</p> <p>getConstructor (Class&lt;?&gt;... parameterTypes) getDeclaredConstructor (Class&lt;?&gt;... parameterTypes)</p> </li><li> <p>如果是public的，直接创建对象</p> <p>newInstance(Object... initargs)</p> </li><li> <p>如果是非public的，需要临时取消检查，然后再创建对象</p> <p>setAccessible(boolean) 暴力反射</p> </li></ul> 
<h4>2.4反射获取成员变量并使用【应用】</h4> 
<p>2.4.1Class类获取成员变量对象的方法</p> 
<ul><li> <p>方法分类</p> 
  <table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Field[] getFields()</td><td>返回所有公共成员变量对象的数组</td></tr><tr><td>Field[] getDeclaredFields()</td><td>返回所有成员变量对象的数组</td></tr><tr><td>Field getField(String name)</td><td>返回单个公共成员变量对象</td></tr><tr><td>Field getDeclaredField(String name)</td><td>返回单个成员变量对象</td></tr></tbody></table></li><li> <p>示例代码</p> <pre><code class="language-java">public class Student {
​
    public String name;
​
    public int age;
​
    public String gender;
​
    private int money = 300;
​
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", gender='" + gender + '\'' +
                ", money=" + money +
                '}';
    }
}
public class ReflectDemo1 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {
       // method1();
        //method2();
        //method3();
        //method4();
​
    }
​
    private static void method4() throws ClassNotFoundException, NoSuchFieldException {
        //        Field getDeclaredField(String name)：返回单个成员变量对象
        //1.获取class对象
        Class clazz = Class.forName("com.itheima.myreflect4.Student");
  
        //2.获取money成员变量
        Field field = clazz.getDeclaredField("money");
  
        //3.打印一下
        System.out.println(field);
    }
  
    private static void method3() throws ClassNotFoundException, NoSuchFieldException {
        //        Field getField(String name)：返回单个公共成员变量对象
        //想要获取的成员变量必须是真实存在的
        //且必须是public修饰的.
        //1.获取class对象
        Class clazz = Class.forName("com.itheima.myreflect4.Student");
  
        //2.获取name这个成员变量
        //Field field = clazz.getField("name");
        //Field field = clazz.getField("name1");
        Field field = clazz.getField("money");
  
        //3.打印一下
        System.out.println(field);
    }
  
    private static void method2() throws ClassNotFoundException {
        //        Field[] getDeclaredFields()：返回所有成员变量对象的数组
        //1.获取class对象
        Class clazz = Class.forName("com.itheima.myreflect4.Student");
  
        //2.获取所有的Field对象
        Field[] fields = clazz.getDeclaredFields();
  
        //3.遍历
        for (Field field : fields) {
            System.out.println(field);
        }
    }
  
    private static void method1() throws ClassNotFoundException {
        //        Field[] getFields()：返回所有公共成员变量对象的数组
  
        //1.获取class对象
        Class clazz = Class.forName("com.itheima.myreflect4.Student");
  
        //2.获取Field对象.
        Field[] fields = clazz.getFields();
  
        //3.遍历
        for (Field field : fields) {
            System.out.println(field);
        }
    }
}</code></pre> </li></ul> 
<p>2.4.2Field类用于给成员变量赋值的方法</p> 
<ul><li> <p>方法介绍</p> 
  <table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void set(Object obj, Object value)</td><td>赋值</td></tr><tr><td>Object get(Object obj)</td><td>获取值</td></tr></tbody></table></li><li> <p>示例代码</p> <pre><code class="language-java">// Student类同上一个示例,这里就不在重复提供了
public class ReflectDemo2 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException {
//        Object get(Object obj) 返回由该 Field表示的字段在指定对象上的值。
        //method1();
        //method2();
​
    }
​
    private static void method2() throws ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException {
        //1.获取class对象
        Class clazz = Class.forName("com.itheima.myreflect4.Student");
​
        //2.获取成员变量Field的对象
        Field field = clazz.getDeclaredField("money");
​
        //3.取消一下访问检查
        field.setAccessible(true);
​
        //4.调用get方法来获取值
        //4.1创建一个对象
        Student student = (Student) clazz.newInstance();
        //4.2获取指定对象的money的值
        Object o = field.get(student);
​
        //5.打印一下
        System.out.println(o);
    }
​
    private static void method1() throws ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException {
        //        void set(Object obj, Object value)：给obj对象的成员变量赋值为value
        //1.获取class对象
        Class clazz = Class.forName("com.itheima.myreflect4.Student");
​
        //2.获取name这个Field对象
        Field field = clazz.getField("name");
​
        //3.利用set方法进行赋值.
        //3.1先创建一个Student对象
        Student student = (Student) clazz.newInstance();
        //3.2有了对象才可以给指定对象进行赋值
        field.set(student,"zhangsan");
​
        System.out.println(student);
    }
}</code></pre> <p></p> </li></ul> 
<h4>2.5反射获取成员方法并使用【应用】</h4> 
<p>2.5.1Class类获取成员方法对象的方法</p> 
<ul><li> <p>方法分类</p> 
  <table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Method[] getMethods()</td><td>返回所有公共成员方法对象的数组，包括继承的</td></tr><tr><td>Method[] getDeclaredMethods()</td><td>返回所有成员方法对象的数组，不包括继承的</td></tr><tr><td>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</td><td>返回单个公共成员方法对象</td></tr><tr><td>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</td><td>返回单个成员方法对象</td></tr></tbody></table></li><li> <p>示例代码</p> <pre><code class="language-java">public class Student {
​
    //私有的，无参无返回值
    private void show() {
        System.out.println("私有的show方法，无参无返回值");
    }
​
    //公共的，无参无返回值
    public void function1() {
        System.out.println("function1方法，无参无返回值");
    }
​
    //公共的，有参无返回值
    public void function2(String name) {
        System.out.println("function2方法，有参无返回值,参数为" + name);
    }
​
    //公共的，无参有返回值
    public String function3() {
        System.out.println("function3方法，无参有返回值");
        return "aaa";
    }
​
    //公共的，有参有返回值
    public String function4(String name) {
        System.out.println("function4方法，有参有返回值,参数为" + name);
        return "aaa";
    }
}
public class ReflectDemo1 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {
        //method1();
        //method2();
        //method3();
        //method4();
        //method5();
    }
​
    private static void method5() throws ClassNotFoundException, NoSuchMethodException {
        //        Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)：
//                                返回单个成员方法对象
        //1.获取class对象
        Class clazz = Class.forName("com.itheima.myreflect5.Student");
        //2.获取一个成员方法show
        Method method = clazz.getDeclaredMethod("show");
        //3.打印一下
        System.out.println(method);
    }
  
    private static void method4() throws ClassNotFoundException, NoSuchMethodException {
        //1.获取class对象
        Class clazz = Class.forName("com.itheima.myreflect5.Student");
        //2.获取一个有形参的方法function2
        Method method = clazz.getMethod("function2", String.class);
        //3.打印一下
        System.out.println(method);
    }
  
    private static void method3() throws ClassNotFoundException, NoSuchMethodException {
        //        Method getMethod(String name, Class&lt;?&gt;... parameterTypes) ：
//                                返回单个公共成员方法对象
        //1.获取class对象
        Class clazz = Class.forName("com.itheima.myreflect5.Student");
        //2.获取成员方法function1
        Method method1 = clazz.getMethod("function1");
        //3.打印一下
        System.out.println(method1);
    }
  
    private static void method2() throws ClassNotFoundException {
        //        Method[] getDeclaredMethods()：
//                                返回所有成员方法对象的数组，不包括继承的
        //1.获取class对象
        Class clazz = Class.forName("com.itheima.myreflect5.Student");
  
        //2.获取Method对象
        Method[] methods = clazz.getDeclaredMethods();
        //3.遍历一下数组
        for (Method method : methods) {
            System.out.println(method);
        }
    }
  
    private static void method1() throws ClassNotFoundException {
        //        Method[] getMethods()：返回所有公共成员方法对象的数组，包括继承的
        //1.获取class对象
        Class clazz = Class.forName("com.itheima.myreflect5.Student");
        //2.获取成员方法对象
        Method[] methods = clazz.getMethods();
        //3.遍历
        for (Method method : methods) {
            System.out.println(method);
        }
    }
}</code></pre> <p></p> </li></ul> 
<p>2.5.2Method类用于执行方法的方法</p> 
<ul><li> <p>方法介绍</p> 
  <table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Object invoke(Object obj, Object... args)</td><td>运行方法</td></tr></tbody></table><p>参数一: 用obj对象调用该方法</p> <p>参数二: 调用方法的传递的参数(如果没有就不写)</p> <p>返回值: 方法的返回值(如果没有就不写)</p> </li><li> <p>示例代码</p> <pre><code class="language-java">public class ReflectDemo2 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException {
//        Object invoke(Object obj, Object... args)：运行方法
//        参数一：用obj对象调用该方法
//        参数二：调用方法的传递的参数（如果没有就不写）
//        返回值：方法的返回值（如果没有就不写）

        //1.获取class对象
        Class clazz = Class.forName("com.itheima.myreflect5.Student");
        //2.获取里面的Method对象  function4
        Method method = clazz.getMethod("function4", String.class);
        //3.运行function4方法就可以了
        //3.1创建一个Student对象,当做方法的调用者
        Student student = (Student) clazz.newInstance();
        //3.2运行方法
        Object result = method.invoke(student, "zhangsan");
        //4.打印一下返回值
        System.out.println(result);
    }
}</code></pre> <p></p> </li></ul> 
<p> </p> 
<h3>1.xml</h3> 
<h4>1.1概述【理解】</h4> 
<ul><li> <p>万维网联盟(W3C)</p> <p>万维网联盟(W3C)创建于1994年，又称W3C理事会。1994年10月在麻省理工学院计算机科学实验室成立。 建立者： Tim Berners-Lee (蒂姆·伯纳斯·李)。 是Web技术领域最具权威和影响力的国际中立性技术标准机构。 到目前为止，W3C已发布了200多项影响深远的Web技术标准及实施指南，</p> 
  <ul><li> <p>如广为业界采用的超文本标记语言HTML（标准通用标记语言下的一个应用）、</p> </li><li> <p>可扩展标记语言XML（标准通用标记语言下的一个子集）</p> </li><li> <p>以及帮助残障人士有效获得Web信息的无障碍指南（WCAG）等</p> </li></ul></li><li> <p>xml概述</p> <p>XML的全称为(EXtensible Markup Language)，是一种可扩展的标记语言 标记语言: 通过标签来描述数据的一门语言(标签有时我们也将其称之为元素) 可扩展：标签的名字是可以自定义的,XML文件是由很多标签组成的,而标签名是可以自定义的</p> </li><li> <p>作用</p> 
  <ul><li> <p>用于进行存储数据和传输数据</p> </li><li> <p>作为软件的配置文件</p> </li></ul></li><li> <p>作为配置文件的优势</p> 
  <ul><li> <p>可读性好</p> </li><li> <p>可维护性高</p> </li></ul></li></ul> 
<h4>1.2标签的规则【应用】</h4> 
<ul><li> <p>标签由一对尖括号和合法标识符组成</p> <pre>&lt;student&gt;</pre> </li><li> <p>标签必须成对出现</p> <pre>&lt;student&gt; &lt;/student&gt;
前边的是开始标签，后边的是结束标签</pre> </li><li> <p>特殊的标签可以不成对,但是必须有结束标记</p> <pre>&lt;address/&gt;</pre> </li><li> <p>标签中可以定义属性,属性和标签名空格隔开,属性值必须用引号引起来</p> <pre>&lt;student id="1"&gt; &lt;/student&gt;</pre> </li><li> <p>标签需要正确的嵌套</p> <pre>这是正确的: &lt;student id="1"&gt; &lt;name&gt;张三&lt;/name&gt; &lt;/student&gt;
这是错误的: &lt;student id="1"&gt;&lt;name&gt;张三&lt;/student&gt;&lt;/name&gt;</pre> </li></ul> 
<h4>1.3语法规则【应用】</h4> 
<ul><li> <p>语法规则</p> 
  <ul><li> <p>XML文件的后缀名为：xml</p> </li><li> <p>文档声明必须是第一行第一列</p> <p>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes”?&gt; version：该属性是必须存在的 encoding：该属性不是必须的</p> <p>打开当前xml文件的时候应该是使用什么字符编码表(一般取值都是UTF-8)</p> <p>standalone: 该属性不是必须的，描述XML文件是否依赖其他的xml文件，取值为yes/no</p> </li><li> <p>必须存在一个根标签，有且只能有一个</p> </li><li> <p>XML文件中可以定义注释信息</p> </li><li> <p>XML文件中可以存在以下特殊字符</p> <pre>&amp;lt; &lt; 小于
&amp;gt; &gt; 大于
&amp;amp; &amp; 和号
&amp;apos; ' 单引号
&amp;quot; " 引号</pre> </li><li> <p>XML文件中可以存在CDATA区</p> <p>&lt;![CDATA[ …内容… ]]&gt;</p> </li></ul></li><li> <p>示例代码</p> <pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!--注释的内容--&gt;
&lt;!--本xml文件用来描述多个学生信息--&gt;
&lt;students&gt;
​
    &lt;!--第一个学生信息--&gt;
    &lt;student id="1"&gt;
        &lt;name&gt;张三&lt;/name&gt;
        &lt;age&gt;23&lt;/age&gt;
        &lt;info&gt;学生&amp;lt; &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;的信息&lt;/info&gt;
        &lt;message&gt; &lt;![CDATA[内容 &lt;&lt;&lt;&lt;&lt;&lt; &gt;&gt;&gt;&gt;&gt;&gt; ]]]&gt;&lt;/message&gt;
    &lt;/student&gt;
​
    &lt;!--第二个学生信息--&gt;
    &lt;student id="2"&gt;
        &lt;name&gt;李四&lt;/name&gt;
        &lt;age&gt;24&lt;/age&gt;
    &lt;/student&gt;
​
&lt;/students&gt;</code></pre> <p></p> </li></ul> 
<h4>1.4xml解析【应用】</h4> 
<ul><li> <p>概述</p> <p>xml解析就是从xml中获取到数据</p> </li><li> <p>常见的解析思想</p> <p>DOM(Document Object Model)文档对象模型:就是把文档的各个组成部分看做成对应的对象。 会把xml文件全部加载到内存,在内存中形成一个树形结构,再获取对应的值</p> <p><img alt="" height="548" src="https://images2.imgbox.com/1b/e4/RhW27xWl_o.png" width="977"></p> </li><li> <p>常见的解析工具</p> 
  <ul><li> <p>JAXP: SUN公司提供的一套XML的解析的API</p> </li><li> <p>JDOM: 开源组织提供了一套XML的解析的API-jdom</p> </li><li> <p>DOM4J: 开源组织提供了一套XML的解析的API-dom4j,全称：Dom For Java</p> </li><li> <p>pull: 主要应用在Android手机端解析XML</p> </li></ul></li><li> <p>解析的准备工作</p> 
  <ol><li> <p>我们可以通过网站：<a href="https://dom4j.github.io/" rel="nofollow" title="dom4j">dom4j</a> 去下载dom4j</p> <p>今天的资料中已经提供,我们不用再单独下载了,直接使用即可</p> </li><li> <p>将提供好的dom4j-1.6.1.zip解压,找到里面的dom4j-1.6.1.jar</p> </li><li> <p>在idea中当前模块下新建一个libs文件夹,将jar包复制到文件夹中</p> </li><li> <p>选中jar包 -&gt; 右键 -&gt; 选择add as library即可</p> </li></ol></li><li> <p>需求</p> 
  <ul><li> <p>解析提供好的xml文件</p> </li><li> <p>将解析到的数据封装到学生对象中</p> </li><li> <p>并将学生对象存储到ArrayList集合中</p> </li><li> <p>遍历集合</p> </li></ul></li><li> <p>代码实现</p> <pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!--注释的内容--&gt;
&lt;!--本xml文件用来描述多个学生信息--&gt;
&lt;students&gt;
​
    &lt;!--第一个学生信息--&gt;
    &lt;student id="1"&gt;
        &lt;name&gt;张三&lt;/name&gt;
        &lt;age&gt;23&lt;/age&gt;
    &lt;/student&gt;
​
    &lt;!--第二个学生信息--&gt;
    &lt;student id="2"&gt;
        &lt;name&gt;李四&lt;/name&gt;
        &lt;age&gt;24&lt;/age&gt;
    &lt;/student&gt;
​
&lt;/students&gt;
​</code></pre> <pre><code class="language-java">// 上边是已经准备好的student.xml文件
public class Student {
    private String id;
    private String name;
    private int age;
​
    public Student() {
    }
​
    public Student(String id, String name, int age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }
​
    public String getId() {
        return id;
    }
​
    public void setId(String id) {
        this.id = id;
    }
​
    public String getName() {
        return name;
    }
​
    public void setName(String name) {
        this.name = name;
    }
​
    public int getAge() {
        return age;
    }
​
    public void setAge(int age) {
        this.age = age;
    }
​
    @Override
    public String toString() {
        return "Student{" +
                "id='" + id + '\'' +
                ", name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
​
/**
 * 利用dom4j解析xml文件
 */
public class XmlParse {
    public static void main(String[] args) throws DocumentException {
        //1.获取一个解析器对象
        SAXReader saxReader = new SAXReader();
        //2.利用解析器把xml文件加载到内存中,并返回一个文档对象
        Document document = saxReader.read(new File("myxml\\xml\\student.xml"));
        //3.获取到根标签
        Element rootElement = document.getRootElement();
        //4.通过根标签来获取student标签
        //elements():可以获取调用者所有的子标签.会把这些子标签放到一个集合中返回.
        //elements("标签名"):可以获取调用者所有的指定的子标签,会把这些子标签放到一个集合中并返回
        //List list = rootElement.elements();
        List&lt;Element&gt; studentElements = rootElement.elements("student");
        //System.out.println(list.size());
​
        //用来装学生对象
        ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;();
​
        //5.遍历集合,得到每一个student标签
        for (Element element : studentElements) {
            //element依次表示每一个student标签
  
            //获取id这个属性
            Attribute attribute = element.attribute("id");
            //获取id的属性值
            String id = attribute.getValue();
​
            //获取name标签
            //element("标签名"):获取调用者指定的子标签
            Element nameElement = element.element("name");
            //获取这个标签的标签体内容
            String name = nameElement.getText();
​
            //获取age标签
            Element ageElement = element.element("age");
            //获取age标签的标签体内容
            String age = ageElement.getText();
​
//            System.out.println(id);
//            System.out.println(name);
//            System.out.println(age);
​
            Student s = new Student(id,name,Integer.parseInt(age));
            list.add(s);
        }
        //遍历操作
        for (Student student : list) {
            System.out.println(student);
        }
    }
}</code></pre> <p></p> </li></ul> 
<h4>1.5DTD约束【理解】</h4> 
<ul><li> <p>什么是约束</p> <p>用来限定xml文件中可使用的标签以及属性</p> </li><li> <p>约束的分类</p> 
  <ul><li> <p>DTD</p> </li><li> <p>schema</p> </li></ul></li><li> <p>编写DTD约束</p> 
  <ul><li> <p>步骤</p> 
    <ol><li> <p>创建一个文件，这个文件的后缀名为.dtd</p> </li><li> <p>看xml文件中使用了哪些元素</p> <p>&lt;!ELEMENT&gt; 可以定义元素</p> </li><li> <p>判断元素是简单元素还是复杂元素</p> <p>简单元素：没有子元素。 复杂元素：有子元素的元素；</p> </li></ol></li><li> <p>代码实现</p> <pre>&lt;!ELEMENT persons (person)&gt;
&lt;!ELEMENT person (name,age)&gt;
&lt;!ELEMENT name (#PCDATA)&gt;
&lt;!ELEMENT age (#PCDATA)&gt;
</pre> </li></ul><pre></pre> </li><li> <p>引入DTD约束</p> 
  <ul><li> <p>引入DTD约束的三种方法</p> 
    <ul><li> <p>引入本地dtd</p> <p>​​</p> </li><li> <p>在xml文件内部引入</p> <p>​​</p> </li><li> <p>引入网络dtd</p> <p>​​</p> </li></ul></li><li> <p>代码实现</p> 
    <ul><li> <p>引入本地DTD约束</p> <pre>// 这是persondtd.dtd文件中的内容,已经提前写好
&lt;!ELEMENT persons (person)&gt;
&lt;!ELEMENT person (name,age)&gt;
&lt;!ELEMENT name (#PCDATA)&gt;
&lt;!ELEMENT age (#PCDATA)&gt;

// 在person1.xml文件中引入persondtd.dtd约束
<span style="color:#a2e043;"><span style="background-color:#0d0016;">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE persons SYSTEM 'persondtd.dtd'&gt;

&lt;persons&gt;
    &lt;person&gt;
        &lt;name&gt;张三&lt;/name&gt;
        &lt;age&gt;23&lt;/age&gt;
    &lt;/person&gt;

&lt;/persons&gt;</span></span>
</pre> </li><li> <p>在xml文件内部引入</p> <pre><span style="color:#a2e043;"><span style="background-color:#0d0016;">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE persons [
        &lt;!ELEMENT persons (person)&gt;
        &lt;!ELEMENT person (name,age)&gt;
        &lt;!ELEMENT name (#PCDATA)&gt;
        &lt;!ELEMENT age (#PCDATA)&gt;
        ]&gt;

&lt;persons&gt;
    &lt;person&gt;
        &lt;name&gt;张三&lt;/name&gt;
        &lt;age&gt;23&lt;/age&gt;
    &lt;/person&gt;

&lt;/persons&gt;</span></span>
</pre> </li><li> <p>引入网络dtd</p> <pre><span style="color:#a2e043;"><span style="background-color:#0d0016;">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE persons PUBLIC "dtd文件的名称" "dtd文档的URL"&gt;

&lt;persons&gt;
    &lt;person&gt;
        &lt;name&gt;张三&lt;/name&gt;
        &lt;age&gt;23&lt;/age&gt;
    &lt;/person&gt;

&lt;/persons&gt;</span></span>
</pre> </li></ul></li></ul></li><li> <p>DTD语法</p> 
  <ul><li> <p>定义元素</p> <p>定义一个元素的格式为：&lt;!ELEMENT 元素名 元素类型&gt; 简单元素：</p> <p>EMPTY: 表示标签体为空</p> <p>ANY: 表示标签体可以为空也可以不为空</p> <p>PCDATA: 表示该元素的内容部分为字符串</p> <p>复杂元素： ​ 直接写子元素名称. 多个子元素可以使用","或者"|"隔开； ​ ","表示定义子元素的顺序 ; "|": 表示子元素只能出现任意一个 ​ "?"零次或一次, "+"一次或多次, "*"零次或多次;如果不写则表示出现一次</p> <p><img alt="" height="371" src="https://images2.imgbox.com/d6/f9/dZ8frWpU_o.png" width="975"></p> </li></ul></li></ul> 
<ul><li> <p>定义属性</p> <p>格式</p> <p>定义一个属性的格式为：&lt;!ATTLIST 元素名称 属性名称 属性的类型 属性的约束&gt; 属性的类型： ​ CDATA类型：普通的字符串</p> <p>属性的约束:</p> <p>// #REQUIRED： 必须的 ​ // #IMPLIED： 属性不是必需的 ​ // #FIXED value：属性值是固定的</p> </li><li> <p>代码实现</p> <pre><code class="language-html">&lt;!ELEMENT persons (person+)&gt;
&lt;!ELEMENT person (name,age)&gt;
&lt;!ELEMENT name (#PCDATA)&gt;
&lt;!ELEMENT age (#PCDATA)&gt;
&lt;!ATTLIST person id CDATA #REQUIRED&gt;

&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE persons SYSTEM 'persondtd.dtd'&gt;

&lt;persons&gt;
    &lt;person id="001"&gt;
        &lt;name&gt;张三&lt;/name&gt;
        &lt;age&gt;23&lt;/age&gt;
    &lt;/person&gt;

    &lt;person id = "002"&gt;
        &lt;name&gt;张三&lt;/name&gt;
        &lt;age&gt;23&lt;/age&gt;
    &lt;/person&gt;

&lt;/persons&gt;</code></pre> <p></p> </li></ul> 
<h4>1.6schema约束【理解】</h4> 
<ul><li> <p>schema和dtd的区别</p> 
  <ol><li> <p>schema约束文件也是一个xml文件，符合xml的语法，这个文件的后缀名.xsd</p> </li><li> <p>一个xml中可以引用多个schema约束文件，多个schema使用名称空间区分（名称空间类似于java包名）</p> </li><li> <p>dtd里面元素类型的取值比较单一常见的是PCDATA类型，但是在schema里面可以支持很多个数据类型</p> </li><li> <p>schema 语法更加的复杂</p> </li></ol><p><img alt="" height="206" src="https://images2.imgbox.com/d9/b2/9LCGE0gc_o.png" width="905"></p> </li><li> <p>编写schema约束</p> 
  <ul><li> <p>步骤</p> <p>1，创建一个文件，这个文件的后缀名为.xsd。</p> </li><li> <p>2，定义文档声明</p> </li><li> <p>3，schema文件的根标签为： &lt;schema&gt;</p> </li><li> <p>4，在&lt;schema&gt;中定义属性： ​ xmlns=<a href="http://www.w3.org/2001/XMLSchema" rel="nofollow" title="XML Schema">XML Schema</a></p> </li><li> <p>5，在&lt;schema&gt;中定义属性 ： ​ targetNamespace =唯一的url地址，指定当前这个schema文件的名称空间。</p> </li><li> <p>6，在&lt;schema&gt;中定义属性 ： ​ elementFormDefault="qualified“，表示当前schema文件是一个质量良好的文件。</p> </li><li> <p>7，通过element定义元素</p> </li><li> <p>8，判断当前元素是简单元素还是复杂元素</p> <p><img alt="" height="514" src="https://images2.imgbox.com/cf/d6/IrUfCg4d_o.png" width="944"></p> </li><li> <p>代码实现</p> <pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;schema
    xmlns="http://www.w3.org/2001/XMLSchema"
    targetNamespace="http://www.itheima.cn/javase"
    elementFormDefault="qualified"
&gt;

    &lt;!--定义persons复杂元素--&gt;
    &lt;element name="persons"&gt;
        &lt;complexType&gt;
            &lt;sequence&gt;
                &lt;!--定义person复杂元素--&gt;
                &lt;element name = "person"&gt;
                    &lt;complexType&gt;
                        &lt;sequence&gt;
                            &lt;!--定义name和age简单元素--&gt;
                            &lt;element name = "name" type = "string"&gt;&lt;/element&gt;
                            &lt;element name = "age" type = "string"&gt;&lt;/element&gt;
                        &lt;/sequence&gt;
                        
                    &lt;/complexType&gt;
                &lt;/element&gt;
            &lt;/sequence&gt;
        &lt;/complexType&gt;

    &lt;/element&gt;

&lt;/schema&gt;
</code></pre> <p></p> </li></ul></li><li> <p>引入schema约束</p> 
  <ul><li> <p>步骤</p> <p>1，在根标签上定义属性xmlns="<a href="http://www.w3.org/2001/XMLSchema-instance" rel="nofollow" title="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>" 2，通过xmlns引入约束文件的名称空间 3，给某一个xmlns属性添加一个标识，用于区分不同的名称空间 ​ 格式为: xmlns:标识=“名称空间地址” ,标识可以是任意的，但是一般取值都是xsi 4，通过xsi:schemaLocation指定名称空间所对应的约束文件路径 ​ 格式为：xsi:schemaLocation = "名称空间url 文件路径“</p> </li><li> <p>代码实现</p> <pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;

&lt;persons
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://www.itheima.cn/javase"
    xsi:schemaLocation="http://www.itheima.cn/javase person.xsd"
&gt;
    &lt;person&gt;
        &lt;name&gt;张三&lt;/name&gt;
        &lt;age&gt;23&lt;/age&gt;
    &lt;/person&gt;

&lt;/persons&gt;</code></pre> <p></p> </li></ul></li><li> <p>schema约束定义属性</p> 
  <ul><li> <p>代码示例</p> <pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;schema
    xmlns="http://www.w3.org/2001/XMLSchema"
    targetNamespace="http://www.itheima.cn/javase"
    elementFormDefault="qualified"
&gt;

    &lt;!--定义persons复杂元素--&gt;
    &lt;element name="persons"&gt;
        &lt;complexType&gt;
            &lt;sequence&gt;
                &lt;!--定义person复杂元素--&gt;
                &lt;element name = "person"&gt;
                    &lt;complexType&gt;
                        &lt;sequence&gt;
                            &lt;!--定义name和age简单元素--&gt;
                            &lt;element name = "name" type = "string"&gt;&lt;/element&gt;
                            &lt;element name = "age" type = "string"&gt;&lt;/element&gt;
                        &lt;/sequence&gt;
                        
                        &lt;!--定义属性，required( 必须的)/optional( 可选的)--&gt;
                        &lt;attribute name="id" type="string" use="required"&gt;&lt;/attribute&gt;
                    &lt;/complexType&gt;
                    
                &lt;/element&gt;
            &lt;/sequence&gt;
        &lt;/complexType&gt;
    &lt;/element&gt;
    
&lt;/schema&gt;

&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;persons
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://www.itheima.cn/javase"
    xsi:schemaLocation="http://www.itheima.cn/javase person.xsd"
&gt;
    &lt;person id="001"&gt;
        &lt;name&gt;张三&lt;/name&gt;
        &lt;age&gt;23&lt;/age&gt;
    &lt;/person&gt;

&lt;/persons&gt;</code></pre> <pre>
</pre> </li></ul></li></ul> 
<h3>2.枚举</h3> 
<h4>2.1概述【理解】</h4> 
<p>为了间接的表示一些固定的值，Java就给我们提供了枚举 是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内</p> 
<h4>2.2定义格式【应用】</h4> 
<ul><li> <p>格式</p> <pre>public enum s {   
	枚举项1,枚举项2,枚举项3;
}
注意: 定义枚举类要用关键字enum
</pre> </li><li> <p>示例代码</p> <pre>// 定义一个枚举类，用来表示春，夏，秋，冬这四个固定值
public enum Season {
    SPRING,SUMMER,AUTUMN,WINTER;
}
</pre> </li></ul> 
<h4>2.3枚举的特点【理解】</h4> 
<ul><li> <p>特点</p> 
  <ul><li> <p>所有枚举类都是Enum的子类</p> </li><li> <p>我们可以通过"枚举类名.枚举项名称"去访问指定的枚举项</p> </li><li> <p>每一个枚举项其实就是该枚举的一个对象</p> </li><li> <p>枚举也是一个类，也可以去定义成员变量</p> </li><li> <p>枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略</p> </li><li> <p>枚举类可以有构造器，但必须是private的，它默认的也是private的。</p> <p>枚举项的用法比较特殊：枚举("");</p> </li><li> <p>枚举类也可以有抽象方法，但是枚举项必须重写该方法</p> </li></ul></li><li> <p>示例代码</p> <pre><code class="language-java">public enum Season {

    SPRING("春"){

        //如果枚举类中有抽象方法
        //那么在枚举项中必须要全部重写
        @Override
        public void show() {
            System.out.println(this.name);
        }

    },

    SUMMER("夏"){
        @Override
        public void show() {
            System.out.println(this.name);
        }
    },

    AUTUMN("秋"){
        @Override
        public void show() {
            System.out.println(this.name);
        }
    },

    WINTER("冬"){
        @Override
        public void show() {
            System.out.println(this.name);
        }
    };

    public String name;

    //空参构造
    //private Season(){}
  
    //有参构造
    private Season(String name){
        this.name = name;
    }
  
    //抽象方法
    public abstract void show();
}

public class EnumDemo {
    public static void main(String[] args) {
        /*
        1.所有枚举类都是Enum的子类
        2.我们可以通过"枚举类名.枚举项名称"去访问指定的枚举项
        3.每一个枚举项其实就是该枚举的一个对象
        4.枚举也是一个类，也可以去定义成员变量
        5.枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，
          但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略
        6.枚举类可以有构造器，但必须是private的，它默认的也是private的。
          枚举项的用法比较特殊：枚举("");
        7.枚举类也可以有抽象方法，但是枚举项必须重写该方法
    */
  
        //第二个特点的演示
        //我们可以通过"枚举类名.枚举项名称"去访问指定的枚举项
        System.out.println(Season.SPRING);
        System.out.println(Season.SUMMER);
        System.out.println(Season.AUTUMN);
        System.out.println(Season.WINTER);
  
        //第三个特点的演示
        //每一个枚举项其实就是该枚举的一个对象
        Season spring = Season.SPRING;
    }
}</code></pre> </li></ul> 
<h4>2.4枚举的方法【应用】</h4> 
<ul><li> <p>方法介绍</p> 
  <table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String name()</td><td>获取枚举项的名称</td></tr><tr><td>int ordinal()</td><td>返回枚举项在枚举类中的索引值</td></tr><tr><td>int compareTo(E o)</td><td>比较两个枚举项，返回的是索引值的差值</td></tr><tr><td>String toString()</td><td>返回枚举常量的名称</td></tr><tr><td>static &lt;T&gt; T valueOf(Class&lt;T&gt; type,String name)</td><td>获取指定枚举类中的指定名称的枚举值</td></tr><tr><td>values()</td><td>获得所有的枚举项</td></tr></tbody></table></li><li> <p>示例代码</p> <pre><code class="language-java">public enum Season {
    SPRING,SUMMER,AUTUMN,WINTER;
}

public class EnumDemo {
    public static void main(String[] args) {
//        String name() 获取枚举项的名称
        String name = Season.SPRING.name();
        System.out.println(name);
        System.out.println("-----------------------------");

//        int ordinal() 返回枚举项在枚举类中的索引值
        int index1 = Season.SPRING.ordinal();
        int index2 = Season.SUMMER.ordinal();
        int index3 = Season.AUTUMN.ordinal();
        int index4 = Season.WINTER.ordinal();
        System.out.println(index1);
        System.out.println(index2);
        System.out.println(index3);
        System.out.println(index4);
        System.out.println("-----------------------------");

//        int compareTo(E o) 比较两个枚举项，返回的是索引值的差值
        int result = Season.SPRING.compareTo(Season.WINTER);
        System.out.println(result);//-3
        System.out.println("-----------------------------");

//        String toString()   返回枚举常量的名称
        String s = Season.SPRING.toString();
        System.out.println(s);
        System.out.println("-----------------------------");

//        static &lt;T&gt; T valueOf(Class&lt;T&gt; type,String name)
//        获取指定枚举类中的指定名称的枚举值
        Season spring = Enum.valueOf(Season.class, "SPRING");
        System.out.println(spring);
        System.out.println(Season.SPRING == spring);
        System.out.println("-----------------------------");

//        values()       获得所有的枚举项
        Season[] values = Season.values();
        for (Season value : values) {
            System.out.println(value);
        }
    }
}</code></pre> <p></p> </li></ul> 
<h3>3.注解</h3> 
<h4>3.1概述【理解】</h4> 
<ul><li> <p>概述</p> <p>对我们的程序进行标注和解释</p> </li><li> <p>注解和注释的区别</p> 
  <ul><li> <p>注释: 给程序员看的</p> </li><li> <p>注解: 给编译器看的</p> </li></ul></li><li> <p>使用注解进行配置配置的优势</p> <p>代码更加简洁,方便</p> </li></ul> 
<h4>3.2自定义注解【理解】</h4> 
<ul><li> <p>格式</p> <p>public @interface 注解名称 {<!-- --></p> <p>public 属性类型 属性名() default 默认值 ;</p> <p>}</p> </li><li> <p>属性类型</p> 
  <ul><li> <p>基本数据类型</p> </li><li> <p>String</p> </li><li> <p>Class</p> </li><li> <p>注解</p> </li><li> <p>枚举</p> </li><li> <p>以上类型的一维数组</p> </li></ul></li><li> <p>代码演示</p> <pre><code class="language-java">public @interface Anno2 {
}

public enum Season {
    SPRING,SUMMER,AUTUMN,WINTER;
}

public @interface Anno1 {

    //定义一个基本类型的属性
    int a () default 23;

    //定义一个String类型的属性
    public String name() default "itheima";

    //定义一个Class类型的属性
    public Class clazz() default Anno2.class;

    //定义一个注解类型的属性
    public Anno2 anno() default @Anno2;

    //定义一个枚举类型的属性
    public Season season() default Season.SPRING;

    //以上类型的一维数组
    //int数组
    public int[] arr() default {1,2,3,4,5};

    //枚举数组
    public Season[] seasons() default {Season.SPRING,Season.SUMMER};

    //value。后期我们在使用注解的时候，如果我们只需要给注解的value属性赋值。
    //那么value就可以省略
    public String value();

}

//在使用注解的时候如果注解里面的属性没有指定默认值。
//那么我们就需要手动给出注解属性的设置值。
//@Anno1(name = "itheima")
@Anno1("abc")
public class AnnoDemo {
}</code></pre> <p></p> </li><li> <p>注意</p> <p>如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可</p> </li><li> <p>自定义注解案例</p> 
  <ul><li> <p>需求</p> <p>自定义一个注解@Test,用于指定类的方法上,如果某一个类的方法上使用了该注解,就执行该方法</p> </li><li> <p>实现步骤</p> 
    <ol><li> <p>自定义一个注解Test,并在类中的某几个方法上加上注解</p> </li><li> <p>在测试类中,获取注解所在的类的Class对象</p> </li><li> <p>获取类中所有的方法对象</p> </li><li> <p>遍历每一个方法对象,判断是否有对应的注解</p> </li></ol></li><li> <p>代码实现</p> <pre><code class="language-java">//表示Test这个注解的存活时间
@Retention(value = RetentionPolicy.RUNTIME)
public @interface Test {
}

public class UseTest {

    //没有使用Test注解
    public void show(){
        System.out.println("UseTest....show....");
    }

    //使用Test注解
    @Test
    public void method(){
        System.out.println("UseTest....method....");
    }

    //没有使用Test注解
    @Test
    public void function(){
        System.out.println("UseTest....function....");
    }
}

public class AnnoDemo {
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException {
        //1.通过反射获取UseTest类的字节码文件对象
        Class clazz = Class.forName("com.itheima.myanno3.UseTest");

        //创建对象
        UseTest useTest = (UseTest) clazz.newInstance();

        //2.通过反射获取这个类里面所有的方法对象
        Method[] methods = clazz.getDeclaredMethods();

        //3.遍历数组，得到每一个方法对象
        for (Method method : methods) {
            //method依次表示每一个方法对象。
            //isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)
            //判断当前方法上是否有指定的注解。
            //参数：注解的字节码文件对象
            //返回值：布尔结果。  true 存在  false 不存在
            if(method.isAnnotationPresent(Test.class)){
                method.invoke(useTest);
            }
        }
    }
}</code></pre> <p></p> </li></ul></li></ul> 
<h4>3.3元注解【理解】</h4> 
<ul><li> <p>概述</p> <p>元注解就是描述注解的注解</p> </li><li> <p>元注解介绍</p> 
  <table><thead><tr><th>元注解名</th><th>说明</th></tr></thead><tbody><tr><td>@Target</td><td>指定了注解能在哪里使用</td></tr><tr><td>@Retention</td><td>可以理解为保留时间(生命周期)</td></tr><tr><td>@Inherited</td><td>表示修饰的自定义注解可以被子类继承</td></tr><tr><td>@Documented</td><td>表示该自定义注解，会出现在API文档里面。</td></tr></tbody></table></li><li> <p>示例代码</p> <pre><code class="language-java">@Target({ElementType.FIELD,ElementType.TYPE,ElementType.METHOD})  //指定注解使用的位置（成员变量，类，方法）
@Retention(RetentionPolicy.RUNTIME) //指定该注解的存活时间
//@Inherited //指定该注解可以被继承
public @interface Anno {
}

@Anno
public class Person {
}

public class Student extends Person {
    public void show(){
        System.out.println("student.......show..........");
    }
}

public class StudentDemo {
    public static void main(String[] args) throws ClassNotFoundException {
        //获取到Student类的字节码文件对象
        Class clazz = Class.forName("com.itheima.myanno4.Student");

        //获取注解。
        boolean result = clazz.isAnnotationPresent(Anno.class);
        System.out.println(result);
    }
}
</code></pre> <p></p> </li></ul> 
<p> </p> 
<h4>一、单元测试</h4> 
<pre>    任何应用程序，在正式发布之前，都需要经过测试，确定应用程序的功能能够满足程序设计的要求。
    
    每个应用程序的都有很多功能，代码也会有很多，少则几万行，多则数十万行。如果等所有的功能都开发完毕，再进行测试，一旦出了bug，由于代码错综复杂，很难排查问题。
    
    所以，实际开发中，需要以功能为单位，设计测试。每写完一个功能，就对这个功能的完整性进行测试，如果所有的功能测试都没有问题，那么整个应用程序就没有问题
    
    测试分类：
        黑盒测试: 不需要写测试代码
        白盒测试: 需要测试代码
        
junit测试框架：
    由apache提供的一种测试框架，可以简化测试代码的编写
    
    使用：
        1.导入junit 的 jar包
        2.定义测试类
            类名规范：被测试类名+Test
        3.定义测试方法
            权限修饰符：public
            返回值类型：void
            方法名:test+被测试方法名
            参数列表：空
            
        4.在测试方法上添加@Test注解
        
        5.运行测试方法
        
    
    @Before注解：
        添加该注解的方法，在所有测试方法执行之前执行，一般用来初始化资源(加载配置文件)
        
    @After注解：
        添加该注解的方法，在所有测试方法执行之后执行，一般用来释放资源
        
        </pre> 
<h4>二、动态代理</h4> 
<pre>设计模式：
    计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。
    
常见设计模式（23种）：
    适配器模式（Adapter Pattern）
    桥接模式（Bridge Pattern）
    过滤器模式（Filter、Criteria Pattern）
    装饰器模式（Decorator Pattern）
    模板模式（Template Pattern）
    代理模式（Proxy Pattern）
    ......
 
 代理模式：
    解决的问题：
        在不修改源码的基础上，对功能(方法)进行增强
    三要素：
        共用接口：为了规定代理对象和被代理对象有共同的行为(方法)
        被代理对象：背后真正做事情的对象
        代理对象：与用户打交道的对象，会调用被代理对象完成功能
    
    实现：
        1.定义接口
        2.创建被代理对象
        3.创建代理对象
        4.用户调用代理对象的方法完成功能
        </pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d46e9d8e6170110ee100403144df6318/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">a&#43;&#43; 与 &#43;&#43;a 的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/510496234b0ba6dacbf32efba97a4d7c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信小程序之短连接 分享转发 点击短连接就可以直接打开小程序某个页面</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>