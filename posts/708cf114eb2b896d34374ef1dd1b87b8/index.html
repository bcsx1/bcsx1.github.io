<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>防抖、节流、深拷贝事件总线 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="防抖、节流、深拷贝事件总线" />
<meta property="og:description" content="1 认识防抖和节流
2 underscore使用
3 防抖函数实现优化
4 节流函数实现优化
5 深拷贝函数的实现
6 事件总线工具实现
简而言之，防抖就是一直触发事件就一直往后拖延再执行。
节流就是一段时间就执行一次，不管中间你触发多少次。
防抖-认识防抖操作 &lt;body&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;input type=&#34;text&#34;&gt; &lt;!-- CDN引入: 网络的js文件 --&gt; &lt;!-- &lt;script src=&#34;https://cdn.jsdelivr.net/npm/underscore@1.13.4/underscore-umd-min.js&#34;&gt;&lt;/script&gt; --&gt; &lt;!-- 本地引入: 下载js文件, 并且本地引入 --&gt; &lt;script src=&#34;./js/underscore.js&#34;&gt;&lt;/script&gt; &lt;script&gt; // 1.获取input元素 const inputEl = document.querySelector(&#34;input&#34;) // 2.监听input元素的输入 // let counter = 1 // inputEl.oninput = function() { // console.log(`发送网络请求${counter&#43;&#43;}:`, this.value) // } // 3.防抖处理代码 let counter = 1 inputEl.oninput = _.debounce(function() { console.log(`发送网络请求${counter&#43;&#43;}:`, this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/708cf114eb2b896d34374ef1dd1b87b8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-17T09:37:57+08:00" />
<meta property="article:modified_time" content="2023-07-17T09:37:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">防抖、节流、深拷贝事件总线</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1 认识防抖和节流</p> 
<p>2 underscore使用</p> 
<p>3 防抖函数实现优化</p> 
<p>4 节流函数实现优化</p> 
<p>5 深拷贝函数的实现</p> 
<p>6 事件总线工具实现</p> 
<p></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>简而言之，防抖就是一直触发事件就一直往后拖延再执行。</strong></span></p> 
 <p><img alt="" height="241" src="https://images2.imgbox.com/13/09/zkCLcSlf_o.png" width="802"></p> 
 <p></p> 
 <p><span style="color:#fe2c24;"><strong>节流就是一段时间就执行一次，不管中间你触发多少次。</strong></span></p> 
 <p><img alt="" height="250" src="https://images2.imgbox.com/75/4a/hGkPwatC_o.png" width="780"></p> 
 <p></p> 
 <p></p> 
</blockquote> 
<p></p> 
<p></p> 
<h2>防抖-认识防抖操作 </h2> 
<blockquote> 
 <pre><code class="language-html">&lt;body&gt;

  &lt;button&gt;按钮&lt;/button&gt;

  &lt;input type="text"&gt;
  
  &lt;!-- CDN引入: 网络的js文件 --&gt;
  &lt;!-- &lt;script src="https://cdn.jsdelivr.net/npm/underscore@1.13.4/underscore-umd-min.js"&gt;&lt;/script&gt; --&gt;
  &lt;!-- 本地引入: 下载js文件, 并且本地引入 --&gt;
  &lt;script src="./js/underscore.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    // 1.获取input元素
    const inputEl = document.querySelector("input")

    // 2.监听input元素的输入
    // let counter = 1
    // inputEl.oninput = function() {
    //   console.log(`发送网络请求${counter++}:`, this.value)
    // }
    
    // 3.防抖处理代码
    let counter = 1
    inputEl.oninput = _.debounce(function() {
      console.log(`发送网络请求${counter++}:`, this.value)
    }, 3000)

  &lt;/script&gt;

&lt;/body&gt;</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2>防抖-实现防抖-基本实现(面试</h2> 
<blockquote> 
 <p>需要拿到之前的执行的函数才能取消之前执行的函数，这里是通过let timer来获取的。</p> 
 <p>主要是通过定时器来做到延时执行，而定时器里面有timer置null的作用清除。</p> 
 <pre><code class="language-javascript">&lt;body&gt;

  &lt;button&gt;按钮&lt;/button&gt;

  &lt;input type="text"&gt;
  
  &lt;!-- CDN引入: 网络的js文件 --&gt;
  &lt;!-- &lt;script src="https://cdn.jsdelivr.net/npm/underscore@1.13.4/underscore-umd-min.js"&gt;&lt;/script&gt; --&gt;
  &lt;!-- 本地引入: 下载js文件, 并且本地引入 --&gt;
  &lt;script src="./js/underscore.js"&gt;&lt;/script&gt;

  &lt;script&gt;
    function hydebounce(fn, delay) {
      // 1.用于记录上一次事件触发的timer
      let timer = null

      // 2.触发事件时执行的函数
      const _debounce = () =&gt; {
        // 2.1.如果有再次触发(更多次触发)事件, 那么取消上一次的事件
        if (timer) clearTimeout(timer)

        // 2.2.延迟去执行对应的fn函数(传入的回调函数)
        timer = setTimeout(() =&gt; {
          fn()
          timer = null // 执行过函数之后, 将timer重新置null
        }, delay);
      }

      // 返回一个新的函数
      return _debounce
    }
  &lt;/script&gt;

  &lt;script&gt;
   

    // 3.自己实现的防抖
    let counter = 1
    inputEl.oninput = hydebounce(function() {
      console.log(`发送网络请求${counter++}`)
    }, 1000)

  &lt;/script&gt;

&lt;/body&gt;</code></pre> 
</blockquote> 
<h2>防抖-实现防抖-this和参数绑定</h2> 
<blockquote> 
 <p>绑定this的过程</p> 
 <p>还有就是dom事件有绑定event事件，我们写hudebounce最终其实是在执行_debounce，那么这个函数其实已经隐式绑定了inputEl,拿到了this就是inputEl。而const _debounce = function(...args)可以拿到event和其他参数传递给fn函数。</p> 
 <pre><code class="language-javascript">&lt;body&gt;

  &lt;button&gt;按钮&lt;/button&gt;

  &lt;input type="text"&gt;
  
  &lt;!-- CDN引入: 网络的js文件 --&gt;
  &lt;!-- &lt;script src="https://cdn.jsdelivr.net/npm/underscore@1.13.4/underscore-umd-min.js"&gt;&lt;/script&gt; --&gt;
  &lt;!-- 本地引入: 下载js文件, 并且本地引入 --&gt;
  &lt;script src="./js/underscore.js"&gt;&lt;/script&gt;

  &lt;script&gt;
    function hydebounce(fn, delay) {
      // 1.用于记录上一次事件触发的timer
      let timer = null

      // 2.触发事件时执行的函数
      const _debounce = function(...args) {
        // 2.1.如果有再次触发(更多次触发)事件, 那么取消上一次的事件
        if (timer) clearTimeout(timer)

        // 2.2.延迟去执行对应的fn函数(传入的回调函数)
        timer = setTimeout(() =&gt; {
          fn.apply(this, args)
          timer = null // 执行过函数之后, 将timer重新置null
        }, delay);
      }

      // 返回一个新的函数
      return _debounce
    }
  &lt;/script&gt;

  &lt;script&gt;
    // 1.获取input元素
    const inputEl = document.querySelector("input")

    // 未进行防抖处理代码
    // let counter = 1
    // inputEl.oninput = function(event) {
    //   console.log(`发送网络请求${counter++}:`, this, event)
    // }

    // 2.underscore防抖处理代码
    // let counter = 1
    // inputEl.oninput = _.debounce(function() {
    //   console.log(`发送网络请求${counter++}:`, this.value)
    // }, 1000)

    // 3.自己实现的防抖
    let counter = 1
    inputEl.oninput = hydebounce(function(event) {
      console.log(`发送网络请求${counter++}:`, this, event)
    }, 1000)

  &lt;/script&gt;

&lt;/body&gt;</code></pre> 
 <p></p> 
</blockquote> 
<h2>防抖-实现防抖-取消功能实现</h2> 
<blockquote> 
 <p>oninput的事件，输入了就一定会执行了，我们可以设置一个按钮来取消这个事件的执行，具体怎么实现看代码。主要是hudebounce的_debounce是对象类型，所以可以直接.函数来取消执行。</p> 
 <pre><code class="language-javascript">&lt;body&gt;

  &lt;button&gt;按钮&lt;/button&gt;

  &lt;input type="text"&gt;
  &lt;button class="cancel"&gt;取消&lt;/button&gt;
  
  &lt;!-- CDN引入: 网络的js文件 --&gt;
  &lt;!-- &lt;script src="https://cdn.jsdelivr.net/npm/underscore@1.13.4/underscore-umd-min.js"&gt;&lt;/script&gt; --&gt;
  &lt;!-- 本地引入: 下载js文件, 并且本地引入 --&gt;
  &lt;script src="./js/underscore.js"&gt;&lt;/script&gt;

  &lt;script&gt;
    function hydebounce(fn, delay) {
      // 1.用于记录上一次事件触发的timer
      let timer = null

      // 2.触发事件时执行的函数
      const _debounce = function(...args) {
        // 2.1.如果有再次触发(更多次触发)事件, 那么取消上一次的事件
        if (timer) clearTimeout(timer)

        // 2.2.延迟去执行对应的fn函数(传入的回调函数)
        timer = setTimeout(() =&gt; {
          fn.apply(this, args)
          timer = null // 执行过函数之后, 将timer重新置null
        }, delay);
      }

      // 3.给_debounce绑定一个取消的函数
      _debounce.cancel = function() {
        if (timer) clearTimeout(timer)
      }

      // 返回一个新的函数
      return _debounce
    }
  &lt;/script&gt;

  &lt;script&gt;
    // 1.获取input元素
    const inputEl = document.querySelector("input")
    const cancelBtn = document.querySelector(".cancel")

    // 未进行防抖处理代码
    // let counter = 1
    // inputEl.oninput = function(event) {
    //   console.log(`发送网络请求${counter++}:`, this, event)
    // }

    // 2.underscore防抖处理代码
    // let counter = 1
    // inputEl.oninput = _.debounce(function() {
    //   console.log(`发送网络请求${counter++}:`, this.value)
    // }, 1000)

    // 3.自己实现的防抖
    let counter = 1
    const debounceFn = hydebounce(function(event) {
      console.log(`发送网络请求${counter++}:`, this, event)
    }, 5000)
    inputEl.oninput = debounceFn

    // 4.实现取消的功能
    cancelBtn.onclick = function() {
      debounceFn.cancel()
    }

  &lt;/script&gt;

&lt;/body&gt;</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2>防抖-实现防抖-立即执行功能</h2> 
<blockquote> 
 <p>应用场景可能是  用户输入book 的时候，第一次输入b的时候马上执行，后续的ook才有防抖效果。通过另外一个变量来控制 let isInvoke。</p> 
 <pre><code class="language-html">&lt;body&gt;

  &lt;button&gt;按钮&lt;/button&gt;

  &lt;input type="text"&gt;
  &lt;button class="cancel"&gt;取消&lt;/button&gt;
  
  &lt;!-- CDN引入: 网络的js文件 --&gt;
  &lt;!-- &lt;script src="https://cdn.jsdelivr.net/npm/underscore@1.13.4/underscore-umd-min.js"&gt;&lt;/script&gt; --&gt;
  &lt;!-- 本地引入: 下载js文件, 并且本地引入 --&gt;
  &lt;script src="./js/underscore.js"&gt;&lt;/script&gt;

  &lt;script&gt;
    // 原则: 一个函数进行做一件事情, 一个变量也用于记录一种状态

    function hydebounce(fn, delay, immediate = false) {
      // 1.用于记录上一次事件触发的timer
      let timer = null
      let isInvoke = false

      // 2.触发事件时执行的函数
      const _debounce = function(...args) {
        // 2.1.如果有再次触发(更多次触发)事件, 那么取消上一次的事件
        if (timer) clearTimeout(timer)

        // 第一次操作是不需要延迟
        if (immediate &amp;&amp; !isInvoke) {
          fn.apply(this, args)
          isInvoke = true
          return
        }

        // 2.2.延迟去执行对应的fn函数(传入的回调函数)
        timer = setTimeout(() =&gt; {
          fn.apply(this, args)
          timer = null // 执行过函数之后, 将timer重新置null
          isInvoke = false
        }, delay);
      }

      // 3.给_debounce绑定一个取消的函数
      _debounce.cancel = function() {
        if (timer) clearTimeout(timer)
        timer = null
        isInvoke = false
      }

      // 返回一个新的函数
      return _debounce
    }
  &lt;/script&gt;

  &lt;script&gt;
    // 1.获取input元素
    const inputEl = document.querySelector("input")
    const cancelBtn = document.querySelector(".cancel")

    // 未进行防抖处理代码
    // let counter = 1
    // inputEl.oninput = function(event) {
    //   console.log(`发送网络请求${counter++}:`, this, event)
    // }

    // 2.underscore防抖处理代码
    // let counter = 1
    // inputEl.oninput = _.debounce(function() {
    //   console.log(`发送网络请求${counter++}:`, this.value)
    // }, 1000)

    // 3.自己实现的防抖
    let counter = 1
    const debounceFn = hydebounce(function(event) {
      console.log(`发送网络请求${counter++}:`, this, event)
    }, 100)
    inputEl.oninput = debounceFn

    // 4.实现取消的功能
    cancelBtn.onclick = function() {
      debounceFn.cancel()
    }

  &lt;/script&gt;

&lt;/body&gt;</code></pre> 
 <p></p> 
</blockquote> 
<h2>防抖-实现防抖-获取返回值</h2> 
<blockquote> 
 <p>利用promise来做到获取返回值。</p> 
 <pre><code class="language-html">&lt;body&gt;

  &lt;button&gt;按钮&lt;/button&gt;

  &lt;input type="text"&gt;
  &lt;button class="cancel"&gt;取消&lt;/button&gt;
  
  &lt;!-- CDN引入: 网络的js文件 --&gt;
  &lt;!-- &lt;script src="https://cdn.jsdelivr.net/npm/underscore@1.13.4/underscore-umd-min.js"&gt;&lt;/script&gt; --&gt;
  &lt;!-- 本地引入: 下载js文件, 并且本地引入 --&gt;
  &lt;script src="./js/underscore.js"&gt;&lt;/script&gt;

  &lt;script&gt;
    // 原则: 一个函数进行做一件事情, 一个变量也用于记录一种状态

    function hydebounce(fn, delay, immediate = false, resultCallback) {
      // 1.用于记录上一次事件触发的timer
      let timer = null
      let isInvoke = false

      // 2.触发事件时执行的函数
      const _debounce = function(...args) {
        return new Promise((resolve, reject) =&gt; {
          try {
            // 2.1.如果有再次触发(更多次触发)事件, 那么取消上一次的事件
            if (timer) clearTimeout(timer)

            // 第一次操作是不需要延迟
            let res = undefined
            if (immediate &amp;&amp; !isInvoke) {
              res = fn.apply(this, args)
              if (resultCallback) resultCallback(res)
              resolve(res)
              isInvoke = true
              return
            }

            // 2.2.延迟去执行对应的fn函数(传入的回调函数)
            timer = setTimeout(() =&gt; {
              res = fn.apply(this, args)
              if (resultCallback) resultCallback(res)
              resolve(res)
              timer = null // 执行过函数之后, 将timer重新置null
              isInvoke = false
            }, delay);
          } catch (error) {
            reject(error)
          }
        })
      }

      // 3.给_debounce绑定一个取消的函数
      _debounce.cancel = function() {
        if (timer) clearTimeout(timer)
        timer = null
        isInvoke = false
      }

      // 返回一个新的函数
      return _debounce
    }
  &lt;/script&gt;

  &lt;script&gt;
    // 1.获取input元素
    const inputEl = document.querySelector("input")
    const cancelBtn = document.querySelector(".cancel")

    // 2.手动绑定函数和执行
    const myDebounceFn = hydebounce(function(name, age, height) {
      console.log("----------", name, age, height)
      return "coderwhy 哈哈哈哈"
    }, 1000, false)

    myDebounceFn("why", 18, 1.88).then(res =&gt; {
      console.log("拿到执行结果:", res)
    })

  &lt;/script&gt;

&lt;/body&gt;</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2>防抖-实现防抖-封装独立文件</h2> 
<blockquote> 
 <p>封装的代码：</p> 
 <pre><code class="language-javascript">
// 原则: 一个函数进行做一件事情, 一个变量也用于记录一种状态
function hydebounce(fn, delay, immediate = false, resultCallback) {
  // 1.用于记录上一次事件触发的timer
  let timer = null
  let isInvoke = false

  // 2.触发事件时执行的函数
  const _debounce = function(...args) {
    return new Promise((resolve, reject) =&gt; {
      try {
        // 2.1.如果有再次触发(更多次触发)事件, 那么取消上一次的事件
        if (timer) clearTimeout(timer)

        // 第一次操作是不需要延迟
        let res = undefined
        if (immediate &amp;&amp; !isInvoke) {
          res = fn.apply(this, args)
          if (resultCallback) resultCallback(res)
          resolve(res)
          isInvoke = true
          return
        }

        // 2.2.延迟去执行对应的fn函数(传入的回调函数)
        timer = setTimeout(() =&gt; {
          res = fn.apply(this, args)
          if (resultCallback) resultCallback(res)
          resolve(res)
          timer = null // 执行过函数之后, 将timer重新置null
          isInvoke = false
        }, delay);
      } catch (error) {
        reject(error)
      }
    })
  }

  // 3.给_debounce绑定一个取消的函数
  _debounce.cancel = function() {
    if (timer) clearTimeout(timer)
    timer = null
    isInvoke = false
  }

  // 返回一个新的函数
  return _debounce
}

</code></pre> 
 <p>执行的代码html</p> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  
  &lt;input type="text"&gt;
  &lt;button class="cancel"&gt;取消&lt;/button&gt;

  &lt;script src="./js/hy_debounce.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    const inputEl = document.querySelector("input")
    const cancelBtn = document.querySelector(".cancel")

    let counter = 1
    const debounceFn = hydebounce(function(event) {
      console.log(`发送网络请求${counter++}:`, this, event)
    }, 1000)
    inputEl.oninput = debounceFn

    // 4.实现取消的功能
    cancelBtn.onclick = function() {
      debounceFn.cancel()
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2>节流-认识节流操作</h2> 
<blockquote> 
 <p>使用第三方库</p> 
 <pre><code class="language-html">&lt;body&gt;

  &lt;button&gt;按钮&lt;/button&gt;

  &lt;input type="text"&gt;
  
  &lt;!-- CDN引入: 网络的js文件 --&gt;
  &lt;!-- &lt;script src="https://cdn.jsdelivr.net/npm/underscore@1.13.4/underscore-umd-min.js"&gt;&lt;/script&gt; --&gt;
  &lt;!-- 本地引入: 下载js文件, 并且本地引入 --&gt;
  &lt;script src="./js/underscore.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    // 1.获取input元素
    const inputEl = document.querySelector("input")

  

    // 4.节流处理代码
    let counter = 1
    inputEl.oninput = _.throttle(function() {
      console.log(`发送网络请求${counter++}:`, this.value)
    }, 1000)

  &lt;/script&gt;

&lt;/body&gt;</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2>节流-实现节流-基本实现(面试)</h2> 
<blockquote> 
 <p>需要通过一个计算公式来实现节流的效果</p> 
 <p>const waitTime = interval - (nowTime - startTime)</p> 
 <p>waitTime用来判断是否执行fn函数</p> 
 <p>interval是使用者规定的执行间隔时间</p> 
 <p>nowTime是记录每次执行hythrottle的时间点</p> 
 <p>startTime是记录每次执行fn的时间点，通过if判断来决定是否执行fn函数。</p> 
 <pre><code class="language-html">&lt;body&gt;

  &lt;button&gt;按钮&lt;/button&gt;

  &lt;input type="text"&gt;
  
  &lt;!-- CDN引入: 网络的js文件 --&gt;
  &lt;!-- &lt;script src="https://cdn.jsdelivr.net/npm/underscore@1.13.4/underscore-umd-min.js"&gt;&lt;/script&gt; --&gt;
  &lt;!-- 本地引入: 下载js文件, 并且本地引入 --&gt;
  &lt;script src="./js/underscore.js"&gt;&lt;/script&gt;

  &lt;script&gt;
    function hythrottle(fn, interval) {
      let startTime = 0

      const _throttle = function() {
        const nowTime = new Date().getTime()
        const waitTime = interval - (nowTime - startTime)
        if (waitTime &lt;= 0) {
          fn()
          startTime = nowTime
        }
      }

      return _throttle
    }
  &lt;/script&gt;

  &lt;script&gt;
    // 1.获取input元素
    const inputEl = document.querySelector("input")

    // 2.underscore节流处理代码
    // let counter = 1
    // inputEl.oninput = _.throttle(function() {
    //   console.log(`发送网络请求${counter++}:`, this.value)
    // }, 1000)

    // 3.自己实现的节流函数
    let counter = 1
    inputEl.oninput = hythrottle(function() {
      console.log(`发送网络请求${counter++}:`, this.value)
    }, 1000)


  &lt;/script&gt;

&lt;/body&gt;</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2>节流-实现节流-this和参数绑定</h2> 
<blockquote> 
 <p>实现的原理和之前的防抖一样，都是利用了隐式绑定的方法。fn.apply(this, args)</p> 
 <pre><code class="language-html">&lt;body&gt;

  &lt;button&gt;按钮&lt;/button&gt;

  &lt;input type="text"&gt;
  
  &lt;!-- CDN引入: 网络的js文件 --&gt;
  &lt;!-- &lt;script src="https://cdn.jsdelivr.net/npm/underscore@1.13.4/underscore-umd-min.js"&gt;&lt;/script&gt; --&gt;
  &lt;!-- 本地引入: 下载js文件, 并且本地引入 --&gt;
  &lt;script src="./js/underscore.js"&gt;&lt;/script&gt;

  &lt;script&gt;
    function hythrottle(fn, interval) {
      let startTime = 0

      const _throttle = function(...args) {
        const nowTime = new Date().getTime()
        const waitTime = interval - (nowTime - startTime)
        if (waitTime &lt;= 0) {
          fn.apply(this, args)
          startTime = nowTime
        }
      }

      return _throttle
    }
  &lt;/script&gt;

  &lt;script&gt;
    // 1.获取input元素
    const inputEl = document.querySelector("input")

    // 2.underscore节流处理代码
    // let counter = 1
    // inputEl.oninput = _.throttle(function() {
    //   console.log(`发送网络请求${counter++}:`, this.value)
    // }, 1000)

    // 3.自己实现的节流函数
    let counter = 1
    inputEl.oninput = hythrottle(function(event) {
      console.log(`发送网络请求${counter++}:`, this.value, event)
    }, 1000)

  &lt;/script&gt;

&lt;/body&gt;</code></pre> 
 <p></p> 
</blockquote> 
<h2>节流-实现节流-立即执行控制</h2> 
<blockquote> 
 <p>立即执行和最后一次执行是否执行。</p> 
 <pre><code class="language-html">&lt;body&gt;

  &lt;button&gt;按钮&lt;/button&gt;

  &lt;input type="text"&gt;
  
  &lt;!-- CDN引入: 网络的js文件 --&gt;
  &lt;!-- &lt;script src="https://cdn.jsdelivr.net/npm/underscore@1.13.4/underscore-umd-min.js"&gt;&lt;/script&gt; --&gt;
  &lt;!-- 本地引入: 下载js文件, 并且本地引入 --&gt;
  &lt;script src="./js/underscore.js"&gt;&lt;/script&gt;

  &lt;script&gt;
    function hythrottle(fn, interval, leading = true) {
      let startTime = 0

      const _throttle = function(...args) {
        // 1.获取当前时间
        const nowTime = new Date().getTime()

        // 对立即执行进行控制
        if (!leading &amp;&amp; startTime === 0) {
          startTime = nowTime
        }

        // 2.计算需要等待的时间执行函数
        const waitTime = interval - (nowTime - startTime)
        if (waitTime &lt;= 0) {
          fn.apply(this, args)
          startTime = nowTime
        }
      }

      return _throttle
    }
  &lt;/script&gt;

  &lt;script&gt;
    // 1.获取input元素
    const inputEl = document.querySelector("input")

    // 2.underscore节流处理代码
    // let counter = 1
    // inputEl.oninput = _.throttle(function() {
    //   console.log(`发送网络请求${counter++}:`, this.value)
    // }, 1000)

    // 3.自己实现的节流函数
    let counter = 1
    inputEl.oninput = hythrottle(function(event) {
      console.log(`发送网络请求${counter++}:`, this.value, event)
    }, 1000)

  &lt;/script&gt;

&lt;/body&gt;</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2>节流-实现节流-尾部执行控制(了解)</h2> 
<blockquote> 
 <p>不同于防抖，防抖的最后一次是一定执行的，但是节流的最后一次如果没有达到限制的时间是不会执行的，以下是解决办法。</p> 
 <pre><code class="language-html">&lt;body&gt;

  &lt;button&gt;按钮&lt;/button&gt;

  &lt;input type="text"&gt;
  
  &lt;!-- CDN引入: 网络的js文件 --&gt;
  &lt;!-- &lt;script src="https://cdn.jsdelivr.net/npm/underscore@1.13.4/underscore-umd-min.js"&gt;&lt;/script&gt; --&gt;
  &lt;!-- 本地引入: 下载js文件, 并且本地引入 --&gt;
  &lt;script src="./js/underscore.js"&gt;&lt;/script&gt;

  &lt;script&gt;
    function hythrottle(fn, interval, { leading = true, trailing = false } = {}) {
      let startTime = 0
      let timer = null

      const _throttle = function(...args) {
        // 1.获取当前时间
        const nowTime = new Date().getTime()

        // 对立即执行进行控制
        if (!leading &amp;&amp; startTime === 0) {
          startTime = nowTime
        }

        // 2.计算需要等待的时间执行函数
        const waitTime = interval - (nowTime - startTime)
        if (waitTime &lt;= 0) {
          // console.log("执行操作fn")
          if (timer) clearTimeout(timer)
          fn.apply(this, args)
          startTime = nowTime
          timer = null
          return
        } 

        // 3.判断是否需要执行尾部
        if (trailing &amp;&amp; !timer) {
          timer = setTimeout(() =&gt; {
            // console.log("执行timer")
            fn.apply(this, args)
            startTime = new Date().getTime()
            timer = null
          }, waitTime);
        }
      }

      return _throttle
    }
  &lt;/script&gt;

  &lt;script&gt;
    // 1.获取input元素
    const inputEl = document.querySelector("input")

    // 2.underscore节流处理代码
    // let counter = 1
    // inputEl.oninput = _.throttle(function() {
    //   console.log(`发送网络请求${counter++}:`, this.value)
    // }, 1000)

    // 3.自己实现的节流函数
    let counter = 1
    inputEl.oninput = hythrottle(function(event) {
      console.log(`发送网络请求${counter++}:`, this.value, event)
    }, 3000, { trailing: true })

  &lt;/script&gt;

&lt;/body&gt;</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2>节流-实现节流-取消功能实现</h2> 
<blockquote> 
 <p>1</p> 
 <pre><code class="language-html">&lt;body&gt;

  &lt;button&gt;按钮&lt;/button&gt;

  &lt;input type="text"&gt;
  &lt;button class="cancel"&gt;取消&lt;/button&gt;
  
  &lt;!-- CDN引入: 网络的js文件 --&gt;
  &lt;!-- &lt;script src="https://cdn.jsdelivr.net/npm/underscore@1.13.4/underscore-umd-min.js"&gt;&lt;/script&gt; --&gt;
  &lt;!-- 本地引入: 下载js文件, 并且本地引入 --&gt;
  &lt;script src="./js/underscore.js"&gt;&lt;/script&gt;

  &lt;script&gt;
    function hythrottle(fn, interval, { leading = true, trailing = false } = {}) {
      let startTime = 0
      let timer = null

      const _throttle = function(...args) {
        // 1.获取当前时间
        const nowTime = new Date().getTime()

        // 对立即执行进行控制
        if (!leading &amp;&amp; startTime === 0) {
          startTime = nowTime
        }

        // 2.计算需要等待的时间执行函数
        const waitTime = interval - (nowTime - startTime)
        if (waitTime &lt;= 0) {
          // console.log("执行操作fn")
          if (timer) clearTimeout(timer)
          fn.apply(this, args)
          startTime = nowTime
          timer = null
          return
        } 

        // 3.判断是否需要执行尾部
        if (trailing &amp;&amp; !timer) {
          timer = setTimeout(() =&gt; {
            // console.log("执行timer")
            fn.apply(this, args)
            startTime = new Date().getTime()
            timer = null
          }, waitTime);
        }
      }

      _throttle.cancel = function() {
        if (timer) clearTimeout(timer)
        startTime = 0
        timer = null
      }

      return _throttle
    }
  &lt;/script&gt;

  &lt;script&gt;
    // 1.获取input元素
    const inputEl = document.querySelector("input")
    const cancelBtn = document.querySelector(".cancel")

    // 2.underscore节流处理代码
    // let counter = 1
    // inputEl.oninput = _.throttle(function() {
    //   console.log(`发送网络请求${counter++}:`, this.value)
    // }, 1000)

    // 3.自己实现的节流函数
    let counter = 1

    const throttleFn = hythrottle(function(event) {
      console.log(`发送网络请求${counter++}:`, this.value, event)
    }, 3000, { trailing: true })

    inputEl.oninput = throttleFn

    cancelBtn.onclick = function() {
      throttleFn.cancel()
    }

  &lt;/script&gt;

&lt;/body&gt;</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2>节流-实现节流-获取返回值</h2> 
<blockquote> 
 <p>1</p> 
 <pre><code class="language-html">&lt;body&gt;

  &lt;button&gt;按钮&lt;/button&gt;

  &lt;input type="text"&gt;
  &lt;button class="cancel"&gt;取消&lt;/button&gt;
  
  &lt;!-- CDN引入: 网络的js文件 --&gt;
  &lt;!-- &lt;script src="https://cdn.jsdelivr.net/npm/underscore@1.13.4/underscore-umd-min.js"&gt;&lt;/script&gt; --&gt;
  &lt;!-- 本地引入: 下载js文件, 并且本地引入 --&gt;
  &lt;script src="./js/underscore.js"&gt;&lt;/script&gt;

  &lt;script&gt;
    function hythrottle(fn, interval, { leading = true, trailing = false } = {}) {
      let startTime = 0
      let timer = null

      const _throttle = function(...args) {
        return new Promise((resolve, reject) =&gt; {
          try {
             // 1.获取当前时间
            const nowTime = new Date().getTime()

            // 对立即执行进行控制
            if (!leading &amp;&amp; startTime === 0) {
              startTime = nowTime
            }

            // 2.计算需要等待的时间执行函数
            const waitTime = interval - (nowTime - startTime)
            if (waitTime &lt;= 0) {
              // console.log("执行操作fn")
              if (timer) clearTimeout(timer)
              const res = fn.apply(this, args)
              resolve(res)
              startTime = nowTime
              timer = null
              return
            } 

            // 3.判断是否需要执行尾部
            if (trailing &amp;&amp; !timer) {
              timer = setTimeout(() =&gt; {
                // console.log("执行timer")
                const res = fn.apply(this, args)
                resolve(res)
                startTime = new Date().getTime()
                timer = null
              }, waitTime);
            }
          } catch (error) {
            reject(error)
          }
        })
      }

      _throttle.cancel = function() {
        if (timer) clearTimeout(timer)
        startTime = 0
        timer = null
      }

      return _throttle
    }
  &lt;/script&gt;

  &lt;script&gt;
    // 1.获取input元素
    const inputEl = document.querySelector("input")
    const cancelBtn = document.querySelector(".cancel")

    // 2.underscore节流处理代码
    // let counter = 1
    // inputEl.oninput = _.throttle(function() {
    //   console.log(`发送网络请求${counter++}:`, this.value)
    // }, 1000)

    // 3.自己实现的节流函数
    let counter = 1

    const throttleFn = hythrottle(function(event) {
      console.log(`发送网络请求${counter++}:`, this.value, event)
      return "throttle return value"
    }, 3000, { trailing: true })

    throttleFn("aaaa").then(res =&gt; {
      console.log("res:", res)
    })

  &lt;/script&gt;

&lt;/body&gt;</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<p></p> 
<h2>节流-实现节流-封装独立文件</h2> 
<blockquote> 
 <p>underscore.js</p> 
 <pre><code class="language-javascript">function hythrottle(fn, interval, { leading = true, trailing = false } = {}) {
  let startTime = 0
  let timer = null

  const _throttle = function(...args) {
    return new Promise((resolve, reject) =&gt; {
      try {
         // 1.获取当前时间
        const nowTime = new Date().getTime()

        // 对立即执行进行控制
        if (!leading &amp;&amp; startTime === 0) {
          startTime = nowTime
        }

        // 2.计算需要等待的时间执行函数
        const waitTime = interval - (nowTime - startTime)
        if (waitTime &lt;= 0) {
          // console.log("执行操作fn")
          if (timer) clearTimeout(timer)
          const res = fn.apply(this, args)
          resolve(res)
          startTime = nowTime
          timer = null
          return
        } 

        // 3.判断是否需要执行尾部
        if (trailing &amp;&amp; !timer) {
          timer = setTimeout(() =&gt; {
            // console.log("执行timer")
            const res = fn.apply(this, args)
            resolve(res)
            startTime = new Date().getTime()
            timer = null
          }, waitTime);
        }
      } catch (error) {
        reject(error)
      }
    })
  }

  _throttle.cancel = function() {
    if (timer) clearTimeout(timer)
    startTime = 0
    timer = null
  }

  return _throttle
}</code></pre> 
 <p></p> 
 <p></p> 
 <p></p> 
 <pre><code class="language-html">&lt;body&gt;

  &lt;button&gt;按钮&lt;/button&gt;

  &lt;input type="text"&gt;
  &lt;button class="cancel"&gt;取消&lt;/button&gt;
  
  &lt;!-- CDN引入: 网络的js文件 --&gt;
  &lt;!-- &lt;script src="https://cdn.jsdelivr.net/npm/underscore@1.13.4/underscore-umd-min.js"&gt;&lt;/script&gt; --&gt;
  &lt;!-- 本地引入: 下载js文件, 并且本地引入 --&gt;
  &lt;script src="./js/underscore.js"&gt;&lt;/script&gt;
  &lt;script src="./js/hy_throttle.js"&gt;&lt;/script&gt;

  &lt;script&gt;
    // 1.获取input元素
    const inputEl = document.querySelector("input")
    const cancelBtn = document.querySelector(".cancel")

    // 2.underscore节流处理代码
    // let counter = 1
    // inputEl.oninput = _.throttle(function() {
    //   console.log(`发送网络请求${counter++}:`, this.value)
    // }, 1000)

    // 3.自己实现的节流函数
    let counter = 1
    const throttleFn = hythrottle(function(event) {
      console.log(`发送网络请求${counter++}:`, this.value, event)
      return "throttle return value"
    }, 3000)

    inputEl.oninput = throttleFn

  &lt;/script&gt;

&lt;/body&gt;</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2>深拷贝-和浅拷贝-引入赋值关系</h2> 
<blockquote> 
 <p>浅拷贝是把一个对象类型的值复制到另外一个对象里面，这两个对象值一样，但是各自修改值的时候不会出现引用赋值那样影响到另外一个对象值，也就是他们两个对象的内存地址不同，是两个不同的对象类型。</p> 
 <p>深拷贝是在浅拷贝的基础上能在对象里面的对象实现浅拷贝的情况。</p> 
 <p></p> 
 <p>深拷贝的第一种方法是利用JSON方法先转成字符串，在转为对象，就能把对象里面的对象转换成深拷贝对象。但是这种有个缺点就是，如果对象里面有函数或者[Symbol()]: "abc"，这种会被忽略掉，没办法获取；循环 的对象也不能用（window.window.window.window）。</p> 
 <p></p> 
 <pre><code class="language-javascript">  console.log(window.window === window)

    const info = {
      name: "why",
      age: 18,
      friend: {
        name: "kobe"
      },
      running: function() {},
      [Symbol()]: "abc",
      // obj: info
    }
    info.obj = info

    // 1.操作一: 引用赋值
    // const obj1 = info

    // 2.操作二: 浅拷贝
    // const obj2 = { ...info }
    // // obj2.name = "james"
    // // obj2.friend.name = "james"
    // // console.log(info.friend.name)

    // const obj3 = Object.assign({}, info)
    // // obj3.name = "curry"
    // obj3.friend.name = "curry"
    // console.log(info.friend.name)

    // 3.操作三: 深拷贝
    // 3.1.JSON方法
    // const obj4 = JSON.parse(JSON.stringify(info))
    // info.friend.name = "curry"
    // console.log(obj4.friend.name)
    // console.log(obj4)

    // 3.2.自己编写一个深拷贝函数(第三方库)</code></pre> 
</blockquote> 
<p></p> 
<p></p> 
<h2>深拷贝-深拷贝函数的基本使用</h2> 
<blockquote> 
 <p>判断是否是对象类型（这里没算函数和数组类型）的工具is_object.js</p> 
 <pre><code class="language-javascript">// 需求: 判断一个标识符是否是对象类型
function isObject(value) {
  // null,object,function,array
  // null -&gt; object
  // function -&gt; function -&gt; true
  // object/array -&gt; object -&gt; true
  const valueType = typeof value
  return (value !== null) &amp;&amp; ( valueType === "object" || valueType === "function" )
}

// const name = "why"
// const age = 18
// const foo = {}
// const bar = function() {}
// const arr = []

// console.log(isObject(null)) // false
// console.log(isObject(bar)) // true
// console.log(isObject(name)) // false
// console.log(isObject(foo)) // true
// console.log(isObject(arr)) // true
</code></pre> 
 <p>深拷贝对类型的核函数</p> 
 <p>这里拷贝的是对象里面有对象的情况</p> 
 <pre><code class="language-html">  &lt;script src="./js/is_object.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    // 深拷贝函数
    function deepCopy(originValue) {
      // 1.如果是原始类型, 直接返回
      if (!isObject(originValue)) {
        return originValue
      }

      // 2.如果是对象类型, 才需要创建对象
      const newObj = {}
      for (const key in originValue) {
        newObj[key] = deepCopy(originValue[key]);
      }
      return newObj
    }

    const info = {
      name: "why",
      age: 18,
      friend: {
        name: "kobe",
        address: {
          name: "洛杉矶",
          detail: "斯坦普斯中心"
        }
      }
    }

    const newObj = deepCopy(info)
    info.friend.address.name = "北京市"
    console.log(newObj.friend.address.name)

  &lt;/script&gt;
</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2>深拷贝-深拷贝函数的数组拷贝</h2> 
<blockquote> 
 <p>这里拷贝的是数组里面存在对象类型时的情况。</p> 
 <pre><code class="language-html">&lt;script src="./js/is_object.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    // 深拷贝函数
    function deepCopy(originValue) {
      // 1.如果是原始类型, 直接返回
      if (!isObject(originValue)) {
        return originValue
      }

      // 2.如果是对象类型, 才需要创建对象
      const newObj = Array.isArray(originValue) ? []: {}
      for (const key in originValue) {
        newObj[key] = deepCopy(originValue[key]);
      }
      return newObj
    }

    const books = [
      { name: "黄金时代", price: 28, desc: { intro: "这本书不错", info: "这本书讲了一个很有意思的故事" } },
      { name: "你不知道JavaScript", price: 99 },
    ]

    // const newBooks = [...books]
    // newBooks[0].price = 88
    // console.log(books[0].price)

    const newBooks = deepCopy(books)
    console.log(newBooks)

  &lt;/script&gt;
</code></pre> 
 <p></p> 
</blockquote> 
<h2>深拷贝-深拷贝函数的其他类型</h2> 
<blockquote> 
 <p>特殊类型的set、function、symbol类型的情况</p> 
 <pre><code class="language-html"> &lt;script src="./js/is_object.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    // 深拷贝函数
    function deepCopy(originValue) {
      // 0.如果值是Symbol的类型
      if (typeof originValue === "symbol") {
        return Symbol(originValue.description)
      }

      // 1.如果是原始类型, 直接返回
      if (!isObject(originValue)) {
        return originValue
      }

      // 2.如果是set类型
      if (originValue instanceof Set) {
        const newSet = new Set()
        for (const setItem of originValue) {
          newSet.add(deepCopy(setItem))
        }
        return newSet
      }

      // 3.如果是函数function类型, 不需要进行深拷贝
      if (typeof originValue === "function") {
        return originValue
      }

      // 2.如果是对象类型, 才需要创建对象
      const newObj = Array.isArray(originValue) ? []: {}
      // 遍历普通的key
      for (const key in originValue) {
        newObj[key] = deepCopy(originValue[key]);
      }
      // 单独遍历symbol
      const symbolKeys = Object.getOwnPropertySymbols(originValue)
      for (const symbolKey of symbolKeys) {
        newObj[Symbol(symbolKey.description)] = deepCopy(originValue[symbolKey])
      }

      return newObj
    }

    const set = new Set(["abc", "cba", "nba"])
    const s1 = Symbol("s1")
    const s2 = Symbol("s2")
    const info = {
      name: "why",
      age: 18,
      friend: {
        name: "kobe",
        address: {
          name: "洛杉矶",
          detail: "斯坦普斯中心"
        }
      },

      // 1.特殊类型: Set
      set: set,

      // 2.特性类型: function
      running: function() {
        console.log("running~")
      },

      // 3.值的特殊类型: Symbol
      symbolKey: Symbol("abc"),

      // 4.key是symbol时
      [s1]: "aaaa",
      [s2]: "bbbb"
    }

    // for (let key in info) {
    //   console.log(key)
    // }

    // const symbol = Symbol()
    // console.log(typeof symbol)
    // console.log(isObject(symbol))

    const newObj = deepCopy(info)
    console.log(newObj)

  &lt;/script&gt;
</code></pre> 
 <p></p> 
</blockquote> 
<h2>深拷贝-深拷贝函数的循环引用</h2> 
<blockquote> 
 <p>如果对象类型里面的变量有对自己的引用，那就回出错，无线循环报错。</p> 
 <p><img alt="" height="363" src="https://images2.imgbox.com/fa/19/iGgeo7ij_o.png" width="593"></p> 
 <p></p> 
 <p></p> 
 <p><img alt="" height="241" src="https://images2.imgbox.com/e9/50/8UiFO1lH_o.png" width="649"></p> 
 <p></p> 
 <pre><code class="language-html">&lt;script src="./js/is_object.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    // 深拷贝函数
    // let map = new WeakMap()
    function deepCopy(originValue, map = new WeakMap()) {
      // const map = new WeakMap()

      // 0.如果值是Symbol的类型
      if (typeof originValue === "symbol") {
        return Symbol(originValue.description)
      }

      // 1.如果是原始类型, 直接返回
      if (!isObject(originValue)) {
        return originValue
      }

      // 2.如果是set类型
      if (originValue instanceof Set) {
        const newSet = new Set()
        for (const setItem of originValue) {
          newSet.add(deepCopy(setItem))
        }
        return newSet
      }

      // 3.如果是函数function类型, 不需要进行深拷贝
      if (typeof originValue === "function") {
        return originValue
      }

      // 4.如果是对象类型, 才需要创建对象
      if (map.get(originValue)) {
        return map.get(originValue)
      }
      const newObj = Array.isArray(originValue) ? []: {}
      map.set(originValue, newObj)
      // 遍历普通的key
      for (const key in originValue) {
        newObj[key] = deepCopy(originValue[key], map);
      }
      // 单独遍历symbol
      const symbolKeys = Object.getOwnPropertySymbols(originValue)
      for (const symbolKey of symbolKeys) {
        newObj[Symbol(symbolKey.description)] = deepCopy(originValue[symbolKey], map)
      }

      return newObj
    }

    const info = {
      name: "why",
      age: 18,
      friend: {
        name: "kobe",
        address: {
          name: "洛杉矶",
          detail: "斯坦普斯中心"
        }
      },
      // self: info
    }
    info.self = info

    let newObj = deepCopy(info)
    console.log(newObj)
    console.log(newObj.self === newObj)


    // mitt
  &lt;/script&gt;</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2>事件总线-事件总线实现</h2> 
<blockquote> 
 <p>跨文件、组件组件的通信使用。</p> 
 <p></p> 
 <pre><code class="language-html">&lt;body&gt;

  &lt;button class="nav-btn"&gt;nav button&lt;/button&gt;
  
  &lt;script&gt;

    // 类EventBus -&gt; 事件总线对象
    class HYEventBus {
      constructor() {
        this.eventMap = {}
      }

      on(eventName, eventFn) {
        let eventFns = this.eventMap[eventName]
        if (!eventFns) {
          eventFns = []
          this.eventMap[eventName] = eventFns
        }
        eventFns.push(eventFn)
      }
      
      off(eventName, eventFn) {
        let eventFns = this.eventMap[eventName]
        if (!eventFns) return
        for (let i = 0; i &lt; eventFns.length; i++) {
          const fn = eventFns[i]
          if (fn === eventFn) {
            eventFns.splice(i, 1)
            break
          }
        }

        // 如果eventFns已经清空了
        if (eventFns.length === 0) {
          delete this.eventMap[eventName]
        }
      }

      emit(eventName, ...args) {
        let eventFns = this.eventMap[eventName]
        if (!eventFns) return
        eventFns.forEach(fn =&gt; {
          fn(...args)
        })
      }
    }


    // 使用过程
    const eventBus = new HYEventBus()

    // aside.vue组件中监听事件
    eventBus.on("navclick", (name, age, height) =&gt; {
      console.log("navclick listener 01", name, age, height)
    })

    const click =  () =&gt; {
      console.log("navclick listener 02")
    }
    eventBus.on("navclick", click)

    setTimeout(() =&gt; {
      eventBus.off("navclick", click)
    }, 5000);

    eventBus.on("asideclick", () =&gt; {
      console.log("asideclick listener")
    })


    // nav.vue
    const navBtnEl = document.querySelector(".nav-btn")
    navBtnEl.onclick = function() {
      console.log("自己监听到")
      eventBus.emit("navclick", "why", 18, 1.88)
    }

  &lt;/script&gt;

&lt;/body&gt;</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<p></p> 
<p><img alt="" height="622" src="https://images2.imgbox.com/2d/1b/C7UJjtd5_o.png" width="1028"></p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/f0/0a/JizB386s_o.png" width="1102"></p> 
<p><img alt="" height="626" src="https://images2.imgbox.com/2e/07/92ep4k8Z_o.png" width="1130"></p> 
<p><img alt="" height="613" src="https://images2.imgbox.com/44/53/jGubobn0_o.png" width="1011"></p> 
<p><img alt="" height="630" src="https://images2.imgbox.com/87/80/k0ov1Oie_o.png" width="928"></p> 
<p><img alt="" height="565" src="https://images2.imgbox.com/66/4b/ijgH9zg2_o.png" width="1136"></p> 
<p><img alt="" height="611" src="https://images2.imgbox.com/94/a0/ltdHiiIS_o.png" width="1110"></p> 
<p><img alt="" height="613" src="https://images2.imgbox.com/a9/e4/Rt43tTTT_o.png" width="1139"></p> 
<p><img alt="" height="514" src="https://images2.imgbox.com/5b/c1/33ygorbO_o.png" width="1087"></p> 
<p><img alt="" height="601" src="https://images2.imgbox.com/29/87/p09CNbc9_o.png" width="787"></p> 
<p><img alt="" height="619" src="https://images2.imgbox.com/c5/a2/WnqFIYJU_o.png" width="910"></p> 
<p><img alt="" height="598" src="https://images2.imgbox.com/86/1b/cG4DVl0R_o.png" width="900"></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/98415e73c2182e915df9e6029c271703/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">分享100多个面向开发人员的免费现代化网站模板，总有一款适合你</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4be147f3f85d43ebb287360f2d85b975/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java - List 对于 stream 的简单操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>