<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编码方式的简介(ASCII, LATIN-1, UTF-8/16/32) - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="编码方式的简介(ASCII, LATIN-1, UTF-8/16/32)" />
<meta property="og:description" content="编码方式的简介
1. ASCII
ASCII是7比特的字符集，涵盖了英语中的绝大多数字符。编码从0到127.
2. ISOLatin-1(the ISO-8859-1 standard)
ISO Latin-1是8比特的字符集，定义了256个字符。前128个字符(00000000-01111111)与ASCII完全一致。
3. Unicode
Unicode只是定义了字符的编码值，并未指定值以何种形式存储。比如汉字“田”的Unicode编码是16进制的7530，转换为二进制是01110101,00110000。比方现在定义一种unicode的实现方式UTF-FAKE，规则是
a. 使用24个字节
b. 每个字节的高7位都是1
c. 每个字节的最末一位存储unicode编码值
那么01110101,00110000的存储形式是
11111110, 11111110, 11111110, 11111110, 11111110, 11111110, 11111110, 11111110,
11111110, 11111111, 11111111, 11111111, 11111110, 11111111, 11111110, 11111111, 11111110, 11111110, 11111111, 11111111, 11111110, 11111110, 11111110, 11111110
其中末位为蓝色0的字节为补足字节。
实际使用的编码方式UTF-8使用三个字节存储“田” 01110101,00110000，如下
11100111, 10010100, 10110000
Unicode的第一个版本于1991年发布，该版本允许的的最大编码空间是两个字节。96年发布的Unicode 2.0版本引入了surrogate pair，将Unicode的编码数目扩充到了百万级，由于可见的将来该数目不大可能用光，因此Unicode委员会对外宣称该上限永不会更改。Surrogate pair在UTF-16和UTF-32中得到了实现。Unicode的前256个字符及编码值与Latin-1完全一致。比如大写字母A在Latin-1和Unicode中的编码值都是0x41（十进制的65）。
Unicode的编码值范围是 000000hex 到10FFFFhex，可划分为17个plane，每个plane包含65536(= 216)个字符。Plane的代码从0到16（十进制），对应于 000000hex，010000hex，020000hex，… … ，0F0000hex，10FFFFhex的蓝色部分。
Unicode的表示方式一般是”U&#43;”后缀上4到6个十六进制字符，如”田“的Unicode表示方式是U&#43;7530。
4. UTF-8
UTF-8采用可变长度的编码，长度从1到4个字节不等。某些应用识别非标准的&#34;utf8&#34; 或&#34;UTF 8&#34;别名。只有ASCII字符在UTF-8中使用一个字节编码，且值与ASCII完全相同，其余字符在UTF-8中使用2到4个字节。因此UTF-8中的单字节且只有单字节编码字符的最高的1个比特是0。
UTF-8对Unicode字符的编码规则如下
Bits of" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/fcb4464fb55248ce441d1c5b5f908c49/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-12-30T14:58:27+08:00" />
<meta property="article:modified_time" content="2013-12-30T14:58:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">编码方式的简介(ASCII, LATIN-1, UTF-8/16/32)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p>编码方式的简介</p> 
<p><strong>1. ASCII</strong></p> 
<p>ASCII是7比特的字符集，涵盖了英语中的绝大多数字符。编码从0到127.</p> 
<p><strong>2. ISOLatin-1(the ISO-8859-1 standard)</strong></p> 
<p>ISO Latin-1是8比特的字符集，定义了256个字符。前128个字符(00000000-01111111)与ASCII完全一致。</p> 
<p> </p> 
<p><strong>3. Unicode</strong></p> 
<p>Unicode只是定义了字符的编码值，并未指定值以何种形式存储。比如汉字“田”的Unicode编码是16进制的7530，转换为二进制是<span style="color:#FF0000;">01110101,00110000</span>。比方现在定义一种unicode的实现方式UTF-FAKE，规则是</p> 
<p>a.      使用24个字节</p> 
<p>b.      每个字节的高7位都是1</p> 
<p>c.      每个字节的最末一位存储unicode编码值</p> 
<p>那么01110101,00110000的存储形式是</p> 
<p>1111111<span style="color:#4472c4;">0</span>, 1111111<span style="color:#4472c4;">0</span>, 1111111<span style="color:#4472c4;">0</span>, 1111111<span style="color:#4472c4;">0</span>, 1111111<span style="color:#4472c4;">0</span>, 1111111<span style="color:#4472c4;">0</span>, 1111111<span style="color:#4472c4;">0</span>, 1111111<span style="color:#4472c4;">0</span>,</p> 
<p>1111111<span style="color:#FF0000;">0</span>, 1111111<span style="color:#FF0000;">1</span>, 1111111<span style="color:#FF0000;">1</span>, 1111111<span style="color:#FF0000;">1</span>, 1111111<span style="color:#FF0000;">0</span>, 1111111<span style="color:#FF0000;">1</span>, 1111111<span style="color:#FF0000;">0</span>, 1111111<span style="color:#FF0000;">1</span>, </p> 
<p>1111111<span style="color:#FF0000;">0</span>, 1111111<span style="color:#FF0000;">0</span>, 1111111<span style="color:#FF0000;">1</span>, 1111111<span style="color:#FF0000;">1</span>, 1111111<span style="color:#FF0000;">0</span>, 1111111<span style="color:#FF0000;">0</span>, 1111111<span style="color:#FF0000;">0</span>, 1111111<span style="color:#FF0000;">0</span></p> 
<p>其中末位为蓝色<span style="color:#4472c4;">0</span>的字节为补足字节。</p> 
<p>实际使用的编码方式UTF-8使用三个字节存储“田”<span style="color:#0070c0;"> 0111</span><span style="color:#FF0000;">0101,00</span><span style="color:#00b050;">110000</span>，如下</p> 
<p>1110<span style="color:#0070c0;">0111</span>, 10<span style="color:#FF0000;">010100</span>, 10<span style="color:#00b050;">110000</span></p> 
<p><span style="color:#00b050;"> </span></p> 
<p>Unicode的第一个版本于1991年发布，该版本允许的的最大编码空间是两个字节。96年发布的Unicode 2.0版本引入了surrogate pair，将Unicode的编码数目扩充到了百万级，由于可见的将来该数目不大可能用光，因此Unicode委员会对外宣称该上限永不会更改。Surrogate pair在UTF-16和UTF-32中得到了实现。Unicode的前256个字符及编码值与Latin-1完全一致。比如大写字母A在Latin-1和Unicode中的编码值都是0x41（十进制的65）。</p> 
<p>Unicode的编码值范围是 <strong><span style="color:#0070c0;">00</span></strong>0000<strong>hex </strong>到<strong><span style="color:#0070c0;">10</span></strong>FFFF<strong>hex</strong>，可划分为17个plane，每个plane包含65536(= 216)个字符。Plane的代码从0到16（十进制），对应于 <strong><span style="color:#0070c0;">00</span></strong>0000<strong>hex</strong>，<strong><span style="color:#0070c0;">01</span></strong>0000<strong>hex</strong>，<strong><span style="color:#0070c0;">02</span></strong>0000<strong>hex</strong>，<strong><span style="color:#0070c0;">… … </span></strong>，<strong><span style="color:#0070c0;">0F</span></strong>0000<strong>hex</strong>，<strong><span style="color:#0070c0;">10</span></strong>FFFF<strong>hex</strong>的蓝色部分。</p> 
<p>Unicode的表示方式一般是”U+”后缀上4到6个十六进制字符，如”田“的Unicode表示方式是U+7530。</p> 
<p> </p> 
<p><strong>4. UTF-8</strong></p> 
<p>UTF-8采用可变长度的编码，长度从1到4个字节不等。某些应用识别非标准的"utf8" 或"UTF 8"别名。只有ASCII字符在UTF-8中使用一个字节编码，且值与ASCII完全相同，其余字符在UTF-8中使用2到4个字节。因此UTF-8中的单字节且只有单字节编码字符的最高的1个比特是0。</p> 
<p>UTF-8对Unicode字符的编码规则如下</p> 
<p> </p> 
<table border="0" cellpadding="0"><tbody><tr><td> <p><strong>Bits of<br> code point</strong></p> </td><td> <p><strong>First<br> code point</strong></p> </td><td> <p><strong>Last<br> code point</strong></p> </td><td> <p><strong>Bytes in<br> sequence</strong></p> </td><td> <p><strong>Byte 1</strong></p> </td><td> <p><strong>Byte 2</strong></p> </td><td> <p><strong>Byte 3</strong></p> </td><td> <p><strong>Byte 4</strong></p> </td></tr><tr><td> <p><strong>  7</strong></p> </td><td> <p>U+0000</p> </td><td> <p>U+007F</p> </td><td> <p>1</p> </td><td> <p><code>0xxxxxxx</code></p> </td></tr><tr><td> <p><strong>11</strong></p> </td><td> <p>U+0080</p> </td><td> <p>U+07FF</p> </td><td> <p>2</p> </td><td> <p><code>110xxxxx</code></p> </td><td> <p><code>10xxxxxx</code></p> </td></tr><tr><td> <p><strong>16</strong></p> </td><td> <p>U+0800</p> </td><td> <p>U+FFFF</p> </td><td> <p>3</p> </td><td> <p><code>1110xxxx</code></p> </td><td> <p><code>10xxxxxx</code></p> </td><td> <p><code>10xxxxxx</code></p> </td></tr><tr><td> <p><strong>21</strong></p> </td><td> <p>U+10000</p> </td><td> <p>U+1FFFFF</p> </td><td> <p>4</p> </td><td> <p><code>11110xxx</code></p> </td><td> <p><code>10xxxxxx</code></p> </td><td> <p><code>10xxxxxx</code></p> </td><td> <p><code>10xxxxxx</code></p> </td></tr></tbody></table> 
<p> </p> 
<p>说明如下：</p> 
<p>1.   只有ASCII使用单字节编码</p> 
<p>2.   Unicode编码值大于127的字符使用多个字节编码。多字节序列的第一个字节称为leading byte，后续的字节称为continuation bytes。Leading byte的高位是110，1110或11110，其中的“1”的个数标明了序列中的字节总数。如2个字节序列的leading byte为<code><strong><span style="color:#FF0000;">11</span></strong></code><code>0xxxxx</code>，其中的<code><strong><span style="color:#FF0000;">11</span></strong></code>标明了这是一个双字节的序列，亦即该序列有1个continuation byte。Continuation bytes的每个字节的高两位均是<strong><span style="color:#FF0000;">10</span></strong>。</p> 
<p>3.  <strong>单字节序列、leading bytes和continuationbytes的高位分别是0，110/1110/11110和10，因此不会混淆。</strong></p> 
<p>还是以汉字”田“为例，展示Unicode字符如何按照UTF-8存储。”田“的Unicode值是U+7530，比对上表发现介于U+0800 - U+FFFF之间，因此需要3个字节来存储。7530转为二进制是1110101,00110000，一共15位。但由于UTF-8的3字节编码存储16个比特，因此将1110101,00110000的高一位补零变成16比特<strong><span style="color:#00b050;">0111</span><span style="color:#00b0f0;">0101,00</span><span style="color:#7030a0;">110000</span></strong>。然后将这16比特依次填入三字节序列1110xxxx 10xxxxxx 10xxxxxx的x中，得到结果</p> 
<p>1110<strong><span style="color:#00b050;">0111</span></strong> 10<strong><span style="color:#00b0f0;">010100</span></strong> 10<strong><span style="color:#7030a0;">110000</span></strong>，写成16进制就是E7 94 B0</p> 
<p><strong>注意</strong>：虽然Unicode中的前256个字符及编码值与Latin-1完全一致，但UTF-8只对前128个即ASCII字符采用单字节编码，其余128个Latin-1字符是采用2个字节编码。因此ASCII编码的文件可以直接以UTF-8方式读取，而Latin-1的文件若包含值为128-255的字符则不可以。</p> 
<p><strong>5. UTF-16</strong></p> 
<p>UTF-16也是采用可变长度编码，可以是一个或者两个16比特。某些应用中允许使用非标准的UTF_16或者UTF16作为别名。Unicode中的第一个plane的65536(= 216)codepoints采用16比特编码，其余的16个plane均采用2个16比特编码。采用2个16比特编码的前后两个16bit分别称为lead surrogate pair和trail surrogate pair，之所以称为surrogate是因为单独一个16bit不代表任何字符，只有组合起来才有意义。</p> 
<p>既然UTF-16也是可变长度编码，如何区分某个16bit是单独表示一个字符还是与后续的16bit组合起来表示一个字符呢？Unicode将D800–DBFF和DC00–DFFF这两个范围作为保留区间，没有将之分配给任何Unicode字符，若某16比特落在D800–DBFF范围内，便可将之视为采用2个16bit编码字符的第一个16bit，而落在DC00–DFFF的16bit可视为采用2个16bit编码字符的第二个16bit。这就使得Unicode第一个plane实际可分配使用的code points只有65536 – (DFFF - D800 + 1) = 65536 – 8*256 = 63488。</p> 
<p>采用一个16bit编码的Unicode字符在UTF-16中的编码值与其在Unicode中是相等的，比如英文大写字母A的Unicode值是U+0041，其UTF-16编码是0041 hex 。Unicode第二到第十七个plane采用两个16bit即surrogate pairs的字符从其Unicode code point到UTF-16的转换规则是</p> 
<p>1.  范围为0x10000 … 0x10FFFF的codepoint减去0x010000，减过后的结果范围是0x00000到0xFFFFF，使得该结果可以使用5位16进制亦即20位2进制数表示</p> 
<p>2.  结果中高10位（范围是0x0到0x3FF）加上0xD800（结果范围是0xD800到0xDBFF）作为双16bit的第一个16bit即leadsurrogate</p> 
<p>3.  结果中低10位（范围是0x0到0x3FF）加上0xDC00（结果范围是0xDC00到0xDFFF）作为双16bit的第二个16bit即trailsurrogate</p> 
<p> </p> 
<p>这样UTF-16与UTF-8都是self-synchronizing的，即某个16bit是否是一个字符的开始无需检查其前一个或者后一个16bit。与UTF-8的不同之处是，UTF-16不支持从某个随机的<strong><span style="color:#FF0000;">字节</span></strong>开始读取。</p> 
<p>举例：UTF-16 序列 0041, D801DC01 (字符"A<img alt="" src="https://images2.imgbox.com/1d/30/hD6jOttH_o.png">")，若第一个字节丢失即从第二个字节读取，那么UTF-16认为序列是41D8,01DC,01；而UTF-8不存在这个问题。</p> 
<p> </p> 
<p><strong>BOM(byte-order mark)</strong></p> 
<p>BOM是Unicode中用来标识字节顺序的字符。</p> 
<p>对于UTF16和UTF32，由于编码单元分别是16bit和32bit，即2个和4个字节，编码单元内字节的顺序就取决于计算机的体系结构。以英文大写字母A和汉字田为例，大端（big endianness，缩写为BE）和小端（littleendianness，缩写为LE）存储的字节序列是</p> 
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td style="vertical-align:top;"> <p> </p> </td><td style="vertical-align:top;"> <p>UTF-16BE</p> </td><td style="vertical-align:top;"> <p>UTF-16LE</p> </td><td style="vertical-align:top;"> <p>UTF-32BE</p> </td><td style="vertical-align:top;"> <p>UTF-32BE</p> </td></tr><tr><td style="vertical-align:top;"> <p>A</p> </td><td style="vertical-align:top;"> <p>00,41</p> </td><td style="vertical-align:top;"> <p>41,00</p> </td><td style="vertical-align:top;"> <p>00,00,00,41</p> </td><td style="vertical-align:top;"> <p>41,00,00,00</p> </td></tr><tr><td style="vertical-align:top;"> <p>田</p> </td><td style="vertical-align:top;"> <p>75,30</p> </td><td style="vertical-align:top;"> <p>30,75</p> </td><td style="vertical-align:top;"> <p>00,00,75,30</p> </td><td style="vertical-align:top;"> <p>30,75,00,00</p> </td></tr></tbody></table> 
<p> </p> 
<p>BOM就是用来标识编码使用的是大端还是小端存储，该符号位于文本序列起始字节之前。</p> 
<p> </p> 
<p><strong>UTF-8</strong></p> 
<p>UTF-8中的BOM是 <strong>0xEF,0xBB,0xBF</strong>。Unicode标准里面允许UTF-8使用BOM，但并不要求也不鼓励使用。由于UTF8编码单位是字节，字节的先后顺序在编码、传输和解码过程中均不改变，因此不存在endianness。BOM在UTF8中的唯一作用是标识序列使用的是UTF8编码，在由其它使用BOM的编码转换为UTF8编码的情况下，建议在UTF8序列中保留BOM以便转换回原编码的时候不丢失BOM信息。</p> 
<p> </p> 
<p>接下来看看用Notepad++的HEX-Editor插件查看的文件16进制的编码。</p> 
<p>文件中仅包含一个英文大写字母A，其Unicode编码值是U+0041。</p> 
<p>使用UTF-8(缺省包含BOM)，字节序列是<strong>ef bb bf 41</strong></p> 
<p>  </p> 
<p> </p> 
<p>  <img alt="" src="https://images2.imgbox.com/2b/a9/uFCHFzU4_o.png"><img alt="" src="https://images2.imgbox.com/29/4d/JSVIHbB7_o.png"></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>使用不带BOM的UTF-8，字节序列是 41。</p> 
<p> </p> 
<p> </p> 
<p>  <img alt="" src="https://images2.imgbox.com/4f/21/NQYporEq_o.png"><img alt="" src="https://images2.imgbox.com/b5/3f/7yNevZuG_o.png"></p> 
<p> </p> 
<p> </p> 
<h4>UTF-16</h4> 
<p>UTF-16中bigendianness和littleendianness的BOM分别是U+FEFF和U+FFFE。可以使用编码方式UTF-16BE和UTF-16LE来显式地标明字节顺序，当使用了UTF-16BE和UTF-16LE时，BOM不应该再出现在字节序列中，很多应用直接忽略该字符若其仍然存在。</p> 
<p>由于Notepad++不支持UTF16编码，因此下面的截图中使用了UTF-16的前身UCS-2来替代。UCS-2对Unicode的第一个plane的编码与UTF-16相同，都是1个16bit，且编码结果相同。</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p><img alt="" src="https://images2.imgbox.com/df/e7/cPk2wrAI_o.png"><img alt="" src="https://images2.imgbox.com/f9/c0/sXyKXxkb_o.png"><img alt="" src="https://images2.imgbox.com/b8/f9/wQvVDLdW_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/58/47/NMuMvV8j_o.png"></p> 
<p> </p> 
<p><strong>UTF-32</strong></p> 
<p>UTF32中的bigendianness和littleendianness的BOM分别是0000FEFF和FFFE0000。</p> 
<p> </p> 
<p>总结五种编码方式的BOM依次是</p> 
<p> </p> 
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td> <p><strong><span style="color:#808080;">BOM</span></strong></p> </td><td> <p><strong><span style="color:#808080;">编码方式</span></strong></p> </td></tr><tr><td> <p>00 00 FE FF</p> </td><td> <p>UTF-32, big-endian</p> </td></tr><tr><td> <p>FF FE 00 00</p> </td><td> <p>UTF-32, little-endian</p> </td></tr><tr><td> <p>FE FF</p> </td><td> <p>UTF-16, big-endian</p> </td></tr><tr><td> <p>FF FE</p> </td><td> <p>UTF-16, little-endian</p> </td></tr><tr><td> <p>EF BB BF</p> </td><td> <p>UTF-8</p> </td></tr></tbody></table> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4dffc0e5223f8cda7f9801362bbdadc4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ubuntu 12.04L 配置android</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fb9debb7627eaaf2b363d943892254bb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CoAP协议学习——CoAP基础</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>