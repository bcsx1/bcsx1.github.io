<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>docker的使用方法 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="docker的使用方法" />
<meta property="og:description" content="文章目录 为什么要用dockerdocker安装docker工作原理docker命令docker搭建练习docker可视化docker镜像docker容器数据卷DockerFiledocker全流程Docker网络原理docker composedocker swarm 为什么要用docker 官网：https://www.docker.com文档地址：https://docs.docker.com仓库地址：https://hub.docker.com 一款产品:
开发：开发环境 — 开发人员
上线：应用环境，应用配置 — 运维人员
传统方法：开发人员打包好应用程序，剩下的交给运维
问题：
环境不同，版本更新，端口冲突等导致服务不可用，这对于运维来说，考验很大环境配置费时费力 现在方法：开发打包部署上线，一套流程做完
docker解决了上面的问题：
打包项目带上环境（镜像） -&gt; docker仓库 -&gt; 下载发布的镜像 -&gt; 直接运行即可
docker核心思想：
隔离：打包装箱，每个容器时相互隔离的
优点： 使得容器之间不会相互影响通过隔离机制，使得某个容器能使用的资源被限制，这样可以节省设备资源，使得设备资源被利用到极致 docker与虚拟机的联系与区别：
虚拟机：例如VMware，通过这个软件我们可以虚拟出来多台电脑，缺点是十分笨重docker：使用了容器技术，也是一种虚拟化技术，但是十分轻巧 假设需要使用一台linux机器
VMware：导入linux镜像（一台电脑）。隔离：需要开启多个虚拟机docker：隔离：镜像（最核心的环境(约4M大小) &#43; 项目需要的运行环境） 传统虚拟机：虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件docker：容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有我们虚拟的硬件，所以就轻便了 docker为什么比VM快：
docker有着比虚拟机更少的抽象层
docker利用的是宿主机的内核，vm需要的是Guest OS。所以说，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免启动引导程序。
docker的好处：
应用更快速的交付和部署更便捷的升级和扩缩容更简单的系统运维更高效的计算资源利用 docker安装 docker的基本组成：
客户端（client）服务器（docker_host）仓库（registry）
镜像（image）：docker镜像就好比一个模板，可以通过这个模板来创建多个容器。容器（Container）：docker利用容器技术，独立运行一个或者一个组应用，通过镜像来创建的。相当于一个小型linux系统。 基本命令：启动，停止，删除可以将这个容器理解为一个简易的linux系统 仓库（repository）：存放镜像的地方。仓库分为公有仓库和私有仓库： docker hub（国外）阿里云，华为云等 安装docker
环境准备
linux基础ubuntu22.04 环境查看
uname -r #确定内核在3.0以上 cat /etc/os-release # 查看操作系统信息 安装
帮助文档：https://www.runoob.com/docker/ubuntu-docker-install.html
卸载旧版本 sudo apt-get remove docker docker-engine docker." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/deffa6fbd3fa2e310963fc746238fc95/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-24T09:15:53+08:00" />
<meta property="article:modified_time" content="2023-11-24T09:15:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">docker的使用方法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#docker_2" rel="nofollow">为什么要用docker</a></li><li><a href="#docker_52" rel="nofollow">docker安装</a></li><li><a href="#docker_140" rel="nofollow">docker工作原理</a></li><li><a href="#docker_145" rel="nofollow">docker命令</a></li><li><a href="#docker_224" rel="nofollow">docker搭建练习</a></li><li><a href="#docker_279" rel="nofollow">docker可视化</a></li><li><a href="#docker_290" rel="nofollow">docker镜像</a></li><li><a href="#docker_313" rel="nofollow">docker容器数据卷</a></li><li><a href="#DockerFile_376" rel="nofollow">DockerFile</a></li><li><a href="#docker_487" rel="nofollow">docker全流程</a></li><li><a href="#Docker_489" rel="nofollow">Docker网络原理</a></li><li><a href="#docker_compose_571" rel="nofollow">docker compose</a></li><li><a href="#docker_swarm_638" rel="nofollow">docker swarm</a></li></ul> 
</div> 
<p></p> 
<h2><a id="docker_2"></a>为什么要用docker</h2> 
<ul><li>官网：<a href="https://www.docker.com" rel="nofollow">https://www.docker.com</a></li><li>文档地址：<a href="https://docs.docker.com" rel="nofollow">https://docs.docker.com</a></li><li>仓库地址：<a href="https://hub.docker.com" rel="nofollow">https://hub.docker.com</a></li></ul> 
<p>一款产品:</p> 
<blockquote> 
 <p>开发：开发环境 — 开发人员<br> 上线：应用环境，应用配置 — 运维人员</p> 
</blockquote> 
<blockquote> 
 <p>传统方法：开发人员打包好应用程序，剩下的交给运维</p> 
 <p>问题：</p> 
 <ol><li>环境不同，版本更新，端口冲突等导致服务不可用，这对于运维来说，考验很大</li><li>环境配置费时费力</li></ol> 
 <p>现在方法：开发打包部署上线，一套流程做完</p> 
</blockquote> 
<p>docker解决了上面的问题：</p> 
<blockquote> 
 <p>打包项目带上环境（镜像） -&gt; docker仓库 -&gt; 下载发布的镜像 -&gt; 直接运行即可</p> 
</blockquote> 
<p>docker核心思想：</p> 
<blockquote> 
 <p>隔离：打包装箱，每个容器时相互隔离的</p> 
 <ul><li>优点：</li></ul> 
 <ol><li>使得容器之间不会相互影响</li><li>通过隔离机制，使得某个容器能使用的资源被限制，这样可以节省设备资源，使得设备资源被利用到极致</li></ol> 
</blockquote> 
<p>docker与虚拟机的联系与区别：</p> 
<blockquote> 
 <ul><li>虚拟机：例如VMware，通过这个软件我们可以虚拟出来多台电脑，缺点是十分笨重</li><li>docker：使用了容器技术，也是一种虚拟化技术，但是十分轻巧</li></ul> 
</blockquote> 
<blockquote> 
 <p>假设需要使用一台linux机器</p> 
 <ul><li>VMware：导入linux镜像（一台电脑）。隔离：需要开启多个虚拟机</li><li>docker：隔离：镜像（最核心的环境(约4M大小) + 项目需要的运行环境）</li></ul> 
</blockquote> 
<blockquote> 
 <ul><li>传统虚拟机：虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</li><li>docker：容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有我们虚拟的硬件，所以就轻便了</li></ul> 
</blockquote> 
<blockquote> 
 <p>docker为什么比VM快：</p> 
 <ol><li> <p>docker有着比虚拟机更少的抽象层<br> <img src="https://images2.imgbox.com/7e/a3/6OUExTKb_o.png" alt="在这里插入图片描述"></p> </li><li> <p>docker利用的是宿主机的内核，vm需要的是Guest OS。所以说，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免启动引导程序。</p> </li></ol> 
</blockquote> 
<p>docker的好处：</p> 
<blockquote> 
 <ol><li>应用更快速的交付和部署</li><li>更便捷的升级和扩缩容</li><li>更简单的系统运维</li><li>更高效的计算资源利用</li></ol> 
</blockquote> 
<h2><a id="docker_52"></a>docker安装</h2> 
<ul><li> <p>docker的基本组成：</p> 
  <blockquote> 
   <ul><li>客户端（client）</li><li>服务器（docker_host）</li><li>仓库（registry）<br> <img src="https://images2.imgbox.com/4e/0c/u415eZhs_o.png" alt="在这里插入图片描述"></li></ul> 
  </blockquote> 
  <blockquote> 
   <ul><li>镜像（image）：docker镜像就好比一个模板，可以通过这个模板来创建多个容器。</li><li>容器（Container）：docker利用容器技术，独立运行一个或者一个组应用，通过镜像来创建的。相当于一个小型linux系统。</li></ul> 
   <blockquote> 
    <ul><li>基本命令：启动，停止，删除</li><li>可以将这个容器理解为一个简易的linux系统</li></ul> 
   </blockquote> 
   <ul><li>仓库（repository）：存放镜像的地方。仓库分为公有仓库和私有仓库：</li></ul> 
   <blockquote> 
    <ul><li>docker hub（国外）</li><li>阿里云，华为云等</li></ul> 
   </blockquote> 
  </blockquote> </li><li> <p>安装docker</p> 
  <ol><li> <p>环境准备</p> 
    <blockquote> 
     <ul><li>linux基础</li><li>ubuntu22.04</li></ul> 
    </blockquote> </li><li> <p>环境查看</p> <pre><code class="prism language-shell"><span class="token function">uname</span> <span class="token parameter variable">-r</span> <span class="token comment">#确定内核在3.0以上</span>
<span class="token function">cat</span> /etc/os-release <span class="token comment"># 查看操作系统信息</span>
</code></pre> </li><li> <p>安装</p> <p>帮助文档：<a href="https://www.runoob.com/docker/ubuntu-docker-install.html" rel="nofollow">https://www.runoob.com/docker/ubuntu-docker-install.html</a></p> 
    <blockquote> 
     <ol><li>卸载旧版本</li></ol> 
     <pre><code class="prism language-shell"><span class="token function">sudo</span> <span class="token function">apt-get</span> remove <span class="token function">docker</span> docker-engine docker.io containerd runc
</code></pre> 
     <ol start="2"><li>安装需要的包</li></ol> 
     <pre><code class="prism language-shell"><span class="token function">sudo</span> <span class="token function">apt-get</span> update
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> apt-transport-https ca-certificates <span class="token function">curl</span> gnupg-agent software-properties-common
</code></pre> 
     <ol start="3"><li>设置仓库</li></ol> 
     <pre><code class="prism language-shell"><span class="token comment"># 添加Docker的官方GPG密钥</span>
<span class="token function">curl</span> <span class="token parameter variable">-fsSL</span> https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg <span class="token operator">|</span> <span class="token function">sudo</span> apt-key <span class="token function">add</span> -
</code></pre> 
     <pre><code class="prism language-shell"><span class="token comment"># 验证是否拥有带指纹的密钥</span>
<span class="token function">sudo</span> apt-key fingerprint 0EBFCD88
</code></pre> 
     <pre><code class="prism language-shell"><span class="token comment"># 设置稳定版仓库</span>
<span class="token function">sudo</span> add-apt-repository <span class="token punctuation">\</span>
<span class="token string">"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \
<span class="token variable"><span class="token variable">$(</span>lsb_release <span class="token parameter variable">-cs</span><span class="token variable">)</span></span> \
stable"</span>
</code></pre> 
     <ol start="4"><li>安装 Docker Engine-Community</li></ol> 
     <pre><code class="prism language-shell"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> docker-ce docker-ce-cli containerd.io
</code></pre> 
     <ol start="5"><li>查看是否安装成功，运行以下hello-world</li></ol> 
     <pre><code class="prism language-shell"><span class="token function">sudo</span> <span class="token function">docker</span> run hello-world
</code></pre> 
     <p><img src="https://images2.imgbox.com/a6/55/fkNvAz1f_o.png" alt="在这里插入图片描述"></p> 
     <ol start="6"><li>查看一下下载的hello-world镜像</li></ol> 
     <pre><code class="prism language-shell"><span class="token function">docker</span> images
</code></pre> 
     <p><img src="https://images2.imgbox.com/ad/98/mJL7qjpQ_o.png" alt="在这里插入图片描述"></p> 
     <ol start="7"><li>卸载docker</li></ol> 
     <pre><code class="prism language-shell"><span class="token function">sudo</span> <span class="token function">apt-get</span> purge docker-ce <span class="token comment"># 删除安装包</span>
<span class="token function">sudo</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> /var/lib/docker <span class="token comment"># 删除镜像、容器、配置文件等内容，</span>
</code></pre> 
    </blockquote> <p>/var/lib/docker是docker默认工作路径</p> </li><li> <p>配置阿里云镜像加速<br> <img src="https://images2.imgbox.com/05/ac/ygdFCNVW_o.png" alt="在这里插入图片描述"></p> </li></ol> </li></ul> 
<ol start="5"><li> <p>回顾hello-world镜像拉取过程</p> 
  <blockquote> 
   <ol><li>docker在本机寻找镜像，判断是否有镜像，如果有则使用并运行。否则执行下一步</li><li>去docker hub上下载。如果没找到镜像，返回错误。如果找到了镜像，将镜像下载到本地</li><li>使用下载好的镜像，下次运行时就可以直接从本机找到该镜像了</li></ol> 
  </blockquote> </li></ol> 
<h2><a id="docker_140"></a>docker工作原理</h2> 
<p>docker是一个client-server结构的系统，docker的守护进程运行在主机上，通过socket从客户端访问<br> docker-server接收到docker-client的指令，就会执行这个命令，可能是启动一个容器，这个容器就可以看成是一个小的linux系统，在这个容器内可以运行一些服务，例如mysql(3306端口)<br> <img src="https://images2.imgbox.com/12/94/NHPUP5C8_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="docker_145"></a>docker命令</h2> 
<p><img src="https://images2.imgbox.com/98/8c/o4VvUVl0_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p>帮助命令</p> 
  <blockquote> 
   <ul><li><code>docker version</code> 显示docker版本信息</li><li><code>docker info</code> 显示docker的系统信息，包括镜像和容器的数量</li><li><code>docker --help</code> 帮助命令</li><li><code>docker &lt;命令&gt; --help</code> 查看特定命令的帮助信息</li></ul> 
  </blockquote> </li><li> <p>帮助文档的地址：<a href="https://docs.docker.com/reference/" rel="nofollow">https://docs.docker.com/reference/</a></p> 
  <blockquote> 
   <p><img src="https://images2.imgbox.com/a7/e5/qTmh7CS2_o.png" alt="在这里插入图片描述"></p> 
  </blockquote> </li><li> <p>镜像命令</p> 
  <blockquote> 
   <ul><li><code>docker images</code> 查看所有镜像</li></ul> 
  </blockquote> 
  <blockquote> 
   <ul><li><code>docker search &lt;镜像名称&gt;</code> 搜索镜像</li></ul> 
  </blockquote> 
  <blockquote> 
   <ul><li><code>docker pull &lt;镜像名称&gt;</code> 下载镜像<br> <img src="https://images2.imgbox.com/22/c3/duy6Bdif_o.png" alt="在这里插入图片描述"><br> <code>docker pull mysql</code> 等价于 <code>docker pull docker.io/library/mysql:latest</code><br> 下载指定版本mysql：<code>docker pull mysql:5.7</code><br> <img src="https://images2.imgbox.com/9a/94/OBjopcJt_o.png" alt="在这里插入图片描述"></li></ul> 
  </blockquote> 
  <blockquote> 
   <ul><li><code>docker rmi --f &lt;镜像名称/镜像id&gt;</code> 删除镜像，使用镜像id不需要全写上，只需要写几个前缀，能够与别的镜像区分开即可</li><li><code>docker rmi --f &lt;镜像id&gt; &lt;镜像id&gt;..</code> 批量删除镜像</li><li><code>docker rmi -f $(docker images -aq)</code> docker images -aq会查出所有镜像的id，这样可以删除所有镜像</li></ul> 
  </blockquote> </li><li> <p>容器命令</p> <p>说明：有了镜像才可以创建容器，linux，下载一个centos镜像来学习<br> <code>docker pull centos</code></p> 
  <ul><li> <p>容器运行</p> 
    <blockquote> 
     <ul><li><code>docker run [可选参数] &lt;image&gt;</code> 新建容器并启动</li></ul> 
     <blockquote> 
      <ul><li><code>--name="NAME"</code> 容器名称</li><li><code>-d</code> 后台方式运行，后台运行时必须要有一个前台进程，否则docker发现没有应用，就会自动停止。具体例如：</li></ul> 
      <blockquote> 
       <p><code>docker run -d centos -c "while true;do echo kuangshen;sleep 1;done"</code> # 这段命令循环运行了一个前端shell脚本，这样就使得docker不停止</p> 
      </blockquote> 
      <ul><li><code>-it</code> 使用交互方式运行，进入容器查看内容</li><li><code>-p 主机端口:容器端口</code> 指定主机端口和容器端口的映射</li><li><code>-p 容器端口</code> 指定容器端口</li><li><code>-P</code> 随机指定端口</li></ul> 
     </blockquote> 
    </blockquote> </li><li> <p>查看正在运行的容器</p> 
    <blockquote> 
     <ul><li><code>docker ps</code> 查看正在运行的docker</li><li><code>docker ps -a</code> 查看正在+曾经运行的docker</li></ul> 
    </blockquote> </li><li> <p>终止容器</p> 
    <blockquote> 
     <ul><li><code>exit</code> 停止容器并退出</li><li><code>ctrl + p + q</code> 容器不停止退出</li></ul> 
    </blockquote> </li><li> <p>删除容器</p> 
    <blockquote> 
     <ul><li><code>docker rm &lt;容器id&gt;</code> 删除容器，不能删除正在运行的容器，如果像删除，加-f参数</li><li><code>docker rm $(docker ps -aq)</code> 删除所有容器</li><li><code>docker ps -a -q|xargs docker rm</code> 删除所有容器</li></ul> 
    </blockquote> </li><li> <p>容器启停</p> 
    <blockquote> 
     <ul><li><code>docker start &lt;容器id&gt;</code> 启动容器</li><li><code>docker restart &lt;容器id&gt;</code> 重启容器</li><li><code>docker stop &lt;容器id&gt;</code>停止当前正在运行的容器</li><li><code>docker kill &lt;容器id&gt;</code>强制停止当前容器</li></ul> 
    </blockquote> </li><li> <p>日志、进程、元数据的查看</p> 
    <blockquote> 
     <ul><li><code>docker logs -tf --tail 10 &lt;容器id&gt;</code> 查看尾部10条日志</li><li><code>docker top &lt;容器id&gt;</code> 查看进程信息</li><li><code>docker inspect &lt;容器id&gt;</code> 查看容器元数据</li></ul> 
    </blockquote> </li><li> <p>进入正在运行的容器、拷贝命令</p> 
    <blockquote> 
     <ul><li><code>docker exec -it &lt;容器id&gt; /bin/bash</code> 交互模式进入</li><li><code>docker attach &lt;容器id&gt;</code> 交互模式进入</li><li><code>docker cp &lt;容器id&gt;:&lt;文件路径&gt; &lt;主机路径&gt; </code> 从容器内拷贝文件到主机上</li></ul> 
    </blockquote> </li></ul> </li></ul> 
<h2><a id="docker_224"></a>docker搭建练习</h2> 
<ul><li> <p>Docker 安装 Nginx</p> 
  <blockquote> 
   <ol><li>搜索镜像<br> <code>docker search nginx</code>或者直接dockerhub上搜索</li><li>下载镜像<br> <code>docker pull nginx</code></li><li>查看镜像<br> <code>docker images</code></li><li>启动镜像<br> <code>docker run -d --name nginx01 -p 3344:80 nginx</code> 给这个容器起一个名:nginx01，外面端口设置为3344（可以进行公网访问），容器内端口设置为nginx默认端口80，这样在外面就可以通过3344端口访问到nginx</li><li>测试镜像<br> <code>curl localhost:3344</code><br> <img src="https://images2.imgbox.com/f3/69/Vu6XSqpF_o.png" alt="在这里插入图片描述"></li><li>交互模式进入容器<br> <code>docker exec -it nginx01 /bin/bash</code></li><li>找到nginx应用路径<br> <code>whereis nginx</code></li></ol> 
  </blockquote> 
  <blockquote> 
   <p>问题：每次需要修改nginx配置文件都需要进入容器内部，十分麻烦，如果可以在容器外部提供一个映射路径，使得能够修改容器内的文件。<br> <code>-v 数据卷</code></p> 
  </blockquote> </li><li> <p>docker 安装 tomcat</p> 
  <blockquote> 
   <ol><li>直接用run自动下载镜像，启动容器<br> <code>docker run -ti --rm tomcat:9.0</code> --rm参数表示该容器用完（stop）即删除，是用来测试的</li><li>正常启动容器<br> <code>docker run -d -p 3355:8080 --name tomcat01 tomcat:9.0</code></li><li>查看容器<br> <code>docker ps</code></li><li>进入容器<br> <code>docker exec -it tomcat01 /bin/bash</code></li><li>终止容器<br> <code>docker stop tomcat01</code></li><li>删除容器<br> <code>docker rm tomcat01</code></li></ol> 
  </blockquote> </li><li> <p>docker 部署 es + kibana</p> 
  <blockquote> 
   <p>问题：</p> 
   <ol><li>es 暴露的端口很多</li><li>es 十分耗内存</li><li>es 的数据一般需要放置到安全目录！挂载</li></ol> 
  </blockquote> 
  <blockquote> 
   <ol><li>去dockerhub搜索elastic镜像<br> <img src="https://images2.imgbox.com/92/fb/jXi50UU1_o.png" alt="在这里插入图片描述"></li><li>下载镜像，启动容器<br> <code>docker network create somenetwork</code><br> <code>docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:tag</code></li><li>查看容器cpu状态<br> <code>docker stats</code></li><li>下载kibana镜像并运行，思考两个容器如何通信<br> <img src="https://images2.imgbox.com/4b/6b/YyrwRumv_o.png" alt="在这里插入图片描述"></li></ol> 
  </blockquote> </li></ul> 
<h2><a id="docker_279"></a>docker可视化</h2> 
<ul><li> <p>portainer：docker图形化界面管理工具！提供一个后台面板供我们操作</p> 
  <blockquote> 
   <p><code>docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code></p> 
  </blockquote> <p>访问测试：</p> 
  <blockquote> 
   <p>localhost:8088<br> 默认用户名：<code>admin</code>，设置密码：<code>XXX</code>，选择<code>local，connect</code><br> <img src="https://images2.imgbox.com/88/11/DK77YkB1_o.png" alt="在这里插入图片描述"></p> 
  </blockquote> </li><li> <p>Rancher</p> </li></ul> 
<h2><a id="docker_290"></a>docker镜像</h2> 
<p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p> 
<ul><li> <p>如何得到镜像</p> 
  <blockquote> 
   <ul><li>远程仓库下载</li><li>朋友拷贝给你</li><li>自己制作一个镜像DockerFile</li></ul> 
  </blockquote> </li><li> <p>核心思想：层级文件系统Union File System（UnionFS）<br> <img src="https://images2.imgbox.com/8c/4c/iT9ukAHb_o.png" alt="在这里插入图片描述"><br> 分层下载的好处在于：当下载一个新的镜像时，如果之前下载过该镜像中的某一层，那么就不用重复下载了，节省内存。</p> </li><li> <p>特点：</p> <p>docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！这一层就是我们通常说的容器层，容器之下的都叫镜像层。</p> </li><li> <p>commit镜像：</p> <p><code>docker commit -m="提交的描述信息" -a="作者" &lt;容器id&gt; 目标镜像名:&lt;tag&gt;</code><br> <code>docker images</code> 查看提交的镜像</p> </li></ul> 
<h2><a id="docker_313"></a>docker容器数据卷</h2> 
<blockquote> 
 <ul><li><strong>问题</strong>：docker是将应用和环境打包成一个镜像，但是不考虑数据。如果数据都存放在容器中，那我们将容器删除，数据就会丢失</li><li><strong>需求</strong>：数据可以持久化</li><li><strong>解决方法</strong>：容器之间需要一个数据共享的技术。docker容器中产生的数据，同步到本地，这就是卷技术。</li></ul> 
</blockquote> 
<p>简单来说，卷技术就是目录的挂载，将容器内的目录挂载到主机上。举例：<br> <img src="https://images2.imgbox.com/ed/32/ophg7WGD_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>方式1：使用命令来挂载</strong>：<br> <code>docker run -it -v 主机目录:容器目录 &lt;容器id&gt;</code><br> <code>docker inspect &lt;容器id&gt;</code> 查看挂载情况，双向绑定，不管修改主机还是容器，都会同步。即使容器被停止了，也会同步<br> <img src="https://images2.imgbox.com/8b/b5/S1sL8SmK_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<ul><li> <p>实战：同步mysql数据</p> 
  <blockquote> 
   <p>运行容器：<br> <code>docker run -d -p 3310:3306 -v /home/yonghu/ceshi:/etc/mysql/conf.d -v /home/yonghu/ceshidata:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</code> 实现多个挂载，配置文件挂载和数据挂载</p> 
  </blockquote> </li><li> <p>具名挂载和匿名挂载</p> 
  <blockquote> 
   <ul><li>匿名挂载：<code>-v 容器路径:&lt;权限&gt;</code></li><li>具名挂载：<code>-v 卷名:容器路径:&lt;权限&gt;</code></li><li>指定路径挂载：<code>-v 主机路径:容器路径:&lt;权限&gt;</code></li><li><code>&lt;权限&gt;</code>可以设置为<code>ro</code>只读、<code>rw</code>读写。<code>ro</code>权限是只能主机进行修改，容器无法修改了。<br> <code>docker volume ls</code> 将所有的卷都打印出来<br> <code>docker volume inspect &lt;卷名&gt;</code> 查看指定卷的细节</li></ul> 
  </blockquote> <p>所有的docker容器内的卷，没有指定目录的情况下都是在<code>/var/lib/docker/volumes</code>目录下</p> </li></ul> 
<blockquote> 
 <p><strong>方式2：使用DockerFile来挂载</strong><br> DockerFile就是用来构建docker镜像的构建文件。其实就是一个命令脚本，通过这个脚本可以生成一个镜像。镜像是一层一层的，因此脚本是一个一个的命令，每个命令都是一层。<br> <code>mkdir ceshi</code><br> <code>pwd</code></p> 
 <blockquote> 
  <p><img src="https://images2.imgbox.com/26/68/KFUjPCTS_o.png" alt="在这里插入图片描述"></p> 
 </blockquote> 
 <p><code>vim dockerfile1</code> 创建一个dockerfile文件</p> 
 <blockquote> 
  <p><img src="https://images2.imgbox.com/d4/87/Uq5ohhoS_o.png" alt="在这里插入图片描述"><br> FROM centos：指定基础镜像<br> VOLUME [“volume01”,“volume02”]：通过volume进行挂载<br> CMD echo “------end------”：输出end<br> CMD /bin/bash：进入到/bin/bash中</p> 
 </blockquote> 
 <p><code>docker build -f dockerfile1 -t test/centos .</code>当前目录下build镜像<br> <code>docker images</code></p> 
 <blockquote> 
  <p><img src="https://images2.imgbox.com/d3/49/YkOpRQ9R_o.png" alt="在这里插入图片描述"></p> 
 </blockquote> 
 <p><code>docker run -it --name mycentos test/centos /bin/bash</code><br> <code>ls -l</code></p> 
 <blockquote> 
  <p><img src="https://images2.imgbox.com/0d/0d/ojdUqrW2_o.png" alt="在这里插入图片描述"></p> 
 </blockquote> 
 <p><code>exit</code><br> <code>docker inspect mycentos</code> 查看卷挂载主机路径</p> 
 <blockquote> 
  <p><img src="https://images2.imgbox.com/01/f5/PioJfHdX_o.png" alt="在这里插入图片描述"></p> 
 </blockquote> 
</blockquote> 
<ul><li> <p>多个mysql同步数据</p> 
  <blockquote> 
   <p><code>docker run -it --name centos01 test/centos</code> 创建父容器（数据卷容器）<br> <code>docker run -it --name centos02 --volumes-from centos01 test/centos</code> --volumes-from同步两个容器</p> 
  </blockquote> 
  <blockquote> 
   <p>即使删除父容器，数据仍然存在</p> 
  </blockquote> </li></ul> 
<h2><a id="DockerFile_376"></a>DockerFile</h2> 
<p>DockerFile就是用来构建docker镜像的构建文件。其实就是一个命令脚本，通过这个脚本可以生成一个镜像。镜像是一层一层的，因此脚本是一个一个的命令，每个命令都是一层。</p> 
<p>构建步骤：</p> 
<ol><li>编写一个 dockerfile 文件</li><li>构建一个镜像： <code>docker build -f &lt;docker文件名&gt; -t 镜像名 .</code></li><li>运行镜像：<code>docker run</code></li><li>发布镜像（dockerhub、阿里云镜像仓库）：<code>docker push</code></li></ol> 
<ul><li> <p>DockerFile基础知识</p> 
  <blockquote> 
   <ol><li>每个保留关键字都必须是大写字母</li><li>执行从上到下顺序执行</li><li># 表示注释</li><li>每一个指令都会创建提交一个新的镜像层，并提交</li></ol> 
  </blockquote> </li><li> <p>DockerFile指令</p> 
  <blockquote> 
   <ul><li>FROM：指定基础镜像。</li></ul> 
   <blockquote> 
    <p>示例：<code>FROM ubuntu:latest</code></p> 
   </blockquote> 
   <ul><li>MAINTAINER：指定维护者信息。</li></ul> 
   <blockquote> 
    <p>示例：<code>MAINTAINER dj&lt;123456@qq.com&gt;</code></p> 
   </blockquote> 
   <ul><li>RUN：在镜像中执行命令。</li></ul> 
   <blockquote> 
    <p>示例：<code>RUN apt-get update &amp;&amp; apt-get install -y package</code></p> 
   </blockquote> 
   <ul><li>COPY：将文件从构建上下文复制到镜像中。</li></ul> 
   <blockquote> 
    <p>示例：<code>COPY app.py /app/</code></p> 
   </blockquote> 
   <ul><li>ADD：类似于 COPY 命令，但还支持远程URL和解压缩文件。</li></ul> 
   <blockquote> 
    <p>示例：<code>ADD http://example.com/file.tar.gz /data/</code></p> 
   </blockquote> 
   <ul><li>WORKDIR：设置工作目录。</li></ul> 
   <blockquote> 
    <p>示例：<code>WORKDIR /app</code></p> 
   </blockquote> 
   <ul><li>EXPOSE：声明容器在运行时监听的端口。</li></ul> 
   <blockquote> 
    <p>示例：<code>EXPOSE 8080</code></p> 
   </blockquote> 
   <ul><li>ENV：设置环境变量。</li></ul> 
   <blockquote> 
    <p>示例：<code>ENV MY_ENV_VAR=value</code></p> 
   </blockquote> 
   <ul><li>CMD：指定容器启动后要执行的命令。只有最后一个会生效，可被替代。</li></ul> 
   <blockquote> 
    <p>示例：<code>CMD ["python", "app.py"]</code></p> 
   </blockquote> 
   <ul><li>ENTRYPOINT：将容器作为可执行程序运行，忽略 CMD 指令。</li></ul> 
   <blockquote> 
    <p>示例：<code>ENTRYPOINT ["python","app.py"]</code></p> 
   </blockquote> 
   <ul><li>VOLUME：声明容器中的挂载点。</li></ul> 
   <blockquote> 
    <p>示例：<code>VOLUME /data</code></p> 
   </blockquote> 
  </blockquote> </li><li> <p>实战：构建自己的centos</p> 
  <ol><li> <p>编写dockerfile文件<br> <code>vim dockerfile2</code></p> <pre><code class="prism language-text">FROM centos
MAINTAINER dj&lt;123456@qq.com&gt;

ENV MYPATH=/usr/local
WORKDIR $MYPATH

RUN yum -y install vim
RUN yum -y install net-tools

EXPOSE 80

CMD echo $MYPATH
CMD echo "----end----"
CMD /bin/bash
</code></pre> </li><li> <p>构建镜像<br> <code>docker build -f dockerfile2 -t test/mycentos .</code></p> </li><li> <p>运行容器<br> <code>docker run -it test/mycentos</code></p> </li><li> <p>查看镜像是如何制作的<br> <code>docker history &lt;容器id&gt;</code></p> </li></ol> </li><li> <p>CMD和ENTRYPOINT的区别</p> <p>CMD命令：</p> 
  <blockquote> 
   <p><code>vim dockerfile3</code></p> 
  </blockquote> <pre><code class="prism language-text">FROM centos
CMD ["ls","-a"]
</code></pre> 
  <blockquote> 
   <p><code>docker build -f dockerfile3 -t test/dockerfile3 .</code><br> <code>docker run -it test/dockerfile3</code> 正常运行得到：<br> <img src="https://images2.imgbox.com/c1/cd/TdJfzCmQ_o.png" alt="在这里插入图片描述"><br> <code>docker run -it test/dockerfile3 -l</code> 后面加一个<code>-l</code>参数，报错：<br> <img src="https://images2.imgbox.com/6a/49/43L2tuCM_o.png" alt="在这里插入图片描述"><br> <code>docker run -it test/dockerfile3 ls -al</code>，正常运行<br> <img src="https://images2.imgbox.com/53/c3/tEiZ5mak_o.png" alt="在这里插入图片描述"></p> 
  </blockquote> <p>ENTRYPOINT命令（追加命令）：</p> 
  <blockquote> 
   <p><code>vim dockerfile4</code></p> 
  </blockquote> <pre><code class="prism language-text">FROM centos
ENTRYPOINT ["ls","-a"]
</code></pre> 
  <blockquote> 
   <p><code>docker build -f dockerfile4 -t test/dockerfile4 .</code><br> <code>docker run -it test/dockerfile4</code> 正常运行得到：<br> <img src="https://images2.imgbox.com/05/27/V6EhL0hj_o.png" alt="在这里插入图片描述"><br> <code>docker run -it test/dockerfile4 -l</code> ，正常运行：<br> <img src="https://images2.imgbox.com/62/e6/WGdmshZh_o.png" alt="在这里插入图片描述"></p> 
  </blockquote> </li><li> <p>实战：部署tomcat<br> <a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=30&amp;spm_id_from=pageDriver&amp;vd_source=3bde26fc3fd311d05f489ace67545cd8" rel="nofollow">bilibili视频 - 部署tomcat</a></p> </li><li> <p>发布自己的镜像到dockerhub</p> 
  <blockquote> 
   <ol><li>dockerhub注册账号</li><li>使用命令登录账号<br> <code>docker login -u &lt;用户名&gt; -p &lt;密码&gt;</code></li><li>提交镜像<br> <code>docker tag &lt;镜像id&gt; &lt;镜像名&gt;:&lt;tag&gt;</code> 指定某个<code>镜像id</code>，复制一个名为<code>&lt;镜像名&gt;:&lt;tag&gt;</code>的新镜像<br> <code>docker push &lt;镜像名&gt;或者&lt;镜像id&gt;:&lt;tag&gt;</code></li></ol> 
  </blockquote> </li></ul> 
<h2><a id="docker_487"></a>docker全流程</h2> 
<p><img src="https://images2.imgbox.com/d0/34/llVbYYRA_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Docker_489"></a>Docker网络原理</h2> 
<ul><li>理解docker0<br> <img src="https://images2.imgbox.com/1b/cb/VzVJCSmp_o.png" alt="在这里插入图片描述"><br> docker0相当于网关。</li></ul> 
<blockquote> 
 <p>问题：docker是如何处理容器网络访问的？</p> 
</blockquote> 
<ul><li> <p>解决上述问题</p> 
  <blockquote> 
   <ol><li> <p>运行一个tomcat容器<br> <code>docker run -d -P --name tomcat01 tomcat</code></p> </li><li> <p>查看容器内部网络地址<br> <code>docker exec -it tomcat01 ip addr</code><br> <img src="https://images2.imgbox.com/bb/52/F0Onw0zr_o.png" alt="在这里插入图片描述"></p> </li><li> <p>尝试ping容器<br> <code>ping 172.17.0.2</code> 可以ping通</p> </li><li> <p>再开启一个tomcat容器<br> <code>docker run -d -P --name tomcat02 tomcat</code></p> </li><li> <p>tomcat01尝试ping tomcat02<br> <code>docker exec -it tomcat01 ping 172.17.0.3</code>，可以ping通<br> <img src="https://images2.imgbox.com/69/9c/oayHQ5G0_o.png" alt="在这里插入图片描述"></p> </li><li> <p>运行<code>ip addr</code>，此时多了两对网卡<br> <img src="https://images2.imgbox.com/7b/e6/OIcIlnxW_o.png" alt="在这里插入图片描述"></p> </li></ol> 
  </blockquote> <p><img src="https://images2.imgbox.com/21/31/a6pkrvtV_o.png" alt="在这里插入图片描述"></p> <p>每启动一个docker容器，dockers就回给dockers容器分配一个ip，我们只要安装了docker，就会有一个网卡docker0（桥接模式），使用的技术是veth-pair技术。</p> 
  <blockquote> 
   <p><strong>veth-pair</strong>：是一对虚拟设备接口，成对出现，一端连接协议，一段彼此相连。例如主机如果想和容器通信，那么主机和容器就会彼此相连，然后再连接协议。<br> <img src="https://images2.imgbox.com/b1/7b/upSd3lAi_o.png" alt="在这里插入图片描述"></p> 
  </blockquote> 
  <blockquote> 
   <p><strong>桥接模式</strong>：在bridged模式下，VMWare虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。主机网卡和虚拟网卡的IP地址处于同一个网段，子网掩码、网关、DNS等参数都相同。这种方式简单，直接将虚拟网卡桥接到一个物理网卡上面，和linux下一个网卡 绑定两个不同地址类似，实际上是将网卡设置为混杂模式，从而达到侦听多个IP的能力。在此种模式下，虚拟机内部的网卡（例如linux下的eth0)直接连到了物理网卡所在的网络上，可以想象为虚拟机和host机处于对等的地位，在网络关系上是平等的，没有谁在谁后面的问题。<br> <strong>NAT模式</strong>：相当于宿主机再构建一个局域网，虚拟机无法和本局域网中的其他真实主机进行通讯。只需要宿主机器能访问互联网，那么虚拟机就能上网，不需要再去配置IP地址，子网掩码，网关。虚拟机和主机能够互相ping通。<br> <img src="https://images2.imgbox.com/52/5e/78fHYdCu_o.png" alt="在这里插入图片描述"></p> 
  </blockquote> </li><li> <p>容器互联 link</p> 
  <blockquote> 
   <ol><li>新建一个容器tomcat03来link tomcat02<br> <code>docker run -d -P --name tomcat03 --link tomcat02 tomcat</code></li><li>测试用容器名，看能否ping通<br> <code>docker exec -it tomcat03 ping tomcat02</code>，可以ping通<br> <code>docker exec -it tomcat02 ping tomcat03</code>，不可以ping通<br> <code>docker exec -it tomcat03 cat /etc/hosts</code>，查看路由，发现tomcat03的路由中存放着tomcat02的ip映射<br> <img src="https://images2.imgbox.com/a5/bf/cFgSppLp_o.png" alt="在这里插入图片描述"><br> <code>docker exec -it tomcat02 cat /etc/hosts</code>，查看路由，发现tomcat02的路由中没有tomcat03的ip映射<br> <img src="https://images2.imgbox.com/f3/45/ikDak1yt_o.png" alt="在这里插入图片描述"></li></ol> 
  </blockquote> </li><li> <p>自定义网络</p> 
  <blockquote> 
   <ol><li>查看网卡<br> <code>docker network ls</code><br> <img src="https://images2.imgbox.com/68/30/RDuXeEdY_o.png" alt="在这里插入图片描述"><br> bridge：桥接模式（自定义网络）<br> host：和宿主机共享网络<br> none：不配置网络<br> container：容器网络连通</li></ol> 
  </blockquote> 
  <blockquote> 
   <ol start="2"><li>自定义网络<br> （1）<code>docker run -d -P --name tomcat01 tomcat</code> 等价于 <code>docker run -d -P --name tomcat01 --net bridge tomcat</code>，默认运行容器使用桥接模式<br> （2）<code>docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</code><br> （3）<code>docker network ls</code><br> （4）<code>docker network inspect mynet</code><br> <img src="https://images2.imgbox.com/d7/7d/0INo5HuO_o.png" alt="在这里插入图片描述"><br> （5）<code>docker run -d -P --net mynet --name tomcat01 tomcat</code>，运行一个自己网络下的容器<br> （6）<strong>自定义网络无需使用link也可以使用容器名进行ping通</strong></li></ol> 
  </blockquote> </li></ul> 
<blockquote> 
 <p>问题：不同网段的容器如何互联？</p> 
</blockquote> 
<ul><li> <p>容器连通</p> <p><img src="https://images2.imgbox.com/24/02/f4iq6r7S_o.png" alt="在这里插入图片描述"><br> <code>docker run -d -P --name tomcat01 tomcat</code><br> <code>docker run -d -P --name tomcat02 --net mynet tomcat</code><br> <code>docker network connect mynet tomcat01</code><br> <code>dcoker exec -it tomcat01 ping tomcat02</code>，可以ping通，反过来也可以ping通<br> <code>docker network inspect tomcat01</code>，观察网卡信息，发现tomcat01被写入<br> <img src="https://images2.imgbox.com/7f/c1/N1lvSuDA_o.png" alt="在这里插入图片描述"><br> <code>docker exec -it tomcat01 ip addr</code>，查看tomcat01网卡信息，发现多了一个IP地址<br> <img src="https://images2.imgbox.com/a0/a6/1vWzi2fo_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h2><a id="docker_compose_571"></a>docker compose</h2> 
<ul><li> <p>docker compose 介绍</p> <p>之前docker只能每个容器单个操作build，run等命令，现在可以使用docker compose批量处理，轻松高效的管理容器。</p> 
  <ul><li> <p>三步骤：</p> 
    <blockquote> 
     <ol><li>Dockerfile保证项目在任何地方运行</li><li>定义服务，编写docker-compose.yml文件</li><li>启动项目，docker-compose up</li></ol> 
    </blockquote> 
    <blockquote> 
     <ul><li><strong>问题</strong>：如果要部署一个web服务，我们要使用到redis、mysql、nginx…多个容器，一个一个去build，run非常麻烦</li><li><strong>解决</strong>：docker compose</li></ul> 
    </blockquote> </li><li> <p>compose中重要概念：</p> 
    <blockquote> 
     <ul><li>服务services：容器，应用。（web,redis,mysql…）</li><li>项目project：一组关联的容器。例如：博客</li></ul> 
    </blockquote> </li></ul> </li><li> <p>docker compose 安装</p> 
  <blockquote> 
   <ul><li><code>sudo curl -L "https://hub.nuaa.cf/docker/compose/releases/download/2.23.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose </code></li><li><code>sudo chmod +x /usr/local/bin/docker-compose</code>，修改权限</li><li><code>docker-compose --version</code>，查看是否安装成功</li></ul> 
  </blockquote> </li><li> <p>docker compose 使用</p> <p><a href="https://docs.docker.com/compose/gettingstarted/" rel="nofollow">官方简单使用</a></p> <p>正常步骤：</p> 
  <blockquote> 
   <ol><li>准备好所有需要的依赖文件</li><li>写好DockerFile来构建web应用镜像</li><li>仓库拉取redis镜像</li><li>run，构造两个容器</li><li>对两个容器做互通</li></ol> 
  </blockquote> <p>docker-compose：</p> 
  <blockquote> 
   <ol><li>准备好所有需要的依赖文件</li><li>写好DockerFile来构建web应用镜像</li><li>写docker-compose.yml文件</li><li>一键部署<code>docker-compose up</code></li></ol> 
  </blockquote> 
  <ul><li> <p>命令：</p> 
    <blockquote> 
     <ul><li><code>docker-compose up</code> 启动</li><li><code>docker-compose down</code> 或 <code>ctrl+c</code> 停止</li></ul> 
    </blockquote> </li></ul> </li><li> <p>docker-compose.yml文件编写</p> <p>共三层：版本、服务、其他配置<br> <a href="https://docs.docker.com/compose/compose-file/03-compose-file/" rel="nofollow">官方文档</a></p> <pre><code class="prism language-text">version: ' ' # 版本
service:     # 服务
	服务1(web):
		images:
		build:
		network:
		...
	服务2(redis):
		...
# 其他配置
volumes:
networks:
configs:
secrets:
</code></pre> </li></ul> 
<h2><a id="docker_swarm_638"></a>docker swarm</h2>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4b5b55588135f15b0b2f4a1747ba17e9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Qt框架学习(1)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e79d949edd1f10a9b08f42e3423a2f70/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【已解决】Factory method ‘redisConnectionFactory‘ threw exception； nested exception is java.lang.</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>