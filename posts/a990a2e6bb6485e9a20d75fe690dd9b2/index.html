<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c# WinForm开发 DataGridView控件的各种操作总结（单元格操作，属性设置） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c# WinForm开发 DataGridView控件的各种操作总结（单元格操作，属性设置）" />
<meta property="og:description" content="一、单元格内容的操作
*****// 取得当前单元格内容 Console.WriteLine(DataGridView1.CurrentCell.Value); // 取得当前单元格的列 Index Console.WriteLine(DataGridView1.CurrentCell.ColumnIndex); // 取得当前单元格的行 Index Console.WriteLine(DataGridView1.CurrentCell.RowIndex);
*******另外，使用 DataGridView.CurrentCellAddress 属性（而不是直接访问单元格）来确定单元格所在的行：
DataGridView.CurrentCellAddress.Y 和列： DataGridView.CurrentCellAddress.X 。这对于避免取消共享行的共享非常有用。 当前的单元格可以通过设定 DataGridView 对象的 CurrentCell 来改变。可以通过 CurrentCell 来设定 DataGridView 的激活单元格。将 CurrentCell 设为 Nothing(null) 可以取消激活的单元格。
// 设定 (0, 0) 为当前单元格 DataGridView1.CurrentCell = DataGridView1[0, 0]; 在整行选中模式开启时，你也可以通过 CurrentCell 来设定选定行。 /// &lt;summary&gt; /// 向下遍历 /// &lt;/summary&gt; /// &lt;param &gt;&lt;/param&gt; /// &lt;param &gt;&lt;/param&gt; private void button4_Click(object sender, EventArgs e) ...{ int row = this.dataGridView1.CurrentRow.Index &#43; 1; if (row &gt; this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/a990a2e6bb6485e9a20d75fe690dd9b2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-08-20T15:18:43+08:00" />
<meta property="article:modified_time" content="2014-08-20T15:18:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c# WinForm开发 DataGridView控件的各种操作总结（单元格操作，属性设置）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>一、单元格内容的操作</strong></p> 
<p><strong></strong></p> 
<p><strong></strong></p> 
<p>*****// 取得当前单元格内容 </p> 
<p><br>         Console.WriteLine(DataGridView1.CurrentCell.Value); <br> // 取得当前单元格的列 Index <br>       Console.WriteLine(DataGridView1.CurrentCell.ColumnIndex); <br> // 取得当前单元格的行 Index <br>       Console.WriteLine(DataGridView1.CurrentCell.RowIndex);</p> 
<p><br> *******另外，使用 DataGridView.CurrentCellAddress 属性（而不是直接访问单元格）来确定单元格所在的行：</p> 
<p></p> 
<p>DataGridView.CurrentCellAddress.Y 和列： DataGridView.CurrentCellAddress.X 。这对于避免取消共享行的共享非常有用。 <br> 当前的单元格可以通过设定 DataGridView 对象的 CurrentCell 来改变。可以通过 CurrentCell 来设定 <br> DataGridView 的激活单元格。将 CurrentCell 设为 Nothing(null) 可以取消激活的单元格。</p> 
<p>// 设定 (0, 0)  为当前单元格 <br> DataGridView1.CurrentCell = DataGridView1[0, 0]; <br> 在整行选中模式开启时，你也可以通过 CurrentCell 来设定选定行。 <br>         /// &lt;summary&gt; <br>         /// 向下遍历 <br>         /// &lt;/summary&gt; <br>         /// &lt;param &gt;&lt;/param&gt; <br>         /// &lt;param &gt;&lt;/param&gt; <br>         private void button4_Click(object sender, EventArgs e) <br>         ...{ <br>             int row = this.dataGridView1.CurrentRow.Index + 1; <br>             if (row &gt; this.dataGridView1.RowCount - 1) <br>                 row = 0; <br>             this.dataGridView1.CurrentCell = this.dataGridView1[0, row];  <br>         } <br> <br>         /// &lt;summary&gt; <br>         /// 向上遍历 <br>         /// &lt;/summary&gt; <br>         /// &lt;param &gt;&lt;/param&gt; <br>         /// &lt;param &gt;&lt;/param&gt; <br>         private void button5_Click(object sender, EventArgs e) <br>         ...{ <br>             int row = this.dataGridView1.CurrentRow.Index - 1; <br>             if (row &lt; 0) <br>                 row = this.dataGridView1.RowCount - 1; <br>             this.dataGridView1.CurrentCell = this.dataGridView1[0, row];  <br>         } <br> * 注意: this.dataGridView 的索引器的参数是: columnIndex, rowIndex 或是 columnName, rowIndex <br> 这与习惯不同。</p> 
<p></p> 
<p>********DataGridView  设定单元格只读：</p> 
<p></p> 
<p>1） 使用 ReadOnly 属性 <br> ?　如果希望，DataGridView 内所有单元格都不可编辑， 那么只要： <br> // 设置 DataGridView1 为只读 <br> DataGridView1.ReadOnly = true;此时，用户的新增行操作和删除行操作也被屏蔽了。 <br> <br> ******如果希望，DataGridView 内某个单元格不可编辑， 那么只要： </p> 
<p><br> // 设置 DataGridView1 的第2列整列单元格为只读 <br> DataGridView1.Columns[1].ReadOnly = true; <br> // 设置 DataGridView1 的第3行整行单元格为只读 <br> DataGridView1.Rows[2].ReadOnly = true; <br> // 设置 DataGridView1 的[0，0]单元格为只读 <br> DataGridView1[0, 0].ReadOnly = true; </p> 
<p></p> 
<p>*******DataGridView 行头列头的单元格</p> 
<p><br> // 改变DataGridView1的第一列列头内容 <br> DataGridView1.Columns[0].HeaderCell.Value = "第一列"; <br> // 改变DataGridView1的第一行行头内容 <br> DataGridView1.Rows[0].HeaderCell.Value = "第一行"; <br> // 改变DataGridView1的左上头部单元内容 <br> DataGridView1.TopLeftHeaderCell.Value = "左上"; <br> 另外你也可以通过 HeaderText 来改变他们的内容。</p> 
<p>// 改变DataGridView1的第一列列头内容 <br> DataGridView1.Columns[0].HeaderText = "第一列"; </p> 
<p><br> *********** DataGridView 单元格的ToolTip的设置 </p> 
<p><br> DataGridView.ShowCellToolTips = True 的情况下， 单元格的 ToolTip 可以表示出来。对于单元格窄小，无法完全显示的单元格， ToolTip 可以显示必要的信息。 <br> 1） 设定单元格的ToolTip内容 <br> // 设定单元格的ToolTip内容 <br> DataGridView1[0, 0].ToolTipText = "该单元格的内容不能修改"; <br> // 设定列头的单元格的ToolTip内容 <br> DataGridView1.Columns[0].ToolTipText = "该列只能输入数字"; <br> // 设定行头的单元格的ToolTip内容 <br> DataGridView1.Rows[0].HeaderCell.ToolTipText = "该行单元格内容不能修改"; <br> 2） CellToolTipTextNeeded 事件 <br> 在批量的单元格的 ToolTip 设定的时候，一个一个指定那么设定的效率比较低， 这时候可以利用 CellToolTipTextNeeded 事件。当单元格的 ToolTipText 变化的时候也会引发该事件。但是，当DataGridView的DataSource被指定且VirualMode=True的时候，该事件不会被引发。 <br> // CellToolTipTextNeeded事件处理方法 <br> private void DataGridView1_CellToolTipTextNeeded(object sender, <br>     DataGridViewCellToolTipTextNeededEventArgs e) <br> { <br>     e.ToolTipText = e.ColumnIndex.ToString() + ", " + e.RowIndex.ToString(); <br> }</p> 
<p></p> 
<p>*******DataGridView 的单元格的边框、 网格线样式的设定 </p> 
<p><br> 1) DataGridView 的边框线样式的设定 <br> DataGridView 的边框线的样式是通过 DataGridView.BorderStyle 属性来设定的。 BorderStyle 属性设定值是一个 <br> BorderStyle 枚举： FixedSingle（单线，默认）、Fixed3D、None。 <br> 2) 单元格的边框线样式的设定 <br> 单元格的边框线的样式是通过 DataGridView.CellBorderStyle 属性来设定的。 CellBorderStyle 属性设定值是 <br> DataGridViewCellBorderStyle 枚举。（详细参见 MSDN） <br> 另外，通过 DataGridView.ColumnHeadersBorderStyle 和 RowHeadersBorderStyle 属性可以修改 DataGridView 的头部的单元格边框线样式。 属性设定值是 DataGridViewHeaderBorderStyle 枚举。（详细参见 MSDN） <br> 3） 单元格的边框颜色的设定 <br> 单元格的边框线的颜色可以通过 DataGridView.GridColor 属性来设定的。默认是 ControlDarkDark 。但是只有在 CellBorderStyle 被设定为 Single、SingleHorizontal、SingleVertical  的条件下才能改变其边框线的颜色。同样，ColumnHeadersBorderStyle 以及 RowHeadersBorderStyle 只有在被设定为 Single 时，才能改变颜色。 <br> 4） 单元格的上下左右的边框线式样的单独设定 <br> CellBorderStyle只能设定单元格全部边框线的式样。要单独改变单元格某一边边框式样的话，需要用到DataGridView.AdvancedCellBorderStyle属性。如示例： <br> ' 单元格的上边和左边线设为二重线 <br> ' 单元格的下边和右边线设为单重线 <br> DataGridView1.AdvancedCellBorderStyle.Top = _ <br>     DataGridViewAdvancedCellBorderStyle.InsetDouble <br> DataGridView1.AdvancedCellBorderStyle.Right = _ <br>     DataGridViewAdvancedCellBorderStyle.Inset <br> DataGridView1.AdvancedCellBorderStyle.Bottom = _ <br>     DataGridViewAdvancedCellBorderStyle.Inset <br> DataGridView1.AdvancedCellBorderStyle.Left = _ <br>     DataGridViewAdvancedCellBorderStyle.InsetDouble <br> 同样，设定行头单元格的属性是： AdvancedRowHeadersBorderStyle， 设定列头单元格属性是：AdvancedColumnHeadersBorderStyle。</p> 
<p></p> 
<p>*******DataGridView 单元格表示值的自定义 <br> <br> 通过CellFormatting事件，可以自定义单元格的表示值。（比如：值为Error的时候，单元格被设定为红色） <br> 下面的示例：将“Colmn1”列的值改为大写。 </p> 
<p>//CellFormatting 事件处理方法 <br> private void DataGridView1_CellFormatting(object sender, <br>     DataGridViewCellFormattingEventArgs e) <br> { <br>     DataGridView dgv = (DataGridView)sender; <br> <br>     // 如果单元格是“Column1”列的单元格 <br>     if (dgv.Columns[e.ColumnIndex].Name == "Column1" &amp;&amp; e.Value is string) <br>     { <br>         // 将单元格值改为大写 <br>         string str = e.Value.ToString(); <br>         e.Value = str.ToUpper(); <br>         // 应用该Format，Format完毕。 <br>         e.FormattingApplied = true; <br>     } <br> } <br> CellFormatting事件的DataGridViewCellFormattingEventArgs对象的Value属性一开始保存着未被格式化的值。当Value属性被设定表示用的文本之后，把FormattingApplied属性做为True，告知DataGridView文本已经格式化完毕。如果不这样做的话，DataGridView会根据已经设定的Format，NullValue，DataSourceNullValue，FormatProvider属性会将Value属性会被重新格式化一遍。</p> 
<p></p> 
<p>*******DataGridView 用户输入时，单元格输入值的设定 </p> 
<p><br> 通过 DataGridView.CellParsing 事件可以设定用户输入的值。下面的示例：当输入英文文本内容的时候，立即被改变为大写。</p> 
<p>//CellParsing 事件处理方法 <br> private void DataGridView1_CellParsing(object sender, <br>     DataGridViewCellParsingEventArgs e) <br> { <br>     DataGridView dgv = (DataGridView)sender; <br> <br>     //单元格列为“Column1”时 <br>     if (dgv.Columns[e.ColumnIndex].Name == "Column1" &amp;&amp; <br>         e.DesiredType == typeof(string)) <br>     { <br>         //将单元格值设为大写 <br>         e.Value = e.Value.ToString().ToUpper(); <br>         //解析完毕 <br>         e.ParsingApplied = true; <br>     } <br> }</p> 
<p></p> 
<p></p> 
<p></p> 
<p><strong>二</strong>、<strong>行/列的操作</strong></p> 
<p><strong></strong></p> 
<p><strong></strong></p> 
<p><strong>*******</strong>DataGridView  不显示最下面的新行： </p> 
<p><br> 通常 DataGridView 的最下面一行是用户新追加的行（行头显示 * ）。如果不想让用户新追加行即不想显示该新行，可以将 DataGridView 对象的 AllowUserToAddRows 属性设置为 False。 <br> // 设置用户不能手动给 DataGridView1 添加新行 <br> DataGridView1.AllowUserToAddRows = false; <br> 但是，可以通过程序： DataGridViewRowCollection.Add 为 DataGridView 追加新行。 <br> <br> 补足： 如果 DataGridView 的 DataSource 绑定的是 DataView, 还可以通过设置 DataView.AllowAdd <br> 属性为 False 来达到同样的效果。</p> 
<p></p> 
<p>********DataGridView  判断新增行： </p> 
<p><br> DataGridView的AllowUserToAddRows属性为True时也就是允许用户追加新行的场合下，DataGridView的最后一行就是新追加的行(*行)。使用 DataGridViewRow.IsNewRow 属性可以判断哪一行是新追加的行。另外，通过DataGridView.NewRowIndex 可以获取新行的行序列号。在没有新行的时候，NewRowIndex = -1。 <br> If （DataGridView1.CurrentRow.IsNewRow） </p> 
<p>    Console.WriteLine("当前行为新追加行。") ;<br> Else <br>     Console.WriteLine("当前行不是新追加行。") ;</p> 
<p><br> *******DataGridView  行的用户删除操作的自定义：</p> 
<p><br> 1） 无条件的限制行删除操作。 <br> 默认时，DataGridView 是允许用户进行行的删除操作的。如果设置 DataGridView对象的AllowUserToDeleteRows属性为 False 时， 用户的行删除操作就被禁止了。 <br> // 禁止DataGridView1的行删除操作。 <br> DataGridView1.AllowUserToDeleteRows = false; <br> 但是，通过 DataGridViewRowCollection.Remove 还是可以进行行的删除。 <br> 补足： 如果 DataGridView 绑定的是 DataView 的话，通过 DataView.AllowDelete 也可以控制行的删除。 </p> 
<p><br> ********行删除时的条件判断处理。 </p> 
<p><br> 用户在删除行的时候，将会引发 DataGridView.UserDeletingRow 事件。 在这个事件里，可以判断条件并取消删除操作。 <br> // DataGridView1 的 UserDeletingRow 事件 <br> private void DataGridView1_UserDeletingRow( <br>     object sender, DataGridViewRowCancelEventArgs e) <br> { <br>     // 删除前的用户确认。 <br>     if (MessageBox.Show("确认要删除该行数据吗？", "删除确认", <br>         MessageBoxButtons.OKCancel, <br>         MessageBoxIcon.Question) != DialogResult.OK) <br>     { <br>         // 如果不是 OK，则取消。 <br>         e.Cancel = true; <br>     } <br> } </p> 
<p><br> ********DataGridView  行、列的隐藏和删除： </p> 
<p><br> 1） 行、列的隐藏 <br> // DataGridView1的第一列隐藏 <br> DataGridView1.Columns[0].Visible = false; <br> // DataGridView1的第一行隐藏 <br> DataGridView1.Rows[0].Visible = false; <br> 2） 行头、列头的隐藏 <br> // 列头隐藏 <br> DataGridView1.ColumnHeadersVisible = false; <br> // 行头隐藏 <br> DataGridView1.RowHeadersVisible = false; <br> 3） 行和列的删除 <br> ' 删除名为"Column1"的列 <br> DataGridView1.Columns.Remove("Column1"); <br> ' 删除第一列 <br> DataGridView1.Columns.RemoveAt(0); <br> ' 删除第一行 <br> DataGridView1.Rows.RemoveAt(0); <br> 4） 删除选中行 <br> foreach (DataGridViewRow r in DataGridView1.SelectedRows) <br> { <br>     if (!r.IsNewRow) <br>     { <br>         DataGridView1.Rows.Remove(r); <br>     } <br> } </p> 
<p><br> *********DataGridView 禁止列或者行的Resize： <br> <br> 1） 禁止所有的列或者行的Resize <br> // 禁止用户改变DataGridView1的所有列的列宽 <br> DataGridView1.AllowUserToResizeColumns = false; <br> <br> //禁止用户改变DataGridView1の所有行的行高 <br> DataGridView1.AllowUserToResizeRows = false; <br> 但是可以通过 DataGridViewColumn.Width 或者 DataGridViewRow.Height 属性设定列宽和行高。 </p> 
<p><br> *******2） 禁止指定行或者列的Resize </p> 
<p><br> // 禁止用户改变DataGridView1的第一列的列宽 <br> DataGridView1.Columns[0].Resizable = DataGridViewTriState.False; <br> // 禁止用户改变DataGridView1的第一列的行宽 <br> DataGridView1.Rows[0].Resizable = DataGridViewTriState.False; <br> 关于 NoSet <br> 当 Resizable 属性设为 DataGridViewTriState.NotSet 时， 实际上会默认以 DataGridView 的 AllowUserToResizeColumns 和  AllowUserToResizeRows 的属性值进行设定。比如： DataGridView.AllowUserToResizeColumns = False 且 Resizable 是 NoSet 设定时，Resizable = False 。 <br> 判断 Resizable 是否是继承设定了 DataGridView 的 AllowUserToResizeColumns 和  AllowUserToResizeRows 的属性值， 可以根据 State 属性判断。如果 State 属性含有 ResizableSet，那么说明没有继承设定。 <br> 3） 列宽和行高的最小值的设定 <br> // 第一列的最小列宽设定为 100 <br> DataGridView1.Columns[0].MinimumWidth = 100; <br> // 第一行的最小行高设定为 50 <br> DataGridView1.Rows[0].MinimumHeight = 50; <br> 4) 禁止用户改变行头的宽度以及列头的高度 <br> // 禁止用户改变列头的高度 <br> DataGridView1.ColumnHeadersHeightSizeMode = <br>     DataGridViewColumnHeadersHeightSizeMode.DisableResizing; <br> // 禁止用户改变行头的宽度 <br> DataGridView1.RowHeadersWidthSizeMode = <br>     DataGridViewRowHeadersWidthSizeMode.EnableResizing; <br> <br> *******DataGridView 列宽和行高自动调整的设定：</p> 
<p></p> 
<p>// 设定包括Header和所有单元格的列宽自动调整 <br> DataGridView1.AutoSizeColumnsMode = DataGridViewAutoSizeColumnsMode.AllCells; <br> // 设定包括Header和所有单元格的行高自动调整 <br> DataGridView1.AutoSizeRowsMode = DataGridViewAutoSizeRowsMode.AllCells; <br> AutoSizeColumnsMode 属性的设定值枚举请参照 msdn 的 DataGridViewAutoSizeRowsMode 说明。 <br> 2）指定列或行自动调整 <br> // 第一列自动调整 <br> DataGridView1.Columns[0].AutoSizeMode =DataGridViewAutoSizeColumnMode.DisplayedCells; <br> AutoSizeMode 设定为 NotSet  时， 默认继承的是  DataGridView.AutoSizeColumnsMode 属性。 <br> 3) 设定列头的高度和行头的宽度自动调整 </p> 
<p>// 设定列头的宽度可以自由调整 <br> DataGridView1.ColumnHeadersHeightSizeMode = <br>     DataGridViewColumnHeadersHeightSizeMode.AutoSize; <br> // 设定行头的宽度可以自由调整 <br> DataGridView1.RowHeadersWidthSizeMode = <br>     DataGridViewRowHeadersWidthSizeMode.AutoSizeToAllHeaders; <br> 4） 随时自动调整 <br> a， 临时的，让列宽自动调整，这和指定AutoSizeColumnsMode属性一样。 </p> 
<p>// 让 DataGridView1 的所有列宽自动调整一下。 <br> DataGridView1.AutoResizeColumns(DataGridViewAutoSizeColumnsMode.AllCells); <br> // 让 DataGridView1 的第一列的列宽自动调整一下。 <br> DataGridView1.AutoResizeColumn(0, DataGridViewAutoSizeColumnMode.AllCells);上面调用的 AutoResizeColumns 和 AutoResizeColumn 当指定的是DataGridViewAutoSizeColumnMode.AllCells 的时候， 参数可以省略。即： <br> DataGridView1.AutoResizeColumn(0) 和 DataGridView1.AutoResizeColumns() <br> b，临时的，让行高自动调整 <br> // 让 DataGridView1 的所有行高自动调整一下。 <br> DataGridView1.AutoResizeRows(DataGridViewAutoSizeRowsMode.AllCells); <br> //让 DataGridView1 的第一行的行高自动调整一下。 <br> DataGridView1.AutoResizeRow(0, DataGridViewAutoSizeRowMode.AllCells);上面调用的 AutoResizeRows 和 AutoResizeRow 当指定的是DataGridViewAutoSizeRowMode.AllCells 的时候， 参数可以省略。即：DataGridView1.AutoResizeRow (0) 和 DataGridView1.AutoResizeRows() <br> c，临时的，让行头和列头自动调整 <br> // 列头高度自动调整 <br> DataGridView1.AutoResizeColumnHeadersHeight(); <br> // 行头宽度自动调整 <br> DataGridView1.AutoResizeRowHeadersWidth( <br>     DataGridViewRowHeadersWidthSizeMode.AutoSizeToAllHeaders); <br> 关于性能： <br> 通过 AutoSizeColumnsMode 或者 AutoSizeRowsMode 属性所指定的单元格进行自动调整时，如果调整次数过于多那么将可能导致性能下降，尤其是在行和列数比较多的情况下。在这时用 DisplayedCells 代替 AllCells 能减少非所见的单元格的调整，从而提高性能。 </p> 
<p></p> 
<p>******DataGridView 冻结列或行</p> 
<p></p> 
<p>1） 列冻结 <br> DataGridViewColumn.Frozen 属性为 True 时， 该列左侧的所有列被固定， 横向滚动时固定列不随滚动条滚动而左右移动。这对于重要列固定显示很有用。</p> 
<p>// DataGridView1的左侧2列固定 <br> DataGridView1.Columns[1].Frozen = true; <br> 但是，DataGridView.AllowUserToOrderColumns = True 时，固定列不能移动到非固定列， 反之亦然。 <br> 2） 行冻结 <br> DataGridViewRow.Frozen 属性为 True 时， 该行上面的所有行被固定， 纵向滚动时固定行不随滚动条滚动而上下移动。</p> 
<p>// DataGridView1 的上3行固定 <br> DataGridView1.Rows[2].Frozen = true;</p> 
<p></p> 
<p>******DataGridView 列顺序的调整</p> 
<p></p> 
<p>设定 DataGridView 的 AllowUserToOrderColumns 为 True 的时候， 用户可以自由调整列的顺序。 <br> 当用户改变列的顺序的时候，其本身的 Index 不会改变，但是 DisplayIndex 改变了。你也可以通过程序改变 DisplayIndex 来改变列的顺序。 列顺序发生改变时会引发 ColumnDisplayIndexChanged 事件： </p> 
<p>// DataGridView1的ColumnDisplayIndexChanged事件处理方法 <br> private void DataGridView1_ColumnDisplayIndexChanged(object sender, <br>     DataGridViewColumnEventArgs e) <br> { <br>     Console.WriteLine("{0} 的位置改变到 {1} ", <br>         e.Column.Name, e.Column.DisplayIndex); <br> }</p> 
<p></p> 
<p>********DataGridView 新加行的默认值的设定 <br> <br> 需要指定新加行的默认值的时候，可以在DataGridView.DefaultValuesNeeded事件里处理。在该事件中处理除了可以设定默认值以外，还可以指定某些特定的单元格的ReadOnly属性等。<br> // DefaultValuesNeeded 事件处理方法 <br> private void DataGridView1_DefaultValuesNeeded(object sender, <br>     DataGridViewRowEventArgs e) <br> { <br>     // 设定单元格的默认值 <br>     e.Row.Cells["Column1"].Value = 0; <br>     e.Row.Cells["Column2"].Value = "-"; <br> }</p> 
<p></p> 
<p></p> 
<p><strong>三、针对datagridview全局属性的设置</strong></p> 
<p><strong></strong></p> 
<p><strong></strong></p> 
<p><strong></strong></p> 
<p><strong></strong></p> 
<p><strong></strong></p> 
<p><strong>*******</strong>使用 EditMode 属性 </p> 
<p><br> DataGridView.EditMode 属性被设置为 DataGridViewEditMode.EditProgrammatically 时，用户就不能手动编辑单元格的内容了。但是可以通过程序，调用 DataGridView.BeginEdit 方法，使单元格进入编辑模式进行编辑。 <br> DataGridView1.EditMode = DataGridViewEditMode.EditProgrammatically; </p> 
<p></p> 
<p>*******根据条件设定单元格的不可编辑状态 </p> 
<p><br> 当一个一个的通过单元格坐标设定单元格 ReadOnly 属性的方法太麻烦的时候，你可以通过 CellBeginEdit 事件来取消单元格的编辑。</p> 
<p></p> 
<p>*******// CellBeginEdit 事件处理方法 </p> 
<p><br> private void DataGridView1_CellBeginEdit(object sender, <br>     DataGridViewCellCancelEventArgs e) <br> { <br>     DataGridView dgv = (DataGridView)sender; <br>     //是否可以进行编辑的条件检查 <br>     if (dgv.Columns[e.ColumnIndex].Name == "Column1" &amp;&amp; <br>         !(bool)dgv["Column2", e.RowIndex].Value) <br>     { <br>         // 取消编辑 <br>         e.Cancel = true; <br>     } <br> } </p> 
<p><br> ********DataGridView 剪切板的操作 </p> 
<p><br> DataGridView.ClipboardCopyMode 属性被设定为 DataGridViewClipboardCopyMode.Disable 以外的情况时，「Ctrl + C」 按下的时候，被选择的单元格的内容会拷贝到系统剪切板内。格式有： Text， UnicodeText，Html， CommaSeparatedValue。可以直接粘贴到 Excel 内。 <br> <br> ClipboardCopyMode 还可以设定 Header部分是否拷贝： EnableAlwaysIncludeHeaderText 拷贝Header部分、EnableWithoutHeaderText 则不拷贝。默认是 EnableWithAutoHeaderText ， Header 如果选择了的话，就拷贝。 <br> 1） 编程方式实现剪切板的拷贝 <br> Clipboard.SetDataObject(DataGridView1.GetClipboardContent()) <br> 2) DataGridView 的数据粘贴 <br> 实现剪切板的拷贝比较容易，但是实现 DataGridView 的直接粘贴就比较难了。「Ctrl + V」按下进行粘贴时，DataGridView 没有提供方法，只能自己实现。 <br> 以下，是粘贴时简单的事例代码，将拷贝数据粘贴到以选择单元格开始的区域内。</p> 
<p>//当前单元格是否选择的判断 <br> if (DataGridView1.CurrentCell == null) <br>     return; <br> int insertRowIndex = DataGridView1.CurrentCell.RowIndex; <br> // 获取剪切板的内容，并按行分割 <br> string pasteText = Clipboard.GetText(); <br> if (string.IsNullOrEmpty(pasteText)) <br>     return; <br> pasteText = pasteText.Replace(" ", " "); <br> pasteText = pasteText.Replace(' ', ' '); <br> pasteText.TrimEnd(new char[] { ' ' }); <br> string[] lines = pasteText.Split(' '); <br> <br> bool isHeader = true; <br> foreach (string line in lines) <br> { <br>     // 是否是列头 <br>     if (isHeader) <br>     { <br>         isHeader = false; <br>         continue; <br>     } <br>     // 按 Tab 分割数据 <br>     string[] vals = line.Split(' '); <br>     // 判断列数是否统一 <br>     if (vals.Length - 1 != DataGridView1.ColumnCount) <br>         throw new ApplicationException("粘贴的列数不正确。"); <br>     DataGridViewRow row = DataGridView1.Rows[insertRowIndex]; <br>     // 行头设定 <br>     row.HeaderCell.Value = vals[0]; <br>     // 单元格内容设定 <br>     for (int i = 0; i &lt; row.Cells.Count; i++) <br>     { <br>         row.Cells[i].Value = vals[i + 1]; <br>     } <br> <br>     //  DataGridView的行索引+1 <br>     insertRowIndex++; <br> } </p> 
<p></p> 
<p>*******DataGridView 的右键菜单（ContextMenuStrip） </p> 
<p><br> DataGridView, DataGridViewColumn, DataGridViewRow, DataGridViewCell 有 ContextMenuStrip 属性。可以通过设定 ContextMenuStrip 对象来控制 DataGridView 的右键菜单的显示。 DataGridViewColumn 的 ContextMenuStrip 属性设定了 除了列头以外的单元格的右键菜单。 DataGridViewRow 的 ContextMenuStrip 属性设定了除了行头以外的单元格的右键菜单。DataGridViewCell 的  ContextMenuStrip 属性设定了指定单元格的右键菜单。 </p> 
<p>// DataGridView 的 ContextMenuStrip 设定 <br> DataGridView1.ContextMenuStrip = this.ContextMenuStrip1; <br> // 列的 ContextMenuStrip 设定 <br> DataGridView1.Columns[0].ContextMenuStrip = this.ContextMenuStrip2; <br> // 列头的 ContextMenuStrip 设定 <br> DataGridView1.Columns[0].HeaderCell.ContextMenuStrip = this.ContextMenuStrip2; <br> // 行的 ContextMenuStrip 设定 <br> DataGridView1.Rows[0].ContextMenuStrip = this.ContextMenuStrip3; <br> // 单元格的 ContextMenuStrip 设定 <br> DataGridView1[0, 0].ContextMenuStrip = this.ContextMenuStrip4; <br> 对于单元格上的右键菜单的设定，优先顺序是：　Cell &gt; Row &gt; Column &gt; DataGridView </p> 
<p><br> *****CellContextMenuStripNeeded、RowContextMenuStripNeeded　事件 </p> 
<p><br> 利用　CellContextMenuStripNeeded　事件可以设定单元格的右键菜单，尤其但需要右键菜单根据单元格值的变化而变化的时候。比起使用循环遍历，使用该事件来设定右键菜单的效率更高。但是，在DataGridView使用了DataSource绑定而且是VirtualMode的时候，该事件将不被引发。 <br> //　CellContextMenuStripNeeded事件处理方法 <br> private void DataGridView1_CellContextMenuStripNeeded(object sender, <br>     DataGridViewCellContextMenuStripNeededEventArgs e) <br> { <br>     DataGridView dgv = (DataGridView)sender; <br>     if (e.RowIndex &lt; 0) <br>     { <br>         //　列头的ContextMenuStrip设定 <br>         e.ContextMenuStrip = this.ContextMenuStrip1; <br>     } <br>     else if (e.ColumnIndex &lt; 0) <br>     { <br>         //　行头的ContextMenuStrip设定 <br>         e.ContextMenuStrip = this.ContextMenuStrip2; <br>     } <br>     else if (dgv[e.ColumnIndex, e.RowIndex].Value is int) <br>     { <br>         //　如果单元格值是整数时 <br>         e.ContextMenuStrip = this.ContextMenuStrip3; <br>     } <br> } <br> 同样，可以通过　RowContextMenuStripNeeded　事件来设定行的右键菜单。</p> 
<p>//　RowContextMenuStripNeeded事件处理方法 <br> private void DataGridView1_RowContextMenuStripNeeded(object sender, <br>     DataGridViewRowContextMenuStripNeededEventArgs e) <br> { <br>     DataGridView dgv = (DataGridView)sender; <br>     //　当"Column1"列是Bool型且为True时、设定其的ContextMenuStrip <br>     object boolVal = dgv["Column1", e.RowIndex].Value; <br>     Console.WriteLine(boolVal); <br>     if (boolVal is bool &amp;&amp; (bool)boolVal) <br>     { <br>         e.ContextMenuStrip = this.ContextMenuStrip1; <br>     } <br> } <br> <br> CellContextMenuStripNeeded　事件处理方法的参数中、「e.ColumnIndex=-1」表示行头、「e.RowIndex=-1」表示列头。RowContextMenuStripNeeded则不存在「e.RowIndex=-1」的情况。</p> 
<p></p> 
<p></p> 
<p><strong>四、针对触发事件的一些介绍</strong></p> 
<p><strong></strong></p> 
<p>我认为只要记住常用的即可，比如鼠标的操作，一些常见的点击触发事件；比如_CellParsing（）一般在编辑状态结束的时候发生。</p> 
<p>其他的用到的时候算查即可，时间长了掌握的也就多了。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4d01e6ff3bacaf1926ea4935ce721705/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Maven常用命令(转载)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4d7c55e5b3cd38c45bdec28bdf502b9e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">axis2开发webservice知识整理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>