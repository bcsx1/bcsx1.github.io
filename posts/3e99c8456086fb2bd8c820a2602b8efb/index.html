<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端开发新工具-vite - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="前端开发新工具-vite" />
<meta property="og:description" content="vite 是什么
vite——一个由 vue 作者尤雨溪专门为 vue 打造的开发利器，其目的是使 vue 项目的开发更加简单和快速。
vite 究竟有什么作用？用 vite 文档上的介绍，它具有以下特点：
快速的冷启动 即时的热模块更新 真正的按需编译 以上三个优点，社区也早有对应的解决方案，比如快速的冷启动可以借助各种 cli ：vue-cli、create-react-app 等等，热更新就更不用说了，不过按需编译需要开发者自行在代码中使用 impor(‘xx.js’) 实现， 那么 vite 有什么特别的地方呢？用作者在微博上的原话：
Vite，一个基于浏览器原生 ES imports 的开发服务器。利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。同时不仅有 Vue 文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。针对生产环境则可以把同一份代码用 rollup 打。虽然现在还比较粗糙，但这个方向我觉得是有潜力的，做得好可以彻底解决改一行代码等半天热更新的问题。[ ]()
可以看到 vite 主要特色是基于浏览器原生的 ES Module 来开发，从而实现按需编译，也就没有打包这个概念——因为需要什么资源直接在浏览器里引入即可，不过基于浏览器原生 ES module 来开发 web 应用也不是什么新鲜事，snowpack 也是做这个事情，而且它可以用在所有项目上，不过目前此项目社区中没有流行的使用起来，好在 vue 在 web 开发领域有着极大的话语权，vite 的出现可以说又会让利用 ES module 开发火一阵子。
有趣的是 vite 算是革了 webpack 的命了（生产环境用 rollup），所以 webpack 的开发者直接喊大哥了…
image.png
vite 的使用方式
同其他开发工具一样，vite 提供了用 npm 或者 yarn 一建生成项目的途径，使用 yarn 在终端执行：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/3e99c8456086fb2bd8c820a2602b8efb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-29T09:19:41+08:00" />
<meta property="article:modified_time" content="2020-09-29T09:19:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端开发新工具-vite</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>vite 是什么</p> 
<p>vite——一个由 vue 作者尤雨溪专门为 vue 打造的开发利器，其目的是使 vue 项目的开发更加简单和快速。</p> 
<p>vite 究竟有什么作用？用 vite 文档上的介绍，它具有以下特点：</p> 
<pre><code>快速的冷启动
即时的热模块更新
真正的按需编译
</code></pre> 
<p>以上三个优点，社区也早有对应的解决方案，比如快速的冷启动可以借助各种 cli ：vue-cli、create-react-app 等等，热更新就更不用说了，不过按需编译需要开发者自行在代码中使用 impor(‘xx.js’) 实现， 那么 vite 有什么特别的地方呢？用作者在微博上的原话：</p> 
<pre><code>Vite，一个基于浏览器原生 ES imports 的开发服务器。利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。同时不仅有 Vue 文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。针对生产环境则可以把同一份代码用 rollup 打。虽然现在还比较粗糙，但这个方向我觉得是有潜力的，做得好可以彻底解决改一行代码等半天热更新的问题。[
</code></pre> 
<p>]()</p> 
<p>可以看到 vite 主要特色是基于浏览器原生的 ES Module 来开发，从而实现按需编译，也就没有打包这个概念——因为需要什么资源直接在浏览器里引入即可，不过基于浏览器原生 ES module 来开发 web 应用也不是什么新鲜事，snowpack 也是做这个事情，而且它可以用在所有项目上，不过目前此项目社区中没有流行的使用起来，好在 vue 在 web 开发领域有着极大的话语权，vite 的出现可以说又会让利用 ES module 开发火一阵子。</p> 
<p>有趣的是 vite 算是革了 webpack 的命了（生产环境用 rollup），所以 webpack 的开发者直接喊大哥了…<br> image.png<br> vite 的使用方式</p> 
<p>同其他开发工具一样，vite 提供了用 npm 或者 yarn 一建生成项目的途径，使用 yarn 在终端执行：</p> 
<p>$ yarn create vite-app <br> $ cd <br> $ yarn<br> $ yarn dev</p> 
<p>即可初始化一个 vite 项目，生成的项目结构非常简洁：</p> 
<p>|____node_modules<br> |____App.vue // vue 应用入口<br> |____index.html // 页面<br> |____package.json</p> 
<p>运行 yarn dev 即可开发 ，打开 package.json 发现，如果 dev 只需要执行 vite 命令，而 build需要使用 vite build。<br> 如何调试 vite</p> 
<p>在 package.json scripts 值里添加一行 debug 命令：</p> 
<p>{<!-- --><br> “scripts”: {<!-- --><br> …<br> “debug”: “node --inspect-brk=5858 ./node_modules/vite/dist/cli.js”<br> }<br> }</p> 
<p>这里使用 node 运行 node_modules 里 vite 包而不是用 npm scripts 的方式，这是 node 应用的调试方式，再配置 vscode 的 launch.json ，指定 vscode 调试 npm scripts 的方式，设置端口、runtime 参数等，就可以调试起来了。</p> 
<p>{<!-- --><br> “type”: “node”,<br> “request”: “launch”,<br> “name”: “Launch via NPM”,<br> “runtimeExecutable”: “npm”,<br> “runtimeArgs”: [“run-script”, “debug”],<br> “port”: 5858,<br> “skipFiles”: ["&lt;node_internals&gt;/**"]<br> }</p> 
<p>由于 node_modules 里的 vite 已经是编译后的代码了，建议 clone 一份原始的 repo 用来参考，两两结合使得执行过程更明确。<br> vite 链路分析<br> 命令解析</p> 
<p>这部分代码在 https://github.com/vuejs/vite/blob/master/src/node/cli.ts 里，主要内容是借助 minimist —— 一个轻量级的命令解析工具解析用户命令，vite 没有使用 commander 这样通用的命令行解决方案，而是近乎裸写了一份，解析命令参数的函数是 parseArgs ，精简后的代码片段如下：</p> 
<p>function parseArgs() {<!-- --><br> const argv = require(‘minimist’)(process.argv.slice(2));<br> // 设置 DEBUG 环境变量<br> if (argv.debug) {<!-- --><br> process.env.DEBUG = <code>vite:</code> + (argv.debug === true ? ‘*’ : argv.debug);<br> }<br> // 遍历 jsx 解析<br> if (argv[‘jsx-factory’]) {<!-- --><br> (argv.jsx || (argv.jsx = {})).factory = argv[‘jsx-factory’];<br> }<br> if (argv[‘jsx-fragment’]) {<!-- --><br> (argv.jsx || (argv.jsx = {})).fragment = argv[‘jsx-fragment’];<br> }<br> // 解析 runServe 或者 runBuild<br> if (argv.<em>[0]) {<!-- --><br> argv.command = argv.</em>[0];<br> }<br> return argv;<br> }</p> 
<p>通过源码和 README，发现 vite 额外添加了对于 jsx 项目的支持，理论上 vite 的原理并不限制只能应用在 vue 上，作者解释因为 react 没有提供 ES module 的支持所以不能在 react 项目里使用，不过可以通过社区中的 ES module 版本的 react 代替。另外，vue3 的 jsx transform 依然在 wip 中，所以这里的支持是预留的。</p> 
<p>拿到 argv 后，会根据 argv.command 的值判断是启动开发服务器或者执行生产构建命令。<br> 值得一提的是，在这个文件中，找到了一个 resolveConfig 方法，这个方法的作用是获取项目下的 vite.config.js，这是在为后续的更多的配置内容做准备。<br> server</p> 
<p>这部分代码在 https://github.com/vuejs/vite/blob/master/src/node/server/index.ts 里，对外暴露一个 createServer 方法，与常见的开发工具一样，vite 使用 koa 作 web 服务器，使用 clmloader 创建了一个监听文件改动的 watcher，同时实现了一个插件机制，以一个 context 对象，将 koa-app 和 watcher 以及其他辅助工具注入到每个 plugin 中，plugin 依次往 context 里的各部分监听事件，每个 plugin 处理不同的事情，这样的好处是职责分明，结构清晰。</p> 
<p>context 组成如下：<br> image.png<br> plugin</p> 
<p>上文我们说到 plugin，那么有哪些 plugin 呢？它们分别是：</p> 
<pre><code>用户注入 plugins —— 自定义 plugin
hmrPlugin —— 处理 hmr 
moduleRewritePlugin —— 重写 script 和 html 
moduleResolvePlugin —— 解析资源路径中含有 @modules 的模块
vuePlugin —— 处理 vue 单文件组件
esbuildPlugin —— 使用 esbuild 处理资源
assetPathPlugin —— 处理静态资源（js）路径
serveStaticPlugin —— 使用 koa-static 托管静态资源
</code></pre> 
<p>我们来看 plugin 的实现方式，开发一个用来拦截 json 文件 plugin 可以这么实现：</p> 
<p>interface ServerPluginContext {<!-- --><br> root: string<br> app: Koa<br> server: Server<br> watcher: HMRWatcher<br> resolver: InternalResolver<br> config: ServerConfig<br> }</p> 
<p>type ServerPlugin = （ctx:ServerPluginContext）=&gt; void;</p> 
<p>const JsonInterceptPlugin:ServerPlugin = ({app})=&gt;{<!-- --><br> app.use(async (ctx, next) =&gt; {<!-- --><br> await next()<br> if (ctx.path.endsWith(’.json’) &amp;&amp; ctx.body) {<!-- --><br> ctx.type = ‘js’<br> ctx.body = <code>export default json</code><br> }<br> })<br> }</p> 
<p>vite 背后的原理都在 plugin 里，这里不再一一解释每个 plugin 的作用，会放在下文背后的原理中一并讨论。<br> build</p> 
<p>这部分代码在 https://github.com/vuejs/vite/blob/master/src/node/build/index.ts 中，build 目录的结构虽然与 server 相似，导出一个 build 方法，同样也有许多 plugin ，不过这些 plugin 与 server 中的用途不一样，因为 build 使用了 rollup ，这些 plugin 也是为 rollup 打包开发的 plugin ，本文就不再多提。<br> vite 运行原理<br> ES module</p> 
<p>要了解 vite 的运行原理，首先要知道什么是 ES module，目前流览器对其的支持如下：<br> image.png<br> 可以看到主流的浏览器（IE11除外）均已经支持，其最大的特点是在浏览器端使用 export import 的方式导入和导出模块，在 script 标签里设置 type=“module” ，然后使用 ES module。</p> 
<p>当 html 里嵌入上面的 script 标签时候，浏览器会发起 http 请求，请求 htttp server 托管的 bar.js ，在 bar.js 里，我们使用 named export 导出模块：</p> 
<p>// bar.js<br> export const bar = ‘bar’;</p> 
<p>ES module 在 vite 中的作用</p> 
<p>打开上文中启动的 vite 项目，访问 view-source 可以发现 html 里有段这样的代码：</p> 
<p>从这段代码中，我们能 get 到以下几点信息：</p> 
<pre><code>从 http://localhost:3000/@modules/vue 中获取 createApp 这个方法
从 http://localhost:3000/App.vue 中获取应用入口
使用 createApp 创建应用并挂载节点
</code></pre> 
<p>createApp 是 vue3.0 的 api，只需知道这是创建了 vue 应用即可，vite 利用 ES module，把 “创建 vue 应用” 这个本来需要通过 webpack 打包后才能执行的代码直接放在浏览器里执行，这么做是为了：</p> 
<pre><code>去掉打包步骤
实现按需加载
</code></pre> 
<p>去掉打包步骤</p> 
<p>去掉打包步骤非常好理解，打包的概念无非是开发者利用工具将应用各个模块集合在一起形成 bundle，以一定规则读取模块的代码——以便在不支持模块化的浏览器里使用。而且为了加载各模块，打包工具会实现胶水代码用来连接和调用模块，比如 webpack 使用 map 存放模块 id 和路径，使用 <strong>webpack_require</strong> 方法获取模块导出，因为浏览器支持了模块化，所以打包这一步就可以省略了。<br> 实现按需打包</p> 
<p>前面说到，webpack 之类的打包工具会将模块提前打包进 bundle 里，但打包本身是静态的——不管某个模块的代码是否执行到，这个模块都要打包到 bundle 里。这样的坏处就是随着项目越来越大打包后的 bundle 也越来越大。</p> 
<p>开发者为了减少 bundle 大小，会使用动态引入 import() 的方式异步的加载模块（ 被引入模块依然需要提前打包)，又或者使用 tree shaking 等方式尽力的去掉未引用的模块，然而这些方式都不如 vite 的优雅，vite 可以只在需要某个模块的时候动态（借助 import() ）的引入它，而不需要提前打包，虽然只能用在开发环境，不过这就够了！<br> vite 如何处理模块</p> 
<p>既然 vite 使用 ES module 在浏览器里使用模块，那么这一步究竟是怎么做的？<br> 上文提到过，ES moudle 使用模块是通过发送 http 请求实现的，所以 vite 必须提供一个静态资源服务器去代理这些模块，上文中提到的 koa 就是做这个事情，其通过对请求路径的分析获取资源的内容返回给浏览器，不过 vite 对于模块访问做了特殊处理。<br> @modules 是什么？</p> 
<p>通过工程下的 index.html 和开发环境下的 html 源文件对比，发现 script 标签里的内容发生了改变，由</p> 
<p>变成了</p> 
<p>上面是 web 项目里标准的 ES module 用法，从 node_modules 里导入一个 vue 的 npm 包，然后由 webpack 通过解析 AST 寻址拿到包的实际地址进行打包，但是在浏览器下无法直接访问 node_modules（只能使用 http请求），所以 vite 对 import 都做了一层处理，其过程如下：</p> 
<pre><code>在 koa 中间件里获取请求 body
通过 es-module-lexer 解析资源 ast 拿到 import 的内容
判断 import 的资源是否是绝对路径，绝对视为 npm 模块
返回处理后的资源路径："vue" =&gt; "/@modules/vue"
</code></pre> 
<p>这部分代码在 serverPluginModuleRewrite 这个 plugin 中。</p> 
<p>为什么需要 @modules？</p> 
<p>原则上这里并不需要对路径进行特殊转换，私以为这是比较巧妙的做法，把文件路径的 rewrite 都写在同一个 plugin 里，这样后续如果加入更多逻辑，改动起来不会影响其他 plugin，其他 plugin 拿到资源路径都是 ‘@modules’ ，比如说后续可能加入 alias 的配置：就像 webpack 一样——可以将项目里的本地文件配置成绝对路径的引用。<br> 怎么返回模块内容</p> 
<p>这部分内容相对来说就很简单了，通过下一个 koa 中间件，用正则匹配到路径上带有 ‘@modules’ 的资源，再通过 require(‘xxx’) 拿到 npm 包的导出最后返回内容，在这里有个很重要的一点，那就是对 vue es 包的特殊处理，比如：</p> 
<p>需要 @vue/runtime-dom 这个包的内容，不能直接通过 require(’<code>@vue/runtime-dom'）得到，而需要通过 require('@vue/runtime-dom/dist/runtime-dom.esm-bundler.js'</code> 的方式</p> 
<p>为什么需要特殊处理 vue es 包？前面我们提到了以往开发需要使用 webpack 之类的打包工具，而 webpack 工具链除了将模块组装到一起形成 bundle，它还可以使得不同模块规范互相引用，比如：</p> 
<pre><code>    ES module (esm) 导入cjs
    CommonJS (cjs) 导入esm
    dynamic import 导入 esm
    dynamic import 导入 cjs
</code></pre> 
<p>目前大部分模块都没有设置默认导出 es module，而是导出了 cjs 的包，vue3.0 也不例外，所以这里要特殊处理一下，关于 es module 的坑可以看这篇文章。</p> 
<p>看到这里，其实聪明的你肯定也想到了，既然 vue3.0 需要额外处理才能拿到 esm 的包内容，那么其他日常使用的 npm 包是不是也同样需要支持？答案是肯定的，但是 vite 目前还没有处理好这块，目前在 vite 项目里使用 lodash 还是会报错的。<br> image.png</p> 
<p>要完全解决获取 esm 包的坑，任重而道远，这部分代码在：serverPluginModuleResolve 这个 plugin 中。<br> vite 如何编译模块</p> 
<p>因为 vite 为 vue3.0 开发，所以这里的编译指的也是编译 vue 单文件组件了，其他 es 模块可以直接导入内容。<br> SFC</p> 
<p>vue 单文件组件（简称 SFC） 是 vue 的一个亮点，前端届对 SFC 褒贬不一，喜欢的人非常喜欢，讨厌的人非常讨厌。个人看来，SFC 是利大于弊的，虽然 SFC 带来了额外的开发工作量，比如为了解析 template 要写模板解析器，还要在 SFC 中解析出逻辑和样式，在 vscode 里要写 vscode 插件，在 webpack 里要写 vue-loader，但是对于使用方来说可以在一个文件里可以同时写 template、js、style，省了各文件互相跳转。</p> 
<p>与 vue-loader 相似，vite 在解析 vue 文件的时候也要分别处理多次，我们打开浏览器的 network，可以看到：<br> image.png</p> 
<p>一个请求 query 中什么都没有，另 2 个请求分别通过在 query 里指定了 type 为 style 和 template。</p> 
<p>先来看看如何将一个 SFC 变成多个请求，我们从第一次请求开始分析，简化后的代码如下：</p> 
<p>function vuePlugin({app}){<!-- --><br> app.use(async (ctx, next) =&gt; {<!-- --><br> if (!ctx.path.endsWith(’.vue’) &amp;&amp; !ctx.vue) {<!-- --><br> return next()<br> }</p> 
<pre><code>const query = ctx.query
// 获取文件名称
let filename = resolver.requestToFile(publicPath)

// 解析器解析 SFC
const descriptor = await parseSFC(root, filename, ctx.body)
if (!descriptor) {
  ctx.status = 404
  return
}
// 第一次请求 .vue
if (!query.type) {
  if (descriptor.script &amp;&amp; descriptor.script.src) {
    filename = await resolveSrcImport(descriptor.script, ctx, resolver)
  }
  ctx.type = 'js'
  // body 返回解析后的代码
  ctx.body = await compileSFCMain(descriptor, filename, publicPath)
}

// ...
</code></pre> 
<p>}</p> 
<p>在 compileSFCMain 中是一段长长的 generate 代码：</p> 
<p>function compileSFCMain(descriptor, filePath: string, publicPath: string) {<!-- --><br> let code = ‘’<br> if (descriptor.script) {<!-- --><br> let content = descriptor.script.content<br> code += content.replace(<code>export default</code>, ‘const __script =’)<br> } else {<!-- --><br> code += <code>const __script = {}</code><br> }</p> 
<p>if (descriptor.styles) {<!-- --><br> code += <code>\nimport { updateStyle } from "${hmrClientId}"\n</code><br> descriptor.styles.forEach((s, i) =&gt; {<!-- --><br> const styleRequest = publicPath + <code>?type=style&amp;index=${i}</code><br> code += <code>\nupdateStyle("${id}-${i}", ${JSON.stringify(styleRequest)})</code><br> })<br> if (hasScoped) {<!-- --><br> code += <code>\n__script.__scopeId = "data-v-${id}"</code><br> }<br> }</p> 
<p>if (descriptor.template) {<!-- --><br> code += <code>\nimport { render as __render } from ${JSON.stringify( publicPath +</code>?type=template<code>)}</code><br> code += <code>\n__script.render = __render</code><br> }<br> code += <code>\n__script.__hmrId = ${JSON.stringify(publicPath)}</code><br> code += <code>\n__script.__file = ${JSON.stringify(filePath)}</code><br> code += <code>\nexport default __script</code><br> return code<br> }</p> 
<p>直接看 generate 后的代码：</p> 
<p>import { updateStyle } from “/vite/hmr”<br> updateStyle(“c44b8200-0”, “/App.vue?type=style&amp;index=0”)<br> __script.__scopeId = “data-v-c44b8200”<br> import { render as __render } from “/App.vue?type=template”<br> __script.render = __render<br> __script.__hmrId = “/App.vue”<br> __script.__file = “/Users/muou/work/playground/vite-app/App.vue”<br> export default __script</p> 
<p>出现了 vite/hmr 的导入，vite/hmr 具体内容我们下文再分析，从这段代码中可以看到，对于 style ，vite 使用 updateStyle 这个方法处理，updateStyle 内容非常简单，这里就不贴代码了，就做了一件事：通过创建 link 元素，设置了它的 href，href 指向带 type=‘style’ 的 .vue 文件， 然后往 document 里塞入一段 css， 对于 template 直接使用 import 导入带 type=’<code>template</code>’ 的 .vue 文件，这两种方式都会使得浏览器发起 http 请求，这样就能被 koa 中间件捕获到了，所以就形成了上文我们看到的：对一个 .vue 文件处理三次的情景。</p> 
<p>这部分代码在：serverPluginVue 这个 plugin 里。<br> vite 热更新</p> 
<p>上文中出现了 vite/hmr ，这就是 vite 处理热更新的关键，在 serverPluginHmr plugin 中，对于 path 等于 vite/hmr 做了一次判断：</p> 
<p>app.use(async (ctx, next) =&gt; {<!-- --><br> if (ctx.path === ‘/vite/hmr’) {<!-- --><br> ctx.type = ‘js’<br> ctx.status = 200<br> ctx.body = hmrClient<br> }<br> }</p> 
<p>hmrClient 是 vite 热更新的客户端代码，需要在浏览器里执行，这里先来说说通用的热更新实现，热更新一般需要四个部分：</p> 
<pre><code>通过 watcher 监听文件改动
通过 server 端编译资源，并推送新资源信息给 client 。
需要框架支持组件 rerender/reload 
client 收到资源信息，执行框架 rerender 逻辑。
</code></pre> 
<p>vite 也不例外同样有这四个部分，其中客户端代码在：client.ts 里，服务端代码在 serverPluginHmr 里，对于 vue 组件的更新，通过 vue3.0 中的 HMRRuntime 处理的。<br> client 端</p> 
<p>在 client 端， WebSocket 监听了一些更新的类型，然后分别处理，它们是：</p> 
<pre><code>vue-reload —— vue 组件更新：通过 import 导入新的 vue 组件，然后执行 HMRRuntime.reload
vue-rerender —— vue template 更新：通过 import 导入新的 template ，然后执行 HMRRuntime.rerender
vue-style-update —— vue style 更新：直接插入新的 stylesheet 
style-update —— css 更新：document 插入新的 stylesheet
style-remove —— css 移除：document 删除 stylesheet
js-update  —— js 更新：直接执行
full-reload —— 页面 roload：使用 window.reload 刷新页面
</code></pre> 
<p>server 端</p> 
<p>在 server 端，通过 watcher 监听页面改动，根据文件类型判断是 js Reload 还是 Vue Reload：</p> 
<p>watcher.on(‘change’, async (file) =&gt; {<!-- --><br> const timestamp = Date.now()<br> if (file.endsWith(’.vue’)) {<!-- --><br> handleVueReload(file, timestamp)<br> } else if (<br> file.endsWith(’.module.css’) ||<br> !(file.endsWith(’.css’) || cssTransforms.some((t) =&gt; t.test(file, {})))<br> ) {<!-- --><br> // everything except plain .css are considered HMR dependencies.<br> // plain css has its own HMR logic in ./serverPluginCss.ts.<br> handleJSReload(file, timestamp)<br> }<br> })</p> 
<p>在 handleVueReload 方法里，会使用解析器拿到当前文件的 template/script/style ，并且与缓存里的上一次解析的结果进行比较，如果 template 发生改变就执行 vue-rerender，如果 style 发生改变就执行 vue-style-update，简化后的逻辑如下：</p> 
<p>async function handleVueReload(<br> file<br> timestamp,<br> content<br> ) {<!-- --><br> // 获取缓存<br> const cacheEntry = vueCache.get(file）</p> 
<pre><code>// 解析 vue 文件                                 
const descriptor = await parseSFC(root, file, content)
if (!descriptor) {
  // read failed
  return
}
    // 拿到上一次解析结果
const prevDescriptor = cacheEntry &amp;&amp; cacheEntry.descriptor

// 设置刷新变量
let needReload = false // script 改变标记
let needCssModuleReload = false // css 改变标记
let needRerender = false // template 改变标记

   // 判断 script 是否相同
if (!isEqual(descriptor.script, prevDescriptor.script)) {
  needReload = true
}

 // 判断 template 是否相同
if (!isEqual(descriptor.template, prevDescriptor.template)) {
  needRerender = true
}
  
// 通过 send 发送 socket
if (needRerender){
    send({
    type: 'vue-rerender',
    path: publicPath,
    timestamp
  })    
}
</code></pre> 
<p>}</p> 
<p>handleJSReload 方法则是根据文件路径引用，判断被哪个 vue 组件所依赖，如果未找到 vue 组件依赖，则判断页面需要刷新，否则走组件更新逻辑，这里就不贴代码了。<br> 整体代码在 client.ts 和 serverPluginHmr 里。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2138b954b96bc03a7d91e8a11c393856/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于win10 和python3.6激活虚拟环境成功！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7ff7d3e72aae992e4d5a202c38741c9e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HDU-5955 Guessing the Dice Roll（AC自动机、高斯消元）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>