<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Elasticsearch7.17学习笔记 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Elasticsearch7.17学习笔记" />
<meta property="og:description" content="前言 本学习笔记主要基于 阅读Elasticsearch7.17版本官方文档和实操总结而来，官方文档地址https://www.elastic.co/guide/en/elasticsearch/reference/7.17/index.html
目录
一、ES的存储形式
二、使用方式
2.1 向ES中添加文档
2.2 搜索
2.3 get specific fields 2.4 范围查询
2.5 extract fields from unstrctured content 从非结构化内容中提取fields
2.6 Combine queries 组合查询
2.7 Aggregate data 聚合数据
2.8 图解一个请求​
2.9 field data type 字段包括哪些类型
2.10 解释 结构化数据、非结构化数据、半结构化数据
2.11 term和match区别
三、Query DSL
3.1 dis_max 分离最大化
3.2 boosting query 3.3 constant_score 3.4 function_score query 用户自定义score机制
3.5 intervals query 间隔查询
3.6 match query 3.7 combined_feilds 多个字段
3.8 multi_match" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/062bd5f7eef2132e64fdb28ae1d33776/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-17T03:44:41+08:00" />
<meta property="article:modified_time" content="2022-10-17T03:44:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Elasticsearch7.17学习笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>前言 </h4> 
<p>       本学习笔记主要基于 阅读Elasticsearch7.17版本官方文档和实操总结而来，官方文档地址<a class="link-info" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/index.html" rel="nofollow" title="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/index.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/index.html</a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81ES%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81ES%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F" rel="nofollow">一、ES的存储形式</a></p> 
<p id="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F" rel="nofollow">二、使用方式</a></p> 
<p id="2.1%20%E5%90%91ES%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E6%A1%A3-toc" style="margin-left:80px;"><a href="#2.1%20%E5%90%91ES%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E6%A1%A3" rel="nofollow">2.1 向ES中添加文档</a></p> 
<p id="2.2%20%E6%90%9C%E7%B4%A2-toc" style="margin-left:80px;"><a href="#2.2%20%E6%90%9C%E7%B4%A2" rel="nofollow">2.2 搜索</a></p> 
<p id="2.3%20get%20specific%20fields%C2%A0-toc" style="margin-left:80px;"><a href="#2.3%20get%20specific%20fields%C2%A0" rel="nofollow">2.3 get specific fields </a></p> 
<p id="2.4%20%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2-toc" style="margin-left:80px;"><a href="#2.4%20%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2" rel="nofollow">2.4 范围查询</a></p> 
<p id="2.5%20extract%20fields%20from%20unstrctured%20content%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E4%BB%8E%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E5%86%85%E5%AE%B9%E4%B8%AD%E6%8F%90%E5%8F%96fields-toc" style="margin-left:80px;"><a href="#2.5%20extract%20fields%20from%20unstrctured%20content%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E4%BB%8E%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E5%86%85%E5%AE%B9%E4%B8%AD%E6%8F%90%E5%8F%96fields" rel="nofollow">2.5 extract fields from unstrctured content  从非结构化内容中提取fields</a></p> 
<p id="2.6%C2%A0Combine%20queries%20%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2-toc" style="margin-left:80px;"><a href="#2.6%C2%A0Combine%20queries%20%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2" rel="nofollow">2.6 Combine queries 组合查询</a></p> 
<p id="2.7%20Aggregate%20data%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E8%81%9A%E5%90%88%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#2.7%20Aggregate%20data%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E8%81%9A%E5%90%88%E6%95%B0%E6%8D%AE" rel="nofollow">2.7 Aggregate data  聚合数据</a></p> 
<p id="2.8%20%E5%9B%BE%E8%A7%A3%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:80px;"><a href="#2.8%20%E5%9B%BE%E8%A7%A3%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">2.8 图解一个请求​</a></p> 
<p id="2.9%20field%20data%20type%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%AD%97%E6%AE%B5%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#2.9%20field%20data%20type%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%AD%97%E6%AE%B5%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" rel="nofollow">2.9 field data type  字段包括哪些类型</a></p> 
<p id="2.10%20%E8%A7%A3%E9%87%8A%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E3%80%81%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E3%80%81%E5%8D%8A%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#2.10%20%E8%A7%A3%E9%87%8A%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E3%80%81%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E3%80%81%E5%8D%8A%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE" rel="nofollow">2.10 解释 结构化数据、非结构化数据、半结构化数据</a></p> 
<p id="2.11%20term%E5%92%8Cmatch%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#2.11%20term%E5%92%8Cmatch%E5%8C%BA%E5%88%AB" rel="nofollow">2.11 term和match区别</a></p> 
<p id="%E4%B8%89%E3%80%81Query%20DSL-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81Query%20DSL" rel="nofollow">三、Query DSL</a></p> 
<p id="3.1%20dis_max%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%88%86%E7%A6%BB%E6%9C%80%E5%A4%A7%E5%8C%96-toc" style="margin-left:80px;"><a href="#3.1%20dis_max%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%88%86%E7%A6%BB%E6%9C%80%E5%A4%A7%E5%8C%96" rel="nofollow">3.1 dis_max 分离最大化</a></p> 
<p id="3.2%20boosting%20query%C2%A0-toc" style="margin-left:80px;"><a href="#3.2%20boosting%20query%C2%A0" rel="nofollow">3.2 boosting query </a></p> 
<p id="3.3%20constant_score%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E5%B8%B8%E9%87%8F%E5%88%86%E6%95%B0%C2%A0-toc" style="margin-left:80px;"><a href="#3.3%20constant_score%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E5%B8%B8%E9%87%8F%E5%88%86%E6%95%B0%C2%A0" rel="nofollow">3.3 constant_score  </a></p> 
<p id="3.4%20function_score%20query%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89score%E6%9C%BA%E5%88%B6-toc" style="margin-left:80px;"><a href="#3.4%20function_score%20query%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89score%E6%9C%BA%E5%88%B6" rel="nofollow">3.4 function_score query  用户自定义score机制</a></p> 
<p id="3.5%C2%A0%20intervals%20query%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E9%97%B4%E9%9A%94%E6%9F%A5%E8%AF%A2-toc" style="margin-left:80px;"><a href="#3.5%C2%A0%20intervals%20query%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E9%97%B4%E9%9A%94%E6%9F%A5%E8%AF%A2" rel="nofollow">3.5 intervals query  间隔查询</a></p> 
<p id="3.6%20match%20query%C2%A0-toc" style="margin-left:80px;"><a href="#3.6%20match%20query%C2%A0" rel="nofollow">3.6 match query </a></p> 
<p id="3.7%C2%A0%20combined_feilds%20%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5-toc" style="margin-left:80px;"><a href="#3.7%C2%A0%20combined_feilds%20%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5" rel="nofollow">3.7 combined_feilds 多个字段</a></p> 
<p id="3.8%20multi_match-toc" style="margin-left:80px;"><a href="#3.8%20multi_match" rel="nofollow">3.8 multi_match</a></p> 
<p id="3.9%20query_string-toc" style="margin-left:80px;"><a href="#3.9%20query_string" rel="nofollow">3.9 query_string</a></p> 
<p id="3.10%20joining%20query-toc" style="margin-left:80px;"><a href="#3.10%20joining%20query" rel="nofollow">3.10 joining query</a></p> 
<p id="3.11%20percolate%C2%A0query-toc" style="margin-left:80px;"><a href="#3.11%20percolate%C2%A0query" rel="nofollow">3.11 percolate query</a></p> 
<p id="3.12%20rank_feature-toc" style="margin-left:80px;"><a href="#3.12%20rank_feature" rel="nofollow">3.12 rank_feature</a></p> 
<p id="3.13%C2%A0pinned%20query%C2%A0-toc" style="margin-left:80px;"><a href="#3.13%C2%A0pinned%20query%C2%A0" rel="nofollow">3.13 pinned query </a></p> 
<p id="3.14%20fuzzy%20query-toc" style="margin-left:80px;"><a href="#3.14%20fuzzy%20query" rel="nofollow">3.14 fuzzy query</a></p> 
<p id="3.15%20exist-toc" style="margin-left:80px;"><a href="#3.15%20exist" rel="nofollow">3.15 exist</a></p> 
<p id="3.16%20wildcard%20query%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E9%80%9A%E9%85%8D%E7%AC%A6%E6%9F%A5%E8%AF%A2-toc" style="margin-left:80px;"><a href="#3.16%20wildcard%20query%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E9%80%9A%E9%85%8D%E7%AC%A6%E6%9F%A5%E8%AF%A2" rel="nofollow">3.16 wildcard query  通配符查询</a></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="%E7%BB%93%E8%AF%AD-toc" style="margin-left:40px;"><a href="#%E7%BB%93%E8%AF%AD" rel="nofollow">结语</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%B8%80%E3%80%81ES%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F">一、ES的存储形式</h3> 
<p>1.Elasticsearch stores complex data structures that have been serialized as JSON documents</p> 
<p>ES存储已序列化为JSON文档的复杂数据结构</p> 
<p>2.When a document is stored, it is indexed</p> 
<p>当文档被存储时，它会被建立索引</p> 
<p>3.An inverted index lists every unique word that appears in any document and identifies all of the documents each word occurs in</p> 
<p>倒排索引列出任何文档中出现的每个惟一单词，并标识每个单词出现的所有文档</p> 
<p>4.An index can be thought of as an optimized collection of documents and each document is a collection of fields, which are the key-value pairs that contain your data</p> 
<p>可以将索引看作是文档的优化集合，每个文档都是字段的集合，字段是包含数据的键-值对</p> 
<p>5.term 是中文 ‘术语或者条款 / 项’ 的意思</p> 
<p>match 是‘匹配’的意思，复数是matches</p> 
<p>extract ‘提取/索取’</p> 
<p>shard 分片</p> 
<p>6.The Elasticsearch REST APIs support structured queries, full text queries, and complex queries that combine the two.  Structured queries are similar to the types of queries you can construct in SQL.  For example, you could search the gender and age fields in your employee index and sort the matches by the hire_date field.  Full-text queries find all documents that match the query string and return them sorted by relevance—how good a match they are for your search terms</p> 
<p>Elasticsearch REST api支持结构化查询、全文查询和将两者结合起来的复杂查询。结构化查询类似于可以在SQL中构造的查询类型。例如，您可以在员工索引中搜索性别和年龄字段，并根据hire_date字段对匹配进行排序。全文查询查找与查询字符串匹配的所有文档，并按相关性(它们与搜索词的匹配程度)排序返回它们</p> 
<h3 id="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">二、使用方式</h3> 
<h4 id="2.1%20%E5%90%91ES%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E6%A1%A3">2.1 向ES中添加文档</h4> 
<p><strong>add single document 添加单个文档</strong></p> 
<p>向ES服务器发送这个请求body</p> 
<pre><code class="language-sql">POST logs-my_app-default/_doc
{
  "@timestamp": "2099-05-06T16:21:15.000Z",
  "event": {
    "original": "192.0.2.42 - - [06/May/2099:16:21:15 +0000] \"GET /images/bg.jpg HTTP/1.0\" 200 24736"
  }
}</code></pre> 
<p>得到响应，其中</p> 
<p>        _index 包含存储的文档</p> 
<p>        _id是文档在索引中的唯一id</p> 
<pre><code class="language-sql">{
  "_index": ".ds-logs-my_app-default-2099-05-06-000001",
  "_type": "_doc",
  "_id": "gl5MJXMBMk1dGnErnBW8",
  "_version": 1,
  "result": "created",
  "_shards": {
    "total": 2,
    "successful": 1,
    "failed": 0
  },
  "_seq_no": 0,
  "_primary_term": 1
}</code></pre> 
<p><strong>一条request请求 添加多个文档</strong></p> 
<p>使用_bulk在首行末端 ,多个文档间需换行，每个文档都是json格式</p> 
<p>示例：</p> 
<pre><code class="language-sql">PUT logs-my_app-default/_bulk
{ "create": { } }
{ "@timestamp": "2099-05-07T16:24:32.000Z", "event": { "original": "192.0.2.242 - - [07/May/2020:16:24:32 -0500] \"GET /images/hm_nbg.jpg HTTP/1.0\" 304 0" } }
{ "create": { } }
{ "@timestamp": "2099-05-08T16:25:42.000Z", "event": { "original": "192.0.2.255 - - [08/May/2099:16:25:42 +0000] \"GET /favicon.ico HTTP/1.0\" 200 3638" } }</code></pre> 
<h4 id="2.2%20%E6%90%9C%E7%B4%A2">2.2 搜索</h4> 
<p>此条请求，将匹配logs-my_app-default中的所有日志条目，并按@timestamp降序对它们进行排序</p> 
<pre><code class="language-sql">GET logs-my_app-default/_search
{
  "query": {
    "match_all": { }
  },
  "sort": [
    {
      "@timestamp": "desc"
    }
  ]
}</code></pre> 
<p>得到response如下，其中</p> 
<p>默认情况下hits部分最多包括与搜索匹配的前10个文档。每个命中的_source是已提交了索引的原始数据(json)</p> 
<pre><code class="language-sql">{
  "took": 2,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped": 0,
    "failed": 0
  },
  "hits": {
    "total": {
      "value": 3,
      "relation": "eq"
    },
    "max_score": null,
    "hits": [
      {
        "_index": ".ds-logs-my_app-default-2099-05-06-000001",
        "_type": "_doc",
        "_id": "PdjWongB9KPnaVm2IyaL",
        "_score": null,
        "_source": {
          "@timestamp": "2099-05-08T16:25:42.000Z",
          "event": {
            "original": "192.0.2.255 - - [08/May/2099:16:25:42 +0000] \"GET /favicon.ico HTTP/1.0\" 200 3638"
          }
        },
        "sort": [
          4081940742000
        ]
      },
      ...
    ]
  }
}</code></pre> 
<h4 id="2.3%20get%20specific%20fields%C2%A0">2.3 get specific fields </h4> 
<p>解析整个_source对于大型文档来说是笨拙的。要从响应中排除它，请将_source参数设置为false。作为代替，使用fields参数来检索所需的字段</p> 
<p>示例：</p> 
<pre><code class="language-sql">GET logs-my_app-default/_search
{
  "query": {
    "match_all": { }
  },
  "fields": [
    "@timestamp"
  ],
  "_source": false,
  "sort": [
    {
      "@timestamp": "desc"
    }
  ]
}</code></pre> 
<p>response以平面数组的形式包含每个命中的field值, 区别与上次搜索可观察fields和_score的内容</p> 
<pre><code class="language-sql">{
  ...
  "hits": {
    ...
    "hits": [
      {
        "_index": ".ds-logs-my_app-default-2099-05-06-000001",
        "_type": "_doc",
        "_id": "PdjWongB9KPnaVm2IyaL",
        "_score": null,
        "fields": {
          "@timestamp": [
            "2099-05-08T16:25:42.000Z"
          ]
        },
        "sort": [
          4081940742000
        ]
      },
      ...
    ]
  }
}</code></pre> 
<h4 id="2.4%20%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2">2.4 范围查询</h4> 
<p>在query中使用range关键字</p> 
<p>gte: greater than or equal 大于等于</p> 
<p>lt: less than 小于</p> 
<pre><code class="language-sql">GET logs-my_app-default/_search
{
  "query": {
    "range": {
      "@timestamp": {
        "gte": "2099-05-05",
        "lt": "2099-05-08"
      }
    }
  },
  "fields": [
    "@timestamp"
  ],
  "_source": false,
  "sort": [
    {
      "@timestamp": "desc"
    }
  ]
}</code></pre> 
<p>可以使用date math 来定义相对时间范围。下面的查询是 搜索过去一天的数据，而不是 去匹配logs-my_app-default中的任何日志条目(上一条请求会去匹配logs-my_app-default中时间戳字段的内容去搜索)。注意观察gte和lt 内容中使用了所谓的date math</p> 
<pre><code class="language-sql">GET logs-my_app-default/_search
{
  "query": {
    "range": {
      "@timestamp": {
        "gte": "now-1d/d",
        "lt": "now/d"
      }
    }
  },
  "fields": [
    "@timestamp"
  ],
  "_source": false,
  "sort": [
    {
      "@timestamp": "desc"
    }
  ]
}</code></pre> 
<h4 id="2.5%20extract%20fields%20from%20unstrctured%20content%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E4%BB%8E%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E5%86%85%E5%AE%B9%E4%B8%AD%E6%8F%90%E5%8F%96fields">2.5 extract fields from unstrctured content  从非结构化内容中提取fields</h4> 
<p>这种搜索 用到了映射，讲 从非结构化内容中提取fields之前，先说一下<strong>mapping映射</strong></p> 
<p>Mapping is the process of defining how a document, and the fields it contains, are stored and indexed.  </p> 
<p>Each document is a collection of fields, which each have their own data type.  When mapping your data, you create a mapping definition, which contains a list of fields that are pertinent to the document.  A mapping definition also includes metadata fields, like the _source field, which customize how a document’s associated metadata is handled.  </p> 
<p>Use dynamic mapping and explicit mapping to define your data.  Each method provides different benefits based on where you are in your data journey.  For example, explicitly map fields where you don’t want to use the defaults, or to gain greater control over which fields are created.  You can then allow Elasticsearch to add other fields dynamically.</p> 
<p>映射是定义文档及其包含的字段如何存储和索引的过程。</p> 
<p>每个文档都是字段的集合，每个字段都有自己的数据类型。当映射数据时，创建映射定义，其中包含与文档相关的字段列表。映射定义还包括元数据字段，如_source字段，它自定义如何处理文档关联的元数据。</p> 
<p>使用动态映射和显式映射来定义数据。每种方法根据您在数据旅程中的位置提供不同的好处。例如，显式地映射不希望使用默认值的字段，或者获得对创建哪些字段的更大控制。然后，您可以允许Elasticsearch 动态 添加其他字段。</p> 
<p>Experiment with mapping options  </p> 
<p>Define runtime fields in a search request to experiment with different mapping options, and also fix mistakes in your index mapping values by overriding values in the mapping during the search request.</p> 
<p>通过映射选项进行试验</p> 
<p>在搜索请求中定义 runtime fields，以试验不同的映射选项，并通过在搜索请求期间覆盖映射中的值来修复索引映射值中的错误</p> 
<p><strong>搜索语句示例：</strong></p> 
<p>其中runtime_mappings部分用到了映射，其中进行了获取source.ip的操作。而后又会在响应中将source.ip放在fields中</p> 
<pre><code class="language-sql">GET logs-my_app-default/_search
{
  "runtime_mappings": {
    "source.ip": {
      "type": "ip",
      "script": """
        String sourceip=grok('%{IPORHOST:sourceip} .*').extract(doc[ "event.original" ].value)?.sourceip;
        if (sourceip != null) emit(sourceip);
      """
    }
  },
  "query": {
    "range": {
      "@timestamp": {
        "gte": "2099-05-05",
        "lt": "2099-05-08"
      }
    }
  },
  "fields": [
    "@timestamp",
    "source.ip"
  ],
  "_source": false,
  "sort": [
    {
      "@timestamp": "desc"
    }
  ]
}</code></pre> 
<p>响应如下</p> 
<pre><code class="language-sql">{
  "took" : 4,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 3,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [
      {
        "_index" : ".ds-logs-my_app-default-2022.10.15-000001",
        "_type" : "_doc",
        "_id" : "J1zs312345B1SeF7g53S",
        "_score" : null,
        "fields" : {
          "@timestamp" : [
            "2099-05-07T16:24:32.000Z"
          ],
          "source.ip" : [
            "192.1.2.122"
          ]
        },
        "sort" : [
          4081854272000
        ]
      },
      {
        "_index" : ".ds-logs-my_app-default-2022.10.15-000001",
        "_type" : "_doc",
        "_id" : "Ilzr3IMBd9B43217032T",
        "_score" : null,
        "fields" : {
          "@timestamp" : [
            "2099-05-06T16:21:15.000Z"
          ],
          "source.ip" : [
            "192.1.2.122"
          ]
        },
        "sort" : [
          4081767675000
        ]
      },
      {
        "_index" : ".ds-logs-my_app-default-2022.10.15-000001",
        "_type" : "_doc",
        "_id" : "Jlz567Bd9B1SeF89XPX",
        "_score" : null,
        "fields" : {
          "@timestamp" : [
            "2099-05-06T16:21:15.000Z"
          ],
          "source.ip" : [
            "192.1.2.122"
          ]
        },
        "sort" : [
          4081767675000
        ]
      }
    ]
  }
}
</code></pre> 
<h4 id="2.6%C2%A0Combine%20queries%20%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2">2.6 <strong>Combine queries 组合查询</strong></h4> 
<p>使用<strong>bool</strong>这个参数</p> 
<p>The following search combines two <code>range</code> queries: one on <code>@timestamp</code> and one on the <code>source.ip</code> runtime field</p> 
<p>示例</p> 
<pre><code class="language-sql">GET logs-my_app-default/_search
{
  "runtime_mappings": {
    "source.ip": {
      "type": "ip",
      "script": """
        String sourceip=grok('%{IPORHOST:sourceip} .*').extract(doc[ "event.original" ].value)?.sourceip;
        if (sourceip != null) emit(sourceip);
      """
    }
  },
  "query": {
    "bool": {
      "filter": [
        {
          "range": {
            "@timestamp": {
              "gte": "2099-05-05",
              "lt": "2099-05-08"
            }
          }
        },
        {
          "range": {
            "source.ip": {
              "gte": "192.0.2.0",
              "lte": "192.0.2.240"
            }
          }
        }
      ]
    }
  },
  "fields": [
    "@timestamp",
    "source.ip"
  ],
  "_source": false,
  "sort": [
    {
      "@timestamp": "desc"
    }
  ]
}</code></pre> 
<p>响应</p> 
<pre><code class="language-sql">#! Elasticsearch built-in security features are not enabled. Without authentication, your cluster could be accessible to anyone. See https://www.elastic.co/guide/en/elasticsearch/reference/7.17/security-minimal-setup.html to enable security.
{
  "took" : 3,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 2,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [
      {
        "_index" : ".ds-logs-my_app-default-2022.10.15-000001",
        "_type" : "_doc",
        "_id" : "Ilzr3IMBd9B1SeF703MT",
        "_score" : null,
        "fields" : {
          "@timestamp" : [
            "2099-05-06T16:21:15.000Z"
          ],
          "source.ip" : [
            "192.0.2.42"
          ]
        },
        "sort" : [
          4081767675000
        ]
      },
      {
        "_index" : ".ds-logs-my_app-default-2022.10.15-000001",
        "_type" : "_doc",
        "_id" : "Jlzs3IMBd9B1SeF7IXPX",
        "_score" : null,
        "fields" : {
          "@timestamp" : [
            "2099-05-06T16:21:15.000Z"
          ],
          "source.ip" : [
            "192.0.2.42"
          ]
        },
        "sort" : [
          4081767675000
        ]
      }
    ]
  }
}
</code></pre> 
<p>compound query 混合查询中，下面这个查询返回满足must/filter/must_not/should的结果</p> 
<p>minimum_should_match是设置应满足should的比例（多个should字句时，设定满足多少should比例才返回）</p> 
<p>boost是设定此搜索条件的权重</p> 
<pre><code class="language-sql">POST _search
{
  "query": {
    "bool" : {
      "must" : {
        "term" : { "user.id" : "kimchy" }
      },
      "filter": {
        "term" : { "tags" : "production" }
      },
      "must_not" : {
        "range" : {
          "age" : { "gte" : 10, "lte" : 20 }
        }
      },
      "should" : [
        { "term" : { "tags" : "env1" } },
        { "term" : { "tags" : "deployed" } }
      ],
      "minimum_should_match" : 1,
      "boost" : 1.0
    }
  }
}</code></pre> 
<h4 id="2.7%20Aggregate%20data%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E8%81%9A%E5%90%88%E6%95%B0%E6%8D%AE">2.7 Aggregate data  聚合数据</h4> 
<p>Use aggregations to summarize data as metrics, statistics, or other analytics.  </p> 
<p>The following search uses an aggregation to calculate the average_response_size using the http.response.body.bytes runtime field.   The aggregation only runs on documents that match the query</p> 
<p>使用聚合将数据总结为度量、统计或其他分析。</p> 
<p>下面的搜索 通过http.response.body.bytes runtime field 聚合计算average_response_size。这个聚合建立在与查询匹配的文档上</p> 
<p>request示例，其中</p> 
<p>runtime_mappings会求得每个请求的http.response.body.bytes放在fields中，用agg关键字声明 聚合 ，聚合字段定义为average_response_size，在其中用avg求平均每个field的http.response.body.bytes</p> 
<pre><code class="language-sql">GET logs-my_app-default/_search
{
  "runtime_mappings": {
    "http.response.body.bytes": {
      "type": "long",
      "script": """
        String bytes=grok('%{COMMONAPACHELOG}').extract(doc[ "event.original" ].value)?.bytes;
        if (bytes != null) emit(Integer.parseInt(bytes));
      """
    }
  },
  "aggs": {
    "average_response_size":{
      "avg": {
        "field": "http.response.body.bytes"
      }
    }
  },
  "query": {
    "bool": {
      "filter": [
        {
          "range": {
            "@timestamp": {
              "gte": "2099-05-05",
              "lt": "2099-05-08"
            }
          }
        }
      ]
    }
  },
  "fields": [
    "@timestamp",
    "http.response.body.bytes"
  ],
  "_source": false,
  "sort": [
    {
      "@timestamp": "desc"
    }
  ]
}</code></pre> 
<p>response，其中</p> 
<p>aggregations字段中包含 聚合计算出的内容</p> 
<pre><code class="language-sql">#! Elasticsearch built-in security features are not enabled. Without authentication, your cluster could be accessible to anyone. See https://www.elastic.co/guide/en/elasticsearch/reference/7.17/security-minimal-setup.html to enable security.
{
  "took" : 112,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 3,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [
      {
        "_index" : ".ds-logs-my_app-default-2022.10.15-000001",
        "_type" : "_doc",
        "_id" : "J1zs3gewsd9B1SeF7gnPS",
        "_score" : null,
        "fields" : {
          "@timestamp" : [
            "2099-05-07T16:24:32.000Z"
          ],
          "http.response.body.bytes" : [
            0
          ]
        },
        "sort" : [
          4081854272000
        ]
      },
      {
        "_index" : ".ds-logs-my_app-default-2022.10.15-000001",
        "_type" : "_doc",
        "_id" : "Ilzr3IMBd9B1S321033T",
        "_score" : null,
        "fields" : {
          "@timestamp" : [
            "2099-05-06T16:21:15.000Z"
          ],
          "http.response.body.bytes" : [
            24736
          ]
        },
        "sort" : [
          4081767675000
        ]
      },
      {
        "_index" : ".ds-logs-my_app-default-2022.10.15-000001",
        "_type" : "_doc",
        "_id" : "Jlzs3IMBd9B1S12345PX",
        "_score" : null,
        "fields" : {
          "@timestamp" : [
            "2099-05-06T16:21:15.000Z"
          ],
          "http.response.body.bytes" : [
            24736
          ]
        },
        "sort" : [
          4081767675000
        ]
      }
    ]
  },
  "aggregations" : {
    "average_response_size" : {
      "value" : 16490.666666666668
    }
  }
}
</code></pre> 
<h4 id="2.8%20%E5%9B%BE%E8%A7%A3%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E2%80%8B%E7%BC%96%E8%BE%91">2.8 图解一个请求<img alt="" height="620" src="https://images2.imgbox.com/44/3b/35lWLQT7_o.png" width="918"></h4> 
<p> 响应</p> 
<p><img alt="" height="495" src="https://images2.imgbox.com/44/05/NgxiBKKx_o.png" width="798"></p> 
<h4 id="2.9%20field%20data%20type%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%AD%97%E6%AE%B5%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2.9 field data type  字段包括哪些类型</h4> 
<p>每个field 数据有自己的field data 类型，比如是：text、keyword、boolean、Dates、Range(long_range/double_range/date_range)、ip等等</p> 
<p>        其中，keyword类型经常用在 sorting, aggregations聚合, and term-level queries, such as term.应避免使用keyword fields full-text search全文搜索，应使用text field type作为代替</p> 
<h4 id="2.10%20%E8%A7%A3%E9%87%8A%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E3%80%81%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E3%80%81%E5%8D%8A%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE">2.10 解释 结构化数据、非结构化数据、半结构化数据</h4> 
<p>结构化数据是指可以使用关系型数据库表示和存储，表现为二维形式的数据。一般特点是：数据以行为单位，一行数据表示一个实体的信息，每一行数据的属性是相同的</p> 
<p>非机构化数据就是没有固定结构的数据。各种文档、图片、视频/音频等都属于非结构化数据。对于这类数据，我们一般直接整体进行存储，而且一般存储为二进制的数据格式</p> 
<p>半结构化数据是结构化数据的一种形式，它并不符合关系型数据库或其他数据表的形式关联起来的数据模型结构，但包含相关标记，用来分隔语义元素以及对记录和字段进行分层。因此，它也被称为自描述的结构。半结构化数据，属于同一类实体可以有不同的属性，即使他们被组合在一起，这些属性的顺序并不重要。常见的半结构数据有XML和JSON</p> 
<h4 id="2.11%20term%E5%92%8Cmatch%E5%8C%BA%E5%88%AB">2.11 term和match区别</h4> 
<p>term是精确搜索，不会对 query的内容 进行分词，拿着整个的query内容 去es中查找。</p> 
<p>match是模糊搜索，会对 query内容 进行分词，即使只有一个字命中也会返回，返回所有的命中结果并附带相似分数_score，我们这里说的分词es官方称作 analyzed text fields（分析过了的文本字段）</p> 
<p>示例：先添加三条文档</p> 
<pre><code class="language-sql">POST /test/_doc
{
"name": "张三",
"age": 25
}

POST /test/_doc
{
"name": "张无忌",
"age": 50
}

POST /test/_doc
{
"name": "李四",
"age": 30
}</code></pre> 
<p>term精确搜索‘张’，响应出 张三和张无忌</p> 
<pre><code class="language-sql"># 请求
GET test/_search
{
  "query": {
    "term": {"name": "张"}
}
}

# 响应
{
  "took" : 0,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 2,
      "relation" : "eq"
    },
    "max_score" : 0.7549127,
    "hits" : [
      {
        "_index" : "test",
        "_type" : "_doc",
        "_id" : "13q_34MBwb0XtVQgyvdY",
        "_score" : 0.7549127,
        "_source" : {
          "name" : "张三",
          "age" : 25
        }
      },
      {
        "_index" : "test",
        "_type" : "_doc",
        "_id" : "2HrA34MBwb0XtVQgbfd6",
        "_score" : 0.6407243,
        "_source" : {
          "name" : "张无忌",
          "age" : 50
        }
      }
    ]
  }
}</code></pre> 
<p>term精确搜索‘张三’，无结果并没有返回之前存的张三</p> 
<p>es默认存储的是text类型字段，默认的分词器会对存储内容进行分词存到倒排索引中，所以即使我们之前存了‘张三’，也term不出来匹配的结果，因为es中的张三已经被分词了，分成了'张' '三'。</p> 
<pre><code class="language-sql">#　请求
GET test/_search
{
  "query": {
    "term": {"name": "张三"}
}
}


#  响应
{
  "took" : 0,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 0,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  }
}
</code></pre> 
<p>match演示，可以看到即使查的是 张三，结果中张无忌也出来了，并且张三的_score高于张无忌的_score</p> 
<pre><code class="language-sql">#　请求
GET test/_search
{
  "query": {
    "match": {"name": "张三"}
}
}

#  响应
{
  "took" : 0,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 2,
      "relation" : "eq"
    },
    "max_score" : 2.0661702,
    "hits" : [
      {
        "_index" : "test",
        "_type" : "_doc",
        "_id" : "13q_34MBwb0XtVQgyvdY",
        "_score" : 2.0661702,
        "_source" : {
          "name" : "张三",
          "age" : 25
        }
      },
      {
        "_index" : "test",
        "_type" : "_doc",
        "_id" : "2HrA34MBwb0XtVQgbfd6",
        "_score" : 0.6407243,
        "_source" : {
          "name" : "张无忌",
          "age" : 50
        }
      }
    ]
  }
}
</code></pre> 
<h3 id="%E4%B8%89%E3%80%81Query%20DSL">三、Query DSL</h3> 
<h4 id="3.1%20dis_max%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%88%86%E7%A6%BB%E6%9C%80%E5%A4%A7%E5%8C%96">3.1 dis_max 分离最大化</h4> 
<p>分离最大化查询（Disjunction Max Query）指的是： 将任何与任一查询匹配的文档作为结果返回，但只将最佳匹配的评分作为查询的评分结果返回。而为了考虑查询的其他字段，在请求参数中加入tie_breaker，此时返回结果 综合score最大的fields的值 与 其他fields 的score乘以tie_breaker</p> 
<h4 id="3.2%20boosting%20query%C2%A0">3.2 boosting query </h4> 
<p>其中包括positive和negative参数</p> 
<p>positive 中的内容是希望匹配的内容</p> 
<p>而negative中的内容会 根据negative_boost系数进行降低权重计算结果 返回</p> 
<pre><code class="language-sql">GET /_search
{
  "query": {
    "boosting": {
      "positive": {
        "term": {
          "text": "apple"
        }
      },
      "negative": {
        "term": {
          "text": "pie tart fruit crumble tree"
        }
      },
      "negative_boost": 0.5
    }
  }
}</code></pre> 
<h4 id="3.3%20constant_score%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E5%B8%B8%E9%87%8F%E5%88%86%E6%95%B0%C2%A0">3.3 constant_score  常量分数 </h4> 
<p>包装一个filter query，返回的结果中score是经过boost计算出来的</p> 
<p>在constant_score下方必要参数：filter</p> 
<p>可选参数:boost，默认为1，如果设为1.2则此条constant_score下每个filter匹配出来的文档score会乘以1.2</p> 
<h4 id="3.4%20function_score%20query%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89score%E6%9C%BA%E5%88%B6">3.4 function_score query  用户自定义score机制</h4> 
<h4 id="3.5%C2%A0%20intervals%20query%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E9%97%B4%E9%9A%94%E6%9F%A5%E8%AF%A2">3.5  intervals query  间隔查询</h4> 
<p>根据 interval query的内容 与 匹配的内容词条 还有 间隔参数  制定间隔规则，去es中索取符合规则的文档</p> 
<p>下面这条返回的结果my favorite food 三个单词是直接挨着的,因为max_gaps设的0， 顺序上它的后面是 hot water OR cold porridge ，因为参数ordered为true</p> 
<p>这条搜索会匹配出my favorite food is cold porridge，而非when it's cold my favorite food is porridge</p> 
<pre><code class="language-sql">POST _search
{
  "query": {
    "intervals" : {
      "my_text" : {
        "all_of" : {
          "ordered" : true,
          "intervals" : [
            {
              "match" : {
                "query" : "my favorite food",
                "max_gaps" : 0,
                "ordered" : true
              }
            },
            {
              "any_of" : {
                "intervals" : [
                  { "match" : { "query" : "hot water" } },
                  { "match" : { "query" : "cold porridge" } }
                ]
              }
            }
          ]
        }
      }
    }
  }
}</code></pre> 
<h4 id="3.6%20match%20query%C2%A0">3.6 match query </h4> 
<p><strong>match_bool_prefix </strong>构造成等价于bool term 查询，注意最后一个词是前缀匹配</p> 
<pre><code class="language-sql">GET /_search
{
  "query": {
    "match_bool_prefix" : {
      "message" : "quick brown f"
    }
  }
}

# 等价于下面这条

GET /_search
{
  "query": {
    "bool" : {
      "should": [
        { "term": { "message": "quick" }},
        { "term": { "message": "brown" }},
        { "prefix": { "message": "f"}}
      ]
    }
  }
}</code></pre> 
<p><strong>match_phrase  短语查询</strong></p> 
<p>会去es中按 math_phrase 中的短语内容和顺序去  查数据</p> 
<p>如下条，返回的结果必须完全满足有 this is a test 这个顺序的</p> 
<p>这里也进行分词了内部是根据位置+1+2 这样满足匹配顺序的，而term query是不分词</p> 
<pre><code class="language-sql">GET /_search
{
  "query": {
    "match_phrase": {
      "message": "this is a test"
    }
  }
}</code></pre> 
<p><strong>match_phrase_prefix</strong></p> 
<p>与 match_pharse类似，但是短语中最后一个字符在倒排序索引列表中进行通配符搜索。重要参数：模糊匹配数控制 max_expansions 默认值50，最小值为1</p> 
<h4 id="3.7%C2%A0%20combined_feilds%20%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5">3.7 combined_feilds 多个字段</h4> 
<p>The combined_fields query supports searching multiple text fields as if their contents had been indexed into one combined field. The query takes a term-centric view of the input string: first it analyzes the query string into individual terms, then looks for each term in any of the fields. This query is particularly useful when a match could span multiple text fields, for example the title, abstract, and body of an article</p> 
<p>combined_fields查询支持搜索多个文本字段，就像它们的内容已经被索引到一个组合字段中一样。查询采用以term为中心的输入字符串视图:首先，它将查询字符串分析为单个term，然后在任何字段中查找每个term。当匹配可以跨越多个文本字段时，例如标题、摘要和文章主体，此查询特别有用</p> 
<p>示例：</p> 
<p>在title, abstract, and body 三个字段中搜database  and systems</p> 
<p>operator 也可以为or </p> 
<pre><code class="language-sql">GET /_search
{
  "query": {
    "combined_fields" : {
      "query":      "database systems",
      "fields":     [ "title", "abstract", "body"],
      "operator":   "and"
    }
  }
}</code></pre> 
<h4 id="3.8%20multi_match">3.8 multi_match</h4> 
<p>multi_match 查询将允许你在 mapping 使用不同的分词器，而 combine_fields 查询需要相同的分析器</p> 
<p>示例</p> 
<p>其中，type默认是best_fields，还可以是most_fields（等价于should ）、phrase and phrase_prefix、cross_fields</p> 
<pre><code class="language-sql">GET /_search
{
  "query": {
    "multi_match" : {
      "query":      "brown fox",
      "type":       "best_fields",
      "fields":     [ "subject", "message" ],
      "tie_breaker": 0.3
    }
  }
}

# 等价于
GET /_search
{
  "query": {
    "dis_max": {
      "queries": [
        { "match": { "subject": "brown fox" }},
        { "match": { "message": "brown fox" }}
      ],
      "tie_breaker": 0.3
    }
  }
</code></pre> 
<h4 id="3.9%20query_string">3.9 query_string</h4> 
<p><strong>3.9.1 指定单个字段查询</strong></p> 
<pre><code class="language-sql">GET /_search
{
  "query": {
    "query_string": {
      "query": "(new york city) OR (big apple)",
      "default_field": "content"
    }
  }
}</code></pre> 
<p><strong>3.9.2 指定多个字段查询</strong></p> 
<pre><code class="language-sql">GET /_search
{
  "query": {
    "query_string": {
      "fields": [ "content", "name" ],
      "query": "this AND that"
    }
  }
</code></pre> 
<p><strong>3.9.3 simple_query_string</strong></p> 
<p>simple_query_string查询的语法比query_string查询更有限，但它不会因为语法无效而返回错误。相反，它会忽略查询字符串中任何无效的部分。</p> 
<h4 id="3.10%20joining%20query">3.10 joining query</h4> 
<p>包括netsed、haschild、hasparent</p> 
<p>nested嵌套对象</p> 
<p>先在mapping映射时定义type为nested，查询时用nested语句</p> 
<pre><code class="language-sql">PUT /my-index-000001
{
  "mappings": {
    "properties": {
      "obj1": {
        "type": "nested"
      }
    }
  }
}</code></pre> 
<pre><code class="language-sql">GET /my-index-000001/_search
{
  "query": {
    "nested": {
      "path": "obj1",
      "query": {
        "bool": {
          "must": [
            { "match": { "obj1.name": "blue" } },
            { "range": { "obj1.count": { "gt": 5 } } }
          ]
        }
      },
      "score_mode": "avg"
    }
  }
}</code></pre> 
<h4 id="3.11%20percolate%C2%A0query">3.11 percolate query</h4> 
<p>es的普通查询是通过某些条件来查询满足的文档，percolator则不同，先是注册一些条件，然后查询一条文档是否满足其中的某些条件。es的percolator特性在数据分类、数据路由、事件监控和预警方面都有很好的应用</p> 
<p>现在Mapping中定义percolator</p> 
<pre><code class="language-sql">PUT /my-index-00001
{
  "mappings": {
    "properties": {
      "message": {
        "type": "text"
      },
      "query": {
        "type": "percolator"
      }
    }
  }
}</code></pre> 
<p>查询时再使用percolate参数</p> 
<h4 id="3.12%20rank_feature">3.12 rank_feature</h4> 
<p>根据上下文动态地对文档进行评分是很常见的。 例如，如果你需要对某个类别内的更多文档进行评分，经典方案是提升（给低分的文档提分）基于某个值的文档，例如页面排名、点击量或类别。Elasticsearch 提供了两种基于值提高分数的新方法。一个是 rank feature 字段，另一个是它的扩展，即使用值向量。根据 rank_feature 或 rank_features 字段的数值提高文档的相关性分数。rank_feature 查询通常用在 bool 查询的 should 子句中，因此它的相关性分数被添加到 bool 查询的其他分数中。<br> (此处借鉴这篇文章)<a href="https://blog.csdn.net/UbuntuTouch/article/details/125425351" title="Elasticsearch：Rank feature query - 排名功能查询_Elastic 中国社区官方博客的博客-CSDN博客_elasticsearch 排名">Elasticsearch：Rank feature query - 排名功能查询_Elastic 中国社区官方博客的博客-CSDN博客_elasticsearch 排名</a></p> 
<h4 id="3.13%C2%A0pinned%20query%C2%A0">3.13 pinned query </h4> 
<p>Promotes selected documents to rank higher than those matching a given query. This feature is typically used to guide searchers to curated documents that are promoted over and above any "organic" matches for a search. The promoted or "pinned" documents are identified using the document IDs stored in the _id field.</p> 
<p>提升选定文档的排名，使其高于匹配给定查询的文档的排名。该功能通常用于引导搜索者到经过策划的文档，这些文档会在搜索的任何“organic”匹配之上被提升。提升或"pinned" 文档使用存储在_id字段中的文档id进行标识。</p> 
<p>比如，下面这个请求，ids中这些内容将置顶返回</p> 
<pre><code class="language-sql">GET /_search
{
  "query": {
    "pinned": {
      "ids": [ "1", "4", "100" ],
      "organic": {
        "match": {
          "description": "iphone"
        }
      }
    }
  }
}</code></pre> 
<h4 id="3.14%20fuzzy%20query">3.14 fuzzy query</h4> 
<p>将我们fuzzy query的内容 进行模糊匹配（或者说自动改错纠正输入内容）到 es中去查找</p> 
<pre><code class="language-sql">GET /_search
{
  "query": {
    "fuzzy": {
      "user.id": {
        "value": "ki"
      }
    }
  }
}</code></pre> 
<h4 id="3.15%20exist">3.15 exist</h4> 
<p>exists过滤document，查找出那些在特定字段有值的document，值可以为‘’不可以为null</p> 
<h4 id="3.16%20wildcard%20query%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E9%80%9A%E9%85%8D%E7%AC%A6%E6%9F%A5%E8%AF%A2">3.16 wildcard query  通配符查询</h4> 
<p>Promotes selected documents to rank higher than those matching a given query. Returns documents that contain terms matching a wildcard pattern. A wildcard operator is a placeholder that matches one or more characters.  For example, the * wildcard operator matches zero or more characters.  You can combine wildcard operators with other characters to create a wildcard pattern.  </p> 
<p>提升选定文档的排名，使其高于匹配给定查询的文档的排名。返回包含匹配通配符模式的术语的文档。通配符是匹配一个或多个字符的占位符。例如，*通配符匹配零个或多个字符。可以将通配符操作符与其他字符组合在一起，以创建通配符模式。</p> 
<h4></h4> 
<h3 id="%E7%BB%93%E8%AF%AD" style="text-align:center;">结语</h3> 
<p>        工作需要的原因，刚开始接触ES，读了两天的英文文档，在此写下文章作为记录。接下来还会持续的学习，欢迎阅读此文以及正在学习ES的同仁在评论区与我交流。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d8a57553015680af7aec209cd284497f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java 泛型进阶</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/076008300e4555b1c1225b90972acf0a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Cantata 测试工具基本使用介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>