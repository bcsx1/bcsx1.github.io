<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构与算法(Python)——常见数据结构Part5(二叉搜索树BST和AVL) - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构与算法(Python)——常见数据结构Part5(二叉搜索树BST和AVL)" />
<meta property="og:description" content="写在前面 在上一节part4我们熟悉了二叉树结构，以及其遍历算法，本节将继续学习常见的树结构，包括二叉搜索树和一种自平衡的二叉搜索树AVL。
1. 二叉搜索树 二叉搜索树(Binary Search Tree):二叉查找树，也称二叉搜索树、有序二叉树（ordered binary tree），排序二叉树（sorted binary tree）。它或者是一棵空树；或者是指具有如下性质的二叉树:
(1)若它的左子树不为空，则左子树上所有的节点的值均小于它的根节点的值 (2) 若它的右子树不为空，则右子树上所有结点的值均大于它的根结点的值(3) 它的左、右子树也分别为二叉搜索树。
上面的定义是一种递归定义，例如下图所示为一棵BST:
定义二叉搜索树如下:
class BinarySearchTree(BinaryTree): &#34;&#34;&#34; 二叉搜索树 &#34;&#34;&#34; def __init__(self): self.root = None 1.1 插入操作 插入二叉树时，插入元素需要与树中已有元素对比，插入到合适位置，以保持二叉树的特性，这个过程可以看做是一个递归的过程，插入元素为e, 插入节点从树的根节点开始，这一过程描述为:
case 1: e如果比当前节点大，则与当前节点的右孩子的根节点比较,即当前节点右孩子设为当前节点，继续比较； case 2: e如果比当前节点小，则与当前节点的左孩子的根节点比较,即当前节点左孩子设为当前节点，继续比较； case 3: e如果与当前节点相等，则不插入。
这个过程即可使用迭代实现，也可以递归实现，一般采用递归比较简洁，描述为:
def add(self, value): if not self.root: self.root = TreeNode(value) return True else: return BinarySearchTree.__add_value(self.root, value) @staticmethod def __add_value(node, value): if not node: return False if node.data == value: return False # duplicate elif value &lt; node." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/99f3f2b62ffee75e0554b4f822293bf5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-02-06T20:30:08+08:00" />
<meta property="article:modified_time" content="2018-02-06T20:30:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构与算法(Python)——常见数据结构Part5(二叉搜索树BST和AVL)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="写在前面">写在前面</h3> 
<p>在上一节part4我们熟悉了二叉树结构，以及其遍历算法，本节将继续学习常见的树结构，包括二叉搜索树和一种自平衡的二叉搜索树AVL。</p> 
<h3 id="1-二叉搜索树">1. 二叉搜索树</h3> 
<p><strong>二叉搜索树(Binary Search Tree)</strong>:二叉查找树，也称二叉搜索树、有序二叉树（ordered binary tree），排序二叉树（sorted binary tree）。它或者是一棵空树；或者是指具有如下性质的二叉树:</p> 
<blockquote> 
 <p>(1)若它的左子树不为空，则左子树上所有的节点的值均小于它的根节点的值 (2) 若它的右子树不为空，则右子树上所有结点的值均大于它的根结点的值(3) 它的左、右子树也分别为二叉搜索树。</p> 
</blockquote> 
<p>上面的定义是一种递归定义，例如下图所示为一棵BST:</p> 
<p><img src="https://images2.imgbox.com/a1/2b/bcQYNAsh_o.jpg" alt="BST" title=""></p> 
<p>定义二叉搜索树如下:</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span><span class="hljs-params">(BinaryTree)</span>:</span>

    <span class="hljs-string">"""
        二叉搜索树
    """</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        self.root = <span class="hljs-keyword">None</span></code></pre> 
<h4 id="11-插入操作">1.1 插入操作</h4> 
<p>插入二叉树时，插入元素需要与树中已有元素对比，插入到合适位置，以保持二叉树的特性，这个过程可以看做是一个递归的过程，插入元素为e, 插入节点从树的根节点开始，这一过程描述为:</p> 
<blockquote> 
 <p>case 1: e如果比当前节点大，则与当前节点的右孩子的根节点比较,即当前节点右孩子设为当前节点，继续比较； <br> case 2: e如果比当前节点小，则与当前节点的左孩子的根节点比较,即当前节点左孩子设为当前节点，继续比较； <br> case 3: e如果与当前节点相等，则不插入。</p> 
</blockquote> 
<p>这个过程即可使用迭代实现，也可以递归实现，一般采用递归比较简洁，描述为:</p> 
<pre class="prettyprint"><code class="language-python hljs ">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, value)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.root:
            self.root = TreeNode(value)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> BinarySearchTree.__add_value(self.root, value)

    <span class="hljs-decorator">@staticmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__add_value</span><span class="hljs-params">(node, value)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">if</span> node.data == value:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>       <span class="hljs-comment"># duplicate</span>
        <span class="hljs-keyword">elif</span> value &lt; node.data:
            <span class="hljs-keyword">if</span> node.left:
                <span class="hljs-keyword">return</span> BinarySearchTree.__add_value(node.left, value)
            <span class="hljs-keyword">else</span>:
                node.left = TreeNode(value)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> node.right:
                <span class="hljs-keyword">return</span> BinarySearchTree.__add_value(node.right, value)
            <span class="hljs-keyword">else</span>:
                node.right = TreeNode(value)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span></code></pre> 
<p>例如初始树为(图片来自:<a href="http://www.algolist.net/Data_structures/Binary_search_tree/Insertion" rel="nofollow">Binary search tree. Adding a value</a>): <br> <img src="https://images2.imgbox.com/ee/63/v0FUfGoY_o.png" alt="初始树" title=""></p> 
<p>插入元素4的过程为:</p> 
<p><img src="https://images2.imgbox.com/12/90/w7H44Br0_o.png" alt="插入过程1" title=""></p> 
<p><img src="https://images2.imgbox.com/d0/46/wdIvIdEc_o.png" alt="插入过程2" title=""></p> 
<p><img src="https://images2.imgbox.com/7e/1d/YH9Y5Wyq_o.png" alt="插入过程3" title=""></p> 
<p><img src="https://images2.imgbox.com/40/b7/vuilygRw_o.png" alt="插入结束" title=""></p> 
<h4 id="12-查找操作">1.2 查找操作</h4> 
<p>实际上上面的插入过程，已经包含了查找过程，只是插入时需要查找到合适位置，而查找则只是查找元素位置。这一过程描述为:</p> 
<pre class="prettyprint"><code class="language-python hljs ">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(self, value)</span>:</span>
        <span class="hljs-keyword">return</span> BinarySearchTree.__find__(self.root, value)

    <span class="hljs-decorator">@staticmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__find__</span><span class="hljs-params">(node, value)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">if</span> value == node.data:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">elif</span> value &lt; node.data:
            <span class="hljs-keyword">return</span> BinarySearchTree.__find__(node.left, value)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> BinarySearchTree.__find__(node.right, value)</code></pre> 
<h4 id="13-删除操作">1.3 删除操作</h4> 
<p>二叉搜索树的删除操作的一个难点在于始终要保持二叉树的性质不被破坏，因此需要分情况进行讨论。</p> 
<p><strong>case 1:</strong> 被删除节点没有孩子节点，例如下面树中删除节点-4。</p> 
<p>这个时候的操作仅需要将这个被删除节点的父节点相应孩子指针域置位None即可。</p> 
<p><img src="https://images2.imgbox.com/d1/cd/5skuIJSN_o.png" alt="删除无孩子节点" title=""></p> 
<p><strong>case 2:</strong> 被删除节点有一个孩子节点，例如下面树中删除节点18。</p> 
<p>这种情形，只需要将被删除节点的孩子指针域连接到这个被删除的节点的那个孩子即可，过程如下图所示: <br> <img src="https://images2.imgbox.com/3b/27/zlcbEM4v_o.png" alt="删除只有一个孩子节点" title=""></p> 
<p><strong>case 3:</strong> 被删除节点有两个孩子节点。</p> 
<p>这种情形要比上面两种情况复杂，因为不能简单地将被删除节点的父节点孩子指针域指向其中任何一个剩余的孩子。例如下图删除12。这个时候有两种策略，其中一个策略叫做<strong>复制删除(remove by copy)</strong>。</p> 
<p><strong>复制删除的思想是:</strong> 寻找待删除节点p的直接后继节点(前驱节点也可以，是一个对称的操作)，将后继节点的值复制到p中，然后删除这个后继节点(后继节点就是p的右子树中根节点的最左边孩子结点，这个节点最多只有一个孩子，因此转换为case1和case2的情况)。例如下面删除12的时候，寻找12的后继节点19，执行复制删除的过程如下所示:</p> 
<p><img src="https://images2.imgbox.com/e3/f3/9PTEwZfw_o.png" alt="复制删除" title=""></p> 
<p>我们将删除三种情况，整理一下，得出BST的删除操作算法描述为:</p> 
<blockquote> 
 <p>case 1: 对于没有孩子的结点，直接删除即可 <br> case 2: 对于只有一个孩子的结点，直接把孩子替换待删除结点即可 <br> case 3: 对于两个孩子都不为空的结点p，复制的思想即为： <br> 寻找待删除节点p的直接后继节点(前驱节点也可以，是一个对称的操作)，将后继节点的值复制到p中，然后删除这个后继节点(后继节点就是p的右子树中根节点的最左边孩子结点，这个节点最多只有一个孩子，因此转换为case1和case2的情况)。</p> 
</blockquote> 
<p>用python实现上述算法，表达为:</p> 
<pre class="prettyprint"><code class="language-python hljs ">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove_by_recursion</span><span class="hljs-params">(self, value)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.root:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">elif</span> value == self.root.data:
            temp_root = TreeNode()      <span class="hljs-comment"># 创建一个临时节点 方便处理</span>
            temp_root.left = self.root
            ret = BinarySearchTree.__remove__(temp_root.left, temp_root, value)
            self.root = temp_root.left
            <span class="hljs-keyword">return</span> ret
        <span class="hljs-keyword">elif</span> value &lt; self.root.data <span class="hljs-keyword">and</span> self.root.left:
            <span class="hljs-keyword">return</span> BinarySearchTree.__remove__(self.root.left, self.root, value)
        <span class="hljs-keyword">elif</span> value &gt; self.root.data <span class="hljs-keyword">and</span> self.root.right:
            <span class="hljs-keyword">return</span> BinarySearchTree.__remove__(self.root.right, self.root, value)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>

    <span class="hljs-decorator">@staticmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__remove__</span><span class="hljs-params">(node, parent_node, value)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> parent_node:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">if</span> value == node.data:
            <span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">and</span> node.right: <span class="hljs-comment"># case 被删除节点左右孩子都存在</span>
                min_node = node.right
                <span class="hljs-keyword">while</span> min_node.left:
                    min_node = min_node.left
                node.data = min_node.data
                BinarySearchTree.__remove__(node.right, node, node.data)
            <span class="hljs-keyword">else</span>:                        <span class="hljs-comment"># case 最多只有一个孩子存在</span>
                <span class="hljs-keyword">if</span> node == parent_node.left:
                    parent_node.left = node.left <span class="hljs-keyword">or</span> node.right
                <span class="hljs-keyword">else</span>:
                    parent_node.right = node.left <span class="hljs-keyword">or</span> node.right
        <span class="hljs-keyword">elif</span> value &lt; node.data <span class="hljs-keyword">and</span> node.left:
            <span class="hljs-keyword">return</span> BinarySearchTree.__remove__(node.left, node, value)
        <span class="hljs-keyword">elif</span> value &gt; node.data <span class="hljs-keyword">and</span> node.right:
            <span class="hljs-keyword">return</span> BinarySearchTree.__remove__(node.right, node, value)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span></code></pre> 
<p><strong>注意</strong>，在上面实现过程中， 当删除节点为根节点时，我们创建了一个临时节点，并以这个节点为真实根节点的父节点，然后执行删除操作，这种方式帮我们统一了代码流程，起到了简化处理的作用，否则针对删除根节点要做特殊处理，代码看起来混乱。</p> 
<p>除了复制删除外，还有一种<strong>合并删除方法(remove by merging)</strong>。合并删除的思想，与复制删除的不同之处主要体现在case3的处理上。case3时，合并删除，将删除节点p的右子树重新合并到前驱的右子树上(前驱节点也即p的左子树根节点的最右边孩子结点，它无右孩子，因此将p的右子树合并到这个前驱结点的右子树上)，结点p的左孩子的根成为新的根结点(将p的左子树链接到p的后继的左子树上，是一个对称的操作，这种方法也是可以的)。例如下图，删除节点20的过程:</p> 
<p><img src="https://images2.imgbox.com/9d/1c/nWvlmAX7_o.png" alt="合并删除" title=""></p> 
<p>合并删除算法在下一部分介绍的AVL树中用的少，这里就不提供实现了，感兴趣地可以自行实现。</p> 
<h3 id="2自平衡的二叉搜索树">2.自平衡的二叉搜索树</h3> 
<h4 id="21-why-平衡二叉搜索树">2.1 why 平衡二叉搜索树</h4> 
<p>含有n个节点的二叉搜索树，其树形并不唯一确定，随着元素输入顺序以及删除操作的变化，树形会大有不同。例如下图表示了数据相同，但树形差别很大的两个BST。</p> 
<p><img src="https://images2.imgbox.com/3b/f2/TctyDdDb_o.png" alt="非平衡二叉搜索树" title=""></p> 
<p><img src="https://images2.imgbox.com/76/7c/O15DjSAX_o.png" alt="平衡的二叉搜索树" title=""></p> 
<p><strong>含有n个节点的二叉搜索树其平均查找长度和树的形态有关</strong>。对比上述两个BST，假设访问其中每个元素的概率相同，则第一个BST中查找长度的期望为14/6，而第二个BST的查找长度的期望为21/6。 <br> 最坏的情况，即第一个BST所示的单支树情况，查找的时间复杂度为O(n)，而我们希望保持二叉搜索树深度较小，当二叉搜索树平衡时(<strong>平衡也就是树的所有叶子节点都出现在一个或者两个层次上，每个节点左子树与右子树的深度之差的绝对值不大于1</strong>)平均查找时间复杂度为O(logn)。</p> 
<p>当n=10000时，最坏需要查找10000次，而将10000个点存储在完全平衡的二叉搜索树中，树的高度为floor(log2(10000))+1=14，则最多需要查找14次。这个差别还是很大的。</p> 
<p>因此要尽可能保持树的平衡。保持树的平衡，有两种策略，一种是全局的，即当插入和删除操作完毕后，对树进行重建，全局调整树为平衡树, 这类算法包括<a href="http://penguin.ewu.edu/~trolfe/DSWpaper/" rel="nofollow">DSW平衡算法</a>；另一种是局部调整，即当插入或者删除导致树不平衡时就立即在局部范围内调整，使树保持平衡，这种树称之为自平衡二叉搜索树(<strong>Self-balancing binary search tree</strong>)，典型地如AVL树、红黑树，本节我们重点学习AVL树。</p> 
<h4 id="22-avl树的定义">2.2 AVL树的定义</h4> 
<p>AVL树的名字以3个发明者名字(Adelson-Velsky and Landis)首字母缩写构成，在AVL中节点N的<strong>平衡因子(Balance factor)</strong>定义为:</p> 
<p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" style="position: relative;"> 
   
   <span class="math" id="MathJax-Span-1" style="width: 26.702em; display: inline-block;"><span style="display: inline-block; position: relative; width: 21.371em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(3.1em, 1021.28em, 5.831em, -1000em); top: -4em; left: 0em;"><span class="mrow" id="MathJax-Span-2"><span style="display: inline-block; position: relative; width: 21.371em; height: 0px;"><span style="position: absolute; clip: rect(3.1em, 1021.28em, 4.4em, -1000em); top: -4em; left: 0em;"><span class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math; font-style: italic;">B</span><span class="mi" id="MathJax-Span-4" style="font-family: MathJax_Math; font-style: italic;">a</span><span class="mi" id="MathJax-Span-5" style="font-family: MathJax_Math; font-style: italic;">l</span><span class="mi" id="MathJax-Span-6" style="font-family: MathJax_Math; font-style: italic;">a</span><span class="mi" id="MathJax-Span-7" style="font-family: MathJax_Math; font-style: italic;">n</span><span class="mi" id="MathJax-Span-8" style="font-family: MathJax_Math; font-style: italic;">c</span><span class="mi" id="MathJax-Span-9" style="font-family: MathJax_Math; font-style: italic;">e</span><span class="mi" id="MathJax-Span-10" style="font-family: MathJax_Math; font-style: italic;">F<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.106em;"></span></span><span class="mi" id="MathJax-Span-11" style="font-family: MathJax_Math; font-style: italic;">a</span><span class="mi" id="MathJax-Span-12" style="font-family: MathJax_Math; font-style: italic;">c</span><span class="mi" id="MathJax-Span-13" style="font-family: MathJax_Math; font-style: italic;">t</span><span class="mi" id="MathJax-Span-14" style="font-family: MathJax_Math; font-style: italic;">o</span><span class="mi" id="MathJax-Span-15" style="font-family: MathJax_Math; font-style: italic;">r</span><span class="mo" id="MathJax-Span-16" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-17" style="font-family: MathJax_Math; font-style: italic;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.085em;"></span></span><span class="mo" id="MathJax-Span-18" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-19" style="font-family: MathJax_Main; padding-left: 0.278em;">:<span style="font-family: MathJax_Main; font-style: normal; font-weight: normal;">=</span></span><span class="mi" id="MathJax-Span-20" style="font-family: MathJax_Math; font-style: italic; padding-left: 0.278em;">H<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.057em;"></span></span><span class="mi" id="MathJax-Span-21" style="font-family: MathJax_Math; font-style: italic;">e</span><span class="mi" id="MathJax-Span-22" style="font-family: MathJax_Math; font-style: italic;">i</span><span class="mi" id="MathJax-Span-23" style="font-family: MathJax_Math; font-style: italic;">g<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-24" style="font-family: MathJax_Math; font-style: italic;">h</span><span class="mi" id="MathJax-Span-25" style="font-family: MathJax_Math; font-style: italic;">t</span><span class="mo" id="MathJax-Span-26" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-27" style="font-family: MathJax_Math; font-style: italic;">R</span><span class="mi" id="MathJax-Span-28" style="font-family: MathJax_Math; font-style: italic;">i</span><span class="mi" id="MathJax-Span-29" style="font-family: MathJax_Math; font-style: italic;">g<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-30" style="font-family: MathJax_Math; font-style: italic;">h</span><span class="mi" id="MathJax-Span-31" style="font-family: MathJax_Math; font-style: italic;">t</span><span class="mi" id="MathJax-Span-32" style="font-family: MathJax_Math; font-style: italic;">S<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.032em;"></span></span><span class="mi" id="MathJax-Span-33" style="font-family: MathJax_Math; font-style: italic;">u</span><span class="mi" id="MathJax-Span-34" style="font-family: MathJax_Math; font-style: italic;">b</span><span class="mi" id="MathJax-Span-35" style="font-family: MathJax_Math; font-style: italic;">t</span><span class="mi" id="MathJax-Span-36" style="font-family: MathJax_Math; font-style: italic;">r</span><span class="mi" id="MathJax-Span-37" style="font-family: MathJax_Math; font-style: italic;">e</span><span class="mi" id="MathJax-Span-38" style="font-family: MathJax_Math; font-style: italic;">e</span><span class="mo" id="MathJax-Span-39" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-40" style="font-family: MathJax_Math; font-style: italic;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.085em;"></span></span><span class="mo" id="MathJax-Span-41" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-42" style="font-family: MathJax_Main;">)</span><span style="display: inline-block; width: 0px; height: 4em;"></span></span><span style="position: absolute; clip: rect(3.1em, 1011.58em, 4.4em, -1000em); top: -2.569em; left: 0em;"><span class="mo" id="MathJax-Span-43" style="font-family: MathJax_Main;">–</span><span class="mi" id="MathJax-Span-44" style="font-family: MathJax_Math; font-style: italic; padding-left: 0.167em;">H<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.057em;"></span></span><span class="mi" id="MathJax-Span-45" style="font-family: MathJax_Math; font-style: italic;">e</span><span class="mi" id="MathJax-Span-46" style="font-family: MathJax_Math; font-style: italic;">i</span><span class="mi" id="MathJax-Span-47" style="font-family: MathJax_Math; font-style: italic;">g<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-48" style="font-family: MathJax_Math; font-style: italic;">h</span><span class="mi" id="MathJax-Span-49" style="font-family: MathJax_Math; font-style: italic;">t</span><span class="mo" id="MathJax-Span-50" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-51" style="font-family: MathJax_Math; font-style: italic;">L</span><span class="mi" id="MathJax-Span-52" style="font-family: MathJax_Math; font-style: italic;">e</span><span class="mi" id="MathJax-Span-53" style="font-family: MathJax_Math; font-style: italic;">f<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.06em;"></span></span><span class="mi" id="MathJax-Span-54" style="font-family: MathJax_Math; font-style: italic;">t</span><span class="mi" id="MathJax-Span-55" style="font-family: MathJax_Math; font-style: italic;">S<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.032em;"></span></span><span class="mi" id="MathJax-Span-56" style="font-family: MathJax_Math; font-style: italic;">u</span><span class="mi" id="MathJax-Span-57" style="font-family: MathJax_Math; font-style: italic;">b</span><span class="mi" id="MathJax-Span-58" style="font-family: MathJax_Math; font-style: italic;">t</span><span class="mi" id="MathJax-Span-59" style="font-family: MathJax_Math; font-style: italic;">r</span><span class="mi" id="MathJax-Span-60" style="font-family: MathJax_Math; font-style: italic;">e</span><span class="mi" id="MathJax-Span-61" style="font-family: MathJax_Math; font-style: italic;">e</span><span class="mo" id="MathJax-Span-62" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-63" style="font-family: MathJax_Math; font-style: italic;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.085em;"></span></span><span class="mo" id="MathJax-Span-64" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-65" style="font-family: MathJax_Main;">)</span><span style="display: inline-block; width: 0px; height: 4em;"></span></span></span></span><span style="display: inline-block; width: 0px; height: 4em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -2.163em; border-left: 0px solid; width: 0px; height: 3.163em;"></span></span> 
  <span class="MJX_Assistive_MathML"> 
    
    
      B 
     
    
      a 
     
    
      l 
     
    
      a 
     
    
      n 
     
    
      c 
     
    
      e 
     
    
      F 
     
    
      a 
     
    
      c 
     
    
      t 
     
    
      o 
     
    
      r 
     
    
      ( 
     
    
      N 
     
    
      ) 
     
    
      := 
     
    
      H 
     
    
      e 
     
    
      i 
     
    
      g 
     
    
      h 
     
    
      t 
     
    
      ( 
     
    
      R 
     
    
      i 
     
    
      g 
     
    
      h 
     
    
      t 
     
    
      S 
     
    
      u 
     
    
      b 
     
    
      t 
     
    
      r 
     
    
      e 
     
    
      e 
     
    
      ( 
     
    
      N 
     
    
      ) 
     
    
      ) 
     
    
      – 
     
    
      H 
     
    
      e 
     
    
      i 
     
    
      g 
     
    
      h 
     
    
      t 
     
    
      ( 
     
    
      L 
     
    
      e 
     
    
      f 
     
    
      t 
     
    
      S 
     
    
      u 
     
    
      b 
     
    
      t 
     
    
      r 
     
    
      e 
     
    
      e 
     
    
      ( 
     
    
      N 
     
    
      ) 
     
    
      ) 
     
   </span></span><script type="math/tex" id="MathJax-Element-1">BalanceFactor(N) := Height(RightSubtree(N)) – Height(LeftSubtree(N))</script></p> 
<blockquote> 
 <p><strong>注意</strong>: 有些教材或者教程，定义平衡因子为左子树高度减去右子树高度，这个做法对于维护树的平衡没有影响，只要在失去平衡时做对应调整即可。</p> 
</blockquote> 
<p>平衡因子的取值范围为: </p> 
<p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-2-Frame" tabindex="0" style="position: relative;"> 
   
   <span class="math" id="MathJax-Span-66" style="width: 16.703em; display: inline-block;"><span style="display: inline-block; position: relative; width: 13.35em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.55em, 1013.28em, 2.85em, -1000em); top: -2.45em; left: 0em;"><span class="mrow" id="MathJax-Span-67"><span class="mi" id="MathJax-Span-68" style="font-family: MathJax_Math; font-style: italic;">B</span><span class="mi" id="MathJax-Span-69" style="font-family: MathJax_Math; font-style: italic;">a</span><span class="mi" id="MathJax-Span-70" style="font-family: MathJax_Math; font-style: italic;">l</span><span class="mi" id="MathJax-Span-71" style="font-family: MathJax_Math; font-style: italic;">a</span><span class="mi" id="MathJax-Span-72" style="font-family: MathJax_Math; font-style: italic;">n</span><span class="mi" id="MathJax-Span-73" style="font-family: MathJax_Math; font-style: italic;">c</span><span class="mi" id="MathJax-Span-74" style="font-family: MathJax_Math; font-style: italic;">e</span><span class="mi" id="MathJax-Span-75" style="font-family: MathJax_Math; font-style: italic;">F<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.106em;"></span></span><span class="mi" id="MathJax-Span-76" style="font-family: MathJax_Math; font-style: italic;">a</span><span class="mi" id="MathJax-Span-77" style="font-family: MathJax_Math; font-style: italic;">c</span><span class="mi" id="MathJax-Span-78" style="font-family: MathJax_Math; font-style: italic;">t</span><span class="mi" id="MathJax-Span-79" style="font-family: MathJax_Math; font-style: italic;">o</span><span class="mi" id="MathJax-Span-80" style="font-family: MathJax_Math; font-style: italic;">r</span><span class="mo" id="MathJax-Span-81" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-82" style="font-family: MathJax_Math; font-style: italic;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.085em;"></span></span><span class="mo" id="MathJax-Span-83" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-84" style="font-family: MathJax_Main; padding-left: 0.278em;">∈</span><span class="texatom" id="MathJax-Span-85" style="padding-left: 0.278em;"><span class="mrow" id="MathJax-Span-86"><span class="mo" id="MathJax-Span-87" style="font-family: MathJax_Main;">–</span><span class="mn" id="MathJax-Span-88" style="font-family: MathJax_Main; padding-left: 0.167em;">1</span><span class="mo" id="MathJax-Span-89" style="font-family: MathJax_Main;">,</span><span class="mn" id="MathJax-Span-90" style="font-family: MathJax_Main; padding-left: 0.167em;">0</span><span class="mo" id="MathJax-Span-91" style="font-family: MathJax_Main;">,</span><span class="mo" id="MathJax-Span-92" style="font-family: MathJax_Main; padding-left: 0.167em;">+</span><span class="mn" id="MathJax-Span-93" style="font-family: MathJax_Main;">1</span></span></span></span><span style="display: inline-block; width: 0px; height: 2.45em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.375em; border-left: 0px solid; width: 0px; height: 1.375em;"></span></span> 
  <span class="MJX_Assistive_MathML"> 
    
    
      B 
     
    
      a 
     
    
      l 
     
    
      a 
     
    
      n 
     
    
      c 
     
    
      e 
     
    
      F 
     
    
      a 
     
    
      c 
     
    
      t 
     
    
      o 
     
    
      r 
     
    
      ( 
     
    
      N 
     
    
      ) 
     
    
      ∈ 
     
     
     
       – 
      
     
       1 
      
     
       , 
      
     
       0 
      
     
       , 
      
     
       + 
      
     
       1 
      
     
   </span></span><script type="math/tex" id="MathJax-Element-2">BalanceFactor(N) ∈ {–1,0,+1}</script>。</p> 
<p>这个取值范围表明: <strong>对于AVL树中任何一个节点N，其左右子树的高度差绝对值最大为1。</strong>对于一个节点N，如果bf &lt;0 则表示节点N的左子树比右子树高；而 bf &gt; 0 则表示节点N的右子树比左子树高。当bf=0时，则说明左子树和右子树等高。下图是标记了平衡因子的一棵AVL：</p> 
<p><img src="https://images2.imgbox.com/af/be/48ce7FoK_o.png" alt="AVL" title=""></p> 
<p>下图是AVL和非AVL的一个对比:</p> 
<p><img src="https://images2.imgbox.com/62/cf/wlt4chSy_o.png" alt="AVL2" title=""></p> 
<p>如何定义AVL树的节点呢？ 不同的教材或者教程，不同语言，给出了不同定义，例如<strong><a href="http://rosettacode.org/wiki/AVL_tree#Python" rel="nofollow">版本1</a></strong>：</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVLNode</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-string">"""A node in the AVL tree."""</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, parent, k)</span>:</span>
        <span class="hljs-string">"""Creates a node.

        Args:
            parent: The node's parent.
            k: key of the node.
        """</span>
        self.key = k
        self.parent = parent
        self.left = <span class="hljs-keyword">None</span>
        self.right = <span class="hljs-keyword">None</span></code></pre> 
<p><strong><a href="https://github.com/pgrafov/python-avl-tree/blob/master/pyavltree.py">版本2</a></strong>:</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, key)</span>:</span>
        self.key = key
        self.parent = <span class="hljs-keyword">None</span>
        self.leftChild = <span class="hljs-keyword">None</span>
        self.rightChild = <span class="hljs-keyword">None</span>
        self.height = <span class="hljs-number">0</span></code></pre> 
<p>各种不同版本定义不尽相同， 这里<strong>需要注意一点是</strong>: 使用平衡因子来确定AVL节点平衡，比使用高度来维护AVL节点平衡，代价要小，使用高度时<strong>很可能进行了不必要的高度计算，从而影响算法效率。</strong> 当然，<strong>采用平衡因子的实现则相对要复杂多了</strong>，维护平衡因子的工作比计算节点的高度更难以控制。</p> 
<p>我们定义的版本如下:</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVLTreeNode</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-string">"""
    树节点
    """</span>
    LEFT_HIGHER = -<span class="hljs-number">1</span>
    EQUAL_HEIGHT = <span class="hljs-number">0</span>
    RIGHT_HIGHER = <span class="hljs-number">1</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, data, left=None, 
    right=None, parent=None, bf=<span class="hljs-number">0</span>)</span>:</span>
        self.data = data
        self.left, self.right = left, right
        self.parent = parent
        self.bf = bf

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> str(self.data) + <span class="hljs-string">"bf("</span> + str(self.bf) + <span class="hljs-string">")"</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.__str__()</code></pre> 
<h4 id="23-avl调整的基本操作">2.3 AVL调整的基本操作</h4> 
<p>在AVL上进行插入或者删除操作后，可能引起插入节点到根节点路径上某个节点失去平衡。这个时候为了维持AVL的特性，即任意节点的左右子树高度差绝对值最大为1，我们需要根据不同情况，进行相应地调整。定义4个基本的调整操作如下。</p> 
<p><strong>case 1: LL类型，只需要一次右旋转调整即可。</strong></p> 
<pre class="prettyprint"><code class=" hljs tex">T1, T2, T3 and T4 are subtrees.
         z                                      y 
        / <span class="hljs-command">\ </span>                                  /   <span class="hljs-command">\
</span>       y   T4      Right Rotate (z)          x      z
      / <span class="hljs-command">\ </span>         - - - - - - - - -&gt;      /  <span class="hljs-command">\ </span>   /  <span class="hljs-command">\ </span>
     x   T3                               T1  T2  T3  T4
    / <span class="hljs-command">\
</span>  T1   T2</code></pre> 
<p>根据上面的节点定义，我们实现为:</p> 
<pre class="prettyprint"><code class="language-python hljs ">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">right_rotate</span><span class="hljs-params">(self, node)</span>:</span>
        <span class="hljs-string">"""
        右旋转调整节点node
            p                       q
           / \                     /  \
          q   s     =&gt;            ql   p
         /  \                         / \
        ql  qr                       qr  s
        :param node: 待调整节点
        :return: None
        """</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> node.left:
            <span class="hljs-keyword">raise</span> AssertionError(
            <span class="hljs-string">" right rotate to illegal node "</span> + str(node))
        parent_node = node.parent
        node_left = node.left
        node.left = node_left.right
        <span class="hljs-keyword">if</span> node.left:
            node.left.parent = node
        node_left.right = node
        node.parent = node_left
        <span class="hljs-keyword">if</span> parent_node:
            <span class="hljs-keyword">if</span> node == parent_node.left:
                parent_node.left = node_left
            <span class="hljs-keyword">else</span>:
                parent_node.right = node_left
            node_left.parent = parent_node
        <span class="hljs-keyword">else</span>:
            self.root = node_left
            node_left.parent = <span class="hljs-keyword">None</span></code></pre> 
<p>上面实现中<strong>需要注意</strong>的是，因为需要引入了节点的parent指针，因此在旋转过程中也需要维护这个指针，如果忽略了这一点将造成程序错误。可以看出引入parent指针，也增加了实现的复杂性。作为一个具体的例子，依次插入节点3,2,1，调整如下图所示:</p> 
<p><img src="https://images2.imgbox.com/78/dd/4k39C11m_o.png" alt="插入右旋转" title=""></p> 
<p><strong>case 2: RR类型，只需要一次左旋转调整。</strong></p> 
<pre class="prettyprint"><code class=" hljs tex"> z                                y
 /  <span class="hljs-command">\ </span>                           /   <span class="hljs-command">\ </span>
T1   y     Left Rotate(z)       z      x
    /  <span class="hljs-command">\ </span>  - - - - - - - -&gt;    / <span class="hljs-command">\ </span>   / <span class="hljs-command">\
</span>   T2   x                     T1  T2 T3  T4
       / <span class="hljs-command">\
</span>     T3  T4</code></pre> 
<p>右旋转的实现和左旋转类似，实现代码在此略去。</p> 
<p><strong>case 3 : LR类型，先进行左旋转，然后进行一次右旋转。</strong></p> 
<pre class="prettyprint"><code class=" hljs tex">     z                               z                           x
    / <span class="hljs-command">\ </span>                           /   <span class="hljs-command">\ </span>                       /  <span class="hljs-command">\ </span>
   y   T4  Left Rotate (y)        x    T4  Right Rotate(z)    y      z
  / <span class="hljs-command">\ </span>     - - - - - - - - -&gt;    /  <span class="hljs-command">\ </span>     - - - - - - - -&gt;  / <span class="hljs-command">\ </span>   / <span class="hljs-command">\
</span>T1   x                          y    T3                    T1  T2 T3  T4
    / <span class="hljs-command">\ </span>                       / <span class="hljs-command">\
</span>  T2   T3                    T1   T2</code></pre> 
<p>这个情况相比之前情况，显得复杂一些，<strong>需要注意的是</strong>:进行两次旋转的作用节点并不是同一个，进行左旋转时支点是失去平衡的节点z的左孩子节点y，进行右旋转时支点是失去平衡的节点z。</p> 
<p>对应的python实现为:</p> 
<pre class="prettyprint"><code class="language-python hljs ">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">left_right_rotate</span><span class="hljs-params">(self, node)</span>:</span>
        <span class="hljs-string">"""
        先左旋转 然后右旋转调整节点node
        :param node: 待调整节点
        :return: None
        """</span>
        self.left_rotate(node.left)
        self.right_rotate(node)</code></pre> 
<p>一个具体的例子，例如依次插入节点3,1,2，调整如下图所示:</p> 
<p><img src="https://images2.imgbox.com/75/41/BSjtDRnp_o.png" alt="调整节点" title=""></p> 
<p><strong>case 4: RL类型，先进行一次右旋转，然后进行一次左旋转。</strong></p> 
<pre class="prettyprint"><code class=" hljs tex">   z                            z                            x
  / <span class="hljs-command">\ </span>                         / <span class="hljs-command">\ </span>                         /  <span class="hljs-command">\ </span>
T1   y   Right Rotate (y)    T1   x      Left Rotate(z)   z      y
    / <span class="hljs-command">\ </span> - - - - - - - - -&gt;     /  <span class="hljs-command">\ </span>  - - - - - - - -&gt;  / <span class="hljs-command">\ </span>   / <span class="hljs-command">\
</span>   x   T4                      T2   y                  T1  T2  T3  T4
  / <span class="hljs-command">\ </span>                             /  <span class="hljs-command">\
</span>T2   T3                           T3   T4</code></pre> 
<h4 id="24-avl的插入操作">2.4 AVL的插入操作</h4> 
<p>插入操作的过程包括两个阶段：</p> 
<blockquote> 
 <p>1) 根据插入元素，找到插入位置，插入元素，这个过程和普通BST一样。 <br> 2) 更新插入节点的父节点到根节点路径上的节点的平衡因子，如果某个节点失去平衡，则需要进行调整。</p> 
</blockquote> 
<p>插入一个新节点，改变的是从这个节点的父节点到根节点路径上节点的平衡因子，只有这条路径上的节点才会出现不平衡现象。如下图所示(来自<a href="http://www.mathcs.emory.edu/~cheung/Courses/323/Syllabus/Trees/AVL-insert.html" rel="nofollow">AVL-insert</a>)：</p> 
<p><img src="https://images2.imgbox.com/87/c0/ksMWuaCD_o.png" alt="插入节点" title=""></p> 
<p>在上图中左边AVL插入节点46，影响的绿色部分表示的路径上节点的高度，我们需要调整的也是这条路径上节点的平衡因子。</p> 
<p>这里需要<strong>注意的一个关键问题是</strong>： <strong>什么时候停止更新节点平衡因子？</strong> 如果遇到一个节点，在插入新节点后高度不变，则可以停止更新了，因为它的祖先节点都没有受到影响。这样，我们需要一个布尔变量标志taller来记录树的高度是否发生了变化。</p> 
<p>在python中要改变函数传递的对象，这个对象必须是可变对象(参见<a href="http://blog.csdn.net/wangdingqiaoit/article/details/77620393">python快速入门篇1</a>)，而内置的bool变量时不可变的，因此我们自己封装一个可变布尔对象，如下:</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoolObject</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-string">"""
    可变布尔对象
    """</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, status=False)</span>:</span>
        self.status = status

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_status</span><span class="hljs-params">(self, status)</span>:</span>
        self.status = status

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_status</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.status

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> (self.status <span class="hljs-keyword">and</span> <span class="hljs-string">'True'</span>) <span class="hljs-keyword">or</span> <span class="hljs-string">'False'</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.__str__()</code></pre> 
<p>在插入节点时，先考虑插入当前节点左孩子的情况。一共细分为4种情况，假设插入节点为X，则调整过程如下所示:</p> 
<p><strong>case 1</strong>: 插入之前A平衡因子已经为-1了，再次插入A左子树，同时是B节点平衡因子变为-1，则A失去平衡，属于LL类型，需要右旋转处理。</p> 
<pre class="prettyprint"><code class=" hljs mathematica">       A                                  B
      /  \                              /  \ 
      B   <span class="hljs-keyword">C</span>(h)    right rotate(A)      /    \
     /  \         ================&gt;    <span class="hljs-keyword">D</span>(h)  A
    /    \                             |    / \
    <span class="hljs-keyword">D</span>(h)  <span class="hljs-keyword">E</span>                            X    <span class="hljs-keyword">E</span>  <span class="hljs-keyword">C</span>(h)
    |
    X</code></pre> 
<p><strong>case 2</strong>: 插入前A平衡因子为-1，再次插入A的左子树，这次B的平衡因子变为+1，属于LR类型，但是对于节点E的平衡因子需要进行讨论，因此一共包括3中细分情况，如下:</p> 
<p><strong>case 2a:</strong> 插入后E节点平衡因子为-1。</p> 
<pre class="prettyprint"><code class=" hljs tex">      A                                     A                                   E
     / <span class="hljs-command">\ </span>                                  / <span class="hljs-command">\ </span>                               /   <span class="hljs-command">\
</span>    /   <span class="hljs-command">\ </span>                                /   <span class="hljs-command">\ </span>                             /     <span class="hljs-command">\
</span>    B    C(h)       left rotate(B)        E    C     right rotate(A)         B       A
   / <span class="hljs-command">\ </span>             ================&gt;    / <span class="hljs-command">\ </span>        ================&gt;      / <span class="hljs-command">\ </span>    / <span class="hljs-command">\
</span>  /   <span class="hljs-command">\ </span>                                /   <span class="hljs-command">\ </span>                             /   <span class="hljs-command">\ </span>  /   <span class="hljs-command">\
</span>  D    E                                B    G                             D    F  G   C
      / <span class="hljs-command">\ </span>                             / <span class="hljs-command">\ </span>                                     |
      F  G(h-1)                        D  F                                     X 
      |                                   |                                   
      X                                   X
</code></pre> 
<p><strong>case 2b</strong>: 插入后E平衡因子为+1。</p> 
<pre class="prettyprint"><code class=" hljs tex">      A                                     A                                   E
     / <span class="hljs-command">\ </span>                                  / <span class="hljs-command">\ </span>                               /   <span class="hljs-command">\
</span>    /   <span class="hljs-command">\ </span>                                /   <span class="hljs-command">\ </span>                             /     <span class="hljs-command">\
</span>    B    C(h)       left rotate(B)        E    C     right rotate(A)        B       A
   / <span class="hljs-command">\ </span>             ================&gt;    / <span class="hljs-command">\ </span>        ================&gt;     / <span class="hljs-command">\ </span>    / <span class="hljs-command">\
</span>  /   <span class="hljs-command">\ </span>                                /   <span class="hljs-command">\ </span>                            /   <span class="hljs-command">\ </span>  /   <span class="hljs-command">\
</span>  D    E                                B    G                            D    F  G   C
      / <span class="hljs-command">\ </span>                             / <span class="hljs-command">\ </span>  |                                    |
      F  G(h-1)                        D  F  X                                    X 
         |                                                                      
         X                                   </code></pre> 
<p><strong>case 3c</strong>: 插入后E的平衡因子为0。</p> 
<pre class="prettyprint"><code class=" hljs autohotkey">       <span class="hljs-literal">A</span>                               <span class="hljs-literal">A</span>                              E
      /                               /                              / \
     B           left roate(B)        E       right rotate(<span class="hljs-literal">A</span>)       /   \
      \          ================&gt;   /        ================&gt;     B    <span class="hljs-literal">A</span>
       E                             B</code></pre> 
<p>上面情况，总结如下表所示:</p> 
<table><thead><tr><th align="left">旋转之前</th><th align="right">旋转类型</th><th align="center">旋转之后</th></tr></thead><tbody><tr><td align="left">A=-2, B=-1</td><td align="right">一次右旋转</td><td align="center">A=0, B= 0</td></tr><tr><td align="left">A=-2, B=+1, E=-1</td><td align="right">先左旋转，后右旋转</td><td align="center">A=+1, B=0, E=0</td></tr><tr><td align="left">A=-2, B=+1, E=+1</td><td align="right">先左旋转，后右旋转</td><td align="center">A=0, B=-1, E=0</td></tr><tr><td align="left">A=-2, B=+1, E=0</td><td align="right">先左旋转，后右旋转</td><td align="center">A=0, B=0, E=0</td></tr></tbody></table> 
<p>对于插入当前节点右孩子的情况，也有类似讨论，限于篇幅，这里略去，留给读者自行练习。总结上述过程，插入节点部分实现为：</p> 
<pre class="prettyprint"><code class="language-python hljs ">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__add_value__</span><span class="hljs-params">(self, node, value, taller)</span>:</span>
        result = <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
            result = <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">elif</span> node.data == value:
            result = <span class="hljs-keyword">False</span>       <span class="hljs-comment"># duplicate</span>
        <span class="hljs-keyword">elif</span> value &lt; node.data:
            <span class="hljs-keyword">if</span> node.left:
                result = self.__add_value__(node.left, value, taller)
            <span class="hljs-keyword">else</span>:
                node.left = AVLTreeNode(value, parent=node)
                taller.set_status(<span class="hljs-keyword">True</span>)
            <span class="hljs-keyword">if</span> result <span class="hljs-keyword">and</span> taller.get_status():
                <span class="hljs-keyword">if</span> node.bf == AVLTreeNode.LEFT_HIGHER:  <span class="hljs-comment"># 在左子树插入前已经左边高则需要平衡处理</span>
                    self.left_balance(node)
                    taller.set_status(<span class="hljs-keyword">False</span>)
                <span class="hljs-keyword">elif</span> node.bf == AVLTreeNode.EQUAL_HEIGHT:  <span class="hljs-comment"># 在左子树插入前节点平衡则现在左边变高</span>
                    node.bf = AVLTreeNode.LEFT_HIGHER
                <span class="hljs-keyword">else</span>:
                    node.bf = AVLTreeNode.EQUAL_HEIGHT  <span class="hljs-comment"># 在左子树插入前节点右边高则现在平衡了</span>
                    taller.set_status(<span class="hljs-keyword">False</span>)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> node.right:
                result = self.__add_value__(node.right, value, taller)
            <span class="hljs-keyword">else</span>:
                node.right = AVLTreeNode(value, parent=node)
                taller.set_status(<span class="hljs-keyword">True</span>)
            <span class="hljs-keyword">if</span> result <span class="hljs-keyword">and</span> taller.get_status():
                <span class="hljs-keyword">if</span> node.bf == AVLTreeNode.LEFT_HIGHER:  <span class="hljs-comment"># 插入右子树前节点左边高则现在平衡了</span>
                    node.bf = AVLTreeNode.EQUAL_HEIGHT
                    taller.set_status(<span class="hljs-keyword">False</span>)
                <span class="hljs-keyword">elif</span> node.bf == AVLTreeNode.EQUAL_HEIGHT:  <span class="hljs-comment"># 插入右子树前节点平衡则现在右边高了</span>
                    node.bf = AVLTreeNode.RIGHT_HIGHER
                <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 插入右子树前节点已经右边高了则需要平衡处理</span>
                    self.right_balance(node)
                    taller.set_status(<span class="hljs-keyword">False</span>)
        <span class="hljs-keyword">return</span> result</code></pre> 
<p>上面分析的插入当前节点左孩子，而进行的左平衡处理过程，实现为：</p> 
<pre class="prettyprint"><code class="language-python hljs ">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">left_balance</span><span class="hljs-params">(self, node)</span>:</span>
        <span class="hljs-string">"""
        左平衡处理
        :param node: 待处理节点
        :return: None
        """</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> node.left:
            <span class="hljs-keyword">raise</span> AssertionError(<span class="hljs-string">" left balance to illegal node "</span> + str(node))
        left_node = node.left
        <span class="hljs-keyword">if</span> left_node.bf == AVLTreeNode.LEFT_HIGHER:   <span class="hljs-comment"># LL型 右旋转</span>
            node.bf = AVLTreeNode.EQUAL_HEIGHT
            left_node.bf = AVLTreeNode.EQUAL_HEIGHT
            self.right_rotate(node)
        <span class="hljs-keyword">elif</span> left_node.bf == AVLTreeNode.RIGHT_HIGHER:    <span class="hljs-comment"># LR型 先左旋转 后右旋转</span>
            left_node_right = left_node.right
            <span class="hljs-keyword">if</span> left_node_right.bf == AVLTreeNode.LEFT_HIGHER:
                node.bf = AVLTreeNode.RIGHT_HIGHER
                left_node.bf = AVLTreeNode.EQUAL_HEIGHT
            <span class="hljs-keyword">elif</span> left_node_right.bf == AVLTreeNode.RIGHT_HIGHER:
                node.bf = AVLTreeNode.EQUAL_HEIGHT
                left_node.bf = AVLTreeNode.LEFT_HIGHER
            <span class="hljs-keyword">else</span>:
                node.bf = AVLTreeNode.EQUAL_HEIGHT
                left_node.bf = AVLTreeNode.EQUAL_HEIGHT
            left_node_right.bf = AVLTreeNode.EQUAL_HEIGHT
            self.left_rotate(left_node)
            self.right_rotate(node)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> AssertionError(<span class="hljs-string">" logic error , should not left balance node "</span> + str(node))</code></pre> 
<h4 id="25-一个完整的插入示例">2.5 一个完整的插入示例</h4> 
<p>插入元素序列为{ 50, 25, 10, 5, 7, 3, 30, 20, 8, 15 }，过程如下图所示(来自<a href="https://www.cs.wcupa.edu/rkline/ds/avl-trees.html" rel="nofollow">AVL Trees </a>)：</p> 
<p><img src="https://images2.imgbox.com/38/fb/Gv1943ms_o.png" alt="插入过程" title=""></p> 
<h4 id="26-avl删除操作">2.6 AVL删除操作</h4> 
<p>删除操作也包括两个步骤：</p> 
<blockquote> 
 <p>1)以BST方式删除节点，使用复制删除方法，将删除节点归一化为删除最多只有一个孩子的情况。 <br> 2)调整删除节点父节点到根节点路径上节点的平衡因子，如果节点失去平衡则进行调整。</p> 
</blockquote> 
<p>调整过程和插入时很类似，但是仍然要<strong>注意一个关键问题</strong>: 什么时候停止调整？ 停止条件是当删除节点对当前节点的高度没有影响时停止，<strong>与插入节点不同，这种调整可能超过一次</strong>。如下图所示：</p> 
<p><img src="https://images2.imgbox.com/5b/e1/YAqns4dd_o.png" alt="删除调整" title=""></p> 
<p>b图中删除了节点80，需要调整节点75，调整完毕后，节点50出现不平衡，仍然需要继续调整。我们同样设置一个布尔变量shorter来保存树高度变化的情况，当删除节点x后根据情况设置shorter变量，当shorter=false时则说明可以停止更新节点平衡因子了。</p> 
<h4 id="261-删除节点的过程">2.6.1 删除节点的过程</h4> 
<p>删除节点的完整算法原文描述为：(来自<a href="https://cs.gmu.edu/~setia/cs310/slides/avl.pdf" rel="nofollow">Height Balance: AVL Trees</a>):</p> 
<blockquote> 
 <ol><li>Reduce the problem to the case when the node x to be removed has at most one child. </li><li>Delete x. We use a bool variable shorter to show if the height of a subtree has been shortened.</li><li>While shorter is true do the following steps for each node P on the path from the <br> parent of x to the root of the tree. When shorter becomes false, the algorithm terminates. <br> <strong>Case 1</strong>: Node P has balance factor equal. The balance factor of P is changed according <br> as its left or right subtree has been shortened, and shorter becomes false. <br> <strong>Case 2</strong>: The balance factor of P is not equal, and the taller subtree was shortened. <br> Change the balance factor of P to equal, and leave shorter as true. <br> <strong>Case 3</strong>: The balance factor of P is not equal, and the shorter subtree was shortened. <br> Apply a rotation as follows to restore balance. Let Q be the root of the taller subtree of P. <br> <strong>Case 3a</strong>: The balance factor of Q is equal. A single rotation restores balance, and shorter becomes false. <br> <strong>Case 3b</strong>: The balance factor of Q is the same as that of P. <br> Apply a single rotation, set the balance factors of P and Q to equal, and leave shorter as true. <br> <strong>Case 3c</strong>: The balance factors of P and Q are opposite. Apply a double rotation (first around Q, then around P), <br> set the balance factor of the new root to equal and the other balance factors as appropriate, and leave shorter as true.</li></ol> 
</blockquote> 
<p>也就是:</p> 
<pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-number">1.</span> 将问题归一化为，删除x节点时，它最多只有一个孩子节点。

<span class="hljs-number">2.</span>删除x。使用一个布尔变量shorter来记录子树的高度是否变低了。

<span class="hljs-number">3.</span> 当shorter为<span class="hljs-constant">true</span>时，对x的父节点到根节点路径上的节点P执行下列步骤；当shorter变为<span class="hljs-constant">false</span>时，算法终止。

<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>： 节点P的平衡因子为<span class="hljs-number">0</span>。节点P的左子树或者右子树高度被降低，这时shorter设置为<span class="hljs-constant">false</span>。

<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>： P的平衡因子不为<span class="hljs-number">0</span>，并且较高的子树高度降低了，这时将P的平衡因子置为<span class="hljs-number">0</span>，让shorter保持为<span class="hljs-constant">true</span>。

<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: P的平衡因子不为<span class="hljs-number">0</span>，并且较矮的子树高度降低了，这个时候需要进行旋转调整。设P的较高子树的根节点为Q。

<span class="hljs-keyword">case</span> <span class="hljs-number">3</span><span class="hljs-operator">a</span>: Q的平衡因子为<span class="hljs-number">0</span>，需要进行一次旋转，并且shorter置为<span class="hljs-constant">false</span>。

<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>b: Q的平衡因子和P一致。进行一次旋转，设置P和Q的平衡因子为<span class="hljs-number">0</span>，shorter置为<span class="hljs-constant">true</span>。

<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>c: Q的平衡因子和P相反，进行两次旋转，首先旋转Q，然后旋转P。
设置新根节点平衡因子为<span class="hljs-number">0</span>，其他平衡因子为合适值，shorter置为<span class="hljs-constant">true</span>。</code></pre> 
<p>在上面提到了3种情形，分别如下所示。</p> 
<p><strong>case 1</strong>： 节点P的平衡因子为0。节点P的左子树或者右子树高度被降低，这时shorter设置为false。</p> 
<pre class="prettyprint"><code class=" hljs tex">          P(0)                               P(+1)
        /     <span class="hljs-command">\ </span>    remove x from A         /    <span class="hljs-command">\ </span>      shorter = false
       /       <span class="hljs-command">\ </span>   ==================&gt;    /      <span class="hljs-command">\ </span>     =========================
      A(h)   B(h)                          A(h-1)   B(h)</code></pre> 
<p><strong>case 2</strong>： P的平衡因子不为0，并且较高的子树高度降低了，这时将P的平衡因子置为0，让shorter保持为true。</p> 
<pre class="prettyprint"><code class=" hljs tex">          P(+1)                                P(0)
        /     <span class="hljs-command">\ </span>    remove x from B           /    <span class="hljs-command">\ </span>   shorter = true
       /       <span class="hljs-command">\ </span>   ==================&gt;      /      <span class="hljs-command">\ </span>    ====================
      A(h)   B(h+1)                          A(h)   B(h)</code></pre> 
<p><strong>case 3a</strong>: Q的平衡因子为0，需要进行一次旋转，并且shorter置为false。</p> 
<pre class="prettyprint"><code class=" hljs tex">        P(+1)                                                      Q(-1)
      /      <span class="hljs-command">\ </span>         remove x from A     left rotate P         /     <span class="hljs-command">\
</span>     /        <span class="hljs-command">\ </span>        ==================================&gt;      /       <span class="hljs-command">\ </span>       shorter = false
    A(h)      Q(0)                                              P(+1)    Qr(h)    ================
             /     <span class="hljs-command">\ </span>                                           /      <span class="hljs-command">\
</span>            /       <span class="hljs-command">\ </span>                                         /        <span class="hljs-command">\
</span>           Ql(h)   Qr(h)                                     A(h-1)     Ql(h)</code></pre> 
<p><strong>case 3b</strong>: Q的平衡因子和P一致。进行一次旋转，设置P和Q的平衡因子为0，shorter置为true。</p> 
<pre class="prettyprint"><code class=" hljs tex">        P(+1)                                                      Q(0)
      /      <span class="hljs-command">\ </span>         remove x from A     left rotate P         /     <span class="hljs-command">\
</span>     /        <span class="hljs-command">\ </span>        ==================================&gt;      /       <span class="hljs-command">\ </span>       shorter = true
    A(h)      Q(+1)                                              P(0)    Qr(h)    ==============
               /     <span class="hljs-command">\ </span>                                         /      <span class="hljs-command">\
</span>              /       <span class="hljs-command">\ </span>                                       /        <span class="hljs-command">\
</span>           Ql(h-1)   Qr(h)                                    A(h-1)    Ql(h-1)</code></pre> 
<p><strong>case 3c</strong>: Q的平衡因子和P相反，进行两次旋转，首先旋转Q，然后旋转P。 <br> 设置新根节点平衡因子为0，其他平衡因子为合适值，shorter置为true。</p> 
<pre class="prettyprint"><code class=" hljs tex">       P(+1)                                                        P      
      /     <span class="hljs-command">\ </span>         remove x from A   right rotate Q            /   <span class="hljs-command">\ </span>             
     /       <span class="hljs-command">\ </span>        ==================================&gt;         A    Ql           
    A(h)     Q(-1)                                                      / <span class="hljs-command">\ </span>         
             /    <span class="hljs-command">\ </span>                                                    /   <span class="hljs-command">\ </span>      
            Ql     Qr(h-1)                                              Qll  Q      
          /  <span class="hljs-command">\ </span>                                                              /  <span class="hljs-command">\ </span>      
         Qll Qlr                                                            Qlr Qr      


                           Ql(0)                                
     left rotate P        /     <span class="hljs-command">\ </span>    shorter = true          
  ====================&gt;  /       <span class="hljs-command">\ </span> ==================    
                         P        Q                                       
                       /  <span class="hljs-command">\ </span>     /  <span class="hljs-command">\ </span>                                 
                      /    <span class="hljs-command">\ </span>   /    <span class="hljs-command">\ </span>                                
                   A(h-1)  Qll  Qlr  Qr(h-1)                             
</code></pre> 
<p>注意case 3c 情况里，对于节点Ql，我们仍然需要根据它的平衡因子进行讨论，因此这时候可以重复使用插入节点时的调整过程。递归删除结点的过程实现如下:</p> 
<pre class="prettyprint"><code class="language-python hljs ">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove_by_recursion</span><span class="hljs-params">(self, value)</span>:</span>
        <span class="hljs-keyword">return</span> self.__remove__(self.root, value, BoolObject(<span class="hljs-keyword">False</span>))

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__remove__</span><span class="hljs-params">(self, node, value, shorter)</span>:</span>
        result = <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        is_remove_at_right = <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">if</span> value == node.data:
            <span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">and</span> node.right:  <span class="hljs-comment"># case 被删除节点左右孩子都存在</span>
                min_node = node.right
                <span class="hljs-keyword">while</span> min_node.left:
                    min_node = min_node.left
                node.data = min_node.data
                is_remove_at_right = <span class="hljs-keyword">True</span>
                result = self.__remove__(node.right, node.data, shorter)
            <span class="hljs-keyword">else</span>:                        <span class="hljs-comment"># case 最多只有一个孩子存在</span>
                <span class="hljs-keyword">if</span> node.parent:
                    <span class="hljs-keyword">if</span> node == node.parent.left:
                        node.parent.left = node.left <span class="hljs-keyword">or</span> node.right
                        <span class="hljs-keyword">if</span> node.parent.left:
                            node.parent.left.parent = node.parent
                    <span class="hljs-keyword">else</span>:
                        node.parent.right = node.left <span class="hljs-keyword">or</span> node.right
                        <span class="hljs-keyword">if</span> node.parent.right:
                            node.parent.right.parent = node.parent
                    shorter.set_status(<span class="hljs-keyword">True</span>)
                <span class="hljs-keyword">else</span>:
                    self.root = node.left <span class="hljs-keyword">or</span> node.right
                    <span class="hljs-keyword">if</span> self.root:
                        self.root.parent = <span class="hljs-keyword">None</span>
                    shorter.set_status(<span class="hljs-keyword">False</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">elif</span> value &lt; node.data <span class="hljs-keyword">and</span> node.left:
            result = self.__remove__(node.left, value, shorter)
        <span class="hljs-keyword">elif</span> value &gt; node.data <span class="hljs-keyword">and</span> node.right:
            is_remove_at_right = <span class="hljs-keyword">True</span>
            result = self.__remove__(node.right, value, shorter)
        <span class="hljs-keyword">if</span> result <span class="hljs-keyword">and</span> shorter.get_status():
            self.remove_balance(node, is_remove_at_right, shorter)
        <span class="hljs-keyword">return</span> result</code></pre> 
<p>在删除时需要根据上述3种情形，进行调整，这个过程实现为：</p> 
<pre class="prettyprint"><code class="language-python hljs ">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove_balance</span><span class="hljs-params">(self, node, is_remove_at_right, shorter)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:
            <span class="hljs-keyword">raise</span> AssertionError(<span class="hljs-string">'remove_balance to empty node.'</span>)
        <span class="hljs-keyword">if</span> node.bf == AVLTreeNode.EQUAL_HEIGHT:  
            <span class="hljs-comment"># case 1 节点删除之前已经平衡 则调整平衡因子 树高度不变</span>
            node.bf = (is_remove_at_right <span class="hljs-keyword">and</span> AVLTreeNode.LEFT_HIGHER) <span class="hljs-keyword">or</span> AVLTreeNode.RIGHT_HIGHER
            shorter.set_status(<span class="hljs-keyword">False</span>)
        <span class="hljs-keyword">elif</span> (node.bf == AVLTreeNode.LEFT_HIGHER <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> is_remove_at_right) \
                <span class="hljs-keyword">or</span> (node.bf == AVLTreeNode.RIGHT_HIGHER <span class="hljs-keyword">and</span> is_remove_at_right): 
                <span class="hljs-comment"># case 2 节点删除之前不平衡在较高子树删除</span>
            node.bf = AVLTreeNode.EQUAL_HEIGHT
            shorter.set_status(<span class="hljs-keyword">True</span>)
            print(<span class="hljs-string">'remove balance case 2'</span>, node, shorter)
        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># case 3 节点删除之前不平衡 在较低子树删除节点后需要平衡处理</span>
            <span class="hljs-keyword">if</span> node.bf == AVLTreeNode.LEFT_HIGHER:
                left_node = node.left  <span class="hljs-comment"># 较高子树根</span>
                <span class="hljs-keyword">if</span> left_node.bf == AVLTreeNode.EQUAL_HEIGHT: 
                  <span class="hljs-comment"># case 3a 较高子树根节点平衡</span>
                    self.right_rotate(node)
                    left_node.bf = AVLTreeNode.RIGHT_HIGHER
                    shorter.set_status(<span class="hljs-keyword">False</span>)
                <span class="hljs-keyword">elif</span> left_node.bf == AVLTreeNode.LEFT_HIGHER: 
                   <span class="hljs-comment">#case 3b 较高子树根节点和node平衡因子一样</span>
                    self.right_rotate(node)
                    node.bf = AVLTreeNode.EQUAL_HEIGHT
                    left_node.bf = AVLTreeNode.EQUAL_HEIGHT
                    shorter.set_status(<span class="hljs-keyword">True</span>)
                <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># case 3c 较高子树根节点和node平衡因子相反</span>
                    self.left_balance(node)
                    shorter.set_status(<span class="hljs-keyword">True</span>)
            <span class="hljs-keyword">elif</span> node.bf == AVLTreeNode.RIGHT_HIGHER:
                right_child = node.right
                <span class="hljs-keyword">if</span> right_child.bf == AVLTreeNode.EQUAL_HEIGHT:
                    self.left_rotate(node)
                    right_child.bf = AVLTreeNode.LEFT_HIGHER
                    shorter.set_status(<span class="hljs-keyword">False</span>)
                <span class="hljs-keyword">elif</span> right_child.bf == AVLTreeNode.RIGHT_HIGHER:
                    self.left_rotate(node)
                    node.bf = AVLTreeNode.EQUAL_HEIGHT
                    right_child.bf = AVLTreeNode.EQUAL_HEIGHT
                <span class="hljs-keyword">else</span>:
                    self.right_balance(node)
                    shorter.set_status(<span class="hljs-keyword">True</span>)</code></pre> 
<h4 id="262-一个完整的删除示例">2.6.2 一个完整的删除示例</h4> 
<p>原始序列为: [50, 25, 10, 5, 7, 3, 30, 20, 8, 15]，依次删除节点[15, 20, 8,3, 25, 50,30]的过程如下图所示:</p> 
<p><img src="https://images2.imgbox.com/28/14/xPJmFedv_o.jpg" alt="删除1" title=""></p> 
<p><img src="https://images2.imgbox.com/90/95/dxBWTFoL_o.jpg" alt="删除2" title=""></p> 
<p><img src="https://images2.imgbox.com/51/02/WdxweozB_o.jpg" alt="删除3" title=""></p> 
<p><img src="https://images2.imgbox.com/c9/30/9dCzNB5B_o.jpg" alt="删除4" title=""></p> 
<p><img src="https://images2.imgbox.com/d5/0c/NRKbblEe_o.jpg" alt="删除5" title=""></p> 
<p><img src="https://images2.imgbox.com/a1/4f/k17DRxq7_o.jpg" alt="删除6" title=""></p> 
<h3 id="27-测试用例">2.7 测试用例</h3> 
<p>上面编写的AVL Tree在维护平衡因子方面付出了很大代价，容易出错，因此需要进行严格测试。首先定义一个方法，测试AVL状态是正确的:</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_avl_status_right</span><span class="hljs-params">(avl, test_case_no, expected_values_in_tree)</span>:</span>
    <span class="hljs-string">"""
    判断AVL树状态是否正常
    :param avl: 输入AVL树
    :param test_case_no: 测试用例编号
    :param expected_values_in_tree: 期待的树上值结果
    :return: True则状态合理 False则不合理
    """</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_func</span><span class="hljs-params">(tree_node, param)</span>:</span>
        <span class="hljs-keyword">if</span> tree_node:
            param[<span class="hljs-number">0</span>].append(tree_node.data)
            param[<span class="hljs-number">1</span>].append(tree_node.bf)
    node_val_list = []   <span class="hljs-comment"># 当前中序遍历元素列表</span>
    node_bf_list = []    <span class="hljs-comment"># 中序遍历平衡因子列表</span>
    avl.in_order_traverse_by_morris(visit_func, (node_val_list, node_bf_list))
    expected_order_output = sorted(expected_values_in_tree)  <span class="hljs-comment"># AVL正常时应该顺序输出的列表</span>
    result_status = <span class="hljs-keyword">True</span>
    <span class="hljs-keyword">if</span> node_val_list != expected_order_output:
        result_status = <span class="hljs-keyword">False</span>
        print(<span class="hljs-string">'Test case: '</span>, test_case_no, <span class="hljs-string">' Error, in order traverse result: '</span>,
              node_val_list, <span class="hljs-string">' expected: '</span>, expected_order_output)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">for</span> bf <span class="hljs-keyword">in</span> node_bf_list:
            <span class="hljs-keyword">if</span> bf <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]:
                print(<span class="hljs-string">'Test case: '</span>, test_case_no, <span class="hljs-string">' Error, balance factor could not be bf= '</span>, bf)
                result_status = <span class="hljs-keyword">False</span>
                <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">return</span> result_status</code></pre> 
<p>进行随机插入和删除测试，随机删除测试如下执行:</p> 
<pre class="prettyprint"><code class="language-python hljs ">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_random_remove</span><span class="hljs-params">(case_count=<span class="hljs-number">100</span>, each_case_length=<span class="hljs-number">1000</span>)</span>:</span>
    is_all_case_ok = <span class="hljs-keyword">True</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, case_count + <span class="hljs-number">1</span>):
        value_list = random.sample(xrange(<span class="hljs-number">1000000000</span>), each_case_length) <span class="hljs-comment"># 构造随机数列</span>
        avl = AVLTree(value_list)
        random.shuffle(value_list)  <span class="hljs-comment"># 构造移除的随机数列</span>
        result_status = <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">while</span> value_list:
            x = value_list.pop(<span class="hljs-number">0</span>)
            avl.remove_by_recursion(x)  <span class="hljs-comment"># 随机移除元素</span>
            result_status = is_avl_status_right(avl, i, value_list)
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result_status:
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result_status:
            print(<span class="hljs-string">'Test case '</span>, i, <span class="hljs-string">'Error found in algorithm.'</span>)
            is_all_case_ok = <span class="hljs-keyword">False</span>
    print(<span class="hljs-string">'is all case passed ?'</span>, is_all_case_ok)</code></pre> 
<p>经过上面大量随机测试，比对输出日志，上面AVL中移除的3种情形都覆盖到了，并且测试用例都通过了，则能断程序正确。</p> 
<h3 id="参考资料">参考资料</h3> 
<ul><li><a href="http://www.algolist.net/Data_structures/Binary_search_tree/Insertion" rel="nofollow">Binary search tree</a></li><li><a href="http://www.btechsmartclass.com/DS/U5_T2.html" rel="nofollow">AVL Tree</a></li><li><a href="https://cs.gmu.edu/~setia/cs310/slides/avl.pdf" rel="nofollow">Height Balance: AVL Trees</a></li><li><a href="https://www.geeksforgeeks.org/avl-tree-set-1-insertion/" rel="nofollow">AVL Tree | Set 1 (Insertion)</a></li><li><a href="http://www.mathcs.emory.edu/~cheung/Courses/323/Syllabus/Trees/AVL.html" rel="nofollow">AVL Tree</a></li><li><a href="https://www.cs.wcupa.edu/rkline/ds/avl-trees.html" rel="nofollow">AVL Trees </a></li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c0537bf17ac7d8f0f179c4ac2092961e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">走着走着，就散了</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/65d0795e2c2f67c54f3fc95bc29f8da4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">安装phpstudy与原来的mysql冲突怎么办</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>