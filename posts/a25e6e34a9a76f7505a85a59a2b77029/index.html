<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java(3)-深入理解java异常处理机制 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java(3)-深入理解java异常处理机制" />
<meta property="og:description" content="二.前言：引子 try…catch…finally恐怕是大家再熟悉不过的语句了，而且感觉用起来也是很简单，逻辑上似乎也是很容易理解。不过，我亲自体验的“教训”告诉我，这个东西可不是想象中的那么简单、听话。不信？那你看看下面的代码，“猜猜”它执行后的结果会是什么？不要往后看答案、也不许执行代码看真正答案哦。如果你的答案是正确，那么这篇文章你就不用浪费时间看啦。
package Test; public class TestException { public TestException() { } boolean testEx() throws Exception { boolean ret = true; try { ret = testEx1(); } catch (Exception e) { System.out.println(&#34;testEx, catch exception&#34;); ret = false; throw e; } finally { System.out.println(&#34;testEx, finally; return value=&#34; &#43; ret); return ret; } } boolean testEx1() throws Exception { boolean ret = true; try { ret = testEx2(); if (!ret) { return false; } System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/a25e6e34a9a76f7505a85a59a2b77029/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-01-20T18:44:00+08:00" />
<meta property="article:modified_time" content="2011-01-20T18:44:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java(3)-深入理解java异常处理机制</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<div> 
 <h2><span style="color:#336699;">二.前言：引子</span></h2> 
 <hr> 
</div> 
<p>       try…catch…finally恐怕是大家再熟悉不过的语句了，而且感觉用起来也是很简单，逻辑上似乎也是很容易理解。不过，我亲自体验的“教训”告诉我，这个东西可不是想象中的那么简单、听话。不信？那你看看下面的代码，“猜猜”它执行后的结果会是什么？不要往后看答案、也不许执行代码看真正答案哦。如果你的答案是正确，那么这篇文章你就不用浪费时间看啦。</p> 
<pre class="has"><code class="language-java">package Test;

public class TestException {
	public TestException() {
	}

	boolean testEx() throws Exception {
		boolean ret = true;
		try {
			ret = testEx1();
		} catch (Exception e) {
			System.out.println("testEx, catch exception");
			ret = false;
			throw e;
		} finally {
			System.out.println("testEx, finally; return value=" + ret);
			return ret;
		}
	}

	boolean testEx1() throws Exception {
		boolean ret = true;
		try {
			ret = testEx2();
			if (!ret) {
				return false;
			}
			System.out.println("testEx1, at the end of try");
			return ret;
		} catch (Exception e) {
			System.out.println("testEx1, catch exception");
			ret = false;
			throw e;
		} finally {
			System.out.println("testEx1, finally; return value=" + ret);
			return ret;
		}
	}

	boolean testEx2() throws Exception {
		boolean ret = true;
		try {
			int b = 12;
			int c;
			for (int i = 2; i &gt;= -2; i--) {
				c = b / i;
				System.out.println("i=" + i);
			}
			return true;
		} catch (Exception e) {
			System.out.println("testEx2, catch exception");
			ret = false;
			throw e;
		} finally {
			System.out.println("testEx2, finally; return value=" + ret);
			return ret;
		}
	}

	public static void main(String[] args) {
		TestException testException1 = new TestException();
		try {
			testException1.testEx();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
</code></pre> 
<p>你的答案是什么？是下面的答案吗？</p> 
<p><span style="color:#454545;">i=2</span><br><span style="color:#454545;">i=1</span><br><span style="color:#454545;">testEx2, catch exception</span><br><span style="color:#454545;">testEx2, finally; return value=false</span><br><span style="color:#454545;">testEx1, catch exception</span><br><span style="color:#ff0000;">testEx1, finally; return value=false</span><br> testEx, catch exception<br><span style="color:#ff0000;">testEx, finally; return value=false</span></p> 
<p>如果你的答案真的如上面所说，那么你错啦。^_^，那就建议你仔细看一看这篇文章或者拿上面的代码按各种不同的情况修改、执行、测试，你会发现有很多事情不是原来想象中的那么简单的。现在公布正确答案：</p> 
<p>i=2<br> i=1<br> testEx2, catch exception<br> testEx2, finally; return value=false<br> testEx1, finally; return value=false<br> testEx, finally; return value=false</p> 
<p> </p> 
<p>注意说明：</p> 
<p>finally语句块不应该出现 应该出现return。上面的return ret最好是其他语句来处理相关逻辑。</p> 
<p> </p> 
<div> 
 <h2><span style="color:#336699;">二.JAVA异常</span></h2> 
 <hr> 
</div> 
<p><span style="color:#000080;"><strong>   </strong></span>异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。</p> 
<p>      Java异常类层次结构图：</p> 
<p> </p> 
<p>        <img alt="" src="https://images2.imgbox.com/98/64/1lOYKeIm_o.png"></p> 
<p> </p> 
<p> </p> 
<p>                                                                    图1 Java异常类层次结构图</p> 
<p> </p> 
<p> </p> 
<p>        在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出）。Throwable 指定代码中可用异常传播机制通过 Java 应用程序传输的任何问题的共性。<br>        <strong><span style="color:#3333ff;">Throwable：</span></strong> 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p> 
<p> </p> 
<p>       <strong><span style="color:#3333ff;">Error（错误）:</span></strong>是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p> 
<p>。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</p> 
<p>       <span style="color:#3333ff;"><strong>Exception（异常）:</strong></span>是程序本身可以处理的异常。</p> 
<p>       Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。</p> 
<p>   <span style="color:#ff6600;">注意：异常和错误的区别：<span style="color:#ff6600;">异常能被</span>程序本身可以处理，错误是无法处理。</span></p> 
<p><span style="color:#ff6600;">   </span>通常，Java的异常(包括Exception和Error)分为<span style="color:#3333ff;"><strong>可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）</strong></span>。<br>       <span style="color:#3333ff;">可查异常（编译器要求必须处置的异常）：</span>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</p> 
<p>      除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p> 
<p>     <span style="color:#3333ff;">不可查异常(编译器不要求强制处置的异常):</span>包括运行时异常（RuntimeException与其子类）和错误（Error）。</p> 
<p>     Exception 这种异常分两大类<span style="color:#3333ff;">运行时异常和非运行时异常(编译异常)</span>。程序中应当尽可能去处理这些异常。</p> 
<p>       <strong><span style="color:#3333ff;">运行时异常：</span></strong>都是RuntimeException类及其子类异常，如NullPointerException(<span style="color:#333333;">空指针异常)</span>、IndexOutOfBoundsException(下标越界异常)等，<span style="color:#ff0000;">这些异常是不检查异常</span>，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p> 
<p>      运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。<br>        <strong><span style="color:#3333ff;">非运行时异常 （编译异常）：</span></strong>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义<span style="color:#ff0000;">检查异常</span>。</p> 
<p><strong><span style="color:#333333;">   </span></strong></p> 
<div> 
 <h2><span style="color:#336699;">三.处理异常机制</span></h2> 
 <hr> 
</div> 
<p>        在 Java 应用程序中，异常处理机制为：<span style="color:#ff0000;">抛出异常，捕捉异常。</span></p> 
<p><span style="color:#3333ff;"><strong>        抛出异常</strong>：</span>当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</p> 
<p>       <strong><span style="color:#3333ff;"> 捕获异常</span></strong>：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</p> 
<p>        对于运行时异常、错误或可查异常，Java技术所要求的异常处理方式有所不同。</p> 
<p>        由于运行时异常的不可查性，为了更合理、更容易地实现应用程序，Java规定，运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。</p> 
<p>       对于方法运行中可能出现的Error，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数Error异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。</p> 
<p>       对于所有的可查异常，Java规定：一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉可查异常时，它必须声明将抛出异常。</p> 
<p>        能够捕捉异常的方法，需要提供相符类型的异常处理器。所捕捉的异常，可能是由于自身语句所引发并抛出的异常，也可能是由某个调用的方法或者Java运行时 系统等抛出的异常。也就是说，<span style="color:#ff0000;">一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常</span>。<span style="color:#ff0000;">简单地说，异常总是先被抛出，后被捕捉的。</span></p> 
<p>        <span style="color:#666666;"> 任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的throw语句抛出异常。</span></p> 
<p><span style="color:#666666;">        从方法中抛出的任何异常都必须使用throws子句。</span></p> 
<p><span style="color:#666666;">        捕捉异常通过try-catch语句或者try-catch-finally语句实现。</span></p> 
<p><span style="color:#666666;">         总体来说，Java规定：对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error。</span></p> 
<h3><span style="color:#3399ea;"><strong>3.1 捕获异常：try、catch 和 finally</strong></span></h3> 
<p><strong><span style="color:#3333ff;">1.try-catch语句</span></strong></p> 
<p>     在Java中，异常通过try-catch语句捕获。其一般语法形式为：</p> 
<pre class="has"><code class="language-java">try {
    // 可能会发生异常的程序代码
} catch (Type1 id1){
    // 捕获并处置try抛出的异常类型Type1
}
catch (Type2 id2){
     //捕获并处置try抛出的异常类型Type2
}</code></pre> 
<p> </p> 
<p>       关键词try后的一对大括号将一块可能发生异常的代码包起来，称为监控区域。Java方法在运行过程中出现异常，则创建异常对象。将异常抛出监控区域之 外，由Java运行时系统试图寻找匹配的catch子句以捕获异常。若有匹配的catch子句，则运行其异常处理代码，try-catch语句结束。</p> 
<p>       匹配的原则是：如果抛出的异常对象属于catch子句的异常类，或者属于该异常类的子类，则认为生成的异常对象与catch块捕获的异常类型相匹配。</p> 
<p><span style="color:#ff0000;">例1</span><span style="color:#000080;">  捕捉throw语句抛出的“除数为0”异常。</span></p> 
<pre class="has"><code class="language-java">public class TestException {
	public static void main(String[] args) {
		int a = 6;
		int b = 0;
		try { // try监控区域
			
			if (b == 0) throw new ArithmeticException(); // 通过throw语句抛出异常
			System.out.println("a/b的值是：" + a / b);
		}
		catch (ArithmeticException e) { // catch捕捉异常
			System.out.println("程序出现异常，变量b不能为0。");
		}
		System.out.println("程序正常结束。");
	}
}</code></pre> 
<p>运行结果：<span style="color:#999999;">程序出现异常，变量b不能为0。</span></p> 
<p><span style="color:#999999;">                    程序正常结束。</span></p> 
<p>        例1  在try监控区域通过if语句进行判断，当“除数为0”的错误条件成立时引发ArithmeticException异常，创建 ArithmeticException异常对象，并由throw语句将异常抛给Java运行时系统，由系统寻找匹配的异常处理器catch并运行相应异 常处理代码，打印输出“程序出现异常，变量b不能为0。”try-catch语句结束，继续程序流程。</p> 
<p>        事实上，“除数为0”等ArithmeticException，是RuntimException的子类。而运行时异常将由运行时系统自动抛出，不需要使用throw语句。</p> 
<p><span style="color:#ff0000;">例2 </span><span style="color:#000080;"> 捕捉运行时系统自动抛出“除数为0”引发的ArithmeticException异常。</span></p> 
<pre class="has"><code class="language-java">	public static void main(String[] args) {
		int a = 6;
		int b = 0;
		try {
			System.out.println("a/b的值是：" + a / b);
		} catch (ArithmeticException e) {
			System.out.println("程序出现异常，变量b不能为0。");
		}
		System.out.println("程序正常结束。");
	}
}</code></pre> 
<p>运行结果：<span style="color:#999999;">程序出现异常，变量b不能为0。</span></p> 
<p><span style="color:#999999;">                  程序正常结束。</span></p> 
<p>例2  中的语句：</p> 
<p>System.out.println("a/b的值是：" + a/b);</p> 
<p>      在运行中出现“除数为0”错误，引发ArithmeticException异常。运行时系统创建异常对象并抛出监控区域，转而匹配合适的异常处理器catch，并执行相应的异常处理代码。</p> 
<p>      由于检查运行时异常的代价远大于捕捉异常所带来的益处，运行时异常不可查。Java编译器允许忽略运行时异常，一个方法可以既不捕捉，也不声明抛出运行时异常。</p> 
<p><span style="color:#ff0000;">例3 </span><span style="color:#000080;"> 不捕捉、也不声明抛出运行时异常。</span></p> 
<pre class="has"><code class="language-java">public class TestException {
	public static void main(String[] args) {
		int a, b;
		a = 6;
		b = 0; // 除数b 的值为0
		System.out.println(a / b);
	}
}</code></pre> 
<p>运行结果：</p> 
<p>Exception in thread "main" java.lang.ArithmeticException: / by zero<br> at Test.TestException.main(TestException.java:8)</p> 
<p><span style="color:#ff0000;">例4</span><span style="color:#000080;">  程序可能存在除数为0异常和数组下标越界异常。</span></p> 
<pre class="has"><code class="language-java">public class TestException {
	public static void main(String[] args) {
		int[] intArray = new int[3];
		try {
			for (int i = 0; i &lt;= intArray.length; i++) {
				intArray[i] = i;
				System.out.println("intArray[" + i + "] = " + intArray[i]);
				System.out.println("intArray[" + i + "]模 " + (i - 2) + "的值:  "
						+ intArray[i] % (i - 2));
			}
		} catch (ArrayIndexOutOfBoundsException e) {
			System.out.println("intArray数组下标越界异常。");
		} catch (ArithmeticException e) {
			System.out.println("除数为0异常。");
		}
		System.out.println("程序正常结束。");
	}
}</code></pre> 
<p>运行结果：</p> 
<p><span style="color:#999999;">intArray[0] = 0</span></p> 
<p><span style="color:#999999;">intArray[0]模 -2的值:  0</span></p> 
<p><span style="color:#999999;">intArray[1] = 1</span></p> 
<p><span style="color:#999999;">intArray[1]模 -1的值:  0</span></p> 
<p><span style="color:#999999;">intArray[2] = 2</span></p> 
<p><span style="color:#999999;">除数为0异常。</span></p> 
<p><span style="color:#999999;">程序正常结束。</span></p> 
<p><span style="color:#000080;">      </span>例4  程序可能会出现除数为0异常，还可能会出现数组下标越界异常。程序运行过程中ArithmeticException异常类型是先行匹配的，因此执行相匹配的catch语句：</p> 
<pre class="has"><code class="language-java">catch (ArithmeticException e){
      System.out.println("除数为0异常。");
 }</code></pre> 
<p> </p> 
<p><span style="color:#000080;">      </span><span style="color:#000080;"> </span>需要注意的是，<span style="color:#ff0000;">一旦某个catch捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个try-catch语句结束。其他的catch子句不再有匹配和捕获异常类型的机会。</span></p> 
<p>      Java通过异常类描述异常类型，异常类的层次结构如图1所示。对于有多个catch子句的异常程序而言，应该尽量将捕获底层异常类的catch子 句放在前面，同时尽量将捕获相对高层的异常类的catch子句放在后面。否则，捕获底层异常类的catch子句将可能会被屏蔽。</p> 
<p>      RuntimeException异常类包括运行时各种常见的异常，ArithmeticException类和ArrayIndexOutOfBoundsException类都是它的子类。因此，RuntimeException异常类的catch子句应该放在 最后面，否则可能会屏蔽其后的特定异常处理或引起编译错误。</p> 
<p><strong><span style="color:#3333ff;">2. try－catch-finally语句</span></strong></p> 
<p>      try-catch语句还可以包括第三部分，就是finally子句。它表示无论是否出现异常，都应当执行的内容。try-catch-finally语句的一般语法形式为：</p> 
<pre class="has"><code class="language-java">                try {
			// 可能会发生异常的程序代码
		} catch (Type1 id1) {
			// 捕获并处理try抛出的异常类型Type1
		} catch (Type2 id2) {
			// 捕获并处理try抛出的异常类型Type2
		} finally {
			// 无论是否发生异常，都将执行的语句块
		}</code></pre> 
<p><span style="color:#ff0000;">例5 </span><span style="color:#000080;"> 带finally子句的异常处理程序。</span></p> 
<pre class="has"><code class="language-java">public class TestException {
	public static void main(String args[]) {
		int i = 0;
		String greetings[] = { " Hello world !", " Hello World !! ",
				" HELLO WORLD !!!" };
		while (i &lt; 4) {
			try {
				// 特别注意循环控制变量i的设计，避免造成无限循环
				System.out.println(greetings[i++]);
			} catch (ArrayIndexOutOfBoundsException e) {
				System.out.println("数组下标越界异常");
			} finally {
				System.out.println("--------------------------");
			}
		}
	}
}</code></pre> 
<p>运行结果：</p> 
<p><span style="color:#999999;">Hello world !</span></p> 
<p><span style="color:#999999;">--------------------------</span></p> 
<p><span style="color:#999999;">Hello World !!</span></p> 
<p><span style="color:#999999;">--------------------------</span></p> 
<p><span style="color:#999999;">HELLO WORLD !!!</span></p> 
<p><span style="color:#999999;">--------------------------</span></p> 
<p><span style="color:#999999;">数组下标越界异常</span></p> 
<p><span style="color:#999999;">--------------------------</span></p> 
<p>     在例5中，请特别注意try子句中语句块的设计，如果设计为如下，将会出现死循环。如果设计为：</p> 
<p> </p> 
<pre class="has"><code class="language-java">try {
      System.out.println (greetings[i]); i++;
}</code></pre> 
<p> </p> 
<p>小结：</p> 
<p><span style="color:#454545;"><strong>try 块：</strong>用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。<br><strong>catch 块：</strong>用于处理try捕获到的异常。<br><strong>finally 块：</strong>无论是否捕获或处理异常，finally块里的语句都会被执行。</span><span style="color:#ff0000;">当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。在以下4种特殊情况下，finally块不会被执行：</span><br> 1）在finally语句块中发生了异常。<br> 2）在前面的代码中用了System.exit()退出程序。<br> 3）程序所在的线程死亡。<br> 4）关闭CPU。</p> 
<p> </p> 
<p> </p> 
<p><span style="color:#3333ff;"><strong>3. try-catch-finally 规则(</strong><a href="http://book.51cto.com/art/201009/227791.htm" rel="nofollow"><strong>异常处理语句的语法规则</strong></a><strong>）：</strong></span></p> 
<p><span style="color:#454545;">1)  必须在 try 之后添加 catch 或 finally 块。try 块后可同时接 catch 和 finally 块，但至少有一个块。</span><br><span style="color:#454545;">2) 必须遵循块顺序：若代码同时使用 catch 和 finally 块，则必须将 catch 块放在 try 块之后。</span><br><span style="color:#454545;">3) catch 块与相应的异常类的类型相关。</span><br><span style="color:#454545;">4) 一个 try 块可能有多个 catch 块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，不会再执行其他的 catch代码块</span><br><span style="color:#454545;">5) 可嵌套 try-catch-finally 结构。</span><br><span style="color:#454545;">6) 在 try-catch-finally 结构中，可重新抛出异常。</span><br><span style="color:#454545;">7) 除了下列情况，总将执行 finally 做为结束：</span><span style="color:#ff6600;">JVM 过早终止（调用 System.exit(int)）；在 finally 块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。</span></p> 
<p><strong><span style="color:#3333ff;">4. try、catch、finally语句块的执行顺序:</span></strong></p> 
<p> </p> 
<p>1)当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；</p> 
<p>2)当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行；</p> 
<p>3)当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句；</p> 
<p><span style="color:#333333;"><strong><span style="color:#333333;"> </span><span style="color:#333333;">图示try、catch、finally语句块的执行：</span></strong></span></p> 
<p><img alt="" height="454" src="https://images2.imgbox.com/c0/6f/atGT72ey_o.png" width="609"></p> 
<p><span style="color:#333333;">                                          图2  <span style="color:#333333;">图示try、catch、finally语句块的执行</span></span><br>  </p> 
<h3><span style="color:#3399ea;"><strong>3.2 抛出异常</strong></span></h3> 
<div> 
 <p><span style="color:#666666;">      任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的throw语句抛出异常。</span><span style="color:#666666;">从方法中抛出的任何异常都必须使用throws子句。</span></p> 
 <h4><span style="color:#3333ff;">1. throws抛出异常</span></h4> 
</div> 
<p><span style="color:#454545;">   如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用throws子句来声明抛出异常。例如汽车在运行时可能会出现故障，汽车本身没办法处理这个故障，那就让开车的人来处理。</span></p> 
<p>     throws语句用在方法定义时声明该方法要抛出的异常类型，如果抛出的是Exception异常类型，则该方法被声明为抛出所有的异常。多个异常可使用逗号分割。throws语句的语法格式为：</p> 
<pre class="has"><code class="language-java">methodname throws Exception1,Exception2,..,ExceptionN
{
}</code></pre> 
<p>    方法名后的throws Exception1,Exception2,...,ExceptionN 为声明要抛出的异常列表。当方法抛出<span style="color:#454545;">异常</span>列表的异常时，方法将不对这些类型及其子类类型的<span style="color:#454545;">异常</span>作处理，而抛向调用该方法的方法，由他去处理。例如：</p> 
<p> </p> 
<pre class="has"><code class="language-java">import java.lang.Exception;
public class TestException {
	static void pop() throws NegativeArraySizeException {
		// 定义方法并抛出NegativeArraySizeException异常
		int[] arr = new int[-3]; // 创建数组
	}

	public static void main(String[] args) { // 主方法
		try { // try语句处理异常信息
			pop(); // 调用pop()方法
		} catch (NegativeArraySizeException e) {
			System.out.println("pop()方法抛出的异常");// 输出异常信息
		}
	}

}</code></pre> 
<p> </p> 
<p>    使用throws关键字将异常抛给调用者后，如果调用者不想处理该异常，可以继续向上抛出，但最终要有能够处理该异常的调用者。</p> 
<p>    pop方法没有处理异常NegativeArraySizeException，而是由main函数来处理。<br><br>    <span style="color:#ff0000;"> </span> <strong><span style="color:#3333ff;">Throws抛出异常的规则：</span></strong></p> 
<p><span style="color:#ff0000;">    1) 如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</span></p> 
<p><span style="color:#ff0000;">    2）必须声明方法可抛出的任何可查异常（checked exception）。即<span style="color:#333333;">如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</span></span></p> 
<p><span style="color:#ff0000;">    3)仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常</span>。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</p> 
<p> </p> 
<p>    4）调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</p> 
<p>    例如：</p> 
<p> </p> 
<pre class="has"><code class="language-java">void method1() throws IOException{}  //合法  
 
//编译错误，必须捕获或声明抛出IOException  
void method2(){  
  method1();  
}  
 
//合法，声明抛出IOException  
void method3()throws IOException {  
  method1();  
}  
 
//合法，声明抛出Exception，IOException是Exception的子类  
void method4()throws Exception {  
  method1();  
}  
 
//合法，捕获IOException  
void method5(){  
 try{  
    method1();  
 }catch(IOException e){…}  
}  
 
//编译错误，必须捕获或声明抛出Exception  
void method6(){  
  try{  
    method1();  
  }catch(IOException e){throw new Exception();}  
}  
 
//合法，声明抛出Exception  
void method7()throws Exception{  
 try{  
  method1();  
 }catch(IOException e){throw new Exception();}  
} </code></pre> 
<p>    <strong><span style="color:#3333ff;"> 判断一个方法可能会出现异常的依据如下：</span></strong><br>      1）方法中有throw语句。例如，以上method7()方法的catch代码块有throw语句。<br>      2）调用了其他方法，其他方法用throws子句声明抛出某种异常。例如，method3()方法调用了method1()方法，method1()方法声明抛出IOException，因此，在method3()方法中可能会出现IOException。</p> 
<p> </p> 
<h4><span style="color:#3333ff;">2. 使用throw抛出异常</span></h4> 
<p>　  throw总是出现在函数体中，<span style="color:#454545;">用来抛出一个Throwable类型的异常</span>。程序会在throw语句后立即终止，它后面的语句执行不到，然后在包含它的所有try块中（可能在上层调用函数中）从里向外寻找含有与其匹配的catch子句的try块。<br> 　　我们知道，异常是异常类的实例对象，我们可以创建异常类的实例对象通过throw语句抛出。该语句的语法格式为：<br>     <span style="color:#454545;">throw new exceptionname;</span><br>     例如抛出一个IOException类的异常对象：<br>     throw new IOException;<br>     要注意的是，throw 抛出的只能够是可抛出类Throwable 或者其子类的实例对象。下面的操作是错误的：<br>     throw new String("exception");</p> 
<p>    这是因为String 不是Throwable 类的子类。</p> 
<p>    <span style="color:#454545;">如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。</span></p> 
<p><span style="color:#454545;">    如果所有方法都层层上抛获取的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。如果抛出的是Error或RuntimeException，则该方法的调用者可选择处理该异常。</span></p> 
<pre class="has"><code class="language-java">package Test;
import java.lang.Exception;
public class TestException {
	static int quotient(int x, int y) throws MyException { // 定义方法抛出异常
		if (y &lt; 0) { // 判断参数是否小于0
			throw new MyException("除数不能是负数"); // 异常信息
		}
		return x/y; // 返回值
	}
	public static void main(String args[]) { // 主方法
		int  a =3;
		int  b =0; 
		try { // try语句包含可能发生异常的语句
			int result = quotient(a, b); // 调用方法quotient()
		} catch (MyException e) { // 处理自定义异常
			System.out.println(e.getMessage()); // 输出异常信息
		} catch (ArithmeticException e) { // 处理ArithmeticException异常
			System.out.println("除数不能为0"); // 输出提示信息
		} catch (Exception e) { // 处理其他异常
			System.out.println("程序发生了其他的异常"); // 输出提示信息
		}
	}

}
class MyException extends Exception { // 创建自定义异常类
	String message; // 定义String类型变量
	public MyException(String ErrorMessagr) { // 父类方法
		message = ErrorMessagr;
	}

	public String getMessage() { // 覆盖getMessage()方法
		return message;
	}
}</code></pre> 
<blockquote> 
 <p><span style="color:#f33b45;">注意：</span></p> 
 <p><strong><span style="color:#f33b45;">1、Throw （是 catch 中还是非 catch 中）后面不能再跟其他代码块了 ，否则编译不能通过,</span></strong></p> 
 <p>例如把return和throw放在一起，IDEA直接提示错误:"Unreachable statement" .</p> 
 <p><img alt="" height="390" src="https://images2.imgbox.com/ef/f4/IEsPQo7b_o.png" width="503"></p> 
 <p><strong><span style="color:#f33b45;">2、但可以在finally语句块有return语句,finally语句块成功骗过编译器让throw和return两者并存</span></strong></p> 
 <p><img alt="" height="363" src="https://images2.imgbox.com/c6/09/crycgcRS_o.png" width="479"></p> 
 <p><span style="color:#7c79e5;"><strong>我们根据开头引子的例子，可以得出结论：</strong></span></p> 
 <p><span style="color:#7c79e5;"><strong>finally如果有return会覆盖catch里的throw，同样如果finally里有throw会覆盖catch里的return。</strong></span></p> 
 <p><span style="color:#7c79e5;"><strong>进而如果catch里和finally都有return， finally中的return会覆盖catch中的。throw也是如此。</strong></span></p> 
</blockquote> 
<p> </p> 
<h3><span style="color:#3399ea;"><strong>3.3 异常链</strong></span></h3> 
<p><span style="color:#ff6600;">      1) 如果调用quotient(3,-1)</span><span style="color:#333333;">，将发生MyException异常，程序调转到catch (MyException e)代码块中执行；</span></p> 
<p><span style="color:#333333;">      </span><span style="color:#ff6600;">2) 如果调用quotient(5,0)</span><span style="color:#333333;">，</span><span style="color:#333333;">将会因“除数为0”错误引发ArithmeticException异常，属于运行时异常类，由Java运行时系统自动抛出。<span style="color:#ff6600;">quotient</span>（）方法没有捕捉ArithmeticException异常，Java运行时系统将沿方法调用栈查到main方法，将抛出的异常上传至<span style="color:#ff6600;">quotient</span>（）方法的调用者：</span></p> 
<p><span style="color:#333333;">         <span style="color:#333333;">int result = quotient(a, b); // 调用方法quotient()</span><br><span style="color:#333333;">        由于该语句在try监控区域内，因此传回的“除数为0”的ArithmeticException异常由Java运行时系统抛出，并匹配catch子句：</span></span></p> 
<p><span style="color:#333333;"><span style="color:#333333;">       catch (ArithmeticException e) { // 处理ArithmeticException异常<br> System.out.println("除数不能为0"); // 输出提示信息<br> } </span></span></p> 
<p><span style="color:#333333;">        </span><span style="color:#333333;">处理结果是输出“</span><span style="color:#333333;">除数不能为0</span><span style="color:#333333;">”。Java这种向上传递异常信息的处理机制，</span><strong><span style="color:#3333ff;">形成异常链</span></strong><span style="color:#333333;">。</span></p> 
<p><span style="color:#333333;"><span style="color:#333333;"><span style="color:#333333;">       Java方法抛出的可查异常将依据调用栈、沿着方法调用的层次结构一直传递到具备处理能力的调用方法，最高层次到main方法为止。如果异常传递到main方法，而main不具备处理能力，也没有通过throws声明抛出该异常，将可能出现编译错误。</span></span></span></p> 
<p> </p> 
<p><span style="color:#454545;">     </span><span style="color:#ff6600;"> 3)如还有其他异常发生</span><span style="color:#454545;">，将使用catch (Exception e)捕捉异常。由于Exception是所有异常类的父类，如果将catch (Exception e)代码块放在其他两个代码块的前面，后面的代码块将永远得不到执行，就没有什么意义了，所以catch语句的顺序不可掉换。</span></p> 
<h3><span style="color:#3399ea;">3.4 Throwable类中的常用方法</span></h3> 
<p><span style="color:#454545;">注意：catch关键字后面括号中的Exception类型的参数e。Exception就是try代码块传递给catch代码块的变量类型，e就是变量名。catch代码块中语句"e.getMessage();"用于输出错误性质。通常异常处理常用3个函数来获取异常的有关信息:</span></p> 
<p><span style="color:#454545;">     getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。</span></p> 
<p><span style="color:#454545;">　 getMeage()：返回异常的消息信息。</span></p> 
<p><span style="color:#454545;">　 printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。</span></p> 
<p><span style="color:#454545;">     有时为了简单会忽略掉catch语句后的代码，这样try-catch语句就成了一种摆设，一旦程序在运行过程中出现了异常，就会忽略处理异常，而错误发生的原因很难查找。</span></p> 
<p> </p> 
<div> 
 <h2><span style="color:#3399ea;">四.try catch finally 语句中有return情况</span></h2> 
</div> 
<hr> 
<h4>1、try中有return语句和最后有return：</h4> 
<p>我们看看这段代码的输出结果：</p> 
<pre><code class="language-html hljs">public class testExcReurn {
    public int add(int a,int b) {
        try {
            return a+b;
        }catch(Exception e){
            System.out.println("catch语句块");
        }finally {
            System.out.println("finally语句块");
        }
        return 0;
    }
    public static void main(String[] args) {
        testExcReurn t = new testExcReurn();
        System.out.println("和="+t.add(9, 34));
    }
}</code></pre> 
<p>A、catch语句块 和=43<br> B、编译异常<br> C、finally语句块 和=43<br> D、和=43 finally语句块</p> 
<p>正确答案：C</p> 
<p>合理的解释是，在try中执行到return语句时，不会真正的return，即只是会计算return中的表达式，之后将结果保存在一个临时栈中，接着执行finally中的语句，最后才会从临时栈中取出之前的结果返回。</p> 
<h4>2、try和finally都有return语句：</h4> 
<pre><code class="language-html hljs">public class testExcReurn {
    public int add(int a,int b) {
        try {
            return a+b;
        }catch(Exception e){
            System.out.println("catch语句块");
        }finally {
            System.out.println("finally语句块");
            return 0;
        }
    }
    public static void main(String[] args) {
        testExcReurn t = new testExcReurn();
        System.out.println("和="+t.add(9, 34));
    }
}</code></pre> 
<p><img alt="" height="62" src="https://images2.imgbox.com/bb/6a/3SAg4ThE_o.png" width="356"></p> 
<p><span style="color:#7c79e5;">finnaly会覆盖try的return语句。</span></p> 
<h4>3、return的数据是引用数据类型</h4> 
<pre><code class="language-html hljs">public class testExcReurn {
    public int a;
    public testExcReurn set() {
        try {
            this.a  = 10;
            return this;
        }catch(Exception e){
            System.out.println("catch语句块");
        }finally {
            System.out.println("finally语句块");
            this.a = 200;
        }
        return this;
    }
    public static void main(String[] args) {
        testExcReurn t = new testExcReurn();
        t.set();
        System.out.println("a="+ t.a);
    }
}</code></pre> 
<p><img alt="" height="71" src="https://images2.imgbox.com/d7/fe/GVARXb6i_o.png" width="367"></p> 
<p> </p> 
<h4>结论：</h4> 
<p><span style="color:#7c79e5;"><strong>1、finally覆盖catch（开头引子的例子）：</strong></span></p> 
<p><span style="color:#7c79e5;"><strong>      1）</strong></span><strong>如果finally有return会覆盖catch里的throw，同样如果finally里有throw会覆盖catch里的return。</strong></p> 
<p><span style="color:#7c79e5;"><strong>      2） </strong></span><strong>如果catch里和finally都有return， finally中的return会覆盖catch中的。throw也是如此。</strong></p> 
<p><span style="color:#7c79e5;"><strong>2、catch有return而finally没有：</strong></span></p> 
<p>     当 try 中抛出异常且catch 中有 return 语句，finally 中没有 return 语句， java 先执行 catch 中非 return 语句，再执行 finally 语句，最后执行 catch 中 return 语句。</p> 
<p><span style="color:#7c79e5;"><strong>3、try有return语句，后续还有return语句，分为以下三种情况：</strong></span></p> 
<p>    情况一：如果finally中有return语句，则会将try中的return语句”覆盖“掉，直接执行finally中的return语句，得到返回值，这样便无法得到try之前保留好的返回值。</p> 
<p>    情况二：如果finally中没有return语句，也没有改变要返回值，则执行完finally中的语句后，会接着执行try中的return语句，返回之前保留的值。</p> 
<p>    情况三：如果finally中没有return语句，但是改变了要返回的值，这里有点类似与引用传递和值传递的区别，分以下两种情况，：</p> 
<p>        1）如果return的数据是基本数据类型或文本字符串，则在finally中对该基本数据的改变不起作用，try中的return语句依然会返回进入finally块之前保留的值。</p> 
<p>        2）如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。</p> 
<p> </p> 
<p> </p> 
<div> 
 <h2><span style="color:#3399ea;">五.Java常见异常</span></h2> 
</div> 
<hr> 
<p>在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:</p> 
<p> </p> 
<h4><span style="color:#3399ea;"><strong>1. runtimeException子类:</strong></span></h4> 
<blockquote> 
 <span style="color:#454545;"><strong> </strong>   1、 java.lang.ArrayIndexOutOfBoundsException</span> 
 <br> 
 <span style="color:#454545;">    数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</span> 
 <br> 
 <span style="color:#454545;">    2、java.lang.ArithmeticException</span> 
 <br> 
 <span style="color:#454545;">    算术条件异常。譬如：整数除零等。</span> 
 <br> 
 <span style="color:#454545;">    3、java.lang.NullPointerException</span> 
 <br> 
 <span style="color:#454545;">    空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</span> 
 <br> 
 <span style="color:#454545;">    4、java.lang.ClassNotFoundException</span> 
 <br> 
 <span style="color:#454545;">    找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</span> 
 <p>   <span style="color:#454545;">5、java.lang.<span style="color:#333333;">NegativeArraySizeException </span></span><span style="color:#333333;"> </span><span style="color:#333333;">数组长度为负异常</span></p> 
 <p><span style="color:#333333;">   6<span style="color:#454545;">、java.lang.<span style="color:#333333;"><span style="color:#333333;">ArrayStoreException</span> </span></span><span style="color:#333333;">数组中包含不兼容的值抛出的异常</span></span></p> 
 <p><span style="color:#333333;"><span style="color:#333333;"><span style="color:#333333;">   7</span><span style="color:#454545;">、java.lang.<span style="color:#333333;"><span style="color:#333333;">SecurityException</span> </span></span><span style="color:#333333;"><span style="color:#333333;">安全性异常</span></span></span></span></p> 
 <p><span style="color:#333333;"><span style="color:#333333;"><span style="color:#333333;"><span style="color:#333333;"> <span style="color:#333333;">  8</span><span style="color:#454545;">、java.lang.<span style="color:#333333;"><span style="color:#333333;">IllegalArgumentException</span> </span></span><span style="color:#333333;"><span style="color:#333333;">非法参数异常</span></span></span></span></span></span></p> 
</blockquote> 
<h4><span style="color:#3399ea;"><strong>2.<strong>IOException</strong></strong></span></h4> 
<blockquote> 
 <p><span style="color:#333333;">IOException：操作输入流和输出流时可能出现的异常。</span></p> 
 <p><span style="color:#333333;">EOFException   文件已结束异常</span></p> 
 <p><span style="color:#333333;">FileNotFoundException   文件未找到异常</span></p> 
</blockquote> 
<h4><span style="color:#3399ea;">3. 其他</span></h4> 
<blockquote> 
 <p><span style="color:#333333;">ClassCastException    类型转换异常类</span></p> 
 <p><span style="color:#333333;">ArrayStoreException  数组中包含不兼容的值抛出的异常</span></p> 
 <p><span style="color:#333333;">SQLException   操作数据库异常类</span></p> 
 <p><span style="color:#333333;">NoSuchFieldException   字段未找到异常</span></p> 
 <p><span style="color:#333333;">NoSuchMethodException   方法未找到抛出的异常</span></p> 
 <p><span style="color:#333333;">NumberFormatException    字符串转换为数字抛出的异常</span></p> 
 <p><span style="color:#333333;">StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常</span></p> 
 <p><span style="color:#333333;">IllegalAccessException  不允许访问某类异常</span></p> 
 <p><span style="color:#333333;">InstantiationException  当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</span></p> 
</blockquote> 
<p> </p> 
<div> 
 <h2><span style="color:#336699;"> 5.自定义异常</span></h2> 
</div> 
<hr> 
<p>使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承Exception类即可。<br> 在程序中使用自定义异常类，大体可分为以下几个步骤：</p> 
<p><strong>1）创建自定义异常类：</strong>一般会选择继承Exception和RuntimeException，如果不要求调用者一定要处理抛出的异常，就继承RuntimeException。<br><strong>2）抛出自定义异常：</strong>在方法中通过throw关键字抛出异常对象。<br><strong>3）捕获自定义异常：</strong>如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。<br> 4）在出现异常方法的调用者中捕获并处理异常<br> 在上面的“使用throw抛出异常”例子已经提到了:</p> 
<pre><code class="language-java">class MyException extends Exception { // 创建自定义异常类
    String message; // 定义String类型变量
    public MyException(String ErrorMessagr) { // 父类方法
        message = ErrorMessagr;
    }

    public String getMessage() { // 覆盖getMessage()方法
        return message;
    }
}</code></pre> 
<p> </p> 
<div>
    
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/45df8f09fdc0da7cd01a888c651c6ec3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">因连接关闭引起的Blob操作异常</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2f2cb76f85b0bf09de933e081f2bce30/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">看了张孝祥的《绝对能够测试你的C语言功力的几个问题》</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>