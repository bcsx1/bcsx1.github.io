<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Dart语言详解 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Dart语言详解" />
<meta property="og:description" content="文章目录 1 变量1.1 变量-变量的声明1.2 变量-默认值1.3 变量-final和const 2 内置类型2.1 内置类型-num, int, double2.2 Strings 字符串2.3 内置类型-bool2.4 内置类型-List2.5 内置类型-Map2.6 内置类型-Set2.7 内置类型-Runes2.8 内置类型-Symbol 3 函数3.1 函数-定义3.2 函数-可选参数3.3 函数-匿名函数3.4 函数-闭包3.5 函数-函数别名 4 操作符5 流程控制语句6 异常6.1 异常-Exception类型6.2 异常-Error类型6.3 异常-抛出6.4 异常-捕获 7 类7.1 类-构造函数7.2 类-命名构造函数7.3 类-重定向构造函数7.4 类-初始化列表7.5 类-调用超类构造函数7.6 类-常量构造函数7.7 类-工厂构造函数7.8 类-Setter和Getter7.9 类-抽象类7.10 类-可调用类 8 Mixin9 泛型9.1 泛型-泛型函数9.2 泛型-构造函数泛型9.3 泛型-泛型限制9.4 泛型-与java区别 10 库10.1 库-使用核心库10.2 库-载入第三方库10.3 库-载入文件10.4 库-指定库前缀10.5 库-选择性载入10.6 库-延迟载入10.7 库-自定义库 11 异步11.1 异步-async和await11.2 异步-then,catchError,whenComplete11.3 异步-Event-Looper11.4 异步-Event Queue和Microtask Queue11." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/a2576866def47dba8d9ed87c6ee0c080/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-08T10:53:03+08:00" />
<meta property="article:modified_time" content="2019-07-08T10:53:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Dart语言详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__1" rel="nofollow">1 变量</a></li><li><ul><li><a href="#11__2" rel="nofollow">1.1 变量-变量的声明</a></li><li><a href="#12__58" rel="nofollow">1.2 变量-默认值</a></li><li><a href="#13_finalconst_68" rel="nofollow">1.3 变量-final和const</a></li></ul> 
  </li><li><a href="#2__147" rel="nofollow">2 内置类型</a></li><li><ul><li><a href="#21_num_int_double_157" rel="nofollow">2.1 内置类型-num, int, double</a></li><li><a href="#22_Strings__192" rel="nofollow">2.2 Strings 字符串</a></li><li><a href="#23_bool_228" rel="nofollow">2.3 内置类型-bool</a></li><li><a href="#24_List_240" rel="nofollow">2.4 内置类型-List</a></li><li><a href="#25_Map_329" rel="nofollow">2.5 内置类型-Map</a></li><li><a href="#26_Set_361" rel="nofollow">2.6 内置类型-Set</a></li><li><a href="#27_Runes_398" rel="nofollow">2.7 内置类型-Runes</a></li><li><a href="#28_Symbol_423" rel="nofollow">2.8 内置类型-Symbol</a></li></ul> 
  </li><li><a href="#3___430" rel="nofollow">3 函数</a></li><li><ul><li><a href="#31__431" rel="nofollow">3.1 函数-定义</a></li><li><a href="#32__461" rel="nofollow">3.2 函数-可选参数</a></li><li><a href="#33__523" rel="nofollow">3.3 函数-匿名函数</a></li><li><a href="#34__572" rel="nofollow">3.4 函数-闭包</a></li><li><a href="#35__587" rel="nofollow">3.5 函数-函数别名</a></li></ul> 
  </li><li><a href="#4__634" rel="nofollow">4 操作符</a></li><li><a href="#5___753" rel="nofollow">5 流程控制语句</a></li><li><a href="#6__785" rel="nofollow">6 异常</a></li><li><ul><li><a href="#61_Exception_786" rel="nofollow">6.1 异常-Exception类型</a></li><li><a href="#62_Error_791" rel="nofollow">6.2 异常-Error类型</a></li><li><a href="#63__794" rel="nofollow">6.3 异常-抛出</a></li><li><a href="#64__807" rel="nofollow">6.4 异常-捕获</a></li></ul> 
  </li><li><a href="#7__831" rel="nofollow">7 类</a></li><li><ul><li><a href="#71__832" rel="nofollow">7.1 类-构造函数</a></li><li><a href="#72__869" rel="nofollow">7.2 类-命名构造函数</a></li><li><a href="#73__899" rel="nofollow">7.3 类-重定向构造函数</a></li><li><a href="#74__923" rel="nofollow">7.4 类-初始化列表</a></li><li><a href="#75___942" rel="nofollow">7.5 类-调用超类构造函数</a></li><li><a href="#76__994" rel="nofollow">7.6 类-常量构造函数</a></li><li><a href="#77__1026" rel="nofollow">7.7 类-工厂构造函数</a></li><li><a href="#78_SetterGetter_1044" rel="nofollow">7.8 类-Setter和Getter</a></li><li><a href="#79__1084" rel="nofollow">7.9 类-抽象类</a></li><li><a href="#710__1202" rel="nofollow">7.10 类-可调用类</a></li></ul> 
  </li><li><a href="#8_Mixin_1228" rel="nofollow">8 Mixin</a></li><li><a href="#9__1405" rel="nofollow">9 泛型</a></li><li><ul><li><a href="#91___1430" rel="nofollow">9.1 泛型-泛型函数</a></li><li><a href="#92__1452" rel="nofollow">9.2 泛型-构造函数泛型</a></li><li><a href="#93__1473" rel="nofollow">9.3 泛型-泛型限制</a></li><li><a href="#94_java_1499" rel="nofollow">9.4 泛型-与java区别</a></li></ul> 
  </li><li><a href="#10__1518" rel="nofollow">10 库</a></li><li><ul><li><a href="#101__1519" rel="nofollow">10.1 库-使用核心库</a></li><li><a href="#102__1529" rel="nofollow">10.2 库-载入第三方库</a></li><li><a href="#103__1564" rel="nofollow">10.3 库-载入文件</a></li><li><a href="#104__1597" rel="nofollow">10.4 库-指定库前缀</a></li><li><a href="#105__1651" rel="nofollow">10.5 库-选择性载入</a></li><li><a href="#106__1667" rel="nofollow">10.6 库-延迟载入</a></li><li><a href="#107__1688" rel="nofollow">10.7 库-自定义库</a></li></ul> 
  </li><li><a href="#11__1731" rel="nofollow">11 异步</a></li><li><ul><li><a href="#111_asyncawait_1732" rel="nofollow">11.1 异步-async和await</a></li><li><a href="#112_thencatchErrorwhenComplete_1779" rel="nofollow">11.2 异步-then,catchError,whenComplete</a></li><li><a href="#113_EventLooper_1810" rel="nofollow">11.3 异步-Event-Looper</a></li><li><a href="#114_Event_QueueMicrotask_Queue_1822" rel="nofollow">11.4 异步-Event Queue和Microtask Queue</a></li><li><a href="#115__1825" rel="nofollow">11.5 异步-任务调度</a></li><li><a href="#116_new_Future_1830" rel="nofollow">11.6 异步-new Future()</a></li><li><a href="#117_scheduleMicrotask_1875" rel="nofollow">11.7 异步-scheduleMicrotask()</a></li></ul> 
  </li><li><a href="#12__1933" rel="nofollow">12 生成器</a></li><li><ul><li><a href="#121___1934" rel="nofollow">12.1 生成器-同步生成器</a></li><li><a href="#122__1971" rel="nofollow">12.2 生成器-异步生成器</a></li><li><a href="#123__2044" rel="nofollow">12.3 生成器-递归生成器</a></li></ul> 
  </li><li><a href="#13_Isolates_2078" rel="nofollow">13 隔离-Isolates</a></li><li><a href="#14__2083" rel="nofollow">14 元数据(注解)</a></li><li><ul><li><a href="#141_deprecated_2084" rel="nofollow">14.1 元数据(注解)-@deprecated</a></li><li><a href="#142_override_2105" rel="nofollow">14.2 元数据(注解)-@override</a></li><li><a href="#143__2130" rel="nofollow">14.3 元数据(注解)-自定义</a></li></ul> 
  </li><li><a href="#15__2160" rel="nofollow">15 注释</a></li><li><ul><li><a href="#151__2161" rel="nofollow">15.1 注释-单行注释</a></li><li><a href="#152__2168" rel="nofollow">15.2 注释-多行注释</a></li><li><a href="#153__2178" rel="nofollow">15.3 注释-文档注释</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1__1"></a>1 变量</h2> 
<h3><a id="11__2"></a>1.1 变量-变量的声明</h3> 
<p>var<br> dynamic<br> Object</p> 
<p>dynamic和Object区别：</p> 
<p>新建一个“1-variables.dart”，添加如下代码：</p> 
<pre><code>void main(){
  dynamic d1 = "1234";
  Object o1 = "1234";
  d1.test();
  o1.test();
}
</code></pre> 
<p>d1.test();不会报错<br> o1.test();会报错<br> 说明dynamic编译时不会检查，Object在编译时会检查。</p> 
<p>总结如下：</p> 
<pre><code>  //var声明一个初始化的变量，变量的类型不能再改变
  var variable1 =
      'hongxue'; //变量是一个引用。名字为 name 的变量引用了 一个内容为 “hongxue” 的 String 对象。
      //variable1 = 123;//变量初始化后，name变量的类型被推断为String类型，其类型不能再改变

  //dynamic和Object声明的变量初始化后，变量的类型仍可改变
  dynamic variable2 = 'hongxue';
  variable2 = 123;
  //  variable2.test();//调用不存在的test()方法，编译通过，运行报异常。编译阶段不检查类型
  Object variable3 = 'hongxue';
  variable3 = 123;
   //  variable3.test();//调用不存在的test()方法，编译不通过。编译阶段检查类型

  //使用确定类型显示声明变量，变量的类型不能再改变
  String name3;
  name3 = 'hongxue';
//  name3 = 123;//变量的类型不能再改变

//var:如果没有初始值，可以变成任何类型
//dynamic:动态任意类型，编译阶段不检查类型
//Object:动态任意类型，编译阶段检查检查类型
//区别：
//唯一区别 var 如果有初始值，类型被锁定
</code></pre> 
<ul><li>var:如果没有初始值，可以变成任何类型</li><li>dynamic:动态任意类型，编译阶段不检查类型</li><li>Object:动态任意类型，编译阶段检查检查类型</li></ul> 
<p>区别：</p> 
<ul><li>唯一区别 var 如果有初始值，类型被锁定</li></ul> 
<h3><a id="12__58"></a>1.2 变量-默认值</h3> 
<p>没有初始化的变量自动获取一个默认值为null<br> 一切皆对象，对象的默认值为null</p> 
<pre><code>  //没有初始化的变量默认值都是null。一切皆对象，对象的默认值是null
  bool isEmpty;
  assert(isEmpty == null);
</code></pre> 
<h3><a id="13_finalconst_68"></a>1.3 变量-final和const</h3> 
<p>共同点：</p> 
<ol><li>声明的类型可省略</li><li>初始化后不能再赋值</li><li>不能和var同时使用</li></ol> 
<pre><code>  //1.  被final或者const修饰的变量，变量类型可以省略
  final fVariable1 = 'hongxue';
//  final String fVariable1 = 'hongxue';
  const cVariable1 = 'hongxue';
//  const String cVariable1 = 'hongxue';

  //2.  被 final 或 const 修饰的变量无法再去修改其值。
//   fVariable1 = 'damon';
//   cVariable1 = 'damon';

  //3.  final或const不能和var同时使用。
//  final var fVariable1 = 'hongxue';
//  const var fVariable1 = 'hongxue';
</code></pre> 
<p>区别(需要注意的地方)：</p> 
<ol start="4"><li>类级别常量，使用static const</li><li>const可使用其他const 常量的值来初始化其值</li><li>使用const赋值声明，const可省略</li><li>可以更改非final、非const变量的值，即使曾经具有const值</li><li>const导致的不可变性是可传递的</li><li>相同的const常量不会在内存中重复创建</li><li>const需要是编译时常量</li></ol> 
<pre><code>  //4.  如果是类级别常量，使用static const
  DateTime; //可参照DateTime static const int monday = 1;

  //5.  const可以使用其他 const常量的值来初始化其值
  const width = 100;
  const height = 100;
  const square = width * height;

  //6.  const赋值 申明可省略
  const List clist = [1, 2, 3];
//  const List clist = const [1, 2, 3];//dart 2之前，const赋值必须用const声明

  //7.  可以更改非final,非const变量的值，即使它曾经具有const值
  var varList = const [1, 2, 3];
  final finalList = const [1, 2, 3];
  const constList = [1, 2, 3];
  varList = [1];
//  constList = [1];
//  finalList = [1];

  //8.  const导致的不可变性是可传递的
  final List ls = [1, 2, 3];
  ls[1] = 4;
  print(ls);
  const List ls1 = [1, 2, 3];
//  ls1[1] = 4;

  //9. 相同的const常量不会在内存中重复创建
  final finalList1 = [1, 2];
  final finalList2 = [1, 2];
  print(identical(finalList1, finalList2)); //identical用于检查两个引用是否指向同一个对象

  const constList1 = [1, 2];
  const constList2 = [1, 2];
  print(identical(constList1, constList2)); //identical用于检查两个引用是否指向同一个对象

  //10. const 需要是编译时常量
  final DateTime finalDateTime = DateTime.now();
  //  const DateTime constDateTime = DateTime.now();//DateTime.now() 是运行期计算出来的值

</code></pre> 
<hr> 
<h2><a id="2__147"></a>2 内置类型</h2> 
<ol><li>Numbers 数值</li><li>Strings 字符串</li><li>Booleans 布尔值</li><li>Lists 列表(数组)</li><li>Sets 集合</li><li>Maps 集合</li><li>Runes 符号字符</li><li>Symbols 标识符</li></ol> 
<h3><a id="21_num_int_double_157"></a>2.1 内置类型-num, int, double</h3> 
<p>int和double是num的子类</p> 
<ul><li>int : 整数值</li><li>double : 64-bit双精度浮点数</li></ul> 
<pre><code>  /// ---------------------------------Numbers数值:num, int, double--------------------------------
  print('-----------------------Numbers------------------------');
  int i = 1; //整数值
  double d = 1.0; //double  64-bit (双精度) 浮点数
  int bitLength = i.bitLength;
  print('bitLength: ${bitLength}'); //bitLength判断int值需要多少bit位
  double maxFinite = double.maxFinite;
  print('maxFinite: ${maxFinite}'); //maxFinitedouble的最大值
  //int和double都是num的子类
  num n1 = 1;
  num n2 = 1.0;
  //支持十进制、十六进制
  int i1 = 0xfff;
  //科学计数法
  double d1 = 1.2e2; //120.0
  //转换
  //String-&gt;int
  int i2 = int.parse('1');
  double d2 = 1; //当double的值为int值时，int自动转成double
  print('d2: ${d2}');
//  int i2 = int.tryParse('1.0');//返回null

  //int-&gt;String
  String str = 123.toString(); //数字也是对象
  print('-----------------------Numbers------------------------');
</code></pre> 
<h3><a id="22_Strings__192"></a>2.2 Strings 字符串</h3> 
<ul><li> <p>Dart 字符串是 UTF-16 编码的字符序列，可以使用单引号或者双引号来创建字符串</p> </li><li> <p>可以使用三个单引号或者双引号创建多行字符串对象</p> </li><li> <p>可以使用 r 前缀创建”原始raw”字符串。</p> </li><li> <p>可以在字符串中使用表达式： ${expression},如果表达式是一个标识符，可以省略 {}，如果表达式的结果为一个对象，则 Dart 会调用对象的 toString() 函数来获取一个字符串</p> </li></ul> 
<pre><code> /// ---------------------------------Strings字符串:String--------------------------------
  print('-----------------------Strings------------------------');
  //Dart 字符串是 UTF-16 编码的字符序列，可以使用单引号或者双引号来创建字符串
  var name = 'xiaoming';
  //可以在字符串中使用表达式： ${expression},如果表达式是一个标识符，可以省略 {}。 如果表达式的结果为一个对象，则 Dart 会调用对象的 toString() 函数来获取一个字符串
  var names = 'hongxue ${name}';
  var rawNames = r'hongxue ${name}'; //r 前缀可以创建一个 “原始 raw” 字符串
  print('names: ${names}');
  print('rawNames: ${rawNames}');
  //如果表达式的结果为一个对象，则 Dart 会调用对象的 toString() 函数来获取一个字符串。
//  print(Map);
  //可以使用三个单引号或者双引号也可以 创建多行字符串对象
  var multiLinesString = '''
  hongxue
  xiaoming''';
  print('multiLinesString: ${multiLinesString}');

  //StringBuffer
  var sb = StringBuffer(); //dart 2 可以省略new
  sb..write('aaa')..write('bbb')..write('ccc'); //..级联符实现链式调用
  sb.writeAll(['ddd', 'eee', 'fff'], ','); //第二个参数表示分隔符，将第一个参数列表里的数据用这个分隔符拼接起来
  print('sb: ${sb}');
  print('-----------------------Strings------------------------');
</code></pre> 
<h3><a id="23_bool_228"></a>2.3 内置类型-bool</h3> 
<ul><li>bool对象未初始化的默认值是null</li></ul> 
<pre><code> /// ---------------------------------Booleans布尔值:bool--------------------------------
  print('-----------------------Booleans------------------------');
  //bool :true 和false
  bool isNull;
  print('isNull: ${isNull}');
  print('-----------------------Booleans------------------------');
</code></pre> 
<h3><a id="24_List_240"></a>2.4 内置类型-List</h3> 
<ul><li>Dart中可以直接打印list包括list的元素，List也是对象。java中直接打印list结果是地址值</li><li>Dart中List的下标索引和java一样从0开始</li><li>和java一样支持泛型。</li><li>有增删改查，支持倒序，自带排序、洗牌，可使用+将两个List合并</li></ul> 
<pre><code> /// ---------------------------------Lists列表(数组):List--------------------------------
  print('-----------------------Lists------------------------');
  //声明
  //自动长度
  List growableList = List();
//  List growableList = new List()..length = 3;
  growableList..add(1)..add(2)..add('xiaoming');
  print('growableList: ${growableList}');
  //固定长度
  var list = List(3); //List的声明，可以用var也可用List。
  list[0] = 1; //下标索引从0开始
  list[1] = 2;
  list[2] = 'xiaoming';
  print('list: ${list}');
  //元素类型固定
  var typeList = List&lt;int&gt;();
  typeList.add(1);
  typeList.add(2);
  typeList.add(3);
  print('typeList: ${typeList}');
  //常用属性
  int first = typeList.first;
  print('typeList.first: ${first}'); //第一个元素
  int last = typeList.last;
  print('typeList.last: ${last}'); //最后一个元素
  int length = typeList.length;
  print('typeList.length: ${length}'); //元素个数
  bool isEmpty = typeList.isEmpty;
  print('typeList.isEmpty: ${isEmpty}'); //是否为空
  bool isNotEmpty = typeList.isNotEmpty;
  print('typeList.isNotEmpty: ${isNotEmpty}'); //是否不为空
  Iterable reversed = typeList.reversed;
  print('typeList.reversed: ${reversed}'); //倒序
  //常用方法 增删改查，排序，洗牌，复制子列表
  var list4 = [];
  //增
  list4.add(1);
  print('add 1 :${list4}');
  list4.addAll([2, 3, 4]);
  print('addAll [2, 3, 4] :${list4}');
  list4.insert(0, 0);
  print('insert(0, 0) :${list4}');
  list4.insertAll(1, [5, 6, 7]);
  print('insertAll(1, [5, 6, 7]) :${list4}');
  //删
  list4.remove(5);
  print('remove 5 :${list4}');
  list4.removeAt(2);
  print('remove at 0 :${list4}');
  //改
  list4[4] = 5;
  print('update list4[4] to 5 :$list4}');
  //range
  list4.fillRange(0, 3, 9);
  print('fillRange update list4[0]-list4[2] to 9 :$list4}');
  Iterable getRange = list4.getRange(0, 3);
  print('getRange list4[0]-list4[2] :$getRange}');
  //查
  var contains = list4.contains(5);
  print('list4 contains 5 :${contains}');
  var indexOf = list4.indexOf(1);
  print('list4 indexOf 1 :${indexOf}');
  int indexWhere = list4.indexWhere((test) =&gt; test == 5);
  print('list4 indexWhere 5 :${indexWhere}');
  //排序
  list4.sort();
  print('list4 sort :${list4}');
  //洗牌
  list4.shuffle();
  print('list4 shuffle :${list4}');
  //复制子列表
  var list5 = list4.sublist(1);
  print('sublist(1) list5 :${list5}');
  //操作符
  var list6 = [8, 9];
  print('list6 :${list6}');
  var list7 = list5 + list6;
  print('list5 + list6 :${list7}');
  print('-----------------------Lists------------------------');
</code></pre> 
<h3><a id="25_Map_329"></a>2.5 内置类型-Map</h3> 
<ul><li>跟java类似</li></ul> 
<pre><code> /// ---------------------------------Maps键值对集合:Map--------------------------------
  print('-----------------------Maps------------------------');
  //声明
  //动态类型
  var dynamicMap = Map();
  dynamicMap['name'] = 'hongxue';
  dynamicMap[1] = 'android';
  print('dynamicMap :${dynamicMap}');
  //强类型
  var map = Map&lt;int, String&gt;();
  map[1] = 'android';
  map[2] = 'flutter';
  print('map :${map}');
  //也可以这样声明
  var map1 = {'name': 'hongxue', 1: 'android'};
  map1.addAll({'name':'xiaoming'});
  print('map1 :${map1}');
  //常用属性
//  print(map.isEmpty); //是否为空
//  print(map.isNotEmpty); //是否不为空
//  print(map.length); //键值对个数
//  print(map.keys); //key 集合
//  print(map.values); //value集合

  //常用方法 增删改查
  print('-----------------------Maps------------------------');
</code></pre> 
<h3><a id="26_Set_361"></a>2.6 内置类型-Set</h3> 
<ul><li>set1.difference(set2):返回set1集合里有但set2里没有的元素集合</li><li>set1.intersection(set2)：返回set1和set2的交集</li><li>set1.union(set2)：返回set1和set2的并集</li><li>set1.retainAll()：set1只保留某些元素(要保留的元素要在原set中存在）</li></ul> 
<pre><code>/// ---------------------------------Sets集合:Set--------------------------------
  print('-----------------------Sets------------------------');
  //6.  Set无重复列表
  var dynamicSet = Set();
  dynamicSet.add('hongxue');
  dynamicSet.add('flutter');
  dynamicSet.add(1);
  dynamicSet.add(1);
  print('dynamicSet :${dynamicSet}');
  //常用属性与list类似

  //常用方法 增删改查与list类似
  var set1 = {'hongxue', 'flutter'};
  print('set1 :${set1}');
  var set2 = {'hongxue', 'xiaoming', 'dart'};
  print('set2 :${set2}');
  var difference12 = set1.difference(set2);
  var difference21 = set2.difference(set1);
  print('set1 difference set2 :${difference12}'); //返回set1集合里有但set2里没有的元素集合
  print('set2 difference set1 :${difference21}'); //返回set2集合里有但set1里没有的元素集合
  var intersection = set1.intersection(set2);
  print('set1 set2交集 :${intersection}'); //返回set1和set2的交集
  var union = set1.union(set2);
  print('set1 set2并集 :${union}'); //返回set1和set2的并集
  set2.retainAll(['hongxue', 'flutter']); //只保留(要保留的元素要在原set中存在）
  print('set2只保留hongxue flutter :${set2}');
  print('-----------------------Sets------------------------');
</code></pre> 
<h3><a id="27_Runes_398"></a>2.7 内置类型-Runes</h3> 
<pre><code>Main(){
  Runes runes = new Runes('\u{1f605} \u6211‘);
  var str1 = String.fromCharCodes(runes);  
  print(str1);
}
</code></pre> 
<pre><code>  /// ---------------------------------Runes符号字符--------------------------------
  //Runes用于在字符串中表示Unicode字符 https://copychar.cc/emoji/
  String runesStr = '?';
  print(runesStr);
  print(runesStr.length); //表示占 2 个 16 位字符
  print(runesStr.runes.length); //表示占 1 个 32 位字符

  Runes runes = new Runes('\u{1f605} \u6211');
  var str1 = String.fromCharCodes(runes); //使用String.fromCharCodes显示字符图形
  print(str1);
  String str2 = '\u{1f605} \u6211'; //如果非4个数值，需要把编码值放到大括号中
  print(str2);
</code></pre> 
<h3><a id="28_Symbol_423"></a>2.8 内置类型-Symbol</h3> 
<ul><li>Symbol标识符，主要是反射用，现在mirrors模块已经被移除</li></ul> 
<hr> 
<h2><a id="3___430"></a>3 函数</h2> 
<h3><a id="31__431"></a>3.1 函数-定义</h3> 
<ul><li>可在函数内定义</li><li>定义函数时可省略类型</li><li>支持缩写语法 =&gt;</li></ul> 
<pre><code>  //普通函数定义
  int add(int x, int y) {
    return x + y;
  }
  print(add(1, 2));

  //所有的函数都返回一个值。如果没有指定返回值，则 默认把语句 return null; 作为函数的最后一个语句执行。
  testFunc() {}
  ;
  print(testFunc());

  //可省略类型(不建议)
  add1(x, y) {
    return x + y;
  }

  print(add1('1', '2'));
  print(add1(1, 2));

  //箭头函数：=&gt;表达式
  int add2(int x, int y) =&gt; x + y;
</code></pre> 
<h3><a id="32__461"></a>3.2 函数-可选参数</h3> 
<ul><li>可选命名参数</li><li>可选位置参数</li><li>默认参数值</li></ul> 
<pre><code>  print('---------------------------可选参数 begin---------------------------');

  //可选命名参数：使用 {param1, param2, …} 的形式来指定命名参数
  int add3({int x, int y, int z}) {
    x ??= 1;
    y ??= 2;
    z ??= 3;
    return x + y + z;
  }

  print(add3());//打印 6

  //可选位置参数：把可选参数放到 [] 中，必填参数要放在可选参数前面
  int add4(int x, [int y, int z]) {
    y ??= 2;
    z ??= 3;
    return x + y + z;
  }

  print(add4(1));//打印 6

  //可选命名参数默认值(默认值必须是编译时常量),目前可以使用等号'='或冒号':'
  //Dart SDK 1.21 之前只能用冒号，冒号的支持以后会移除，所以建议使用等号
  int add5(int x, {int y = 2, int z = 3}) {
    return x + y + z;
  }

  //前面的必填参数没有名字
  print(add5(1, y: 10, z: 2));

  //可选位置参数默认值(默认值必须是编译时常量),只能使用等号'='
  int add6(int x, [int y = 2, int z = 3]) {
    return x + y + z;
  }

  print(add6(1));

  //使用list或map作为默认值，但必须是const
  void func(
      {List list = const [1, 2, 3],
      Map map = const {1: 1, 'name': 'hongxue'}}) {
  }

  print('---------------------------可选参数 end---------------------------');
</code></pre> 
<p>打印：</p> 
<pre><code>---------------------------可选参数 begin---------------------------
6
6
13
6
---------------------------可选参数 end---------------------------
</code></pre> 
<h3><a id="33__523"></a>3.3 函数-匿名函数</h3> 
<ul><li>可赋值给变量，通过变量调用</li><li>可在其他函数中直接调用或传递给其他函数</li></ul> 
<pre><code>print('---------------------------匿名函数 begin---------------------------');

  //匿名函数
  //赋值给变量
  //无参匿名函数
  var anonFunc1 = () =&gt; print('无参匿名函数');
  anonFunc1();

  //有参匿名函数
  var anonFunc = (name) =&gt; 'I am $name';
  print(anonFunc('xiaoming'));

  //通过()调用，不推荐
//  (()=&gt;print('不推荐'))();

  //匿名函数传参
  List test(List list, String func(str)) {
    for (var i = 0; i &lt; list.length; i++) {
      list[i] = func(list[i]);
    }
    return list;
  }

  var list = ['x', 'i', 'a', 'o', 'm'];
  print(test(list, (str) =&gt; str * 2)); //String * int, Dart和Python可以这样用

  //List.forEach()就用的匿名函数
  List list1 = [11, 12, 13];
  list1.forEach((item) =&gt; print('$item'));

  print('---------------------------匿名函数 end---------------------------');
</code></pre> 
<p>打印如下：</p> 
<pre><code>---------------------------匿名函数 begin---------------------------
无参匿名函数
I am xiaoming
[xx, ii, aa, oo, mm]
11
12
13
---------------------------匿名函数 end---------------------------
</code></pre> 
<h3><a id="34__572"></a>3.4 函数-闭包</h3> 
<pre><code>  //返回Function对象（闭包）
  Function makeAddFunc(int x) {
    x++;
    return (int y) =&gt; x + y;
  }

  var addFunc = makeAddFunc(2);
  print(addFunc(3));
</code></pre> 
<p>打印：6</p> 
<h3><a id="35__587"></a>3.5 函数-函数别名</h3> 
<pre><code>//函数别名
typedef MyFunc(int a, int b);

//根据MyFunc相同的函数签名定义两个函数
subtsract(int a, int b) {
  print('subtsract: ${a - b}');
}

divide(int a, int b) {
  print('divide: ${a / b}');
}

//typedef 也可以作为参数传递给函数
calculator(int a, int b, MyFunc func) {
  func(a, b);
}
</code></pre> 
<pre><code>void main(){

 // 函数别名
  MyFunc myFunc;
  //可以指向任何同签名的函数
  myFunc = subtsract;
  myFunc(5, 2);
  myFunc = divide;
  myFunc(8, 2);
  //typedef 作为参数传递给函数
  calculator(5, 2, subtsract);
  calculator(8, 2, divide);

}
</code></pre> 
<p>打印：</p> 
<pre><code>subtsract: 3
divide: 4.0
subtsract: 3
divide: 4.0
</code></pre> 
<hr> 
<h2><a id="4__634"></a>4 操作符</h2> 
<p><img src="https://images2.imgbox.com/fb/b1/SfJ1Mpw5_o.png" alt="在这里插入图片描述" width="580"></p> 
<pre><code>main() {
  //Operators 操作符
  /// ---------------------------------后缀操作符 ?.--------------------------------
  //  条件成员访问 和 . 类似，但是左边的操作对象不能为 null，例如 foo?.bar 如果 foo 为 null 则返回 null，否则返回 bar 成员
  String a;
  print(a?.length);

  /// ---------------------------------取商操作符 ~/--------------------------------
  //  被除数 ÷ 除数 = 商 ... 余数，A ~/ B = C，这个C就是商。相当于Java里的 /
  print(2 / 3);
  print(2 ~/ 3);

  /// ---------------------------------类型判定操作符--------------------------------
  //类型判定操作符：as、is、is!在运行时判定对象类型
  //as 类型转换
  num iNum = 1;
  num dNum = 1.0;
  int i = iNum as int;
  double d = dNum as double;
  print([i, d]);

//  String s = iNum as String;

  //is 如果对象是指定的类型返回 True
  print(iNum is int);
  Child child;
  Child child1 = new Child();
  print(child is Parent); //child is Null
  print(child1 is Parent);

  //is! 如果对象是指定的类型返回 False
  print(iNum is! int);

  /// ---------------------------------条件表达式--------------------------------
  // 三目运算符 condition ? expr1 : expr2
  bool isFinish = true;
  String txtVal = isFinish ? 'yes' : 'no';
  // expr1 ?? expr2，如果 expr1 是 non-null，返回其值； 否则执行 expr2 并返回其结果。
  bool isPaused;
  isPaused = isPaused ?? false;
  //或者
  isPaused ??= false;

  /// ---------------------------------级联操作符--------------------------------
  // .. 可以在同一个对象上 连续调用多个函数以及访问成员变量。
  // 严格来说， 两个点的级联语法不是一个操作符。 只是一个 Dart 特殊语法。
  StringBuffer sb = new StringBuffer();
  sb
    ..write('hongxue')
    ..write('flutter')
    ..write('\n')
    ..writeln('xiaoming');

  //重写操作符

}

class Parent {}

class Child extends Parent {}
</code></pre> 
<p>打印：</p> 
<pre><code>null
0.6666666666666666
0
[1, 1.0]
true
false
true
false
</code></pre> 
<hr> 
<p>重载操作符：</p> 
<pre><code>void main(){
  final v1 = Vector(5,6);
  final v2 = Vector(2,2);
  final r1 = v1 + v2;
  final r2 = v1 - v2;
  print([r1.x,r1.y]);
  print([r2.x,r2.y]);
}

//重载操作符
class Vector{
  final int x;
  final int y;

  const Vector(this.x,this.y);

  //重载+
  Vector operator +(Vector v){
    return new Vector(x + v.x, y + v.y);
  }
  //重载
  Vector operator -(Vector v){
    return new Vector(x - v.x, y - v.y);
  }

}
</code></pre> 
<p>打印：</p> 
<pre><code>[7, 8]
[3, 4]
</code></pre> 
<h2><a id="5___753"></a>5 流程控制语句</h2> 
<ul><li>if else</li><li>for, forEach, for-in</li><li>while , do-while</li><li>break , continue</li><li>switch case</li></ul> 
<pre><code>main() {
  var collection = [0, 1, 2];
  //forEach
  collection.forEach((item) =&gt; print('forEach: $item'));
  //for-in遍历元素
  for (var item in collection) {
    print('for-in: $item');
  }
}
</code></pre> 
<p>打印：</p> 
<pre><code>forEach: 0
forEach: 1
forEach: 2
for-in: 0
for-in: 1
for-in: 2

</code></pre> 
<h2><a id="6__785"></a>6 异常</h2> 
<h3><a id="61_Exception_786"></a>6.1 异常-Exception类型</h3> 
<p><img src="https://images2.imgbox.com/1d/3d/ljU4byDn_o.png" alt="在这里插入图片描述" width="550"></p> 
<br> 
<h3><a id="62_Error_791"></a>6.2 异常-Error类型</h3> 
<p><img src="https://images2.imgbox.com/be/0d/Y3aapsDV_o.png" alt="在这里插入图片描述" width="650"></p> 
<h3><a id="63__794"></a>6.3 异常-抛出</h3> 
<pre><code>// 抛出Exception 对象
// throw new FormatException(‘格式异常');

// 抛出Error 对象
// throw new OutOfMemoryError();

// 抛出任意非null对象
// throw '这是一个异常';
</code></pre> 
<h3><a id="64__807"></a>6.4 异常-捕获</h3> 
<pre><code>try {
  throw new OutOfMemoryError();
} on OutOfMemoryError {
  print('没有内存了');
} on Error catch(e) {
  print('Unknown error: $e');
} catch (e, s) {
  print('Exception details: $e');
  print('Stack Trace: $s');
} finally {
  print('end');
} 
</code></pre> 
<p>打印：</p> 
<pre><code>没有内存了
end
</code></pre> 
<hr> 
<h2><a id="7__831"></a>7 类</h2> 
<h3><a id="71__832"></a>7.1 类-构造函数</h3> 
<pre><code>//java中写法
class Point {
  double x;
  double y;

  Point(int x, int y) {
    this.x = x;
    this.y = y;
  }
}
</code></pre> 
<pre><code>//dart建议写法
class Point {
  num x;
  num y;
  Point(this.x, this.y);
}
</code></pre> 
<pre><code>main() {
  //普通构造函数
  var p = new Point(1, 1); //new 可省略 var point = Point(1, 2);
  print(p);
}
</code></pre> 
<p>打印：</p> 
<pre><code>Point(x = 1, y = 1)
</code></pre> 
<h3><a id="72__869"></a>7.2 类-命名构造函数</h3> 
<pre><code>class Point { 
  num x; 
  num y; 

  Point(this.x, this.y); 

  //命名构造函数
  Point.fromJson(Map json) { 
    x = json['x']; 
    y = json['y']; 
  } 
}
</code></pre> 
<pre><code>void main(){
	//命名构造函数
	p = Point.fromJson({'x': 2, 'y': 2});
	print(p);
}
</code></pre> 
<p>打印：</p> 
<pre><code>Point(x = 2, y = 2)
</code></pre> 
<h3><a id="73__899"></a>7.3 类-重定向构造函数</h3> 
<pre><code>class Point { 
  num x; 
  num y; 

  Point(this.x, this.y); 

  //重定向构造函数，使用冒号调用其他构造函数
  Point.alongXAxis(num x) : this(x, 0);
}
</code></pre> 
<pre><code>  //重定向构造函数
  p = Point.alongXAxis(0);
  print(p);
</code></pre> 
<p>打印：</p> 
<pre><code>Point(x = 0, y = 0)
</code></pre> 
<h3><a id="74__923"></a>7.4 类-初始化列表</h3> 
<pre><code>import 'dart:math';

class Point {
  //final变量不能被修改，必须被构造函数初始化
  final num x;
  final num y;
  final num distanceFromOrigin;

  //初始化列表
  Point(x, y)
      : x = x,
        y = y,
        distanceFromOrigin = sqrt(x * x + y * y);
}
</code></pre> 
<h3><a id="75___942"></a>7.5 类-调用超类构造函数</h3> 
<pre><code>class Parent {
  int x;
  int y;

  //父类命名构造函数不会传递  
  Parent.fromJson(x, y)
      : x = x,
        y = y {
    print('父类命名构造函数');
  }
}
</code></pre> 
<pre><code>class Child extends Parent {
  int x;
  int y;
  //若超类没有默认构造函数， 需要手动调用超类其他构造函数
  Child(x, y) : super.fromJson(x, y) {
    //调用父类构造函数的参数无法访问 this
    print('子类构造函数');
  }

  //在构造函数的初始化列表中使用super()，需要把它放到最后
  Child.fromJson(x, y) 
	 : x = x,
	   y = y,
	   super.fromJson(x, y) {
    print('子类命名构造函数');
  }
}
</code></pre> 
<pre><code>main() {
  //调用超类构造函数
  var child = Child.fromJson(1, 2);
  var child1 = Child(3, 4);
}
</code></pre> 
<p>打印：</p> 
<pre><code>超类命名构造函数
子类命名构造函数
超类命名构造函数
子类构造函数
</code></pre> 
<h3><a id="76__994"></a>7.6 类-常量构造函数</h3> 
<pre><code>class Point2 {
  //定义const构造函数要确保所有实例变量都是final
  final num x;
  final num y;
  static final Point2 origin = const Point2(0, 0);

  //const关键字放在构造函数名称之前，且不能有函数体
  const Point2(this.x, this.y);
}
</code></pre> 
<pre><code>void main(){
	//常量构造函数
  var p2 = const Point2(4, 4);
  print(p2);
  var p21 = Point2(4, 4); //创建的是非 常量对象
  var p22 = const Point2(4, 4);
  print(identical(p2, p21));
  print(identical(p2, p22));
}
</code></pre> 
<p>打印：</p> 
<pre><code>Point2(x = 4, y = 4)
false
true
</code></pre> 
<h3><a id="77__1026"></a>7.7 类-工厂构造函数</h3> 
<pre><code>class Singleton {
  String name;
  //工厂构造函数无法访问this，所以这里要用static
  static Singleton _cache; 

  //工厂方法构造函数，关键字factory
  factory Singleton([String name = 'singleton']) =&gt;
      Singleton._cache ??= Singleton._newObject(name);

  //定义一个命名构造函数用来生产实例
  Singleton._newObject(this.name);
}
</code></pre> 
<p>打印：true</p> 
<h3><a id="78_SetterGetter_1044"></a>7.8 类-Setter和Getter</h3> 
<pre><code>main() {
  //set get
  var rect = new Rectangle(1, 1, 10, 10);
  print(rect.left);
  rect.right = 15;
  print(rect.left);
}

//setter getter
//每个实例变量都隐含的具有一个 getter， 如果变量不是 final 的则还有一个 setter
//可以通过实行 getter 和 setter 来创建新的属性， 使用 get 和 set 关键字定义 getter 和 setter
class Rectangle {
  num left;
  num top;
  num width;
  num height;

  Rectangle(this.left, this.top, this.width, this.height);

  // getter 和 setter 的好处是，可以开始使用实例变量，后面可以把实例变量用函数包裹起来，而调用你代码的地方不需要修改。
  //获取right值
  num get right =&gt; left + width;
  //设置right值，同时left也发生变化
  set right(num value) =&gt; left = value - width;
  //获取bottom值
  num get bottom =&gt; top + height;
  //设置bottom值，同时top也发生变化
  set bottom(num value) =&gt; top = value - height;
}
</code></pre> 
<p>打印：</p> 
<pre><code>1
5
</code></pre> 
<h3><a id="79__1084"></a>7.9 类-抽象类</h3> 
<ul><li>abstract关键字修饰class</li><li>继承的方式使用</li><li>接口的方式使用</li></ul> 
<p>工厂模式两种方式：</p> 
<p>1 创建工厂构造函数</p> 
<pre><code>main() {
  //创建工厂构造函数
  var footMassage = new Massage('foot');
  footMassage.doMassage();
  var bodyMassage = new Massage('body');
  bodyMassage.doMassage();
  var specialMassage = new Massage('%#@##@##');
  specialMassage.doMassage();
}
//工厂模式
abstract class Massage {
  factory Massage(String type) {
    switch (type) {
      case 'foot':
        return new FootMassage();
      case 'body':
        return new BodyMassage();
      default:
        return new SpecialMassage();
    }
  }
  void doMassage();
}

class FootMassage implements Massage {
  @override
  doMassage() {
    print('脚底');
  }
}
class BodyMassage implements Massage {
  @override
  void doMassage() {
    print('全身');
  }
}
class SpecialMassage implements Massage {
  @override
  void doMassage() {
    print('特殊');
  }
}
</code></pre> 
<p>打印：</p> 
<pre><code>脚底
全身
特殊
</code></pre> 
<hr> 
<p>2 创建顶级函数</p> 
<pre><code>main() {
  //创建顶级函数
  var footMassage = massageFactory('foot');
  footMassage.doMassage();
  var bodyMassage = massageFactory('body');
  bodyMassage.doMassage();
  var specialMassage = massageFactory('xxx');
  specialMassage.doMassage();
}
//工厂函数
class Massage {
  void doMassage(){
    print('按摩');
  }
}
class FootMassage extends Massage {
  @override
  doMassage() {
    print('脚底');
  }
}

class BodyMassage extends Massage {
  @override
  void doMassage() {
    print('全身');
  }
}

class SpecialMassage extends Massage {
  @override
  void doMassage() {
    print('特殊');
  }
}
Massage massageFactory(String type){
  switch (type) {
    case 'foot':
      return new FootMassage();
    case 'body':
      return new BodyMassage();
    default:
      return new SpecialMassage();
  }
}
</code></pre> 
<p>打印：</p> 
<pre><code>脚底
全身
特殊
</code></pre> 
<h3><a id="710__1202"></a>7.10 类-可调用类</h3> 
<pre><code>main() {
  //可调用类
  var cf = new ClassFunction();
  var out = cf("hongxue","flutter,","xiaoming");
  print('$out'); // Hi there, gang!
  print(cf.runtimeType); // WannabeFunction
  print(out.runtimeType); // String
  print(cf is Function); // true
}
//可调用类
class ClassFunction {
  call(String a, String b, String c) =&gt; '$a $b $c!';
}
</code></pre> 
<p>打印：</p> 
<pre><code>hongxue flutter, xiaoming!
ClassFunction
String
false
</code></pre> 
<hr> 
<h2><a id="8_Mixin_1228"></a>8 Mixin</h2> 
<p>可以理解为多进程。<br> <img src="https://images2.imgbox.com/ce/a8/69DLIXPW_o.png" alt="在这里插入图片描述"></p> 
<pre><code>main() {
  Bicycle().transport();
  Motorcycle().transport();
  Car().transport();
  WoodenCar().transport();  //四轮木制脚踏车
}

//交通工具类，拥有运输功能
abstract class Transportation {
  //运输功能
  void transport();
}

//自行车
class Bicycle extends Transportation
    with TwoWheelTransportation, LowSafetyIndex, BodyEnergyTransportation {
  @override
  void transport() {
    print(
        "自行车:\n动力组件: ${powerUnit()} , 安全指数： ${safetyIndex()} , 动力来源：${energy()}");
  }

//  String safetyIndex() =&gt; "low";
//
//  String powerUnit() =&gt; "两个轮子";
//
//  String energy() =&gt; "全靠腿登";
}

//摩托车
class Motorcycle extends Transportation
    with TwoWheelTransportation, LowSafetyIndex, GasolineEnergyTransportation {
  @override
  void transport() {
    print(
        "摩托车:\n动力组件: ${powerUnit()} , 安全指数： ${safetyIndex()} , 动力来源：${energy()}");
  }

//  String safetyIndex() =&gt; "low";
//
//  String powerUnit() =&gt; "两个轮子";
//
//  String energy() =&gt; "汽油";
}

//汽车
class Car extends Transportation
    with
        FourWheelTransportation,
        MiddleSafetyIndex,
        GasolineEnergyTransportation {
  @override
  void transport() {
    print(
        "汽车:\n动力组件: ${powerUnit()} , 安全指数： ${safetyIndex()} , 动力来源：${energy()}");
  }

//  String safetyIndex() =&gt; "middle";
//
//  String powerUnit() =&gt; "四个轮子";
//
//  String energy() =&gt; "汽油";
}

//双轮交通工具
class TwoWheelTransportation {
  String powerUnit() =&gt; "两个轮子";
}

//四轮交通工具，一般来说安全性能为中
class FourWheelTransportation {
  String powerUnit() =&gt; "四个轮子";
}

//安全指数中等的交通工具儿
class MiddleSafetyIndex {
  String safetyIndex() =&gt; "middle";
}

//安全指数低的交通工具儿
class LowSafetyIndex {
  String safetyIndex() =&gt; "low";
}

//人力发动机
class BodyEnergyTransportation {
  String energy() =&gt; "全靠腿登";
}

//汽油能源交通工具
class GasolineEnergyTransportation {
  String energy() =&gt; "汽油";
}

//四轮木制脚踏车
class WoodenCar extends Car
//    with LowSafetyIndex, BodyEnergyTransportation
//implements LowSafetyIndex, BodyEnergyTransportation
    {
  @override
  void transport() {
    print(
        "四轮木制脚踏车:\n动力组件: ${powerUnit()} ， 安全指数： ${safetyIndex()} ， 动力来源：${energy()}");
  }
}
</code></pre> 
<p>打印：</p> 
<pre><code>自行车:
动力组件: 两个轮子 , 安全指数： low , 动力来源：全靠腿登
摩托车:
动力组件: 两个轮子 , 安全指数： low , 动力来源：汽油
汽车:
动力组件: 四个轮子 , 安全指数： middle , 动力来源：汽油
四轮木制脚踏车:
动力组件: 四个轮子 ， 安全指数： middle ， 动力来源：汽油
</code></pre> 
<hr> 
<p>顺序问题：</p> 
<pre><code>void main(){
  var messageAB = AB().getMessage();
  print(messageAB);
  var messageBA = BA().getMessage();
  print(messageBA);
  var messageC = C().getMessage();
  print(messageC);
  var messageCC = CC().getMessage();
  print(messageCC);
}

//顺序问题
//如果2个或多个超类拥有相同签名的A方法，那么子类会以继承的最后一个超类中的A方法为准。
//当然这是子类没有重写A方法的前提下，如果子类自己重写了A方法则以本身的A方法为准
class A {
  String getMessage() =&gt; 'A';
}

class B {
  String getMessage() =&gt; 'B';
}

class P {
  String getMessage() =&gt; 'P';
}

class AB extends P with A, B {}

class BA extends P with B, A {}

class C extends P with B, A {
  String getMessage() =&gt; 'C'; //优先级最高的是在具体类中的方法。
}

class CC extends P with B implements A {
} //这里的implement只是表明要实现A的方法，这个时候具体实现是再B中mixin了具体实现

</code></pre> 
<p>打印：</p> 
<pre><code>B
A
C
B
</code></pre> 
<hr> 
<h2><a id="9__1405"></a>9 泛型</h2> 
<pre><code>void main(){
  //使用泛型，很多的容器对象，在创建对象时都可以定义泛型类型,跟java一样
  var list = List&lt;String&gt;();
  list.add('aaa');
  list.add('bbb');
  list.add('ccc');
  print(list);

  var map = Map&lt;int, String&gt;();
  map[1] = 'aaaa';
  map[2] = 'bbbb';
  map[3] = 'cccc';
  print(map);
}
</code></pre> 
<p>打印：</p> 
<pre><code>[aaa, bbb, ccc]
{1: aaaa, 2: bbbb, 3: cccc}
</code></pre> 
<h3><a id="91___1430"></a>9.1 泛型-泛型函数</h3> 
<pre><code>void main(){
  var key = addCache('hongxue', 'xiaoming');
  print(key);
}

//泛型函数
K addCache&lt;K, V&gt;(K key, V value) {
  K temp = key;
  print('${key}: ${value}');
  return temp;
}
</code></pre> 
<p>打印：</p> 
<pre><code>hongxue: xiaoming
hongxue
</code></pre> 
<h3><a id="92__1452"></a>9.2 泛型-构造函数泛型</h3> 
<pre><code>void main(){
  //构造函数泛型
  var p = Phone&lt;String&gt;('123456');
  print(p.mobileNumber);
}

//构造函数泛型
class Phone&lt;T&gt; {
  final T mobileNumber;
  Phone(this.mobileNumber);
}
</code></pre> 
<p>打印：</p> 
<pre><code>123456
</code></pre> 
<h3><a id="93__1473"></a>9.3 泛型-泛型限制</h3> 
<pre><code>void main(){
  //泛型限制， 通过 extends 关键字限定可泛型使用的类型
  var footMassage = FootMassage();
  var m = Massage&lt;FootMassage&gt;(footMassage);
  m.massage.doMassage();
}
//泛型限制
class Massage&lt;T extends FootMassage &gt; {
  final T massage;
  Massage(this.massage);
}
class FootMassage {
  void doMassage() {
    print('脚底');
  }
}
</code></pre> 
<p>打印：</p> 
<pre><code>脚底
</code></pre> 
<h3><a id="94_java_1499"></a>9.4 泛型-与java区别</h3> 
<ul><li>Java中的泛型信息是编译时的，泛型信息在运行时是不存在的</li><li>Dart的泛型类型是固化的，在运行时也有可以判断的具体类型</li></ul> 
<pre><code>void main(){
  var names = List&lt;String&gt;();
  print(names is List&lt;String&gt;);//true
  print(names.runtimeType); // List&lt;String&gt;
}
</code></pre> 
<p>打印：</p> 
<pre><code>true
List&lt;String&gt;
</code></pre> 
<hr> 
<h2><a id="10__1518"></a>10 库</h2> 
<h3><a id="101__1519"></a>10.1 库-使用核心库</h3> 
<p>使用import关键字来载入库：</p> 
<pre><code>import "dart:math";

void main() {
  print(sqrt(4));//开平方 2.0
}
</code></pre> 
<h3><a id="102__1529"></a>10.2 库-载入第三方库</h3> 
<p><a href="https://pub.flutter-io.cn/" rel="nofollow">https://pub.flutter-io.cn/</a></p> 
<p>1.编写pubspec.yaml:</p> 
<pre><code>dependencies:
  flutter:
    sdk: flutter

  cupertino_icons: ^0.1.0
  dio: ^2.1.0
</code></pre> 
<p>2.调用</p> 
<pre><code>import "package:dio/dio.dart";

void main() {
  getHttp();
}

void getHttp() async {
  try {
    Response response = await Dio().get("https://www.baidu.com");
    print(response);
  } catch (e) {
    print(e);
  }
}

</code></pre> 
<h3><a id="103__1564"></a>10.3 库-载入文件</h3> 
<p>新建一个mylib1.dart</p> 
<pre><code>class MyLib {
  String name;
  static MyLib _cache; //工厂构造函数无法访问 this。所以这里要静态的

  factory MyLib([String name = 'singleton']) =&gt;
      MyLib._cache ??= MyLib._newObject(name);

  //定义一个命名构造函数用来生产实例
  MyLib._newObject(this.name);
}

class Test {
  void test() =&gt; print('Test');
}

test(){

}

</code></pre> 
<pre><code>//载入文件
import “mylib1.dart";

void main() {
  var myLib1 = MyLib();
}
</code></pre> 
<h3><a id="104__1597"></a>10.4 库-指定库前缀</h3> 
<p>如果两个库有冲突的标识符，可以为其中一个或两个库都指定前缀:</p> 
<p>mylib1.dart</p> 
<pre><code>class MyLib {
  String name;
  static MyLib _cache; //工厂构造函数无法访问 this。所以这里要静态的

  factory MyLib([String name = 'singleton']) =&gt;
      MyLib._cache ??= MyLib._newObject(name);

//定义一个命名构造函数用来生产实例
  MyLib._newObject(this.name);
}

class Test {
  void test() =&gt; print('Test');
}

test(){

}
</code></pre> 
<p>mylib2.dart</p> 
<pre><code>class MyLib{
  String name;
  static MyLib _cache; //工厂构造函数无法访问 this。所以这里要静态的

  factory MyLib([String name = 'singleton']) =&gt;
      MyLib._cache ??= MyLib._newObject(name);

//定义一个命名构造函数用来生产实例
  MyLib._newObject(this.name);
}

class Test{
  void test() =&gt; print('Test');
}
</code></pre> 
<p>载入文件</p> 
<pre><code>import 'mylib1.dart' as lib1; //载入文件
import 'mylib2.dart' as lib2; //如果两个库有冲突的标识符，可以为其中一个或两个库都指定前缀

void main() {
  var myLib = lib1.MyLib();
  var myLib2 = lib2.MyLib();
}
</code></pre> 
<h3><a id="105__1651"></a>10.5 库-选择性载入</h3> 
<ul><li>show-只载入库的某些部分</li><li>hide-筛选掉库的某些部分</li></ul> 
<pre><code>import 'mylib1.dart' as lib1 show Test; //只载入库的某些部分
import 'mylib2.dart' as lib2 hide Test; //筛选掉库的某些部分

void main(){
  //选择性载入
  var test = lib1.Test();
  var lib = lib2.MyLib();

}
</code></pre> 
<h3><a id="106__1667"></a>10.6 库-延迟载入</h3> 
<ul><li>使用deferred as导入</li><li>使用标识符调用loadLibrary()加载库</li></ul> 
<pre><code>import 'mylib1.dart' deferred as lazyLib; //延迟载入

void main(){
  //延迟载入
  lazyLoad();
}
//延迟载入
//可提高程序启动速度
//用在不常使用的功能
//用在载入时间过长的包
lazyLoad() async {
  await lazyLib.loadLibrary();
  var t = lazyLib.Test();
  t.test();
}
</code></pre> 
<h3><a id="107__1688"></a>10.7 库-自定义库</h3> 
<p>新建util.dart</p> 
<pre><code>part of mylib;

void printUtil() =&gt; print('util');
</code></pre> 
<p>新建tool.dart</p> 
<pre><code>part of mylib;

void printTool() =&gt; print('tool');
</code></pre> 
<p>新建mylib.dart</p> 
<pre><code>library mylib;

part 'util.dart';
part 'tool.dart';

void printMyLib() =&gt; print('mylib');
</code></pre> 
<pre><code>import 'mylib/mylib.dart';//载入自定义库

void main(){
  //载入自定义库
  printMyLib();
  printUtil();
  printTool();
}
</code></pre> 
<p>打印：</p> 
<pre><code>mylib
util
tool
</code></pre> 
<hr> 
<h2><a id="11__1731"></a>11 异步</h2> 
<h3><a id="111_asyncawait_1732"></a>11.1 异步-async和await</h3> 
<pre><code>import 'dart:async';

main() async {
  // async wait
  getName1();
  getName2();
  getName3();
}

// async wait
Future&lt;void&gt; getName1() async {
//  getStr1();//可以不用await打断点看下await后的区别
  await getStr1(); //遇到第一个await表达式执行暂停，返回future对象，await表达式执行完成后继续执行
  await getStr2(); //await表达式可以使用多次
  print('getName1');
}

getStr1() {
  print('getStr1');
}

getStr2() {
  print('getStr2');
}

getName2() {
  print('getName2');
}

getName3() {
  print('getName3');
}
</code></pre> 
<p>打印：</p> 
<pre><code>getStr1
getName2
getName3
getStr2
getName1
</code></pre> 
<h3><a id="112_thencatchErrorwhenComplete_1779"></a>11.2 异步-then,catchError,whenComplete</h3> 
<pre><code>import 'dart:async';

main() async {
  //then catchError whenComplete
  new Future(() =&gt; futureTask()) //  异步任务的函数
      .then((m) =&gt; "a:$m") //   任务执行完后的子任务
      .then((m) =&gt; print('a$m')) //  其中m为上个任务执行完后的返回的结果
      .then((_) =&gt; new Future.error('error'))
      .then((m) =&gt; print('damon'))
      .whenComplete(() =&gt; print('whenComplete1')) //不是最后执行whenComplete，通常放到最后回调

//      .catchError((e) =&gt; print(e))//如果不写test默认实现一个返回true的test方法
      .catchError((e) =&gt; print('catchError:' + e), test: (Object o) {
    print('test:' + o);
    return true; //返回true，会被catchError捕获
//        return false; //返回false，继续抛出错误，会被下一个catchError捕获
  })
      .catchError((e) =&gt; print('catchError2:' + e))
//      .then((m) =&gt; print('dongnao'))
//      .whenComplete(() =&gt; print('finish'))
      ;
}

int futureTask() {
//  throw 'error';
  return 10;
}
</code></pre> 
<h3><a id="113_EventLooper_1810"></a>11.3 异步-Event-Looper</h3> 
<p><img src="https://images2.imgbox.com/5f/a2/P2wFBC6Z_o.png" alt="在这里插入图片描述"></p> 
<p>打印：</p> 
<pre><code>aa:10
whenComplete1
test:error
catchError:error
</code></pre> 
<h3><a id="114_Event_QueueMicrotask_Queue_1822"></a>11.4 异步-Event Queue和Microtask Queue</h3> 
<p><img src="https://images2.imgbox.com/3d/b4/5BlqT4kQ_o.png" alt="在这里插入图片描述" width="400"></p> 
<h3><a id="115__1825"></a>11.5 异步-任务调度</h3> 
<ul><li>使用Future类，可以将任务加入到Event Queue的队尾</li><li>使用scheduleMicrotask函数，将任务加入到Microtask Queue队尾<br> <img src="https://images2.imgbox.com/d1/f4/6tBRQqgD_o.png" alt="在这里插入图片描述" width="450"></li></ul> 
<h3><a id="116_new_Future_1830"></a>11.6 异步-new Future()</h3> 
<pre><code>import 'dart:async';

main() async {
  // Future
  testFuture();
}

//Future
void testFuture() {
  Future f = new Future(() =&gt; print("f1"));
  Future f1 = new Future(() =&gt; null); //7163524
//  Future f1 = new Future.delayed(Duration(seconds: 1) ,() =&gt; null);//7132465
  Future f2 = new Future(() =&gt; null);
  Future f3 = new Future(() =&gt; null);

  f3.then((_) =&gt; print("f2"));
  f2.then((_) {
    print("f3");
    new Future(() =&gt; print("f4"));
    f1.then((_) {
      print("f5");
    });
  });

  f1.then((m) {
    print("f6");
  });
  print("f7");
}
</code></pre> 
<p>打印：</p> 
<pre><code>f7
f1
f6
f3
f5
f2
f4
</code></pre> 
<h3><a id="117_scheduleMicrotask_1875"></a>11.7 异步-scheduleMicrotask()</h3> 
<pre><code>import 'dart:async';

main() async {
  //scheduleMicrotask
  testScheduleMicrotask();
}
//scheduleMicrotask
void testScheduleMicrotask() {
  //918346572
  scheduleMicrotask(() =&gt; print('s1'));

  new Future.delayed(new Duration(seconds: 1), () =&gt; print('s2'));

  new Future(() =&gt; print('s3')).then((_) {
    print('s4');
    scheduleMicrotask(() =&gt; print('s5'));
  }).then((_) =&gt; print('s6'));

  new Future(() =&gt; print('s10'))
      .then((_) =&gt; new Future(() =&gt; print('s11')))
      .then((_) =&gt; print('s12'));

  new Future(() =&gt; print('s7'));

  scheduleMicrotask(() =&gt; print('s8'));

  print('s9');
}
</code></pre> 
<p>打印：</p> 
<pre><code>s9
s1
s8
s3
s4
s6
s5
s10
s7
s11
s12
s2
</code></pre> 
<p><img src="https://images2.imgbox.com/11/2b/z2DbMUHn_o.png" alt="在这里插入图片描述" width="500"></p> 
<center>
  顺序图 
</center> 
<br> 
<hr> 
<h2><a id="12__1933"></a>12 生成器</h2> 
<h3><a id="121___1934"></a>12.1 生成器-同步生成器</h3> 
<pre><code>void main(){
  //同步生成器
  //调用getSyncGenerator立即返回Iterable
  var it = getSyncGenerator(5).iterator;
  //  调用moveNext方法时getSyncGenerator才开始执行
  while (it.moveNext()) {
    print(it.current);
  }
}

//同步生成器： 使用sync*，返回的是Iterable对象
Iterable&lt;int&gt; getSyncGenerator(int n) sync* {
  print('start');
  int k = n;
  while (k &gt; 0) {
    //yield会返回moveNext为true,并等待 moveNext 指令
    yield k--;
  }
  print('end');
}
</code></pre> 
<p>打印：</p> 
<pre><code>start
5
4
3
2
1
end
</code></pre> 
<h3><a id="122__1971"></a>12.2 生成器-异步生成器</h3> 
<p>1：</p> 
<pre><code>void main(){
  //异步生成器
  //调用getAsyncGenerator立即返回Stream,只有执行了listen，函数才会开始执行
  //getAsyncGenerator(5).listen((value) =&gt; print(value));
  StreamSubscription subscription = getAsyncGenerator(5).listen(null);
  subscription.onData((value) {
    print(value);
  });
}

//异步生成器： 使用async*，返回的是Stream对象
Stream&lt;int&gt; getAsyncGenerator(int n) async* {
  print('start');
  int k = 0;
  while (k &lt; n) {
    //yield不用暂停，数据以流的方式一次性推送,通过StreamSubscription进行控制
    yield k++;
  }
  print('end');
}
</code></pre> 
<p>打印：</p> 
<pre><code>start
0
1
2
3
4
end
</code></pre> 
<hr> 
<p>2 :</p> 
<pre><code>import 'dart:async';

void main(){
  //异步生成器
  //调用getAsyncGenerator立即返回Stream,只有执行了listen，函数才会开始执行
  StreamSubscription subscription = getAsyncGenerator(5).listen(null);
  subscription.onData((value) {
    print(value);
    if (value &gt;= 2) {
      subscription.pause(); //可以使用StreamSubscription对象对数据流进行控制
    }
  });
}

//异步生成器： 使用async*，返回的是Stream对象
Stream&lt;int&gt; getAsyncGenerator(int n) async* {
  print('start');
  int k = 0;
  while (k &lt; n) {
    //yield不用暂停，数据以流的方式一次性推送,通过StreamSubscription进行控制
    yield k++;
  }
  print('end');
}
</code></pre> 
<p>打印：</p> 
<pre><code>start
0
1
2
</code></pre> 
<h3><a id="123__2044"></a>12.3 生成器-递归生成器</h3> 
<pre><code>import 'dart:async';

void main(){
  //递归生成器
  //同步
  var it1 = getSyncRecursiveGenerator(5).iterator;
  while (it1.moveNext()) {
    print(it1.current);
  }
  //异步
  getAsyncRecursiveGenerator(5).listen((value) =&gt; print(value));
}

//递归生成器：使用yield*
Iterable&lt;int&gt; getSyncRecursiveGenerator(int n) sync* {
  if (n &gt; 0) {
    yield n;
    yield* getSyncRecursiveGenerator(n - 1);
  }
}

//异步递归生成器
Stream&lt;int&gt; getAsyncRecursiveGenerator(int n) async* {
  if (n &gt; 0) {
    yield n;
    yield* getAsyncRecursiveGenerator(n - 1);
  }
}
</code></pre> 
<hr> 
<h2><a id="13_Isolates_2078"></a>13 隔离-Isolates</h2> 
<ul><li>所有Dart代码都在隔离区内运行，而不是线程。每个隔离区都有自己的内存堆，确保不会从任何其他隔离区访问隔离区的状态。</li></ul> 
<hr> 
<h2><a id="14__2083"></a>14 元数据(注解)</h2> 
<h3><a id="141_deprecated_2084"></a>14.1 元数据(注解)-@deprecated</h3> 
<pre><code>main() {
  dynamic tv = new Television();
  tv.activate();
  tv.turnOn();
}

class Television {
  @deprecated
  void activate() {
    turnOn();
  }

  void turnOn() {
    print('Television turn on!');
  }
}
</code></pre> 
<h3><a id="142_override_2105"></a>14.2 元数据(注解)-@override</h3> 
<pre><code>main() {
  dynamic tv = new Television();
  tv.activate();
  tv.turnOn();
  tv.turnOff();
}

class Television {
  @deprecated
  void activate() {
    turnOn();
  }
  
  void turnOn() {
    print('Television turn on!');
  }
  @override
  noSuchMethod(Invocation mirror) {
    print('没有找到方法');
  }
}
</code></pre> 
<h3><a id="143__2130"></a>14.3 元数据(注解)-自定义</h3> 
<pre><code>//todo.dart

class Todo {
  final String who;
  final String what;

  const Todo({this.who, this.what});
}
</code></pre> 
<pre><code>import 'todo.dart’;

main() {
  dynamic tv = new Television();
  tv.doSomething();
}

class Television {
  @Todo(who: 'damon', what: 'create a new method')
  void doSomething() {
    print('doSomething');
  }
}
</code></pre> 
<hr> 
<h2><a id="15__2160"></a>15 注释</h2> 
<h3><a id="151__2161"></a>15.1 注释-单行注释</h3> 
<p>单行注释以//开头。Dart编译器会忽略//和行尾之间的所有内容。</p> 
<pre><code>// 这是单行注释
</code></pre> 
<h3><a id="152__2168"></a>15.2 注释-多行注释</h3> 
<ul><li>多行注释以/<em>开头，以</em>/结尾。介于/*和 */两者之间的内容会被编译器忽略（除非该注释是一个文档注释）。</li><li>多行注释可以嵌套。</li></ul> 
<pre><code>/*
 * 这是多行注释
 * 这是多行注释 
 */
</code></pre> 
<h3><a id="153__2178"></a>15.3 注释-文档注释</h3> 
<ul><li>文档注释以///或者/**开头。</li><li>可以通过dartdoc命令导出文档。</li></ul> 
<pre><code>/// 这是文档注释

/**
  * 这是文档注释
  */
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7b495720e75a8f2490ed82bebc0f4afb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">qss样式表之QComboBox</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3ee04162b08af4196c51747c4ee28e11/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ubuntu boot修复</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>