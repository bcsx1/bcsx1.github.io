<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue.js3.0 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue.js3.0" />
<meta property="og:description" content="Vue.js 3.0 javaScript 相关 Symbol() 是 JavaScript 中的一个原始数据类型，用于创建唯一的、不可变的值。 安装npm install @vue/cli -g 本地node安装vue 工具用于创建项目 命令行输入 vue ui ，根据网址在线创建 ​基础语法 ​语法 1、取值双大括号 {{}} 生命周期 ​组合式API 创建应用 import { createApp } from ‘vue’ ​​import { createApp } from “vue”; import App from “./App.vue”; const app = createApp(App); 挂载 其他组件 router 、store app.use(router).use(store); //最后 app.mount(“#el”); .mount() 方法应该始终在整个应用配置和资源注册完成后被调用。同时请注意，不同于其他资源注册方法，它的返回值是根组件实例而非应用实例。 ​数据和方法 ​function/箭头函数 ​使用箭头函数定义方法时并不会创建函数作用域，因此this也不会指向其父级实例，此时的this会向上追踪。当找到某个函数作用域时，this将指向该函数的父级实例；否则，this将指向浏览器的内置对象Windows。 ​watch更注重于处理数据变化时的业务逻辑，而computed更注重于衍生数据 ​DOM渲染 ​选项优先级 ​选项的优先级 el、template、render三个选项的功能是一致的——获取实例模板（指定或是创建）。然而，当实例同时存在这三个选项时，Vue将如何处理呢？ render&gt;template&gt;el ​封装复用 计算属性 创建一个只读的计算属性 ref： const count = ref(1)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/a427bbd563dd25f8cac50d46a77261da/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-22T07:53:35+08:00" />
<meta property="article:modified_time" content="2023-06-22T07:53:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue.js3.0</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Vuejs_30_0"></a>Vue.js 3.0</h2> 
<h3><a id="javaScript__2"></a>javaScript 相关</h3> 
<h4><a id="Symbol__JavaScript__5"></a>Symbol() 是 JavaScript 中的一个原始数据类型，用于创建唯一的、不可变的值。</h4> 
<h3><a id="npm_install_vuecli_g_8"></a>安装npm install @vue/cli -g</h3> 
<h4><a id="nodevue__11"></a>本地node安装vue 工具用于创建项目</h4> 
<h5><a id="_vue_ui__14"></a>命令行输入 vue ui ，根据网址在线创建</h5> 
<h3><a id="_17"></a>​基础语法</h3> 
<h4><a id="_19"></a>​语法</h4> 
<h5><a id="1__21"></a>1、取值双大括号 {<!-- -->{}}</h5> 
<h5><a id="_23"></a>生命周期</h5> 
<h6><a id="_26"></a></h6> 
<h4><a id="API_28"></a>​组合式API</h4> 
<h5><a id="_31"></a>创建应用</h5> 
<h6><a id="import__createApp__from_vue_34"></a>import { createApp } from ‘vue’</h6> 
<h6><a id="import__createApp__from_vue_import_App_from_Appvue_const_app__createAppApp__%C2%A0_router_store_appuserouterusestore__appmountel_37"></a>​​import { createApp } from “vue”; import App from “./App.vue”; const app = createApp(App); 挂载 其他组件  router 、store app.use(router).use(store); //最后 app.mount(“#el”);</h6> 
<h6><a id="mount__39"></a>.mount() 方法应该始终在整个应用配置和资源注册完成后被调用。同时请注意，不同于其他资源注册方法，它的返回值是根组件实例而非应用实例。</h6> 
<h5><a id="_41"></a>​数据和方法</h5> 
<h6><a id="function_43"></a>​function/箭头函数</h6> 
<h6><a id="thisthisthisthisWindows_45"></a>​使用箭头函数定义方法时并不会创建函数作用域，因此this也不会指向其父级实例，此时的this会向上追踪。当找到某个函数作用域时，this将指向该函数的父级实例；否则，this将指向浏览器的内置对象Windows。</h6> 
<h5><a id="watchcomputed_47"></a>​watch更注重于处理数据变化时的业务逻辑，而computed更注重于衍生数据</h5> 
<h5><a id="DOM_49"></a>​DOM渲染</h5> 
<h6><a id="_51"></a>​选项优先级</h6> 
<h6><a id="%C2%A0eltemplaterenderVue_rendertemplateel_53"></a>​选项的优先级 el、template、render三个选项的功能是一致的——获取实例模板（指定或是创建）。然而，当实例同时存在这三个选项时，Vue将如何处理呢？ render&gt;template&gt;el</h6> 
<h5><a id="_55"></a>​封装复用</h5> 
<h5><a id="_57"></a>计算属性</h5> 
<h6><a id="_ref_60"></a>创建一个只读的计算属性 ref：</h6> 
<p>const count = ref(1)<br> const plusOne = computed(() =&gt; count.value + 1)</p> 
<p>console.log(plusOne.value) // 2</p> 
<p>plusOne.value++ // 错误</p> 
<h6><a id="_ref_70"></a>创建一个可写的计算属性 ref：</h6> 
<p>const count = ref(1)<br> const plusOne = computed({<!-- --><br> get: () =&gt; count.value + 1,<br> set: (val) =&gt; {<!-- --><br> count.value = val - 1<br> }<br> })</p> 
<p>plusOne.value = 1<br> console.log(count.value) // 0</p> 
<h5><a id="_84"></a>侦听器</h5> 
<h6><a id="_87"></a>侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。</h6> 
<p>watch 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组<br> 你不能直接侦听响应式对象的属性值 ，因为属性值不为响应式监听，使用getter函数方式可以</p> 
<h6><a id="const_x__ref0_94"></a>const x = ref(0)</h6> 
<p>const y = ref(0)</p> 
<p>// 单个 ref<br> watch(x, (newX) =&gt; {<!-- --><br> console.log(<code>x is ${newX}</code>)<br> })</p> 
<p>// getter 函数<br> watch(<br> () =&gt; x.value + y.value,<br> (sum) =&gt; {<!-- --><br> console.log(<code>sum of x + y is: ${sum}</code>)<br> }<br> )</p> 
<p>// 多个来源组成的数组<br> watch([x, () =&gt; y.value], ([newX, newY]) =&gt; {<!-- --><br> console.log(<code>x is ${newX} and y is ${newY}</code>)<br> })</p> 
<h6><a id="watch_watch__117"></a>watch 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。watch 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。</h6> 
<p>watchEffect，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确</p> 
<h6><a id="watchEffect_122"></a>watchEffect</h6> 
<p>对于这种只有一个依赖项的例子来说，watchEffect() 的好处相对较小。但是对于有多个依赖项的侦听器来说，使用 watchEffect() 可以消除手动维护依赖列表的负担。此外，如果你需要侦听一个嵌套数据结构中的几个属性，watchEffect() 可能会比深度侦听器更有效，因为它将只跟踪回调中被使用到的属性，而不是递归地跟踪所有的属性。</p> 
<h6><a id="_127"></a></h6> 
<p>const todoId = ref(1)<br> const data = ref(null)</p> 
<p>watch(todoId, async () =&gt; {<!-- --><br> const response = await fetch(<br> <code>https://jsonplaceholder.typicode.com/todos/${todoId.value}</code><br> )<br> data.value = await response.json()<br> }, { immediate: true })</p> 
<p>简化<br> watchEffect(async () =&gt; {<!-- --><br> const response = await fetch(<br> <code>https://jsonplaceholder.typicode.com/todos/${todoId.value}</code><br> )<br> data.value = await response.json()<br> })</p> 
<h5><a id="_147"></a>修饰符</h5> 
<h6><a id="lazy_150"></a>.lazy</h6> 
<h6><a id="vmodel__input__IME__lazy__change__153"></a>默认情况下，v-model 会在每次 input 事件后更新数据 (IME 拼字阶段的状态例外)。你可以添加 lazy 修饰符来改为在每次 change 事件后更新数据</h6> 
 
<h6><a id="number_159"></a>.number</h6> 
<h6><a id="_vmodel__number_input_vmodelnumberage__162"></a>如果你想让用户输入自动转换为数字，你可以在 v-model 后添加 .number 修饰符来管理输入</h6> 
<p>如果该值无法被 parseFloat() 处理，那么将返回原始值。</p> 
<p>number 修饰符会在输入框有 type=“number” 时自动启用。</p> 
<h6><a id="trim_168"></a>.trim</h6> 
<h6><a id="_vmodel__trim_input_vmodeltrimmsg__171"></a>如果你想要默认自动去除用户输入内容中两端的空格，你可以在 v-model 后添加 .trim 修饰符：</h6> 
<h6><a id="prevent_174"></a>.prevent</h6> 
<h6><a id="prevent_177"></a>.prevent修饰符可以用于阻止元素的默认行为，例如防止表单提交或链接页面跳转时重新加载页面。</h6> 
<p>当使用@click.prevent修饰符时，点击事件将不会触发默认行为（例如将链接打开或提交表单），而只会执行绑定的方法。<br> 点击按钮将调用submitForm方法来提交表单，而不会触发按钮的默认行为，即重新加载页面</p> 
<h6><a id="_passivecapture__once_183"></a>事件修饰符 .passive、.capture 和 .once</h6> 
<h4><a id="Prop__186"></a>Prop 逐级透传问题，定义全局参数</h4> 
<h5><a id="provide__inject__1__189"></a>provide 和 inject 可以帮助我们解决这一问题。 [1] 一个父组件相对于其所有的后代组件，会作为依赖提供者。任何后代的组件树，无论层级有多深，都可以注入由父组件提供给整条链路的依赖。</h5> 
<h6><a id="__keyvalue_194"></a>父组件提供者 提供key,value</h6> 
<p>，提供的响应式状态使后代组件可以由此和提供者建立响应式的联系。<br> import { ref, provide } from ‘vue’</p> 
<h3><a id="const_count__ref0%0Aprovidekey_count_198"></a>const count = ref(0)<br> provide(‘key’, count)</h3> 
<p>Provide​除了在一个组件中提供依赖，我们还可以在整个应用层面提供依赖：<br> import { createApp } from ‘vue’<br> const app = createApp({})<br> app.provide(/* 注入名 <em>/ ‘message’, /</em> 值 */ ‘hello!’)<br> 在应用级别提供的数据在该应用内的所有组件中都可以注入。这在你编写插件时会特别有用，因为插件一般都不会使用组件形式来提供值。</p> 
<h6><a id="script_setup_209"></a></h6> 
<p>import { inject } from ‘vue’</p> 
<p>const message = inject(‘message’,‘这是默认值’)<br> </p> 
<h6><a id="___217"></a>当提供 / 注入响应式的数据时，建议尽可能将任何对响应式状态的变更都保持在供给方组件中。这样可以确保所提供状态的声明和变更操作都内聚在同一个组件内，使其更容易维护。</h6> 
<p>有的时候，我们可能需要在注入方组件中更改数据。在这种情况下，我们推荐在供给方组件内声明并提供一个更改数据的方法函数</p> 
<h5><a id="___222"></a> 
 </h5> 
<h6><a id="___240"></a> 
 </h6> 
<h4><a id="_253"></a>响应性</h4> 
<h5><a id="import__toRefs_toRef__from_vue_256"></a>import { toRefs, toRef } from ‘vue’</h5> 
<p>export default {<!-- --><br> setup(props) {<!-- --><br> // 将 <code>props</code> 转为一个其中全是 ref 的对象，然后解构<br> const { title } = toRefs(props)<br> // <code>title</code> 是一个追踪着 <code>props.title</code> 的 ref<br> console.log(title.value)</p> 
<pre><code>// 或者，将 `props` 的单个属性转为一个 ref
const title = toRef(props, 'title')
</code></pre> 
<p>}<br> }</p> 
<h5><a id="_272"></a>深层响应性</h5> 
<h6><a id="reactive_275"></a>reactive</h6> 
<h6><a id="import__reactive__from_vue_278"></a>import { reactive } from ‘vue’</h6> 
<p>const obj = reactive({<!-- --><br> nested: { count: 0 },<br> arr: [‘foo’, ‘bar’]<br> })</p> 
<p>function mutateDeeply() {<!-- --><br> // 以下都会按照期望工作<br> obj.nested.count++<br> obj.arr.push(‘baz’)<br> }</p> 
<ul><li> <p>shallowReactive()是 reactive() 的浅层作用形式</p> </li><li> <p>reactive() 返回的是一个原始对象的 Proxy，它和原始对象是不相等的</p> </li><li> <p>reactive() API 有两条限制：</p> </li></ul> 
<p>仅对对象类型有效（对象、数组和 Map、Set 这样的集合类型），而对 string、number 和 boolean 这样的 原始类型 无效。</p> 
<p>因为 Vue 的响应式系统是通过属性访问进行追踪的，因此我们必须始终保持对该响应式对象的相同引用。这意味着我们不可以随意地“替换”一个响应式对象，因为这将导致对初始引用的响应性连接丢失：</p> 
<ul><li> <p>reactive() 的种种限制归根结底是因为 JavaScript 没有可以作用于所有值类型的 “引用” 机制。</p> </li><li> <p>TIP 不推荐使用 reactive() 的泛型参数，因为处理了深层次 ref 解包的返回值与泛型参数的类型不同。</p> </li></ul> 
<h6><a id="toRefs_312"></a>toRefs()</h6> 
<ul><li>将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 toRef() 创建的。</li></ul> 
<h6><a id="toRef_317"></a>toRef()</h6> 
<ul><li>基于响应式对象上的一个属性，创建一个对应的 ref。这样创建的 ref 与其源属性保持同步：改变源属性的值将更新 ref 的值，反之亦然</li></ul> 
<h6><a id="ref_323"></a>ref</h6> 
<h6><a id="Vue__ref__326"></a>Vue 提供了一个 ref() 方法来</h6> 
<p>允许我们创建可以使用<br> 任何值类型的响应式 ref</p> 
<ul><li>import { ref } from ‘vue’</li></ul> 
<p>const count = ref(0)</p> 
<h6><a id="ref__value__ref__337"></a>ref() 将传入参数的值包装为一个带 .value 属性的 ref 对象</h6> 
<h6><a id="ref__value__reactive__value_340"></a>和响应式对象的属性类似，ref 的 .value 属性也是响应式的。同时，当值为对象类型时，会用 reactive() 自动转换它的 .value</h6> 
<ul><li>const objectRef = ref({ count: 0 })</li></ul> 
<p>// 这是响应式的替换<br> objectRef.value = { count: 1 }</p> 
<ul><li>ref() 让我们能创造一种对任意值的 “引用”，并能够在不丢失响应性的前提下传递这些引用。这个功能很重要，因为它经常用于将逻辑提取到 组合函数 中</li></ul> 
<h6><a id="ef__353"></a>ef 在模板中的解包​</h6> 
<p>当 ref 在模板中作为顶层属性被访问时，它们会被自动“解包”，所以不需要使用 .value</p> 
<ul><li> <p>当一个 ref 被嵌套在一个响应式对象中，作为属性被访问或更改时，它会自动解包，因此会表现得和一般的属性一样</p> </li><li> <p>只有当嵌套在一个深层响应式对象内时，才会发生 ref 解包。当其作为浅层响应式对象的属性被访问时不会解包。</p> </li></ul> 
<h6><a id="toRow_363"></a>toRow</h6> 
<h6><a id="const_foo___366"></a>const foo = {}</h6> 
<p>const reactiveFoo = reactive(foo)</p> 
<p>console.log(toRaw(reactiveFoo) === foo) // true</p> 
<ul><li>这是一个可以用于临时读取而不引起代理访问/跟踪开销，或是写入而不触发更改的特殊方法。不建议保存对原始对象的持久引用，请谨慎使用</li></ul> 
<h4><a id="_376"></a>单文件组件</h4> 
<h5><a id="1TodoList_379"></a>1、组件名应该采用单词大写开头的驼峰命名法，例如"TodoList"。</h5> 
<p>2、组件应该在一个单独的文件中进行定义，文件名应该与组件名相同，并以.vue为后缀。</p> 
<h6><a id="_Vue__Vue__JavaScript__383"></a>当不使用构建步骤时，一个 Vue 组件以一个包含 Vue 特定选项的 JavaScript 对象来定义：</h6> 
<p>import { ref } from ‘vue’</p> 
<p>export default {<!-- --><br> setup() {<!-- --><br> const count = ref(0)<br> return { count }<br> },<br> template: <code> &lt;button @click="count++"&gt; You clicked me {<!-- -->{ count }} times. &lt;/button&gt;</code><br> // 或者 <code>template: '#my-template-element'</code><br> }</p> 
<h6><a id="_Vue__vue___SFC_400"></a>当使用构建步骤时，我们一般会将 Vue 组件定义在一个单独的 .vue 文件中，这被叫做单文件组件 (简称 SFC)：</h6> 
<h5><a id="defineProps__script_setup__props_defineProps__props_413"></a>defineProps 是一个仅 </h5> 
<p>const props = defineProps([‘title’])<br> console.log(props.title)</p> 
<h5><a id="_props_419"></a>传递 props，</h5> 
<p>接收任意类型的 JavaScript 值作为 props</p> 
<h6><a id="_script_setupprops__props_props__setup__423"></a>如果你没有使用 </h6> 
<p>export default {<!-- --><br> props: [‘title’],<br> setup(props) {<!-- --><br> console.log(props.title)<br> }<br> }</p> 
<h5><a id="defineProps__defineEmits_433"></a>defineProps() 和 defineEmits()</h5> 
<h6><a id="script_setup_436"></a></h6> 
<p>const props = defineProps({<!-- --><br> foo: String<br> })</p> 
<p>const emit = defineEmits([‘change’, ‘delete’])<br> // setup 代码<br> </p> 
<h6><a id="BlogPost_447"></a>&lt;BlogPost</h6> 
<p>…<br> @enlarge-text=“postFontSize += 0.1”<br> /&gt;</p> 
<h6><a id="_emit__454"></a>子组件可以通过调用内置的 $emit 方法，通过传入事件名称来抛出一个事件：</h6> 
<p>vue</p> 
 
<div class="blog-post"> 
 <h5>{<!-- -->{ title }}</h5> 
</div> 
<h6><a id="defineEmits__script_setup__emit__emit__script_setup__emit_466"></a>defineEmits 仅可用于 </h6> 
<ul><li>export default defineComponent({<!-- --><br> emits: [‘update:value’],</li></ul> 
<p>props: {<!-- --><br> value: {<!-- --><br> type: String,<br> required: true<br> }<br> },</p> 
<p>setup(props, { emit }) {<!-- --><br> function onInput(event) {<!-- --><br> emit(‘update:value’, event.target.value);<br> }</p> 
<pre><code>return {
  onInput
};
</code></pre> 
<p>}<br> });</p> 
<h5><a id="_497"></a>插槽，组件要接收模板内容</h5> 
<p>为子组件传递一些模板片段，让子组件在它们的组件中渲染这些片段。</p> 
<h6><a id="_501"></a>实例</h6> 
<h6><a id="FancyButton_504"></a></h6> 
<p>Click me! 
 <br> </p> 
<ul><li> </li></ul> 
<p> 
 <br> </p> 
<pre><code>  * 
</code></pre> 
<h6><a id="_519"></a>渲染作用域</h6> 
<h6><a id="_522"></a>插槽内容可以访问到父组件的数据作用域，因为插槽内容本身是在父组件模板中定义的</h6> 
<p>插槽内容无法访问子组件的数据。Vue 模板中的表达式只能访问其定义时所处的作用域，这和 JavaScript 的词法作用域规则是一致的。换言之：</p> 
<p>父组件模板中的表达式只能访问父组件的作用域；子组件模板中的表达式只能访问子组件的作用域。</p> 
<h6><a id="_528"></a>默认内容</h6> 
<h6><a id="button_typesubmit_531"></a></h6> Submit 
 
<h6><a id="_539"></a>具名插槽</h6> 
<h6><a id="name_542"></a>插槽带有name名称</h6> 
<div class="container"> 
 <header> 
 </header> 
 <footer> 
 </footer> 
</div> 
<ul><li>使用时指定,v-slot 有对应的简写 #<br> <br> </li></ul> 
<pre><code>&lt;!-- header 插槽的内容放这里 --&gt;
</code></pre> 
<pre><code>  * &lt;BaseLayout&gt;
</code></pre> 
<p>&lt;template #header&gt;<br> </p> 
<h2>Here might be a page title</h2> 
<br> 
<p></p> 
<p>&lt;template #default&gt;<br> </p> 
<p>A paragraph for the main content.</p> 
<br> 
<p>And another one.</p> 
<br> 
<p>&lt;template #footer&gt;<br> </p> 
<p>Here’s some contact info</p> 
<br> 
<br> 
<pre><code>  * &lt;BaseLayout&gt;
</code></pre> 
<p>&lt;template #header&gt;<br> </p> 
<h2>Here might be a page title</h2> 
<br> 
<p></p> 
 
<p>A paragraph for the main content.</p> 
<p>And another one.</p> 
<p>&lt;template #footer&gt;<br> </p> 
<p>Here’s some contact info</p> 
<br> 
<br> 
<h6><a id="_599"></a>在某些场景下插槽的内容可能想要同时使用父组件域内和子组件域内的数据。要做到这一点，我们需要一种方法来让子组件在渲染时将一部分数据提供给插槽。</h6> 
<p>我们也确实有办法这么做！可以像对组件传递 props 那样，向一个插槽的出口上传递 attributes：</p> 
<p>template</p> 
 
<div> 
</div> 
<h3><a id="_vuerouter_610"></a>​路由 vue-router</h3> 
<h4><a id="_612"></a></h4> 
<h5><a id="_npm_install_vuerouter_save_614"></a>​安装 npm install vue-router --save</h5> 
<h6><a id="VueRouterhashhistoryhash_616"></a>​Vue-Router有两种模式：hash模式和history模式。默认的路由模式是hash模式。</h6> 
<h6><a id="import__createRouter_createWebHistory__from_vuerouter_const_routes____%C2%A0%C2%A0path_userinfo_%C2%A0%C2%A0name_UserInfo_redirect_home_%C2%A0%C2%A0component___importviewsUserInfovue_meta__name_why_age_18_height_188__props_true__const_router__createRouter_%C2%A0%C2%A0history_createWebHistoryprocessenvBASE_URL_%C2%A0%C2%A0routes__export_default_router_618"></a>import { createRouter, createWebHistory } from ‘vue-router’ const routes = [ {   path: ‘/userinfo’,   name: ‘UserInfo’, redirect: “/home”,   component: () =&gt; import(‘…/views/UserInfo.vue’), meta: { name: “why”, age: 18, height: 1.88 }, props: true }] const router = createRouter({   history: createWebHistory(process.env.BASE_URL),   routes }) export default router</h6> 
<h6><a id="import__createRouter_createWebHashHistory__from_vuerouter_const_routes___path_userinfo_name_UserInfo_component___importviewsUserInfovue__const_router__createRouter_history_createWebHashHistory_routes__export_default_router_620"></a>​import { createRouter, createWebHashHistory } from ‘vue-router’ const routes = [{ path: ‘/userinfo’, name: ‘UserInfo’, component: () =&gt; import(‘…/views/UserInfo.vue’) }] const router = createRouter({ history: createWebHashHistory(), routes }) export default router</h6> 
<h6><a id="_route__URL_props___props__true_routeparams__props__props_components__default_User_sidebar_Sidebar__props__default_true_sidebar_false__622"></a>在你的组件中使用 $route 会与路由紧密耦合，这限制了组件的灵活性，因为它只能用于特定的 URL。虽然这不一定是件坏事，但我们可以通过 props 配置来解除这种行为​ 当 props 设置为 true 时，route.params 将被设置为组件的 props 对于有命名视图的路由，你必须为每个命名视图定义 props components: { default: User, sidebar: Sidebar }, props: { default: true, sidebar: false }</h6> 
<h6><a id="appuserouter_624"></a>​app.use(router)</h6> 
<h4><a id="_626"></a>​核心概念</h4> 
<h5><a id="_628"></a>​导航守卫</h5> 
<h6><a id="_630"></a>​全局前置</h6> 
<h6><a id="onst_router__createRouter___routerbeforeEachto_from_______false__return_false__632"></a>​onst router = createRouter({ … }) router.beforeEach((to, from) =&gt; { // … // 返回 false 以取消导航 return false })</h6> 
<ul><li> <p>​可用于登录验证</p> 
  <ul><li>​/** * 返回值问题: * 1.false: 不进行导航 * 2.undefined或者不写返回值: 进行默认导航 * 3.字符串: 路径, 跳转到对应的路径中 * 4.对象: 类似于 router.push({path: “/login”, query: …}) */ router.beforeEach((to, from) =&gt; { console.log(<code>进行了${++counter}路由跳转</code>) // if (to.path.indexOf(“/home”) !== -1) { // return “/login” // } if (to.path !== “/login”) { const token = window.localStorage.getItem(“token”); if (!token) { return “/login” } }</li></ul> </li></ul> 
<h6><a id="_638"></a>​路由独享的守卫</h6> 
<h6><a id="const_routes____path_usersid_component_UserDetails_beforeEnter_to_from____reject_the_navigation_return_false____640"></a>​const routes = [ { path: ‘/users/:id’, component: UserDetails, beforeEnter: (to, from) =&gt; { // reject the navigation return false }, }, ]</h6> 
<h6><a id="_642"></a>​组件内的守卫</h6> 
<h5><a id="_644"></a>​动态路由</h5> 
<h6><a id="__646"></a>// 添加路由</h6> 
<p>router.addRoute({ path: ‘/about’, component: About }) 添加后不会调转，需要调用调转 push,replace<br> // 我们也可以使用 this.$route<br> 或 route = useRoute() （在 setup 中） router.replace(router.currentRoute.value.fullPath)<br> // 删除路由<br> router.removeRoute(‘about’)​ router.hasRoute()：检查路由是否存在。<br> router.getRoutes()：获取一个包含所有路由记录的数组。</p> 
<h6><a id="_655"></a>父子路由，在子路由前不加‘/’,编译器会自动添加</h6> 
<h5><a id="_658"></a>​命名视图</h5> 
<h6><a id="routerview_classview_leftsidebar_nameLeftSidebarrouterview_routerview_classview_maincontentrouterview_routerview_classview_rightsidebar_nameRightSidebarrouterview_660"></a>​ </h6> 
<h6><a id="_components___s_const_router__createRouter_history_createWebHashHistory_routes___path__components__default_Home__LeftSidebar_LeftSidebar__LeftSidebar___routerview__name__RightSidebar_____662"></a>​一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置 (带上 s)： const router = createRouter({ history: createWebHashHistory(), routes: [ { path: ‘/’, components: { default: Home, // LeftSidebar: LeftSidebar 的缩写 LeftSidebar, // 它们与 <code>&lt;router-view&gt;</code> 上的 <code>name</code> 属性匹配 RightSidebar, }, }, ], })</h6> 
<h4><a id="_664"></a>使用</h4> 
<h5><a id="push__entry_URL_thisrouterpush_thisrouterpush_nameabout_params_id1______routerlink_tohomeHomerouterlink____a_hrefhomeHomea___vbind__JS___routerlink_tohomeHomerouterlink____routerlink_to_path_home_Homerouterlink____routerlink_to_name_user_params__userId_123_Userrouterlink___registerplanprivate__routerlink_to_path_register_query__plan_private__Register_routerlink__routerview_classview_leftsidebar_nameLeftSidebarrouterview_routerview_classview_maincontentrouterview_routerview_classview_rightsidebar_nameRightSidebarrouterview_666"></a>push# 通过在历史堆栈中推送一个 entry，以编程方式导航到一个新的 URL。 this.<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         r 
        
       
         o 
        
       
         u 
        
       
         t 
        
       
         e 
        
       
         r 
        
       
         . 
        
       
         p 
        
       
         u 
        
       
         s 
        
       
         h 
        
       
         ( 
        
       
         ‘路由地址’ 
        
       
         ) 
        
       
         t 
        
       
         h 
        
       
         i 
        
       
         s 
        
       
         . 
        
       
      
        router.push(‘路由地址’) this. 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0278em;">er</span><span class="mord">.</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord">‘</span><span class="mord cjk_fallback">路由地址</span><span class="mord">’</span><span class="mclose">)</span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span></span>router.push({ name:‘about’, params:{ id:1 } }) ​ 
  Home 
  <a href="/home" rel="nofollow">Home</a> 
  Home 
  Home 
  User 
  Register 命名视图 </h5> 
<h6><a id="_godelta_number_void__thisroutergo_forward__go1_const_router_useRouter_routerforward_routergo1_routerforward_routerback_routergo1_routerback_668"></a>​返回历史中的路由，前一页后一页 go(delta: number): void 允许你在历史中前进或后退。 this.$router.go() forward() == go(1) const router= useRouter() //向前移动一个记录，与router.forward()相同 router.go(1) router.forward() //返回一条记录，与router.back()相同 router.go(-1) router.back()</h6> 
<h5><a id="__thisrouteparams_%C2%A0thisroutequery_670"></a>​获取 链接参数 this.<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         r 
        
       
         o 
        
       
         u 
        
       
         t 
        
       
         e 
        
       
         . 
        
       
         p 
        
       
         a 
        
       
         r 
        
       
         a 
        
       
         m 
        
       
         s 
        
       
           
        
       
         t 
        
       
         h 
        
       
         i 
        
       
         s 
        
       
         . 
        
       
      
        route.params  this. 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord">.</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">am</span><span class="mord mathnormal">s</span><span class="mord"> </span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span></span>route.query</h5> 
<h5><a id="_672"></a>父子路由</h5> 
<h6><a id="export_default_new_VueRouter_675"></a>export default new VueRouter({<!-- --></h6> 
<pre><code>routes:[
    {
        //第一组路由规则
        path:'/home',
        component:Home
        children:[//为什么是数组形式?因为可能有多个子路由
            {
                path:'news',//这里的路径就不要加'/'了,因为底层给你遍历这一堆规则的时候人家已经给你加上'/'了
                component:News,
            }
        ]
    },
]
</code></pre> 
<p>})</p> 
<h6><a id="_693"></a>反例</h6> 
<ul><li> <p>News<br> Message<br> </p> 
  <ul><li>点击news路径变成了:</li></ul> </li></ul> 
<p>http://localhost:8080/#/news<br> 1<br> 为什么?</p> 
<p>因为没有对应规则;刚才的路径/home变成了/news是一种路径的改变</p> 
<p>路径改变了，前端路由器就监测到了，然后路由器拿着你的/news回到路由规则(router &gt; index.js)里面进行匹配(在routes里面问)对比完毕没有对的上的，所以页面什么都不成现</p> 
<h6><a id="_715"></a>正例</h6> 
<ul><li> <p>News<br> Message<br> </p> 
  <ul><li>子主题1</li></ul> </li></ul> 
<h3><a id="_vuexPinia_726"></a>​状态管理 vuex&amp;&amp;Pinia</h3> 
<h4><a id="Pinpa_729"></a>Pinpa</h4> 
<h5><a id="%C2%A0_npm_install_pinia%C2%A0%C2%A0save_731"></a>​安装  npm install pinia  --save</h5> 
<h6><a id="%C2%A0_createPinia_733"></a>包名  ​createPinia</h6> 
<h6><a id="import__createPinia__from_pinia_const_pinia__createPinia_appusepinia_735"></a>import { createPinia } from “pinia”; const pinia = createPinia(); app.use(pinia);</h6> 
<h5><a id="_737"></a>​核心</h5> 
<h6><a id="%C2%A0_defineStore_739"></a>​包名  defineStore</h6> 
<h6><a id="import__defineStore%C2%A0_from_pinia_741"></a>​import { defineStore}  from ‘pinia’</h6> 
<h6><a id="stateactions__getters_743"></a>​state、actions 与 getters</h6> 
<h6><a id="const%C2%A0_userStore__defineStoreuser_state____count_0__getters__%C2%A0_%C2%A0doubleCount_state__statecount__2__actions__%C2%A0_increment__%C2%A0_%C2%A0_thiscount_%C2%A0_%C2%A0async%C2%A0_%C2%A0randomizeCounter__%C2%A0_thisuserData__await_apipost_login_password_____745"></a>​const  userStore = defineStore(‘user’,{ state: () =&gt; ({ count: 0 }), getters: {    doubleCount: (state) =&gt; state.count * 2, }, actions: {   increment() {     this.count++  },  async   randomizeCounter() {   this.userData = await api.post({ login, password }) }, }, })</h6> 
<ul><li> <p>​Getter 完全等同于 store 的 state 的计算值。可以通过 defineStore() 中的 getters 属性来定义它们。推荐使用箭头函数，并且它将接收 state 作为第一个参数</p> </li><li> <p>​在使用常规函数定义 getter 时，我们也可以通过 this 访问到整个 store 实例，但(在 TypeScript 中)必须定义返回类型。这是为了避免 TypeScript 的已知缺陷，不过这不影响用箭头函数定义的 getter，也不会影响不使用 this 的 getter。</p> </li><li> <p>​Action 相当于组件中的 method。它们可以通过 defineStore() 中的 actions 属性来定义，并且它们也是定义业务逻辑的完美选择。也可通过 this 访问整个 store 实例</p> </li><li> <p>​不同的是，action 可以是异步的，你可以在它们里面 await 调用任何 API，以及其他 action！</p> </li></ul> 
<h6><a id="_755"></a>​使用</h6> 
<h6><a id="import__useUsersStore__from_srcstoreuser_const_store__useUsersStore_consolelogstore_757"></a>​import { useUsersStore } from “…/src/store/user”; const store = useUsersStore(); console.log(store);</h6> 
<ul><li>​也可以store中使用其他 store</li></ul> 
<h6><a id="_store_const_reset_____storereset__761"></a>​// 重置store const reset = () =&gt; { store.$reset(); };</h6> 
<h6><a id="import__storeToRefs__from_pinia_const_store__useUsersStore_const__name_age_sex___storeToRefsstore_763"></a>​import { storeToRefs } from ‘pinia’; const store = useUsersStore(); const { name, age, sex } = storeToRefs(store);</h6> 
<h4><a id="vuex_765"></a>​vuex</h4> 
<h5><a id="%C2%A0npm_install_vuexnext_save_767"></a>​安装 npm install vuex@next --save</h5> 
<h5><a id="_769"></a>​核心</h5> 
<h6><a id="statemutationsactionsgettersmodules_storestatedata_771"></a>​state、mutations、actions、getters、modules 提供唯一的公共数据源，所有共享的数据统一放到store的state进行储存，相似与data</h6> 
<h6><a id="import__createStore__from_vuex_export_default_createStore_state__info_hello__mutations___mutations_updateInfo_state_payload__stateinfo__payload___actions___actions__2_updateInfo_context_payload__setTimeout___contextcommitupdateInfo_payload__2000___ES2015__incrementAsync__commit___setTimeout___commitincrement__1000__async_actionB__dispatch_commit___await_dispatchactionA___actionA__commitgotOtherData_await_getOtherData___getters___getters_formatInfo_stategetters__return_stateinfo___Tom___modules____773"></a>​import { createStore } from ‘vuex’ export default createStore({ state: { info: ‘hello’ }, mutations: { // 定义mutations，用于修改状态(同步) updateInfo (state, payload) { state.info = payload } }, actions: { // 定义actions，用于修改状态(异步) // 2秒后更新状态 updateInfo (context, payload) { setTimeout(() =&gt; { context.commit(‘updateInfo’, payload) }, 2000) }, // 利用ES2015 的参数解构来简化代码 incrementAsync ({ commit }) { setTimeout(() =&gt; { commit(‘increment’) }, 1000) }, async actionB ({ dispatch, commit }) { await dispatch(‘actionA’) // 等待 actionA 完成 commit(‘gotOtherData’, await getOtherData()) } }, getters: { // 定义一个getters,有两个参数 formatInfo (state,getters) { return state.info + ’ Tom’ } }, modules: { } })</h6> 
<ul><li> <p>​getters</p> 
  <ul><li>​Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性） mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性： import { mapGetters } from ‘vuex’</li></ul> </li><li> <p>mutations</p> 
  <ul><li> <p>​Vuex 的 store 中的状态的唯一方法是提交 mutation，Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的事件类型 (type)和一个回调函数 (handler)。它会接受 state 作为第一个参数</p> </li><li> <p>​一条重要的原则就是要记住 mutation 必须是同步函数</p> </li></ul> </li><li> <p>​actions</p> 
  <ul><li> <p>​Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。</p> </li><li> <p>​Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters</p> </li><li> <p>​ES2015 的参数解构来简化代码（特别是我们需要调用 commit 很多次的时候）</p> </li></ul> </li></ul> 
<h6><a id="_793"></a>​使用</h6> 
<h6><a id="storecommitincrement_storecommitincrement_10__storecommit_type_increment_amount_10__795"></a>​store.commit(‘increment’) store.commit(‘increment’, 10) 或 store.commit({ type: ‘increment’, amount: 10 })</h6> 
<h6><a id="import__mapMutations__from_vuex_797"></a>​import { mapMutations } from ‘vuex’</h6> 
<h6><a id="Action__storedispatch__storedispatchincrement___storedispatchincrementAsync__amount_10____storedispatch_type_incrementAsync_amount_10__storedispatchactionAthen____799"></a>​Action 通过 store.dispatch 方法触发： store.dispatch(‘increment’) // 以载荷形式分发 store.dispatch(‘incrementAsync’, { amount: 10 }) // 以对象形式分发 store.dispatch({ type: ‘incrementAsync’, amount: 10 }) store.dispatch(‘actionA’).then(() =&gt; { })</h6> 
<h3><a id="_801"></a>用于在浏览器中</h3> 
<p>发起网络请求的工具</p> 
<h4><a id="_805"></a></h4> 
<p>Axios是一个基于Promise的HTTP客户端，可以用于发送HTTP请求并处理响应。它支持更多的浏览器，包括IE8及以上版本，并提供了更多的功能，如请求取消、拦截请求和响应等。同时，在错误处理和配置方面，Axios也比Fetch更加全面和灵活。</p> 
<h5><a id="axiosgethttpsapiexamplecomdata_810"></a>axios.get(‘https://api.example.com/data’)</h5> 
<p>.then(response =&gt; console.log(response.data))<br> .catch(error =&gt; console.error(error));</p> 
<p>axios.post(‘https://api.example.com/login’, {<!-- --><br> username: ‘example’,<br> password: ‘password’<br> })<br> .then(response =&gt; console.log(response.data))<br> .catch(error =&gt; console.error(error));</p> 
<h4><a id="FetchWeb_APIAPIPromiseFetchES6_822"></a>Fetch是Web API，是浏览器内置的API之一，使用Promise对象来处理异步请求和响应。Fetch支持ES6语法特性，并且比较轻量级，不需要任何第三方库或插件。</h4> 
<h5><a id="fetchhttpsapiexamplecomdata_825"></a>fetch(‘https://api.example.com/data’)</h5> 
<p>.then(response =&gt; response.json())<br> .then(data =&gt; console.log(data))<br> .catch(error =&gt; console.error(error));</p> 
<h3><a id="vue2_831"></a>响应式中与vue2的区别</h3> 
<h4><a id="_834"></a>机制不同</h4> 
<h5><a id="vue2ObjectdefinePropertyobj_title__837"></a>vue2中的代理方式为Object.defineProperty(obj, ‘title’, {<!-- --></h5> 
<p>get() {},<br> set() {},<br> })</p> 
<p>当项目里“读取 obj.title”和“修改 obj.title”的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。</p> 
<h5><a id="vue3_Proxy__API__845"></a>vue3采用 Proxy 这个 API 就是真正的代理</h5> 
<p>new Proxy(obj, {<!-- --><br> get() { },<br> set() { },<br> })<br> 需要注意的是，虽然 Proxy 拦截 obj 这个数据，但 obj 具体是什么属性，Proxy 则不关心，统一都拦截了。而且 Proxy 还可以监听更多的数据格式，比如 Set、Map，这是 Vue 2 做不到的。</p> 
<h6><a id="Proxy__Vue_3__IE11__854"></a>Proxy 存在一些兼容性问题，这也是为什么 Vue 3 不兼容 IE11 以下的浏览器的原因</h6>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9fdebe1fa5715b6f8fad4a1dbf615861/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在windows同时安装两个idea的方法教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ecc06b35395001cbb75cc6b1c4f41a51/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ChatGLM-6B tuning 推理源码解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>