<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vulkan Specification(Vulkan规范)：第十四章 14.6 内置变量 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vulkan Specification(Vulkan规范)：第十四章 14.6 内置变量" />
<meta property="og:description" content="14.6. 内置变量 带有BuiltIn 修饰符修饰的变量是内置变量，可以在着色器内被访问。
每个 BuiltIn 修饰的含义有如下几种： 此节的剩余部分，内置变量的名称与术语带有内置修饰符的变量等同。 内置变量中整数类型的可以被声明为有符号或者无符号整数。
ClipDistance
Decorating a variable with the ClipDistance built-in decoration will make that variable contain the mechanism for controlling user clipping. ClipDistance is an array such that the ith element of the array specifies the clip distance for plane i. A clip distance of 0 means the vertex is on the plane, a positive distance means the vertex is inside the clip half-space, and a negative distance means the point is outside the clip half-space." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/c57dfe92a975e2ea849200c9a5bc604d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-12T00:48:36+08:00" />
<meta property="article:modified_time" content="2020-07-12T00:48:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vulkan Specification(Vulkan规范)：第十四章 14.6 内置变量</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="interfaces-builtin-variables">14.6. 内置变量</h4> 
<p>带有<code>BuiltIn</code> 修饰符修饰的变量是内置变量，可以在着色器内被访问。</p> 
<p>每个 <code>BuiltIn</code> 修饰的含义有如下几种： 此节的剩余部分，内置变量的名称与术语带有内置修饰符的变量等同。 内置变量中整数类型的可以被声明为有符号或者无符号整数。</p> 
<p><code>ClipDistance</code></p> 
<p>Decorating a variable with the <code>ClipDistance</code> built-in decoration will make that variable contain the mechanism for controlling user clipping. <code>ClipDistance</code> is an array such that the ith element of the array specifies the clip distance for plane i. A clip distance of 0 means the vertex is on the plane, a positive distance means the vertex is inside the clip half-space, and a negative distance means the point is outside the clip half-space.</p> 
<p><code>ClipDistance</code> 修饰符只能在顶点、片元、细分控制、细分求值、几何着色器内使用。</p> 
<p>在顶点着色器内，<code>ClipDistance</code> 修饰的任何变量必须使用 <code>Output</code> 存储类别来声明。</p> 
<p>在片元着色器内，<code>ClipDistance</code> 修饰的变量必须使用<code>Input</code> 存储类别来声明。</p> 
<p>在细分控制、细分求值、几何着色器内，<code>ClipDistance</code> 修饰的任何变量只能是<code>Input</code> 或者 <code>Output</code>类别。</p> 
<p><code>ClipDistance</code> 修饰的任何变量必须位声明位32位浮点型的数组。</p> 
<table><tbody><tr><td> </td><td> <p>注意</p> <p><code>ClipDistance</code>修饰的数组变量，会自动被着色器填充大小。</p> </td></tr></tbody></table> 
<table><tbody><tr><td> </td><td> <p>注意</p> <p>在顶点处理阶段，这些值在图元之间被线性插值，部分插值距离小于0的图元 将被认为是超出剪裁空间。 若 <code>ClipDistance</code> 被片元着色器使用， <code>ClipDistance</code>将包含这些线性插值的值。</p> </td></tr></tbody></table> 
<p><code>CullDistance</code></p> 
<p>Decorating a variable with the <code>CullDistance</code> built-in decoration will make that variable contain the mechanism for controlling user culling. If any member of this array is assigned a negative value for all vertices belonging to a primitive, then the primitive is discarded before rasterization.</p> 
<p><code>CullDistance</code> 修饰符只能在顶点、片元、细分控制、细分求值、几何着色器中使用。</p> 
<p>在顶点着色器中，<code>CullDistance</code> 修饰的任何变量必须使用 <code>Output</code> 存储类别来声明。</p> 
<p>在片元着色器中，<code>CullDistance</code> 修饰的任何变量必须使用 <code>Input</code> 存储类别来声明。</p> 
<p>在细分控制、细分求值、或几何着色器中，<code>CullDistance</code> 修饰的任何变量必须使用 input 或 output 类别。</p> 
<p><code>CullDistance</code> 修饰的任何变量必须被声明位32位浮点型的三元素数组。</p> 
<table><tbody><tr><td> </td><td> <p>注意</p> <p>在片元着色器中，<code>CullDistance</code> 数组的值在每个图元之间被线性差值。</p> </td></tr></tbody></table> 
<table><tbody><tr><td> </td><td> <p>注意</p> <p>若<code>CullDistance</code> 修饰一个 input variable，该变量将包含对应的值，从 上一个着色器阶段的 <code>CullDistance</code> 修饰的输出变量获得。</p> </td></tr></tbody></table> 
<p><code>FragCoord</code></p> 
<p>使用 <code>FragCoord</code> built-in 修饰符来修饰一个变量将造成该变量 包含片元着色器处理生成的帧缓冲区坐标 \((x,y,z,\frac{1}{w})\) 。 (x,y) 坐标 (0,0) 是帧缓冲区左上角像素的左上角。</p> 
<p>当开启了采样着色时， <code>FragCoord</code> 的 x 和 y 成员反映了该着色器调用对应的采样位置。</p> 
<p>当没有开启采样着色时，<code>FragCoord</code> 的x 和 y 成员反映了像素的中心 (0.5,0.5) 的位置 。</p> 
<p><code>FragCoord</code>的 z 成员是图元的插值深度值。</p> 
<p>w 成员是插值的 \(\frac{1}{w}\).</p> 
<p><code>FragCoord</code> 修饰符只能在片元着色器中使用。</p> 
<p><code>FragCoord</code> 修饰的变量必须使用<code>Input</code> 存储类别来声明。</p> 
<p><code>Centroid</code> 差值修饰副被忽略，但是在<code>FragCoord</code>上是允许的。</p> 
<p><code>FragCoord</code> 修饰的变量必须被声明位32位浮点型的四元素数组。</p> 
<p><code>FragDepth</code></p> 
<p>Decorating a variable with the <code>FragDepth</code> built-in decoration will make that variable contain the new depth value for all samples covered by the fragment. This value will be used for depth testing and, if the depth test passes, any subsequent write to the depth/stencil attachment.</p> 
<p>To write to <code>FragDepth</code>, a shader <strong>must</strong> declare the <code>DepthReplacing</code> execution mode. If a shader declares the <code>DepthReplacing</code> execution mode and there is an execution path through the shader that does not set <code>FragDepth</code>, then the fragment’s depth value is undefined for executions of the shader that take that path.</p> 
<p><code>FragDepth</code> 修饰符只能在片元着色器中使用。</p> 
<p><code>FragDepth</code> 修饰的变量必须使用<code>Output</code> 存储类别来声明。</p> 
<p><code>FragDepth</code> 修饰的变量必须被声明位32位浮点型标量。</p> 
<p><code>FrontFacing</code></p> 
<p>Decorating a variable with the <code>FrontFacing</code> built-in decoration will make that variable contain whether a primitive is front or back facing. This variable is non-zero if the current fragment is considered to be part of a <a href="http://spec.vulkan.org.cn/#primsrast-polygons-basic" rel="nofollow">front-facing</a> primitive and is zero if the fragment is considered to be part of a back-facing primitive.</p> 
<p><code>FrontFacing</code> 修饰符只能在片元着色器中使用。</p> 
<p><code>FrontFacing</code> 修饰的变量必须使用 <code>Input</code> 存储类别来声明。</p> 
<p><code>FrontFacing</code> 修饰的变量必须被声明位boolean 类型。</p> 
<p><code>GlobalInvocationId</code></p> 
<p>Decorating a variable with the <code>GlobalInvocationId</code> built-in decoration will make that variable contain the location of the current invocation within the global workgroup. Each component is equal to the index of the local workgroup multiplied by the size of the local workgroup plus <code>LocalInvocationId</code>.</p> 
<p><code>GlobalInvocationId</code> 修饰符只能在计算着色器中使用。</p> 
<p><code>GlobalInvocationId</code> 修饰的变量必须使用 <code>Input</code> 存储类别来声明。</p> 
<p><code>GlobalInvocationId</code> 修饰的变量必须被声明为32位整型的三元素数组。</p> 
<p><code>HelperInvocation</code></p> 
<p>Decorating a variable with the <code>HelperInvocation</code> built-in decoration will make that variable contain whether the current invocation is a helper invocation. This variable is non-zero if the current fragment being shaded is a helper invocation and zero otherwise. A helper invocation is an invocation of the shader that is produced to satisfy internal requirements such as the generation of derivatives.</p> 
<p><code>HelperInvocation</code> 修饰符必须在片元着色器中使用。</p> 
<p><code>HelperInvocation</code> 修饰的变量必须使用 <code>Input</code> 存储类别来声明。</p> 
<p><code>HelperInvocation</code> 修饰的变量必须位声明为boolean类型。</p> 
<table><tbody><tr><td> </td><td> <p>注意</p> <p>It is very likely that a helper invocation will have a value of <code>SampleMask</code> fragment shader input value that is zero.</p> </td></tr></tbody></table> 
<p><code>InvocationId</code></p> 
<p>Decorating a variable with the <code>InvocationId</code> built-in decoration will make that variable contain the index of the current shader invocation in a geometry shader, or the index of the output patch vertex in a tessellation control shader.</p> 
<p>在几何着色器内，当前着色器调用的索引从0 到 着色器内声明的<a href="http://spec.vulkan.org.cn/#geometry-invocations" rel="nofollow">instances</a> 减去1之差。 若几何着色器的实例数量是1或者未指定，那么 <code>InvocationId</code> 将为0.</p> 
<p><code>InvocationId</code> 修饰符只能在细分控制、几何着色器中使用。</p> 
<p><code>InvocationId</code> 修饰的变量必须使用<code>Input</code> 存储类别来声明。</p> 
<p><code>InvocationId</code> 修饰的变量必须被声明为32位整型标量。</p> 
<p><code>InstanceIndex</code></p> 
<p>Decorating a variable with the <code>InstanceIndex</code> built-in decoration will make that variable contain the index of the instance that is being processed by the current vertex shader invocation. <code>InstanceIndex</code> begins at the <code>firstInstance</code> parameter to <code><a href="http://spec.vulkan.org.cn/#vkCmdDraw" rel="nofollow">vkCmdDraw</a></code> or <code><a href="http://spec.vulkan.org.cn/#vkCmdDrawIndexed" rel="nofollow">vkCmdDrawIndexed</a></code> or at the <code>firstInstance</code> member of a structure consumed by <code><a href="http://spec.vulkan.org.cn/#vkCmdDrawIndirect" rel="nofollow">vkCmdDrawIndirect</a></code> or <code><a href="http://spec.vulkan.org.cn/#vkCmdDrawIndexedIndirect" rel="nofollow">vkCmdDrawIndexedIndirect</a></code>.</p> 
<p><code>InstanceIndex</code> 修饰符只能在顶点着色器中使用。</p> 
<p><code>InstanceIndex</code> 修饰的变量必须使用<code>Input</code> 存储类别来声明。</p> 
<p><code>InstanceIndex</code> 修饰的变量必须被声明位一个32位整型标量。</p> 
<p><code>Layer</code></p> 
<p>Decorating a variable with the <code>Layer</code> built-in decoration will make that variable contain the select layer of a multi-layer framebuffer attachment.</p> 
<p>In a geometry shader, any variable decorated with <code>Layer</code> can be written with the framebuffer layer index to which the primitive produced by the geometry shader will be directed. If a geometry shader entry point’s interface does not include a variable decorated with <code>Layer</code>, then the first layer is used. If a geometry shader entry point’s interface includes a variable decorated with <code>Layer</code>, it <strong>must</strong> write the same value to <code>Layer</code> for all output vertices of a given primitive.</p> 
<p>In a fragment shader, a variable decorated with <code>Layer</code> contains the layer index of the primitive that the fragment invocation belongs to.</p> 
<p><code>Layer</code> 修饰符只能在几何、片元着色器中使用。</p> 
<p>在几何着色器中，<code>Layer</code> 修饰的任何变量必须使用<code>Output</code> 存储类别来声明。</p> 
<p>在片元着色器中， <code>Layer</code> 修饰的任何变量必须使用<code>Input</code> 存储类别来声明。</p> 
<p><code>Layer</code> 修饰的任何变量必须被声明位32位整型标量。</p> 
<p><code>LocalInvocationId</code></p> 
<p>Decorating a variable with the <code>LocalInvocationId</code> built-in decoration will make that variable contain the location of the current compute shader invocation within the local workgroup. Each component ranges from zero through to the size of the workgroup in that dimension minus one.</p> 
<p><code>LocalInvocationId</code> 修饰符必须在计算着色器中使用。</p> 
<p><code>LocalInvocationId</code> 修饰的变量必须使用 <code>Input</code> 存储类别来声明。</p> 
<p><code>LocalInvocationId</code> 修饰的变量必须被声明位32位整型的三元素向量。</p> 
<table><tbody><tr><td> </td><td> <p>注意</p> <p>If the size of the workgroup in a particular dimension is one, then the <code>LocalInvocationId</code> in that dimension will be zero. If the workgroup is effectively two-dimensional, then <code>LocalInvocationId</code>.z will be zero. If the workgroup is effectively one-dimensional, then both <code>LocalInvocationId</code>.y and <code>LocalInvocationId</code>.z will be zero.</p> </td></tr></tbody></table> 
<p><code>NumWorkgroups</code></p> 
<p>Decorating a variable with the <code>NumWorkgroups</code> built-in decoration will make that variable contain the number of local workgroups that are part of the dispatch that the invocation belongs to. Each component is equal to the values of the parameters passed into <code><a href="http://spec.vulkan.org.cn/#vkCmdDispatch" rel="nofollow">vkCmdDispatch</a></code> or read from the <code>VkDispatchIndirectCommand</code> structure read through a call to <code><a href="http://spec.vulkan.org.cn/#vkCmdDispatchIndirect" rel="nofollow">vkCmdDispatchIndirect</a></code>.</p> 
<p><code>NumWorkgroups</code> 修饰符只能在计算着色器中使用。</p> 
<p><code>NumWorkgroups</code> 修饰的变量必须使用<code>Input</code> 存储类别来声明。</p> 
<p><code>NumWorkgroups</code> 修饰的变量必须被声明位32位整型的三元素数组。</p> 
<p><code>PatchVertices</code></p> 
<p>Decorating a variable with the <code>PatchVertices</code> built-in decoration will make that variable contain the number of vertices in the input patch being processed by the shader. A single tessellation control or tessellation evaluation shader <strong>can</strong> read patches of differing sizes, so the value of the <code>PatchVertices</code> variable <strong>may</strong> differ between patches.</p> 
<p><code>PatchVertices</code> 修饰符只能在细分控制、细分求值着色器中使用。</p> 
<p><code>PatchVertices</code> 修饰的变量必须使用<code>Input</code> 存储类别来声明。</p> 
<p><code>PatchVertices</code> 修饰的变量必须被声明位32位整型标量。</p> 
<p><code>PointCoord</code></p> 
<p>Decorating a variable with the <code>PointCoord</code> built-in decoration will make that variable contain the coordinate of the current fragment within the point being rasterized, normalized to the size of the point with origin in the upper left corner of the point, as described in <a href="http://spec.vulkan.org.cn/#primsrast-points-basic" rel="nofollow">Basic Point Rasterization</a>. If the primitive the fragment shader invocation belongs to is not a point, then the variable decorated with <code>PointCoord</code> contains an undefined value.</p> 
<p><code>PointCoord</code> 修饰符只能在片元着色器中使用。</p> 
<p><code>PointCoord</code> 修饰的变量必须使用<code>Input</code> 存储类别来声明。</p> 
<p><code>PointCoord</code> 修饰的变量必须被声明位32位浮点型二元素数组。</p> 
<table><tbody><tr><td> </td><td> <p>注意</p> <p>取决于单点是如何被渲染的， <code>PointCoord</code> 可能永远不会达到 (0,0) 或 (1,1).</p> </td></tr></tbody></table> 
<p><code>PointSize</code></p> 
<p>给一个变量加上<code>PointSize</code> built-in 修饰符将导致该变量包含顶点图元的大小。 管线内最后的顶点处理阶段写入到<code>PointSize</code>修饰的该变量被用于 栅格化产生的帧缓冲区空间的点的大小。</p> 
<p><code>PointSize</code> 修饰符只能在顶点、细分控制、细分求值、几何着色器中使用。shaders.</p> 
<p>在顶点着色器中，<code>PointSize</code> 修饰的任何变量必须使用<code>Output</code> 存储类别来声明。</p> 
<p>在细分控制、细分求值、几何着色器中，<code>PointSize</code> 修饰的任何变量必须使用 <code>Input</code> 或者 <code>Output</code> 存储类别来声明。</p> 
<p><code>PointSize</code> 修饰的任何变量必须被声明位一个32位浮点型标量。</p> 
<table><tbody><tr><td> </td><td> <p>注意</p> <p>When <code>PointSize</code> decorates a variable in the <code>Input</code> storage class, it contains the data written to the output variable decorated with <code>PointSize</code> from the previous shader stage.</p> </td></tr></tbody></table> 
<p><code>Position</code></p> 
<p>Decorating a variable with the <code>Position</code> built-in decoration will make that variable contain the position of the current vertex. In the last vertex processing stage, the value of the variable decorated with <code>Position</code> is used in subsequent primitive assembly, clipping, and rasterization operations.</p> 
<p><code>Position</code> 修饰符只能在顶点、细分控制、细分求值、几何着色器中使用。</p> 
<p>在顶点着色器中，<code>Position</code> 修饰的任何变量必须使用 <code>Output</code> 存储类别来声明。</p> 
<p>在细分控制、细分求值或几何着色器中， <code>Position</code> 修饰的任何变量只能使用 input 或者 output存储类别来声明。</p> 
<p><code>Position</code> 修饰的任何变量必须被声明为32位浮点型的四元素数组。</p> 
<table><tbody><tr><td> </td><td> <p>注意</p> <p>When <code>Position</code> decorates a variable in the <code>Input</code> storage class, it contains the data written to the output variable decorated with <code>Position</code> from the previous shader stage.</p> </td></tr></tbody></table> 
<p><code>PrimitiveId</code></p> 
<p>使用 <code>PrimitiveId</code> built-in修饰符修饰的变量将让该变量包含当前图元的索引。</p> 
<p>在细分控制和细分求值着色器中，它将包含 对应着色器调用的当前渲染图元内的patch的索引。</p> 
<p>在几何着色器内，它将包含从当前渲染图元的集合开始之后 作为着色器输入的图元的个数。</p> 
<p>在片元着色器中，它将包含几何着色器（若有的话）写入的图元索引，或者该值会当作 几何着色器（若有的话）的输入。</p> 
<p>If a geometry shader is present and the fragment shader reads from an input variable decorated with <code>PrimitiveId</code>, then the geometry shader <strong>must</strong> write to an output variable decorated with <code>PrimitiveId</code> in all execution paths.</p> 
<p><code>PrimitiveId</code> 修饰符只能在片元、细分控制、细分求值、几何着色器中使用。</p> 
<p>In a tessellation control or tessellation evaluation shader, any variable decorated with <code>PrimitiveId</code> <strong>must</strong> be declared using the <code>Output</code> storage class.</p> 
<p>In a geometry shader, any variable decorated with <code>PrimitiveId</code> <strong>must</strong> be declared using either the <code>Input</code> or <code>Output</code> storage class.</p> 
<p>In a fragment shader, any variable decorated with <code>PrimitiveId</code> <strong>must</strong> be declared using the <code>Input</code> storage class, and either the <code>Geometry</code> or <code>Tessellation</code> capability must also be declared.</p> 
<p><code>PrimitiveId</code> 修饰的任何变量必须被声明为32位整型标量。</p> 
<table><tbody><tr><td> </td><td> <p>注意</p> <p>当<code>PrimitiveId</code> 修饰符被应用到几何着色器的一个输出变量上，生成的值在片元着色器中可以通过<code>PrimitiveId</code>修饰的输入变量看到。</p> </td></tr></tbody></table> 
<p><code>SampleId</code></p> 
<p>Decorating a variable with the <code>SampleId</code> built-in decoration will make that variable contain the zero-based index of the sample the invocation corresponds to. <code>SampleId</code> ranges from zero to the number of samples in the framebuffer minus one. If a fragment shader entry point’s interface includes an input variable decorated with <code>SampleId</code>, per-sample shading is enabled for draws that use that fragment shader.</p> 
<p><code>SampleId</code> 修饰符只能在片元着色器中使用。</p> 
<p><code>SampleId</code> 修饰的变量只能使用<code>Input</code> 存储类别修饰。</p> 
<p><code>SampleId</code>修饰的变量必须被声明为32位的标量整型。</p> 
<p><code>SampleMask</code></p> 
<p>Decorating a variable with the <code>SampleMask</code> built-in decoration will make any variable contain the sample coverage mask for the current fragment shader invocation.</p> 
<p>A variable in the <code>Input</code> storage class decorated with <code>SampleMask</code> will contain a bitmask of the set of samples covered by the primitive generating the fragment during rasterization. It has a sample bit set if and only if the sample is considered covered for this fragment shader invocation. <code>SampleMask</code>[] is an array of integers. Bits are mapped to samples in a manner where bit B of mask M (<code>SampleMask[M]</code>) corresponds to sample 32 × M + B.</p> 
<p>When state specifies multiple fragment shader invocations for a given fragment, the sample mask for any single fragment shader invocation specifies the subset of the covered samples for the fragment that correspond to the invocation. In this case, the bit corresponding to each covered sample will be set in exactly one fragment shader invocation.</p> 
<p>A variable in the <code>Output</code> storage class decorated with <code>SampleMask</code> is an array of integers forming a bit array in a manner similar an input variable decorated with <code>SampleMask</code>, but where each bit represents coverage as computed by the shader. Modifying the sample mask by writing zero to a bit of <code>SampleMask</code> causes the sample to be considered uncovered. However, setting sample mask bits to one will never enable samples not covered by the original primitive. If the fragment shader is being evaluated at any frequency other than per-fragment, bits of the sample mask not corresponding to the current fragment shader invocation are ignored. This array <strong>must</strong> be sized in the fragment shader either implicitly or explicitly, to be no larger than the implementation-dependent maximum sample-mask (as an array of 32-bit elements), determined by the maximum number of samples. If a fragment shader entry point’s interface includes an output variable decorated with <code>SampleMask</code>, the sample mask will be undefined for any array elements of any fragment shader invocations that fail to assign a value. If a fragment shader entry point’s interface does not include an output variable decorated with <code>SampleMask</code>, the sample mask has no effect on the processing of a fragment.</p> 
<p><code>SampleMask</code> 修饰符只能在片元着色器内使用。</p> 
<p><code>SampleMask</code> 修饰的任何变量必须使用 <code>Input</code> 或 <code>Output</code> 存储类型来声明。</p> 
<p><code>SampleMask</code>修饰的任何变量必须被声明为32位整型的数组。</p> 
<p><code>SamplePosition</code></p> 
<p>Decorating a variable with the <code>SamplePosition</code> built-in decoration will make that variable contain the sub-pixel position of the sample being shaded. The top left of the pixel is considered to be at coordinate (0,0) and the bottom right of the pixel is considered to be at coordinate (1,1). If a fragment shader entry point’s interface includes an input variable decorated with <code>SamplePosition</code>, per-sample shading is enabled for draws that use that fragment shader.</p> 
<p><code>SamplePosition</code> 修饰符必须只在片元着色器中使用。</p> 
<p><code>SamplePosition</code>修饰的变量必须使用<code>Input</code> 存储类别来声明。</p> 
<p>The variable decorated with <code>SamplePosition</code> <strong>must</strong> be declared as a two-component vector of 32-bit floating-point values.</p> 
<p><code>TessCoord</code></p> 
<p>Decorating a variable with the <code>TessCoord</code> built-in decoration will make that variable contain the three-dimensional (u,v,w) barycentric coordinate of the tessellated vertex within the patch. u, v, and w are in the range [0,1] and vary linearly across the primitive being subdivided. For the tessellation modes of <code>Quads</code> or <code>IsoLines</code>, the third component is always zero.</p> 
<p><code>TessCoord</code> 修饰符只能在细分求值着色器中使用。</p> 
<p><code>TessCoord</code>修饰的变量必须使用<code>Input</code> 存储类别来声明。</p> 
<p><code>TessCoord</code> 修饰的变量必须被声明为 32位浮点类型的三元素数组。</p> 
<p><code>TessLevelOuter</code></p> 
<p>Decorating a variable with the <code>TessLevelOuter</code> built-in decoration will make that variable contain the outer tessellation levels for the current patch.</p> 
<p>In tessellation control shaders, the variable decorated with <code>TessLevelOuter</code> <strong>can</strong> be written to which controls the tessellation factors for the resulting patch. These values are used by the tessellator to control primitive tessellation and <strong>can</strong> be read by tessellation evaluation shaders.</p> 
<p>在细分求值着色器内，<code>TessLevelOuter</code>修饰的变量可以读取 细分控制着色器写入的值。</p> 
<p><code>TessLevelOuter</code> 修饰符只能在细分控制着色器、细分求值着色器中使用。</p> 
<p>在细分控制着色器内，<code>TessLevelOuter</code>修饰的任何变量必须使用 <code>Output</code> 存储类别来声明。</p> 
<p>在细分求值着色器内，<code>TessLevelOuter</code>修饰的任何变量必须使用 <code>Input</code> 存储类别来声明。</p> 
<p><code>TessLevelOuter</code>修饰的任何变量必须被声明为32位浮点型的四元素数组。</p> 
<p><code>TessLevelInner</code></p> 
<p>Decorating a variable with the <code>TessLevelInner</code> built-in decoration will make that variable contain the inner tessellation levels for the current patch.</p> 
<p>In tessellation control shaders, the variable decorated with <code>TessLevelInner</code> <strong>can</strong> be written to, which controls the tessellation factors for the resulting patch. These values are used by the tessellator to control primitive tessellation and <strong>can</strong> be read by tessellation evaluation shaders.</p> 
<p>In tessellation evaluation shaders, the variable decorated with <code>TessLevelInner</code> <strong>can</strong> read the values written by the tessellation control shader.</p> 
<p><code>TessLevelInner</code> 修饰符只能在细分控制着色器、细分求值着色器内使用。</p> 
<p>In a tessellation control shader, any variable decorated with <code>TessLevelInner</code> <strong>must</strong> be declared using the <code>Output</code> storage class.</p> 
<p>In a tessellation evaluation shader, any variable decorated with <code>TessLevelInner</code> <strong>must</strong> be declared using the <code>Input</code> storage class.</p> 
<p>Any variable decorated with <code>TessLevelInner</code> <strong>must</strong> be declared as an array of size two, containing 32-bit floating-point values.</p> 
<p><code>VertexIndex</code></p> 
<p>使用built-in 修饰符 <code>VertexIndex</code> 来修饰变量，将导致当前顶点着色器调用正在处理的该变量包含顶点的索引。 对于非索引化绘制，此变量从 <code>firstVertex</code> 参数开始 到 <code><a href="http://spec.vulkan.org.cn/#vkCmdDraw" rel="nofollow">vkCmdDraw</a></code> 或者 <code><a href="http://spec.vulkan.org.cn/#vkCmdDrawIndirect" rel="nofollow">vkCmdDrawIndirect</a></code>使用的数据结构的<code>firstVertex</code> 成员，且在绘制过程中对于每个顶点增长一个。 对于索引化绘制，它的值就是 顶点的索引缓冲区的内容加上 <code><a href="http://spec.vulkan.org.cn/#vkCmdDrawIndexed" rel="nofollow">vkCmdDrawIndexed</a></code> 命令的<code>vertexOffset</code>参数或者 <code><a href="http://spec.vulkan.org.cn/#vkCmdDrawIndexedIndirect" rel="nofollow">vkCmdDrawIndexedIndirect</a></code>使用的 <code>vertexOffset</code>成员。</p> 
<p><code>VertexIndex</code> 修饰符只能在顶点着色器内使用。</p> 
<p><code>VertexIndex</code>修饰的变量必须使用<code>Input</code> 存储类别来声明。</p> 
<p><code>VertexIndex</code> 修饰的变量必须被声明位32位的标量整型。</p> 
<table><tbody><tr><td> </td><td> <p>注意</p> <p><code>VertexIndex</code> 对于每个实例都从相同的值开始。</p> </td></tr></tbody></table> 
<p><code>ViewportIndex</code></p> 
<p>Decorating a variable with the <code>ViewportIndex</code> built-in decoration will make that variable contain the index of the viewport.</p> 
<p>In a geometry shader, the variable decorated with <code>ViewportIndex</code> can be written to with the viewport index to which the primitive produced by the geometry shader will be directed. The selected viewport index is used to select the viewport transform and scissor rectangle. If a geometry shader entry point’s interface does not include a variable decorated with <code>ViewportIndex</code>, then the first viewport is used. If a geometry shader entry point’s interface includes a variable decorated with <code>ViewportIndex</code>, it <strong>must</strong> write the same value to <code>ViewportIndex</code> for all output vertices of a given primitive.</p> 
<p>In a fragment shader, the variable decorated with <code>ViewportIndex</code> contains the viewport index of the primitive that the fragment invocation belongs to.</p> 
<p><code>ViewportIndex</code> 修饰符只能在几何着色器、片元着色器中使用。</p> 
<p>在几何着色器内部，<code>ViewportIndex</code> 修饰的任何变量必须使用 <code>Output</code> 存储类别来声明。</p> 
<p>在片元着色器内，<code>ViewportIndex</code> 修饰的任何变量必须使用 <code>Input</code> 存储类别来声明。</p> 
<p><code>ViewportIndex</code>修饰的任何变量必须被声明为32位整型标量。</p> 
<p><code>WorkgroupId</code></p> 
<p>Decorating a variable with the <code>WorkgroupId</code> built-in decoration will make that variable contain the global workgroup that the current invocation is a member of. Each component ranges from zero to the values of the parameters passed into <code><a href="http://spec.vulkan.org.cn/#vkCmdDispatch" rel="nofollow">vkCmdDispatch</a></code> or read from the <code>VkDispatchIndirectCommand</code> structure read through a call to <code><a href="http://spec.vulkan.org.cn/#vkCmdDispatchIndirect" rel="nofollow">vkCmdDispatchIndirect</a></code>.</p> 
<p><code>WorkgroupId</code> 修饰符只能在计算着色器内使用。</p> 
<p><code>WorkgroupId</code> 修饰的变量必须使用<code>Input</code> 存储类别来声明。</p> 
<p><code>WorkgroupId</code> 修饰的变量必须被声明位32位整型的三元素数组。</p> 
<p><code>WorkgroupSize</code></p> 
<p>Decorating a variable with the <code>WorkgroupSize</code> built-in decoration will make that variable contain the dimensions of a local workgroup. If an object is decorated with the <code>WorkgroupSize</code> decoration, this <strong>must</strong> take precedence over any execution mode set for <code>LocalSize</code>.</p> 
<p><code>WorkgroupSize</code> 修饰符只能在计算着色器内使用。</p> 
<p><code>WorkgroupSize</code> 修饰的对象必须是一个特化常量或者是一个常量。</p> 
<p><code>WorkgroupSize</code> 修饰的对象必须被声明为32位整型的三元素数组。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7dfd8383d337cd62f686d137db6acf1d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Redis中string数据结构的实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b282b90240672e9fed82e2710d0637bb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DPDK网卡设备加载流程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>