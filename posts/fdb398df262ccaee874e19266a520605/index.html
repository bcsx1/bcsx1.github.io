<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OpenCV C&#43;&#43;双目三维重建：双目摄像头实现双目测距 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OpenCV C&#43;&#43;双目三维重建：双目摄像头实现双目测距" />
<meta property="og:description" content="OpenCV C&#43;&#43;双目三维重建：双目摄像头实现双目测距 目录
OpenCV C&#43;&#43;双目三维重建：双目摄像头实现双目测距
1.目录结构
2.依赖库
(1) Ubuntu 18.04配置开发环境
(2) Windows配置开发环境
3.双目相机标定
(1)双目相机标定-Python版
(2)双目相机标定-Matlab版
4.相机参数配置
5. 双目测距
6. 运行Demo
7.双目测距的误差说明
8. 双目三维重建项目代码（C/C&#43;&#43;版本）
(1)效果图
(2)源码下载
9. 双目三维重建项目代码（Python版本）
10. 双目三维重建项目代码（Android版本）
11.参考资料
本篇博文是《双目三维重建系统(双目标定&#43;立体校正&#43;双目测距&#43;点云显示)Python​​​​​​》的续作，我们将搭建一个OpenCV C&#43;&#43;版本的双目三维重建系统。由于我们只考虑三维重建实现双目测距效果，因而去除了PCL和Open3d库三维显示效果，但依然保留了视差图，深度图等可视化效果，用户可以通过鼠标点击图像，即可获得对应的世界坐标以及深度距离信息。
从效果来看，C&#43;&#43;版本的双目测距和Python版本的效果几乎一致，性能更优，速度更快，基本可以达到工业级别测距精度，可在Linux开发板运行，非常适合应用于无人机，智能小车测距避障等场景。​
来~先看一下Demo的效果图（鼠标点击，终端会打印对应距离信息）： ​
OpenCV C&#43;&#43;双目摄像头实现双目测距主要支持：
支持双USB连接线的双目摄像头支持使用WLS滤波器对视差图进行滤波支持双目测距(鼠标点击图像即可获得其深度距离)提供配套的opencv-4.3.0和opencv_contrib-4.3.0源码 （Linux系统需要自行编译；Windows10系统已提供opencv_contrib编译文件，可直接复用，无需重新编译）相比Python版本，C&#43;&#43;版本性能更优，速度更快，可在Linux开发板运行，非常适合应用于无人机，智能小车测距避障等场景。支持Linux系统：项目源码已在Ubuntu 18.04系统验证通过（需要自行编译opencv-4.3.0和opencv_contrib-4.3.0）支持Windows10系统：项目源码已在Windows10系统验证通过，配套了Visual Studio 2017项目，可直接使用其他系统平台开发，请在配置好opencv和opencv_contrib开发环境 诚然，网上有很多C&#43;&#43;版本双测距的代码，但项目都不是十分完整，而且恢复视差图效果也一般，难以达到商业实际应用，究其原因，主要有下面几个：
双目摄像头质量问题，双目标定存在问题，导致校准误差较大没有使用WLS滤波器对视差图进行滤波，该方法可以极大提高视差图的效果 双目测距Demo视频
如果你需要Python版本的双目测距， 请查看鄙人另一篇博客《双目三维重建：双目摄像头实现双目测距（Python》
本篇将着重介绍OpenCV C&#43;&#43;项目实现双目测距的过程，关于双目相机标定&#43;双目校正&#43;双目匹配等内容，请查看鄙人另一篇博客 《双目三维重建系统(双目标定&#43;立体校正&#43;双目测距&#43;点云显示)Python​​​​​​》
【项目源码下载地址】OpenCV C&#43;&#43;双目摄像头实现双目测距
【尊重原则，转载请注明出处】https://blog.csdn.net/guyuealian/article/details/127446435
1.目录结构 . ├── configs # 相机参数文件 ├── data # 相机采集的数据 ├── docs # 一些文档图片 ├── src # C&#43;&#43;源码 ├── build." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/fdb398df262ccaee874e19266a520605/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-26T14:49:17+08:00" />
<meta property="article:modified_time" content="2023-10-26T14:49:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OpenCV C&#43;&#43;双目三维重建：双目摄像头实现双目测距</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="OpenCV%20C%2B%2B%E5%8F%8C%E7%9B%AE%E6%91%84%E5%83%8F%E5%A4%B4%E5%AE%9E%E7%8E%B0%E5%8F%8C%E7%9B%AE%E6%B5%8B%E8%B7%9D" style="text-align:center;">OpenCV C++双目三维重建：双目摄像头实现双目测距</h2> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="OpenCV%20C%2B%2B%E5%8F%8C%E7%9B%AE%E6%91%84%E5%83%8F%E5%A4%B4%E5%AE%9E%E7%8E%B0%E5%8F%8C%E7%9B%AE%E6%B5%8B%E8%B7%9D-toc" style="margin-left:0px;"><a href="#OpenCV%20C%2B%2B%E5%8F%8C%E7%9B%AE%E6%91%84%E5%83%8F%E5%A4%B4%E5%AE%9E%E7%8E%B0%E5%8F%8C%E7%9B%AE%E6%B5%8B%E8%B7%9D" rel="nofollow">OpenCV C++双目三维重建：双目摄像头实现双目测距</a></p> 
<p id="1.%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#1.%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84" rel="nofollow">1.目录结构</a></p> 
<p id="2.%E4%BE%9D%E8%B5%96%E5%BA%93-toc" style="margin-left:40px;"><a href="#2.%E4%BE%9D%E8%B5%96%E5%BA%93" rel="nofollow">2.依赖库</a></p> 
<p id="%C2%A0(1)%20Ubuntu%2018.04%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-toc" style="margin-left:80px;"><a href="#%C2%A0%281%29%20Ubuntu%2018.04%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83" rel="nofollow"> (1) Ubuntu 18.04配置开发环境</a></p> 
<p id="%C2%A0(2)%20Windows%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-toc" style="margin-left:80px;"><a href="#%C2%A0%282%29%20Windows%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83" rel="nofollow"> (2) Windows配置开发环境</a></p> 
<p id="3.%E5%8F%8C%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A-toc" style="margin-left:40px;"><a href="#3.%E5%8F%8C%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A" rel="nofollow">3.双目相机标定</a></p> 
<p id="%C2%A0(1)%E5%8F%8C%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A-Python%E7%89%88-toc" style="margin-left:80px;"><a href="#%C2%A0%281%29%E5%8F%8C%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A-Python%E7%89%88" rel="nofollow"> (1)双目相机标定-Python版</a></p> 
<p id="%C2%A0(2)%E5%8F%8C%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A-Matlab%E7%89%88-toc" style="margin-left:80px;"><a href="#%C2%A0%282%29%E5%8F%8C%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A-Matlab%E7%89%88" rel="nofollow"> (2)双目相机标定-Matlab版</a></p> 
<p id="4.%E7%9B%B8%E6%9C%BA%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#4.%E7%9B%B8%E6%9C%BA%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE" rel="nofollow">4.相机参数配置</a></p> 
<p id="5.%20%E5%8F%8C%E7%9B%AE%E6%B5%8B%E8%B7%9D-toc" style="margin-left:40px;"><a href="#5.%20%E5%8F%8C%E7%9B%AE%E6%B5%8B%E8%B7%9D" rel="nofollow">5. 双目测距</a></p> 
<p id="6.%20%E8%BF%90%E8%A1%8CDemo-toc" style="margin-left:40px;"><a href="#6.%20%E8%BF%90%E8%A1%8CDemo" rel="nofollow">6. 运行Demo</a></p> 
<p id="6.%E5%8F%8C%E7%9B%AE%E6%B5%8B%E8%B7%9D%E7%9A%84%E8%AF%AF%E5%B7%AE%E8%AF%B4%E6%98%8E-toc" style="margin-left:40px;"><a href="#6.%E5%8F%8C%E7%9B%AE%E6%B5%8B%E8%B7%9D%E7%9A%84%E8%AF%AF%E5%B7%AE%E8%AF%B4%E6%98%8E" rel="nofollow">7.双目测距的误差说明</a></p> 
<p id="9.%20%E5%8F%8C%E7%9B%AE%E6%B5%8B%E8%B7%9DDemo%EF%BC%88C%2FC%2B%2B%E7%89%88%E6%9C%AC%EF%BC%89-toc" style="margin-left:40px;"><a href="#9.%20%E5%8F%8C%E7%9B%AE%E6%B5%8B%E8%B7%9DDemo%EF%BC%88C%2FC%2B%2B%E7%89%88%E6%9C%AC%EF%BC%89" rel="nofollow">8. 双目三维重建项目代码（C/C++版本）</a></p> 
<p id="7.%C2%A0%E6%95%88%E6%9E%9C%E5%9B%BE-toc" style="margin-left:80px;"><a href="#7.%C2%A0%E6%95%88%E6%9E%9C%E5%9B%BE" rel="nofollow">(1)效果图</a></p> 
<p id="8.%20%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD-toc" style="margin-left:80px;"><a href="#8.%20%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD" rel="nofollow">(2)源码下载</a></p> 
<p id="8.%20%E5%8F%8C%E7%9B%AE%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%88Python%E7%89%88%E6%9C%AC%EF%BC%89-toc" style="margin-left:40px;"><a href="#8.%20%E5%8F%8C%E7%9B%AE%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%88Python%E7%89%88%E6%9C%AC%EF%BC%89" rel="nofollow">9. 双目三维重建项目代码（Python版本）</a></p> 
<p id="11.%20%E5%8F%8C%E7%9B%AE%E6%B5%8B%E8%B7%9DDemo%EF%BC%88Android%E7%89%88%E6%9C%AC%EF%BC%89-toc" style="margin-left:40px;"><a href="#11.%20%E5%8F%8C%E7%9B%AE%E6%B5%8B%E8%B7%9DDemo%EF%BC%88Android%E7%89%88%E6%9C%AC%EF%BC%89" rel="nofollow">10. 双目三维重建项目代码（Android版本）</a></p> 
<p id="9.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-toc" style="margin-left:40px;"><a href="#9.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" rel="nofollow">11.参考资料</a></p> 
<hr id="hr-toc"> 
<p>本篇博文是《<a href="https://blog.csdn.net/guyuealian/article/details/121301896" title="双目三维重建系统(双目标定+立体校正+双目测距+点云显示)Python">双目三维重建系统(双目标定+立体校正+双目测距+点云显示)Python</a>​​​​​​》的续作，我们将搭建一个OpenCV C++版本的双目三维重建系统。由于我们只考虑三维重建实现双目测距效果，因而去除了PCL和Open3d库三维显示效果，但依然保留了视差图，深度图等可视化效果，用户可以通过鼠标点击图像，即可获得对应的世界坐标以及深度距离信息。</p> 
<p>从效果来看，C++版本的双目测距和Python版本的效果几乎一致，性能更优，速度更快，基本可以达到<strong>工业级别测距精度</strong>，可在Linux开发板运行，<span style="color:#fe2c24;">非常适合应用于无人机，智能小车测距避障等场景。​</span></p> 
<p>来~先看一下Demo的效果图（<span style="color:#fe2c24;">鼠标点击，终端会打印对应距离信息</span>）： </p> 
<p><img alt="c4e2af59d2c64999bbf53e1c68832d9b.gif" src="https://images2.imgbox.com/24/84/GPyY12iS_o.gif">​</p> 
<p>OpenCV C++双目摄像头实现双目测距主要支持：</p> 
<blockquote> 
 <ul><li>支持双USB连接线的双目摄像头</li><li>支持使用WLS滤波器对视差图进行滤波</li><li>支持双目测距(鼠标点击图像即可获得其深度距离)</li><li>提供配套的opencv-4.3.0和opencv_contrib-4.3.0源码 （<span style="color:#fe2c24;">Linux系统需要自行编译；Windows10系统已提供opencv_contrib编译文件，可直接复用，无需重新编译</span>）</li><li>相比Python版本，C++版本性能更优，速度更快，可在Linux开发板运行，非常适合应用于无人机，智能小车测距避障等场景。</li><li><strong>支持Linux系统：</strong>项目源码已在Ubuntu 18.04系统验证通过（<span style="color:#fe2c24;">需要自行编译opencv-4.3.0和opencv_contrib-4.3.0</span>）</li><li><strong>支持Windows10系统：</strong>项目源码已在<strong>Windows10</strong>系统验证通过，配套了Visual Studio 2017项目，可直接使用</li><li>其他系统平台开发，请在配置好opencv和opencv_contrib开发环境</li></ul> 
</blockquote> 
<p>诚然，网上有很多C++版本双测距的代码，但项目都不是十分完整，而且恢复视差图效果也一般，难以达到商业实际应用，究其原因，主要有下面几个：</p> 
<blockquote> 
 <ul><li>双目摄像头质量问题，</li><li>双目标定存在问题，导致校准误差较大</li><li>没有使用<strong>WLS滤波器对视差图进行滤波，该方法可以极大提高视差图的效果</strong></li></ul> 
</blockquote> 
<table border="1" cellpadding="1" cellspacing="1" style="width:0px;"><tbody><tr><td> 
    <div> 
     <div class="csdn-video-box"> 
      <iframe id="fjHYSF53-1666348974279" frameborder="0" src="https://live.csdn.net/v/embed/247210" allowfullscreen="true" data-mediaembed="csdn"></iframe> 
      <p>双目测距Demo视频</p> 
     </div> 
    </div> </td></tr></tbody></table> 
<p>如果你需要Python版本的双目测距， 请查看鄙人另一篇博客《<a href="https://blog.csdn.net/guyuealian/article/details/121870887" title="双目三维重建：双目摄像头实现双目测距（Python">双目三维重建：双目摄像头实现双目测距（Python</a>》</p> 
<p>本篇将着重介绍OpenCV C++项目实现双目测距的过程，关于<strong>双目相机标定+双目校正+双目匹配</strong>等内容，请查看鄙人另一篇博客 《<a href="https://blog.csdn.net/guyuealian/article/details/121301896" title="双目三维重建系统(双目标定+立体校正+双目测距+点云显示)Python">双目三维重建系统(双目标定+立体校正+双目测距+点云显示)Python</a>​​​​​​》</p> 
<p><strong>【项目源码下载地址</strong>】<a href="https://mp.weixin.qq.com/s/ZiAranhL4NwlYdcJ1nsvRw" rel="nofollow" title="OpenCV C++双目摄像头实现双目测距">OpenCV C++双目摄像头实现双目测距</a></p> 
<p><strong>【尊重原则，转载请注明出处】</strong><a href="https://blog.csdn.net/guyuealian/article/details/127446435" title="https://blog.csdn.net/guyuealian/article/details/127446435">https://blog.csdn.net/guyuealian/article/details/127446435</a></p> 
<hr> 
<h3 id="1.%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">1.目录结构</h3> 
<div> 
 <pre><code class="language-bash">.
├── configs          # 相机参数文件
├── data             # 相机采集的数据
├── docs             # 一些文档图片
├── src              # C++源码
├── build.sh         # 构建build脚本
├── main.cpp         # 主程序
├── CMakeLists.txt   # CMake文件
└── README.md        # 说明文档</code></pre> 
</div> 
<hr> 
<h3 id="2.%E4%BE%9D%E8%B5%96%E5%BA%93">2.依赖库</h3> 
<h4 id="%C2%A0(1)%20Ubuntu%2018.04%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"> (1) Ubuntu 18.04配置开发环境</h4> 
<ul><li>系统平台：Ubuntu 18.04</li><li>opencv-4.3.0 (opencv-3.4.0以上亦可)</li><li>opencv_contrib-4.3.0 (opencv_contrib-3.4.0以上亦可)，WLS滤波器需要用到opencv_contrib库</li></ul> 
<p>Ubuntu 18.04 opencv安装教程，请参考文章：<a href="https://blog.csdn.net/guyuealian/article/details/127400841" title="Ubuntu18.04安装opencv和opencv_contrib">Ubuntu18.04安装opencv和opencv_contrib</a></p> 
<p>PS: 需确保opencv和opencv_contrib的版本号一致，避免版本差异导致编译错误。</p> 
<h4 id="%C2%A0(2)%20Windows%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"> (2) Windows配置开发环境</h4> 
<h4></h4> 
<ul><li>系统平台：Windows10</li><li>opencv-4.3.0 (opencv-3.4.0以上亦可)</li><li>opencv_contrib-4.3.0 (opencv_contrib-3.4.0以上亦可)，WLS滤波器需要用到opencv_contrib库</li></ul> 
<p>Windows opencv安装教程，请参考文章：<a href="https://blog.csdn.net/nohopenolove/article/details/107028598" title="Visual Studio 2017环境cmake编译opencv 4.3.0+opencv_contrib 4.3.0">Visual Studio 2017环境cmake编译opencv 4.3.0+opencv_contrib 4.3.0</a></p> 
<p>特别说明：</p> 
<blockquote> 
 <p>鄙人是在Ubuntu 18.04平台使用CLion工具进行开发（默认编码格式utf-8），其他平台可能会出现编码格式异常的问题；特别注意，如果你在Windows系统使用Visual Studio 进行开发（默认编码格式GBK），会出现如【本地函数定义是非法的】语法异常错误等问题；解决方法也很简单，只需要在<strong>属性页</strong>的<strong>命令行</strong>中，添加<strong>/utf-8</strong>即可</p> 
</blockquote> 
<p><img alt="" height="982" src="https://images2.imgbox.com/a1/df/A6gOtNMo_o.png" width="1200"></p> 
<blockquote> 
 <p>项目源码已经在Ubuntu 18.04和Windows10系统进行了验证；第三方依赖库只有opencv和opencv_contrib，如果你在其他系统平台开发，请自行配置好opencv和opencv_contrib开发环境；</p> 
</blockquote> 
<hr> 
<h3 id="3.%E5%8F%8C%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A">3.双目相机标定</h3> 
<h4 id="%C2%A0(1)%E5%8F%8C%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A-Python%E7%89%88"> (1)双目相机标定-Python版</h4> 
<p>请参考鄙人另一篇博客，无需Matlab，即可进行相机标定：<a href="https://blog.csdn.net/guyuealian/article/details/121301896" title="双目三维重建系统(双目标定+立体校正+双目测距+点云显示)Python">双目三维重建系统(双目标定+立体校正+双目测距+点云显示)Python</a></p> 
<p>该方法双目标定完成后，会得到一个双目相机内外参数信息(<strong><code>stereo_cam.yml</code></strong>)文件:</p> 
<div> 
 <pre><code class="language-XML">%YAML:1.0
---
size: !!opencv-matrix
   rows: 2
   cols: 1
   dt: d
   data: [ 640., 480. ]
K1: !!opencv-matrix
   rows: 3
   cols: 3
   dt: d
   data: [ 7.6159209686584518e+02, 0., 3.2031427422505453e+02, 0.,
       7.6167321445963728e+02, 2.2467546927337131e+02, 0., 0., 1. ]
D1: !!opencv-matrix
   rows: 1
   cols: 5
   dt: d
   data: [ 3.4834574885170888e-02, -5.5261651661983137e-02,
       5.7491952731614823e-04, -4.2764224824172658e-05,
       1.8477350140315381e-02 ]
K2: !!opencv-matrix
   rows: 3
   cols: 3
   dt: d
   data: [ 7.6327773941976670e+02, 0., 2.8768149948082271e+02, 0.,
       7.6350419442870850e+02, 2.1897333598636970e+02, 0., 0., 1. ]
D2: !!opencv-matrix
   rows: 1
   cols: 5
   dt: d
   data: [ 3.5020972475517692e-02, -4.0770660841280497e-02,
       -4.4231087565750534e-04, -1.0552562170995372e-03,
       -9.7749906830348537e-02 ]
R: !!opencv-matrix
   rows: 3
   cols: 3
   dt: d
   data: [ 9.9999370552351063e-01, 7.8563885326366346e-04,
       3.4600122760633780e-03, -7.9503151737356746e-04,
       9.9999600079883766e-01, 2.7140949167922721e-03,
       -3.4578661403601796e-03, -2.7168286517956050e-03,
       9.9999033095517087e-01 ]
T: !!opencv-matrix
   rows: 3
   cols: 1
   dt: d
   data: [ -6.0005833133148414e+01, 1.7047017063672587e-01,
       6.0300223404957642e-01 ]
E: !!opencv-matrix
   rows: 3
   cols: 3
   dt: d
   data: [ -1.1005724987007073e-04, -6.0346296076620343e-01,
       1.6883191705475561e-01, 3.9550629985097430e-01,
       -1.6255182474732952e-01, 6.0007339329190145e+01,
       -1.2276256904913259e-01, -6.0005727085740176e+01,
       -1.6345135556766910e-01 ]
F: !!opencv-matrix
   rows: 3
   cols: 3
   dt: d
   data: [ -6.7250769136371160e-10, -3.6870834234286016e-06,
       1.6143104894409041e-03, 2.4160347372858321e-06,
       -9.9287680075344234e-07, 2.7862421257891157e-01,
       -1.1014218394645766e-03, -2.7856049650040260e-01, 1. ]
R1: !!opencv-matrix
   rows: 3
   cols: 3
   dt: d
   data: [ 9.9997618806974742e-01, -2.0278309638726887e-03,
       -6.5963016213173775e-03, 2.0367881225372914e-03,
       9.9999701250432615e-01, 1.3514719999064883e-03,
       6.5935413581266105e-03, -1.3648750875444691e-03,
       9.9997733090723306e-01 ]
R2: !!opencv-matrix
   rows: 3
   cols: 3
   dt: d
   data: [ 9.9994547731576255e-01, -2.8407384289991728e-03,
       -1.0048512373976153e-02, 2.8270879178959596e-03,
       9.9999506202764499e-01, -1.3724045434755307e-03,
       1.0052361397026631e-02, 1.3439216883706559e-03,
       9.9994857062992937e-01 ]
P1: !!opencv-matrix
   rows: 3
   cols: 4
   dt: d
   data: [ 7.3741438842621210e+02, 0., 3.1126281356811523e+02, 0., 0.,
       7.3741438842621210e+02, 2.2189782714843750e+02, 0., 0., 0., 1.,
       0. ]
P2: !!opencv-matrix
   rows: 3
   cols: 4
   dt: d
   data: [ 7.3741438842621210e+02, 0., 3.1126281356811523e+02,
       -4.4251577456670653e+04, 0., 7.3741438842621210e+02,
       2.2189782714843750e+02, 0., 0., 0., 1., 0. ]
Q: !!opencv-matrix
   rows: 4
   cols: 4
   dt: d
   data: [ 1., 0., 0., -3.1126281356811523e+02, 0., 1., 0.,
       -2.2189782714843750e+02, 0., 0., 0., 7.3741438842621210e+02, 0.,
       0., 1.6664137886344466e-02, 0. ]
</code></pre> 
</div> 
<p>参数说明： </p> 
<blockquote> 
 <ul><li>参数size，对应图像宽高(width,height)</li><li>参数K1，对应左目相机<strong>内参矩阵</strong>(3×3)</li><li>参数D1，对应左目相机<strong>畸变系数矩阵</strong>(5×1)</li><li>参数K2，对应右目相机<strong>内参矩阵</strong>(3×3)</li><li>参数D2，对应右目相机<strong>畸变系数矩阵</strong>(5×1)</li><li>参数T，对应双目相机<strong>平移向量</strong>T(3×1)</li><li>参数R，对应双目相机<strong>旋转矩阵</strong>R(3×3)</li><li>至于配置文件中的参数,如<strong>R1, R2, P1, P2, Q</strong>这些重投影矩阵，可默写即可，不用修改，这些在运行时，会重新计算。</li></ul> 
</blockquote> 
<h4 id="%C2%A0(2)%E5%8F%8C%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A-Matlab%E7%89%88"> (2)双目相机标定-Matlab版</h4> 
<p>网上已经存在很多Matlab双目相机标定的教程，请自行百度哈 ；使用Matlab工具箱进行双目相机标定后，请对应参数进行修改</p> 
<blockquote> 
 <p>需要注意的是：<strong>旋转矩阵</strong>R是(3×3)二维矩阵，而Matlab给出的是旋转向量om(1×3)，请使用cv2.Rodrigues()将旋转向量转为旋转矩阵，参考下面的代码进行转换</p> 
</blockquote> 
<div> 
 <pre><code class="language-python">    import cv2
    import numpy as np

    # 定义旋转矩阵R，旋转向量om
    R = [[9.9999370551606337e-01, 7.8563882630048958e-04, 3.4600144345510440e-03],
         [-7.9503149273969136e-04, 9.9999600080163187e-01, 2.7140938945082542e-03],
         [-3.4578682997252063e-03, -2.7168276311286426e-03, 9.9999033095047696e-01]]
    R = np.asarray(R)
    print(f"旋转矩阵R:\n {R}")
    # 把旋转矩阵R转化为旋转向量om
    om, _ = cv2.Rodrigues(R)
    print(f"旋转向量om:\n {om}")
    # 把旋转向量om转换为旋转矩阵R
    R1, _ = cv2.Rodrigues(om)
    print(f"旋转矩阵R1:\n {R1}")
</code></pre> 
</div> 
<hr> 
<h3 id="4.%E7%9B%B8%E6%9C%BA%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE">4.相机参数配置</h3> 
<ul><li>双目相机标定完成后，得到了相机内外参数信息</li><li>根据自己相机参数定义C++的<code>CameraParam</code>即可</li><li>下面C++代码中，定义了双目相机CameraParam变量camera1，用户需要根据自己的双目相机，修改对应的相机内外参数。</li></ul> 
<div> 
 <pre><code class="language-cpp">
/**
 * 双目摄像头的相机参数
 */
struct CameraParam {
int width;           //图像的宽度width
int height;          //图像的高度height
Mat cameraMatrixL;   //左相机内参K1(3×3)
Mat distCoeffL;      //左相机畸变系数D1(5×1)
Mat cameraMatrixR;   //右相机内参K2(3×3)
Mat distCoeffR;      //右相机畸变系数D2(5×1)
Mat T;               //平移向量T(3×1)
Mat R;               //旋转矩阵R(3×3)，如果是(3×1)旋转向量，请使用cv::Rodrigues()进行变换转为(3×3)旋转矩阵R
};

/***
 * 设置摄像头参数，需要根据双目摄像头标定结果进行填写
 */
static CameraParam camera1 = {
640,//width
480,//height
(Mat_&lt;double&gt;(3, 3)
&lt;&lt; 7.6159209686633153e+02, 0., 3.2031427422691633e+02, 0., 7.6167321446015626e+02, 2.2467546926913309e+02, 0., 0., 1.),//cameraMatrixL
(Mat_&lt;double&gt;(5, 1)
&lt;&lt; 3.4834574887256914e-02, -5.5261651680159028e-02, 5.7491952534806736e-04, -4.2764223950233445e-05, 1.8477350164208820e-02),//distCoeffL
(Mat_&lt;double&gt;(3, 3)
&lt;&lt; 7.6327773983796783e+02, 0., 2.8768149776326379e+02, 0., 7.6350419482215057e+02, 2.1897333669573928e+02, 0., 0., 1.),
(Mat_&lt;double&gt;(5, 1)
&lt;&lt; 3.5020967512300320e-02, -4.0770565902033332e-02, -4.4231049297594003e-04, -1.0552565496142535e-03, -9.7750314807571667e-02),
(Mat_&lt;double&gt;(3, 1)
&lt;&lt; -6.0005833075452117e+01, 1.7047023105446815e-01, 6.0300273851103448e-01),
(Mat_&lt;double&gt;(3, 3)
&lt;&lt; 9.9999370551606337e-01, 7.8563882630048958e-04, 3.4600144345510440e-03, -7.9503149273969136e-04, 9.9999600080163187e-01, 2.7140938945082542e-03, -3.4578682997252063e-03, -2.7168276311286426e-03, 9.9999033095047696e-01),
};
</code></pre> 
</div> 
<hr> 
<h3 id="5.%20%E5%8F%8C%E7%9B%AE%E6%B5%8B%E8%B7%9D">5. 双目测距</h3> 
<p>OpenCV C++版本的双目测距与Python版本双目测距的效果几乎一致，且性能更优，速度更快，基本可以达到<strong>工业级别测距精度</strong>。由于我们只考虑三维重建实现双目测距效果，因而去除了PCL和Open3d库三维显示效果，但依然保留了视差图，深度图等可视化效果，用户可以通过鼠标点击图像，即可获得对应的世界坐标以及深度距离信息。</p> 
<p>函数接口声明，都已经给出了详细的参数说明，为了方便大家学习，函数命名和实现逻辑与Python版本的几乎一致：</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="text-align:center;width:358px;"><strong><a class="link-info" href="https://blog.csdn.net/guyuealian/article/details/121301896" title="Python版本">Python版本</a></strong></td><td style="text-align:center;width:440px;"><strong><a class="link-info" href="https://panjinquan.blog.csdn.net/article/details/127446435" rel="nofollow" title="C++版本">C++版本</a></strong></td></tr><tr><td style="width:358px;"><img alt="6201b0393f4543cb8f4ba377592aad39.png" src="https://images2.imgbox.com/4f/e4/xiJM41ko_o.png">​</td><td style="width:440px;"><img alt="9dab0b5137da435b8affb8f414cc9a99.png" src="https://images2.imgbox.com/70/ee/DKikdZdJ_o.png">​</td></tr></tbody></table> 
<p></p> 
<div> 
 <pre><code class="language-cpp">//
// Created by 390737991@qq.com on 2022/10/6.
//

#ifndef CAMERA_CALIBRATION_RECONSTRUCT_CPP_STEREO_RECONSTRUCT_H
#define CAMERA_CALIBRATION_RECONSTRUCT_CPP_STEREO_RECONSTRUCT_H

#include &lt;opencv2/opencv.hpp&gt;
#include &lt;iostream&gt;

using namespace std;
using namespace cv;

cv::Mat xyz_coord;                                   //用于存放每个像素点距离相机镜头的三维坐标
cv::Point start;                                     //鼠标按下的起始点
cv::Rect buttonRect;                                 //定义矩形选框
bool buttonStatus = false;                           //是否选择对象


/**
 * 双目摄像头的相机参数
 */
struct CameraParam {
    int width;           //图像的宽度width
    int height;          //图像的高度height
    Mat cameraMatrixL;   //左相机内参K1(3×3)
    Mat distCoeffL;      //左相机畸变系数D1(5×1)
    Mat cameraMatrixR;   //右相机内参K2(3×3)
    Mat distCoeffR;      //右相机畸变系数D2(5×1)
    Mat T;               //平移向量T(3×1)
    Mat R;               //旋转矩阵R(3×3)，如果是(3×1)旋转向量，请使用cv::Rodrigues()进行变换转为(3×3)旋转矩阵R
};

/***
 * 设置摄像头参数，需要根据双目摄像头标定结果进行填写
 */
static CameraParam camera1 = {640,//width
                              480,//height
                              (Mat_&lt;double&gt;(3, 3)
                                      &lt;&lt; 7.6159209686633153e+02, 0., 3.2031427422691633e+02, 0., 7.6167321446015626e+02, 2.2467546926913309e+02, 0., 0., 1.),//cameraMatrixL
                              (Mat_&lt;double&gt;(5, 1)
                                      &lt;&lt; 3.4834574887256914e-02, -5.5261651680159028e-02, 5.7491952534806736e-04, -4.2764223950233445e-05, 1.8477350164208820e-02),//distCoeffL
                              (Mat_&lt;double&gt;(3, 3)
                                      &lt;&lt; 7.6327773983796783e+02, 0., 2.8768149776326379e+02, 0., 7.6350419482215057e+02, 2.1897333669573928e+02, 0., 0., 1.),
                              (Mat_&lt;double&gt;(5, 1)
                                      &lt;&lt; 3.5020967512300320e-02, -4.0770565902033332e-02, -4.4231049297594003e-04, -1.0552565496142535e-03, -9.7750314807571667e-02),
                              (Mat_&lt;double&gt;(3, 1)
                                      &lt;&lt; -6.0005833075452117e+01, 1.7047023105446815e-01, 6.0300273851103448e-01),
                              (Mat_&lt;double&gt;(3, 3)
                                      &lt;&lt; 9.9999370551606337e-01, 7.8563882630048958e-04, 3.4600144345510440e-03, -7.9503149273969136e-04, 9.9999600080163187e-01, 2.7140938945082542e-03, -3.4578682997252063e-03, -2.7168276311286426e-03, 9.9999033095047696e-01),
};

/***
 * 鼠标响应回调函数
 * @param event
 * @param x
 * @param y
 */
static void onMouse(int event, int x, int y, int, void *) {
    if (buttonStatus) {
        buttonRect.x = MIN(x, start.x);
        buttonRect.y = MIN(y, start.y);
        buttonRect.width = std::abs(x - start.x);
        buttonRect.height = std::abs(y - start.y);
    }

    switch (event) {
        case EVENT_LBUTTONDOWN:             //鼠标左按钮按下的事件
            start = Point(x, y);
            buttonRect = Rect(x, y, 0, 0);
            buttonStatus = true;
            cout &lt;&lt; "image(x,y)=" &lt;&lt; start;
            cout &lt;&lt; " world coords=(x,y,depth)=" &lt;&lt; xyz_coord.at&lt;Vec3f&gt;(start) &lt;&lt; endl;
            break;
        case EVENT_LBUTTONUP:               //鼠标左按钮释放的事件
            buttonStatus = false;
            if (buttonRect.width &gt; 0 &amp;&amp; buttonRect.height &gt; 0)
                break;
    }
}

/***
 * 显示图像
 * @param winname 窗口名称
 * @param image 图像
 * @param delay 显示延迟，0表示阻塞显示
 * @param flags 显示方式
 */
static void show_image(const string &amp;winname, cv::Mat &amp;image, int delay = 0, int flags = cv::WINDOW_AUTOSIZE) {
    cv::namedWindow(winname, flags);
    cv::imshow(winname, image);
    cv::waitKey(delay);
}

/***
 * 读取视频文件
 * @param video_file 视频文件
 * @param cap 视频流对象
 * @param width 设置图像的宽度
 * @param height 设置图像的高度
 * @param fps 设置视频播放频率
 * @return
 */
bool get_video_capture(string video_file, cv::VideoCapture &amp;cap, int width = -1, int height = -1, int fps = -1) {
    //VideoCapture video_cap;
    cap.open(video_file);
    if (width &gt; 0 &amp;&amp; height &gt; 0) {
        cap.set(cv::CAP_PROP_FRAME_WIDTH, width); //设置图像的宽度
        cap.set(cv::CAP_PROP_FRAME_HEIGHT, height); //设置图像的高度
    }
    if (fps &gt; 0) {
        cap.set(cv::CAP_PROP_FPS, fps);
    }
    if (!cap.isOpened())//判断是否读取成功
    {
        return false;
    }
    return true;
}

/***
 * 读取摄像头
 * @param camera_id 摄像头ID号，默认从0开始
 * @param cap 视频流对象
 * @param width 设置图像的宽度
 * @param height 设置图像的高度
 * @param fps 设置视频播放频率
 * @return
 */
bool get_video_capture(int camera_id, cv::VideoCapture &amp;cap, int width = -1, int height = -1, int fps = -1) {
    //VideoCapture video_cap;
    cap.open(camera_id);    //摄像头ID号，默认从0开始
    if (width &gt; 0 &amp;&amp; height &gt; 0) {
        cap.set(cv::CAP_PROP_FRAME_WIDTH, width); //设置捕获图像的宽度
        cap.set(cv::CAP_PROP_FRAME_HEIGHT, height);  //设置捕获图像的高度
    }
    if (fps &gt; 0) {
        cap.set(cv::CAP_PROP_FPS, fps);
    }
    if (!cap.isOpened()) //判断是否成功打开相机
    {
        return false;
    }
    return true;
}

class StereoReconstruct {
public:

    /***
     * 构造函数，初始化StereoReconstruct
     * @param camera 双目相机参数
     * @param use_wls 是否使用WLS滤波器对视差图进行滤波
     */
    StereoReconstruct(CameraParam camera, bool use_wls = true);

    /***
     * release
     */
    ~StereoReconstruct();

    /***
     * 开始双目测距任务
     * @param frameL
     * @param frameR
     */
    void task(Mat frameL, Mat frameR, int delay = 0);

    /***
     * 畸变校正和立体校正
     * @param imgL 左视图
     * @param imgR 右视图
     * @param rectifiedL 校正后左视图
     * @param rectifiedR 校正后右视图
     */
    void get_rectify_image(Mat &amp;imgL, Mat &amp;imgR, Mat &amp;rectifiedL, Mat &amp;rectifiedR);

    /***
     * 获得视差图
     * @param imgL 畸变校正和立体校正后的左视图
     * @param imgR 畸变校正和立体校正后的右视图
     * @param dispL 返回视差图
     * @param use_wls 是否使用WLS滤波器对视差图进行滤波
     */
    void get_disparity(Mat &amp;imgL, Mat &amp;imgR, Mat &amp;dispL, bool use_wls = true);//SGBM匹配算法

    /***
     * 计算像素点的3D坐标（左相机坐标系下）
     * @param disp 视差图
     * @param points_3d 返回三维坐标points_3d，三个通道分布表示(X,Y,Z)，其中Z是深度图depth, 即距离,单位是毫米(mm)
     * @param scale 单位变换尺度,默认scale=1.0,单位为毫米
     */
    void get_3dpoints(Mat &amp;disp, Mat &amp;points_3d, float scale = 1.0);

    /***
     * 将输入深度图转换为伪彩色图，方面可视化
     * @param depth
     * @param colormap
     */
    void get_visual_depth(cv::Mat &amp;depth, cv::Mat &amp;colormap, float clip_max = 6000.0);

    /***
     * 显示矫正效果
     * @param rectifiedL
     * @param rectifiedR
     */
    void show_rectify_result(cv::Mat rectifiedL, cv::Mat rectifiedR);

    /***
     * 可视化视差图和深度图
     * @param frameL
     * @param frameR
     * @param points_3d
     * @param disp
     * @param delay
     */
    void show_2dimage(Mat &amp;frameL, Mat &amp;frameR, Mat &amp;points_3d, Mat &amp;disp, int delay);

    /***
     * 显示Mat的最大最小值
     * @param src
     * @param vmin 最小值下限
     * @param vmax 最大值下限
     */
    void clip(cv::Mat &amp;src, float vmin, float vmax);

    /***
     * 显示Mat的最大最小值
     * @param src
     * @param th
     * @param vmin
     */
    void clip_min(cv::Mat &amp;src, float th, float vmin);


public:
    string depth_windows = "depth-color";             // 深度图的窗口名称
    int use_wls;                                      // 是否使用WLS滤波器对视差图进行滤波
    Size image_size;                                  // 图像宽高(width,height)
    Rect validROIL;                                   // 图像校正之后，会对图像进行裁剪，这里的左视图裁剪之后的区域
    Rect validROIR;                                   // 图像校正之后，会对图像进行裁剪，这里的右视图裁剪之后的区域
    Mat mapLx, mapLy, mapRx, mapRy;                   // 映射表
    Mat Rl, Rr, Pl, Pr, Q;                            // 校正后的旋转矩阵R，投影矩阵P, 重投影矩阵Q
    cv::Ptr&lt;cv::StereoSGBM&gt; sgbm;
};


#endif //CAMERA_CALIBRATION_RECONSTRUCT_CPP_STEREO_RECONSTRUCT_H
</code></pre> 
</div> 
<hr> 
<h3 id="6.%20%E8%BF%90%E8%A1%8CDemo">6. 运行Demo</h3> 
<ul><li>主程序main.cpp实现了三个Demo</li></ul> 
<blockquote> 
 <ol><li>测试demo视频文件: 这是使用摄像头录制的双目视频文件，用于测试效果双目测距的效果</li><li>测试双目摄像头(双USB连接线的双目摄像头)：用于测试双目摄像头，需要根据自己的摄像头修改ID号</li><li>测试一对左右相机图像效果</li></ol> 
</blockquote> 
<div> 
 <pre><code class="language-cpp">//
// 双目测距Demo
// Created by AI吃大瓜 on 2022/10/6.
//
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;iostream&gt;
#include "stereo_reconstruct.h"

/***
 * 测试demo视频文件
 * @return
 */
int test_video_file() {
    CameraParam camera = camera1;//双目相机参数
    bool use_wls = true;         //是否使用WLS滤波器对视差图进行滤波
    StereoReconstruct *detector = new StereoReconstruct(camera, use_wls);
    int imageWidth = camera1.width;      //单目图像的宽度
    int imageHeight = camera1.height;    //单目图像的高度
    string left_video = "../data/lenacv-video/left_video.avi";
    string right_video = "../data/lenacv-video/right_video.avi";
    VideoCapture capL, capR;
    bool retL = get_video_capture(left_video, capL, imageWidth, imageHeight);
    bool retR = get_video_capture(right_video, capR, imageWidth, imageHeight);
    Mat frameL, frameR;
    while (retL &amp;&amp; retR) {
        capL &gt;&gt; frameL;
        capR &gt;&gt; frameR;
        if (frameL.empty() or frameR.empty()) break;
        detector-&gt;task(frameL, frameR, 20);
    }
    capL.release();         //释放对相机的控制
    capR.release();         //释放对相机的控制
    delete detector;
    return 0;

}


/***
 * 测试双目摄像头(双USB连接线的双目摄像头)
 * @return
 */
int test_camera() {
    CameraParam camera = camera1;//双目相机参数
    bool use_wls = true;         //是否使用WLS滤波器对视差图进行滤波
    StereoReconstruct *detector = new StereoReconstruct(camera, use_wls);
    int imageWidth = camera1.width;       //单目图像的宽度
    int imageHeight = camera1.height;     //单目图像的高度
    int camera1 = 0;                      //左摄像头ID号(请修改成自己左摄像头ID号)
    int camera2 = 1;                      //右摄像头ID号(请修改成自己右摄像头ID号)
    VideoCapture capL, capR;
    bool retL = get_video_capture(camera1, capL, imageWidth, imageHeight);
    bool retR = get_video_capture(camera2, capR, imageWidth, imageHeight);
    Mat frameL, frameR;
    while (retL &amp;&amp; retR) {
        capL &gt;&gt; frameL;
        capR &gt;&gt; frameR;
        if (frameL.empty() or frameR.empty()) break;
        detector-&gt;task(frameL, frameR, 20);
    }
    capL.release();         //释放对相机的控制
    capR.release();         //释放对相机的控制
    delete detector;
    return 0;
}

/***
 * 测试一对左右图像
 * @return
 */
int test_pair_image_file() {
    CameraParam camera = camera1;//双目相机参数
    bool use_wls = true;         //是否使用WLS滤波器对视差图进行滤波
    StereoReconstruct *detector = new StereoReconstruct(camera, use_wls);
    Mat frameL = imread("../data/left.png", IMREAD_COLOR);
    Mat frameR = imread("../data/right.png", IMREAD_COLOR);
    detector-&gt;task(frameL, frameR, 0);
    delete detector;
    return 0;
}


int main() {
    //测试一对左右图像
    test_pair_image_file();
    //测试demo视频文件
    test_video_file();
    //测试双目摄像头(双USB连接线的双目摄像头)
    test_camera();
    return 0;
}
</code></pre> 
</div> 
<ul><li>终端运行脚本：<strong><code>bash build.sh</code></strong></li></ul> 
<div> 
 <pre><code class="language-cpp">#!/usr/bin/env bash
if [ ! -d "build/" ];then
  mkdir "build"
else
  echo "exist build"
fi
cd build
cmake ..
make -j4
sleep 1
./Demo</code></pre> 
</div> 
<hr> 
<h3 id="6.%E5%8F%8C%E7%9B%AE%E6%B5%8B%E8%B7%9D%E7%9A%84%E8%AF%AF%E5%B7%AE%E8%AF%B4%E6%98%8E">7.双目测距的误差说明</h3> 
<p> 双目测距的误差和精度说明：</p> 
<ul><li>有网友反馈，测量精度较差，在评估测量精度前，请严格按照博文进行相机标定，标定误差不能超过0.1，否则测距误差较大</li><li>理论上双目的测量精度可以达到毫米(mm)级别，但并非无条件的，根据上式可以看出，某点像素的深度精度取决于该点处估计的视差d的精度。假设视差d的误差恒定，当测量距离越远，得到的深度精度则越差，因此使用双目相机不适宜测量太远的目标。</li><li>如果想要对与较远的目标能够得到较为可靠的深度，一方面需要提高相机的基线距离，但是基线距离越大，左右视图的重叠区域就会变小，内容差异变大，从而提高立体匹配的难度，另一方面可以选择更大焦距的相机，然而焦距越大，相机的视域则越小，导致离相机较近的物体的距离难以估计。</li><li>理论上，深度方向的测量误差与测量距离的平方成正比，而X/Y方向的误差与距离成正比；而距离很近时，<strong>由于存在死角</strong>，会导致难以匹配的问题；想象一下，如果你眼前放置一块物体，那你左眼只能看到物体左侧表面，右眼同理只能看到物体右侧表面，这时由于配准失败，导致视差计算失败；这个问题在基线越长，问题就越严重</li><li>下图给出双目测距误差和测量距离的关系，一般有效的测量距离是<strong>0.6米到6米</strong>之间<img alt="" height="350" src="https://images2.imgbox.com/9e/b1/SsLGvCPe_o.png" width="600"></li></ul> 
<hr> 
<h3 id="9.%20%E5%8F%8C%E7%9B%AE%E6%B5%8B%E8%B7%9DDemo%EF%BC%88C%2FC%2B%2B%E7%89%88%E6%9C%AC%EF%BC%89">8. 双目三维重建项目代码（C/C++版本）</h3> 
<h4 id="7.%C2%A0%E6%95%88%E6%9E%9C%E5%9B%BE">(1)效果图</h4> 
<p>C++版本的双目测距与Python版本的效果几乎一致。从重建效果来看，未使用<strong>WLS滤波</strong>，其视差图出现了很多空洞，存在很多误匹配点；但使用<strong>WLS滤波后，视差图变得比较平滑，整体效果都有明显改善。</strong></p> 
<table align="center"><thead><tr><th style="text-align:center;">左视图</th><th style="text-align:center;">右视图</th></tr></thead><tbody><tr><td><img alt="5a3336fbf4af441a841d588af792f80a.png" src="https://images2.imgbox.com/c8/bc/U3OemA9l_o.png">​</td><td><img alt="ebd6856f807944fcb860151375cd4e87.png" src="https://images2.imgbox.com/e6/01/AnvPlezp_o.png">​</td></tr><tr><td style="text-align:center;"><strong>视差图(未滤波)</strong></td><td style="text-align:center;"><strong>深度图(未滤波)</strong></td></tr><tr><td><img alt="f8d06f5f839142eca3b921b19661c18b.png" src="https://images2.imgbox.com/a3/97/ceX4Wiso_o.png">​</td><td><img alt="d2b1c330bc164790abbc72ead1ee7bd5.png" src="https://images2.imgbox.com/09/81/DrYUaAPi_o.png">​</td></tr><tr><td style="text-align:center;"><strong>视差图(滤波后)</strong></td><td style="text-align:center;"><strong>深度图(滤波后)</strong></td></tr><tr><td><img alt="5e265a93d39442ba9a861a3090bd2b58.png" src="https://images2.imgbox.com/86/90/tXi6e1E2_o.png">​</td><td><img alt="b883a3e05140451499e1aeb99ae12434.png" src="https://images2.imgbox.com/c0/65/Hk23lMd5_o.png">​</td></tr></tbody></table> 
<ul><li> 运行主程序后，<span style="color:#fe2c24;"><strong>鼠标点击<code>depth-color</code>窗口的图像任意区域，终端会打印对应距离信息</strong></span></li></ul> 
<p><img alt="132861d6b5fd489f9e35ea7926eb5857.gif" src="https://images2.imgbox.com/a2/32/SREyYF5P_o.gif">​</p> 
<hr> 
<h4 id="8.%20%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD">(2)源码下载</h4> 
<p>OpenCV C++版本双目测距项目代码包含：<a href="https://mp.weixin.qq.com/s/ZiAranhL4NwlYdcJ1nsvRw" rel="nofollow" title="OpenCV C++双目摄像头实现双目测距">OpenCV C++双目摄像头实现双目测距</a></p> 
<p><img alt="" height="427" src="https://images2.imgbox.com/aa/2b/89VYRLLH_o.png" width="771">​</p> 
<p> <strong>【项目源码下载地址</strong>】<a href="https://mp.weixin.qq.com/s/ZiAranhL4NwlYdcJ1nsvRw" rel="nofollow" title="OpenCV C++双目摄像头实现双目测距">OpenCV C++双目摄像头实现双目测距</a></p> 
<blockquote> 
 <ul><li>支持双USB连接线的双目摄像头</li><li>支持使用WLS滤波器对视差图进行滤波</li><li>支持双目测距(鼠标点击图像即可获得其深度距离)</li><li>提供配套的opencv-4.3.0和opencv_contrib-4.3.0源码 （<span style="color:#fe2c24;">Linux系统需要自行编译；Windows10系统已提供opencv_contrib编译文件，可直接复用，无需重新编译</span>）</li><li>相比Python版本，C++版本性能更优，速度更快，可在Linux开发板运行，非常适合应用于无人机，智能小车测距避障等场景。</li><li><strong>支持Linux系统：</strong>项目源码已在Ubuntu 18.04系统验证通过（<span style="color:#fe2c24;">需要自行编译opencv-4.3.0和opencv_contrib-4.3.0</span>）</li><li><strong>支持Windows10系统：</strong>项目源码已在<strong>Windows10</strong>系统验证通过，配套了Visual Studio 2017项目，可直接使用</li><li>其他系统平台开发，请在配置好opencv和opencv_contrib开发环境</li></ul> 
</blockquote> 
<hr> 
<h3 id="8.%20%E5%8F%8C%E7%9B%AE%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%88Python%E7%89%88%E6%9C%AC%EF%BC%89">9. 双目三维重建项目代码（Python版本）</h3> 
<p>如果你需要Python版本的双目测距， 请查看鄙人另一篇博客《<a href="https://blog.csdn.net/guyuealian/article/details/121301896" title="双目三维重建系统(双目标定+立体校正+双目测距+点云显示)Python">双目三维重建系统(双目标定+立体校正+双目测距+点云显示)Python</a>》</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:0px;"><tbody><tr><td> 
    <div> 
     <div class="csdn-video-box"> 
      <iframe id="fjHYSF53-1666348974279" frameborder="0" src="https://live.csdn.net/v/embed/247210" allowfullscreen="true" data-mediaembed="csdn"></iframe> 
      <p>双目测距Demo视频</p> 
     </div> 
    </div> </td></tr></tbody></table> 
<hr> 
<h3 id="11.%20%E5%8F%8C%E7%9B%AE%E6%B5%8B%E8%B7%9DDemo%EF%BC%88Android%E7%89%88%E6%9C%AC%EF%BC%89">10. 双目三维重建项目代码（Android版本）</h3> 
<p>如果你需要Android版本的双目测距， 请查看鄙人另一篇博客《<a class="link-info" href="https://blog.csdn.net/guyuealian/article/details/129762989" title="Android OpenCV实现双目三维重建：双目摄像头实现双目测距">Android OpenCV实现双目三维重建：双目摄像头实现双目测距</a>》</p> 
<p style="text-align:center;"><img alt="" height="545" src="https://images2.imgbox.com/6e/1c/eDFWwLxc_o.gif" width="250">       <img alt="" height="545" src="https://images2.imgbox.com/cc/13/HaFb0nQA_o.gif" width="250"></p> 
<hr> 
<h3 id="9.%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">11.参考资料</h3> 
<ol><li><a href="https://blog.csdn.net/guyuealian/article/details/127446435" title="OpenCV C++双目三维重建：双目摄像头实现双目测距">OpenCV C++双目三维重建：双目摄像头实现双目测距</a></li><li><a href="https://blog.csdn.net/guyuealian/article/details/121870887" title="双目三维重建：双目摄像头实现双目测距（Python）">双目三维重建：双目摄像头实现双目测距（Python）</a></li><li><a href="https://blog.csdn.net/guyuealian/article/details/121301896" title="双目三维重建系统(双目标定+立体校正+双目测距+点云显示)Python">双目三维重建系统(双目标定+立体校正+双目测距+点云显示)Python</a></li><li><a href="https://blog.csdn.net/guyuealian/article/details/127400841" title="Ubuntu18.04安装opencv和opencv_contrib">Ubuntu18.04安装opencv和opencv_contrib</a></li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1a9e10c26106e8979b43a10a7d3cc92a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Redis 出现（error）NOAUTH Authentication required. 报错的解决办法，秒懂!</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/78e04bd5bbe03faa94eca2ff0332965a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">学习如何学习【笔记经验】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>