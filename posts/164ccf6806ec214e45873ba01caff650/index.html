<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>NodeJs 面试题 2023 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="NodeJs 面试题 2023" />
<meta property="og:description" content="（要知道对好事的称颂过于夸大，也会招来人们的反感轻蔑和嫉妒。——培根） ㅤㅤㅤ
ㅤㅤㅤ
ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ
NodeJs相关 什么是NodeJs
Nodejs是一个基于V8虚拟机的JavaScript的运行时平台，使用了事件驱动和非阻塞IO模型，让JavaScript能够像Java，PHP等语言一样运行在服务端 NodeJs优势
开发效率高，js动态语言， 不强制要求类型io性能强劲，依靠libuv，不用考虑多线程等复杂操作(线程创建和销毁，线程锁，线程管理)，降低开发成本有强大的npm包平台，类似Java的maven前后端语言统一，降低开发成本 NodeJs常见应用场景
web后端开发，目前流行的框架有express，koa，egg，nestjs等app后端开发，作为后端提供http等服务接口桌面端开发，比如用nw.js和electron.js框架开发桌面端应用web端服务器控制台后端开发，比如tty.js3D引擎建模和渲染，比如使用Three.js和Grimoire.js制作3D引擎游戏制作，比如使用pomelo.js和Phaser.js等制作网页游戏日常工作脚本，比如解析表格，统计数据等 和JavaScript的区别
JavaScript只能应用在前端，Nodejs可以让JavaScript运行在服务端JavaScript的全局对象是windows，而Node是GlobalJavaScript因为浏览器的差异要考虑兼容性，而Nodejs是服务端，所以不需要考虑兼容性Node的事件循环依赖底层libuv，JavaScript的事件循环依赖的是浏览器 和Java相比的区别
node是单线程，java是多线程node使用js语言，开发成本低，io多线程由libuv提供，省去了操作多线程的成本(比如多线程的创建和销毁，锁的管理，设计复杂)node是解释性语言，运行时才进行编译检查。而java是半编译半解释型语言node是弱类型语言，编码中不强制类型。java是强类型语言，编码中强制类型node使用的是js语言，前后端统一语言，降低开发成本，维护成本，前后端工具包通用，提高团队整体开发效率 NodeJs的优缺点
优点 js语言不强制要求类型，开发效率高前后端语言统一 降低团队的沟通成本，提高工作效率前后端的工具包可以通用全栈开发 性能强劲，node底层使用libuv管理多线程，利用异步事件模型来提高IO性能使用libuv不用关心多线程的创建和销毁，不用自己管理多线程，间接的提高了开发效率多进程提高服务性能，利用work子进程分担主进程的任务，也能间接的提高算力 缺点 js弱类型，可以动态更改类型，导致后期代码维护难度升高虽然底层有libuv提高io性能，也有多进程提高并发执行，但对于cpu密集型任务来说，依然是劣势。即便node10x版本提供了工作线程，但使用和管理起来过于麻烦因为是单线程，所以代码中任意一处发生的异常都是致命的，需要开发者谨慎处理异常 NodeJs特性都有哪些
事件驱动非阻塞io单线程(但io操作是多线程) NodeJs事件驱动是什么
典型的发布订阅模式，只有当事件发生的时候才会调用回调函数。其中会有一个事件队列不断的获取事件来执行 NodeJs事件驱动的优缺点
优点
适合处理密集型I/O任务：通过事件循环机制，多个并行的任务，在JavaScript处理起来，只是将不同的任务分配给不同的线程，等待返回结果执行即可。所以处理速度超级快，有很高的实时性。适合处理高并发：RESTful Api动辄发起成千上万条请求，但是请求本身并没有太多的计算量，开启多线程处理等待结果又太浪费机器性能。所以事件循环非常适合处理此种场景。适合处理少量业务逻辑：例如浏览器中，在处理用户交互事件，页面渲染等少量业务逻辑的场景上，具有很好实时性，能给用户提供很流畅的体验。 缺点
不适合cpu密集型应用：因为JavaScript单线程的设计，因此，对于高强度运算的任务，可能会因为运算能力有限，导致任务处理时间过长，影响后续任务执行。 解决办法 业务代码优化，将单个cpu密集型任务拆成多个子任务，留出一定时间间隔执行其他任务利用多进程提高服务处理能力利用工作线程提高计算能力 cpu利用率低：因为单线程的原因，cpu多核性能利用率低。 解决办法 利用多进程提高cpu多核利用率 安全性低：因为单线程的原因，如果主线程发生错误，将直接导致应用崩溃。 解决办法 添加全局异常过滤器，做默认异常处理做好线上监控，收到反馈时及时处理 NodeJs事件驱动原理
事件循环是 Node.js 处理非阻塞 I/O 操作的机制——尽管 JavaScript 是单线程处理的——当有可能的时候，它们会把操作转移到系统内核中去。
既然目前大多数内核都是多线程的，它们可在后台处理多种操作。当其中的一个操作完成的时候，内核通知 Node.js 将适合的回调函数添加到 轮询 队列中等待时机执行
详情请看NodeJs事件循环原理
libuv线程池运行原理
libuv最初是为nodejs编写的跨平台支持库。它是围绕事件驱动的异步 I/O 模型设计的
libuv 提供了一个线程池，可用于运行用户代码并在循环线程中获得通知。此线程池在内部用于运行所有文件系统操作，以及 getaddrinfo 和 getnameinfo 请求。
它的默认大小是 4，但可以在启动时通过将 UV_THREADPOOL_SIZE环境变量设置为任何值来更改它，最大支持1024个线程
线程池是全局的，并且在所有事件循环中共享。当特定函数使用线程池时（即使用时uv_queue_work()），libuv 会预先分配并初始化 允许的最大线程数 UV_THREADPOOL_SIZE。这会导致相对较小的内存开销，但会提高运行时线程的性能" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/164ccf6806ec214e45873ba01caff650/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-11T16:34:53+08:00" />
<meta property="article:modified_time" content="2023-06-11T16:34:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">NodeJs 面试题 2023</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h6><a id="center_0"></a> 
 <center>
   （要知道对好事的称颂过于夸大，也会招来人们的反感轻蔑和嫉妒。——培根） 
 </center></h6> 
<p>ㅤㅤㅤ<br> ㅤㅤㅤ<br> ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ<img src="https://images2.imgbox.com/73/01/axdMSovU_o.jpg" alt="在这里插入图片描述"></p> 
<h4><a id="NodeJs_4"></a>NodeJs相关</h4> 
<ul><li> <p>什么是NodeJs</p> 
  <ul><li>Nodejs是一个基于V8虚拟机的JavaScript的运行时平台，使用了事件驱动和非阻塞IO模型，让JavaScript能够像Java，PHP等语言一样运行在服务端</li></ul> </li><li> <p>NodeJs优势</p> 
  <ul><li>开发效率高，js动态语言， 不强制要求类型</li><li>io性能强劲，依靠libuv，不用考虑多线程等复杂操作(线程创建和销毁，线程锁，线程管理)，降低开发成本</li><li>有强大的npm包平台，类似Java的maven</li><li>前后端语言统一，降低开发成本</li></ul> </li><li> <p>NodeJs常见应用场景</p> 
  <ul><li>web后端开发，目前流行的框架有express，koa，egg，nestjs等</li><li>app后端开发，作为后端提供http等服务接口</li><li>桌面端开发，比如用nw.js和electron.js框架开发桌面端应用</li><li>web端服务器控制台后端开发，比如tty.js</li><li>3D引擎建模和渲染，比如使用Three.js和Grimoire.js制作3D引擎</li><li>游戏制作，比如使用pomelo.js和Phaser.js等制作网页游戏</li><li>日常工作脚本，比如解析表格，统计数据等</li></ul> </li><li> <p>和JavaScript的区别</p> 
  <ul><li>JavaScript只能应用在前端，Nodejs可以让JavaScript运行在服务端</li><li>JavaScript的全局对象是windows，而Node是Global</li><li>JavaScript因为浏览器的差异要考虑兼容性，而Nodejs是服务端，所以不需要考虑兼容性</li><li>Node的事件循环依赖底层libuv，JavaScript的事件循环依赖的是浏览器</li></ul> </li><li> <p>和Java相比的区别</p> 
  <ul><li>node是单线程，java是多线程</li><li>node使用js语言，开发成本低，io多线程由libuv提供，省去了操作多线程的成本(比如多线程的创建和销毁，锁的管理，设计复杂)</li><li>node是解释性语言，运行时才进行编译检查。而java是半编译半解释型语言</li><li>node是弱类型语言，编码中不强制类型。java是强类型语言，编码中强制类型</li><li>node使用的是js语言，前后端统一语言，降低开发成本，维护成本，前后端工具包通用，提高团队整体开发效率</li></ul> </li><li> <p>NodeJs的优缺点</p> 
  <ul><li>优点 
    <ul><li>js语言不强制要求类型，开发效率高</li><li>前后端语言统一 
      <ul><li>降低团队的沟通成本，提高工作效率</li><li>前后端的工具包可以通用</li><li>全栈开发</li></ul> </li><li>性能强劲，node底层使用libuv管理多线程，利用异步事件模型来提高IO性能</li><li>使用libuv不用关心多线程的创建和销毁，不用自己管理多线程，间接的提高了开发效率</li><li>多进程提高服务性能，利用work子进程分担主进程的任务，也能间接的提高算力</li></ul> </li><li>缺点 
    <ul><li>js弱类型，可以动态更改类型，导致后期代码维护难度升高</li><li>虽然底层有libuv提高io性能，也有多进程提高并发执行，但对于cpu密集型任务来说，依然是劣势。即便node10x版本提供了工作线程，但使用和管理起来过于麻烦</li><li>因为是单线程，所以代码中任意一处发生的异常都是致命的，需要开发者谨慎处理异常</li></ul> </li></ul> </li><li> <p>NodeJs特性都有哪些</p> 
  <ul><li>事件驱动</li><li>非阻塞io</li><li>单线程(但io操作是多线程)</li></ul> </li><li> <p>NodeJs事件驱动是什么</p> 
  <ul><li>典型的发布订阅模式，只有当事件发生的时候才会调用回调函数。其中会有一个事件队列不断的获取事件来执行</li></ul> </li><li> <p>NodeJs事件驱动的优缺点</p> 
  <ul><li> <p>优点</p> 
    <ul><li>适合处理<strong>密集型I/O任务</strong>：通过事件循环机制，多个并行的任务，在JavaScript处理起来，只是将不同的任务分配给不同的线程，等待返回结果执行即可。所以处理速度超级快，有很高的实时性。</li><li>适合处理<strong>高并发</strong>：RESTful Api动辄发起成千上万条请求，但是请求本身并没有太多的计算量，开启多线程处理等待结果又太浪费机器性能。所以事件循环非常适合处理此种场景。</li><li>适合处理<strong>少量业务逻辑</strong>：例如浏览器中，在处理用户交互事件，页面渲染等少量业务逻辑的场景上，具有很好实时性，能给用户提供很流畅的体验。</li></ul> </li><li> <p>缺点</p> 
    <ul><li>不适合cpu密集型应用：因为JavaScript单线程的设计，因此，对于高强度运算的任务，可能会因为运算能力有限，导致任务处理时间过长，影响后续任务执行。 
      <ul><li>解决办法 
        <ul><li>业务代码优化，将单个cpu密集型任务拆成多个子任务，留出一定时间间隔执行其他任务</li><li>利用多进程提高服务处理能力</li><li>利用工作线程提高计算能力</li></ul> </li></ul> </li><li>cpu利用率低：因为单线程的原因，cpu多核性能利用率低。 
      <ul><li>解决办法 
        <ul><li>利用多进程提高cpu多核利用率</li></ul> </li></ul> </li><li>安全性低：因为单线程的原因，如果主线程发生错误，将直接导致应用崩溃。 
      <ul><li>解决办法 
        <ul><li>添加全局异常过滤器，做默认异常处理</li><li>做好线上监控，收到反馈时及时处理</li></ul> </li></ul> </li></ul> </li></ul> </li><li> <p>NodeJs事件驱动原理</p> 
  <ul><li> <p>事件循环是 Node.js 处理非阻塞 I/O 操作的机制——尽管 JavaScript 是单线程处理的——当有可能的时候，它们会把操作转移到系统内核中去。</p> <p>既然目前大多数内核都是多线程的，它们可在后台处理多种操作。当其中的一个操作完成的时候，内核通知 Node.js 将适合的回调函数添加到 <em>轮询</em> 队列中等待时机执行</p> </li><li> <p><a href="https://blog.csdn.net/qq_42427109/article/details/125301276?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22125301276%22,%22source%22:%22qq_42427109%22%7D&amp;ctrtid=5OEVl">详情请看NodeJs事件循环原理</a></p> </li></ul> </li><li> <p>libuv线程池运行原理</p> 
  <ul><li> <p>libuv最初是为nodejs编写的跨平台支持库。它是围绕事件驱动的异步 I/O 模型设计的</p> </li><li> <p>libuv 提供了一个线程池，可用于运行用户代码并在循环线程中获得通知。此线程池在内部用于运行所有文件系统操作，以及 getaddrinfo 和 getnameinfo 请求。</p> <p>它的默认大小是 4，但可以在启动时通过将 <code>UV_THREADPOOL_SIZE</code>环境变量设置为任何值来更改它，最大支持1024个线程</p> </li><li> <p>线程池是全局的，并且在所有事件循环中共享。当特定函数使用线程池时（即使用时<a href="http://docs.libuv.org/en/latest/threadpool.html#c.uv_queue_work" rel="nofollow"><code>uv_queue_work()</code></a>），libuv 会预先分配并初始化 允许的最大线程数 <code>UV_THREADPOOL_SIZE</code>。这会导致相对较小的内存开销，但会提高运行时线程的性能</p> </li></ul> </li><li> <p>NodeJs如何使用libuv中的线程池</p> 
  <ul><li>node通过使用node-gyp将c++代码编译成.node文件，然后在js内部引入就可以使用了。</li><li>通过c++提供的接口，在node里就可以利用libuv驱动来使用系统资源了</li></ul> </li><li> <p>NodeJs事件驱动和浏览器的事件循环区别是什么</p> 
  <ul><li> <p>浏览器的事件循环队列分为macro（宏任务）队列和 micro（微任务）队列。宏任务队列可以有多个</p> </li><li> <p>当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。</p> </li><li> <p>比如以下代码就能够很明显的看出浏览器事件循环和nodejs事件循环的区别</p> <pre><code class="prism language-typescript"><span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'children2'</span><span class="token punctuation">)</span>
        <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'children2-1'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'children3'</span><span class="token punctuation">)</span>
        <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'children3-1'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'children1'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 以上代码在node11以下版本的执行结果(先执行所有的宏任务，再执行微任务)</span>
<span class="token comment">// start</span>
<span class="token comment">// end</span>
<span class="token comment">// children1</span>
<span class="token comment">// children2</span>
<span class="token comment">// children3</span>
<span class="token comment">// children2-1</span>
<span class="token comment">// children3-1</span>

<span class="token comment">// 以上代码在node11及浏览器的执行结果(顺序执行宏任务和微任务)</span>
<span class="token comment">// start</span>
<span class="token comment">// end</span>
<span class="token comment">// children1</span>
<span class="token comment">// children2</span>
<span class="token comment">// children2-1</span>
<span class="token comment">// children3</span>
<span class="token comment">// children3-1</span>
</code></pre> </li></ul> </li><li> <p>浏览器线程模型</p> 
  <ul><li> <p><a href="https://chromium.googlesource.com/chromium/src/+/main/docs/threading_and_tasks.md#Threads" rel="nofollow">chrom线程模型</a></p> </li><li> <p><img src="https://images2.imgbox.com/dc/f3/LmTUT8Jl_o.png" alt="在这里插入图片描述"></p> </li><li> <p>chrom是多进程+多线程的，对于每一个chrom进程，它都有一个主线程用来处理UI和JS代码，还有一个IO线程用来处理网络请求。</p> </li></ul> </li><li> <p>NodeJs如何提升性能和代码质量</p> 
  <ul><li>提高性能 
    <ul><li>node自身 
      <ul><li>多用promise并行处理io，或者其他的第三方异步io库，比如async，bluebird</li><li>减少同步代码，多使用异步</li><li>使用typescript，虽然开发成本提高了，但性能会提升。因为动态类型的代码，v8虚拟机在运行的时候会反复的执行优化，如果不更改类型，那么就不会触发v8虚拟机的反优化。也是一个提高性能的手段</li><li>使用多进程，充分利用CPU的多核机制。提高处理非IO类业务的性能</li></ul> </li><li>数据库 
      <ul><li>热点数据使用缓存设计，比如使用redis进行存储</li><li>数据库分库分表，减小库和表的数据大小，提高检索性能。数据量的减少意味着检索范围也会缩小，从而提升了性能 
        <ul><li>分库(适用于系统全局化处理) 
          <ul><li>比如后台有定时脚本，每天凌晨遍历目前所有库/指定库的大小，如果某库的磁盘空间占用大于100g，则按照日期规则，使用日期作为后缀进行分库，然后将该库作为新租户/用户库</li></ul> </li><li>分表(适用于针对某业务模块或某租户) 
          <ul><li>比如后台有定时脚本，每天凌晨遍历所有库/指定库内表的大小，对超过2gb或者3gb的，按照日期规则，使用日期作为后缀进行分表，然后将该表作为新租户/用户的表</li></ul> </li><li>分库分表后带来的问题 
          <ul><li>如果设计不当，则导致租户/用户的数据分散存储在不同的库和表中，导致后期维护困难，所以我们尽量让他们之间独立，每个租户/用户只使用一个分库，分库下的表可以根据大小进行分表，新业务和分表呈一对一的关系。就业务的表不再分表处理，而是做冷热数据处理</li></ul> </li></ul> </li><li>数据库表添加索引，对热点字段建立索引，提高检索性能。数据库性能提升的主要方式之一</li><li>sql优化 
        <ul><li>为热点数据建立合适的索引，唯一索引，组合索引等</li><li>使用projection只查询需要的字段，避免返回多余的字段</li><li>比如mongodb数据库，避免使用"<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
              
               
                
                
                  n 
                 
                
                  e 
                 
                
                  " 
                 
                
                  ， 
                 
                
                  " 
                 
                
               
                 ne"，" 
                
               
             </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord">"</span><span class="mord cjk_fallback">，</span><span class="mord">"</span></span></span></span></span>exist"，"<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
              
               
                
                
                  n 
                 
                
                  o 
                 
                
                  t 
                 
                
                  " 
                 
                
                  ， 
                 
                
                  " 
                 
                
               
                 not"，" 
                
               
             </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord">"</span><span class="mord cjk_fallback">，</span><span class="mord">"</span></span></span></span></span>nin"等字段，这些字段在查询时不会使用索引，所以检索性能较差</li><li>限制返回的结果数，比如limit。当结果数过多时，会降低性能</li><li>表字段内容不要过大，比如几m，几十m的那种。过大的字段会在保存和查询的时候降低性能</li><li>表字段优化，避免因过度设计而导致的冗余字段降低性能，比如加入了未来5-10年的发展中，业务可能需要的字段</li></ul> </li></ul> </li><li>数据库集群 以mongodb为例 
      <ul><li>使用副本集，读写分离，提高检索性能</li><li>当数据量达到千万，亿级别时可以使用分片。副本集虽然读写分离，但数据的存储并没有分离。mongodb的分片解决了这个问题，相比较副本集，一个副本存储了所有数据库，但分片等于一个副本的数据分别存储到数十个，数百个分片中。查询的时候，同时从这些分片中进行查询，将查询的性能又提高了一个档次 
        <ul><li>用户的请求会发送给 mongos 路由服务器, 路由服务器会根据查询条件去配置服务器查询对应的数据段和属于哪个分片服务器, 如果用户查询的条件是分片片键字段, 那么路由服务器会返回保存在那一台分片服务器上, 路由服务器就会去对应的分片服务器获取数据, 并将取到的数据返回给用户。</li><li>如果用户查询的条件不是分片片键字段, 那么配置服务器无法告知路由服务器数据保存在哪一个分片服务器上，路由服务器会把请求发送到所有的分片服务器上, 然后再将查询到的数据汇总后返回给用户。</li></ul> </li><li>冷热数据分离，根据租户/用户的活跃时间，将不活跃用户(比如最近两年没有登陆过)的数据迁移至冷数据库集群中(副本集较少，配置较低，分片数少的集群)，这样就可以减少主集群的数据量，提高磁盘空间和检索性能。当不活跃用户由活跃时，通过后台脚本或者服务将该用户的数据再进行回迁即可。</li></ul> </li><li>架构优化 
      <ul><li>不使用框架，使用原生js进行编码(对团队素质和技术能力要求极高)。因为现在的流行框架大多都加入了一些实际业务不需要的代码，间接的拖慢了服务性能</li><li>提高硬件配置，比如内存，cpu，带宽等</li><li>横向扩展服务集群，搭配负载均衡策略，提高服务的整体吞吐量和性能</li><li>使用k8s容器化管理，使用沙箱隔离服务间环境(减少服务间的影响)，合理分配每个服务运行环境的pod配置，既提高服务性能还能提高稳定性</li></ul> </li></ul> </li><li>提高质量 
    <ul><li>使用typescript，集成eslint，避免使用any，提前检查错误，减少bug出现率</li><li>审查代码，每次代码版本测试/发布前进行审查，及时对有问题的代码进行优化和修复</li><li>核心代码编写注释，方便后期维护和二次开发</li><li>抽象通用组件，提高代码复用性，减少冗余代码</li><li>编写测试单元，发版前运行测试单元</li></ul> </li><li>提高服务高稳定性 
    <ul><li>完善系统监控，比如使用grafana实时监测服务的cpu，内存，硬盘，IO等</li><li>完善日志分析系统，比如使用业界流行的kibana日志分析平台 
      <ul><li>完善的日志检索功能</li><li>完善的可视化图标分析</li></ul> </li><li>完善服务整体高可用性，比如使用k8s生态，rancher，harbor等 
      <ul><li>服务发现和负载均衡 
        <ul><li>Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定</li></ul> </li><li>滚动发布 
        <ul><li>每次先关闭一个pod，再重启一个pod，可以保证服务不中断的情况下进行系统升级</li></ul> </li><li>镜像回滚 
        <ul><li>利用harbor和rancher对镜像进行管理，可以使用界面或命令进行一键回滚</li></ul> </li><li>自动完成装箱计算 
        <ul><li>Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源</li></ul> </li><li>自我修复 
        <ul><li>Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器</li></ul> </li><li>密钥与配置管理 
        <ul><li>Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥</li></ul> </li><li>更便捷的水平扩展 
        <ul><li>通过rancher等可视化界面，可以快速的对pod进行管理，比如新增，删除，调整pod的资源等</li></ul> </li><li>健康检查 
        <ul><li>k8s会对每一个pod做定时的健康检查，对于非健康的pod，k8s会对它做重启处理</li></ul> </li></ul> </li></ul> </li></ul> </li><li> <p>常用的排序算法</p> <pre><code class="prism language-typescript"><span class="token comment">/**
 * @event 快速排序
 * @description 
 * 
 * 快速排序是对冒泡排序的一种改进。它的基本思想是：
 * 通过一趟排序将要排序的数据分割成独立的两部分，
 * 其中一部分的所有数据都比另外一不部分的所有数据都要小，
 * 然后再按此方法对这两部分数据分别进行快速排序，
 * 整个排序过程可以递归进行，以此达到整个数据变成有序序列。
 * 整个排序过程只需要三步：
1. 找到该数组的基准点(中间数)，并创建两个空数组left和right；
2. 遍历数组，拿出数组中的每个数和基准点进行比较，
   如果比基准点小就放到left数组中，如果比基准点大就放到right数组中；
3. 对数组left和right进行递归调用
 */</span>

<span class="token comment">//第一种方式（类似二分法，一直缩小范围）</span>
<span class="token comment">//先处理leftArr的递归，再处理rightArr的递归</span>
<span class="token keyword">const</span> <span class="token function-variable function">arrSortFast</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> leftArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> rightArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//每次删除一个数组元素并获得返回值当作基数，直到数组被删除到只剩下一个时，直接返回</span>
    <span class="token comment">//Math.round 向上取整 3.5取4 3.3取3</span>
    <span class="token keyword">const</span> baseNumber <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>v <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">&lt;</span> baseNumber<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            leftArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            rightArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">arrSortFast</span><span class="token punctuation">(</span>leftArr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span>baseNumber<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">arrSortFast</span><span class="token punctuation">(</span>rightArr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">arrSortFast</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/**
 * 算法解析
 * 第一阶段：
 * 取出中位数 9
 * 当前数组为 [5, 3, 6, 10, 2, 4, 7, 1, 8]
 * 经过左右过滤
 * 左数组为 [5, 3, 6, 2, 4, 7, 1, 8]
 * 右数组为 [10]
 * 
 * 第二阶段：使用左数组继续递归
 * 取出中位数 4
 * 左数组为 [3, 2, 1]
 * 右数组为 [5, 6, 7, 8]
 * 
 * 第二阶段继续：使用左数组继续递归
 * 取出中位数 2
 * 左数组为 1
 * 右数组为3
 * 由于过滤的只剩下最后一个，所以直接返回
 * 此时结果为[1, 2, 3]
 * 
 * 第二阶段继续：使用右数组进行递归
 * 取出中位数7
 * 左数组为 [5, 6] 超过两个元素的都会进行再次递归 那么此时得到的结果肯定也是[5, 6]
 * 右数组为 [8]
 * 此时结果为 [5, 6, 7, 8]
 * 
 * 此时已经得到过滤后的左右数组分别为[1, 2, 3]和[5, 6, 7, 8]，中位数是4
 * 那么此时结果为[1, 2, 3, 4, 5, 6, 7, 8]
 * 
 * 当前回到第一阶段
 * [5, 3, 6, 2, 4, 7, 1, 8]过滤后的结果为[1, 2, 3, 4, 5, 6, 7, 8]
 * 中位数是9 右数组是[10]
 * 那么此时最终结果为[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 */</span>




<span class="token comment">/**
 * 冒泡排序法
 * 相邻比较
 */</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> length <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">// 单层for循环</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">let</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 在循环到最大值时候重置j(j=-1到上面j++重置为0)这样可以省了外层for循环</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            length<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/**
 * 第一阶段过滤得到结果
 * [3, 4, 5, 4, 1, 3, 2, 0, 3, 88, 99]
 * 
 * 第二阶段过滤 此时把长度-1
 * [3, 4, 5, 1, 3, 2, 0, 3, 4, 88, 99]
 * 
 * 第三阶段过滤
 * [3, 4, 1, 3, 2, 0, 3, 4, 5, 88, 99]
 * 
 * 第四阶段过滤
 * [3, 1, 3, 2, 0, 3, 4, 4, 5, 88, 99]
 * 
 * 以此类推 一直比较 得到结果
 */</span>

<span class="token comment">/**
 * 选择排序
 * 选择某一个元素当作最小数依次遍历
 * 每次找到最小值和前面的位置进行替换
 */</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">let</span> minIndex<span class="token punctuation">;</span>
    <span class="token keyword">let</span> temp<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">//选择当前下标为最小元素</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>     <span class="token comment">//每一次从i+1个开始遍历找出比自身小的元素</span>
                minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>                 <span class="token comment">//将最小数的索引保存</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//接下来的操作类似冒泡，都是互换元素位置</span>
        temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
        arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p>Http七层协议工作原理，都有哪些状态码，分别是什么意思</p> 
  <ul><li> <p>为什么需要协议？</p> 
    <ul><li>如果苹果，三星，华为都是自己的协议，那么就只能和自己通信，所以就弄一个标准化的协议，所有人来实现，这样所有人就能互通了</li></ul> </li><li> <p>四层协议关系</p> 
    <ul><li>应用层：http协议，邮件服务协议</li><li>传输层：TCP协议 
      <ul><li>SYN 建立连接</li><li>FIN 关闭连接</li><li>ACK 响应连接</li><li>PSH DATA数据传输</li><li>RST 连接重置</li></ul> </li><li>网络层：IP协议</li><li>数据链路层：以太网协议</li></ul> </li><li> <p>端口号范围0-65535，1024之前不允许用</p> </li><li> <p>物理层</p> 
    <ul><li>过去：通过家里的猫来连接网线实现电脑间的通信，这个就属于物理层</li><li>现在：连接无线网，属于无线讯号，也是物理层</li><li>连接上之后传递010101的电路信号</li></ul> </li><li> <p>数据链路层</p> 
    <ul><li>是给电路信号分配规则的，过去每个公司都有自己的电路信号规则。</li><li>后来出现了以太网协议，将电信号归纳成一个数据包，也叫一个帧。 
      <ul><li>每一帧都分成两部分，标头head和数据data</li><li>标头head包含了一些说明信息，比如发送者mac地址，接收者mac地址和数据类型等</li></ul> </li><li>而电路信号的通信又依赖网卡，利用电脑间的网卡进行通信 
      <ul><li>以太网协议规定网卡包含mac地址，mac地址是网卡的唯一标识，全球唯一 
        <ul><li>12个16进制的数字表示mac地址</li><li>前6个16进制数字是厂商编号</li></ul> </li><li>后6个16进制数字是网卡流水号 
        <ul><li>windows使用ipconfig命令查看mac地址 物理地址 比如7C-67-A2-20-AB-5C</li><li>linux使用ifconfig -a命令查看mac地址</li></ul> </li><li>所以以太网传递数据包就必须指定接收者的mac地址才能进行传输</li><li>以太网协议如何根据网卡进行通信的？ 
        <ul><li>局域网情况下，也叫子网 
          <ul><li>在以太网内一个数据包的发送，会先广播给局域网的所有电脑设备网卡，然后每台电脑都从数据包中取出接收者的mac地址和自己的mac地址进行对比，如果是一样的，则说明是给自己发送的数据包才进行处理，否则就丢弃数据包</li></ul> </li><li>如何知道哪些电脑在当前局域网内呢？ 
          <ul><li>这就需要依靠网络层来支持了 
            <ul><li>请看下面的网络层</li></ul> </li></ul> </li></ul> </li></ul> </li></ul> </li><li> <p>网络层</p> 
    <ul><li>网络层里有ip协议，ip协议定以的地址就是ip地址。ip地址理由ipv4和ipv6两种类型，目前广泛使用的是ipv4，是由32个二进制数字组成，但一般由4个十进制数字来表示，范围是0.0.0.0到255.255.255.255</li><li>每台电脑都有一个ip地址，前24位(前3位十进制数字)代表网络，后8位(最后1个十进制数字)代表了主机，如果几台电脑是一个子网的，那么前3位十进制的数字就是一样的 
      <ul><li>比如开虚拟机或者连接的都是同一个网线，无线网，则电脑的ip地址分别是192.168.0.180，192.168.0.181，192.168.0.182，192.168.0.183，可以看出192.168.0这三位数字是一样的就证明大家是一个子网的，最后一个数字就是主机编号</li><li>但上面的描述不是百分百准备，需要将子网掩码进行二进制运算才可以真正对比出是不是属于同一个子网内 
        <ul><li>比如192.168.0.180和192.168.0.181 通过二进制运算后的结果分别式</li><li>11000000.10101000.0.10110100</li><li>11000000.10101000.0.10110101</li><li>然后判断前三位 如果相同则证明是一个子网</li><li>最后一位表示主机编号</li><li>所以通过子网掩码就可以确定局域网下的电脑，然后就可以互相通信了</li><li>但如果不在一个子网内？是如何通信呢</li><li>所以这就需要路由器</li></ul> </li></ul> </li><li>路由器 也成为网关 
      <ul><li>可以把多个子网给串联起来</li><li>根据以太坊协议，网卡间只能在子网内进行通信，但要和其他网卡进行通信，就可以把包发给交换机，交换机再把包进行广播，路由器(路由器也有mac地址)上的网卡收到后判断是不是自己的，是自己的话，再通过交换用以太坊协议进行广播分发</li><li>所以以太网要和多个子网进行通讯，就需要交换机和路由器</li><li>ARP协议 
        <ul><li>一个局域网内的机器会互相给对方发送自己的mac地址，所以当一个机器要发送数据包时，就可以知道其他电脑的mac地址了</li></ul> </li></ul> </li><li>交换机，一种工作在数据链路成的设备，网关是工作在网络层</li><li>总结：子网间的机器如何通信，在数据包中写上对方的mac地址，通过交换机用以太坊协议进行广播。如果是跨子网通信，在包里写上目标和路由器的mac地址，路由器再根据目标地址通过交换机进行广播，一直持续找到最终mac地址为止</li><li>LAN 局域网</li><li>WAN 广域网</li><li>WLAN 无线局域网</li><li>但同一个电脑下运行着qq，微信，视频等软件，怎么区分数据包是发给这个ip下的哪一个服务呢？那么就需要有一个端口的概念来进行区分，所以这也是为什么端口要唯一的原因。</li><li>那么如何将数据包发到某一个ip的某一个端口上？这就需要TCP协议了</li></ul> </li><li> <p>传输层</p> 
    <ul><li> <p>TCP协议简述</p> 
      <ul><li> <p>存在长连接和短连接</p> 
        <ul><li> <p>短链接</p> 
          <ul><li> <p>TCP短连接：client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次请求就完成了。这时候双方任意都可以发起close操作，不过一般都是client先发起close操作。上述可知，短连接一般只会在 client/server间传递一次请求操作。</p> <p>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</p> </li></ul> </li><li> <p>长连接 keepalive</p> 
          <ul><li>TCP长连接的情况：client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</li><li>如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测4个客户端状态</li><li>客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。</li><li>客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。</li><li>客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。<br> 客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。</li></ul> </li><li> <p>什么时候用长连接或者短连接</p> 
          <ul><li>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，下次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</li><li>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</li></ul> </li></ul> </li><li> <p>服务于会话层</p> </li><li> <p>建立在某个主机的某个端口到另一个主机下某个端口的连接和通信的，这个通信是使用socket来实现，通过socket实现上面的ip寻址，而且还会建立端口间的连接。规定了一套基于端口的通信协议，包括建立连接，发送和读取消息。</p> </li><li> <p>大概机制就是在数据包中加入端口号，寻址到ip后，再去寻找监听该端口号的服务，将数据包发送过去</p> </li><li> <p>特点</p> 
        <ul><li>TCP依靠端口来进行通信 TCP头有自己的端口 TCPdata有目标的端口</li><li>传输可靠，因为要经历三次握手和四次挥手</li><li>可靠性传输依赖的是ARQ协议</li><li>流量控制</li></ul> </li></ul> </li><li> <p>UDP协议简述</p> 
      <ul><li>UDP提供无连接服务</li><li>不需要维护连接状态</li><li>适用于效率高的应用</li><li>不像TCP那样每一次发送都需要进行确认</li><li>性能高，开销小</li><li>连接不可靠</li></ul> </li></ul> </li><li> <p>会话层</p> 
    <ul><li>维护两个节点的传输连接，确保点到点传输不中断和管理数据交换等功能</li></ul> </li><li> <p>表示层</p> 
    <ul><li>提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别</li><li>作用 
      <ul><li>数据编码和解码</li><li>数据加密和解密</li><li>数据压缩和解压缩</li><li>展示图片，音频和视频等</li></ul> </li><li>总结 
      <ul><li>表示层从应用层接收数据。这些数据是以字符和数字的形式出现的，表示层将这些数据转换成为机器可以理解的二进制格式，也就是封装数据，和格式化数据。例如：将ASCII码转化为别的编码，这个功能称为“翻译”。在传输数据之前，表示层减少了用来表示原始数据的比特数，这个过程被称为数据压缩，它可以是无损或者有损的，数据压缩减少了存储原始数据所需的空间，所以它可以在很短的时间内到达目的地，数据压缩对实时视频和音频的传输有很大的帮助。</li><li>为了保持完整性的数据，传输前的会给数据加密，而加密和解密是敏感数据的安全保障，在中心端，数据在接受端被加密，数据被解密为SSL协议或者安全套接字。</li><li>所以，<strong><code>表示层执行三个基本功能：翻译、压缩和加密/解密</code></strong>。</li></ul> </li></ul> </li><li> <p>应用层 http协议(80端口)，https(443端口)，ftp(21)，ssh(22)，smtp(25)</p> 
    <ul><li> <p>TCP能传输数据了，为什么还需要类似http这种应用层协议？</p> 
      <ul><li>因为如果每个公司都有自己的应用层协议，那么会导致两端数据无法识别。所以就需要抽象出国际协议，比如http(Hyper Text Transfer Protocol)。</li><li>它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以<a href="https://baike.baidu.com/item/ASCII/309296" rel="nofollow">ASCII</a>形式给出；而消息内容则具有一个类似<a href="https://baike.baidu.com/item/MIME/2900607" rel="nofollow">MIME</a>的格式。这个简单模型是早期<a href="https://baike.baidu.com/item/Web/150564" rel="nofollow">Web</a>成功的有功之臣，因为它使开发和部署非常地直截了当</li><li>因为我们在传输数据时，可以只使用TCP/IP协议进行传输，但是这样没有应用层的参与，会导致两端无法识别数据内容，这样传输的数据也就没有意义了。因此如果想让传输的数据有意义，那么就必须要用到应用层的协议，比如http</li><li>web使用http协议作为应用层协议，封装http文本信息，然后使用tcp协议进行传输</li></ul> </li><li> <p>http长连接 keep-alive</p> 
      <ul><li> <p>若开启后，在一次http请求中，服务器进行响应后，不再直接断开TCP连接，而是将TCP连接维持一段时间。在这段时间内，如果同一客户端再次向服务端发起http请求，便可以复用此TCP连接，向服务端发起请求，并重置timeout时间计数器，在接下来一段时间内还可以继续复用。这样无疑省略了反复创建和销毁TCP连接的损耗</p> </li><li> <p>启用HTTP keep-Alive的优缺点：</p> <p>优点：keep-alive机制避免了频繁建立和销毁连接的开销。 同时，减少服务端TIME_WAIT状态的TCP连接的数量(因为由服务端进程主动关闭连接)</p> <p>缺点：若keep-alive timeout设置的时间较长，长时间的TCP连接维持，会一定程度的浪费系统资源。</p> <p>总体而言，HTTP keep-Alive的机制还是利大于弊的，只要合理使用、配置合理的timeout参数。</p> </li><li> <p>和TCP的keepalive区别是</p> 
        <ul><li>TCP的是为了检测心跳，保持活跃的</li><li>HTTP的主要是在TCP的保活基础上重用连接，提高性能的</li></ul> </li></ul> </li></ul> </li><li> <p>什么是DNS</p> 
    <ul><li>通常我们访问网址都需要输入一个域名，但协议都是根据ip进行寻址的，所以会有一个DNS服务器，输入一个域名的时候会先发给DNS服务器，DNS服务再告诉你对应的ip地址</li></ul> </li></ul> </li><li> <p>WebSocket面试题</p> 
  <ul><li> <p>websocket和socket的区别</p> 
    <ul><li> <p>什么是socket协议</p> 
      <ul><li>socket是应用层与TCP/IP协议通信的中间软件抽象层，它是一组接口。而websocket协议是一个完整的应用层协议，基于TCP长连接实现的</li><li>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</li><li>Socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作, socket就是该模式的一个实现，socket是一种特殊的文件，一些socket函数就是对其进行的操作(打开、读/写IO、关闭)。</li><li>套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是IP地址与端口的组合。</li></ul> </li><li> <p>sockey协议调用流程</p> 
      <ul><li>先从服务器端说起，服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</li></ul> </li><li> <p>socket核心api</p> 
      <ul><li> <p>**socket()：**创建套接字。</p> <p>**bind()：**指定本地地址。一个套接字用socket()创建后，它其实还没有与任何特定的本地或目的地址相关联。在很多情况下，应用程序并不关心它们使用的本地地址，这时就可以不用调用bind指定本地的地址，而由协议软件为它们选择一个。但是，在某个知名端口（Well-known Port）上操作的服务器进程必须要对系统指定本地端口。所以一旦创建了一个套接字，服务器就必须使用bind()系统调用为套接字建立一个本地地址。</p> </li><li> <p>**listen()：**设置等待连接状态。对于一个服务器的程序，当申请到套接字，并调用bind()与本地地址绑定后，就应该等待某个客户机的程序来要求连接。listen()就是把一个套接字设置为这种状态的函数。</p> </li><li> <p>**connect()：**将套接字连接到目的地址。初始创建的套接字并未与任何外地目的地址关联。客户机可以调connect()为套接字绑定一个永久的目的地址，将它置于已连接状态。对数据流方式的套接字，必须在传输数据前，调用connect()构造一个与目的地的TCP连接，并在不能构造连接时返回一个差错代码。如果是数据报方式，则不是必须在传输数据前调用connect。如果调用了connect()，也并不像数据流方式那样发送请求建连的报文，而是只在本地存储目的地址，以后该socket上发送的所有数据都送往这个地址，程序员就可以免去为每一次发送数据都指定目的地址的麻烦。</p> </li><li> <p>**accept()：**接受连接请求。服务器进程使用系统调用socket，bind和listen创建一个套接字，将它绑定到知名的端口，并指定连接请求的队列长度。然后，服务器调用accept进入等待状态，直到到达一个连接请求。</p> </li><li> <p>**read()、write()：**当服务器与客户已经建立好连接之后。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信</p> </li></ul> </li></ul> </li><li> <p>什么是websocket</p> 
    <ul><li>HTML5的一种新协议，允许服务器向客户端传递信息，实现浏览器和客户端双工通信</li></ul> </li><li> <p>运行原理</p> 
    <ul><li> <p>为什么要用</p> 
      <ul><li>因为http协议请求后都会关闭连接，下次请求的时候又要重新建立连接。但长轮询过多时会对服务器负载造成较大影响。所以就用websocket协议来完成类似聊天室，实时状态推送等业务场景功能</li></ul> </li><li> <p>应用场景</p> 
      <ul><li>实时通信</li></ul> </li><li> <p>特点</p> 
      <ul><li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器</li><li>数据格式比较轻量，性能开销小，通信高效</li><li>没有同源限制，客户端可以与任意服务器通信</li></ul> </li><li> <p>基于TCP再次封装的另一个协议</p> </li><li> <p>首先在连接的时候会发送一个协议升级请求，在http请求上加上socket相关的请求头</p> 
      <ul><li> <pre><code>Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits
Sec-WebSocket-Key: k1kbxGRqGIBD5Y/LdIFwGQ==
Sec-WebSocket-Version: 13
Upgrade: websocket
</code></pre> </li></ul> </li><li> <p>服务端如果支持socket的话，会返回101状态码同意协议升级</p> </li><li> <p>总结概述</p> 
      <ul><li>websocket是HTML5新增的一种全双工通信协议，客户端和服务端基于TCP握手连接成功后，两者之间就可以建立持久性的连接，实现双向数据传输。它也是基于TCP协议的，建立连接时也是先通过TCP完成三次握手，然后再发送一个http请求，携带协议升级的相关请求标识，比如Upgrade: websocket。服务端同意协议升级并返回一个回包进行确认，这样websocket就连接上了 
        <ul><li>后续的发送消息就依靠网络层协议来完成了，交换机，网关等</li></ul> </li></ul> </li></ul> </li><li> <p>WebSocket和Http区别，相比的优缺点</p> 
    <ul><li>总结 
      <ul><li>websocket是全双工协议，客户端和服务端双向通信</li><li>websocket协议头是ws/wss，http是http/https</li><li>websocket只需要连接一次，http需要反复的创建和关闭连接</li><li>websocket不关注接收者的状态，http需要关注接收者的状态</li><li>两个都是基于socket协议(socket基于TCP协议)</li></ul> </li><li>相同点 
      <ul><li>都是 TCP 协议；<br> 都使用 Request/Response 模型进行连接的建立；<br> websocket 是基于 http 的，他们的兼容性都很好；<br> 在连接的建立过程中对错误的处理方式相同；<br> 都可以在网络中传输数据。</li></ul> </li><li>不同点 
      <ul><li>websocket 是持久连接，http 是短连接；<br> websocket 的协议是以 ws/wss 开头，http 对应的是 http/https；<br> websocket 是有状态的，http 是无状态的；<br> websocket 连接之后服务器和客户端可以双向发送数据，http 只能是客户端发起一次请求之后，服务器才能返回数据；<br> websocket 是可以跨域的；<br> websocket 连接建立之后，数据的传输使用帧来传递，不再需要Request消息。</li></ul> </li></ul> </li><li> <p>为什么用这个技术</p> 
    <ul><li>解决http长轮询造成的性能和资源浪费问题</li></ul> </li><li> <p>WebSocket和Socket.io区别</p> 
    <ul><li>socket.io是对websocket的再一次封装 
      <ul><li>相比websocket，它提供了以下接口</li><li>自动重连</li><li>自动检测掉线</li><li>广播</li><li>解决因浏览器兼容导致的问题 
        <ul><li>有些浏览器不兼容，所以默认还支持了长轮询的尝试</li></ul> </li><li>前后端都要使用socket.io库</li></ul> </li></ul> </li><li> <p>socket.io工作原理</p> 
    <ul><li>首先，<code>socket.io</code>通过一个<code>http</code>请求,并且该请求头中带有升级协议(<code>Connection:Upgrade</code>、<code>Upgrade:websocket</code>)等信息，告诉服务端准备建立连接，此时，后端返回的<code>response</code>数据</li><li>当客户端收到响应之后，<code>scoket.io</code>会根据当前客户端环境是否支持<code>Websocket</code>。如果支持，则建立一个<code>websocket</code>连接，否则使用<code>polling</code>(<code>xhr</code>、<code>jsonp</code>)长轮询进行<strong>双向数据通信</strong></li><li>心跳参数配置 
      <ul><li>pingTimeout 
        <ul><li>Ping消息超时时间（毫秒），默认20秒，这个时间间隔内没有接收到心跳消息就会发送超时事件</li><li>默认是20000，20秒</li></ul> </li><li>pingInterval 
        <ul><li>Ping消息间隔（毫秒），默认25秒。客户端向服务器发送一条心跳检测</li><li>默认是25000，25秒</li></ul> </li><li>upgradeTimeout 
        <ul><li>协议升级超时时间（毫秒），默认10秒。HTTP握手升级为ws协议超时时间</li></ul> </li></ul> </li><li>心跳检测机制 
      <ul><li>概述 
        <ul><li>为了确保客户端与服务端的长连接正常，有时即使客户端连接中断，但是服务端未触发onclose事件，这就有可能导致无效连接占用。所以需要一种机制，确保两端的连接处于正常状态，心跳检测就是这种机制。客户端每隔一段时间，会向服务端发送心跳(数据包)，服务端也会返回response进行反馈连接正常。</li></ul> </li><li><code>socket.io</code>与<code>engine.io</code>的一大区别在于，<code>socket.io</code>并不直接提供连接功能，而是在<code>engine.io</code>层提供。</li></ul> </li></ul> </li></ul> </li><li> <p>什么是跨域，如何解决</p> 
  <ul><li>跨域的概念 
    <ul><li>浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域</li></ul> </li><li>需要同源策略的原因 
    <ul><li>设置同源策略的主要目的是为了安全,如果没有同源限制,在浏览器中的cookie等其他数据可以任意读取,不同域下的DOM任意操作,ajax任意请求其他网站的数据,包括隐私数据。</li></ul> </li><li>哪些场景需要跨域 
    <ul><li>需要本地联调测试环境，本地用的local，测试环境用的ip或者域名</li><li>多个产品之间需要进行对接</li></ul> </li><li>如何解决跨域问题 
    <ul><li>请求头添加以下配置项 nginx和后端服务均可 
      <ul><li>Access-Control-Allow-Origin <em>允许哪些网站的跨域请求</em></li><li>Access-Control-Allow-Methods <em>允许的跨域ajax的请求方式</em></li><li>Access-Control-Allow-Headers <em>允许在请求中携带的头信息</em></li></ul> </li><li>jsonp请求 
      <ul><li>事先定义一个用于获取跨域响应数据的回调函数，并通过没有同源策略限制的<code>script</code>标签发起一个请求（将回调函数的名称放到这个请求的<code>query</code>参数里），然后服务端返回这个回调函数的执行，并将需要响应的数据放到回调函数的参数里，前端的<code>script</code>标签请求到这个执行的回调函数后会立马执行，于是就拿到了执行的响应数据。 
        <ul><li>优点 
          <ul><li>它不像<code>XMLHttpRequest</code>对象实现的<code>Ajax</code>请求那样受到同源策略的限制</li><li>它的兼容性更好，在更加古老的浏览器中都可以运行，不需要<code>XMLHttpRequest</code>或<code>ActiveX</code>的支持</li><li>并且在请求完毕后可以通过调用<code>callback</code>的方式回传结果</li></ul> </li><li>缺点 
          <ul><li>它<strong>只支持<code>GET</code>请求</strong>而不支持 <code>POST</code> 等其它类型的 HTTP 请求</li><li>它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript 调用的问题</li></ul> </li></ul> </li></ul> </li></ul> </li></ul> </li><li> <p>Nodejs的buffer原理和应用场景</p> 
  <ul><li>JavaScript 起初为浏览器而设计，没有读取或操作二进制数据流的机制。Buffer类的引入，则让NodeJS拥有操作文件流或网络二进制流的能力</li><li>也可以用来请求中的字符串转换</li><li>对字符串进行其他类型的编码解码等</li></ul> </li><li> <p>Nodejs的流的应用场景以及运行原理</p> 
  <ul><li>主要用于处理大文件，利用fs模块中的读取和写入流可以操作</li><li>也可以用stream模块，但一般fs模块就满足了，因为fs内部就继承了stream模块</li><li>解决因文件过大而导致的内存占用高的问题</li></ul> </li><li> <p>Nodejs await/async原理</p> 
  <ul><li>async放在函数前 这个函数会返回promise</li><li>await放在函数前 则会等待这个函数执行完毕</li><li>要了解await就要先理解generator函数</li><li>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</li><li>generator函数的特性有以下两点 
    <ul><li>一是，<code>function</code>关键字与函数名之间有一个星号；</li><li>二是，函数体内部使用<code>yield</code>表达式</li></ul> </li><li>generator是es6提供的函数同步执行的方法，使用*号标记函数为generator，内部使用yield暂停表达式，使用next进行放行</li></ul> </li><li> <p>Nodejs多进程应用场景，如何做负载均衡和进程间通讯</p> 
  <ul><li>master进程负责启动子进程，然后子进程工作</li><li>Worker 进程的数量一般根据服务器的 CPU 核数来定，这样就可以完美利用多核资源</li></ul> </li><li> <p>进程和线程的区别</p> 
  <ul><li>线程就可以当做是进程里面的执行的单元,同时它也是这个进程里面的一个能够调度的实体</li></ul> </li><li> <p>CommonJs概念</p> 
  <ul><li>由于早期javascript缺少模块的概念，产生了commonjs规范</li><li>规范特性 
    <ul><li>通过require引入模块并应用在当前的上下文</li><li>模块内部需要用exports来提供导出</li></ul> </li><li>相关文章 
    <ul><li><a href="https://blog.csdn.net/qq_42427109/article/details/88383123?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165633969016781432926292%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165633969016781432926292&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-88383123-null-null.nonecase&amp;utm_term=CommonJs&amp;spm=1018.2226.3001.4450">Noejs CommonJS模块机制</a></li></ul> </li></ul> </li><li> <p>Nodejs模块</p> 
  <ul><li>es5和es6区别 
    <ul><li>es5使用require</li><li>es6使用import</li><li>es6 module属于编译时加载，也就是静态加载，在编译时就能确定模块的依赖关系，以及输入和输出的变量；commonjs属于运行时加载，只有代码在运行时才能确定这些东西。</li><li>es6 module可以做到tree-shaking，也就是可以加载模块部分用到的内容，commonjs需要加载整个模块，再取内容。</li><li>es6 module输出的是值的引用，commonjs输出的是值的拷贝。</li><li>es6 module中的import是异步加载，commonjs中的require是同步加载</li></ul> </li><li>export和export.default区别 
    <ul><li>export.default是默认导出，一个模块只允许有一个默认导出，重复的会被覆盖</li><li>export类似module.export，可以导出一个或多个成员</li></ul> </li></ul> </li><li> <p>ExpressJs</p> 
  <ul><li>概念 
    <ul><li>node中上手最简单，内置功能多的框架</li></ul> </li><li>特点 
    <ul><li>内置了常用中间件，方便使用 
      <ul><li>express.static 提供静态资源，例如 HTML 文件、图像等</li><li>exporess.json 使用 JSON 有效负载解析传入请求</li><li>express.urlencoded 解析带有 URL 编码负载的传入请求</li><li>express.text(基于body-parser) 将请求参数解析为字符串</li><li>express.router 路由文件</li></ul> </li><li>回调基于callback</li></ul> </li></ul> </li><li> <p>KoaJs</p> 
  <ul><li> <p>概念</p> 
    <ul><li>下一代的nodejs框架koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手</li></ul> </li><li> <p>特点</p> 
    <ul><li> <p>洋葱卷模型</p> 
      <ul><li> <p>概述</p> 
        <ul><li>先由内向外执行，再由外向内执行</li></ul> </li><li> <p>源码</p> </li></ul> <pre><code class="prism language-typescript"> <span class="token keyword">function</span> <span class="token function">compose</span> <span class="token punctuation">(</span>middleware<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token comment">// ...</span>
   <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>context<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// last called middleware #</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
    <span class="token comment">// 一开始的时候传入为 0，后续会递增</span>
    <span class="token keyword">return</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">function</span> <span class="token function">dispatch</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 假如没有递增，则说明执行了多次</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> index<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'next() called multiple times'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      index <span class="token operator">=</span> i
      <span class="token comment">// 拿到当前的中间件</span>
      <span class="token keyword">let</span> fn <span class="token operator">=</span> middleware<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> middleware<span class="token punctuation">.</span>length<span class="token punctuation">)</span> fn <span class="token operator">=</span> next
      <span class="token comment">// 当 fn 为空的时候，就会开始执行 next() 后面部分的代码</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fn<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 执行中间件，留意这两个参数，都是中间件的传参，第一个是上下文，第二个是 next 函数</span>
        <span class="token comment">// 也就是说执行 next 的时候也就是调用 dispatch 函数的时候</span>
        <span class="token keyword">return</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token function">dispatch</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>	
</code></pre> 
      <ul><li> <p>为什么需要</p> 
        <ul><li>因为express的next在异步情况下的顺序不能保持一致，所以需要用await保证顺序，就形成了洋葱卷模型</li><li>其实就是express的next不是用promise实现的，导致异步无法控制，而koa的next是用promise实现的，再结合流行的await，可以很好的控制中间件的异步顺序</li></ul> </li></ul> </li><li> <p>没有内置任何中间件，比express更轻量</p> </li><li> <p>基于es6，默认await/async</p> </li><li> <p>有一个统一上下文遍历ctx，方便业务处理，不再需要层层向下传递。</p> </li><li> <p>比koa1中的generator更简单的异步，async/await</p> </li><li> <p>缺点</p> 
      <ul><li>上下文依赖ctx，导致ctx臃肿，难以维护</li><li>没有强一致的约束，对团队素质要求高</li></ul> </li></ul> </li></ul> </li><li> <p>EggJs</p> 
  <ul><li>特点 
    <ul><li>支持ts</li><li>基于koa，内置洋葱卷模型</li><li>约定大于配置 
      <ul><li>controller</li><li>service</li><li>router</li></ul> </li><li>内置多进程模型 
      <ul><li>node内置了一个模块cluster 多进程</li></ul> </li><li>插件机制 
      <ul><li>比起传统的util文件，插件更适合拓展和维护，一个插件只做一件事。 
        <ul><li>而且插件的约定也是按照egg的目录结构而来的，一个迷你的egg应用 
          <ul><li>去掉了router和controller</li></ul> </li></ul> </li></ul> </li><li>渐进式开发 
      <ul><li>前期，最初团队抽象出了一些公共的方法 .util.ts</li><li>中期，这个通用方法还不是很完善，直接用插件不好维护，但可以先写成插件的形式</li><li>通过config/plugin.js来挂载</li><li>后期，经过一段时间考验后，该插件已经完善且稳定，所以可以进行单独的抽离 
        <ul><li>就是单独抽离出一个npm包，不过包结构要按照egg的格式来</li></ul> </li><li>终期，已经积累了很多可以复用的插件，并且在多个团队和项目中可以复用，所以此时可以沉淀到框架中 
        <ul><li>将可复用的插件单独抽象成一个框架给多个团队和项目使用</li></ul> </li></ul> </li></ul> </li><li>缺点 
    <ul><li>基于koa，自带多进程模型，相比较koa和express较重</li><li>约定大于配置，业务扩展难度高，插件扩展难度也会变高</li><li>基于koa，上下文依赖ctx，导致ctx臃肿，难以维护</li></ul> </li></ul> </li><li> <p>NestJs</p> 
  <ul><li> <p>特点</p> 
    <ul><li>基于express 
      <ul><li>因为为了设计一个开箱即用的框架，而express内置了很多模块，所以基于express</li></ul> </li><li>完全支持typescript 
      <ul><li>类型约束</li><li>编译期间有类型检查，能预知错误</li></ul> </li><li>模块概念 
      <ul><li>通过模块将每个应用功能进行解耦。相比express等框架，没有模块约束，代码相比nestjs，维护难度更高</li></ul> </li><li>异常过滤器 
      <ul><li>全局的异常过滤器，对全局的异常做定制化处理</li></ul> </li><li>管道 
      <ul><li>对请求参数进行转换或者验证</li></ul> </li><li>守卫 
      <ul><li>用户权限校验</li><li>用户角色校验</li><li>用户鉴权等</li></ul> </li><li>更符合现代化编程的中间件模式 
      <ul><li>传统的express,koa等node框架，通过和路由编码的方式来进行绑定</li><li>而nestjs是基于模块进行中间件配置的形式来绑定中间件</li></ul> </li><li>拦截器，比如用于请求前后的日志链路追踪，或者请求和返回参数的定制化</li><li>官方文档非常完善，每一个模块都提供了标准的示例</li><li>AOP(Aspect Oriented Programming)，面向切面编程</li><li>IOC 
      <ul><li>控制反转。比如传统的开发模式是每次都要重新实例化一个对象。但是在nestjs的IOC模式中，只需要将对象注入到构造函数声明中就行</li></ul> </li><li>生命周期钩子函数 
      <ul><li>OnModuleInit 
        <ul><li>初始化主模块依赖处理后调用一次</li></ul> </li><li>OnApplicationBootstrap 
        <ul><li>在应用程序完全启动并监听连接后调用一次</li></ul> </li><li>OnModuleDestroy 
        <ul><li>收到终止信号(例如SIGTERM)后调用</li></ul> </li><li>beforeApplicationShutdown 
        <ul><li>在<code>onModuleDestroy()</code>完成(Promise被resolved或者rejected)；一旦完成，将关闭所有连接(调用app.close() 方法).</li></ul> </li><li>OnApplicationShutdown 
        <ul><li>连接关闭处理时调用(app.close())</li></ul> </li></ul> </li><li>OOP面向对象思想 
      <ul><li>面向对象编程，通过对象内的各种属性和方法来完成编程。容易维护和扩展。 
        <ul><li>封装 将通用的方法抽象到一个util内</li><li>继承 扩展类的功能 
          <ul><li><strong>super</strong>关键字用于访问和调用对象父类上的函数。可以<strong>调用</strong>父类的<strong>构造函数</strong>，<strong>也可以调用</strong>父类的<strong>普通函数</strong></li></ul> </li><li>多态 
          <ul><li>同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果</li><li>比如两个方法都有send函数，要在一个函数内进行调用，就要根据不同的方法调用不同的send函数。那么利用多态，直接将类初始化，函数内部只需要执行send方法而不需要关注上层是谁了</li><li>比如使用抽象类和接口实现</li></ul> </li></ul> </li></ul> </li><li>FP函数式编程 
      <ul><li> <p>函数式编程是一种强调以函数使用为主的软件开发风格 ，也是一种范式</p> 
        <ul><li>用函数来编程，更好的模块化</li><li>函数可以复用</li><li>低耦合</li></ul> </li><li> <p>伪代码</p> 
        <ul><li>函数作为参数执行</li><li>函数作为返回值执行</li></ul> </li><li> <p>其他的应用场景<br> 编写可以轻松复用和配置的小代码块，就像我们使用npm一样<br> 举个例子，你有一家商店，然后你想给你的优惠顾客10%的折扣：</p> <pre><code class="prism language-typescript"><span class="token keyword">function</span> <span class="token function">discount</span> <span class="token punctuation">(</span>price<span class="token punctuation">,</span> discount<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> price <span class="token operator">*</span> discount
<span class="token punctuation">}</span>
<span class="token comment">// 当一个顾客消费了500元</span>
<span class="token keyword">const</span> price <span class="token operator">=</span> <span class="token function">discount</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">)</span> <span class="token comment">// $50</span>

<span class="token comment">// 从长远看，你的每一笔生意都要计算10%的折扣</span>
<span class="token keyword">const</span> price <span class="token operator">=</span> <span class="token function">discount</span><span class="token punctuation">(</span><span class="token number">1500</span><span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">)</span> <span class="token comment">// $150</span>
<span class="token keyword">const</span> price <span class="token operator">=</span> <span class="token function">discount</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">)</span> <span class="token comment">// $200</span>
<span class="token keyword">const</span> price <span class="token operator">=</span> <span class="token function">discount</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">)</span> <span class="token comment">// $5</span>
<span class="token keyword">const</span> price <span class="token operator">=</span> <span class="token function">discount</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">)</span> <span class="token comment">// $30</span>

<span class="token comment">// 将这个函数柯里化，然后我们就不用每次都写那0.1了</span>
<span class="token keyword">function</span> <span class="token function">discount</span> <span class="token punctuation">(</span>discount<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>price<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> price <span class="token operator">*</span> discount
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> tenPercentDiscount <span class="token operator">=</span> <span class="token function">discount</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span>

<span class="token comment">// 现在，我们只需用商品价格来计算就可以了：</span>
<span class="token function">tenPercentDiscount</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span> <span class="token comment">// $50</span>

<span class="token comment">// 接下来，有些优惠顾客越来越重要，让我们称为vip顾客，然后我们要给20%的折扣，我们这样来使用柯里化了的discount函数：</span>
<span class="token keyword">const</span> twentyPercentDiscount <span class="token operator">=</span> <span class="token function">discount</span><span class="token punctuation">(</span><span class="token number">0.2</span><span class="token punctuation">)</span>

<span class="token comment">// 我们为vip顾客使用0.2调用柯里化discount函数来配置了一个新的函数。这个twentyPercentDiscount函数会被用来计算vip顾客的折扣：</span>
<span class="token function">twentyPercentDiscount</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span> <span class="token comment">// $100</span>
<span class="token function">twentyPercentDiscount</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span> <span class="token comment">// $600</span>
<span class="token function">twentyPercentDiscount</span><span class="token punctuation">(</span><span class="token number">80000</span><span class="token punctuation">)</span> <span class="token comment">// $16000</span>
</code></pre> <p>避免频繁调用具有相同参数的函数<br> 比如我们有个用来计算体积的函数</p> <pre><code class="prism language-typescript"><span class="token keyword">function</span> <span class="token function">volume</span> <span class="token punctuation">(</span>l<span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> l <span class="token operator">*</span> w <span class="token operator">*</span> h
<span class="token punctuation">}</span>

<span class="token comment">// 碰巧你仓库里的所有物品都是100m高。你会看到你不停地用h=100来调用这个函数：</span>
<span class="token function">volume</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// 2003000</span>
<span class="token function">volume</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// 144000</span>
<span class="token function">volume</span><span class="token punctuation">(</span><span class="token number">2322</span><span class="token punctuation">,</span> <span class="token number">232</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// 53870400</span>

<span class="token comment">// 为了解决这个问题，你把volume函数柯里化（像我们之前做过的）：</span>
<span class="token keyword">function</span> <span class="token function">volume</span> <span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> l <span class="token operator">*</span> w <span class="token operator">*</span> h
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 我们能给同类物品定义一个特殊函数：</span>
<span class="token keyword">const</span> hCylinderHeight <span class="token operator">=</span> <span class="token function">volume</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token function">hCylinderHeight</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span> <span class="token comment">// 600000</span>
<span class="token function">hCylinderHeight</span><span class="token punctuation">(</span><span class="token number">2322</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">232</span><span class="token punctuation">)</span> <span class="token comment">// 53870400</span>
</code></pre> </li></ul> </li></ul> </li><li> <p>应用场景</p> 
    <ul><li>中大型企业框架 
      <ul><li>ts支持，减少团队代码后期维护成本</li><li>更现代的开发模式</li><li>丰富的插件生态，提高开发效率</li></ul> </li></ul> </li><li> <p>自定义注解</p> 
    <ul><li>通过这个包实现<a href="https://link.zhihu.com/?target=https%3A//github.com/rbuckton/reflect-metadata" rel="nofollow">reflect-metadata</a></li></ul> </li></ul> </li><li> <p>V8虚拟机</p> 
  <ul><li> <p>什么是V8虚拟机？说说你对虚拟机的理解</p> 
    <ul><li>v8引擎是谷歌浏览器用的虚拟机。用于解释和执行javascript代码</li><li>说到底，JavaScript引擎就是用来执行JavaScript代码用的，为其提供了一个运行时环境，提供解释/编译、自动内存管理（GC）、对象模型、核心库等功能。</li></ul> </li><li> <p>为什么v8引擎的性能强劲</p> 
    <ul><li>相比较其他的javascript引擎，v8的性能更高 
      <ul><li>热点代码缓存</li><li>增量式的垃圾回收机制</li><li>隐藏类，对相同属性的对象通过隐藏类共享，后续访问只需要根据设定的对象偏移量操作即可。如果位置发生变化，则重新生成隐藏类</li><li>对隐藏类做缓存，因为获取隐藏类的地址依然有提升空间，所以就对隐藏类进行缓存，查找的时候先判断是否是相同的隐藏类，是的话直接使用该缓存结果</li><li>新版本的v8引入了Sparkplug引擎，提高非热点代码的执行效率</li></ul> </li></ul> </li><li> <p>垃圾回收机制</p> 
    <ul><li>64系统为1.4g</li><li>32系统0.7g(因为32位系统内存最大只支持4g)</li><li>也可以通过启动参数来调整</li><li>32和64区别，内存大小不同，兼容性不同</li><li>新生代：存活周期短</li><li>老年代：存货周期长</li><li>v8默认采用的是分代式垃圾回收机制 
      <ul><li><a href="https://blog.csdn.net/qq_42427109/article/details/100902835?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168422690116800186597998%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=168422690116800186597998&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-100902835-null-null.article_score_rank_blog&amp;utm_term=%E5%9E%83%E5%9C%BE&amp;spm=1018.2226.3001.4450">V8垃圾回收机制</a></li></ul> </li><li>其他垃圾回收机制 
      <ul><li>标记清除 
        <ul><li>标记清楚在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。这样设计是因为存活的在对象占用比例小，所以才会更高效</li><li>优点 
          <ul><li>比较通用和简单的算法</li></ul> </li><li>缺点 
          <ul><li>内存不连续</li></ul> </li></ul> </li><li>复制清除 
        <ul><li>将堆内存一分为二，from和to这两个空间，分配对象的时候，会先检查from空间是否还有存活对象，有的话就复制到to空间中，那些非存活对象会被释放。完成复制后，to和from的空间再进行互换，下次分配的时候继续执行刚才的步骤。当一个对象检查多次依然存活，那么它就会晋升到老年代中。判断内存地址来区分是否被检查过</li><li>优点 
          <ul><li>解决内存碎片问题</li><li>回收效率高</li></ul> </li><li>缺点 
          <ul><li>将内存缩小为原来的一半，代价高</li><li>随着存活对象的比例提升，复制的成本会逐渐提高</li></ul> </li></ul> </li><li>标记整理 
        <ul><li>解决内存碎片化和复制清除内存利用率低的问题</li><li>让所有存活的对象移动到一段，然后直接清理掉另一端的内存。这样就避免了内存碎片和内存利用率低的问题</li><li>当存活对象过多时，v8采用增量式迁移，每次移动一小部分进行处理，提高处理效率</li></ul> </li><li>分代式垃圾回收 
        <ul><li>V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</li><li>新生代使用复制清除回收算法</li><li>老年代使用标记整理算法(因为标记清除会留下不连续的内存碎片)，并且v8对老年代的回收做了优化，使用增量标记提高了回收效率</li></ul> </li></ul> </li></ul> </li><li> <p>内存结构</p> 
    <ul><li> <p>为什么需要堆栈区</p> 
      <ul><li>程序执行过程中，需要记录上下文，那么就要把数据记录到内存中合适的地方，并做好分配和初始化等工作。</li></ul> </li><li> <p>堆区</p> 
      <ul><li>堆区用来存储对象，由栈区的对象引用地址来进行调用 
        <ul><li>这样设计的使对象实体的 运用 更加的灵活、隔离、模块化 
          <ul><li><strong>灵活</strong>：相当于业务数据存放到一个空间足够的池子，我想实现怎样的逻辑，需要怎么的业务数据，通过引用的方式直接获取想要的业务数据。</li><li><strong>隔离</strong>：业务数据和业务逻辑存放在不同的空间，互不干扰。</li><li><strong>模块化</strong>：通过业务数据和业务逻辑的组合，形成具有特定功能的模块。</li></ul> </li></ul> </li><li>对象内存的管理由垃圾回收机制来处理</li></ul> </li><li> <p>堆栈区(栈区)</p> 
      <ul><li>栈区用来记录程序的执行顺序，所以只存储了基本变量类型和对象的引用地址</li><li>函数调用栈，先进后出 
        <ul><li>原因 
          <ul><li>要是在生活中我们也是按照栈的规则来排顺序，这个世界岂不是乱了套了，试想你去银行排队取钱，明明你是第一个去，却等到晚上晚上银行人员快下班了你才最后处理完业务，恐怕你早就跟人干起来了</li><li>举个例子吧：我创建一个函数A,在函数A中调用了另一个函数B！那么堆栈中应该是先把A的压栈，再把B压栈！而只有当B这个函数执行完了才会继续执行A后面的代码，所以必须先把B弹栈！这就是后进先出！不然的话程序岂不是乱套了！</li></ul> </li></ul> </li><li>主要作用 
        <ul><li>保存函数的局部变量</li><li>向被调用函数传递参数</li><li>返回函数的返回值</li><li>保存函数的返回地址。返回地址是指从被调用函数返回后调用者应该继续执行的指令地址</li></ul> </li><li>工作流程 
        <ul><li>每个函数在执行过程中都需要使用一块栈内存用来保存上述这些值，我们称这块栈内存为某函数的栈帧(stack frame)。当发生函数调用时，因为调用者还没有执行完，其栈内存中保存的数据还有用，所以被调用函数不能覆盖调用者的栈帧，只能把被调用函数的栈帧“push”到栈上，等被调函数执行完成后再把其栈帧从栈上“pop”出去，这样，栈的大小就会随函数调用层级的增加而生长，随函数的返回而缩小</li></ul> </li></ul> </li><li> <p>栈区和堆区的区别示例</p> 
      <ul><li> <p>以图书馆作为例子，图书馆就是系统 全部 的内存空间，里面的任何东西都是基于图书馆来分配空间。</p> <p>每一本书就是一个 对象实体，他们存放在书架上，书架就是 堆。假设图书馆有各种各样的书架，可以满足所有大小的书本，即使书的大小各异，管理员只需要找到合适的位置存放。</p> <p>为了方便存取书本，图书馆管理员会为每一本书设计一个编号，并记录在一个表格上，编号就是对象实体的 内存地址。</p> <p>那什么是 对象引用 呢，答案就是读者的每一条借书记录，每一次的借书行为可以理解为对书本的一次引用。借书的记录都会登记在一个表格上，这个表格就是 栈。借书记录仅仅是一段文字，所需要的空间很小，而且大小基本固定，通常情况下用一个本子、一个电子表格、一个数据库，做一个表格就可以满足需求。</p> <p>书本、编号、借书记录三者的结合，相辅相成，让整个图书馆的对图书的管理更加的灵活、方便和规范。</p> <p>其实，代码世界中很多的设计原理都是源于我们的生活，又高于生活。设计模式就在我们身边，无处不在，善于观察生活中的事物，从生活中领悟设计模式吧</p> </li></ul> </li></ul> </li></ul> </li><li> <p>都用过哪些NodeJs模块</p> 
  <ul><li>内置模块 
    <ul><li>cluster 
      <ul><li>操作多进程</li></ul> </li><li>process 
      <ul><li>处理环境变量，监听全局未捕获异常，控制进程退出，获取机器负载信息等</li></ul> </li><li>http 
      <ul><li>给其他服务发起http请求</li></ul> </li><li>fs 
      <ul><li>操作文件的增删改查</li></ul> </li><li>buffer 
      <ul><li>buffer是一个二进制数据流，操作文件，数据流转换，比如base64编码解码等</li></ul> </li><li>stream 
      <ul><li>流，处理大文件，避免大文件占用内存过高的问题</li></ul> </li></ul> </li><li>第三方模块 
    <ul><li>lodash 
      <ul><li>判断数值是否为空 isEmpty 
        <ul><li>对空字符串 null undefind 0 空数组的判断都很好用</li></ul> </li><li>数组去重 uniq 
        <ul><li>用js的话要么自己抽象一个方法，要么用set，lodash自己有封装好的</li></ul> </li><li>对数字的高级操作，交集(intersection)，补集(xor)，过滤(difference)，分组(group)等</li><li>等等等</li></ul> </li><li>bluebird/async 异步流程控制 
      <ul><li>异步串行</li><li>异步并行</li><li>同时串并</li><li>等等等</li></ul> </li><li>moment/dayjs 
      <ul><li>日期处理 
        <ul><li>时间戳转日期</li><li>日期转时间戳</li><li>获取某几个月的时间</li><li>计算时间差</li><li>等等等</li></ul> </li></ul> </li><li>node-xlsx 
      <ul><li>xlsx文件的导入导出解析</li></ul> </li><li>ioredis 
      <ul><li>连接redis驱动，操作redis</li></ul> </li><li>mongoose 
      <ul><li>连接mongodb驱动，操作Mongodb</li></ul> </li><li>log4js 
      <ul><li>服务日志记录和输出</li></ul> </li><li>qiniu 
      <ul><li>对接第三方云存储平台，处理文件的增删改查</li></ul> </li></ul> </li></ul> </li><li> <p>看过哪些模块的源码</p> 
  <ul><li> <p>lodash</p> 
    <ul><li> <p>出于好奇，看了isEmpty源码</p> 
      <ol><li> <p>先判断是否为空</p> </li><li> <p>再判断是否像数组</p> 
        <ol><li>判断是否拥有length属性</li><li>判断是否是函数 
          <ol><li>用typeof判断 object和function 此时都会被判定为对象</li></ol> </li></ol> </li><li> <p>接下在像数组的情况下继续进行或的判断</p> 
        <ol><li>判断是否是数组，使用Object.prototype.toString.call()判断，如果是’[object Array]'这个字符串，就是数组</li><li>不是数组，再判断是否是字符串 
          <ul><li>用typeof判断是否是字符串</li><li>满足任意一项，则返回length长度，0对于js是false，大于0则证明是有值的</li></ul> </li></ol> </li><li> <p>如果不是数组也不是字符串，则执行nativeKeys方法</p> 
        <ol><li>先用Object强制转换，对于undefind，null等无效类型，默认返回空数组，其他的则转换为对应的string，number，json等类型</li><li>然后再用Object.keys获取变量的key列表，返回length</li><li>0是false，大于0的是true</li></ol> </li><li> <p>Object.prototype.toString.call()原理</p> 
        <ul><li><a href="https://blog.csdn.net/qq_42427109/article/details/130492172?spm=1001.2014.3001.5502">JavaScript类型检查</a></li></ul> </li><li> <p>和instanceof，type of区别</p> 
        <ul><li> <p>typeof只能判断基本类型，引用类型都是object</p> <pre><code class="prism language-typescript"><span class="token keyword">function</span> <span class="token function">instance_of</span><span class="token punctuation">(</span><span class="token constant">L</span><span class="token punctuation">,</span> <span class="token constant">R</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//L 表示左表达式，R 表示右表达式 </span>

<span class="token keyword">var</span> <span class="token constant">O</span> <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>   <span class="token comment">// 取 R 的显示原型 </span>

<span class="token constant">L</span> <span class="token operator">=</span> <span class="token constant">L</span><span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>  <span class="token comment">// 取 L 的隐式原型</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>    

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">L</span> <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span>      

          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">O</span> <span class="token operator">===</span> <span class="token constant">L</span><span class="token punctuation">)</span>  <span class="token comment">// 当 O 显式原型 严格等于  L隐式原型 时，返回true</span>

          <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>   

    <span class="token constant">L</span> <span class="token operator">=</span> <span class="token constant">L</span><span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>  

<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> </li><li> <p>instanceof判断构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p> 
          <ul><li> <p>instanceof 的工作原理就是将 s 每一层的 <strong>proto</strong> 与 F.prototype 做比较<br> 找到相同返回 true<br> 至最后一层仍没有找到返回 false</p> </li><li> <p>比如判断 一个字段的类型是否是数组</p> 
            <ul><li>会先拿这个数组的原型链__proto__原型链对比数组的原型prototype</li><li>如果一致则返回true，否则继续对比</li><li>下一层的原型链就是Object的了，如果还是不一样就继续对比</li><li>一直到为null，则返回false</li></ul> </li><li> <p>但instanceof有个缺点，不能用来判断是否为Object，因为最终都指向了Object。</p> </li></ul> </li></ul> </li></ol> </li></ul> </li><li> <p>koa-bodyparser</p> 
    <ul><li>平台服务总是报很多json类的转换异常，看不到具体的日志，因为没有执行到中间件就被捕获了。</li><li>后来发现只要post请求的body参数不是json类型，该插件就会抛错，然后被全局异常捕获。然后单独把这个包拿出来，只做一个打印，然后由拦截器中间件来处理这个错误</li></ul> </li></ul> </li><li> <p>什么是原型和原型链</p> 
  <ul><li>原型 
    <ul><li>每个对象都有<strong>prototype</strong>属性</li><li>prototype包含了对象的属性和方法</li></ul> </li><li>原型链 
    <ul><li>对象的追踪过程，函数-&gt;对象-&gt;null</li></ul> </li></ul> </li><li> <p>什么是闭包</p> 
  <ul><li> <p>函数内部保存的变量不随这个函数调用结束而被销毁就是闭包</p> </li><li> <p>闭包的应用场景</p> 
    <ul><li>操作函数内部变量</li><li>将变量维护在内存中不释放</li><li>常见的例子就是递归计算和函数式编程</li></ul> </li><li> <p>闭包的例子</p> <pre><code class="prism language-typescript"><span class="token keyword">const</span> <span class="token function-variable function">fun</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> num <span class="token operator">+=</span> v<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> data5 <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//初始化函数fun并得到函数的匿名函数返回值(这里只初始化了一次)</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">data5</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//1    给匿名函数传参并得到累加的结果</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">data5</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2 	由于fun函数未重新初始化，且此时num的值为1，所以累加得2</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">data5</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//3	与上面雷同</span>
</code></pre> </li></ul> </li><li> <p>什么是深拷贝和浅拷贝</p> 
  <ul><li>比如基本类型是深拷贝，拷贝的是值</li><li>对象是浅拷贝，拷贝的是引用地址</li><li>需要重新分配内存地址才能解决浅拷贝问题 
    <ul><li> <p>常用的方法有</p> 
      <ul><li>JSON.parse(JSON.stringify(obj))</li><li>lodash的deepLone方法</li><li>自定义克隆方法</li></ul> <pre><code class="prism language-typescript"><span class="token keyword">const</span> <span class="token function-variable function">deepClone</span> <span class="token operator">=</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> clonedObj <span class="token operator">=</span> <span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      clonedObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> clonedObj<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> </li></ul> </li></ul> </li><li> <p>JavaScript作用域</p> 
  <ul><li> <p>分为全局和局部作用域</p> 
    <ul><li> <p>每次代码执行前会先进行"预编译"</p> </li><li> <p>比如有下面一段代码</p> </li></ul> <pre><code class="prism language-typescript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
   <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c <span class="token operator">+</span> b <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
    <ul><li> <p>在执行之前会先预编译成以下的预编译代码</p> 
      <ul><li>生成全局作用域 global object 简称go</li></ul> </li></ul> <pre><code class="prism language-typescript"><span class="token constant">GO</span><span class="token punctuation">{<!-- --></span>
  a<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
  <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span> foo<span class="token punctuation">{<!-- --></span><span class="token operator">...</span><span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> 
    <ul><li>执行到foo的时候 生成foo的函数局部作用域 active object 简称ao</li></ul> <pre><code class="prism language-typescript"><span class="token constant">AO1</span><span class="token punctuation">{<!-- --></span>
  b<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
  <span class="token function-variable function">bar</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token operator">...</span><span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> 
    <ul><li>执行foo内部函数bar的时候，生成bar的函数局部作用域</li></ul> <pre><code class="prism language-typescript"><span class="token constant">AO2</span><span class="token punctuation">{<!-- --></span>
  c<span class="token operator">:</span> <span class="token keyword">undefined</span>
 <span class="token punctuation">}</span>
</code></pre> 
    <ul><li> <p>然后先执行ao2，给变量c复制，在当前局部作用域可以找到，然后执行b，发现当前局部作用域没有，于是就去外层的作用域查找，找到了，执行。然后执行a，发现发现当前局部作用域没有，于是就去外层的作用域查找，发现也没有，一直找到全局作用域，找到了执行，没找到就当作undefind处理</p> 
      <ul><li>其中 这个查找的过程就是作用域链，有点类似js的原型链</li></ul> </li></ul> </li></ul> </li><li> <p>JavaScript继承，更详细的请查看<a href="https://blog.csdn.net/qq_42427109/article/details/130521357?spm=1001.2014.3001.5502">JS继承原理</a></p> 
  <ul><li> <p>es5</p> 
    <ul><li> <p>原型继承</p> 
      <ul><li> <p>使用prototype重新赋值，然后再扩展新对象的prototype</p> </li><li> <p>示例</p> <pre><code class="prism language-typescript"><span class="token comment">// 继承</span>
<span class="token constant">B</span><span class="token punctuation">.</span>prototype<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name"><span class="token constant">A</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 扩展</span>
<span class="token constant">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">splice</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> </li></ul> </li><li> <p>call和apply，<a href="https://blog.csdn.net/qq_42427109/article/details/130511055?spm=1001.2014.3001.5501">更详细的请查看这篇文章</a></p> 
      <ul><li> <p>用来改变this的指向，将一个对象作为另一个对象的实现</p> </li><li> <p>示例</p> <pre><code class="prism language-typescript"><span class="token keyword">function</span> <span class="token function">myfunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Lee'</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">myTxt</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>txt<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">'i am'</span><span class="token punctuation">,</span>txt <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">myfunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token function">myfunc1</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> myfunc3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">myfunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myfunc3<span class="token punctuation">.</span><span class="token function">myTxt</span><span class="token punctuation">(</span><span class="token string">'Geing'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// i am Geing</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span> <span class="token punctuation">(</span>myfunc3<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// Lee</span>
</code></pre> </li><li> <p>其中myfun2中没有任何实现，只是将myfun1替换了myfun2的实现</p> </li><li> <p>区别</p> 
        <ul><li>call的第二个参数可以是任意类型，而apply必须是数组</li></ul> </li></ul> </li></ul> </li><li> <p>es6</p> 
    <ul><li> <p>使用class类，通过extends关键字实现继承</p> 
      <ul><li> <p>类只是一个语法糖，背后其实还是构造函数来实现的</p> </li><li> <p>原理</p> 
        <ul><li> <p>通过_inherits函数实现</p> </li><li> <p>先判断当前对象是否是函数，如果不是函数则报错类型异常</p> </li><li> <p>然后就是继承父类的原型和原型链，下面是示例</p> <pre><code class="prism language-typescript"><span class="token comment">// 继承原型链</span>
<span class="token constant">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_proto_ <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">.</span>prototype
</code></pre> </li></ul> </li></ul> </li><li> <p>super关键字用来做什么，<a href="https://blog.csdn.net/qq_42427109/article/details/130533071?spm=1001.2014.3001.5501">更详细的请查看这篇文章</a></p> 
      <ul><li>用于访问和调用对象父类上的函数</li></ul> </li><li> <p>super为什么在构造函数中必须写在前面，否则就不能用this？</p> 
      <ul><li> <p>比如下面的代码</p> <pre><code class="prism language-typescript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">class</span> <span class="token class-name">PolitePerson</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">greetColleagues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这行代码是无效的，后面告诉你为什么</span>
   <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">greetColleagues</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Good morning folks!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> 
        <ul><li>如果允许在调用super之前使用this的话。一段时间后，我们可能会修改greetColleagues，并在提示消息中添加Person的name：</li></ul> <pre><code class="prism language-typescript"><span class="token function">greetColleagues</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Good morning folks!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'My name is '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">', nice to meet you!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre> 
        <ul><li> <p>但是我们忘记了super()在设置this.name之前先调用了this.greetColleagues()。 所以此时this.name还没有定义，就会出现出现undefind</p> </li><li> <p>所以javascript强制在this之前调用super，先完成父类构造函数的构建，再执行子类</p> </li></ul> </li><li> <p>super的实现也是使用call方法</p> </li></ul> </li></ul> </li></ul> </li><li> <p>bind,call和apply应用场景和区别，<a href="https://blog.csdn.net/qq_42427109/article/details/130511055?spm=1001.2014.3001.5501">更详细的请查看这篇文章</a></p> 
  <ul><li>都可以用来改变this指向</li><li>call的第二个参数是任意类型</li><li>apply的第二个参数是数组</li><li>应用场景 
    <ul><li>call和apply多用来实现继承</li><li>bind多用来改变this指向</li></ul> </li></ul> </li><li> <p>2个等于号和3个等于号区别，<a href="https://blog.csdn.net/qq_42427109/article/details/130605484?spm=1001.2014.3001.5501">更详细的请查看这篇文章</a></p> 
  <ul><li>2个会进行类型转换 比如判断1和’1’ 他们是相等的</li><li>3个不会进行类型转换，所有是严格判断</li></ul> </li><li> <p>线上cpu高的问题</p> 
  <ul><li>定时器 
    <ul><li>有一天突然线上服务的cpu不间断的飙升到三四百</li><li>于是排查代码,发现在早期的代码中，有一处每30s批量查询数据库(根据指定客户数，并发在20-30之间)，并对返回值进行计算和处理(批量计算客户的号码区间，筛选和重组，比如03766848660-03766848889)</li><li>因为该业务对性能要求不高，所以让同事把代码改为分批执行，每次执行十个，就解决了此性能问题</li></ul> </li><li>redis 
    <ul><li>有一天上午十点多收到运维通知，redis告警cpu占用率高，于是就排查最近代码，发现其他部门有同事，在关键业务处使用keys*来查询所有 
      <ul><li>于是立马所属部门同事，给出建议方案进行更改</li></ul> </li><li>有一些大key，存储了一个账户的所有座席配置(存储的数据量过大，高大几m甚至几十m)，频繁获取也会导致redis cpu飙升。于是在当天晚上就进行了简化，只存储业务需要的字段，对不需要的字段进行剔除</li></ul> </li></ul> </li><li> <p>线上内存高的问题</p> 
  <ul><li>内存泄漏 
    <ul><li>有一天下午，客户报问题，服务突然不可用了 
      <ul><li>发现node接口服务自动重启了</li><li>查看最近代码发现是因为有人用了global对象，全局缓存。用来给数据库降低压力的，但是有一个用户监控类的缓存没有清除，导致内存持续升高</li><li>后来改成放在redis中后解决</li></ul> </li></ul> </li><li>流出宽带高 
    <ul><li>系统中提供了对外开放接口，但早期部分接口没有做分页，允许查询所有，导致某一天数据库的外网出流量特别高，数据库频繁告警。所以就立刻做了热更新，做了默认分页20，解决了此问题</li></ul> </li><li>数据库内存暴涨，导致某节点重启。同事在对线上服务做脚本处理时(分析线上用户数据脚本)，因为走的是内部鉴权，没有限制。导致对查询没有做好并发控制，瞬间的并发(同时发起100个查询请求，持续几分钟)，拖垮了数据库节点。导致了故障。后续解决方案是统一了鉴权，不再放宽内部请求。</li></ul> </li><li> <p>排查内存泄漏的方案是什么</p> 
  <ul><li>看最近代码是否有以下问题 
    <ul><li>全局对象</li><li>闭包</li><li>定时器用过后没有清除</li></ul> </li><li>或者使用easy-monitor可视化工具查看某段时间的内存使用情况</li></ul> </li><li> <p>数组和链表数据结构和区别，<a href="https://blog.csdn.net/qq_42427109/article/details/130622987?spm=1001.2014.3001.5501">更详细的请查看这篇文章</a></p> 
  <ul><li>数组 有顺序，大小固定，查询效率高</li><li>链表 无顺序，没有固定大小，插入删除效率高</li></ul> </li><li> <p>什么是缓冲区</p> 
  <ul><li>nodejs buffer是一个二进制数据流，在操作文件的时候会用到。处理数据流</li></ul> </li><li> <p>Nodejs最近大版本都更新了什么，<a href="https://blog.csdn.net/qq_42427109/article/details/130581875?spm=1001.2014.3001.5501">更详细的请查看这篇文章</a></p> 
  <ul><li> <p>官网维护的更新日志</p> </li><li> <p>https://github.com/nodejs/node/tree/main/doc/changelogs</p> </li><li> <p>node 10</p> 
    <ul><li>支持http2</li><li>增加了n-api 支持</li><li>修复了一些漏洞</li></ul> </li><li> <p>node 12</p> 
    <ul><li>提供了打印堆快照的工具</li><li>http换成lhttp</li><li>Worker Threads 工作线程</li></ul> </li><li> <p>node 14</p> 
    <ul><li>支持es module，使用import导入模块</li><li>升级v8版本</li><li>可选链，空值合并操作符</li><li>异步本地存储。async 调用栈追踪，由此的来了trace，链路追踪id的插件</li></ul> </li><li> <p>node 16</p> 
    <ul><li>更新v8版本</li><li>返回promise的定时器</li><li>Node.js针对不同的平台提供预构建的二进制文件，给苹果芯片提供了新的二进制版本</li><li>其他相关漏洞修复</li></ul> </li><li> <p>node 18</p> 
    <ul><li>内置fetch，基于undiciundici</li><li>内置test单元测试模块</li><li>更新v8版本</li><li>其他修复等</li></ul> </li></ul> </li><li> <p>js如何判断数据类型，<a href="https://blog.csdn.net/qq_42427109/article/details/130492172?spm=1001.2014.3001.5501">更详细的请查看这篇文章</a></p> 
  <ul><li> <p>typeof，instanceof，Object.prototype.toString.call</p> </li><li> <p>Object.prototype.toString.call()原理</p> 
    <ul><li>和instanceof相同，但使用的是就近原型链，而不会去向上寻找(比如找到了顶级Object)。所以传入一个数组时，就获取的是数组的原型链__proto__是Array</li></ul> </li><li> <p>和instanceof，type of区别</p> 
    <ul><li> <p>typeof只能判断基本类型，引用类型都是object</p> </li><li> <p>instanceof判断构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p> <pre><code class="prism language-typescript"><span class="token keyword">function</span> <span class="token function">instance_of</span><span class="token punctuation">(</span><span class="token constant">L</span><span class="token punctuation">,</span> <span class="token constant">R</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//L 表示左表达式，R 表示右表达式 </span>
  
  <span class="token keyword">var</span> <span class="token constant">O</span> <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>   <span class="token comment">// 取 R 的显示原型 </span>
  
  <span class="token constant">L</span> <span class="token operator">=</span> <span class="token constant">L</span><span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>  <span class="token comment">// 取 L 的隐式原型</span>
  
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>    
  
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">L</span> <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span>      
  
         <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   
  
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">O</span> <span class="token operator">===</span> <span class="token constant">L</span><span class="token punctuation">)</span>  <span class="token comment">// 当 O 显式原型 严格等于  L隐式原型 时，返回true</span>
  
         <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>   
  
    <span class="token constant">L</span> <span class="token operator">=</span> <span class="token constant">L</span><span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>  
  
  <span class="token punctuation">}</span>
  
<span class="token punctuation">}</span>
</code></pre> 
      <ul><li> <p>instanceof 的工作原理就是将 s 每一层的 <strong>proto</strong> 与 F.prototype 做比较<br> 找到相同返回 true<br> 至最后一层仍没有找到返回 false</p> </li><li> <p>比如判断 一个字段的类型是否是数组</p> 
        <ul><li>会先拿这个数组的原型链__proto__原型链对比数组的原型prototype</li><li>如果一致则返回true，否则继续对比</li><li>下一层的原型链就是Object的了，如果还是不一样就继续对比</li><li>一直到为null，则返回false</li></ul> </li><li> <p>但instanceof有个缺点，不能用来判断是否为Object，因为最终都指向了Object。</p> </li></ul> </li></ul> </li></ul> </li><li> <p>node如何接受客户端上传的文件</p> 
  <ul><li>使用node的multer或者busboy等工具包</li><li>接受前端的form表单文件</li><li>然后使用node的stream流写入文件</li></ul> </li><li> <p>箭头函数，<a href="https://blog.csdn.net/qq_42427109/article/details/130526529?spm=1001.2014.3001.5501">更详细的请查看这篇文章</a></p> 
  <ul><li>缩短函数代码</li><li>解决this指向问题</li></ul> </li><li> <p>单元测试</p> 
  <ul><li>mocha框架</li><li>提高项目质量</li><li>减少测试成本</li><li>精准定位bug</li></ul> </li></ul> 
<p>TypeScript</p> 
<ul><li> <p>特点</p> 
  <ul><li>能够使用最新的esma规范</li><li>js的超集</li><li>静态类型化编程</li><li>提供了注解，更现代化的开发模式</li><li>编译期间的类型检查</li></ul> </li><li> <p>应用场景</p> 
  <ul><li>中大型企业的最佳选择</li><li>使用最新的ECMA规范</li><li>更健壮的企业级服务</li></ul> </li><li> <p>缺点</p> 
  <ul><li>增加了类型，提高了开发工作量</li><li>有一些库目前还不支持ts，比如缺少.d.ts文件</li><li>对团队素质要求高</li></ul> </li><li> <p>目前用的什么版本，有什么特性</p> 
  <ul><li> <p>目前用的4.6版本</p> 
    <ul><li> <p>特性</p> 
      <ul><li> <p>super关键字允许写在this后面，以前只能写在前面</p> </li><li> <p>枚举类型支持解构</p> <pre><code class="prism language-typescript"><span class="token keyword">type</span> <span class="token class-name">Action</span> <span class="token operator">=</span>
<span class="token operator">|</span> <span class="token punctuation">{<!-- --></span> kind<span class="token operator">:</span> <span class="token string">"NumberContents"</span><span class="token punctuation">,</span> payload<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>
<span class="token operator">|</span> <span class="token punctuation">{<!-- --></span> kind<span class="token operator">:</span> <span class="token string">"StringContents"</span><span class="token punctuation">,</span> payload<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 以前结构会报错</span>
<span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> kind<span class="token punctuation">,</span> payload <span class="token punctuation">}</span> <span class="token operator">=</span> action<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>kind <span class="token operator">===</span> <span class="token string">"NumberContents"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> num <span class="token operator">=</span> payload <span class="token operator">*</span> <span class="token number">2</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>更智能的jsdoc，通过注释也可以看到类型</p> </li><li> <p>其他的问题修复等</p> </li></ul> </li></ul> </li></ul> </li><li> <p>经常用哪些类型接口</p> 
  <ul><li>type 简单类型 字符串数字等</li><li>interface 复杂类型 对象等</li><li>Record <strong>根据输入的索引生成新类型</strong></li><li>Pick <strong>取旧类型中的部分索引类型为新类型</strong></li><li>Omit <strong>提出原类型中的部分属性，生成新的类型</strong></li><li>Exclude <strong>根据索引移除类型中的key得到新的索引类型</strong></li><li><strong>ReturnType</strong> <strong>获取函数返回值类型</strong></li></ul> </li><li> <p><a href="https://blog.csdn.net/qq_42427109/article/details/131153458?spm=1001.2014.3001.5501">自定义装饰器和原理</a></p> </li></ul> 
<h4><a id="_1612"></a>数据库</h4> 
<p>Mongodb</p> 
<ul><li> <p>关系型和非关系型区别</p> 
  <ul><li>sql语句不同，mongo的是json类型，而mysql是一个字符串语句，中间用空格间隔</li><li>关系型支持连表，非关系型不支持</li><li>非关系型数据结构灵活，比如mongo，都是key，value类型</li><li>非关系型比关系型更灵活，比如mongo可以随时的动态增删字段</li></ul> </li><li> <p>Mongodb应用场景</p> 
  <ul><li>操作简单，开发成本低。因为数据结构都是json，尤其和javascript很契合</li><li>扩展性强。nosql型数据库不要求强一致的字段结构，可以随便的增删字段</li><li>高性能和吞吐量。传统型数据库都有事务，导致速度没有mongo快</li><li>mongodb分片集群。扩展方便，提高集群性能和高可用性</li></ul> </li><li> <p>Mongo优缺点</p> 
  <ul><li>优点 
    <ul><li>弱一致性，不要求强一致数据结构</li><li>高扩展性，任意扩展字段和数据库集群节点</li><li>mongodb是商业化的，发展稳定</li><li>JSON存储结构，开发高效</li><li>更现代化的可视化管理工具，比如MongodbCompase，NoSQLBooster，ClusterControl等</li></ul> </li><li>缺点 
    <ul><li>表关联查询支持弱，在部分复杂业务场景下，开发效率低</li><li>旧版本不支持事务(新版本3.6支持)</li><li>因为弱类型，可以更改数据类型，后期维护成本高</li><li>占用空间大，因为都是bson结构的key，value形式</li></ul> </li></ul> </li><li> <p>Mongo集群是否了解</p> 
  <ul><li>什么是副本集 
    <ul><li>概念 
      <ul><li>mongodb的高可用方案</li></ul> </li><li>应用场景 
      <ul><li>数据备份</li><li>数据恢复</li><li>读写分离</li></ul> </li><li>副本集最小可用方案 
      <ul><li>一主两从</li></ul> </li><li>都有哪些独写策略 
      <ul><li>primary 默认 所有的读操作都从当前副本集主节点</li><li>primaryPreferred 从主节点读取数据，但是如果主节点不可用了，会从从节点读取</li><li>secondary 所有读操作都从副本集的从节点读取</li><li>secondaryPreferred 从从节点进行读操作，但是如果从节点都不可用了，从主节点读取</li><li>nearest 从副本集中延迟最低的成员读取，不考虑成员的类型</li></ul> </li></ul> </li><li>副本集配置</li><li>最小配置 
    <ul><li>一主两从</li></ul> </li><li>一个主节点 
    <ul><li>一个复制集有且仅有一台服务器处于Primary状态，只有主节点才对外提供读写服务。如果主节点挂掉，复制集将投票选出一个备节点成为新的主节点</li></ul> </li><li>两个备用节点 
    <ul><li>备用节点，复制集允许有多台Secondary，每个备用节点的数据与主节点的数据是完全同步的。Recovering 恢复中，当复制集中某台服务器挂掉或者掉线后数据无法同步，重新恢复服务后从其他成员复制数据，这时就处于恢复过程，数据同步后，该节点又回到备用状态</li></ul> </li><li>一个仲裁节点 
    <ul><li>该类节点可以不用单独存在，如果配置为仲裁节点，就主要负责在复本集中监控其他节点状态，投票选出主节点。该节点将不会用于存放数据。如果没有仲裁节点，那么投票工作将由所有节点共同进行</li></ul> </li><li>副本集健康检测 
    <ul><li>每个成员都需要知道其他成员的状态：哪个是主节点？哪个可以作为同步源？哪个挂掉了？为了维护集合的最新视图，每个成员每隔两秒钟就会向其他成员发送个心跳请求(heartbeat request)。心跳请求的信息量非常小，用于检查每个成员的状态</li></ul> </li><li>数据同步和恢复 
    <ul><li>每个节点都有自己的oplog日志，该日志记录了每一个写操作，备份节点通过该日志同步数据，后续也通过该日志恢复数据</li></ul> </li><li>副本集搭建 
    <ul><li><a href="https://blog.csdn.net/qq_42427109/article/details/99305926?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168437779916800213017334%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=168437779916800213017334&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-99305926-null-null.article_score_rank_blog&amp;utm_term=mongodb%E5%89%AF%E6%9C%AC%E9%9B%86%E6%90%AD%E5%BB%BA&amp;spm=1018.2226.3001.4450">更详细的请查看这篇文章</a></li></ul> </li><li>副本集主节点选举过程 
    <ul><li>触发选举的时机 
      <ul><li>副本集被加入了新节点</li><li>重启副本集</li><li>使用rs.stepdown命令(将主节点降低)或使用rs.reconfig命令(重新配置现有副本集)</li><li>心跳检测超时，比如主节点或副节点崩溃</li></ul> </li><li>选举过程 
      <ul><li>选举规则是根据票数来决定，票数最高，且获得了“大多数”成员的投票支持的节点获胜。“大多数”：假设复制集内投票成员数量为N，则大多数为 N/2 + 1。例如：3个投票成员，则大多数的值是2。当复制集内存活成员数量不足大多数时，整个复制集将无法选举出Primary，复制集将无法提供写服务，处于只读状态</li><li>若票数相同，且都获得了“大多数”成员的投票支持的，节点状态是健康的，节点优先级高且数据新的节点获胜。数据的新旧是通过操作日志oplog来对比的，优先级可以通过人工配置</li></ul> </li><li>仲裁节点 
      <ul><li>提升集群可用性 
        <ul><li>假设现在有三个节点，其中两个节点崩溃，那么按照N/2+1的选举规则，3/2+1&gt;1，但此时只有一个节点存活，所以无法进行投票，就导致集群不可用</li><li>有了仲裁节点后，仲裁节点不存储数据，只用来选举。那么你当前的节点数就是2，在两个节点崩溃的情况下，因为有了仲裁节点的加入，使得集群可以正常投票选举，继续提供服务</li></ul> </li></ul> </li><li>为什么集群节点通常都要求是奇数而不是偶数 
      <ul><li>主要防止脑裂的情况 
        <ul><li>通常在集群间通信异常的时候，可能会分裂成两个小集群 
          <ul><li>奇数的情况下，比如5台机器，由于脑裂分裂成了以下两组</li><li>A：1节点 B：4节点</li><li>A：2节点 B：3节点</li><li>…</li><li>因为(总节点数/2)+1的模式，那么总会有一个小集群在选举后继续提供服务</li></ul> </li><li>偶数的情况下，比如4台机器，由于脑裂分裂成了以下两组 
          <ul><li>A：1节点 B：3节点</li><li>A：2节点 B：2节点</li><li>…</li><li>因为(总节点数/2)+1的模式，其中第二种情况因为不满足选举模式，从而导致无法继续提供服务</li></ul> </li></ul> </li></ul> </li></ul> </li><li>什么是分片 
    <ul><li>概念 
      <ul><li>把一张表中的数据分割到不同的服务器上进行保存。一般用在特别大量的数据库集群中，比如一张表的数据几百个g这种，通过分片到多台服务器上。比如传统的副本集，所有的数据都在一个服务器上，分片通过分布式存储来提高查询性能。</li><li>每一个分片集群都有一个主分片，其中包含该数据库的所有未分片集合，存储了所有未分片集合的数据</li><li>在初始化数据库时，会选择集群中数据量最少的分片作为主分片</li></ul> </li><li>组成 
      <ul><li>mongos路由，用于将请求转发给不同的分片，将多个分片的结果进行整合</li><li>config-server，保存集群的元数据，比如分片的路由规则，服务器配置等等</li><li>分片，存储数据库数据，一个分片默认是64m。分片由分片键和分片算法组成 
        <ul><li>分片键 
          <ul><li>有了分片，但还需要解决数据块的问题，如果所有的数据库都存储在一个分片，那么性能会打折扣。所以出现了分片键，分片键能够将数据块分为多个小块分别存储在不同的分片中来提升性能 
            <ul><li>范围片键 
              <ul><li>可以高效的读取连续范围内的目标文档。如果你使用范围查询，则可以比较快速的拿到所有的结果值。因为数据所在的数据chunk比较少</li></ul> </li><li>hash片键 
              <ul><li>哈希分片在分片集群中提供了更均匀的数据分布，集合中那些具有近似值的文档，可能会被分到不同的块上</li></ul> </li></ul> </li></ul> </li><li>每一个分片集群有一个主分片</li><li>每一个分片默认三个副本</li></ul> </li></ul> </li></ul> </li><li>分片和副本集的区别 
    <ul><li>副本集 
      <ul><li>硬件和维护成本低</li><li>发生故障时，备份直接可以直接恢复服务</li></ul> </li><li>分片 
      <ul><li>维护成本高，因为将数据分部到了很多台机器上</li><li>对数据流大的应用来说能显著提高查询性能</li></ul> </li></ul> </li><li>如果一个分片（Shard）停止或很慢的时候，发起一个查询会怎样 
    <ul><li>如果一个分片停止了，除非查询设置了“Partial”选项，否则查询会返回一个错误。如果一个分片响应很慢，MongoDB会等待它的响应</li></ul> </li><li>数据在什么时候才会扩展到多个分片(shard)里 
    <ul><li>MongoDB 分片是基于区域(range)的。所以一个集合(collection)中的所有的对象都被存放到一个块(chunk)中。只有当存在多余一个块的时候，才会有多个分片获取数据的选项。现在，每个默认块的大小是 64Mb，所以你需要至少 64 Mb 空间才可以实施一个迁移。</li></ul> </li><li>其他 
    <ul><li>副本集默认每2秒检测心跳，感知其他节点是否宕机，角色发生转换等</li><li>副本集依赖oplog，mongo的写操作日志来完成数据的同步的</li><li>副本集的主从同步机制核心是，主节点在完成写操作后同步到oplog日志中，然后从节点主动拉取oplog日志中的日志</li></ul> </li></ul> </li><li> <p>都有哪些数据类型</p> 
  <ul><li>和mysql类似，底层存储的时候会有以下类型 
    <ul><li>string</li><li>array</li><li>boolean</li><li>date</li><li>double</li><li>int</li><li>object</li><li>等等</li></ul> </li></ul> </li><li> <p>ObjectId如何组成</p> 
  <ul><li>一个24位数的字符串 
    <ul><li>前八位是时间戳</li><li>后六位是主机标识</li><li>后四位是进程id</li><li>后六位是自增的随机数</li></ul> </li></ul> </li><li> <p>什么是索引</p> 
  <ul><li>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。就好比书的目录，有了目录才能更精确的查找，否则只能进行全表搜索</li></ul> </li><li> <p>常用的索引类型</p> 
  <ul><li>主键索引 
    <ul><li>主键_id，数据库默认插入的索引</li></ul> </li><li>唯一索引 
    <ul><li>针对某一个字段的索引</li></ul> </li><li>复合索引 
    <ul><li>多字段联合的索引</li></ul> </li></ul> </li><li> <p>索引的优缺点</p> 
  <ul><li>优点 
    <ul><li>提升数据查询性能</li></ul> </li><li>缺点 
    <ul><li>占用额外的空间</li><li>维护索引成本</li></ul> </li></ul> </li><li> <p>mongodb索引数据结构和原理</p> 
  <ul><li>mongodb使用的是基于二叉树的B树 
    <ul><li>因为在大多数场景中，都是读多写少。所以相比较传统的B+树(只有叶节点存放数据，其余节点用来索引)，mongodb的设计是为了更高的查询性能而来。B树的每个索引节点都会有Data域。所有对于B树来说，只要找到对应的索引节点，就可以访问，所以对于非范围类查询性能很高。</li></ul> </li><li>叶子节点：没有孩子节点的节点叫作叶子节点</li><li>非叶子节点：跟叶子节点相反，有孩子节点的节点</li></ul> </li><li> <p>Mongo查询计划</p> 
  <ul><li>db.find().explain</li><li>都看哪些指标？ 
    <ul><li>stage 直接看出是否使用索引 
      <ul><li>FETCH 根据索引位置查找</li><li>IXSCAN 索引扫描</li><li>COLLSCAN 全表扫描</li></ul> </li><li>nReturned 返回了多少</li><li>totalKeysExamined 索引扫描了多少</li><li>totalDocsExamined 文档扫描了多少</li><li>executionTimeMillis 整体执行时长</li></ul> </li><li>一般看着这几个指标就能看出是否用到了索引，或者索引是否设计合理</li></ul> </li><li> <p>数据库语句执行过程</p> 
  <ul><li>首选客户端向服务器发送一个查询请求</li><li>服务器先检查是否有缓存，有缓存则返回，没有缓存则执行下一个阶段 
    <ul><li>缓存的重新发生在数据库表数据大小，表结构等发生变更时</li></ul> </li><li>下一个阶段 
    <ul><li>sql解析 
      <ul><li>检查sql是否合法，如果find查询第一个参数指定的操作符不对，比如$in写成了in，则mongo解析会抛异常</li></ul> </li><li>预处理 
      <ul><li>生成该sql的最优查询计划</li></ul> </li><li>执行胜出的查询计划并齿形</li><li>将结果返回给客户端</li></ul> </li></ul> </li><li> <p>数据库cpu高的问题</p> 
  <ul><li>瞬间有很多大量的慢查询，一直没有处理完，导致cpu飙升 
    <ul><li>是因为内部产品交互通过http，但是没有控制频率，导致大量请求瞬间打到服务和数据库</li><li>当时解决的方案是 
      <ul><li>通过日志分析平台，统计最近半小时的请求和频次</li><li>查看代码用到该查询条件的代码</li></ul> </li><li>找到了一个频次异常的接口</li><li>找到了对应的代码</li><li>锁定到是内部运营平台调用释放客服号码的接口，这个接口是释放一个租户内的所有号码，少则几十个，多则几百上千。运营平台来调用的时候没有控制频率，导致瞬间几千个请求打过来。数据库的cpu就飙升了</li><li>然后联系到使用运营平台的人，暂停这个操作(因为系统有记录操作人)。暂停后，数据库负载恢复，后续我们的接口增加频次限制，运营平台也增加调用接口的频次控制</li></ul> </li><li>内部报表统计接口查询报表，因为报表的数据流大，查询时间有时候会在几秒，统计的时候没有注意频次，cpu也会飙升</li></ul> </li><li> <p>数据库内存高的问题</p> 
  <ul><li>某一天数据库的内存频繁告警超过80%，于是先查看数据库慢查询(怀疑是查询的结果集过大)，然后锁定到了几张表。</li><li>查找几个涉及到这个表查询的业务，导出，对外接口</li><li>然后就分析导出和对外接口的调用频次</li><li>发现有个请求，指定的查询结果数是1000，平均每秒1-2次请求</li><li>然后我们内部有一个限流器 
    <ul><li>根据ip限制它一分钟只能调用20次</li><li>查询结果，一次最多100个</li></ul> </li><li>然后数据库的内存占用量就恢复了</li></ul> </li><li> <p>数据库流量高的问题</p> 
  <ul><li>和上面的问题一样</li></ul> </li><li> <p>Mongo底层存储结构</p> 
  <ul><li>mongo使用的是WiredTiger存储引擎，该引擎使用B树作为数据结构</li><li>B树是一种自平衡的搜索，和二叉树不同的是，二叉树最多两个子节点，而B树是每个节点的关键字=节点数-1</li><li>每个树节点都存有数据，所以只要找到索引就可以进行访问，更适合查询</li></ul> </li><li> <p>性能优化<br> 在上面"NodeJs如何提升性能和代码质量"中有提到</p> </li><li> <p>慢查询分析</p> 
  <ul><li>db.system.profile.find({“millis”:{$gte:8000}}).limit(10).pretty();比如查询十条时间大于8000毫秒的sql语句并对结果进行美化 
    <ul><li>该慢查询结果将返回查询消耗的时间，查询指定，查询条件等</li></ul> </li><li>然后我们可以再使用explain对该查询条件进行分析，在上面的"Mongo查询计划"已提到查询计划的关键指标</li><li>在知道具体的慢查询库，表和查询条件后，我们可以查看服务代码来进行排查和优化</li></ul> </li></ul> 
<p>Redis</p> 
<ul><li> <p>和其他传统数据库区别</p> 
  <ul><li>redis的sql语句和传统的不同</li><li>redis基于内存内存，省去了磁盘操作，所以性能高</li><li>redis多用于热点数据查询，不像传统数据库用来存储大量数据</li></ul> </li><li> <p>Redis应用场景都有哪些</p> 
  <ul><li>热点数据缓存</li><li>缓存数据共享</li><li>分布式锁 nx</li><li>计数器 incr</li><li>单点登录</li></ul> </li><li> <p>数据结构</p> 
  <ul><li>string 
    <ul><li>字符串是所有编程语言中最常见和最常用的数据类型，而且也是redis最基本的数据类型之一，而且redis中所有key的类型都是字符串，它是一个由字节组成的序列，在Rediss中是二进制安全的。它是标准的key-value，通常用于存储字符串、整数和浮点。Value可容纳高达512MB的数据</li></ul> </li><li>list 
    <ul><li>列表是一个双向可读可写的管道，其头部是左侧，尾部是右侧，一个列表可以最多包含2^32-1个元素，即4294967295个元素</li></ul> </li><li>set 
    <ul><li>set是string类型的无序集合，集合中的成员是唯一的，这就意味着集合中不能出现重复的数据,可以在两个不同的集合中对数据进行比对并取值</li></ul> </li><li>zset 
    <ul><li>redis有序集合和集合一样，也是string类型元素的集合，且不允许重复的成员，不同的是每个元素都会关联一个double双精度浮点数类型的分数，redis正是通过该分数来为集合中的成员进行从小到大的排序，有序集合成员是唯一的，但分数却可以重复，集合是通过hash表实现的，所以添加，删除，查找的复杂度是O（1），集合中最大的成员数是2^32-1，每个集合可以存储40多亿成员</li></ul> </li><li>hash 
    <ul><li>hash是一个string类型的feild和value的映射表，hash特别适合用于存储对象，redis中每个hash可以存储40多亿键值对</li></ul> </li></ul> </li><li> <p>常用操作语句</p> 
  <ul><li>string 
    <ul><li>set/get 存储和获取key</li><li>mset/mget 批量存储和获取多个key</li><li>append 对某个key的值做追加操作</li><li>incr 对数值做递增操作</li><li>exists 判断某个key是否存在</li><li>expire 设置过期时间</li><li>ttl 查看过期时间</li><li>persist 取消key的过期时间变为永久</li></ul> </li><li>list 
    <ul><li>lpush 生成列表并插入数据</li><li>llen 获取列表长度</li></ul> </li><li>set 
    <ul><li>sadd 生成无序集合</li><li>smembers 获取无序集合set1的所有数据</li><li>sdiff 差集</li><li>sinter 交集</li><li>sunion 并集</li></ul> </li><li>zset 
    <ul><li>zadd 生成有序集合</li><li>zcard 获取集合长度</li></ul> </li><li>hash 
    <ul><li>hset 生成hash key</li><li>hdel 删除一个hash key的字段</li><li>hgetall 获取指定hash的所有key，value</li></ul> </li></ul> </li><li> <p>为什么Redis快</p> 
  <ul><li>基于内存，省去了操作磁盘的时间</li><li>单线程，减去了多线程的上下文切换和锁的问题</li><li>多路复用，类似nodejs事件循环，所有的读写都放入事件循环中，内部用多线程来执行</li></ul> </li><li> <p>常用的数据结构有哪些</p> 
  <ul><li>set 简单字符串存储</li><li>exists 是否存在指定key</li><li>del 删除key</li><li>mset 存储多个键值对</li><li>incr 计数器</li><li>expire 过期时间</li></ul> </li><li> <p>缓存击穿</p> 
  <ul><li>概念 
    <ul><li><strong>高并发流量，访问的这个数据是热点数据，请求的数据在 DB 中存在，但是 Redis 存的那一份已经过期，后端需要从 DB 加载数据并写到 Redis</strong></li><li>但由于高并发，可能会把数据库击垮，导致服务不可用</li></ul> </li><li>解决方案 
    <ol><li>热点key不设置过期时间</li><li>给热点key的过期时间设置一个随机值，避免同一时间过期 
      <ul><li>给一个1-10分钟的过期时间</li></ul> </li></ol> </li><li>问题场景 
    <ul><li>比如用户信息</li></ul> </li></ul> </li><li> <p>缓存穿透</p> 
  <ul><li>概念 
    <ul><li>意味着有特殊请求在查询一个不存在的数据，<strong>即数据不存在 Redis 也不存在于数据库</strong>。导致每次请求都会<strong>穿透</strong>到数据库，缓存成了摆设，对数据库产生很大压力从而影响正常服务</li></ul> </li><li>解决方案 
    <ul><li>缓存空值：当请求的数据不存在 Redis 也不存在数据库的时候，设置一个缺省值（比如：None）。当后续再次进行查询则直接返回空值或者缺省值</li></ul> </li><li>问题场景 
    <ul><li>在缓存击穿的基础上，数据库也查不到，也没有一个默认值，导致一直查询</li></ul> </li></ul> </li><li> <p>缓存雪崩</p> 
  <ul><li>概念 
    <ul><li><strong>大量的请求无法在 Redis 缓存系统中处理，请求全部打到数据库，导致数据库压力激增</strong></li></ul> </li><li>解决方案 
    <ul><li><strong>过期时间添加随机值</strong></li><li>http接口限流</li><li>服务熔断降级</li></ul> </li><li>问题场景 
    <ul><li>大量热点数据同时过期，导致大量请求需要查询数据库并写到缓存；</li><li>Redis 故障宕机，缓存系统异常</li></ul> </li></ul> </li><li> <p>过期策略</p> 
  <ul><li>定期策略 
    <ul><li>当Redis运行到设定的时期时会在具有过期设置的key中随机测试一些key，并且把其中过期的key从内存中删除</li><li>具体来说，Redis 每秒执行 10 次： 
      <ol><li>从具有关联过期的key集中测试 20 个随机key</li><li>删除所有发现过期的key</li><li>如果超过 25% 的key已过期，则从步骤 1 重新开始</li></ol> </li></ul> </li><li>惰性策略 
    <ul><li>当某个客户端试图访问key时，发现该key已超时会把此key从内存中删除</li></ul> </li></ul> </li><li> <p>内存淘汰策略</p> 
  <ul><li>noeviction：当内存使用达到<a href="https://so.csdn.net/so/search?q=%E9%98%88%E5%80%BC&amp;spm=1001.2101.3001.7020">阈值</a>的时候，所有引起申请内存的命令会报错</li><li>allkeys-lru：在<a href="https://so.csdn.net/so/search?q=%E4%B8%BB%E9%94%AE&amp;spm=1001.2101.3001.7020">主键</a>空间中，优先移除最近未使用的key</li><li><a href="https://so.csdn.net/so/search?q=volatile&amp;spm=1001.2101.3001.7020">volatile</a>-lru：在设置了过期时间的键空间中，优先移除最近未使用的key</li><li>allkeys-random：在主键空间中，随机移除某个key</li><li>volatile-random：在设置了过期时间的键空间中，随机移除某个key</li><li>volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的key优先移除</li><li>配置方法 
    <ul><li>编辑redis.conf，更改maxmemory-policy配置</li></ul> </li><li>redis默认是<strong>noeviction</strong></li></ul> </li><li> <p>持久化机制，优缺点</p> 
  <ul><li> <p>RDB</p> 
    <ul><li> <p>概念</p> 
      <ul><li>在指定时间将当前时刻内存中的数据生成一个快照文件（.rdb文件，默认为dump.rdb），并将这个快照文件保存到磁盘上。这样，即使redis宕机了，下次重启时也可以通过读取这个快照文件来恢复数据</li></ul> </li><li> <p>备份策略</p> 
      <ul><li> <pre><code>save 3600 1 -&gt; 3600秒内有1个key被修改，则触发RDB

save 300 100 -&gt; 300秒内有100个key被修改，则触发RDB

save 60 10000 -&gt; 60秒内有10000个key被修改，则触发RDB
</code></pre> </li><li> <p>重写操作是redis主进程fork一个子进程来处理，避免阻塞主进程</p> </li></ul> </li><li> <p><mark>redis默认是rbd策略</mark></p> </li></ul> </li><li> <p>AOF</p> 
    <ul><li> <p>概念</p> 
      <ul><li>AOF是redis提供的另一种数据持久化方式，它会记录客户端对redis服务端的每一次写操作，并将这些写操作以redis协议追加保存到后缀为aof的文件末尾。在redis服务器重启时，会读取并加载aof文件，达到恢复数据的目的。</li></ul> </li><li> <p>开启aof</p> 
      <ul><li>更改reids.conf中的appendonly配置，0为不开启，1为开启</li></ul> </li><li> <p>备份策略</p> 
      <ul><li><strong>appendfsync always</strong> 
        <ul><li>客户端对redis服务器的每次写操作都写入AOF日志文件。这种方式是最安全的方式，但每次写操作都进行一次磁盘IO，非常影响redis的性能，所以一般不使用这种方式。</li></ul> </li><li><strong>appendfsync everysec</strong> 
        <ul><li>每秒刷新一次缓冲区中的数据到AOF文件。这种方式是<mark>redis默认使用的策略</mark>，是考虑数据完整性和性能的这种方案，理论上，这种方式最多只会丢失1秒内的数据</li></ul> </li><li><strong>appendfsync no</strong> 
        <ul><li>redis服务器不负责将数据写入到AOF文件中，而是直接交给操作系统去判断什么时候写入。这种方式是最快的一种策略，但丢失数据的可能性非常大，因此也是不推荐使用的</li></ul> </li></ul> </li><li> <p>AOF重写</p> 
      <ul><li> <p>背景</p> 
        <ul><li>AOF是Redis增量模式的持久化方式，随着redis的持续运行，会不断有新的数据写入AOF文件中，逐渐占用大量磁盘空间，还会降低Redis启动速度。Redis中有rewrite机制来合并AOF历史记录。</li><li>比如当我们对同一个key做多次写操作时，就会产生大量针对同一个key操作的日志指令，导致AOF文件会变得非常大，恢复数据的时候会变得非常慢</li></ul> </li><li> <p>触发命令 <strong>bgrewriteaof</strong></p> </li><li> <p>触发策略</p> 
        <ul><li>auto-aof-rewrite-percentage 100 
          <ul><li>当文件的大小达到原先文件大小（上次重写后的文件大小，如果没有重写过，那就是redis服务启动时的文件大小）的两倍</li></ul> </li><li>auto-aof-rewrite-min-size 64mb 
          <ul><li>文件重写的最小文件大小，即当AOF文件低于64mb时，不会触发重写</li></ul> </li></ul> </li><li> <p>重写流程</p> 
        <ul><li> <p>（1）bgrewriteaof触发重写，判断是否存在bgsave或者bgrewriteaof正在执行，存在则等待其执行结束再执行；</p> <p>（2）主进程fork子进程，防止主进程阻塞无法提供服务；</p> <p>（3）子进程遍历Redis内存快照中数据写入临时AOF文件，同时会将新的写指令写入aof_buf和aof_rewrite_buf两个重写缓冲区，前者是为了写回旧的AOF文件，后者是为了后续刷新到临时AOF文件中，防止快照内存遍历时新的写入操作丢失；</p> <p>（4）子进程结束临时AOF文件写入后，通知主进程；</p> <p>（5）主进程会将上面的aof_rewirte_buf缓冲区中的数据写入到子进程生成的临时AOF文件中；</p> <p>（6）主进程使用临时AOF文件替换旧AOF文件，完成整个重写过程。</p> </li></ul> </li></ul> </li></ul> </li><li> <p>RDB优缺点</p> 
    <ul><li>优点 
      <ul><li>体积比aof小，rdb更紧凑</li><li>恢复的速度快，因为rdn是快照型数据，不用重新读取并写入内存</li></ul> </li><li>缺点 
      <ul><li>因为有同步间隔，所以宕机时毕竟存在数据丢失</li><li>虽然是异步备份，但当redis机器负载高的时候，备份的时间也会加长</li></ul> </li></ul> </li><li> <p>AOF优缺点</p> 
    <ul><li>优点 
      <ul><li>数据备份比RDB可靠，因为可以设置每次写入追加</li><li>自动重写机制，缩小aof文件</li></ul> </li><li>缺点 
      <ul><li>对redis性能有损耗，毕竟每次写入都同步</li><li>aof文件体积大，恢复时间长</li></ul> </li></ul> </li></ul> </li><li> <p>redis高可用</p> 
  <ul><li>主从模式 
    <ul><li>概念 
      <ul><li>和传统数据库一样，一主两从，用来做数据备份，提高数据库读写能力的</li></ul> </li><li>应用场景 
      <ul><li>读写分离 
        <ul><li>主写，从读，降低主节点压力，提高查询性能</li></ul> </li><li>数据备份 
        <ul><li>机器宕机，磁盘损坏等，可以用其他节点数据进行备份</li></ul> </li><li>提高服务高可用性 
        <ul><li>至少一主两从，主节点挂了，从节点顶上</li></ul> </li></ul> </li><li>数据同步策略 
      <ul><li>全量同步 
        <ul><li>发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份</li><li>1）从服务器连接主服务器，发送SYNC命令；<br> 　　2）主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；<br> 　　3）主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；<br> 　　4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照（快照文件先接收保存到磁盘，最后加载到内存中）；<br> 　　5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；<br> 　　6）从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li></ul> </li><li>增量同步 
        <ul><li>Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。 增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</li><li>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。<br> 增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令</li></ul> </li></ul> </li></ul> </li><li>哨兵 
    <ul><li>概念 
      <ul><li>用于监控Redis集群中Master状态的工具，是Redis高可用解决方案，哨兵可以监视一个或者多个redis master服务，以及这些master服务的所有从服务。 某个master服务宕机后，会把这个master下的某个从服务升级为master来替代已宕机的master继续工作。</li><li>即使后来之前的master重启服务，也不会变回master了，而是作为slave从服务</li></ul> </li><li>应用场景 
      <ul><li>当主服务器宕机时，需要将从服务器手动切换(<code>slaveof no one</code>)到主从服务器，这需要人工干预。</li></ul> </li><li>作用 
      <ul><li>心跳检测 
        <ul><li><strong>Sentinel会不断检查主服务器和从属服务器是否正常运行</strong></li></ul> </li><li>通知 
        <ul><li><strong>当受监控的Redis服务器出现问题时，Sentinel会通过API脚本向管理员或其他应用程序发送通知</strong></li><li>redis发布订阅来完成</li></ul> </li><li><strong>自动故障转移</strong> 
        <ul><li><strong>当主节点无法正常工作时，Sentinel将启动自动故障转移操作。它将与发生故障的主节点处于主从关系的从节点之一升级到新的主节点，并将其他从节点指向新的主节点</strong></li></ul> </li></ul> </li></ul> </li><li>哨兵自动选举机制 
    <ul><li>没有哨兵的情况下，主从模式需要人为干预才能够正常的进行选举，并且后续的ip更换操作也很繁琐</li><li>哨兵每秒会给所有节点发送心跳检测，如果心跳检测超时则认定为死忙</li><li>为了避免在网络阻塞或者机器负载高的情况下影响单个哨兵的能力，通常会搭建哨兵集群，三个哨兵节点</li><li>当一个哨兵判断主节点下线后会通知其他哨兵根据自己掌握的节点状况进行投票和选举</li><li>其投票通过数和mongodb一样，(N/2)+1，比如三个哨兵，那么阈值为2</li><li>投票通过后又由谁来进行主从的切换？</li><li>哨兵内部还会再进行主哨兵选举，先发现主节点故障的哨兵拥有优先投票权，每一个哨兵只能投票一次</li><li>哨兵集群数和数据库集群数类似，都是奇数，为了防止脑裂</li></ul> </li></ul> </li><li> <p>redisAOF问题，<a href="https://blog.csdn.net/weixin_38860565/article/details/105590865">更详细的请查看这篇文章</a><br> AOF重写导致的redis子进程崩溃，服务重启。解决方案是先优化代码中的大key，延迟重写时机，保证服务可用，比如超过上一重写文件的多少倍后再重写。待redis写入量没那么高时，再调整会重写策略，提前重写即可。主要是大key占用了不必要的空间。</p> </li><li> <p>分布式锁的使用和问题，解决方案</p> 
  <ul><li>应用场景 
    <ul><li>多个定时器任务扫描，如何避免同一个任务重复处理</li></ul> </li><li>setnx 
    <ul><li>存在返回0</li><li>不存在返回1</li></ul> </li><li>setex 
    <ul><li>解决定时器问题，设置锁的同时设置过期时间</li></ul> </li></ul> </li><li> <p>什么是缓存重建</p> 
  <ul><li>热点key大量失效 
    <ul><li>key不过期</li><li>或者惰性创建，访问的时候，先检查，有则读取，没有则创建</li></ul> </li></ul> </li><li> <p>redis是单线程还是多线程，6.0以后多线程解决了什么问题</p> 
  <ul><li>单线程，减去了多线程的上下文切换和锁的问题</li><li>多路复用，类似nodejs事件循环，所有的读写都放入事件循环中，内部用多线程来执行</li><li>多线程还是为了解决io性能，引入多线程，每一个线程维护一个事件队列</li></ul> </li><li> <p>redis事务</p> 
  <ul><li> <p>MULTI，EXEC，DISCARD，WATCH 四个命令是 Redis 事务的四个基础命令。其中：</p> <p>MULTI，告诉 Redis 服务器开启一个事务。注意，只是开启，而不是执行 。<br> EXEC，告诉 Redis 开始执行事务 。<br> DISCARD，告诉 Redis 取消事务。<br> WATCH，监视某一个键值对，它的作用是在事务执行之前如果监视的键值被修改，事务会被取消。</p> </li><li> <p>应用场景</p> 
    <ul><li>数据一致性</li></ul> </li></ul> </li><li> <p>redis发布订阅</p> 
  <ul><li>和node事件机制一样，通过on监听，发送等</li></ul> </li><li> <p>cpu高</p> 
  <ul><li>有一天上午十点多redis告警cpu占用率高，于是就排查最近代码，发现有人用了keys*来查询所有 
    <ul><li>当时立马改代码升级优化了一些</li><li>后面还发现有一些大key，存储了一个账户的所有座席配置，频繁获取也会导致redis cpu飙升</li></ul> </li></ul> </li><li> <p>内存高</p> 
  <ul><li>有一次线上的redis机器内存告警 
    <ul><li>我们先查看目前存在的大key(数据量比较大的key) 
      <ul><li>bigkeys命令可以查看，但只能看到String、hash、list、set、zset这五种类型 
        <ul><li>优点是可以在线扫描，不阻塞服务；缺点是信息较少，内容不够精确。</li></ul> </li><li>使用<strong>redis-rdb-tools</strong>工具，它实例上执行bgsave，bgsave会触发redis的快照备份，导出csv形式的文件，然后就可以进行分析了</li></ul> </li><li>解决方案 
      <ul><li>当时这个大key hset占用了5m的空间，寸的时候是全量存进去。但实际使用只用了几个字段。所以当时就立刻更改代码，对这种key进行拆分，只存必要的字段。就解决了这个问题</li></ul> </li></ul> </li></ul> </li><li> <p>性能优化</p> 
  <ul><li>key的命名尽量简短，节省空间，提升搜索性能</li><li>不要使用keys *，keys *, 这个命令是阻塞的，即操作执行期间，其它任何命令在你的实例中都无法执行。当redis中key数据量小时到无所谓，数据量大就很糟糕了。可以去使用SCAN进行滚动分页查询解决。</li><li>合理的设置key的有效期一些不应该长期存储的key，比如验证码，临时的token，session等都应该设置有效期，避免长期占用孔间</li><li>合理的关闭AOF持久化存储，对于某些不需要进行持久化存储的业务可以关闭AOF，因为每次AOF重写都需要占用额外的cpu和内存</li><li>避免使用大key，比如一个key的值上m甚至几十m时，严重影响查询性能并且占用空间</li><li>集群扩展</li><li>冷热数据分离</li></ul> </li><li> <p>慢查询分析</p> 
  <ul><li>redis慢查询分析支持两个参数配置 
    <ul><li>slowlog-log-slower-than 预设阈值，单位微妙(默认10000)。超过预设阈值的才会被记录到慢查询日志中</li><li>slowlog-max-len 慢查询日志的列表长度(能记录的慢日志条数)。一个新的命令满足慢查询条件时被插入到这个列表中， 当慢查询日志列表已处于其最大长度时， 最早插入的一个命令将从列表中移出</li></ul> </li><li>slowlog-log-slower-than 的默认值是 10000 微秒，也就是 10 毫秒。</li><li>slowlog-max-len 的默认值是 128，也就是说慢查询命令队列可以保存 128 条慢查询记录</li><li>config set slowlog-log-slower-than 100 设置慢查询阈值为100毫秒</li><li>config set slowlog-max-len 200 设置慢查询日志保存行数为200</li><li>slowlog get 1 获取最近一条慢查询，如果不带数字则进行滚动获取<pre><code class="prism language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> slowlog get <span class="token number">1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">7</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1610156232</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">24</span>
   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"slowlog"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"get"</span>
   <span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">"127.0.0.1:58406"</span>
   <span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">""</span>
</code></pre> 
    <ol><li> <p>记录的慢查询标号，倒序显示</p> </li><li> <p>记录该命令的时间戳</p> </li><li> <p>执行命令的耗时，微秒为单位</p> </li><li> <p>执行的具体命令</p> </li><li> <p>执行该命令客户端的 IP 地址和端口号</p> </li></ol> </li><li>在找到对应的慢查询命令和请求来源后，我们就可以通过服务的请求日志和服务代码找到对应的接口/代码来进行排查了</li></ul> </li></ul> 
<h4><a id="_2208"></a>架构</h4> 
<p>微服务的优缺点</p> 
<ul><li>优势 
  <ul><li>每一个应用都是独立的服务 
    <ul><li>相比较单点服务，服务的升级和迭代不影响其他服务</li></ul> </li><li>服务性能提升 
    <ul><li>服务拆分后，体积变小，也没有其他服务的代码影响，整体性能提升</li></ul> </li><li>更适合快速迭代 
    <ul><li>相比较单点服务，每次发布都是一个整体，编译，打包时间长。微服务编译和打包时间短</li></ul> </li><li>单一职责 
    <ul><li>随着服务和团队的扩大，单体服务已经不能满足多个团队间的协作，因为一个团队的代码变动可能影响其他团队。所以拆分后，每个团队变更自己的服务，不影响其他人的</li></ul> </li></ul> </li><li>劣势 
  <ul><li>分布式部署后，调用关系变得复杂了，之前都是单点，服务内部就通信即可。现在多个服务都是http和消息中间件调用，维护成本变高</li><li>测试难度提升，一个服务的接口变动会影响其他调用方</li><li>运维难度提升，之前只需要升级，监控单点服务。现在多个服务，每一个服务的升级，监控都是更高的成本问题</li></ul> </li></ul> 
<p>什么是restful风格</p> 
<ul><li> <p>简称rest，它是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件，它主要用于<strong>客户端和服务端</strong>交互类的软件。基于这个风格设计的软件可以更简介，更有层次</p> </li><li> <p>特性</p> 
  <ul><li>资源 
    <ul><li>可以用一个URI（统一资源定位符）指向它，每种资源对应一个特性的URI。要获取这个资源，访问它的URI就可以，因此URI即为每一个资源的独一无二的识别符</li></ul> </li><li>表现层 
    <ul><li>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式。</li></ul> </li><li>状态转换 
    <ul><li>四个表示操作方式的动词：<strong>GET、POST、PUT、DELETE</strong>。他们分别对应四种基本操作：GET用来获取资源，POST用来新建资源，PUT用来更新资源，DELETE用来删除资源</li></ul> </li></ul> </li><li> <p>如何设计</p> 
  <ul><li> <p><strong>路径设计</strong>：数据库设计完毕之后，基本上就可以确定有哪些资源要进行操作，相对应的路径也可以设计出来。</p> <p><strong>动词设计</strong>：也就是针对资源的具体操作类型，有HTTP动词表示，常用的HTTP动词如下：POST、DELETE、PUT、GET</p> </li></ul> </li></ul> 
<p>常用的设计模式，应用场景，解决了什么问题</p> 
<ul><li>单例 业务隔离 
  <ul><li>单例模式可以保证内存里只有一个实例，减少了内存的开销</li><li>可以避免对资源的多重占用</li><li>更专注，只做一件事</li></ul> </li><li>适配器模式 继承 
  <ul><li>提高代码重用性</li><li>提高代码的扩展性</li></ul> </li><li>开放封闭 
  <ul><li>当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定</li></ul> </li><li>策略模式 
  <ul><li>避免多重判断</li><li>扩展性高</li></ul> </li><li>工厂模式 
  <ul><li>主要用来初始化对象，规范对象初始化过程，节省对象的初始化成本</li></ul> </li></ul> 
<p>什么是DDD设计模式，应用场景，解决了什么问题</p> 
<ul><li>概念 
  <ul><li>领域驱动设计模式，把业务拆分成细粒度的领域，解决因为项目庞大而导致的耦合性问题</li><li>application 应用层 属于业务的上层，用来编排业务层</li><li>domain 领域层 实现具体业务处理，service逻辑层</li><li>interface 接口层，接收接口调用</li><li>repository 数据库仓储，处理数据库操作</li><li>infrastructure 基础设施层，处理常量，通用方法等 
    <ul><li>只做增删改查 不做任何其他业务</li></ul> </li><li>引入VO，DTO，DO，PO概念 
    <ul><li>VO 
      <ul><li>视图对象，主要对应界面显示的数据对象。对于一个 WEB 页面，或者 SWT、SWING 的一个界面，用一个 VO 对象对应整个界面的值</li></ul> </li><li>DTO 
      <ul><li>数据传输对象，接收前端传递来的对象值以及接收时的校验等</li></ul> </li><li>DO 
      <ul><li>领域对象，就是从现实世界中抽象出来的有形或无形的业务实体</li></ul> </li><li>PO 
      <ul><li>持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，也就是数据库实例化对象</li></ul> </li></ul> </li></ul> </li><li>应用场景 
  <ul><li>项目逻辑性复杂，规模较大项目适合用DDD模式</li></ul> </li><li>解决了以下问题 
  <ul><li>传统的MVC模式的业务层全部由service承担，这就导致service层代码臃肿且越来越难维护，模块间的关系难以梳理，模块间的耦合度过高，比如一个service方法可能包含，参数校验，参数解析，业务处理，异步事件，消息队列，数据库操作等。有个ddd，那么一个service层就被拆分为基础设施层，应用层，领域层，仓储层</li><li>在划分领域的基础上，又对实体对象进行了划分，分为VO，DTO，DO，PO。业务对象的细分一方面使得业务更加便于理解和区分，也让业务间的实例化对象隔离，避免污染而造成后续的维护等问题</li></ul> </li></ul> 
<p>Kakfa</p> 
<ul><li> <p>概念</p> 
  <ul><li>业务解耦 
    <ul><li>传统的http业务，每一个接收方的变动都可能导致推送方的代码有所变动，久而久之，非常不利于维护。有了消息队列，那么推送放只负责推送消息，对于接收方如何处理，它不需要关心，从而达到了解耦。</li></ul> </li><li>削峰 
    <ul><li>传统模式，并发量大的会导致业务异常，比如数据库负载过高。而消息队列会根据对方的消费能力来处理，可能会有短暂的挤压，但不会导致数据库负载过高</li></ul> </li><li>可靠性传输 
    <ul><li>传统http如果没有重试机制，会导致请求丢失。kafka会保证被消费者接收</li></ul> </li></ul> </li><li> <p>组成</p> 
  <ul><li>生产者 消息发送方</li><li>实例 kafka服务器， Kafka服务器，负责消息存储和转发</li><li>topic 消息类别，Kafka按照topic来分类消息</li><li>分区 用于提高kakfa吞吐量</li><li>副本 每个分区有多个副本 默认10个，不能大于broker的数量，用于做主备切换</li><li>消费者 接受消息</li><li>消费者组 多个消费者在一个消费组，一个分区的数据只能被一个组内的一个消费者消费。同一个消费者可以处理同一个主题下不同分区的数据</li><li>zookeeper 保证kafka集群的通信，配置和可用性</li></ul> </li><li> <p>当前使用的是2.8.0版本</p> </li><li> <p>消费者获取消息的机制</p> 
  <ul><li>通过拉取的方式</li><li>pull模式消费者自主决定是否批量从broker拉取数据，而push模式在无法知道消费者消费能力情况下，不易控制推送速度，太快可能造成消费者奔溃，太慢又可能造成浪费</li><li>生产者会发送给订阅这个主题的分区，如果指定分区，则发给指定分区。如果没有指定，则轮询发送。</li></ul> </li><li> <p>kafka为什么用zookeeper</p> 
  <ul><li>主要用于在集群中不同节点之间进行通信，在 Kafka 中，它被用于提交偏移量，因此如果节点在任何情况下都失败了，它都可以从之前提交的偏移量中获取，除此之外，它还执行其他活动，如: leader 检测、分布式同步、配置管理、识别新节点何时离开或连接、集群、节点实时状态等等</li></ul> </li><li> <p>消息同步机制</p> 
  <ul><li>ack=0 不关注消费者是否收到消息</li><li>ack=1 只要leader节点收到通知 就算成功(kafka默认选项)</li><li>ack=-1 所有复制节点收到通知才算成功</li></ul> </li><li> <p>什么是分区</p> 
  <ul><li>如果你创建的<code>topic</code>有5个分区，当你一次性向 kafka 中推 1000 条数据时，这 1000 条数据默认会分配到 5 个分区中，其中每个分区存储 200 条数据</li><li>这样做的目的，就是方便消费者从不同的分区拉取数据，假如你启动 5 个线程同时拉取数据，每个线程拉取一个分区，消费速度会非常非常快！</li><li>发送消息时先发给主分区，主分区同步给子分区 
    <ul><li>分配机制 
      <ul><li>1、数据在写入的时候可以指定需要写入的分区，如果有指定，则写入对应的分区</li><li>2、如果没有指定分区，但是设置了数据的key，则会根据key的值hash出一个分区</li><li>3、如果既没指定分区，又没有设置key，则会轮询选出一个分区</li></ul> </li></ul> </li><li>消费者从主分区中拉取消息</li></ul> </li><li> <p>kafka消息顺序</p> 
  <ul><li>同一个分区内的消息是有序的</li><li>多个分区是无序的</li></ul> </li><li> <p>消费者分区分配策略</p> 
  <ul><li><strong>RangeAssignor</strong> 范围分配 
    <ul><li>kafka默认的分配策略，假如现在有 10 个分区，3 个消费者，排序后的分区将会是0,1,2,3,4,5,6,7,8,9；消费者排序完之后将会是C1-0,C2-0,C3-0。那么第一个消费者就多消费一个分区</li><li>默认按照编号排序分配</li></ul> </li></ul> </li><li> <p>kafka如何跟踪消费状态</p> 
  <ul><li>通过offset偏移量来标记消费的位置</li></ul> </li><li> <p>分区策略</p> 
  <ul><li>轮询 一次将消息发给该topic下所有分区</li><li>指定分区</li></ul> </li><li> <p>kafka为什么性能强</p> 
  <ul><li>利用分区提高集群负载 
    <ul><li>多个分区</li></ul> </li><li>数据缓存 
    <ul><li>如果在 Cache 中存在该数据且是最新的，则直接将数据传递给用户程序，免除了对底层磁盘的操作，提高了性能</li></ul> </li><li>批处理 
    <ul><li>控制分批发送</li></ul> </li></ul> </li><li> <p>应用场景</p> 
  <ul><li>日志收集</li><li>对接多方，需要业务解耦 
    <ul><li>用户登录退出事件</li><li>企业账单</li><li>通话事件</li><li>报表事件</li></ul> </li></ul> </li><li> <p>常见面试题</p> 
  <ul><li>kafka中的broker 是干什么的 
    <ul><li>broker 是消息的代理，Producers往Brokers里面的指定Topic中写消息，Consumers从Brokers里面拉取指定Topic的消息，然后进行业务处理，broker在中间起到一个代理保存消息的中转站。</li></ul> </li><li>kafka中的 zookeeper 起到什么作用，可以不用zookeeper么 
    <ul><li>zookeeper 是一个分布式的协调组件，早期版本的kafka用zk做meta信息存储，consumer的消费状态，group的管理以及 offset的值。考虑到zk本身的一些因素以及整个架构较大概率存在单点问题，新版本中逐渐弱化了zookeeper的作用。新的consumer使用了kafka内部的group coordination协议，也减少了对zookeeper的依赖，<br> 但是broker依然依赖于ZK，zookeeper 在kafka中还用来选举controller 和 检测broker是否存活等等。</li></ul> </li><li>Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么 
    <ul><li>ISR:In-Sync Replicas 副本同步队列。AR:Assigned Replicas 所有副本</li></ul> </li><li>kafka中consumer group 是什么概念 
    <ul><li>同样是逻辑上的概念，是Kafka实现单播和广播两种消息模型的手段。同一个topic的数据，会广播给不同的group；同一个group中的worker，只有一个worker能拿到这个数据。换句话说，对于同一个topic，每个group都可以拿到同样的所有数据，但是数据进入group后只能被其中的一个worker消费。group内的worker可以使用多线程或多进程来实现，也可以将进程分散在多台机器上，worker的数量通常不超过partition的数量，且二者最好保持整数倍关系，因为Kafka在设计时假定了一个partition只能被一个worker消费（同一group内）</li></ul> </li><li>kafka的消费者是pull(拉)还是push(推)模式，这种模式有什么好处 
    <ul><li>kafka遵循了一种大部分消息系统共同的传统的设计：producer 将消息推送到 broker，consumer 从broker 拉取消息 
      <ul><li>优点：pull模式消费者自主决定是否批量从broker拉取数据，而push模式在无法知道消费者消费能力情况下，不易控制推送速度，太快可能造成消费者奔溃，太慢又可能造成浪费</li><li>缺点：如果 broker 没有可供消费的消息，将导致 consumer 不断在循环中轮询，直到新消息到到达。为了避免这点，Kafka 有个参数可以让 consumer阻塞知道新消息到达(当然也可以阻塞知道消息的数量达到某个特定的量这样就可以批量发送)</li></ul> </li></ul> </li><li>kafka 如何不消费重复数据？比如扣款，我们不能重复的扣 
    <ul><li>这个问题换种问法，就是kafka如何保证消息的幂等性。对于消息队列来说，出现重复消息的概率还是挺大的，不能完全依赖消息队列，而是应该在业务层进行数据的一致性幂等校验</li><li>比如你处理的数据要写库（mysql，redis等），你先根据主键查一下，如果这数据都有了，你就别插入了，进行一些消息登记或者update等其他操作。另外，数据库层面也可以设置唯一健，确保数据不要重复插入等 。一般这里要求生产者在发送消息的时候，携带全局的唯一id</li></ul> </li><li>kafka Stream 
    <ul><li>Kafka Streams是一个客户端程序库，用于处理和分析存储在Kafka中的数据，并将得到的数据写回Kafka或发送到外部系统。可以说是消息转换器，在消息发送之前进行转换后再重新发送。可以针对部分业务场景做数据化定制，或者在不改变生产者业务的前提下来转换消息体</li></ul> </li></ul> </li><li> <p>集群</p> 
  <ul><li>kafka最小可用集群是三个节点，也就是三个broker，和传统集群类似，一个主节点，两个从节点</li></ul> </li><li> <p>消息队列常见问题</p> 
  <ul><li>消息堆积 
    <ul><li>某天运维监控系统告警，kafka的消息堆积超过阈值200，于是进入系统查看发现某topic下的消息堆积已经达到了220</li><li>于是查看代码中接收该topic消息的代码，先是排查了对第三方接口同步调用的日志，均在200毫秒内返回，又查看企业内部调用，发现有一个数据同步接口延迟最高可达30s</li><li>联系到该部分的同事，经过排查发现是因为该接口代码近期有更新，增加了部分查询数据和逻辑复杂的运算，导致上层应用消费能力下降，从而导致上层的消息堆积</li><li>临时的解决方案是当天该部门回滚代码，保证服务可用</li><li>最终解决方案是，该接口只负责接收和存储事件。具体的业务处理交给内部服务来进行定时的处理 
      <ul><li>上层应用也将部分第三方，其他部门的接口调用改为了异步或超时处理</li></ul> </li></ul> </li><li>消息重复 
    <ul><li>同样是上面的问题，同步的延迟导致触发了kafka的重试，数据库中被插入了重复数据，同时重复的调用了其他服务的接口，也导致了其他服务存储了重复的数据</li><li>后续我们将部分对幂等性要求高的业务统一做了数据校验重复方案，就解决了此问题</li></ul> </li></ul> </li></ul> 
<p>Apollo</p> 
<ul><li>什么是apollo 
  <ul><li>一款可靠的<a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&amp;spm=1001.2101.3001.7020">分布式</a>配置管理中心，诞生于携程框架研发部，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景</li></ul> </li><li>特点，应用场景 
  <ul><li>统一管理不同环境，不同集群的配置</li><li>配置实时更新</li><li>版本发布</li><li>灰度发布</li><li>权限管理</li></ul> </li><li>组成 
  <ul><li>application 应用</li><li>environment 环境</li><li>cluster 集群</li><li>namespace 命名空间</li></ul> </li><li>组件 
  <ul><li>config service</li><li>admin service</li><li>protal</li></ul> </li></ul> 
<p>私有包使用nexus作为仓储</p> 
<p>Docker</p> 
<ul><li>什么是docker 
  <ul><li>使用go编写，开源的容器引擎。docker可以让开发者打包他们的应用和依赖到一个轻量的容器中，然后可以发布到任意的linux平台。</li></ul> </li><li>dockerfile 
  <ul><li>用来构建docker镜像的文本文件，包含了构建镜像的指令和说明等</li></ul> </li><li>应用场景和优缺点 
  <ul><li>比起传统sh脚本，docker镜像更适合自动编译，打包和发布</li><li>自动化集成，cicd</li><li>维护成本低，容错率高</li><li>隔离运行环境</li></ul> </li><li>常用命令 
  <ul><li>docker info 查看docker版本信息</li><li>docker images 查看镜像列表</li><li>docker search 镜像名称 搜索镜像</li><li>docker run 镜像名称 运行镜像</li><li>docker ps -a 查看容器列表</li><li>docker image rm 镜像名 删除某一个镜像</li></ul> </li><li>你们公司都是如何使用docker的 
  <ul><li>公司内部使用k8s来管理和编排docker。</li><li>在ci阶段，使用dockerfiler完成编译，打包。然后将镜像推送到harbor仓储。到cd阶段，上k8s环境更改镜像id，触发k8s的更新后，自动滚动发布。</li></ul> </li></ul> 
<p>K8s</p> 
<ul><li> <p>什么是k8s，和docker区别</p> 
  <ul><li>概念 
    <ul><li>一个容器编排工具，可以滚动升级，对运行的容器状态进行监控，还有健康检查等</li></ul> </li><li>docker是一个容器部署工具，运行环境隔离，有自己的文件系统等 
    <ul><li>优点 
      <ul><li>运行管理隔离，相互不影响</li><li>有利于分布式，因为容器轻量，每一个应用都可以当作一个容器</li></ul> </li><li>缺点 
      <ul><li>随着容器的增加,容器的管理是个大问题</li><li>服务升级如何保证不中断</li><li>服务运行状态的监控</li><li>容器的监控</li></ul> </li></ul> </li></ul> </li><li> <p>特点，应用场景和优缺点</p> 
  <ul><li>中大型应用使用k8s比较合适，因为随着应用体积变大，运维监控成本会变高</li></ul> </li><li> <p>k8s的组成</p> 
  <ul><li>apiserver 
    <ul><li>Kubernetes API 服务器验证并配置 API 对象的数据， 这些对象包括 pods、services、replication、controllers 等。 API 服务器为 REST 操作提供服务，并为集群的共享状态提供前端， 所有其他组件都通过该前端进行交互</li></ul> </li><li>etcd 
    <ul><li>etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。</li></ul> </li><li>proxy 
    <ul><li>工作节点上的一个网络代理组件，运行在每个节点上<br> 它维护节点上的网络规则，实现了Kubernetes Service 概念的一部分 。它的作用是使发往 Service 的流量（通过ClusterIP和端口）负载均衡到正确的后端Pod</li></ul> </li><li>kubelet 
    <ul><li>Kubelet组件运行在Node节点上，维持运行中的Pods以及提供kuberntes运行时环境，主要完成以下使命：<br> １．监视分配给该Node节点的pods<br> ２．挂载pod所需要的volumes<br> ３．下载pod的secret<br> ４．通过docker/rkt来运行pod中的容器<br> ５．周期的执行pod中为容器定义的liveness探针<br> ６．上报pod的状态给系统的其他组件<br> ７．上报Node的状态</li></ul> </li></ul> </li><li> <p>k8s核心概念</p> 
  <ul><li>pod 
    <ul><li>k8s内的一个容器单元，相当于一个拥有命名空间和存储卷的docker容器</li></ul> </li><li>deployment 
    <ul><li>用来管理pod，控制pod的增删改</li></ul> </li><li>service 
    <ul><li>实现pod的网络通信。因为pod每次变更都会发生ip变动，所以就需要一个入口来屏蔽ip的变动，实现通过service访问内部pod</li><li>service和pod没有直接关系，pod通过<strong>endpoints</strong>暴漏出来，只要pod变更就会同步到<strong>endpoints</strong>中。service通过endpoints的映射关系来访问pod</li></ul> </li></ul> </li><li> <p>k8s的健康检查机制都有哪些</p> 
  <ul><li>存活探测器 
    <ul><li>用来探测什么时候重启定时器</li></ul> </li><li>就绪探测器 
    <ul><li>用来探测什么时候可以接受请求流量</li></ul> </li><li>启动探测器 
    <ul><li>用来探测应用程序何时启动</li></ul> </li></ul> </li><li> <p>如何实现集群管理</p> 
  <ul><li>开发人员通过rancher可视化平台，实现对pod的生命周期管理</li></ul> </li><li> <p>K8S基础</p> 
  <ul><li>K8S的概念</li><li>是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制</li><li>k8s解决了什么问题</li><li>解决以下问题 
    <ul><li>随着容器的增加,容器的协调和调度步骤主键繁琐</li><li>服务升级如何保证不中断 
      <ul><li>服务运行状态的监控</li></ul> </li><li>容器的监控</li></ul> </li></ul> </li><li> <p>K8S中POD的概念</p> 
  <ul><li>k8s内的一个容器单元，相当于一个拥有命名空间和存储卷的docker容器</li></ul> </li><li> <p>K8S的命名空间</p> 
  <ul><li>命名空间 namespace 是 k8s 集群级别的资源，可以给不同的用户、租户、环境或项目创建对应的命名空间，例如，可以为 test、devlopment、production 环境分别创建各自的命名空间 
    <ul><li>命名空间适用于存在很多跨多个团队或项目的用户的场景</li></ul> </li></ul> </li><li> <p>Deployment无状态应用的部署</p> 
  <ul><li>编写一个yml文件，按照k8s的格式定以命名空间，pod标签，端口号，镜像id等</li></ul> </li><li> <p>Service的类型</p> 
  <ul><li>clusterip 
    <ul><li>通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。 这也是默认的 ServiceType</li></ul> </li><li>NodePort 
    <ul><li>通过每个节点上的 IP 和静态端口（NodePort）暴露服务。 NodePort 服务会路由到自动创建的 ClusterIP 服务。 通过请求 &lt;节点 IP&gt;:&lt;节点端口&gt;，你可以从集群的外部访问一个 NodePort 服务。</li></ul> </li><li>LoadBalancer 
    <ul><li>使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 NodePort 服务和 ClusterIP 服务上</li></ul> </li></ul> </li><li> <p>Service和pod的关系</p> 
  <ul><li>service和pod并没有直接的关系。pod通过endpoints暴露出来，只要pod发生变更，便会同步至endpoints中。有了service和endpoints后，kube-proxy会实时监听它们的更新和删除操作，然后更新iptables代理规则，重新生成该service访问pod的ip和端口映射规则</li></ul> </li><li> <p>labels标签</p> 
  <ul><li><strong>当相同类型的资源越来越多，对资源划分管理是很有必要，此时就可以使用label为资源对象 命名，以便于配置，部署等管理工作，提升资源的管理效率</strong></li></ul> </li><li> <p>labels selector 标签选择器</p> 
  <ul><li>Label selector(标签选择器)是Kubernetes核心的分组机制，通过label selector客户端/用户能够识别一组有共同特征或属性的资源对象 
    <ul><li>通过资源对象上定义的Label Selector来筛选要监控的Pod副本的数量，从而实现Pod副本的数量始终符合预期设定的全自动控制流程</li><li>kupe-proxy进程通过Service的Label Selector来选择对应的Pod，自动建立器每个Service到对应Pod的请求转发路由表，从而实现Service的智能负载均衡机制 
      <ul><li>通过对某些Node定义特定的Label,并且在Pod定义文件中使用NodeSelector这种标签调度策略，Kube-scheduler进程可以实现Pod定向调度的特性</li></ul> </li></ul> </li></ul> </li><li> <p>Ingress七层负载均衡</p> 
  <ul><li>ingress其实类似nginx，通过k8s监听ingress资源的变化，重新生成nginx.conf文件，然后生效 
    <ul><li>和tcp七层协议一样，只不过最后通过service完成负载均衡</li></ul> </li></ul> </li><li> <p>K8S深入</p> 
  <ul><li> <p>K8S的资源配额、限制</p> 
    <ul><li>通常nodejs的pod限制在2c4g，但可以通过配置yml文件来达到以下目的 
      <ul><li>达到1.8c的时候扩容一个pod</li><li>达到3.5g的时候库容一个pod</li></ul> </li></ul> </li><li> <p>K8S的环境变量</p> 
    <ul><li>在yml配置文件中的env下定义即可</li></ul> </li><li> <p>K8S配置管理（ConfigMap、Secret等）</p> 
    <ul><li>configmap是k8s的一个配置管理组件，可以将配置以key-value的形式传递，通常用来保存不需要<a href="https://so.csdn.net/so/search?q=%E5%8A%A0%E5%AF%86&amp;spm=1001.2101.3001.7020">加密</a>的配置信息，加密信息则需用到Secret，主要用来应对以下场景： 
      <ul><li>使用k8s部署应用，当你将应用配置写进代码中，就会存在一个问题，更新配置时也需要打包镜像，configmap可以将配置信息和docker镜像解耦。</li><li>使用微服务架构的话，存在多个服务共用配置的情况，如果每个服务中单独一份配置的话，那么更新配置就很麻烦，使用configmap可以友好的进行配置共享。<br> 其次，configmap可以用来保存单个属性，也可以用来保存配置文件</li></ul> </li></ul> </li><li> <p>K8S的滚动更新</p> 
    <ul><li>所谓滚动升级，就是在升级过程中，并不一下子启动所有新版本，是先启动一台新版本，再停止一台老版本，然后再启动一台新版本，再停止一台老版本，直到升级完成</li></ul> </li><li> <p>K8S的健康检查</p> 
    <ul><li> <p>存活探测器</p> 
      <ul><li>用来探测什么时候重启定时器</li></ul> </li><li> <p>就绪探测器</p> 
      <ul><li>用来探测什么时候可以接受请求流量</li></ul> </li><li> <p>启动探测器</p> 
      <ul><li>用来探测应用程序何时启动</li></ul> </li><li> <p>K8S的存储管理（PV、PVC等）<br> <a href="https://blog.csdn.net/qq_42427109/article/details/123772657?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165648854616781818756176%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165648854616781818756176&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-15-123772657-null-null.nonecase&amp;utm_term=k8s&amp;spm=1018.2226.3001.4450">kubernetes 入门实践-存储 volume-nfs-pv-pvc<br> </a></p> </li><li> <p>K8S的有状态服务StatefulSet<br> <a href="https://blog.csdn.net/qq_42427109/article/details/122909622?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165648854616781818756176%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165648854616781818756176&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-7-122909622-null-null.nonecase&amp;utm_term=k8s&amp;spm=1018.2226.3001.4450">kubernetes 入门实践-有状态的服务 StateFulSet<br> </a></p> </li><li> <p>K8S的Job、CronJob<br> 批任务处理，其中CronJon可以处理定时任务</p> </li><li> <p>使用流水线部署K8S应用<br> <a href="https://blog.csdn.net/qq_42427109/article/details/120691001?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165648890516781432928155%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165648890516781432928155&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-120691001-null-null.nonecase&amp;utm_term=ci&amp;spm=1018.2226.3001.4450">GitHub Actions CI/CD<br> </a></p> </li></ul> </li><li> <p>K8S进阶</p> 
    <ul><li> <p>K8S集群搭建<br> <a href="https://blog.csdn.net/qq_42427109/article/details/121891058?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165648854616781818756176%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165648854616781818756176&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-13-121891058-null-null.nonecase&amp;utm_term=k8s&amp;spm=1018.2226.3001.4450">kubernetes 入门实践-搭建集群</a></p> </li><li> <p>K8S负载均衡<br> <a href="https://blog.csdn.net/qq_42427109/article/details/122288688?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165648854616781818756176%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165648854616781818756176&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-5-122288688-null-null.nonecase&amp;utm_term=k8s&amp;spm=1018.2226.3001.4450">kubernetes 入门实践-Ingress</a><br> 其中ingress负责访问service的策略，而ingress-controller负责负载均衡策略</p> </li><li> <p>K8S的调度策略（亲和、反亲和等）<br> Pod亲和性指的是满足特定条件的的Pod对象运行在同一个node上， 而反亲和性调度则要求它们不能运行于同一node</p> </li><li> <p>K8S的存储（本地存储、分布式存储等）<br> <a href="https://blog.csdn.net/qq_42427109/article/details/124085390?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165648854616781818756176%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165648854616781818756176&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-9-124085390-null-null.nonecase&amp;utm_term=k8s&amp;spm=1018.2226.3001.4450">kubernetes 入门实践-存储-hostpath</a><br> <a href="https://blog.csdn.net/qq_42427109/article/details/124085588?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165648854616781818756176%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165648854616781818756176&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-11-124085588-null-null.nonecase&amp;utm_term=k8s&amp;spm=1018.2226.3001.4450">kubernetes 入门实践-搭建nfs服务器</a></p> </li><li> <p>K8S中的负载均衡（ClusterIP、NodePort、L4、L7负载均衡）</p> </li><li> <p>K8S的弹性伸缩（HPA）</p> 
      <ul><li>HPA 
        <ul><li>根据资源利用率或者自定义指标自动调整replication controller, Deployment 或 ReplicaSet，实现部署的水平自动扩缩容，让部署的规模接近于实际服务的负载。可以使用rancher界面功能，终端命令或者hpa yml配置文件完成</li></ul> </li></ul> </li><li> <p>使用Helm Chart发布应用</p> 
      <ul><li>helm是kubernetes生态系统中的一个软件包管理工具，类似ubuntu的apt,centos的yum或python的pip一样，专门负责管理kubernetes应用资源；使用helm可以对kubernetes应用进行统一打包、分发、安装、升级以及回退等操作</li></ul> </li><li> <p>K8S的日志、监控、告警体系</p> </li><li> <p>Istio服务网格与流量治理</p> </li><li> <p>K8S技术演进路线（AKS、ASK、ACI、FaaS等）</p> </li></ul> </li></ul> </li></ul> 
<h4><a id="_2606"></a>项目</h4> 
<p>你们线上运行多少机器，都是什么配置，为什么这样配置</p> 
<ul><li>旧平台 我们部门总共20台，大多都是4c8g的机器，一共14个服务</li><li>新平台 ，一共接近30台服务器，但经过容器化管理后，单位其实是pod。我们pod基本配置都是2c4g的，每个服务两个pod，部分流量大的pod会扩展到3-4个，除了个别服务，因为要处理导入和导出，所以内存较高。新平台的服务，我们部门总共有25个</li></ul> 
<p>QPS达到多少</p> 
<ul><li>能打到1000-1200 200+ms</li></ul> 
<p>你们登录加密token怎么做的</p> 
<ul><li>直接用md5来做的</li><li>后台通过加盐来对比数据库密码</li></ul> 
<p>单点登录如何做的</p> 
<ul><li>用redis存储单点登录状态，第三方发起/loginToken登陆时，通过接口传递用户标记获取token，然后用token发起单点登录</li></ul> 
<p>说说对sass行业的理解</p> 
<ul><li>是一种通过网络提供集中式服务的软件。</li><li>不用购买，安装和维护任何软件硬件，只需要根据需要。每个月付钱即可。和"租"类似</li></ul> 
<p>什么是线程安全和不安全</p> 
<ul><li>安全 
  <ul><li>有锁机制，避免了多个线程争抢资源问题</li></ul> </li><li>不安全 
  <ul><li>没有锁，多个线程可能争抢资源，导致业务异常。比如多个定时器任务就需要用到锁。或者相同状态的业务处理，或者有顺序要求的业务处理等</li></ul> </li></ul> 
<p>什么是GRPC</p> 
<ul><li>先看一下rcp和http区别 
  <ul><li>RPC 主要用于公司内部的服务调用，性能消耗低，传输效率高，实现复杂。<br> HTTP 主要用于对外的异构环境，浏览器接口调用，App 接口调用，第三方接口调用等。</li></ul> </li><li>grpc是基于rpc的一个框架</li></ul> 
<h4><a id="ElasticSearch_2645"></a>ElasticSearch</h4> 
<ul><li>什么是Elasticsearch 
  <ul><li>基于lucence的搜索引擎，接口风格基于resultful，使用Java开发的</li><li>分片 
    <ul><li>概念 
      <ul><li>在ES中所有数据的文件块，也是<strong>数据的最小单元块</strong>，整个ES集群的核心就是对所有分片的分布、索引、负载、路由等达到惊人的速度</li></ul> </li><li>假设 IndexA 有2个分片，我们向 IndexA 中插入10条数据 (10个文档)，那么这10条数据会尽可能平均的分为5条存储在第一个分片，剩下的5条会存储在另一个分片中。</li><li>设置分片的关键字是number_of_shards</li><li>设置分片副本的关键字是number_of_replicas</li><li>设置分片的策略 
      <ul><li>建议：（仅参考）</li><li>1、每一个分片数据文件小于30GB</li><li>2、每一个索引中的一个分片对应一个节点</li><li>3、节点数大于等于分片数</li></ul> </li></ul> </li><li>副本 
    <ul><li>保障系统的高可用性，如果分片异常，副本分片会晋升为分片</li></ul> </li></ul> </li><li>特点 
  <ul><li>分布式文件存储 
    <ul><li>和mongodb分片优点类似，将多条数据分布在不同的分片上，提高查询性能</li><li>也有master和node节点</li></ul> </li><li>实时分析的分布式搜索引擎 
    <ul><li>基于倒排索引和lucence</li></ul> </li><li>高扩展性 
    <ul><li>扩展简单，只需要一台机器，根据配置文件指定集群节点加入即可</li></ul> </li></ul> </li><li>优缺点 
  <ul><li>优点 
    <ul><li>高可用性，分布式部署，支持快照备份和恢复 
      <ul><li>和传统的数据库集群一样，都是三个节点</li><li>类似mongodb的分片机制，把数据存储在不同的分片中，提高查询性能和负载承受能力</li></ul> </li><li>生态完善，部署简单，数据迁移简单等 
      <ul><li>根据文档即可部署</li><li>kibana日志分析</li><li>elasticsearch内置了数据迁移api</li></ul> </li><li>内置多种分词器，满足大部分业务场景 
      <ul><li>完全模糊搜索 ngram</li><li>中文分词 IK</li><li>还有很多其他的</li></ul> </li><li>搜索性能高 
      <ul><li>每个字段都有索引</li></ul> </li></ul> </li><li>缺点 
    <ul><li>增加维护成本，毕竟是一个额外的组件</li><li>不能随意更改索引结构，对于现有数据的结构，只能通过迁移数据到新索引结构上来解决</li></ul> </li></ul> </li><li>应用场景 
  <ul><li>模糊搜索，全文检索</li><li>日志分析，kibana内部集成了elasticsearch</li><li>运维监控</li></ul> </li><li>当前用的是2.x版本</li><li>索引比较大的 工单数据量是一千多万，占用空间三百多g</li><li>一千多万数据量用默认的stander分词器，占用一百多g。使用ngram后占用三百多g</li><li>业务中的应用场景 
  <ul><li>客户手机号和昵称模糊搜索</li><li>工单编号和工单备注模糊搜索</li><li>通话关联的客户昵称和手机号模糊搜索</li></ul> </li><li>正序和倒排索引区别 
  <ul><li>正序索引 
    <ul><li>概念 
      <ul><li>好比mongodb，搜索一个关键字，要扫描表中每一个文档进行匹配</li></ul> </li><li>好比在mongo中模糊搜索，包含这个关键字的文档 
      <ul><li>数据库就会用这个关键字逐个匹配表中的文档，如果有100个文档，就扫描100次</li><li>优点 
        <ul><li>直接正序插入，不用对关键词进行拆分，所以插入效率高</li></ul> </li><li>缺点 
        <ul><li>检索性能差</li></ul> </li></ul> </li></ul> </li><li>倒排索引 
    <ul><li>概念 
      <ul><li>和正序反过来，比如搜索苹果手机，那么倒排索引会拆分成苹，果，手，机这四个词，每一个词分别对应了包含该关键字的文档id</li></ul> </li><li>三要素 
      <ul><li>词条 
        <ul><li>检索的关键词，关键字key</li></ul> </li><li>词典 
        <ul><li>词条的集合，拆分后的词组</li></ul> </li><li>倒排表 
        <ul><li>记录词条出现的位置和频率，每一项是一个倒排项</li></ul> </li></ul> </li><li>优点 
      <ul><li>检索性能高</li></ul> </li><li>缺点 
      <ul><li>插入的效率低，因为要对关键字进行拆分，构建索引</li></ul> </li></ul> </li></ul> </li><li>当前使用的是什么版本 2.x版本</li><li>Elasticsearch基本概念 
  <ul><li>集群</li><li>节点</li><li>索引</li><li>文档</li><li>类型</li></ul> </li><li>Elasticsearch如何保证写一致 
  <ul><li>在操作写入的时候，es会进行以下步骤确保写一致性 
    <ul><li>检查活跃的副本数，这个参数默认为1，也可以自己指定。如果活跃的副本数小于设定的值，则写入失败</li><li>然后等待所有副本写入成功(中间会有一些重试措施)才返回，但并不是所有都写入才算成功</li><li>写入中，如果有一个副本异常，持续失败，那么副本会通知主节点，将异常的副本关系移除。被移除的副本不接受任何请求。</li></ul> </li></ul> </li><li>Elasticsearch写一致性策略 
  <ul><li>one：只要有1个primary shard是可用的，就可以进行写操作</li><li>all：必须所有的primary shard和replica shard都是可用的，才可以进行写操作</li><li>quorum：默认值。要求所有的shard中，必须大部分shard都是可用的，才可以进行写操作 
    <ul><li>int( (shard + number_of_replicas) / 2 ) + 1</li><li>举个例子，3个primary shard，number_of_replicas=1，总共有3 + 3 * 1 = 6个shard 
      <ul><li>quorum = int( (3 + 1) / 2 ) + 1 = 3</li><li>所以，要求6个shard中至少有3个shard是active状态的，才可以执行这个写操作</li></ul> </li></ul> </li></ul> </li><li>你们都用到了哪些分词器 
  <ul><li>stander</li><li>ngram</li></ul> </li><li>Elasticsearch基本语法 
  <ul><li>数据结构 
    <ul><li>index 索引</li><li>type 类型</li><li>id 字段id</li><li>routing 路由</li><li>body 数据体</li></ul> </li><li>查询 
    <ul><li>query 查询器</li><li>should 或条件，至少满足一项</li><li>filter 过滤器，条件</li><li>term 精准匹配</li><li>match 模糊匹配</li><li>Match_phrase 短语模糊匹配</li><li>size 查询多少个</li><li>_source 返回指定字段</li></ul> </li></ul> </li><li>Elasticsearch数据类型 
  <ul><li>text：被分析索引的字符串类型</li><li>keyword：不能被分析，只能被精确匹配的字符串类型</li><li>date：日期类型，可以配合format一起使用</li><li>long：长整型，数字类型</li><li>integer：整型，数字类型</li><li>short：短整型，数字类型</li><li>double：双精度浮点型，数字类型</li><li>Boolean：布尔型，true、false</li><li>array：数组类型</li><li>object：对象类型，json嵌套</li><li>ip：ip类型</li><li>geo_point：地理位置类型</li></ul> </li><li>Elasticsearch使用中遇到的问题 
  <ul><li>默认的stander不能满足业务场景模糊搜索的需求，然后使用ngram进行改造，设置最小和最小分次数，设置的是1_25。它会逐字分词，然后使用uniq对重复结果过滤，对于大文本的场景较少，所以再使用limit对结果数进行限制。</li><li>数据迁移失败，因为es默认会字符串进行转换，比如’1.0’会被转成1，字符串’2022’会被转换成日期格式，但字符串是一个自由的文本内容，按照es隐式转换标准会失败，所以就把这两个配置项给关闭了numeric_detection 数字转换，date_detection 日期转换</li></ul> </li><li>如何监控Elasticsearch状态 
  <ul><li>elasticsearch-head 开源地址在github</li></ul> </li><li>常见面试题 
  <ul><li>集群 
    <ul><li>一共13个es节点，接近30个索引，大部分以业务命名，个别的会以日期命名。</li><li>默认情况下，，Elasticsearch为每个索引创建五个主分片和一个副本。这意味着每个索引将包含五个主分片，每个分片将具有一个副本。</li></ul> </li><li>api 
    <ul><li><a href="https://blog.csdn.net/qq_42427109/article/details/123446547?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168432628616800213044645%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=168432628616800213044645&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-123446547-null-null.article_score_rank_blog&amp;utm_term=elasticsearch&amp;spm=1018.2226.3001.4450">elasticsearch常用API</a></li></ul> </li><li>性能优化 
    <ul><li>对于不需要模糊匹配的字段尽量使用keyword。keyword不进行分词，直接索引</li><li>尽量使用term查询</li><li>只存储业务需要字段，节省空间并提升性能</li><li>减少大文本存储，虽然es适合大文本检索，但过大的文本也会造成性能问题</li><li>使用索引滚动模式，避免一个索引数据过于庞大而造成的性能问题。可以采用按月或按年来进行日期滚动</li><li>减少搜索结果，避免每次查询上百上千的数量，过多的查询结果也会造成性能问题</li><li>冷却分离存储，分两种级别 
      <ul><li>业务级别，非热点或核心业务可以存储冷数据中，这样热数据索引空间变小，就能够提升热数据的性能</li><li>用户级别，将非活跃用户的数据存储到冷索引中，那么热索引的空间变小，自然查询性能就变高了</li></ul> </li></ul> </li></ul> </li></ul> 
<h4><a id="_2796"></a>综合</h4> 
<p>该篇是对标了几个大厂常问和一些偏八股文的问题</p> 
<p>TCP和UDP区别</p> 
<ul><li>UDP提供无连接服务</li><li>UDP不需要维护连接状态</li><li>UDP适用于效率高的应用</li><li>UDP不像TCP那样每一次发送都需要进行确认</li><li>UDP性能高，开销小</li><li>UDP连接不可靠</li></ul> 
<p>HTTP和HTTPS区别</p> 
<ul><li>HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；</li><li>HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；</li><li>使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；</li><li>HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。</li><li>HTTPS使用了非对称加密和对称加密：HTTPS是在HTTP的基础上增加了SSL层，服务器和客户端传输数据前先采用非对称加密算法生产一个秘钥，再用这个秘钥使用对称加密算法加密要传输的数据，这样做即保证了秘钥的安全，有提高了数据加密效率。</li></ul> 
<p>HTTP长连接和短链接区别</p> 
<ul><li>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，下次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</li><li>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</li><li>http1.1 默认支持长连接(keep-alive)，TCP连接之后不会马山断开，之后再加载静态资源，都会基于这个TCP连接。http1.1还保持了host头部，也支持虚拟主机。而且支持断点续传 
  <ul><li>长连接详解 
    <ul><li>第一次请求网页时会打开一个TCP连接，去加载css等静态资源，等这些请求加载完毕后才会释放连接。当一个请求对于的回包回来时，他却无法分辨是属于哪个请求的。所以回包只能按请求顺序返回，这就引来了另一个问题-线头阻塞。</li></ul> </li></ul> </li><li>http 2.0 多路复用。基于TCP连接并行发送多个请求和接受响应，解决http1.1请求串行的性能问题等</li></ul> 
<p>TCP长连接和HTTP长连接区别</p> 
<ul><li>TCP的是为了检测心跳，保持活跃的</li><li>HTTP的主要是在TCP的保活基础上重用连接，提高性能的</li></ul> 
<p>TCP如何保证可靠性传输</p> 
<ul><li>ARQ协议(超时重传协议) 
  <ul><li>ARQ 协议也就是<strong>超时重传机制</strong>。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含停止等待 ARQ 和连续 ARQ</li><li>正常传输过程<br> 只要 A 向 B 发送一段报文，都要<strong>停止发送</strong>并启动一个定时器，等待对端回应，在定时器时间内<strong>接收到对端应答就取消</strong>定时器并发送下一段报文</li></ul> </li></ul> 
<p>浏览器输入网址后都发生了什么</p> 
<ul><li>输入www.baiidu.com</li><li>将域名发送给DNS服务器</li><li>DNS服务器返回一个ip地址</li><li>然后客户端会把自己的ip和DNS返回的ip 分别换算成二进制，然后对比前三位数是否在一个子网</li><li>在一个子网则直接发送</li><li>不在一个子网，则将数据包发给交换机，通过以太网协议广播到路由器(网关)，路由器再继续进行寻址，直到找到对应的ip服务器</li><li>然后把http请求打包到数据包中构成请求报文</li><li>然后就到了传输层，经过TCP协议需要设置接收方的端口。然后把应用层的数据包封装到TCP数据包中，并加上一个TCP头部，该头部包含了接收方的端口号</li><li>然后就到了网络层，走ip协议，把tcp协议的头和数据包放入ip数据包中，再加一个ip头(包含了本机和接收方的ip地址)</li><li>然后就到了数据链路层，再把ip数据包放入以太网数据包中，头部存放了本机网卡的mac地址，网关的mac地址。但是以太网的数据包限制大小在1500个字节，如果超出则进行分割，分割后的数据包报头都包含了mac地址。然后再通过交换机，用以太网协议进行广播分发</li><li>直到找到最后的ip服务器。收到分割后的包根据ip头的序号再讲这分割后的包进行合并。然后从ip数据包中找到tcp数据包，再从tcp数据包中找到http数据包进行读取和处理。然后再把返回的数据封装成http响应报文并放在http数据包中，再放入tcp数据包，再放入ip数据包，最终封装成以太网数据包，通过网关寻址转发回去</li></ul> 
<p>HTTP1.0,1.1,2.0的区别</p> 
<ul><li>http1.0 需要指定kepp-alive来保持连接，默认短链接，每次请求都要重新建立一次TCP连接，处理完毕后就释放连接。但这样的话当网页内容较多时，比如css,js比较多，那么每次都要重新请求，就很浪费资源</li><li>http1.1 支持长连接(keep-alive)，TCP连接之后不会马山断开，之后再加载静态资源，都会基于这个TCP连接。http1.1还保持了host头部，也支持虚拟主机。而且支持断点续传 
  <ul><li>长连接详解 
    <ul><li>第一次请求网页时会打开一个TCP连接，去加载css等静态资源，等这些请求加载完毕后才会释放连接。当一个请求对于的回包回来时，他却无法分辨是属于哪个请求的。所以回包只能按请求顺序返回，这就引来了另一个问题-线头阻塞。</li></ul> </li></ul> </li><li>http 2.0 多路复用。基于TCP连接并行发送多个请求和接受响应，解决http1.1请求串行的性能问题等</li><li>其实长连接和短连接指的是TCP连接</li></ul> 
<p>HTTP三次握手和四次挥手过程</p> 
<ul><li>三次握手 
  <ul><li><strong>第一次握手（进入同步已发送状态）</strong> 
    <ul><li><strong>向服务器发送连接请求报文段</strong> 包含了端口和序列号</li><li>发送SYN序列号，此时seq=a</li></ul> </li><li><strong>第二次握手（进入同步收到状态）</strong> 
    <ul><li>确认报文段，标识服务器希望从客户端这边接收到数据的序列号</li><li>服务端返回SYN序列号，其中seq=b，并把ack+1进行返回</li></ul> </li><li><strong>第三次握手（已进入连接状态）</strong> 
    <ul><li>客户端收到服务端发送的确认<strong>ACK</strong>后，还要再次向服务器给出确认，确认报文段的ACK设置为１</li><li>SYN内的seq=b+1</li></ul> </li><li>三次握手的目的不仅在于通信双方了解一个连接正在建立，还在于用数据包的选项承载特殊的信息，确保通信双方是可靠的</li></ul> </li><li>四次挥手 
  <ul><li><strong>第一次挥手（终止等待状态）</strong> 
    <ul><li>客户端向服务器发出连接释放的报文段</li><li>发送 FIN，seq=a</li></ul> </li><li><strong>第二次挥手（终止等待状态２）</strong> 
    <ul><li>服务区收到连接释放报文段后立即发出确认</li><li>服务端返回ACK，seq=b，ack=a+1</li></ul> </li><li><strong>第三次挥手（最后确认）</strong> 
    <ul><li>如果服务器已经没有向客户端发送数据，其应用的进程就通知服务器释放连接</li><li>服务端继续返回FIN，seq=b，ack=a+1</li></ul> </li><li><strong>第四次挥手（时间等待）</strong> 
    <ul><li>客户端收到服务器的连接释放报文段后，立即对此发出确认</li><li>这样就能够让TCP重新发送最终的ACK以避免出现丢失的情况，重新发送最终的ACK并不是因为TCP重新传递了ACK，而是因为通信的另一方重新传递了它的FIN序列号</li><li>为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。</li><li>客户端发送ACK，seq=b+1</li></ul> </li></ul> </li></ul> 
<p>为什么是三次握手而不是两次</p> 
<ul><li>可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费。</li></ul> 
<p>进程，线程，协程区别</p> 
<ul><li> <p>进程是具有⼀定独⽴功能的程序关于某个数据集合上的⼀次运⾏活动,进程是系统进⾏资源分配和调度的⼀个独⽴单位。每个进程都有⾃⼰的独⽴<br> 内存空间，不同进程通过进程间通信来通信。由于进程⽐较重量，占据独⽴的内存，所以上下⽂进程间的切换开销（栈、寄存器、虚拟内存、⽂件<br> 句柄等）⽐较⼤，但相对⽐较稳定安全。</p> </li><li> <p>线程是进程的⼀个实体,是CPU调度和分派的基本单位,它是⽐进程更⼩的能独⽴运⾏的基本单位.线程⾃⼰基本上不拥有系统资源,只拥有⼀点在运<br> ⾏中必不可少的资源(如程序计数器,⼀组寄存器和栈),但是它可与同属⼀个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共<br> 享内存，上下⽂切换很快，资源开销较少，但相⽐进程不够稳定容易丢失数据。</p> </li><li> <p>协程是⼀种⽤户态的轻量级线程，协程的调度完全由⽤户控制。协程拥有⾃⼰的寄存器上下⽂和栈。协程调度切换时，将寄存器上下⽂和栈保存到<br> 其他地⽅，在切回来的时候，恢复先前保存的寄存器上下⽂和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下<br> ⽂的切换⾮常快。</p> </li></ul> 
<p>时间和空间复杂度</p> 
<ul><li>O(1) 没有循环 一次性执行</li><li>O(logN) 对数型TCP</li><li>O(n)线性 一个循环</li><li>O(n2)平方 for循环嵌套for</li><li>O(n3)立方 for循环嵌套for再嵌套for</li><li>O(2^n)指数</li><li>…</li></ul> 
<p>serverless</p> 
<ul><li>核心概念 
  <ul><li><strong>弱化了储存和计算之间的联系。</strong> 服务的储存和计算被分开部署和收费，服务的储存不再是它本身的一部分，而是演变成了独立的云服务，这使得计算变得<strong>无状态化</strong>，更容易调度和缩扩容，同时也降低了数据丢失的风险</li><li><strong>代码的执行不再需要手动分配资源。</strong> 我们再也不需要为服务的运行指定需要的资源（比如使用几台机器、多大的带宽、多大的磁盘…），只需要提供一份代码，剩下的交由serverless平台去处理就行了</li><li><strong>按使用量计费。</strong> serverless按照服务的使用量（调用次数、时长等）进行计费，而不是像传统的serverful服务那样，按照使用的资源（ECS实例、VM的规格等）计费。</li></ul> </li></ul> 
<p><a href="https://blog.csdn.net/qq_42427109/article/details/130624033?spm=1001.2014.3001.5501">微信云开发技术架构</a><br> <a href="https://blog.csdn.net/qq_42427109/article/details/127786503?spm=1001.2014.3001.5501">Serverless入门</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3e5afb0428e19ca41b47d688171dd4a8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用MATLAB将Excel里面的数据导入，并且将MATLAB数据导入到Excel里面的命令介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9e0d25de08d9b5ab5497d1d3cb4b7bc4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一个自用Typora魔改主题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>