<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Nginx安装及入门笔记 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Nginx安装及入门笔记" />
<meta property="og:description" content="Nginx环境准备 Nginx版本介绍 Nginx的官方网站为: http://nginx.org
打开源码可以看到如下的页面内容
Nginx的官方下载网站为http://nginx.org/en/download.html，当然你也可以之间在首页选中右边的download进入版本下载网页。在下载页面我们会看到如下内容：
获取Nginx源码 http://nginx.org/download/
打开上述网站，就可以查看到Nginx的所有版本，选中自己需要的版本进行下载。下载我们可以直接在windows上下载然后上传到服务器，也可以直接从服务器上下载，这个时候就需要准备一台服务器。
准备服务器系统 环境准备
VMware WorkStation Centos7 MobaXterm xsheel,SecureCRT 网络 (1)确认centos的内核
准备一个内核为2.6及以上版本的操作系统，因为linux2.6及以上内核才支持epoll,而Nginx需要解决高并发压力问题是需要用到epoll，所以我们需要有这样的版本要求。
我们可以使用uname -a命令来查询linux的内核版本。
(2)确保centos能联网
ping www.baidu.com (3)确认关闭防火墙
这一项的要求仅针对于那些对linux系统的防火墙设置规则不太清楚的，建议大家把防火墙都关闭掉，因为我们此次课程主要的内容是对Nginx的学习，把防火墙关闭掉，可以省掉后续Nginx学习过程中遇到的诸多问题。
关闭的方式有如下两种：
systemctl stop firewalld 关闭运行的防火墙，系统重新启动后，防火墙将重新打开 systemctl disable firewalld 永久关闭防火墙，，系统重新启动后，防火墙依然关闭 systemctl status firewalld	查看防火墙状态 （4）确认停用selinux
selinux(security-enhanced linux),美国安全局对于强制访问控制的实现，在linux2.6内核以后的版本中，selinux已经成功内核中的一部分。可以说selinux是linux史上最杰出的新安全子系统之一。虽然有了selinux，我们的系统会更安全，但是对于我们的学习Nginx的历程中，会多很多设置，所以这块建议大家将selinux进行关闭。
sestatus查看状态
如果查看不是disabled状态，我们可以通过修改配置文件来进行设置,修改SELINUX=disabled，然后重启下系统即可生效。
vim /etc/selinux/config Nginx安装方式介绍 Nginx的安装方式有两种分别是:
通过Nginx源码 通过Nginx源码简单安装 (1) 通过Nginx源码复杂安装 (3) 通过yum安装 (2) 如果通过Nginx源码安装需要提前准备的内容：
GCC编译器 Nginx是使用C语言编写的程序，因此想要运行Nginx就需要安装一个编译工具。GCC就是一个开源的编译器集合，用于处理各种各样的语言，其中就包含了C语言。
使用命令yum install -y gcc来安装
安装成功后，可以通过gcc --version来查看gcc是否安装成功
PCRE Nginx在编译过程中需要使用到PCRE库（perl Compatible Regular Expressoin 兼容正则表达式库)，因为在Nginx的Rewrite模块和http核心模块都会使用到PCRE正则表达式语法。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/1e73208e0da7274c52042fa8ba4d6f67/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-27T21:53:01+08:00" />
<meta property="article:modified_time" content="2021-05-27T21:53:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Nginx安装及入门笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Nginx_0"></a>Nginx环境准备</h3> 
<h4><a id="Nginx_2"></a>Nginx版本介绍</h4> 
<p>Nginx的官方网站为: http://nginx.org</p> 
<p>打开源码可以看到如下的页面内容<br> <img src="https://images2.imgbox.com/54/6f/xUmSdUTP_o.png" alt="在这里插入图片描述"></p> 
<p>Nginx的官方下载网站为<a href="http://nginx.org/en/download.html" rel="nofollow">http://nginx.org/en/download.html</a>，当然你也可以之间在首页选中右边的download进入版本下载网页。在下载页面我们会看到如下内容：</p> 
<p><img src="https://images2.imgbox.com/37/ee/PqmWkTJh_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Nginx_13"></a>获取Nginx源码</h4> 
<p><a href="http://nginx.org/download/" rel="nofollow">http://nginx.org/download/</a></p> 
<p>打开上述网站，就可以查看到Nginx的所有版本，选中自己需要的版本进行下载。下载我们可以直接在windows上下载然后上传到服务器，也可以直接从服务器上下载，这个时候就需要准备一台服务器。</p> 
<p><img src="https://images2.imgbox.com/55/02/EgvFeOjy_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_24"></a>准备服务器系统</h4> 
<p>环境准备</p> 
<pre><code>VMware WorkStation
Centos7
MobaXterm
	xsheel,SecureCRT
网络
</code></pre> 
<p>(1)确认centos的内核</p> 
<p>准备一个内核为2.6及以上版本的操作系统，因为linux2.6及以上内核才支持epoll,而Nginx需要解决高并发压力问题是需要用到epoll，所以我们需要有这样的版本要求。</p> 
<p>我们可以使用<code>uname -a</code>命令来查询linux的内核版本。</p> 
<p><img src="https://images2.imgbox.com/9e/41/rvt2Dzs4_o.png" alt="在这里插入图片描述"></p> 
<p>(2)确保centos能联网</p> 
<pre><code>ping www.baidu.com
</code></pre> 
<p><img src="https://images2.imgbox.com/79/22/q94HX5D2_o.png" alt="在这里插入图片描述"></p> 
<p>(3)确认关闭防火墙</p> 
<p>这一项的要求仅针对于那些对linux系统的防火墙设置规则不太清楚的，建议大家把防火墙都关闭掉，因为我们此次课程主要的内容是对Nginx的学习，把防火墙关闭掉，可以省掉后续Nginx学习过程中遇到的诸多问题。</p> 
<p>关闭的方式有如下两种：</p> 
<pre><code>systemctl stop firewalld      关闭运行的防火墙，系统重新启动后，防火墙将重新打开
systemctl disable firewalld   永久关闭防火墙，，系统重新启动后，防火墙依然关闭
systemctl status firewalld	 查看防火墙状态
</code></pre> 
<p>（4）确认停用selinux</p> 
<p>selinux(security-enhanced linux),美国安全局对于强制访问控制的实现，在linux2.6内核以后的版本中，selinux已经成功内核中的一部分。可以说selinux是linux史上最杰出的新安全子系统之一。虽然有了selinux，我们的系统会更安全，但是对于我们的学习Nginx的历程中，会多很多设置，所以这块建议大家将selinux进行关闭。</p> 
<p>sestatus查看状态</p> 
<p><img src="https://images2.imgbox.com/05/cd/ElEfvbGK_o.png" alt="在这里插入图片描述"></p> 
<p>如果查看不是disabled状态，我们可以通过修改配置文件来进行设置,修改SELINUX=disabled，然后重启下系统即可生效。</p> 
<pre><code>vim /etc/selinux/config
</code></pre> 
<p><img src="https://images2.imgbox.com/99/2d/XVRuoOf6_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Nginx_85"></a>Nginx安装方式介绍</h4> 
<p>Nginx的安装方式有两种分别是:</p> 
<pre><code>通过Nginx源码
	通过Nginx源码简单安装 (1)
	通过Nginx源码复杂安装 (3)
通过yum安装 (2)
</code></pre> 
<p>如果通过Nginx源码安装需要提前准备的内容：</p> 
<h6><a id="GCC_98"></a>GCC编译器</h6> 
<p>Nginx是使用C语言编写的程序，因此想要运行Nginx就需要安装一个编译工具。GCC就是一个开源的编译器集合，用于处理各种各样的语言，其中就包含了C语言。</p> 
<p>使用命令<code>yum install -y gcc</code>来安装</p> 
<p>安装成功后，可以通过<code>gcc --version</code>来查看gcc是否安装成功</p> 
<h6><a id="PCRE_106"></a>PCRE</h6> 
<p>Nginx在编译过程中需要使用到PCRE库（perl Compatible Regular Expressoin 兼容正则表达式库)，因为在Nginx的Rewrite模块和http核心模块都会使用到PCRE正则表达式语法。</p> 
<p>可以使用命令<code>yum install -y pcre pcre-devel</code>来进行安装</p> 
<p>安装成功后，可以通过<code>rpm -qa pcre pcre-devel</code>来查看是否安装成功</p> 
<h6><a id="zlib_114"></a>zlib</h6> 
<p>zlib库提供了开发人员的压缩算法，在Nginx的各个模块中需要使用gzip压缩，所以我们也需要提前安装其库及源代码zlib和zlib-devel</p> 
<p>可以使用命令<code>yum install -y zlib zlib-devel</code>来进行安装</p> 
<p>安装成功后，可以通过<code>rpm -qa zlib zlib-devel</code>来查看是否安装成功</p> 
<h6><a id="OpenSSL_122"></a>OpenSSL</h6> 
<p>OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包进行安全通信，并且避免被窃听。</p> 
<p>SSL:Secure Sockets Layer安全套接协议的缩写，可以在Internet上提供秘密性传输，其目标是保证两个应用间通信的保密性和可靠性。在Nginx中，如果服务器需要提供安全网页时就需要用到OpenSSL库，所以我们需要对OpenSSL的库文件及它的开发安装包进行一个安装。</p> 
<p>可以使用命令<code>yum install -y openssl openssl-devel</code>来进行安装</p> 
<p>安装成功后，可以通过<code>rpm -qa openssl openssl-devel</code>来查看是否安装成功</p> 
<p>上述命令，一个个来的话比较麻烦，我们也可以通过一条命令来进行安装</p> 
<p><code>yum install -y gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel</code>进行全部安装。</p> 
<h5><a id="Nginx_138"></a>方案一：Nginx的源码简单安装</h5> 
<p>(1)进入官网查找需要下载版本的链接地址，然后使用wget命令进行下载</p> 
<pre><code>wget http://nginx.org/download/nginx-1.16.1.tar.gz
</code></pre> 
<p>(2)建议大家将下载的资源进行包管理</p> 
<pre><code>mkdir -p nginx/core
mv nginx-1.16.1.tar.gz nginx/core
</code></pre> 
<p>(3)解压缩</p> 
<pre><code>tar -xzf nginx-1.16.1.tar.gz
</code></pre> 
<p>(4)进入资源文件中，发现configure</p> 
<pre><code>./configure
</code></pre> 
<p>(5)编译</p> 
<pre><code>make
</code></pre> 
<p>(6)安装</p> 
<pre><code>make install
</code></pre> 
<h5><a id="yum_179"></a>方案二：yum安装</h5> 
<p>使用源码进行简单安装，我们会发现安装的过程比较繁琐，需要提前准备GCC编译器、PCRE兼容正则表达式库、zlib压缩库、OpenSSL安全通信的软件库包，然后才能进行Nginx的安装。</p> 
<p>（1）安装yum-utils</p> 
<pre><code>sudo yum  install -y yum-utils
</code></pre> 
<p>（2）添加yum源文件</p> 
<pre><code>vim /etc/yum.repos.d/nginx.repo
</code></pre> 
<pre><code>[nginx-stable]
name=nginx stable repo
baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
gpgcheck=1
enabled=1
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true

[nginx-mainline]
name=nginx mainline repo
baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/
gpgcheck=1
enabled=0
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true
</code></pre> 
<p>（3）查看是否安装成功</p> 
<pre><code>yum list | grep nginx
</code></pre> 
<p><img src="https://images2.imgbox.com/02/a4/qTrC7Omq_o.png" alt="在这里插入图片描述"></p> 
<p>（4）使用yum进行安装</p> 
<pre><code>yun install -y nginx
</code></pre> 
<p>（5）查看nginx的安装位置</p> 
<pre><code>whereis nginx
</code></pre> 
<p><img src="https://images2.imgbox.com/b6/90/CKXe1d8K_o.png" alt="在这里插入图片描述"></p> 
<p>（6）启动测试</p> 
<h5><a id="yum_236"></a>源码简单安装和yum安装的差异：</h5> 
<p>这里先介绍一个命令: <code>./nginx -V</code>,通过该命令可以查看到所安装Nginx的版本及相关配置信息。</p> 
<p>简单安装</p> 
<p><img src="https://images2.imgbox.com/c9/cb/su0A7Rbu_o.png" alt="在这里插入图片描述"></p> 
<p>yum安装</p> 
<p><img src="https://images2.imgbox.com/f6/cc/znxaEQrE_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="Nginx_250"></a>解压Nginx目录</h6> 
<p>执行<code>tar -zxvf nginx-1.16.1.tar.gz</code>对下载的资源进行解压缩，进入压缩后的目录，可以看到如下结构</p> 
<p><img src="https://images2.imgbox.com/ca/5c/uTmdMvY7_o.png" alt="在这里插入图片描述"></p> 
<p>内容解释：</p> 
<p>auto:存放的是编译相关的脚本</p> 
<p>CHANGES:版本变更记录</p> 
<p>CHANGES.ru:俄罗斯文的版本变更记录</p> 
<p>conf:nginx默认的配置文件</p> 
<p>configure:nginx软件的自动脚本程序,是一个比较重要的文件，作用如下：</p> 
<p>​ （1）检测环境及根据环境检测结果生成C代码</p> 
<p>​ （2）生成编译代码需要的Makefile文件</p> 
<p>contrib:存放的是几个特殊的脚本文件，其中README中对脚本有着详细的说明</p> 
<p>html:存放的是Nginx自带的两个html页面，访问Nginx的首页和错误页面</p> 
<p>LICENSE:许可证的相关描述文件</p> 
<p>man:nginx的man手册</p> 
<p>README:Nginx的阅读指南</p> 
<p>src:Nginx的源代码</p> 
<h5><a id="Nginx_285"></a>方案三:Nginx的源码复杂安装</h5> 
<p>这种方式和简单的安装配置不同的地方在第一步，通过<code>./configure</code>来对编译参数进行设置，需要我们手动来指定。那么都有哪些参数可以进行设置，接下来我们进行一个详细的说明。</p> 
<p>PATH:是和路径相关的配置信息</p> 
<p>with:是启动模块，默认是关闭的</p> 
<p>without:是关闭模块，默认是开启的</p> 
<p>我们先来认识一些简单的路径配置已经通过这些配置来完成一个简单的编译：</p> 
<p>–prefix=PATH</p> 
<pre><code>指向Nginx的安装目录，默认值为/usr/local/nginx   
</code></pre> 
<p>–sbin-path=PATH</p> 
<pre><code>指向(执行)程序文件(nginx)的路径,默认值为&lt;prefix&gt;/sbin/nginx
</code></pre> 
<p>–modules-path=PATH</p> 
<pre><code>指向Nginx动态模块安装目录，默认值为&lt;prefix&gt;/modules
</code></pre> 
<p>–conf-path=PATH</p> 
<pre><code>指向配置文件(nginx.conf)的路径,默认值为&lt;prefix&gt;/conf/nginx.conf
</code></pre> 
<p>–error-log-path=PATH</p> 
<pre><code>指向错误日志文件的路径,默认值为&lt;prefix&gt;/logs/error.log
</code></pre> 
<p>–http-log-path=PATH</p> 
<pre><code>指向访问日志文件的路径,默认值为&lt;prefix&gt;/logs/access.log
</code></pre> 
<p>–pid-path=PATH</p> 
<pre><code>指向Nginx启动后进行ID的文件路径，默认值为&lt;prefix&gt;/logs/nginx.pid
</code></pre> 
<p>–lock-path=PATH</p> 
<pre><code>指向Nginx锁文件的存放路径,默认值为&lt;prefix&gt;/logs/nginx.lock
</code></pre> 
<p>要想使用可以通过如下命令</p> 
<pre><code>./configure --prefix=/usr/local/nginx \
--sbin-path=/usr/local/nginx/sbin/nginx \
--modules-path=/usr/local/nginx/modules \
--conf-path=/usr/local/nginx/conf/nginx.conf \
--error-log-path=/usr/local/nginx/logs/error.log \
--http-log-path=/usr/local/nginx/logs/access.log \
--pid-path=/usr/local/nginx/logs/nginx.pid \
--lock-path=/usr/local/nginx/logs/nginx.lock
</code></pre> 
<p>在使用上述命令之前，需要将之前服务器已经安装的nginx进行卸载，卸载的步骤分为三步骤：</p> 
<p>步骤一：需要将nginx的进程关闭</p> 
<pre><code>./nginx -s stop
</code></pre> 
<p>步骤二:将安装的nginx进行删除</p> 
<pre><code>rm -rf /usr/local/nginx
</code></pre> 
<p>步骤三:将安装包之前编译的环境清除掉</p> 
<pre><code>make clean
</code></pre> 
<h4><a id="Nginx_378"></a>Nginx目录结构分析</h4> 
<p>在使用Nginx之前，我们先对安装好的Nginx目录文件进行一个分析，在这块给大家介绍一个工具tree，通过tree我们可以很方面的去查看centos系统上的文件目录结构，当然，如果想使用tree工具，就得先通过<code>yum install -y tree</code>来进行安装，安装成功后，可以通过执行<code>tree /usr/local/nginx</code>(tree后面跟的是Nginx的安装目录)，获取的结果如下：</p> 
<p><img src="https://images2.imgbox.com/4c/0c/XXD8ax7u_o.png" alt="在这里插入图片描述"></p> 
<p>conf:nginx所有配置文件目录</p> 
<p>​ CGI(Common Gateway Interface)通用网关【接口】，主要解决的问题是从客户端发送一个请求和数据，服务端获取到请求和数据后可以调用调用CGI【程序】处理及相应结果给客户端的一种标准规范。</p> 
<p>​ fastcgi.conf:fastcgi相关配置文件</p> 
<p>​ fastcgi.conf.default:fastcgi.conf的备份文件</p> 
<p>​ fastcgi_params:fastcgi的参数文件</p> 
<p>​ fastcgi_params.default:fastcgi的参数备份文件</p> 
<p>​ scgi_params:scgi的参数文件</p> 
<p>​ scgi_params.default：scgi的参数备份文件</p> 
<p>​ uwsgi_params:uwsgi的参数文件</p> 
<p>​ uwsgi_params.default:uwsgi的参数备份文件</p> 
<p>​ mime.types:记录的是HTTP协议中的Content-Type的值和文件后缀名的对应关系</p> 
<p>​ mime.types.default:mime.types的备份文件</p> 
<p>​ nginx.conf:这个是Nginx的核心配置文件，这个文件非常重要，也是我们即将要学习的重点</p> 
<p>​ nginx.conf.default:nginx.conf的备份文件</p> 
<p>​ koi-utf、koi-win、win-utf这三个文件都是与编码转换映射相关的配置文件，用来将一种编码转换成另一种编码</p> 
<p>html:存放nginx自带的两个静态的html页面</p> 
<p>​ 50x.html:访问失败后的失败页面</p> 
<p>​ index.html:成功访问的默认首页</p> 
<p>logs:记录入门的文件，当nginx服务器启动后，这里面会有 access.log error.log 和nginx.pid三个文件出现。</p> 
<p>sbin:是存放执行程序文件nginx</p> 
<p>​ nginx是用来控制Nginx的启动和停止等相关的命令。</p> 
<h4><a id="Nginx_429"></a>Nginx服务器启停命令</h4> 
<p>Nginx安装完成后，接下来我们要学习的是如何启动、重启和停止Nginx的服务。</p> 
<p>对于Nginx的启停在linux系统中也有很多种方式，我们本次课程介绍两种方式：</p> 
<ol><li> <p>Nginx服务的信号控制</p> </li><li> <p>Nginx的命令行控制</p> </li></ol> 
<h5><a id="Nginx_439"></a>方式一:Nginx服务的信号控制</h5> 
<pre><code>Nginx中的master和worker进程?
Nginx的工作方式?
如何获取进程的PID?
信号有哪些?
如何通过信号控制Nginx的启停等相关操作?
</code></pre> 
<p>前面在提到Nginx的高性能，其实也和它的架构模式有关。Nginx默认采用的是多进程的方式来工作的，当将Nginx启动后，我们通过<code>ps -ef | grep nginx</code>命令可以查看到如下内容：</p> 
<p><img src="https://images2.imgbox.com/40/34/TsC7uOWK_o.png" alt="在这里插入图片描述"></p> 
<p>从上图中可以看到,Nginx后台进程中包含一个master进程和多个worker进程，master进程主要用来管理worker进程，包含接收外界的信息，并将接收到的信号发送给各个worker进程，监控worker进程的状态，当worker进程出现异常退出后，会自动重新启动新的worker进程。而worker进程则是专门用来处理用户请求的，各个worker进程之间是平等的并且相互独立，处理请求的机会也是一样的。nginx的进程模型，我们可以通过下图来说明下：</p> 
<p><img src="https://images2.imgbox.com/a7/98/q4v4wDJx_o.png" alt="在这里插入图片描述"></p> 
<p>我们现在作为管理员，只需要通过给master进程发送信号就可以来控制Nginx,这个时候我们需要有两个前提条件，一个是要操作的master进程，一个是信号。</p> 
<p>（1）要想操作Nginx的master进程，就需要获取到master进程的进程号ID。获取方式简单介绍两个，</p> 
<p>方式一：通过<code>ps -ef | grep nginx</code>；</p> 
<p>方式二：在讲解nginx的<code>./configure</code>的配置参数的时候，有一个参数是<code>--pid-path=PATH</code>默认是<code>/usr/local/nginx/logs/nginx.pid</code>,所以可以通过查看该文件来获取nginx的master进程ID.</p> 
<p>（2）信号</p> 
<table><thead><tr><th>信号</th><th>作用</th></tr></thead><tbody><tr><td>TERM/INT</td><td>立即关闭整个服务</td></tr><tr><td>QUIT</td><td>"优雅"地关闭整个服务</td></tr><tr><td>HUP</td><td>重读配置文件并使用服务对新配置项生效</td></tr><tr><td>USR1</td><td>重新打开日志文件，可以用来进行日志切割</td></tr><tr><td>USR2</td><td>平滑升级到最新版的nginx</td></tr><tr><td>WINCH</td><td>所有子进程不在接收处理新连接，相当于给work进程发送QUIT指令</td></tr></tbody></table> 
<p>调用命令为<code>kill -signal PID</code></p> 
<p>signal:即为信号；PID即为获取到的master线程ID</p> 
<ol><li>发送TERM/INT信号给master进程，会将Nginx服务立即关闭。</li></ol> 
<pre><code>kill -TERM PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`
kill -INT PID / kill -INT `cat /usr/local/nginx/logs/nginx.pid`
</code></pre> 
<ol start="2"><li>发送QUIT信号给master进程，master进程会控制所有的work进程不再接收新的请求，等所有请求处理完后，在把进程都关闭掉。</li></ol> 
<pre><code>kill -QUIT PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`
</code></pre> 
<ol start="3"><li>发送HUP信号给master进程，master进程会把控制旧的work进程不再接收新的请求，等处理完请求后将旧的work进程关闭掉，然后根据nginx的配置文件重新启动新的work进程</li></ol> 
<pre><code>kill -HUP PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`
</code></pre> 
<ol start="4"><li>发送USR1信号给master进程，告诉Nginx重新开启日志文件</li></ol> 
<pre><code>kill -USR1 PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`
</code></pre> 
<ol start="5"><li>发送USR2信号给master进程，告诉master进程要平滑升级，这个时候，会重新开启对应的master进程和work进程，整个系统中将会有两个master进程，并且新的master进程的PID会被记录在<code>/usr/local/nginx/logs/nginx.pid</code>而之前的旧的master进程PID会被记录在<code>/usr/local/nginx/logs/nginx.pid.oldbin</code>文件中，接着再次发送QUIT信号给旧的master进程，让其处理完请求后再进行关闭</li></ol> 
<pre><code>kill -USR2 PID / kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`
</code></pre> 
<pre><code>kill -QUIT PID / kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`
</code></pre> 
<p><img src="https://images2.imgbox.com/89/a5/SRnp1yGY_o.png" alt="在这里插入图片描述"></p> 
<ol start="6"><li>发送WINCH信号给master进程,让master进程控制不让所有的work进程在接收新的请求了，请求处理完后关闭work进程。注意master进程不会被关闭掉</li></ol> 
<pre><code>kill -WINCH PID /kill -WINCH`cat /usr/local/nginx/logs/nginx.pid`
</code></pre> 
<h5><a id="Nginx_526"></a>方式二:Nginx的命令行控制</h5> 
<p>此方式是通过Nginx安装目录下的sbin下的可执行文件nginx来进行Nginx状态的控制，我们可以通过<code>nginx -h</code>来查看都有哪些参数可以用：</p> 
<p><img src="https://images2.imgbox.com/cf/41/OgbErWWv_o.png" alt="在这里插入图片描述"></p> 
<p>-?和-h:显示帮助信息</p> 
<p>-v:打印版本号信息并退出</p> 
<p>-V:打印版本号信息和配置信息并退出</p> 
<p>-t:测试nginx的配置文件语法是否正确并退出</p> 
<p>-T:测试nginx的配置文件语法是否正确并列出用到的配置文件信息然后退出</p> 
<p>-q:在配置测试期间禁止显示非错误消息</p> 
<p>-s:signal信号，后面可以跟 ：</p> 
<p>​ stop[快速关闭，类似于TERM/INT信号的作用]</p> 
<p>​ quit[优雅的关闭，类似于QUIT信号的作用]</p> 
<p>​ reopen[重新打开日志文件类似于USR1信号的作用]</p> 
<p>​ reload[类似于HUP信号的作用]</p> 
<p>-p:prefix，指定Nginx的prefix路径，(默认为: /usr/local/nginx/)</p> 
<p>-c:filename,指定Nginx的配置文件路径,(默认为: conf/nginx.conf)</p> 
<p>-g:用来补充Nginx配置文件，向Nginx服务指定启动时应用全局的配置</p> 
<h4><a id="Nginx_561"></a>Nginx服务器版本升级和新增模块</h4> 
<p>如果想对Nginx的版本进行更新，或者要应用一些新的模块，最简单的做法就是停止当前的Nginx服务，然后开启新的Nginx服务。但是这样会导致在一段时间内，用户是无法访问服务器。为了解决这个问题，我们就需要用到Nginx服务器提供的平滑升级功能。这个也是Nginx的一大特点，使用这种方式，就可以使Nginx在7*24小时不间断的提供服务了。接下来我们分析下需求：</p> 
<pre><code>需求：Nginx的版本最开始使用的是Nginx-1.14.2,由于服务升级，需要将Nginx的版本升级到Nginx-1.16.1,要求Nginx不能中断提供服务。
</code></pre> 
<p>为了应对上述的需求，这里我们给大家提供两种解决方案:</p> 
<p>方案一:使用Nginx服务信号完成Nginx的升级</p> 
<p>方案二:使用Nginx安装目录的make命令完成升级</p> 
<h5><a id="_575"></a>环境准备</h5> 
<p>（1）先准备两个版本的Nginx分别是 1.14.2和1.16.1</p> 
<p>（2）使用Nginx源码安装的方式将1.14.2版本安装成功并正确访问</p> 
<pre><code>进入安装目录
./configure
make &amp;&amp; make install
</code></pre> 
<p>（3）将Nginx1.16.1进行参数配置和编译，不需要进行安装。</p> 
<pre><code>进入安装目录
./configure
make 
</code></pre> 
<h5><a id="Nginx_595"></a>方案一:使用Nginx服务信号进行升级</h5> 
<p>第一步:将1.14.2版本的sbin目录下的nginx进行备份</p> 
<pre><code>cd /usr/local/nginx/sbin
mv nginx nginxold
</code></pre> 
<p>第二步:将Nginx1.16.1安装目录编译后的objs目录下的nginx文件，拷贝到原来<code>/usr/local/nginx/sbin</code>目录下</p> 
<pre><code>cd ~/nginx/core/nginx-1.16.1/objs
cp nginx /usr/local/nginx/sbin
</code></pre> 
<p>第三步:发送信号USR2给Nginx的1.14.2版本对应的master进程</p> 
<p>第四步:发送信号QUIT给Nginx的1.14.2版本对应的master进程</p> 
<pre><code>kill -QUIT `more /usr/local/logs/nginx.pid.oldbin`
</code></pre> 
<h5><a id="Nginxmake_619"></a>方案二:使用Nginx安装目录的make命令完成升级</h5> 
<p>第一步:将1.14.2版本的sbin目录下的nginx进行备份</p> 
<pre><code>cd /usr/local/nginx/sbin
mv nginx nginxold
</code></pre> 
<p>第二步:将Nginx1.16.1安装目录编译后的objs目录下的nginx文件，拷贝到原来<code>/usr/local/nginx/sbin</code>目录下</p> 
<pre><code>cd ~/nginx/core/nginx-1.16.1/objs
cp nginx /usr/local/nginx/sbin
</code></pre> 
<p>第三步:进入到安装目录，执行<code>make upgrade</code></p> 
<p><img src="https://images2.imgbox.com/49/fd/pHN36iXI_o.png" alt="在这里插入图片描述"></p> 
<p>第四步:查看是否更新成功</p> 
<pre><code>./nginx -v
</code></pre> 
<p>在整个过程中，其实Nginx是一直对外提供服务的。并且当Nginx的服务器启动成功后，我们是可以通过浏览器进行直接访问的，同时我们可以通过更改html目录下的页面来修改我们在页面上所看到的内容，那么问题来了，为什么我们要修改html目录下的文件，能不能多添加一些页面是Nginx的功能更加丰富，还有前面聊到Nginx的前端功能又是如何来实现的，这就需要我们对Nginx的核心配置文件进行一个详细的学习。</p> 
<h3><a id="Nginx_648"></a>Nginx核心配置文件结构</h3> 
<p>从前面的内容学习中，我们知道Nginx的核心配置文件默认是放在<code>/usr/local/nginx/conf/nginx.conf</code>，这一节，我们就来学习下nginx.conf的内容和基本配置方法。</p> 
<p>读取Nginx自带的Nginx配置文件，我们将其中的注释部分【学习一个技术点就是在Nginx的配置文件中可以使用<code>#</code>来注释】删除掉后，就剩下下面内容:</p> 
<pre><code class="prism language-conf">worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;

    server {
        listen       80;
        server_name  localhost;
        location / {
            root   html;
            index  index.html index.htm;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }

}
</code></pre> 
<pre><code>指令名	指令值;  #全局块，主要设置Nginx服务器整体运行的配置指令

 #events块,主要设置,Nginx服务器与用户的网络连接,这一部分对Nginx服务器的性能影响较大
events {	 
    指令名	指令值;
}
#http块，是Nginx服务器配置中的重要部分，代理、缓存、日志记录、第三方模块配置...             
http {		
    指令名	指令值;
    server { #server块，是Nginx配置和虚拟主机相关的内容
        指令名	指令值;
        location / { 
        #location块，基于Nginx服务器接收请求字符串与location后面的值进行匹配，对特定请求进行处理
            指令名	指令值;
        }
    }
	...
}
</code></pre> 
<p>简单小结下:</p> 
<p>nginx.conf配置文件中默认有三大块：全局块、events块、http块</p> 
<p>http块中可以配置多个server块，每个server块又可以配置多个location块。</p> 
<h4><a id="_710"></a>全局块</h4> 
<h5><a id="user_712"></a>user指令</h5> 
<p>（1）user:用于配置运行Nginx服务器的worker进程的用户和用户组。</p> 
<table><thead><tr><th>语法</th><th>user user [group]</th></tr></thead><tbody><tr><td>默认值</td><td>nobody</td></tr><tr><td>位置</td><td>全局块</td></tr></tbody></table> 
<p>该属性也可以在编译的时候指定，语法如下<code>./configure --user=user --group=group</code>,如果两个地方都进行了设置，最终生效的是配置文件中的配置。</p> 
<p>该指令的使用步骤:</p> 
<p>(1)设置一个用户信息"www"</p> 
<pre><code>user www;
</code></pre> 
<p><img src="https://images2.imgbox.com/91/3a/m7l4bTaG_o.png" alt="在这里插入图片描述"></p> 
<p>(2) 创建一个用户</p> 
<pre><code>useradd www
</code></pre> 
<p>(3)修改user属性</p> 
<pre><code>user www
</code></pre> 
<p>(4)创建<code>/root/html/index.html</code>页面，添加如下内容</p> 
<pre><code class="prism language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Welcome to nginx!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
    <span class="token selector">body</span> <span class="token punctuation">{<!-- --></span>
        <span class="token property">width</span><span class="token punctuation">:</span> 35em<span class="token punctuation">;</span>
        <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
        <span class="token property">font-family</span><span class="token punctuation">:</span> Tahoma<span class="token punctuation">,</span> Verdana<span class="token punctuation">,</span> Arial<span class="token punctuation">,</span> sans-serif<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>Welcome to nginx!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>For online documentation and support please refer to
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://nginx.org/<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>nginx.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/&gt;</span></span>
Commercial support is available at
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://nginx.com/<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>nginx.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>em</span><span class="token punctuation">&gt;</span></span>Thank you for using nginx.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>em</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>em</span><span class="token punctuation">&gt;</span></span>I am WWW<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>em</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>(5)修改nginx.conf</p> 
<pre><code>location / {
	root   /root/html;
	index  index.html index.htm;
}
</code></pre> 
<p>(5)测试启动访问</p> 
<pre><code>页面会报403拒绝访问的错误
</code></pre> 
<p>(6)分析原因</p> 
<pre><code>因为当前用户没有访问/root/html目录的权限
</code></pre> 
<p>(7)将文件创建到 <code>/home/www/html/index.html</code>,修改配置</p> 
<pre><code>location / {
	root   /home/www/html;
	index  index.html index.htm;
}
</code></pre> 
<p>(8)再次测试启动访问</p> 
<pre><code>能正常访问。
</code></pre> 
<p>综上所述，使用user指令可以指定启动运行工作进程的用户及用户组，这样对于系统的权限访问控制的更加精细，也更加安全。</p> 
<h5><a id="work_process_814"></a>work process指令</h5> 
<p>master_process:用来指定是否开启工作进程。</p> 
<table><thead><tr><th>语法</th><th>master_process on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>master_process on;</td></tr><tr><td>位置</td><td>全局块</td></tr></tbody></table> 
<p>worker_processes:用于配置Nginx生成工作进程的数量，这个是Nginx服务器实现并发处理服务的关键所在。理论上来说workder process的值越大，可以支持的并发处理量也越多，但事实上这个值的设定是需要受到来自服务器自身的限制，建议将该值和服务器CPU的内核数保存一致。</p> 
<table><thead><tr><th>语法</th><th>worker_processes num/auto;</th></tr></thead><tbody><tr><td>默认值</td><td>1</td></tr><tr><td>位置</td><td>全局块</td></tr></tbody></table> 
<p>如果将worker_processes设置成2，则会看到如下内容:</p> 
<p><img src="https://images2.imgbox.com/23/c7/uZmcfhqD_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_835"></a>其他指令</h5> 
<p>daemon：设定Nginx是否以守护进程的方式启动。</p> 
<p>守护式进程是linux后台执行的一种服务进程，特点是独立于控制终端，不会随着终端关闭而停止。</p> 
<table><thead><tr><th>语法</th><th>daemon on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>daemon on;</td></tr><tr><td>位置</td><td>全局块</td></tr></tbody></table> 
<p>pid:用来配置Nginx当前master进程的进程号ID存储的文件路径。</p> 
<table><thead><tr><th>语法</th><th>pid file;</th></tr></thead><tbody><tr><td>默认值</td><td>默认为:/usr/local/nginx/logs/nginx.pid</td></tr><tr><td>位置</td><td>全局块</td></tr></tbody></table> 
<p>该属性可以通过<code>./configure --pid-path=PATH</code>来指定</p> 
<p>error_log:用来配置Nginx的错误日志存放路径</p> 
<table><thead><tr><th>语法</th><th>error_log file [日志级别];</th></tr></thead><tbody><tr><td>默认值</td><td>error_log logs/error.log error;</td></tr><tr><td>位置</td><td>全局块、http、server、location</td></tr></tbody></table> 
<p>该属性可以通过<code>./configure --error-log-path=PATH</code>来指定</p> 
<p>其中日志级别的值有：debug|info|notice|warn|error|crit|alert|emerg，翻译过来为试|信息|通知|警告|错误|临界|警报|紧急，这块建议大家设置的时候不要设置成info以下的等级，因为会带来大量的磁盘I/O消耗，影响Nginx的性能。</p> 
<p>（5）include:用来引入其他配置文件，使Nginx的配置更加灵活</p> 
<table><thead><tr><th>语法</th><th>include file;</th></tr></thead><tbody><tr><td>默认值</td><td>无</td></tr><tr><td>位置</td><td>any</td></tr></tbody></table> 
<h4><a id="events_873"></a>events块</h4> 
<p>（1）accept_mutex:用来设置Nginx网络连接序列化</p> 
<table><thead><tr><th>语法</th><th>accept_mutex on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>accept_mutex on;</td></tr><tr><td>位置</td><td>events</td></tr></tbody></table> 
<p>这个配置主要可以用来解决常说的"惊群"问题。大致意思是在某一个时刻，客户端发来一个请求连接，Nginx后台是以多进程的工作模式，也就是说有多个worker进程会被同时唤醒，但是最终只会有一个进程可以获取到连接，如果每次唤醒的进程数目太多，就会影响Nginx的整体性能。如果将上述值设置为on(开启状态)，将会对多个Nginx进程接收连接进行序列号，一个个来唤醒接收，就防止了多个进程对连接的争抢。</p> 
<p><img src="https://images2.imgbox.com/23/bc/iX9UzZcA_o.png" alt="在这里插入图片描述"></p> 
<p>（2）multi_accept:用来设置是否允许同时接收多个网络连接</p> 
<table><thead><tr><th>语法</th><th>multi_accept on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>multi_accept off;</td></tr><tr><td>位置</td><td>events</td></tr></tbody></table> 
<p>如果multi_accept被禁止了，nginx一个工作进程只能同时接受一个新的连接。否则，一个工作进程可以同时接受所有的新连接</p> 
<p>（3）worker_connections：用来配置单个worker进程最大的连接数</p> 
<table><thead><tr><th>语法</th><th>worker_connections number;</th></tr></thead><tbody><tr><td>默认值</td><td>worker_commections 512;</td></tr><tr><td>位置</td><td>events</td></tr></tbody></table> 
<p>这里的连接数不仅仅包括和前端用户建立的连接数，而是包括所有可能的连接数。另外，number值不能大于操作系统支持打开的最大文件句柄数量。</p> 
<p>（4）use:用来设置Nginx服务器选择哪种事件驱动来处理网络消息。</p> 
<table><thead><tr><th>语法</th><th>use method;</th></tr></thead><tbody><tr><td>默认值</td><td>根据操作系统定</td></tr><tr><td>位置</td><td>events</td></tr></tbody></table> 
<p>注意：此处所选择事件处理模型是Nginx优化部分的一个重要内容，method的可选值有select/poll/epoll/kqueue等，之前在准备centos环境的时候，我们强调过要使用linux内核在2.6以上，就是为了能使用epoll函数来优化Nginx。</p> 
<p>另外这些值的选择，我们也可以在编译的时候使用</p> 
<p><code>--with-select_module</code>、<code>--without-select_module</code>、</p> 
<p><code>--with-poll_module</code>、<code>--without-poll_module</code>来设置是否需要将对应的事件驱动模块编译到Nginx的内核。</p> 
<h5><a id="events_920"></a>events指令配置实例</h5> 
<p>打开Nginx的配置文件 nginx.conf,添加如下配置</p> 
<pre><code>events{
	accept_mutex on;
	multi_accept on;
	worker_commections 1024;
	use epoll;
}
</code></pre> 
<p>启动测试</p> 
<pre><code>./nginx -t
./nginx -s reload
</code></pre> 
<h4><a id="http_940"></a>http块</h4> 
<h5><a id="MIMEType_942"></a>定义MIME-Type</h5> 
<p>我们都知道浏览器中可以显示的内容有HTML、XML、GIF等种类繁多的文件、媒体等资源，浏览器为了区分这些资源，就需要使用MIME Type。所以说MIME Type是网络资源的媒体类型。Nginx作为web服务器，也需要能够识别前端请求的资源类型。</p> 
<p>在Nginx的配置文件中，默认有两行配置</p> 
<pre><code>include mime.types;
default_type application/octet-stream;
</code></pre> 
<p>（1）default_type:用来配置Nginx响应前端请求默认的MIME类型。</p> 
<table><thead><tr><th>语法</th><th>default_type mime-type;</th></tr></thead><tbody><tr><td>默认值</td><td>default_type text/plain；</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table> 
<p>在default_type之前还有一句<code>include mime.types</code>,include之前我们已经介绍过，相当于把mime.types文件中MIMT类型与相关类型文件的文件后缀名的对应关系加入到当前的配置文件中。</p> 
<p>举例来说明：</p> 
<p>有些时候请求某些接口的时候需要返回指定的文本字符串或者json字符串，如果逻辑非常简单或者干脆是固定的字符串，那么可以使用nginx快速实现，这样就不用编写程序响应请求了，可以减少服务器资源占用并且响应性能非常快。</p> 
<p>如何实现:</p> 
<pre><code>location /get_text {
	#这里也可以设置成text/plain
    default_type text/html;
    return 200 "This is nginx's text";
}
location /get_json{
    default_type application/json;
    return 200 '{"name":"TOM","age":18}';
}
</code></pre> 
<h5><a id="_980"></a>自定义服务日志</h5> 
<p>Nginx中日志的类型分access.log、error.log。</p> 
<p>access.log:用来记录用户所有的访问请求。</p> 
<p>error.log:记录nginx本身运行时的错误信息，不会记录用户的访问请求。</p> 
<p>Nginx服务器支持对服务日志的格式、大小、输出等进行设置，需要使用到两个指令，分别是access_log和log_format指令。</p> 
<p>（1）access_log:用来设置用户访问日志的相关属性。</p> 
<table><thead><tr><th>语法</th><th>access_log path[format[buffer=size]]</th></tr></thead><tbody><tr><td>默认值</td><td>access_log logs/access.log combined;</td></tr><tr><td>位置</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table> 
<p>（2）log_format:用来指定日志的输出格式。</p> 
<table><thead><tr><th>语法</th><th>log_format name [escape=default|json|none] string…;</th></tr></thead><tbody><tr><td>默认值</td><td>log_format combined “…”;</td></tr><tr><td>位置</td><td>http</td></tr></tbody></table> 
<h5><a id="_1004"></a>其他配置指令</h5> 
<p>（1）sendfile:用来设置Nginx服务器是否使用sendfile()传输文件，该属性可以大大提高Nginx处理静态资源的性能</p> 
<table><thead><tr><th>语法</th><th>sendfile on|off；</th></tr></thead><tbody><tr><td>默认值</td><td>sendfile off;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table> 
<p>（2）keepalive_timeout:用来设置长连接的超时时间。</p> 
<p>》为什么要使用keepalive？</p> 
<pre><code>我们都知道HTTP是一种无状态协议，客户端向服务端发送一个TCP请求，服务端响应完毕后断开连接。
如何客户端向服务端发送多个请求，每个请求都需要重新创建一次连接，效率相对来说比较多，使用keepalive模式，可以告诉服务器端在处理完一个请求后保持这个TCP连接的打开状态，若接收到来自这个客户端的其他请求，服务端就会利用这个未被关闭的连接，而不需要重新创建一个新连接，提升效率，但是这个连接也不能一直保持，这样的话，连接如果过多，也会是服务端的性能下降，这个时候就需要我们进行设置其的超时时间。
</code></pre> 
<table><thead><tr><th>语法</th><th>keepalive_timeout time;</th></tr></thead><tbody><tr><td>默认值</td><td>keepalive_timeout 75s;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table> 
<p>（3）keepalive_requests:用来设置一个keep-alive连接使用的次数。</p> 
<table><thead><tr><th>语法</th><th>keepalive_requests number;</th></tr></thead><tbody><tr><td>默认值</td><td>keepalive_requests 100;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table> 
<h4><a id="serverlocation_1034"></a>server块和location块</h4> 
<p>server块和location块都是我们要重点讲解和学习的内容，因为我们后面会对Nginx的功能进行详细讲解，所以这块内容就放到静态资源部署的地方给大家详细说明。</p> 
<p>本节我们主要来认识下Nginx默认给的nginx.conf中的相关内容，以及server块与location块在使用的时候需要注意的一些内容。</p> 
<pre><code>	server {
        listen       80;
        server_name  localhost;
        location / {
            root   html;
            index  index.html index.htm;
        }
       
        error_page   500 502 503 504 404  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/50d2b85cdfeaeb6f0f9e356b17c0474f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RestTemplate-文件上传下载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d62f5e7067ff276a844a8ca2ab535d72/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用vs建立C/C&#43;&#43;项目</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>