<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>学习笔记整理 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="学习笔记整理" />
<meta property="og:description" content="本文仅用于作者考研路上的学习与思考，以便日后复习，若有不对，欢迎读者指正 操作系统 1 堆，栈有什么区别？ 从数据结构的角度来看：
栈：在数据结构中，是一种受限的线性表，特点是后进先出，
堆：实际上就是优先队列的一种数据结构，第一个元素有最高的优先权
在数据结构中，有大根堆和小根堆的概念
概念：叶子节点大于（或小于）父节点
从内存分区的角度来看：
在C&#43;&#43;中内存分为五大分区，分别是栈区，堆区，自由存储区，常量存储区，全局静态存储区
栈的使用与回收都是系统进行的，而在C语言中使用malloc在堆中申请空间，需要手动使用free释放，在C&#43;&#43;中使用new在自由存储区申请空间，delete释放。
2进程和线程的区别 进程是系统进行分配资源和内存管理的基本单位，是一段程序在某一个数据集上面的一次运算，运行时，从磁盘中加载到内存。
线程是系统调度的最小单位，是进程的一部分。
区别：一个进程包括多个线程，线程是进程执行的每一一个小任务，进程切换时需要切换资源和内存，而线程切换时不需要切换资源和内存，只需要切换pc指针。
3 什么是死锁 死锁的定义：如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发事件，那么该组进程是死锁的。
死锁的条件：
①互斥条件②占有和等待条件③不剥夺条件④循环等待条件
死锁的常见表现：
（1）多进程死锁：有A，B两个进程，进程A拥有资源1，需要请求正在被进程B占有的资源2，而进程B拥有资源2，又在请求资源1，两个进程都在等待对方释放资源后请求该资源，而相互僵持，陷入死锁。
（2）单线程死锁:进程A拥有进程1，而它又在请求资源1，而它所请求的资源1必须等待该资源使用完毕得到释放后才可被请求，这样，就陷入了自己的死锁。
解决死锁的方法：
①终止（或撤销）进程。终止系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态中解除出来。
（2）抢占资源。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以打破死锁状态
4 内存管理有哪些方法 常见的内存管理方式有分区存储管理，页式管理，段式管理，虚拟存储管理
连续存储管理，包括固定分区存储管理，非固定分区存储管理
分页存储管理
段式存储管理
虚拟存储管理
5 操作系统提供给程序员创建进程的接口有哪些 系统调用fork()，vfork() ,clone()
6 进程调度算法有哪些？ 先来先服务，短作业优先，高优先权优先（可以动态优先，高响应比优先，也可静态优先权），基于时间片轮转（基于时间片轮转调度算法RR，多级反馈队列算法FB），最短剩余时间优先。
7 中断嵌套是什么； 指新的优先级更高的中断会去中断CPU上正在运行的中断程序，并且在新的中断结束后，返回到被中断点处继续执行。
8 调度什么时候发生？ ①当进程需要等待某个资源（比如I/O设备）时，主动请求调度让出CPU
②当前的时间片用完时
③当进程状态状态发生改变时：比如，进程终止，进程睡眠
④进程从中断，异常及系统调用返回到用户态时。
9 操作系统的定义？ 操作系统是管理计算机硬件与软件资源的计算机程序。
它提供：内存和资源的分配，控制输入输出设备，操作网络和管理文件，提供人机交互界面
10 一个文件在磁盘上，如何访问到 缺页中断
或者主动调用int 19H中断，将磁盘的数据读入到内存
当程序执行的指令或访问到的数据在内存中时可顺利执行；如果在磁盘中，需要系统自动将这部分信息装入，这称“部分装入”；如此刻没有足够的空闲内存空间，便把内存中不用的信息暂时移到磁盘上，这称部分替换。所以只要“部分装入”和“部分替换能够实现”，实现从磁盘中读入数据，来让CPU执行。
根据FCB汇集和组织形成的文件目录，文件目录将文件名称转化为磁盘中的存储位置，然后通过访问道磁盘中的数据就可以访问到了。
11 操作系统的知识结构，内容，包括哪些？ 处理器管理，进程调度，存储管理，设备管理，文件管理
12 什么是进程，进程调度是调度谁，进程的工作状态 进程中程序关于一个操作数据集上的一次运行活动，同时，进程也是资源和内存分配的基本单位。
进程调度是调度谁：因为程序在CPU中是走走停停的，为了使CPU能够达到最大的使用效率，当某一个进程在运行过程中需要停止等待，比如说，需要等待I/O，而这时，访问外设的时候，时间就比较长，这时，该进程就会让出CPU的使用权，按照所规定的调度算法，选择在就绪队列的中的其中一个进程，将当前的CPU进程保存在PCB块中，以linux操作系统为例，就是调用shedul（）中的switch_to()进程切换进程。
进程的工作状态：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/6b22b8dcc7a571445919a53e5d404a89/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-16T22:05:54+08:00" />
<meta property="article:modified_time" content="2020-05-16T22:05:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">学习笔记整理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a><strong>本文仅用于作者考研路上的学习与思考，以便日后复习，若有不对，欢迎读者指正</strong></h2> 
<h2><a id="_3"></a>操作系统</h2> 
<h4><a id="1__5"></a>1 堆，栈有什么区别？</h4> 
<p>从数据结构的角度来看：</p> 
<p>栈：在数据结构中，是一种受限的线性表，特点是后进先出，</p> 
<p>堆：实际上就是优先队列的一种数据结构，第一个元素有最高的优先权</p> 
<p>在数据结构中，有大根堆和小根堆的概念</p> 
<p>概念：叶子节点大于（或小于）父节点</p> 
<p>从内存分区的角度来看：</p> 
<p>在C++中内存分为五大分区，分别是栈区，堆区，自由存储区，常量存储区，全局静态存储区</p> 
<p>栈的使用与回收都是系统进行的，而在C语言中使用malloc在堆中申请空间，需要手动使用free释放，在C++中使用new在自由存储区申请空间，delete释放。</p> 
<h4><a id="2_23"></a>2进程和线程的区别</h4> 
<p>进程是系统进行分配资源和内存管理的基本单位，是一段程序在某一个数据集上面的一次运算，运行时，从磁盘中加载到内存。</p> 
<p>线程是系统调度的最小单位，是进程的一部分。</p> 
<p>区别：一个进程包括多个线程，线程是进程执行的每一一个小任务，进程切换时需要切换资源和内存，而线程切换时不需要切换资源和内存，只需要切换pc指针。</p> 
<h4><a id="3__31"></a>3 什么是死锁</h4> 
<p>死锁的定义：如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发事件，那么该组进程是死锁的。</p> 
<p>死锁的条件：<br> ①互斥条件②占有和等待条件③不剥夺条件④循环等待条件</p> 
<p>死锁的常见表现：</p> 
<p>（1）多进程死锁：有A，B两个进程，进程A拥有资源1，需要请求正在被进程B占有的资源2，而进程B拥有资源2，又在请求资源1，两个进程都在等待对方释放资源后请求该资源，而相互僵持，陷入死锁。</p> 
<p>（2）单线程死锁:进程A拥有进程1，而它又在请求资源1，而它所请求的资源1必须等待该资源使用完毕得到释放后才可被请求，这样，就陷入了自己的死锁。</p> 
<p>解决死锁的方法：</p> 
<p>①终止（或撤销）进程。终止系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态中解除出来。</p> 
<p>（2）抢占资源。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以打破死锁状态</p> 
<h4><a id="4__50"></a>4 内存管理有哪些方法</h4> 
<p>常见的内存管理方式有分区存储管理，页式管理，段式管理，虚拟存储管理</p> 
<p>连续存储管理，包括固定分区存储管理，非固定分区存储管理<br> 分页存储管理<br> 段式存储管理<br> 虚拟存储管理</p> 
<h4><a id="5__59"></a>5 操作系统提供给程序员创建进程的接口有哪些</h4> 
<p>系统调用fork()，vfork() ,clone()</p> 
<h4><a id="6__63"></a>6 进程调度算法有哪些？</h4> 
<p>先来先服务，短作业优先，高优先权优先（可以动态优先，高响应比优先，也可静态优先权），基于时间片轮转（基于时间片轮转调度算法RR，多级反馈队列算法FB），最短剩余时间优先。</p> 
<h4><a id="7__67"></a>7 中断嵌套是什么；</h4> 
<p>指新的优先级更高的中断会去中断CPU上正在运行的中断程序，并且在新的中断结束后，返回到被中断点处继续执行。</p> 
<h4><a id="8__71"></a>8 调度什么时候发生？</h4> 
<p>①当进程需要等待某个资源（比如I/O设备）时，主动请求调度让出CPU</p> 
<p>②当前的时间片用完时</p> 
<p>③当进程状态状态发生改变时：比如，进程终止，进程睡眠</p> 
<p>④进程从中断，异常及系统调用返回到用户态时。</p> 
<h4><a id="9__81"></a>9 操作系统的定义？</h4> 
<p>操作系统是管理计算机硬件与软件资源的计算机程序。</p> 
<p>它提供：内存和资源的分配，控制输入输出设备，操作网络和管理文件，提供人机交互界面</p> 
<h4><a id="10___87"></a>10 一个文件在磁盘上，如何访问到</h4> 
<p>缺页中断<br> 或者主动调用int 19H中断，将磁盘的数据读入到内存</p> 
<p>当程序执行的指令或访问到的数据在内存中时可顺利执行；如果在磁盘中，需要系统自动将这部分信息装入，这称“部分装入”；如此刻没有足够的空闲内存空间，便把内存中不用的信息暂时移到磁盘上，这称部分替换。所以只要“部分装入”和“部分替换能够实现”，实现从磁盘中读入数据，来让CPU执行。<br> 根据FCB汇集和组织形成的文件目录，文件目录将文件名称转化为磁盘中的存储位置，然后通过访问道磁盘中的数据就可以访问到了。</p> 
<h4><a id="11___95"></a>11 操作系统的知识结构，内容，包括哪些？</h4> 
<p>处理器管理，进程调度，存储管理，设备管理，文件管理</p> 
<h4><a id="12___99"></a>12 什么是进程，进程调度是调度谁，进程的工作状态</h4> 
<p>进程中程序关于一个操作数据集上的一次运行活动，同时，进程也是资源和内存分配的基本单位。</p> 
<p><strong>进程调度是调度谁</strong>：因为程序在CPU中是走走停停的，为了使CPU能够达到最大的使用效率，当某一个进程在运行过程中需要停止等待，比如说，需要等待I/O，而这时，访问外设的时候，时间就比较长，这时，该进程就会让出CPU的使用权，按照所规定的调度算法，选择在就绪队列的中的其中一个进程，将当前的CPU进程保存在PCB块中，以linux操作系统为例，就是调用shedul（）中的switch_to()进程切换进程。</p> 
<p><strong>进程的工作状态：</strong></p> 
<p>有两种，一种是比较简单的，由运行态，就绪态，和阻塞态</p> 
<p>另外一种是7种模式：有新建态，运行态，就绪态，和阻塞态，挂起就绪态和挂起阻塞态</p> 
<h4><a id="13__111"></a>13 为什么要有系统调用</h4> 
<p>在linux内核中，有实现系统功能的子程序。系统分为内核态和用户态，内核态实现系统功能，用户态实现应用程序，当用户态需要使用的系统资源时，比如访问I/O设备等，就需要系统调用，同时，设置内核态与用户态也是访止用户的态程序随意更改内核的数据。</p> 
<h4><a id="14__115"></a>14 说一下内存管理方式有哪些</h4> 
<p>连续分区管理，分页管理，分段管理，虚拟存储管理技术管理</p> 
<h4><a id="15__119"></a>15 请求分页页面置换算法列举？</h4> 
<p>LRU，LFU，FIFO 第二次机会替换算法 时钟算法 改进的时钟算法</p> 
<h4><a id="16__clock_123"></a>16 叙述clock置换算法</h4> 
<p>用循环队列构造页面队列</p> 
<p>初始化：每一个页设置一个引用位，页面被调入内存时引用位置为1，每一个页面被访问时内存引用位置为1<br> 进行淘汰时，从指针指向的页面开始扫描，遇到引用位为1的页面，讲引用位置0；遇到引用位为0的页面，淘汰该页面。</p> 
<p>若扫描循环队列，所有页面引用位均为1，则所有页面经过依次扫描引用位均置为0，指针也就回到开始扫描的地方，那下一次扫描一定有页面换出。</p> 
<p>改进的clock有两个位，一个修改位，一是引用位</p> 
<p>第一次扫描，找到未被修改且未被引用的的页，如果找了，就淘汰该页面<br> 第二次扫描，找到第一个未被修改，且被引用的页，如果找了，淘汰该页，并将扫描过引用位为1的页，将该位置0<br> 第三次扫描，一定可以找到一个淘汰页</p> 
<h4><a id="17__140"></a>17 虚拟存储的作用？为什么虚拟存储可以实现？</h4> 
<p>内存在计算机中的作用很大，电脑中所有运行的程序都要经过内存来执行，如果执行的程序很大或很多，就很导致内存消耗殆进。为了解决这个问题，拿出一部分硬盘空间来充当内存使用，当内存用完时，计算机就自动调用硬盘来当内存，以缓解内存的内存的紧张。</p> 
<p>为什么虚拟存储可以实现？</p> 
<p>操作系统可以痛过调用系统中断</p> 
<h4><a id="18__148"></a>18 多级存储系统的作用？</h4> 
<p>计算机系统中，运行越快的存储器件，价格越昂贵，寄存器的速度大于存储器，存储器存取速度远远大于磁盘，但是它们的存储容量是相反的，为了缓解储存容量，高速度，低成本之间的关系，在CPU与存储器之间加上cache，来解决cpu与主存储器之间的速度不匹配，在主存器与外存之间加一个TLB快表，使得计算看似扩展了更大的容量空间。</p> 
<h4><a id="19___152"></a>19 寄存器和存储器的区别</h4> 
<p>寄存器存储容量小，但是寄存器速度快</p> 
<p>存储器存储容量比寄存器大很多，但是存取时间长</p> 
<p>寄存器在CPU内，存储器一般只硬盘，U盘等，在CPU外，<br> 寄存器存储的是直接操作数据，存储器中放的是指令和数据</p> 
<h4><a id="20__161"></a>20 操作系统中用来表示内存已被占用的数据结构是什么</h4> 
<p>根据操作系统所使用的存储技术的不同，所使用的数据结构表也不不同？<br> 在固定分区存储管理中，内存分配表<br> 在可变分区存储管理中，使用已分配区表和未分配区表<br> 在分页存储管理中，使用内存物理块表用来记录页框的状态，管理内存物理块分布<br> 在段式存储管理中，使用段表管理</p> 
<h4><a id="21__171"></a>21 系统调用与普通调用的区别？</h4> 
<h2><a id="_175"></a>计算机组成原理</h2> 
<h4><a id="1__177"></a>1 单片机的引导过程</h4> 
<p>操作系统的系统的启动过程<br> 当Linux 0.11 操作系统进入实模式，并从地址0xFFFF0开始自动执行程序代码，物理地址为0处进行初始化中断向量，然后将第一个扇区读入到内存的7C00处，然后从7c00处开始执行。</p> 
<p>单片机的启动过程：<br> 单片机上电或者复位后，CS被置为FFFFH，IP被置为0000H，cpu就从内存的FFFF0H处取出第一条指令，开始执行。</p> 
<h4><a id="2_DMA_187"></a>2 DMA控制器是主设备还是从设备，什么时候做主设备</h4> 
<p>有的时候是主设备，有的时候是从设备，</p> 
<p>当CPU给DMA发送数据，字节数，此时他就是从设备。</p> 
<p>当DMA控制总线，让外设与存储器之间传输数据时，就是主设备。</p> 
<h4><a id="3_8259_195"></a>3 8259的中断过程</h4> 
<p>8259A有两种模式，一种是操作模式，一种是中断模式<br> 单片机可通过端口的方式，CPU可发送in，out指令控制发送给8259进入中断模式，8259便接收中断向量号，通过中断判优选择结构选择紧急程度最高的中断进行相应，通过int端口给CPU发送中断请求，CPU收到后响应中断，8259给CPU发送中断向量号，CPU收到中断向量后进行执行。</p> 
<h4><a id="4__200"></a>4 动态存储和静态存储的区别</h4> 
<p>静态存储：指在编译时对数据对象固定的存储位置，运行时始终不变。即一旦存储空间的某个位置分配给某个数据名，则目标程序在运行过程中该地址就属于该地址名</p> 
<p>由静态存储分配产生的数据区称为静态数据区</p> 
<p>静态存储分配适用于不允许递归过程或递归调用，不允许可变体积的数据结构语言</p> 
<p>静态存储分配的特点：简单，易于实现</p> 
<p>动态存储：</p> 
<p>指运行阶段源程序中的数据对象分配存储位置</p> 
<p>实行动态存储分配的语言特点</p> 
<p>允许递归过程</p> 
<p>允许可变数据结构</p> 
<p>允许用于自由申请内存以及释放</p> 
<h4><a id="5_CPU_222"></a>5 设计CPU思路</h4> 
<p>设计思路：</p> 
<p>要想设计CPU，就要设计一个的简易指令系统，在根据指令搭建对应的数据通路，在数据通路的基础上实现控制逻辑，下一步是加上流水线，划分流水线，紧接着解决流水线中冲突的问题，提高流水线的效率，最后解决CPU异常的问题。</p> 
<h4><a id="6__Cache___228"></a>6 关于高速缓存 Cache 的两种写 入方法是什么</h4> 
<p>什么是cache，cache内存与CPU之间很小的一个缓存，用于存放主存中最近经常使用得数据，用于缓解CPU于主存之间的速度，大大提高了CPU得运行效率。</p> 
<p>写回法：命中，直接修改cache内容，只有当此行被换出时才写回主存。没命中时，从内存中分配一块给 cache，对擦车进行写。</p> 
<p>全写法：当cache命中时，cache与主存同时发生修改，当cache没命中时，有两种方法，一是要访问的内存数据的那一块分配给cache后，cache和内存同时修改；或者只修改内存。</p> 
<p>写一次法：第一次使用全写法，后面都是用写回法</p> 
<h4><a id="7__238"></a>7 嵌入式系统和普通的系统区别在哪</h4> 
<p>区别1：类型</p> 
<p>普通系统：应该指实实在在的一般电脑安装的系统</p> 
<p>嵌入式操作系统：指“看不见”的操作系统，形式多样，应用领域广泛，按应用进行分类；</p> 
<p>区别2:组成</p> 
<p>通用：通用处理器，标准总线和外设，软硬件相对独立</p> 
<p>嵌入式：面向特定应用的微处理器，总线和外设一半集成在处理器内部，软硬件紧密结合，具有很强的专用性，必须结合实际系统进行合理的裁剪利用；</p> 
<h4><a id="8__252"></a>8 嵌入式系统用什么语言写，什么是嵌入式</h4> 
<p>C/C++，可以控制，可以操作或辅助操作机器和设备装置，是一种专用计算机<br> 汇编语言</p> 
<h4><a id="9___257"></a>9 单片机为啥叫单片机</h4> 
<p>将运算器，存储器，控制器，输入输出，集成到一块硅芯片中，该芯片具有完整的基本计算机的功能，所以称为单片微型计算机，简称单片机</p> 
<h4><a id="10_CPU_261"></a>10 外部中断CPU该如何处理</h4> 
<p>CPU从外部中断源接收到中断后，CPU在满足中断的条件下，发送中断响应，并关中断不再响应其他中断。CPU寻找中断源是哪个设备，找到后，保存当前CPU的状态，以及各种寄存器的状态，将PC转移到中断处理程序的地址，完成中断处理程序之后，恢复现场，打开中断，继续开始的中断点执行。</p> 
<h2><a id="_265"></a>计算机网络</h2> 
<h4><a id="1__267"></a>1 一个访问网络的过程</h4> 
<p>当在网站上输入了地址后，浏览器便会向本地域名服务器请求解析，若本地域名服务器没有，则本地域名服务器以客户的方式向根域名服务器发送请求报文解析请求，根域名判断在DNS.abc的域，将权限域名服务器的地址发送给本地域名服务器，本地域名器向权限域名服务器发送连接请求，权限域名服务器找到后，将域名的IP地址发送给本地域名服务器，本地域名服务器收到后，保存下来，并将IP发送给主机，主机便于IP地址所在的从机建立TCP连接请求，经过三次握手，主机便下载到了html，并以图形化的方式呈现给用户一个界面</p> 
<h4><a id="2_DHCP_271"></a>2 DHCP协议的作用</h4> 
<p>DHCP(动态主机配置协议)作用：动态分配IP</p> 
<p>从我的理解：</p> 
<p>首先客户端问附近的服务器有ip地址码</p> 
<p>服务器回答，说有啊，服务端就发一一个ip过去</p> 
<p>客户端就申请使用这个ip</p> 
<p>服务端就确认</p> 
<p>简单介绍下DHCP</p> 
<p>A 客户端要IP，发送第一个报文discover</p> 
<p>B 发送一个offer回应它，可以提供IP</p> 
<p>A 就发送一个request请求报文</p> 
<p>B 服务器收到后，如果可以，就发送一个ACK确认</p> 
<h4><a id="3_OSI_295"></a>3 网络OSI的七层结构</h4> 
<p>物联网，链路层，网络层，运输层，会话层，表示层，应用层</p> 
<h4><a id="5_rarp_299"></a>5 rarp的作用，相对应的协议是什么，地址解析的过程。</h4> 
<p>RARP通过发送反向解析的MAC地址，其他RARP服务器接收到后，在一张映射表中查询，若有，返回的数据中包含了该设备的所需的IP地址，</p> 
<p>相对应的协议是arp；</p> 
<p>地址解析过程：</p> 
<p>当主机A打算给主机B发送IP数据报时，A在缓存区中查看是否有无主机B的IP地址，如有，直接查出其对应的硬件地址，将该硬件地址写入MAC帧，如果没有，就使用目的MAC地址为FF-FF-FF-FF-FF的帧来广播ARP请求，可以使同一个局域网的所有主机收到ARP请求，当B主机收到后，就给A发送响应分组，分组中就包含了该IP地址与MAC地址的映射关系。</p> 
<h4><a id="5_TCPUDPIP_309"></a>5 发微信用的是TCP还是UDP，为什么，所需的IP地址。</h4> 
<p>看发送的文件，当发送一些聊天文字的时候，数据比较小，采用哦个UDP报文传输，当发送一些几十兆几百兆的视频，由于数据比较大，一个报文放不下，所以需要使用TCP传输</p> 
<h4><a id="6__313"></a>6 路由器和交换机的功能然后他们的区别</h4> 
<p>路由器用于大型网络之间的互联，路由转发，拥塞控制等</p> 
<p>交换机用于局域网内部之间的互联。</p> 
<p>区别：</p> 
<p>路由器可以隔离冲突域，也可以隔离广播域</p> 
<p>交换机可以隔离冲突域，不可隔离广播域</p> 
<p>路由器是网络层设备</p> 
<p>交换机是数据链路层设备</p> 
<h4><a id="7_TCP_329"></a>7 TCP拥塞的解决方式，分别解释一下</h4> 
<p>慢启动：当新建TCP连接时，拥塞窗口CWND初始化为1，表示一个数据包大小，源端按cwnd发送数据，每收到一个ACK确认，cwnd窗口数就+1，在一个RTT时间内，CWND就会增加一倍，即CWND随着RTT呈指数增长。</p> 
<p>拥塞避免：当cwnd达到ssthresh时，在此阶段，发送方每接收一个ACK确认，CWND就增加1，CWND就会随着RTT呈现线性增长</p> 
<p>当出现由超时指示丢包时，拥塞窗口变为1，开始慢启动过程。这样就可以迅速减少主机发送到网络中的分组数。</p> 
<p>快重传和快恢复：当收到3个以上的重复ACK确认时，说明有可能有数据报丢失，于是需要立刻重传该丢失的数据包，这就是快重传。更新当前的ssthresh为当前CWND的1/2，然后将CWND变为原来的1/2，开始拥塞避免阶段，即随着RTT呈线性增长，这个过程就是快速恢复阶段。</p> 
<h4><a id="8_TCP_339"></a>8 TCP为什么三次握手</h4> 
<p>为什么三次握手而不是两次握手，这是为了解决已失效的建立报又发送到了服务端。如果采用两次握手，试想一下出现这样一种情况，客户端向服务器第一次发送数据，由于网络原因，这个数据包走了一条比较长的链路，客户端对该数据包的时间到时，就重新发送一个建立请求报文，此时网络又好了，于是服务端接收到了第二次建立连接请求的报文，于是服务段发送确认，并反向发送连接请求，客户端再发送一个确认，此时建立连接之后，双方互相发送信息，再通过四次挥手，断开连接，此时第一次走了好远的数据报文，又到了服务端，服务段以为客户端又要建立连接，于是就打开了连接，便发向确认，而客户端自己又没发送请求建立连接，所以客户端就把这个确认丢掉，但是此时服务端打开了连接，一直在等待客户端发送数据过来，这也就服务端的资源，而网上的主机很多，这样就造成了很多不必要的浪费。</p> 
<h4><a id="9_TCP_343"></a>9 用自己的话讲TCP连接到底是什么</h4> 
<p>TCP：传输控制协议，就是为了保证互联网通信的双方能够可靠传输，所以TCP协议就制定了可靠的传输协议，想慢开始，快回复，拥塞控制，快重传</p> 
<h2><a id="_347"></a>数据结构</h2> 
<h4><a id="1___349"></a>1 描述一下你学过的排序算法</h4> 
<p><strong>插入排序</strong></p> 
<p>①：直接插入，折半插入，希尔排序</p> 
<p>②基于交换的有<br> 冒泡排序和快速排序</p> 
<p>③基于选择的有<br> 简单选择排序和堆排序<br> 基数排序和归并排序</p> 
<p>冒泡排序 ：一个循环，从前到后比较，当后面的一个值比前面的值小，交换，再循环循环上面的过程直到数据有序。</p> 
<p>快速排序：设两个指针，i，j分别指向待排序的数据的两头，左边不动，右边指针左移找到一个比左边指针小的值交换，左边指针移动，找到一个比右边指针大的值交换，直到i&gt;停止。</p> 
<p>选择排序：假设待排序的数据是L[1…n],第i次从L[i…n]中选取最小或者最大的值与L[i]交换，直到所有数据有序</p> 
<p>堆排序：先更具堆的要求，建立大根堆或者小根堆，拿小根堆为例，对建立好的初始堆排序，每次将堆中最后一个元素与第一个元素交换，再进行一次堆调整，接着，把倒数第二个与一个元素交换，重复，直到堆满足小根堆和大根堆定义</p> 
<p>基数排序</p> 
<p>把数据根据相同的各位收集在一起，对每组收集的数据进行插入排序，最后对所有数据进行插入排序</p> 
<p>归并排序：设排序有n个数，把所有待排序的数据，两两和并，得到n/2个长度为二或者1的有序表，重复，直到得到长度为n的序表为止。</p> 
<h4><a id="2__376"></a>2 数据结构的顺序结构有哪些</h4> 
<p>顺序表，队列和栈</p> 
<h4><a id="3__380"></a>3 给一个链表，如何确定这个链表有环？</h4> 
<p>遍历这个链表，将访问过的节点标记已访问，如果继续遍历到已访问过的结点时，则有环，否则，当遍历结束时即遍历到空时，说明该链表无环。</p> 
<h4><a id="4__384"></a>4 数据结构如何使链表逆置</h4> 
<p>只需要遍历一个链表，使用头插法插入到表中</p> 
<h4><a id="5__388"></a>5 你能描述一下数据结构具体有哪几种吗？</h4> 
<p>线性表：</p> 
<p>顺序存储—顺序表</p> 
<p>链式存储 —链表</p> 
<p>栈，和队列</p> 
<p>树</p> 
<p>二叉树，平衡二叉树，haffuman树，完全二叉树，</p> 
<p>图</p> 
<p>深度优先遍历，广度优先遍历</p> 
<h4><a id="6____406"></a>6 佛洛依德算法 迪杰斯特拉算法</h4> 
<p>佛洛依德算法：</p> 
<p>计算多源点间的最短路径</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         令 
        
       
         g 
        
       
         [ 
        
       
         u 
        
       
         ] 
        
       
         [ 
        
       
         v 
        
       
         ] 
        
       
         表 
        
       
         示 
        
       
         u 
        
       
         到 
        
       
         v 
        
       
         的 
        
       
         距 
        
       
         离 
        
       
         ， 
        
       
         找 
        
       
         到 
        
       
         一 
        
       
         个 
        
       
         k 
        
       
         点 
        
       
         ， 
        
       
         使 
        
       
         g 
        
       
         [ 
        
       
         u 
        
       
         ] 
        
       
         [ 
        
       
         v 
        
       
         ] 
        
       
         &gt; 
        
       
         g 
        
       
         [ 
        
       
         u 
        
       
         ] 
        
       
         [ 
        
       
         k 
        
       
         ] 
        
       
         + 
        
       
         g 
        
       
         [ 
        
       
         k 
        
       
         ] 
        
       
         [ 
        
       
         v 
        
       
         ] 
        
       
         , 
        
       
         则 
        
       
         g 
        
       
         [ 
        
       
         u 
        
       
         ] 
        
       
         [ 
        
       
         v 
        
       
         ] 
        
       
         = 
        
       
         g 
        
       
         [ 
        
       
         u 
        
       
         ] 
        
       
         [ 
        
       
         k 
        
       
         ] 
        
       
         + 
        
       
         g 
        
       
         [ 
        
       
         k 
        
       
         ] 
        
       
         [ 
        
       
         v 
        
       
         ] 
        
       
      
        令 g[u][v]表示 u到v的距离，找到一个k点，使g[u][v]&gt;g[u][k]+g[k][v],则g[u][v]=g[u][k]+g[k][v] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord cjk_fallback">令</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">]</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord mathdefault">u</span><span class="mord cjk_fallback">到</span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">距</span><span class="mord cjk_fallback">离</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">找</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">使</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord cjk_fallback">则</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">]</span></span></span></span></span></p> 
<p>重复该步直至所有结点均已遍历</p> 
<p>迪杰斯特拉算法：求源点到其他结点的最短路径</p> 
<p>先初始化d[i],d[i]为源点A到其他结点的权值，不直接相连为无穷大</p> 
<p>计算，.</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         如 
        
       
         果 
        
       
         找 
        
       
         到 
        
       
         一 
        
       
         点 
        
       
         k 
        
       
         ， 
        
       
         使 
        
       
         得 
        
       
         d 
        
       
         [ 
        
       
         i 
        
       
         ] 
        
       
         &gt; 
        
       
         [ 
        
       
         0 
        
       
         ] 
        
       
         [ 
        
       
         k 
        
       
         ] 
        
       
         + 
        
       
         d 
        
       
         [ 
        
       
         k 
        
       
         ] 
        
       
         [ 
        
       
         i 
        
       
         ] 
        
       
         , 
        
       
         则 
        
       
         将 
        
       
         d 
        
       
         [ 
        
       
         i 
        
       
         ] 
        
       
         = 
        
       
         d 
        
       
         [ 
        
       
         0 
        
       
         ] 
        
       
         [ 
        
       
         k 
        
       
         ] 
        
       
         + 
        
       
         [ 
        
       
         k 
        
       
         ] 
        
       
         [ 
        
       
         i 
        
       
         ] 
        
       
         , 
        
       
         每 
        
       
         找 
        
       
         到 
        
       
         一 
        
       
         个 
        
       
         k 
        
       
         ， 
        
       
         就 
        
       
         放 
        
       
         入 
        
       
         集 
        
       
         合 
        
       
         中 
        
       
         ， 
        
       
         重 
        
       
         复 
        
       
         以 
        
       
         上 
        
       
         步 
        
       
         骤 
        
       
         ， 
        
       
         直 
        
       
         到 
        
       
         所 
        
       
         有 
        
       
         结 
        
       
         点 
        
       
         均 
        
       
         在 
        
       
         集 
        
       
         合 
        
       
         S 
        
       
         中 
        
       
      
        如果找到一点k，使得d[i]&gt;[0][k]+d[k][i],则将d[i] = d[0][k]+[k][i] ,每找到一个k，就放入集合中，重复以上步骤，直到所有结点均在集合S中 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">找</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">点</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">得</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">将</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord cjk_fallback">每</span><span class="mord cjk_fallback">找</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">放</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">复</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">步</span><span class="mord cjk_fallback">骤</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">均</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">合</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mord cjk_fallback">中</span></span></span></span></span></p> 
<h2><a id="_425"></a>数字电路</h2> 
<h4><a id="_429"></a>数字逻辑主要学了哪些东西</h4> 
<p>**BCD编码：**用4位二进制数来表示1位十进制数中的0~9这10个码数，用二进制编码的10进制编码。</p> 
<p>**反演规则：**与变非，非变与，原变量变反变量，1/0互换</p> 
<p>**对偶规则：**与变非，1/0互换</p> 
<p>**什么是最小项？**与或表达式</p> 
<p>n个变量X<sub>1</sub>，X<sub>2</sub>…X<sub>n</sub>，每个变量都以它得原变量或非变量得形式在乘积项中出现，且出现一次。</p> 
<p>**什么是最大项？**或与表达式</p> 
<p>n个变量X<sub>1</sub>，X<sub>2</sub>…X<sub>n</sub>，每个变量都以它得原变量或非变量得形式在和//项中出现，且出现一次。</p> 
<p>**两个的关系：**最小项对应最大项取反</p> 
<p>卡诺图：是与变量的<strong>最小项</strong>对应的按一定规则的方格图，，每一个方格对应一个最小项的有或无</p> 
<p>逻辑门电路 与 或 非 异或和同或</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kzRjwhW3-1589637931309)(C:\Users\Mr. chen\AppData\Roaming\Typora\typora-user-images\image-20200304125810990.png)]</p> 
<p>MOS管：的开关特性相当于一个由UGS控制的无触点开关。</p> 
<p>逻辑代数</p> 
<p>组合逻辑电路</p> 
<p>触发器</p> 
<p>时序逻辑电路</p> 
<p>脉冲波形的产生与变换</p> 
<p>数模与模数转换</p> 
<p>半导体存储器</p> 
<p>数字逻辑基础，组合逻辑电路，常用组合逻辑功能器件，时序逻辑电路</p> 
<p>触发器</p> 
<h4><a id="6__473"></a>6 组合逻辑电路和时序逻辑电路区别（电路图的区别和性能特性的区别）</h4> 
<p>组合逻辑电路：任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关</p> 
<p>时序电路具有记忆功能，时序电路的特点是：输出不仅取决于当时的输入值，而且还与电路过去的状态有关。</p> 
<p>电路图上时序逻辑电路多了一个存储器件。</p> 
<h4><a id="7__481"></a>7 大信号和小信号的区别</h4> 
<p>大信号和小信号是根据放大器动态范围来说的信号分类。</p> 
<p>大信号体现的特性是直流的静态工作点，其直流阻抗就是V/I = b/a</p> 
<p>小信号体现的是静态工作点的斜率，可以成△V/△I</p> 
<p>静态工作点：指的是输入信号为零时，电路处于直流，电压的数值在三极管特性曲线上表示<br> 为一个确定的点</p> 
<h4><a id="8__492"></a>8 模电分析方法应该先分析交流还是直流，为什么，怎么进行分析</h4> 
<p>遵循先直流，后交流的原则，直流是基础，交流是目的，只有静态工作点Q合适，保证方法信号不失真，进行交流分析才有意义。</p> 
<p>静态工作点Q的作用：</p> 
<p>①确定放大电压和电流的静态值</p> 
<p>②选取合适的静态工作点可以防止电路产生非线性失真</p> 
<h2><a id="C_504"></a>C语言：</h2> 
<h4><a id="1__506"></a>1 数据结构中线性表有哪些？</h4> 
<p>线性表，栈，队列</p> 
<h4><a id="2__510"></a>2 还有快排和冒泡的原理自己他们的空间复杂度是多少</h4> 
<p>快排㏒<sub>2</sub>n，冒泡 O(1)</p> 
<h2><a id="C_514"></a>C++方面：</h2> 
<h4><a id="1__516"></a>1 几种方法写阶乘；</h4> 
<p>3种，static，递归，循环</p> 
<h4><a id="2_intcharintcharLinux_520"></a>2 定义一个结构体，里面一个int类型成员，一个char，int占四位，char占一位，那么在Linux占几位</h4> 
<p>8个字节，char 定义了一个字节后，再定义一个int 类型，int的为4个字节，要存储再4的倍数的存储单元种，所以编号为1，2，3的字节要填充，int定义的从4开始。</p> 
<h4><a id="3__1_526"></a>3 请设计算法统计一个二进制数中1的个数</h4> 
<p>两种方法：</p> 
<p>第一种是：设置一个变量count，将二进制放入string变量中，遍历string变量的每一个字符，当这个字符等于1是，conut++</p> 
<p>第二种方法是：C++中有一个bitset，直接用bitset定义的二进制变量调用count就可以得出1的个数</p> 
<h4><a id="4__534"></a>4 递归的含义，递归能不能替代循环，递归需要做什么？</h4> 
<p>递归其实就是一个函数直接调用或间接调用自己过程。</p> 
<p>递归可以替代循环，递归需要压栈，存放下一条指令的地址以及函数的参数</p> 
<p>递归可以改写成循环，有些递归只需要一个循环就可以实现，有些递归需要循环+栈，需要辅助空间记录过程中的，某些数据才可以。</p> 
<h4><a id="5___542"></a>5 堆栈需要用的什么</h4> 
<p>bp，ss</p> 
<h4><a id="6_printf_546"></a>6 printf函数在汇编中怎么实现</h4> 
<p>在汇编中，先把printf的参数，从右往左压入栈中，再根据栈中，格式，计算对应格式所占的空间，再调用system_call ，来实现输出</p> 
<h4><a id="7_printf_550"></a>7 printf函数的参数格式，长度等等</h4> 
<p>%d %i %u %f %ld %lf c%G c %X %x %s</p> 
<h4><a id="8__554"></a>8 描述斐波那契序列算法和</h4> 
<p>算法①：</p> 
<p>使用递归，当n&lt;=1返回n</p> 
<p>当n&gt;=2时 f(n) = f(n-1)+f(n-2)</p> 
<p>调用f(n)</p> 
<p>if n==1 return faci(1);</p> 
<p>​ else f(n) = f(n-1)+f(n-2)</p> 
<p>算法②：</p> 
<p>使用迭代的方法：</p> 
<p>循环 1 到 n</p> 
<p>{<!-- --><br> 当前值 = f(i-1) + fi;</p> 
<p>f(i-1) = fi;</p> 
<p>f(i) = 当前值；<br> }</p> 
<h4><a id="9__584"></a>9 汉诺塔算法</h4> 
<p>算法：有三个柱子ABC，n个盘子在A柱子上</p> 
<p>将A上面n-1个盘子借助于C，移动到B，</p> 
<p>将A上最下面的一个盘子移动到C</p> 
<p>再将B上的n-1个盘子借助于A移动到C（此时问题的规模就变小了，但还是同样的问题规模）</p> 
<h4><a id="10_C_594"></a>10 C语言中你习惯定义全局变量还是局部变量</h4> 
<p>一般的话，为了方便管理，我会尽量为了模块编程，尽量使各个模块低耦合，定义局部变量使用</p> 
<p>如果实在是</p> 
<h4><a id="11__600"></a>11 编译的过程是什么</h4> 
<p>词法分析， 语法分析， 语义分析及中间代码生成，优化，目标代码生成</p> 
<h4><a id="12__604"></a>12 专业学了啥</h4> 
<p>编程语言学了：C，C++，java，php，C#</p> 
<p>计算机基础课学了：数据结构，操作系统，数据库，计算机组成原理，数据库，计算机网络</p> 
<p>应用型课程学了web前端，web服务端，andriod开发，linux 0.11内核注释</p> 
<p>硬件学了一点：数字逻辑，模拟电路与电子设计，单片机</p> 
<p>自己看过嵌入式系统原理，传感网原理与技术，proteus，DXP，</p> 
<h4><a id="13__618"></a>13 嵌入式课程教了啥</h4> 
<p>大学没有嵌入式课程</p> 
<p>但是自己看过相关的书，什么是嵌入式，家里的冰箱，微波炉点，计算机系统嵌入</p> 
<h4><a id="14__624"></a>14 斐波那契递归和迭代区别是啥</h4> 
<p>递归：自己调用自己，迭代：反复替换</p> 
<p>递归和迭代都是有重复，只是重复的不同，迭代显式使用重复结构，而递归通过重复调用函数实现。</p> 
<p>递归与迭代都是基于控制结构：迭代用重复结构，而递归用选择结构</p> 
<p>递归在遇到基本情况停止，迭代在循环条件失效时停止</p> 
<p>时间复杂度，用递归来求，时间复杂度O（2<sup>n</sup>）,迭代时间复杂度O（n）</p> 
<h4><a id="15__636"></a>15 递归的定义及优缺点</h4> 
<h4><a id="16__C__3_638"></a>16 C 语言的 3个基本结构是啥</h4> 
<p>选择结构，循环结构，顺序结构,</p> 
<h4><a id="17___642"></a>17 全局变量和局部变量分别存储在哪里</h4> 
<p>堆，栈，自由存储区，静态/全局变量存储区，常量存储区</p> 
<h4><a id="18__646"></a>18 数组和指针的区别是什么</h4> 
<p>很多区别：</p> 
<p>声明一个数组，编译器将根据数组的大小为他分配内存空间</p> 
<p>声明一个指针，编译器只为指针本身保存内存空间</p> 
<p>另一方面：如果声明一个数组int a[]; 和声明一个指针 int *b;</p> 
<p>表达式b++可通过编译，而a++无法通过编译，因为a是一个常量。</p> 
<h4><a id="19_c_658"></a>19 c++的继承方式</h4> 
<p>三种继承方式：</p> 
<p>public：父类成员在子类中均可使用</p> 
<p>protected：父类的公有成员变为保护成员，其他成员保持不变</p> 
<p>private：父类所有成员在子类中变为私有成员</p> 
<h4><a id="20_CC_669"></a>20 .请简述C，C++语言有何区别和联系</h4> 
<p>C先出现，C++是在C上扩充，C是C++的子集，C++是C的超集</p> 
<p>C是面向过程，C++是面向对象</p> 
<p>C++在C的基础上，增加了很多关键字，比如bool ，const，protected等等</p> 
<p>malloc和free替换成了new和delete</p> 
<p>C不支持相同参数个数的重载，而c++中支持相同参数个数的重载。</p> 
<h4><a id="21__682"></a>21 .简述面向对象有哪些好处</h4> 
<p>优点：易于维护，复用，扩展，由于，面向对象有封装，继承，多态的特性，可以设计出低耦合的系统，使系统易于维护，更加灵活。</p> 
<p>缺点：性能比比面向过程低</p> 
<h4><a id="22___688"></a>22 .简述类和对象</h4> 
<p>对象是对客观事物的抽象，类是对对象的抽象，类是一种抽象的数据类型。</p> 
<p>它们的关系是，对象是类的实例，类是对象</p> 
<h4><a id="23__694"></a>23 .什么是重载</h4> 
<p>重载：就是函数或者方法有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或方法。</p> 
<p>重载的作用：</p> 
<p>不用为了对不同的参数类型或参数个数，而写多个函数。多个函数用同一个名字，但参数列表，即参数的个数或数据类型可以不同，调用的时候，虽然方法名字相同，但是可以根据参数自动调用相应的函数</p> 
<h4><a id="24_Cfriend_702"></a>24 .C++里什么是friend?</h4> 
<p>用friend可以声明一个友元函数或者友元类，通过友元函数或或者友元类可以访问一个分装了类中的成员，尽管，friend破坏了类的封装性，但是为了数据共享，提高程序的效率和可读性，这种破坏也是很有必要的。</p> 
<h4><a id="25__Javac_706"></a>25 Java和c++的异同</h4> 
<p>相同点：都是面向对象的思想，都有封装，继承，多态等特性</p> 
<p>不同点：<br> 1.java为解释性语言，程序源代码经过java编译器编译成字节码，然后又JVM解释成机器指令，然后执行。<br> C/C++为编译性语言，源代码经过编译，汇编，链接后生成可执行的二进制代码，可直接执行。<br> 因此java的执行速度比C/C++慢，但java能够跨平台执行，C/C++不同。</p> 
<p>2 . java是纯面向对象语言，除了基本数据类型外，其他类型都是类，而C++兼容面向对象和面对过程，可以定义全局变量和全局函数，而java没有</p> 
<p>3.java不支持C++中的多继承，但java引入了接口的概念。</p> 
<p>4 java不支持运算符重载，而C++语言支持运算符重载。</p> 
<p>5 .java中没有指针的概念，C++有指针的概念</p> 
<h4><a id="26_Javac_723"></a>26 Java与c++的类、继承有什么相同和不同</h4> 
<p>重载：C++提供了运算符重载，而java并不提供</p> 
<p>继承：C++支持多重继承，这是C++的一个特征，他允许多父类派生一个类。java只能单继承，但是java通过可以实现多接口，来变相实现了多继承。</p> 
<h4><a id="27___729"></a>27 面向对象中什么封装，多态，继承</h4> 
<p>封装：隐藏对象属性和实现的细节，仅对外公开接口，控制在程序中属性得读和修改得访问级别，将抽象得到的数据和行为相结合形成一个有机得整体类</p> 
<p>多态：用同一相同的指令调用不同的方法，这样的称之为多态，需要使用到virtual关键字，使得虚函数在运行时动态绑定。</p> 
<p>继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法，对象的一个新类可以从现有的类中派生，这个过程称为类的继承。新类称为原始类的派生类，而原始类称为新类的基类或者父类。</p> 
<h2><a id="_737"></a>数据库</h2> 
<h4><a id="1__739"></a>1 数据库有几种锁</h4> 
<p>加锁是实现数据库并发控制的一个非常重要的技术。</p> 
<p>为什么要上锁？</p> 
<p>当事务在对某个数据对象进行操作前，先向系统发出请求，对其进行加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其它的事务就不能对此数据对象进行更新操作。</p> 
<p>数据库中有两种类型的锁：</p> 
<p>排它锁和共享锁。</p> 
<p>共享锁的数据对象可以被其他事务读取，但不能修改</p> 
<p>排它锁：其他的事务不能对它读取和修改。</p> 
<h4><a id="2__755"></a>2 数据库的事务</h4> 
<p>什么是数据库事务？<br> 数据库是指操作多个数据项的一组数据库操作序列，这组序列要么全部执行，要么全部失败，是一个不可分割的工作单位。</p> 
<p>有四个特性：ACID</p> 
<p>a：原子性</p> 
<p>c：一致性</p> 
<p>i：隔离性</p> 
<p>d：持久性</p> 
<h4><a id="3__770"></a>3 常用的数据库有哪些？</h4> 
<p>MySql，SQL server，Ocacle，，Access，redis，HBase</p> 
<h4><a id="4___774"></a>4 数据库的主码外码?</h4> 
<p>主码和外码是用来实现参照完整性的，外码的数据项需要参照主码的数据项来操作，具体实现是创建数据库中时表间创建关系</p> 
<p>1.参照关系比如学生表的学号时学生表的主键，是成绩表的外键，成绩表的学号参照学生表的学号录入的，也就是，如果学生表没有的学号，成绩表是无法录入的</p> 
<p>2.级联操作，当删除主表里面的学号时，从表里面的那个学号会响应的自动删除，修改。外码参照主码修改</p> 
<h4><a id="5__782"></a>5 数据库范式的定义以及区别</h4> 
<p>第一范式：表中的每一个属性都是一个原子，不可再分。</p> 
<p>第二范式：（无重复的行）在满足第一范式的基础上，每一个元组必须可以被唯一地区分，非主属性完全依赖于主键</p> 
<p>第三范式：在满足第二范式的基础上 ，要求一个数据库表中不包含已在其他表中亦包含的非主关键字信息，不能存在非关键字字段对一候选关键字段的传递函数依赖。</p> 
<p>非主属性不存在传递依赖于码和不存在部分依赖于码。</p> 
<p>（巴斯范式）：在第三范式的基础上，数据库表中如果<strong>不存在任何字段对任一候选关键字段的传递函数依赖</strong>。不存在任何字段对任意候选字段传递函数依赖</p> 
<h2><a id="_794"></a>离散数学</h2> 
<h4><a id="1___796"></a>1 用离散数学解释下主成分分析是啥</h4> 
<p>主程序程序分析（PCA）是一种降维方法，通常用于通过将数量很多的变量转化为仍包含集合中大部分信息的较少变量来降低数据集的维度。</p> 
<h4><a id="2__800"></a>2 离散数学关于群的定义</h4> 
<p>对于&lt;G,*&gt;</p> 
<p>若G关于*封闭</p> 
<p>G上运算*结合律</p> 
<p>G关于*存在么元e</p> 
<p>如果对任意a属于群，a*b等于e，b属于群</p> 
<p>则称代数系统&lt;G，*&gt;为群</p> 
<h2><a id="_815"></a>其他</h2> 
<h4><a id="2___817"></a>2 一个方形桌子砍一刀后有几个角？</h4> 
<p>还有5个角</p> 
<h4><a id="3__821"></a>3 解释机器学习</h4> 
<p>机器学习其实是一个程序，只是这个程序可以根据输入的数据不断进化，然后通过获得经验来处理未曾见过的数据</p> 
<h4><a id="4109_825"></a>4一个逻辑问题，10框苹果，有9框每个半斤重，有一筐每个四两，如何通过只称重一次，找出那个不一样的</h4> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ( 
         
        
          55 
         
        
          ∗ 
         
        
          5 
         
        
          − 
         
        
          m 
         
        
          ) 
         
        
          = 
         
        
          45 
         
        
          ∗ 
         
        
          5 
         
        
          + 
         
        
          4 
         
        
          ∗ 
         
        
          10 
         
        
       
         (55*5-m)=45*5 + 4*10 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mord">5</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span><span class="mord">5</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></span></span></p> 
<p>等式左边是若10篮子是5两的总质量（单位：两）-多计算的两数 = 称重的总两数</p> 
<p>什么是均值？**</p> 
<p>是平均数？一组数据之和除以该数的个数</p> 
<h4><a id="7__837"></a>7 讲下你的毕设</h4> 
<h4><a id="10__840"></a>10 学校，专业是啥，专业多少人，排名多少</h4> 
<h4><a id="11___842"></a>11 特征值是啥</h4> 
<p>如果一个矩阵乘以一个向量 = 一个值乘以该向量，则称该值为该矩阵的特征值</p> 
<h4><a id="14__847"></a>14 做过什么项目问了</h4> 
<h4><a id="15__849"></a>15 队列和链表相比的缺点</h4> 
<h4><a id="16__851"></a>16 你最喜欢的专业课是什么？</h4> 
<p>​ 计算机网络和C++</p> 
<h4><a id="17_sin_01_855"></a>17 怎么求sin 0.1</h4> 
<p>用泰勒公式，把sin的展开式写出来，可以通过编程来计算</p> 
<h4><a id="18__859"></a>18 你学过这个专业相关得专业课有哪些**</h4> 
<p>计算机组成原理，单片机</p> 
<h4><a id="19__863"></a>19 相比于门外等着的人，你觉得你的优势是什么（英语）**</h4> 
<p>Frist ，my major is computer and science，so I have some koneledge about my major</p> 
<p>second，I choose the major because I have intense interest，I ever get access it</p> 
<p>the</p> 
<h4><a id="20__871"></a>20 为什么选择这个方向</h4> 
<p>前沿技术</p> 
<h4><a id="21__876"></a>21 极大似然函数的作用:</h4> 
<p>可以根据极大似然函数可以求得极大似然估计值，即用已知的总体和样本结果，反求样本最有可能发生的概率。</p> 
<h4><a id="22__880"></a>22 一个箱子，放了一个白球，一个黑球，每次取一个便放回去，问至少有一次是白球的概率是多少；</h4> 
<p>1-2<sup>-n</sup></p> 
<h4><a id="23___k_884"></a>23 双聚类 启发式搜索 k均值聚类</h4> 
<p><strong>双聚类算法：</strong></p> 
<p>光谱联合聚类：</p> 
<p>在矩阵中，找到的值高于其它行和列中的值，每行和每列只属于一个双聚类，因此重新排列行和列中的这些高值，使这些分区沿着矩阵对角线连续显示。</p> 
<p><strong>启发式搜索：</strong></p> 
<p>利用当前与问题有关的信息作为启发式信息，这些信息是能够提升查找效率以及减少查找次数的。</p> 
<p>如何利用这些信息？</p> 
<p>定义一个估价函数h（x）。h(x)是对当前状态x的一个估计，表示x状态到目标状态的距离。</p> 
<p>1.h(x)&gt;=0</p> 
<p>2.h(x)越小表示越接近目标状态；</p> 
<p>3.如果h(x) == 0，说明达到目标状态</p> 
<p><strong>k均值聚类：</strong></p> 
<p>K均值聚类算法:是一种迭代求解的聚类分析算法，其步骤是，欲将数据分为k组，则随机选取K个对象作为初始聚类的中心，然后计算每个对象与各个种子聚类中心之间的距离，把每个对象分配给距离它最近的聚类中心。重复以上步骤，直到</p> 
<p>①没有对象被重新分配给不同的聚类</p> 
<p>②没有聚类中心在发生变化</p> 
<p>③误差平方和局部最小</p> 
<h4><a id="24_____916"></a>24 学过哪些前沿课程 课程内容是什么 人工智能是什么</h4> 
<p>大数据：是指数据的获取，分析，管理，计算超出了当前数据库软件工具的处理能力范围的一种数据集合。</p> 
<p>特点：大，多样，有效度密度低，高速，真实性</p> 
<p>初级阶段有：分布式计算技术，HADOOP，分布式存储技术原理，MAPREDUCE</p> 
<p>hadoop就是一种分布式计算的解决方案</p> 
<p>比如说从1TB或者1PB的数据中寻找关键词，通常可能要消耗几天，但是使用hadoop只需要几个小时，hadoop将数据发送到sou各个HDFS（分布式文件系统中），各个分布式文件处理后，再返回，这就大大缩小了搜索时间。</p> 
<p>内容是什么？</p> 
<h4><a id="25___930"></a>25 数据挖掘有什么应用</h4> 
<p><strong>什么是数据挖掘？</strong></p> 
<p>数据挖掘就是从海量的信息中利用有效的算法提去需要的信息。</p> 
<p>应用：就我们生活中熟知的网上购物，用户可以根据以往其他用户大量评价，来计算机决定该物品是否值得购买~</p> 
<h4><a id="27__938"></a>27 机器人的定义是啥</h4> 
<p>自动执行工作的机器装置，或者可以运行预先编写的程序的机器。能够代替人类的工作，比如基本家务，或者高空作业，高危作业等。</p> 
<h4><a id="28_942"></a>28人工智能是啥</h4> 
<p>人工智能研究，模拟，延伸人的技术，方法，理论的一门技术科学。</p> 
<h4><a id="29__946"></a>29 人工智能的避障算法是啥</h4> 
<p>比较热门的有：遗传算法，神经网络算法，模糊算法</p> 
<p>神经网络：是一种模仿生物神经网络的结构和功能的数学模型或计算模型</p> 
<p>模糊算法：没有根据经典控制理论那样把实际情况加以简化从而建立数学模型，而是通过人的经验和决策进行相应的模糊逻辑推理。</p> 
<h4><a id="30_python_955"></a>30 python特殊的数据类型</h4> 
<p>列表，元组，字典，集合</p> 
<h4><a id="31__961"></a>31 机器人的定义。</h4> 
<p>机器人：是自动执行工作的机器装置，既可以接收人的指挥，又可以运行预先编排得程序，能够协助人类的工作。</p> 
<h3><a id="32__965"></a>32 人工智能的定义</h3> 
<p>研究和发开用于模拟，延伸和扩展人智能的理论，方法，技术的一门技术科学。</p> 
<h4><a id="33PLCFPGA_969"></a>33PLC与FPGA的中文名称。</h4> 
<p>PLC：可编程逻辑控制器</p> 
<p>FPGA：可编码门列阵</p> 
<h4><a id="34__web_975"></a>34 设计web服务器；</h4> 
<p>和客户交流，确定好需求分析</p> 
<p>系统设计：程序设计+前端UI+数据库设计</p> 
<h4><a id="35__981"></a>35 机器学习？</h4> 
<p>机器学习，赋予机器学习的能力，一台机器通过一定数量的训练，来实现能够根据已知的数据，来解决未知的事情，根据已知的样本情况，来实现相应的功能</p> 
<p>比如说，十字路口的红绿灯，可以设计成，将所有通过这个红绿灯的情况记录在车的系统中，车不用人控制，遇到一种情况，自己与系统的系统中的所有样本比对，从而，装上了机器学习的机器，就会自己做出判断，选择如何做出相应的对策。</p> 
<h4><a id="36__987"></a>36 计算机视觉的看法</h4> 
<p>就是赋予机器具有自然视觉能力的学科把，将图像输入到计算机中，计算机处理，理解，研究图像信息，从而对外界做出相应的反应。</p> 
<h4><a id="37__991"></a>37 .什么是传感网？</h4> 
<p>我们生活中到处都网络互联，手机到路由器，路由器到路由器，等等再到手机，而传感网是互联网是一个部分，它是物联网的一个很重的模块—感知模块，他从各个节点接收数据，处理后，可以存储，再汇聚到汇聚节点，汇聚节点通过卫星发送到服务器，人们就可以再远程去监控，或者判断具体事务的情况啊。</p> 
<h4><a id="38__995"></a>38 蒙特卡洛求不规则图形面积</h4> 
<p>比如一张图，有不规则的图形，可以用散点法，也就是蒙特卡洛，比如在上面撒芝麻，看看有多少芝麻在图上，然后找比例求面积</p> 
<h4><a id="39__999"></a>39 复变函数的卷积公式</h4> 
<p>应该有两个函数，根据这两个函数求第三个函数，求这个函数平滑后的面积，也就是求翻转平移后的面积。</p> 
<h4><a id="40__1003"></a>40 傅里叶变换</h4> 
<p>将一个函数或者一个信号，看成若干个小信号或者若干个三角函数叠加，从时域和频域叠加都可以组成原来的信号。</p> 
<h4><a id="41_n_1007"></a>41 泰勒公式的展开，n取到多少怎么确定</h4> 
<p>展开到直到抵消不了为止</p> 
<h4><a id="42__1011"></a>42 什么是蚁群算法？</h4> 
<p>通过正反馈机制寻找最优解，这个最优解是全局最优解，可以与运筹学结合起来用，比如说TSP（旅行商问题），指派问题</p> 
<h4><a id="43___1015"></a>43 空间解析几何中的四维空间和解析集合讲了什么</h4> 
<p>我觉得应该有点到体积距离，三位以上的方程把，比如说，二维的圆，三位中球的界面是二维的圆，四位中，四位对应的是珍，</p> 
<h2><a id="_1019"></a>算法设计与分析</h2> 
<h6><a id="_1021"></a>什么是递归算法</h6> 
<p>①程序调用自身的编程技巧称之为递归，通常一个过程或者一个方法在定义或说明中直接调用或间接调用自身的一种方法。通常，它把一个大型的问题层层化为相类似的并且规模较小的问题求解，递归策略只需要较少的代码实现就可描述出问题中所需要的多次重复计算，大大减少了代码量。</p> 
<p>②递归函数函数需要设置出口，当递归到子问题不能再分解时，就返回。</p> 
<h6><a id="_1027"></a>什么是分治算法？</h6> 
<p>①把一个大问题划分成K个小问题，如果K个小问题还可以划分，则再把它们分别划分成K个更小的问题，直到问题规模足够小，小到可以直接求解，然后把小问题合并成原问题的解。</p> 
<p>②分治算法要注意：</p> 
<p>小问题小到一定规模可以求解</p> 
<p>划分的小问题应该可以合并成原问题的解</p> 
<p>划分的小问题应该具有最优的子结构</p> 
<p>划分的小问题应该相互独立性</p> 
<h6><a id="_1041"></a>什么是贪心算法？</h6> 
<p>贪心算法：把大问题拆分成为同类的更加简单求局部最优解的问题，贪心问题求解的最终可能是整体的最优解。贪心算法不适合对所有问题进行求最优解。贪心算法在每一步上能获得局部最优解，但有时产生的不一定是最优的，所以贪心算法不要回溯。</p> 
<h6><a id="_1045"></a>什么是回溯算法？</h6> 
<p>回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。回溯算法的基本思想是：按照深度优先搜索的策略，从一条路往前走，能进则则进，不能进则退回来，换一条路往前走。</p> 
<h6><a id="_1049"></a>什么是分支限界算法？</h6> 
<p>分支限界的基本思想，就是对有约束条件的最优化问题的所有可行解空间进搜索，把全部可行的解空间不断分割为越来越小的分支，并为每一个分支计算一个界，每次分支的时候，对于不满足限界函数的分支不予考虑，从而缩小了搜索范围。</p> 
<h6><a id="_1053"></a>什么是动态规划问题？</h6> 
<p>动态规划基本思想是，将原问题分解相类似且规模较小的子问题，在求解过程中，记录下子问题的解，用子问题的解，一步步求出原问题的解，相比于分治算法，动态规划算法，减少了相同子问题的计算次数。</p> 
<h3><a id="_1059"></a>政治</h3> 
<h3><a id="_1061"></a>什么是核心价值观？</h3> 
<p>富强 民主 文明 和谐<br> 自由 平等 公正 法治</p> 
<p>爱国 敬业 诚信 友善</p> 
<h3><a id="_1068"></a>什么是两学一做？</h3> 
<p>学党章党规，学系列讲话，做合格党员。</p> 
<h3><a id="_1072"></a>什么是一个中心，两个基本点？</h3> 
<p>以经济建设为中心，坚持四项基本原则，坚持改革开放。</p> 
<h4><a id="_1078"></a>前沿技术？</h4> 
<p>5G站点的开发，截止于2020年5月12日，中国已建设站点19.8万个。</p> 
<p>5G可以应用于各行各业，我们也将迎来，智慧城市，车联网，智慧医疗，以及享受8K视频体验</p> 
<h4><a id="_1084"></a>什么是区块链技术？</h4> 
<p>区块链技术是在多方无需互信的环境下，通过密码学技术让系统中所有参与方协作，来共同记录维护一个可靠的数据日志的方式。</p> 
<h4><a id="_1088"></a>什么是比特币？</h4> 
<p>这个就要举一个粒子，比特币也是一种货币，在这个系统里面，就好比我现实中，没有银行这个系统一样，每一个网络的节点都负责记录网上所有的几张，系统就会奖励其中记账最快的节点，奖励比特币，所以网上的各个节点通过算法平计算能里。</p> 
<h4><a id="_1093"></a>什么是优先级反转？如何解决?</h4> 
<p>指高优先级的进程要去访问一个低优先级使用的资源，而低优先级的正在访问，使得高优先级的进程就要陷入一种等待与阻塞状态。<br> 使用优先级天花板或者优先级继承的方法解决。</p> 
<p>优先级天花板：每一个信号设置一个优先级天花板，优先级天花板是指优先级高于使用该信号的所有任务，当任务得到该信号时，将优先级设置位优先级天花板的值。</p> 
<p>优先级继承：当一个任务阻塞了一组任务时，若阻塞任务中存在高优先级任务，将该任务的优先级设置位阻塞任务中的最高的优先级的值。</p> 
<h4><a id="_1104"></a>为什么要有泰勒展开式？对计算机学科的意义是什么？</h4> 
<p>可以使用泰勒展开式的无限个多项式对某个函数求近似，计算机科学中在openCV中进行模拟曲线可以用的到</p> 
<h4><a id="_1109"></a>线性代数中坐标变化的意义是什么？能解决什么问题？</h4> 
<p>线性代数可以表示图像中的数值，可以对矩阵进行变化，例如对图像进行二值化，灰度化等。</p> 
<h4><a id="8354_1113"></a>一个桶装8斤油，另一个有3斤与5斤桶，怎么就分成两桶4斤油？</h4> 
<p>先将8斤油倒入5斤桶中，此时3 0 5</p> 
<p>再将，5斤油倒入3斤油桶中，再将3斤油桶的油倒入第一个桶中，得到了，6 0 2</p> 
<p>接着将2倒入3斤油桶中，再将6斤倒入五斤油桶中，就得到了，1 2 5<br> 此时只需要，将5斤倒入一斤3斤桶，合并1，3就可以得到两个4 斤油了</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e9381e8923b9251e1918ded3857e7776/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">理解直推式学习和归纳式学习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ecdc57713496360070638885a7e29350/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">创建触发器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>