<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>hadoop相关 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="hadoop相关" />
<meta property="og:description" content="hadoop Hadoop的功能以及模块功能：Hadoop解决的问题模块 下面哪个程序负责 HDFS 数据存储？hdfs 中的 block 默认保存几份？下列哪个程序通常与NameNode 在一个节点启动？HDFS 默认 Block SizeClient 端上传文件的时候下列哪项正确下面与 HDFS 类似的框架是？Ganglia 不仅可以进行监控，也可以进行告警。（正确）Nagios 不可以监控 Hadoop 集群，因为它不提供 Hadoop支持。（错误 ）如果 NameNode 意外终止，SecondaryNameNode 会接替它使集群继续工作。（错误 ）Cloudera CDH 是需要付费使用的。（错误）NameNode 负责管理 metadata，client 端每次读写请求，它都会从磁盘中读取或则会写入 metadata信息并反馈 client 端。（错误）NameNode 本地磁盘保存了 Block 的位置信息。（ 个人认为正确)DataNode 通过长连接与 NameNode 保持通信。错误Hadoop 自身具有严格的权限管理和安全措施保障集群正常运行。（错误）Slave 节点要存储数据，所以它的磁盘越大越好。（错误）hadoop dfsadmin –report 命令用于检测 HDFS 损坏块。（错误）Hadoop 默认调度器策略为 FIFO（正确 ）FIFO：`先进先出`Capacity：容量调度机制Fair：公平调度机制 集群内每个节点都应该配 RAID，这样避免单磁盘损坏，影响整个节点运行。（错误）Hadoop 环境变量中的 HADOOP_HEAPSIZE 用于设置所有 Hadoop 守护线程的内存。它默认是 200 GB。（ 错误）DataNode 首次加入 cluster 的时候，如果 log 中报告不兼容文件版本，那需要 NameNode执行―Hadoopnamenode -format‖操作格式化磁盘。（错误 ）Block Size 是不可以修改的。（错误）Hadoop 支持数据的随机读写。（错）因为 HDFS 有多个副本，所以 NameNode 是不存在单点问题的。（错误 ）Hadoop 是 Java 开发的，所以 MapReduce 只支持 Java 语言编写。（错误 ）每个 map 槽就是一个线程。（错误）Mapreduce 的 input split 就是一个 block。（错误）hdfs的体系结构简要描述如何安装配置一个apache开源版本hadoop，只描述即可，无需列出完整步骤，能列出步骤更好。启动hadoop集群时报下图错误，分析什么原因：请列出hadoop的进程名称Hadoop的核心配置是什么？那当下又该如何配置？ “jps”命令的用处？杀死一个 job?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/019d648e07a81add605880a541a45c46/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-03T19:10:45+08:00" />
<meta property="article:modified_time" content="2023-12-03T19:10:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">hadoop相关</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>hadoop</h4> 
 <ul><li><a href="#Hadoop_2" rel="nofollow">Hadoop的功能以及模块</a></li><li><ul><li><ul><li><a href="#Hadoop_3" rel="nofollow">功能：Hadoop解决的问题</a></li><li><a href="#_6" rel="nofollow">模块</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_HDFS__25" rel="nofollow">下面哪个程序负责 HDFS 数据存储？</a></li><li><a href="#hdfs__block__31" rel="nofollow">hdfs 中的 block 默认保存几份？</a></li><li><a href="#NameNode__37" rel="nofollow">下列哪个程序通常与NameNode 在一个节点启动？</a></li><li><a href="#HDFS__Block_Size_58" rel="nofollow">HDFS 默认 Block Size</a></li><li><a href="#Client__64" rel="nofollow">Client 端上传文件的时候下列哪项正确</a></li><li><a href="#_HDFS__74" rel="nofollow">下面与 HDFS 类似的框架是？</a></li><li><a href="#Ganglia__79" rel="nofollow">Ganglia 不仅可以进行监控，也可以进行告警。（正确）</a></li><li><a href="#Nagios__Hadoop__Hadoop__82" rel="nofollow">Nagios 不可以监控 Hadoop 集群，因为它不提供 Hadoop支持。（错误 ）</a></li><li><a href="#_NameNode_SecondaryNameNode___84" rel="nofollow">如果 NameNode 意外终止，SecondaryNameNode 会接替它使集群继续工作。（错误 ）</a></li><li><a href="#Cloudera_CDH__91" rel="nofollow">Cloudera CDH 是需要付费使用的。（错误）</a></li><li><a href="#NameNode__metadataclient__metadata_client__94" rel="nofollow">NameNode 负责管理 metadata，client 端每次读写请求，它都会从磁盘中读取或则会写入 metadata信息并反馈 client 端。（错误）</a></li><li><a href="#NameNode__Block___105" rel="nofollow">NameNode 本地磁盘保存了 Block 的位置信息。（ 个人认为正确)</a></li><li><a href="#DataNode__NameNode__108" rel="nofollow">DataNode 通过长连接与 NameNode 保持通信。错误</a></li><li><a href="#Hadoop__116" rel="nofollow">Hadoop 自身具有严格的权限管理和安全措施保障集群正常运行。（错误）</a></li><li><a href="#Slave__117" rel="nofollow">Slave 节点要存储数据，所以它的磁盘越大越好。（错误）</a></li><li><a href="#hadoop_dfsadmin_report__HDFS__120" rel="nofollow">hadoop dfsadmin –report 命令用于检测 HDFS 损坏块。（错误）</a></li><li><a href="#Hadoop__FIFO__127" rel="nofollow">Hadoop 默认调度器策略为 FIFO（正确 ）</a></li><li><ul><li><ul><li><a href="#FIFO_128" rel="nofollow">FIFO：`先进先出`</a></li><li><a href="#Capacity_140" rel="nofollow">Capacity：容量调度机制</a></li><li><a href="#Fair_154" rel="nofollow">Fair：公平调度机制</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_RAID_168" rel="nofollow">集群内每个节点都应该配 RAID，这样避免单磁盘损坏，影响整个节点运行。（错误）</a></li><li><a href="#Hadoop__HADOOP_HEAPSIZE__Hadoop__200_GB__173" rel="nofollow">Hadoop 环境变量中的 HADOOP_HEAPSIZE 用于设置所有 Hadoop 守护线程的内存。它默认是 200 GB。（ 错误）</a></li><li><a href="#DataNode__cluster__log__NameNodeHadoopnamenode_format__176" rel="nofollow">DataNode 首次加入 cluster 的时候，如果 log 中报告不兼容文件版本，那需要 NameNode执行―Hadoopnamenode -format‖操作格式化磁盘。（错误 ）</a></li><li><a href="#Block_Size__179" rel="nofollow">Block Size 是不可以修改的。（错误）</a></li><li><a href="#Hadoop__194" rel="nofollow">Hadoop 支持数据的随机读写。（错）</a></li><li><a href="#_HDFS__NameNode___198" rel="nofollow">因为 HDFS 有多个副本，所以 NameNode 是不存在单点问题的。（错误 ）</a></li><li><a href="#Hadoop__Java__MapReduce__Java___201" rel="nofollow">Hadoop 是 Java 开发的，所以 MapReduce 只支持 Java 语言编写。（错误 ）</a></li><li><a href="#_map__204" rel="nofollow">每个 map 槽就是一个线程。（错误）</a></li><li><a href="#Mapreduce__input_split__block_208" rel="nofollow">Mapreduce 的 input split 就是一个 block。（错误）</a></li><li><a href="#hdfs_228" rel="nofollow">hdfs的体系结构</a></li><li><a href="#apachehadoop_235" rel="nofollow">简要描述如何安装配置一个apache开源版本hadoop，只描述即可，无需列出完整步骤，能列出步骤更好。</a></li><li><a href="#hadoop_301" rel="nofollow">启动hadoop集群时报下图错误，分析什么原因：</a></li><li><a href="#hadoop_306" rel="nofollow">请列出hadoop的进程名称</a></li><li><a href="#Hadoop_313" rel="nofollow">Hadoop的核心配置是什么？</a></li><li><ul><li><ul><li><ul><li><a href="#_319" rel="nofollow">那当下又该如何配置？</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#jps_326" rel="nofollow">“jps”命令的用处？</a></li><li><a href="#_job_329" rel="nofollow">杀死一个 job?</a></li><li><a href="#_332" rel="nofollow">加入一个新的存储节点和删除一个计算节点？</a></li><li><a href="#_hadoop__354" rel="nofollow">请列出你所知道的 hadoop 调度器，并简要说明其工作方法？</a></li><li><a href="#hadoop_384" rel="nofollow">hadoop框架中怎么来优化</a></li><li><ul><li><ul><li><a href="#1Writable_390" rel="nofollow">1.使用自定义Writable</a></li><li><a href="#2_StringBuilder_396" rel="nofollow">2. 使用StringBuilder</a></li><li><a href="#3_DistributedCache_400" rel="nofollow">3. 使用DistributedCache加载文件</a></li><li><a href="#4_Combiner_Parttitioner_Comparator_403" rel="nofollow">4. 充分使用Combiner Parttitioner Comparator。</a></li><li><a href="#5_InputFormatOutputFormat_409" rel="nofollow">5. 使用自定义InputFormat和OutputFormat</a></li><li><a href="#6_MR_410" rel="nofollow">6. MR应避免</a></li><li><a href="#7map_421" rel="nofollow">7.关于map的数目</a></li><li><a href="#8reduce_426" rel="nofollow">8.关于reduce的数目</a></li><li><a href="#9Mapside_431" rel="nofollow">9.Map-side相关参数优化</a></li><li><a href="#10_437" rel="nofollow">10.压缩（时间换空间）</a></li><li><a href="#11_reduceside_440" rel="nofollow">11. reduce-side相关参数优化</a></li><li><a href="#13___447" rel="nofollow">13 从应用程序角度进行优化</a></li></ul> 
  </li></ul> 
  </li><li><a href="#datanode_480" rel="nofollow">datanode在什么情况下不会备份</a></li><li><a href="#combiner_483" rel="nofollow">combiner出现在那个过程</a></li><li><a href="#3datanodedatanode_486" rel="nofollow">3个datanode中有一个datanode出现错误会怎样？</a></li><li><a href="#hadoop__namenode__488" rel="nofollow">hadoop 的 namenode 宕机,怎么解决</a></li><li><a href="#datanode__491" rel="nofollow">一个datanode 宕机,怎么一个流程恢复</a></li><li><a href="#_hadoop__494" rel="nofollow">请简述 hadoop 怎么样实现二级排序？</a></li><li><a href="#MapReducejoin12_498" rel="nofollow">如何使用MapReduce实现两个表join，可以考虑一下几种情况：（1）一个表大，一个表小（可放到内存中）；（2）两个表都是大表？</a></li><li><a href="#MapReduce_502" rel="nofollow">MapReduce中排序发生在哪几个阶段？这些排序是否可以避免？为什么？</a></li><li><a href="#_mapreduce_combinerpartition__505" rel="nofollow">请简述 mapreduce 中，combiner，partition 作用？</a></li><li><a href="#mapreduce_524" rel="nofollow">用mapreduce怎么处理数据倾斜问题？</a></li><li><a href="#hadoopCombiner_559" rel="nofollow">hadoop中Combiner的作用?</a></li><li><a href="#Mapreduce__map___reduce____564" rel="nofollow">Mapreduce 的 map 数量 和 reduce 数量 怎么确定 ,怎么配置</a></li><li><a href="#hadoop_567" rel="nofollow">在hadoop中文件的压缩带来了两大好处：</a></li><li><a href="#mapreduce_571" rel="nofollow">mapreduce的调度模式（)</a></li><li><a href="#Hadoop_837" rel="nofollow">Hadoop的三大分布式模块及功能分别是什么？</a></li><li><a href="#Hadoop_848" rel="nofollow">什么情况下需要编译Hadoop？</a></li><li><a href="#SecondaryNameNode_852" rel="nofollow">SecondaryNameNode</a></li><li><a href="#hdfs_855" rel="nofollow">hdfs写流程</a></li><li><a href="#hdfs_880" rel="nofollow">hdfs读流程</a></li><li><a href="#mapreduce__887" rel="nofollow">举一个简单的例子说明mapreduce是怎么来运行的 ?</a></li><li><a href="#mrshuffle_899" rel="nofollow">mr之shuffle详解</a></li><li><a href="#mr_901" rel="nofollow">mr流程图</a></li><li><a href="#yarn_904" rel="nofollow">yarn流程</a></li><li><a href="#HDFSHA_916" rel="nofollow">HDFS的HA架构</a></li><li><a href="#VS_918" rel="nofollow">行式存储VS列式存储</a></li><li><ul><li><ul><li><a href="#_919" rel="nofollow">行式存储</a></li><li><a href="#_924" rel="nofollow">列式存储</a></li></ul> 
  </li></ul> 
  </li><li><a href="#HadoopDataNode_933" rel="nofollow">Hadoop集群中其中一台DataNode节点的磁盘快满了怎么处理？</a></li></ul> 
</div> 
<p></p> 
<h2><a id="Hadoop_2"></a>Hadoop的功能以及模块</h2> 
<h4><a id="Hadoop_3"></a>功能：Hadoop解决的问题</h4> 
<ul><li>大数据<code>存储</code></li><li>大数据<code>计算</code></li></ul> 
<h4><a id="_6"></a>模块</h4> 
<ul><li>Hadoop Common: The common utilities that support the other Hadoop modules. 
  <ul><li>Hadoop的通用组件，用于连接各个模块的应用</li></ul> </li><li>Hadoop Distributed File System (<mark>HDFS</mark>™): A distributed file system that provides high-throughput access to application data. 
  <ul><li>HDFS，<code>分布式文件系统</code>，用于提供高吞吐量的数据访问</li><li>实现大数据的存储，提供大数据的读写访问</li></ul> </li><li>Hadoop <mark>MapReduce</mark>: A YARN-based system for parallel processing of large data sets. 
  <ul><li><code>分布式计算模型</code>，用于并行化的处理大量数据，基于Yarn</li><li>MapReduce程序运行在YARN，由YARN提供分布式CPU和内存资源</li></ul> </li><li>Hadoop <mark>YARN</mark>: A framework for job scheduling and cluster resource management. 
  <ul><li><code>分布式资源管理和任务调度框架</code></li><li><mark>资源管理</mark>：<code>将多台机器的资源构建成一个整体，CPU、内存</code> 
    <ul><li><code>对外提供统一的运行资源平台</code></li><li>资源容器</li><li>负责给在YARN中运行的程序提供资源</li></ul> </li><li><mark>任务调度</mark> 
    <ul><li>多个MapReduce程序</li><li><code>谁先运行，谁后运行</code></li><li><code>每个程序使用多少资源</code></li></ul> </li></ul> </li></ul> 
<h2><a id="_HDFS__25"></a>下面哪个程序负责 HDFS 数据存储？</h2> 
<ul><li>a)NameNode</li><li>b)Jobtracker</li><li>c)<code>Datanode </code></li><li>d)secondaryNameNode</li><li>e)tasktracker</li></ul> 
<h2><a id="hdfs__block__31"></a>hdfs 中的 block 默认保存几份？</h2> 
<ul><li>a)<code>3份</code></li><li>b)2份</li><li>c)1份</li><li>d)不确定</li></ul> 
<h2><a id="NameNode__37"></a>下列哪个程序通常与NameNode 在一个节点启动？</h2> 
<ul><li>a)SecondaryNameNode</li><li>b)DataNode</li><li>c)<code>TaskTracker</code></li><li>d)Jobtracker</li><li>注：haoop1.X</li></ul> 
<pre><code class="prism language-java">分析：
hadoop 的集群是基于 master<span class="token operator">/</span>slave 模式，namenode 和 jobtracker 属于 master，datanode 和 tasktracker属于 slave，master 只有一个，而 slave 有多个。<span class="token class-name">SecondaryNameNode</span> 内存需求和 <span class="token class-name">NameNode</span> 在一个数量级上，所以通常 secondary <span class="token class-name">NameNode</span>（运行在单独的物理机器上）和 <span class="token class-name">NameNode</span> 运行在不同的机器上。
<span class="token class-name">JobTracker</span> 和 <span class="token class-name">TaskTracker</span>
<span class="token class-name">JobTracker</span> 对应于 <span class="token class-name">NameNode</span>
<span class="token class-name">TaskTracker</span> 对应于 <span class="token class-name">DataNode</span>
<span class="token class-name">DataNode</span> 和 <span class="token class-name">NameNode</span> 是针对数据存放来而言的
<span class="token class-name">JobTracker</span> 和 <span class="token class-name">TaskTracker</span> 是对于 <span class="token class-name">MapReduce</span> 执行而言的
mapreduce 中几个主要概念，mapreduce 整体上可以分为这么几条执行线索：
jobclient，<span class="token class-name">JobTracker</span> 与 <span class="token class-name">TaskTracker</span>。
<span class="token number">1</span>、<span class="token class-name">JobClient</span> 会在用户端通过 <span class="token class-name">JobClient</span> 类将应用已经配置参数打包成 jar 文件存储到 hdfs，并把路径提交到 <span class="token class-name">Jobtracker</span><span class="token punctuation">,</span>然后由 <span class="token class-name">JobTracker</span> 创建每一个 <span class="token class-name">Task</span>（即 <span class="token class-name">MapTask</span> 和 <span class="token class-name">ReduceTask</span>）并将它们分发到各个 <span class="token class-name">TaskTracker</span> 服务中去执行
<span class="token number">2</span>、<span class="token class-name">JobTracker</span> 是一个 master 服务，软件启动之后 <span class="token class-name">JobTracker</span> 接收 <span class="token class-name">Job</span>，负责调度 <span class="token class-name">Job</span> 的每一个子任务 task运行于 <span class="token class-name">TaskTracker</span> 上，并监控它们，如果发现有失败的 task 就重新运行它。一般情况应该把 <span class="token class-name">JobTracker</span> 部署在单独的机器上。
<span class="token number">3</span>、<span class="token class-name">TaskTracker</span> 是运行在多个节点上的 slaver 服务。<span class="token class-name">TaskTracker</span> 主动与 <span class="token class-name">JobTracker</span> 通信，接收作业，并负责直接执行每一个任务。<span class="token class-name">TaskTracker</span> 都需要运行在 <span class="token constant">HDFS</span> 的 <span class="token class-name">DataNode</span> 上
</code></pre> 
<h2><a id="HDFS__Block_Size_58"></a>HDFS 默认 Block Size</h2> 
<ul><li>a)32MB</li><li>b)64MB</li><li>c)<code>128MB</code></li><li>注：旧版本是64MB</li></ul> 
<h2><a id="Client__64"></a>Client 端上传文件的时候下列哪项正确</h2> 
<ul><li>a)数据经过 NameNode 传递给 DataNode</li><li>b)<code>Client 端将文件切分为 Block，依次上传</code></li><li>c)Client 只上传数据到一台 DataNode，然后由 NameNode 负责 Block 复制工作</li></ul> 
<pre><code class="prism language-java"><span class="token class-name">Client</span> 向 <span class="token class-name">NameNode</span> 发起文件写入的请求。
<span class="token class-name">NameNode</span> 根据文件大小和文件块配置情况，返回给 <span class="token class-name">Client</span> 它所管理部分 <span class="token class-name">DataNode</span> 的信息。
<span class="token class-name">Client</span> 将文件划分为多个 <span class="token class-name">Block</span>，根据 <span class="token class-name">DataNode</span> 的地址信息，按顺序写入到每一个 <span class="token class-name">DataNode</span> 块中。
</code></pre> 
<h2><a id="_HDFS__74"></a>下面与 HDFS 类似的框架是？</h2> 
<ul><li>A NTFS</li><li>B FAT32</li><li>C <code>GFS</code></li><li>D EXT3</li></ul> 
<h2><a id="Ganglia__79"></a>Ganglia 不仅可以进行监控，也可以进行告警。（正确）</h2> 
<ul><li>解析： 
  <ul><li>ganglia 作为一款最常用的 Linux 环境中的监控软件，它擅长的的是从节点中按照用户的需求以较低的代价采集数据。但是 ganglia 在预警以及发生事件后通知用户上并不擅长。最新的ganglia 已经有了部分这方面的功能。但是更擅长做警告的还有 Nagios。Nagios，就是一款精于预警、通知的软件。通过将 Ganglia 和Nagios 组合起来，把 Ganglia 采集的数据作为 Nagios 的数据源，然后利用 Nagios 来发送预警通知，可以完美的实现一整套监控管理的系统。</li></ul> </li></ul> 
<h2><a id="Nagios__Hadoop__Hadoop__82"></a>Nagios 不可以监控 Hadoop 集群，因为它不提供 Hadoop支持。（错误 ）</h2> 
<ul><li>分析：Nagios 是集群监控工具，而且是云计算三大利器之一</li></ul> 
<h2><a id="_NameNode_SecondaryNameNode___84"></a>如果 NameNode 意外终止，SecondaryNameNode 会接替它使集群继续工作。（错误 ）</h2> 
<ul><li>分析： 
  <ul><li><code>SecondaryNameNode不是NameNode备份</code></li><li>功能：<code>在不影响NameNode对外提供服务的情况下，偷偷将内存元数据与文件元数据进行同步，加快下一次NameNode启动的进度</code></li></ul> </li><li>补充：<code>NameNode的备份还叫NameNode</code> 
  <ul><li>一个是active的NameNode</li><li>一个是standby的NameNode</li></ul> </li></ul> 
<h2><a id="Cloudera_CDH__91"></a>Cloudera CDH 是需要付费使用的。（错误）</h2> 
<ul><li>分析： 
  <ul><li>第一套付费产品是 Cloudera Enterpris，Cloudera Enterprise 在美国加州举行的 Hadoop 大会 (HadoopSummit) 上公开，以若干私有管理、监控、运作工具加强 Hadoop 的功能。收费采取合约订购方式，价格随用的 Hadoop 叢集大小变动。</li></ul> </li></ul> 
<h2><a id="NameNode__metadataclient__metadata_client__94"></a>NameNode 负责管理 metadata，client 端每次读写请求，它都会从磁盘中读取或则会写入 metadata信息并反馈 client 端。（错误）</h2> 
<ul><li>分析： 
  <ul><li><code>NameNode 不需要从磁盘读取 metadata，所有数据都在内存中，硬盘上的只是序列化的结果，只有每次namenode 启动的时候才会读取。</code></li></ul> </li><li>1）文件写入 
  <ul><li>Client 向 NameNode 发起文件写入的请求。</li><li>NameNode 根据文件大小和文件块配置情况，返回给 Client 它所管理部分 DataNode 的信息。</li><li>Client 将文件划分为多个 Block，根据 DataNode 的地址信息，按顺序写入到每一个 DataNode 块中。</li></ul> </li><li>2）文件读取 
  <ul><li>Client 向 NameNode 发起文件读取的请求</li><li>NameNode 返回文件存储的 DataNode 的信息。</li><li>Client 读取文件信息。</li></ul> </li></ul> 
<h2><a id="NameNode__Block___105"></a>NameNode 本地磁盘保存了 Block 的位置信息。（ 个人认为正确)</h2> 
<ul><li>分析： 
  <ul><li>DataNode 是文件存储的基本单元，它将 Block 存储在本地文件系统中，保存了 Block 的 Meta-data，同时周期性地将所有存在的 Block 信息发送给 NameNode。</li></ul> </li></ul> 
<h2><a id="DataNode__NameNode__108"></a>DataNode 通过长连接与 NameNode 保持通信。错误</h2> 
<ul><li>分析： 
  <ul><li>通过<code>心跳机制</code>。</li></ul> </li><li>补充： 
  <ul><li>（1）<code>长连接</code> 
    <ul><li>Client 方与 Server 方先建立通讯连接，连接<code>建立后不断开</code>，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在，此种方式常用于点对点通讯。</li></ul> </li><li>（2）<code>短连接</code> 
    <ul><li>Client 方与 Server 每进行一次报文收发交易时才进行通讯连接，交易<code>完毕后立即断开连接</code>。此种方式常用于一点对多点通讯，比如多个 Client 连接一个 Server.</li></ul> </li></ul> </li></ul> 
<h2><a id="Hadoop__116"></a>Hadoop 自身具有严格的权限管理和安全措施保障集群正常运行。（错误）</h2> 
<h2><a id="Slave__117"></a>Slave 节点要存储数据，所以它的磁盘越大越好。（错误）</h2> 
<ul><li>分析： 
  <ul><li>一旦 Slave 节点宕机，数据恢复是一个难题</li></ul> </li></ul> 
<h2><a id="hadoop_dfsadmin_report__HDFS__120"></a>hadoop dfsadmin –report 命令用于检测 HDFS 损坏块。（错误）</h2> 
<ul><li>分析： 
  <ul><li>hadoop dfsadmin -report</li></ul> </li><li>可以快速定位出哪些节点 down 掉了</li><li>HDFS 的容量以及使用了多少</li><li>以及每个节点的硬盘使用情况。</li><li>当然 NameNode 有个 http 页面也可以查询，但是这个命令的输出更适合我们的脚本监控 dfs 的使用状况</li></ul> 
<h2><a id="Hadoop__FIFO__127"></a>Hadoop 默认调度器策略为 FIFO（正确 ）</h2> 
<h4><a id="FIFO_128"></a>FIFO：<code>先进先出</code></h4> 
<ul><li>YARN中构建一个队列【管道：一头进，一头出】</li><li>所有提交的任务都按照提交的时间放到队列中</li><li>先放入的程序，享有整个YARN中的所有资源，<code>哪怕你用不了，那也是你的</code></li><li>直到先放进去的程序运行完成，才会运行第二个程序</li><li>特点 
  <ul><li>单队列，先进先出</li><li><code>运行的程序，享有所有资源</code></li><li>程序<code>不能并行也不能并发</code></li><li><code>并行：多个程序在不同的队列中同时运行</code></li><li><code>并发：在一个队列中多个程序同时运行</code></li></ul> </li><li><mark>这种方式是Hadoop默认的调度方式</mark></li></ul> 
<h4><a id="Capacity_140"></a>Capacity：容量调度机制</h4> 
<ul><li>YARN中构建多个队列，每个队列是FIFO</li><li>将整个YARN的资源分配到不同的队列中 
  <ul><li>YARN：24core 24GB</li><li>队列1：12core 12GB</li><li>队列2：12Core 12GB</li></ul> </li><li>运行程序时，可以指定将程序提交到哪个队列中运行</li><li>特点 
  <ul><li><code>多队列，但是每个队列内部还是FIFO</code></li><li>并行运行多个程序，每个程序运行在不同的队列中</li><li>支持资源的动态抢占：<code>如果队列1的资源不够，队列2的资源非常充足，借队列2的资源来运行</code></li><li>程序1：队列1:13core13GB</li><li>队列2没有程序，队列1可以跟队列2借，程序<code>执行完成以后还回去</code></li></ul> </li><li><mark>这种方式是Apache版本的Hadoop默认的调度方式</mark></li></ul> 
<h4><a id="Fair_154"></a>Fair：公平调度机制</h4> 
<ul><li><mark>这种方式是CDH版本的默认调度方式，也是工作中普遍使用的方式</mark></li><li>YARN中构建多个队列，每个队列是公平的共享资源的</li><li>每个队列里是可以同时运行多个程序的</li><li>支持一个队列中并发运行多个程序</li><li>第一个程序：会享有这个队列的所有资源</li><li>第二个程序：将当前空闲的资源与第二个程序进行平分</li><li>|</li><li>让每个程序都能拿到资源</li><li>特点 
  <ul><li><code>多队列，队列内部的每个程序共享资源</code></li><li><code>允许一个队列中并发运行，运行多个队列并行运行</code></li><li>也<code>支持队列间的资源的动态抢占</code></li><li><code>指定队列程序的优先级</code></li></ul> </li></ul> 
<h2><a id="_RAID_168"></a>集群内每个节点都应该配 RAID，这样避免单磁盘损坏，影响整个节点运行。（错误）</h2> 
<ul><li>分析： 
  <ul><li>首先明白什么是 RAID：磁盘阵列（Redundant Arrays of Independent Disks，RAID），有“独立磁盘构成的具有冗余能力的阵列”之意。</li></ul> </li><li>这句话错误的地方在于<code>太绝对</code>，具体情况具体分析。</li><li>因为 <code>hadoop 本身就具有冗余能力</code>，所以如果不是很严格不需要都配备 RAID。</li></ul> 
<h2><a id="Hadoop__HADOOP_HEAPSIZE__Hadoop__200_GB__173"></a>Hadoop 环境变量中的 HADOOP_HEAPSIZE 用于设置所有 Hadoop 守护线程的内存。它默认是 200 GB。（ 错误）</h2> 
<ul><li>分析： 
  <ul><li>hadoop 为各个守护进程（namenode,secondarynamenode,jobtracker,datanode,tasktracker）统一分配的内存在 hadoop-env.sh 中设置，参数为 HADOOP_HEAPSIZE，默认为 1000M。</li></ul> </li></ul> 
<h2><a id="DataNode__cluster__log__NameNodeHadoopnamenode_format__176"></a>DataNode 首次加入 cluster 的时候，如果 log 中报告不兼容文件版本，那需要 NameNode执行―Hadoopnamenode -format‖操作格式化磁盘。（错误 ）</h2> 
<ul><li>分析： 
  <ul><li>这个报错是说明 DataNode 所装的 Hadoop 版本和其它节点不一致，应该检查 DataNode 的 Hadoop 版本</li></ul> </li></ul> 
<h2><a id="Block_Size__179"></a>Block Size 是不可以修改的。（错误）</h2> 
<ul><li>解析： 
  <ul><li>Hadoop 的基础配置文件是 hadoop-default.xml，默认建立一个 Job 的时候会建立 Job 的 Config，Config</li></ul> </li><li>首先读入hadoop-default.xml的配置，然后再读入hadoop-site.xml的配置（这个文件初始的时候配置为空），</li><li>hadoop-site.xml 中主要配置需要覆盖的 hadoop-default.xml 的系统级配置。具体配置可以参考下：</li></ul> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">&gt;</span></span>dfs.block.size<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">&gt;</span></span>
  //block 的大小，单位字节，后面会提到用处，必须是 512 的倍数，因为采用 crc 作文件完整性校验，默认配置 512 是 checksum 的最小单元。
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>5120000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">&gt;</span></span>The default block size for new files.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<h2><a id="Hadoop__194"></a>Hadoop 支持数据的随机读写。（错）</h2> 
<ul><li>分析： 
  <ul><li>lucene 是支持随机读写的，而 <code>hdfs 只支持随机读</code>。但是 HBase 可以来补救。</li><li><code>HBase 提供随机读写，来解决 Hadoop 不能处理的问题</code>。HBase 自底层设计开始即聚焦于各种可伸缩性问题：<code>表可以很―高‖，有数十亿个数据行；也可以很―宽‖，有数百万个列</code>；水平分区并在上千个普通商用机节点上自动复制。<code>表的模式是物理存储的直接反映，使系统有可能提高高效的数据结构的序列化、存储和检索。</code></li></ul> </li></ul> 
<h2><a id="_HDFS__NameNode___198"></a>因为 HDFS 有多个副本，所以 NameNode 是不存在单点问题的。（错误 ）</h2> 
<ul><li>分析： 
  <ul><li><code>副本针对DataName而讲的</code></li></ul> </li></ul> 
<h2><a id="Hadoop__Java__MapReduce__Java___201"></a>Hadoop 是 Java 开发的，所以 MapReduce 只支持 Java 语言编写。（错误 ）</h2> 
<ul><li>分析： 
  <ul><li><code>支持c++等语言，需要通过接口。</code></li></ul> </li></ul> 
<h2><a id="_map__204"></a>每个 map 槽就是一个线程。（错误）</h2> 
<ul><li>分析： 
  <ul><li>一个task对应一个线程</li><li>分析：首先我们知道什么是 map 槽,map 槽→map slot，<code>map slot 只是一个逻辑值 </code>(org.apache.hadoop.mapred.TaskTracker.TaskLauncher.numFreeSlots )，<code>而不是对应着一个线程或者进程</code></li></ul> </li></ul> 
<h2><a id="Mapreduce__input_split__block_208"></a>Mapreduce 的 input split 就是一个 block。（错误）</h2> 
<ul><li> <p>分析：</p> 
  <ul><li><code>应该是一个block数组</code></li></ul> </li><li> <p>1、运行mapred程序；</p> </li><li> <p>2、本次运行将生成一个Job，于是JobClient向JobTracker申请一个JobID以标识这个Job；</p> </li><li> <p>3、JobClient将Job所需要的资源提交到HDFS中一个以JobID命名的目录中。这些资源包括JAR包、配置文件、InputSplit、等；</p> </li><li> <p>4、JobClient向JobTracker提交这个Job；</p> </li><li> <p>5、JobTracker初始化这个Job；</p> </li><li> <p>6、JobTracker从HDFS获取这个Job的Split等信息；</p> </li><li> <p>7、JobTracker向TaskTracker分配任务；</p> </li><li> <p>8、TaskTracker从HDFS获取这个Job的相关资源；</p> </li><li> <p>9、TaskTracker开启一个新的JVM；</p> </li><li> <p>10、TaskTracker用新的JVM来执行Map或Reduce；</p> </li><li> <p>InputSplit也是一个interface，具体返回什么样的implement，这是由具体的InputFormat来决定的。InputSplit也只有两个接口函数：</p> 
  <ul><li>long getLength() throws IOException;</li><li>String[] getLocations() throws IOException;</li></ul> </li><li> <p>这个interface仅仅描述了Split有多长，以及存放这个Split的Location信息（也就是这个Split在HDFS上存放的机器。它可能有多个replication，存在于多台机器上）。除此之外，就再没有任何直接描述Split的信息了。比如：Split对应于哪个文件？在文件中的起始和结束位置是什么？等等重要的特征都没有描述到。</p> </li><li> <p>为什么会这样呢？因为关于Split的那些描述信息，对于MapReduce框架来说是不需要关心的。框架只关心Split的长度（主要用于一些统计信息）和Split的Location（主要用于Split的调度，后面会细说）。</p> </li><li> <p>而Split中真正重要的描述信息还是只有InputFormat会关心。在需要读取一个Split的时候，其对应的InputSplit会被传递到InputFormat的第二个接口函数getRecordReader，然后被用于初始化一个RecordReader，以解析输入数据。也就是说，描述Split的重要信息都被隐藏了，只有具体的InputFormat自己知道。它只需要保证getSplits返回的InputSplit和getRecordReader所关心的InputSplit是同样的implement就行了。这就给InputFormat的实现提供了巨大的灵活性。</p> </li></ul> 
<h2><a id="hdfs_228"></a>hdfs的体系结构</h2> 
<ul><li>解答： 
  <ul><li>hdfs有<code>namenode、secondraynamenode、datanode</code>组成。</li><li>为n+1模式</li><li><code>namenode负责管理datanode和记录元数据</code></li><li><code>secondraynamenode负责合并日志</code></li><li><code>datanode负责存储数据</code></li></ul> </li></ul> 
<h2><a id="apachehadoop_235"></a>简要描述如何安装配置一个apache开源版本hadoop，只描述即可，无需列出完整步骤，能列出步骤更好。</h2> 
<ul><li>流程：</li><li>1.创建hadoop用户和用户组，用来管理hadoop项目</li><li>2.修改IP</li></ul> 
<pre><code class="prism language-xml">vim /etc/sysconfig/network-scripts/ifcfg-eth0
</code></pre> 
<ul><li>3.修改主机名：</li></ul> 
<pre><code class="prism language-bash"> <span class="token function">vim</span> /etc/sysconfig/network
</code></pre> 
<ul><li>4.修改host主机名和ip地址映射：</li></ul> 
<p>vim /etc/hosts</p> 
<ul><li>5.查看防火墙状态并关闭防火墙：</li></ul> 
<pre><code class="prism language-bash"> <span class="token comment">#查看防火墙状态</span>
    <span class="token function">service</span> iptables status
    <span class="token comment">#关闭防火墙</span>
    <span class="token function">service</span> iptables stop
    <span class="token comment">#查看防火墙开机启动状态</span>
    <span class="token function">chkconfig</span> iptables <span class="token parameter variable">--list</span>
    <span class="token comment">#关闭防火墙开机启动</span>
    <span class="token function">chkconfig</span> iptables off
</code></pre> 
<ul><li>6.安装ssh并配置免密码登录：</li></ul> 
<pre><code class="prism language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa
执行完这个命令后，会生成两个文件id_rsa（私钥）、id_rsa.pub（公钥）
将公钥拷贝到要免登陆的机器上
<span class="token function">cat</span> ~/.ssh/id_rsa.pub <span class="token operator">&gt;&gt;</span> ~/.ssh/authorized_keys
    或
ssh-copy-id <span class="token parameter variable">-i</span> localhost
</code></pre> 
<ul><li>7.安装JDK，并配置环境变量</li></ul> 
<pre><code class="prism language-bash"> <span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> jdk**.tar.gz <span class="token parameter variable">-C</span> /user/java/ 修改/etc/profile文件，配置java环境变量
</code></pre> 
<ul><li>8.上传解压hadoop安装包</li></ul> 
<pre><code class="prism language-bash">  <span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> hadoop<span class="token punctuation">..</span><span class="token punctuation">..</span>tar.gz
</code></pre> 
<ul><li>9.配置conf文件夹下的hadoop-env.sh,core-site.xml,hdfs-site.xml,mapred-site.xml,yarn-site.xml,slaves文件</li><li>10.安装配置zookeeper集群</li><li>11.格式namenode</li></ul> 
<pre><code class="prism language-bash">hdfs namenode <span class="token parameter variable">-format</span>
</code></pre> 
<h2><a id="hadoop_301"></a>启动hadoop集群时报下图错误，分析什么原因：</h2> 
<ul><li>解答： 
  <ul><li>1、权限问题，可能曾经用root启动过集群。(例如hadoop搭建的集群,是tmp/hadoop-hadoop/…)</li><li>2、可能是文件夹不存在</li><li>3、解决: 删掉tmp下的那个文件,或改成当前用户</li></ul> </li></ul> 
<h2><a id="hadoop_306"></a>请列出hadoop的进程名称</h2> 
<ul><li>解答： 
  <ul><li>1.namenode:管理集群，并记录datanode文件信息。</li><li>2.Secondname:可以做冷备，对一定范围内的数据做快照性备份。</li><li>3.Datanode：存储数据。</li><li>4.Jobtracker：管理任务，并将任务分配给tasktracker。</li><li>5.Tasktracker:任务执行者</li></ul> </li></ul> 
<h2><a id="Hadoop_313"></a>Hadoop的核心配置是什么？</h2> 
<ul><li>解答： 
  <ul><li>Hadoop的核心配置通过两个xml文件来完成：</li><li>1.hadoop-default.xml；</li><li>2.hadoop-site.xml。</li><li>这些文件都使用xml格式，因此每个xml中都有一些属性，包括名称和值，但是当下这些文件都已不复存在。</li></ul> </li></ul> 
<h5><a id="_319"></a>那当下又该如何配置？</h5> 
<ul><li>解答： 
  <ul><li>Hadoop现在拥有3个配置文件：</li><li>1，core-site.xml；</li><li>2，hdfs-site.xml；</li><li>3，mapred-site.xml。</li><li>这些文件都保存在conf/子目录下。</li></ul> </li></ul> 
<h2><a id="jps_326"></a>“jps”命令的用处？</h2> 
<ul><li>解答： 
  <ul><li>这个命令可以检查Namenode、Datanode、Task Tracker、 Job Tracker是否正常工作。</li></ul> </li></ul> 
<h2><a id="_job_329"></a>杀死一个 job?</h2> 
<ul><li>jps查询进程</li><li>kill -9 job-id</li></ul> 
<h2><a id="_332"></a>加入一个新的存储节点和删除一个计算节点？</h2> 
<ul><li>解答：</li><li>添加新节点： 
  <ul><li>1.将namenode的hadoop文件全部复制到新节点。</li><li>2.修改每个节点的hosts文件，将节点四的名字加入进去。</li><li>3.配置ssh免密登录，使得namenode登录新节点的时候不需要输入密码。</li><li>4.修改各节点的slaves文件，加入新节点的名称。</li><li>5.单独启动该节点上的Datanode进程和NodeManager进程。 
    <ul><li>hadoop-daemon.sh start datanode</li><li>yarn-daemon.sh start nodemanager</li></ul> </li><li>6.之后再去web ui上去看看，是否添加成功。</li><li>7.因为添加了新节点之后，其实整个集群的负载均衡机制是偏斜了的，因为你的新节点完全没有数据存在，所以这个时候应该执行一下，start-balancer.sh,重新平衡一下各个节点上数据块的分布</li></ul> </li><li>移除一个节点： 
  <ul><li>1.修改core-site.xml 
    <ul><li>配置dfs.hosts.exclude</li></ul> </li><li>2.修改hdfs-site.xml 
    <ul><li>配置dfs.hosts.exclude</li></ul> </li><li>3.在master上创建并修改excludes文件，添加需要删除节点的IP</li><li>4.在master上刷新节点配置情况 
    <ul><li>hadoop dfsadmin -refreshnodes</li></ul> </li><li>10.删除 hdfs 上的/tmp/aaa 目录 
    <ul><li>hdfs dfs -rmr /tmp/aaa</li></ul> </li></ul> </li></ul> 
<h2><a id="_hadoop__354"></a>请列出你所知道的 hadoop 调度器，并简要说明其工作方法？</h2> 
<ul><li>解答：</li><li>1.FIFO schedular:先入先出调度器,hadoop1.x默认 
  <ul><li>队列方式将一个一个job任务按照时间先后顺序进行服务</li><li>1.YARN中构建一个队列【管道：一头进，一头出】</li><li>2.所有提交的任务都按照提交的时间放到队列中</li><li>3.先放入的程序，享有整个YARN中的所有资源，哪怕你用不了，那也是你的</li><li>4.直到先放进去的程序运行完成，才会运行第二个程序</li><li>特点 
    <ul><li>1.单队列，先进先出</li><li>2.运行的程序，享有所有资源</li><li>3.程序不能并行也不能并发</li></ul> </li><li>并行：多个程序在不同的队列中同时运行</li><li>并发：在一个队列中多个程序同时运行</li></ul> </li><li>2.Capacity schedular:容量调度器 
  <ul><li>1.YARN中构建多个队列，每个队列是FIFO</li><li>2.将整个YARN的资源分配到不同的队列中</li><li>3.运行程序时，可以指定将程序提交到哪个队列中运行</li><li>特点 
    <ul><li>1.多队列，但是每个队列内部还是FIFO</li><li>2.并行运行多个程序，每个程序运行在不同的队列中</li><li>3.支持资源的动态抢占：如果队列1的资源不够，队列2的资源非常充足，借队列2的资源来运行</li></ul> </li></ul> </li><li>3.Fair schedular:公平调度 
  <ul><li>1.YARN中构建多个队列，每个队列是公平的共享资源的</li><li>2.支持一个队列中并发运行多个程序</li><li>特点 
    <ul><li>1.多队列，队列内部的每个程序共享资源</li><li>2.允许一个队列中并发运行，运行多个队列并行运行</li><li>3.也支持队列间的资源的动态抢占</li><li>4.指定队列程序的优先级</li></ul> </li></ul> </li></ul> 
<h2><a id="hadoop_384"></a>hadoop框架中怎么来优化</h2> 
<ul><li>解答： 
  <ul><li>（1） 从应用程序角度进行优化。由于mapreduce是迭代逐行解析数据文件的，怎样在迭代的情况下，编写高效率的应用程序，是一种优化思路。</li><li>（2） 对Hadoop参数进行调优。当前hadoop系统有190多个配置参数，怎样调整这些参数，使hadoop作业运行尽可能的快，也是一种优化思路。</li><li>（3） 从系统实现角度进行优化。这种优化难度是最大的，它是从hadoop实现机制角度，发现当前Hadoop设计和实现上的缺点，然后进行源码级地修改。该方法虽难度大，但往往效果明显。</li><li>（4）linux内核参数调整</li></ul> </li></ul> 
<h4><a id="1Writable_390"></a>1.使用自定义Writable</h4> 
<ul><li>自带的Text很好用，但是字符串转换开销较大，故根据实际需要自定义Writable，注意作为Key时要实现WritableCompareable接口</li><li>避免output.collect(new Text( ),new Text())</li><li>提倡key.set( ) value.set( ) output.collect(key,value)</li><li>前者会产生大量的Text对象，使用完后Java垃圾回收器会花费大量的时间去收集这些对象</li></ul> 
<h4><a id="2_StringBuilder_396"></a>2. 使用StringBuilder</h4> 
<ul><li>不要使用Formatter StringBuffer（ 线程安全）</li><li>StringBuffer尽量少使用多个append方法，适当使用+</li></ul> 
<h4><a id="3_DistributedCache_400"></a>3. 使用DistributedCache加载文件</h4> 
<ul><li>比如配置文件，词典，共享文件，避免使用static变量</li></ul> 
<h4><a id="4_Combiner_Parttitioner_Comparator_403"></a>4. 充分使用Combiner Parttitioner Comparator。</h4> 
<ul><li>Combiner : 对map任务进行本地聚合</li><li>Parttitioner ： 合适的Parttitioner避免reduce端负载不均</li><li>Comparator ： 二次排序</li><li>比如求每天的最大气温，map结果为日期：气温，若气温是降序的，直接取列表首元素即可</li></ul> 
<h4><a id="5_InputFormatOutputFormat_409"></a>5. 使用自定义InputFormat和OutputFormat</h4> 
<h4><a id="6_MR_410"></a>6. MR应避免</h4> 
<ul><li>静态变量：不能用于计数，应使用Counter</li><li>大对象：Map List</li><li>递归：避免递归深度过大</li><li>超长正则表达式：消耗性能，要在map或reduce函数外编译正则表达式</li><li>不要创建本地文件：变向的把HDFS里面的数据转移到TaskTracker，占用网络带宽</li><li>不要大量创建目录和文件</li><li>不要大量使用System.out.println，而使用Logger</li><li>不要自定义过多的Counter，最好不要超过100个</li><li>不要配置过大内存，mapred.child.java.opts -Xmx2000m是用来设置mapreduce任务使用的最大heap量</li></ul> 
<h4><a id="7map_421"></a>7.关于map的数目</h4> 
<ul><li>map数目过大[创建和初始化map的开销]，一般是由大量小文件造成的，或者dfs.block.size设置的太小，对于小文件可以archive文件或者Hadoop fs -merge合并成一个大文件.</li><li>map数目过少，造成单个map任务执行时间过长，频繁推测执行，且容易内存溢出，并行性优势不能体现出来。dfs.block.size一般为256M-512M</li><li>压缩的Text 文件是不能被分割的，所以尽量使用SequenceFile，可以切分</li></ul> 
<h4><a id="8reduce_426"></a>8.关于reduce的数目</h4> 
<ul><li>reduce数目过大，产生大量的小文件，消耗大量不必要的资源，reduce数目过低呢，造成数据倾斜问题，且通常不能通过修改参数改变。</li><li>可选方案：mapred.reduce.tasks设为-1变成AutoReduce。</li><li>Key的分布，也在某种程度上决定了Reduce数目，所以要根据Key的特点设计相对应的Parttitioner 避免数据倾斜</li></ul> 
<h4><a id="9Mapside_431"></a>9.Map-side相关参数优化</h4> 
<ul><li>io.sort.mb（100MB）：通常k个map tasks会对应一个buffer，buffer主要用来缓存map部分计算结果，并做一些预排序提高map性能，若map输出结果较大，可以调高这个参数，减少map任务进行spill任务个数，降低 I/O的操作次数。若map任务的瓶颈在I/O的话，那么将会大大提高map性能。如何判断map任务的瓶颈？</li><li>io.sort.spill.percent(0.8)：spill操作就是当内存buffer超过一定阈值（这里通常是百分比）的时候，会将buffer中得数据写到Disk中。而不是等buffer满后在spill，否则会造成map的计算任务等待buffer的释放。一般来说，调整 io.sort.mb而不是这个参数。</li><li>io.sort.factor（10）：map任务会产生很多的spill文件，而map任务在正常退出之前会将这些spill文件合并成一个文件，即merger过程，缺省是一次合并10个参数，调大io.sort.factor，减少merge的次数，减少Disk I/O操作，提高map性能。</li><li>min.num.spill.for.combine：通常为了减少map和reduce数据传输量，我们会制定一个combiner，将map结果进行本地聚集。这里combiner可能在merger之前，也可能在其之后。那么什么时候在其之前呢？当spill个数至少为min.num.spill.for.combine指定的数目时同时程序指定了Combiner，Combiner会在其之前运行，减少写入到Disk的数据量，减少I/O次数。</li></ul> 
<h4><a id="10_437"></a>10.压缩（时间换空间）</h4> 
<ul><li>MR中的数据无论是中间数据还是输入输出结果都是巨大的，若不使用压缩不仅浪费磁盘空间且会消耗大量网络带宽。同样在spill，merge（reduce也对有一个merge）亦可以使用压缩。若想在cpu时间和压缩比之间寻找一个平衡，LzoCodec比较适合。通常MR任务的瓶颈不在CPU而在于I/O，所以大部分的MR任务都适合使用压缩。</li></ul> 
<h4><a id="11_reduceside_440"></a>11. reduce-side相关参数优化</h4> 
<ul><li>reduce：copy-&gt;sort-&gt;reduce，也称shuffle</li><li>mapred.reduce.parellel.copies（5）：任一个map任务可能包含一个或者多个reduce所需要数据，故一个map任务完成后，相应的reduce就会立即启动线程下载自己所需要的数据。调大这个参数比较适合map任务比较多且完成时间比较短的Job。</li><li>mapred.reduce.copy.backoff：reduce端从map端下载数据也有可能由于网络故障，map端机器故障而失败。那么reduce下载线程肯定不会无限等待，当等待时间超过mapred.reduce.copy.backoff时，便放弃，尝试从其他地方下载。需注意：在网络情况比较差的环境，我们需要调大这个参数，避免reduce下载线程被误判为失败。</li><li>io.sort.factor：recude将map结果下载到本地时，亦需要merge，如果reduce的瓶颈在于I/O，可尝试调高增加merge的并发吞吐，提高reduce性能、</li><li>mapred.job.shuffle.input.buffer.percent（0.7）：reduce从map下载的数据不会立刻就写到Disk中，而是先缓存在内存中，mapred.job.shuffle.input.buffer.percent指定内存的多少比例用于缓存数据，内存大小可通过mapred.child.java.opts来设置。和map类似，buffer不是等到写满才往磁盘中写，也是到达阈值就写，阈值由mapred.job,shuffle.merge.percent来指定。若Reduce下载速度很快，容易内存溢出，适当增大这个参数对增加reduce性能有些帮助。</li><li>mapred.job.reduce.input.buffer.percent (0)：当Reduce下载map数据完成之后，就会开始真正的reduce的计算，reduce的计算必然也是要消耗内存的，那么在读物reduce所需要的数据时，同样需要内存作为buffer，这个参数是决定多少的内存百分比作为buffer。默认为0，也就是说reduce全部从磁盘读数据。若redcue计算任务消耗内存很小，那么可以设置这个参数大于0，使一部分内存用来缓存数据。</li></ul> 
<h4><a id="13___447"></a>13 从应用程序角度进行优化</h4> 
<ul><li>解答： 
  <ul><li>（1） 避免不必要的reduce任务<br> 如果mapreduce程序中reduce是不必要的，那么我们可以在map中处理数据, Reducer设置为0。这样避免了多余的reduce任务。</li><li>（2） 为job添加一个Combiner<br> 为job添加一个combiner可以大大减少shuffle阶段从map task拷贝给远程reduce task的数据量。一般而言，combiner与reducer相同。</li><li>（3） 根据处理数据特征使用最适合和简洁的Writable类型<br> Text对象使用起来很方便，但它在由数值转换到文本或是由UTF8字符串转换到文本时都是低效的，且会消耗大量的CPU时间。当处理那些非文本的数据时，可以使用二进制的Writable类型，如IntWritable， FloatWritable等。二进制writable好处：避免文件转换的消耗；使map task中间结果占用更少的空间。</li><li>（4） 重用Writable类型<br> 很多MapReduce用户常犯的一个错误是，在一个map/reduce方法中为每个输出都创建Writable对象。例如，你的Wordcout mapper方法可能这样写：</li></ul> </li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  …
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> word <span class="token operator">:</span> words<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    output<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
这样会导致程序分配出成千上万个短周期的对象。<span class="token class-name">Java</span>垃圾收集器就要为此做很多的工作。更有效的写法是：
<span class="token keyword">class</span> <span class="token class-name">MyMapper</span> … <span class="token punctuation">{<!-- --></span>
  <span class="token class-name">Text</span> wordText <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">IntWritable</span> one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token operator">:</span> words<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      wordText<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>
      output<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>wordText<span class="token punctuation">,</span> one<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>（5） 使用StringBuffer而不是String<br> 当需要对字符串进行操作时，使用StringBuffer而不是String，String是read-only的，如果对它进行修改，会产生临时对象，而StringBuffer是可修改的，不会产生临时对象。</li></ul> 
<h2><a id="datanode_480"></a>datanode在什么情况下不会备份</h2> 
<ul><li>解答： 
  <ul><li>当备份数为1时。</li></ul> </li></ul> 
<h2><a id="combiner_483"></a>combiner出现在那个过程</h2> 
<ul><li>解答： 
  <ul><li><code>出现在map阶段的map方法后</code></li></ul> </li></ul> 
<h2><a id="3datanodedatanode_486"></a>3个datanode中有一个datanode出现错误会怎样？</h2> 
<ul><li><code>这个datanode的数据会在其他的datanode上重新做备份。</code></li></ul> 
<h2><a id="hadoop__namenode__488"></a>hadoop 的 namenode 宕机,怎么解决</h2> 
<ul><li>解答： 
  <ul><li>先分析宕机后的损失，宕机后直接导致client无法访问，内存中的元数据丢失，但是硬盘中的元数据应该还存在，如果只是节点挂了，重启即可，如果是机器挂了，重启机器后看节点是否能重启，不能重启就要找到原因修复了。但是最终的解决方案应该是在设计集群的初期就考虑到这个问题，做namenode的HA。</li></ul> </li></ul> 
<h2><a id="datanode__491"></a>一个datanode 宕机,怎么一个流程恢复</h2> 
<ul><li>解答：</li><li>Datanode宕机了后，如果是<code>短暂的宕机，可以实现写好脚本监控，将它启动起来</code>。如果是<code>长时间宕机了，那么datanode上的数据应该已经被备份到其他机器了，那这台datanode就是一台新的datanode了，删除他的所有数据文件和状态文件，重新启动。</code></li></ul> 
<h2><a id="_hadoop__494"></a>请简述 hadoop 怎么样实现二级排序？</h2> 
<ul><li>解答： 
  <ul><li>在Reduce阶段，先对Key排序，再对Value排序</li><li>最常用的方法是<code>将Value放到Key中，实现一个组合Key</code>，然后<code>自定义Key排序规则</code>（为Key实现一个WritableComparable）。</li></ul> </li></ul> 
<h2><a id="MapReducejoin12_498"></a>如何使用MapReduce实现两个表join，可以考虑一下几种情况：（1）一个表大，一个表小（可放到内存中）；（2）两个表都是大表？</h2> 
<ul><li>解答： 
  <ul><li>第一种情况比较简单，<code>只需将小表放到DistributedCache中即可；</code></li><li>第二种情况常用的方法有：<code>map-side join（要求输入数据有序，通常用户Hbase中的数据表连接），reduce-side join，semi join（半连接）</code></li></ul> </li></ul> 
<h2><a id="MapReduce_502"></a>MapReduce中排序发生在哪几个阶段？这些排序是否可以避免？为什么？</h2> 
<ul><li>解答： 
  <ul><li>一个MapReduce作业由Map阶段和Reduce阶段两部分组成，这两阶段会对数据排序，从这个意义上说，MapReduce框架本质就是一个Distributed Sort。在Map阶段，在Map阶段，<code>Map Task会在本地磁盘输出一个按照key排序（采用的是快速排序）的文件（中间可能产生多个文件，但最终会合并成一个）</code>，在Reduce阶段，每个<code>Reduce Task会对收到的数据排序，这样，数据便按照Key分成了若干组，之后以组为单位交给reduce（）处理</code>。很多人的误解在Map阶段，如果不使用Combiner便不会排序，这是错误的，<code>不管你用不用Combiner，Map Task均会对产生的数据排序（如果没有Reduce Task，则不会排序， 实际上Map阶段的排序就是为了减轻Reduce端排序负载</code>）。由于这些排序是MapReduce自动完成的，用户无法控制，因此，在hadoop 1.x中无法避免，也不可以关闭，但hadoop2.x是可以关闭的。</li></ul> </li></ul> 
<h2><a id="_mapreduce_combinerpartition__505"></a>请简述 mapreduce 中，combiner，partition 作用？</h2> 
<ul><li>解答：</li><li><code>combiner是reduce的实现，在map端运行计算任务，减少map端的输出数据</code>。 
  <ul><li>作用就是优化。</li><li><code>但是combiner的使用场景是mapreduce的map输出结果和reduce输入输出一样</code>。</li></ul> </li><li>partition的默认实现是<code>hashpartitio</code>n，是<code>map端将数据按照reduce个数取余，进行分区，不同的reduce来copy自己的数据。</code> 
  <ul><li>partition的作用是<code>将数据分到不同的reduce进行计算，加快计算效果</code>。</li></ul> </li><li>1、<code>combiner最基本是实现本地key的聚合，对map输出的key排序，value进行迭代</code>。如下所示： 
  <ul><li>map: (K1, V1) → list(K2, V2)</li><li>combine: (K2, list(V2)) → list(K2, V2)</li><li>reduce: (K2, list(V2)) → list(K3, V3)</li></ul> </li><li>2、<code>combiner还具有类似本地的reduce功能.</code> 
  <ul><li>例如hadoop自带的wordcount的例子和找出value的最大值的程序，combiner和reduce完全一致。如下所示：</li><li>map: (K1, V1) → list(K2, V2)</li><li>combine: (K2, list(V2)) → list(K3, V3)</li><li>reduce: (K3, list(V3)) → list(K4, V4)</li></ul> </li><li>3、<code>如果不用combiner，那么，所有的结果都是reduce完成，效率会相对低下。使用combiner，先完成的map会在本地聚合，提升速度。</code></li><li>4、<code>对于hadoop自带的wordcount的例子，value就是一个叠加的数字，所以map一结束就可以进行reduce的value叠加，而不必要等到所有的map结束再去进行reduce的value叠加。</code> 
  <ul><li>combiner使用的合适，可以在满足业务的情况下提升job的速度，<code>如果不合适，则将导致输出的结果不正确。</code></li></ul> </li></ul> 
<h2><a id="mapreduce_524"></a>用mapreduce怎么处理数据倾斜问题？</h2> 
<ul><li>解答： 
  <ul><li>数据倾斜：map /reduce程序执行时，reduce节点大部分执行完毕，但是有一个或者几个reduce节点运行很慢，导致整个程序的处理时间很长，这是因为某一个key的条数比其他key多很多（有时是百倍或者千倍之多），<code>这条key所在的reduce节点所处理的数据量比其他节点就大很多，从而导致某几个节点迟迟运行不完，此称之为数据倾斜</code>。</li></ul> </li><li>用hadoop程序进行数据关联时，常碰到数据倾斜的情况，这里提供一种解决方法。 
  <ul><li><code>自己实现partition类，用key和value相加取hash值：</code></li></ul> </li><li>方式1：</li><li>源代码：</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getPartition</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span>
                          <span class="token keyword">int</span> numReduceTasks<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span> <span class="token operator">%</span> numReduceTasks<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> 
<ul><li>修改后</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getPartition</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span>
                          <span class="token keyword">int</span> numReduceTasks<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>（key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>value<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>） <span class="token operator">&amp;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span> <span class="token operator">%</span> numReduceTasks<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> 
<ul><li>方式2：</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashPartitioner</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Partitioner</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span> <span class="token keyword">int</span> aa<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">/** Use {@link Object#hashCode()} to partition. */</span>
  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getPartition</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span>
                         <span class="token keyword">int</span> numReduceTasks<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>aa<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span> <span class="token operator">%</span> numReduceTasks<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> 
<h2><a id="hadoopCombiner_559"></a>hadoop中Combiner的作用?</h2> 
<ul><li>解答： 
  <ul><li>combiner是reduce的实现，在map端运行计算任务，<code>减少map端的输出数据</code>。</li><li>作用就是<code>优化</code>。</li><li>但是<code>combiner的使用场景是mapreduce的map和reduce输入输出一样。</code></li></ul> </li></ul> 
<h2><a id="Mapreduce__map___reduce____564"></a>Mapreduce 的 map 数量 和 reduce 数量 怎么确定 ,怎么配置</h2> 
<ul><li>解答： 
  <ul><li><code>map的数量有数据块决定，reduce数量随便配置</code>。</li></ul> </li></ul> 
<h2><a id="hadoop_567"></a>在hadoop中文件的压缩带来了两大好处：</h2> 
<ul><li>解答： 
  <ul><li>（1）它<code>减少了存储文件所需的空间</code>；</li><li>（2）<code>加快了数据在网络上或者从磁盘上或到磁盘上的传输速度</code>；</li></ul> </li></ul> 
<h2><a id="mapreduce_571"></a>mapreduce的调度模式（)</h2> 
<ul><li>解答：</li><li>一个MapReduce作业的生命周期大体分为5个阶段 【1】 ： 
  <ul><li>1.<code>作业提交与初始化</code></li><li>2.<code>任务调度与监控</code></li><li>3.<code>任务运行环境准备</code></li><li>4.<code>任务执行</code></li><li>5.<code>作业完成</code></li></ul> </li><li>我们假设JobTracker已经启动，那么调度器是怎么启动的？JobTracker在启动时有以下代码：</li></ul> 
<pre><code class="prism language-java"><span class="token class-name">JobTracker</span> tracker <span class="token operator">=</span> <span class="token function">startTracker</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JobConf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
tracker<span class="token punctuation">.</span><span class="token function">offerService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>其中offerService方法负责启动JobTracker提供的各个服务，有这样一行代码：</li></ul> 
<pre><code class="prism language-java">taskScheduler<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>taskScheduler即为任务调度器。start方法是抽象类TaskScheduler提供的接口，用于启动调度器。每个调度器类都要继承TaskScheduler类。回忆一下，调度器启动时会将各个监听器对象注册到JobTracker，以FIFO调度器JobQueueTaskScheduler为例：</li></ul> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    taskTrackerManager<span class="token punctuation">.</span><span class="token function">addJobInProgressListener</span><span class="token punctuation">(</span>jobQueueJobInProgressListener<span class="token punctuation">)</span><span class="token punctuation">;</span>
    eagerTaskInitializationListener<span class="token punctuation">.</span><span class="token function">setTaskTrackerManager</span><span class="token punctuation">(</span>taskTrackerManager<span class="token punctuation">)</span><span class="token punctuation">;</span>
    eagerTaskInitializationListener<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    taskTrackerManager<span class="token punctuation">.</span><span class="token function">addJobInProgressListener</span><span class="token punctuation">(</span>
        eagerTaskInitializationListener<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> 
<ul><li>这里注册了两个监听器，其中eagerTaskInitializationListener负责作业初始化，而jobQueueJobInProgressListener则负责作业的执行和监控。当有作业提交到JobTracker时，JobTracker会执行所有订阅它消息的监听器的jobAdded方法。对于eagerTaskInitializationListener来说：</li></ul> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">jobAdded</span><span class="token punctuation">(</span><span class="token class-name">JobInProgress</span> job<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>jobInitQueue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      jobInitQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">resortInitQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      jobInitQueue<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> 
<ul><li>提交的作业的JobInProgress对象被添加到作业初始化队列jobInitQueue中，并唤醒初始化线程（若原来没有作业可以初始化）：</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">JobInitManager</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token class-name">JobInProgress</span> job <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
       <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
          <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>jobInitQueue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>jobInitQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
              jobInitQueue<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            job <span class="token operator">=</span> jobInitQueue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InitJob</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token constant">LOG</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"JobInitManagerThread interrupted."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      threadPool<span class="token punctuation">.</span><span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> 
<ul><li>这种工作方式是一种“生产者-消费者”模式：作业初始化线程是消费者，而监听器eagerTaskInitializationListener是生产者。这里可以有多个消费者线程，放到一个固定资源的线程池中，线程个数通过mapred.jobinit.threads参数配置，默认为4个。</li><li>下面我们重点来看调度器中的另一个监听器。 jobQueueJobInProgressListener对象在调度器中初始化时连续执行了两个构造器完成初始化：</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">JobQueueJobInProgressListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">JobSchedulingInfo</span><span class="token punctuation">,</span>
                     <span class="token class-name">JobInProgress</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token constant">FIFO_JOB_QUEUE_COMPARATOR</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/**
   * For clients that want to provide their own job priorities.
   * @param jobQueue A collection whose iterator returns jobs in priority order.
   */</span>
  <span class="token keyword">protected</span> <span class="token class-name">JobQueueJobInProgressListener</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">JobSchedulingInfo</span><span class="token punctuation">,</span>
                                          <span class="token class-name">JobInProgress</span><span class="token punctuation">&gt;</span></span> jobQueue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>jobQueue <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedMap</span><span class="token punctuation">(</span>jobQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> 
<ul><li>其中，第一个构造器调用重载的第二个构造器。可以看到，调度器使用一个队列jobQueue来保存提交的作业。这个队列使用一个TreeMap对象实现，TreeMap的特点是底层使用红黑树实现，可以按照键来排序，并且由于是平衡树，效率较高。作为键的是一个JobSchedulingInfo对象，作为值就是提交的作业对应的JobInProgress对象。另外，由于TreeMap本身不是线程安全的，这里使用了集合类的同步方法构造了一个线程安全的Map。使用带有排序功能的数据结构的目的是使作业在队列中按照优先级的大小排列，这样每次调度器只需从队列头部获得作业即可。</li><li>作业的顺序由优先级决定，而优先级信息包含在JobSchedulingInfo对象中：</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">JobSchedulingInfo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">JobPriority</span> priority<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> startTime<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">JobID</span> id<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>该对象包含了作业的优先级、ID和开始时间等信息。在Hadoop中，作业的优先级有以下五种：VERY_HIGH、HIGH、NORMAL、LOW、VERY_LOW。这些字段是通过作业的JobStatus对象初始化的。由于该对象作为TreeMap的键，因此要实现自己的equals方法和hashCode方法：</li></ul> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token class-name">JobSchedulingInfo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">JobSchedulingInfo</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">JobSchedulingInfo</span> that <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">JobSchedulingInfo</span><span class="token punctuation">)</span>obj<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>startTime <span class="token operator">==</span> that<span class="token punctuation">.</span>startTime <span class="token operator">&amp;&amp;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>priority <span class="token operator">==</span> that<span class="token punctuation">.</span>priority<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<ul><li>我们看到，两个JobSchedulingInfo对象相等的条件是类型一致，并且作业ID、开始时间和优先级都相等。hashCode的计算比较简单：</li></ul> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>id<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> priority<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<ul><li>注意，监听器的第一个构造器有一个比较器参数，用于定义 JobSchedulingInfo的比较方式：</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">JobSchedulingInfo</span><span class="token punctuation">&gt;</span></span> <span class="token constant">FIFO_JOB_QUEUE_COMPARATOR</span>
    <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">JobSchedulingInfo</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">JobSchedulingInfo</span> o1<span class="token punctuation">,</span> <span class="token class-name">JobSchedulingInfo</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">int</span> res <span class="token operator">=</span> o1<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>o2<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>o1<span class="token punctuation">.</span><span class="token function">getStartTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> o2<span class="token punctuation">.</span><span class="token function">getStartTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
          res <span class="token operator">=</span> <span class="token punctuation">(</span>o1<span class="token punctuation">.</span><span class="token function">getStartTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> o2<span class="token punctuation">.</span><span class="token function">getStartTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        res <span class="token operator">=</span> o1<span class="token punctuation">.</span><span class="token function">getJobID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>o2<span class="token punctuation">.</span><span class="token function">getJobID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>从上面看出，首先比较作业的优先级，若优先级相等则比较开始时间（FIFO），若再相等则比较作业ID。 我们在实现自己的调度器时可能要定义自己的作业队列，那么作业在队列中的顺序（即 JobSchedulingInfo的比较器 ）就要仔细定义，这是调度器能够正常运行基础。</li><li>Hadoop中的作业调度采用pull方式，即TaskTracker定时向JobTracker发送心跳信息索取一个新的任务，这些信息包括数据结点上作业和任务的运行情况，以及该TaskTracker上的资源使用情况。JobTracker会依据以上信息更新作业队列的状态，并调用调度器选择一个或多个任务以心跳响应的形式返回给TaskTracker。从上面描述可以看出，JobTracker和taskScheduler之间的互相利用关系：前者利用后者为TaskTracker分配任务；后者利用前者更新队列和作业信息。接下来，我们一步步详述该过程。</li><li>首先，当一个心跳到达JobTracker时（实际上这是一个来自TaskTracker的远程过程调用 heartbeat方法 ，协议接口是InterTrackerProtocol），会执行两种动作：更新状态和下达命令 【1】 。下达命令稍后关注。有关更新状态的一些代码片段如下：</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">processHeartbeat</span><span class="token punctuation">(</span>status<span class="token punctuation">,</span> initialContact<span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>prevHeartbeatResponse <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        trackerToHeartbeatResponseMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>trackerName<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HeartbeatResponse</span><span class="token punctuation">(</span>newResponseId<span class="token punctuation">,</span>
                   <span class="token keyword">new</span> <span class="token class-name">TaskTrackerAction</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span><span class="token keyword">new</span> <span class="token class-name">ReinitTrackerAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<ul><li>具体的心跳处理，由私有函数processHeartbeat完成。该函数中有以下两个方法调用：</li></ul> 
<pre><code class="prism language-java"><span class="token function">updateTaskStatuses</span><span class="token punctuation">(</span>trackerStatus<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">updateNodeHealthStatus</span><span class="token punctuation">(</span>trackerStatus<span class="token punctuation">,</span> timeStamp<span class="token punctuation">)</span><span class="token punctuation">;</span>
分别用来更新任务的状态和结点的健康状态。在第一个方法中有下面代码片段：
<span class="token class-name">TaskInProgress</span> tip <span class="token operator">=</span> taskidToTIPMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>taskId<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// Check if the tip is known to the jobtracker. In case of a restarted</span>
      <span class="token comment">// jt, some tasks might join in later</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>tip <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token function">hasRestarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tip <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          tip <span class="token operator">=</span> job<span class="token punctuation">.</span><span class="token function">getTaskInProgress</span><span class="token punctuation">(</span>taskId<span class="token punctuation">.</span><span class="token function">getTaskID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          job<span class="token punctuation">.</span><span class="token function">addRunningTaskToTIP</span><span class="token punctuation">(</span>tip<span class="token punctuation">,</span> taskId<span class="token punctuation">,</span> status<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// Update the job and inform the listeners if necessary</span>
        <span class="token class-name">JobStatus</span> prevStatus <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">JobStatus</span><span class="token punctuation">)</span>job<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// Clone TaskStatus object here, because JobInProgress</span>
        <span class="token comment">// or TaskInProgress can modify this object and</span>
        <span class="token comment">// the changes should not get reflected in TaskTrackerStatus.</span>
        <span class="token comment">// An old TaskTrackerStatus is used later in countMapTasks, etc.</span>
        job<span class="token punctuation">.</span><span class="token function">updateTaskStatus</span><span class="token punctuation">(</span>tip<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">TaskStatus</span><span class="token punctuation">)</span>report<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">JobStatus</span> newStatus <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">JobStatus</span><span class="token punctuation">)</span>job<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// Update the listeners if an incomplete job completes</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>prevStatus<span class="token punctuation">.</span><span class="token function">getRunState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> newStatus<span class="token punctuation">.</span><span class="token function">getRunState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token class-name">JobStatusChangeEvent</span> event <span class="token operator">=</span>
            <span class="token keyword">new</span> <span class="token class-name">JobStatusChangeEvent</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token class-name">EventType</span><span class="token punctuation">.</span><span class="token constant">RUN_STATE_CHANGED</span><span class="token punctuation">,</span>
                                     prevStatus<span class="token punctuation">,</span> newStatus<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">updateJobInProgressListeners</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token constant">LOG</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Serious problem.  While updating status, cannot find taskid "</span>
                 <span class="token operator">+</span> report<span class="token punctuation">.</span><span class="token function">getTaskID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
</code></pre> 
<ul><li>这里的job对象通过从TaskTracker那里得到的task状态信息中抽取出来。注意，这里拷贝了原有作业状态的一个副本，然后修改这个副本的相关信息，调用的是updateJobStatus方法，更新任务的状态信息和JobInProgress的相关信息，如map和reduce任务的进度等，这里不展开了。这些信息的更新可以为调度器的工作提供依据。</li><li>作业状态的更新是通过updateJobInProgressListeners方法实现，该方法的参数是一个JobStatusChangeEvent对象，表示作业状态变化的事件。这种事件的类型可以是运行状态改变、开始时间改变、优先级改变等等。用户也可以根据需要自定义事件类型。事件对象维护了两个JobStatus对象，分别表示事件发生前后作业的状态。</li><li>进入该方法后，我们又看到了熟悉的观察者模式：</li></ul> 
<pre><code class="prism language-java"><span class="token comment">// Update the listeners about the job</span>
  <span class="token comment">// Assuming JobTracker is locked on entry.</span>
  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">updateJobInProgressListeners</span><span class="token punctuation">(</span><span class="token class-name">JobChangeEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">JobInProgressListener</span> listener <span class="token operator">:</span> jobInProgressListeners<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      listener<span class="token punctuation">.</span><span class="token function">jobUpdated</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> 
<ul><li>这次每个监听器要回调jobUpdated方法，表示作业有更新。对于jobQueueJobInProgressListener来说是这样做的：</li></ul> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">jobUpdated</span><span class="token punctuation">(</span><span class="token class-name">JobChangeEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">JobInProgress</span> job <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">getJobInProgress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>event <span class="token keyword">instanceof</span> <span class="token class-name">JobStatusChangeEvent</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// Check if the ordering of the job has changed</span>
      <span class="token comment">// For now priority and start-time can change the job ordering</span>
      <span class="token class-name">JobStatusChangeEvent</span> statusEvent <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">JobStatusChangeEvent</span><span class="token punctuation">)</span>event<span class="token punctuation">;</span>
      <span class="token class-name">JobSchedulingInfo</span> oldInfo <span class="token operator">=</span> 
        <span class="token keyword">new</span> <span class="token class-name">JobSchedulingInfo</span><span class="token punctuation">(</span>statusEvent<span class="token punctuation">.</span><span class="token function">getOldStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>statusEvent<span class="token punctuation">.</span><span class="token function">getEventType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">EventType</span><span class="token punctuation">.</span><span class="token constant">PRIORITY_CHANGED</span>
          <span class="token operator">||</span> statusEvent<span class="token punctuation">.</span><span class="token function">getEventType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">EventType</span><span class="token punctuation">.</span><span class="token constant">START_TIME_CHANGED</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// Make a priority change</span>
        <span class="token function">reorderJobs</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> oldInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>statusEvent<span class="token punctuation">.</span><span class="token function">getEventType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">EventType</span><span class="token punctuation">.</span><span class="token constant">RUN_STATE_CHANGED</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// Check if the job is complete</span>
        <span class="token keyword">int</span> runState <span class="token operator">=</span> statusEvent<span class="token punctuation">.</span><span class="token function">getNewStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRunState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>runState <span class="token operator">==</span> <span class="token class-name">JobStatus</span><span class="token punctuation">.</span><span class="token constant">SUCCEEDED</span>
            <span class="token operator">||</span> runState <span class="token operator">==</span> <span class="token class-name">JobStatus</span><span class="token punctuation">.</span><span class="token constant">FAILED</span>
            <span class="token operator">||</span> runState <span class="token operator">==</span> <span class="token class-name">JobStatus</span><span class="token punctuation">.</span><span class="token constant">KILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token function">jobCompleted</span><span class="token punctuation">(</span>oldInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> 
<ul><li>首先，获取作业更新 前 的状态。然后根据事件的类型，进行相应的处理。比如，如果优先级变化了，则要重新排列队列中作业的顺序。这里直接取出原有作业，重新插入队列。插入后，作业会自动重新排序，体现了TreeMap的优越性。再比如，如果作业状态变为完成，那么就从队列中删除该作业。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">reorderJobs</span><span class="token punctuation">(</span><span class="token class-name">JobInProgress</span> job<span class="token punctuation">,</span> <span class="token class-name">JobSchedulingInfo</span> oldInfo<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>jobQueue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      jobQueue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>oldInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
      jobQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JobSchedulingInfo</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span><span class="token punctuation">,</span> job<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> 
<ul><li>下面就是调度器中最关键的一步了：任务选择。此时，作业队列中信息已经更新完毕，可以选择一些任务返回给TaskTracker执行了。heartbeat方法接下来会有这样的代码：</li></ul> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Task</span><span class="token punctuation">&gt;</span></span> tasks <span class="token operator">=</span> <span class="token function">getSetupAndCleanupTasks</span><span class="token punctuation">(</span>taskTrackerStatus<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>tasks <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    tasks <span class="token operator">=</span> taskScheduler<span class="token punctuation">.</span><span class="token function">assignTasks</span><span class="token punctuation">(</span>taskTrackers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>trackerName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> 
<h2><a id="Hadoop_837"></a>Hadoop的三大分布式模块及功能分别是什么？</h2> 
<ul><li>解答: 
  <ul><li>1.<code>HDFS:分布式文件系统</code> 
    <ul><li>实现大数据的<code>存储</code></li><li>提供高吞吐量的数据访问</li></ul> </li><li>2.<code>MapReduce:分布式计算模型</code> 
    <ul><li>用于并行化处理大量数量,基于yarn</li></ul> </li><li>3.<code>Yarn:分布式资源管理和任务调度框架 </code> 
    <ul><li>对外提供统一的运行资源平台</li><li>负责给yarn中运行的程序提供资源</li><li>决定多个程序运行顺序及所需资源</li></ul> </li></ul> </li></ul> 
<h2><a id="Hadoop_848"></a>什么情况下需要编译Hadoop？</h2> 
<ul><li>解答: 
  <ul><li>1.<code>官方版本有阉割,部分功能缺失</code></li><li>2.<code>对官方版本的某些功能不满意</code></li></ul> </li></ul> 
<h2><a id="SecondaryNameNode_852"></a>SecondaryNameNode</h2> 
<p><img src="https://images2.imgbox.com/75/6d/RteQ8WeI_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="hdfs_855"></a>hdfs写流程</h2> 
<ul><li>流程：</li><li>1-客户端读取配置文件，找到NameNode的地址</li><li>2-客户端向NameNode发送写入请求</li><li>3-NameNode会检查是否允许写入将确认同意写入的，结果返回给客户端 
  <ul><li>检查文件是否存在</li><li>是否有权限</li><li>存储路径是否存在</li><li>有没有DataNode可以存储</li></ul> </li><li>4-客户端会将大文件进行拆分成若干个小文件</li><li>5-提交第一个块写入的请求给NameNode</li><li>6-NameNode根据当前集群的情况以及副本的个数，返回三台DataNode的地址 
  <ul><li>NameNode会根据副本：3份</li><li>根据机架感知做基本计算： 
    <ul><li>如果客户端所在的机器也是DataNode会存储一份 
      <ul><li>以后如果客户端这台机器进行读的时候，可以直接从本机快速读取</li></ul> </li><li>与客户端在同一个机架的另外一台机器也会存储一份 
      <ul><li>如果客户端这台机器宕机，从同机架获取这个块，是最快的</li></ul> </li><li>另外一个机架的一台机器也会存储一份 
      <ul><li>如果第一个机架全部宕机，另外一个机架照样有一份可以用</li></ul> </li></ul> </li></ul> </li><li>7-客户端拿到这三台DataNode的地址，通过机架感知，选择最近的一台进行写入块</li><li>8-客户端将整个块分成很多小的部分，每个部分挨个发送给DataNode</li><li>9-最近的DataNode接受到写入请求，将这个数据同步给其他两个DataNode</li><li>10-所有的DataNode写入完成逐级返回ack确认，客户端接受到ack，发送下一个小的部分，直到整个块发送完成</li><li>11-客户端重复第5步，提交下一个块的写入请求，直到整个文件所有块写完成<img src="https://images2.imgbox.com/e1/dd/ui3xc2Gn_o.png" alt="在这里插入图片描述"></li></ul> 
<h2><a id="hdfs_880"></a>hdfs读流程</h2> 
<ul><li>1-客户端向NameNode请求读取一个文件</li><li>2-NameNode检查元数据</li><li>3-返回这个文件对应的所有的块的所有的DataNode地址</li><li>4-客户端根据地址列表，计算出每个块离自己最近的那台DataNode</li><li>5-到离自己最近的每台机器，取对应的块</li><li>6-将每个块进行合并<img src="https://images2.imgbox.com/b9/77/numFZMBY_o.png" alt="在这里插入图片描述"></li></ul> 
<h2><a id="mapreduce__887"></a>举一个简单的例子说明mapreduce是怎么来运行的 ?</h2> 
<ul><li>Input：/wordcount/input/wordcount.txt 
  <ul><li><code>将每一行数据变成一个keyvalue</code></li><li><code>value就是这一行的内容</code></li></ul> </li><li>Map： 
  <ul><li>map：<code>将value进行分割，得到每个单词，将单词作为key，1作为value输出</code></li></ul> </li><li>Shuffle：自动实现的，不用管 
  <ul><li><mark>分组</mark>：按照单词做分组，<code>相同单词的value都在一个迭代器中</code></li><li><mark>排序</mark>：按照单词做排序</li></ul> </li><li>Reduce 
  <ul><li>reduce：<code>对每个单词的迭代器中进行聚合</code></li></ul> </li><li>Output：/wordcount/output4</li></ul> 
<h2><a id="mrshuffle_899"></a>mr之shuffle详解</h2> 
<p><img src="https://images2.imgbox.com/d9/3b/GD1ALYHk_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="mr_901"></a>mr流程图</h2> 
<p><img src="https://images2.imgbox.com/96/60/zFaYxI1f_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="yarn_904"></a>yarn流程</h2> 
<ul><li>1-客户端提交请求给RM</li><li>2-RM会随机选择一台机器启动这个程序的APPMaster ，负责管理这个程序</li><li>3-APPMaster启动以后会向RM申请资源和指令</li><li>4-RM将每台机器要启动的Task和能使用的资源封装在Container中返回给APPMaster</li><li>5-APPMaster会通知对应的NodeManager启动MapTask并执行</li><li>6-所有的MapTask执行完成通知APPMaster</li><li>7-APPMaster启动ReduceTask</li><li>8-Reduce到每个MapTask机器上取数据，执行处理</li><li>9-Reduce执行结束通知APPMaster</li><li>10-APPMaster将结果返回给ResourceManager<br> <img src="https://images2.imgbox.com/52/81/aIKXXoIm_o.png" alt="在这里插入图片描述"></li></ul> 
<h2><a id="HDFSHA_916"></a>HDFS的HA架构</h2> 
<p><img src="https://images2.imgbox.com/bf/f1/IMp2hT8x_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="VS_918"></a>行式存储VS列式存储</h2> 
<h4><a id="_919"></a>行式存储</h4> 
<ul><li>优点：insert/update比较方便</li><li>缺点： 
  <ul><li>不同类型数据存放在同一个block中，压缩性能不好；</li><li>针对条件是某列的查询会读取所有数据</li></ul> </li></ul> 
<h4><a id="_924"></a>列式存储</h4> 
<ul><li>优点： 
  <ul><li>同类型数据存放在同一个block中，压缩性能好</li><li>查询时只有涉及的列会被读取</li><li>任何列都能做为索引</li></ul> </li><li>缺点 
  <ul><li>针对全表查询，需要数据重组</li><li>insert/update比较麻烦<br> <img src="https://images2.imgbox.com/20/ed/gKYIaUBR_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h2><a id="HadoopDataNode_933"></a>Hadoop集群中其中一台DataNode节点的磁盘快满了怎么处理？</h2> 
<p>基本策略就是首先迁移数据，删除无用数据，都弄完还是不能满足，就只能加磁盘。</p> 
<ul><li>场景1: DN节点单块磁盘坏了 
  <ul><li>数据移走，移到空闲盘，然后做均衡让DN自己去识别</li></ul> </li><li>场景2:DN节点的所有盘都快满了 
  <ul><li>方法一：删除数据 ，rebalance</li><li>方法二：加磁盘，不能直接加，因为还是会往旧磁盘写数据，越写越多，需要调整往多磁盘写数据的策略，默认是轮询写，需要改为优先写剩余磁盘空间多的磁盘策略</li></ul> </li><li>场景3:应用程序误放在DN节点上，把系统盘或者数据盘占满了 
  <ul><li>联系应用owner，停程序，把数据移走，之后要么改程序要么做软连接</li></ul> </li><li>场景4:不要的数据 
  <ul><li>节点退集群后，直接删除</li></ul> </li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dfb68222c849da20cc477504426968ab/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STM32学习笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/42c3598948bbbc4c50ac6348336576c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【【Micro Blaze 的 最后补充 与 回顾 】】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>