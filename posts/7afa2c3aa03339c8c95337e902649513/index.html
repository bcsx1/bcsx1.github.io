<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>软件工程知识点汇总 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="软件工程知识点汇总" />
<meta property="og:description" content="目录 前言第1章 绪论1.1 软件和软件危机1.1.3 软件危机 1.2 软件工程学的范畴1.2.1 软件开发方法学 1.3 软件工程的发展1.3.1 3种编程范型 第2章 软件生存周期与软件过程2.1 软件生存周期2.2 传统的软件过程2.2.1 瀑布模型（大题常考）特点阶段缺点存在的问题 2.2.2 快速原型模型原型开发的优越性原型模型的启示 2.3 软件演化模型2.3.1 增量模型（incremental model）2.3.2 螺旋模型（spiral model）2.3.3 构件集成模型 2.4 形式化方法模型2.4.1 转换模型（transformational model）2.4.2 净室模型（cleanroom model） 2.5 统一过程和敏捷过程2.5.1 统一过程（Rational Unified Process,RUP）2.5.2 敏捷过程2.5.3 极限编程（extreme programming,XP） 2.6 软件可行性研究2.6.1 可行性研究的内容与步骤1. 研究的内容 2.6.2 软件风险分析 第3章 结构化分析与设计3.1 概述3.1.1 结构化分析与设计的由来结构化分析（structured analysis,SA）结构化设计（structured design,SD） 3.1.2 SA 模型的组成与描述1. SA 模型的组成2. SA 模型的描述工具(1) 数据流图（DFD）(2) 数据字典（DD）(3) 加工规格说明 3.1.3 SD 模型的组成与描述1. SD 模型的组成2. SD 模型的描述工具(1) SC 图的组成符号(2) SC 图的模块调用 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/7afa2c3aa03339c8c95337e902649513/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-08T23:56:59+08:00" />
<meta property="article:modified_time" content="2020-12-08T23:56:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">软件工程知识点汇总</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">前言</a></li><li><a href="#1__3" rel="nofollow">第1章 绪论</a></li><li><ul><li><a href="#11__4" rel="nofollow">1.1 软件和软件危机</a></li><li><ul><li><a href="#113__5" rel="nofollow">1.1.3 软件危机</a></li></ul> 
   </li><li><a href="#12__17" rel="nofollow">1.2 软件工程学的范畴</a></li><li><ul><li><a href="#121__19" rel="nofollow">1.2.1 软件开发方法学</a></li></ul> 
   </li><li><a href="#13__21" rel="nofollow">1.3 软件工程的发展</a></li><li><ul><li><a href="#131_3_22" rel="nofollow">1.3.1 3种编程范型</a></li></ul> 
  </li></ul> 
  </li><li><a href="#2__32" rel="nofollow">第2章 软件生存周期与软件过程</a></li><li><ul><li><a href="#21__33" rel="nofollow">2.1 软件生存周期</a></li><li><a href="#22__40" rel="nofollow">2.2 传统的软件过程</a></li><li><ul><li><a href="#221__41" rel="nofollow">2.2.1 瀑布模型（大题常考）</a></li><li><ul><li><a href="#_45" rel="nofollow">特点</a></li><li><a href="#_49" rel="nofollow">阶段</a></li><li><a href="#_59" rel="nofollow">缺点</a></li><li><a href="#_61" rel="nofollow">存在的问题</a></li></ul> 
    </li><li><a href="#222__63" rel="nofollow">2.2.2 快速原型模型</a></li><li><ul><li><a href="#_67" rel="nofollow">原型开发的优越性</a></li><li><a href="#_72" rel="nofollow">原型模型的启示</a></li></ul> 
   </li></ul> 
   </li><li><a href="#23__76" rel="nofollow">2.3 软件演化模型</a></li><li><ul><li><a href="#231_incremental_model_78" rel="nofollow">2.3.1 增量模型（incremental model）</a></li><li><a href="#232_spiral_model_80" rel="nofollow">2.3.2 螺旋模型（spiral model）</a></li><li><a href="#233__93" rel="nofollow">2.3.3 构件集成模型</a></li></ul> 
   </li><li><a href="#24__105" rel="nofollow">2.4 形式化方法模型</a></li><li><ul><li><a href="#241_transformational_model_110" rel="nofollow">2.4.1 转换模型（transformational model）</a></li><li><a href="#242_cleanroom_model_115" rel="nofollow">2.4.2 净室模型（cleanroom model）</a></li></ul> 
   </li><li><a href="#25__122" rel="nofollow">2.5 统一过程和敏捷过程</a></li><li><ul><li><a href="#251_Rational_Unified_ProcessRUP_128" rel="nofollow">2.5.1 统一过程（Rational Unified Process,RUP）</a></li><li><a href="#252__144" rel="nofollow">2.5.2 敏捷过程</a></li><li><a href="#253_extreme_programmingXP_149" rel="nofollow">2.5.3 极限编程（extreme programming,XP）</a></li></ul> 
   </li><li><a href="#26__167" rel="nofollow">2.6 软件可行性研究</a></li><li><ul><li><a href="#261__171" rel="nofollow">2.6.1 可行性研究的内容与步骤</a></li><li><ul><li><a href="#1__172" rel="nofollow">1. 研究的内容</a></li></ul> 
    </li><li><a href="#262__178" rel="nofollow">2.6.2 软件风险分析</a></li></ul> 
  </li></ul> 
  </li><li><a href="#3__182" rel="nofollow">第3章 结构化分析与设计</a></li><li><ul><li><a href="#31__186" rel="nofollow">3.1 概述</a></li><li><ul><li><a href="#311__187" rel="nofollow">3.1.1 结构化分析与设计的由来</a></li><li><ul><li><a href="#structured_analysisSA_197" rel="nofollow">结构化分析（structured analysis,SA）</a></li><li><a href="#structured_designSD_208" rel="nofollow">结构化设计（structured design,SD）</a></li></ul> 
    </li><li><a href="#312_SA__220" rel="nofollow">3.1.2 SA 模型的组成与描述</a></li><li><ul><li><a href="#1_SA__226" rel="nofollow">1. SA 模型的组成</a></li><li><a href="#2_SA__238" rel="nofollow">2. SA 模型的描述工具</a></li><li><ul><li><a href="#1_DFD_239" rel="nofollow">(1) 数据流图（DFD）</a></li><li><a href="#2_DD_251" rel="nofollow">(2) 数据字典（DD）</a></li><li><a href="#3__261" rel="nofollow">(3) 加工规格说明</a></li></ul> 
    </li></ul> 
    </li><li><a href="#313_SD__270" rel="nofollow">3.1.3 SD 模型的组成与描述</a></li><li><ul><li><a href="#1_SD__271" rel="nofollow">1. SD 模型的组成</a></li><li><a href="#2_SD__275" rel="nofollow">2. SD 模型的描述工具</a></li><li><ul><li><a href="#1_SC__279" rel="nofollow">(1) SC 图的组成符号</a></li><li><a href="#2_SC__281" rel="nofollow">(2) SC 图的模块调用</a></li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#33__283" rel="nofollow">3.3 结构化系统设计</a></li><li><ul><li><a href="#331_SD_284" rel="nofollow">3.3.1 SD概述</a></li><li><a href="#332_SDDFDSC_288" rel="nofollow">3.3.2 SD的步骤：从DFD图到SC图</a></li><li><ul><li><a href="#1__289" rel="nofollow">1. 数据流图的类型</a></li><li><ul><li><a href="#1__290" rel="nofollow">(1) 变换型结构</a></li><li><a href="#2__296" rel="nofollow">(2) 事务型结构</a></li></ul> 
    </li></ul> 
    </li><li><a href="#335_SC_300" rel="nofollow">3.3.5 优化初始SC图的指导规则</a></li><li><ul><li><a href="#1__301" rel="nofollow">1. 对模块划分的原则</a></li><li><a href="#2__303" rel="nofollow">2. 高扇入/低扇出的原则</a></li></ul> 
   </li></ul> 
   </li><li><a href="#34__310" rel="nofollow">3.4 模块设计</a></li><li><ul><li><a href="#341__311" rel="nofollow">3.4.1 目的与任务</a></li><li><a href="#342__316" rel="nofollow">3.4.2 模块设计的原则与方法</a></li><li><a href="#343__321" rel="nofollow">3.4.3 常用的表达工具</a></li></ul> 
  </li></ul> 
  </li><li><a href="#4_UML_329" rel="nofollow">第4章 面向对象与UML</a></li><li><ul><li><a href="#42_UML_330" rel="nofollow">4.2 UML简介</a></li><li><ul><li><a href="#421_UML_331" rel="nofollow">4.2.1 UML的组成</a></li><li><ul><li><a href="#1_UML_333" rel="nofollow">1. UML的模型元素</a></li><li><a href="#2_UML__348" rel="nofollow">2. UML 的元模型结构</a></li><li><ul><li><a href="#1__351" rel="nofollow">(1) 元元模型</a></li><li><a href="#2__355" rel="nofollow">(2) 元模型</a></li><li><a href="#3__359" rel="nofollow">(3) 模型</a></li><li><a href="#4__363" rel="nofollow">(4) 用户模型</a></li></ul> 
     </li><li><a href="#3__367" rel="nofollow">3. 图和视图</a></li><li><ul><li><a href="#1_diagram_368" rel="nofollow">(1) 图（diagram）</a></li><li><a href="#2_view_380" rel="nofollow">(2) 视图（view）</a></li></ul> 
    </li></ul> 
    </li><li><a href="#422_UML_382" rel="nofollow">4.2.2 UML的特点</a></li></ul> 
   </li><li><a href="#43__386" rel="nofollow">4.3 静态建模</a></li><li><ul><li><a href="#431__391" rel="nofollow">4.3.1 用例图与用例模型</a></li><li><ul><li><a href="#1__392" rel="nofollow">1. 组成符号</a></li><li><a href="#2__394" rel="nofollow">2. 建立用例图</a></li><li><a href="#3__396" rel="nofollow">3. 用例之间的关系</a></li><li><ul><li><a href="#1_extend_397" rel="nofollow">(1) 扩展关系（extend）</a></li><li><a href="#2_include_401" rel="nofollow">(2) 包含关系（include）</a></li></ul> 
    </li></ul> 
    </li><li><a href="#432__406" rel="nofollow">4.3.2 类图和对象图</a></li><li><ul><li><a href="#1__408" rel="nofollow">1. 类图和对象图</a></li></ul> 
    </li><li><a href="#433__424" rel="nofollow">4.3.3 包</a></li></ul> 
   </li><li><a href="#44__430" rel="nofollow">4.4 动态建模</a></li><li><ul><li><a href="#441__431" rel="nofollow">4.4.1 消息</a></li><li><a href="#442__439" rel="nofollow">4.4.2 状态图</a></li><li><a href="#443__444" rel="nofollow">4.4.3 时序图和协作图</a></li><li><ul><li><a href="#1__446" rel="nofollow">1. 时序/顺序图</a></li><li><a href="#2__451" rel="nofollow">2. 协作图</a></li></ul> 
    </li><li><a href="#444__456" rel="nofollow">4.4.4 活动图</a></li></ul> 
   </li><li><a href="#45__460" rel="nofollow">4.5 物理架构建模</a></li><li><ul><li><a href="#452__461" rel="nofollow">4.5.2 构件图和部署图</a></li></ul> 
   </li><li><a href="#46_UML_466" rel="nofollow">4.6 UML工具</a></li></ul> 
  </li><li><a href="#5__469" rel="nofollow">第5章 需求分析与建模</a></li><li><ul><li><a href="#51__473" rel="nofollow">5.1 软件需求工程</a></li><li><ul><li><a href="#511__474" rel="nofollow">5.1.1 软件需求的定义</a></li><li><a href="#512__486" rel="nofollow">5.1.2 软件需求的特性</a></li></ul> 
   </li><li><a href="#52__493" rel="nofollow">5.2 需求分析与建模</a></li><li><ul><li><a href="#521__495" rel="nofollow">5.2.1 需求分析的步骤</a></li></ul> 
   </li><li><a href="#53__503" rel="nofollow">5.3 需求获取的常用方法</a></li><li><ul><li><a href="#531__504" rel="nofollow">5.3.1 常规的需求获取方法</a></li><li><a href="#532__509" rel="nofollow">5.3.2 用快速原型法获取需求</a></li></ul> 
   </li><li><a href="#54__511" rel="nofollow">5.4 需求模型</a></li><li><ul><li><a href="#541__512" rel="nofollow">5.4.1 需求模型概述</a></li><li><ul><li><a href="#1__513" rel="nofollow">1. 结构化需求模型</a></li><li><a href="#2__519" rel="nofollow">2. 面向对象需求模型</a></li></ul> 
    </li><li><a href="#542__527" rel="nofollow">5.4.2 面向对象的需求建模</a></li></ul> 
   </li><li><a href="#55__542" rel="nofollow">5.5 软件需求描述</a></li><li><a href="#56__552" rel="nofollow">5.6 需求管理</a></li><li><ul><li><a href="#561__553" rel="nofollow">5.6.1 需求管理的内容</a></li><li><ul><li><a href="#1__554" rel="nofollow">1. 需求管理的特定实践</a></li><li><a href="#2__556" rel="nofollow">2. 需求变更的流程</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#6__566" rel="nofollow">第6章 面向对象分析</a></li><li><ul><li><a href="#61__567" rel="nofollow">6.1 软件分析概述</a></li><li><ul><li><a href="#611__568" rel="nofollow">6.1.1 面向对象软件分析</a></li><li><ul><li><a href="#1_OOA_570" rel="nofollow">1. OOA的主要任务</a></li><li><a href="#2_OOA_572" rel="nofollow">2. OOA的模型</a></li><li><a href="#3_OOA_575" rel="nofollow">3. OOA的优点</a></li><li><a href="#4__583" rel="nofollow">4. 分析模型的一般特点</a></li></ul> 
    </li><li><a href="#612__591" rel="nofollow">6.1.2 面向对象分析模型</a></li><li><ul><li><a href="#1__592" rel="nofollow">1. 典型的五层次模型</a></li></ul> 
   </li></ul> 
   </li><li><a href="#62__598" rel="nofollow">6.2 面向对象分析建模</a></li><li><ul><li><a href="#621__599" rel="nofollow">6.2.1 识别与确定分析类</a></li><li><ul><li><a href="#1__600" rel="nofollow">1. 分析类的类型</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#7__615" rel="nofollow">第7章 面向对象设计</a></li><li><ul><li><a href="#71__617" rel="nofollow">7.1 软件设计概述</a></li><li><ul><li><a href="#711__619" rel="nofollow">7.1.1 软件设计的概念</a></li><li><ul><li><a href="#1__620" rel="nofollow">1. 模块与构件</a></li><li><a href="#3__624" rel="nofollow">3. 信息隐藏</a></li></ul> 
    </li><li><a href="#713__628" rel="nofollow">7.1.3 模块化设计</a></li><li><ul><li><a href="#2__629" rel="nofollow">2. 模块独立性</a></li><li><ul><li><a href="#1__637" rel="nofollow">(1) 内聚</a></li><li><a href="#2__645" rel="nofollow">(2) 耦合</a></li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#72__654" rel="nofollow">7.2 面向对象设计建模</a></li><li><ul><li><a href="#721__655" rel="nofollow">7.2.1 面向对象设计模型</a></li><li><a href="#722__665" rel="nofollow">7.2.2 面向对象设计的任务</a></li><li><a href="#723__677" rel="nofollow">7.2.3 模式的应用</a></li></ul> 
   </li><li><a href="#73__683" rel="nofollow">7.3 系统架构设计</a></li><li><a href="#74__694" rel="nofollow">7.4 系统元素设计</a></li></ul> 
  </li><li><a href="#8__698" rel="nofollow">第8章 编码与测试</a></li><li><ul><li><a href="#84__699" rel="nofollow">8.4 测试的基本概念</a></li><li><ul><li><a href="#842__700" rel="nofollow">8.4.2 测试的特性</a></li><li><ul><li><a href="#1__701" rel="nofollow">1. 挑剔性</a></li><li><a href="#2__702" rel="nofollow">2. 复杂性</a></li><li><a href="#3__703" rel="nofollow">3. 不彻底性</a></li><li><a href="#4__705" rel="nofollow">4. 经济性</a></li></ul> 
   </li></ul> 
   </li><li><a href="#85__706" rel="nofollow">8.5 黑盒测试和白盒测试</a></li><li><ul><li><a href="#851__707" rel="nofollow">8.5.1 黑盒测试</a></li><li><ul><li><a href="#1_equivalence_partitioning_709" rel="nofollow">1. 等价分类法（equivalence partitioning）</a></li><li><a href="#2_boundary_value_analysis_710" rel="nofollow">2. 边界值分析法（boundary value analysis）</a></li><li><a href="#3_error_guessing_712" rel="nofollow">3. 错误猜测法（error guessing）</a></li></ul> 
    </li><li><a href="#852__713" rel="nofollow">8.5.2 白盒测试</a></li><li><ul><li><a href="#1__717" rel="nofollow">1. 逻辑覆盖测试法</a></li></ul> 
   </li></ul> 
   </li><li><a href="#87__726" rel="nofollow">8.7 多模块程序的测试策略</a></li><li><ul><li><a href="#871__727" rel="nofollow">8.7.1 测试的层次性</a></li><li><a href="#872__732" rel="nofollow">8.7.2 单元测试</a></li><li><a href="#873__736" rel="nofollow">8.7.3 集成测试</a></li><li><a href="#874__738" rel="nofollow">8.7.4 确认测试</a></li><li><a href="#875__742" rel="nofollow">8.7.5 系统测试</a></li></ul> 
  </li></ul> 
  </li><li><a href="#9__746" rel="nofollow">第9章 软件维护</a></li><li><ul><li><a href="#95__750" rel="nofollow">9.5. 软件配置管理</a></li><li><ul><li><a href="#2__751" rel="nofollow">2. 软件配置项</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_753" rel="nofollow">其它</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>前言</h2> 
<p>参考教材：《软件工程——原理、方法与应用》（第3版）</p> 
<h2><a id="1__3"></a>第1章 绪论</h2> 
<h3><a id="11__4"></a>1.1 软件和软件危机</h3> 
<h4><a id="113__5"></a>1.1.3 软件危机</h4> 
<p>软件危机指在计算机软件的开发和维护过程中所遇到的一系列严重问题。</p> 
<p>软件工程方法的产生源于软件危机，<mark>软件的复杂性</mark>是产生软件危机的内在原因。</p> 
<p>产生软件危机的原因：</p> 
<ul><li>软件维护费用急剧上升，直接威胁计算机应用的扩大。</li><li>软件生产技术进步缓慢，是加剧软件危机的重要原因。</li></ul> 
<p>Q：什么是软件危机？为什么会产生软件危机？<br> A：软件危机是指落后的软件生产方式无法满足迅速增长的软件需求，从而导致软件开发与维护过程中出现一系列问题现象。原因主要有：一，软件维护费用急剧上升，直接威胁计算机应用的扩大；二，软件生产技术进步缓慢。</p> 
<h3><a id="12__17"></a>1.2 软件工程学的范畴</h3> 
<p><img src="https://images2.imgbox.com/18/da/TiM5mhFE_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="121__19"></a>1.2.1 软件开发方法学</h4> 
<p>软件的发展，大体上经历了程序、软件和软件产品 3 个阶段。</p> 
<h3><a id="13__21"></a>1.3 软件工程的发展</h3> 
<h4><a id="131_3_22"></a>1.3.1 3种编程范型</h4> 
<ul><li>过程式编程范型：着眼于程序的过程和基本控制结构，粒度最小。</li><li>面向对象编程范型：着眼于程序中的对象，粒度比较大。</li><li>基于构件技术的编程范型：着眼于适合整个领域的类对象，粒度更大。</li></ul> 
<p>由上可见，编程范型的演变是伴随着编程粒度的扩大而推进的，这也标志着软件开发技术的不断成熟。</p> 
<p>Q：什么是软件生产工程化？工程化生产方法与早期的程序设计方法主要差别在哪里？<br> A：结构化程序设计的出现，使许多产业界认识到必须把软件生产从个人化方式改变为工程化。采用工程的概念、原理、技术和方法开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程，同时这也是工程化生产方法。</p> 
<h2><a id="2__32"></a>第2章 软件生存周期与软件过程</h2> 
<h3><a id="21__33"></a>2.1 软件生存周期</h3> 
<p>Q：什么是软件生存周期？把生存周期划分为阶段的目的是什么？<br> A：软件生存周期划分为计划、开发和运行三个时期；把整个生存周期划分为较小的阶段，给每个阶段赋予确定而有限的任务，就能够化简每一步工作内容，使因软件规模而增长而大大增加了软件复杂性得交易控制和管理。</p> 
<p>软件生存周期的主要活动：</p> 
<blockquote> 
 <p>需求分析 → 软件分析 → 软件设计 → 编码（测试）→ 软件测试 → 运行维护</p> 
</blockquote> 
<h3><a id="22__40"></a>2.2 传统的软件过程</h3> 
<h4><a id="221__41"></a>2.2.1 瀑布模型（大题常考）</h4> 
<p>瀑布开发模型是一种基于软件生存周期的线性开发模型。</p> 
<p><mark>瀑布模型</mark>的缺点是缺乏灵活性，特别是无法解决软件需求不明确或不准确的问题。</p> 
<h5><a id="_45"></a>特点</h5> 
<ul><li><mark>阶段间的顺序性和依赖性</mark></li><li><mark>推迟实现的观点</mark></li><li><mark>保证质量的观点</mark></li></ul> 
<h5><a id="_49"></a>阶段</h5> 
<ul><li><mark>用户要求</mark></li><li><mark>需求分析</mark></li><li><mark>概要/总体设计</mark></li><li><mark>详细设计</mark></li><li><mark>编码</mark></li><li><mark>测试</mark></li><li><mark>维护</mark></li></ul> 
<p><img src="https://images2.imgbox.com/f2/95/iwOoo4q3_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_59"></a>缺点</h5> 
<p>由于用户不可能一次性的提出所有的需求，而瀑布模型是属于“线性”的开发模型，因而瀑布模型不能适应用户在开发后期提出的需求变更。</p> 
<h5><a id="_61"></a>存在的问题</h5> 
<p>按照瀑布模型来开发软件，只有当分析员能够做出准确的需求分析时，才能够得到预期的结果。不幸的是，由于多数用户不熟悉计算机，系统分析员对用户的专业也往往了解不深，因而很难在开发的初始阶段彻底弄清软件需求。为了解决这一问题，人们提出了“快速原型模型”。</p> 
<h4><a id="222__63"></a>2.2.2 快速原型模型</h4> 
<p>原型化方法是用户和设计者之间执行的一种交互构成，适用于需求不确定性高的情况。</p> 
<p>在快速原型模型的开发过程中，用原型过程来代替全部开发阶段所用模型是<mark>演化型原型</mark>模型。</p> 
<h5><a id="_67"></a>原型开发的优越性</h5> 
<ul><li>逼真</li><li>快速</li></ul> 
<p>软件开发人员向用户提供一个“样品”，用户向开发人员迅速作出反馈。</p> 
<h5><a id="_72"></a>原型模型的启示</h5> 
<p>下图显示了快速原型软件开发的过程模型。<br> <img src="https://images2.imgbox.com/dc/4b/E8ghDUw7_o.png" alt="在这里插入图片描述"><br> 用户的介入和反馈，使它在原型的分析与设计阶段可能出现多次回溯和迭代，从而形成非线性的开发模型。</p> 
<h3><a id="23__76"></a>2.3 软件演化模型</h3> 
<p>常见的演化模型有增量模型与螺旋模型两种。它们都是<mark>瀑布模型</mark>和<mark>快速原型模型</mark>相结合的产物。</p> 
<h4><a id="231_incremental_model_78"></a>2.3.1 增量模型（incremental model）</h4> 
<p><img src="https://images2.imgbox.com/28/f6/zJhjpVer_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="232_spiral_model_80"></a>2.3.2 螺旋模型（spiral model）</h4> 
<p>适用于大型软件的开发。</p> 
<p>项目按照顺时针方向沿螺旋线移动时，每轮螺旋包含以下四种活动：</p> 
<ol><li>计划</li><li>风险分析</li><li>建立原型</li><li>用户评审</li></ol> 
<p>按此顺序周而复始，直到实现最终产品。</p> 
<p><img src="https://images2.imgbox.com/39/eb/XXcom0Fk_o.png" alt="在这里插入图片描述"><br> 螺旋模型的特点，是在项目的所有阶段都考虑各类风险，从而能在风险变成问题之前降低它的危害。螺旋模型开发的成败，在很大程度上依赖于风险评估的准确性。</p> 
<h4><a id="233__93"></a>2.3.3 构件集成模型</h4> 
<p>适用于面向对象的软件开发。</p> 
<p>统一建模语言（unified modeling language,UML），把众多面向对象分析和设计工具综合成一种标准，使面向对象的方法成为主流的软件开发方法。</p> 
<p>面向对象思想最重要的特征是在解空间中引入了“对象”的概念。</p> 
<p>面向对象方法学包含了对象（object）、类（class）、继承（inheritance）、消息（message）等核心概念。</p> 
<blockquote> 
 <p>面向对象 = 对象 + 分类（classification）+ 继承 + 消息通信（communication with messages）</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c5/08/FIYr5VCn_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="24__105"></a>2.4 形式化方法模型</h3> 
<p>软件开发方法可分为：</p> 
<ul><li>形式化方法——学术界流行</li><li>非形式化方法——工业界流行</li></ul> 
<h4><a id="241_transformational_model_110"></a>2.4.1 转换模型（transformational model）</h4> 
<p>转换模型是将形式化软件开发和程序自动生成技术相结合的一种软件开发模型。</p> 
<p><img src="https://images2.imgbox.com/22/7e/hQAIgLyn_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="242_cleanroom_model_115"></a>2.4.2 净室模型（cleanroom model）</h4> 
<p>净室模型是一种形式化的增量开发模型。</p> 
<p>基本思想：力求在分析和设计阶段就消除错误，确保正确，然后在无缺陷或“洁净”的状态下实现软件的制作。</p> 
<p><img src="https://images2.imgbox.com/1a/3d/AI72jLay_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/df/44/V1YLNJmF_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="25__122"></a>2.5 统一过程和敏捷过程</h3> 
<p>Q：RUP是什么？ 试比较RUP和XP的差异。<br> A：RUP（Rational Unified Process，统一软件开发过程，统一软件过程）是一个面向对象且基于网络的程序开发方法论。<br> RUP统一软件过程是描述软件开发中各个环节应该做什么，怎么做，什么时候做以及为什么要做，描述了以某种顺序完成的活动。其在一个二维空间中描述软件开发活动，可以分为初始阶段，细化阶段，构造阶段和迁移阶段。<br> XP 极限过程是一个轻量级的，敏捷的软件开发方法，同时也是一个非常严谨和周密的方法。它有四个价值观：交流，简单，反馈和勇气。</p> 
<h4><a id="251_Rational_Unified_ProcessRUP_128"></a>2.5.1 统一过程（Rational Unified Process,RUP）</h4> 
<p>统一过程描述了软件开发中各个环节做的内容：</p> 
<ul><li>做什么——产品（artifact）</li><li>怎么做——活动（activity）</li><li>什么时候做——工作流（workflow）</li><li>为什么要做</li><li>谁来做——人员（role）</li></ul> 
<p>统一过程包括四个阶段：</p> 
<ul><li>初始阶段</li><li>细化阶段</li><li>构造阶段</li><li>迁移阶段</li></ul> 
<p><img src="https://images2.imgbox.com/67/13/dNhKxZKA_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="252__144"></a>2.5.2 敏捷过程</h4> 
<p>敏捷开发（agile development）是一种以人为核心、以迭代方式循序渐进开发的方法，其软件开发的过程称为“敏捷过程”。</p> 
<p>下图为 4 个简单的价值观以及敏捷开发方法应遵循的 12 条原则：<br> <img src="https://images2.imgbox.com/0d/b8/RIZP7IH8_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="253_extreme_programmingXP_149"></a>2.5.3 极限编程（extreme programming,XP）</h4> 
<p>极限编程是敏捷过程的一种方法。</p> 
<p>它有 4 个价值观：</p> 
<ul><li>交流</li><li>简单</li><li>反馈</li><li>勇气</li></ul> 
<p>即，任何一个软件项目都可以从 4 个方面入手进行改善：</p> 
<ul><li>加强交流</li><li>从简单做起</li><li>寻求反馈</li><li>勇于实事求是</li></ul> 
<p>XP方法包括以下 12 个核心实践：<br> <img src="https://images2.imgbox.com/eb/bd/d3zR3jAK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a8/df/XGG5tu2S_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="26__167"></a>2.6 软件可行性研究</h3> 
<p>可行性论证其实是在高层次上进行的一次大大简化了的需求分析与设计。</p> 
<p>可行性研究进一步研究问题分析阶段所确定的问题是否有可行的解。</p> 
<h4><a id="261__171"></a>2.6.1 可行性研究的内容与步骤</h4> 
<h5><a id="1__172"></a>1. 研究的内容</h5> 
<ul><li>经济可行性。实现这个系统有没有经济效益？多长时间可以收回成本？</li><li>技术可行性。现有的技术能否实现这一新系统？有哪些技术难点？建议采用的技术先进程度怎样？</li><li>运行可行性。为新系统规定的运行方式是否可行？</li><li>法律可行性。新系统的开发会不会在社会上或政治上引起侵权、破坏或其他责任问题？</li></ul> 
<h4><a id="262__178"></a>2.6.2 软件风险分析</h4> 
<ul><li>风险识别</li><li>风险预测</li><li>风险的驾驭和监控</li></ul> 
<h2><a id="3__182"></a>第3章 结构化分析与设计</h2> 
<p>第一代（传统软件工程）→ 第二代（OO软件工程）→ 第三代（基于构件的软件工程）</p> 
<p>本章重点介绍基于瀑布模型的结构化分析与设计。</p> 
<h3><a id="31__186"></a>3.1 概述</h3> 
<h4><a id="311__187"></a>3.1.1 结构化分析与设计的由来</h4> 
<p>系统的整个开发流程，可以简明地表示为：</p> 
<p><img src="https://images2.imgbox.com/c4/a4/5LlyapQc_o.png" alt="在这里插入图片描述"></p> 
<ul><li>DFD 图：Data Flow Diagram,数据流图</li><li>PSPEC：加工规格说明</li><li>CSPEC：控制规格说明</li><li>SRS：Software Requirements Specification,需求规格说明书</li><li>SC 图：Structure Chart,结构图</li></ul> 
<h5><a id="structured_analysisSA_197"></a>结构化分析（structured analysis,SA）</h5> 
<p>任务：</p> 
<ul><li>建立系统分析模型（analysis model）</li><li>编写软件需求规格说明书</li></ul> 
<p>步骤：</p> 
<ul><li>自顶向下对系统进行功能分解，画出分层 DFD 图</li><li>由后向前定义系统的数据和加工，编写 DD 和 PSPEC</li><li>最终写出 SRS</li></ul> 
<p>数据流图和数据字典共同构成了系统的<mark>逻辑</mark>模型，是需求规格说明书的主要组成部分。</p> 
<h5><a id="structured_designSD_208"></a>结构化设计（structured design,SD）</h5> 
<p>SD 阶段先把分析模型中的 DFD 图转换为最终 SC 图。</p> 
<blockquote> 
 <p>软件设计 = 概要/总体设计 + 详细设计/模块设计</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f8/f7/sAGsxPdT_o.png" alt="在这里插入图片描述"><br> 传统的软件设计又可细分：</p> 
<ul><li>面向数据流的设计</li><li>面向数据（数据结构）的设计</li></ul> 
<p>前者以 SD 方法为代表，后者以 Jackson 方法为代表。</p> 
<h4><a id="312_SA__220"></a>3.1.2 SA 模型的组成与描述</h4> 
<p><img src="https://images2.imgbox.com/ef/fe/jBSqwSjv_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7f/9c/SQWzyxdK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/66/57/PoMJtFNi_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0c/88/WUruTe10_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1_SA__226"></a>1. SA 模型的组成</h5> 
<p>由图可见，<mark>数据字典</mark>（DD）处于模型的核心，它是系统涉及的各种数据对象的总和。从DD出发可构建 3 种图：</p> 
<ul><li><mark>实体联系图</mark>（E-R 图）</li><li><mark>数据流图</mark>（DFD）</li><li><mark>状态变换图</mark>（STD）</li></ul> 
<p>下图重要<br> <img src="https://images2.imgbox.com/41/dd/zuCEms7O_o.png" alt="在这里插入图片描述"></p> 
<ul><li>DD：Data Dictionary,数据字典</li><li>E-R 图：Entity-Relation Diagram,实体联系图</li><li>STD 图：Status Transform Diagram,状态变换图</li></ul> 
<h5><a id="2_SA__238"></a>2. SA 模型的描述工具</h5> 
<h6><a id="1_DFD_239"></a>(1) 数据流图（DFD）</h6> 
<p>高度抽象的软件系统功能模型：<br> <img src="https://images2.imgbox.com/e0/9c/35x3VagB_o.png" alt="在这里插入图片描述"><br> 数据流图只使用 4 种基本图形符号：</p> 
<ul><li>圆框代表加工</li><li>箭头代表数据的流向，数据名称总是标在箭头的边上；</li><li>方框表示数据的源点和终点</li><li>双杠（或单杠）表示数据文件或数据库</li></ul> 
<p>基于计算机的教材销售系统的 DFD 图：<br> <img src="https://images2.imgbox.com/67/98/fhUnUykm_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="2_DD_251"></a>(2) 数据字典（DD）</h6> 
<ul><li> <p>数据流<br> <img src="https://images2.imgbox.com/ac/fc/CRPk5cbB_o.png" alt="在这里插入图片描述"></p> </li><li> <p>数据文件<br> <img src="https://images2.imgbox.com/56/1d/hFyomNKu_o.png" alt="在这里插入图片描述"></p> </li><li> <p>数据项<br> <img src="https://images2.imgbox.com/85/ef/XDerbMac_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h6><a id="3__261"></a>(3) 加工规格说明</h6> 
<ul><li> <p>结构化语言<br> <img src="https://images2.imgbox.com/85/cc/9G49ZoVO_o.png" alt="在这里插入图片描述"></p> </li><li> <p>判定表或判定树<br> 某公司为推销人员制定了奖励办法，把奖金与推销金额及预收贷款的数额挂钩。凡每周推销金额不超过 10000 元的，按预收贷款是否超过 50%，分别奖励推销额的 6% 或 4%。若推销金额超过 10000 元，则按预收贷款是否超过 50% ，分别奖励推销额的 8% 或 5%。对于月薪低于 1000 元的推销员，分别另发鼓励奖 300、200 和 500、300 元。试分别采用判定表和判定树为 DFD 图中用来“计算奖金”的加工写出 PSPEC。<br> 下图分别显示了用判定表和判定树描述的 PSPEC，二者的含义相同。<br> <img src="https://images2.imgbox.com/12/90/wAAUpv3F_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b9/4f/tNWsJR8C_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h4><a id="313_SD__270"></a>3.1.3 SD 模型的组成与描述</h4> 
<h5><a id="1_SD__271"></a>1. SD 模型的组成</h5> 
<p>SD 模型是由 SA 模型映射而来的。<br> <img src="https://images2.imgbox.com/54/35/xmcBj9Ad_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_SD__275"></a>2. SD 模型的描述工具</h5> 
<p>其描述工具为结构图（structure chart），简称 SC 图。</p> 
<p>软件结构图中，模块框之间若有直线连接，表示它们之间存在<mark>调用关系</mark>。</p> 
<h6><a id="1_SC__279"></a>(1) SC 图的组成符号</h6> 
<p><img src="https://images2.imgbox.com/0a/10/orZTCOTQ_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="2_SC__281"></a>(2) SC 图的模块调用</h6> 
<p><img src="https://images2.imgbox.com/a1/6e/HXBoh8r9_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="33__283"></a>3.3 结构化系统设计</h3> 
<h4><a id="331_SD_284"></a>3.3.1 SD概述</h4> 
<ul><li>面向数据流设计和面向数据设计</li><li>从分析模型导出设计模型<br> <img src="https://images2.imgbox.com/19/90/ajL39Uh1_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="332_SDDFDSC_288"></a>3.3.2 SD的步骤：从DFD图到SC图</h4> 
<h5><a id="1__289"></a>1. 数据流图的类型</h5> 
<h6><a id="1__290"></a>(1) 变换型结构</h6> 
<p>由传入路径、变换中心和传出路径 3 部分组成。</p> 
<p>下图显示了该型结构的基本模型和数据流：<br> <img src="https://images2.imgbox.com/b4/f2/V0wVOtyC_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="2__296"></a>(2) 事务型结构</h6> 
<p>事务型结构由至少一条接受路径、一个事务中心与若干条动作路径组成。<br> <img src="https://images2.imgbox.com/09/6e/DwlOEQMG_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="335_SC_300"></a>3.3.5 优化初始SC图的指导规则</h4> 
<h5><a id="1__301"></a>1. 对模块划分的原则</h5> 
<p>一般来说，模块的总行数应该控制在 10-100 行的范围内，最好为 30-60 行，能容纳在一张打印纸内。</p> 
<h5><a id="2__303"></a>2. 高扇入/低扇出的原则</h5> 
<p>扇入高则上级模块多，能够增加模块的利用率；扇出低则表示下级模块少，可以减少模块调用和控制的复杂度。</p> 
<p>设计良好的软件通常具有瓮型（oval-shaped）结构，两头小，中间大，如图所示。这类软件在下部收拢，表明它在低层模块中使用了较多高扇入的共享模块。</p> 
<p><img src="https://images2.imgbox.com/49/3b/2fxFKhDn_o.png" alt="在这里插入图片描述"><br> 软件结构图的形态特征能反映程序重用率的是<mark>扇入</mark>。</p> 
<h3><a id="34__310"></a>3.4 模块设计</h3> 
<h4><a id="341__311"></a>3.4.1 目的与任务</h4> 
<p>目的：为 SC 图中的每个模块确定采用的算法和块内数据结构，用选定的表达工具给出清晰的描述。</p> 
<p>任务：编写软件的模块设计说明书。</p> 
<h4><a id="342__316"></a>3.4.2 模块设计的原则与方法</h4> 
<ul><li>清晰第一的设计风格</li><li>结构化的控制结构</li><li>逐步细化的实现方法</li></ul> 
<h4><a id="343__321"></a>3.4.3 常用的表达工具</h4> 
<ul><li>流程图</li><li>N-S 图</li><li>伪代码（PDL语言）</li></ul> 
<p><img src="https://images2.imgbox.com/d6/d9/0KRDgilI_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3f/4b/Tl7uKypu_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="4_UML_329"></a>第4章 面向对象与UML</h2> 
<h3><a id="42_UML_330"></a>4.2 UML简介</h3> 
<h4><a id="421_UML_331"></a>4.2.1 UML的组成</h4> 
<p>UML 是一种基于面向对象的可视化建模语言。</p> 
<h5><a id="1_UML_333"></a>1. UML的模型元素</h5> 
<p><img src="https://images2.imgbox.com/9e/72/2rDylMdh_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d0/47/5rGOI918_o.jpg" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7b/91/dNScsQZ9_o.png" alt="在这里插入图片描述"></p> 
<p>以下是几种主要连接关系的含义：</p> 
<ul><li>关联（association）：模型元素实例之间的固定对应关系，为永久性的结构关系。</li><li>泛化（generalization）：表示一般与特殊关系，“一般”元素是“特殊”元素的泛化，“特殊”元素是“一般”元素的特化（specialization）。</li><li>依赖（dependency）：表示一个元素以某种方式依赖于另一个元素，为短暂性关系。</li><li>实现（realization）：表示接口和实现它的模型元素之间的关系。</li><li>聚集（aggregation）：表示“整体”与“部分”关系，“部分”元素是“整体”元素的一部分。</li><li>组合（composition）：表示强烈的“整体”与“部分”关系，“部分”不能独立于“整体”而存在。</li></ul> 
<p>Q：请指出 UML 类图中类之间的除聚合与组合之外的关系有哪些？聚合与组合关系有什么区别和联系？<br> A：还有的关系有：关联、依赖、继承、实现。聚合与组合的区别是：聚合表示两个对象之间是整体和部分的弱关系，部分的生命周期可以超越整体；组合表示两个对象之间是整体和部分的强关系，部分的生命周期不能超越整体，或者说不能脱离整体而存在。聚合是一种特殊的关联，而组合又是一种特殊的聚合。</p> 
<h5><a id="2_UML__348"></a>2. UML 的元模型结构</h5> 
<p>下一层是上一层的基础，上一层是下一层的实例。<br> <img src="https://images2.imgbox.com/d6/f8/g3TGELGn_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="1__351"></a>(1) 元元模型</h6> 
<p>元元模型定义了用于描述元模型的语言，它是任何模型的基础。<br> <img src="https://images2.imgbox.com/28/75/fnNYZnQh_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="2__355"></a>(2) 元模型</h6> 
<p>元模型定义了用于描述模型的语言。<br> <img src="https://images2.imgbox.com/ad/2f/oYFaMVWl_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="3__359"></a>(3) 模型</h6> 
<p>模型定义了用于描述信息领域的语言，它组成了 UML 的基本元素。<br> <img src="https://images2.imgbox.com/a0/d5/xnuMWwJN_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="4__363"></a>(4) 用户模型</h6> 
<p>用户模型是模型的实例，它用于表达一个模型的特定情况。<br> <img src="https://images2.imgbox.com/4e/bf/XCT2VNaY_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3__367"></a>3. 图和视图</h5> 
<h6><a id="1_diagram_368"></a>(1) 图（diagram）</h6> 
<p><img src="https://images2.imgbox.com/3e/c1/3ddh78we_o.png" alt="在这里插入图片描述"></p> 
<ul><li>用例图描述系统功能</li><li>类图描述系统的静态结构</li><li>对象图描述系统在某个时刻的静态结构</li><li>构件图描述实现系统的元素的组织</li><li>部署图描述系统环境元素的配置，亦可称为配置图</li><li>状态图描述系统元素的状态条件和响应</li><li>时序图按时间顺序描述系统元素间的交互</li><li>协作图按照连接关系描述系统元素间的交互</li><li>活动图描述系统元素的活动流程</li></ul> 
<h6><a id="2_view_380"></a>(2) 视图（view）</h6> 
<p><img src="https://images2.imgbox.com/04/fc/G2kuVXdr_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="422_UML_382"></a>4.2.2 UML的特点</h4> 
<ul><li>统一标准</li><li>面向对象</li><li>表达能力强大、可视化</li></ul> 
<h3><a id="43__386"></a>4.3 静态建模</h3> 
<p>UML的静态建模机制包括：</p> 
<ul><li>用例图</li><li>类图</li><li>对象图</li></ul> 
<h4><a id="431__391"></a>4.3.1 用例图与用例模型</h4> 
<h5><a id="1__392"></a>1. 组成符号</h5> 
<p><img src="https://images2.imgbox.com/b5/4a/RQzeqqbZ_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2__394"></a>2. 建立用例图</h5> 
<p><img src="https://images2.imgbox.com/b2/0b/JDOufvSr_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3__396"></a>3. 用例之间的关系</h5> 
<h6><a id="1_extend_397"></a>(1) 扩展关系（extend）</h6> 
<p>根据指定的条件，一个用例中有可能加入另一个用例的动作，这两个用例之间的关系就是扩展关系。<br> <img src="https://images2.imgbox.com/dd/83/BqEd2Ljm_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="2_include_401"></a>(2) 包含关系（include）</h6> 
<p>当一个用例的行为包含另一个用例的行为时，这两个用例之间就构成了包含关系。如果若干个用例有某些行为是相同的，即可把这些相同的行为抽取出来单独成为一个用例，称为抽象用例。</p> 
<p>用例图中包含关系是指一个用例继承了另一个用例。（×）<br> <img src="https://images2.imgbox.com/c0/15/igjVoCaI_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="432__406"></a>4.3.2 类图和对象图</h4> 
<p>类图是最重要的模型图，它描述了系统中各类对象以及它们之间的各种关系。</p> 
<h5><a id="1__408"></a>1. 类图和对象图</h5> 
<p>不同的属性具有不同的可见性。常见的可见性和在 UML 中的表示：</p> 
<ul><li><mark>Public（+）</mark></li><li><mark>Private（-）</mark></li><li><mark>Protected（#）</mark></li></ul> 
<p>类图可描述类与类之间的静态关系：</p> 
<ul><li>关联</li><li>聚集</li><li>泛化</li><li>依赖以及组合</li><li>约束与派生</li></ul> 
<p><img src="https://images2.imgbox.com/f9/2a/2UC2i9aU_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/eb/a4/v60O5Tr5_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="433__424"></a>4.3.3 包</h4> 
<p>在 OO 设计中，可将许多类集合成一个更高层次的单位，形成一个高内聚、低耦合的类的集合。</p> 
<p>UML 把这种将一些模型元素组织成语义上相关的组的分组机制称为包。<br> <img src="https://images2.imgbox.com/ed/a4/hWZxUHEP_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="44__430"></a>4.4 动态建模</h3> 
<h4><a id="441__431"></a>4.4.1 消息</h4> 
<p>UML 定义的消息类型有以下 3 种：</p> 
<ul><li>简单消息（simple message）：表示简单的控制流。</li><li>同步消息（synchronous message）：表示嵌套的控制流。</li><li>异步消息（asynchronous message）：表示异步控制流。</li></ul> 
<p><img src="https://images2.imgbox.com/34/76/zG9kTfsl_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="442__439"></a>4.4.2 状态图</h4> 
<p>状态图（state diagram）用来描述一个特定对象的所有可能状态以及引起其状态转移的事件。</p> 
<p><img src="https://images2.imgbox.com/c2/6a/QwGn4YuG_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="443__444"></a>4.4.3 时序图和协作图</h4> 
<p>交互图有顺序图和协作图两种形式。</p> 
<h5><a id="1__446"></a>1. 时序/顺序图</h5> 
<p><mark>时序图</mark>（sequence diagram）用来描述对象之间的动态交互，着重体现对象间消息传递的时间顺序。</p> 
<p><img src="https://images2.imgbox.com/a6/ea/3sVqYwdt_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2__451"></a>2. 协作图</h5> 
<p>协作图（collaboration diagram）用于描述相互协作的对象间的交互和链接。</p> 
<p><img src="https://images2.imgbox.com/66/c6/5y2CJaSX_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="444__456"></a>4.4.4 活动图</h4> 
<p>活动图（activity diagram）显示动作流程及其结果，它既可用来描述操作（类的方法）的行为，也可以描述用例和对象内部的工作过程。</p> 
<p><img src="https://images2.imgbox.com/f9/f4/ffay6ED3_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="45__460"></a>4.5 物理架构建模</h3> 
<h4><a id="452__461"></a>4.5.2 构件图和部署图</h4> 
<ul><li>构件图显示软件构件之间的依赖关系</li><li>部署图描述系统硬件的物理拓扑结构以及在此结构上执行的软件</li></ul> 
<p><img src="https://images2.imgbox.com/a4/ac/RsTtzbHJ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="46_UML_466"></a>4.6 UML工具</h3> 
<ul><li>Rational Rose</li><li>StarUML</li></ul> 
<h2><a id="5__469"></a>第5章 需求分析与建模</h2> 
<p>需求分析阶段最重要的的技术文档之一是<mark>需求规格说明书</mark>（SRS）。</p> 
<p>在需求分析中，分析员要从用户那里解决的最重要的问题是明确软件做什么。</p> 
<h3><a id="51__473"></a>5.1 软件需求工程</h3> 
<h4><a id="511__474"></a>5.1.1 软件需求的定义</h4> 
<p>软件需求主要指一个软件系统必须遵循的条件或具备的能力。</p> 
<p>这里的条件或能力可以从两个方面来理解：</p> 
<ul><li>一是用户解决问题或达到目标所需的条件或能力，即系统的外部行为。</li><li>二是系统为了满足合同、规范或其他规定文档所需具有的条件或能力，即系统的内部特性。</li></ul> 
<p>软件需求一般包括 3 个不同的层次：</p> 
<ul><li>业务需求</li><li>用户需求</li><li>功能需求</li></ul> 
<h4><a id="512__486"></a>5.1.2 软件需求的特性</h4> 
<ul><li>功能性</li><li>可用性</li><li>可靠性</li><li>性能</li><li>可支持性</li><li>设计约束</li></ul> 
<h3><a id="52__493"></a>5.2 需求分析与建模</h3> 
<p>需求分析的目的主要是为待开发的软件系统进行需求定义与分析，并建立一个需求模型（requirement model）。</p> 
<h4><a id="521__495"></a>5.2.1 需求分析的步骤</h4> 
<p>软件的需求分析一般包括如下的 4 个步骤：</p> 
<ul><li><mark>需求获取</mark></li><li><mark>需求建模</mark></li><li><mark>需求描述</mark>（即编写 SRS）</li><li><mark>需求验证/需求审评</mark></li></ul> 
<p><img src="https://images2.imgbox.com/2a/54/cLuQYIdq_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="53__503"></a>5.3 需求获取的常用方法</h3> 
<h4><a id="531__504"></a>5.3.1 常规的需求获取方法</h4> 
<ul><li>建立联合分析小组</li><li>用户访谈</li><li>问题分析与确认</li></ul> 
<h4><a id="532__509"></a>5.3.2 用快速原型法获取需求</h4> 
<p>第四代开发技术（4GT）是快速原型法的常用技术。</p> 
<h3><a id="54__511"></a>5.4 需求模型</h3> 
<h4><a id="541__512"></a>5.4.1 需求模型概述</h4> 
<h5><a id="1__513"></a>1. 结构化需求模型</h5> 
<ul><li>包括数据流图和加工规格说明的功能模型</li><li>主要由数据字典和 E-R 图等组成的数据模型</li><li>由状态转换图、控制流图和控制规格说明等组成的行为模型</li></ul> 
<p><img src="https://images2.imgbox.com/71/ce/WSk4vbhY_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2__519"></a>2. 面向对象需求模型</h5> 
<ul><li>用例模型 
  <ul><li>用例图</li><li>用例规约</li></ul> </li><li>补充规约</li><li>术语表</li></ul> 
<p><img src="https://images2.imgbox.com/5e/2e/h89ghQUg_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="542__527"></a>5.4.2 面向对象的需求建模</h4> 
<p>步骤：</p> 
<ol><li>画用例图</li><li>写用例规约</li><li>描述补充规约</li><li>编写术语表</li></ol> 
<p>用例规约文档一般包含以下内容：</p> 
<ul><li>简要说明</li><li>事件流 
  <ul><li>基本流</li><li>备选流</li></ul> </li><li>特殊需求</li><li>前置条件和后置条件</li></ul> 
<h3><a id="55__542"></a>5.5 软件需求描述</h3> 
<p>SRS包括：</p> 
<ul><li>引言</li><li>信息描述</li><li>功能描述</li><li>行为描述</li><li>质量保证</li><li>接口描述</li><li>其他描述</li></ul> 
<h3><a id="56__552"></a>5.6 需求管理</h3> 
<h4><a id="561__553"></a>5.6.1 需求管理的内容</h4> 
<h5><a id="1__554"></a>1. 需求管理的特定实践</h5> 
<p><img src="https://images2.imgbox.com/30/6e/CBjQL7Zx_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2__556"></a>2. 需求变更的流程</h5> 
<blockquote> 
 <p>变更申请 → 审批 → 更改 → 重新确认</p> 
</blockquote> 
<p>对软件影响大的需求变更，应该提交给<mark>SCCB</mark>（软件变更控制委员会）审批。</p> 
<p>Q：需求分析的任务是什么？怎样理解分析阶段的任务是决定“做什么”，而不是“怎么做”？<br> 答：需求分析主要有两个任务：<br> 1）通过对问题及其环境的理解、分析和综合建立分析模型；<br> 2）是在完全弄清用户对软件系统的确切要求的基础上，用“软件需求规格说明书”把用户的需求表达出来。需求分析的任务就是为了明确要开发的是一个什么系统，而不是怎么去实现这个系统。</p> 
<h2><a id="6__566"></a>第6章 面向对象分析</h2> 
<h3><a id="61__567"></a>6.1 软件分析概述</h3> 
<h4><a id="611__568"></a>6.1.1 面向对象软件分析</h4> 
<p>UML 是面向对象分析（object-oriented analysis,OOA）的重要表达工具。</p> 
<h5><a id="1_OOA_570"></a>1. OOA的主要任务</h5> 
<p>首先要理解用户的需求，包括全面理解和分析用户需求，明确所开发的软件系统的职责，形成文件并规范地加以表述。然后进行分析，提取类和对象，并结合分析进行建模。</p> 
<h5><a id="2_OOA_572"></a>2. OOA的模型</h5> 
<p>如图所示，处于 OOA 模型核心的是以<mark>用例模型</mark>为主体的需求模型。当软件开发小组获得软件需求后，分析员即可据此创建一组场景（scenario）。<br> <img src="https://images2.imgbox.com/c1/64/WgZM9nPi_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3_OOA_575"></a>3. OOA的优点</h5> 
<p>与传统的软件分析方法相比较，面向对象分析具有如下优点：</p> 
<ul><li>同时加强了对问题空间和软件系统的理解。</li><li>改进包括用户在内的与软件分析有关的各类人员之间的交流。</li><li>对需求的变化具有较强的适应性。</li><li>很好地支持软件复用。</li><li>确保从需求模型到设计模型的一致性。</li></ul> 
<h5><a id="4__583"></a>4. 分析模型的一般特点</h5> 
<p>分析模型由一组子模型组成。</p> 
<p>特点：</p> 
<ul><li>全面覆盖软件的功能需求</li><li>分析模型与软件的实现无关</li><li>分析模型的表述方法与所采用的分析技术有关</li></ul> 
<h4><a id="612__591"></a>6.1.2 面向对象分析模型</h4> 
<h5><a id="1__592"></a>1. 典型的五层次模型</h5> 
<ul><li>建立类/对象层</li><li>建立属性层</li><li>建立服务层</li><li>建立结构层</li><li>建立主题层</li></ul> 
<h3><a id="62__598"></a>6.2 面向对象分析建模</h3> 
<h4><a id="621__599"></a>6.2.1 识别与确定分析类</h4> 
<h5><a id="1__600"></a>1. 分析类的类型</h5> 
<p>通常，分析类被划分为 3 种类型：</p> 
<ul><li><mark>边界类</mark></li><li><mark>控制类</mark>：作为完成用例任务的责任承担者，协调、控制其他类共同完成用例规定的功能或行为。</li><li><mark>实体类</mark></li></ul> 
<p>可分别用标记</p> 
<ul><li>《boundary》</li><li>《control》</li><li>《entity》</li></ul> 
<p>来表示。</p> 
<p><img src="https://images2.imgbox.com/1e/be/iTLrk5pE_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="7__615"></a>第7章 面向对象设计</h2> 
<p>在面向对象设计阶段着重完成“如何做”的问题，也就是着重考虑对象的实现细节。</p> 
<h3><a id="71__617"></a>7.1 软件设计概述</h3> 
<p>在面向对象的设计中，我们应遵循的设计准则除了模块化、抽象、低耦合、高内聚以外，还有<mark>信息隐蔽</mark>。</p> 
<h4><a id="711__619"></a>7.1.1 软件设计的概念</h4> 
<h5><a id="1__620"></a>1. 模块与构件</h5> 
<ul><li>模块：一个拥有明确定义的输入、输出和特征的程序实体。</li><li>软件构件：可重复使用的软件组件。</li></ul> 
<h5><a id="3__624"></a>3. 信息隐藏</h5> 
<p>系统分解为模块时应遵循的指导思想。</p> 
<p>这一指导思想的目的，是为了提高模块的独立性。</p> 
<h4><a id="713__628"></a>7.1.3 模块化设计</h4> 
<h5><a id="2__629"></a>2. 模块独立性</h5> 
<p>独立性可以从两个方面来度量：</p> 
<ul><li>模块本身的内聚（cohesion）：模块内部各个成分之间的联系，所以也称为块内联系或模块强度。</li><li>模块之间的耦合（coupling）：一个模块与其他模块间的联系，所以又称为块间联系。</li></ul> 
<p><mark>模块的独立性愈高，则块内联系越强，块间联系越弱。</mark></p> 
<p>C.Myers 把内聚和耦合各划分为 7 类，现分别介绍如下。</p> 
<h6><a id="1__637"></a>(1) 内聚</h6> 
<p>内聚是从功能的角度对模块内部聚合能力的量度。</p> 
<p>最强：<mark>功能性内聚</mark><br> 最弱：<mark>偶然性内聚</mark></p> 
<p><img src="https://images2.imgbox.com/98/5b/8esGFzyC_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="2__645"></a>(2) 耦合</h6> 
<p>耦合是对软件内部块间联系的度量。</p> 
<p>最强：内容耦合<br> 最弱：非直接耦合</p> 
<p><img src="https://images2.imgbox.com/64/79/8lBXT4U4_o.png" alt="在这里插入图片描述"><br> Q：衡量模块独立性的两个定性标准是什么？这两个标准的定义分别是什么？在我们的软件设计中，关于模块独立性我们追求的目标是什么？<br> A：衡量模块独立性的两个定性标准是内聚和耦合。耦合是指对一个软件结构内不同模块彼此之间互相依赖（连接）的紧密程度；而内聚则标志一个模块内部各个元素彼此结合的紧密程度。在我们的软件设计中，关于模块独立性我们追求的目标是紧密内聚松散耦合（或者高内聚低耦合）。</p> 
<h3><a id="72__654"></a>7.2 面向对象设计建模</h3> 
<h4><a id="721__655"></a>7.2.1 面向对象设计模型</h4> 
<p>OO 设计模型由</p> 
<ul><li>系统架构层：描述了整个系统的总体结构，使所设计的软件能够满足客户定义的需求，并实现支持客户需求的技术基础设施。</li><li>类和对象层：包含类层次关系，使得系统能够以通用的方式创建并不断逼近特殊需求，该层同时包含了每个对象的设计表示。</li><li>消息层：描述对象间的消息模型，它建立了系统的外部和内部接口，包含使得每个对象能够和其协作者通信的细节。</li><li>责任层：包含针对每个对象的所有属性和操作的数据结构和算法的设计。</li></ul> 
<p>4 个层次组成。</p> 
<p><img src="https://images2.imgbox.com/8e/d5/069sRuUl_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="722__665"></a>7.2.2 面向对象设计的任务</h4> 
<p>正如传统设计可分为概要设计和详细设计两个阶段，OOD 的软件设计也可划分为两个层次：</p> 
<ul><li><mark>系统架构设计</mark></li><li><mark>系统元素设计</mark></li></ul> 
<p>设计任务：将分析阶段建立的分析模型转变为软件设计模型。</p> 
<p>设计目标：细化解决方案的可视化设计模型，确保设计模型最终能平滑地过渡到程序代码。</p> 
<p>软件系统架构是指系统主要组成元素的组织或结构，以及其他全局性决策，组成元素之间通过接口进行交互。</p> 
<p>系统元素包括组成系统的类、子系统与接口、包等。系统元素设计是对每一个设计元素进行详细的设计。</p> 
<h4><a id="723__677"></a>7.2.3 模式的应用</h4> 
<p>每个模式都描述了一个在某个特定环境中不断出现的问题，然后描述该问题解决方案的核心。就其抽象的级别而言，软件模式可以分为：</p> 
<ul><li><mark>架构模式</mark></li><li><mark>设计模式</mark></li><li><mark>习惯用法</mark></li></ul> 
<h3><a id="73__683"></a>7.3 系统架构设计</h3> 
<ul><li>设计系统高层结构 
  <ul><li>应用子系统层</li><li>业务专用层</li><li>中间件层</li><li>系统软件层</li></ul> </li><li>确定设计元素</li><li>确定任务管理策略</li><li>实现分布式机制</li><li>设计数据存储</li></ul> 
<h3><a id="74__694"></a>7.4 系统元素设计</h3> 
<ul><li>子系统设计</li><li>分包设计</li><li>类/对象设计</li></ul> 
<h2><a id="8__698"></a>第8章 编码与测试</h2> 
<h3><a id="84__699"></a>8.4 测试的基本概念</h3> 
<h4><a id="842__700"></a>8.4.2 测试的特性</h4> 
<h5><a id="1__701"></a>1. 挑剔性</h5> 
<h5><a id="2__702"></a>2. 复杂性</h5> 
<h5><a id="3__703"></a>3. 不彻底性</h5> 
<p>E.W.Dijkstra 有一句名言：“程序测试只能证明错误的存在，不能证明错误不存在。”</p> 
<h5><a id="4__705"></a>4. 经济性</h5> 
<h3><a id="85__706"></a>8.5 黑盒测试和白盒测试</h3> 
<h4><a id="851__707"></a>8.5.1 黑盒测试</h4> 
<p>黑盒测试就是根据被测试程序功能来进行测试，所以也称为功能测试。</p> 
<h5><a id="1_equivalence_partitioning_709"></a>1. 等价分类法（equivalence partitioning）</h5> 
<h5><a id="2_boundary_value_analysis_710"></a>2. 边界值分析法（boundary value analysis）</h5> 
<p>边界值分析方法是取输入/输出等价类的边界值来构成测试用例的测试方法。</p> 
<h5><a id="3_error_guessing_712"></a>3. 错误猜测法（error guessing）</h5> 
<h4><a id="852__713"></a>8.5.2 白盒测试</h4> 
<p>白盒测试以程序的结构为依据，所以又称为结构测试。</p> 
<p>白盒测试仅与程序的内部结构有关，完全可以不考虑程序的功能要求。</p> 
<h5><a id="1__717"></a>1. 逻辑覆盖测试法</h5> 
<p><img src="https://images2.imgbox.com/e1/9f/iEvOhoMZ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/11/dd/4ngIfysk_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/5a/34/DFOypEbI_o.png" alt="在这里插入图片描述"><br> 判定覆盖不一定包含条件覆盖，条件覆盖也不一定包含判定覆盖。</p> 
<p>Q：简述软件测试的目的、任务与动态测试类型。<br> A：软件测试是一个为了寻找软件错误而运行程序的过程。目的就是为了发现软件中的错误。软件测试的任务是通过在计算机上执行程序，暴露程序中的潜在的错误。（一个好的测试用例是指很可能找到迄今为止尚未发现的错误的用例。一个成功的测试是指揭示了迄今为止尚未发现的错误的测试。）动态软件测试主要分为白盒测试和黑盒测试两大类。</p> 
<h3><a id="87__726"></a>8.7 多模块程序的测试策略</h3> 
<h4><a id="871__727"></a>8.7.1 测试的层次性</h4> 
<p>按照软件工程的观点，多模块程序的测试共包括 4 个层次。</p> 
<p><img src="https://images2.imgbox.com/99/e5/F1cv0kyd_o.png" alt="在这里插入图片描述"><br> 在进行软件测试时，首先应当进行<mark>单元测试</mark>，然后再进行组装测试，最后再进行有效性测试。</p> 
<h4><a id="872__732"></a>8.7.2 单元测试</h4> 
<p>通过对象模块的静态分析与动态测试，使其代码达到模块说明书的需求。</p> 
<p>单元测试阶段主要涉及<mark>详细设计</mark>的文档。</p> 
<h4><a id="873__736"></a>8.7.3 集成测试</h4> 
<p>将经过单元测试的模块逐步组装成具有良好一致性的完整的程序。</p> 
<h4><a id="874__738"></a>8.7.4 确认测试</h4> 
<p>确认组装完毕的程序是否满足软件需求规格说明书（SRS）的要求。</p> 
<p>针对软件需求分析所进行的软件测试是指<mark>确认测试</mark>。</p> 
<h4><a id="875__742"></a>8.7.5 系统测试</h4> 
<p>检查把确认测试合格的软件安装到系统中以后，能否与系统的其余部分协调运行，并且实现 SRS 的要求。</p> 
<p>单元测试是发现编码错误，集成测试是发现模块的接口错误，确认测试是为了发现功能错误，那么系统测试是为了发现<mark>性能、质量不合要求</mark>的错误。</p> 
<h2><a id="9__746"></a>第9章 软件维护</h2> 
<p>产生软件维护的副作用是指<mark>因修改软件造成的错误</mark>。</p> 
<p>软件生命周期中所花费用最多的阶段是<mark>软件维护</mark>。</p> 
<h3><a id="95__750"></a>9.5. 软件配置管理</h3> 
<h4><a id="2__751"></a>2. 软件配置项</h4> 
<p>软件过程的输出信息可以分为 3 个主要类别：其一是计算机程序（源代码和可执行程序），其二是描述计算机程序的文档（针对技术开发者和用户），其三是数据（包含在程序内部或外部）。这些项包含了所有在软件过程种产生的<mark>信息</mark>，总称为软件配置项。</p> 
<h2><a id="_753"></a>其它</h2> 
<p><mark>回归测试</mark>是指重新执行已经做过的测试的某个子集，以保证由于调试或其他原因引起的变化，不会导致非预期的软件行为或额外错误的测试活动。</p> 
<p>针对下面一个程序段</p> 
<pre><code class="prism language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>A <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>B <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	X <span class="token operator">=</span> X <span class="token operator">/</span> A<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>A <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>X <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	X<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>选取测试用例：CASE 1：A=2 B=0 X=3，该测试用例满足了<mark>语句覆盖</mark>。</p> 
<p>软件是<mark>程序及其文档</mark>。</p> 
<p>文档是软件产品的一部分，没有文档的软件就不称其为软件。</p> 
<p>软件工程的三要素是<mark>工具、过程和方法</mark>。</p> 
<p>系统边界是一个系统所包含的所有系统成分与系统以外各种事物的分界线。</p> 
<p>在用例之间，会有三种不同的关系：</p> 
<ul><li><mark>包含（include）</mark></li><li><mark>扩展（extend）</mark></li><li><mark>泛化（generalization）</mark></li></ul> 
<p>一台计算机有很多零部件，例如：键盘、鼠标、主板、显示器等等，我们可以用一个聚集图来描述，也就是说计算机是一个聚集体。</p> 
<p>数据管理部分的设计是 OOD 模型中的一部分，负责使用关系数据库存储和检索永久对象。（×）</p> 
<p>一个软件从开始立项起，到废止不用止，统称为软件的生命周期。</p> 
<p>软件生存周期主要活动：</p> 
<ul><li><mark>需求分析</mark></li><li><mark>软件分析</mark></li><li><mark>软件设计</mark></li><li><mark>编码</mark></li><li><mark>软件测试</mark></li><li><mark>运行维护</mark></li></ul> 
<p>从心理学角度看，对数据流程图的数据处理泡进行分解，一次分解为<mark>7±2</mark>个泡为宜。</p> 
<p>结构化程序设计采用的三种基本控制结构：</p> 
<ul><li><mark>顺序</mark></li><li><mark>选择</mark></li><li><mark>循环</mark></li></ul> 
<p>结构化程序设计主要强调的是<mark>程序易读性</mark>。</p> 
<p>解释下列名词：（1）模块；（2）模块化；（3）模块化设计。<br> 答：模块是一个拥有明确定义的 、输出和特性的程序实体。<br> 模块化是指解决一个复杂问题时自顶向下逐层把软件系统划分成若干模块的过程。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体，完成整个系统所要求的功能。<br> 模块化设计是把大型软件按照规定的原则划分成一个个较小的、相对独立但又相互关联的模块。但又相互关联的模块。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/461476ac05c1d3d0e2a5cd83b15c3e9b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">北航数理统计大作业_【保研故事】四非通信保研边缘人如何绝处逢生推免北航！...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/98280de77789c717812461171cc0b326/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python同时监听多个端口_nginx 多个vs,一台服务器多个server监听不同端口，都从80访问...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>