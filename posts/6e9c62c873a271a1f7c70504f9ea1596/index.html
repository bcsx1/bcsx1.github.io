<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32 HAL库开发——入门篇（2）：定时器 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32 HAL库开发——入门篇（2）：定时器" />
<meta property="og:description" content="目录 一、TIMER定时器概述
1.1 软件定时原理
1.2 定时器定时原理
1.3 STM32定时器分类
1.4 STM32定时器特性表
1.5 STM32基本、通用、高级定时器功能整体的区别
二、基本定时器
2.1 基本定时器简介
2.3 STM32定时器计数模式及溢出条件
2.4 定时器中断实验相关寄存器
2.5 定时器溢出时间计算方法
2.6 定时器中断实验配置步骤
2.7 编程实战：定时器中断实验
三、通用定时器
3.1 通用定时器简介
3.2 通用定时器框图 3.3 计数器时钟源
3.3.1 外部时钟模式1
3.3.2 外部时钟模式2
3.3.3 内部触发输入 3.4 通用定时器PWM输出实验
3.4.1 通用定时器输出比较部分框图
3.4.2 通用定时器输出PWM原理
3.4.3 PWM模式
3.4.4 通用定时器PWM输出实验配置步骤
3.4.5 编程实战：通用定时器PWM输出实验
3.5 通用定时器输入捕获实验
3.5.1 通用定时器输入捕获部分框图
3.5.2 通用定时器输入捕获脉宽测量原理
3.5.4 编程实战：通用定时器输入捕获实验
3.6 通用定时器脉冲计数实验
3.6.1 脉冲计数实验原理
3.6.2 通用定时器脉冲计数实验配置步骤
3.6.3 编程实战：通用定时器脉冲计数实验
四、高级定时器
4.1 高级定时器简介" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/6e9c62c873a271a1f7c70504f9ea1596/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-22T09:52:29+08:00" />
<meta property="article:modified_time" content="2023-06-22T09:52:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32 HAL库开发——入门篇（2）：定时器</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="main-toc"><strong>目录</strong></h2> 
<p id="%E4%B8%80%E3%80%81TIMER%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81TIMER%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A6%82%E8%BF%B0" rel="nofollow">一、TIMER定时器概述</a></p> 
<p id="1.1%20%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#1.1%20%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%8E%9F%E7%90%86" rel="nofollow">1.1 软件定时原理</a></p> 
<p id="1.2%20%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#1.2%20%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E5%8E%9F%E7%90%86" rel="nofollow">1.2 定时器定时原理</a></p> 
<p id="1.3%20STM32%E5%AE%9A%E6%97%B6%E5%99%A8%E5%88%86%E7%B1%BB-toc" style="margin-left:40px;"><a href="#1.3%20STM32%E5%AE%9A%E6%97%B6%E5%99%A8%E5%88%86%E7%B1%BB" rel="nofollow">1.3 STM32定时器分类</a></p> 
<p id="1.4%20STM32%E5%AE%9A%E6%97%B6%E5%99%A8%E7%89%B9%E6%80%A7%E8%A1%A8-toc" style="margin-left:40px;"><a href="#1.4%20STM32%E5%AE%9A%E6%97%B6%E5%99%A8%E7%89%B9%E6%80%A7%E8%A1%A8" rel="nofollow">1.4 STM32定时器特性表</a></p> 
<p id="1.5%20STM32%E5%9F%BA%E6%9C%AC%E3%80%81%E9%80%9A%E7%94%A8%E3%80%81%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8A%9F%E8%83%BD%E6%95%B4%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#1.5%20STM32%E5%9F%BA%E6%9C%AC%E3%80%81%E9%80%9A%E7%94%A8%E3%80%81%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8A%9F%E8%83%BD%E6%95%B4%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">1.5 STM32基本、通用、高级定时器功能整体的区别</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8" rel="nofollow">二、基本定时器</a></p> 
<p id="2.1%20%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#2.1%20%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%80%E4%BB%8B" rel="nofollow">2.1 基本定时器简介</a></p> 
<p id="2.3%20STM32%E5%AE%9A%E6%97%B6%E5%99%A8%E8%AE%A1%E6%95%B0%E6%A8%A1%E5%BC%8F%E5%8F%8A%E6%BA%A2%E5%87%BA%E6%9D%A1%E4%BB%B6-toc" style="margin-left:40px;"><a href="#2.3%20STM32%E5%AE%9A%E6%97%B6%E5%99%A8%E8%AE%A1%E6%95%B0%E6%A8%A1%E5%BC%8F%E5%8F%8A%E6%BA%A2%E5%87%BA%E6%9D%A1%E4%BB%B6" rel="nofollow">2.3 STM32定时器计数模式及溢出条件</a></p> 
<p id="2.4%20%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8-toc" style="margin-left:40px;"><a href="#2.4%20%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8" rel="nofollow">2.4 定时器中断实验相关寄存器</a></p> 
<p id="2.5%20%E5%AE%9A%E6%97%B6%E5%99%A8%E6%BA%A2%E5%87%BA%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#2.5%20%E5%AE%9A%E6%97%B6%E5%99%A8%E6%BA%A2%E5%87%BA%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95" rel="nofollow">2.5 定时器溢出时间计算方法</a></p> 
<p id="2.6%20%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;"><a href="#2.6%20%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4" rel="nofollow">2.6 定时器中断实验配置步骤</a></p> 
<p id="2.7%20%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C-toc" style="margin-left:40px;"><a href="#2.7%20%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C" rel="nofollow">2.7 编程实战：定时器中断实验</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8" rel="nofollow">三、通用定时器</a></p> 
<p id="3.1%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#3.1%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%80%E4%BB%8B" rel="nofollow">3.1 通用定时器简介</a></p> 
<p id="3.2%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A1%86%E5%9B%BE%C2%A0-toc" style="margin-left:40px;"><a href="#3.2%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A1%86%E5%9B%BE%C2%A0" rel="nofollow">3.2 通用定时器框图 </a></p> 
<p id="3.3%20%E8%AE%A1%E6%95%B0%E5%99%A8%E6%97%B6%E9%92%9F%E6%BA%90-toc" style="margin-left:40px;"><a href="#3.3%20%E8%AE%A1%E6%95%B0%E5%99%A8%E6%97%B6%E9%92%9F%E6%BA%90" rel="nofollow">3.3 计数器时钟源</a></p> 
<p id="3.3.1%20%E5%A4%96%E9%83%A8%E6%97%B6%E9%92%9F%E6%A8%A1%E5%BC%8F1-toc" style="margin-left:80px;"><a href="#3.3.1%20%E5%A4%96%E9%83%A8%E6%97%B6%E9%92%9F%E6%A8%A1%E5%BC%8F1" rel="nofollow">3.3.1 外部时钟模式1</a></p> 
<p id="3.3.2%20%E5%A4%96%E9%83%A8%E6%97%B6%E9%92%9F%E6%A8%A1%E5%BC%8F2-toc" style="margin-left:80px;"><a href="#3.3.2%20%E5%A4%96%E9%83%A8%E6%97%B6%E9%92%9F%E6%A8%A1%E5%BC%8F2" rel="nofollow">3.3.2 外部时钟模式2</a></p> 
<p id="3.3.3%20%E5%86%85%E9%83%A8%E8%A7%A6%E5%8F%91%E8%BE%93%E5%85%A5%C2%A0-toc" style="margin-left:80px;"><a href="#3.3.3%20%E5%86%85%E9%83%A8%E8%A7%A6%E5%8F%91%E8%BE%93%E5%85%A5%C2%A0" rel="nofollow">3.3.3 内部触发输入 </a></p> 
<p id="3.4%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8PWM%E8%BE%93%E5%87%BA%E5%AE%9E%E9%AA%8C-toc" style="margin-left:40px;"><a href="#3.4%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8PWM%E8%BE%93%E5%87%BA%E5%AE%9E%E9%AA%8C" rel="nofollow">3.4 通用定时器PWM输出实验</a></p> 
<p id="3.4.1%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%E9%83%A8%E5%88%86%E6%A1%86%E5%9B%BE-toc" style="margin-left:80px;"><a href="#3.4.1%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%E9%83%A8%E5%88%86%E6%A1%86%E5%9B%BE" rel="nofollow">3.4.1 通用定时器输出比较部分框图</a></p> 
<p id="3.4.2%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%87%BAPWM%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#3.4.2%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%87%BAPWM%E5%8E%9F%E7%90%86" rel="nofollow">3.4.2 通用定时器输出PWM原理</a></p> 
<p id="3.4.3%20PWM%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#3.4.3%20PWM%E6%A8%A1%E5%BC%8F" rel="nofollow">3.4.3 PWM模式</a></p> 
<p id="3.4.4%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8PWM%E8%BE%93%E5%87%BA%E5%AE%9E%E9%AA%8C%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4-toc" style="margin-left:80px;"><a href="#3.4.4%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8PWM%E8%BE%93%E5%87%BA%E5%AE%9E%E9%AA%8C%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4" rel="nofollow">3.4.4 通用定时器PWM输出实验配置步骤</a></p> 
<p id="3.4.5%20%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%9A%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8PWM%E8%BE%93%E5%87%BA%E5%AE%9E%E9%AA%8C-toc" style="margin-left:80px;"><a href="#3.4.5%20%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%9A%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8PWM%E8%BE%93%E5%87%BA%E5%AE%9E%E9%AA%8C" rel="nofollow">3.4.5 编程实战：通用定时器PWM输出实验</a></p> 
<p id="3.5%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%AE%9E%E9%AA%8C-toc" style="margin-left:40px;"><a href="#3.5%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%AE%9E%E9%AA%8C" rel="nofollow">3.5 通用定时器输入捕获实验</a></p> 
<p id="3.5.1%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E9%83%A8%E5%88%86%E6%A1%86%E5%9B%BE-toc" style="margin-left:80px;"><a href="#3.5.1%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E9%83%A8%E5%88%86%E6%A1%86%E5%9B%BE" rel="nofollow">3.5.1 通用定时器输入捕获部分框图</a></p> 
<p id="3.5.2%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E8%84%89%E5%AE%BD%E6%B5%8B%E9%87%8F%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#3.5.2%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E8%84%89%E5%AE%BD%E6%B5%8B%E9%87%8F%E5%8E%9F%E7%90%86" rel="nofollow">3.5.2 通用定时器输入捕获脉宽测量原理</a></p> 
<p id="3.5.4%C2%A0%20%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%9A%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%AE%9E%E9%AA%8C-toc" style="margin-left:80px;"><a href="#3.5.4%C2%A0%20%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%9A%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%AE%9E%E9%AA%8C" rel="nofollow">3.5.4  编程实战：通用定时器输入捕获实验</a></p> 
<p id="3.6%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%84%89%E5%86%B2%E8%AE%A1%E6%95%B0%E5%AE%9E%E9%AA%8C-toc" style="margin-left:40px;"><a href="#3.6%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%84%89%E5%86%B2%E8%AE%A1%E6%95%B0%E5%AE%9E%E9%AA%8C" rel="nofollow">3.6 通用定时器脉冲计数实验</a></p> 
<p id="3.6.1%20%E8%84%89%E5%86%B2%E8%AE%A1%E6%95%B0%E5%AE%9E%E9%AA%8C%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#3.6.1%20%E8%84%89%E5%86%B2%E8%AE%A1%E6%95%B0%E5%AE%9E%E9%AA%8C%E5%8E%9F%E7%90%86" rel="nofollow">3.6.1 脉冲计数实验原理</a></p> 
<p id="3.6.2%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%84%89%E5%86%B2%E8%AE%A1%E6%95%B0%E5%AE%9E%E9%AA%8C%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4-toc" style="margin-left:80px;"><a href="#3.6.2%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%84%89%E5%86%B2%E8%AE%A1%E6%95%B0%E5%AE%9E%E9%AA%8C%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4" rel="nofollow">3.6.2 通用定时器脉冲计数实验配置步骤</a></p> 
<p id="3.6.3%20%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%9A%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%84%89%E5%86%B2%E8%AE%A1%E6%95%B0%E5%AE%9E%E9%AA%8C-toc" style="margin-left:80px;"><a href="#3.6.3%20%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%9A%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%84%89%E5%86%B2%E8%AE%A1%E6%95%B0%E5%AE%9E%E9%AA%8C" rel="nofollow">3.6.3 编程实战：通用定时器脉冲计数实验</a></p> 
<p id="%E5%9B%9B%E3%80%81%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8" rel="nofollow">四、高级定时器</a></p> 
<p id="4.1%20%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#4.1%20%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%80%E4%BB%8B" rel="nofollow">4.1 高级定时器简介</a></p> 
<p id="4.2%20%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A1%86%E5%9B%BE-toc" style="margin-left:40px;"><a href="#4.2%20%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A1%86%E5%9B%BE" rel="nofollow">4.2 高级定时器框图</a></p> 
<p id="4.3%C2%A0%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%87%BA%E6%8C%87%E5%AE%9A%E4%B8%AA%E6%95%B0PWM%E5%AE%9E%E9%AA%8C-toc" style="margin-left:40px;"><a href="#4.3%C2%A0%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%87%BA%E6%8C%87%E5%AE%9A%E4%B8%AA%E6%95%B0PWM%E5%AE%9E%E9%AA%8C" rel="nofollow">4.3 高级定时器输出指定个数PWM实验</a></p> 
<p id="4.3.1%20%E9%87%8D%E5%A4%8D%E8%AE%A1%E6%95%B0%E5%99%A8%E7%89%B9%E6%80%A7%C2%A0-toc" style="margin-left:80px;"><a href="#4.3.1%20%E9%87%8D%E5%A4%8D%E8%AE%A1%E6%95%B0%E5%99%A8%E7%89%B9%E6%80%A7%C2%A0" rel="nofollow">4.3.1 重复计数器特性 </a></p> 
<p id="4.3.2%20%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%87%BA%E6%8C%87%E5%AE%9A%E4%B8%AA%E6%95%B0PWM%E4%B8%AA%E6%95%B0-toc" style="margin-left:80px;"><a href="#4.3.2%20%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%87%BA%E6%8C%87%E5%AE%9A%E4%B8%AA%E6%95%B0PWM%E4%B8%AA%E6%95%B0" rel="nofollow">4.3.2 高级定时器输出指定个数PWM个数</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<p></p> 
<p>使用正点原子stm32f103精英版 </p> 
<p><img alt="" height="483" src="https://images2.imgbox.com/84/51/mvegpP5w_o.png" width="680"></p> 
<h2 id="%E4%B8%80%E3%80%81TIMER%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A6%82%E8%BF%B0">一、TIMER定时器概述</h2> 
<p><img alt="" height="655" src="https://images2.imgbox.com/55/53/MvOPeRoF_o.png" width="1087"></p> 
<h3 id="1.1%20%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%8E%9F%E7%90%86">1.1 软件定时原理</h3> 
<p>软件延时过程中，程序就进入延时函数中，无法执行其他程序</p> 
<p>下图的72，是因为f103的主频是72MHz，这样调用延时肯定是不精准的</p> 
<p><img alt="" height="597" src="https://images2.imgbox.com/f0/fb/lQfLAmPx_o.png" width="1200"></p> 
<p></p> 
<h3 id="1.2%20%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E5%8E%9F%E7%90%86">1.2 定时器定时原理</h3> 
<p><img alt="" height="648" src="https://images2.imgbox.com/7d/9f/gdNvbVoW_o.png" width="1200"></p> 
<p></p> 
<h3 id="1.3%20STM32%E5%AE%9A%E6%97%B6%E5%99%A8%E5%88%86%E7%B1%BB">1.3 STM32定时器分类</h3> 
<p><img alt="" height="698" src="https://images2.imgbox.com/34/cb/smlTd4aC_o.png" width="1200"></p> 
<p>实时时钟就是 RTC </p> 
<p></p> 
<h3 id="1.4%20STM32%E5%AE%9A%E6%97%B6%E5%99%A8%E7%89%B9%E6%80%A7%E8%A1%A8">1.4 STM32定时器特性表</h3> 
<p><img alt="" height="728" src="https://images2.imgbox.com/46/0c/ToBgQZpA_o.png" width="1200"></p> 
<p></p> 
<h3 id="1.5%20STM32%E5%9F%BA%E6%9C%AC%E3%80%81%E9%80%9A%E7%94%A8%E3%80%81%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8A%9F%E8%83%BD%E6%95%B4%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB">1.5 STM32基本、通用、高级定时器功能整体的区别</h3> 
<p><img alt="" height="607" src="https://images2.imgbox.com/e1/f8/CBlUluqV_o.png" width="1200"></p> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8">二、基本定时器</h2> 
<p><img alt="" height="607" src="https://images2.imgbox.com/25/e9/iWYyWlCC_o.png" width="850"></p> 
<p></p> 
<h3 id="2.1%20%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%80%E4%BB%8B">2.1 基本定时器简介</h3> 
<p><img alt="" height="661" src="https://images2.imgbox.com/dd/42/9AuLyW5K_o.png" width="1200"></p> 
<p>基本定时器的时钟来源只能是内部时钟</p> 
<p><img alt="" height="709" src="https://images2.imgbox.com/4d/fe/1lAzqotD_o.png" width="1200">       通过程序的方式无法直接访问影子寄存器，但可以通过写入arr自动重载寄存器，它再转移到影子寄存器生效，此时ARR寄存器就起到一个缓冲或缓存的作用</p> 
<p>       事件是默认产生；中断和DMA输出是默认不产生，但可以配置产生 </p> 
<p>        ARPE位的作用：设置有缓冲作用后，ARR的值要等事件发生后写入影子寄存器；设置没有缓冲作用的话，ARR的值就马上转移到影子寄存器中生效</p> 
<p><img alt="" height="508" src="https://images2.imgbox.com/cd/39/8Pwu9tze_o.png" width="1099"></p> 
<p><img alt="" height="765" src="https://images2.imgbox.com/14/31/9AOzos1L_o.png" width="1200">       虽然最大总线的最大时钟频率是72、36MHz，但定时器的最大时钟频率不一定有这么大 </p> 
<p><img alt="" height="723" src="https://images2.imgbox.com/2c/ad/4rCG4mG6_o.png" width="1200"></p> 
<p><img alt="" height="586" src="https://images2.imgbox.com/58/54/7ot90MCo_o.png" width="1200"></p> 
<p>       可以看到例程中 APB2 预分频系数是1，所以最大还是72MHz </p> 
<p>       APB1 预分频系数是2，APB1时钟是从AHB 2分频过来的，所以APB1给到定时器的时钟要乘2，定时器时钟就也是72Mhz了</p> 
<p></p> 
<h3 id="2.3%20STM32%E5%AE%9A%E6%97%B6%E5%99%A8%E8%AE%A1%E6%95%B0%E6%A8%A1%E5%BC%8F%E5%8F%8A%E6%BA%A2%E5%87%BA%E6%9D%A1%E4%BB%B6">2.3 STM32定时器计数模式及溢出条件</h3> 
<p><img alt="" height="718" src="https://images2.imgbox.com/1d/b8/ESzj4KHc_o.png" width="1200"></p> 
<p><img alt="" height="695" src="https://images2.imgbox.com/92/f4/8jimlyhT_o.png" width="1200"><img alt="" height="690" src="https://images2.imgbox.com/85/a2/Dg3PJm1f_o.png" width="1200"><img alt="" height="707" src="https://images2.imgbox.com/b9/92/JW8C7g7J_o.png" width="1200"> </p> 
<h3 id="2.4%20%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8">2.4 定时器中断实验相关寄存器</h3> 
<p><img alt="" height="717" src="https://images2.imgbox.com/c4/99/R6zLaxvp_o.png" width="1200">如一个例子，控制led亮1s，灭2s</p> 
<p>（1）当没有缓冲时，假设先设置arr=99，1s后更新灭，然后重新写入arr=199灭2s，这其中写arr的值也需要时间</p> 
<p>（2）而有缓冲时，假设先设置arr=99，1s后更新灭，然后在这1s内写入arr=199，此时因为有缓冲所以arr的值不会立即写入要等更新后写入，所以就节省了写入arr值的时间，减小了误差</p> 
<p><img alt="" height="709" src="https://images2.imgbox.com/04/5e/MzDlTU5m_o.png" width="1200"><img alt="" height="669" src="https://images2.imgbox.com/a3/0c/9wECWd1q_o.png" width="1200"><img alt="" height="691" src="https://images2.imgbox.com/3e/52/9JopI9gy_o.png" width="1200"><img alt="" height="568" src="https://images2.imgbox.com/92/76/q9DHOJrn_o.png" width="1200"><img alt="" height="668" src="https://images2.imgbox.com/ad/02/JZjVkvRS_o.png" width="1200"><img alt="" height="654" src="https://images2.imgbox.com/a2/c4/KocYPv87_o.png" width="1200"> </p> 
<h3 id="2.5%20%E5%AE%9A%E6%97%B6%E5%99%A8%E6%BA%A2%E5%87%BA%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95">2.5 定时器溢出时间计算方法</h3> 
<p><img alt="" height="672" src="https://images2.imgbox.com/a9/f6/hifrFht7_o.png" width="1200">ARR也是同理，寄存器最小值为0，我从0数到3，你不能说我就数了3个数吧，当然是3+1=4个数 </p> 
<p></p> 
<h3 id="2.6%20%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4">2.6 定时器中断实验配置步骤</h3> 
<p><img alt="" height="630" src="https://images2.imgbox.com/2c/2b/RWfdvPqS_o.png" width="1200"><img alt="" height="572" src="https://images2.imgbox.com/5d/dd/UcuVq9rX_o.png" width="1200">基地址：</p> 
<p><img alt="" height="571" src="https://images2.imgbox.com/71/a9/0CHrm9yl_o.png" width="1200"></p> 
<p><img alt="" height="759" src="https://images2.imgbox.com/c1/94/QG9xsSRr_o.png" width="1200">基本定时器技术模式固定递增，无分频因子</p> 
<p>重复计数器寄存器只有高级定时器才有 </p> 
<p>自动重载预装载使能就是CR1寄存器的位7：APRE</p> 
<p><img alt="" height="805" src="https://images2.imgbox.com/a4/a5/Mf1Roq5f_o.png" width="1200"></p> 
<p>基本定时器只有更新中断 </p> 
<p><img alt="" height="519" src="https://images2.imgbox.com/ce/cc/iPiGnra6_o.png" width="1200"></p> 
<h3 id="2.7%20%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C">2.7 编程实战：定时器中断实验</h3> 
<p>       更新中断产生的方式：</p> 
<p>       （1）定时器溢出时伴随更新时间和更新中断的产生</p> 
<p>       （2）通过软件设置UG位产生软件的更新时间从而产生更新中断</p> 
<p>       这里使用定时器溢出的方式 </p> 
<p><img alt="" height="700" src="https://images2.imgbox.com/5d/58/geM6vuNR_o.png" width="1200"><img alt="" height="680" src="https://images2.imgbox.com/aa/62/EPokvpZA_o.png" width="1200"></p> 
<pre><code>#include "./BSP/TIMER/timer.h"
#include "./BSP/LED/led.h"

TIM_HandleTypeDef g_timx_handle;

/* 定时器中断初始化函数 */
void btim_timx_int_init(uint16_t arr, uint16_t psc)
{
    g_timx_handle.Instance = TIM6;
    g_timx_handle.Init.Prescaler = psc;
    g_timx_handle.Init.Period = arr;
    HAL_TIM_Base_Init(&amp;g_timx_handle);
    
    HAL_TIM_Base_Start_IT(&amp;g_timx_handle);

}



/* 定时器基础MSP初始化函数 */
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
{
    if(htim-&gt;Instance == TIM6)
    {
        __HAL_RCC_TIM6_CLK_ENABLE();
        HAL_NVIC_SetPriority(TIM6_IRQn, 2, 3);
        HAL_NVIC_EnableIRQ(TIM6_IRQn);
    
    }

}



/* 定时器6中断服务函数 */
void TIM6_IRQHandler()
{
    HAL_TIM_IRQHandler(&amp;g_timx_handle);
}



/* 定时器溢出中断回调函数 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim-&gt;Instance == TIM6)  /* 判断是定时器6，否则多个定时器进来会混乱 */
    {
        LED0_TOGGLE();
    
    }


}

</code></pre> 
<h2 id="%E4%B8%89%E3%80%81%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8">三、通用定时器</h2> 
<p><img alt="" height="579" src="https://images2.imgbox.com/32/65/aiWMi0Vw_o.png" width="945"></p> 
<h3 id="3.1%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%80%E4%BB%8B">3.1 通用定时器简介</h3> 
<p><img alt="" height="568" src="https://images2.imgbox.com/bf/37/9wZhNVWo_o.png" width="1200"><img alt="" height="495" src="https://images2.imgbox.com/2a/b4/1KVH848g_o.png" width="1200">       通用定时器时钟来自RCC内部时钟，有4类：</p> 
<p>       （1）APB总线上的时钟</p> 
<p>       （2）ITR0-4内部触发输入时钟部分</p> 
<p>       （3）可以复用为ETR引脚的IO口</p> 
<p><img alt="" height="380" src="https://images2.imgbox.com/c5/a3/Wt4b5xj1_o.png" width="568"></p> 
<p>       （4）定时器的通道1、通道2</p> 
<p><img alt="" height="475" src="https://images2.imgbox.com/1a/3b/oLARsvJe_o.png" width="659"></p> 
<p>如：<img alt="" height="317" src="https://images2.imgbox.com/84/6e/BSUYQ8Yp_o.png" width="1115"></p> 
<p></p> 
<h3 id="3.2%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A1%86%E5%9B%BE%C2%A0">3.2 通用定时器框图 </h3> 
<p><img alt="" height="821" src="https://images2.imgbox.com/df/58/mk1AvVtE_o.png" width="1200"> </p> 
<h3 id="3.3%20%E8%AE%A1%E6%95%B0%E5%99%A8%E6%97%B6%E9%92%9F%E6%BA%90">3.3 计数器时钟源</h3> 
<p><img alt="" height="804" src="https://images2.imgbox.com/d1/12/O8mCC19q_o.png" width="1200"><img alt="" height="565" src="https://images2.imgbox.com/fd/cb/eTd44opq_o.png" width="1170"><img alt="" height="712" src="https://images2.imgbox.com/4c/eb/k4YfTH6L_o.png" width="1200"></p> 
<p><img alt="" height="568" src="https://images2.imgbox.com/14/56/ahwp3RoF_o.png" width="1200"></p> 
<h4></h4> 
<h4 id="3.3.1%20%E5%A4%96%E9%83%A8%E6%97%B6%E9%92%9F%E6%A8%A1%E5%BC%8F1">3.3.1 外部时钟模式1</h4> 
<p>TI1_ED 来自通道1，双边沿</p> 
<p>TI1FP1、TI2FP2来自通道1、2，单边沿 </p> 
<p><img alt="" height="591" src="https://images2.imgbox.com/22/ef/JtwmbN6a_o.png" width="1179"><img alt="" height="343" src="https://images2.imgbox.com/26/2f/upg4oqG5_o.png" width="1133"><img alt="" height="735" src="https://images2.imgbox.com/6d/0b/bcH1ZbLS_o.png" width="1200"> </p> 
<h4 id="3.3.2%20%E5%A4%96%E9%83%A8%E6%97%B6%E9%92%9F%E6%A8%A1%E5%BC%8F2">3.3.2 外部时钟模式2</h4> 
<p><img alt="" height="591" src="https://images2.imgbox.com/fc/a6/8W9h6HKZ_o.png" width="1200"><img alt="" height="594" src="https://images2.imgbox.com/e5/42/Y7RCxMI2_o.png" width="1200"></p> 
<p></p> 
<h4 id="3.3.3%20%E5%86%85%E9%83%A8%E8%A7%A6%E5%8F%91%E8%BE%93%E5%85%A5%C2%A0">3.3.3 内部触发输入 </h4> 
<p><img alt="" height="703" src="https://images2.imgbox.com/00/4c/yNEQUgM3_o.png" width="1200"><img alt="" height="751" src="https://images2.imgbox.com/09/8f/HM4eRdUR_o.png" width="1200"><img alt="" height="327" src="https://images2.imgbox.com/ab/a8/4QJTuSNt_o.png" width="1200">只有通用和高级定时器才可以参与</p> 
<p><img alt="" height="706" src="https://images2.imgbox.com/28/4e/tkTpNovm_o.png" width="1200"><img alt="" height="240" src="https://images2.imgbox.com/08/3e/ppZc0vz8_o.png" width="1200"> </p> 
<h3 id="3.4%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8PWM%E8%BE%93%E5%87%BA%E5%AE%9E%E9%AA%8C">3.4 通用定时器PWM输出实验</h3> 
<p><img alt="" height="567" src="https://images2.imgbox.com/3d/73/6K8qgLaZ_o.png" width="1038"></p> 
<h4 id="3.4.1%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%E9%83%A8%E5%88%86%E6%A1%86%E5%9B%BE">3.4.1 通用定时器输出比较部分框图</h4> 
<p><img alt="" height="648" src="https://images2.imgbox.com/71/56/qgNA2jJ5_o.png" width="1200"></p> 
<p><img alt="" height="713" src="https://images2.imgbox.com/6b/2c/ueWoX0Dt_o.png" width="1200"><img alt="" height="478" src="https://images2.imgbox.com/3b/c3/QjHA9bn1_o.png" width="1200"><img alt="" height="645" src="https://images2.imgbox.com/59/4a/4YuKMmEr_o.png" width="1200"><img alt="" height="733" src="https://images2.imgbox.com/7b/ed/X6izMliI_o.png" width="1200"><img alt="" height="505" src="https://images2.imgbox.com/7c/79/oBcwUFzT_o.png" width="1200"></p> 
<p></p> 
<h4 id="3.4.2%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%87%BAPWM%E5%8E%9F%E7%90%86">3.4.2 通用定时器输出PWM原理</h4> 
<p><img alt="" height="711" src="https://images2.imgbox.com/c5/2c/yHThadgJ_o.png" width="1200"></p> 
<p></p> 
<h4 id="3.4.3%20PWM%E6%A8%A1%E5%BC%8F">3.4.3 PWM模式</h4> 
<p><img alt="" height="652" src="https://images2.imgbox.com/99/ac/a06coVfF_o.png" width="1200"><img alt="" height="823" src="https://images2.imgbox.com/b0/51/pMg3vJWE_o.png" width="1200"> </p> 
<h4 id="3.4.4%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8PWM%E8%BE%93%E5%87%BA%E5%AE%9E%E9%AA%8C%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4">3.4.4 通用定时器PWM输出实验配置步骤</h4> 
<p><img alt="" height="675" src="https://images2.imgbox.com/b7/81/NOdrDO0a_o.png" width="1200"></p> 
<p><img alt="" height="562" src="https://images2.imgbox.com/95/f3/MiRa33NX_o.png" width="1200"><img alt="" height="685" src="https://images2.imgbox.com/da/cb/4zJGzM1S_o.png" width="1200"><img alt="" height="752" src="https://images2.imgbox.com/04/67/FRiHG2Ns_o.png" width="353"> </p> 
<p><img alt="" height="728" src="https://images2.imgbox.com/ea/1b/Fx1EetSV_o.png" width="850"><img alt="" height="294" src="https://images2.imgbox.com/5e/e2/H3Ca2hZt_o.png" width="1200"> </p> 
<h4 id="3.4.5%20%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%9A%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8PWM%E8%BE%93%E5%87%BA%E5%AE%9E%E9%AA%8C">3.4.5 编程实战：通用定时器PWM输出实验</h4> 
<p><img alt="" height="525" src="https://images2.imgbox.com/41/b6/y50K7doL_o.png" width="1200"><img alt="" height="531" src="https://images2.imgbox.com/97/39/SsuThAAC_o.png" width="1117"><img alt="" height="86" src="https://images2.imgbox.com/a0/7c/nXp2eK3Q_o.png" width="1200"> </p> 
<pre><code>#include "./BSP/TIMER/gtim.h"

TIM_HandleTypeDef g_timx_pwm_chy_handle;


/* 通用定时器PWM输出初始化函数 */
void gtim_timx_pwm_chy_init(uint16_t arr, uint16_t psc)
{
    TIM_OC_InitTypeDef timx_oc_pwm_chy;
    
    g_timx_pwm_chy_handle.Instance = TIM3;
    g_timx_pwm_chy_handle.Init.Prescaler = psc;
    g_timx_pwm_chy_handle.Init.Period = arr;
    g_timx_pwm_chy_handle.Init.CounterMode = TIM_COUNTERMODE_UP; // 计数模式
    HAL_TIM_PWM_Init(&amp;g_timx_pwm_chy_handle);
    
    timx_oc_pwm_chy.OCMode = TIM_OCMODE_PWM1;
    timx_oc_pwm_chy.Pulse = arr / 2;  // 比较值，就是CCRx的值
    timx_oc_pwm_chy.OCPolarity = TIM_OCPOLARITY_LOW; // 输出极性为低，低电平有效
    HAL_TIM_PWM_ConfigChannel(&amp;g_timx_pwm_chy_handle, &amp;timx_oc_pwm_chy, TIM_CHANNEL_2);
    
    HAL_TIM_PWM_Start(&amp;g_timx_pwm_chy_handle, TIM_CHANNEL_2);


}

/* 定时器输出PWM MSP初始化函数 */
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
{
    if(htim-&gt;Instance == TIM3)
    {
        GPIO_InitTypeDef gpio_init_struct;
        __HAL_RCC_GPIOB_CLK_ENABLE();                                 /* LED0时钟使能 */
        __HAL_RCC_TIM3_CLK_ENABLE();                                 /* LED1时钟使能 */

        gpio_init_struct.Pin = GPIO_PIN_5;                   /* LED0引脚 */
        gpio_init_struct.Mode = GPIO_MODE_AF_PP;            /* 复用推挽输出 */
        gpio_init_struct.Pull = GPIO_PULLUP;                    /* 上拉 */
        gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH;          /* 高速 */
        HAL_GPIO_Init(GPIOB, &amp;gpio_init_struct);       /* 初始化LED0引脚 */

        /* 重映射 */
        __HAL_RCC_AFIO_CLK_ENABLE();
        __HAL_AFIO_REMAP_TIM3_PARTIAL();
    
    }

}


</code></pre> 
<pre><code>
#include "./SYSTEM/sys/sys.h"
#include "./SYSTEM/delay/delay.h"
#include "./SYSTEM/usart/usart.h"
#include "./BSP/LED/led.h"
#include "./BSP/TIMER/gtim.h"

extern TIM_HandleTypeDef g_timx_pwm_chy_handle;

int main(void)
{
    uint16_t ledpwm = 0;
    uint8_t dir = 1;
    
    HAL_Init();                                 /* 初始化HAL库 */
    sys_stm32_clock_init(RCC_PLL_MUL9);         /* 设置时钟,72M */
    delay_init(72);                             /* 初始化延时函数 */
    led_init();                                 /* 初始化LED */
    usart_init(115200);
    gtim_timx_pwm_chy_init(499, 71);   // 2KHz
    
    
    
    while(1)
    {
        
        delay_ms(10);
        
        if(dir) ledpwm++;
        else ledpwm--;
        
        if(ledpwm &gt; 300) dir = 0;
        if(ledpwm == 0) dir = 1;
        
        __HAL_TIM_SET_COMPARE(&amp;g_timx_pwm_chy_handle, TIM_CHANNEL_2, ledpwm);
    }
}

</code></pre> 
<h3 id="3.5%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%AE%9E%E9%AA%8C">3.5 通用定时器输入捕获实验</h3> 
<p><img alt="" height="517" src="https://images2.imgbox.com/6f/53/odhgFEG8_o.png" width="1043"></p> 
<h4 id="3.5.1%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E9%83%A8%E5%88%86%E6%A1%86%E5%9B%BE">3.5.1 通用定时器输入捕获部分框图</h4> 
<p><img alt="" height="631" src="https://images2.imgbox.com/0d/5d/b3rxa7Ej_o.png" width="1200">只要 CC1S 不是00就是输入模式 </p> 
<p><img alt="" height="667" src="https://images2.imgbox.com/32/bf/3rkeilm6_o.png" width="1200"></p> 
<p><img alt="" height="676" src="https://images2.imgbox.com/3f/28/tBUaUIo5_o.png" width="1200">CCR1读操作完成后，影子寄存器的值才会被转移到预装载寄存器中  </p> 
<p></p> 
<h4 id="3.5.2%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E8%84%89%E5%AE%BD%E6%B5%8B%E9%87%8F%E5%8E%9F%E7%90%86">3.5.2 通用定时器输入捕获脉宽测量原理</h4> 
<p>       t1 处产生一个捕获事件，将计数器的计数值转移到CCR1中 ，此时将计数器的值清零，将上升沿检测改为下降沿检测，</p> 
<p><img alt="" height="735" src="https://images2.imgbox.com/51/fa/0qWC8NPV_o.png" width="1200"><img alt="" height="706" src="https://images2.imgbox.com/e4/f1/fJBeWV0X_o.png" width="1200"><img alt="" height="687" src="https://images2.imgbox.com/68/18/uONyxkqa_o.png" width="1200"><img alt="" height="623" src="https://images2.imgbox.com/65/4d/p6TK5r6V_o.png" width="1200">输入捕获分频系数：捕获几个上升沿触发 </p> 
<p>Polarity</p> 
<p><img alt="" height="291" src="https://images2.imgbox.com/8c/09/w95oIAc4_o.png" width="984"></p> 
<p>Selection </p> 
<p><img alt="" height="288" src="https://images2.imgbox.com/cf/53/Ab1GQmed_o.png" width="1064">Prescaler </p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/cb/2c/1DUoEQJL_o.png" width="928">Filter</p> 
<p><img alt="" height="432" src="https://images2.imgbox.com/8c/53/j93LCMFv_o.png" width="1200"></p> 
<h4 id="3.5.4%C2%A0%20%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%9A%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%AE%9E%E9%AA%8C">3.5.4  编程实战：通用定时器输入捕获实验</h4> 
<p><img alt="" height="407" src="https://images2.imgbox.com/aa/6a/DiJWLkrb_o.png" width="1200"></p> 
<p>72Mhz / 72 =1MHz 就是1us（1微秒）计数一次</p> 
<p><img alt="" height="720" src="https://images2.imgbox.com/f9/cf/IKw4KhNo_o.png" width="1200"><img alt="" height="646" src="https://images2.imgbox.com/ef/b5/gNsouJzR_o.png" width="1200"></p> 
<pre><code>#include "./BSP/TIMER/gtim.h"



TIM_HandleTypeDef g_timx_cap_chy_handle;

void gtim_timx_cap_chy_init(uint16_t arr, uint16_t psc)
{
    TIM_IC_InitTypeDef timx_ic_cap_chy = {0};                       /* 初始化结构体变量建议给个初值0 */
    
    g_timx_cap_chy_handle.Instance = TIM5;                          /* 定时器5 */
    g_timx_cap_chy_handle.Init.Prescaler = psc;                     /* 定时器分频 */
    g_timx_cap_chy_handle.Init.CounterMode = TIM_COUNTERMODE_UP;    /* 递增计数模式 */
    g_timx_cap_chy_handle.Init.Period = arr;                        /* 自动重装载值 */
    HAL_TIM_IC_Init(&amp;g_timx_cap_chy_handle);
    
    timx_ic_cap_chy.ICPolarity = TIM_ICPOLARITY_RISING;             /* 上升沿捕获 */
    timx_ic_cap_chy.ICSelection = TIM_ICSELECTION_DIRECTTI;         /* 映射到TI1 */
    timx_ic_cap_chy.ICPrescaler = TIM_ICPSC_DIV1;                   /* 配置输入分频 */
    timx_ic_cap_chy.ICFilter = 0;                                   /* 配置输入滤波器 */
    HAL_TIM_IC_ConfigChannel(&amp;g_timx_cap_chy_handle, &amp;timx_ic_cap_chy, TIM_CHANNEL_1);

    __HAL_TIM_ENABLE_IT(&amp;g_timx_cap_chy_handle, TIM_IT_UPDATE);     /* 使能更新中断 */
    HAL_TIM_IC_Start_IT(&amp;g_timx_cap_chy_handle, TIM_CHANNEL_1);     /* 开始捕获TIM5的通道1，捕获中断使能 */

}


void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
{
    if(htim-&gt;Instance == TIM5)
    {
        GPIO_InitTypeDef gpio_init_struct;
        __HAL_RCC_TIM5_CLK_ENABLE();
        __HAL_RCC_GPIOA_CLK_ENABLE();
        
        gpio_init_struct.Pin = GPIO_PIN_0;
        gpio_init_struct.Mode = GPIO_MODE_AF_PP; // 复用功能是可以读取io的电平情况的,输出也能读值
        gpio_init_struct.Pull = GPIO_PULLDOWN;
        gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH;
        HAL_GPIO_Init(GPIOA, &amp;gpio_init_struct);
        
        HAL_NVIC_SetPriority(TIM5_IRQn, 1, 3);
        HAL_NVIC_EnableIRQ(TIM5_IRQn);
       
    }
}    

/* 输入捕获状态（g_timxchy_cap_sta）
 * [7]  ：0，没有成功的捕获；1，成功捕获1次
 * [6]  ：0，还没捕获到高电平；1，已经捕获到高电平
 * [5:0]：捕获高电平后溢出的次数，最多溢出63次，所以最长捕获值 = 63*65536 + 65535 = 4194303
 *        注意：为了通用，我们默认ARR和CCRy都是16位寄存器，对于32位的定时器（如TIM5），也只按16位计算
 *        F1系列定时器都是16位，把g_timxchy_cap_sta定义为uint16_t，还可以测的时间更长
 *        按1us的计数频率，最长溢时间为：4194303 us，约4.19s
 *
 *        说明一下：正常32位的定时器来说，1us计数器加1，溢出时间为4294秒，2^32 = 4294967296
 *
 */

uint8_t g_timxchy_cap_sta = 0;  /* 输入捕获状态 */
uint16_t g_timxchy_cap_val = 0; /* 输入捕获值 */

/* 定时器5中断服务函数 */
void TIM5_IRQHandler(void)
{
    HAL_TIM_IRQHandler(&amp;g_timx_cap_chy_handle);
}

/* 定时器输入捕获中断回调函数 */
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
    if(htim-&gt;Instance == TIM5)
    {
        if((g_timxchy_cap_sta &amp; 0x80) == 0) // 还没有成功捕获
        {
            if(g_timxchy_cap_sta &amp; 0x40)    // 捕获下降沿
            {
                g_timxchy_cap_sta |= 0x80;   // 标记捕获到一次高电平
                g_timxchy_cap_val = HAL_TIM_ReadCapturedValue(&amp;g_timx_cap_chy_handle, TIM_CHANNEL_1);
                TIM_RESET_CAPTUREPOLARITY(&amp;g_timx_cap_chy_handle, TIM_CHANNEL_1);  // 清除原来的设置
                TIM_SET_CAPTUREPOLARITY(&amp;g_timx_cap_chy_handle, TIM_CHANNEL_1, TIM_ICPOLARITY_RISING);// 开启新一次捕获上升沿
            }
            else /* 还未开始，第一次捕获上升沿 */
            {
                g_timxchy_cap_sta = 0;
                g_timxchy_cap_val = 0;
                g_timxchy_cap_sta |= 0x40;   // 标记捕获到了上升沿
                __HAL_TIM_DISABLE(&amp;g_timx_cap_chy_handle);              // 关闭定时器5
                __HAL_TIM_SET_COUNTER(&amp;g_timx_cap_chy_handle, 0);       // 定时器5计数器清零
                TIM_RESET_CAPTUREPOLARITY(&amp;g_timx_cap_chy_handle, TIM_CHANNEL_1);// 清除原来的设置
                TIM_SET_CAPTUREPOLARITY(&amp;g_timx_cap_chy_handle, TIM_CHANNEL_1, TIM_ICPOLARITY_FALLING); // 捕获下降沿
                __HAL_TIM_ENABLE(&amp;g_timx_cap_chy_handle);               // 使能定时器5
            }
        }
    }
}

/* 定时器更新中断回调函数 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim-&gt;Instance == TIM5)
    {
        if((g_timxchy_cap_sta &amp; 0x80) == 0) // 还没有成功捕获
        {
            if(g_timxchy_cap_sta &amp; 0x40)    // 捕获下降沿
            {
                if((g_timxchy_cap_sta &amp; 0x3F) == 0x3F) /* 高电平太长了 */
                {
                    TIM_RESET_CAPTUREPOLARITY(&amp;g_timx_cap_chy_handle, TIM_CHANNEL_1);// 清除原来的设置
                    TIM_SET_CAPTUREPOLARITY(&amp;g_timx_cap_chy_handle, TIM_CHANNEL_1, TIM_ICPOLARITY_RISING); // 设置捕获上升沿
                    g_timxchy_cap_sta |= 0X80;
                    g_timxchy_cap_val = 0XFFFF;
                }
                else   /* 累计定时器溢出次数 */
                {
                    g_timxchy_cap_sta++;
                }
            }
        }
    }

}


</code></pre> 
<pre><code>#include "./SYSTEM/sys/sys.h"
#include "./SYSTEM/delay/delay.h"
#include "./SYSTEM/usart/usart.h"
#include "./BSP/LED/led.h"
#include "./BSP/TIMER/gtim.h"

extern uint8_t g_timxchy_cap_sta;  /* 输入捕获状态 */
extern uint16_t g_timxchy_cap_val; /* 输入捕获值 */

int main(void)
{
    uint32_t temp = 0;
    uint8_t t = 0;
    
    HAL_Init();                                 /* 初始化HAL库 */
    sys_stm32_clock_init(RCC_PLL_MUL9);         /* 设置时钟,72M */
    delay_init(72);                             /* 初始化延时函数 */
    led_init();                                 /* 初始化LED */
    usart_init(115200);
    gtim_timx_cap_chy_init(65535, 71);
    
    while(1)
    {
        if(g_timxchy_cap_sta &amp; 0x80) // 还没有成功捕获
        {
            temp = g_timxchy_cap_sta &amp; 0x3F;
            temp *= 65536;               /* 溢出时间总和 */
            temp += g_timxchy_cap_val;   /* 总的高电平时间 */
            printf("HIGH:%d us\r\n", temp);
            g_timxchy_cap_sta = 0;       /* 开启下一次捕获 */
        }
        
        t++;
        
        if(t &gt; 20)                       /* 200ms进入一次 */
        {
            t = 0;
            LED0_TOGGLE();               /* LED0闪烁，提是程序在运行 */
        }
        delay_ms(10);
    }
}

</code></pre> 
<p></p> 
<h3 id="3.6%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%84%89%E5%86%B2%E8%AE%A1%E6%95%B0%E5%AE%9E%E9%AA%8C">3.6 通用定时器脉冲计数实验</h3> 
<p><img alt="" height="455" src="https://images2.imgbox.com/87/74/hRyts751_o.png" width="1088">4个时钟源：（1）内部时钟；（2）外部触发1：由CH1、CH2；（3）外部触发2：由IO的ETR；（4）内部触发输入：一般用于级联 </p> 
<p><img alt="" height="644" src="https://images2.imgbox.com/9b/e1/8z3lfvR0_o.png" width="1200"></p> 
<p></p> 
<h4 id="3.6.1%20%E8%84%89%E5%86%B2%E8%AE%A1%E6%95%B0%E5%AE%9E%E9%AA%8C%E5%8E%9F%E7%90%86">3.6.1 脉冲计数实验原理</h4> 
<p><img alt="" height="833" src="https://images2.imgbox.com/87/78/hnTGKfWg_o.png" width="1200"></p> 
<p><img alt="" height="686" src="https://images2.imgbox.com/de/35/o7eG11R1_o.png" width="1200"></p> 
<p></p> 
<h4 id="3.6.2%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%84%89%E5%86%B2%E8%AE%A1%E6%95%B0%E5%AE%9E%E9%AA%8C%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4">3.6.2 通用定时器脉冲计数实验配置步骤</h4> 
<p><img alt="" height="673" src="https://images2.imgbox.com/b5/93/79dzMuOk_o.png" width="1200"><img alt="" height="588" src="https://images2.imgbox.com/1d/22/9j3GPCZA_o.png" width="1200"><img alt="" height="444" src="https://images2.imgbox.com/07/5c/L6ul9InT_o.png" width="935"></p> 
<p><img alt="" height="556" src="https://images2.imgbox.com/66/74/NU8KNXsa_o.png" width="1200"></p> 
<p><strong>SlaveMode：</strong></p> 
<p><img alt="" height="262" src="https://images2.imgbox.com/e3/50/uRBuZ6JA_o.png" width="1200"><br>  （1）DISABLE：不使用从模式就是使用内部时钟</p> 
<p> （2）RESET：复位 </p> 
<p> （3）GATED：门电路</p> 
<p> （4）TRIGGER：触发模式 </p> 
<p> （5）EXTERNAL1：外部时钟模式1</p> 
<p></p> 
<p><strong>触发源： </strong></p> 
<p><img alt="" height="313" src="https://images2.imgbox.com/39/fd/yR7Oo7ZW_o.png" width="1200"><img alt="" height="555" src="https://images2.imgbox.com/e1/8e/vRFWYXGm_o.png" width="1200"> </p> 
<p><strong>边沿检测器： </strong></p> 
<p><img alt="" height="682" src="https://images2.imgbox.com/01/dc/1u0D4TFN_o.png" width="1200">边沿检测器有2个， 上2个是上面的检测器，下3个是下面的检测器</p> 
<p><img alt="" height="258" src="https://images2.imgbox.com/c5/00/QKUcNzOa_o.png" width="1200">BOTHEDGE用处暂不明</p> 
<p></p> 
<p><strong>分频器：</strong></p> 
<p><img alt="" height="236" src="https://images2.imgbox.com/6f/6a/1Jh1TwLr_o.png" width="1200">外2会用到分频器，外1没用到 </p> 
<p></p> 
<p><strong>滤波器：</strong></p> 
<p><img alt="" height="672" src="https://images2.imgbox.com/28/16/1Ey5cXcm_o.png" width="1191">滤波器外1和外2都用到了，实验里没用</p> 
<p></p> 
<h4 id="3.6.3%20%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%9A%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%84%89%E5%86%B2%E8%AE%A1%E6%95%B0%E5%AE%9E%E9%AA%8C">3.6.3 编程实战：通用定时器脉冲计数实验</h4> 
<p><img alt="" height="499" src="https://images2.imgbox.com/ea/dd/wNeG3BrM_o.png" width="1200"></p> 
<p><img alt="" height="751" src="https://images2.imgbox.com/4a/95/h4MHBgZq_o.png" width="1200"></p> 
<p><img alt="" height="521" src="https://images2.imgbox.com/3b/12/prB8AWDR_o.png" width="1200"></p> 
<p><img alt="" height="817" src="https://images2.imgbox.com/00/5c/Q3cMq4eY_o.png" width="1200"></p> 
<pre><code>#include "./BSP/TIMER/gtim.h"

TIM_HandleTypeDef g_timx_cap_chy_handle;

void gtim_timx_cap_chy_init(uint16_t arr, uint16_t psc)
{
    TIM_SlaveConfigTypeDef tim_slave_config = {0};
    
    g_timx_cap_chy_handle.Instance = TIM2;                          /* 定时器5 */
    g_timx_cap_chy_handle.Init.Prescaler = psc;                     /* 定时器分频 */
    g_timx_cap_chy_handle.Init.CounterMode = TIM_COUNTERMODE_UP;    /* 递增计数模式 */
    g_timx_cap_chy_handle.Init.Period = arr;                        /* 自动重装载值 */
    HAL_TIM_IC_Init(&amp;g_timx_cap_chy_handle);
    
    tim_slave_config.SlaveMode = TIM_SLAVEMODE_EXTERNAL1;
    tim_slave_config.InputTrigger = TIM_TS_TI1FP1;
    tim_slave_config.TriggerPolarity = TIM_TRIGGERPOLARITY_RISING;
    tim_slave_config.TriggerFilter = 0;
    HAL_TIM_SlaveConfigSynchro(&amp;g_timx_cap_chy_handle, &amp;tim_slave_config);
    
    HAL_TIM_IC_Start(&amp;g_timx_cap_chy_handle, TIM_CHANNEL_1);

}

void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
{
    if(htim-&gt;Instance == TIM2)
    {
        GPIO_InitTypeDef gpio_init_struct;
        __HAL_RCC_TIM2_CLK_ENABLE();
        __HAL_RCC_GPIOA_CLK_ENABLE();
        
        gpio_init_struct.Pin = GPIO_PIN_0;
        gpio_init_struct.Mode = GPIO_MODE_AF_PP; // 复用功能是可以读取io的电平情况的,输出也能读值
        gpio_init_struct.Pull = GPIO_PULLDOWN;
        gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH; // 输入可以不设置速度
        HAL_GPIO_Init(GPIOA, &amp;gpio_init_struct);
       
    }
}  
</code></pre> 
<pre><code>#include "./SYSTEM/sys/sys.h"
#include "./SYSTEM/delay/delay.h"
#include "./SYSTEM/usart/usart.h"
#include "./BSP/LED/led.h"
#include "./BSP/TIMER/gtim.h"
#include "./BSP/KEY/key.h"

extern TIM_HandleTypeDef g_timx_cap_chy_handle;

int main(void)
{
    uint16_t curcnt;
    uint16_t oldcnt;
    uint8_t key;
    uint8_t t = 0;
    
    HAL_Init();                                 /* 初始化HAL库 */
    sys_stm32_clock_init(RCC_PLL_MUL9);         /* 设置时钟,72M */
    delay_init(72);                             /* 初始化延时函数 */
    led_init();                                 /* 初始化LED */
    usart_init(115200);
    gtim_timx_cap_chy_init(65535, 0);
    key_init();
    
    while(1)
    {
        key = key_scan(0);
        if(key == KEY0_PRES)
        {
            __HAL_TIM_SET_COUNTER(&amp;g_timx_cap_chy_handle, 0);
        }            
        
        curcnt = __HAL_TIM_GET_COUNTER(&amp;g_timx_cap_chy_handle);
        if(oldcnt != curcnt)
        {
            oldcnt = curcnt;
            printf("CNT:%d\r\n", oldcnt);
        }
        t ++;
        
        if(t &gt; 20)
        {
            t = 0;
            LED0_TOGGLE();
        }
        delay_ms(10);
    }
}

</code></pre> 
<p>       此时定时器计数cnt == arr 的时候会溢出，因为设置了 arr = 65535，所以最大计数值即最大捕获数量就是 65535，如果要增大计数量，可以添加定时器更新中断</p> 
<p></p> 
<h2 id="%E5%9B%9B%E3%80%81%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8">四、高级定时器</h2> 
<p><img alt="" height="599" src="https://images2.imgbox.com/ea/18/dIqNpDee_o.png" width="1011"></p> 
<h3 id="4.1%20%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%80%E4%BB%8B">4.1 高级定时器简介</h3> 
<p><img alt="" height="719" src="https://images2.imgbox.com/d0/bb/hme3izBh_o.png" width="1200"><img alt="" height="727" src="https://images2.imgbox.com/3c/24/elSpNPOp_o.png" width="1200">重复计数器，对REP寄存器写一个值，每次溢出就减1，指导减为0后，就产生更新事件</p> 
<p></p> 
<h3 id="4.2%20%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A1%86%E5%9B%BE">4.2 高级定时器框图</h3> 
<p><img alt="" height="885" src="https://images2.imgbox.com/16/d3/IfLcqND2_o.png" width="1200">通道1、2、3都有CHxN就是互补通道 </p> 
<p></p> 
<h3 id="4.3%C2%A0%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%87%BA%E6%8C%87%E5%AE%9A%E4%B8%AA%E6%95%B0PWM%E5%AE%9E%E9%AA%8C">4.3 高级定时器输出指定个数PWM实验</h3> 
<p><img alt="" height="536" src="https://images2.imgbox.com/6f/65/YkKJYfF0_o.png" width="1186"></p> 
<p></p> 
<h4 id="4.3.1%20%E9%87%8D%E5%A4%8D%E8%AE%A1%E6%95%B0%E5%99%A8%E7%89%B9%E6%80%A7%C2%A0">4.3.1 重复计数器特性 </h4> 
<p><img alt="" height="856" src="https://images2.imgbox.com/95/57/XMbAViWO_o.png" width="1200"></p> 
<p>       再同步就是软件手动产生更新事件后，RCR寄存器的值会再缓冲到它的影子寄存器中，影子寄存器就被重置了</p> 
<p><img alt="" height="678" src="https://images2.imgbox.com/2b/0c/3zD8eFrX_o.png" width="1200"></p> 
<p><img alt="" height="842" src="https://images2.imgbox.com/71/09/0QIVezN0_o.png" width="1200"></p> 
<p>  </p> 
<h4 id="4.3.2%20%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%87%BA%E6%8C%87%E5%AE%9A%E4%B8%AA%E6%95%B0PWM%E4%B8%AA%E6%95%B0">4.3.2 高级定时器输出指定个数PWM个数</h4> 
<p><img alt="" height="554" src="https://images2.imgbox.com/de/1c/zlkplCpv_o.png" width="1168"></p> 
<p><img alt="" height="698" src="https://images2.imgbox.com/9c/74/ye4KCz0i_o.png" width="1200"></p> 
<p> p105  5：43</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ecc06b35395001cbb75cc6b1c4f41a51/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ChatGLM-6B tuning 推理源码解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/aebec994845ed94b2b8a03ed0783b529/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数组的应用之单位转换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>