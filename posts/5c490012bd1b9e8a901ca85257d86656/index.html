<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端八股文整理 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="前端八股文整理" />
<meta property="og:description" content="HTML Canvas元素有什么用
HTML5的canvas元素使用javascript在网页上绘制图形
前端模块化规范
①说说自己对前端模块化开发的认识
(1)异步模块定义(AMD)规范是require.js推广的对模块定义的规范。
(2)通用模块定义（CMD）规范是SeaJS推广的对模块定义的规范。
(3)AMD提前执行，CMD延迟执行
②为什么需要前端模块化
高内聚低耦合，有利于团队开发，方便维护以及代码块复用。
③EMAScript 6模块规范
(1)对比于Commonjs,语法更简洁，可以更好地支持循环依赖
(2)对比于AMD,直接支持异步加载和配置模块加载
(3)对于结构可以做静态分析、静态检测
④模块化Javascript开发的优势是什么
(1)将功能分离出来
(2)具有更好的代码组织方式
(3)可以按需加载
(4)避免了命名冲突
（5）解决了依赖问题
⑤require.js解决了什么问题
(1)实现了javascript文件的异步加载
(2)有助于管理模块之间的依赖性
(3)便于代码的编写和维护
⑥说说对CommonJS和AMD的理解
CommonJS是服务器端模块的规范，规范同步加载模块，也就是说，只有加载完成，才能执行后面的操作，Node.js采用了这个规范，CommonJS的风格是通过对module.exports或exports的属性赋值来达到暴露模块接口的目的。
AMD规范则非同步加载模块，允许指定回调函数，AMD推荐的风格是通过module transport规范暴露接口，即通过返回一个对象暴露模块接口。
CSS
css的盒模型
元素实际宽度尺寸=width&#43;padding&#43;border
em与rem的区别
em相对于父元素，rem相对于根元素
BFC的形成和作用
BFC属于常规流，它是页面上的一个隔离的独立容器，容器里的子元素不会影响到外面的元素。
作用：①解决外部边距重叠；②解决父元素因子元素浮动带来的塌陷问题
移动端自适应的方式
1.媒体查询：通过查询设备的宽度来执行不同的css代码
2.Flex弹性布局：高度定死，宽度自适应，元素都采用px做单位
3.rem&#43;viewport缩放：根据屏幕宽度设定rem值，需要适配的元素都使用rem为单位，不需要适配的元素还是使用px为单位。
4.rem实现：通过代码来控制rem基准值
JS JS的数据类型
①基本数据类型：number\string\boolean\undefined\null\symbol
②引用数据类型：object\array\function
注意：基本数据类型保存在栈中，复制的是值本身，修改时都会发生变化；引用数据类型保存在堆里，复制的是地址
let const var的区别
var存在变量提升，let和const不存在
var没有块级作用域，let和const具有
var允许重复声明，let和const在同一作用域不允许重复声明
var和let声明的变量可以修改，而const是常量，不能修改
如何阻止冒泡和默认行为
e.stopPropagation()
e.preventDefault()
setInterval和setTimeout的区别
setInterval():可循环执行多次，一般用于刷新表单
setTimeout():只执行一次，用于延迟执行某方法或功能
获取DOM元素有哪些方法
document.getElementById()
document.getElementByTagName()
document.getElementByClassName()
document.getElementByName()
document.querySelector()
document.querySelectorAll()
事件机制有几个阶段
三个阶段：事件捕获、事件触发、事件冒泡。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/5c490012bd1b9e8a901ca85257d86656/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-25T20:18:19+08:00" />
<meta property="article:modified_time" content="2022-08-25T20:18:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端八股文整理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><span style="color:#9c8ec1;"><strong>HTML </strong></span></h3> 
<p><span style="color:#0d0016;"><strong>Canvas元素有什么用</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        </strong>HTML5的canvas元素使用javascript在网页上绘制图形</span></p> 
<p><strong>前端模块化规范</strong></p> 
<p><strong>        </strong>①说说自己对前端模块化开发的认识</p> 
<p>                (1)异步模块定义(AMD)规范是require.js推广的对模块定义的规范。</p> 
<p>                (2)通用模块定义（CMD）规范是SeaJS推广的对模块定义的规范。</p> 
<p>                (3)AMD提前执行，CMD延迟执行</p> 
<p>        ②为什么需要前端模块化</p> 
<p>                高内聚低耦合，有利于团队开发，方便维护以及代码块复用。</p> 
<p>        ③EMAScript 6模块规范</p> 
<p>                (1)对比于Commonjs,语法更简洁，可以更好地支持循环依赖</p> 
<p>                (2)对比于AMD,直接支持异步加载和配置模块加载</p> 
<p>                (3)对于结构可以做静态分析、静态检测</p> 
<p>        ④模块化Javascript开发的优势是什么</p> 
<p>                (1)将功能分离出来</p> 
<p>                (2)具有更好的代码组织方式</p> 
<p>                (3)可以按需加载</p> 
<p>                (4)避免了命名冲突</p> 
<p>              （5）解决了依赖问题</p> 
<p>        ⑤require.js解决了什么问题</p> 
<p>                (1)实现了javascript文件的异步加载</p> 
<p>                (2)有助于管理模块之间的依赖性</p> 
<p>                (3)便于代码的编写和维护</p> 
<p>        ⑥说说对CommonJS和AMD的理解</p> 
<p>                CommonJS是服务器端模块的规范，规范同步加载模块，也就是说，只有加载完成，才能执行后面的操作，Node.js采用了这个规范，CommonJS的风格是通过对module.exports或exports的属性赋值来达到暴露模块接口的目的。</p> 
<p>                AMD规范则非同步加载模块，允许指定回调函数，AMD推荐的风格是通过module transport规范暴露接口，即通过返回一个对象暴露模块接口。</p> 
<p></p> 
<p><span style="color:#9c8ec1;"><strong>CSS</strong></span></p> 
<p><strong>css的盒模型</strong></p> 
<p>        元素实际宽度尺寸=width+padding+border</p> 
<p><strong>em与rem的区别</strong></p> 
<p><strong>       </strong> em相对于父元素，rem相对于根元素</p> 
<p><strong>BFC的形成和作用</strong></p> 
<p><strong>      </strong> BFC属于常规流，它是页面上的一个隔离的独立容器，容器里的子元素不会影响到外面的元素。</p> 
<p>        作用：①解决外部边距重叠；②解决父元素因子元素浮动带来的塌陷问题</p> 
<p><strong>移动端自适应的方式</strong></p> 
<p><strong>      </strong>  1.媒体查询：通过查询设备的宽度来执行不同的css代码</p> 
<p>        2.Flex弹性布局：高度定死，宽度自适应，元素都采用px做单位</p> 
<p>        3.rem+viewport缩放：根据屏幕宽度设定rem值，需要适配的元素都使用rem为单位，不需要适配的元素还是使用px为单位。</p> 
<p>        4.rem实现：通过代码来控制rem基准值</p> 
<p></p> 
<h3><span style="color:#9c8ec1;"><strong>JS</strong></span></h3> 
<p><strong>JS的数据类型</strong></p> 
<p><strong>        </strong>①基本数据类型：number\string\boolean\undefined\null\symbol</p> 
<p>        ②引用数据类型：object\array\function</p> 
<p>        注意：基本数据类型保存在栈中，复制的是值本身，修改时都会发生变化；引用数据类型保存在堆里，复制的是地址</p> 
<p><strong>let const var的区别</strong></p> 
<p><strong>       </strong> var存在变量提升，let和const不存在</p> 
<p>        var没有块级作用域，let和const具有</p> 
<p>        var允许重复声明，let和const在同一作用域不允许重复声明</p> 
<p>        var和let声明的变量可以修改，而const是常量，不能修改</p> 
<p><strong>如何阻止冒泡和默认行为</strong></p> 
<p>        e.stopPropagation()</p> 
<p>        e.preventDefault()</p> 
<p><strong>setInterval和setTimeout的区别</strong></p> 
<p>        setInterval():可循环执行多次，一般用于刷新表单</p> 
<p>        setTimeout():只执行一次，用于延迟执行某方法或功能</p> 
<p><strong>获取DOM元素有哪些方法</strong></p> 
<p>        document.getElementById()</p> 
<p>        document.getElementByTagName()</p> 
<p>        document.getElementByClassName()</p> 
<p>        document.getElementByName()</p> 
<p>        document.querySelector()</p> 
<p>        document.querySelectorAll()</p> 
<p><strong>事件机制有几个阶段</strong></p> 
<p><strong>        </strong>三个阶段：事件捕获、事件触发、事件冒泡。</p> 
<p><strong>事件循环</strong></p> 
<p><strong>        </strong>浏览器中js代码是单线程执行，不存在并发，异步是通过维护一个队列来执行的，这样的机制叫事件循环</p> 
<p><strong>事件委托</strong></p> 
<p><strong>       </strong>事件委托也叫事件代理，“事件代理”即是把原本需要绑定在子元素的响应事件（click、keydown…）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。<strong> </strong></p> 
<p><strong>JS阻塞问题</strong></p> 
<p><strong>     </strong>   指当浏览器在解析文档或者渲染页面时，遇见了JS代码，需要渲染引擎中断，而运行js引擎，从而阻塞浏览器原本的工作状态。</p> 
<p>        解决方法：将script标签放在头部，加上async或defer属性，两者都可以让浏览器进行异步加载js代码或者利用DOM动态创建script标签</p> 
<p><strong>New操作符的原理</strong></p> 
<p><strong>       </strong> 创建一个空对象作为将要返回的对象实例，将这个空对象的原型指向构造函数的prototype属性，将这个空对象赋值给函数内部的this关键字，开始执行内部的代码。</p> 
<p><strong>闭包的作用和原理</strong></p> 
<p><strong>       </strong> 闭包就是能够读取其他函数内部变量的函数，作用是将函数内部和函数外部连接起来的桥梁。</p> 
<p><strong>ES5、ES6如何实现继承</strong></p> 
<p><strong>       </strong> ES5的继承通过prototype或构造函数机制来实现，ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上。</p> 
<p>        ES6通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承。子类必须在constructor方法中调用super方法，否则新建实例报错，因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工，如果不调用super方法，子类得不到this对象。</p> 
<p><strong>Javascript异步编程</strong></p> 
<p><strong>        </strong>四种方法：①回调函数②事件监听③发布/订阅④Promise对象</p> 
<p><strong>数据类型的检测方式</strong></p> 
<p><strong>        </strong>①typeof--&gt;console.log(typeof 1)--&gt;number</p> 
<p>        ②instanceof--&gt;console.log(1 instanceof Number)--&gt;false 只能判断引用数据类型</p> 
<p>        ③constructor--&gt;console.log((1).constructor===number)--&gt;true</p> 
<p>        ④Object.prototype.toString.call()</p> 
<p>                var a=Object.prototype.toString;</p> 
<p>                console.log(a.call(1))--&gt;[object Number]</p> 
<p><strong>判断数组的方法</strong></p> 
<p><strong>       </strong> let arr=[]</p> 
<p><strong>        </strong>①instanceof--&gt;console.log(arr instanceof Array)</p> 
<p>        ②constructor--&gt;console.log(arr.constructor===Array)</p> 
<p>        ③isPrototypeOf--&gt;console.log(Array.prototype.isPrototypeOf(arr))</p> 
<p>        ④Object.getPrototypeOf--&gt;</p> 
<p>                console.log(Object.getPrototypeOf(arr)===Array.prototype)</p> 
<p>        ⑤Object.prototype.toString--&gt;</p> 
<p>                console.log(Object.prototype.toString.call(arr)==='[Array type]')</p> 
<p>        ⑥Array.isArray--&gt;console.log(Array.isArray(arr))</p> 
<p><strong>遍历数组的方法</strong></p> 
<p><strong>       </strong> 1.for循环</p> 
<p>        2.for...in</p> 
<p>        3.for...of</p> 
<p>        4.foreach方法</p> 
<p>        5.map方法</p> 
<p>        6.filter方法</p> 
<p>        for in与for of的区别：for in 遍历数组时，得到的是元素下标，for of 遍历数组时，得到的是数组元素</p> 
<p>        for与foreach的区别：for循环可以使用break跳出循环，但foreach不能；for循环可以控制循环的起点，foreach只能默认从索引0开始</p> 
<p><strong>undefined和null的区别</strong></p> 
<p><strong>       </strong> null和undefined的值相等，但类型不等；null会隐式转换为0，undefined会隐式转换为NaN</p> 
<p><strong>为什么0.1+0.2 != 0.3</strong></p> 
<p><strong>        </strong>因为发生了精度丢失，在JS内部所有的计算都是以二进制方式计算的，在0.1和0.2转换双精度二进制浮点数时，由于二进制浮点数的小数位只能存储52位，导致小数点后第53位的数要进行舍弃操作，从而造成精度丢失，最终导致0.1+0.2!=0.3</p> 
<p>        解决方案：可以先转换为整数，运算后再转换为小数。--&gt;（0.1*10+0.2*10）/10===0.3</p> 
<p><strong>箭头函数和普通函数的区别</strong></p> 
<p><strong>        </strong>1.箭头函数是匿名函数，不能作为构造函数，不能使用new</p> 
<p>        2.箭头函数不绑定arguments,取而代之的是rest参数</p> 
<p>        3.箭头函数没有原型属性且this的作用域不同</p> 
<p><strong>splice(开始的位置，截取的个数，添加的元素)</strong></p> 
<p><strong>       </strong> 返回值为由被删除的元素组成的一个数组，如果只删除了一个元素，则返回只包含一个元素的数组，如果没有删除元素，则返回空数组，这个方法会改变原数组，数组的长度会发生变化</p> 
<p><strong>this的指向有哪些情况</strong></p> 
<p><strong>      </strong>  ①全局作用域的this指向window</p> 
<p>        ②对象内部的this指向它本身</p> 
<p>        ③构造函数指向它的实例</p> 
<p>        ④apply(),bind(),call()指向函数的第一个参数</p> 
<p>        ⑤箭头函数没有自己的this,要向上层作用域找，若找到全局则指向window</p> 
<p></p> 
<h3><span style="color:#9c8ec1;"><strong>Promise</strong></span></h3> 
<p><span style="color:#494949;"><strong>定义及作用</strong></span></p> 
<p><span style="color:#494949;"><strong>        </strong>Promise是ES6中进行异步编程的新解决方案，支持链式调用，可以解决回调地狱问题，指定回调方式更灵活，具有三种状态pending\rejected\resolved</span></p> 
<p><strong>async和await</strong></p> 
<p><strong>         </strong>async用于声明一个函数是异步的，await则是等待一个异步函数执行完成的。async函数一定会返回一个promise对象，await只能在async中使用，await命令后面是一个Promise对象，返回该对象的结果，如果不是promise对象，则直接返回对应的值。</p> 
<p></p> 
<h3><span style="color:#9c8ec1;"><strong>VUE</strong></span></h3> 
<p><strong>什么是Vue的生命周期</strong></p> 
<p>        Vue实例从创建到销毁的过程，也就是从开始创建、初始化数据、编译模板、挂载DOM、渲染更新等一系列操作过程，即为Vue的生命周期。</p> 
<p><strong>Vue生命周期的作用是什么</strong></p> 
<p><strong>        </strong>帮助我们在控制整个Vue实例的过程中形成更好的逻辑</p> 
<p><strong>Vue生命周期共有几个阶段</strong></p> 
<p>        八个，分别是：创建前/后、挂载前/后、更新前/后、销毁前/后</p> 
<p>beforeCreate,created,beforeMount,mounted,beforeUpdate,updated,beforeDestory,destoryed</p> 
<p><strong>v-if和v-show</strong></p> 
<p>        相同点：都是控制元素在页面是否显示</p> 
<p>        不同点：v-show是将元素的display设置为none控制元素的隐藏，DOM元素依旧存在；v-if则是将DOM元素进行添加或删除</p> 
<p><strong>Vue的双向数据绑定原理</strong></p> 
<p><strong>        </strong>采用数据监听，解析结合订阅者模式的方式，通过Object.defineProperty()来监听各个属性的getter和setter,在数据变化时发布消息给订阅者，触发相应的监听回调，从而实现数据的双向绑定。</p> 
<p><strong>mvc和mvvm的区别</strong></p> 
<p>        ①mvc是单向的，mvvm是双向的，并且是自动的，也就是数据发生变化自动同步视图，视图发生变化自动同步数据②解决了MVC中大量的DOM操作，在数据频繁更新的时候，采用了虚拟DOM，减少过度渲染，提高性能</p> 
<p><strong>computed 和 watch </strong><br> computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值</p> 
<p>watch： 更多的是监听的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p> 
<p><strong>Vuex有几种属性</strong></p> 
<p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p> 
<p><strong>SPA单页面的理解</strong></p> 
<p><strong>        </strong>①什么是SPA</p> 
<p><strong>               </strong> SPA（single-page-application）仅在WEB页面初始化时加载相应的HTML、Javascript和css一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转，取而代之的是利用路由机制实现HTML内容的变换，UI与用户的交互，避免页面的重新加载</p> 
<p>        ②SPA单页面有什么优缺点</p> 
<p>                优点：A.用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；B.SPA相对于服务器压力更小；C.前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理</p> 
<p>                缺点：A.初次加载耗时多，为实现单页Web应用功能及显示效果，需要在加载页面的时候将javascript、css统一加载，部分页面按需加载；B.前进后退路由管理，由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；C.SEO难度较大，所有的内容都在一个页面中动态替换显示。</p> 
<p><strong>组件通信的几种方法</strong></p> 
<p></p> 
<h3><span style="color:#9c8ec1;"><strong>计算机网络</strong></span></h3> 
<p><strong>tcp的三次握手</strong></p> 
<p>        第一次握手是客户端向服务器发起的，是用来申请建立连接的，报文中的SYN标志会标记为1</p> 
<p>        第二次握手是服务器回复客户端的，用来确认并接受连接请求，报文中的SYN和ACK标志都会标记为1</p> 
<p>        第三次握手是客户端发送给服务器的，用来确认服务器的回复消息，报文中的ACK标志标记为1<strong>  </strong></p> 
<p><strong>http和https的基本概念、区别</strong></p> 
<p>        http:是一个客户端和服务器端请求和应答的标准（TCP）,用于从WWW服务器传输超文本到本地浏览器的超文本传输协议</p> 
<p>        https:是以安全为目标的HTTP通道，即HTTP下加入SSL层进行加密。其作用是建立一个信息安全通道来确保数据的传输以及网站的真实性</p> 
<p><strong>https的工作原理</strong></p> 
<p><strong>        </strong>客户端使用https url访问服务器，要求web服务器建立SSL链接，web服务器接收到客户端的请求之后，会将网站的证书传输给客户端，然后web服务器和客户端开始协商SSL链接的安全等级，客户端通过双方协商的安全等级建立会话密钥并传送给网站，web服务器则通过自己的私钥解密出会话密钥，并通过会话密钥加密与客户端之间的通信</p> 
<p><strong>http的缓存机制(强缓存与协商缓存)</strong></p> 
<p><strong>        </strong>浏览器第一次请求时，服务器返回资源，浏览器缓存在本地，并且服务器会通知浏览器一个缓存时间，下次请求如果在缓存时间内，直接使用缓存，否则进入协商缓存。</p> 
<p><strong>http与https的区别及优缺点</strong></p> 
<p><strong>        ①</strong>http是超文本协议传输协议，信息是明文传输，https协议要比http协议安全，https是具有安全性的ssl加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性②http协议默认端口为80，https协议默认端口为443③http的连接很简单，是无状态的，https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电④https缓存不如http高效，会增加数据开销⑤https协议需要ca证书，费用较高，功能越强大的证书费越高⑥SSL证书需要绑定IP，不能在同一个IP绑定多个域名，IPV4资源支持不了这种消耗</p> 
<p><strong>tcp三次握手为什么不能是两次或四次</strong><br>         两次握手无法保证服务端和客户端的接发功能都是ok的，四次握手会降低连接的速度和效率。</p> 
<p><strong>400、401、403、404、500、502状态码</strong></p> 
<p>        400状态码：请求无效--&gt;产生原因：前端提交数据的字段名称和字段类型与后台的实体没有保持一致或者是前端提交到后台的数据应该是JSON字符串类型，但是前端没有将对象JSON.stringify转化成字符串--&gt;解决方法：对照字段的名称保持一致性或者将对象通过JSON.stringify实现序列化</p> 
<p>        401状态码：当前请求需要用户验证</p> 
<p>        403状态码：服务器已经得到请求，但是拒绝执行</p> 
<p>        404 请求错误，因发送的请求语法错误,服务器无法正常读取。</p> 
<p>        500 内部服务器错误，服务器遇到未知无法解决的问题</p> 
<p>        502 无效网关，服务器作为网关且从上游服务器获取到了一个无效的HTTP响应</p> 
<p><strong>tcp和udp的区别</strong></p> 
<p><strong>        </strong>①TCP是面向链接的，UDP是面向无连接的②TCP仅支持单播传输，UDP提供了单播，多播，广播的功能③TCP的三次握手保证了连接的可靠性，UDP是面向无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会被正确接收④UDP的头部开销比TCP小，数据传输速率更高，实时性更好</p> 
<p></p> 
<h3><span style="color:#9c8ec1;"><strong>浏览器</strong></span></h3> 
<p><strong>Cookie、sessionStorage、localStorage的比较</strong></p> 
<p>        相同点：存储在客户端</p> 
<p>        不同点：①Cookie数据大小不能超过4K，sessionStorage、localStorage的存储相比而言大得多，可以达到5M+；②Cookie在设置的过期时间之前一直有效，sessionStorage数据在当前浏览器窗口关闭后自动删除，localStorage数据永久保存，浏览器关闭后数据不丢失，除非主动删除数据；</p> 
<p><strong>DOCTYPE的作用</strong></p> 
<p><strong>       </strong> 告诉浏览器解析器用什么文档标准解析此文档。</p> 
<p><strong>一个页面从输入url到渲染完成都发生了什么</strong></p> 
<p>        包括三个部分，首先是DNS解析URL,然后是浏览器发送请求与服务器进行交互，最后浏览器对接收到的html页面进行渲染</p> 
<p><strong>浏览器在生成页面的时候会生成哪两棵树</strong></p> 
<p><strong>       </strong> DOM树和CSSOM规则树，当浏览器接收到服务器传来的 HTML 文档后,会遍历文档节点,生成DOM 树, CSSOM 规则树由浏览器解析CSS 文件生成<strong> </strong></p> 
<p><strong>浏览器引擎</strong></p> 
<p><strong>      </strong>  渲染引擎：主要负责解析html和css相关文件</p> 
<p>        JS引擎：负责JS代码运行与解析</p> 
<p><strong>浏览器渲染机制</strong></p> 
<p><strong>       </strong> ①浏览器根据服务器响应返回的html，进行解析后构建一棵DOM节点树；②根据css文件，构建得到CSSOM树；③将DOM树和CSSOM树结合，精确计算每个节点的位置、尺寸等属性，构建出渲染树；④渲染至用户页面</p> 
<p><strong>浏览器跨域问题</strong></p> 
<p><strong>       </strong> ①为什么浏览器会禁止跨域：为了防止网站被恶意攻击，导致用户信息被泄露，所以浏览器使用了同源策略，防止CSRF攻击</p> 
<p>        ②什么是同源策略：同源策略是一种约定，同源是指<strong>协议、域名、端口</strong>三者相同。</p> 
<p>        ③什么是跨域：跨域是指浏览器允许向服务器发送跨域请求，从而克服Ajax只能同源使用的限制。</p> 
<p>        ④解决跨域的方案：</p> 
<p><strong>浏览器事件循环</strong></p> 
<p><strong>        </strong>主线程不断从任务队列中读取事件，这个过程是循环不断的，这种运行机制就叫做事件循环（Event Loop）,事件循环包含宏任务和微任务</p> 
<p><strong>浏览器重排重绘</strong></p> 
<p><strong>        </strong>重排更加耗费性能，重绘不一定重排，重排一定会重绘。</p> 
<p><strong>        </strong>重绘：一个元素是外观改变，但是没有改变布局。浏览器会根据元素的新属性重新绘制，元素外观重新展示，重绘不会重新布局。</p> 
<p>        重排：DOM的变化影响到了元素的几何属性，DOM树会重新计算，节点的增删也会改变DOM树，发生重排。</p> 
<p></p> 
<h3><span style="color:#9c8ec1;"><strong>前端工程化</strong></span></h3> 
<p><strong>babel的原理</strong></p> 
<p>        babel是一个js代码编译器，通过插件将高版本的js转换为需要的低版本js</p> 
<p><strong>webpack的原理</strong></p> 
<p><strong>      </strong>  通过一些loader和plugin把项目源代码打包成浏览器可以识别的代码同时做一些优化</p> 
<p><strong>Webpack构建流程</strong></p> 
<p><strong>        </strong>初始化参数--&gt;开始编译--&gt;确定入口--&gt;编译模块--&gt;完成模块编译--&gt;输出资源--&gt;输出完成</p> 
<p><strong>Webpack loader/plugin</strong></p> 
<p></p> 
<p><span style="color:#494949;"><strong>谈谈你对webpack的理解</strong></span></p> 
<p><span style="color:#494949;"><strong>        </strong>webpack是一个模块化打包JS的工具，在webpack中一切文件都是模块，通过loader转换文件，通过plugin注入钩子，最后输出由多个模块组合而成的文件。</span></p> 
<p><strong><span style="color:#494949;">bundle\chunk\Loader\Plugin是什么</span></strong></p> 
<p><strong><span style="color:#494949;">        </span></strong><span style="color:#494949;">bundle:由webpack打包出来的文件</span></p> 
<p><span style="color:#494949;">        chunk:是一个代码块一个chunk由多个模块组合而成</span></p> 
<p><span style="color:#494949;">        Loader:因为webpack本身只理解javascript,所以loader用来解析js以外的东西，主要用于告诉webpack如何处理某一类型的文件，并引入到打包出来的文件中。</span></p> 
<p><span style="color:#494949;">                常用Loader:</span></p> 
<p><span style="color:#494949;">                        file-Loader:把文件输出到一个文件夹中，在代码中通过相对URL去引用输出的文件</span></p> 
<p><span style="color:#494949;">                        babel-Loader:把ES6转换为ES5，加载css，支持模块化、压缩、文件导入等特性</span></p> 
<p><span style="color:#494949;">                        style-Loader:把css代码注入到javascript中，通过DOM操作去加载css</span></p> 
<p><span style="color:#494949;">                        eslint-loader:通过eslint检查javascript代码</span></p> 
<p><span style="color:#494949;">        plugin:是一个扩展器，针对于在loader结束之后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，监听webpack打包过程中的某些节点，在合适的机会通过webpack提供的API改变输出结果。</span></p> 
<p><span style="color:#494949;">                常用plugin:</span></p> 
<p><span style="color:#494949;">                        define-plugin:定义环境变量</span></p> 
<p><span style="color:#494949;">                        commons-chunk-plugin:提取公共代码</span></p> 
<p><span style="color:#494949;">                        uglifyjs-webpack-plugin:通过UglifyES压缩ES6代码</span></p> 
<p></p> 
<h3><span style="color:#9c8ec1;"><strong>编程</strong></span></h3> 
<p><strong>防抖和节流</strong><br> 作用：都是在高频事件中防止函数被多次调用，是一种性能优化的方案</p> 
<p>区别：防抖函数只会在高频事件结束后n秒调用1次函数，节流函数在高频事件触发过程中每隔n秒调用一次函数</p> 
<pre><code> function debounce(fn,wait){
            let timer=null
            return function () {
                let _this=this
                let args=arguments
                clearTimeout(timer)
                timer=setTimeout(()=&gt;{
                    fn.apply(_this.args)
                }),wait
            }
        }
 function throttle(fn,delay){
            let timer=null
            return function () {
                let _this=this
                let args=arguments
                if(!timer){
                    timer=setTimeout(()=&gt;{
                        timer=null
                        fn.apply(_this.args)
                    },delay)
                }
            }
        }</code></pre> 
<p><strong>手写Promise</strong></p> 
<pre><code>Promise.all()是只有当所有promise对象都返回resolved，才会返回所有resolved的结果，
只要有一个返回rejected,那它就会返回rejected的结果

Promise.prototype.myAll=function(_promises){
    return new Promise((resolve,reject)=&gt;{
        const promises=[..._prmises]
        const res=[]
        const len=promises.length
        for(let i=0;i&lt;len;i++){
            Promise.resolve(promise[i]).then((o)=&gt;{
                res[i]=o
                if(++count===len){
                    return resolve(res)
                   }
                }).catch((e)=&gt;{
                    reject(e)
                    })    
               }
            })
        }
</code></pre> 
<p><strong>手写深拷贝</strong></p> 
<pre><code>function deepClone(source) {
        //   需要一个判断是否为基本数据类型的函数
        const isPrimitive=()=&gt;{
            return /Number|Strinng|Boolean|Null|Function|Undefined|Symbol/.test(Object.prototype.toString.call(source))
        } 
        // 返回数据类型
        const check=()=&gt;{
            return Object.prototype.toString.call(source)
        }
        let res=null
        // 如果为基本数据类型，直接赋值
        if (isPrimitive(source)) {
            res=source
        }else if(check(source)=='[object Date]'){
            res=new Date(source)
        }else if (check(source)=='[object RegExp]') {
            res=new RegExp(source)
        }else if(check(source)=='[object Set]'){
            res=new Set()
            for(let v of source){
                res.add(deepClone(v))
            }
        }else if(check(source)=='[object Map]'){
            res=new Map()
            for(let [key,val] of source.entries()){
                res.set(key,deepClone(val))
            }
        }else if (check(source)=='[object Array]') {
            res=[]
            for(let v of source){
                res.push(deepClone(v))
            }
        }else if (check(source)=='[object Object]') {
            res={}
            for(let i in source){
                res[i]=deepClone(source[i])
            }
        }
        return res
       }</code></pre> 
<p><strong>盒子水平垂直居中排列的方法</strong></p> 
<pre><code>(1).inner{
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
(2).outer{
    display:table-cell;
    vertical-align:middle;
    text-align:center;
}
    .inner{display:inline-block}
(3).outer{
    display:flex;
    justify-content:center;
    align-item:center;
}
(4).outer{
    display:grid;
    place-content:center;
}
(5).inner{
    position: absolute;
    top: 50%;
    left: 50%;
    margin-top:-高度的一半;
    margin-left:-宽度的一半；
}</code></pre> 
<p><br>            </p> 
<p></p> 
<p></p> 
<p>        </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a4e9afe9cea0664ab3f19e28a8d4cb7d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Unity 锚点 Anchors</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/edae5f9d9bd7d82774277147e07a2ac4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【模拟 IC】电荷泵的基础知识之正电荷泵</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>