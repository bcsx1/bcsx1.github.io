<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ARM伪指令 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ARM伪指令" />
<meta property="og:description" content="1. ARM汇编器所支持的伪指令 本文引用地址：http://www.eepw.com.cn/article/201611/318753.htm 在ARM汇编语言程序里，有一些特殊指令助记符，这些助记符与指令系统的助记符不同，没有相对应的操作码，通常称这些特殊指令助记符为伪指令，他们所完成的操作称为伪操作。 伪指令在源程序中的作用是为完成汇编程序作各种准备工作的，这些伪指令仅在汇编过程中起作用，一旦汇编结束，伪指令的使命就完成。 在ARM的汇编程序中，有如下几种伪指令：
符号定义伪指令数据定义伪指令汇编控制伪指令宏指令以及其他伪指令 1.1 符号定义（Symbol Definition）伪指令 符号定义伪指令用于定义ARM汇编程序中的变量、对变量赋值以及定义寄存器的别名等操作。常见的符号定义伪指令有如下几种： — 用于定义全局变量的GBLA、GBLL和GBLS。 — 用于定义局部变量的LCLA、LCLL和LCLS。 — 用于对变量赋值的SETA、SETL、SETS。 — 为通用寄存器列表定义名称的RLIST。 1、 GBLA、GBLL和GBLS 语法格式： GBLA（GBLL或GBLS） 全局变量名 GBLA、GBLL和GBLS伪指令用于定义一个ARM程序中的全局变量，并将其初始化。其中： GBLA伪指令用于定义一个全局的数字变量，并初始化为0； GBLL伪指令用于定义一个全局的逻辑变量，并初始化为F（假）； GBLS伪指令用于定义一个全局的字符串变量，并初始化为空； 由于以上三条伪指令用于定义全局变量，因此在整个程序范围内变量名必须唯一。 使用示例：
GBLA Test1 ；定义一个全局的数字变量，变量名为Test1 Test1 SETA 0xaa ；将该变量赋值为0xaa GBLL Test2 ；定义一个全局的逻辑变量，变量名为Test2 Test2 SETL {TRUE} ；将该变量赋值为真 GBLS Test3 ；定义一个全局的字符串变量，变量名为Test3 Test3 SETS “Testing” ；将该变量赋值为“Testing” 2、 LCLA、LCLL和LCLS 语法格式： LCLA（LCLL或LCLS） 局部变量名 LCLA、LCLL和LCLS伪指令用于定义一个ARM程序中的局部变量，并将其初始化。其中： LCLA伪指令用于定义一个局部的数字变量，并初始化为0； LCLL伪指令用于定义一个局部的逻辑变量，并初始化为F（假）； LCLS伪指令用于定义一个局部的字符串变量，并初始化为空； 以上三条伪指令用于声明局部变量，在其作用范围内变量名必须唯一。 使用示例：
LCLA Test4 ；声明一个局部的数字变量，变量名为Test4 Test3 SETA 0xaa ；将该变量赋值为0xaa LCLL Test5 ；声明一个局部的逻辑变量，变量名为Test5 Test4 SETL {TRUE} ；将该变量赋值为真 LCLS Test6 ；定义一个局部的字符串变量，变量名为Test6 Test6 SETS “Testing” ；将该变量赋值为“Testing” 3、 SETA、SETL和SETS 语法格式： 变量名 SETA（SETL或SETS） 表达式 伪指令SETA、SETL、SETS用于给一个已经定义的全局变量或局部变量赋值。 SETA伪指令用于给一个数学变量赋值； SETL伪指令用于给一个逻辑变量赋值； SETS伪指令用于给一个字符串变量赋值； 其中，变量名为已经定义过的全局变量或局部变量，表达式为将要赋给变量的值。 使用示例：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/08496b2c269d5d25fd1ff3e325d82f55/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-11-10T10:00:30+08:00" />
<meta property="article:modified_time" content="2017-11-10T10:00:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ARM伪指令</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="1-arm汇编器所支持的伪指令">1. ARM汇编器所支持的伪指令</h2> 
<p>本文引用地址：<a href="http://www.eepw.com.cn/article/201611/318753.htm" rel="nofollow">http://www.eepw.com.cn/article/201611/318753.htm</a> <br> 在ARM汇编语言程序里，有一些特殊指令助记符，这些助记符与指令系统的助记符不同，没有相对应的操作码，通常称这些特殊指令助记符为伪指令，他们所完成的操作称为伪操作。 <br> 伪指令在源程序中的作用是为完成汇编程序作各种准备工作的，这些伪指令仅在汇编过程中起作用，一旦汇编结束，伪指令的使命就完成。 <br> 在ARM的汇编程序中，有如下几种伪指令：</p> 
<ul><li>符号定义伪指令</li><li>数据定义伪指令</li><li>汇编控制伪指令</li><li>宏指令以及其他伪指令</li></ul> 
<h3 id="11-符号定义symbol-definition伪指令">1.1 符号定义（Symbol Definition）伪指令</h3> 
<p>符号定义伪指令用于定义ARM汇编程序中的变量、对变量赋值以及定义寄存器的别名等操作。常见的符号定义伪指令有如下几种： <br> — 用于定义全局变量的GBLA、GBLL和GBLS。 <br> — 用于定义局部变量的LCLA、LCLL和LCLS。 <br> — 用于对变量赋值的SETA、SETL、SETS。 <br> — 为通用寄存器列表定义名称的RLIST。 <br> 1、 GBLA、GBLL和GBLS <br> 语法格式： <br> GBLA（GBLL或GBLS） 全局变量名 <br> GBLA、GBLL和GBLS伪指令用于定义一个ARM程序中的全局变量，并将其初始化。其中： <br> GBLA伪指令用于定义一个全局的数字变量，并初始化为0； <br> GBLL伪指令用于定义一个全局的逻辑变量，并初始化为F（假）； <br> GBLS伪指令用于定义一个全局的字符串变量，并初始化为空； <br> 由于以上三条伪指令用于定义全局变量，因此在整个程序范围内变量名必须唯一。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs mathematica">GBLA Test1 ；定义一个全局的数字变量，变量名为Test1
Test1 SETA <span class="hljs-number">0xaa</span> ；将该变量赋值为<span class="hljs-number">0xaa</span>
GBLL Test2 ；定义一个全局的逻辑变量，变量名为Test2
Test2 SETL <span class="hljs-list">{TRUE}</span> ；将该变量赋值为真
GBLS Test3 ；定义一个全局的字符串变量，变量名为Test3
Test3 SETS “Testing” ；将该变量赋值为“Testing”</code></pre> 
<p>2、 LCLA、LCLL和LCLS <br> 语法格式： <br> LCLA（LCLL或LCLS） 局部变量名 <br> LCLA、LCLL和LCLS伪指令用于定义一个ARM程序中的局部变量，并将其初始化。其中： <br> LCLA伪指令用于定义一个局部的数字变量，并初始化为0； <br> LCLL伪指令用于定义一个局部的逻辑变量，并初始化为F（假）； <br> LCLS伪指令用于定义一个局部的字符串变量，并初始化为空； <br> 以上三条伪指令用于声明局部变量，在其作用范围内变量名必须唯一。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs mathematica">LCLA Test4 ；声明一个局部的数字变量，变量名为Test4
Test3 SETA <span class="hljs-number">0xaa</span> ；将该变量赋值为<span class="hljs-number">0xaa</span>
LCLL Test5 ；声明一个局部的逻辑变量，变量名为Test5
Test4 SETL <span class="hljs-list">{TRUE}</span> ；将该变量赋值为真
LCLS Test6 ；定义一个局部的字符串变量，变量名为Test6
Test6 SETS “Testing” ；将该变量赋值为“Testing”</code></pre> 
<p>3、 SETA、SETL和SETS <br> 语法格式： <br> 变量名 SETA（SETL或SETS） 表达式 <br> 伪指令SETA、SETL、SETS用于给一个已经定义的全局变量或局部变量赋值。 <br> SETA伪指令用于给一个数学变量赋值； <br> SETL伪指令用于给一个逻辑变量赋值； <br> SETS伪指令用于给一个字符串变量赋值； <br> 其中，变量名为已经定义过的全局变量或局部变量，表达式为将要赋给变量的值。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs mathematica">LCLA Test3 ；声明一个局部的数字变量，变量名为Test3
Test3 SETA <span class="hljs-number">0xaa</span> ；将该变量赋值为<span class="hljs-number">0xaa</span>
LCLL Test4 ；声明一个局部的逻辑变量，变量名为Test4
Test4 SETL <span class="hljs-list">{TRUE}</span> ；将该变量赋值为真</code></pre> 
<p>4、 RLIST <br> 语法格式： <br> 名称 RLIST {寄存器列表} <br> RLIST伪指令可用于对一个通用寄存器列表定义名称，使用该伪指令定义的名称可在ARM指令LDM/STM中使用。在LDM/STM指令中，列表中的寄存器访问次序为根据寄存器的编号由低到高，而与列表中的寄存器排列次序无关。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">RegList RLIST {<!-- --><span class="hljs-built_in">R0</span>-<span class="hljs-built_in">R5</span>，<span class="hljs-built_in">R8</span>，<span class="hljs-built_in">R10</span>} ；将寄存器列表名称定义为RegList，可在ARM指令LDM/STM中通过该名称访问寄存器列表。</code></pre> 
<h3 id="12-数据定义data-definition伪指令">1.2 数据定义（Data Definition）伪指令</h3> 
<p>数据定义伪指令一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化。常见的数据定义伪指令有如下几种： <br> — DCB 用于分配一片连续的字节存储单元并用指定的数据初始化。 <br> — DCW（DCWU） 用于分配一片连续的半字存储单元并用指定的数据初始化。 <br> — DCD（DCDU） 用于分配一片连续的字存储单元并用指定的数据初始化。 <br> — DCFD（DCFDU）用于为双精度的浮点数分配一片连续的字存储单元并用指定的数据初始化。 <br> — DCFS（DCFSU） 用于为单精度的浮点数分配一片连续的字存储单元并用指定的数据初始化。 <br> — DCQ（DCQU） 用于分配一片以8字节为单位的连续的存储单元并用指定的数据初始化。 <br> — SPACE 用于分配一片连续的存储单元 <br> — MAP 用于定义一个结构化的内存表首地址 <br> — FIELD 用于定义一个结构化的内存表的数据域 <br> 1、 DCB <br> 语法格式： <br> 标号 DCB 表达式 <br> DCB伪指令用于分配一片连续的字节存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为0～255的数字或字符串。DCB也可用“=”代替。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs cs">Str DCB “This <span class="hljs-keyword">is</span> a test！” ；分配一片连续的字节存储单元并初始化。</code></pre> 
<p>2、 DCW（或DCWU） <br> 语法格式： <br> 标号 DCW（或DCWU） 表达式 <br> DCW（或DCWU）伪指令用于分配一片连续的半字存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为程序标号或数字表达式。。 <br> 用DCW分配的字存储单元是半字对齐的，而用DCWU分配的字存储单元并不严格半字对齐。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs ">DataTest DCW 1，2，3 ；分配一片连续的半字存储单元并初始化。</code></pre> 
<p>3、 DCD（或DCDU） <br> 语法格式： <br> 标号 DCD（或DCDU） 表达式 <br> DCD（或DCDU）伪指令用于分配一片连续的字存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为程序标号或数字表达式。DCD也可用“&amp;”代替。 <br> 用DCD分配的字存储单元是字对齐的，而用DCDU分配的字存储单元并不严格字对齐。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs ">DataTest DCD 4，5，6 ；分配一片连续的字存储单元并初始化。</code></pre> 
<p>4、 DCFD（或DCFDU） <br> 语法格式： <br> 标号 DCFD（或DCFDU） 表达式 <br> DCFD（或DCFDU）伪指令用于为双精度的浮点数分配一片连续的字存储单元并用伪指令中指定的表达式初始化。每个双精度的浮点数占据两个字单元。 <br> 用DCFD分配的字存储单元是字对齐的，而用DCFDU分配的字存储单元并不严格字对齐。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs ">FDataTest DCFD 2E115，-5E7 ；分配一片连续的字存储单元并初始化为指定的双精度数。</code></pre> 
<p>5、 DCFS（或DCFSU） <br> 语法格式： <br> 标号 DCFS（或DCFSU） 表达式 <br> DCFS（或DCFSU）伪指令用于为单精度的浮点数分配一片连续的字存储单元并用伪指令中指定的表达式初始化。每个单精度的浮点数占据一个字单元。 <br> 用DCFS分配的字存储单元是字对齐的，而用DCFSU分配的字存储单元并不严格字对齐。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs mathematica">FDataTest DCFS <span class="hljs-number">2E5</span>，-<span class="hljs-number">5</span><span class="hljs-keyword">E</span>－<span class="hljs-number">7</span> ；分配一片连续的字存储单元并初始化为指定的单精度数。</code></pre> 
<p>6、 DCQ(或DCQU） <br> 语法格式： <br> 标号 DCQ（或DCQU） 表达式 <br> DCQ（或DCQU）伪指令用于分配一片以8个字节为单位的连续存储区域并用伪指令中指定的表达式初始化。 <br> 用DCQ分配的存储单元是字对齐的，而用DCQU分配的存储单元并不严格字对齐。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs ">DataTest DCQ 100 ；分配一片连续的存储单元并初始化为指定的值。</code></pre> 
<p>7、 SPACE <br> 语法格式： <br> 标号 SPACE 表达式 <br> SPACE伪指令用于分配一片连续的存储区域并初始化为0。其中，表达式为要分配的字节数。SPACE也可用“％”代替。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs livecodeserver">DataSpace <span class="hljs-constant">SPACE</span> <span class="hljs-number">100</span> ；分配连续<span class="hljs-number">100</span>字节的存储单元并初始化为<span class="hljs-number">0</span>。</code></pre> 
<p>8、 MAP <br> 语法格式： <br> MAP 表达式{，基址寄存器} <br> MAP伪指令用于定义一个结构化的内存表的首地址。MAP也可用“＾”代替。 <br> 表达式可以为程序中的标号或数学表达式，基址寄存器为可选项，当基址寄存器选项不存在时，表达式的值即为内存表的首地址，当该选项存在时，内存表的首地址为表达式的值与基址寄存器的和。 <br> MAP伪指令通常与FIELD伪指令配合使用来定义结构化的内存表。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">MAP <span class="hljs-number">0x100</span>，<span class="hljs-built_in">R0</span> ；定义结构化内存表首地址的值为<span class="hljs-number">0x100</span>＋<span class="hljs-built_in">R0</span>。</code></pre> 
<p>9、 FILED <br> 语法格式： <br> 标号 FIELD 表达式 <br> FIELD伪指令用于定义一个结构化内存表中的数据域。FILED也可用“#”代替。 <br> 表达式的值为当前数据域在内存表中所占的字节数。 <br> FIELD伪指令常与MAP伪指令配合使用来定义结构化的内存表。MAP伪指令定义内存表的首地址，FIELD伪指令定义内存表中的各个数据域，并可以为每个数据域指定一个标号供其他的指令引用。 <br> 注意MAP和FIELD伪指令仅用于定义数据结构，并不实际分配存储单元。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs autohotkey">MAP <span class="hljs-number">0</span>x100 ；定义结构化内存表首地址的值为<span class="hljs-number">0</span>x100。
<span class="hljs-literal">A</span> FIELD <span class="hljs-number">16</span> ；定义<span class="hljs-literal">A</span>的长度为<span class="hljs-number">16</span>字节，位置为<span class="hljs-number">0</span>x100
B FIELD <span class="hljs-number">32</span> ；定义B的长度为<span class="hljs-number">32</span>字节，位置为<span class="hljs-number">0</span>x110
S FIELD <span class="hljs-number">256</span> ；定义S的长度为<span class="hljs-number">256</span>字节，位置为<span class="hljs-number">0</span>x130</code></pre> 
<h3 id="13-汇编控制assembly-control伪指令">1.3 汇编控制（Assembly Control）伪指令</h3> 
<p>汇编控制伪指令用于控制汇编程序的执行流程，常用的汇编控制伪指令包括以下几条： <br> — IF、ELSE、ENDIF <br> — WHILE、WEND <br> — MACRO、MEND <br> — MEXIT <br> 1、 IF、ELSE、ENDIF <br> 语法格式：</p> 
<pre class="prettyprint"><code class=" hljs php"><span class="hljs-keyword">IF</span> 逻辑表达式
指令序列<span class="hljs-number">1</span>
<span class="hljs-keyword">ELSE</span>
指令序列<span class="hljs-number">2</span>
<span class="hljs-keyword">ENDIF</span></code></pre> 
<p>IF、ELSE、ENDIF伪指令能根据条件的成立与否决定是否执行某个指令序列。当IF后面的逻辑表达式为真，则执行指令序列1，否则执行指令序列2。其中，ELSE及指令序列2可以没有，此时，当IF后面的逻辑表达式为真，则执行指令序列1，否则继续执行后面的指令。 <br> IF、ELSE、ENDIF伪指令可以嵌套使用。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs php">GBLL Test ；声明一个全局的逻辑变量，变量名为Test
……
<span class="hljs-keyword">IF</span> Test = <span class="hljs-keyword">TRUE</span>
指令序列<span class="hljs-number">1</span>
<span class="hljs-keyword">ELSE</span>
指令序列<span class="hljs-number">2</span>
<span class="hljs-keyword">ENDIF</span></code></pre> 
<p>2、 WHILE、WEND <br> 语法格式： <br> WHILE 逻辑表达式 <br> 指令序列 <br> WEND <br> WHILE、WEND伪指令能根据条件的成立与否决定是否循环执行某个指令序列。当WHILE后面的逻辑表达式为真，则执行指令序列，该指令序列执行完毕后，再判断逻辑表达式的值，若为真则继续执行，一直到逻辑表达式的值为假。 <br> WHILE、WEND伪指令可以嵌套使用。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs vbscript">GBLA Counter ；声明一个全局的数学变量，变量名为Counter
Counter SETA <span class="hljs-number">3</span> ；由变量Counter控制循环次数
……
<span class="hljs-keyword">WHILE</span> Counter &lt; <span class="hljs-number">10</span>
指令序列
<span class="hljs-keyword">WEND</span></code></pre> 
<p>3、 MACRO、MEND <br> 语法格式： <br> $标号 宏名 $参数1，$参数2，…… <br> 指令序列 <br> MEND <br> MACRO、MEND伪指令可以将一段代码定义为一个整体，称为宏指令，然后就可以在程序中通过宏指令多次调用该段代码。其中，$标号在宏指令被展开时，标号会被替换为用户定义的符号， <br> 宏指令可以使用一个或多个参数，当宏指令被展开时，这些参数被相应的值替换。 <br> 宏指令的使用方式和功能与子程序有些相似，子程序可以提供模块化的程序设计、节省存储空间并提高运行速度。但在使用子程序结构时需要保护现场，从而增加了系统的开销，因此，在代码较短且需要传递的参数较多时，可以使用宏指令代替子程序。 <br> 包含在MACRO和MEND之间的指令序列称为宏定义体，在宏定义体的第一行应声明宏的原型（包含宏名、所需的参数），然后就可以在汇编程序中通过宏名来调用该指令序列。在源程序被编译时，汇编器将宏调用展开，用宏定义中的指令序列代替程序中的宏调用，并将实际参数的值传递给宏定义中的形式参数。 <br> MACRO、MEND伪指令可以嵌套使用。 <br> 4、 MEXIT <br> 语法格式： <br> MEXIT <br> MEXIT用于从宏定义中跳转出去。</p> 
<p>4.1.4 其他常用的伪指令 <br> 还有一些其他的伪指令，在汇编程序中经常会被使用，包括以下几条： <br> — AREA <br> — ALIGN <br> — CODE16、CODE32 <br> — ENTRY <br> — END <br> — EQU <br> — EXPORT（或GLOBAL） <br> — IMPORT <br> — EXTERN <br> — GET（或INCLUDE） <br> — INCBIN <br> — RN <br> — ROUT <br> 1、 AREA <br> 语法格式：</p> 
<pre class="prettyprint"><code class=" hljs ">AREA 段名 属性1，属性2，……</code></pre> 
<p>AREA伪指令用于定义一个代码段或数据段。其中，段名若以数字开头，则该段名需用“|”括起来，如|1_test|。 <br> 属性字段表示该代码段（或数据段）的相关属性，多个属性用逗号分隔。常用的属性如下： <br> — CODE属性：用于定义代码段，默认为READONLY。 <br> — DATA属性：用于定义数据段，默认为READWRITE。 <br> — READONLY属性：指定本段为只读，代码段默认为READONLY。 <br> — READWRITE属性：指定本段为可读可写，数据段的默认属性为READWRITE。 <br> — ALIGN属性：使用方式为ALIGN 表达式。在默认时，ELF（可执行连接文件）的代码段和数据段是按字对齐的，表达式的取值范围为0～31，相应的对齐方式为2表达式次方。 <br> — COMMON属性：该属性定义一个通用的段，不包含任何的用户代码和数据。各源文件中同名的COMMON段共享同一段存储单元。 <br> 一个汇编语言程序至少要包含一个段，当程序太长时，也可以将程序分为多个代码段和数据段。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs vbnet">AREA Init，CODE，<span class="hljs-keyword">READONLY</span>

指令序列；该伪指令定义了一个代码段，段名为Init，属性为只读</code></pre> 
<p>2、 ALIGN <br> 语法格式： <br> ALIGN {表达式{，偏移量}} <br> ALIGN伪指令可通过添加填充字节的方式，使当前位置满足一定的对其方式|。其中，表达式的值用于指定对齐方式，可能的取值为2的幂，如1、2、4、8、16等。若未指定表达式，则将当前位置对齐到下一个字的位置。偏移量也为一个数字表达式，若使用该字段，则当前位置的对齐方式为：2的表达式次幂＋偏移量。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs vbnet">AREA Init，CODE，<span class="hljs-keyword">READONLY</span>，ALIEN＝<span class="hljs-number">3</span> ；指定后面的指令为<span class="hljs-number">8</span>字节对齐
指令序列
<span class="hljs-keyword">END</span></code></pre> 
<p>3、 CODE16、CODE32 <br> 语法格式： <br> CODE16（或CODE32） <br> CODE16伪指令通知编译器，其后的指令序列为16位的Thumb指令。 <br> CODE32伪指令通知编译器，其后的指令序列为32位的ARM指令。 <br> 若在汇编源程序中同时包含ARM指令和Thumb指令时，可用CODE16伪指令通知编译器其后的指令序列为16位的Thumb指令，CODE32伪指令通知编译器其后的指令序列为32位的ARM指令。因此，在使用ARM指令和Thumb指令混合编程的代码里，可用这两条伪指令进行切换，但注意他们只通知编译器其后指令的类型，并不能对处理器进行状态的切换。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">AREA Init，CODE，READONLY
……
CODE32 ；通知编译器其后的指令为<span class="hljs-number">32</span>位的ARM指令
LDR <span class="hljs-built_in">R0</span>，＝NEXT＋<span class="hljs-number">1</span> ；将跳转地址放入寄存器<span class="hljs-built_in">R0</span>
BX <span class="hljs-built_in">R0</span> ；程序跳转到新的位置执行，并将处理器切换到Thumb工作状态
……
CODE16 ；通知编译器其后的指令为<span class="hljs-number">16</span>位的Thumb指令
NEXT LDR <span class="hljs-built_in">R3</span>，＝<span class="hljs-number">0x3FF</span>
……</code></pre> 
<p>END ；程序结束 <br> 4、 ENTRY <br> 语法格式： <br> ENTRY <br> ENTRY伪指令用于指定汇编程序的入口点。在一个完整的汇编程序中至少要有一个ENTRY（也可以有多个，当有多个ENTRY时，程序的真正入口点由链接器指定），但在一个源文件里最多只能有一个ENTRY（可以没有）。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs vbnet">AREA Init，CODE，<span class="hljs-keyword">READONLY</span>
ENTRY ；指定应用程序的入口点
……</code></pre> 
<p>5、 END <br> 语法格式： <br> END <br> END伪指令用于通知编译器已经到了源程序的结尾。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs vbnet">AREA Init，CODE，<span class="hljs-keyword">READONLY</span>
……
<span class="hljs-keyword">END</span> ；指定应用程序的结尾</code></pre> 
<p>6、 EQU <br> 语法格式： <br> 名称 EQU 表达式{，类型} <br> EQU伪指令用于为程序中的常量、标号等定义一个等效的字符名称，类似于C语言中的＃define。其中EQU可用“*”代替。 <br> 名称为EQU伪指令定义的字符名称，当表达式为32位的常量时，可以指定表达式的数据类型，可以有以下三种类型： <br> CODE16、CODE32和DATA <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs dos">Test <span class="hljs-flow">EQU</span> <span class="hljs-number">50</span> ；定义标号Test的值为<span class="hljs-number">50</span>
Addr <span class="hljs-flow">EQU</span> <span class="hljs-number">0</span>x55，CODE32 ；定义Addr的值为<span class="hljs-number">0</span>x55，且该处为<span class="hljs-number">32</span>位的ARM指令。</code></pre> 
<p>7、 EXPORT（或GLOBAL） <br> 语法格式： <br> EXPORT 标号{[WEAK]} <br> EXPORT伪指令用于在程序中声明一个全局的标号，该标号可在其他的文件中引用。EXPORT可用GLOBAL代替。标号在程序中区分大小写，[WEAK]选项声明其他的同名标号优先于该标号被引用。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs vbnet">AREA Init，CODE，<span class="hljs-keyword">READONLY</span>
EXPORT Stest ；声明一个可全局引用的标号Stest
……
<span class="hljs-keyword">END</span></code></pre> 
<p>8、 IMPORT <br> 语法格式： <br> IMPORT 标号{[WEAK]} <br> IMPORT伪指令用于通知编译器要使用的标号在其他的源文件中定义，但要在当前源文件中引用，而且无论当前源文件是否引用该标号，该标号均会被加入到当前源文件的符号表中。 <br> 标号在程序中区分大小写，[WEAK]选项表示当所有的源文件都没有定义这样一个标号时，编译器也不给出错误信息，在多数情况下将该标号置为0，若该标号为B或BL指令引用，则将B或BL指令置为NOP操作。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs vbnet">AREA Init，CODE，<span class="hljs-keyword">READONLY</span>
IMPORT Main ；通知编译器当前文件要引用标号Main，但Main在其他源文件中定义
……
<span class="hljs-keyword">END</span></code></pre> 
<p>9、 EXTERN <br> 语法格式： <br> EXTERN 标号{[WEAK]} <br> EXTERN伪指令用于通知编译器要使用的标号在其他的源文件中定义，但要在当前源文件中引用，如果当前源文件实际并未引用该标号，该标号就不会被加入到当前源文件的符号表中。 <br> 标号在程序中区分大小写，[WEAK]选项表示当所有的源文件都没有定义这样一个标号时，编译器也不给出错误信息，在多数情况下将该标号置为0，若该标号为B或BL指令引用，则将B或BL指令置为NOP操作。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs vbnet">AREA Init，CODE，<span class="hljs-keyword">READONLY</span>
EXTERN Main ；通知编译器当前文件要引用标号Main，但Main在其他源文件中定义
……
<span class="hljs-keyword">END</span></code></pre> 
<p>10、 GET（或INCLUDE） <br> 语法格式： <br> GET 文件名 <br> GET伪指令用于将一个源文件包含到当前的源文件中，并将被包含的源文件在当前位置进行汇编处理。可以使用INCLUDE代替GET。 <br> 汇编程序中常用的方法是在某源文件中定义一些宏指令，用EQU定义常量的符号名称，用MAP和FIELD定义结构化的数据类型，然后用GET伪指令将这个源文件包含到其他的源文件中。使用方法与C语言中的“include”相似。 <br> GET伪指令只能用于包含源文件，包含目标文件需要使用INCBIN伪指令 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">AREA Init，CODE，READONLY
GET a1<span class="hljs-preprocessor">.s</span> ；通知编译器当前源文件包含源文件a1<span class="hljs-preprocessor">.s</span>
GE T C：a2<span class="hljs-preprocessor">.s</span> ；通知编译器当前源文件包含源文件C： a2<span class="hljs-preprocessor">.s</span>
……
END</code></pre> 
<p>11、 INCBIN <br> 语法格式： <br> INCBIN 文件名 <br> INCBIN伪指令用于将一个目标文件或数据文件包含到当前的源文件中，被包含的文件不作任何变动的存放在当前文件中，编译器从其后开始继续处理。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">AREA Init，CODE，READONLY
INCBIN a1<span class="hljs-preprocessor">.dat</span> ；通知编译器当前源文件包含文件a1<span class="hljs-preprocessor">.dat</span>
INCBIN C：a2<span class="hljs-preprocessor">.txt</span> ；通知编译器当前源文件包含文件C：a2<span class="hljs-preprocessor">.txt</span>
……
END</code></pre> 
<p>12、 RN <br> 语法格式： <br> 名称 RN 表达式 <br> RN伪指令用于给一个寄存器定义一个别名。采用这种方式可以方便程序员记忆该寄存器的功能。其中，名称为给寄存器定义的别名，表达式为寄存器的编码。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">Temp RN <span class="hljs-built_in">R0</span> ；将<span class="hljs-built_in">R0</span>定义一个别名Temp</code></pre> 
<p>13、 ROUT <br> 语法格式： <br> {名称} ROUT <br> ROUT伪指令用于给一个局部变量定义作用范围。在程序中未使用该伪指令时，局部变量的作用范围为所在的AREA，而使用ROUT后，局部变量的作为范围为当前ROUT和下一个ROUT之间。</p> 
<h2 id="2-汇编语言的语句格式">2 汇编语言的语句格式</h2> 
<p>ARM（Thumb）汇编语言的语句格式为： <br> {标号} {指令或伪指令} {；注释} <br> 在汇编语言程序设计中，每一条指令的助记符可以全部用大写、或全部用小写，但不用许在一条指令中大、小写混用。 <br> 同时，如果一条语句太长，可将该长语句分为若干行来书写，在行的末尾用“”表示下一行与本行为同一条语句。</p> 
<h3 id="21-在汇编语言程序中常用的符号">2.1 在汇编语言程序中常用的符号</h3> 
<p>在汇编语言程序设计中，经常使用各种符号代替地址、变量和常量等，以增加程序的可读性。尽管符号的命名由编程者决定，但并不是任意的，必须遵循以下的约定： <br> — 符号区分大小写，同名的大、小写符号会被编译器认为是两个不同的符号。 <br> — 符号在其作用范围内必须唯一。 <br> — 自定义的符号名不能与系统的保留字相同。 <br> — 符号名不应与指令或伪指令同名。 <br> 1、 程序中的变量 <br> 程序中的变量是指其值在程序的运行过程中可以改变的量。ARM（Thumb）汇编程序所支持的变量有数字变量、逻辑变量和字符串变量。 <br> 数字变量用于在程序的运行中保存数字值，但注意数字值的大小不应超出数字变量所能表示的范围。 <br> 逻辑变量用于在程序的运行中保存逻辑值，逻辑值只有两种取值情况：真或假。 <br> 字符串变量用于在程序的运行中保存一个字符串，但注意字符串的长度不应超出字符串变量所能表示的范围。 <br> 在ARM（Thumb）汇编语言程序设计中，可使用GBLA、GBLL、GBLS伪指令声明全局变量，使用LCLA、LCLL、LCLS伪指令声明局部变量，并可使用SETA、SETL和SETS对其进行初始化。 <br> 2、 程序中的常量 <br> 程序中的常量是指其值在程序的运行过程中不能被改变的量。ARM（Thumb）汇编程序所支持的常量有数字常量、逻辑常量和字符串常量。 <br> 数字常量一般为32位的整数，当作为无符号数时，其取值范围为0～232-1，当作为有符号数时，其取值范围为-231～231-1。 <br> 逻辑常量只有两种取值情况：真或假。 <br> 字符串常量为一个固定的字符串，一般用于程序运行时的信息提示。 <br> 3、 程序中的变量代换 <br> 程序中的变量可通过代换操作取得一个常量。代换操作符为“$”。 <br> 如果在数字变量前面有一个代换操作符“$”，编译器会将该数字变量的值转换为十六进制的字符串，并将该十六进制的字符串代换“$”后的数字变量。 <br> 如果在逻辑变量前面有一个代换操作符“$”，编译器会将该逻辑变量代换为它的取值（真或假）。 <br> 如果在字符串变量前面有一个代换操作符“$”，编译器会将该字符串变量的值代换“$”后的字符串变量。 <br> 使用示例：</p> 
<pre class="prettyprint"><code class=" hljs cs">LCLS S1 ；定义局部字符串变量S1和S2
LCLS S2
S1 SETS “Test！”
S2 SETS “This <span class="hljs-keyword">is</span> a $S1” ；字符串变量S2的值为“This <span class="hljs-keyword">is</span> a Test！”</code></pre> 
<h3 id="22-汇编语言程序中的表达式和运算符">2.2 汇编语言程序中的表达式和运算符</h3> 
<p>在汇编语言程序设计中，也经常使用各种表达式，表达式一般由变量、常量、运算符和括号构成。常用的表达式有数字表达式、逻辑表达式和字符串表达式，其运算次序遵循如下的优先级： <br> — 优先级相同的双目运算符的运算顺序为从左到右。 <br> — 相邻的单目运算符的运算顺序为从右到左，且单目运算符的优先级高于其他运算符。 <br> — 括号运算符的优先级最高。 <br> 1、 数字表达式及运算符 <br> 数字表达式一般由数字常量、数字变量、数字运算符和括号构成。与数字表达式相关的运算符如下： <br> — “＋”、“－”、“×”、“/” 及“MOD”算术运算符 <br> 以上的算术运算符分别代表加、减、乘、除和取余数运算。例如，以X和Y表示两个数字表达式，则：</p> 
<pre class="prettyprint"><code class=" hljs vbnet">X＋Y 表示X与Y的和。
X－Y 表示X与Y的差。
X×Y 表示X与Y的乘积。
X/Y 表示X除以Y的商。
X：<span class="hljs-keyword">MOD</span>：Y 表示X除以Y的余数。</code></pre> 
<p>— “ROL”、“ROR”、“SHL”及“SHR”移位运算符 <br> 以X和Y表示两个数字表达式，以上的移位运算符代表的运算如下：</p> 
<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-built_in">X</span>：<span class="hljs-keyword">ROL</span>：<span class="hljs-built_in">Y</span> 表示将<span class="hljs-built_in">X</span>循环左移<span class="hljs-built_in">Y</span>位。
<span class="hljs-built_in">X</span>：<span class="hljs-keyword">ROR</span>：<span class="hljs-built_in">Y</span> 表示将<span class="hljs-built_in">X</span>循环右移<span class="hljs-built_in">Y</span>位。
<span class="hljs-built_in">X</span>：SHL：<span class="hljs-built_in">Y</span> 表示将<span class="hljs-built_in">X</span>左移<span class="hljs-built_in">Y</span>位。
<span class="hljs-built_in">X</span>：SHR：<span class="hljs-built_in">Y</span> 表示将<span class="hljs-built_in">X</span>右移<span class="hljs-built_in">Y</span>位。</code></pre> 
<p>— “AND”、“OR”、“NOT”及“EOR”按位逻辑运算符 <br> 以X和Y表示两个数字表达式，以上的按位逻辑运算符代表的运算如下：</p> 
<pre class="prettyprint"><code class=" hljs vbnet">X：<span class="hljs-keyword">AND</span>：Y 表示将X和Y按位作逻辑与的操作。
X：<span class="hljs-keyword">OR</span>：Y 表示将X和Y按位作逻辑或的操作。
：<span class="hljs-keyword">NOT</span>：Y 表示将Y按位作逻辑非的操作。
X：EOR：Y 表示将X和Y按位作逻辑异或的操作。</code></pre> 
<p>2、 逻辑表达式及运算符 <br> 逻辑表达式一般由逻辑量、逻辑运算符和括号构成，其表达式的运算结果为真或假。与逻辑表达式相关的运算符如下： <br> — “=”、“&gt;”、“&lt;”、“&gt;=”、“&lt;= ”、“/=”、“ &lt;&gt;” 运算符 <br> 以X和Y表示两个逻辑表达式，以上的运算符代表的运算如下：</p> 
<pre class="prettyprint"><code class=" hljs makefile"><span class="hljs-constant">X</span> = Y 表示X等于Y。
X &gt; Y 表示X大于Y。
X &lt; Y 表示X小于Y。
<span class="hljs-constant">X</span> &gt;= Y 表示X大于等于Y。
<span class="hljs-constant">X</span> &lt;= Y 表示X小于等于Y。
<span class="hljs-constant">X</span> /= Y 表示X不等于Y。
X &lt;&gt; Y 表示X不等于Y。</code></pre> 
<p>— “LAND”、“LOR”、“LNOT”及“LEOR”运算符 <br> 以X和Y表示两个逻辑表达式，以上的逻辑运算符代表的运算如下：</p> 
<pre class="prettyprint"><code class=" hljs ">X：LAND：Y 表示将X和Y 作逻辑与的操作。
X：LOR：Y 表示将X和Y作逻辑或的操作。
：LNOT：Y 表示将Y作逻辑非的操作。
X：LEOR：Y 表示将X和Y作逻辑异或的操作。</code></pre> 
<p>3、 字符串表达式及运算符 <br> 字符串表达式一般由字符串常量、字符串变量、运算符和括号构成。编译器所支持的字符串最大长度为512字节。常用的与字符串表达式相关的运算符如下： <br> — LEN运算符 <br> LEN运算符返回字符串的长度（字符数），以X表示字符串表达式，其语法格式如下：</p> 
<pre class="prettyprint"><code class=" hljs ruleslanguage">：<span class="hljs-keyword">LEN</span>：X</code></pre> 
<p>— CHR运算符 <br> CHR运算符将0～255之间的整数转换为一个字符，以M表示某一个整数，其语法格式如下：</p> 
<pre class="prettyprint"><code class=" hljs vbscript">：<span class="hljs-built_in">CHR</span>：M</code></pre> 
<p>— STR运算符 <br> STR运算符将将一个数字表达式或逻辑表达式转换为一个字符串。对于数字表达式，STR运算符将其转换为一个以十六进制组成的字符串；对于逻辑表达式，STR运算符将其转换为字符串T或F，其语法格式如下：</p> 
<pre class="prettyprint"><code class=" hljs ">：STR：X</code></pre> 
<p>其中，X为一个数字表达式或逻辑表达式。 <br> — LEFT运算符 <br> LEFT运算符返回某个字符串左端的一个子串，其语法格式如下：</p> 
<pre class="prettyprint"><code class=" hljs ruleslanguage">X：<span class="hljs-keyword">LEFT</span>：Y</code></pre> 
<p>其中：X为源字符串，Y为一个整数，表示要返回的字符个数。 <br> — RIGHT运算符 <br> 与LEFT运算符相对应，RIGHT运算符返回某个字符串右端的一个子串，其语法格式如下：</p> 
<pre class="prettyprint"><code class=" hljs ruleslanguage">X：<span class="hljs-keyword">RIGHT</span>：Y</code></pre> 
<p>其中：X为源字符串，Y为一个整数，表示要返回的字符个数。 <br> — CC运算符 <br> CC运算符用于将两个字符串连接成一个字符串，其语法格式如下：</p> 
<pre class="prettyprint"><code class=" hljs ">X：CC：Y</code></pre> 
<p>其中：X为源字符串1，Y为源字符串2，CC运算符将Y连接到X的后面。 <br> 4、 与寄存器和程序计数器（PC）相关的表达式及运算符 <br> 常用的与寄存器和程序计数器（PC）相关的表达式及运算符如下： <br> — BASE运算符 <br> BASE运算符返回基于寄存器的表达式中寄存器的编号，其语法格式如下：</p> 
<pre class="prettyprint"><code class=" hljs ">：BASE：X</code></pre> 
<p>其中，X为与寄存器相关的表达式。 <br> — INDEX运算符 <br> INDEX运算符返回基于寄存器的表达式中相对于其基址寄存器的偏移量，其语法格式如下：</p> 
<pre class="prettyprint"><code class=" hljs delphi">：<span class="hljs-keyword">INDEX</span>：X</code></pre> 
<p>其中，X为与寄存器相关的表达式。 <br> 5、 其他常用运算符 <br> — ？运算符 <br> ？运算符返回某代码行所生成的可执行代码的长度，例如：</p> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-string">?X</span></code></pre> 
<p>返回定义符号X的代码行所生成的可执行代码的字节数。 <br> — DEF运算符 <br> DEF运算符判断是否定义某个符号，例如：</p> 
<pre class="prettyprint"><code class=" hljs ">：DEF：X</code></pre> 
<p>如果符号X已经定义，则结果为真，否则为假。</p> 
<h2 id="3-汇编语言的程序结构">3 汇编语言的程序结构</h2> 
<h3 id="31-汇编语言的程序结构">3.1 汇编语言的程序结构</h3> 
<p>在ARM（Thumb）汇编语言程序中，以程序段为单位组织代码。段是相对独立的指令或数据序列，具有特定的名称。段可以分为代码段和数据段，代码段的内容为执行代码，数据段存放代码运行时需要用到的数据。一个汇编程序至少应该有一个代码段，当程序较长时，可以分割为多个代码段和数据段，多个段在程序编译链接时最终形成一个可执行的映象文件。 <br> 可执行映象文件通常由以下几部分构成： <br> — 一个或多个代码段，代码段的属性为只读。 <br> — 零个或多个包含初始化数据的数据段，数据段的属性为可读写。 <br> — 零个或多个不包含初始化数据的数据段，数据段的属性为可读写。 <br> 链接器根据系统默认或用户设定的规则，将各个段安排在存储器中的相应位置。因此源程序中段之间的相对位置与可执行的映象文件中段的相对位置一般不会相同。 <br> 以下是一个汇编语言源程序的基本结构：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">AREA Init，CODE，READONLY
ENTRY
Start
LDR <span class="hljs-built_in">R0</span>，=<span class="hljs-number">0x3FF5000</span>
LDR <span class="hljs-built_in">R1</span>，<span class="hljs-number">0xFF</span>
STR <span class="hljs-built_in">R1</span>，[<span class="hljs-built_in">R0</span>]
LDR <span class="hljs-built_in">R0</span>，=<span class="hljs-number">0x3FF5008</span>
LDR <span class="hljs-built_in">R1</span>，<span class="hljs-number">0x01</span>
STR <span class="hljs-built_in">R1</span>，[<span class="hljs-built_in">R0</span>]
......
END</code></pre> 
<p>在汇编语言程序中，用AREA伪指令定义一个段，并说明所定义段的相关属性，本例定义一个名为Init的代码段，属性为只读。ENTRY伪指令标识程序的入口点，接下来为指令序列，程序的末尾为END伪指令，该伪指令告诉编译器源文件的结束，每一个汇编程序段都必须有一条END伪指令，指示代码段的结束。</p> 
<h3 id="32-汇编语言的子程序调用">3.2 汇编语言的子程序调用</h3> 
<p>在ARM汇编语言程序中，子程序的调用一般是通过BL指令来实现的。在程序中，使用指令：BL 子程序名 <br> 即可完成子程序的调用。 <br> 该指令在执行时完成如下操作：将子程序的返回地址存放在连接寄存器LR中，同时将程序计数器PC指向子程序的入口点，当子程序执行完毕需要返回调用处时，只需要将存放在LR中的返回地址重新拷贝给程序计数器PC即可。在调用子程序的同时，也可以完成参数的传递和从子程序返回运算的结果，通常可以使用寄存器R0～R3完成。 <br> 以下是使用BL指令调用子程序的汇编语言源程序的基本结构：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">AREA Init，CODE，READONLY
ENTRY
Start
LDR <span class="hljs-built_in">R0</span>，=<span class="hljs-number">0x3FF5000</span>
LDR <span class="hljs-built_in">R1</span>，<span class="hljs-number">0xFF</span>
STR <span class="hljs-built_in">R1</span>，[<span class="hljs-built_in">R0</span>]
LDR <span class="hljs-built_in">R0</span>，=<span class="hljs-number">0x3FF5008</span>
LDR <span class="hljs-built_in">R1</span>，<span class="hljs-number">0x01</span>
STR <span class="hljs-built_in">R1</span>，[<span class="hljs-built_in">R0</span>]
BL PRINT_TEXT
┉┉
PRINT_TEXT
┉┉
<span class="hljs-keyword">MOV</span> PC，BL
┉┉
END</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f54614582208c18a04bc6928f5d2ab5f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python3:urllib中urlopen()函数新特点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9732e6bd8b5bd540b04c8fe29f855721/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于timeStamp的两个属性</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>