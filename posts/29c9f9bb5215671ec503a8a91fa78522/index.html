<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>机器学习-SVM - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="机器学习-SVM" />
<meta property="og:description" content="\[此篇文章介绍关于SVM中的一些不懂的地方的公式推导，以及代码实现和一些SVM问题，通过做题检验掌握的效果。\]
一、代码实现 \[调用sklearn包，进行SVM分类\]
#!/usr/bin/python # -*- coding utf-8 -*- import numpy as np import matplotlib.pyplot as plt import pandas as pd import matplotlib as mpl from sklearn import svm from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score def load_data(): path = &#39;E:\数据挖掘\Machine learning\[小象学院]机器学习课件\8.Regression代码\8.Regression\iris.data&#39; # 读取文件路径 data = pd.read_csv(path, header = None) # 从data 读取数据, x为前4列的所有数据, y为第5列数据 x, y = data[range(4)], data[4] # 返回字符类别的位置索引, 因y数组包含三类, 对应返回下标值 y = pd.Categorical(y).codes # 取x的前两列数据, 一般SVM只做二特征分类, 多特征的转化为多个二特征分类再bagging?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/29c9f9bb5215671ec503a8a91fa78522/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-26T13:13:00+08:00" />
<meta property="article:modified_time" content="2019-08-26T13:13:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">机器学习-SVM</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"> 
 <p><span class="math display">\[此篇文章介绍关于SVM中的一些不懂的地方的公式推导，以及代码实现和一些SVM问题，通过做题检验掌握的效果。\]</span></p> 
 <h2 id="一代码实现">一、代码实现</h2> 
 <p><span class="math display">\[调用sklearn包，进行SVM分类\]</span></p> 
 <pre><code>#!/usr/bin/python
# -*- coding utf-8 -*-


import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import matplotlib as mpl
from sklearn import svm
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score


def load_data():
    path = 'E:\数据挖掘\Machine learning\[小象学院]机器学习课件\8.Regression代码\8.Regression\iris.data'  
    # 读取文件路径
    data = pd.read_csv(path, header = None)
    # 从data 读取数据, x为前4列的所有数据, y为第5列数据
    x, y = data[range(4)], data[4]
    # 返回字符类别的位置索引, 因y数组包含三类, 对应返回下标值
    y = pd.Categorical(y).codes
    # 取x的前两列数据, 一般SVM只做二特征分类, 多特征的转化为多个二特征分类再bagging?
    x = x[[0, 1]]
    # x = x[[0 ,2]]
    return x, y



def classifier(x,y):
    # 鸢尾花包含四个特征属性, 包含三类标签, 山鸢尾(0), 变色鸢尾(1), 维吉尼亚鸢尾(2)
    iris_feature = u'花萼长度', u'花萼宽度', u'花瓣长度', u'花瓣宽度'
    # 按 0.6 的比例，test_data 占40%， train_data 占60%, random_state随机数的种子, 1为产生相同随机数, 产生不同随机数
    x_train, x_test, y_train, y_test = train_test_split(x, y, random_state=1, train_size=0.6)
    # 使用SVM进行分类训练, 包含关键字, C, gamma, kernel
    # kernel='linear'时，为线性核，C越大分类效果越好, kernel= 'rbf' 时（default）, 为高斯核
    # gamma值越小，分类界面越连续；gamma值越大，分类界面越“散”，分类效果越好
    # decision_function_shape = 'ovr' 时，为one vs rest, 即一个类别与其他类别进行划分，decision_function_shape = 'ovo'
    # 为one vs one,即将类别两两之间进行划分，用二分类的方法模拟多分类的结果
    clf = svm.SVC(C=0.8, kernel='rbf', gamma=20, decision_function_shape='ovr')
    clf.fit(x_train, y_train.ravel())
    # score函数返回返回该次预测的系数R2, 在（0, 1)之间、accuracy_score指的是分类准确率，即分类正确占所有分类的百分比
    # recall_score 召回率 = 提取出的正确信息条数 / 样本中的信息条数
    print(clf.score(x_train, y_train))
    print('训练集准确率：', accuracy_score(y_train, clf.predict(x_train)))
    print(clf.score(x_test, y_test))
    print('测试集准确率：', accuracy_score(y_test, clf.predict(x_test)))

    # decision_function()的功能: 计算样本点到分割超平面的函数距离, 每一列的值代表距离各类别的距离
    print('decision_function:\n', clf.decision_function(x_train))
    print('\npredict:\n', clf.predict(x_train))

    # 画图
    x1_min, x2_min = x.min()  # 第0列的范围
    x1_max, x2_max = x.max()  # 第1列的范围
    x1, x2 = np.mgrid[x1_min:x1_max:500j, x2_min:x2_max:500j]  # 生成网格采样点
    grid_test = np.stack((x1.flat, x2.flat), axis=1)  # 测试点
    # print 'grid_test = \n', grid_test
    # Z = clf.decision_function(grid_test)    # 样本到决策面的距离
    # print Z
    grid_hat = clf.predict(grid_test)  # 预测分类值
    grid_hat = grid_hat.reshape(x1.shape)  # 使之与输入的形状相同
    mpl.rcParams['font.sans-serif'] = [u'SimHei']
    mpl.rcParams['axes.unicode_minus'] = False

    cm_light = mpl.colors.ListedColormap(['#A0FFA0', '#FFA0A0', '#A0A0FF'])
    cm_dark = mpl.colors.ListedColormap(['g', 'r', 'b'])
    plt.figure(facecolor='w')
    plt.pcolormesh(x1, x2, grid_hat, cmap=cm_light)
    plt.scatter(x[0], x[1], c=y, edgecolors='k', s=50, cmap=cm_dark)  # 样本
    plt.scatter(x_test[0], x_test[1], s=120, facecolors='none', zorder=10)  # 圈中测试集样本
    plt.xlabel(iris_feature[0], fontsize=13)
    plt.ylabel(iris_feature[1], fontsize=13)
    plt.xlim(x1_min, x1_max)
    plt.ylim(x2_min, x2_max)
    plt.title(u'鸢尾花SVM二特征分类', fontsize=16)
    plt.grid(b=True, ls=':')
    plt.tight_layout(pad=1.5)
    plt.show()


if __name__ == "__main__":
    x, y = load_data()
    classifier(x, y)</code></pre> 
 <p><span class="math display">\[SMO算法\]</span></p> 
 <pre><code># -*- coding: utf-8 -*-
import numpy as np
import matplotlib.pyplot as plt


def loadDataSet(fileName):
    # 数据矩阵
    dataMat = []
    # 标签向量
    labelMat = []
    # 打开文件
    fr = open(fileName)
    # 逐行读取
    for line in fr.readlines():
        # 去掉每一行首尾的空白符，例如'\n','\r','\t',' '
        # 将每一行内容根据'\t'符进行切片
        lineArr = line.strip().split('\t')
        # 添加数据(100个元素排成一行)
        dataMat.append([float(lineArr[0]), float(lineArr[1])])
        # 添加标签(100个元素排成一行)
        labelMat.append(float(lineArr[2]))
    return dataMat, labelMat

def selectJrand(i, m):
    # i为第一个alpha的下标，m是所有alpha的数目
    j = i
    while (j == i):
        # uniform()方法将随机生成一个实数，它在[x, y)范围内
        j = int(np.random.uniform(0, m))
    return j


def clipAlpha(aj, H, L):
    if aj &gt; H:
        aj = H
    if L &gt; aj:
        aj = L
    return aj

def smoSimple(dataMatIn, classLabels, C, toler, maxIter):
    # 转换为numpy的mat矩阵存储(100,2)
    dataMatrix = np.mat(dataMatIn)
    # 转换为numpy的mat矩阵存储并转置(100,1)
    labelMat = np.mat(classLabels).transpose()
    # 初始化b参数，统计dataMatrix的维度,m:行；n:列
    b = 0
    # 统计dataMatrix的维度,m:100行；n:2列
    m, n = np.shape(dataMatrix)
    # 初始化alpha参数，设为0
    alphas = np.mat(np.zeros((m, 1)))
    # 初始化迭代次数
    iter_num = 0
    # 最多迭代maxIter次
    while (iter_num &lt; maxIter):
        alphaPairsChanged = 0
        for i in range(m):
            # 步骤1：计算误差Ei
            # multiply(a,b)就是个乘法，如果a,b是两个数组，那么对应元素相乘
            # .T为转置
            fxi = float(np.multiply(alphas, labelMat).T * (dataMatrix * dataMatrix[i, :].T)) + b
            # 误差项计算公式
            Ei = fxi - float(labelMat[i])
            # 优化alpha，设定一定的容错率
            if ((labelMat[i] * Ei &lt; -toler) and (alphas[i] &lt; C)) or ((labelMat[i] * Ei &gt; toler) and (alphas[i] &gt; 0)):
                # 随机选择另一个alpha_i成对比优化的alpha_j
                j = selectJrand(i, m)
                # 步骤1，计算误差Ej
                fxj = float(np.multiply(alphas, labelMat).T * (dataMatrix * dataMatrix[j, :].T)) + b
                # 误差项计算公式
                Ej = fxj - float(labelMat[j])
                # 保存更新前的alpha值，使用深拷贝(完全拷贝)A深层拷贝为B，A和B是两个独立的个体
                alphaIold = alphas[i].copy()
                alphaJold = alphas[j].copy()
                # 步骤2：计算上下界H和L
                if (labelMat[i] != labelMat[j]):
                    L = max(0, alphas[j] - alphas[i])
                    H = min(C, C + alphas[j] - alphas[i])
                else:
                    L = max(0, alphas[j] + alphas[i] - C)
                    H = min(C, alphas[j] + alphas[i])
                if (L == H):
                    print("L == H")
                    continue
                # 步骤3：计算eta
                eta = 2.0 * dataMatrix[i, :] * dataMatrix[j, :].T - dataMatrix[i, :] * dataMatrix[i, :].T - dataMatrix[
                                                                                                            j,
                                                                                                            :] * dataMatrix[
                                                                                                                 j, :].T
                if eta &gt;= 0:
                    print("eta&gt;=0")
                    continue
                # 步骤4：更新alpha_j
                alphas[j] -= labelMat[j] * (Ei - Ej) / eta
                # 步骤5：修剪alpha_j
                alphas[j] = clipAlpha(alphas[j], H, L)
                if (abs(alphas[j] - alphaJold) &lt; 0.00001):
                    print("alpha_j变化太小")
                    continue
                # 步骤6：更新alpha_i
                alphas[i] += labelMat[j] * labelMat[i] * (alphaJold - alphas[j])
                # 步骤7：更新b_1和b_2
                b1 = b - Ei - labelMat[i] * (alphas[i] - alphaIold) * dataMatrix[i, :] * dataMatrix[i, :].T - labelMat[
                    j] * (alphas[j] - alphaJold) * dataMatrix[j, :] * dataMatrix[i, :].T
                b2 = b - Ej - labelMat[i] * (alphas[i] - alphaIold) * dataMatrix[i, :] * dataMatrix[j, :].T - labelMat[
                    j] * (alphas[j] - alphaJold) * dataMatrix[j, :] * dataMatrix[j, :].T
                # 步骤8：根据b_1和b_2更新b
                if (0 &lt; alphas[i] &lt; C):
                    b = b1
                elif (0 &lt; alphas[j] &lt; C):
                    b = b2
                else:
                    b = (b1 + b2) / 2.0
                # 统计优化次数
                alphaPairsChanged += 1
                # 打印统计信息
                print("第%d次迭代 样本：%d， alpha优化次数：%d" % (iter_num, i, alphaPairsChanged))
        # 更新迭代次数
        if (alphaPairsChanged == 0):
            iter_num += 1
        else:
            iter_num = 0
        print("迭代次数：%d" % iter_num)
    return b, alphas


def get_w(dataMat, labelMat, alphas):
    alphas, dataMat, labelMat = np.array(alphas), np.array(dataMat), np.array(labelMat)
    # 我们不知道labelMat的shape属性是多少，
    # 但是想让labelMat变成只有一列，行数不知道多少，
    # 通过labelMat.reshape(1, -1)，Numpy自动计算出有100行，
    # 新的数组shape属性为(100, 1)
    # np.tile(labelMat.reshape(1, -1).T, (1, 2))将labelMat扩展为两列(将第1列复制得到第2列)
    # dot()函数是矩阵乘，而*则表示逐个元素相乘
    # w = sum(alpha_i * yi * xi)
    w = np.dot((np.tile(labelMat.reshape(1, -1).T, (1, 2)) * dataMat).T, alphas)
    return w.tolist()


def showClassifer(dataMat, w, b):
    # 正样本
    data_plus = []
    # 负样本
    data_minus = []
    for i in range(len(dataMat)):
        if labelMat[i] &gt; 0:
            data_plus.append(dataMat[i])
        else:
            data_minus.append(dataMat[i])
    # 转换为numpy矩阵
    data_plus_np = np.array(data_plus)
    # 转换为numpy矩阵
    data_minus_np = np.array(data_minus)
    # 正样本散点图（scatter）
    # transpose转置
    plt.scatter(np.transpose(data_plus_np)[0], np.transpose(data_plus_np)[1], s=30, alpha=0.7)
    # 负样本散点图（scatter）
    plt.scatter(np.transpose(data_minus_np)[0], np.transpose(data_minus_np)[1], s=30, alpha=0.7)
    # 绘制直线
    x1 = max(dataMat)[0]
    x2 = min(dataMat)[0]
    a1, a2 = w
    b = float(b)
    a1 = float(a1[0])
    a2 = float(a2[0])
    y1, y2 = (-b - a1 * x1) / a2, (-b - a1 * x2) / a2
    plt.plot([x1, x2], [y1, y2])
    # 找出支持向量点
    # enumerate在字典上是枚举、列举的意思
    for i, alpha in enumerate(alphas):
        # 支持向量机的点
        if (abs(alpha) &gt; 0):
            x, y = dataMat[i]
            plt.scatter([x], [y], s=150, c='none', alpha=0.7, linewidth=1.5, edgecolors='red')
    plt.show()


if __name__ == '__main__':
    dataMat, labelMat = loadDataSet('E:\\数据挖掘\\Machine learning\\代码\\SVM_Project1\\testSet.txt')
    b, alphas = smoSimple(dataMat, labelMat, 0.6, 0.001, 40)
    w = get_w(dataMat, labelMat, alphas)
    showClassifer(dataMat, w, b)
</code></pre> 
 <p><span class="math display">\[核函数测试\]</span></p> 
 <pre><code># -*- coding: utf-8 -*-

import matplotlib.pyplot as plt
import numpy as np
import random

class optStruct:
    def __init__(self, dataMatIn, classLabels, C, toler, kTup):
        # 数据矩阵
        self.X = dataMatIn
        # 数据标签
        self.labelMat = classLabels
        # 松弛变量
        self.C = C
        # 容错率
        self.tol = toler
        # 矩阵的行数
        self.m = np.shape(dataMatIn)[0]
        # 根据矩阵行数初始化alphas矩阵，一个m行1列的全零列向量
        self.alphas = np.mat(np.zeros((self.m, 1)))
        # 初始化b参数为0
        self.b = 0
        # 根据矩阵行数初始化误差缓存矩阵，第一列为是否有效标志位，第二列为实际的误差E的值
        self.eCache = np.mat(np.zeros((self.m, 2)))
        # 初始化核K
        self.K = np.mat(np.zeros((self.m, self.m)))
        # 计算所有数据的核K
        for i in range(self.m):
            self.K[:, i] = kernelTrans(self.X, self.X[i, :], kTup)

def kernelTrans(X, A, kTup):
    # 读取X的行列数
    m, n = np.shape(X)
    # K初始化为m行1列的零向量
    K = np.mat(np.zeros((m, 1)))
    # 线性核函数只进行内积
    if kTup[0] == 'lin':
        K = X * A.T
    # 高斯核函数，根据高斯核函数公式计算
    elif kTup[0] == 'rbf':
        for j in range(m):
            deltaRow = X[j, :] - A
            K[j] = deltaRow * deltaRow.T
        K = np.exp(K / (-1 * kTup[1] ** 2))
    else:
        raise NameError('核函数无法识别')
    return K


def loadDataSet(fileName):
    # 数据矩阵
    dataMat = []
    # 标签向量
    labelMat = []
    # 打开文件
    fr = open(fileName)
    # 逐行读取
    for line in fr.readlines():
        # 去掉每一行首尾的空白符，例如'\n','\r','\t',' '
        # 将每一行内容根据'\t'符进行切片
        lineArr = line.strip().split('\t')
        # 添加数据(100个元素排成一行)
        dataMat.append([float(lineArr[0]), float(lineArr[1])])
        # 添加标签(100个元素排成一行)
        labelMat.append(float(lineArr[2]))
    return dataMat, labelMat

def calcEk(oS, k):
    # multiply(a,b)就是个乘法，如果a,b是两个数组，那么对应元素相乘
    # .T为转置
    fXk = float(np.multiply(oS.alphas, oS.labelMat).T * oS.K[:, k] + oS.b)
    # 计算误差项
    Ek = fXk - float(oS.labelMat[k])
    # 返回误差项
    return Ek


def selectJrand(i, m):
    j = i
    while (j == i):
        # uniform()方法将随机生成一个实数，它在[x, y)范围内
        j = int(random.uniform(0, m))
    return j


def selectJ(i, oS, Ei):
    # 初始化
    maxK = -1
    maxDeltaE = 0
    Ej = 0
    # 根据Ei更新误差缓存
    oS.eCache[i] = [1, Ei]
    # 对一个矩阵.A转换为Array类型
    # 返回误差不为0的数据的索引值
    validEcacheList = np.nonzero(oS.eCache[:, 0].A)[0]
    # 有不为0的误差
    if (len(validEcacheList) &gt; 1):
        # 遍历，找到最大的Ek
        for k in validEcacheList:
            # 不计算k==i节省时间
            if k == i:
                continue
            # 计算Ek
            Ek = calcEk(oS, k)
            # 计算|Ei - Ek|
            deltaE = abs(Ei - Ek)
            # 找到maxDeltaE
            if (deltaE &gt; maxDeltaE):
                maxK = k
                maxDeltaE = deltaE
                Ej = Ek
        # 返回maxK，Ej
        return maxK, Ej
    # 没有不为0的误差
    else:
        # 随机选择alpha_j的索引值
        j = selectJrand(i, oS.m)
        # 计算Ej
        Ej = calcEk(oS, j)
    # 返回j，Ej
    return j, Ej


def updateEk(oS, k):
    # 计算Ek
    Ek = calcEk(oS, k)
    # 更新误差缓存
    oS.eCache[k] = [1, Ek]


def clipAlpha(aj, H, L):
    if aj &gt; H:
        aj = H
    if L &gt; aj:
        aj = L
    return aj

def innerL(i, oS):
    # 步骤1：计算误差Ei
    Ei = calcEk(oS, i)
    # 优化alpha,设定一定的容错率
    if ((oS.labelMat[i] * Ei &lt; -oS.tol) and (oS.alphas[i] &lt; oS.C)) or (
            (oS.labelMat[i] * Ei &gt; oS.tol) and (oS.alphas[i] &gt; 0)):
        # 使用内循环启发方式2选择alpha_j,并计算Ej
        j, Ej = selectJ(i, oS, Ei)
        # 保存更新前的alpha值，使用深层拷贝
        alphaIold = oS.alphas[i].copy()
        alphaJold = oS.alphas[j].copy()
        # 步骤2：计算上界H和下界L
        if (oS.labelMat[i] != oS.labelMat[j]):
            L = max(0, oS.alphas[j] - oS.alphas[i])
            H = min(oS.C, oS.C + oS.alphas[j] - oS.alphas[i])
        else:
            L = max(0, oS.alphas[j] + oS.alphas[i] - oS.C)
            H = min(oS.C, oS.alphas[j] + oS.alphas[i])
        if L == H:
            print("L == H")
            return 0
        # 步骤3：计算eta
        eta = 2.0 * oS.K[i, j] - oS.K[i, i] - oS.K[j, j]
        if eta &gt;= 0:
            print("eta &gt;= 0")
            return 0
        # 步骤4：更新alpha_j
        oS.alphas[j] -= oS.labelMat[j] * (Ei - Ej) / eta
        # 步骤5：修剪alpha_j
        oS.alphas[j] = clipAlpha(oS.alphas[j], H, L)
        # 更新Ej至误差缓存
        updateEk(oS, j)
        if (abs(oS.alphas[j] - alphaJold) &lt; 0.00001):
            print("alpha_j变化太小")
            return 0
        # 步骤6：更新alpha_i
        oS.alphas[i] += oS.labelMat[i] * oS.labelMat[j] * (alphaJold - oS.alphas[j])
        # 更新Ei至误差缓存
        updateEk(oS, i)
        # 步骤7：更新b_1和b_2:
        b1 = oS.b - Ei - oS.labelMat[i] * (oS.alphas[i] - alphaIold) * oS.K[i, i] - oS.labelMat[j] * (
                    oS.alphas[j] - alphaJold) * oS.K[j, i]
        b2 = oS.b - Ej - oS.labelMat[i] * (oS.alphas[i] - alphaIold) * oS.K[i, j] - oS.labelMat[j] * (
                    oS.alphas[j] - alphaJold) * oS.K[j, j]
        # 步骤8：根据b_1和b_2更新b
        if (0 &lt; oS.alphas[i] &lt; oS.C):
            oS.b = b1
        elif (0 &lt; oS.alphas[j] &lt; oS.C):
            oS.b = b2
        else:
            oS.b = (b1 + b2) / 2.0
        return 1
    else:
        return 0


def smoP(dataMatIn, classLabels, C, toler, maxIter, kTup=('lin', 0)):
    # 初始化数据结构
    oS = optStruct(np.mat(dataMatIn), np.mat(classLabels).transpose(), C, toler, kTup)
    # 初始化当前迭代次数
    iter = 0
    entrieSet = True
    alphaPairsChanged = 0
    # 遍历整个数据集alpha都没有更新或者超过最大迭代次数，则退出循环
    while (iter &lt; maxIter) and ((alphaPairsChanged &gt; 0) or (entrieSet)):
        alphaPairsChanged = 0
        # 遍历整个数据集
        if entrieSet:
            for i in range(oS.m):
                # 使用优化的SMO算法
                alphaPairsChanged += innerL(i, oS)
                print("全样本遍历:第%d次迭代 样本:%d, alpha优化次数:%d" % (iter, i, alphaPairsChanged))
            iter += 1
        # 遍历非边界值
        else:
            # 遍历不在边界0和C的alpha
            nonBoundIs = np.nonzero((oS.alphas.A &gt; 0) * (oS.alphas.A &lt; C))[0]
            for i in nonBoundIs:
                alphaPairsChanged += innerL(i, oS)
                print("非边界遍历:第%d次迭代 样本:%d, alpha优化次数:%d" % (iter, i, alphaPairsChanged))
            iter += 1
        # 遍历一次后改为非边界遍历
        if entrieSet:
            entrieSet = False
        # 如果alpha没有更新，计算全样本遍历
        elif (alphaPairsChanged == 0):
            entrieSet = True
        print("迭代次数:%d" % iter)
    # 返回SMO算法计算的b和alphas
    return oS.b, oS.alphas

def testRbf(k1=1.3):
    # 加载训练集
    dataArr, labelArr = loadDataSet('E:\\数据挖掘\\Machine learning\\代码\\SVM_Project3\\testSetRBF.txt')
    # 根据训练集计算b, alphas
    b, alphas = smoP(dataArr, labelArr, 200, 0.0001, 100, ('rbf', k1))
    datMat = np.mat(dataArr)
    labelMat = np.mat(labelArr).transpose()
    # 获得支持向量
    svInd = np.nonzero(alphas.A &gt; 0)[0]
    sVs = datMat[svInd]
    labelSV = labelMat[svInd]
    print("支持向量个数:%d" % np.shape(sVs)[0])
    m, n = np.shape(datMat)
    errorCount = 0
    for i in range(m):
        # 计算各个点的核
        kernelEval = kernelTrans(sVs, datMat[i, :], ('rbf', k1))
        # 根据支持向量的点计算超平面，返回预测结果
        predict = kernelEval.T * np.multiply(labelSV, alphas[svInd]) + b
        # 返回数组中各元素的正负号，用1和-1表示，并统计错误个数
        if np.sign(predict) != np.sign(labelArr[i]):
            errorCount += 1
    # 打印错误率
    print('训练集错误率:%.2f%%' % ((float(errorCount) / m) * 100))
    # 加载测试集
    dataArr, labelArr = loadDataSet('E:\\数据挖掘\\Machine learning\\代码\\SVM_Project3\\testSetRBF2.txt')
    errorCount = 0
    datMat = np.mat(dataArr)
    labelMat = np.mat(labelArr).transpose()
    m, n = np.shape(datMat)
    for i in range(m):
        # 计算各个点的核
        kernelEval = kernelTrans(sVs, datMat[i, :], ('rbf', k1))
        # 根据支持向量的点计算超平面，返回预测结果
        predict = kernelEval.T * np.multiply(labelSV, alphas[svInd]) + b
        # 返回数组中各元素的正负号，用1和-1表示，并统计错误个数
        if np.sign(predict) != np.sign(labelArr[i]):
            errorCount += 1
    # 打印错误率
    print('训练集错误率:%.2f%%' % ((float(errorCount) / m) * 100))


def showDataSet(dataMat, labelMat):
    # 正样本
    data_plus = []
    # 负样本
    data_minus = []
    for i in range(len(dataMat)):
        if labelMat[i] &gt; 0:
            data_plus.append(dataMat[i])
        else:
            data_minus.append(dataMat[i])
    # 转换为numpy矩阵
    data_plus_np = np.array(data_plus)
    # 转换为numpy矩阵
    data_minus_np = np.array(data_minus)
    # 正样本散点图（scatter）
    # transpose转置
    plt.scatter(np.transpose(data_plus_np)[0], np.transpose(data_plus_np)[1])
    # 负样本散点图（scatter）
    plt.scatter(np.transpose(data_minus_np)[0], np.transpose(data_minus_np)[1])
    # 显示
    plt.show()


if __name__ == '__main__':
    testRbf()</code></pre> 
 <h2 id="二公式推导">二、公式推导</h2> 
 <p><span class="math inline">\(在样本空间中任意点x到超平面(w,b)的距离可写为：\)</span></p> 
 <p><span class="math display">\[ r = \frac{|w^Tx + b|}{||w||} \]</span></p> 
 <p><span class="math display">\[推导如下：\\ 取x_0为任意点x在超平面y= w^Tx + b的投影\\ wx_0 +b = 0 \Longrightarrow |w\vec {xx_0}| = |w\vec r|= ||w||r \\ 另一方面:|w\vec{xx_0}| = |w(x_0 -x)|=|-b-wx|=|b+wx|\\ \therefore r = \frac{|w^Tx + b|}{||w||}\]</span><br><span class="math display">\[ \hat r=yf(x)=y(w^Tx + b)\\ \tilde r = ry = y\frac{|w^Tx + b|}{||w||}=\frac {\hat r}{||w||}\\ \\定义\hat r为函数间隔，\tilde r为几何间隔 \]</span></p> 
 <p><span class="math display">\[ L(\boldsymbol{w}, b, \boldsymbol{\alpha})=\frac{1}{2}\|\boldsymbol{w}\|^{2}+\sum_{i=1}^{m} \alpha_{i}\left(1-y_{i}\left(\boldsymbol{w}^{\top} \boldsymbol{x}_{i}+b\right)\right) \]</span></p> 
 <p><span class="math display">\[原问题为极小极大问题\min_{\boldsymbol{w,b}}\quad \max_{\boldsymbol{\alpha}}\quad L(w,b,\alpha)\\ 转化为极大极小问题\max_{\boldsymbol{\alpha}}\quad \min_{\boldsymbol{w,b}}\quad L(w,b,\alpha)\]</span></p> 
 <p><span class="math display">\[推导如下：\\ 目标函数：min\frac{1}{2}||w||^2\\ 约束条件：y_i(w^Tx_i + b) \geq 1\\ \therefore 对每个在y_i(w^Tx_i+b)-1的i乘以\alpha_i\\ \therefore L(\boldsymbol{w}, b, \boldsymbol{\alpha})=\frac{1}{2}\|\boldsymbol{w}\|^{2}+\sum_{i=1}^{m} \alpha_{i}\left(1-y_{i}\left(\boldsymbol{w}^{\top} \boldsymbol{x}_{i}+b\right)\right)\]</span></p> 
 <p><span class="math display">\[在其他的机器学习上述公式是L(\boldsymbol{w}, b, \boldsymbol{\alpha})=\frac{1}{2}\|\boldsymbol{w}\|^{2}-\sum_{i=1}^{m} \alpha_{i}\left(y_{i}\left(\boldsymbol{w}^{\top} \boldsymbol{x}_{i}+b\right)-1\right)，两者等价\]</span><br><span class="math display">\[ \begin{aligned} w &amp;= \sum_{i=1}^m\alpha_iy_i\boldsymbol{x}_i \\ 0 &amp;=\sum_{i=1}^m\alpha_iy_i \end{aligned} \]</span></p> 
 <p><span class="math display">\[推导如下：\\ \begin{aligned} L(\boldsymbol{w},b,\boldsymbol{\alpha}) &amp;= \frac{1}{2}||\boldsymbol{w}||^2+\sum_{i=1}^m\alpha_i(1-y_i(\boldsymbol{w}^T\boldsymbol{x}_i+b)) \\ &amp; = \frac{1}{2}||\boldsymbol{w}||^2+\sum_{i=1}^m(\alpha_i-\alpha_iy_i \boldsymbol{w}^T\boldsymbol{x}_i-\alpha_iy_ib)\\ &amp; =\frac{1}{2}\boldsymbol{w}^T\boldsymbol{w}+\sum_{i=1}^m\alpha_i -\sum_{i=1}^m\alpha_iy_i\boldsymbol{w}^T\boldsymbol{x}_i-\sum_{i=1}^m\alpha_iy_ib \end{aligned}\]</span></p> 
 <p><span class="math display">\[\frac {\partial L}{\partial \boldsymbol{w}}=\frac{1}{2}\times2\times\boldsymbol{w} + 0 - \sum_{i=1}^{m}\alpha_iy_i \boldsymbol{x}_i-0= 0 \Longrightarrow \boldsymbol{w}=\sum_{i=1}^{m}\alpha_iy_i \boldsymbol{x}_i\]</span></p> 
 <p><span class="math display">\[\frac {\partial L}{\partial b}=0+0-0-\sum_{i=1}^{m}\alpha_iy_i=0 \Longrightarrow \sum_{i=1}^{m}\alpha_iy_i=0\]</span><br><span class="math display">\[ \begin{aligned} \max_{\boldsymbol{\alpha}} &amp; \sum_{i=1}^m\alpha_i - \frac{1}{2}\sum_{i = 1}^m\sum_{j=1}^m\alpha_i \alpha_j y_iy_j\boldsymbol{x}_i^T\boldsymbol{x}_j \\ s.t. &amp; \sum_{i=1}^m \alpha_i y_i =0 \\ &amp; \alpha_i \geq 0 \quad i=1,2,\dots ,m \end{aligned} \]</span><br><span class="math inline">\(推导如下：\\计算拉格朗日函数，即将求得的两个公式代入\)</span></p> 
 <p><span class="math display">\[\begin{aligned} \min_{\boldsymbol{w},b} L(\boldsymbol{w},b,\boldsymbol{\alpha}) &amp;=\frac{1}{2}\boldsymbol{w}^T\boldsymbol{w}+\sum_{i=1}^m\alpha_i -\sum_{i=1}^m\alpha_iy_i\boldsymbol{w}^T\boldsymbol{x}_i-\sum_{i=1}^m\alpha_iy_ib \\ &amp;=\frac {1}{2}\boldsymbol{w}^T\sum _{i=1}^m\alpha_iy_i\boldsymbol{x}_i-\boldsymbol{w}^T\sum _{i=1}^m\alpha_iy_i\boldsymbol{x}_i+\sum _{i=1}^m\alpha_ i -b\sum _{i=1}^m\alpha_iy_i \\ &amp; = -\frac {1}{2}\boldsymbol{w}^T\sum _{i=1}^m\alpha_iy_i\boldsymbol{x}_i+\sum _{i=1}^m\alpha_i -b\sum _{i=1}^m\alpha_iy_i \end{aligned}\]</span></p> 
 <p><span class="math display">\[\begin{aligned} \min_{\boldsymbol{w},b} L(\boldsymbol{w},b,\boldsymbol{\alpha}) &amp;= -\frac {1}{2}\boldsymbol{w}^T\sum _{i=1}^m\alpha_iy_i\boldsymbol{x}_i+\sum _{i=1}^m\alpha_i \\ &amp;=-\frac {1}{2}(\sum_{i=1}^{m}\alpha_iy_i\boldsymbol{x}_i)^T(\sum _{i=1}^m\alpha_iy_i\boldsymbol{x}_i)+\sum _{i=1}^m\alpha_i \\ &amp;=-\frac {1}{2}\sum_{i=1}^{m}\alpha_iy_i\boldsymbol{x}_i^T\sum _{i=1}^m\alpha_iy_i\boldsymbol{x}_i+\sum _{i=1}^m\alpha_i \\ &amp;=\sum _{i=1}^m\alpha_i-\frac {1}{2}\sum_{i=1 }^{m}\sum_{j=1}^{m}\alpha_i\alpha_jy_iy_j\boldsymbol{x}_i^T\boldsymbol{x}_j \end{aligned}\]</span><br><span class="math display">\[ \begin{aligned} &amp; \min_{\boldsymbol{\alpha}}\frac{1}{2}\sum_{i = 1}^m\sum_{j=1}^m\alpha_i \alpha_j y_iy_j\boldsymbol{x}_i^T\boldsymbol{x}_j- \sum_{i=1}^m\alpha_i\\ &amp; s.t. \sum_{i=1}^m \alpha_i y_i =0 \\ &amp; \alpha_i \geq 0 \quad i=1,2,\dots ,m \end{aligned} \]</span><br><span class="math display">\[在原\max_{\boldsymbol{\alpha}}\quad \min_{\boldsymbol{w,b}}\quad L(w,b,\alpha)加负号，同样转化为约束最优化问题，为了求解最优解\alpha^*\]</span><br><span class="math display">\[ 计算得到\\w^* = \sum_{i =1}^m{\alpha_i}^*y_ix_i\\ b^* = y_i -\sum_{i=1}^m{\alpha_i}^*y_i（x_ix_j）\\ 分离得到超平面：\\ w^*x+ b^* =0\\ 分类决策函数：\\ f(x) =sign(w^*x+b^*) \]</span></p> 
 <p><span class="math display">\[引入松弛因子\xi_i的目标函数如下:\\\]</span><br><span class="math display">\[ \begin{aligned} &amp; \min_{\boldsymbol{w,b,\xi}}\frac{1}{2}||w||^2 +C\sum_{i = 1}^m\xi_i\\ s.t. &amp; y_i(w.x_i+b)\geq1-\xi_i, i=1,2,\dots ,m \\ &amp; \xi_i \geq 0 \quad i=1,2,\dots ,m \end{aligned} \]</span></p> 
 <p><span class="math display">\[同理如上式，构造拉格朗日函数L，再对w,b,\xi分别求偏导，再代入L\]</span><br><span class="math display">\[ \begin{aligned} L(\boldsymbol{w},b,\boldsymbol{\alpha},\boldsymbol{\xi},\boldsymbol{\mu}) &amp;= \frac{1}{2}||\boldsymbol{w}||^2+C\sum_{i=1}^m \xi_i+\sum_{i=1}^m \alpha_i(1-\xi_i-y_i(\boldsymbol{w}^T\boldsymbol{x}_i+b))-\sum_{i=1}^m\mu_i \xi_i \end{aligned} \]</span><br><span class="math display">\[对w,b,\xi求偏导\]</span><br><span class="math display">\[ \begin{aligned} w &amp;= \sum_{i=1}^m\alpha_iy_i\boldsymbol{x}_i \\ 0 &amp;=\sum_{i=1}^m\alpha_iy_i\\ C &amp; = a_i+\mu_i \end{aligned} \]</span></p> 
 <p><span class="math display">\[代入L\]</span><br><span class="math display">\[ \begin{aligned} \min_{\boldsymbol{w},b,\boldsymbol{\xi}}L(\boldsymbol{w},b,\boldsymbol{\alpha},\boldsymbol{\xi},\boldsymbol{\mu}) &amp;= \frac{1}{2}||\boldsymbol{w}||^2+C\sum_{i=1}^m \xi_i+\sum_{i=1}^m \alpha_i(1-\xi_i-y_i(\boldsymbol{w}^T\boldsymbol{x}_i+b))-\sum_{i=1}^m\mu_i \xi_i \\ &amp;=\frac{1}{2}||\boldsymbol{w}||^2+\sum_{i=1}^m\alpha_i(1-y_i(\boldsymbol{w}^T\boldsymbol{x}_i+b))+C\sum_{i=1}^m \xi_i-\sum_{i=1}^m \alpha_i \xi_i-\sum_{i=1}^m\mu_i \xi_i \\ &amp; = -\frac {1}{2}\sum_{i=1}^{m}\alpha_iy_i\boldsymbol{x}_i^T\sum _{i=1}^m\alpha_iy_i\boldsymbol{x}_i+\sum _{i=1}^m\alpha_i +\sum_{i=1}^m C\xi_i-\sum_{i=1}^m \alpha_i \xi_i-\sum_{i=1}^m\mu_i \xi_i \\ &amp; = -\frac {1}{2}\sum_{i=1}^{m}\alpha_iy_i\boldsymbol{x}_i^T\sum _{i=1}^m\alpha_iy_i\boldsymbol{x}_i+\sum _{i=1}^m\alpha_i +\sum_{i=1}^m (C-\alpha_i-\mu_i)\xi_i \\ &amp;=\sum _{i=1}^m\alpha_i-\frac {1}{2}\sum_{i=1 }^{m}\sum_{j=1}^{m}\alpha_i\alpha_jy_iy_j\boldsymbol{x}_i^T\boldsymbol{x}_j \end{aligned} \]</span><br><span class="math display">\[再求\alpha极大\max\]</span><br><span class="math display">\[ \begin{aligned} &amp;\max_{\alpha}\sum _{i=1}^m\alpha_i-\frac {1}{2}\sum_{i=1 }^{m}\sum_{j=1}^{m}\alpha_i\alpha_jy_iy_j\boldsymbol{x}_i^T\boldsymbol{x}_j\\ 转化为\\ &amp;\min_{\alpha}\frac {1}{2}\sum_{i=1 }^{m}\sum_{j=1}^{m}\alpha_i\alpha_jy_iy_j\boldsymbol{x}_i^T\boldsymbol{x}_j-\sum _{i=1}^m\alpha_i\\ &amp;s.t.\sum_{i=1}^m \alpha_i y_i=0 \\ &amp;0 \leq\alpha_i \leq C \quad i=1,2,\dots ,m \end{aligned} \]</span><br><span class="math display">\[求最优解\alpha^*\]</span><br><span class="math display">\[ 计算得到\\w^* = \sum_{i =1}^m{\alpha_i}^*y_ix_i\\ b^* = (\max_{i: y_i =1} w^*.x_i + \min_{i: y_i =-1} w^x* +x_i)/2\\ 分离得到超平面：\\ w^*x+ b^* =0\\ 分类决策函数：\\ f(x) =sign(w^*x+b^*) \]</span></p> 
 <p><span class="math display">\[ \left\{\begin{array}{l} {\alpha_{i}\left(f\left(\boldsymbol{x}_{i}\right)-y_{i}-\epsilon-\xi_{i}\right)=0} \\ {\hat{\alpha}_{i}\left(y_{i}-f\left(\boldsymbol{x}_{i}\right)-\epsilon-\hat{\xi}_{i}\right)=0} \\ {\alpha_{i} \hat{\alpha}_{i}=0, \xi_{i} \hat{\xi}_{i}=0} \\ {\left(C-\alpha_{i}\right) \xi_{i}=0,\left(C-\hat{\alpha}_{i}\right) \hat{\xi}_{i}=0} \end{array}\right. \]</span><br><span class="math display">\[推导如下：\\\]</span><br><span class="math display">\[ \left\{\begin{array}{l}2{f\left(\boldsymbol{x}_{i}\right)-y_{i}-\epsilon-\xi_{i} \leq 0 }  \\ 3{y_{i}-f\left(\boldsymbol{x}_{i}\right)-\epsilon-\hat{\xi}_{i} \leq 0 } \\ 4{-\xi_{i} \leq 0} \\5{-\hat{\xi}_{i} \leq 0}6\end{array}\right. \]</span></p> 
 <p><span class="math display">\[ \left\{\begin{array}{l} {\alpha_i\left(f\left(\boldsymbol{x}_{i}\right)-y_{i}-\epsilon-\xi_{i} \right) = 0 } \\ {\hat{\alpha}_i\left(y_{i}-f\left(\boldsymbol{x}_{i}\right)-\epsilon-\hat{\xi}_{i} \right) = 0 } \\ {-\mu_i\xi_{i} = 0 \Rightarrow \mu_i\xi_{i} = 0 } \\ {-\hat{\mu}_i \hat{\xi}_{i} = 0 \Rightarrow \hat{\mu}_i \hat{\xi}_{i} = 0 } \end{array}\right. \]</span></p> 
 <p><span class="math display">\[\because\begin{aligned} \mu_i=C-\alpha_i \\ \hat{\mu}_i=C-\hat{\alpha}_i \end{aligned}\]</span><br><span class="math display">\[ \left\{\begin{array}{l} {\alpha_i\left(f\left(\boldsymbol{x}_{i}\right)-y_{i}-\epsilon-\xi_{i} \right) = 0 } \\ {\hat{\alpha}_i\left(y_{i}-f\left(\boldsymbol{x}_{i}\right)-\epsilon-\hat{\xi}_{i} \right) = 0 } \\ {(C-\alpha_i)\xi_{i} = 0 } \\ {(C-\hat{\alpha}_i) \hat{\xi}_{i} = 0 } \end{array}\right. \]</span><br><span class="math display">\[前面硬间隔与软间隔均处理线性问题，而对非线性问题需要将低维空间映射到高维空间，引入核函数\]</span></p> 
 <p><span class="math display">\[多项式核函数\]</span><br><span class="math display">\[ k(\vec x,\vec y)= (\vec x,\vec y +c)^2\\ =(\vec x, \vec y)^2+2c\vec x\vec y+c^2\\ =\sum_{i =1}^n \sum_{j=1}^m(x_ix_j)(y_iy_j)+\sum_{i=1}^m(\sqrt {2c}x_i \sqrt{2cy_i})+c^2 \]</span><br><span class="math inline">\(高斯核函数\)</span><br><span class="math display">\[ k(\vec x_1,\vec x_2) = e^-\frac{x_1^2+x_2^2}{2\sigma^2}(1+\frac {x_1 x_2}{\sigma^2}+\frac{x_1^2+x_2^2}{2\sigma^2 \sigma^2}+...+\frac{x_1^n+x_2^n}{n!\sigma^n\sigma^n}) \]</span></p> 
 <h2 id="三练习题目">三、练习题目</h2> 
 <h3 id="给定三个数据点正例点x_1-3-3t-x_2-4-3t负例点x_3-1-1t求线性可分svm">3.1 给定三个数据点，正例点<span class="math inline">\(x_1 = (3, 3)^T\)</span>, <span class="math inline">\(x_2 = (4, 3)^T\)</span>,负例点<span class="math inline">\(x_3 = (1, 1)^T\)</span>，求线性可分SVM</h3> 
 <h3 id="svm可否用于多分类">3.2 SVM可否用于多分类</h3> 
 <h3 id="svm和logistic回归的比较">3.3 SVM和Logistic回归的比较</h3> 
 <h3 id="核函数是什么高斯核映射到无穷维是怎么回事">3.4 核函数是什么？高斯核映射到无穷维是怎么回事？</h3> 
 <h3 id="如何理解svm的损失函数">3.5 如何理解SVM的损失函数？</h3> 
 <h3 id="使用高斯核函数请描述svm的参数c和-sigma-对分类器的影响">3.6 使用高斯核函数，请描述SVM的参数C和 <span class="math inline">\(\sigma\)</span> 对分类器的影响</h3> 
 <h3 id="比较感知机的对偶性形式与线性可分支持向量机的对偶形式">3.7 比较感知机的对偶性形式与线性可分支持向量机的对偶形式</h3> 
 <h3 id="证明内积的正整数幂函数">3-8 证明内积的正整数幂函数：</h3> 
 <p><span class="math display">\[ K(x,z) = (x,z)^p\\ 是正定核函数，此处p为正整数，x,z为R \]</span></p> 
 <h3 id="线性支持向量机还可定义为以下形式">3.9 线性支持向量机还可定义为以下形式：</h3> 
 <p><span class="math display">\[ \begin{aligned} \min_{\boldsymbol{w,b,\xi}}\quad \frac{1}{2}||w||^2+C\sum_{i=1}^N{\xi_i}^2\\ s.t.\quad y_i(\boldsymbol w.{x_i}+b)\geq 1-\xi_i, i= 1,2,...,N\\ {\xi}_i \geq 0, i=1, 2,...,N \end{aligned}\\ 求其对偶形式 \]</span></p> 
 <h3 id="给定数据点正例点x_1-1-2t-x_2-2-3t-x_3-1-1t负例点x_4-1-1tx_5-1-1t求最大间隔分离超平面和分类决策函数并在图上画出分离超平面间隔边界及支持向量">3.10 给定数据点，正例点<span class="math inline">\(x_1 = (1, 2)^T\)</span>, <span class="math inline">\(x_2 = (2, 3)^T\)</span>, <span class="math inline">\(x_3 = (1, 1)^T,\)</span>负例点<span class="math inline">\(x_4 = (1, 1)^T\)</span>,<span class="math inline">\(x_5 = (1, 1)^T\)</span>,求最大间隔分离超平面和分类决策函数，并在图上画出分离超平面，间隔边界及支持向量</h3> 
 <h3 id="分析svm对噪声敏感的原因">3.11 分析SVM对噪声敏感的原因</h3> 
 <h3 id="使用核技巧推广对数几率回归产生核对率回归">3.12 使用核技巧推广对数几率回归，产生核对率回归</h3> 
 <h3 id="给出式6.52的kkt条件">3.13 给出式（6.52）的KKT条件</h3> 
 <h3 id="讨论线性判别分析与线性核支持向量机在何种条件等价">3.13 讨论线性判别分析与线性核支持向量机在何种条件等价</h3> 
 <h2 id="四参看文献">四、参看文献</h2> 
 <p>[1] 《机器学习》 邹博</p> 
 <p>[2] 《SVM的三重境界》 July</p> 
 <p>[3] 《pumpkin-book》 Datawhale</p> 
 <p>[4] 《机器学习》周志华</p> 
 <p>[5] 《机器学习实战》Peter</p> 
 <p>[6] 《统计学习方法》李航，清华大学出版社，2012</p> 
 <p>[7] 《机器学习算法精讲》 秦曾昌，2018</p> 
</div> 
<p>转载于:https://www.cnblogs.com/Jacon-hunt/p/11409720.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b18512533c0dd01235bff99cebdf2f36/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CSS布局-水平&amp;垂直对齐</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dbf4b617299f66d5e1966e012936520c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Springboot使用mongoDB，比较两个字段的大小</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>