<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>4 FFmpeg从入门到精通-FFmpeg转码 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="4 FFmpeg从入门到精通-FFmpeg转码" />
<meta property="og:description" content="1 FFmpeg从入门到精通-FFmpeg简介
2 FFmpeg从入门到精通-FFmpeg工具使用基础
3 FFmpeg从入门到精通-FFmpeg转封装
4 FFmpeg从入门到精通-FFmpeg转码
5 FFmpeg从入门到精通-FFmpeg流媒体
6 FFmpeg从入门到精通-FFmpeg滤镜使用
7 FFmpeg从入门到精通-FFmpeg中Linux设备操作
8 FFmpeg从入门到精通-FFmpeg接口libavformat的使用
9 FFmpeg从入门到精通-FFmpeg接口libavcodec的使用
10 FFmpeg从入门到精通-FFmpeg接口libavfilter的使用
文章目录 4.FFmpeg转码 4.1 FFmpeg软编码H.264与H.265 4.1.1 x264编码参数简介 4.1.2 H.264编码举例 1.编码器预设参数设置preset 2.H.264编码优化参数tune 3.H.264的profile与level设置 4.控制场景切换关键帧插入参数sc_threshold 5.设置x264内部参数x264opts 6.CBR恒定码率设置参数nal-hrd 4.2 FFmpeg硬编解码 4.2.1 Nvidia GPU硬编解码 1.Nvidia硬编码参数 2.Nvidia硬编解码参数使用举例 4.2.2 Intel QSV硬编码 1.Intel QSV H.264参数说明 2.Intel QSV H.264使用举例 3.Intel QSV H.265参数说明 4.Intel QSV H.265使用举例 4.2.3 树莓派硬编码 1.h264_omx参数说明 4.3 FFmpeg输出MP3 4.3.1 MP3编码参数介绍 4.3.2 MP3的编码质量设置 4.3.3 平均码率编码参数ABR 4.4 FFmpeg输出AAC 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2b0fd117a415581841420fc1df6b4d3d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-23T18:12:53+08:00" />
<meta property="article:modified_time" content="2023-03-23T18:12:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">4 FFmpeg从入门到精通-FFmpeg转码</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><a href="https://blog.csdn.net/migu123/article/details/129300701">1 FFmpeg从入门到精通-FFmpeg简介</a><br> <a href="https://blog.csdn.net/migu123/article/details/129300983">2 FFmpeg从入门到精通-FFmpeg工具使用基础</a><br> <a href="https://blog.csdn.net/migu123/article/details/129301229">3 FFmpeg从入门到精通-FFmpeg转封装</a><br> <a href="https://blog.csdn.net/migu123/article/details/129313337">4 FFmpeg从入门到精通-FFmpeg转码</a><br> <a href="https://blog.csdn.net/migu123/article/details/129313756">5 FFmpeg从入门到精通-FFmpeg流媒体</a><br> <a href="https://blog.csdn.net/migu123/article/details/129314333">6 FFmpeg从入门到精通-FFmpeg滤镜使用</a><br> <a href="https://blog.csdn.net/migu123/article/details/129314910">7 FFmpeg从入门到精通-FFmpeg中Linux设备操作</a><br> <a href="https://blog.csdn.net/migu123/article/details/129317309">8 FFmpeg从入门到精通-FFmpeg接口libavformat的使用</a><br> <a href="https://blog.csdn.net/migu123/article/details/129324534">9 FFmpeg从入门到精通-FFmpeg接口libavcodec的使用</a><br> <a href="https://blog.csdn.net/migu123/article/details/129324632">10 FFmpeg从入门到精通-FFmpeg接口libavfilter的使用</a></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#font_face_size44FFmpegfont_12" rel="nofollow"><font face="黑体" size="4">4.FFmpeg转码</font></a></li><li><ul><li><a href="#nbspnbspfont_face_size341_FFmpegH264H265font_13" rel="nofollow">  <font face="黑体" size="3">4.1 FFmpeg软编码H.264与H.265</font></a></li><li><ul><li><a href="#font_face_size3nbspnbsp411_x264font_22" rel="nofollow"><font face="黑体" size="3">  4.1.1 x264编码参数简介</font></a></li><li><a href="#font_face_size3nbspnbsp412_H264font_26" rel="nofollow"><font face="黑体" size="3">  4.1.2 H.264编码举例</font></a></li><li><ul><li><a href="#font_face_size2_nbspnbsp_1presetfont_28" rel="nofollow"><font face="楷体" size="2">    1.编码器预设参数设置preset</font></a></li><li><a href="#font_face_size2_nbspnbsp_2H264tunefont_128" rel="nofollow"><font face="楷体" size="2">    2.H.264编码优化参数tune</font></a></li><li><a href="#font_face_size2_nbspnbsp_3H264profilelevelfont_172" rel="nofollow"><font face="楷体" size="2">    3.H.264的profile与level设置</font></a></li><li><a href="#font_face_size2_nbspnbsp_4sc_thresholdfont_191" rel="nofollow"><font face="楷体" size="2">    4.控制场景切换关键帧插入参数sc_threshold</font></a></li><li><a href="#font_face_size2_nbspnbsp_5x264x264optsfont_205" rel="nofollow"><font face="楷体" size="2">    5.设置x264内部参数x264opts</font></a></li><li><a href="#font_face_size2_nbspnbsp_6CBRnalhrdfont_221" rel="nofollow"><font face="楷体" size="2">    6.CBR恒定码率设置参数nal-hrd</font></a></li></ul> 
   </li></ul> 
   </li><li><a href="#nbspnbspfont_face_size342_FFmpegfont_241" rel="nofollow">  <font face="黑体" size="3">4.2 FFmpeg硬编解码</font></a></li><li><ul><li><a href="#font_face_size3nbspnbsp421_Nvidia_GPUfont_243" rel="nofollow"><font face="黑体" size="3">  4.2.1 Nvidia GPU硬编解码</font></a></li><li><ul><li><a href="#font_face_size2_nbspnbsp_1Nvidiafont_245" rel="nofollow"><font face="楷体" size="2">    1.Nvidia硬编码参数</font></a></li><li><a href="#font_face_size2_nbspnbsp_2Nvidiafont_249" rel="nofollow"><font face="楷体" size="2">    2.Nvidia硬编解码参数使用举例</font></a></li></ul> 
    </li><li><a href="#font_face_size3nbspnbsp422_Intel_QSVfont_277" rel="nofollow"><font face="黑体" size="3">  4.2.2 Intel QSV硬编码</font></a></li><li><ul><li><a href="#font_face_size2_nbspnbsp_1Intel_QSV_H264font_287" rel="nofollow"><font face="楷体" size="2">    1.Intel QSV H.264参数说明</font></a></li><li><a href="#font_face_size2_nbspnbsp_2Intel_QSV_H264font_291" rel="nofollow"><font face="楷体" size="2">    2.Intel QSV H.264使用举例</font></a></li><li><a href="#font_face_size2_nbspnbsp_3Intel_QSV_H265font_333" rel="nofollow"><font face="楷体" size="2">    3.Intel QSV H.265参数说明</font></a></li><li><a href="#font_face_size2_nbspnbsp_4Intel_QSV_H265font_336" rel="nofollow"><font face="楷体" size="2">    4.Intel QSV H.265使用举例</font></a></li></ul> 
    </li><li><a href="#font_face_size3nbspnbsp423_font_352" rel="nofollow"><font face="黑体" size="3">  4.2.3 树莓派硬编码</font></a></li><li><ul><li><a href="#font_face_size2_nbspnbsp_1h264_omxfont_368" rel="nofollow"><font face="楷体" size="2">    1.h264_omx参数说明</font></a></li></ul> 
   </li></ul> 
   </li><li><a href="#nbspnbspfont_face_size343_FFmpegMP3font_372" rel="nofollow">  <font face="黑体" size="3">4.3 FFmpeg输出MP3</font></a></li><li><ul><li><a href="#font_face_size3nbspnbsp431_MP3font_374" rel="nofollow"><font face="黑体" size="3">  4.3.1 MP3编码参数介绍</font></a></li><li><a href="#font_face_size3nbspnbsp432_MP3font_378" rel="nofollow"><font face="黑体" size="3">  4.3.2 MP3的编码质量设置</font></a></li><li><a href="#font_face_size3nbspnbsp433_ABRfont_437" rel="nofollow"><font face="黑体" size="3">  4.3.3 平均码率编码参数ABR</font></a></li></ul> 
   </li><li><a href="#nbspnbspfont_face_size344_FFmpegAACfont_463" rel="nofollow">  <font face="黑体" size="3">4.4 FFmpeg输出AAC</font></a></li><li><ul><li><a href="#font_face_size3nbspnbsp441_FFmpegAACfont_469" rel="nofollow"><font face="黑体" size="3">  4.4.1 FFmpeg中的AAC编码器使用</font></a></li><li><a href="#font_face_size3nbspnbsp442_FDK_AACAACCodecfont_532" rel="nofollow"><font face="黑体" size="3">  4.4.2 FDK AAC第三方的AAC编解码Codec库</font></a></li><li><ul><li><a href="#font_face_size2_nbspnbsp_1CBRfont_534" rel="nofollow"><font face="楷体" size="2">    1.恒定码率（CBR）模式</font></a></li><li><a href="#font_face_size2_nbspnbsp_2VBRfont_545" rel="nofollow"><font face="楷体" size="2">    2.动态码率（VBR）模式</font></a></li></ul> 
    </li><li><a href="#font_face_size3nbspnbsp443_AACfont_556" rel="nofollow"><font face="黑体" size="3">  4.4.3 高质量AAC设置</font></a></li><li><ul><li><a href="#font_face_size2_nbspnbsp_1HEAACfont_558" rel="nofollow"><font face="楷体" size="2">    1.HE-AAC音频编码设置</font></a></li><li><a href="#font_face_size2_nbspnbsp_2HEv2AAC%09font_576" rel="nofollow"><font face="楷体" size="2">    2.HEv2-AAC音频编码设置 </font></a></li></ul> 
    </li><li><a href="#font_face_size3nbspnbsp444_AACfont_592" rel="nofollow"><font face="黑体" size="3">  4.4.4 AAC音频质量对比</font></a></li></ul> 
   </li><li><a href="#nbspnbspfont_face_size345_font_599" rel="nofollow">  <font face="黑体" size="3">4.5 系统资源使用情况</font></a></li><li><a href="#nbspnbspfont_face_size346_font_607" rel="nofollow">  <font face="黑体" size="3">4.6 小结</font></a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="font_face_size44FFmpegfont_12"></a><font face="黑体" size="4">4.FFmpeg转码</font></h2> 
<h3><a id="nbspnbspfont_face_size341_FFmpegH264H265font_13"></a>  <font face="黑体" size="3">4.1 FFmpeg软编码H.264与H.265</font></h3> 
<p><font face="Courier New">    支持H.264的封装格式有很多，如FLV、MP4、HLS（M3U8）、MKV、TS等格式；FFmpeg本身并不支持H.264的编码器，而是由FFmpeg的第三方模块对其进行支持，例如x264和OpenH264，二者各有各的优势。由于OpenH264开源比较晚，所以x264还是当前最常用的编码器，这里将重点介绍FFmpeg中x264的使用；使用x264进行H.264编码时，<code>所支持的像素格式主要包含yuv420p、yuvj420p、yuv422p、yuvj422p、yuv444p、yuvj444p、nv12、nv16、nv21。通过ffmpeg -h encoder=libx264可以查看到：</code></font></p> 
<pre><code class="prism language-bash">Encoder libx264 <span class="token punctuation">[</span>libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part <span class="token number">10</span><span class="token punctuation">]</span>:
    General capabilities: dr1 delay threads
    Threading capabilities: other
    Supported pixel formats: yuv420p yuvj420p yuv422p yuvj422p yuv444p yuvj444p nv12 nv16 nv21 yuv420p10le yuv422p10le yuv444p10le nv20le gray gray10le
</code></pre> 
<p><font face="Courier New">    因为其所支持的像素色彩格式比较多，所以x264支持的范围更广。下面就来详细介绍FFmpeg中x264的参数。</font></p> 
<h4><a id="font_face_size3nbspnbsp411_x264font_22"></a><font face="黑体" size="3">  4.1.1 x264编码参数简介</font></h4> 
<p><font face="Courier New">    x264参数在FFmpeg中可以使用很多参数，同样也可以使用x264本身的参数来控制，具体参数列表见下表。</font><br> <img src="https://images2.imgbox.com/c7/8c/TN4Ju64w_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    以上为H.264编码时用到的常见的参数，设置参数后编码生成的文件可以通过一些外部协助工具进行查看，如Elecard、Bitrate Viewer、ffprobe等。</font></p> 
<h4><a id="font_face_size3nbspnbsp412_H264font_26"></a><font face="黑体" size="3">  4.1.2 H.264编码举例</font></h4> 
<p><font face="Courier New">    上节中已经给出了FFmpeg中H.264编码器的操作参数，下面就来列举一些实际中常用的例子。</font></p> 
<h5><a id="font_face_size2_nbspnbsp_1presetfont_28"></a><font face="楷体" size="2">    1.编码器预设参数设置preset</font></h5> 
<p><font face="Courier New">    从FFmpeg的x264参考说明中可以看到，可以使用x264 --full help查看preset设置的详细说明，找到x264帮助信息中的preset参数项之后，可以看到其包含了以下几种预设参数，预设参数的详细设置具体如下。<br>     <code>·ultrafast：最快的编码方式</code><br>     除了默认设置之外，还增加了如下参数设置：</font></p> 
<pre><code class="prism language-bash">-no-8x8dct --aq-mode <span class="token number">0</span> --b-adapt <span class="token number">0</span> --bframes <span class="token number">0</span> --no-cabac --no-deblock --no-mbtree --me dia --no-mixed-refs --partitions none --rc-lookahead <span class="token number">0</span> --ref <span class="token number">1</span> --scenecut <span class="token number">0</span> --subme <span class="token number">0</span> --trellis <span class="token number">0</span> --no-weightb --weightp <span class="token number">0</span>
</code></pre> 
<p><font face="Courier New">    <code>·superfast：超级快速的编码方式</code><br> 除了默认设置之外，还增加了如下参数设置：</font></p> 
<pre><code class="prism language-bash">-no-mbtree --me dia --no-mixed-refs  --partitions i8x8,i4x4 --rc-lookahead <span class="token number">0</span>  --ref <span class="token number">1</span> --subme <span class="token number">1</span> --trellis <span class="token number">0</span> --weightp <span class="token number">1</span>
</code></pre> 
<p><font face="Courier New">    <code>·veryfast：非常快速的编码方式</code><br>     除了默认设置之外，还增加了如下参数设置：</font></p> 
<pre><code class="prism language-bash">-no-mixed-refs --rc-lookahead <span class="token number">10</span> --ref <span class="token number">1</span> --subme <span class="token number">2</span> --trellis <span class="token number">0</span> --weightp <span class="token number">1</span>
</code></pre> 
<p><font face="Courier New">    <code>·faster：稍微快速的编码方式</code><br>     除了默认设置之外，还增加了如下参数设置：</font></p> 
<pre><code class="prism language-bash">-no-mixed-refs --rc-lookahead <span class="token number">20</span> --ref <span class="token number">2</span> --subme <span class="token number">4</span> --weightp <span class="token number">1</span>
</code></pre> 
<p><font face="Courier New">    <code>·fast：快速的编码方式</code><br>     除了默认设置之外，还增加了如下参数设置：</font></p> 
<pre><code class="prism language-bash">-rc-lookahead <span class="token number">30</span> --ref <span class="token number">2</span> --subme <span class="token number">6</span> --weightp <span class="token number">1</span>
</code></pre> 
<p><font face="Courier New">    <code>·medium：折中的编码方式</code><br>     参数全部为默认设置。<br>     <code>·slow：慢的编码方式</code><br>     除了默认设置之外，还增加了如下参数设置：</font></p> 
<pre><code class="prism language-bash">-b-adapt <span class="token number">2</span> --direct auto --me umh --rc-lookahead <span class="token number">50</span> --ref <span class="token number">5</span> --subme <span class="token number">8</span>
</code></pre> 
<p><font face="Courier New">    <code>·slower：更慢的编码方式</code><br>     除了默认设置之外，还增加了如下参数设置：</font></p> 
<pre><code class="prism language-bash">-b-adapt <span class="token number">2</span> --direct auto --me umh --partitions all --rc-lookahead <span class="token number">60</span> --ref <span class="token number">8</span> --subme <span class="token number">9</span> --trellis <span class="token number">2</span>
</code></pre> 
<p><font face="Courier New">    <code>·veryslow：非常慢的编码方式</code><br>     除了默认设置之外，还增加了如下参数设置：</font></p> 
<pre><code class="prism language-bash">-b-adapt <span class="token number">2</span> --bframes <span class="token number">8</span> --direct auto --me umh --merange <span class="token number">24</span> --partitions all --ref <span class="token number">16</span> --subme <span class="token number">10</span> --trellis <span class="token number">2</span> --rc-lookahead <span class="token number">60</span>
</code></pre> 
<p><font face="Courier New">    <code>·placebo：最慢的编码方式</code><br>     除了默认设置之外，还增加了如下参数设置：</font></p> 
<pre><code class="prism language-bash">-bframes <span class="token number">16</span> --b-adapt <span class="token number">2</span> --direct auto --slow-firstpass --no-fast-pskip --me tesa --merange <span class="token number">24</span> --partitions all --rc-lookahead <span class="token number">60</span> --ref <span class="token number">16</span> --subme <span class="token number">11</span> --trellis <span class="token number">2</span>
</code></pre> 
<p><font face="Courier New">    随着所设置参数的不同，所编码出来的清晰度也会有所不同，设置相关的预设参数之后，有很多参数也会被设置所影响，因此需要了解相关的参数含义。为了方便操作，通过preset进行设置即可，下面就来看一下相同的机器中，<mark>设置ultrafast与设置medium预设参数之后转码效率的对比</mark>：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -vcodec libx264 -preset ultrafast -b:v 2000k output.mp4
</code></pre> 
<p><font face="Courier New">    命令行执行之后，输出内容如下：</font></p> 
<pre><code class="prism language-bash">Output <span class="token comment">#0, mp4, to 'output.mp4':</span>
  Metadata:
    major_brand     <span class="token builtin class-name">:</span> isom
    minor_version   <span class="token builtin class-name">:</span> <span class="token number">512</span>
    compatible_brands: isomiso2avc1mp41
    encoder         <span class="token builtin class-name">:</span> Lavf59.27.100
  Stream <span class="token comment">#0:0(und): Video: h264 (avc1 / 0x31637661), yuv420p(progressive), 1280x720, q=2-31, 2000 kb/s, 30 fps, 15360 tbn (default)</span>
    Metadata:
      handler_name    <span class="token builtin class-name">:</span> VideoHandler
      vendor_id       <span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
      encoder         <span class="token builtin class-name">:</span> Lavc59.37.100 libx264
    Side data:
      cpb: bitrate max/min/avg: <span class="token number">0</span>/0/2000000 buffer size: <span class="token number">0</span> vbv_delay: N/A
  Stream <span class="token comment">#0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 128 kb/s (default)</span>
    Metadata:
      handler_name    <span class="token builtin class-name">:</span> SoundHandler
      vendor_id       <span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
      encoder         <span class="token builtin class-name">:</span> Lavc59.37.100 aac
<span class="token assign-left variable">frame</span><span class="token operator">=</span> <span class="token number">2114</span> <span class="token assign-left variable">fps</span><span class="token operator">=</span><span class="token number">267</span> <span class="token assign-left variable">q</span><span class="token operator">=</span>-1.0 <span class="token assign-left variable">Lsize</span><span class="token operator">=</span>   13331kB <span class="token assign-left variable">time</span><span class="token operator">=</span>00:01:10.43 <span class="token assign-left variable">bitrate</span><span class="token operator">=</span><span class="token number">1550</span>.5kbits/s <span class="token assign-left variable">dup</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">drop</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">speed</span><span class="token operator">=</span> <span class="token number">8</span>.9x    
</code></pre> 
<p><font face="Courier New">    从命令行执行后的输出内容中可以看到，转码的预设参数为ultrafast模式，转码的速度为8.9倍速，接下来再看一下设置为medium模式后的速度：</font></p> 
<pre><code class="prism language-bash">Output <span class="token comment">#0, mp4, to 'output.mp4':</span>
  Metadata:
    major_brand     <span class="token builtin class-name">:</span> isom
    minor_version   <span class="token builtin class-name">:</span> <span class="token number">512</span>
    compatible_brands: isomiso2avc1mp41
    encoder         <span class="token builtin class-name">:</span> Lavf59.27.100
  Stream <span class="token comment">#0:0(und): Video: h264 (avc1 / 0x31637661), yuv420p(progressive), 1280x720, q=2-31, 2000 kb/s, 30 fps, 15360 tbn (default)</span>
    Metadata:
      handler_name    <span class="token builtin class-name">:</span> VideoHandler
      vendor_id       <span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
      encoder         <span class="token builtin class-name">:</span> Lavc59.37.100 libx264
    Side data:
      cpb: bitrate max/min/avg: <span class="token number">0</span>/0/2000000 buffer size: <span class="token number">0</span> vbv_delay: N/A
  Stream <span class="token comment">#0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 128 kb/s (default)</span>
    Metadata:
      handler_name    <span class="token builtin class-name">:</span> SoundHandler
      vendor_id       <span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
      encoder         <span class="token builtin class-name">:</span> Lavc59.37.100 aac
<span class="token assign-left variable">frame</span><span class="token operator">=</span> <span class="token number">2114</span> <span class="token assign-left variable">fps</span><span class="token operator">=</span> <span class="token number">56</span> <span class="token assign-left variable">q</span><span class="token operator">=</span>-1.0 <span class="token assign-left variable">Lsize</span><span class="token operator">=</span>   12217kB <span class="token assign-left variable">time</span><span class="token operator">=</span>00:01:10.37 <span class="token assign-left variable">bitrate</span><span class="token operator">=</span><span class="token number">1422</span>.1kbits/s <span class="token assign-left variable">dup</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">drop</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">speed</span><span class="token operator">=</span><span class="token number">1</span>.87x  
</code></pre> 
<p><font face="Courier New">    从以上输出内容中可以看到，设置medium模式后，转码速度为1.87倍速，速度虽然降低了，但画质却有了明显的提升，对比效果如图所示。</font><br> <img src="https://images2.imgbox.com/ee/3e/24CSu7ob_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    很显然，图中的上图是通过预设参数ultrafast转码之后的效果，下边的图像是通过medium转码之后的效果上下图像相差比较大，上边图像的马赛克多一些，图中草的对比比较明显，主要是因为<mark>两个preset中所设置的参数略有不同</mark>，详情可以参考前边的参数说明。</font></p> 
<h5><a id="font_face_size2_nbspnbsp_2H264tunefont_128"></a><font face="楷体" size="2">    2.H.264编码优化参数tune</font></h5> 
<p><font face="Courier New">    使用tune参数调优H.264编码时，可以包含如下几个场景：==film、animation、grain、stillimage、psnr、ssim、fastdecode、zerolatency；==这几种场景所使用的x264参数也各有不同，具体如下。</font><br>     <code>·film</code><br>     除默认参数配置之外，还需要设置如下参数：</p> 
<pre><code class="prism language-bash">-deblock -1:-1 --psy-rd <span class="token operator">&lt;</span>unset<span class="token operator">&gt;</span>:0.15
animation
</code></pre> 
<p><font face="Courier New">    <code>·animation</code><br>     除默认参数配置之外，还需要设置如下参数：</font></p> 
<pre><code class="prism language-bash">-bframes <span class="token punctuation">{<!-- --></span>+2<span class="token punctuation">}</span> --deblock <span class="token number">1</span>:1 --psy-rd <span class="token number">0.4</span>:<span class="token operator">&lt;</span>unset<span class="token operator">&gt;</span> --aq-strength <span class="token number">0.6</span> --ref <span class="token punctuation">{<!-- --></span>Double <span class="token keyword">if</span> <span class="token operator">&gt;</span><span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">1</span><span class="token punctuation">}</span>
</code></pre> 
<p><font face="Courier New">    <code>·grain</code><br>     除默认参数配置之外，还需要设置如下参数：</font></p> 
<pre><code class="prism language-bash">-aq-strength <span class="token number">0.5</span> --no-dct-decimate --deadzone-inter <span class="token number">6</span> --deadzone-intra <span class="token number">6</span> --deblock -2:-2 --ipratio <span class="token number">1.1</span> --pbratio <span class="token number">1.1</span> --psy-rd <span class="token operator">&lt;</span>unset<span class="token operator">&gt;</span>:0.25 --qcomp <span class="token number">0.8</span>
</code></pre> 
<p><font face="Courier New">    <code>·stillimage</code><br>     除默认参数配置之外，还需要设置如下参数：</font></p> 
<pre><code class="prism language-bash">-aq-strength <span class="token number">1.2</span> --deblock -3:-3 --psy-rd <span class="token number">2.0</span>:0.7
</code></pre> 
<p><font face="Courier New">    <code>·psnr</code><br>     除默认参数配置之外，还需要设置如下参数：</font></p> 
<pre><code class="prism language-bash">-aq-mode <span class="token number">0</span> --no-psy
</code></pre> 
<p><font face="Courier New">    <code>·ssim</code><br>     除默认参数配置之外，还需要设置如下参数：</font></p> 
<pre><code class="prism language-bash">-aq-mode <span class="token number">2</span> --no-psy
</code></pre> 
<p><font face="Courier New">    <code>·fastdecode</code><br>     除默认参数配置之外，还需要设置如下参数：</font></p> 
<pre><code class="prism language-bash">-no-cabac --no-deblock --no-weightb --weightp <span class="token number">0</span>
</code></pre> 
<p><font face="Courier New">    <code>·zerolatency</code><br>     除默认参数配置之外，还需要设置如下参数：</font></p> 
<pre><code class="prism language-bash">-bframes <span class="token number">0</span> --force-cfr --no-mbtree --sync-lookahead <span class="token number">0</span> --sliced-threads --rc-lookahead <span class="token number">0</span>
</code></pre> 
<p><font face="Courier New">    <mark>在使用FFmpeg与x264进行H.264直播编码并进行推流时，只用tune参数的zerolatency将会提升效率，因为其降低了因编码导致的延迟</mark>。</font></p> 
<h5><a id="font_face_size2_nbspnbsp_3H264profilelevelfont_172"></a><font face="楷体" size="2">    3.H.264的profile与level设置</font></h5> 
<p><font face="Courier New">    这里的<code>profile（档次）与level（等级）</code>的设置与H.264标准文档ISO-14496-Part10中描述的profile、level的信息基本相同，<mark>x264编码器支持Baseline、Extented、Main、High、High10、High422、High444共7种profile参数设置</mark>，根据profile的不同，编码出来的视频的很多参数也有所不同，具体的情况可以参考下表。</font><br> <img src="https://images2.imgbox.com/70/1a/n9RxQJPZ_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    level设置则与标准的ISO-14496-Part10参考中的Annex A中描述的表格完全相同，见表</font><br> <img src="https://images2.imgbox.com/25/9b/7m2EAzbz_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    下面使用baseline profile编码一个H.264视频，然后使用high profile编码一个H.264视频，分析两类不同profile编码出来的视频的区别，从表所示的profile参数中可以看到，<code>使用baseline profile编码的H.264视频不会包含B Slice，而使用main profile、high profile编码出来的视频，均可以包含B Slice</code>，下面就来着重查看baseline与high两种不同profile编码出来的视频是否包含B Slice。<br>     首先使用FFmpeg编码生成baseline与high两种profile的视频：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -vcodec libx264 -profile:v baseline -level <span class="token number">3.1</span> -s 352x288 -an -y -t <span class="token number">10</span> output_baseline.ts
ffmpeg -i input.mp4 -vcodec libx264 -profile:v high -level <span class="token number">3.1</span> -s 352x288 -an -y -t <span class="token number">10</span> output_high.ts
</code></pre> 
<p><font face="Courier New">    从以上的输出结果可以看到共执行了两次ffmpeg，分别生成output_baseline.ts与output_high.ts两个文件。前面章节中提到过使用ffprobe可以查看到每一帧具体是I帧、P帧还是B帧，下面使用ffprobe查看这两个文件中包含B帧的情况：</font></p> 
<pre><code class="prism language-bash">ffprobe -v quiet -show_frames -select_streams <span class="token function">v</span> output_baseline.ts <span class="token operator">|</span><span class="token function">grep</span> <span class="token string">"pict_type=B"</span><span class="token operator">|</span><span class="token function">wc</span> -1
<span class="token number">0</span>
ffprobe -v quiet -show_frames -select_streams <span class="token function">v</span> output_high.ts <span class="token operator">|</span><span class="token function">grep</span> <span class="token string">"pict_type=B"</span><span class="token operator">|</span><span class="token function">wc</span> -l
<span class="token number">194</span>
</code></pre> 
<p><font face="Courier New">    从输出的结果中可以看到，baseline profile中包含了0个B帧，而high profile的视频中包含了194个B帧。<mark>当进行实时流媒体直播时，采用baseline编码相对main或high的profile会更可靠些</mark>；但适当地加入B帧能够有效地降低码率，所以应根据需要与具体的业务场景进行选择。</font></p> 
<h5><a id="font_face_size2_nbspnbsp_4sc_thresholdfont_191"></a><font face="楷体" size="2">    4.控制场景切换关键帧插入参数sc_threshold</font></h5> 
<p><font face="Courier New">    在FFmpeg中，通过命令行的<code>-g参数设置以帧数间隔为GOP的长度</code>，但是当遇到场景切换时，<code>例如从一个画面突然变成另外一个画面时，会强行插入一个关键帧，这时GOP的间隔将会重新开始</code>，这样的场景切换在点播视频文件中会频频遇到，如果将点播文件进行M3U8切片，或者将点播文件进行串流虚拟直播时，GOP的间隔也会出现相同的情况，为了避免这种情况的产生，可以通过使用<code>sc_threshold参数进行设定以决定是否在场景切换时插入关键帧</code>。<br>     下面执行ffmpeg命令控制编码时的GOP大小，生成MP4之后使用Elecard StreamEye观察GOP的情况：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -c:v libx264 -g <span class="token number">50</span> -t <span class="token number">60</span> output.mp4
</code></pre> 
<p><font face="Courier New">    根据这条命令可以看出，每50帧被设置为一个GOP间隔，生成60秒的MP4视频，接下来查看一下GOP的情况，如图所示。</font><br> <img src="https://images2.imgbox.com/2a/ee/55w0f2fc_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    从图4-2中可以看出，其中有一段GOP的间距比较短，这是因为强行插入了GOP而导致的，这个情形插入的GOP是由于场景切换导致的GOP插入。为了使得GOP的插入更加均匀，使用参数sc_threshold即可，下面来看一下效果：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -c:v libx264 -g <span class="token number">50</span> -sc_threshold <span class="token number">0</span> -t <span class="token number">60</span> -y output.mp4
</code></pre> 
<p><font face="Courier New">    执行完这条命令行之后，GOP间隔被设置为50帧，并且场景切换时不插入关键帧，执行完之后生成的MP4效果如图所示，<code>GOP非常均匀，均为50帧一个GOP，场景切换时并没有强行插入GOP，这样做有一个好处，那就是可以控制关键帧，在进行视频切片时将会更加方便</code>，如下图所示。</font><br> <img src="https://images2.imgbox.com/5c/b3/RF9DiESP_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="font_face_size2_nbspnbsp_5x264x264optsfont_205"></a><font face="楷体" size="2">    5.设置x264内部参数x264opts</font></h5> 
<p><font face="Courier New">    由于FFmpeg设置x264参数时增加的参数比较多，所以FFmpeg开放了x264opts，可以通过<mark>这个参数设置x264内部私有参数，如设置I帧、P帧、B帧的顺序及规律等</mark>，通过x264opts可以设置x264内部的很多参数。下面举个例子，控制I帧、P帧、B帧的顺序及出现频率，首先分析一下设置的GOP参数，如果视频GOP设置为50帧，那么如果在这50帧中不希望出现B帧，则客户只需要将x264参数bframes设置为0即可：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -c:v libx264 -x264opts <span class="token string">"bframes=0"</span> -g <span class="token number">50</span> -sc_threshold <span class="token number">0</span>  output.mp4
</code></pre> 
<p><font face="Courier New">    命令行执行完毕后，使用Elecard StreamEye查看帧的信息，结果如图所示。<br> <img src="https://images2.imgbox.com/e2/16/5H6VaAXz_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    从图中可以看出，output.mp4中<mark>H.264的帧排列中并不包含B帧，全部为P帧与I帧</mark>。<br>     <code>如果希望控制I帧、P帧、B帧的频率与规律，可以通过控制GOP中B帧的帧数来实现，P帧的频率可以通过x264的参数b-adapt进行设置</code>。<br>     例如设置GOP中，每2个P帧之间存放3个B帧：</font></font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -c:v libx264 -x264opts <span class="token string">"bframes=3:b-adapt=0"</span> -g <span class="token number">50</span> -sc_threshold <span class="token number">0</span> output.mp4
</code></pre> 
<p><font face="Courier New">    命令行执行完之后，使用Elecard StreamEye查看帧信息，如图所示。<br> <img src="https://images2.imgbox.com/35/c9/lWBGDzMS_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    <mark>视频中的B帧越多，同等码率时的清晰度将会越高</mark>，但是B帧越多，编码与解码所带来的复杂度也就越高，所以合理地使用B帧非常重要，尤其是在进行清晰度与码率衡量时。</font></font></p> 
<h5><a id="font_face_size2_nbspnbsp_6CBRnalhrdfont_221"></a><font face="楷体" size="2">    6.CBR恒定码率设置参数nal-hrd</font></h5> 
<p><font face="Courier New">    从前面对x264参数的介绍中可以看出，编码能够设置VBR、CBR的编码模式，<mark>VBR为可变码率，CBR为恒定码率</mark>。但CBR依然存在；下面就来介绍一下CBR码率视频的制作。FFmpeg是通过参数-b:v来指定视频的编码码率的，但是设定的码率是平均码率，并不能够很好地控制最大码率及最小码率的波动，如果需要控制最大码率和最小码率以控制码率的波动，则需要使用FFmpeg的<mark>三个参数-b:v、maxrate、minrate</mark>：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -c:v libx264 -x264opts <span class="token string">"bframes=10:b-adapt=0"</span> -b:v 1000k -maxrate 1000k -minrate 1000k -bufsize 50k -nal-hrd cbr -g <span class="token number">50</span> -sc_threshold <span class="token number">0</span> output.ts
</code></pre> 
<p><font face="Courier New">    下面就来分析一下这条命令行，具体如下。<br>     <code>·设置B帧的个数，并且是每两个P帧之间包含10个B帧</code><br>     <code>·设置视频码率为1000kbit/s</code><br>     <code>·设置最大码率为1000kbit/s</code><br>     <code>·设置最小码率为1000kbit/s</code><br>     <code>·设置编码的buffer大小为50KB</code><br>     <code>·设置H.264的编码HRD信号形式为CBR</code><br>     <code>·设置每50帧一个GOP</code><br>     <code>·设置场景切换不强行插入关键帧</code><br>     根据上述参数设置之后生成的output.ts文件，使用Bitrate Viewer观察其码率波动效果，结果如图所示。</font><br> <img src="https://images2.imgbox.com/9d/fa/dLhNI6mE_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    从图中可以看到码率波动为最小996kbit/s，最大码率为11551kbit/s，码率得到了控制。<br>     接下来使用Elecard StreamEye查看一下视频流信息，如图所示。</font><br> <img src="https://images2.imgbox.com/0c/2d/7uDsvFAW_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    在FFmpeg中进行H.265编码时，可以采用x265进行编码，H.265编码参数与x264的编码参数相差不多，基本可以通用。</font></p> 
<h3><a id="nbspnbspfont_face_size342_FFmpegfont_241"></a>  <font face="黑体" size="3">4.2 FFmpeg硬编解码</font></h3> 
<p><font face="Courier New">    当使用FFmpeg进行软编码时，常见的基于CPU进行H.264或H.265编码其相对成本会比较高，会考虑采用硬编码，<mark>常见的硬编码包含Nvidia GPU与Intel QSV两种</mark>，还有<mark>常见的嵌入式平台，如树莓派、瑞芯微等</mark>，本节将重点介绍常见的Nvidia与Intel硬编码，以及树莓派的硬编码。</font></p> 
<h4><a id="font_face_size3nbspnbsp421_Nvidia_GPUfont_243"></a><font face="黑体" size="3">  4.2.1 Nvidia GPU硬编解码</font></h4> 
<p><font face="Courier New">    在计算机的显卡生产厂商里，最常见的就是Nvidia了，Nvidia在图像处理技术方面非常强悍FFmpeg集成Nvidia显卡视频处理模块后，使用FFmpeg能够将Nvidia的视频编解码功能快速使用起来，下面就来了解一下Nvidia在FFmpeg中支持的操作参数。</font></p> 
<h5><a id="font_face_size2_nbspnbsp_1Nvidiafont_245"></a><font face="楷体" size="2">    1.Nvidia硬编码参数</font></h5> 
<p><font face="Courier New">    使用Nvidia GPU编码之前，首先需要了解在FFmpeg中对于Nvidia的GPU编码均支持哪些参数，可以通过<mark>ffmpeg -h encoder=h264_nvenc</mark>进行查看。Nvidia硬编码参数见表。</font><br> <img src="https://images2.imgbox.com/fe/6c/y0L9Ttv8_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    从表所示的参数列表中可以看到，编码的参数例如preset参数、profile参数、level参数、场景切换参数等。下面就来针对常用的主要参数进行举例。</font></p> 
<h5><a id="font_face_size2_nbspnbsp_2Nvidiafont_249"></a><font face="楷体" size="2">    2.Nvidia硬编解码参数使用举例</font></h5> 
<p><font face="Courier New">    在使用Nvidia进行编解码时，可以使用<code>ffmpeg -h encoder=h264_nvenc</code>查看FFmpeg中Nvidia做H.264编码时的参数支持，使用<code>ffmpeg -h decoder=h264_cuvid</code>查看FFmpeg中Nvidia做H.264解码时的参数支持。在做H.264编码时，首先需要确认nvenc支持的像素格式：</font></p> 
<pre><code class="prism language-bash">Encoder h264_nvenc <span class="token punctuation">[</span>NVIDIA NVENC H.264 encoder<span class="token punctuation">]</span>:
    General capabilities: dr1 delay hardware
    Threading capabilities: none
    Supported hardware devices: cuda cuda d3d11va d3d11va
    Supported pixel formats: yuv420p nv12 p010le yuv444p p016le yuv444p16le bgr0 bgra rgb0 rgba x2rgb10le x2bgr10le gbrp gbrp16le cuda d3d11
</code></pre> 
<p><font face="Courier New">    如h264_nvenc基本信息所示，使用nvenc进行H.264编码时所支持的像素格式为<mark>yuv420p、nv12、p010le、yuv444p、yuv444p16le、rgb0、cuda</mark>。<br>     而在做H.264解码时，需要查看cuvid所支持的解码像素格式：</font></p> 
<pre><code class="prism language-bash">Decoder h264_cuvid <span class="token punctuation">[</span>Nvidia CUVID H264 decoder<span class="token punctuation">]</span>:
    General capabilities: delay avoidprobe hardware
    Threading capabilities: none
    Supported hardware devices: cuda
    Supported pixel formats: cuda nv12 p010le p016le
h264_cuvid AVOptions:
</code></pre> 
<p><font face="Courier New">    如h264_cuvid基本信息所示，<mark>使用cuvid解码H.264时所支持的像素格式为cuda、nv12</mark>。了解清楚了所支持的像素格式之后，接下来列举一个硬编码与硬解码的例子：</font></p> 
<pre><code class="prism language-bash">ffmpeg -hwaccel cuvid -vcodec h264_cuvid -i input.mp4 -vf <span class="token assign-left variable">scale_npp</span><span class="token operator">=</span><span class="token number">1920</span>:1080 -vcodec h264_nvenc -acodec copy -f mp4 -y output.mp4
</code></pre> 
<p><font face="Courier New">    命令行执行完毕之后，会将input.mp4的视频像素改变为1920×1080，将码率改变为2000kbit/s，输出为output.mp4。下面就来看一下转码时的效果：</font></p> 
<pre><code class="prism language-bash"></code></pre> 
<p><font face="Courier New">    如上述的输出信息所示，使用的是cuvid硬解码与nvenc硬编码，将视频从4K视频降低为1080p，同时将码率从35Mbit/s降低至2Mbit/s，效率刚刚好能够支撑转码处理。而在普通的PC机中，如果不这样使用硬编解码处理，效率将会极为低下。下面就来看一下使用硬转码时的CPU使用情况，如图4-8所示。<br>     从图4-8中可以看到，使用硬转码4K视频至1080p视频时，CPU的使用效率可以控制在10%之内，而在使用软转码时，CPU的占用率将远远高于100%。</font></p> 
<h4><a id="font_face_size3nbspnbsp422_Intel_QSVfont_277"></a><font face="黑体" size="3">  4.2.2 Intel QSV硬编码</font></h4> 
<p><font face="Courier New">    硬编解码除了可以使用Nvidia的GPU之外，Intel的QSV也是一种不错的方案，FFmpeg对于Intel的QSV支持相对也比较灵活，<mark>如果希望使用FFmpeg的Intel QSV编码，则需要在编译FFmpeg时开启QSV支持：</mark></font></p> 
<pre><code class="prism language-bash">ffmpeg -hide_banner -codecs<span class="token operator">|</span><span class="token function">grep</span> h264
</code></pre> 
<p><font face="Courier New">    命令行执行后的输出内容如下：</font></p> 
<pre><code class="prism language-bash"> DEV.LS h264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part <span class="token number">10</span> <span class="token punctuation">(</span>encoders: libx264 libx264rgb <span class="token punctuation">)</span>
</code></pre> 
<p><font face="Courier New">    如上述输出信息所示，FFmpeg通过<code>--enable-libmfx开启对Intel QSV的支持</code>；FFmpeg项目中已经支持了H.264、H.265的硬解码、硬编码，下面就来看一下H.264和H.265的参数相关的支持与操作。</font></p> 
<h5><a id="font_face_size2_nbspnbsp_1Intel_QSV_H264font_287"></a><font face="楷体" size="2">    1.Intel QSV H.264参数说明</font></h5> 
<p><font face="Courier New">    在使用Intel QSV编码之前，首先查看一下FFmpeg支持Intel Media SDK QSV的参数，执行命令行<code>ffmpeg -h encoder=h264_qsv</code>可以得到QSV参数信息，具体见表4-5。</font><br> <img src="https://images2.imgbox.com/ef/d8/IJzk1j8F_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    从表中可以看出，硬件编码所支持的参数虽然比libx264软编码的参数设置稍微少一些，但是基本上也可以实现常见的功能，下面列举几个硬转码的例子，来对比一下其与软编码的区别。</font></p> 
<h5><a id="font_face_size2_nbspnbsp_2Intel_QSV_H264font_291"></a><font face="楷体" size="2">    2.Intel QSV H.264使用举例</font></h5> 
<p><font face="Courier New">    因为是使用硬件的codec，因此可以考虑解码时使用硬件解码，编码时使用硬件编码，通过<code>ffmpeg -h encoder=h264与ffmpeg -h decoder=h264查看h264_qsv硬件参数信息时可以看到</code>，<mark>h264_qsv只支持nv12与qsv的像素格式，所以在使用yuv420p时需要将其转换成nv12才可以</mark>，FFmpeg已经可以自动进行该操作的转换，下面看一下硬转码的例子：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i 10M1080P.mp4 -pix_fmt nv12 -vcodec h264_qsv -an -y output.mp4
</code></pre> 
<p><font face="Courier New">    命令行执行之后，FFmpeg将会使用h264_qsv进行解码与编码，转码速度如下所示：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, mov,mp4,m4a,3gp,3g2,mj2, from 'input.mp4':</span>
  Metadata:
    major_brand     <span class="token builtin class-name">:</span> isom
    minor_version   <span class="token builtin class-name">:</span> <span class="token number">512</span>
    compatible_brands: isomiso2avc1mp41
    encoder         <span class="token builtin class-name">:</span> Lavf59.27.100
  Duration: 00:00:35.07, start: <span class="token number">0.000000</span>, bitrate: <span class="token number">2661</span> kb/s
  Stream <span class="token comment">#0:0[0x1](und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(tv, bt709, progressive), 1920x1080 [SAR 1:1 DAR 16:9], 2493 kb/s, 30 fps, 30 tbr, 15360 tbn (default)</span>
    Metadata:
      handler_name    <span class="token builtin class-name">:</span> VideoHandler
      vendor_id       <span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
  Stream <span class="token comment">#0:1[0x2](und): Audio: aac (LC) (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 159 kb/s (default)</span>
    Metadata:
      handler_name    <span class="token builtin class-name">:</span> SoundHandler
      vendor_id       <span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
Stream mapping:
  Stream <span class="token comment">#0:0 -&gt; #0:0 (h264 (native) -&gt; h264 (h264_qsv))</span>
Press <span class="token punctuation">[</span>q<span class="token punctuation">]</span> to stop, <span class="token punctuation">[</span>?<span class="token punctuation">]</span> <span class="token keyword">for</span> <span class="token builtin class-name">help</span>
Output <span class="token comment">#0, mp4, to 'output.mp4':</span>
  Metadata:
    major_brand     <span class="token builtin class-name">:</span> isom
    minor_version   <span class="token builtin class-name">:</span> <span class="token number">512</span>
    compatible_brands: isomiso2avc1mp41
    encoder         <span class="token builtin class-name">:</span> Lavf59.34.102
  Stream <span class="token comment">#0:0(und): Video: h264 (avc1 / 0x31637661), nv12(tv, bt709, progressive), 1920x1080 [SAR 1:1 DAR 16:9], q=2-31, 1000 kb/s, 30 fps, 15360 tbn (default)</span>
    Metadata:
      handler_name    <span class="token builtin class-name">:</span> VideoHandler
      vendor_id       <span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
      encoder         <span class="token builtin class-name">:</span> Lavc59.54.100 h264_qsv
    Side data:
      cpb: bitrate max/min/avg: <span class="token number">0</span>/0/1000000 buffer size: <span class="token number">0</span> vbv_delay: N/A
<span class="token assign-left variable">frame</span><span class="token operator">=</span> <span class="token number">1052</span> <span class="token assign-left variable">fps</span><span class="token operator">=</span><span class="token number">141</span> <span class="token assign-left variable">q</span><span class="token operator">=</span><span class="token number">26.0</span> <span class="token assign-left variable">Lsize</span><span class="token operator">=</span>    4190kB <span class="token assign-left variable">time</span><span class="token operator">=</span>00:00:35.00 <span class="token assign-left variable">bitrate</span><span class="token operator">=</span> <span class="token number">980</span>.8kbits/s <span class="token assign-left variable">speed</span><span class="token operator">=</span><span class="token number">4</span>.69x
video:4179kB audio:0kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: <span class="token number">0.277420</span>%
</code></pre> 
<p><font face="Courier New">    如上述的输出内容所示，FFmpeg采用的是Intel QSV进行H.264转码，将1080p/2.6M的H.264的视频转换为1080p/1M的视频输出，转码速度4.69倍速，如果<mark>只使用libx264做软编码时速度并不会有这么快。h264_qsv编码采用的是Intel的GPU编码，对CPU资源也相对更加节省一些</mark>。</font></p> 
<h5><a id="font_face_size2_nbspnbsp_3Intel_QSV_H265font_333"></a><font face="楷体" size="2">    3.Intel QSV H.265参数说明</font></h5> 
<p><font face="Courier New">    FFmpeg中的Intel QSV H.265（HEVC）的参数与Intel QSV H.264的参数类似，但是FFmpeg另外还支持指定使用软编码还是硬编码的参数。Intel QSV H.265编码参数见表。</font><br> <img src="https://images2.imgbox.com/64/c4/XulQzI61_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="font_face_size2_nbspnbsp_4Intel_QSV_H265font_336"></a><font face="楷体" size="2">    4.Intel QSV H.265使用举例</font></h5> 
<p><font face="Courier New">    在使用Intel进行高清编码时，使用AVC编码之后观察码率会比较高，但是使用H.265（HEVC）则能更好地降低同样清晰度的码率，下面举例说明：</font></p> 
<pre><code class="prism language-bash">ffmpeg -hide_banner -y -hwaccel qsv -i 10M1080P.mp4 -an -c:v hevc_qsv -load_plugin hevc_hw -b:v 5M -maxrate 5M out.mp4
</code></pre> 
<p><font face="Courier New">    命令行执行之后，<code>FFmpeg会将1080p的高清视频转换为H.265视频</code>，<mark>使用CPU进行1080p的H.265编码时速度相对会比较慢，而使用Intel QSV进行编码时，效率则会稍微高一些</mark>，效果如下：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, mov,mp4,m4a,3gp,3g2,mj2, from 'H264_1080P_8M_29.97fps.mp4</span>
        major_brand     <span class="token builtin class-name">:</span> isom
        minor_version   <span class="token builtin class-name">:</span> <span class="token number">512</span>
        compatible_brands: isomiso2avc1mp41
        creation_time   <span class="token builtin class-name">:</span> <span class="token number">1970</span>-01-01T00:00:00.000000Z
        encoder         <span class="token builtin class-name">:</span> Lavf53.6.0
    Duration: 00:01:00.29, start: <span class="token number">0.000000</span>, bitrate: <span class="token number">8044</span> kb/s
</code></pre> 
<p><font face="Courier New">    至此，FFmpeg支持的Intel QSV硬编解码已全部介绍完毕。</font></p> 
<h4><a id="font_face_size3nbspnbsp423_font_352"></a><font face="黑体" size="3">  4.2.3 树莓派硬编码</font></h4> 
<p><font face="Courier New">    下面就来看一下硬编码所支持的配置：</font></p> 
<pre><code class="prism language-bash">ffmpeg version <span class="token number">2022</span>-11-23-git-c8e9cc8d20-full_build-www.gyan.dev Copyright <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token number">2000</span>-2022 the FFmpeg developers
    built with gcc <span class="token number">12.1</span>.0 <span class="token punctuation">(</span>Rev2, Built by MSYS2 project<span class="token punctuation">)</span>
    configuration: —enable-omx-rpi
    libavutil      <span class="token number">55</span>. <span class="token number">58.100</span> / <span class="token number">55</span>. <span class="token number">58.100</span>
    libavcodec     <span class="token number">57</span>. <span class="token number">89.100</span> / <span class="token number">57</span>. <span class="token number">89.100</span>
    libavformat    <span class="token number">57</span>. <span class="token number">71.100</span> / <span class="token number">57</span>. <span class="token number">71.100</span>
    libavdevice    <span class="token number">57</span>.  <span class="token number">6.100</span> / <span class="token number">57</span>.  <span class="token number">6.100</span>
    libavfilter     <span class="token number">6</span>. <span class="token number">82.100</span> /  <span class="token number">6</span>. <span class="token number">82.100</span>
    libswscale      <span class="token number">4</span>.  <span class="token number">6.100</span> /  <span class="token number">4</span>.  <span class="token number">6.100</span>
    libswresample   <span class="token number">2</span>.  <span class="token number">7.100</span> /  <span class="token number">2</span>.  <span class="token number">7.100</span>
V…<span class="token punctuation">..</span> h264_omx             OpenMAX IL H.264 video encoder <span class="token punctuation">(</span>codec h264<span class="token punctuation">)</span>
</code></pre> 
<p><font face="Courier New">    在FFmpeg下面支持树莓派的H.264编码采用的是OpenMAX框架，在编译FFmpeg工程之前配置编译时，需要使用<code>--enable-omx-pi</code>支持，下面来看一下具体的参数说明。</font></p> 
<h5><a id="font_face_size2_nbspnbsp_1h264_omxfont_368"></a><font face="楷体" size="2">    1.h264_omx参数说明</font></h5> 
<p><font face="Courier New">    在树莓派中使用的是h264_omx进行编码，ffmpeg对于树莓派的h264_omx编码参数可以通过<code>ffmpeg -h encoder=h264_omx</code>获得，具体参数见表。</font><br> <img src="https://images2.imgbox.com/92/64/xNKAhu5O_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    从表中可以看出，目前一共有三个参数可用，<mark>omx_libname与omx_libprefix均是运行ffmpeg时加载omx所使用的参数，zerocopy则用于提升编码时的性能</mark>。</font></p> 
<h3><a id="nbspnbspfont_face_size343_FFmpegMP3font_372"></a>  <font face="黑体" size="3">4.3 FFmpeg输出MP3</font></h3> 
<p><font face="Courier New">    使用FFmpeg可以解码MP3，同样FFmpeg也可以支持MP3编码，FFmpeg使用第三方库libmp3lame即可编码MP3格式。不但如此，MP3编码还是低延迟的编码，<mark>可以支持的采样率比较多</mark>，包含44100、48000、32000、22050、24000、16000、11025、12000、8000多种采样率，<mark>采样格式也比较多</mark>，包含s32p（signed32bits，planar）、fltp（float，planar）、s16p（signed16bits，planar）多种格式，<mark>声道布局方式支持包含mono（单声道模式）、stereo（环绕立体声模式）</mark>，下面就来详细介绍MP3编码参数。</font></p> 
<h4><a id="font_face_size3nbspnbsp431_MP3font_374"></a><font face="黑体" size="3">  4.3.1 MP3编码参数介绍</font></h4> 
<p><font face="Courier New">    查看FFmpeg对于MP3的参数支持，可以通过<code>ffmpeg -h encoder=libmp3lame</code>得到MP3的参数，见表。</font><br> <img src="https://images2.imgbox.com/ad/97/eS39J8AS_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    从表中可以看到，FFmpeg对MP3编码操作相关的参数包含了主要的控制参数，更高级的参数控制，尚未全部从lame中移植到FFmpeg中，还有待开发完善。下面就来介绍FFmpeg中重点支持的这些参数的使用及基本原理。</font></p> 
<h4><a id="font_face_size3nbspnbsp432_MP3font_378"></a><font face="黑体" size="3">  4.3.2 MP3的编码质量设置</font></h4> 
<p><font face="Courier New">    在FFmpeg中进行MP3编码采用的是第三方库libmp3lame，所以进行MP3编码时，需要设置编码参数acodec为libmp3lame，命令行如下：</font></p> 
<pre><code class="prism language-bash">ffmpeg –i INPUT –acodec libmp3lame OUTPUT.mp3
</code></pre> 
<p><font face="Courier New">    根据上面的命令行可以<code>得到音频编码为MP3封装文件</code>。<br>     MP3编码的码率得到控制之后，控制质量时需要通过<code>-qscale:a</code>进行控制，也可以使用上表中的q参数进行控制，质量不同码率也不同，详情可以参考表。</font><br> <img src="https://images2.imgbox.com/cb/1d/hVDUj3LA_o.png" alt="在这里插入图片描述"><br> <font face="Courier New">    表可以作为参考，如果遇到将低码率转换为高码率的情况，则并不一定会很符合上述参数，但在大多数情况下是符合的，下面举例说明：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp3 -acodec libmp3lame -q:a <span class="token number">8</span> output.mp3
</code></pre> 
<p><font face="Courier New">    执行完上面这条命令行之后，将生成的output.mp3的码率区间设置在70kbit/s至105kbit/s之间，下面将转码前的input.mp3与转码后的output.mp3做一个比较：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, mp3, from 'input.mp3':</span>
  Duration: 00:03:50.64, start: <span class="token number">0.000000</span>, bitrate: <span class="token number">128</span> kb/s
  Stream <span class="token comment">#0:0: Audio: mp3, 44100 Hz, stereo, fltp, 128 kb/s</span>
Stream mapping:
  Stream <span class="token comment">#0:0 -&gt; #0:0 (mp3 (mp3float) -&gt; mp3 (libmp3lame))</span>
Press <span class="token punctuation">[</span>q<span class="token punctuation">]</span> to stop, <span class="token punctuation">[</span>?<span class="token punctuation">]</span> <span class="token keyword">for</span> <span class="token builtin class-name">help</span>
Output <span class="token comment">#0, mp3, to 'output.mp3':</span>
  Metadata:
    TSSE            <span class="token builtin class-name">:</span> Lavf59.34.102
  Stream <span class="token comment">#0:0: Audio: mp3, 44100 Hz, stereo, fltp</span>
    Metadata:
      encoder         <span class="token builtin class-name">:</span> Lavc59.54.100 libmp3lame
<span class="token assign-left variable">size</span><span class="token operator">=</span>    2560kB <span class="token assign-left variable">time</span><span class="token operator">=</span>00:03:50.61 <span class="token assign-left variable">bitrate</span><span class="token operator">=</span>  <span class="token number">90</span>.9kbits/s <span class="token assign-left variable">speed</span><span class="token operator">=</span><span class="token number">86</span>.4x
video:0kB audio:2560kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: <span class="token number">0.009653</span>%
</code></pre> 
<p><font face="Courier New">    从以上代码可以看到，转码前的input.mp3的码率为128kbit/s，转码后的output.mp3的码率为91kbit/s。在转码过程中，从FFmpeg的输出过程信息中可以看到编码时的码率在不断地发生变动：</font></p> 
<pre><code class="prism language-bash"><span class="token assign-left variable">size</span><span class="token operator">=</span>    2560kB <span class="token assign-left variable">time</span><span class="token operator">=</span>00:03:50.61 <span class="token assign-left variable">bitrate</span><span class="token operator">=</span>  <span class="token number">90</span>.9kbits/s <span class="token assign-left variable">speed</span><span class="token operator">=</span><span class="token number">86</span>.4x
</code></pre> 
<p><font face="Courier New">    以上码率设置方式为<mark>VBR码率，常见的MP3编码设置为CBR</mark>，通过FFmpeg参数-b即可设置，在FFmpeg编码过程中，码率几乎不会波动：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp3 -acodec libmp3lame -b:a 64k output.mp3
</code></pre> 
<p><font face="Courier New">    执行完上述命令行之后，结果将会生成编码为MP3的音频。<br>     对比转码前与转码后的两个MP3文件：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, mp3, from 'input.mp3':</span>
  Duration: 00:03:50.64, start: <span class="token number">0.000000</span>, bitrate: <span class="token number">128</span> kb/s
  Stream <span class="token comment">#0:0: Audio: mp3, 44100 Hz, stereo, fltp, 128 kb/s</span>
Stream mapping:
  Stream <span class="token comment">#0:0 -&gt; #0:0 (mp3 (mp3float) -&gt; mp3 (libmp3lame))</span>
Press <span class="token punctuation">[</span>q<span class="token punctuation">]</span> to stop, <span class="token punctuation">[</span>?<span class="token punctuation">]</span> <span class="token keyword">for</span> <span class="token builtin class-name">help</span>
Output <span class="token comment">#0, mp3, to 'output.mp3':</span>
  Metadata:
    TSSE            <span class="token builtin class-name">:</span> Lavf59.34.102
  Stream <span class="token comment">#0:0: Audio: mp3, 44100 Hz, stereo, fltp, 64 kb/s</span>
    Metadata:
      encoder         <span class="token builtin class-name">:</span> Lavc59.54.100 libmp3lame
<span class="token assign-left variable">size</span><span class="token operator">=</span>    1802kB <span class="token assign-left variable">time</span><span class="token operator">=</span>00:03:50.61 <span class="token assign-left variable">bitrate</span><span class="token operator">=</span>  <span class="token number">64</span>.0kbits/s <span class="token assign-left variable">speed</span><span class="token operator">=</span><span class="token number">65</span>.9x
video:0kB audio:1802kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: <span class="token number">0.013711</span>%
</code></pre> 
<p><font face="Courier New">    两个文件均为<code>CBR编码方式编码的MP3</code>，并且可以看到编码过程中码率几乎没有波动：</font></p> 
<pre><code class="prism language-bash"><span class="token assign-left variable">size</span><span class="token operator">=</span>    1802kB <span class="token assign-left variable">time</span><span class="token operator">=</span>00:03:50.61 <span class="token assign-left variable">bitrate</span><span class="token operator">=</span>  <span class="token number">64</span>.0kbits/s <span class="token assign-left variable">speed</span><span class="token operator">=</span><span class="token number">65</span>.9x
</code></pre> 
<h4><a id="font_face_size3nbspnbsp433_ABRfont_437"></a><font face="黑体" size="3">  4.3.3 平均码率编码参数ABR</font></h4> 
<p><font face="Courier New">    ABR是VBR与CBR的混合产物，表示平均码率编码，<code>使用ABR参数之后，编码速度将会比VBR高，但是质量会比VBR的编码稍逊一些，比CBR编码好一些</code>，在FFmpeg中可使用参数-abr来控制MP3编码为ABR编码方式：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp3 –acodec libmp3lame -b:a 64k -abr <span class="token number">1</span> output.mp3
</code></pre> 
<p><font face="Courier New">    执行上面这条命令之后，编码之后的输出信息如下：</font></p> 
<pre><code class="prism language-bash"></code></pre> 
<p><font face="Courier New">    原本为64kbit/s码率的CBR编码方式的MP3音频，因为设置abr参数之后，成为ABR编码方式的MP3音频，可以观察编码过程中的输出内容：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, mp3, from 'input.mp3':</span>
  Duration: 00:03:50.64, start: <span class="token number">0.000000</span>, bitrate: <span class="token number">128</span> kb/s
  Stream <span class="token comment">#0:0: Audio: mp3, 44100 Hz, stereo, fltp, 128 kb/s</span>
Stream mapping:
  Stream <span class="token comment">#0:0 -&gt; #0:0 (mp3 (mp3float) -&gt; mp3 (libmp3lame))</span>
Press <span class="token punctuation">[</span>q<span class="token punctuation">]</span> to stop, <span class="token punctuation">[</span>?<span class="token punctuation">]</span> <span class="token keyword">for</span> <span class="token builtin class-name">help</span>
Output <span class="token comment">#0, mp3, to 'output.mp3':</span>
  Metadata:
    TSSE            <span class="token builtin class-name">:</span> Lavf59.34.102
  Stream <span class="token comment">#0:0: Audio: mp3, 44100 Hz, stereo, fltp, 64 kb/s</span>
    Metadata:
      encoder         <span class="token builtin class-name">:</span> Lavc59.54.100 libmp3lame
<span class="token assign-left variable">size</span><span class="token operator">=</span>    1858kB <span class="token assign-left variable">time</span><span class="token operator">=</span>00:03:50.61 <span class="token assign-left variable">bitrate</span><span class="token operator">=</span>  <span class="token number">66</span>.0kbits/s <span class="token assign-left variable">speed</span><span class="token operator">=</span><span class="token number">64</span>.6x
video:0kB audio:1858kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: <span class="token number">0.013297</span>%
</code></pre> 
<p><font face="Courier New">    看似VBR，其实为ABR。</font></p> 
<h3><a id="nbspnbspfont_face_size344_FFmpegAACfont_463"></a>  <font face="黑体" size="3">4.4 FFmpeg输出AAC</font></h3> 
<p><font face="Courier New">    在音视频流中，无论直播与点播，<mark>AAC都是目前最常用的一种音频编码格式，例如RTMP直播、HLS直播、RTSP直播、FLV直播、FLV点播、MP4点播等文件中都是常见的AAC音视频</mark>。<br>     与MP3相比，AAC是一种编码效率更高、编码音质更好的音频编码格式，常见的使用AAC编码后的文件存储格式为m4a，如在iPhone或者iPad中即为m4a。FFmpeg可以支持AAC的三种编码器具体如下。<br>     <code>·aac：FFmpeg本身的AAC编码实现</code><br>     <code>·libfaac：第三方的AAC编码器</code><br>     <code>·libfdk_aac：第三方的AAC编码器</code></font></p> 
<h4><a id="font_face_size3nbspnbsp441_FFmpegAACfont_469"></a><font face="黑体" size="3">  4.4.1 FFmpeg中的AAC编码器使用</font></h4> 
<p><font face="Courier New">    下面列举几个使用FFmpeg中的AAC编码器编码的例子：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -c:a aac -b:a 160k output.aac
</code></pre> 
<p><font face="Courier New">    根据这条命令行可以看出，编码为AAC音频，码率为160kbit/s，编码生成的输出文件为output.aac文件：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, mov,mp4,m4a,3gp,3g2,mj2, from 'input.mp4':</span>
  Metadata:
    major_brand     <span class="token builtin class-name">:</span> isom
    minor_version   <span class="token builtin class-name">:</span> <span class="token number">512</span>
    compatible_brands: isomiso2avc1mp41
    encoder         <span class="token builtin class-name">:</span> Lavf59.27.100
  Duration: 00:00:35.07, start: <span class="token number">0.000000</span>, bitrate: <span class="token number">2661</span> kb/s
  Stream <span class="token comment">#0:0[0x1](und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(tv, bt709, progressive), 1920x1080 [SAR 1:1 DAR 16:9], 2493 kb/s, 30 fps, 30 tbr, 15360 tbn (default)</span>
    Metadata:
      handler_name    <span class="token builtin class-name">:</span> VideoHandler
      vendor_id       <span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
  Stream <span class="token comment">#0:1[0x2](und): Audio: aac (LC) (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 159 kb/s (default)</span>
    Metadata:
      handler_name    <span class="token builtin class-name">:</span> SoundHandler
      vendor_id       <span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
Stream mapping:
  Stream <span class="token comment">#0:1 -&gt; #0:0 (aac (native) -&gt; aac (native))</span>
Press <span class="token punctuation">[</span>q<span class="token punctuation">]</span> to stop, <span class="token punctuation">[</span>?<span class="token punctuation">]</span> <span class="token keyword">for</span> <span class="token builtin class-name">help</span>
Output <span class="token comment">#0, adts, to 'output.aac':</span>
  Metadata:
    major_brand     <span class="token builtin class-name">:</span> isom
    minor_version   <span class="token builtin class-name">:</span> <span class="token number">512</span>
    compatible_brands: isomiso2avc1mp41
    encoder         <span class="token builtin class-name">:</span> Lavf59.34.102
  Stream <span class="token comment">#0:0(und): Audio: aac (LC), 48000 Hz, stereo, fltp, 160 kb/s (default)</span>
    Metadata:
      handler_name    <span class="token builtin class-name">:</span> SoundHandler
      vendor_id       <span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
      encoder         <span class="token builtin class-name">:</span> Lavc59.54.100 aac
<span class="token assign-left variable">size</span><span class="token operator">=</span>      21kB <span class="token assign-left variable">time</span><span class="token operator">=</span>00:00:34.98 <span class="token assign-left variable">bitrate</span><span class="token operator">=</span>   <span class="token number">4</span>.9kbits/s <span class="token assign-left variable">speed</span><span class="token operator">=</span> 240x
</code></pre> 
<p><font face="Courier New">    接下来再列举一个例子：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.wav -c:a aac -q:a <span class="token number">2</span> output.m4a
</code></pre> 
<p><font face="Courier New">    从这条命令行可以看出，在编码AAC时，同样也用到了qscale参数，这个q在这里设置的有效范围为0.1～2之间，其用于设置AAC音频的VBR质量，效果并不可控，可以设置几个参数来看一下效果：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, wav, from 'input.wav':</span>
    Duration: 00:04:13.10, bitrate: <span class="token number">1411</span> kb/s
        Stream <span class="token comment">#0:0: Audio: pcm_s16le ([1][0][0][0] / 0x0001), 44100 Hz, stereo, s16, 1411 kb/s</span>
Input <span class="token comment">#1, mov,mp4,m4a,3gp,3g2,mj2, from 'output_0.1.m4a':</span>
    Metadata:
        encoder         <span class="token builtin class-name">:</span> Lavf57.66.102
    Duration: 00:04:13.12, start: <span class="token number">0.000000</span>, bitrate: <span class="token number">23</span> kb/s
        Stream <span class="token comment">#1:0(und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 24 kb/s (default)</span>
Input <span class="token comment">#2, mov,mp4,m4a,3gp,3g2,mj2, from 'output_2.0.m4a':</span>
    Metadata:
        encoder         <span class="token builtin class-name">:</span> Lavf57.66.102
    Duration: 00:04:13.12, start: <span class="token number">0.000000</span>, bitrate: <span class="token number">186</span> kb/s
        Stream <span class="token comment">#2:0(und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 186 kb/s (default)</span>
</code></pre> 
<p><font face="Courier New">    从以上代码可以看到一共有三个Input文件，具体如下。<br>     ·Input#0为原始文件，码率为1411kbit/s<br>     ·Input#1为设置q：a为0.1的文件，码率为24kbit/s<br>     ·Input#2为设置q：a为2.0的文件，码率为186kbit/s<br>     可以使用-q:a设置AAC的输出质量，关于AAC的输出控制很简单，这里就介绍这么多。</font></p> 
<h4><a id="font_face_size3nbspnbsp442_FDK_AACAACCodecfont_532"></a><font face="黑体" size="3">  4.4.2 FDK AAC第三方的AAC编解码Codec库</font></h4> 
<p><font face="Courier New">    <code>FDK-AAC库是FFmpeg支持的第三方编码库中质量最高的AAC编码库</code>，下面就来介绍一下libfdk_aac的几种编码模式。</font></p> 
<h5><a id="font_face_size2_nbspnbsp_1CBRfont_534"></a><font face="楷体" size="2">    1.恒定码率（CBR）模式</font></h5> 
<p><font face="Courier New">    如果使用libfdk_aac设定一个恒定的码率，改变编码后的大小，并且可以兼容HE-AAC Profile，则可以根据音频设置的经验设置码率，例如如果一个声道使用64kbit/s，那么双声道为128kbit/s，环绕立体声为384kbit/s，这种通常为5.1环绕立体声。可以通过b:a参数进行设置。下面就来举几个例子：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.wav -c:a libfdk_aac -b:a 128k output.m4a
</code></pre> 
<p><font face="Courier New">    根据这条命令行可以看出，FFmpeg使用libfdk_aac将input.wav转为恒定码率为128kbit/s、编码为AAC的output.m4a音频文件。</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.mp4 -c:v copy -c:a libfdk_aac -b:a 384k output.mp4
</code></pre> 
<p><font face="Courier New">    根据这条命令行可以看出，FFmpeg将input.mp4的视频文件按照原有的编码方式进行输出封装，将音频以libfdk_aac进行编码，音频通道为环绕立体声，码率为384kbit/s，封装格式为output.mp4。<br>     以上两个例子均为使用libfdk_aac进行AAC编码的案例，使用libfdk_aac可以编码AAC的恒定码率（CBR），相关内容至此介绍完毕。</font></p> 
<h5><a id="font_face_size2_nbspnbsp_2VBRfont_545"></a><font face="楷体" size="2">    2.动态码率（VBR）模式</font></h5> 
<p><font face="Courier New">    使用VBR可以有更好的音频质量，使用libfdk_aac进行VBR模式的AAC编码时，可以设置5个级别。<br>     根据表的内容，第一列为VBR的类型，第二列为每通道编码后的码率，第三列中有三种AAC编码信息，具体如下。<br>     <code>·LC：Low Complexity AAC</code>，这种编码相对来说体积比较大，质量稍差<br>     <code>·HE：High-Efficiency AAC</code>，这种编码相对来说体积稍小，质量较好<br>     <code>·HEv2：High-Efficiency AAC version2</code>，这种编码相对来说体积小，质量优<br> <font face="Courier New">    下面举个例子，将音频压缩为AAC编码的m4a容器：</font></font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.wav -c:a libfdk_aac -vbr <span class="token number">3</span> output.m4a
</code></pre> 
<p><font face="Courier New">    执行完上述命令之后，FFmpeg会将input.wav的音频转为音频编码为libfdk_aac的output.m4a音频文件。</font></p> 
<h4><a id="font_face_size3nbspnbsp443_AACfont_556"></a><font face="黑体" size="3">  4.4.3 高质量AAC设置</font></h4> 
<p><font face="Courier New">    根据前面的介绍，<mark>AAC音频分为三种LC、HE-AAC、HEv2-AAC</mark>，前文已经介绍过LC的编码设置，下面举例介绍HE-AAC与HEv2-AAC的设置。</font></p> 
<h5><a id="font_face_size2_nbspnbsp_1HEAACfont_558"></a><font face="楷体" size="2">    1.HE-AAC音频编码设置</font></h5> 
<pre><code class="prism language-bash">ffmpeg -i input.wav -c:a libfdk_aac -profile:a aac_he -b:a 64k output.m4a
</code></pre> 
<p><font face="Courier New">    执行完上述命令行之后，编码后输出output.m4a的信息如下：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, mov,mp4,m4a,3gp,3g2,mj2, from 'output.m4a':</span>
    Metadata:
        major_brand     <span class="token builtin class-name">:</span> M4A 
        minor_version   <span class="token builtin class-name">:</span> <span class="token number">512</span>
        compatible_brands: isomiso2
        encoder         <span class="token builtin class-name">:</span> Lavf57.71.100
    Duration: 00:04:13.22, start: <span class="token number">0.000000</span>, bitrate: <span class="token number">64</span> kb/s
        Stream <span class="token comment">#0:0(und): Audio: aac (HE-AAC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 64 kb/s (default)</span>
    Metadata:
        handler_name    <span class="token builtin class-name">:</span> SoundHandler
</code></pre> 
<p><font face="Courier New">    从以上代码可以看出，音频编码为HE-AAC，可见编码参数已通过-profile:a aac_he设置生效。</font></p> 
<h5><a id="font_face_size2_nbspnbsp_2HEv2AAC%09font_576"></a><font face="楷体" size="2">    2.HEv2-AAC音频编码设置 </font></h5> 
<p><font face="Courier New">    执行如下命令：</font></p> 
<pre><code class="prism language-bash">ffmpeg -i input.wav -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k output.m4a
</code></pre> 
<p><font face="Courier New">    编码后输出output.m4a信息如下：</font></p> 
<pre><code class="prism language-bash">Input <span class="token comment">#0, mov,mp4,m4a,3gp,3g2,mj2, from 'output.m4a':</span>
    Metadata:
        major_brand     <span class="token builtin class-name">:</span> M4A 
        minor_version   <span class="token builtin class-name">:</span> <span class="token number">512</span>
        compatible_brands: isomiso2
        encoder         <span class="token builtin class-name">:</span> Lavf57.71.100
    Duration: 00:04:13.26, start: -0.021814, bitrate: <span class="token number">32</span> kb/s
        Stream <span class="token comment">#0:0(und): Audio: aac (HE-AACv2) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 32 kb/s (default)</span>
</code></pre> 
<h4><a id="font_face_size3nbspnbsp444_AACfont_592"></a><font face="黑体" size="3">  4.4.4 AAC音频质量对比</font></h4> 
<p><font face="Courier New">    AAC-LC的音频编码可以采用libfaac、libfdk_aac、FFmpeg内置AAC三种，其质量顺序排列如下。<br>     <code>·libfdk_aac音频编码质量最优</code><br>     <code>·FFmpeg内置AAC编码次于libfdk_aac但优于libfaac</code><br>     <code>·libfaac在FFmpeg内置AAC编码为实验品时是除了libfdk_aac之外的唯一选择</code><br>     <strong>注意：</strong><br>     <mark>在新版本的FFmpeg中，libfaac已经被删除。</mark></font></p> 
<h3><a id="nbspnbspfont_face_size345_font_599"></a>  <font face="黑体" size="3">4.5 系统资源使用情况</font></h3> 
<p><font face="Courier New">    音视频转码与音视频转封装的不同之处在于音视频转码会占用大量的计算资源，而转封装则主要是将音频数据或者视频数据取出，然后转而封装（Mux）成另外一种封装格式，转封装主要占用IO资源，而转码主要占用CPU资源，同时转码也会使用更多的内存资源，下面观察一下转码视频时的CPU资源使用情况。<br>     首先使用FFmpeg进行转码：</font></p> 
<pre><code class="prism language-bash">ffmpeg -re -i input.mp4 -vcodec libx264 -an output.mp4
</code></pre> 
<p><font face="Courier New">    执行完上述命令行之后，使用系统命令top查看FFmpeg的CPU资源使用情况，结果如图所示。</font><br> <img src="https://images2.imgbox.com/74/88/OIFwbRtB_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="nbspnbspfont_face_size346_font_607"></a>  <font face="黑体" size="3">4.6 小结</font></h3> 
<p><font face="Courier New">    使用FFmpeg进行编解码（转码）相关的介绍至此已经告一段落，可以根据上述所讲按需使用，由于转码需要占用大量的计算资源，所以可以考虑多种优化手段进行支持。如果转码质量要求极高，那么必然需要大量的计算资源，可以考虑采用GPU进行编码，以节省CPU资源来进行其他工作。</font></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/27eb48effc6e845c98d076bab5ee1291/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">h5 video 移动端使用记录</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2e82b988a6ae6f5222560a4a803570ad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Dart语言简介</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>