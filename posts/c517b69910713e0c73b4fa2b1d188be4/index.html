<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【OpenCV入门教程之十四】OpenCV霍夫变换：霍夫线变换，霍夫圆变换合辑 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【OpenCV入门教程之十四】OpenCV霍夫变换：霍夫线变换，霍夫圆变换合辑" />
<meta property="og:description" content="本系列文章由@浅墨_毛星云 出品，转载请注明出处。 文章链接： http://blog.csdn.net/poem_qianmo/article/details/26977557
作者：毛星云（浅墨） 微博：http://weibo.com/u/1723155442
知乎：http://www.zhihu.com/people/mao-xing-yun
邮箱： happylifemxy@163.com
写作当前博文时配套使用的OpenCV版本： 2.4.9
本篇文章中，我们一起探讨了OpenCV中霍夫变换相关的知识点，以及了解了OpenCV中实现霍夫线变换的HoughLines、HoughLinesP函数的使用方法，实现霍夫圆变换的HoughCircles函数的使用方法。此博文一共有四个配套的简短的示例程序，其详细注释过的代码都在文中贴出，且文章最后提供了综合示例程序的下载。
先尝鲜一下其中一个示例程序的运行截图：
一、引言 在图像处理和计算机视觉领域中，如何从当前的图像中提取所需要的特征信息是图像识别的关键所在。在许多应用场合中需要快速准确地检测出直线或者圆。其中一种非常有效的解决问题的方法是霍夫（Hough）变换，其为图像处理中从图像中识别几何形状的基本方法之一，应用很广泛，也有很多改进算法。最基本的霍夫变换是从黑白图像中检测直线(线段)。这篇文章就将介绍OpenCV中霍夫变换的使用方法和相关知识。
二、霍夫变换概述 霍夫变换(Hough Transform)是图像处理中的一种特征提取技术，该过程在一个参数空间中通过计算累计结果的局部最大值得到一个符合该特定形状的集合作为霍夫变换结果。
霍夫变换于1962年由PaulHough首次提出，最初的Hough变换是设计用来检测直线和曲线，起初的方法要求知道物体边界线的解析方程，但不需要有关区域位置的先验知识。这种方法的一个突出优点是分割结果的Robustness,即对数据的不完全或噪声不是非常敏感。然而，要获得描述边界的解析表达常常是不可能的。　后于1972年由Richard Duda &amp; Peter Hart推广使用，经典霍夫变换用来检测图像中的直线，后来霍夫变换扩展到任意形状物体的识别，多为圆和椭圆。霍夫变换运用两个坐标空间之间的变换将在一个空间中具有相同形状的曲线或直线映射到另一个坐标空间的一个点上形成峰值，从而把检测任意形状的问题转化为统计峰值问题。
霍夫变换在OpenCV中分为霍夫线变换和霍夫圆变换两种，我们下面将分别进行介绍。
三、霍夫线变换 3.1 OpenCV中的霍夫线变换 我们知道，霍夫线变换是一种用来寻找直线的方法. 在使用霍夫线变换之前, 首先要对图像进行边缘检测的处理，也即霍夫线变换的直接输入只能是边缘二值图像.
OpenCV支持三种不同的霍夫线变换，它们分别是：标准霍夫变换(Standard Hough Transform，SHT)和多尺度霍夫变换（Multi-Scale Hough Transform，MSHT）累计概率霍夫变换(Progressive Probabilistic Hough Transform ，PPHT)。
其中，多尺度霍夫变换（MSHT）为经典霍夫变换（SHT）在多尺度下的一个变种。累计概率霍夫变换(PPHT）算法是标准霍夫变换（SHT）算法的一个改进，它在一定的范围内进行霍夫变换，计算单独线段的方向以及范围，从而减少计算量，缩短计算时间。之所以称PPHT为“概率”的，是因为并不将累加器平面内的所有可能的点累加，而只是累加其中的一部分，该想法是如果峰值如果足够高，只用一小部分时间去寻找它就够了。这样猜想的话，可以实质性地减少计算时间。
在OpenCV中，我们可以用HoughLines函数来调用标准霍夫变换SHT和多尺度霍夫变换MSHT。
而HoughLinesP函数用于调用累计概率霍夫变换PPHT。累计概率霍夫变换执行效率很高，所有相比于HoughLines函数，我们更倾向于使用HoughLinesP函数。
总结一下，OpenCV中的霍夫线变换有如下三种：
&lt;1&gt;标准霍夫变换（StandardHough Transform，SHT），由HoughLines函数调用。
&lt;2&gt;多尺度霍夫变换（Multi-ScaleHough Transform，MSHT），由HoughLines函数调用。
&lt;3&gt;累计概率霍夫变换（ProgressiveProbabilistic Hough Transform，PPHT），由HoughLinesP函数调用。
3.2 霍夫线变换的原理 【1】众所周知, 一条直线在图像二维空间可由两个变量表示. 如:
&lt;1&gt;在笛卡尔坐标系: 可由参数: 斜率和截距(m,b) 表示。
&lt;2&gt;在极坐标系: 可由参数: 极径和极角表示。
对于霍夫变换, 我们将采用第二种方式极坐标系来表示直线. 因此, 直线的表达式可为:
化简便可得到: 【2】一般来说对于点, 我们可以将通过这个点的一族直线统一定义为:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/c517b69910713e0c73b4fa2b1d188be4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-05-26T09:19:39+08:00" />
<meta property="article:modified_time" content="2014-05-26T09:19:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【OpenCV入门教程之十四】OpenCV霍夫变换：霍夫线变换，霍夫圆变换合辑</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3> 
 <blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"> 
  <h2><span style="font-weight: normal;"></span></h2><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px; font-weight: bold;"><span style="font-family: 'Microsoft YaHei'; font-size: 16px;"><span style="color: rgb(51, 51, 255);"><span style="white-space: pre;"><br></span></span></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px; font-weight: bold;"><span style="font-family: 'Microsoft YaHei'; font-size: 16px;"><span style="color: rgb(51, 51, 255);"><span style="white-space: pre;"><br></span></span></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px; font-weight: bold;"><span style="font-family: 'Microsoft YaHei'; font-size: 16px;"><span style="color: rgb(51, 51, 255);"><span style="white-space: pre;"> </span>本系列文章由</span><span style="color: rgb(204, 0, 0);"><a target="_blank" href="http://weibo.com/1723155442" rel="nofollow noopener noreferrer" style="color: rgb(202, 0, 0); text-decoration: none;">@浅墨_毛星云</a> </span><span style="color: rgb(51, 51, 255);">出品，转载请注明出处。 </span></span><span style="font-family: 'Microsoft YaHei'; color: rgb(51, 51, 255);"> </span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px;"></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px;"></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px;"></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px;"></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px;"></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px;"></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px;"><span style="font-size: 16px;"><strong><span style="font-family: 'Microsoft YaHei';"><span style="color: rgb(102, 0, 204); white-space: pre;"> </span><span style="color: rgb(102, 0, 204);">文章链接：</span><a target="_blank" href="http://blog.csdn.net/poem_qianmo/article/details/22745559" style="color: rgb(202, 0, 0); text-decoration: none;" rel="noopener noreferrer"><span style="color: rgb(255, 102, 0);"> </span><span style="color: rgb(255, 0, 0);"></span></a><a target="_blank" href="http://blog.csdn.net/poem_qianmo/article/details/26977557" style="color: rgb(202, 0, 0); text-decoration: none;" rel="noopener noreferrer">http://blog.csdn.net/poem_qianmo/article/details/26977557</a></span><a target="_blank" href="http://blog.csdn.net/poem_qianmo/article/details/21479533" style="color: rgb(202, 0, 0); text-decoration: none;" rel="noopener noreferrer"></a></strong></span></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px;"></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px;"><span style="font-size: 16px;"><span style="font-family: 'Microsoft YaHei';"><strong><span style="color: rgb(102, 0, 204); white-space: pre;"> </span><span style="color: rgb(0, 153, 0);">作者：毛星云（浅墨）    </span></strong></span></span><span style="color: rgb(204, 0, 0); font-family: 'Microsoft YaHei'; font-size: 16px;"><strong>微博：</strong></span><a target="_blank" href="http://weibo.com/u/1723155442" rel="nofollow noopener noreferrer" style="color: rgb(202, 0, 0); text-decoration: none; font-weight: bold; font-family: 'Microsoft YaHei'; font-size: 16px;">http://weibo.com/u/1723155442</a></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px;"><span style="color: rgb(51, 102, 255); font-family: 'Microsoft YaHei'; font-size: 16px;"><strong><span style="white-space: pre;"> </span>知乎：</strong></span><a target="_blank" href="http://www.zhihu.com/people/mao-xing-yun" rel="nofollow noopener noreferrer" style="color: rgb(202, 0, 0); text-decoration: none; font-weight: bold; font-family: 'Microsoft YaHei'; font-size: 16px;">http://www.zhihu.com/people/mao-xing-yun</a></p><p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px;"><span style="font-size: 16px; font-family: 'Microsoft YaHei';"><strong><strong><span style="color: rgb(0, 153, 0); white-space: pre;"> </span><span style="color: rgb(51, 153, 153);">邮箱：</span><span style="color: rgb(0, 153, 0);"> </span></strong></strong></span><span style="font-size: 16px; color: rgb(0, 153, 0);"><strong><strong><span style="color: rgb(202, 0, 0); font-family: 'Microsoft YaHei';"><a target="_blank" href="mailto:happylifemxy@163.com" rel="nofollow noopener noreferrer" style="color: rgb(202, 0, 0); text-decoration: none;">happylifemxy@163.com</a></span></strong></strong></span><br></p><span class="eye-protector-processed" style="line-height: 26px; font-family: 'Microsoft YaHei'; font-size: 16px; font-weight: bold; white-space: pre; border-color: rgb(153, 153, 0); color: rgb(153, 153, 0);"> </span><span class="eye-protector-processed" style="line-height: 26px; font-family: 'Microsoft YaHei'; font-size: 16px; font-weight: bold; white-space: pre; border-color: rgb(153, 153, 0);"><span style="color: rgb(153, 51, 153);">写作当前博文时配套使用的OpenCV版本：</span></span><span style="line-height: 26px; font-family: 'Microsoft YaHei'; font-size: 16px; white-space: pre;"><strong><span style="color: rgb(153, 51, 153);"> </span><span style="color: rgb(102, 102, 102);">2.4.9</span></strong></span><br> 
  <div> 
   <br> 
  </div> 
  <div> 
   <br> 
  </div> 
  <p><span style="font-size:14px;"><span style="font-family:Microsoft YaHei;font-weight: normal;"> 本篇文章中，我们一起探讨了OpenCV中霍夫变换相关的知识点，</span><span style="font-family: 'Microsoft YaHei'; line-height: 26px; font-weight: normal;">以及了解了OpenCV中实现霍夫线变换的HoughLines、HoughLinesP函数的使用方法，实现霍夫圆变换的HoughCircles函数的使用方法。</span><span style="font-family: 'Microsoft YaHei'; font-weight: normal; line-height: 26px;">此博文一共有四个配套的简短的示例程序，其详细注释过的代码都在文中贴出，且文章最后提供了综合示例程序的下载。</span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"></span></p> 
  <p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; line-height: 26px;"><span style="font-family: 'Microsoft YaHei'; font-weight: normal;"><span style="font-size:14px;">先尝鲜一下其中一个示例程序的运行截图：</span></span></p> 
  <p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; line-height: 26px;"><span style="font-family: 'Microsoft YaHei'; font-weight: normal;"><span style="font-size:14px;"><br></span></span></p> 
  <p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px;"><span style="font-family: 'Microsoft YaHei';"><img src="https://images2.imgbox.com/7a/0d/ih6EaISc_o.jpg" alt=""><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <h3><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></h3> 
  <h3><span style="font-family:Microsoft YaHei;font-size:32px;color:#993399;font-weight: normal;">一、引言</span></h3> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">在图像处理和计算机视觉领域中，如何从当前的图像中提取所需要的特征信息是图像识别的关键所在。在许多应用场合中需要快速准确地检测出直线或者圆。其中一种非常有效的解决问题的方法是霍夫（Hough）变换，其为图像处理中从图像中识别几何形状的基本方法之一，应用很广泛，也有很多改进算法。最基本的霍夫变换是从黑白图像中检测直线(线段)。这篇文章就将介绍OpenCV中霍夫变换的使用方法和相关知识。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <h3><span style="font-family:Microsoft YaHei;font-size:32px;color:#cc0000;font-weight: normal;">二、霍夫变换概述</span></h3> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">霍夫变换(Hough Transform)是图像处理中的一种特征提取技术，该过程在一个参数空间中通过计算累计结果的局部最大值得到一个符合该特定形状的集合作为霍夫变换结果。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">霍夫变换于1962年由PaulHough首次提出，最初的Hough变换是设计用来检测直线和曲线，起初的方法要求知道物体边界线的解析方程，但不需要有关区域位置的先验知识。这种方法的一个突出优点是分割结果的Robustness,即对数据的不完全或噪声不是非常敏感。然而，要获得描述边界的解析表达常常是不可能的。　后于1972年由Richard Duda &amp; Peter Hart推广使用，经典霍夫变换用来检测图像中的直线，后来霍夫变换扩展到任意形状物体的识别，多为圆和椭圆。霍夫变换运用两个坐标空间之间的变换将在一个空间中具有相同形状的曲线或直线映射到另一个坐标空间的一个点上形成峰值，从而把检测任意形状的问题转化为统计峰值问题。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">霍夫变换在OpenCV中分为霍夫线变换和霍夫圆变换两种，我们下面将分别进行介绍。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><br></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <h3><span style="font-family:Microsoft YaHei;font-size:32px;color:#339999;font-weight: normal;">三、霍夫线变换</span></h3> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <h4><span style="font-family:Microsoft YaHei;font-size:32px;color:#999999;font-weight: normal;">3.1  </span><span style="font-family:Microsoft YaHei;font-size:24px;color:#6600cc;font-weight: normal;">OpenCV中的霍夫线变换</span></h4> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><br></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">我们知道，霍夫线变换是一种用来寻找直线的方法. 在使用霍夫线变换之前, 首先要对图像进行边缘检测的处理，也即霍夫线变换的直接输入只能是边缘二值图像.</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">OpenCV支持三种不同的霍夫线变换，它们分别是：标准霍夫变换(Standard Hough Transform，SHT)和多尺度霍夫变换（Multi-Scale Hough Transform，MSHT）累计概率霍夫变换(Progressive Probabilistic Hough Transform ，PPHT)。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">其中，多尺度霍夫变换（MSHT）为经典霍夫变换（SHT）在多尺度下的一个变种。累计概率霍夫变换(PPHT）算法是标准霍夫变换（SHT）算法的一个改进，它在一定的范围内进行霍夫变换，计算单独线段的方向以及范围，从而减少计算量，缩短计算时间。之所以称PPHT为“概率”的，是因为并不将累加器平面内的所有可能的点累加，而只是累加其中的一部分，该想法是如果峰值如果足够高，只用一小部分时间去寻找它就够了。这样猜想的话，可以实质性地减少计算时间。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">在OpenCV中，我们可以用HoughLines函数来调用标准霍夫变换SHT和多尺度霍夫变换MSHT。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">而HoughLinesP函数用于调用累计概率霍夫变换PPHT。累计概率霍夫变换执行效率很高，所有相比于HoughLines函数，我们更倾向于使用HoughLinesP函数。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">总结一下，OpenCV中的霍夫线变换有如下三种：</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:24px;color:#cc0000;font-weight: normal;">&lt;1&gt;</span><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">标准霍夫变换（StandardHough Transform，SHT），由HoughLines函数调用。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:24px;color:#009900;font-weight: normal;">&lt;2&gt;</span><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">多尺度霍夫变换（Multi-ScaleHough Transform，MSHT），由HoughLines函数调用。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-weight: normal;"><span style="font-size:24px;color:#3366ff;">&lt;3&gt;</span><span style="font-size:14px;">累计概率霍夫变换（ProgressiveProbabilistic Hough Transform，PPHT），由HoughLinesP函数调用。</span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <h4><span style="font-family:Microsoft YaHei;font-size:32px;color:#999999;font-weight: normal;">3.2 </span><span style="font-family:Microsoft YaHei;font-size:24px;color:#cc0000;font-weight: normal;">霍夫线变换的原理</span></h4> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-weight: normal;"><span style="font-size:24px;color:#009900;">【1】</span><span style="font-size:14px;">众所周知, 一条直线在图像二维空间可由两个变量表示. 如:</span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">&lt;1&gt;在笛卡尔坐标系: 可由参数: 斜率和截距<span style="font-family: 'Microsoft YaHei';font-size:14px;">(m,b) </span>表示。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">&lt;2&gt;在极坐标系: 可由参数: 极径和极角<img src="https://images2.imgbox.com/4f/d5/sWZVH27m_o.png" width="45" height="20" alt="">表示。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p style="text-align: center;"><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><img src="https://images2.imgbox.com/9a/9f/lXNkUoTR_o.jpg" width="400" height="320" alt=""><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">对于霍夫变换, 我们将采用第二种方式极坐标系来表示直线. 因此, 直线的表达式可为:</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p style="text-align: center;"><img src="https://images2.imgbox.com/4c/8f/a1qXOtT1_o.gif" width="280" height="60" alt=""></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">化简便可得到: </span></p> 
  <p style="text-align: center;"><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><img src="https://images2.imgbox.com/cb/d0/6fMaUE5i_o.gif" width="300" height="30" alt=""><br></span></p> 
  <p></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:24px;color:#cc0000;font-weight: normal;">【2】</span><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">一般来说对于点<img src="https://images2.imgbox.com/56/df/r9MtQgDR_o.gif" width="80" height="25" alt="">, 我们可以将通过这个点的一族直线统一定义为:</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p style="text-align: center;"> <img src="https://images2.imgbox.com/e8/e7/ePyBICf3_o.gif" width="300" height="30" alt=""></p> 
  <p style="text-align: center;"><br></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">这就意味着每一对<img src="https://images2.imgbox.com/ca/fb/T7SIT2xP_o.png" width="70" height="25" alt="">代表一条通过点<img src="https://images2.imgbox.com/ae/fd/95DMdRw1_o.gif" width="80" height="25" style="font-family: 'Microsoft YaHei';font-size:14px;" alt="">的直线。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-weight: normal;"><span style="font-size:24px;color:#6666cc;">【3】</span><span style="font-size:14px;">如果对于一个给定点</span><img src="https://images2.imgbox.com/f0/89/9UcbbJdg_o.gif" width="80" height="25" style="font-family: 'Microsoft YaHei';font-size:14px;" alt=""><span style="font-size:14px;">我们在极坐标对极径极角平面绘出所有通过它的直线, 将得到一条正弦曲线. 例如, 对于给定点X_0= 8 和Y_0= 6 我们可以绘出下图 (在平面):</span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p style="text-align: center;"><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> <img src="https://images2.imgbox.com/c9/02/i8camcVi_o.jpg" width="450" height="300" alt=""></span></p> 
  <p></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">只绘出满足下列条件的点 <img src="https://images2.imgbox.com/5c/35/R3xVLNXa_o.png" width="50" height="16" alt=""> 和  <img src="https://images2.imgbox.com/d7/dc/fy0wRFt8_o.png" width="100" height="16" alt=""> .</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-weight: normal;"><span style="font-size:24px;color:#006600;">【4】</span><span style="font-size:14px;">我们可以对图像中所有的点进行上述操作. 如果两个不同点进行上述操作后得到的曲线在平面<img src="https://images2.imgbox.com/47/0d/qMXvVAtU_o.png" width="56" height="18" alt="">相交, 这就意味着它</span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">们通过同一条直线. 例如,接上面的例子我们继续对点 <img src="https://images2.imgbox.com/c0/2b/5f0ZvG4p_o.png" width="120" height="18" alt=""> 和点 <img src="https://images2.imgbox.com/08/77/jKOWFGeO_o.png" width="130" height="18" alt=""> 绘图, 得到下图:</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p style="text-align: center;"><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> <img src="https://images2.imgbox.com/dc/c9/zuB07R4x_o.jpg" width="450" height="300" alt=""></span></p> 
  <p></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">这三条曲线在平面相交于点 (0.925, 9.6), 坐标表示的是参数对 <img src="https://images2.imgbox.com/4d/e5/LzJwV8WV_o.png" width="55" height="18" alt=""> 或者是说点<img src="https://images2.imgbox.com/15/06/I5Y3Hhy9_o.gif" width="80" height="25" style="font-family: 'Microsoft YaHei';font-size:14px;" alt="">, 点<img src="https://images2.imgbox.com/35/d4/I8dKDVNq_o.png" width="80" height="25" alt="">和点<img src="https://images2.imgbox.com/d8/0b/TQqPfD17_o.png" width="80" height="25" alt="">组成的平面内的的直线。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-weight: normal;"><span style="font-size:24px;color:#cc0000;">【5】</span><span style="font-size:14px;">以上的说明表明，一般来说, 一条直线能够通过在平面 </span><img src="https://images2.imgbox.com/d2/78/zbclC7Pc_o.png" width="55" height="18" style="font-family: 'Microsoft YaHei';font-size:14px;" alt=""><span style="font-size:14px;"> 寻找交于一点的曲线数量来检测。而越多曲线交于一点也就意味着这个交点表示的直线由更多的点组成. 一般来说我们可以通过设置直线上点的阈值来定义多少条曲线交于一点我们才认为检测到了一条直线。</span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-weight: normal;"><span style="font-size:24px;color:#666600;">【6】</span><span style="font-size:14px;">这就是霍夫线变换要做的. 它追踪图像中每个点对应曲线间的交点. 如果交于一点的曲线的数量超过了阈值, 那么可以认为这个交点所代表的参数对<img src="https://images2.imgbox.com/4d/f1/DvQ8toj8_o.png" width="70" height="26" alt="">在原图像中为一条直线。</span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><br></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <h4><span style="font-family:Microsoft YaHei;font-size:32px;color:#999999;font-weight: normal;">3.3 </span><span style="font-family:Microsoft YaHei;font-size:24px;color:#009900;font-weight: normal;">HoughLines( )函数详解</span></h4> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">此函数可以找出采用标准霍夫变换的二值图像线条。在OpenCV中，我们可以用其来调用标准霍夫变换SHT和多尺度霍夫变换MSHT的OpenCV内建算法。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"></span></p> 
  <pre><code class="language-cpp">C++: void HoughLines(InputArray image, OutputArray lines, double rho, double theta, int threshold, double srn=0, double stn=0 )</code></pre> 
  <br> 
  <p></p> 
  <p></p> 
 </blockquote><span style="font-family:Microsoft YaHei;font-size:14px;"><span style="font-weight: normal;"><br></span></span> 
 <ul style="font-family: 'Microsoft YaHei';font-size:14px; font-weight: normal;"><li>第一个参数，InputArray类型的image，输入图像，即源图像，需为8位的单通道二进制图像，可以将任意的源图载入进来后由函数修改成此格式后，再填在这里。</li><li>第二个参数，InputArray类型的lines，经过调用HoughLines函数后储存了霍夫线变换检测到线条的输出矢量。每一条线由具有两个元素的矢量<img src="https://images2.imgbox.com/1d/1d/VmV1iWdl_o.png" width="48" height="22" alt="">表示，其中，<img src="https://images2.imgbox.com/af/6b/dsQTPOUp_o.png" width="13" height="16" alt="">是离坐标原点((0,0)（也就是图像的左上角）的距离。 <img src="https://images2.imgbox.com/27/42/0BXELOcI_o.gif" width="12" height="16" alt="">是弧度线条旋转角度（0~垂直线，π/2~水平线）。</li><li>第三个参数，double类型的rho，以像素为单位的距离精度。另一种形容方式是直线搜索时的进步尺寸的单位半径。PS:Latex中/rho就表示 <img src="https://images2.imgbox.com/e8/05/M5cP0kAB_o.png" width="13" height="16" style="font-family: 'Microsoft YaHei';font-size:14px;" alt="">。</li><li>第四个参数，double类型的theta，以弧度为单位的角度精度。另一种形容方式是直线搜索时的进步尺寸的单位角度。</li><li>第五个参数，int类型的threshold，累加平面的阈值参数，即识别某部分为图中的一条直线时它在累加平面中必须达到的值。大于阈值<span style="font-family: 'Microsoft YaHei'; font-size: 14px;">threshold</span>的线段才可以被检测通过并返回到结果中。</li><li>第六个参数，double类型的srn，有默认值0。对于多尺度的霍夫变换，这是第三个参数进步尺寸rho的除数距离。粗略的累加器进步尺寸直接是第三个参数rho，而精确的累加器进步尺寸为rho/srn。</li><li>第七个参数，double类型的stn，有默认值0，对于多尺度霍夫变换，srn表示第四个参数进步尺寸的单位角度theta的除数距离。且如果srn和stn同时为0，就表示使用经典的霍夫变换。否则，这两个参数应该都为正数。</li></ul></h3> 
<h3> 
 <blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">另外，关于霍夫变换的详细解释，可以看此英文页面：</span></p> 
  <p><a target="_blank" href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm" rel="nofollow noopener noreferrer"><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm</span></a></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">在学完函数解析，看看浅墨为大家准备的以HoughLines为核心的示例程序，就可以全方位了解HoughLines函数的使用方法了：</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"></span></p> 
  <pre><code class="language-cpp">//-----------------------------------【头文件包含部分】---------------------------------------
//		描述：包含程序所依赖的头文件
//---------------------------------------------------------------------------------------------- 
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;

//-----------------------------------【命名空间声明部分】---------------------------------------
//		描述：包含程序所使用的命名空间
//----------------------------------------------------------------------------------------------- 
using namespace cv;
//-----------------------------------【main( )函数】--------------------------------------------
//		描述：控制台应用程序的入口函数，我们的程序从这里开始
//-----------------------------------------------------------------------------------------------
int main( )
{
	//【1】载入原始图和Mat变量定义   
	Mat srcImage = imread("1.jpg");  //工程目录下应该有一张名为1.jpg的素材图
	Mat midImage,dstImage;//临时变量和目标图的定义

	//【2】进行边缘检测和转化为灰度图
	Canny(srcImage, midImage, 50, 200, 3);//进行一此canny边缘检测
	cvtColor(midImage,dstImage, CV_GRAY2BGR);//转化边缘检测后的图为灰度图

	//【3】进行霍夫线变换
	vector&lt;Vec2f&gt; lines;//定义一个矢量结构lines用于存放得到的线段矢量集合
	HoughLines(midImage, lines, 1, CV_PI/180, 150, 0, 0 );

	//【4】依次在图中绘制出每条线段
	for( size_t i = 0; i &lt; lines.size(); i++ )
	{
		float rho = lines[i][0], theta = lines[i][1];
		Point pt1, pt2;
		double a = cos(theta), b = sin(theta);
		double x0 = a*rho, y0 = b*rho;
		pt1.x = cvRound(x0 + 1000*(-b));
		pt1.y = cvRound(y0 + 1000*(a));
		pt2.x = cvRound(x0 - 1000*(-b));
		pt2.y = cvRound(y0 - 1000*(a));
		line( dstImage, pt1, pt2, Scalar(55,100,195), 1, CV_AA);
	}

	//【5】显示原始图  
	imshow("【原始图】", srcImage);  

	//【6】边缘检测后的图 
	imshow("【边缘检测后的图】", midImage);  

	//【7】显示效果图  
	imshow("【效果图】", dstImage);  

	waitKey(0);  

	return 0;  
}</code></pre> 
  <br> 
  <br> 
  <p></p> 
  <p><br></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">运行截图：</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> <img src="https://images2.imgbox.com/f1/01/tud7FxQa_o.jpg" alt=""></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">来一张大图：</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><img src="https://images2.imgbox.com/9e/35/Qdedcap3_o.jpg" alt=""><br></span></p> 
  <p><br></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">PS：可以通过调节line(dstImage, pt1, pt2, Scalar(55,100,195), 1, CV_AA);一句Scalar(55,100,195)参数中G、B、R颜色值的数值，得到图中想要的线条颜色。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <h3><span style="font-family:Microsoft YaHei;font-size:32px;color:#999999;font-weight: normal;">3.4 </span><span style="font-family:Microsoft YaHei;font-size:24px;color:#009900;font-weight: normal;">HoughLinesP( )函数详解</span></h3> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">此函数在HoughLines的基础上末尾加了一个代表Probabilistic（概率）的P，表明它可以采用累计概率霍夫变换（PPHT）来找出二值图像中的直线。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"></span></p> 
  <pre><code class="language-cpp">C++: void HoughLinesP(InputArray image, OutputArray lines, double rho, double theta, int threshold, double minLineLength=0, double maxLineGap=0 )</code></pre> 
  <p></p> 
  <p></p> 
  <p><br></p> 
  <p></p> 
  <ul><li><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;">第一个参数，InputArray类型的image，输入图像，即源图像，需为8位的单通道二进制图像，可以将任意的源图载入进来后由函数修改成此格式后，再填在这里。</span></li><li><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;">第二个参数，InputArray类型的lines，经过调用HoughLinesP函数后后存储了检测到的线条的输出矢量，每一条线由具有四个元素的矢量(x_1,y_1, x_2, y_2）  表示，其中，(x_1, y_1)和(x_2, y_2) 是是每个检测到的线段的结束点。</span></li><li><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;">第三个参数，double类型的rho，<span style="font-family: 'Microsoft YaHei'; font-size: 14px;">以像素为单位的距离精度。</span>另一种形容方式是直线搜索时的进步尺寸的单位半径。</span></li><li><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;">第四个参数，double类型的theta，以弧度为单位的角度精度。另一种形容方式是直线搜索时的进步尺寸的单位角度。</span></li><li><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;">第五个参数，int类型的threshold，累加平面的阈值参数，即识别某部分为图中的一条直线时它在累加平面中必须达到的值。<span style="font-family: 'Microsoft YaHei'; font-size: 14px;">大于阈值</span><span style="font-family: 'Microsoft YaHei'; font-size: 14px;">threshold</span><span style="font-family: 'Microsoft YaHei'; font-size: 14px;">的线段才可以被检测通过并返回到结果中。</span></span></li><li><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;">第六个参数，double类型的minLineLength，有默认值0，表示最低线段的长度，比这个设定参数短的线段就不能被显现出来。</span></li><li><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;">第七个参数，double类型的maxLineGap，有默认值0，允许将同一行点与点之间连接起来的最大的距离。</span></li></ul> 
  <p></p> 
  <p><br></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">对于此函数，依然是为大家准备了示例程序：</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"></span></p> 
  <pre><code class="language-cpp">//-----------------------------------【头文件包含部分】---------------------------------------
//		描述：包含程序所依赖的头文件
//---------------------------------------------------------------------------------------------- 
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;

//-----------------------------------【命名空间声明部分】---------------------------------------
//		描述：包含程序所使用的命名空间
//----------------------------------------------------------------------------------------------- 
using namespace cv;
//-----------------------------------【main( )函数】--------------------------------------------
//		描述：控制台应用程序的入口函数，我们的程序从这里开始
//-----------------------------------------------------------------------------------------------
int main( )
{
	//【1】载入原始图和Mat变量定义   
	Mat srcImage = imread("1.jpg");  //工程目录下应该有一张名为1.jpg的素材图
	Mat midImage,dstImage;//临时变量和目标图的定义

	//【2】进行边缘检测和转化为灰度图
	Canny(srcImage, midImage, 50, 200, 3);//进行一此canny边缘检测
	cvtColor(midImage,dstImage, CV_GRAY2BGR);//转化边缘检测后的图为灰度图

	//【3】进行霍夫线变换
	vector&lt;Vec4i&gt; lines;//定义一个矢量结构lines用于存放得到的线段矢量集合
	HoughLinesP(midImage, lines, 1, CV_PI/180, 80, 50, 10 );

	//【4】依次在图中绘制出每条线段
	for( size_t i = 0; i &lt; lines.size(); i++ )
	{
		Vec4i l = lines[i];
		line( dstImage, Point(l[0], l[1]), Point(l[2], l[3]), Scalar(186,88,255), 1, CV_AA);
	}

	//【5】显示原始图  
	imshow("【原始图】", srcImage);  

	//【6】边缘检测后的图 
	imshow("【边缘检测后的图】", midImage);  

	//【7】显示效果图  
	imshow("【效果图】", dstImage);  

	waitKey(0);  

	return 0;  
}</code></pre> 
  <br> 
  <br> 
  <p></p> 
  <p></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">运行截图：</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> <img src="https://images2.imgbox.com/7f/96/gxp9ezQ3_o.jpg" alt=""></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;"><span style="font-weight: normal;">来一张大图：</span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;"><span style="font-weight: normal;"><img src="https://images2.imgbox.com/f7/a3/WfhZ9OBQ_o.jpg" alt=""><br></span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;"><span style="font-weight: normal;"><br></span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;"><span style="font-weight: normal;"><br></span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <h2><span style="font-family:Microsoft YaHei;font-size:32px;color:#993399;font-weight: normal;">四、霍夫圆变换</span></h2> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">霍夫圆变换的基本原理和上面讲的霍夫线变化大体上是很类似的，只是点对应的二维极径极角空间被三维的圆心点x, y还有半径r空间取代。说“大体上类似”的原因是，如果完全用相同的方法的话，累加平面会被三维的累加容器所代替：在这三维中，一维是x，一维是y，另外一维是圆的半径r。这就意味着需要大量的内存而且执行效率会很低，速度会很慢。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">对直线来说, 一条直线能由参数极径极角<img src="https://images2.imgbox.com/41/ec/8sW833rx_o.png" width="40" height="20" alt="">表示. 而对圆来说, 我们需要三个参数来表示一个圆, 也就是：</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p style="text-align: center;"><img src="https://images2.imgbox.com/16/ef/SGZR5lWT_o.png" width="333" height="33" alt=""></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">这里的 表示圆心的位置 (下图中的绿点) 而 r 表示半径, 这样我们就能唯一的定义一个圆了, 见下图:</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> <img src="https://images2.imgbox.com/40/ea/9uRWFh17_o.jpg" alt=""> <img src="https://images2.imgbox.com/59/40/rebGdZC2_o.jpg" style="font-family: 'Microsoft YaHei';font-size:14px;" alt=""></span></p> 
  <p></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">在OpenCV中，我们一般通过一个叫做“霍夫梯度法”的方法来解决圆变换的问题。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <h4><span style="font-family:Microsoft YaHei;font-size:32px;color:#999999;font-weight: normal;">4.1 </span><span style="font-family:Microsoft YaHei;font-size:24px;color:#993399;font-weight: normal;">霍夫梯度法的原理</span></h4> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">霍夫梯度法的原理是这样的。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-weight: normal;"><span style="color: rgb(153, 0, 0);"><span style="font-size:18px;">【1】</span></span><span style="font-size:14px;">首先对图像应用边缘检测，比如用canny边缘检测。</span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-weight: normal;"><span style="color: rgb(102, 0, 204);"><span style="font-size:18px;">【2】</span></span><span style="font-size:14px;">然后，对边缘图像中的每一个非零点，考虑其局部梯度，即用Sobel（）函数计算x和y方向的Sobel一阶导数得到梯度。</span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-weight: normal;"><span style="color: rgb(102, 102, 0);"><span style="font-size:18px;">【3】</span></span><span style="font-size:14px;">利用得到的梯度，由斜率指定的直线上的每一个点都在累加器中被累加，这里的斜率是从一个指定的最小值到指定的最大值的距离。</span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-weight: normal;"><span style="color: rgb(0, 153, 0);"><span style="font-size:18px;">【4】</span></span><span style="font-size:14px;">同时，标记边缘图像中每一个非0像素的位置。</span></span></p> 
  <p><span style="font-family: 'Microsoft YaHei'; color: rgb(204, 0, 0); font-weight: normal;"><span style="font-size:18px;">【5】</span></span><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">然后从二维累加器中这些点中选择候选的中心，这些中心都大于给定阈值并且大于其所有近邻。这些候选的中心按照累加值降序排列，以便于最支持像素的中心首先出现。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-weight: normal;"><span style="color: rgb(51, 51, 255);"><span style="font-size:18px;">【6】</span></span><span style="font-size:14px;">接下来对每一个中心，考虑所有的非0像素。</span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-weight: normal;"><span style="color: rgb(153, 51, 0);"><span style="font-size:18px;">【7】</span></span><span style="font-size:14px;">这些像素按照其与中心的距离排序。从到最大半径的最小距离算起，选择非0像素最支持的一条半径。8.如果一个中心收到边缘图像非0像素最充分的支持，并且到前期被选择的中心有足够的距离，那么它就会被保留下来。</span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">这个实现可以使算法执行起来更高效，或许更加重要的是，能够帮助解决三维累加器中<span style="font-family: 'Microsoft YaHei';font-size:14px;">会产生许多噪声并且使得结果不稳定的</span>稀疏分布问题。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">人无完人，金无足赤。同样，这个算法也并不是十全十美的，还有许多需要指出的缺点。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <h3><span style="font-family:Microsoft YaHei;font-size:32px;color:#999999;font-weight: normal;">4.2 </span><span style="font-family:Microsoft YaHei;font-size:24px;color:#3333ff;font-weight: normal;">霍夫梯度法的缺点</span></h3> 
  <div> 
   <span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span> 
  </div> 
  <p><span style="font-family:Microsoft YaHei;font-weight: normal;"><span style="font-size:24px;color:#cc0000;">&lt;1&gt;</span><span style="font-size:14px;">在霍夫梯度法中，我们使用Sobel导数来计算局部梯度，那么随之而来的假设是，其可以视作等同于一条局部切线，并这个不是一个数值稳定的做法。在大多数情况下，这样做会得到正确的结果，但或许会在输出中产生一些噪声。</span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-weight: normal;"><span style="font-size:24px;color:#009900;">&lt;2&gt;</span><span style="font-size:14px;">在边缘图像中的整个非0像素集被看做每个中心的候选部分。因此，如果把累加器的阈值设置偏低，算法将要消耗比较长的时间。第三，因为每一个中心只选择一个圆，如果有同心圆，就只能选择其中的一个。</span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:24px;color:#6633ff;font-weight: normal;">&lt;3&gt;</span><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">因为中心是按照其关联的累加器值的升序排列的，并且如果新的中心过于接近之前已经接受的中心的话，就不会被保留下来。且当有许多同心圆或者是近似的同心圆时，霍夫梯度法的倾向是保留最大的一个圆。可以说这是一种比较极端的做法，因为在这里默认Sobel导数会产生噪声，若是对于无穷分辨率的平滑图像而言的话，这才是必须的。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <h3><span style="font-family:Microsoft YaHei;font-size:32px;color:#999999;font-weight: normal;">4.3 </span><span style="font-family:Microsoft YaHei;font-size:24px;color:#ff0000;font-weight: normal;">HoughCircles( )函数详解</span></h3> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">HoughCircles函数可以利用霍夫变换算法检测出灰度图中的圆。它和之前的HoughLines和HoughLinesP比较明显的一个区别是它不需要源图是二值的，而HoughLines和HoughLinesP都需要源图为二值图像。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"></span></p> 
  <pre><code class="language-cpp">C++: void HoughCircles(InputArray image,OutputArray circles, int method, double dp, double minDist, double param1=100,double param2=100, int minRadius=0, int maxRadius=0 )</code></pre> 
  <p></p> 
  <p></p> 
  <ul><li><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;">第一个参数，InputArray类型的image，输入图像，即源图像，需为8位的灰度单通道图像。</span></li><li><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;">第二个参数，InputArray类型的circles，经过调用HoughCircles函数后此参数存储了检测到的圆的输出矢量，每个矢量由包含了3个元素的浮点矢量(x, y, radius)表示。</span></li><li><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;">第三个参数，int类型的method，即使用的检测方法，目前OpenCV中就霍夫梯度法一种可以使用，它的标识符为CV_HOUGH_GRADIENT，在此参数处填这个标识符即可。</span></li><li><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;">第四个参数，double类型的dp，用来检测圆心的累加器图像的分辨率于输入图像之比的倒数，且此参数允许创建一个比输入图像分辨率低的累加器。上述文字不好理解的话，来看例子吧。例如，如果dp= 1时，累加器和输入图像具有相同的分辨率。如果dp=2，累加器便有输入图像一半那么大的宽度和高度。</span></li><li><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;">第五个参数，double类型的minDist，为霍夫变换检测到的圆的圆心之间的最小距离，即让我们的算法能明显区分的两个不同圆之间的最小距离。这个参数如果太小的话，多个相邻的圆可能被错误地检测成了一个重合的圆。反之，这个参数设置太大的话，某些圆就不能被检测出来了。</span></li><li><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;">第六个参数，double类型的param1，有默认值100。它是第三个参数method设置的检测方法的对应的参数。对当前唯一的方法霍夫梯度法CV_HOUGH_GRADIENT，它表示传递给canny边缘检测算子的高阈值，而低阈值为高阈值的一半。</span></li><li><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;">第七个参数，double类型的param2，也有默认值100。它是第三个参数method设置的检测方法的对应的参数。对当前唯一的方法霍夫梯度法CV_HOUGH_GRADIENT，它表示在检测阶段圆心的累加器阈值。它越小的话，就可以检测到更多根本不存在的圆，而它越大的话，能通过检测的圆就更加接近完美的圆形了。</span></li><li><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;">第八个参数，int类型的minRadius,有默认值0，表示圆半径的最小值。</span></li><li><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;">第九个参数，int类型的maxRadius,也有默认值0，表示圆半径的最大值。</span></li></ul> 
  <p></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">需要注意的是，使用此函数可以很容易地检测出圆的圆心，但是它可能找不到合适的圆半径。我们可以通过第八个参数minRadius和第九个参数maxRadius指定最小和最大的圆半径，来辅助圆检测的效果。或者，我们可以直接忽略返回半径，因为它们都有着默认值0，单单用HoughCircles函数检测出来的圆心，然后用额外的一些步骤来进一步确定半径。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> <span style="font-family: 'Microsoft YaHei';font-size:14px;">依然是为大家准备了基于此函数的示例程序：</span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><span style="font-family: 'Microsoft YaHei';font-size:14px;"></span></span></p> 
  <pre><code class="language-cpp">//-----------------------------------【头文件包含部分】---------------------------------------
//		描述：包含程序所依赖的头文件
//---------------------------------------------------------------------------------------------- 
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;

//-----------------------------------【命名空间声明部分】---------------------------------------
//		描述：包含程序所使用的命名空间
//----------------------------------------------------------------------------------------------- 
using namespace cv;
//-----------------------------------【main( )函数】--------------------------------------------
//		描述：控制台应用程序的入口函数，我们的程序从这里开始
//-----------------------------------------------------------------------------------------------
int main( )
{
	//【1】载入原始图和Mat变量定义   
	Mat srcImage = imread("1.jpg");  //工程目录下应该有一张名为1.jpg的素材图
	Mat midImage,dstImage;//临时变量和目标图的定义

	//【2】显示原始图
	imshow("【原始图】", srcImage);  

	//【3】转为灰度图，进行图像平滑
	cvtColor(srcImage,midImage, CV_BGR2GRAY);//转化边缘检测后的图为灰度图
	GaussianBlur( midImage, midImage, Size(9, 9), 2, 2 );

	//【4】进行霍夫圆变换
	vector&lt;Vec3f&gt; circles;
	HoughCircles( midImage, circles, CV_HOUGH_GRADIENT,1.5, 10, 200, 100, 0, 0 );

	//【5】依次在图中绘制出圆
	for( size_t i = 0; i &lt; circles.size(); i++ )
	{
		Point center(cvRound(circles[i][0]), cvRound(circles[i][1]));
		int radius = cvRound(circles[i][2]);
		//绘制圆心
		circle( srcImage, center, 3, Scalar(0,255,0), -1, 8, 0 );
		//绘制圆轮廓
		circle( srcImage, center, radius, Scalar(155,50,255), 3, 8, 0 );
	}

	//【6】显示效果图  
	imshow("【效果图】", srcImage);  

	waitKey(0);  

	return 0;  
}</code></pre> 
  <p></p> 
  <br> 
  <span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">运行截图：</span> 
  <p></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><span style="font-family: 'Microsoft YaHei';font-size:14px;"><img src="https://images2.imgbox.com/1e/77/zTis0lbR_o.jpg" width="787" height="810" alt=""><br></span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><span style="font-family: 'Microsoft YaHei';font-size:14px;"><br></span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><span style="font-family: 'Microsoft YaHei';font-size:14px;"><img src="https://images2.imgbox.com/e2/db/vO2CYIzb_o.jpg" alt=""><br></span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <h2><span style="font-family:Microsoft YaHei;font-size:32px;color:#000099;font-weight: normal;">五、源码部分</span></h2> 
  <div> 
   <span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span> 
  </div> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">这个部分就是贴出<span style="font-family: 'Microsoft YaHei';font-size:14px;">OpenCV中</span>本文相关函数的源码实现细节，来给想了解实现细节的小伙伴们参考的</span><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;">，浅墨就暂时不在源码的细节上挖深作详细注释了。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <h3><span style="font-family:Microsoft YaHei;font-size:32px;color:#999999;font-weight: normal;">5.1 </span><span style="font-family:Microsoft YaHei;font-size:24px;color:#990000;font-weight: normal;">OpenCV2.X中HoughLines( )函数源码</span></h3> 
  <p></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"></span></p> 
  <pre><code class="language-cpp">void cv::HoughLines( InputArray _image,OutputArray _lines,
                     double rho, double theta,int threshold,
                     double srn, double stn )
{
   Ptr&lt;CvMemStorage&gt; storage = cvCreateMemStorage(STORAGE_SIZE);
   Mat image = _image.getMat();
   CvMat c_image = image;
   CvSeq* seq = cvHoughLines2( &amp;c_image, storage, srn == 0 &amp;&amp;stn == 0 ?
                    CV_HOUGH_STANDARD :CV_HOUGH_MULTI_SCALE,
                    rho, theta, threshold, srn,stn );
   seqToMat(seq, _lines);
}</code></pre> 
  <p></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">可以发现其内部实现是基于OpenCV 1.X旧版的cvHoughLines2函数，我们再来看看其旧版cvHoughLines2的函数源码。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <h5><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></h5> 
  <h3><span style="font-family:Microsoft YaHei;font-size:32px;color:#999999;font-weight: normal;">5.1.1 </span><span style="font-family:Microsoft YaHei;font-size:24px;color:#339999;font-weight: normal;">OpenCV2.X中cvHoughLines2()函数源码</span></h3> 
  <div> 
   <br> 
  </div> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"></span></p> 
  <pre><code class="language-cpp">CV_IMPL CvSeq*
cvHoughLines2( CvArr* src_image, void*lineStorage, int method,
               double rho, double theta, intthreshold,
               double param1, double param2 )
{
   CvSeq* result = 0;
 
   CvMat stub, *img = (CvMat*)src_image;
   CvMat* mat = 0;
   CvSeq* lines = 0;
   CvSeq lines_header;
   CvSeqBlock lines_block;
   int lineType, elemSize;
   int linesMax = INT_MAX;
   int iparam1, iparam2;
 
   img = cvGetMat( img, &amp;stub );
 
   if( !CV_IS_MASK_ARR(img))
       CV_Error( CV_StsBadArg, "The source image must be 8-bit,single-channel" );
 
   if( !lineStorage )
       CV_Error( CV_StsNullPtr, "NULL destination" );
 
   if( rho &lt;= 0 || theta &lt;= 0 || threshold &lt;= 0 )
       CV_Error( CV_StsOutOfRange, "rho, theta and threshold must bepositive" );
 
   if( method != CV_HOUGH_PROBABILISTIC )
    {
       lineType = CV_32FC2;
       elemSize = sizeof(float)*2;
    }
   else
    {
       lineType = CV_32SC4;
       elemSize = sizeof(int)*4;
    }
 
   if( CV_IS_STORAGE( lineStorage ))
    {
       lines = cvCreateSeq( lineType, sizeof(CvSeq), elemSize,(CvMemStorage*)lineStorage );
    }
   else if( CV_IS_MAT( lineStorage ))
    {
       mat = (CvMat*)lineStorage;
 
       if( !CV_IS_MAT_CONT( mat-&gt;type ) || (mat-&gt;rows != 1 &amp;&amp;mat-&gt;cols != 1) )
           CV_Error( CV_StsBadArg,
           "The destination matrix should be continuous and have a single rowor a single column" );
 
       if( CV_MAT_TYPE( mat-&gt;type ) != lineType )
           CV_Error( CV_StsBadArg,
           "The destination matrix data type is inappropriate, see themanual" );
 
       lines = cvMakeSeqHeaderForArray( lineType, sizeof(CvSeq), elemSize,mat-&gt;data.ptr,
                                        mat-&gt;rows + mat-&gt;cols - 1, &amp;lines_header, &amp;lines_block );
       linesMax = lines-&gt;total;
       cvClearSeq( lines );
    }
   else
       CV_Error( CV_StsBadArg, "Destination is not CvMemStorage* norCvMat*" );
 
   iparam1 = cvRound(param1);
   iparam2 = cvRound(param2);
 
   switch( method )
    {
   case CV_HOUGH_STANDARD:
         icvHoughLinesStandard( img, (float)rho,
               (float)theta, threshold,lines, linesMax );
         break;
   case CV_HOUGH_MULTI_SCALE:
         icvHoughLinesSDiv( img, (float)rho, (float)theta,
                threshold, iparam1, iparam2,lines, linesMax );
         break;
   case CV_HOUGH_PROBABILISTIC:
         icvHoughLinesProbabilistic( img, (float)rho, (float)theta,
                threshold, iparam1, iparam2,lines, linesMax );
         break;
   default:
       CV_Error( CV_StsBadArg, "Unrecognized method id" );
    }
 
   if( mat )
    {
       if( mat-&gt;cols &gt; mat-&gt;rows )
           mat-&gt;cols = lines-&gt;total;
       else
           mat-&gt;rows = lines-&gt;total;
    }
   else
       result = lines;
 
   return result;
}</code></pre> 
  <p></p> 
  <br> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <h4><span style="font-family:Microsoft YaHei;font-size:32px;color:#999999;font-weight: normal;">5.2 </span><span style="font-size:24px;color:#cc0000;"><span style="font-family: 'Microsoft YaHei'; font-weight: normal;">OpenCV2.X中</span><span style="font-family: 'Microsoft YaHei'; font-weight: normal;">HoughLinesP</span><span style="font-family: 'Microsoft YaHei'; font-weight: normal;">()函数源码</span></span></h4> 
  <p><br></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"></span></p> 
  <pre><code class="language-cpp">void cv::HoughLinesP( InputArray _image,OutputArray _lines,
                      double rho, double theta,int threshold,
                      double minLineLength,double maxGap )
{
   Ptr&lt;CvMemStorage&gt; storage = cvCreateMemStorage(STORAGE_SIZE);
   Mat image = _image.getMat();
   CvMat c_image = image;
    CvSeq*seq = cvHoughLines2( &amp;c_image, storage, CV_HOUGH_PROBABILISTIC,
                    rho, theta, threshold,minLineLength, maxGap );
   seqToMat(seq, _lines);
}</code></pre> 
  <br> 
  <br> 
  <p></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">可以发现其内部内部实现依然是基于旧版OpenCV 1.X的<span style="font-family: 'Microsoft YaHei'; font-size: 14px;">cvHoughLines2</span>函数的，上面我们已经将<span style="font-family: 'Microsoft YaHei'; font-size: 14px;">cvHoughLines2（）</span>贴出来了，这里就不再次贴出了。</span></p> 
  <p><br></p> 
  <br> 
  <p></p> 
  <p><br></p> 
  <h4><span style="font-family:Microsoft YaHei;font-size:32px;color:#999999;font-weight: normal;">5.3 </span><span style="font-family:Microsoft YaHei;font-size:24px;color:#339999;font-weight: normal;">OpenCV2.X中HoughCircles()函数源码</span></h4> 
  <p></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"></span></p> 
  <pre><code class="language-cpp">void cv::HoughCircles( InputArray _image,OutputArray _circles,
                       int method, double dp,double min_dist,
                       double param1, doubleparam2,
                       int minRadius, int maxRadius )
{
   Ptr&lt;CvMemStorage&gt; storage = cvCreateMemStorage(STORAGE_SIZE);
   Mat image = _image.getMat();
   CvMat c_image = image;
   CvSeq* seq = cvHoughCircles( &amp;c_image, storage, method,
                    dp, min_dist, param1,param2, minRadius, maxRadius );
   seqToMat(seq, _circles);
}</code></pre> 
  <br> 
  <p></p> 
  <p><span style="font-weight: normal;"><span style="font-family: 'Microsoft YaHei'; font-size: 14px;">可以发现其内部内部实现是基于旧版OpenCV 1.X的cvHoughCircles，我们再来看看其旧版</span></span><span style="font-weight: normal; font-size: 12px;"><span style="font-family:Microsoft YaHei;font-size:14px;">cvHoughCircles( )</span></span><span style="font-weight: normal; font-family: 'Microsoft YaHei'; font-size: 14px;">的函数源码。</span></p> 
  <p><span style="font-family: 'Microsoft YaHei'; font-size: 14px; font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <h5><span style="font-family:Microsoft YaHei;font-size:32px;color:#999999;font-weight: normal;">5.3.1 </span><span style="font-family:Microsoft YaHei;font-size:24px;color:#ff0000;font-weight: normal;">OpenCV2.X中cvHoughCircles()函数源码</span></h5> 
  <div> 
   <br> 
  </div> 
  <br> 
  <span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"></span> 
  <pre><code class="language-cpp">CV_IMPL CvSeq*
cvHoughCircles( CvArr* src_image, void*circle_storage,
                int method, double dp, doublemin_dist,
                double param1, double param2,
                int min_radius, int max_radius)
{
   CvSeq* result = 0;
 
   CvMat stub, *img = (CvMat*)src_image;
   CvMat* mat = 0;
   CvSeq* circles = 0;
   CvSeq circles_header;
   CvSeqBlock circles_block;
   int circles_max = INT_MAX;
   int canny_threshold = cvRound(param1);
   int acc_threshold = cvRound(param2);
 
   img = cvGetMat( img, &amp;stub );
 
   if( !CV_IS_MASK_ARR(img))
       CV_Error( CV_StsBadArg, "The source image must be 8-bit,single-channel" );
 
   if( !circle_storage )
       CV_Error( CV_StsNullPtr, "NULL destination" );
 
   if( dp &lt;= 0 || min_dist &lt;= 0 || canny_threshold &lt;= 0 ||acc_threshold &lt;= 0 )
       CV_Error( CV_StsOutOfRange, "dp, min_dist, canny_threshold andacc_threshold must be all positive numbers" );
 
   min_radius = MAX( min_radius, 0 );
   if( max_radius &lt;= 0 )
       max_radius = MAX( img-&gt;rows, img-&gt;cols );
   else if( max_radius &lt;= min_radius )
       max_radius = min_radius + 2;
 
   if( CV_IS_STORAGE( circle_storage ))
    {
       circles = cvCreateSeq( CV_32FC3, sizeof(CvSeq),
           sizeof(float)*3, (CvMemStorage*)circle_storage );
    }
   else if( CV_IS_MAT( circle_storage ))
    {
       mat = (CvMat*)circle_storage;
 
       if( !CV_IS_MAT_CONT( mat-&gt;type ) || (mat-&gt;rows != 1 &amp;&amp;mat-&gt;cols != 1) ||
           CV_MAT_TYPE(mat-&gt;type) != CV_32FC3 )
           CV_Error( CV_StsBadArg,
           "The destination matrix should be continuous and have a single rowor a single column" );
 
       circles = cvMakeSeqHeaderForArray( CV_32FC3, sizeof(CvSeq),sizeof(float)*3,
                mat-&gt;data.ptr, mat-&gt;rows +mat-&gt;cols - 1, &amp;circles_header, &amp;circles_block );
       circles_max = circles-&gt;total;
       cvClearSeq( circles );
    }
   else
       CV_Error( CV_StsBadArg, "Destination is not CvMemStorage* norCvMat*" );
 
   switch( method )
    {
   case CV_HOUGH_GRADIENT:
       icvHoughCirclesGradient( img, (float)dp, (float)min_dist,
                                min_radius,max_radius, canny_threshold,
                                acc_threshold,circles, circles_max );
         break;
   default:
       CV_Error( CV_StsBadArg, "Unrecognized method id" );
    }
 
   if( mat )
    {
       if( mat-&gt;cols &gt; mat-&gt;rows )
           mat-&gt;cols = circles-&gt;total;
       else
           mat-&gt;rows = circles-&gt;total;
    }
   else
       result = circles;
 
   return result;
}</code></pre> 
  <br> 
  <br> 
 </blockquote> 
 <blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"> 
  <p></p> 
  <p><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;"><br></span></p> 
  <p><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;"><br></span></p> 
  <p><span style="font-weight: normal; font-family: 'Microsoft YaHei';font-size:14px;"><br></span></p> 
  <p><span style="font-weight: normal;"><span style="font-family:Microsoft YaHei;font-size:32px;color:#006600;">五、综合示例部分</span></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">这次的综合示例，浅墨在HoughLinesP函数的基础上，为其添加了用于控制其第五个参数阈值threshold的滚动条。于是便能通过调节滚动条，改变阈值，动态地控制霍夫线变换检测的线条多少。</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">废话不多说，直接上详细注释的代码：</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"></span></p> 
  <pre><code class="language-cpp">//-----------------------------------【程序说明】----------------------------------------------
//		程序名称:：《【OpenCV入门教程之十四】OpenCV霍夫变换：霍夫线变换，霍夫圆变换合辑 》 博文配套源码 
//		开发所用IDE版本：Visual Studio 2010
//   		开发所用OpenCV版本：	2.4.9
//		2014年5月26日 Created by 浅墨
//----------------------------------------------------------------------------------------------

//-----------------------------------【头文件包含部分】---------------------------------------
//		描述：包含程序所依赖的头文件
//---------------------------------------------------------------------------------------------- 
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;

//-----------------------------------【命名空间声明部分】--------------------------------------
//		描述：包含程序所使用的命名空间
//----------------------------------------------------------------------------------------------- 
using namespace std;
using namespace cv;


//-----------------------------------【全局变量声明部分】--------------------------------------
//		描述：全局变量声明
//-----------------------------------------------------------------------------------------------
Mat g_srcImage, g_dstImage,g_midImage;//原始图、中间图和效果图
vector&lt;Vec4i&gt; g_lines;//定义一个矢量结构g_lines用于存放得到的线段矢量集合
//变量接收的TrackBar位置参数
int g_nthreshold=100;

//-----------------------------------【全局函数声明部分】--------------------------------------
//		描述：全局函数声明
//-----------------------------------------------------------------------------------------------

static void on_HoughLines(int, void*);//回调函数
static void ShowHelpText();


//-----------------------------------【main( )函数】--------------------------------------------
//		描述：控制台应用程序的入口函数，我们的程序从这里开始
//-----------------------------------------------------------------------------------------------
int main( )
{
	//改变console字体颜色
	system("color 3F");  

	ShowHelpText();

	//载入原始图和Mat变量定义   
	Mat g_srcImage = imread("1.jpg");  //工程目录下应该有一张名为1.jpg的素材图

	//显示原始图  
	imshow("【原始图】", g_srcImage);  

	//创建滚动条
	namedWindow("【效果图】",1);
	createTrackbar("值", "【效果图】",&amp;g_nthreshold,200,on_HoughLines);

	//进行边缘检测和转化为灰度图
	Canny(g_srcImage, g_midImage, 50, 200, 3);//进行一次canny边缘检测
	cvtColor(g_midImage,g_dstImage, CV_GRAY2BGR);//转化边缘检测后的图为灰度图

	//调用一次回调函数，调用一次HoughLinesP函数
	on_HoughLines(g_nthreshold,0);
	HoughLinesP(g_midImage, g_lines, 1, CV_PI/180, 80, 50, 10 );

	//显示效果图  
	imshow("【效果图】", g_dstImage);  


	waitKey(0);  

	return 0;  

}


//-----------------------------------【on_HoughLines( )函数】--------------------------------
//		描述：【顶帽运算/黑帽运算】窗口的回调函数
//----------------------------------------------------------------------------------------------
static void on_HoughLines(int, void*)
{
	//定义局部变量储存全局变量
	 Mat dstImage=g_dstImage.clone();
	 Mat midImage=g_midImage.clone();

	 //调用HoughLinesP函数
	 vector&lt;Vec4i&gt; mylines;
	HoughLinesP(midImage, mylines, 1, CV_PI/180, g_nthreshold+1, 50, 10 );

	//循环遍历绘制每一条线段
	for( size_t i = 0; i &lt; mylines.size(); i++ )
	{
		Vec4i l = mylines[i];
		line( dstImage, Point(l[0], l[1]), Point(l[2], l[3]), Scalar(23,180,55), 1, CV_AA);
	}
	//显示图像
	imshow("【效果图】",dstImage);
}

//-----------------------------------【ShowHelpText( )函数】----------------------------------
//		描述：输出一些帮助信息
//----------------------------------------------------------------------------------------------
static void ShowHelpText()
{
	//输出一些帮助信息
	printf("\n\n\n\t请调整滚动条观察图像效果~\n\n");
	printf("\n\n\t\t\t\t\t\t\t\t by浅墨"
		);
}</code></pre> 
  <p></p> 
  <br> 
  <span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span> 
 </blockquote> 
 <blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"> 
  <span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span> 
 </blockquote> 
 <blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"> 
  <span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">放一些运行截图吧。</span> 
  <p></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">原始图：</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><img src="https://images2.imgbox.com/ca/cd/Kbd0maoU_o.jpg" alt=""><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">阈值为95时：</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><img src="https://images2.imgbox.com/70/c2/VCV3XMSD_o.jpg" alt=""><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> 阈值为35时：</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><img src="https://images2.imgbox.com/a6/8f/KOFPyIuD_o.jpg" alt=""><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"> </span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;">阈值为200时：</span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><img src="https://images2.imgbox.com/2f/27/uY5fGg1t_o.jpg" alt=""><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"><br></span></p> 
  <p><span style="font-family:Microsoft YaHei;font-size:14px;font-weight: normal;"></span></p> 
  <p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px;"><span style="font-family: 'Microsoft YaHei'; font-size: 32px; color: rgb(0, 153, 0); font-weight: normal;">本篇文章的配套源代码请点击这里下载：</span></p> 
  <p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px;"><span style="font-family: 'Microsoft YaHei'; font-weight: normal;"> </span></p> 
  <p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px;"><span style="font-family: 'Microsoft YaHei'; font-size: 32px;"><span style="color: rgb(204, 0, 0); text-decoration: none; font-weight: normal;"><a target="_blank" href="http://download.csdn.net/detail/zhmxy555/7402125" style="color: rgb(202, 0, 0); text-decoration: none;" rel="noopener noreferrer">【浅墨OpenCV入门教程之十四】配套源代码下载</a></span></span></p> 
  <p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px;"><span style="font-family: 'Microsoft YaHei';"> </span></p> 
  <p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; font-family: Arial; font-size: 14px; line-height: 26px;"><span style="font-family: 'Microsoft YaHei';"> <img src="https://images2.imgbox.com/35/eb/5QdeRBtv_o.jpg" alt=""></span></p> 
  <p style="margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; line-height: 26px;"><span style="font-weight: normal;"><span style="font-family:Microsoft YaHei;font-size:14px;">OK，今天的内容大概就是这些，我们下篇文章见：）</span></span></p> 
  <br> 
 </blockquote></h3>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dc7cea9851f24a8398c57d05e57efbc3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【图文】Latex 中文字体的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eed518d97b5ac4b9772a70e7f60e842f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">authz-db = authz 引起的 svn 认证失败</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>