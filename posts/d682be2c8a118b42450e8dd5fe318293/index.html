<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux驱动进阶(四)——内外存访问 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux驱动进阶(四)——内外存访问" />
<meta property="og:description" content="文章目录 前言内存分配kmalloc函数vmalloc()函数后备高速缓存 页面分配内存分配物理地址和虚拟地址之间的转换 设备I/O端口的访问Linux I/O端口读写函数I/O内存读写使用I/O端口 小结 前言 驱动程序加载成功的一个关键因素，就是内核能够为驱动程序分配足够的内存空间。这些控件一部分用于驱动程序必要的数据结构，另一部分用于数据交换。同时，内核也应该具有访问外部设备端口的能力。一般来说，外部设备被连接到内存空间或者I/O空间中。本章将对内外存设备的访问进行详细的介绍。
内存分配 本节主要介绍内存分配的一些函数，包括kmalloc()函数和vmalloc()函数等。在介绍完这两个重要的函数之后，将重点讲解后备高速缓存的内容，这些知识对于驱动开发来说非常重要，需要引起注意。
kmalloc函数 在C语言中，经常会遇到malloc()和free()这两个函数“冤家”。malloc()函数用来进行内存分配，free()函数用来释放内存。kmalloc()函数类似于malloc()函数，不同的是kmalloc()函数用于内核态的内存分配。kmalloc()函数是一个功能强大的函数，如果内存充足，这个函数将运行的非常快。
kmalloc()函数在物理内存中为程序分配一个连续的存储空间。这个存储空间的数据不会被清零，也就是保存内存中原有的数据，在使用的时候需要引起注意。kmalloc()函数运行很快。可以传递标志给它，不允许其在分配内存时阻塞。kmalloc()函数原型如下：
static inline void *kmalloc(size_t size, gfp_t flags) kmalloc()函数的第一个参数是size，表示分配内存的大小。第2个参数是分配标志，可以通过这个标志控制kmalloc()函数的多种分配方式。和其他函数不同，kmalloc()函数的这两个参数非常重要，下面将对这两个参数详细的解释。
1.size参数
size参数涉及内存管理的问题，内存管理是Linux子系统中非常重要的一部分。Linux的内存管理方式限定了内存只能按照页面的大小进行内存分配。通常，页面大小为4K。如果使用kmalloc()函数为某个驱动程序分配4字节的内存空间，则Linux会返回一个页面4K的内存空间，这显然是一种内存浪费。
因为空间浪费的原因，kmalloc()函数与用户空间malloc()函数的实现完全不同。malloc()函数在堆中分配内存空间，分配的空间大小非常灵活，而kmalloc()函数分配内存空间的方法比较特殊，下面对这种方法进行简要的解释。
Linux内核对kmalloc()函数的处理方式是，先分配一系列不同大小的内存池，每个池中的内存大小是固定的。当分配内存时，将包含足够大的内存池中的内存传递给kmalloc()函数。在分配内存时，Linux内核只能分配预定义、固定大小的字节数。如果申请的内存大小不是2的整数倍，则会多申请一些内存，将大于申请内存的内存区块返回给请求者。
Linux内核为kmalloc()函数提供了大小为32字节、64字节、128字节、256字节、512字节、1024字节、2048字节、4096字节、8KB、16KB、32KB、64KB和128KB的内存池。所以程序员应该注意，kmalloc()函数最小能够分配32字节的内存，如果请求的内存小于32字节，那么也会返回32字节。kmalloc()函数能够分配的内存块的大小，也存在一个上限。为了代码的可移植性，这个上限一般是128KB。如果希望分配更多的内存，最好使用其他的内存分配方法。
2.flags参数
flags参数能够以多种方式控制kmalloc()函数的行为。最常用的申请内存的参数是GFP_KERNEL。使用这个参数运行调用它的进程在内存较少时进入睡眠，当内存充足时再分配页面。因此，使用GFP_KERNEL标志可能会引起阻塞，对于不允许阻塞的应用，应该使用其他的申请内存标志。在进程睡眠时，内核子系统会将缓冲区的内容写入磁盘，从而为睡眠的进程留出更多的空间。
在中断处理程序、等待队列等函数中不能使用GFP_KERNEL标志，因为这个标志可能会引起调用者的睡眠。当睡眠之后再唤醒，很多程序会出现错误。这种情况下可以使用GFP_ATOMIC标志，表示原子性的分配内存，也就是在分配内存的过程中不允许睡眠。为什么GFP_ATOMIC标志不会引起睡眠呢？这是因为内核为这种分配方式预留了一些内存空间，这些内存空间只有在kmalloc()函数传递标志为GFP_ATOMIC时，才会使用。在大多数情况下，GFP_ATOMIC标志的分配方式会成功，并即时返回。
除了GFP_KERNEL和GFP_ATOMIC标志外，还会有一些其他的标志，但其他的标志并不常用。这些标志的意义和使用方法如下表。
vmalloc()函数 vmalloc()函数用来分配虚拟地址连续但是物理地址不连续的内存。这就是说，用vmalloc()函数分配的页在虚拟地址空间中是连续的，而在物理地址空间中是不连续的。这是因为如果需要分配200M的内存空间，而实际的物理内存中现在不存在一块连续的200M内存空间，但是内存有大量的内存碎片，其容量大于200M，那么就可以使用vmalloc()函数将不连续的物理地址空间映射层连续的虚拟地址空间。
从执行效率上来讲，vmalloc()函数的运行开销远远大于__get_free_pages()函数。因为vmalloc()函数会建立新的页表，将不连续的物理内存映射成连续的虚拟内存，所以开销比较大。另外，由于新页表的建立，vmalloc()函数也更浪费CPU时间，而且需要更多的内存来存放页表。一般来说，vmalloc()函数用来申请大量的内存，对于少量的内存，最好使用__get_free_pages()函数来申请。
1.vmalloc()函数申请和释放
vmalloc()函数定义在mm\vmalloc.c文件中，该函数的原型如下：
void *vmalloc(unsigned long size) vmalloc()函数接收一个参数，size是分配连续内存的大小。如果函数执行成功，则返回虚拟地址连续的一块内存区域。为了释放内存，Linux内核也提供了一个释放由vmalloc()函数分配的内存，这个函数是vfree()函数，其代码如下：
void vfree(const void *addr) 2.vmalloc()函数举例
vmalloc()函数在功能上与kmalloc()函数不同，但在使用上基本相同。首先使用vmalloc()函数分配一个内存空间，并返回一个虚拟地址。内存分配是一项要求严格的任务，无论什么时候，都应该对返回值进行检测。当分配内存后，可以使用copy_from_user()对内存进行访问。也可以将返回的内存空间转换为一个结构体，像下面代码的12~15行一样使用vmalloc()分配的内存空间。在不需要使用内存时，可以使用20行的vfree()函数释放内存。在驱动程序中，使用vmalloc()函数的一个实例如xxx()函数所示：
static int xxx(...) { ... /*省略代码*/ cpuid_entires - vmalloc(sizeof(struct kvm_cpuid_entry) * cpuid-&gt;nent ); if(!cpuid_entries) goto out; if(copy_from_user(cpuid_entries, entries, cpuid-&gt;nent * sizeof(struct kvm_cpuid_entry))) goto out_free; for(i=0; i&lt; cpuid-&gt;nent; i&#43;&#43;){ vcpu-&gt;arch." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/d682be2c8a118b42450e8dd5fe318293/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-14T20:51:11+08:00" />
<meta property="article:modified_time" content="2023-07-14T20:51:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux驱动进阶(四)——内外存访问</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_4" rel="nofollow">前言</a></li><li><a href="#_6" rel="nofollow">内存分配</a></li><li><ul><li><a href="#kmalloc_8" rel="nofollow">kmalloc函数</a></li><li><a href="#vmalloc_25" rel="nofollow">vmalloc()函数</a></li><li><a href="#_62" rel="nofollow">后备高速缓存</a></li></ul> 
  </li><li><a href="#_108" rel="nofollow">页面分配</a></li><li><ul><li><a href="#_110" rel="nofollow">内存分配</a></li><li><a href="#_188" rel="nofollow">物理地址和虚拟地址之间的转换</a></li></ul> 
  </li><li><a href="#IO_209" rel="nofollow">设备I/O端口的访问</a></li><li><ul><li><a href="#Linux_IO_211" rel="nofollow">Linux I/O端口读写函数</a></li><li><a href="#IO_216" rel="nofollow">I/O内存读写</a></li><li><a href="#IO_345" rel="nofollow">使用I/O端口</a></li></ul> 
  </li><li><a href="#_400" rel="nofollow">小结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_4"></a>前言</h2> 
<p>驱动程序加载成功的一个关键因素，就是内核能够为驱动程序分配足够的内存空间。这些控件一部分用于驱动程序必要的数据结构，另一部分用于数据交换。同时，内核也应该具有访问外部设备端口的能力。一般来说，外部设备被连接到内存空间或者I/O空间中。本章将对内外存设备的访问进行详细的介绍。</p> 
<h2><a id="_6"></a>内存分配</h2> 
<p>本节主要介绍内存分配的一些函数，包括<code>kmalloc()</code>函数和<code>vmalloc()</code>函数等。在介绍完这两个重要的函数之后，将重点讲解后备高速缓存的内容，这些知识对于驱动开发来说非常重要，需要引起注意。</p> 
<h3><a id="kmalloc_8"></a>kmalloc函数</h3> 
<p>在C语言中，经常会遇到<code>malloc()和free()</code>这两个函数“冤家”。<code>malloc()</code>函数用来进行内存分配，<code>free()</code>函数用来释放内存。<code>kmalloc()</code>函数类似于<code>malloc()</code>函数，不同的是<code>kmalloc()</code>函数用于内核态的内存分配。<code>kmalloc()</code>函数是一个功能强大的函数，如果内存充足，这个函数将运行的非常快。<br> <code>kmalloc()</code>函数在物理内存中为程序分配一个连续的存储空间。这个存储空间的数据不会被清零，也就是保存内存中原有的数据，在使用的时候需要引起注意。<code>kmalloc()</code>函数运行很快。可以传递标志给它，不允许其在分配内存时阻塞。<code>kmalloc()</code>函数原型如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kmalloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">gfp_t</span> flags<span class="token punctuation">)</span>
</code></pre> 
<p><code>kmalloc()</code>函数的第一个参数是size，表示分配内存的大小。第2个参数是分配标志，可以通过这个标志控制<code>kmalloc()</code>函数的多种分配方式。和其他函数不同，<code>kmalloc()</code>函数的这两个参数非常重要，下面将对这两个参数详细的解释。<br> <code>1.size参数</code><br> size参数涉及内存管理的问题，内存管理是Linux子系统中非常重要的一部分。Linux的内存管理方式限定了内存只能按照页面的大小进行内存分配。通常，页面大小为4K。如果使用<code>kmalloc()</code>函数为某个驱动程序分配4字节的内存空间，则Linux会返回一个页面4K的内存空间，这显然是一种内存浪费。<br> 因为空间浪费的原因，<code>kmalloc()</code>函数与用户空间<code>malloc()</code>函数的实现完全不同。<code>malloc()</code>函数在堆中分配内存空间，分配的空间大小非常灵活，而<code>kmalloc()</code>函数分配内存空间的方法比较特殊，下面对这种方法进行简要的解释。<br> Linux内核对<code>kmalloc()</code>函数的处理方式是，先分配一系列不同大小的内存池，每个池中的内存大小是固定的。当分配内存时，将包含足够大的内存池中的内存传递给<code>kmalloc()</code>函数。在分配内存时，Linux内核只能分配预定义、固定大小的字节数。如果申请的内存大小不是2的整数倍，则会多申请一些内存，将大于申请内存的内存区块返回给请求者。<br> Linux内核为<code>kmalloc()</code>函数提供了大小为32字节、64字节、128字节、256字节、512字节、1024字节、2048字节、4096字节、8KB、16KB、32KB、64KB和128KB的内存池。所以程序员应该注意，<code>kmalloc()</code>函数最小能够分配32字节的内存，如果请求的内存小于32字节，那么也会返回32字节。<code>kmalloc()</code>函数能够分配的内存块的大小，也存在一个上限。为了代码的可移植性，这个上限一般是128KB。如果希望分配更多的内存，最好使用其他的内存分配方法。<br> <code>2.flags参数</code><br> <code>flags</code>参数能够以多种方式控制<code>kmalloc()</code>函数的行为。最常用的申请内存的参数是<code>GFP_KERNEL</code>。使用这个参数运行调用它的进程在内存较少时进入睡眠，当内存充足时再分配页面。因此，使用<code>GFP_KERNEL</code>标志可能会引起阻塞，对于不允许阻塞的应用，应该使用其他的申请内存标志。在进程睡眠时，内核子系统会将缓冲区的内容写入磁盘，从而为睡眠的进程留出更多的空间。<br> 在中断处理程序、等待队列等函数中不能使用<code>GFP_KERNEL</code>标志，因为这个标志可能会引起调用者的睡眠。当睡眠之后再唤醒，很多程序会出现错误。这种情况下可以使用<code>GFP_ATOMIC</code>标志，表示原子性的分配内存，也就是在分配内存的过程中不允许睡眠。为什么<code>GFP_ATOMIC</code>标志不会引起睡眠呢？这是因为内核为这种分配方式预留了一些内存空间，这些内存空间只有在<code>kmalloc()</code>函数传递标志为<code>GFP_ATOMIC</code>时，才会使用。在大多数情况下，<code>GFP_ATOMIC</code>标志的分配方式会成功，并即时返回。<br> 除了<code>GFP_KERNEL</code>和<code>GFP_ATOMIC</code>标志外，还会有一些其他的标志，但其他的标志并不常用。这些标志的意义和使用方法如下表。<br> <img src="https://images2.imgbox.com/36/42/nkp3Asb8_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="vmalloc_25"></a>vmalloc()函数</h3> 
<p><code>vmalloc()</code>函数用来分配虚拟地址连续但是物理地址不连续的内存。这就是说，用<code>vmalloc()</code>函数分配的页在虚拟地址空间中是连续的，而在物理地址空间中是不连续的。这是因为如果需要分配200M的内存空间，而实际的物理内存中现在不存在一块连续的200M内存空间，但是内存有大量的内存碎片，其容量大于200M，那么就可以使用<code>vmalloc()</code>函数将不连续的物理地址空间映射层连续的虚拟地址空间。<br> 从执行效率上来讲，<code>vmalloc()</code>函数的运行开销远远大于<code>__get_free_pages()</code>函数。因为<code>vmalloc()</code>函数会建立新的页表，将不连续的物理内存映射成连续的虚拟内存，所以开销比较大。另外，由于新页表的建立，<code>vmalloc()</code>函数也更浪费CPU时间，而且需要更多的内存来存放页表。一般来说，<code>vmalloc()</code>函数用来申请大量的内存，对于少量的内存，最好使用<code>__get_free_pages()</code>函数来申请。<br> <code>1.vmalloc()函数申请和释放</code><br> <code>vmalloc()</code>函数定义在<code>mm\vmalloc.c</code>文件中，该函数的原型如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">vmalloc</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span>
</code></pre> 
<p><code>vmalloc()</code>函数接收一个参数，<code>size</code>是分配连续内存的大小。如果函数执行成功，则返回虚拟地址连续的一块内存区域。为了释放内存，Linux内核也提供了一个释放由<code>vmalloc()</code>函数分配的内存，这个函数是<code>vfree()</code>函数，其代码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">vfree</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">)</span>
</code></pre> 
<p><code>2.vmalloc()</code>函数举例<br> <code>vmalloc()</code>函数在功能上与<code>kmalloc()</code>函数不同，但在使用上基本相同。首先使用<code>vmalloc()</code>函数分配一个内存空间，并返回一个虚拟地址。内存分配是一项要求严格的任务，无论什么时候，都应该对返回值进行检测。当分配内存后，可以使用<code>copy_from_user()</code>对内存进行访问。也可以将返回的内存空间转换为一个结构体，像下面代码的12~15行一样使用<code>vmalloc()</code>分配的内存空间。在不需要使用内存时，可以使用20行的<code>vfree()</code>函数释放内存。在驱动程序中，使用<code>vmalloc()</code>函数的一个实例如<code>xxx()</code>函数所示：</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">xxx</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">/*省略代码*/</span>
	cpuid_entires <span class="token operator">-</span> <span class="token function">vmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_cpuid_entry</span><span class="token punctuation">)</span> <span class="token operator">*</span> cpuid<span class="token operator">-&gt;</span>nent <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>cpuid_entries<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> out<span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>cpuid_entries<span class="token punctuation">,</span> entries<span class="token punctuation">,</span> cpuid<span class="token operator">-&gt;</span>nent <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_cpuid_entry</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">goto</span> out_free<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> cpuid<span class="token operator">-&gt;</span>nent<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		vcpu<span class="token operator">-&gt;</span>arch<span class="token punctuation">.</span>cpuid_emtries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>eax <span class="token operator">=</span> cpuid_entries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>eax<span class="token punctuation">;</span>
		vcpu<span class="token operator">-&gt;</span>arch<span class="token punctuation">.</span>cpuid_emtries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>ebx<span class="token operator">=</span> cpuid_entries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>ebx<span class="token punctuation">;</span>
		vcpu<span class="token operator">-&gt;</span>arch<span class="token punctuation">.</span>cpuid_emtries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>ecx<span class="token operator">=</span> cpuid_entries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>ecx<span class="token punctuation">;</span>
		vcpu<span class="token operator">-&gt;</span>arch<span class="token punctuation">.</span>cpuid_emtries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>edx<span class="token operator">=</span> cpuid_entries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>edx<span class="token punctuation">;</span>
		vcpu<span class="token operator">-&gt;</span>arch<span class="token punctuation">.</span>cpuid_emtries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">/*省略代码*/</span>
out_free<span class="token operator">:</span>
	<span class="token function">vfree</span><span class="token punctuation">(</span>cpuid_entries<span class="token punctuation">)</span><span class="token punctuation">;</span>
out<span class="token operator">:</span>
	<span class="token keyword">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_62"></a>后备高速缓存</h3> 
<p>在驱动程序中，会经常反复地分配很多同一大小的内存块，也会频繁的将这些内存块给释放掉。如果频繁的申请和释放内存，很容易产生内存碎片，使用内存池很好地解决了这个问题。在Linux中，为一些反复分配和释放的结构体预留了一些内存空间，使用内存池来管理，管理这种内存池的技术叫做<code>slab</code>分配器。这种内存叫做后备高速缓存。<br> <code>slab</code>分配器的相关函数定义在<code>&lt;linux/slab.h&gt;</code>文件中，使用后备高速缓存前，需要创建一个<code>kernel_cache</code>的结构体。<br> <code>1.创建slab缓存函数</code><br> 在使用<code>slab</code>缓存前，需要先调用<code>kmem_cache_create()</code>函数创建一块<code>slab</code>缓存，该函数的代码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span><span class="token function">kmem_cache_create</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">size_t</span> align<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>ctor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>该函数创建一个新的后备高速缓存对象，这个缓存区中可以容纳指定个数的内存块。内存块的数目由参数<code>size</code>来指定。参数<code>name</code>表示该后备高速缓存对象的名字，以后可以使用<code>name</code>来表示使用那个后备高速缓存。<br> <code>kmem_cache_create()</code>函数的第3个参数<code>align</code>是后备高速缓存中第一个对象的偏移值，这个值一般情况下被置为0。第4个参数<code>flage</code>是一个位掩码，表示控制如何完成分配工作。第5个参数<code>ctor</code>是一个可选的函数，用来对加入后备高速缓存中的内存块进行初始化。</p> 
<pre><code class="prism language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bio</span><span class="token punctuation">)</span> <span class="token operator">+</span> extra_size<span class="token punctuation">;</span>
slab <span class="token operator">=</span> <span class="token function">kmem_cache_create</span><span class="token punctuation">(</span><span class="token string">"DRIVER_NAME"</span><span class="token punctuation">,</span> sz<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SLAB_HWCACHE_ALIGN<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>2.分配slab缓存函数</code><br> 一旦调用<code>kmem_cache_create()</code>函数创建了后备高速缓存，就可以调用<code>kmem_cache_alloc()</code>函数创建内存块对象。<code>kmem_cache_alloc()</code>函数原型如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>cachep<span class="token punctuation">,</span> <span class="token class-name">gfp_t</span> flags<span class="token punctuation">)</span>
</code></pre> 
<p>该函数的第1个参数<code>cachep</code>是开始分配的后备高速缓存。第二个参数<code>flags</code>与传递给<code>kmalloc()</code>函数的参数相同，一般为<code>GFP_KERNEL</code>。<br> 与<code>kmem_cache_alloc()</code>函数对应的释放函数是<code>kmem_cache_free()</code>函数，该函数释放一个内存块对象。其函数原型如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">kmem_cache_free</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>cachep<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>objp<span class="token punctuation">)</span>
</code></pre> 
<p><code>3.销毁slab缓存函数</code><br> 与<code>kmem_cache_create()</code>函数对应的释放函数是<code>kmem_cache_destroy()</code>函数，该函数释放一个后备高速缓存。其函数的原型如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span>  <span class="token function">kmem_cache_destroy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>c<span class="token punctuation">)</span>
</code></pre> 
<p>该函数只有在后备高速缓存区中的所有内存块对象都调用<code>kmem_cache_free()</code>函数释放后，才能销毁后备高速缓存。<br> <code>4.slab缓存举例</code><br> 一个使用后备高速缓存的例子如下代码所示，这段代码创建了一个存放<code>struct thread_info</code>结构体的后备高速缓存，这个结构体表示线程结构体。在Linux中，涉及大量线程的创建和销毁，如果使用<code>__get_free_pages()</code>函数会造成内存的大量浪费，而且效率也比较低。对于线程结构体，在内核初始化阶段，就创建了一个名为<code>thread_info</code>的后备高速缓存，代码如下：</p> 
<pre><code class="prism language-c"><span class="token comment">/*以下两行创建slab缓存*/</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>thread_info_cache<span class="token punctuation">;</span> 
		<span class="token comment">/*声明一个struct kmem_cache的指针*/</span>
thread_info_cache <span class="token operator">=</span> <span class="token function">kmem_cache_create</span><span class="token punctuation">(</span><span class="token string">"thread_info"</span><span class="token punctuation">,</span> THREAD_SIZE<span class="token punctuation">,</span>
					THREAD_SIZE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*创建一个后备高速缓存区*/</span>
<span class="token comment">/*以下两行分配slab缓存*/</span>
<span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span>ti<span class="token punctuation">;</span>   <span class="token comment">/*线程结构体指针*/</span>
ti <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>thread_info_cache<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*分配一个结构体*/</span>
<span class="token comment">/*省略了使用slab缓存的函数*/</span>
<span class="token comment">/*以下两行释放slab缓存*/</span>
<span class="token function">kmem_cache_free</span><span class="token punctuation">(</span>thread_info_cache<span class="token punctuation">,</span> ti<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/*释放一个结构体*/</span>
<span class="token function">kmem_cache_destroy</span><span class="token punctuation">(</span>thread_info_cache<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/*销毁一个结构体*/</span>
</code></pre> 
<h2><a id="_108"></a>页面分配</h2> 
<p>在Linux中提供了一系列的函数用来分配和释放页面。当一个驱动程序进程需要申请内存时，内核会根据需要分配请求的页面数给申请者。当驱动程序不需要申请内存时，必须释放申请的页面数，以防止内存泄漏。本节将对页面的分配方法进行详细的讲述，这些知识对驱动程序开发非常重要。</p> 
<h3><a id="_110"></a>内存分配</h3> 
<p>Linux内核内存管理子系统提供了一系列函数用来进行内存分配和释放。为了管理方便，Linux中是以页为单位进行内存分配的。在32为机器上，一般一页的大小为4KB；在46位的机器上，一般一页的大小为8KB，具体根据平台而定。当驱动程序的一个进程申请空间时，内存管理子系统会分配所请求的页数给驱动程序。如果驱动程序不需要内存时，也可以释放内存，若将内存归还给内核为其他程序所用。下面介绍内存管理子系统提供了那些函数进行内存的分配和释放。<br> <code>1.内存分配函数的分类</code><br> 从内存管理子系统提供的内存管理函数的返回值将函数分为两类：第一类函数向内存申请者返回一个<code>struct page</code>结构的指针，指向内核分配给申请者的页面。第二类函数返回一个32位的虚拟地址，该地址是分配的页面的虚拟首地址。虚拟地址和物理地址在大多数计算机组成和原理课上都有讲解，希望引起读者的注意。<br> 其次，可以根据函数返回的页面数目对函数进行分类：第一类函数只返回一个页面，第二类函数可以返回多个页面，页面的数目可以由驱动程序开发人员自己指定。内存分配函数分类如下图所示：<br> <img src="https://images2.imgbox.com/0c/bd/J5piQJhQ_o.png" alt="在这里插入图片描述"><br> <code>2.alloc_page()和alloc_pages()</code>函数<br> 返回<code>struct page</code>结构体函数主要有两个：<code>alloc_page()</code>函数和<code>alloc_pages()</code>函数。这两个函数定义在<code>/include/linux/gfp.h</code>文件中。<code>alloc_page()</code>函数分配一个页面，<code>alloc_pages()</code>函数根据用户需要分配多个页面。需要注意的是，这两个函数都返回一个<code>struct page</code>结构体的指针。这两个函数的代码如下：</p> 
<pre><code class="prism language-c"><span class="token comment">/*alloc_page()函数分配一个页面，调用alloc_pages()实现分配一个页面的功能*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">alloc_page</span><span class="token expression"><span class="token punctuation">(</span>gfp_mask<span class="token punctuation">)</span>  <span class="token function">alloc_pages</span><span class="token punctuation">(</span>gfp_mask<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token comment">/*alloc_pages()函数分配多个页面，调用alloc_pages_node()实现分配一个页面的功能*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">alloc_pages</span><span class="token expression"><span class="token punctuation">(</span>gfp_mask<span class="token punctuation">,</span> order<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token function">alloc_pages_node</span><span class="token punctuation">(</span><span class="token function">numa_node_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gfp_mask<span class="token punctuation">,</span> order<span class="token punctuation">)</span></span></span>
<span class="token comment">/*该函数是真正的内存分配函数*/</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">alloc_pages_node</span><span class="token punctuation">(</span><span class="token keyword">int</span> nid<span class="token punctuation">,</span> <span class="token class-name">gfp_t</span> gfp_mask<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>order <span class="token operator">&gt;=</span> MAX_ORDER<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>nid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
		nid <span class="token operator">=</span> <span class="token function">numa_node_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">__alloc_pages</span><span class="token punctuation">(</span>gfp_mask<span class="token punctuation">,</span> order<span class="token punctuation">,</span> <span class="token function">node_zonelist</span><span class="token punctuation">(</span>nid<span class="token punctuation">,</span> gfp_mask<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>下面对这些函数进行详细的解释。</p> 
<ul><li><code>alloc_pages()</code>函数功能是分配多个页面。第一个参数表示分配内存的标志。这个标志与<code>kmalloc()</code>函数的标志相同。准确的说，<code>kmalloc()</code>函数是由<code>alloc_pages()</code>函数实现的，所以它们有相同的内存分配标志。第二个参数<code>order</code>表示分配页面的个数，这些页面是连续的。页面的个数由2的order次方来表示，例如如果只分配一个页面，order的值应该为0。</li><li><code>alloc_pages()</code>函数调用如果成功，会返回指向第一个页面的<code>struct page</code>结构体的指针；如果分配失败，则返回一个NULL值。任何时候内存分配都有可能失败，所以应该在内存分配之后检查其返回值是否合法。</li><li><code>alloc_page()</code>函数定义在2行，其只分配一个页面。这个宏只接收一个<code>gfp_mask</code>参数，表示内存分配的标志。默认情况下<code>order</code>被设置为0，表示函数将分配2的0次方等于1个物理页面给申请进程。<br> <code>3.__get_free_page()和__get_free_pages()</code>函数<br> 第二类函数执行后，返回申请的页面的第一个页面虚拟地址。如果返回多个页面，则只返回第一个页面的虚拟地址。<code>__get_free_page()</code>函数和<code>__get_free_pages()</code>函数就返回一个页面虚拟地址。其中<code>__get_free_page()</code>函数只返回一个页面，<code>__get_free_pages()</code>函数则返回多个页面。这两个函数或宏的代码如下：</li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__get_free_page</span><span class="token expression"><span class="token punctuation">(</span>gfp_mask<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
		<span class="token expression"><span class="token function">__get_free_pages</span><span class="token punctuation">(</span><span class="token punctuation">(</span>gfp_mask<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></span></span>
</code></pre> 
<p><code>__get_free_page</code>宏最终调用<code>__get_free_pages()</code>函数实现的，在调用<code>__get_free_pages()</code>函数时将<code>order</code>的值直接赋为0，这样就只返回一个页面。<code>__get_free_pages()</code>函数不仅可以分配多个连续的页面，而且可以分配一个页面，其代码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">__get_free_pages</span><span class="token punctuation">(</span><span class="token class-name">gfp_t</span> gfp_mask<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
	page <span class="token operator">=</span> <span class="token function">alloc_pages</span><span class="token punctuation">(</span>gfp_mask<span class="token punctuation">,</span> order<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">page_address</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>下面对该函数进行详细的解释：</p> 
<ul><li><code>__get_free_pages()</code>函数接收两个参数。第一个参数与<code>kmalloc()</code>函数的标志是一样的，第二个函数用来表示申请多少页的内存，页数的计算公式为：页数=2的order次方。如果要分配一个页面，那么只需要order等于0就可以了。</li><li>3行，定义了一个<code>struct page</code>的指针。</li><li>4行，调用了<code>alloc_pages()</code>函数分配了2的order次方页的内存空间。</li><li>5、6行，如果内存不足分配失败，返回0。</li><li>7行，调用<code>page_address()</code>函数将物理地址转换为虚拟地址。<br> <code>4.内存释放函数</code><br> 当不再需要内存时，需要将内存还给内存管理系统，否则可能会造成资源泄露。Linux提供了一个函数用来释放内存。在释放内存时，应该给释放函数传递正确的<code>struct page</code>指针或者地址，都在会使内存错误的释放，导致系统崩溃。内存释放函数或宏的定义如下：</li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__free_page</span><span class="token expression"><span class="token punctuation">(</span>page<span class="token punctuation">)</span>  <span class="token function">__free_pages</span><span class="token punctuation">(</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__free_pages</span><span class="token expression"><span class="token punctuation">(</span>addr<span class="token punctuation">)</span> <span class="token function">free_pages</span><span class="token punctuation">(</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span></span></span>
</code></pre> 
<p>这两个函数的代码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">free_pages</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>addr <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">VM_BUG_ON</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">virt_addr_valid</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">__free_pages</span><span class="token punctuation">(</span><span class="token function">virt_to_page</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>addr<span class="token punctuation">)</span><span class="token punctuation">,</span> order<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">__free_pages</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">put_page_testzero</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>order <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token function">free_hot_page</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span>
			<span class="token function">__free_pages_ok</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> order<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>从上面的代码可以看出，<code>free_pages()</code>函数是调用<code>__free_pages()</code>函数完成内存释放的。<code>free_pages()</code>函数的第一个参数是指向内存页面的虚拟地址，第二个参数是需要释放的页面数目，应该和分配页面时的数目相同。</p> 
<h3><a id="_188"></a>物理地址和虚拟地址之间的转换</h3> 
<p>在内存分配的大多数函数中，基本都涉及物理地址和虚拟地址之间的转换。使用<code>virt_to_phys()</code>函数可以将内核虚拟地址转换为物理地址。<code>virt_to_phys()</code>函数定义如下：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__pa</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-</span> PAGE_OFFSET<span class="token punctuation">)</span></span></span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">virt_to_phys</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">void</span> <span class="token operator">*</span>address<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">__pa</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>virt_to_phys()</code>函数调用了<code>__pa</code>宏，<code>__pa</code>宏会将虚拟地址<code>address</code>减去<code>PAGE_OFFSET</code>，通常在32位平台上定义为<code>3GB</code>。<br> 与<code>virt_to_phys()</code>函数对应的函数是<code>phys_to_virt()</code>，这个函数将物理地址转化为内核虚拟地址。<code>phys_to_virt()</code>函数的定义如下：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__va</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> PAGE_OFFSET<span class="token punctuation">)</span></span></span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">phys_to_virt</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> address<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">__va</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>phys_to_virt()</code>函数调用了<code>__va</code>宏，<code>__va</code>宏会将物理地址<code>address</code>加上<code>PAGE_OFFSET</code>，通常在32为平台上定义为3GB。<br> Linux中，物理地址和虚拟地址的关系如下图。在32位计算机中，最大的虚拟地址空间大小是<code>4GB</code>。<code>0~3GB</code>表示用户空间，<code>PAGE_OFFSET</code>被定义为3GB，就是用户空间和内核空间的分界点。Linux内核中，使用3GB~4GB的内核空间来映射实际的物理地址。物理内存可能大于1GB的内核空间，甚至可能大很多。目前，主流的计算机物理内存在4GB左右。这种情况下，Linux使用一种非线性的映射方法，用1GB大小的内核空间来映射有可能大于1GB的物理内存。<br> <img src="https://images2.imgbox.com/4e/ea/q97CNxHR_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="IO_209"></a>设备I/O端口的访问</h2> 
<p>设备有一组外部寄存器用来存储和控制设备的状态。存储设备状态的寄存器叫做数据寄存器；控制设备状态的寄存器叫做控制寄存器。这些寄存器可能位于内存空间，也可能位于I/O空间，本节将介绍这些空间的寄存器访问方法。</p> 
<h3><a id="Linux_IO_211"></a>Linux I/O端口读写函数</h3> 
<p>设备内部集成了一些寄存器，程序可以通过寄存器来控制设备。大部分外部设备都有多个寄存器，例如看门狗控制寄存器（<code>WTCON</code>）、数据寄存器（<code>WTDAT</code>）和计数寄存器（<code>WTCNT</code>）等；有如IIC设备也有4个寄存器来完成所有IIC操作，这些寄存器是<code>IICCON</code>、<code>IICSTAT</code>、<code>IICADD</code>、<code>IICCDS</code>。<br> 根据设备需要完成的功能，可以将外部设备连接到内存地址空间上或者连接到I/O地址空间。无论是内存地址空间还是I/O地址空间，这些寄存器的访问都是连续的。一般台式机在设计时，因为内存地址空间比较紧张，所以一般将外部设备连接到I/O地址空间上。而对于嵌入式设备，内存一般是64M或者128M，大多数嵌入式处理器支持1G的内存空间，所以可以将外部设备连接到多余的内存空间上。<br> 在硬件设计上，内存地址空间和<code>I/O</code>地址空间的区别不是很大，都是由地址总线、控制总线和数据总线连接到CPU上的。对于非嵌入式产品的大型设备使用的CPU，一般将内存地址和I/O地址空间分开，对其进行单独访问，并提供相应的读写指令。例如在x86平台上，对I/O地址空间的访问，就是使用in、out指令。<br> 对于简单的嵌入式设备的CPU，一般将I/O地址空间合并在内存地址空间中。ARM处理器可以访问1G的内存地址空间，可以将内存挂接在低地址空间，将外部设备挂接在未使用的内存地址空间中。可以使用与访问内存相同的方法来访问外部设备。</p> 
<h3><a id="IO_216"></a>I/O内存读写</h3> 
<p>可以将I/O端口映射到I/O内存空间来访问。如下图所示是I/O内存的访问流程，在设备驱动模块的加载函数或者<code>open()</code>函数中可以调用<code>request_mem_region()</code>函数来申请资源。使用<code>ioremap()</code>函数将I/O端口所在的物理地址映射到虚拟地址上，之后，就可以调用<code>readb()、readw()、readl()</code>等函数读写寄存器中的内容了。当不再使用I/O内存时，可以使用<code>ioummap()</code>函数释放物理地址到虚拟地址的映射。最后，使用<code>release_mem_region()</code>函数释放申请的资源。<br> <img src="https://images2.imgbox.com/25/8b/XngWYi0T_o.png" alt="在这里插入图片描述"><br> <code>1.申请I/O内存</code><br> 在使用形如<code>readb()、readw()、readl()</code>等函数访问I/O内存前，首先需要分配一个I/O内存区域。完成这个功能的函数是<code>request_mem_region()</code>，该函数原型如下：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>   <span class="token macro-name function">request_mem_region</span><span class="token expression"><span class="token punctuation">(</span>start<span class="token punctuation">,</span> n <span class="token punctuation">,</span> name<span class="token punctuation">)</span></span></span>
<span class="token function">__request_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>iomem_resource<span class="token punctuation">,</span> <span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
</code></pre> 
<p><code>request_mem_region</code>被定义为一个宏，内部调用了<code>__request_region()</code>函数。宏<code>request_mem_region</code>带3个参数，第一个参数<code>start</code>是物理地址的开始区域，第2个参数n是需要分配内存的字节长度，第3个参数<code>name</code>是这个资源的名字。如果函数成功，返回一个资源指针；如果函数失败，则返回一个NULL值。在模块卸载函数中，如果不再使用内存资源，可以使用<code>release_region()</code>宏释放内存资源，该函数的原型如下：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">release_region</span><span class="token expression"><span class="token punctuation">(</span>start<span class="token punctuation">,</span> n<span class="token punctuation">)</span>   <span class="token function">__release_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioport_resource<span class="token punctuation">,</span> <span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
</code></pre> 
<p><code>2.物理地址到虚拟地址的映射函数</code><br> 在使用读写I/O内存的函数之前，需要使用<code>ioremap()</code>函数，将外部设备的I/O端口物理地址映射到虚拟地址。<code>ioremap()</code>函数的原型如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> __iomem <span class="token operator">*</span><span class="token function">ioremap</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> phys_addr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span>
</code></pre> 
<p><code>ioremap()</code>函数接收一个物理地址和一个整个I/O端口的大小，返回一个虚拟地址，这个虚拟地址对应一个<code>size</code>大小的物理地址空间。使用<code>ioremap()</code>函数后，物理地址被映射到虚拟地址空间中，所以读写I/O端口中的数据就像读取内存中的数据一样简单。通过<code>ioremap()</code>函数申请的虚拟地址，需要使用<code>iounmap()</code>函数来释放，该函数的原型如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">iounmap</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">void</span> __iomem <span class="token operator">*</span>addr<span class="token punctuation">)</span>
</code></pre> 
<p><code>iounmap()</code>函数接收<code>ioremap()</code>函数申请的虚拟地址作为参数，并取消物理地址到虚拟地址的映射。虽然<code>ioremap()</code>函数是返回的虚拟地址，但是不能直接当作指针使用。<br> <code>3.I/O内存的读写</code><br> 内核开发者准备了一组函数用来完成虚拟地址的读写，这些函数如下：</p> 
<ul><li><code>ioread()</code>函数和<code>iowrite8()</code>函数用来读写8位I/O内存。</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">ioread8</span><span class="token punctuation">(</span><span class="token keyword">void</span> __iomem <span class="token operator">*</span>addr<span class="token punctuation">)</span>
<span class="token keyword">void</span> <span class="token function">iowrite8</span><span class="token punctuation">(</span>u8 b<span class="token punctuation">,</span> <span class="token keyword">void</span> __iomem <span class="token operator">*</span>addr<span class="token punctuation">)</span>
</code></pre> 
<ul><li><code>ioread16()</code>函数和<code>iowrite16()</code>函数用来读写16位I/O内存。</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">ioread16</span><span class="token punctuation">(</span><span class="token keyword">void</span> __iomem <span class="token operator">*</span>addr<span class="token punctuation">)</span>
<span class="token keyword">void</span> <span class="token function">iowrite16</span><span class="token punctuation">(</span>u16 b<span class="token punctuation">,</span> <span class="token keyword">void</span> __iomem <span class="token operator">*</span>addr<span class="token punctuation">)</span>
</code></pre> 
<ul><li><code>ioread32()</code>函数和<code>iowrite()32</code>函数用来读写32位I/O内存。</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">ioread32</span><span class="token punctuation">(</span><span class="token keyword">void</span> __iomem <span class="token operator">*</span>addr<span class="token punctuation">)</span>
<span class="token keyword">void</span> <span class="token function">iowrite32</span><span class="token punctuation">(</span>u32 b<span class="token punctuation">,</span> <span class="token keyword">void</span> __iomem <span class="token operator">*</span>addr<span class="token punctuation">)</span>
</code></pre> 
<ul><li>对于大存储的设备，可以通过以上函数重复读写多次来完成大量数据的传送。Linux内核也提供了一组函数用来读写一系列的值，这些函数是上面函数的重复调用，函数原型如下：</li></ul> 
<pre><code class="prism language-c"><span class="token comment">/*以下3个函数读取一串I/O内存的值*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ioread8_rep</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">,</span>d<span class="token punctuation">,</span>c<span class="token punctuation">)</span>  <span class="token function">_raw_readsb</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>d<span class="token punctuation">,</span>c<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ioread16_rep</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">,</span>d<span class="token punctuation">,</span>c<span class="token punctuation">)</span>  <span class="token function">_raw_readsw</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>d<span class="token punctuation">,</span>c<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ioread32_rep</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">,</span>d<span class="token punctuation">,</span>c<span class="token punctuation">)</span>  <span class="token function">_raw_readsl</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>d<span class="token punctuation">,</span>c<span class="token punctuation">)</span></span></span>
<span class="token comment">/*以下3个函数写入一串I/O内存的值*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">iowrite8_rep</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">,</span>s<span class="token punctuation">,</span>c<span class="token punctuation">)</span> <span class="token function">__raw_writesb</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>s<span class="token punctuation">,</span>c<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">iowrite16_rep</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">,</span>s<span class="token punctuation">,</span>c<span class="token punctuation">)</span> <span class="token function">__raw_writesw</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>s<span class="token punctuation">,</span>c<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">iowrite32_rep</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">,</span>s<span class="token punctuation">,</span>c<span class="token punctuation">)</span> <span class="token function">__raw_writesl</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>s<span class="token punctuation">,</span>c<span class="token punctuation">)</span></span></span>
</code></pre> 
<p>在阅读Linux内核源代码时，会发现有些驱动程序使用<code>readb()、readw()、readl()</code>等较古老的函数。为了保证驱动程序的兼容性，内核仍然使用这些函数，但是在新的驱动代码中鼓励使用前面提到的函数。主要原因是新函数在运行时，会执行类型检查，从而保证了驱动程序的安全性。旧的函数或宏原型如下：</p> 
<pre><code class="prism language-c">u8 <span class="token function">readb</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">volatile</span> <span class="token keyword">void</span> __iomem <span class="token operator">*</span>addr<span class="token punctuation">)</span>
<span class="token keyword">void</span> <span class="token function">writeb</span><span class="token punctuation">(</span>u8 b<span class="token punctuation">,</span> <span class="token keyword">volatile</span> <span class="token keyword">void</span> __iomem <span class="token operator">*</span>addr<span class="token punctuation">)</span>
u8 <span class="token function">readw</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">volatile</span> <span class="token keyword">void</span> __iomem <span class="token operator">*</span>addr<span class="token punctuation">)</span>
<span class="token keyword">void</span> <span class="token function">writew</span><span class="token punctuation">(</span>u16 b<span class="token punctuation">,</span> <span class="token keyword">volatile</span> <span class="token keyword">void</span> __iomem <span class="token operator">*</span>addr<span class="token punctuation">)</span>
u8 <span class="token function">readl</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">volatile</span> <span class="token keyword">void</span> __iomem <span class="token operator">*</span>addr<span class="token punctuation">)</span>
<span class="token keyword">void</span> <span class="token function">writel</span><span class="token punctuation">(</span>u32 b<span class="token punctuation">,</span> <span class="token keyword">volatile</span> <span class="token keyword">void</span> __iomem <span class="token operator">*</span>addr<span class="token punctuation">)</span>
</code></pre> 
<p><code>readb()</code>函数与<code>ioread8()</code>函数功能相同；<code>writeb()</code>函数和<code>iowrite8()</code>函数功能相同；其他同理。<br> <code>4.I/O内存的读写举例</code><br> 一个使用I/O内存的完成实例可以从<code>rtc</code>实时时钟驱动程序中看到。在<code>rtc</code>实时时钟驱动程序的探测函数<code>s3c_rtc_probe()</code>中。首先调用了<code>platform_get_resource()</code>函数从平台设备中获得I/O端口的定义，主要是I/O端口的物理地址。然后先后使用<code>request_mem_region()</code>和<code>ioremap()</code>函数将I/O端口的物理地址转换为虚拟地址，并存储在一个全局变量<code>s3c_rtc_base</code>中，这样就可以通过这个变量访问<code>rtc</code>寄存器的值了。<code>s3c_rtc_probe()</code>函数的代码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> __iomem <span class="token operator">*</span>s3c_rtc_base<span class="token punctuation">;</span> <span class="token comment">/*定义一个全局变量，存放虚拟内存地址*/</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> __devint <span class="token function">s3c_rtc_probe</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span>pdev<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">/*省略部分代码*/</span>
	<span class="token comment">/*从平台设备中获得I/O端口的定义*/</span>
	res <span class="token operator">=</span> <span class="token function">platform_get_resource</span><span class="token punctuation">(</span>pdev<span class="token punctuation">,</span> IORESOURCE_MEM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>res <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">dev_err</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> <span class="token string">"failed to get memory region resource\n"</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>ENPENT<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	s3c_rtc_mem <span class="token operator">=</span> <span class="token function">request_mem_region</span><span class="token punctuation">(</span>res<span class="token operator">-&gt;</span>start<span class="token punctuation">,</span>
					res<span class="token operator">-&gt;</span>end <span class="token operator">-</span> res<span class="token operator">-&gt;</span>start<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>
					pdev<span class="token operator">-&gt;</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*申请内存资源*/</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>s3c_rtc_mem <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  <span class="token comment">/*如果有错误，则跳转到错误处理代码中*/</span>
		<span class="token function">dev_err</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> <span class="token string">"failed to reserve memory region\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		ret <span class="token operator">=</span> <span class="token operator">-</span>ENOENT<span class="token punctuation">;</span>
		<span class="token keyword">goto</span> err_nores<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	s3c_rtc_base <span class="token operator">=</span> <span class="token function">ioremap</span><span class="token punctuation">(</span>res<span class="token operator">-&gt;</span>start<span class="token punctuation">,</span> res<span class="token operator">-&gt;</span>end <span class="token operator">-</span> res<span class="token operator">-&gt;</span>start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/*申请物理地址映射成虚拟地址*/</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>s3c_rtc_base <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  <span class="token comment">/*如果错误，则跳转到错误处理代码中*/</span>
		<span class="token function">dev_err</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> <span class="token string">"failed ioremap()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		ret <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
		<span class="token keyword">goto</span> err_nomap<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token comment">/*省略部分代码*/</span>

err_nomap<span class="token operator">:</span>
	<span class="token function">iounmap</span><span class="token punctuation">(</span>s3c_rtc_base<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/*如果错误，则取消映射*/</span>
err_nortc<span class="token operator">:</span>
	<span class="token function">release_resource</span><span class="token punctuation">(</span>s3c_rtc_mem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*如果错误，则释放资源*/</span>
err_norse<span class="token operator">:</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用<code>request_mem_region()</code>和<code>ioremap()</code>函数将I/O端口的物理地址转换为虚拟地址，这样就可以使用<code>readb()</code>和<code>writeb()</code>函数向I/O内存中写入数据了。<code>rtc</code>实时时钟的<code>s3c_rtc_setpie()</code>函数就使用了者两个函数向S3C2410_TICNT中写入数据。<code>s3c_rtc_setpie()</code>函数的源代码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">s3c_rtc_setpie</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">int</span> enable<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> tmp<span class="token punctuation">;</span>
	<span class="token function">pr_debug</span><span class="token punctuation">(</span><span class="token string">"%s:pie=%d\n"</span><span class="token punctuation">,</span><span class="token constant">__func__</span><span class="token punctuation">,</span> enabled<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">spin_lock_irq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s3c_rtc_pie_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
	tmp <span class="token operator">=</span> <span class="token function">readb</span><span class="token punctuation">(</span>s3c_rtc_base <span class="token operator">+</span> S3Cs410_TICNT<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>S3C2410_TICNT_ENABLE<span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>enabled<span class="token punctuation">)</span>
		tmp <span class="token operator">|=</span> S3C2410_TICNT_ENABLE<span class="token punctuation">;</span>
	<span class="token function">writeb</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> s3c_rtc_base <span class="token operator">+</span> S3C2410_TICNT<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">spin_unlock_irq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s3c_rtc_pie_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当不再使用I/O内存时，可以使用<code>iounmap()</code>函数释放物理地址到虚拟地址的映射。最后，使用<code>release_mem_region()</code>函数释放申请的资源。<code>rtc</code>实时时钟的<code>s3c_rtc_remove()</code>函数就使用<code>iounmap()</code>和<code>release_mem_region()</code>函数释放申请的内存空间。<code>s3c_rtc_remove()</code>函数代码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> __devexit <span class="token function">s3c_rtc_remove</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> <span class="token class-name">rtc_device</span> <span class="token operator">*</span>rtc <span class="token operator">=</span> <span class="token function">platform_get_drvdata</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">platform_set_drvdata</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">rtc_device_unregister</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">s3c_rtc_setpie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">iounmap</span><span class="token punctuation">(</span>s3c_rtc_base<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">release_resource</span><span class="token punctuation">(</span>s3c_rtc_mem<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">kfree</span><span class="token punctuation">(</span>s3c_rtc_mem<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="IO_345"></a>使用I/O端口</h3> 
<p>对于使用I/O地址空间的外部设备，需要通过I/O端口和设备传输数据。在访问I/O端口前，需要向内核申请I/O端口使用的资源。如下图所示，在设备驱动模块的加载函数或者<code>open()</code>函数中可以调用<code>request_region()</code>函数请求I/O端口资源；然后使用<code>inb()、outb()、intw()、outw()</code>等函数来读写外部设备的I/O端口；最后，在设备驱动程序的模块卸载函数或者<code>release()</code>函数中，释放申请的I/O内存资源。<br> <img src="https://images2.imgbox.com/ca/79/oQhMVQVK_o.png" alt="在这里插入图片描述"><br> <code>1.申请和释放I/O端口</code><br> 如果要访问I/O端口，那么就需要先申请一个内存资源来对应I/O端口，在此之前，不能对I/O端口进行操作。Linux内核提供了一个函数来申请I/O端口的资源，只有申请了该端口资源之后，才能使用该端口，这个函数是<code>request_region()</code>，函数代码如下：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">request_region</span><span class="token expression"><span class="token punctuation">(</span>start<span class="token punctuation">,</span>n<span class="token punctuation">,</span>name<span class="token punctuation">)</span>  <span class="token function">__request_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioport_resource<span class="token punctuation">,</span></span></span>
<span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">struct</span> <span class="token class-name">resource</span> <span class="token operator">*</span> <span class="token function">__request_region</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">resource</span> <span class="token operator">*</span>parent<span class="token punctuation">,</span> 
					<span class="token class-name">resource_size_t</span> start<span class="token punctuation">,</span> <span class="token class-name">resource_size_t</span> n<span class="token punctuation">,</span>
					<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
</code></pre> 
<p><code>request_region()</code>函数是一个宏，由<code>__request_region()</code>函数来实现。这个宏接收3个参数，第一个参数<code>start</code>是要使用的I/O端口的地址，第2个参数表示从<code>start</code>开始的n个端口，第3个参数是设备的名字。如果分配成功，那么<code>request_region()</code>函数会返回一个非NULL值；如果失败，则返回NULL值，此时，不能使用这些端口。<br> <code>__request_region()</code>函数用来申请资源，这个函数有5个参数。第1个参数是资源的父资源，这样所有系统的资源被连接成一棵资源树，方便内核的管理。第2个参数是I/O端口的开始地址。第3个参数表示需要映射多少个I/O端口。第4个参数是设备的名字。第5个参数是资源的标志。<br> 如果不再使用I/O端口，需要在适当的时候释放I/O端口，这个过程一般在模块的卸载函数中，释放I/O端口的宏是<code>release_region()</code>,其代码如下：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">release_region</span><span class="token expression"><span class="token punctuation">(</span>start<span class="token punctuation">,</span> n<span class="token punctuation">)</span>   <span class="token function">__release_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioport_resource<span class="token punctuation">,</span> <span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">void</span> <span class="token function">__release_region</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">resource</span> <span class="token operator">*</span>parent<span class="token punctuation">,</span> <span class="token class-name">resource_size_t</span> start<span class="token punctuation">,</span> <span class="token class-name">reosurce_size_t</span> n<span class="token punctuation">)</span>
</code></pre> 
<p><code>release_region</code>是一个宏，由<code>__release_region()</code>函数来实现。第一个参数<code>start</code>是要使用的I/O端口的地址，第2个参数表示从<code>start</code>开始的n个端口。<br> <code>2.读写I/O端口</code><br> 当驱动程序申请了I/O相关的资源后，可以对这些端口进行数据的读取或写入。对不同功能的寄存器写入不同的值，就能够使外部设备完成相应的工作。一般来说，大多数外部设备将端口的大小设为8位、16位或者32位。不同大小的端口需要使用不同的读取和写入函数，不能将这些函数混淆使用。如果用一个读取8位端口的函数读一个16位的端口，会导致错误。读取端口数据的函数如下所示。</p> 
<ul><li><code>inb()和outb()</code>函数是读写8位端口的函数。<code>inb()</code>函数第一个参数是端口号，其是一个无符号的16位端口号。<code>outb()</code>函数用来向端口写入一个8位的数据，第1个参数是要写入的8位数据，第2个参数是I/O端口。</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> u8 <span class="token function">inb</span><span class="token punctuation">(</span>u16 port<span class="token punctuation">)</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">outb</span><span class="token punctuation">(</span>u8 v<span class="token punctuation">,</span> u16 port<span class="token punctuation">)</span>
</code></pre> 
<ul><li><code>inw()和outw()</code>函数是读写16位端口的函数。<code>inb()</code>函数第一个参数是端口号，其是一个无符号的16位端口号。<code>outw()</code>函数用来向端口写入一个16位的数据，第1个参数是要写入的16位数据，第2个参数是I/O端口。</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> u6 <span class="token function">inw</span><span class="token punctuation">(</span>u16 port<span class="token punctuation">)</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">outw</span><span class="token punctuation">(</span>u16 v<span class="token punctuation">,</span> u16 port<span class="token punctuation">)</span>
</code></pre> 
<ul><li><code>inl()和outl()</code>函数是读写32位端口的函数。<code>inl()</code>函数第一个参数是端口号，其是一个无符号的32位端口号。<code>outl()</code>函数用来向端口写入一个32位的数据，第1个参数是要写入的32位数据，第2个参数是I/O端口。</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> u8 <span class="token function">inl</span><span class="token punctuation">(</span>u32 port<span class="token punctuation">)</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">outl</span><span class="token punctuation">(</span>u32 v<span class="token punctuation">,</span> u16 port<span class="token punctuation">)</span>
</code></pre> 
<p>上面的函数基本是一次传送1、2和4字节。在某些处理器上也实现了一次传输一串数据的功能，串中的基本单位可以是字节、字和双字。串传输比单独的字节传输速度要快很多，所以对于处理需要传输大量数据时非常有用。一些串传输的I/O函数原型如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">insb</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">)</span>
<span class="token keyword">void</span> <span class="token function">outsb</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">)</span>
</code></pre> 
<p><code>insb()</code>函数从<code>addr</code>地址向<code>dst</code>地址读取<code>count</code>个字节，<code>outsb()</code>函数从<code>addr</code>地址向<code>src</code>地址写入<code>count</code>个字节。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">insw</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">)</span>
<span class="token keyword">void</span> <span class="token function">outsw</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">)</span>
</code></pre> 
<p><code>insw()</code>函数从<code>addr</code>地址读取<code>countx2</code>个字节，<code>outsw()</code>函数从<code>addr</code>地址向<code>dst</code>地址写入<code>countx2</code>个字节。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">insl</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">)</span>
<span class="token keyword">void</span> <span class="token function">outsl</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">)</span>
</code></pre> 
<p><code>insw()</code>函数从<code>addr</code>地址读取<code>countx4</code>个字节，<code>outsw()</code>函数从<code>addr</code>地址向<code>dst</code>地址写入<code>countx4</code>个字节。<br> 需要注意的是，串传输函数直接从端口中读出或者写入指定长度的数据。因此，如果当外部设备和主机之间有不同的字节序时，则会导致意外的错误。例如主机使用小端字节序，外部设备使用大端字节序，在进行数据读写时，应该交换字节序，使彼此互相理解。</p> 
<h2><a id="_400"></a>小结</h2> 
<p>外部设备可以处于内存空间或者I/O空间中，对于嵌入式产品来说，一般外部设备处于内存空间中。本章对外部设备处于内存空间和I/O空间的情况分别进行了讲解。在Linux中，为了方便编写驱动程序，对内存空间和I/O空间的访问提供了一套统一的方法，这个方法是“申请资源-&gt;映射内存空间-&gt;访问内存-&gt;取消映射-&gt;释放资源”。<br> Linux中使用了后备高速缓存来频繁地分配和释放同一种对象，这样不但减少了内存碎片的出现，而且还提高了系统的性能，为驱动程序的高效性打下基础。<br> Linux中提供了一套分配和释放页面的函数，这些函数可以根据需要分配物理连续或者不连续的内存，并将其映射到虚拟地址空间中，然后对其进行访问。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2ed512a19be3a60d41189a15291b4c2c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">3-线程的3种创建方式7种写法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/074a92f3444ab95e1aecb6b46781056d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PS快捷键</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>