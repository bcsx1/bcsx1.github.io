<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>boost库介绍以及使用 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="boost库介绍以及使用" />
<meta property="og:description" content="C&#43;&#43; boost库介绍以及使用 一. 什么是boost库 ​ boost 库是一个优秀的，可移植的，开源的 C&#43;&#43; 库，它是由 C&#43;&#43; 标准委员会发起的，其中一些内容已经成为了下一代 C&#43;&#43; 标准库的内容，在 C&#43;&#43; 社区中影响甚大，是一个不折不扣的准标准库，它的功能十分强大，弥补了 C&#43;&#43; 很多功能函数处理上的不足。
​ 学习链接: https://theboostcpplibraries.com/
​ https://www.cnblogs.com/lidabo/p/9294874.html
​ https://tangxing.blog.csdn.net/article/details/116393985
二. 特点 ​ 可移植性：Windows，Linux，Unix 等
​ 开源免费：使用 Boost License 来授权使用，商业和非商业都是可以使用的
​ 高效：具有工业强度，设计结构良好，广泛使用
三. 分类 ​ boost 库功能强大，按照功能模块分类，大致可以分为如下：
字符串和文本处理库，容器库，迭代器库，算法库，函数对象和高阶编程库，泛型编程，模板元编程，预处理元编程，并发编程，数字和数学，排错和测试，数据结构，图像处理，输入输出，内存管理，跨语言混合编程，解析，编程接口等。
四.boost库安装 一. CentOS环境下搭建boost开发环境 安装boost库
# yum install boost # yum install boost-devel 二. 下载boost库及编译 ​ 要使用 C&#43;&#43; boost 库，先要下载 boost 库，下载地址是：https://www.boost.org/
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0hDUehNp-1680489201384)(watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODEwMjc3MQ==,size_16,color_FFFFFF,t_70.png)]
​ 选择 Downloads 下的 Current Release 就可以下载了。下载完成后查看目录，大致如下结构所示。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/c55c4ac42c517baf368de35852b3e44e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-03T10:35:08+08:00" />
<meta property="article:modified_time" content="2023-04-03T10:35:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">boost库介绍以及使用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="C_boost_0"></a>C++ boost库介绍以及使用</h3> 
<h4><a id="_boost_2"></a>一. 什么是boost库</h4> 
<p>​ boost 库是一个优秀的，可移植的，开源的 C++ 库，它是由 C++ 标准委员会发起的，其中一些内容已经成为了下一代 C++ 标准库的内容，在 C++ 社区中影响甚大，是一个不折不扣的准标准库，它的功能十分强大，弥补了 C++ 很多功能函数处理上的不足。</p> 
<p>​ 学习链接: https://theboostcpplibraries.com/</p> 
<p>​ https://www.cnblogs.com/lidabo/p/9294874.html</p> 
<p>​ https://tangxing.blog.csdn.net/article/details/116393985</p> 
<h4><a id="__12"></a>二. 特点</h4> 
<p>​ 可移植性：Windows，Linux，Unix 等</p> 
<p>​ 开源免费：使用 Boost License 来授权使用，商业和非商业都是可以使用的</p> 
<p>​ 高效：具有工业强度，设计结构良好，广泛使用</p> 
<h4><a id="__20"></a>三. 分类</h4> 
<p>​ boost 库功能强大，按照功能模块分类，大致可以分为如下：</p> 
<p>字符串和文本处理库，容器库，迭代器库，算法库，函数对象和高阶编程库，泛型编程，模板元编程，预处理元编程，并发编程，数字和数学，排错和测试，数据结构，图像处理，输入输出，内存管理，跨语言混合编程，解析，编程接口等。</p> 
<h4><a id="boost_26"></a>四.boost库安装</h4> 
<h5><a id="__CentOSboost_28"></a>一. CentOS环境下搭建boost开发环境</h5> 
<p>安装boost库</p> 
<pre><code class="prism language-shell"><span class="token comment"># yum install boost</span>

<span class="token comment"># yum install boost-devel</span>
</code></pre> 
<h5><a id="_boost_40"></a>二. 下载boost库及编译</h5> 
<p>​ 要使用 C++ boost 库，先要下载 boost 库，下载地址是：https://www.boost.org/</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0hDUehNp-1680489201384)(watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODEwMjc3MQ==,size_16,color_FFFFFF,t_70.png)]</p> 
<p>​ 选择 Downloads 下的 Current Release 就可以下载了。下载完成后查看目录，大致如下结构所示。</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-n1c8tmoH-1680489201385)(watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODEwMjc3MQ==,size_16,color_FFFFFF,t_70-16803409982002.png)]</p> 
<p>Boost 压缩包解压后有5万多个文件，占据近 700MB 的磁盘空间，但其目录结构却很简洁清晰：</p> 
<pre><code>boost_1_72_0/  #存放配置脚本和说明文件
├──── boost    #最重要的目录，90%以上的Boost程序库源码都在这里
├──── doc      #HTML格式的文档，也可以生成PDF格式的文档
├──── libs     #所有组件的示例、测试、编译代码和说明文档
├──── more     #库作者的相关文档
├──── status   #可用于测试Boost库的各个组件
└──── tools    #b2、quickbook 等自带工具
</code></pre> 
<p>在大多数情况下，我们只需要关心 boost 子目录，这里面以头文件的形式分门别类地存放了我们要使用的库代码：</p> 
<pre><code>boost_1_72_0/  #Boost 安装根目录
├──── boost    #boost子目录
│    ├──── accumulators #累加器库
│    ├──── algorithm    #算法库
│    ├──── align        #内存对齐库
│    ├──── archive      #序列化库
│    ├──── asio         #异步并发库
│    ├──── assign       #赋值初始化库
│    ├──── atomic       #原子操作库
│    ├──── beast        #高级网络通信库（HTTP/WebSocket）
│    ├──── bimap        #双向关联数组
│    ├──── bind         #bind表达式
│    ├──── chrono       #时间处理库
│    ├──── ...          #其他库……
│    └──── yap          #表达式模板库
</code></pre> 
<p>Boost C++ 库的 1.42.0 版本包含了超过90个库，本书只详细讨论了以下各库：</p> 
<table><thead><tr><th>Boost C++ 库</th><th>简要说明</th></tr></thead><tbody><tr><td><a href="http://zh.highscore.de/cpp/boost/datastructures.html#datastructures_any" rel="nofollow">Boost.Any</a></td><td>Boost.Any 提供了一个名为 <code>boost::any</code> 的数据类型，可以存放任意的类型。 例如，一个类型为 <code>boost::any</code> 的变量可以先存放一个 <code>int</code> 类型的值，然后替换为一个 <code>std::string</code> 类型的字符串。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/containers.html#containers_array" rel="nofollow">Boost.Array</a></td><td>Boost.Array 可以把 C++ 数组视同 C++ 标准的容器。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/asio.html" rel="nofollow">Boost.Asio</a></td><td>Boost.Asio 可用于开发异步处理数据的应用，如网络应用。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/containers.html#containers_bimap" rel="nofollow">Boost.Bimap</a></td><td>Boost.Bimap 提供了一个名为 <code>boost::bimap</code> 的类，它类似于 <code>std::map</code>. 主要的差别在于 <code>boost::bimap</code> 可以同时从键和值进行搜索。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/functionobjects.html#functionobjects_bind" rel="nofollow">Boost.Bind</a></td><td>Boost.Bind 是一种适配器，可以将函数作为模板参数，即使该函数的签名与模板参数不兼容。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/castoperators.html#castoperators_conversion" rel="nofollow">Boost.Conversion</a></td><td>Boost.Conversion 提供了三个转型操作符，分别执行向下转型、交叉转型，以及不同数字类型间的值转换。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/datetime.html" rel="nofollow">Boost.DateTime</a></td><td>Boost.DateTime 可用于以灵活的格式处理、读入和写出日期及时间值。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/errorhandling.html#errorhandling_exception" rel="nofollow">Boost.Exception</a></td><td>Boost.Exception 可以在抛出的异常中加入额外的数据，以便在 <code>catch</code> 处理中提供更多的信息。 这有助于更容易地调试，以及对异常情况更好地作出反应。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/filesystem.html" rel="nofollow">Boost.Filesystem</a></td><td>Boost.Filesystem 提供了一个类来处理路径信息，还包含了几个访问文件和目录的函数。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/stringhandling.html#stringhandling_format" rel="nofollow">Boost.Format</a></td><td>Boost.Format 以一个类型安全且可扩展的 <code>boost::format</code> 类替代了 <code>std::printf()</code> 函数。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/functionobjects.html#functionobjects_function" rel="nofollow">Boost.Function</a></td><td>Boost.Function 简化了函数指针的定义。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/interprocesscommunication.html" rel="nofollow">Boost.Interprocess</a></td><td>Boost.Interprocess 允许多个应用通过共享内存以快速、高效的方式进行通信。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/functionobjects.html#functionobjects_lambda" rel="nofollow">Boost.Lambda</a></td><td>Boost.Lambda 可以定义匿名的函数。 代码被内联地声明和执行，避免了单独的函数调用。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/containers.html#containers_multiindex" rel="nofollow">Boost.Multiindex</a></td><td>Boost.Multiindex 定义了一些新的容器，它们可以同时支持多个接口，如 <code>std::vector</code> 和 <code>std::map</code> 的接口。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/castoperators.html#castoperators_numeric_conversion" rel="nofollow">Boost.NumericConversion</a></td><td>Boost.NumericConversion 提供了一个转型操作符，可以安全地在不同的数字类型间进行值转换，不会生成上溢出或下溢出的条件。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/smartpointers.html#smartpointers_pointer_container" rel="nofollow">Boost.PointerContainer</a></td><td>Boost.PointerContainer 提供了专门为动态分配对象进行优化的容器。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/functionobjects.html#functionobjects_ref" rel="nofollow">Boost.Ref</a></td><td>Boost.Ref 的适配器可以将不可复制对象的引用传给需要复制的函数。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/stringhandling.html#stringhandling_regex" rel="nofollow">Boost.Regex</a></td><td>Boost.Regex 提供了通过正则表达式进行文本搜索的函数。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/serialization.html" rel="nofollow">Boost.Serialization</a></td><td>通过 Boost.Serialization，对象可以被序列化，如保存在文件中，并在以后重新导入。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/eventhandling.html" rel="nofollow">Boost.Signals</a></td><td>Boost.Signal 是一个事件处理的框架，基于所谓的 signal/slot 概念。 函数与信号相关联并在信号被触发时自动被调用。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/smartpointers.html" rel="nofollow">Boost.SmartPoiners</a></td><td>Boost.SmartPoiners 提供了多个智能指针，简化了动态分配对象的管理。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/parser.html" rel="nofollow">Boost.Spirit</a></td><td>Boost.Spirit 可以用类似于 EBNF (扩展巴科斯范式)的语法生成词法分析器。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/stringhandling.html#stringhandling_stringalgorithms" rel="nofollow">Boost.StringAlgorithms</a></td><td>Boost.StringAlgorithms 提供了多个独立的函数，以方便处理字符串。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/errorhandling.html#errorhandling_system" rel="nofollow">Boost.System</a></td><td>Boost.System 提供了一个处理系统相关或应用相关错误代码的框架。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/multithreading.html" rel="nofollow">Boost.Thread</a></td><td>Boost.Thread 可用于开发多线程应用。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/stringhandling.html#stringhandling_tokenizer" rel="nofollow">Boost.Tokenizer</a></td><td>Boost.Tokenizer 可以对一个字符串的各个组件进行迭代。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/datastructures.html#datastructures_tuple" rel="nofollow">Boost.Tuple</a></td><td>Boost.Tuple 提供了泛化版的 <code>std::pair</code>，可以将任意数量的数据组在一起。</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/containers.html#containers_unordered" rel="nofollow">Boost.Unordered</a></td><td>Boost.Unordered 扩展了 C++ 标准的容器，增加了<code>boost::unordered_set</code> 和 <code>boost::unordered_map</code>.</td></tr><tr><td><a href="http://zh.highscore.de/cpp/boost/datastructures.html#datastructures_variant" rel="nofollow">Boost.Variant</a></td><td>Boost.Variant 可以定义多个数据类型，类似于 <code>union</code>, 将多个数据类型组在一起。 Boost.Variant 比 <code>union</code> 优胜的地方在于它可以使用类。</td></tr></tbody></table> 
<p>linux下编译方式:</p> 
<pre><code class="prism language-shell">$ <span class="token function">tar</span> -xzf boost_1_81_0.tar.gz
$ <span class="token builtin class-name">cd</span> boost_1_81_0/
<span class="token comment">#--with-liraries：需要编译的库 --with-toolset：编译时使用的编译器</span>
$ ./bootstrap.sh --with-libraries<span class="token operator">=</span>all --with-toolset<span class="token operator">=</span>gcc
<span class="token comment"># 默认头文件在/usr/local/include，库文件在/usr/local/lib</span>
$ ./b2 <span class="token function">install</span> --prefix<span class="token operator">=</span>/usr  
</code></pre> 
<h4><a id="_Boost__127"></a>五. Boost 使用方式</h4> 
<p>​ Boost 库的大多数组件不需要编译链接，我们在自己的源码里直接包含头文件即可。例如，如果要使用 boost::tribool，只需要在 C++ 源文件中添加如下 include 语句：</p> 
<pre><code class="prism language-c++">//大多数Boost库仅包含头文件（.hpp）：它们完全由包含模板和内联函数的头文件组成；链接时不需要单独编译的库二进制文件或特殊处理。
#include &lt;boost/XXX.hpp&gt;
</code></pre> 
<pre><code class="prism language-c++">#include &lt;boost/logic/tribool.hpp&gt; //使用tribool库
</code></pre> 
<p>细心的读者会发现，Boost 库的头文件与我们平常所用的头文件（*.h）或 C++ 标准库的头文件（没有后缀名）不同，这正是 Boost 的独特之处。它把 C++ 类的声明和实现放在了一个文件中，而不是分成两个文件，即<code>.h+.cpp</code>，故文件的后缀是<code>.hpp</code>。</p> 
<pre><code>之所以这么做当然是有理由的。其中一个原因就是与普通的C头文件（*.h）区分，另一个很重要的原因就是使 Boost 库不需要预先编译，直接将其引入程序员的工程即可编译链接，方便了 Boost 库的使用。
Java、C＃、PHP、Python 程序员应该对这种代码文件形式很熟悉，这几种语言都在一个文件中编写所有代码。
</code></pre> 
<p>剩下的少量库（如 chrono、date_time、program_options、test、thread 等）必须编译成静态库或动态库，并在构建时指定链接选项才能使用。</p> 
<p>大多数的 boost 库仅需要包含头文件 hpp 即可，不需要再链接其他的 lib 文件，但是有些 boost 下的库是需要包含 lib 文件的。</p> 
<h4><a id="__151"></a>六. 使用案例</h4> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;boost/version.hpp&gt;  //包含 Boost 头文件
#include &lt;boost/config.hpp&gt;  //包含 Boost 头文件
using namespace std;
int main()
{
    cout &lt;&lt; BOOST_VERSION &lt;&lt; endl;  //Boost 版本号
    cout &lt;&lt; BOOST_LIB_VERSION &lt;&lt; endl;  //Boost 版本号
    cout &lt;&lt; BOOST_PLATFORM &lt;&lt; endl;  //操作系统
    cout &lt;&lt; BOOST_COMPILER &lt;&lt; endl;  //编译器
    cout &lt;&lt; BOOST_STDLIB &lt;&lt; endl;  //标准库
    return 0;
}

//g++ -o a.out test.cpp
</code></pre> 
<pre><code class="prism language-c++">#include &lt;iostream&gt; 
#include &lt;boost/filesystem.hpp&gt; 
 
using namespace boost::filesystem; 
 
int main(int argc, char *argv[]) 
{ 
 if (argc &lt; 2)
 { 
  std::cout &lt;&lt; "用法：app path\n"; 
  return 1; 
 } 
 std::cout &lt;&lt; argv[1] &lt;&lt; ":" &lt;&lt; file_size(argv[1]) &lt;&lt; std::endl; 
 return 0; 
} 

// 编译命令：g++ demo2.cpp -o demo2  -lboost_system -lboost_filesystem
</code></pre> 
<pre><code class="prism language-c++">#include &lt;boost/thread/thread.hpp&gt;
#include &lt;iostream&gt;
 
using namespace std;
 
void NewThread()
{
        cout &lt;&lt; "New thread is running..." &lt;&lt; endl;
}
 
int main(int argc, char* argv[])
{
        boost::thread newthread(&amp;NewThread);
        newthread.join();
        return 0;
}

// g++ main.cpp -o test -lboost_system -lboost_thread
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d54802ec3c07272eacaecff9bac9eabf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SQL注入基本教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8e23b695ef62ea94055fe98494b61430/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">boost.variant</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>