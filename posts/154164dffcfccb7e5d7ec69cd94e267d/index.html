<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; 面试八股文总结 -- STL - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; 面试八股文总结 -- STL" />
<meta property="og:description" content="STL 1 请说说 STL 的基本组成部分 参考回答
标准模板库（Standard Template Library,简称STL）简单说，就是一些常用数据结构和算法的模板的集合。
广义上讲，STL分为3类：Algorithm（算法）、Container（容器）和Iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。
详细的说，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。
答案解析
标准模板库STL主要由6大组成部分：容器(Container)
是一种数据结构， 如list, vector, 和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。
算法（Algorithm）
是用来操作容器中的数据的模板函数。例如，STL用sort()来对一 个vector中的数据进行排序，用find()来搜索一个list中的对象， 函数本身与他们操作的数据的结构和类型无关，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。
迭代器（Iterator）
提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。 迭代器就如同一个指针。事实上，C&#43;&#43; 的指针也是一种迭代器。 但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符方法的类对象;
仿函数（Function object）
仿函数又称之为函数对象， 其实就是重载了操作符的struct,没有什么特别的地方。
适配器（Adaptor）
简单的说就是一种接口类，专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。
空间配制器（Allocator）
为STL提供空间配置的系统。其中主要工作包括两部分：
（1）对象的创建与销毁；（2）内存的获取与释放。
2 请说说 STL 中常见的容器，并介绍一下实现原理 容器可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是模板类，分为顺序容器、关联式容器、容器适配器三种类型，三种类型容器特性分别如下：
顺序容器
容器并非排序的，元素的插入位置同元素的值无关。包含vector、deque、list，具体实现原理如下：
（1）vector 头文件
动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。
（2）deque 头文件
双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。
（3）list 头文件
双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。
关联式容器
元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性能；通常以平衡二叉树的方式实现。包含set、multiset、map、multimap，具体实现原理如下：
（1）set/multiset 头文件
set 即集合。set中不允许相同元素，multiset中允许存在相同元素。
（2）map/multimap 头文件
map与set的不同在于map中存放的元素有且仅有两个成员变，一个名为first,另一个名为second, map根据first值对元素从小到大排序，并可快速地根据first来检索元素。
注意：map同multimap的不同在于是否允许相同first值的元素。
容器适配器
封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个具有stack功能的数据结构。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue，具体实现原理如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/154164dffcfccb7e5d7ec69cd94e267d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-01T20:10:45+08:00" />
<meta property="article:modified_time" content="2022-05-01T20:10:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; 面试八股文总结 -- STL</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="STL_0"></a>STL</h2> 
<h5><a id="1__STL__2"></a>1 请说说 STL 的基本组成部分</h5> 
<p><strong>参考回答</strong></p> 
<p>标准模板库（Standard Template Library,简称STL）简单说，就是一些常用数据结构和算法的模板的集合。</p> 
<p><strong>广义上讲</strong>，STL分为3类：<font color="cornflowerblue">Algorithm（算法）、Container（容器）和Iterator（迭代器）</font>，容器和算法通过迭代器可以进行无缝地连接。</p> 
<p><strong>详细的说</strong>，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。</p> 
<p><strong>答案解析</strong></p> 
<p>标准模板库STL主要由6大组成部分：容器(Container)</p> 
<ol><li> <p>是一种数据结构， 如<font color="cornflowerblue">list, vector, 和deques，以模板类的方法提供</font>。为了访问容器中的数据，可以使用由容器类输出的迭代器。</p> </li><li> <p>算法（Algorithm）</p> <p>是用来<font color="cornflowerblue">操作容器中的数据的模板函数</font>。例如，STL用sort()来对一 个vector中的数据进行排序，用find()来搜索一个list中的对象， 函数本身与他们操作的数据的结构和类型无关，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。</p> </li><li> <p>迭代器（Iterator）</p> <p>提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。 迭代器就如同一个指针。事实上，C++ 的指针也是一种迭代器。 但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符方法的类对象;</p> </li><li> <p>仿函数（Function object）</p> <p><font color="cornflowerblue"> 仿函数又称之为函数对象， 其实就是重载了操作符的struct,没有什么特别的地方。</font></p> </li><li> <p>适配器（Adaptor）</p> <p><font color="red">简单的说就是一种接口类，专门用来修改现有类的接口，提供一中新的接口</font>；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。</p> </li><li> <p>空间配制器（Allocator）</p> <p>为STL<font color="cornflowerblue">提供空间配置的系统</font>。其中主要工作包括两部分：</p> <p><font color="red">（1）对象的创建与销毁；（2）内存的获取与释放</font>。</p> </li></ol> 
<h5><a id="2__STL__40"></a>2 请说说 STL 中常见的容器，并介绍一下实现原理</h5> 
<p>容器可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是模板类，分为顺序容器、关联式容器、容器适配器三种类型，三种类型容器特性分别如下：</p> 
<ol><li> <p>顺序容器</p> <p>容器并非排序的，元素的插入位置同元素的值无关。包含vector、deque、list，具体实现原理如下：</p> <p>（1）vector 头文件</p> <p>动态数组。元素在内存<strong>连续存放</strong>。<strong>随机存取</strong>任何元素都能在<strong>常数时间完成</strong>。在<strong>尾端增删元素具有较佳的性能</strong>。</p> <p>（2）deque 头文件</p> <p><strong>双向队列。元素在内存连续存放</strong>。<strong>随机存取任何元素都能在常数时间完成</strong>（仅次于vector）。在<strong>两端增删元素具有较佳的性能</strong>（大部分情况下是常数时间）。</p> <p>（3）list 头文件</p> <p>双向链表。元素在<strong>内存不连续存放</strong>。在<strong>任何位置增删元素都能在常数时间完成。不支持随机存取</strong>。</p> </li><li> <p>关联式容器</p> <p><strong>元素是排序的</strong>；插入任何元素，都按相应的排序规则来确定其位置；在<font color="red">查找时具有非常好的性能</font>；通常以<font color="red">平衡二叉树的方式实现。包含set、multiset、map、multimap，</font>具体实现原理如下：</p> <p>（1）set/multiset 头文件</p> <p>set 即集合。set中不允许相同元素，multiset中允许存在相同元素。</p> <p>（2）map/multimap 头文件</p> <p>map与set的不同在于map中存放的元素有且仅有两个成员变，一个名为first,另一个名为second, <font color="red">map根据first值对元素从小到大排序</font>，并可快速地根据first来检索元素。</p> <p><strong>注意</strong>：map同multimap的不同在于是否允许相同first值的元素。</p> </li><li> <p>容器适配器</p> <p><font color="red">封装了一些基本的容器，使之具备了新的函数功能</font>，比如把deque封装一下变为一个具有stack功能的数据结构。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue，具体实现原理如下：</p> <p>（1）stack 头文件</p> <p>栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最进插入序列的项（栈顶的项）。后进先出。</p> <p>（2）queue 头文件</p> <p>队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。</p> <p>（3）priority_queue 头文件</p> <p>优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。</p> </li></ol> 
<h5><a id="3__STL__map_hashtable_deque_list__90"></a>3 说说 STL 中 map hashtable deque list 的实现原理</h5> 
<p><strong>参考回答</strong></p> 
<p>map、hashtable、deque、list实现机理分别为红黑树、函数映射、双向队列、双向链表，他们的特性分别如下：</p> 
<ol><li> <p>map实现原理</p> <p>map内部实现了一个<strong>红黑树</strong>（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特<font color="red">点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。</font></p> </li><li> <p>hashtable（也称散列表，直译作哈希表）实现原理</p> <p>hashtable采用了<strong>函数映射的思想</strong>记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。这决定了哈希表特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。</p> </li><li> <p>deque实现原理</p> <p>deque内部实现的是一个<strong>双向队列</strong>。<font color="cornflowerblue">元素在内存连续存放</font>。随机存取任何元素都在常数时间完成（仅次于vector）。所有适用于vector的操作都适用于deque。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。</p> </li><li> <p>list实现原理</p> <p>list内部实现的是一个<strong>双向链表</strong>。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。无成员函数，给定一个下标i，访问第i个元素的内容，只能从头部挨个遍历到第i个元素。</p> </li></ol> 
<h5><a id="4__STL_allocator_112"></a>4 请你来介绍一下 STL 的空间配置器（allocator）</h5> 
<p><strong>参考回答</strong></p> 
<p>一般情况下,一个程序包括数据结构和相应的算法，而数据结构作为存储数据的组织形式，与内存空间有着密切的联系。在C++ STL中，<font color="red">空间配置器便是用来实现内存空间(一般是内存，也可以是硬盘等空间)分配的工具</font>，他与容器联系紧密，每一种容器的空间分配都是通过空间分配器alloctor实现的。</p> 
<p><strong>答案解析</strong></p> 
<ol><li> <p>两种C++类对象实例化方式的异同</p> <p>在c++中，创建类对象一般分为两种方式：一种是<font color="red">直接利用构造函数,直接构造类对象</font>，如 Test test()；另一种是<font color="red">通过new来实例化一个类对象</font>，如 Test *pTest = new Test；那么，这两种方式有什么异同点呢？</p> <p>我们知道，内存分配主要有三种方式：</p> <p>（1）<font color="red"> 静态存储区分配</font>：内存在程序<font color="red">编译的时候已经分配好</font>，这块内存在程序的<font color="red">整个运行空间内都存在</font>。如全局变量,静态变量等。</p> <p>（2） <font color="red">栈空间分配：</font>程序在<font color="red">运行期间，函数内的局部变量通过栈空间来分配存储</font>（函数调用栈），当<font color="cornflowerblue">函数执行完毕返回时，相对应的栈空间被立即回收。主要是局部变量。</font><br> （3）<font color="red">堆空间分配：</font>程序在运行期间，通过在堆空间上为数据分配存储空间，通过<font color="cornflowerblue">malloc和new创建的对象都是从堆空间分配内存，这类空间需要程序员自己来管理，必须通过free()或者是delete()函数对堆空间进行释放，否则会造成内存溢出。</font></p> <p>那么，从<strong>内存空间分配的角度</strong>来对这两种方式的区别，就比较容易区分:</p> <p>（1）对于第一种方式来说，是直接通过调用Test类的构造函数来实例化Test类对象的,如果该实例化对象是一个局部变量，则其是在栈空间分配相应的存储空间。<br> （2）对于第二种方式来说,就显得比较复杂。这里主要以new类对象来说明一下。new一个类对象,其实是执行了两步操作：首先,调用new在堆空间分配内存,然后调用类的构造函数构造对象的内容；同样，使用delete释放时，也是经历了两个步骤：首先调用类的析构函数释放类对象，然后调用delete释放堆空间。</p> </li><li> <p>C++ STL空间配置器实现</p> <p>很容易想象，为了实现空间配置器，完全可以利用new和delete函数并对其进行封装实现STL的空间配置器，的确可以这样。但是，为了最大化提升效率，SGI STL版本并没有简单的这样做，而是采取了一定的措施，实现了更加高效复杂的空间分配策略。由于以上的构造都分为两部分，所以，在SGI STL中，将对象的构造切分开来，分成空间配置和对象构造两部分。</p> <p>内存配置操作: 通过alloc::allocate()实现<br> ​ 内存释放操作: 通过alloc::deallocate()实现<br> ​ 对象构造操作: 通过::construct()实现<br> ​ 对象释放操作: 通过::destroy()实现</p> <p>关于内存空间的配置与释放，SGI STL采用了两级配置器：一级配置器主要是考虑大块内存空间，利用malloc和free实现；二级配置器主要是考虑小块内存空间而设计的（为了最大化解决内存碎片问题，进而提升效率），采用链表free_list来维护内存池（memory pool），free_list通过union结构实现，空闲的内存块互相挂接在一块，内存块一旦被使用，则被从链表中剔除，易于维护。</p> </li></ol> 
<h5><a id="5_STL__147"></a>5 STL 容器用过哪些，查找的时间复杂度是多少，为什么？</h5> 
<p><strong>参考回答</strong></p> 
<p>STL中常用的容器有vector、deque、list、map、set、multimap、multiset、unordered_map、unordered_set等。容器底层实现方式及时间复杂度分别如下：</p> 
<ol><li> <p>vector</p> <p>采用一维数组实现，元素在内存连续存放，不同操作的时间复杂度为：</p> <p>插入: O(N)</p> <p>查看: O(1)</p> <p>删除: O(N)</p> </li><li> <p>deque</p> <p>采用双向队列实现，元素在内存连续存放，不同操作的时间复杂度为：</p> <p>插入: O(N)</p> <p>查看: O(1)</p> <p>删除: O(N)</p> </li><li> <p>list</p> <p>采用双向链表实现，元素存放在堆中，不同操作的时间复杂度为：</p> <p>插入: O(1)</p> <p>查看: O(N)</p> <p>删除: O(1)</p> </li><li> <p>map、set、multimap、multiset</p> <p>上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为:</p> <p>插入: O(logN)</p> <p>查看: O(logN)</p> <p>删除: O(logN)</p> </li><li> <p>unordered_map、unordered_set、unordered_multimap、 unordered_multiset</p> <p>上述四种容器采用哈希表实现，不同操作的时间复杂度为：<br> 插入: O(1)，最坏情况O(N)</p> <p>查看: O(1)，最坏情况O(N)</p> <p>删除: O(1)，最坏情况O(N)</p> <p><strong>注意</strong>：容器的时间复杂度取决于其底层实现方式。</p> </li></ol> 
<h5><a id="6__204"></a>6 迭代器用过吗？什么时候会失效？</h5> 
<p><strong>参考回答</strong></p> 
<p>用过，常用容器迭代器失效情形如下。</p> 
<ol><li>对于<font color="red">序列容器</font>vector，deque来说，使用erase后，<font color="cornflowerblue">后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。</font></li><li>对于<font color="cornflowerblue">关联容器map</font>，set来说，使用了erase后，<font color="cornflowerblue">当前元素的迭代器失效</font>，但是其结构是红黑树，删除当前元素，<font color="red">不会影响下一个元素的迭代器</font>，所以在调用erase之前，记录下一个元素的迭代器即可。</li><li>对于<font color="red">list来说</font>，它使用了<font color="red">不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器</font>，因此上面两种方法都可以使用。</li></ol> 
<h5><a id="7_STL_214"></a>7 说一下STL中迭代器的作用，有指针为何还要迭代器？</h5> 
<ol><li> <p>迭代器的作用</p> <p>（1）用于指向顺序容器和关联容器中的元素</p> <p>（2）通过迭代器可以读取它指向的元素</p> <p>（3）通过非const迭代器还可以修改其指向的元素</p> </li><li> <p>迭代器和指针的区别</p> <p><strong>迭代器不是指针，是类模板，表现的像指针</strong>。他只是模拟了指针的一些功能，重载了指针的一些操作符，–&gt;、++、–等。迭代器封装了指针，是一个”可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象，<font color="red"><strong>本质</strong>是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针</font>，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p> <p><strong>迭代器返回的是对象引用而不是对象的值</strong>，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。</p> </li><li> <p>迭代器产生的原因</p> <p>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，<font color="red">使得不用暴露集合内部的结构而达到循环遍历集合的效果。</font></p> </li></ol> 
<p><strong>答案解析</strong></p> 
<ol><li> <p>迭代器</p> <p>Iterator（迭代器）模式又称游标（Cursor）模式，用于提供一种方法<strong>顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示</strong>。 或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们<strong>可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素</strong>。 由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展Iterator。</p> </li><li> <p>迭代器示例：</p> </li></ol> 
<pre><code class="prism language-c++">#include &lt;vector&gt;
#include &lt;iostream&gt;
using namespace std;

int main() {
    vector&lt;int&gt; v; //一个存放int元素的数组，一开始里面没有元素
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);
    vector&lt;int&gt;::const_iterator i; //常量迭代器
    for (i = v.begin(); i != v.end(); ++i) //v.begin()表示v第一个元素迭代器指针，++i指向下一个元素
        cout &lt;&lt; *i &lt;&lt; ","; //*i表示迭代器指向的元素
    cout &lt;&lt; endl;

    vector&lt;int&gt;::reverse_iterator r; //反向迭代器
    for (r = v.rbegin(); r != v.rend(); r++)
        cout &lt;&lt; *r &lt;&lt; ",";
    cout &lt;&lt; endl;
    vector&lt;int&gt;::iterator j; //非常量迭代器
    for (j = v.begin();j != v.end();j++)
        *j = 100;
    for (i = v.begin();i != v.end();i++)
        cout &lt;&lt; *i &lt;&lt; ",";
    return 0;
}

/*    运行结果：
          1,2,3,4,
          4,3,2,1,
          100,100,100,100,
*/                
</code></pre> 
<h5><a id="8__STL__278"></a>8 说说 STL 迭代器是怎么删除元素的</h5> 
<p><strong>参考回答</strong></p> 
<p>这是主要考察迭代器失效的问题。</p> 
<ol><li>对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器；</li><li>对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可；</li><li>对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。</li></ol> 
<p><strong>答案解析</strong></p> 
<p>容器上迭代器分类如下表（详细实现过程请翻阅相关资料详细了解）：</p> 
<table><thead><tr><th align="center">容器</th><th align="center">容器上的迭代器类别</th></tr></thead><tbody><tr><td align="center">vector</td><td align="center">随机访问</td></tr><tr><td align="center">deque</td><td align="center">随机访问</td></tr><tr><td align="center">list</td><td align="center">双向</td></tr><tr><td align="center">set/multiset</td><td align="center">双向</td></tr><tr><td align="center">map/multimap</td><td align="center">双向</td></tr><tr><td align="center">stack</td><td align="center">不支持迭代器</td></tr><tr><td align="center">queue</td><td align="center">不支持迭代器</td></tr><tr><td align="center">priority_queue</td><td align="center">不支持迭代器</td></tr></tbody></table> 
<h5><a id="9__STL__resize__reserve__303"></a>9 说说 STL 中 resize 和 reserve 的区别</h5> 
<p><strong>参考回答</strong></p> 
<ol><li> <p>首先必须弄清楚两个概念：</p> <p>（1）capacity：该值在容器初始化时赋值，指的是<font color="red">容器能够容纳的最大的元素的个数</font>。还不能通过下标等访问，因为此时容器中还没有创建任何对象。</p> <p>（2）size：指的是<font color="red">此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象</font>。</p> </li><li> <p>resize和reserve区别主要有以下几点：</p> <p>（1）<font color="red">resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert（）或push_back（）等创建对象。</font></p> <p>（2）<font color="red">resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小。</font></p> <p>（3）两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。</p> </li></ol> 
<p><strong>答案解析</strong></p> 
<p><strong>问题延伸：</strong></p> 
<p>resize 和 reserve 既有差别，也有共同点。两个接口的<strong>共同点</strong>是**它们都保证了vector的空间大小(capacity)最少达到它的参数所指定的大小。**下面就他们的细节进行分析。</p> 
<p>为实现resize的语义，resize接口做了两个保证：</p> 
<p>（1）保证区间[0, new_size)范围内数据有效，如果下标index在此区间内，vector[indext]是合法的；</p> 
<p>（2）保证区间[0, new_size)范围以外数据无效，如果下标index在区间外，vector[indext]是非法的。</p> 
<p>reserve只是保证vector的空间大小(capacity)最少达到它的参数所指定的大小n。在区间[0, n)范围内，如果下标是index，vector[index]这种访问有可能是合法的，也有可能是非法的，视具体情况而定。</p> 
<p>以下是两个接口的源代码：</p> 
<pre><code class="prism language-c++">void resize(size_type new_size)

   { 
           resize(new_size, T());
   }
  void resize(size_type new_size, const T&amp; x)
   {
        if (new_size &lt; size()) 
              erase(begin() + new_size, end()); // erase区间范围以外的数据，确保区间以外的数据无效
           else
              insert(end(), new_size - size(), x); // 填补区间范围内空缺的数据，确保区间内的数据有效
   }


#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int main()
{
    vector&lt;int&gt; a;
    cout&lt;&lt;"initial capacity:"&lt;&lt;a.capacity()&lt;&lt;endl;
    cout&lt;&lt;"initial size:"&lt;&lt;a.size()&lt;&lt;endl;

    /*resize改变capacity和size*/
    a.resize(20);
    cout&lt;&lt;"resize capacity:"&lt;&lt;a.capacity()&lt;&lt;endl;
    cout&lt;&lt;"resize size:"&lt;&lt;a.size()&lt;&lt;endl;


    vector&lt;int&gt; b;
     /*reserve改变capacity,不改变resize*/
    b.reserve(100);
    cout&lt;&lt;"reserve capacity:"&lt;&lt;b.capacity()&lt;&lt;endl;
    cout&lt;&lt;"reserve size:"&lt;&lt;b.size()&lt;&lt;endl;
return 0;
}

/*    运行结果：
          initial capacity:0
        initial size:0
        resize capacity:20
        resize size:20
        reserve capacity:100
        reserve size:0
*/    
</code></pre> 
<p><strong>注意</strong>：如果n大于当前的vector的容量(是容量，并非vector的size)，将会引起自动内存分配。所以现有的pointer,references,iterators将会失效。而内存的重新配置会很耗时间。</p> 
<h5><a id="10__STL__387"></a>10 说说 STL 容器动态链接可能产生的问题？</h5> 
<p><strong>参考回答</strong></p> 
<ol><li> <p>可能产生 的问题</p> <p>容器是一种动态分配内存空间的一个变量集合类型变量。在一般的程序函数里，局部容器，参数传递容器，参数传递容器的引用，参数传递容器指针都是可以正常运行的，而在动态链接库函数内部使用容器也是没有问题的，但是给动态库函数传递容器的对象本身，则会出现内存堆栈破坏的问题。</p> </li><li> <p>产生问题的原因<br> 容器和动态链接库相互支持不够好，动态链接库函数中使用容器时，参数中只能传递容器的引用，并且要保证容器的大小不能超出初始大小，否则导致容器自动重新分配，就会出现内存堆栈破坏问题。</p> </li></ol> 
<h5><a id="11__map__unordered_map__398"></a>11 说说 map 和 unordered_map 的区别？底层实现</h5> 
<p><strong>参考回答</strong></p> 
<p>map和unordered_map的区别在于他们的<strong>实现基理不同</strong>。</p> 
<ol><li> <p>map实现机理</p> <p><font color="red">map内部实现了一个<strong>红黑树</strong>（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。</font>因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。</p> </li><li> <p>unordered_map实现机理</p> <p><font color="red">unordered_map内部实现了一个<strong>哈希表</strong>（也叫散列表），通过把关键码值映射到Hash表中一个位置来访问记录，查找时间复杂度可达O（1）</font>，其中在海量数据处理中有着广泛应用。因此，元素的排列顺序是无序的。</p> </li></ol> 
<h5><a id="12__vector__list__412"></a>12 说说 vector 和 list 的区别，分别适用于什么场景？</h5> 
<p><strong>参考回答</strong></p> 
<p>vector和list区别在于<strong>底层实现机理不同</strong>，因而特性和适用场景也有所不同。</p> 
<p><strong>vector：一维数组</strong></p> 
<p>特点：元素在内存连续存放，动态数组，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后内存也不会释放。</p> 
<p>优点：和数组类似开辟一段连续的空间，并且支持随机访问，所以它的查找效率高其时间复杂度O(1)。</p> 
<p>缺点：由于开辟一段连续的空间，所以插入删除会需要对数据进行移动比较麻烦，时间复杂度O（n），另外当空间不足时还需要进行扩容。</p> 
<p><strong>list：双向链表</strong></p> 
<p>特点：元素在堆中存放，每个元素都是存放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问。</p> 
<p>优点：底层实现是循环双链表，当对大量数据进行插入删除时，其时间复杂度O(1)。</p> 
<p>缺点：底层没有连续的空间，只能通过指针来访问，所以查找数据需要遍历其时间复杂度O（n），没有提供[]操作符的重载。</p> 
<p><strong>应用场景</strong></p> 
<p><font color="red"> vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。</font></p> 
<p><font color="red"> list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</font></p> 
<h5><a id="13__vector__440"></a>13 简述 vector 的实现原理</h5> 
<p><strong>参考回答</strong></p> 
<p>vector底层实现原理为<strong>一维数组</strong>（元素在空间连续存放）。</p> 
<ol><li> <p>新增元素</p> <p>Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。插入新的数据分在最后插入push_back和通过迭代器在任何位置插入，这里说一下通过迭代器插入，通过迭代器与第一个元素的距离知道要插入的位置，即int index=iter-begin()。这个元素后面的所有元素都向后移动一个位置，在空出来的位置上存入新增的元素。</p> <pre><code class="prism language-c++">//新增元素 
void insert(const_iterator iter,const T&amp; t )
    {  
        int index=iter-begin();
        if (index&lt;size_)
       {
           if (size_==capacity_)
           {
                int capa=calculateCapacity();
              newCapacity(capa);
           }
           memmove(buf+index+1,buf+index,(size_-index)*sizeof(T)); 
           buf[index]=t;
           size_++;
       } 
   }
</code></pre> </li><li> <p>删除元素</p> <p>删除和新增差不多，也分两种，删除最后一个元素pop_back和通过迭代器删除任意一个元素erase(iter)。通过迭代器删除还是先找到要删除元素的位置，即int index=iter-begin();这个位置后面的每个元素都想前移动一个元素的位置。同时我们知道erase不释放内存只初始化成默认值。</p> <p>删除全部元素clear：只是循环调用了erase，所以删除全部元素的时候，不释放内存。内存是在析构函数中释放的。</p> <pre><code class="prism language-c++">//删除元素 
iterator erase(const_iterator iter)
        {
            int index=iter-begin(); 
            if (index&lt;size_ &amp;&amp; size_&gt;0)
            {
                memmove(buf+index ,buf+index+1,(size_-index)*sizeof(T)); 
                buf[--size_]=T();
            } 
            return iterator(iter); 
        }
</code></pre> </li><li> <p>迭代器iteraotr</p> <p>迭代器iteraotr是STL的一个重要组成部分,通过iterator可以很方便的存储集合中的元素.STL为每个集合都写了一个迭代器, 迭代器其实是对一个指针的包装,实现一些常用的方法,如++,–,!=,==,*,-&gt;等, 通过这些方法可以找到当前元素或是别的元素. vector是STL集合中比较特殊的一个,因为vector中的每个元素都是连续的,所以在自己实现vector的时候可以用指针代替。</p> <pre><code class="prism language-c++">//迭代器的实现
template&lt;class _Category,
    class _Ty,
    class _Diff = ptrdiff_t,
    class _Pointer = _Ty *,
    class _Reference = _Ty&amp;&gt;
    struct iterator
    {    // base type for all iterator classes
           typedef _Category iterator_category;
           typedef _Ty value_type;
           typedef _Diff difference_type;
           typedef _Diff distance_type;    // retained
           typedef _Pointer pointer;
           typedef _Reference reference;
    };
</code></pre> </li></ol> 
<h5><a id="14__STL__map__511"></a>14 简述 STL 中的 map 的实现原理</h5> 
<p><strong>参考回答</strong></p> 
<p>map是关联式容器，它们的底层容器都是<strong>红黑树</strong>。map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。</p> 
<ol><li> <p>map的特性如下</p> <p>（1）map以RBTree作为底层容器；</p> <p>（2）所有元素都是键+值存在；</p> <p>（3）不允许键重复；</p> <p>（4）所有元素是通过键进行自动排序的；</p> <p>（5）map的键是不能修改的，但是其键对应的值是可以修改的。</p> </li></ol> 
<h5><a id="15_C__vector__list_529"></a>15 C++ 的 vector 和 list中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？</h5> 
<p><strong>参考回答</strong></p> 
<ol><li> <p>迭代器和指针之间的区别</p> <p><strong>迭代器不是指针，是类模板，表现的像指针</strong>。他只是模拟了指针的一些功能，重载了指针的一些操作符，–&gt;、++、–等。迭代器封装了指针，是一个”可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象，<strong>本质</strong>是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p> <p><strong>迭代器返回的是对象引用而不是对象的值</strong>，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。</p> </li><li> <p>vector和list特性</p> <p><strong>vector特性</strong> 动态数组。元素在内存连续存放。随机存取任何元素都在常数时间完成。在尾端增删元素具有较大的性能（大部分情况下是常数时间）。</p> <p><strong>list特性</strong> 双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。</p> </li><li> <p>vector增删元素</p> <p>对于vector而言，删除某个元素以后，该元素后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。</p> </li><li> <p>list增删元素</p> <p>对于list而言，删除某个元素，只有“指向被删除元素”的那个迭代器失效，其它迭代器不受任何影响。</p> </li></ol> 
<h5><a id="16__map__set__553"></a>16 请你来说一下 map 和 set 有什么区别，分别又是怎么实现的？</h5> 
<p><strong>参考回答</strong></p> 
<ol><li> <p>set是一种关联式容器，其特性如下：</p> <p>（1）set以RBTree作为底层容器</p> <p>（2）所得元素的只有key没有value，value就是key</p> <p>（3）不允许出现键值重复</p> <p>（4）所有的元素都会被自动排序</p> <p>（5）不能通过迭代器来改变set的值，因为set的值就是键，set的迭代器是const的</p> </li><li> <p>map和set一样是关联式容器，其特性如下：</p> <p>（1）map以RBTree作为底层容器</p> <p>（2）所有元素都是键+值存在</p> <p>（3）不允许键重复</p> <p>（4）所有元素是通过键进行自动排序的</p> <p>（5）map的键是不能修改的，但是其键对应的值是可以修改的</p> <p>综上所述，map和set<strong>底层实现</strong>都是红黑树；map和set的<strong>区别</strong>在于map的值不作为键，键和值是分开的。</p> </li></ol> 
<h5><a id="18__push_back__emplace_back__583"></a>18 说说 push_back 和 emplace_back 的区别</h5> 
<p><strong>参考回答</strong></p> 
<p>如果要将一个临时变量push到容器的末尾，push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。</p> 
<p><strong>答案解析</strong></p> 
<p>参考代码：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
using namespace std;

class A {
public:
    A(int i){
        str = to_string(i);
        cout &lt;&lt; "构造函数" &lt;&lt; endl; 
    }
    ~A(){}
    A(const A&amp; other): str(other.str){
        cout &lt;&lt; "拷贝构造" &lt;&lt; endl;
    }

public:
    string str;
};

int main()
{
    vector&lt;A&gt; vec;
    vec.reserve(10);
    for(int i=0;i&lt;10;i++){
        vec.push_back(A(i)); //调用了10次构造函数和10次拷贝构造函数,
//        vec.emplace_back(i);  //调用了10次构造函数一次拷贝构造函数都没有调用过
    }
</code></pre> 
<h5><a id="19_STL__vector__list__624"></a>19 STL 中 vector 与 list 具体是怎么实现的？常见操作的时间复杂度是多少？</h5> 
<p><strong>参考回答</strong></p> 
<ol><li> <p>vector 一维数组（元素在内存连续存放）</p> <p>是动态数组，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后，内存也不会释放；如果新增大小当前大小时才会重新分配内存。</p> <p>扩容方式： a. 倍放开辟三倍的内存</p> <p>b. 旧的数据开辟到新的内存</p> <p>c. 释放旧的内存</p> <p>d. 指向新内存</p> </li><li> <p>list 双向链表（元素存放在堆中）</p> <p>元素存放在堆中，每个元素都是放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点，使得它的随机存取变得非常没有效率，因此它没有提供[ ]操作符的重载。但是由于链表的特点，它可以很有效的支持任意地方的删除和插入操作。</p> <p>特点：a. 随机访问不方便</p> <p>b. 删除插入操作方便</p> </li><li> <p>常见时间复杂度</p> <p>（1）vector插入、查找、删除时间复杂度分别为：O(n)、O(1)、O(n)；</p> <p>（2）list插入、查找、删除时间复杂度分别为：O(1)、O(n)、O(1)。</p> </li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2052bbc491675c004cc62afea59cae2d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kotlin 委派(ReadOnlyProperty) 仿造viewModels 写一个viewBindings</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/95580e26c6016a5fb34fa897ffdfd0f5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IDEA快捷键</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>