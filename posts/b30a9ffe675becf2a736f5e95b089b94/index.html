<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【分布式事务】深入探索 Seata 的四种分布式事务解决方案的原理，优缺点以及在微服务中的实现 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【分布式事务】深入探索 Seata 的四种分布式事务解决方案的原理，优缺点以及在微服务中的实现" />
<meta property="og:description" content="文章目录 前言一、XA 模式1.1 XA 模式原理1.2 XA 模式的优缺点及应用场景1.3 Seata XA 模式在微服务中的实现 二、AT 模式2.1 Seata AT 模式原理2.2 AT 模式的脏写问题和写隔离3.3 AT 模式的优缺点3.4 Seata AT 模式在微服务中的实现 三、TCC 模式3.1 TCC 模式原理3.2 Seata 的 TCC 模型3.3 TCC 模型事务悬挂和空回滚3.4 TCC 模式的实现 四、SAGA 模式4.1 SAGA 模式原理4.2 SAGA 模式的优缺点 前言 分布式事务是在分布式系统中保持数据一致性的关键问题之一。Seata（Simple Extensible Autonomous Transaction Architecture）是一款开源的分布式事务解决方案，它提供了四种不同的事务模式，分别是XA、AT、TCC、SAGA。本文将深入探讨这四种分布式事务解决方案的原理、优缺点以及应用场景，以帮助开发人员更好地选择适合其项目的分布式事务模式。
一、XA 模式 1.1 XA 模式原理 XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范描述了全局的 TM 与局部的 RM 之间的接口，几乎所有主流的数据库都对 XA 规范提供了支持。
XA 模式的事务管理可以分为两个阶段：
正常情况，即所有分支事务都执行成功，需要提交：
第一阶段： 事务协调者（TM）通知局部资源管理器（RM）准备执行业务操作。所有分支事务执行成功，RM 告知 TM 自己已经就绪准备提交事务。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/b30a9ffe675becf2a736f5e95b089b94/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-08T16:59:59+08:00" />
<meta property="article:modified_time" content="2023-11-08T16:59:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【分布式事务】深入探索 Seata 的四种分布式事务解决方案的原理，优缺点以及在微服务中的实现</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_6" rel="nofollow">前言</a></li><li><a href="#XA__9" rel="nofollow">一、XA 模式</a></li><li><ul><li><a href="#11_XA__10" rel="nofollow">1.1 XA 模式原理</a></li><li><a href="#12_XA__64" rel="nofollow">1.2 XA 模式的优缺点及应用场景</a></li><li><a href="#13_Seata_XA__92" rel="nofollow">1.3 Seata XA 模式在微服务中的实现</a></li></ul> 
  </li><li><a href="#AT__120" rel="nofollow">二、AT 模式</a></li><li><ul><li><a href="#21_Seata_AT__124" rel="nofollow">2.1 Seata AT 模式原理</a></li><li><a href="#22_AT__209" rel="nofollow">2.2 AT 模式的脏写问题和写隔离</a></li><li><a href="#33_AT__247" rel="nofollow">3.3 AT 模式的优缺点</a></li><li><a href="#34_Seata_AT__265" rel="nofollow">3.4 Seata AT 模式在微服务中的实现</a></li></ul> 
  </li><li><a href="#TCC__341" rel="nofollow">三、TCC 模式</a></li><li><ul><li><a href="#31_TCC__343" rel="nofollow">3.1 TCC 模式原理</a></li><li><a href="#32_Seata__TCC__388" rel="nofollow">3.2 Seata 的 TCC 模型</a></li><li><a href="#33_TCC__419" rel="nofollow">3.3 TCC 模型事务悬挂和空回滚</a></li><li><a href="#34_TCC__444" rel="nofollow">3.4 TCC 模式的实现</a></li></ul> 
  </li><li><a href="#SAGA__576" rel="nofollow">四、SAGA 模式</a></li><li><ul><li><a href="#41_SAGA__578" rel="nofollow">4.1 SAGA 模式原理</a></li><li><a href="#42_SAGA__594" rel="nofollow">4.2 SAGA 模式的优缺点</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_6"></a>前言</h2> 
<p>分布式事务是在分布式系统中保持数据一致性的关键问题之一。Seata（Simple Extensible Autonomous Transaction Architecture）是一款开源的分布式事务解决方案，它提供了四种不同的事务模式，分别是XA、AT、TCC、SAGA。本文将深入探讨这四种分布式事务解决方案的原理、优缺点以及应用场景，以帮助开发人员更好地选择适合其项目的分布式事务模式。</p> 
<h2><a id="XA__9"></a>一、XA 模式</h2> 
<h3><a id="11_XA__10"></a>1.1 XA 模式原理</h3> 
<p>XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范描述了全局的 TM 与局部的 RM 之间的接口，几乎所有主流的数据库都对 XA 规范提供了支持。</p> 
<p><strong>XA 模式的事务管理可以分为两个阶段：</strong></p> 
<p><strong>正常情况，即所有分支事务都执行成功，需要提交：</strong></p> 
<p><img src="https://images2.imgbox.com/70/97/gqiVLkoC_o.png" alt=""></p> 
<ol><li> <p><strong>第一阶段：</strong> 事务协调者（TM）通知局部资源管理器（RM）准备执行业务操作。所有分支事务执行成功，RM 告知 TM 自己已经就绪准备提交事务。</p> </li><li> <p><strong>第二阶段：</strong> TM 通知所有 RM 提交事务，即所有分支事务的更改被持久化，当所有的分支事务提交成功后告知 TM 自己已提交。</p> </li></ol> 
<p><strong>异常情况，即存在分支事务执行失败，需要回滚：</strong></p> 
<p><img src="https://images2.imgbox.com/76/38/CBGRaZAY_o.png" alt=""></p> 
<ol><li> <p><strong>第一阶段：</strong> 事务协调者（TM）通知局部资源管理器（RM）准备执行业务操作，存在分支事务执行失败，就向 TM 返回自己执行失败。</p> </li><li> <p><strong>第二阶段：</strong> 如果存在分支事务执行失败，TM 通知所有执行成功并处于就绪状态的 RM 回滚事务，即所有分支事务的更改被撤销。</p> </li></ol> 
<blockquote> 
 <p><strong>Seata 的 XA 模式</strong></p> 
</blockquote> 
<p>Seata 对原始的 XA 模式做了简单的封装和改造，以适应自己的事务模型，基本架构如图如下：</p> 
<p><img src="https://images2.imgbox.com/14/09/LwO3h8p3_o.png" alt=""><br> Seata 的 XA 模式与传统的 XA 模式相似，在实际工作流程中进行了一些调整。以下是 Seata XA 模式的工作原理说明：</p> 
<ol><li> <p><strong>RM 一阶段的工作：</strong></p> 
  <ul><li>RM 将分支事务注册到全局事务协调器（TC）。</li><li>RM 执行分支业务操作，但不提交。这确保了分支事务不会立即生效，等待全局协调后再决定是否提交。</li><li>RM 报告分支事务执行状态给 TC。</li></ul> </li><li> <p><strong>TC 二阶段的工作：</strong></p> 
  <ul><li>TC 检测各个分支事务的执行状态。</li><li>如果所有分支事务都成功，TC通知所有RM提交事务，即提交所有分支事务的更改。</li><li>如果有任何分支事务失败，TC通知所有RM回滚事务，即回滚所有分支事务的更改</li></ul> </li><li> <p><strong>RM二阶段的工作：</strong></p> 
  <ul><li>RM 接收来自TC的指令，根据指令来提交或回滚分支事务。</li></ul> </li></ol> 
<p>Seata 的 XA 模式通过全局事务协调器（TC）确保分布式事务的一致性，它与传统 XA 模式的主要区别在于 Seata 对分支事务的执行进行了微调，以便更好地适应分布式事务管理的需求。这种模式允许应用在分布式环境中实现事务管理，确保数据的一致性。</p> 
<h3><a id="12_XA__64"></a>1.2 XA 模式的优缺点及应用场景</h3> 
<p><strong>优点：</strong></p> 
<ol><li> <p><strong>强一致性：</strong> XA 模式保证了数据的强一致性，即要么所有事务都提交成功，要么都回滚失败。这对于需要高度一致性的应用非常重要，如金融系统或在线支付。</p> </li><li> <p><strong>广泛支持：</strong> XA 模式是一种经典的分布式事务处理标准，几乎所有主流的数据库都支持 XA 规范，因此可以在不同的数据库和消息队列之间进行事务协调。</p> </li></ol> 
<p><strong>缺点：</strong></p> 
<ol><li> <p><strong>性能开销：</strong> 由于涉及到两个阶段的协调，XA 模式通常性能开销较大。在第一阶段，需要等待所有分支事务执行完毕并报告状态，而在第二阶段，需要等待所有分支事务的提交或回滚完成。这导致了较长的事务执行时间。</p> </li><li> <p><strong>单点问题：</strong> XA 模式中需要一个全局的事务协调器（Transaction Coordinator），这可能成为系统的单点故障。如果事务协调器发生故障，整个系统的可用性将受到影响。</p> </li><li> <p><strong>资源锁定：</strong> 在第一阶段，分支事务执行后需要等待全局事务协调器的指令，这可能导致资源锁定时间较长，影响并发性能。</p> </li><li> <p><strong>复杂性：</strong> 实现 XA 模式的分布式事务处理需要复杂的编程和配置，开发和维护成本较高。</p> </li></ol> 
<p><strong>应用场景：</strong></p> 
<p>XA 模式适用于对<code>数据强一致性要求较高</code>的场景，其中数据的一致性比性能更为重要。一些典型的应用场景包括：</p> 
<ul><li>金融系统：在金融交易中，数据的一致性至关重要，因此需要使用 XA 模式来确保所有相关操作的一致性。</li><li>在线支付：在线支付系统必须确保交易的一致性，以避免出现重复扣款或未扣款的情况。</li><li>订单处理系统：在订单处理系统中，需要确保订单的创建、支付、发货等操作都能够保持一致性，以避免出现订单漏发或重复发货的问题。</li></ul> 
<p>总之，XA 模式适用于那些对数据一致性要求非常高且可以承受一定性能开销的分布式应用场景。</p> 
<h3><a id="13_Seata_XA__92"></a>1.3 Seata XA 模式在微服务中的实现</h3> 
<p>这里我以<a href="https://blog.csdn.net/qq_61635026/article/details/134271840?spm=1001.2014.3001.5501">前文</a>的 <code>seata-cloud-demo</code> 为例，来演示 Seata 分布式事务不同的解决方案，首先是 XA 模式：</p> 
<p>由于 Seata 的 <code>starter</code> 已经完成了 XA 模式的自动装配，实现就变得非常简单了，步骤如下：</p> 
<ol><li> <p>修改<code>application.yml</code>文件（每个参与事务的微服务），开启 XA 模式：</p> <pre><code class="prism language-yml"><span class="token key atrule">seata</span><span class="token punctuation">:</span>
  <span class="token key atrule">data-source-proxy-mode</span><span class="token punctuation">:</span> XA <span class="token comment"># 开启数据源代理的 XA 模式</span>
</code></pre> </li><li> <p>给发起全局事务的入口方法添加 <code>@GlobalTransactional</code> 注解，在上面创建订单的整个微服务中，全局事务的入口就是创建订单的业务逻辑的 <code>create</code> 方法：<br> <img src="https://images2.imgbox.com/d3/03/koeuak21_o.png" alt=""><br> 这里将 <code>@Transactional</code> 注解改成 <code>@GlobalTransactional</code> 即可：<br> <img src="https://images2.imgbox.com/02/98/av8EzMW1_o.png" alt=""></p> </li><li> <p>当完成上面所有的配置之后，就可以启动所有的微服务，然后使用 Postman 进行测试了：</p> 
  <ul><li>现在账户表和库存表的数据如下：<br> <img src="https://images2.imgbox.com/8d/6f/i6BrTOr8_o.png" alt=""><br> <img src="https://images2.imgbox.com/45/49/jZUJyiIV_o.png" alt=""></li><li>直接演示创建订单失败的情况：<br> <img src="https://images2.imgbox.com/af/bd/n7Z33TCa_o.png" alt=""></li><li>此时由于库存不足，创建订单失败了，在前文中因为没有实现分布式事务，因此账户服务在执行成功之后没有进行回滚，而现在实现了分布式事务，则就不应该再扣款了：<br> <img src="https://images2.imgbox.com/e4/71/H4JAUCXN_o.png" alt=""><br> 通过 <code>account-service</code> 服务的日志来看，也是先执行成功了，最后因为库存服务执行失败，进行了回滚操作：<br> <img src="https://images2.imgbox.com/f5/81/n2bw8q9J_o.png" alt=""></li></ul> </li></ol> 
<h2><a id="AT__120"></a>二、AT 模式</h2> 
<p>AT 模式同样是分阶段提交的事务模式，不过弥补了 XA 模型中因为锁对资源而导致的周期过长问题：</p> 
<h3><a id="21_Seata_AT__124"></a>2.1 Seata AT 模式原理</h3> 
<p>AT模式（Auto Transaction）是一种自动事务模式，它试图通过自动提交和回滚来实现分布式事务的一致性。与 XA 模式不同，AT 模式一阶段直接提交事务，不会锁定资源，AT 模式下数据的回滚依赖于数据库的 <code>undo log</code>。</p> 
<p><strong>在 Seata 的 AT 模式中，事务管理的架构图如下：</strong></p> 
<p><img src="https://images2.imgbox.com/aa/8d/hIoSqXEg_o.png" alt=""></p> 
<p><strong>Seata AT 模式的事务管理流程：</strong></p> 
<ol><li> <p><strong>阶段一 RM 的工作：</strong></p> 
  <ul><li>注册分支事务：当一个分支事务开始时，它会在本地数据库中注册自己。</li><li>记录 <code>undo-log</code>（数据快照）：在分支事务执行业务SQL之前，记录当前数据的快照，以便在回滚时恢复数据。</li><li>执行业务SQL并提交：分支事务执行业务SQL并自动提交本地事务。这是AT模式的特点，不涉及两阶段提交。</li><li>报告事务状态：RM报告分支事务的执行状态给TC（Transaction Coordinator）。</li></ul> </li><li> <p><strong>阶段二提交时 RM 的工作：</strong></p> 
  <ul><li>在提交时，RM只需删除相应的<code>undo-log</code>，因为分支事务已经自动提交，不需要额外的提交操作。</li></ul> </li><li> <p><strong>阶段二回滚时 RM 的工作：</strong></p> 
  <ul><li>在回滚时，RM根据之前记录的<code>undo-log</code>来恢复数据到更新前的状态。</li></ul> </li></ol> 
<p>Seata 的 AT 模式依赖于数据库的本地事务管理能力，每个分支事务在本地自动管理自己的事务。如果分支事务成功提交，那么全局事务也会提交；如果分支事务出现失败，全局事务将会回滚，确保数据的一致性。</p> 
<p>总的来说，Seata 的 AT 模式通过自动提交和回滚分支事务，减少了全局事务协调的复杂性，同时提供了高性能的分布式事务管理方式。这种模式适用于那些可以容忍一定程度数据不一致的应用场景，特别是对性能要求较高的应用。</p> 
<blockquote> 
 <p>例如，现在用一个真实的业务来梳理下 AT 模式的原理。</p> 
</blockquote> 
<p>比如，现在又一个数据库表，记录用户余额：</p> 
<table><thead><tr><th><strong>id</strong></th><th><strong>money</strong></th></tr></thead><tbody><tr><td>1</td><td>100</td></tr></tbody></table> 
<p>其中一个分支业务要执行的SQL为：</p> 
<pre><code class="prism language-sql"><span class="token keyword">update</span> tb_account <span class="token keyword">set</span> money <span class="token operator">=</span> money <span class="token operator">-</span> <span class="token number">10</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span>
</code></pre> 
<p>AT 模式下，当前分支事务执行流程如下：</p> 
<p><strong>一阶段：</strong></p> 
<ol><li> <p>TM 发起并注册全局事务到 TC</p> </li><li> <p>TM 调用分支事务</p> </li><li> <p>分支事务准备执行业务 SQL</p> </li><li> <p>RM 拦截业务 SQL，根据 where 条件查询原始数据，形成快照。</p> <pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"id"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string-property property">"money"</span><span class="token operator">:</span> <span class="token number">100</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>RM 执行业务 SQL，提交本地事务，释放数据库锁。此时 <code>money = 90</code></p> </li><li> <p>RM 报告本地事务状态给 TC</p> </li></ol> 
<p><strong>二阶段：</strong></p> 
<ol><li> <p>TM 通知 TC 事务结束</p> </li><li> <p>TC 检查分支事务状态</p> 
  <ul><li>如果都成功，则立即删除快照</li><li>如果有分支事务失败，需要回滚。读取快照数据（<code>{"id": 1, "money": 100}</code>），将快照恢复到数据库。此时数据库再次恢复为 100</li></ul> </li></ol> 
<p><strong>上述过程的流程图：</strong></p> 
<p><img src="https://images2.imgbox.com/c7/4c/zjRKyKWe_o.png" alt=""></p> 
<h3><a id="22_AT__209"></a>2.2 AT 模式的脏写问题和写隔离</h3> 
<blockquote> 
 <p><strong>脏写问题：</strong></p> 
</blockquote> 
<p>在多线程并发访问 AT 模式的分布式事务时，有可能出现脏写问题，例如下图所示：</p> 
<p><img src="https://images2.imgbox.com/b5/63/EHcfQI60_o.png" alt=""><br> <strong>对上图中脏写问题的说明：</strong></p> 
<ol><li>同时有两个并发的全局事务执行：<code>update tb_account set money = money - 10 where id = 1</code>；</li><li>事务 1 首先获取到了 DB 锁，保存了快照（此时 <code>money</code> 为 100）之后，执行业务逻辑将 <code>money</code> 设置为了 90，然后提交了分支事务，并是否了 DB 锁；</li><li>此时，事务 2 也获取到了 DB 锁，然后保存了快照（此时的 <code>money</code> 为 90），然后执行业务将 <code>money</code> 设置成了 80，提交分支事务并是否 DB 锁；</li><li>事务 1 因为后续的其中分支事务执行失败了，因此需要恢复前面所有提交了的分支事务，此时再次获取到了 DB 锁，然后需要根据自己的快照（<code>money</code> 为 100）来恢复数据。但是，此时的数据库中的 <code>money</code> 为 80，而站在事务 1 的角度则应该为 90，因此就丢失了一次更新，出现了脏写的问题。</li></ol> 
<blockquote> 
 <p><strong>解决方法：</strong></p> 
</blockquote> 
<p>为了解决上面的脏写问题，Seata 引入了全局锁，开启写隔离。即在释放 DB 锁之前，先拿到全局锁，避免同一时刻有另外一个事务来操作当前数据：</p> 
<p><img src="https://images2.imgbox.com/c7/c4/jFpCXzd0_o.png" alt=""><strong>对上述写隔离的详细说明：</strong></p> 
<ol><li>同样是两个并发的全局事务执行：<code>update tb_account set money = money - 10 where id = 1</code>；</li><li>事务1 首先获取到 DB 锁，并保存了快照（<code>money</code> 为 100），然后执行了业务逻辑（更新 <code>money</code> 为 90），在提交分支事务之前获取了全局锁，然后提交分支事务，释放 DB 锁；</li><li>然后事务 2 就获取到了 DB 锁，保存快照（<code>money</code> 为 90），然后执行业务逻辑（设置<code>money</code> 为 80），执行完之后尝试获取全局锁，但此时全局锁被事务 1 持有，因此执行重复尝试获取，如果一直获取不到则会导致任务超时，自动回滚并释放 DB 锁；</li><li>后面事务1因为其他分支事务执行失败，首先获取 DB 锁，然后根据快照恢复数据，快照中 <code>money</code> 为 100，实际和 事务1 所期望的 <code>money</code> 都为 90，因此成功通过快照恢复数据。</li></ol> 
<p>要实现上面这个功能，需要额外引入一个数据库表，来记录当前全局锁的获取情况。</p> 
<blockquote> 
 <p>但是还是一个问题，那就是如果是一个 Seata 管理的全局事务和一个非 Seata 管理的全局事务来并发执行上述的业务逻辑，又该如何保存数据的一致性呢？</p> 
</blockquote> 
<p>幸运的是，Seata 以及为我们考虑到了这个问题（虽然这个问题一般不会出现）：<br> <img src="https://images2.imgbox.com/c7/4d/IXZy9bl5_o.png" alt="">Seata 会在执行业务逻辑的前后都生成一个快照，即<code>before-image</code> 和 <code>after-image</code>，后面当需要进行数据的恢复时就需要对比这两个快照和实际数据库中的数据是否一致，然后再执行数据的恢复操作。如果数据不一致，则需要记录异常，发出警告，通知人工介入来处理。</p> 
<h3><a id="33_AT__247"></a>3.3 AT 模式的优缺点</h3> 
<p>AT（Auto Transaction）模式是Seata中的一种分布式事务模式，它具有优点和缺点如下：</p> 
<p><strong>优点：</strong></p> 
<ol><li> <p><strong>一阶段完成直接提交事务：</strong> AT 模式的第一阶段（执行业务SQL并自动提交）不涉及全局事务协调器的参与，因此可以更快地完成事务操作，释放数据库资源，从而提高性能。</p> </li><li> <p><strong>利用全局锁实现读写隔离：</strong> AT 模式引入全局锁和写隔离，可以防止脏写问题和提供写隔离。这有助于确保数据的一致性和避免并发写操作导致的问题。</p> </li><li> <p><strong>没有代码侵入，框架自动完成回滚和提交：</strong> 在 AT 模式下，开发人员不需要编写特定的代码来处理分布式事务的提交和回滚，Seata 框架会自动处理这些事务管理的细节，降低了开发的复杂性。</p> </li></ol> 
<p><strong>缺点：</strong></p> 
<ul><li><strong>两阶段之间属于软状态：</strong> AT 模式中的两阶段提交之间是一个软状态，全局事务在第一阶段已经提交了分支事务，但最终一致性要在第二阶段进行检查和修复。这可能导致一定程度的数据不一致性，尤其是在第二阶段出现问题时。</li></ul> 
<p>尽管 AT 模式具有一些显著的优点，例如性能较好和较低的代码侵入性，但它仍然面临着最终一致性和软状态的挑战。开发人员需要权衡这些因素，并根据应用程序的需求选择适当的分布式事务模式。</p> 
<h3><a id="34_Seata_AT__265"></a>3.4 Seata AT 模式在微服务中的实现</h3> 
<p>AT 模式中的快照生成、回滚等动作都是由框架自动完成，没有任何代码侵入，因此实现非常简单。只不过，AT 模式需要一个表来记录全局锁，另一张表来记录数据快照 <code>undo_log</code>。下面是实现 AT 模式的具体步骤：</p> 
<ol><li>导入数据库表，记录全局锁和快照</li></ol> 
<p><code>lock_table</code> 用于记录全局锁，其使用对象的 <code>seata-server</code>，因此需要在<code>seata</code>数据库（由<code>seataServer.properties</code>配置文件指定）中创建该表：</p> 
<pre><code class="prism language-sql"><span class="token comment">-- ----------------------------</span>
<span class="token comment">-- Table structure for lock_table</span>
<span class="token comment">-- ----------------------------</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token identifier"><span class="token punctuation">`</span>lock_table<span class="token punctuation">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>lock_table<span class="token punctuation">`</span></span>  <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">`</span>row_key<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8 <span class="token keyword">COLLATE</span> utf8_general_ci <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>xid<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">96</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8 <span class="token keyword">COLLATE</span> utf8_general_ci <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>transaction_id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>branch_id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>resource_id<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8 <span class="token keyword">COLLATE</span> utf8_general_ci <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>table_name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8 <span class="token keyword">COLLATE</span> utf8_general_ci <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>pk<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8 <span class="token keyword">COLLATE</span> utf8_general_ci <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span></span> <span class="token keyword">datetime</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span></span> <span class="token keyword">datetime</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>row_key<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">,</span>
  <span class="token keyword">INDEX</span> <span class="token identifier"><span class="token punctuation">`</span>idx_branch_id<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>branch_id<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">=</span> utf8 <span class="token keyword">COLLATE</span> <span class="token operator">=</span> utf8_general_ci ROW_FORMAT <span class="token operator">=</span> Compact<span class="token punctuation">;</span>
</code></pre> 
<p><code>undo_log</code>表用于记录快照，因此其使用对象是微服务，因此和账户表等创建到同一个数据库下：</p> 
<pre><code class="prism language-sql"><span class="token comment">-- ----------------------------</span>
<span class="token comment">-- Table structure for undo_log</span>
<span class="token comment">-- ----------------------------</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token identifier"><span class="token punctuation">`</span>undo_log<span class="token punctuation">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>undo_log<span class="token punctuation">`</span></span>  <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">`</span>branch_id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'branch transaction id'</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>xid<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8 <span class="token keyword">COLLATE</span> utf8_general_ci <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'global transaction id'</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>context<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8 <span class="token keyword">COLLATE</span> utf8_general_ci <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'undo_log context,such as serialization'</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>rollback_info<span class="token punctuation">`</span></span> <span class="token keyword">longblob</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'rollback info'</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>log_status<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'0:normal status,1:defense status'</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>log_created<span class="token punctuation">`</span></span> <span class="token keyword">datetime</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'create datetime'</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>log_modified<span class="token punctuation">`</span></span> <span class="token keyword">datetime</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'modify datetime'</span><span class="token punctuation">,</span>
  <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> <span class="token identifier"><span class="token punctuation">`</span>ux_undo_log<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>xid<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>branch_id<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">=</span> utf8 <span class="token keyword">COLLATE</span> <span class="token operator">=</span> utf8_general_ci <span class="token keyword">COMMENT</span> <span class="token operator">=</span> <span class="token string">'AT transaction mode undo table'</span> ROW_FORMAT <span class="token operator">=</span> Compact<span class="token punctuation">;</span>
</code></pre> 
<ol start="2"><li>修改所有微服务的<code>application.yml</code>文件，将事务模式修改为 AT 模式：</li></ol> 
<pre><code class="prism language-yml"><span class="token key atrule">seata</span><span class="token punctuation">:</span>
  <span class="token key atrule">data-source-proxy-mode</span><span class="token punctuation">:</span> AT <span class="token comment"># 开启数据源代理的 AT 模式</span>
</code></pre> 
<p>可以发现，AT 模式是 Seata 的默认模式：<br> <img src="https://images2.imgbox.com/b8/ac/4CZ5SpWY_o.png" alt=""></p> 
<ol start="4"><li>重启微服务并测试</li></ol> 
<p>此时，以断点调试的方式发送下面的请求：<br> <img src="https://images2.imgbox.com/df/b1/ePVKQ2EE_o.png" alt=""><br> 断点设置：</p> 
<p><img src="https://images2.imgbox.com/29/9a/ppLlAAKJ_o.png" alt="">启动调试，可以看到在<code>lock_table</code> 表中为账户表和订单表都创建了全局锁：</p> 
<p><img src="https://images2.imgbox.com/ee/04/McC3AayJ_o.png" alt=""></p> 
<p>并且 <code>undo_log</code>表中也创建了相应的快照：<img src="https://images2.imgbox.com/bc/21/6b9VPZGo_o.png" alt=""></p> 
<p>放行之后，通过查看 <code>account-service</code> 服务的日志：<br> <img src="https://images2.imgbox.com/72/09/vKKQFMvR_o.png" alt=""><br> 发现成功使用快照对数据进行了恢复，并且将<code>lock_table</code> 和 <code>undo_log</code> 表中的数据也进行了删除。</p> 
<h2><a id="TCC__341"></a>三、TCC 模式</h2> 
<h3><a id="31_TCC__343"></a>3.1 TCC 模式原理</h3> 
<p>TCC模式（Try-Confirm-Cancel）与AT模式非常相似，它也是一种分布式事务模式，但不同之处在于TCC模式需要通过人工编码来实现数据恢复。在TCC模式中，需要实现三个方法：Try（尝试）、Confirm（确认）、Cancel（取消）。下面将详细介绍TCC模式的原理和流程。</p> 
<blockquote> 
 <p><strong>TCC模式的三个方法：</strong></p> 
</blockquote> 
<ol><li> <p><strong>Try（尝试）：</strong> 这个方法用于资源的检测和预留。在Try阶段，事务会尝试执行业务逻辑，检查是否有足够的资源来执行操作，并预留资源以确保后续的确认或取消操作可以成功执行。</p> </li><li> <p><strong>Confirm（确认）：</strong> 这个方法用于完成资源操作业务。如果Try成功，那么在确认阶段将完成资源操作的实际业务。确认操作一定要能成功，以确保资源的变化被永久性地提交。</p> </li><li> <p><strong>Cancel（取消）：</strong> 这个方法用于资源的释放和恢复。如果Try成功但后续的确认操作出现问题，那么需要执行取消操作来释放预留的资源并恢复原始状态。</p> </li></ol> 
<blockquote> 
 <p><strong>流程分析：</strong></p> 
</blockquote> 
<p>让我们通过一个简单的例子来说明TCC模式的流程，假设有一个扣减用户余额的业务。账户A的初始余额是100元，需要扣减30元。</p> 
<p><strong>阶段一（Try）：</strong></p> 
<p>在Try阶段，我们需要检查账户余额是否充足，如果充足，就会增加冻结金额并扣除可用余额。初始余额如下：</p> 
<p><img src="https://images2.imgbox.com/a3/c8/I53fe0l6_o.png" alt="初始余额"></p> 
<p>余额充足，可以冻结30元：</p> 
<p><img src="https://images2.imgbox.com/7b/db/sTvZZsoE_o.png" alt="冻结金额增加"></p> 
<p>此时，总金额 = 冻结金额 + 可用金额，数量依然是100元，事务可以直接提交而无需等待其他事务。</p> 
<p><strong>阶段二（Confirm）：</strong></p> 
<p>如果要提交（Confirm），则需要扣减冻结金额30元，确认可以提交。不过之前的可用金额已经扣减过了，这里只需清除冻结金额：</p> 
<p><img src="https://images2.imgbox.com/41/4f/m7Bnc9rh_o.png" alt="冻结金额清除"></p> 
<p>此时，总金额 = 冻结金额 + 可用金额 = 0 + 70 = 70元。</p> 
<p><strong>阶段三（Cancel）：</strong></p> 
<p>如果要回滚（Cancel），则需要扣减冻结金额30元，同时恢复可用余额30元，以释放冻结金额并恢复可用金额：</p> 
<p><img src="https://images2.imgbox.com/6b/9d/WZ01ZEQi_o.png" alt="冻结金额扣减和可用金额增加"></p> 
<p>TCC模式的关键在于实现Try、Confirm和Cancel方法，以确保事务的一致性和可恢复性。如果Try成功但Confirm或Cancel出现问题，需要能够正确处理资源的释放和恢复操作。</p> 
<h3><a id="32_Seata__TCC__388"></a>3.2 Seata 的 TCC 模型</h3> 
<p>Seata中的TCC（Try-Confirm-Cancel）模型延续了之前介绍的事务架构，如下图所示：</p> 
<p><img src="https://images2.imgbox.com/50/a5/GjEMKDYh_o.png" alt="Seata TCC模型"></p> 
<p>TCC模式中，每个阶段的作用如下：</p> 
<ul><li> <p><strong>Try（尝试）：</strong> 这个阶段用于资源检查和预留。事务会尝试执行业务逻辑，检查资源是否足够，并预留资源。</p> </li><li> <p><strong>Confirm（确认）：</strong> 这个阶段用于完成资源操作业务。如果Try成功，Confirm将执行实际的资源操作并提交事务。</p> </li><li> <p><strong>Cancel（取消）：</strong> 这个阶段用于资源释放和恢复。如果Try成功但Confirm出现问题，需要执行Cancel来释放资源并恢复原始状态。</p> </li></ul> 
<p>TCC模式的优点包括：</p> 
<ul><li> <p><strong>一阶段完成直接提交事务，释放数据库资源，性能好：</strong> TCC的Try阶段可以迅速完成，无需等待其他事务，从而释放数据库资源，提高性能。</p> </li><li> <p><strong>相比AT模式，无需生成快照，无需使用全局锁，性能最强：</strong> TCC模式相对于AT模式，减少了对数据库快照的依赖，同时也不需要全局锁，因此具有较高的性能。</p> </li><li> <p><strong>不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库：</strong> TCC模式不要求数据库必须支持XA事务，因此可以用于非事务型数据库。</p> </li></ul> 
<p>TCC模式的缺点包括：</p> 
<ul><li> <p><strong>有代码侵入，需要人为编写Try、Confirm和Cancel接口，较为繁琐：</strong> TCC模式需要开发人员编写特定的Try、Confirm和Cancel方法，这可能增加了开发的复杂性。</p> </li><li> <p><strong>软状态，事务是最终一致：</strong> TCC模式的事务具有软状态，确认和取消操作可能出现问题，需要考虑如何处理失败情况以保证最终一致性。</p> </li></ul> 
<p>总之，TCC模式在性能方面表现出色，但需要开发人员编写更多的代码来处理分布式事务的逻辑。选择TCC模式还应该考虑应用程序的特定需求和数据库的支持情况。</p> 
<h3><a id="33_TCC__419"></a>3.3 TCC 模型事务悬挂和空回滚</h3> 
<p>在TCC（Try-Confirm-Cancel）模型中，存在两个重要问题，即事务悬挂和空回滚，它们涉及到事务的正确执行和终止。</p> 
<blockquote> 
 <ol><li><strong>空回滚：</strong></li></ol> 
</blockquote> 
<p>如下图所示：</p> 
<p><img src="https://images2.imgbox.com/1f/64/IzRjujBV_o.png" alt=""></p> 
<p>当某分支事务的Try阶段被阻塞，可<code>在这里插入代码片</code>能导致全局事务超时，触发二阶段的 Cancel 操作。然而，在执行Cancel操作之前，Try操作尚未执行，这种情况被称为空回滚。这意味着 Cancel 操作在 Try 操作之前执行，导致 Cancel 操作无法正常回滚已经执行的 Try 操作。空回滚是一个问题，因为它会导致事务的状态不正确。</p> 
<p>解决空回滚的方法是在执行 Cancel 操作时，应判断 Try 是否已经执行。如果 Try 尚未执行，那么 Cancel 操作应该记录当前的状态，以等待进行 Try 操作时判断这个操作是否是 Cancel。</p> 
<blockquote> 
 <ol start="2"><li><strong>业务悬挂：</strong></li></ol> 
</blockquote> 
<p>事务悬挂是在发生空回滚后的情况下出现的问题。当某个业务的 Try 操作被阻塞，已经发生了空回滚，然后之前被阻塞的 Try 操作重新启动并继续执行时，这些 Try 操作可能永远无法完成 Confirm 或 Cancel 操作，导致事务一直处于中间状态，这就是事务悬挂。</p> 
<p>解决事务悬挂的方法是在执行 Try 操作时，判断是否已经执行了 Cancel 操作。如果 Cancel 操作已经执行，那么 Try 操作应该被阻止，以避免事务悬挂的问题。</p> 
<h3><a id="34_TCC__444"></a>3.4 TCC 模式的实现</h3> 
<p>TCC（Try-Confirm-Cancel）模式是一种用于实现分布式事务的模式，它通过分解事务操作为三个步骤，分别是Try、Confirm、Cancel，来实现分布式事务的一致性和可靠性。这种模式通常需要解决空回滚和业务悬挂等问题。以下是TCC模式的实现示例：</p> 
<blockquote> 
 <ol><li>数据库表设计</li></ol> 
</blockquote> 
<p>为了解决TCC模式中的空回滚和业务悬挂问题，通常需要使用数据库表来记录事务状态。以下是一个示例数据库表的设计：</p> 
<pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>account_freeze_tbl<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">`</span>xid<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>user_id<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'用户id'</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>freeze_money<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'冻结金额'</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>state<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'事务状态，0:try，1:confirm，2:cancel'</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>xid<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 ROW_FORMAT<span class="token operator">=</span>COMPACT<span class="token punctuation">;</span>
</code></pre> 
<p>这个表的字段含义如下：</p> 
<ul><li><code>xid</code>：全局事务的唯一标识符。</li><li><code>user_id</code>：用户ID，标识参与事务的用户。</li><li><code>freeze_money</code>：记录用户的冻结金额，用于TCC事务。</li><li><code>state</code>：记录事务状态，通常使用0表示Try阶段，1表示Confirm阶段，2表示Cancel阶段。</li></ul> 
<p>通过这张表，可以追踪每个全局事务的状态，从而解决空回滚和业务悬挂问题。</p> 
<blockquote> 
 <ol start="2"><li>声明TCC接口</li></ol> 
</blockquote> 
<p>TCC模式的 Try、Confirm、Cancel 方法都需要在接口中基于注解进行声明。在<code>service</code>包下创建一个接口，并声明 TCC 的三个方法：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@LocalTCC</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AccountTCCService</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@TwoPhaseBusinessAction</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"deduct"</span><span class="token punctuation">,</span> commitMethod <span class="token operator">=</span> <span class="token string">"confirm"</span><span class="token punctuation">,</span> rollbackMethod <span class="token operator">=</span> <span class="token string">"cancel"</span><span class="token punctuation">)</span>
    <span class="token keyword">void</span> <span class="token function">deduct</span><span class="token punctuation">(</span><span class="token annotation punctuation">@BusinessActionContextParameter</span><span class="token punctuation">(</span>paramName <span class="token operator">=</span> <span class="token string">"userId"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> userId<span class="token punctuation">,</span>
                <span class="token annotation punctuation">@BusinessActionContextParameter</span><span class="token punctuation">(</span>paramName <span class="token operator">=</span> <span class="token string">"money"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">boolean</span> <span class="token function">confirm</span><span class="token punctuation">(</span><span class="token class-name">BusinessActionContext</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token class-name">BusinessActionContext</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <ol start="3"><li>编写实现类</li></ol> 
</blockquote> 
<p>然后，在<code>account-service</code>服务的<code>service.impl</code>包下创建一个类，实现 TCC 业务：</p> 
<pre><code class="prism language-java">
<span class="token annotation punctuation">@Service</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AccountTCCServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">AccountTCCService</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">AccountMapper</span> accountMapper<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">AccountFreezeMapper</span> accountFreezeMapper<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token annotation punctuation">@Transactional</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deduct</span><span class="token punctuation">(</span><span class="token class-name">String</span> userId<span class="token punctuation">,</span> <span class="token keyword">int</span> money<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 0. 获取事务id</span>
        <span class="token class-name">String</span> xid <span class="token operator">=</span> <span class="token class-name">RootContext</span><span class="token punctuation">.</span><span class="token function">getXID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 1. 处理业务悬挂，判断 freeze 中是否有冻结记录，如果有，一定是执行过 CANCEL，因此拒绝业务</span>
        <span class="token class-name">AccountFreeze</span> oldFreeze <span class="token operator">=</span> accountFreezeMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span>xid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>oldFreeze <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 执行过 CANCEL，因此拒绝业务</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 2. （由于是 unsigned 类型）直接扣减可用余额</span>
        accountMapper<span class="token punctuation">.</span><span class="token function">deduct</span><span class="token punctuation">(</span>userId<span class="token punctuation">,</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 3. 记录冻结金额，事务状态</span>
        <span class="token class-name">AccountFreeze</span> freeze <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AccountFreeze</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        freeze<span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
        freeze<span class="token punctuation">.</span><span class="token function">setFreezeMoney</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>
        freeze<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token class-name">AccountFreeze<span class="token punctuation">.</span>State</span><span class="token punctuation">.</span><span class="token constant">TRY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        freeze<span class="token punctuation">.</span><span class="token function">setXid</span><span class="token punctuation">(</span>xid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        accountFreezeMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>freeze<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">confirm</span><span class="token punctuation">(</span><span class="token class-name">BusinessActionContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1. 获取事务 id</span>
        <span class="token class-name">String</span> xid <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getXid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2. 根据id删除冻结记录</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> accountFreezeMapper<span class="token punctuation">.</span><span class="token function">deleteById</span><span class="token punctuation">(</span>xid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token class-name">BusinessActionContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 0. 查询冻结记录</span>
        <span class="token class-name">String</span> xid <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getXid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> userId <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getActionContext</span><span class="token punctuation">(</span><span class="token string">"userId"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">AccountFreeze</span> freeze <span class="token operator">=</span> accountFreezeMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span>xid<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 1. 空回滚判断，判断 freeze 是否为 null</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>freeze <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 为 null 则证明 try 没有执行，需要空回滚</span>
            freeze <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AccountFreeze</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            freeze<span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
            freeze<span class="token punctuation">.</span><span class="token function">setFreezeMoney</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            freeze<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token class-name">AccountFreeze<span class="token punctuation">.</span>State</span><span class="token punctuation">.</span><span class="token constant">CANCEL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            freeze<span class="token punctuation">.</span><span class="token function">setXid</span><span class="token punctuation">(</span>xid<span class="token punctuation">)</span><span class="token punctuation">;</span>
            accountFreezeMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>freeze<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 2. 幂等判断</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>freeze<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">AccountFreeze<span class="token punctuation">.</span>State</span><span class="token punctuation">.</span><span class="token constant">CANCEL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 以及处理过一次 CANCEL 操作</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 3. 恢复可用余额</span>
        accountMapper<span class="token punctuation">.</span><span class="token function">refund</span><span class="token punctuation">(</span>freeze<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> freeze<span class="token punctuation">.</span><span class="token function">getFreezeMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 4. 将冻结金额清零，状态改为CANCEL</span>
        freeze<span class="token punctuation">.</span><span class="token function">setFreezeMoney</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        freeze<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token class-name">AccountFreeze<span class="token punctuation">.</span>State</span><span class="token punctuation">.</span><span class="token constant">CANCEL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> accountFreezeMapper<span class="token punctuation">.</span><span class="token function">updateById</span><span class="token punctuation">(</span>freeze<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里，首先声明了TCC的Try、Confirm、Cancel方法，并在实现类中编写了相应的逻辑。在Try方法中，我们扣减可用余额并记录冻结金额和事务状态。在Confirm方法中，我们根据事务ID删除冻结记录。在Cancel方法中，我们恢复可用余额，将冻结金额清零，并将事务状态改为CANCEL。这些操作将确保TCC事务的正常执行，即使出现空回滚或业务悬挂情况也能进行处理。</p> 
<h2><a id="SAGA__576"></a>四、SAGA 模式</h2> 
<h3><a id="41_SAGA__578"></a>4.1 SAGA 模式原理</h3> 
<p>SAGA 模式是一种分布式事务处理模式，旨在解决大规模分布式系统中的事务问题。其原理如下：</p> 
<ol><li> <p><strong>事务分解</strong>：将一个复杂的分布式事务分解为多个小事务，每个小事务可以独立执行。这些小事务可以跨越不同的服务和系统。</p> </li><li> <p><strong>事务状态迁移</strong>：每个小事务有两个关键操作，即<code>compensating</code>（回滚）和<code>confirming</code>（确认）。事务状态可以从一个状态迁移到另一个状态，例如从<code>Started</code>（已开始）到<code>Completed</code>（已完成），或从<code>Started</code>到<code>Compensated</code>（已回滚）。</p> </li><li> <p><strong>协调器</strong>：有一个中央协调器或协调服务来管理整个事务的执行。协调器负责确保事务的状态迁移按正确的顺序发生，以保持事务的一致性。</p> </li><li> <p><strong>异常处理</strong>：如果某个小事务失败，协调器会触发相应的<code>compensating</code>操作来撤销之前已经执行的小事务，以确保事务的一致性。</p> </li><li> <p><strong>事务状态管理</strong>：协调器跟踪和管理每个小事务的状态变化，以确保最终事务能够成功完成或者回滚到一致的状态。</p> </li><li> <p><strong>最终一致性</strong>：SAGA 模式追求最终一致性，即事务可能会暂时处于不一致状态，但最终会达到一致状态。这意味着SAGA模式在处理大规模分布式事务时牺牲了一些一致性，以提高性能和可伸缩性。</p> </li></ol> 
<h3><a id="42_SAGA__594"></a>4.2 SAGA 模式的优缺点</h3> 
<p><strong>优点：</strong></p> 
<ol><li> <p><strong>分布式事务处理</strong>：SAGA 模式是专门用于处理分布式事务的模式，能够有效解决跨多个服务的复杂事务问题。</p> </li><li> <p><strong>高可伸缩性</strong>：由于事务被分解成多个小事务，这些小事务可以并行执行，提高了系统的可伸缩性。</p> </li><li> <p><strong>容错性</strong>：SAGA 模式可以容忍某些小事务失败，通过回滚操作来保持整体事务的一致性。</p> </li><li> <p><strong>降低锁竞争</strong>：与传统的两阶段提交（2PC）相比，SAGA 模式可以减少全局锁的使用，从而降低锁竞争。</p> </li><li> <p><strong>灵活性</strong>：SAGA 模式允许在事务的执行过程中动态调整事务的状态迁移路径，更加灵活适应不同的业务需求。</p> </li></ol> 
<p><strong>缺点：</strong></p> 
<ol><li> <p><strong>复杂性</strong>：SAGA 模式的实现相对复杂，需要编写和维护<code>compensating</code>和<code>confirming</code>操作，以及确保正确的状态迁移。</p> </li><li> <p><strong>最终一致性</strong>：SAGA 模式只追求最终一致性，可能会在事务过程中出现一时的不一致，需要额外的处理来处理这些不一致。</p> </li><li> <p><strong>性能开销</strong>：由于SAGA 模式需要在协调器上执行状态管理和协调操作，可能会引入一些性能开销。</p> </li><li> <p><strong>难以调试</strong>：SAGA 模式中的事务状态管理和回滚操作可能会增加调试的难度，特别是在复杂的分布式环境中。</p> </li></ol> 
<p>总的来说，SAGA 模式适用于需要处理大规模分布式事务的场景，但在实施时需要权衡复杂性、一致性和性能之间的关系。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/beeb67dd8e0bddf09944019b4c5a3d56/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">bat脚本之“一键删除指定的文件夹和文件”</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c22a27abba8347d7c24191657f83153b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ES优化实战 - 小操作节省百分之三十以上的磁盘空间</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>