<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>信号（二）——进程间数据传递sigaction函数（sigaction结构体、siginfo_t 结构体）、sigqueue函数（sigval联合体）、信号的顺序响应问题——linux系统编程 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="信号（二）——进程间数据传递sigaction函数（sigaction结构体、siginfo_t 结构体）、sigqueue函数（sigval联合体）、信号的顺序响应问题——linux系统编程" />
<meta property="og:description" content="文章目录 sigaction信号安装函数sigaction 结构体siginfo_t 结构体 sigqueue信号发送函数sigval联合体 信号的顺序响应问题代码示例 上一篇讲到信号值位于SIGRTMIN和SIGRTMAX之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。Linux在支持新版本的信号安装函数sigation（）以及信号发送函数sigqueue()的同时，仍然支持早期的signal（）信号安装函数，支持信号发送函数kill()。kill&#43;signal与sigqueue&#43;sigaction的主要差别体现在后者可以带值发信号，这样就可以实现进程间是数据通信啦
sigqueue&#43;sigaction sigaction信号安装函数 部分man：
NAME sigaction, rt_sigaction - examine and change a signal action SYNOPSIS #include &lt;signal.h&gt; int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); Feature Test Macro Requirements for glibc (see feature_test_macros(7)): sigaction(): _POSIX_C_SOURCE &gt;= 1 || _XOPEN_SOURCE || _POSIX_SOURCE siginfo_t: _POSIX_C_SOURCE &gt;= 199309L DESCRIPTION The sigaction() system call is used to change the action taken by a process on receipt of a specific signal." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/ae422a2f3dbabe18c65caa00d18a871e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-26T15:58:13+08:00" />
<meta property="article:modified_time" content="2020-07-26T15:58:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">信号（二）——进程间数据传递sigaction函数（sigaction结构体、siginfo_t 结构体）、sigqueue函数（sigval联合体）、信号的顺序响应问题——linux系统编程</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#sigaction_5" rel="nofollow">sigaction信号安装函数</a></li><li><ul><li><a href="#sigaction__107" rel="nofollow">sigaction 结构体</a></li><li><a href="#siginfo_t__167" rel="nofollow">siginfo_t 结构体</a></li></ul> 
   </li><li><a href="#sigqueue_216" rel="nofollow">sigqueue信号发送函数</a></li><li><ul><li><a href="#sigval_267" rel="nofollow">sigval联合体</a></li></ul> 
   </li><li><a href="#_289" rel="nofollow">信号的顺序响应问题</a></li><li><a href="#_296" rel="nofollow">代码示例</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<ul><li>上一篇讲到信号值位于SIGRTMIN和SIGRTMAX之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。</li><li>Linux在支持新版本的信号安装函数sigation（）以及信号发送函数sigqueue()的同时，仍然支持早期的signal（）信号安装函数，支持信号发送函数kill()。</li><li>kill+signal与sigqueue+sigaction的主要差别体现在后者可以带值发信号，这样就可以实现进程间是数据通信啦<br> sigqueue+sigaction</li></ul> 
<h3><a id="sigaction_5"></a>sigaction信号安装函数</h3> 
<p>部分man：</p> 
<pre><code class="prism language-cpp">NAME
       sigaction<span class="token punctuation">,</span> rt_sigaction <span class="token operator">-</span> examine <span class="token operator">and</span> change a signal action

SYNOPSIS
       <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>

       <span class="token keyword">int</span> <span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> sigaction <span class="token operator">*</span>act<span class="token punctuation">,</span>
                     <span class="token keyword">struct</span> sigaction <span class="token operator">*</span>oldact<span class="token punctuation">)</span><span class="token punctuation">;</span>

   Feature Test Macro Requirements <span class="token keyword">for</span> glibc <span class="token punctuation">(</span>see <span class="token function">feature_test_macros</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span>

       <span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> _POSIX_C_SOURCE <span class="token operator">&gt;=</span> <span class="token number">1</span> <span class="token operator">||</span> _XOPEN_SOURCE <span class="token operator">||</span> _POSIX_SOURCE

       siginfo_t<span class="token operator">:</span> _POSIX_C_SOURCE <span class="token operator">&gt;=</span> <span class="token number">199309L</span>

DESCRIPTION
       The <span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> system call is used to change the action taken by a process on receipt of a specific signal<span class="token punctuation">.</span>  <span class="token punctuation">(</span>See <span class="token function">signal</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token keyword">for</span> an overview of signals<span class="token punctuation">.</span><span class="token punctuation">)</span>

       signum specifies the signal <span class="token operator">and</span> can be any valid signal except SIGKILL <span class="token operator">and</span> SIGSTOP<span class="token punctuation">.</span>

       If act is non<span class="token operator">-</span><span class="token constant">NULL</span><span class="token punctuation">,</span> the <span class="token keyword">new</span> action <span class="token keyword">for</span> signal signum is installed from act<span class="token punctuation">.</span>  If oldact is non<span class="token operator">-</span><span class="token constant">NULL</span><span class="token punctuation">,</span> the previous action is saved in oldact<span class="token punctuation">.</span>

       The sigaction structure is defined as something like<span class="token operator">:</span>

           <span class="token keyword">struct</span> sigaction <span class="token punctuation">{<!-- --></span>
               <span class="token keyword">void</span>     <span class="token punctuation">(</span><span class="token operator">*</span>sa_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token keyword">void</span>     <span class="token punctuation">(</span><span class="token operator">*</span>sa_sigaction<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> siginfo_t <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               sigset_t   sa_mask<span class="token punctuation">;</span>
               <span class="token keyword">int</span>        sa_flags<span class="token punctuation">;</span>
               <span class="token keyword">void</span>     <span class="token punctuation">(</span><span class="token operator">*</span>sa_restorer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span><span class="token punctuation">;</span>

       On some architectures a <span class="token keyword">union</span> is involved<span class="token operator">:</span> <span class="token keyword">do</span> <span class="token operator">not</span> assign to both sa_handler <span class="token operator">and</span> sa_sigaction<span class="token punctuation">.</span>

       The  sa_restorer  field  is  <span class="token operator">not</span>  intended <span class="token keyword">for</span> application use<span class="token punctuation">.</span>  <span class="token punctuation">(</span>POSIX does <span class="token operator">not</span> specify a sa_restorer field<span class="token punctuation">.</span><span class="token punctuation">)</span>  Some further details of purpose of <span class="token keyword">this</span> field can be
       found in <span class="token function">sigreturn</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>

       sa_handler specifies the action to be associated with signum <span class="token operator">and</span> may be SIG_DFL <span class="token keyword">for</span> the <span class="token keyword">default</span> action<span class="token punctuation">,</span> SIG_IGN to ignore <span class="token keyword">this</span> signal<span class="token punctuation">,</span> <span class="token operator">or</span> a pointer to a signal han‐
       dling function<span class="token punctuation">.</span>  This function receives the signal number as its only argument<span class="token punctuation">.</span>

       If  SA_SIGINFO  is  specified  in sa_flags<span class="token punctuation">,</span> then sa_sigaction <span class="token punctuation">(</span>instead of sa_handler<span class="token punctuation">)</span> specifies the signal<span class="token operator">-</span>handling function <span class="token keyword">for</span> signum<span class="token punctuation">.</span>  This function receives the
       signal number as its first argument<span class="token punctuation">,</span> a pointer to a siginfo_t as its second argument <span class="token operator">and</span> a pointer to a ucontext_t <span class="token punctuation">(</span>cast to <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> as its  third  argument<span class="token punctuation">.</span>   <span class="token punctuation">(</span>Com‐
       monly<span class="token punctuation">,</span> the handler function doesn't make any use of the third argument<span class="token punctuation">.</span>  See <span class="token function">getcontext</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">for</span> further information about ucontext_t<span class="token punctuation">.</span><span class="token punctuation">)</span>

       sa_mask  specifies  a mask of signals which should be blocked <span class="token punctuation">(</span>i<span class="token punctuation">.</span>e<span class="token punctuation">.</span><span class="token punctuation">,</span> added to the signal mask of the thread in which the signal handler is invoked<span class="token punctuation">)</span> during execution
       of the signal handler<span class="token punctuation">.</span>  In addition<span class="token punctuation">,</span> the signal which triggered the handler will be blocked<span class="token punctuation">,</span> unless the SA_NODEFER flag is used<span class="token punctuation">.</span>
       sa_flags specifies a set of flags which modify the behavior of the signal<span class="token punctuation">.</span>  It is formed by the bitwise OR of zero <span class="token operator">or</span> more of the following<span class="token operator">:</span>

           SA_NOCLDSTOP
                  If signum is SIGCHLD<span class="token punctuation">,</span> <span class="token keyword">do</span> <span class="token operator">not</span> receive notification when child processes stop <span class="token punctuation">(</span>i<span class="token punctuation">.</span>e<span class="token punctuation">.</span><span class="token punctuation">,</span> when they receive one of SIGSTOP<span class="token punctuation">,</span> SIGTSTP<span class="token punctuation">,</span>  SIGTTIN<span class="token punctuation">,</span>  <span class="token operator">or</span>  SIGTTOU<span class="token punctuation">)</span>  <span class="token operator">or</span>
                  resume <span class="token punctuation">(</span>i<span class="token punctuation">.</span>e<span class="token punctuation">.</span><span class="token punctuation">,</span> they receive SIGCONT<span class="token punctuation">)</span> <span class="token punctuation">(</span>see <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>  This flag is meaningful only when establishing a handler <span class="token keyword">for</span> SIGCHLD<span class="token punctuation">.</span>

           SA_NOCLDWAIT <span class="token punctuation">(</span>since Linux <span class="token number">2.6</span><span class="token punctuation">)</span>
                  If signum is SIGCHLD<span class="token punctuation">,</span> <span class="token keyword">do</span> <span class="token operator">not</span> transform children into zombies when they terminate<span class="token punctuation">.</span>  See also <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>  This flag is meaningful only when establishing a
                  handler <span class="token keyword">for</span> SIGCHLD<span class="token punctuation">,</span> <span class="token operator">or</span> when setting that signal's disposition to SIG_DFL<span class="token punctuation">.</span>

                  If the SA_NOCLDWAIT flag is set when establishing a handler <span class="token keyword">for</span> SIGCHLD<span class="token punctuation">,</span> POSIX<span class="token punctuation">.</span><span class="token number">1</span> leaves it unspecified whether a SIGCHLD signal is generated when a child
                  process terminates<span class="token punctuation">.</span>  On Linux<span class="token punctuation">,</span> a SIGCHLD signal is generated in <span class="token keyword">this</span> <span class="token keyword">case</span><span class="token punctuation">;</span> on some other implementations<span class="token punctuation">,</span> it is <span class="token operator">not</span><span class="token punctuation">.</span>

           SA_NODEFER
                  Do  <span class="token operator">not</span>  prevent  the  signal  from  being received from within its own signal handler<span class="token punctuation">.</span>  This flag is meaningful only when establishing a signal handler<span class="token punctuation">.</span>
                  SA_NOMASK is an obsolete<span class="token punctuation">,</span> nonstandard synonym <span class="token keyword">for</span> <span class="token keyword">this</span> flag<span class="token punctuation">.</span>

           SA_ONSTACK
                  Call the signal handler on an alternate signal stack provided by <span class="token function">sigaltstack</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>  If an alternate stack is <span class="token operator">not</span> available<span class="token punctuation">,</span> the <span class="token keyword">default</span> stack will be used<span class="token punctuation">.</span>
                  This flag is meaningful only when establishing a signal handler<span class="token punctuation">.</span>

           SA_RESETHAND
                  Restore  the signal action to the <span class="token keyword">default</span> upon entry to the signal handler<span class="token punctuation">.</span>  This flag is meaningful only when establishing a signal handler<span class="token punctuation">.</span>  SA_ONESHOT
                  is an obsolete<span class="token punctuation">,</span> nonstandard synonym <span class="token keyword">for</span> <span class="token keyword">this</span> flag<span class="token punctuation">.</span>

           SA_RESTART
                  Provide behavior compatible with BSD signal semantics by making certain system calls restartable across signals<span class="token punctuation">.</span>   This  flag  is  meaningful  only  when
                  establishing a signal handler<span class="token punctuation">.</span>  See <span class="token function">signal</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token keyword">for</span> a discussion of system call restarting<span class="token punctuation">.</span>

           SA_RESTORER
                  Not intended <span class="token keyword">for</span> application use<span class="token punctuation">.</span>  This flag is used by C libraries to indicate that the sa_restorer field contains the address of a <span class="token string">"signal trampoline"</span><span class="token punctuation">.</span>
                  See <span class="token function">sigreturn</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">for</span> more details<span class="token punctuation">.</span>

           SA_SIGINFO <span class="token punctuation">(</span>since Linux <span class="token number">2.2</span><span class="token punctuation">)</span>
                  The signal handler takes three arguments<span class="token punctuation">,</span> <span class="token operator">not</span> one<span class="token punctuation">.</span>  In <span class="token keyword">this</span> <span class="token keyword">case</span><span class="token punctuation">,</span> sa_sigaction should be set instead of sa_handler<span class="token punctuation">.</span>  This flag is  meaningful  only  when
                  establishing a signal handler<span class="token punctuation">.</span>

</code></pre> 
<p>简单总结：</p> 
<ul><li>包含头文件&lt;signal.h&gt;</li><li>功能:sigaction函数用于改变进程接收到特定信号后的行为。</li><li>原型： int sigaction(int signum,const struct sigaction *act,const struct sigaction *old);</li></ul> 
<p>参数 ：</p> 
<ul><li> <p>该函数的第一个参数为信号的值，可以为<strong>除sigkill及sigstop外的任何一 个特定有效的信号</strong>（为这两个信号定义自己的处理函数，将导致信号安装错误）</p> </li><li> <p>第二个参数是指向结构sigaction的一个实例的<strong>指针</strong>，在结构 sigaction的实例中，指定了对特定信号的处理，可以为空，进程会以缺省方式对信号处理</p> </li><li> <p>第三个参数oldact指向的对象用来保存原来对相应信号的处理，可以传入结构sigaction的指针来获取之前对信号处理情况，如果不需要保存可指定oldact为null。</p> </li><li> <p>如果把第二、第三个参数都设为NULL，那么该函数可用于检查信号的有效性。</p> </li><li> <p><strong>第二个参数最为重要，其中包含了对指定信号的处理、信号所传递的信息、信号处理函数执行过程中应屏蔽掉哪些函数等等。</strong></p> </li><li> <p>返回值:函数成功返回0，失败返回-1</p> </li></ul> 
<h4><a id="sigaction__107"></a>sigaction 结构体</h4> 
<p>在sigaction函数的第二个第三个参数，为指向sigaction这个结构体类型的指针</p> 
<pre><code class="prism language-cpp">   <span class="token keyword">struct</span> sigaction <span class="token punctuation">{<!-- --></span>
       <span class="token keyword">void</span>     <span class="token punctuation">(</span><span class="token operator">*</span>sa_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">void</span>     <span class="token punctuation">(</span><span class="token operator">*</span>sa_sigaction<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> siginfo_t <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       sigset_t   sa_mask<span class="token punctuation">;</span>
       <span class="token keyword">int</span>        sa_flags<span class="token punctuation">;</span>
       <span class="token keyword">void</span>     <span class="token punctuation">(</span><span class="token operator">*</span>sa_restorer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>1. sa_handler指定信号关联函数</strong></p> 
<p>sa_handler指定信号关联函数，赋值为一个函数指针（函数名）即用户指定的信号处理函数。除此之外，还可以赋值为常数SIG_IGN表示忽略信号，赋值为常数SIG_DFL表示执行系统默认动作(采用缺省的处理方式)。<br> 赋值为一个函数指针表示用自定义函数捕捉信号，或者说向内核注册了一个信号处理函数，该函数返回值为void，可以带一个int参数，通过参数可以得知当前信号的编号，这样就可以用同一个函数处理多种信号。显然，这也是一个回调函数，不是被main函数调用，而是被系统所调用。</p> 
<p><strong>2. sa_sigaction指定信号关联函数</strong></p> 
<p>和sa_handler的差别在于：</p> 
<p>由sa_handler指定的处理函数只有一个参数，即信号值，所以信号不能传递除信号值之外的任何信息；<br> （例如上一篇的void signal_fun(int num)）</p> 
<p>由_sa_sigaction是指定的信号处理函数带有三个参数，是为实时信号而设的（当然同样支持非实时信号），它指定一个3参数信号处理函数。第一个参数为信号值，第二个参数是指向siginfo_t结构的指针，结构中包含信号携带的数据值，第三个参数没有使用（posix没有规范使用该参数的标准）<br> 例如void signal_handle_new(int num,siginfo_t *info,void *d)</p> 
<p>sa_handler主要用于不可靠信号（实时信号当然也可以，只是不能带信息），sa_sigaction用于实时信号可以带信息(siginfo_t)，两者不能同时出现。</p> 
<p><strong>3. sa_mask存放需要手动屏蔽的信号</strong></p> 
<p>sa_mask指定在信号处理程序执行过程中，哪些信号应当被阻塞。缺省情况下当前信号本身被阻塞，防止信号的嵌套发送，除非指定SA_NODEFER或者SA_NOMASK标志位，处理程序执行完后，被阻塞的信号开始执行。</p> 
<p>注：请注意sa_mask指定的信号阻塞的前提条件，是在由sigaction（）安装信号的处理函数执行过程中由sa_mask指定的信号才被阻塞。<br> （屏蔽相关内容将在下一篇中带来）</p> 
<p><strong>4.sa_flags指定一组修改信号行为的标志</strong><br> flag在man文档中有详细列出，常用的有：<br> <strong>SA_SIGINFO：</strong><br> 当sig_act.sa_flags = SA_SIGINFO;<br> 时需要指定sa_sigaction。a_sigaction函数的第一个参数与sa_handler一样表示当前信号的编号，第二个参数是一个siginfo_t 结构体，第三个参数一般不用。当使用sa_handler时sa_flags设置为0即可。</p> 
<blockquote> 
 <p>If SA_SIGINFO is specified in sa_flags, then sa_sigaction (instead of sa_handler) specifies the signal-handling function for signum.<br> This function receives the signal number as its first argument, a pointer to a siginfo_t as its second argument and a pointer to a ucontext_t (cast to void *)as its third argument. (Commonly, the handler function doesn’t make any use of the third argument. See getcontext(3) for further information aboutucontext_t.)<br> ……<br> SA_SIGINFO (since Linux 2.2)<br> The signal handler takes three arguments, not one. In this case, sa_sigaction should be set instead of sa_handler. This flag is meaningful only when establishing a signal handler.<br> 注：很多文献在阐述该标志位时都认为，如果设置了该标志位，就必须定义三参数信号处理函数。实际不是这样的，验证方法很简单：自己实现一个单一参数信号处理函数，并在程序中设置该标志位，可以察看程序的运行结果。实际上，可以把该标志位看成信号是否传递参数的开关，如果设置该位，则传递参数；否则，不传递参数。</p> 
</blockquote> 
<p><strong>SA_NODEFER：</strong><br> 当SA_NODEFER设置时在信号处理函数执行期间不会屏蔽当前信号；</p> 
<blockquote> 
 <p>SA_NODEFER<br> Do not prevent the signal from being received from within its own signal handler. This flag is meaningful only when establishing a signal handler.<br> SA_NOMASK is an obsolete, nonstandard synonym for this flag.</p> 
</blockquote> 
<p><strong>5.sa_restorer</strong><br> 已过时，POSIX不支持它，不应再被使用。</p> 
<h4><a id="siginfo_t__167"></a>siginfo_t 结构体</h4> 
<p>在man sigaction 中对siginfo_t 结构体也作了说明</p> 
<pre><code class="prism language-cpp">The siginfo_t argument to sa_sigaction is a <span class="token keyword">struct</span> with the following fields<span class="token operator">:</span>

           siginfo_t <span class="token punctuation">{<!-- --></span>
               <span class="token keyword">int</span>      si_signo<span class="token punctuation">;</span>     <span class="token comment">/* Signal number 信号编号 */</span>
               <span class="token keyword">int</span>      si_errno<span class="token punctuation">;</span>     <span class="token comment">/* An errno value 如果为非零值则错误代码与之关联 */</span>
               <span class="token keyword">int</span>      si_code<span class="token punctuation">;</span>      <span class="token comment">/* Signal code 说明进程如何接收信号以及从何处收到*/</span>
               <span class="token keyword">int</span>      si_trapno<span class="token punctuation">;</span>    <span class="token comment">/* Trap number that caused
                                         hardware-generated signal
                                         (unused on most architectures) */</span>
               pid_t    si_pid<span class="token punctuation">;</span>       <span class="token comment">/* Sending process ID适用于SIGCHLD，代表被终止进程的PID  */</span>
               uid_t    si_uid<span class="token punctuation">;</span>       <span class="token comment">/* Real user ID of sending process适用于SIGCHLD,代表被终止进程所拥有进程的UID  */</span>
               <span class="token keyword">int</span>      si_status<span class="token punctuation">;</span>    <span class="token comment">/* Exit value or signal 适用于SIGCHLD，代表被终止进程的状态 */</span>
               clock_t  si_utime<span class="token punctuation">;</span>     <span class="token comment">/* User time consumed 适用于SIGCHLD，代表被终止进程所消耗的用户时间 */</span>
               clock_t  si_stime<span class="token punctuation">;</span>     <span class="token comment">/* System time consumed 适用于SIGCHLD，代表被终止进程所消耗系统的时间 */</span>
               <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
               sigval_t si_value<span class="token punctuation">;</span>     <span class="token comment">/* Signal value */</span>
               <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
               <span class="token keyword">int</span>      si_int<span class="token punctuation">;</span>       <span class="token comment">/* POSIX.1b signal */</span>
               <span class="token keyword">void</span>    <span class="token operator">*</span>si_ptr<span class="token punctuation">;</span>       <span class="token comment">/* POSIX.1b signal */</span>
               <span class="token keyword">int</span>      si_overrun<span class="token punctuation">;</span>   <span class="token comment">/* Timer overrun count;
                                         POSIX.1b timers */</span>
               <span class="token keyword">int</span>      si_timerid<span class="token punctuation">;</span>   <span class="token comment">/* Timer ID; POSIX.1b timers */</span>
               <span class="token keyword">void</span>    <span class="token operator">*</span>si_addr<span class="token punctuation">;</span>      <span class="token comment">/* Memory location which caused fault */</span>
               <span class="token keyword">long</span>     si_band<span class="token punctuation">;</span>      <span class="token comment">/* Band event (was int in
                                         glibc 2.3.2 and earlier) */</span>
               <span class="token keyword">int</span>      si_fd<span class="token punctuation">;</span>        <span class="token comment">/* File descriptor */</span>
               <span class="token keyword">short</span>    si_addr_lsb<span class="token punctuation">;</span>  <span class="token comment">/* Least significant bit of address
                                         (since Linux 2.6.32) */</span>
               <span class="token keyword">void</span>    <span class="token operator">*</span>si_call_addr<span class="token punctuation">;</span> <span class="token comment">/* Address of system call instruction
                                         (since Linux 3.5) */</span>
               <span class="token keyword">int</span>      si_syscall<span class="token punctuation">;</span>   <span class="token comment">/* Number of attempted system call
                                         (since Linux 3.5) */</span>
               <span class="token keyword">unsigned</span> <span class="token keyword">int</span> si_arch<span class="token punctuation">;</span>  <span class="token comment">/* Architecture of attempted system call
                                         (since Linux 3.5) */</span>
           <span class="token punctuation">}</span>
</code></pre> 
<p>请留意两个用于传输数据的变量：<br> sigval_t si_value; /* Signal value <em>/<br> int si_int; /</em> POSIX.1b signal */<br> 实际上：</p> 
<ul><li><mark>siginfo_t 结构体中(sigval_t) si_value就是sigqueue函数中传入的第三个参数sigval</mark></li><li><mark>siginfo_t 结构体中(int) si_int就是从sigqueue函数中传入的第三个参数sigval.sival_int中获得</mark></li><li><mark>siginfo_t 结构体中si_ptr就是从sigqueue函数中传入的第三个参数sigval.sival_ptr中获得</mark><br> 所以可以通过sigqueue种对sigval值的传入来实现信号带值，在信号处理函数中<code>void signal_handle_new(int num,siginfo_t *info,void *d)</code>读取第二个参数中对应变量的值来获取信号所带参数，通过这种方法实现进程间通讯<br> （下面会详细介绍sigqueue和sigval）</li></ul> 
<h3><a id="sigqueue_216"></a>sigqueue信号发送函数</h3> 
<p>man：</p> 
<pre><code class="prism language-cpp">NAME
       sigqueue <span class="token operator">-</span> queue a signal <span class="token operator">and</span> data to a process

SYNOPSIS
       <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
       <span class="token keyword">int</span> <span class="token function">sigqueue</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">union</span> sigval value<span class="token punctuation">)</span><span class="token punctuation">;</span>
   Feature Test Macro Requirements <span class="token keyword">for</span> glibc <span class="token punctuation">(</span>see <span class="token function">feature_test_macros</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span>
       <span class="token function">sigqueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> _POSIX_C_SOURCE <span class="token operator">&gt;=</span> <span class="token number">199309L</span>

DESCRIPTION
       <span class="token function">sigqueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  sends  the signal specified in sig to the process whose PID is given in pid<span class="token punctuation">.</span>  The permissions required to send a signal are the same as <span class="token keyword">for</span> <span class="token function">kill</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>  As
       with <span class="token function">kill</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> the null signal <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> can be used to check <span class="token keyword">if</span> a process with a given PID exists<span class="token punctuation">.</span>

       The value argument is used to specify an accompanying item of data <span class="token punctuation">(</span>either an integer <span class="token operator">or</span> a pointer value<span class="token punctuation">)</span> to be sent with the signal<span class="token punctuation">,</span> <span class="token operator">and</span> has the following type<span class="token operator">:</span>

           <span class="token keyword">union</span> sigval <span class="token punctuation">{<!-- --></span>
               <span class="token keyword">int</span>   sival_int<span class="token punctuation">;</span>
               <span class="token keyword">void</span> <span class="token operator">*</span>sival_ptr<span class="token punctuation">;</span>
           <span class="token punctuation">}</span><span class="token punctuation">;</span>

       If the receiving process has installed a handler <span class="token keyword">for</span> <span class="token keyword">this</span> signal <span class="token keyword">using</span> the SA_SIGINFO flag to <span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> then it can obtain <span class="token keyword">this</span> data via the si_value  field  of
       the siginfo_t structure passed as the second argument to the handler<span class="token punctuation">.</span>  Furthermore<span class="token punctuation">,</span> the si_code field of that structure will be set to SI_QUEUE<span class="token punctuation">.</span>

RETURN VALUE
       On  success<span class="token punctuation">,</span> <span class="token function">sigqueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> returns <span class="token number">0</span><span class="token punctuation">,</span> indicating that the signal was successfully queued to the receiving process<span class="token punctuation">.</span>  Otherwise<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> is returned <span class="token operator">and</span> errno is set to indi‐
       cate the error<span class="token punctuation">.</span>

ERRORS
       EAGAIN The limit of signals which may be queued has been reached<span class="token punctuation">.</span>  <span class="token punctuation">(</span>See <span class="token function">signal</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token keyword">for</span> further information<span class="token punctuation">.</span><span class="token punctuation">)</span>
       EINVAL sig was invalid<span class="token punctuation">.</span>
       EPERM  The process does <span class="token operator">not</span> have permission to send the signal to the receiving process<span class="token punctuation">.</span>  For the required permissions<span class="token punctuation">,</span> see <span class="token function">kill</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
       ESRCH  No process has a PID matching pid<span class="token punctuation">.</span>

</code></pre> 
<ul><li>功能:新的发送信号系统调用,主要是针对实时信号提出的支持信号带有参数,与函数sigaction()配合使用。</li><li>原型: int sigqueue(pid_t pid, int sig, const union sigval value);</li></ul> 
<p>参数：</p> 
<ul><li>第一个参数是指定接收信号的进程id，</li><li>第二个参数确定即将发送的信号，</li><li>第三个参数是一个联合数据结构union sigval，指定了信号传递的参数，即通常所说的4字节值。</li></ul> 
<p>sigqueue()比kill()传递了更多的附加信息，但sigqueue()只能向一个进程发送信号，而不能发送信号给一个进程组。</p> 
<ul><li>返回值成功返回0,失败返回-1</li></ul> 
<p>同样可以使用传送sig=0的方式，检查指定pid进程是否存在</p> 
<h4><a id="sigval_267"></a>sigval联合体</h4> 
<pre><code class="prism language-cpp">      The value argument is used to specify an accompanying item of data <span class="token punctuation">(</span>either an integer <span class="token operator">or</span> a pointer value<span class="token punctuation">)</span> to be sent with the signal<span class="token punctuation">,</span> <span class="token operator">and</span> has the following type<span class="token operator">:</span>

           <span class="token keyword">union</span> sigval <span class="token punctuation">{<!-- --></span>
               <span class="token keyword">int</span>   sival_int<span class="token punctuation">;</span>
               <span class="token keyword">void</span> <span class="token operator">*</span>sival_ptr<span class="token punctuation">;</span>
           <span class="token punctuation">}</span><span class="token punctuation">;</span>

       If the receiving process has installed a handler <span class="token keyword">for</span> <span class="token keyword">this</span> signal <span class="token keyword">using</span> the SA_SIGINFO flag to <span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> then it can obtain <span class="token keyword">this</span> data via the si_value  field  of
       the siginfo_t structure passed as the second argument to the handler<span class="token punctuation">.</span>  Furthermore<span class="token punctuation">,</span> the si_code field of that structure will be set to SI_QUEUE<span class="token punctuation">.</span>

</code></pre> 
<ul><li>采用联合数据结构，说明siginfo_t结构中si_value要么持有一个4字节的整数值，要么持有一个指针，这就构成了与信号相关的数据。</li><li>sigqueue的第三个参数就是sigval联合数据结构，当调用sigqueue时，该<strong>数据结构中的数据就将拷贝到信号处理函数的第二个参数中</strong>。</li><li>在信号的处理函数中，包含这样的信号相关数据指针，但没有规定具体如何对这些数据进行操作，操作方法应该由程序开发人员根据具体任务事先约定。</li><li>这样，在发送信号同时，就可以让信号传递一些附加信息。信号可以传递信息对程序开发是非常有意义的。</li></ul> 
<p>实际开发中我们将要通过信号传输的值赋值入sigval，即可在siginfo_t 中获得到</p> 
<h3><a id="_289"></a>信号的顺序响应问题</h3> 
<p>linux系统是无法预知信号接收的时机的，那么就有可能出现这样的情况：<br> linux在执行一个信号对应的自定义信号处理函数的时候，接收到了一个新的信号，那应该怎么处理呢？<br> 分为两种情况：</p> 
<ul><li>如果linux执行一个信号处理函数的时候如果又收到<mark>一个不同种信号</mark>，会<strong>去执行新的信号处理函数</strong>，执行完之后再回来执行。</li><li>如果linux执行一个信号处理函数的时候如果又收到又收到一个<mark>同种信号</mark>，则<strong>不会打断，是排队顺序执行的</strong>。<br> 这有一点像嵌套中断，但不同信号间没有优先级</li></ul> 
<h3><a id="_296"></a>代码示例</h3> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span><span class="token comment">//unix stand lib</span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;sys/fcntl.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;dirent.h&gt;</span></span><span class="token comment">//file dir</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span><span class="token comment">//wait func</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token comment">//ststem</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>


<span class="token comment">//新的信号处理函数多了两个参数，其中signfo_t里面携带了我们想要的数据</span>
<span class="token keyword">void</span> <span class="token function">signal_handle_new</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> siginfo_t <span class="token operator">*</span>info<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"get value="</span> <span class="token operator">&lt;&lt;</span> info<span class="token operator">-</span><span class="token operator">&gt;</span>si_int <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//安装信号先于发送信号</span>
	<span class="token keyword">struct</span> sigaction sig_act<span class="token punctuation">;</span><span class="token comment">//新建信号安装结构体</span>
	sig_act<span class="token punctuation">.</span>sa_sigaction <span class="token operator">=</span> signal_handle_new<span class="token punctuation">;</span><span class="token comment">//指定信号关联函数</span>
	sig_act<span class="token punctuation">.</span>sa_flags <span class="token operator">=</span> SA_SIGINFO<span class="token punctuation">;</span><span class="token comment">//声明信号是携带数据的</span>
	<span class="token comment">//将信号和安装信号结构体关联</span>
	<span class="token function">sigaction</span><span class="token punctuation">(</span>SIGUSR1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sig_act<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//信号num，新信号结构体指针，旧信号结构体指针</span>


	pid_t pid<span class="token punctuation">;</span>
	pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//为了降低CPU使用率</span>
		<span class="token punctuation">}</span>	
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//保证子进程先走</span>
		sigval value<span class="token punctuation">;</span><span class="token comment">//新建携带数据联合体value</span>
		value<span class="token punctuation">.</span>sival_int <span class="token operator">=</span> <span class="token number">1999</span><span class="token punctuation">;</span>

		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"send signal"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">sigqueue</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> SIGUSR1<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//携带value值发送信号SIGUSR1给进程号为pid的进程</span>
	<span class="token punctuation">}</span>	
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>解释详见代码中注释，运行结果如下：<br> <img src="https://images2.imgbox.com/eb/91/a5SaTDg3_o.png" alt="在这里插入图片描述"><br> 证明信号处理函数获取到了信号发送携带的int值，接收成功</p> 
<p>我们进一步定义两套信号和对应的信号处理函数，实验信号的顺序响应问题，即排队响应和打断响应问题<br> 同种信号在信号处理函数执行时输入：</p> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span><span class="token comment">//wait func</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token comment">//ststem</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>


<span class="token comment">//新的信号处理函数多了两个参数，其中signfo_t里面携带了我们想要的数据</span>
<span class="token keyword">void</span> <span class="token function">signal_handle_new</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> siginfo_t <span class="token operator">*</span>info<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"signal_handle_new is running"</span> <span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">signal_handle_new2</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> siginfo_t <span class="token operator">*</span>info<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>d<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"signal_handle_new2 is running"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//安装信号</span>
	<span class="token keyword">struct</span> sigaction sig_act<span class="token punctuation">,</span> sig_act2<span class="token punctuation">;</span><span class="token comment">//新建信号安装结构体</span>
	sig_act<span class="token punctuation">.</span>sa_sigaction <span class="token operator">=</span> signal_handle_new<span class="token punctuation">;</span><span class="token comment">//指定信号关联函数</span>
	sig_act2<span class="token punctuation">.</span>sa_sigaction <span class="token operator">=</span> signal_handle_new2<span class="token punctuation">;</span><span class="token comment">//指定信号关联函数</span>
	<span class="token comment">//将信号和安装信号结构体关联</span>
	<span class="token function">sigaction</span><span class="token punctuation">(</span>SIGUSR1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sig_act<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//信号num，新信号结构体指针，旧信号结构体指针</span>
	<span class="token function">sigaction</span><span class="token punctuation">(</span>SIGUSR2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sig_act2<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//信号num，新信号结构体指针，旧信号结构体指针</span>
	
	
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"process run..."</span> <span class="token operator">&lt;&lt;</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/cd/55/HkVVQRlG_o.png" alt="在这里插入图片描述"><br> 从打印数字顺序可以看出，如果linux执行一个信号处理函数的时候如果又收到又收到一个<mark>同种信号</mark>，则<strong>不会打断，是排队顺序执行的</strong>。</p> 
<p>同样的代码，接下来测试不同种信号在信号处理函数执行时输入：<br> <img src="https://images2.imgbox.com/ee/6c/lsq69m2j_o.png" alt="在这里插入图片描述"><br> 可以验证上面的结论：如果linux执行一个信号处理函数的时候如果又收到<mark>一个不同种信号</mark>，会<strong>去执行新的信号处理函数</strong>，执行完之后再回来执行。</p> 
<p>另外需注意：</p> 
<ul><li>如果发送了信号但是没有安装对应接收信号，这是子进程会结束掉，即变成僵尸进程</li></ul> 
<p>结构体部分内容参考：<br> <a href="https://www.cnblogs.com/mickole/p/3191804.html" rel="nofollow">https://www.cnblogs.com/mickole/p/3191804.html</a><br> <a href="https://blog.csdn.net/jnu_simba/article/details/8947410">https://blog.csdn.net/jnu_simba/article/details/8947410</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/af61694ec1cd6ff03ce917650f29da73/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">“running install error: can‘t create or remove files in install directory  The following error occu”</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8709b6ebb97536b0b547bdd34af5b469/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">交叉熵损失函数整理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>