<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java Web 开发详解 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java Web 开发详解" />
<meta property="og:description" content="一、Web基础 1、Web 概述 Web 在英文中的含义是网状物、网络。在计算机领域，它通常指的是后者，即网络。
像 WWW 是由 3 个单词组成的，即World Wide Web，中文含义是万维网。
他们的出现都是为了让我们在网络的世界中获取资源，这些资源的存放之处，我们称之为网站。我们通过输入网站的地址（即网址），就可以访问网站中提供的资源。
在网上我们能访问到的内容全是资源（不区分局域网还是广域网）。只不过，不同类型的资源展示的效果不一样。资源可以分为静态资源和动态资源：
静态资源指的是，网站中提供给人们展示的资源是一成不变的，也就是说不同人或者在不同时间，看到的内容都是一样的。例如：我们看到的新闻，网站的使用手册，网站功能说明文档等等。而作为开发者，我们编写的 html、css、js、图片、多媒体等，都可以称为静态资源。
动态资源指的是，网站中提供给人们展示的资源是由程序产生的，在不同的时间或者用不同的人员由于身份的不同，所看到的内容是不一样的。例如：我们在12306上购买火车票，火车票的余票数由于时间的变化，会逐渐的减少，直到最后没有余票。还有，我们在 CSDN 上下载资料，只有登录成功后，且积分足够时才能下载。否则就不能下载，这就是访客身份和会员身份的区别。作为开发人员，我们编写的 JSP、servlet、php、ASP 等都是动态资源。
关于广域网和局域网的划分，广域网指的就是万维网，也就是我们说的互联网；局域网是指的是在一定范围之内可以访问的网络，出了这个范围，就不能再使用的网络。
2、系统结构 根据基础结构划分：C/S 结构，B/S 结构两类。根据技术选型划分：Model1 模型，Model2 模型，MVC 模型、三层架构 &#43; MVC 模型。根据部署方式划分：一体化架构，垂直拆分架构，分布式架构，流动计算架构，微服务架构。 1. C/S 结构
它指的是客户端——服务器的方式，其中 C 代表着 Client，S 代表着服务器。
C/S 结构的系统设计图如下：
2. B/S 结构
它指的是浏览器——服务器的方式，其中 B 代表着 Browser，S 代表着服务器。
B/S 结构的系统设计图如下：
3. 两种结构的区别及优略
两种结构的区别：
硬件环境不同：C/S 通常是建立在专用的网络或小范围的网络环境上（即局域网），且必须要安装客户端；而 B/S 是建立在广域网上的，适应范围强，通常有操作系统和浏览器就行。
C/S 结构比 B/S 结构更安全，因为用户群相对固定，对信息的保护更强。
B/S 结构维护升级比较简单，而 C/S 结构维护升级相对困难。
优势：
C/S：是能充分发挥客户端PC的处理能力，很多工作可以在客户端处理后再提交给服务器。对应的优点就是客户端响应速度快。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2afa027582c66e42a28b42c99e8c76e0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-28T11:09:32+08:00" />
<meta property="article:modified_time" content="2022-10-28T11:09:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java Web 开发详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、Web基础</h3> 
<h4>1、Web 概述</h4> 
<p>Web 在英文中的含义是网状物、网络。在计算机领域，它通常指的是后者，即网络。</p> 
<p>像 <strong>WWW</strong> 是由 3 个单词组成的，即World Wide Web，中文含义是万维网。</p> 
<p>他们的出现都是为了让我们在网络的世界中获取资源，这些资源的存放之处，我们称之为网站。我们通过输入网站的地址（即网址），就可以访问网站中提供的资源。</p> 
<p>在网上我们能访问到的内容全是资源（不区分局域网还是广域网）。只不过，不同类型的资源展示的效果不一样。资源可以分为静态资源和动态资源：</p> 
<ul><li> <p><code>静态资源</code>指的是，网站中提供给人们展示的资源是一成不变的，也就是说不同人或者在不同时间，看到的内容都是一样的。例如：我们看到的新闻，网站的使用手册，网站功能说明文档等等。而作为开发者，我们编写的 html、css、js、图片、多媒体等，都可以称为静态资源。</p> </li><li> <p><code>动态资源</code>指的是，网站中提供给人们展示的资源是由程序产生的，在不同的时间或者用不同的人员由于身份的不同，所看到的内容是不一样的。例如：我们在12306上购买火车票，火车票的余票数由于时间的变化，会逐渐的减少，直到最后没有余票。还有，我们在 CSDN 上下载资料，只有登录成功后，且积分足够时才能下载。否则就不能下载，这就是访客身份和会员身份的区别。作为开发人员，我们编写的 JSP、servlet、php、ASP 等都是动态资源。</p> </li></ul> 
<p>关于广域网和局域网的划分，广域网指的就是万维网，也就是我们说的互联网；局域网是指的是在一定范围之内可以访问的网络，出了这个范围，就不能再使用的网络。</p> 
<h4>2、系统结构</h4> 
<ul><li>根据基础结构划分：C/S 结构，B/S 结构两类。</li><li>根据技术选型划分：Model1 模型，Model2 模型，MVC 模型、三层架构 + MVC 模型。</li><li>根据部署方式划分：一体化架构，垂直拆分架构，分布式架构，流动计算架构，微服务架构。</li></ul> 
<p id="cs-结构"><strong>1. C/S 结构</strong></p> 
<p>它指的是<code>客户端——服务器</code>的方式，其中 C 代表着 Client，S 代表着服务器。</p> 
<p>C/S 结构的系统设计图如下：</p> 
<p><img alt="" height="796" src="https://images2.imgbox.com/7e/73/RWibMAwj_o.png" width="963"></p> 
<p><strong>2. B/S 结构</strong></p> 
<p>它指的是<code>浏览器——服务器</code>的方式，其中 B 代表着 Browser，S 代表着服务器。</p> 
<p>B/S 结构的系统设计图如下：</p> 
<p><img alt="" height="754" src="https://images2.imgbox.com/04/d6/L4X2szDL_o.png" width="1013"></p> 
<p><strong>3. 两种结构的区别及优略</strong></p> 
<p>两种结构的区别：</p> 
<ol><li> <p>硬件环境不同：C/S 通常是建立在专用的网络或小范围的网络环境上（即局域网），且必须要安装客户端；而 B/S 是建立在广域网上的，适应范围强，通常有操作系统和浏览器就行。</p> </li><li> <p>C/S 结构比 B/S 结构更安全，因为用户群相对固定，对信息的保护更强。</p> </li><li> <p>B/S 结构维护升级比较简单，而 C/S 结构维护升级相对困难。</p> </li></ol> 
<p>优势：</p> 
<ol><li> <p>C/S：是能充分发挥客户端PC的处理能力，很多工作可以在客户端处理后再提交给服务器。对应的优点就是客户端响应速度快。</p> </li><li> <p>B/S：总体拥有成本低、维护方便、分布性强、开发简单，可以不用安装任何专门的软件就能 实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能使用。</p> </li></ol> 
<h4>3、HTTP协议</h4> 
<p><strong>1. HTTP协议简介</strong></p> 
<p>在Web应用中，浏览器请求一个URL，服务器就把生成的HTML网页发送给浏览器，而浏览器和服务器之间的传输协议是HTTP，所以：</p> 
<ul><li> <p>HTML是一种用来定义网页的文本，会HTML，就可以编写网页；</p> </li><li> <p>HTTP是在网络上传输HTML的协议，用于浏览器和服务器的通信。</p> </li></ul> 
<p>HTTP协议是一个基于TCP协议之上的请求-响应协议，它非常简单，我们先使用Chrome浏览器查看新浪首页，然后选择View - Developer - Inspect Elements就可以看到HTML：</p> 
<p><img alt="" height="637" src="https://images2.imgbox.com/7b/18/pEftUa2t_o.png" width="647"></p> 
<p>切换到Network，重新加载页面，可以看到浏览器发出的每一个请求和响应： </p> 
<p><img alt="" height="642" src="https://images2.imgbox.com/b4/a2/bv1KfG6F_o.png" width="651"></p> 
<p>使用Chrome浏览器可以方便地调试Web应用程序。</p> 
<p>对于Browser来说，请求页面的流程如下：</p> 
<ol><li>与服务器建立TCP连接；</li><li>发送HTTP请求；</li><li>收取HTTP响应，然后把网页在浏览器中显示出来。</li></ol> 
<p>浏览器发送的HTTP请求如下：</p> 
<pre><code>GET / HTTP/1.1
Host: www.sina.com.cn
User-Agent: Mozilla/5.0 xxx
Accept: */*
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8</code></pre> 
<p>其中，第一行表示使用GET请求获取路径为/的资源，并使用HTTP/1.1协议，从第二行开始，每行都是以Header: Value形式表示的HTTP头，比较常用的HTTP Header包括：</p> 
<ul><li>Host: 表示请求的主机名，因为一个服务器上可能运行着多个网站，因此，Host表示浏览器正在请求的域名；</li><li>User-Agent: 标识客户端本身，例如Chrome浏览器的标识类似<code>Mozilla/5.0 ... Chrome/79</code>，IE浏览器的标识类似<code>Mozilla/5.0 (Windows NT ...) like Gecko</code>；</li><li>Accept：表示浏览器能接收的资源类型，如<code>text/*</code>，<code>image/*</code>或者<code>*/*</code>表示所有；</li><li>Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；</li><li>Accept-Encoding：表示浏览器可以支持的压缩类型，例如<code>gzip, deflate, br</code>。</li></ul> 
<p>服务器的响应如下：</p> 
<pre><code>HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 21932
Content-Encoding: gzip
Cache-Control: max-age=300

&lt;html&gt;...网页数据...</code></pre> 
<p>服务器响应的第一行总是版本号+空格+数字+空格+文本，数字表示响应代码，其中2xx表示成功，3xx表示重定向，4xx表示客户端引发的错误，5xx表示服务器端引发的错误。数字是给程序识别，文本则是给开发者调试使用的。</p> 
<p>常见的响应代码有：</p> 
<ul><li>200 OK：表示成功；</li><li>301 Moved Permanently：表示该URL已经永久重定向；</li><li>302 Found：表示该URL需要临时重定向；</li><li>304 Not Modified：表示该资源没有修改，客户端可以使用本地缓存的版本；</li><li>400 Bad Request：表示客户端发送了一个错误的请求，例如参数无效；</li><li>401 Unauthorized：表示客户端因为身份未验证而不允许访问该URL；</li><li>403 Forbidden：表示服务器因为权限问题拒绝了客户端的请求；</li><li>404 Not Found：表示客户端请求了一个不存在的资源；</li><li>500 Internal Server Error：表示服务器处理时内部出错，例如因为无法连接数据库；</li><li>503 Service Unavailable：表示服务器此刻暂时无法处理请求。</li></ul> 
<p>从第二行开始，服务器每一行均返回一个HTTP头。服务器经常返回的HTTP Header包括：</p> 
<ul><li>Content-Type：表示该响应内容的类型，例如<code>text/html</code>，<code>image/jpeg</code>；</li><li>Content-Length：表示该响应内容的长度（字节数）；</li><li>Content-Encoding：表示该响应压缩算法，例如<code>gzip</code>；</li><li>Cache-Control：指示客户端应如何缓存，例如<code>max-age=300</code>表示可以最多缓存300秒。</li></ul> 
<p>HTTP请求和响应都由HTTP Header和HTTP Body构成，其中HTTP Header每行都以\r\n结束。如果遇到两个连续的\r\n，那么后面就是HTTP Body。浏览器读取HTTP Body，并根据Header信息中指示的Content-Type、Content-Encoding等解压后显示网页、图像或其他内容。</p> 
<p>通常浏览器获取的第一个资源是HTML网页，在网页中，如果嵌入了JavaScript、CSS、图片、视频等其他资源，浏览器会根据资源的URL再次向服务器请求对应的资源。</p> 
<p>关于HTTP协议的详细内容，请参考<a href="https://www.amazon.cn/dp/B00M2DKYRC/" rel="nofollow" title="HTTP权威指南">HTTP权威指南</a>一书，或者<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" rel="nofollow" title="Mozilla开发者网站">Mozilla开发者网站</a>。</p> 
<p>这里我们以服务器的身份响应客户端请求，编写服务器程序来处理客户端请求通常就称之为Web开发。</p> 
<h4>4、编写HTTP Server</h4> 
<p>我们来看一下如何编写HTTP Server。一个HTTP Server本质上是一个TCP服务器，我们先用TCP编程的多线程实现的服务器端框架：</p> 
<pre><code>public class Server {
    public static void main(String[] args) throws IOException {
        ServerSocket ss = new ServerSocket(8080); // 监听指定端口
        System.out.println("server is running...");
        for (;;) {
            Socket sock = ss.accept();
            System.out.println("connected from " + sock.getRemoteSocketAddress());
            Thread t = new Handler(sock);
            t.start();
        }
    }
}

class Handler extends Thread {
    Socket sock;

    public Handler(Socket sock) {
        this.sock = sock;
    }

    public void run() {
        try (InputStream input = this.sock.getInputStream()) {
            try (OutputStream output = this.sock.getOutputStream()) {
                handle(input, output);
            }
        } catch (Exception e) {
            try {
                this.sock.close();
            } catch (IOException ioe) {
            }
            System.out.println("client disconnected.");
        }
    }

    private void handle(InputStream input, OutputStream output) throws IOException {
        var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));
        var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));
        // TODO: 处理HTTP请求
    }
}
</code></pre> 
<p>只需要在handle()方法中，用Reader读取HTTP请求，用Writer发送HTTP响应，即可实现一个最简单的HTTP服务器。编写代码如下：</p> 
<pre><code>private void handle(InputStream input, OutputStream output) throws IOException {
    System.out.println("Process new http request...");
    var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));
    var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));
    // 读取HTTP请求:
    boolean requestOk = false;
    String first = reader.readLine();
    if (first.startsWith("GET / HTTP/1.")) {
        requestOk = true;
    }
    for (;;) {
        String header = reader.readLine();
        if (header.isEmpty()) { // 读取到空行时, HTTP Header读取完毕
            break;
        }
        System.out.println(header);
    }
    System.out.println(requestOk ? "Response OK" : "Response Error");
    if (!requestOk) {
        // 发送错误响应:
        writer.write("HTTP/1.0 404 Not Found\r\n");
        writer.write("Content-Length: 0\r\n");
        writer.write("\r\n");
        writer.flush();
    } else {
        // 发送成功响应:
        String data = "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;";
        int length = data.getBytes(StandardCharsets.UTF_8).length;
        writer.write("HTTP/1.0 200 OK\r\n");
        writer.write("Connection: close\r\n");
        writer.write("Content-Type: text/html\r\n");
        writer.write("Content-Length: " + length + "\r\n");
        writer.write("\r\n"); // 空行标识Header和Body的分隔
        writer.write(data);
        writer.flush();
    }
}
</code></pre> 
<p>这里的核心代码是，先读取HTTP请求，这里我们只处理GET /的请求。当读取到空行时，表示已读到连续两个\r\n，说明请求结束，可以发送响应。发送响应的时候，首先发送响应代码HTTP/1.0 200 OK表示一个成功的200响应，使用HTTP/1.0协议，然后，依次发送Header，发送完Header后，再发送一个空行标识Header结束，紧接着发送HTTP Body，在浏览器输入http://localhost.com:8080/就可以看到响应页面：</p> 
<p>HTTP目前有多个版本，1.0是早期版本，浏览器每次建立TCP连接后，只发送一个HTTP请求并接收一个HTTP响应，然后就关闭TCP连接。由于创建TCP连接本身就需要消耗一定的时间，因此，HTTP 1.1允许浏览器和服务器在同一个TCP连接上反复发送、接收多个HTTP请求和响应，这样就大大提高了传输效率。</p> 
<p>我们注意到HTTP协议是一个请求-响应协议，它总是发送一个请求，然后接收一个响应。能不能一次性发送多个请求，然后再接收多个响应呢？HTTP 2.0可以支持浏览器同时发出多个请求，但每个请求需要唯一标识，服务器可以不按请求的顺序返回多个响应，由浏览器自己把收到的响应和请求对应起来。可见，HTTP 2.0进一步提高了传输效率，因为浏览器发出一个请求后，不必等待响应，就可以继续发下一个请求。</p> 
<p>HTTP 3.0为了进一步提高速度，将抛弃TCP协议，改为使用无需创建连接的UDP协议，目前HTTP 3.0仍然处于实验阶段。</p> 
<p>总结：</p> 
<p>使用B/S架构时，总是通过HTTP协议实现通信，Web开发通常是指开发服务器端的Web应用程序。</p> 
<h3>二、JavaEE和Tomcat</h3> 
<h4>1、JavaEE 规范</h4> 
<p><code>JavaEE</code>规范是<code>J2EE</code>规范的新名称，早期被称为 J2EE 规范，其全称是 Java 2 Platform Enterprise Edition，是由 SUN 公司领导、各厂家共同制定并得到广泛认可的工业标准（JCP 组织成员）。</p> 
<p>其中，JCP 组织（<a href="https://jcp.org/en/home/index" rel="nofollow" title="官网">官网</a>）的全称是 Java Community Process，是一个开放的国际组织，主要由 Java 开发者以及被授权者组成，职能是发展和更新，成立于 1998 年。</p> 
<p>JavaEE 规范是众多 Java 开发技术的总称。这些技术规范都是沿用自 J2EE 的，一共包括了 13 个技术规范，如jsp/servlet、jndi、jaxp、jdbc、jni、jaxb、jmf、jta、jpa、EJB 等。</p> 
<p>JavaEE 的版本是延续了 J2EE 的版本，但是没有继续采用其命名规则。J2EE 的版本从 1.0 开始到 1.4 结束，而 JavaEE 版本是从 JavaEE 5 版本开始的，详情请参考：<a href="https://www.oracle.com/technetwork/cn/java/javaee/overview/index.html" rel="nofollow" title="JavaEE8 规范概览">JavaEE8 规范概览</a>。</p> 
<h4>2、Tomcat</h4> 
<p><strong>1. Tomcat 简介</strong></p> 
<p>服务器的概念非常的广泛，它可以指代一台特殊的计算机（相比普通计算机运行更快、负载更高、价格更贵），也可以指代用于部署网站的应用。</p> 
<p>以下说的服务器，其实是 Web 服务器，或者应用服务器，它本质就是一个软件，一个应用。作用就是发布我们的应用（工程），让用户可以通过浏览器访问我们的应用。</p> 
<p>常见的应用服务器：</p> 
<table><thead><tr><th>服务器名称</th><th>说明</th></tr></thead><tbody><tr><td>weblogic</td><td>实现了 javaEE 规范，重量级服务器，又称为 javaEE 容器</td></tr><tr><td>websphereAS</td><td>实现了 javaEE 规范，重量级服务器</td></tr><tr><td>JBOSSAS</td><td>实现了 JavaEE 规范，重量级服务器，免费</td></tr><tr><td>Tomcat</td><td>实现了 jsp/servlet 规范，是一个轻量级服务器，开源免费</td></tr></tbody></table> 
<p><strong>2. Tomcat下载与安装</strong></p> 
<p><a href="http://tomcat.apache.org/" rel="nofollow" title="Tomcat 官网下载地址">Tomcat 官网下载地址</a></p> 
<p id="tomcat-各版本所需支持">Tomcat 各版本所需支持：</p> 
<p><img alt="" height="296" src="https://images2.imgbox.com/7e/1e/siCp4uR4_o.png" width="1031"></p> 
<p>Tomcat 目录结构：</p> 
<p><img alt="" height="476" src="https://images2.imgbox.com/c1/76/IuMVrNHW_o.png" width="628"></p> 
<p><strong>3. Tomcat 基础使用</strong></p> 
<p>Tomcat实际上也是一个Java程序，我们看看Tomcat的启动流程：</p> 
<ol><li>启动JVM并执行Tomcat的<code>main()</code>方法；</li><li>加载war并初始化Servlet；</li><li>正常服务。</li></ol> 
<p>启动Tomcat无非就是设置好classpath并执行Tomcat某个jar包的main()方法，我们完全可以把Tomcat的jar包全部引入进来，然后自己编写一个main()方法，先启动Tomcat，然后让它加载我们的webapp就行。</p> 
<p>我们新建一个web-servlet-embedded工程，编写pom.xml如下：</p> 
<pre><code>&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
    &lt;artifactId&gt;web-servlet-embedded&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
        &lt;java.version&gt;17&lt;/java.version&gt;
        &lt;tomcat.version&gt;10.1.1&lt;/tomcat.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
            &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;
            &lt;version&gt;${tomcat.version}&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
            &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
            &lt;version&gt;${tomcat.version}&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;</code></pre> 
<p>其中，&lt;packaging&gt;类型仍然为war，引入依赖tomcat-embed-core和tomcat-embed-jasper，引入的Tomcat版本&lt;tomcat.version&gt;为10.1.1。</p> 
<p>不必引入Servlet API，因为引入Tomcat依赖后自动引入了Servlet API。因此，我们可以正常编写Servlet如下：</p> 
<pre><code>@WebServlet(urlPatterns = "/")
public class HelloServlet extends HttpServlet {
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType("text/html");
        String name = req.getParameter("name");
        if (name == null) {
            name = "world";
        }
        PrintWriter pw = resp.getWriter();
        pw.write("&lt;h1&gt;Hello, " + name + "!&lt;/h1&gt;");
        pw.flush();
    }
}</code></pre> 
<p>然后，我们编写一个main()方法，启动Tomcat服务器：</p> 
<pre><code>public class Main {
    public static void main(String[] args) throws Exception {
        // 启动Tomcat:
        Tomcat tomcat = new Tomcat();
        tomcat.setPort(Integer.getInteger("port", 8080));
        tomcat.getConnector();
        // 创建webapp:
        Context ctx = tomcat.addWebapp("", new File("src/main/webapp").getAbsolutePath());
        WebResourceRoot resources = new StandardRoot(ctx);
        resources.addPreResources(
                new DirResourceSet(resources, "/WEB-INF/classes", new File("target/classes").getAbsolutePath(), "/"));
        ctx.setResources(resources);
        tomcat.start();
        tomcat.getServer().await();
    }
}</code></pre> 
<p>这样，我们直接运行main()方法，即可启动嵌入式Tomcat服务器，然后，通过预设的tomcat.addWebapp("", new File("src/main/webapp")，Tomcat会自动加载当前工程作为根webapp，可直接在浏览器访问http://localhost:8080/：</p> 
<p><img alt="" height="144" src="https://images2.imgbox.com/a9/e4/1g5c3fFl_o.png" width="407"></p> 
<p>通过main()方法启动Tomcat服务器并加载我们自己的webapp有如下好处：</p> 
<ol><li>启动简单，无需下载Tomcat或安装任何IDE插件；</li><li>调试方便，可在IDE中使用断点调试；</li><li>使用Maven创建war包后，也可以正常部署到独立的Tomcat服务器中。</li></ol> 
<p>对SpringBoot有所了解的童鞋可能知道，SpringBoot也支持在<code>main()</code>方法中一行代码直接启动Tomcat，并且还能方便地更换成Jetty等其他服务器。</p> 
<p>推荐使用main()方法启动嵌入式Tomcat服务器并加载当前工程的webapp，便于开发调试，且不影响打包部署，能极大地提升开发效率。</p> 
<p>Tomcat启动报错解决：</p> 
<p>问题 1：启动一闪而过。</p> 
<ul><li> <p>原因：没有配置环境变量。</p> </li><li> <p>解决办法：配置上 JAVA_HOME 环境变量。</p> </li></ul> 
<p>问题 2：报错信息 Address already in use : JVM_Bind。</p> 
<ul><li> <p>原因：端口被占用。</p> </li><li> <p>解决办法：找到占用该端口的应用。</p> 
  <ul><li>已占的进程不重要：使用 cmd 命令：netstat -a -o 查看 pid，在任务管理器中结束占用端口的进程。</li><li>已占的进程很重要：修改 Tomcat 自己的端口号。在 Tomcat 目录下<code>\conf\server.xml</code>中修改配置：</li></ul></li></ul> 
<p><img alt="" height="57" src="https://images2.imgbox.com/0a/eb/J2mv1IOc_o.png" width="425"></p> 
<p>问题 3：启动时很多异常，但能正常启动。</p> 
<ul><li> <p>原因：Tomcat 中部署着很多项目，每次启动这些项目都会启动。而这些项目中有启动报异常的。</p> </li><li> <p>解决办法：</p> 
  <ul><li>能找到报异常的项目，就把它从发布目录中移除。</li><li>不能确定报异常的项目，就重新部署一个新的 Tomcat。</li></ul></li></ul> 
<p>其它问题：</p> 
<ul><li> <p>例如启动产生异常，但是不能正常启动。此时就需要部署一个新的 Tomcat 启动，来确定是系统问题，还是 Tomcat 的问题。</p> </li><li> <p>此时就需要具体问题，具体分析，然后再对症解决。</p> </li></ul> 
<p><strong>4. IDEA 集成 Tomcat</strong></p> 
<p><img alt="" height="550" src="https://images2.imgbox.com/96/11/JEixLH6w_o.png" width="835"></p> 
<p><img alt="" height="788" src="https://images2.imgbox.com/dd/b6/9MFqtux8_o.png" width="1200"></p> 
<p><img alt="" height="809" src="https://images2.imgbox.com/7c/d7/IgO0Q0Qq_o.png" width="1200"></p> 
<p><img alt="" height="362" src="https://images2.imgbox.com/8e/bf/aREdsdSh_o.png" width="591"></p> 
<p><strong>5. Tomcat 配置虚拟目录</strong></p> 
<p>虚拟目录的配置，支持两种方式：第一种是通过在主配置文件中添加标签实现；第二种是通过写一个独立配置文件实现。</p> 
<p>方式一：在server.xml的&lt;Host&gt;元素中加一个&lt;Context path="" docBase=""/&gt;元素。</p> 
<ul><li><code>path</code>：访问资源 URI。URI 名称可以随便起，但是必须在前面加上一个“/”。</li><li><code>docBase</code>：资源所在的磁盘物理地址。</li></ul> 
<p>方式二：是写一个独立的xml文件，该文件名可以随便起，但在文件内写一个&lt;Context/&gt;元素。</p> 
<ul><li>该文件要放在 Tomcat 目录中的<code>conf\Catalina\localhost\</code>目录下。</li><li>需要注意的是，在使用了独立的配置文件之后，访问资源 URI 就变成了<code>/+文件的名称</code>，而<code>Context</code>的<code>path</code>属性就失效了。</li></ul> 
<p><strong>6. Tomcat 配置虚拟主机（域名）</strong></p> 
<p>在&lt;Engine&gt;元素中添加一个&lt;Host name="" appBase="" unparkWARs="" autoDeploy="" /&gt;，其中：</p> 
<ul><li><code>name</code>：指定主机的名称。</li><li><code>appBase</code>：当前主机的应用发布目录。</li><li><code>unparkWARs</code>：启动时是否自动解压 war 包。</li><li><code>autoDeploy</code>：是否自动发布。</li></ul> 
<p>配置示例如下：</p> 
<pre><code>&lt;Host name="www.itcast.cn" appBase="D:\itcastapps" unpackWARs="true" autoDeploy="true"/&gt;

&lt;Host name="www.itheima.com" appBase="D:\itheimaapps" unpackWARs="true" autoDeploy="true"/&gt;</code></pre> 
<p><strong>7. Tomcat 默认项配置</strong></p> 
<p><strong>1）配置默认端口</strong></p> 
<p>Tomcat 服务器的主配置文件中配置着访问端口，它在配置文件中写的值是：8080。配置方式如下：</p> 
<pre><code>&lt;Connector port="80" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;</code></pre> 
<p><strong>2）配置默认应用</strong></p> 
<p>有两种方式可以配置默认应用。</p> 
<p>方式一：把要作为默认应用的应用，名称改为<code>ROOT</code>，放到<code>webapps</code>目录中。</p> 
<p><img alt="" height="238" src="https://images2.imgbox.com/55/25/SV0P3xRm_o.png" width="391"></p> 
<p>方式二：写一个独立的配置文件，文件名称为<code>ROOT.xml</code>。</p> 
<ul><li> <p>注意：<code>ROOT</code>必须大写。当使用了独立的<code>ROOT.xml</code>文件时，<code>webapps</code>下<code>ROOT</code>应用就不再是默认应用。</p> </li></ul> 
<p><img alt="" height="153" src="https://images2.imgbox.com/05/9a/eT0UihJG_o.png" width="386"></p> 
<p><strong>3）配置默认主页</strong></p> 
<p>首先要明确的是，配置默认主页是针对应用所说的，是应用的默认主页。</p> 
<p>在应用的 web.xml 中配置：</p> 
<pre><code>&lt;welcome-file-list&gt;
    &lt;welcome-file&gt;默认主页&lt;/welcome-file&gt;
&lt;/welcome-file-list&gt;</code></pre> 
<p>例如：</p> 
<pre><code>&lt;welcome-file-list&gt;
    &lt;!-- 有多个默认页时，先找到的就显示，不再往下找 --&gt;
    &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;
    &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;
    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
&lt;/welcome-file-list&gt;</code></pre> 
<h4>3、Java Web 应用</h4> 
<p><strong>1. Java Web 工程概述</strong></p> 
<p><code>JavaWeb</code>应用是一个全新的应用种类，这类应用程序指供浏览器访问的程序，通常也简称为 Web 应用。</p> 
<p>一个 Web 应用由多个静态 Web 资源和动态 Web 资源组成，例如有 html、css、js 文件，jsp 文件、java 程序、支持的 jar 包、工程配置文件、图片、音视频等等。</p> 
<p>Web 应用开发好后，若想供外界访问，需要把 Web 应用的所在目录，交给 Web 服务器管理（Tomcat 就是 Web 服务器之一），这个过程称之为虚似目录的映射。</p> 
<p><strong>2. Java Web 应用目录结构</strong></p> 
<p><img alt="" height="182" src="https://images2.imgbox.com/f5/f5/oyIv2oHP_o.png" width="411"></p> 
<pre><code>myapp -------- 应用名称
    demo.html
    css/demo.css
    js/demo.js
	WEB-INF -------- 如果有 web.xml 或者 .class 文件时，该目录必须存在，且严格区分大小写。
	        -------- 该目录下的资源，客户端是无法直接访问的。
                -------- 目录中内容如下：
        classes 目录 -------- web 应用的 class 文件（加载顺序：我们的 class，lib 目录中的 jar 包，tomcat 的 lib 目录中的 jar 包。其优先级依次降低）
        lib 目录 -------- web 应用所需的 jar 包（tomcat 的 lib 目录下 jar 为所有应用共享）
        web.xml -------- web 应用的主配置文件</code></pre> 
<p><strong>3. IDEA 创建 Java Web 应用工程</strong></p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/2c/de/wlUsng8L_o.png" width="456"></p> 
<p><img alt="" height="579" src="https://images2.imgbox.com/8c/66/Rvkj60WO_o.png" width="896"></p> 
<p><img alt="" height="583" src="https://images2.imgbox.com/01/dd/yB6Zl16W_o.png" width="894"></p> 
<p><img alt="" height="213" src="https://images2.imgbox.com/d1/e7/5Rz1dW9P_o.png" width="792"></p> 
<p><strong>4. Java Web 应用部署</strong></p> 
<p><strong>1）IDEA 部署</strong></p> 
<p><img alt="" height="364" src="https://images2.imgbox.com/be/a1/74boSS6I_o.png" width="584"></p> 
<p><img alt="" height="737" src="https://images2.imgbox.com/59/81/mg1AUeMT_o.png" width="1200"></p> 
<p><img alt="" height="361" src="https://images2.imgbox.com/6c/b4/f0VV7888_o.png" width="607"></p> 
<p><strong>2）war 包发布</strong></p> 
<p>步骤一：使用命令jar -cvf war [需要打包的目录路径]打包 war 包。</p> 
<p><img alt="" height="471" src="https://images2.imgbox.com/0a/e7/73cc8D5J_o.png" width="886"></p> 
<p><img alt="" height="189" src="https://images2.imgbox.com/6a/eb/MqMFJ9uZ_o.png" width="269"></p> 
<p>步骤二：把打好的 war 包拷贝到 tomcat 的 webapps 目录中。 </p> 
<p><img alt="" height="288" src="https://images2.imgbox.com/6a/56/C8cGygOB_o.png" width="391"></p> 
<p>步骤三：Tomcat 在启动时，会自动解压 war 包。 </p> 
<p><img alt="" height="612" src="https://images2.imgbox.com/d1/16/vIpXfcOo_o.png" width="691"></p> 
<h3>三、Servlet 控制器</h3> 
<h4>1、Java Web 设计模式</h4> 
<p><img alt="" height="454" src="https://images2.imgbox.com/3d/a5/aAk8Zk1W_o.png" width="1069"></p> 
<p>上面的例子，我们看到，编写HTTP服务器其实是非常简单的，只需要先编写基于多线程的TCP服务，然后在一个TCP连接中读取HTTP请求，发送HTTP响应即可。 </p> 
<p>但是，要编写一个完善的HTTP服务器，以HTTP/1.1为例，需要考虑的包括：</p> 
<ul><li>识别正确和错误的HTTP请求；</li><li>识别正确和错误的HTTP头；</li><li>复用TCP连接；</li><li>复用线程；</li><li>IO异常处理；</li><li>...</li></ul> 
<p>这些基础工作需要耗费大量的时间，并且经过长期测试才能稳定运行。如果我们只需要输出一个简单的HTML页面，就不得不编写上千行底层代码，那就根本无法做到高效而可靠地开发。</p> 
<p>因此，在JavaEE平台上，处理TCP连接，解析HTTP协议这些底层工作统统扔给现成的Web服务器去做，我们只需要把自己的应用程序跑在Web服务器上。为了实现这一目的，JavaEE提供了Servlet API，我们使用Servlet API编写自己的Servlet来处理HTTP请求，Web服务器实现Servlet API接口，实现底层功能：</p> 
<p><img alt="" height="112" src="https://images2.imgbox.com/fa/7b/8JUPCvWP_o.png" width="280"></p> 
<p>一个完整的Web应用程序的开发流程如下：</p> 
<ol><li>编写Servlet；</li><li>打包为war文件；</li><li>复制到Tomcat的webapps目录下；</li><li>启动Tomcat。</li></ol> 
<p>我们来实现一个最简单的Servlet：</p> 
<pre><code>// WebServlet注解表示这是一个Servlet，并映射到地址/:
@WebServlet(urlPatterns = "/")
public class HelloServlet extends HttpServlet {
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {
        // 设置响应类型:
        resp.setContentType("text/html");
        // 获取输出流:
        PrintWriter pw = resp.getWriter();
        // 写入响应:
        pw.write("&lt;h1&gt;Hello, world!&lt;/h1&gt;");
        // 最后不要忘记flush强制输出:
        pw.flush();
    }
}</code></pre> 
<p>一个Servlet总是继承自HttpServlet，然后覆写doGet()或doPost()方法。注意到doGet()方法传入了HttpServletRequest和HttpServletResponse两个对象，分别代表HTTP请求和响应。我们使用Servlet API时，并不直接与底层TCP交互，也不需要解析HTTP协议，因为HttpServletRequest和HttpServletResponse就已经封装好了请求和响应。以发送响应为例，我们只需要设置正确的响应类型，然后获取PrintWriter，写入响应即可。</p> 
<p>现在问题来了：Servlet API是谁提供？</p> 
<p>Servlet API是一个jar包，我们需要通过Maven来引入它，才能正常编译。编写pom.xml文件如下：</p> 
<pre><code>&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
    &lt;artifactId&gt;web-servlet-hello&lt;/artifactId&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
        &lt;java.version&gt;17&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;5.0.0&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;finalName&gt;hello&lt;/finalName&gt;
    &lt;/build&gt;
&lt;/project&gt;</code></pre> 
<p>注意到这个pom.xml与前面我们讲到的普通Java程序有个区别，打包类型不是jar，而是war，表示Java Web Application Archive：</p> 
<pre><code>&lt;packaging&gt;war&lt;/packaging&gt;</code></pre> 
<p>引入的Servlet API如下：</p> 
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;5.0.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</code></pre> 
<p>注意到&lt;scope&gt;指定为provided，表示编译时使用，但不会打包到.war文件中，因为运行期Web服务器本身已经提供了Servlet API相关的jar包。</p> 
<p>整个工程结构如下：</p> 
<p><img alt="" height="193" src="https://images2.imgbox.com/2a/ea/ge6v8eLu_o.png" width="438"></p> 
<p>目录webapp目前为空，如果我们需要存放一些资源文件，则需要放入该目录。有的同学可能会问，webapp目录下是否需要一个/WEB-INF/web.xml配置文件？这个配置文件是低版本Servlet必须的，但是高版本Servlet已不再需要，所以无需该配置文件。</p> 
<p>运行Maven命令mvn clean package，在target目录下得到一个hello.war文件，这个文件就是我们编译打包后的Web应用程序。</p> 
<p>如果执行package命令遇到Execution default-war of goal org.apache.maven.plugins:maven-war-plugin:2.2:war failed错误时，可手动指定maven-war-plugin最新版本3.3.2，参考练习工程的pom.xml。</p> 
<p>现在问题又来了：我们应该如何运行这个war文件？</p> 
<p>普通的Java程序是通过启动JVM，然后执行main()方法开始运行。但是Web应用程序有所不同，我们无法直接运行war文件，必须先启动Web服务器，再由Web服务器加载我们编写的HelloServlet，这样就可以让HelloServlet处理浏览器发送的请求。</p> 
<p>因此，我们首先要找一个支持Servlet API的Web服务器。常用的服务器有：</p> 
<ul><li><a href="https://tomcat.apache.org/" rel="nofollow" title="Tomcat">Tomcat</a>：由Apache开发的开源免费服务器；</li><li><a href="https://www.eclipse.org/jetty/" rel="nofollow" title="Jetty">Jetty</a>：由Eclipse开发的开源免费服务器；</li><li><a href="https://javaee.github.io/glassfish/" rel="nofollow" title="GlassFish">GlassFish</a>：一个开源的全功能JavaEE服务器。</li></ul> 
<p>还有一些收费的商用服务器，如Oracle的<a href="https://www.oracle.com/middleware/weblogic/" rel="nofollow" title="WebLogic">WebLogic</a>，IBM的<a href="https://www.ibm.com/cloud/websphere-application-platform/" rel="nofollow" title="WebSphere">WebSphere</a>。</p> 
<p>无论使用哪个服务器，只要它支持Servlet API 5.0（因为我们引入的Servlet版本是5.0），我们的war包都可以在上面运行。这里我们选择使用最广泛的开源免费的Tomcat服务器。</p> 
<p>要运行我们的hello.war，首先要<a href="https://tomcat.apache.org/download-10.cgi" rel="nofollow" title="下载Tomcat服务器">下载Tomcat服务器</a>，解压后，把hello.war复制到Tomcat的webapps目录下，然后切换到bin目录，执行startup.sh或startup.bat启动Tomcat服务器：</p> 
<pre><code>$ ./startup.sh 
Using CATALINA_BASE:   .../apache-tomcat-10.1.x
Using CATALINA_HOME:   .../apache-tomcat-10.1.x
Using CATALINA_TMPDIR: .../apache-tomcat-10.1.x/temp
Using JRE_HOME:        .../jdk-17.jdk/Contents/Home
Using CLASSPATH:       .../apache-tomcat-10.1.x/bin/bootstrap.jar:...
Tomcat started.</code></pre> 
<p>在浏览器输入http://localhost:8080/hello/即可看到HelloServlet的输出：</p> 
<p><img alt="" height="160" src="https://images2.imgbox.com/ff/27/YeZaimM9_o.png" width="382"></p> 
<p>细心的童鞋可能会问，为啥路径是/hello/而不是/？因为一个Web服务器允许同时运行多个Web App，而我们的Web App叫hello，因此，第一级目录/hello表示Web App的名字，后面的/才是我们在HelloServlet中映射的路径。</p> 
<p>那能不能直接使用/而不是/hello/？毕竟/比较简洁。</p> 
<p>答案是肯定的。先关闭Tomcat（执行shutdown.sh或shutdown.bat），然后删除Tomcat的webapps目录下的所有文件夹和文件，最后把我们的hello.war复制过来，改名为ROOT.war，文件名为ROOT的应用程序将作为默认应用，启动后直接访问http://localhost:8080/即可。</p> 
<p>实际上，类似Tomcat这样的服务器也是Java编写的，启动Tomcat服务器实际上是启动Java虚拟机，执行Tomcat的main()方法，然后由Tomcat负责加载我们的.war文件，并创建一个HelloServlet实例，最后以多线程的模式来处理HTTP请求。如果Tomcat服务器收到的请求路径是/（假定部署文件为ROOT.war），就转发到HelloServlet并传入HttpServletRequest和HttpServletResponse两个对象。</p> 
<p>因为我们编写的Servlet并不是直接运行，而是由Web服务器加载后创建实例运行，所以，类似Tomcat这样的Web服务器也称为Servlet容器。</p> 
<p>在Servlet容器中运行的Servlet具有如下特点：</p> 
<ul><li>无法在代码中直接通过new创建Servlet实例，必须由Servlet容器自动创建Servlet实例；</li><li>Servlet容器只会给每个Servlet类创建唯一实例；</li><li>Servlet容器会使用多线程执行doGet()或doPost()方法；</li><li>在Servlet中定义的实例变量会被多个线程同时访问，要注意线程安全；</li><li>HttpServletRequest和HttpServletResponse实例是由Servlet容器传入的局部变量，它们只能被当前线程访问，不存在多个线程访问的问题；</li><li>在doGet()或doPost()方法中，如果使用了ThreadLocal，但没有清理，那么它的状态很可能会影响到下次的某个请求，因为Servlet容器很可能用线程池实现线程复用；</li></ul> 
<p>总结：</p> 
<ul><li>编写Web应用程序就是编写Servlet处理HTTP请求；</li><li>Servlet API提供了HttpServletRequest和HttpServletResponse两个高级接口来封装HTTP请求和响应；</li><li>Web应用程序必须按固定结构组织并打包为.war文件；</li><li>需要启动Web服务器来加载我们的war包来运行Servlet。</li></ul> 
<h4>2、Servlet 简介</h4> 
<p>Servlet 是 SUN 公司提供的一套规范，名称就叫 Servlet 规范，它也是 JavaEE 规范之一。我们可以通过访问<a href="https://javaee.github.io/javaee-spec/javadocs/" rel="nofollow" title="官方 API">官方 API</a> 学习和查阅里面的内容。</p> 
<p>打开官方 API 网址，在左上部分找到 javax.servlet 包，在左下部分找到 Servlet，如下图显示：</p> 
<p><img alt="" height="651" src="https://images2.imgbox.com/9a/99/ywO2PNnQ_o.png" width="913"></p> 
<p>通过阅读 API，我们可以得到如下信息：</p> 
<ol><li>Servlet 是一个运行在 Web 服务端的 Java 小程序。</li><li>它可以用于接收和响应客户端的请求，主要功能在于交互式地浏览和修改数据，生成动态的 Web 内容。</li><li>要想实现 Servlet 功能，可以实现 Servlet 接口、继承 GenericServlet 或者 HttpServlet。</li><li>每次请求都会执行 service 方法。</li><li>Servlet 还支持配置。</li></ol> 
<p><img alt="" height="829" src="https://images2.imgbox.com/b0/60/4VxzpNT1_o.png" width="824"></p> 
<p>Servlet 主要执行以下工作：</p> 
<p>使用 Servlet，可以收集来自网页表单的用户输入，可以呈现来自数据库或者其他来源的记录，还可以动态地创建网页（JSP）。</p> 
<ol><li><strong>读取客户端（浏览器）发送的显式的数据</strong>。这包括网页上的 HTML 表单，或者也可以是来自 Applet 或自定义的 HTTP 客户端程序的表单。</li><li><strong>读取客户端（浏览器）发送的隐式的 HTTP 请求数据</strong>。这包括 Cookies、媒体类型和浏览器能理解的压缩格式等。</li><li><strong>处理数据并生成结果</strong>。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，认用 Web 服务，或者直接计算得出对应的响应。</li><li><strong>发送显式的数据（即文档）到客户端（浏览器）</strong>。该文档的格式可以是多种多样自包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。</li><li><strong>发送隐式的 HTTP 响应到客户端（浏览器）</strong>。这包括告诉浏览器或其他客户端被返国的文档类型（例如 HTML）、设置 Cookie 和缓存参数，以及其他类似的任务。</li></ol> 
<p>Java Servlet 通常情况下与使用 CGI（common gateway interface，公共网关接口）实现的程序可以达到异曲同工的效果。</p> 
<p>但是相比于 CGI，Servlet 有以下几点优势：</p> 
<ol><li>性能明显更好。</li><li>在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。</li><li>Servlet 是独立于平台的，因为它们是用 Java 编写的。</li><li>服务器上的 Java 安全管理器具有一定的限制，以保护服务器计算机上的资源。因此 Servlet 是可信的。</li><li>Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 Socket 和 RMI 机制与 Applet、数据库或其他软件进行交互。</li></ol> 
<h4>3、Servlet 基础使用</h4> 
<p><strong>1. Servlet 编写步骤</strong></p> 
<p><strong>1）编码</strong></p> 
<ol><li> <p>前期准备-创建 Java Web 工程；</p> </li><li> <p>编写一个普通类继承 GenericServlet 并重写 service 方法；</p> </li><li> <p>在 web.xml 配置 Servlet；</p> </li></ol> 
<p><strong>2）测试</strong></p> 
<ol><li> <p>在 Tomcat 中部署项目；</p> </li><li> <p>在浏览器访问 Servlet。</p> </li></ol> 
<p><img alt="" height="529" src="https://images2.imgbox.com/4d/c8/9sQj5Pzh_o.png" width="1180"></p> 
<p><strong>2. Servlet 执行过程 </strong></p> 
<p><img alt="" height="815" src="https://images2.imgbox.com/3f/d8/n297UiW4_o.png" width="1200"></p> 
<ol><li>浏览器使用 Socket（IP+端口）与服务器建立连接。</li><li>浏览器将请求数据按照 HTTP 打成一个数据包（请求数据包）发送给服务器。</li><li>服务器解析请求数据包并创建请求对象（request）和响应对象（response）。 
  <ul><li>请求对象是 HttpServletRquest 接口的一个实现。</li><li>响应对象是 HttpServletResponse 接口的一个实现，响应对象用于存放 Servlet 处理自的结果。</li></ul></li><li>服务器将解析之后的数据存放到请求对象（request）里面。</li><li>服务器依据请求资源路径找到相应的 Servlet 配置，通过反射创建 Servlet 实例。</li><li>服务器调用其 service() 方法，在在调用 serviceO方法时，会将事先创建好的请求对象（request）和响应对象（response）作为参数进行传递。</li><li>在 Servlet 内部，可以通过 reques st 获得请求数据，或者通过 response 设置响应数据</li><li>服务器从 response 中获取数据 按照 HTTP 打成一个数据包（响应数据包），发送给浏览器。</li><li>浏览器解析响应数据包，取出相应的数据，生成相应的界面。</li></ol> 
<p><strong>3. Servlet 类视图</strong></p> 
<ul><li>在 Servlet 的 API 介绍中，除了继承 GenericServlet 外还可以继承 HttpServlet。</li><li>通过查阅 servlet 的类视图，我们看到 GenericServlet 还有一个子类 HttpServlet。</li><li>同时，在 service 方法中还有参数 ServletRequest 和 ServletResponse。</li></ul> 
<p>它们的关系如下图所示：</p> 
<p><img alt="" height="304" src="https://images2.imgbox.com/64/9a/ytvy7FQk_o.png" width="451"></p> 
<p><strong>4. Servlet 编写方式</strong></p> 
<p>我们在实现 Servlet 功能时，可以选择以下三种方式：</p> 
<p>第一种：实现 Servlet 接口，接口中的方法必须全部实现。</p> 
<ul><li>使用此种方式，表示接口中的所有方法在需求方面都有重写的必要。此种方式支持最大程度的自定义。</li></ul> 
<p>第二种：继承 GenericServlet，service 方法必须重写，其他方可根据需求，选择性重写。</p> 
<ul><li>使用此种方式，表示只在接收和响应客户端请求这方面有重写的需求，而其他方法可根据实际需求选择性重写，使我们的开发 Servlet 变得简单。但是，此种方式是和 HTTP 协议无关的。</li></ul> 
<p>第三种：继承 HttpServlet。</p> 
<ul><li>它是 javax.servlet.http 包下的一个抽象类，是 GenericServlet 的子类。</li><li><code>如果我们选择继承 HttpServlet 时，只需要重写 doGet 和 doPost 方法，不需要覆盖 service 方法。</code></li><li>使用此种方式，表示我们的请求和响应需要和 HTTP 协议相关。也就是说，我们是通过 HTTP 协议来访问的。那么每次请求和响应都符合 HTTP 协议的规范。请求的方式就是 HTTP 协议所支持的方式（HTTP 协议支持 7 种请求方式：GET、POST、PUT、DELETE、TRACE、OPTIONS、HEAD)。</li><li>为了实现代码的可重用性，通常我们只需要在 doGet 或者 doPost 方法任意一个中提供具体功能即可，而另外的那个方法只需要调用提供了功能的方法。</li></ul> 
<p><strong>5. Servlet 生命周期</strong></p> 
<p>对象的生命周期，就是对象从生到死的过程，即：出生——活着——死亡。用更偏向于开发的官方说法，就是对象从被创建到销毁的过程。</p> 
<p>Servlet 的生命周期主要有初始化阶段、处理客户端请求阶段和终止阶段：</p> 
<ol><li> <p><strong>初始化阶段</strong></p> 
  <ul><li>Servlet 容器加载 Servlet，加载完成后，Servlet 容器会创建一个 Servlet 实例并调用 init() 方法，init() 方法只会调用一次。</li><li>Servlet 容器会在以下几种情况加载 Servlet： 
    <ol><li>Servlet 容器启动时自动加载某些 Servlet，这样需要在 web.xml 文件中添加。</li><li>在 Servlet 容器启动后，客户首次向 Servlet 发送请求。</li><li>Servlet 类文件被更新后，重新加载。</li></ol></li></ul></li><li> <p><strong>处理客户端请求阶段</strong></p> 
  <ul><li>每收到一个客户端请求，服务器就会产生一个新的线程去处理。对于用户的 Servlet 请求，Servlet 容器会创建一个特定于请求的 ServletRequest 和 ServletResponse。</li><li>对于 Tomcat 来说，它会将传递来的参数放入一个哈希表中，这是一个 String-&gt;String[]的键值映射。</li></ul></li><li> <p><strong>终止阶段</strong></p> 
  <ul><li>当 Web 应用被终止，或者 Servlet 容器终止运行，又或者 Servlet 重新加载 Servlet 新实例时，Servlet 容器会调用 Servlet 的 destroy() 方法。</li></ul></li></ol> 
<p>通过分析 Servlet 的生命周期可以发现，它的实例化和初始化只会在请求第一次到达 Servlet 时执行，而销毁只会在 Tomcat 服务器停止时执行。</p> 
<p>由此我们得出一个结论，Servlet 对象只会创建一次，销毁一次。所以，每一个 Servlet 只有一个实例对象。如果一个对象实例在应用中是唯一的存在，那么我们就说它是单实例的，即运用了单例模式。</p> 
<p><img alt="" height="700" src="https://images2.imgbox.com/bb/6b/pamTLSST_o.png" width="844"></p> 
<p>如下是一个典型的 Servlet 生命周期方案： </p> 
<p><img alt="" height="685" src="https://images2.imgbox.com/0f/61/kmc5TQcJ_o.png" width="825"></p> 
<ol><li>第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。</li><li>Servlet 容器在调用 service() 方法之前加载 Servlet。</li><li>Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 service() 方法。</li></ol> 
<p><strong>6. Servlet 执行时一般要实现的方法</strong></p> 
<p>Servlet 类要继承的 GenericServlet 与 HttpServlet 类说明：</p> 
<ol><li>GenericServlet 类是一个实现了 Servlet 的基本特征和功能的基类，其完整名称为 javax.Servlet.GenericServlet，它实现了 Servlet 和 ServletConfig 接口。</li><li>HtpServlet 类是 GenericServlet 的子类，其完整名称为javax.Servlet.HttpServlet，它提供了处理 HTTP 的基本构架。如果一个 Servlet 类要充分使用 HTTP 的功能，就应该继 HttpServlet。在 HttpServlet 类及其子类中，除可以调用 HttpServlet 类内部新定义的方法外，可以调用包括 Servlet、ServletConfig 接口和 GenericServlet 类中的一些方法。</li></ol> 
<p>Servlet 若继承上述类，执行时一般要实现的方法：</p> 
<pre><code>publle void init(servletconfig config)
public void service(servletRequest request, servletResponse response) public void destroy()
public Servletconfig getservletConfig() 
publle string getservletInfo()</code></pre> 
<ol><li> <p><code>init()</code> 方法在 Servlet 的生命周期中仅执行一次，在 Servlet 引擎创建 Servlet 对象后执行。 Servlet 在调用 init() 方法时，会传递一个包含 Servlet 的配置和运行环境信息的 ServletConfig 对象。如果初始化代码中要使用到 ServletConfig 对象，则初始化代码就只能在 Servlet 的 init() 方法中编写，而不能在构造方法中编写。默认的 init(方法通常是符合要求的，不过也可以根据需要进行覆盖，比如管理服务器端资源、初始化数据库连接等，默认的 inti()方法设置了 Servlet的初始化参数，并用它的 ServeltConfig 对象参数来启动配置，所以覆盖 init() 方法时，应调用 super.init() 以确保仍然执行这些任务。</p> </li><li> <p><code>service()</code> 方法是 Servlet 的核心，用于响应对 Servlet 的访问请求。对于 HttpServlet，每当客户请求一个 HttpServlet 对象时，该对象的 serviceO方法就要被调用，HttpServlet 默认的 serviceo方法的服务功能就是调用与 HTTP 请求的方法相应的 do 功能:doPostO和 doGet0，所以对于 HttpServlet，一般都是重写 doPostO和 doGet()方法。</p> </li><li> <p><code>destroy()</code> 方法在 Servlet 的生命周期中也仅执行一次，即在服务器停止卸载 Servlet 之前被调用，把 Servlet 作为服务器进程的一部分关闭。默认的 destroy() 方法通常是符合要求的，但也可以覆盖，来完成与 init() 方法相反的功能。比如在卸载 Servlet 时将统计数字保存在文件中，或是关闭数据库连接或 I/O 流。</p> </li><li> <p><code>getServletConfig()</code> 方法返回一个 ServletConfig 对象，该对象用来返回初始化参数和 ServletContext。ServletContext 接口提供有关 Servlet 的环境信息。</p> </li><li> <p><code>getServletInfo()</code> 方法提供有关 Servlet 的描述信息，如作者、版本、版权。可以对它进行覆盖。</p> </li><li> <p><code>doXxx()</code> 方法客户端可以用 HTTP 中规定的各种请求方式来访问 Servlet，Servlet 采取不同的访问方式进行处理。不管用哪种请求方式访问 Servlet，Servlet 引擎都会调用 Servlet 的 service() 方法，service() 方法是所有请求方式的入口。</p> 
  <ul><li>doGet() 用于处理 GET 请求；</li><li>doPost() 用于处理 POST 请求；</li><li>doHead() 用于处理 HEAD 请求；</li><li>doPut() 用于处理 PUT 请求；</li><li>doDelete() 用于处理 DELETE 请求；</li><li>doTrace() 用于处理 TRACE 请求；</li><li>doOptions() 用于处理 OPTIONS 请求。</li></ul></li></ol> 
<p><strong>7. Servlet 线程安全</strong></p> 
<p>由于 Servlet 运用了单例模式，即在整个应用中，每一个 Servlet 类只有一个实例对象，所以我们需要分析这个唯一的实例中的类成员是否线程安全。</p> 
<p>接下来，我们来看下面的的示例：</p> 
<pre><code>public class ServletDemo extends HttpServlet {
    //1.定义用户名成员变量
    //private String username = null;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String username = null;
        //synchronized (this) {
            //2.获取用户名
            username = req.getParameter("username");

            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            //3.获取输出流对象
            PrintWriter pw = resp.getWriter();

            //4.响应给客户端浏览器
            pw.print("welcome:" + username);

            //5.关流
            pw.close();
        //}
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req,resp);
    }
}
</code></pre> 
<p>启动两个浏览器，输入不同的参数，访问之后发现输出的结果都是一样，所以出现线程安全问题：</p> 
<p><img alt="" height="676" src="https://images2.imgbox.com/ce/d4/D5A4FGUb_o.png" width="1200"></p> 
<p>通过上面的测试我们发现，在 Servlet 中定义了类成员后，多个浏览器都会共享类成员的数据。每一个浏览器端就代表是一个线程，那么多个浏览器就是多个线程，所以测试的结果说明了多个线程会共享 Servlet 类成员中的数据。那么，其中任何一个线程修改了数据，都会影响其他线程。因此，我们可以认为 Servlet 不是线程安全的。</p> 
<p>分析产生这个问题的根本原因，其实就是因为 Servlet 是单例，单例对象的类成员只会随类实例化时初始化一次，之后的操作都可能会改变，而不是重新初始化。</p> 
<p>要解决这个线程安全问题，需要在 Servlet 中定义类成员时慎重。</p> 
<ul><li>如果类成员是共用的，并且只会在初始化时赋值，其余时间都是获取的话，那么是没问题的。</li><li>但如果类成员并非共用，或者每次使用都有可能对其赋值（如上图示例），那么就要考虑线程安全问题了，解决方案是把它定义到 doGet 或者 doPost 方法中。</li></ul> 
<p><strong>8. Servlet 映射配置</strong></p> 
<p>Servlet 支持三种映射方式，以达到灵活配置的目的。</p> 
<p>首先编写一个Servlet，代码如下：</p> 
<pre><code>public class ServletDemo extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("ServletDemo5接收到了请求");
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req,resp);
    }
}
</code></pre> 
<p id="方式一精确映射">方式一：精确映射。</p> 
<p>此种方式，只有和映射配置一模一样时，Servlet 才会接收和响应来自客户端的请求。</p> 
<p><img alt="" height="497" src="https://images2.imgbox.com/c6/c7/wMZS7xgq_o.png" width="824"></p> 
<p id="方式二开头通配符">方式二：/开头+通配符。</p> 
<p>此种方式，只要符合目录结构即可，不用考虑结尾是什么。</p> 
<p>例如：映射为：/servlet/*</p> 
<ul><li> <p>访问 <a href="http://localhost:8585/servlet/itheima" rel="nofollow" title="http://localhost:8585/servlet/itheima">http://localhost:8585/servlet/itheima</a> 或 <a href="http://localhost:8585/servlet/itcast.do" rel="nofollow" title="http://localhost:8585/servlet/itcast.do">http://localhost:8585/servlet/itcast.do</a> 这两个 URL 都可以。</p> </li><li> <p>因为用的<code>*</code>，表示 /servlet/ 后面的内容是什么都可以。</p> </li></ul> 
<p><img alt="" height="946" src="https://images2.imgbox.com/c9/a9/9Eh5A2YL_o.png" width="810"></p> 
<p id="方式三通配符固定格式结尾">方式三：通配符+固定格式结尾。</p> 
<p>此种方式，只要符合固定结尾格式即可，其前面的访问URI无须关心（注意协议，主机和端口必须正确）</p> 
<p>例如：映射为：*.do</p> 
<ul><li>访问 URL：<a href="http://localhost:8585/servlet/itcast.do" rel="nofollow" title="http://localhost:8585/servlet/itcast.do">http://localhost:8585/servlet/itcast.do</a> 或 <a href="http://localhost:8585/itheima.do" rel="nofollow" title="http://localhost:8585/itheima.do">http://localhost:8585/itheima.do</a> 这两个 URL 都可以。</li><li>因为都是以 .do 作为结尾，而前面用 * 号通配符配置的映射。</li></ul> 
<p><img alt="" height="942" src="https://images2.imgbox.com/2a/d2/RG1uMjIh_o.png" width="904"></p> 
<p id="优先级">优先级：</p> 
<p>通过测试我们发现，Servlet 支持多种配置方式，但是由此也引出了一个问题，当有两个及以上的 Servlet 映射都符合请求 URL 时，由谁来响应呢？</p> 
<p>注意：HTTP 协议的特征是一请求一响应的规则。那么有一个请求，必然有且只有一个响应。所以，映射规则的优先级如下：</p> 
<ol><li>精确匹配</li><li>/开头+通配符</li><li>通配符+固定格式结尾</li></ol> 
<p><img alt="" height="1022" src="https://images2.imgbox.com/61/a4/SLW5yjpb_o.png" width="1200"></p> 
<p><strong>9. 多路径映射 Servlet</strong></p> 
<p>这其实是给一个 Servlet 配置多个访问映射，从而可以根据不同请求 URL 实现不同的功能。</p> 
<p>示例 Servlet：</p> 
<pre><code>public class ServletDemo extends HttpServlet {

    /**
     * 根据不同的请求URL，做不同的处理规则
     * @param req
     * @param resp
     * @throws ServletException
     * @throws IOException
     */
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //1. 获取当前请求的 URI
        String uri = req.getRequestURI();
        uri = uri.substring(uri.lastIndexOf("/"), uri.length());
        //2. 判断是1号请求还是2号请求
        if("/servletDemo7".equals(uri)){
            System.out.println("ServletDemo7执行1号请求的业务逻辑：商品单价7折显示");
        }else if("/demo7".equals(uri)){
            System.out.println("ServletDemo7执行2号请求的业务逻辑：商品单价8折显示");
        }else {
            System.out.println("ServletDemo7执行基本业务逻辑：商品单价原价显示");
        }
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
</code></pre> 
<p>web.xml 配置 Servlet：</p> 
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;servletDemo7&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.itheima.web.servlet.ServletDemo7&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;!--映射路径1--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;servletDemo7&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/demo7&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;!--映射路径2--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;servletDemo7&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/servletDemo7&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;!--映射路径3--&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;servletDemo7&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre> 
<p>启动服务，测试运行结果：</p> 
<p><img alt="" height="490" src="https://images2.imgbox.com/7d/4a/YKzjZZiS_o.png" width="692"></p> 
<p><strong>10. 启动时即创建 Servlet</strong></p> 
<p>Servlet 的创建默认情况下是请求第一次到达 Servlet 时创建的。但是我们知道，Servlet 是单例的，也就是说在应用中只有唯一的一个实例，所以在 Tomcat 启动加载应用的时候就创建也是一个很好的选择。那么两者有什么区别呢？</p> 
<ul><li> <p>第一种：应用加载时创建 Servlet。</p> 
  <ul><li>它的优势是在服务器启动时，就把需要的对象都创建完成了，从而在使用的时候减少了创建对象的时间，提高了首次执行的效率。</li><li>它的弊端也同样明显，因为在应用加载时就创建了 Servlet 对象，因此，有可能导致内存中充斥着大量用不上的 Servlet 对象，造成了内存的浪费。</li></ul></li><li> <p>第二种：请求第一次访问是创建 Servlet。</p> 
  <ul><li>它的优势就是减少了对服务器内存的浪费，因为那些一直没有被访问过的 Servlet 对象就不会被创建，同时也提高了服务器的启动时间。</li><li>而它的弊端就是，如果有一些要在应用加载时就做的初始化操作，那么它就没法完成，从而要考虑其他技术实现。</li></ul></li></ul> 
<p>通过上面的分析可得出，当需要在应用加载就要完成一些工作时，就需要选择第一种方式；当有很多 Servlet 且其使用时机并不确定时，就选择第二种方式。</p> 
<p>在 web.xml 中是支持对 Servlet 的创建时机进行配置的，配置的方式如下：</p> 
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;servletDemo3&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.itheima.web.servlet.ServletDemo3&lt;/servlet-class&gt;
    &lt;!-- 配置Servlet的创建顺序，当配置此标签时，Servlet就会改为应用加载时创建
        配置项的取值只能是正整数（包括0），数值越小，表明创建的优先级越高。
    --&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;servletDemo3&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/servletDemo3&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre> 
<p><img alt="" height="150" src="https://images2.imgbox.com/b8/0d/8T9aaUzC_o.png" width="871"></p> 
<p><strong>11. 默认 Servlet</strong></p> 
<p>默认 Servlet 是由 Web 服务器提供的一个 Servlet，它配置在 Tomcat 的 conf 目录下的 web.xml 中。</p> 
<p>如下图所示：</p> 
<p><img alt="" height="446" src="https://images2.imgbox.com/f9/7d/TTO712AP_o.png" width="887"></p> 
<p>它的映射路径是&lt;url-pattern&gt;/&lt;url-pattern&gt;。在我们发送请求时，首先会在我们应用中的 web.xml 中查找映射配置，找到就执行。当找不到对应的 Servlet 路径时，就会去找默认的 Servlet，由默认 Servlet 处理。所以，一切都是 Servlet。</p> 
<p><strong>12. Servlet 关系总图</strong></p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/c8/7d/C8Gpxh3I_o.png" width="1135"></p> 
<h4>4、ServletConfig</h4> 
<p><strong>1. ServletConfig 简介</strong></p> 
<p>概念：</p> 
<ul><li>ServletConfig 是 Servlet 的配置参数对象。</li><li>在 Servlet 规范中，允许为每个 Servlet 都提供一些初始化配置。所以，每个 Servlet 都一个自己的 ServletConfig。</li><li>它的作用是在 Servlet 初始化期间，把一些配置信息传递给 Servlet。</li></ul> 
<p>生命周期：</p> 
<ul><li>由于 ServletConfig 是在初始化阶段读取了 web.xml 中为 Servlet 准备的初始化配置，并把配置信息传递给 Servlet，所以生命周期与 Servlet 相同。</li><li>这里需要注意的是，如果 Servlet 配置了<code>&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</code>，那么 ServletConfig 也会在应用加载时创建。</li></ul> 
<p><strong>2. ServletConfig 使用</strong></p> 
<p id="获取">获取：</p> 
<p>ServletConfig 可以为每个 Servlet 都提供初始化参数，所以肯定可以在每个 Servlet 中都配置。</p> 
<pre><code>public class ServletDemo8 extends HttpServlet {

    // 定义 Servlet 配置对象 ServletConfig
    private ServletConfig servletConfig;

    /**
     * 在初始化时为 ServletConfig 赋值
     * @param config
     * @throws ServletException
     */
    @Override
    public void init(ServletConfig config) throws ServletException {
        this.servletConfig = config;
    }

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 输出ServletConfig
        System.out.println(servletConfig);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req,resp);
    }
}
</code></pre> 
<p>web.xml：</p> 
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;servletDemo8&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.itheima.web.servlet.ServletDemo8&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;servletDemo8&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/servletDemo8&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre> 
<p>上面我们已经准备好了 Servlet，同时也获取到了它的 ServletConfig 对象，而如何配置初始化参数，则需要使用<code>&lt;servlet&gt;</code>标签中的<code>&lt;init-param&gt;</code>标签来配置。</p> 
<p>即 Servlet 的初始化参数都是配置在 Servlet 的声明部分的，并且每个 Servlet 都支持有多个初始化参数，并且初始化参数都是以键值对的形式存在的。</p> 
<p>配置示例：</p> 
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;servletDemo8&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.itheima.web.servlet.ServletDemo8&lt;/servlet-class&gt;
    &lt;!--配置初始化参数--&gt;
    &lt;init-param&gt;
        &lt;!--用于获取初始化参数的key--&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;!--初始化参数的值--&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--每个初始化参数都需要用到init-param标签--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;servletInfo&lt;/param-name&gt;
        &lt;param-value&gt;This is Demo8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;servletDemo8&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/servletDemo8&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre> 
<p id="常用方法">常用方法：</p> 
<p><img alt="" height="426" src="https://images2.imgbox.com/86/12/gdISslWw_o.png" width="1025"></p> 
<p>示例： </p> 
<pre><code>/**
 * 演示Servlet的初始化参数对象
 * @author 黑马程序员
 * @Company http://www.itheima.com
 */
public class ServletDemo8 extends HttpServlet {

    // 定义 Servlet 配置对象 ServletConfig
    private ServletConfig servletConfig;

    /**
     * 在初始化时为 ServletConfig 赋值
     * @param config
     * @throws ServletException
     */
    @Override
    public void init(ServletConfig config) throws ServletException {
        this.servletConfig = config;
    }

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 1. 输出ServletConfig
        System.out.println(servletConfig);
        // 2. 获取Servlet的名称
        String servletName= servletConfig.getServletName();
        System.out.println(servletName);
        // 3. 获取字符集编码
        String encoding = servletConfig.getInitParameter("encoding");
        System.out.println(encoding);
        // 4. 获取所有初始化参数名称的枚举
        Enumeration&lt;String&gt; names = servletConfig.getInitParameterNames();
        //遍历names
        while(names.hasMoreElements()){
            //取出每个name（key）
            String name = names.nextElement();
            //根据key获取value
            String value = servletConfig.getInitParameter(name);
            System.out.println("name:"+name+",value:"+value);
        }
        // 5. 获取ServletContext对象
        ServletContext servletContext = servletConfig.getServletContext();
        System.out.println(servletContext);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req,resp);
    }
}
</code></pre> 
<p><img alt="" height="360" src="https://images2.imgbox.com/94/38/2emZOC9R_o.png" width="699"></p> 
<h4>5、ServletContext</h4> 
<p><strong>1. ServletContext 简介</strong></p> 
<p>ServletContext 对象是<code>应用上下文对象</code>。</p> 
<p>每一个应用有且只有一个 ServletContext 对象，它可以实现让应用中所有 Servlet 间的数据共享。</p> 
<p>生命周期：</p> 
<ol><li> <p>出生： 应用一加载，该对象就被创建出来了。一个应用只有一个实例对象（Servlet 和 ServletContext 都是单例的）。</p> </li><li> <p>活着：只要应用一直提供服务，该对象就一直存在。</p> </li><li> <p>死亡：应用停止（或者服务器挂了），该对象消亡。</p> </li></ol> 
<p>域对象概念：</p> 
<ul><li> <p>域对象指的是<code>对象有作用域，即有作用范围</code>。</p> </li><li> <p>域对象的作用，域对象可以实现数据共享。不同作用范围的域对象，共享数据的能力不一样。</p> </li><li> <p>在 Servlet 规范中，一共有 4 个域对象，ServletContext 就是其中一个。</p> </li><li> <p>ServletContext 是 web 应用中最大的作用域，叫<code>application 域</code>。每个应用只有一个 application 域，它可以实现整个应用间的数据共享功能。</p> </li></ul> 
<p><strong>2. ServletContext 使用</strong></p> 
<p id="获取-1">获取：</p> 
<p>只需要调用 ServletConfig 对象的getServletContext()方法就可以了。</p> 
<pre><code>public class ServletDemo9 extends HttpServlet {

    // 定义 Servlet 配置对象 ServletConfig
    private ServletConfig servletConfig;

    /**
     * 在初始化时为 ServletConfig 赋值
     * @param config
     * @throws ServletException
     */
    @Override
    public void init(ServletConfig config) throws ServletException {
        this.servletConfig = config;
    }

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 获取 ServletContext 对象
        ServletContext servletContext = servletConfig.getServletContext();
        System.out.println(servletContext);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req,resp);
    }
}
</code></pre> 
<p>web.xml：</p> 
<pre><code>&lt;servlet&gt;
	&lt;servlet-name&gt;servletDemo9&lt;/servlet-name&gt;
	&lt;servlet-class&gt;com.itheima.web.servlet.ServletDemo9&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;servletDemo9&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/servletDemo9&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre> 
<p>更简洁的获取方法：</p> 
<p>在实际开发中，如果每个 Servlet 对 ServletContext 都使用频繁的话，那么每个 Servlet 里定义 ServletConfig，再获取 ServletContext 的代码将非常多，造成大量的重复代码。</p> 
<p>而 Servlet 规范的定义中也为我们想到了这一点，所以它在 GenericServlet 中，已经为我们声明好了 ServletContext 获取的方法。</p> 
<p><img alt="" height="835" src="https://images2.imgbox.com/ed/e7/ZkzwKB33_o.png" width="1055"></p> 
<p>示例 Servlet 都是继承自 HttpServlet，而 HttpServlet 又是 GenericServlet 的子类，所以我们在获取 ServletContext 时，如果当前 Servlet 没有用到它自己的初始化参数时，就可以不用再定义初始化参数了，而是直接改成下图所示的代码即可： </p> 
<p><img alt="" height="646" src="https://images2.imgbox.com/50/de/oX8JeS0O_o.png" width="975"></p> 
<p>ServletContext 既然被称之为应用上下文对象，那么它的配置就是针对整个应用的配置，而非某个特定 Servlet 的配置。它的配置被称为应用的初始化参数配置。</p> 
<p>配置的方式，需要在&lt;web-app&gt;标签中使用&lt;context-param&gt;来配置初始化参数。</p> 
<p>具体代码如下：</p> 
<pre><code>&lt;!--配置应用初始化参数--&gt;
&lt;context-param&gt;
    &lt;!--用于获取初始化参数的 key--&gt;
    &lt;param-name&gt;servletContextInfo&lt;/param-name&gt;
    &lt;!--初始化参数的值--&gt;
    &lt;param-value&gt;This is application scope&lt;/param-value&gt;
&lt;/context-param&gt;
&lt;!--每个应用初始化参数都需要用到 context-param 标签--&gt;
&lt;context-param&gt;
    &lt;param-name&gt;globalEncoding&lt;/param-name&gt;
    &lt;param-value&gt;UTF-8&lt;/param-value&gt;
&lt;/context-param&gt;</code></pre> 
<h4><strong>6、Servlet 注解开发</strong></h4> 
<p><strong>1. Servlet 3.0 规范</strong></p> 
<p>在大概十多年前，那会还是 Servlet 2.5 的版本的天下，它最明显的特征就是 Servlet 的配置要求配在 web.xml 中。</p> 
<p>从 2007 年开始到 2009 年底的这个时间段中，软件开发开始逐步的演变，基于注解的配置理念开始逐渐出现，大量注解配置思想开始用于各种框架的设计中，例如：Spring 3.0 版本的 Java Based Configuration、JPA 规范、Apache 旗下的 struts2 和 mybatis 的注解配置开发等等。</p> 
<p>JavaEE6 规范也是在这个期间设计并推出的，与之对应就是它里面包含了新的 Servlet 规范：Servlet 3.0 版本。</p> 
<p><strong>2. 使用示例</strong></p> 
<p>配置步骤：</p> 
<p>步骤一：创建 Java Web 工程，并移除 web.xml。</p> 
<p><img alt="" height="523" src="https://images2.imgbox.com/7e/92/9lafIQtl_o.png" width="802"></p> 
<p><img alt="" height="521" src="https://images2.imgbox.com/fe/39/btnjOZ3u_o.png" width="806"></p> 
<p>步骤二：编写 Servlet。</p> 
<pre><code>public class ServletDemo1 extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doPost(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("Servlet Demo1 Annotation");
    }
}</code></pre> 
<p>步骤三：使用注解配置 Servlet。</p> 
<p><img alt="" height="413" src="https://images2.imgbox.com/4b/17/zVWp0XT3_o.png" width="670"></p> 
<p>步骤四：测试。 </p> 
<p><img alt="" height="249" src="https://images2.imgbox.com/67/5b/TTiQR1Ge_o.png" width="471"></p> 
<p>注解源码分析： </p> 
<pre><code>/**
 * WebServlet注解
 * @since Servlet 3.0
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface WebServlet {

    /**
     * 指定Servlet的名称。
     * 相当于xml配置中&lt;servlet&gt;标签下的&lt;servlet-name&gt;
     */
    String name() default "";

    /**
     * 用于映射Servlet访问的url映射
     * 相当于xml配置时的&lt;url-pattern&gt;
     */
    String[] value() default {};

    /**
     * 相当于xml配置时的&lt;url-pattern&gt;
     */
    String[] urlPatterns() default {};

    /**
     * 用于配置Servlet的启动时机
     * 相当于xml配置的&lt;load-on-startup&gt;
     */
    int loadOnStartup() default -1;

    /**
     * 用于配置Servlet的初始化参数
     * 相当于xml配置的&lt;init-param&gt;
     */
    WebInitParam[] initParams() default {};

    /**
     * 用于配置Servlet是否支持异步
     * 相当于xml配置的&lt;async-supported&gt;
     */
    boolean asyncSupported() default false;

    /**
     * 用于指定Servlet的小图标
     */
    String smallIcon() default "";

    /**
     * 用于指定Servlet的大图标
     */
    String largeIcon() default "";

    /**
     * 用于指定Servlet的描述信息
     */
    String description() default "";

    /**
     * 用于指定Servlet的显示名称
     */
    String displayName() default "";
}
</code></pre> 
<h4>7、请求对象</h4> 
<p><strong>1. 请求对象介绍</strong></p> 
<p>请求，顾名思义，就是客户端希望从服务器端索取一些资源，因此向服务器发出的询问。在 B/S 架构中，就是客户浏览器向服务器发出询问。在 JavaEE 工程中，客户浏览器发出询问，要遵循 HTTP 协议所规定的。</p> 
<p>请求对象，就是在 JavaEE 工程中，用于发送请求的对象。</p> 
<p id="常用请求对象">常用请求对象：</p> 
<p>常用的请求对象是ServletRequest和HttpServletRequest，它们的区别就是是否和 HTTP 协议有关。</p> 
<p><img alt="" height="321" src="https://images2.imgbox.com/47/f2/2H40ToyJ_o.png" width="620"></p> 
<p>常用方法：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/51/ab/YKpFcBK1_o.png" width="1200"></p> 
<p><strong>2. 获取各种路径</strong></p> 
<pre><code>import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class requestServlet {
    
    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        //本机地址：服务器地址
        String localAddr = request.getLocalAddr();
        //本机名称：服务器名称
        String localName = request.getLocalName();
        //本机端口：服务器端口
        int localPort = request.getLocalPort();
        //来访者ip
        String remoteAddr = request.getRemoteAddr();
        //来访者主机
        String remoteHost = request.getRemoteHost();
        //来访者端口
        int remotePort = request.getRemotePort();
        //统一资源标识符
        String URI = request.getRequestURI();
        //统一资源定位符
        String URL = request.getRequestURL().toString();
        //获取查询字符串
        String queryString = request.getQueryString();
        //获取Servlet映射路径
        String servletPath = request.getServletPath();

        //输出内容
        System.out.println("getLocalAddr() is :"+localAddr);
        System.out.println("getLocalName() is :"+localName);
        System.out.println("getLocalPort() is :"+localPort);
        System.out.println("getRemoteAddr() is :"+remoteAddr);
        System.out.println("getRemoteHost() is :"+remoteHost);
        System.out.println("getRemotePort() is :"+remotePort);
        System.out.println("getRequestURI() is :"+URI);
        System.out.println("getRequestURL() is :"+URL);
        System.out.println("getQueryString() is :"+queryString);
        System.out.println("getServletPath() is :"+servletPath);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }
    
}
</code></pre> 
<p id="获取请求头信息"><strong>3. 获取请求头信息</strong></p> 
<pre><code>import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Enumeration;

public class requestServlet {
    
    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        //1.根据名称获取头的值	一个消息头一个值
        String value = request.getHeader("Accept-Encoding");
        System.out.println("getHeader():"+value);

        //2.根据名称获取头的值	一个头多个值
        Enumeration&lt;String&gt; values = request.getHeaders("Accept");
        while(values.hasMoreElements()){
            System.out.println("getHeaders():"+values.nextElement());
        }

        //3.获取请求消息头的名称的枚举
        Enumeration&lt;String&gt; names = request.getHeaderNames();
        while(names.hasMoreElements()){
            String name = names.nextElement();
            String value1 = request.getHeader(name);
            System.out.println(name+":"+value1);
        }
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre> 
<p id="获取请求参数"><strong>4. 获取请求参数</strong></p> 
<p><strong>1）获取请求参数</strong></p> 
<p>准备一个表单页面：</p> 
<pre><code>&lt;form action="/requestServlet" method="post"&gt;
    用户名：&lt;input type="text" name="username" /&gt;&lt;br/&gt;
    密码：&lt;input type="password" name="password" /&gt;&lt;br/&gt;
    确认密码：&lt;input type="password" name="password" /&gt;&lt;br/&gt;
    性别：&lt;input type="radio" name="gender" value="1" checked&gt;男
    &lt;input type="radio" name="gender" value="0"&gt;女
    &lt;br/&gt;
    &lt;input type="submit" value="注册" /&gt;
&lt;/form&gt;</code></pre> 
<p>方法示例：</p> 
<pre><code>import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Arrays;
import java.util.Enumeration;

@WebServlet("/requestServlet")
public class requestServlet extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        // 方式一
        String username = request.getParameter("username");
        String[] password = request.getParameterValues("password");  // 当表单中有多个名称是一样时，得到是一个字符串数组
        String gender = request.getParameter("gender");
        System.out.println(username+","+ Arrays.toString(password)+","+gender);  // user,[123, 123],1

        // 方式二
        // 1.获取请求正文名称的枚举
        Enumeration&lt;String&gt; names = request.getParameterNames();
        // 2.遍历正文名称的枚举
        while(names.hasMoreElements()){
            String name = names.nextElement();
            String value = request.getParameter(name);
            System.out.println(name+":"+value);
            /*
            username:user
            password:123
            gender:1
             */
        }
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }
}
</code></pre> 
<p><strong>2）封装请求参数到实体类中</strong></p> 
<p>通过上面的示例方法可以获取到请求参数，但是如果参数过多，在进行传递时，方法的形参定义将会变得非常难看。此时我们应该用一个对象来描述这些参数，它就是实体类。</p> 
<p>实体类示例：</p> 
<pre><code>import java.util.Arrays;

public class Student {

    // 成员变量名要与表单name值一致
    private String username;
    private String password;
    private String[] hobby;

    public Student() {
    }

    public Student(String username, String password, String[] hobby) {
        this.username = username;
        this.password = password;
        this.hobby = hobby;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String[] getHobby() {
        return hobby;
    }

    public void setHobby(String[] hobby) {
        this.hobby = hobby;
    }

    @Override
    public String toString() {
        return "Student{" +
                "username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", hobby=" + Arrays.toString(hobby) +
                '}';
    }
}
</code></pre> 
<p>我们现在要做的就是把表单中提交过来的数据填充到实体类中。</p> 
<p>使用 apache 的 commons-beanutils 实现封装：</p> 
<pre><code>private void test(HttpServletRequest request, HttpServletResponse response)
    throws ServletException, IOException {
    Users user = new Users();
    System.out.println("封装前："+user.toString());
    try{
        BeanUtils.populate(user, request.getParameterMap());  // 就一句代码
    }catch(Exception e){
        e.printStackTrace();
    }
    System.out.println("封装后："+user.toString());
}
</code></pre> 
<p id="以流的方式读取请求信息"><strong>5. 以流的方式读取请求信息</strong></p> 
<pre><code>import javax.servlet.ServletException;
import javax.servlet.ServletInputStream;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/*
    流对象获取数据
 */
@WebServlet("/servletDemo")
public class ServletDemo extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 字符流（必须是post方式）
        /*BufferedReader br = req.getReader();
        String line;
        while((line = br.readLine()) != null) {
            System.out.println(line);
        }*/
        // br.close();  // 由request获取的流对象无需手动关闭，由服务器自动关闭即可

        // 字节流
        ServletInputStream is = req.getInputStream();
        byte[] arr = new byte[1024];
        int len;
        while((len = is.read(arr)) != -1) {
            System.out.println(new String(arr, 0, len));
        }
        // is.close();
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req,resp);
    }
}
</code></pre> 
<p id="请求的中文乱码问题"><strong>6. 请求的中文乱码问题</strong></p> 
<p><strong>1）POST 请求</strong></p> 
<pre><code>public class RequestDemo extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        //1.获取请求正文
		/*POST方式：
		 * 问题：取的时候会不会有乱码
		 * 答案：会。因为是在获取的时候就已经乱码
		 * 解决办法：
		 * 	 是request对象的编码出问题了，因此设置request对象的字符集
		 *   request.setCharacterEncoding("GBK"); 它只能解决POST的请求方式，GET方式解决不了
		 * 结论：
		 * 	 请求正文的字符集和响应正文的字符集没有关系。各是各的
		 */
		request.setCharacterEncoding("UTF-8");
		String username = request.getParameter("username");
        // 输出到控制台
		System.out.println(username);
        // 输出到浏览器：注意响应的乱码问题已经解决了
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        out.write(username);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }
}
</code></pre> 
<p><strong>2）GET 请求</strong></p> 
<p>GET 方式请求的正文是在地址栏中，在 Tomcat8.5 版本及以后，Tomcat 服务器已经帮我们解决了，所以不会有乱码问题。</p> 
<p>而如果我们使用的不是 Tomcat 服务器，或者 Tomcat 版本是 8.5 以前，那么 GET 方式仍然会有乱码问题。</p> 
<p>解决方式如下：</p> 
<pre><code>public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        /*
         * GET方式：正文在地址栏
         * username=%D5%C5%C8%FD
         * %D5%C5%C8%FD是已经被编过一次码了
         *
         * 解决办法：
         * 	 使用正确的码表对已经编过码的数据进行解码。
         * 		就是把取出的内容转成一个字节数组，但是要使用正确的码表。（ISO-8859-1）
         * 	 再使用正确的码表进行编码
         * 		把字节数组再转成一个字符串，需要使用正确的码表，是看浏览器当时用的是什么码表
         */
        String username = request.getParameter("username");
        byte[] by = username.getBytes("ISO-8859-1");
        username = new String(by, "GBK");

        //输出到浏览器：注意响应的乱码问题已经解决了
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        out.write(username);
}

public void doPost(HttpServletRequest request, HttpServletResponse response)
    throws ServletException, IOException {
    doGet(request, response);
}
</code></pre> 
<p><strong>7. 请求转发</strong></p> 
<p id="请求域"><strong>1）请求域</strong></p> 
<ul><li><strong>请求（Request）域</strong>：可以在一次请求范围内进行数据共享。一般用于请求转发的多个资源中共享数据。</li><li><strong>作用范围</strong>：当前请求（一次请求，和当前请求的转发之中。</li></ul> 
<p><img alt="" height="108" src="https://images2.imgbox.com/b6/02/y7KlB6WA_o.png" width="625"></p> 
<p>请求对象操作共享数据的方法： </p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void</td><td>setAttribute(String name, Object value)</td><td>向请求域对象中存储数据</td></tr><tr><td>Object</td><td>getAttribute(String name)</td><td>通过名称获取请求域对象中的数据</td></tr><tr><td>void</td><td>removeAttribute(String name)</td><td>通过名称移除请求域对象中的数据</td></tr></tbody></table> 
<p><strong>2）请求转发</strong></p> 
<p><strong>请求转发</strong>：客户端的一次请求到达后，发现需要借助其他 Servlet 来实现功能。</p> 
<p>特点：</p> 
<ul><li>浏览器地址不变</li><li>域对象中的数据不丢失</li><li>负责转发的 Servlet 的响应正文会丢失</li><li>由转发的目的地（Servlet）来响应客户端</li></ul> 
<p><img alt="" height="119" src="https://images2.imgbox.com/3c/9b/1gTp4dau_o.png" width="623"></p> 
<p>请求转发代码示例：</p> 
<ul><li>中转 Servlet</li></ul> 
<pre><code>    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        // 1.拿到请求调度对象
        RequestDispatcher rd = request.getRequestDispatcher("/RequestDemo7");  // 如果是给浏览器看的，/可写可不写。如果是给服务器看的，一般情况下，/都是必须的。
        // 2.放入数据到请求域中
        request.setAttribute("CityCode", "bj-010");
        // 3.实现真正的转发操作
        rd.forward(request, response);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }
</code></pre> 
<ul><li>目标 Servlet</li></ul> 
<pre><code>    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        // 获取请求域中的数据
        String value = (String)request.getAttribute("CityCode");
        response.getWriter().write("welcome to request demo："+value);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }
</code></pre> 
<p><strong>3）请求转发与重定向的区别</strong></p> 
<ul><li> <p>当使用<strong>请求转发</strong>时，Servlet 容器将使用一个内部的方法来调用目标页面，新的页面继续处理同一个请求，而浏览器将不会知道这个过程（即服务器行为）。与之相反，<strong>重定向</strong>的含义是第一个页面通知浏览器发送一个新的页面请求。因为当使用重定向时，浏览器中所显示的 URL 会变成新页面的 URL（浏览器行为）。而当使用转发时，该 URL 会保持不变。</p> </li><li> <p><strong>重定向</strong>的速度比转发慢，因为浏览器还得发出一个新的请求。</p> </li><li> <p>同时，由于<strong>重定向</strong>产生了一个新的请求，所以经过一次重定向后，请求内的对象将无法使用。</p> </li></ul> 
<p>总结：</p> 
<ul><li><strong>重定向</strong>：两次请求，浏览器行为，地址栏改变，请求域中的数据会丢失。</li><li><strong>请求转发</strong>：一次请求，服务器行为，地址栏不变，请求域中的数据不丢失。</li></ul> 
<p>怎么选择是重定向还是转发呢？</p> 
<ul><li> <p>通常情况下转发更快，而且能保持请求内的对象，所以它是第一选择。但是由于在转发之后，浏览器中 URL 仍然指向开始页面，此时如果重载当前页面，开始页面将会被重新调用。如果不想看到这样的情况，则选择重定向。</p> </li><li> <p>不要仅仅为了把变量传到下一个页面而使用 session 作用域，那会无故增大变量的作用域，转发也许可以帮助解决这个问题。</p> 
  <ul><li>重定向：以前的请求中存放的变量全部失效，并进入一个新的请求作用域。</li><li>转发：以前的请求中存放的变量不会失效，就像把两个页面拼到了一起。</li></ul></li></ul> 
<p><strong>4）请求包含</strong></p> 
<p>我们都知道 HTTP 协议的特点是一请求，一响应的方式，所以绝对不可能出现有多个 Servlet 同时响应的方式。那么我们就需要用到“请求包含”，把多个 Servlet 的响应内容合并输出。</p> 
<p><strong>请求包含</strong>：可以合并其他 Servlet 中的功能，一起响应给客户端。</p> 
<p><strong>特点：</strong></p> 
<ul><li>浏览器地址不变</li><li>域对象中的数据不丢失</li><li>被包含的 Servlet 响应头会丢失</li><li>这种包含是“动态包含”：各编译各的，只是最后合并输出</li></ul> 
<p>代码示例：</p> 
<ul><li>被包含 Servlet</li></ul> 
<pre><code>@WebServlet("/RequestDemo1")
public class RequestDemo1 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.getWriter().write("include request demo1");
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }
}
</code></pre> 
<ul><li>最终 Servlet</li></ul> 
<pre><code>public class RequestDemo2 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.getWriter().write("include request demo2");
        // 1.拿到请求调度对象
        RequestDispatcher rd = request.getRequestDispatcher("/RequestDemo1");
        // 2.实现包含的操作
        rd.include(request, response);
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }
}
</code></pre> 
<p>浏览器响应结果：</p> 
<pre><code>include request demo2
include request demo1</code></pre> 
<h4>8、响应对象</h4> 
<p><strong>1. 响应对象简介</strong></p> 
<p>什么是响应：</p> 
<p>响应，它表示了服务器端收到请求，同时也已经处理完成，把处理的结果告知用户。简单来说，指的就是服务器把请求的处理结果告知客户端。在 B/S 架构中，响应就是把结果带回浏览器。</p> 
<p>响应对象，顾名思义就是用于在 JavaWeb 工程中实现上述功能的对象。</p> 
<p>常用响应对象：</p> 
<p>响应对象也是 Servlet 规范中定义的，它包括了协议无关的和协议相关的。</p> 
<ul><li> <p>协议无关的对象标准是：ServletResponse 接口</p> </li><li> <p>协议相关的对象标准是：HttpServletResponse 接口</p> </li></ul> 
<p>类结构图如下：</p> 
<p><img alt="" height="338" src="https://images2.imgbox.com/53/85/2WpUXs99_o.png" width="423"></p> 
<p>常用方法：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/28/fa/UOT5p7vJ_o.png" width="1150"></p> 
<p>注意：</p> 
<ul><li>response 获取的流无需手动关闭（close），由服务器关闭即可。</li><li>response 得到的字符流和字节流互斥，只能选其一。</li></ul> 
<p><img alt="" height="456" src="https://images2.imgbox.com/06/da/GrIN60UB_o.png" width="1060"></p> 
<p><strong>2. 字节流响应对象及中文乱码问题</strong></p> 
<p>常用方法：</p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>ServletOutputStream</td><td>getOutputStream()</td><td>获取响应字节输出流对象</td></tr><tr><td>void</td><td>setContentType("text/html;charset=UTF-8")</td><td>设置响应内容类型，解决中文乱码问题</td></tr></tbody></table> 
<p>中文乱码问题：</p> 
<ul><li><strong>问题</strong>：IDEA 编写的 String str = "字节流中文乱码问题"，使用字节流输出，会不会产生中文乱码？</li><li><strong>答案</strong>：会产生乱码。</li><li><strong>原因</strong>：String str = "字节流中文乱码问题"; 在保存时用的是 IDEA 创建文件使用的字符集 UTF-8。在到浏览器上显示，Chrome 浏览器和 IE 浏览器默认的字符集是 GB2312（GBK），存和取用的不是同一个码表，就会产生乱码。</li><li><strong>引申</strong>：如果产生了乱码，就是存和取用的不是同一个码表</li><li><strong>解决方案</strong>：把存和取的码表统一。</li></ul> 
<p>解决方法详解：</p> 
<ol><li>解决方法一：修改浏览器的编码，使用右键——编码——改成UTF-8。IE 和火狐浏览器可以直接右键设置字符集。而 chrome 需要安装插件，很麻烦。（不建议使用，尽量不要求用户做什么事情）</li><li>解决方法二：向页面上输出一个 meta 标签：&lt;meta http-equiv="content-type" content="text/html;charset=UTF-8"&gt;，其实它就是指挥了浏览器，使用哪个编码进行显示。（不建议使用，因为不好记）</li><li>解决方法三：设置响应消息头，告知浏览器响应正文的MIME类型和字符集：response.setHeader("Content-Type","text/html;charset=UTF-8");</li><li>解决方法四：（推荐使用）本质就是设置了一个响应消息头：<code>response.setContentType("text/html;charset=UTF-8")</code>;</li></ol> 
<p>示例代码：</p> 
<pre><code>public class ResponseDemo extends HttpServlet {

    /**
     * 演示字节流输出的乱码问题
     */
    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        String str = "字节流输出中文的乱码问题";  // UTF-8的字符集。  解决方法一：浏览器显示也需要使用UTF-8的字符
        // 1.拿到字节流输出对象
        ServletOutputStream sos = response.getOutputStream();

        // 解决方法二：sos.write("&lt;meta http-equiv='content-type' content='text/html;charset=UTF-8'&gt;".getBytes());
        // 解决方法三：response.setHeader("Content-Type","text/html;charset=UTF-8");
		
        // 解决方法四：
        response.setContentType("text/html;charset=UTF-8");
		
        // 2.把str转换成字节数组之后输出到浏览器
        sos.write(str.getBytes("UTF-8")); 
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }
}
</code></pre> 
<p><img alt="" height="786" src="https://images2.imgbox.com/5d/17/2Vstv05K_o.png" width="798"></p> 
<p><strong>3. 字符流响应对象及中文乱码问题</strong></p> 
<pre><code>public class ResponseDemo extends HttpServlet {

    /**
     * 演示：字符流输出中文乱码
     * @param request
     * @param response
     * @throws ServletException
     * @throws IOException
     */
    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
				
        String str = "字符流输出中文乱码";

        // 设置响应正文的MIME类型和字符集
        response.setContentType("text/html;charset=UTF-8");
		
        // 1.获取字符输出流
        PrintWriter out = response.getWriter();
        // 2.使用字符流输出中文
		out.write(str);
		
        /**
         * 问题：out.write(str); 直接输出，会不会产生乱码？
		 *
         * 答案：会产生乱码
		 *
         * 原因：
         *   UTF-8(存)————&gt;PrintWriter ISO-8859-1(取)		乱
         *   PrintWirter ISO-8859-1(存)————&gt;浏览器 GBK(取)	乱
         *
         * 解决办法：
         * 	 改变PrintWriter的字符集，PrintWriter是从response对象中获取的，因此设置response的字符集。
         *   注意：设置response的字符集，需要在拿流之前。
         *  response.setCharacterEncoding("UTF-8");
         *
         * response.setContentType("text/html;charset=UTF-8");
         * 此方法，其实是做了两件事：
         * 		1. 设置响应对象的字符集（包括响应对象取出的字符输出流）
         * 		2. 告知浏览器响应正文的MIME类型和字符集
         */
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }
}
</code></pre> 
<p><img alt="" height="790" src="https://images2.imgbox.com/02/bc/k3GvsZXV_o.png" width="800"></p> 
<p><strong>4. 响应消息头：设置缓存时间</strong></p> 
<p>使用缓存的一般都是静态资源，动态资源一般不能缓存。</p> 
<pre><code>public class ResponseDemo extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        
        String str = "设置缓存时间";
        
        /*
         * 设置缓存时间，其实就是设置响应消息头：Expires，其值是一个毫秒数。
         * 使用的是：response.setDateHeader();
         *
         * 缓存1小时，是在当前时间的毫秒数上加上1小时之后的毫秒值       
        */
        
        response.setDateHeader("Expires",System.currentTimeMillis()+1*60*60*1000);
        response.setContentType("text/html;charset=UTF-8");
        response.getOutputStream().write(str.getBytes());
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre> 
<p><img alt="" height="638" src="https://images2.imgbox.com/99/ed/eRxW1SQi_o.png" width="1075"></p> 
<p><img alt="" height="399" src="https://images2.imgbox.com/a7/4c/TvHivM0x_o.png" width="799"></p> 
<p><strong>5. 响应消息头：定时刷新</strong></p> 
<pre><code>public class ResponseDemo extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        String str = "用户名和密码不匹配，2秒后转向登录页面...";
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        out.write(str);
        // 定时刷新，其实就是设置一个响应消息头
        response.setHeader("Refresh", "2;URL=/login.html");  // Refresh设置的时间单位是秒，如果刷新到其他地址，需要在时间后面拼接上地址
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }

}</code></pre> 
<p><img alt="" height="399" src="https://images2.imgbox.com/12/75/OjP3Ssj5_o.png" width="800"></p> 
<p><strong>6. 请求重定向</strong></p> 
<ul><li><strong>原始 Servlet</strong></li></ul> 
<pre><code>public class ResponseDemo6 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        // 1.设置响应状态码
//		response.setStatus(302);
        // 2.定向到哪里去: 其实就是设置响应消息头，Location
//		response.setHeader("Location", "ResponseDemo7");

        //使用重定向方法
        response.sendRedirect("ResponseDemo7");  // 此行做了什么事，请看上面
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }

}</code></pre> 
<ul><li><strong>目标 Servlet</strong></li></ul> 
<pre><code>public class ResponseDemo7 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.getWriter().write("welcome to ResponseDemo7");
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }
}
</code></pre> 
<p><img alt="" height="730" src="https://images2.imgbox.com/a8/ab/jQWhUGfz_o.png" width="1107"></p> 
<p><strong>7. 文件下载</strong></p> 
<p>首先在工程的 web 目录下新建一个目录 uploads，并且拷贝一张图片到目录中，如下图所示：</p> 
<p><img alt="" height="297" src="https://images2.imgbox.com/b2/1a/Y1n1PtX0_o.png" width="363"></p> 
<p>文件下载的 Servlet： </p> 
<pre><code>public class ResponseDemo8 extends HttpServlet {

    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        /*
         * 文件下载的思路：
         * 		1.获取文件路径
         * 		2.把文件读到字节输入流中
         * 		3.告知浏览器，以下载的方式打开（告知浏览器下载文件的MIME类型）
         * 		4.使用响应对象的字节输出流输出到浏览器上
         */
        // 1.获取文件路径（绝对路径）
        ServletContext context = this.getServletContext();
        String filePath = context.getRealPath("/uploads/6.jpg");//通过文件的虚拟路径，获取文件的绝对路径
        // 2.通过文件路径构建一个字节输入流
        InputStream in  = new FileInputStream(filePath);
        // 3.设置响应消息头
        response.setHeader("Content-Type", "application/octet-stream");  // 注意下载的时候，设置响应正文的MIME类型，用application/octet-stream
        response.setHeader("Content-Disposition", "attachment;filename=1.jpg");  // 告知浏览器以下载的方式打开
        // 4.使用响应对象的字节输出流输出
        OutputStream out = response.getOutputStream();
        int len = 0;
        byte[] by = new byte[1024];
        while((len = in.read(by)) != -1){
            out.write(by, 0, len);
        }
        in.close();
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre> 
<p><img alt="" height="268" src="https://images2.imgbox.com/d2/71/u4puphKy_o.png" width="615"></p> 
<h4>9、会话管理</h4> 
<p><strong>1. 会话管理简介</strong></p> 
<p>什么是会话：</p> 
<p>这里的会话，指的是 Web 开发中的一次通话过程，当打开浏览器，访问网站地址后，会话开始，当关闭浏览器（或者到了过期时间），会话结束。</p> 
<p>会话管理的作用：</p> 
<p>什么时候会用到会话管理呢？最常见的就是购物车，当我们登录成功后，把商品加入到购物车之中，此时我们无论再浏览什么商品，当点击购物车时，那些加入的商品都仍在购物车中。</p> 
<p>在我们的实际开发中，还有很多地方都离不开会话管理技术。比如，我们在论坛发帖，没有登录的游客身份是不允许发帖的。所以当我们登录成功后，无论我们进入哪个版块发帖，只要权限允许的情况下，服务器都会认识我们，从而让我们发帖，因为登录成功的信息一直保留在服务器端的会话中。</p> 
<p>通过上面的两个例子，我们可以看出，它是为我们共享数据用的，并且是在<strong>不同请求间</strong>实现数据共享。也就是说，如果我们需要在<strong>多次请求间</strong>实现数据共享，就可以考虑使用会话管理技术了。</p> 
<p>会话管理分类：</p> 
<p>在 JavaEE 的项目中，会话管理分为两类，分别是：客户端会话管理技术和服务端会话管理技术。</p> 
<ul><li> <p><strong>客户端</strong>会话管理技术：它是把要共享的数据保存到了客户端（也就是浏览器端）。每次请求时，把会话信息带到服务器，从而实现多次请求的数据共享。</p> </li><li> <p><strong>服务端</strong>会话管理技术：它本质仍是采用客户端会话管理技术，只不过保存到客户端的是一个特殊的标识，并且把要共享的数据保存到了服务端的内存对象中。每次请求时，把这个标识带到服务器端，然后使用这个标识，找到对应的内存空间，从而实现数据共享。</p> </li></ul> 
<p><strong>2. 客户端会话管理技术：Cookie</strong></p> 
<p id="cookie-概述"><strong>1）Cookie 概述</strong></p> 
<p>它是客户端浏览器的缓存文件，里面记录了客户浏览器访问网站的一些内容。同时，也是 HTTP 请求和响应消息头的一部分。</p> 
<p>作用：</p> 
<p>Cookie 可以保存客户端浏览器访问网站的相关内容（需要客户端不禁用 Cookie），从而在每次访问需要同一个内容时，先从本地缓存获取，使资源共享，提高效率。</p> 
<p id="cookie-常用属性"><strong>2）Cookie 常用属性</strong></p> 
<table><thead><tr><th>属性名称</th><th>属性作用</th><th>是否重要</th></tr></thead><tbody><tr><td>name</td><td>cookie 的名称</td><td>必要属性</td></tr><tr><td>value</td><td>cookie 的值（不能是中文）</td><td>必要属性</td></tr><tr><td>path</td><td>cookie 的路径</td><td>重要</td></tr><tr><td>domain</td><td>cookie 的域名</td><td>重要</td></tr><tr><td>maxAge</td><td>cookie 的生存时间</td><td>重要</td></tr><tr><td>version</td><td>cookie 的版本号</td><td>不重要</td></tr><tr><td>comment</td><td>cookie 的说明</td><td>不重要</td></tr></tbody></table> 
<p>详解：</p> 
<ul><li> <p>Cookie 有大小和个数限制：</p> 
  <ul><li>每个网站最多只能存 20 个cookie，且大小不能超过 4kb。</li><li>同时，所有网站的 cookie 总数不超过 300 个。</li></ul></li><li> <p>maxAge 值：</p> </li><li> <p>当要删除 Cookie 时，可以设置 maxAge 值为 0。</p> </li><li> <p>当不设置 maxAge 时，使用的是浏览器的内存。当关闭浏览器之后，Cookie 将丢失。</p> </li><li> <p>设置了此值，就会保存成缓存文件（值必须是大于 0 的，以秒为单位）。</p> </li></ul> 
<p id="cookie-常用方法"><strong>3）Cookie 常用方法</strong></p> 
<p>创建 Cookie：</p> 
<p><img alt="" height="588" src="https://images2.imgbox.com/5c/77/kw9nG9t1_o.png" width="298"></p> 
<pre><code>/**
 * 通过指定的名称和值构造一个Cookie
 *
 * Cookie的名称必须遵循RFC 2109规范。这就意味着，它只能包含ASCII字母数字字符，
 * 不能包含逗号、分号或空格或以$字符开头。
 * 创建后无法更改cookie的名称。
 *
 * 该值可以是服务器选择发送的任何内容。
 * 它的价值可能只有服务器才感兴趣。
 * 创建之后，可以使用setValue方法更改cookie的值。
 */
public Cookie(String name, String value) {
	validation.validate(name);
	this.name = name;
	this.value = value;
}
</code></pre> 
<p>向浏览器添加 Cookie： </p> 
<p><img alt="" height="210" src="https://images2.imgbox.com/31/67/Xkysiwto_o.png" width="729"></p> 
<pre><code>/**
 * 添加Cookie到响应中。此方法可以多次调用，用以添加多个Cookie。
 */
public void addCookie(Cookie cookie);</code></pre> 
<p>获取客户端 Cookie：</p> 
<p><img alt="" height="205" src="https://images2.imgbox.com/3e/46/PsqQ8zjP_o.png" width="734"></p> 
<pre><code>/**
 * 这是HttpServletRequest中的方法。
 * 它返回一个Cookie的数组，包含客户端随此请求发送的所有Cookie对象。
 * 如果没有符合规则的cookie，则此方法返回null。
 */
 public Cookie[] getCookies();
</code></pre> 
<p><strong>4）Cookie 的 Path ：客户浏览器何时带 cookie 到服务器端，何时不带</strong></p> 
<p>需求说明：</p> 
<p>创建一个 Cookie，设置 Cookie 的 path，通过不同的路径访问，从而查看请求携带 Cookie 的情况。</p> 
<p>案例目的：</p> 
<p>通过此案例的讲解，可以清晰的描述出，客户浏览器何时带 cookie 到服务器端，何时不带。</p> 
<p>案例步骤：</p> 
<p>第一步：编写 Servlet。</p> 
<ol><li>在 demo1 中写一个 cookie 到客户端</li><li>在 demo2 和 demo3 中分别去获取 cookie 
  <ul><li>demo1 的 Servlet 映射是 /servlet/PathQuestionDemo1</li><li>demo2 的 Servlet 映射是 /servlet/PathQuestionDemo2</li><li>demo3 的 Servlet 映射是 /PathQuestionDemo3</li></ul></li></ol> 
<pre><code>/**
 * 写一个 cookie 到客户端
 */
public class PathQuestionDemo1 extends HttpServlet {

	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		// 1.创建一个Cookie
		Cookie cookie = new Cookie("pathquestion", "CookiePathQuestion");
		// 2.设置cookie的最大存活时间
		cookie.setMaxAge(Integer.MAX_VALUE);
		// 3.把cookie发送到客户端
		response.addCookie(cookie);  // setHeader("Set-Cookie", "cookie的值")
	}

	public void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		doGet(request, response);
	}
}
</code></pre> 
<pre><code>/**
 * 获取Cookie，名称是pathquestion
 */
public class PathQuestionDemo2 extends HttpServlet {

	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		// 1.获取所有的cookie
		Cookie[] cs = request.getCookies();
		// 2.遍历cookie的数组
		for(int i=0; cs!=null &amp;&amp; i&lt;cs.length; i++){
			if("pathquestion".equals(cs[i].getName())){
				// 找到了我们想要的cookie，输出cookie的值
				response.getWriter().write(cs[i].getValue());
				return;
			}
		}
	}

	public void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		doGet(request, response);
	}
}
</code></pre> 
<pre><code>/**
 * 获取Cookie，名称是pathquestion
 */
public class PathQuestionDemo3 extends HttpServlet {

	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		// 1.获取所有的cookie
		Cookie[] cs = request.getCookies();
		// 2.遍历cookie的数组
		for(int i=0;cs!=null &amp;&amp; i&lt;cs.length;i++){
			if("pathquestion".equals(cs[i].getName())){
				// 找到了我们想要的cookie，输出cookie的值
				response.getWriter().write(cs[i].getValue());
				return;
			}
		}
	}

	public void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		doGet(request, response);
	}
}
</code></pre> 
<p>第二步：配置 Servlet。</p> 
<pre><code>&lt;!-- Demo1：设置Cookie --&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;PathQuestionDemo1&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.web.servlet.pathquestion.PathQuestionDemo1&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;PathQuestionDemo1&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/servlet/PathQuestionDemo1&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;!-- Demo2：获取Cookie --&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;PathQuestionDemo2&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.web.servlet.pathquestion.PathQuestionDemo2&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;PathQuestionDemo2&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/servlet/PathQuestionDemo2&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;!-- Demo3：获取Cookie --&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;PathQuestionDemo3&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.web.servlet.pathquestion.PathQuestionDemo3&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;PathQuestionDemo3&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/PathQuestionDemo3&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre> 
<p>测试结果：</p> 
<p>通过分别运行 PathQuestionDemo1，2 和 3 这三个 Servlet，我们发现由 demo1 写的 Cookie，在 demo2 中可以取到，但是到了 demo3 中就无法获取了。</p> 
<p><img alt="" height="480" src="https://images2.imgbox.com/a9/50/FPynUtRJ_o.png" width="1015"></p> 
<p><img alt="" height="571" src="https://images2.imgbox.com/ca/3c/vdEjZ1q9_o.png" width="1028"></p> 
<p><img alt="" height="543" src="https://images2.imgbox.com/c3/45/9608avGO_o.png" width="1027"></p> 
<p>路径问题的分析及总结：</p> 
<p><strong>问题</strong>：demo2 和 demo3 谁能取到 Cookie？</p> 
<p><strong>答案</strong>：demo2 能取到，demo3 取不到。</p> 
<p><strong>分析：</strong></p> 
<ol><li>首先，我们要知道如何确定一个 cookie ？那就是使用 cookie 的三个属性组合：<code>domain + path + name</code>。</li><li>这里面，同一个应用的domain是一样的，在我们的案例中都是 localhost。并且，我们取的都是同一个 cookie，所以 name 也是一样的，都是 pathquestion。</li><li>那么，不一样的只能是 path 了。但是示例中没有设置过 cookie 的 path 属性，这就表明 path 是有默认值的。</li><li>接下来，我们打开这个 cookie 来看一看，在 IE 浏览器访问一次 PathQuestionDemo1 这个 Servlet：</li></ol> 
<p><img alt="" height="651" src="https://images2.imgbox.com/11/d2/TFmSGUxO_o.png" width="807"></p> 
<p>我们是通过 demo1 写的 cookie，demo1 的访问路径是 <a href="http://localhost:9090/servlet/PathQuestionDemo1" rel="nofollow" title="http://localhost:9090/servlet/PathQuestionDemo1">http://localhost:9090/servlet/PathQuestionDemo1</a> 。通过比较两个路径：请求资源地址和 cookie 的 path，可以看出：cookie 的 path 默认值是 <code>URI 中去掉资源的部分</code>。</p> 
<p>在上述案例中：</p> 
<table><thead><tr><th>访问 URL</th><th>URI 部分</th><th>Cookie 的 Path</th><th>是否携带 Cookie</th><th>能否取到 Cookie</th></tr></thead><tbody><tr><td><a href="http://localhost:9090/servlet/PathQuestionDemo2" rel="nofollow" title="http://localhost:9090/servlet/PathQuestionDemo2">http://localhost:9090/servlet/PathQuestionDemo2</a></td><td>/servlet/PathQuestionDemo2</td><td>/servlet/</td><td>带</td><td>能取到</td></tr><tr><td><a href="http://localhost:9090/PathQuestionDemo3" rel="nofollow" title="http://localhost:9090/PathQuestionDemo3">http://localhost:9090/PathQuestionDemo3</a></td><td>/PathQuestionDemo3</td><td>/servlet/</td><td>不带</td><td>不能取到</td></tr></tbody></table> 
<p>总结：客户端什么时候带 cookie 到服务器，什么时候不带？</p> 
<ul><li>就是看 URI 和 cookie 的 path 比较。</li><li><code>URI.startWith(cookie 的 path)</code>：如果返回的是 true 就带，如果返回的是 false 就不带。</li></ul> 
<p><strong>3. 服务端会话管理技术：Session</strong></p> 
<p id="httpsession-对象概述"><strong>1）HttpSession 对象概述</strong></p> 
<p>HttpSession 是 Servlet 规范中提供的一个接口。该接口的实现由 Servlet 规范的实现提供商提供。</p> 
<p>由于 Tomcat 服务器对 Servlet 规范进行了实现，所以 HttpSession 接口的实现由 Tomcat 提供。该对象用于提供一种通过多个页面请求或访问网站，来标识用户并存储有关该用户的信息的方法。简单说它就是一个服务端的会话对象，用于存储用户的会话数据。</p> 
<p>同时，它也是 Servlet 规范中四大域对象之一的会话域对象。并且它也是用于实现数据共享的，但它与前面介绍的应用域和请求域是有区别的。</p> 
<table><thead><tr><th>域对象</th><th>作用范围</th><th>使用场景</th></tr></thead><tbody><tr><td>ServletContext</td><td>整个应用范围</td><td>当前项目中需要数据共享时，可以使用此域对象。</td></tr><tr><td>ServletRequest</td><td>当前请求范围</td><td>在请求或者当前请求转发时需要数据共享可以使用此域对象。</td></tr><tr><td>HttpSession</td><td>会话返回</td><td>在当前会话范围中实现数据共享；可以在多次请求中实现数据共享。</td></tr></tbody></table> 
<p><strong>2）HttpSession 对象的获取</strong></p> 
<p>HttpSession 的获取是通过 HttpServletRequest 接口中的两个方法获取的，如下图所示：</p> 
<p><img alt="" height="601" src="https://images2.imgbox.com/e1/6f/8FAGlO4e_o.png" width="754"></p> 
<p>两个方法的区别： </p> 
<p><img alt="" height="1047" src="https://images2.imgbox.com/87/de/0I5iuojT_o.png" width="935"></p> 
<p><strong>3）HttpSession 常用方法</strong></p> 
<p><img alt="" height="1180" src="https://images2.imgbox.com/cf/8e/zAtrh7Ns_o.png" width="1200"></p> 
<p><strong>4）HttpSession 入门案例</strong></p> 
<p>需求说明：</p> 
<p>在请求 HttpSessionDemo1 这个 Servlet 时，携带用户名信息，并且把信息保存到会话域中，然后从 HttpSessionDemo2 这个 Servlet 中获取登录信息。</p> 
<p>案例目的：</p> 
<p>通过本案例认识到会话域的作用，即多次请求间的数据共享。因为是两次请求，请求域肯定不一样了，所以不能用请求域实现。</p> 
<p>最终掌握 HttpSession 对象的获取和使用。</p> 
<p>原理分析：</p> 
<p>HttpSession 虽然是服务端会话管理技术的对象，但它本质仍是一个 Cookie，是一个由服务器自动创建的特殊的 Cookie，Cookie 的名称是 JSESSIONID，其值是服务器分配的一个唯一的标识。</p> 
<p>当我们使用 HttpSession 时，浏览器在没有禁用 Cookie 的情况下，都会把这个 Cookie 带到服务器端，然后根据唯一标识去查找对应的 HttpSession 对象，找到了，我们就可以直接使用了。</p> 
<p>下图就是入门案例中，HttpSession 分配的唯一标识，可以看到两次请求的 JSESSIONID 的值是一样的：</p> 
<p><img alt="" height="1110" src="https://images2.imgbox.com/b7/3f/m1BT5bsr_o.png" width="1178"></p> 
<p><strong>5）HttpSession 的钝化和活化</strong></p> 
<p>什么是持久态？</p> 
<ul><li> <p>把长时间不用，但还不到过期时间的 HttpSession 进行序列化，写到磁盘上。</p> </li><li> <p>我们把 HttpSession 持久态也叫做钝化（与钝化相反的，我们叫活化）。</p> </li></ul> 
<p>什么时候使用持久化？</p> 
<ul><li> <p>第一种情况：当访问量很大时，服务器会根据 getLastAccessTime 来进行排序，对长时间不用，但是还没到过期时间的 HttpSession 进行持久化。</p> </li><li> <p>第二种情况：当服务器进行重启的时候，为了保持客户 HttpSession 中的数据，也要对 HttpSession 进行持久化。</p> </li></ul> 
<p>注意：</p> 
<ul><li> <p>HttpSession 的持久化由服务器来负责管理，我们不用关心。</p> </li><li> <p>只有实现了序列化接口的类才能被序列化，否则不行。</p> </li></ul> 
<h3>四、JSP、EL 表达式、JSTL </h3> 
<h4>1、JSP概述</h4> 
<p><strong>1. JSP 简介</strong></p> 
<p>JSP 全称是 Java Server Page，它和 Servlet 一样，也是 Sun 公司推出的一套开发动态 web 资源的技术，称为 JSP/Servlet 规范。</p> 
<p>JSP 的本质其实就是一个 Servlet。</p> 
<p><strong>2. JSP 与 Servlet 的区别</strong></p> 
<ol><li> <p>JSP 经编译后就变成了 Servlet（JSP 的本质就是 Servlet，JVM 只能识别 Java 的类，不能识别 JSP 的代码，于是 Web 容器将 JSP 的代码编译成 JVM 能够识别的 Java类）。</p> </li><li> <p>Servlet 和 JSP 最主要的不同点在于：Servlet 的应用逻辑在 Java 文件中，并且完全从表示层中的 HTML 里分离开来。而对于 JSP，Java 和 HTML 可以组合成一个扩展名为 .jsp 的文件。</p> </li><li> <p>JSP 是 Servlet 的一种简化，使用 JSP 只需要完成输出到客户端的内容（JSP 中的 Java 脚本如何镶嵌到一个类中，由 JSP 容器完成）；而 Servlet 则是个完整的 Java 类，这个类的 service() 方法用于生成对客户端的响应。</p> </li><li> <p>JSP 更擅长于页面显示（视图），Servlet 更擅长于逻辑控制。</p> </li><li> <p>Servlet 中没有内置对象，JSP 中的内置对象都必须通过 HttpServletRequest 对象、 HttpServletResponse 对象以及 HttpServlet 对象得到。</p> </li></ol> 
<p id="jsphtmlservlet-适用场景"><strong>3. JSP、HTML、Servlet 适用场景</strong></p> 
<table><thead><tr><th>类别</th><th>适用场景</th></tr></thead><tbody><tr><td>HTML</td><td>只能开发静态资源，不能包含 java 代码，无法添加动态数据。</td></tr><tr><td>Servlet</td><td>写 java 代码，可以输出页面内容，但是不够方便，开发效率低。</td></tr><tr><td>JSP</td><td>包括了 HTML 的展示技术，同时具备 Servlet 输出动态资源的能力；但是不适合作为控制器来用。</td></tr></tbody></table> 
<p><strong>4. JSP 简单入门</strong></p> 
<p>创建 JavaWeb 工程：</p> 
<p><img alt="" height="283" src="https://images2.imgbox.com/a1/8a/QAf5JCxL_o.png" width="419"></p> 
<p>在 index.jsp 中编写内容： </p> 
<pre><code>&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;JSP的入门&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
      这是第一个JSP页面
  &lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>测试运行：</p> 
<p><img alt="" height="275" src="https://images2.imgbox.com/01/0c/2Cowmdyv_o.png" width="489"></p> 
<p><strong>5. JSP 执行详解</strong></p> 
<p>JSP 就是一个特殊的 Servlet，其<strong>执行过程</strong>如下：</p> 
<ol><li>客户端提交请求；</li><li>Tomcat 服务器解析请求地址；</li><li>找到 JSP 页面；</li><li>Tomcat 将 JSP 页面翻译成 Servlet 的 java 文件；</li><li>将翻译好的 .java 文件编译成 .class 文件；</li><li>返回到客户端浏览器上。</li></ol> 
<p>JSP 的 .java 文件内容分析：</p> 
<p>当我们打开 index.jsp 翻译的 java 文件看到的就是public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase类的声明，接着我们在 Tomcat 的源码中找到该类的声明，如下图：</p> 
<p><img alt="" height="437" src="https://images2.imgbox.com/02/f0/4lTCty4j_o.png" width="805"></p> 
<p>该图表明我们写的 JSP 的本质就是一个 HttpServlet：</p> 
<p><img alt="" height="433" src="https://images2.imgbox.com/95/1b/mUUQ1SoP_o.png" width="1200"></p> 
<p>同时，我们在 index_jsp.java 文件中找到了输出页面的代码，并且在浏览器端查看源文件，看到的内容是一样的。这也就是说明，我们的浏览器上的内容，在通过 JSP 展示时，本质都是用 out.write() 输出出来的。</p> 
<p>至此，我们应该清楚地认识到，JSP 是一个特殊的 Servlet，主要是<code>用于展示动态数据</code>。它展示的方式是用流把数据输出。而我们在使用 JSP 时，涉及的 HTML 部分，都与 HTML 的用法一致，这部分称为 JSP 中的模板元素，在开发过程中，先写好这些模板元素，因为它们决定了页面的外观。</p> 
<h4>2、JSP语法</h4> 
<p><strong>1. Java 代码块</strong></p> 
<p>在 JSP 中，可以使用 java 脚本代码，形式为：<code>&lt;% 此处写java代码 %&gt;</code>。</p> 
<p>但是在实际开发中，极少使用此种形式编写 java 代码。同时需要注意的是：</p> 
<pre><code>&lt;%
	在里面写java程序脚本，需要注意：这里面的内容由tomcat负责翻译，翻译之后是service方法的成员变量
%&gt;</code></pre> 
<p>示例：</p> 
<pre><code>&lt;!--Java代码块--&gt;
&lt;% out.println("这是Java代码块");%&gt;
&lt;hr/&gt;</code></pre> 
<p><strong>2. JSP 表达式</strong></p> 
<p>在 JSP 中，可以使用特定表达式语法，形式为：<code>&lt;%=表达式%&gt;</code>。</p> 
<p>JSP 在翻译完后是<code>out.print(表达式内容);</code>，所以<code>&lt;%out.print("当前时间);%&gt;</code>和<code>&lt;%="当前时间"%&gt;</code>是等价的。</p> 
<p>在实际开发中，这种表达式语法用的也很少。</p> 
<p>示例：</p> 
<pre><code>&lt;!--JSP表达式--&gt;
&lt;%="这是JSP表达式"%&gt;&lt;br/&gt;
就相当于&lt;br/&gt;
&lt;%out.println("这是没有JSP表达式输出的");%&gt;</code></pre> 
<p><strong>3. JSP 声明</strong></p> 
<p>在 JSP 中也可以声明一些变量、方法、静态方法，形式为：<code>&lt;%! 声明的内容 %&gt;</code>。</p> 
<p>使用 JSP 声明时需要注意：</p> 
<pre><code>&lt;%! 
	需要注意的是：写在里面的内容将会被tomcat翻译成全局的属性或者类方法
%&gt;       </code></pre> 
<p>示例：</p> 
<pre><code>&lt;!--JSP声明--&gt;
&lt;%! String str = "声明语法格式";%&gt;
&lt;%=str%&gt;</code></pre> 
<p><strong>4. JSP 注释</strong></p> 
<p>在使用 JSP 时，它也有自己的注释，形式为：<code>&lt;%--注释--%&gt;</code>。</p> 
<p>需要注意的是：</p> 
<ul><li> <p>在 JSP 中可以使用 HTML 的注释，但是只能注释 HTML 元素，不能注释 Java 程序片段和表达式。同时，被 HTML 注释部分会参与翻译，并且会在浏览器上显示。</p> </li><li> <p>JSP 的注释不仅可以注释 Java 程序片段，也可以注释 HTML 元素，并且被 JSP 注释的部分不会参与翻译成 .java 文件，也不会在浏览器上显示。</p> </li></ul> 
<p>示例：</p> 
<pre><code>&lt;%--JSP注释--%&gt;
&lt;!--HTML注释--&gt;</code></pre> 
<p><strong>5. 语法示例</strong></p> 
<pre><code>&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;JSP语法&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;!--Java代码块--&gt;
&lt;% out.println("这是Java代码块");%&gt;
&lt;hr/&gt;

&lt;!--JSP表达式--&gt;
&lt;%="这是JSP表达式"%&gt;&lt;br/&gt;
就相当于&lt;br/&gt;
&lt;%out.println("这是没有JSP表达式输出的");%&gt;

&lt;hr/&gt;
&lt;!--JSP声明--&gt;
&lt;%! String str = "声明语法格式";%&gt;
&lt;%=str%&gt;

&lt;hr/&gt;

&lt;%--JSP注释--%&gt;
&lt;!--HTML注释--&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>JSP 语法运行结果：</p> 
<p><img alt="" height="499" src="https://images2.imgbox.com/1a/b4/zEkWwHkg_o.png" width="531"></p> 
<h4>3、JSP指令</h4> 
<p><strong>1. page 指令</strong></p> 
<p><code>language</code>：告知引擎，脚本使用的是 Java。默认是 Java，不写也行。</p> 
<p><code>extends</code>：告知引擎，JSP 对应的 Servlet 的父类是哪个，不需要写，也不需要改。</p> 
<p><code>import</code>：告知引擎，导入哪些包（类）。</p> 
<p>注意：引擎会自动导入：java.lang.*, javax.servlet.*, javax.servlet.http.*, javax.servlet.jsp.*</p> 
<p>导入的语法：</p> 
<pre><code>&lt;%@pageimport=”java.util.Date, java.util.UUID”%&gt;</code></pre> 
<p>或者：</p> 
<pre><code>&lt;%@pageimport=”java.util.Date”%&gt;
&lt;%@pageimport=”java.util.UUID”%&gt;</code></pre> 
<p>Eclipse 自动导入：Alt + /</p> 
<p><strong><code>session</code></strong>：告知引擎是否产生 HttpSession 对象，即是否在代码中调用 request.getSession()。默认是 true。</p> 
<p><strong><code>buffer</code></strong>：JspWriter 用于输出 JSP 内容到页面上。告知引擎，设定他的缓存大小。默认 8kb。</p> 
<p><strong><code>errorPage</code></strong>：告知引擎，当前页面出现异常后，应该转发到哪个页面上（路径写法：/代表当前应用）。</p> 
<ul><li>当在 errorPage 上使用了 isErrorPage=true 之后，IE8 有时候不能正常显示。</li><li>配置全局错误页面：web.xml。</li><li>当使用了全局错误页面，就无须再写 errorPage 来实现转到错误页面，而是由服务器负责跳转到错误页面。</li></ul> 
<pre><code>&lt;error-page&gt;    
    &lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt;    			
    &lt;location&gt;/error.jsp&lt;/location&gt;
&lt;/error-page&gt;

&lt;error-page&gt;
    &lt;error-code&gt;404&lt;/error-code&gt;
    &lt;location&gt;/404.html&lt;/location&gt;
&lt;/error-page&gt;   </code></pre> 
<p><strong><code>isErrorPage</code></strong>：告知引擎，是否抓住异常。如果该属性为 true，页面中就可以使用 exception 对象，打印异常的详细信息。默认值是 false。</p> 
<p><strong><code>contentType</code></strong>：告知引擎，响应正文的 MIME 类型。</p> 
<ul><li>contentType="text/html;charset=UTF-8" 相当于 response.setContentType("text/html;charset=UTF-8");</li></ul> 
<p><strong><code>pageEncoding</code></strong>：告知引擎，翻译 JSP 时（从磁盘上读取 JSP 文件）所用的码表。</p> 
<ul><li>pageEncoding="UTF-8" 相当于告知引擎用 UTF-8 读取 JSP 。</li></ul> 
<p><strong><code>isELIgnored</code></strong>：告知引擎，是否忽略 EL 表达式，默认值是 false，不忽略。</p> 
<p><strong>2. include 指令</strong></p> 
<p>语法：&lt;%@include file="" %&gt;，该指令表示包含外部页面。</p> 
<ul><li>file 属性以<code>/</code>开头，表示当前应用。</li></ul> 
<p>使用示例：</p> 
<p><img alt="" height="332" src="https://images2.imgbox.com/c5/cc/F4m8osgH_o.png" width="1053"></p> 
<p>静态包含 .java 文件内容： </p> 
<p><img alt="" height="578" src="https://images2.imgbox.com/d5/6d/LDUpmVIL_o.png" width="352"></p> 
<p><strong>3. aglib 指令</strong></p> 
<p>语法：<code>&lt;%taglib uri="" prefix=""%&gt;</code></p> 
<p>作用：该指令用于引入外部标签库（html 标签和 jsp 标签无需引入）。</p> 
<p>属性：</p> 
<ul><li>uri：外部标签的 URI 地址。</li><li>prefix：使用标签时的前缀。</li></ul> 
<h4>4、JSP对象</h4> 
<p><strong>1. 九大隐式对象</strong></p> 
<p>什么是隐式对象呢？它指的是在 JSP 中，可以不声明就直接使用的对象。它只存在于 JSP 中，因为 Java 类中的变量必须要先声明再使用。</p> 
<p>其实 JSP 中的隐式对象也并非是未声明，只是它是在翻译成 .java 文件时声明的，所以我们可以在 JSP 中直接使用。</p> 
<table><thead><tr><th>隐式对象名称</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>request</td><td>javax.servlet.http.HttpServletRequest</td><td></td></tr><tr><td>response</td><td>javax.servlet.http.HttpServletResponse</td><td></td></tr><tr><td>session</td><td>javax.servlet.http.HttpSession</td><td>page 指令可以控制开关</td></tr><tr><td>application</td><td>javax.servlet.ServletContext</td><td></td></tr><tr><td>page</td><td>Java.lang.Object</td><td>当前 JSP 对应的 servlet 引用实例</td></tr><tr><td>config</td><td>javax.servlet.ServletConfig</td><td></td></tr><tr><td>exception</td><td>java.lang.Throwable</td><td>page 指令可以控制开关</td></tr><tr><td>out</td><td>javax.servlet.jsp.JspWriter</td><td>字符输出流，相当于 printwriter</td></tr><tr><td>pageContext</td><td>javax.servlet.jsp.PageContext</td><td>重要</td></tr></tbody></table> 
<p><strong>2. ageContext 对象</strong></p> 
<p>它是 JSP 独有的对象，Servlet 中没有这个对象。</p> 
<p>ageContext 本身也是一个域（作用范围）对象，但是它可以操作其他 3 个域对象中的属性，而且还可以获取其他 8 个隐式对象。</p> 
<p>生命周期：</p> 
<p>它是一个局部变量，所以它的生命周期随着 JSP 的创建而开始，随着 JSP 的结束而消失。每个 JSP 页面都有一个独立的 PageContext。</p> 
<p>常用方法：</p> 
<p><img alt="" height="1030" src="https://images2.imgbox.com/80/94/QgqQZpvj_o.png" width="1200"></p> 
<p><strong>3. 四大域对象</strong></p> 
<table><thead><tr><th>域对象名称</th><th>范围</th><th>级别</th><th>备注</th></tr></thead><tbody><tr><td>PageContext</td><td>页面范围</td><td>最小，只能在当前页面用</td><td>因范围太小，开发使用较少</td></tr><tr><td>ServletRequest</td><td>请求范围</td><td>一次请求或当前请求转发用</td><td>当请求转发之后，再次转发时请求域丢失。开发使用较多</td></tr><tr><td>HttpSession</td><td>会话范围</td><td>多次请求数据共享时使用</td><td>多次请求共享数据，但不同的客户端不能共享。。如存放用户的登录信息、购物车功能。开发使用较多</td></tr><tr><td>ServletContext</td><td>应用范围</td><td>最大，整个应用都可以使用</td><td>因范围太大，尽量少用。如果对数据有修改则需要做同步处理</td></tr></tbody></table> 
<h4>5、MVC模型</h4> 
<p>MVC 模型：</p> 
<ul><li> <p><code>M（model，模型）</code>：通常用于封装数据模型（实体类）。</p> </li><li> <p><code>V（view，视图）</code>：通常用于展示数据。动态展示用 JSP 页面，静态数据展示用 HTML。</p> 
  <ul><li><strong>JSP</strong> 擅长显示界面，不擅长处理程序逻辑。在 Web 开发中多用于展示动态界面。</li></ul></li><li> <p><code>C（controller，控制器）</code>：通常用于处理请求和响应。一般指的是 Servlet。</p> 
  <ul><li><strong>Servlet</strong> 擅长处理业务逻辑，不擅长输出显示界面。在 Web 开发中多用于控制程序逻辑（流程）。</li></ul></li></ul> 
<p><img alt="" height="531" src="https://images2.imgbox.com/0b/40/pBOaRrOE_o.png" width="665"></p> 
<h4>6、JSP综合案例</h4> 
<p><strong>1. 登录功能</strong></p> 
<p>index.jsp：主页。</p> 
<pre><code>&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;首页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;%--
        获取会话域的数据
        如果获取到了，则显示添加和查询功能
        如果获取不到，则显示登录功能
    --%&gt;
    &lt;% Object username = session.getAttribute("username");
            if(username == null || "".equals(username)){
    %&gt;
            &lt;a href="/web_demo/login.jsp"&gt;登录&lt;a/&gt;
    &lt;%}else { %&gt;
            &lt;a href="/web_demo/add.jsp"&gt;添加&lt;a/&gt;
            &lt;a href="/web_demo/queryServlet"&gt;查询&lt;a/&gt;
    &lt;% } %&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>login.jsp：登录页。</p> 
<pre><code>&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;登录页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action="/web_demo/loginServlet" method="get" autocomplete="off"&gt;
        姓名：&lt;input type="text" name="username"&gt;&lt;br/&gt;
        密码：&lt;input type="password" name="password"&gt;&lt;br/&gt;
        &lt;button type="submit"&gt;登录&lt;/button&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>LoginServlet：获取登录页的用户名和密码。</p> 
<pre><code>package com.demo;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/loginServlet")
public class LoginServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 获取用户名和密码
        String username = req.getParameter("username");
        String password = req.getParameter("password");

        // 校验用户名密码
        // 用户名为空
        if("".equals(username) || username == null){
            // 重定向到登录页
            resp.sendRedirect("/web_demo/login.jsp");
        } else {
            // 用户名不为空，存入会话域数据
            req.getSession().setAttribute("username", username);
            // 重定向到首页
            resp.sendRedirect("/web_demo/index.jsp");
        }
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.doGet(req, resp);
    }
}
</code></pre> 
<p><strong>2. 添加功能</strong></p> 
<p>add.jsp：实现添加学生信息的表单项。</p> 
<pre><code>&lt;%--
  Created by IntelliJ IDEA.
  User: juno
  Date: 2021/10/7
  Time: 21:18
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;添加页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action="/web_demo/addServlet" method="get" autocomplete="off"&gt;
        学生姓名：&lt;input type="text" name="username"&gt;&lt;br/&gt;
        学生年龄：&lt;input type="number" name="age"&gt;&lt;br/&gt;
        学生成绩：&lt;input type="number" name="score"&gt;&lt;br/&gt;
        &lt;button type="submit"&gt;保存&lt;/button&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>AddServlet：获取学生信息并保存到文件中。</p> 
<pre><code>package com.demo;

import com.demo.bean.Student;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

@WebServlet("/addServlet")
public class AddServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 获取表单数据
        String username = req.getParameter("username");
        String age = req.getParameter("age");
        String score = req.getParameter("score");

        // 创建学生对象并赋值
        Student student = new Student();
        student.setAge(age);
        student.setScore(score);
        student.setUsername(username);

        // 将新增数据写入文件中
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter("d://student.txt", true));
        bufferedWriter.write(username+","+age+","+score);
        bufferedWriter.newLine();
        bufferedWriter.close();

        // 通过定时刷新功能响应给浏览器
        resp.setContentType("text/html;charset=UTF-8");
        resp.getWriter().write("添加成功！2秒后自动跳转到首页~");
        resp.setHeader("Refresh", "2;URL=/web_demo/index.jsp");
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.doGet(req, resp);
    }
}
</code></pre> 
<p><strong>3. 查看功能</strong></p> 
<p>QueryServlet：读取文件中的学生信息到集合中。</p> 
<pre><code>package com.demo;

import com.demo.bean.Student;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

@WebServlet("/queryServlet")
public class QueryServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 创建字符输入流对象，关联读取的文件
        BufferedReader bufferedReader = new BufferedReader(new FileReader("d://student.txt"));

        // 创建集合对象，用于保存student对象
        ArrayList&lt;Student&gt; arrayList = new ArrayList&lt;&gt;();

        // 循环读取文件中的数据，将数据封装到Student对象中。再把多个学生对象添加到集合中
        String line;
        while((line = bufferedReader.readLine()) != null){
            Student student = new Student();
            String[] attribute = line.split(",");
            student.setUsername(attribute[0]);
            student.setAge(attribute[1]);
            student.setScore(attribute[2]);
            arrayList.add(student);
        }

        // 将集合对象存入会话域中
        req.getSession().setAttribute("students", arrayList);

        // 重定向到学生列表页面
        resp.sendRedirect("/web_demo/query.jsp");
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.doGet(req, resp);
    }
}
</code></pre> 
<p>query.jsp：展示学生信息列表。</p> 
<pre><code>&lt;%--
  Created by IntelliJ IDEA.
  User: juno
  Date: 2021/10/7
  Time: 23:41
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page import="com.demo.bean.Student" %&gt;
&lt;%@ page import="java.util.ArrayList" %&gt;
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;学生列表页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;table width="600px" border="1px"&gt;
    &lt;tr&gt;
      &lt;th&gt;学生姓名&lt;/th&gt;
      &lt;th&gt;学生年龄&lt;/th&gt;
      &lt;th&gt;学生成绩&lt;/th&gt;
    &lt;/tr&gt;
      &lt;% ArrayList&lt;Student&gt; students = (ArrayList&lt;Student&gt;) session.getAttribute("students");
          for(Student student: students){
      %&gt;
          &lt;tr align="center"&gt;
            &lt;td&gt;&lt;%= student.getUsername() %&gt;&lt;/td&gt;
            &lt;td&gt;&lt;%= student.getAge() %&gt;&lt;/td&gt;
            &lt;td&gt;&lt;%= student.getScore() %&gt;&lt;/td&gt;
          &lt;tr/&gt;
      &lt;%  } %&gt;
  &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>页面效果如下：</p> 
<p><img alt="" height="71" src="https://images2.imgbox.com/78/53/zNjfkN0f_o.png" width="444"></p> 
<h4><strong>7、EL表达式</strong></h4> 
<p><strong>1. EL 表达式介绍</strong></p> 
<p>基本概念：</p> 
<p>EL 表达式，全称是 Expression Language，意为表达式语言。它是 Servlet 规范中的一部分，是 JSP2.0 规范加入的内容。</p> 
<p>其作用是用于在 JSP 页面中获取数据，从而让我们的 JSP 脱离 Java 代码块和 JSP 表达式。</p> 
<p><strong>1）基本语法</strong></p> 
<p>EL 表达式的语法格式非常简单：${表达式内容}。</p> 
<p>假定我们在请求域中存入了一个名称为 "message" 的数据，此时在 JSP 中获取的方式如下：</p> 
<pre><code>&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;EL表达式入门案例&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;%--使用java代码在请求域中存入一个名称为message的数据--%&gt;
    &lt;% request.setAttribute("message","Expression Language"); %&gt;

    Java代码块获取：&lt;% out.print(request.getAttribute("message")); %&gt;
    &lt;br/&gt;
    JSP表达式获取：&lt;%= request.getAttribute("message") %&gt;
    &lt;br/&gt;
    EL表达式获取：${message}
  &lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>可以看出，有多种方式可以从请求域中获取数据，但是 EL 表达式写起来是最简单的方式。这也是以后我们在实际开发中，当使用 JSP 作为视图时，绝大多数都会采用的方式。</p> 
<p id="el-表达式注意事项"><strong>2）EL 表达式注意事项</strong></p> 
<p>EL 表达式没有空指针异常、没有数组下标越界、没有字符串拼接。</p> 
<pre><code>&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;EL表达式的注意事项&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;%-- EL表达式的三个没有 --%&gt;
    第一个：没有空指针异常&lt;br/&gt;
    &lt;% String str = null;
       request.setAttribute("testNull",str);
    %&gt;
    ${testNull}
    &lt;hr/&gt;
    第二个：没有数组下标越界&lt;br/&gt;
    &lt;% String[] strs = new String[]{"a","b","c"};
       request.setAttribute("strs",strs);
    %&gt;
    取第一个元素：${strs[0]}&lt;br/&gt;
    取第六个元素：${strs[5]}
    &lt;hr/&gt;
    第三个：没有字符串拼接&lt;br/&gt;
    &lt;%--${strs[0]+strs[1]}--%&gt;
    ${strs[0]}+${strs[1]}
  &lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>运行效果：</p> 
<p><img alt="" height="145" src="https://images2.imgbox.com/5a/07/iZiZSjxd_o.png" width="163"></p> 
<p><strong>3）EL 表达式的数据来源</strong></p> 
<p>EL 表达式只能从四大域中获取数据，调用的就是<code>findAttribute(name,value);</code>方法，通过名称根据范围由小到大逐个域中查找，找到就返回，找不到就什么都不显示。</p> 
<p>它可以获取对象，可以是对象中关联的其他对象，可以是一个 List 集合，也可以是一个 Map 集合。</p> 
<p><strong>使用</strong>：创建两个实体类（User 和 Address）并使用 EL 表达式获取输出</p> 
<ul><li>User 实体类</li></ul> 
<pre><code>public class User implements Serializable{

    private String name = "黑马";
    private int age = 18;
    private Address address = new Address();
    
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public Address getAddress() {
        return address;
    }
    public void setAddress(Address address) {
        this.address = address;
    }    
}
</code></pre> 
<ul><li>Address 实体类</li></ul> 
<pre><code>public class Address implements Serializable {

    private String province = "北京";
    private String city = "昌平区";

    public String getProvince() {
        return province;
    }
    public void setProvince(String province) {
        this.province = province;
    }
    public String getCity() {
        return city;
    }
    public void setCity(String city) {
        this.city = city;
    }
}</code></pre> 
<ul><li>JSP</li></ul> 
<pre><code>&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;
&lt;%@ page import="com.itheima.domain.User" %&gt;
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;EL入门&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;%--
            EL表达式的数据获取：
                它只能在四大域对象中获取数据，不在四大域对象中的数据它取不到。
                它的获取方式就是findAttribute(String name)
         --%&gt;
         
         &lt;br/&gt;-----------获取对象数据---------------------&lt;br/&gt;
         &lt;% //1.把用户信息存入域中
             User user = new User();
             pageContext.setAttribute("u", user);
          %&gt;
          ${u}===============输出的是内存地址 &lt;%--相当于调用 &lt;%=pageContext.findAttribute("u")%&gt; --%&gt;&lt;br/&gt;
          ${u.name} &lt;%--相当于调用 &lt;% User user = (User) pageContext.findAttribute("u");out.print(user.getName());%&gt; --%&gt;&lt;br/&gt;
          ${u.age}
         
         &lt;br/&gt;-----------获取关联对象数据------------------&lt;br/&gt;
         ${u.address}==========输出的address对象的地址&lt;br/&gt;
         ${u.address.province}${u.address.city}&lt;br/&gt;
         ${u["address"]['province']}
         
         &lt;br/&gt;-----------获取数组数据---------------------&lt;br/&gt;
         &lt;% String[] strs = new String[]{"He", "llo", "Expression", "Language"}; 
             pageContext.setAttribute("strs", strs);
         %&gt;
         ${strs[0]}==========取的数组中下标为0的元素&lt;br/&gt;
         ${strs[3]}
         ${strs[5]}===========如果超过了数组的下标，则什么都不显示&lt;br/&gt;
         ${strs["2"]}=========会自动为我们转换成下标&lt;br/&gt;
         ${strs['1']}
         
         &lt;br/&gt;-----------获取List集合数据-----------------&lt;br/&gt;
         &lt;% List&lt;String&gt; list = new ArrayList&lt;String&gt;();
             list.add("AAA");
             list.add("BBB");
             list.add("CCC");
             list.add("DDD");
             pageContext.setAttribute("list", list);
          %&gt;
         ${list}&lt;br/&gt;
         ${list[0]}&lt;br/&gt;
         ${list[3]}&lt;br/&gt;
         
         &lt;br/&gt;-----------获取Map集合数据------------------&lt;br/&gt;
         &lt;% Map&lt;String,User&gt; map = new HashMap&lt;String,User&gt;();
             map.put("aaa", new User());
             pageContext.setAttribute("map", map);
          %&gt;
          ${map}&lt;br/&gt;
          ${map.aaa} &lt;%--获取map的value，是通过get(Key) --%&gt; &lt;br/&gt;
          ${map.aaa.name}${map.aaa.age}&lt;br/&gt;
          ${map["aaa"].name}
    &lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>运行效果：</p> 
<p><img alt="" height="512" src="https://images2.imgbox.com/4a/ab/JlXLqftg_o.png" width="568"></p> 
<p><strong>4）EL 表达式运算符</strong></p> 
<p><img alt="" height="165" src="https://images2.imgbox.com/a3/4c/DIISTNud_o.png" width="602"></p> 
<p>有两个特殊的运算符，使用方式如下： </p> 
<pre><code>&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;
&lt;%@ page import="com.itheima.domain.User" %&gt;
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;EL两个特殊的运算符&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;%-- empty运算符：
             它会判断：对象是否为null，字符串是否为空字符串，集合中元素是否是0个
        --%&gt;
        &lt;% String str = null;
          String str1 = "";
          List&lt;String&gt; slist = new ArrayList&lt;String&gt;();
          pageContext.setAttribute("str", str);
          pageContext.setAttribute("str1", str1);
          pageContext.setAttribute("slist", slist);
        %&gt;
        ${empty str}============当对象为null返回true&lt;br/&gt;
        ${empty str1}==========当字符串为空字符串是返回true(注意：它不会调用trim()方法)&lt;br&gt;
        ${empty slist}==========当集合中的元素是0个时，是true
        &lt;hr/&gt;
			
        &lt;%-- 三元运算符： 
             条件?真:假  
        --%&gt;
        &lt;% request.setAttribute("gender", "female"); %&gt;
        &lt;input type="radio" name="gender" value="male" ${gender eq "male"?"checked":""} &gt;男
        &lt;input type="radio" name="gender" value="female" ${gender eq "female"?"checked":""}&gt;女
    &lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>运行效果：</p> 
<p><img alt="" height="275" src="https://images2.imgbox.com/f4/96/4mLUrZuh_o.png" width="573"></p> 
<p><strong>5）EL 表达式的 11 个隐式对象</strong></p> 
<p>EL表达式除了能在四大域中获取数据，同时也为我们提供了隐式对象，可以让我们无需声明而直接使用，并且可以访问对象有返回值的方法。</p> 
<p>11 个对象见下表（需要注意的是，它和 JSP 的隐式对象不是一回事）：</p> 
<table><thead><tr><th>EL 中的隐式对象</th><th>类型</th><th>对应的 JSP 隐式对象</th><th>备注</th></tr></thead><tbody><tr><td>PageContext</td><td>Javax.serlvet.jsp.PageContext</td><td>PageContext</td><td>完全一样</td></tr><tr><td>ApplicationScope</td><td>Java.util.Map</td><td>没有</td><td>应用域范围的对象数据</td></tr><tr><td>SessionScope</td><td>Java.util.Map</td><td>没有</td><td>会话域范围的对象数据</td></tr><tr><td>RequestScope</td><td>Java.util.Map</td><td>没有</td><td>请求域范围的对象数据</td></tr><tr><td>PageScope</td><td>Java.util.Map</td><td>没有</td><td>页面域范围的对象数据</td></tr><tr><td>Header</td><td>Java.util.Map</td><td>没有</td><td>请求消息头 key，值是 value（一个）</td></tr><tr><td>HeaderValues</td><td>Java.util.Map</td><td>没有</td><td>请求消息头 key，值是数组（一个头多个值）</td></tr><tr><td>Param</td><td>Java.util.Map</td><td>没有</td><td>请求参数 key，值是 value（一个）</td></tr><tr><td>ParamValues</td><td>Java.util.Map</td><td>没有</td><td>请求参数 key，值是数组（一个名称多个值）</td></tr><tr><td>InitParam</td><td>Java.util.Map</td><td>没有</td><td>全局参数，key 是参数名称，value 是参数值</td></tr><tr><td>Cookie</td><td>Java.util.Map</td><td>没有</td><td>Key 是 cookie 的名称，value 是 cookie 对象</td></tr></tbody></table> 
<p>示例：</p> 
<pre><code>&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;EL表达式11个隐式对象&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;%-- applicationScope sessionScope requestScope pageScope 操作四大域对象中的数据 --%&gt;
    &lt;%--获取四大域对象中的数据--%&gt;
    &lt;%
       pageContext.setAttribute("username", "zhangsan");
       request.setAttribute("username", "zhangsan");
       session.setAttribute("username", "zhangsan");
       application.setAttribute("username", "zhangsan");
    %&gt;
    ${username} &lt;br&gt;
    ${requestScope.username} &lt;br&gt;

    &lt;%-- pageContext对象 可以获取其他三个域对象和JSP中八个隐式对象 --%&gt;
    &lt;%-- 获取虚拟目录名称 --%&gt;
    ${pageContext.request.contextPath} &lt;%-- 等价于 &lt;%= request.getContextPath() %&gt; --%&gt;

    &lt;%-- header headerValues  获取请求头数据 --%&gt;
    ${header["connection"]} &lt;br&gt;
    ${headerValues["connection"][0]} &lt;br&gt;

    &lt;%-- param paramValues 获取请求参数数据 --%&gt;
    ${param.username} &lt;br&gt;
    ${paramValues.hobby[0]} &lt;br&gt;
    ${paramValues.hobby[1]} &lt;br&gt;

    &lt;%-- initParam 获取全局配置参数 --%&gt;
    ${initParam["pname"]}  &lt;br&gt;

    &lt;%-- cookie 获取cookie信息 --%&gt;
    ${cookie}  &lt;br&gt;  &lt;%-- 获取Map集合 --%&gt;
    ${cookie.JSESSIONID}  &lt;br&gt; &lt;%-- 获取map集合中第二个元素 --%&gt;
    ${cookie.JSESSIONID.name}  &lt;br&gt; &lt;%-- 获取cookie对象的名称 --%&gt;
    ${cookie.JSESSIONID.value} &lt;%-- 获取cookie对象的值 --%&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<h4>8、JSTL</h4> 
<p><strong>1. JSTL 简介</strong></p> 
<p>JSTL 的全称是 JSP Standard Tag Libary，是 JSP 中标准的标签库。</p> 
<p>JSTP 是由 Apache 实现的，由以下 5 个部分组成：</p> 
<table><thead><tr><th>组成</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>Core</td><td>核心标签库</td><td>通用逻辑处理</td></tr><tr><td>Fmt</td><td>国际化相关</td><td>需要不同地域显示不同语言时使用</td></tr><tr><td>Functions</td><td>EL 函数</td><td>EL 表达式可以使用的方法</td></tr><tr><td>SQL</td><td>操作数据库</td><td>很少用</td></tr><tr><td>XML</td><td>操作XML</td><td>很少用</td></tr></tbody></table> 
<p><strong>1）使用要求</strong></p> 
<p>要想使用 JSTL 标签库，需要先在 javaweb 工程中需要导入坐标。首先是要在工程的 WEB-INF 目录中创建一个 lib 目录，然后把 JSTL 的 jar 拷贝到 lib 目录中，再在 jar 包上点击右键，然后选择【Add as Libary】添加。</p> 
<p>如下图所示：</p> 
<p><img alt="" height="332" src="https://images2.imgbox.com/de/61/McuAIgM4_o.png" width="300"></p> 
<p><strong>2）核心标签库</strong></p> 
<p>在实际开发中，用到的 JSTL 标签库主要以核心标签库为准，偶尔会用到国际化标签库的标签。</p> 
<p>下表中把经常可能用到的标签列在此处，其余标签库可自行查阅：</p> 
<table><thead><tr><th>标签名称</th><th>功能分类</th><th>分类</th><th>作用</th></tr></thead><tbody><tr><td>&lt;c:if&gt;</td><td>流程控制</td><td>核心标签库</td><td>用于条件判断</td></tr><tr><td>&lt;c:choose&gt;<br> &lt;c:when&gt;<br> &lt;c:otherwise&gt;</td><td>流程控制</td><td>核心标签库</td><td>用于多个条件判断</td></tr><tr><td>&lt;c:foreache&gt;</td><td>迭代操作</td><td>核心标签库</td><td>用于循环遍历</td></tr></tbody></table> 
<p><strong>3）JSTL 使用</strong></p> 
<pre><code>&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;
&lt;%-- 导入jstl标签库 --%&gt;
&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;JSTL的常用标签&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  
    &lt;%-- 演示 c:if --%&gt;
    &lt;% pageContext.setAttribute("score", "F"); %&gt;
    &lt;c:if test="${pageScope.score eq 'A'}"&gt;
        优秀
    &lt;/c:if&gt;
    &lt;c:if    test="${pageScope.score eq 'C'}"&gt;
        一般
    &lt;/c:if&gt;
    &lt;hr/&gt;
    
    &lt;%-- 演示 c:choose c:when c:otherwise --%&gt;
    &lt;c:choose&gt;
        &lt;c:when test="${pageScope.score eq 'A'}"&gt;
            AAA
        &lt;/c:when&gt;
        &lt;c:when test="${pageScope.score eq 'B'}"&gt;BBB
        &lt;/c:when&gt;
        &lt;c:when test="${pageScope.score eq 'C'}"&gt;CCC
        &lt;/c:when&gt;
        &lt;c:when test="${pageScope.score eq 'D'}"&gt;DDD
        &lt;/c:when&gt;
        &lt;c:otherwise&gt;其他&lt;/c:otherwise&gt;
    &lt;/c:choose&gt;
    
    &lt;%-- 演示 c:forEach 它是用来遍历集合的
         属性：
             items：要遍历的集合，它可以是EL表达式取出来的
             var：把当前遍历的元素放入指定的page域中。 var的取值就是key,当前遍历的元素就是value
                 注意：它不能支持EL表达式，只能是字符串常量
             begin:开始遍历的索引
             end:结束遍历的索引
             step：步长。i+=step
             varStatus：它是一个计数器对象。里面有两个属性，一个是用于记录索引。一个是用于计数。
                        索引是从0开始。计数是从1开始
    --%&gt;
    &lt;hr/&gt;
    
    &lt;% List&lt;String&gt; list = new ArrayList&lt;String&gt;();
       list.add("AAA");
       list.add("BBB");
       list.add("CCC");
       list.add("DDD");
       list.add("EEE");
       list.add("FFF");
       list.add("GGG");
       list.add("HHH");
       list.add("III");
       list.add("JJJ");
       list.add("KKK");
       list.add("LLL");
       pageContext.setAttribute("list",list);
     %&gt;
     
    &lt;c:forEach items="${list}" var="s" begin="1" end="7" step="2"&gt;
        ${s}&lt;br/&gt;
    &lt;/c:forEach&gt;
    
    &lt;hr/&gt;
    
    &lt;c:forEach begin="1" end="9" var="num"&gt;
        &lt;a href="#"&gt;${num}&lt;/a&gt;
    &lt;/c:forEach&gt;
    &lt;hr/&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;索引&lt;/td&gt;
            &lt;td&gt;序号&lt;/td&gt;
            &lt;td&gt;信息&lt;/td&gt;
        &lt;/tr&gt;

    &lt;c:forEach items="${list}" var="s" varStatus="vs"&gt;
        &lt;tr&gt;
            &lt;td&gt;${vs.index}&lt;/td&gt;
            &lt;td&gt;${vs.count}&lt;/td&gt;
            &lt;td&gt;${s}&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/c:forEach&gt;

    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<h3>五、Filter 过滤器</h3> 
<h4>1、Filter 简介</h4> 
<p><strong>1. 过滤器基本概念</strong></p> 
<p>Servlet 过滤器从字面可理解为经过一层层的过滤处理才达到使用的要求，而其实 Servlet 过滤器就是服务器与客户端请求与响应的中间层组件。</p> 
<p>在实际项目开发中 Servlet 过滤器主要用于对浏览器的请求进行过滤处理，将过滤后的请求再转给下一个资源。</p> 
<p>过滤器是以一种组件的形式绑定到 Web 应用程序当中的，与其他的 Web 应用程序组件不同的是，过滤器是采用了“链”的方式进行处理的，如下所示：</p> 
<p><img alt="" height="347" src="https://images2.imgbox.com/f8/0b/ExgpmZhq_o.png" width="966"></p> 
<p><strong>2. Filter</strong></p> 
<p>Filter（过滤器）是 JavaWeb 三大组件之一（另外两个是 Servlet 和 Listener），是在 2000 年发布的 Servlet2.3 规范中加入的一个接口，是 Servlet 规范中非常实用的技术。</p> 
<p>当需要限制用户访问某些资源或者在处理请求时提前处理某些资源的时候，就可以使用过滤器（Filter）完成。</p> 
<ul><li>当一个请求访问服务器资源时，服务器首先判断会是否有过滤器与请求资源相关联，如果有，过滤器会先将请求拦截下来，完成一些特定的功能，再由过滤器决定是否继续交给请求资源进行处理。</li><li>响应也是类似的。</li></ul> 
<p>Filter 应用场景：</p> 
<ul><li>URL 级别的权限控制</li><li>过滤敏感词汇</li><li>中文乱码问题</li><li>...</li></ul> 
<p>Servlet 的 Filter 特点：</p> 
<ol><li> <p><strong>声明式的</strong><br> 通过在 web.xml 配置文件中声明，允许添加、删除过滤器，而无须改动任何应用程序代码或 JSP 页面。</p> </li><li> <p><strong>灵活的</strong><br> 过滤器可用于客户端的直接调用执行预处理和后期的处理工作，通过过滤链可以实现一些灵活的功能。</p> </li><li> <p><strong>可移植的</strong><br> 由于现今各个 Web 容器都是以 Servlet 的规范进行设计的，因此 Servlet 过滤器同样是跨容器的。</p> </li><li> <p><strong>可重用的</strong><br> 基于其可移植性和声明式的配置方式，Filter 是可重用的。</p> </li></ol> 
<p>总的来说，Servlet 的过滤器是通过一个配置文件来灵活的声明的模块化可重用组件。过滤器动态的截获传入的请求和传出的响应，在不修改程序代码的情况下，透明的添加或删除他们。其独立于任何平台和 Web 容器。</p> 
<h4>2、Filter API</h4> 
<p><strong>1. Filter核心方法</strong></p> 
<p>Filter 是一个接口。如果想实现过滤器的功能，则必须实现该接口。</p> 
<p>核心方法：</p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>init(FilterConfig config)</td><td>初始化方法</td></tr><tr><td>void</td><td>doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</td><td>对请求资源和响应资源进行拦截</td></tr><tr><td>void</td><td>destroy()</td><td>销毁方法</td></tr></tbody></table> 
<p>配置方式：</p> 
<ul><li> <p>方式一：使用注解 @WebFilter("拦截路径")</p> </li><li> <p>方式二：web.xml 配置</p> </li></ul> 
<p><img alt="" height="148" src="https://images2.imgbox.com/2e/97/0cTa6WKd_o.png" width="410"></p> 
<p><img alt="" height="776" src="https://images2.imgbox.com/fd/cd/kUfuoBfu_o.png" width="1078"></p> 
<p><img alt="" height="299" src="https://images2.imgbox.com/97/73/eLeMfZZd_o.png" width="1200"></p> 
<p><strong>2. FilterChain</strong></p> 
<ul><li> <p>FilterChain 是一个接口，代表过滤器链对象，由 Servlet 容器提供实现类对象，我们直接使用即可。</p> </li><li> <p>过滤器可以定义多个，就会组成过滤器链。</p> </li></ul> 
<p>核心方法：</p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>doFilter(ServletRequest request, ServletResponse response)</td><td>放行方法</td></tr></tbody></table> 
<ul><li>如果有多个过滤器，则会在第一个过滤器中再调用下一个过滤器，依次类推，直到到达最终访问资源。</li><li>如果只有一个过滤器，放行时，就会直接到达最终访问资源。</li></ul> 
<p><img alt="" height="428" src="https://images2.imgbox.com/60/c2/GS2mTuLY_o.png" width="1200"></p> 
<p><strong>3. FilterConfig</strong></p> 
<p>FilterConfig 是一个接口，代表过滤器的配置对象，可以加载一些初始化参数。</p> 
<p>核心方法：</p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>String</td><td>getFilterName()</td><td>获取过滤器对象名称</td></tr><tr><td>String</td><td>getInitParameter(String key)</td><td>根据 key 获取 value</td></tr><tr><td>Enumeration&lt;String&gt;</td><td>getInitParameterNames()</td><td>获取所有参数的 key</td></tr><tr><td>ServletContext</td><td>getServletContext()</td><td>获取应用上下文对象</td></tr></tbody></table> 
<p><img alt="" height="616" src="https://images2.imgbox.com/a2/f2/Zco5q7JR_o.png" width="1200"></p> 
<h4>3、Filter 工作原理</h4> 
<p><strong>1. Filter 的体系结构</strong></p> 
<p>如其名字所暗示的一样，Servlet 过滤器用于拦截传入的请求和传出的响应，并监视、修改处理 Web 工程中的数据流。过滤器是一个可插入的自由组件。Web 资源可以不配置过滤器、也可以配置单个过滤器，也可以配置多个过滤器，形成一个过滤器链。Filter 接受用户的请求，并决定将请求转发给链中的下一个组件，或者终止请求直接向客户端返回一个响应。如果请求被转发了，它将被传递给链中的下一个过滤器(以 web.xml 过滤器的配置顺序为标准)。这个请求在通过过滤链并被服务器处理之后，一个响应将以相反的顺序通过该链发送回去。这样，请求和响应都得到了处理。 </p> 
<p>Filter 可以应用在客户端和 Servlet 之间、Servlet 和 Servlet 或 JSP 之间，并且可以通过配置言息，灵活的使用那个过滤器。</p> 
<p>基于上述体系结构的描述，Filter 工作原理如下图所示：</p> 
<p><img alt="" height="553" src="https://images2.imgbox.com/14/7f/KjWbCyak_o.png" width="1200"></p> 
<ol><li>客户端浏览器在访问 Web 服务器的某个具体资源的时候，经过过滤器 1 中 code l 代码块的相关处理之后，将请求传递给过滤链中的下一个过滤器 2（过滤链的顺序以配置文件中的顺序为基准)</li><li>过滤器 2 处理完之后，请求就根据传递的 Servlet 完成相应的逻辑。</li><li>返回响应的过程类似，只是过滤链的顺序相反。</li></ol> 
<h4>4、Filter 生命周期</h4> 
<p>生命周期：</p> 
<ol><li>出生：当应用加载时，执行初始化方法。</li><li>活着：只要应用一直提供服务，对象就一直存在。</li><li>死亡：当应用卸载时（执行销毁方法）或服务器宕机时，对象消亡。</li></ol> 
<p>Filter 的实例对象在内存中也只有一份，所以 Filter 也是单例的。</p> 
<pre><code>import javax.servlet.*;
import java.io.IOException;

/*
    过滤器生命周期
 */
//@WebFilter("/*")
public class FilterDemo03 implements Filter{

    /*
        初始化方法
     */
    @Override
    public void init(FilterConfig filterConfig) {
        System.out.println("对象初始化成功了...");
    }

    /*
        提供服务方法
     */
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("filterDemo03执行了...");

        //处理乱码
        servletResponse.setContentType("text/html;charset=UTF-8");

        //放行
        filterChain.doFilter(servletRequest,servletResponse);
    }

    /*
        对象销毁
     */
    @Override
    public void destroy() {
        System.out.println("对象销毁了...");
    }
}
</code></pre> 
<h4>5、Filter 使用案例</h4> 
<p>Filter 的创建过程：</p> 
<p>要编写一个过滤器必须实现 Filter 接口，实现其接口规定的方法。</p> 
<ol><li>实现 javax.Servlet.Filter 接口;</li><li>实现 init() 方法，读取过滤器的初始化参数；</li><li>实现 doFilter()方法，完成对请求或响应的过滤；</li><li>调用 FilterChain 接口对象的 doFilter() 方法，向后续的过滤器传递请求或响应。</li></ol> 
<p>编写接收和处理请求的 Servlet：</p> 
<pre><code>public class ServletDemo1 extends HttpServlet {

    /**
     * 处理请求的方法
     * @param req
     * @param resp
     * @throws ServletException
     * @throws IOException
     */
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("ServletDemo1接收到了请求");
        req.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(req,resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
       doGet(req,resp);
    }
}
</code></pre> 
<p>配置 Servlet：</p> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1"
         metadata-complete="true"&gt;
    
    &lt;!--配置Servlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.itheima.web.servlet.ServletDemo1&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/ServletDemo1&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</code></pre> 
<p>编写 index.jsp：</p> 
<pre><code>&lt;%-- Created by IntelliJ IDEA. --%&gt;
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;主页面&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;a href="${pageContext.request.contextPath}/ServletDemo1"&gt;访问ServletDemo1&lt;/a&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>编写 success.jsp：</p> 
<pre><code>&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;成功页面&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;% System.out.println("success.jsp执行了"); %&gt;
执行成功！
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>编写 Filter：</p> 
<pre><code>public class FilterDemo1 implements Filter {

    /**
     * 过滤器的核心方法
     * @param request
     * @param response
     * @param chain
     * @throws IOException
     * @throws ServletException
     */
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        /**
         * 如果不写此段代码，控制台会输出两次：FilterDemo1拦截到了请求。
         */
        HttpServletRequest req = (HttpServletRequest) request;
        String requestURI = req.getRequestURI();
        if (requestURI.contains("favicon.ico")) {
            return;
        }

        System.out.println("FilterDemo1拦截到了请求");
    }
}
</code></pre> 
<p>配置 Filter：</p> 
<pre><code>&lt;!--配置过滤器--&gt;
&lt;filter&gt;
    &lt;filter-name&gt;FilterDemo1&lt;/filter-name&gt;
    &lt;filter-class&gt;com.itheima.web.filter.FilterDemo1&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;FilterDemo1&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre> 
<p>运行结果分析：</p> 
<p><img alt="" height="349" src="https://images2.imgbox.com/4b/1f/uu1OCs8S_o.png" width="656"></p> 
<p>当我们启动服务并在地址栏输入访问地址后，发现浏览器任何内容都没有，控制台却输出了【FilterDemo1拦截到了请求】，也就是说在访问任何资源的时候，都先经过了过滤器。</p> 
<p>这是因为，我们在配置过滤器的拦截规则时，使用了<code>/*</code>，表示访问当前应用下的任何资源，此过滤器都会起作用。</p> 
<p>除了这种全部过滤的规则之外，它还支持特定类型的过滤配置。我们可以稍作调整，修改的方式如下：</p> 
<p><img alt="" height="166" src="https://images2.imgbox.com/f9/bd/IZjwxj1A_o.png" width="1167"></p> 
<p>新的问题是，我们拦截下来了，但点击链接发送请求，运行结果是： </p> 
<p><img alt="" height="585" src="https://images2.imgbox.com/50/6c/5rF5QTqj_o.png" width="774"></p> 
<p>对此，需要对过滤器执行放行操作，才能让它继续执行，那么如何放行的？</p> 
<p>我们需要使用FilterChain中的doFilter方法放行：</p> 
<p><img alt="" height="643" src="https://images2.imgbox.com/71/eb/N2bB0dVP_o.png" width="1166"></p> 
<p>继续修改：在FilterDemo1的doFilter方法后添加一行代码。</p> 
<pre><code>    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        /**
         * 如果不写此段代码，控制台会输出两次：FilterDemo1拦截到了请求。

        HttpServletRequest req = (HttpServletRequest) request;
        String requestURI = req.getRequestURI();
        if (requestURI.contains("favicon.ico")) {
            return;
        }*/
        System.out.println("FilterDemo1拦截到了请求");
        // 过滤器放行
        chain.doFilter(request,response);
        // 新增一行代码
        System.out.println("FilterDemo1放行之后，又回到了doFilter方法");
    }</code></pre> 
<p> 运行结果如下，我们发现过滤器放行之后执行完目标资源，最后仍会回到过滤器中。</p> 
<p><img alt="" height="318" src="https://images2.imgbox.com/63/46/3hr29xBy_o.png" width="629"></p> 
<h4>6、FilterConfig</h4> 
<p id="filterconfig过滤器配置对象"><strong>1. 过滤器配置对象</strong></p> 
<p>新增过滤器 FilterDemo2 ：</p> 
<pre><code>public class FilterDemo2 implements Filter {

    private FilterConfig filterConfig;

    /**
     * 初始化方法
     */
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("FilterDemo2的初始化方法执行了");
        // 给过滤器配置对象赋值
        this.filterConfig = filterConfig;
    }

    /**
     * 过滤器的核心方法
     */
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {

        System.out.println("FilterDemo2拦截到了请求");

        // 根据名称获取过滤器的初始化参数
        String paramValue = filterConfig.getInitParameter("filterInitParamName");
        System.out.println(paramValue);

        // 获取过滤器初始化参数名称的枚举
        Enumeration&lt;String&gt; initNames = filterConfig.getInitParameterNames();
        while(initNames.hasMoreElements()){
            String initName = initNames.nextElement();
            String initValue = filterConfig.getInitParameter(initName);
            System.out.println(initName+","+initValue);
        }

        // 获取ServletContext对象
        ServletContext servletContext = filterConfig.getServletContext();
        System.out.println(servletContext);

        // 获取过滤器名称
        String filterName = filterConfig.getFilterName();
        System.out.println(filterName);

        // 过滤器放行
        chain.doFilter(request, response);
    }
    
    /**
     * 销毁方法
     */
    @Override
    public void destroy() {
        System.out.println("FilterDemo2的销毁方法执行了");
    }
}
</code></pre> 
<p>配置 FilterDemo2 ：</p> 
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;FilterDemo2&lt;/filter-name&gt;
    &lt;filter-class&gt;com.itheima.web.filter.FilterDemo2&lt;/filter-class&gt;
    &lt;!--配置过滤器的初始化参数--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;filterInitParamName&lt;/param-name&gt;
        &lt;param-value&gt;filterInitParamValue&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;FilterDemo2&lt;/filter-name&gt;
    &lt;url-pattern&gt;/ServletDemo1&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre> 
<p>运行效果：</p> 
<p><img alt="" height="329" src="https://images2.imgbox.com/86/73/JJv87lN5_o.png" width="695"></p> 
<h4>7、Filter 五种拦截行为</h4> 
<pre><code>    &lt;filter&gt;
        &lt;filter-name&gt;filterDemo05&lt;/filter-name&gt;
        &lt;filter-class&gt;com.itheima.filter.FilterDemo05&lt;/filter-class&gt;
        &lt;!-- 配置开启异步支持，当dispatcher配置ASYNC时，需要配置此行 --&gt;
        &lt;async-supported&gt;true&lt;/async-supported&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;filterDemo05&lt;/filter-name&gt;
        &lt;!-- &lt;url-pattern&gt;/error.jsp&lt;/url-pattern&gt; --&gt;
        &lt;url-pattern&gt;/index.jsp&lt;/url-pattern&gt;
        &lt;!-- 过滤请求（默认值）--&gt;
        &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
        &lt;!-- 过滤全局错误页面：当由服务器调用全局错误页面时，过滤器工作 --&gt;
        &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt;
        &lt;!-- 过滤请求转发：当请求转发时，过滤器工作 --&gt;
        &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;
        &lt;!-- 过滤请求包含：当请求包含时，过滤器工作。它只能过滤动态包含，jsp的include指令是静态包含，过滤器不会起作用 --&gt;
        &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;
        &lt;!-- 过滤异步类型，它要求我们在filter标签中配置开启异步支持 --&gt;
        &lt;dispatcher&gt;ASYNC&lt;/dispatcher&gt;
    &lt;/filter-mapping&gt;

    &lt;!-- 配置全局错误页面 --&gt;
    &lt;error-page&gt;
        &lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt;
        &lt;location&gt;/error.jsp&lt;/location&gt;
    &lt;/error-page&gt;
    &lt;error-page&gt;
        &lt;error-code&gt;404&lt;/error-code&gt;
        &lt;location&gt;/error.jsp&lt;/location&gt;
    &lt;/error-page&gt;
&lt;/web-app&gt;
</code></pre> 
<h3>六、Listener 监听器</h3> 
<h4>1、Listener 简介</h4> 
<p><strong>1. 观察者设计模式</strong></p> 
<p>在介绍 Listener（监听器）之前，需要先了解观察者设计模式，因为所有的监听器都是观察者设计模式的体现。</p> 
<p>那么什么是观察者设计模式呢？</p> 
<p>它是<code>事件驱动</code>的一种体现形式。就好比在做什么事情的时候被人盯着，当做了某件事时，就会触发事件。</p> 
<p>观察者模式通常由以下三部分组成：</p> 
<ol><li> <p><code>事件源</code>：触发事件的对象。</p> </li><li> <p><code>事件</code>：触发的动作，里面封装了事件源。</p> </li><li> <p><code>监听器</code>：当事件源触发事件时，要做的事情。一般是一个接口，由使用者来实现。（此处还涉及一种设计模式的思想：策略模式）</p> </li></ol> 
<p>下图描述了观察者设计模式组成：</p> 
<p><img alt="" height="747" src="https://images2.imgbox.com/19/84/WYW8wFgm_o.png" width="1061"></p> 
<p><strong>2. Listener 介绍</strong></p> 
<p>在程序当中我们可以对以下情况进行监听：对象的创建销毁、域对象中属性的变化、会话相关内容。</p> 
<p>Servlet 规范中共计 8 个监听器，监听器都是以接口形式提供的，具体功能需要我们自己来完成。</p> 
<h4>2、Listener 配置方式</h4> 
<p>Listender 有两种配置方法：</p> 
<ol><li> <p><strong>注解方式 </strong>@WebListener</p> </li><li> <p><strong>web.xml 配置方式</strong></p> </li></ol> 
<pre><code>    &lt;!-- 配置监听器 --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;com.listener.ServletContextListenerDemo&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;com.listener.ServletContextAttributeListenerDemo&lt;/listener-class&gt;
    &lt;/listener&gt;</code></pre> 
<h4>3、Servlet 规范中的 8 个监听器</h4> 
<p><strong>1. 8个监听器</strong></p> 
<ul><li> <p><strong>监听对象的</strong></p> 
  <ol><li>ServletContextListener</li><li>HttpSessionListener</li><li>ServletRequestListener</li></ol></li><li> <p><strong>监听域中属性变化的</strong></p> 
  <ol><li>ServletContextAttributeListener</li><li>HttpSessionAttributeListener</li><li>ServletRequestAttributeListener</li></ol></li><li> <p><strong>会话相关的感知型</strong></p> 
  <ol><li>HttpSessionBindingListener</li><li>HttpSessionActivationListener</li></ol></li></ul> 
<p><strong>2. 监听对象的监听器</strong></p> 
<p id="1servletcontextlistener"><strong>1）ServletContextListener</strong></p> 
<p>用于监听 ServletContext 对象的创建和销毁。</p> 
<p>核心方法：</p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>contextlnitialized(ServletContextEvent sce)</td><td>对象创建时执行该方法</td></tr><tr><td>void</td><td>contextDestroyed(ServletContextEvent sce)</td><td>对象销毁时执行该方法</td></tr></tbody></table> 
<p>ServletContextEvent 参数：代表事件对象</p> 
<ul><li>事件对象中封装了事件源，也就是 ServletContext</li><li>直正的事件指的是创建或销毁 ServletContext 对象的操作</li></ul> 
<p id="2httpsessionlistener"><strong>2）HttpSessionListener</strong></p> 
<p>用于监听 HttpSession 对象的创建和销毁核心方法。</p> 
<p>核心方法：</p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>sessionCreated(HttpSessionEventse)</td><td>对象创建时执行该方法</td></tr><tr><td>void</td><td>sessionDestroyed(HttpSessionEvent se</td><td>对象销毁时执行该方法</td></tr></tbody></table> 
<p>HttpSessionEvent 参数：代表事件对象</p> 
<ul><li>事件对象中封装了事件源，也就是 HttpSession</li><li>真正的事件指的是创建或销毁 HttpSession 对象的操作</li></ul> 
<p id="3servletrequestlistener"><strong>3）ServletRequestListener</strong></p> 
<p>用于监听 ServletRequest 对象的创建和销毁核心方法。</p> 
<p>核心方法：</p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>requestinitialized(ServletRequestEvent sre)</td><td>对象创建时执行该方法</td></tr><tr><td>void</td><td>requestDestroyed(ServletRequestEvent sre)</td><td>对象销毁时执行该方法</td></tr></tbody></table> 
<p>ServletRequest5vent 参数：代表事件对象</p> 
<ul><li>事件对象中封装了事件源，也就是 ServletRequest</li><li>真正的事件指的是创建或销毁 ServletRequest 对象的操作</li></ul> 
<p><strong>3. 监听域中属性变化的监听器</strong></p> 
<p id="4servletcontextattributelistener"><strong>1）ServletContextAttributeListener</strong></p> 
<p>用于监听 ServletContext 应用域中属性的变化核心方法。</p> 
<p>核心方法：</p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>attributeAdded(ServletContextAttributeEvent scae)</td><td>域中添加属性时执行该方法</td></tr><tr><td>void</td><td>attributeRemoved(ServletContextAttributeEvent scae)</td><td>域中移除属性时执行该方法</td></tr><tr><td>void</td><td>attributeReplaced(ServletContextAttributeEvent scae)</td><td>域中替换属性时执行该方法</td></tr></tbody></table> 
<p>ServletContextAttributeEvent 参数：代表事件对象</p> 
<ul><li>事件对象中封装了事件源，也就是 ServletContext</li><li>直正的事件指的是添加、移除、替换应用域中属性的操作</li></ul> 
<p id="5httpsessionattributelistener"><strong>2）HttpSessionAttributeListener</strong></p> 
<p>用于监听 HttpSession 会话域中属性的变化。</p> 
<p>核心方法：</p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>attributeAdded(HttpSessionBindingEvent se)</td><td>域中添加属性时执行该方法</td></tr><tr><td>void</td><td>attributeRemoved(HttpSessionBindingEvent se)</td><td>域中移除属性时执行该方法</td></tr><tr><td>void</td><td>attributeReplaced(HttpSessionBindingEvent se)</td><td>域中替换属性时执行该方法</td></tr></tbody></table> 
<p>HttpSessionBindingEvent 参数：代表事件对象</p> 
<ul><li>事件对象中封装了事件源，也就是 HttpSession</li><li>真正的事件指的是添加、移除、替换会话域中属性的操作</li></ul> 
<p id="6servletrequestattributelistener"><strong>3）ServletRequestAttributeListener</strong></p> 
<p>用于监听 ServletRequest 请求域中属性的变化。</p> 
<p>核心方法：</p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>attributeAdded(ServletRequestAttributeEvent srae)</td><td>域中添加属性时执行该方法</td></tr><tr><td>void</td><td>attributeRemoved(ServletRequestAttributeEvent srae)</td><td>域中移除属性时执行该方法</td></tr><tr><td>void</td><td>attributeReplaced(ServletRequestAttributeEvent srae)</td><td>域中替换属性时执行该方法</td></tr></tbody></table> 
<p>ServletRequestAttributeEvent 参数：代表事件对象</p> 
<ul><li>事件对象中封装了事件源，也就是 ServletRequest</li><li>真正的事件指的是添加、移除、替换请求域中属性的操作</li></ul> 
<p><strong>4. 监听会话相关的感知型监听器</strong></p> 
<p>注意：监听会话相关的感知型监听器，只要定义了即可使用，无需进行配置。</p> 
<p id="7httpsessionbindinglistener"><strong>1）HttpSessionBindingListener</strong></p> 
<p>用于感知对象和会话域绑定的监听器。</p> 
<p>核心方法：</p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>valueBound(HttpSessionBindingEvent event)</td><td>数据添加到会话域中（绑定）时执行该方法</td></tr><tr><td>void</td><td>valueUnbound(HttpSessionBindingEvent event)</td><td>数据从会话域中移除（解绑）时执行该方法</td></tr></tbody></table> 
<p>HttpSessionBindingEvent 参数：代表事件对象</p> 
<ul><li>事件对象中封装了事件源，也就是 HttpSession</li><li>直正的事件指的是添加、移除会话域中数据的操作</li></ul> 
<p id="8httpsessionactivationlistener"><strong>2）HttpSessionActivationListener</strong></p> 
<p>用于感知会话域中对象钝化（序列化）和活化（反序列化）的监听器。</p> 
<p>核心方法：</p> 
<table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>sessionWillPassivate(HttpSessionEvent se)</td><td>会话域中数据钝化时执行该方法</td></tr><tr><td>void</td><td>sessionDidActivate(HttpSessionEvent se)</td><td>会话域中数据活化时执行该方法</td></tr></tbody></table> 
<p>HttpSessionEvent 参数：代表事件对象</p> 
<ul><li>事件对象中封装了事件源，也就是 HttpSession</li><li>直正的事件指的是会话域中数据钝化、活化的操作</li></ul> 
<h4>4、Listener 使用示例</h4> 
<p><strong>1. ServletContextListener 使用示例</strong></p> 
<p><strong>1）编写监听器</strong></p> 
<pre><code>/**
 * 用于监听ServletContext对象创建和销毁的监听器
 */
@WebListener
public class ServletContextListenerDemo implements ServletContextListener {

    /**
     * 对象创建时，执行此方法
     * @param sce
     */
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        System.out.println("监听到了对象的创建");
        // 获取事件源对象
        ServletContext servletContext = sce.getServletContext();
        System.out.println(servletContext);
    }

    /**
     * 对象销毁时，执行此方法
     * @param sce
     */
    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        System.out.println("监听到了对象的销毁");
    }
}
</code></pre> 
<p><strong>2）启动并停止 web 服务</strong></p> 
<p><img alt="" height="319" src="https://images2.imgbox.com/1b/9d/eikEKoKt_o.png" width="685"></p> 
<p><strong>2. ServletContextAttributeListener 使用示例</strong></p> 
<p><strong>1）编写监听器</strong></p> 
<pre><code>/**
 * 监听域中属性发生变化的监听器
 */
public class ServletContextAttributeListenerDemo implements ServletContextAttributeListener {

    /**
     * 域中添加了数据
     * @param scae
     */
    @Override
    public void attributeAdded(ServletContextAttributeEvent scae) {
        System.out.println("监听到域中加入了属性");
        /**
         * 由于除了我们往域中添加了数据外，应用在加载时还会自动往域中添加一些属性。
         * 我们可以获取域中所有名称的枚举，从而看到域中都有哪些属性
         */
        
        //1.获取事件源对象ServletContext
        ServletContext servletContext = scae.getServletContext();
        //2.获取域中所有名称的枚举
        Enumeration&lt;String&gt; names = servletContext.getAttributeNames();
        //3.遍历名称的枚举
        while(names.hasMoreElements()){
            //4.获取每个名称
            String name = names.nextElement();
            //5.获取值
            Object value = servletContext.getAttribute(name);
            //6.输出名称和值
            System.out.println("name is "+name+" and value is "+value);
        }
    }

    /**
     * 域中移除了数据
     * @param scae
     */
    @Override
    public void attributeRemoved(ServletContextAttributeEvent scae) {
        System.out.println("监听到域中移除了属性");
    }

    /**
     * 域中属性发生了替换
     * @param scae
     */
    @Override
    public void attributeReplaced(ServletContextAttributeEvent scae) {
        System.out.println("监听到域中属性发生了替换");
    }
}
</code></pre> 
<p>同时，我们还需要借助上个示例的 ServletContextListenerDemo 监听器，往域中存入数据、替换域中的数据以及从域中移除数据，代码如下：</p> 
<pre><code>/**
 * 用于监听ServletContext对象创建和销毁的监听器
 */
public class ServletContextListenerDemo implements ServletContextListener {

    /**
     * 对象创建时，执行此方法
     * @param sce
     */
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        System.out.println("监听到了对象的创建");
        //1.获取事件源对象
        ServletContext servletContext = sce.getServletContext();
        //2.往域中加入属性
        servletContext.setAttribute("servletContext","test");
    }

    /**
     * 对象销毁时，执行此方法
     * @param sce
     */
    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        //1.取出事件源对象
        ServletContext servletContext = sce.getServletContext();
        //2.往域中加入属性，但是名称仍采用servletContext，此时就是替换
        servletContext.setAttribute("servletContext","demo");
        System.out.println("监听到了对象的销毁");
        //3.移除属性
        servletContext.removeAttribute("servletContext");
    }
}
</code></pre> 
<p><strong>2）在 web.xml 中配置监听器</strong></p> 
<pre><code>&lt;!--配置监听器--&gt;
&lt;listener&gt;
    &lt;listener-class&gt;com.listener.ServletContextListenerDemo&lt;/listener-class&gt;
&lt;/listener&gt;

&lt;!--配置监听器--&gt;
&lt;listener&gt;
    &lt;listener-class&gt;com.listener.ServletContextAttributeListenerDemo&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre> 
<p><strong>3）启动 web 服务</strong></p> 
<p><img alt="" height="496" src="https://images2.imgbox.com/15/d0/LxdD7OfD_o.png" width="1160"></p> 
<h4>5、Listener 综合案例</h4> 
<p>对前面的JSP综合案例进行优化。</p> 
<p>优化需求：</p> 
<ol><li>解决乱码：使用过滤器统一实现请求和响应乱码问题的解决。</li><li>检查登录：使用过滤器统一实现身份认证。</li><li>优化 JSP 页面：使用 EL 表达式和 JSTL 。</li></ol> 
<p id="1乱码问题过滤器"><strong>1）乱码问题过滤器</strong></p> 
<pre><code>import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

// 解决全局乱码问题
@WebFilter("/*")
public class EncodingFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        // 将请求和响应对象转换为和HTTP协议相关
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        HttpServletResponse httpServletResponse = (HttpServletResponse) response;

        // 设置编码格式
        httpServletRequest.setCharacterEncoding("UTF-8");
        httpServletResponse.setContentType("text/html;charset=UTF-8");

        // 放行
        chain.doFilter(httpServletRequest, httpServletResponse);

    }
}
</code></pre> 
<p><strong>2）检查登录过滤器</strong></p> 
<pre><code>import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

// 检查登录态
@WebFilter(value={"/add.jsp", "/queryServlet"})
public class LoginFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        // 将请求和响应对象转换为和HTTP协议相关
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        HttpServletResponse httpServletResponse = (HttpServletResponse) response;

        // 判断会话域对象中的身份数据
        Object username = httpServletRequest.getSession().getAttribute("username");
        if ("".equals(username) || username == null) {
            // 重定向到登录页
            httpServletResponse.sendRedirect(httpServletRequest.getContextPath()+"/login.jsp");
            return;
        }

        // 放行
        chain.doFilter(httpServletRequest, httpServletResponse);
    }
}
</code></pre> 
<p><strong>3）优化 JSP：使用 EL 表达式和 JSTL</strong></p> 
<p>修改 add.jsp 的虚拟访问路径：</p> 
<pre><code>&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;添加&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action="${pageContext.request.contextPath}/addServlet" method="post" autocomplete="off"&gt;
        学生姓名：&lt;input type="text" name="username"&gt;&lt;br/&gt;
        学生年龄：&lt;input type="number" name="age"&gt;&lt;br/&gt;
        学生成绩：&lt;input type="number" name="score"&gt;&lt;br/&gt;
        &lt;button type="submit"&gt;保存&lt;/button&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>修改 index.jsp：</p> 
<pre><code>&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;

&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;学生管理系统首页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;%--
        获取会话域的数据
        如果获取到了，则显示添加和查询功能
        如果获取不到，则显示登录功能
    --%&gt;
    &lt;c:if test="${sessionScope.username eq null}"&gt;
        &lt;a href="${pageContext.request.contextPath}/login.jsp"&gt;登录&lt;a/&gt;
    &lt;/c:if&gt;

    &lt;c:if test="${sessionScope.username ne null}"&gt;
        &lt;a href="${pageContext.request.contextPath}/add.jsp"&gt;添加&lt;a/&gt;
        &lt;a href="${pageContext.request.contextPath}/queryServlet"&gt;查询&lt;a/&gt;
    &lt;/c:if&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>修改 query.jsp ：</p> 
<pre><code>&lt;%@ page import="com.demo.bean.Student" %&gt;
&lt;%@ page import="java.util.ArrayList" %&gt;
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;

&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;学生列表页面&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;table width="600px" border="1px"&gt;
    &lt;tr&gt;
      &lt;th&gt;学生姓名&lt;/th&gt;
      &lt;th&gt;学生年龄&lt;/th&gt;
      &lt;th&gt;学生成绩&lt;/th&gt;
    &lt;/tr&gt;
      &lt;c:forEach items="${students}" var="student"&gt;
          &lt;tr align="center"&gt;
              &lt;td&gt;${student.username}&lt;/td&gt;
              &lt;td&gt;${student.age}&lt;/td&gt;
              &lt;td&gt;${student.score}&lt;/td&gt;
          &lt;tr/&gt;
      &lt;/c:forEach&gt;

  &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>修改 login.jsp ：</p> 
<pre><code>&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;登录页面&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action="${pageContext.request.contextPath}/loginServlet" method="get" autocomplete="off"&gt;
        姓名：&lt;input type="text" name="username"&gt;&lt;br/&gt;
        密码：&lt;input type="password" name="password"&gt;&lt;br/&gt;
        &lt;button type="submit"&gt;登录&lt;/button&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<h3>七、MVC开发部署</h3> 
<h4>1、MVC开发</h4> 
<p>通过结合Servlet和JSP的MVC模式，我们可以发挥二者各自的优点：</p> 
<ul><li>Servlet实现业务逻辑；</li><li>JSP实现展示逻辑。</li></ul> 
<p>假设我们已经编写了几个JavaBean：</p> 
<pre><code>public class User {
    public long id;
    public String name;
    public School school;
}

public class School {
    public String name;
    public String address;
}</code></pre> 
<p>在UserServlet中，我们可以从数据库读取User、School等信息，然后，把读取到的JavaBean先放到HttpServletRequest中，再通过forward()传给user.jsp处理：</p> 
<pre><code>@WebServlet(urlPatterns = "/user")
public class UserServlet extends HttpServlet {
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 假装从数据库读取:
        School school = new School("No.1 Middle School", "101 South Street");
        User user = new User(123, "Bob", school);
        // 放入Request中:
        req.setAttribute("user", user);
        // forward给user.jsp:
        req.getRequestDispatcher("/WEB-INF/user.jsp").forward(req, resp);
    }
}</code></pre> 
<p>在user.jsp中，我们只负责展示相关JavaBean的信息，不需要编写访问数据库等复杂逻辑：</p> 
<pre><code>&lt;%@ page import="com.itranswarp.learnjava.bean.*"%&gt;
&lt;%
    User user = (User) request.getAttribute("user");
%&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Hello World - JSP&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Hello &lt;%= user.name %&gt;!&lt;/h1&gt;
    &lt;p&gt;School Name:
    &lt;span style="color:red"&gt;
        &lt;%= user.school.name %&gt;
    &lt;/span&gt;
    &lt;/p&gt;
    &lt;p&gt;School Address:
    &lt;span style="color:red"&gt;
        &lt;%= user.school.address %&gt;
    &lt;/span&gt;
    &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>请注意几点：</p> 
<ul><li>需要展示的<code>User</code>被放入<code>HttpServletRequest</code>中以便传递给JSP，因为一个请求对应一个<code>HttpServletRequest</code>，我们也无需清理它，处理完该请求后<code>HttpServletRequest</code>实例将被丢弃；</li><li>把<code>user.jsp</code>放到<code>/WEB-INF/</code>目录下，是因为<code>WEB-INF</code>是一个特殊目录，Web Server会阻止浏览器对<code>WEB-INF</code>目录下任何资源的访问，这样就防止用户通过<code>/user.jsp</code>路径直接访问到JSP页面；</li><li>JSP页面首先从<code>request</code>变量获取<code>User</code>实例，然后在页面中直接输出，此处未考虑HTML的转义问题，有潜在安全风险。</li></ul> 
<p>我们在浏览器访问http://localhost:8080/user，请求首先由UserServlet处理，然后交给user.jsp渲染：</p> 
<p><img alt="" height="209" src="https://images2.imgbox.com/14/81/c7Z9lj1n_o.png" width="390"></p> 
<p>我们把UserServlet看作业务逻辑处理，把User看作模型，把user.jsp看作渲染，这种设计模式通常被称为MVC：Model-View-Controller，即UserServlet作为控制器（Controller），User作为模型（Model），user.jsp作为视图（View），整个MVC架构如下： </p> 
<p><img alt="" height="183" src="https://images2.imgbox.com/85/c1/EFHP92DU_o.png" width="402"></p> 
<p>使用MVC模式的好处是，Controller专注于业务处理，它的处理结果就是Model。Model可以是一个JavaBean，也可以是一个包含多个对象的Map，Controller只负责把Model传递给View，View只负责把Model给“渲染”出来，这样，三者职责明确，且开发更简单，因为开发Controller时无需关注页面，开发View时无需关心如何创建Model。</p> 
<p>MVC模式广泛地应用在Web页面和传统的桌面程序中，我们在这里通过Servlet和JSP实现了一个简单的MVC模型，但它还不够简洁和灵活，后续我们会介绍更简单的Spring MVC开发。</p> 
<p>直接把MVC搭在Servlet和JSP之上还是不太好，原因如下：</p> 
<ul><li>Servlet提供的接口仍然偏底层，需要实现Servlet调用相关接口；</li><li>JSP对页面开发不友好，更好的替代品是模板引擎；</li><li>业务逻辑最好由纯粹的Java类实现，而不是强迫继承自Servlet。</li></ul> 
<p>能不能通过普通的Java类实现MVC的Controller？类似下面的代码：</p> 
<p></p> 
<pre><code>public class UserController {
    @GetMapping("/signin")
    public ModelAndView signin() {
        ...
    }

    @PostMapping("/signin")
    public ModelAndView doSignin(SignInBean bean) {
        ...
    }

    @GetMapping("/signout")
    public ModelAndView signout(HttpSession session) {
        ...
    }
}</code></pre> 
<p>上面的这个Java类每个方法都对应一个GET或POST请求，方法返回值是ModelAndView，它包含一个View的路径以及一个Model，这样，再由MVC框架处理后返回给浏览器。</p> 
<p>如果是GET请求，我们希望MVC框架能直接把URL参数按方法参数对应起来然后传入：</p> 
<pre><code>@GetMapping("/hello")
public ModelAndView hello(String name) {
    ...
}</code></pre> 
<p>如果是POST请求，我们希望MVC框架能直接把Post参数变成一个JavaBean后通过方法参数传入：</p> 
<pre><code>@PostMapping("/signin")
public ModelAndView doSignin(SignInBean bean) {
    ...
}</code></pre> 
<p>为了增加灵活性，如果Controller的方法在处理请求时需要访问HttpServletRequest、HttpServletResponse、HttpSession这些实例时，只要方法参数有定义，就可以自动传入：</p> 
<pre><code>@GetMapping("/signout")
public ModelAndView signout(HttpSession session) {
    ...
}</code></pre> 
<p>以上就是我们在设计MVC框架时，上层代码所需要的一切信息。</p> 
<h4>2、MVC框架</h4> 
<p>如何设计一个MVC框架？</p> 
<p>在前面，我们已经定义了上层代码编写Controller的一切接口信息，并且并不要求实现特定接口，只需返回ModelAndView对象，该对象包含一个View和一个Model。实际上View就是模板的路径，而Model可以用一个Map&lt;String, Object&gt;表示，因此，ModelAndView定义非常简单：</p> 
<pre><code>public class ModelAndView {
    Map&lt;String, Object&gt; model;
    String view;
}</code></pre> 
<p>比较复杂的是我们需要在MVC框架中创建一个接收所有请求的Servlet，通常我们把它命名为DispatcherServlet，它总是映射到/，然后，根据不同的Controller的方法定义的@Get或@Post的Path决定调用哪个方法，最后，获得方法返回的ModelAndView后，渲染模板，写入HttpServletResponse，即完成了整个MVC的处理。</p> 
<p>这个MVC的架构如下：</p> 
<p><img alt="" height="224" src="https://images2.imgbox.com/6f/45/CuWbtm3F_o.png" width="424"></p> 
<p>其中，DispatcherServlet以及如何渲染均由MVC框架实现，在MVC框架之上只需要编写每一个Controller。</p> 
<p>我们来看看如何编写最复杂的DispatcherServlet。首先，我们需要存储请求路径到某个具体方法的映射：</p> 
<pre><code>@WebServlet(urlPatterns = "/")
public class DispatcherServlet extends HttpServlet {
    private Map&lt;String, GetDispatcher&gt; getMappings = new HashMap&lt;&gt;();
    private Map&lt;String, PostDispatcher&gt; postMappings = new HashMap&lt;&gt;();
}</code></pre> 
<p>处理一个GET请求是通过GetDispatcher对象完成的，它需要如下信息：</p> 
<pre><code>class GetDispatcher {
    Object instance; // Controller实例
    Method method; // Controller方法
    String[] parameterNames; // 方法参数名称
    Class&lt;?&gt;[] parameterClasses; // 方法参数类型
}</code></pre> 
<p>有了以上信息，就可以定义invoke()来处理真正的请求：</p> 
<pre><code>class GetDispatcher {
    ...
    public ModelAndView invoke(HttpServletRequest request, HttpServletResponse response) {
        Object[] arguments = new Object[parameterClasses.length];
        for (int i = 0; i &lt; parameterClasses.length; i++) {
            String parameterName = parameterNames[i];
            Class&lt;?&gt; parameterClass = parameterClasses[i];
            if (parameterClass == HttpServletRequest.class) {
                arguments[i] = request;
            } else if (parameterClass == HttpServletResponse.class) {
                arguments[i] = response;
            } else if (parameterClass == HttpSession.class) {
                arguments[i] = request.getSession();
            } else if (parameterClass == int.class) {
                arguments[i] = Integer.valueOf(getOrDefault(request, parameterName, "0"));
            } else if (parameterClass == long.class) {
                arguments[i] = Long.valueOf(getOrDefault(request, parameterName, "0"));
            } else if (parameterClass == boolean.class) {
                arguments[i] = Boolean.valueOf(getOrDefault(request, parameterName, "false"));
            } else if (parameterClass == String.class) {
                arguments[i] = getOrDefault(request, parameterName, "");
            } else {
                throw new RuntimeException("Missing handler for type: " + parameterClass);
            }
        }
        return (ModelAndView) this.method.invoke(this.instance, arguments);
    }

    private String getOrDefault(HttpServletRequest request, String name, String defaultValue) {
        String s = request.getParameter(name);
        return s == null ? defaultValue : s;
    }
}</code></pre> 
<p>上述代码比较繁琐，但逻辑非常简单，即通过构造某个方法需要的所有参数列表，使用反射调用该方法后返回结果。</p> 
<p>类似的，PostDispatcher需要如下信息：</p> 
<pre><code>class PostDispatcher {
    Object instance; // Controller实例
    Method method; // Controller方法
    Class&lt;?&gt;[] parameterClasses; // 方法参数类型
    ObjectMapper objectMapper; // JSON映射
}</code></pre> 
<p>和GET请求不同，POST请求严格地来说不能有URL参数，所有数据都应当从Post Body中读取。这里我们为了简化处理，<em>只支持</em>JSON格式的POST请求，这样，把Post数据转化为JavaBean就非常容易。</p> 
<pre><code>class PostDispatcher {
    ...
    public ModelAndView invoke(HttpServletRequest request, HttpServletResponse response) {
        Object[] arguments = new Object[parameterClasses.length];
        for (int i = 0; i &lt; parameterClasses.length; i++) {
            Class&lt;?&gt; parameterClass = parameterClasses[i];
            if (parameterClass == HttpServletRequest.class) {
                arguments[i] = request;
            } else if (parameterClass == HttpServletResponse.class) {
                arguments[i] = response;
            } else if (parameterClass == HttpSession.class) {
                arguments[i] = request.getSession();
            } else {
                // 读取JSON并解析为JavaBean:
                BufferedReader reader = request.getReader();
                arguments[i] = this.objectMapper.readValue(reader, parameterClass);
            }
        }
        return (ModelAndView) this.method.invoke(instance, arguments);
    }
}</code></pre> 
<p>最后，我们来实现整个DispatcherServlet的处理流程，以doGet()为例：</p> 
<pre><code>public class DispatcherServlet extends HttpServlet {
    ...
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType("text/html");
        resp.setCharacterEncoding("UTF-8");
        String path = req.getRequestURI().substring(req.getContextPath().length());
        // 根据路径查找GetDispatcher:
        GetDispatcher dispatcher = this.getMappings.get(path);
        if (dispatcher == null) {
            // 未找到返回404:
            resp.sendError(404);
            return;
        }
        // 调用Controller方法获得返回值:
        ModelAndView mv = dispatcher.invoke(req, resp);
        // 允许返回null:
        if (mv == null) {
            return;
        }
        // 允许返回`redirect:`开头的view表示重定向:
        if (mv.view.startsWith("redirect:")) {
            resp.sendRedirect(mv.view.substring(9));
            return;
        }
        // 将模板引擎渲染的内容写入响应:
        PrintWriter pw = resp.getWriter();
        this.viewEngine.render(mv, pw);
        pw.flush();
    }
}</code></pre> 
<p>这里有几个小改进：</p> 
<ul><li>允许Controller方法返回<code>null</code>，表示内部已自行处理完毕；</li><li>允许Controller方法返回以<code>redirect:</code>开头的view名称，表示一个重定向。</li></ul> 
<p>这样使得上层代码编写更灵活。例如，一个显示用户资料的请求可以这样写：</p> 
<pre><code>@GetMapping("/user/profile")
public ModelAndView profile(HttpServletResponse response, HttpSession session) {
    User user = (User) session.getAttribute("user");
    if (user == null) {
        // 未登录，跳转到登录页:
        return new ModelAndView("redirect:/signin");
    }
    if (!user.isManager()) {
        // 权限不够，返回403:
        response.sendError(403);
        return null;
    }
    return new ModelAndView("/profile.html", Map.of("user", user));
}</code></pre> 
<p>最后一步是在DispatcherServlet的init()方法中初始化所有Get和Post的映射，以及用于渲染的模板引擎：</p> 
<pre><code>public class DispatcherServlet extends HttpServlet {
    private Map&lt;String, GetDispatcher&gt; getMappings = new HashMap&lt;&gt;();
    private Map&lt;String, PostDispatcher&gt; postMappings = new HashMap&lt;&gt;();
    private ViewEngine viewEngine;

    @Override
    public void init() throws ServletException {
        this.getMappings = scanGetInControllers();
        this.postMappings = scanPostInControllers();
        this.viewEngine = new ViewEngine(getServletContext());
    }
    ...
}</code></pre> 
<p>如何扫描所有Controller以获取所有标记有@GetMapping和@PostMapping的方法？当然是使用反射了。虽然代码比较繁琐，但我们相信各位童鞋可以轻松实现。</p> 
<p>这样，整个MVC框架就搭建完毕。</p> 
<h4>3、实现渲染</h4> 
<p>有的童鞋对如何使用模板引擎进行渲染有疑问，即如何实现上述的ViewEngine？其实ViewEngine非常简单，只需要实现一个简单的render()方法：</p> 
<pre><code>public class ViewEngine {
    public void render(ModelAndView mv, Writer writer) throws IOException {
        String view = mv.view;
        Map&lt;String, Object&gt; model = mv.model;
        // 根据view找到模板文件:
        Template template = getTemplateByPath(view);
        // 渲染并写入Writer:
        template.write(writer, model);
    }
}</code></pre> 
<p>Java有很多开源的模板引擎，常用的有：</p> 
<ul><li><a href="https://www.thymeleaf.org/" rel="nofollow" title="Thymeleaf">Thymeleaf</a></li><li><a href="https://freemarker.apache.org/" rel="nofollow" title="FreeMarker">FreeMarker</a></li><li><a href="https://velocity.apache.org/" rel="nofollow" title="Velocity">Velocity</a></li></ul> 
<p>他们的用法都大同小异。这里我们推荐一个使用<a href="https://palletsprojects.com/p/jinja/" rel="nofollow" title="Jinja">Jinja</a>语法的模板引擎<a href="https://pebbletemplates.io/" rel="nofollow" title="Pebble">Pebble</a>，它的特点是语法简单，支持模板继承，编写出来的模板类似：</p> 
<pre><code>&lt;html&gt;
&lt;body&gt;
  &lt;ul&gt;
  {% for user in users %}
    &lt;li&gt;&lt;a href="{<!-- -->{ user.url }}"&gt;{<!-- -->{ user.username }}&lt;/a&gt;&lt;/li&gt;
  {% endfor %}
  &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>即变量用{<!-- -->{ xxx }}表示，控制语句用{% xxx %}表示。</p> 
<p>使用Pebble渲染只需要如下几行代码：</p> 
<pre><code>public class ViewEngine {
    private final PebbleEngine engine;

    public ViewEngine(ServletContext servletContext) {
        // 定义一个ServletLoader用于加载模板:
        ServletLoader loader = new ServletLoader(servletContext);
        // 模板编码:
        loader.setCharset("UTF-8");
        // 模板前缀，这里默认模板必须放在`/WEB-INF/templates`目录:
        loader.setPrefix("/WEB-INF/templates");
        // 模板后缀:
        loader.setSuffix("");
        // 创建Pebble实例:
        this.engine = new PebbleEngine.Builder()
            .autoEscaping(true) // 默认打开HTML字符转义，防止XSS攻击
            .cacheActive(false) // 禁用缓存使得每次修改模板可以立刻看到效果
            .loader(loader).build();
    }

    public void render(ModelAndView mv, Writer writer) throws IOException {
        // 查找模板:
        PebbleTemplate template = this.engine.getTemplate(mv.view);
        // 渲染:
        template.evaluate(writer, mv.model);
    }
}
</code></pre> 
<p>最后我们来看看整个工程的结构：</p> 
<p><img alt="" height="535" src="https://images2.imgbox.com/e9/27/DuGwzs4D_o.png" width="487"></p> 
<p>其中，framework包是MVC的框架，完全可以单独编译后作为一个Maven依赖引入，controller包才是我们需要编写的业务逻辑。</p> 
<p>我们还硬性规定模板必须放在webapp/WEB-INF/templates目录下，静态文件必须放在webapp/static目录下，因此，为了便于开发，我们还顺带实现一个FileServlet来处理静态文件：</p> 
<pre><code>@WebServlet(urlPatterns = { "/favicon.ico", "/static/*" })
public class FileServlet extends HttpServlet {
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 读取当前请求路径:
        ServletContext ctx = req.getServletContext();
        // RequestURI包含ContextPath,需要去掉:
        String urlPath = req.getRequestURI().substring(ctx.getContextPath().length());
        // 获取真实文件路径:
        String filepath = ctx.getRealPath(urlPath);
        if (filepath == null) {
            // 无法获取到路径:
            resp.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
        Path path = Paths.get(filepath);
        if (!path.toFile().isFile()) {
            // 文件不存在:
            resp.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
        // 根据文件名猜测Content-Type:
        String mime = Files.probeContentType(path);
        if (mime == null) {
            mime = "application/octet-stream";
        }
        resp.setContentType(mime);
        // 读取文件并写入Response:
        OutputStream output = resp.getOutputStream();
        try (InputStream input = new BufferedInputStream(new FileInputStream(filepath))) {
            input.transferTo(output);
        }
        output.flush();
    }
}</code></pre> 
<p>行代码，在浏览器中输入URLhttp://localhost:8080/hello?name=Bob可以看到如下页面：</p> 
<p><img alt="" height="332" src="https://images2.imgbox.com/55/3b/q622lQf8_o.png" width="508"></p> 
<p>为了把方法参数的名称编译到class文件中，以便处理@GetMapping时使用，我们需要打开编译器的一个参数，在Eclipse中勾选Preferences-Java-Compiler-Store information about method parameters (usable via reflection)；在Idea中选择Preferences-Build, Execution, Deployment-Compiler-Java Compiler-Additional command line parameters，填入-parameters；在Maven的pom.xml添加一段配置如下： </p> 
<pre><code>&lt;project ...&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    ...
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;compilerArgs&gt;
                        &lt;arg&gt;-parameters&lt;/arg&gt;
                    &lt;/compilerArgs&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</code></pre> 
<p>有些用过Spring MVC的童鞋会发现，本节实现的这个MVC框架，上层代码使用的公共类如GetMapping、PostMapping和ModelAndView都和Spring MVC非常类似。实际上，我们这个MVC框架主要参考就是Spring MVC，通过实现一个“简化版”MVC，可以掌握Java Web MVC开发的核心思想与原理，对将来直接使用Spring MVC是非常有帮助的。</p> 
<p>一个MVC框架是基于Servlet基础抽象出更高级的接口，使得上层基于MVC框架的开发可以不涉及Servlet相关的HttpServletRequest等接口，处理多个请求更加灵活，并且可以使用任意模板引擎，不必使用JSP。</p> 
<h4>4、部署项目</h4> 
<p>对一个Web应用程序来说，除了Servlet、Filter这些逻辑组件，还需要JSP这样的视图文件，外加一堆静态资源文件，如CSS、JS等。</p> 
<p>合理组织文件结构非常重要。我们以一个具体的Web应用程序为例：</p> 
<p><img alt="" height="321" src="https://images2.imgbox.com/27/25/pP0DiCxw_o.png" width="451"></p> 
<p>我们把所有的静态资源文件放入/static/目录，在开发阶段，有些Web服务器会自动为我们加一个专门负责处理静态文件的Servlet，但如果IndexServlet映射路径为/，会屏蔽掉处理静态文件的Servlet映射。因此，我们需要自己编写一个处理静态文件的FileServlet： </p> 
<pre><code>@WebServlet(urlPatterns = "/static/*")
public class FileServlet extends HttpServlet {
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext ctx = req.getServletContext();
        // RequestURI包含ContextPath,需要去掉:
        String urlPath = req.getRequestURI().substring(ctx.getContextPath().length());
        // 获取真实文件路径:
        String filepath = ctx.getRealPath(urlPath);
        if (filepath == null) {
            // 无法获取到路径:
            resp.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
        Path path = Paths.get(filepath);
        if (!path.toFile().isFile()) {
            // 文件不存在:
            resp.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
        // 根据文件名猜测Content-Type:
        String mime = Files.probeContentType(path);
        if (mime == null) {
            mime = "application/octet-stream";
        }
        resp.setContentType(mime);
        // 读取文件并写入Response:
        OutputStream output = resp.getOutputStream();
        try (InputStream input = new BufferedInputStream(new FileInputStream(filepath))) {
            input.transferTo(output);
        }
        output.flush();
    }
}</code></pre> 
<p>这样一来，在开发阶段，我们就可以方便地高效开发。</p> 
<p>类似Tomcat这样的Web服务器，运行的Web应用程序通常都是业务系统，因此，这类服务器也被称为应用服务器。应用服务器并不擅长处理静态文件，也不适合直接暴露给用户。通常，我们在生产环境部署时，总是使用类似Nginx这样的服务器充当反向代理和静态服务器，只有动态请求才会放行给应用服务器，所以，部署架构如下：</p> 
<p><img alt="" height="149" src="https://images2.imgbox.com/49/a7/22eaUqa4_o.png" width="512"></p> 
<p>实现上述功能的Nginx配置文件如下： </p> 
<pre><code>server {
    listen 80;

    server_name www.local.yyds.com;

    # 静态文件根目录:
    root /path/to/src/main/webapp;

    access_log /var/log/nginx/webapp_access_log;
    error_log  /var/log/nginx/webapp_error_log;

    # 处理静态文件请求:
    location /static {
    }

    # 处理静态文件请求:
    location /favicon.ico {
    }

    # 不允许请求/WEB-INF:
    location /WEB-INF {
        return 404;
    }

    # 其他请求转发给Tomcat:
    location / {
        proxy_pass       http://127.0.0.1:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}</code></pre> 
<p>使用Nginx配合Tomcat服务器，可以充分发挥Nginx作为网关的优势，既可以高效处理静态文件，也可以把https、防火墙、限速、反爬虫等功能放到Nginx中，使得我们自己的WebApp能专注于业务逻辑。</p> 
<p>注意：部署Web应用程序时，要设计合理的目录结构，同时考虑开发模式需要便捷性，生产模式需要高性能。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cb5101e9fbbb62d840f7a51568897df8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pycharm运行时报错ImportError: cannot import name ‘Bar‘ from ‘pyecharts‘（用pycharm绘制柱状图）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8fe7b7168e404d5853795f8a5ad225b4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux 【gcc，make/makefile】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>