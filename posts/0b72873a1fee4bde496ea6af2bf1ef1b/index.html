<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>pandas——python - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="pandas——python" />
<meta property="og:description" content="目录
0.导引 1.Series 1.1 Series的创建 1.2 Series的索引
1.3 Series的切片 1.4 Series常用属性和方法
1.5 Series的运算
1.6 Series练习
2.DataFrame
2.1 DataFrame的创建
2.2 DataFrame的索引 2.3 DataFrame的切片
2.4 DataFrame的运算
2.5 DataFrame练习 2.6 pandas中的None和np.nan
2.6.1 基本概念
2.6.2 pandas中的None和np.nan都视为np.nan
2.6.3 pandas中的None与np.nan操作
3.pandas多层级索引 3.1 多层级索引的创建
3.2 多层级索引的访问与切片
3.3 多层级索引的变形操作（stack）
4.pandas汇总操作
4.1 级联 4.1.1 使用pd.concat()级联
4.1.2 不匹配级联
4.1.3 使用append()函数添加
4.2 合并
4.2.1 一对一合并 4.2.2 多对一合并
4.2.3 多对多合并
4.2.4 key的规范化 4.2.5 没有相同的columns也可以合并 4.2.6 内合并与外合并 4.2.7 列冲突的解决 4.2.8 简易回顾&#43;练习 5.pandas的数据处理" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/0b72873a1fee4bde496ea6af2bf1ef1b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-09T16:49:01+08:00" />
<meta property="article:modified_time" content="2022-07-09T16:49:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">pandas——python</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="0.%E5%AF%BC%E5%BC%95-toc" style="margin-left:0px;"><a href="#0.%E5%AF%BC%E5%BC%95" rel="nofollow">0.导引 </a></p> 
<p id="1.Series%C2%A0-toc" style="margin-left:0px;"><a href="#1.Series%C2%A0" rel="nofollow">1.Series </a></p> 
<p id="1.1%20Series%E7%9A%84%E5%88%9B%E5%BB%BA%C2%A0-toc" style="margin-left:40px;"><a href="#1.1%20Series%E7%9A%84%E5%88%9B%E5%BB%BA%C2%A0" rel="nofollow">1.1 Series的创建 </a></p> 
<p id="1.2%20Series%E7%9A%84%E7%B4%A2%E5%BC%95-toc" style="margin-left:40px;"><a href="#1.2%20Series%E7%9A%84%E7%B4%A2%E5%BC%95" rel="nofollow">1.2 Series的索引</a></p> 
<p id="1.3%20Series%E7%9A%84%E5%88%87%E7%89%87%C2%A0-toc" style="margin-left:40px;"><a href="#1.3%20Series%E7%9A%84%E5%88%87%E7%89%87%C2%A0" rel="nofollow">1.3 Series的切片 </a></p> 
<p id="1.4%20Series%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#1.4%20Series%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95" rel="nofollow">1.4 Series常用属性和方法</a></p> 
<p id="1.5%20Series%E7%9A%84%E8%BF%90%E7%AE%97-toc" style="margin-left:40px;"><a href="#1.5%20Series%E7%9A%84%E8%BF%90%E7%AE%97" rel="nofollow">1.5 Series的运算</a></p> 
<p id="1.6%20Series%E7%BB%83%E4%B9%A0-toc" style="margin-left:40px;"><a href="#1.6%20Series%E7%BB%83%E4%B9%A0" rel="nofollow">1.6 Series练习</a></p> 
<p id="2.DataFrame-toc" style="margin-left:0px;"><a href="#2.DataFrame" rel="nofollow">2.DataFrame</a></p> 
<p id="2.1%20DataFrame%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:40px;"><a href="#2.1%20DataFrame%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">2.1 DataFrame的创建</a></p> 
<p id="2.2%20DataFrame%E7%9A%84%E7%B4%A2%E5%BC%95%C2%A0%C2%A0-toc" style="margin-left:40px;"><a href="#2.2%20DataFrame%E7%9A%84%E7%B4%A2%E5%BC%95%C2%A0%C2%A0" rel="nofollow">2.2 DataFrame的索引  </a></p> 
<p id="2.3%C2%A0DataFrame%E7%9A%84%E5%88%87%E7%89%87-toc" style="margin-left:40px;"><a href="#2.3%C2%A0DataFrame%E7%9A%84%E5%88%87%E7%89%87" rel="nofollow">2.3 DataFrame的切片</a></p> 
<p id="2.4%20DataFrame%E7%9A%84%E8%BF%90%E7%AE%97-toc" style="margin-left:40px;"><a href="#2.4%20DataFrame%E7%9A%84%E8%BF%90%E7%AE%97" rel="nofollow">2.4 DataFrame的运算</a></p> 
<p id="2.5%20DataFrame%E7%BB%83%E4%B9%A0%C2%A0-toc" style="margin-left:40px;"><a href="#2.5%20DataFrame%E7%BB%83%E4%B9%A0%C2%A0" rel="nofollow">2.5 DataFrame练习 </a></p> 
<p id="3.pandas%E4%B8%AD%E7%9A%84None%E5%92%8Cnp.nan-toc" style="margin-left:40px;"><a href="#3.pandas%E4%B8%AD%E7%9A%84None%E5%92%8Cnp.nan" rel="nofollow">2.6 pandas中的None和np.nan</a></p> 
<p id="3.1%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#3.1%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">2.6.1 基本概念</a></p> 
<p id="3.1.1%20pandas%E4%B8%AD%E7%9A%84None%E5%92%8Cnp.nan%E9%83%BD%E8%A7%86%E4%B8%BAnp.nan-toc" style="margin-left:80px;"><a href="#3.1.1%20pandas%E4%B8%AD%E7%9A%84None%E5%92%8Cnp.nan%E9%83%BD%E8%A7%86%E4%B8%BAnp.nan" rel="nofollow">2.6.2 pandas中的None和np.nan都视为np.nan</a></p> 
<p id="3.1.2%20pandas%E4%B8%AD%E7%9A%84None%E4%B8%8Enp.nan%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#3.1.2%20pandas%E4%B8%AD%E7%9A%84None%E4%B8%8Enp.nan%E6%93%8D%E4%BD%9C" rel="nofollow">2.6.3 pandas中的None与np.nan操作</a></p> 
<p id="3.pandas%E5%A4%9A%E5%B1%82%E7%BA%A7%E7%B4%A2%E5%BC%95%C2%A0%20%C2%A0%20%C2%A0%C2%A0-toc" style="margin-left:0px;"><a href="#3.pandas%E5%A4%9A%E5%B1%82%E7%BA%A7%E7%B4%A2%E5%BC%95%C2%A0%20%C2%A0%20%C2%A0%C2%A0" rel="nofollow">3.pandas多层级索引      </a></p> 
<p id="3.1%20%E5%A4%9A%E5%B1%82%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:40px;"><a href="#3.1%20%E5%A4%9A%E5%B1%82%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">3.1 多层级索引的创建</a></p> 
<p id="3.2%20%E5%A4%9A%E5%B1%82%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BF%E9%97%AE%E4%B8%8E%E5%88%87%E7%89%87-toc" style="margin-left:40px;"><a href="#3.2%20%E5%A4%9A%E5%B1%82%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BF%E9%97%AE%E4%B8%8E%E5%88%87%E7%89%87" rel="nofollow">3.2 多层级索引的访问与切片</a></p> 
<p id="3.3%20%E5%A4%9A%E5%B1%82%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8F%98%E5%BD%A2%E6%93%8D%E4%BD%9C%EF%BC%88stack%EF%BC%89-toc" style="margin-left:40px;"><a href="#3.3%20%E5%A4%9A%E5%B1%82%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8F%98%E5%BD%A2%E6%93%8D%E4%BD%9C%EF%BC%88stack%EF%BC%89" rel="nofollow">3.3 多层级索引的变形操作（stack）</a></p> 
<p id="4.pandas%E6%B1%87%E6%80%BB%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#4.pandas%E6%B1%87%E6%80%BB%E6%93%8D%E4%BD%9C" rel="nofollow">4.pandas汇总操作</a></p> 
<p id="4.1%20%E7%BA%A7%E8%81%94%C2%A0-toc" style="margin-left:40px;"><a href="#4.1%20%E7%BA%A7%E8%81%94%C2%A0" rel="nofollow">4.1 级联 </a></p> 
<p id="4.1.1%C2%A0%E4%BD%BF%E7%94%A8pd.concat()%E7%BA%A7%E8%81%94-toc" style="margin-left:80px;"><a href="#4.1.1%C2%A0%E4%BD%BF%E7%94%A8pd.concat%28%29%E7%BA%A7%E8%81%94" rel="nofollow">4.1.1 使用pd.concat()级联</a></p> 
<p id="4.1.2%20%E4%B8%8D%E5%8C%B9%E9%85%8D%E7%BA%A7%E8%81%94-toc" style="margin-left:80px;"><a href="#4.1.2%20%E4%B8%8D%E5%8C%B9%E9%85%8D%E7%BA%A7%E8%81%94" rel="nofollow">4.1.2 不匹配级联</a></p> 
<p id="4.1.3%20%E4%BD%BF%E7%94%A8append()%E5%87%BD%E6%95%B0%E6%B7%BB%E5%8A%A0-toc" style="margin-left:80px;"><a href="#4.1.3%20%E4%BD%BF%E7%94%A8append%28%29%E5%87%BD%E6%95%B0%E6%B7%BB%E5%8A%A0" rel="nofollow">4.1.3 使用append()函数添加</a></p> 
<p id="4.2%20%E5%90%88%E5%B9%B6-toc" style="margin-left:40px;"><a href="#4.2%20%E5%90%88%E5%B9%B6" rel="nofollow">4.2 合并</a></p> 
<p id="4.2.1%20%E4%B8%80%E5%AF%B9%E4%B8%80%E5%90%88%E5%B9%B6%C2%A0-toc" style="margin-left:80px;"><a href="#4.2.1%20%E4%B8%80%E5%AF%B9%E4%B8%80%E5%90%88%E5%B9%B6%C2%A0" rel="nofollow">4.2.1 一对一合并 </a></p> 
<p id="4.2.2%20%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%90%88%E5%B9%B6-toc" style="margin-left:80px;"><a href="#4.2.2%20%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%90%88%E5%B9%B6" rel="nofollow">4.2.2 多对一合并</a></p> 
<p id="4.2.3%20%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%90%88%E5%B9%B6-toc" style="margin-left:80px;"><a href="#4.2.3%20%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%90%88%E5%B9%B6" rel="nofollow">4.2.3 多对多合并</a></p> 
<p id="4.2.4%20key%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96%C2%A0%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#4.2.4%20key%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96%C2%A0%C2%A0%C2%A0" rel="nofollow">4.2.4 key的规范化   </a></p> 
<p id="4.2.5%20%E6%B2%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84columns%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%90%88%E5%B9%B6%C2%A0-toc" style="margin-left:80px;"><a href="#4.2.5%20%E6%B2%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84columns%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%90%88%E5%B9%B6%C2%A0" rel="nofollow">4.2.5 没有相同的columns也可以合并 </a></p> 
<p id="4.2.6%20%E5%86%85%E5%90%88%E5%B9%B6%E4%B8%8E%E5%A4%96%E5%90%88%E5%B9%B6%C2%A0-toc" style="margin-left:80px;"><a href="#4.2.6%20%E5%86%85%E5%90%88%E5%B9%B6%E4%B8%8E%E5%A4%96%E5%90%88%E5%B9%B6%C2%A0" rel="nofollow">4.2.6 内合并与外合并 </a></p> 
<p id="4.2.7%20%E5%88%97%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%C2%A0-toc" style="margin-left:80px;"><a href="#4.2.7%20%E5%88%97%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%C2%A0" rel="nofollow">4.2.7 列冲突的解决 </a></p> 
<p id="4.2.8%20%E7%AE%80%E6%98%93%E5%9B%9E%E9%A1%BE%C2%A0-toc" style="margin-left:80px;"><a href="#4.2.8%20%E7%AE%80%E6%98%93%E5%9B%9E%E9%A1%BE%C2%A0" rel="nofollow">4.2.8 简易回顾+练习 </a></p> 
<p id="5.%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E7%BE%8E%E5%9B%BD%E5%90%84%E5%B7%9E%E4%BA%BA%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%C2%A0-toc" style="margin-left:0px;"><a href="#5.%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E7%BE%8E%E5%9B%BD%E5%90%84%E5%B7%9E%E4%BA%BA%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%C2%A0" rel="nofollow">5.pandas的数据处理</a></p> 
<p id="5.1%20%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#5.1%20%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0" rel="nofollow">5.1 删除重复元素</a></p> 
<p id="5.2%20%E6%98%A0%E5%B0%84%C2%A0-toc" style="margin-left:40px;"><a href="#5.2%20%E6%98%A0%E5%B0%84%C2%A0" rel="nofollow">5.2 映射 </a></p> 
<p id="5.2.1%20replace()%E5%87%BD%E6%95%B0%EF%BC%9A%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#5.2.1%20replace%28%29%E5%87%BD%E6%95%B0%EF%BC%9A%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0%C2%A0%C2%A0" rel="nofollow">5.2.1 replace()函数：替换元素  </a></p> 
<p id="5.2.2%20map()%E5%87%BD%E6%95%B0%EF%BC%9A%E6%96%B0%E5%BB%BA%E4%B8%80%E5%88%97-toc" style="margin-left:80px;"><a href="#5.2.2%20map%28%29%E5%87%BD%E6%95%B0%EF%BC%9A%E6%96%B0%E5%BB%BA%E4%B8%80%E5%88%97" rel="nofollow">5.2.2 map()函数：新建一列</a></p> 
<p id="5.2.3%20%E5%B0%8F%E7%BB%83%E4%B9%A0-toc" style="margin-left:80px;"><a href="#5.2.3%20%E5%B0%8F%E7%BB%83%E4%B9%A0" rel="nofollow">5.2.3 小练习</a></p> 
<p id="5.2.4%20rename()%E5%87%BD%E6%95%B0%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%B4%A2%E5%BC%95-toc" style="margin-left:80px;"><a href="#5.2.4%20rename%28%29%E5%87%BD%E6%95%B0%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%B4%A2%E5%BC%95" rel="nofollow">5.2.4 rename()函数：替换索引</a></p> 
<p id="5.3%C2%A0%E4%BD%BF%E7%94%A8%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BC%82%E5%B8%B8%E5%80%BC%E6%A3%80%E6%B5%8B%E5%92%8C%E8%BF%87%E6%BB%A4-toc" style="margin-left:40px;"><a href="#5.3%C2%A0%E4%BD%BF%E7%94%A8%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BC%82%E5%B8%B8%E5%80%BC%E6%A3%80%E6%B5%8B%E5%92%8C%E8%BF%87%E6%BB%A4" rel="nofollow">5.3 使用聚合操作对数据异常值检测和过滤</a></p> 
<p id="5.3.1%20%E6%9F%A5%E7%9C%8B%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%C2%A0-toc" style="margin-left:80px;"><a href="#5.3.1%20%E6%9F%A5%E7%9C%8B%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%C2%A0" rel="nofollow">5.3.1 查看表格数据信息的常用方法 </a></p> 
<p id="5.3.2%20%E5%BC%82%E5%B8%B8%E5%80%BC%E5%A4%84%E7%90%86-toc" style="margin-left:80px;"><a href="#5.3.2%20%E5%BC%82%E5%B8%B8%E5%80%BC%E5%A4%84%E7%90%86" rel="nofollow">5.3.2 异常值处理</a></p> 
<p id="5.4%20%E6%8E%92%E5%BA%8F%C2%A0-toc" style="margin-left:40px;"><a href="#5.4%20%E6%8E%92%E5%BA%8F%C2%A0" rel="nofollow">5.4 排序 </a></p> 
<p id="5.5%20%E6%95%B0%E6%8D%AE%E5%88%86%E7%B1%BB%2F%E7%BB%84%E5%A4%84%E7%90%86%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91-toc" style="margin-left:40px;"><a href="#5.5%20%E6%95%B0%E6%8D%AE%E5%88%86%E7%B1%BB%2F%E7%BB%84%E5%A4%84%E7%90%86%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91" rel="nofollow">5.5 数据分类/组处理【重点】</a></p> 
<p id="5.5.1%20%E5%8D%95%E5%AD%97%E6%AE%B5%E5%88%86%E7%BB%84%C2%A0-toc" style="margin-left:80px;"><a href="#5.5.1%20%E5%8D%95%E5%AD%97%E6%AE%B5%E5%88%86%E7%BB%84%C2%A0" rel="nofollow">5.5.1 单字段分组 </a></p> 
<p id="5.5.2%20%E5%A4%9A%E5%AD%97%E6%AE%B5%E5%88%86%E7%BB%84-toc" style="margin-left:80px;"><a href="#5.5.2%20%E5%A4%9A%E5%AD%97%E6%AE%B5%E5%88%86%E7%BB%84" rel="nofollow">5.5.2 多字段分组</a></p> 
<p id="5.5.3%20%E9%80%8F%E8%A7%86%E8%A1%A8%C2%A0-toc" style="margin-left:80px;"><a href="#5.5.3%20%E9%80%8F%E8%A7%86%E8%A1%A8%C2%A0" rel="nofollow">5.5.3 透视表 </a></p> 
<p id="5.5.4%20%E4%BA%A4%E5%8F%89%E8%A1%A8-toc" style="margin-left:80px;"><a href="#5.5.4%20%E4%BA%A4%E5%8F%89%E8%A1%A8" rel="nofollow">5.5.4 交叉表</a></p> 
<p id="5.6%20%E9%AB%98%E7%BA%A7%E8%81%9A%E5%90%88-toc" style="margin-left:40px;"><a href="#5.6%20%E9%AB%98%E7%BA%A7%E8%81%9A%E5%90%88" rel="nofollow">5.6 高级聚合</a></p> 
<p id="5.6.1%20apply()%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#5.6.1%20apply%28%29%E5%87%BD%E6%95%B0" rel="nofollow">5.6.1 apply()函数</a></p> 
<p id="5.6.2%20transform()%E5%87%BD%E6%95%B0%C2%A0-toc" style="margin-left:80px;"><a href="#5.6.2%20transform%28%29%E5%87%BD%E6%95%B0%C2%A0" rel="nofollow">5.6.2 transform()函数 </a></p> 
<p id="5.6.3%20%E5%B0%8F%E7%BB%83%E4%B9%A0-toc" style="margin-left:80px;"><a href="#5.6.3%20%E5%B0%8F%E7%BB%83%E4%B9%A0" rel="nofollow">5.6.3 小练习</a></p> 
<p id="%E9%99%84%E8%BD%BDnumpy%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E9%99%84%E8%BD%BDnumpy%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5%EF%BC%9A" rel="nofollow">附载numpy学习链接：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="0.%E5%AF%BC%E5%BC%95">0.导引 </h2> 
<blockquote> 
 <p><strong>数据分析三剑客：</strong>numpy, pandas, matplotlib</p> 
 <p></p> 
 <p>numpy  array     提供了运算基础</p> 
 <p>pandas              提供了业务逻辑的处理方法</p> 
 <p>matplotlib           做绘图展示<br> Series，DataFrame</p> 
</blockquote> 
<p><img alt="" height="153" src="https://images2.imgbox.com/1d/c1/CvqLZrmM_o.png" width="607">  </p> 
<p><img alt="" height="634" src="https://images2.imgbox.com/b7/cb/WW95lI8O_o.png" width="770"></p> 
<p><img alt="" height="521" src="https://images2.imgbox.com/47/f6/fI1kBzY4_o.png" width="1047"></p> 
<p><img alt="" height="466" src="https://images2.imgbox.com/e0/11/O5LKrCRd_o.png" width="1200"></p> 
<p><img alt="" height="787" src="https://images2.imgbox.com/aa/cb/17JdBzWZ_o.png" width="1200"></p> 
<p></p> 
<h2 id="1.Series%C2%A0">1.Series </h2> 
<blockquote> 
 <p><strong>一维数组：</strong>有序的数据类型相同的集合<br><strong>Series：</strong>一维数组的强化版，增加了像字典一样的key-value一样的访问机制，同时也保留了        数组的访问机制</p> 
 <p><strong>字典：</strong>无序的结合</p> 
 <p></p> 
 <p>Series是一种类似于一维数组的对象，由下面两个部分组成：</p> 
 <ul><li>values ：一组数据( ndarray类型)</li><li>index：相关的数据索引标签</li></ul> 
</blockquote> 
<h3 id="1.1%20Series%E7%9A%84%E5%88%9B%E5%BB%BA%C2%A0">1.1 Series的创建 </h3> 
<blockquote> 
 <p><strong>两种创建方式︰</strong><br><strong>(1)由列表或nunpy数组创建</strong><br>         默认索引为0到N-1的整数型索引<br>         还可以通过设置index参数指定索引<br> 特别地，由numpy创建的是引用，而不是副本(列表创建的是副本) 。对Series元素的改变也会改变原来的ndarray对象中的元素。(列表没有这种情况)<br><strong>(2)由字典创建</strong></p> 
</blockquote> 
<p><img alt="" height="223" src="https://images2.imgbox.com/45/7f/wBRy7Jys_o.png" width="336">  </p> 
<p><img alt="" height="635" src="https://images2.imgbox.com/18/aa/qgEX8Wz3_o.png" width="1200"><img alt="" height="524" src="https://images2.imgbox.com/e1/ab/9sVAqCPU_o.png" width="599"></p> 
<p></p> 
<p><img alt="" height="472" src="https://images2.imgbox.com/0e/07/XqRccFF0_o.png" width="603"></p> 
<p><img alt="" height="540" src="https://images2.imgbox.com/99/e8/fI0lEMVP_o.png" width="771"></p> 
<p><img alt="" height="672" src="https://images2.imgbox.com/77/f6/NY5IlAMW_o.png" width="770"></p> 
<h3 id="1.2%20Series%E7%9A%84%E7%B4%A2%E5%BC%95">1.2 Series的索引</h3> 
<blockquote> 
 <p> 可以使用中括号取单个索引（此时返回的是元素类型），或者中括号里一个列表取多个索引（此时返回的仍然是一个Series类型)。分为显示索引和隐式索引：</p> 
 <p><strong>(1)显式索引：</strong></p> 
 <ul><li>使用index中的元素作为索引值</li><li>使用.loc[]（推荐)     配合显式索引</li><li>使用.iloc[]（推荐）  配合隐式索引</li><li>使用带索引的bool型的Series列表访问</li></ul> 
 <p>    注意，此时是闭区间</p> 
 <p><strong>(1)隐式索引：</strong></p> 
 <p><strong>    </strong>像普通列表一样访问</p> 
</blockquote> 
<p><img alt="" height="646" src="https://images2.imgbox.com/20/49/g8qTu9rN_o.png" width="821"></p> 
<p><img alt="" height="198" src="https://images2.imgbox.com/e4/f7/d3DfPBbq_o.png" width="621"></p> 
<p><img alt="" height="583" src="https://images2.imgbox.com/15/b8/aSAwo0aX_o.png" width="853"></p> 
<p><img alt="" height="683" src="https://images2.imgbox.com/9d/2a/StHwg0QO_o.png" width="921"></p> 
<p><img alt="" height="364" src="https://images2.imgbox.com/5b/69/0mKxiVR3_o.png" width="965"></p> 
<h3 id="1.3%20Series%E7%9A%84%E5%88%87%E7%89%87%C2%A0">1.3 Series的切片 </h3> 
<blockquote> 
 <p>1.数组</p> 
 <p>2.字典</p> 
 <p>3. s.loc[ ]</p> 
 <p>4. s.iloc[ ]</p> 
 <p><strong>注意：</strong>默认都是左闭右开区间，所有使用显示索引（即自己设定的index）切片的都是闭区间</p> 
</blockquote> 
<p><img alt="" height="575" src="https://images2.imgbox.com/f8/17/vk8oZinx_o.png" width="754"></p> 
<p><img alt="" height="366" src="https://images2.imgbox.com/33/c1/UUYmdTio_o.png" width="690"></p> 
<h3 id="1.4%20Series%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">1.4 Series常用属性和方法</h3> 
<blockquote> 
 <p>可以把Series看成一个定长的有序字典。</p> 
 <ul><li>可以通过<strong>shape , size , index,values</strong>等得到series的属性。</li><li>可以使用<strong>head(),tail()</strong>分别查看前n个和后n个值。</li><li>当索引没有对应的值时，可能出现缺失数据显示<strong>NaN</strong> ( not a number )的情况。</li><li>可以使用<strong>pd.isnull() , pd.notnull()</strong>，或<strong>自带isnull(),notnull()函数</strong>检测缺失数据。</li><li>Series对象本身及其实例都有一个<strong>name属性</strong></li><li><strong>s.sort_values()</strong>  ==&gt; 根据值排序            <strong>s.sort_index() </strong> ==&gt; 根据索引排序</li><li>统计所有值出现的次数：s.value_counts()</li></ul> 
</blockquote> 
<p><img alt="" height="613" src="https://images2.imgbox.com/ed/e2/C5Vyrj4j_o.png" width="816"></p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/bb/99/f8lmV2Vf_o.png" width="763"></p> 
<p><img alt="" height="345" src="https://images2.imgbox.com/2b/1a/ercjUOZU_o.png" width="760"></p> 
<p><img alt="" height="313" src="https://images2.imgbox.com/f7/92/0RMsyuHj_o.png" width="853"></p> 
<p> <img alt="" height="483" src="https://images2.imgbox.com/38/0c/KJNB5s71_o.png" width="643"></p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/22/43/gMDUPPKW_o.png" width="851"></p> 
<p><img alt="" height="673" src="https://images2.imgbox.com/3b/33/z5EqFboM_o.png" width="1068"></p> 
<p><img alt="" height="253" src="https://images2.imgbox.com/a3/c4/3CkBQoHP_o.png" width="693"></p> 
<h3 id="1.5%20Series%E7%9A%84%E8%BF%90%E7%AE%97">1.5 Series的运算</h3> 
<blockquote> 
 <p>(1)适用于numpy的数组运算也适用于Series</p> 
 <p>        Series和numpy运算，隐式索引对齐；当然也有广播机制<br> (2) Series之间的运算</p> 
 <ul><li>在运算中自动对齐不同索引的数据</li><li>如果索引不对应，则补NaN</li></ul> 
 <p><strong>注意：</strong>要想保留所有的index，则需要使用：</p> 
 <ul><li>add()    加</li><li>sub()    减</li><li>mul()    乘</li><li>div()     除</li></ul> 
</blockquote> 
<p><img alt="" height="631" src="https://images2.imgbox.com/2d/ef/oMOxjeXZ_o.png" width="901"><img alt="" height="617" src="https://images2.imgbox.com/ca/a3/5LMJ3RkJ_o.png" width="973"> <img alt="" height="253" src="https://images2.imgbox.com/00/0e/m5TUhba7_o.png" width="611"></p> 
<p></p> 
<h3 id="1.6%20Series%E7%BB%83%E4%B9%A0">1.6 Series练习</h3> 
<blockquote> 
 <p>1.随机生成两组学生成绩，一组python，一组java，学生包括lucy、mery、tom、jack</p> 
 <p>2.计算每个学生的平均成绩<br> 3.找出python未及格的学生姓名</p> 
 <p>4.找出java未及格的学生姓名<br> 5.如果需要给mery的python成绩加10分，如何实现</p> 
 <p>6.计算各学科的班级平均成绩</p> 
</blockquote> 
<p><img alt="" height="415" src="https://images2.imgbox.com/d2/db/peDE0EKn_o.png" width="1022"></p> 
<p><img alt="" height="468" src="https://images2.imgbox.com/a5/01/QTCabkbS_o.png" width="719"></p> 
<p><img alt="" height="404" src="https://images2.imgbox.com/cc/df/rHT8TKsD_o.png" width="719"></p> 
<h2 id="2.DataFrame">2.DataFrame</h2> 
<blockquote> 
 <p><strong>DataFrame</strong>是一个【表格型】的数据结构（二维），可以看做是【由Series组成的字典】(共用同一个索引)。DataFrame由按一定顺序排列的多列数据组成。设计初衷是将Series的使用场景从一维拓展到多维。DataFrame既有行索引，也有列索引。</p> 
 <ul><li>行索引：index</li><li>列索引：columns</li><li>值：values ( numpy的二维数组)</li></ul> 
</blockquote> 
<p><img alt="" height="360" src="https://images2.imgbox.com/2d/ea/VDtmZydE_o.png" width="843"></p> 
<p><img alt="" height="137" src="https://images2.imgbox.com/29/8b/bBvrs2JB_o.png" width="843"></p> 
<h3 id="2.1%20DataFrame%E7%9A%84%E5%88%9B%E5%BB%BA">2.1 DataFrame的创建</h3> 
<blockquote> 
 <p>最常用的方法是传递一个字典来创建。DataFrame以字典的键作为每一【列】的名称，以字典的值(一个数组)作为每一列。此外，DataFrame会自动加上每一行的索引(和Series一样）。<br> 同Series一样，若传入的列与字典的键不匹配，则相应的值为NaN。<br> DataFrame属性：values、columns、index、shape </p> 
</blockquote> 
<blockquote> 
 <p><strong>三种创建方法：</strong></p> 
 <ul><li>构造函数构造   ==&gt;不建议这种，因为每一列数据是一样的</li><li>字典构造          ==&gt;建议这种，因为每一列数据可以不一样</li><li> 从文件中读取DataFrame文件   ==&gt;   pd.read_csv()  pd.read_table()  pd.read_excel()  </li><li>使用Series构造DataFrame</li></ul> 
</blockquote> 
<p><img alt="" height="674" src="https://images2.imgbox.com/61/24/qEbcqvlk_o.png" width="1164"></p> 
<p><img alt="" height="436" src="https://images2.imgbox.com/da/c6/Jba3WHcl_o.png" width="1200"></p> 
<p><img alt="" height="374" src="https://images2.imgbox.com/c7/01/bk0fj3Gu_o.png" width="1200"></p> 
<p><img alt="" height="577" src="https://images2.imgbox.com/49/2a/4jKSWQYU_o.png" width="549"></p> 
<p><img alt="" height="502" src="https://images2.imgbox.com/86/ad/t1RU12IE_o.png" width="935"></p> 
<p><img alt="" height="501" src="https://images2.imgbox.com/34/f6/3qpqbRVM_o.png" width="1124"></p> 
<p><img alt="" height="669" src="https://images2.imgbox.com/1e/2f/4CVGecMZ_o.png" width="1184"></p> 
<h3 id="2.2%20DataFrame%E7%9A%84%E7%B4%A2%E5%BC%95%C2%A0%C2%A0">2.2 DataFrame的索引  </h3> 
<blockquote> 
 <p><strong> (1)对列进行索引</strong></p> 
 <ul><li>通过类似字典的方式</li><li>通过属性的方式</li></ul> 
 <p>可以将DataFrame的列获取为一个Series。返回的Series拥有原DataFrame相同的索引，且name属性也已经设置好了，就是相应的列名。</p> 
 <p><br><strong>(2)对行进行索引   </strong></p> 
 <ul><li>使用.ix[ ]来进行行索引</li><li>使用.loc[ ]加index来进行行索引</li><li>使用.iloc[ ]加整数来进行行索引</li></ul> 
 <p>同样返回一个Series , index为原来的columns。<br><br><strong>(3)对元素索引的方法   </strong> ==&gt;  元素访问的逻辑和numpy的访问逻辑一致(先行后列)</p> 
 <ul><li>使用列索引</li><li>使用行索引（iloc[3,1]相当于两个参数；iloc[[3,3]]里面的[3,3]看做一个参数）</li><li>使用values属性（二维numpy数组)<br>  </li></ul> 
</blockquote> 
<p> <img alt="" height="344" src="https://images2.imgbox.com/56/5b/fstYlU08_o.png" width="482"></p> 
<p> <img alt="" height="390" src="https://images2.imgbox.com/58/f6/DgEokZmd_o.png" width="500"></p> 
<p><img alt="" height="603" src="https://images2.imgbox.com/5b/06/tSKoTwks_o.png" width="867"></p> 
<p><img alt="" height="556" src="https://images2.imgbox.com/b6/a9/iOBjkDmL_o.png" width="1200"></p> 
<p> <img alt="" height="617" src="https://images2.imgbox.com/64/cf/jrvAW9wj_o.png" width="898"></p> 
<h3 id="2.3%C2%A0DataFrame%E7%9A%84%E5%88%87%E7%89%87">2.3 DataFrame的切片</h3> 
<blockquote> 
 <p><strong>【注意】</strong>直接用中括号时：</p> 
 <ul><li>索引表示的是列索引</li><li>切片表示的是行切片<br>  </li></ul> 
 <p>标签处理的切片都是闭区间。</p> 
 <p><strong>列切片：</strong>逻辑和二维数组一样，想切列，必须先把行全部保留下来</p> 
</blockquote> 
<p><img alt="" height="353" src="https://images2.imgbox.com/b5/a9/bpSBvLRW_o.png" width="1077"><img alt="" height="512" src="https://images2.imgbox.com/7b/e1/k9F04jbz_o.png" width="797"></p> 
<p><img alt="" height="645" src="https://images2.imgbox.com/80/bf/w11PUinR_o.png" width="910"></p> 
<p><img alt="" height="685" src="https://images2.imgbox.com/d4/eb/lk8Rv7qm_o.png" width="677"></p> 
<h3 id="2.4%20DataFrame%E7%9A%84%E8%BF%90%E7%AE%97">2.4 DataFrame的运算</h3> 
<blockquote> 
 <p><strong>运算的三种情况：</strong></p> 
 <ul><li>DataFrame和一个数                                 ==&gt;   广播机制</li><li>DataFrame和数组（numpy、Series)       ==&gt;   索引对齐，axis控制方向 
   <ul><li>DataFrame和 DataFrame                  ==&gt;   索引对齐，不分方向<br>  </li></ul></li></ul> 
 <p><strong>( 1 ) DataFrame之间的运算</strong><br> 同Series一样：</p> 
 <ul><li>在运算中自动对齐相同索引的数据</li><li>如果索引不对应，则补NaN</li></ul> 
 <p></p> 
 <p><strong>默认运算都是列方向</strong><br>  df.mean()                   df.sum()    </p> 
</blockquote> 
<p><img alt="" height="520" src="https://images2.imgbox.com/03/e9/NJjLUvP4_o.png" width="761"></p> 
<p><img alt="" height="484" src="https://images2.imgbox.com/f1/b2/BOkNqAWb_o.png" width="712"></p> 
<p><img alt="" height="376" src="https://images2.imgbox.com/43/a1/nRy6m1rB_o.png" width="617"></p> 
<p><img alt="" height="486" src="https://images2.imgbox.com/ae/e0/3iixF4cv_o.png" width="752"></p> 
<p><img alt="" height="614" src="https://images2.imgbox.com/91/4e/flUSj7VA_o.png" width="1200"></p> 
<p><img alt="" height="316" src="https://images2.imgbox.com/e0/70/S3PcfTKE_o.png" width="686"></p> 
<p><img alt="" height="455" src="https://images2.imgbox.com/6d/61/u5Rf2DsS_o.png" width="703"> <img alt="" height="274" src="https://images2.imgbox.com/91/e4/eDNlWsRH_o.png" width="586"></p> 
<p><img alt="" height="622" src="https://images2.imgbox.com/99/1d/rVWD4Tlm_o.png" width="1200"></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%912.5%20DataFrame%E7%BB%83%E4%B9%A0"><img alt="" height="409" src="https://images2.imgbox.com/82/ae/q9u4GN4j_o.png" width="775"></p> 
<h3 id="2.5%20DataFrame%E7%BB%83%E4%B9%A0%C2%A0">2.5 DataFrame练习 </h3> 
<blockquote> 
 <p><strong>练习：</strong><br> 1.假设ddd是期中考试成绩，ddd2是期末考试成绩，请自由创建ddd2，并将其与ddd相加，求期中期末平均值。</p> 
 <p>2.假设张三期中考试数学被发现作弊，要记为0分，如何实现?<br> 3.李四因为举报张三作弊立功，期中考i试所有科目加100分，如何实现?<br> 4.后来老师发现有一道题出错了，为了安抚学生情绪，给每位学生每个科目都加10分，如何实现?</p> 
</blockquote> 
<h3 id="3.pandas%E4%B8%AD%E7%9A%84None%E5%92%8Cnp.nan">2.6 pandas中的None和np.nan</h3> 
<h4 id="3.1%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">2.6.1 基本概念</h4> 
<blockquote> 
 <p><strong>有两种丢失数据：</strong></p> 
 <ul><li>None</li><li>np.nan(NaN)</li></ul> 
 <p>在python中尽量用NaN，而不是要用None,因为对象比int类型运算慢的多。</p> 
 <p><br><strong>None：</strong></p> 
 <p>None是Python自带的，其类型为python object。因此，None不能参与到任何计算中。<br> object类型的运算要比int类型的运算慢得多<br> 计算不同数据类型求和时间<br> %timeit np.arange(1e5,dtype=xxx).sum()<br>  </p> 
 <p><strong>np.nan：</strong></p> 
 <p>np.nan和任何数运算，得到结果还是nan。<br> np.nan是浮点类型，能参与到计算中。但计算的结果总是NaN。<br> 但可以使用np.nan*()函数来计算nan，此时视nan为0。<br>  </p> 
</blockquote> 
<p><img alt="" height="666" src="https://images2.imgbox.com/d0/3c/Wo9OVgPM_o.png" width="1029"></p> 
<h4 id="3.1.1%20pandas%E4%B8%AD%E7%9A%84None%E5%92%8Cnp.nan%E9%83%BD%E8%A7%86%E4%B8%BAnp.nan">2.6.2 pandas中的None和np.nan都视为np.nan</h4> 
<blockquote> 
 <p>pandas会把None优化为np.nan。</p> 
</blockquote> 
<p><img alt="" height="540" src="https://images2.imgbox.com/56/e2/WgIdNTqz_o.png" width="885"> <img alt="" height="575" src="https://images2.imgbox.com/aa/db/dITbM3qI_o.png" width="1143"></p> 
<p><img alt="" height="211" src="https://images2.imgbox.com/c3/1d/IysFpbEu_o.png" width="712"></p> 
<h4 id="3.1.2%20pandas%E4%B8%AD%E7%9A%84None%E4%B8%8Enp.nan%E6%93%8D%E4%BD%9C">2.6.3 pandas中的None与np.nan操作</h4> 
<blockquote> 
 <ul><li>isnull()</li><li>notnull()</li><li>dropna( )：过滤丢失数据<br>     可以选择过滤的是行还是列(默认为行)<br>     也可以选择过滤的方式how = 'all'</li><li>fillna()：填充丢失数据   <br>     ==&gt;    通常的办法就是是用每一列的某一个聚合指标来对每一列进行填充<br>     可以选择前向填充还是后向填充；向前：从下/右往上/左，向后：从上/左往下右<br>                                                           ‘backfill'  'bfill'   'pad'    'ffill'<br>     对于DataFrame来说，还要选择填充的轴axis。记住，对于DataFrame来说：</li></ul> 
 <p>                 axis=0：index/行<br>                  axis=1：columns/列</p> 
</blockquote> 
<p><img alt="" height="550" src="https://images2.imgbox.com/89/c1/ApvdPvXZ_o.png" width="648"></p> 
<p><img alt="" height="591" src="https://images2.imgbox.com/47/79/22czYtu4_o.png" width="683"></p> 
<p><img alt="" height="491" src="https://images2.imgbox.com/c1/a6/resH4mLM_o.png" width="753"></p> 
<p><img alt="" height="258" src="https://images2.imgbox.com/0e/71/gnTThHzg_o.png" width="1002"> <img alt="" height="585" src="https://images2.imgbox.com/39/85/M31ySx9i_o.png" width="673"> </p> 
<p><img alt="" height="545" src="https://images2.imgbox.com/6d/2b/uNMHqMXA_o.png" width="802"></p> 
<p><img alt="" height="508" src="https://images2.imgbox.com/e6/40/X2Ue4Io4_o.png" width="796"></p> 
<p><img alt="" height="483" src="https://images2.imgbox.com/43/7c/ATHxVC39_o.png" width="829"></p> 
<p> <img alt="" height="314" src="https://images2.imgbox.com/2a/84/CVac3dg1_o.png" width="655"></p> 
<p></p> 
<h2 id="3.pandas%E5%A4%9A%E5%B1%82%E7%BA%A7%E7%B4%A2%E5%BC%95%C2%A0%20%C2%A0%20%C2%A0%C2%A0">3.pandas多层级索引      </h2> 
<p><img alt="" height="428" src="https://images2.imgbox.com/d8/dc/U9IbKIL9_o.png" width="1200"></p> 
<p><img alt="" height="660" src="https://images2.imgbox.com/01/24/aDeMcMTV_o.png" width="1200"></p> 
<h3 id="3.1%20%E5%A4%9A%E5%B1%82%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA">3.1 多层级索引的创建</h3> 
<blockquote> 
 <p><strong>1)隐式构造</strong><br>         最常见的方法是给DataFrame构造函数的index参数传递两个或更多的数组</p> 
 <ul><li>Series也可以创建多层索引</li></ul> 
 <p><strong>2)显示构造pd.Multilndex</strong></p> 
 <ul><li>使用数组</li><li>使用tuple</li><li>使用from_product    ==&gt;  最简单，推荐使用</li></ul> 
</blockquote> 
<p><img alt="" height="543" src="https://images2.imgbox.com/aa/9d/uWI6p8vz_o.png" width="834"></p> 
<p><img alt="" height="375" src="https://images2.imgbox.com/ba/e1/wgkeXMOL_o.png" width="1200"><img alt="" height="404" src="https://images2.imgbox.com/74/36/RycV53jf_o.png" width="1200"></p> 
<h3 id="3.2%20%E5%A4%9A%E5%B1%82%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BF%E9%97%AE%E4%B8%8E%E5%88%87%E7%89%87">3.2 多层级索引的访问与切片</h3> 
<blockquote> 
 <p><strong>多层级索引访问的核心：</strong><br>         1.多层级的索引的表达方式变成元组<br>         2.隐式索引的访问方式不受影响</p> 
 <p></p> 
 <p><span style="color:#fe2c24;">建议隐式索引</span>，这样不用写乱七八糟的元组。 ==&gt; 隐式索引永远是<span style="color:#fe2c24;">单层的</span></p> 
 <p><strong>1) Series的操作</strong><br> 【重要】对于Series来说，直接中括号[ ]与使用.loc[ ]完全一样，推荐使用.loc[ ]和切片。</p> 
 <ul><li>索引</li><li>切片</li></ul> 
 <p><strong>2)  DataFrame的操作</strong></p> 
 <ul><li>可以直接使用列名称来进行列索引<br>      行多级索引的索引和切片操作<br>      列多级索引的索引和切片操作</li><li>使用行索引需要用ix()，loc[ ]等函数<br> 【极其重要】推荐使用loc[ ]函数<br><strong>注意：</strong>在对行索引的时候，若一级行索引还有多个，对二级行索引会遇到问题！也就是说，无法直接对二级索引进行索引，必须二级索引变成一级索引后才能对其进行索引！</li></ul> 
</blockquote> 
<blockquote> 
 <p>多级索引用元组表示，其余与Series访问一样。 </p> 
</blockquote> 
<p><img alt="" height="544" src="https://images2.imgbox.com/f0/d7/SwXx09Zw_o.png" width="810"><img alt="" height="427" src="https://images2.imgbox.com/d3/12/WFC9kq5A_o.png" width="735"></p> 
<p><img alt="" height="439" src="https://images2.imgbox.com/55/5a/EGN1EXJx_o.png" width="715"></p> 
<p><img alt="" height="568" src="https://images2.imgbox.com/a8/fb/vYYyFH6W_o.png" width="818"></p> 
<p><img alt="" height="404" src="https://images2.imgbox.com/d1/c6/XBSbBdCf_o.png" width="679"></p> 
<p><img alt="" height="369" src="https://images2.imgbox.com/bf/b7/FSn5Sgxq_o.png" width="968"></p> 
<h3 id="3.3%20%E5%A4%9A%E5%B1%82%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8F%98%E5%BD%A2%E6%93%8D%E4%BD%9C%EF%BC%88stack%EF%BC%89">3.3 多层级索引的变形操作（stack）</h3> 
<blockquote> 
 <ul><li>stack()         ==&gt;  column变成index</li><li>unstack()     ==&gt;  index变成column</li></ul> 
 <p>【小技巧】使用stack()的时候，level等于哪一个，哪一个就消失，出现在行里。<br> 【小技巧】使用unstack()的时候，level等于哪一个，哪一个就消失，出现在列里。</p> 
 <p><br>   ==&gt; 从里往外数，就是-1 -2 -3；从外往里数，就是0 1 2</p> 
</blockquote> 
<p><img alt="" height="582" src="https://images2.imgbox.com/bd/c7/QQbcidL2_o.png" width="765"></p> 
<p><img alt="" height="555" src="https://images2.imgbox.com/e1/52/zlmOcdka_o.png" width="874"><img alt="" height="283" src="https://images2.imgbox.com/9c/b9/TMyDdbDj_o.png" width="798"></p> 
<p><img alt="" height="650" src="https://images2.imgbox.com/ef/83/pQzZ3IvX_o.png" width="705"><img alt="" height="323" src="https://images2.imgbox.com/d0/86/MtAbbfzn_o.png" width="569"></p> 
<h2 id="4.pandas%E6%B1%87%E6%80%BB%E6%93%8D%E4%BD%9C">4.pandas汇总操作</h2> 
<blockquote> 
 <p><strong> pandas的拼接分为两种：</strong></p> 
 <ul><li>级联：pd.concat，pd.append</li><li>合并：pd.merge，pd.join</li></ul> 
</blockquote> 
<h3 id="4.1%20%E7%BA%A7%E8%81%94%C2%A0">4.1 级联 </h3> 
<h4 id="4.1.1%C2%A0%E4%BD%BF%E7%94%A8pd.concat()%E7%BA%A7%E8%81%94">4.1.1 使用pd.concat()级联</h4> 
<blockquote> 
 <ul><li>级联方向上的<strong>形状不同</strong>，同样可以连接</li><li>以索引对齐的方式连接，所以跟<strong>顺序没关系</strong><br>  </li></ul> 
 <p>pandas使用pd.concat函数，与np.concatenate函数类似，只是多了一些参数:<br>         objs                                       ==&gt;   要参与级联的pandas对象的列表、元组   <br>         axis=0<br>         join='outer'</p> 
 <p>        join_axes=None</p> 
 <p>        ignore_index=False              ==&gt;   原始索引无意义，可以忽略索引级联</p> 
 <p>        keys                                      ==&gt;   可以弄多级索引</p> 
 <p><br>  </p> 
 <ul><li>原始表的索引没有实际意义，可以忽略处理，用ignore_index避免重复；</li><li>如果级联后，原始索引不能忽略，但又希望避免重复，可以用keys做成多层级表格</li></ul> 
</blockquote> 
<p><img alt="" height="551" src="https://images2.imgbox.com/be/78/K3Ra2gAu_o.png" width="1200"><img alt="" height="486" src="https://images2.imgbox.com/f3/96/sVz82byv_o.png" width="906"></p> 
<p><img alt="" height="429" src="https://images2.imgbox.com/8f/1d/2DaiNjct_o.png" width="903"></p> 
<p><img alt="" height="735" src="https://images2.imgbox.com/c2/db/6rQ3xm9x_o.png" width="979"></p> 
<p><img alt="" height="622" src="https://images2.imgbox.com/88/5f/v3IvP2N9_o.png" width="785"></p> 
<p><img alt="" height="484" src="https://images2.imgbox.com/3b/67/F9H4ICba_o.png" width="908"></p> 
<p><img alt="" height="532" src="https://images2.imgbox.com/cd/35/dpNhD8qd_o.png" width="1181"><img alt="" height="692" src="https://images2.imgbox.com/49/5c/b89Qq5lx_o.png" width="1039"></p> 
<p></p> 
<h4 id="4.1.2%20%E4%B8%8D%E5%8C%B9%E9%85%8D%E7%BA%A7%E8%81%94">4.1.2 不匹配级联</h4> 
<blockquote> 
 <p><strong>不匹配</strong>指的是级联的维度的索引不一致。例如纵向级联时列索引不一致，横向级联时行索引不一致<br><strong>有3种连接方式：</strong></p> 
 <ul><li>外连接：补NaN(默认模式)     ==&gt;  outer  保存连接的表的所有字段，缺失值补空值</li><li>内连接：只连接匹配的项       ==&gt;   inner  只保留公共字段     【不建议】</li><li>连接指定轴 join_axes</li></ul> 
</blockquote> 
<p><img alt="" height="523" src="https://images2.imgbox.com/e0/04/aliidHvI_o.png" width="1048"></p> 
<p><img alt="" height="378" src="https://images2.imgbox.com/82/ae/jbPbKP9u_o.png" width="840"></p> 
<p><img alt="" height="403" src="https://images2.imgbox.com/a6/14/CHFr30oP_o.png" width="745"></p> 
<h4 id="4.1.3%20%E4%BD%BF%E7%94%A8append()%E5%87%BD%E6%95%B0%E6%B7%BB%E5%8A%A0">4.1.3 使用append()函数添加</h4> 
<blockquote> 
 <p>由于在后面级联的使用非常普遍，因此有一个函数append专门用于在后面添加。<br><strong>注意：</strong>append函数只是沿着axis=0的方向进行级联</p> 
</blockquote> 
<p><img alt="" height="505" src="https://images2.imgbox.com/22/fa/pt8ZgsVl_o.png" width="1038"></p> 
<p><img alt="" height="454" src="https://images2.imgbox.com/31/ba/X4tpXYc9_o.png" width="716"></p> 
<h3 id="4.2%20%E5%90%88%E5%B9%B6">4.2 合并</h3> 
<blockquote> 
 <p>合并只跟列有关，两张表要去找<strong>默认</strong>内容相同的列来进行合并，也可以columns不相同。<br> 合并的两张表一定存在至少一列，在内容上有对应关系：</p> 
 <ul><li>一对一合并</li><li>多对一合并</li><li>多对多合并</li><li>key的规范化    ==&gt;   1.使用on=显式指定哪一列为key,当有多个key相同时使用；<br>                         ==&gt;   2.使用left_on和right_on指定左右两边的列作为key，当左右两边的                                     key都不想等时使用。</li></ul> 
 <p>合并可以同时参考多列进行，这取决于你的业务需求。<br>  </p> 
 <p>merge与concat的区别在于，merge需要依据某一共同【列】来进行合并<br> 使用pd.merge()合并时，会自动根据两者相同column名称的那一列，作为key来进行合并。注意：每一列元素的顺序不要求一致</p> 
</blockquote> 
<p><img alt="" height="303" src="https://images2.imgbox.com/1c/75/wM9zkpCL_o.png" width="891"></p> 
<p><img alt="" height="116" src="https://images2.imgbox.com/71/e5/eA0hlPC1_o.png" width="685"></p> 
<h4 id="4.2.1%20%E4%B8%80%E5%AF%B9%E4%B8%80%E5%90%88%E5%B9%B6%C2%A0"><strong>4.2.1 一对一合并 </strong></h4> 
<p><img alt="" height="222" src="https://images2.imgbox.com/1f/91/eHWKestt_o.png" width="594"></p> 
<p><img alt="" height="243" src="https://images2.imgbox.com/b9/8b/bR9PDVyF_o.png" width="537">  </p> 
<p><img alt="" height="263" src="https://images2.imgbox.com/e6/e9/o3Dd9pOB_o.png" width="548"></p> 
<p><img alt="" height="346" src="https://images2.imgbox.com/8d/7c/xpQQh1eW_o.png" width="497"></p> 
<h4 id="4.2.2%20%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%90%88%E5%B9%B6"><strong>4.2.2 多对一合并</strong></h4> 
<p><img alt="" height="222" src="https://images2.imgbox.com/ef/ce/7wLbxm7e_o.png" width="594"></p> 
<p><img alt="" height="276" src="https://images2.imgbox.com/9e/61/I1TrDvmM_o.png" width="623"></p> 
<p><img alt="" height="283" src="https://images2.imgbox.com/4d/5f/hrEmLRPL_o.png" width="636"></p> 
<h4 id="4.2.3%20%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%90%88%E5%B9%B6"><strong>4.2.3 多对多合并</strong></h4> 
<p><img alt="" height="427" src="https://images2.imgbox.com/b3/9b/4TbZzzw4_o.png" width="960"></p> 
<p><img alt="" height="276" src="https://images2.imgbox.com/a3/65/QspJlYW3_o.png" width="623"></p> 
<p> <img alt="" height="423" src="https://images2.imgbox.com/36/8c/RwEeixSD_o.png" width="633"></p> 
<p><img alt="" height="311" src="https://images2.imgbox.com/a0/fb/glIi21bV_o.png" width="716"></p> 
<h4 id="4.2.4%20key%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96%C2%A0%C2%A0%C2%A0"><strong>4.2.4 key的规范化 </strong>  </h4> 
<p><img alt="" height="578" src="https://images2.imgbox.com/ec/45/RGG4NPOp_o.png" width="822"></p> 
<p><img alt="" height="275" src="https://images2.imgbox.com/47/2b/7Khuyb4j_o.png" width="719"></p> 
<h4 id="4.2.5%20%E6%B2%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84columns%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%90%88%E5%B9%B6%C2%A0"><strong>4.2.5 没有相同的columns也可以合并 </strong></h4> 
<p><img alt="" height="488" src="https://images2.imgbox.com/6f/fd/JqFJbaU1_o.png" width="623"></p> 
<p><img alt="" height="266" src="https://images2.imgbox.com/7c/4d/bXie1GNJ_o.png" width="948"></p> 
<p><img alt="" height="230" src="https://images2.imgbox.com/f4/29/ooOoCyva_o.png" width="616"></p> 
<p><img alt="" height="190" src="https://images2.imgbox.com/e5/62/M0ppEFDS_o.png" width="642"></p> 
<p><img alt="" height="286" src="https://images2.imgbox.com/e1/30/sGTo18H0_o.png" width="647"></p> 
<h4 id="4.2.6%20%E5%86%85%E5%90%88%E5%B9%B6%E4%B8%8E%E5%A4%96%E5%90%88%E5%B9%B6%C2%A0">4.2.6 内合并与外合并 </h4> 
<blockquote> 
 <ul><li>内合并：只保留两者都有的key (默认模式)</li><li>外合并how='guter'：补NaN    ==&gt;  【推荐使用】</li><li>左合并、右合并: how='left' , how='right'     ==&gt;   根据左表和右表来保留内容</li></ul> 
 <p><strong>pd.merge()</strong><br> 1.都是以列为合并项；<br> 2.参与合并的列必须满足一对一、一对多、多对多关系中的至少一种；</p> 
 <p>3.参与合并的列的选择应该是选择离散型数据而不是连续型数据。</p> 
 <ul><li>how='inner'合并的方式内合并外合并左合并右合并</li><li>on指定参与合并的列用于有多列标签相同的情况</li><li>left_on\right_on分别制定左右表参与合并的列用于两张表参与合并的列标签不同的情况</li><li>suffiexes一般与on参数一起使用，给相同列标签但是没有参与合并的列添加后缀</li><li>left_index\right_index指定索引作为合并的参考值</li></ul> 
 <p></p> 
 <p><strong>merge的内合并与concat的内合并的区别：</strong></p> 
 <ul><li>inner内合并，只保留相同的【内容】</li><li>concat 的内连接：只保留相同的【标签】</li></ul> 
</blockquote> 
<p><img alt="" height="470" src="https://images2.imgbox.com/39/96/PqQPz6Ds_o.png" width="684"></p> 
<p><img alt="" height="255" src="https://images2.imgbox.com/d8/90/NzgVZSIj_o.png" width="701"><img alt="" height="264" src="https://images2.imgbox.com/d4/c8/Xj66lAEy_o.png" width="694"></p> 
<p><img alt="" height="230" src="https://images2.imgbox.com/db/89/5ZJqW2yY_o.png" width="768"></p> 
<h4 id="4.2.7%20%E5%88%97%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%C2%A0">4.2.7 列冲突的解决 </h4> 
<blockquote> 
 <p>当列冲突时，即有多个列名称相同时需要使用on=来指定哪一个列作为key，配合suffixes指定冲突列名；</p> 
 <p>可以使用suffixes=自己指定后缀。<br>  </p> 
</blockquote> 
<p><img alt="" height="280" src="https://images2.imgbox.com/09/15/sHLEWVom_o.png" width="748"></p> 
<p><img alt="" height="426" src="https://images2.imgbox.com/78/8e/jqXHciNl_o.png" width="740"><img alt="" height="470" src="https://images2.imgbox.com/c1/14/tEDcyHp1_o.png" width="964"></p> 
<h4 id="4.2.8%20%E7%AE%80%E6%98%93%E5%9B%9E%E9%A1%BE%C2%A0">4.2.8 简易回顾+练习 </h4> 
<p><strong>【简易回顾】</strong></p> 
<p><img alt="" height="674" src="https://images2.imgbox.com/64/c7/rKkCSKjh_o.png" width="857"></p> 
<p><img alt="" height="229" src="https://images2.imgbox.com/aa/9f/O1OiLccm_o.png" width="758"></p> 
<p><img alt="" height="507" src="https://images2.imgbox.com/e6/71/404LNpmm_o.png" width="689"><img alt="" height="212" src="https://images2.imgbox.com/49/48/81ZZghWw_o.png" width="811"></p> 
<p><img alt="" height="211" src="https://images2.imgbox.com/25/33/fNUWAh0U_o.png" width="791"><strong>【练习一】</strong></p> 
<p><img alt="" height="114" src="https://images2.imgbox.com/e2/87/Jcrl8S8G_o.png" width="1020"></p> 
<p><img alt="" height="639" src="https://images2.imgbox.com/33/df/lYLme8H9_o.png" width="879"></p> 
<p> <img alt="" height="273" src="https://images2.imgbox.com/3f/82/M6nhqWr3_o.png" width="688"><img alt="" height="266" src="https://images2.imgbox.com/33/81/3LnWyTE2_o.png" width="861"></p> 
<p><img alt="" height="260" src="https://images2.imgbox.com/9a/a8/cg63fsnW_o.png" width="883"><strong>【练习二】</strong></p> 
<blockquote> 
 <p> 假设有两个同学都叫李四，ddd5、ddd6都是张三和李四的成绩表，如何合并?</p> 
</blockquote> 
<p><img alt="" height="629" src="https://images2.imgbox.com/0d/b2/iZrzMFqB_o.png" width="844"></p> 
<p><img alt="" height="258" src="https://images2.imgbox.com/ee/2b/pUOuI7TX_o.png" width="791"></p> 
<h2 id="5.%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E7%BE%8E%E5%9B%BD%E5%90%84%E5%B7%9E%E4%BA%BA%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%C2%A0">5.pandas的数据处理</h2> 
<blockquote> 
 <p><strong>先了解数据：</strong></p> 
 <ul><li>df.read()</li><li>df.info()</li><li>df.description()</li></ul> 
 <p><strong>原始数据最基本的操作包括如下三步：</strong></p> 
 <ul><li>空值的处理</li><li>重复值的处理</li><li>异常值的处理 </li></ul> 
</blockquote> 
<h3 id="5.1%20%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">5.1 删除重复元素</h3> 
<blockquote> 
 <p>使用duplicated()函数检测重复的行，返回元素为布尔类型的Series对象，每个元素对应一行，如果该行不是第一次出现，则元素为True</p> 
 <ul><li>使用drop_duplicates()函数删除重复的行</li><li>使用duplicated()函数查看重复的行</li></ul> 
 <p>如果使用pd.concat([df1,df2],axis = 1)生成新的DataFrame，新的df中columns相同，使用duplicate()和drop_duplicates()都会出问题。</p> 
</blockquote> 
<p><img alt="" height="623" src="https://images2.imgbox.com/7f/b6/ccjUo3Lg_o.png" width="872"></p> 
<p><img alt="" height="504" src="https://images2.imgbox.com/c0/9b/tJt3OtVE_o.png" width="867"></p> 
<p><img alt="" height="667" src="https://images2.imgbox.com/96/92/tNyvEUi5_o.png" width="808"></p> 
<p><img alt="" height="688" src="https://images2.imgbox.com/ac/7c/81DuWWzx_o.png" width="790"></p> 
<p><img alt="" height="473" src="https://images2.imgbox.com/5f/3a/iSJNYrcU_o.png" width="812"></p> 
<p><img alt="" height="428" src="https://images2.imgbox.com/87/34/NDxTIJ1y_o.png" width="967">​​​​​​​</p> 
<h3 id="5.2%20%E6%98%A0%E5%B0%84%C2%A0">5.2 映射 </h3> 
<blockquote> 
 <p><strong>映射的含义︰</strong>创建一个映射关系列表，把values元素和一个特定的标签或者字符串绑定包含三种操作︰</p> 
 <ul><li>replace()函数︰替换元素(DataFramelSeries的函数)</li><li>最重要：map()函数︰新建一列(Series的函数)</li><li>rename()函数：替换索引(DataFrame的函数)</li></ul> 
 <p><br><strong>fillna和replace的区别：</strong></p> 
 <p>        fillna负责空值的填充，而replace是任意值的填充。即replace是fillna的高级版本。</p> 
</blockquote> 
<h4 id="5.2.1%20replace()%E5%87%BD%E6%95%B0%EF%BC%9A%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0%C2%A0%C2%A0">5.2.1 replace()函数：替换元素  </h4> 
<blockquote> 
 <p>使用replace()函数，对values进行替换操作。</p> 
 <p><br><strong>Series替换操作：</strong></p> 
 <ul><li>单值替换   </li><li>列表替换</li><li>字典替换（推荐）</li></ul> 
 <p><strong>Series参数说明∶</strong></p> 
 <ul><li>method：对指定的值使用相邻的值填充 </li><li>limit：设定填充次数</li></ul> 
</blockquote> 
<p><strong>1)替换字符串</strong></p> 
<p><img alt="" height="460" src="https://images2.imgbox.com/81/65/QLskR0ya_o.png" width="732"><strong>2）替换数字</strong> </p> 
<p><img alt="" height="442" src="https://images2.imgbox.com/6f/d2/841KQFx1_o.png" width="695"></p> 
<p><strong>3)使用列表替换多个值</strong> </p> 
<p><img alt="" height="428" src="https://images2.imgbox.com/f3/3a/AK3vEEJD_o.png" width="764"><strong>4)使用字典替换</strong></p> 
<p><img alt="" height="539" src="https://images2.imgbox.com/07/24/ToB4UCcl_o.png" width="753"><strong>5）使用字典处理某一列的替换</strong></p> 
<p><img alt="" height="467" src="https://images2.imgbox.com/5b/1f/s76yrDbx_o.png" width="723"><img alt="" height="409" src="https://images2.imgbox.com/af/02/GscoDvy3_o.png" width="768"></p> 
<p><img alt="" height="427" src="https://images2.imgbox.com/2c/3d/k5lkqhYZ_o.png" width="782"></p> 
<p><strong>6)正则表达式替换</strong></p> 
<p><img alt="" height="441" src="https://images2.imgbox.com/b0/cc/KCFT8mfm_o.png" width="864"></p> 
<p><strong>7）填充</strong></p> 
<p><img alt="" height="607" src="https://images2.imgbox.com/c2/b6/2ymojepe_o.png" width="895"></p> 
<p><strong>8）小练习</strong> </p> 
<blockquote> 
</blockquote> 
<blockquote> 
 <p>假设课表里有满分的情况，老师认为是作弊，把所有满分的情况r(包括150,300分）都记0分，如何实现? </p> 
</blockquote> 
<p><img alt="" height="388" src="https://images2.imgbox.com/8b/3c/1wteN5OG_o.png" width="654"> </p> 
<p><img alt="" height="443" src="https://images2.imgbox.com/40/69/3bgeE7JY_o.png" width="1078"></p> 
<h4 id="5.2.2%20map()%E5%87%BD%E6%95%B0%EF%BC%9A%E6%96%B0%E5%BB%BA%E4%B8%80%E5%88%97">5.2.2 map()函数：新建一列</h4> 
<blockquote> 
 <p>map是Series的函数，所以通常被用来对某一列进行整体的映射处理。<br>  </p> 
 <ul><li>map()可以使用字典映射新─列数据</li><li>map()中可以使用lambd表达式</li><li>map()中可以使用方法，可以是自定义的方法</li></ul> 
 <p><strong>注意：</strong></p> 
 <ul><li>map()中不能使用sum之类的函数，for循环</li><li>map(字典)字典的键要足以匹配所有的数据，否则出现NaN</li></ul> 
</blockquote> 
<p><strong>1）使用字典映射</strong> </p> 
<p><img alt="" height="671" src="https://images2.imgbox.com/97/4b/jC4Gao5C_o.png" width="759"></p> 
<p><img alt="" height="585" src="https://images2.imgbox.com/6b/20/0hz2WXBA_o.png" width="840"></p> 
<p><strong>2）使用方法映射</strong></p> 
<p><img alt="" height="595" src="https://images2.imgbox.com/74/0b/deMBbtNo_o.png" width="684"></p> 
<p><img alt="" height="659" src="https://images2.imgbox.com/29/d1/oMtaHcTY_o.png" width="850"></p> 
<p><strong>3)lambda处理</strong></p> 
<p> <img alt="" height="439" src="https://images2.imgbox.com/cd/9c/vqKCAmsl_o.png" width="613"></p> 
<h4 id="5.2.3%20%E5%B0%8F%E7%BB%83%E4%B9%A0">5.2.3 小练习</h4> 
<blockquote> 
 <p>新增两列，分别为张三、李四的成绩状态，如果分数低于90，则为"failed"，如果分数高于120，则为"excellent"，其他则为"pass"。</p> 
 <p>【提示】使用函数作为map的参数 </p> 
</blockquote> 
<p><img alt="" height="747" src="https://images2.imgbox.com/93/09/CXECsNVJ_o.png" width="1200"><img alt="" height="251" src="https://images2.imgbox.com/23/8f/dWnL3JQc_o.png" width="842"></p> 
<p><img alt="" height="447" src="https://images2.imgbox.com/5d/cf/DxuDKQm2_o.png" width="760"></p> 
<h4 id="5.2.4%20rename()%E5%87%BD%E6%95%B0%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%B4%A2%E5%BC%95">5.2.4 rename()函数：替换索引</h4> 
<blockquote> 
 <p><strong>使用rename()函数替换行索引：</strong></p> 
 <ul><li>mapper替换所有索引</li><li>index替换行索引</li><li>columns替换列索引</li><li>level指定多维索引的维度</li></ul> 
</blockquote> 
<p><img alt="" height="260" src="https://images2.imgbox.com/93/77/yBdWBD3R_o.png" width="764"><img alt="" height="653" src="https://images2.imgbox.com/dd/9c/NfzCubAx_o.png" width="895"><img alt="" height="466" src="https://images2.imgbox.com/5b/74/HUeQDGl4_o.png" width="945"></p> 
<p><img alt="" height="363" src="https://images2.imgbox.com/35/2d/z4yDaQ7N_o.png" width="908"></p> 
<p><img alt="" height="518" src="https://images2.imgbox.com/ce/74/4B9Vhbon_o.png" width="952"></p> 
<p><img alt="" height="359" src="https://images2.imgbox.com/28/d4/GjeP8X7b_o.png" width="1033"><img alt="" height="321" src="https://images2.imgbox.com/c4/d1/TuPwNw26_o.png" width="729"></p> 
<h3 id="5.3%C2%A0%E4%BD%BF%E7%94%A8%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BC%82%E5%B8%B8%E5%80%BC%E6%A3%80%E6%B5%8B%E5%92%8C%E8%BF%87%E6%BB%A4">5.3 使用聚合操作对数据异常值检测和过滤</h3> 
<blockquote> 
 <p>使用<strong>describe()函数</strong>查看每一列的描述性统计量。 ==&gt; 只对可以运算的列有效</p> 
 <p>使用<strong>std()函数</strong>可以求得DataFrame对象每一列的标准差。==&gt; 异常值的通用界定方法</p> 
 <p>                                                                                                  |data|&gt;3*|std()|       </p> 
 <p><strong>离群点的检测：</strong>数值型的数据都可以使用离群点的方式来检测异常<br>  </p> 
</blockquote> 
<h4 id="5.3.1%20%E6%9F%A5%E7%9C%8B%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%C2%A0">5.3.1 查看表格数据信息的常用方法 </h4> 
<blockquote> 
 <p>df.dtypes     df.head()    df.tail()    df.info()    df.describe()</p> 
</blockquote> 
<p><img alt="" height="707" src="https://images2.imgbox.com/5d/9a/aUX3kyb9_o.png" width="784"></p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/30/0a/3mqLKDUn_o.png" width="808"></p> 
<p><img alt="" height="284" src="https://images2.imgbox.com/ad/8e/VD0X93hT_o.png" width="744"><img alt="" height="406" src="https://images2.imgbox.com/e2/9e/AMokxyhc_o.png" width="802"><img alt="" height="246" src="https://images2.imgbox.com/02/03/wpBNwQNo_o.png" width="621"> </p> 
<h4 id="5.3.2%20%E5%BC%82%E5%B8%B8%E5%80%BC%E5%A4%84%E7%90%86">5.3.2 异常值处理</h4> 
<blockquote> 
 <p><strong>异常值通用的界定办法：</strong></p> 
 <ul><li>如果数据是呈标准正态分布的，/data &gt;3*/data.std()/</li><li>离群点的检测：数值型的数据都可以使用离群点的方式来检测异常</li></ul> 
</blockquote> 
<p><img alt="" height="213" src="https://images2.imgbox.com/98/81/v4TC63qG_o.png" width="757"></p> 
<p><img alt="" height="601" src="https://images2.imgbox.com/ce/f6/VXRJ2fmo_o.png" width="932"></p> 
<p><img alt="" height="591" src="https://images2.imgbox.com/a8/26/NfS6FG6z_o.png" width="1057"></p> 
<p> </p> 
<h3 id="5.4%20%E6%8E%92%E5%BA%8F%C2%A0">5.4 排序 </h3> 
<blockquote> 
 <p><strong>使用.take()函数排序：</strong><br>         take()函数接受一个索引列表，用数字表示</p> 
 <p>        eg : df.take([1,3,4,2,5])<br> 可以借助np.random.permutation()函数随机排序<br><br><strong>随机抽样：</strong><br> 当DataFrame规模足够大时，直接使用np.random.randint()函数，就配合take()函数实现随机抽样。<br>  </p> 
</blockquote> 
<p><strong>1)排序</strong> </p> 
<p><img alt="" height="565" src="https://images2.imgbox.com/03/3e/LzETa56A_o.png" width="1007"></p> 
<p><img alt="" height="326" src="https://images2.imgbox.com/0b/a8/9NzmCeFR_o.png" width="772"></p> 
<p><img alt="" height="329" src="https://images2.imgbox.com/25/54/48SS1BvH_o.png" width="657"></p> 
<p><strong>2）随机抽样</strong><img alt="" height="608" src="https://images2.imgbox.com/39/7b/zpfyUYh0_o.png" width="915"></p> 
<p><img alt="" height="224" src="https://images2.imgbox.com/97/cb/Mplbzxdf_o.png" width="760">  </p> 
<h3 id="5.5%20%E6%95%B0%E6%8D%AE%E5%88%86%E7%B1%BB%2F%E7%BB%84%E5%A4%84%E7%90%86%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91">5.5 数据分类/组处理【重点】</h3> 
<blockquote> 
 <p>数据聚合是数据处理的最后一步，通常是要使每一个数组生成一个单一的数值。</p> 
 <p><strong>数据分类处理：</strong></p> 
 <ul><li>分组：先把数据分为几组</li><li>用函数处理：为不同组的数据应用不同的函数以转换数据</li><li>合并：把不同组得到的结果合并起来</li></ul> 
 <p><strong>数据分类处理的核心：</strong></p> 
 <ul><li>groupby()函数</li><li>groups属性查看分组情况</li></ul> 
 <p><br><strong>交叉表：</strong><br>         交叉表(cross-tabulation,简称crosstab)是一种用于计算分组频率的特殊透视表。<br><strong>透视表：</strong><br>         透视表(pivot table)是各种电子表格程序和其他数据分析软件中一种常见的数据汇总工具。它根据一个或多个键对数据进行聚合，并根据行和列上得分组建将数据分配到各个矩形区域中。在Python和pandas中，可以通过本章所介绍的groupby功能以及（能够利用层次化索引的）DataFrame有一个pivot_table方法，此外还有一个顶级的pandas.pivot_table函数。除了能为groupby提供便利之外，pivot_table还可以添加分项小计(也叫margins )。</p> 
</blockquote> 
<h4 id="5.5.1%20%E5%8D%95%E5%AD%97%E6%AE%B5%E5%88%86%E7%BB%84%C2%A0">5.5.1 单字段分组 </h4> 
<p><img alt="" height="498" src="https://images2.imgbox.com/6d/a6/ufyAj6c9_o.png" width="1190"></p> 
<p><img alt="" height="326" src="https://images2.imgbox.com/3d/c1/GxmEh0tL_o.png" width="991"><img alt="" height="247" src="https://images2.imgbox.com/cd/70/Qg7vEYrv_o.png" width="1195"></p> 
<p><img alt="" height="181" src="https://images2.imgbox.com/bc/1e/fD2u2OHT_o.png" width="810"><img alt="" height="244" src="https://images2.imgbox.com/24/f6/XTeAaCPy_o.png" width="802"></p> 
<p><img alt="" height="246" src="https://images2.imgbox.com/5e/21/DUUL4job_o.png" width="764"></p> 
<p> <img alt="" height="160" src="https://images2.imgbox.com/e7/19/WPhf8kr0_o.png" width="662"></p> 
<p><img alt="" height="520" src="https://images2.imgbox.com/a1/79/MK8vMv8L_o.png" width="950"><img alt="" height="151" src="https://images2.imgbox.com/da/3b/XioXInRX_o.png" width="679"></p> 
<p><img alt="" height="241" src="https://images2.imgbox.com/60/ea/Ab4yXSVv_o.png" width="732"></p> 
<p><img alt="" height="513" src="https://images2.imgbox.com/fa/76/28EUav67_o.png" width="1066"></p> 
<h4 id="5.5.2%20%E5%A4%9A%E5%AD%97%E6%AE%B5%E5%88%86%E7%BB%84">5.5.2 多字段分组</h4> 
<p><img alt="" height="373" src="https://images2.imgbox.com/40/70/34LZ4Vjx_o.png" width="1140"></p> 
<p><img alt="" height="474" src="https://images2.imgbox.com/ca/3f/Lus4CXa6_o.png" width="815"><img alt="" height="420" src="https://images2.imgbox.com/aa/24/4l4mVUXv_o.png" width="940"></p> 
<p><img alt="" height="417" src="https://images2.imgbox.com/4f/19/dIwu3nyd_o.png" width="1109"> </p> 
<h4 id="5.5.3%20%E9%80%8F%E8%A7%86%E8%A1%A8%C2%A0">5.5.3 透视表 </h4> 
<blockquote> 
 <p><strong>透视表：</strong><br>         透视表(pivot table)是各种电子表格程序和其他数据分析软件中一种常见的数据汇总工具。它根据一个或多个键对数据进行聚合，并根据行和列上得分组建将数据分配到各个矩形区域中。在Python和pandas中，可以通过本章所介绍的groupby功能以及（能够利用层次化索引的）DataFrame有一个pivot_table方法，此外还有一个顶级的pandas.pivot_table函数。除了能为groupby提供便利之外，pivot_table还可以添加分项小计(也叫margins )。</p> 
</blockquote> 
<p><img alt="" height="391" src="https://images2.imgbox.com/c4/0b/xS6hdMAf_o.png" width="1167"></p> 
<p><img alt="" height="375" src="https://images2.imgbox.com/99/6d/cLkFOIu5_o.png" width="1171"><img alt="" height="372" src="https://images2.imgbox.com/7e/ad/Ko1MeeCn_o.png" width="1160"> </p> 
<h4 id="5.5.4%20%E4%BA%A4%E5%8F%89%E8%A1%A8">5.5.4 交叉表</h4> 
<blockquote> 
 <p><strong>交叉表：</strong><br>         交叉表(cross-tabulation,简称crosstab)是一种用于计算分组<strong>频率</strong>的特殊透视表。</p>         一种特殊的透视表， 
 <strong>用于统计个数</strong>。直接对一个对象操作。 
</blockquote> 
<p><img alt="" height="355" src="https://images2.imgbox.com/b4/28/e08iM53j_o.png" width="780"><img alt="" height="350" src="https://images2.imgbox.com/88/39/BDruEPfG_o.png" width="617"></p> 
<h3 id="5.6%20%E9%AB%98%E7%BA%A7%E8%81%9A%E5%90%88">5.6 高级聚合</h3> 
<blockquote> 
 <p><strong>使用groupby分组后，也可以使用transform和apply提供自定义函数实现更多的运算。</strong></p> 
 <ul><li>df.groupby("item')['price'].sum()     &lt;==&gt;   df.groupby('item')['price'].apply(np.sum)</li><li>transform和apply都会进行运算，在transform或者apply中传入函数即可</li><li>transform和apply也可以传入一个lambda表达式</li></ul> 
 <p><strong>注意：</strong></p> 
 <ul><li>transform会自动匹配列索引返回值，不去重</li><li>apply 会根据分组情况返回值，去重</li></ul> 
</blockquote> 
<h4 id="5.6.1%20apply()%E5%87%BD%E6%95%B0"><strong>5.6.1 apply()函数</strong></h4> 
<p><img alt="" height="243" src="https://images2.imgbox.com/dd/cc/JpIFdKWm_o.png" width="662"></p> 
<p><img alt="" height="264" src="https://images2.imgbox.com/f6/68/VlvmsA7G_o.png" width="698"><img alt="" height="557" src="https://images2.imgbox.com/5b/ce/4GUdyFf7_o.png" width="912"></p> 
<p><img alt="" height="570" src="https://images2.imgbox.com/89/4e/HsmiIinW_o.png" width="695"></p> 
<p><img alt="" height="360" src="https://images2.imgbox.com/6b/7b/tbPqSF50_o.png" width="693"></p> 
<p><img alt="" height="523" src="https://images2.imgbox.com/31/a2/2cJDul22_o.png" width="799"></p> 
<p><img alt="" height="495" src="https://images2.imgbox.com/86/aa/GRbu8FPX_o.png" width="879"></p> 
<h4 id="5.6.2%20transform()%E5%87%BD%E6%95%B0%C2%A0"><strong>5.6.2 transform()函数</strong> </h4> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <ul><li>transform会自动匹配列索引返回值，不去重</li><li>apply 会根据分组情况返回值，去重</li></ul> 
</blockquote> 
<p><img alt="" height="462" src="https://images2.imgbox.com/7d/6f/tYOYDPKg_o.png" width="873"></p> 
<h4 id="5.6.3%20%E5%B0%8F%E7%BB%83%E4%B9%A0">5.6.3 小练习</h4> 
<blockquote> 
 <p>假设菜市场张大妈在卖菜，有以下属性︰<br>         菜品(item)：萝卜，白菜，辣椒，冬瓜</p> 
 <p>        颜色(color)：白，青，红<br>         重量(weight)<br>         价格(price)</p> 
 <p><br> 1.以属性为列索引，创建一个DataFrame对象df</p> 
 <p>2.对df进行聚合操作，求出颜色为白色的价格总和</p> 
 <p>        df. groupby ("color")["price"].sum()<br> 3.对df进行聚合操作，求出萝卜的所有重量(包括白萝卜，胡萝卜，青萝卜)以及平均价格</p> 
 <p>        r = df.groupby("item").agg({"weight" :"sum" ,"price" :"mean"})</p> 
 <p>4.使用merge合并总重量及平均价格</p> 
 <p>        pd.merge(df, r，left_on="item",right_index=True)</p> 
</blockquote> 
<p> </p> 
<h2 id="%E9%99%84%E8%BD%BDnumpy%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5%EF%BC%9A">附载numpy学习链接：</h2> 
<p><a class="has-card" href="https://mp.csdn.net/mp_blog/creation/editor/125643490" title="numpy学习"><span class="link-card-box"><span class="link-title">numpy学习</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/43/88/xAhRQcqm_o.png">https://mp.csdn.net/mp_blog/creation/editor/125643490</span></span></a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a68f87f453896edc830a2270476ec114/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于Web的酒店客房管理系统的设计与实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b9c8d1c85b3f10b3b1931f78396cd825/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">1.4 网络体系结构与协议分层</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>