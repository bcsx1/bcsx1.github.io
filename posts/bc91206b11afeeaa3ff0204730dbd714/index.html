<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《软件工程》知识点复习总结 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《软件工程》知识点复习总结" />
<meta property="og:description" content="目录 一、软件及软件工程1. 软件的本质2. 软件危机3. 软件工程定义4. 软件生命周期 二、软件过程及过程模型1. 软件过程2. 软件过程模型3. 通用过程模型4. 过程流5. 过程模型5.1 瀑布模型5.2 原型开发模型（快速原型）5.3 增量模型5.4 螺旋模型5.5 专用过程模型5.6 形式化方法模型 三、敏捷开发敏捷开发敏捷原则敏捷过程极限编程XPScrum 四、软件需求软件需求需求工程需求获取技术 五、需求建模需求建模概述基于场景的建模基于数据流的建模基于数据的建模面向状态的建模方法 六、软件设计七、软件测试八、软件项目管理 一、软件及软件工程 1. 软件的本质 计算机软件 指计算机系统中的程序、数据及其相关文档
三要素：
程序：按照特定顺序组织的计算机数据和指令的集合。
数据：使程序能正常执行的数据结构
文档：为了便于理解程序所需的与开发、维护和使用有关的资料
软件 = 程序 &#43; 文档 &#43; 数据
软件的特点
软件是设计开发的，而不是传统意义上生产制造的。
软件不会“磨损”，但会退化。
大多数软件还是用户定制的。
计算机软件可分为七个大类：
系统软件应用软件工程/科学软件嵌入式软件人工智能软件产品线软件WebApp移动App 另一种分类
系统软件：
位于计算机系统中最靠近硬件的一层，其它软件一般都通过系统软件发挥作用，它与具体的应用领域无关。如操作系统、编译程序等。
支持软件：
支持软件的开发和维护的软件。如数据库管理系统、网络软件、软件开发环境等。
应用软件：
特定应用领域专用的软件。如实时软件、嵌入式软件、科学和工程计算软件、事务处理软件、人工智能软件等。
2. 软件危机 软件危机(Software Crisis)：计算机软件的开发和维护过程所遇到的一系列严重问题。
软件危机的表现：
对软件开发成本和进度的估算很不准确，甚至严重拖期和超出预算；无法满足用户需求，导致用户很不满意；质量很不可靠，经常失效；难以更改、调试和增强；没有适当的文档；软件成本比重上升；软件开发生产率跟不上计算机应用迅速深入的趋势。 软件为什么要更新和迭代？
软件必须适应新的计算环境或技术的需要。必须增强软件来实现新的业务需求。软件必须扩展到与其他更现代的系统或数据库进行互操作。必须重新构建软件，使其在网络环境中可行。 为什么会产生软件危机？
与软件本身的特点有关 (难于维护, 逻辑复杂)与软件开发与维护的方法不正确有关 3. 软件工程定义 1993年IEEE进一步给出了一个更全面更具体的定义：
软件工程是：
（1）将系统化的、规范化、可量化的方法应用于软件的开发、运行和维护，即将工程化方法应用于软件。
（2）在（1）中所述方法的研究" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/bc91206b11afeeaa3ff0204730dbd714/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-25T23:11:10+08:00" />
<meta property="article:modified_time" content="2021-06-25T23:11:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《软件工程》知识点复习总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_2" rel="nofollow">一、软件及软件工程</a></li><li><ul><li><a href="#1__4" rel="nofollow">1. 软件的本质</a></li><li><a href="#2__49" rel="nofollow">2. 软件危机</a></li><li><a href="#3__74" rel="nofollow">3. 软件工程定义</a></li><li><a href="#4__99" rel="nofollow">4. 软件生命周期</a></li></ul> 
  </li><li><a href="#_115" rel="nofollow">二、软件过程及过程模型</a></li><li><ul><li><a href="#1__117" rel="nofollow">1. 软件过程</a></li><li><a href="#2__131" rel="nofollow">2. 软件过程模型</a></li><li><a href="#3__140" rel="nofollow">3. 通用过程模型</a></li><li><a href="#4__142" rel="nofollow">4. 过程流</a></li><li><a href="#5__146" rel="nofollow">5. 过程模型</a></li><li><ul><li><a href="#51__158" rel="nofollow">5.1 瀑布模型</a></li><li><a href="#52__193" rel="nofollow">5.2 原型开发模型（快速原型）</a></li><li><a href="#53__235" rel="nofollow">5.3 增量模型</a></li><li><a href="#54__280" rel="nofollow">5.4 螺旋模型</a></li><li><a href="#55__307" rel="nofollow">5.5 专用过程模型</a></li><li><a href="#56__339" rel="nofollow">5.6 形式化方法模型</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_357" rel="nofollow">三、敏捷开发</a></li><li><ul><li><a href="#_360" rel="nofollow">敏捷开发</a></li><li><a href="#_376" rel="nofollow">敏捷原则</a></li><li><a href="#_391" rel="nofollow">敏捷过程</a></li><li><a href="#XP_404" rel="nofollow">极限编程XP</a></li><li><a href="#Scrum_421" rel="nofollow">Scrum</a></li></ul> 
  </li><li><a href="#_453" rel="nofollow">四、软件需求</a></li><li><ul><li><a href="#_464" rel="nofollow">软件需求</a></li><li><a href="#_501" rel="nofollow">需求工程</a></li><li><a href="#_526" rel="nofollow">需求获取技术</a></li></ul> 
  </li><li><a href="#_536" rel="nofollow">五、需求建模</a></li><li><ul><li><a href="#_551" rel="nofollow">需求建模概述</a></li><li><a href="#_557" rel="nofollow">基于场景的建模</a></li><li><a href="#_566" rel="nofollow">基于数据流的建模</a></li><li><a href="#_668" rel="nofollow">基于数据的建模</a></li><li><a href="#_671" rel="nofollow">面向状态的建模方法</a></li></ul> 
  </li><li><a href="#_673" rel="nofollow">六、软件设计</a></li><li><a href="#_674" rel="nofollow">七、软件测试</a></li><li><a href="#_675" rel="nofollow">八、软件项目管理</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>一、软件及软件工程</h2> 
<h3><a id="1__4"></a>1. 软件的本质</h3> 
<p><strong>计算机软件</strong> 指计算机系统中的程序、数据及其相关文档</p> 
<p><strong>三要素：</strong></p> 
<p>程序：按照特定顺序组织的计算机数据和指令的集合。</p> 
<p>数据：使程序能正常执行的数据结构</p> 
<p>文档：为了便于理解程序所需的与开发、维护和使用有关的资料</p> 
<p><strong>软件 = 程序 + 文档 + 数据</strong></p> 
<p><strong>软件的特点</strong></p> 
<ul><li> <p>软件是设计开发的，而不是传统意义上生产制造的。</p> </li><li> <p>软件不会“磨损”，但会退化。</p> </li><li> <p>大多数软件还是用户定制的。</p> </li></ul> 
<p>计算机软件可分为七个大类：</p> 
<ul><li>系统软件</li><li>应用软件</li><li>工程/科学软件</li><li>嵌入式软件</li><li>人工智能软件</li><li>产品线软件</li><li>WebApp</li><li>移动App</li></ul> 
<p>另一种分类</p> 
<ul><li> <p><strong>系统软件：</strong><br> 位于计算机系统中最靠近硬件的一层，其它软件一般都通过系统软件发挥作用，它与具体的应用领域无关。如操作系统、编译程序等。</p> </li><li> <p><strong>支持软件：</strong><br> 支持软件的开发和维护的软件。如数据库管理系统、网络软件、软件开发环境等。</p> </li><li> <p><strong>应用软件：</strong><br> 特定应用领域专用的软件。如实时软件、嵌入式软件、科学和工程计算软件、事务处理软件、人工智能软件等。</p> </li></ul> 
<h3><a id="2__49"></a>2. 软件危机</h3> 
<p><strong>软件危机(Software Crisis)</strong>：计算机软件的开发和维护过程所遇到的一系列严重问题。</p> 
<p><strong>软件危机的表现</strong>：</p> 
<ul><li>对软件开发成本和进度的估算很不准确，甚至严重拖期和超出预算；</li><li>无法满足用户需求，导致用户很不满意；</li><li>质量很不可靠，经常失效；</li><li>难以更改、调试和增强；</li><li>没有适当的文档；</li><li>软件成本比重上升；</li><li>软件开发生产率跟不上计算机应用迅速深入的趋势。</li></ul> 
<p><strong>软件为什么要更新和迭代？</strong></p> 
<ul><li>软件必须适应新的计算环境或技术的需要。</li><li>必须增强软件来实现新的业务需求。</li><li>软件必须扩展到与其他更现代的系统或数据库进行互操作。</li><li>必须重新构建软件，使其在网络环境中可行。</li></ul> 
<p><strong>为什么会产生软件危机？</strong></p> 
<ul><li>与软件本身的特点有关 (难于维护, 逻辑复杂)</li><li>与软件开发与维护的方法不正确有关</li></ul> 
<h3><a id="3__74"></a>3. 软件工程定义</h3> 
<p><strong>1993年IEEE进一步给出了一个更全面更具体的定义：</strong></p> 
<blockquote> 
 <p>软件工程是：<br> （1）将系统化的、规范化、可量化的方法应用于软件的开发、运行和维护，即将工程化方法应用于软件。<br> （2）在（1）中所述方法的研究</p> 
</blockquote> 
<p><strong>《计算机科学技术百科全书》中的定义：</strong></p> 
<blockquote> 
 <p>软件工程是应用计算机科学、数学及管理科学等原理开发软件的工程。软件工程借鉴传统工程的原则、方法，以提高质量、降低成本。其中，计算机科学、数学用于构建模型与算法，工程科学用于制定规范、设计范型(paradigm)、评估成本及确定权衡，管理科学用于计划、资源、质量、成本等。</p> 
</blockquote> 
<p><strong>软件工程的内容</strong></p> 
<ul><li>软件工程是一种层次化的技术。任何工程方法必须构建在质量承诺的基础上。</li><li>软件工程的基础是过程。软件过程将各个技术层次结合在一起，使得合理及时地开发计算机软件成为可能。</li><li>软件工程方法为构建软件提供技术上的解决方法。</li><li>软件工程工具为过程和方法提供自动化或半自动化的支持。<br> <img src="https://images2.imgbox.com/12/a2/QA3kADfv_o.png" alt="在这里插入图片描述"></li></ul> 
<p><strong>软件工具</strong>是指能支持软件生存周期中某一阶段（如系统定义、需求分析、设计、编码、测试或维护等）的需要而使用的软件工具。</p> 
<p><img src="https://images2.imgbox.com/5b/37/Ur0toKxb_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4__99"></a>4. 软件生命周期</h3> 
<p>软件生命周期， 又称为软件生存周期，是软件从产生直到报废的整个时期。</p> 
<p><img src="https://images2.imgbox.com/99/1d/cd2U9Qbf_o.png" alt="在这里插入图片描述"></p> 
<p><strong>思考</strong></p> 
<ol><li>什么是计算机软件？软件的特点是什么？</li><li>何谓“软件危机”？</li><li>主要有哪些软件工程方法？软件工程有哪三个要素？</li><li>软件生命周期主要包含哪几个阶段？</li></ol> 
<h2><a id="_115"></a>二、软件过程及过程模型</h2> 
<h3><a id="1__117"></a>1. 软件过程</h3> 
<ul><li> <p>（教材）一个为创建高质量软件所需要完成的活动、动作和任务的框架 。</p> </li><li> <p>（百度百科）一个为建造高质量软件所需完成的任务的框架，即形成软件产品的一系列步骤，包括中间产品、资源、角色及过程中采取的方法、工具等范畴。</p> </li></ul> 
<p><strong>通用活动</strong></p> 
<ul><li>沟通：包含了与客户(和其他共利益者)之间大量的交流和协作，还包括需求获取以及其他相关活动。</li><li>策划：指为后续的软件工程工作制定计划。它描述了需要执行的技术任务、可能的风险、资源需求、工作产品和工作进度计划。</li><li>建模：包括创建模型和设计两方面。创建模型有助于客户和开发人员更好地理解软件需求；设计可以实现需求。</li><li>构建：包括编码(手写或自动生成)和测试。</li><li>部署：软件(全部或者完成的部分)交付到用户，用户对其进行评测并给出反馈意见。</li></ul> 
<h3><a id="2__131"></a>2. 软件过程模型</h3> 
<ul><li> <p>也称 软件开发模型 或 软件生存周期模型</p> </li><li> <p>是软件生存周期中一系列有序的软件开发活动的流程，是软件开发全部活动的结构框架。</p> </li><li> <p>对一个软件的开发无论其大小，都需要选择一个合适的软件过程模型，主要根据软件的类型、规模，开发方法、开发环境等多种因素来确定。</p> </li></ul> 
<h3><a id="3__140"></a>3. 通用过程模型</h3> 
<p><img src="https://images2.imgbox.com/6f/86/gzMKUENm_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4__142"></a>4. 过程流</h3> 
<p><img src="https://images2.imgbox.com/ae/40/MhjqZZ90_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5__146"></a>5. 过程模型</h3> 
<ul><li>写了再改模型</li><li>瀑布模型</li><li>增量过程模型</li><li>演化过程模型 
  <ul><li>原型开发模型</li><li>螺旋模型</li></ul> </li><li>并发模型</li><li>基于构件的开发</li></ul> 
<h4><a id="51__158"></a>5.1 瀑布模型</h4> 
<p><img src="https://images2.imgbox.com/2d/11/NlmxFKN4_o.png" alt="在这里插入图片描述"><br> 瀑布模型的变体–V模型<br> <img src="https://images2.imgbox.com/6d/8b/ymzcP06v_o.png" alt="在这里插入图片描述"><br> <strong>瀑布模型的特点</strong></p> 
<ul><li>阶段间具有顺序性和依赖性</li><li>推迟实现的观点</li><li>质量保证的观点</li></ul> 
<p><strong>瀑布模型的优点</strong></p> 
<ul><li>可强迫开发人员采用规范的方法（例如，结构化技术）。</li><li>要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证。</li><li>严格地规定了每个阶段必须提交的文档。</li></ul> 
<p><strong>瀑布模型的问题</strong></p> 
<ul><li>难以应对需求变化：客户难以准确表达需求，软件团队很难准确理解需求。</li><li>过于理想：实际项目很少按照该模型给出的顺序进行；</li><li>风险太大：用户必须有耐心，等到系统开发完成才能见到软件；</li><li>阻塞状态：开发者常常被不必要地耽搁。</li></ul> 
<p><strong>瀑布模型的适用场合</strong></p> 
<ul><li>需求相当稳定，客户需求被全面的了解风险管理。</li><li>开发团队对于应用领域非常熟悉。</li><li>外部环境的不可控因素很少。</li><li>小型清晰的项目。</li></ul> 
<h4><a id="52__193"></a>5.2 原型开发模型（快速原型）</h4> 
<p><strong>原型开发模型的产生：</strong></p> 
<ul><li> <p>瀑布模型将软件生命周期划分成独立串行的几个阶段，前一个阶段没有完成便无法开始下一阶段的工作。</p> </li><li> <p>然而完整而准确的需求规格说明是很难得到的，因为：<br> 在开发早期用户往往对系统只有一个模糊的想法，很难完全准确地表达对系统的全面要求</p> </li><li> <p>随着开发工作的推进，用户可能会产生新的要求</p> </li><li> <p>开发者又可能在设计与实现的过程中遇到一些没有预料到的实际困难，需要以改变需求来解脱困境</p> </li></ul> 
<p>原型（prototype）是预期系统的一个可执行版本，它反映了系统性质（如功能、计算结果等）的一个选定的子集。</p> 
<p>一个原型不必满足目标软件的所有约束，其目的是能快速、低成本地构建原型。被开发的原型应交付给客户试用，并收集客户的反馈意见，这些反馈意见可在下一轮迭代中对原型进行改进。在前一个原型需要改进，或者需要扩展其范围的时候，进入下一轮原型的迭代开发</p> 
<p><img src="https://images2.imgbox.com/3a/83/tHxPpv4H_o.png" alt="在这里插入图片描述"><br> <strong>原型开发的优点</strong></p> 
<ul><li> <p>快速开发出可以演示的系统，方便了客户沟通。</p> </li><li> <p>采用迭代技术能够使开发者逐步弄清客户的需求。</p> </li></ul> 
<p><strong>原型的使用策略：</strong></p> 
<ul><li> <p><strong>废弃（throw away）策略</strong><br> 主要用于探索型和实验型原型的开发。这些原型关注于目标系统的某些特性，而不是全部特性，开发这些原型时通常不考虑与探索或实验目的无关的功能、质量、结构等因素，这种原型通常被废丢，然后根据探索或实验的结果用良好的结构和设计思想重新设计目标系统</p> </li><li> <p><strong>追加（add on）策略</strong><br> 主要用于演化型原型的开发。这种原型通常是实现了目标系统中已明确定义的特性的一个子集，通过对它的不断修改和扩充，逐步追加新的要求，最后使其演化成最终的目标系统</p> </li></ul> 
<p><strong>原型模型— 适用情况</strong></p> 
<ul><li> <p>用户定义了一组一般性目标，但不能标识出详细的输入、处理及输出需求；</p> </li><li> <p>开发者可能不能确定算法的有效性、操作系统的适应性或人机交互的形式；</p> </li></ul> 
<h4><a id="53__235"></a>5.3 增量模型</h4> 
<ul><li> <p>增量模型以迭代的方式运用瀑布模型。</p> </li><li> <p>随着时间的推移，发布一系列称为增量的版本，随着每个版本的交付，逐步为用户提供更多的功能。</p> </li></ul> 
<p><img src="https://images2.imgbox.com/c1/f1/2aCeyqtM_o.png" alt="在这里插入图片描述"></p> 
<p><strong>增量模型的使用方法</strong></p> 
<ul><li> <p>软件被作为一系列的增量来进行开发，每一个增量都提交一个可以操作的产品，可供用户评估。</p> </li><li> <p>第一个增量往往是核心产品：满足了基本的需求，但是缺少附加的特性。</p> </li><li> <p>客户使用上一个增量的提交物并进行评价，制定下一个增量计划，说明需要增加的特性和功能。</p> </li><li> <p>重复上述过程，直到最终产品产生为止。</p> </li></ul> 
<p><strong>增量模型的优点</strong></p> 
<ul><li> <p>提高对用户需求的响应：用户看到可操作的早期版本后会提出一些建议和需求，可以在后续增量中调整。</p> </li><li> <p>人员分配灵活：如果找不到足够的开发人员，可采用增量模型，早期的增量由少量人员实现，如果客户反响较好，则在下一个增量中投入更多的人力。</p> </li><li> <p>可规避技术风险：不确定的功能放在后面开发。</p> </li></ul> 
<p><strong>增量模型存在的问题</strong></p> 
<ul><li> <p>每个附加的增量并入现有的软件时，必须不破坏原来已构造好的东西。</p> </li><li> <p>加入新增量时应简单、方便 ——软件的体系结构应当是开放的。</p> </li><li> <p>仍然无法处理需求发生变更的情况。</p> </li><li> <p>管理人员须有足够的技术能力来协调好各增量之间的关系。</p> </li><li> <p>难以确定所有版本共需的公用模块。</p> </li></ul> 
<h4><a id="54__280"></a>5.4 螺旋模型</h4> 
<p>Boehm于1988年提出，是一种演化过程模型，主要针对大型软件项目的开发。<br> 风险驱动的软件开发模型</p> 
<p>采用循环的方式，逐步加深系统定义和实现的深度，确定一系列里程碑，确保stakeholders都支持系统解决方案。</p> 
<p>第一圈一般开发出产品的规格说明，接下来开发产品的原型系统，并在每次迭代中逐步完善，开发不同的软件版本，结合了原型的迭代性质和瀑布模型的可控性、系统性特点。</p> 
<p><img src="https://images2.imgbox.com/3a/8c/m3u6cIgX_o.png" alt="在这里插入图片描述"></p> 
<p><strong>螺旋模型的优点</strong></p> 
<ul><li> <p>结合了原型的迭代性质与瀑布模型的系统性和可控性，是一种风险驱动型的过程模型。</p> </li><li> <p>采用循环的方式逐步加深系统定义和实现的深度，同时更好地理解、应对和降低风险。</p> </li><li> <p>确定一系列里程碑，确保各方都得到可行的系统解决方案。</p> </li><li> <p>始终保持可操作性，直到软件生命周期的结束。</p> </li><li> <p>风险驱动。</p> </li></ul> 
<p><strong>螺旋模型存在的问题</strong></p> 
<ul><li> <p>螺旋模型依赖大量的风险评估专家来保证成功。如果有较大的风险没有被发现和管理，肯定会发生问题。</p> </li><li> <p>软件开发人员应该擅长寻找可能的风险，准确的分析风险，否则将会带来更大的风险。</p> </li></ul> 
<h4><a id="55__307"></a>5.5 专用过程模型</h4> 
<ul><li> <p>基于构件的开发 — 能够使软件复用</p> </li><li> <p>形式化方法模型 — 注重需求的数学规格说明</p> </li><li> <p>面向方面的软件开发 — 为定义、说明、设计和构建方面提供过程和方法</p> </li><li> <p>统一过程 — 一种“用例驱动、以构架为中心的迭代和增量”，软件过程和统一建模语言(UML)紧密结合</p> </li></ul> 
<p><strong>基于构件的开发</strong></p> 
<p>是在一定构件模型的支持下，复用构件库中的一个或多个软件构件，通过组合手段（集成）高效率、高质量地构造应用软件系统的过程。</p> 
<p><img src="https://images2.imgbox.com/8b/8e/FaJ3ov1D_o.png" alt="在这里插入图片描述"></p> 
<p><strong>优点：</strong></p> 
<ul><li> <p>充分利用软件复用，提高了软件开发的效率。</p> </li><li> <p>允许多个项目同时开发，降低了费用，提高了可维护性，可实现分步提交软件产品。</p> </li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li> <p>缺乏通用的构件组装结构标准，风险较大；</p> </li><li> <p>构件可重用性和系统高效性之间不易协调；</p> </li><li> <p>由于过分依赖于构件，构件质量影响着最终产品的质量。</p> </li></ul> 
<h4><a id="56__339"></a>5.6 形式化方法模型</h4> 
<p>从广义上讲，形式化方法是借助数学的方法来解决软件工程领域的问题，主要包括建立精确的数学模型以及对模型的分析活动。<br> 狭义的讲，形式化方法是运用形式化语言，进行形式化的规格描述、模型推理和验证的方法。<br> 形式化方法原则上就是用数学与逻辑的方法描述和验证软件。<br> 可以实现从描述到实现的自动转换。</p> 
<p>优点</p> 
<ul><li>能够开发出无缺陷的软件</li></ul> 
<p>缺点</p> 
<ul><li> <p>成本高、耗时</p> </li><li> <p>对开发人员的技术水平要求高</p> </li></ul> 
<h2><a id="_357"></a>三、敏捷开发</h2> 
<h3><a id="_360"></a>敏捷开发</h3> 
<p>软件更像一个活着的植物，软件开发是自底向上逐步有序的生长过程，类似于植物自然生长</p> 
<p>敏捷开发遵循软件客观规律，不断的进行迭代增量开发，最终交付符合客户价值的产品</p> 
<p>敏捷价值观</p> 
<ul><li> <p>个人和他们之间的交流胜过开发过程和工具</p> </li><li> <p>可运行的软件胜过宽泛的文档</p> </li><li> <p>客户合作胜过合同谈判</p> </li><li> <p>对变更的良好响应胜过按部就班地遵循计划</p> </li></ul> 
<h3><a id="_376"></a>敏捷原则</h3> 
<ol><li>我们最优先要做的是通过<strong>尽早、持续交付有价值的软件</strong>来使客户满意。</li><li>即使在开发的后期，也<strong>欢迎需求变更</strong>。敏捷过程利用变更为客户创造竞争优势。</li><li><strong>经常交付可运行软件</strong>，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好。 （小步快跑）</li><li>在整个项目开发期间，业务人员和开发人员<strong>必须天天都在一起工作</strong>。</li><li>围绕有积极性的<strong>个人</strong>构建项目。给他们提供所需的环境和支持，并且信任他们能够完成工作。</li><li>在团队内部，最富有效果和效率的信息传递方法是<strong>面对面交谈</strong>。</li><li><strong>可运行软件</strong>是进度的首要度量标准。</li><li>提倡<strong>可持续的开发速度</strong>。责任人(sponsor)、开发者和用户应该能够长期保持<strong>稳定的开发速度</strong>。</li><li>不断地<strong>关注优秀的技能和好的设计</strong>会增强敏捷能力。</li><li>简单——是减少不必要工作量的艺术——是必要的</li><li>最好的架构、需求和设计出自于自组织团队。</li><li>每隔一定时间，团队会反省如何才能更有效地工作，并相应调整自己的行为。</li></ol> 
<h3><a id="_391"></a>敏捷过程</h3> 
<p>基于敏捷原则进行的软件开发过程，视为敏捷过程。<br> 敏捷过程模型</p> 
<ul><li>极限编程</li><li>Scrum</li><li>自适应软件开发（ASD）</li><li>动态系统开发方法（DSDM）</li><li>特征驱动开发（FDD）</li><li>精益软件开发（LSD）</li><li>敏捷建模AM</li><li>敏捷统一过程AUP</li></ul> 
<h3><a id="XP_404"></a>极限编程XP</h3> 
<p>极限编程是敏捷软件开发中应用最为广泛和最富有成效的几种方法学之一。<br> 极限编程的主要目标在于降低因需求变更而带来的成本。<br> 采用迭代的交付方式，每个迭代很短（1-3周时间）。在每个迭代结束的时候，团队交付可运行的，经过测试的功能，这些功能可以马上投入使用。</p> 
<ul><li>XP 编码 
  <ul><li>鼓励“测试驱动开发(TDD)”</li><li>鼓励“结对编程”</li><li>鼓励“重构”</li></ul> </li><li>XP 测试 
  <ul><li>每天进行集成和确认测试（持续集成）</li><li>“验收测试” 由客户确定，根据本次软件发布中所实现的用户故事而确定。</li></ul> </li></ul> 
<h3><a id="Scrum_421"></a>Scrum</h3> 
<ul><li>一种敏捷开发的模型。</li><li>采用短周期迭代交付方式</li></ul> 
<p>Scrum 流程包括：<br> 3个角色<br> 3个工件<br> 5个活动</p> 
<p><strong>Scrum中的角色</strong></p> 
<ul><li>同项目经理类似的Scrum<strong>主管</strong>:负责维护过程和任务</li><li><strong>产品负责人</strong>代表利益所有者</li><li><strong>开发团队</strong>包括了所有开发人员</li></ul> 
<p><strong>Scrum的工件（资料、文档）</strong></p> 
<ul><li>Product Backlog产品订单</li><li>Sprint Backlog冲刺订单</li><li>Burndown chart燃尽图</li></ul> 
<p><strong>Scrum的活动</strong></p> 
<ul><li>Sprint冲刺</li><li>Sprint planning meeting冲刺计划会</li><li>Daily standup meeting每日立会</li><li>Sprint review冲刺评审会</li><li>Retrospective meeting回顾会议</li></ul> 
<h2><a id="_453"></a>四、软件需求</h2> 
<p>1、什么是软件需求？<br> 2、软件需求分类<br> 3、需求工程<br> 4、需求获取技术<br> 5、竞争性需求分析<br> 6、需求规格说明书<br> 7、案例分析</p> 
<h3><a id="_464"></a>软件需求</h3> 
<ul><li>用户解决问题或达到目标所需的条件和能力</li><li>系统或系统部件为满足合同、标准、规范或其它正式规定文档所需具有的条件和能力</li><li>以上条件和能力的文档说明</li></ul> 
<p>软件需求的三个层次:</p> 
<ul><li>业务需求</li><li>用户需求</li><li>功能需求</li></ul> 
<p><img src="https://images2.imgbox.com/bb/2e/42SBuH2a_o.png" alt="在这里插入图片描述"></p> 
<p><strong>业务需求</strong></p> 
<p>业务需求(business requirement)反映了组织机构或客户对系统、产品高层次的目标要求</p> 
<p><strong>用户需求</strong></p> 
<p>用户需求(user requirement)描述了用户使用产品必须要完成的任务。</p> 
<p><strong>功能需求</strong></p> 
<p>系统分析员描述 开发人员在产品中实现的软件功能，用户利用这些功能来完成任务，满足业务需求。<br> 功能需求是需求的主体，它描述的是开发人员如何设计具体的解决方案来实现这些用户需求（how），其数量往往比用户需求高一个数量级。</p> 
<ul><li> <p>功能需求：描述系统预期提供的功能或服务</p> </li><li> <p>非功能需求：不直接与系统具体功能相关的需求。</p> </li></ul> 
<h3><a id="_501"></a>需求工程</h3> 
<p>应用已证实有效的技术、方法进行需求分析，确定客户需求，帮助分析人员理解问题并定义目标系统的所有外部特征的一门学科。<br> 它通过合适的工具和记号系统地描述待开发系统及其行为特征和相关约束，形成需求文档，并对用户不断变化的需求演进给予支持。</p> 
<p><strong>需求工程的基本活动</strong></p> 
<p><strong>获取需求<br> 细化(需求分析)<br> 协商<br> 编写需求规格说明<br> 确认需求<br> 需求管理</strong></p> 
<p><strong>需求分析的目的:</strong></p> 
<ul><li>说明软件的工作特征</li><li>指明软件和其他系统元素的接口<br> 规定软件必须满足的约束</li></ul> 
<p><strong>需求分析的主要任务：</strong></p> 
<ul><li>细化在前期需求工程的基础需求</li><li>构建一种或多种模型以描述用户场景、功能活动、类、类之间的关系、系统和类的行为、数据流等</li></ul> 
<h3><a id="_526"></a>需求获取技术</h3> 
<p>面谈<br> 调查<br> 观察实际业务过程<br> 原型法<br> 头脑风暴<br> 场景技术</p> 
<h2><a id="_536"></a>五、需求建模</h2> 
<p><strong>需求建模的元素</strong></p> 
<ul><li> <p><strong>场景模型</strong><br> 出自各种系统“参与者”观点的需求</p> </li><li> <p><strong>数据模型</strong><br> 描述问题信息域的模型(用于建立数据库)</p> </li><li> <p><strong>类模型</strong><br> 表示面向对象类（属性和操作）的模型</p> </li><li> <p><strong>数据流模型</strong><br> 描述功能元素在系统中运行时怎样进行数据变换</p> </li><li> <p><strong>行为模型</strong><br> 描述系统的外部行为</p> </li></ul> 
<h3><a id="_551"></a>需求建模概述</h3> 
<p><strong>需求建模的总体目标:</strong></p> 
<ul><li>描述客户需要什么；</li><li>为软件设计奠定基础；</li><li>定义在软件完成后可以被确认的一组需求。</li></ul> 
<h3><a id="_557"></a>基于场景的建模</h3> 
<p><strong>用例：</strong></p> 
<p>用于表示系统所提供的服务，描述参与者为了使用系统所提供的某一完整功能而与系统之间发生的一段对话（交互）。</p> 
<p><strong>场景：</strong></p> 
<p>场景是用例的实例化，从一个用例可以实例化出来多个用例场景。用例就是对全部场景的抽象。</p> 
<h3><a id="_566"></a>基于数据流的建模</h3> 
<p>结构化方法概述</p> 
<p>一种面向数据流的传统软件开发方法，以数据流为中心构建软件的分析模型和设计模型</p> 
<p>分为：</p> 
<ul><li> <p>结构化分析(Structured Analysis 简称SA)</p> </li><li> <p>结构化设计(Structuresd Design 简称SD)</p> </li><li> <p>结构化程序设计(Structured Programmin 简称SP)</p> </li></ul> 
<p><strong>结构化的需求分析模型：</strong></p> 
<ul><li> <p>功能模型（数据流模型），用来描述系统中的数据处理过程</p> </li><li> <p>行为模型（状态转换模型），用来描述系统如何对事件做出响应</p> </li><li> <p>数据模型（实体—关系模型）：用来描述系统中的数据及其之间的关系。</p> </li></ul> 
<p><strong>数据字典</strong>是模型的核心，它包含了软件使用和产生的所有数据的描述</p> 
<p><strong>数据流图</strong>（DFD，Data Flow Diagram）服务于两个目的：一是指明数据在系统中移动时如何被变换，二是描述对数据流进行变换的功能和子功能。</p> 
<p><img src="https://images2.imgbox.com/4d/fb/KOZKFCUa_o.png" alt="在这里插入图片描述"></p> 
<p><strong>数据流图符号</strong></p> 
<p>Data Flow Diagram(简称DFD)：描述输入数据流到输出数据流的变换(即加工、处理)过程，用于对系统的功能建模，基本元素包括:</p> 
<p><img src="https://images2.imgbox.com/92/07/o4Q5XGms_o.png" alt="在这里插入图片描述"><br> <strong>数据流图举例</strong></p> 
<p>设一个工厂采购部每天需要一张定货报表。定货的零件数据有：零件编号、名称、数量、价格、供应者等。零件的入库、出库事务由仓库管理员通过计算机终端输入给定货系统。当某零件的库存数少于给定的库存量临界值时，就应该再次定货。<br> 数据流分析：<br> 数据源点：仓管员（负责入库或出库事务给定货系统）；<br> 数据终点：采购员（接收每天的定货报表）；<br> 数据流：事务，定货报表；<br> 数据存储：定货信息，库存清单；</p> 
<p><img src="https://images2.imgbox.com/7d/e9/1dQbOf10_o.png" alt="在这里插入图片描述"><br> <strong>数据流图的各个层次</strong></p> 
<ul><li>顶层图（第0层）只有代表整个软件系统的1个加工，描述了软件系统与外界之间的数据流</li><li>顶层图中的加工经分解后的图称为第1层图(只有1张)</li><li>中间层图中至少有一个加工(也可以有多个)在下层图中分解成一张子图</li><li>处于最底层的图称为底层图，其中所有的加工不再分解成新的子图</li></ul> 
<p><strong>分层数据流图示例——资格和水平考试的考务处理系统</strong></p> 
<p>简化的资格和水平考试的考务处理系统<br> 分成多个级别，如初级程序员、程序员、高级程序员、系统分析员等，凡满足一定条件的考生都可参加某一级别的考试<br> 考试的合格标准将根据每年的考试成绩由考试中心确定<br> 考试的阅卷由阅卷站进行，因此，阅卷工作不包含在软件系统中</p> 
<p><strong>资格和水平考试的考务处理系统—功能需求</strong></p> 
<p>1．对考生送来的报名单进行检查<br> 2．对合格的报名单编好准考证号后将准考证送给考生，并将汇总后的考生名单送给阅卷站<br> 3．对阅卷站送来的成绩清单进行检查，并根据考试中心制订的合格标准审定合格者<br> 4．制作考生通知单送给考生<br> 5．进行成绩分类统计(按地区、年龄、文化程度、职业、考试级别等分类)和试题难度分析，产生统计分析表</p> 
<p><strong>画顶层图</strong></p> 
<ul><li> <p>确定源点和终点</p> </li><li> <p>确定顶层图的加工</p> </li><li> <p>确定数据流（系统的输入/输出信息）</p> </li><li> <p>确定存储</p> </li></ul> 
<p>确定源点和终点：考生、阅卷站和考试中心<br> 它们都既是源点又是终点<br> 顶层图唯一的加工：软件系统(考务处理系统)<br> 确定数据流：系统的输入/输出信息<br> 输入数据流：报名单(来自考生)、成绩清单(来自阅卷站)、合格标准(来自考试中心)<br> 输出数据流：准考证(送往考生)、考生名单(送往阅卷站)、考生通知书(送往考生)、统计分析表(送往考试中心)<br> 额外的输出流(考虑系统的健壮性)：不合格报名单(返回给考生)，错误成绩清单(返回给阅卷站)<br> 顶层图通常没有文件</p> 
<p><strong>考务处理系统顶层图</strong><br> <img src="https://images2.imgbox.com/a3/86/5XSpOlFp_o.png" alt="在这里插入图片描述"><br> <strong>考务处理系统1层图</strong></p> 
<p>根据功能需求对功能进行分解：考务处理系统可分解为两部分<br> 一、考试报名<br> 1．对考生送来的报名单进行检查<br> 2．对合格的报名单编好准考证号后将准考证送给考生，并将汇总后的考生名单送给阅卷站<br> （需要增加存储：考生名册）<br> 二、统计成绩<br> 3．对阅卷站送来的成绩清单进行检查，并根据考试中心制订的合格标准审定合格者<br> 4．制作考生通知单送给考生<br> 5．进行成绩分类统计(按地区、年龄、文化程度、职业、考试级别等分类)和试题难度分析，产生统计分析表</p> 
<p><img src="https://images2.imgbox.com/3c/0d/ysrr2CmW_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_668"></a>基于数据的建模</h3> 
<h3><a id="_671"></a>面向状态的建模方法</h3> 
<h2><a id="_673"></a>六、软件设计</h2> 
<h2><a id="_674"></a>七、软件测试</h2> 
<h2><a id="_675"></a>八、软件项目管理</h2>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/98c30dcd9010bcf7d5241032c7ff97d0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用户权限控制(Token登录)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0c8a0ff4e204af72f35896ab07c577ad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PC常用软件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>