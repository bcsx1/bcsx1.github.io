<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c语言知识点总结（常更）建议收藏 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c语言知识点总结（常更）建议收藏" />
<meta property="og:description" content="目录 1. 关于命名与代码规范2.关于输入与输出3.关于数据类型4. 关于运算符5. 分支6.循环7.数组8.模块化程序设计标准库函数 1. 关于命名与代码规范 简单变量名最多可以包含31个字符，建议使用student_name这种形式进行命名，当然也可以使用studentName这种形式。给简单变量命名，第一个字母一定小写。宏常量采用大写字母，如PI。函数的命名：采用一个单词命名时采用小写，若采用多个单词命名函数，则将后面每个单词的首字母大写，也有的人采取所有单词的首字母大写。我觉得第一种方式用的更多一些。if语句前面留一行，if条件内的语句整体向后缩进。循环语句的前后各空一行，增加程序的可读性 2.关于输入与输出 关于scanf：https://blog.csdn.net/qq_38048756/article/details/115530687关于printf：https://blog.csdn.net/qq_38048756/article/details/115598738scanf格式串中的空格符：意味着跳过零个或多个空白字符（空格、回车、制表符等）scanf函数是有返回值的，返回值表示成功输入变量的个数，当输入结束标志时，scanf函数无法再读取值，返回-1，因此我们会见到如下这种形式的代码： while(scanf(&#34;%d&#34;, &amp;x) == 1) { } 或者 while(scanf(&#34;%d&#34;, &amp;x) != EOF) { } /*上述代码表示利用while循环去读取键盘输入的数据并赋值给x 但是如果输入1 2 3 4 按下回车后，会发现没有显示结果，这是 因为程序还在等待输入，按回车并不意味着输入的结束，windows下 输入完毕后先按Enter，再按Ctrl&#43;Z键，最后再按Enter键即可结束 输入，Linux下，输入完毕后按Ctrl&#43;D即可结束输入 */ while(scanf()!=EOF),其作用和while(scanf(&#34;%d&#34;, &amp;x) == 1)相同，意思是当遇到输入结束标志时，结束循环，输入结束的标志就是EOF，EOF是stdio.h中预定义的一个符号常量，通常值为-1，windows下输入EOF的方法是按下Ctrl&#43;Z组合键，Linux系统下是按Ctrl&#43;D.关于输入输出重定向：https://blog.csdn.net/qq_38048756/article/details/117201318 3.关于数据类型 无符号整数类型主要应用于底层编程，在一般应用中不会使用。各种数据类型所占字节：https://blog.csdn.net/qq_38048756/article/details/115533752bool数据类型，在C99中提供了一个头文件 &lt;stdbool.h&gt; 定义了bool，true代表1，false代表0。只要导入 stdbool.h ，就可以操作布尔类型了。需要注意的是c99并没有规定int类型的确切大小，c99只是规定了int至少是16位，没有规定具体值。但是目前大部分平台下int都是32位整数 浮点数据
浮点数据的存储：
对于带小数点的数据，这类数据在计算机中以浮点（小数点是浮动的）格式进行存储，存储浮点数时，分为符号位、阶码和尾数三部分。
例如浮点数-13.625，符号位为1，整数部分和小数部分转化为二进制，得到 ( 1101.101 ) 2 (1101.101)_2 (1101.101)2​，所以需要将小数点左移3位（使整体变为一个刚比1大的数据），故阶码是 ( 11 ) 2 (11)_2 (11)2​，尾数为 ( 1.101101 ) 2 (1.101101)_2 (1.101101)2​，以IEE754标准的double格式存储，占8个字节，内容如下：
号位（1位）阶码（11位）尾数（52位）00000000001100000000000000000000000000000000000000000000001101101 阶码所占的位数决定了浮点类型的表示范围，尾数所占的位数决定了浮点类型的有效位数，在这种存储格式中，尾数部分小数点前的1被省略，不占存储位（因为毕竟已经明确知道尾数小数点前一定是1）。
c中提供了三种浮点类型，以适合不同需要：
float：单精度浮点类型" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/f9a665d56c5c41b14d51dd7461876492/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-11T14:40:32+08:00" />
<meta property="article:modified_time" content="2021-04-11T14:40:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c语言知识点总结（常更）建议收藏</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1__1" rel="nofollow">1. 关于命名与代码规范</a></li><li><a href="#2_8" rel="nofollow">2.关于输入与输出</a></li><li><a href="#3_26" rel="nofollow">3.关于数据类型</a></li><li><a href="#4__87" rel="nofollow">4. 关于运算符</a></li><li><a href="#5__109" rel="nofollow">5. 分支</a></li><li><a href="#6_147" rel="nofollow">6.循环</a></li><li><a href="#7_173" rel="nofollow">7.数组</a></li><li><a href="#8_182" rel="nofollow">8.模块化程序设计</a></li><li><a href="#_236" rel="nofollow">标准库函数</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1__1"></a>1. 关于命名与代码规范</h2> 
<ul><li>简单变量名最多可以包含31个字符，建议使用student_name这种形式进行命名，当然也可以使用studentName这种形式。给简单变量命名，第一个字母一定小写。</li><li>宏常量采用大写字母，如PI。</li><li>函数的命名：采用一个单词命名时采用小写，若采用多个单词命名函数，则将后面每个单词的首字母大写，也有的人采取所有单词的首字母大写。我觉得第一种方式用的更多一些。</li><li>if语句前面留一行，if条件内的语句整体向后缩进。</li><li>循环语句的前后各空一行，增加程序的可读性</li></ul> 
<h2><a id="2_8"></a>2.关于输入与输出</h2> 
<ul><li><a href="https://blog.csdn.net/qq_38048756/article/details/115530687">关于scanf</a>：https://blog.csdn.net/qq_38048756/article/details/115530687</li><li><a href="https://blog.csdn.net/qq_38048756/article/details/115598738">关于printf</a>：https://blog.csdn.net/qq_38048756/article/details/115598738</li><li>scanf格式串中的空格符：意味着跳过零个或多个空白字符（空格、回车、制表符等）</li><li>scanf函数是有返回值的，返回值表示成功输入变量的个数，当输入结束标志时，scanf函数无法再读取值，返回-1，因此我们会见到如下这种形式的代码：</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>
或者
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>
<span class="token comment">/*上述代码表示利用while循环去读取键盘输入的数据并赋值给x
但是如果输入1 2 3 4 按下回车后，会发现没有显示结果，这是
因为程序还在等待输入，按回车并不意味着输入的结束，windows下
输入完毕后先按Enter，再按Ctrl+Z键，最后再按Enter键即可结束
输入，Linux下，输入完毕后按Ctrl+D即可结束输入 */</span>
</code></pre> 
<ul><li><code>while(scanf()!=EOF)</code>,其作用和<code>while(scanf("%d", &amp;x) == 1)</code>相同，意思是当遇到输入结束标志时，结束循环，输入结束的标志就是EOF，EOF是stdio.h中预定义的一个符号常量，通常值为-1，windows下输入EOF的方法是按下Ctrl+Z组合键，Linux系统下是按Ctrl+D.</li><li><a href="https://blog.csdn.net/qq_38048756/article/details/117201318">关于输入输出重定向</a>：https://blog.csdn.net/qq_38048756/article/details/117201318</li></ul> 
<h2><a id="3_26"></a>3.关于数据类型</h2> 
<ul><li>无符号整数类型主要应用于底层编程，在一般应用中不会使用。</li><li><a href="https://blog.csdn.net/qq_38048756/article/details/115533752">各种数据类型所占字节</a>：https://blog.csdn.net/qq_38048756/article/details/115533752</li><li>bool数据类型，在C99中提供了一个头文件 &lt;stdbool.h&gt; 定义了bool，true代表1，false代表0。只要导入 stdbool.h ，就可以操作布尔类型了。</li><li>需要注意的是c99并没有规定int类型的确切大小，c99只是规定了int至少是16位，没有规定具体值。但是目前大部分平台下int都是32位整数</li></ul> 
<hr> 
<ul><li> <p><strong>浮点数据</strong></p> </li><li> <p>浮点数据的存储：<br> 对于带小数点的数据，这类数据在计算机中以浮点（小数点是浮动的）格式进行存储，存储浮点数时，分为符号位、阶码和尾数三部分。<br> 例如浮点数-13.625，符号位为1，整数部分和小数部分转化为二进制，得到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           ( 
          
         
           1101.101 
          
          
          
            ) 
           
          
            2 
           
          
         
        
          (1101.101)_2 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，所以需要将小数点左移3位（使整体变为一个刚比1大的数据），故阶码是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           ( 
          
         
           11 
          
          
          
            ) 
           
          
            2 
           
          
         
        
          (11)_2 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，尾数为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           ( 
          
         
           1.101101 
          
          
          
            ) 
           
          
            2 
           
          
         
        
          (1.101101)_2 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，以IEE754标准的double格式存储，占8个字节，内容如下：</p> 
  <table><thead><tr><th>号位（1位）</th><th>阶码（11位）</th><th>尾数（52位）</th></tr></thead><tbody><tr><td>0</td><td>00000000011</td><td>00000000000000000000000000000000000000000000001101101</td></tr></tbody></table></li></ul> 
<p>阶码所占的位数决定了浮点类型的表示范围，尾数所占的位数决定了浮点类型的有效位数，在这种存储格式中，尾数部分小数点前的1被省略，不占存储位（因为毕竟已经明确知道尾数小数点前一定是1）。</p> 
<ul><li>c中提供了三种浮点类型，以适合不同需要：<br> float：单精度浮点类型<br> double：双精度浮点类型<br> long double：扩展精度浮点类型<br> c标准中没有明确规定以上三种类型的精度到底是多少，不同的计算机可以用不同的方法存储浮点数，大多是计算机遵循IEEE754标准，该标准用4个字节表示float类型，8个字节表示double类型，long double类型随机器不同而不同，常见的是80位和128位，在vc++ 6.0中，占64位，8个字节。</li><li><strong>浮点数精度问题</strong>：和整数类型不同的是，c中的浮点类型是一种近似表示，比如十进制的1.2，其二进制形式为1.001100110011…，这是一个无限循环小数，所以计算机无法精确表示，因为任何类型数据都有固定长度，所以这个小数只能截断保存部分，所以浮点类型是不精确的数据类型。</li><li>所以，不能用关系运算符“==”来判断两个浮点数是否相等，例如判断两个浮点数a，b是否相等可采用<code>fabs(a-b) &lt; 1e-10</code>的形式</li></ul> 
<hr> 
<ul><li><strong>c语言中的字符数据</strong>： 
  <ul><li>c中的字符型数据，实际存储的是字符的ascii码</li><li>字符型数据像整数类型一样也分为有符号型和无符号型，c标准中没有说明char默认的类型是无符号型还是有符号型。有的编译器默认char为有符号型，有的编译器默认char为无符号型。visual c++默认char有符号型。通过有符号字符型取值范围为-128~127，而无符号型字符的取值范围为0~255,所以要注意避免字符类型溢出的错误。</li><li>字符常量：字符常量是用单引号括起来的单个普通字符或转义字符：‘a’, ‘B’, ‘3’, ‘$’, ‘\0’, ‘\n’</li><li>字符型数据：当今最常用的是ASCII字符集，它用7个二进制位表示128个字符，字符型数据在内存中一般占1个字节，字节最高位为0.</li><li>字符变量：字符变量定义形式为：<code>char 变量名;</code>例如<code>char ch;</code>可以将一个字符型常量存入字符变量，也可以将-128至127之间的整数存入字符变量，例如<code>ch=65;</code>既可以将该变量的内容解释为字符，也可以将改变量的内容解释为字符。当算术运算中出现char类型时，编译器会对该值进行类型提升，转换为int型，然后再进行计算，如：‘a’+1的值为98。</li><li>c语言是把字符当成整数来处理的。</li><li>输入输出：读入char型数据，可以采用：<code>scanf("%c", &amp;ch);</code>也可以采用<code>ch = getchar();</code>输出char类型的数据，可以采用<code>printf("%c", ch);</code>也可以采用<code>putchar(ch);</code></li><li>getchar()和putchar()函数是c标准库函数中专门用于字符输入和输出的函数，getchar()的功能是从系统隐含指定的输入设备(即终端键盘)输入一个字符，函数返回输入的字符，对于字符型数据而言，所有的输入都是有效输入，包括空格和回车等空白字符，所以在每次读入字符时，要提前对输入流中的换行符和空格等空白符进行处理。</li><li>可以使用赋值抑制符“ * ”跳过读入的字符，<code>char ch; scanf("%*c%c", &amp;ch);</code></li><li>处理字符的函数：</li></ul> </li></ul> 
<table><thead><tr><th>函数</th><th align="left">功能</th></tr></thead><tbody><tr><td>tolower()</td><td align="left">转换为小写字母</td></tr><tr><td>toupper()</td><td align="left">转换为大写字母</td></tr><tr><td>islower()</td><td align="left">判断是否是小写字母</td></tr><tr><td>isupper()</td><td align="left">判断是否是大写字母</td></tr><tr><td>isalpha()</td><td align="left">判断是否是大写字母</td></tr><tr><td>isdigit()</td><td align="left">判断是否是十进制数字(‘0’ - ‘9’)</td></tr><tr><td>isxdigit()</td><td align="left">判断是否是十六进制数字(‘0’ - ‘9’, ‘a’ - ‘f’, ‘A’ - ‘F’)</td></tr><tr><td>isblank()</td><td align="left">判断是否是空白字符（空格，‘\t’）</td></tr></tbody></table> 
<hr> 
<ul><li>极限常量</li><li>头文件&lt;limits.h&gt;定义了每种类型极限值的符号常量，如下表 
  <table><thead><tr><th>类型</th><th>下限</th><th>上限</th></tr></thead><tbody><tr><td>char</td><td>CHAR_MIN</td><td>CHAR_MAX</td></tr><tr><td>int</td><td>INT_MIN</td><td>INT_MAX</td></tr><tr><td>long</td><td>LONG_MIN</td><td>LONG_MAX</td></tr><tr><td>float</td><td>FLT_MIN</td><td>FLT_MAX</td></tr><tr><td>double</td><td>DBL_MIN</td><td>DBL_MAX</td></tr></tbody></table> </li><li>无符号整数类型的下限都是0，所以没有特定的符号，无符号类型的上限符号常量是对应带符号类型上限常量名前加“U"，分别为UCHAR_MAX、UINT_MAX、ULONG_MAX</li></ul> 
<h2><a id="4__87"></a>4. 关于运算符</h2> 
<ul><li> <p>模运算的符号与第一个操作数相同</p> </li><li> <p>执行算术运算，通常需要要求操作数具有相同的数据类型（相同的字节数和相同的存储方式）。计算机可以直接将两个32位整数相加，但是无法将一个16位整数与一个32位整数直接相加，也无法将一个32位整数和一个32位浮点数直接相加。不过c语言允许在表达式中混合使用基本数据类型，在这种情况下，编译器会对某些操作数进行类型转换，以便硬件可以对表达式进行计算。</p> </li><li> <p>类型转换：一共有三种方式</p> 
  <ul><li>第一种是算数转换：当算数运算、关系运算或逻辑运算的两个操作数不同，精度低的向精度高的自动转换，也就是类型提升。char-&gt;int-&gt;float-&gt;double</li><li>赋值时类型转换：编译器在对此种情况下会遵循：将赋值运算符右侧表达式的值转换为赋值运算符左侧变量的类型。赋值时右侧数据类型高于左侧，将丢失部分数据，造成精度降低，或发生数据溢出，导致结果错误。如：double a = 1; //把1.0赋给a 而int i = 1.5 //把1.5转为整型1，赋给i</li><li>强制类型转换：这种形式的类型转化并不会改变操作数本身，例如：double a = 2.5; int n; n = (int) a; 此时n的值为2，而a的值仍为2.5。</li></ul> </li><li> <p>关于逻辑运算：逻辑表达式的值即逻辑运算的结果只有真和假两个值，C语言本身是没有提供布尔类型的，运算结果为真用int数值类型的1来表示，运算结果为假用0表示。但是在需要判断一个数值表达式真假的时候，由于任意一个数值表达式的值不局限于0和1，因此c是根据表达式的值为非0还是0来判断真假的。如果表达式的值非0则为真，否则为假。例如：!2为0即假。</p> </li><li> <p>c语言中的逻辑运算符都是短路运算符，一旦能确定整个表达式的值，就不再继续计算。</p> </li><li> <p>对于浮点运算时可能存在误差的，所以在对浮点数进行比较时，要考虑浮点误差。</p> </li><li> <p>浮点数对应的四舍五入的实现：通过floor(x+0.05)实现，可以想象成在数轴上把一个单位区间往左移动0.5个单位的距离，floor(x)等于1的区间为[1, 2)，而floor(x+0.5)等于1的区间为[0.5, 1.5).</p> </li><li> <p><a href="https://blog.csdn.net/qq_38048756/article/details/115729561">运算符优先级与结合性总表</a>：https://blog.csdn.net/qq_38048756/article/details/115729561</p> </li><li> <p>&gt;&gt;右移运算符，右移n位表示除以<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            2 
           
          
            n 
           
          
         
        
          2^n 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.664392em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>，&lt;&lt;左移运算符，左移n位表示乘<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            2 
           
          
            n 
           
          
         
        
          2^n 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.664392em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>，更详细的参考https://blog.csdn.net/qq_15037231/article/details/76999926</p> </li><li> <p>i++与++i的区别：<br> 二者都会给i加1，但是当他们用在一个表达式当中时，二者是不同的，i++会使用加1前的值计算表达式,而++i会使用加1后的值计算表达式。<br> 例子：a = 8; b = a++;结果：b = 8; a = 9;<br> a = 8; c = ++a;结果：c = 9; a = 9;<br> 所以++ i 是先加后赋值（比较）；i ++ 是先赋值（比较）后加</p> </li><li> <p>逗号表达式的求解过程是：先求解表达式1，再求解表达式2。整个逗号表达式的值是表达式2的值。<br> 例子：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           a 
          
         
           = 
          
         
           3 
          
         
           ∗ 
          
         
           5 
          
         
           ， 
          
         
           a 
          
         
           ∗ 
          
         
           4 
          
         
        
          a=3 * 5，a*4 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">5</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span></span></span></span></span>； 先计算a = 3 * 5然后再计算a*4 = 60，该逗号表达式的结果就是60（a仍为15）.</p> </li><li> <p>!运算符是一个逻辑运算符，用来反转一个条件的值，该运算符只需要一个操作数，若操作数为真，则该逻辑表达式为假，该操作数为假，则该逻辑表达式为真。</p> </li></ul> 
<h2><a id="5__109"></a>5. 分支</h2> 
<hr> 
<ul><li>嵌套的if语句实现多分支结构：</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token number">1</span><span class="token punctuation">)</span>  语句<span class="token number">1</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token number">2</span><span class="token punctuation">)</span>  语句<span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>表达式n<span class="token punctuation">)</span>  语句n
<span class="token keyword">else</span>  语句n<span class="token operator">+</span><span class="token number">1</span>
</code></pre> 
<pre><code>多分支if语句的执行流程：
（1）依次计算并判断表达式1~n，若成立则执行后面的语句
（2）若所有的if条件都不成立，执行语句n+1
（3）无论执行完哪个语句分支，都不会执行其他分支
</code></pre> 
<hr> 
<ul><li>switch多分支</li><li>当问题需要处理的分支情况较多时(一般大于3种)，通常使用开关语句switch语句来代替条件语句简化程序的设计。开关语句就像多路开关一样，使程序控制流程形成多个分支，根据一个表达式的不同取值，选择其中一个或几个分支执行。<br> switch语句的一般形式</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">switch</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>	<span class="token keyword">case</span> 常量表达式<span class="token number">1</span>： 语句序列<span class="token number">1</span>
	<span class="token keyword">case</span> 常量表达式<span class="token number">2</span>： 语句序列<span class="token number">2</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">case</span> 常量表达式n： 语句序列n
	<span class="token keyword">default</span>：语句序列n<span class="token operator">+</span><span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>（1）控制表达式。switch后边必须跟着由圆括号括起来的整型表达式，c把字符当成整数处理，所以switch语句中可以对字符进行判定，但是表达式不能用浮点数和字符串。<br> （2）分支标号。每个分支的开头都有一个标号，格式为<code>case 常量表达式:</code>常量表达式的值必须是整数或者字符<br> （3）语句序列。每个分支后边可以跟任意多条语句，而且不需要用花括号括起来，每组语句的最后一条通常是break语句。</p> 
<ul><li>switch语句执行的流程：首先计算switch后的表达式的值，然后将该值依次与case后的常量值进行比较，当它们相等时，执行相应case后面的代码段，case相当于一个语句标号，程序从此标号下开始向下执行，<strong>直到遇到break语句，则跳出switch语句，否则程序将会执行到switch语句结束</strong>。</li><li>switch中要求不允许使用重复的分支标号，否则会编译出错，但是对分支的顺序是没有要求的，default分支不一定要放在最后。</li><li>switch语句要比if语句执行速度块，执行效率高，特别是在有许多情况需要判定的情况下。（因为switch语句在编译的时候，会有一个map进行映射，所以直接查表一步找到特定分支，而if多分支是按顺序比较，如满足条件，则执行对应的代码，否则跳转到下一个分支再进行比较。）此部分的解释具体可参考：<a href="https://www.cnblogs.com/idorax/p/6275259.html" rel="nofollow">https://www.cnblogs.com/idorax/p/6275259.html</a></li><li></ul> 
<h2><a id="6_147"></a>6.循环</h2> 
<ul><li>循环分为for循环、while循环和do_while循环。for循环适合指定循环次数的循环；while循环在循环体执行之前测试控制表达式；do循环在循环体执行之后测试控制表达式。</li><li>for(表达式1；表达式2；表达式3)<br> 其执行的过程为：<br> <img src="https://images2.imgbox.com/54/1a/L4PN8e0s_o.png" alt="在这里插入图片描述"></li><li>do while循环，循环体至少执行一次</li><li>有些情况下，循环的准确次数无法事前预知，例如：每次循环都包含输入数据的语句，循环是否结束由输入决定，这种情况下可以采用while循环实现，如：</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>number<span class="token punctuation">)</span><span class="token punctuation">,</span> number <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token comment">//此处采用了逗号表达式读入数据和判断数据的合法性作为循环控制的表达式。</span>
</code></pre> 
<ul><li>break和continue：break的作用是提前结束所在循环，continue的作用可以中断循环体的本次循环（即跳过循环体中尚未执行的语句），立即开始执行下一次循环。</li><li>goto语句：goto语句可以跳到函数中任何有标记的语句处，格式为：<code>goto 语句标号;</code>语句标号由一个标识符加一个冒号组成，它标识程序的一个特定位置，一般放在一段可执行语句的左边。</li><li></ul> 
<p>例如：求1-100的累加和。</p> 
<pre><code class="prism language-c">sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
loop<span class="token operator">:</span> sum <span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span>
i<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">)</span>
	<span class="token keyword">goto</span> loop<span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>goto语句一般不建议使用，因为它会破坏程序的结构，程序可读性差，容易带来隐患。不过<strong>当需要从多重循环中退出，或从包含switch语句的循环中退出时，用goto语句比较合理</strong>。</li></ul> 
<h2><a id="7_173"></a>7.数组</h2> 
<ul><li>比较大的数组尽量声明在main函数外，否则程序可能无法运行</li><li>c语言数组不能够进行赋值操作，如果要从数组a复制k个元素到数组b，可以这样做memcpy(b, a, sizeof(int) * k)。当然如果数组a和b是浮点型的，复制时要写成memcpy(b, a, sizeof(double)*k)。如果需要把数组a全部复制到数组b中，可以通过memcpy(b, a, sizeof(a))实现。</li><li>memset(a, o, sizeof(a))可以将数组a清零，虽然也可以使用循环完成，但是memset方便又快捷。</li><li>关于memcpy与memset函数<a href="https://blog.csdn.net/qq_38048756/article/details/115831128">https://blog.csdn.net/qq_38048756/article/details/115831128</a></li><li>c中的字符串用字符数组来表示 
  <ul><li><code>char s[20]; scanf("%s", s);</code> 其中scanf("%s", s)用来读入一个不含空格、tab和回车字符的字符串，存入字符数组s中，注意s前没有&amp;。</li><li>strchr()函数用来在一个字符串中查找单个字符，例如 <code>strchr(s, 'a');</code>表示在在字符数组s中寻找字符‘a’，若找到返回该位置，否则返回0</li></ul> </li></ul> 
<h2><a id="8_182"></a>8.模块化程序设计</h2> 
<ul><li>从软件工程的视点，关于函数有以下几点说明：<br> (1)一个函数的规模一般不要超过一页，最好控制在半页内容，小规模的函数可以提高程序的可用性<br> (2)一个程序最好设计成一些小函数的组合，这样易于编写、排错、维护和修改<br> (3)如果一个函数形参列表中的参数数目很大，则说明这个函数功能过多，可以考虑将其分解为若干具有单一功能的小函数，函数头的长足最好控制在一行之内<br> (4)函数原型、函数头和函数调用语句三者应该在形参和实参的输了、类型和顺序以及返回值的类型上严格保持一致。</li></ul> 
<hr> 
<ul><li>关于函数原型声明的问题： 
  <ul><li>函数声明是为了使编译器可以先对函数进行概要浏览，而函数的完整定义以后再给出，这种声明成为函数原型。</li><li>一般而言，如果函数定义在函数调用之前，是不需要函数原型声明的，那么为什么还会有函数原型声明这一说法：这是因为对于大型程序而言，一个程序中可能包含多个函数，而某些函数之间可能是相互调用的，当把所有的函数定义放在main之前，这时候需要去斟酌它们的顺序，防止出现调用未定义的函数，而如果两个函数相互调用（这种形式称之为间接递归），这时候无论先定义哪个函数，都会导致未定义的函数。而且当程序达到一定规模的时候，在一个文件中放置所有的函数是不可行的，所以这时，就需要函数原型告诉编译器在其他文件中定义的函数。</li><li>因此，建议在程序中包含所有被调用的函数的函数原型，这样可利用c语言的类型检查功能。</li><li>函数原型一般放在程序的开头处，这样会对程序中出现在它后面的所有对这个函数的调用语句起作用。而在一个函数内部的函数原型，将只对在该函数中出现的调用语句起作用，这样做的好处是满足"最小权限原则"。</li></ul> </li></ul> 
<hr> 
<ul><li>关与函数调用与内存管理的内容：<a href="https://blog.csdn.net/qq_38048756/article/details/110475125">https://blog.csdn.net/qq_38048756/article/details/110475125</a></li><li><strong>按值传递机制</strong>：函数定义时的参数成为形式参数（简称形参），函数调用时的参数称为实际参数（简称实参），在程序运行中遇到函数调用时，将实参的值依次传送给形参，这就是参数传递，这种参数传递是单向的，程序会为实参创建一个副本，作为被调用函数的形参，实参和形参各有不同的存储单元。被调函数中对这个副本的修改不会影响到主调函数中实参变量的原始值，这种传递方式被称为按值传递机制。</li></ul> 
<hr> 
<ul><li>变量的存储类型： 
  <ul><li>变量除了数据类型，还有其他属性：存储类型、作用域和链接等。</li><li>变量的存储类型决定了它的存储周期、作用域和链接。变量的存储周期是指变量存在于内存的时间。有些变量存在时间短、有的变量反复被创建、收回，有些则在程序的整个运行期间都驻留在内存中。</li><li>变量的作用域是指变量在程序能够被访问到的区域</li><li>变量的链接属性是针对多个源文件组成的程序而言的，旨在说明这个变量能否被其他源文件访问</li><li>变量的存储类型决定了为变量分配内存和释放内存的时间，变量的存储类型共有4种：auto、static、extern和register</li><li>auto存储类型： 
    <ul><li>auto存储类型的变量只在所在块有效，在所在块被执行时获得内存单元，并在块终止时释放内存单元。例如：<code>auto int n;</code>这句代码表明n是具有自动存储周期的局部变量，auto存储类型几乎从来不用明确表明，因为函数的局部变量（函数体内声明的变量和形参列表中的变量）都默认为auto存储类型。</li><li>自动存储是一种节约内存的手段，符合“最小权限原则”，因为auto变量只在需要它们的时候才占用内存。</li></ul> </li><li>static存储类型： 
    <ul><li>具有静态存储周期的变量所占用的存储单元是从程序运行的开始时刻分配和初始化的，并且只分配和初始化一次。</li><li>可以将局部变量声明为static存储类型，称为静态局部变量，在整个程序执行期间拥有最久的存储单元，都会保留变量的值。</li><li>外部变量具有静态存储周期，将一个变量声明为外部变量的方法是将其声明在所有函数体之外，外部变量在整个程序运行期间始终存在，但只可以被位于其声明语句之后的函数访问。</li></ul> </li><li>extern存储类型<br> - extern存储类型可以使几个源文件共享一个变量，提醒编译器需要访问定义在别处的变量，可能是同一文件稍后的位置，也可能在另一个文件中。<br> - 注意：extern不是变量定义，只是声明一个定义在别处的变量，例如：</li></ul> </li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/0c/aa/NTjahhw8_o.png" alt="在这里插入图片描述"></p> 
<ul><li>register存储类型 
  <ul><li>当程序被执行时，数据通常存储在内存，当需要计算或其他处理时才装入CPU的寄存器中。而声明变量为register类型就要求编译器把变量存储在寄存器中。 
    <ul><li>寄存器是驻留在CPU中的存储单元，具有比内存更高的存取速度。</li><li>一般将诸如循环变量和累加和变量等这类需要频繁访问的变量声明为寄存器类型。例如：<code>register int sum;</code></li><li>如今，register声明常常是多余的，今天的编译器已经具有很好的优化能力，编译器会找出被频繁访问的变量，并将其驻留在寄存器中，而无需register声明。</li></ul> </li></ul> </li></ul> 
<h2><a id="_236"></a>标准库函数</h2> 
<ul><li> <p>&lt;math.h&gt;</p> 
  <ul><li>abs(x): 求整数x绝对值</li><li>fabs(x): 求实数x绝对值，返回double</li><li>pow(x, y): 求<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
           
             x 
            
           
             y 
            
           
          
         
           x^y 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.664392em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">y</span></span></span></span></span></span></span></span></span></span></span></span>，x，y与返回值都为double</li><li>exp(x): 求<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
           
             e 
            
           
             x 
            
           
          
         
           e^x 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.664392em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span></span>,x与返回值均为double</li><li>log(x): 求自然对数ln(x),x与返回值均为double</li><li>log10(x): 求以10为底的对数，x与返回值均为double</li><li>三角函数sin(x),cos(x),tan(x)，x与返回值均为double</li><li>fmax(a, b): 比较a与b的大小，返回较大的那个，a,b与返回值均为double</li><li>fmin(a, b): 比较a与b的大小，返回较小的那个，a,b与返回值均为double</li></ul> </li><li> <p>&lt;string.h&gt;</p> 
  <ul><li><a href="https://blog.csdn.net/qq_38048756/article/details/115831128">memset与memcpy函数</a>：https://blog.csdn.net/qq_38048756/article/details/115831128</li></ul> </li><li> <p>&lt;time.h&gt;</p> 
  <ul><li><a href="https://blog.csdn.net/qq_38048756/article/details/102613004">clock()计时操作</a>：https://blog.csdn.net/qq_38048756/article/details/102613004</li></ul> </li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8a6f582b47e088499bc802165bb2e64a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">php怎么调用麦克风,javascript – 使用带有HTML5的用户麦克风录制音频</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f74a396830158e6620da9ac3c9368aa7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Cisco ASA防火墙Telnet SSH配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>