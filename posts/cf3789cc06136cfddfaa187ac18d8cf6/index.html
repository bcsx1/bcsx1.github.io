<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STL详解（十） 字符串string - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STL详解（十） 字符串string" />
<meta property="og:description" content="使用场合： 因为C风格字符串(以空字符结尾的字符数组)太过复杂难于掌握，不适合大程序的开发，所以C&#43;&#43;标准库定义了一种string类，它不必担心内存是否足够及字符串长度，可以使用输入输出流方式直接进行操作，也可以通过文件等手段进行操作，同时C&#43;&#43;的算法库对string也有着很好的支持 ，而且string还和c语言的字符串之间有着良好的接口，因此现在编程中涉及到字符串的处理，就可以直接使用string类了。
string类是由模板而实例化的一个标准类，本质上不是一个标准数据类型，我们尽可以把它看成是C&#43;&#43;的基本数据类型。
string 函数列表 函数名描述begin得到指向字符串开头的Iteratorend得到指向字符串结尾的Iteratorrbegin得到指向反向字符串开头的Iteratorrend得到指向反向字符串结尾的Iteratorsize得到字符串的大小length和size函数功能相同max_size字符串可能的最大大小capacity在不重新分配内存的情况下，字符串可能的大小empty判断是否为空[ ]、at下标访问，取第几个元素，相当于数组c_str取得C风格的const char* 字符串data取得字符串内容地址operator=赋值操作符reserve预留空间swap交换函数insert插入字符append追加字符push_back追加字符&#43;=&#43;= 操作符erase删除字符串clear清空字符容器中所有内容resize重新分配空间assign和赋值操作符一样replace替代copy字符串到空间find查找rfind反向查找find_first_of查找包含子串中的任何字符，返回第一个位置find_first_not_of查找不包含子串中的任何字符，返回第一个位置find_last_of查找包含子串中的任何字符，返回最后一个位置find_last_not_of查找不包含子串中的任何字符，返回最后一个位置substr得到字串compare比较字符串&#43;字符串链接==判断是否相等!=判断是否不等于&lt; 、 &lt;= 、 &gt;= 、&gt;判断是否小于、小于等于、大于等于、大于&gt;&gt;从输入流中读入字符串&lt;&lt;字符串写入输出流getline从输入流中读入一行 一、string的初始化 首先，为了在我们的程序中使用string类型，我们必须包含头文件 。
#include&lt;string&gt; //注意这里不是string.h , string.h是C字符串头文件, 当然也可以用万能头文件&lt;bits/stdc&#43;&#43;.h&gt;
using namespace std; //此语句必不可少，否则有的编译器无法识别。
二、C&#43;&#43;字符串声明与初始化赋值 声明一个字符串变量：
string s;//声明一个string 对象
string ss[10];//声明一个string对象的数组 这样我们就声明了一个字符串变量s 和一个字符串对象数组。
string是C&#43;&#43;中一个类，就有构造函数和析构函数。上面的声明没有传入参数，所以就直接使用了string的默认的构造函数，这个函数所作的就是把Str初始化为一个空字符串。String类的构造函数和析构函数如下：
#include&lt;bits/stdc&#43;&#43;.h&gt; using namespace std; int main() { freopen(&#34;a.in&#34;,&#34;r&#34;,stdin); freopen(&#34;a.out&#34;,&#34;w&#34;,stdout); string str; //定义了一个空字符串str str = &#34;Hello world&#34;; // 给str赋值为&#34;Hello world&#34;，也可以上面定义时直接赋值。 char cstr[] = &#34;abcde&#34;; //定义了一个C字符串 string s1(str); //调用复制构造函数生成s1，s1为str的复制品 string s4(cstr); //将C字符串作为s4的初值 string str1(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/cf3789cc06136cfddfaa187ac18d8cf6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-27T11:00:16+08:00" />
<meta property="article:modified_time" content="2018-11-27T11:00:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STL详解（十） 字符串string</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>使用场合：</h2> 
<p>因为C风格字符串(以空字符结尾的字符数组)太过复杂难于掌握，不适合大程序的开发，所以C++标准库定义了一种string类，它不必担心内存是否足够及字符串长度，可以使用输入输出流方式直接进行操作，也可以通过文件等手段进行操作，同时C++的算法库对string也有着很好的支持 ，而且string还和c语言的字符串之间有着良好的接口，因此现在编程中涉及到字符串的处理，就可以直接使用string类了。</p> 
<p>string类是由模板而实例化的一个标准类，本质上不是一个标准数据类型，我们尽可以把它看成是C++的基本数据类型。</p> 
<h2><strong>string 函数列表</strong></h2> 
<table border="1" cellpadding="0" cellspacing="1"><tbody><tr><td>函数名</td><td>描述</td></tr><tr><td>begin</td><td>得到指向字符串开头的Iterator</td></tr><tr><td>end</td><td>得到指向字符串结尾的Iterator</td></tr><tr><td>rbegin</td><td>得到指向反向字符串开头的Iterator</td></tr><tr><td>rend</td><td>得到指向反向字符串结尾的Iterator</td></tr><tr><td>size</td><td>得到字符串的大小</td></tr><tr><td>length</td><td>和size函数功能相同</td></tr><tr><td>max_size</td><td>字符串可能的最大大小</td></tr><tr><td>capacity</td><td>在不重新分配内存的情况下，字符串可能的大小</td></tr><tr><td>empty</td><td>判断是否为空</td></tr><tr><td>[  ]、at</td><td>下标访问，取第几个元素，相当于数组</td></tr><tr><td>c_str</td><td>取得C风格的const char* 字符串</td></tr><tr><td>data</td><td>取得字符串内容地址</td></tr><tr><td>operator=</td><td>赋值操作符</td></tr><tr><td>reserve</td><td>预留空间</td></tr><tr><td>swap</td><td>交换函数</td></tr><tr><td>insert</td><td>插入字符</td></tr><tr><td>append</td><td>追加字符</td></tr><tr><td>push_back</td><td>追加字符</td></tr><tr><td>+=</td><td>+= 操作符</td></tr><tr><td>erase</td><td>删除字符串</td></tr><tr><td>clear</td><td>清空字符容器中所有内容</td></tr><tr><td>resize</td><td>重新分配空间</td></tr><tr><td>assign</td><td>和赋值操作符一样</td></tr><tr><td>replace</td><td>替代</td></tr><tr><td>copy</td><td>字符串到空间</td></tr><tr><td>find</td><td>查找</td></tr><tr><td>rfind</td><td>反向查找</td></tr><tr><td>find_first_of</td><td>查找包含子串中的任何字符，返回第一个位置</td></tr><tr><td>find_first_not_of</td><td>查找不包含子串中的任何字符，返回第一个位置</td></tr><tr><td>find_last_of</td><td>查找包含子串中的任何字符，返回最后一个位置</td></tr><tr><td>find_last_not_of</td><td>查找不包含子串中的任何字符，返回最后一个位置</td></tr><tr><td>substr</td><td>得到字串</td></tr><tr><td>compare</td><td>比较字符串</td></tr><tr><td>+</td><td>字符串链接</td></tr><tr><td>==</td><td>判断是否相等</td></tr><tr><td>!=</td><td>判断是否不等于</td></tr><tr><td>&lt; 、 &lt;= 、 &gt;=  、&gt;</td><td>判断是否小于、小于等于、大于等于、大于</td></tr><tr><td>&gt;&gt;</td><td>从输入流中读入字符串</td></tr><tr><td>&lt;&lt;</td><td>字符串写入输出流</td></tr><tr><td>getline</td><td>从输入流中读入一行</td></tr></tbody></table> 
<h2>一、string的初始化</h2> 
<p>    <strong>首先，为了在我们的程序中使用string类型，我们必须包含头文件 </strong>。</p> 
<p>    #include&lt;string&gt;                   //注意这里不是string.h ,    string.h是C字符串头文件,   当然也可以用万能头文件&lt;bits/stdc++.h&gt;</p> 
<p>    using    namespace   std;     //此语句必不可少，否则有的编译器无法识别。</p> 
<h2>二、C++字符串声明与初始化赋值</h2> 
<p>声明一个字符串变量：</p> 
<table align="left" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td> <p>string s;//声明一个string 对象</p> </td></tr><tr><td>string ss[10];//声明一个string对象的数组</td></tr></tbody></table> 
<p></p> 
<p></p> 
<p></p> 
<p>这样我们就声明了一个字符串变量s 和一个字符串对象数组。</p> 
<p>string是C++中一个类，就有构造函数和析构函数。上面的声明没有传入参数，所以就直接使用了string的默认的构造函数，这个函数所作的就是把Str初始化为一个空字符串。String类的构造函数和析构函数如下：</p> 
<pre class="has"><code class="language-cs">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{ freopen("a.in","r",stdin);
  freopen("a.out","w",stdout);
  string str;             //定义了一个空字符串str
  str = "Hello world";    // 给str赋值为"Hello world"，也可以上面定义时直接赋值。
  char cstr[] = "abcde";  //定义了一个C字符串
  
  string s1(str);         //调用复制构造函数生成s1，s1为str的复制品
  string s4(cstr);        //将C字符串作为s4的初值
  string str1("1234");    //生成"1234"的复制品
  cout&lt;&lt;s1&lt;&lt;endl;
  cout&lt;&lt;s4&lt;&lt;endl;
  cout&lt;&lt;str1&lt;&lt;endl;
  
  string s2(str,6);       //将str内，开始于位置6的部分当作s2的初值
  string s5(cstr,3);      //将C字符串前3个字符作为字符串s5的初值。
  string str4("123456",5);//结果为"12345"
  cout&lt;&lt;s2&lt;&lt;endl; 
  cout&lt;&lt;s5&lt;&lt;endl;
  cout&lt;&lt;str4&lt;&lt;endl;

  string s3(str,6,3);     //将str内，开始于6且长度顶多为3的部分作为s3的初值
  string str3("12345",1,3);//结果为"234"
  cout&lt;&lt;s3&lt;&lt;endl;
  cout&lt;&lt;str3&lt;&lt;endl;
  
  string s6(5,'A');       //生成一个字符串，包含5个'A'字符
  cout&lt;&lt;s6&lt;&lt;endl;
  string s7(str.begin(),str.begin()+5); //区间str.begin()和str.begin()+5内的字符作为初值
  cout&lt;&lt;s7&lt;&lt;endl;
  str.~string();           //销毁str字串所有字符，释放内存
}</code></pre> 
<p>程序执行结果为：</p> 
<pre class="has"><code>Hello world
abcde
1234
world
abc
12345
wor
234
AAAAA
Hello
</code></pre> 
<h2>三、string特性描述</h2> 
<p>可用下列函数来获得string的一些特性：</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:104px;">返回值类型</td><td style="width:162px;">函数</td><td style="width:463px;">描述</td></tr><tr><td style="width:104px;">int</td><td style="width:162px;">capacity()</td><td style="width:463px;">返回当前容量（即string中不必增加内存即可存放的元素个数</td></tr><tr><td style="width:104px;">int</td><td style="width:162px;">max_size()</td><td style="width:463px;">返回string对象中可存放的最大字符串的长度</td></tr><tr><td style="width:104px;">int</td><td style="width:162px;">size()</td><td style="width:463px;">返回当前字符串的大小</td></tr><tr><td style="width:104px;">int</td><td style="width:162px;">length()</td><td style="width:463px;">返回当前字符串的长度</td></tr><tr><td style="width:104px;">bool</td><td style="width:162px;">empty()</td><td style="width:463px;">当前字符串是否为空</td></tr><tr><td style="width:104px;">void</td><td style="width:162px;">resize(int len,char c)</td><td style="width:463px;">把字符串当前大小置为len，多去少补，多出的字符c填充不足的部分</td></tr></tbody></table> 
<p><strong>大小和容量：</strong></p> 
<p>1. size()和length()：返回string对象的字符个数，他们执行效果相同。C++的话，倾向于用 size();<br> 2.empty()用来检查字符串是否为空。<br> 3. max_size()：返回string对象最多包含的字符数，很可能和机器本身的限制或者字符串所在位置连续内存的大小有关系。我们一般情况下不用关心他，应该大小足够我们用的。但是不够用的话，会抛出length_error异常。<br> 4. capacity()函数返回在重新申请更多的空间前字符串可以容纳的字符数.就是string当前能够容纳的最大字符数；即capacity()&gt;=length()。<br> 5.resize()函数，为string重新分配内存。重新分配的大小由其参数决定，默认参数为0，这时候会对string进行非强制性缩减。</p> 
<p></p> 
<pre class="has"><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{   string str;
    if (str.empty())  cout&lt;&lt;"str is NULL."&lt;&lt;endl;
       else   cout&lt;&lt;"str is not NULL."&lt;&lt;endl;
    str = str + "abcdefg";
    cout&lt;&lt;"str is "&lt;&lt;str&lt;&lt;endl;
    cout&lt;&lt;"str's size is "&lt;&lt;str.size()&lt;&lt;endl;
    cout&lt;&lt;"str's capacity is "&lt;&lt;str.capacity()&lt;&lt;endl;
    cout&lt;&lt;"str's max size is "&lt;&lt;str.max_size()&lt;&lt;endl;
    cout&lt;&lt;"str's length is "&lt;&lt;str.length()&lt;&lt;endl;
    str.resize(20,'c');
    cout&lt;&lt;"str is "&lt;&lt;str&lt;&lt;endl;
    str.resize(5);
    cout&lt;&lt;"str is "&lt;&lt;str&lt;&lt;endl;
    return 0;
}</code></pre> 
<p><strong>程序执行结果为：</strong></p> 
<pre class="has"><code>str is NULL.
str is abcdefg
str's size is 7
str's capacity is 7
str's max size is 1073741820
str's length is 7
str is abcdefgccccccccccccc
str is abcde</code></pre> 
<h3></h3> 
<h2>四、string的比较操作（<strong>==、&gt;、&lt;、&gt;=、&lt;=、!=、compare()</strong>）</h2> 
<p><strong>1、用运算符 ==、&gt;、&lt;、&gt;=、&lt;=、和!=比较字符串，</strong>这些操作符是按从左向右顺序逐一比较，遇到不相等的字符就按这个位置上的两个字符的ASC码大小比较，ASC码大的字串大。</p> 
<p><strong>2、compare()比较两个字符串。</strong></p> 
<p>compare()为区分大小写比较字符串，比如，利用compare比较字串“str”与字串“lpsz”，等同于区分大小写比较“str”与“lpsz”的第一个相异字符，如果“str”该处的字符比“lpsz”大，则字符串“str”大于“lpsz”，返回1；如果“str”该处的字符比“lpsz”小，则字符串“str”小于“lpsz”，返回-1；“str”与“lpsz”内容完全一致则返回0。</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:93px;">返回值类型</td><td style="width:391px;">函数</td><td style="width:366px;">描述</td></tr><tr><td style="width:93px;">int</td><td style="width:391px;">str.compare(const string &amp;s)</td><td style="width:366px;">比较字符串str和s的大小</td></tr><tr><td style="width:93px;">int</td><td style="width:391px;">str.compare(int pos, int n,const string &amp;s)</td><td style="width:366px;">比较字符串str从pos开始的n个字符组成的字符串与s的大小</td></tr><tr><td style="width:93px;">int</td><td style="width:391px;">str.compare(int pos, int n,const string &amp;s,int pos2,int n2)</td><td style="width:366px;"> <p>比较字符串str从pos开始的n个字符组成的字符串与s中pos2开始的n2个字符组成的字符串的大小</p> </td></tr><tr><td style="width:93px;">int</td><td style="width:391px;">str.compare(const char *s) ;</td><td style="width:366px;">比较字符串str和c字符串s的大小</td></tr><tr><td style="width:93px;">int </td><td style="width:391px;">str.compare(int pos, int n,const char *s) ;</td><td style="width:366px;">比较字符串str从pos开始的n个字符组成的字符串与c字符串s的大小</td></tr><tr><td style="width:93px;">int</td><td style="width:391px;">str.compare(int pos, int n,const char *s, int pos2，int n2) ;</td><td style="width:366px;">比较字符串str从pos开始的n个字符组成的字符串与c字符串s中pos2开始的n2个字符组成的字符串的大小</td></tr></tbody></table> 
<p>例一：</p> 
<pre class="has"><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{ 	string str1="hi,test,hello";
	string str2="hi,test";
	//字符串比较
	if(str1.compare(str2)&gt;0) printf("str1&gt;str2\n");
	else if(str1.compare(str2)&lt;0)	printf("str1&lt;str2\n");
	     else	printf("str1==str2\n");
	
	//str1的子串（从索引3开始，包含4个字符）与str2进行比较
	if(str1.compare(3,4,str2)==0)	printf("str1的指定子串等于str2\n");
	else	printf("str1的指定子串不等于str2\n");
	
	//str1指定子串与str2的指定子串进行比较
	if(str1.compare(3,4,str2,3,4)==0) printf("str1的指定子串等于str2的指定子串\n");
	else printf("str1的指定子串不等于str2的指定子串\n");
	
	//str1指定子串与字符串的前n个字符进行比较
	if(str1.compare(0,2,"hi,hello",2)==0) printf("str1的指定子串等于指定字符串的前2个字符组成的子串\n");
	else	printf("str1的指定子串不等于指定字符串的前2个字符组成的子串\n");
	return 0;	
}</code></pre> 
<p>程序执行结果为：</p> 
<pre class="has"><code>str1&gt;str2
str1的指定子串不等于str2
str1的指定子串等于str2的指定子串
str1的指定子串等于指定字符串的前2个字符组成的子串
</code></pre> 
<p>例二：</p> 
<pre class="has"><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{  	string A("aBcdef");	string B("AbcdEf");	string C("123456");	string D("123dfg");
	int m = A.compare(B);
	int n = A.compare(1, 5, B);
	int p = A.compare(1, 5, B, 4, 2);
	int q = A.compare(0, 3, D, 0, 3);
	cout &lt;&lt; "m=" &lt;&lt; m &lt;&lt; endl;
	cout &lt;&lt; "n=" &lt;&lt; n &lt;&lt; endl;
	cout &lt;&lt; "p=" &lt;&lt; p &lt;&lt; endl;
	cout &lt;&lt; "q=" &lt;&lt; q &lt;&lt; endl;
}</code></pre> 
<p>程序执行结果为：</p> 
<pre class="has"><code>m=1
n=1
p=-1
q=1</code></pre> 
<p></p> 
<h2>五、字符串内容修改</h2> 
<h3><strong>（5.1）string类的赋值函数：给字符串赋值assign()函数。</strong></h3> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:89px;">返回值类型</td><td style="width:326px;">函数</td><td style="width:363px;">描述</td></tr><tr><td style="width:89px;">string</td><td style="width:326px;">str=(const string &amp;s);</td><td style="width:363px;">把字符串s，赋值给字符串str</td></tr><tr><td style="width:89px;">string</td><td style="width:326px;">str.assign(const char *s);</td><td style="width:363px;">用c类型字符串s赋值给字符串str</td></tr><tr><td style="width:89px;">string</td><td style="width:326px;">str.assign(const char *s,int n);</td><td style="width:363px;">用c字符串s前n个字符，赋值给字符串str</td></tr><tr><td style="width:89px;">string</td><td style="width:326px;">str.assign(const string &amp;s);</td><td style="width:363px;">把字符串s，赋值给字符串str</td></tr><tr><td style="width:89px;">string</td><td style="width:326px;">str.assign(int n,char c);</td><td style="width:363px;">用n个字符c，赋值给字符串str</td></tr><tr><td style="width:89px;">string</td><td style="width:326px;">str.assign(const string &amp;s,int start,int n);</td><td style="width:363px;">把字符串s中从start开始的n个字符，赋值给字符串str</td></tr><tr><td style="width:89px;">string</td><td style="width:326px;">str.assign(const_iterator first,const_itertor last);</td><td style="width:363px;">把first和last迭代器之间的部分，赋值给字符串str</td></tr></tbody></table> 
<pre class="has"><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{   string str;
    string base="The quick brown fox jumps over a lazy dog.";
        
    str.assign(base);       //直接把base赋值给str
                            //str(base)是错误的，只有在赋初值时可以用str(base)。
    cout&lt;&lt;str&lt;&lt;'\n';
    
    str.assign(base,10,9);  //把base第10个字符以及后面的8个字符赋给str
    cout&lt;&lt;str&lt;&lt;'\n';        // "brown fox"
    
    str.assign("pangrams are cool",7);//把参数中的0到6个字符串赋给str
    cout&lt;&lt;str&lt;&lt;'\n';        // "pangram"
    
    str.assign("c-string"); //直接使用参数赋值
    cout &lt;&lt; str &lt;&lt; '\n';    // "c-string"
    
    str.assign(10,'*');     //给str赋值10个'*'字符
    cout&lt;&lt;str&lt;&lt;'\n';        // "**********"
    
    str.assign&lt;int&gt;(10,0x2D);//赋值是10个'-'
    cout &lt;&lt; str &lt;&lt; '\n';     // "----------"
   
    str.assign(base.begin()+16,base.end()-12); //指定base迭代器范围的字符串
    cout&lt;&lt;str&lt;&lt;'\n';         // "fox jumps over"
}</code></pre> 
<p>程序执行结果为：</p> 
<pre class="has"><code>The quick brown fox jumps over a lazy dog.
brown fox
pangram
c-string
**********
----------
fox jumps over
</code></pre> 
<h3><strong>（5.2）字符的连接（在尾巴上增加）</strong></h3> 
<p><strong>        1、</strong><strong>append()函数可以用来在字符串的末尾追加字符和字符串，</strong></p> 
<p><strong>        2、也可以用　+　和　+=　来实现，</strong></p> 
<p><strong>        3、push_back()在字符串的末尾追加一个字符，不能追加字符串。</strong></p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:100px;">返回值类型</td><td style="width:345px;">函数</td><td style="width:395px;">描述</td></tr><tr><td style="width:100px;">string</td><td style="width:345px;">str+=(const string &amp;s);</td><td style="width:395px;">把字符串s,连接到字符串str的结尾 </td></tr><tr><td style="width:100px;">string</td><td style="width:345px;">str.append(const char *s); </td><td style="width:395px;">把c类型字符串s,连接到字符串str的结尾 </td></tr><tr><td style="width:100px;">string</td><td style="width:345px;">str.append(const char *s,int n);</td><td style="width:395px;">把c类型字符串s的前n个字符,连接到字符串str的结尾 </td></tr><tr><td style="width:100px;">string</td><td style="width:345px;">str.append(const string &amp;s); </td><td style="width:395px;">把字符串s,连接到字符串str的结尾 ,同+=相同。</td></tr><tr><td style="width:100px;">string</td><td style="width:345px;">str.append(const string &amp;s,int pos,int n);</td><td style="width:395px;">把字符串s中从pos开始的n个字符,连接到字符串str的结尾 </td></tr><tr><td style="width:100px;">string</td><td style="width:345px;">str.append(int n,char c);  </td><td style="width:395px;">在字符串str结尾添加n个字符c</td></tr><tr><td style="width:100px;">string</td><td style="width:345px;">str.append(const_iterator first,const_iterator last);</td><td style="width:395px;">把迭代器first和last之间的部分,连接到字符串str的结尾 </td></tr><tr><td style="width:100px;">string</td><td style="width:345px;">str.push_back(char c)</td><td style="width:395px;">在字符串str的末尾追加一个字符</td></tr></tbody></table> 
<pre class="has"><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{string str;
 string str2="Writing ";
 string str3="print 10 and then 5 more";

 str.append(str2);        //直接追加一个str2的字符串，追加"Writing "
 str.append(str3,6,3);    //后面追加str3第6个字符开始的3个字符串 ,追加"10 "
 str.append("dots are cool",5); //追加字符串形参的前5个字符，追加"dots "
 str.append("here: ");    //直接追加 "here: "
 str.append(10,'.');     //追加 10个'.' ，追加 ".........."
 str.append(str3.begin()+8,str3.end()); //从str3的第8个字符开始追加" and then 5 more"
 str.append&lt;int&gt;(5,65);   //这个比较特殊，意思是添加5个'A'，65对应的asc码就是65
 
 str+="lalala";           //字符串追加也可以用重载运算符实现
 
 str.push_back('X');    //括号内不能用双引号如：“X”,不能用多个字符如：“AFF”。 

 cout&lt;&lt;str&lt;&lt;'\n';
}</code></pre> 
<p>程序执行结果为：</p> 
<pre class="has"><code>Writing 10 dots here: .......... and then 5 moreAAAAAlalalaX
</code></pre> 
<h3>    <strong>（5.3）string类的插入函数</strong><strong>：插入字符串insert()。</strong></h3> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:100px;">返回值类型</td><td style="width:385px;">函数</td><td style="width:364px;">描述</td></tr><tr><td style="width:100px;">string</td><td style="width:385px;">str.insert(int p0, const char *s);</td><td style="width:364px;">在p0位置插入C语言字符串s</td></tr><tr><td style="width:100px;">string</td><td style="width:385px;">str.insert(int p0, const char *s, int n);</td><td style="width:364px;">在p0位置插入C语言字符串s的前n个字符</td></tr><tr><td style="width:100px;">string</td><td style="width:385px;">str.insert(int p0,const string &amp;s);</td><td style="width:364px;">在p0位置插入C++字符串s</td></tr><tr><td style="width:100px;">string</td><td style="width:385px;">str.insert(int p0,const string &amp;s, int pos, int n);</td><td style="width:364px;">在p0位置插入C++字符串s从pos开始的连续n个字符</td></tr><tr><td style="width:100px;">string</td><td style="width:385px;">str.insert(int p0, int n, char c);</td><td style="width:364px;">在p0处插入n个字符c</td></tr><tr><td style="width:100px;">iterator</td><td style="width:385px;">str.insert(iterator it, char c);</td><td style="width:364px;">在it处插入字符c，返回插入后迭代器的位置</td></tr><tr><td style="width:100px;">void</td><td style="width:385px;">str.insert(iterator it, const_iterator first, const_iteratorlast);</td><td style="width:364px;">在it处插入从first开始至last-1的所有字符</td></tr><tr><td style="width:100px;">void</td><td style="width:385px;">str.insert(iterator it, int n, char c);</td><td style="width:364px;">在it处插入n个字符c</td></tr></tbody></table> 
<p>例一、</p> 
<pre class="has"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{   ios::sync_with_stdio(false);    
    string str="to be question";
    string str2="the ";
    string str3="or not to be";
    string::iterator it;

    //s.insert(pos,str)//在s的pos位置插入str
    str.insert(6,str2);                 // to be the question
    cout&lt;&lt;str&lt;&lt;endl;
    //s.insert(pos,str,a,n)在s的pos位置插入str中插入位置a到后面的n个字符
    str.insert(6,str3,3,4);             // to be not the question
    cout&lt;&lt;str&lt;&lt;endl;
    //s.insert(pos,cstr,n)//在pos位置插入cstr字符串从开始到后面的n个字符
    str.insert(10,"that is cool",8);    // to be not that is the question
    cout&lt;&lt;str&lt;&lt;endl;
    //s.insert(pos,cstr)在s的pos位置插入cstr
    str.insert(10,"to be ");            // to be not to be that is the question
    cout&lt;&lt;str&lt;&lt;endl;
    //s.insert(pos,n,ch)在s.pos位置上面插入n个ch
    str.insert(15,1,':');               // to be not to be: that is the question
    cout&lt;&lt;str&lt;&lt;endl;
    //s.insert(s.it,ch)在s的it指向位置前面插入一个字符ch，返回新插入的位置的迭代器
    it = str.insert(str.begin()+5,','); // to be, not to be: that is the question
    cout&lt;&lt;*it&lt;&lt;endl;
    cout&lt;&lt;str&lt;&lt;endl;
    //s.insert(s.it,n,ch)//在s的it所指向位置的前面插入n个ch
    str.insert (str.end(),3,'.');       // to be, not to be: that is the question...
    cout&lt;&lt;str&lt;&lt;endl;
    //s.insert(it,str.ita,str.itb)在it所指向的位置的前面插入[ita,itb)的字符串
    str.insert (it+2,str3.begin(),str3.begin()+3); // to be, or not to be: that is the question...
    cout&lt;&lt;str&lt;&lt;endl;
}</code></pre> 
<p>程序执行结果为：</p> 
<pre class="has"><code>to be the question
to be not the question
to be not that is the question
to be not to be that is the question
to be not to be: that is the question
,
to be, not to be: that is the question
to be, not to be: that is the question...
to be, or not to be: that is the question...</code></pre> 
<p>在竞赛中遇到大数据时，往往读文件成了程序运行速度的瓶颈，需要更快的读取方式。cin读入速度缓慢原因一般cin与stdin总是保持同步的，正因为这个的特性，导致cin有许多额外的开销，禁用这个特性只需一个语句<strong>std::ios::sync_with_stdio(false);</strong>，这样就可以取消cin于stdin的同步了，效率可以提高几乎10倍。</p> 
<h3><strong>（5.4）string类的删除函数 ：删除字符串erase（）。</strong></h3> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:100px;">返回值类型</td><td style="width:278px;">函数</td><td style="width:471px;">描述</td></tr><tr><td style="width:100px;">iterator</td><td style="width:278px;">str.erase(iterator first, iterator last);</td><td style="width:471px;">删除[first，last）之间的所有字符，返回删除后迭代器的位置</td></tr><tr><td style="width:100px;">iterator</td><td style="width:278px;">str.erase(iterator it);</td><td style="width:471px;">删除it指向的字符，返回删除后迭代器的位置</td></tr><tr><td style="width:100px;">string</td><td style="width:278px;">str.erase(int pos = 0, int n = npos);</td><td style="width:471px;">删除pos开始的n个字符，返回修改后的字符串</td></tr></tbody></table> 
<pre class="has"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{ string str("This is an example sentence.");
  cout &lt;&lt; str &lt;&lt; '\n';  
                          // "This is an example sentence."
  str.erase (10,8);       //            ^^^^^^^^
  //直接指定删除的字符串位置第十个后面的8个字符
  cout &lt;&lt; str &lt;&lt; '\n';
                            // "This is an sentence."
  str.erase (str.begin()+9);//           ^
  //删除迭代器指向的字符
  cout &lt;&lt; str &lt;&lt; '\n';
                            // "This is a sentence."
                            //       ^^^^^
  str.erase (str.begin()+5, str.end()-9);
  //删除迭代器范围的字符
  cout &lt;&lt; str &lt;&lt; '\n';
                            // "This sentence."
}</code></pre> 
<p> 程序执行结果为：</p> 
<pre class="has"><code>This is an example sentence.
This is an sentence.
This is a sentence.
This sentence.</code></pre> 
<h3><strong>（5.5）string类的替换函数（replace）：​​​​​替换字符串。</strong></h3> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:92px;">返回值类型</td><td style="width:423px;">函数</td><td style="width:334px;">描述</td></tr><tr><td style="width:92px;">string</td><td style="width:423px;">str.replace(int p0, int n,const char *s);</td><td style="width:334px;">删除从p0开始的n0个字符，然后在p0处插入串s</td></tr><tr><td style="width:92px;">string</td><td style="width:423px;">str.replace(int p0, int n0,const char *s, int n);</td><td style="width:334px;">删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符</td></tr><tr><td style="width:92px;">string</td><td style="width:423px;">str.replace(int p0, int n0,const string &amp;s);</td><td style="width:334px;">删除从p0开始的n0个字符，然后在p0处插入串s</td></tr><tr><td style="width:92px;">string</td><td style="width:423px;">str.replace(int p0, int n0,const string &amp;s, int pos, int n);</td><td style="width:334px;">删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符</td></tr><tr><td style="width:92px;">string</td><td style="width:423px;">str.replace(int p0, int n0,int n, char c);</td><td style="width:334px;">删除p0开始的n0个字符，然后在p0处插入n个字符c</td></tr><tr><td style="width:92px;">string</td><td style="width:423px;">str.replace(iterator first0, iterator last0,const char *s);</td><td style="width:334px;">把[first0，last0）之间的部分替换为字符串s</td></tr><tr><td style="width:92px;">string</td><td style="width:423px;">str.replace(iterator first0, iterator last0,const char *s, int n);</td><td style="width:334px;">把[first0，last0）之间的部分替换为s的前n个字符</td></tr><tr><td style="width:92px;">string</td><td style="width:423px;">str.replace(iterator first0, iterator last0,const string &amp;s);</td><td style="width:334px;">把[first0，last0）之间的部分替换为串s</td></tr><tr><td style="width:92px;">string</td><td style="width:423px;">replace(iterator first0, iterator last0,int n, char c);</td><td style="width:334px;">把[first0，last0）之间的部分替换为n个字符c</td></tr><tr><td style="width:92px;">string</td><td style="width:423px;">replace(iterator first0, iterator last0,const_iterator first, const_iterator last);</td><td style="width:334px;">把[first0，last0）之间的部分替换成[first，last）之间的字符串</td></tr></tbody></table> 
<p>例一：</p> 
<pre class="has"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main ()
{   string base="this is a test string.";
    string str2="n example";
    string str3="sample phrase";
    string str4="useful.";

string str=base;   // "this is a test string."
cout&lt;&lt;str&lt;&lt;endl; 
	
	//str第9个字符以及后面的5个字符被str2代替
str.replace(9,5,str2);  // "this is an example string." (1)
cout&lt;&lt;str&lt;&lt;endl;
	
	//第19个字符串以及后面的6个字符用str的第7个字符以及后面的6个字符代替
str.replace(19,6,str3,7,6);   // "this is an example phrase." (2)
cout&lt;&lt;str&lt;&lt;endl;
   
    //第8个字符以及后面的9个字符用字符串参数代替
str.replace(8,10,"just a");   // "this is just a phrase."     (3)
cout&lt;&lt;str&lt;&lt;endl;
   
    //第8个字符以及后面的5个字符用字符串参数的前7个字符替换
str.replace(8,6,"a shorty",7); // "this is a short phrase."    (4)
cout&lt;&lt;str&lt;&lt;endl;
	
	//第22以及后面的0个字符用3个叹号替换
str.replace(22,1,3,'!');       // "this is a short phrase!!!"  (5)
cout&lt;&lt;str&lt;&lt;endl;
	
	//迭代器的原理同上
    // Using iterators:    0123456789*123456789*
str.replace(str.begin(),str.end()-3,str3);      // "sample phrase!!!"      (1)
cout&lt;&lt;str&lt;&lt;endl;
str.replace(str.begin(),str.begin()+6,"replace");  // "replace phrase!!!"  (3)
cout&lt;&lt;str&lt;&lt;endl;
str.replace(str.begin()+8,str.begin()+14,"is coolness",7);//"replace is cool!!!" (4)
cout&lt;&lt;str&lt;&lt;endl;
str.replace(str.begin()+12,str.end()-4,4,'o');  // "replace is cooool!!!"  (5)
cout&lt;&lt;str&lt;&lt;endl;
str.replace(str.begin()+11,str.end(),str4.begin(),str4.end()); // "replace is useful." (6)
cout&lt;&lt;str&lt;&lt;endl;
}</code></pre> 
<p>程序执行结果为：</p> 
<pre class="has"><code>this is a test string.
this is an example string.
this is an example phrase.
this is just a phrase.
this is a short phrase.
this is a short phrase!!!
sample phrase!!!
replace phrase!!!
replace is cool!!!
replace is cooool!!!
replace is useful.</code></pre> 
<h3><strong>（5.6）sawp()函数：相互交换字符串</strong></h3> 
<pre class="has"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{string str="give me";
 string str1="a cup'";
 str.swap(str1);
 cout&lt;&lt;str&lt;&lt;endl;    //输出:a cup
 cout&lt;&lt;str1&lt;&lt;endl;   //输出:give me
}</code></pre> 
<h3><strong>（5.7）把字符串清空</strong></h3> 
<p>把字符串清空的方法有三个：</p> 
<p>1、s=””;</p> 
<p>２、s.clear();</p> 
<p>３、s.erase();</p> 
<h3><strong>（5.8）string和数值转换  ：</strong></h3> 
<p>在c++11当中有定义好的现成的函数取调用，非常方便。</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:197px;">返回值类型</td><td style="width:301px;">函数</td><td style="width:550px;">描述</td></tr><tr><td style="width:197px;">string</td><td style="width:301px;">to_string(val)</td><td style="width:550px;">把val转换成string</td></tr><tr><td style="width:197px;">int</td><td style="width:301px;">stoi(s,p,b)</td><td style="width:550px;">把字符串s从p开始转换成b进制的int</td></tr><tr><td style="width:197px;">long</td><td style="width:301px;">stol(s,p,b) </td><td style="width:550px;">把字符串s从p开始转换成b进制的long</td></tr><tr><td style="width:197px;">unsigned long</td><td style="width:301px;">stoul(s,p,b) </td><td style="width:550px;">把字符串s从p开始转换成b进制的unsigned long</td></tr><tr><td style="width:197px;">long long</td><td style="width:301px;">stoll(s,p,b)</td><td style="width:550px;">把字符串s从p开始转换成b进制的long long</td></tr><tr><td style="width:197px;">unsigned long long</td><td style="width:301px;">stoull(s,p,b)</td><td style="width:550px;">把字符串s从p开始转换成b进制的unsigned long long</td></tr><tr><td style="width:197px;">float</td><td style="width:301px;">stof(s,p)</td><td style="width:550px;">把字符串s从p开始转换成float</td></tr><tr><td style="width:197px;">double</td><td style="width:301px;">stod(s,p) </td><td style="width:550px;">把字符串s从p开始转换成double</td></tr><tr><td style="width:197px;">long double</td><td style="width:301px;">stold(s,p) </td><td style="width:550px;">把字符串s从p开始转换成long double</td></tr></tbody></table> 
<p>以上函数是C++11中的库函数，让Dev C++支持C++11还要在软件中进行设置。</p> 
<p>1.先在dev的【工具】里找到【编译选项】</p> 
<p><br> 2.一开始普遍的dev应该都是以下这个界面，在【编译时加入以下命令】栏是空白的且没有打钩。</p> 
<p><br><img alt="" class="has" src="https://images2.imgbox.com/b6/09/j3p7cipp_o.jpg"></p> 
<p>3.奇迹就在此刻改变.在这个【编译时加入以下命令】处打钩,然后在空白栏输入【-std=c++11】（c是小写的），确定.然后就能支持c++1</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/5d/d6/gU0AZaem_o.jpg"></p> 
<pre class="has"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    string s1;
    s1=to_string(100);
    cout&lt;&lt;s1&lt;&lt;endl;
    int a=stoi(s1,0,10)+1;
    cout&lt;&lt;a&lt;&lt;endl;
}</code></pre> 
<p><span style="color:#f33b45;">以上程序在Dev C++编译环境中设置好【-std=c++11】后才可以运行。</span></p> 
<h3><strong>（5.9）</strong>String字符串与字符(char类型)数组互相转换<strong> ：</strong></h3> 
<p><strong>1、字符数组转化成string类型</strong></p> 
<pre class="has"><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{char ch[] = "ABCDEFG";
 string str(ch);//也可string str = ch;
 cout&lt;&lt;str;
}</code></pre> 
<p>或者</p> 
<pre class="has"><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{char ch[]="ABCDEFG";
 string str;
 str=ch;//在原有基础上添加可以用str+=ch;
 cout&lt;&lt;str;
}</code></pre> 
<p><br><strong>２、将string类型转换为字符数组</strong><br> char buf[10];<br> string str("ABCDEFG");<br> length = str.copy(buf, 9);<br> buf[length] = '\0';<br> 或者<br> char buf[10];<br> string str("ABCDEFG");<br> strcpy(buf, str.c_str());//strncpy(buf, str.c_str(), 10);</p> 
<p>标准库的string类提供了3个成员函数来从一个string得到c类型的字符数组：c_str()、data()、copy(p,n)。</p> 
<p>1. c_str()：生成一个const char*指针，指向以空字符终止的数组。</p> 
<p>注：</p> 
<p>①这个数组的数据是临时的，当有一个改变这些数据的成员函数被调用后，其中的数据就会失效。因此要么现用先转换，要么把它的数据复制到用户自己可以管理的内存中。注意。看下例：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p><code>const</code> <code>char</code><code>* c;</code></p> <p><code>string s=</code><code>"1234"</code><code>;</code></p> <p><code>c = s.c_str();</code></p> <p><code>cout&lt;&lt;c&lt;&lt;endl; </code><code>//输出：1234</code></p> <p><code>s=</code><code>"abcd"</code><code>;</code></p> <p><code>cout&lt;&lt;c&lt;&lt;endl; </code><code>//输出：abcd</code></p> </td></tr></tbody></table> 
<p></p> 
<p>上面如果继续用c指针的话，导致的错误将是不可想象的。就如：1234变为abcd</p> 
<p>其实上面的c = s.c_str(); 不是一个好习惯。既然c指针指向的内容容易失效，我们就应该按照上面的方法，那怎么把数据复制出来呢？这就要用到strcpy等函数（推荐）。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p><code>//const char* c; //①</code></p> <p><code>//char* c;       //②</code></p> <p><code>//char c[20];</code></p> <p><code>char</code><code>* c=</code><code>new</code> <code>char</code><code>[20];</code></p> <p><code>string s=</code><code>"1234"</code><code>;</code></p> <p><code>//c = s.c_str();</code></p> <p><code>strcpy</code><code>(c,s.c_str());</code></p> <p><code>cout&lt;&lt;c&lt;&lt;endl; </code><code>//输出：1234</code></p> <p><code>s=</code><code>"abcd"</code><code>;</code></p> <p><code>cout&lt;&lt;c&lt;&lt;endl; </code><code>//输出：1234</code></p> </td></tr></tbody></table> 
<p>注意：不能再像上面一样①所示了，const还怎么向里面写入值啊；也不能②所示，使用了未初始化的局部变量“c”，运行会出错的 。</p> 
<p>② c_str()返回一个客户程序可读不可改的指向字符数组的指针，不需要手动释放或删除这个指针。</p> 
<p>2. data():与c_str()类似，但是返回的数组不以空字符终止。</p> 
<p>3. copy(p,n,size_type _Off = 0)：从string类型对象中至多复制n个字符到字符指针p指向的空间中。默认从首字符开始，但是也可以指定，开始的位置（记住从0开始）。返回真正从对象中复制的字符。------用户要确保p指向的空间足够保存n个字符。</p> 
<pre class="has"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

int main( )

{   string str1 ( "1234567890" );

    basic_string &lt;char&gt;::iterator str_Iter;

    char array1 [ 20 ] = { 0 };

    char array2 [ 10 ] = { 0 };

    basic_string &lt;char&gt;:: pointer array1Ptr = array1;

    basic_string &lt;char&gt;:: value_type *array2Ptr = array2;



    cout &lt;&lt; "The original string str1 is: ";

    for ( str_Iter = str1.begin( ); str_Iter != str1.end( ); str_Iter++ )

        cout &lt;&lt; *str_Iter;

    cout &lt;&lt; endl;



    basic_string &lt;char&gt;:: size_type nArray1;

    // Note: string::copy is potentially unsafe, consider

    // using string::_Copy_s instead.

    nArray1 = str1.copy ( array1Ptr , 12 );  // C4996

    cout &lt;&lt; "The number of copied characters in array1 is: "

        &lt;&lt; nArray1 &lt;&lt; endl;

    cout &lt;&lt; "The copied characters array1 is: " &lt;&lt; array1Ptr &lt;&lt; endl;



    basic_string &lt;char&gt;:: size_type nArray2;

    // Note: string::copy is potentially unsafe, consider

    // using string::_Copy_s instead.

    nArray2 = str1.copy ( array2Ptr , 5 , 6  );  // C4996

    cout &lt;&lt; "The number of copied characters in array2 is: "

        &lt;&lt; nArray2 &lt;&lt; endl;

    cout &lt;&lt; "The copied characters array2 is: " &lt;&lt; array2Ptr &lt;&lt; endl;</code></pre> 
<h2><strong>六、访问单个字符。可以</strong>通过[　]下标，函数at（）及迭代器三种方法来访问单个字符。</h2> 
<pre class="has"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{   string s1 = "abcdefg";

    //1、数组方式
    cout &lt;&lt; "数组方式:" &lt;&lt; endl;
    for (int i = 0; i &lt; s1.length(); i++)
        cout &lt;&lt;s1[i] &lt;&lt;endl;
        
    //2、函数方式
    cout &lt;&lt; "数组方式:" &lt;&lt; endl;
    for (int i = 0; i &lt; s1.length(); i++)
        cout &lt;&lt;s1.at(i) &lt;&lt;endl;    

    //３、迭代方式
    cout &lt;&lt; "迭代方式:" &lt;&lt; endl;
    for (string::iterator it = s1.begin(); it != s1.end(); it++)
        cout&lt;&lt;*it&lt;&lt; endl;
}</code></pre> 
<p><strong>注意：运算符[  ]和at()均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[  ]不提供检查访问。</strong></p> 
<p></p> 
<h2>七、字符串的输入输出。&gt;&gt;、 &lt;&lt; 、getline()</h2> 
<p>1、string类重载运算符operator&gt;&gt;用于输入，同样重载运算符operator&lt;&lt;用于输出操作。</p> 
<p>2、getline()的原型： getline ( istream &amp;is , string &amp;str , char delim );</p> 
<p>其中:</p> 
<p>istream &amp;is 表示一个输入流，譬如cin；</p> 
<p>string&amp;str表示把从输入流读入的字符串存放在这个字符串中（可以自己随便命名，str什么的都可以）；</p> 
<p>char delim表示遇到这个字符停止读入，在不设置的情况下系统默认该字符为'\n'，也就是回车换行符（遇到回车停止读入）。</p> 
<p>例如：</p> 
<pre class="has"><code class="language-cpp">string line;
cout&lt;&lt;"please cin a line:";
getline（cin,line,'#');
cout&lt;&lt;"The line you give is:"&lt;&lt;line&lt;&lt;endl;</code></pre> 
<p>输入"You are the #best!" 的时候，输入流实际上只读入了"You are the "，#后面的并没有存放到line中。</p> 
<p>程序运行结果应该是这样的： </p> 
<pre class="has"><code>please cin a line:You are the #best!
The line you give is:You are the </code></pre> 
<p>while(getline(cin,line))语句</p> 
<p>注意这里默认回车符停止读入,按Ctrl+Z或键入回车即可退出循环。</p> 
<p>在这个语句中，首先getline从标准输入设备上读入字符，然后返回给输入流cin，注意了，是cin，所以while判断语句的真实判断对象是cin，也就是判断当前是否存在有效的输入流。在这种情况下，我想只要你的电脑不中毒不发神经你的输入流怎么会没有效？所以这种情况下不管你怎么输入都跳不出循环，因为你的输入流有效，跳不出循环。</p> 
<p>然而有些同学误以为while判断语句的判断对象是line（也就是line是否为空），然后想通过直接回车（即输入一个空的line）跳出循环，却发现怎么也跳不出循环。这是因为你的回车只会终止getline()函数的读入操作。getline()函数终止后又进行while（）判断（即判断输入流是否有效，你的输入流当然有效，满足条件），所以又运行getline()函数。</p> 
<p>所以，以下的写法根本不可能让你推出while（）循环的：</p> 
<p>while(getline(cin,line))    cout&lt;&lt;line&lt;&lt;endl;</p> 
<p><strong>二、cin.getline()</strong></p> 
<p>此函数会一次读取多个字符(包括空白字符）。它以指定的地址为存放第一个读取的字符的位置，依次向后存放读取的字符，直到读满N-1个，或者遇到指定的结束符为止。若不指定结束符，则默认结束符为'\n'。其语法为:</p> 
<p>cin.getline(字符指针(char*),字符个数N(int),结束符(char));</p> 
<pre class="has"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{char a[30];
 cout &lt;&lt; "请输入一个字符串：" &lt;&lt; endl;
 cin.getline(a, 10);//第10位存放字符串结束符'\0'
 for (int i = 0; i&lt;10; i++)
 cout &lt;&lt; "第"&lt;&lt;i+1&lt;&lt;"个值为："&lt;&lt;a[i] &lt;&lt; endl;
 return 0;
}</code></pre> 
<p>输入:1234567890123</p> 
<p>输出:</p> 
<pre class="has"><code>请输入一个字符串：
第1个值为：1
第2个值为：2
第3个值为：3
第4个值为：4
第5个值为：5
第6个值为：6
第7个值为：7
第8个值为：8
第9个值为：9
第10个值为：</code></pre> 
<p></p> 
<h2>八、<strong>string的搜索操作:  </strong></h2> 
<h3><strong>8.1、 find()  和  rfind() 函数:  find函数主要是查找一个字符串是否在调用的字符串中出现过，大小写敏感。</strong></h3> 
<p>str.find(str2)，当str2是str的子串时，返回其在str中第一次出现的位置，否则返回string::npos。</p> 
<p>str.find(str2,pos)，是从str的pos号位开始查找匹配str2，找到返回其位置；否则返回string::npos。</p> 
<p>string::npos是一个常数，其本身的值等于-1，但由于是unsigned int类型，因此，也可以认为是unsigned int类型的最大值（4294967295）。</p> 
<p>rfind()与find()很相似，差别在于查找顺序不一样，find()是从指定位置起向后查找，直到串尾。rfind()是从指定位置起向前查找，直到串首，相当于逆向查找，<span style="color:#f33b45;"><strong>返回的位置仍然是从前往后数的。</strong></span></p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:89px;">返回值类型</td><td style="width:306px;">函数</td><td style="width:454px;">描述</td></tr><tr><td style="width:89px;">int</td><td style="width:306px;">str.find(char c, int pos = 0);</td><td style="width:454px;">从pos开始查找字符c在C++字符串str中的位置</td></tr><tr><td style="width:89px;">int</td><td style="width:306px;">str.find(const char *s, int pos = 0); </td><td style="width:454px;">从pos开始查找c语言字符串s在C++字符串str中的位置</td></tr><tr><td style="width:89px;">int</td><td style="width:306px;">str.find(const char *s, int pos, int n);</td><td style="width:454px;">从pos开始查找c语言字符串s中前n个字符在C++字符串str中的位置</td></tr><tr><td style="width:89px;">int</td><td style="width:306px;">str.find(const string &amp;s, int pos = 0); </td><td style="width:454px;">从pos开始查找c++字符串s在C++字符串str中的位置。</td></tr><tr><td style="width:89px;">int</td><td style="width:306px;">str.rfind(char c, int pos = npos);</td><td style="width:454px;">从pos开始从后向前查找字符c在C++字符串str中的位置</td></tr><tr><td style="width:89px;">int</td><td style="width:306px;">str.rfind(const char *s, int pos = npos);  </td><td style="width:454px;">从pos开始从后向前查找c语言字符串s在C++字符串str中的位置</td></tr><tr><td style="width:89px;">int</td><td style="width:306px;">str.rfind(const char *s, int pos, int n = npos);</td><td style="width:454px;">从pos开始从后向前查找c语言字符串s中前n个字符在C++字符串str中的位置</td></tr><tr><td style="width:89px;">int</td><td style="width:306px;">str.rfind(const string &amp;s,int pos = npos);</td><td style="width:454px;">从pos开始从后向前查找c++字符串s在C++字符串str中的位置。</td></tr></tbody></table> 
<p>例一、</p> 
<pre class="has"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    string str ("There are two needles in this haystack with needles.");
    string str2 ("needle");

    //在str当中查找第一个出现的needle，找到则返回出现的位置，否则返回结尾
    int found = str.find(str2);
    if (found!=string::npos)
    cout &lt;&lt; "first 'needle' found at: " &lt;&lt; found &lt;&lt; '\n';
    //在str当中，从第found+1的位置开始查找参数字符串的前6个字符
    found=str.find("needles are small",found+1,6);
    if (found!=string::npos)
    cout &lt;&lt; "second 'needle' found at: " &lt;&lt; found &lt;&lt; '\n';
    //在str当中查找参数中的字符串
    found=str.find("haystack");
    if (found!=string::npos)
    cout &lt;&lt; "'haystack' also found at: " &lt;&lt; found &lt;&lt; '\n';
    //查找一个字符
    found=str.find('.');
    if (found!=string::npos)
    cout &lt;&lt; "Period found at: " &lt;&lt; found &lt;&lt; '\n';
    //组合使用，把str2用参数表中的字符串代替
    // let's replace the first needle:
    str.replace(str.find(str2),str2.length(),"preposition");
    cout &lt;&lt; str &lt;&lt; '\n';
    return 0;
}</code></pre> 
<p>程序结果：</p> 
<pre class="has"><code>first 'needle' found at: 14
second 'needle' found at: 44
'haystack' also found at: 30
Period found at: 51
There are two prepositions in this haystack with needles.
</code></pre> 
<p>例二、</p> 
<pre class="has"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{//测试find (charT c, size_type pos = 0) const noexcept;
 string st1("babbabab");
 cout &lt;&lt;st1.find('a')&lt;&lt;endl;//1 由原型知，若省略第2个参数，则默认从位置0（即第1个字符）起开始查找
 cout&lt;&lt;st1.find('a',0)&lt;&lt;endl;//1
 cout&lt;&lt;st1.find('a',1)&lt;&lt;endl;//1   
 cout&lt;&lt;st1.find('a',2)&lt;&lt;endl;//4  在st1中，从位置2（包括位置2）开始查找字符a，返回首次匹配的位置，匹配失败，返回npos
 cout&lt;&lt;st1.rfind('a',7)&lt;&lt;endl;//6  
 cout&lt;&lt;st1.find('c',0)&lt;&lt;endl;//4294967295
 cout&lt;&lt;(st1.find('c',0) == -1)&lt;&lt;endl;//1
 cout&lt;&lt;(st1.find('c',0)==4294967295)&lt;&lt;endl;//1 两句均输出1，原因是计算机中-1和4294967295都表示为32个1（二进制）
 cout&lt;&lt;st1.find('a',100)&lt;&lt;endl;//4294967295  当查找的起始位置超出字符串长度时，按查找失败处理，返回npos
 
//测试find (const basic_string&amp; str, size_type pos = 0);
 string st2("aabcbcabcbabcc");
 string str1("abc");
 cout&lt;&lt;st2.find(str1,2)&lt;&lt;endl;//6  从st2的位置2开始匹配，返回第一次成功匹配时匹配的串（abc）的首字符在st2中的位置，失败返回npos

//测试size_type find (const charT* s, size_type pos = 0) ;
 cout &lt;&lt; st2.find("abc",2)&lt;&lt;endl; //6   同上，只不过参数不是string而是char*

//测试size_type find (const charT* s, size_type pos, size_type n) ;
 cout&lt;&lt;st2.find("abcdefg",2,3)&lt;&lt;endl;//6   取abcdefg得前3个字符（abc）参与匹配，相当于st2.find("abc",2)
 cout&lt;&lt;st2.find("abcbc",0,5)&lt;&lt;endl;//1  相当于st2.find("abcbc", 0)
 cout&lt;&lt;st2.find("abcbc",0,6)&lt;&lt;endl;//4294967295  第3个参数超出第1个参数的长度时，返回npos
}</code></pre> 
<p>例三、</p> 
<pre class="has"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    string str ("The sixth sick sheik's sixth sheep's sick.");
    string key ("sixth");//                    ^
    //rfind是找最后一个出现的匹配字符串
    size_t found = str.rfind(key);
    if (found!=string::npos)
    {
        cout&lt;&lt;found&lt;&lt;endl;//输出23
        str.replace (found,key.length(),"seventh");//找到的sixth替换成seventh
    }
    cout &lt;&lt; str &lt;&lt; '\n';
    return 0;
}</code></pre> 
<p>程序结果：</p> 
<pre class="has"><code>23
The sixth sick sheik's seventh sheep's sick.</code></pre> 
<h3><strong>8.2、find_first_of（）和 find_first_not_of（）和 函数:  </strong><br>         在源串中从位置pos起往后查找，只要在源串中遇到一个字符，该字符与目标串中<strong>任意一个字符</strong>相同，就停止查找，返回该字符在源串中的位置；若匹配失败，返回npos。</h3> 
<p>        注意find_first_of函数和find函数的区别，如果是str.find(“abc”)的话，则必须找到完全匹配abc的才算查找成功，而find_first_of只需要abc中任何一个出现即可。</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:92px;">返回值类型</td><td style="width:331px;">函数</td><td style="width:426px;">描述</td></tr><tr><td style="width:92px;">int</td><td style="width:331px;">str.find_first_of(char c, int pos = 0);</td><td style="width:426px;">从pos开始查找字符c在C++字符串str中的位置</td></tr><tr><td style="width:92px;">int</td><td style="width:331px;">str.find_first_of(const char *s, int pos = 0); </td><td style="width:426px;">从pos开始查找c语言字符串s中<span style="color:#f33b45;">任何一个字符首次</span>在C++字符串str中的位置</td></tr><tr><td style="width:92px;">int</td><td style="width:331px;">str.find_first_of(const char *s, int pos, int n);</td><td style="width:426px;">从pos开始查找c语言字符串s中前n个字符中<span style="color:#f33b45;">任何一个字符首次</span>在C++字符串str中的位置</td></tr><tr><td style="width:92px;">int</td><td style="width:331px;">str.find_first_of(const string &amp;s,int pos = 0); </td><td style="width:426px;">从pos开始查找c++字符串s中<span style="color:#f33b45;">任何一个字符首次</span>在C++字符串str中的位置。</td></tr><tr><td style="width:92px;">int</td><td style="width:331px;">str.find_first_not_of(char c, int pos = 0);</td><td style="width:426px;">从pos开始查找字符c<span style="color:#f33b45;">以外的任何一个字符</span>在C++字符串str中的位置</td></tr><tr><td style="width:92px;">int</td><td style="width:331px;">str.find_first_not_of(const char *s, int pos = 0);  </td><td style="width:426px;">从pos开始c语言字符串s<span style="color:#f33b45;">以外的任何一个字符</span>在C++字符串str中的位置</td></tr><tr><td style="width:92px;">int</td><td style="width:331px;">str.find_first_not_of(const char *s, int pos,int n);</td><td style="width:426px;">从pos开始查找c语言字符串s中前n个字符<span style="color:#f33b45;">以外的任何一个字符</span>在C++字符串str中的位置</td></tr><tr><td style="width:92px;">int</td><td style="width:331px;">str.find_first_not_of(const string &amp;s,int pos = 0);</td><td style="width:426px;">从pos开始查找c++字符串s<span style="color:#f33b45;">以外的任何一个字符</span>在C++字符串str中的位置。</td></tr></tbody></table> 
<h3><strong>8.3、find_last_of（）和 find_last_not_of（）和 函数:  </strong></h3> 
<p>在源串中从位置pos起往前查找，只要在源串中遇到一个字符，该字符与目标串中<strong>任意一个字符</strong>相同，就停止查找，返回该字符在源串中的位置；若匹配失败，返回npos。<span style="color:#f33b45;">find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找</span></p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:92px;">返回值类型</td><td style="width:350px;">函数</td><td style="width:407px;">描述</td></tr><tr><td style="width:92px;">int</td><td style="width:350px;">str.find_last_of(char c, pos = npos);</td><td style="width:407px;">从pos开始<span style="color:#3399ea;">由后向前</span>查找字符c在C++字符串str中的位置</td></tr><tr><td style="width:92px;">int</td><td style="width:350px;">str.find_last_of(const char *s, int pos = npos); </td><td style="width:407px;">从pos开始<span style="color:#3399ea;">由后向前</span>查找c语言字符串s中<span style="color:#f33b45;">任何一个字符首次</span>在C++字符串str中的位置</td></tr><tr><td style="width:92px;">int</td><td style="width:350px;">str.find_last_of(const char *s, int pos, int n=npos);</td><td style="width:407px;">从pos开始<span style="color:#3399ea;">由后向前</span>查找c语言字符串s中前n个字符中<span style="color:#f33b45;">任何一个字符首次</span>在C++字符串str中的位置</td></tr><tr><td style="width:92px;">int</td><td style="width:350px;">str.find_last_of(const string &amp;s,int pos = npos); </td><td style="width:407px;">从pos开始<span style="color:#3399ea;">由后向前</span>查找c++字符串s中<span style="color:#f33b45;">任何一个字符首次</span>在C++字符串str中的位置。</td></tr><tr><td style="width:92px;">int</td><td style="width:350px;">str.find_last_not_of(char c, int pos = npos);</td><td style="width:407px;">从pos开始<span style="color:#3399ea;">由后向前</span>从后向前查找字符c<span style="color:#f33b45;">以外的任何一个字符</span>在C++字符串str中的位置</td></tr><tr><td style="width:92px;">int</td><td style="width:350px;">str.find_last_not_of(const char *s, int pos = npos);  </td><td style="width:407px;">从pos开始<span style="color:#3399ea;">由后向前</span>从后向前查找c语言字符串s<span style="color:#f33b45;">以外的任何一个字符</span>在C++字符串str中的位置</td></tr><tr><td style="width:92px;">int</td><td style="width:350px;">str.find_last_not_of(const char *s, int pos,int n);</td><td style="width:407px;">从pos开始<span style="color:#3399ea;">由后向前</span>从后向前查找c语言字符串s中前n个字符<span style="color:#f33b45;">以外的任何一个字符</span>在C++字符串str中的位置</td></tr><tr><td style="width:92px;">int</td><td style="width:350px;">str.find_last_not_of(const string &amp;s,int pos = npos);</td><td style="width:407px;">从pos开始<span style="color:#3399ea;">由后向前</span>从后向前查找c++字符串s<span style="color:#f33b45;">以外的任何一个字符</span>在C++字符串str中的位置。</td></tr></tbody></table> 
<h2><strong>九、string的子串substr():</strong></h2> 
<p>这个函数的作用是取字符串str中位置为pos开始的len个字符，返回一个字符串。</p> 
<p>如果pos开始后len个字符长度超出了字符串的长度，则取到最后一个字符。</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:89px;">返回值类型</td><td style="width:326px;">函数</td><td style="width:363px;">描述</td></tr><tr><td style="width:89px;">string</td><td style="width:326px;">str.substr(int pos = 0,int n = npos) ;</td><td style="width:363px;">返回pos开始的n个字符组成的字符串给str字符串</td></tr></tbody></table> 
<p>假设：string s = “0123456789”;</p> 
<pre class="has"><code class="language-cpp">string sub1 = s.substr(5); //只有一个参数5,  则表示从下标为5开始一直到结尾：sub1 = “56789”

string sub2 = s.substr(5, 3); //有二个参数（5，3），表示从下标为5开始截取长度为3位：sub2 = “567”</code></pre> 
<h3></h3> 
<h2>10、读程序，写结果：</h2> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std; 
int main()
{  string str1; 
   cin &gt;&gt; str1;//当用cin&gt;&gt;进行字符串的输入的时候，遇到空格的地方就停止字符串的读取输入
   cout &lt;&lt; str1 &lt;&lt; endl;   
   cin.get();//这个的作用就是读取cin&gt;&gt;输入的结束符，不用会对getline的输入产生影响！
   getline(cin, str1);//字符串的行输入
   cout &lt;&lt; str1 &lt;&lt; endl;   

   string str2 = "aaaaa";//最简单的字符串初始化
   cout &lt;&lt; str2 &lt;&lt; endl;   

   char *s = "bbbbb";   
   string str3(s);//用c字符串s初始化
   cout &lt;&lt; str3 &lt;&lt; endl;   

   char ch = 'c';   
   string str4(5, ch);//用n个字符ch初始化
   cout &lt;&lt; str4 &lt;&lt; endl;   

   string str5 = "abcde";   
   ch = str5[3];//返回当前字符串中第n个字符的位置
   cout &lt;&lt; ch &lt;&lt; endl;   

   string str6 = "abcde";   
   ch = str6.at(4);    //at()返回当前字符串中第n个字符的位置,并且提供范围检查，当越界时会抛出异常！
   cout &lt;&lt; ch &lt;&lt; endl;    

   string str7 = "abcdefgh";   
   int size;    
   size = str7.capacity();    //返回当前容量 
   cout &lt;&lt; size &lt;&lt; endl;   
   size = str7.max_size();   //返回string对象中可存放的最大字符串的长度 
   cout &lt;&lt; size &lt;&lt; endl;   
   size = str7.size();        //返回当前字符串的大小 
   cout &lt;&lt; size &lt;&lt; endl;   
   size = str7.length();      //返回当前字符串的长度 
   cout &lt;&lt; size &lt;&lt; endl;   
   bool flag;   
   flag = str7.empty();      //判断当前字符串是否为空 
   cout &lt;&lt; flag &lt;&lt; endl;   
   int len = 10;   
   str7.resize(len, ch);   //把字符串当前大小置为len，并用字符ch填充不足的部分 
   cout &lt;&lt; str7 &lt;&lt; endl;   

   string str8;   
   str8 = str7;              //把字符串str7赋给当前字符串 
   cout &lt;&lt; str8 &lt;&lt; endl;   
   str8.assign(str7);      //把字符串str7赋给当前字符串 
   cout &lt;&lt; str8 &lt;&lt; endl;    
   str8.assign(s);         //用c类型字符串s赋值 ?
   cout &lt;&lt; str8 &lt;&lt; endl;    
   str8.assign(s, 2);         //用c类型字符串s开始的n个字符赋值 
   cout &lt;&lt; str8 &lt;&lt; endl;   
   str8.assign(len, ch);   //用len个字符ch赋值给当前字符串 
   cout &lt;&lt; str8 &lt;&lt; endl;   
   str8.assign(str7, 0, 3);   //把字符串str7中从0开始的3个字符赋给当前字符串 
   cout &lt;&lt; str8 &lt;&lt; endl;    
   string str9 = "0123456789";   
   str8.assign(str9.begin(), str9.end());//把迭代器之间的字符赋给字符串 
   cout &lt;&lt; str8 &lt;&lt; endl;    

   string str10;   
   str10 += str9;          //把字符串str9连接到当前字符串的结尾 
   cout &lt;&lt; str10 &lt;&lt; endl;    
   str10.append(s);         //把c类型字符串s连接到当前字符串的结尾 
   cout &lt;&lt; str10 &lt;&lt; endl;   
   str10.append(s, 2);      //把c类型字符串s的前2个字符连接到当前字符串的结尾 
   cout &lt;&lt; str10 &lt;&lt; endl;    
   str10.append(str9.begin(), str9.end());      //把迭代器之间的一段字符连接到当前字符串的结尾 
   cout &lt;&lt; str10 &lt;&lt; endl;    
   str10.push_back('k');   //把一个字符连接到当前字符串的结尾 
   cout &lt;&lt; str10 &lt;&lt; endl;   

   //7.string的比较 ?
   flag = (str9 == str10);   //判断两个字符串是否相等 
   cout &lt;&lt; flag &lt;&lt; endl;    
   flag = (str9 != str10);   //判断两个字符串是否不相等 
   cout &lt;&lt; flag &lt;&lt; endl;    
   flag = (str9 &gt; str10);   //判断两个字符串是否大于关系 
   cout &lt;&lt; flag &lt;&lt; endl;   
   flag = (str9 &lt; str10);   //判断两个字符串是否为小于关系 
   cout &lt;&lt; flag &lt;&lt; endl;    
   flag = (str9 &gt;= str10);   //判断两个字符串是否为大于等于关系 
   cout &lt;&lt; flag &lt;&lt; endl;    
   flag = (str9 &lt;= str10);   //判断两个字符串否为小于等于关系 
   cout &lt;&lt; flag &lt;&lt; endl;    

   //以下的3个函数同样适用于c类型的字符串，
   //在compare函数中&gt;时返回1，&lt;时返回-1，=时返回0 
   flag = str10.compare(str9);   //比较两个字符串的大小，通过ASCII的相减得出！ 
   cout &lt;&lt; flag &lt;&lt; endl;   
   flag = str10.compare(6, 12, str9);   //比较str10字符串从6开始的12个字符组成的字符串与str9的大小 
   cout &lt;&lt; flag &lt;&lt; endl;   
   flag = str10.compare(6, 12, str9, 3, 5);   //比较str10字符串从6开始的12个字符组成的字符串与str9字符串从3开始的5个字符组成的字符串的大小 
   cout &lt;&lt; flag &lt;&lt; endl;   


   string str11;   
   str11 = str10.substr(10, 15);   //返回从下标10开始的15个字符组成的字符串 
   cout &lt;&lt; str11 &lt;&lt; endl;   

   //9.string的交换 ?
   str11.swap(str10);   //交换str11与str10的值 
   cout &lt;&lt; str11 &lt;&lt; endl;   

   //10.string的查找，查找成功时返回所在位置，失败时返回string::npos的值，即是-1 
   string str12 = "abcdefghijklmnopqrstuvwxyz";   
   int pos;   
   pos = str12.find('i', 0);     //从位置0开始查找字符i在当前字符串的位置 
   cout &lt;&lt; pos &lt;&lt; endl;   
   pos = str12.find("ghijk", 0);   //从位置0开始查找字符串“ghijk”在当前字符串的位置 
   cout &lt;&lt; pos &lt;&lt; endl;   
   pos = str12.find("opqrstuvw", 0, 4);   //从位置0开始查找字符串“opqrstuvw”前4个字符组成的字符串在当前字符串中的位置 
   cout &lt;&lt; pos &lt;&lt; endl;   
   pos = str12.rfind('s', string::npos);   //从字符串str12反向开始查找字符s在字符串中的位置 
   cout &lt;&lt; pos &lt;&lt; endl;   
   pos = str12.rfind("klmn", string::npos);   //从字符串str12反向开始查找字符串“klmn”在字符串中的位置 
   cout &lt;&lt; pos &lt;&lt; endl;   
   pos = str12.rfind("opqrstuvw", string::npos, 3);   //从string::pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置 
   cout &lt;&lt; pos &lt;&lt; endl;   

   string str13 = "aaaabbbbccccdddeeefffggghhhiiijjjkkllmmmandjfaklsdfpopdtwptioczx";   
   pos = str13.find_first_of('d', 0);   //从位置0开始查找字符d在当前字符串第一次出现的位置
   cout &lt;&lt; pos &lt;&lt; endl;    
   pos = str13.find_first_of("eefff", 0);   //从位置0开始查找字符串“eeefff“在当前字符串中第一次出现的位置 
   cout &lt;&lt; pos &lt;&lt; endl;   
   pos = str13.find_first_of("efff", 0, 3);   //从位置0开始查找当前串中第一个在字符串”efff“的前3个字符组成的数组里的字符的位置 
   cout &lt;&lt; pos &lt;&lt; endl;    
   pos = str13.find_first_not_of('b', 0);   //从当前串中查找第一个不在串s中的字符出现的位置 
   cout &lt;&lt; pos &lt;&lt; endl;    
   pos = str13.find_first_not_of("abcdefghij", 0);   //从当前串中查找第一个不在串s中的字符出现的位置 
   cout &lt;&lt; pos &lt;&lt; endl;    
   pos = str13.find_first_not_of("abcdefghij", 0, 3);   //从当前串中查找第一个不在由字符串”abcdefghij”的前3个字符所组成的字符串中的字符出现的位置 
   cout &lt;&lt; pos &lt;&lt; endl;    

   //下面的last的格式和first的一致，只是它从后面检索！   
   pos = str13.find_last_of('b', string::npos);    
   cout &lt;&lt; pos &lt;&lt; endl;   
   pos = str13.find_last_of("abcdef", string::npos);    
   cout &lt;&lt; pos &lt;&lt; endl;    
   pos = str13.find_last_of("abcdef", string::npos, 2);   
   cout &lt;&lt; pos &lt;&lt; endl;   
   pos = str13.find_last_not_of('a', string::npos);   
   cout &lt;&lt; pos &lt;&lt; endl;    
   pos = str13.find_last_not_of("abcdef", string::npos);   
   cout &lt;&lt; pos &lt;&lt; endl;   
   pos = str13.find_last_not_of("abcdef", string::npos, 3);   
   cout &lt;&lt; pos &lt;&lt; endl;   

   //11.string的替换 
   string str14 = "abcdefghijklmn";    
   str14.replace(0, 3, "qqqq");   //删除从0开始的3个字符，然后在0处插入字符串“qqqq” 
   cout &lt;&lt; str14 &lt;&lt; endl;   
   str14.replace(0, 3, "vvvv", 2);    //删除从0开始的3个字符，然后在0处插入字符串“vvvv”的前2个字符 
   cout &lt;&lt; str14 &lt;&lt; endl;   
   str14.replace(0, 3, "opqrstuvw", 2, 4);   //删除从0开始的3个字符，然后在0处插入字符串“opqrstuvw”从位置2开始的4个字符 
   cout &lt;&lt; str14 &lt;&lt; endl;   
   str14.replace(0, 3, 8, 'c');   //删除从0开始的3个字符，然后在0处插入8个字符 c 
   cout &lt;&lt; str14 &lt;&lt; endl;   
   //上面的位置可以换为迭代器的位置，操作是一样的，在这里就不再重复了！ 

   //12.string的插入，下面的位置处亦可以用迭代器的指针表示，操作是一样的 
   string str15 = "abcdefg";   
   str15.insert(0, "mnop");//在字符串的0位置开始处，插入字符串“mnop” 
   cout &lt;&lt; str15 &lt;&lt; endl;   
   str15.insert(0, 2, 'm');    //在字符串的0位置开始处，插入2个字符m 
   cout &lt;&lt; str15 &lt;&lt; endl;   
   str15.insert(0, "uvwxy", 3);   //在字符串的0位置开始处，插入字符串“uvwxy”中的前3个字符 
   cout &lt;&lt; str15 &lt;&lt; endl;    
   str15.insert(0, "uvwxy", 1, 2);    //在字符串的0位置开始处，插入从字符串“uvwxy”的1位置开始的2个字符
   cout &lt;&lt; str15 &lt;&lt; endl;   

   //13.string的删除 
   string str16 = "gfedcba"; 
   string::iterator it;   
   it = str16.begin();   
   it++;   
   str16.erase(it);   //删除it指向的字符，返回删除后迭代器的位置 
   cout &lt;&lt; str16 &lt;&lt; endl;   
   str16.erase(it, it+3);   //删除it和it+3之间的所有字符，返回删除后迭代器的位置 
   cout &lt;&lt; str16 &lt;&lt; endl;   
   str16.erase(2);   //删除从字符串位置3以后的所有字符，返回位置3前面的字符 
   cout &lt;&lt; str16 &lt;&lt; endl;   

   //14.字符串的流处理 
   string str17("hello,this is a test");
   istringstream is(str17);
   string s1,s2,s3,s4;
   is&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3&gt;&gt;s4;
   //s1="hello,this",s2="is",s3="a",s4="test" 
   ostringstream os;
   os&lt;&lt;s1&lt;&lt;s2&lt;&lt;s3&lt;&lt;s4;
   cout&lt;&lt;os.str() &lt;&lt; endl;

}   </code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a2cb39b41022dbc20e06e357ca170bf9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言实现24点小游戏</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4feb2347744253411654aac0038a809e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PYQGIS独立应用开发</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>