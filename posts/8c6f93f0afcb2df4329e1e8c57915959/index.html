<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>嵌入式linux面试题解析（二）——C语言部分一 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="嵌入式linux面试题解析（二）——C语言部分一" />
<meta property="og:description" content="1、编写统计一个数二进制表示中有多少个1的函数
int count_bit1(int m)
{
int count = 0;
while(m)
{
m = m &amp; (m-1);
count&#43;&#43;;
}
return count;
}
2、编写一个函数判断一个数是否是2的N次方
int is_number(int num)
{
if( m &amp; (m - 1) == 0)
return 0;//如果一个数是2的N次方，返回0
else
return 1;//如果一个数不是2的N次方，返回1
}
3、用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
#define SECONDS_PER_YEAR (1UL*60 * 60 * 24 * 365)
兼容16位CPU， #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL这种用法在GCC是不能编译通过的。
4、预处理器标识#error的目的是什么？
#error error-message停止编译并显示错误信息,error-message不需要双引号
5、嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？
while(1)
{
;
}" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/8c6f93f0afcb2df4329e1e8c57915959/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-10-23T09:57:20+08:00" />
<meta property="article:modified_time" content="2017-10-23T09:57:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">嵌入式linux面试题解析（二）——C语言部分一</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:justify"><span style="font-family:'楷体'; font-size:19px">1、编写统计一个数二进制表示中有多少个1的函数</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">int count_bit1(int m)</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">{<!-- --></span></p> 
<p style="text-indent:60px"><span style="font-family:'楷体'; font-size:16px">int count = 0;</span></p> 
<p style="text-indent:60px"><span style="font-family:'楷体'; font-size:16px">while(m)</span></p> 
<p style="text-indent:60px"><span style="font-family:'楷体'; font-size:16px">{<!-- --></span></p> 
<p style="text-indent:88px"><span style="font-family:'楷体'; font-size:16px">m = m &amp; (m-1);</span></p> 
<p style="text-indent:88px"><span style="font-family:'楷体'; font-size:16px">count++;</span></p> 
<p style="text-indent:60px"><span style="font-family:'楷体'; font-size:16px">}</span></p> 
<p style="text-indent:60px"><span style="font-family:'楷体'; font-size:16px">return count;</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">}</span></p> 
<p><span style="font-family:'楷体'; font-size:16px"> </span></p> 
<p style="text-align:justify"><span style="font-family:'楷体'; font-size:19px">2、编写一个函数判断一个数是否是2的N次方</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">int is_number(int num)</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">{<!-- --></span></p> 
<p style="text-indent:60px"><span style="font-family:'楷体'; font-size:16px">if( m &amp; (m - 1) == 0)</span></p> 
<p style="text-indent:88px"><span style="font-family:'楷体'; font-size:16px">return 0;//<span style="font-family:'楷体'">如果一个数是</span><span style="font-family:'宋体'">2</span><span style="font-family:'楷体'">的</span><span style="font-family:'宋体'">N</span><span style="font-family:'楷体'">次方，返回</span><span style="font-family:'宋体'">0</span></span></p> 
<p style="text-indent:60px"><span style="font-family:'楷体'; font-size:16px">else</span></p> 
<p style="text-indent:88px"><span style="font-family:'楷体'; font-size:16px">return 1;//<span style="font-family:'楷体'">如果一个数不是</span><span style="font-family:'宋体'">2</span><span style="font-family:'楷体'">的</span><span style="font-family:'宋体'">N</span><span style="font-family:'楷体'">次方，返回</span><span style="font-family:'宋体'">1</span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">}</span></p> 
<p><span style="font-family:'楷体'; font-size:16px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">3、</span><span style="font-family:'楷体'; font-size:19px">用预处理指令</span><span style="font-family:'楷体'; font-size:19px">#define </span><span style="font-family:'楷体'; font-size:19px">声明一个常数，用以表明</span><span style="font-family:'楷体'; font-size:19px">1</span><span style="font-family:'楷体'; font-size:19px">年中有多少秒（忽略闰年问题）</span></p> 
<p><span style="font-family:Arial; font-size:18px">    #define    </span><span style="font-family:Arial; font-size:18px">SECONDS_PER_YEAR    </span><span style="font-family:Arial; font-size:18px">(1UL*60 * 60 * 24 * 365)</span><span style="font-family:'宋体'; font-size:18px"></span></p> 
<p><span style="font-family:'楷体'; font-size:19px">     兼容16位CPU，<span style="font-family:Arial; font-size:18px">  #define    </span><span style="font-family:Arial; font-size:18px">SECONDS_PER_YEAR    </span><span style="font-family:Arial; font-size:18px">(60 * 60 * 24 * 365)</span>UL这种用法在GCC是不能编译通过的。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">4、</span><span style="font-family:'楷体'; font-size:19px">预处理器标识</span><span style="font-family:'楷体'; font-size:19px">#error</span><span style="font-family:'楷体'; font-size:19px">的目的是什么？</span></p> 
<p style="margin-left:43px"><span style="font-family:'楷体'; font-size:19px">#error </span><span style="font-family:'楷体'; font-size:19px">error-message</span><span style="font-family:'楷体'; font-size:19px">停止编译并显示错误信息</span><span style="font-family:'楷体'; font-size:19px">,error-message不需要双引号</span></p> 
<p style="margin-left:43px"><span style="font-family:'楷体'; font-size:19px"><br> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">5、</span><span style="font-family:'楷体'; font-size:19px">嵌入式系统中经常要用到无限循环，你怎么样用</span><span style="font-family:'楷体'; font-size:19px">C</span><span style="font-family:'楷体'; font-size:19px">编写死循环呢？</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:Arial; font-size:18px">while(1)</span><span style="font-family:Arial; font-size:18px"><br> </span><span style="font-family:Arial; font-size:18px">{<!-- --></span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'宋体'; font-size:18px">;</span><span style="font-family:Arial; font-size:18px"><br> </span><span style="font-family:Arial; font-size:18px">}</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:Arial; font-size:18px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">6、</span><span style="font-family:'楷体'; font-size:19px">用变量</span><span style="font-family:'楷体'; font-size:19px">a</span><span style="font-family:'楷体'; font-size:19px">给出下面的定义</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">a) </span><span style="font-family:'楷体'; font-size:19px">一个整型数（</span><span style="font-family:'楷体'; font-size:19px">An integer</span><span style="font-family:'楷体'; font-size:19px">）</span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">b)</span><span style="font-family:'楷体'; font-size:19px">一个指向整型数的指针（</span><span style="font-family:'楷体'; font-size:19px"> A pointer to an integer</span><span style="font-family:'楷体'; font-size:19px">）</span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">c)</span><span style="font-family:'楷体'; font-size:19px">一个指向指针的指针，它指向的指针是指向一个整型数（</span><span style="font-family:'楷体'; font-size:19px"> A pointer to a pointer to an intege</span><span style="font-family:'楷体'; font-size:19px">r</span><span style="font-family:'楷体'; font-size:19px">）</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">d)</span><span style="font-family:'楷体'; font-size:19px">一个有</span><span style="font-family:'楷体'; font-size:19px">10</span><span style="font-family:'楷体'; font-size:19px">个整型数的数组（</span><span style="font-family:'楷体'; font-size:19px"> An array of 10 integers</span><span style="font-family:'楷体'; font-size:19px">）</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">e) </span><span style="font-family:'楷体'; font-size:19px">一个有</span><span style="font-family:'楷体'; font-size:19px">10</span><span style="font-family:'楷体'; font-size:19px">个指针的数组，该指针是指向一个整型数的。（</span><span style="font-family:'楷体'; font-size:19px">An array of 10 pointers to integers</span><span style="font-family:'楷体'; font-size:19px">）</span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">f) </span><span style="font-family:'楷体'; font-size:19px">一个指向有</span><span style="font-family:'楷体'; font-size:19px">10</span><span style="font-family:'楷体'; font-size:19px">个整型数数组的指针（</span><span style="font-family:'楷体'; font-size:19px"> A pointer to an array of 10 integers</span><span style="font-family:'楷体'; font-size:19px">）</span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">g) </span><span style="font-family:'楷体'; font-size:19px">一个指向函数的指针，该函数有一个整型参数并返回一个整型数（</span><span style="font-family:'楷体'; font-size:19px">A pointer to a function that takes an integer as anargument and returns an integer</span><span style="font-family:'楷体'; font-size:19px">）</span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">h)</span><span style="font-family:'楷体'; font-size:19px">一个有</span><span style="font-family:'楷体'; font-size:19px">10</span><span style="font-family:'楷体'; font-size:19px">个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（</span><span style="font-family:'楷体'; font-size:19px"> An array of ten pointers to functions that take aninteger argument and return an integer </span><span style="font-family:'楷体'; font-size:19px">）</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:16px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">定义如下：</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">a) int a; // An integer </span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">b) int *a; // A pointer to an integer </span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">c) int **a; // A pointer to a pointer to an integer </span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">d) int a[10]; // An array of 10 integers</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">e) int *a[10]; // Anarray of 10 pointers to integers </span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">等价于</span><span style="font-family:'楷体'; font-size:19px">int *(a[10]);</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">f) int (*a)[10]; // Apointer to an array of 10 integers </span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">g) int (*max_function)(int a); // A pointer to afunction a that takes an integer argument and returns an integer</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">h) int (*a[10])(int);// An array of 10 pointers to functions that take an integer argument andreturn an integer</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">7、</span><span style="font-family:'楷体'; font-size:19px">键字</span><span style="font-family:'楷体'; font-size:19px">static</span><span style="font-family:'楷体'; font-size:19px">的作用是什么？</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    在</span><span style="font-family:'楷体'; font-size:19px">C</span><span style="font-family:'楷体'; font-size:19px">语言中，关键字</span><span style="font-family:'楷体'; font-size:19px">static</span><span style="font-family:'楷体'; font-size:19px">有三个明显的作用：</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    A、</span><span style="font-family:'楷体'; font-size:19px">一旦声明为静态变量</span><span style="font-family:'楷体'; font-size:19px">,</span><span style="font-family:'楷体'; font-size:19px">在编译时刻开始永远存在</span><span style="font-family:'楷体'; font-size:19px">,</span><span style="font-family:'楷体'; font-size:19px">不受作用域范围约束</span><span style="font-family:'楷体'; font-size:19px">,</span><span style="font-family:'楷体'; font-size:19px">但是如果是局部静态变量</span><span style="font-family:'楷体'; font-size:19px">,</span><span style="font-family:'楷体'; font-size:19px">则此静态变量只能在局部作用域内使用</span><span style="font-family:'楷体'; font-size:19px">,</span><span style="font-family:'楷体'; font-size:19px">超出范围不能使用</span><span style="font-family:'楷体'; font-size:19px">,</span><span style="font-family:'楷体'; font-size:19px">但是它确实还占用内存</span><span style="font-family:'楷体'; font-size:19px">,</span><span style="font-family:'楷体'; font-size:19px">还存在</span><span style="font-family:'楷体'; font-size:19px">.</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    B、</span><span style="font-family:'楷体'; font-size:19px">在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    C、</span><span style="font-family:'楷体'; font-size:19px">在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">8、typedef与define的区别</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    typedef是</span><span style="font-family:'楷体'; font-size:19px">C语言</span><span style="font-family:'楷体'; font-size:19px">中用来声明自定义数据类型，配合各种原有数据类型来达到简化编程的目的的类型定义关键字</span><span style="font-family:'楷体'; font-size:19px">。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    #define是预处理指令</span><span style="font-family:'楷体'; font-size:19px">，是宏定义。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">int a = 80;</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">typedef int * PINT;</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">const PINT p = &amp;a;//const修饰指针类型，限定指针变量p为只读</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">PINT const p = &amp;a;//const修饰指针类型，限定指针变量p为只读</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">9、k输出的值是多少</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> int main(int argc, char *argv[])</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> {<!-- --></span></p> 
<p><span style="font-family:'楷体'; font-size:19px">      char k = 0;</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">      int i;</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">      for(i = 0; i &lt; 127; i++)</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">          k += i &amp; 3;</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">      printf("k = %d\n", k);</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">      return 0;</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">  }</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    i：0 </span><span style="font-family:'楷体'; font-size:19px">1 </span><span style="font-family:'楷体'; font-size:19px">2 </span><span style="font-family:'楷体'; font-size:19px">3 </span><span style="font-family:'楷体'; font-size:19px">4 </span><span style="font-family:'楷体'; font-size:19px">5</span><span style="font-family:'楷体'; font-size:19px"> 6 </span><span style="font-family:'楷体'; font-size:19px">7</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">i &amp; 3：0</span><span style="font-family:'楷体'; font-size:19px"> 1 </span><span style="font-family:'楷体'; font-size:19px">2 </span><span style="font-family:'楷体'; font-size:19px">3</span><span style="font-family:'楷体'; font-size:19px"> 0</span><span style="font-family:'楷体'; font-size:19px"> 1 </span><span style="font-family:'楷体'; font-size:19px">2 </span><span style="font-family:'楷体'; font-size:19px">3</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px"> k：0</span><span style="font-family:'楷体'; font-size:19px"> 1 </span><span style="font-family:'楷体'; font-size:19px">2 </span><span style="font-family:'楷体'; font-size:19px">3 </span><span style="font-family:'楷体'; font-size:19px">6 </span><span style="font-family:'楷体'; font-size:19px">6</span><span style="font-family:'楷体'; font-size:19px"> 7</span><span style="font-family:'楷体'; font-size:19px"> 9</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px">i共计有32组0</span><span style="font-family:'楷体'; font-size:19px"> 1 </span><span style="font-family:'楷体'; font-size:19px">2</span><span style="font-family:'楷体'; font-size:19px"> 3和一组0 </span><span style="font-family:'楷体'; font-size:19px">1组成</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px">因此k=32 *（0 + 1 + 2 + 3）+（0 + 1）= 187</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px">由于k为char，所以k在127以后的数是-127，-126....，所以</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px">K = （187-127）+ （-127）= -67；</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    输出-67；</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">10、</span><span style="font-family:'楷体'; font-size:19px">嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。  </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">解答出如下：</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    int *ptr;  </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    ptr = (int *)0x67a9; </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    *ptr = 0xaa55;</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">嵌入式开发中常用应用：</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">#define rPCONA</span><span style="font-family:'楷体'; font-size:19px">(*(volatile unsigned *)0x1D20000)</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">#define rPDATA</span><span style="font-family:'楷体'; font-size:19px">(*(volatile unsigned *)0x1D20004)</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">11、下列代码输出结果是多少</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">char str1[] = "abc"; </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">char str2[] = "abc"; </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">const char str3[] = "abc"; </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">const char str4[] = "abc"; </span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">const char *str5 = "abc"; </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">const char *str6 = "abc"; </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">char *str7 = "abc"; </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">char *str8 = "abc"; </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">  </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl; </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl; </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl; </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl; </span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px">解答：</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    输出</span><span style="font-family:'楷体'; font-size:19px">结果是：0 0 1 1  </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    解析：</span><span style="font-family:'楷体'; font-size:19px">str1,str2,str3,str4是数组变量，有各自的内存空间；而str5,str6,str7,str8是指针，指向相同的常量区域。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"><br> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">12、简介##和#的作用</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    预处理器运算符##是连接符号，由两个井号组成，其功能是在带参数的宏定义中将两个子串(token)联接起来，从而形成一个新的子串。但它不可以是第一个或者最后一个子串。所谓的子串(token)就是指编译器能够识别的最小语法单元。如果替换文本中的参数与##相邻，则该参数将被实际参数替换，##与前后的空白将被删除，并对替换后的结果重新扫描。 形成一个新的标号，如果这样产生的记号无效，或者结果依赖于##运算顺序，则结果没有定义。</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">    #define</span><span style="font-family:'楷体'; font-size:19px">paste(front,back)</span><span style="font-family:'楷体'; font-size:19px">front##back</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">    宏调用paste(name,_xiaobai)的结果为name_xiaobai</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    #符是把传递过来的参数当成字符串进行替代</span></p> 
<p><span style="font-family:Consolas; font-size:18px">    #define</span><span style="font-family:Consolas; font-size:18px">dprint(expr)</span><span style="font-family:Consolas; font-size:18px">printf(#expr"=%d\n",expr)</span></p> 
<p style="margin-left:0; text-indent:0; text-align:left"><span style="font-family:Consolas; font-size:18px">    int</span><span style="font-family:'宋体'; font-size:16px"> </span><span style="font-family:Consolas; font-size:18px">a=20,b=10;</span></p> 
<p style="margin-left:0; text-indent:0; text-align:left"><span style="font-family:Consolas; font-size:18px">    dprint(a/b);</span></p> 
<p style="text-align:left"><span style="font-family:Consolas; font-size:18px">    <span style="font-family:'楷体','楷体_GB2312',SimKai; font-size:18px">打印出</span>：</span><span style="font-family:'宋体'; font-size:18px"> a/b=2</span></p> 
<p style="text-align:left"><span style="font-family:'宋体'; font-size:18px"><br> </span></p> 
<p><span style="font-family:Consolas; font-size:18px">13、</span><span style="font-family:'楷体'; font-size:19px">关键字volatile有什么含意?并给出三个不同的例子。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    定义为volatile的变量</span><span style="font-family:'楷体'; font-size:19px">表明</span><span style="font-family:'楷体'; font-size:19px">变量可能会被意想不到地改变，编译器就不会去假设这个变量的值。</span><span style="font-family:'楷体'; font-size:19px">准确</span><span style="font-family:'楷体'; font-size:19px">地说，优化器在用到volatile</span><span style="font-family:'楷体'; font-size:19px">修饰</span><span style="font-family:'楷体'; font-size:19px">的变量时必须每次都小心地重新读取变量的值，而不是使用保存在寄存器里的备份。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    使用</span><span style="font-family:'楷体'; font-size:19px">volatile变量的例子：</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    A、</span><span style="font-family:'楷体'; font-size:19px">并行设备的硬件寄存器（如：状态寄存器）</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px"> B、</span><span style="font-family:'楷体'; font-size:19px">一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    C、</span><span style="font-family:'楷体'; font-size:19px">多线程应用中被几个任务共享的变量</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px">深入理解：</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px">（</span><span style="font-family:'楷体'; font-size:19px">1</span><span style="font-family:'楷体'; font-size:19px">）</span><span style="font-family:'楷体'; font-size:19px">一个参数既可以是const还可以是volatile吗？解释为什么。</span></p> 
<p style="margin-left:28px; text-indent:28px"><span style="font-family:'楷体'; font-size:19px">是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">（</span><span style="font-family:'楷体'; font-size:19px">2</span><span style="font-family:'楷体'; font-size:19px">）</span><span style="font-family:'楷体'; font-size:19px">一个指针可以是volatile 吗？解释为什么。</span></p> 
<p style="margin-left:28px; text-indent:28px"><span style="font-family:'楷体'; font-size:19px">是的。尽管这并不很常见。一个例子是当一个中服务子程序修</span><span style="font-family:'楷体'; font-size:19px">改</span><span style="font-family:'楷体'; font-size:19px">一个指向一个buffer的指针时。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">（</span><span style="font-family:'楷体'; font-size:19px">3</span><span style="font-family:'楷体'; font-size:19px">）</span><span style="font-family:'楷体'; font-size:19px">下面的函数有什么错误：</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">int square(volatile int *ptr)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        return *ptr </span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px">* </span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px">*ptr;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    函数</span><span style="font-family:'楷体'; font-size:19px">目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">int square(volatile int </span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px">*ptr)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    int a,b;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    a = *ptr;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    b = *ptr;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    return a * b;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，</span><span style="font-family:'楷体'; font-size:19px">函数</span><span style="font-family:'楷体'; font-size:19px">可能返</span><span style="font-family:'楷体'; font-size:19px">回</span><span style="font-family:'楷体'; font-size:19px">不是你所期望的平方值</span><span style="font-family:'楷体'; font-size:19px">。</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'宋体'; font-size:16px">long square(volatile int *ptr)</span><span style="font-family:'宋体'; font-size:16px"><br> </span><span style="font-family:'宋体'; font-size:16px">{<!-- --></span><span style="font-family:'宋体'; font-size:16px"><br> </span><span style="font-family:'宋体'; font-size:16px">    int a;</span><span style="font-family:'宋体'; font-size:16px"><br> </span><span style="font-family:'宋体'; font-size:16px">    a = *ptr;</span><span style="font-family:'宋体'; font-size:16px"><br> </span><span style="font-family:'宋体'; font-size:16px">    return a * a;</span><span style="font-family:'宋体'; font-size:16px"><br> </span><span style="font-family:'宋体'; font-size:16px">}</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'宋体'; font-size:16px"><br> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">14、</span><span style="font-family:'楷体'; font-size:19px">嵌入式系统中断服务子程序(ISR)</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    中断是嵌入式系统中重要的组成部分，导致了很多编译开发商提供一种扩展—让标准C支持中断。</span><span style="font-family:'楷体'; font-size:19px">具体</span><span style="font-family:'楷体'; font-size:19px">代表是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">__interrupt double compute_area (double radius)</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">{<!-- --></span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    double area = PI * radius * radius;</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    printf("Area = %f", area);</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    return area;</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">}</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    中断程序的特点：<br> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    A、</span><span style="font-family:'楷体'; font-size:19px">ISR 不能返回一个值。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    B、</span><span style="font-family:'楷体'; font-size:19px">ISR 不能传递参数。 </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    C、</span><span style="font-family:'楷体'; font-size:19px">在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    D、</span><span style="font-family:'楷体'; font-size:19px">printf()经常有重入和性能上的问题。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"><br> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">15、</span><span style="font-family:'楷体'; font-size:19px">嵌入式C语言开发中的位操作</span></p> 
<p><strong><span style="font-family:'楷体'; font-weight:bold; font-size:19px">    A、</span><span style="font-family:'楷体'; font-weight:bold; font-size:19px">将寄存器指定位</span><span style="font-family:'楷体'; font-weight:bold; font-size:19px">（第</span><span style="font-family:'楷体'; font-weight:bold; font-size:19px">n位</span><span style="font-family:'楷体'; font-weight:bold; font-size:19px">）</span><span style="font-family:'楷体'; font-weight:bold; font-size:19px">置为1</span></strong></p> 
<p><span style="font-family:'楷体'; font-size:16px">    GPXX</span><span style="font-family:'宋体'; font-size:16px"> |= (1&lt;&lt;n)  </span></p> 
<p><span style="font-family:'楷体'; font-size:16px">    GPXX |= </span><span style="font-family:'宋体'; font-size:16px">(1&lt;&lt; 7) | (1&lt;&lt; 4 ) | (1&lt;&lt; 0)</span><span style="font-family:'楷体'; font-size:16px">；<span style="font-family:'宋体'">//</span><span style="font-family:'楷体'">第</span><span style="font-family:'宋体'">0</span><span style="font-family:'楷体'">、</span><span style="font-family:'宋体'">4</span><span style="font-family:'楷体'">、</span><span style="font-family:'宋体'">7</span><span style="font-family:'楷体'">位置</span><span style="font-family:'宋体'">1</span><span style="font-family:'楷体'">，其他保留</span></span></p> 
<p><strong><span style="font-family:'楷体'; font-weight:bold; font-size:19px">    B、</span><span style="font-family:'楷体'; font-weight:bold; font-size:19px">将寄存器指定位</span><span style="font-family:'楷体'; font-weight:bold; font-size:19px">（第</span><span style="font-family:'楷体'; font-weight:bold; font-size:19px">n位</span><span style="font-family:'楷体'; font-weight:bold; font-size:19px">）</span><span style="font-family:'楷体'; font-weight:bold; font-size:19px">置为0</span></strong></p> 
<p><span style="font-family:'楷体'; font-size:16px">    GPXX </span><span style="font-family:'楷体'; font-size:16px">&amp;= ~<span style="font-family:'楷体'">（</span><span style="font-family:'宋体'">1&lt;&lt;n )</span></span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    将寄存器的</span><span style="font-family:'楷体'; font-size:19px">第</span><span style="font-family:'楷体'; font-size:19px">n</span><span style="font-family:'楷体'; font-size:19px">位清</span><span style="font-family:'楷体'; font-size:19px">0</span><span style="font-family:'楷体'; font-size:19px">，而又不影响其它位的现有状态。</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">    GPXX </span><span style="font-family:'楷体'; font-size:16px">&amp;= ~<span style="font-family:'楷体'">（</span><span style="font-family:'宋体'">1&lt;&lt;</span></span><span style="font-family:'楷体'; font-size:16px">4</span><span style="font-family:'楷体'; font-size:16px"> )</span></p> 
<p><strong><span style="font-family:'楷体'; font-weight:bold; font-size:19px">    C、嵌入式开发位操作实例</span></strong></p> 
<p><span style="font-family:'楷体'; font-size:16px">   </span><span style="font-family:'楷体'; font-size:16px"> </span><span style="font-family:'楷体'; font-size:16px">unsigned int i = 0x00ff1234;</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">    //i |= (0x1&lt;&lt;13);//bit13<span style="font-family:'楷体'">置</span><span style="font-family:'宋体'">1</span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">    //i |= (0xF&lt;&lt;4);//bit4-bit7<span style="font-family:'楷体'">置</span><span style="font-family:'宋体'">1</span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">    //i &amp;= ~(1&lt;&lt;17);//<span style="font-family:'楷体'">清除</span><span style="font-family:'宋体'">bit17 </span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">    //i &amp;= ~(0x1f&lt;&lt;12);//<span style="font-family:'楷体'">清除</span><span style="font-family:'宋体'">bit12</span><span style="font-family:'楷体'">开始的</span><span style="font-family:'宋体'">5</span><span style="font-family:'楷体'">位 </span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">    </span></p> 
<p><span style="font-family:'楷体'; font-size:16px">    //<span style="font-family:'楷体'">取出</span><span style="font-family:'宋体'">bit3-bit8</span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">    //i &amp;= (0x3F&lt;&lt;3);//<span style="font-family:'楷体'">保留</span><span style="font-family:'宋体'">bit3-bit8</span><span style="font-family:'楷体'">，其他位清零</span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">    //i &gt;&gt;= 3;//<span style="font-family:'楷体'">右移</span><span style="font-family:'宋体'">3</span><span style="font-family:'楷体'">位</span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:16px">    //<span style="font-family:'楷体'">给寄存器的</span><span style="font-family:'宋体'">bit7-bit17</span><span style="font-family:'楷体'">赋值</span><span style="font-family:'宋体'">937</span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">    //i &amp;= ~(0x7FF&lt;&lt;7);//bit7-bit17<span style="font-family:'楷体'">清零</span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">    //i |= (937&lt;&lt;7);//bit7-bit17<span style="font-family:'楷体'">赋值</span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:16px">    //<span style="font-family:'楷体'">将寄存器</span><span style="font-family:'宋体'">bit7-bit17</span><span style="font-family:'楷体'">的值加</span><span style="font-family:'宋体'">17</span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">   </span><span style="font-family:'楷体'; font-size:16px">//</span><span style="font-family:'楷体'; font-size:16px"> unsigned int a = i;//<span style="font-family:'楷体'">将</span><span style="font-family:'宋体'">a</span><span style="font-family:'楷体'">作为</span><span style="font-family:'宋体'">i</span><span style="font-family:'楷体'">的副本，避免</span><span style="font-family:'宋体'">i</span><span style="font-family:'楷体'">的其他位被修改</span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">   </span><span style="font-family:'楷体'; font-size:16px">//</span><span style="font-family:'楷体'; font-size:16px"> a &amp;= (0x7FF&lt;&lt;7);//<span style="font-family:'楷体'">取出</span><span style="font-family:'宋体'">bit7-bit17</span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">   </span><span style="font-family:'楷体'; font-size:16px">//</span><span style="font-family:'楷体'; font-size:16px">a &gt;&gt;= 7;//</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">   </span><span style="font-family:'楷体'; font-size:16px">//</span><span style="font-family:'楷体'; font-size:16px"> a += 17;//<span style="font-family:'楷体'">加</span><span style="font-family:'宋体'">17</span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">   </span><span style="font-family:'楷体'; font-size:16px">//</span><span style="font-family:'楷体'; font-size:16px"> i &amp;= ~(0x7FF&lt;&lt;7);//<span style="font-family:'楷体'">将</span><span style="font-family:'宋体'">i</span><span style="font-family:'楷体'">的</span><span style="font-family:'宋体'">bit7-bit17</span><span style="font-family:'楷体'">清零</span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">   </span><span style="font-family:'楷体'; font-size:16px">//</span><span style="font-family:'楷体'; font-size:16px"> i |= (a&lt;&lt;7);//<span style="font-family:'楷体'">将</span><span style="font-family:'宋体'">+17</span><span style="font-family:'楷体'">后的数写入</span><span style="font-family:'宋体'">bit7-bit17</span><span style="font-family:'楷体'">，其他位不变</span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:16px">    //<span style="font-family:'楷体'">给一个寄存器的</span><span style="font-family:'宋体'">bit7-bit17</span><span style="font-family:'楷体'">赋值</span><span style="font-family:'宋体'">937</span><span style="font-family:'楷体'">，同时给</span><span style="font-family:'宋体'">bit21-bit25</span><span style="font-family:'楷体'">赋值</span><span style="font-family:'宋体'">17</span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">    i &amp;= ~</span><span style="font-family:'楷体'; font-size:16px">(</span><span style="font-family:'楷体'; font-size:16px">(0x7FF&lt;&lt;7)</span><span style="font-family:'楷体'; font-size:16px"> | (0x1F&lt;&lt;21))</span><span style="font-family:'楷体'; font-size:16px">;</span><span style="font-family:'楷体'; font-size:16px">//bit7-bit17<span style="font-family:'楷体'">、</span><span style="font-family:'宋体'">bit21-bit25</span><span style="font-family:'楷体'">清零</span></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">    i |= </span><span style="font-family:'楷体'; font-size:16px">(</span><span style="font-family:'楷体'; font-size:16px">(937&lt;&lt;7)</span><span style="font-family:'楷体'; font-size:16px"> | (17&lt;&lt;21))</span><span style="font-family:'楷体'; font-size:16px">;</span><span style="font-family:'楷体'; font-size:16px">//bit7-bit17<span style="font-family:'楷体'">、</span><span style="font-family:'宋体'">bit21-bit25</span><span style="font-family:'楷体'">赋值</span></span></p> 
<p><strong><span style="font-family:'楷体'; font-weight:bold; font-size:19px">    D、位操作的宏定义</span></strong></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:16px">//<span style="font-family:'楷体'">用宏定义将</span><span style="font-family:'宋体'">32</span><span style="font-family:'楷体'">位数</span><span style="font-family:'宋体'">x</span><span style="font-family:'楷体'">的第</span><span style="font-family:'宋体'">n</span><span style="font-family:'楷体'">位</span><span style="font-family:'宋体'">(bit0</span><span style="font-family:'楷体'">为第</span><span style="font-family:'宋体'">1</span><span style="font-family:'楷体'">位</span><span style="font-family:'宋体'">)</span><span style="font-family:'楷体'">置位</span></span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:16px">#define SET_BIT_N(x,n) (x | (1U&lt;&lt;(n-1)))</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:16px">//<span style="font-family:'楷体'">用宏定义将</span><span style="font-family:'宋体'">32</span><span style="font-family:'楷体'">位数</span><span style="font-family:'宋体'">x</span><span style="font-family:'楷体'">的第</span><span style="font-family:'宋体'">n</span><span style="font-family:'楷体'">位</span><span style="font-family:'宋体'">(bit0</span><span style="font-family:'楷体'">为第</span><span style="font-family:'宋体'">1</span><span style="font-family:'楷体'">位</span><span style="font-family:'宋体'">)</span><span style="font-family:'楷体'">清零</span></span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:16px">#define CLEAR_BIT_N(x,n) (x &amp; (~(1U&lt;&lt;(n-1))))</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:16px">//<span style="font-family:'楷体'">用宏定义将</span><span style="font-family:'宋体'">32</span><span style="font-family:'楷体'">位数</span><span style="font-family:'宋体'">x</span><span style="font-family:'楷体'">的第</span><span style="font-family:'宋体'">n</span><span style="font-family:'楷体'">位到第</span><span style="font-family:'宋体'">m</span><span style="font-family:'楷体'">位</span><span style="font-family:'宋体'">(bit0</span><span style="font-family:'楷体'">为第</span><span style="font-family:'宋体'">1</span><span style="font-family:'楷体'">位</span><span style="font-family:'宋体'">)</span><span style="font-family:'楷体'">置位</span></span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:16px">#define SET_BITS_N_M(x,n,m) (x | (((~0U)&gt;&gt;(32-(m-n+1)))&lt;&lt;(n-1)))</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:16px">//<span style="font-family:'楷体'">用宏定义将</span><span style="font-family:'宋体'">32</span><span style="font-family:'楷体'">位数</span><span style="font-family:'宋体'">x</span><span style="font-family:'楷体'">的第</span><span style="font-family:'宋体'">n</span><span style="font-family:'楷体'">位到第</span><span style="font-family:'宋体'">m</span><span style="font-family:'楷体'">位</span><span style="font-family:'宋体'">(bit0</span><span style="font-family:'楷体'">为第</span><span style="font-family:'宋体'">1</span><span style="font-family:'楷体'">位</span><span style="font-family:'宋体'">)</span><span style="font-family:'楷体'">清零</span></span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:16px">#define CLEAR_BITS_N_M(x,n,m) (x &amp; (~(((~0U)&gt;&gt;(32-(m-n+1)))&lt;&lt;(n-1))))</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:16px">//<span style="font-family:'楷体'">用宏定义获取</span><span style="font-family:'宋体'">32</span><span style="font-family:'楷体'">位数</span><span style="font-family:'宋体'">x</span><span style="font-family:'楷体'">的第</span><span style="font-family:'宋体'">n</span><span style="font-family:'楷体'">位到第</span><span style="font-family:'宋体'">m</span><span style="font-family:'楷体'">位</span><span style="font-family:'宋体'">(bit0</span><span style="font-family:'楷体'">为第</span><span style="font-family:'宋体'">1</span><span style="font-family:'楷体'">位</span><span style="font-family:'宋体'">)</span><span style="font-family:'楷体'">的部分</span></span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:16px">#define GET_BITS_N_M(x,n,m) ((x &amp; ~(~(0U)&lt;&lt;(m-n+1))&lt;&lt;(n-1))&gt;&gt;(n-1))</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:16px"><br> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">16、大小端的介绍</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">     </span><span style="font-family:'楷体'; font-size:19px">Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    数字0x12 34 56 78在内存中的表示形式为：</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px">大端模式：</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">低地址 -----------------&gt; 高地址</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">0x12  |  0x34  |  0x56  |  0x78</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">小端模式：</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">低地址 ------------------&gt; 高地址</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">0x78  |  0x56  |  0x34  |  0x12</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">Big-Endian: 低地址存放高位，如下：</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">高地址</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        ---------------</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        buf[3] (0x78) -- 低位</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        buf[2] (0x56)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        buf[1] (0x34)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        buf[0] (0x12) -- 高位</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        ---------------</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        低地址</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">Little-Endian: 低地址存放低位，如下：</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">高地址</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        ---------------</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        buf[3] (0x12) -- 高位</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        buf[2] (0x34)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        buf[1] (0x56)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        buf[0] (0x78) -- 低位</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        --------------</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">低地址</span></p> 
<p style="margin-left:43px"><span style="font-family:'楷体'; font-size:19px">C语言实现测试大小端：</span></p> 
<p><span style="font-family:'楷体'; font-size:16px"> #include &lt;stdio.h&gt;</span></p> 
<p><span style="font-family:'楷体'; font-size:16px"> int main(int argc, char **argv)</span></p> 
<p><span style="font-family:'楷体'; font-size:16px"> {<!-- --></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">      union</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">      {<!-- --></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">          int a;</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">          char b;</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">      }c;</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">      c.a = 1;</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">      if(c.b == 1)</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">      {<!-- --></span></p> 
<p><span style="font-family:'楷体'; font-size:16px">          printf("little\n");</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">      }</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">      else</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">          printf("big\n");</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">      return 0;</span></p> 
<p><span style="font-family:'楷体'; font-size:16px">  }</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    常见CPU的大小端：</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px"> Big Endian : PowerPC、IBM、Sun</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    Little Endian : x86、DEC</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    常见文件的字节序</span><span style="font-family:'楷体'; font-size:19px">：</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px"> Adobe PS – Big Endian</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    BMP – Little Endian</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    DXF(AutoCAD) – Variable</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    GIF – Little Endian</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    JPEG – Big Endian</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    MacPaint – Big Endian</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    RTF – Little Endian</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px"><br> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    Java和所有的网络通讯协议都是使用Big-Endian的编码。</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px">大小端的转换：</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">16位</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">#define BigtoLittle16(A)   (( ((uint16)(A) &amp; 0xff00) &gt;&gt; 8)    | \  </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">                                       (( (uint16)(A) &amp; 0x00ff) &lt;&lt; 8))  </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">32位</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">#define BigtoLittle32(A)   ((( (uint32)(A) &amp; 0xff000000) &gt;&gt; 24) | \  </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">                                       (( (uint32)(A) &amp; 0x00ff0000) &gt;&gt; 8)   | \  </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">                                       (( (uint32)(A) &amp; 0x0000ff00) &lt;&lt; 8)   | \  </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">                                       (( (uint32)(A) &amp; 0x000000ff) &lt;&lt; 24))  </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    从软件的角度上，不同端模式的处理器进行数据传递时必须要考虑端模式的不同。如进行网络数据传递时，必须要考虑端模式的转换。在Socket接口编程中，以下几个函数用于大小端字节序的转换。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    ntohs(n)     //16位数据类型网络字节顺序到主机字节顺序的转换  </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    htons(n)     //16位数据类型主机字节顺序到网络字节顺序的转换  </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    ntohl(n)      //32位数据类型网络字节顺序到主机字节顺序的转换  </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    htonl(n)      //32位数据类型主机字节顺序到网络字节顺序的转换 </span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">17、</span><span style="font-family:'楷体'; font-size:19px">引用和指针有什么区别？</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px">A、</span><span style="font-family:'楷体'; font-size:19px">应用必须初始化，指针不必；</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px">B、</span><span style="font-family:'楷体'; font-size:19px">引用处画化后不能改变，指针可以被改变；</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px">C、</span><span style="font-family:'楷体'; font-size:19px">不存在指向空值的引用，但存在指向空值的指针；</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px"><br> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">18、</span><span style="font-family:'楷体'; font-size:19px">写出</span><span style="font-family:'楷体'; font-size:19px">float</span><span style="font-family:'楷体'; font-size:19px">，</span><span style="font-family:'楷体'; font-size:19px">bool</span><span style="font-family:'楷体'; font-size:19px">，</span><span style="font-family:'楷体'; font-size:19px">int</span><span style="font-family:'楷体'; font-size:19px">类型与零的比较，假设变量为</span><span style="font-family:'楷体'; font-size:19px">X</span><span style="font-family:'楷体'; font-size:19px">：</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">       Int </span><span style="font-family:'楷体'; font-size:19px">：</span><span style="font-family:'楷体'; font-size:19px">    if</span><span style="font-family:'楷体'; font-size:19px">（</span><span style="font-family:'楷体'; font-size:19px">x==0</span><span style="font-family:'楷体'; font-size:19px">）</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">       Float</span><span style="font-family:'楷体'; font-size:19px">：</span><span style="font-family:'楷体'; font-size:19px">    if</span><span style="font-family:'楷体'; font-size:19px">（</span><span style="font-family:'楷体'; font-size:19px">x</span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px">&gt;</span><span style="font-family:'楷体'; font-size:19px"> -</span><span style="font-family:'楷体'; font-size:19px">0.0000001</span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px">&amp;&amp;</span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px">x</span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px">&lt;</span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px">0.0000001</span><span style="font-family:'楷体'; font-size:19px">）</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">       Bool:      if(x==false)</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"><br> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">19、多维数组的定义</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    在数组定义int a[2][2]={<!-- -->{3},{2,3}}；则a[0][1]的值为0。</span><span style="font-family:'楷体'; font-size:19px">（对）</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">#include &lt;stdio.h&gt;</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">intmain(int argc,char * argv[])</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">{<!-- --></span></p> 
<p><span style="font-family:'楷体'; font-size:19px">int a [3][2]={(0,1),(2,3),(4,5)};</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">int *p;</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">p=a [0];</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">printf("%d",p[0]);</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">}</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    问打印出来结果是多少？</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    答案：1</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    分析：花括号里嵌套的是小括号而不是花括号！这里是花括号里面嵌套了逗号表达式！其实这个赋值就相当于int a [3][2]={ 1, 3, 5};</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"><br> </span></p> 
<p><span style="font-family:'宋体'; font-size:18px">20、</span><span style="font-family:'楷体'; font-size:19px">评价下面的代码片断</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    unsigned int zero = 0; </span> <span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    unsigned int compzero = 0xFFFF; </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下： </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    unsigned int compzero = ~0; <br> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px"></span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">1、</span><span style="font-family:'楷体'; font-size:19px">.h头文件中的ifndef/define/endif 的作用？</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    答：防止该头文件被重复引用。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">2、</span><span style="font-family:'楷体'; font-size:19px">#include 与 #include “file.h”的区别？</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    答：前者是从Standard Library的路径寻找和引用file.h，而后者是从当前工作路径搜寻并引用file.h。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">3、</span><span style="font-family:'楷体'; font-size:19px">描述实时系统的基本特性</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    答 ：在特定时间内完成特定的任务，实时性与可靠性。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">4、</span><span style="font-family:'楷体'; font-size:19px">全局变量和局部变量在内存中是否有区别？如果有，是什么区别？</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    答 ：全局变量储存在静态数据区，局部变量在堆栈中。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">5、</span><span style="font-family:'楷体'; font-size:19px">堆栈溢出一般是由什么原因导致的？</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    答 ：</span><span style="font-family:'楷体'; font-size:19px">    A、</span><span style="font-family:'楷体'; font-size:19px">没有回收垃圾资源</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">             B、</span><span style="font-family:'楷体'; font-size:19px">层次太深的递归调用</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">6、</span><span style="font-family:'楷体'; font-size:19px">不能做switch()的参数类型</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    答 ：switch的参数不能为实型。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">7、</span><span style="font-family:'楷体'; font-size:19px">局部变量能否和全局变量重名？</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    答：能，局部会屏蔽全局。要用全局变量，需要使用”::”</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内</span><span style="font-family:'楷体'; font-size:19px">。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">8、</span><span style="font-family:'楷体'; font-size:19px">如何引用一个已经定义过的全局变量？</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    答 </span><span style="font-family:'楷体'; font-size:19px">：</span><span style="font-family:'楷体'; font-size:19px">可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">9、</span><span style="font-family:'楷体'; font-size:19px">全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    答 </span><span style="font-family:'楷体'; font-size:19px">：</span><span style="font-family:'楷体'; font-size:19px">可以，在不同的C文件中以static形式来声明同名全局变量。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">10、</span><span style="font-family:'楷体'; font-size:19px">do……while和while……有什么区别？</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    答 </span><span style="font-family:'楷体'; font-size:19px">：</span><span style="font-family:'楷体'; font-size:19px">前一个循环一遍再判断，后一个判断以后再循环。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">11、</span><span style="font-family:'楷体'; font-size:19px">程序的内存分配</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    答：一个由</span><span style="font-family:'楷体'; font-size:19px">C</span><span style="font-family:'楷体'; font-size:19px">/C++编译的程序占用的内存分为以下几个部分</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    A、</span><span style="font-family:'楷体'; font-size:19px">栈区（stack）—由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    B、</span><span style="font-family:'楷体'; font-size:19px">堆区（heap）—一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    C、</span><span style="font-family:'楷体'; font-size:19px">全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    D、</span><span style="font-family:'楷体'; font-size:19px">文字常量区—常量字符串就是放在这里的。程序结束后由系统释放。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    E、</span><span style="font-family:'楷体'; font-size:19px">程序代码区—存放函数体的二进制代码</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">12、</span><span style="font-family:'楷体'; font-size:19px">解释堆和栈的区别</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    答：堆（heap）和栈(stack)的区别</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px"> A、</span><span style="font-family:'楷体'; font-size:19px">申请方式</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    stack:由系统自动分配。例如，声明在函数中一个局部变量int b;系统自动在栈中为b开辟空间</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    heap:需要程序员自己申请，并指明大小，</span></p> 
<p style="text-indent:28px"><span style="font-family:'楷体'; font-size:19px">在c中malloc函数</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    如p1=(char*)malloc(10);</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    但是注意p1本身是在栈中的。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">  B、</span><span style="font-family:'楷体'; font-size:19px">申请后系统的响应</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">  C、</span><span style="font-family:'楷体'; font-size:19px">申请大小的限制</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域</span><span style="font-family:'楷体'; font-size:19px">，即</span><span style="font-family:'楷体'; font-size:19px">栈顶的地址和栈的最大容量是系统预先规定好的，</span><span style="font-family:'楷体'; font-size:19px">linux系统可以使用</span><span style="font-family:'楷体'; font-size:19px">ulimit -a</span><span style="font-family:'楷体'; font-size:19px">命令查看当前系统的栈的大小</span><span style="font-family:'楷体'; font-size:19px">，</span><span style="font-family:'楷体'; font-size:19px">默认为</span><span style="font-family:'楷体'; font-size:19px">10M（64位系统），</span><span style="font-family:'楷体'; font-size:19px">如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">  D、</span><span style="font-family:'楷体'; font-size:19px">申请效率的比较：</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    栈:由系统自动分配，速度较快。但程序员是无法控制的。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    堆:是由</span><span style="font-family:'楷体'; font-size:19px">malloc</span><span style="font-family:'楷体'; font-size:19px">分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">  E、</span><span style="font-family:'楷体'; font-size:19px">堆和栈中的存储内容</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">  F、</span><span style="font-family:'楷体'; font-size:19px">存取效率的比较</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    char s1[]=”aaaaaaaaaaaaaaa”;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    char *s2=”bbbbbbbbbbbbbbbbb”;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    aaaaaaaaaaa是在运行时刻赋值的；</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    而bbbbbbbbbbb是在编译时就确定的；</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    比如：</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">#include</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">void</span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px">main()</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">char a=1;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">char c[]=”1234567890″;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">char *p=”1234567890″;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">a = c[1];</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">a = p[1];</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">return;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">对应的汇编代码</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">10:a=c[1];</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">004010678A4DF1</span><span style="font-family:'楷体'; font-size:19px">mov</span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px">cl,byteptr[ebp-0Fh]</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">0040106A884DFC</span><span style="font-family:'楷体'; font-size:19px">mov</span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px">byteptr[ebp-4],cl</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">11:a=p[1];</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">0040106D8B55EC</span><span style="font-family:'楷体'; font-size:19px">mov</span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px">edx,dwordptr[ebp-14h]</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">004010708A4201</span><span style="font-family:'楷体'; font-size:19px">mov</span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px">al,byteptr[edx+1]</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">004010738845FC</span><span style="font-family:'楷体'; font-size:19px">mov</span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px">byteptr[ebp-4],al</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">13</span><span style="font-family:'楷体'; font-size:19px">、什么是预编译,何时需要预编译?</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    答：预编译又称为预处理,是做些代码文本的替换工作。处理#开头的指令,比如拷贝#include包含的文件代码，#define宏定义的替换,条件编译等，就是为编译做的预备工作的阶段，主要处理#开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">GCC</span><span style="font-family:'楷体'; font-size:19px">编译系统在对程序进行通常的编译之前，先进行预处理。</span><span style="font-family:'楷体'; font-size:19px">GCC</span><span style="font-family:'楷体'; font-size:19px">提供的预处理功能主要有以下三种：宏定义</span><span style="font-family:'楷体'; font-size:19px">、</span><span style="font-family:'楷体'; font-size:19px">文件包含</span><span style="font-family:'楷体'; font-size:19px">、</span><span style="font-family:'楷体'; font-size:19px">条件编译</span></p> 
<p style="text-indent:28px"><span style="font-family:'楷体'; font-size:19px">使用场合如下：</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    A、</span><span style="font-family:'楷体'; font-size:19px">总是使用不经常改动的大型代码体。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    B、</span><span style="font-family:'楷体'; font-size:19px">程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">14</span><span style="font-family:'楷体'; font-size:19px">、描述内存分配方式以及它们的区别?</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    答：</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">    </span><span style="font-family:'楷体'; font-size:19px">A、</span><span style="font-family:'楷体'; font-size:19px">从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    B、</span><span style="font-family:'楷体'; font-size:19px">在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    C、</span><span style="font-family:'楷体'; font-size:19px">从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">15</span><span style="font-family:'楷体'; font-size:19px">、简述数组与指针的区别？</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    答：数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    A、</span><span style="font-family:'楷体'; font-size:19px">修改内容上的差别</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">char a[] = “hello”;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">a[0] = ‘X’;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">char *p = “world”; // 注意p 指向常量字符串</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">p[0] = ‘X’; // 编译器不能发现该错误，运行时</span><span style="font-family:'楷体'; font-size:19px">出现段</span><span style="font-family:'楷体'; font-size:19px">错误</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    B、</span><span style="font-family:'楷体'; font-size:19px">用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">char a[] = “hello world”;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">char *p = a;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">计算数组和指针的内存容量</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">void Func(char a[100])</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是100 字节</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">16</span><span style="font-family:'楷体'; font-size:19px">、论述含参数的宏与函数的优缺点</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">答： </span></p> 
<p style="text-indent:121px"><span style="font-family:'楷体'; font-size:19px">带参宏</span><span style="font-family:'楷体'; font-size:19px">                 函数</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">处理时间     </span><span style="font-family:'楷体'; font-size:19px">编译时                 </span><span style="font-family:'楷体'; font-size:19px">程序运行时</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">参数类型 </span><span style="font-family:'楷体'; font-size:19px">    没有参数类型问题     </span><span style="font-family:'楷体'; font-size:19px">  定义实参、形参类型</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">处理过程 </span><span style="font-family:'楷体'; font-size:19px">    不分配内存 </span><span style="font-family:'楷体'; font-size:19px">            分配内存</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">程序长度 </span><span style="font-family:'楷体'; font-size:19px">    变长 </span><span style="font-family:'楷体'; font-size:19px">                  不变</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">运行速度 </span><span style="font-family:'楷体'; font-size:19px">    不占运行时间 </span><span style="font-family:'楷体'; font-size:19px">          调用和返回占用时间</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">17</span><span style="font-family:'楷体'; font-size:19px">、写一个“标准”宏</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">答：交换两个参数值的宏定义为：. #define SWAP(a,b)\</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">(a)=(a)+(b);\</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">(b)=(a)-(b);\</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">(a)=(a)-(b);</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">输入两个参数，输出较小的一个：</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">#define MIN(A,B) ((A) &lt; (B))? (A) : (B))</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">表明1年中有多少秒（忽略闰年问题）：</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">#define SECONDS_PER_YEAR (60</span><span style="font-family:'楷体'; font-size:19px">UL</span><span style="font-family:'楷体'; font-size:19px">* 60 * 24 * 365)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">已知一个数组table，用一个宏定义，求出数据的元素个数</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">#define NTBL (sizeof(table)/sizeof(table[0]))</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">18、</span><span style="font-family:'楷体'; font-size:19px">A.c 和B.c两个c文件中使用了两个相同名字的static变量,编译的时候会不会有问题?这两个static变量会保存到哪里（栈还是堆或者其他的）?</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    答：</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">    static的全局变量，表明变量仅在本模块中有意义，不会影响其他模块。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    存放</span><span style="font-family:'楷体'; font-size:19px">在</span><span style="font-family:'楷体'; font-size:19px">静态</span><span style="font-family:'楷体'; font-size:19px">数据区，但是编译器对他们的命名是不同的。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    如果要使变量在其他模块也有意义的话，需要使用extern关键字。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">19、</span><span style="font-family:'楷体'; font-size:19px">下面的代码输出是什么，为什么？</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">void foo(void)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">unsigned int a = 6;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">int b = -20;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">(a+b &gt; 6) ? puts(“&gt; 6″) : puts(“&lt;= 6");</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">20、</span><span style="font-family:'楷体'; font-size:19px">交换两个变量的值，不使用第三个变量。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    即a=3,b=5,交换之后a=5,b=3;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">有两种解法, 一种用算术算法, 一种用^(异或)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">a = a + b;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">b = a - b;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">a = a - b;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">or</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">a = a^b;// 只能对int,char..</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">b = a^b;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">a = a^b;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">or</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">a ^= b ^= a;</span></p> 
<br> 
<p><span style="font-family:'楷体'; font-size:19px"></span></p> 
<p><span style="font-family:'楷体'; font-size:19px">1、</span><span style="font-family:'楷体'; font-size:19px">下面的程序会出现什么结果</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">#include </span><span style="font-family:'楷体'; font-size:19px">&lt;stdio.h&gt;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">#include </span><span style="font-family:'楷体'; font-size:19px">&lt;stdlib.h&gt;</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">#include &lt;string.h&gt;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">void getmemory(char *p)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    p=(char *) malloc(100);</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    strcpy(p,”hello world”);</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">int main( )</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    char *str=NULL;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    getmemory(str);</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    printf(“%s/n”,str);</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    free(str);</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    return 0;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">程序崩溃，getmemory中的malloc 不能返回动态内存， free（）对str操作很危险</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">2</span><span style="font-family:'楷体'; font-size:19px">、(void *)ptr 和 (*(void**))ptr的结果是否相同？</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">答：ptr为同一个指针</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">(void *)ptr 和 (*(void**))ptr值是相同的</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">3、</span><span style="font-family:'楷体'; font-size:19px">对绝对地址0×100000赋值且想让程序跳转到绝对地址是0×100000去执行</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">(unsigned int*)0×100000 = 1234;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">首先要将0×100000强制转换成函数指针,即:</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">(void (*)())0×100000</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">然后再调用它:</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">*((void (*)())0×100000)();</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">用typedef可以看得更直观些:</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">typedef void(*)() voidFuncPtr;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">*((voidFuncPtr)0×100000)();</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">4、</span><span style="font-family:'楷体'; font-size:19px">下面的函数实现在一个数上加一个数，有什么错误？请改正。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">int add_n ( int n )</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    static int i = 100;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    i += n;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    return i;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    当你第二次调用时得不到正确的结果，难道你写个函数就是为了调用一次？问题就出在 static上</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">5、</span><span style="font-family:'楷体'; font-size:19px">下面这个程序执行后会有什么错误或者效果:</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">#define MAX 255</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">int main()</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    unsigned char A[MAX],i;//i被定义为unsigned char</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    for (i=0;i&lt;=MAX;i++)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    A[i]=i;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">解答：死循环加数组越界访问（C/C++不进行数组越界检查）</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">MAX=255</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">数组A的下标范围为:0..MAX-1,这是其一</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">其二</span><span style="font-family:'楷体'; font-size:19px">、</span><span style="font-family:'楷体'; font-size:19px">当i循环到255时,循环内执行:</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">A[255]=255;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">这句本身没有问题</span><span style="font-family:'楷体'; font-size:19px">，</span><span style="font-family:'楷体'; font-size:19px">但是返回for (i=0;i&lt;=MAX;i++)语句时,</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">由于unsigned char的取值范围在(0..255),i++以后i又为0了..无限循环下去.</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">6、</span><span style="font-family:'楷体'; font-size:19px">请问一下程序将输出什么结果？</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">char *RetMenory(void)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    char p[] = “hellow world”;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    return p;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">void Test(void)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    char *str = NULL;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    str = RetMemory();</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    printf(str);</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    RetMenory执行完毕，p资源被回收，指向未知地址。返回地址，str的内容应是不可预测的, 打印的应该是str的地址</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">7、</span><span style="font-family:'楷体'; font-size:19px">对下面程序进行分析</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">void test2()</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    char string[10], str1[10];</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    int i;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    for(i=0; i&lt;10; i++)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    {<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        str1[i] = 'a';</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    }</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    strcpy( string, str1 );</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">解答：</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">字符数组str1不能在数组内结束</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">strcpy(string, str1)调用使得从str1内存起复制到string内存起所复制的字节数具有不确定性</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">指出库函数strcpy工作方式</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">str1不能在数组内结束:因为str1的存储为：{a,a,a,a,a,a,a,a,a,a},没有'\0'(字符串结束符)，所以不能结束</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">strcpy( char *s1,char *s2)他的工作原理是，扫描s2指向的内存，逐个字符付到s1所指向的内存，直到碰到'\0',因为str1结尾没有'\0'，所以具有不确定性，不知道他后面还会付什么东东。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">正确应如下</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">void test2()</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    char string[10], str1[10];</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    int i;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    for(i=0; i&lt;9; i++)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    {<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        str1[i] = 'a'+i; //把abcdefghi赋值给字符数组</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    }</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    str[i]='\0';//加上结束符</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    strcpy( string, str1 );</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">8、</span><span style="font-family:'楷体'; font-size:19px">分析</span><span style="font-family:'楷体'; font-size:19px">下列代码输出的值</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">int arr[] = {6,7,8,9,10};</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">int *ptr = arr;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">*(ptr++)+=123;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">printf(“ %d %d ”, *ptr, *(++ptr));</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">输出：8 8</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">过程：对于*(ptr++)+=123;先做加法6+123，然后++，指针指向7；对于printf(“ %d %d ”, *ptr, *(++ptr));从后往前执行，指针先++，指向8，然后输出8，紧接着再输出8</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">9、</span><span style="font-family:'楷体'; font-size:19px">分析下面的代码：</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">char *a = "hello";</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">char *b = "hello";</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">if(a= =b)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    printf("YES");</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">else</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    printf("NO");</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">输出</span><span style="font-family:'楷体'; font-size:19px">YES</span></p> 
<p style="text-indent:28px"><span style="font-family:'楷体'; font-size:19px">"hello"是一个常量字符串</span><span style="font-family:'楷体'; font-size:19px">，</span><span style="font-family:'楷体'; font-size:19px">位于静态存储区，在程序生命期内恒定不变</span><span style="font-family:'楷体'; font-size:19px">，</span><span style="font-family:'楷体'; font-size:19px">a和b同时指向同一个hello的。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">10、</span><span style="font-family:'楷体'; font-size:19px">已知strcpy函数的原型是：</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">char * strcpy(char * strDest,const char * strSrc);</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">不调用库函数，实现strcpy函数。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">解释为什么要返回char *。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">解答</span><span style="font-family:'楷体'; font-size:19px">：</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">strcpy实现代码</span><span style="font-family:'楷体'; font-size:19px">：</span></p> 
<p style="text-align:justify"><span style="font-family:'楷体'; font-size:19px">char * strcpy( char *strDest, const char *strSrc ) </span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">　assert( (strDest != NULL) &amp;&amp; (strSrc != NULL) );</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">　char *address = strDest; </span> <span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">　while( (*strDest++ = * strSrc++) != '’ ); </span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">　　return address;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span><span style="font-family:'楷体'; font-size:19px"></span><span style="font-family:'楷体'; font-size:19px"></span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">11、</span><span style="font-family:'楷体'; font-size:19px">判断一个字符串是不是回文</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">int IsReverseStr(char *aStr)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    int i,j;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    int found=1;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    if(aStr==NULL)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        return -1;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    j=strlen(aStr);</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    for(i=0;i</span><span style="font-family:'楷体'; font-size:19px">&lt;j; i++)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    if(*(aStr+i)!=*(aStr+j-i-1))</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    {<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        found=0;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        break;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    }</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    return found;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">12、</span><span style="font-family:'楷体'; font-size:19px">写一个函数比较两个字符串str1和str2的大小，若相等返回0，若str1大于</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">str2返回1，若str1小于str2返回－1</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">int strcmp ( const char * src,const char * dst)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    int ret = 0 ;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    while( ! (ret = *(unsigned char *)src – *(unsigned char *)dst) &amp;&amp; *dst)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    {<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        ++src;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        ++dst;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    }</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    if ( ret &lt; 0 )</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        ret = -1 ;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    else if ( ret &gt; 0 )</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        ret = 1 ;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    return( ret );</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">}</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">13、</span><span style="font-family:'楷体'; font-size:19px">给定字符串A和B,输出A和B中的最大公共子串。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">比如A="aocdfe" B="pmcdfa" 则输出"cdf"</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">*/</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">//Author: azhen</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">#include</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">#include</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">#include</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">char *commanstring(char shortstring[], char longstring[])</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    int i, j;</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px"> char *substring=malloc(256);</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px"> if(strstr(longstring, shortstring)!=NULL) </span></p> 
<p style="margin-left:28px; text-indent:28px"><span style="font-family:'楷体'; font-size:19px">return shortstring; </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    for(i=strlen(shortstring)-1;i&gt;0; i–) //否则，开始循环计算</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    {<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        for(j=0; j&lt;=strlen(shortstring)-i; j++)</span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px"> {<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">            memcpy(substring, &amp;shortstring[j], i);</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">            substring[i]='\0';</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">            if(strstr(longstring, substring)!=NULL)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">            return substring;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        }</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    }</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    return NULL;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">int </span><span style="font-family:'楷体'; font-size:19px">main()</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    char *str1=malloc(256);</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    char *str2=malloc(256);</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    char *comman=NULL;</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px"> gets(str1);</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    gets(str2);</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px"> if(strlen(str1)&gt;strlen(str2)) //将短的字符串放前面</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        comman=commanstring(str2, str1);</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    else</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        comman=commanstring(str1, str2);</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    printf(“the longest comman string is: %s\n”, comman);</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">14</span><span style="font-family:'楷体'; font-size:19px">、编写一个 C 函数，该函数在一个字符串中找到可能的最长的子字符串，且该字符串是由同一字符组成的。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">char * search(char *cpSource, char ch)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    char *cpTemp=NULL, *cpDest=NULL;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    int iTemp, iCount=0;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    while(*cpSource)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    {<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        if(*cpSource == ch)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        {<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">            iTemp = 0;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">            cpTemp = cpSource;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">            while(*cpSource == ch)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">                ++iTemp, ++cpSource;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">            if(iTemp &gt; iCount)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">                iCount = iTemp, cpDest = cpTemp;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">            if(!*cpSource)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">                break;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        }</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    ++cpSource;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    }</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    return cpDest;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">} </span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">15、</span><span style="font-family:'楷体'; font-size:19px">不用库函数,用C语言实现将一整型数字转化为字符串</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">int getlen(char *s)</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    int n;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    for(n = 0; *s != '\0'; s++)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        n++;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    return n;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">void reverse(char s[])</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    int c,i,j;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    for(i = 0,j = getlen(s) - 1; i &lt; j; i++,j--)</span></p> 
<p style="text-indent:28px"><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        c = s[i];</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        s[i] = s[j];</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        s[j] = c;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    }</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">void itoa(int n,char s[])</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    int i,sign;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    if((sign = n) &lt; 0)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    n = -n;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    i = 0;</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    do{/*以反序生成数字*/</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        s[i++] = n%10 + '0';/*get next number*/</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    }while((n /= 10) &gt; 0);/*delete the number*/</span></p> 
<p style="margin-left:0; text-indent:28px"><span style="font-family:'楷体'; font-size:19px"> if(sign &lt; 0)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">        s[i++] = '-';</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    s[i] = '\0';</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    reverse(s);</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">}</span><span style="font-family:'楷体'; font-size:19px"></span></p> 
<p><span style="font-family:'楷体'; font-size:19px"><br> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">16、</span><span style="font-family:'楷体'; font-size:19px">请说出const与#define 相比，有何优点？</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">答：</span><span style="font-family:'楷体'; font-size:19px">c</span><span style="font-family:'楷体'; font-size:19px">onst作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">A、</span><span style="font-family:'楷体'; font-size:19px">const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">B、</span><span style="font-family:'楷体'; font-size:19px">有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">17、</span><span style="font-family:'楷体'; font-size:19px">编写用C语言实现的求n阶阶乘问题的递归算法：</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">答:</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">long int fact(int n)</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">{<!-- --></span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    i</span><span style="font-family:'楷体'; font-size:19px">f(n==0||n==1)</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">       </span><span style="font-family:'楷体'; font-size:19px">r</span><span style="font-family:'楷体'; font-size:19px">eturn 1;</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">    e</span><span style="font-family:'楷体'; font-size:19px">lse</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px">      r</span><span style="font-family:'楷体'; font-size:19px">eturn n*fact(n-1);</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">}</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">18、</span><span style="font-family:'楷体'; font-size:19px">二分查找算法：</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">A</span><span style="font-family:'楷体'; font-size:19px">递归方法实现：</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">int BSearch(elemtype a[],elemtype x,int low,int high)</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">/*在下</span><span style="font-family:'楷体'; font-size:19px">界</span><span style="font-family:'楷体'; font-size:19px">为low，上界为high的数组a中折半查找数据元素x*/</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">{<!-- --></span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">int mid;</span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">if(low&gt;high) </span></p> 
<p style="text-indent:93px"><span style="font-family:'楷体'; font-size:19px">return -1;</span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">mid=(low+high)/2;</span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">if(x</span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px">==</span><span style="font-family:'楷体'; font-size:19px"> </span><span style="font-family:'楷体'; font-size:19px">a[mid]) </span></p> 
<p style="text-indent:93px"><span style="font-family:'楷体'; font-size:19px">return mid;</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">       i</span><span style="font-family:'楷体'; font-size:19px">f(x&lt;a[mid]) </span></p> 
<p style="text-indent:93px"><span style="font-family:'楷体'; font-size:19px">return(bsearch(a,x,low,mid-1));</span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">else </span> </p> 
<p style="text-indent:93px"><span style="font-family:'楷体'; font-size:19px">return(BSearch(a,x,mid+1,high));</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">}</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">B、</span><span style="font-family:'楷体'; font-size:19px">非递归方法实现：</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">int BSearch(elemtype a[],keytype key,int n)</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">{<!-- --></span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">int low,high,mid;</span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">low=0;high=n-1;</span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">while(low&lt;=high) </span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">{<!-- --></span></p> 
<p style="text-indent:93px"><span style="font-family:'楷体'; font-size:19px">mid=(low+high)/2;</span></p> 
<p style="text-indent:93px"><span style="font-family:'楷体'; font-size:19px">if(a[mid].key==key) </span></p> 
<p style="text-indent:121px"><span style="font-family:'楷体'; font-size:19px">return mid;</span></p> 
<p style="text-indent:93px"><span style="font-family:'楷体'; font-size:19px">else if(a[mid].key&lt;key) </span></p> 
<p style="text-indent:121px"><span style="font-family:'楷体'; font-size:19px">low="mid+1;&lt;/font"&gt;</span></p> 
<p style="text-indent:93px"><span style="font-family:'楷体'; font-size:19px">else </span> </p> 
<p style="text-indent:121px"><span style="font-family:'楷体'; font-size:19px">high=mid-1;</span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">}</span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">return -1;</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">}</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">19、</span><span style="font-family:'楷体'; font-size:19px">递归计算如下递归函数的值（斐波拉契）</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">f(1)=1</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">f(2)=1</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">f(n)=f(n-1)+f(n-2) n&gt;2</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">解：</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">A、</span><span style="font-family:'楷体'; font-size:19px">非递归算法</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">int f(int n)</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">{<!-- --></span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">int i,s,s1,s2;</span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">s1=1;/*s1用于保存f(n-1)的值*/</span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">s2=1;/*s2用于保存f(n-2)的值*/</span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">s=1;</span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">for(i=3;i&lt;=n;i++)</span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">{<!-- --></span></p> 
<p style="text-indent:93px"><span style="font-family:'楷体'; font-size:19px">s=s1+s2;</span></p> 
<p style="text-indent:93px"><span style="font-family:'楷体'; font-size:19px">s2=s1;</span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">   s1=s;</span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">}</span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">return(s);</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">}</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">B、</span><span style="font-family:'楷体'; font-size:19px">递归算法</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">i</span><span style="font-family:'楷体'; font-size:19px">nt f(int n)</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">{<!-- --></span></p> 
<p style="text-indent:65px"><span style="font-family:'楷体'; font-size:19px">i</span><span style="font-family:'楷体'; font-size:19px">f(n==1||n==2)</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">   </span><span style="font-family:'楷体'; font-size:19px">        r</span><span style="font-family:'楷体'; font-size:19px">erurn 1;</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">       </span><span style="font-family:'楷体'; font-size:19px">e</span><span style="font-family:'楷体'; font-size:19px">lse</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">   </span><span style="font-family:'楷体'; font-size:19px">        r</span><span style="font-family:'楷体'; font-size:19px">e</span><span style="font-family:'楷体'; font-size:19px">t</span><span style="font-family:'楷体'; font-size:19px">u</span><span style="font-family:'楷体'; font-size:19px">r</span><span style="font-family:'楷体'; font-size:19px">n f(n-1)+f(n-2);</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">}</span></p> 
<p><span style="font-family:'楷体'; font-size:19px"><br> </span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px">20、</span><span style="font-family:'楷体'; font-size:19px">如何判断一段程序是由C 编译程序还是由C++编译程序编译的？</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">答：</span></p> 
<p><span style="font-family:'楷体'; font-size:19px">#ifdef __cplusplus</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">cout&lt;&lt;"c++";</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">#else</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">cout&lt;&lt;"c";</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">#endif</span></p> 
<p style="margin-left:0; text-indent:0"><span style="font-family:'楷体'; font-size:19px"> </span></p> 
<p><span style="font-family:'楷体'; font-size:19px">21、</span><span style="font-family:'楷体'; font-size:19px">结构与</span><span style="font-family:'楷体'; font-size:19px">共用体</span><span style="font-family:'楷体'; font-size:19px">有和区别？</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">答：</span></p> 
<p style="text-indent:28px"><span style="font-family:'楷体'; font-size:19px"> A、</span><span style="font-family:'楷体'; font-size:19px">结构和</span><span style="font-family:'楷体'; font-size:19px">共用体</span><span style="font-family:'楷体'; font-size:19px">都是由多个不同的数据类型成员组成, 但在任何同一时刻, </span><span style="font-family:'楷体'; font-size:19px">共用体</span><span style="font-family:'楷体'; font-size:19px">中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。</span><span style="font-family:'楷体'; font-size:19px"><br> </span><span style="font-family:'楷体'; font-size:19px">    B、</span><span style="font-family:'楷体'; font-size:19px">对于</span><span style="font-family:'楷体'; font-size:19px">共用体</span><span style="font-family:'楷体'; font-size:19px">的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的</span></p> 
<br>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c4e72fc976aa206ab498210986dd4082/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">box-shadow兼容性</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6ac13bbdc34f457bd926662366610718/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">postgresql的Explain命令结果分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>