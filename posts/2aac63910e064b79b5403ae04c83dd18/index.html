<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>sklearn库的学习 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="sklearn库的学习" />
<meta property="og:description" content="网上有很多关于sklearn的学习教程，大部分都是简单的讲清楚某一个方面。其实最好的教程就是官方文档（http://scikit-learn.org/stable/），但是官方文档讲述的太过于详细，同时很多人对官方文档的理解和结构认识上都不能很好的把握。我写这篇文章的目的是想用一篇文章讲清楚整个sklearn库，我会讲清楚怎么样用这个库，而不是讲清楚每一个知识点。（授人以鱼不如授人以渔）（本文很多都是从实践的角度出发，也仅仅只代表我个人的认识） 本篇文章主要从两个方面出发：1，介绍sklearn官方文档的类容和结构；2，从机器学习重要步骤出发讲清楚sklearn的使用方法。
一、sklearn官方文档的类容和结构 1，机器学习的认识：从实践的角度出发，机器学学习要做的工作就是在我们有的一个数据集上建立一个或者多个模型，然后对我们的模型进行优化和评估。我们将会在sklearn中看到下图各个模块到底是什么，怎么用。 2，sklearn库官方文档结构： 下图表示：官方文档有很多模块： tutorials：是一个官方教程，可以理解快速上手教程，但是看完感觉并没有很快。 user guide(用户指南）：这里对每一个算法有详细的介绍 API：这里是库调用的方法 FAQ：常见问题 contributing:贡献，还介绍最新的一些代码，功能。 （下面三个就跟没有用了） 总结：一般的做法是API里面找到你要调用的方法，然后可以查看方法参数的情况和使用情况。也可以在指南里面找到具体的解释。
3，sklearn库的结构： （1）结构： 由图中，可以看到库的算法主要有四类：分类，回归，聚类，降维。其中：
常用的回归：线性、决策树、SVM、KNN ；集成回归：随机森林、Adaboost、GradientBoosting、Bagging、ExtraTrees常用的分类：线性、决策树、SVM、KNN，朴素贝叶斯；集成分类：随机森林、Adaboost、GradientBoosting、Bagging、ExtraTrees常用聚类：k均值（K-means）、层次聚类（Hierarchical clustering）、DBSCAN常用降维：LinearDiscriminantAnalysis、PCA （2）图片中隐含的操作流程： 这个流程图代表：蓝色圆圈内是判断条件，绿色方框内是可以选择的算法。你可以根据自己的数据特征和任务目标去找到一条自己的操作路线，一步步做就好了。
二、机器学习主要步骤中sklearn应用 1，数据集：面对自己的任务肯定有自己的数据集，但是对于学习来说，sklearn提供了一些数据，主要有两部分：现在网上一些常用的数据集，可以通过方法加载；另一种sklearn可以生成数据，可以生成你设定的数据。（设定规模，噪声等） 下面是一段python实例：
from sklearn import datasets from sklearn.linear_model import LinearRegression import matplotlib.pyplot as plt #使用以后的数据集进行线性回归（这里是波士顿房价数据） loaded_data=datasets.load_boston() data_X=loaded_data.data data_y=loaded_data.target model=LinearRegression() model.fit(data_X,data_y) print(model.predict(data_X[:4,:])) print(data_y[:4]) #使用生成线性回归的数据集，最后的数据集结果用散点图表示 X,y=datasets.make_regression(n_samples=100,n_features=1,n_targets=1,noise=10) #n_samples表示样本数目，n_features特征的数目 n_tragets noise噪音 plt.scatter(X,y) plt.show() 2，数据预处理：数据预处理包括：降维、数据归一化、特征提取和特征转换（one-hot）等，这在sklearn里面有很多方法，具体查看api。这里用归一化（preprocessing.scale() ）例子解释一下：
from sklearn import preprocessing #进行标准化数据时，需要引入个包 import numpy as np from sklearn.cross_validation import train_test_split from sklearn.datasets.samples_generator import make_classification from sklearn." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2aac63910e064b79b5403ae04c83dd18/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-02T00:41:44+08:00" />
<meta property="article:modified_time" content="2019-12-02T00:41:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">sklearn库的学习</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>网上有很多关于sklearn的学习教程，大部分都是简单的讲清楚某一个方面。其实最好的教程就是官方文档（<a href="http://scikit-learn.org/stable/" rel="nofollow">http://scikit-learn.org/stable/</a>），但是官方文档讲述的太过于详细，同时很多人对官方文档的理解和结构认识上都不能很好的把握。我写这篇文章的目的是想用一篇文章讲清楚整个sklearn库，我会讲清楚怎么样用这个库，而不是讲清楚每一个知识点。（授人以鱼不如授人以渔）（本文很多都是从实践的角度出发，也仅仅只代表我个人的认识） <br> 本篇文章主要从两个方面出发：1，介绍sklearn官方文档的类容和结构；2，从机器学习重要步骤出发讲清楚sklearn的使用方法。</p> 
<p><strong>一、sklearn官方文档的类容和结构</strong> <br><strong>1，机器学习的认识：</strong>从实践的角度出发，机器学学习要做的工作就是在我们有的一个数据集上建立一个或者多个模型，然后对我们的模型进行优化和评估。我们将会在sklearn中看到下图各个模块到底是什么，怎么用。 <br><img alt="这里写图片描述" class="has" src="https://images2.imgbox.com/38/93/SYwj3fYU_o.png"></p> 
<p><strong>2，sklearn库官方文档结构：</strong> <br><strong>下图表示：官方文档有很多模块：</strong> <br> tutorials：是一个官方教程，可以理解快速上手教程，但是看完感觉并没有很快。 <br> user guide(用户指南）：这里对每一个算法有详细的介绍 <br> API：这里是库调用的方法 <br> FAQ：常见问题 <br> contributing:贡献，还介绍最新的一些代码，功能。 <br> （下面三个就跟没有用了） <br><img alt="这里写图片描述" class="has" src="https://images2.imgbox.com/13/a7/aOVrgSli_o.png"> <br> 总结：一般的做法是API里面找到你要调用的方法，然后可以查看方法参数的情况和使用情况。也可以在指南里面找到具体的解释。</p> 
<p><strong>3，sklearn库的结构：</strong> <br><img alt="这里写图片描述" class="has" src="https://images2.imgbox.com/d6/eb/y723wk0E_o.png"><br><strong>（1）结构：</strong> <br> 由图中，可以看到库的算法主要有四类：<strong>分类，回归，聚类，降维</strong>。其中：</p> 
<ul><li>常用的回归：线性、决策树、SVM、KNN ；集成回归：随机森林、Adaboost、GradientBoosting、Bagging、ExtraTrees</li><li>常用的分类：线性、决策树、SVM、KNN，朴素贝叶斯；集成分类：随机森林、Adaboost、GradientBoosting、Bagging、ExtraTrees</li><li>常用聚类：k均值（K-means）、层次聚类（Hierarchical clustering）、DBSCAN</li><li>常用降维：LinearDiscriminantAnalysis、PCA</li></ul> 
<p><strong>（2）图片中隐含的操作流程：</strong> <br> 这个流程图代表：蓝色圆圈内是判断条件，绿色方框内是可以选择的算法。你可以根据自己的<strong>数据特征和任务目标</strong>去找到一条自己的操作路线，一步步做就好了。</p> 
<p><strong>二、机器学习主要步骤中sklearn应用</strong> <br><strong>1，数据集：</strong>面对自己的任务肯定有自己的数据集，但是对于学习来说，sklearn提供了一些数据，主要有两部分：现在网上一些常用的数据集，可以通过方法加载；另一种sklearn可以生成数据，可以生成你设定的数据。（设定规模，噪声等） <br><img alt="这里写图片描述" class="has" src="https://images2.imgbox.com/2a/fc/fp2tWmtt_o.png"></p> 
<p>下面是一段python实例：</p> 
<pre class="has"><code class="language-python">from sklearn import datasets
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt

#使用以后的数据集进行线性回归（这里是波士顿房价数据）
loaded_data=datasets.load_boston()
data_X=loaded_data.data
data_y=loaded_data.target

model=LinearRegression()
model.fit(data_X,data_y)

print(model.predict(data_X[:4,:]))
print(data_y[:4])

#使用生成线性回归的数据集，最后的数据集结果用散点图表示
X,y=datasets.make_regression(n_samples=100,n_features=1,n_targets=1,noise=10)   #n_samples表示样本数目，n_features特征的数目  n_tragets  noise噪音
plt.scatter(X,y)
plt.show()</code></pre> 
<p><strong>2，数据预处理：</strong>数据预处理包括：降维、数据归一化、特征提取和特征转换（one-hot）等，这在sklearn里面有很多方法，具体查看api。这里用归一化（preprocessing.scale() ）例子解释一下：</p> 
<pre class="has"><code class="language-python">from sklearn import preprocessing #进行标准化数据时，需要引入个包
import numpy as np
from sklearn.cross_validation import train_test_split
from sklearn.datasets.samples_generator import  make_classification
from sklearn.svm import SVC
import matplotlib.pyplot as plt


X,y=make_classification(n_samples=300,n_features=2,n_redundant=0,n_informative=2,random_state=22,n_clusters_per_class=1,scale=100)

#X=preprocessing.minmax_scale(X,feature_range=(-1,1))
X=preprocessing.scale(X)   #0.966666666667 没有 0.477777777778
X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=0.3)
clf=SVC()
clf.fit(X_train,y_train)
print(clf.score(X_test,y_test))


plt.scatter(X[:,0],X[:,1],c=y)
plt.show()

a=np.array([[10,2.7,3.6],
            [-100,5,-2],
            [120,20,40]],dtype=np.float64)   #每一列代表一个属性
print(a)　　　　　　　#标准化之前a　　　　　
print(preprocessing.scale(a))　#标准化之后的a　</code></pre> 
<p><strong>3，选择模型并训练：</strong> sklearn里面有很多的机器学习方法，可以查看api找到你需要的方法，sklearn统一了所有模型调用的api，使用起来还是比较简单。</p> 
<pre class="has"><code class="language-python">from sklearn import datasets
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt

#使用以后的数据集进行线性回归
loaded_data=datasets.load_boston()
data_X=loaded_data.data
data_y=loaded_data.target

model=LinearRegression()
model.fit(data_X,data_y)

print(model.predict(data_X[:4,:]))
print(data_y[:4])

#参数
print(model.coef_)      #如果y=0.1x+0.3   则此行输出的结果为0.1
print(model.intercept_)             #此行输出的结果为0.3
print(model.get_params())       #模型定义时定义的参数，如果没有定义则返回默认值
print(model.score(data_X,data_y))   #给训练模型打分，注意用在LinearR中使用R^2 conefficient of determination打分</code></pre> 
<p><strong>4，模型评分：</strong> <br> （1）模型的score方法：最简单的模型评估方法是调用模型自己的方法：</p> 
<pre class="has"><code class="language-python">    #预测
    y_predict = knnClf.predict(x_test)
    print("score on the testdata:",knnClf.score(x_test,y_test))</code></pre> 
<p>（2）sklearn的指标函数：库提供的一些计算方法，常用的有classification_report方法 <br><img alt="这里写图片描述" class="has" src="https://images2.imgbox.com/ba/11/iY4E7eWS_o.png"></p> 
<p>下面是一个svm分类器，是关于图片分类的，具体数据这里没有给出，大家只需要关注模型的评估就好。</p> 
<pre class="has"><code class="language-python">def svmClassify(x_train, x_test, y_train, y_test):
    id = range(1, x_test.shape[0]+1)
    print("start run svm!")
    #训练
    svc = svm.SVC(kernel='rbf', C=10,probability=True)
    svc.fit(x_train, y_train)
    #预测
    y_predict = svc.predict(x_test)
    print("svm mode's score on the test data:",svc.score(x_test,y_test))
    print("svm mode's evaluate:",classification_report(y_test,y_predict))
    # print(svc.coef_)  # 如果y=0.1x+0.3   则此行输出的结果为0.1
    # print(svc.intercept_)  # 此行输出的结果为0.3
    print(svc.get_params())  # 模型定义时定义的参数，如果没有定义则返回默认值

    #可能性计算
    probablity = svc.predict_proba(x_test)
    list_pro = []
    for i in range(probablity.shape[0]):
        pro = max(list(probablity[i]))
        list_pro.append(pro)
    #输出
    index = np.array(id).reshape(-1,1)
    result = pd.DataFrame(np.column_stack((np.array(id).reshape(-1, 1), np.array(y_test).reshape(-1, 1),np.array(y_predict).reshape(-1,1),np.array(list_pro).reshape(-1,1))),
                          columns=['ImageId','test_label','predict_lable','probablity'])

    result.to_csv("result/svm_result.csv", index=False, header=True, encoding='gbk')

    diff_index = []
    for i in range(result.shape[0]):
        # print(result['test_label'][i], result['predict_lable'][i],)
        diff_index.append(result['test_label'][i] != result['predict_lable'][i])
    print(diff_index)
    diff = result[diff_index]
    diff_x = x_test_original[diff_index]

    diff.to_csv('result/svm_result_diff.csv', index=False, header=True, encoding='gbk')
    # 查看每个错误
    for i in range(len(diff_index)):
        # print("label is:",diff['test_label'][i],"predict is:",diff['predict_lable'][i])
        print("test label is :", diff.iloc[i]['test_label'], 'predict label is :', diff.iloc[i]['predict_lable'])
        x = diff_x[i]
        img = x.reshape(28, 28)
        image_show(img)</code></pre> 
<p>（3）sklearn也支持自己开发评价方法</p> 
<p><strong>5，模型的保存于恢复：</strong>模型的保存与恢复可以采用python的pickle，也可以用joblib的方法。</p> 
<pre class="has"><code class="language-python">from sklearn import svm
from sklearn import datasets

clf=svm.SVC()
iris=datasets.load_iris()
X,y=iris.data,iris.target
clf.fit(X,y)

#method1:pickle
import pickle
#save
with open('save/clf.pickle','wb')as f:
    pickle.dump(clf,f)

#restore
with open('save/clf.pickle','rb') as f:
    clf=pickle.load(f)
    print(clf.predict(X[0:1]))


#method2:joblib
from sklearn.externals import joblib
#save
joblib.dump(clf,'save/clf.pkl')
clf3=joblib.load('save/clf.pkl')
print(clf3.predict(X[0:1]))</code></pre> 
<p>这是一篇入门的文章，希望入门的人有一个很好的引导，接下来我也会跟新一些重要的内容。下一篇，我打算讲解交叉验证这个很重要的模块。</p> 
<p> </p> 
<hr> 
<hr> 
<hr> 
<p>前言<br> sklearn想必不用我多介绍了，一句话，她是机器学习领域中最知名的python模块之一，若想要在机器学习领域有一番建树，必绕不开sklearn</p> 
<p>sklearn的官网链接http://scikit-learn.org/stable/index.html#</p> 
<p>首先，放上一张官网上的sklearn的结构图：</p> 
<p><br> 目录<br> 1. 分类、回归<br> 2. 降维<br> 3. 模型评估与选择<br> 4. 数据预处理<br> 大类    小类    适用问题    实现    说明<br> 分类、回归                <br> 1.1 广义线性模型    1.1.1 普通最小二乘法    回归    sklearn.linear_model.LinearRegression    <br> 注：本节中所有的回归模型皆为线性回归模型    1.1.2 Ridge/岭回归    回归    sklearn.linear_model.Ridge    解决两类回归问题：<br> 一是样本少于变量个数<br> 二是变量间存在共线性<br> 1.1.3 Lasso    回归    sklearn.linear_model.Lasso    适合特征较少的数据<br> 1.1.4 Multi-task Lasso    回归    sklearn.linear_model.MultiTaskLasso    y值不是一元的回归问题<br> 1.1.5 Elastic Net    回归    sklearn.linear_model.ElasticNet    结合了Ridge和Lasso<br> 1.1.6 Multi-task Elastic Net    回归    sklearn.linear_model.MultiTaskElasticNet    y值不是一元的回归问题<br> 1.1.7 Least Angle Regression(LARS)    回归    sklearn.linear_model.Lars    适合高维数据<br> 1.1.8 LARS Lasso    回归    sklearn.linear_model.LassoLars    (1)适合高维数据使用<br> (2)LARS算法实现的lasso模型<br> 1.1.9 Orthogonal Matching Pursuit (OMP)    回归    sklearn.linear_model.OrthogonalMatchingPursuit    基于贪心算法实现<br> 1.1.10 贝叶斯回归    回归    sklearn.linear_model.BayesianRidge <br> sklearn.linear_model.ARDRegression    优点： (1)适用于手边数据(2)可用于在估计过程中包含正规化参数 <br> 缺点：耗时<br> 1.1.11 Logistic regression    分类    sklearn.linear_model.LogisticRegression    <br> 1.1.12 SGD(随机梯度下降法)    分类<br> /回归    sklearn.linear_model.SGDClassifier<br> sklearn.linear_model.SGDRegressor    适用于大规模数据<br> 1.1.13 Perceptron    分类    sklearn.linear_model.Perceptron    适用于大规模数据<br> 1.1.14 Passive Aggressive Algorithms    分类<br> /回归    sklearn.linear_model.<br> PassiveAggressiveClassifier</p> 
<p>sklearn.linear_model.<br> PassiveAggressiveRegressor    适用于大规模数据<br> 1.1.15 Huber Regression    回归    sklearn.linear_model.HuberRegressor    能够处理数据中有异常值的情况<br> 1.1.16 多项式回归    回归    sklearn.preprocessing.PolynomialFeatures    通过PolynomialFeatures将非线性特征转化成多项式形式，再用线性模型进行处理<br> 1.2 线性和二次判别分析    1.2.1 LDA    分类/降维    sklearn.discriminant_analysis.<br> LinearDiscriminantAnalysis    <br> 1.2.2 QDA    分类    sklearn.discriminant_analysis.<br> QuadraticDiscriminantAnalysis    <br> 1.3 核岭回归    简称KRR    回归    sklearn.kernel_ridge.KernelRidge    将核技巧应用到岭回归(1.1.2)中，以实现非线性回归<br> 1.4 支持向量机    1.4.1 SVC,NuSVC,LinearSVC    分类    sklearn.svm.SVC<br> sklearn.svm.NuSVC<br> sklearn.svm.LinearSVC    SVC可用于非线性分类，可指定核函数；<br> NuSVC与SVC唯一的不同是可控制支持向量的个数;<br> LinearSVC用于线性分类<br> 1.4.2 SVR,NuSVR,LinearSVR    回归    sklearn.svm.SVR<br> sklearn.svm.NuSVR<br> sklearn.svm.LinearSVR    同上，将"分类"变成"回归"即可<br> 1.4.3 OneClassSVM    异常检测    sklearn.svm.OneClassSVM    无监督实现异常值检测<br> 1.5 随机梯度下降    同1.1.12            <br> 1.6 最近邻    1.6.1 Unsupervised Nearest Neighbors    –    sklearn.neighbors.NearestNeighbors    无监督实现K近邻的寻找<br> 1.6.2 Nearest Neighbors Classification    分类    sklearn.neighbors.KNeighborsClassifier<br> sklearn.neighbors.RadiusNeighborsClassifier    (1)不太适用于高维数据<br> (2)两种实现只是距离度量不一样，后者更适合非均匀的采样<br> 1.6.3 Nearest Neighbors Regression    回归    sklearn.neighbors.KNeighborsRegressor<br> sklearn.neighbors.RadiusNeighborsRegressor    同上<br> 1.6.5 Nearest Centroid Classifier    分类    sklearn.neighbors.NearestCentroid    每个类对应一个质心，测试样本被分类到距离最近的质心所在的类别<br> 1.7 高斯过程(GP/GPML)    1.7.1 GPR    回归    sklearn.gaussian_process.<br> GaussianProcessRegressor    与KRR一样使用了核技巧<br> 1.7.3 GPC    分类    sklearn.gaussian_process.<br> GaussianProcessClassifier    <br> 1.8 交叉分解    实现算法：CCA和PLS    –    –    用来计算两个多元数据集的线性关系，当预测数据比观测数据有更多的变量时，用PLS更好<br> 1.9 朴素贝叶斯    1.9.1 高斯朴素贝叶斯    分类    sklearn.naive_bayes.GaussianNB    处理特征是连续型变量的情况<br> 1.9.2 多项式朴素贝叶斯    分类    sklearn.naive_bayes.MultinomialNB    最常见，要求特征是离散数据<br> 1.9.3 伯努利朴素贝叶斯    分类    sklearn.naive_bayes.BernoulliNB    要求特征是离散的，且为布尔类型，即true和false，或者1和0<br> 1.10 决策树    1.10.1 Classification    分类    sklearn.tree.DecisionTreeClassifier    <br> 1.10.2 Regression    回归    sklearn.tree.DecisionTreeRegressor    <br> 1.11 集成方法    1.11.1 Bagging    分类/回归    sklearn.ensemble.BaggingClassifier<br> sklearn.ensemble.BaggingRegressor    可以指定基学习器，默认为决策树<br> 注：1和2属于集成方法中的并行化方法，3和4属于序列化方法    1.11.2 Forests of randomized trees    分类/回归    RandomForest(RF,随机森林):<br> sklearn.ensemble.RandomForestClassifier<br> sklearn.ensemble.RandomForestRegressor<br> ExtraTrees(RF改进):<br> sklearn.ensemble.ExtraTreesClassifier<br> sklearn.ensemble.ExtraTreesRegressor    基学习器为决策树<br> 1.11.3 AdaBoost    分类/回归    sklearn.ensemble.AdaBoostClassifier<br> sklearn.ensemble.AdaBoostRegressor    可以指定基学习器，默认为决策树<br> 号外：最近特别火的两个梯度提升算法，LightGBM和XGBoost<br> (XGBoost提供了sklearn接口)    1.11.4 Gradient Tree Boosting    分类/回归    GBDT:<br> sklearn.ensemble.GradientBoostingClassifier<br> GBRT:<br> sklearn.ensemble.GradientBoostingRegressor    基学习器为决策树<br> 1.11.5 Voting Classifier    分类    sklearn.ensemble.VotingClassifier    须指定基学习器<br> 1.12 多类与多标签算法    –    –    –    sklearn中的分类算法都默认支持多类分类，其中LinearSVC、 LogisticRegression和GaussianProcessClassifier在进行多类分类时需指定参数multi_class<br> 1.13 特征选择    1.13.1 过滤法之方差选择法    特征选择    sklearn.feature_selection.VarianceThreshold    特征选择方法分为3种：过滤法、包裹法和嵌入法。过滤法不用考虑后续学习器<br> 1.13.2 过滤法之卡方检验    特征选择    sklearn.feature_selection.SelectKBest    <br> 1.13.3 包裹法之递归特征消除法    特征选择    sklearn.feature_selection.RFE    包裹法需考虑后续学习器，参数中需输入基学习器<br> 1.13.4 嵌入法    特征选择    sklearn.feature_selection.SelectFromModel    嵌入法是过滤法和嵌入法的结合，参数中也需输入基学习器<br> 1.14 半监督    1.14.1 Label Propagation    分类/回归    sklearn.semi_supervised.LabelPropagation<br> sklearn.semi_supervised.LabelSpreading    <br> 1.15 保序回归    –    回归    sklearn.isotonic.IsotonicRegression    <br> 1.16 概率校准    –    –    –    在执行分类时，获得预测的标签的概率<br> 1.17 神经网络模型    （待写）            <br> 降维                <br> 2.5 降维    2.5.1 主成分分析    降维    PCA:<br> sklearn.decomposition.PCA<br> IPCA:<br> sklearn.decomposition.IncrementalPCA<br> KPCA:<br> sklearn.decomposition.KernelPCA<br> SPCA:<br> sklearn.decomposition.SparsePCA    (1)IPCA比PCA有更好的内存效率，适合超大规模降维。<br> (2)KPCA可以进行非线性降维<br> (3)SPCA是PCA的变体，降维后返回最佳的稀疏矩阵<br> 2.5.2 截断奇异值分解    降维    sklearn.decomposition.TruncatedSVD    可以直接对scipy.sparse矩阵处理<br> 2.5.3 字典学习    –    sklearn.decomposition.SparseCoder<br> sklearn.decomposition.DictionaryLearning    SparseCoder实现稀疏编码，DictionaryLearning实现字典学习<br> 模型评估与选择                <br> 3.1 交叉验证/CV    3.1.1 分割训练集和测试集    –    sklearn.model_selection.train_test_split    <br> 3.1.2 通过交叉验证评估score    –    sklearn.model_selection.cross_val_score    score对应性能度量，分类问题默认为accuracy_score，回归问题默认为r2_score<br> 3.1.3 留一法LOO    –    sklearn.model_selection.LeaveOneOut    CV的特例<br> 3.1.4 留P法LPO    –    sklearn.model_selection.LeavePOut    CV的特例<br> 3.2 调参    3.2.1 网格搜索    –    sklearn.model_selection.GridSearchCV    最常用的调参方法。可传入学习器、学习器参数范围、性能度量score(默认为accuracy_score或r2_score )等<br> 3.2.2 随机搜索    –    sklearn.model_selection.RandomizedSearchCV    参数传入同上<br> 3.3 性能度量    3.3.1 分类度量    –    –    对应交叉验证和调参中的score<br> 3.3.2 回归度量    –    –    <br> 3.3.3 聚类度量    –    –    <br> 3.4 模型持久性    –    –    –    使用pickle存放模型，可以使模型不用重复训练<br> 3.5 验证曲线    3.5.1 验证曲线    –    sklearn.model_selection.validation_curve    横轴为某个参数的值，纵轴为模型得分<br> 3.5.2 学习曲线    –    sklearn.model_selection.learning_curve    横轴为训练数据大小，纵轴为模型得分<br> 数据预处理                <br> 4.3 数据预处理    4.3.1 标准化    数据预处理    标准化:<br> sklearn.preprocessing.scale<br> sklearn.preprocessing.StandardScaler    scale与StandardScaler都是将将特征转化成标准正态分布(即均值为0，方差为1),且都可以处理scipy.sparse矩阵，但一般选择后者<br> 数据预处理    <br> 区间缩放:<br> sklearn.preprocessing.MinMaxScaler<br> sklearn.preprocessing.MaxAbsScale    MinMaxScaler默认为0-1缩放，MaxAbsScaler可以处理scipy.sparse矩阵<br> 4.3.2 非线性转换    数据预处理    sklearn.preprocessing.QuantileTransformer    可以更少的受异常值的影响<br> 4.3.3 归一化    数据预处理    sklearn.preprocessing.Normalizer    将行向量转换为单位向量，目的在于样本向量在点乘运算或其他核函数计算相似性时，拥有统一的标准<br> 4.3.4 二值化    数据预处理    sklearn.preprocessing.Binarizer    通过设置阈值对定量特征处理，获取布尔值<br> 4.3.5 哑编码    数据预处理    sklearn.preprocessing.OneHotEncoder    对定性特征编码。也可用pandas.get_dummies实现<br> 4.3.6 缺失值计算    数据预处理    sklearn.preprocessing.Imputer    可用三种方式填充缺失值，均值（默认）、中位数和众数。也可用pandas.fillna实现<br> 4.3.7 多项式转换    数据预处理    sklearn.preprocessing.PolynomialFeatures    <br> 4.3.8 自定义转换    数据预处理    sklearn.preprocessing.FunctionTransformer    <br> 我的github上也有，欢迎大家去看</p> 
<hr> 
<hr> 
<hr> 
<p><a href="https://blog.csdn.net/GitChat/article/details/79396231">https://blog.csdn.net/GitChat/article/details/79396231</a></p> 
<p><br><img alt="" class="has" height="898" src="https://images2.imgbox.com/67/17/Ar0sXkeb_o.png" width="976"></p> 
<p><img alt="" class="has" height="822" src="https://images2.imgbox.com/f8/6f/Yn1WONrI_o.png" width="970"></p> 
<p><img alt="" class="has" height="858" src="https://images2.imgbox.com/b6/ff/80N9voDo_o.png" width="970"></p> 
<p><img alt="" class="has" height="883" src="https://images2.imgbox.com/4c/8d/kqUPx5By_o.png" width="976"></p> 
<p><img alt="" class="has" height="771" src="https://images2.imgbox.com/26/64/pZaDQs7X_o.png" width="972"></p> 
<p><img alt="" class="has" height="894" src="https://images2.imgbox.com/82/c2/oya1SLf8_o.png" width="966"></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b730101ca81d327d217edff2e058d343/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">存储空间都去哪了？占用空间比文件大太多？可能是文件系统和默认簇大小惹的祸</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7a1c8b60b681859e6393af46c4096327/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">springboot 整合apollo时引用apollo-client后报错</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>