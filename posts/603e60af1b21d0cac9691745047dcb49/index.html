<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OkHttp源码分析 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OkHttp源码分析" />
<meta property="og:description" content="本文配套视频： okhttp内核分析配套视频一okhttp内核分析配套视频二okhttp内核分析配套视频三 源码分析相关面试题 Volley源码分析注解框架实现原理 基本使用 从使用方法出发，首先是怎么使用，其次是我们使用的功能在内部是如何实现的.建议大家下载 OkHttp 源码之后，跟着本文，过一遍源码。
官方博客栗子：http://square.github.io/okhttp/#examples
OkHttpClient client = new OkHttpClient(); String run(String url) throws IOException { Request request = new Request.Builder() .url(url) .build(); Response response = client.newCall(request).execute(); return response.body().string(); } 12345678910 Request、Response、Call 基本概念 上面的代码中涉及到几个常用的类：Request、Response和Call。下面分别介绍：
Request 每一个HTTP请求包含一个URL、一个方法（GET或POST或其他）、一些HTTP头。请求还可能包含一个特定内容类型的数据类的主体部分。
Response 响应是对请求的回复，包含状态码、HTTP头和主体部分。
Call OkHttp使用Call抽象出一个满足请求的模型，尽管中间可能会有多个请求或响应。执行Call有两种方式，同步或异步
第一步：创建 OkHttpClient对象,进行源码分析： OkHttpClient client = new OkHttpClient();` 1 通过okhttp源码分析,直接创建的 OkHttpClient对象并且默认构造builder对象进行初始化
public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory { public OkHttpClient() { this(new Builder()); } OkHttpClient(Builder builder) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/603e60af1b21d0cac9691745047dcb49/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-06-13T14:24:56+08:00" />
<meta property="article:modified_time" content="2018-06-13T14:24:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OkHttp源码分析</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article_content clearfix csdn-tracking-statistics" style="padding:0px;margin:0px;"> 
 <div class="markdown_views" style="padding:0px;margin:0px;font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"> 
  <h4 style="padding:0px;">本文配套视频：</h4> 
  <ul style="list-style:none;"><li style="padding:0px;"><a href="https://v.qq.com/x/page/j050015e4sm.html" rel="nofollow">okhttp内核分析配套视频一</a></li><li style="padding:0px;"><a href="https://v.qq.com/x/page/i05006qtood.html" rel="nofollow">okhttp内核分析配套视频二</a></li><li style="padding:0px;"><a href="https://v.qq.com/x/page/y0500461od9.html" rel="nofollow">okhttp内核分析配套视频三</a></li></ul> 
  <h4 style="padding:0px;">源码分析相关面试题</h4> 
  <ul style="list-style:none;"><li style="padding:0px;"><a href="http://blog.csdn.net/mwq384807683/article/details/71305969">Volley源码分析</a></li><li style="padding:0px;"><a href="http://blog.csdn.net/mwq384807683/article/details/70795881">注解框架实现原理</a></li></ul> 
  <h5 style="padding:0px;">基本使用</h5> 
  <p>从使用方法出发，首先是怎么使用，其次是我们使用的功能在内部是如何实现的.建议大家下载 OkHttp 源码之后，跟着本文，过一遍源码。</p> 
  <p>官方博客栗子：<a href="http://square.github.io/okhttp/#examples" rel="nofollow">http://square.github.io/okhttp/#examples</a></p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs vbscript has-numbering">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();

<span class="hljs-built_in">String</span> run(<span class="hljs-built_in">String</span> url) throws IOException {
  <span class="hljs-built_in">Request</span> <span class="hljs-built_in">request</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Request</span>.Builder()
      .url(url)
      .build();

  <span class="hljs-built_in">Response</span> <span class="hljs-built_in">response</span> = client.newCall(<span class="hljs-built_in">request</span>).<span class="hljs-keyword">execute</span>();
  return <span class="hljs-built_in">response</span>.body().<span class="hljs-built_in">string</span>();
}</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li></ul> 
  <h4 style="padding:0px;">Request、Response、Call 基本概念</h4> 
  <p>上面的代码中涉及到几个常用的类：Request、Response和Call。下面分别介绍：</p> 
  <h5 style="padding:0px;">Request</h5> 
  <p>每一个HTTP请求包含一个URL、一个方法（GET或POST或其他）、一些HTTP头。请求还可能包含一个特定内容类型的数据类的主体部分。</p> 
  <h5 style="padding:0px;">Response</h5> 
  <p>响应是对请求的回复，包含状态码、HTTP头和主体部分。</p> 
  <h5 style="padding:0px;">Call</h5> 
  <p>OkHttp使用Call抽象出一个满足请求的模型，尽管中间可能会有多个请求或响应。执行Call有两种方式，同步或异步</p> 
  <h4 style="padding:0px;">第一步：创建 OkHttpClient对象,进行源码分析：</h4> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs axapta has-numbering">OkHttpClient <span class="hljs-keyword">client</span> = <span class="hljs-keyword">new</span> OkHttpClient();`</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li></ul> 
  <p>通过okhttp源码分析,直接创建的 OkHttpClient对象并且默认构造builder对象进行初始化</p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs avrasm has-numbering">public class OkHttpClient implements Cloneable, <span class="hljs-keyword">Call</span><span class="hljs-preprocessor">.Factory</span>, WebSocket<span class="hljs-preprocessor">.Factory</span> {
  public OkHttpClient() {
       this(new Builder())<span class="hljs-comment">;</span>
  }
  OkHttpClient(Builder builder) {
    this<span class="hljs-preprocessor">.dispatcher</span> = builder<span class="hljs-preprocessor">.dispatcher</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.proxy</span> = builder<span class="hljs-preprocessor">.proxy</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.protocols</span> = builder<span class="hljs-preprocessor">.protocols</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.connectionSpecs</span> = builder<span class="hljs-preprocessor">.connectionSpecs</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.interceptors</span> = Util<span class="hljs-preprocessor">.immutableList</span>(builder<span class="hljs-preprocessor">.interceptors</span>)<span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.networkInterceptors</span> = Util<span class="hljs-preprocessor">.immutableList</span>(builder<span class="hljs-preprocessor">.networkInterceptors</span>)<span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.eventListenerFactory</span> = builder<span class="hljs-preprocessor">.eventListenerFactory</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.proxySelector</span> = builder<span class="hljs-preprocessor">.proxySelector</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.cookieJar</span> = builder<span class="hljs-preprocessor">.cookieJar</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.cache</span> = builder<span class="hljs-preprocessor">.cache</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.internalCache</span> = builder<span class="hljs-preprocessor">.internalCache</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.socketFactory</span> = builder<span class="hljs-preprocessor">.socketFactory</span><span class="hljs-comment">;</span>

    boolean isTLS = false<span class="hljs-comment">;</span>
    ......

    this<span class="hljs-preprocessor">.hostnameVerifier</span> = builder<span class="hljs-preprocessor">.hostnameVerifier</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.certificatePinner</span> = builder<span class="hljs-preprocessor">.certificatePinner</span><span class="hljs-preprocessor">.withCertificateChainCleaner</span>(
        certificateChainCleaner)<span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.proxyAuthenticator</span> = builder<span class="hljs-preprocessor">.proxyAuthenticator</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.authenticator</span> = builder<span class="hljs-preprocessor">.authenticator</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.connectionPool</span> = builder<span class="hljs-preprocessor">.connectionPool</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.dns</span> = builder<span class="hljs-preprocessor">.dns</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.followSslRedirects</span> = builder<span class="hljs-preprocessor">.followSslRedirects</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.followRedirects</span> = builder<span class="hljs-preprocessor">.followRedirects</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.retryOnConnectionFailure</span> = builder<span class="hljs-preprocessor">.retryOnConnectionFailure</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.connectTimeout</span> = builder<span class="hljs-preprocessor">.connectTimeout</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.readTimeout</span> = builder<span class="hljs-preprocessor">.readTimeout</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.writeTimeout</span> = builder<span class="hljs-preprocessor">.writeTimeout</span><span class="hljs-comment">;</span>
    this<span class="hljs-preprocessor">.pingInterval</span> = builder<span class="hljs-preprocessor">.pingInterval</span><span class="hljs-comment">;</span>
  }
}</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">12</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">13</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">14</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">15</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">16</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">17</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">18</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">19</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">20</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">21</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">22</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">23</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">24</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">25</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">26</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">27</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">28</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">29</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">30</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">31</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">32</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">33</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">34</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">35</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">36</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">37</li></ul> 
  <h4 style="padding:0px;">第二步：接下来发起 HTTP 请求</h4> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs vbscript has-numbering"><span class="hljs-built_in">Request</span> <span class="hljs-built_in">request</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Request</span>.Builder().url(<span class="hljs-string">"url"</span>).build();
okHttpClient.newCall(<span class="hljs-built_in">request</span>).enqueue(<span class="hljs-keyword">new</span> Callback() {
  @Override
  <span class="hljs-keyword">public</span> void onFailure(<span class="hljs-keyword">Call</span> <span class="hljs-keyword">call</span>, IOException e) {

 }

@Override
<span class="hljs-keyword">public</span> void onResponse(<span class="hljs-keyword">Call</span> <span class="hljs-keyword">call</span>, <span class="hljs-built_in">Response</span> <span class="hljs-built_in">response</span>) throws IOException {

}
});</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">12</li></ul> 
  <h4 style="padding:0px;">第二步：代码流程分析：</h4> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs vbscript has-numbering"><span class="hljs-built_in">Request</span> <span class="hljs-built_in">request</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Request</span>.Builder().url(<span class="hljs-string">"url"</span>).build();</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li></ul> 
  <p>初始化构建者模式和请求对象，并且用URL替换Web套接字URL。</p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs cs has-numbering"><span class="hljs-keyword">public</span> final <span class="hljs-keyword">class</span> Request {
    <span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span>() {
      <span class="hljs-keyword">this</span>.method = <span class="hljs-string">"GET"</span>;
      <span class="hljs-keyword">this</span>.headers = <span class="hljs-keyword">new</span> Headers.Builder();
    }
    <span class="hljs-keyword">public</span> Builder <span class="hljs-title">url</span>(String url) {
      ......

      <span class="hljs-comment">// Silently replace web socket URLs with HTTP URLs.</span>
      <span class="hljs-keyword">if</span> (url.regionMatches(<span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"ws:"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>)) {
        url = <span class="hljs-string">"http:"</span> + url.substring(<span class="hljs-number">3</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url.regionMatches(<span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"wss:"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>)) {
        url = <span class="hljs-string">"https:"</span> + url.substring(<span class="hljs-number">4</span>);
      }

      HttpUrl parsed = HttpUrl.parse(url);
      ......
      <span class="hljs-keyword">return</span> url(parsed);
    }
    <span class="hljs-keyword">public</span> Request <span class="hljs-title">build</span>() {
      ......
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Request(<span class="hljs-keyword">this</span>);
    }
}</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">12</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">13</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">14</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">15</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">16</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">17</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">18</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">19</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">20</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">21</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">22</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">23</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">24</li></ul> 
  <h4 style="padding:0px;">第三步：方法解析：</h4> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering">okHttpClient.newCall(request).enqueue(<span class="hljs-keyword">new</span> Callback() {
<span class="hljs-annotation">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span>(Call call, IOException e) {

}

<span class="hljs-annotation">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span>(Call call, Response response) <span class="hljs-keyword">throws</span> IOException {

}
});</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li></ul> 
  <p>源码分析：</p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OkHttpClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Call</span>.<span class="hljs-title">Factory</span>, <span class="hljs-title">WebSocket</span>.<span class="hljs-title">Factory</span> {<!-- --></span>
   <span class="hljs-annotation">@Override</span> 
   <span class="hljs-keyword">public</span> Call <span class="hljs-title">newCall</span>(Request request) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RealCall(<span class="hljs-keyword">this</span>, request, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* for web socket */</span>);
   }



}</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li></ul> 
  <p>RealCall实现了Call.Factory接口创建了一个RealCall的实例，而RealCall是Call接口的实现。</p> 
  <h4 style="padding:0px;">异步请求的执行流程</h4> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs axapta has-numbering"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealCall</span> <span class="hljs-inheritance"><span class="hljs-keyword">implements</span></span> <span class="hljs-title">Call</span> {<!-- --></span>
   @Override 
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> enqueue(Callback responseCallback) {
   synchronized (<span class="hljs-keyword">this</span>) {
   <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Already Executed"</span>);
      executed = <span class="hljs-keyword">true</span>;
   }
    captureCallStackTrace();
    <span class="hljs-keyword">client</span>.dispatcher().enqueue(<span class="hljs-keyword">new</span> AsyncCall(responseCallback));
  }
}</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li></ul> 
  <p>由以上源码得知：</p> 
  <p>1） 检查这个 call 是否已经被执行了，每个 call 只能被执行一次，如果想要一个完全一样的 call，可以利用 call#clone 方法进行克隆。</p> 
  <p>2）利用 client.dispatcher().enqueue(this) 来进行实际执行，dispatcher 是刚才看到的 OkHttpClient.Builder 的成员之一</p> 
  <p>3）AsyncCall是RealCall的一个内部类并且继承NamedRunnable，那么首先看NamedRunnable类是什么样的，如下：</p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NamedRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> {<!-- --></span>
  ......

  <span class="hljs-annotation">@Override</span> 
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
   ......
    <span class="hljs-keyword">try</span> {
      execute();
    }
    ......
  }

  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span>();
}</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">12</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">13</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">14</li></ul> 
  <p>可以看到NamedRunnable实现了Runnbale接口并且是个抽象类，其抽象方法是execute()，该方法是在run方法中被调用的，这也就意味着NamedRunnable是一个任务，并且其子类应该实现execute方法。下面再看AsyncCall的实现：</p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs axapta has-numbering"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncCall</span> <span class="hljs-inheritance"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">NamedRunnable</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Callback responseCallback;

    AsyncCall(Callback responseCallback) {
      <span class="hljs-keyword">super</span>(<span class="hljs-string">"OkHttp %s"</span>, redactedUrl());
      <span class="hljs-keyword">this</span>.responseCallback = responseCallback;
    }

    ......
<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealCall</span> <span class="hljs-inheritance"><span class="hljs-keyword">implements</span></span> <span class="hljs-title">Call</span> {<!-- --></span>
  @Override <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> execute() {
  <span class="hljs-keyword">boolean</span> signalledCallback = <span class="hljs-keyword">false</span>;
  <span class="hljs-keyword">try</span> {
     Response response = getResponseWithInterceptorChain();
  <span class="hljs-keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) {
     signalledCallback = <span class="hljs-keyword">true</span>;
     responseCallback.onFailure(RealCall.<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>));
  } <span class="hljs-keyword">else</span> {
    signalledCallback = <span class="hljs-keyword">true</span>;
    responseCallback.onResponse(RealCall.<span class="hljs-keyword">this</span>, response);
  }
 } <span class="hljs-keyword">catch</span> (IOException e) {
  ......
  responseCallback.onFailure(RealCall.<span class="hljs-keyword">this</span>, e);

} <span class="hljs-keyword">finally</span> {
    <span class="hljs-keyword">client</span>.dispatcher().finished(<span class="hljs-keyword">this</span>);
  }
}</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">12</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">13</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">14</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">15</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">16</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">17</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">18</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">19</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">20</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">21</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">22</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">23</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">24</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">25</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">26</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">27</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">28</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">29</li></ul> 
  <p>AsyncCall实现了execute方法，首先是调用getResponseWithInterceptorChain()方法获取响应，然后获取成功后，就调用回调的onReponse方法，如果失败，就调用回调的onFailure方法。最后，调用Dispatcher的finished方法。</p> 
  <p>关键代码：</p> 
  <p>responseCallback.onFailure(RealCall.this, new IOException(“Canceled”));</p> 
  <p>和</p> 
  <p>responseCallback.onResponse(RealCall.this, response);</p> 
  <p>走完这两句代码会进行回调到刚刚我们初始化Okhttp的地方,如下：</p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering">okHttpClient.newCall(request).enqueue(<span class="hljs-keyword">new</span> Callback() {
   <span class="hljs-annotation">@Override</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span>(Call call, IOException e) {

   }

   <span class="hljs-annotation">@Override</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span>(Call call, Response response) <span class="hljs-keyword">throws</span> IOException {

   }
});</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li></ul> 
  <h4 style="padding:0px;">核心重点类Dispatcher线程池介绍</h4> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dispatcher</span> {<!-- --></span>
  <span class="hljs-javadoc">/** 最大并发请求数为64 */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxRequests = <span class="hljs-number">64</span>;
  <span class="hljs-javadoc">/** 每个主机最大请求数为5 */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxRequestsPerHost = <span class="hljs-number">5</span>;

  <span class="hljs-javadoc">/** 线程池 */</span>
  <span class="hljs-keyword">private</span> ExecutorService executorService;

  <span class="hljs-javadoc">/** 准备执行的请求 */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();

  <span class="hljs-javadoc">/** 正在执行的异步请求，包含已经取消但未执行完的请求 */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();

  <span class="hljs-javadoc">/** 正在执行的同步请求，包含已经取消单未执行完的请求 */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">12</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">13</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">14</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">15</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">16</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">17</li></ul> 
  <p>在OkHttp，使用如下构造了单例线程池</p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> ExecutorService <span class="hljs-title">executorService</span>() {
    <span class="hljs-keyword">if</span> (executorService == <span class="hljs-keyword">null</span>) {
      executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE, <span class="hljs-number">60</span>, TimeUnit.SECONDS,
          <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="hljs-string">"OkHttp Dispatcher"</span>, <span class="hljs-keyword">false</span>));
    }
    <span class="hljs-keyword">return</span> executorService;
  }</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li></ul> 
  <p>构造一个线程池ExecutorService：</p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs lasso has-numbering">executorService <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> ThreadPoolExecutor(
<span class="hljs-comment">//corePoolSize 最小并发线程数,如果是0的话，空闲一段时间后所有线程将全部被销毁</span>
    <span class="hljs-number">0</span>, 
<span class="hljs-comment">//maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理</span>
    <span class="hljs-built_in">Integer</span><span class="hljs-built_in">.</span>MAX_VALUE, 
<span class="hljs-comment">//keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间</span>
    <span class="hljs-number">60</span>, 
<span class="hljs-comment">//单位秒</span>
    TimeUnit<span class="hljs-built_in">.</span>SECONDS,
<span class="hljs-comment">//工作队列,先进先出</span>
    <span class="hljs-literal">new</span> SynchronousQueue<span class="hljs-subst">&lt;</span>Runnable<span class="hljs-subst">&gt;</span>(),   
<span class="hljs-comment">//单个线程的工厂         </span>
   Util<span class="hljs-built_in">.</span>threadFactory(<span class="hljs-string">"OkHttp Dispatcher"</span>, <span class="hljs-literal">false</span>));</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">12</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">13</li></ul> 
  <p>可以看出，在Okhttp中，构建了一个核心为[0, Integer.MAX_VALUE]的线程池，它不保留任何最小线程数，随时创建更多的线程数，当线程空闲时只能活60秒，它使用了一个不存储元素的阻塞工作队列，一个叫做”OkHttp Dispatcher”的线程工厂。</p> 
  <p>也就是说，在实际运行中，当收到10个并发请求时，线程池会创建十个线程，当工作完成后，线程池会在60s后相继关闭所有线程。</p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs sql has-numbering">synchronized void enqueue(AsyncCall <span class="hljs-operator"><span class="hljs-keyword">call</span>) {
    <span class="hljs-keyword">if</span> (runningAsyncCalls.<span class="hljs-keyword">size</span>() &lt; maxRequests &amp;&amp; runningCallsForHost(<span class="hljs-keyword">call</span>) &lt; maxRequestsPerHost) {
      runningAsyncCalls.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">call</span>);</span>
      executorService().execute(<span class="hljs-operator"><span class="hljs-keyword">call</span>);</span>
    } else {
      readyAsyncCalls.add(<span class="hljs-operator"><span class="hljs-keyword">call</span>);</span>
    }
  }</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li></ul> 
  <p>从上述源码分析，如果当前还能执行一个并发请求，则加入 runningAsyncCalls ，立即执行，否则加入 readyAsyncCalls 队列。</p> 
  <p>Dispatcher线程池总结</p> 
  <p>1）调度线程池Disptcher实现了高并发，低阻塞的实现 <br>2）采用Deque作为缓存，先进先出的顺序执行 <br>3）任务在try/finally中调用了finished函数，控制任务队列的执行顺序，而不是采用锁，减少了编码复杂性提高性能</p> 
  <p>这里是分析OkHttp源码，并不详细讲线程池原理，如对线程池不了解请参考如下链接</p> 
  <p><a href="http://www.jianshu.com/p/c22398f8587f" rel="nofollow">点我，线程池原理，在文章性能优化最后有视频对线程池原理讲解</a></p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs axapta has-numbering">
 <span class="hljs-keyword">try</span> {
        Response response = getResponseWithInterceptorChain();
        <span class="hljs-keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) {
          signalledCallback = <span class="hljs-keyword">true</span>;
          responseCallback.onFailure(RealCall.<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>));
        } <span class="hljs-keyword">else</span> {
          signalledCallback = <span class="hljs-keyword">true</span>;
          responseCallback.onResponse(RealCall.<span class="hljs-keyword">this</span>, response);
        }
      } <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">client</span>.dispatcher().finished(<span class="hljs-keyword">this</span>);
      }</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">12</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">13</li></ul> 
  <p>当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数</p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs sql has-numbering"> void finished(AsyncCall <span class="hljs-operator"><span class="hljs-keyword">call</span>) {
    finished(runningAsyncCalls, <span class="hljs-keyword">call</span>, <span class="hljs-keyword">true</span>);</span>
  }

</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li></ul> 
  <p>从上面的代码可以看出，第一个参数传入的是正在运行的异步队列，第三个参数为true，下面再看有是三个参数的finished方法：</p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">finished</span>(Deque&lt;T&gt; calls, T call, <span class="hljs-keyword">boolean</span> promoteCalls) {
    <span class="hljs-keyword">int</span> runningCallsCount;
    Runnable idleCallback;
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
      <span class="hljs-keyword">if</span> (!calls.remove(call)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(<span class="hljs-string">"Call wasn't in-flight!"</span>);
      <span class="hljs-keyword">if</span> (promoteCalls) promoteCalls();
      runningCallsCount = runningCallsCount();
      idleCallback = <span class="hljs-keyword">this</span>.idleCallback;
    }

    <span class="hljs-keyword">if</span> (runningCallsCount == <span class="hljs-number">0</span> &amp;&amp; idleCallback != <span class="hljs-keyword">null</span>) {
      idleCallback.run();
    }
  }</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">12</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">13</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">14</li></ul> 
  <p>打开源码，发现它将正在运行的任务Call从队列runningAsyncCalls中移除后，获取运行数量判断是否进入了Idle状态,接着执行promoteCalls()函数,下面是promoteCalls()方法：</p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs cs has-numbering"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">promoteCalls</span>() {
    <span class="hljs-keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Already running max capacity.</span>
    <span class="hljs-keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// No ready calls to promote.</span>

    <span class="hljs-keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) {
      AsyncCall call = i.next();

      <span class="hljs-keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) {
        i.remove();
        runningAsyncCalls.add(call);
        executorService().execute(call);
      }

      <span class="hljs-keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Reached max capacity.</span>
    }
  }</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">12</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">13</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">14</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">15</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">16</li></ul> 
  <p>主要就是遍历等待队列，并且需要满足同一主机的请求小于maxRequestsPerHost时，就移到运行队列中并交给线程池运行。就主动的把缓存队列向前走了一步，而没有使用互斥锁等复杂编码</p> 
  <h4 style="padding:0px;">核心重点getResponseWithInterceptorChain方法</h4> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs axapta has-numbering">Response getResponseWithInterceptorChain() throws IOException {
    <span class="hljs-comment">// Build a full stack of interceptors.</span>
    List&lt;Interceptor&gt; interceptors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    interceptors.addAll(<span class="hljs-keyword">client</span>.interceptors());
    interceptors.add(retryAndFollowUpInterceptor);
    interceptors.add(<span class="hljs-keyword">new</span> BridgeInterceptor(<span class="hljs-keyword">client</span>.cookieJar()));
    interceptors.add(<span class="hljs-keyword">new</span> CacheInterceptor(<span class="hljs-keyword">client</span>.internalCache()));
    interceptors.add(<span class="hljs-keyword">new</span> ConnectInterceptor(<span class="hljs-keyword">client</span>));
    <span class="hljs-keyword">if</span> (!forWebSocket) {
      interceptors.addAll(<span class="hljs-keyword">client</span>.networkInterceptors());
    }
    interceptors.add(<span class="hljs-keyword">new</span> CallServerInterceptor(forWebSocket));

    Interceptor.Chain chain = <span class="hljs-keyword">new</span> RealInterceptorChain(
        interceptors, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, originalRequest);
    <span class="hljs-keyword">return</span> chain.proceed(originalRequest);
  }</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">12</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">13</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">14</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">15</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">16</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">17</li></ul> 
  <p><img src="https://images2.imgbox.com/3b/3c/rhPQiKwP_o.png" alt="" title="" style="margin-top:24px;margin-bottom:24px;"></p> 
  <p>1）在配置 OkHttpClient 时设置的 interceptors； <br>2）负责失败重试以及重定向的 RetryAndFollowUpInterceptor； <br>3）负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的 BridgeInterceptor； <br>4）负责读取缓存直接返回、更新缓存的 CacheInterceptor； <br>5）负责和服务器建立连接的 ConnectInterceptor； <br>6）配置 OkHttpClient 时设置的 networkInterceptors； <br>7）负责向服务器发送请求数据、从服务器读取响应数据的 CallServerInterceptor。</p> 
  <p>OkHttp的这种拦截器链采用的是责任链模式，这样的好处是将请求的发送和处理分开，并且可以动态添加中间的处理方实现对请求的处理、短路等操作。</p> 
  <p>从上述源码得知，不管okhttp有多少拦截器最后都会走，如下方法：</p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs cs has-numbering">Interceptor.Chain chain = <span class="hljs-keyword">new</span> RealInterceptorChain(
        interceptors, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, originalRequest);
<span class="hljs-keyword">return</span> chain.proceed(originalRequest);</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li></ul> 
  <p>从方法名字基本可以猜到是干嘛的，调用 chain.proceed(originalRequest); 将request传递进来，从拦截器链里拿到返回结果。那么拦截器Interceptor是干嘛的，Chain是干嘛的呢？继续往下看RealInterceptorChain</p> 
  <p>RealInterceptorChain类</p> 
  <p>下面是RealInterceptorChain的定义，该类实现了Chain接口，在getResponseWithInterceptorChain调用时好几个参数都传的null。</p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealInterceptorChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span>.<span class="hljs-title">Chain</span> {<!-- --></span>

   <span class="hljs-keyword">public</span> <span class="hljs-title">RealInterceptorChain</span>(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,
        HttpCodec httpCodec, RealConnection connection, <span class="hljs-keyword">int</span> index, Request request) {
        <span class="hljs-keyword">this</span>.interceptors = interceptors;
        <span class="hljs-keyword">this</span>.connection = connection;
        <span class="hljs-keyword">this</span>.streamAllocation = streamAllocation;
        <span class="hljs-keyword">this</span>.httpCodec = httpCodec;
        <span class="hljs-keyword">this</span>.index = index;
        <span class="hljs-keyword">this</span>.request = request;
  }
  ......

 <span class="hljs-annotation">@Override</span> 
 <span class="hljs-keyword">public</span> Response <span class="hljs-title">proceed</span>(Request request) <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-keyword">return</span> proceed(request, streamAllocation, httpCodec, connection);
  }

  <span class="hljs-keyword">public</span> Response <span class="hljs-title">proceed</span>(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
      RealConnection connection) <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-keyword">if</span> (index &gt;= interceptors.size()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError();

    calls++;

    ......

    <span class="hljs-comment">// Call the next interceptor in the chain.</span>
    RealInterceptorChain next = <span class="hljs-keyword">new</span> RealInterceptorChain(
        interceptors, streamAllocation, httpCodec, connection, index + <span class="hljs-number">1</span>, request);
    Interceptor interceptor = interceptors.get(index);
    Response response = interceptor.intercept(next);

   ......

    <span class="hljs-keyword">return</span> response;
  }

  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span>();
}</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">12</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">13</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">14</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">15</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">16</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">17</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">18</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">19</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">20</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">21</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">22</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">23</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">24</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">25</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">26</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">27</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">28</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">29</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">30</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">31</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">32</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">33</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">34</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">35</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">36</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">37</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">38</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">39</li></ul> 
  <p>主要看proceed方法，proceed方法中判断index（此时为0）是否大于或者等于client.interceptors(List )的大小。由于httpStream为null，所以首先创建next拦截器链，主需要把索引置为index+1即可；然后获取第一个拦截器，调用其intercept方法。</p> 
  <p>Interceptor 代码如下：</p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs vbscript has-numbering"><span class="hljs-keyword">public</span> interface Interceptor {
  <span class="hljs-built_in">Response</span> intercept(Chain chain) throws IOException;

  interface Chain {
    <span class="hljs-built_in">Request</span> <span class="hljs-built_in">request</span>();

    <span class="hljs-built_in">Response</span> proceed(<span class="hljs-built_in">Request</span> <span class="hljs-built_in">request</span>) throws IOException;

    Connection connection();
  }
}</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li></ul> 
  <p>BridgeInterceptor</p> 
  <p>BridgeInterceptor从用户的请求构建网络请求，然后提交给网络，最后从网络响应中提取出用户响应。从最上面的图可以看出，BridgeInterceptor实现了适配的功能。下面是其intercept方法：</p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BridgeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> {<!-- --></span>
  ......

<span class="hljs-annotation">@Override</span> 
<span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span>(Chain chain) <span class="hljs-keyword">throws</span> IOException {
  Request userRequest = chain.request();
  Request.Builder requestBuilder = userRequest.newBuilder();

 RequestBody body = userRequest.body();
 <span class="hljs-comment">//如果存在请求主体部分，那么需要添加Content-Type、Content-Length首部</span>
 <span class="hljs-keyword">if</span> (body != <span class="hljs-keyword">null</span>) {
      MediaType contentType = body.contentType();
      <span class="hljs-keyword">if</span> (contentType != <span class="hljs-keyword">null</span>) {
        requestBuilder.header(<span class="hljs-string">"Content-Type"</span>, contentType.toString());
      }

      <span class="hljs-keyword">long</span> contentLength = body.contentLength();
      <span class="hljs-keyword">if</span> (contentLength != -<span class="hljs-number">1</span>) {
        requestBuilder.header(<span class="hljs-string">"Content-Length"</span>, Long.toString(contentLength));
        requestBuilder.removeHeader(<span class="hljs-string">"Transfer-Encoding"</span>);
      } <span class="hljs-keyword">else</span> {
        requestBuilder.header(<span class="hljs-string">"Transfer-Encoding"</span>, <span class="hljs-string">"chunked"</span>);
        requestBuilder.removeHeader(<span class="hljs-string">"Content-Length"</span>);
      }
    }

    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"Host"</span>) == <span class="hljs-keyword">null</span>) {
      requestBuilder.header(<span class="hljs-string">"Host"</span>, hostHeader(userRequest.url(), <span class="hljs-keyword">false</span>));
    }

    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"Connection"</span>) == <span class="hljs-keyword">null</span>) {
      requestBuilder.header(<span class="hljs-string">"Connection"</span>, <span class="hljs-string">"Keep-Alive"</span>);
    }

    <span class="hljs-comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span>
    <span class="hljs-comment">// the transfer stream.</span>
    <span class="hljs-keyword">boolean</span> transparentGzip = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"Accept-Encoding"</span>) == <span class="hljs-keyword">null</span> &amp;&amp; userRequest.header(<span class="hljs-string">"Range"</span>) == <span class="hljs-keyword">null</span>) {
      transparentGzip = <span class="hljs-keyword">true</span>;
      requestBuilder.header(<span class="hljs-string">"Accept-Encoding"</span>, <span class="hljs-string">"gzip"</span>);
    }

    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());
    <span class="hljs-keyword">if</span> (!cookies.isEmpty()) {
      requestBuilder.header(<span class="hljs-string">"Cookie"</span>, cookieHeader(cookies));
    }

  <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"User-Agent"</span>) == <span class="hljs-keyword">null</span>) {
      requestBuilder.header(<span class="hljs-string">"User-Agent"</span>, Version.userAgent());
  }

Response networkResponse = chain.proceed(requestBuilder.build());

HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());

Response.Builder responseBuilder = networkResponse.newBuilder()
        .request(userRequest);

    <span class="hljs-keyword">if</span> (transparentGzip
        &amp;&amp; <span class="hljs-string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="hljs-string">"Content-Encoding"</span>))
        &amp;&amp; HttpHeaders.hasBody(networkResponse)) {
      GzipSource responseBody = <span class="hljs-keyword">new</span> GzipSource(networkResponse.body().source());
      Headers strippedHeaders = networkResponse.headers().newBuilder()
          .removeAll(<span class="hljs-string">"Content-Encoding"</span>)
          .removeAll(<span class="hljs-string">"Content-Length"</span>)
          .build();
      responseBuilder.headers(strippedHeaders);
      responseBuilder.body(<span class="hljs-keyword">new</span> RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));
    }

    <span class="hljs-keyword">return</span> responseBuilder.build();
  }

  <span class="hljs-javadoc">/** Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}. */</span>
  <span class="hljs-keyword">private</span> String <span class="hljs-title">cookieHeader</span>(List&lt;Cookie&gt; cookies) {
    StringBuilder cookieHeader = <span class="hljs-keyword">new</span> StringBuilder();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = cookies.size(); i &lt; size; i++) {
      <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) {
        cookieHeader.append(<span class="hljs-string">"; "</span>);
      }
      Cookie cookie = cookies.get(i);
      cookieHeader.append(cookie.name()).append(<span class="hljs-string">'='</span>).append(cookie.value());
    }
    <span class="hljs-keyword">return</span> cookieHeader.toString();
  }
}</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">12</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">13</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">14</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">15</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">16</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">17</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">18</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">19</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">20</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">21</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">22</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">23</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">24</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">25</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">26</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">27</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">28</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">29</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">30</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">31</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">32</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">33</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">34</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">35</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">36</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">37</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">38</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">39</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">40</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">41</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">42</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">43</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">44</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">45</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">46</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">47</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">48</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">49</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">50</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">51</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">52</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">53</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">54</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">55</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">56</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">57</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">58</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">59</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">60</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">61</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">62</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">63</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">64</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">65</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">66</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">67</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">68</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">69</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">70</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">71</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">72</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">73</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">74</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">75</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">76</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">77</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">78</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">79</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">80</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">81</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">82</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">83</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">84</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">85</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">86</li></ul> 
  <p>从上面的代码可以看出，首先获取原请求，然后在请求中添加头，比如Host、Connection、Accept-Encoding参数等，然后根据看是否需要填充Cookie，在对原始请求做出处理后，使用chain的procced方法得到响应，接下来对响应做处理得到用户响应，最后返回响应。接下来再看下一个拦截器ConnectInterceptor的处理。</p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs java has-numbering"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> {<!-- --></span>
  ......

 <span class="hljs-annotation">@Override</span> 
 <span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span>(Chain chain) <span class="hljs-keyword">throws</span> IOException {
 RealInterceptorChain realChain = (RealInterceptorChain) chain;
Request request = realChain.request();
StreamAllocation streamAllocation = realChain.streamAllocation();

 <span class="hljs-comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span>
 <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="hljs-string">"GET"</span>);
 HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);
 RealConnection connection = streamAllocation.connection();

 <span class="hljs-keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);
  }
}</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">12</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">13</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">14</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">15</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">16</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">17</li></ul> 
  <p>实际上建立连接就是创建了一个 HttpCodec 对象，它利用 Okio 对 Socket 的读写操作进行封装，Okio 以后有机会再进行分析，现在让我们对它们保持一个简单地认识：它对 java.io 和 java.nio 进行了封装，让我们更便捷高效的进行 IO 操作。</p> 
  <p>CallServerInterceptor</p> 
  <p>CallServerInterceptor是拦截器链中最后一个拦截器，负责将网络请求提交给服务器。它的intercept方法实现如下：</p> 
  <pre class="prettyprint" style="font-size:14px;line-height:22px;"><code class="hljs d has-numbering"><span class="hljs-keyword">@Override</span> 
<span class="hljs-keyword">public</span> Response intercept(Chain chain) throws IOException {
    RealInterceptorChain realChain = (RealInterceptorChain) chain;
    HttpCodec httpCodec = realChain.httpStream();
    StreamAllocation streamAllocation = realChain.streamAllocation();
    RealConnection connection = (RealConnection) realChain.connection();
    Request request = realChain.request();

    <span class="hljs-built_in">long</span> sentRequestMillis = System.currentTimeMillis();
    httpCodec.writeRequestHeaders(request);

    Response.Builder responseBuilder = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.<span class="hljs-keyword">body</span>() != <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100</span>
      <span class="hljs-comment">// Continue" response before transmitting the request body. If we don't get that, return what</span>
      <span class="hljs-comment">// we did get (such as a 4xx response) without ever transmitting the request body.</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="hljs-string">"Expect"</span>))) {
        httpCodec.flushRequest();
        responseBuilder = httpCodec.readResponseHeaders(<span class="hljs-literal">true</span>);
      }

      <span class="hljs-keyword">if</span> (responseBuilder == <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span>
        Sink requestBodyOut = httpCodec.createRequestBody(request, request.<span class="hljs-keyword">body</span>().contentLength());
        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
        request.<span class="hljs-keyword">body</span>().writeTo(bufferedRequestBody);
        bufferedRequestBody.close();
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!connection.isMultiplexed()) {
        <span class="hljs-comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection from</span>
        <span class="hljs-comment">// being reused. Otherwise we're still obligated to transmit the request body to leave the</span>
        <span class="hljs-comment">// connection in a consistent state.</span>
        streamAllocation.noNewStreams();
      }
    }

    httpCodec.finishRequest();

    <span class="hljs-keyword">if</span> (responseBuilder == <span class="hljs-literal">null</span>) {
      responseBuilder = httpCodec.readResponseHeaders(<span class="hljs-literal">false</span>);
    }

    Response response = responseBuilder
        .request(request)
        .handshake(streamAllocation.connection().handshake())
        .sentRequestAtMillis(sentRequestMillis)
        .receivedResponseAtMillis(System.currentTimeMillis())
        .build();

    <span class="hljs-keyword">int</span> code = response.code();
    <span class="hljs-keyword">if</span> (forWebSocket &amp;&amp; code == <span class="hljs-number">101</span>) {
      <span class="hljs-comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span>
      response = response.newBuilder()
          .<span class="hljs-keyword">body</span>(Util.EMPTY_RESPONSE)
          .build();
    } <span class="hljs-keyword">else</span> {
      response = response.newBuilder()
          .<span class="hljs-keyword">body</span>(httpCodec.openResponseBody(response))
          .build();
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="hljs-string">"Connection"</span>))
        || <span class="hljs-string">"close"</span>.equalsIgnoreCase(response.header(<span class="hljs-string">"Connection"</span>))) {
      streamAllocation.noNewStreams();
    }

    <span class="hljs-keyword">if</span> ((code == <span class="hljs-number">204</span> || code == <span class="hljs-number">205</span>) &amp;&amp; response.<span class="hljs-keyword">body</span>().contentLength() &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ProtocolException(
          <span class="hljs-string">"HTTP "</span> + code + <span class="hljs-string">" had non-zero Content-Length: "</span> + response.<span class="hljs-keyword">body</span>().contentLength());
    }

    <span class="hljs-keyword">return</span> response;
  }</code></pre> 
  <ul class="pre-numbering"><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">1</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">2</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">3</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">4</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">5</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">6</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">7</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">8</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">9</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">10</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">11</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">12</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">13</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">14</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">15</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">16</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">17</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">18</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">19</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">20</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">21</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">22</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">23</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">24</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">25</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">26</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">27</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">28</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">29</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">30</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">31</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">32</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">33</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">34</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">35</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">36</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">37</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">38</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">39</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">40</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">41</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">42</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">43</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">44</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">45</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">46</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">47</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">48</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">49</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">50</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">51</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">52</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">53</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">54</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">55</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">56</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">57</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">58</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">59</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">60</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">61</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">62</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">63</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">64</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">65</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">66</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">67</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">68</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">69</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">70</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">71</li><li style="padding-right:8px;padding-left:8px;color:rgb(153,153,153);">72</li></ul> 
  <p>从上面的代码中可以看出，首先获取HttpStream对象，然后调用writeRequestHeaders方法写入请求的头部，然后判断是否需要写入请求的body部分，最后调用finishRequest()方法将所有数据刷新给底层的Socket，接下来尝试调用readResponseHeaders()方法读取响应的头部，然后再调用openResponseBody()方法得到响应的body部分，最后返回响应。</p> 
  <h4 style="padding:0px;">最后总结</h4> 
  <p>OkHttp的底层是通过Java的Socket发送HTTP请求与接受响应的(这也好理解，HTTP就是基于TCP协议的)，但是OkHttp实现了连接池的概念，即对于同一主机的多个请求，其实可以公用一个Socket连接，而不是每次发送完HTTP请求就关闭底层的Socket，这样就实现了连接池的概念。而OkHttp对Socket的读写操作使用的OkIo库进行了一层封装。</p> 
  <p><img src="https://images2.imgbox.com/a3/4d/Q8z5C7p9_o.png" alt="" title="" style="margin-top:24px;margin-bottom:24px;"></p> 
 </div> 
</div> 
<div class="article-bar-bottom" style="padding:0px 0px 16px;margin:36px 0px 0px;border-bottom:1px solid rgb(227,227,227);color:rgb(51,51,51);font-family:'SF Pro Display', Roboto, Noto, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;font-size:14px;"> 
 <div class="article-copyright" style="padding:0px;margin:0px;font-size:12px;color:rgb(153,153,153);">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/mwq384807683/article/details/71173442 
 </div> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/41645f15158b0a2202e590cb4205d5a3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ConstraintLayout 中 Barrier的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1a73641c7a75009e0a34ebaea29f6859/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用canvas将照片和海报边框图片合成海报的移动端例子</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>