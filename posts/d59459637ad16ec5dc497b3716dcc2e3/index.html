<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>在线matlab代码学习神器Octave Online - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="在线matlab代码学习神器Octave Online" />
<meta property="og:description" content="Octave与MATLAB完全兼容，免安装使用方便。注册和非注册功能会有不同，如下：
未注册，功能简洁：
注册后，功能全面：
心动不如行动，赶快试试看~
附录：
Octave Online: Free Interface compatible with MATLAB官方网址
答疑部分：
留言提问请参考文档：
Simple File I/O
The save and load commands allow data to be written to and read from disk files in various formats. The default format of files written by the save command can be controlled using the functionssave_default_options and save_precision.
As an example the following code creates a 3-by-3 matrix and saves it to the file ‘myfile." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/d59459637ad16ec5dc497b3716dcc2e3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-12T17:19:28+08:00" />
<meta property="article:modified_time" content="2018-03-12T17:19:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">在线matlab代码学习神器Octave Online</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Octave与MATLAB完全兼容，免安装使用方便。注册和非注册功能会有不同，如下：</p> 
<p>未注册，功能简洁：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/26/f7/xFIccafF_o.jpg"></p> 
<p>注册后，功能全面：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/8b/34/UmFSVvpP_o.jpg"></p> 
<p>心动不如行动，赶快试试看~</p> 
<p>附录：</p> 
<p><a href="https://octave-online.net/" rel="nofollow">Octave Online: Free Interface compatible with MATLAB官方网址</a></p> 
<p>答疑部分：</p> 
<p>留言提问请参考文档：</p> 
<p>Simple File I/O</p> 
<p><a name="index-saving-data"></a><a name="index-loading-data"></a></p> 
<p>The <code>save</code> and <code>load</code> commands allow data to be written to and read from disk files in various formats. The default format of files written by the <code>save</code> command can be controlled using the functions<code>save_default_options</code> and <code>save_precision</code>.</p> 
<p>As an example the following code creates a 3-by-3 matrix and saves it to the file ‘myfile.mat’.</p> 
<pre>A = [ 1:3; 4:6; 7:9 ];
save myfile.mat A
</pre> 
<p>Once one or more variables have been saved to a file, they can be read into memory using the <code>load</code>command.</p> 
<pre>load myfile.mat
A
     -| A =
     -|
     -|    1   2   3
     -|    4   5   6
     -|    7   8   9
</pre> 
<p><a name="XREFsave"></a></p> 
<p><a name="index-save"></a><strong>save</strong> <em>file</em></p> 
<p><a name="index-save-1"></a><strong>save</strong> <em>options file</em></p> 
<p><a name="index-save-2"></a><strong>save</strong> <em>options file v1 v2 …</em></p> 
<p><a name="index-save-3"></a><strong>save</strong> <em>options file -struct STRUCT</em></p> 
<p><a name="index-save-4"></a><strong>save</strong> <em>options file -struct STRUCT f1 f2 …</em></p> 
<p><a name="index-save-5"></a><strong>save</strong> <em>- v1 v2 …</em></p> 
<p><a name="index-save-6"></a><em>str =</em> <strong>save</strong> <em>("-", <code>"v1"</code>, <code>"v2"</code>, …)</em></p> 
<p>Save the named variables v1, v2, …, in the file file.</p> 
<p>The special filename ‘-’ may be used to return the content of the variables as a string. If no variable names are listed, Octave saves all the variables in the current scope. Otherwise, full variable names or pattern syntax can be used to specify the variables to save. If the -struct modifier is used then the fields of the <strong>scalar</strong> struct are saved as if they were variables with the corresponding field names. The -struct option can be combined with specific field names f1, f2, … to write only certain fields to the file.</p> 
<p>Valid options for the <code>save</code> command are listed in the following table. Options that modify the output format override the format specified by <code>save_default_options</code>.</p> 
<p>If save is invoked using the functional form</p> 
<pre>save ("-option1", …, "file", "v1", …)
</pre> 
<p>then the options, file, and variable name arguments (v1, …) must be specified as character strings.</p> 
<p>If called with a filename of <code>"-"</code>, write the output to stdout if nargout is 0, otherwise return the output in a character string.</p> 
<p><code>-append</code></p> 
<p>Append to the destination instead of overwriting.</p> 
<p><code>-ascii</code></p> 
<p>Save a matrix in a text file without a header or any other information. The matrix must be 2-D and only the real part of any complex value is written to the file. Numbers are stored in single-precision format and separated by spaces. Additional options for the -ascii format are</p> 
<p><code>-double</code></p> 
<p>Store numbers in double-precision format.</p> 
<p><code>-tabs</code></p> 
<p>Separate numbers with tabs.</p> 
<p><code>-binary</code></p> 
<p>Save the data in Octave’s binary data format.</p> 
<p><code>-float-binary</code></p> 
<p>Save the data in Octave’s binary data format but using only single precision. Use this format <strong>only</strong> if you know that all the values to be saved can be represented in single precision.</p> 
<p><code>-hdf5</code></p> 
<p>Save the data in HDF5 format. (HDF5 is a free, portable, binary format developed by the National Center for Supercomputing Applications at the University of Illinois.) This format is only available if Octave was built with a link to the HDF5 libraries.</p> 
<p><code>-float-hdf5</code></p> 
<p>Save the data in HDF5 format but using only single precision. Use this format <strong>only</strong> if you know that all the values to be saved can be represented in single precision.</p> 
<p><code>-V7</code></p> 
<p><code>-v7</code></p> 
<p><code>-7</code></p> 
<p><code>-mat7-binary</code></p> 
<p>Save the data in MATLAB’s v7 binary data format.</p> 
<p><code>-V6</code></p> 
<p><code>-v6</code></p> 
<p><code>-6</code></p> 
<p><code>-mat</code></p> 
<p><code>-mat-binary</code></p> 
<p>Save the data in MATLAB’s v6 binary data format.</p> 
<p><code>-V4</code></p> 
<p><code>-v4</code></p> 
<p><code>-4</code></p> 
<p><code>-mat4-binary</code></p> 
<p>Save the data in the binary format written by MATLAB version 4.</p> 
<p><code>-text</code></p> 
<p>Save the data in Octave’s text data format. (default).</p> 
<p><code>-zip</code></p> 
<p><code>-z</code></p> 
<p>Use the gzip algorithm to compress the file. This works on files that are compressed with gzip outside of Octave, and gzip can also be used to convert the files for backward compatibility. This option is only available if Octave was built with a link to the zlib libraries.</p> 
<p>The list of variables to save may use wildcard patterns containing the following special characters:</p> 
<p><code>?</code></p> 
<p>Match any single character.</p> 
<p><code>*</code></p> 
<p>Match zero or more characters.</p> 
<p><code>[ list ]</code></p> 
<p>Match the list of characters specified by list. If the first character is <code>!</code> or <code>^</code>, match all characters except those specified by list. For example, the pattern <code>[a-zA-Z]</code> will match all lower and uppercase alphabetic characters.</p> 
<p>Wildcards may also be used in the field name specifications when using the -structmodifier (but not in the struct name itself).</p> 
<p>Except when using the MATLAB binary data file format or the ‘-ascii’ format, saving global variables also saves the global status of the variable. If the variable is restored at a later time using ‘load’, it will be restored as a global variable.</p> 
<p>The command</p> 
<pre>save -binary data a b*
</pre> 
<p>saves the variable ‘a’ and all variables beginning with ‘b’ to the file data in Octave’s binary format.</p> 
<p><strong>See also:</strong> <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFload" rel="nofollow">load</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFsave_005fdefault_005foptions" rel="nofollow">save_default_options</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFsave_005fheader_005fformat_005fstring" rel="nofollow">save_header_format_string</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFsave_005fprecision" rel="nofollow">save_precision</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFdlmread" rel="nofollow">dlmread</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFcsvread" rel="nofollow">csvread</a>, <a href="https://octave.org/doc/interpreter/Binary-I_002fO.html#XREFfread" rel="nofollow">fread</a>.</p> 
<p>There are three functions that modify the behavior of <code>save</code>.</p> 
<p><a name="XREFsave_005fdefault_005foptions"></a></p> 
<p><a name="index-save_005fdefault_005foptions"></a><em>val =</em> <strong>save_default_options</strong> <em>()</em></p> 
<p><a name="index-save_005fdefault_005foptions-1"></a><em>old_val =</em> <strong>save_default_options</strong> <em>(new_val)</em></p> 
<p><a name="index-save_005fdefault_005foptions-2"></a><strong>save_default_options</strong> <em>(new_val, "local")</em></p> 
<p>Query or set the internal variable that specifies the default options for the <code>save</code> command, and defines the default format.</p> 
<p>The default value is <code>"-text"</code> (Octave’s own text-based file format). See the documentation of the <code>save</code> command for other choices.</p> 
<p>When called from inside a function with the <code>"local"</code> option, the variable is changed locally for the function and any subroutines it calls. The original variable value is restored when exiting the function.</p> 
<p><strong>See also:</strong> <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFsave" rel="nofollow">save</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFsave_005fheader_005fformat_005fstring" rel="nofollow">save_header_format_string</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFsave_005fprecision" rel="nofollow">save_precision</a>.</p> 
<p><a name="XREFsave_005fprecision"></a></p> 
<p><a name="index-save_005fprecision"></a><em>val =</em> <strong>save_precision</strong> <em>()</em></p> 
<p><a name="index-save_005fprecision-1"></a><em>old_val =</em> <strong>save_precision</strong> <em>(new_val)</em></p> 
<p><a name="index-save_005fprecision-2"></a><strong>save_precision</strong> <em>(new_val, "local")</em></p> 
<p>Query or set the internal variable that specifies the number of digits to keep when saving data in text format.</p> 
<p>The default value is 17 which is the minimum necessary for the lossless saving and restoring of IEEE-754 double values; For IEEE-754 single values the minimum value is 9. If file size is a concern, it is probably better to choose a binary format for saving data rather than to reduce the precision of the saved values.</p> 
<p>When called from inside a function with the <code>"local"</code> option, the variable is changed locally for the function and any subroutines it calls. The original variable value is restored when exiting the function.</p> 
<p><strong>See also:</strong> <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFsave_005fdefault_005foptions" rel="nofollow">save_default_options</a>.</p> 
<p><a name="XREFsave_005fheader_005fformat_005fstring"></a></p> 
<p><a name="index-save_005fheader_005fformat_005fstring"></a><em>val =</em> <strong>save_header_format_string</strong> <em>()</em></p> 
<p><a name="index-save_005fheader_005fformat_005fstring-1"></a><em>old_val =</em> <strong>save_header_format_string</strong> <em>(new_val)</em></p> 
<p><a name="index-save_005fheader_005fformat_005fstring-2"></a><strong>save_header_format_string</strong> <em>(new_val, "local")</em></p> 
<p>Query or set the internal variable that specifies the format string used for the comment line written at the beginning of text-format data files saved by Octave.</p> 
<p>The format string is passed to <code>strftime</code> and must begin with the character ‘#’ and contain no newline characters. If the value of <code>save_header_format_string</code> is the empty string, the header comment is omitted from text-format data files. The default value is</p> 
<pre>"# Created by Octave VERSION, %a %b %d %H:%M:%S %Y %Z &lt;USER@HOST&gt;"
</pre> 
<p>When called from inside a function with the <code>"local"</code> option, the variable is changed locally for the function and any subroutines it calls. The original variable value is restored when exiting the function.</p> 
<p><strong>See also:</strong> <a href="https://octave.org/doc/interpreter/Timing-Utilities.html#XREFstrftime" rel="nofollow">strftime</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFsave_005fdefault_005foptions" rel="nofollow">save_default_options</a>.</p> 
<p><a name="XREFload"></a></p> 
<p><a name="index-load"></a><strong>load</strong> <em>file</em></p> 
<p><a name="index-load-1"></a><strong>load</strong> <em>options file</em></p> 
<p><a name="index-load-2"></a><strong>load</strong> <em>options file v1 v2 …</em></p> 
<p><a name="index-load-3"></a><em>S =</em> <strong>load</strong> <em>("options", "file", "v1", "v2", …)</em></p> 
<p><a name="index-load-4"></a><strong>load</strong> <em>file options</em></p> 
<p><a name="index-load-5"></a><strong>load</strong> <em>file options v1 v2 …</em></p> 
<p><a name="index-load-6"></a><em>S =</em> <strong>load</strong> <em>("file", "options", "v1", "v2", …)</em></p> 
<p>Load the named variables v1, v2, …, from the file file.</p> 
<p>If no variables are specified then all variables found in the file will be loaded. As with <code>save</code>, the list of variables to extract can be full names or use a pattern syntax. The format of the file is automatically detected but may be overridden by supplying the appropriate option.</p> 
<p>If load is invoked using the functional form</p> 
<pre>load ("-option1", …, "file", "v1", …)
</pre> 
<p>then the options, file, and variable name arguments (v1, …) must be specified as character strings.</p> 
<p>If a variable that is not marked as global is loaded from a file when a global symbol with the same name already exists, it is loaded in the global symbol table. Also, if a variable is marked as global in a file and a local symbol exists, the local symbol is moved to the global symbol table and given the value from the file.</p> 
<p>If invoked with a single output argument, Octave returns data instead of inserting variables in the symbol table. If the data file contains only numbers (TAB- or space-delimited columns), a matrix of values is returned. Otherwise, <code>load</code> returns a structure with members corresponding to the names of the variables in the file.</p> 
<p>The <code>load</code> command can read data stored in Octave’s text and binary formats, and MATLAB’s binary format. If compiled with zlib support, it can also load gzip-compressed files. It will automatically detect the type of file and do conversion from different floating point formats (currently only IEEE big and little endian, though other formats may be added in the future).</p> 
<p>Valid options for <code>load</code> are listed in the following table.</p> 
<p><code>-force</code></p> 
<p>This option is accepted for backward compatibility but is ignored. Octave now overwrites variables currently in memory with those of the same name found in the file.</p> 
<p><code>-ascii</code></p> 
<p>Force Octave to assume the file contains columns of numbers in text format without any header or other information. Data in the file will be loaded as a single numeric matrix with the name of the variable derived from the name of the file.</p> 
<p><code>-binary</code></p> 
<p>Force Octave to assume the file is in Octave’s binary format.</p> 
<p><code>-hdf5</code></p> 
<p>Force Octave to assume the file is in HDF5 format. (HDF5 is a free, portable binary format developed by the National Center for Supercomputing Applications at the University of Illinois.) Note that Octave can read HDF5 files not created by itself, but may skip some datasets in formats that it cannot support. This format is only available if Octave was built with a link to the HDF5 libraries.</p> 
<p><code>-import</code></p> 
<p>This option is accepted for backward compatibility but is ignored. Octave can now support multi-dimensional HDF data and automatically modifies variable names if they are invalid Octave identifiers.</p> 
<p><code>-mat</code></p> 
<p><code>-mat-binary</code></p> 
<p><code>-6</code></p> 
<p><code>-v6</code></p> 
<p><code>-7</code></p> 
<p><code>-v7</code></p> 
<p>Force Octave to assume the file is in MATLAB’s version 6 or 7 binary format.</p> 
<p><code>-mat4-binary</code></p> 
<p><code>-4</code></p> 
<p><code>-v4</code></p> 
<p><code>-V4</code></p> 
<p>Force Octave to assume the file is in the binary format written by MATLAB version 4.</p> 
<p><code>-text</code></p> 
<p>Force Octave to assume the file is in Octave’s text format.</p> 
<p><strong>See also:</strong> <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFsave" rel="nofollow">save</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFdlmwrite" rel="nofollow">dlmwrite</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFcsvwrite" rel="nofollow">csvwrite</a>, <a href="https://octave.org/doc/interpreter/Binary-I_002fO.html#XREFfwrite" rel="nofollow">fwrite</a>.</p> 
<p><a name="XREFfileread"></a></p> 
<p><a name="index-fileread"></a><em>str =</em> <strong>fileread</strong> <em>(filename)</em></p> 
<p>Read the contents of filename and return it as a string.</p> 
<p><strong>See also:</strong> <a href="https://octave.org/doc/interpreter/Binary-I_002fO.html#XREFfread" rel="nofollow">fread</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFtextread" rel="nofollow">textread</a>, <a href="https://octave.org/doc/interpreter/Formatted-Input.html#XREFsscanf" rel="nofollow">sscanf</a>.</p> 
<p><a name="XREFnative_005ffloat_005fformat"></a></p> 
<p><a name="index-native_005ffloat_005fformat"></a><strong>native_float_format</strong> <em>()</em></p> 
<p>Return the native floating point format as a string.</p> 
<p>It is possible to write data to a file in a similar way to the <code>disp</code> function for writing data to the screen. The <code>fdisp</code> works just like <code>disp</code> except its first argument is a file pointer as created by <code>fopen</code>. As an example, the following code writes to data ‘myfile.txt’.</p> 
<pre>fid = fopen ("myfile.txt", "w");
fdisp (fid, "3/8 is ");
fdisp (fid, 3/8);
fclose (fid);
</pre> 
<p>See <a href="https://octave.org/doc/interpreter/Opening-and-Closing-Files.html#Opening-and-Closing-Files" rel="nofollow">Opening and Closing Files</a>, for details on how to use <code>fopen</code> and <code>fclose</code>.</p> 
<p><a name="XREFfdisp"></a></p> 
<p><a name="index-fdisp"></a><strong>fdisp</strong> <em>(fid, x)</em></p> 
<p>Display the value of x on the stream fid.</p> 
<p>For example:</p> 
<pre>fdisp (stdout, "The value of pi is:"), fdisp (stdout, pi)

     -| the value of pi is:
     -| 3.1416
</pre> 
<p>Note that the output from <code>fdisp</code> always ends with a newline.</p> 
<p><strong>See also:</strong> <a href="https://octave.org/doc/interpreter/Terminal-Output.html#XREFdisp" rel="nofollow">disp</a>.</p> 
<p>Octave can also read and write matrices text files such as comma separated lists.</p> 
<p><a name="XREFdlmwrite"></a></p> 
<p><a name="index-dlmwrite"></a><strong>dlmwrite</strong> <em>(file, M)</em></p> 
<p><a name="index-dlmwrite-1"></a><strong>dlmwrite</strong> <em>(file, M, delim, r, c)</em></p> 
<p><a name="index-dlmwrite-2"></a><strong>dlmwrite</strong> <em>(file, M, key, val …)</em></p> 
<p><a name="index-dlmwrite-3"></a><strong>dlmwrite</strong> <em>(file, M, "-append", …)</em></p> 
<p><a name="index-dlmwrite-4"></a><strong>dlmwrite</strong> <em>(fid, …)</em></p> 
<p>Write the numeric matrix M to the text file file using a delimiter.</p> 
<p>file should be a filename or a writable file ID given by <code>fopen</code>.</p> 
<p>The parameter delim specifies the delimiter to use to separate values on a row. If no delimiter is specified the comma character ‘,’ is used.</p> 
<p>The value of r specifies the number of delimiter-only lines to add to the start of the file.</p> 
<p>The value of c specifies the number of delimiters to prepend to each line of data.</p> 
<p>If the argument <code>"-append"</code> is given, append to the end of file.</p> 
<p>In addition, the following keyword value pairs may appear at the end of the argument list:</p> 
<p><code>"append"</code></p> 
<p>Either <code>"on"</code> or <code>"off"</code>. See <code>"-append"</code> above.</p> 
<p><code>"delimiter"</code></p> 
<p>See delim above.</p> 
<p><code>"newline"</code></p> 
<p>The character(s) to separate each row. Three special cases exist for this option. <code>"unix"</code> is changed into <code>"\n"</code>, <code>"pc"</code> is changed into <code>"\r\n"</code>, and <code>"mac"</code> is changed into <code>"\r"</code>. Any other value is used directly as the newline separator.</p> 
<p><code>"roffset"</code></p> 
<p>See r above.</p> 
<p><code>"coffset"</code></p> 
<p>See c above.</p> 
<p><code>"precision"</code></p> 
<p>The precision to use when writing the file. It can either be a format string (as used by fprintf) or a number of significant digits.</p> 
<pre>dlmwrite ("file.csv", reshape (1:16, 4, 4));
</pre> 
<pre>dlmwrite ("file.tex", a, "delimiter", "&amp;", "newline", "\n")
</pre> 
<p><strong>See also:</strong> <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFdlmread" rel="nofollow">dlmread</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFcsvread" rel="nofollow">csvread</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFcsvwrite" rel="nofollow">csvwrite</a>.</p> 
<p><a name="XREFdlmread"></a></p> 
<p><a name="index-dlmread"></a><em>data =</em> <strong>dlmread</strong> <em>(file)</em></p> 
<p><a name="index-dlmread-1"></a><em>data =</em> <strong>dlmread</strong> <em>(file, sep)</em></p> 
<p><a name="index-dlmread-2"></a><em>data =</em> <strong>dlmread</strong> <em>(file, sep, r0, c0)</em></p> 
<p><a name="index-dlmread-3"></a><em>data =</em> <strong>dlmread</strong> <em>(file, sep, range)</em></p> 
<p><a name="index-dlmread-4"></a><em>data =</em> <strong>dlmread</strong> <em>(…, "emptyvalue", EMPTYVAL)</em></p> 
<p>Read numeric data from the text file file which uses the delimiter sep between data values.</p> 
<p>If sep is not defined the separator between fields is determined from the file itself.</p> 
<p>The optional scalar arguments r0 and c0 define the starting row and column of the data to be read. These values are indexed from zero, i.e., the first data row corresponds to an index of zero.</p> 
<p>The range parameter specifies exactly which data elements are read. The first form of the parameter is a 4-element vector containing the upper left and lower right corners <code>[R0,C0,R1,C1]</code> where the indices are zero-based. Alternatively, a spreadsheet style form such as <code>"A2..Q15"</code> or <code>"T1:AA5"</code> can be used. The lowest alphabetical index <code>'A'</code> refers to the first column. The lowest row index is 1.</p> 
<p>file should be a filename or a file id given by <code>fopen</code>. In the latter case, the file is read until end of file is reached.</p> 
<p>The <code>"emptyvalue"</code> option may be used to specify the value used to fill empty fields. The default is zero. Note that any non-numeric values, such as text, are also replaced by the <code>"emptyvalue"</code>.</p> 
<p><strong>See also:</strong> <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFcsvread" rel="nofollow">csvread</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFtextscan" rel="nofollow">textscan</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFtextread" rel="nofollow">textread</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFdlmwrite" rel="nofollow">dlmwrite</a>.</p> 
<p><a name="XREFcsvwrite"></a></p> 
<p><a name="index-csvwrite"></a><strong>csvwrite</strong> <em>(filename, x)</em></p> 
<p><a name="index-csvwrite-1"></a><strong>csvwrite</strong> <em>(filename, x, dlm_opt1, …)</em></p> 
<p>Write the numeric matrix x to the file filename in comma-separated-value (CSV) format.</p> 
<p>This function is equivalent to</p> 
<pre>dlmwrite (filename, x, ",", dlm_opt1, …)
</pre> 
<p>Any optional arguments are passed directly to <code>dlmwrite</code> (see <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFdlmwrite" rel="nofollow">dlmwrite</a>).</p> 
<p><strong>See also:</strong> <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFcsvread" rel="nofollow">csvread</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFdlmwrite" rel="nofollow">dlmwrite</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFdlmread" rel="nofollow">dlmread</a>.</p> 
<p><a name="XREFcsvread"></a></p> 
<p><a name="index-csvread"></a><em>x =</em> <strong>csvread</strong> <em>(filename)</em></p> 
<p><a name="index-csvread-1"></a><em>x =</em> <strong>csvread</strong> <em>(filename, dlm_opt1, …)</em></p> 
<p>Read the comma-separated-value (CSV) file filename into the matrix x.</p> 
<p>Note: only CSV files containing numeric data can be read.</p> 
<p>This function is equivalent to</p> 
<pre>x = dlmread (filename, "," , dlm_opt1, …)
</pre> 
<p>Any optional arguments are passed directly to <code>dlmread</code> (see <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFdlmread" rel="nofollow">dlmread</a>).</p> 
<p><strong>See also:</strong> <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFdlmread" rel="nofollow">dlmread</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFtextread" rel="nofollow">textread</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFtextscan" rel="nofollow">textscan</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFcsvwrite" rel="nofollow">csvwrite</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFdlmwrite" rel="nofollow">dlmwrite</a>.</p> 
<p>Formatted data from can be read from, or written to, text files as well.</p> 
<p><a name="XREFtextread"></a></p> 
<p><a name="index-textread"></a><em>[a, …] =</em> <strong>textread</strong> <em>(filename)</em></p> 
<p><a name="index-textread-1"></a><em>[a, …] =</em> <strong>textread</strong> <em>(filename, format)</em></p> 
<p><a name="index-textread-2"></a><em>[a, …] =</em> <strong>textread</strong> <em>(filename, format, n)</em></p> 
<p><a name="index-textread-3"></a><em>[a, …] =</em> <strong>textread</strong> <em>(filename, format, prop1, value1, …)</em></p> 
<p><a name="index-textread-4"></a><em>[a, …] =</em> <strong>textread</strong> <em>(filename, format, n, prop1, value1, …)</em></p> 
<p>Read data from a text file.</p> 
<p>The file filename is read and parsed according to format. The function behaves like <code>strread</code>except it works by parsing a file instead of a string. See the documentation of <code>strread</code> for details.</p> 
<p>In addition to the options supported by <code>strread</code>, this function supports two more:</p> 
<ul><li><code>"headerlines"</code>: The first value number of lines of filename are skipped.</li><li><code>"endofline"</code>: Specify a single character or <code>"\r\n"</code>. If no value is given, it will be inferred from the file. If set to <code>""</code> (empty string) EOLs are ignored as delimiters.</li></ul> 
<p>The optional input n (format repeat count) specifies the number of times the format string is to be used or the number of lines to be read, whichever happens first while reading. The former is equivalent to requesting that the data output vectors should be of length N. Note that when reading files with format strings referring to multiple lines, n should rather be the number of lines to be read than the number of format string uses.</p> 
<p>If the format string is empty (not just omitted) and the file contains only numeric data (excluding headerlines), textread will return a rectangular matrix with the number of columns matching the number of numeric fields on the first data line of the file. Empty fields are returned as zero values.</p> 
<p>Examples:</p> 
<pre>  Assume a data file like:
  1 a 2 b
  3 c 4 d
  5 e
</pre> 
<pre>  [a, b] = textread (f, "%f %s")
  returns two columns of data, one with doubles, the other a
  cellstr array:
  a = [1; 2; 3; 4; 5]
  b = {"a"; "b"; "c"; "d"; "e"}
</pre> 
<pre>  [a, b] = textread (f, "%f %s", 3)
  (read data into two culumns, try to use the format string
  three times)
  returns
  a = [1; 2; 3]
  b = {"a"; "b"; "c"}

</pre> 
<pre>  With a data file like:
  1
  a
  2
  b

  [a, b] = textread (f, "%f %s", 2)
  returns a = 1 and b = {"a"}; i.e., the format string is used
  only once because the format string refers to 2 lines of the
  data file.  To obtain 2x1 data output columns, specify N = 4
  (number of data lines containing all requested data) rather
  than 2.
</pre> 
<p><strong>See also:</strong> <a href="https://octave.org/doc/interpreter/Manipulating-Strings.html#XREFstrread" rel="nofollow">strread</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFload" rel="nofollow">load</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFdlmread" rel="nofollow">dlmread</a>, <a href="https://octave.org/doc/interpreter/Formatted-Input.html#XREFfscanf" rel="nofollow">fscanf</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFtextscan" rel="nofollow">textscan</a>.</p> 
<p><a name="XREFtextscan"></a></p> 
<p><a name="index-textscan"></a><em>C =</em> <strong>textscan</strong> <em>(fid, format)</em></p> 
<p><a name="index-textscan-1"></a><em>C =</em> <strong>textscan</strong> <em>(fid, format, repeat)</em></p> 
<p><a name="index-textscan-2"></a><em>C =</em> <strong>textscan</strong> <em>(fid, format, param, value, …)</em></p> 
<p><a name="index-textscan-3"></a><em>C =</em> <strong>textscan</strong> <em>(fid, format, repeat, param, value, …)</em></p> 
<p><a name="index-textscan-4"></a><em>C =</em> <strong>textscan</strong> <em>(str, …)</em></p> 
<p><a name="index-textscan-5"></a><em>[C, position, errmsg] =</em> <strong>textscan</strong> <em>(…)</em></p> 
<p>Read data from a text file or string.</p> 
<p>The string str or file associated with fid is read from and parsed according to format. The function is an extension of <code>strread</code> and <code>textread</code>. Differences include: the ability to read from either a file or a string, additional options, and additional format specifiers.</p> 
<p>The input is interpreted as a sequence of words, delimiters (such as whitespace), and literals. The characters that form delimiters and whitespace are determined by the options. The format consists of format specifiers interspersed between literals. In the format, whitespace forms a delimiter between consecutive literals, but is otherwise ignored.</p> 
<p>The output C is a cell array where the number of columns is determined by the number of format specifiers.</p> 
<p>The first word of the input is matched to the first specifier of the format and placed in the first column of the output; the second is matched to the second specifier and placed in the second column and so forth. If there are more words than specifiers then the process is repeated until all words have been processed or the limit imposed by repeat has been met (see below).</p> 
<p>The string format describes how the words in str should be parsed. As in fscanf, any (non-whitespace) text in the format that is not one of these specifiers is considered a literal. If there is a literal between two format specifiers then that same literal must appear in the input stream between the matching words.</p> 
<p>The following specifiers are valid:</p> 
<p><code>%f</code></p> 
<p><code>%f64</code></p> 
<p><code>%n</code></p> 
<p>The word is parsed as a number and converted to double.</p> 
<p><code>%f32</code></p> 
<p>The word is parsed as a number and converted to single (float).</p> 
<p><code>%d</code></p> 
<p><code>%d8</code></p> 
<p><code>%d16</code></p> 
<p><code>%d32</code></p> 
<p><code>%d64</code></p> 
<p>The word is parsed as a number and converted to int8, int16, int32, or int64. If no size is specified then int32 is used.</p> 
<p><code>%u</code></p> 
<p><code>%u8</code></p> 
<p><code>%u16</code></p> 
<p><code>%u32</code></p> 
<p><code>%u64</code></p> 
<p>The word is parsed as a number and converted to uint8, uint16, uint32, or uint64. If no size is specified then uint32 is used.</p> 
<p><code>%s</code></p> 
<p>The word is parsed as a string ending at the last character before whitespace, an end-of-line, or a delimiter specified in the options.</p> 
<p><code>%q</code></p> 
<p>The word is parsed as a "quoted string". If the first character of the string is a double quote (") then the string includes everything until a matching double quote—including whitespace, delimiters, and end-of-line characters. If a pair of consecutive double quotes appears in the input, it is replaced in the output by a single double quote. For examples, the input "He said ""Hello""" would return the value ’He said "Hello"’.</p> 
<p><code>%c</code></p> 
<p>The next character of the input is read. This includes delimiters, whitespace, and end-of-line characters.</p> 
<p><code>%[…]</code></p> 
<p><code>%[^…]</code></p> 
<p>In the first form, the word consists of the longest run consisting of only characters between the brackets. Ranges of characters can be specified by a hyphen; for example, %[0-9a-zA-Z] matches all alphanumeric characters (if the underlying character set is ASCII). Since MATLABtreats hyphens literally, this expansion only applies to alphanumeric characters. To include ’-’ in the set, it should appear first or last in the brackets; to include ’]’, it should be the first character. If the first character is ’^’ then the word consists of characters <strong>not</strong> listed.</p> 
<p><code>%N…</code></p> 
<p>For %s, %c %d, %f, %n, %u, an optional width can be specified as %Ns, etc. where N is an integer &gt; 1. For %c, this causes exactly N characters to be read instead of a single character. For the other specifiers, it is an upper bound on the number of characters read; normal delimiters can cause fewer characters to be read. For complex numbers, this limit applies to the real and imaginary components individually. For %f and %n, format specifiers like %N.Mf are allowed, where M is an upper bound on number of characters after the decimal point to be considered; subsequent digits are skipped. For example, the specifier %8.2f would read 12.345e6 as 1.234e7.</p> 
<p><code>%*…</code></p> 
<p>The word specified by the remainder of the conversion specifier is skipped.</p> 
<p><code>literals</code></p> 
<p>In addition the format may contain literal character strings; these will be skipped during reading. If the input string does not match this literal, the processing terminates.</p> 
<p>Parsed words corresponding to the first specifier are returned in the first output argument and likewise for the rest of the specifiers.</p> 
<p>By default, if there is only one input argument, format is "%f". This means that numbers are read from the input into a single column vector. If format is explicitly empty (<code>""</code>) then textscan will return data in a number of columns matching the number of fields on the first data line of the input. Either of these is suitable only when the input is exclusively numeric.</p> 
<p>For example, the string</p> 
<pre>str = "\
Bunny Bugs   5.5\n\
Duck Daffy  -7.5e-5\n\
Penguin Tux   6"
</pre> 
<p>can be read using</p> 
<pre>a = textscan (str, "%s %s %f");
</pre> 
<p>The optional numeric argument repeat can be used for limiting the number of items read:</p> 
<p>-1</p> 
<p>Read all of the string or file until the end (default).</p> 
<p>N</p> 
<p>Read until the first of two conditions occurs: 1) the format has been processed N times, or 2) N lines of the input have been processed. Zero (0) is an acceptable value for repeat. Currently, end-of-line characters inside %q, %c, and %[…]$ conversions do not contribute to the line count. This is incompatible with MATLAB and may change in future.</p> 
<p>The behavior of <code>textscan</code> can be changed via property/value pairs. The following properties are recognized:</p> 
<p><code>"BufSize"</code></p> 
<p>This specifies the number of bytes to use for the internal buffer. A modest speed improvement may be obtained by setting this to a large value when reading a large file, especially if the input contains long strings. The default is 4096, or a value dependent on n if that is specified.</p> 
<p><code>"CollectOutput"</code></p> 
<p>A value of 1 or true instructs <code>textscan</code> to concatenate consecutive columns of the same class in the output cell array. A value of 0 or false (default) leaves output in distinct columns.</p> 
<p><code>"CommentStyle"</code></p> 
<p>Specify parts of the input which are considered comments and will be skipped. value is the comment style and can be either (1) A string or 1x1 cell string, to skip everything to the right of it; (2) A cell array of two strings, to skip everything between the first and second strings. Comments are only parsed where whitespace is accepted and do not act as delimiters.</p> 
<p><code>"Delimiter"</code></p> 
<p>If value is a string, any character in value will be used to split the input into words. If valueis a cell array of strings, any string in the array will be used to split the input into words. (default value = any whitespace.)</p> 
<p><code>"EmptyValue"</code></p> 
<p>Value to return for empty numeric values in non-whitespace delimited data. The default is NaN. When the data type does not support NaN (int32 for example), then the default is zero.</p> 
<p><code>"EndOfLine"</code></p> 
<p>value can be either an emtpy or one character specifying the end-of-line character, or the pair<code>"\r\n"</code> (CRLF). In the latter case, any of <code>"\r"</code>, <code>"\n"</code> or <code>"\r\n"</code> is counted as a (single) newline. If no value is given, <code>"\r\n"</code> is used.</p> 
<p><code>"HeaderLines"</code></p> 
<p>The first value number of lines of fid are skipped. Note that this does not refer to the first non-comment lines, but the first lines of any type.</p> 
<p><code>"MultipleDelimsAsOne"</code></p> 
<p>If value is nonzero, treat a series of consecutive delimiters, without whitespace in between, as a single delimiter. Consecutive delimiter series need not be vertically aligned. Without this option, a single delimiter before the end of the line does not cause the line to be considered to end with an empty value, but a single delimiter at the start of a line causes the line to be considered to start with an empty value.</p> 
<p><code>"TreatAsEmpty"</code></p> 
<p>Treat single occurrences (surrounded by delimiters or whitespace) of the string(s) in valueas missing values.</p> 
<p><code>"ReturnOnError"</code></p> 
<p>If set to numerical 1 or true, return normally as soon as an error is encountered, such as trying to read a string using <code>%f</code>. If set to 0 or false, return an error and no data.</p> 
<p><code>"Whitespace"</code></p> 
<p>Any character in value will be interpreted as whitespace and trimmed; The default value for whitespace is <code>" \b\r\n\t"</code> (note the space). Unless whitespace is set to <code>""</code> (empty) AND at least one <code>"%s"</code> format conversion specifier is supplied, a space is always part of whitespace.</p> 
<p>When the number of words in str or fid doesn’t match an exact multiple of the number of format conversion specifiers, <code>textscan</code>’s behavior depends on whether the last character of the string or file is an end-of-line as specified by the <code>EndOfLine</code> option:</p> 
<p>last character = end-of-line</p> 
<p>Data columns are padded with empty fields, NaN or 0 (for integer fields) so that all columns have equal length</p> 
<p>last character is not end-of-line</p> 
<p>Data columns are not padded; <code>textscan</code> returns columns of unequal length</p> 
<p>The second output position provides the location, in characters from the beginning of the file or string, where processing stopped.</p> 
<p><strong>See also:</strong> <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFdlmread" rel="nofollow">dlmread</a>, <a href="https://octave.org/doc/interpreter/Formatted-Input.html#XREFfscanf" rel="nofollow">fscanf</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFload" rel="nofollow">load</a>, <a href="https://octave.org/doc/interpreter/Manipulating-Strings.html#XREFstrread" rel="nofollow">strread</a>, <a href="https://octave.org/doc/interpreter/Simple-File-I_002fO.html#XREFtextread" rel="nofollow">textread</a>.</p> 
<p>The <code>importdata</code> function has the ability to work with a wide variety of data.</p> 
<p><a name="XREFimportdata"></a></p> 
<p><a name="index-importdata"></a><em>A =</em> <strong>importdata</strong> <em>(fname)</em></p> 
<p><a name="index-importdata-1"></a><em>A =</em> <strong>importdata</strong> <em>(fname, delimiter)</em></p> 
<p><a name="index-importdata-2"></a><em>A =</em> <strong>importdata</strong> <em>(fname, delimiter, header_rows)</em></p> 
<p><a name="index-importdata-3"></a><em>[A, delimiter] =</em> <strong>importdata</strong> <em>(…)</em></p> 
<p><a name="index-importdata-4"></a><em>[A, delimiter, header_rows] =</em> <strong>importdata</strong> <em>(…)</em></p> 
<p>Import data from the file fname.</p> 
<p>Input parameters:</p> 
<ul><li>fname The name of the file containing data.</li><li>delimiter The character separating columns of data. Use <code>\t</code> for tab. (Only valid for ASCII files)</li><li>header_rows The number of header rows before the data begins. (Only valid for ASCII files)</li></ul> 
<p>Different file types are supported:</p> 
<ul><li>ASCII table <p>Import ASCII table using the specified number of header rows and the specified delimiter.</p> </li><li>Image file</li><li>MATLAB file</li><li>Spreadsheet files (depending on external software)</li><li>WAV file</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/131156a7f53b43825954185b4e1f1669/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">从零开发校园商铺平台（SSM到SpringBoot）三.Logback配置与使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/73be55283ed96cce6cefaf661289c5f5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">GitHub使用笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>