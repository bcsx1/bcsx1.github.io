<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM快速入门 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JVM快速入门" />
<meta property="og:description" content="1、类加载机制： PS:关于双亲委派机制，扩展类加载器在JDK1.9中改为了平台加载器，如下图所示 2、JVM内存模型 JDK1.7版本 （方法区=Non-Heap, hotspot中为永久代） 在JDK1.8中，永久代改为元数据空间，直接由操作系统分配，不再受限于JVM。 方法区在逻辑上属于堆内存，表现在： 线程共享；都可以被GC所管理。 关于JDK1.7与JDK1.8的堆内存具体差异，可以看下图 JDK1.8 JDK1.7 计算伸缩区是否使用，将会耗费一定的计算资源，又因为使用JVM肯定要尽可能的往大设置，在我们工作中伸缩区的存在意义不大，所以一般设置&#34;-Xmx512M -Xms512M&#34;，其中512M根据自己需要设定，单位可以是M，也可以是G，二者应该设置相同的数值。 -Xmx设置的为JVM最大堆内存，默认物理内存的1/4； -Xms设置的为JVM初始堆内存，默认物理内存的1/64； 3、对象可以回收的依据——对象不可用 引用计数器和可达性分析算法两种。
引用计数器记录对象是否被引用，当计数器为零时，说明对象已经不再被使用，可以进行回收。java中的对象有复杂的引用关系，如两个对象互相引用，引用计数器无法判定这种情况，所以sun jdk中并没有实现这种GC方式。
可达性分析：从GC Roots作为起始点，向下搜索，搜索所走过的路径成为引用链（Reference Chain）。当一个对象到GC Roots不存在引用链时，证明此对象不可用。
4、内存回收算法 1）三种回收算法的介绍 复制：从根集合搜扫描出存活的对象，然后将存活的对象复制到一块新的未使用的空间中，当要回收的空间中存活的对象较少时，比较高效。年轻代使用这种算法；
标记清除：从根集合开始扫描，对存活的对象进行标记，比较完毕后，再扫描整个空间中未标记的对象，然后进行回收，不需要对对象进行移动；
标记整理：基于“标记清除”，但是回收不存活的对象后，会把所有存活的对象在内存空间中进行移动，好处是减少了内存碎片，缺点是成本比较高。老年代使用这种算法；
PS:会发生STW（Stop-The-World）问题，暂时挂起所有的执行线程，标记可以回收的对象。
2）复制算法的应用——年轻代垃圾回收机制 年轻代 Eden 伊甸园区
占年轻代80%空间
新建的对象放这里，如果过大直接放老年代。S0 10%空间S1 10%空间 回收时，伊甸园&#43;S0存活的对象，放入S1；清空伊甸园&#43;S0；再次回收时，伊甸园&#43;S1存活的对象，放入S0；清空伊甸园&#43;S1；1-4步循环进行，必定有10%的年轻代空间被浪费掉；S0或者S1放不下对象时（分配担保），或对象年龄（存活一次回收&#43;1）够大时，或新生对象过大时，或动态年龄比例满足条件时（根据年龄划分，低龄对象所占空间占比达到50%，送走高龄），将对象放入老年代。 5、GC处理流程 1、新对象都会在伊甸园区开辟，伊甸园区的内存空间不足会发生MinorGC。 Member mem = new Member()，很小，直接保存在伊甸园；过大，放入老年代。 2、有些对象执行了N次的MinorGC后还会存在，那么这些对象将进入到存活区（S0&#43;S1，永远都有一个空着）； 3、根据大小、年龄、动态年龄比例，或者存活区放不下了，把相应的对象放入老年代； 4、若干次MinorGC回收之后空间依然不够使用，那么则进行老年代GC回收，执行了MajorGC（Full GC，性能很差），如果可以回收空间，则继续进行MinorGC； 5、如果MajorGC失败，则继续内存已经占用完满，则抛出OOM异常； 6、G1算法 支持大内存（4G-64G）；支持多CPU；减少STW停顿时间；可以保证并发状态下的程序执行；采用分片的思想，每个片区都有自己独立的年轻代、老年代，独立进行自己的垃圾回收。开启命令 -XX:&#43;UseG1GC 7、jvm性能调优 java内存分析工具： jmap -heap PIDtomcat/bin/catalina.sh（8G机器）添加JAVA_OPTS=&#34;-Xms4096m -Xmx4096m -Xss1024K -XX:&#43;UseG1GC” 8、其他资料 为什么要有GC（垃圾回收）？ JVM通过GC来回收堆和方法区中的内存，GC的基本原理就是找到程序中不再被使用的对象，然后回收掉这些对象占用的内存。
主要的收集器有哪些？ 引用计数器和跟踪计数器两种。
引用计数器记录对象是否被引用，当计数器为零时，说明对象已经不再被使用，可以进行回收。java中的对象有复杂的引用关系，不是很适合引用计数器，所以sun jdk中并没有实现这种GC方式。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/a6abbff2665ef169d600c72c035b470f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-28T05:19:37+08:00" />
<meta property="article:modified_time" content="2019-11-28T05:19:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM快速入门</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="margin-left:0px;"><strong><span style="color:#000000;">1、类加载机制：</span></strong></h2> 
<div style="margin-left:0px;"> 
 <img alt="" class="has" src="https://images2.imgbox.com/80/76/WmiHpy4M_o.png"> 
</div> 
<div style="margin-left:0px;"> 
 <span style="color:#000000;">PS:关于双亲委派机制，扩展类加载器在<strong>JDK1.9</strong>中改为了平台加载器，如下图所示</span> 
</div> 
<div style="margin-left:0px;"> 
 <img alt="" class="has" src="https://images2.imgbox.com/07/e9/9HrtS13B_o.png"> 
</div> 
<h2 style="margin-left:0px;"><strong><span style="color:#000000;">2、JVM内存模型</span></strong></h2> 
<div style="margin-left:0px;"> 
 <img alt="" class="has" height="296" src="https://images2.imgbox.com/19/f3/4LOIDcDs_o.png" width="671"> 
</div> 
<div style="margin-left:0px;">
    
</div> 
<div style="margin-left:0px;"> 
 <span style="color:#000000;">JDK1.7版本</span> 
</div> 
<div style="margin-left:0px;"> 
 <span style="color:#000000;">（方法区=Non-Heap, hotspot中为永久代）</span> 
</div> 
<div style="margin-left:0px;">
    
</div> 
<div style="margin-left:0px;"> 
 <span style="color:#000000;">在JDK1.8中，永久代改为元数据空间，直接由操作系统分配，不再受限于JVM。</span> 
</div> 
<div style="margin-left:0px;"> 
 <span style="color:#000000;">方法区在逻辑上属于堆内存，表现在：</span> 
</div> 
<div style="margin-left:0px;"> 
 <ul style="margin-left:0px;"><li><span style="color:#000000;">线程共享；</span></li><li><span style="color:#000000;">都可以被GC所管理。</span></li></ul> 
</div> 
<div style="margin-left:0px;"> 
 <span style="color:#000000;">关于JDK1.7与JDK1.8的堆内存具体差异，可以看下图</span> 
</div> 
<div style="margin-left:0px;"> 
 <figure class="image"> 
  <img alt="" height="410" src="https://images2.imgbox.com/92/f2/qxOS2eES_o.png" width="922"> 
  <figcaption>
    JDK1.8 
  </figcaption> 
 </figure> 
</div> 
<div style="margin-left:0px;"> 
 <figure class="image"> 
  <img alt="" height="410" src="https://images2.imgbox.com/2c/ab/La0nhIiO_o.png" width="890"> 
  <figcaption>
    JDK1.7 
  </figcaption> 
 </figure> 
</div> 
<div style="margin-left:0px;"> 
 <span style="color:#000000;">    计算伸缩区是否使用，将会耗费一定的计算资源，又因为使用JVM肯定要尽可能的往大设置，在我们工作中伸缩区的存在意义不大，所以一般设置"-Xmx512M -Xms512M"，其中512M根据自己需要设定，单位可以是M，也可以是G，二者应该设置相同的数值。</span> 
</div> 
<div style="margin-left:0px;"> 
 <span style="color:#000000;">    -Xmx设置的为JVM最大堆内存，默认物理内存的1/4；</span> 
</div> 
<div style="margin-left:0px;"> 
 <span style="color:#000000;">    -Xms设置的为JVM初始堆内存，默认物理内存的1/64；</span> 
</div> 
<div style="margin-left:0px;">
    
</div> 
<h2 style="margin-left:0px;"><strong><span style="color:#000000;">3、对象可以回收的依据——对象不可用</span></strong></h2> 
<p style="margin-left:0px;"><span style="color:#000000;"><strong>引用计数器</strong>和<strong>可达性分析算法</strong>两种。</span></p> 
<p style="margin-left:0px;"><span style="color:#000000;"><span style="color:#ff0000;">引用计数器</span>记录对象是否被引用，当计数器为零时，说明对象已经不再被使用，可以进行回收。java中的对象有复杂的引用关系，如两个对象互相引用，引用计数器无法判定这种情况，所以sun jdk中并没有实现这种GC方式。</span></p> 
<p style="margin-left:0px;"><span style="color:#000000;"><span style="color:#ff0000;"><strong>可达性分析</strong></span>：从GC Roots作为起始点，向下搜索，搜索所走过的路径成为引用链（Reference Chain）。当一个对象到GC Roots不存在引用链时，证明此对象不可用。</span></p> 
<p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
<h2 style="margin-left:0px;"><strong><span style="color:#000000;"><strong>4、内存回收算法</strong></span></strong></h2> 
<h4 style="margin-left:0px;"><strong><span style="color:#000000;">1）三种回收算法的介绍</span></strong></h4> 
<p style="margin-left:0px;"><span style="color:#000000;"><span style="color:#ff0000;"><strong>复制</strong></span>：从根集合搜扫描出存活的对象，然后将存活的对象复制到一块新的未使用的空间中，当要回收的空间中存活的对象较少时，比较高效。<span style="color:#ff0000;">年轻代</span>使用这种算法；</span></p> 
<p style="margin-left:0px;"><span style="color:#000000;"><span style="color:#ff0000;">标记清除</span>：从根集合开始扫描，对存活的对象进行标记，比较完毕后，再扫描整个空间中未标记的对象，然后进行回收，不需要对对象进行移动；</span></p> 
<p style="margin-left:0px;"><span style="color:#000000;"><span style="color:#ff0000;"><strong>标记整理</strong></span>：基于“标记清除”，但是回收不存活的对象后，会把所有存活的对象在内存空间中进行移动，好处是减少了内存碎片，缺点是成本比较高。<span style="color:#ff0000;">老年代</span>使用这种算法；</span></p> 
<p style="margin-left:0px;"><span style="color:#000000;">PS:会发生<span style="color:#ff0000;"><strong>STW</strong></span>（Stop-The-World）问题，暂时挂起所有的执行线程，标记可以回收的对象。</span></p> 
<h4 style="margin-left:0px;"><strong><span style="color:#000000;">2）复制算法的应用——年轻代垃圾回收机制</span></strong></h4> 
<div style="margin-left:0px;"> 
 <table border="4" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
    年轻代 
  </caption><tbody><tr><td rowspan="2" style="width:360px;">Eden 伊甸园区<br> 占年轻代80%空间<br> 新建的对象放这里，如果过大直接放老年代。</td><td style="width:138px;">S0 10%空间</td></tr><tr><td style="width:138px;">S1 10%空间</td></tr></tbody></table> 
</div> 
<div style="margin-left:0px;"> 
 <ol style="margin-left:0px;"><li><span style="color:#000000;">回收时，伊甸园+S0存活的对象，放入S1；</span></li><li><span style="color:#000000;">清空伊甸园+S0；</span></li><li><span style="color:#000000;">再次回收时，伊甸园+S1存活的对象，放入S0；</span></li><li><span style="color:#000000;">清空伊甸园+S1；</span></li><li><span style="color:#000000;">1-4步循环进行，必定有10%的年轻代空间被浪费掉；</span></li><li><span style="color:#000000;">S0或者S1放不下对象时（分配担保），或对象年龄（存活一次回收+1）够大时，或新生对象过大时，或动态年龄比例满足条件时（根据年龄划分，低龄对象所占空间占比达到50%，送走高龄），将对象放入老年代。</span></li></ol> 
</div> 
<div style="margin-left:0px;">
    
</div> 
<h2 style="margin-left:0px;"><strong><span style="color:#000000;">5、GC处理流程</span></strong></h2> 
<div style="margin-left:0px;"> 
 <span style="color:#000000;">1、新对象都会在伊甸园区开辟，伊甸园区的内存空间不足会发生MinorGC。</span> 
</div> 
<div style="margin-left:0px;"> 
 <span style="color:#000000;">Member mem = new Member()，很小，直接保存在伊甸园；过大，放入老年代。</span> 
</div> 
<div style="margin-left:0px;"> 
 <span style="color:#000000;">2、有些对象执行了N次的MinorGC后还会存在，那么这些对象将进入到存活区（S0+S1，永远都有一个空着）；</span> 
</div> 
<div style="margin-left:0px;"> 
 <span style="color:#000000;">3、根据大小、年龄、动态年龄比例，或者存活区放不下了，把相应的对象放入老年代；</span> 
</div> 
<div style="margin-left:0px;"> 
 <span style="color:#000000;">4、若干次MinorGC回收之后空间依然不够使用，那么则进行老年代GC回收，执行了MajorGC（Full GC，性能很差），如果可以回收空间，则继续进行MinorGC；</span> 
</div> 
<div style="margin-left:0px;"> 
 <span style="color:#000000;">5、如果MajorGC失败，则继续内存已经占用完满，则抛出OOM异常；</span> 
</div> 
<div style="margin-left:0px;">
    
</div> 
<h2 style="margin-left:0px;"><strong><span style="color:#000000;">6、G1算法</span></strong></h2> 
<div style="margin-left:0px;"> 
 <ul style="margin-left:0px;"><li><span style="color:#000000;">支持大内存（4G-64G）；</span></li><li><span style="color:#000000;">支持多CPU；</span></li><li><span style="color:#000000;">减少STW停顿时间；</span></li><li><span style="color:#000000;">可以保证并发状态下的程序执行；</span></li><li><span style="color:#000000;">采用分片的思想，每个片区都有自己独立的年轻代、老年代，独立进行自己的垃圾回收。</span></li><li><span style="color:#000000;">开启命令 -XX:+UseG1GC</span></li></ul> 
</div> 
<div style="margin-left:0px;"> 
 <img alt="" class="has" height="154" src="https://images2.imgbox.com/74/67/h8TRz6AU_o.png" width="456"> 
</div> 
<div style="margin-left:0px;">
    
</div> 
<h2 style="margin-left:0px;"><strong><span style="color:#000000;">7、jvm性能调优</span></strong></h2> 
<div style="margin-left:0px;"> 
 <ul style="margin-left:0px;"><li><span style="color:#000000;">java内存分析工具： jmap -heap PID</span></li><li><span style="color:#000000;">tomcat/bin/catalina.sh（8G机器）添加JAVA_OPTS="-Xms4096m -Xmx4096m -Xss1024K -XX:+UseG1GC”</span></li></ul> 
</div> 
<div style="margin-left:0px;">
    
</div> 
<h2 style="margin-left:0px;"><strong><span style="color:#000000;">8、其他资料</span></strong></h2> 
<div style="margin-left:0px;"> 
 <h4 style="margin-left:0px;"><span style="color:#000000;"><strong><strong>为什么要有GC（垃圾回收）？</strong></strong></span></h4> 
 <p style="margin-left:0px;"> </p> 
 <p style="margin-left:0px;"><span style="color:#000000;">JVM通过GC来回收堆和方法区中的内存，GC的基本原理就是找到程序中不再被使用的对象，然后回收掉这些对象占用的内存。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
 <h4 style="margin-left:0px;"><span style="color:#000000;"><strong><strong>主要的收集器有哪些？</strong></strong></span></h4> 
 <p style="margin-left:0px;"><span style="color:#000000;">引用计数器和跟踪计数器两种。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">引用计数器记录对象是否被引用，当计数器为零时，说明对象已经不再被使用，可以进行回收。java中的对象有复杂的引用关系，不是很适合引用计数器，所以sun jdk中并没有实现这种GC方式。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">跟踪收集器，全局记录数据的引用状态，基于一定的条件触发。执行的时候，从根集合开始扫描对象的引用关系，主要有复制（copying）、标记-清除（Mark-Sweep）、标记-压缩(Mark-Compact)那种算法。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
 <h4 style="margin-left:0px;"><span style="color:#000000;"><strong><strong>跟踪计数器的三种算法简介？</strong></strong></span></h4> 
 <p style="margin-left:0px;"><span style="color:#000000;">复制：从根集合搜扫描出存活的对象，然后将存活的对象复制到一块新的未使用的空间中，当要回收的空间中存活的对象较少时，比较高效；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">标记清除：从根集合开始扫描，对存活的对象进行标记，比较完毕后，再扫描整个空间中未标记的对象，然后进行回收，不需要对对象进行移动；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">标记压缩：标记形式和“标记清除”一样，但是回收不存活的对象后，会把所有存活的对象在内存空间中进行移动，好处是减少了内存碎片，缺点是成本比较高；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
 <h4 style="margin-left:0px;"><span style="color:#000000;"><strong><strong>java内存区域的形式是啥样的？</strong></strong></span></h4> 
 <p style="margin-left:0px;"><span style="color:#000000;">这里就不再介绍了，之前有一篇文章中专门介绍这个的（<a href="https://www.iteye.com/blog/1333100">http://iamzhongyong.iteye.com/blog/1333100</a>）。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
 <h4 style="margin-left:0px;"><span style="color:#000000;"><strong><strong>新生代可用的GC？</strong></strong></span></h4> 
 <p style="margin-left:0px;"><span style="color:#000000;">新生代中对象存活的时间比较短，因此给予Copying算法实现，Eden区域存放新创建的对象，S0和S1区其中一块用于存放在Minor GC的时候作为复制存活对象的目标空间，另外一块清空。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"><strong>串行GC（Serial GC）</strong>比较适合单CPU的情况，可以通过-XX：UseSerialGC来强行制定；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"><strong>并行回收GC（Parallel Scavenge）</strong>，启动的时候按照设置的参数来划定Eden/S0/S1区域的大小，但是在运行时，会根据Minor GC的频率、消耗时间来动态调整三个区域的大小，可以用过-XX：UseAdaptiveSizePolicy来固定大小，不进行动态调整；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"><strong>并行GC（ParNew）</strong>划分Eden、S1、S0的区域上和串行GC一样。并行GC需要配合旧生代使用CMS GC（这是他和并行回收GC的不同）（如果配置了CMS GC的方式，那么新生代默认采取的就是并行GC的方式）；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
 <h4 style="margin-left:0px;"><span style="color:#000000;"><strong><strong>啥时候会触发Minor GC？</strong></strong></span></h4> 
 <p style="margin-left:0px;"><span style="color:#000000;">当Eden区域分配内存时，发现空间不足，JVM就会触发Minor GC，程序中System.gc()也可以来触发。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
 <h4 style="margin-left:0px;"><span style="color:#000000;"><strong><strong>旧生代可用的GC方式有哪几种？</strong></strong></span></h4> 
 <p style="margin-left:0px;"><span style="color:#000000;">串行GC（Serial MSC）、并行GC（Parallel MSC）、并发GC（CMS）；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
 <h4 style="margin-left:0px;"><span style="color:#000000;"><strong><strong>关于CMS？</strong></strong></span></h4> 
 <p style="margin-left:0px;"><span style="color:#000000;">采用CMS时候，新生代必须使用Serial GC或者ParNew GC两种。CMS共有七个步骤，只有Initial Marking和Final Marking两个阶段是stop-the-world的，其他步骤均和应用并行进行。持久代的GC也采用CMS，通过-XX：CMSPermGenSweepingEnabled -XX：CMSClassUnloadingEnabled来制定。在采用cms gc的情况下，ygc变慢的原因通常是由于old gen出现了大量的碎片。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
 <h4 style="margin-left:0px;"><span style="color:#000000;"><strong><strong>为啥CMS会有内存碎片，如何避免？</strong></strong></span></h4> 
 <p style="margin-left:0px;"><span style="color:#000000;">由于在CMS的回收步骤中，没有对内存进行压缩，所以会有内存碎片出现，CMS提供了一个整理碎片的功能，通过-XX：UseCompactAtFullCollection来启动此功能，启动这个功能后，默认每次执行Full GC的时候会进行整理（也可以通过-XX：CMSFullGCsBeforeCompaction=n来制定多少次Full GC之后来执行整理），整理碎片会stop-the-world.</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
 <h4 style="margin-left:0px;"><span style="color:#000000;"><strong><strong>啥时候会触发CMS GC？</strong></strong></span></h4> 
 <p style="margin-left:0px;"><span style="color:#000000;">1、旧生代或者持久代已经使用的空间达到设定的百分比时（CMSInitiatingOccupancyFraction这个设置old区，perm区也可以设置）；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">2、JVM自动触发(JVM的动态策略，也就是悲观策略)（基于之前GC的频率以及旧生代的增长趋势来评估决定什么时候开始执行），如果不希望JVM自行决定，可以通过-XX：UseCMSInitiatingOccupancyOnly=true来制定；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">3、设置了 -XX：CMSClassUnloadingE考虑nabled 这个则考虑Perm区；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
 <h4 style="margin-left:0px;"><span style="color:#000000;"><strong><strong>啥时候会触发Full GC？</strong></strong></span></h4> 
 <p style="margin-left:0px;"><span style="color:#000000;">一、旧生代空间不足：java.lang.outOfMemoryError：java heap space；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">二、Perm空间满：java.lang.outOfMemoryError：PermGen space；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">三、CMS GC时出现promotion failed  和concurrent  mode failure（Concurrent mode failure发生的原因一般是CMS正在进行，但是由于old区内存不足，需要尽快回收old区里面的死的java对象，这个时候foreground gc需要被触发，停止所有的java线程，同时终止CMS，直接进行MSC。）；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">四、统计得到的minor GC晋升到旧生代的平均大小大于旧生代的剩余空间；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">五、主动触发Full GC（执行jmap -histo:live [pid]）来避免碎片问题；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
 <h4 style="margin-left:0px;"><span style="color:#000000;"><strong><strong>为啥heap小于3g不建议使用CMS GC这种方式？</strong></strong></span></h4> 
 <p style="margin-left:0px;"><span style="color:#000000;"><a href="http://hellojava.info/?p=142" rel="nofollow">http://hellojava.info/?p=142</a> 毕大师的这篇文章讲的很清楚。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">1、触发比例不好设置，设置大了，那么剩余的空间就少了很多，设置小了，那old区还没放置多少东西，就要进行回收了；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">2、CMS进行的时候，是并行的，也就意味着如果过于频繁的话，会和应用的强占CPU；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">3、CMS会有内存 碎片问题；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">4、YGC的速率变慢（由于CMS GC的实现原理，导致对象从新生代晋升到旧生代时，寻找哪里能放下的这个步骤比ParallelOld GC是慢一些的，因此就导致了YGC速度会有一定程度的下降。）；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
 <h4 style="margin-left:0px;"><span style="color:#000000;"><strong><strong>JVM的悲观策略是啥？</strong></strong></span></h4> 
 <p style="margin-left:0px;"><span style="color:#000000;">所谓的悲观策略（<a href="http://tmalltesting.com/archives/663" rel="nofollow">http://tmalltesting.com/archives/663</a> 我们性能测试团队一个同学分析的案例），就是JVM不按照JVM指定的参数来进行CMS GC，而是根据内存情况以及之前回收的方式动态调整，自行进行GC。旧生代剩余的空间（available）大于新生代中使用的空间（max_promotion_in_bytes），或者大于之前平均晋升的old的大小（av_promo），返回false。cms gc是每隔一个周期（默认2s）就会做一次这个检查，如果为false，则不执行YGC，而触发cms gc。</span></p> 
 <h4 style="margin-left:0px;"><span style="color:#000000;"><strong> </strong></span></h4> 
 <h4 style="margin-left:0px;"><span style="color:#000000;"><strong><strong>我们经常使用的是啥GC方式？</strong></strong></span></h4> 
 <p style="margin-left:0px;"><span style="color:#000000;">针对目前线上机器的情况（8G的物流内存），heap区一般设置在4g或者5g左右，一般是使用CMS GC，这时候：</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">young区使用ParNew（并行GC），Old+Perm(需要单独设置)使用CMS，整个堆（young+old+perm）使用MSC（（Mark Sweep Compact）是CMS GC算法的Full GC算法,单线程回收整个堆，回收过程有严格的步骤。压缩，所以回收完理论上任何Generation都不会有内存碎片）压缩回收的方式。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
 <h4 style="margin-left:0px;"><span style="color:#000000;"><strong><strong>读懂GC日志？</strong></strong></span></h4> 
 <p style="margin-left:0px;"><span style="color:#000000;"><strong>基本上都是这种格式：回收前区域占用的大小-&gt;回收后区域占用的大小（区域设置的大小），占用的时间</strong></span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"><strong> </strong></span></p> 
 <p><span style="color:#000000;"><strong><strong>1、promotion failed的一段日志</strong></strong></span></p> 
 <div style="margin-left:0px;"> 
  <div style="margin-left:0px;"> 
   <table border="1" cellspacing="0"><tbody><tr><td style="border-color:#bbbbbb;"> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">1</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">2</span> 
       </div> </td><td style="border-color:#bbbbbb;"> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>2013</code><code>-</code><code>11</code><code>-27T03:</code><code>00</code><code>:</code><code>53.638</code><code>+</code><code>0800</code><code>: </code><code>35333.562</code><code>: [GC </code><code>35333.562</code><code>: [ParNew (promotion failed): 1877376K-&gt;1877376K(1877376K), </code><code>15.7989680</code> <code>secs]</code><code>35349.361</code><code>: [CMS: 2144171K-&gt;2129287K(2146304K), </code><code>10.4200280</code> <code>sec</code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>s] 3514052K-&gt;2129287K(4023680K), [CMS Perm : 119979K-&gt;118652K(190132K)], </code><code>26.2193500</code> <code>secs] [Times: user=</code><code>30.35</code> <code>sys=</code><code>5.19</code><code>, real=</code><code>26.22</code> <code>secs]</code></span> 
       </div> </td></tr></tbody></table> 
  </div> 
 </div> 
 <p style="margin-left:0px;"><span style="color:#000000;">解释如下：</span></p> 
 <div style="margin-left:0px;"> 
  <div style="margin-left:0px;"> 
   <table border="1" cellspacing="0"><tbody><tr><td style="border-color:#bbbbbb;"> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">1</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">2</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">3</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">4</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">5</span> 
       </div> </td><td style="border-color:#bbbbbb;"> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>1877376K-&gt;1877376K(1877376K), </code><code>15.7989680</code> <code>secs   young区</code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>2144171K-&gt;2129287K(2146304K), </code><code>10.4200280</code> <code>sec     old区情况</code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>3514052K-&gt;2129287K(4023680K)                     heap区情况</code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>119979K-&gt;118652K(190132K)], </code><code>26.2193500</code> <code>secs      perm区情况 </code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>[Times: user=</code><code>30.35</code> <code>sys=</code><code>5.19</code><code>, real=</code><code>26.22</code> <code>secs]    整个过程的时间消耗</code></span> 
       </div> </td></tr></tbody></table> 
  </div> 
 </div> 
 <p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
 <p><span style="color:#000000;"><strong><strong>2、一段正常的CMS的日志</strong></strong></span></p> 
 <div style="margin-left:0px;"> 
  <div style="margin-left:0px;"> 
   <table border="1" cellspacing="0"><tbody><tr><td style="border-color:#bbbbbb;"> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">1</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">2</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">3</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">4</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">5</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">6</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">7</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">8</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">9</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">10</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">11</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">12</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">13</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">14</span> 
       </div> </td><td style="border-color:#bbbbbb;"> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>2013</code><code>-</code><code>11</code><code>-27T04:</code><code>00</code><code>:</code><code>12.819</code><code>+</code><code>0800</code><code>: </code><code>38892.743</code><code>: [GC [</code><code>1</code> <code>CMS-initial-mark: 1547313K(2146304K)] 1734957K(4023680K), </code><code>0.1390860</code> <code>secs] [Times: user=</code><code>0.14</code> <code>sys=</code><code>0.00</code><code>, real=</code><code>0.14</code> <code>secs]</code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>2013</code><code>-</code><code>11</code><code>-27T04:</code><code>00</code><code>:</code><code>12.958</code><code>+</code><code>0800</code><code>: </code><code>38892.883</code><code>: [CMS-concurrent-mark-start]</code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>2013</code><code>-</code><code>11</code><code>-27T04:</code><code>00</code><code>:</code><code>19.231</code><code>+</code><code>0800</code><code>: </code><code>38899.155</code><code>: [CMS-concurrent-mark: </code><code>6.255</code><code>/</code><code>6.272</code> <code>secs] [Times: user=</code><code>8.49</code> <code>sys=</code><code>1.57</code><code>, real=</code><code>6.27</code> <code>secs]</code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>2013</code><code>-</code><code>11</code><code>-27T04:</code><code>00</code><code>:</code><code>19.231</code><code>+</code><code>0800</code><code>: </code><code>38899.155</code><code>: [CMS-concurrent-preclean-start]</code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>2013</code><code>-</code><code>11</code><code>-27T04:</code><code>00</code><code>:</code><code>19.250</code><code>+</code><code>0800</code><code>: </code><code>38899.175</code><code>: [CMS-concurrent-preclean: </code><code>0.018</code><code>/</code><code>0.019</code> <code>secs] [Times: user=</code><code>0.02</code> <code>sys=</code><code>0.00</code><code>, real=</code><code>0.02</code> <code>secs]</code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>2013</code><code>-</code><code>11</code><code>-27T04:</code><code>00</code><code>:</code><code>19.250</code><code>+</code><code>0800</code><code>: </code><code>38899.175</code><code>: [CMS-concurrent-abortable-preclean-start]</code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code> </code><code>CMS: abort preclean due to time </code><code>2013</code><code>-</code><code>11</code><code>-27T04:</code><code>00</code><code>:</code><code>25.252</code><code>+</code><code>0800</code><code>: </code><code>38905.176</code><code>: [CMS-concurrent-abortable-preclean: </code><code>5.993</code><code>/</code><code>6.002</code> <code>secs] [Times: user=</code><code>6.97</code> <code>sys=</code><code>2.16</code><code>, real=</code><code>6.00</code> <code>secs]</code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>2013</code><code>-</code><code>11</code><code>-27T04:</code><code>00</code><code>:</code><code>25.253</code><code>+</code><code>0800</code><code>: </code><code>38905.177</code><code>: [GC[YG occupancy: </code><code>573705</code> <code>K (</code><code>1877376</code> <code>K)]</code><code>38905.177</code><code>: [Rescan (parallel) , </code><code>0.3685690</code> <code>secs]</code><code>38905.546</code><code>: [weak refs processing, </code><code>0.0024100</code> <code>secs]</code><code>38905.548</code><code>: [cla</code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>ss unloading, </code><code>0.0177600</code> <code>secs]</code><code>38905.566</code><code>: [scrub symbol &amp; string tables, </code><code>0.0154090</code> <code>secs] [</code><code>1</code> <code>CMS-remark: 1547313K(2146304K)] 2121018K(4023680K), </code><code>0.4229380</code> <code>secs] [Times: user=</code><code>1.41</code> <code>sys=</code><code>0.01</code><code>, real=</code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>0.43</code> <code>secs]</code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>2013</code><code>-</code><code>11</code><code>-27T04:</code><code>00</code><code>:</code><code>25.676</code><code>+</code><code>0800</code><code>: </code><code>38905.601</code><code>: [CMS-concurrent-sweep-start]</code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>2013</code><code>-</code><code>11</code><code>-27T04:</code><code>00</code><code>:</code><code>26.436</code><code>+</code><code>0800</code><code>: </code><code>38906.360</code><code>: [CMS-concurrent-sweep: </code><code>0.759</code><code>/</code><code>0.760</code> <code>secs] [Times: user=</code><code>1.06</code> <code>sys=</code><code>0.48</code><code>, real=</code><code>0.76</code> <code>secs]</code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>2013</code><code>-</code><code>11</code><code>-27T04:</code><code>00</code><code>:</code><code>26.436</code><code>+</code><code>0800</code><code>: </code><code>38906.360</code><code>: [CMS-concurrent-reset-start]</code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>2013</code><code>-</code><code>11</code><code>-27T04:</code><code>00</code><code>:</code><code>26.441</code><code>+</code><code>0800</code><code>: </code><code>38906.365</code><code>: [CMS-concurrent-reset: </code><code>0.005</code><code>/</code><code>0.005</code> <code>secs] [Times: user=</code><code>0.00</code> <code>sys=</code><code>0.00</code><code>, real=</code><code>0.00</code> <code>secs]</code></span> 
       </div> </td></tr></tbody></table> 
  </div> 
 </div> 
 <p style="margin-left:0px;"><span style="color:#000000;"><strong>这个是一个正常的CMS的日志，共分为七个步骤，重点关注initial-mark和remark这两个阶段，因为这两个是停机的。</strong></span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">A、[GC [1 CMS-initial-mark: 1547313K(2146304K)] 1734957K(4023680K), 0.1390860 secs] [Times: user=0.14 sys=0.00, real=0.14 secs]</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">各个数据依次表示标记前后old区的所有对象占内存大小和old的capacity，整个JavaHeap（不包括perm）所有对象占内存总的大小和JavaHeap的capacity。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">B、2013-11-27T04:00:25.253+0800: 38905.177: [GC[YG occupancy: 573705 K (1877376 K)]38905.177: [Rescan (parallel) , 0.3685690 secs]38905.546: [weak refs processing, 0.0024100 secs]38905.548: [class unloading, 0.0177600 secs]38905.566: [scrub symbol &amp; string tables, 0.0154090 secs] [1 CMS-remark: 1547313K(2146304K)] 2121018K(4023680K), 0.4229380 secs] [Times: user=1.41 sys=0.01, real=0.43 secs]</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">Rescan (parallel)表示的是多线程处理young区和多线程扫描old+perm的卡表的总时间， parallel 表示多GC线程并行。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">weak refs processing 处理old区的弱引用的总时间，用于回收native memory。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">class unloading 回收SystemDictionary消耗的总时间。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
 <p><span style="color:#000000;"><strong><strong>3、一段正常的Young GC的日志</strong></strong></span></p> 
 <div style="margin-left:0px;"> 
  <div style="margin-left:0px;"> 
   <table border="1" cellspacing="0"><tbody><tr><td style="border-color:#bbbbbb;"> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">1</span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">2</span> 
       </div> </td><td style="border-color:#bbbbbb;"> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>2013</code><code>-</code><code>11</code><code>-27T04:</code><code>00</code><code>:</code><code>07.345</code><code>+</code><code>0800</code><code>: </code><code>38887.270</code><code>: [GC </code><code>38887.270</code><code>: [ParNew: 1791076K-&gt;170624K(1877376K), </code><code>0.2324440</code> <code>secs] 2988366K-&gt;1413629K(4023680K), </code><code>0.2326470</code> <code>secs] [Times: user=</code><code>0.80</code> <code>sys=</code><code>0.00</code><code>, real=</code><code>0</code><code>.</code></span> 
       </div> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>23</code> <code>secs]</code></span> 
       </div> </td></tr></tbody></table> 
  </div> 
 </div> 
 <p style="margin-left:0px;"><span style="color:#000000;">ParNew这个表明是并行的回收方式，具体的分别是young区、整个heap区的情况；</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
 <p><span style="color:#000000;"><strong><strong>4、一段通过system.gc产生的FullGC日志</strong></strong></span></p> 
 <div style="margin-left:0px;"> 
  <div style="margin-left:0px;"> 
   <table border="1" cellspacing="0"><tbody><tr><td style="border-color:#bbbbbb;"> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">1</span> 
       </div> </td><td style="border-color:#bbbbbb;"> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>2013</code><code>-</code><code>07</code><code>-21T17:</code><code>44</code><code>:</code><code>01.554</code><code>+</code><code>0800</code><code>: </code><code>50.568</code><code>: [Full GC (System) </code><code>50.568</code><code>: [CMS: 943772K-&gt;220K(2596864K), </code><code>2.3424070</code> <code>secs] 1477000K-&gt;220K(4061184K), [CMS Perm : 3361K-&gt;3361K(98304K)], </code><code>2.3425410</code> <code>secs] [Times: user=</code><code>2.33</code> <code>sys=</code><code>0.01</code><code>, real=</code><code>2.34</code> <code>secs]</code></span> 
       </div> </td></tr></tbody></table> 
  </div> 
 </div> 
 <p style="margin-left:0px;"><span style="color:#000000;">解释如下：</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">Full GC (System)意味着这是个system.gc调用产生的MSC。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">“943772K-&gt;220K(2596864K), 2.3424070 secs”表示：这次MSC前后old区内总对象大小，old的capacity及这次MSC耗时。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">“1477000K-&gt;220K(4061184K)”表示：这次MSC前后JavaHeap内总对象大小，JavaHeap的capacity。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;">“3361K-&gt;3361K(98304K)], 2.3425410 secs”表示：这次MSC前后Perm区内总对象大小，Perm区的capacity。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
 <p><span style="color:#000000;"><strong><strong>5、一个特殊的GC日志，根据动态计算直接进行的FullGC（MSC的方式）</strong></strong></span></p> 
 <div style="margin-left:0px;"> 
  <div style="margin-left:0px;"> 
   <table border="1" cellspacing="0"><tbody><tr><td style="border-color:#bbbbbb;"> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;">1</span> 
       </div> </td><td style="border-color:#bbbbbb;"> 
       <div style="margin-left:0px;"> 
        <span style="color:#000000;"><code>2013</code><code>-</code><code>03</code><code>-13T13:</code><code>48</code><code>:</code><code>06.349</code><code>+</code><code>0800</code><code>: </code><code>7.092</code><code>: [GC </code><code>7.092</code><code>: [ParNew: 471872K-&gt;471872K(471872K), </code><code>0.0000420</code> <code>secs]</code><code>7.092</code><code>: [CMS: 366666K-&gt;524287K(524288K), </code><code>27.0023450</code> <code>secs] 838538K-&gt;829914K(996160K), [CMS Perm : 3196K-&gt;3195K(131072K)], </code><code>27.0025170</code> <code>secs]</code></span> 
       </div> </td></tr></tbody></table> 
  </div> 
 </div> 
 <p style="margin-left:0px;"><span style="color:#000000;">ParNew的时间特别短，jvm在minor gc前会首先确认old是不是足够大，如果不够大，这次young gc直接返回，进行MSC。</span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"> </span></p> 
 <p style="margin-left:0px;"> </p> 
 <p style="margin-left:0px;"><span style="color:#000000;"><strong>其他资料转载自文章：</strong></span></p> 
 <p style="margin-left:0px;"><span style="color:#000000;"><a href="https://www.iteye.com/blog/iamzhongyong-1989829">https://www.iteye.com/blog/iamzhongyong-1989829</a>  <strong>一次CMS GC问题排查过程（理解原理+读懂GC日志）</strong></span></p> 
</div> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/78d1ad3d16417f6e6dde18175729da25/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android 如何正确的重写 onDestroy() 方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/61eac77ab78db370b5f44a2309f974f0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">菜鸟初次接触框架逻辑</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>