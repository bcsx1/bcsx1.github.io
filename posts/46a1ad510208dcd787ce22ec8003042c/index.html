<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【秋招面试题】C&#43;&#43; 网络编程 面试题库（一） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【秋招面试题】C&#43;&#43; 网络编程 面试题库（一）" />
<meta property="og:description" content="目录 一、线程池的设计及作用
二、线程和进程的区别
三、C&#43;&#43; 设计模式
四、进程间的通讯方式
五、引用和指针的区别
六、构造函数和析构函数 七、深拷贝和浅拷贝
八、对多态的理解
九、数据结构有哪些
十、socket包安全
十一、new和malloc的区别
十二、epoll的 LT 和 ET 模式的理解
十三、TCP/UPD的区别
十四、三次握手和四次挥手
十五、socket的概念和特点
十六、gdb调试
十七、面向对象的理解
十八、虚函数的作用
十九、类和对象的关系 二十、IO复用，epoll和select的区别，opoll和selete的特点
二十一、客户端与服务器如何通信
二十二、堆和栈的区别
二十三、结构体和类的区别
二十四、STL中的vector如何实现
二十五、如何保证线程的安全
二十六、数组和链表的区别
二十七、boost库是否有了解
二十八、socket的工作模式，为什么选择socket
二十九、长连接和短连接
三十、socket中阻塞和非阻塞的区别
一、线程池的设计及作用 线程池的作用：
线程池是为了解决线程在程序中因频繁创建和销毁而消耗大量时间而存在的，即在程序开始正式任务之前，先创建出一些线程，这些线程在程序不会被销毁，而且程序在运行中也不会再去创建线程。这样在程序的运行期间就提高了效率。
线程池的设计思路：
先创建出一组线程，当有新任务进来时就从线程池中取出空闲线程处理任务，任务完成之后又重新放回去，当线程池中的所有线程都在任务时，只能等待有线程结束任务才能继续执行。
二、线程和进程的区别 根本区别：进程是操作系统资源分配的基本单位，而线程是CPU任务调度和执行的基本单位
在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）
内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。
包含关系：一个线程只能属于一个进程，但是一个进程可以拥有多个线程。多线程处理就是允许一个进程中在同一时刻执行多个任务。所以线程也被称为轻权进程或者轻量级进程。
三、C&#43;&#43; 设计模式 单例模式
概念：是指在内存中只会创建且仅创建一次对象的设计模式
优点： 1.保证一个类只有一个实例，并提供一个访问它的全局访问点，使得系统中只有唯一的一个对象实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例 2.由于在系统内存中只存在一个对象，因此可以节约系统资源、提高系统的性能。
缺点：
就是不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。
实现要点：
在类中，要构造一个实例，就必须调用类的构造函数，并且为了保证全局只有一个实例，
需防止在外部调用类的构造函数而构造实例，需要将构造函数的访问权限标记为private，
同时阻止拷贝创建对象时赋值拷贝对象，因此也将它们声明并权限标记为private；
另外，需要提供一个全局访问点，就需要在类中定义一个static函数，返回在类内部唯一构造的实例。
观察者模式
观察者模式定义了对象间的一对多依赖关系，让一个或多个观察者对象观察一个主题对象。当主题对象的状态发生变化时，系统能通知所有的依赖于此对象的观察者对象，从而使得观察者对象能够自动更新。
实现方式：
a） 角色抽象类（提供对观察者的添加，删除和通知功能）。
b） 角色具体类，实现a，维护一个c的集合（对角色抽象类的实现）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/46a1ad510208dcd787ce22ec8003042c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-06T16:01:46+08:00" />
<meta property="article:modified_time" content="2022-10-06T16:01:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【秋招面试题】C&#43;&#43; 网络编程 面试题库（一）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E7%9B%AE%E5%BD%95">目录</h2> 
<p id="%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BD%9C%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BD%9C%E7%94%A8" rel="nofollow">一、线程池的设计及作用</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">二、线程和进程的区别</a></p> 
<p id="%E4%B8%89%E3%80%81C%2B%2B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81C%2B%2B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" rel="nofollow">三、C++ 设计模式</a></p> 
<p id="%E5%9B%9B%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F" rel="nofollow">四、进程间的通讯方式</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">五、引用和指针的区别</a></p> 
<p id="%E5%85%AD%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%C2%A0" rel="nofollow">六、构造函数和析构函数 </a></p> 
<p id="%E4%B8%83%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D" rel="nofollow">七、深拷贝和浅拷贝</a></p> 
<p id="%E5%85%AB%E3%80%81%E5%AF%B9%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%E5%85%AB%E3%80%81%E5%AF%B9%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3" rel="nofollow">八、对多态的理解</a></p> 
<p id="%E4%B9%9D%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B-toc" style="margin-left:0px;"><a href="#%E4%B9%9D%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B" rel="nofollow">九、数据结构有哪些</a></p> 
<p id="%E5%8D%81%E3%80%81socket%E5%8C%85%E5%AE%89%E5%85%A8-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E3%80%81socket%E5%8C%85%E5%AE%89%E5%85%A8" rel="nofollow">十、socket包安全</a></p> 
<p id="%E5%8D%81%E4%B8%80%E3%80%81new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%B8%80%E3%80%81new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">十一、new和malloc的区别</a></p> 
<p id="%E5%8D%81%E4%BA%8C%E3%80%81epoll%E7%9A%84%20LT%E5%92%8C%20ET%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%BA%8C%E3%80%81epoll%E7%9A%84%20LT%E5%92%8C%20ET%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3" rel="nofollow">十二、epoll的 LT 和 ET 模式的理解</a></p> 
<p id="%E5%8D%81%E4%B8%89%E3%80%81TCP%2FUPD%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%B8%89%E3%80%81TCP%2FUPD%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">十三、TCP/UPD的区别</a></p> 
<p id="%E5%8D%81%E5%9B%9B%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E5%9B%9B%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B" rel="nofollow">十四、三次握手和四次挥手</a></p> 
<p id="%E5%8D%81%E4%BA%94%E3%80%81socket%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E7%82%B9-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%BA%94%E3%80%81socket%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E7%82%B9" rel="nofollow">十五、socket的概念和特点</a></p> 
<p id="%E5%8D%81%E5%85%AD%E3%80%81gdb%E8%B0%83%E8%AF%95-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E5%85%AD%E3%80%81gdb%E8%B0%83%E8%AF%95" rel="nofollow">十六、gdb调试</a></p> 
<p id="%C2%A0%E5%8D%81%E4%B8%83%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%8D%81%E4%B8%83%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3" rel="nofollow"> 十七、面向对象的理解</a></p> 
<p id="%E5%8D%81%E5%85%AB%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E5%85%AB%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">十八、虚函数的作用</a></p> 
<p id="%E5%8D%81%E4%B9%9D%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%B9%9D%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB%C2%A0" rel="nofollow">十九、类和对象的关系 </a></p> 
<p id="%E4%BA%8C%E5%8D%81%E3%80%81IO%E5%A4%8D%E7%94%A8%EF%BC%8Cepoll%E5%92%8Cselect%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8Copoll%E5%92%8Cselete%E7%9A%84%E7%89%B9%E7%82%B9-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8D%81%E3%80%81IO%E5%A4%8D%E7%94%A8%EF%BC%8Cepoll%E5%92%8Cselect%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8Copoll%E5%92%8Cselete%E7%9A%84%E7%89%B9%E7%82%B9" rel="nofollow">二十、IO复用，epoll和select的区别，opoll和selete的特点</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E4%B8%80%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8D%81%E4%B8%80%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1" rel="nofollow">二十一、客户端与服务器如何通信</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%81%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%81%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">二十二、堆和栈的区别</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E4%B8%89%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8D%81%E4%B8%89%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">二十三、结构体和类的区别</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E5%9B%9B%E3%80%81STL%E4%B8%AD%E7%9A%84vector%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8D%81%E5%9B%9B%E3%80%81STL%E4%B8%AD%E7%9A%84vector%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0" rel="nofollow">二十四、STL中的vector如何实现</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8" rel="nofollow">二十五、如何保证线程的安全</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E5%85%AD%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8D%81%E5%85%AD%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">二十六、数组和链表的区别</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E4%B8%83%E3%80%81boost%E5%BA%93%E6%98%AF%E5%90%A6%E6%9C%89%E4%BA%86%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8D%81%E4%B8%83%E3%80%81boost%E5%BA%93%E6%98%AF%E5%90%A6%E6%9C%89%E4%BA%86%E8%A7%A3" rel="nofollow">二十七、boost库是否有了解</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81socket%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9socket-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81socket%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9socket" rel="nofollow">二十八、socket的工作模式，为什么选择socket</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E4%B9%9D%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8D%81%E4%B9%9D%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5" rel="nofollow">二十九、长连接和短连接</a></p> 
<p id="%E4%B8%89%E5%8D%81%E3%80%81socket%E4%B8%AD%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E5%8D%81%E3%80%81socket%E4%B8%AD%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">三十、socket中阻塞和非阻塞的区别</a></p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BD%9C%E7%94%A8">一、线程池的设计及作用</h2> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>线程池的作用：</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">线程池是为了解决线程在程序中因频繁创建和销毁而消耗大量时间而存在的</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">，</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">即在程序开始正式任务之前，先创建出一些线程，这些线程在程序不会被销毁，而且程序在运行中也不会再去创建线程。这样在程序的运行期间就提高了效率。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>线程池的设计思路：</strong></span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">先创建出一组线程，</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">当有新任务进来时就从线程池中取出空闲线程处理任务，任务完成之后又重新放回去，当线程池中的所有线程都在任务时，只能等待有线程结束任务才能继续执行。</span></span></p> 
<h2 id="%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB" style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">二、线程和进程的区别</span></span></h2> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">根本区别：</span></span></span></strong><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">进程是操作系统资源分配的基本单位，而线程是</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">CPU</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">任务调度和执行的基本单位</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>所处环境：</strong>在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>内存分配方面：</strong>系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">包含关系：</span></span></strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">一个线程只能属于一个进程，但是一个进程可以拥有多个线程。多线程处理就是允许一个进程中在同一时刻执行多个任务。</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">所以线程也被称为轻权进程或者轻量级进程。</span></span></span></p> 
<h2 id="%E4%B8%89%E3%80%81C%2B%2B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" style="text-align:left;"><strong>三、C++ 设计模式</strong></h2> 
<p style="text-align:justify;"><strong>单例模式</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">概念：是指在内存中只会创建且仅创建一次对象的设计模式</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">优点</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">：</span></span></strong> </p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">1.</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">保证一个类只有一个实例，并提供一个访问它的全局访问点，使</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">得系统中只有唯一的一个对象实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例 </span></span></p> 
<p style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">2.由于在系统内存中只存在一个对象，因此可以节约系统资源</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">、</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">提高系统的性能。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">缺点：</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">就是不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。</span></span></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">实现要点：</span></span></span></strong></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">在类中，要构造一个实例，就必须调用类的构造函数，并且为了保证全局只有一个实例，</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">需防止在外部调用类的构造函数而构造实例，需要将构造函数的访问权限标记为private，</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">同时阻止拷贝创建对象时赋值拷贝对象，因此也将它们声明并权限标记为private；</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">另外，需要提供一个全局访问点，就需要在类中定义一个static函数，返回在类内部唯一构造的实例。</span></span></span></p> 
<p style="text-align:justify;"><strong>观察者模式</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">观察者模式定义了对象间的一对多依赖关系，让一个或多个观察者对象观察一个主题对象。当主题对象的状态发生变化时，系统能通知所有的依赖于此对象的观察者对象，从而使得观察者对象能够自动更新。</span></span></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">实现方式：</span></span></span></strong></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">a） 角色抽象类（提供对观察者的添加，删除和通知功能）。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">b） 角色具体类，实现a，维护一个c的集合（对角色抽象类的实现）。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">c）  观察者抽象类（被角色通知后实现的方法）。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">d） 观察者实现类，实现c（多个）。</span></span></span></p> 
<p style="text-align:justify;"><strong>工厂模式</strong></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">工厂模式包括三种：简单工厂模式、工厂方法模式、抽象工厂模式。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">工厂模式的主要作用是封装对象的创建，分离对象的创建和操作过程，用于批量管理对象的创建过程，便于程序的维护和扩展。</span></span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">简单工厂是工厂模式最简单的一种实现，对于不同产品的创建定义一个工厂类，将产品的类型作为参数传入到工厂的创建函数，根据类型分支选择不同的产品构造函数。</span></span></p> 
<h2 id="%E5%9B%9B%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F" style="text-align:left;"><strong>四、进程间的通讯方式</strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>管道：</strong>数据只能单向流动，<span style="background-color:#ffffff;"><span style="color:#4b4b4b;">速度慢，容量有限，只有父子进程能通讯</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>消息队列：</strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>共享内存：</strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">映射一段能被其他进程访问的内存，这段内存由一个进程创建，但多个进程都可以访问；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>信号量：</strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">是一个计数器，用于控制多个进程间对共享资源的访问；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>套接字：</strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">用于不同计算机之间的不同进程间通信</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">。</span></span></p> 
<h2 id="%E4%BA%94%E3%80%81%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB" style="text-align:left;"><strong>五、引用和指针的区别</strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>本质：</strong>引用是别名，指针是地址</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>相同点：</strong></span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">都是地址的概念；</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。</span></span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">不同点：</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#333333;">1.</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">引用不可以为空，但指针可以为空</span></span> ，<span style="background-color:#ffffff;"><span style="color:#333333;">故定义一个引用的时候，必须初始化</span></span></p> 
<p style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#333333;">2.引用不可以改变指向，对一个对象"至死不渝"；但是指针可以改变指向，而指向其它对象</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">，</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">虽然引用不可以改变指向，但是可以改变初始化对象的内容</span></span></p> 
<p style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#333333;">3.引用的大小是所指向的变量的大小，因为引用只是一个别名而已；指针是指针本身的大小，4个字节</span></span></p> 
<p style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#333333;">4.引用比指针更安全。由于不存在空引用，并且引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用，因此引用很安全。对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为NULL，所以不安全。</span></span></p> 
<p style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#333333;">5.引用仅在声明时带有引用运算符“&amp;”，以后像普通变量一样使用，不能再带“&amp;”，其它场合使用的“&amp;”都是地址操作符</span></span>。</p> 
<h2 id="%E5%85%AD%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%C2%A0"><strong>六、构造函数和析构函数</strong> </h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#333333;"><strong>构造函数的作用：</strong></span></span><span style="background-color:#ffffff;"><span style="color:#333333;">用于新建对象的初始化工作。</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">（</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">一个类可以有多个构造函数，构造函数可以重载，不可以加虚函数</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">）</span></span><br><span style="background-color:#ffffff;"><span style="color:#333333;"><strong>析构函数的作用：</strong></span></span><span style="background-color:#ffffff;"><span style="color:#333333;">用于在撤销对象前，完成一些清理工作，比如：释放内存等。</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">（</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">一个类只能有一个析构函数，不可以重载</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">）</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">拷贝构造函数：</span></span></strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">拷贝构造函数是一种特殊的构造函数，函数的名称必须和类名称一致，它的唯一的一个参数是本类型的一个引用变量，该参数是const类型，不可变的。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h2 id="%E4%B8%83%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D" style="text-align:left;"><strong>七、深拷贝和浅拷贝</strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>浅拷贝：</strong>浅拷贝是对指针进行拷贝，拷贝后两个指针指向同一块内存空间。C++中如果不定义类的</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">赋值</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">构造函数，就会调用类的默认</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">赋值</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">构造函数，而类的</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">赋值</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">构造函数是浅拷贝。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>深拷贝：</strong>深拷贝是对指针进行拷贝而且还对内容进行拷贝，拷贝完成后，指</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">针</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">指向的地址不一样，但是值是一样的。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>浅拷贝和深拷贝的区别：</strong>前者就是使用编译器提供的默认拷贝构造函数或者默认赋值构造函数。后者是自己显示实现的拷贝/赋值构造函数。</span></span></p> 
<h2 id="%E5%85%AB%E3%80%81%E5%AF%B9%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3" style="text-align:left;"><strong>八、对多态的理解</strong></h2> 
<p style="margin-left:.0001pt;text-align:left;">C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类类，别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。</p> 
<p style="margin-left:.0001pt;text-align:justify;">多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。</p> 
<p style="text-align:left;"><strong>多态的条件：</strong></p> 
<p style="text-align:left;">1.必须有继承</p> 
<p style="text-align:left;">2.要有虚函数重写</p> 
<p style="text-align:justify;">3.用父类指针（引用）指向子类对象</p> 
<p style="margin-left:.0001pt;text-align:left;"><strong>多态的基础理论：</strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong>联编：</strong>一个程序模块，代码之间互相关联的过程</p> 
<p style="margin-left:.0001pt;text-align:left;"><strong>动态联编：</strong>把程序联编的过程，推迟到运行时进行</p> 
<p style="margin-left:.0001pt;text-align:left;"><strong>静态联编</strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong>多态的实现效果：</strong></p> 
<p style="margin-left:.0001pt;text-align:left;">同样的调用语句，不同的表现形态</p> 
<p style="margin-left:.0001pt;text-align:left;"><strong>多态的意义：</strong>设计模式的基础、编写框架的基础、函数指针做函数参数</p> 
<h2 id="%E4%B9%9D%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B" style="text-align:left;"><strong>九、数据结构有哪些</strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">什么是数据结构:</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。</span></span> <br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>常用的数据结构有：</strong>数组，栈，链表，队列，树，图，堆，散列表等。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">数组：</span></span></strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">数组是可以</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">在</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">栈：</span></span></strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">队列：</span></span></strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">链表：</span></span></strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。</span></span> </p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">树：</span></span></strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。</span></span></p> 
<h2 id="%E5%8D%81%E3%80%81socket%E5%8C%85%E5%AE%89%E5%85%A8" style="text-align:left;"><strong>十、socket包安全</strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">TCP是一个基于字节流的传输服务，"流"意味着TCP所传输的数据是没有边界的。这不同于UDP提供基于消息的传输服务，其传输的数据是有边界的。TCP的发送方无法保证对等方每次接收到的是一个完整的</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">数据包。</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">就会出现分包或粘包的问题.</span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>分包：</strong>传输数据不完整，一条信息被分成多次发送。 </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">比如我们发送了一条信息：“你好”，我们可能只收到了“你”，却没有收到“好”，这样就会导致数据的不完整。 </span></span><br><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">粘包</span></span></strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">：传输的多条数据粘在一起，比如我发了“你好”和“我是小胖”，我们可能会收到“你好我是小胖”，也可</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">能收到“你好我是”“你好我”“你好我是小”，后几种情况是分包粘包同时发生，我们肯定不期望这种现象发生，所以我们就有必要对我们发送的数据进行编辑。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">Socket只是一种通信手段它本身没有任何额外的安全措施，所以要用到加密技术 ，不然通信的数据非常容易初攻击者获取到</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">,</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">一般情况下，我们会使用CRC进行冗余验证，看数据包是否传输完整，然后自定义自己的加密方式，将数据包加密以后再发出，有的项目还会对数据包进行压缩，所以我们这里给出一种通用的结构：</span></span><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">数据头（长度）+冗余验证（CRC）+是否压缩+包体（加密后）。</span></span></strong> </p> 
<h2 id="%E5%8D%81%E4%B8%80%E3%80%81new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB" style="text-align:left;"><strong>十一、new和malloc的区别</strong></h2> 
<table border="1" cellspacing="0" style="margin-left:6.75pt;"><tbody><tr><td style="vertical-align:top;width:66.55pt;"> <p style="margin-left:.0001pt;text-align:justify;">区别</p> </td><td style="vertical-align:top;width:173.05pt;"> <p style="margin-left:.0001pt;text-align:justify;">New 和delete</p> </td><td style="vertical-align:top;width:186.5pt;"> <p style="margin-left:.0001pt;text-align:justify;">malloc和free</p> </td></tr><tr><td style="vertical-align:top;width:66.55pt;"> <p style="margin-left:.0001pt;text-align:justify;">属性</p> </td><td style="vertical-align:top;width:173.05pt;"> <p style="margin-left:.0001pt;text-align:justify;">C++编译器支持</p> </td><td style="vertical-align:top;width:186.5pt;"> <p style="margin-left:.0001pt;text-align:justify;">库函数、头文件支持C</p> </td></tr><tr><td style="vertical-align:top;width:66.55pt;"> <p style="margin-left:.0001pt;text-align:justify;">参数</p> </td><td style="vertical-align:top;width:173.05pt;"> <p style="margin-left:.0001pt;text-align:justify;">申请内存无需指定内存大小</p> </td><td style="vertical-align:top;width:186.5pt;"> <p style="margin-left:.0001pt;text-align:justify;">显式指定大小</p> </td></tr><tr><td style="vertical-align:top;width:66.55pt;"> <p style="margin-left:.0001pt;text-align:justify;">返回值</p> </td><td style="vertical-align:top;width:173.05pt;"> <p style="margin-left:.0001pt;text-align:justify;">对象类型的指针</p> </td><td style="vertical-align:top;width:186.5pt;"> <p style="margin-left:.0001pt;text-align:justify;">泛型，void*类型，再转换为需要的类型</p> </td></tr><tr><td style="vertical-align:top;width:66.55pt;"> <p style="margin-left:.0001pt;text-align:justify;">内存区域</p> </td><td style="vertical-align:top;width:173.05pt;"> <p style="margin-left:.0001pt;text-align:justify;">自由存储区</p> </td><td style="vertical-align:top;width:186.5pt;"> <p style="margin-left:.0001pt;text-align:justify;">堆上动态分配内存</p> </td></tr></tbody></table> 
<h2 id="%E5%8D%81%E4%BA%8C%E3%80%81epoll%E7%9A%84%20LT%E5%92%8C%20ET%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3" style="text-align:left;"><strong>十二、epoll的 LT 和 ET 模式的理解</strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;">epoll 对文件描述符的操作有两种模式：LT（level trigger）和 ET（edge trigger）。LT 模式是默认模式，LT 模式与 ET 模式的区别如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;">LT 模式：支持block和no-block socket。当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。效率会低于ET触发，尤其在大并发，大流量的情况下。但是LT对代码编写要求比较低，不容易出现问题。LT模式服务编写上的表现是：只要有数据没有被获取，内核就不断通知你，因此不用担心事件丢失的情况。</p> 
<p style="margin-left:.0001pt;text-align:justify;">ET 模式：只支持no-block socket。当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此事件。该模式效率非常高，尤其在高并发，大流量的情况下，会比LT少很多epoll的系统调用。但是对编程要求高，需要细致的处理每个请求，否则容易发生丢失事件的情况。</p> 
<h2 id="%E5%8D%81%E4%B8%89%E3%80%81TCP%2FUPD%E7%9A%84%E5%8C%BA%E5%88%AB" style="text-align:left;"><strong>十三、TCP/UPD的区别</strong></h2> 
<ul><li style="text-align:justify;"><span style="background-color:#ffffff;">TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，是专门为了在不可靠的网络中提供一个可靠的端对端字节流而设计的，面向字节流。</span></li><li style="text-align:justify;"><span style="background-color:#ffffff;">UDP（用户数据报协议）是iso参考模型中一种无连接的传输层协议，提供简单不可靠的非连接传输层服务，面向报文</span></li></ul> 
<p style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">区别：</span></span></strong></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">1） TCP是面向连接的，可靠性高；UDP是基于非连接的，可靠性低 </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">2） 由于TCP是连接的通信，需要有三次握手、重新确认等连接过程，会有延时，实时性差，同时过程复杂，也使其易于攻击；UDP没有建立连接的过程，因而实时性较强，也稍安全 </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">3） 在传输相同大小的数据时，TCP首部开销20字节；UDP首部开销8字节，TCP报头比UDP复杂，故实际包含的用户数据较少。TCP在IP协议的基础上添加了序号机制、确认机制、超时重传机制等，保证了传输的可靠性，不会出现丢包或乱序，而UDP有丢包，故TCP开销大，UDP开销较小 </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">4） 每条TCP连接只能</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">是</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">点到点的；UDP支持一对一、一对多、多对一、多对多的交互通信</span></span></span></p> 
<p style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">应用场景选择:</span></span></strong></span></p> 
<ul><li style="text-align:justify;"><span style="background-color:#ffffff;">对实时性要求高和高速传输的场合下使用UDP;在可靠性要求低，追求效率的情况下使用UDP;</span></li><li style="text-align:justify;"><span style="background-color:#ffffff;">需要传输大量数据且对可靠性要求高的情况下使用TCP</span></li></ul> 
<h2 id="%E5%8D%81%E5%9B%9B%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B" style="text-align:left;"><strong>十四、三次握手和四次挥手</strong></h2> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">三次握手：客户端和服务端建立连接需要三次握手 </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">第一次：客户端向服务端发送报文，向服务器发送连接请求； </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">第二次：服务端向客户端返回ACK报文，通知客户端可以连接； </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">第三次：客户端收到服务端报文，正式连接服务端。 </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">三次握手完成。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">四次挥手：客户端要与服务器断开连接，需要四次挥手 </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">第一次：客户端向服务端发送FIN报文，向服务器发送中断连接请求； </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">第二次：服务器收到客户端中断请求，向客户端发送已得知中断请求，但服务器还有资源未处理，需要等待； </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">第三次：服务器处理完数据后，再次向客户端发送报文，告诉客户端可以断开连接了； </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">第四次：客户端收到服务端断开连接的确认信息后，最后发送信息看是否真的断开连接了，如果服务器一段时间没有回应，则说明已经断开，中断过程完成； </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">四次挥手完成。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"></p> 
<h2 id="%E5%8D%81%E4%BA%94%E3%80%81socket%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E7%82%B9" style="text-align:left;"><strong>十五、socket的概念和特点</strong></h2> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">socket</span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">概念</span></span></strong><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">: </span></span></strong></span></p> 
<p style="margin-left:0;text-align:left;"> <span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">这是为了实现以上的通信过程而建立成来的通信管道，其真实的代表是客户端和服务器端的一个通信进程，双方进程通过socket进行通信，而通信的规则采用指定的协议。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">socket只是一种连接模式，不是协议，socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。tcp、udp，简单的说（虽然不准确）是两个最基本的协议,很多其它协议都是基于这两个协议如，http就是基于tcp的，.用socket可以创建tcp连接，也可以创建udp连接。</span></span></span> </p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">Socket 传输的特点：</span></span></strong></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">优点:</span></span></strong></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"> 1)  传输数据为字节级，传输数据可自定义，数据量小（对于手机应用讲：费用低）</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"> 2）传输数据时间短，性能高</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"> 3）适合于客户端和服务器端之间信息实时交互</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"> 4）可以加密,数据安全性强</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><br><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">缺点：</span></span></strong></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">1）需对传输的数据进行解析，转化成应用级的数据</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">2）对开发人员的开发水平要求高</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">3）相对于Http协议传输，增加了开发量</span></span></span></p> 
<h2 id="%E5%8D%81%E5%85%AD%E3%80%81gdb%E8%B0%83%E8%AF%95" style="text-align:left;"><strong>十六、gdb调试</strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">进入gdb后可直接在(gdb)后输入相应命令进行调试操作。</span></span></p> 
<ol><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">启动gdb</span></span></li><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">查看源码 list</span></span></li><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">运行程序 run</span></span></li><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">设置断点 break</span></span></li><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">单步执行 continue、step、next</span></span></li><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">查看变量 printf</span></span></li><li style="text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">退出调试 quit</span></span></li></ol> 
<h2 id="%C2%A0%E5%8D%81%E4%B8%83%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"> 十七、面向对象的理解</h2> 
<ol><li style="text-align:justify;">面向对象</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">   特点：被动的去实现，分解成一个个的对象</p> 
<p style="margin-left:.0001pt;text-align:justify;">   由现实的世界建立的软件模型</p> 
<p style="margin-left:.0001pt;text-align:justify;">   优点：效率高、易维护、易复用、易扩展</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>缺点：</strong>类调用时需要实例化，开销比较大</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>面向对象：</strong>面向对象编程就是把问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。</p> 
<p style="margin-left:.0001pt;text-align:justify;">面向对象就是高度实物抽象化（功能划分）、面向过程就是自顶向下的编程（步骤划分）</p> 
<h2 id="%E5%8D%81%E5%85%AB%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8" style="text-align:left;"><strong>十八、虚函数的作用</strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>虚函数的作用：</strong>用专业术语来解释就是实现多态性（Polymorphism），多态性是将接口与实现进行分离；用形象的语言来解释就是实现以共同的方法，但因个体差异而采用不同的策略。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>虚函数的实现：</strong>在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</span></span></p> 
<h2 id="%E5%8D%81%E4%B9%9D%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB%C2%A0">十九、类和对象的关系 </h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">类是对象的概括，对象是类的具体体现</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">1）</span><span style="color:#494949;"><strong>对象：</strong></span><span style="color:#4d4d4d;">对象是运行期的基本实体，它是一个封装了数据和操作这些数据的代码的逻辑实体。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">2）</span></span><span style="color:#494949;"><strong><span style="background-color:#ffffff;">类</span></strong></span><span style="background-color:#ffffff;"><span style="color:#494949;">：</span><span style="color:#4d4d4d;">类是具有相同类型的对象的抽象。一个对象所包含的所有数据和代码可以通过类来构造。</span></span></span></p> 
<h2 id="%E4%BA%8C%E5%8D%81%E3%80%81IO%E5%A4%8D%E7%94%A8%EF%BC%8Cepoll%E5%92%8Cselect%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8Copoll%E5%92%8Cselete%E7%9A%84%E7%89%B9%E7%82%B9">二十、<strong>IO复用，epoll和select的区别，opoll和selete的特点</strong></h2> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">I/O 多路复用是为了解决进程或线程阻塞到某个 I/O 系统调用而出现的技术，使进程或线程不阻塞于某个特定的 I/O 系统调用。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">select()，poll()，epoll()都是I/O多路复用的机制。I/O多路复用通过一种机制，</span></span><span style="color:#494949;"><strong><span style="background-color:#ffffff;">可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪，就是这个文件描述符进行读写操作之前），能够通知程序进行相应的读写操作</span></strong><span style="background-color:#ffffff;">。</span></span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>epoll:</strong></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就需态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">epoll的优点：</span></span></span></strong></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">1、没有最大并发连接的限制，</span></span></strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；</span></span><br><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">2、效率提升</span></span></strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">3、 内存拷贝</span></span></strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</span></span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>Selete：</strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">select 的核心功能是调用tcp文件系统的poll函数，不停的查询，如果没有想要的数据，主动执行一次调度（防止一直占用cpu），直到有一个连接有想要的消息为止。从这里可以看出select的执行方式基本就是不同的调用poll,直到有需要的消息为止。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">缺点：</span></span></strong></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">1、每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">2、同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大；</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">3、select支持的文件描述符数量太小了，默认是1024。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">优点：</span></span></strong></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">1、select的可移植性更好，在某些Unix系统上不支持poll()。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">2、select对于超时值提供了更好的精度：微秒，而poll是毫秒。</span></span></span></p> 
<h2 id="%E4%BA%8C%E5%8D%81%E4%B8%80%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1">二十一、客户端与服务器如何通信</h2> 
<p style="margin-left:.0001pt;text-align:justify;">1.服务器先用socket（）函数来建立一个套接字，用这个套接字完成通信的监听和数据的收发<br> 2.服务器用bind（）函数来绑定一个端口号和IP地址，使套接字与指定的端口号和IP地址相关联<br> 3.用服务器调用listen（）函数，使服务器的这个端口和IP处于监听状态，等待网络中某一客户机的请求发送<br> 4.客户机用socket（）函数建立一个套接字，设定远程IP和端口<br> 5.客户机调用connect（）函数连接远程计算机指定的端口。<br> 6.服务器调用accept（）函数来接受远程计算机的请求，建立与客户机之间的通信连接<br> 7.建立连接以后，客户机用write（）函数或者close（）函数向socket中写入数据，也可以用read（）函数读区服务器发来的数据<br> 8.服务器用read（）函数读区客户机发来的数据，也可以用write（）函数或者send（）函数来发送数据<br> 9.通信完成以后，使用close（）函数关闭socket连接</p> 
<h2 id="%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%81%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB">二十二、堆和栈的区别</h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：</span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">（2）空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。</span></span></span> </p> 
<h2 id="%E4%BA%8C%E5%8D%81%E4%B8%89%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB">二十三、<strong>结构体和类的区别</strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;">最本质的一个区别就是默认的访问控制： <br> 默认的继承访问权限 <br> struct是public的，class是private的。</p> 
<h2 id="%E4%BA%8C%E5%8D%81%E5%9B%9B%E3%80%81STL%E4%B8%AD%E7%9A%84vector%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0">二十四、<strong>STL中的vector如何实现</strong></h2> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准程序库中，包括容器、算法、迭代器组件。</span></span> <br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">vector内部使用动态数组的方式实现的。如果动态数组的内存不够用，就要动态的重新分配，一般是当前大小的两倍，然后把原数组的内容拷贝过去。所以，在一般情况下，其访问速度同一般数组，只有在重新分配发生时，其性能才会下降。注意vector的size()和capacity()是不同的，前者表示数组中元素的多少，后者表示数组有多大的容量。由上面的分析可以看出，使用vector的时候需要注意内存的使用，如果频繁地进行内存的重新分配，会导致效率低下。它的内部使用allocator类进行内存管理，程序员不需要自己操作内存。</span></span> </p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">vector其中一个特点：内存空间只会增长，不会减小，援引C++ Primer：为了支持快速的随机访问，vector容器的元素以连续方式存放，每一个元素都紧挨着前一个元素存储。设想一下，当vector添加一个元素时，为了满足连续存放这个特性，都需要重新分配空间、拷贝元素、撤销旧空间，这样性能难以接受。因此STL实现者在对vector进行内存分配时，其实际分配的容量要比当前所需的空间多一些。就是说，vector容器预留了一些额外的存储区，用于存放新添加的元素，这样就不必为每个新元素重新分配整个容器的内存空间。</span></span></p> 
<h2 id="%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8">二十五、如何保证线程的安全</h2> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">在大多数软件应用中，线程的数量都不止一个，多线程程序处在一个多变的环境中，可访问的全局变量和堆数据随时都可能被其他的线程改变，这就将“线程安全”的问题提上了议程。那么，如何确保线程的安全呢？</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">线程安全</span></span></strong><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">一般说来，确保线程安全的方法有这几个：</span></span><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">竞争与原子操作、同步与锁、可重入、过度优化</span></span></strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">竞争与原子操作</span></span></strong><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">多个线程同时访问和修改一个数据，可能造成很严重的后果。出现严重后果的原因是很多操作被操作系统编译为汇编代码之后不止一条指令，因此在执行的时候可能执行了一半就被调度系统打断了而去执行别的代码了。一般将单指令的操作称为原子的(Atomic)，因为不管怎样，单条指令的执行是不会被打断的。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">因此，为了避免出现多线程操作数据的出现异常，Linux系统提供了一些常用操作的原子指令，确保了线程的安全。但是，它们只适用于比较简单的场合，在复杂的情况下就要选用其他的方法了。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">同步与锁</span></span></strong><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">为了避免多个线程同时读写一个数据而产生不可预料的后果，开发人员要将各个线程对同一个数据的访问同步，也就是说，在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">同步的最常用的方法是使用锁(Lock)，它是一种非强制机制，每个线程在访问数据或资源之前首先试图获取锁，并在访问结束之后释放锁；在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新可用。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">二元信号量是最简单的一种锁，它只有两种状态：占用与非占用，它适合只能被唯一一个线程独占访问的资源。对于允许多个线程并发访问的资源，要使用多元信号量(简称信号量)。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">可重入</span></span></strong><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">一个函数被重入，表示这个函数没有执行完成，但由于外部因素或内部因素，又一次进入该函数执行。一个函数称为可重入的，表明该函数被重入之后不会产生任何不良后果。可重入是并发安全的强力保障，一个可重入的函数可以在多线程环境下放心使用。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">过度优化</span></span></strong><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">在很多情况下，即使我们合理地使用了锁，也不一定能够保证线程安全，因此，我们可能对代码进行过度的优化以确保线程安全。</span></span></span></p> 
<h2 id="%E4%BA%8C%E5%8D%81%E5%85%AD%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB">二十六、数组和链表的区别</h2> 
<p id="%E6%95%B0%E7%BB%84" style="margin-left:0pt;text-align:left;"><strong><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">数组</span></span></span></strong></p> 
<p style="margin-left:0pt;text-align:left;"><span style="color:#494949;"><strong>数组的特点：</strong></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">1.在内存中，数组是一块连续的区域</span></span> <br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">2.数组需要预留空间</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">在使用前需要提前申请所占内存的大小，这样不知道需要多大的空间，就预先申请可能会浪费内存空间，即数组空间利用率低 </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>ps：</strong>数组的空间在编译阶段就需要进行确定，所以需要提前给出数组空间的大小（在运行阶段是不允许改变的）</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">3.在数组起始位置处，插入数据和删除数据效率低。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">插入数据时，待插入位置的的元素和它后面的所有元素都需要向后搬移 </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">删除数据时，待删除位置后面的所有元素都需要向前搬移</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">4.随机访问效率很高，时间复杂度可以达到O(1)</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">因为数组的内存是连续的，想要访问那个元素，直接从数组的首地址处向后偏移就可以访问到了</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">5.数组开辟的空间，在不够使用的时候需要扩容，扩容的话，就会涉及到需要把旧数组中的所有元素向新数组中搬移 </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">6.数组的空间是从栈分配的</span></span></span></p> 
<p><span style="color:#494949;"><strong>数组的优点：</strong></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">随机访问性强</span></span><span style="background-color:#eef0f4;"><span style="color:#555666;">，</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">查找速度快，时间复杂度为O(1)</span></span></p> 
<p><span style="color:#494949;"><strong>数组的缺点：</strong></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">1.头插和头删的效率低，时间复杂度为O(N) </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">2.空间利用率不高 </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">3.内存空间要求高，必须有足够的连续的内存空间 </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">4.数组空间的大小固定，不能动态拓展</span></span></p> 
<p id="%E9%93%BE%E8%A1%A8" style="margin-left:0pt;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">链表</span></span></strong></span></p> 
<p><span style="color:#494949;"><strong>链表的特点：</strong></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">1.在内存中，元素的空间可以在任意地方，空间是分散的，不需要连续 </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">2.链表中的元素都会两个属性，一个是元素的值，另一个是指针，此指针标记了下一个元素的地址</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">每一个数据都会保存下一个数据的内存的地址，通过此地址可以找到下一个数据</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">3.查找数据时效率低,时间复杂度为O(N)</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">因为链表的空间是分散的，所以不具有随机访问性，如要需要访问某个位置的数据，需要从第一个数据开始找起，依次往后遍历，直到找到待查询的位置，故可能在查找某个元素时，时间复杂度达到O(N)</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">4.空间不需要提前指定大小，是动态申请的，根据需求动态的申请和删除内存空间，扩展方便，故空间的利用率较高 </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">5.任意位置插入元素和删除元素效率较高，时间复杂度为O(1) </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">6.链表的空间是从堆中分配的</span></span></p> 
<p><span style="color:#494949;"><strong>链表的优点：</strong></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">1.任意位置插入元素和删除元素的速度快，时间复杂度为O(1) </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">2.内存利用率高，不会浪费内存 </span></span><br><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">3.链表的空间大小不固定，可以动态拓展</span></span></p> 
<p><span style="color:#494949;"><strong>链表的缺点：</strong></span></p> 
<p>随机访问效率低，时间复杂度为0(N) </p> 
<p> </p> 
<h2 id="%E4%BA%8C%E5%8D%81%E4%B8%83%E3%80%81boost%E5%BA%93%E6%98%AF%E5%90%A6%E6%9C%89%E4%BA%86%E8%A7%A3" style="text-align:left;">二十七、<strong>boost库是否有了解</strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">boost库是一个优秀的。可移植，开源的C++库，它是由C++标准委员会库工作自成员发起，它是对STL的延续和扩充，设计理念和STL比较接近，都是利用泛型让复用达到最大化，其中有些内容经常成为下一代C++标准库内容，在C++社区影响很大，是不折不扣的“准”标准库。</span></span></p> 
<p> </p> 
<h2 id="%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81socket%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9socket">二十八、<strong>socket的工作模式，为什么选择socket</strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">socket是对tcp/ip协议的封装和应用，给我们提供了操作网络的接口</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>工作模式：</strong></span></span></strong></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>阻塞模式：</strong>是socket的缺省方式，也是最常用的方式，即函数阻塞直到调用完毕。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">可能造成阻塞的函数有：connect()、accept()、读写函数、select()、poll()等。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">非阻塞模式：</span></span></strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">非阻塞IO通过进程反复调用IO函数（多次系统调用，并马上返回）；在数据拷贝的过程中，进程是阻塞的；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>I/O多路复用（同步I/O模式）：</strong>使用select()、poll()等函数实现对多个socket的同步I/O操作。它能同时等待多个socket描述符，而这些socket描述符其中的任意一个进入读就绪/写就绪/出错状态</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">为什么选择socket?</span></span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">应用层通过传输层进行数据通信时，TCP和UDP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了称为套接字(Socket)的接口，区分不同应用程序进程间的网络通信和连接。 </span></span></p> 
<h2 id="%E4%BA%8C%E5%8D%81%E4%B9%9D%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5">二十九、<strong>长连接和短连接</strong></h2> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">短连接</span></span></strong></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">连接-&gt;传输数据-&gt;关闭连接</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束后就中断连接。短连接是指SOCKET连接后发送后接收完数据后马上断开连接。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">长连接</span></span></strong></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">连接-&gt;传输数据-&gt;保持连接-&gt;传输数据-&gt;....-&gt;关闭连接</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。</span></span></span></p> 
<h2 id="%E4%B8%89%E5%8D%81%E3%80%81socket%E4%B8%AD%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB">三十、<strong>socket中阻塞和非阻塞的区别</strong></h2> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">非阻塞模式可以理解为，执行此套接字的网络调用时，不管是否执行成功，都会立即返回。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">如调用recv( )函数读取网络缓冲区中的数据时，不管是否读到数据都立即返回，而不会一直挂在此函数的调用上。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">而阻塞模式为只有接收到数据后才会返回，套接字默认的会创建堵塞模式。</span></span></span></p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/56f56d07d907906cd166066591648706/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">为什么你学不会递归？谈谈我的经验</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6ed1c7611ad50e4995dcf05cc2fbdb39/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Airtest</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>