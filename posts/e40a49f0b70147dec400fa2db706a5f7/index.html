<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python学习笔记2 序列概述——列表、元组和字符串 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python学习笔记2 序列概述——列表、元组和字符串" />
<meta property="og:description" content="1. 序列概述 数据结构是以某种方式（如通过编号）组合起来的数据元素（如数、字符乃至其他数据结构）集合。（A data structure is a specialized format for organizing and storing data.）
在Python中，最基本的数据结构为序列（sequence）。序列中的每个元素都有编号，即其位置或索引，其中第一个元素的索引为0，第二个元素的索引为1，依此类推。
基本的序列包括：列表、元组、字符串。其中，列表和元组的主要不同在于，列表是可以修改的，而元组不可以。这意味着列表适用于需要中途添加元素的情形，而元组适用于出于某种考虑需要禁止修改序列的情形。
Python支持一种数据结构的基本概念，名为容器（container）。容器基本上就是可包含其他对象的对象。两种主要的容器是序列（如列表、元组、字符串）和映射（如字典）。在序列中，每个元素都有编号，而在映射中，每个元素都有名称（也叫键）。有一种既不是序列也不是映射的容器，它就是集合（set）。
2. 序列的通用操作 索引、切片、相加、相乘和成员资格检查适用于所有的序列。另外，Python还提供了一些内置函数，可用于确定序列的长度以及找出序列中最大和最小的元素。
2.1 索引 按照元素的编号来访问各个元素，即为索引（indexing）。序列从左向右，以0作为第一个元素的编号，编号依次递增；从右向左，以-1作为最后一个元素的编号，编号依次递减。
&gt;&gt;&gt; greeting = &#39;Hellow&#39; &gt;&gt;&gt; greeting[0] &#39;H&#39; &gt;&gt;&gt; greeting[-1] &#39;w&#39; &gt;&gt;&gt; &#39;Hellow&#39;[1] &#39;e&#39; &gt;&gt;&gt; fourth = input(&#39;Year:&#39;)[3] Year:2008 &gt;&gt;&gt; fourth &#39;8&#39; 2.2 切片 除使用索引来访问单个元素外，还可使用切片（slicing）来访问特定范围内的元素。
切片顾头不顾尾（例如[-3:-1]，无法索引到最后一个元素）；如果第一个索引指定的元素位于第二个索引指定的元素后面（如：[-3:0]，结果就为空序列）；简写的重要性，当冒号后不写任何内容时，切片直接结束于序列的末尾（例如索引最后三个元素:[-3:]）；步长，表示索引每次移动的方向和大小，为正时，表示向右移动，反之向左。当步长为负值时，第一个索引指定的元素可以位于第二个索引指定的元素后面，而上述[-3:0]结果为空序列的原因是该操作种默认是步长为正1，索引向右移动到达末尾，而无法到达第一个元素，返回空序列。 2.3 序列相加 可使用加法运算符拼接序列。
&gt;&gt;&gt; [1, 2, 3] &#43; [4, 5, 6] [1, 2, 3, 4, 5, 6] &gt;&gt;&gt; &#39;Hellow, &#39; &#43; &#39;World!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/e40a49f0b70147dec400fa2db706a5f7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-20T15:03:35+08:00" />
<meta property="article:modified_time" content="2020-08-20T15:03:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python学习笔记2 序列概述——列表、元组和字符串</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="color:#86ca5e;">1. 序列概述</span></h2> 
<p><strong>数据结构</strong>是以某种方式（如通过编号）组合起来的数据元素（如数、字符乃至其他数据结构）集合。（A data structure is a specialized format for organizing and storing data.）</p> 
<p><strong>在Python中，最基本的数据结构为序列（sequence）</strong>。序列中的每个元素都有编号，即其位置或索引，其中第一个元素的索引为0，第二个元素的索引为1，依此类推。</p> 
<p><strong>基本的序列包括：列表、元组、字符串。</strong>其中，<strong>列表和元组的主要不同在于，列表是可以修改的，而元组不可以</strong>。这意味着列表适用于需要中途添加元素的情形，而元组适用于出于某种考虑需要禁止修改序列的情形。</p> 
<blockquote> 
 <p><strong>Python支持一种数据结构的基本概念，名为容器（container）。容器基本上就是可包含其他对象的对象。</strong>两种主要的容器是序列（如列表、元组、字符串）和映射（如字典）。在序列中，每个元素都有编号，而在映射中，每个元素都有名称（也叫键）。有一种既不是序列也不是映射的容器，它就是集合（set）。</p> 
</blockquote> 
<h2><span style="color:#86ca5e;">2. 序列的通用操作</span></h2> 
<p><strong>索引、切片、相加、相乘和成员资格检查适用于所有的序列</strong>。另外，Python还提供了一些内置函数，可用于<strong>确定序列的长度以及找出序列中最大和最小的元素</strong>。</p> 
<h3>2.1 索引</h3> 
<p>按照元素的编号来访问各个元素，即为索引（indexing）。序列从左向右，以0作为第一个元素的编号，编号依次递增；从右向左，以-1作为最后一个元素的编号，编号依次递减。</p> 
<pre><code class="language-python">&gt;&gt;&gt; greeting = 'Hellow'
&gt;&gt;&gt; greeting[0]
'H'
&gt;&gt;&gt; greeting[-1]
'w'
&gt;&gt;&gt; 'Hellow'[1]
'e'
&gt;&gt;&gt; fourth = input('Year:')[3]
Year:2008
&gt;&gt;&gt; fourth
'8'</code></pre> 
<h3>2.2 切片</h3> 
<p>除使用索引来访问单个元素外，还可<strong>使用切片（slicing）来访问特定范围内的元素。</strong></p> 
<ol><li><strong>切片顾头不顾尾（例如[-3:-1]，无法索引到最后一个元素）；</strong></li><li><strong>如果第一个索引指定的元素位于第二个索引指定的元素后面（如：[-3:0]，结果就为空序列）；</strong></li><li><strong>简写的重要性，当冒号后不写任何内容时，切片直接结束于序列的末尾（例如索引最后三个元素:[-3:]）；</strong></li><li>步长，表示索引每次移动的方向和大小，为正时，表示向右移动，反之向左。当步长为负值时，<strong>第一个索引指定的元素可以位于第二个索引指定的元素后面，而上述[-3:0]结果为空序列的原因是该操作种默认是步长为正1，索引向右移动到达末尾，而无法到达第一个元素，返回空序列。</strong></li></ol> 
<h3>2.3 序列相加</h3> 
<p>可使用加法运算符拼接序列。</p> 
<pre><code class="language-python">&gt;&gt;&gt; [1, 2, 3] + [4, 5, 6]
[1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; 'Hellow, ' +  'World!'
'Hellow, World!'
# 虽然列表和字符串都是序列，但是一般不能拼接不同类型的序列
&gt;&gt;&gt; [1, 2, 3] + 'World'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can only concatenate list (not "str") to list
&gt;&gt;&gt; [1, 2, 3] + list('World')
[1, 2, 3, 'W', 'o', 'r', 'l', 'd']</code></pre> 
<h3>2.4 乘法</h3> 
<p>将序列与数x相乘时，将重复这个序列x次来创建一个新序列</p> 
<pre><code class="language-python">&gt;&gt;&gt; 'python'*5
'pythonpythonpythonpythonpython'
&gt;&gt;&gt; [666] * 5
[666, 666, 666, 666, 666]</code></pre> 
<p>创建一个包含是个元素的空列表。</p> 
<pre><code class="language-python">&gt;&gt;&gt; sequence = [None] * 10
&gt;&gt;&gt; sequence
[None, None, None, None, None, None, None, None, None, None]</code></pre> 
<h3>2.5 成员资格</h3> 
<p>要检查特定的值是否包含在序列中，可使用运算符in。它检查是否满足指定的条件，并返回相应的值：满足时返回True，不满足时返回False。这样的运算符称为布尔运算符，而前述真值称为布尔值。</p> 
<p>例子：从用户那里获取一个用户名和一个PIN码，并检查它们组成的列表是否包含在数据库（实际上也是一个列表）中。如果用户名-PIN码对包含在数据库中，就打印字符串'Accessgranted'</p> 
<pre><code class="language-python">&gt;&gt;&gt; database = [
...     ['albert', '1234'],
...     ['sunhao', '2333']
... ]
&gt;&gt;&gt; username = input('User name:')

&gt;&gt;&gt; pin = input('PIN code:')

&gt;&gt;&gt; if [username, pin] in database: print('Access granted')
</code></pre> 
<h3>2.6 长度、最大值和最小值</h3> 
<p>函数len返回序列包含的元素个数，而min和max分别返回序列中最小和最大的元素</p> 
<h2><span style="color:#86ca5e;">3 列表：Python的主力</span></h2> 
<h3><strong>3.1 列表的创建</strong></h3> 
<p>1. <strong>以<span style="color:#3399ea;"> [ ]</span> 括起来, 每个元素用'<span style="color:#3399ea;"> ,</span> '隔开</strong></p> 
<pre><code class="language-python">l1 = [1, 2, '太白']</code></pre> 
<p><strong>2. 使用字符串来创建列表，方式：函数list（实际上是一个类），将字符串转化为列表。</strong></p> 
<pre><code class="language-python"># 将字符串转化为字符列表
&gt;&gt;&gt; list('Hello')
['H', 'e', 'l', 'l', 'o']
</code></pre> 
<p>可将任何序列（而不仅仅是字符串）作为list的参数。</p> 
<p>另外，如果要<strong>将字符列表（如前述代码中的字符列表）转换为字符串</strong>，可使用下面的表达式：</p> 
<p><strong>         <span style="color:#3399ea;">   ''.join(somelist)</span></strong></p> 
<p>       其中somelist是要转换的列表。</p> 
<pre><code class="language-python">s3 = list('Hellow')
print(s3)
s4 =''.join(s3)
print(s4)</code></pre> 
<h3><strong>3. 2. 基本的列表操作</strong></h3> 
<p><strong>1. 列表的索引、切片</strong></p> 
<p><strong>同上序列概述。</strong></p> 
<p><span style="color:#f33b45;"><strong>2. 删除元素</strong></span></p> 
<ul><li><strong>pop 按照索引删除，默认为最后一个元素，返回值为删除的元素；注意：pop是唯一既修改列表又返回一个非None值的列表方法。</strong></li></ul> 
<pre><code class="language-python">l1 = ['alex', 'wusir', 'taibai', 'ritian']
print(l1.pop(0)) # 返回值为删除的元素
print(l1)
</code></pre> 
<ul><li><strong>remove 按照元素删除，用于删除第一个为指定值的元素；不同于pop的是，它修改列表，但不返回任何值。</strong></li></ul> 
<pre><code class="language-python">l1 = ['alex', 'wusir', 'taibai', 'ritian']
l1.remove('alex')
print(l1)</code></pre> 
<ul><li><strong>全部删除（清空</strong>）</li></ul> 
<pre><code class="language-python">l1 = ['alex', 'wusir', 'taibai', 'ritian']
l1.clear()
print(l1)</code></pre> 
<ul><li><strong>del  </strong> 
  <ul><li>可以按照索引删除 <pre><code class="language-python">&gt;&gt;&gt; name = ['sunhao', 'wangjingjing', 'sushi']
&gt;&gt;&gt; del name[2]
&gt;&gt;&gt; name
['sunhao', 'wangjingjing']</code></pre> </li><li>可以按照切片删除 <pre><code class="language-python">&gt;&gt;&gt; name = ['sunhao', 'wangjingjing', 'sushi']
&gt;&gt;&gt; del name[:2]</code></pre> <p> </p> </li><li>可以在内存级别删除整个列表  <pre><code class="language-python">l1 = ['alex', 'wusir', 'taibai', 'ritian']
del l1</code></pre> <p><strong>注意：</strong>python的del不同于C的free和C++的delete；由于python都是引用，而python有GC机制，所以，del语句作用在变量上，而不是数据对象上。</p> <pre><code class="language-python">&gt;&gt;&gt; a = 1 #对象1被变量a引用，对象1的引用计数器为1
&gt;&gt;&gt; b = a # 对象1被变量b应用，对象1的引用计数器加1
&gt;&gt;&gt; c = b # 对象1被变量c引用，对象1 的引用计数器加1
&gt;&gt;&gt; del a # 删除变量a，解除a对1的引用
&gt;&gt;&gt; del b # 删除变量b，解除b对1的引用
&gt;&gt;&gt; print(c) # 最终变量c的引用仍为1
1</code></pre> </li></ul></li></ul> 
<p>              <strong>  del删除的是变量，而不是数据本身。</strong></p> 
<pre><code class="language-python">&gt;&gt;&gt; li = [1,2, 3, 4, 5] '''列表本身不包含数据1,2,3,4,5，而是包含变量：li[0] li[1] li[2] li[3] li[4] '''  
&gt;&gt;&gt; first = li[1] #拷贝列表，也不会有数据对象的复制，而是创建新的变量引用，变量forst引用对象2  
&gt;&gt;&gt; del li  
&gt;&gt;&gt; first  
2</code></pre> 
<p><span style="color:#f33b45;"><strong>3. 增加元素</strong></span></p> 
<ul><li>append  追加，将一个对象附加到列表末尾。 
  <ul><li>增添新员工： <pre><code class="language-python">name_list = ['赵三', '李四']
while 1:
    username = input("输入新员工姓名：").strip()
    if username.upper() == 'Q':
        break
    name_list.append(username)
print(name_list)</code></pre> </li></ul></li></ul> 
<ul><li><strong>insert 插入</strong> （<strong> 在索引前插入对象，Insert object before index.</strong>） <pre><code>l1 = ['alex', 'wusir', 'taibai', 'ritian']
l1.insert(1, '王五')
print(l1)</code></pre> 
  <ul><li>可使用切片赋值来获得与insert一样的效果 <pre><code class="language-python">&gt;&gt;&gt; l1 = ['alex', 'whsir', 'taibai', 'ritian']
&gt;&gt;&gt; l1[1:1] = ['王五']
&gt;&gt;&gt; l1
['alex', '王五', 'whsir', 'taibai', 'ritian']</code></pre> <p> </p> </li></ul></li><li><strong>extend  迭代追加   （Extend list by appending elements from the iterable.）。方法extend让你能够同时将多个值附加到列表末尾，为此<span style="color:#3399ea;">可将这些值组成的序列作为参数</span>提供给方法extend。换而言之，你可使用一个列表来扩展另一个列表。</strong> <pre><code class="language-python">&gt;&gt;&gt; l1 = ['alex', 'wusir', 'taibai', 'ritian']
&gt;&gt;&gt; l1.extend(['李四', '王二麻子'])
&gt;&gt;&gt; print(l1)
['alex', 'wusir', 'taibai', 'ritian', '李四', '王二麻子']
&gt;&gt;&gt; l1.extend('abc')
&gt;&gt;&gt; print(l1)
['alex', 'wusir', 'taibai', 'ritian', '李四', '王二麻子', 'a', 'b', 'c']</code></pre> 
  <ul><li>       要获得与extend相同的效果，可将列表赋给切片，但可读性不是很高。 <pre><code class="language-python">​
&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [4, 5, 6]
&gt;&gt;&gt; a[len(a):] = b
&gt;&gt;&gt; a
[1, 2, 3, 4, 5, 6]

​</code></pre> </li></ul></li></ul> 
<p><span style="color:#f33b45;"><strong>4. 修变列表</strong></span></p> 
<ul><li>按照索引改 <pre><code class="language-python">l1 = ['alex', 'wusir', 'taibai', 'ritian']
l1[0] = '王五'
print(l1)</code></pre> <p> </p> </li><li>按照切片改：1，通过使用切片赋值，可将切片替换为长度与其不同的序列。 <pre><code class="language-python">&gt;&gt;&gt; x = list('aaaa')
&gt;&gt;&gt; x[2:] = list('bcdefg')
&gt;&gt;&gt; x
['a', 'a', 'b', 'c', 'd', 'e', 'f', 'g']</code></pre> 
  <ul><li> <p style="text-indent:33px;">2，<strong>使用切片赋值还可在不替换原有元素的情况下插入新元素。</strong></p> 
    <div>
        
    </div> 
    <div> 
     <pre><code class="language-python">&gt;&gt;&gt; x = list('1234456')
&gt;&gt;&gt; x
['1', '2', '3', '4', '4', '5', '6']
&gt;&gt;&gt; x[2:2] = ['8','8','8']
&gt;&gt;&gt; x
['1', '2', '8', '8', '8', '3', '4', '4', '5', '6']</code></pre> 
    </div> </li><li> 3，使用切片赋值还可以删除元素 <pre><code class="language-python">&gt;&gt;&gt; numbers = [1, 2, 3, 4, 5]
&gt;&gt;&gt; numbers[0:3] = []
&gt;&gt;&gt; numbers
[4, 5]</code></pre> <p> </p> </li></ul></li><li>按照切片＋步长 
  <div> 
   <pre><code class="language-python">l1 = ['alex', 'wusir', 'taibai', 'ritian']
l1[0:3:2] = ['w', 'r']
print(l1)</code></pre> 
  </div> <p> </p> </li></ul> 
<p><span style="color:#f33b45;"><strong>5. 列表查询</strong></span></p> 
<ul><li>切片，索引</li><li>for循环</li></ul> 
<p><strong>6. 其他列表方法</strong></p> 
<ul><li>len()</li><li>count() #计算指定的元素在列表中出现了多少次。</li><li>index() # 通过元素查找索引，<strong>在列表中查找指定值第一次出现的索引，查不到时报错</strong></li><li><strong>sort()</strong> #当列表都是由数字组成时，将数字从小到大就地排序；就地排序意味着对原来的列表进行修改，使其元素按顺序排列，而不是返回排序后的列表的副本。<strong>sort(reverse = Ture)，则从大到小进行排列。</strong></li><li> <pre><code class="language-python"># 由于sort修改x且不返回任何值，最终的结果是x是经过排序的，因此y包含None。
&gt;&gt;&gt; x = [2, 3, 5, 2, 1, 0]
&gt;&gt;&gt; y = x.sort()
&gt;&gt;&gt; y
&gt;&gt;&gt; print(y)
None</code></pre> <p>为获取排序后的列表的副本，另一种方式是使用<strong>函数sorted，该函数可用于任何序列，但总是返回一个列表。</strong></p> <pre><code class="language-python">&gt;&gt;&gt; x = [2, 3, 5, 2, 1, 0]
&gt;&gt;&gt; y = sorted(x)
&gt;&gt;&gt; y
[0, 1, 2, 2, 3, 5]</code></pre> <p><span style="color:#e579b6;"><strong>方法sort可接受两个参数：key和reverse，</strong>这两个参数通常是按名称指定的，称为关键字参数。参数key类似于参数cmp：你将其设置为一个用于排序的函数。然而，不会直接使用这个函数来判断一个元素是否比另一个元素小，而是使用它来为每个元素创建一个键，再根据这些键对元素进行排序。因此，要根据长度对元素进行排序，可将参数key设置为函数len。</span></p> <pre><code class="language-python">&gt;&gt;&gt; x = ['sunhao', 'jingjingwang', 'wukongsun']
&gt;&gt;&gt; x.sort(key = len)
&gt;&gt;&gt; x
['sunhao', 'wukongsun', 'jingjingwang']</code></pre> <p>对于另一关键字参数reverse，只需将其指定为一个真值（True或False），以指出是否要按相反的顺序对列表进行排序。</p> </li></ul> 
<ul><li><strong>reverse() </strong>#反转，按相反的顺序排列列表中的元素</li><li><strong>copy()</strong>  复制列表。 <pre><code class="language-python"># 常规复制 只是将另一个名称关联到列表
&gt;&gt;&gt; a = [1,  2, 3]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b[0] = 2
&gt;&gt;&gt; a
[2, 2, 3]
# 要让a和b指向不同的列表，就必须将b关联到a的副本
&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; b[0] = 2
&gt;&gt;&gt; a
[1, 2, 3]</code></pre> <h2> </h2> </li></ul> 
<h2>4. 元组：不可修改的序列</h2> 
<p>元组：与列表一样，元组也是序列，唯一的差别在于元组是不能修改的。</p> 
<p>元组用圆括号括起来，各元素之间用逗号隔开。注意：创建只含有一个值的元组时，该值后面必须添加逗号。</p> 
<pre><code class="language-python">&gt;&gt;&gt; 2*(40 + 2)
84
&gt;&gt;&gt; 2*(40 +2,)
(42, 42)</code></pre> 
<p><strong>tuple</strong>的工作原理与list很像：它将一个序列作为参数，并将其转换为元组。如果参数已经是元组，就原封不动地返回它。</p> 
<pre><code class="language-python">&gt;&gt;&gt; tuple([1, 2, 3])
(1, 2, 3)
&gt;&gt;&gt; tuple('apple')
('a', 'p', 'p', 'l', 'e')
&gt;&gt;&gt; tuple((1, 2, 3))
(1, 2, 3)</code></pre> 
<p>元组与列表很相似，为何要熟悉元组呢？原因有以下两个：</p> 
<ul><li>它们用作映射中的键（以及集合的成员），而列表不行。映射将在第4章详细介绍。</li><li>有些内置函数和方法返回元组，这意味着必须跟它们打交道。只要不尝试修改元组，与元组“打交道”通常意味着像处理列表一样处理它们（需要使用元组没有的index和count等方法时例外）。</li></ul> 
<h2>5. 字符串</h2> 
<p><strong>字符串是由零个或多个字符组成的有限序列（</strong>维基百科定义<strong>）</strong>。而在Python 3中，它有着更明确的意思：<strong>字符串是由Unicode码点组成的不可变序列（Strings are immutable sequences of Unicode code points）。</strong></p> 
<p>python 中凡是用引号（英文单引号、双引号、三引号）引起来的就是字符串。</p> 
<h4>5.1.1 字符串基本操作</h4> 
<p>所有标准序列操作（<strong>索引、切片、乘法、成员资格检查、长度、最小值和最大值）都适用于字符串</strong>，但别忘了字符串是不可变的，因此所有的元素赋值和切片赋值都是非法的。</p> 
<p><strong>1. 字符串的创建</strong></p> 
<pre><code class="language-python">s1 = ' alex'
s2 = 'alex李哥'
# 单双引号配合使用
s3 = " I’m 12 years old "
print (s3)
# 换行的字符串需要用三个引号括起来
msg = """ 窗前明月光，
疑是地上霜"""

</code></pre> 
<ul><li>如果字符串内部既包含<strong><code>'</code></strong>又包含<strong><code>"</code></strong>怎么办？可以用<strong>转义字符<code>\</code></strong>来标识。</li></ul> 
<pre><code class="language-python">print ('I\'m \"OK\"!')</code></pre> 
<p style="text-indent:33px;"><strong><code> \n</code>表示换行，<code>\t</code>表示制表符</strong>，字符<code>\</code>本身也要转义，所以<code>\\</code>表示的字符就是<code>\。</code></p> 
<p style="text-indent:33px;"> 如果字符串内部有很多换行，用<code>\n</code>写在一行里不好阅读，为了简化，<strong>Python允许用<code>'''...'''</code>的格式表示多行内容。</strong></p> 
<pre><code class="language-python">print('''line1
line2
line3''')</code></pre> 
<ul><li>提示：<strong>常规字符串也可横跨多行。只要在行尾加上反斜杠，反斜杠和换行符将被转义，即被忽略。此时，代码是多行呈现，而实际打印效果并不是多行呈现。</strong></li></ul> 
<pre><code class="language-python">&gt;&gt;&gt; print ('Hellw, \
... world!')
Hellw, world!</code></pre> 
<p style="text-indent:33px;">这种处理手法也适用于表达式和语句，可将一条语句在多行书写。</p> 
<pre><code class="language-python">&gt;&gt;&gt; 1 +2 + \
... 4 + 5
12
&gt;&gt;&gt; print \
... ( 'Hello, world')
Hello, world</code></pre> 
<p><span style="color:#f33b45;"><strong>2. 原始字符串</strong></span></p> 
<p>由于反斜杠\ 的特殊意义，在表示路径时，将面临大量的发斜杠进行转义。</p> 
<pre><code class="language-python">path = 'C:\\Program Files\\fnord\\foo\\bar\\baz\\frozz\\bozz'</code></pre> 
<p>在这样的情况下，<strong>原始字符串</strong>可派上用场，因为它们根本不会对反斜杠做特殊处理，而是让字符串包含的每个字符都保持原样。</p> 
<pre><code class="language-python">&gt;&gt;&gt; print(r'C:\Program Files\fnord\foo\bar\baz\frozz\b')
C:\Program Files\fnord\foo\bar\baz\frozz\b</code></pre> 
<p>不过，<strong>原始字符串不能以单个反斜杠结尾</strong>。</p> 
<h3>5.2 字符串的常用方法</h3> 
<p>前面介绍了列表的方法，而字符串的方法要多得多，因为其很多方法都是从模块string那里“继承”而来的。</p> 
<h4>5.2.1 模块string简介</h4> 
<p>虽然字符串方法完全盖住了模块string的风头，但这个模块包含一些字符串没有的常量和函数。下面就是模块string中几个很有用的常量。</p> 
<blockquote> 
 <p>❑ string.digits：包含数字0～9的字符串。❑ string.ascii_letters：包含所有ASCII字母（大写和小写）的字符串。❑ string.ascii_lowercase：包含所有小写ASCII字母的字符串。❑ string.printable：包含所有可打印的ASCII字符的字符串。❑ string.punctuation：包含所有ASCII标点字符的字符串。❑ string.ascii_uppercase：包含所有大写ASCII字母的字符串。</p> 
</blockquote> 
<pre><code class="language-python">&gt;&gt;&gt; import string
&gt;&gt;&gt; string.ascii_letters
'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
&gt;&gt;&gt; string.ascii_uppercase
'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</code></pre> 
<h4>5.2.2 center——通过在两边添加填充字符（默认为空格）让字符串居中。</h4> 
<pre><code class="language-html hljs">str.center(width[, fillchar])</code></pre> 
<ul><li>width -- 字符串的总宽度。</li><li>fillchar -- 填充字符。</li></ul> 
<h4>5.2.3 find——在字符串中查找子串。如果找到，就返回子串的第一个字符的索引，否则返回-1。</h4> 
<h4>5.2.4 join——合并序列的元素（可选择直接合并，或以指定字符连结元素），所合并序列的元素必须都是字符串</h4> 
<pre><code class="language-python">&gt;&gt;&gt; s1 = list("apple")
&gt;&gt;&gt; ''.join(s1)
'apple'
&gt;&gt;&gt; '*'.join(s1)
'a*p*p*l*e'
&gt;&gt;&gt; s1 = 'qpp'
&gt;&gt;&gt; '@'.join(s1)
'q@p@p'</code></pre> 
<p><strong>其作用与split相反</strong></p> 
<h4><strong>5.2.5 lower——返回字符串的小写版本</strong></h4> 
<p><strong>upper——返回字符串的大写版本</strong></p> 
<p><strong>title——将字符串转换为词首大写，即所有单词的首字母都大写，其他字母都小写。</strong></p> 
<p><strong>模块string中的函数capwords——词首大写，较title准确些</strong></p> 
<h4><strong>5.2.6 replace——将指定子串都替换为另一个字符串，并返回替换后的结果。</strong></h4> 
<h4><span style="color:#86ca5e;"><strong>5.2.7 split——</strong></span><strong>split是一个非常重要的字符串方法</strong>，<strong>其作用与join相反，用于将字符串拆分为序列（默认</strong>将默认在单个或多个连续的空白字符（空格、制表符、换行符等）处进行拆分，可指定分隔符<strong>）。</strong></h4> 
<pre><code class="language-python">&gt;&gt;&gt; '1 + 2 +3'.split('+')
['1 ', ' 2 ', '3']
&gt;&gt;&gt; 'Using the default'.split()
['Using', 'the', 'default']</code></pre> 
<h4>5.2.8 strip——默认将字符串开头和末尾的空白（但不包括中间的空白）删除，并返回删除后的结果。</h4> 
<p>与lower一样，需要将用户输入与已存储的值进行比较时，strip很有用，可以避免用户多输入空格时索引错误。</p> 
<pre><code class="language-python">&gt;&gt;&gt; '*** SPAM * for * everyone!!!***'.strip('*! ')
'SPAM * for * everyone'</code></pre> 
<h4>5.2.9 translate</h4> 
<p>相对于replace，translate可以同时替换多个字符，效率更高。</p> 
<p>使用translate前需要创建一个<strong>转换表—</strong>—指出了不同Unicode码点之间的转换关系。<strong>要创建转换表，可对字符串类型str调用方法maketrans</strong>，这个方法接受两个参数：两个长度相同的字符串，它们指定要将第一个字符串中的每个字符都替换为第二个字符串中的相应字符。</p> 
<pre><code class="language-python">&gt;&gt;&gt; table = str.maketrans('cs', 'kz',' ')
&gt;&gt;&gt; table
{99: 107, 115: 122, 32: None}
&gt;&gt;&gt; 'this is an incredible test'.translate(table)
'thizizaninkredibletezt'</code></pre> 
<h4>5.2.10 判断字符串是否满足特定的条件</h4> 
<p>很多字符串方法都以is打头，如isspace、isdigit和isupper，它们判断字符串是否具有特定的性质（如包含的字符全为空白、数字或大写）。如果字符串具备特定的性质，这些方法就返回True，否则返回False。</p> 
<p><a href="https://weread.qq.com/web/reader/fa7325c0718ff605fa72aa4ka5732aa0226a5771bce9dc4" rel="nofollow">参考资料：《Python基础教程（第3版）》，[挪]芒努斯·利·海特兰德，人民邮电出版社，2018.</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c828baf6ed4bfdc26a3ad287ed13699d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">phpstrom 使用起来很卡的解决办法：The IDE is running low on memory and this might affect performance. Please cons</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/da82bd5e27e2cd4acc5af6bc87fad007/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL设置编码的命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>