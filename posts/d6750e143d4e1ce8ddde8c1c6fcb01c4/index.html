<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Dart语言——45分钟快速入门（上） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Dart语言——45分钟快速入门（上）" />
<meta property="og:description" content="文章目录 前言视频课程环境准备 安装Dart SDK配置环境变量配置 VSCode 编辑器测试环境 基础语法 代码注释内置数据类型变量与常量 定义变量定义常量 内置类型的常用操作 数值类型字符串布尔类型列表映射 函数 定义函数函数的参数 命名可选参数位置可选参数 匿名函数箭头函数 运算符 算术运算符类型判定运算符条件表达式级联运算符条件成员访问符 分支与循环 条件分支循环语句 基本循环特有循环 关注我的公众号：编程之路从0到1 前言 谷歌推出Flutter跨平台UI框架后，对移动端的开发又产生了新的影响，Flutter采用Dart语言开发，而Flutter为什么选择Dart语言作为唯一的开发语言呢？总的来说，其拥有如下优势
Dart可基于AOT（Ahead Of Time）编译，即编译成平台的本地代码，运行性能高。Dart也可基于JIT（Just In Time）编译，编译快速，可热加载，使开发周期加倍提升（Flutter亚秒级有状态热重载）Dart可以更轻松地创建以60fps运行的流畅动画和转场。Dart在没有锁的情况下进行对象分配和垃圾回收Dart语法结合Java与JavaScript语法特点，几乎没有令人不适的怪异语法，使Java程序员倍感亲切，快速上手 通常来说一门语言要么使用AOT编译，编译慢，开发效率低，或者使用JIT编译，在运行时编译，虽然可以热重载，但是执行效率低，而Dart在这两种之间做出了完美平衡，当开发时使用JIT编译，调试快，所见即所得，开发效率高，当发布时，使用AOT编译，编译成目标平台的本地代码，执行效率高。
视频课程 博主发布的相关视频课程
Flutter全栈式开发之Dart 编程指南
Flutter 全栈式开发指南
快速上手篇可试看
环境准备 安装Dart SDK 官方下载地址
共有三种SDK版本选择
FlutterWebServer 本章仅作为Dart编程语法学习，这里建议安装Server版的SDK，然后选择Windows版本进行下载。
配置环境变量 在Windows上，通过点击下一步即可安装，安装完成后，需将dart-sdk下的的bin目录添加到系统Path环境变量中。这一步骤是通常的命令配置步骤。
配置 VSCode 编辑器 作为Dart语言的学习，不建议下载笨重的IDE，官方提供支持VSCode 编辑器插件，建议使用VSCode 学习。
从 官网下载 VSCode编辑器，安装完成后，启动VSCode并在插件商店中搜索Dart进行插件安装。
测试环境 在VSCode中新建一个test.dart文件，编写如下代码
void main(){ print(&#34;hello world!&#34;); } 123 运行后成功在控制台输出hello world!
基础语法 代码注释 Dart中的代码注释基本与Java语言相同
// 单行注释 /* * 多行注释 */ /** * 文档注释 */ /// 使用三个斜杠开头 /// 这是Dart特有的文档注释 123456789101112 内置数据类型 在Dart中，所有能够使用变量引用的都是对象，每个对象都是一个类的实例。数字、函数和 null 也都是对象。所有的对象都继承于Object类。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/d6750e143d4e1ce8ddde8c1c6fcb01c4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-03T18:27:53+08:00" />
<meta property="article:modified_time" content="2020-12-03T18:27:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Dart语言——45分钟快速入门（上）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <div id="article_content" class="article_content clearfix"> 
 <div id="content_views" class="markdown_views prism-tomorrow-night-eighties"> 
  <div class="toc"> 
   <h4>文章目录</h4> 
   <ul><li><a href="#_1" rel="nofollow noopener noreferrer" target="_self">前言</a></li><li><a href="#_11" rel="nofollow noopener noreferrer" target="_self">视频课程</a></li><li><a href="#_21" rel="nofollow noopener noreferrer" target="_self">环境准备</a></li><li> 
     <ul><li><a href="#Dart_SDK_22" rel="nofollow noopener noreferrer" target="_self">安装Dart SDK</a></li><li><a href="#_31" rel="nofollow noopener noreferrer" target="_self">配置环境变量</a></li><li><a href="#_VSCode__35" rel="nofollow noopener noreferrer" target="_self">配置 VSCode 编辑器</a></li><li><a href="#_41" rel="nofollow noopener noreferrer" target="_self">测试环境</a></li></ul> </li><li><a href="#_50" rel="nofollow noopener noreferrer" target="_self">基础语法</a></li><li> 
     <ul><li><a href="#_52" rel="nofollow noopener noreferrer" target="_self">代码注释</a></li><li><a href="#_69" rel="nofollow noopener noreferrer" target="_self">内置数据类型</a></li><li><a href="#_78" rel="nofollow noopener noreferrer" target="_self">变量与常量</a></li><li> 
       <ul><li><a href="#_79" rel="nofollow noopener noreferrer" target="_self">定义变量</a></li><li><a href="#_114" rel="nofollow noopener noreferrer" target="_self">定义常量</a></li></ul> </li><li><a href="#_134" rel="nofollow noopener noreferrer" target="_self">内置类型的常用操作</a></li><li> 
       <ul><li><a href="#_135" rel="nofollow noopener noreferrer" target="_self">数值类型</a></li><li><a href="#_156" rel="nofollow noopener noreferrer" target="_self">字符串</a></li><li><a href="#_196" rel="nofollow noopener noreferrer" target="_self">布尔类型</a></li><li><a href="#_204" rel="nofollow noopener noreferrer" target="_self">列表</a></li><li><a href="#_221" rel="nofollow noopener noreferrer" target="_self">映射</a></li></ul> </li><li><a href="#_247" rel="nofollow noopener noreferrer" target="_self">函数</a></li><li> 
       <ul><li><a href="#_250" rel="nofollow noopener noreferrer" target="_self">定义函数</a></li><li><a href="#_267" rel="nofollow noopener noreferrer" target="_self">函数的参数</a></li><li> 
         <ul><li><a href="#_274" rel="nofollow noopener noreferrer" target="_self">命名可选参数</a></li><li><a href="#_300" rel="nofollow noopener noreferrer" target="_self">位置可选参数</a></li></ul> </li><li><a href="#_334" rel="nofollow noopener noreferrer" target="_self">匿名函数</a></li><li><a href="#_349" rel="nofollow noopener noreferrer" target="_self">箭头函数</a></li></ul> </li><li><a href="#_375" rel="nofollow noopener noreferrer" target="_self">运算符</a></li><li> 
       <ul><li><a href="#_378" rel="nofollow noopener noreferrer" target="_self">算术运算符</a></li><li><a href="#_383" rel="nofollow noopener noreferrer" target="_self">类型判定运算符</a></li><li><a href="#_401" rel="nofollow noopener noreferrer" target="_self">条件表达式</a></li><li><a href="#_415" rel="nofollow noopener noreferrer" target="_self">级联运算符</a></li><li><a href="#_427" rel="nofollow noopener noreferrer" target="_self">条件成员访问符</a></li></ul> </li><li><a href="#_442" rel="nofollow noopener noreferrer" target="_self">分支与循环</a></li><li> 
       <ul><li><a href="#_443" rel="nofollow noopener noreferrer" target="_self">条件分支</a></li><li><a href="#_471" rel="nofollow noopener noreferrer" target="_self">循环语句</a></li><li> 
         <ul><li><a href="#_472" rel="nofollow noopener noreferrer" target="_self">基本循环</a></li><li><a href="#_492" rel="nofollow noopener noreferrer" target="_self">特有循环</a></li></ul> </li></ul> </li><li><a href="#01_529" rel="nofollow noopener noreferrer" target="_self">关注我的公众号：编程之路从0到1</a></li></ul> </li></ul> 
  </div> 
  <p></p> 
  <h2><a id="_1"></a>前言</h2> 
  <p>谷歌推出Flutter跨平台UI框架后，对移动端的开发又产生了新的影响，Flutter采用Dart语言开发，而Flutter为什么选择Dart语言作为唯一的开发语言呢？总的来说，其拥有如下优势</p> 
  <ul><li>Dart可基于AOT（Ahead Of Time）编译，即编译成平台的本地代码，运行性能高。</li><li>Dart也可基于JIT（Just In Time）编译，编译快速，可热加载，使开发周期加倍提升（Flutter亚秒级有状态热重载）</li><li>Dart可以更轻松地创建以60fps运行的流畅动画和转场。Dart在没有锁的情况下进行对象分配和垃圾回收</li><li>Dart语法结合Java与JavaScript语法特点，几乎没有令人不适的怪异语法，使Java程序员倍感亲切，快速上手</li></ul> 
  <p>通常来说一门语言要么使用AOT编译，编译慢，开发效率低，或者使用JIT编译，在运行时编译，虽然可以热重载，但是执行效率低，而Dart在这两种之间做出了完美平衡，当开发时使用JIT编译，调试快，所见即所得，开发效率高，当发布时，使用AOT编译，编译成目标平台的本地代码，执行效率高。</p> 
  <h2><a id="_11"></a>视频课程</h2> 
  <p>博主发布的相关视频课程</p> 
  <p><a href="https://blog.csdn.net/yingshukun/article/details/104302296">Flutter全栈式开发之Dart 编程指南</a><br> <img src="https://images2.imgbox.com/65/ac/8i7QWsj3_o.png" alt="二维码"></p> 
  <p><a href="https://study.163.com/course/courseMain.htm?courseId=1210111872&amp;share=2&amp;shareId=480000001855430" rel="nofollow">Flutter 全栈式开发指南</a><br> 快速上手篇可试看<br> <img src="https://images2.imgbox.com/7d/3a/ow5NinHL_o.png" alt=""></p> 
  <h2><a id="_21"></a>环境准备</h2> 
  <h3><a id="Dart_SDK_22"></a>安装Dart SDK</h3> 
  <p><a href="https://www.dartlang.org/install" rel="nofollow">官方下载地址</a><br> 共有三种SDK版本选择</p> 
  <ul><li>Flutter</li><li>Web</li><li>Server</li></ul> 
  <p>本章仅作为Dart编程语法学习，这里建议安装<strong>Server</strong>版的SDK，然后选择Windows版本进行下载。</p> 
  <h3><a id="_31"></a>配置环境变量</h3> 
  <p>在Windows上，通过点击下一步即可安装，安装完成后，需将<code>dart-sdk</code>下的的<code>bin</code>目录添加到系统Path环境变量中。这一步骤是通常的命令配置步骤。</p> 
  <h3><a id="_VSCode__35"></a>配置 VSCode 编辑器</h3> 
  <p>作为Dart语言的学习，不建议下载笨重的IDE，官方提供支持VSCode 编辑器插件，建议使用VSCode 学习。</p> 
  <p>从 <a href="https://code.visualstudio.com/" rel="nofollow" title="官网下载">官网下载</a> VSCode编辑器，安装完成后，启动VSCode并在插件商店中搜索Dart进行插件安装。</p> 
  <h3><a id="_41"></a>测试环境</h3> 
  <p>在VSCode中新建一个<code>test.dart</code>文件，编写如下代码</p> 
  <pre class="prettyprint"><code class="prism language-dart has-numbering">void  main(){
    print("hello world!");
}
</code>
   
   <div class="hljs-button {2}"></div>
   
   </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li></ul> 
  <p>运行后成功在控制台输出<code>hello world!</code></p> 
  <h2><a id="_50"></a>基础语法</h2> 
  <h3><a id="_52"></a>代码注释</h3> 
  <p>Dart中的代码注释基本与Java语言相同</p> 
  <pre class="prettyprint"><code class="prism language-dart has-numbering">// 单行注释
/*
 * 多行注释
 */
/**
 * 文档注释
 */
/// 使用三个斜杠开头
/// 这是Dart特有的文档注释
</code>
   
   <div class="hljs-button {2}"></div>
   
   </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li></ul> 
  <h3><a id="_69"></a>内置数据类型</h3> 
  <p><img src="https://images2.imgbox.com/87/f7/nogSOgOG_o.png" alt="在这里插入图片描述"></p> 
  <blockquote> 
   <p>在Dart中，所有能够使用变量引用的都是对象，每个对象都是一个类的实例。数字、函数和 <code>null</code> 也都是对象。所有的对象都继承于Object类。</p> 
  </blockquote> 
  <p>要注意，没有初始化的变量默认值为 <code>null</code>。数值类型变量的默认值也是 <code>null</code>。</p> 
  <p>数值类型<code>num</code>有两个具体子类，分别为<code>int</code>和<code>double</code>，其中<code>int</code>为整数值，范围是<code>-2^53</code>至<code>2^53</code>之间；<code>double</code>则是64位的双精度浮点数。</p> 
  <h3><a id="_78"></a>变量与常量</h3> 
  <h4><a id="_79"></a>定义变量</h4> 
  <p>Dart中定义变量有两种方式，一种是静态类型语言常用的方式，显式指定变量类型，另一种则是动态语言的常用方式，不指定类型，由vm自动推断。</p> 
  <pre class="prettyprint"><code class="prism language-dart has-numbering">// 1.通过显式指定类型来定义变量
String name = "张三";
num age = 18;
// 2.使用关键字var，不指定类型
var address = "深南大道";
var id = 100;
/* 使用var定义变量，即使未显式指定类型，一旦赋值后类型就被固定
 * 因此使用var定义的变量不能改变数据类型
 */
var number = 19;
// 以下代码错误，无法运行，number变量已确定为int类型
number = "2019";
</code>
   
   <div class="hljs-button {2}"></div>
   
   </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li></ul> 
  <p>如想动态改变变量的数据类型，应当使用<code>dynamic</code>或<code>Object</code>来定义变量。</p> 
  <pre class="prettyprint"><code class="prism language-dart has-numbering">// dynamic声明变量
dynamic var1 = "hello";
var1 = 19;
print(var1);    // 19
// Object声明变量
Object var2 = 20;
var2 = "Alice";
print(var2);    // Alice
</code>
   
   <div class="hljs-button {2}"></div>
   
   </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li></ul> 
  <p>建议在编写代码时，尽可能显式指定变量类型，这样可以提升代码可读性与调试的便利性。</p> 
  <h4><a id="_114"></a>定义常量</h4> 
  <p>Dart中定义常量也有两种方式，一种使用<code>final</code>关键字，同Java中的用法， 一个 final 变量只能赋值一次；另一种是Dart的方式，使用<code>const</code>关键字定义。</p> 
  <pre class="prettyprint"><code class="prism language-dart has-numbering">// 1.使用final关键字定义常量
final height = 10;
// 2.使用const关键字定义常量
const pi = 3.14;
</code>
   
   <div class="hljs-button {2}"></div>
   
   </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li></ul> 
  <p>需要注意，<code>final</code>定义的常量是运行时常量，而<code>const</code>常量则是编译时常量，也就是说<code>final</code>定义常量时，其值可以是一个变量，而<code>const</code>定义的常量，其值必须是一个字面常量值。</p> 
  <pre class="prettyprint"><code class="prism language-dart has-numbering">final time = new DateTime.now(); // 正确
const time = new DateTime.now(); // 错误
const list = const[1,2,3];       // 正确
const list = [1,2,3];            // 错误
</code>
   
   <div class="hljs-button {2}"></div>
   
   </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li></ul> 
  <h3><a id="_134"></a>内置类型的常用操作</h3> 
  <h4><a id="_135"></a>数值类型</h4> 
  <pre class="prettyprint"><code class="prism language-dart has-numbering">// String 转 int
var one = int.parse('1');
// String 转 double
var onePointOne = double.parse('1.1');
// int 转 String
String oneAsStr = 1.toString();
// double 转 String
String piAsStr = 3.14159.toStringAsFixed(2); // 保留两位 '3.14'
// Dart也支持整数位操作，&lt;&lt;、 &gt;&gt;、&amp;、|
print((3 &lt;&lt; 1) == 6);  // 0011 &lt;&lt; 1 == 0110
print((3 &gt;&gt; 1) == 1);  // 0011 &gt;&gt; 1 == 0001
print((3 | 4)  == 7);  // 0011 | 0100 == 0111
</code>
   
   <div class="hljs-button {2}"></div>
   
   </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li></ul> 
  <h4><a id="_156"></a>字符串</h4> 
  <blockquote> 
   <p>值得一提的是，Dart中提供的字符串<code>插值表达式</code>使字符串格式化变得异常方便。</p> 
  </blockquote> 
  <pre class="prettyprint"><code class="prism language-dart has-numbering">// 1.Dart可以使用单引号或双引号来创建字符串
var s1 = "hello";
var s2 = 'world';
// 2.类似Python，Dart可以使用三引号来创建包含多行的字符串
var multiLine1 = """你可以像这样，创建一个
包含了多行的字符串内容
""";
var multiLine2 = '''你也可以使用三个单引号，创建一个
包含了多行的字符串内容
''';
// 3.类似Python，还可以在字符串字面值的前面加上`r`来创建原始字符串，则该字符串中特殊字符可以不用转义
var path = r'D:\workspace\code';
// 4.Dart支持使用"+"操作符拼接字符串
var greet = "hello" + " world";
// 5.Dart提供了插值表达式"${}"，也可以用于拼接字符串
var name = "王五";
var aStr = "hello,${name}";
print(aStr);    // hello,王五
// 当仅取变量值时，可以省略花括号
var aStr2 = "hello,$name"; // hello,王五
// 当拼接的是一个表达式时，则不能省略花括号
var str1 = "link";
var str2 = "click ${str1.toUpperCase()}";
print(str2);   // click LINK
// 6. 与Java不同，Dart使用"=="来比较字符串的内容
print("hello" == "world");
</code>
   
   <div class="hljs-button {2}"></div>
   
   </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li><li>34</li></ul> 
  <h4><a id="_196"></a>布尔类型</h4> 
  <blockquote> 
   <p>Dart中的布尔类型用法同Java，仅有<code>false</code>、<code>true</code>两个值，不能使用0、非0或者<code>null</code>、非<code>null</code>来表达<code>false</code>和<code>true</code>。与Java不同的是，布尔类型的默认值为<code>null</code></p> 
  </blockquote> 
  <pre class="prettyprint"><code class="prism language-dart has-numbering">bool flags;
print(flags);    // null
</code>
   
   <div class="hljs-button {2}"></div>
   
   </pre><ul class="pre-numbering"><li>1</li><li>2</li></ul> 
  <h4><a id="_204"></a>列表</h4> 
  <p>Dart中列表操作与JavaScript中的数组相似。</p> 
  <pre class="prettyprint"><code class="prism language-dart has-numbering">// 创建列表
var list = [1, 2, 3];
// 下标从0开始。使用length可以访问list的长度
print(list[0]);
print(list.length);
// 可以使用add添加元素
list.add(5);
// 可在list字面量前添加const关键字，定义一个不可改变的 列表（编译时常量）
var constantList = const [1, 2, 3];
constantList[1] = 1;     // 报错
</code>
   
   <div class="hljs-button {2}"></div>
   
   </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li></ul> 
  <h4><a id="_221"></a>映射</h4> 
  <p>又称为关联数组，相当于Java中的<code>HashMap</code></p> 
  <pre class="prettyprint"><code class="prism language-dart has-numbering">// 1.通过字面量创建Map
var gifts = {
  'first' : 'partridge',
  'second': 'turtledoves',
  'fifth' : 'golden rings'
};
// 2.使用Map类的构造函数创建对象
var pic = new Map();
// 往Map中添加键值对
pic['first'] = 'partridge';
pic['second'] = 'turtledoves';
pic['fifth'] = 'golden rings';
// 3.获取Map的长度
print(pic.length);
// 4.查找Map
pirnt(pic["first"]);
print(pic["four"]);    // 键不存在则返回 null
</code>
   
   <div class="hljs-button {2}"></div>
   
   </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li></ul> 
  <h3><a id="_247"></a>函数</h3> 
  <blockquote> 
   <p>在Dart中，函数（或方法） 也是对象，它的类型是 <code>Function</code>。 这意味着，函数可以赋值给变量，也可以当做其他函数的参数。</p> 
  </blockquote> 
  <h4><a id="_250"></a>定义函数</h4> 
  <p>Dart中定义函数，基本上与Java类似</p> 
  <pre class="prettyprint"><code class="prism language-dart has-numbering">String greet(String name){
    return "hello,$name";
}
</code>
   
   <div class="hljs-button {2}"></div>
   
   </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li></ul> 
  <p>在Dart中，类型是可选，可以省略显式的类型，但仍然建议显式指定类型。</p> 
  <pre class="prettyprint"><code class="prism language-dart has-numbering">greet(name){
    return "hello,$name";
}
</code>
   
   <div class="hljs-button {2}"></div>
   
   </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li></ul> 
  <p>要注意，函数也是对象，所有函数都有返回值。当没有指定返回值的时候，函数会返回<code>null</code>。当然，如果你强行使用<code>void</code>来修饰函数，则函数真的没有返回值，这种情况就另当别论了。</p> 
  <h4><a id="_267"></a>函数的参数</h4> 
  <p>Dart中支持两种可选参数</p> 
  <ul><li>命名可选参数</li><li>位置可选参数</li></ul> 
  <p>在Java中通常使用方法重载来实现同名方法的不同参数调用，Dart中则可以通过可选参数来实现相同效果。</p> 
  <h5><a id="_274"></a>命名可选参数</h5> 
  <p>先来看一下<code>命名参数</code>，它使用花括号来定义参数列表</p> 
  <pre class="prettyprint"><code class="prism language-dart has-numbering">// 定义一个函数，参数列表用花括号包裹
enableFlags({bool bold, bool hidden}) {
    // do something
}
// 调用方式，传参时使用"参数名:值"的形式
enableFlags(hidden:true,bold:false);
</code>
   
   <div class="hljs-button {2}"></div>
   
   </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li></ul> 
  <p>如果在定义函数时，给参数列表中的参数设置默认值，则该参数就是可选的，函数调用时可以忽略该参数，使用默认的值。</p> 
  <pre class="prettyprint"><code class="prism language-dart has-numbering">// 定义add函数
add({int x, int y=1, int z=0}){
    print(x + y + z;
}
// 调用
add(x:18);              // 19
add(x:18, y:2, z:10);   // 30
</code>
   
   <div class="hljs-button {2}"></div>
   
   </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li></ul> 
  <p>这里需要注意一下，SDK 1.21之前的版本中，命名参数不能使用<code>=</code>号来设置默认值，而SDK 1.21之后，只能使用<code>=</code>号来设置默认值。因此，请检查并升级SDK版本。</p> 
  <h5><a id="_300"></a>位置可选参数</h5> 
  <p><code>位置可选参数</code>使用中括号来定义参数列表，中括号中的参数是可选的</p> 
  <pre class="prettyprint"><code class="prism language-dart has-numbering">// 定义add函数
add(int x, [int y, int z]){
    int result = x;
    if (y !=  null){
        result = result + y;
    }
    if (z !=  null){
        result = result + z;
    }
    print(result);
}
// 调用
add(18);           // 18
add(18,12);        // 30
add(18, 12, 15);   // 45
</code>
   
   <div class="hljs-button {2}"></div>
   
   </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li></ul> 
  <p>给<code>位置可选参数</code>设置默认值</p> 
  <pre class="prettyprint"><code class="prism language-dart has-numbering">// 定义add函数
add(int x, [int y=0, int z=0]){
    print(x +ｙ＋ｚ);
}
</code>
   
   <div class="hljs-button {2}"></div>
   
   </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li></ul> 
  <p>最后需要注意一下<code>命名可选参数</code>与<code>位置可选参数</code>的区别，前者中的参数与顺序无关，无需按顺序传参，且传参数时需使用冒号；后者与顺序相关，传参必须依照顺序。</p> 
  <h4><a id="_334"></a>匿名函数</h4> 
  <blockquote> 
   <p>大部分函数都有名字，但我们也可以创建没有名字的函数，称为匿名函数，也被称为lambda表达式或者闭包。</p> 
  </blockquote> 
  <pre class="prettyprint"><code class="prism language-dart has-numbering">// 定义匿名函数，并将其赋值给一个变量func，注意，函数体最后的花括号处必须有分号结束。
var func = (x,y){
    return x + y;
};
</code></pre> 
 </div> 
</div> 
<p>print(func(10,11)); // 21</p> 
<div class="hljs-button {2}"></div> 
<ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li></ul> 
<p>注意，匿名函数与普通函数基本相同，也有参数列表，函数体，只是省去了函数名而已。</p> 
<h4><a id="_349"></a>箭头函数</h4> 
<blockquote> 
 <p>Dart中的箭头函数与JavaScript中的基本相同。当函数体中只包含一个语句时，我们就可以使用<code>=&gt;</code>箭头语法进行缩写。注意，箭头函数仅仅只是一个简洁表达的语法糖。</p> 
</blockquote> 
<p>普通函数</p> 
<pre class="prettyprint"><code class="prism language-dart has-numbering">add(num x, num y){
    return x + y;
}
print(add(18,12));    // 30
</code>
 
 <div class="hljs-button {2}"></div>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li></ul> 
<p>箭头函数</p> 
<pre class="prettyprint"><code class="prism language-dart has-numbering">// 与上面的普通函数完全等价
add(num x, num y) =&gt; x + y;
print(add(18,12));    // 30
</code>
 
 <div class="hljs-button {2}"></div>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li></ul> 
<p>箭头函数省略了花括号的表达，箭头后面跟一个表达式，函数的返回值也就是这个表达式的值。另外，箭头函数也可以与匿名函数结合，形成匿名箭头函数。</p> 
<pre class="prettyprint"><code class="prism language-dart has-numbering">var func = (num x, num y) =&gt; x + y;
</code>
 
 <div class="hljs-button {2}"></div>
 
 </pre><ul class="pre-numbering"><li>1</li></ul> 
<h3><a id="_375"></a>运算符</h3> 
<p>Dart语言中的运算符与Java中的绝大多数相同。</p> 
<h4><a id="_378"></a>算术运算符</h4> 
<p><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>同Java语言</p> 
<p>Dart中又多出了一个整除运算符<code>~/</code>，与普通除号的区别是将相除后的结果取整返回。</p> 
<h4><a id="_383"></a>类型判定运算符</h4> 
<p>以下是Dart增加的类型相关的运算符。</p> 
<div class="table-box"> 
 <table><thead><tr><th>操作符</th><th>解释</th></tr></thead><tbody><tr><td><code>as</code></td><td>用于类型转换</td></tr><tr><td><code>is</code></td><td>如果对象是指定的类型就返回 True</td></tr><tr><td><code>is!</code></td><td>如果对象不是指定的类型返回 True</td></tr></tbody></table> 
</div> 
<p>当 <code>obj</code> 实现了 <code>T</code> 的接口时， <code>obj is T</code> 才是 true。类似于Java中的<code>instanceof</code>。</p> 
<p>Dart中使用 <code>as</code> 操作符把对象转换为特定的类型，如无法转换则会抛出异常，因此在转换前最好使用<code>is</code>运算符进行检测。</p> 
<pre class="prettyprint"><code class="prism language-dart has-numbering">// 将p转换为Person类型再操作
(p as Person).name = 'Bruce';
</code>
 
 <div class="hljs-button {2}"></div>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li></ul> 
<h4><a id="_401"></a>条件表达式</h4> 
<p>Dart中也支持三目表达式<br> <code>condition ? expr1 : expr2</code></p> 
<p>除此外，Dart还增加了非空条件判断符<code>??</code><br> <code>expr1 ?? expr2</code><br> 上述运算表示，如果expr1的值不等于<code>null</code>，则返回其值； 否则执行表达式expr2并返回其结果。</p> 
<pre class="prettyprint"><code class="prism language-dart has-numbering">var str1 =  "Hello";
var str2 =  "world";
var result = str1 ?? str2.toUpperCase();
</code>
 
 <div class="hljs-button {2}"></div>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li></ul> 
<h4><a id="_415"></a>级联运算符</h4> 
<blockquote> 
 <p>我们通常使用<code>.</code>操作符调用对象的方法，这在Dart中也是支持的，但是Dart另外增加了一种级联运算符<code>..</code>，用两个点表示。</p> 
</blockquote> 
<p><code>级联运算符</code>可以在同一个对象上连续调用多个方法以及访问成员变量。 使用它可以避免创建临时变量， 写出更流畅的代码。</p> 
<p>假如类Person有三个方法，<code>setName</code>、<code>setAge</code>、<code>save</code>，则可如下调用</p> 
<pre class="prettyprint"><code class="prism language-dart has-numbering">new Person()..setName("Bob")..setAge(20)..save();
</code>
 
 <div class="hljs-button {2}"></div>
 
 </pre><ul class="pre-numbering"><li>1</li></ul> 
<p>使用<code>级联运算符</code>调用方法，无需该方法返回对象本身即可连续的流式的调用该对象的其他方法。</p> 
<h4><a id="_427"></a>条件成员访问符</h4> 
<blockquote> 
 <p>在Java中很容易碰到恼人的空指针错误，因此在方法调用前需要进行对象的非空判断，这样的判断语句使代码变得冗长，可读性差，不整洁。Dart中则发明了一个新的运算符用于处理此类情况。</p> 
</blockquote> 
<p>条件成员访问符<code>?.</code>，它和<code>.</code>类似，但是运算符左边的对象不能为<code>null</code>，否则返回<code>null</code>，若对象不为<code>null</code>，则返回对象本身。</p> 
<pre class="prettyprint"><code class="prism language-dart has-numbering">// list1默认值为null
List list1;
print(list1?.length);  // null
List list2 = [];
print(list2?.length);  // 0
</code>
 
 <div class="hljs-button {2}"></div>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li></ul> 
<h3><a id="_442"></a>分支与循环</h3> 
<h4><a id="_443"></a>条件分支</h4> 
<p>Dart中的条件分支基本与Java相同</p> 
<p><code>if</code>条件分支</p> 
<pre class="prettyprint"><code class="prism language-dart has-numbering">if(i &lt; 0){
  print('i &lt; 0');
}else if(i == 0){
  print('i = 0');
} else {
  print('i &gt; 0');
}
</code>
 
 <div class="hljs-button {2}"></div>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li></ul> 
<p><code>switch</code>条件分支</p> 
<pre class="prettyprint"><code class="prism language-dart has-numbering">// 在switch的case中可以使用整数、字符串、枚举类型和编译时常量
String command = 'OPEN';
switch (command) {
  case 'CLOSED':
    break;
  case 'OPEN':
    break;
  default:
    print('Default');
}
</code>
 
 <div class="hljs-button {2}"></div>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li></ul> 
<h4><a id="_471"></a>循环语句</h4> 
<h5><a id="_472"></a>基本循环</h5> 
<p>Dart中的基本循环语句与Java相同</p> 
<pre class="prettyprint"><code class="prism language-dart has-numbering">// for循环
for(int i = 0; i &lt; 9; i++) {
  print(i);
}
// while循环
while(true){
  //do something
}
// do-while循环
do{
  //do something
} while(true);
</code>
 
 <div class="hljs-button {2}"></div>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li></ul> 
<h5><a id="_492"></a>特有循环</h5> 
<pre class="prettyprint"><code class="prism language-dart has-numbering">var myList = ['Java','JavaScript','Dart'];
// for...in...循环，类似Java中的增强for
for (var it in myList ){
    print(it);
}
// forEach循环。其参数为一个Function对象，这里传入一个匿名函数
myList.forEach((var it){
    print(it);
});
// 可以使用匿名箭头函数简写
myList.forEach((it) =&gt; print(it));
</code>
 
 <div class="hljs-button {2}"></div>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li></ul> 
<p>使用循环遍历Map</p> 
<pre class="prettyprint"><code class="prism language-dart has-numbering">var myMap = {
'zhangsan':'201901',
'lisi':'201902',
'wangwu':'201902'
};
// forEach遍历Map
myMap.forEach((k, v) =&gt;  print("$k : $v"));
// 根据键获取值来遍历。通过keys返回Map中所有键的集合
for(var k in myMap.keys){
    print("$k : ${myMap[k]}");
}
</code>
 
 <div class="hljs-button {2}"></div>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li></ul> 
<p>下一篇 <a href="https://arcticfox.blog.csdn.net/article/details/88754457" rel="nofollow">Dart语言——45分钟快速入门（下）</a></p> 
<h3><a id="01_529"></a>关注我的公众号：编程之路从0到1</h3> 
<p><img src="https://images2.imgbox.com/47/c2/QvBtEzPe_o.jpg" alt="编程之路从0到1"></p> 
<div> 
 <div></div> 
</div> 
<div> 
 <div></div> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9b0ad8a9166af6a47a05f54de3514a0b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python怎么查询元素是否在列表中_python怎么判断某一元素是否在列表中</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3541c952f834531771b38e08d15d9ae1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ECCV2020最佳论文RAFT：Recurrent All-Pairs Field Transforms for Optical Flow</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>