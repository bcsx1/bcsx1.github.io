<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一个C语言的基本教程—指针篇 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一个C语言的基本教程—指针篇" />
<meta property="og:description" content="文章目录 9. C语言真正的灵魂——指针(1). 指针到底是什么？(2). 指针的基本结构(3). 取地址(&amp;)和解引用(*)操作符(4). 指针有什么用呢？#1.swap函数的例子#2.只传值的C语言函数#3.总结#4.其他语言一瞥 (5). 令人头疼的多重指针(6). 数组和指针的关系#1.指针的加减运算#2.连续的内存#3.传入数组的函数#4.返回数组的函数#5.一些运算符的优先级#6.以指针的方式访问数组#7.为什么数组下标要从0开始？#8.数组指针与指针数组 (7). 动态内存分配#1.从malloc说起：#2.改进后的calloc#3.灵活伸缩的realloc#4.多维数组和malloc函数#5.健忘的人们和迷茫的人们 (8). 等会儿，void* 是个啥？(9). 字符串去哪儿了？#1.我们见到的字符串#2.自定义的字符串 (10). 字符串/数组的更多操作#1.strlen()#2.strcpy()#3.strcat()#4.strcmp()#5.memcpy()#6.memset() (11). 现在我们就可以说说int argc和char* argv[]是什么东西了(12). 自由的指针和不自由的程序员(13). 关于“地址”的思考——我们能不能做个游戏修改器(CE)？(14). 关于函数指针小结 9. C语言真正的灵魂——指针 我想大家就算可能没有学过编程语言，也应该听说过指针的大名，指针的确是C语言中最重要的概念之一了，再我们具体讲完这一章之后，我相信你也会对我说的这句话有自己的理解。
(1). 指针到底是什么？ 有这么一件事情，AAA路上有两三百个商铺，而其中有 一家大型连锁奶茶店“好茶” 在这条街的头和尾各开了一家“好茶”，有一天你来逛街，朋友说：“去好茶买杯奶茶吧！”你表示认同，不过这条街上有两家好茶，要去哪一家呢？
我当然不是来让你考虑去哪一家的，只是我们可以把这个事情类比成C语言中的一些东西，我们来看下面这个程序：
#include &lt;stdio.h&gt; int main() { int a = 1; { int a = 2; printf(&#34;a = %d\n&#34;, a); } printf(&#34;a = %d\n&#34;, a); return 0; } 它的运行结果如下：
他们都叫做a，但是值不一样，就像是我们刚说的那条街上的两家店，虽然名字一样，但是他们肯定不是同一家店，那我们有什么办法区分它们吗？在现实中，我们可以用地址来区分它们：AAA路0100号好茶和AAA路3300号好茶，所以在C语言中对于变量我们也有这样的地址，这个地址就是变量在内存中的具体位置，而存储地址的变量，就称为指针(pointer)。
当然，指针并不一定都用在相同名字的变量上面，只是这个例子更加有助于我们理解“变量的位置”这个概念。我们也可以把指针想象成是一张写着地址的纸。
(2). 指针的基本结构 要声明一个指针变量还是比较简单的，只需要在各种数据类型后加一个*就好了，例如下面的三种写法：
int* p0; double * p1; float *p2; 从语言的角度来看，他们没有任何区别，不过我更推荐使用int* p的格式，将int* 看作int型指针这样一个新的数据类型。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/c4776937b50fb70b0243fc114bcec8b6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-10T10:51:49+08:00" />
<meta property="article:modified_time" content="2022-11-10T10:51:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一个C语言的基本教程—指针篇</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#9_C_1" rel="nofollow">9. C语言真正的灵魂——指针</a></li><li><ul><li><ul><li><a href="#1__4" rel="nofollow">(1). 指针到底是什么？</a></li><li><a href="#2__25" rel="nofollow">(2). 指针的基本结构</a></li><li><a href="#3__40" rel="nofollow">(3). 取地址(&amp;)和解引用(*)操作符</a></li><li><a href="#4__113" rel="nofollow">(4). 指针有什么用呢？</a></li><li><ul><li><a href="#1swap_114" rel="nofollow">#1.swap函数的例子</a></li><li><a href="#2C_138" rel="nofollow">#2.只传值的C语言函数</a></li><li><a href="#3_141" rel="nofollow">#3.总结</a></li><li><a href="#4_143" rel="nofollow">#4.其他语言一瞥</a></li></ul> 
    </li><li><a href="#5__167" rel="nofollow">(5). 令人头疼的多重指针</a></li><li><a href="#6__190" rel="nofollow">(6). 数组和指针的关系</a></li><li><ul><li><a href="#1_191" rel="nofollow">#1.指针的加减运算</a></li><li><a href="#2_230" rel="nofollow">#2.连续的内存</a></li><li><a href="#3_278" rel="nofollow">#3.传入数组的函数</a></li><li><a href="#4_325" rel="nofollow">#4.返回数组的函数</a></li><li><a href="#5_405" rel="nofollow">#5.一些运算符的优先级</a></li><li><a href="#6_425" rel="nofollow">#6.以指针的方式访问数组</a></li><li><a href="#70_434" rel="nofollow">#7.为什么数组下标要从0开始？</a></li><li><a href="#8_438" rel="nofollow">#8.数组指针与指针数组</a></li></ul> 
    </li><li><a href="#7__459" rel="nofollow">(7). 动态内存分配</a></li><li><ul><li><a href="#1malloc_462" rel="nofollow">#1.从malloc说起：</a></li><li><a href="#2calloc_491" rel="nofollow">#2.改进后的calloc</a></li><li><a href="#3realloc_498" rel="nofollow">#3.灵活伸缩的realloc</a></li><li><a href="#4malloc_505" rel="nofollow">#4.多维数组和malloc函数</a></li><li><a href="#5_549" rel="nofollow">#5.健忘的人们和迷茫的人们</a></li></ul> 
    </li><li><a href="#8_void__564" rel="nofollow">(8). 等会儿，void* 是个啥？</a></li><li><a href="#9__651" rel="nofollow">(9). 字符串去哪儿了？</a></li><li><ul><li><a href="#1_652" rel="nofollow">#1.我们见到的字符串</a></li><li><a href="#2_681" rel="nofollow">#2.自定义的字符串</a></li></ul> 
    </li><li><a href="#10__722" rel="nofollow">(10). 字符串/数组的更多操作</a></li><li><ul><li><a href="#1strlen_724" rel="nofollow">#1.strlen()</a></li><li><a href="#2strcpy_744" rel="nofollow">#2.strcpy()</a></li><li><a href="#3strcat_767" rel="nofollow">#3.strcat()</a></li><li><a href="#4strcmp_790" rel="nofollow">#4.strcmp()</a></li><li><a href="#5memcpy_813" rel="nofollow">#5.memcpy()</a></li><li><a href="#6memset_862" rel="nofollow">#6.memset()</a></li></ul> 
    </li><li><a href="#11_int_argcchar_argv_897" rel="nofollow">(11). 现在我们就可以说说int argc和char* argv[]是什么东西了</a></li><li><a href="#12__921" rel="nofollow">(12). 自由的指针和不自由的程序员</a></li><li><a href="#13_CE_941" rel="nofollow">(13). 关于“地址”的思考——我们能不能做个游戏修改器(CE)？</a></li><li><a href="#14__983" rel="nofollow">(14). 关于函数指针</a></li><li><a href="#_986" rel="nofollow">小结</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="9_C_1"></a>9. C语言真正的灵魂——指针</h2> 
<p>  我想大家就算可能没有学过编程语言，也应该听说过指针的大名，<strong>指针的确是C语言中最重要的概念之一</strong>了，再我们具体讲完这一章之后，我相信你也会对我说的这句话有自己的理解。</p> 
<h4><a id="1__4"></a>(1). 指针到底是什么？</h4> 
<p>  有这么一件事情，AAA路上有<strong>两三百个商铺</strong>，而其中有 <strong>一家大型连锁奶茶店“好茶”</strong> 在这条街的头和尾各开了一家“好茶”，有一天你来逛街，朋友说：“去好茶买杯奶茶吧！”你表示认同，不过这条街上有两家好茶，<strong>要去哪一家呢</strong>？<br>   我当然不是来让你考虑去哪一家的，只是我们可以把这个事情类比成C语言中的一些东西，我们来看下面这个程序：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  它的运行结果如下：<br> <img src="https://images2.imgbox.com/de/9e/PqCsIooz_o.png" alt="p48"></p> 
<p>  他们都叫做a，但是值不一样，就像是我们刚说的那条街上的两家店，虽然名字一样，但是他们<strong>肯定不是同一家店</strong>，那我们有什么办法区分它们吗？在现实中，我们可以用<strong>地址</strong>来区分它们：<strong>AAA路0100号好茶</strong>和<strong>AAA路3300号好茶</strong>，所以在C语言中对于<strong>变量</strong>我们也有这样的<strong>地址</strong>，这个地址就是变量在内存中的具体位置，而<strong>存储地址的变量</strong>，就称为<strong>指针(pointer)</strong>。<br>   <strong>当然，指针并不一定都用在相同名字的变量上面，只是这个例子更加有助于我们理解“变量的位置”这个概念。我们也可以把指针想象成是一张写着地址的纸。</strong></p> 
<h4><a id="2__25"></a>(2). 指针的基本结构</h4> 
<p>  要声明一个指针变量还是比较简单的，只需要在各种数据类型后加一个*就好了，例如下面的三种写法：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span><span class="token operator">*</span> p0<span class="token punctuation">;</span>
<span class="token keyword">double</span> <span class="token operator">*</span> p1<span class="token punctuation">;</span>
<span class="token keyword">float</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>
</code></pre> 
<p>  从语言的角度来看，他们<strong>没有任何区别</strong>，不过我<strong>更推荐使用int* p的格式，将int* 看作int型指针这样一个新的数据类型</strong>。<br>   不过就声明一下也没用啊，总得给它赋个值是吧，我们之前说指针是用来存储变量的地址的，所以<strong>每个指针都需要依托一个已经存在的值、新定义的值或是NULL</strong>，NULL是C语言中定义的一个宏，它代表<strong>空指针</strong>，我们在上面声明的三个指针都是仅声明的状态，就如同我们<strong>仅声明一个变量</strong>一样，这个指针会<strong>指向一个不确定的随机位置</strong>，我们将<strong>这种指向不确定位置的指针叫做“野指针”</strong>。所以说，如果<strong>没有明确</strong>指针p应该指向什么对象的时候，在声明的时候就应该将他们置为空指针：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span><span class="token operator">*</span> p0 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> <span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
</code></pre> 
<p>  说了这么多还是没有回答这个问题，假设有一个确定的变量a，我们怎么使p指向a呢（如果p存储的是a的地址，我们就称p是指向a的）？这就需要用到 <strong>取地址操作符(&amp;)</strong> 了。</p> 
<h4><a id="3__40"></a>(3). 取地址(&amp;)和解引用(*)操作符</h4> 
<p>  有点眼熟的嗷这个&amp;，我们最早说的用户输入好像就用到了这个：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  没错，这个&amp;正是我们要说的取地址操作符。我们可以用&amp;连接一个变量名来取得这个变量名的地址，到这里我们就可以回答上一节的问题了：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  这样一来我们就给p赋上了a的地址，这样一来p就指向a了。不过这段代码啥也不会做，对于一个地址，<strong>%p可以作为它的格式化占位符</strong>，我们把p打印出来试试看：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p = %p\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/e2/21/UEX7jt3L_o.png" alt="p49"></p> 
<p>  它打印出了一串十六进制的数字，这就是变量a的地址，当然你的运行结果可能跟我完全不一样，这是正常的，我们<strong>不能保证每个人运行的时候变量都存储在同一个地址上</strong>，甚至可能在同一台机器上运行几次的结果都是不一样的。<br>   看到这一串十六进制数字，你可能想<strong>自己打一串</strong>上去，然后指定C语言去帮你读写这个地址，<strong>完全没问题</strong>，这是你的自由，不过如果你<strong>尝试的数字太小</strong>，很有可能会出现异常，至于为什么，我会在<strong>第十二节</strong>中提到。<br>   那让我们再回到第一节的代码，两个a位于不同的作用域，如果在内外分别用printf打印出值来他们也是不一样的，他们的地址是不是也不一样呢，我们来试试看：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"outer a = %p\n"</span><span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"inner a = %p\n"</span><span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/1f/2a/hvmRhNFX_o.png" alt="p50"></p> 
<p>  他们的值不一样，地址也不一样。在C语言中，还有一个与取地址相反的操作，是取某个地址对应的值，这就是<strong>解引用操作符(*)</strong>。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"outer a = %d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"inner a = %d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/61/9b/XItiUydH_o.png" alt="p51"></p> 
<p>  很轻松的，我们就访问到了内部和外部两个a的值。那么很自然的，我们会想到下一个问题，指针到底有什么用呢？</p> 
<h4><a id="4__113"></a>(4). 指针有什么用呢？</h4> 
<h5><a id="1swap_114"></a>#1.swap函数的例子</h5> 
<p>  再回到之前提过的<strong>swap函数</strong>的例子，我们想要交换变量a和b的值，最初我们只能选择<strong>通过赋值的方式来改变</strong>，在我们了解了指针之后，我们可以改变一下自己的思路了，我们可以把swap写成这个样子：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %d, b = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %d, b = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/fa/db/MG7emaqp_o.png" alt="p52"></p> 
<p>  成功了！我们<strong>没有在main里面对a和b做任何的赋值操作就完成了交换a和b的操作</strong>，那为什么我们要这么做呢？</p> 
<h5><a id="2C_138"></a>#2.只传值的C语言函数</h5> 
<p>  如标题所说，C语言的所有函数的参数都只参数对应的值进来，你可以认为是<strong>传入了一个值</strong>，然后在<strong>函数的作用域中再创建了一个同名的变量把这个值存起来</strong>，这才使得我们在指针之前做的swap函数没有办法交换两个变量的值，但指针是<strong>某变量的确定位置</strong>，就像是<strong>送一封信给小明</strong>和<strong>送一封信到BBB路3213号XXX小区0x1001号楼503室</strong>的区别一样。<br>   由此就产生了这个问题：仅仅把变量名传入是没有办法对变量进行修改的。不过，传地址的值进去就没问题了，我们直接对地址读写就好了。</p> 
<h5><a id="3_141"></a>#3.总结</h5> 
<p>  因此指针带来的一个最大好处是：<strong>可以在函数体内改变函数体外声明的变量的值了（不用在函数体外对变量赋值）</strong></p> 
<h5><a id="4_143"></a>#4.其他语言一瞥</h5> 
<p>  我的确是很喜欢C++哈哈哈哈哈，来看看C++中是如何应对函数内改变变量值的需求的：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a<span class="token punctuation">{<!-- --></span><span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">,</span> b<span class="token punctuation">{<!-- --></span><span class="token number">31</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a = "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">", b = "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>   
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a = "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">", b = "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> temp<span class="token punctuation">{<!-- --></span>a<span class="token punctuation">}</span><span class="token punctuation">;</span>
    a <span class="token operator">=</span> b<span class="token punctuation">;</span>
    b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/3d/3d/tC66Dtls_o.png" alt="p53"></p> 
<p>  它也完成了交换的工作，不过参数类型好像有点不一样，这里写在<strong>类型后、变量名前的&amp;可不是取地址操作符</strong>，这是C++中引入的 <strong>“引用类型”</strong> ，引用类型是一种<strong>指针常量</strong>，即int* const p;（p不能改变，但*p可以发生改变），通俗来说就是给变量起了一个别名，然后调用别名也相当于调用本体了。这样做的好处是：<strong>减少指针的使用</strong>，指针的<strong>自由性</strong>给程序员带来了很多方便，但是也会因为各种各样的原因产生危险，这在之后的内容中会提到。</p> 
<h4><a id="5__167"></a>(5). 令人头疼的多重指针</h4> 
<p>  指针指针，说到底其实还是一个变量，既然是变量那就存在于内存中，指针也会有自己的地址，所以如果我们对指针试着取个地址呢：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;a = %p\n"</span><span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;p = %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/75/09/DUYYRps2_o.png" alt="p54"></p> 
<p>  还真能行！我们对一个指针取了地址并打印出来，我们把&amp;p1用p2存起来，那应该写成这样：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>p1<span class="token punctuation">;</span>
</code></pre> 
<p>  这个p2就叫做<strong>二重指针</strong>，即<strong>指向指针的指针</strong>，不过如同我之前说的多维数组一样，C语言中也没有内置二重指针这种类型，所以<strong>二重指针</strong>，<strong>三重指针</strong>这种也只是：<strong>指针的指针</strong>、<strong>指针的指针的指针</strong>…<br>   多重指针的理解是这样的：有一个变量Zeta，Alice说去找Bob，Bob说去找Caren，就这么一直传下去传到了Y，Y说去找Zeta，我们终于找到Zeta了，也就是说，Y写着Zeta地址的纸，再往前一直如此，最终Alice是写着Bob地址的纸。<br>   他的确是可以这么一直取地址下去，不过指针的维度越高，对于人来说就<strong>越难以理解</strong>，所以一般来说用的更多的也只有<strong>一重指针和二重指针</strong>。</p> 
<h4><a id="6__190"></a>(6). 数组和指针的关系</h4> 
<h5><a id="1_191"></a>#1.指针的加减运算</h5> 
<p>  我们再把之前指针的值拿过来：(0x代表这是一个十六进制数)<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          p 
         
        
          = 
         
        
          0 
         
        
          x 
         
        
          0000008 
         
        
          c 
         
        
          375 
         
        
          f 
         
        
          f 
         
        
          86 
         
        
          c 
         
        
       
         p = 0x0000008c375ff86c 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">0000008</span><span class="mord mathnormal">c</span><span class="mord">375</span><span class="mord mathnormal" style="margin-right: 0.1076em;">ff</span><span class="mord">86</span><span class="mord mathnormal">c</span></span></span></span></span></span><br>   这个p是int* 类型的，不过我们也并没有说p是常量，那地址肯定是可以改变的，假设我们对p做一次自增会怎么样呢？</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p = %p\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"++p = %p\n"</span><span class="token punctuation">,</span> <span class="token operator">++</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/55/ba/hjZt58Tm_o.png" alt="p55"></p> 
<p>  好像这个地址的变化不像我们想的一样只是简单的加一，这个++p和p相差的值貌似是4，而且好像sizeof(int)也是4啊，我们再来多试几次：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(int) = %u\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p = %p\n"</span><span class="token punctuation">,</span> p<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">12.0</span><span class="token punctuation">,</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(double) = %u\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p1 = %p\n"</span><span class="token punctuation">,</span> p1<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/50/3b/lYIj2IuD_o.png" alt="p56"></p> 
<p>  这回我还顺便实验了一下double，<strong>果然每次+1之后地址都是直接加了一个sizeof(type)</strong>，这是为什么呢？很简单：类型是固定的，每一次向后跳转都是<strong>逻辑的跳转</strong>，一个int类型占用<strong>四个字节</strong>，假设我们只往后偏一个字节，相当于是访问了一个int值四个字节中的<strong>第三个字节往后的内容</strong>，这就<strong>乱了套</strong>了是吧，所以<strong>对于指针的加减运算，都是直接跳转指针的类型对应的字节数</strong>。<br>   每次+1都可以向后跳转一个int值，我们可以看到上面的p，每一个之间都差了4，这说明这<strong>几个地址在内存中是连续</strong>的，好像<strong>数组就是一种在内存中分配一片连续内存用于存储数据的东西</strong>来着，是吧？那数组是不是和指针有着什么联系呢？</p> 
<h5><a id="2_230"></a>#2.连续的内存</h5> 
<p>  所以的确，数组与指针有着千丝万缕的联系，我们先来做这么一件事情：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f6/38/mUFhvPpp_o.png" alt="p57"></p> 
<p>  果然！数组a中的五个数字的地址都是连着的！这就验证了我说的：<strong>数组是分配一片连续内存来存储数据的结构</strong>。在C语言中，数组和指针是可以互相转换的，比如我们如果直接用%p打印出a和a[0]的地址：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %p\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;a[0] = %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f2/f6/pPQtb53p_o.png" alt="p58"></p> 
<p>  没错，以地址形式访问数组a时，访问的就是数组的第一个元素，所以有这个等式：&amp;a[0] == a，指针与数组就可以互相转换了。<br>   不过这样的转换过程是退化的过程，因为<strong>数组是分配一片内存的，它是确定大小的</strong>，<strong>指针只能保证指向的位置有效，后续的内存是否属于这个数组是不明确的</strong>，比如我们看看下面这个例子：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(b) == %d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(a) = %d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/24/cb/GeWKvAWq_o.png" alt="p59"></p> 
<p>  在这里我使用了后面一节会讲到的malloc函数，你先别管那么多，<strong>b就是一个能容纳5个int值的数组</strong>，我们把<strong>a和b的字节数都用sizeof输出出来</strong>，结果发现，明明都是5个int值，为什么a是正确的，b是错误的呢？<br>   其实是这样的：b虽然是一个数组，但是它其实是一个动态分配出来的指针，它不具备数组的特性，只是我们可以通过数组的方式进行访问而已，因为我使用的机器是64位，对于内存的寻址应该是从<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         0000 
        
       
         , 
        
       
         . 
        
       
         . 
        
       
         . 
        
       
         , 
        
       
         0000 
        
       
         → 
        
       
         1111 
        
       
         , 
        
       
         . 
        
       
         . 
        
       
         . 
        
       
         , 
        
       
         1111 
        
       
      
        0000,...,0000 \to 1111,...,1111 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8389em; vertical-align: -0.1944em;"></span><span class="mord">0000</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">0000</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8389em; vertical-align: -0.1944em;"></span><span class="mord">1111</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">1111</span></span></span></span></span>(64位)，所以内存占用8字节存储地址，而a是数组，有确定的大小，所以打印出来就是5*sizeof(int) = 20。<br>   因此你明白了，<strong>数组和指针虽然有联系，但他们不完全是相同的</strong>，<strong>数组可以转换为指针，不过转换的过程属于退化</strong>，指针只对指向的元素负责，后续的元素并不能保证是被分配给当前指针的。</p> 
<h5><a id="3_278"></a>#3.传入数组的函数</h5> 
<p>  把数组作为参数传入函数是一个很自然的想法，在此我就不再多言，对于一维数组我们可以：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>  对于一维数组，传数组可以<strong>不用确定数组大小</strong>（中括号内不用填数字），当然填了也行，只是这样一来就会<strong>限定传入数组的大小。</strong> 不过对于二维数组来说，这件事情是不成立的：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>  传入二维数组时，后面一个维度的参数必须传入，否则就不能通过编译，不过你可能想这么一件事情：我们如果用C语言写一个跟矩阵有关的函数，那<strong>矩阵规模不能直接确定，后续通过n，m两个参数传入即可</strong>，能不能这么做呢：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>  这样不行，因为n和m还没有声明过，不过改成下面这样就可以了：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> mat<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			mat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> 
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>mat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> 
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> mat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> arr<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/62/b2/uoxjuwIq_o.png" alt="p66"></p> 
<p>  还真行，<strong>这回我甚至都不知道可以这么做了哈哈哈哈哈哈</strong>，这个例子当中比较重要的一点是：<strong>在具体调用函数传数组的时候，数组的后面不要跟中括号，否则它代表的是取值而不是传入数组</strong>！这么写参数表我不知道算不算是特性，<strong>一般来说如果要传入规模不定的多维数组更多的应该是采用退化成指针的方式</strong>：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="4_325"></a>#4.返回数组的函数</h5> 
<p>  假设有这么一个情景：你<strong>把一个数组arr传入了函数f，在函数中对arr进行了一些操作，然后再操作完成后，你希望函数把数组返回</strong>，这样就可以在别的地方把这个数组<strong>赋值给一个新的变量</strong>了，你可能想这么写：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> arr2<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  这段代码都不用跑，你就知道<strong>肯定不能正常运行</strong>，我在多维数组的那一部分就曾经提到过，C语言中没有int[]这样的数据类型，所以<strong>通过这样的方式返回一个数组是做不到的</strong>，不过嘛…C语言也没有完全堵死返回数组的操作：<strong>我们可以把数组退化成指针再返回</strong>：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span><span class="token operator">*</span> arr2 <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/3b/c1/FM24XCgQ_o.png" alt="p64"></p> 
<p>  大功告成！我们用f函数返回了一个处理过后的数组。由此你就明白了：<strong>由于不存在int []类型，我们就必须把数组退化成为指针再作为返回值返回。</strong><br>   还有一个问题：我们说C语言的函数参数都是传值的，那传入的这个数组arr和main函数中的arr是同一个对象吗？</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"In f, arr = %p\n"</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"In main, arr = %p\n"</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> arr2 <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/22/62/4jBhsDIR_o.png" alt="p65"></p> 
<p>  有那么一点出乎意料，不过也在情理之中，事实上对于数组参数，<strong>对于它的传值是传入地址，而不是将数组复制一份</strong>。</p> 
<h5><a id="5_405"></a>#5.一些运算符的优先级</h5> 
<p>  你时常可以从别人的代码中看到这样的东西：*p++，p是一个指针，p++就是自增操作，不过返回本身的值，而*p则是访问对应地址的值，所以总结一下就是，<strong>访问当前地址的值，然后把地址向后推一位，</strong> 这是个很聪明的操作，至少代码可以少写那么一两行，假设你有一天也这么写，不过多写了一个括号，即(*p)++，会怎么样呢？</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p = %p\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %d\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p = %p\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/43/53/dLhsbzzb_o.png" alt="p67"></p> 
<p>  结果就是指针p没变，a的值还加了1，这是因为这个括号改变了运算的优先级，我们应该来了解一下 <strong>*, &amp;, ++, --等等运算符之间的优先级</strong> ：</p> 
<ul><li>  !, ~, ++, --, -, *, &amp;, sizeof()的优先级其实是相同的，在他们同时出现的时候，遵循<strong>从右向左结合</strong>的规则。</li><li>  (), []，.和-&gt;的优先级要高于上述运算符，(.和-&gt;我们之后来介绍)</li></ul> 
<h5><a id="6_425"></a>#6.以指针的方式访问数组</h5> 
<p>  结合前面几节的内容，就很好想到了：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>arr <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>  这很好，因为arr就是首元素的地址，加上一个<strong>偏移量i</strong>之后，就是第i个元素的地址了，再通过*访问，就完成了！</p> 
<h5><a id="70_434"></a>#7.为什么数组下标要从0开始？</h5> 
<p>  看我上一节加粗的<strong>偏移量i</strong>，没错，数组下标从0开始就是因为这个<strong>偏移量(offset)</strong>，我们以指针方式访问数组的时候，*arr就相当于*(arr+0)，<strong>相对于arr这个地址偏移的量为0，所以首元素就是从下标0开始</strong>了。<br>   从0开始当然不是计算机的什么神秘仪式，下标从0开始就是从偏移量开始的，后来很多的编程语言已经没有指针了，但是他们仍然保留了从0开始这个规则。</p> 
<h5><a id="8_438"></a>#8.数组指针与指针数组</h5> 
<p>  数组指针比较好说，&amp;a[0]或者直接用a，他们就是一个数组指针，即<strong>指向数组的指针</strong>，<strong>指针数组则是一个存储指针的数组</strong>，我们来看个例子：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token operator">*</span> array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
    array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
    array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p : %d\n"</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/b0/a0/x97lPVrL_o.png" alt="p68"></p> 
<p>  这么以来我们就存了三个指针进入数组中，这就是指针数组。</p> 
<h4><a id="7__459"></a>(7). 动态内存分配</h4> 
<p>  可算是讲到这里了，我在数组篇就挖的坑到这儿该填了，这次我们来讲讲stdlib.h头文件中的malloc函数。<br>   之前提到：直接声明并定义的数组是存放在<strong>栈内存</strong>中的，不过栈内存的空间并不算很大，而且如果不用VLA的话，我们不能在运行期确定数组的大小。<strong>那C语言当然能解决这个问题啊，堆内存那么大，不用岂不是很浪费？</strong> calloc、malloc和realloc函数就是用于处理这个问题的好方法。</p> 
<h5><a id="1malloc_462"></a>#1.从malloc说起：</h5> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// malloc的使用方法</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记得free</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/9d/51/ddQbtrfJ_o.png" alt="p69"></p> 
<p>  还不错，这段代码里我们用malloc分配了一片内存给a，之后就可以<strong>按照数组的方式操作</strong>了！这就是<strong>动态分配内存</strong>的魅力，数组的<strong>大小n也是由用户输入确定</strong>的，这也满足了我们在数组篇就希望的在运行期确定数组大小。<br>   malloc函数的原型如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>  其中的<strong>参数size就是分配内存的字节数</strong>，在我们使用的时候，由于<strong>机器和编译环境不同可能不确定int的字节数</strong>，所以我们可以<strong>用n*sizeof(int)的方式自动计算出字节数</strong>，然后分配内存，当然，n*sizeof(double)等等也都是可以的，然后由于函数分配后得到的是<strong>void型指针</strong>，我们得把它<strong>显式类型转换</strong>为int*才行。<br>   在最后，我们还调用了free()函数，这个函数没有返回值。<strong>只要使用了动态内存分配，那么我们就一定需要调用free()把这片内存还给操作系统</strong>：虽然程序退出的时候的确会自己把空间还回去，但是有的时候我们可能需要<strong>长期运行一个程序</strong>，假设经常会有malloc分配内存，如果一直不free掉，迟早有一天所有的内存都会被消耗殆尽，那就很有可能就会导致软件崩溃，甚至系统崩溃。所以说，<strong>一定要记得在适当的地方free!</strong></p> 
<h5><a id="2calloc_491"></a>#2.改进后的calloc</h5> 
<p>  calloc函数与malloc其实差不多，不过是malloc的改进版，它的原型如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">calloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> num<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>  其中num是元素的个数，size是每个元素所占据的字节数，这个函数与malloc的最大区别是：调用calloc分配的内存会自动在每个位置上赋0值，有的时候这好像是个不错的操作呢。</p> 
<h5><a id="3realloc_498"></a>#3.灵活伸缩的realloc</h5> 
<p>  realloc是re-allocate的意思，利用realloc函数可以重新分配已经分配好的内存，它的原型如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">realloc</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>  ptr就是已经分配好的内存对应的指针，size是新的空间大小，变大变小都是可以的。在此就不过多介绍了。</p> 
<h5><a id="4malloc_505"></a>#4.多维数组和malloc函数</h5> 
<p>  说了malloc函数可以用于动态分配一个一维数组出来，那二维数组甚至是多维数组呢？很容易想到我们可以这么做：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> arr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>m <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">free</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/6d/04/Lo4UE1MG_o.png" alt="p70"></p> 
<p>  我们创建了一个<strong>三行五列的矩阵啊</strong>，首先是新建了一个int**类型的变量arr，之后<strong>用malloc分配n个sizeof(int*)的空间用于存储n个能容纳m个int元素的内存的地址</strong>，然后从arr[0]到arr[n-1]一个一个去用malloc分配内存，这样就形成了一个二维数组了！<br>   程序结束之前，我们先用<strong>for循环把arr中每个元素地址对应分配的内存给free掉</strong>，<strong>再把arr对应的内存也给free掉</strong>，这样就好了，对于更高维度的数组我们也可以做类似的操作。<br>   这个过程中，arr其实就是一个指针数组，它的每一个元素都是一个指针。<br>   不过有一个问题：为什么我们一定要用for循环一个一个元素去free呢？我只free掉arr不行吗？要回答这个问题，我们把上面的程序中的printf("%d ", arr[i][j]);改为<strong>打印每个元素的地址</strong>试试：<br> <img src="https://images2.imgbox.com/cf/ce/ZEoyrLYP_o.png" alt="p71"></p> 
<p>  哦吼？我们会发现<strong>第一行在最后一个元素和第二行第一个元素之间并不是只差4字节</strong>，<strong>三个int*之间都不是连续的</strong>，与之对比，我们来看看int a[3][5]的表现：<br> <img src="https://images2.imgbox.com/fc/33/6lMfFrZf_o.png" alt="p72"></p> 
<p>  分配在<strong>栈内存上的多维数组中的元素地址是连续</strong>的，所以这也就告诉我们：动态内存分配得到的多维数组与栈内存上的数组是<strong>不同</strong>的，<strong>动态内存分配得到的数组的每一行之间可能是不连续的</strong>，因此我们<strong>不能通过一个free一次把他们全都归还，所以必须要用for循环的方式一行一行free掉</strong>。</p> 
<h5><a id="5_549"></a>#5.健忘的人们和迷茫的人们</h5> 
<p>  初学者们经常把free忘掉，毕竟大家之前用数组也没有说要free掉，这是个习惯问题，而动态内存分配的老手们则会迷茫：我应该在什么时候调用free呢？很多人总是不知道应该在什么时候使用free来节省内存，当然，我有的时候也会遇到这些问题，这可能需要你长期的coding经验，所以，多尝试一下，总是没有坏处的。<br>   不得不再提一下C++，之前我有提到C++中的引用，这是“去指针化”的步骤之一，当然因为要兼容C语言不可能把指针全部去掉，那有没有什么好办法可以避免忘记归还内存呢？</p> 
<ul><li>先说一句：C++中可以使用new语句来动态分配内存：</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> 
<p>  这要比C语言的malloc先进不少，至少我不用自己去算字节数了是吧。对应的，如果要归还内存，需要用到delete语句：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span>
或
<span class="token keyword">delete</span> a<span class="token punctuation">;</span>
</code></pre> 
<p>  中间加不加中括号取决于你的a是<strong>一个数组还是仅仅是一个对象指针</strong>。在C++中，大家也会经常忘记delete这件事情，所以从C++03开始，出现一个新东西：<strong>智能指针</strong>，早期的是auto_ptr，在C++11标准中auto_ptr被移除，取而代之的是unique_ptr和shared_ptr，他们的具体区别我就不提了，但是他们最大的特点是：<strong>在指针对应的对象生命期结束的时候会自动调用对象的析构函数，然后自动delete掉这个它，这可真是个不错的事情</strong>！</p> 
<h4><a id="8_void__564"></a>(8). 等会儿，void* 是个啥？</h4> 
<p>  上一节在讲malloc函数的时候我们说：malloc返回的是一个void类型的指针，我一下就跳过了，不过我想你应该会感到奇怪吧，我们说<strong>void是指什么都没有的空类型</strong>，那void*是啥？<br>   void* 并不是与void对应的“空指针”，它真正的意思是<strong>无类型指针</strong>，即我们通过malloc分配的<strong>仅仅只是一片连续内存，没有对空间进行划分</strong>,这样一来也就没有类型的区别了。<br>   那void*除了被我们转换为不同类型的指针，它就没有别的作用了吗？你先别急，我们来看下面这一段代码：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">void</span><span class="token operator">*</span> array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">0.123</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> c <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>
	
	array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
	array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
	array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>c<span class="token punctuation">;</span>
	
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1.%d\n"</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2.%f\n"</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token operator">*</span><span class="token punctuation">)</span>array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3.%s\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/7b/d3/TfTLgtGf_o.png" alt="p73"></p> 
<p>  先缓缓，我们先来解释一下这段代码在干什么：<strong>首先创建一个容纳三个无类型指针的数组，然后把整数a，双精度浮点数b和字符串c转换成无类型指针再存入array中，之后我们把各个元素取出来再解引用</strong>，打印出了不同的值，由此一来，我们便<strong>在一个数组中存放了三个不同类型的元素</strong>，是不是感觉让你大受震撼？在类型系统这么强的C语言中，居然能够有一个数组同时存放三个类型的元素！<br>   除此之外，void*还有一个用途，在stdlib.h头文件中有一个内置函数叫做qsort，它的原型如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">qsort</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> base<span class="token punctuation">,</span> <span class="token class-name">size_t</span> num<span class="token punctuation">,</span> <span class="token class-name">size_t</span> width<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">(</span>__cdecl<span class="token operator">*</span> compare<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>  有点复杂，不过其实四个参数都很好理解：</p> 
<ul><li>void* base：被排序的数组（不指定数组类型）</li><li>size_t num：被排序数组中元素的个数</li><li>size_t width：一个元素的字节数</li><li>int(__cdecl* compare)(const void*,const void*)：这个有点复杂，其中的compare是一个<strong>函数指针</strong>，返回值的类型为int，它的两个参数均为const void* 类型，即<strong>无类型指针类型</strong>，使用<strong>const保证了compare内部不会对传入值进行修改</strong></li></ul> 
<p>  那么数组base使用的void*确保了<strong>无论传入什么样的数组都是可以排序的</strong>，这种在强类型语言中可以<strong>应对各种不同类型的函数</strong>就是<strong>泛型</strong>，泛型可以减少程序员的劳动，不必再对每一种类型都单独写一个函数了，不过在C语言中，通过void*实现的泛型还是很受限制的，比如你可能可以想到这么一件事情：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg1<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> arg2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">void</span> temp <span class="token operator">=</span> <span class="token operator">*</span>arg1<span class="token punctuation">;</span>
    <span class="token operator">*</span>arg1 <span class="token operator">=</span> <span class="token operator">*</span>arg2<span class="token punctuation">;</span>
    <span class="token operator">*</span>arg2 <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  看似很有道理，这样一来这个swap函数不管传入什么都可以交换了，不过实际上如果你仔细看看就会发现问题：</p> 
<pre><code class="prism language-c">    <span class="token keyword">void</span> temp <span class="token operator">=</span> <span class="token operator">*</span>arg1<span class="token punctuation">;</span>
</code></pre> 
<p>  在C语言中，变量的类型不能为void，这样一来temp就不能产生了，而不止于此，后面的*arg1也是错误的，我们在<strong>解引用操作的时候会返回指针对应地址的值，这个值是与类型相关的</strong>：int型占4字节，double型占8字节，<strong>如果连类型都不能确定，C语言从这个地址向后取几个字节作为返回值呢</strong>？当然，针对于不同类型的swap函数我们之后会实现，但不是用如上的办法。<br>   这个例子就说明了一个事情：C语言并没有完全支持泛型这种编程范式，更多的只是通过void*取了个巧，C++支持非常非常多的编程范式，泛型就是其一，泛型在C++中的体现是<strong>模板</strong>，当我们声明模板，利用<strong>模板编写函数或类之后</strong>，在调用的过程中编译器会<strong>自动生成对应类型的代码</strong>：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> arg1<span class="token punctuation">,</span> T<span class="token operator">&amp;</span> arg2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    T temp <span class="token operator">=</span> arg1<span class="token punctuation">;</span>
    arg1 <span class="token operator">=</span> arg2<span class="token punctuation">;</span>
    arg2 <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token generic-function"><span class="token function">swap</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a = "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> 
    <span class="token operator">&lt;&lt;</span> <span class="token string">"b = "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  以上的代码你可以自己尝试执行一下，在此我就不过多阐述了。void*指针的更多妙用你可以自己尝试一下，在这里我想再说一说qsort函数。</p> 
<ul><li>qsort函数是C语言内置的快速排序函数，可以对传入的<strong>任何类型数组实现快速排序</strong>，而使用qsort最关键的一点是要自己写一个compare函数，compare函数的原型是这样：</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> vp1<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> vp2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>  返回值类型必须为int，传入的两个参数类型均为void*类型，举个例子：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> vp1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> vp2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>vp1 <span class="token operator">-</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>vp2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  这就是一个针对于int类型值的排序，<strong>当compare的返回值大于0时，vp1对应的元素会排在vp2的右边；小于0时，vp1则会在vp2的左边，等于0时，二者的顺序不确定。</strong><br>   排序的规则由你自行定义，不过要<strong>保证传入的指针类型以及传出的值类型</strong>。</p> 
<h4><a id="9__651"></a>(9). 字符串去哪儿了？</h4> 
<h5><a id="1_652"></a>#1.我们见到的字符串</h5> 
<p>  我还是觉得你应该是学过或者至少了解过python之类的其他语言，在这些语言中你可能很早就接触过了 <strong>“字符串”</strong> 这个概念，很简单，就是一串字符构成的一种数据类型，有的时候我们<strong>输出运算结果，也可以增加一些辅助文字——即构造一个字符串用于打印</strong>，那C语言的字符串去哪了？我们先来看看这个：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The value of b is %d\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  我就不加运行截图了，你<strong>很容易知道会打印出什么东西来</strong>。其实，在printf函数中用<strong>一对双引号所括起来的部分就是一个字符串</strong>，我们一直都在用它，只是没有提出来而已，不过这样的字符串被称为<strong>字符串字面量</strong>，是一个常量。<strong>字符串字面量</strong>存储在内存中的常量区，看下面这个例子：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p1 = %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token string">"Hello,world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span>b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p1 = %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token string">"Hello,world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不要忘记free()哦</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/99/41/foQeRc9q_o.png" alt="p62"></p> 
<p>  中间写一段的目的是<strong>排除在栈内存和堆内存中的可能性</strong>，即便我们没有把"Hello,world!"这个字符串赋给某个变量，它<strong>还是被储存下来了</strong>，这也就说明了字符串字面量是<strong>存储在常量区</strong>的。</p> 
<h5><a id="2_681"></a>#2.自定义的字符串</h5> 
<p>  遗憾的是C语言<strong>没有提供一个类似于C++/Java中的string类</strong>，C语言的字符串是<strong>基于字符数组实现</strong>的，其与字符数组最大的区别是：字符串的尾部需要添加’\0’字符作为结尾标志，我们可以把’\0’字符称为空字符，它的ASCII码值正好是0，所以在给某一位赋值为’\0’时也可以直接赋值为0。<br>   字符串"Hello,world!"是这样存储（数组形式）的：<br> <img src="https://images2.imgbox.com/f0/e7/dTRDg2Bl_o.png" alt="p60"></p> 
<p>  在C语言中初始化这样一个字符串有三种方法：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token char">'H'</span><span class="token punctuation">,</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'l'</span><span class="token punctuation">,</span><span class="token char">'l'</span><span class="token punctuation">,</span><span class="token char">'o'</span><span class="token punctuation">,</span><span class="token char">','</span><span class="token punctuation">,</span><span class="token char">'w'</span><span class="token punctuation">,</span><span class="token char">'o'</span><span class="token punctuation">,</span><span class="token char">'r'</span><span class="token punctuation">,</span><span class="token char">'l'</span><span class="token punctuation">,</span><span class="token char">'d'</span><span class="token punctuation">,</span><span class="token char">'!'</span><span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 方法1</span>
    <span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello,world!"</span><span class="token punctuation">;</span> <span class="token comment">// 方法2</span>
    <span class="token keyword">char</span><span class="token operator">*</span> str3 <span class="token operator">=</span> <span class="token string">"Hello,world!"</span><span class="token punctuation">;</span> <span class="token comment">// 方法3</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/9a/85/7BTnAtub_o.png" alt="p61"></p> 
<p>  我们用%s作为字符串的格式化占位符，可以将字符串打印出来，三种方法中，前两种是在<strong>字符数组</strong>的基础上操作的，只要保证<strong>数组长度大于等于字符总数</strong>就行了，第三种则是以<strong>指针</strong>的形式出现的。当然，第一种方式有种不太聪明的感觉…<br>   第一种就不必说了，第二种是把<strong>字符串拷贝一份</strong>过来形成的新字符串，而第三种则是<strong>直接指向字符串常量</strong>：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token char">'H'</span><span class="token punctuation">,</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'l'</span><span class="token punctuation">,</span><span class="token char">'l'</span><span class="token punctuation">,</span><span class="token char">'o'</span><span class="token punctuation">,</span><span class="token char">','</span><span class="token punctuation">,</span><span class="token char">'w'</span><span class="token punctuation">,</span><span class="token char">'o'</span><span class="token punctuation">,</span><span class="token char">'r'</span><span class="token punctuation">,</span><span class="token char">'l'</span><span class="token punctuation">,</span><span class="token char">'d'</span><span class="token punctuation">,</span><span class="token char">'!'</span><span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 方法1</span>
    <span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello,world!"</span><span class="token punctuation">;</span> <span class="token comment">// 方法2</span>
    <span class="token keyword">char</span><span class="token operator">*</span> str3 <span class="token operator">=</span> <span class="token string">"Hello,world!"</span><span class="token punctuation">;</span> <span class="token comment">// 方法3</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"str1p = %p\n"</span><span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"str2p = %p\n"</span><span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"str3p = %p\n"</span><span class="token punctuation">,</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"strSp = %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token string">"Hello,world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/b8/f2/bcU8MVYV_o.png" alt="p63"></p> 
<p>  strSp是常量区的"Hello,world!"的地址，str3的地址和它是完全一致的。</p> 
<h4><a id="10__722"></a>(10). 字符串/数组的更多操作</h4> 
<p>  在C语言中有一个叫做string.h的头文件，其中包含了很多字符串相关的函数，并且还有一部分内存操作的函数，我们将介绍：strlen()，strcpy()，strcat()，strcmp()，memcpy()，memset()这几个函数。</p> 
<h5><a id="1strlen_724"></a>#1.strlen()</h5> 
<ul><li>函数原型：size_t strlen(const char* str);</li><li>参数：字符串str</li><li>作用：<strong>数出字符串str的字符数（不包含’\0’）</strong></li><li>返回值：字符串str的长度（不包含字符串尾部的’\0’字符）</li><li>例子：</li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token string">"Hello,world!"</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"strlen(%s) = %d\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/6c/ca/fcOu2l2F_o.png" alt="p74"></p> 
<ul><li>注意：请保证传入的是字符串（包含’\0’且在正确位置上）而不是字符数组</li></ul> 
<h5><a id="2strcpy_744"></a>#2.strcpy()</h5> 
<ul><li>函数原型：char* strcpy(char* dest, const char* src);</li><li>参数：目标字符串dest，源字符串src</li><li>作用：<strong>将源字符串src的内容复制到目标字符串dest</strong></li><li>返回值：指向目标字符串dest的指针</li><li>例子：</li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> dest<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span><span class="token operator">*</span> src <span class="token operator">=</span> <span class="token string">"Wonderful day!"</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span><span class="token operator">*</span> d <span class="token operator">=</span> <span class="token function">strcpy</span><span class="token punctuation">(</span>dest<span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"d = %s\n"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"dest = %s\n"</span><span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/40/0a/dubQJeWN_o.png" alt="p75"></p> 
<ul><li>注意：目标数组dest的长度要足够，否则如果源字符串太长可能会出现溢出的问题</li></ul> 
<h5><a id="3strcat_767"></a>#3.strcat()</h5> 
<ul><li>函数原型：char* strcat(char* dest, const char* src);</li><li>参数：目标字符串dest，源字符串src</li><li>作用：<strong>将源字符串src的内容拼接到目标字符串dest之后</strong></li><li>返回值：指向目标字符串dest的指针</li><li>例子：</li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> dest<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello,"</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span><span class="token operator">*</span> src <span class="token operator">=</span> <span class="token string">"world!"</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span><span class="token operator">*</span> d <span class="token operator">=</span> <span class="token function">strcat</span><span class="token punctuation">(</span>dest<span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"d = %s\n"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"dest = %s\n"</span><span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/40/62/2WOLjh5p_o.png" alt="p76"></p> 
<ul><li>注意：目标数组dest的长度要足够，否则如果源字符串太长可能会出现溢出的问题</li></ul> 
<h5><a id="4strcmp_790"></a>#4.strcmp()</h5> 
<ul><li>函数原型：int strcmp(const char* str1, const char* str2);</li><li>参数：需要比较的字符串str1和str2</li><li>作用：<strong>两个字符串自左向右逐个字符相比（按 ASCII 值大小相比较），直到出现不同的字符或遇 \0 为止</strong></li><li>返回值：return &lt; 0 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          → 
         
        
       
         \rightarrow 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.3669em;"></span><span class="mrel">→</span></span></span></span></span> str1 &lt; str2;<br> return == 0 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          → 
         
        
       
         \rightarrow 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.3669em;"></span><span class="mrel">→</span></span></span></span></span> str1 == str2;<br> return &gt; 0 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          → 
         
        
       
         \rightarrow 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.3669em;"></span><span class="mrel">→</span></span></span></span></span> str1 &gt; str2;</li><li>例子：</li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span><span class="token operator">*</span> str1 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span><span class="token operator">*</span> str2 <span class="token operator">=</span> <span class="token string">"ABC"</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"strcmp(%s, %s) = %d\n"</span><span class="token punctuation">,</span> str1<span class="token punctuation">,</span> str2<span class="token punctuation">,</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/c8/54/CETkvIkn_o.png" alt="p77"></p> 
<ul><li>注意：返回的具体值<strong>与编译器有关</strong>，C语言标准仅规定了<strong>返回值的正负</strong></li></ul> 
<h5><a id="5memcpy_813"></a>#5.memcpy()</h5> 
<ul><li><strong>memcpy和memset不仅仅是字符串的操作，他们本身都是直接对内存操作，因此无论是什么类型的指针都可以</strong></li><li>函数原型：void* memcpy(void* vp1, const void* vp2, size_t n);</li><li>参数：数据源指针vp2，被复制入的指针vp1，复制的字节数n</li><li>作用：<strong>从vp2的地址起向后取n个字节的数据，复制进入vp1中</strong></li><li>返回值：指向被复制入的指针vp1</li><li>例子：</li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello, WORLD"</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span><span class="token operator">*</span> str2 <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span><span class="token operator">*</span> d <span class="token operator">=</span> <span class="token function">memcpy</span><span class="token punctuation">(</span>str1<span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">,</span> str2<span class="token punctuation">,</span> <span class="token number">6</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"str1 = %s\n"</span><span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"d = %s\n"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/69/73/qsI8M3iR_o.png" alt="p78"></p> 
<p>  不要感到奇怪，我们传入的<strong>vp1为str1+6</strong>，即’W’字符的地址，调用类似的以无类型指针为参数的函数<strong>可以不需要进行显式类型转换</strong>，这里的作用就是把str1中的WORLD替换成了world，你也可以自己尝试一下。</p> 
<p>  这里要提一下我之前所说的 <strong>"泛型版"swap函数</strong>，对于不存在void类型变量这件事情，我们可以用memcpy来替代：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>vp1<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>vp2<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>  
    <span class="token keyword">void</span><span class="token operator">*</span> buffer <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span>vp1<span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">memcpy</span><span class="token punctuation">(</span>vp1<span class="token punctuation">,</span>vp2<span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">memcpy</span><span class="token punctuation">(</span>vp2<span class="token punctuation">,</span>buffer<span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %d, b = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/70/7a/ma5LFJ2H_o.png" alt="p79"></p> 
<p>  没错，这样就实现了一个真正的泛型版swap函数，只要我们每次都在调用的时候传入对应的字节数就可以了。</p> 
<h5><a id="6memset_862"></a>#6.memset()</h5> 
<ul><li>函数原型：void* memset(void* vp, int c, size_t n);</li><li>参数：被赋值的指针vp，需要赋的值c，字节数n</li><li>作用：<strong>将从vp的地址起的后面n个字节均赋值为c</strong></li><li>返回值：被赋值的指针vp</li><li>例子：</li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token operator">*</span> array <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Before memset: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"After memset: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f2/33/REMJJ8fx_o.png" alt="p80"></p> 
<p>  你看，只要一条memset()我们就可以把数组的每一个元素初始化为0，当然初始化为其他值也是可以的。memset()也可以对字符串赋值，这个就留给你自己去尝试了。</p> 
<ul><li>其实string.h还有更多函数，如果你想了解他们，可以参考一下<a href="https://www.runoob.com/cprogramming/c-standard-library-string-h.html" rel="nofollow">菜鸟教程：&lt;string.h&gt;</a></li></ul> 
<h4><a id="11_int_argcchar_argv_897"></a>(11). 现在我们就可以说说int argc和char* argv[]是什么东西了</h4> 
<p>  我们之前提过老朋友main()函数中实际上有两个参数，它的原型如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>  main函数是C语言的入口函数，char* argv[]是一个字符串数组，int argc是这个数组中包含的元素数量，假设我们在调用的时候给它加点参数，可能会有神奇的效果：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d : %s\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  这一次的编译运行我们放到Linux下完成：<br> <img src="https://images2.imgbox.com/9c/42/b7McacaZ_o.png" alt="p81"></p> 
<p>  当我们直接执行这个程序的时候，它打印的结果是0 : ./argv.out，也就是说<strong>argv[0]是执行程序的命令</strong>，那如果我们在<strong>运行的时候多加一点东西</strong>会怎么样呢？<br> <img src="https://images2.imgbox.com/2b/88/1fPYZKkW_o.png" alt="p82"></p> 
<p>  没错，我们可以执行的同时向C语言程序<strong>附加很多不同的指令/参数</strong>，这些东西也会被加入argv数组中，<strong>作为参数传进main函数</strong>，这样一来我们就可以做很多事情了，比如<strong>设置一个debug模式：只需要在启动程序的时候后面加一条Debug参数</strong>就可以了，还有很多诸如此类的用法。</p> 
<h4><a id="12__921"></a>(12). 自由的指针和不自由的程序员</h4> 
<p>  你可以在你的程序中任意指定某个指针指向任意一个地址，当然能不能成功就看你的运气了，因为有的时候可能你<strong>输入的地址超出范围、进入了不该进入的地方</strong>等等，这些时候程序会直接崩溃，然后可能return一个相当大的值告诉你运行异常。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token number">0x1</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/1e/79/KlsCsZtv_o.png" alt="p83"></p> 
<p>  你也可以试试，这说明我们没有办法读写0x1(0x表示16进制数字)这个位置上的值，从0x0起的一部分内存区域用于<strong>存储操作系统等等的一些重要信息</strong>，对于程序来说，这一部分内容是<strong>不可读写</strong>的，否则可能导致操作系统的崩溃。<br>   当然，指针还是自由的，因为你仍然可以给p赋值为0x1，只是在<strong>读写的时候会出问题</strong>罢了，指针给C语言程序员带来了非常非常多的方便之处，我之前说的<strong>swap函数</strong>就是其中之一，不过与此同时，指针也带来了很多<strong>安全隐患</strong>，除了前面所说的<strong>尝试修改不可读写的部分</strong>，还有：</p> 
<ul><li><strong>越界访问：数组的越界访问、部分不对空间进行检查或者限制的函数如strcpy和strcat等</strong></li><li><strong>内存泄露：使用malloc或calloc分配的内存在结束前没有释放</strong></li></ul> 
<p>  所以虽然指针很自由，但是我们这些程序是不自由的，在用指针的时候一定要处处当心，毕竟你也不想写个小程序结果把电脑给玩崩了是吧？之后用指针的时候，一定要<strong>小心谨慎</strong>！</p> 
<h4><a id="13_CE_941"></a>(13). 关于“地址”的思考——我们能不能做个游戏修改器(CE)？</h4> 
<p>  到这里，你肯定已经对指针有了深入的理解，就算不深入，也肯定收获了很多，我当初学指针的时候，就对 <strong>“地址”</strong> 这个事情产生了非常强烈的兴趣，为什么这么说呢？之前玩很多单机游戏的时候，有一个叫做Cheat Engine(后称CE)的游戏修改器，它的具体用法是这样的：</p> 
<ul><li>首先确定游戏中的某个数值，例如我要修改植物大战僵尸一局游戏中的阳光数，一开始初始值是25，我先在CE中搜索25，它会出现一大堆候选位置。</li><li>搜索完之后，在游戏中再次修改阳光数量，比如向日葵产生了25阳光收集一下，现在就是50了，然后再在CE搜索一下50，这时候候选区的数量就会明显减少，之后再重复<strong>改变和搜索</strong>的过程</li><li>直到只有一个候选或只有两个候选，这时候对这个地址直接进行修改就行了，然后你就会发现阳光数变成了你想要的数字</li></ul> 
<p>  我在这段描述中提到了关键词：<strong>“地址”</strong>，所以CE其实是<strong>对特定的地址写入值</strong>，从而达到<strong>修改游戏内变量</strong>的效果，我们是不是刚才学过指针和地址来着，那我们来试试看吧！</p> 
<pre><code class="prism language-c"><span class="token comment">// 这是第一个程序，是需要被修改的值</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;a = %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保在修改过程中程序是暂停的</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 这是第二个程序，用来修改指定地址的值</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%p"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>p <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/0c/d5/1WKMdSs9_o.png" alt="p84"></p> 
<p>  这次我把两个窗口一起截进来了，<strong>第一个窗口是修改值用的，第二个则是被修改用的</strong>，结果是有点<strong>令人失望</strong>的，我们把地址输入第一个窗口再输入一个值，<strong>它就返回了3221225477，再看原来的窗口，a的值也没有发生改变</strong>，这说明我们的尝试失败了！<br>   <strong>如果你真的有想到这一层并且也付诸了实践，那我相信你肯定对于计算机具有相当的兴趣，能够有这样的探索精神对于学习计算机时非常有利的！</strong><br>   不过，到底为什么会这样呢？这就要回到 <strong>“地址”<strong>这个词本身了，在一个程序中使用&amp;取地址，得到的这个</strong>地址并不是直接对应到物理内存上的</strong>，以Windows进程来说，每个进程都可以分配到自己的一个线性地址空间(0x0000…000 ~ 0xFFFF…FFFF)，但这个地址<strong>没有反映其在物理内存上的真实地址</strong>，因此这么一来，我们在不同的进程中甚至可能得到相同的地址，毕竟这个<strong>地址并不对应真实地址</strong>，由此，我们仅仅通过进程A输出地址，再在进程B中修改地址的值是<strong>不可能这么简单的完成的</strong>。<br>   这件事当然也是可以完成的，在Windows中我们可以通过Win32API的内置函数来获取真实地址然后进行修改，当然更深入的内容我也不太懂了哈哈。<br>   具体也可以看看这一篇专业回答：<a href="https://www.zhihu.com/question/379177766/answer/1082583597" rel="nofollow">C语言中&amp;取地址取到的地址是真实内存的地址吗？</a></p> 
<p>  虽然这个试验失败了，但是我们从中可以说是学到了不少东西呢！</p> 
<h4><a id="14__983"></a>(14). 关于函数指针</h4> 
<p>  鉴于这是一个基础教程，我不会在这里讲函数指针的相关内容，后续可能会有单独的文章来补充这一节。</p> 
<h4><a id="_986"></a>小结</h4> 
<p>  指针这一章可真是“鸿篇巨制”，我们从各个方面介绍了指针，从含义解释到应用，这么一大章的内容肯定是要<strong>花不少时间消化</strong>的，你可以多看几遍，然后<strong>对着代码敲敲、运行一下</strong>。<strong>如果你从头看到了这里，你就已经可以算是C语言入门了</strong>，我的教程中并<strong>没有掺杂太多的题目</strong>，我希望你能够在学习了这些知识之后自己去尝试，思考一下我们学习的这些东西<strong>到底有什么用</strong>，例如这次13节中的自己写一个CE就是很好的尝试，虽然结果可能和想象有出入，但这个过程中你一定能学到很多很多的知识，这是刷题不能带给你的，计算机的学习也是这样，作为一门应用型的工科，你更应该多在实践中完成学习，毕竟运行结果不会骗你，该是怎么样，跑跑就知道了。<br>   教程写到这里就已经过了大半了，之后的几章会分别介绍<strong>优化用户交互的格式化输入与输出</strong>，<strong>把数据打包的结构体和联合</strong>，<strong>把数据长期保存的文件</strong>以及<strong>奇妙的位运算</strong>，真心希望这篇教程能够帮助到你！</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3a44b9b32ba573dfd9cf824acd266357/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java绘图库JFreeChart的详细使用教程(入门级)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/65910c85628ae4b01700e84633d9dfa8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">阿里云验证SSL证书</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>