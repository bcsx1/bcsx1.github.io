<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>利用MATLAB构建特殊通用矩阵 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="利用MATLAB构建特殊通用矩阵" />
<meta property="og:description" content="在MATLAB编程中，经常需要遇到一些特殊的通用矩阵，本篇主要介绍的是MATLAB中可能会用到特殊矩阵。
1、零矩阵 MATLAB使用zeros函数来创建零矩阵，所谓零矩阵就是矩阵中所有元素皆为0的矩阵。zeros函数的调用方式如下所示：
（1）zeros(n)：n为常数，生成一个n×n的矩阵。
例如，生成一个4×4的零矩阵的代码为：
a=zeros(4) 运行结果如下所示：
a = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 当n的值省略的时候，那么生成一个1×1的向量，结果如下所示：
ans = 0 （2）zeros(m,n)：m，n均为常数，生成一个m×n的零矩阵。生成一个m×n的零矩阵也可以写成zeros([m,n])的方式。
例如生成一个3×4的零矩阵的代码如下：
a=zeros(3,4) 运行结果如下所示：
a = 0 0 0 0 0 0 0 0 0 0 0 0 （3）zeros(size(A))：A为矩阵，zeros生成一个与矩阵A相同行和列的零矩阵。
例如：
A=[3,4,5;2,7,8]; a=zeros(size(A)) 运行结果如下所示：
a = 0 0 0 0 0 0 （4）zeros(m,n,&#39;like&#39;,p)：p为矩阵，生成一个与p类型相同，大小为m行n列的零矩阵。
例如：
p=[2&#43;1i,3;4,2&#43;3i]; zeros(3,2,&#39;like&#39;,p) 在上述代码段中的p矩阵为一个复数矩阵，那么matlab中所求的结果应为一个3行2列的复数矩阵。运行结果如下所示：
ans = 0.0000 &#43; 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/5cec545c25fb9ef615a40e54458c5c18/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-29T08:42:19+08:00" />
<meta property="article:modified_time" content="2023-12-29T08:42:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">利用MATLAB构建特殊通用矩阵</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在MATLAB编程中，经常需要遇到一些特殊的通用矩阵，本篇主要介绍的是MATLAB中可能会用到特殊矩阵。</p> 
<h4>1、零矩阵</h4> 
<p>MATLAB使用zeros函数来创建零矩阵，所谓零矩阵就是矩阵中所有元素皆为0的矩阵。zeros函数的调用方式如下所示：</p> 
<p>（1）zeros(n)：n为常数，生成一个n×n的矩阵。</p> 
<p>例如，生成一个4×4的零矩阵的代码为：</p> 
<div> 
 <pre><code class="language-Matlab">a=zeros(4)</code></pre> 
</div> 
<p>运行结果如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a =
     0     0     0     0
     0     0     0     0
     0     0     0     0
     0     0     0     0</code></pre> 
</div> 
<p>当n的值省略的时候，那么生成一个1×1的向量，结果如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">ans =

     0</code></pre> 
</div> 
<p>（2）zeros(m,n)：m，n均为常数，生成一个m×n的零矩阵。生成一个m×n的零矩阵也可以写成zeros([m,n])的方式。</p> 
<p>例如生成一个3×4的零矩阵的代码如下：</p> 
<div> 
 <pre><code class="language-Matlab">a=zeros(3,4)</code></pre> 
</div> 
<p>运行结果如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a =
     0     0     0     0
     0     0     0     0
     0     0     0     0</code></pre> 
</div> 
<p>（3）zeros(size(A))：A为矩阵，zeros生成一个与矩阵A相同行和列的零矩阵。</p> 
<p>例如：</p> 
<div> 
 <pre><code class="language-Matlab">A=[3,4,5;2,7,8];
a=zeros(size(A))</code></pre> 
</div> 
<p>运行结果如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a =
     0     0     0
     0     0     0</code></pre> 
</div> 
<p>（4）zeros(m,n,'like',p)：p为矩阵，生成一个与p类型相同，大小为m行n列的零矩阵。</p> 
<p>例如：</p> 
<div> 
 <pre><code class="language-Matlab">p=[2+1i,3;4,2+3i];
zeros(3,2,'like',p)</code></pre> 
</div> 
<p>在上述代码段中的p矩阵为一个复数矩阵，那么matlab中所求的结果应为一个3行2列的复数矩阵。运行结果如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">ans =
   0.0000 + 0.0000i   0.0000 + 0.0000i
   0.0000 + 0.0000i   0.0000 + 0.0000i
   0.0000 + 0.0000i   0.0000 + 0.0000i
</code></pre> 
</div> 
<p>（5）zeros(m,n,typename)：生成一个m行n列的矩阵，其中矩阵的中所有元素的类型通过typename指定的。</p> 
<p>例如，生成一个3行4列的int类型的矩阵代码如下所示：</p> 
<div> 
 <pre><code>a=zeros(3,4,'int16')</code></pre> 
</div> 
<p>运行结果如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a =

  3×4 int16 矩阵

   0   0   0   0
   0   0   0   0
   0   0   0   0</code></pre> 
</div> 
<p>在例如，生成一个3行4列的logical类型的矩阵代码如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a=zeros(4,4,'logical')</code></pre> 
</div> 
<p>运行结果如下如所示：</p> 
<div> 
 <pre><code class="language-Matlab">a =

  4×4 logical 数组

   0   0   0   0
   0   0   0   0
   0   0   0   0
   0   0   0   0</code></pre> 
</div> 
<p>在typename中可以选择的值包括：'double'、'single'、‘logical’、‘int8‘、’int16‘、'int32'、’uint8‘、'uint16'、’uint32‘或者是zeros函数支持的其他类的名称。</p> 
<p>（5）flase函数</p> 
<p>在MATLAB中，false函数用于生成全为0的逻辑矩阵。</p> 
<p>例如，生成一个3行4类的全0逻辑矩阵，代码如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a=false(3,4)</code></pre> 
</div> 
<p>运行结果如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a =

  3×4 logical 数组

   0   0   0   0
   0   0   0   0
   0   0   0   0</code></pre> 
</div> 
<p>需要注意的是，false(3,4)和zeros(3,4,'logical')所达成的效果是相同的。</p> 
<h4>2、幺矩阵</h4> 
<p>在线性代数中，矩阵中的所有元素的值全为1的矩阵的称为幺矩阵，在MATLAB中初始化幺矩阵通常使用ones函数，其中ones函数所使用的调用格式与zeros函数类似。</p> 
<p>（1）例如，建立一个4行6列的ones函数的代码如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a=ones(4,6)</code></pre> 
</div> 
<p>运行结果如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a =

     1     1     1     1     1     1
     1     1     1     1     1     1
     1     1     1     1     1     1
     1     1     1     1     1     1
</code></pre> 
</div> 
<p>通过与zeros函数进行类比，可以对于ones函数使用相同的操作。</p> 
<p>（2）true函数</p> 
<p>在MATLAB中，true函数用于生成全为1的逻辑矩阵。</p> 
<p>例如，生成一个3行4类的全1逻辑矩阵，代码如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a=true(3,4)</code></pre> 
</div> 
<p>运行结果如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a =

  3×4 logical 数组

   1   1   1   1
   1   1   1   1
   1   1   1   1</code></pre> 
</div> 
<p>需要注意的是，true(3,4)和ones(3,4,'logical')所达成的效果是相同的。</p> 
<h4>3、eye函数</h4> 
<p>在MATLAB中，eye函数可以初始化单位矩阵，即对角线上元素均为1其余元素均为0的方阵。</p> 
<p>例如初始化一个3行3列的单位矩阵代码如下：<br>  </p> 
<div> 
 <pre><code class="language-Matlab">a=eye(3,3)</code></pre> 
</div> 
<p>运行结果如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a =
     1     0     0
     0     1     0
     0     0     1</code></pre> 
</div> 
<p>需要注意的是，eye函数不仅可以初始化单位矩阵，同时可以初始化行和列不相同的矩阵，其中主对角线的元素全为1，其余元素均为0。例如：</p> 
<div> 
 <pre><code class="language-Matlab">a=eye(3,4)
b=eye(4,3)</code></pre> 
</div> 
<p>运行结果如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a =
     1     0     0     0
     0     1     0     0
     0     0     1     0
b =
     1     0     0
     0     1     0
     0     0     1
     0     0     0</code></pre> 
</div> 
<h4>4、随机矩阵</h4> 
<p>在MATLAB中，有多个函数用于生成随机矩阵，包括rand函数、randi函数、randn函数和randperm函数:</p> 
<p>（1）rand(m,n)：生成一个m行n列的矩阵，矩阵中所有元素的值均在0-1之间。</p> 
<p>例如初始化一个3行4列的随机矩阵，代码如下：</p> 
<div> 
 <pre><code class="language-Matlab">a=rand(3,4)</code></pre> 
</div> 
<p>运行结果如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a =
    0.8147    0.9134    0.2785    0.9649
    0.9058    0.6324    0.5469    0.1576
    0.1270    0.0975    0.9575    0.9706</code></pre> 
</div> 
<p>（2）randi(imax,m,n)：生成一个m行n列的矩阵，其中矩阵的所有元素为[1,imax]均匀分布的随机矩阵。</p> 
<p>例如初始化一个4行5列，元素从[1,6]之间的矩阵，代码如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a=randi(6,4,5)</code></pre> 
</div> 
<p>运行结果如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a =
     6     3     4     5     4
     3     6     1     5     2
     5     5     6     5     5
     1     6     6     3     1</code></pre> 
</div> 
<p>（3）randn(m,n)：生成一组3行4列的矩阵，其中矩阵中的所有元素为平均值为0、方差为1的标准正太分布随机数。</p> 
<p>例如，初始化一个均值为0、方差为1的4行5列的矩阵，代码如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a=randn(4,5)</code></pre> 
</div> 
<p>运行结果如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a =
    0.6007    1.5326    1.1174    1.1006   -0.7423
   -1.2141   -0.7697   -1.0891    1.5442   -1.0616
   -1.1135    0.3714    0.0326    0.0859    2.3505
   -0.0068   -0.2256    0.5525   -1.4916   -0.6156
</code></pre> 
</div> 
<p>（4）randperm(n,k)：将[1,n]的整数随机排列，生成一个指定长度为k的向量：</p> 
<p>例如初始化一个长度为6，将[1,6]之间的整数随机排列的向量：</p> 
<div> 
 <pre><code class="language-Matlab">a=randperm(6,6)</code></pre> 
</div> 
<p>运行结果如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a =
     2     1     5     3     4     6</code></pre> 
</div> 
<p>需要注意的是randperm(n,k)中，但k的小于n时（k必须小于等于n），运行结果是随机选取k个[1,n]的整数进行随机排列的向量。</p> 
<p>例如，初始化一个长度为4，将区间[1,6]的整数随机排列的向量，代码如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a=randperm(6,4)</code></pre> 
</div> 
<p>运行结果如下所示：</p> 
<div> 
 <pre><code class="language-Matlab">a =

     3     6     4     1
</code></pre> 
</div> 
<h4>5、魔方矩阵</h4> 
<p>魔方矩阵又称幻方、九宫格、纵横线，是有相同的行数和列数，并在每行每列、对角线上的和都相等的矩阵，其中矩阵的每一行以及每一列的和均为<img alt="\frac{n(n^2+1)}{2}" class="mathcode" src="https://images2.imgbox.com/bc/2b/ZVSOkdYL_o.png">。魔方矩阵中的每个元素不能相同。（本段定义参考百度百科<a class="link-info" href="https://baike.baidu.com/item/%E9%AD%94%E6%96%B9%E7%9F%A9%E9%98%B5" rel="nofollow" title="魔方矩阵">魔方矩阵</a>）</p> 
<p>在MATLAB中，提供magic函数来生成一个魔方矩阵，调用格式如下所示：</p> 
<p>magic(n)：生成n阶的魔方矩阵。</p> 
<p>例如生成一个4阶的魔方矩阵，代码如下所示：</p> 
<pre><code class="language-Matlab">a=magic(4)</code></pre> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">a =
    16     2     3    13
     5    11    10     8
     9     7     6    12
     4    14    15     1</code></pre> 
<h4>6、范德蒙德矩阵</h4> 
<p>使用MATLAB所生成的范德蒙德矩阵中，最后一列的元素全为1，倒数第二列的元素为用户指定的向量，而其余列是其后一列向量与倒数第二列向量的点乘积。在MATLAB中，使用vander函初始化一个范德蒙德矩阵。</p> 
<p>例如，初始一个倒数第二行元素从上到下依次是1、3、4、7、8的5阶矩阵，代码如下：</p> 
<pre><code class="language-Matlab">a=vander([1,3,4,7,8])</code></pre> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">a =
           1           1           1           1           1
          81          27           9           3           1
         256          64          16           4           1
        2401         343          49           7           1
        4096         512          64           8           1</code></pre> 
<h4>7、帕斯卡矩阵</h4> 
<p>帕斯卡矩阵是由<img alt="(x+y)^n" class="mathcode" src="https://images2.imgbox.com/9b/77/hTHT4vNo_o.png">展开之后系数随n的增大组成的三角形表，又称为杨辉三角表。其矩阵的第1行和第1列的元素均为1，其余第i行第j列的元素<img alt="a_{ij}=a_{i,j-1}+a_{i-1,j}" class="mathcode" src="https://images2.imgbox.com/b2/bc/GjdGRstR_o.png">。在MATLAB中使用pascal函数生成一个n阶帕斯卡矩阵。</p> 
<p>例如，生成一个5阶帕斯卡矩阵，代码如下：</p> 
<pre><code class="language-Matlab">a=pascal(5)
</code></pre> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">a =
     1     1     1     1     1
     1     2     3     4     5
     1     3     6    10    15
     1     4    10    20    35
     1     5    15    35    70</code></pre> 
<p>同时帕斯卡矩阵可以计算<img alt="(x+y)^n" class="mathcode" src="https://images2.imgbox.com/af/6c/iYcpTzQY_o.png">的展开式中各项的系数，第1至第n项的系数为从<img alt="a_{n1}" class="mathcode" src="https://images2.imgbox.com/c8/c5/R0Fx7SmK_o.png">、<img alt="a_{n-1,2}" class="mathcode" src="https://images2.imgbox.com/6b/71/vhEVLIoV_o.png">...<img alt="a_{1n}" class="mathcode" src="https://images2.imgbox.com/16/6f/uClpRsbm_o.png">例如计算<img alt="(x+y)^4" class="mathcode" src="https://images2.imgbox.com/b0/5a/Z0YZwRSZ_o.png">的展开式的系数：</p> 
<pre><code class="language-Matlab">a=pascal(4)</code></pre> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">a =
     1     1     1     1
     1     2     3     4
     1     3     6    10
     1     4    10    20
</code></pre> 
<p>则<img alt="(x+y)_4" class="mathcode" src="https://images2.imgbox.com/45/84/IpExvteH_o.png">的各项系数为顺着副对角线从左下角至右上角（或从右上角值左下角）各个元素的值，即：<img alt="(x+y)^4=x^{3}+3x^{2}y+3xy^{2}+y^{3}" class="mathcode" src="https://images2.imgbox.com/48/c7/cVWR4biP_o.png"></p> 
<h4>8、托普利兹矩阵</h4> 
<p>托普利兹矩阵是矩阵第一行和第一列的元素，其他元素都是和左上角的元素相同。在MATLAB中，toeplitz(v1,v2)：v1和v2分别表示托普利兹矩阵的第一列的列向量和第一行的行向量。其中v1向量和v2向量的首元素必须相同。</p> 
<p>例如初始化化一个托普利兹矩阵：</p> 
<pre><code class="language-Matlab"> a=toeplitz([4,3,2,6],[4,6,9,10,12])</code></pre> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">a =
     4     6     9    10    12
     3     4     6     9    10
     2     3     4     6     9
     6     2     3     4     6</code></pre> 
<h4>9、希尔伯特矩阵</h4> 
<p>希尔伯特矩阵是一个数学变化矩阵，每个元素的值<img alt="a_{ij}=\frac{1}{i+j-1}" class="mathcode" src="https://images2.imgbox.com/a7/23/x8u4OzYj_o.png">，希尔伯特矩阵是个高度病态的矩阵（即任何一个元素发生变化，整个矩阵的行列式和逆矩阵都会发生巨大变化），MATLAB提供了hilb函数生成希尔伯特矩阵。其中hilb函数有两种调用格式：</p> 
<p>hilb(n)：n为常数，返回一个n阶的希尔伯特矩阵。</p> 
<p>hilb(n,classname)：n为常数，表示的是希尔伯特矩阵的阶数，classname表示矩阵的类，classname的矩阵的类，可以取值为‘double’和‘single’，其中默认值为‘double’。</p> 
<p>例如初始化一个4阶希尔伯特矩阵：</p> 
<pre><code class="language-Matlab">a=hilb(4)</code></pre> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">a =
    1.0000    0.5000    0.3333    0.2500
    0.5000    0.3333    0.2500    0.2000
    0.3333    0.2500    0.2000    0.1667
    0.2500    0.2000    0.1667    0.1429</code></pre> 
<p>在例如初始化一个single类的5阶矩阵。</p> 
<pre><code class="language-Matlab">a=hilb(5,'single')
</code></pre> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">a =

  5×5 single 矩阵

    1.0000    0.5000    0.3333    0.2500    0.2000
    0.5000    0.3333    0.2500    0.2000    0.1667
    0.3333    0.2500    0.2000    0.1667    0.1429
    0.2500    0.2000    0.1667    0.1429    0.1250
    0.2000    0.1667    0.1429    0.1250    0.1111
</code></pre> 
<p>MATLAB中有专门求希尔伯特矩阵的逆矩阵的函数invhilb函数，当n小于15时，invhilb(n)生成希尔伯特矩阵的精确的逆矩阵，当n大于15时，invhilb(n)生成的是Hilbert矩阵的近似矩阵。</p> 
<h4>10、伴随矩阵</h4> 
<p>MATLAB对于一个多项式<img alt="p(x)=a_{n}x^{n}+a_{n-1}x^{n-1}+...+a_{1}x+a_{0}" class="mathcode" src="https://images2.imgbox.com/1a/fe/oUv9rUR1_o.png">的伴随矩阵为：</p> 
<p><img alt="A=\begin{bmatrix} - \frac{a_{n-1}}{a_n}&amp; -\frac{a_{n-2}}{a_{n}} &amp; -\frac{a_{n-3}}{a_n} &amp; ... &amp; -\frac{a_{1}}{a_{n}} &amp; -\frac{a_{0}}{a_{n}}\\ 1 &amp; 0 &amp; 0 &amp; ... &amp; 0 &amp; 0\\ 0&amp; 1 &amp; 0 &amp; ... &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1&amp; ... &amp; 0 &amp; 0\\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp;\vdots \\ 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1 &amp; 0 \end{bmatrix}" class="mathcode" src="https://images2.imgbox.com/06/e6/8Aolfmzp_o.png"></p> 
<p>方程p(x)的根称为A的特征值。</p> 
<p>MATLAB生成使用compan函数生成伴随矩阵，例如求<img alt="4x^{4}+5x^{3}+12x^{2}+4x+6" class="mathcode" src="https://images2.imgbox.com/9b/e0/BY1i7B2o_o.png">的伴随矩阵，代码如下：</p> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">a=compan([4,5,12,4,6])</code></pre> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">a =

   -1.2500   -3.0000   -1.0000   -1.5000
    1.0000         0         0         0
         0    1.0000         0         0
         0         0    1.0000         0</code></pre> 
<h4>11、级联矩阵</h4> 
<p>MATLAB将用指定方向进行合并两个或者多个矩阵，函数调用如下如下：</p> 
<p>（1）cat(dim,A1,A2,A3,A4,...An)：在指定维度合并矩阵，cat(1,A,B)等同于cat(1,A,B)等同于[A;B]，而cat(2,A,B)等同于[A,B]。</p> 
<p>例如将三个矩阵的纵向合并矩阵：</p> 
<pre><code class="language-Matlab">A=[1,2,3;4,3,5];
B=[1,2,1;5,4,1];
C=[0,1,6;7,3,1];
D=cat(1,A,B,C)
E=cat(2,A,B,C)</code></pre> 
<p>运行结果如下：</p> 
<pre><code class="language-Matlab">D =
     1     2     3
     4     3     5
     1     2     1
     5     4     1
     0     1     6
     7     3     1

E =
     1     2     3     1     2     1     0     1     6
     4     3     5     5     4     1     7     3     1</code></pre> 
<p>（2）horzcat(A1,A2,...An)：横向合并矩阵，horzcat(A,B)等同于[A,B]。</p> 
<p>例如：</p> 
<pre><code class="language-Matlab">A=[1,3;4,6;3,1];
B=[3,2;1,4;5,1];
A=horzcat(A,B)</code></pre> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">A =
     1     3     3     2
     4     6     1     4
     3     1     5     1</code></pre> 
<p>（3）horzcat(A1,A2,...An)：纵向合并矩阵，horzcat(A,B)等同于[A;B]。</p> 
<p>例如：</p> 
<pre><code class="language-Matlab">A=[1,3,4;6,3,1];
B=[3,2,1;4,5,1];
A=vertcat(A,B)</code></pre> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">A =
     1     3     4
     6     3     1
     3     2     1
     4     5     1</code></pre> 
<p>（4）repmat(A,m,n)：复制矩阵A来构造一个新的矩阵，其中纵向复制m个A，横向复制有n个A。</p> 
<p>例如：</p> 
<pre><code class="language-Matlab">A=[1,4;5,8]
A=repmat(A,2,3)</code></pre> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">A =
     1     4     1     4     1     4
     5     8     5     8     5     8
     1     4     1     4     1     4
     5     8     5     8     5     8</code></pre> 
<h4>12、累计矩阵</h4> 
<p>在MATLAB中，使用accumarray对于指定的向量进行累计，然后用计算的结果构造一个新的矩阵。accumarray有如下几种调用格式：</p> 
<p>（1）accumarray(subs,val)：subs是下标矩阵或者是向量，而val是数据，val可以是一个标量或者是一个向量。</p> 
<p>当subs是一个向量时：</p> 
<pre><code class="language-Matlab">val=1;
subs=[1;2;5;2;4];
a=accumarray(subs,val)</code></pre> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">a =
     1
     2
     0
     1
     1</code></pre> 
<p>由上图中的运行显示，返回的是一个计数向量，表示的subs向量中下标出现次数与val的积。如果将val的值改为2：</p> 
<pre><code class="language-Matlab">val=2;
subs=[1;2;5;2;4];
a=accumarray(subs,val)</code></pre> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">a =
     2
     4
     0
     2
     2</code></pre> 
<p>对比两次运行结果可以看到，当val变化增加一倍时，返回的结果也同样增加一倍。</p> 
<p>当val是一个向量时：</p> 
<pre><code class="language-Matlab">val=10:10:50;
subs=[1;2;5;3;4];
a=accumarray(subs,val)</code></pre> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">a =
    10
    20
    40
    50
    30</code></pre> 
<p>当subs是一个二维矩阵的时候，subs矩阵中的每行是val中对应元素的位置。</p> 
<p>例如：</p> 
<pre><code class="language-Matlab">val = 10:10:50;
subs=[1,3;3,1;2,2;3,2;2,1];
a=accumarray(subs,val)</code></pre> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">a =

     0     0    10
    50    30     0
    20    40     0</code></pre> 
<p>当subs中如果两行元素相同的时候，那么对应的val就会累计起来。例如：</p> 
<pre><code class="language-Matlab">val = 10:10:50;
subs=[1,3;3,1;2,2;3,2;3,1];
a=accumarray(subs,val)</code></pre> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">a =

     0     0    10
     0    30     0
    70    40     0</code></pre> 
<p>（2）accumarray(subs,val,sz)：subs和val同（1）相同，而sz表示的是输出数组的大小。其中，ALL(MAX(subs)&lt;=sz)，例如：</p> 
<pre><code class="language-Matlab">val=10:10:50;
subs=[1;2;5;3;4];
sz=[6 1]
a=accumarray(subs,val,sz)</code></pre> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">a =
    10
    20
    40
    50
    30
     0</code></pre> 
<p>由运行结果可以看出，返回的结果为6行1列的矩阵，其中大于原来行数的内容会用0来补充。</p> 
<p>（3）accumarray(subs,val,sz,fun)：subs和val同（1）相同，sz表示的输出数组的大小，其中，其中ALL(MAX(subs)&lt;=sz)，fun表示的是函数，默认情况下为[]，例如;</p> 
<pre><code class="language-Matlab">val = 1:5;
subs = [1,1;2,1;2,2;1,2;2,1];
a = accumarray(subs,val,[],@(x) {x})</code></pre> 
<p>运行结果如下所示：</p> 
<pre><code class="language-Matlab">a =

  2×2 cell 数组

    {[       1]}    {[4]}
    {2×1 double}    {[3]</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/af60020ee1b32561f5a83363a609ce6e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">单机游戏数据自动保存方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/797f540f0efd2fc694fa7edd8460e7d6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">archiver error. Connect internal only, until freed.</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>