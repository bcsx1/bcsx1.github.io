<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>iOS VIPER架构实践(二)：VIPER详解与实现 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="iOS VIPER架构实践(二)：VIPER详解与实现" />
<meta property="og:description" content="第一篇文章对VIPER进行了简单的介绍，这篇文章将从VIPER的源头开始，比较现有的几种VIPER实现，对VIPER进行进一步的职责剖析，并对各种细节实现问题进行挖掘和探讨。最后给出两个完整的VIPER实现，并且提供快速生成VIPER代码的模板。
Demo和轮子的github地址是：ZIKViper，路由工具：ZIKRouter。有用请点个star~ 注意，Demo需要先用pod install安装一下依赖库。
两个实现展示了以下问题的解决方案：
如何彻底地解决不同模块之间的耦合如何在一个模块里引入子模块子模块和父模块之间如何通信如何对模块进行依赖注入面向接口的路由工具 目录 起源Clean Architecture Enterprise Business RulesApplication Business RulesInterface AdaptersFrameworks &amp; Drivers总结现有的各种VIPER实现 Brigade团队的实现 争议Rambler&amp;Co团队的实现 争议Uber团队的实现 各部分职责数据驱动争议其他设计方案一：最完整的VIPER ViewPresenterInteractorServiceWireframeRouterAdapterBuilder模块间解耦子模块 子模块的来源通信方式依赖注入映射到MVC方案二：允许适当耦合 ViewPresenterInteractor路由和依赖注入总结Demo和代码模板参考 起源 VIPER架构，最初是2013年在MutualMobile的技术博客上，由Jeff Gilbert 和 Conrad Stoll 提出的。他们的博客网站有过一次迁移，原文地址已经失效，这是迁移后的博文：MEET VIPER: MUTUAL MOBILE’S APPLICATION OF CLEAN ARCHITECTURE FOR IOS APPS。
这是文章中提出的架构示意图：
Wireframe可以看作是Router的另一种表达。可以看到，VIPER之间的关系已经很明确了。之后，作者在2014年在objc.io上发表了另一篇更详细的介绍文章：Architecting iOS Apps with VIPER。
在作者的第一篇文章里，阐述了VIPER是在接触到了Uncle Bob的Clean Architecture后，对Clean Architecture的一次实践。因此，VIPER真正的源头应该是Clean Architecture。
Clean Architecture 由Uncle Bob在2011年提出的Clean Architecture，是一个平台无关的抽象架构。想要详细学习的，可以阅读作者的原文：Clean Architecture，翻译：干净的架构The Clean Architecture。
它通过梳理软件中不同层之间的依赖关系，提出了一个自外向内，单向依赖的架构，如下图所示：
越靠近内层，越变得抽象，越接近设计的核心。越靠近外层，越和具体的平台和实现技术相关。内层的部分完全不知道外层的存在和实现方式，代码只能从外层向内层引用，目的是为了实现层与层之间的隔离。将不同抽象程度的层进行隔离，做到了把业务规则和具体实现分离开。你可以把外层看作是内层的delegate，外层只能通过内层提供的delegate接口来使用内层。
Enterprise Business Rules 代表了这个软件项目的业务规则。由数据实体体现，是一些可以在不同的程序应用之间共享的数据结构。
Application Business Rules 代表了本应用所使用的一些业务规则。封装和实现了用到的业务功能，会将各种实体的数据结构转为在用例中传递的实体类，但是和具体的数据库技术或者UI无关。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/f58a5e4679a1fb90548ce2840f4b432f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-08-21T02:25:41+08:00" />
<meta property="article:modified_time" content="2017-08-21T02:25:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">iOS VIPER架构实践(二)：VIPER详解与实现</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <p>第一篇文章对VIPER进行了简单的介绍，这篇文章将从VIPER的源头开始，比较现有的几种VIPER实现，对VIPER进行进一步的职责剖析，并对各种细节实现问题进行挖掘和探讨。最后给出两个完整的VIPER实现，并且提供快速生成VIPER代码的模板。</p> 
 <p>Demo和轮子的github地址是：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FZuikyo%2FZIKViper" rel="nofollow">ZIKViper</a>，路由工具：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FZuikyo%2FZIKRouter" rel="nofollow">ZIKRouter</a>。有用请点个star~ 注意，Demo需要先用pod install安装一下依赖库。</p> 
 <p>两个实现展示了以下问题的解决方案：</p> 
 <ul><li>如何彻底地解决不同模块之间的耦合</li><li>如何在一个模块里引入子模块</li><li>子模块和父模块之间如何通信</li><li>如何对模块进行依赖注入</li><li>面向接口的路由工具</li></ul> 
 <h3 class="heading">目录</h3> 
 <ul><li>起源</li><li>Clean Architecture 
   <ul><li>Enterprise Business Rules</li><li>Application Business Rules</li><li>Interface Adapters</li><li>Frameworks &amp; Drivers</li><li>总结</li></ul></li><li>现有的各种VIPER实现 
   <ul><li>Brigade团队的实现 
     <ul><li>争议</li></ul></li><li>Rambler&amp;Co团队的实现 
     <ul><li>争议</li></ul></li><li>Uber团队的实现 
     <ul><li>各部分职责</li><li>数据驱动</li><li>争议</li><li>其他设计</li></ul></li></ul></li><li>方案一：最完整的VIPER 
   <ul><li>View</li><li>Presenter</li><li>Interactor</li><li>Service</li><li>Wireframe</li><li>Router</li><li>Adapter</li><li>Builder</li></ul></li><li>模块间解耦</li><li>子模块 
   <ul><li>子模块的来源</li><li>通信方式</li></ul></li><li>依赖注入</li><li>映射到MVC</li><li>方案二：允许适当耦合 
   <ul><li>View</li><li>Presenter</li><li>Interactor</li><li>路由和依赖注入</li><li>总结</li></ul></li><li>Demo和代码模板</li><li>参考</li></ul> 
 <h3 class="heading">起源</h3> 
 <p>VIPER架构，最初是2013年在MutualMobile的技术博客上，由Jeff Gilbert 和 Conrad Stoll 提出的。他们的博客网站有过一次迁移，原文地址已经失效，这是迁移后的博文：<a href="https://link.juejin.im?target=https%3A%2F%2Fmutualmobile.com%2Fposts%2Fmeet-viper-fast-agile-non-lethal-ios-architecture-framework" rel="nofollow">MEET VIPER: MUTUAL MOBILE’S APPLICATION OF CLEAN ARCHITECTURE FOR IOS APPS</a>。</p> 
 <p>这是文章中提出的架构示意图：</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p>Wireframe可以看作是Router的另一种表达。可以看到，VIPER之间的关系已经很明确了。之后，作者在2014年在objc.io上发表了另一篇更详细的介绍文章：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.objc.io%2Fissues%2F13-architecture%2Fviper%2F" rel="nofollow">Architecting iOS Apps with VIPER</a>。</p> 
 <p>在作者的第一篇文章里，阐述了VIPER是在接触到了Uncle Bob的<a href="https://link.juejin.im?target=https%3A%2F%2F8thlight.com%2Fblog%2Funcle-bob%2F2012%2F08%2F13%2Fthe-clean-architecture.html" rel="nofollow">Clean Architecture</a>后，对Clean Architecture的一次实践。因此，VIPER真正的源头应该是Clean Architecture。</p> 
 <h3 class="heading"><a name="Clean-Architecture"></a>Clean Architecture</h3> 
 <p>由Uncle Bob在2011年提出的<code>Clean Architecture</code>，是一个平台无关的抽象架构。想要详细学习的，可以阅读作者的原文：<a href="https://link.juejin.im?target=https%3A%2F%2F8thlight.com%2Fblog%2Funcle-bob%2F2012%2F08%2F13%2Fthe-clean-architecture.html" rel="nofollow">Clean Architecture</a>，翻译：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.jdon.com%2Fartichect%2Fthe-clean-architecture.html" rel="nofollow">干净的架构The Clean Architecture</a>。</p> 
 <p>它通过梳理软件中不同层之间的依赖关系，提出了一个自外向内，单向依赖的架构，如下图所示：</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p>越靠近内层，越变得抽象，越接近设计的核心。越靠近外层，越和具体的平台和实现技术相关。内层的部分完全不知道外层的存在和实现方式，代码只能从外层向内层引用，目的是为了实现层与层之间的隔离。将不同抽象程度的层进行隔离，做到了把业务规则和具体实现分离开。你可以把外层看作是内层的delegate，外层只能通过内层提供的delegate接口来使用内层。</p> 
 <h4 class="heading"><a name="Clean-Architecture-Enterprise-Business-Rules"></a>Enterprise Business Rules</h4> 
 <p>代表了这个软件项目的业务规则。由数据实体体现，是一些可以在不同的程序应用之间共享的数据结构。</p> 
 <h4 class="heading"><a name="Clean-Architecture-Application-Business-Rules"></a>Application Business Rules</h4> 
 <p>代表了本应用所使用的一些业务规则。封装和实现了用到的业务功能，会将各种实体的数据结构转为在用例中传递的实体类，但是和具体的数据库技术或者UI无关。</p> 
 <h4 class="heading"><a name="Clean-Architecture-Interface-Adapters"></a>Interface Adapters</h4> 
 <p>接口适配层。将用例的规则和具体的实现技术进行抽象地对接，将用例中用到的实体类转为供数据库存储的格式或者供View展示的格式。类似于MVVM中把Model的数据传递给ViewModel供View显示。</p> 
 <p>右下角表示了接口适配层中不同模块间的通信方式。不同的模块在业务用例中产生关联和数据传递。Input、Output就是Use Case提供给外层的数据流动接口。</p> 
 <h4 class="heading"><a name="Clean-Architecture-Frameworks-Drivers"></a>Frameworks &amp; Drivers</h4> 
 <p>库和驱动层，代表了选用的各种具体的实现技术，例如持久层使用SQLite还是Core Data，网络层使用NSURLSession、NSURLConnection还是AFNetworking等。</p> 
 <h4 class="heading"><a name="Clean-Architecture-summary"></a>总结</h4> 
 <p>可以看到，Clean Architecture里已经出现了Use Case、Interactor、Presenter等概念，它为VIPER的工程实现提供了设计思想，VIPER将它的设计转化成了具体的实现。VIPER里的各部分正是存在着由外向内的依赖，从外向内表现为：<code>View -&gt; Presenter -&gt; Interactor -&gt; Entity</code>，<code>Wireframe</code>严格来说也是一类特殊的Use Case，用于不同模块之间通信，连接了不同的<code>Presenter</code>。</p> 
 <p>必须要记住的是，<strong>VIPER架构是根据由外向内的依赖关系来设计的</strong>。这句话是指导我们进行进一步设计和优化的关键。</p> 
 <h3 class="heading"><a name="other-implementations"></a>现有的各种VIPER实现</h3> 
 <p>MutualMobile的那两篇文章虽然已经明确了VIPER各部分之间的职责，并且给出了简单的Demo，但是对Wireframe部分的实现有些争议，解耦做得不够彻底，并且对各层之间如何交互还处在最简单的实现上。之后出现了挺多文章来将VIPER进一步细化，不过某些细节的实现上有些差别，在给出我自己的VIPER之前，我将先对这些实现进行一次综合的比较分析，看看他们都使用了哪些技术，遇到了哪些争议点。不同实现之间已经公认的地方我就不再单独列出了。</p> 
 <h4 class="heading"><a name="other-implementations-Brigade"></a>Brigade团队的实现</h4> 
 <p>原文地址：<a href="https://link.juejin.im?target=https%3A%2F%2Fbrigade.engineering%2Fbrigades-experience-using-an-mvc-alternative-36ef1601a41f" rel="nofollow">Brigade’s Experience Using an MVC Alternative: VIPER architecture for iOS applications</a>。</p> 
 <p>文章把VIPER的优点总结了一下，提出了这样的架构图：</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p>他们对VIPER的各部分都没有异议，只是对Interactor的实现进行了进一步细化。用一个Data Manager提供给各个Use Case管理Entity，比如获取、存储功能。在Service中调用网络层去获取服务端的数据。</p> 
 <p>文章中还认为应该由Wireframe负责初始化整个VIPER，生成各部分的类，并设置依赖关系，并且引用另一个模块的Wireframe，负责跳转到另一个界面。</p> 
 <p>和这个实现类似的还有：</p> 
 <ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fswifting.io%2Fblog%2F2016%2F03%2F07%2F8-viper-to-be-or-not-to-be%2F" rel="nofollow">VIPER to be or not to be?</a>。这篇文章里给出了一个Unit Test的例子，还探讨了应该在什么情况下开始应用VIPER。</li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fcheesecakelabs.com%2Fblog%2Fbest-practices-viper-architecture%2F" rel="nofollow">VIPER architecture: Our best practices to build an app like a boss</a>。Demo地址：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FCheesecakeLabs%2FBoilerplate_iOS_VIPER" rel="nofollow">Boilerplate_iOS_VIPER</a>。</li></ul> 
 <p>针对VIPER需要编写太多初始化代码的麻烦，可以使用Xcode自带的Template解决。而很多作者都提到了一个代码生成工具：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Frambler-digital-solutions%2FGeneramba" rel="nofollow">Generamba</a>。</p> 
 <h5 class="heading"><a name="other-implementations-Brigade-discusstion"></a>争议</h5> 
 <p>文章并没有对VIPER进行修改，只是进一步细化了。这应该是一个最简单的实现。如果你要实施VIPER，参照这篇文章来没有什么大问题。但是它没有探讨的问题是：</p> 
 <ul><li>如何解决不同Wrieframe之间的耦合？</li><li>Wrieframe如何知道其他模块需要的初始化参数？</li><li>在模块间通信时，Interactor的数据如何传递给另一个模块？</li><li>父模块和子模块之间是怎样的关系？</li></ul> 
 <h4 class="heading"><a name="other-implementations-Rambler"></a>Rambler&amp;Co团队的实现</h4> 
 <p>一个对VIPER十分感兴趣的俄国团队，编写了一本关于VIPER的书：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fstrongself%2FThe-Book-of-VIPER" rel="nofollow">The-Book-of-VIPER</a>。并且给出了一个目前网络上实现完成度最高的开源Demo：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Frambler-digital-solutions%2Frambler-it-ios" rel="nofollow">rambler-it-ios</a>，以及他们用于实施VIPER的库：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Frambler-digital-solutions%2FViperMcFlurry" rel="nofollow">ViperMcFlurry</a>。</p> 
 <p>他们整理的VIPER架构图如下：</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p>和其他实现不同的是，他们把VIPER的初始化和装配工作单独放到了一个Assembly里，Router只做界面跳转的工作。并且把VIPER内不同部分之间的通信统一用Input和Output来表示。Input表示外部主动调用模块提供的接口，Output表示模块通过外部实现所要求的接口，将事件传递到外部。</p> 
 <p>之所以将模块初始化单独放到Assembly里，是因为Router如果负责初始化本模块，会违背单一职责原则。</p> 
 <h5 class="heading"><a name="other-implementations-Rambler-discusstion"></a>争议</h5> 
 <p>这个实现的愿景很好，只是在转变为具体实现的时候不够完美，有很多问题尚待解决。具体可以参见Demo。</p> 
 <ul><li>Assembly使用了<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fappsquickly%2FTyphoon" rel="nofollow">Typhoon</a>这个依赖注入工具，通过Method Swizzling自动初始化VIPER的各个部分</li></ul> 
 <p>我对Typhoon这个依赖注入工具不是特别感冒，它使用了十分复杂的run time技术，想要追踪一个对象的注入过程时，会看得晕头转向。而且它无法实现运行时由调用方动态注入，只能实现预定义好的静态注入。也就是不能动态传参。</p> 
 <ul><li>使用storyboard进行路由</li></ul> 
 <p>在Demo中实现了在执行segue时用block来使用<code>-prepareForSegue:sender:</code>，实现向目的界面传参，实现了动态注入。但是这样就把路由限定在了storyboard的segue技术上，那么对于那些没有使用storyboard的项目应该怎么办呢？Demo并没有给出答案。而且<code>-prepareForSegue:sender:</code>只能向View传参，但是有一些参数是View不应该接触到的，而是应该直接传给Presenter或者Interactor的。</p> 
 <ul><li>有时候模块需要从Output中获取数据，例如Presenter主动获取View中的文字，传递给Interactor，此时<code>Output</code>并不能完整描述它的职责，还可以再进一步划分</li></ul> 
 <p>也就是说，他们的方案在设计上是不错的，但在技术上还有很多改进空间。</p> 
 <h4 class="heading"><a name="other-implementations-Uber"></a>Uber团队的实现</h4> 
 <p>Uber由于业务越来越复杂，旧项目的架构已经无法满足当前的需求，因此在2016年完全重构了他们的 rider app。他们借鉴VIPER，并且设计出了一个VIPER的变种架构：Riblets。文章地址：<a href="https://link.juejin.im?target=https%3A%2F%2Feng.uber.com%2Fnew-rider-app%2F" rel="nofollow">ENGINEERING THE ARCHITECTURE BEHIND UBER’S NEW RIDER APP</a>。</p> 
 <p>架构图如下：</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p>数据流向图：</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p>父模块和子模块之间通信：</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <h5 class="heading"><a name="other-implementations-Uber-intro"></a>各部分职责</h5> 
 <p>这里只列出一些和VIPER有差异的地方：</p> 
 <ul><li>Builder负责初始化Riblets模块内的各个部分，定义了模块的依赖参数</li><li>Component负责获取和初始化那些不是Riblets模块内的部分，例如services，并注入到Interactor中</li><li>Router负责管理子模块，持有子模块的Router，并把子模块的View添加到视图树上</li><li>Interactor通过调用Service管理Model，而不是在Interactor中直接管理</li><li>Interactor和子模块的Interactor通过监听者模式和delegate互相通信</li></ul> 
 <h5 class="heading"><a name="other-implementations-Uber-data-drive"></a>数据驱动</h5> 
 <p>最大的改变是将Router从Presenter移到了Interactor，改变了模块的主从关系，整个模块的生命周期现在由Interactor来管理。而之前的VIPER模块是依赖于View的生命周期的。这样一来，整个架构就从View驱动变成了业务驱动，或者数据驱动。</p> 
 <p>关于这个改变，Uber给出了两个原因：</p> 
 <ul><li>想要统一iOS和Andorid的软件架构，以及更好地互相借鉴开发经验和教训，因而需要改变iOS中视图驱动的设计</li><li>想要创建一个没有View，只有业务逻辑的模块，因此生命周期需要由Interactor管理</li></ul> 
 <h5 class="heading"><a name="other-implementations-Uber-discussion"></a>争议</h5> 
 <p>Uber团队的确很有想法。在对他们的这个方案进行深入实践之前，我无法评论这个方案是好是坏，我只在这里提出一些实践中可能会遇到的问题。</p> 
 <p>关于Uber给出的第一个原因，这是Uber团队基于协调两个开发团队的情况而做出的选择，如果我们没有他们这样统一开发的需求，并没有必要借鉴。iOS的UIKit是一个视图驱动的框架，很难做到100%数据驱动，在实践中将会遇到许多需要解决的问题，除非有足够的开发时间，否则不要草率地投入其中。是否要使用数据驱动的设计，还是应该由项目的业务设计来决定。当数据变化大部分是由后端的Service和网络数据引起时，再去考虑数据驱动吧。例如Uber的地图路线由定位模块不断计算，自动更新，就比较适合使用数据驱动。</p> 
 <p>关于第二个原因，一个没有View和Presenter的VIPER，就只剩下Router、Interactor、Model，这时这个模块可以看做是一个可以通过Router调用的Service或者Manager，这个Service有自己的状态和生命周期，Service也可以在View销毁后继续完成剩余的业务工作，只要业务需要，可以进行自持有，自释放。而且这个Service最终还是会表现在某个View上。这么看来，Router的层级已经升高了，成为了整个app内的模块间通信工具，可以连接任意模块，不仅仅是VIPER，因此Router由谁持有，就完全由模块内部自由管理了。</p> 
 <p>只是，在iOS中的VIPER里，实际的路由API都是存在于UIViewController上的，Router会直接和View产生引用，把Router放到和View隔离的Interactor里会破坏隔离。而且从Clean架构的分层来看，层级升高后的Router应该是处在Interface Adapter层和Framework &amp; Driver层之间，而Interactor则是在Application Business Rules层，由Interactor来管理其他角色，会破坏了Clean Architecture里的依赖关系。</p> 
 <p>比如一个没有View的、用于管理语音通话数据的Interactor，收到了通话异常中断的事件，在处理事件时，它不应该通过Router将自己移除，或者结束整个语音通话业务，或者自动调用重新拨号的业务，这样很容易会让不同的Use Case之间产生耦合，这些都应该由更上层的Service去选择执行，如果有页面跳转的设计，则应该把事件转发给一个存在Presenter层的Parent VIPER模块，由parent来决定是退出通话界面还是弹窗提示。当一个Interactor没有Presenter和View时，它一定是另一个VIPER的子模块。这么看来，在没有View时，或许让Service来持有Router才是正确的。</p> 
 <p>因此，如果真的有把VIPER变成数据驱动的需求，主要还是源于Uber给出的第一个基于团队统一的理由。</p> 
 <h5 class="heading"><a name="other-implementations-Uber-other-design"></a>其他设计</h5> 
 <p>文章里还给出了一些很有参考价值的内容，比如：</p> 
 <ul><li>对Interactor进行注入的Component</li><li>视图树变成了Router树</li><li>Interactor不直接维护Model，而是通过对应的Service来维护Model</li><li>父模块和子模块之间通过Interactor来通信</li></ul> 
 <p>Uber的这个方案讲了很多其他方案没有提到的方面，比如依赖注入、如何引入子模块等问题。不过这个方案并没有开源。</p> 
 <h3 class="heading"><a name="implementation1"></a>方案一：最完整的VIPER</h3> 
 <p>首先总结出一个绝对标准的VIPER，各部分遵循隔离关系，同时考虑到依赖注入、子模块通信、模块间解耦等问题，将VIPER的各部分的职责变得更加明确，也新增了几个角色。示例图如下，各角色的颜色和Clean Architecture图中各层的颜色对应：</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p>示例代码将用一个笔记应用作为演示。</p> 
 <h4 class="heading"><a name="implementation1-view"></a>View</h4> 
 <p>View可以是一个UIView + UIViewController，也可以只是一个custom UIView，也可以是一个自定义的用于管理UIView的Manager，只要它实现了View的接口就可以。</p> 
 <p>View层的职责：</p> 
 <ul><li>展示界面，组合各种UIView，并在UIViewController内管理各种控件的布局、更新</li><li>View对外暴露各种用于更新UI的接口，而自己不主动更新UI</li><li>View持有一个由外部注入的eventHandler对象，将View层的事件发送给eventHandler</li><li>View持有一个由外部注入的viewDataSource对象，在View的渲染过程中，会从viewDataSource获取一些用于展示的数据，viewDataSource的接口命名应该尽量和具体业务无关</li><li>View向Presenter提供routeSource，也就是用于界面跳转的源界面</li></ul> 
 <p>View层会引入各种自定义控件，这些控件有许多delegate，都在View层实现，统一包装后，再交给Presenter层实现。因为Presenter层并不知道View的实现细节，因此也就不知道这些控件的接口，Presenter层只知道View层统一暴露出来的接口。而且这些控件的接口在定义时可能会将数据获取、事件回调、控件渲染接口混杂起来，最具代表性的就是<code>UITableViewDataSource</code>里的<code>-tableView:cellForRowAtIndexPath:</code>。这个接口同时涉及到了<code>UITableViewCell</code>和渲染cell所需要的Model，是非常容易产生耦合的地方，因此需要做一次分解。应该在View的dataSource里定义一个从外部获取所需要的简单类型数据的方法，在<code>-tableView:cellForRowAtIndexPath:</code>里用获取到的数据渲染cell。示例代码：</p> 
 <pre><code class="hljs bash copyable">@protocol ZIKNoteListViewEventHandler &lt;NSObject&gt;
- (void)handleDidSelectRowAtIndexPath:(NSIndexPath *)indexPath;
@end
<span class="copy-code-btn">复制代码</span></code></pre> 
 <pre><code class="hljs bash copyable">@protocol ZIKNoteListViewDataSource &lt;NSObject&gt;
- (NSInteger)numberOfRowsInSection:(NSInteger)section;
- (NSString *)textOfCellForRowAtIndexPath:(NSIndexPath *)indexPath;
- (NSString *)detailTextOfCellForRowAtIndexPath:(NSIndexPath *)indexPath;
@end
<span class="copy-code-btn">复制代码</span></code></pre> 
 <pre><code class="hljs bash copyable">@interface ZIKNoteListViewController () &lt;UITableViewDelegate,UITableViewDataSource&gt;
@property (nonatomic, strong) id&lt;ZIKNoteListViewEventHandler&gt; eventHandler;
@property (nonatomic, strong) id&lt;ZIKNoteListViewDataSource&gt; viewDataSource;
@property (weak, nonatomic) IBOutlet UITableView *noteListTableView;
@end

@implementation ZIKNoteListViewController

- (UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath
                                      text:(NSString *)text
                                detailText:(NSString *)detailText {
    UITableViewCell *cell = [self.noteListTableView dequeueReusableCellWithIdentifier:@<span class="hljs-string">"noteListCell"</span> <span class="hljs-keyword">for</span>IndexPath:indexPath];
    cell.textLabel.text = text;
    cell.detailTextLabel.text = detailText;
    <span class="hljs-built_in">return</span> cell;
}

<span class="hljs-comment">#pragma mark UITableViewDataSource</span>

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    <span class="hljs-built_in">return</span> [self.viewDataSource numberOfRowsInSection:section];
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    NSString *text = [self.viewDataSource textOfCellForRowAtIndexPath:indexPath];
    NSString *detailText = [self.viewDataSource detailTextOfCellForRowAtIndexPath:indexPath];
    UITableViewCell *cell = [self cellForRowAtIndexPath:indexPath
                                                   text:text
                                             detailText:detailText];
    <span class="hljs-built_in">return</span> cell;
}

<span class="hljs-comment">#pragma mark UITableViewDelegate</span>

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
    [tableView deselectRowAtIndexPath:indexPath animated:YES];
    
    [self.eventHandler handleDidSelectRowAtIndexPath:indexPath];
}

@end
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>一般来说，viewDataSource和eventHandler都是由Presenter来担任的，Presenter接收到dataSource请求时，从Interactor里获取并返回对应的数据。你也可以选择在View和Presenter之间用ViewModel来进行交互。</p> 
 <h4 class="heading"><a name="implementation1-presenter"></a>Presenter</h4> 
 <p>Presenter由View持有，它的职责有：</p> 
 <ul><li>接收并处理来自View的事件</li><li>维护和View相关的各种状态和配置，比如界面是否使用夜间模式等</li><li>调用Interactor提供的Use Case执行业务逻辑</li><li>向Interactor提供View中的数据，让Interactor生成需要的Model</li><li>接收并处理来自Interactor的业务事件回调事件</li><li>通知View进行更新操作</li><li>通过Wireframe跳转到其他View</li></ul> 
 <p>Presenter是View和业务之间的中转站，它不包含业务实现代码，而是负责调用现成的各种Use Case，将具体事件转化为具体业务。Presenter里不应该导入UIKit，否则就有可能入侵View层的渲染工作。Presenter里也不应该出现Model类，当数据从Interactor传递到Presenter里时，应该转变为简单的数据结构。</p> 
 <p>示例代码：</p> 
 <pre><code class="hljs bash copyable">@interface ZIKNoteListViewPresenter () &lt;ZIKNoteListViewDataSource, ZIKNoteListViewEventHandler&gt;
@property (nonatomic, strong) id&lt;ZIKNoteListWireframeProtocol&gt; wireframe;
@property (nonatomic, weak) id&lt;ZIKViperView,ZIKNoteListViewProtocol&gt; view;
@property (nonatomic, strong) id&lt;ZIKNoteListInteractorInput&gt; interactor;
@end

@implementation ZIKNoteListViewPresenter

<span class="hljs-comment">#pragma mark ZIKNoteListViewDataSource</span>

- (NSInteger)numberOfRowsInSection:(NSInteger)section {
    <span class="hljs-built_in">return</span> self.interactor.noteCount;
}

- (NSString *)textOfCellForRowAtIndexPath:(NSIndexPath *)indexPath {
    NSString *title = [self.interactor titleForNoteAtIndex:indexPath.row];
    <span class="hljs-built_in">return</span> title;
}

- (NSString *)detailTextOfCellForRowAtIndexPath:(NSIndexPath *)indexPath {
    NSString *content = [self.interactor contentForNoteAtIndex:indexPath.row];
    <span class="hljs-built_in">return</span> content;
}

<span class="hljs-comment">#pragma mark ZIKNoteListViewEventHandler</span>

- (void)handleDidSelectRowAtIndexPath:(NSIndexPath *)indexPath {
    NSString *uuid = [self.interactor noteUUIDAtIndex:indexPath.row];
    NSString *title = [self.interactor noteTitleAtIndex:indexPath.row];
    NSString *content = [self.interactor noteContentAtIndex:indexPath.row];
    
    [self.wireframe pushEditorViewForEditingNoteWithUUID:uuid title:title content:content delegate:self];
}

@end
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h4 class="heading"><a name="implementation1-interactor"></a>Interactor</h4> 
 <p>Ineractor的职责：</p> 
 <ul><li>实现和封装各种业务的Use Case，供外部调用</li><li>维护和业务相关的各种状态，比如是否正在编辑笔记</li><li>Interactor可以获取各种Manager和Service，用于组合实现业务逻辑，这些Manager和Service应该是由外部注入的依赖，而不是直接引用具体的类</li><li>通过DataManager维护Model</li><li>监听各种外部的业务事件并处理，必要时将事件发送给eventHandler</li><li>Interactor持有一个由外部注入的eventHandler对象，将需要外部处理的业务事件发送给eventHandler，或者通过eventHandler接口对某些数据操作的过程进行回调</li><li>Interactor持有一个由外部注入的dataSource对象，用于获取View上的数据，以更新Model</li></ul> 
 <p>Interactor是业务的实现者和维护者，它会调用各种Service来实现业务逻辑，封装成明确的用例。而这些Service在使用时，也都是基于接口的，因为Interactor的实现不和具体的类绑定，而是由Application注入Interactor需要的Service。</p> 
 <p>示例代码：</p> 
 <pre><code class="hljs bash copyable">@protocol ZIKNoteListInteractorInput &lt;NSObject&gt;
- (void)loadAllNotes;
- (NSInteger)noteCount;
- (NSString *)titleForNoteAtIndex:(NSUInteger)idx;
- (NSString *)contentForNoteAtIndex:(NSUInteger)idx;
- (NSString *)noteUUIDAtIndex:(NSUInteger)idx;
- (NSString *)noteTitleAtIndex:(NSUInteger)idx;
- (NSString *)noteContentAtIndex:(NSUInteger)idx;
@end
<span class="copy-code-btn">复制代码</span></code></pre> 
 <pre><code class="hljs bash copyable">@interface ZIKNoteListInteractor : NSObject &lt;ZIKNoteListInteractorInput&gt;
@property (nonatomic, weak) id dataSource;
@property (nonatomic, weak) id eventHandler;
@end

@implementation ZIKNoteListInteractor

- (void)loadAllNotes {
    [[ZIKNoteDataManager sharedInsatnce] fetchAllNotesWithCompletion:^(NSArray *notes) {
        [self.eventHandler didFinishLoadAllNotes];
    }];
}

- (NSArray&lt;ZIKNoteModel *&gt; *)noteList {
    <span class="hljs-built_in">return</span> [ZIKNoteDataManager sharedInsatnce].noteList;
}

- (NSInteger)noteCount {
    <span class="hljs-built_in">return</span> self.noteList.count;
}

- (NSString *)titleForNoteAtIndex:(NSUInteger)idx {
    <span class="hljs-keyword">if</span> (self.noteList.count - 1 &lt; idx) {
        <span class="hljs-built_in">return</span> nil;
    }
    <span class="hljs-built_in">return</span> [[self.noteList objectAtIndex:idx] title];
}

- (NSString *)contentForNoteAtIndex:(NSUInteger)idx {
    <span class="hljs-keyword">if</span> (self.noteList.count - 1 &lt; idx) {
        <span class="hljs-built_in">return</span> nil;
    }
    <span class="hljs-built_in">return</span> [[self.noteList objectAtIndex:idx] content];
}

- (NSString *)noteUUIDAtIndex:(NSUInteger)idx {
    <span class="hljs-keyword">if</span> (self.noteList.count - 1 &lt; idx) {
        <span class="hljs-built_in">return</span> nil;
    }
    <span class="hljs-built_in">return</span> [[self.noteList objectAtIndex:idx] uuid];
}

- (NSString *)noteTitleAtIndex:(NSUInteger)idx {
    <span class="hljs-keyword">if</span> (self.noteList.count - 1 &lt; idx) {
        <span class="hljs-built_in">return</span> nil;
    }
    <span class="hljs-built_in">return</span> [[self.noteList objectAtIndex:idx] title];
}

- (NSString *)noteContentAtIndex:(NSUInteger)idx {
    <span class="hljs-keyword">if</span> (self.noteList.count - 1 &lt; idx) {
        <span class="hljs-built_in">return</span> nil;
    }
    <span class="hljs-built_in">return</span> [[self.noteList objectAtIndex:idx] content];
}

@end
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h4 class="heading"><a name="implementation1-service"></a>Service</h4> 
 <p>向Interactor提供各种封装好的服务，例如数据库的访问、存储，调用定位功能等。Service由Application在执行路由时注入到Builder里，再由Buidler注入到Interactor里。也可以只注入一个Service Router，在运行时再通过这个Service Router懒加载需要的Service，相当于注入了一个提供Router功能的Service。</p> 
 <p>Service可以看作是没有View的VIPER，也有自己的路由和Builder。</p> 
 <h4 class="heading"><a name="implementation1-wireframe"></a>Wireframe</h4> 
 <p>翻译成中文叫线框，用于表达从一个Module到另一个Module的过程。虽然也是扮演者执行路由的角色，但是其实它和Router是有区别的。</p> 
 <p>Wireframe和storyboard中连接好的一个个segue类似，负责提供一系列具体的路由用例，这个用例里已经配置好了源界面和目的界面的一些依赖，包括转场动画、模块间传参等。Wireframe的接口是提供给模块内部使用的，它通过调用Router来执行真正的路由操作。</p> 
 <p>示例代码：</p> 
 <pre><code class="hljs bash copyable">@interface ZIKTNoteListWireframe : NSObject &lt;ZIKTViperWireframe&gt;
- (void)presentLoginViewWithMessage:(NSString *)message delegate:(id&lt;ZIKTLoginViewDelegate&gt;)delegate completion:(void (^ __nullable)(void))completion;
- (void)dismissLoginView:(UIViewController *)viewController animated:(BOOL)animated completion:(void (^ __nullable)(void))completion;
- (void)presentEditorForCreatingNewNoteWithDelegate:(id&lt;ZIKTEditorDelegate&gt;)delegate completion:(void (^ __nullable)(void))completion;
- (void)pushEditorViewForEditingNoteWithUUID:(NSString *)uuid title:(NSString *)title content:(NSString *)content delegate:(id&lt;ZIKTEditorDelegate&gt;)delegate;
- (UIViewController *)editorViewForEditingNoteWithUUID:(NSString *)uuid title:(NSString *)title content:(NSString *)content delegate:(id&lt;ZIKTEditorDelegate&gt;)delegate;
- (void)pushEditorViewController:(UIViewController *)destination fromViewController:(UIViewController *)<span class="hljs-built_in">source</span> animated:(BOOL)animated;
- (void)quitEditorViewWithAnimated:(BOOL)animated;
@end
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h4 class="heading"><a name="implementation1-router"></a>Router</h4> 
 <p>Router则是由Application提供的具体路由技术，可以简单封装UIKit里的那些跳转方法，也可以用URL Router来执行路由。但是一个模块是不需要知道app使用的是什么具体技术的。Router才是真正连接各个模块的地方。它也负责寻找对应的目的模块，并且通过Buidler进行依赖注入。</p> 
 <p>示例代码：</p> 
 <pre><code class="hljs bash copyable">@interface ZIKTRouter : NSObject &lt;ZIKTViperRouter&gt;
///封装UIKit的跳转方法
+ (void)pushViewController:(UIViewController *)destination fromViewController:(UIViewController *)<span class="hljs-built_in">source</span> animated:(BOOL)animated;
+ (void)popViewController:(UIViewController *)viewController animated:(BOOL)animated;
+ (void)presentViewController:(UIViewController *)viewControllerToPresent fromViewController:(UIViewController *)<span class="hljs-built_in">source</span> animated:(BOOL)animated completion:(void (^ __nullable)(void))completion;
+ (void)dismissViewController:(UIViewController *)viewController animated:(BOOL)animated completion:(void (^ __nullable)(void))completion;
@end

@implementation ZIKTRouter (ZIKTEditor)

+ (UIViewController *)viewForCreatingNoteWithDelegate:(id&lt;ZIKTEditorDelegate&gt;)delegate {
    <span class="hljs-built_in">return</span> [ZIKTEditorBuilder viewForCreatingNoteWithDelegate:delegate];
}

+ (UIViewController *)viewForEditingNoteWithUUID:(NSString *)uuid title:(NSString *)title content:(NSString *)content delegate:(id&lt;ZIKTEditorDelegate&gt;)delegate {
    <span class="hljs-built_in">return</span> [ZIKTEditorBuilder viewForEditingNoteWithUUID:uuid title:title content:content delegate:delegate];
}

@end
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h4 class="heading"><a name="implementation1-adapter"></a>Adapter</h4> 
 <p>由Application实现，负责在模块通信时进行一些接口的转换，例如两个模块使用了相同业务功能的某个Service，使用的protocol实现一样，但是protocol名字不一样，就可以在路由时，在Adapter里进行一次转换。甚至只要定义的逻辑一样，依赖参数的名字和数据类型也可以允许不同。这样就能让模块不依赖于某个具体的protocol，而是依赖于protocol实际定义的依赖和接口。</p> 
 <p>注意这里的Adapter和Clean Architecture里的<code>Interface Adapter</code>是不一样的。这里的Adapter就是字面意义上的接口转换，而Clean Architecture里的<code>Interface Adapter</code>层更加抽象，是Use Case层与具体实现技术之间的转换，囊括了更多的角色。</p> 
 <h4 class="heading"><a name="implementation1-builder"></a>Builder</h4> 
 <p>负责初始化整个模块，配置VIPER之间的关系，并对外声明模块需要的依赖，让外部执行注入。</p> 
 <h3 class="heading"><a name="module-decoupling"></a>模块间解耦</h3> 
 <p>一个VIPER模块可以看做是一个独立的组件，可以被单独封装成一个库，被app引用。这时候，app就负责将各个模块连接起来，也就是图中灰色的<code>Application Context</code>部分。一个模块，肯定是存在于一个上下文环境中才能运行起来的。</p> 
 <p><code>Wireframe</code> -&gt; <code>Router</code> -&gt; <code>Adapter</code> -&gt; <code>Builder</code> 实现了一个完整的模块间路由，并且实现了模块间的解耦。</p> 
 <p>其中Wireframe和Builder是分别由引用者模块和被引用模块提供的，是两个模块的出口和入口，而Router和Adapter则是由模块的使用者——Application实现的。</p> 
 <p>当两个模块之间存在引用关系时，说明存在业务逻辑上的耦合，这种耦合是业务的一部分，是不可能消除的。我们能做的就是把耦合尽量交给模块调用者，由Application来提供具体的类，注入到各个模块之中，而模块内部只面向protocol即可。这样的话，被引用模块只要实现了相同的接口，就可以随时替换，甚至接口有一些差异时，只要被引用模块提供了相同功能的接口，也可以通过Adapter来做接口兼容转换，让引用者模块无需做任何修改。</p> 
 <p>Wireframe相当于插头，Builder相当于插座，而Router和Adapter相当于电路和转接头，将不同规格的插座和插头连接起来。把这些连接和适配的工作交给Application层，就能让两个模块实现各自独立。</p> 
 <h3 class="heading"><a name="submodule"></a>子模块</h3> 
 <p>大部分方案都没有讨论子模块存在的情况。在VIPER里如何引入另一个VIPER模块？多个模块之间如何交互？子模块由谁初始化、由谁管理？</p> 
 <p>其他几个实现中，只有Uber较为详细地讨论了子模块的问题。在Uber的Riblets架构里，子模块的Router被添加到父模块的Router，模块之间通过delegate和监听的方式进行通信。这样做会让模块间产生一定的耦合。如果子模块是由于父View使用了一个子View控件而被引入的，那么父Interactor就会在代码里多出一个子Interactor，这样就导致了View的实现方式影响了Interactor的实现。</p> 
 <h4 class="heading"><a name="submodule-source"></a>子模块的来源</h4> 
 <p>子模块的来源有：</p> 
 <ul><li>View引用了一个封装好的子View控件，连带着引入了子View的整个VIPER</li><li>Interactor使用了一个Service</li></ul> 
 <h4 class="heading"><a name="submodule-communication"></a>通信方式</h4> 
 <p>子View可能是一个UIView，也可能是一个Child UIViewController。因此子View有可能需要向外部请求数据，也可能独立完成所有任务，不需要依赖父模块。</p> 
 <p>如果子View可以独立，那在子模块里不会出现和父模块交互的逻辑，只有把一些事件通过Output传递出去的接口。这时只需要把子View的接口封装在父View的接口里即可，父Presenter和父Interactor是不知道父View提供的这几个接口是通过子View实现的。这样父模块就能接收到子模块的事件了，而且能够保持Interactor和Presenter、View之间从低到高的依赖关系。</p> 
 <p>如果父模块需要调用子模块的某些功能，或者从子模块获取数据，可以选择封装到父View的接口里，不过如果涉及到数据模型，并且不想让数据模型出现在View的接口中，可以把子Interactor作为父Interactor的一个Service，在引入子模块时，通过父Builder注入到父Interactor里，或者根据依赖关系解耦地再彻底一点，注入到父Presenter里，让父Presenter再把接口转发给父Interactor。这样子模块和父模块就能通过Service的形式进行通信了，而这时，父Interactor也不知道这个Service是来自子模块里的。</p> 
 <p>在这样的设计下，子模块和父模块是不知道彼此的存在的，只是通过接口进行交互。好处是父View如果想要更换为另一个相同功能的子View控件，就只需要在父View里修改，不会影响Presenter和Interactor。</p> 
 <h3 class="heading"><a name="dependency-injection"></a>依赖注入</h3> 
 <p>这个VIPER的设计是通过接口将各个部分组合在一起的，一个类需要设置很多依赖，例如Interactor需要依赖许多Service。这就涉及到了两个问题：</p> 
 <ul><li>在哪里配置依赖</li><li>一个类怎么声明自己的依赖</li></ul> 
 <p>在这个方案中，由Builder声明整个模块的依赖，然后在Builder内部为不同的类设置依赖，外部在注入依赖时，就不必知道内部是怎么使用这些依赖参数的。一个类如果有必需的依赖参数，可以直接在init方法里体现，对于那些非必需的依赖，可以通过暴露接口来声明。</p> 
 <p>如果需要动态注入，而不是在模块初始化时就配置所有的依赖，Builder也可以提供动态注入的接口。</p> 
 <h3 class="heading"><a name="map-to-mvc"></a>映射到MVC</h3> 
 <p>如果你需要把一个模块从MVC重构到VIPER，可以先按照这个步骤：</p> 
 <ul><li>整理Controller中的代码，把不同职责的代码用pragma mark分隔好</li><li>整理好后，按照各部分的职责，将代码分散到VIPER的各个角色中，此时View、Presenter、Interactor之间可以直接互相引用</li><li>把View、Presenter、Interactor进行解耦，抽出接口，互相之间依赖接口进行交互</li></ul> 
 <p>下面就是第一步里在Controller中可以分隔出的职责：</p> 
 <pre><code class="hljs bash copyable">@implementation ViewController
//------View-------

//View的生命周期
<span class="hljs-comment">#pragma mark View life</span>

//View的配置，包括布局设置
<span class="hljs-comment">#pragma mark View config</span>

//更新View的接口
<span class="hljs-comment">#pragma mark Update view</span>

//View需要从model中获取的数据
<span class="hljs-comment">#pragma mark Request view data source</span>

//监控、接收View的事件
<span class="hljs-comment">#pragma mark Send view event</span>

//------Presenter-------

//处理View的事件
<span class="hljs-comment">#pragma mark Handle view event</span>

//界面跳转
<span class="hljs-comment">#pragma mark Wireframe</span>

//向View提供配置用的数据
<span class="hljs-comment">#pragma mark Provide view data source</span>

//提供生成model需要的数据
<span class="hljs-comment">#pragma mark Provide model data source</span>

//处理业务事件，调用业务用例
<span class="hljs-comment">#pragma mark Handle business event</span>

//------Interactor-------

//监控、接收业务事件
<span class="hljs-comment">#pragma mark Send business event</span>

//业务用例
<span class="hljs-comment">#pragma mark Business use case</span>

//获取生成model需要的数据
<span class="hljs-comment">#pragma mark Request data for model</span>

//维护model
<span class="hljs-comment">#pragma mark Manage model</span>

@end
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>这里缺少了View状态管理、业务状态管理等职责，因为这些状态一般都是@property，用pragma mark不能分隔它们，只能在@interface里声明的时候进行隔离。</p> 
 <h3 class="heading"><a name="implementation2"></a>方案二：允许适当耦合</h3> 
 <p>上面的方案是以最彻底的解耦为目标设计的，在实践中，如果真的完全按照这个设计，代码量的确不小。其实一些地方的耦合并不会引起多大问题，除非你的模块需要封装成通用组件供多个app使用，否则并不需要按照100%的解耦要求来编写。因此接下来我再总结一个稍微简化的方案，总结一下各部分可以在哪些地方出现耦合，哪些耦合不能出现。</p> 
 <p>在这个方案里，我使用了一个中介者来减少一部分代码，Router就是一个很适合成为中介者的角色。</p> 
 <p>架构图如下：</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <h4 class="heading"><a name="implementation2-view"></a>View</h4> 
 <ul><li>View可以直接通过Router引入另一个子View，不需要通过Presenter的路由来引入</li><li>View中的一些delegate如果变化的可能性不大，可以直接让Presenter实现（例如<code>UITableViewDataSource</code>），不用再封装一遍后交给Presenter</li><li>View不能出现Model类</li></ul> 
 <h4 class="heading"><a name="implementation2-presenter"></a>Presenter</h4> 
 <ul><li>Presenter可以直接调用Router执行路由，不用再通过Wireframe封装一遍</li><li>Presenter的接口参数中可以出现Model类，但是不能导入Model类的头文件并且使用Model类，只能用于参数传递</li><li>Presenter中不建议导入UIKit，除非能保证不会使用那些会影响控件渲染的方法</li></ul> 
 <h4 class="heading"><a name="implementation2-interactor"></a>Interactor</h4> 
 <ul><li>一些app中常用的Service可以直接引入，不需要通过外部注入的方式来使用</li><li>Interactor可以用一个Service Router来动态获取Service</li></ul> 
 <h4 class="heading"><a name="implementation2-router-dependency-injection"></a>路由和依赖注入</h4> 
 <p>改变得最多的就是路由部分。View、Presenter和Interactor都可以使用路由来获取一些模块。View可以通过路由获取子View，Presenter可以通过路由获取其他View模块，Interactor可以通过路由获取Service。</p> 
 <p>在实现时，可以把Wireframe、Router、Builder整合到一起，全都放到Router里，Router由模块实现并提供给外部使用。类似于Brigade团队和Rambler&amp;Co团队的实现。但是他们的实现都是直接在Router里引入其他模块的Router，这样会导致依赖混乱，更好的方式是通过一个中间人统一提供其他模块的接口。</p> 
 <p>我在这里造了个轮子，通过protocol来寻找需要的模块并执行路由，不用直接导入目的模块中的类，并且提供了Adapter的支持，可以让多个protocol指向同一个模块。这样就能避免模块间的直接依赖。</p> 
 <p>示例代码：</p> 
 <pre><code class="hljs bash copyable">///editor模块的依赖声明
@protocol NoteEditorProtocol &lt;NSObject&gt;
@property (nonatomic, weak) id&lt;ZIKEditorDelegate&gt; delegate;
- (void)constructForCreatingNewNote;
- (void)constructForEditingNote:(ZIKNoteModel *)note;
@end

@implementation ZIKNoteListViewPresenter

- (void)handleDidSelectRowAtIndexPath:(NSIndexPath *)indexPath {
    NSAssert([[self.view routeSource] isKindOfClass:[UIViewController class]], nil);
    
    //跳转到编辑器界面；通过protocol获取对应的router类，再通过protocol注入依赖
    //App可以用Adapter把NoteEditorProtocol和真正的protocol进行匹配和转接
    [ZIKViewRouterToModule(NoteEditorProtocol)
	     performFromSource:[self.view routeSource] //跳转的源界面
	     configuring:^(ZIKViewRouteConfiguration&lt;NoteEditorProtocol&gt; *config) {
	         //路由配置
	         //设置跳转方式，支持所有界面跳转类型
	         config.routeType = ZIKViewRouteTypePush;
	         //Router内部负责用获取到的参数初始化editor模块
	         config.delegate = self;
	         [config constructForEditingNote:[self.interactor noteAtIndex:indexPath.row]];
	         config.prepareForRoute = ^(id destination) {
	             //跳转前配置目的界面
	         };
	         config.routeCompletion = ^(id destination) {
	             //跳转结束处理
	         };
	         config.performerErrorHandler = ^(SEL routeAction, NSError * error) {
	             //跳转失败处理
	         };
	     }];
}

@end
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h4 class="heading"><a name="implementation2-summary"></a>总结</h4> 
 <p>这个方案依赖于一个统一的中间人，也就是路由工具，在我的实现里就是<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FZuikyo%2FZIKRouter" rel="nofollow">ZIKRouter</a>。View、Presenter、Interactor都可以使用对应功能的Router获取子模块。而由于ZIKRouter仍然是通过protocol的方式来和子模块进行交互，因此仍然可保持模块间解耦。唯一的耦合就是各部分都引用了ZIKRouter这个工具。如果你想把模块和ZIKRouter的耦合也去除，可以让Router也变成面向接口，由外部注入。</p> 
 <h3 class="heading"><a name="demo-template"></a>Demo和代码模板</h3> 
 <p>针对两个方案，同时写了两个相同功能的Demo，可以比较一下代码上的区别。地址在：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FZuikyo%2FZIKViper" rel="nofollow">ZIKViper</a>。注意，Demo需要先用pod install安装一下依赖库。</p> 
 <p>项目里也提供了Xcode File Template用于快速生成VIPER代码模板。把<code>.xctemplate</code>后缀的文件夹拷贝到<code>~/Library/Developer/Xcode/Templates/</code>目录下，就可以在Xcode的<code>New-&gt;File-&gt;Template</code>里选择代码模板快速生成代码。</p> 
 <h3 class="heading"><a name="reference"></a>参考</h3> 
 <ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fmutualmobile.com%2Fposts%2Fmeet-viper-fast-agile-non-lethal-ios-architecture-framework" rel="nofollow">MEET VIPER: MUTUAL MOBILE’S APPLICATION OF CLEAN ARCHITECTURE FOR IOS APPS</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.objc.io%2Fissues%2F13-architecture%2Fviper%2F" rel="nofollow">Architecting iOS Apps with VIPER</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2F8thlight.com%2Fblog%2Funcle-bob%2F2012%2F08%2F13%2Fthe-clean-architecture.html" rel="nofollow">Clean Architecture</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fbrigade.engineering%2Fbrigades-experience-using-an-mvc-alternative-36ef1601a41f" rel="nofollow">Brigade’s Experience Using an MVC Alternative: VIPER architecture for iOS applications</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fswifting.io%2Fblog%2F2016%2F03%2F07%2F8-viper-to-be-or-not-to-be%2F" rel="nofollow">VIPER to be or not to be?</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fcheesecakelabs.com%2Fblog%2Fbest-practices-viper-architecture%2F" rel="nofollow">VIPER architecture: Our best practices to build an app like a boss</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fstrongself%2FThe-Book-of-VIPER" rel="nofollow">The-Book-of-VIPER</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Feng.uber.com%2Fnew-rider-app%2F" rel="nofollow">ENGINEERING THE ARCHITECTURE BEHIND UBER’S NEW RIDER APP</a></li></ul> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/91ce0c91fe5b92b0dc3694d6e936fabb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Git十周岁之际，Linus Torvalds大谈Git开发故事</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e905dfffe4e49890e59f557b92024463/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用XMLWorkerHelper.getInstance().parseXHtml生成PDF时中文不显示或乱码问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>