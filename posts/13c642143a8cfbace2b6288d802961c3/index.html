<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python常用的内置函数（会持续增加的） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python常用的内置函数（会持续增加的）" />
<meta property="og:description" content="Python 常用内置函数如下： 不是原创，但是都是自己整理的
1. abs()函数返回数字的绝对值。 print( abs(-45) ) # 返回 45 print(&#34;abs(0.2):&#34;,abs(0.2)) # 返回 abs(0.2): 0.2 2. all() 函数用于判断给定的参数中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。元素除了是 0、空、None、False 外都算 True；空元组、空列表返回值为True。 print( all( [0.1,1,-1] ) ) # 返回 True print( all( (None,1) ) ) # 返回 False（其中一个元素为None） print( all( [0,1,-1] ) ) # 返回 False（其中一个元素为0） print( all( [&#34; &#34;,&#34;a&#34;,&#34;&#34;] ) ) # 返回 False(第三个元素为空) 3. any() 函数用于判断给定的参数是否全部为False，是则返回False，如果有一个为True，则返回True。 元素除了是 0、空、False外都算 TRUE。 # 参数全部不为 0、空、FALSE print(any(&#34;-45&#34;)) # True print(any([&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/13c642143a8cfbace2b6288d802961c3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-22T09:20:41+08:00" />
<meta property="article:modified_time" content="2020-10-22T09:20:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python常用的内置函数（会持续增加的）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Python__0"></a>Python 常用内置函数如下：</h2> 
<p><s>不是原创，但是都是自己整理的</s></p> 
<h6><a id="1_abs_4"></a>1. abs()函数返回数字的绝对值。</h6> 
<pre><code>print( abs(-45) )                  # 返回 45

print("abs(0.2):",abs(0.2))        # 返回 abs(0.2): 0.2
</code></pre> 
<h6><a id="2_all__TRUE_True_False_0NoneFalse__TrueTrue_14"></a>2. all() 函数用于判断给定的参数中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。元素除了是 0、空、None、False 外都算 True；空元组、空列表返回值为True。</h6> 
<pre><code>print( all( [0.1,1,-1] )  )        # 返回 True
print( all( (None,1) )  )          # 返回 False（其中一个元素为None）
print( all( [0,1,-1] )  )          # 返回 False（其中一个元素为0）
print( all( [" ","a",""] )  )      # 返回 False(第三个元素为空)
</code></pre> 
<h6><a id="3_any_FalseFalseTrueTrue__0False_TRUE_25"></a>3. any() 函数用于判断给定的参数是否全部为False，是则返回False，如果有一个为True，则返回True。 元素除了是 0、空、False外都算 TRUE。</h6> 
<pre><code># 参数全部不为 0、空、FALSE
print(any("-45"))                 #  True
print(any(["-45"]))               #  True
print( any( ("0","ab","") ) )     #  True（注意：第一个参数0加了双引号，表示为一个字符串）

# 参数全部为 0、空、False
print( any( (0,"") ) )            #  False
print( any( (0,"",False) ) )      #  False
</code></pre> 
<h6><a id="4_binintlong_int_44"></a>4. bin()函数返回一个整数int或者长整数long int的二进制表示。</h6> 
<pre><code>print( bin(10) )        #  0b1010

print( bin(133) )       #  0b10000101
</code></pre> 
<h6><a id="5_bool_0True0False_54"></a>5. bool() 函数用于将给定参数转换为布尔类型，如果参数不为空或不为0，返回True；参数为0或没有参数，返回False。</h6> 
<pre><code>print( bool(10) )                 #  True
print( bool([0]) )                #  True
print( bool(["123","s",0]) )      #  True

print( bool(0) )                  #  False
print( bool() )                   #  False
</code></pre> 
<h6><a id="6_bytearray_0__x__2560255bytearray_71"></a>6. bytearray()方法返回一个新字节数组。这个数组里的元素是可变的，并且每个元素的值范围: 0 &lt;= x &lt; 256（即0-255）。即bytearray()是可修改的二进制字节格式。</h6> 
<pre><code>1 b = bytearray("abcd",encoding="utf-8")
2 print(b[0])            #  返回数字97，即把“abcd”的“a"对应的ascii码打印出来了
3 b[0] = 99              #  把字符串第一个字节修改为99（即对应字母为“c”）
4 print(b)               #  返回：bytearray(b'cbcd')---第一个字节a已被修改为c
</code></pre> 
<h6><a id="7_callablelambda___call_____True_82"></a>7. callable()函数用于检查一个对象是否可调用的。对于函数、方法、lambda函式、类以及实现了 <strong>call</strong> 方法的类实例, 它都返回 True。（可以加括号的都可以调用）</h6> 
<pre><code>1 def sayhi():pass                 #  先定义一个函数sayhi()
2 print( callable( sayhi ) )       #  True
1 a = 1
2 print( callable( a ) )           #  False
</code></pre> 
<h6><a id="8_chrrange2560255ASCII_93"></a>8. chr()函数用一个范围在range(256)内（即0～255）的整数作参数，返回一个对应的ASCII数值。</h6> 
<pre><code># 把数字98在ascii码中对应的字符打印出来
print( chr(98) )                   #  返回：b
</code></pre> 
<h6><a id="9_dict_102"></a>9. dict()函数用来将元组/列表转换为字典格式。</h6> 
<pre><code>print(dict(a='a', b='b', t='t'))
#  返回：{'b': 'b', 'a': 'a', 't': 't'}

print(dict( [ ('one',1),('two',2),('three',3) ]  ) )   # 可迭代对象方式来构造字典
#  返回：{'two': 2, 'one': 1, 'three': 3}

print(dict(zip(["1","2","3"],["a","b","c"])))     # 映射函数方式来构造字典
#  返回：{'2': 'b', '3': 'c', '1': 'a'}
</code></pre> 
<h6><a id="10_dir_121"></a>10. dir()函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。</h6> 
<pre><code>print( dir() )           #  获得当前模块的属性列表
#  返回：['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__']
print( dir([]) )         #  查看列表的方法
#  返回：['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
</code></pre> 
<h6><a id="11_divmod_xy_136"></a>11. divmod() 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组（商x，余数y）。</h6> 
<pre><code>print( divmod(5,2) )    #  返回：(2, 1)
print( divmod(5,1) )    #  返回：(5, 0)
print( divmod(5,3) )    #  返回：(1, 2)
</code></pre> 
<h6><a id="12_enumerate__for_Python_23_26__start__146"></a>12. enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。Python 2.3. 以上版本可用，2.6 添加 start 参数。//打标签</h6> 
<pre><code>1 seasons = ['Spring', 'Summer', 'Fall', 'Winter']    
2 print(list(enumerate(seasons)))                  #  返回：[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
1 print(list(enumerate(seasons, start=1)) )         # 下标从 1 开始 
#  返回：[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
</code></pre> 
<h6><a id="13_eval__157"></a>13. eval() 函数用来执行一个字符串表达式，并返回表达式的值。</h6> 
<pre><code>print(eval('3 * 2'))          # 6
1 x = 7
2 print(eval('3 + x'))        # 10
</code></pre> 
<h6><a id="14_exec_PythonevalexecPython_167"></a>14. exec() 执行储存在字符串或文件中的Python语句，相比于eval，exec可以执行更复杂的Python代码。</h6> 
<pre><code>exec("print('Hello World')")        # 执行简单的字符串
# Hello World
</code></pre> 
<pre><code>exec("for i in range(5): print('iter time is %d'%i)")      # 执行复杂的for循环
# iter time is 0
# iter time is 1
# iter time is 2
# iter time is 3
# iter time is 4
</code></pre> 
<h6><a id="15_filterlist_189"></a>15. filter()用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，可用list()来转换为列表。</h6> 
<p>注意： filter()接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回True或 False，最后将返回 True 的元素放到新列表中。</p> 
<pre><code>res = filter(lambda n:n&gt;5,range(10))   # 过滤掉0-9中不符合n&gt;5的数据
for i in res:                          # 循环打印符合n&gt;5的数据
    print(i)  
    
# 5
# 6
# 7
# 8
# 9
</code></pre> 
<h6><a id="16_format_______format__211"></a>16. format()是一种格式化字符串的函数 ，基本语法是通过 {} 和 : 来代替以前的 % 。format 函数可以接受不限个参数，位置可以不按顺序。</h6> 
<pre><code># 位置映射

print( "{}{}".format('a','1') )
# a1

print('name:{n},url:{u}'.format(n='alex',u='www.xxxxx.com'))
# name:alex,url:www.xxxxx.com
</code></pre> 
<pre><code># 元素访问

print( "{0[0]},{0[1]}".format(('baidu','com')) )                # 按顺序
# baidu,com

print( "{0[2]},{0[0]},{0[1]}".format(('baidu','com','www')) )   # 不按顺序
# www,baidu,com
</code></pre> 
<h6><a id="17_float__241"></a>17. float() 函数用于将整数和字符串转换成浮点数。</h6> 
<pre><code>print(float(1))
# 1.0

print(float(0.1))
# 0.1

print(float('123'))
# 123.0
</code></pre> 
<h6><a id="18_frozenset__260"></a>18. frozenset() 返回一个冻结的集合（一个无序的不重复元素序列），冻结后集合不能再添加或删除任何元素。</h6> 
<pre><code>1 a = frozenset(range(10))             # 先创建一个冻结集合
2 print(a)                 
3 # frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9})
4 
5 del a[0]                             # 试图删除冻结集合a中的元素，报错
6 # TypeError: 'frozenset' object doesn't support item deletion
</code></pre> 
<pre><code>1 b = frozenset("happy")               # 将字符串转换成一个集合
2 print(b)
3 # frozenset({'a', 'h', 'p', 'y'})    # 无序不重复
1 c = frozenset()                      # 创建一个空集合
2 print(c)
3 # frozenset()                        # 如果不提供任何参数，默认会生成空集合
</code></pre> 
<h6><a id="19_globals__286"></a>19. globals() 函数会以字典格式返回当前位置的全部全局变量。</h6> 
<pre><code>print(globals())     # globals 函数返回一个全局变量的字典，包括所有导入的变量。

#  {'__file__': 'C:/Users/Administrator/PycharmProjects/test/day4/内置函数-globals().py', '__spec__': None, '__doc__': None, '__package__': None, 'a': 'append', '__cached__': None, '__loader__': &lt;_frozen_importlib_external.SourceFileLoader object at 0x0000000000666B00&gt;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__name__': '__main__'}
</code></pre> 
<h6><a id="20_hasattr__True_False_296"></a>20. hasattr() 函数用于判断对象是否包含对应的属性。如果对象有该属性返回 True，否则返回 False。</h6> 
<pre><code>1 class t:
2     a = 1
3     b = 2
4     c = 3
5 
6 p = t()
7 print(hasattr(p,'a'))    # True
8 print(hasattr(p,'b'))    # True
9 print(hasattr(p,'x'))    # False
</code></pre> 
<h6><a id="21_hash__listsetdictionary_316"></a>21. hash() 用于获取一个对象（数字或者字符串等）的哈希值。不能直接应用于 list、set、dictionary。</h6> 
<p>注意：在 hash() 对对象使用时，所得的结果不仅和对象的内容有关，还和对象的 id()，也就是内存地址有关。</p> 
<pre><code>print(hash(1))                  # 1
print(hash(20000))              # 20000
print(hash('123'))              # -6436280630278763230
print(hash('ab12'))             # 5468785079765213470
print(hash('ab12'))             # 5468785079765213470
</code></pre> 
<h6><a id="22_help__330"></a>22. help() 函数用于查看函数或模块用途的详细说明。</h6> 
<pre><code>help('sys')             # 查看 sys 模块的帮助
help('str')             # 查看 str 数据类型的帮助
a = [1,2,3]
help(a)                 # 查看列表 list 帮助信息
help(a.append)          # 显示list的append方法的帮助
</code></pre> 
<h6><a id="23_hex_0x_342"></a>23. hex() 函数用于将一个整数转换为十六进制数。返回一个字符串，以0x开头。</h6> 
<pre><code>print(hex(1))        # 0x1

print(hex(-256))     # -0x100
print(type(hex(-256)))    #&lt;class 'str'&gt;
</code></pre> 
<h6><a id="24_id_353"></a>24. id()函数用于获取对象的内存地址。</h6> 
<pre><code>a = "123"                             # 字符串
print(id(a))                          # 13870392

b = [1,2,3]                           # 列表
print(id(b))                          # 7184328

c = {'num1':1,'num2':2,'num3':3}       # 字典
print(id(c))                           # 6923656
</code></pre> 
<h6><a id="25_input__string_Python3x_raw_input__input_input__372"></a>25. input() 函数接受一个标准输入数据，返回为 string 类型。这个函数是最最常用的了。在Python3.x中 raw_input() 和 input() 进行了整合，仅保留了input( )函数。</h6> 
<pre><code>a = '123456'
b = input("username:")

if b == a :            # 如果b的输入数据等于a存储的数据，打印”right“
    print("right")
else:                  # 否则打印”wrong“
    print("wrong")
</code></pre> 
<h6><a id="26_int__390"></a>26. int() 函数用于将一个字符串或数字转换为整型。</h6> 
<pre><code>print(int())                # 不传入参数时，得到结果0
print(int(0.5))             # 去掉小数部分，得到结果0
print(int(3))               # 得到结果3
print(int('0xa',16))        # 十六进制数“0xa”转换成十进制整数，得到结果10
print(int('00010',2))       # 二进制数“00010”转换成十进制整数，得到结果2
</code></pre> 
<h6><a id="27_isinstance__type_402"></a>27. isinstance() 函数来判断一个对象是否是一个已知的类型，返回布尔值。类似 type()。</h6> 
<pre><code>a = 2

print(isinstance(a,int))                   #  True
print(isinstance(a,str))                   #  False
print(isinstance(a,(str,tuple,dict)))      #  False
print(isinstance(a,(str,tuple,int)))       # 是元组其中的一个则返回True
</code></pre> 
<ul><li><strong>isinstance() 与 type() 区别：</strong></li></ul> 
<pre><code>   　　  type() 不会认为子类是一种父类类型，不考虑继承关系。  　　 
　　　　  isinstance() 会认为子类是一种父类类型，考虑继承关系。  　　  
　　　　　如果要判断两个类型是否相同推荐使用 isinstance()。

示例：
</code></pre> 
<pre><code> 1 class A:
 2     pass
 3 
 4 class B(A):
 5     pass
 6 
 7 print(isinstance(A(),A))    # True
 8 print( type(A()) == A )     # True
 9 
10 print(isinstance(B(),A))    # True
11 print( type(B()) == A )     # False   --type()不考虑继承关系
</code></pre> 
<h6><a id="28_issubclassclassclassinfoTrueFalse_447"></a>28. issubclass()用于判断参数class是否是类型参数classinfo的子类，是则返回True，否则返回False。</h6> 
<p>语法：issubclass(class,classinfo)。</p> 
<pre><code>1 class a:
2     pass
3 class b(a):     # b继承了a，即b是a的子类
4     pass
5 
6 print(issubclass(a,b))    # 判断 a 是 b 的子类？
7 # False
8 print(issubclass(b,a))    # 判断 b 是 a 的子类？
9 # True
</code></pre> 
<h6><a id="29_iter_listtupleiternextiter___iter____469"></a>29. iter() 函数用来生成迭代器。list、tuple等都是可迭代对象，我们可以通过iter()函数获取这些可迭代对象的迭代器，然后可以对获取到的迭代器不断用next()函数来获取下条数据。iter()函数实际上就是调了可迭代对象的 <strong>iter</strong> 方法。</h6> 
<p># 注意：当已经迭代完最后一个数据之后，再次调用next()函数会抛出 StopIteration的异常，来告诉我们所有数据都已迭代完成。</p> 
<pre><code> 1 it = [1,2,3]
 2 it_list = iter(it)
 3 
 4 print(next(it_list))
 5 # 1
 6 print(next(it_list))
 7 # 2
 8 print(next(it_list))
 9 # 3
10 print(next(it_list))
11 # StopIteration
</code></pre> 
<h6><a id="30_len__493"></a>30. len() 方法返回对象（字符、列表、元组等）长度或元素个数。</h6> 
<pre><code># len()方法返回对象（字符、列表、元组等）长度或元素个数。
print(len('1234'))              # 字符串，返回字符长度4
print(len(['1234','asd',1]))    # 列表，返回元素个数3
print(len((1,2,3,4,50)))        # 元组，返回元素个数5

print(len(12))                  # 注意：整数类型不适用，否则报错
# TypeError: object of type 'int' has no len()
</code></pre> 
<h6><a id="31_list__511"></a>31. list() 方法用于将元组转换为列表。</h6> 
<p>注：元组与列表是非常类似的，区别在于元组的元素值不能修改，元组是放在括号中，列表是放于方括号中。</p> 
<pre><code>print( list((1,2,3)))           # [1, 2, 3]
</code></pre> 
<h6><a id="32_mapflistflistlist_521"></a>32. map()接收函数f和list，并通过把函数f依次作用在list的每个元素上，得到一个新的list并返回。</h6> 
<pre><code> 1 res = map(lambda n: n*2,[0,1,2,3,4,5])    # 使用 lambda 匿名函数
 2 for i in res:
 3     print(i)
 4 
 5 # 返回以下数据：
 6 # 0
 7 # 2
 8 # 4
 9 # 6
10 # 8
11 # 10
</code></pre> 
<pre><code> 1 # 提供了两个列表，对相同位置的列表数据进行相加
 2 
 3 a = map(lambda x,y : x+y,[1,2,3,4,5],[2,4,6,8,10])
 4 for i in a:
 5     print(i)
 6 
 7 # 返回以下数据：
 8 # 3
 9 # 6
10 # 9
11 # 12
12 # 15
</code></pre> 
<h6><a id="33_max_560"></a>33. max()函数返回给定参数的最大值，参数可以为序列。</h6> 
<pre><code>print("max(10,20,30):" , max(10,20,30) )
# max(10,20,30): 30

print("max(10,-2,3.4):" , max(10,-2,3.4) )
# max(10,-2,3.4): 10

print("max({'b':2,'a':1,'c':0}):" , max({'b':2,'a':1,'c':0}) )   # 字典，默认按key排序
# max({'b':2,'a':1,'c':0}): c
</code></pre> 
<h6><a id="34_min_577"></a>34. min()函数返回给定参数的最小值，参数可以为序列。</h6> 
<pre><code>print("min(10,20,30):" , min(10,20,30) )
# min(10,20,30): 10

print("min(10,-2,3.4):" , min(10,-2,3.4) )
# min(10,-2,3.4): -2

print("min({'b':2,'a':1,'c':0}):" , min({'b':2,'a':1,'c':0}) )   # 字典，默认按key排序
# min({'b':2,'a':1,'c':0}): a
</code></pre> 
<h6><a id="35_next__596"></a>35. next() 返回迭代器的下一个项目。</h6> 
<pre><code> 1 # 首先获得Iterator对象:
 2 it = iter([1,2,3,4,5])
 3 
 4 # 循环:
 5 while True:
 6     try:
 7         # 获得下一个值:
 8         x = next(it)
 9         print(x)
10     except StopIteration:
11         break
12     # 遇到StopIteration就退出循环
</code></pre> 
<h6><a id="36_oct__619"></a>36. oct() 函数将一个整数转换成八进制字符串。</h6> 
<pre><code>print( oct(10) )          # 0o12
print( oct(255) )         # 0o377
print( oct(-6655) )       # -0o14777
</code></pre> 
<h6><a id="37_open__file__629"></a>37. open() 函数用于打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写。</h6> 
<pre><code>f = open("test1.txt","w",encoding="utf-8")    # 创建一个file
print(f.write("abc"))

f = open("test1.txt","r",encoding="utf-8")    # 读取文件数据
print(f.read())
</code></pre> 
<h6><a id="38_ordchr1ASCIIUnicode_Unicode__TypeError__641"></a>38. ord()函数是chr()的配对函数，它以一个字符（长度为1的字符串）作为参数，返回对应的ASCII数值，或者Unicode数值，如果所给的 Unicode 字符超出了定义范围，则会引发一个 TypeError 的异常。</h6> 
<pre><code># 把字符 b（长度为1的字符串）作为参数在ascii码中对应的字符打印出来

print( ord('b') )    # 返回：98
print( ord('%') )    # 返回：37
</code></pre> 
<h6><a id="39_powxy_652"></a>39. pow()函数返回x的y次方的值。</h6> 
<p>注意：pow()通过内置的方法直接调用，内置方法会把参数作为整型，而 math 模块则会把参数转换为 float。</p> 
<pre><code># 通过内置的方法直接调用

print( pow(2,2) )          #  2的二次方
# 4
print( pow(2,-2) )         #  2的负二次方
# 0.5
</code></pre> 
<pre><code>1 # 导入math模块
2 
3 import math
4 
5 print(math.pow(3,2))   # 3的负二次方
6 # 9.0
</code></pre> 
<h6><a id="40_printprint_Python3xPython2x_682"></a>40. print()用于打印输出，最常见的一个函数。print 在Python3.x是一个函数，但在Python2.x版本只是一个关键字。</h6> 
<pre><code>print( abs(-45) )           # 45
print("Hello World!")       # Hello World!
print([1,2,3])              # [1, 2, 3]
</code></pre> 
<h6><a id="41_range__for_rangestart_stop_step_692"></a>41. range() 函数可创建一个整数列表，一般用在 for 循环中。语法：range(start, stop[, step])</h6> 
<pre><code>for i in range(10):
    print(i)            # 依次打印数字0-9

for a in range(0,10,2):     # 步长为2
    print(a)            # 打印0,2,4,6,8

for b in range(10, 0, -2):  # 步长为-2
    print(b)            # 打印10,8,6,4,2
</code></pre> 
<h6><a id="42_reduce_Python3_reducefunctoolsfunctools_711"></a>42. reduce() 函数会对参数序列中元素进行累积。在Python3 ，reduce()被放置在functools模块里，如果想要使用它，需要先引入functools模块。</h6> 
<pre><code>import functools

a = functools.reduce(lambda x,y:x+y,[1,2,3])
print(a)           # 6 ， 即从1加到3

b = functools.reduce(lambda x,y:x+y,range(10))
print(b)           # 45 ， 即从0加到9
</code></pre> 
<h6><a id="43_repr__string__729"></a>43. repr() 函数将对象转化为供解释器读取的形式。返回一个对象的 string 格式。</h6> 
<pre><code>r = repr((1,2,3))
print( r )              # (1, 2, 3)
print( type(r) )        #  &lt;class 'str'&gt;

dict = repr({'a':1,'b':2,'c':3})
print( dict )    # {'c': 3, 'a': 1, 'b': 2}
print( type(dict) )    # &lt;class 'str'&gt;
</code></pre> 
<h6><a id="44_reversed__reversedseq_tuple_string_list__range_745"></a>44. reversed() 函数返回一个反转的迭代器。 reversed(seq)要转换的序列，可以是 tuple, string, list 或 range。</h6> 
<pre><code>rev = reversed( [1,2,3,4,5] )       # 列表
print(list(rev))
# [5, 4, 3, 2, 1]

rev1 = reversed( "school" )         # 元组
print(tuple(rev1))
# ('l', 'o', 'o', 'h', 'c', 's')

rev2 = reversed(range(10))          # range
print(list(rev2))
# [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
</code></pre> 
<h6><a id="45_round_xround_765"></a>45. round() 方法返回浮点数x的四舍五入值。（除非对精确度没什么要求，否则尽量避开用round()函数）</h6> 
<pre><code>print( round(4.3))         # 只有一个参数时，默认保留到整数
# 4

print( round(2.678,2))     #  保留2位小数
#  2.68

print( round(5/3,3))     #  运算表达式并保留3位小数
#  1.667
</code></pre> 
<h6><a id="46_set__784"></a>46. set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。</h6> 
<pre><code>1 a = set('school')
2 print(a)            # 重复的被删除，得到结果：{'o', 'c', 's', 'l', 'h'}
</code></pre> 
<pre><code>1 b = set([1,2,3,4,5])
2 c = set([2,4,6,8,10])
3 
4 print(b &amp; c)     # 交集，得到结果为{2, 4}
5 print(b | c)     # 并集，得到结果为{1, 2, 3, 4, 5, 6, 8, 10}
6 print(b - c)     # 差集，得到结果为{1, 3, 5}
</code></pre> 
<h6><a id="47_slice__804"></a>47. slice() 函数实现切片对象，主要用在切片操作函数里的参数传递。</h6> 
<pre><code>a = slice("school")
print(a)            # slice(None, 'school', None)
</code></pre> 
<h6><a id="48_sorted__813"></a>48. sorted() 函数对所有可迭代的对象进行排序（默认升序）操作。</h6> 
<pre><code># 对列表进行排序
print(sorted([1,2,5,30,4,22]))    # [1, 2, 4, 5, 22, 30]

# 对字典进行排序
dict = {23:42,1:0,98:46,47:-28}
print( sorted(dict) )                     # 只对key排序
# [1, 23, 47, 98]

print( sorted(dict.items()) )             # 默认按key进行排序
# [(1, 0), (23, 42), (47, -28), (98, 46)]

print( sorted(dict.items(),key=lambda x:x[1]) )      # 用匿名函数实现按value进行排序
# [(47, -28), (1, 0), (23, 42), (98, 46)]
</code></pre> 
<pre><code># 利用key进行倒序排序
test1 = [1,2,5,30,4,22]
r_list = sorted(test1,key=lambda x:x*-1)
print(r_list)                     # [30, 22, 5, 4, 2, 1]


# 要进行反向排序，也可以通过传入第三个参数 reverse=True：
test2 = [1,2,5,30,4,22]
print(sorted(test2,reverse=True))    # [30, 22, 5, 4, 2, 1]
</code></pre> 
<h6><a id="49_str_string_851"></a>49. str() 函数将对象转化为string格式。</h6> 
<pre><code>1 a =  str((1,2,3))
2 print(a)            # 打印a，得到结果(1, 2, 3)
3 print(type(a))      # 打印a的类型，得到结果 &lt;class 'str'&gt;
</code></pre> 
<h6><a id="50_sum_861"></a>50. sum()函数对参数进行求和计算。</h6> 
<pre><code>print( sum([1,2,3]) )        #  6
print( sum([1,2,3],4) )      #  列表计算总和后再加4，得到结果10
print( sum( (1,2,3),4 ) )    #  元组计算总和后再加4，得到结果10
</code></pre> 
<h6><a id="51_tuplemap_871"></a>51. tuple()函数将列表、字符串、字典。集合、map对象等其他类型可迭代对象转换为元组。</h6> 
<p># 注：元组与列表是非常类似的，区别在于元组的元素值不能修改，元组是放在括号中，列表是放于方括号中。</p> 
<pre><code>print( tuple([1, 2, 3]))     # (1,2,3)
</code></pre> 
<h6><a id="52_type__881"></a>52. type() 函数如果你只有第一个参数则返回对象的类型，三个参数返回新的类型对象。</h6> 
<pre><code>print(type(1))                   # &lt;class 'int'&gt;
print(type("123"))               # &lt;class 'str'&gt;
print(type([123,456]))           # &lt;class 'list'&gt;
print(type( (123,456) ) )        # &lt;class 'tuple'&gt;
print(type({'a':1,'b':2}) )      # &lt;class 'dict'&gt;
</code></pre> 
<h6><a id="53_zip__list____893"></a>53. zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。可以使用 list() 转换来输出列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同。利用 * 号操作符，可以将元组解压为列表。</h6> 
<pre><code> 1 a = [1,2,3]
 2 b = [4,5,6]
 3 c = [7,8,9,10]
 4 
 5 for i in zip(a,b):
 6     print(i)
 7 
 8 # 返回结果：
 9 # (1, 4)
10 # (2, 5)
11 # (3, 6)
12 
13 print(list(zip(a,b)))       # list() 转换为列表
14 # [(1, 4), (2, 5), (3, 6)]
15 
16 print(list(zip(b,c)))       # 元素个数与最短的列表一致
17 # [(4, 7), (5, 8), (6, 9)]
18 
19 a1,a2 = zip(*zip(a,b))      #  用zip(*)解压
20 print(list(a1))         # [1, 2, 3]
21 print(list(a2))         # [4, 5, 6]
</code></pre> 
<h6><a id="54__import______import____925"></a>54_<em>import_</em>() 函数用于动态加载类和函数。如果一个模块经常变化就可以使用 <strong>import</strong>() 来动态载入。</h6> 
<pre><code>__import__('decorator')

# 返回结果如下：
# in the bar
# the func run time is 3.000171661376953
# 首先获得Iterator对象:
it = iter([1,2,3,4,5])
# 循环:
while True:
    try:
        # 获得下一个值:
x = next(it)
        print(x)
    except StopIteration:
        break
# 遇到StopIteration就退出循环
</code></pre> 
<h6><a id="55lower__946"></a>55.lower ()方法转换字符串中所有大写字符为小写</h6> 
<pre><code>str = "THIS IS STRING EXAMPLE....WOW!!!"

print(str.lower())

以上实例输出结果如下：

this is string example....wow!!!
</code></pre> 
<h6><a id="56upper_958"></a>56.upper()将字符串中小写的字母转为大写字母</h6> 
<pre><code>str = "this is string example....wow!!!"

print("str.upper() : ", str.upper())
以上实例输出结果如下：

str.upper() :  THIS IS STRING EXAMPLE....WOW!!!
</code></pre> 
<h6><a id="57capitalize_969"></a>57.capitalize()字符串中字母首字母大写其余小写</h6> 
<pre><code>c = "hello"
c1 = c.capitalize()
print(c1)
以上实例输出结果如下：

Hello
</code></pre> 
<h6><a id="58title_980"></a>58.title()字符串中字母每个单词的首字母大写其余小写</h6> 
<pre><code>d = "hello world"
d1 = d.title()
print(d1)
以上实例输出结果如下：

Hello World
</code></pre> 
<h6><a id="59remove_991"></a>59.remove()删除首次出现的制定元素</h6> 
<pre><code>&gt;&gt;&gt; alis=[1,2,1,1,3,1,1,1]
&gt;&gt;&gt; for i in range(alis.count(1)):
	alis.remove(1)
	print(alis)

	
[2, 1, 1, 3, 1, 1, 1]
[2, 1, 3, 1, 1, 1]
[2, 3, 1, 1, 1]
[2, 3, 1, 1]
[2, 3, 1]
[2, 3]
&gt;&gt;&gt; 
</code></pre> 
<h6><a id="60count_1011"></a>60.count()返回出现的次数</h6> 
<pre><code>返回数值 9 在列表中出现的次数：

points = [1, 4, 2, 9, 7, 8, 9, 3, 1]

x = points.count(9)
</code></pre> 
<h6><a id="61sort_1021"></a>61.sort()可以进行原地排序，没有返回值，或者说返回值为空值</h6> 
<pre><code> 1.原址排序

1）列表有自己的sort方法，其对列表进行原址排序，既然是原址排序，那显然元组不可能拥有这种方法，因为元组是不可修改的。

x  =  [ 4 ,  6 ,  2 ,  1 ,  7 ,  9 ]
x.sort()
print  x  # [1, 2, 4, 6, 7, 9]
2.副本排序

1）[:]分片方法

x  = [ 4 ,  6 ,  2 ,  1 ,  7 ,  9 ]
y  =  x[ : ]
y.sort()
print  y  #[1, 2, 4, 6, 7, 9]
print  x  #[4, 6, 2, 1, 7, 9]
注意：y = x[:] 通过分片操作将列表x的元素全部拷贝给y，如果简单的把x赋值给y：y = x，y和x还是指向同一个列表，并没有产生新的副本。

2）sorted方法,与sort（）方法不同，返回一个新的列表，不对原来的列表进行任何修改

sorted返回一个有序的副本，并且类型总是列表，如下：

x  = [ 4 ,  6 ,  2 ,  1 ,  7 ,  9 ]
y  =  sorted (x)
print  y  #[1, 2, 4, 6, 7, 9]
print  x  #[4, 6, 2, 1, 7, 9] 
print  sorted ( 'Python' )  #['P', 'h', 'n', 'o', 't', 'y']
</code></pre> 
<h6><a id="62strip_1053"></a>62.strip()函数</h6> 
<pre><code>声明：s为字符串，rm为要删除的字符序列

s.strip(rm)        删除s字符串中开头、结尾处，位于 rm删除序列的字符

s.lstrip(rm)       删除s字符串中开头处，位于 rm删除序列的字符

s.rstrip(rm)      删除s字符串中结尾处，位于 rm删除序列的字符

注意：

1. 当rm为空时，默认删除空白符（包括'\n', '\r',  '\t',  ' ')

2.这里的rm删除序列是只要边（开头或结尾）上的字符在删除序列内，就删除掉。

例如 ：
&gt;&gt;&gt;a='123abc'
&gt;&gt;&gt;a.strip('21')
'3abc'
&gt;&gt;&gt;a.strip('12')
'3abc'


</code></pre> 
<h6><a id="63randint_1080"></a>63.randint()随机生成树</h6> 
<ul><li><strong>在python中的random.randint(a,b)用于生成一个指定范围内的整数。其中参数a是下限，参数b是上限bai，生成的随机数n: a &lt;= n &lt;= b。</strong></li></ul> 
<p>print random.randint(12, 20) #生成的随机数n: 12 &lt;= n &lt;= 20<br> print random.randint(20, 20) #结果永远是20<br> #print random.randint(20, 10) #该语句是错误的。下限必须小于上限</p> 
<p>所以说，random.randint(1,100)随机数中使包括1和100的。</p> 
<h6><a id="64fromkeysNone_1090"></a>64.fromkeys()方法用于创建一个新的字典，并以可迭代对象中的元素分别作为字典中的键，且所有键对应同一个值，默认为None。</h6> 
<pre><code>/* 
fromkeys() 方法语法： dict.fromkeys(iterable[,value=None]) 
iterable-- 用于创建新的字典的键的可迭代对象（字符串、列表、元祖、字典）。
value -- 可选参数, 字典所有键对应同一个值的初始值，默认为None。
*/

iterable1 = "12" # 字符串
iterable2 = [1,2] # 列表
iterable3 = (1,2) # 元祖
iterable4 = {1:'one',2:'two'} # 字典
 
v1 = dict.fromkeys(iterable1,'字符串')
v2 = dict.fromkeys(iterable2,'列表')
v3 = dict.fromkeys(iterable3,'元祖')
v4 = dict.fromkeys(iterable4,'字典')
v5 = dict.fromkeys(iterable4) #value默认为None
 
print(v1)
print(v2)
print(v3)
print(v4)
print(v5)
/*************************************/
以上实例输出结果为：

{'1': '字符串', '2': '字符串'}
{1: '列表', 2: '列表'}
{1: '元祖', 2: '元祖'}
{1: '字典', 2: '字典'}
{1: None, 2: None}
</code></pre> 
<h6><a id="65_values_list_1125"></a>65. values() 方法以列表形式（并非直接的列表，若要返回列表值还需调用list函数）返回字典中的所有值。</h6> 
<pre><code>D = {'Sex': 'female', 'Age': 7, 'Name': 'Zara'}
 
print ("字典所有值为 : ",  D.values())
print ("转换为列表 : ",  list(D.values()))

以上实例输出结果为：
字典所有值为 :  D_values(['Zara', 'female', 7])
转换为列表 :  ['Zara', 'female', 7]

//***************************
alist=input('请输入字符串')
d=dict()
for i in alist:
    d[i]=alist.count(i)
print(d)
max_value=max(d.values())
for k,v in d.items():
    if v==max_value:
        print(k)

</code></pre> 
<h6><a id="66items_items__key__value__1150"></a>66.items() 方法的遍历：items() 方法把字典中每对 key 和 value 组成一个元组，并把这些元组放在列表中返回。</h6> 
<pre><code>d = {'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt; d.items()
dict_items([('one', 1), ('two', 2), ('three', 3)])
&gt;&gt;&gt; type(d.items())
&lt;class 'dict_items'&gt;
 
&gt;&gt;&gt; for key,value in d.items():#当两个参数时
    print(key + ':' + str(value))
one:1
two:2
three:3
 
&gt;&gt;&gt; for i in d.items():#当参数只有一个时
    print(i)
('one', 1)
('two', 2)
('three', 3)
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a50130a276995943f0ea4c4e99aab477/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">安卓10蓝牙问题_安卓系统蓝牙服务com.android.bluetooth的使能</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d1a815bb250dcd63112425f9c08bae7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LLDP邻居信息表相关OID</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>