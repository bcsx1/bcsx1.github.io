<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OpenCV 配置选项参考文档 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OpenCV 配置选项参考文档" />
<meta property="og:description" content="OpenCV 配置选项参考文档 介绍通用选项和附加模块一起构建调试（Debug）构建静态构建生成 pkg-config 信息构建测试、示例和应用只构建部分模块下载的依赖项CPU 优化级别性能分析、代码覆盖率、清理、强化、size optimization 功能特性与依赖项相关选项命名规范异构计算对 CUDA 的支持对 OpenCL 的支持 图像的读写（imgcodecs 模块）内置格式对 PNG, JPEG, TIFF, WEBP 的支持GDAL 集成GDCM 集成 视频的读写（videoio 模块）Video4LinuxFFmpegGStreamerMicrosoft Media FoundationDirectShowAVFoundation其它后端videoio plugins 并行处理多线程插件 GUI 后端（highgui 模块）OpenGLhighgui 插件 深度学习神经网络推断后端和选项 （dnn 模块） 安装布局安装根目录组件和位置 其他功能自动化构建Contrib 模块 尚未写入文档的其它选项 本文参考官方文档 OpenCV configuration options reference，更新的内容请参考此文档。
由于博主水平有限，且刚接触 OpenCV，翻译有不通顺、错误的地方，请大佬们指正。本文会龟速长期纠正更新。
介绍 💡 NOTE: 本文假设您已阅读 OpenCV installation overview 教程或具有 CMake 的操作经验。
可以通过几种不同的方式设置配置选项：
命令行：cmake -Doption=value ...初始缓存文件： cmake -C my_options.txt ...通过图形用户界面（GUI，cmake-gui）进行交互操作 本文中将使用常规命令行。
大部分选项都可以在 OpenCV 的根 CMake 脚本中找到：opencv/CMakeLists.txt。 一些选项可能在特定的模块中被定义。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/74e8ed56d73ce905d17c98cc3f2d3e72/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-02T20:53:53+08:00" />
<meta property="article:modified_time" content="2022-02-02T20:53:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OpenCV 配置选项参考文档</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>OpenCV 配置选项参考文档</h4> 
 <ul><li><ul><li><a href="#_6" rel="nofollow">介绍</a></li><li><a href="#_37" rel="nofollow">通用选项</a></li><li><ul><li><a href="#_39" rel="nofollow">和附加模块一起构建</a></li><li><a href="#Debug_57" rel="nofollow">调试（Debug）构建</a></li><li><a href="#_91" rel="nofollow">静态构建</a></li><li><a href="#_pkgconfig__106" rel="nofollow">生成 pkg-config 信息</a></li><li><a href="#_117" rel="nofollow">构建测试、示例和应用</a></li><li><a href="#_131" rel="nofollow">只构建部分模块</a></li><li><a href="#_152" rel="nofollow">下载的依赖项</a></li><li><a href="#CPU__172" rel="nofollow">CPU 优化级别</a></li><li><a href="#size_optimization_205" rel="nofollow">性能分析、代码覆盖率、清理、强化、size optimization</a></li></ul> 
   </li><li><a href="#_226" rel="nofollow">功能特性与依赖项相关</a></li><li><ul><li><a href="#_233" rel="nofollow">选项命名规范</a></li><li><a href="#_244" rel="nofollow">异构计算</a></li><li><ul><li><a href="#_CUDA__245" rel="nofollow">对 CUDA 的支持</a></li><li><a href="#_OpenCL__260" rel="nofollow">对 OpenCL 的支持</a></li></ul> 
    </li><li><a href="#imgcodecs__271" rel="nofollow">图像的读写（imgcodecs 模块）</a></li><li><ul><li><a href="#_273" rel="nofollow">内置格式</a></li><li><a href="#_PNG_JPEG_TIFF_WEBP__282" rel="nofollow">对 PNG, JPEG, TIFF, WEBP 的支持</a></li><li><a href="#GDAL__298" rel="nofollow">GDAL 集成</a></li><li><a href="#GDCM__303" rel="nofollow">GDCM 集成</a></li></ul> 
    </li><li><a href="#videoio__308" rel="nofollow">视频的读写（videoio 模块）</a></li><li><ul><li><a href="#Video4Linux_312" rel="nofollow">Video4Linux</a></li><li><a href="#FFmpeg_317" rel="nofollow">FFmpeg</a></li><li><a href="#GStreamer_331" rel="nofollow">GStreamer</a></li><li><a href="#Microsoft_Media_Foundation_338" rel="nofollow">Microsoft Media Foundation</a></li><li><a href="#DirectShow_346" rel="nofollow">DirectShow</a></li><li><a href="#AVFoundation_351" rel="nofollow">AVFoundation</a></li><li><a href="#_356" rel="nofollow">其它后端</a></li><li><a href="#videoio_plugins_373" rel="nofollow">videoio plugins</a></li></ul> 
    </li><li><a href="#_383" rel="nofollow">并行处理</a></li><li><ul><li><a href="#_398" rel="nofollow">多线程插件</a></li></ul> 
    </li><li><a href="#GUI_highgui__408" rel="nofollow">GUI 后端（highgui 模块）</a></li><li><ul><li><a href="#OpenGL_421" rel="nofollow">OpenGL</a></li><li><a href="#highgui__426" rel="nofollow">highgui 插件</a></li></ul> 
    </li><li><a href="#_dnn__436" rel="nofollow">深度学习神经网络推断后端和选项 （dnn 模块）</a></li></ul> 
   </li><li><a href="#_454" rel="nofollow">安装布局</a></li><li><ul><li><a href="#_455" rel="nofollow">安装根目录</a></li><li><a href="#_482" rel="nofollow">组件和位置</a></li></ul> 
   </li><li><a href="#_522" rel="nofollow">其他功能</a></li><li><ul><li><a href="#_540" rel="nofollow">自动化构建</a></li><li><a href="#Contrib__552" rel="nofollow">Contrib 模块</a></li></ul> 
   </li><li><a href="#_561" rel="nofollow">尚未写入文档的其它选项</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p>本文参考官方文档 <a href="https://docs.opencv.org/4.x/db/d05/tutorial_config_reference.html" rel="nofollow">OpenCV configuration options reference</a>，更新的内容请参考此文档。</p> 
<p>由于博主水平有限，且刚接触 OpenCV，翻译有不通顺、错误的地方，请大佬们指正。本文会<s>龟速</s>长期纠正更新。</p> 
<h3><a id="_6"></a>介绍</h3> 
<blockquote> 
 <p>💡 <strong>NOTE</strong>: 本文假设您已阅读 <a href="https://docs.opencv.org/4.x/d0/d3d/tutorial_general_install.html" rel="nofollow">OpenCV installation overview</a> 教程或具有 CMake 的操作经验。</p> 
</blockquote> 
<p>可以通过几种不同的方式设置配置选项：</p> 
<ul><li>命令行：<code>cmake -Doption=value ...</code></li><li>初始缓存文件： <code>cmake -C my_options.txt ...</code></li><li>通过图形用户界面（GUI，<em>cmake-gui</em>）进行交互操作</li></ul> 
<p>本文中将使用常规命令行。</p> 
<p>大部分选项都可以在 OpenCV 的根 CMake 脚本中找到：<code>opencv/CMakeLists.txt</code>。 一些选项可能在特定的模块中被定义。</p> 
<p>可以使用 CMake 工具打印所有可用选项：</p> 
<pre><code class="prism language-Bash"># initial configuration
cmake ../opencv
# print all options
cmake -L
# print all options with help message
cmake -LH
# print all options including advanced
cmake -LA
</code></pre> 
<p>最流行最有用的选项是以 <code>WITH_</code>, <code>ENABLE_</code>, <code>BUILD_</code>, <code>OPENCV_</code> 为前缀的那些。</p> 
<p>选项的默认值因平台和其他选项值而异。</p> 
<h3><a id="_37"></a>通用选项</h3> 
<h4><a id="_39"></a>和附加模块一起构建</h4> 
<ul><li><code>OPENCV_EXTRA_MODULES_PATH</code> 选项的值应为一个用分号分隔的目录列表，这些目录包含你要一起构建的那些附加模块。模块目录必须有兼容的布局和 CMakeLists.txt，简要说明可以在 <a href="https://github.com/opencv/opencv/wiki/Coding_Style_Guide">Coding Style Guide</a> 中找到。</li></ul> 
<p>示例：</p> 
<pre><code class="prism language-Bash"># build with all modules in opencv_contrib
cmake -DOPENCV_EXTRA_MODULES_PATH=../opencv_contrib/modules ../opencv
# build with one of opencv_contrib modules
cmake -DOPENCV_EXTRA_MODULES_PATH=../opencv_contrib/modules/bgsegm ../opencv
# build with two custom modules (semicolon must be escaped in bash)
cmake -DOPENCV_EXTRA_MODULES_PATH=../my_mod1\;../my_mod2 ../opencv
</code></pre> 
<blockquote> 
 <p>💡 <strong>NOTE</strong>: 仅支持 0 级和 1 级深度模块位置，下面的命令会引发错误：<br> <code>cmake -DOPENCV_EXTRA_MODULES_PATH=../opencv_contrib ../opencv</code></p> 
</blockquote> 
<h4><a id="Debug_57"></a>调试（Debug）构建</h4> 
<p><code>CMAKE_BUILD_TYPE</code> 选项可用于启用调试构建；生成的二进制文件将包含调试符号，并且大多数编译器优化将被关闭。</p> 
<p>要在发布（Release）版本中启用调试符号，请开启 <code>BUILD_WITH_DEBUG_INFO</code> 选项。</p> 
<p>在某些平台（操作系统）例如 Linux 上，必须在配置阶段设置构建类型（BUILD_TYPE）：</p> 
<pre><code class="prism language-Bash">cmake -DCMAKE_BUILD_TYPE=Debug ../opencv
cmake --build .
</code></pre> 
<p>在其他平台上，可以在同一构建目录中生成不同类型的构建（例如 Visual Studio、XCode）：</p> 
<pre><code class="prism language-PowerShell">cmake &lt;options&gt; ../opencv
cmake --build . --config Debug
</code></pre> 
<p>如果你使用 GNU libstdc++（GCC 的默认值），可以打开 <code>ENABLE_GNU_STL_DEBUG</code> 选项，然后 C++ 库可以在调试模式下使用，例如:访问 vector 元素时将检查索引边界。</p> 
<p>可以使用 <code>CV_DISABLE_OPTIMIZATION</code> 选项禁用许多优化：</p> 
<ul><li>一些第三方库（例如 IPP、Lapack、Eigen）</li><li>Explicit vectorized implementation (universal intrinsics, raw intrinsics, etc.)</li><li>调度优化</li><li>显式循环展开</li></ul> 
<blockquote> 
 <p>也可以参考：</p> 
 <ul><li><a href="https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html" rel="nofollow">CMake variable: CMAKE_BUILD_TYPE</a></li><li><a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_macros.html" rel="nofollow">GNU libstdc++ manual: using macros</a></li><li><a href="https://github.com/opencv/opencv/wiki/CPU-optimizations-build-options">OpenCV wiki: CPU optimizations build options</a></li></ul> 
</blockquote> 
<h4><a id="_91"></a>静态构建</h4> 
<p><code>BUILD_SHARED_LIBS</code> 选项控制是生成动态库（.dll、.so、.dylib）还是静态库（.a、.lib）。 该选项的默认值取决于目标平台，在大多数情况下是 ON（生成静态库）。</p> 
<p>示例：</p> 
<pre><code class="prism language-Bash">cmake -DBUILD_SHARED_LIBS=OFF ../opencv
</code></pre> 
<blockquote> 
 <p>也可以参考：<a href="https://en.wikipedia.org/wiki/Static_library" rel="nofollow">Wikipedia: Static library</a></p> 
</blockquote> 
<p><code>ENABLE_PIC</code> 设置 <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_POSITION_INDEPENDENT_CODE.html" rel="nofollow">CMAKE_POSITION_INDEPENDENT_CODE</a> 选项。 它启用或禁用“位置无关代码（PIC）”的生成。 构建动态库或打算链接到动态库的静态库时，必须启用此选项。 默认值为 <code>ON</code>。</p> 
<blockquote> 
 <p>也可以参考：<a href="https://en.wikipedia.org/wiki/Position-independent_code" rel="nofollow">Wikipedia: Position-independent_code</a></p> 
</blockquote> 
<h4><a id="_pkgconfig__106"></a>生成 pkg-config 信息</h4> 
<p><code>OPENCV_GENERATE_PKGCONFIG</code> 选项启用带标准 CMake 包的 <code>.pc</code> 文件生成。该文件对于不使用 CMake 进行构建的项目很有用。</p> 
<p>示例：</p> 
<pre><code class="prism language-Bash">cmake -DOPENCV_GENERATE_PKGCONFIG=ON ../opencv
</code></pre> 
<blockquote> 
 <p>💡 <strong>NOTE</strong>: 由于配置过程的复杂性，导致 <code>.pc</code> 文件可能包含不完整的第三方依赖项列表，并且可能在某些配置中不起作用，尤其是对于静态构建。 此功能自 OpenCV 4.x 版本起不再正式支持，默认禁用（disable）。</p> 
</blockquote> 
<h4><a id="_117"></a>构建测试、示例和应用</h4> 
<p>有两种测试：准确性 accuracy (<code>opencv_test_*</code>) 和性能 performance (<code>opencv_perf_*</code>)。默认情况下启用测试和应用，而不构建示例，你需要显式（手动）启用它。</p> 
<p>相应的 CMake 选项：</p> 
<pre><code class="prism language-Bash">cmake \
  -DBUILD_TESTS=ON \
  -DBUILD_PERF_TESTS=ON \
  -DBUILD_EXAMPLES=ON \
  -DBUILD_opencv_apps=ON \
  ../opencv
</code></pre> 
<h4><a id="_131"></a>只构建部分模块</h4> 
<p>OpenCV 每个模块都是源代码目录中 module 目录的子目录。 可以使用以下选项来禁用一个模块：</p> 
<pre><code class="prism language-Bash">cmake -DBUILD_opencv_calib3d=OFF ../opencv
</code></pre> 
<p>另一个相反功能的选项只构建指定的模块和它们依赖的所有模块：</p> 
<pre><code class="prism language-Bash">cmake -DBUILD_LIST=calib3d,videoio,ts ../opencv
</code></pre> 
<p>在这个例子中，我们请求了 3 个模块，并且配置脚本已自动确定所有依赖项：</p> 
<pre><code>--   OpenCV modules:
--     To be built:                 calib3d core features2d flann highgui imgcodecs imgproc ts videoio
</code></pre> 
<h4><a id="_152"></a>下载的依赖项</h4> 
<p>配置脚本可以尝试从网络上下载附加的库和文件，如果失败，相应的功能将被关闭。在某些情况下，可能会发生配置错误。默认情况下，所有文件先被下载到 <code>&lt;source&gt;/.cache</code> 目录，然后被解压缩或复制到构建目录。可以通过设置环境变量或配置选项来更改下载缓存的位置：</p> 
<pre><code class="prism language-Bash">export OPENCV_DOWNLOAD_PATH=/tmp/opencv-cache
cmake ../opencv
# or
cmake -DOPENCV_DOWNLOAD_PATH=/tmp/opencv-cache ../opencv
</code></pre> 
<p>如果你通过代理访问网络，在运行 <code>cmake</code> 前需要设置相应的环境变量：</p> 
<pre><code class="prism language-Bash">export http_proxy=&lt;proxy-host&gt;:&lt;port&gt;
export https_proxy=&lt;proxy-host&gt;:&lt;port&gt;
</code></pre> 
<p>下载过程的完整日志可以在构建目录中的 <code>CMakeDownloadLog.txt</code> 文件中找到。此外，对于每个失败的下载，都会在构建目录中的帮助脚本中添加一个命令，例如 <code>download_with_wget.sh</code>。用户可以按原样运行这些脚本，也可以根据自己的需要进行修改。</p> 
<h4><a id="CPU__172"></a>CPU 优化级别</h4> 
<p>默认情况下，在 x86_64 机器上，该库将针对 SSE3 指令集级别进行编译。 此级别可以通过配置选项更改：</p> 
<pre><code class="prism language-Bash">cmake -DCPU_BASELINE=AVX2 ../opencv
</code></pre> 
<blockquote> 
 <p>💡 <strong>NOTE</strong>: 其他平台有自己的指令集级别：ARM 上的 <code>VFPV3</code> 和 <code>NEON</code>，PowerPC 上的 <code>VSX</code>。</p> 
</blockquote> 
<p>一些函数支持分派机制，允许为多个指令集进行编译并在运行时在其中选择一个。 可以在配置期间更改启用的指令集列表：</p> 
<pre><code class="prism language-Bash">cmake -DCPU_DISPATCH=AVX,AVX2 ../opencv
</code></pre> 
<p>要禁用分派机制，此选项值应设置为空：</p> 
<pre><code class="prism language-Bash">cmake -DCPU_DISPATCH= ../opencv
</code></pre> 
<p>可以使用以下选项禁用优化部分代码以便进行故障排除和调试：</p> 
<pre><code class="prism language-Bash"># disable universal intrinsics
cmake -DCV_ENABLE_INTRINSICS=OFF ../opencv
# disable all possible built-in optimizations
cmake -DCV_DISABLE_OPTIMIZATION=ON ../opencv
</code></pre> 
<blockquote> 
 <p>💡 <strong>NOTE</strong>: 关于 CPU 优化选项的更多细节可以在 <a href="https://github.com/opencv/opencv/wiki/CPU-optimizations-build-options">OpenCV wiki: CPU optimizations build options</a> 上找到</p> 
</blockquote> 
<h4><a id="size_optimization_205"></a>性能分析、代码覆盖率、清理、强化、size optimization</h4> 
<blockquote> 
 <p><a href="https://en.wikipedia.org/wiki/Profiling_%28computer_programming%29" rel="nofollow">性能分析（Profiling）</a>、<a href="https://en.wikipedia.org/wiki/Code_coverage" rel="nofollow">代码覆盖率（Coverage）</a>、清理（Sanitize）、<a href="https://en.wikipedia.org/wiki/Hardening_%28computing%29" rel="nofollow">强化（Hardening）</a>、size optimization</p> 
</blockquote> 
<p>以下选项可用于生成带有检测或改进安全性的特殊构建，默认情况下它们都被禁用。</p> 
<table><thead><tr><th>选项</th><th>编译器</th><th>说明</th></tr></thead><tbody><tr><td><code>ENABLE_PROFILING</code></td><td>GCC 或 Clang</td><td>启用编译器和链接器的性能分析选项。</td></tr><tr><td><code>ENABLE_COVERAGE</code></td><td>GCC 或 Clang</td><td>启用对代码覆盖率的支持。</td></tr><tr><td><code>OPENCV_ENABLE_MEMORY_SANITIZER</code></td><td>不适用</td><td>在代码中启用几个 quirks 以协助内存清理器。</td></tr><tr><td><code>ENABLE_BUILD_HARDENING</code></td><td>GCC、Clang、MSVC</td><td>启用减少代码开发可能性的编译器选项。</td></tr><tr><td><code>ENABLE_LTO</code></td><td>GCC、Clang、MSVC</td><td>启用链接时间优化 (LTO)。</td></tr><tr><td><code>ENABLE_THIN_LTO</code></td><td>Clang</td><td>启用 Thin LTO，它将中间代码合并到二进制文件中，允许稍后优化应用程序。</td></tr></tbody></table> 
<blockquote> 
 <p>也可以参考：</p> 
 <ul><li><a href="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html" rel="nofollow">GCC instrumentation</a></li><li><a href="https://en.wikipedia.org/wiki/Hardening_%28computing%29" rel="nofollow">Build hardening</a></li><li><a href="https://en.wikipedia.org/wiki/Interprocedural_optimization" rel="nofollow">Interprocedural optimization</a></li><li><a href="https://gcc.gnu.org/wiki/LinkTimeOptimization" rel="nofollow">Link time optimization</a></li><li><a href="https://clang.llvm.org/docs/ThinLTO.html" rel="nofollow">ThinLTO</a></li></ul> 
</blockquote> 
<h3><a id="_226"></a>功能特性与依赖项相关</h3> 
<p>有许多可选的依赖项和功能特性可以打开或关闭。CMake 有一个特殊选项可以打印所有可用配置参数：</p> 
<pre><code class="prism language-Bash">cmake -LH ../opencv
</code></pre> 
<h4><a id="_233"></a>选项命名规范</h4> 
<p>用于控制依赖库的选项有三种，分别有不同的前缀：</p> 
<ul><li><code>WITH_</code>：是否启用（enable or disable）此依赖</li><li><code>BUILD_</code>：是否启用与 OpenCV 捆绑的第三方库的构建与使用</li><li><code>HAVE_</code>：表明此依赖是否被启用，当自动检测无法使用时，可以用于手动启用一个依赖</li></ul> 
<p>当一个 <code>WITH_</code> 选项被 <strong>启用</strong> 时，有：</p> 
<ul><li>如果 相应的 <code>BUILD_</code> 选项也被启用，第三方库被构建并启用 =&gt; 相应的 <code>HAVE_</code> 选项值会被设置为 <code>ON</code></li><li>如果相应的 <code>BUILD_</code> 选项被禁用，会检测第三方库，如果第三方库被找到则被启用 =&gt; 如果找到了依赖则相应的 <code>HAVE_</code> 选项值会被设置为 <code>ON</code></li></ul> 
<h4><a id="_244"></a>异构计算</h4> 
<h5><a id="_CUDA__245"></a>对 CUDA 的支持</h5> 
<p><code>WITH_CUDA</code> （默认值：<em>OFF</em>）</p> 
<p>OpenCV 的许多算法用 CUDA 加速实现，这些函数在单独的模块中。需要预先安装 CUDA toolkit。必须先从 NVIDIA 官网安装 CUDA toolkit。 对于低于 3.9 的 CMake 版本，OpenCV 使用自己的 <code>cmake/FindCUDA.cmake</code> 脚本，而对于较新的 CMake 版本，OpenCV 使用与 CMake 一起打包的版本。 附加选项可用于控制构建过程，例如 <code>CUDA_GENERATION</code> 或 <code>CUDA_ARCH_BIN</code>。 这些参数尚未写入文档，请查阅 <code>cmake/OpenCVDetectCUDA.cmake</code> 脚本了解详细信息。</p> 
<blockquote> 
 <p>💡 <strong>NOTE</strong>: 从 OpenCV 4.0 版本开始所有的 CUDA 加速算法被移动到了 opencv_contrib 仓库（OpenCV Contrib） 中。要一起构建 opencv 和 opencv_contrib，请参考上一节的 <strong>和附加模块一起构建</strong> 小节。<br> 一些教程可以在相应的部分找到：<a href="https://docs.opencv.org/4.x/da/d2c/tutorial_table_of_content_gpu.html" rel="nofollow">GPU-Accelerated Computer Vision (cuda module)</a></p> 
</blockquote> 
<blockquote> 
 <p>也可以参考：</p> 
 <ul><li><a href="https://docs.opencv.org/4.x/d1/d1e/group__cuda.html" rel="nofollow">CUDA-accelerated Computer Vision</a></li><li><a href="https://en.wikipedia.org/wiki/CUDA" rel="nofollow">Wikipedia: CUDA</a></li></ul> 
</blockquote> 
<p><strong>TODO</strong>: 其他选项: <code>WITH_CUFFT</code>, <code>WITH_CUBLAS</code>, <code>WITH_NVCUVID</code>？</p> 
<h5><a id="_OpenCL__260"></a>对 OpenCL 的支持</h5> 
<p><code>WITH_OPENCL</code>（默认值：<em>ON</em>）</p> 
<p>许多使用 OpenCL 加速的算法可以通过所谓的 “Transparent API (T-API)” 来访问。此集成使用了在用户级上与常规 CPU 实现相同的函数。当输入和输出的图形参数被作为不透明的 <code>cv::UMat</code> 对象传递时会切换到 OpenCL 分支执行。需要了解更多的信息可以参考 <a href="https://opencv.org/opencl/" rel="nofollow">The Brief Introduction</a> 和 <a href="https://docs.opencv.org/4.x/dc/d83/group__core__opencl.html" rel="nofollow"><strong>OpenCL support</strong></a></p> 
<p>在构建时，此功能不需要任何先决条件。运行时需要一个 OpenCL runtime，你可以使用 <code>clinfo</code> 和/或 <code>opencv_version --opencl</code> 命令来检查它是否存在。OpenCL 集成的一些参数可以使用环境变量进行修改，例如 <code>OPENCV_OPENCL_DEVICE</code>。但目前还没有关于此功能的完整文档，因此要获取详细信息请查看 <code>modules/core/src/ocl.cpp</code> 文件中的源代码。</p> 
<blockquote> 
 <p>也可以参考：<a href="https://en.wikipedia.org/wiki/OpenCL" rel="nofollow">Wikipedia: OpenCL</a></p> 
</blockquote> 
<p><strong>TODO</strong>：其他选项：<code>WITH_OPENCL_SVM</code>、<code>WITH_OPENCLAMDFFT</code>、<code>WITH_OPENCLAMDBLAS</code>、<code>WITH_OPENCL_D3D11_NV</code>、<code>WITH_VA_INTEL</code></p> 
<h4><a id="imgcodecs__271"></a>图像的读写（imgcodecs 模块）</h4> 
<h5><a id="_273"></a>内置格式</h5> 
<p>下面这些格式可以直接被 OpenCV 读取而不需要任何第三方库的帮助：</p> 
<ul><li><a href="https://en.wikipedia.org/wiki/BMP_file_format" rel="nofollow">BMP</a></li><li><a href="https://en.wikipedia.org/wiki/RGBE_image_format" rel="nofollow">HDR</a> (<code>WITH_IMGCODEC_HDR</code>)</li><li><a href="https://en.wikipedia.org/wiki/Sun_Raster" rel="nofollow">Sun Raster</a> (<code>WITH_IMGCODEC_SUNRASTER</code>)</li><li><a href="https://en.wikipedia.org/wiki/Netpbm#File_formats" rel="nofollow">PPM, PGM, PBM, PFM</a> (<code>WITH_IMGCODEC_PXM</code>, <code>WITH_IMGCODEC_PFM</code>)</li></ul> 
<h5><a id="_PNG_JPEG_TIFF_WEBP__282"></a>对 PNG, JPEG, TIFF, WEBP 的支持</h5> 
<table><thead><tr><th>格式</th><th>编译选项</th><th>默认值</th><th>强制构建自身</th></tr></thead><tbody><tr><td><a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics" rel="nofollow">PNG</a></td><td><code>WITH_PNG</code></td><td><em>ON</em></td><td><code>BUILD_PNG</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/JPEG" rel="nofollow">JPEG</a></td><td><code>WITH_JPEG</code></td><td><em>ON</em></td><td><code>BUILD_JPEG</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/TIFF" rel="nofollow">TIFF</a></td><td><code>WITH_TIFF</code></td><td><em>ON</em></td><td><code>BUILD_TIFF</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/WebP" rel="nofollow">WEBP</a></td><td><code>WITH_WEBP</code></td><td><em>ON</em></td><td><code>BUILD_WEBP</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/OpenJPEG" rel="nofollow">JPEG2000 with OpenJPEG</a></td><td><code>WITH_OPENJPEG</code></td><td><em>ON</em></td><td><code>BUILD_OPENJPEG</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/JasPer" rel="nofollow">JPEG2000 with JasPer</a></td><td><code>WITH_JASPER</code></td><td><em>ON</em>（请参考 <strong>NOTE</strong>）</td><td><code>BUILD_JASPER</code></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/OpenEXR" rel="nofollow">EXR</a></td><td><code>WITH_OPENEXR</code></td><td><em>ON</em></td><td><code>BUILD_OPENEXR</code></td></tr></tbody></table> 
<p>读取这些格式的图像所需的所有库都包含在 OpenCV 中，如果在配置阶段未找到，则会自动构建。 相应的 <code>BUILD_*</code> 选项将强制构建和使用自己的库，它们在某些平台上默认启用，例如 Windows。</p> 
<blockquote> 
 <p>💡 <strong>NOTE</strong>: OpenJPEG 的优先级高于已弃用的 JasPer。 要使用 JasPer，必须禁用 OpenJPEG。</p> 
</blockquote> 
<h5><a id="GDAL__298"></a>GDAL 集成</h5> 
<p><code>WITH_GDAL</code> （默认值：<em>OFF</em>）</p> 
<p><a href="https://en.wikipedia.org/wiki/GDAL" rel="nofollow">GDAL</a> 是一个更高级别的库，支持读取多种文件格式，包括 PNG、JPEG 和 TIFF。 打开文件时它将具有更高的优先级，并且可以覆盖其他后端。 将使用 CMake 包机制搜索此库，确保已正确安装或手动设置 <code>GDAL_DIR</code> 环境或 CMake 变量。</p> 
<h5><a id="GDCM__303"></a>GDCM 集成</h5> 
<p><code>WITH_GDCM</code> （默认值：<em>OFF</em>）</p> 
<p>通过 <a href="https://en.wikipedia.org/wiki/GDCM" rel="nofollow">GDCM</a> 库启用 <a href="https://en.wikipedia.org/wiki/DICOM" rel="nofollow">DICOM</a> 医学图像格式支持。 将使用 CMake 包机制搜索此库，确保已正确安装或手动设置 <code>GDCM_DIR</code> 环境或 CMake 变量。</p> 
<h4><a id="videoio__308"></a>视频的读写（videoio 模块）</h4> 
<p><strong>TODO</strong>：videoio 的工作原理、注册表、优先级</p> 
<h5><a id="Video4Linux_312"></a>Video4Linux</h5> 
<p><code>WITH_V4L</code> （Linux；默认值：<em>ON</em> ）</p> 
<p>使用 <a href="https://en.wikipedia.org/wiki/Video4Linux" rel="nofollow">Video4Linux</a> API 从相机捕获图像。必须安装 Linux 内核头文件。</p> 
<h5><a id="FFmpeg_317"></a>FFmpeg</h5> 
<p><code>WITH_FFMPEG</code> （默认值：<em>ON</em> ）</p> 
<p>与 <a href="https://en.wikipedia.org/wiki/FFmpeg" rel="nofollow">FFmpeg</a> 库集成，用于解码和编码视频文件和网络流。 这个库可以读写许多流行的视频格式。由几个组件组成，它们需要提前安装：</p> 
<ul><li>avcodec</li><li>avformat</li><li>avutil</li><li>swscale</li><li>avresample （可选）</li></ul> 
<p>除了 Windows 平台：一个预构建的 <a href="https://github.com/opencv/opencv_3rdparty/tree/ffmpeg/4.x">包含 FFmpeg 的插件库</a> 将在配置阶段被下载并与所有生成的库一起被复制到 <code>bin</code> 文件夹。</p> 
<blockquote> 
 <p>💡 <strong>NOTE</strong>: 可以使用 <a href="https://en.wikipedia.org/wiki/Libav" rel="nofollow">Libav</a> 库代替 FFmpeg，但不积极支持这种组合。</p> 
</blockquote> 
<h5><a id="GStreamer_331"></a>GStreamer</h5> 
<p><code>WITH_GSTREAMER</code>（默认值：<em>ON</em> ）</p> 
<p>启用与 <a href="https://en.wikipedia.org/wiki/GStreamer" rel="nofollow">GStreamer</a> 库的集成，用于解码和编码视频文件、从摄像机和网络流中捕获帧。 可以安装许多插件来扩展支持的格式列表。OpenCV 允许运行作为字符串传递给 <strong><code>cv::VideoCapture</code></strong> 和 <strong><code>cv::VideoWriter</code></strong> 对象的任意 GStreamer 管道。</p> 
<p>各种 GStreamer 插件在不同平台上提供硬件加速的视频处理。</p> 
<h5><a id="Microsoft_Media_Foundation_338"></a>Microsoft Media Foundation</h5> 
<p><code>WITH_MSMF</code>（Windows；默认值：<em>ON</em> ）<br> 启用使用 Windows 的内置媒体基础框架（Windows’ built-in <a href="https://en.wikipedia.org/wiki/Media_Foundation" rel="nofollow">Media Foundation framework</a>）的 MSMF 后端。 可用于从相机捕获帧，解码和编码视频文件。</p> 
<p>此后端具有硬件加速处理支持——<code>WITH_MSMF_DXVA</code> 编译选项，其默认值为 <em>ON</em>。</p> 
<blockquote> 
 <p>💡 <strong>NOTE</strong>: 较早版本的 Windows（10 之前）可能具有不兼容的 Media Foundation 版本，已知在 OpenCV 中使用它们时会出现问题。</p> 
</blockquote> 
<h5><a id="DirectShow_346"></a>DirectShow</h5> 
<p><code>WITH_DSHOW</code>（Windows；默认值：<em>ON</em> ）</p> 
<p>此后端使用较旧的 <a href="https://en.wikipedia.org/wiki/DirectShow" rel="nofollow">DirectShow</a> 框架。 它只能用于从相机捕获帧。 现在不推荐使用它以支持 MSMF 后端，尽管两者可以在同一个构建中同时启用。</p> 
<h5><a id="AVFoundation_351"></a>AVFoundation</h5> 
<p><code>WITH_AVFOUNDATION</code>（Apple；默认值：<em>ON</em> ）</p> 
<p><a href="https://en.wikipedia.org/wiki/AVFoundation" rel="nofollow">AVFoundation</a> 框架是 Apple 平台的一部分，可用于从相机捕获帧、编码和解码视频文件。</p> 
<h5><a id="_356"></a>其它后端</h5> 
<p>有多个不太流行的框架可用于读取和写入视频。 每个都需要安装相应的库或 SDK。</p> 
<table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>WITH_1394</code></td><td><em>ON</em></td><td>使用 DC1394 库对 <a href="https://en.wikipedia.org/wiki/IEEE_1394#IIDC" rel="nofollow">IIDC IEEE1394</a> 的支持。</td></tr><tr><td><code>WITH_OPENNI</code></td><td><em>OFF</em></td><td><a href="https://en.wikipedia.org/wiki/OpenNI" rel="nofollow">OpenNI</a> 可用于从深度感应相机捕获数据。已弃用。</td></tr><tr><td><code>WITH_OPENNI2</code></td><td><em>OFF</em></td><td><a href="https://structure.io/openni" rel="nofollow">OpenNI2</a> 可用于从深度感应相机捕获数据。</td></tr><tr><td><code>WITH_PVAPI</code></td><td><em>OFF</em></td><td><a href="https://www.alliedvision.com/en/support/software-downloads.html" rel="nofollow">PVAPI</a> 是用于 Prosilica GigE 相机的旧版 SDK。 已弃用。</td></tr><tr><td><code>WITH_ARAVIS</code></td><td><em>OFF</em></td><td><a href="https://github.com/AravisProject/aravis">Aravis</a> 库用于使用 Genicam 相机进行视频采集。</td></tr><tr><td><code>WITH_XIMEA</code></td><td><em>OFF</em></td><td>对 <a href="https://www.ximea.com/" rel="nofollow">XIMEA</a> 相机的支持。</td></tr><tr><td><code>WITH_XINE</code></td><td><em>OFF</em></td><td>对 <a href="https://en.wikipedia.org/wiki/Xine" rel="nofollow">XINE</a> 库的支持。</td></tr><tr><td><code>WITH_LIBREALSENSE</code></td><td><em>OFF</em></td><td>对 <a href="https://en.wikipedia.org/wiki/Intel_RealSense" rel="nofollow">RealSense</a> 摄像头的支持。</td></tr><tr><td><code>WITH_MFX</code></td><td><em>OFF</em></td><td><a href="http://mediasdk.intel.com/" rel="nofollow">MediaSDK</a> 库可用于原始视频流的硬件加速解码和编码。</td></tr><tr><td><code>WITH_GPHOTO2</code></td><td><em>OFF</em></td><td><a href="https://en.wikipedia.org/wiki/GPhoto" rel="nofollow">GPhoto</a> 库可用于从相机中捕获帧。</td></tr><tr><td><code>WITH_ANDROID_MEDIANDK</code></td><td><em>ON</em></td><td>自 API level 21 起，<a href="https://developer.android.com/ndk/guides/stable_apis#libmediandk" rel="nofollow">MediaNDK</a> 库可以在 Android 上使用。</td></tr></tbody></table> 
<h5><a id="videoio_plugins_373"></a>videoio plugins</h5> 
<p>OpenCV 从 4.1.0 版本开始，一些 videoio 后端可以构建为插件，从而打破对第三方库的严格依赖，并使它们在运行时成为可选项。以下选项可用于控制此机制：</p> 
<table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>VIDEOIO_ENABLE_PLUGINS</code></td><td><em>ON</em></td><td>完全启用或禁用插件。</td></tr><tr><td><code>VIDEOIO_PLUGIN_LIST</code></td><td><em>空</em></td><td>要编译为插件的后端名称的列表，使用逗号或分号分隔。支持的名称有 <em>ffmpeg</em>、<em>gstreamer</em>、<em>msmf</em>、<em>mfx</em> 和 <em>all</em>。</td></tr></tbody></table> 
<p>在 <a href="https://docs.opencv.org/4.x/d0/d3d/tutorial_general_install.html" rel="nofollow">OpenCV installation overview</a> 中有特定插件的构建说明。</p> 
<h4><a id="_383"></a>并行处理</h4> 
<p>一些 OpenCV 算法可以使用多线程来加速处理。OpenCV 可以和一个多线程（Threading）后端一起构建。</p> 
<table><thead><tr><th>后端</th><th>选项</th><th>默认值</th><th>平台</th><th>描述</th></tr></thead><tbody><tr><td>pthreads</td><td><code>WITH_PTHREADS_PF</code></td><td><em>ON</em></td><td>类 Unix</td><td>基于 <a href="https://en.wikipedia.org/wiki/POSIX_Threads" rel="nofollow">pthreads</a> 库的默认后端可在 Linux、Android 和其他类 Unix 平台上使用。线程池在 OpenCV 中实现，可以通过环境变量 <code>OPENCV_THREAD_POOL_*</code> 进行控制。详细信息请参考 <code>modules/core/src/parallel_impl.cpp</code> 文件中的源代码。</td></tr><tr><td>Concurrency</td><td>不适用</td><td><em>ON</em></td><td>Windows</td><td><a href="https://docs.microsoft.com/en-us/cpp/parallel/concrt/concurrency-runtime?view=msvc-170" rel="nofollow">Concurrency runtime</a> 在 Windows 上可用，除非启用其他后端，否则将在支持的平台上打开。</td></tr><tr><td>GCD</td><td>不适用</td><td><em>ON</em></td><td>Apple</td><td><a href="https://en.wikipedia.org/wiki/Grand_Central_Dispatch" rel="nofollow">Grand Central Dispatch</a> 在 Apple 平台上可用，除非启用其他后端，否则将自动打开。使用全局系统线程池。</td></tr><tr><td>TBB</td><td><code>WITH_TBB</code></td><td><em>OFF</em></td><td>跨平台</td><td><a href="https://en.wikipedia.org/wiki/Threading_Building_Blocks" rel="nofollow">Threading Building Blocks</a> 是一个用于并行编程的跨平台库。</td></tr><tr><td>OpenMP</td><td><code>WITH_OPENMP</code></td><td><em>OFF</em></td><td>跨平台</td><td><a href="https://en.wikipedia.org/wiki/OpenMP" rel="nofollow">OpenMP</a> API 依赖于编译器支持。</td></tr><tr><td>HPX</td><td><code>WITH_HPX</code></td><td><em>OFF</em></td><td>跨平台</td><td><a href="https://en.wikipedia.org/wiki/HPX" rel="nofollow">High Performance ParallelX</a> 是一个实验性后端，更适合多处理器环境。</td></tr></tbody></table> 
<blockquote> 
 <p>💡 <strong>NOTE</strong>: OpenCV 可以从 GitHub 下载和构建 TBB 库，可以使用 <code>BUILD_TBB</code> 选项启用此功能。</p> 
</blockquote> 
<h5><a id="_398"></a>多线程插件</h5> 
<p>从 OpenCV 4.5.2 开始支持动态加载线程后端。 目前仅支持单独的编译过程：首先必须使用一些默认的并行后端（例如 pthreads）构建 OpenCV，然后构建每个插件并将生成的二进制文件复制到 lib 或 bin 文件夹。</p> 
<table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>PARALLEL_ENABLE_PLUGINS</code></td><td>ON</td><td>启用插件支持。如果禁用此选项，OpenCV 将不会尝试加载任何内容。</td></tr></tbody></table> 
<p>在 <a href="https://docs.opencv.org/4.x/d0/d3d/tutorial_general_install.html" rel="nofollow">OpenCV installation overview</a> 中有特定插件的构建说明。</p> 
<h4><a id="GUI_highgui__408"></a>GUI 后端（highgui 模块）</h4> 
<p>OpenCV 依赖于各种 GUI 库来绘制窗口。</p> 
<table><thead><tr><th>选项</th><th>默认值</th><th>平台</th><th>描述</th></tr></thead><tbody><tr><td><code>WITH_GTK</code></td><td><em>ON</em></td><td>Linux</td><td><a href="https://en.wikipedia.org/wiki/GTK" rel="nofollow">GTK</a> 是 Linux 和类 Unix 操作系统中的常用工具包。 默认情况下如果找到版本 3 将使用它，可以使用 <code>WITH_GTK_2_X</code> 选项来强制使用版本 2。</td></tr><tr><td><code>WITH_WIN32UI</code></td><td><em>ON</em></td><td>Windows</td><td><a href="https://en.wikipedia.org/wiki/Windows_API" rel="nofollow">WinAPI</a> 是 Windows 中的标准 GUI API。</td></tr><tr><td>不适用</td><td><em>ON</em></td><td>macOS</td><td><a href="https://en.wikipedia.org/wiki/Cocoa_%28API%29" rel="nofollow">Cocoa</a> 是 macOS 中使用的框架。</td></tr><tr><td><code>WITH_QT</code></td><td><em>OFF</em></td><td>跨平台</td><td><a href="https://en.wikipedia.org/wiki/Qt_%28software%29" rel="nofollow">Qt</a> 是一个跨平台的 GUI 框架。</td></tr></tbody></table> 
<blockquote> 
 <p>💡 <strong>NOTE</strong>: 带对 Qt 支持的 OpenCV 编译后启用了高级的 highgui 接口，请参阅 <a href="https://docs.opencv.org/4.x/dc/d46/group__highgui__qt.html" rel="nofollow"><strong>Qt New Functions</strong></a> 了解详细信息。</p> 
</blockquote> 
<h5><a id="OpenGL_421"></a>OpenGL</h5> 
<p><code>WITH_OPENGL</code> （默认值： <em>OFF</em>）</p> 
<p>OpenGL 集成可用于与以下后端一起绘制硬件加速窗口：GTK、WIN32 和 Qt。并启用与 OpenGL 的基本互操作性，有关详细信息，请参阅 <a href="https://docs.opencv.org/4.x/d2/d3c/group__core__opengl.html" rel="nofollow"><strong>OpenGL interoperability</strong></a> 和 <a href="https://docs.opencv.org/4.x/df/d24/group__highgui__opengl.html" rel="nofollow"><strong>OpenGL support</strong></a>。</p> 
<h5><a id="highgui__426"></a>highgui 插件</h5> 
<p>从 OpenCV 4.5.3 开始，GTK 后端可以被构建为动态加载的插件。 以下选项可用于控制此机制：</p> 
<table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>HIGHGUI_ENABLE_PLUGINS</code></td><td><em>ON</em></td><td>完全启用或禁用插件。</td></tr><tr><td><code>HIGHGUI_PLUGIN_LIST</code></td><td><em>空</em></td><td>要编译为插件的后端名称列表，用逗号或分号分隔。 支持的名称有 <em>gtk</em>、<em>gtk2</em>、<em>gtk3</em> 和 <em>all</em>。</td></tr></tbody></table> 
<p>在 <a href="https://docs.opencv.org/4.x/d0/d3d/tutorial_general_install.html" rel="nofollow">OpenCV installation overview</a> 中有特定插件的构建说明。</p> 
<h4><a id="_dnn__436"></a>深度学习神经网络推断后端和选项 （dnn 模块）</h4> 
<p>OpenCV 有自己的 DNN 推理模块，它有自己的内置引擎，但也可以使用其他库进行优化处理。可以在单个构建中启用多个后端，在运行时自动或手动选择。</p> 
<table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>WITH_PROTOBUF</code></td><td><em>ON</em></td><td>启用对 <a href="https://en.wikipedia.org/wiki/Protocol_Buffers" rel="nofollow">protobuf</a> 库的搜索。OpenCV 可以构建自己的库副本或使用外部库。dnn 模块需要此依赖项，如果找不到则 dnn 模块将被禁用。</td></tr><tr><td><code>BUILD_PROTOBUF</code></td><td><em>ON</em></td><td>构建自己的 protobuf 库副本。如果要使用外部库则必须禁用此选项。</td></tr><tr><td><code>PROTOBUF_UPDATE_FILES</code></td><td><em>OFF</em></td><td>重新生成所有 <code>.proto</code> 文件。必须安装与使用的 protobuf 版本兼容的 protoc 编译器。</td></tr><tr><td><code>OPENCV_DNN_OPENCL</code></td><td><em>ON</em></td><td>启用内置的 OpenCL 推断后端。</td></tr><tr><td><code>WITH_INF_ENGINE</code></td><td><em>OFF</em></td><td><strong>自 OpenVINO 2022.1 起已弃用</strong>。启用英特尔推断引擎 （<a href="https://github.com/openvinotoolkit/openvino">Intel Inference Engine</a>, IE）后端。允许以 IE 格式 （<code>.xml</code> + <code>.bin</code>）来运行网络。推断引擎必须作为 <a href="https://en.wikipedia.org/wiki/OpenVINO" rel="nofollow">OpenVINO toolkit</a> 的一部分安装，或者作为从源代码构建的独立库安装。</td></tr><tr><td><code>INF_ENGINE_RELEASE</code></td><td><em>2020040000</em></td><td><strong>自 OpenVINO 2022.1 起已弃用</strong>。定义与 OpenVINO 工具包版本绑定的推断引擎库版本。必须是 10 位的字符串，例如 2020040000 对应于 OpenVINO 2020.4。</td></tr><tr><td><code>WITH_NGRAPH</code></td><td><em>OFF</em></td><td><strong>自 OpenVINO 2022.1 起已弃用</strong>。启用对英特尔 NGraph 库的支持。该库是推断引擎后端的一部分，它允许运行从 OpenCV 支持的多种格式的文件中读取的任意网络：Caffe、TensorFlow、PyTorch、Darknet 等。必须安装 NGraph 库，它包含在推断引擎中。</td></tr><tr><td><code>WITH_OPENVINO</code></td><td><em>OFF</em></td><td>启用对英特尔 OpenVINO Toolkit 的支持。<strong>从 OpenVINO&gt;=2022.1 起应该使用此选项而不是 <code>WITH_INF_ENGINE</code> 和 <code>WITH_NGRAPH</code></strong>。</td></tr><tr><td><code>OPENCV_DNN_CUDA</code></td><td><em>OFF</em></td><td>启用 <a href="https://en.wikipedia.org/wiki/CUDA" rel="nofollow">CUDA</a> 后端。必须安装 CUDA、CUBLAS 和 <a href="https://developer.nvidia.com/cudnn" rel="nofollow">CUDNN</a>。</td></tr><tr><td><code>WITH_HALIDE</code></td><td><em>OFF</em></td><td>使用实验性的 <a href="https://en.wikipedia.org/wiki/Halide_%28programming_language%29" rel="nofollow">Halide</a> 后端，它可以在运行时为 dnn 层生成优化的代码。必须安装 Halide。</td></tr><tr><td><code>WITH_VULKAN</code></td><td><em>OFF</em></td><td>启用实验性 <a href="https://en.wikipedia.org/wiki/Vulkan_%28API%29" rel="nofollow">Vulkan</a> 后端。不需要附加依赖项，但可以使用外部 Vulkan 头文件（<code>VULKAN_INCLUDE_DIRS</code>）。</td></tr><tr><td><code>WITH_TENGINE</code></td><td><em>OFF</em></td><td>为 ARM CPU 启用实验性 <a href="https://github.com/OAID/Tengine">Tengine</a> 后端。必须安装 Tengine 库。</td></tr></tbody></table> 
<h3><a id="_454"></a>安装布局</h3> 
<h4><a id="_455"></a>安装根目录</h4> 
<p>要安装生成的二进制文件，应该配置根位置。默认值取决于（操作系统）发行版，在 Ubuntu 中通常设置为 <code>/usr/local</code>。它可以在配置期间更改：</p> 
<pre><code class="prism language-Bash">cmake -DCMAKE_INSTALL_PREFIX=/opt/opencv ../opencv
</code></pre> 
<p>此路径可以是相对于当前工作目录的相对路径，在下面的示例中，它将设置为 <code>&lt;absolute-path-to-build&gt;/install</code>：</p> 
<pre><code class="prism language-Bash">cmake -DCMAKE_INSTALL_PREFIX=install ../opencv
</code></pre> 
<p>构建库后，（root / 管理员）可以使用以下命令将所有文件复制到配置的安装位置：</p> 
<pre><code class="prism language-Bash">cmake --build . --target install
</code></pre> 
<p>要以普通用户身份将二进制文件安装到系统位置（例如 <code>/usr/local</code>），必须用权限提升（<code>sudo</code>）来运行上面的命令：</p> 
<pre><code class="prism language-Bash">sudo cmake --build . --target install
</code></pre> 
<blockquote> 
 <p>💡 <strong>NOTE</strong>: 在某些平台 (Linux) 上，可以在安装期间删除符号信息。二进制文件将缩小 10-15%，但调试将受到限制：<br> <code>cmake --build . --target install/strip</code></p> 
</blockquote> 
<h4><a id="_482"></a>组件和位置</h4> 
<p>这些编译选项可以用于控制是否安装库的一部分：</p> 
<table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>INSTALL_C_EXAMPLES</code></td><td><em>OFF</em></td><td>安装<em>samples/cpp</em> 目录中的 C++ 示例源代码。</td></tr><tr><td><code>INSTALL_PYTHON_EXAMPLES</code></td><td><em>OFF</em></td><td>安装 <em>samples/python</em> 目录中的 Python 示例源代码。</td></tr><tr><td><code>INSTALL_ANDROID_EXAMPLES</code></td><td><em>OFF</em></td><td>安装 <em>samples/android</em> 目录中的 Android 示例源代码。</td></tr><tr><td><code>INSTALL_BIN_EXAMPLES</code></td><td><em>OFF</em></td><td>安装预构建的示例应用程序（必须启用 <code>BUILD_EXAMPLES</code> 选项）。</td></tr><tr><td><code>INSTALL_TESTS</code></td><td><em>OFF</em></td><td>安装测试（必须启用 <code>BUILD_TESTS</code> 选项）。</td></tr><tr><td><code>OPENCV_INSTALL_APPS_LIST</code></td><td><em>all</em></td><td>要安装的预构建应用程序（在 <em>apps</em> 目录中）的列表，用逗号或分号分隔。</td></tr></tbody></table> 
<p>以下编译选项可以修改相应组件的相对于安装前缀（install prefix）的安装位置。这些选项的默认值取决于平台和其他选项，要了解详细信息请查看 <em>cmake/OpenCVInstallLayout.cmake</em> 文件。</p> 
<table><thead><tr><th>选项</th><th>组件</th></tr></thead><tbody><tr><td><code>OPENCV_BIN_INSTALL_PATH</code></td><td>应用程序、动态库（win）</td></tr><tr><td><code>OPENCV_TEST_INSTALL_PATH</code></td><td>测试应用程序</td></tr><tr><td><code>OPENCV_SAMPLES_BIN_INSTALL_PATH</code></td><td>示例应用程序</td></tr><tr><td><code>OPENCV_LIB_INSTALL_PATH</code></td><td>动态库，导入库（win）</td></tr><tr><td><code>OPENCV_LIB_ARCHIVE_INSTALL_PATH</code></td><td>静态库</td></tr><tr><td><code>OPENCV_3P_LIB_INSTALL_PATH</code></td><td>3rdparty （第三方）库</td></tr><tr><td><code>OPENCV_CONFIG_INSTALL_PATH</code></td><td>CMake 配置包</td></tr><tr><td><code>OPENCV_INCLUDE_INSTALL_PATH</code></td><td>头文件</td></tr><tr><td><code>OPENCV_OTHER_INSTALL_PATH</code></td><td>附加数据文件</td></tr><tr><td><code>OPENCV_SAMPLES_SRC_INSTALL_PATH</code></td><td>示例源代码</td></tr><tr><td><code>OPENCV_LICENSES_INSTALL_PATH</code></td><td>包含的 3rdparty（第三方） 组件的许可证</td></tr><tr><td><code>OPENCV_TEST_DATA_INSTALL_PATH</code></td><td>测试数据</td></tr><tr><td><code>OPENCV_DOC_INSTALL_PATH</code></td><td>文档</td></tr><tr><td><code>OPENCV_JAR_INSTALL_PATH</code></td><td>带有 Java 绑定的 JAR 文件</td></tr><tr><td><code>OPENCV_JNI_INSTALL_PATH</code></td><td>Java 绑定的 JNI 部分</td></tr><tr><td><code>OPENCV_JNI_BIN_INSTALL_PATH</code></td><td>Java 绑定的 JNI 部分的动态库</td></tr></tbody></table> 
<p>以下选项可用于更改常见场景的安装布局：</p> 
<table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>INSTALL_CREATE_DISTRIB</code></td><td><em>OFF</em></td><td>调整多项以生成 Windows 和 Android 发行版。</td></tr><tr><td><code>INSTALL_TO_MANGLED_PATHS</code></td><td><em>OFF</em></td><td>通过添加一层版本号来允许同时安装多个版本。例如，启用此选项后，头文件将安装到 <em>/usr/include/opencv-4.4.0</em> 而不是 <em>/usr/include/opencv4</em>。</td></tr></tbody></table> 
<h3><a id="_522"></a>其他功能</h3> 
<table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>OPENCV_ENABLE_NONFREE</code></td><td><em>OFF</em></td><td>库中包含的一些算法已知受专利保护，在默认情况下被禁用。</td></tr><tr><td><code>OPENCV_FORCE_3RDPARTY_BUILD</code></td><td><em>OFF</em></td><td>立即启用所有 <code>BUILD_</code> 选项。</td></tr><tr><td><code>ENABLE_CCACHE</code></td><td><em>ON</em>（在类 Unix 平台上）</td><td>启用 <a href="https://en.wikipedia.org/wiki/Ccache" rel="nofollow">ccache</a> 自动检查。该工具包装编译器调用并缓存结果，可以显著地缩短重新编译的时间。</td></tr><tr><td><code>ENABLE_PRECOMPILED_HEADERS</code></td><td><em>ON</em>（对于 MSVC 编译器）</td><td>启用对预编译头文件的支持。改进构建时间。</td></tr><tr><td><code>BUILD_DOCS</code></td><td><em>OFF</em></td><td>启用文档的构建（<em>doxygen</em>、<em>doxygen_cpp</em>、<em>doxygen_python</em>、<em>doxygen_javadoc</em> 目标）。构建必须安装 <a href="http://www.doxygen.org/index.html" rel="nofollow">Doxygen</a> 才能构建 C++ 文档。必须安装 Python 和 <a href="https://en.wikipedia.org/wiki/Beautiful_Soup_%28HTML_parser%29" rel="nofollow">BeautifulSoup4</a> 才能构建 Python 文档。 必须安装 Javadoc 和 Ant 才能构建 Java 文档（Java SDK 的一部分）。</td></tr><tr><td><code>ENABLE_PYLINT</code></td><td><em>ON</em>（启用文档或示例时）</td><td>启用 <a href="https://en.wikipedia.org/wiki/Pylint" rel="nofollow">Pylint</a> 对 python 脚本进行检查（<em>check_pylint</em> 目标）。必须安装 Pylint。</td></tr><tr><td><code>ENABLE_FLAKE8</code></td><td><em>ON</em>（启用文档或示例时）</td><td>启用 <a href="https://flake8.pycqa.org/" rel="nofollow">Flake8</a> 对 python 脚本进行检查（<em>check_flake8</em> 目标）。必须安装 Flake8。</td></tr><tr><td><code>BUILD_JAVA</code></td><td><em>ON</em></td><td>启用对 Java 包装器的构建。必须安装 Java SDK 和 Ant。</td></tr><tr><td><code>BUILD_FAT_JAVA_LIB</code></td><td><em>ON</em>（用于静态 Android 构建）</td><td>构建单个 <em>opencv_java</em> 动态库，其中包含与 Java 绑定捆绑的所有库功能。</td></tr><tr><td><code>BUILD_opencv_python2</code></td><td><em>ON</em></td><td>构建 python2 绑定（已弃用）。必须安装带有开发文件和 numpy 的 Python。</td></tr><tr><td><code>BUILD_opencv_python3</code></td><td><em>ON</em></td><td>构建 python3 绑定。必须安装带有开发文件和 numpy 的 Python。</td></tr></tbody></table> 
<p><strong>TODO</strong>: 需要单独的教程涵盖绑定（bindings）的构建</p> 
<h4><a id="_540"></a>自动化构建</h4> 
<p>一些特性是专门为自动化构建环境添加的，比如持续连续集成和打包系统。</p> 
<table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>ENABLE_NOISY_WARNINGS</code></td><td><em>OFF</em></td><td>启用几个被认为是噪声（noisy）的编译器警告，它们的重要性低于其他警告。这些警告通常被忽略，但在某些情况下值得检查。</td></tr><tr><td><code>OPENCV_WARNINGS_ARE_ERRORS</code></td><td><em>OFF</em></td><td>将编译器警告视为错误，构建将终止。</td></tr><tr><td><code>ENABLE_CONFIG_VERIFICATION</code></td><td><em>OFF</em></td><td>对于每个启用的依赖项（<code>WITH_</code> 选项），验证它是否已被找到并启用（<code>HAVE_</code> 变量）。默认情况下，如果未找到依赖项，该功能将被静默关闭，但启用此选项后，CMake 配置将失败。方便需要稳定的库配置而不依赖于环境波动的打包系统。</td></tr><tr><td><code>OPENCV_CMAKE_HOOKS_DIR</code></td><td><em>空</em></td><td>OpenCV 允许通过在每个阶段和子阶段添加自定义 hook 脚本来自定义配置过程。在此变量设置的目录中具有预定义名称的 CMake 脚本将包含在各个配置阶段之前和之后。文件名示例：<em>CMAKE_INIT.cmake</em>、<em>PRE_CMAKE_BOOTSTRAP.cmake</em>、<em>POST_CMAKE_BOOTSTRAP.cmake</em> 等。其他名称没有写入文档，可以通过在项目 CMake 文件中搜索 <em>ocv_cmake_hook</em> 宏调用找到。</td></tr><tr><td><code>OPENCV_DUMP_HOOKS_FLOW</code></td><td><em>OFF</em></td><td>对每个 CMake hook 脚本调用启用调试消息打印。</td></tr></tbody></table> 
<h4><a id="Contrib__552"></a>Contrib 模块</h4> 
<p><code>opencv_contrib</code> 模块中使用了以下构建选项，如前所述，这些额外的模块可以通过设置 <code>DOPENCV_EXTRA_MODULES_PATH</code> 选项添加到您的最终构建中。</p> 
<table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>WITH_CLP</code></td><td><em>OFF</em></td><td>将添加对 videostab 模块所需的 coinor 线性编程（coinor linear programming）库的构建支持。请确保安装 coinor-clp 的开发库。</td></tr></tbody></table> 
<h3><a id="_561"></a>尚未写入文档的其它选项</h3> 
<p><code>BUILD_ANDROID_PROJECTS</code> <code>BUILD_ANDROID_EXAMPLES</code> <code>ANDROID_HOME</code> <code>ANDROID_SDK</code> <code>ANDROID_NDK</code> <code>ANDROID_SDK_ROOT</code></p> 
<p><code>CMAKE_TOOLCHAIN_FILE</code></p> 
<p><code>WITH_CAROTENE</code> <code>WITH_CPUFEATURES</code> <code>WITH_EIGEN</code> <code>WITH_OPENVX</code> <code>WITH_DIRECTX</code> <code>WITH_VA</code> <code>WITH_LAPACK</code> <code>WITH_QUIRC</code> <code>BUILD_ZLIB</code> <code>BUILD_ITT</code> <code>WITH_IPP</code> <code>BUILD_IPP_IW</code></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/04c71a5bb659195ac7998a9f9e1b0ada/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LeetCode -1631 最小体力消耗路径</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e6e0733539ac0fc3e0b10bf929b12cd1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux中函数库文件依赖关系查找网站 www.rpmfind.net</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>