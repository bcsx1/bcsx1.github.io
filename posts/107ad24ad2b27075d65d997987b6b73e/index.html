<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Celery-4.1 用户指南: Configuration and defaults - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Celery-4.1 用户指南: Configuration and defaults" />
<meta property="og:description" content="这篇文档描述了可用的配置选项。
如果你使用默认的加载器，你必须创建 celeryconfig.py 模块并且保证它在python路径中。
配置文件示例 以下是配置示例，你可以从这个开始。它包括运行一个基本Celery应用的所有基础设置。
## Broker settings. broker_url = &#39;amqp://guest:guest@localhost:5672//&#39; # List of modules to import when the Celery worker starts. imports = (&#39;myapp.tasks&#39;,) ## Using the database to store task state and results. result_backend = &#39;db&#43;sqlite:///results.db&#39; task_annotations = {&#39;tasks.add&#39;: {&#39;rate_limit&#39;: &#39;10/s&#39;}} 新的小写设置 4.0 版本引入了新的小写设置名称以及社会组织。
与以前版本的不同，除了设置项名称变为小写字母外，还有一个前缀的重命名，例如 celerybeat_ 变为 beat_，celeryd_ 变为 worker，以及很多顶级 celery_ 设置重命名成了 task_ 前缀。
Celery 仍然能读取老的配置文件，所以并不仓促迁移到新的设置格式。
Setting nameReplace withCELERY_ACCEPT_CONTENTaccept_contentCELERY_ENABLE_UTCenable_utcCELERY_IMPORTSimportsCELERY_INCLUDEincludeCELERY_TIMEZONEtimezoneCELERYBEAT_MAX_LOOP_INTERVALbeat_max_loop_intervalCELERYBEAT_SCHEDULEbeat_scheduleCELERYBEAT_SCHEDULERbeat_schedulerCELERYBEAT_SCHEDULE_FILENAMEbeat_schedule_filenameCELERYBEAT_SYNC_EVERYbeat_sync_everyBROKER_URLbroker_urlBROKER_TRANSPORTbroker_transportBROKER_TRANSPORT_OPTIONSbroker_transport_optionsBROKER_CONNECTION_TIMEOUTbroker_connection_timeoutBROKER_CONNECTION_RETRYbroker_connection_retryBROKER_CONNECTION_MAX_RETRIESbroker_connection_max_retriesBROKER_FAILOVER_STRATEGYbroker_failover_strategyBROKER_HEARTBEATbroker_heartbeatBROKER_LOGIN_METHODbroker_login_methodBROKER_POOL_LIMITbroker_pool_limitBROKER_USE_SSLbroker_use_sslCELERY_CACHE_BACKENDcache_backendCELERY_CACHE_BACKEND_OPTIONScache_backend_optionsCASSANDRA_COLUMN_FAMILYcassandra_tableCASSANDRA_ENTRY_TTLcassandra_entry_ttlCASSANDRA_KEYSPACEcassandra_keyspaceCASSANDRA_PORTcassandra_portCASSANDRA_READ_CONSISTENCYcassandra_read_consistencyCASSANDRA_SERVERScassandra_serversCASSANDRA_WRITE_CONSISTENCYcassandra_write_consistencyCELERY_COUCHBASE_BACKEND_SETTINGScouchbase_backend_settingsCELERY_MONGODB_BACKEND_SETTINGSmongodb_backend_settingsCELERY_EVENT_QUEUE_EXPIRESevent_queue_expiresCELERY_EVENT_QUEUE_TTLevent_queue_ttlCELERY_EVENT_QUEUE_PREFIXevent_queue_prefixCELERY_EVENT_SERIALIZERevent_serializerCELERY_REDIS_DBredis_dbCELERY_REDIS_HOSTredis_hostCELERY_REDIS_MAX_CONNECTIONSredis_max_connectionsCELERY_REDIS_PASSWORDredis_passwordCELERY_REDIS_PORTredis_portCELERY_RESULT_BACKENDresult_backendCELERY_MAX_CACHED_RESULTSresult_cache_maxCELERY_MESSAGE_COMPRESSIONresult_compressionCELERY_RESULT_EXCHANGEresult_exchangeCELERY_RESULT_EXCHANGE_TYPEresult_exchange_typeCELERY_TASK_RESULT_EXPIRESresult_expiresCELERY_RESULT_PERSISTENTresult_persistentCELERY_RESULT_SERIALIZERresult_serializerCELERY_RESULT_DBURIUse result_backend instead.CELERY_RESULT_ENGINE_OPTIONSdatabase_engine_options[…]_DB_SHORT_LIVED_SESSIONSdatabase_short_lived_sessionsCELERY_RESULT_DB_TABLE_NAMESdatabase_db_namesCELERY_SECURITY_CERTIFICATEsecurity_certificateCELERY_SECURITY_CERT_STOREsecurity_cert_storeCELERY_SECURITY_KEYsecurity_keyCELERY_TASK_ACKS_LATEtask_acks_lateCELERY_TASK_ALWAYS_EAGERtask_always_eagerCELERY_TASK_ANNOTATIONStask_annotationsCELERY_TASK_COMPRESSIONtask_compressionCELERY_TASK_CREATE_MISSING_QUEUEStask_create_missing_queuesCELERY_TASK_DEFAULT_DELIVERY_MODEtask_default_delivery_modeCELERY_TASK_DEFAULT_EXCHANGEtask_default_exchangeCELERY_TASK_DEFAULT_EXCHANGE_TYPEtask_default_exchange_typeCELERY_TASK_DEFAULT_QUEUEtask_default_queueCELERY_TASK_DEFAULT_RATE_LIMITtask_default_rate_limitCELERY_TASK_DEFAULT_ROUTING_KEYtask_default_routing_keyCELERY_TASK_EAGER_PROPAGATEStask_eager_propagatesCELERY_TASK_IGNORE_RESULTtask_ignore_resultCELERY_TASK_PUBLISH_RETRYtask_publish_retryCELERY_TASK_PUBLISH_RETRY_POLICYtask_publish_retry_policyCELERY_TASK_QUEUEStask_queuesCELERY_TASK_ROUTEStask_routesCELERY_TASK_SEND_SENT_EVENTtask_send_sent_eventCELERY_TASK_SERIALIZERtask_serializerCELERYD_TASK_SOFT_TIME_LIMITtask_soft_time_limitCELERYD_TASK_TIME_LIMITtask_time_limitCELERY_TRACK_STARTEDtask_track_startedCELERYD_AGENTworker_agentCELERYD_AUTOSCALERworker_autoscalerCELERYD_CONCURRENCYworker_concurrencyCELERYD_CONSUMERworker_consumerCELERY_WORKER_DIRECTworker_directCELERY_DISABLE_RATE_LIMITSworker_disable_rate_limitsCELERY_ENABLE_REMOTE_CONTROLworker_enable_remote_controlCELERYD_HIJACK_ROOT_LOGGERworker_hijack_root_loggerCELERYD_LOG_COLORworker_log_colorCELERYD_LOG_FORMATworker_log_formatCELERYD_WORKER_LOST_WAITworker_lost_waitCELERYD_MAX_TASKS_PER_CHILDworker_max_tasks_per_childCELERYD_POOLworker_poolCELERYD_POOL_PUTLOCKSworker_pool_putlocksCELERYD_POOL_RESTARTSworker_pool_restartsCELERYD_PREFETCH_MULTIPLIERworker_prefetch_multiplierCELERYD_REDIRECT_STDOUTSworker_redirect_stdoutsCELERYD_REDIRECT_STDOUTS_LEVELworker_redirect_stdouts_levelCELERYD_SEND_EVENTSworker_send_task_eventsCELERYD_STATE_DBworker_state_dbCELERYD_TASK_LOG_FORMATworker_task_log_formatCELERYD_TIMERworker_timerCELERYD_TIMER_PRECISIONworker_timer_precision 配置指示 通用设置 accept_content 默认值: {‘json’} (set, list, or tuple)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/107ad24ad2b27075d65d997987b6b73e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-12-15T14:47:43+08:00" />
<meta property="article:modified_time" content="2017-12-15T14:47:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Celery-4.1 用户指南: Configuration and defaults</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>这篇文档描述了可用的配置选项。</p> 
<p>如果你使用默认的加载器，你必须创建 celeryconfig.py 模块并且保证它在python路径中。</p> 
<h3 id="配置文件示例">配置文件示例</h3> 
<p>以下是配置示例，你可以从这个开始。它包括运行一个基本Celery应用的所有基础设置。</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">## Broker settings.</span>
broker_url = <span class="hljs-string">'amqp://guest:guest@localhost:5672//'</span>

<span class="hljs-preprocessor"># List of modules to import when the Celery worker starts.</span>
imports = (<span class="hljs-string">'myapp.tasks'</span>,)

<span class="hljs-preprocessor">## Using the database to store task state and results.</span>
result_backend = <span class="hljs-string">'db+sqlite:///results.db'</span>

task_annotations = {<!-- --><span class="hljs-string">'tasks.add'</span>: {<!-- --><span class="hljs-string">'rate_limit'</span>: <span class="hljs-string">'10/s'</span>}}</code></pre> 
<h3 id="新的小写设置">新的小写设置</h3> 
<p>4.0 版本引入了新的小写设置名称以及社会组织。</p> 
<p>与以前版本的不同，除了设置项名称变为小写字母外，还有一个前缀的重命名，例如 celerybeat_ 变为 beat_，celeryd_ 变为 worker，以及很多顶级 celery_ 设置重命名成了 task_ 前缀。</p> 
<p>Celery 仍然能读取老的配置文件，所以并不仓促迁移到新的设置格式。</p> 
<table><thead><tr><th>Setting name</th><th>Replace with</th></tr></thead><tbody><tr><td>CELERY_ACCEPT_CONTENT</td><td>accept_content</td></tr><tr><td>CELERY_ENABLE_UTC</td><td>enable_utc</td></tr><tr><td>CELERY_IMPORTS</td><td>imports</td></tr><tr><td>CELERY_INCLUDE</td><td>include</td></tr><tr><td>CELERY_TIMEZONE</td><td>timezone</td></tr><tr><td>CELERYBEAT_MAX_LOOP_INTERVAL</td><td>beat_max_loop_interval</td></tr><tr><td>CELERYBEAT_SCHEDULE</td><td>beat_schedule</td></tr><tr><td>CELERYBEAT_SCHEDULER</td><td>beat_scheduler</td></tr><tr><td>CELERYBEAT_SCHEDULE_FILENAME</td><td>beat_schedule_filename</td></tr><tr><td>CELERYBEAT_SYNC_EVERY</td><td>beat_sync_every</td></tr><tr><td>BROKER_URL</td><td>broker_url</td></tr><tr><td>BROKER_TRANSPORT</td><td>broker_transport</td></tr><tr><td>BROKER_TRANSPORT_OPTIONS</td><td>broker_transport_options</td></tr><tr><td>BROKER_CONNECTION_TIMEOUT</td><td>broker_connection_timeout</td></tr><tr><td>BROKER_CONNECTION_RETRY</td><td>broker_connection_retry</td></tr><tr><td>BROKER_CONNECTION_MAX_RETRIES</td><td>broker_connection_max_retries</td></tr><tr><td>BROKER_FAILOVER_STRATEGY</td><td>broker_failover_strategy</td></tr><tr><td>BROKER_HEARTBEAT</td><td>broker_heartbeat</td></tr><tr><td>BROKER_LOGIN_METHOD</td><td>broker_login_method</td></tr><tr><td>BROKER_POOL_LIMIT</td><td>broker_pool_limit</td></tr><tr><td>BROKER_USE_SSL</td><td>broker_use_ssl</td></tr><tr><td>CELERY_CACHE_BACKEND</td><td>cache_backend</td></tr><tr><td>CELERY_CACHE_BACKEND_OPTIONS</td><td>cache_backend_options</td></tr><tr><td>CASSANDRA_COLUMN_FAMILY</td><td>cassandra_table</td></tr><tr><td>CASSANDRA_ENTRY_TTL</td><td>cassandra_entry_ttl</td></tr><tr><td>CASSANDRA_KEYSPACE</td><td>cassandra_keyspace</td></tr><tr><td>CASSANDRA_PORT</td><td>cassandra_port</td></tr><tr><td>CASSANDRA_READ_CONSISTENCY</td><td>cassandra_read_consistency</td></tr><tr><td>CASSANDRA_SERVERS</td><td>cassandra_servers</td></tr><tr><td>CASSANDRA_WRITE_CONSISTENCY</td><td>cassandra_write_consistency</td></tr><tr><td>CELERY_COUCHBASE_BACKEND_SETTINGS</td><td>couchbase_backend_settings</td></tr><tr><td>CELERY_MONGODB_BACKEND_SETTINGS</td><td>mongodb_backend_settings</td></tr><tr><td>CELERY_EVENT_QUEUE_EXPIRES</td><td>event_queue_expires</td></tr><tr><td>CELERY_EVENT_QUEUE_TTL</td><td>event_queue_ttl</td></tr><tr><td>CELERY_EVENT_QUEUE_PREFIX</td><td>event_queue_prefix</td></tr><tr><td>CELERY_EVENT_SERIALIZER</td><td>event_serializer</td></tr><tr><td>CELERY_REDIS_DB</td><td>redis_db</td></tr><tr><td>CELERY_REDIS_HOST</td><td>redis_host</td></tr><tr><td>CELERY_REDIS_MAX_CONNECTIONS</td><td>redis_max_connections</td></tr><tr><td>CELERY_REDIS_PASSWORD</td><td>redis_password</td></tr><tr><td>CELERY_REDIS_PORT</td><td>redis_port</td></tr><tr><td>CELERY_RESULT_BACKEND</td><td>result_backend</td></tr><tr><td>CELERY_MAX_CACHED_RESULTS</td><td>result_cache_max</td></tr><tr><td>CELERY_MESSAGE_COMPRESSION</td><td>result_compression</td></tr><tr><td>CELERY_RESULT_EXCHANGE</td><td>result_exchange</td></tr><tr><td>CELERY_RESULT_EXCHANGE_TYPE</td><td>result_exchange_type</td></tr><tr><td>CELERY_TASK_RESULT_EXPIRES</td><td>result_expires</td></tr><tr><td>CELERY_RESULT_PERSISTENT</td><td>result_persistent</td></tr><tr><td>CELERY_RESULT_SERIALIZER</td><td>result_serializer</td></tr><tr><td>CELERY_RESULT_DBURI</td><td>Use result_backend instead.</td></tr><tr><td>CELERY_RESULT_ENGINE_OPTIONS</td><td>database_engine_options</td></tr><tr><td>[…]_DB_SHORT_LIVED_SESSIONS</td><td>database_short_lived_sessions</td></tr><tr><td>CELERY_RESULT_DB_TABLE_NAMES</td><td>database_db_names</td></tr><tr><td>CELERY_SECURITY_CERTIFICATE</td><td>security_certificate</td></tr><tr><td>CELERY_SECURITY_CERT_STORE</td><td>security_cert_store</td></tr><tr><td>CELERY_SECURITY_KEY</td><td>security_key</td></tr><tr><td>CELERY_TASK_ACKS_LATE</td><td>task_acks_late</td></tr><tr><td>CELERY_TASK_ALWAYS_EAGER</td><td>task_always_eager</td></tr><tr><td>CELERY_TASK_ANNOTATIONS</td><td>task_annotations</td></tr><tr><td>CELERY_TASK_COMPRESSION</td><td>task_compression</td></tr><tr><td>CELERY_TASK_CREATE_MISSING_QUEUES</td><td>task_create_missing_queues</td></tr><tr><td>CELERY_TASK_DEFAULT_DELIVERY_MODE</td><td>task_default_delivery_mode</td></tr><tr><td>CELERY_TASK_DEFAULT_EXCHANGE</td><td>task_default_exchange</td></tr><tr><td>CELERY_TASK_DEFAULT_EXCHANGE_TYPE</td><td>task_default_exchange_type</td></tr><tr><td>CELERY_TASK_DEFAULT_QUEUE</td><td>task_default_queue</td></tr><tr><td>CELERY_TASK_DEFAULT_RATE_LIMIT</td><td>task_default_rate_limit</td></tr><tr><td>CELERY_TASK_DEFAULT_ROUTING_KEY</td><td>task_default_routing_key</td></tr><tr><td>CELERY_TASK_EAGER_PROPAGATES</td><td>task_eager_propagates</td></tr><tr><td>CELERY_TASK_IGNORE_RESULT</td><td>task_ignore_result</td></tr><tr><td>CELERY_TASK_PUBLISH_RETRY</td><td>task_publish_retry</td></tr><tr><td>CELERY_TASK_PUBLISH_RETRY_POLICY</td><td>task_publish_retry_policy</td></tr><tr><td>CELERY_TASK_QUEUES</td><td>task_queues</td></tr><tr><td>CELERY_TASK_ROUTES</td><td>task_routes</td></tr><tr><td>CELERY_TASK_SEND_SENT_EVENT</td><td>task_send_sent_event</td></tr><tr><td>CELERY_TASK_SERIALIZER</td><td>task_serializer</td></tr><tr><td>CELERYD_TASK_SOFT_TIME_LIMIT</td><td>task_soft_time_limit</td></tr><tr><td>CELERYD_TASK_TIME_LIMIT</td><td>task_time_limit</td></tr><tr><td>CELERY_TRACK_STARTED</td><td>task_track_started</td></tr><tr><td>CELERYD_AGENT</td><td>worker_agent</td></tr><tr><td>CELERYD_AUTOSCALER</td><td>worker_autoscaler</td></tr><tr><td>CELERYD_CONCURRENCY</td><td>worker_concurrency</td></tr><tr><td>CELERYD_CONSUMER</td><td>worker_consumer</td></tr><tr><td>CELERY_WORKER_DIRECT</td><td>worker_direct</td></tr><tr><td>CELERY_DISABLE_RATE_LIMITS</td><td>worker_disable_rate_limits</td></tr><tr><td>CELERY_ENABLE_REMOTE_CONTROL</td><td>worker_enable_remote_control</td></tr><tr><td>CELERYD_HIJACK_ROOT_LOGGER</td><td>worker_hijack_root_logger</td></tr><tr><td>CELERYD_LOG_COLOR</td><td>worker_log_color</td></tr><tr><td>CELERYD_LOG_FORMAT</td><td>worker_log_format</td></tr><tr><td>CELERYD_WORKER_LOST_WAIT</td><td>worker_lost_wait</td></tr><tr><td>CELERYD_MAX_TASKS_PER_CHILD</td><td>worker_max_tasks_per_child</td></tr><tr><td>CELERYD_POOL</td><td>worker_pool</td></tr><tr><td>CELERYD_POOL_PUTLOCKS</td><td>worker_pool_putlocks</td></tr><tr><td>CELERYD_POOL_RESTARTS</td><td>worker_pool_restarts</td></tr><tr><td>CELERYD_PREFETCH_MULTIPLIER</td><td>worker_prefetch_multiplier</td></tr><tr><td>CELERYD_REDIRECT_STDOUTS</td><td>worker_redirect_stdouts</td></tr><tr><td>CELERYD_REDIRECT_STDOUTS_LEVEL</td><td>worker_redirect_stdouts_level</td></tr><tr><td>CELERYD_SEND_EVENTS</td><td>worker_send_task_events</td></tr><tr><td>CELERYD_STATE_DB</td><td>worker_state_db</td></tr><tr><td>CELERYD_TASK_LOG_FORMAT</td><td>worker_task_log_format</td></tr><tr><td>CELERYD_TIMER</td><td>worker_timer</td></tr><tr><td>CELERYD_TIMER_PRECISION</td><td>worker_timer_precision</td></tr></tbody></table> 
<h3 id="配置指示">配置指示</h3> 
<h4 id="通用设置">通用设置</h4> 
<ul><li>accept_content <br> 默认值: {‘json’} (set, list, or tuple). <br> 允许的内容类型/序列化器的白名单</li></ul> 
<p>如果接收到一个消息，其内容类型不再上述列表中，它将会被丢弃并抛出一个错误。</p> 
<p>默认情况下，任意内容类型都是启用的，包括pickle以及yaml，所以确保不受信任的第三方不能访问你的消息中间件。查看安全这一节获取更多信息。</p> 
<p>示例：</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor"># using serializer name</span>
accept_content = [<span class="hljs-string">'json'</span>]

<span class="hljs-preprocessor"># or the actual content-type (MIME)</span>
accept_content = [<span class="hljs-string">'application/json'</span>]</code></pre> 
<h4 id="时间与日期设置">时间与日期设置</h4> 
<ul><li>enable_utc <br> 2.5 版本新特性。 <br> 默认值：从 3.0 版本开始默认启用</li></ul> 
<p>一旦启用，消息中的日期和时间将会转化成 UTC 时区。</p> 
<p>注意2.5版本以下的工作单元将会认为所有消息都使用的本地时区，所以只有在所有的工作单元都升级了的情况下再启用这个特性。</p> 
<ul><li>timezone <br> 2.5版本新特性 <br> 默认值： “UTC”</li></ul> 
<p>设置Celery使用一个自定义的时区。这个时区值可以是pytz库支持的任意时区。</p> 
<p>如果没有设置，UTC时区将被使用。为了向后兼容，还提供了一个 enable_utc设置，如果他设置成假，将使用系统本地时区。</p> 
<h4 id="任务设置">任务设置</h4> 
<ul><li>task_annotations <br> 这个设置可以用来在配置文件中重写任意任务属性。这个设置可以是一个字典，获取一个annotation对象的列表，这个列表对任务进行过滤，对匹配的任务名称起作用，并返回待更改属性的一个映射。</li></ul> 
<p>以下将更改 tasks.add 任务的 rate_limit 属性：</p> 
<p>task_annotations = {‘tasks.add’: {‘rate_limit’: ‘10/s’}} <br> 或者对所有的任务更改：</p> 
<p>task_annotations = {‘*’: {‘rate_limit’: ‘10/s’}} <br> 你还可以更改方法，例如 on_failure 处理函数：</p> 
<p>def my_on_failure(self, exc, task_id, args, kwargs, einfo): <br> print(‘Oh no! Task failed: {0!r}’.format(exc))</p> 
<p>task_annotations = {‘*’: {‘on_failure’: my_on_failure}} <br> 如果你需要更灵活的控制，那么你可以使用对象而不是字典来选择任务来进行注解：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAnnotate</span><span class="hljs-params">(object)</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">annotate</span><span class="hljs-params">(self, task)</span>:</span>
        <span class="hljs-keyword">if</span> task.name.startswith(<span class="hljs-string">'tasks.'</span>):
            <span class="hljs-keyword">return</span> {<!-- --><span class="hljs-string">'rate_limit'</span>: <span class="hljs-string">'10/s'</span>}

task_annotations = (MyAnnotate(), {other,})</code></pre> 
<ul><li>task_compression <br> 默认值： None <br> 任务消息的默认压缩算法。可以是 gzip、bzip2(如果可用)，或者任意在 Kombu 压缩模式注册表中注册的自定义压缩算法。</li></ul> 
<p>默认发送未压缩的消息。</p> 
<ul><li>task_protocol <br> 默认值：2(从4.0版本开始) <br> 设置默认的任务消息协议版本。支持的协议：1 和 2</li></ul> 
<p>协议 2 在 3.1.24 以及 4.x+ 被支持</p> 
<ul><li>task_serializer <br> 默认值：“json”(从4.0版本开始，更早:pickle) <br> 一个表示使用的默认序列化方法的字符串。可以是 json(默认)、pickle、 yaml、msgpack，或者任意在 kombu.serialization.registry 中注册过的自定义序列化方法。</li></ul> 
<p>另见： <br> Serializers</p> 
<ul><li>task_publish_retry <br> 2.2版本新特性 <br> 默认值：启用</li></ul> 
<p>决定当连接丢失或者其他连接错误时任务消息的发布是否会重试，查看 task_publish_retry_policy。</p> 
<ul><li>task_publish_retry_policy <br> 2.2版本新特性 <br> 默认值：查看 Message Sending Retry。</li></ul> 
<p>定义当连接丢失或者其他连接错误时任务消息的发布重试策略。</p> 
<h4 id="任务执行设置">任务执行设置</h4> 
<ul><li>task_always_eager <br> 默认值：禁用 <br> 如果设置成 True，所有的任务都将在本地执行知道任务返回。apply_async() 以及Task.delay()将返回一个 EagerResult 实例，模拟AsyncResult实例的API和行为，除了这个结果是已经计算过的之外。</li></ul> 
<p>也就是说，任务将会在本地执行而不是发送到队列。</p> 
<ul><li>task_eager_propagates <br> 默认值：禁用 <br> 如果设置成 True，本地执行的任务（使用 task.apply()，或者 task_always_eager 被启用）将传递异常。</li></ul> 
<p>这与使用 apply() 带 throw=True 参数有同样的效果。</p> 
<ul><li>task_remote_tracebacks <br> 默认值：禁用 <br> 如果启用了，当重新抛出任务错误时，任务结果将会包括工作单元的堆栈信息。</li></ul> 
<p>它需要 tblib 库，可以通过 pip 安装：</p> 
<p>$ pip install celery[tblib] <br> 查看 Bundles 获取关于组合多个扩展需求的信息。</p> 
<ul><li><p>task_ignore_result <br> 默认值：禁用 <br> 是否存储任务返回值（tombstones）。如果你只是想在发生错误的时候记录返回值，可以设置:task_store_errors_even_if_ignored</p></li><li><p>task_store_errors_even_if_ignored <br> 默认值：禁用 <br> 如果设置了，即使 Task.ignore_result 启用了，工作单元也会爱结果后端中存储所有的任务错误。</p></li><li><p>task_track_started <br> 默认值：禁用 <br> 如果设置成真，当任务被工作单元执行时，任务将报告它的状态为started。默认值是假，因为通常行为是不做这种粒度级别的汇报。任务会处于 pending、finished 或者 waiting to be retried。当有长时间任务，并且需要知道当前正在运行什么任务时，有一个 started状态将会很有用。</p></li><li><p>task_time_limit <br> 默认值：没有时间限制 <br> 任务的硬时间限制，以秒为单位。如果这个时间限制被超过，处理任务的工作单元进程将会被杀死并使用一个新的替代。</p></li><li><p>task_soft_time_limit <br> 默认值：没有时间限制 <br> 任务的软时间限制，以秒为单位</p></li></ul> 
<p>当这个时间限制超过后，SoftTimeLimitExceeded异常将会被抛出。例如，任务可以捕获这个异常在硬时间限制到达之前对环境进行清理：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">from</span> celery.exceptions <span class="hljs-keyword">import</span> SoftTimeLimitExceeded

<span class="hljs-decorator">@app.task</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mytask</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">return</span> do_work()
    <span class="hljs-keyword">except</span> SoftTimeLimitExceeded:
        cleanup_in_a_hurry()</code></pre> 
<ul><li>task_acks_late <br> 默认值：禁用 <br> 延迟确认意味着任务消息将在任务执行完成之后再进行确认，而不是刚开始时（默认行为）。</li></ul> 
<p>另见： <br> FAQ： Shoud I use retry or acks_late</p> 
<ul><li>task_reject_on_worker_lost <br> 默认值：禁用 <br> 即使 task_acks_late 被启用，当处理任务的工作单元异常退出或者收到信号而退出时工作单元将会确认任务消息。</li></ul> 
<p>将这个设置成真可以让消息重新入队，所以任务将会被再执行，在同一个工作单元或者另外一个工作单元。</p> 
<p>告警： <br> 启用这个可能导致消息循环；确保你知道你在做什么</p> 
<ul><li>task_default_rate_limit <br> 默认值：没有速率限制 <br> 任务的全局默认速率限制</li></ul> 
<p>当任务没有一个自定义的速率限制时，这个值将被使用</p> 
<p>另见： <br> worker_disable_rate_limits 设置可以禁用所有的速率限制</p> 
<h4 id="任务结果后端设置">任务结果后端设置</h4> 
<ul><li><p>result_backend <br> 默认值：默认不启用结果后端 <br> 用来存储结果的后端。可以是下列之一：</p> 
  <ol><li><p>rpc <br> 以 AMQP 消息形式发送结果。查看 RPC 后端设置</p></li><li><p>database <br> 使用一个 SQLAlchemy 支持的结构化数据库。查看数据库后端设置</p></li><li><p>redis <br> 使用 Redis 存储结果。查看 Redis 后端设置</p></li><li><p>cache <br> 使用 Memcached 存储结果。查看 Cache 后端设置</p></li><li><p>cassandra <br> 使用 Cassandra 存储结果。查看 Cassandra 后端设置</p></li><li><p>elasticsearch <br> 使用 Elasticsearch 存储结果。查看 Elasticsearch 后端设置</p></li><li><p>ironcache <br> 使用 IronCache 存储结果。查看 IronCache 后端设置</p></li><li><p>couchbase <br> 使用 Couchbase 存储结果。查看 Couchbase 后端设置</p></li><li><p>couchdb <br> 使用 CouchDB 存储结果。查看 CouchDB 后端设置</p></li><li><p>filesystem <br> 使用共享文件夹存储结果。查看 File-system 后端设置</p></li><li><p>consul <br> 使用 Consul K/V 存储结果。查看 Consul K/V 后端设置</p></li></ol></li><li><p>result_serializer <br> 默认值：从4.0版本开始使用 json(更早：pickle) <br> 查看 Serializers 获取支持的序列化格式的信息。</p></li><li><p>result_compression <br> 默认值：无压缩 <br> 结果值得可选压缩方法。支持 task_seralizer 设置相同的选项。</p></li><li><p>result_expires <br> 默认值：1天后过期 <br> 存储的结果被删除的时间（秒数，或者一个 timedelta 对象）</p></li></ul> 
<p>有一个内建的周期性任务将删除过期的任务结果（celery.backend_cleanup），前提是 celery beat 已经被启用。这个任务每天上午4点运行。</p> 
<p>值 None 或者 0 意思是结果永不删除（取决于后端声明）</p> 
<p>注意： <br> 当前这个特性只支持 AMQP, database, cache, Redis 这些存储后端。当使用 database 存储后端，celery beat必须执行使得过期结果被删除。</p> 
<ul><li>result_cache_max <br> 默认值：默认禁用 <br> 启用结果的客户端缓存。</li></ul> 
<p>对于老的 amqp 后端，存储结果一旦被消费它将不再可用，此时这个特性将起到作用。</p> 
<p>这是老的结果被删除之前总的结果缓存的数量。值 0 或者 None 意味着没有限制，并且值 -1 将禁用缓存。</p> 
<h4 id="database-后端设置">Database 后端设置</h4> 
<p>Database URL 示例</p> 
<p>使用一个数据库存储后端，你必须配置 result_backend 设置为一个连接的URL，并且带 db+ 前缀：</p> 
<pre class="prettyprint"><code class=" hljs vhdl">result_backend = <span class="hljs-attribute">'db</span>+scheme://user:password@host:<span class="hljs-keyword">port</span>/dbname'</code></pre> 
<p>示例：</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor"># sqlite (filename)</span>
result_backend = <span class="hljs-string">'db+sqlite:///results.sqlite'</span>

<span class="hljs-preprocessor"># mysql</span>
result_backend = <span class="hljs-string">'db+mysql://scott:tiger@localhost/foo'</span>

<span class="hljs-preprocessor"># postgresql</span>
result_backend = <span class="hljs-string">'db+postgresql://scott:tiger@localhost/mydatabase'</span>

<span class="hljs-preprocessor"># oracle</span>
result_backend = <span class="hljs-string">'db+oracle://scott:tiger@127.0.0.1:1521/sidname'</span></code></pre> 
<p>查看 Supported Databases 获取支持的数据库的一个表，查看 Connection String 获取相关的连接字符串（这是 db+ 前缀后带的URI的一部分）</p> 
<ul><li>database_engine_options <br> 默认值：{} （空映射） <br> 你可以使用 sqlalchmey_engine_options 设置声明额外的 SQLAchemy 数据库引擎选项：</li></ul> 
<pre class="prettyprint"><code class=" hljs php"><span class="hljs-comment"># echo enables verbose logging from SQLAlchemy.</span>
app.conf.database_engine_options = {<!-- --><span class="hljs-string">'echo'</span>: <span class="hljs-keyword">True</span>}</code></pre> 
<ul><li><p>database_short_lived_sessions <br> 默认值：默认禁用 <br> 默认禁用短会话。如果启用了，他们会急剧的降低性能，特别是对于处理很多任务的系统。当工作单元的流量很低，缓存的数据库连接会由于空闲而变为无用，进而会导致工作单元出错，这种情况下这个选项是有用的。例如：间歇性的错误如（OperationalError）（2006, ‘MySQL server has gone away’）通过启用短会话能解决。这个选项只影响数据库后端。</p></li><li><p>database_table_names <br> 默认值：{} (空映射) <br> 当 SQLAlchemy 设置成结果后端， Celery 自动创建两个表来存储任务的元数据。这个设置允许你自定义表名称：</p></li></ul> 
<pre class="prettyprint"><code class=" hljs rust"># <span class="hljs-keyword">use</span> custom table names <span class="hljs-keyword">for</span> the database result backend.
database_table_names = {
    <span class="hljs-string">'task'</span>: <span class="hljs-string">'myapp_taskmeta'</span>,
    <span class="hljs-string">'group'</span>: <span class="hljs-string">'myapp_groupmeta'</span>,
}</code></pre> 
<h4 id="rpc-后端设置">RPC 后端设置</h4> 
<ul><li>result_persistent <br> 默认值：默认被禁用（瞬态消息） <br> 如果设置成真，结果消息将被持久化。这意味着消息中间件重启后消息不会丢失。</li></ul> 
<p>配置示例：</p> 
<pre class="prettyprint"><code class=" hljs ini"><span class="hljs-setting">result_backend = <span class="hljs-value">'rpc://'</span></span>
<span class="hljs-setting">result_persistent = <span class="hljs-value"><span class="hljs-keyword">False</span></span></span></code></pre> 
<h4 id="cache-后端设置">Cache 后端设置</h4> 
<p>注意： <br> 缓存后端支持 pylibmc 和 python-memcached 库。后者只有在 pylibmc 没有安装时才会被使用。</p> 
<p>使用一个 Memcached 服务器：</p> 
<pre class="prettyprint"><code class=" hljs bash">result_backend = <span class="hljs-string">'cache+memcached://127.0.0.1:11211/'</span></code></pre> 
<p>使用多个 Memcached 服务器：</p> 
<pre class="prettyprint"><code class=" hljs python">result_backend = <span class="hljs-string">"""
    cache+memcached://172.19.26.240:11211;172.19.26.242:11211/
"""</span>.strip()</code></pre> 
<p>“memory” 后端只在内存中存储缓存：</p> 
<pre class="prettyprint"><code class=" hljs bash">result_backend = <span class="hljs-string">'cache'</span>
cache_backend = <span class="hljs-string">'memory'</span></code></pre> 
<ul><li>cache_backend_options <br> 默认值：{} (空映射) <br> 你可以使用 cache_backend_options 设置 pylibmc 选项：</li></ul> 
<pre class="prettyprint"><code class=" hljs php">cache_backend_options = {
    <span class="hljs-string">'binary'</span>: <span class="hljs-keyword">True</span>,
    <span class="hljs-string">'behaviors'</span>: {<!-- --><span class="hljs-string">'tcp_nodelay'</span>: <span class="hljs-keyword">True</span>},
}</code></pre> 
<ul><li>cache_backend <br> 这个设置不再使用了，因为现在可以直接在 result_backend 中设置后端存储。</li></ul> 
<h4 id="redis-后端设置">Redis 后端设置</h4> 
<h5 id="配置后端-url">配置后端 URL</h5> 
<p>注意： <br> Redis 后端需要 Redis 库。</p> 
<p>可以使用 pip 安装这个包：</p> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>pip install celery[redis]</code></pre> 
<p>查看 Bundles 获取组合多个扩展需求的信息</p> 
<p>后端需要 result_backend 设置成一个 Redis URL:</p> 
<pre class="prettyprint"><code class=" hljs vhdl">result_backend = <span class="hljs-attribute">'redis</span>://:password@host:<span class="hljs-keyword">port</span>/db'</code></pre> 
<p>例如：</p> 
<pre class="prettyprint"><code class=" hljs bash">result_backend = <span class="hljs-string">'redis://localhost/0'</span></code></pre> 
<p>等同于：</p> 
<pre class="prettyprint"><code class=" hljs bash">result_backend = <span class="hljs-string">'redis://'</span></code></pre> 
<p>URL 的字段如下定义： <br> 1. password <br> 连接数据库的密码 <br> 2. host <br> Redis 服务器的主机名或者IP地址（例如：localhost） <br> 3. port <br> Redis 服务器的端口。默认是 6379 <br> 4. db <br> 使用的数据库编号。默认是0。db 可以包含一个可选的斜杠</p> 
<ul><li><p>redis_backend_us_ssl <br> 默认值：禁用 <br> Redis后端支持 SSL。这个选项的合法值与 broker_use_ssl 相同</p></li><li><p>redis_max_connections <br> 默认值：无显示 <br> Redis 连接池的最大可用连接数，这些连接用来发送和接收结果</p></li><li><p>redis_socket_connect_timeout <br> 5.0.1版本新特性 <br> 默认值：None</p></li></ul> 
<p>从存储后端连接到Redis服务器的连接的Socket超时时间（以秒为单位，int/float）</p> 
<ul><li>redis_socket_timeout <br> 默认值：120秒 <br> 对 Redis 服务器的读写操作的 Socket 超时时间（以秒为单位，int/float），由存储后端使用</li></ul> 
<p>Cassandra 后端设置</p> 
<p>注意： <br> Cassandra 后端驱动 cassandra-driver。</p> 
<p>使用 pip 安装：</p> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>pip install celery[cassandra]</code></pre> 
<p>查看 Bundles 获取关于组合扩展需求的信息。</p> 
<p>后端需要配置下列配置指令</p> 
<ul><li>cassandra_servers <br> 默认值： [] (空列表) <br> Cassandra 服务器列表。例如:</li></ul> 
<pre class="prettyprint"><code class=" hljs bash">cassandra_servers = [<span class="hljs-string">'localhost'</span>]</code></pre> 
<ul><li><p>cassandra_port <br> 默认值：9042. <br> 连接到Cassandra服务器的端口</p></li><li><p>cassandra_keyspace <br> 默认值: None. <br> 存储结果的 key-space。例如:</p></li></ul> 
<pre class="prettyprint"><code class=" hljs bash">cassandra_keyspace = <span class="hljs-string">'tasks_keyspace'</span></code></pre> 
<ul><li>cassandra_table <br> 默认值: None. <br> 存储结果的表（列族）。例如:</li></ul> 
<pre class="prettyprint"><code class=" hljs bash">cassandra_table = <span class="hljs-string">'tasks'</span></code></pre> 
<ul><li><p>cassandra_read_consistency <br> 默认值: None. <br> 使用的读一致性。值可以是 ONE, TWO, THREE, QUORUM, ALL, LOCAL_QUORUM, EACH_QUORUM, LOCAL_ONE</p></li><li><p>cassandra_write_consistency <br> 默认值: None. <br> 使用的写一致性。值可以是 ONE, TWO, THREE, QUORUM, ALL, LOCAL_QUORUM, EACH_QUORUM, LOCAL_ONE</p></li><li><p>cassandra_entry_ttl <br> 默认值: None. <br> 状态项的 Time-to-live。添加过后一段时间他们将会过期并且被删除。值 None (默认) 意味着他们永不过期</p></li><li><p>cassandra_auth_provider <br> 默认值: None. <br> 使用的 cassandra.auth 模块中的 AuthProvider。 值可以是 PlainTextAuthProvider 或者 SaslAuthProvider</p></li><li><p>cassandra_auth_kwargs <br> 默认值: {} (空映射) <br> 传递给 authentication provider 的命名参数。例如:</p></li></ul> 
<pre class="prettyprint"><code class=" hljs bash">cassandra_auth_kwargs = {
    username: <span class="hljs-string">'cassandra'</span>,
    password: <span class="hljs-string">'cassandra'</span>
}</code></pre> 
<p>配置示例：</p> 
<pre class="prettyprint"><code class=" hljs bash">cassandra_servers = [<span class="hljs-string">'localhost'</span>]
cassandra_keyspace = <span class="hljs-string">'celery'</span>
cassandra_table = <span class="hljs-string">'tasks'</span>
cassandra_<span class="hljs-built_in">read</span>_consistency = <span class="hljs-string">'ONE'</span>
cassandra_write_consistency = <span class="hljs-string">'ONE'</span>
cassandra_entry_ttl = <span class="hljs-number">86400</span></code></pre> 
<h4 id="elasticsearch-后端设置">Elasticsearch 后端设置</h4> 
<p>使用 Elasticsearch 作为结果后端，你只需要将result_backend设置成正确的 URL。</p> 
<p>配置示例：</p> 
<pre class="prettyprint"><code class=" hljs bash">result_backend = <span class="hljs-string">'elasticsearch://example.com:9200/index_name/doc_type'</span></code></pre> 
<ul><li><p>elasticsearch_retry_on_timeout <br> 默认值: False <br> 超时后是否应该触发在另一个节点重试?</p></li><li><p>elasticsearch_max_retries <br> 默认值: 3 <br> 异常被传递前的最大重试次数</p></li><li><p>elasticsearch_timeout <br> 默认值: 10.0 秒 <br> elasticsearch 使用的全局超时时间</p></li></ul> 
<h4 id="riak-后端设置">Riak 后端设置</h4> 
<p>注意： <br> Riak 后端需要 riak 库</p> 
<p>使用 pip 进行安装：</p> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>pip install celery[riak]</code></pre> 
<p>查看 Bundles 获取组合多扩展需求的信息。</p> 
<p>后端需要result_backend设置成一个 Riak URL:</p> 
<pre class="prettyprint"><code class=" hljs vhdl">result_backend = <span class="hljs-attribute">'riak</span>://host:<span class="hljs-keyword">port</span>/bucket'</code></pre> 
<p>例如：</p> 
<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">result_backend </span>=<span class="hljs-string"> 'riak://localhost/celery</span></code></pre> 
<p>等同于：</p> 
<pre class="prettyprint"><code class=" hljs bash">result_backend = <span class="hljs-string">'riak://'</span></code></pre> 
<p>URL 的字段定义如下： <br> 1. host <br> Riak 服务器的主机名或者IP地址（例如 localhost） <br> 2. port <br> 使用 protobuf 协议的Riak 服务器端口，默认是 8087 <br> 3. bucket <br> 使用的Bucket名称。默认是 celery。bucket 名称需要是一个只包含ASCII字符的字符串。</p> 
<p>另外，这个后端可以使用如下配置指令进行配置：</p> 
<ul><li><p>riak_backend_settings <br> 默认值: {} (空映射) <br> 这是一个支持如下键的映射:</p> 
  <ol><li><p>host <br> Riak 服务器的主机名或者IP地址（例如 localhost）</p></li><li><p>port <br> Riak 服务器端口。默认是 8087</p></li><li><p>bucket <br> 使用的Bucket名称。默认是 celery。bucket 名称需要是一个只包含ASCII字符的字符串。</p></li><li><p>protocol <br> 连接到 Riak 服务器使用的协议。这不可以通过 result_backend 配置</p></li></ol></li></ul> 
<h4 id="aws-dynamodb-后端设置">AWS DynamoDB 后端设置</h4> 
<p>注意： <br> Dynamodb 后端需要 boto3 库</p> 
<p>使用 pip 进行安装：</p> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>pip install celery[dynamodb]</code></pre> 
<p>查看 Bundles 获取组合多扩展需求的信息。</p> 
<p>后端需要 result_backend 设置成一个 DynamoDB URL：</p> 
<pre class="prettyprint"><code class=" hljs vhdl">result_backend = <span class="hljs-attribute">'dynamodb</span>://aws_access_key_id:aws_secret_access_key@region:<span class="hljs-keyword">port</span>/table?read=n&amp;write=m'</code></pre> 
<p>例如，声明 AWS 区域以及表名称：</p> 
<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">result_backend </span>=<span class="hljs-string"> 'dynamodb://@us-east-1/celery_results</span></code></pre> 
<p>或者从环境中获取 AWS 配置参数，使用默认表名称（celery）以及声明读写吞吐量：</p> 
<pre class="prettyprint"><code class=" hljs bash">result_backend = <span class="hljs-string">'dynamodb://@/?read=5&amp;write=5'</span></code></pre> 
<p>或者在本地使用 DynamoDB 的可下载版本：</p> 
<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">result_backend </span>=<span class="hljs-string"> 'dynamodb://@localhost:8000</span></code></pre> 
<p>URL 中的字段如下定义：</p> 
<ol><li><p>aws_access_key_id &amp; aws_secret_access_key <br> 访问 AWS API 资源的认证信息。这可以通过 boto3 从不同的源获取到</p></li><li><p>region <br> AWS 区域，例如： us-east-1 或者本地版本的 localhost。查看 boto3 库文档获取更多的信息。</p></li><li><p>port <br> 如果你使用的本地版本，这是本地DynamoDB示例监听的端口。如果你没有把区域设置成 localhost，这个设置选项将无效</p></li><li><p>table <br> 使用的表名。默认是 celery。查看 DynamoDB 命名规则获取允许的字符以及表名长度的信息。</p></li><li><p>read &amp; write <br> 所创建的 DynamoBD 表的读写能力单元。默认的读写值都是 1。更多的细节可以从 Provisioned Throughput documentation 中获取到。</p></li></ol> 
<h4 id="ironcache-后端设置">IronCache 后端设置</h4> 
<p>注意： <br> IronCache 后端需要 iron_celery 库：</p> 
<p>使用 pip 进行安装：</p> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>pip install iron_celery</code></pre> 
<p>IronCache 通过在 result_backend 中配置的 URL 进行声明，例如：</p> 
<pre class="prettyprint"><code class=" hljs bash">result_backend = <span class="hljs-string">'ironcache://project_id:token@'</span></code></pre> 
<p>或者更改缓存名称：</p> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-symbol">ironcache:</span><span class="hljs-symbol">://project_id</span><span class="hljs-symbol">:token</span>@/awesomecache</code></pre> 
<p>更多的信息，查看 <a href="https://github.com/iron-io/iron_celery" target="_blank" rel="noopener noreferrer">https://github.com/iron-io/iron_celery</a></p> 
<h4 id="couchbase-后端设置">Couchbase 后端设置</h4> 
<p>注意： <br> Couchbase 后端需要 couchbase 库</p> 
<p>使用 pip 进行安装：</p> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>pip install celery[couchbase]</code></pre> 
<p>查看 Bundle 获取组合多扩展需求的步骤。</p> 
<p>后端可以通过 result_backend 设置成一个 Couchbase URL:</p> 
<pre class="prettyprint"><code class=" hljs vhdl">result_backend = <span class="hljs-attribute">'couchbase</span>://username:password@host:<span class="hljs-keyword">port</span>/bucket'</code></pre> 
<ul><li>couchbase_backend_settings</li></ul> 
<p>默认值：{} （空映射）</p> 
<p>这是一个支持如下键的映射：</p> 
<ol><li>host <br> Couchbase 服务器的主机名。默认是 localhost</li><li>port <br> Couchbase 服务器监听的端口。默认是 8091</li><li>bucket <br> Couchbase 服务器默认写入的桶。默认是default</li><li>username <br> Couchbase 服务器认证的用户名（可选）</li><li>password <br> Couchbase 服务器认证的密码（可选）</li></ol> 
<h4 id="couchdb-后端设置">CouchDB 后端设置</h4> 
<p>注意： <br> CouchDB 后端需要 pycouchdb 库: <br> 使用 pip 安装这个包：</p> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>pip install celery[couchdb]</code></pre> 
<p>查看 Bundles 获取更多关于组合多扩展需求的信息</p> 
<p>后端可以通过 result_backend 配置成一个 CouchDB URL:</p> 
<pre class="prettyprint"><code class=" hljs vhdl">result_backend = <span class="hljs-attribute">'couchdb</span>://username:password@host:<span class="hljs-keyword">port</span>/container'</code></pre> 
<p>URL 由以下部分组成：</p> 
<ol><li>username <br> Couchbase 服务器认证的用户名（可选）</li><li>password <br> Couchbase 服务器认证的密码（可选）</li><li>host <br> Couchbase 服务器的主机名。默认是 localhost</li><li>port <br> Couchbase 服务器监听的端口。默认是 8091</li><li>container <br> CouchDB 服务器写入的默认容器。默认是 default</li></ol> 
<h4 id="file-system-后端设置">File-system 后端设置</h4> 
<p>后端可以通过一个文件 URL 配置，例如：</p> 
<pre class="prettyprint"><code class=" hljs bash">CELERY_RESULT_BACKEND = <span class="hljs-string">'file:///var/celery/results'</span></code></pre> 
<p>配置的目录需要被共享，并且所有使用该后端的服务器都可写。</p> 
<p>如果你在单独的一个系统上使用 Celery，你不需要任何进一步的配置就可以简单的使用这个后端。对于大型的集群，你可以使用 NFS、GlusterFS、CIFS、HDFS(使用FUSE)，或者其他文件系统。</p> 
<h4 id="consul-kv-存储后端设置">Consul K/V 存储后端设置</h4> 
<p>Consul 后端可以通过 URL 配置：</p> 
<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">CELERY_RESULT_BACKEND </span>=<span class="hljs-string"> ‘consul://localhost:8500/’</span></code></pre> 
<p>后端将在 Consul K/V 存储中作为单独键存储结果</p> 
<p>后端使用Consul 中的 TTLs 支持结果的自动过期</p> 
<h4 id="消息路由">消息路由</h4> 
<ul><li>task_queues <br> 默认值： None （默认队列的配置） <br> 多数用户不愿声明这个配置，而是使用 automatic routing facilites。</li></ul> 
<p>如果你真的需要配置高级路由，这个设置应该是一个 kombu.Queue 对象的列表，工作单元可以从中消费。</p> 
<p>注意工作单元可以通过 -Q 选项覆盖这个设置，或者这个列表中的单独队列可以通过 -X 选项进行排除。</p> 
<p>查看 Basics 获取更多的信息。</p> 
<p>默认值是 celery 队列的一个队列/消息交换器/绑定的键，消息交互类型是direct。</p> 
<p>查看 task_routes</p> 
<ul><li>task_routes <br> 默认值： None <br> 一个路由器的列表，或者单个路路由，用来路由任务到相应的队列。当决定一个任务的最终目的，路由器将按声明顺序进行轮询。</li></ul> 
<p>一个路由器可以通过如下方式声明：</p> 
<ol><li>函数，签名格式为 <code>(name, args, kwargs, options, task=None, **kwargs)</code></li><li>字符串，提供到路由函数的路径</li><li>字典，包含路由声明，它将会转化成一个 <code>celery.routes.MapRoute</code> 实例</li><li>一个 <code>(pattern, route)</code> 元组的列表，它将会转化成一个 <code>celery.routes.MapRoute</code> 实例 <br> 示例：</li></ol> 
<pre class="prettyprint"><code class=" hljs php">task_routes = {
    <span class="hljs-string">'celery.ping'</span>: <span class="hljs-string">'default'</span>,
    <span class="hljs-string">'mytasks.add'</span>: <span class="hljs-string">'cpu-bound'</span>,
    <span class="hljs-string">'feed.tasks.*'</span>: <span class="hljs-string">'feeds'</span>,                           <span class="hljs-comment"># &lt;-- glob pattern</span>
    re.compile(r<span class="hljs-string">'(image|video)\.tasks\..*'</span>): <span class="hljs-string">'media'</span>,  <span class="hljs-comment"># &lt;-- regex</span>
    <span class="hljs-string">'video.encode'</span>: {
        <span class="hljs-string">'queue'</span>: <span class="hljs-string">'video'</span>,
        <span class="hljs-string">'exchange'</span>: <span class="hljs-string">'media'</span>
        <span class="hljs-string">'routing_key'</span>: <span class="hljs-string">'media.video.encode'</span>,
    },
}

task_routes = (<span class="hljs-string">'myapp.tasks.route_task'</span>, {<!-- --><span class="hljs-string">'celery.ping'</span>: <span class="hljs-string">'default})
其中，myapp.tasks.route_task 可以是：

def route_task(self, name, args, kwargs, options, task=None, **kw):
        if task == '</span>celery.ping<span class="hljs-string">':
            return {'</span>queue<span class="hljs-string">': '</span><span class="hljs-keyword">default</span><span class="hljs-string">'}</span></code></pre> 
<p>route_task 可以返回一个字符串或者一个字典。一个字符串表示 task_queues 中的一个队列名，而字典表示一个自定义的路由。</p> 
<p>当发送消息，路由被按顺序询问。第一个返回非 None 值得路由将被使用。消息选项此时将与找到的路由设置合并，其中路由器的设置要优先。</p> 
<p>例如： apply_async() 有这些参数：</p> 
<pre class="prettyprint"><code class=" hljs handlebars"><span class="xml"><span class="hljs-tag"><span class="hljs-attribute">Task.apply_async</span>(<span class="hljs-attribute">immediate</span>=<span class="hljs-value">False,</span> <span class="hljs-attribute">exchange</span>=<span class="hljs-value">'video'</span><span class="hljs-value">,</span>
                 <span class="hljs-attribute">routing_key</span>=<span class="hljs-value">'video.compress'</span><span class="hljs-value">)</span></span></span></code></pre> 
<p>并且有一个路由器返回：</p> 
<pre class="prettyprint"><code class=" hljs php">{<!-- --><span class="hljs-string">'immediate'</span>: <span class="hljs-keyword">True</span>, <span class="hljs-string">'exchange'</span>: <span class="hljs-string">'urgent'</span>}</code></pre> 
<p>那么最终的消息选项将是：</p> 
<pre class="prettyprint"><code class=" hljs handlebars"><span class="xml"><span class="hljs-tag"><span class="hljs-attribute">immediate</span>=<span class="hljs-value">True,</span> <span class="hljs-attribute">exchange</span>=<span class="hljs-value">'urgent'</span><span class="hljs-value">,</span> <span class="hljs-attribute">routing_key</span>=<span class="hljs-value">'video.compress'</span></span></span></code></pre> 
<p>（以及Task类中定义的任意默认消息选项）</p> 
<p>当进行合并时，task_routes 中定义的值会优先于 task_queues 中定义的值。</p> 
<p>对于如下设置：</p> 
<pre class="prettyprint"><code class=" hljs bash">task_queues = {
    <span class="hljs-string">'cpubound'</span>: {
        <span class="hljs-string">'exchange'</span>: <span class="hljs-string">'cpubound'</span>,
        <span class="hljs-string">'routing_key'</span>: <span class="hljs-string">'cpubound'</span>,
    },
}

task_routes = {
    <span class="hljs-string">'tasks.add'</span>: {
        <span class="hljs-string">'queue'</span>: <span class="hljs-string">'cpubound'</span>,
        <span class="hljs-string">'routing_key'</span>: <span class="hljs-string">'tasks.add'</span>,
        <span class="hljs-string">'serializer'</span>: <span class="hljs-string">'json'</span>,
    },
}</code></pre> 
<p>tasks.add 的最终路由选项将变为：</p> 
<pre class="prettyprint"><code class=" hljs bash">{<!-- --><span class="hljs-string">'exchange'</span>: <span class="hljs-string">'cpubound'</span>,
 <span class="hljs-string">'routing_key'</span>: <span class="hljs-string">'tasks.add'</span>,
 <span class="hljs-string">'serializer'</span>: <span class="hljs-string">'json'</span>}</code></pre> 
<p>查看路由器获取更多的示例。</p> 
<ul><li>task_queue_ha_policy <br> 消息中间件： RabbitMQ <br> 默认值：None <br> 这将设置一个队列的HA策略，并且值可以是一个字符串（通常是 all）</li></ul> 
<pre class="prettyprint"><code class=" hljs bash">task_queue_ha_policy = <span class="hljs-string">'all'</span></code></pre> 
<p>使用 all 将复制队列到所有的当前节点，或者你指定一个节点的列表：</p> 
<pre class="prettyprint"><code class=" hljs nginx"><span class="hljs-title">task_queue_ha_policy</span> = [<span class="hljs-string">'rabbit<span class="hljs-variable">@host1</span>'</span>, <span class="hljs-string">'rabbit<span class="hljs-variable">@host2</span>'</span>]</code></pre> 
<p>使用一个列表将隐示设置 x-ha-policy为‘nodes，x-ha-policy-params` 为给定的节点列表</p> 
<p>查看 <a href="http://www.rabbitmq.com/ha.html" rel="nofollow noopener noreferrer" target="_blank">http://www.rabbitmq.com/ha.html</a> 获取更多的信息</p> 
<ul><li><p>task_queue_max_priority <br> 消息中间件： RabbitMQ <br> 默认值： None <br> 查看 RabbitMQ Message Priorities</p></li><li><p>worker_direct <br> 默认值： 禁用</p></li></ul> 
<p>这个选项使得每个工作单元又一个专门的队列，所以任务可以路由到指定的工作单元。</p> 
<p>每个工作单元的队列名称是基于工作单元主机名和一个 .dq后缀自动产生的，使用 C.dq 消息交互器。</p> 
<p>例如：节点名称为 w1@example.com 的工作单元的队列名称为：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">w1@example<span class="hljs-preprocessor">.com</span><span class="hljs-preprocessor">.dq</span></code></pre> 
<p>此时，你可以通过指定主机名为路由键并且使用 C.dq 消息交互器来将任务路由到指定的节点。</p> 
<pre class="prettyprint"><code class=" hljs bash">task_routes = {
    <span class="hljs-string">'tasks.add'</span>: {<!-- --><span class="hljs-string">'exchange'</span>: <span class="hljs-string">'C.dq'</span>, <span class="hljs-string">'routing_key'</span>: <span class="hljs-string">'w1@example.com'</span>}
}</code></pre> 
<ul><li><p>task_create_missing_queues <br> 默认值：启用 <br> 如果启用（默认），任何声明的未在 task_queues 中未定义的队列都将自动被创建。查看 Automaci routing。</p></li><li><p>task_default_queue <br> 默认值： celery <br> 如果消息没有声明路由或者自定义的队列，apply_async 默认使用的队列名称。</p></li></ul> 
<p>这个队列必须在 task_queues 中。如果 task_queues 没有声明，那么他将自动创建一个队列项，而这个设置值就作为队列的名称。</p> 
<p>另见： <br> 修改默认队列的名称</p> 
<ul><li><p>task_default_exchange <br> 默认值：”celery” <br> 当 task_queues 设置中指定键没有声明自定义的消息交互器，那么这个默认的消息交互器将被使用。</p></li><li><p>task_default_exchange_type <br> 默认值：”direct” <br> 当 task_queues 设置中指定键没有声明自定义的消息交互器类型，那么这个默认的消息交互器类型将被使用。</p></li><li><p>task_default_routing_key <br> 默认值：”celery” <br> 当 task_queues 设置中指定键没有声明自定义的路由键，那么这个默认的路由键将被使用。</p></li><li><p>task_default_delivery_mode <br> 默认值：”presistent”</p></li></ul> 
<p>可以是瞬态的（消息不写硬盘），或者持久的（写硬盘）</p> 
<h4 id="消息中间件设置">消息中间件设置</h4> 
<ul><li>broker_url <br> 默认值：”amqp://” <br> 默认的消息中间件URL。这必须是一个如下形式的URL：</li></ul> 
<pre class="prettyprint"><code class=" hljs vhdl"><span class="hljs-keyword">transport</span>://userid:password@hostname:<span class="hljs-keyword">port</span>/virtual_host</code></pre> 
<p>其中只有模式部分是必须的，其余部分都是可选的，默认会设置为对应传输中间件的默认值。</p> 
<p>传输部分是使用的消息中间件的实现，默认是 amqp，（如果安装了librabbitmq会使用这个库，否则使用pyamqp）。还有其他可用的选择，包括 redis://、 sqs://、 qpid://。</p> 
<p>模式部分可以是你自己的传输中间件实现的全限定路径：</p> 
<pre class="prettyprint"><code class=" hljs bash">broker_url = <span class="hljs-string">'proj.transports.MyTransport://localhost'</span></code></pre> 
<p>可以配置多个消息中间件，使用相同的传输协议也行。消息中间件可以通过当个字符串声明，不同的消息中间件URL之间用冒号分隔：</p> 
<pre class="prettyprint"><code class=" hljs vhdl">broker_url = <span class="hljs-attribute">'transport</span>://userid:password@hostname:<span class="hljs-keyword">port</span>//;<span class="hljs-keyword">transport</span>://userid:password@hostname:<span class="hljs-keyword">port</span>//'</code></pre> 
<p>或者作为一个列表：</p> 
<pre class="prettyprint"><code class=" hljs vhdl">broker_url = [
    <span class="hljs-attribute">'transport</span>://userid:password@localhost:<span class="hljs-keyword">port</span>//',
    <span class="hljs-attribute">'transport</span>://userid:password@hostname:<span class="hljs-keyword">port</span>//'
]</code></pre> 
<p>这些消息中间件将被用于broker_failover_strategy</p> 
<p>查看Kombu 文档中的 URLs 章节获取更多的信息。</p> 
<ul><li>broker_read_url / broker_write_url <br> 默认值：broker_url的设置值 <br> 这些设置可以配置而不用 broker_url 的设置，可以为消息中间件声明不同的连接参数，用来消费和生成消息。</li></ul> 
<p>示例：</p> 
<pre class="prettyprint"><code class=" hljs nginx"><span class="hljs-title">broker_read_url</span> = <span class="hljs-string">'amqp://user:pass<span class="hljs-variable">@broker</span>.example.com:56721'</span>
broker_write_url = <span class="hljs-string">'amqp://user:pass<span class="hljs-variable">@broker</span>.example.com:56722'</span></code></pre> 
<p>所有选项都可以声明成一个列表，作为故障恢复的可选值，查看 broker_url 获取更多的信息</p> 
<ul><li>broker_failover_strategy <br> 默认值：“round-robin” <br> 消息中间件连接对象的默认故障恢复策略。如果提供了，将映射到 kombu.connection.failover_strategies 中的一个键，或者引用任何方法，从给定的列表中产生一个项。</li></ul> 
<p>示例：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-comment"># Random failover strategy</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">random_failover_strategy</span><span class="hljs-params">(servers)</span>:</span>
    it = list(servers)  <span class="hljs-comment"># don't modify callers list</span>
    shuffle = random.shuffle
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> repeat(<span class="hljs-keyword">None</span>):
        shuffle(it)
        <span class="hljs-keyword">yield</span> it[<span class="hljs-number">0</span>]

broker_failover_strategy = random_failover_strategy</code></pre> 
<ul><li>broker_heartbeat <br> 支持的传输层协议：pyamqp <br> 默认值：120.0（与服务器协商）</li></ul> 
<p>注意：这个值只被工作单元使用，客户端此时不使用心跳。</p> 
<p>因为单纯使用 TCP/IP 并不总是及时探测到连接丢失，所以 AMQP 定义了心跳，客户端和消息中间件用来检测连接是否关闭。</p> 
<p>心跳会被监控，如果心跳值是 10 秒，那么检测心跳的时间间隔是 10 除以broker_heartbeat_checkrate （默认情况下，这个值是心跳值的两倍，所以对于10秒心跳，心跳每隔5秒检测一次）</p> 
<ul><li>broker_heartbeat_checkrate <br> 支持的传输层协议：pyamqp <br> 默认值：2.0</li></ul> 
<p>工作单元会间隔监控消息中间件没有丢失过多的心跳。这个检测的速率是用 broker_heartbeat 值除以这个设置值得到的，所以如果心跳是 10.0 并且这个设置值是默认的2.0，那么这个监控将每隔5秒钟执行一次（心跳发送速率的两倍）</p> 
<ul><li>broker_use_ssl <br> 支持的传输层协议： pyamqp, redis <br> 默认值: 禁用</li></ul> 
<p>在消息中间件连接上使用SSL</p> 
<p>这个选项的合法值依据使用的传输协议的不同而不同</p> 
<ul><li>pyamqp <br> 如果设置成True，连接将依据默认的SSL设置启用SSL。如果设置成一个字典，将依据给定的策略配置SSL连接。使用的格式是 python 的 ssl.wrap_socket() 选项。</li></ul> 
<p>注意SSL套接字一般会在消息中间件的一个单独的端口上服务。</p> 
<p>以下示例提供了客户端证书，并且使用一个自定义的认证授权来验证服务器证书：</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">import</span> ssl

broker_use_ssl = {
  <span class="hljs-string">'keyfile'</span>: <span class="hljs-string">'/var/ssl/private/worker-key.pem'</span>,
  <span class="hljs-string">'certfile'</span>: <span class="hljs-string">'/var/ssl/amqp-server-cert.pem'</span>,
  <span class="hljs-string">'ca_certs'</span>: <span class="hljs-string">'/var/ssl/myca.pem'</span>,
  <span class="hljs-string">'cert_reqs'</span>: ssl.CERT_REQUIRED
}</code></pre> 
<p>告警： <br> 使用 broker_use_ssl=True 时请小心。可能你的默认配置根本不会验证服务器证书。请阅读python的 ssl module security considerations。</p> 
<ul><li>redis <br> 设置必须是一个字典，包括如下键：</li></ul> 
<pre class="prettyprint"><code class=" hljs livecodeserver">ssl_cert_reqs (required): <span class="hljs-constant">one</span> <span class="hljs-operator">of</span> <span class="hljs-operator">the</span> SSLContext.verify_mode values: 
ssl.CERT_NONE
ssl.CERT_OPTIONAL
ssl.CERT_REQUIRED
ssl_ca_certs (optional): path <span class="hljs-built_in">to</span> <span class="hljs-operator">the</span> CA certificate
ssl_certfile (optional): path <span class="hljs-built_in">to</span> <span class="hljs-operator">the</span> client certificate
ssl_keyfile (optional): path <span class="hljs-built_in">to</span> <span class="hljs-operator">the</span> client key</code></pre> 
<ul><li>broker_pool_limit <br> 2.3版本新特性</li></ul> 
<p>默认值：10</p> 
<p>连接池中可以打开最大连接数。</p> 
<p>从2.5版本开始连接池被默认启用，默认限制是10个连接。这个数值可以依据使用一个连接的 threads/green-threads (eventlet/gevent) 数量进行更改。例如：运行 eventlet 启动 1000 个 greenlets，他们使用一个连接到消息中间件，如果发生竞态条件，那么你应该开始增加这个限制。</p> 
<p>如果设置成None或者0，连接池将会被禁用，并且每次使用连接都会重新建立连接并关闭。</p> 
<ul><li><p>broker_connection_timeout <br> 默认值：4.0 <br> 放弃与AMQP服务器建立连接之前默认等待的超时时间。当使用 gevent 时该设置被禁用。</p></li><li><p>broker_connection_retry <br> 默认值：启用 <br> 如果与 AMQP 消息中间件的连接断开，将自动重新建立连接</p></li></ul> 
<p>每次重试中间等待的时间会递增，并且在 broker_connection_max_retries 未达到之前会一只重试</p> 
<ul><li>broker_connection_max_retries <br> 默认值：100 <br> 放弃与 AMQP 服务器重新建立连接之前的最大重试次数</li></ul> 
<p>如果设置成 0 或者 None，将一只重试</p> 
<ul><li><p>broker_login_method <br> 默认值：AMQPLAIN <br> 设置自定义的 amqp 登陆方法</p></li><li><p>broker_transport_options <br> 2.2 版本新特性 <br> 默认值：{} （空映射）</p></li></ul> 
<p>传递给底层传输中间件的一个附加选项的字典</p> 
<p>设置可见超时时间的示例如下（Redis 与 SQS 传输中间件支持）：</p> 
<p>broker_transport_options = {‘visibility_timeout’: 18000} # 5 hours <br> 工作单元</p> 
<ul><li>imports <br> 默认值：[] （空列表） <br> 当工作单元启动时导入的一系列模块</li></ul> 
<p>这用来声明要导入的模块，但是它还可用来导入信号处理函数和附加的远程控制命令，等等。</p> 
<p>这些模块将会以原来声明的顺序导入</p> 
<ul><li>include <br> 默认值：[] (空列表) <br> 语义上与 imports 相同，但是可以作为将不同导入分类的一种手段</li></ul> 
<p>这个设置中的模块是在 imports 设置中的模块导入之后才导入</p> 
<ul><li>worker_concurrency <br> 默认值：CPU核数 <br> 执行任务的并发工作单元 process/threads/green 数量</li></ul> 
<p>如果你大部分操作是I/O操作，你可以设置更多的进程（线程），但是大部分情况下都是以CPU数作为定界，尝试让这个值接近你机器的CPU核数。如果没有设置，当前机器的 CPU核数将会被使用</p> 
<ul><li>worker_prefetch_multiplier <br> 默认值：4 <br> 工作单元一次预获取多少个消息是这个设置值乘以并发进程的数量。默认值是 4（每个进程4条消息）。但是，默认设置通常是好的选择 - 如果你有长时间任务等待在队列中，并且你必须启动工作单元，注意第一个工作单元初始时将收到4倍的消息量。因此任务可能在工作单元间不会平均分布</li></ul> 
<p>禁用这个选项，只要将 worker_prefetch_multiplier 设置成 1。设置成 0 将允许工作单元持续消费它想要的尽可能多的消息。</p> 
<p>更详细的信息，请阅读 Prefetch Limits</p> 
<p>注意： <br> 带 ETA/countdown 的任务不会受 prefetch 限制的影响</p> 
<ul><li><p>worker_lost_wait <br> 默认值：10.0 秒 <br> 有些情况下，工作单元可能在没有适当清理的情况下就被杀死，并且工作单元可能在终止前已经发布了一个结果。这个值声明了在抛出 WorkerLostError 异常之前我们会在丢失的结果值上等待多久</p></li><li><p>worker_max_tasks_per_child <br> 一个工作单元进程在被一个新的进程替代之前可以执行的最大任务数</p></li><li><p>worker_max_memory_per_child</p></li></ul> 
<p>默认值：没有限制。类型：int(kilobytes)</p> 
<p>一个工作单元进程在被一个新的进程替代之前可以消耗的最大预留内存（单位KB）。如果单独一个任务就导致工作单元超过这个限制，当前的任务会执行完成，并且之后这个进程将会被更新替代。</p> 
<p>示例：</p> 
<pre class="prettyprint"><code class=" hljs bash">worker_max_memory_per_child = <span class="hljs-number">12000</span>  <span class="hljs-comment"># 12MB</span></code></pre> 
<ul><li><p>worker_disable_rate_limits <br> 默认值：禁用（启用速率限制） <br> 即使任务显示设置了速率，仍然禁用所有速率限制</p></li><li><p>worker_state_db <br> 默认值：None <br> 存储工作单元状态的文件名称（如取消的任务）。可以是相对或者绝对路径，但是注意后缀.db 可能会被添加到文件名后（依赖于python 的版本）</p></li></ul> 
<p>也可以通过celery worker –statedb 参数设置</p> 
<ul><li>worker_timer_precision <br> 默认值：1.0秒 <br> 设置重新检测调度器之前ETA调度器可以休息的最大秒数</li></ul> 
<p>设置成1意味着调度器精度将为1秒。如果你需要毫秒精度，你可以设置成 0.1</p> 
<ul><li>worker_enable_remote_control <br> 默认值：默认启用 <br> 声明工作单元的远程控制是否启用</li></ul> 
<h4 id="事件">事件</h4> 
<ul><li><p>worker_send_task_events <br> 默认值：默认禁用 <br> 发送任务相关的事件，使得任务可以使用类似flower 的工作监控到。为工作单元的 -E 参数设置默认值</p></li><li><p>task_send_sent_event <br> 2.2 版本新特性 <br> 默认值：默认禁用</p></li></ul> 
<p>如果启用，对于每个任务都将有一个 task-sent 事件被发送，因此任务在被消费前就能被追踪。</p> 
<ul><li>event_queue_ttl <br> 支持的传输中间件: amqp <br> 默认值：5.0 秒 <br> 发送到一个监控客户端事件队列的消息的过期时间（x-message-ttl），以秒为单位（int/float)。</li></ul> 
<p>例如：如果这个值设置为10，被递送到这个队列的消息将会在10秒后被删除</p> 
<ul><li><p>event_queue_expires <br> 支持的传输中间件: amqp <br> 默认值：60.0 秒 <br> 一个监控客户端事件队列被删除前的过期时间（x-expires）。</p></li><li><p>event_queue_prefix <br> 默认值： “celeryev”. <br> 事件接收队列名称的前缀</p></li><li><p>event_serializer <br> 默认值： “json”. <br> 当发送事件消息时使用的消息序列化格式</p></li></ul> 
<h4 id="远程控制命令">远程控制命令</h4> 
<ul><li><p>control_queue_ttl <br> 默认值： 300.0</p></li><li><p>control_queue_expires <br> 默认值： 10.0</p></li></ul> 
<h4 id="日志">日志</h4> 
<ul><li>worker_hijack_root_logger <br> 2.2 版本新特性 <br> 默认值： 默认启用 (hijack root logger).</li></ul> 
<p>默认情况下，任意前面配置的根日志器的处理函数都将被移除。如果你想自定义日志处理函数，那么你可以通过设置 worker_hijack_root_logger = False 来禁用这个行为</p> 
<p>注意： <br> 日志可以通过连接到 celery.signals.setup_logging 进行定制化</p> 
<ul><li><p>worker_log_color <br> 默认值： 如果应用实例日志输出到一个终端，这个将启用 <br> 启用/禁用Celery 应用日志输出的颜色</p></li><li><p>worker_log_format <br> 默认值： <br> [%(asctime)s: %(levelname)s/%(processName)s] %(message)s <br> 日志信息的格式</p></li></ul> 
<p>查看python 日志模块获取更多关于日志的信息</p> 
<ul><li>worker_task_log_format <br> 默认值：</li></ul> 
<pre class="prettyprint"><code class=" hljs ruby">[<span class="hljs-string">%(asctime)</span><span class="hljs-symbol">s:</span> <span class="hljs-string">%(levelname)</span>s/<span class="hljs-string">%(processName)</span>s]
    [<span class="hljs-string">%(task_name)</span>s(<span class="hljs-string">%(task_id)</span>s)] <span class="hljs-string">%(message)</span>s</code></pre> 
<p>任务中记录日志使用的格式</p> 
<p>查看python 日志模块获取更多关于日志的信息</p> 
<ul><li>worker_redirect_stdouts <br> 默认值： 默认启用 <br> 如果启用来，标准输出和标准错误输出将重定向到当前日志器</li></ul> 
<p>工作单元和 beat 将使用到</p> 
<ul><li>worker_redirect_stdouts_level <br> 默认值：WARNING <br> 标准输出和标准错误输出的日志级别。可以是DEBUG, INFO, WARNING, ERROR, or CRITICAL</li></ul> 
<h4 id="安全">安全</h4> 
<ul><li>security_key <br> 默认值： None. <br> 2.5 版本新特性</li></ul> 
<p>包含私钥的文件的相对或者绝对路径，私钥用来在使用消息签名时对消息进行签名。</p> 
<ul><li>security_certificate <br> 默认值：None. <br> 2.5 版本新特性</li></ul> 
<p>包含X.509认证的文件的相对或者绝对路径，认证用来在使用消息签名时对消息进行签名。</p> 
<ul><li>security_cert_store <br> 默认值：None. <br> 2.5 版本新特性</li></ul> 
<p>包含用来进行消息签名的X.509认证的目录。可以使用文件名模式匹配（例如：/etc/certs/*.pem）</p> 
<p>自定义组件类 （高级）</p> 
<ul><li><p>worker_pool <br> 默认值：”prefork” (celery.concurrency.prefork:TaskPool). <br> 工作单元使用的池类的名称</p></li><li><p>Eventlet/Gevent <br> 永远不要使用这个选项来选择用eventlet 还是 gevent。你必须对工作单元使用-P选项，确保应急补丁不会应用过迟，导致出现奇怪的现象。</p></li><li><p>worker_pool_restarts <br> 默认值：默认禁用</p></li></ul> 
<p>如果启用，工作单元池可以使用 pool_restart 远程控制命令进行重启</p> 
<ul><li>worker_autoscaler <br> 2.2 版本新特性 <br> 默认值： “celery.worker.autoscale:Autoscaler”.</li></ul> 
<p>使用的自动扩展类的名称</p> 
<ul><li><p>worker_consumer <br> 默认值：”celery.worker.consumer:Consumer”. <br> 工作单元使用的消费类的名称</p></li><li><p>worker_timer <br> 默认值：”kombu.async.hub.timer:Timer”. <br> 工作单元使用的 ETA 调度器类的名称。默认值是被池具体实现设置。</p></li></ul> 
<h4 id="beat-设置-celery-beat">Beat 设置 （celery beat）</h4> 
<ul><li><p>beat_schedule <br> 默认值： {} (空映射) <br> beat调度的周期性任务。查看Entries</p></li><li><p>beat_scheduler <br> 默认值：”celery.beat:PersistentScheduler”. <br> 默认的调度器类。如果同时使用django-celery-beat扩展，可以设置成 “django_celery_beat.schedulers:DatabaseScheduler”</p></li></ul> 
<p>也可以通过celery beat 的 -S 参数进行设置</p> 
<ul><li>beat_schedule_filename <br> 默认值： “celerybeat-schedule”. <br> 存储周期性任务最后运行时间的文件的名称，这个文件被PersistentScheduler使用。可以是相对或者绝对路径，但是注意后缀.db可能添加到文件名后（依赖于python版本）</li></ul> 
<p>也可以通过 celery beat 的 –schedule 参数进行设置</p> 
<ul><li><p>beat_sync_every <br> 默认值：0. <br> 另一个数据库同步发起前可以执行的周期性任务的数量。值0（默认）表示基于时间同步 - 默认是3分钟，由scheduler.sync_every确定。如果设置成1，beat将在每个任务消息发送后发起同步。</p></li><li><p>beat_max_loop_interval <br> 默认值： 0.</p></li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bd7ea68492789947ce97fd46f652e61a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">财富自由？五年后为什么他月入十万，而我月入六千</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/48ff991fec229ffc22367d15bba04d2f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">tensorflow版本的一些区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>