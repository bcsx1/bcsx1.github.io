<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>shiro 拦截未登录的ajax_Shiro是如何拦截未登录请求的(一) - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="shiro 拦截未登录的ajax_Shiro是如何拦截未登录请求的(一)" />
<meta property="og:description" content="问题描述
之前在公司搭项目平台的时候权限框架采用的是shiro,由于系统主要面向的是APP端的用户,PC端仅仅是公司内部人员在使用,而且考虑到系统的可用性和扩展性,服务端首先基于shiro做了一些改造以支持多数据源认证和分布式会话(关于分布式session可查看{% post_link SpringBoot集成Shiro实现多数据源认证授权与分布式会话(一)%}).我们知道在web环境下http是一种无状态的通讯协议,要想记录和校验用户的登录状态必须通过session的机制来实现,浏览器是通过cookie中存储的sessionid来确定用户的session数据的,shiro默认也是采用这种机制.而对于移动端用户来讲,则可以使用token的方式来进行身份鉴权,原理跟浏览器使用cookie传输是一样的.
token身份鉴权的流程
1.服务端在用户正常登录之后,通过特定算法生成一个全局唯一的字符串token并返回给客户端.
2.客户端在接下来的请求都会在请求头中携带token,服务端拦截token并对用户做身份鉴权.
3.token带有自动失效的机制,当用户主动退出或者失效时间一到则服务端删除会话信息.
遇到的问题
网上查了一下我们知道shiro也是通过携带cookie中的sessionid来做鉴权的,既然移动端使用的是token的机制,那么要想使shiro能够支持这套机制就必须改造shiro的鉴权方式.之前在搭框架的时候为了解决这个问题曾经草草的翻了一下shiro的源码(这货的代码量真心大啊,看的人一头雾水),找了很久也没找到它是在何处处理的,当时因为时间关系只好放弃,用了一种很笨的方法在请求头header中存储以键为Cookie,值为token=web_session_key-xxx的键值对的方式来确保shiro能通过解析校验,这样app端是能够正常交互的,但是对于后面增加的h5应用或者小程序则不行,首先是跨域问题(关于跨域可查看{% post_link 前后端分离之CORS跨域请求踩坑总结%}),由于是前后端分离的应用,浏览器的同源策略不允许js访问跨域的cookie,这样每次请求shiro获取的cookie都为空,过滤器会拦截下这个请求并作出如下响应:
image.png
为了h5应用能够与服务端正常交互只好想办法绕过shiro的拦截校验,既然无法传输cookie,只好在header中传一个token,并在自定义的过滤器(继承自shiro的FormAuthenticationFilter)中覆写它的isAccessAllowed方法,此方法返回值若为true则说明shiro鉴权通过,否则执行redirectToLogin方法跳转到登录页面.
@Override
protected boolean isAccessAllowed(ServletRequest request,
ServletResponse response, Object mappedValue) {
HttpServletRequest httpRequest = (HttpServletRequest) request;
boolean isLogin;
String device = httpRequest.getHeader(&#34;device&#34;);
// 如果是客户端是H5
if (StringHelpUtils.isNotBlank(device) &amp;&amp; device.equals(&#34;H5&#34;)) {
String h5Token = httpRequest.getHeader(&#34;token&#34;);
Cookie[] cookies = httpRequest.getCookies();
if (null != cookies) {
for (Cookie cookie : cookies) {
if (cookie.getName().equals(&#34;token&#34;)) {
cookie.setValue(h5Token);
}
}
}
isLogin = isH5Login(h5Token);//绕过shiro,直接到redis中校验token" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/6db0d36b5984d06f75b856616f53d9b3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-19T14:47:08+08:00" />
<meta property="article:modified_time" content="2020-12-19T14:47:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">shiro 拦截未登录的ajax_Shiro是如何拦截未登录请求的(一)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>问题描述</p> 
 <p>之前在公司搭项目平台的时候权限框架采用的是shiro,由于系统主要面向的是APP端的用户,PC端仅仅是公司内部人员在使用,而且考虑到系统的可用性和扩展性,服务端首先基于shiro做了一些改造以支持多数据源认证和分布式会话(关于分布式session可查看{% post_link SpringBoot集成Shiro实现多数据源认证授权与分布式会话(一)%}).我们知道在web环境下http是一种无状态的通讯协议,要想记录和校验用户的登录状态必须通过session的机制来实现,浏览器是通过cookie中存储的sessionid来确定用户的session数据的,shiro默认也是采用这种机制.而对于移动端用户来讲,则可以使用token的方式来进行身份鉴权,原理跟浏览器使用cookie传输是一样的.</p> 
 <p>token身份鉴权的流程</p> 
 <p>1.服务端在用户正常登录之后,通过特定算法生成一个全局唯一的字符串token并返回给客户端.</p> 
 <p>2.客户端在接下来的请求都会在请求头中携带token,服务端拦截token并对用户做身份鉴权.</p> 
 <p>3.token带有自动失效的机制,当用户主动退出或者失效时间一到则服务端删除会话信息.</p> 
 <p>遇到的问题</p> 
 <p>网上查了一下我们知道shiro也是通过携带cookie中的sessionid来做鉴权的,既然移动端使用的是token的机制,那么要想使shiro能够支持这套机制就必须改造shiro的鉴权方式.之前在搭框架的时候为了解决这个问题曾经草草的翻了一下shiro的源码(这货的代码量真心大啊,看的人一头雾水),找了很久也没找到它是在何处处理的,当时因为时间关系只好放弃,用了一种很笨的方法在请求头header中存储以键为Cookie,值为token=web_session_key-xxx的键值对的方式来确保shiro能通过解析校验,这样app端是能够正常交互的,但是对于后面增加的h5应用或者小程序则不行,首先是跨域问题(关于跨域可查看{% post_link 前后端分离之CORS跨域请求踩坑总结%}),由于是前后端分离的应用,浏览器的同源策略不允许js访问跨域的cookie,这样每次请求shiro获取的cookie都为空,过滤器会拦截下这个请求并作出如下响应:</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>image.png</p> 
 <p>为了h5应用能够与服务端正常交互只好想办法绕过shiro的拦截校验,既然无法传输cookie,只好在header中传一个token,并在自定义的过滤器(继承自shiro的FormAuthenticationFilter)中覆写它的isAccessAllowed方法,此方法返回值若为true则说明shiro鉴权通过,否则执行redirectToLogin方法跳转到登录页面.</p> 
 <p>@Override</p> 
 <p>protected boolean isAccessAllowed(ServletRequest request,</p> 
 <p>ServletResponse response, Object mappedValue) {<!-- --></p> 
 <p>HttpServletRequest httpRequest = (HttpServletRequest) request;</p> 
 <p>boolean isLogin;</p> 
 <p>String device = httpRequest.getHeader("device");</p> 
 <p>// 如果是客户端是H5</p> 
 <p>if (StringHelpUtils.isNotBlank(device) &amp;&amp; device.equals("H5")) {<!-- --></p> 
 <p>String h5Token = httpRequest.getHeader("token");</p> 
 <p>Cookie[] cookies = httpRequest.getCookies();</p> 
 <p>if (null != cookies) {<!-- --></p> 
 <p>for (Cookie cookie : cookies) {<!-- --></p> 
 <p>if (cookie.getName().equals("token")) {<!-- --></p> 
 <p>cookie.setValue(h5Token);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>isLogin = isH5Login(h5Token);//绕过shiro,直接到redis中校验token</p> 
 <p>} else {<!-- --></p> 
 <p>// 如果是APP或者PC端</p> 
 <p>Subject subject = getSubject(request, response);</p> 
 <p>isLogin = subject.isAuthenticated();</p> 
 <p>}</p> 
 <p>return isLogin;</p> 
 <p>}</p> 
 <p>到这里基本上shiro的登录校验是绕过去了,其实这里并不是真的绕过,因为shiro该做的事情还是会照做,只不过是我们再到redis中去匹配一次而已,但是却带来了一个新的问题,那就是服务端通过SecurityUtils.getSubject().getSession();取到的用户session对象与之前登录时产生的session对象并不是同一个,原因是shiro本身在执行校验时由于无法获取到cookie中的token,所以它把这个请求当成是一个新的请求,每次调用都会创建一个新的session,但这个新session里面并不存在我们需要的用户相关登录信息,而由于app与小程序是同一套接口,这样就影响到了原先已写好的业务代码了...虽然解决方法还是有的,但是总觉得整个过程下来,代码和功能的实现都让人觉得很别扭,因此本文想从源码的角度去逐步剖析shiro是如何拦截未登录请求的,从根源上来寻求解决方案,同时又不会对已对接好的业务接口造成影响.</p> 
 <p>源码跟踪</p> 
 <p>在开始跟源码之前,我们先来看看下面的异常堆栈图</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>image.png</p> 
 <p>之所以要帖这个图是因为shiro的代码实在太多,全部去看不太现实,因此在程序里面造了个异常,从异常的底部开始一步步跟下去总可以发现根源的,我们知道shiro的入口是个过滤器shiroFilter,因此不用怀疑先从过滤器找起,首先是ApplicationFilterChain,看名字和包路径就知道这个不是shiro的实现类,大概查了一下知道它是tomcat实现的过滤器链.其采用了责任链的设计模式,我们在idea中打开这个类,在它的internalDoFilter方法上加断点.</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>image.png</p> 
 <p>由这行代码ApplicationFilterConfig filterConfig = this.filters[this.pos++];可知this.filters是一个ApplicationFilterConfig集合,这个集合存储了ApplicationFilterChain里面的所有过滤器,如下图.</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>QQ截图20180711145037.png</p> 
 <p>其中ApplicationFilterConfig是个filter容器,我们来看看它的定义:</p> 
 <p>org.apache.catalina.core.ApplicationFilterConfig</p> 
 <p>Implementation of a javax.servlet.FilterConfig useful in managing the filter instances instantiated when a web application is first started.</p> 
 <p>大致意思是说当web应用一开始启动时,会将工程中的所有的实例化的filter实例加载到此容器中.下面来看看容器启动后加载了哪些filter实例.</p> 
 <p>name=characterEncodingFilter</p> 
 <p>name=hiddenHttpMethodFilter</p> 
 <p>name=httpPutFormContentFilter</p> 
 <p>name=requestContextFilter</p> 
 <p>name=corsFilter</p> 
 <p>name=shiroFilter</p> 
 <p>name=Tomcat WebSocket(JSR356) Filter</p> 
 <p>其中characterEncodingFilter(用于处理编码问题)、hiddenHttpMethodFilter(隐藏HTTP函数)、httpPutFormContentFilter(form表单处理)、requestContextFilter(请求上下文)等是springboot自动添加的一些常用过滤器(注意这几个filter的完整限定类名为Ordered开头的,如OrderedCharacterEncodingFilter继承自CharacterEncodingFilter,里面多了个order属性,用于确定该filter的执行顺序).</p> 
 <p>corsFilter是我们后端统一使用cors来解决跨域问题的.</p> 
 <p>wsFilter这个filter应该是用来处理WebSocket的.</p> 
 <p>最后一个shiroFilter是我们要关注的重点,它是整个shiro框架的入口,注意它的filterClass是ShiroFilterFacotoryBean$SpringShiroFilter,看名字应该是spring生成的一个代理类了,先不管它是怎么生成的,继续往下看会发现上述列出来的过滤器中除了wsFilter和shiroFilter之外其他的filter都继承自org.springframework.web.filter.OncePerRequestFilter.而spring的OncePerRequestFilter是一个抽象过滤器类,其中定义的抽象方法doFilterInternal是由其子类来实现的,doFilter方法则是final的子类只能继承不能覆写.比如CharacterEncodingFilter继承了OncePerRequestFilter的doFilter方法且实现了doFilterInternal方法.</p> 
 <p>所以从上面的异常堆栈图中我们可以看出每次ApplicationFilterChain执行链中filter的doFilter方法时都会先执行它的父类OncePerRequestFilter的doFilter方法然后再执行这个filter实现的doFilterInternal方法,一直到shiro自己的OncePerRequestFilter(注意shiro自己实现的这个filter跟spring的不是同一个)为止.你一定会很奇怪为什么这里会执行shiro的OncePerRequestFilter,按道理springboot默认的filter和跨域的filter都执行过去了,那么接下来要执行的应该是shiro的入口shiroFilter才对.所以到目前为止我们一共有两个疑惑:</p> 
 <p>1.ShiroFilterFacotoryBean$SpringShiroFilter是怎么来的.</p> 
 <p>2.shiro的执行入口为什么是其内部实现的OncePerRequestFilter.</p> 
 <p>带着这些问题我们继续往下看,首先是项目中shiroFilter的配置.</p> 
 <p>ShiroFilterFactoryBean</p> 
 <p>@Bean</p> 
 <p>public ShiroFilterFactoryBean shiroFilter() {<!-- --></p> 
 <p>ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();</p> 
 <p>// 必须设置 SecurityManager</p> 
 <p>shiroFilterFactoryBean.setSecurityManager(getDefaultWebSecurityManager());</p> 
 <p>........</p> 
 <p>return shiroFilterFactoryBean;</p> 
 <p>}</p> 
 <p>从上述配置可知使用了ShiroFilterFactoryBean来创建shiroFilter,所以重点在于ShiroFilterFactoryBean这个类.它的主要源代码如下:</p> 
 <p>public class ShiroFilterFactoryBean implements FactoryBean, BeanPostProcessor {<!-- --></p> 
 <p>private static final transient Logger log = LoggerFactory.getLogger(ShiroFilterFactoryBean.class);</p> 
 <p>private SecurityManager securityManager;</p> 
 <p>private Map filters = new LinkedHashMap();</p> 
 <p>private Map filterChainDefinitionMap = new LinkedHashMap();</p> 
 <p>private String loginUrl;</p> 
 <p>private String successUrl;</p> 
 <p>private String unauthorizedUrl;</p> 
 <p>private AbstractShiroFilter instance;</p> 
 <p>......</p> 
 <p>}</p> 
 <p>从类的定义中可知ShiroFilterFactoryBean实现了接口FactoryBean和BeanPostProcessor.</p> 
 <p>BeanPostProcessor接口的作用是在Spring容器启动时,容器中所有的bean在初始化的前后都会调用这个接口的方法postProcessBeforeInitialization并在这个方法中判断当前的bean是否为Filter,若是则装载进Map集合filters中.</p> 
 <p>public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {<!-- --></p> 
 <p>if (bean instanceof Filter) {<!-- --></p> 
 <p>log.debug("Found filter chain candidate filter '{}'", beanName);</p> 
 <p>Filter filter = (Filter)bean;</p> 
 <p>this.applyGlobalPropertiesIfNecessary(filter);</p> 
 <p>this.getFilters().put(beanName, filter);</p> 
 <p>} else {<!-- --></p> 
 <p>log.trace("Ignoring non-Filter bean '{}'", beanName);</p> 
 <p>}</p> 
 <p>return bean;</p> 
 <p>}</p> 
 <p>public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {<!-- --></p> 
 <p>return bean;</p> 
 <p>}</p> 
 <p>而ShiroFilterFactoryBean本身又实现了另外一个接口FactoryBean,FactoryBean的作用是在执行getBean("shiroFilter")时会调用其getObject方法来获取一个代理实例,看源码可知其调用的是this.createInstance()函数,返回的是一个SpringShiroFilter实例.代码如下:</p> 
 <p>public Object getObject() throws Exception {<!-- --></p> 
 <p>if (this.instance == null) {<!-- --></p> 
 <p>this.instance = this.createInstance();</p> 
 <p>}</p> 
 <p>return this.instance;</p> 
 <p>}</p> 
 <p>public Class getObjectType() {<!-- --></p> 
 <p>return ShiroFilterFactoryBean.SpringShiroFilter.class;</p> 
 <p>}</p> 
 <p>protected AbstractShiroFilter createInstance() throws Exception {<!-- --></p> 
 <p>log.debug("Creating Shiro Filter instance.");</p> 
 <p>SecurityManager securityManager = this.getSecurityManager();</p> 
 <p>String msg;</p> 
 <p>if (securityManager == null) {<!-- --></p> 
 <p>msg = "SecurityManager property must be set.";</p> 
 <p>throw new BeanInitializationException(msg);</p> 
 <p>} else if (!(securityManager instanceof WebSecurityManager)) {<!-- --></p> 
 <p>msg = "The security manager does not implement the WebSecurityManager interface.";</p> 
 <p>throw new BeanInitializationException(msg);</p> 
 <p>} else {<!-- --></p> 
 <p>FilterChainManager manager = this.createFilterChainManager();</p> 
 <p>PathMatchingFilterChainResolver chainResolver = new PathMatchingFilterChainResolver();</p> 
 <p>chainResolver.setFilterChainManager(manager);</p> 
 <p>return new ShiroFilterFactoryBean.SpringShiroFilter((WebSecurityManager)securityManager, chainResolver);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>SpringShiroFilter是ShiroFilterFactoryBean类的静态内部类,继承自shiro的AbstractShiroFilter.</p> 
 <p>private static final class SpringShiroFilter extends AbstractShiroFilter {<!-- --></p> 
 <p>protected SpringShiroFilter(WebSecurityManager webSecurityManager, FilterChainResolver resolver) {<!-- --></p> 
 <p>if (webSecurityManager == null) {<!-- --></p> 
 <p>throw new IllegalArgumentException("WebSecurityManager property cannot be null.");</p> 
 <p>} else {<!-- --></p> 
 <p>this.setSecurityManager(webSecurityManager);</p> 
 <p>if (resolver != null) {<!-- --></p> 
 <p>this.setFilterChainResolver(resolver);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>跟到这里也就明白了ShiroFilterFacotoryBean$SpringShiroFilter是怎么来的了,那么第一个问题已解答,至于第二个问题的答案则要通过AbstractShiroFilter的源码来找了.</p> 
 <p>public abstract class AbstractShiroFilter extends OncePerRequestFilter {<!-- --></p> 
 <p>}</p> 
 <p>通过源码可知AbstractShiroFilter是一个抽象过滤器,继承自shiro的抽象filter-OncePerRequestFilter,而OncePerRequestFilter中的抽象方法doFilterInternal则由其实现类AbstractShiroFilter负责实现,我们来看看doFilterInternal的具体代码:</p> 
 <p>protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse, final FilterChain chain)</p> 
 <p>throws ServletException, IOException {<!-- --></p> 
 <p>Throwable t = null;</p> 
 <p>try {<!-- --></p> 
 <p>final ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain);</p> 
 <p>final ServletResponse response = prepareServletResponse(request, servletResponse, chain);</p> 
 <p>final Subject subject = createSubject(request, response);</p> 
 <p>//noinspection unchecked</p> 
 <p>subject.execute(new Callable() {<!-- --></p> 
 <p>public Object call() throws Exception {<!-- --></p> 
 <p>updateSessionLastAccessTime(request, response);</p> 
 <p>executeChain(request, response, chain);</p> 
 <p>return null;</p> 
 <p>}</p> 
 <p>});</p> 
 <p>} catch (ExecutionException ex) {<!-- --></p> 
 <p>t = ex.getCause();</p> 
 <p>} catch (Throwable throwable) {<!-- --></p> 
 <p>t = throwable;</p> 
 <p>}</p> 
 <p>if (t != null) {<!-- --></p> 
 <p>if (t instanceof ServletException) {<!-- --></p> 
 <p>throw (ServletException) t;</p> 
 <p>}</p> 
 <p>if (t instanceof IOException) {<!-- --></p> 
 <p>throw (IOException) t;</p> 
 <p>}</p> 
 <p>//otherwise it's not one of the two exceptions expected by the filter method signature - wrap it in one:</p> 
 <p>String msg = "Filtered request failed.";</p> 
 <p>throw new ServletException(msg, t);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>回到最初的问题:shiro是如何拦截未登录请求的,根据前面的贴出来异常堆栈图的指示,我们重点来看看上面第10行代码中的createSubject方法,其实现如下:</p> 
 <p>protected WebSubject createSubject(ServletRequest request, ServletResponse response) {<!-- --></p> 
 <p>return new WebSubject.Builder(getSecurityManager(), request, response).buildWebSubject();</p> 
 <p>}</p> 
 <p>此处调用的buildWebSubject方法的实现是在接口WebSubject的内部静态类Builder中.</p> 
 <p>public WebSubject buildWebSubject() {<!-- --></p> 
 <p>Subject subject = super.buildSubject();</p> 
 <p>if (!(subject instanceof WebSubject)) {<!-- --></p> 
 <p>String msg = "Subject implementation returned from the SecurityManager was not a " +</p> 
 <p>WebSubject.class.getName() + " implementation. Please ensure a Web-enabled SecurityManager " +</p> 
 <p>"has been configured and made available to this builder.";</p> 
 <p>throw new IllegalStateException(msg);</p> 
 <p>}</p> 
 <p>return (WebSubject) subject;</p> 
 <p>}</p> 
 <p>这个方法主要用来创建shiro的主体subject,在静态类Builder中并没有相关实现的代码,而是在其父类Subject中.</p> 
 <p>public Subject buildSubject() {<!-- --></p> 
 <p>return this.securityManager.createSubject(this.subjectContext);</p> 
 <p>}</p> 
 <p>this.securityManager是shiro的安全管理器,管理着所有的Subject,且负责进行认证和授权、及会话、缓存等的管理,在实例化ShiroFilterFactoryBean时由springboot配置中注入过来的,我们来看看项目中的配置:</p> 
 <p>shiroFilterFactoryBean.setSecurityManager(getDefaultWebSecurityManager());</p> 
 <p>@Bean(name = "securityManager")</p> 
 <p>public DefaultWebSecurityManager getDefaultWebSecurityManager() {<!-- --></p> 
 <p>logger.info("注入Shiro的Web过滤器--&gt;securityManager", ShiroFilterFactoryBean.class);</p> 
 <p>DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();</p> 
 <p>......</p> 
 <p>return securityManager;</p> 
 <p>}</p> 
 <p>从上面的代码调试跟踪可知createSubject方法的实现在DefaultWebSecurityManager的父类DefaultSecurityManager中.</p> 
 <p>public Subject createSubject(SubjectContext subjectContext) {<!-- --></p> 
 <p>//create a copy so we don't modify the argument's backing map:</p> 
 <p>SubjectContext context = copy(subjectContext);</p> 
 <p>//ensure that the context has a SecurityManager instance, and if not, add one:</p> 
 <p>context = ensureSecurityManager(context);</p> 
 <p>//Resolve an associated Session (usually based on a referenced session ID), and place it in the context before</p> 
 <p>//sending to the SubjectFactory. The SubjectFactory should not need to know how to acquire sessions as the</p> 
 <p>//process is often environment specific - better to shield the SF from these details:</p> 
 <p>context = resolveSession(context);</p> 
 <p>//Similarly, the SubjectFactory should not require any concept of RememberMe - translate that here first</p> 
 <p>//if possible before handing off to the SubjectFactory:</p> 
 <p>context = resolvePrincipals(context);</p> 
 <p>Subject subject = doCreateSubject(context);</p> 
 <p>//save this subject for future reference if necessary:</p> 
 <p>//(this is needed here in case rememberMe principals were resolved and they need to be stored in the</p> 
 <p>//session, so we don't constantly rehydrate the rememberMe PrincipalCollection on every operation).</p> 
 <p>//Added in 1.2:</p> 
 <p>save(subject);</p> 
 <p>return subject;</p> 
 <p>}</p> 
 <p>其中第11行context = resolveSession(context);看注释是通过引用的sessionid来解析关联的会话,进去看看它的实现:</p> 
 <p>protected SubjectContext resolveSession(SubjectContext context) {<!-- --></p> 
 <p>if (context.resolveSession() != null) {<!-- --></p> 
 <p>log.debug("Context already contains a session. Returning.");</p> 
 <p>return context;</p> 
 <p>}</p> 
 <p>try {<!-- --></p> 
 <p>//Context couldn't resolve it directly, let's see if we can since we have direct access to</p> 
 <p>//the session manager:</p> 
 <p>Session session = resolveContextSession(context);</p> 
 <p>if (session != null) {<!-- --></p> 
 <p>context.setSession(session);</p> 
 <p>}</p> 
 <p>} catch (InvalidSessionException e) {<!-- --></p> 
 <p>log.debug("Resolved SubjectContext context session is invalid. Ignoring and creating an anonymous " +</p> 
 <p>"(session-less) Subject instance.", e);</p> 
 <p>}</p> 
 <p>return context;</p> 
 <p>}</p> 
 <p>注意第9行Session session = resolveContextSession(context);跟进去这个方法.</p> 
 <p>protected Session resolveContextSession(SubjectContext context) throws InvalidSessionException {<!-- --></p> 
 <p>SessionKey key = getSessionKey(context);</p> 
 <p>if (key != null) {<!-- --></p> 
 <p>return getSession(key);</p> 
 <p>}</p> 
 <p>return null;</p> 
 <p>}</p> 
 <p>protected SessionKey getSessionKey(SubjectContext context) {<!-- --></p> 
 <p>Serializable sessionId = context.getSessionId();</p> 
 <p>if (sessionId != null) {<!-- --></p> 
 <p>return new DefaultSessionKey(sessionId);</p> 
 <p>}</p> 
 <p>return null;</p> 
 <p>}</p> 
 <p>其中getSession(key)调用的是抽象类SessionsSecurityManager中的getSession方法.</p> 
 <p>public Session getSession(SessionKey key) throws SessionException {<!-- --></p> 
 <p>return this.sessionManager.getSession(key);</p> 
 <p>}</p> 
 <p>继续往下跑则到了抽象类AbstractNativeSessionManager中的getSession方法.</p> 
 <p>public Session getSession(SessionKey key) throws SessionException {<!-- --></p> 
 <p>Session session = lookupSession(key);</p> 
 <p>return session != null ? createExposedSession(session, key) : null;</p> 
 <p>}</p> 
 <p>private Session lookupSession(SessionKey key) throws SessionException {<!-- --></p> 
 <p>if (key == null) {<!-- --></p> 
 <p>throw new NullPointerException("SessionKey argument cannot be null.");</p> 
 <p>}</p> 
 <p>return doGetSession(key);</p> 
 <p>}</p> 
 <p>而第10行的doGetSession方法则调用了抽象类AbstractValidatingSessionManager中的doGetSession方法</p> 
 <p>@Override</p> 
 <p>protected final Session doGetSession(final SessionKey key) throws InvalidSessionException {<!-- --></p> 
 <p>enableSessionValidationIfNecessary();</p> 
 <p>log.trace("Attempting to retrieve session with key {}", key);</p> 
 <p>Session s = retrieveSession(key);</p> 
 <p>if (s != null) {<!-- --></p> 
 <p>validate(s, key);</p> 
 <p>}</p> 
 <p>return s;</p> 
 <p>}</p> 
 <p>这里重点来看看第7行retrieveSession方法,跟进去发现它的实现在shiro的默认session管理器类DefaultSessionManager中.</p> 
 <p>protected Session retrieveSession(SessionKey sessionKey) throws UnknownSessionException {<!-- --></p> 
 <p>Serializable sessionId = getSessionId(sessionKey);</p> 
 <p>if (sessionId == null) {<!-- --></p> 
 <p>log.debug("Unable to resolve session ID from SessionKey [{}]. Returning null to indicate a " +</p> 
 <p>"session could not be found.", sessionKey);</p> 
 <p>return null;</p> 
 <p>}</p> 
 <p>Session s = retrieveSessionFromDataSource(sessionId);</p> 
 <p>if (s == null) {<!-- --></p> 
 <p>//session ID was provided, meaning one is expected to be found, but we couldn't find one:</p> 
 <p>String msg = "Could not find session with ID [" + sessionId + "]";</p> 
 <p>throw new UnknownSessionException(msg);</p> 
 <p>}</p> 
 <p>return s;</p> 
 <p>}</p> 
 <p>由第2行Serializable sessionId = getSessionId(sessionKey);进去getSessionId方法,其实现在类DefaultWebSessionManager中.</p> 
 <p>@Override</p> 
 <p>public Serializable getSessionId(SessionKey key) {<!-- --></p> 
 <p>Serializable id = super.getSessionId(key);</p> 
 <p>if (id == null &amp;&amp; WebUtils.isWeb(key)) {<!-- --></p> 
 <p>ServletRequest request = WebUtils.getRequest(key);</p> 
 <p>ServletResponse response = WebUtils.getResponse(key);</p> 
 <p>id = getSessionId(request, response);//此处调用下面的getSessionId方法</p> 
 <p>}</p> 
 <p>return id;</p> 
 <p>}</p> 
 <p>protected Serializable getSessionId(ServletRequest request, ServletResponse response) {<!-- --></p> 
 <p>return getReferencedSessionId(request, response);//调用下面的getReferencedSessionId方法</p> 
 <p>}</p> 
 <p>private Serializable getReferencedSessionId(ServletRequest request, ServletResponse response) {<!-- --></p> 
 <p>//这句是重点</p> 
 <p>String id = getSessionIdCookieValue(request, response);</p> 
 <p>if (id != null) {<!-- --></p> 
 <p>request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,</p> 
 <p>ShiroHttpServletRequest.COOKIE_SESSION_ID_SOURCE);</p> 
 <p>} else {<!-- --></p> 
 <p>//not in a cookie, or cookie is disabled - try the request URI as a fallback (i.e. due to URL rewriting):</p> 
 <p>//try the URI path segment parameters first:</p> 
 <p>id = getUriPathSegmentParamValue(request, ShiroHttpSession.DEFAULT_SESSION_ID_NAME);</p> 
 <p>if (id == null) {<!-- --></p> 
 <p>//not a URI path segment parameter, try the query parameters:</p> 
 <p>String name = getSessionIdName();</p> 
 <p>id = request.getParameter(name);</p> 
 <p>if (id == null) {<!-- --></p> 
 <p>//try lowercase:</p> 
 <p>id = request.getParameter(name.toLowerCase());</p> 
 <p>}</p> 
 <p>}</p> 
 <p>if (id != null) {<!-- --></p> 
 <p>request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,</p> 
 <p>ShiroHttpServletRequest.URL_SESSION_ID_SOURCE);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>if (id != null) {<!-- --></p> 
 <p>request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id);</p> 
 <p>//automatically mark it valid here. If it is invalid, the</p> 
 <p>//onUnknownSession method below will be invoked and we'll remove the attribute at that time.</p> 
 <p>request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);</p> 
 <p>}</p> 
 <p>// always set rewrite flag - SHIRO-361</p> 
 <p>request.setAttribute(ShiroHttpServletRequest.SESSION_ID_URL_REWRITING_ENABLED, isSessionIdUrlRewritingEnabled());</p> 
 <p>return id;</p> 
 <p>}</p> 
 <p>关键在第18行String id = getSessionIdCookieValue(request, response);这句,继续跟进去.</p> 
 <p>private String getSessionIdCookieValue(ServletRequest request, ServletResponse response) {<!-- --></p> 
 <p>if (!isSessionIdCookieEnabled()) {<!-- --></p> 
 <p>log.debug("Session ID cookie is disabled - session id will not be acquired from a request cookie.");</p> 
 <p>return null;</p> 
 <p>}</p> 
 <p>if (!(request instanceof HttpServletRequest)) {<!-- --></p> 
 <p>log.debug("Current request is not an HttpServletRequest - cannot get session ID cookie. Returning null.");</p> 
 <p>return null;</p> 
 <p>}</p> 
 <p>HttpServletRequest httpRequest = (HttpServletRequest) request;</p> 
 <p>return getSessionIdCookie().readValue(httpRequest, WebUtils.toHttp(response));</p> 
 <p>}</p> 
 <p>可以看到这个方法的返回值是getSessionIdCookie().readValue(httpRequest, WebUtils.toHttp(response));其中getSessionIdCookie()返回的是一个Cookie对象,但是注意这里的Cookie是shiro自定义的一个接口.</p> 
 <p>public interface Cookie {<!-- --></p> 
 <p>/**</p> 
 <p>* The value of deleted cookie (with the maxAge 0).</p> 
 <p>*/</p> 
 <p>public static final String DELETED_COOKIE_VALUE = "deleteMe";</p> 
 <p>/**</p> 
 <p>* The number of seconds in one year (= 60 * 60 * 24 * 365).</p> 
 <p>*/</p> 
 <p>public static final int ONE_YEAR = 60 * 60 * 24 * 365;</p> 
 <p>/**</p> 
 <p>* Root path to use when the path hasn't been set and request context root is empty or null.</p> 
 <p>*/</p> 
 <p>public static final String ROOT_PATH = "/";</p> 
 <p>String getName();</p> 
 <p>void setName(String name);</p> 
 <p>String getValue();</p> 
 <p>void setValue(String value);</p> 
 <p>String getComment();</p> 
 <p>void setComment(String comment);</p> 
 <p>String getDomain();</p> 
 <p>void setDomain(String domain);</p> 
 <p>int getMaxAge();</p> 
 <p>void setMaxAge(int maxAge);</p> 
 <p>String getPath();</p> 
 <p>void setPath(String path);</p> 
 <p>boolean isSecure();</p> 
 <p>void setSecure(boolean secure);</p> 
 <p>int getVersion();</p> 
 <p>void setVersion(int version);</p> 
 <p>void setHttpOnly(boolean httpOnly);</p> 
 <p>boolean isHttpOnly();</p> 
 <p>void saveTo(HttpServletRequest request, HttpServletResponse response);</p> 
 <p>void removeFrom(HttpServletRequest request, HttpServletResponse response);</p> 
 <p>String readValue(HttpServletRequest request, HttpServletResponse response);</p> 
 <p>}</p> 
 <p>我们来看看其子类SimpleCookie中的readValue,这里的SimpleCookie就是我们之前在springboot中所配置的bean,我们给它命了个名字叫"token".</p> 
 <p>@Bean</p> 
 <p>public SimpleCookie wapsession() {<!-- --></p> 
 <p>SimpleCookie simpleCookie = new SimpleCookie("token");</p> 
 <p>simpleCookie.setMaxAge(2592000);</p> 
 <p>return simpleCookie;</p> 
 <p>}</p> 
 <p>然后去看它的readValue方法.</p> 
 <p>public String readValue(HttpServletRequest request, HttpServletResponse ignored) {<!-- --></p> 
 <p>String name = getName();</p> 
 <p>String value = null;</p> 
 <p>javax.servlet.http.Cookie cookie = getCookie(request, name);</p> 
 <p>if (cookie != null) {<!-- --></p> 
 <p>// Validate that the cookie is used at the correct place.</p> 
 <p>String path = StringUtils.clean(getPath());</p> 
 <p>if (path != null &amp;&amp; !pathMatches(path, request.getRequestURI())) {<!-- --></p> 
 <p>log.warn("Found '{}' cookie at path '{}', but should be only used for '{}'", new Object[] { name, request.getRequestURI(), path});</p> 
 <p>} else {<!-- --></p> 
 <p>value = cookie.getValue();</p> 
 <p>log.debug("Found '{}' cookie value [{}]", name, value);</p> 
 <p>}</p> 
 <p>} else {<!-- --></p> 
 <p>log.trace("No '{}' cookie value", name);</p> 
 <p>}</p> 
 <p>return value;</p> 
 <p>}</p> 
 <p>上面第2行的getName()返回的是cookie的名称,我们在配置时传入的是字符串"token",再看第4行中的getCookie方法,虽然前面的Cookie对象是shiro自定义的,但这里获取的cookie却是java原生的javax.servlet.http.Cookie类.</p> 
 <p>private static javax.servlet.http.Cookie getCookie(HttpServletRequest request, String cookieName) {<!-- --></p> 
 <p>javax.servlet.http.Cookie cookies[] = request.getCookies();</p> 
 <p>if (cookies != null) {<!-- --></p> 
 <p>for (javax.servlet.http.Cookie cookie : cookies) {<!-- --></p> 
 <p>if (cookie.getName().equals(cookieName)) {<!-- --></p> 
 <p>return cookie;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>return null;</p> 
 <p>}</p> 
 <p>跟到这里总算找到shiro是在哪里拦截cookie的了,前面我们说过在app端是以Cookie为键,token=web_session_key-xxx为值的键值对方式传输的所以不会被拦截,而h5或小程序由于无法传输cookie则直接传token,那么服务端自然取不到cookie也就是说sessionid为null,所以当调用doGetSession(key)方法时返回的session对象也是null的,我们再往回看DefaultSecurityManager的createSubject方法,执行完context = resolveSession(context);之后返回的是一个session为null的上下文信息,紧接着执行context = resolvePrincipals(context);获取登录用户的Principal信息,由于在上面返回的context中并没有找到相关已登录的信息,自然取出来的principal和authenticationInfo也是null.</p> 
 <p>protected SubjectContext resolvePrincipals(SubjectContext context) {<!-- --></p> 
 <p>PrincipalCollection principals = context.resolvePrincipals();</p> 
 <p>if (CollectionUtils.isEmpty(principals)) {<!-- --></p> 
 <p>log.trace("No identity (PrincipalCollection) found in the context. Looking for a remembered identity.");</p> 
 <p>principals = getRememberedIdentity(context);</p> 
 <p>if (!CollectionUtils.isEmpty(principals)) {<!-- --></p> 
 <p>log.debug("Found remembered PrincipalCollection. Adding to the context to be used " +</p> 
 <p>"for subject construction by the SubjectFactory.");</p> 
 <p>context.setPrincipals(principals);</p> 
 <p>// The following call was removed (commented out) in Shiro 1.2 because it uses the session as an</p> 
 <p>// implementation strategy. Session use for Shiro's own needs should be controlled in a single place</p> 
 <p>// to be more manageable for end-users: there are a number of stateless (e.g. REST) applications that</p> 
 <p>// use Shiro that need to ensure that sessions are only used when desirable. If Shiro's internal</p> 
 <p>// implementations used Subject sessions (setting attributes) whenever we wanted, it would be much</p> 
 <p>// harder for end-users to control when/where that occurs.</p> 
 <p>//</p> 
 <p>// Because of this, the SubjectDAO was created as the single point of control, and session state logic</p> 
 <p>// has been moved to the DefaultSubjectDAO implementation.</p> 
 <p>// Removed in Shiro 1.2. SHIRO-157 is still satisfied by the new DefaultSubjectDAO implementation</p> 
 <p>// introduced in 1.2</p> 
 <p>// Satisfies SHIRO-157:</p> 
 <p>// bindPrincipalsToSession(principals, context);</p> 
 <p>} else {<!-- --></p> 
 <p>log.trace("No remembered identity found. Returning original context.");</p> 
 <p>}</p> 
 <p>}</p> 
 <p>return context;</p> 
 <p>}</p> 
 <p>public PrincipalCollection resolvePrincipals() {<!-- --></p> 
 <p>PrincipalCollection principals = getPrincipals();</p> 
 <p>if (CollectionUtils.isEmpty(principals)) {<!-- --></p> 
 <p>//check to see if they were just authenticated:</p> 
 <p>AuthenticationInfo info = getAuthenticationInfo();</p> 
 <p>if (info != null) {<!-- --></p> 
 <p>principals = info.getPrincipals();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>if (CollectionUtils.isEmpty(principals)) {<!-- --></p> 
 <p>Subject subject = getSubject();</p> 
 <p>if (subject != null) {<!-- --></p> 
 <p>principals = subject.getPrincipals();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>if (CollectionUtils.isEmpty(principals)) {<!-- --></p> 
 <p>//try the session:</p> 
 <p>Session session = resolveSession();</p> 
 <p>if (session != null) {<!-- --></p> 
 <p>principals = (PrincipalCollection) session.getAttribute(PRINCIPALS_SESSION_KEY);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>return principals;</p> 
 <p>}</p> 
 <p>再接着就是Subject subject =doCreateSubject(context); 创建一个subject了.来看下大致是怎么创建subject的.</p> 
 <p>public Subject createSubject(SubjectContext context) {<!-- --></p> 
 <p>//这里的context其实就是个map集合即上文调用context = resolveSession(context);返回的</p> 
 <p>if (!(context instanceof WebSubjectContext)) {<!-- --></p> 
 <p>return super.createSubject(context);</p> 
 <p>}</p> 
 <p>WebSubjectContext wsc = (WebSubjectContext) context;</p> 
 <p>SecurityManager securityManager = wsc.resolveSecurityManager();</p> 
 <p>Session session = wsc.resolveSession();//取出的session是null</p> 
 <p>//在context中没有取到key的SESSION_CREATION_ENABLED的元素,所以直接返回为ture</p> 
 <p>boolean sessionEnabled = wsc.isSessionCreationEnabled();</p> 
 <p>PrincipalCollection principals = wsc.resolvePrincipals();//取出的principals是null</p> 
 <p>//由于前面得到的AuthenticationInfo是null,所以这里的authenticated 为false</p> 
 <p>boolean authenticated = wsc.resolveAuthenticated();</p> 
 <p>String host = wsc.resolveHost();</p> 
 <p>ServletRequest request = wsc.resolveServletRequest();</p> 
 <p>ServletResponse response = wsc.resolveServletResponse();</p> 
 <p>return new WebDelegatingSubject(principals, authenticated, host, session, sessionEnabled,</p> 
 <p>request, response, securityManager);</p> 
 <p>}</p> 
 <p>可以看到最终创建的subject对象.</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>image.png</p> 
 <p>subject创建完了,接着就是过滤器链的处理了,中间经过ProxiedFilterChain、OncePerRequestFilter、AdviceFilter、PathMatchingFilter这几个过滤器再到AccessControlFilter.onPreHandle方法.</p> 
 <p>public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {<!-- --></p> 
 <p>return isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue);</p> 
 <p>}</p> 
 <p>isAccessAllowed调的是AuthenticationFilter中的isAccessAllowed方法.</p> 
 <p>protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) {<!-- --></p> 
 <p>Subject subject = getSubject(request, response);</p> 
 <p>return subject.isAuthenticated();</p> 
 <p>}</p> 
 <p>这里的subject就是我们之前创建的subject了,显然isAuthenticated方法返回false.接着执行onAccessDenied方法,此方法实现在AuthenticatingFilter的子类FormAuthenticationFilter中.</p> 
 <p>protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {<!-- --></p> 
 <p>if (isLoginRequest(request, response)) {<!-- --></p> 
 <p>if (isLoginSubmission(request, response)) {<!-- --></p> 
 <p>if (log.isTraceEnabled()) {<!-- --></p> 
 <p>log.trace("Login submission detected. Attempting to execute login.");</p> 
 <p>}</p> 
 <p>return executeLogin(request, response);</p> 
 <p>} else {<!-- --></p> 
 <p>if (log.isTraceEnabled()) {<!-- --></p> 
 <p>log.trace("Login page view.");</p> 
 <p>}</p> 
 <p>//allow them to see the login page ;)</p> 
 <p>return true;</p> 
 <p>}</p> 
 <p>} else {<!-- --></p> 
 <p>if (log.isTraceEnabled()) {<!-- --></p> 
 <p>log.trace("Attempting to access a path which requires authentication. Forwarding to the " +</p> 
 <p>"Authentication url [" + getLoginUrl() + "]");</p> 
 <p>}</p> 
 <p>saveRequestAndRedirectToLogin(request, response);</p> 
 <p>return false;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>代码很简单非登录请求则执行saveRequestAndRedirectToLogin方法.</p> 
 <p>protected void saveRequestAndRedirectToLogin(ServletRequest request, ServletResponse response) throws IOException {<!-- --></p> 
 <p>saveRequest(request);</p> 
 <p>redirectToLogin(request, response);</p> 
 <p>}</p> 
 <p>//以下两个方法皆在WebUtils类中实现.</p> 
 <p>protected void saveRequest(ServletRequest request) {<!-- --></p> 
 <p>WebUtils.saveRequest(request);</p> 
 <p>}</p> 
 <p>public static void saveRequest(ServletRequest request) {<!-- --></p> 
 <p>Subject subject = SecurityUtils.getSubject();</p> 
 <p>Session session = subject.getSession();//重点看这行</p> 
 <p>HttpServletRequest httpRequest = toHttp(request);</p> 
 <p>SavedRequest savedRequest = new SavedRequest(httpRequest);</p> 
 <p>session.setAttribute(SAVED_REQUEST_KEY, savedRequest);</p> 
 <p>}</p> 
 <p>上面的Session session = subject.getSession();真正调用的是getSession(true);方法参数为true表示会创建一个新的session对象.这块代码相对简单可以加断点一步步跟进去,大致上最终就是调用我们自定义的RedisSessionDao创建一个新的session对象之后,再执行DefaultWebSessionManager的storeSessionId方法创建一个SimpleCookie对象,最后在response中添加到请求头header里面.</p> 
 <p>public void saveTo(HttpServletRequest request, HttpServletResponse response) {<!-- --></p> 
 <p>String name = getName();</p> 
 <p>String value = getValue();</p> 
 <p>String comment = getComment();</p> 
 <p>String domain = getDomain();</p> 
 <p>String path = calculatePath(request);</p> 
 <p>int maxAge = getMaxAge();</p> 
 <p>int version = getVersion();</p> 
 <p>boolean secure = isSecure();</p> 
 <p>boolean httpOnly = isHttpOnly();</p> 
 <p>addCookieHeader(response, name, value, comment, domain, path, maxAge, version, secure, httpOnly);</p> 
 <p>}</p> 
 <p>private void addCookieHeader(HttpServletResponse response, String name, String value, String comment,</p> 
 <p>String domain, String path, int maxAge, int version,</p> 
 <p>boolean secure, boolean httpOnly) {<!-- --></p> 
 <p>String headerValue = buildHeaderValue(name, value, comment, domain, path, maxAge, version, secure, httpOnly);</p> 
 <p>response.addHeader(COOKIE_HEADER_NAME, headerValue);</p> 
 <p>if (log.isDebugEnabled()) {<!-- --></p> 
 <p>log.debug("Added HttpServletResponse Cookie [{}]", headerValue);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>新的session对象生成之后最终将执行redirectToLogin方法,由于我们自定义了扩展自FormAuthenticationFilter的过滤器,因此调用的是我们自己的方法,并在其中对不同的调用端做不同的响应处理.</p> 
 <p>@Override</p> 
 <p>protected void redirectToLogin(ServletRequest request,</p> 
 <p>ServletResponse response) throws IOException {<!-- --></p> 
 <p>String loginUrl = getLoginUrl();</p> 
 <p>if (logger.isDebugEnabled()) {<!-- --></p> 
 <p>logger.debug("客户端登录的URL:{}", loginUrl);</p> 
 <p>}</p> 
 <p>HttpServletRequest httpRequest = (HttpServletRequest) request;</p> 
 <p>//System.out.println(httpRequest.getRequestURL());</p> 
 <p>HttpServletResponse httpResponse = (HttpServletResponse) response;</p> 
 <p>httpResponse.setContentType("text/html; charset=utf-8");</p> 
 <p>httpRequest.setCharacterEncoding("UTF-8");</p> 
 <p>// 是否为APP登录请求</p> 
 <p>if (StringHelpUtils.isNotBlank(httpRequest.getHeader("device"))</p> 
 <p>&amp;&amp; (httpRequest.getHeader("device").equals("APP") || httpRequest</p> 
 <p>.getHeader("device").equals("H5"))) {<!-- --></p> 
 <p>String token = httpRequest.getHeader(TOKEN);</p> 
 <p>if (logger.isDebugEnabled()) {<!-- --></p> 
 <p>logger.debug("客户端设备:{},token:{}",</p> 
 <p>httpRequest.getHeader("device"), token);</p> 
 <p>}</p> 
 <p>if (StringHelpUtils.isBlank(token)) {<!-- --></p> 
 <p>ResponseEntity result = new ResponseEntity().isOk(HttpStatus.TOKEN_NOT_EXIST,</p> 
 <p>"认证失败!");</p> 
 <p>httpResponse.getWriter().append(JSON.toJSONString(result));</p> 
 <p>httpResponse.getWriter().flush();</p> 
 <p>httpResponse.getWriter().close();</p> 
 <p>} else {<!-- --></p> 
 <p>ResponseEntity result = new ResponseEntity().isOk(</p> 
 <p>HttpStatus.APP_UNKNOW_ACCOUNT, "认证失败!");</p> 
 <p>httpResponse.getWriter().append(JSON.toJSONString(result));</p> 
 <p>httpResponse.getWriter().flush();</p> 
 <p>httpResponse.getWriter().close();</p> 
 <p>}</p> 
 <p>} else {<!-- --></p> 
 <p>// PC跳转 如果是非Ajax请求 按默认的配置跳转到登录页面</p> 
 <p>if (!"XMLHttpRequest".equalsIgnoreCase(httpRequest</p> 
 <p>.getHeader("X-Requested-With"))) {// 不是ajax请求</p> 
 <p>WebUtils.issueRedirect(request, response, loginUrl);</p> 
 <p>} else {<!-- --></p> 
 <p>// 如果是Aajx请求,则返回会话失效的JSON信息</p> 
 <p>ResponseEntity result = new ResponseEntity().isOk(</p> 
 <p>HttpStatus.SESSION_UNVAILDATE</p> 
 <p>, "请求失败!");</p> 
 <p>httpResponse.getWriter().append(JSON.toJSONString(result));</p> 
 <p>httpResponse.getWriter().flush();</p> 
 <p>httpResponse.getWriter().close();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ed9c5f8c6107655d65004603333bc3b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">声音存储空间计算公式_声音图像视频容量计算公式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/310fb9c78255f53e7e1c533690e406ff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">7-3 装箱问题 (10分)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>