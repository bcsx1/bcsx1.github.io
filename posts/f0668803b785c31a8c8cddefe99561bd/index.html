<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STL详解（四） 优先对列容器priority queue - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STL详解（四） 优先对列容器priority queue" />
<meta property="og:description" content="一、优先队列priority_queue简介 priority_queue（优先队列）允许用户为队列中元素设置优先级，放置元素的时候不是直接放到队尾，而是放置到比它优先级低的元素前面。
priority_queue有三个模板参数：priority_queue&lt;Type, Container, Functional&gt;，其中后两个可以省略。
Type :为数据类型，
Container: 为保存数据的容器，必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector。
Functional :为元素比较方式。基本数据类型或已定义了比较运算符的类，可以直接用STL的less算子和greater算子——默认使用less算子，即小的往后排，大的往前排，大的先出队（出队时，序列顶的最大的元素出队）。
对于greater 算子大的往后排，小的往前排，小的先出队（出队时，序列顶的最小的元素出队）。
二、定义priority_queue对象 示例代码如下：
priority_queue&lt;int&gt; q1;
priority_queue&lt;pair&lt;int,int&gt;&gt; q2;
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q3;//定义优先级小的先出队
三、成员函数列表及详细说明： empty() 如果队列为空返回真
pop() 删除队顶元素
push() 加入一个元素
size() 返回优先队列中拥有的元素个数
top() 返回优先队列队顶元素（队列中的front()变成了top()）
在默认的优先队列中，优先级高的先出队。在默认的int型中先出队的为较大的数。
注意：priority queue和 queue不同的是，priority queue没有j back() 和 front() ，而只能通过top()或pop() ,访问队尾元素（也称堆顶元素），也就是优先级最高的元素。
1、int 类型比较（默认从大到小，大的先出）
#include &lt;bits/stdc&#43;&#43;.h&gt; using namespace std; int main () {	priority_queue&lt;int&gt; q; q.push(1); q.push(5); q.push(3); q.push(9); q.push(2); cout&lt;&lt;q.top()&lt;&lt;endl; q.pop(); cout&lt;&lt;q.top()&lt;&lt;endl; system(&#34;pause&#34;); return 0; } 结果为：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/f0668803b785c31a8c8cddefe99561bd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-10T19:16:31+08:00" />
<meta property="article:modified_time" content="2023-11-10T19:16:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STL详解（四） 优先对列容器priority queue</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、优先队列priority_queue简介</h2> 
<p>        priority_queue（优先队列）允许用户为队列中元素设置优先级，放置元素的时候不是直接放到队尾，而是放置到比它优先级低的元素前面。</p> 
<p>priority_queue有三个模板参数：priority_queue&lt;Type, 　Container, 　Functional&gt;，其中后两个可以省略。</p> 
<p><strong>Type :</strong>为数据类型，</p> 
<p><strong>Container:</strong> 为保存数据的容器，必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector。</p> 
<p><strong>Functional :</strong>为元素比较方式。基本数据类型或已定义了比较运算符的类，可以直接用STL的less算子和greater算子——默认使用less算子，即小的往后排，大的往前排，大的先出队（出队时，序列顶的最大的元素出队）。</p> 
<p>对于greater 算子大的往后排，小的往前排，小的先出队（出队时，序列顶的最小的元素出队）。</p> 
<p></p> 
<p><img alt="" class="has" height="384" src="https://images2.imgbox.com/5d/db/fYzrcizi_o.png" width="354"></p> 
<p></p> 
<h2>二、定义priority_queue对象</h2> 
<p><strong>示例代码如下：</strong></p> 
<p>priority_queue&lt;int&gt; q1;</p> 
<p>priority_queue&lt;pair&lt;int,int&gt;&gt; q2;</p> 
<p>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q3;//定义优先级小的先出队<br>  </p> 
<h2>三、成员函数列表及详细说明：</h2> 
<p><br> empty() 如果队列为空返回真</p> 
<p>pop() 删除队顶元素</p> 
<p>push() 加入一个元素</p> 
<p>size() 返回优先队列中拥有的元素个数</p> 
<p>top() 返回优先队列队顶元素（队列中的front()变成了top()）</p> 
<p>在默认的优先队列中，优先级高的先出队。在默认的int型中先出队的为较大的数。</p> 
<p>注意：priority queue和 queue不同的是，<span style="color:#f33b45;">priority queue没有j back() 和 front() </span>，而只能通过top()或pop()  ,访问队尾元素（也称堆顶元素），也就是优先级最高的元素。</p> 
<p></p> 
<p>1、int 类型比较（默认从大到小，大的先出）</p> 
<pre class="has"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main ()
{	priority_queue&lt;int&gt; q;
	q.push(1);
	q.push(5);
	q.push(3);
	q.push(9);
	q.push(2);
	cout&lt;&lt;q.top()&lt;&lt;endl;
	q.pop();
	cout&lt;&lt;q.top()&lt;&lt;endl;
	system("pause");
	return 0;
}</code></pre> 
<p>结果为：</p> 
<p></p> 
<p>改写算子（从小到大，小的先出）</p> 
<pre class="has"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main ()
{	priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;
	q.push(1);
	q.push(5);
	q.push(3);
	q.push(9);
	q.push(2);
	cout&lt;&lt;q.top()&lt;&lt;endl;
	q.pop();
	cout&lt;&lt;q.top()&lt;&lt;endl;
	system("pause");
	return 0;
}</code></pre> 
<p>结果为：</p> 
<p></p> 
<p>2.pari的比较，先比较第一个元素，第一个相等比较第二个</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;
int main() 
{
    priority_queue&lt;pair&lt;int, int&gt; &gt; a;
    pair&lt;int, int&gt; b(1, 2);
    pair&lt;int, int&gt; c(1, 3);
    pair&lt;int, int&gt; d(2, 5);
    a.push(d);
    a.push(c);
    a.push(b);
    while (!a.empty()) 
    {
        cout &lt;&lt; a.top().first &lt;&lt; ' ' &lt;&lt; a.top().second &lt;&lt; '\n';
        a.pop();
    }
}</code></pre> 
<p></p> 
<p></p> 
<p>使用priority_queue时，最困难的可能就是如何定义比较算子了。</p> 
<p></p> 
<h2><strong>四、自己定义比较算子</strong></h2> 
<p><strong>    </strong>可以有多种方法，最常见的就是重载比较运算符，注意重载操作返回的结果是bool类型，并且此处的比较操作与map等其他处不同，在map中以&lt;作为比较操作，则值小的排在前面，而优先级队列中以&lt;作为比较操作，值大的优先级高，而优先级高的放在队列前面，反之以&gt;操作符确定优先级关系时，表明优先级是按值从大到小排列，值小的优先级高，优先级高的放在队列前面。</p> 
<p></p> 
<p><strong>自定义优先级的三种方法：</strong></p> 
<p></p> 
<p><strong>1.结构体声明方式：定义在结构体内部</strong></p> 
<p><strong>第一种方式：</strong></p> 
<pre class="has"><code class="language-cpp">struct node{
    int value;
    friend bool operator&lt;(const node &amp;a,const node &amp;b){
        return a.value&lt;b.value;  //按value从大到小排列
    }
};
priority_queue&lt;node&gt;q;  </code></pre> 
<p>第二种方式：</p> 
<pre><code class="language-cpp">struct T{
    int x,y,z;
    bool operator&lt;(const T &amp;a) const {
        return z&lt;a.z; // '&gt;'按照z从小到大排列,'&lt;'按照z从大到小排列
    }
}a;</code></pre> 
<p>        下面这个例子是<strong>结构体声明方式</strong>，在priority_queue中插入若干个结构体，结构体成员为(x,y,z)，以结构体成员z值来确定优先级顺序：</p> 
<pre class="has"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
struct T{
    int x,y,z;
    friend bool operator&lt;(const T &amp;a,const T &amp;b){
        return a.z&lt;b.z; // '&gt;'按照z从小到大排列,'&lt;'按照z从大到小排列
    }
}a;
priority_queue&lt;T&gt;q;  

int main()  
{   for(int i=1;i&lt;=4;i++)
    {  cin&gt;&gt;a.x&gt;&gt;a.y&gt;&gt;a.z;
       q.push(a);
	}   
    
    while(!q.empty())  
    {   T t=q.top();  
        q.pop();  
        cout&lt;&lt;t.x&lt;&lt;" "&lt;&lt;t.y&lt;&lt;" "&lt;&lt;t.z&lt;&lt;endl;  
    }  
    system("Pause");  
    return 1;  
}  </code></pre> 
<p>　</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
struct T{
    int x,y,z;
    bool operator&lt;(const T &amp;a) const {
        return z&lt;a.z; // '&gt;'按照z从小到大排列,'&lt;'按照z从大到小排列
    }
}a;
priority_queue&lt;T&gt;q;  

int main()  
{   for(int i=1;i&lt;=4;i++)
    {  cin&gt;&gt;a.x&gt;&gt;a.y&gt;&gt;a.z;
       q.push(a);
	}   
    
    while(!q.empty())  
    {   T t=q.top();  
        q.pop();  
        cout&lt;&lt;t.x&lt;&lt;" "&lt;&lt;t.y&lt;&lt;" "&lt;&lt;t.z&lt;&lt;endl;  
    }  
    system("Pause");  
    return 1;  
}  </code></pre> 
<p>　</p> 
<p>输入：</p> 
<p>4 4 3 2 2 5 1 5 4 3 3 6</p> 
<p>输出：</p> 
<p></p> 
<p><strong>2、结构体声明方式：定义在结构体外部，重载操作符:</strong></p> 
<pre class="has"><code class="language-cpp">bool operator &lt; (const node &amp;a, const node &amp;b) //或者写成 bool operator&lt;( const node &amp;a, const node &amp;b)  
 {
     return a.value &lt; b.value; // 按照value从大到小排列
 } 
priority_queue&lt;node&gt;q;</code></pre> 
<p>(const node &amp;a是用引用传递，比按值传递node a效率更高，效果是一样的).</p> 
<p>　　下面这个例子是<strong>重载比较运算符</strong>，在priority_queue中插入若干个结构体，结构体成员为(x,y,z)，以结构体成员z值来确定优先级顺序，z值大的排在队列前面：</p> 
<pre class="has"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
struct T  
{  int x,y,z;   
}a;  
bool operator&lt;(const T &amp;t1,const T &amp;t2)  //或者写成 bool operator&lt;( const T &amp;t1, const T &amp;t2)  
{     return t1.z&lt;t2.z;  // '&gt;'按照z从小到大排列,'&lt;'按照z从大到小排列
}  
int main()  
{   priority_queue&lt;T&gt;q; 
    for(int i=1;i&lt;=4;i++)
    {  cin&gt;&gt;a.x&gt;&gt;a.y&gt;&gt;a.z;
       q.push(a);
	}   
    
    while(!q.empty())  
    {   T t=q.top();  
        q.pop();  
        cout&lt;&lt;t.x&lt;&lt;" "&lt;&lt;t.y&lt;&lt;" "&lt;&lt;t.z&lt;&lt;endl;  
    }  
    system("Pause");  
    return 1;  
}  </code></pre> 
<p>输入：</p> 
<p>4 4 3 2 2 5 1 5 4 3 3 6</p> 
<p>输出：</p> 
<p></p> 
<p><strong>3.比较函数声明方式:</strong></p> 
<pre class="has"><code class="language-cpp">struct cmp{

    bool operator ()( node &amp;a, node &amp;b)//或者写成 bool operator&lt;(const node &amp;a, const node )  
    {
        return a.value&gt;b.value;// 按照value从小到大排列
    }
};
priority_queue&lt;node, vector&lt;node&gt;, cmp&gt;q;
</code></pre> 
<p></p> 
<p>下面这个例子是自定义比较函数，在priority_queue中插入若干个结构体，结构体成员为(x,y,z)，以结构体成员z值来确定优先级顺序：</p> 
<pre class="has"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
struct T  
{  int x,y,z;   
}a;  
struct cmp
{   bool operator ()(T &amp;a, T &amp;b)  //或者写成 bool operator ()(const T &amp;a,const T &amp;b)
    {  return a.z&gt;b.z;// '&gt;'按照z从小到大排列,'&lt;'按照z从大到小排列
    }
};
priority_queue&lt;T, vector&lt;T&gt;, cmp&gt;q;

int main()  
{   for(int i=1;i&lt;=4;i++)
    {  cin&gt;&gt;a.x&gt;&gt;a.y&gt;&gt;a.z;
       q.push(a);
	}   
    
    while(!q.empty())  
    {   T t=q.top();  
        q.pop();  
        cout&lt;&lt;t.x&lt;&lt;" "&lt;&lt;t.y&lt;&lt;" "&lt;&lt;t.z&lt;&lt;endl;  
    }  
    system("Pause");  
    return 1;  
}  </code></pre> 
<p>输入：</p> 
<p>4 4 3 2 2 5 1 5 4 3 3 6</p> 
<p>输出：</p> 
<p><br>  </p> 
<p></p> 
<h2>五　应用举例：</h2> 
<p>1、<a class="link-info" href="https://www.luogu.com.cn/problem/P3887" rel="nofollow" title="P3887 [GDOI2014] 世界杯">P3887 [GDOI2014] 世界杯</a></p> 
<p><strong>１、  有序表的最小和</strong></p> 
<p><strong>【问题描述】</strong></p> 
<p>给出两个长度为 n 的有序表 A 和 B，在 A 和 B 中各任取一个元素，可以得到 n 2 个和，求这些和中最小的 n 个。</p> 
<p><strong>【输入格式】</strong></p> 
<p>第 1 行包含 1 个整数正 n（n≤400000）。</p> 
<p>第 2 行与第 3 行分别有 n 个整数，各代表有序表 A 和 B。一行中的每两个整数之间用一个空格隔开，大小在长整型范围内，数据保证有序表单调递增。</p> 
<p><strong>【输出格式】</strong></p> 
<p>输出共 n 行，每行一个整数，第 i 行为第 i 小的和。</p> 
<p>数据保证在 long long 范围内。<strong> </strong> </p> 
<p><strong>【输入样例】</strong></p> 
<p>3</p> 
<p>1 2 5</p> 
<p>2 4 7</p> 
<p><strong>【输出样例】</strong></p> 
<p>3</p> 
<p>4</p> 
<p>5</p> 
<p></p> 
<p></p> 
<p><strong>２、合并果子</strong></p> 
<p><strong>题目描述</strong></p> 
<p>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n−1 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1 ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。</p> 
<p>例如有 3种果子，数目依次为 1， 2， 9。可以先将 1 、 2堆合并，新堆数目为 3 ，耗费体力为 3 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12 ，耗费体力为 12 。所以多多总共耗费体力 3+12=15 。可以证明 15 为最小的体力耗费值。</p> 
<p><strong>输入输出格式</strong></p> 
<p><strong>输入格式：</strong></p> 
<p>共两行。<br> 第一行是一个整数 n(1≤n≤10000) ，表示果子的种类数。</p> 
<p>第二行包含 n 个整数，用空格分隔，第 i 个整数ai​(1≤ai​≤20000) 是第 i 种果子的数目。</p> 
<p><strong>输出格式：</strong></p> 
<p>一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 2^31 。</p> 
<p><strong>输入输出样例</strong></p> 
<p><strong>输入样例#1：</strong> </p> 
<pre class="has"><code class="language-html">3 
1 2 9 
</code></pre> 
<p><strong>输出样例#1：</strong> </p> 
<pre class="has"><code class="language-html">15
</code></pre> 
<p><strong>说明</strong></p> 
<p>对于30％的数据，保证有n≤1000：</p> 
<p>对于50％的数据，保证有n≤5000；</p> 
<p>对于全部的数据，保证有n≤10000</p> 
<p></p> 
<p><strong>3、priority queue练习</strong></p> 
<p>总时间限制: 2500ms　　　内存限制: 131072kB</p> 
<p><strong>描述</strong></p> 
<p>我们定义一个正整数a比正整数b优先的含义是：<br> *a的质因数数目（不包括自身）比b的质因数数目多；<br> *当两者质因数数目相等时，数值较大者优先级高。</p> 
<p></p> 
<p>现在给定一个容器，初始元素数目为0，之后每次往里面添加10个元素，每次添加之后，要求输出优先级最高与最低的元素，并把该两元素从容器中删除。</p> 
<p><strong>输入</strong></p> 
<p>第一行: num (添加元素次数，num &lt;= 30)</p> 
<p>下面10*num行，每行一个正整数n（n &lt; 10000000).</p> 
<p><strong>输出</strong></p> 
<p>每次输入10个整数后，输出容器中优先级最高与最低的元素，两者用空格间隔。</p> 
<p><strong>样例输入</strong></p> 
<pre class="has"><code class="language-html">1
10 7 66 4 5 30 91 100 8 9</code></pre> 
<p><strong>样例输出</strong></p> 
<pre class="has"><code class="language-html">66 5</code></pre> 
<p></p> 
<p><strong>4、看病要排队</strong></p> 
<p>看病要排队这个是地球人都知道的常识。 <br> 不过经过细心的0068的观察，他发现了医院里排队还是有讲究的。0068所去的医院有三个医生（汗，这么少）同时看病。而看病的人病情有轻重，所以不能根据简单的先来先服务的原则。所以医院对每种病情规定了10种不同的优先级。级别为10的优先权最高，级别为1的优先权最低。医生在看病时，则会在他的队伍里面选择一个优先权最高的人进行诊治。如果遇到两个优先权一样的病人的话，则选择最早来排队的病人。 <br><br> 现在就请你帮助医院模拟这个看病过程。</p> 
<p><strong>Input</strong></p> 
<p>输入数据包含多组测试，请处理到文件结束。 <br> 每组数据第一行有一个正整数N(0&lt;N&lt;2000)表示发生事件的数目。 <br> 接下来有N行分别表示发生的事件。 <br> 一共有两种事件： <br> 1:"IN A B",表示有一个拥有优先级B的病人要求医生A诊治。(0&lt;A&lt;=3,0&lt;B&lt;=10)<br> 2:"OUT A",表示医生A进行了一次诊治，诊治完毕后，病人出院。(0&lt;A&lt;=3)</p> 
<p><strong>Output</strong></p> 
<p>对于每个"OUT A"事件，请在一行里面输出被诊治人的编号ID。如果该事件时无病人需要诊治，则输出"EMPTY"。 <br> 诊治人的编号ID的定义为：在一组测试中，"IN A B"事件发生第K次时，进来的病人ID即为K。从1开始编号。 </p> 
<p><strong>Sample Input</strong></p> 
<pre class="has"><code class="language-html">7
IN 1 1
IN 1 2
OUT 1
OUT 2
IN 2 1
OUT 2
OUT 1
2
IN 1 1
OUT 1</code></pre> 
<p><strong>Sample Output</strong></p> 
<pre class="has"><code class="language-html">2
EMPTY
3
1
</code></pre> 
<p><strong>思路：</strong>简单的模拟，或者直接用优先队列，因为病人的级别越高就有更高的优先权，所以用优先队列更容易理解；</p> 
<p><strong>代码:模拟</strong></p> 
<pre class="has"><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,k;
int s1[2010],s2[2010],s3[2010],s[2010];
void fun(int a) {
	int i,t=0,max=-1;
	if(a==1) {
		for(i=1; i&lt;k; i++)
			if(s1[i]&amp;&amp;s1[i]&gt;max) { //判断A级医生诊断的病人且级别高的人优先看病
				max=s1[i];
				t=i;
			}
		s1[t]=0;
		s[n++]=t;// 把病人的ID储存起来
	} else if(a==2) { //B级医生与A医生级相同 ，同理A级医生
		for(i=0; i&lt;k; i++)
			if(s2[i]&amp;&amp;s2[i]&gt;max) {
				max=s2[i];
				t=i;
			}
		s2[t]=0;
		s[n++]=t;
	} else {
		//同理与上
		for(i=0; i&lt;k; i++)
			if(s3[i]&amp;&amp;s3[i]&gt;max) {
				max=s3[i];
				t=i;
			}
		s3[t]=0;
		s[n++]=t;
	}
}
int main() {
	int m;
	while(~scanf("%d",&amp;m)) {
		int i,j,a,b;
		n=0;
		k=1;
		memset(s1,0,sizeof(s1));//清空数组；
		memset(s2,0,sizeof(s2));
		memset(s3,0,sizeof(s3));
		char c[100];
		for(i=0; i&lt;m; i++) {
			scanf("%s",c);
			if(c[0]=='I') {
				scanf("%d%d",&amp;a,&amp;b);
				if(a==1)//把看病的病人储存在数组中
					s1[k++]=b;//不同医生看的病人储存在不同的数组中
				else if(a==2) s2[k++]=b;
				else     s3[k++]=b;
			}
			if(c[0]=='O') { //当有 医生诊治完时，
				scanf("%d",&amp;a);
				fun(a);//储存医生诊断的病人；
			}
		}
		for(i=0; i&lt;n; i++) {
			if(s[i])//如果数组s不为0，说明有医生诊断 ，否则就没有；
				printf("%d\n",s[i]);
			else
				printf("EMPTY\n");
		}
	}
}
</code></pre> 
<p>思路：将每个病人的信息储存为一个结构体，将每个医生的求诊信息当成队列数组中的元素。以病人的级别，若级别相同，则以病人来到医院的先后作为队列的优先级。</p> 
<p><strong>代码</strong>：<strong>优先队列</strong></p> 
<pre class="has"><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct per {
	int num,id;
} s;
//先定义结构体，再写重载函数定义优先级比较简单明了
bool operator &lt; (const per &amp;x,const per &amp;y) { //重载 "&lt;" 操作符定义优先级
	if(x.num==y.num)//当级别相同时从小到大排序
		return x.id&gt;y.id;
	else
		return x.num&lt;y.num;//当级别不同是从大到小排序
}

int main() {
	int n,a,b;
	char str[5];
	while(scanf("%d",&amp;n)!=EOF) {
		int k=1;
		priority_queue&lt;per&gt;q[4];
		while(n--) {
			scanf("%s%d",str,&amp;a);
			if(strcmp(str,"IN")==0) {
				scanf("%d",&amp;b);
				s.num=b;
				s.id=k++;//储存病人的ID;
				q[a].push(s);//把病人入队列；
			} else {
				if(!q[a].empty()) { //有医生诊断
					s=q[a].top();
					q[a].pop();
					printf("%d\n",s.id);
				} else
					printf("EMPTY\n");
			}
		}
	}
	return 0;
}</code></pre> 
<p></p> 
<p><strong>１、  有序表的最小和</strong></p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
priority_queue&lt;int, vector&lt;int&gt;,greater&lt;int&gt; &gt; q;
int n,i,j,a[400001],b[400001];
int main()  
{   
    cin&gt;&gt;n;
    for( i=1;i&lt;=n;i++)  cin&gt;&gt;a[i]; 
    for(i=1;i&lt;=n;i++)   cin&gt;&gt;b[i];  
    for(i=1;i&lt;=n;i++)
      for(j=1;j&lt;=n;j++)  
         q.push(a[i]+b[j]);
    
    for(i=1;i&lt;=n;i++)
    {    cout&lt;&lt;q.top()&lt;&lt;endl;  q.pop();   }      
}</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/66d56cc703a903ad4325c1c2b5088742/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STL详解（二） 栈容器Stack</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/39bf9c429e1857c53f1b65032708d229/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux 防火墙操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>