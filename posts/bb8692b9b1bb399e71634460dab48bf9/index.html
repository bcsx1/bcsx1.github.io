<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[计算机毕设]基于java的本地监听与远程端口扫描系统设计与实现(源代码&#43;项目报告) - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[计算机毕设]基于java的本地监听与远程端口扫描系统设计与实现(源代码&#43;项目报告)" />
<meta property="og:description" content="本地监听与远程端口扫描的设计与开发
项目材料报告
随着Internet的不断发展，信息技术已成为社会进步的巨大推动力。不管是存储于服务器里还是流通于Internet上的信息都已成为一个关系事业成败的关键，这就使保证信息的安全变得格外重要。本地监听与远程端口扫描程序就是在基于Internet的端口扫描的基础上，开发的一个基于java的本地监听和远程端口扫描的小程序。
该程序主要包括四个功能模块：显示当前系统信息；显示网络状态；显示当前进程；扫描计算机。其中当前系统信息和网络状态可以反应出当前计算机的系统配置和网络设置,让用户可以直观便捷的了解主机状况。而本地监听实现对正在运行进程的监听和进程分析。远程端口扫描用来对本机或远程主机的端口开放状态进行检测。通过使用以上四个功能可以使用户对本机的安全程度有更好认识，也可以对目标主机的开放状况有更直观的了解。
目 录
论文页数：19页
1引言. 1
1.1课题背景. 1
1.2 课题研究意义. 1
1.3 与以往的程序的区别. 1
2 基本理论. 2
2.1 TCP/IP协议和IP地址. 2
2.2 用TCP/IP进行通信的示意图. 3
2.3 端口. 3
2.4 JAVA Socket类. 3
3 系统功能模块设计与实现. 4
3.1 体系结构与功能介绍. 4
3.1.1 体系结构. 4
3.1.2 功能大体介绍. 4
3.2 程序主界面. 5
3.3 当前系统信息界面. 6
3.4 网络状态程序界面. 7
3.5 本地监听. 7
3.6 远程端口扫描. 8
3.6.1 Socket类编程机制. 8
3.6.2 功能详解. 10
4系统关键点测试. 14
结 论." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/bb8692b9b1bb399e71634460dab48bf9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-28T23:00:47+08:00" />
<meta property="article:modified_time" content="2023-10-28T23:00:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[计算机毕设]基于java的本地监听与远程端口扫描系统设计与实现(源代码&#43;项目报告)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <p style="margin-left:0;text-align:center;"><strong>本地监听与远程端口扫描的设计与开发</strong></p> 
 <p style="margin-left:0;text-align:center;"><strong>项目材料报告</strong></p> 
 <p style="margin-left:0;text-align:justify;">随着Internet的不断发展，信息技术已成为社会进步的巨大推动力。不管是存储于服务器里还是流通于Internet上的信息都已成为一个关系事业成败的关键，这就使保证信息的安全变得格外重要。本地监听与远程端口扫描程序就是在基于Internet的端口扫描的基础上，开发的一个基于java的本地监听和远程端口扫描的小程序。</p> 
 <p style="margin-left:0;text-align:justify;">该程序主要包括四个功能模块：显示当前系统信息；显示网络状态；显示当前进程；扫描计算机。其中当前系统信息和网络状态可以反应出当前计算机的系统配置和网络设置,让用户可以直观便捷的了解主机状况。而本地监听实现对正在运行进程的监听和进程分析。远程端口扫描用来对本机或远程主机的端口开放状态进行检测。通过使用以上四个功能可以使用户对本机的安全程度有更好认识，也可以对目标主机的开放状况有更直观的了解。</p> 
 <p style="margin-left:0;text-align:center;"><strong> </strong><strong>目  录</strong></p> 
 <p style="margin-left:0;"><strong>论文页数：19页</strong></p> 
 <p style="margin-left:0;"><strong><span style="color:#000066;"><a href="#_Toc178566081" rel="nofollow">1引言. 1</a></span></strong></p> 
 <p style="margin-left:10.5pt;"><span style="color:#000066;"><a href="#_Toc178566082" rel="nofollow">1.1课题背景. 1</a></span></p> 
 <p style="margin-left:10.5pt;"><span style="color:#000066;"><a href="#_Toc178566083" rel="nofollow">1.2 课题研究意义. 1</a></span></p> 
 <p style="margin-left:10.5pt;"><span style="color:#000066;"><a href="#_Toc178566084" rel="nofollow">1.3 与以往的程序的区别. 1</a></span></p> 
 <p style="margin-left:0;"><strong><span style="color:#000066;"><a href="#_Toc178566085" rel="nofollow">2 基本理论. 2</a></span></strong></p> 
 <p style="margin-left:21pt;"><em><span style="color:#000066;"><a href="#_Toc178566086" rel="nofollow">2.1 TCP/IP协议和IP地址. 2</a></span></em></p> 
 <p style="margin-left:21pt;"><em><span style="color:#000066;"><a href="#_Toc178566087" rel="nofollow">2.2 用TCP/IP进行通信的示意图. 3</a></span></em></p> 
 <p style="margin-left:21pt;"><em><span style="color:#000066;"><a href="#_Toc178566088" rel="nofollow">2.3 端口. 3</a></span></em></p> 
 <p style="margin-left:21pt;"><em><span style="color:#000066;"><a href="#_Toc178566089" rel="nofollow">2.4 JAVA Socket类. 3</a></span></em></p> 
 <p style="margin-left:0;"><strong><span style="color:#000066;"><a href="#_Toc178566090" rel="nofollow">3 系统功能模块设计与实现. 4</a></span></strong></p> 
 <p style="margin-left:10.5pt;"><span style="color:#000066;"><a href="#_Toc178566091" rel="nofollow">3.1 体系结构与功能介绍. 4</a></span></p> 
 <p style="margin-left:21pt;"><em><span style="color:#000066;"><a href="#_Toc178566092" rel="nofollow">3.1.1 体系结构. 4</a></span></em></p> 
 <p style="margin-left:21pt;"><em><span style="color:#000066;"><a href="#_Toc178566093" rel="nofollow">3.1.2 功能大体介绍. 4</a></span></em></p> 
 <p style="margin-left:10.5pt;"><span style="color:#000066;"><a href="#_Toc178566094" rel="nofollow">3.2 程序主界面. 5</a></span></p> 
 <p style="margin-left:10.5pt;"><span style="color:#000066;"><a href="#_Toc178566095" rel="nofollow">3.3 当前系统信息界面. 6</a></span></p> 
 <p style="margin-left:10.5pt;"><span style="color:#000066;"><a href="#_Toc178566096" rel="nofollow">3.4 网络状态程序界面. 7</a></span></p> 
 <p style="margin-left:10.5pt;"><span style="color:#000066;"><a href="#_Toc178566097" rel="nofollow">3.5 本地监听. 7</a></span></p> 
 <p style="margin-left:10.5pt;"><span style="color:#000066;"><a href="#_Toc178566098" rel="nofollow">3.6 远程端口扫描. 8</a></span></p> 
 <p style="margin-left:21pt;"><em><span style="color:#000066;"><a href="#_Toc178566099" rel="nofollow">3.6.1 Socket类编程机制. 8</a></span></em></p> 
 <p style="margin-left:21pt;"><em><span style="color:#000066;"><a href="#_Toc178566100" rel="nofollow">3.6.2 功能详解. 10</a></span></em></p> 
 <p style="margin-left:0;"><strong><span style="color:#000066;"><a href="#_Toc178566101" rel="nofollow">4系统关键点测试. 14</a></span></strong></p> 
 <p style="margin-left:0;"><strong><span style="color:#000066;"><a href="#_Toc178566102" rel="nofollow">结   论. 17</a></span></strong></p> 
 <p style="margin-left:0;"><strong><span style="color:#000066;"><a href="#_Toc178566103" rel="nofollow">参考文献. 17</a></span></strong></p> 
 <p style="margin-left:0;"><strong><span style="color:#000066;"><a href="#_Toc178566104" rel="nofollow">致    谢. 18</a></span></strong></p> 
 <p style="margin-left:0;"><strong><span style="color:#000066;"><a href="#_Toc178566105" rel="nofollow">声    明. 19</a></span></strong></p> 
</div> 
<h2 style="margin-left:21.6pt;"><strong><a name="_Toc178566081">1引言</a></strong></h2> 
<h3 style="margin-left:0;text-align:justify;"><strong><a name="_Toc169410796"></a><a name="_Toc178566082"></a><a name="_Toc136592276"></a><a name="_Toc136593406"></a><a name="_Toc136593651"></a><a name="_Toc136927408"></a><a name="_Toc137205487"></a><a name="_Toc137206719"></a><a name="_Toc136592277"></a><a name="_Toc136593407"></a><a name="_Toc136593652"></a><a name="_Toc136927409"></a><a name="_Toc137205488"></a><a name="_Toc137206720"></a><a name="_Toc136592278"></a><a name="_Toc136593408"></a><a name="_Toc136593653"></a><a name="_Toc136927410"></a><a name="_Toc137205489"></a><a name="_Toc137206721"></a>1.1课题背景</strong></h3> 
<p style="margin-left:0;text-align:justify;">互联网与生俱有的开放性、交互性和分散性特征使人类所憧憬的信息共享、开放、灵活和快速等需求得到满足。网络环境为信息共享、信息交流、信息服务创造了理想空间，网络技术的迅速发展和广泛应用，为人类社会的进步提供了巨大推动力。然而，正是由于互联网的特性，产生了许多安全问题。</p> 
<p style="margin-left:0;text-align:justify;">本地监听与远程端口扫描统互相配合，能够有效提高网络的安全性。通过对计算机的扫描，管理员可以了解主机的安全配置和运行的进程，及时发现安全漏洞，客观评估本地主机的风险性。管理员根据扫描和监听的结果，对存在的漏洞进行重新修复。在黑客进行攻击前防范。如果防火墙和网络监控是被动的防御手段，那么本地监听和远程端口扫描则是主动防御手段，可以有效阻止黑客的攻击，做到防患于未然。</p> 
<h3 style="margin-left:0;text-align:justify;"><strong><a name="_Toc169410797"></a><a name="_Toc178566083">1.2 </a>课题研究意义</strong></h3> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">网络中的每一台计算机如同一座城堡，在这些城堡中，有的对外完全开放，有的却是紧锁城门。入侵者们是如何找到，打开城门的呢？这些城门究竟通往何处呢？</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">在网络技术中，把这些城堡的“城门“称之为计算机的端口，端口扫描是入侵者搜集信息的常用手法之一。扫描端口的目的如下：判断目标主机上开放了那些端口。判断目标主机的这些端口进行什么服务。掌握了这些信息后，入侵者能够使用相应的手段实现入侵。本程序即可以对本机正在运行的进程进行监听，并对自身的主机扫描，对结果进行分析，找出漏洞，从而为之后的重新配置做好准备。</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">利用平时所学的知识，将这个程序的各个功能实现。通过实践也可以进一步把所学的东西掌握牢固，找出其中不足的地方，在今后的学习生活中一步步的完善。</span></p> 
<h3 style="margin-left:0;text-align:justify;"><strong><a name="_Toc169410798"></a><a name="_Toc178566084">1.3 </a>与以往的程序的区别</strong></h3> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">本程序与以往的程序的最大的区别主要是该程序是使用Java语言编译的。而决大部分该类似程序都是运用VB或者VC语言编写的。而用平时自己自学的Java语言编写该程序对自身来说是一个挑战，也是检验知识掌握程度的一件工作。对于选择Java编译，主要是它有以下一些优点：</span></p> 
<p style="margin-left:0;text-align:justify;">1）面向对象性：</p> 
<p style="margin-left:0;text-align:justify;">面向对象是Java 最重要的特性。跟新一代程序设计语言相比，Java的面向对象性更加彻底，所有的Java 小程序和applet均是对象，其封装性实现了模块化和信息隐藏，继承性实现了代码的复用，使用户可以建立自己的类库。          </p> 
<p style="margin-left:0;text-align:justify;">2）平台无关性：</p> 
<p style="margin-left:0;text-align:justify;">Java的编译程序生成一种高级的、与机器独立的“机器码”（字节代码）它是针对由 Java解释程序和运行时系统实现的虚拟机器而生成的，可以在任何支持 Java解释器的操作系统平台上运行。因此，如果软件开发人员采用 Java，就没有必要为不同平台编写、编译并测试代码，从而可以大大节省开销；同样，用户在考虑购置字处理和出版软件时，也不必考虑软件制造商提供了什么支持环境。</p> 
<p style="margin-left:0;text-align:justify;">3）简洁性：</p> 
<p style="margin-left:0;text-align:justify;">Java是一种面向对象的高级程序设计语言，它特别注重简洁性 ，这个原则在电脑界被称为 KISS（Keep It Small and Simple）。它没有预处理程序、# define及相关的成份、首部（header）文件，且 Java中无危险的指针运算，既减少了程序的复杂性，又增加了安全性。 Java语言与 C+ + /C有许多相似之处，但却比 C+ + /C简单得多，不但易读易懂，而且代码的修改和重用也很容易；Java语言无结构（ structure）和联合（ Union）这样的复杂数据类型，可以利用类的实例变量达到同样的效果；Java语言也没有函数 （function），函数的功能可以通过定义一个类及为这个类建立方法来实现。</p> 
<p style="margin-left:0;text-align:justify;">4）可移植性：</p> 
<p style="margin-left:0;text-align:justify;">序被编译后生成的并不是机器代码，而是生成字节代码 （Byte Code）。字节代码是以 Java虚拟环境（Java Virtual Machine）为基础的，Java对每一个可能和系统软硬件相关的部分都作了明确的定义，这就消除了C++/C语言中数据类型的不确定性（例如整数类型 int在不同的系统中可能会有16bit，32bit或64bit等不同的长度）。Java语言环境本身也容易移植到新的体系结构和操作系统 ，其编译程序也是用 Java语言编写的，它运行时的系统是用 ANSI C编写的，带有清晰的可移植边界。</p> 
<p style="margin-left:0;text-align:justify;">5）安全性：</p> 
<p style="margin-left:0;text-align:justify;">Java语言摒弃了C++/C中大量过于复杂、容易导致编程错误和影响系统安全的部分，例如不再支持在C++/C中常用的指针操作、内存动态（ malloc和 free）分配等功能。 Java程序在执行时会对自身作严格的检查以防止任何非法的修改，因而它具有良好的防病毒和防止网络非法入侵的能力。</p> 
<h2 style="margin-left:21.6pt;"><strong><a name="_Toc178566085"></a><a name="_Toc169253936"></a><a name="_Toc169410799">2 </a>基本理论</strong></h2> 
<h4 style="margin-left:0;text-align:justify;"><strong><a name="_Toc169253938"></a><a name="_Toc169410801"></a><a name="_Toc178566086">2.1 TCP/IP</a>协议和IP地址</strong></h4> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">进入Internet联结的计算机必须根据网络要求遵循有关通信协议全球的Internet网就是基于TCP/IP协议，在网络中的各个计算机通信存在最基本问题就是如何识别与之通信的计算机，像城市中的街道内各户编号一样，IP地址是TCP/IP中用于唯一标识一台计算机的编号，IP地址提供对网络中计算机的标识以及它所在的网络。</span></p> 
<h4 style="margin-left:0;text-align:justify;"><strong><a name="_Toc169410802"></a><a name="_Toc178566087">2.2 </a>用TCP/IP进行通信的示意图</strong></h4> 
<p style="margin-left:0;text-align:justify;">在TCP/IP的应用层协议使用的是客户－服务器方式。客户（Client）和服务器（Server）都是指通信中所涉及的两个应用进程。客户－服务器方式所描述的是进程之间服务和被服务的关系。当A进程需要B进程的服务时就主动呼叫B进程，在这种情况下，A是客户而B是服务器。这里最重要的特征就是：客户是服务请求方，服务器是服务提供方。</p> 
<p style="margin-left:0;text-align:justify;">客户与服务器的通信关系一旦建立，通信就可是双向的，客户和服务器都可以发送和接收信息，如图1所示：</p> 
<p style="margin-left:0;text-align:center;">图1  TCP/IP通信方式                     </p> 
<p style="margin-left:0;text-align:justify;">当TCP/IP数据包到达目的地后，计算机首先去掉地址标志，利用TCP的装箱单检查数据在传输中是否有损失，如果接收方发现有损坏的数据包，就要求发送端重新发送被损坏的数据包，确认无误后再将各个数据包重新组合成原文件。就这样，Internet通过TCP/IP协议实现了全球通信的功能。</p> 
<h4 style="margin-left:0;text-align:justify;"><strong><a name="_Toc169410803"></a><a name="_Toc178566088">2.3 </a>端口</strong></h4> 
<p style="margin-left:0;text-align:justify;">通常因特网中的某种服务对应某个协议，并与某个惟一的端口号关联在一起。端口由一个16位二进制整数表示，应用进程必须与该端口号绑定才能进行通信。1024以下端口号保留为系统服务，其他为用户一般应用服务。</p> 
<h4 style="margin-left:0;text-align:justify;"><strong><a name="_Toc178566089"></a><a name="_Toc169410804">2.4 </a>JAVA Socket类</strong></h4> 
<p style="margin-left:0;text-align:justify;">Socket是著名的网络应用编程接口（API）之一,而 Java 语言是网络编程的主要语言，提供了强大和独特的网络通讯支持机制和能力。在Java网络编程中，Socket层次，即传统网络编程经常采用的方式，通过在Client/Server（客户机/服务器）结构的应用程序之间建立Socket套接字连接，然后在连接之上进行数据通信，是一种经常采用的通信模式。套接字类型Socket根据其传输数据类型的不同,可以分为以 下 三 种 类 型：</p> 
<p style="margin-left:0;text-align:justify;">1）字节流套接字（Socket -stream）,提供了一个双向的、面向连接的、可靠的、无差错的字节流通信，无重复的发送且按发送顺序接收。内设流量控制，避免数据流超限；不保持信息边界。实现这种特性的通信协议在收到差错时将重传信息，若在连接已经切断后再发数据则返回错误信息，FTP 协议即采用流式套接字。</p> 
<p style="margin-left:0;text-align:justify;">2）数据报套接字 （Socket Dgram）；提供了一个无连接服务，每个数据包都有地址。数据包以独立包形式被发送，但不保证顺序，不保证可靠或不重复。网络文件系统 NFS 使用数据报式套接字。</p> 
<p style="margin-left:0;text-align:justify;">3）原始数据套接字（Socket Raw），该接口允许对较低层次协议 ，如 IP、ICMP 直接访问。这不是给普通用户使用的，而是给要开发新协议或对低层协议有兴趣的人使用。</p> 
<h2 style="margin-left:21.6pt;"><strong><a name="_Toc169410811"></a><a name="_Toc178566090">3 </a>系统功能模块设计与实现</strong></h2> 
<h3 style="margin-left:0;text-align:justify;"><strong><a name="_Toc169410805"></a><a name="_Toc169600049"></a><a name="_Toc178566091">3.1 </a>体系结构与功能介绍</strong></h3> 
<h4 style="margin-left:0;text-align:justify;"><strong><a name="_Toc169410806"></a><a name="_Toc169600050"></a><a name="_Toc178566092">3.1.1 </a>体系结构</strong></h4> 
<p style="margin-left:0;text-align:justify;">设计C/S模式的本地监听和远程端口扫描。C/S模式本地监听远程扫描系统共有6个Java 源文件和1个form文件组成，form文件是主类的窗口文件，由IDE netbeans自动生成。主类MainJFrame.java主要完成本地进程的实时枚举，相关开放端口的枚举功能；ThreadScan.java主要完成多线程的远程主机扫描。其他的几个类文件主要是辅助类，以及方法实现类，用来完成响应的业务操作。</p> 
<h4 style="margin-left:0;text-align:justify;"><strong><a name="_Toc169410807"></a><a name="_Toc169600051"></a><a name="_Toc178566093">3.1.2 </a>功能大体介绍</strong></h4> 
<p style="margin-left:0;text-align:justify;">该程序有以下功能模块：</p> 
<p style="margin-left:0;text-align:justify;">本地监听：主要实现实时查看操作系统当前运行进程，并根据进程查看本机响应端口和远程计算机连接情况。用户可以实时枚举当前系统所有运行的进程，根据进程id和端口开放的关系，查找开放的TCP及UDP端口。由于java工作的虚拟机之上的，所以java并不能直接获得操作系统进程的句柄。这些操作只能通过操作系统API或者提供的接口程序运行，本次设计考虑到java本地接口和Runtime类运行操作系统自己提供的shell/命令行（windows）两种方式。</p> 
<p style="margin-left:0;text-align:justify;">远程扫描：远程端口Java socket类与远程主机给定的端口范围，采用多线程逐个连接。如果能够连接上表示对方相应的端口开放，如果不能视为没有开放。暂时不考虑对方主机存在防火墙。用户可以设定每次扫描的线程数，线程数越大，对当前扫描主机，及网络的压力就越大，扫描的速度也相对比较快。（程序规定扫描线程数为1-200的整数，默认线程数为100）。</p> 
<h3 style="margin-left:0;text-align:justify;"><strong><a name="_Toc169253941"></a><a name="_Toc169410812"></a><a name="_Toc178566094">3.2 </a>程序主界面</strong></h3> 
<p style="margin-left:0;text-align:center;">图2 主程序界面</p> 
<p style="margin-left:0;text-align:justify;">MainJFrame类主要实现该程序的界面排版，将实现程序界面的所有的类封装在com.text包中。该包中将程序主界面分为三个部分，分别用不同的组件去实现，它包括菜单栏，滚动窗格，以及消息提示框的文本区控件，程序主界面如图2所示。</p> 
<p style="margin-left:0;text-align:justify;">每一部分所使用的类以及对象如表1所示。</p> 
<p style="margin-left:0;text-align:center;">表1 组件以及类对照表</p> 
<table align="center" border="1" cellspacing="0"><tbody><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:center;">名 称</p> </td><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:center;">对 象</p> </td><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:center;">类</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:center;">菜单条</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:justify;">            menu</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:justify;">JMenuBar</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:center;">菜单</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:center;">文件，操作</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:center;">JMenu</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:center;">菜单项</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:justify;">本机信息，net，exit，当前进程信息，扫描计算机</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:center;">JMenuItem</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:center;">滚动窗格</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:center;">Pane13，tipPane</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:center;">JScrollBar</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:center;">文本区</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:center;">psInfo</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:center;">JTextArea</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:center;">表格</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:center;">table</p> </td><td style="vertical-align:top;"> <p style="margin-left:0;text-align:center;">JTable</p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;">首先在主窗体内创建轻量组件，如menu=new javax.swing.JMenuBar()定义了整个菜单条对象，如 文件 = new javax.swing.JMenu()，操作 = new javax.swing.JMenu()则是创建的菜单对象，菜单对象之下的菜单项对象如 当前系统信息 = new javax.swing.JMenuItem()；网络状态 = new javax.swing.JMenuItem()；当前进程信息 = new javax.swing.JMenuItem()；扫描计算机 = new javax.swing.JMenuItem()则是可以发生ActionEvent事件，通过鼠标点击实现该程序的两个主要功能：本地监听与远程端口扫描。</p> 
<h3 style="margin-left:0;text-align:justify;"><strong><a name="_Toc169410813"></a><a name="_Toc178566095">3.3 </a>当前系统信息界面 </strong></h3> 
<p style="margin-left:0;text-align:center;"><span style="color:#000000;">图3 当前系统信息</span></p> 
<p style="margin-left:0;text-align:justify;">在Java应用程序运行时，特别是需要在跨平台工作环境下运行时，需要确定操作系统类型、用户JDK版本和用户工作目录等随工作平台变化的信息，来保证程序正确运行。一般情况下，可以利用JDK提供的系统属性类（Properties）中的方法，快速地获取工作环境信息。另外，程序开发人员还可以定义与应用程序相关的系统属性文件，在用户程序执行过程中动态地加载程序员定义的属性文件来控制程序运行。</p> 
<p style="margin-left:0;text-align:justify;">主要功能显示操作系统的各种信息，以上的操作系统信息，系统版本，Java，jre安装路径，当前用户名都是通过使用System.getProperty()方法得到的，然后输出到创建的文本区中。比如获得系统名，可以通过调用方法System.getProperty(“os.name”)；系统版本通过调用方法System.getProperty("os.version")获得。</p> 
<p style="margin-left:0;text-align:justify;">String []headers={"操作系统","系统版本","java虚拟机版本","jre安装路径","当前用户名"}；</p> 
<p style="margin-left:0;text-align:justify;">    Properties   prop   =   new Properties(System.getProperties());</p> 
<p style="margin-left:0;text-align:justify;">        //在标准输出中输出系统属性的内容</p> 
<p style="margin-left:0;text-align:justify;">        //prop.list(System.out);</p> 
<p style="margin-left:0;text-align:justify;">        StringBuffer sys=new StringBuffer();</p> 
<p style="margin-left:0;text-align:justify;">        contents[0][0]=System.getProperty("os.name");</p> 
<p style="margin-left:0;text-align:justify;">        contents[0][1]=System.getProperty("os.version");</p> 
<p style="margin-left:0;text-align:justify;">        contents[0][2]=System.getProperty("java.vm.version");</p> 
<p style="margin-left:0;text-align:justify;">        contents[0][3]=System.getProperty("java.home");</p> 
<p style="margin-left:0;text-align:justify;">        contents[0][4]=System.getProperty("user.name");</p> 
<p style="margin-left:0;text-align:justify;">        contents[0][5]=System.getProperty("os.name");</p> 
<p style="margin-left:0;text-align:justify;">        dm.setDataVector(contents,headers);</p> 
<p style="margin-left:0;text-align:justify;">        table.setModel(dm);</p> 
<h3 style="margin-left:0;text-align:justify;"><strong><a name="_Toc169410814"></a><a name="_Toc178566096">3.4</a> 网络状态程序界面</strong></h3> 
<p style="margin-left:0;text-align:center;">   图4 网络状态界面</p> 
<p style="margin-left:0;text-align:justify;">该功能主要显示当前网络的各种配置信息，如主机名，物理地址，ip地址，子网掩码等数据。通过调用系统本身的可执行程序ipocnfig.exe，nbtstat.exe来实现网络状态的功能。而实现对系统程序的调用则离不开Java本身丰富的类。Prcess是java.Lang包中的一个类，可以使用该包中的Runtime类调用其静态方法exec得到Process的一个实例，exec方法可以运行一个可执行文件，即启动一个进程（如ipconfig与nbtstat命令），exec方法返回一个Process对象。一个Process对象可以使用个getInputStream（）方法获得该进程的输入流。利用Process中的流，获得该网络的信息。</p> 
<p style="margin-left:0;text-align:justify;">// Process pp = Runtime.getRuntime().exec("nbtstat -a " + ipAddress);</p> 
<p style="margin-left:0;text-align:justify;">            Process pp = Runtime.getRuntime().exec("ipconfig /all ");</p> 
<p style="margin-left:0;text-align:justify;">            InputStreamReader ir = new InputStreamReader(pp.getInputStream());</p> 
<p style="margin-left:0;text-align:justify;">            LineNumberReader input = new LineNumberReader(ir);</p> 
<p style="margin-left:0;text-align:justify;">           for (String str = input.readLine(); str != null; str = nextLines) //str对象通过readLine（）方法读取文本行，一直读取文本行的内容直到并显示内容直到下一文本行为空。           {<!-- --></p> 
<p style="margin-left:0;text-align:justify;">                if(str!=null)</p> 
<p style="margin-left:0;text-align:justify;">                    netInfo.append(str+"\n");</p> 
<h3 style="margin-left:0;text-align:justify;"><strong><a name="_Toc169410815"></a><a name="_Toc178566097">3.5 </a>本地监听</strong></h3> 
<p style="margin-left:0;text-align:justify;">它也可以显示当前进程的运行情况，如图5所示：                 </p> 
<p style="margin-left:0;text-align:center;"><span style="color:#000000;">图5 本地监听界面</span></p> 
<p style="margin-left:0;text-align:justify;">由于java工作的虚拟机之上的，所以java并不能直接获得操作系统进程的句柄。这些操作只能通过操作系统API或者提供的接口程序运行。当要执行本机上的可执行文件时，如tasklist.exe时，这里使用java.lang包中的Runtime类。对象process调用exec（“tasklist /v”）方法打开本机上上的可执行文件，然后将结果输入到文本区中。而这里read（）方法只读取其中的进程名称与进程号内容。</p> 
<p style="margin-left:0;text-align:justify;">String []headers={"进程名称","进程号"};…….</p> 
<p style="margin-left:0;text-align:justify;">……………</p> 
<p style="margin-left:0;text-align:justify;">String s1 = "tasklist";</p> 
<p style="margin-left:0;text-align:justify;">            Process process = Runtime.getRuntime().exec("tasklist /v");//通过Tasklist命令是一个用来显示运行在本地或远程计算机上的所有进程的命令行工具。</p> 
<p style="margin-left:0;text-align:justify;">            BufferedReader bufferedreader = new BufferedReader(new InputStreamReader(process.getInputStream()));//BufferReader方法可以把一个流（对象）接到另一个流上，从中连续读取内容。也就是读完一个进程的进程名后接着读取它的进程号。</p> 
<p style="margin-left:0;text-align:justify;">            String nextLine;</p> 
<h3 style="margin-left:0;text-align:justify;"><strong><a name="_Toc169410816"></a><a name="_Toc178566098">3.6 </a>远程端口扫描</strong></h3> 
<p style="margin-left:0;text-align:justify;">主要扫描远端主机给定端口范围的开放情况，可指定ip及端口扫描范围，扫描线程数，线程范围现规定范围为0-200，因为线程数过大会给当前主机造成过大压力，可能造成主机死机。</p> 
<h4 style="margin-left:0;text-align:justify;"><strong><a name="_Toc169410817"></a><a name="_Toc178566099">3.6.1 Socket</a>类编程机制</strong></h4> 
<p style="margin-left:0;text-align:justify;">随着计算机技术的发展，现在的操作系统多同时运行多个进程（或线程） 。Socket机制成功的解决了两台主机不同进程之间的通信问题。下图是一个典型的面向连接的 Socket 通信机制示意图。它采用客户服务器模式,由服务器方先建立自己的半相关（建立Socket并将Socket联编到某个端口上），并进入监听状态，同时监听是否有与自己端口相对应的连接请求。连接是客户方发送的这里户方在建立自己的半相关后，向服务器发起连接（调用方法accept()）；这样就建立起来一个完整的连接。</p> 
<p style="margin-left:0;text-align:justify;">该程序则是机制中的客户端，只要知道目的主机的地址，就可以进行端口扫描。（不考虑防火墙）。下面介绍两个主机之间通信是如何建立的。</p> 
<p style="margin-left:0;text-align:justify;">服务器端：主进程  1）创建一个Socket，将其绑定到服务器本地址和一个已知协议端口上。让该端口保持非连接状态。 2）将该端口设置为被动式。 3）主进程守候在这个指定的端口上 ，等待收接客户机的连接请求。 4）当有来自客户端的连接请求时，向客户机发送应答并创建一个新的从进程来处理响应。返回 3）， 5）退出。从进程 : 1）由于接收到连接请求而被创建，即用于连接的Socket。 2）根据用户的连接请求 ，决定利用该连接与客户机进行交互。 3）交互结束 ，关闭连接并退出。</p> 
<p style="margin-left:0;text-align:justify;">客户机端 :</p> 
<p style="margin-left:0;text-align:justify;">1）创建一个用于远程通信的Socket。代码如下所示：</p> 
<p style="margin-left:0;text-align:justify;">Socket theTCPsocket;</p> 
<p style="margin-left:0;text-align:justify;"> 2）发起一个到服务器进程的主动连接.</p> 
<p style="margin-left:0;text-align:justify;">theTCPsocket=new Socket(hostAddress,i)；hostAddress输入目标主机的IP或域名。</p> 
<p style="margin-left:0;text-align:justify;"> 3）利用该连接与服务器进程进行通信。</p> 
<p style="margin-left:0;text-align:justify;"> 4）通信结束，关闭连接并退出。本应用程序就是这个通信机制中的客户端。</p> 
<p style="margin-left:0;text-align:justify;">theTCPsocket.close();机制如图6所示：</p> 
<table><tbody><tr><td> 
    <div> 
     <p>客户机</p> 
    </div> </td></tr></tbody></table> 
<table><tbody><tr><td> 
    <div> 
     <p>服务器</p> 
    </div> </td></tr></tbody></table> 
<table><tbody><tr><td> 
    <div> 
     <p>在指定端口生成ServerSocket</p> 
    </div> </td></tr></tbody></table> 
<table><tbody><tr><td> 
    <div> 
     <p>根据服务器所在主机的IP地址和port生成一个socket</p> 
    </div> </td></tr></tbody></table> 
<p style="margin-left:25.5pt;">传</p> 
<table><tbody><tr><td> 
    <div> 
     <p>倾听客户端发来的请求</p> 
    </div> </td></tr></tbody></table> 
<table><tbody><tr><td> 
    <div> 
     <p style="margin-left:10.5pt;">连接请求</p> 
    </div> </td></tr></tbody></table> 
<table><tbody><tr><td> 
    <div> 
     <p style="margin-left:10.5pt;">服务请求</p> 
    </div> </td></tr></tbody></table> 
<table border="1"><tbody><tr><td style="background-color:#ffffff;border-color:#000000;vertical-align:top;"> 
    <table><tbody><tr><td> 
        <div> 
         <p style="margin-left:0;text-align:justify;">有socket生成输入输出流</p> 
        </div> </td></tr></tbody></table></td></tr></tbody></table> 
<table border="1"><tbody><tr><td style="background-color:#ffffff;border-color:#000000;vertical-align:top;"> 
    <table><tbody><tr><td> 
        <div> 
         <p style="margin-left:0;text-align:justify;">由得到的socket实例生成输入输出流</p> 
        </div> </td></tr></tbody></table></td></tr></tbody></table> 
<p>                                       </p> 
<table><tbody><tr><td> 
    <div> 
     <p>向服务器发送数据</p> 
    </div> </td></tr></tbody></table> 
<table><tbody><tr><td> 
    <div> 
     <p>向客户发送数据</p> 
    </div> </td></tr></tbody></table> 
<table><tbody><tr><td> 
    <div> 
     <p>关闭socket</p> 
    </div> </td></tr></tbody></table> 
<table><tbody><tr><td> 
    <div> 
     <p>从服务器接受请求</p> 
    </div> </td></tr></tbody></table> 
<table><tbody><tr><td> 
    <div> 
     <p>关闭socket</p> 
    </div> </td></tr></tbody></table> 
<table><tbody><tr><td> 
    <div> 
     <p style="margin-left:10.5pt;">服务应答</p> 
    </div> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:center;">图6　Socket通信机原理</p> 
<p style="margin-left:0;text-align:justify;">Socket和ServerSocket类库位于java.net包中。ServerSocket用于服务器端，Socket是建立网络连接时使用的，本应用程序就是一个客户端。</p> 
<h4 style="margin-left:0;text-align:justify;"><strong><a name="_Toc178566100">3.6.2 </a>功能详解</strong></h4> 
<p style="margin-left:0;text-align:justify;">连接成功时，应用程序两端都会产生一个Socket实例，操作这个实例，完成所需的会话。对于一个网络连接来说，套接字是平等的，并没有差别，不因为在服务器端或在客户端而产生不同级别。不管是Socket还是ServerSocket它们的工作都是通过 SocketImpl类及其子类完成的。</p> 
<p style="margin-left:0;text-align:justify;">本地主机端口扫描功能是查看本机的哪些端口属于打开状态，哪些是关闭状态。在界面的ip或域名处输入：localhost，端口范围的正确输入是0-65535的整数，而且输入的最小端口号小于输入的最大端口号。线程数则输入1-200的整数。该程序可以正常运行：</p> 
<p style="margin-left:0;text-align:justify;">本地端口扫描界面如图7所示：</p> 
<p style="margin-left:0;text-align:center;"><span style="color:#000000;">图7 本机端口扫描</span></p> 
<p style="margin-left:0;text-align:justify;">指定主机（可达），输入正确的端口范围，正确的线程数，远程端口扫描界面如图8所示：</p> 
<p style="margin-left:0;text-align:center;"><span style="color:#000000;">图8 远程端口扫描</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">该程序主要由TCPThread.java实现。</span></p> 
<ol><li><span style="color:#000000;">包含TCPThread的public类，主要功能为启动端口扫描线程。根究用户输入的端口范围，线程数等信息进行扫描，并判断端口类型。</span></li><li><span style="color:#000000;">类CancelAction：实现“退出”按钮的事件侦听。</span></li><li><span style="color:#000000;">类SubmitAction：实现“开始扫描”按钮的事件侦听。包括判断各个文本框中数据的有效性，并启动相应的线程数开始扫描。</span></li><li><span style="color:#000000;">类OKAction：错误提示框中“确定”按钮的事件侦听。如图9所示：</span></li></ol> 
<table><tbody><tr><td> 
    <div> 
     <p>该类从Thread继承</p> 
    </div> </td></tr></tbody></table> 
<table border="1"><tbody><tr><td style="background-color:#ffffff;border-color:#000000;vertical-align:top;"> 
    <table><tbody><tr><td> 
        <div> 
         <p style="margin-left:0;text-align:center;">TCPThread</p> 
         <p style="margin-left:0;text-align:justify;">.java</p> 
        </div> </td></tr></tbody></table></td></tr></tbody></table> 
<table><tbody><tr><td> 
    <div> 
     <p>TCPThread类</p> 
     <p></p> 
    </div> </td></tr></tbody></table> 
<table><tbody><tr><td> 
    <div> 
     <p style="text-align:center;">SubmitAction类</p> 
     <p></p> 
    </div> </td></tr></tbody></table> 
<table><tbody><tr><td> 
    <div> 
     <p style="text-align:center;">其中这三个类完成辅助功能，包含于TCPThread</p> 
     <p>.java</p> 
    </div> </td></tr></tbody></table> 
<table><tbody><tr><td> 
    <div> 
     <p style="text-align:center;">其中这三个类完成辅助功能，包含于TCPThread</p> 
     <p>.java</p> 
     <p></p> 
    </div> </td></tr></tbody></table> 
<table><tbody><tr><td> 
    <div> 
     <p>OKAction类</p> 
     <p></p> 
    </div> </td></tr></tbody></table> 
<table><tbody><tr><td> 
    <div> 
     <p>CancleAction类</p> 
     <p></p> 
    </div> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:center;"><span style="color:#000000;">图9 类的结构</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">网络编程的基本模型就是客户机到服务器模型。简单的说就是两个进程之间相互通讯，然后其中一个必须提供一个固定的位置（IP或域名），而另一个则只需要知道这个固定的位置，并去建立两者之间的联系，然后完成数据的通讯就可以了。这里提供固定位置的通常称为服务器（被扫描的主机），而建立联系的就是客户端（主机）。客户机必须知道有关服务器的IP地址。对于着一点</span><span style="color:#000000;">Java</span><span style="color:#000000;">也提供了一个相关的类</span><span style="color:#000000;">InetAddress</span> <span style="color:#000000;">该对象的实例必须通过它的静态方法来提供。它的静态方法主要提供了得到本机IP 和通过名字或IP直接得到</span><span style="color:#000000;">InetAddress</span><span style="color:#000000;">的方法。</span></p> 
<p style="margin-left:0;text-align:justify;">以上两种方式扫描方式所包含的变量为：最小端口号int MIN_port；最大端口号 int MAX_port；线程数 int threadnum；InetAdress所含主机地址通过静态方法getByName（）获取。</p> 
<p style="margin-left:0;text-align:justify;">Internet上的计算机，端口号标示正在计算机上运行的进程（程序）。端口号与IP地址的组合得到一个网络套接字。端口号被规定为一个在0-65535范围内的整数。其中，0-1023被预先定义的服务通信占用（如telnet占用端口号23，http占用80端口）。</p> 
<p style="margin-left:0;text-align:justify;"> public void run() {    //使用实现接口 Runnable 的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用对象的 run 方法        </p> 
<p style="margin-left:0;text-align:justify;">        int i;//整型变量 i；</p> 
<p style="margin-left:0;text-align:justify;">        Socket theTCPsocket;// 此类实现客户端套接字,套接字是两台机器之间的通信端点</p> 
<p style="margin-left:0;text-align:justify;">        for (i = MIN_port+threadnum; i &lt; MAX_port; i += Integer.parseInt(ThreadScan.maxThread.getText()))//将字符串参数作为有符号的十进制整数进行分析。文本内容用 parseInt()就可以将最大线程数准换为对于的int型数据 {<!-- --></p> 
<p style="margin-left:0;text-align:justify;">            ThreadScan.status.setText("扫描状态:正在扫描 "+i+" 端");</p> 
<p style="margin-left:0;text-align:justify;">            try {<!-- --></p> 
<p style="margin-left:0;text-align:justify;">                theTCPsocket=new Socket(hostAddress,i);//参数host是服务器的ip地址，port端口号；</p> 
<p style="margin-left:0;text-align:justify;">                theTCPsocket.close();</p> 
<p style="margin-left:0;text-align:justify;">                ThreadScan.Result.append(" "+i);</p> 
<p style="margin-left:0;text-align:justify;">                switch(i) {<!-- --></p> 
<p style="margin-left:0;text-align:justify;">                    case 21:</p> 
<p style="margin-left:0;text-align:justify;">                        ThreadScan.Result.append("(FTP)");？//当端口号为21则FTP服务在运行；</p> 
<p style="margin-left:0;text-align:justify;">                        break;</p> 
<p style="margin-left:0;text-align:justify;">                    case 23:</p> 
<p style="margin-left:0;text-align:justify;">                        ThreadScan.Result.append("(TELNET)");当端口为23则telnet服务在运行；</p> 
<p style="margin-left:0;text-align:justify;">                        break;</p> 
<p style="margin-left:0;text-align:justify;">                    case 25:</p> 
<p style="margin-left:0;text-align:justify;">                        ThreadScan.Result.append("(SMTP)");当端口为25则SMTP服务在运行</p> 
<p style="margin-left:0;text-align:justify;">                        break;</p> 
<p style="margin-left:0;text-align:justify;">                    case 80:</p> 
<p style="margin-left:0;text-align:justify;">                        ThreadScan.Result.append("(HTTP)");当端口为80则HTTP服务在运行；</p> 
<p style="margin-left:0;text-align:justify;">                        break;</p> 
<p style="margin-left:0;text-align:justify;">                    case 110:</p> 
<p style="margin-left:0;text-align:justify;">                        ThreadScan.Result.append("(POP)");端口为110时，POP服务在运行；</p> 
<p style="margin-left:0;text-align:justify;">                        break;</p> 
<p style="margin-left:0;text-align:justify;">                    case 139:</p> 
<p style="margin-left:0;text-align:justify;">                        ThreadScan.Result.append("(netBIOS)");当端口为139时，netBIOS服务在运行；</p> 
<p style="margin-left:0;text-align:justify;">                        break;  </p> 
<h2 style="margin-left:21.6pt;"><strong><a name="_Toc169253942"></a><a name="_Toc169410818"></a><a name="_Toc178566101">4系统关键点测试</a></strong></h2> 
<p style="margin-left:0;text-align:justify;">对系统的远程端口扫描功能进行健壮性的测试，主要对其容错性能进行一个测试，测试该程序是不是能够在正常情况下运转。因为能力和条件有限，所以测试次数比正规测试强度的要求差很远。这里之所以加入这个测试，主要目的是模仿一个软件生产的正规流程，而健壮性测试在其中是非常必要的。</p> 
<p style="margin-left:0;text-align:justify;">该部分针对端口扫描的各种不同情况进行了四种情况的测试：</p> 
<p style="margin-left:0;text-align:justify;">测试1：当输入正确ip或域名，正确的最小端口号和最大端口（端口号输入是0-65535的整数），正确的线程数（输入为1-200的整数），程序可以正常运行。当在ip或域名输入正确，线程数输入错误，端口号输入错误时系统会发生错误提示。</p> 
<p style="margin-left:0;text-align:justify;">根据本系统的健壮性要求对此进行了8次测试，下面根据测试的列举了2次测试结果。</p> 
<p style="margin-left:0;text-align:justify;">当程序ip或域名处标准输入：localhost，端口范围标准输入：0-1000，线程数标准输入：100.该程序正常运行。</p> 
<p style="margin-left:0;text-align:justify;">当程序ip或域名处标准输入：localhost,端口范围错误输入：1.5-1000，线程数错误输入：100.3</p> 
<p style="margin-left:0;text-align:justify;">出现如图9所示提示框：</p> 
<p style="margin-left:0cm;text-align:center;">                  图10 报错提示框1</p> 
<p style="margin-left:0;text-align:justify;">分析：经8次不同类型及各类型的不同种输入的结果显示本功能点能达到百分百的可靠性。</p> 
<p style="margin-left:0;text-align:justify;">测试2：当输入正确ip或域名，正确的最小端口号和最大端口（端口号输入是0-65535的整数），正确的线程数（输入为1-200的整数），程序可以正常运行.当输入错误的IP地址/域名，正确的最小端口号，最大端口号，正确的线程数时系统会发生错误提示。</p> 
<p style="margin-left:0;text-align:justify;">根据本系统的健壮性要求对此进行了8次测试，下面根据测试的列举了2次测试结果。</p> 
<p style="margin-left:0;text-align:justify;">当程序ip或域名处标准输入：localhost，端口范围标准输入：0-1000，线程数标准输入：100.该程序正常运行。</p> 
<p style="margin-left:0;text-align:justify;">当程序ip或域名处错误输入：258.0.25.3,端口范围标准输入：0-1000，线程数标准输入：100.</p> 
<p style="margin-left:0;text-align:justify;">出现如图10所示提示框：</p> 
<p style="margin-left:0cm;text-align:center;">图11 报错提示框2</p> 
<p style="margin-left:0;text-align:justify;">分析：经8次不同类型及各类型的不同种输入的结果显示本功能点能达到百分百的可靠性。</p> 
<p style="margin-left:0;text-align:justify;">测试3：当输入正确ip或域名，正确的最小端口号和最大端口（端口号输入是0-65535的整数），正确的线程数（输入为1-200的整数），程序可以正常运行。当在ip或域名输入正确，线程数输入正确，端口范围输入错误时系统会发生错误提示。</p> 
<p style="margin-left:0;text-align:justify;">根据本系统的健壮性要求对此进行了8次测试，下面根据测试的列举了3次测试结果。</p> 
<p style="margin-left:0;text-align:justify;">当程序ip或域名处标准输入：www.163.com，端口范围标准输入：0-1000，线程数标准输入：100.该程序正常。</p> 
<p style="margin-left:0;text-align:justify;">当程序ip或域名处标准输入：www.163.com,端口范围标准输入：1000-0，线程数标准输入：100.</p> 
<p style="margin-left:0;text-align:justify;">出现如下图11所示提示框：</p> 
<p style="margin-left:0;text-align:center;"><span style="color:#000000;">图12 报错提示框3</span></p> 
<p style="margin-left:0;text-align:justify;">当程序ip或域名处标准输入：www.163.com,端口范围标准输入：0-65536，线程数标准输入：100.出现如下图12所示提示框：</p> 
<p style="margin-left:0;text-align:center;"><span style="color:#000000;">图13 报错提示框4</span></p> 
<p style="margin-left:0;text-align:justify;">分析：经8次不同类型及各类型的不同种输入的结果显示本功能点能达到百分百的可靠性。</p> 
<p style="margin-left:0;text-align:justify;">测试4：当输入正确ip或域名，正确的最小端口号和最大端口（端口号输入是0-65535的整数），正确的线程数（输入为1-200的整数），程序可以正常运行。当在ip或域名输入正确，端口号范围输入正确，线程数输入错误时系统会发生错误提示。</p> 
<p style="margin-left:0;text-align:justify;">根据本系统的健壮性要求对此进行了8次测试，下面根据测试的列举了2次测试结果。</p> 
<p style="margin-left:0;text-align:justify;">当程序ip或域名处标准输入：localhost，端口范围标准输入：0-1000，线程数标准输入：100.该程序正常运行。</p> 
<p style="margin-left:0;text-align:justify;">当程序ip或域名处标准输入：localhost,端口范围错误输入：0-1000，线程数错误输入：205出现如图13所示提示框：</p> 
<p style="margin-left:0;text-align:center;"><span style="color:#000000;">图14 报错提示框5</span></p> 
<p style="margin-left:0;text-align:justify;">分析：经8次不同类型及各类型的不同种输入的结果显示本功能点能达到百分百的可靠性。</p> 
<h2 style="margin-left:21.6pt;text-align:center;"><strong><a name="_Toc169410820"></a><a name="_Toc178566102">结   论</a></strong></h2> 
<p style="margin-left:0;text-align:justify;"><a name="_Toc169410821">本课题主要利用本地监听与远程端口扫描系统有效反应出计算机的安全状况，辅助用户管理计算机。其中系统配置查看功能和网络配置功能，帮助管理员直观了解主机系统配置和网络设置状况。本地监听实现对主机当前进程运行情况的枚举，反应出当前进程的TCP、UDP连接情况。远程端口扫描可以实现对本机或远程主机开放端口的扫描，找出潜在的漏洞。管理员根据扫描和监听的结果，自主对存在的漏洞进行重新修复，从而提高计算机的安全性。</a></p> 
<p style="margin-left:0;text-align:justify;">软件虽然实现了一些功能但是还是存在很多的问题和缺陷，但是我还是通过完成毕业设计使自己的能力得到很大的提高，并且充分体会到理论与实践之间的重要联系，进一步的了解了Java语言和网络基本知识。经过大学四年的学习生活，毕业设计不仅是对我们所学知识的综合体现，而且是对诸多方面的一种总结，让我们更清楚的认识到了自己的不足之处，希望在以后的生活，工作中不断完善自我，提高自己的水平。</p> 
<h2 style="background-color:transparent;margin-left:21.6pt;text-align:center;"><strong><a name="_Toc178566103">参考文献</a></strong></h2> 
<p style="margin-left:0;text-align:justify;">[1] 孙一林,彭波.Java网络编程实例[M].北京：清华大学出版社,2003.4。</p> 
<p style="margin-left:0;text-align:justify;">[2] 殷兆麟.Java网络编程[M].北京：国防工业出版社,2001.5。</p> 
<p style="margin-left:0;text-align:justify;">[3] 吴逸贤,吴目诚.Java2程序设计[M].南京：科学出版社,2003.8。</p> 
<p style="margin-left:0;text-align:justify;">[4] 刘弈等.基于Socket的Java 语言网络通信机制和程序设计[J].计算机应用工程,1999，（5）78 – 81。</p> 
<p style="margin-left:0;text-align:justify;">[5] Douglas E. Comer,David L. Stevens[美国]．TCP/ IP 网络互连技术[M].北京：清华大学出版社,1998。</p> 
<h2 style="margin-left:0px;text-align:justify;">参考资料</h2> 
<p style="margin-left:0;text-align:justify;"><a href="https://download.csdn.net/download/dwf1354046363/22827860" title="java毕业设计——JAVA本地监听与远程端口扫描(源代码+论文).zip">java毕业设计——JAVA本地监听与远程端口扫描(源代码+论文).zip</a></p> 
<p style="margin-left:0;text-align:justify;"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ae95d050a5341dd5415dddac444fa512/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CentOS服务器重装系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/de02486886b55ab74476dd2eca0a6e45/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WebSocketClient objects are not reuseable</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>