<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【无人机开发】通讯协议MavLink详解 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【无人机开发】通讯协议MavLink详解" />
<meta property="og:description" content="1. MAVLink简介 MAVLink（Micro Air Vehicle Link，微型空中飞行器链路通讯协议）是无人飞行器与地面站（Ground Control Station ，GCS）之间通讯，以及无人飞行器之间通讯最常用的协议。它已经在PX4、APM、PIXHAWK和Parrot AR.Drone飞控平台上进行了大量测试。
2.发明者Lorenz Meier简介 MAVLink的最初开发于2009年，由Lorenz Meier完成。Lorenz Meier的LinkedIn主页是：https://www.linkedin.com/in/meierlorenz，个人主页是：https://www.inf.ethz.ch/personal/lomeier/。 根据官网和个人主页，Lorenz Meie的个人经历如下：  2004年~2008年在德国康斯坦茨大学（Universität Konstanz）就读信息工程专业；  2008 年~2011年在苏黎世联邦理工学院（德语：Eidgenössische Technische Hochschule Zürich，简称 ETH Zürich或ETHZ）就读视觉计算方向研究生；  2011~至今在ETHZ攻读博士后，研究方向是：Research on Drones and mobile phones focused on obstacle mapping, path planning and control.  2011年到现在，Lorenz Meier一直是开源无人机项目Autopilot的建立者和维护者。关于Autopilot，我会另辟章节介绍。 从介绍来看，Lorenz Meier的研究方向包括了无人机避障、基于智能手机或无人机的3D重建、无人机通讯协议等有趣又前言的内容。 这个页面是Lorenz Meier发表的几篇文章：https://www.researchgate.net/profile/Lorenz_Meier3
3. MAVLink相关资料 维基百科：https://en.wikipedia.org/wiki/MAVLink MavLink官方网站：http://qgroundcontrol.org/mavlink/start Python写的用于生成C、Java等语言的MavLink生成器软件：https://github.com/mavlink/mavlink
4.协议构成 下面内容引自官网。 • The checksum is the same as used in ITU X.25 and SAE AS-4 standards (CRC-16-CCITT), documented in SAE AS5669A." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/3baf9a2019b7e1cfb5ad2cb2ddc8fd69/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-04T10:57:51+08:00" />
<meta property="article:modified_time" content="2023-04-04T10:57:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【无人机开发】通讯协议MavLink详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="1-mavlink简介">1. MAVLink简介</h3> 
<p>MAVLink（Micro Air Vehicle Link，微型空中飞行器链路通讯协议）是无人飞行器与地面站（Ground Control Station ，GCS）之间通讯，以及无人飞行器之间通讯最常用的协议。它已经在PX4、APM、PIXHAWK和Parrot AR.Drone飞控平台上进行了大量测试。</p> 
<h3 id="2发明者lorenz-meier简介"><a name="t1"></a>2.发明者Lorenz Meier简介</h3> 
<p>MAVLink的最初开发于2009年，由Lorenz Meier完成。Lorenz Meier的LinkedIn主页是：<a href="https://www.linkedin.com/in/meierlorenz" rel="nofollow" title="https://www.linkedin.com/in/meierlorenz">https://www.linkedin.com/in/meierlorenz</a>，个人主页是：<a href="https://www.inf.ethz.ch/personal/lomeier/" rel="nofollow" title="https://www.inf.ethz.ch/personal/lomeier/">https://www.inf.ethz.ch/personal/lomeier/</a>。 <br> 根据官网和个人主页，Lorenz Meie的个人经历如下： <br>  2004年~2008年在德国康斯坦茨大学（Universität Konstanz）就读信息工程专业； <br>  2008 年~2011年在苏黎世联邦理工学院（德语：Eidgenössische Technische Hochschule Zürich，简称 ETH Zürich或ETHZ）就读视觉计算方向研究生； <br>  2011~至今在ETHZ攻读博士后，研究方向是：Research on Drones and mobile phones focused on obstacle mapping, path planning and control. <br>  2011年到现在，Lorenz Meier一直是开源无人机项目Autopilot的建立者和维护者。关于Autopilot，我会另辟章节介绍。 <br> 从介绍来看，Lorenz Meier的研究方向包括了无人机避障、基于智能手机或无人机的3D重建、无人机通讯协议等有趣又前言的内容。 <br> 这个页面是Lorenz Meier发表的几篇文章：<a href="https://www.researchgate.net/profile/Lorenz_Meier3" rel="nofollow" title="https://www.researchgate.net/profile/Lorenz_Meier3">https://www.researchgate.net/profile/Lorenz_Meier3</a></p> 
<h3 id="3-mavlink相关资料"><a name="t2"></a>3. MAVLink相关资料</h3> 
<p>维基百科：<a href="https://en.wikipedia.org/wiki/MAVLink" rel="nofollow" title="https://en.wikipedia.org/wiki/MAVLink">https://en.wikipedia.org/wiki/MAVLink</a> <br> MavLink官方网站：<a href="http://qgroundcontrol.org/mavlink/start" rel="nofollow" title="http://qgroundcontrol.org/mavlink/start">http://qgroundcontrol.org/mavlink/start</a> <br> Python写的用于生成C、Java等语言的MavLink生成器软件：<a href="https://github.com/mavlink/mavlink" title="https://github.com/mavlink/mavlink">https://github.com/mavlink/mavlink</a></p> 
<h3 id="4协议构成"><a name="t3"></a>4.协议构成</h3> 
<p>下面内容引自官网。 <br><img alt="这里写图片描述" class="has" src="https://images2.imgbox.com/71/e2/KgPHpWVr_o.png"> <br> • The checksum is the same as used in ITU X.25 and SAE AS-4 standards (CRC-16-CCITT), documented in SAE AS5669A. Please see the MAVLink source code for a documented C-implementation of it. LINK TO CHECKSUM <br> • The minimum packet length is 8 bytes for acknowledgement packets without payload <br> • The maximum packet length is 263 bytes for full payload</p> 
<p>MavLink的长度是固定的，即 17byte= 6 bytes header + 9 bytes payload + 2 bytes checksum。</p> 
<h3 id="5封包过程"><a name="t4"></a>5.封包过程</h3> 
<p>由用户生成的部分包括PlayLoad本身、消息包的STX、COMP、MSG，其他部分自动生成。下图来自于博客<a href="http://blog.csdn.net/u013983741/article/details/48053235" title="MAVLink协议通信分析——（二）消息结构_Fergus-CSDN博客">MAVLink协议通信分析——（二）消息结构_Fergus-CSDN博客</a>，侵删。 <br><img alt="这里写图片描述" class="has" src="https://images2.imgbox.com/47/d3/Evvq9Q3n_o.png"></p> 
<h3 id="63dr-service实现mavlink协议"><a name="t5"></a>6.3DR Service实现MavLink协议</h3> 
<p>3DR Service是Autopilot提供的Android端的app服务，用于做SDK，提供与无人机通讯，以AIDL的方式为上层的App提供服务。基于3DRService，开发者可以不用处理复杂的MavLink通讯，只根据AIDL接口调用服务即可。 <br> 这里下载了3DRService用于分析，地址为：<a href="https://github.com/ne0fhyk/3DRServices" title="https://github.com/ne0fhyk/3DRServices">https://github.com/ne0fhyk/3DRServices</a>。3DRService将MavLink的协议部分作为单独的包，即项目中的dependencyLibs文件夹。</p> 
<h4 id="61-uml图"><a name="t6"></a>6.1. UML图</h4> 
<p>绘制dependencyLibs的UML图。该包主要提供了MavLink的所有类型的封包类和解析类。 <br><img alt="这里写图片描述" class="has" src="https://images2.imgbox.com/1f/d7/Zax2WcPs_o.png"></p> 
<p>例如，对于MAVLinkPacket类，其核心部分为封包过程。</p> 
<ol><li> <p><code>/**</code></p> </li><li> <p><code>* Encode this packet for transmission.</code></p> </li><li> <p><code>*</code></p> </li><li> <p><code>* @return Array with bytes to be transmitted</code></p> </li><li> <p><code>*/</code></p> </li><li> <p><code>public byte[] encodePacket() {<!-- --></code></p> </li><li> <p><code>byte[] buffer = new byte[6 + len + 2];</code></p> </li><li><li> <p><code>int i = 0;</code></p> </li><li> <p><code>buffer[i++] = (byte) MAVLINK_STX;</code></p> </li><li> <p><code>buffer[i++] = (byte) len;</code></p> </li><li> <p><code>buffer[i++] = (byte) seq;</code></p> </li><li> <p><code>buffer[i++] = (byte) sysid;</code></p> </li><li> <p><code>buffer[i++] = (byte) compid;</code></p> </li><li> <p><code>buffer[i++] = (byte) msgid;</code></p> </li><li><li> <p><code>final int payloadSize = payload.size();</code></p> </li><li> <p><code>for (int j = 0; j &lt; payloadSize; j++) {<!-- --></code></p> </li><li> <p><code>buffer[i++] = payload.payload.get(j);</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>generateCRC();</code></p> </li><li> <p><code>buffer[i++] = (byte) (crc.getLSB());</code></p> </li><li> <p><code>buffer[i++] = (byte) (crc.getMSB());</code></p> </li><li> <p><code>return buffer;</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p>解包的核心部分在Parser类中：</p> 
<ol><li> <p><code>/**</code></p> </li><li> <p><code>* This is a convenience function which handles the complete MAVLink</code></p> </li><li> <p><code>* parsing. the function will parse one byte at a time and return the</code></p> </li><li> <p><code>* complete packet once it could be successfully decoded. Checksum and other</code></p> </li><li> <p><code>* failures will be silently ignored.</code></p> </li><li> <p><code>* </code></p> </li><li> <p><code>* @param c</code></p> </li><li> <p><code>* The char to parse</code></p> </li><li> <p><code>*/</code></p> </li><li> <p><code>public MAVLinkPacket mavlink_parse_char(int c) {<!-- --></code></p> </li><li> <p><code>msg_received = false;</code></p> </li><li><li> <p><code>switch (state) {<!-- --></code></p> </li><li> <p><code>case MAVLINK_PARSE_STATE_UNINIT:</code></p> </li><li> <p><code>case MAVLINK_PARSE_STATE_IDLE:</code></p> </li><li><li> <p><code>if (c == MAVLinkPacket.MAVLINK_STX) {<!-- --></code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_STX;</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>break;</code></p> </li><li><li> <p><code>case MAVLINK_PARSE_STATE_GOT_STX:</code></p> </li><li> <p><code>if (msg_received) {<!-- --></code></p> </li><li> <p><code>msg_received = false;</code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_IDLE;</code></p> </li><li> <p><code>} else {<!-- --></code></p> </li><li> <p><code>m = new MAVLinkPacket(c);</code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_LENGTH;</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>break;</code></p> </li><li><li> <p><code>case MAVLINK_PARSE_STATE_GOT_LENGTH:</code></p> </li><li> <p><code>m.seq = c;</code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_SEQ;</code></p> </li><li> <p><code>break;</code></p> </li><li><li> <p><code>case MAVLINK_PARSE_STATE_GOT_SEQ:</code></p> </li><li> <p><code>m.sysid = c;</code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_SYSID;</code></p> </li><li> <p><code>break;</code></p> </li><li><li> <p><code>case MAVLINK_PARSE_STATE_GOT_SYSID:</code></p> </li><li> <p><code>m.compid = c;</code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_COMPID;</code></p> </li><li> <p><code>break;</code></p> </li><li><li> <p><code>case MAVLINK_PARSE_STATE_GOT_COMPID:</code></p> </li><li> <p><code>m.msgid = c;</code></p> </li><li> <p><code>if (m.len == 0) {<!-- --></code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_PAYLOAD;</code></p> </li><li> <p><code>} else {<!-- --></code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID;</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>break;</code></p> </li><li><li> <p><code>case MAVLINK_PARSE_STATE_GOT_MSGID:</code></p> </li><li> <p><code>m.payload.add((byte) c);</code></p> </li><li> <p><code>if (m.payloadIsFilled()) {<!-- --></code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_PAYLOAD;</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>break;</code></p> </li><li><li> <p><code>case MAVLINK_PARSE_STATE_GOT_PAYLOAD:</code></p> </li><li> <p><code>m.generateCRC();</code></p> </li><li> <p><code>// Check first checksum byte</code></p> </li><li> <p><code>if (c != m.crc.getLSB()) {<!-- --></code></p> </li><li> <p><code>msg_received = false;</code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_IDLE;</code></p> </li><li> <p><code>if (c == MAVLinkPacket.MAVLINK_STX) {<!-- --></code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_STX;</code></p> </li><li> <p><code>m.crc.start_checksum();</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>stats.crcError();</code></p> </li><li> <p><code>} else {<!-- --></code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_CRC1;</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>break;</code></p> </li><li><li> <p><code>case MAVLINK_PARSE_STATE_GOT_CRC1:</code></p> </li><li> <p><code>// Check second checksum byte</code></p> </li><li> <p><code>if (c != m.crc.getMSB()) {<!-- --></code></p> </li><li> <p><code>msg_received = false;</code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_IDLE;</code></p> </li><li> <p><code>if (c == MAVLinkPacket.MAVLINK_STX) {<!-- --></code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_STX;</code></p> </li><li> <p><code>m.crc.start_checksum();</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>stats.crcError();</code></p> </li><li> <p><code>} else { // Successfully received the message</code></p> </li><li> <p><code>stats.newPacket(m);</code></p> </li><li> <p><code>msg_received = true;</code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_IDLE;</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>break;</code></p> </li><li><li> <p><code>}</code></p> </li><li> <p><code>if (msg_received) {<!-- --></code></p> </li><li> <p><code>return m;</code></p> </li><li> <p><code>} else {<!-- --></code></p> </li><li> <p><code>return null;</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p>这个类的使用是逐个直接解析，解析完毕后返回完整的包，例如，对字节数组packet，解析过程如下：</p> 
<pre><code class="language-html"> </code></pre> 
<ol><li> <p><code>for(int i = 0; i &lt; packet.length - 1; i++){<!-- --></code></p> </li><li> <p><code>parser.mavlink_parse_char(packet[i] &amp; 0xFF);//每次解析1位</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>MAVLinkPacket m = parser.mavlink_parse_char(packet[packet.length - 1] &amp; 0xFF);//最后1位即可返回</code></p> </li></ol> 
<h4 id="62-mavlink包测试"><a name="t7"></a>6.2 MavLink包测试</h4> 
<p>dependencyLibs提供了测试实例。以msg_altitude为例，判断生成的包和解析的包是否相同，即可判断该类是否正确。</p> 
<ol><li> <p><code>/**</code></p> </li><li> <p><code>* The current system altitude.</code></p> </li><li> <p><code>*/</code></p> </li><li> <p><code>public class msg_altitude_test{<!-- --></code></p> </li><li><li> <p><code>public static final int MAVLINK_MSG_ID_ALTITUDE = 141;</code></p> </li><li> <p><code>public static final int MAVLINK_MSG_LENGTH = 24;</code></p> </li><li> <p><code>private static final long serialVersionUID = MAVLINK_MSG_ID_ALTITUDE;</code></p> </li><li><li> <p><code>private Parser parser = new Parser();//1位解析类</code></p> </li><li><li> <p><code>public CRC generateCRC(byte[] packet){<!-- --></code></p> </li><li> <p><code>CRC crc = new CRC();</code></p> </li><li> <p><code>for (int i = 1; i &lt; packet.length - 2; i++) {<!-- --></code></p> </li><li> <p><code>crc.update_checksum(packet[i] &amp; 0xFF);</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>crc.finish_checksum(MAVLINK_MSG_ID_ALTITUDE);</code></p> </li><li> <p><code>return crc;</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public byte[] generateTestPacket(){<!-- --></code></p> </li><li> <p><code>ByteBuffer payload = ByteBuffer.allocate(6 + MAVLINK_MSG_LENGTH + 2);</code></p> </li><li> <p><code>payload.put((byte)MAVLinkPacket.MAVLINK_STX); //stx</code></p> </li><li> <p><code>payload.put((byte)MAVLINK_MSG_LENGTH); //len</code></p> </li><li> <p><code>payload.put((byte)0); //seq</code></p> </li><li> <p><code>payload.put((byte)255); //sysid</code></p> </li><li> <p><code>payload.put((byte)190); //comp id</code></p> </li><li> <p><code>payload.put((byte)MAVLINK_MSG_ID_ALTITUDE); //msg id</code></p> </li><li> <p><code>payload.putFloat((float)17.0); //altitude_monotonic</code></p> </li><li> <p><code>payload.putFloat((float)45.0); //altitude_amsl</code></p> </li><li> <p><code>payload.putFloat((float)73.0); //altitude_local</code></p> </li><li> <p><code>payload.putFloat((float)101.0); //altitude_relative</code></p> </li><li> <p><code>payload.putFloat((float)129.0); //altitude_terrain</code></p> </li><li> <p><code>payload.putFloat((float)157.0); //bottom_clearance</code></p> </li><li><li> <p><code>CRC crc = generateCRC(payload.array());</code></p> </li><li> <p><code>payload.put((byte)crc.getLSB());</code></p> </li><li> <p><code>payload.put((byte)crc.getMSB());</code></p> </li><li> <p><code>return payload.array();</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>@Test</code></p> </li><li> <p><code>public void test(){<!-- --></code></p> </li><li> <p><code>byte[] packet = generateTestPacket();</code></p> </li><li> <p><code>for(int i = 0; i &lt; packet.length - 1; i++){<!-- --></code></p> </li><li> <p><code>parser.mavlink_parse_char(packet[i] &amp; 0xFF);//每次解析1位</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>MAVLinkPacket m = parser.mavlink_parse_char(packet[packet.length - 1] &amp; 0xFF);//最后1位即可返回</code></p> </li><li> <p><code>byte[] processedPacket = m.encodePacket();//解析</code></p> </li><li> <p><code>assertArrayEquals("msg_altitude", processedPacket, packet);</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<h3 id="参考"><a name="t8"></a>参考</h3> 
<p>[1]<a href="http://mrsxm.mfzgi5lqnfwg65bomnxw2.erenta.ru/wp-content/uploads/sites/6/2015/05/MAVLINK_FOR_DUMMIESPart1_v.1.1.pdf" rel="nofollow" title="http://mrsxm.mfzgi5lqnfwg65bomnxw2.erenta.ru/wp-content/uploads/sites/6/2015/05/MAVLINK_FOR_DUMMIESPart1_v.1.1.pdf">http://mrsxm.mfzgi5lqnfwg65bomnxw2.erenta.ru/wp-content/uploads/sites/6/2015/05/MAVLINK_FOR_DUMMIESPart1_v.1.1.pdf</a> <br> [2]<a href="http://blog.csdn.net/u013983741/article/details/48053235" title="MAVLink协议通信分析——（二）消息结构_Fergus-CSDN博客">MAVLink协议通信分析——（二）消息结构_Fergus-CSDN博客</a></p> 
<p></p> 
<h2>Android地面站-MavLink解析部分源码</h2> 
<p>MavLink是轻量级的通讯协议,主要应用于终端与小型无人载具间的通讯。由于它的通用性,MavLink可以被翻译成各种语言的代码应用于各种不同的环境。具体如何通过工具来生成对应的MavLink代码请访问:</p> 
<p>http://www.qgroundcontrol.org/mavlink/create_new_mavlink_message</p> 
<p>MavLink协议所定义的消息,大致分为两类,一类是通用消息,另外一种是自定义消息。通用消息和自定义消息的数据结构相同,差异只体现在数据本身。我取MavLink中最常使用的心跳消息作为例子:</p> 
<p></p> 
<pre><code class="language-html"> </code></pre> 
<ol><li> <p><code>&lt;message id="0" name="HEARTBEAT"&gt;</code></p> </li><li> <p><code>&lt;description&gt;The heartbeat message shows that a system is present and responding. The type of the MAV and Autopilot hardware allow the receiving system to treat further messages from this system appropriate (e.g. by laying out the user interface based on the autopilot).&lt;/description&gt;</code></p> </li><li> <p><code>&lt;field type="uint8_t" name="type"&gt;Type of the MAV (quadrotor, helicopter, etc., up to 15 types, defined in MAV_TYPE ENUM)&lt;/field&gt;</code></p> </li><li> <p><code>&lt;field type="uint8_t" name="autopilot"&gt;Autopilot type / class. defined in MAV_CLASS ENUM&lt;/field&gt;</code></p> </li><li> <p><code>&lt;field type="uint8_t" name="base_mode"&gt;System mode bitfield, see MAV_MODE_FLAGS ENUM in mavlink/include/mavlink_types.h&lt;/field&gt;</code></p> </li><li> <p><code>&lt;field type="uint32_t" name="custom_mode"&gt;Navigation mode bitfield, see MAV_AUTOPILOT_CUSTOM_MODE ENUM for some examples. This field is autopilot-specific.&lt;/field&gt;</code></p> </li><li> <p><code>&lt;field type="uint8_t" name="system_status"&gt;System status flag, see MAV_STATUS ENUM&lt;/field&gt;</code></p> </li><li> <p><code>&lt;field type="uint8_t_mavlink_version" name="mavlink_version"&gt;MAVLink version&lt;/field&gt;</code></p> </li><li> <p><code>&lt;/message&gt;</code></p> </li></ol> 
<p><br> 这里的心跳和push中的心跳是一个意思。由于网络环境的不确定性,加入心跳来保证长连接的可靠性。MavLink的消息定义以通用的XML格式为基准,并且根节点是&lt;message&gt;节点。消息ID从0~255,同时为了区分自定义消息。name属性定义了此消息的名称,description节点记录了此消息的用途。field节点用于记录消息中的域。uint8_t中的数字代表此域占用多少个bit。即uint8_t占用8个bit一个字节,而uint32_t占用32个bit,4个字节。各个域分别所代表的含义是:</p> 
<p>1. <strong>type:</strong> 代表小型无人交通工具的类型,可能是直升机,汽车,多旋翼等等</p> 
<p>2.<strong>autopilot: </strong>代表此操作系统平台,平台的类型由MAV_TYPE类:</p> 
<p></p> 
<pre><code class="language-html"> </code></pre> 
<ol><li> <p><code>public class MAV_TYPE {<!-- --></code></p> </li><li> <p><code>public static final int MAV_TYPE_GENERIC = 0; /* Generic micro air vehicle. | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_FIXED_WING = 1; /* Fixed wing aircraft. | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_QUADROTOR = 2; /* Quadrotor | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_COAXIAL = 3; /* Coaxial helicopter | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_HELICOPTER = 4; /* Normal helicopter with tail rotor. | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_ANTENNA_TRACKER = 5; /* Ground installation | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_GCS = 6; /* Operator control unit / ground control station | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_AIRSHIP = 7; /* Airship, controlled | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_FREE_BALLOON = 8; /* Free balloon, uncontrolled | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_ROCKET = 9; /* Rocket | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_GROUND_ROVER = 10; /* Ground rover | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_SURFACE_BOAT = 11; /* Surface vessel, boat, ship | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_SUBMARINE = 12; /* Submarine | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_HEXAROTOR = 13; /* Hexarotor | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_OCTOROTOR = 14; /* Octorotor | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_TRICOPTER = 15; /* Octorotor | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_FLAPPING_WING = 16; /* Flapping wing | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_KITE = 17; /* Flapping wing | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_ONBOARD_CONTROLLER = 18; /* Onboard companion controller | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_VTOL_DUOROTOR = 19; /* Two-rotor VTOL using control surfaces in vertical operation in addition. Tailsitter. | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_VTOL_QUADROTOR = 20; /* Quad-rotor VTOL using a V-shaped quad config in vertical operation. Tailsitter. | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_VTOL_TILTROTOR = 21; /* Tiltrotor VTOL | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_VTOL_RESERVED2 = 22; /* VTOL reserved 2 | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_VTOL_RESERVED3 = 23; /* VTOL reserved 3 | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_VTOL_RESERVED4 = 24; /* VTOL reserved 4 | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_VTOL_RESERVED5 = 25; /* VTOL reserved 5 | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_GIMBAL = 26; /* Onboard gimbal | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_ADSB = 27; /* Onboard ADSB peripheral | */</code></p> </li><li> <p><code>public static final int MAV_TYPE_ENUM_END = 28; /* | */</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p><br>  </p> 
<p>3.<strong>base_mode:</strong>记录小型交通工具的基本模式</p> 
<p>4.<strong>custom_mode:</strong>记录小型交工具的特征模式</p> 
<p>5.<strong>mavlink_version:</strong>mavlink协议的版本号</p> 
<p>大家可能好奇为什么有了个基本模式还有有个特征模式,原因是因为MavLink是要兼顾多种类型的小型交通工具的协议,这样的话,不能保证所有的基本模式覆盖到所有的交通器。</p> 
<p>接下来,我们通过网站上的mavlink-generator 去生成一套java代码,用在我们的android程序中。</p> 
<p>生成的代码移植性很好,我们可以无缝的直接copy到我们的android工程中。我们来看下生成的代码的分包:</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/8b/17/Ce2bsptO_o.jpg"></p> 
<p><strong>common包: </strong>放一些常用的MavLink消息和CRC校验工具</p> 
<p><strong>ardupilotmega包:</strong>存放针对mega板子特有的消息</p> 
<p><strong>Messages包:</strong>提供消息基本类和一些缓存处理类</p> 
<p><strong>enums包:</strong>存放一些常量</p> 
<p><strong>MAVLinkPacket类:</strong>用来记录原始报文</p> 
<p><strong>Parser类:</strong>用于解析信道中传递过来的数据,生成MAVLinkPacket格式的报文。</p> 
<p></p> 
<p>由于本篇的主题是MavLink消息在Android地面站的解析,因此我们不过分的关注于信道和业务本身。我们看上面的分包我们会发现,其实对于解析来说,最重要的就是Parser类。在我们开始解析前,通过一张图再回忆一下心跳消息的数据结构,因为我们将以它为样本作为例子:</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/4c/ed/gEMSuWWE_o.jpg"></p> 
<p>我们收到的心跳完整报文是一个byte数组,因此我们需要对它进行解析,解析出我们自己的对象模型,就需要调用mavlink_parse_char(int c)方法。这就有个问题,我们明明读取到的是byte数组,但是方法中要我们传递一个int。这个原因我们不妨来看一下Parser这个类:</p> 
<p></p> 
<pre><code class="language-html"> </code></pre> 
<ol><li> <p><code>public class Parser {<!-- --></code></p> </li><li><li> <p><code>/**</code></p> </li><li> <p><code>* States from the parsing state machine</code></p> </li><li> <p><code>*/</code></p> </li><li> <p><code>enum MAV_states {<!-- --></code></p> </li><li> <p><code>MAVLINK_PARSE_STATE_UNINIT, MAVLINK_PARSE_STATE_IDLE, MAVLINK_PARSE_STATE_GOT_STX, MAVLINK_PARSE_STATE_GOT_LENGTH, MAVLINK_PARSE_STATE_GOT_SEQ, MAVLINK_PARSE_STATE_GOT_SYSID, MAVLINK_PARSE_STATE_GOT_COMPID, MAVLINK_PARSE_STATE_GOT_MSGID, MAVLINK_PARSE_STATE_GOT_CRC1, MAVLINK_PARSE_STATE_GOT_PAYLOAD</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>MAV_states state = MAV_states.MAVLINK_PARSE_STATE_UNINIT;</code></p> </li><li><li> <p><code>private boolean msg_received;</code></p> </li><li><li> <p><code>public MAVLinkStats stats = new MAVLinkStats();</code></p> </li><li> <p><code>private MAVLinkPacket m;</code></p> </li><li><li> <p><code>/**</code></p> </li><li> <p><code>* This is a convenience function which handles the complete MAVLink</code></p> </li><li> <p><code>* parsing. the function will parse one byte at a time and return the</code></p> </li><li> <p><code>* complete packet once it could be successfully decoded. Checksum and other</code></p> </li><li> <p><code>* failures will be silently ignored.</code></p> </li><li> <p><code>* </code></p> </li><li> <p><code>* @param c</code></p> </li><li> <p><code>* The char to parse</code></p> </li><li> <p><code>*/</code></p> </li><li> <p><code>public MAVLinkPacket mavlink_parse_char(int c) {<!-- --></code></p> </li><li> <p><code>msg_received = false;</code></p> </li><li><li> <p><code>switch (state) {<!-- --></code></p> </li><li> <p><code>case MAVLINK_PARSE_STATE_UNINIT:</code></p> </li><li> <p><code>case MAVLINK_PARSE_STATE_IDLE:</code></p> </li><li><li> <p><code>if (c == MAVLinkPacket.MAVLINK_STX) {<!-- --></code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_STX;</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>break;</code></p> </li><li><li> <p><code>case MAVLINK_PARSE_STATE_GOT_STX:</code></p> </li><li> <p><code>if (msg_received) {<!-- --></code></p> </li><li> <p><code>msg_received = false;</code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_IDLE;</code></p> </li><li> <p><code>} else {<!-- --></code></p> </li><li> <p><code>m = new MAVLinkPacket(c);</code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_LENGTH;</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>break;</code></p> </li><li><li> <p><code>case MAVLINK_PARSE_STATE_GOT_LENGTH:</code></p> </li><li> <p><code>m.seq = c;</code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_SEQ;</code></p> </li><li> <p><code>break;</code></p> </li><li><li> <p><code>case MAVLINK_PARSE_STATE_GOT_SEQ:</code></p> </li><li> <p><code>m.sysid = c;</code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_SYSID;</code></p> </li><li> <p><code>break;</code></p> </li><li><li> <p><code>case MAVLINK_PARSE_STATE_GOT_SYSID:</code></p> </li><li> <p><code>m.compid = c;</code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_COMPID;</code></p> </li><li> <p><code>break;</code></p> </li><li><li> <p><code>case MAVLINK_PARSE_STATE_GOT_COMPID:</code></p> </li><li> <p><code>m.msgid = c;</code></p> </li><li> <p><code>if (m.len == 0) {<!-- --></code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_PAYLOAD;</code></p> </li><li> <p><code>} else {<!-- --></code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID;</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>break;</code></p> </li><li><li> <p><code>case MAVLINK_PARSE_STATE_GOT_MSGID:</code></p> </li><li> <p><code>m.payload.add((byte) c);</code></p> </li><li> <p><code>if (m.payloadIsFilled()) {<!-- --></code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_PAYLOAD;</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>break;</code></p> </li><li><li> <p><code>case MAVLINK_PARSE_STATE_GOT_PAYLOAD:</code></p> </li><li> <p><code>m.generateCRC();</code></p> </li><li> <p><code>// Check first checksum byte</code></p> </li><li> <p><code>if (c != m.crc.getLSB()) {<!-- --></code></p> </li><li> <p><code>msg_received = false;</code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_IDLE;</code></p> </li><li> <p><code>if (c == MAVLinkPacket.MAVLINK_STX) {<!-- --></code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_STX;</code></p> </li><li> <p><code>m.crc.start_checksum();</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>stats.crcError();</code></p> </li><li> <p><code>} else {<!-- --></code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_CRC1;</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>break;</code></p> </li><li><li> <p><code>case MAVLINK_PARSE_STATE_GOT_CRC1:</code></p> </li><li> <p><code>// Check second checksum byte</code></p> </li><li> <p><code>if (c != m.crc.getMSB()) {<!-- --></code></p> </li><li> <p><code>msg_received = false;</code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_IDLE;</code></p> </li><li> <p><code>if (c == MAVLinkPacket.MAVLINK_STX) {<!-- --></code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_STX;</code></p> </li><li> <p><code>m.crc.start_checksum();</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>stats.crcError();</code></p> </li><li> <p><code>} else { // Successfully received the message</code></p> </li><li> <p><code>stats.newPacket(m);</code></p> </li><li> <p><code>msg_received = true;</code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_IDLE;</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>break;</code></p> </li><li><li> <p><code>}</code></p> </li><li> <p><code>if (msg_received) {<!-- --></code></p> </li><li> <p><code>return m;</code></p> </li><li> <p><code>} else {<!-- --></code></p> </li><li> <p><code>return null;</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>}</code></p> </li></ol> 
<p>我们发现,Parser类必须要线性的解析报文,也就是说,在同一个周期内,只能有一条消息在Parser类中处理。并且Parser类的方法结构本质上是一个状态机。外部代码需要遍历传入byte中的数据用于生成报文:</p> 
<p></p> 
<pre><code class="language-html"> </code></pre> 
<ol><li> <p><code>private void handleData(Parser parser, int bufferSize, byte[] buffer) {<!-- --></code></p> </li><li> <p><code>if (bufferSize &lt; 1) {<!-- --></code></p> </li><li> <p><code>return;</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>for (int i = 0; i &lt; bufferSize; i++) {<!-- --></code></p> </li><li> <p><code>int code = buffer[i] &amp; 0x00ff;</code></p> </li><li> <p><code>MAVLinkPacket receivedPacket = parser.mavlink_parse_char(code);</code></p> </li><li> <p><code>if (receivedPacket != null) {<!-- --></code></p> </li><li> <p><code>//test(receivedPacket);</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p>Parser类所具有的状态列表:</p> 
<p></p> 
<pre><code class="language-html"> </code></pre> 
<ol><li> <p><code>enum MAV_states {<!-- --></code></p> </li><li> <p><code>MAVLINK_PARSE_STATE_UNINIT, MAVLINK_PARSE_STATE_IDLE, MAVLINK_PARSE_STATE_GOT_STX, MAVLINK_PARSE_STATE_GOT_LENGTH, MAVLINK_PARSE_STATE_GOT_SEQ, MAVLINK_PARSE_STATE_GOT_SYSID, MAVLINK_PARSE_STATE_GOT_COMPID, MAVLINK_PARSE_STATE_GOT_MSGID, MAVLINK_PARSE_STATE_GOT_CRC1, MAVLINK_PARSE_STATE_GOT_PAYLOAD</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p><br>  </p> 
<p>前面说了Parser类本质上是一个状态机,初始的状态是:MAV_PARSE_STATE_UNINIT。一旦解析成功或者失败,状态将进入到IDLE。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/4c/1b/rQUNO50A_o.jpg"></p> 
<p></p> 
<p>Parser类的状态机基本可以使用上面的图片表示,基本上没有什么复杂的内容,主要的在与刚开始的数据长度的记录。如果你的数据长度大于零的话,解析器会将你的数据缓存在一个叫做payload的数据结构中。</p> 
<p></p> 
<pre><code class="language-html"> </code></pre> 
<ol><li> <p><code>case MAVLINK_PARSE_STATE_GOT_MSGID:</code></p> </li><li> <p><code>m.payload.add((byte) c);</code></p> </li><li> <p><code>if (m.payloadIsFilled()) {<!-- --></code></p> </li><li> <p><code>state = MAV_states.MAVLINK_PARSE_STATE_GOT_PAYLOAD;</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>break;</code></p> </li></ol> 
<p>PayLoad对应的类是MAVLinkPayLoad类,他是数据的缓存器和转换器,就是将无意义的byte数组,组织成为有意义的平台数据类型。</p> 
<p></p> 
<pre><code class="language-html"> </code></pre> 
<ol><li> <p><code>public class MAVLinkPayload {<!-- --></code></p> </li><li><li> <p><code>private static final byte UNSIGNED_BYTE_MIN_VALUE = 0;</code></p> </li><li> <p><code>private static final short UNSIGNED_BYTE_MAX_VALUE = Byte.MAX_VALUE - Byte.MIN_VALUE;</code></p> </li><li><li> <p><code>private static final short UNSIGNED_SHORT_MIN_VALUE = 0;</code></p> </li><li> <p><code>private static final int UNSIGNED_SHORT_MAX_VALUE = Short.MAX_VALUE - Short.MIN_VALUE;</code></p> </li><li><li> <p><code>private static final int UNSIGNED_INT_MIN_VALUE = 0;</code></p> </li><li> <p><code>private static final long UNSIGNED_INT_MAX_VALUE = (long) Integer.MAX_VALUE - Integer.MIN_VALUE;</code></p> </li><li><li> <p><code>private static final long UNSIGNED_LONG_MIN_VALUE = 0;</code></p> </li><li><li> <p><code>public static final int MAX_PAYLOAD_SIZE = 255;</code></p> </li><li><li> <p><code>public final ByteBuffer payload;</code></p> </li><li> <p><code>public int index;</code></p> </li><li><li> <p><code>public MAVLinkPayload(int payloadSize) {<!-- --></code></p> </li><li> <p><code>if(payloadSize &gt; MAX_PAYLOAD_SIZE) {<!-- --></code></p> </li><li> <p><code>payload = ByteBuffer.allocate(MAX_PAYLOAD_SIZE);</code></p> </li><li> <p><code>} else {<!-- --></code></p> </li><li> <p><code>payload = ByteBuffer.allocate(payloadSize);</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public ByteBuffer getData() {<!-- --></code></p> </li><li> <p><code>return payload;</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public int size() {<!-- --></code></p> </li><li> <p><code>return payload.position();</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public void add(byte c) {<!-- --></code></p> </li><li> <p><code>payload.put(c);</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public void resetIndex() {<!-- --></code></p> </li><li> <p><code>index = 0;</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public byte getByte() {<!-- --></code></p> </li><li> <p><code>byte result = 0;</code></p> </li><li> <p><code>result |= (payload.get(index + 0) &amp; 0xFF);</code></p> </li><li> <p><code>index += 1;</code></p> </li><li> <p><code>return result;</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public short getUnsignedByte(){<!-- --></code></p> </li><li> <p><code>short result = 0;</code></p> </li><li> <p><code>result |= payload.get(index + 0) &amp; 0xFF;</code></p> </li><li> <p><code>index+= 1;</code></p> </li><li> <p><code>return result; </code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public short getShort() {<!-- --></code></p> </li><li> <p><code>short result = 0;</code></p> </li><li> <p><code>result |= (payload.get(index + 1) &amp; 0xFF) &lt;&lt; 8;</code></p> </li><li> <p><code>result |= (payload.get(index + 0) &amp; 0xFF);</code></p> </li><li> <p><code>index += 2;</code></p> </li><li> <p><code>return result;</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public int getUnsignedShort(){<!-- --></code></p> </li><li> <p><code>int result = 0;</code></p> </li><li> <p><code>result |= (payload.get(index + 1) &amp; 0xFF) &lt;&lt; 8;</code></p> </li><li> <p><code>result |= (payload.get(index + 0) &amp; 0xFF);</code></p> </li><li> <p><code>index += 2;</code></p> </li><li> <p><code>return result;</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public int getInt() {<!-- --></code></p> </li><li> <p><code>int result = 0;</code></p> </li><li> <p><code>result |= (payload.get(index + 3) &amp; 0xFF) &lt;&lt; 24;</code></p> </li><li> <p><code>result |= (payload.get(index + 2) &amp; 0xFF) &lt;&lt; 16;</code></p> </li><li> <p><code>result |= (payload.get(index + 1) &amp; 0xFF) &lt;&lt; 8;</code></p> </li><li> <p><code>result |= (payload.get(index + 0) &amp; 0xFF);</code></p> </li><li> <p><code>index += 4;</code></p> </li><li> <p><code>return result;</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public long getUnsignedInt(){<!-- --></code></p> </li><li> <p><code>long result = 0;</code></p> </li><li> <p><code>result |= (payload.get(index + 3) &amp; 0xFFFFL) &lt;&lt; 24;</code></p> </li><li> <p><code>result |= (payload.get(index + 2) &amp; 0xFFFFL) &lt;&lt; 16;</code></p> </li><li> <p><code>result |= (payload.get(index + 1) &amp; 0xFFFFL) &lt;&lt; 8;</code></p> </li><li> <p><code>result |= (payload.get(index + 0) &amp; 0xFFFFL);</code></p> </li><li> <p><code>index += 4;</code></p> </li><li> <p><code>return result;</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public long getLong() {<!-- --></code></p> </li><li> <p><code>long result = 0;</code></p> </li><li> <p><code>result |= (payload.get(index + 7) &amp; 0xFFFFL) &lt;&lt; 56;</code></p> </li><li> <p><code>result |= (payload.get(index + 6) &amp; 0xFFFFL) &lt;&lt; 48;</code></p> </li><li> <p><code>result |= (payload.get(index + 5) &amp; 0xFFFFL) &lt;&lt; 40;</code></p> </li><li> <p><code>result |= (payload.get(index + 4) &amp; 0xFFFFL) &lt;&lt; 32;</code></p> </li><li> <p><code>result |= (payload.get(index + 3) &amp; 0xFFFFL) &lt;&lt; 24;</code></p> </li><li> <p><code>result |= (payload.get(index + 2) &amp; 0xFFFFL) &lt;&lt; 16;</code></p> </li><li> <p><code>result |= (payload.get(index + 1) &amp; 0xFFFFL) &lt;&lt; 8;</code></p> </li><li> <p><code>result |= (payload.get(index + 0) &amp; 0xFFFFL);</code></p> </li><li> <p><code>index += 8;</code></p> </li><li> <p><code>return result;</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public long getUnsignedLong(){<!-- --></code></p> </li><li> <p><code>return getLong();</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public long getLongReverse() {<!-- --></code></p> </li><li> <p><code>long result = 0;</code></p> </li><li> <p><code>result |= (payload.get(index + 0) &amp; 0xFFFFL) &lt;&lt; 56;</code></p> </li><li> <p><code>result |= (payload.get(index + 1) &amp; 0xFFFFL) &lt;&lt; 48;</code></p> </li><li> <p><code>result |= (payload.get(index + 2) &amp; 0xFFFFL) &lt;&lt; 40;</code></p> </li><li> <p><code>result |= (payload.get(index + 3) &amp; 0xFFFFL) &lt;&lt; 32;</code></p> </li><li> <p><code>result |= (payload.get(index + 4) &amp; 0xFFFFL) &lt;&lt; 24;</code></p> </li><li> <p><code>result |= (payload.get(index + 5) &amp; 0xFFFFL) &lt;&lt; 16;</code></p> </li><li> <p><code>result |= (payload.get(index + 6) &amp; 0xFFFFL) &lt;&lt; 8;</code></p> </li><li> <p><code>result |= (payload.get(index + 7) &amp; 0xFFFFL);</code></p> </li><li> <p><code>index += 8;</code></p> </li><li> <p><code>return result;</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public float getFloat() {<!-- --></code></p> </li><li> <p><code>return Float.intBitsToFloat(getInt());</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public void putByte(byte data) {<!-- --></code></p> </li><li> <p><code>add(data);</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public void putUnsignedByte(short data){<!-- --></code></p> </li><li> <p><code>if(data &lt; UNSIGNED_BYTE_MIN_VALUE || data &gt; UNSIGNED_BYTE_MAX_VALUE){<!-- --></code></p> </li><li> <p><code>throw new IllegalArgumentException("Value is outside of the range of an unsigned byte: " + data);</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>putByte((byte) data);</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public void putShort(short data) {<!-- --></code></p> </li><li> <p><code>add((byte) (data &gt;&gt; 0));</code></p> </li><li> <p><code>add((byte) (data &gt;&gt; 8));</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public void putUnsignedShort(int data){<!-- --></code></p> </li><li> <p><code>if(data &lt; UNSIGNED_SHORT_MIN_VALUE || data &gt; UNSIGNED_SHORT_MAX_VALUE){<!-- --></code></p> </li><li> <p><code>throw new IllegalArgumentException("Value is outside of the range of an unsigned short: " + data);</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>putShort((short) data);</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public void putInt(int data) {<!-- --></code></p> </li><li> <p><code>add((byte) (data &gt;&gt; 0));</code></p> </li><li> <p><code>add((byte) (data &gt;&gt; 8));</code></p> </li><li> <p><code>add((byte) (data &gt;&gt; 16));</code></p> </li><li> <p><code>add((byte) (data &gt;&gt; 24));</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public void putUnsignedInt(long data){<!-- --></code></p> </li><li> <p><code>if(data &lt; UNSIGNED_INT_MIN_VALUE || data &gt; UNSIGNED_INT_MAX_VALUE){<!-- --></code></p> </li><li> <p><code>throw new IllegalArgumentException("Value is outside of the range of an unsigned int: " + data);</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>putInt((int) data);</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public void putLong(long data) {<!-- --></code></p> </li><li> <p><code>add((byte) (data &gt;&gt; 0));</code></p> </li><li> <p><code>add((byte) (data &gt;&gt; 8));</code></p> </li><li> <p><code>add((byte) (data &gt;&gt; 16));</code></p> </li><li> <p><code>add((byte) (data &gt;&gt; 24));</code></p> </li><li> <p><code>add((byte) (data &gt;&gt; 32));</code></p> </li><li> <p><code>add((byte) (data &gt;&gt; 40));</code></p> </li><li> <p><code>add((byte) (data &gt;&gt; 48));</code></p> </li><li> <p><code>add((byte) (data &gt;&gt; 56));</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public void putUnsignedLong(long data){<!-- --></code></p> </li><li> <p><code>if(data &lt; UNSIGNED_LONG_MIN_VALUE){<!-- --></code></p> </li><li> <p><code>throw new IllegalArgumentException("Value is outside of the range of an unsigned long: " + data);</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>putLong(data);</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>public void putFloat(float data) {<!-- --></code></p> </li><li> <p><code>putInt(Float.floatToIntBits(data));</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>}</code></p> </li></ol> 
<p><br> 这个类的复用性很高,我们在很多解析器里面都可以用到它,希望大家以后如果写自己的解析器的话可以想到它。好的,我们现在有了数据Payload我们怎么解析出消息呢？</p> 
<p>我们回到我们的Packet类,Packet用了一个很典型的命名unpack来用来解包:</p> 
<p></p> 
<pre><code class="language-html"> </code></pre> 
<ol><li> <p><code>public MAVLinkMessage unpack() {<!-- --></code></p> </li><li> <p><code>switch (msgid) {<!-- --></code></p> </li><li><li> <p><code>case msg_sensor_offsets.MAVLINK_MSG_ID_SENSOR_OFFSETS:</code></p> </li><li> <p><code>return new msg_sensor_offsets(this);</code></p> </li><li><li> <p><code>case msg_set_mag_offsets.MAVLINK_MSG_ID_SET_MAG_OFFSETS:</code></p> </li><li> <p><code>return new msg_set_mag_offsets(this);</code></p> </li><li><li> <p><code>case msg_meminfo.MAVLINK_MSG_ID_MEMINFO:</code></p> </li><li> <p><code>return new msg_meminfo(this);</code></p> </li><li> <p><code>......</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p><br> 如果你自定义了一种MavLink协议类型的话,代码生成器会自动帮你生成一个case和一个消息类,而在这里,我们找到我们所需要的心跳类case:</p> 
<p></p> 
<pre><code class="language-html"> </code></pre> 
<ol><li> <p><code>case msg_heartbeat.MAVLINK_MSG_ID_HEARTBEAT:</code></p> </li><li> <p><code>return new msg_heartbeat(this);</code></p> </li></ol> 
<p><br> 在心跳消息的构造器里,具体消息类型会对报文的具体内容做真正的解包:</p> 
<p></p> 
<pre><code class="language-html"> </code></pre> 
<ol><li> <p><code>public void unpack(MAVLinkPayload payload) {<!-- --></code></p> </li><li> <p><code>payload.resetIndex();</code></p> </li><li><li> <p><code>this.custom_mode = payload.getUnsignedInt();</code></p> </li><li><li> <p><code>this.type = payload.getUnsignedByte();</code></p> </li><li><li> <p><code>this.autopilot = payload.getUnsignedByte();</code></p> </li><li><li> <p><code>this.base_mode = payload.getUnsignedByte();</code></p> </li><li><li> <p><code>this.system_status = payload.getUnsignedByte();</code></p> </li><li><li> <p><code>this.mavlink_version = payload.getUnsignedByte();</code></p> </li><li><li> <p><code>}</code></p> </li></ol> 
<p><br> 这样,记录在payload中杂乱的数据就被记录在msg_heartbeat类的变量中啦~</p> 
<p>大家如果感兴趣,就自己去生成和阅读它的代码,代码量很少很好读懂,且通用性很好很好调试。</p> 
<p></p> 
<h2><strong>MAVLink—最强大的微型飞行器通信协议</strong></h2> 
<p><strong>1 简介</strong>MAVLink通讯协议是一个为微型飞行器设计的非常轻巧的、只由头文件构成的信息编组库。<br> 它可以通过串口非常高效地封装C结构数据，并将这些数据包发送至地面控制站。该协议被PX4, PIXHAWK, APM和Parrot AR.Drone平台所广泛测试并在以上的项目中作为MCU/IMU间以及Linux进程和地面站链路通信间的主干通信协议。</p> 
<p style="margin-left:0px;">MAVLink最初由LorenzMeier根据LGPL许可在2009年初发表。</p> 
<p style="margin-left:0px;"></p> 
<p><strong>1.1  综合教程（见附件1）</strong><strong>1.2  MAVLink消息格式及MAVLink API标准文件（见附件2）</strong><strong>1.3  协议内容</strong><br>  </p> 
<p>1）线上（On-the-wire）格式和CRC冗余校验——</p> 
<p>2）MAVLink 1.1版兼容性和特点</p> 
<p>3）MAVLink任务内容</p> 
<p>（1）  路径点协议</p> 
<p>（2）  参数协议</p> 
<p>（3）  图像传输协议</p> 
<p>（4）  控制接口</p> 
<p>4）MAVLink数据类型及相关约定</p> 
<p>5）常见MAVLink消息</p> 
<p></p> 
<p><strong>1.4 MAVLink代码及生成器</strong><br> “普通信息集”包含了非常广泛的常用信息并以C语言头文件储存。如果你想定义并使用自己的代码，可以使用MAVLink Generator(C/C++,python)或QGroundcontrol。<br><br><strong>1.5 MAVLink生态系统</strong><br> 1） 使用MAVLink的自动驾系统</p> 
<p>Ÿ  <a href="http://code.google.com/p/ardupilot-mega/" rel="nofollow" title="ArduPilotMega">ArduPilotMega</a> (mainprotocol)</p> 
<p>Ÿ  <a href="http://pixhawk.ethz.ch/wiki/electronics/imu" rel="nofollow" title="pxIMU Autopilot">pxIMU Autopilot</a> (mainprotocol)</p> 
<p>Ÿ  <a href="http://slugsuav.soe.ucsc.edu/index.html" rel="nofollow" title="SLUGS Autopilot">SLUGS Autopilot</a> (mainprotocol)</p> 
<p>Ÿ  <a href="http://www.aerialrobotics.eu/flexipilot/flexipilot1.2-osd-en.pdf" rel="nofollow" title="FLEXIPILOT">FLEXIPILOT</a> (optionalprotocol)</p> 
<p>Ÿ  <a href="http://code.google.com/p/gentlenav/wiki/MatrixPilot" rel="nofollow" title="UAVDevBoard/Gentlenav/MatrixPilot">UAVDevBoard/Gentlenav/MatrixPilot</a> (optionalprotocol)</p> 
<p>Ÿ  <a href="http://www.sensesoar.ethz.ch/doku.php?id=news" rel="nofollow" title="SenseSoarAutopilot">SenseSoarAutopilot</a> (main protocol)</p> 
<p>Ÿ  <a href="http://www.sky-drones.com/" rel="nofollow" title="SmartAPAutopilot">SmartAPAutopilot</a> (main protocol)</p> 
<p>Ÿ  <a href="http://autoquad.org/" rel="nofollow" title="AutoQuad 6 AutoPilot">AutoQuad 6 AutoPilot</a> (mainprotocol)</p> 
<p>2） 使用MAVLink的软件包</p> 
<p>Ÿ  <a href="http://www.qgroundcontrol.org/" rel="nofollow" title="QGroundControl(Windows/Mac/Linux)">QGroundControl(Windows/Mac/Linux)</a></p> 
<p>Ÿ  <a href="http://code.google.com/p/happykillmore-gcs/" rel="nofollow" title="HK GroundControl Station (Windows)">HK GroundControl Station (Windows)</a></p> 
<p>Ÿ  <a href="http://code.google.com/p/ardupilot-mega/wiki/Mission" rel="nofollow" title="APMPlanner (Windows/Mac)">APMPlanner (Windows/Mac)</a></p> 
<p>Ÿ  <a href="http://autoquad.org/software-downloads/?category=2" rel="nofollow" title="QGroundControlw/ AutoQuad MainWidget (Windows/Mac/Linux)">QGroundControlw/ AutoQuad MainWidget (Windows/Mac/Linux)</a></p> 
<p>Ÿ  <a href="http://code.google.com/p/copter-gcs/" rel="nofollow" title="Copter GCS(Android)">Copter GCS(Android)</a></p> 
<p>Ÿ  <a href="http://autoquad.org/software-downloads/?category=2" rel="nofollow" title="AutoQuadGCS (Android)">AutoQuadGCS (Android)</a></p> 
<p>Ÿ  ROS to MAVLink bridge: <a href="https://github.com/mavlink/mavlink-ros" title="https://github.com/mavlink/mavlink-ros">https://github.com/mavlink/mavlink-ros</a></p> 
<p>Ÿ  MAVCONN Lightweight Aerial Middleware <a href="http://pixhawk.ethz.ch/software/middleware/start" rel="nofollow" title="http://pixhawk.ethz.ch/software/middleware/start">http://pixhawk.ethz.ch/software/middleware/start</a></p> 
<p>Ÿ  oooArk / MAVSim <a href="http://www.youtube.com/watch?v=-wQVrM5SL2o&amp;fe" rel="nofollow" title="http://www.youtube.com/watch?v=-wQVrM5SL2o&amp;fe">http://www.youtube.com/watch?v=-wQVrM5SL2o&amp;fe</a></p> 
<p>Ÿ  <a href="http://www.qgroundcontrol.org/mavlink/pymavlink" rel="nofollow" title="MAVLinkpython bindings">MAVLinkpython bindings</a></p> 
<p>Ÿ  <a href="http://www.qgroundcontrol.org/mavlink/mavproxy_startpage" rel="nofollow" title="MAVProxy">MAVProxy</a> (allows toconnect multiple UDP/serial links, including flightgear):</p> 
<p>3） 使用MAVLink的项目</p> 
<p>Ÿ   ArduPilotMega <a href="http://code.google.com/p/ardupilot-mega/" rel="nofollow" title="http://code.google.com/p/ardupilot-mega/">http://code.google.com/p/ardupilot-mega/</a></p> 
<p>Ÿ   MatrixPilot UAVDevBoard <a href="http://code.google.com/p/gentlenav/" rel="nofollow" title="http://code.google.com/p/gentlenav/">http://code.google.com/p/gentlenav/</a></p> 
<p>Ÿ   PIXHAWK <a href="http://pixhawk.ethz.ch/" rel="nofollow" title="http://pixhawk.ethz.ch/">http://pixhawk.ethz.ch/</a></p> 
<p>Ÿ   ETH Flying MachineArena <a href="http://www.idsc.ethz.ch/Research_DAndrea/FMA" rel="nofollow" title="http://www.idsc.ethz.ch/Research_DAndrea/FMA">http://www.idsc.ethz.ch/Research_DAndrea/FMA</a></p> 
<p>Ÿ   ETH SenseSoarSolar Airplane Project <a href="http://www.sensesoar.ethz.ch/doku.php?id=news" rel="nofollow" title="http://www.sensesoar.ethz.ch/doku.php?id=news">http://www.sensesoar.ethz.ch/doku.php?id=news</a></p> 
<p>Ÿ   ETH Skye BlimpProject <a href="http://www.projectskye.ch/" rel="nofollow" title="http://www.projectskye.ch/">http://www.projectskye.ch/</a></p> 
<p>Ÿ   UC Santa CruzSLUGS <a href="http://slugsuav.soe.ucsc.edu/index.html" rel="nofollow" title="Intro">Intro</a></p> 
<p>Ÿ   ArduCAMOSD <a href="http://code.google.com/p/arducam-osd/" rel="nofollow" title="http://code.google.com/p/arducam-osd/">http://code.google.com/p/arducam-osd/</a></p> 
<p>Ÿ   Sky-Drones - UAVFlight Control Systems <a href="http://www.sky-drones.com/" rel="nofollow" title="Designers and Manufacturers of Drone Software and Hardware for Enterprise - Sky-Drones Technologies Ltd">Designers and Manufacturers of Drone Software and Hardware for Enterprise - Sky-Drones Technologies Ltd</a></p> 
<p>Ÿ   AutoQuad -Autonomous Multirotor Vehicle controller <a href="http://autoquad.org/" rel="nofollow" title="http://autoquad.org/">http://autoquad.org/</a></p> 
<p><br><strong>1.6 MAVLink 数据格式分解</strong><br> 以一个MAVLink数据包为例，下图为其数据包具体的结构剖析。该结构是受到CAN和SAE AS-4标准的启发构建的。</p> 
<p>                              </p> 
<table border="1" cellspacing="0"><tbody><tr><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>字节顺序</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>内容</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>值</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>含义</p>   </td></tr><tr><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>0</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>数据包开始标志</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>v1.0: 0xFE  (v0.9: 0x55)</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>指示新的数据包即将开始</p>   </td></tr><tr><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>1</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>有效载荷长度</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>0 - 255</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>指示接下来的有效负载长度</p>   </td></tr><tr><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>2</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>数据包 序列号</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>0 - 255</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>每个传输部件都会对发送序列进行计数。该结构能够检测到数据包的丢失</p>   </td></tr><tr><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>3</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>系统ID</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>1 – 255</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>发送该包的系统ID。该结构能够区分在同一网络中不同的MAV。</p>   </td></tr><tr><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>4</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>设备ID</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>0 – 255</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>发送该数据包的设备ID。该结构能够区分同一系统的不同发送设备。如：IMU和AutoPilot。</p>   </td></tr><tr><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>5</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>消息ID</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>0 - 255</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>消息ID。该ID定义了有效负载的“含义”以及负载应被如何正确的解码</p>   </td></tr><tr><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>6至(n+6)</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>数据</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>(0 – 255)字节</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>消息数据。具体内容取决于消息ID</p>   </td></tr><tr><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>(n+7)至(n+8)</p>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   <p>校验位</p>    <p>(低字节和高字节)</p>   </td><td colspan="2" style="background-color:#ffffff;border-color:#e3edf5;">   <p>ITU X.25/ SAE AS-4哈希校验，<strong>不包括数据包开始的标志，所以字节</strong><strong>1 ..</strong><strong>（</strong><strong>N+6</strong><strong>）</strong>注意：校验码同样包括MAVLINK_CRC_EXTRA(数值从消息字段开始计算,避免同一个数据包因版本而变量值不同因其的解码问题。</p>   </td></tr></tbody></table> 
<p>Ÿ 校验值使用的是与 ITU X.25 和SAE AS-4相同的校验标准（CRC-16-CCITT）,在文档<a href="http://www.sae.org/servlets/productDetail?PROD_TYP=STD&amp;PROD_CD=AS5669A" rel="nofollow" title="SAE AS5669A">SAE AS5669A</a>中有叙述。</p> 
<p>Ÿ 通信包的最小长度为不带任何有效负载的8字节大小。</p> 
<p>Ÿ 通信包的最大长度为满载263字节。</p> 
<p></p> 
<p><strong>1.7    协议支持的数据结构</strong></p> 
<p style="margin-left:0px;">MAVLink协议支持固定大小的整形数据类型、IEEE 754协议规定的单精度浮点型数据、以上数据构成的数组（如：char[10]），以及由协议自动添加的特别的MAVLink版本字段类型。具体如下：</p> 
<p>§ <strong>char</strong> -Characters / strings</p> 
<p>§ <strong>uint8_t</strong> - Unsigned8 bit</p> 
<p>§ <strong>int8_t</strong> - Signed 8bit</p> 
<p>§ <strong>uint16_t</strong> - Unsigned16 bit</p> 
<p>§ <strong>int16_t</strong> - Signed16 bit</p> 
<p>§ <strong>uint32_t</strong> - Unsigned32 bit</p> 
<p>§ <strong>int32_t</strong> - Signed32 bit</p> 
<p>§ <strong>uint64_t</strong> - Unsigned64 bit</p> 
<p>§ <strong>int64_t</strong> - Signed64 bit</p> 
<p>§ <strong>float</strong> - IEEE 754single precision floating point number</p> 
<p>§ <strong>double</strong> - IEEE 754double precision floating point number</p> 
<p>§ <strong>uint8_t_mavlink_version</strong> - 无符号8位字段，以当前的MAVLink版本发送时被自动添加，它不能被更改只是在数据包中以通常无符号8位整型字段读取。</p> 
<p></p> 
<p><strong>1.8  性能</strong><br> 该协议主要面向两方面特性：传输速度和安全性。协议允许检验消息内容，同样允许检测丢失的消息序列但仍然只需要每个包中6个字节的开销来保证。<br> 传输实例：</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="background-color:#ffffff;border-color:#e3edf5;">  链路速度/波特<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   硬件<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   更新速率<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   负载<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   浮点值<br>   </td></tr><tr><td style="background-color:#ffffff;border-color:#e3edf5;">  115200 baud<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   XBee Pro 2.4 GHz<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   50  Hz<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   224 bytes<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   56<br>   </td></tr><tr><td style="background-color:#ffffff;border-color:#e3edf5;">  115200 baud<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   XBee Pro 2.4 GHz<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   100 Hz<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   109 bytes<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   27<br>   </td></tr><tr><td style="background-color:#ffffff;border-color:#e3edf5;">  57600 baud<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   XBee Pro 2.4 GHz<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   100 Hz<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   51  bytes<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   12<br>   </td></tr><tr><td style="background-color:#ffffff;border-color:#e3edf5;">  9600 baud<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   XBee Pro XSC 900<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   50  Hz<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   13  bytes<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   3<br>   </td></tr><tr><td style="background-color:#ffffff;border-color:#e3edf5;">  9600 baud<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   XBee Pro XSC 900<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   20  Hz<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   42  bytes<br>   </td><td style="background-color:#ffffff;border-color:#e3edf5;">   10<br>   </td></tr></tbody></table> 
<p><br><strong>1.9  未来的工作/想法</strong><br> Ÿ 采用变长数组<br> Ÿ 支持位域（例如：将8个布尔型的值封装入一个uint8_t结构中，但所有的C结构函数都可调用全部的8个布尔型量。用户就不必在整体移动或隐藏中浪费时间）<br> Ÿ 可变的多样头部，允许设定目标系统和目标部件（不改变协议本身，只是方便函数调用它们）<br><br><strong>2  路径点协议</strong><br> 路径点协议描述了路径点是如何被发送到MAV并被它所读取的。其目标是在发送端和接收端确保建立一种连续稳定的状态。QGroundControl执行了在地面控制端的协议要求，每个在MAV上使用MAVLink实现路径点协议的规划模块能够和QGroundControl通讯并交换和更新它的路径点。<br><br><strong>2.1 通信/状态机</strong><br> 协议中包含很多事务，每一个事务的完成情况以成功和失败来描述，在接收端的路径点列表状态未改变则被认为该事务的完成情况是失败的。只有在两个正在通讯的部分之间么有其他的事务在活动中时，新的事务才可以被一个特定的消息字段唤起进行。这意味着，如果想要发起一个新的事务，参与到该事务中的通讯部分必须全部处于IDLE即空状态。如果开始了一个事务，则通讯部分的状态将改变。引入一个以这种方式工作的状态机，则路径点协议可以十分简单的实现。<br> 除了应答消息之外的其他信息在被发送之后，发送端的部件就会启动一个定时器。如果在特定的时间内，没有收到响应则请求的消息将会被重新发送一次。该重传过程会重复数次，如果在最后一次的重传超时后仍然没有收到相应，则认定该项事务失败。该重传机制意味着所有的部件必须能够处理重复的消息。<br><br><strong>2.2 读取MAV的路径点列表</strong></p> 
<p style="margin-left:0px;">  为了能够从部件中检索含有所有路径点的列表，将会发送一个WAYPOINT_REQUEST_LIST的消息，而目标部件将会回应一个WAYPOINT_COUNT消息，描述在它的列表中的路径点数量。</p> 
<p>之后，正在发送请求的部件会要求没有个路径点从序列号0开始发送WAYPOINT_REQUEST消息，而目标部件会以包含有路径点数据的对应的WAYPOINT消息来回应每一个请求。</p> 
<p>当最后一个路径节点成功的接收到消息之后，发送请求的部件会向目的地部件发送一个WAYPOINT_ACK消息。这个消息将结束该项事务。需要注意的是，目的地部件必须监听来自最后一个路径节点的WAYPOINT_REQUEST消息，知道它拿到WAYPOINT_ACK消息或另一个消息命令开启一个不同的事务或者发生了超时。</p> 
<p></p> 
<p><strong>2.3 书写MAV的路径列表</strong></p> 
<p style="margin-left:0px;">  为了能够发送一个路径点的列表，一个包含有列表中路径点数量的WAYPOINT_COUNT消息会被发送至目的地设备。而该设备将做好接收消息的准备，同时通过发送从序列号0开始的WAYPOINT_REQUEST消息开始检索所有的路径点。而发送路径点列表的设备将会以WAYPOINT消息来回应所有的请求。</p> 
<p>当最后一个路径节点被目的地设备成功接收后，该目标设备将向发送设备发送一个WAYPOINT_ACK消息。之后将结束该事务。<br> 如果一个路径点计划器设备在事务之外收到了WAYPOINT消息，它将发送一个WAYPOINT_ACK消息。<br><br><strong>2.4 清除MAV的路径点列表</strong></p> 
<p style="margin-left:0px;">  要清除一个设备的路径点列表则可以发送WAYPOINT_CLEAR_ALL消息。在清除了路径点列表之后，目标设备将以WAYPOINT_ACK消息作为回应。</p> 
<p style="margin-left:0px;"></p> 
<p><strong>2.5 设置新的当前MAV路径点</strong></p> 
<p style="margin-left:0px;">  要向设备设置新的当前活跃路径点，发送一个WAYPOINT_SET_CURRENT消息即可。在完成了更改当前的路径点后目标设备将通过带有新的当前序列号的WAYPOINT_CURRENT消息作为回应。</p> 
<p><br><strong>2.6 MAV抵达路径点的状态消息</strong><br> 如果MAV上的路径点规划设备抵达一个路径点，它将会广播一个WAYPOINT_REACHED消息。由于是广播消息，因此不需要发送ACK消息，同样也就不能保证消息的接收。<br><br><strong>2.7  MAV更改当前路径点的状态消息</strong><br> 如果一个MAV上的路径点规划设备选择了一个新的路径点作为它的新的当前航电，它将会广播一个WAYPOINT_CURRENT消息。由于是广播消息，因此不需要发送ACK消息，同样也就不能保证消息的接收。建议该消息能够在较小的间隔中发送两次，从而保证能够有较大的可能性使得所有接收端收到。<br><br><strong>2.8  路径点文件格式</strong><br> 尽管这不是MAVLink协议的一部分，这个是建议的路径点文件格式（QGroundControl和其他设备默认使用）。请注意在参数之间的空格实质上是&lt;tab&gt;（在大多数编程语言中是”\t”）<br><br><strong>3  参数协议</strong><br> 板载参数协议接口允许向内存（RAM）读写参数（例如：PID增益）也可以向参数存储器读写（EEPROM或者硬盘）。<br>    它不仅可以被部署安装在一个微型控制器上（例如：带有ARM7的pxIMU），也可以是标准软件（如：Linux系统中的px_multitracker进程）。<br><br><strong>3.1  支持的数据类型</strong><br> MAVLink v1.0支持如下数据类型：</p> 
<p>§ uint32_t - 32bit unsigned integer (use the ENUMvalue MAV_PARAM_TYPE_UINT32)</p> 
<p>§ int32_t - 32bit signed integer (use the ENUM value MAV_PARAM_TYPE_INT32)</p> 
<p>§ float - IEEE754 single precision floating point number(use the ENUM value MAV_PARAM_TYPE_FLOAT)</p> 
<p style="margin-left:0px;"><strong>注意：所有的参数都以浮点型的</strong><strong>mavlink_param_union_t</strong><strong>值发送，</strong><strong>也就是意味着一个参数应当已这个按字节转换为相应的浮点型数据（没有类型转换）【</strong>which means that a parameter should be byte-wise convertedwith this union to a byte-wise float (no type conversion)】。这对于为了不影响和限制扩展后的整型参数的最大精确度的目的是非常必要的。例如：GPS定位的参数以单精度浮点型数据只能精确到几米的级别，而GPS定位参数如果以1E7</p> 
<p><br><strong>3.2  多系统和多部件支持</strong><br> MAVLink在同一链接上支持并行的多系统/飞行器。不仅如此，它同样还支持在同一飞行器上的多个支持MAVLink协议设备的情况。例如，协议允许自动驾驶设备和负载单元在一个电磁波链接上来沟通。因此，在不同的部件之间参数协议也是不同的。通过发送请求参数消息target_component从0开始进行计数（步进值设置：MAV_COMP_ID_ALL）来从系统获得完整的参数列表。所有的机载部件都应当以带有他们的ID或是MAV_COMP_ID_ALL(0)的ID对参数请求信息进行回应。QGroundControl默认查询系统的所有部件（它只查询当前选定的系统，并不是所有系统），因此发送ID 0/MAV_COMP_ID_ALL。<br><br><strong>3.3    QGroundControl里的图形用户界面</strong><br> 基于这个原因，参数接口将会辨别不同系统（一个系统就是一架飞机）和部件（一个部件就是一个实体的架构，例如：IMU或一个Linux进程）。这可以允许透明的访问每一个独立的部件参数而不再需要一个主要的机载单元来负责翻译对于机载部件的读/写参数请求。<br> 如下图所示，在参数树中每个部件被一个顶层节点代表。系统（即无人机）可以从顶层的下拉菜单中选择。GUI将会跟踪参数的改变并且将参数发送至正确的部件当中。<br> 为了方便多个参数的使用，树是根据第一下划线中的参数名称从顶层开始分组和构建的。所以PID_POS_X_P和PID_POS_Y_P将会被划分在在PID节点下。<br><br><strong>3.4  通信/状态机</strong><br> 机载参数被定义为一个14字符的字符串并存储了一个浮点值（IEEE 754 单精度，4字节）。此键值对有许多重要的属性：</p> 
<p>Ÿ  可读的变量名对于用户来说是非常有帮助的，但是它仍然足够小。</p> 
<p>Ÿ  GCS不需要提前知道机载部件的参数有哪些。</p> 
<p>Ÿ  确保支持未知的autopilots设备，只要他们执行协议内容。</p> 
<p>Ÿ  添加一个参数只会改变飞机上的代码。</p> 
<p></p> 
<p><strong>3.4.1读取参数</strong></p> 
<p style="margin-left:0px;">发送PARAM_REQUEST_LIST消息将激活读取参数列表的活动。飞机上的部件在收到这条指令后应当开始独立的传输参数。发送过程中在每个参数之后要适当的延迟，以免占用     <br> 全部的无线电带宽。</p> 
<p style="margin-left:0px;"></p> 
<p><strong>3.4.2读取单个参数</strong><br> 单个参数可以通过PARAM_REQUEST_READ消息来读取。<br><br><strong>3.4.3写参数</strong><br> 由于QGroundControl在初始状态时并没有自己的参数列表，在写参数列表之前参数列表首先要被读取一次。在那之后，参数才可以通过向部件发送键值对来被写入进去。由于QGroundControl会追踪参数的改变，电机写入按钮只会传输那些已经被更改的值。MAV<strong>必须确认这个写入的操作</strong>通过发送一个含有最新被写入进去的参数值的PARAM_VALUE的参数值消息。<br><br><br><strong>3.5  机上永久存储器</strong><br> 参数接口提供了两个按钮来将飞机上的参数从永久的机上存储器装载至RAM和将当前的参数值从RAM保存至永久存储器。若需要从QGroundControl向永久存储器写入数据，首先数据需要被传输然后必须执行写入到ROM的命令。<br><br><strong>3.6  QGroundControl的参数文档</strong><br> QGroundControl允许将当前飞机上的参数值保存至一个文本文档中。之后文档可以被再次的导入和传输到MAV中。这就可以允许如配置几个飞行器都是完全相似的默认安全值。<br><br><strong>3.7  MCU</strong><br> 这个单片机实现来自PIXHAWK IMU/Autopilot代码库。它允许贮存机上参数。请注意,这段代码可能没有编译,您首先需要调整你的板载数据结构。<br><br><strong>4  图像传输协议</strong><br> 本节讲述图像数据流是如何工作和如何囊括了包括实施细节（在MAV和QGroundControl）和MAV与QGroundControl之间的通讯。<br> 图像传输协议包含两个模块：图像流和视频流：<br>  </p> 
<p>Ÿ  <strong>图像流</strong></p> 
<p>部分使用MAVLink作为通讯频道，同时图像流部分能够被用来从MAV向QGroundControl传输任何类型的图像（原始图像、体感数据…）。它主要是获取相机的实时图像病将其分解为小块通过MAVLink来进行发送。该模块主要是用来直接向QGroundControl传输图像（即HUD不见如下所述）。</p> 
<p><strong>注意：</strong>该模块也可以用来向QGroundControl发送海量数据块而不是图像。<br>  </p> 
<p>Ÿ  <strong>视频流</strong></p> 
<p>部分以MPEG2的格式流式发送“真实（real）”的视频。它使用实时的照相机图像并使用FFMpeg来编码视频流。这个模块的主要应用情形是在任意的移动设备（笔记本电脑、只能手机、、、）上观看实时的视频传输而不需要使用QGroundControl和MAVLink的客户端。</p> 
<p>图像流部分相较于视频流部分的主要优点是更好的融入了QGroundControl。最主要的缺点是需要MAVLink的支持（因此不像视频流部分由较好的跨平台特性）。<br><strong>4.1  通讯</strong><strong>4.1.1 图像流</strong><br> 图像流部分使用了两个MAVLink消息：一个是握手消息，DATA_TRANSMISSION_HANDSHAKE来初始化、控制和停止图像流；还有一个数据容器消息，ENCAPSULATED_IMAGE，来传输图像数据（见右图）。<br> （1）       通讯是由QGroundControl发起开始数据流的请求而发起的。因此，若要开始通讯，MAVLink消息的如下字段必须被设置：<br> Ÿ   target：设置为目标MAV的ID;<br> Ÿ   state：设置为0；<br> Ÿ   id：表示图像流的ID；<br><strong>注意：</strong>目前，图像流部分只支持每个图像类型一个数据流，因此需要将id设置为和type字段想吐的整数。<br> Ÿ   type：在mavlink.h头文件中ENUM MAVLINK_DATA_STREAM_TYPES记录的任意类型。<br> Ÿ   freq：对于“frame per seconds”则大于0，“seconds per frame”则小于0。<br><br> 该协议允许请求一个特定图像的质量。如需要，则必须设置quality字段。在初始请求时所有其他的字段必须为0。<br> （2）       当目标MAV收到握手请求之后，它会回送一个确认消息并开始在请求的帧频上进行图像流传输。握手消息的ACK包通常情况下包含和由QGroundControl请求的消息相同的值（state设置为1，因为这是ACK消息），并增添有关下一个发送消息的大小的相关数据：<br> Ÿ   值packets包括MAVLink ENCAPSULATED_DATA包的数量；<br> Ÿ   值payload指定了每个数据包的有效载荷大小（通常为252字节）。<br> Ÿ   值size指定了图像的字节大小。</p> 
<p>（3）       之后，图像数据会被分割成适合正常的MAVLink消息的数据块。它们会被封装在ENCAPSULATED_DATA数据包中通过MAVLink进行发送。每个数据包包含一个序列号以及图像流对应的ID。然后，图像流就开始定期的发送新的图片，期间不再需要其他的交互。每一个新图像都有一个新的DATA_TRANSMISSION_HANDSHAKE的ACK包并更新图像的size，packets和payload值。在这个ACK包之后，新的图像作为一系列的ENCAPSULATED_DATA包而到达。<strong>注意：</strong>对于流中的每一个新图像，序列号都从0开始。</p> 
<p>（4）       要停止一个图像流，你必须要发送一个新的DATA_TRANSMISSION_HANDSHAKE请求包，并将频率设置为0。<br><br><strong>4.1.2 视频流</strong><br> 视频传输协议相较于图像传输协议简单许多：它只包含一个MAVLink消息，VIDEO_STREAM，用来开始和停止视频流（见下图）。</p> 
<p style="margin-left:0px;">     <br> 视频流消息有两个值需要设置：</p> 
<p>Ÿ   target：目标MAV；<br> Ÿ   start_stop：1为开始视频流，0为结束视频流。<br> 视频流由FFMpeg于MAV端创建并开始。一个小的MAVLink包抓取摄像机图像，添加(Y)UV渠道给YUV420 rawimage格式，并将该图片填制FFMpeg。之后，输出将被传输至地面站（<strong>注意：</strong>目前，这需要地面站有一个固定的IP并且在初始状态时有一个配置MAV的步骤）。收到视频后，QGroundControl打开VLC窗口对视频流进行重新分配：它从MAV得到这个视频流并将它作为RTP流（在一个多播地址）和HTTP流（直接单播流）提供给网络。这个过程并没有对原始流进行代码转换，以保持尽可能低的性能影响。<br> 现在其他的移动设备可以通过多播地址 239.255.12.45 来链接到这个视频流，或通过[url=http://[qgc-host]/MAVLive.mpg%E6%9D%A5%E9%93%BE%E6%8E%A5%E5%88%B0HTTP]http://[QGC-HOST]/MAVLive.mpg来链接到HTTP[/url]流。多播流通过SAP声明为”MAVLive”.<br><br><strong>4.2  使用/配置</strong><br> 在MAV上使用这两个模块，你需要做如下几步：<br><br><strong>4.2.1 图像流</strong><br> 1、为你的MAV编译mavconn中间件<br> 2、至少开启MAV上的这些设备：</p> 
<p style="margin-left:0px;">px_mavlink_bridge_udp&amp;</p> 
<p style="margin-left:0px;">px_system_control--heartbeat &amp;</p> 
<p style="margin-left:0px;">px_camera -o lcm&amp;</p> 
<p>3、编译并启动QGroundControl<br> 4、开启图像流设备（你可以添加-v标志来查看更多输出）：<br> px_imagestreamer<br> 5、初始化图像流: 打开HUD部件,到小部件上单击右键并选择“启用图像直播”。<br> 现在你可以观看每秒一个画面的视频了（默认，此处为硬编码）<br><br><strong>4.2.2 视频流</strong><br> 1、执行上文所述的图像流的1至3步；<br> 2、在主目录中创建一个符号链接：</p> 
<p style="margin-left:0px;">cd~                                                        </p> 
<p style="margin-left:0px;">ln-s mavconn/src/comm/video/px_videostreamer.sh px_videostreamer.sh</p> 
<p><br> （<strong>注意：</strong>你可以复制这个文件，但不建议这么做）；<br> 3、开启MAV上的视频流传输部件：<br> px_videostreamer<br><br> 4、初始化视频流：打开HUD插件，单击右键并选择“启用视频直播”。<br><br> 之后一个VLC窗口将开启。只要你想向其他人传输视频流，就请不要关闭这个窗口！如果你想观看当前的视频流，只需在其他的VLC窗口中打开这个视频流。<br><br><strong>4.2.3  Developer</strong><br> 目前，只实现了对当前摄像机的图像以JPEG格式进行图像流传输。要想实现自己的图像流传输，你必须做如下的事情：<br> Ÿ   编写一个MAVLink处理程序来处理您选定的格式的图片流开始传输的请求。<br> Ÿ   编写一个数据处理程序来处理你的数据（如，立体相机图像），将其编码为你选择的格式（如，原始图像、JPEG、BMP）然后将其分散并通过MAVLink进行传输。<br> Ÿ   扩展QGroundControl中UAS部件内的数据/消息处理程序来正确处理你的数据（如，对选定的格式进行拆包）。<br> Ÿ   编写或对原来的插件进行扩展来根据你的想法显示你的数据。</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0af0211e0978c5fc95312e867d1edb55/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">arcmap坐标系转换</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/19c731d9d569fc6863de6ab9ec136ca5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">FastDFS</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>