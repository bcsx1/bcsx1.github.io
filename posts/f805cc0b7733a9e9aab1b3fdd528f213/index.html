<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——线性结构（线性表） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构——线性结构（线性表）" />
<meta property="og:description" content="文章目录 一. 线性结构概述1. 线性结构（线性表的逻辑结构)的定义2. 线性表的特点 二. 线性结构分类1. 连续存储[顺序表](1). 什么叫数组(2). 顺序表算法的基本操作(3). 顺序表(物理结构) 2. 离散存储[链表](1). 定义1. 专业术语2. 确定一个链表需要几个参数3. 每一个链表节点的数据类型如何表示 (2). 分类1. 单链表2. 双链表3. 循环链表4. 静态链表 3. 顺序表和链表的比较(1). 顺序表1. 优点2. 缺点 (2). 链表1. 优点2. 缺点 三. 数据结构和算法1. 算法种类2. 什么是数据结构(1). 狭义(2). 广义 3. 什么算法(1). 狭义(2). 广义 4. 学习算法的方法 一. 线性结构概述 1. 线性结构（线性表的逻辑结构)的定义 定义：把所有的结点用一根直线穿起来详细定义：线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中n为表长，n=0是一个空表。用L表示线性表：L=(a1,a2,…,ai,ai&#43;1,…,an)。a1是唯一的第一个数据元素，又称表头元素；an是唯一的最后一个元素，又叫表尾元素。除了第一个元素之外，每个元素有且仅有一个直接前驱。除了最后一个元素外，每个元素有且仅有一个直接后继。
2. 线性表的特点 线性结构的特点：在数据元素的非空有限集中
1. 存在惟一的一个被称做“第一个”的数据元素 2. 存在惟一的一个被称做“最后一个”的数据元素 3. 除第一个之外，集合中的每个数据元素均只有一个前驱 4. 除最后一个之外，集合中每个数据元素均只有一个后继 线性表(linear_list)
定义：是n个数据元素的有限序列
特点：
线性表中的数据元素可以是各种各样的，但同一线性表中的元素必定具有相同特性，即属于同一数据对象（占有相同的大小） 相邻数据元素之间存在着序偶关系，元素有其先后次序 线性表的长度可以根据需要增长或缩短 抽象数据类型线性表的定义
线性结构/线性表是一种逻辑结构，而顺序存储/顺序表以及链式存储/链表则是一种存储结构
二. 线性结构分类 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/f805cc0b7733a9e9aab1b3fdd528f213/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-28T22:34:53+08:00" />
<meta property="article:modified_time" content="2022-07-28T22:34:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——线性结构（线性表）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#__1" rel="nofollow">一. 线性结构概述</a></li><li><ul><li><a href="#1__2" rel="nofollow">1. 线性结构（线性表的逻辑结构)的定义</a></li><li><a href="#2__9" rel="nofollow">2. 线性表的特点</a></li></ul> 
  </li><li><a href="#__32" rel="nofollow">二. 线性结构分类</a></li><li><ul><li><a href="#1__33" rel="nofollow">1. 连续存储[顺序表]</a></li><li><ul><li><a href="#1__37" rel="nofollow">(1). 什么叫数组</a></li><li><a href="#2__40" rel="nofollow">(2). 顺序表算法的基本操作</a></li><li><a href="#3__60" rel="nofollow">(3). 顺序表(物理结构)</a></li></ul> 
   </li><li><a href="#2__130" rel="nofollow">2. 离散存储[链表]</a></li><li><ul><li><a href="#1__131" rel="nofollow">(1). 定义</a></li><li><ul><li><a href="#1__137" rel="nofollow">1. 专业术语</a></li><li><a href="#2__150" rel="nofollow">2. 确定一个链表需要几个参数</a></li><li><a href="#3__155" rel="nofollow">3. 每一个链表节点的数据类型如何表示</a></li></ul> 
    </li><li><a href="#2__171" rel="nofollow">(2). 分类</a></li><li><ul><li><a href="#1__173" rel="nofollow">1. 单链表</a></li><li><a href="#2__260" rel="nofollow">2. 双链表</a></li><li><a href="#3__295" rel="nofollow">3. 循环链表</a></li><li><a href="#4__320" rel="nofollow">4. 静态链表</a></li></ul> 
   </li></ul> 
   </li><li><a href="#3__342" rel="nofollow">3. 顺序表和链表的比较</a></li><li><ul><li><a href="#1__345" rel="nofollow">(1). 顺序表</a></li><li><ul><li><a href="#1__346" rel="nofollow">1. 优点</a></li><li><a href="#2__351" rel="nofollow">2. 缺点</a></li></ul> 
    </li><li><a href="#2__356" rel="nofollow">(2). 链表</a></li><li><ul><li><a href="#1__357" rel="nofollow">1. 优点</a></li><li><a href="#2__360" rel="nofollow">2. 缺点</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#__366" rel="nofollow">三. 数据结构和算法</a></li><li><ul><li><a href="#1__367" rel="nofollow">1. 算法种类</a></li><li><a href="#2__377" rel="nofollow">2. 什么是数据结构</a></li><li><ul><li><a href="#1__378" rel="nofollow">(1). 狭义</a></li><li><a href="#2__386" rel="nofollow">(2). 广义</a></li></ul> 
   </li><li><a href="#3__389" rel="nofollow">3. 什么算法</a></li><li><ul><li><a href="#1__390" rel="nofollow">(1). 狭义</a></li><li><a href="#2__394" rel="nofollow">(2). 广义</a></li></ul> 
   </li><li><a href="#4__400" rel="nofollow">4. 学习算法的方法</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="__1"></a>一. 线性结构概述</h2> 
<h3><a id="1__2"></a>1. 线性结构（线性表的逻辑结构)的定义</h3> 
<ul><li>定义：把所有的结点用一根直线穿起来</li><li>详细定义：线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中n为表长，n=0是一个空表。</li><li>用L表示线性表：L=(a1,a2,…,ai,ai+1,…,an)。a1是唯一的第一个数据元素，又称表头元素；an是唯一的最后一个元素，又叫表尾元素。</li><li>除了第一个元素之外，每个元素有且仅有一个直接前驱。除了最后一个元素外，每个元素有且仅有一个直接后继。<br> <img src="https://images2.imgbox.com/3b/ff/UETJYKS3_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="2__9"></a>2. 线性表的特点</h3> 
<ul><li> <p>线性结构的特点：在数据元素的非空有限集中</p> <pre><code>  1. 存在惟一的一个被称做“第一个”的数据元素
  2. 存在惟一的一个被称做“最后一个”的数据元素
  3. 除第一个之外，集合中的每个数据元素均只有一个前驱
  4. 除最后一个之外，集合中每个数据元素均只有一个后继
</code></pre> </li><li> <p>线性表(linear_list)<br> 定义：是n个数据元素的有限序列</p> <p>特点：</p> <pre><code>线性表中的数据元素可以是各种各样的，但同一线性表中的元素必定具有相同特性，即属于同一数据对象（占有相同的大小）
相邻数据元素之间存在着序偶关系，元素有其先后次序
线性表的长度可以根据需要增长或缩短
</code></pre> </li><li> <p>抽象数据类型线性表的定义<br> <img src="https://images2.imgbox.com/00/0d/XfJpefbw_o.jpg" width="60%"><br> <img src="https://images2.imgbox.com/14/c0/9IzSxcRh_o.jpg" width="50%"></p> </li></ul> 
<p><font color="red">线性结构/线性表是一种逻辑结构，而顺序存储/顺序表以及链式存储/链表则是一种存储结构</font></p> 
<h2><a id="__32"></a>二. 线性结构分类</h2> 
<h3><a id="1__33"></a>1. 连续存储[顺序表]</h3> 
<p><font color="red">线性表的顺序存储结构是一种随机存取的存储结构。<br> 通常我们用高级设计语言中的数组来描述线性表的顺序结构<br> 所以下面我都是用C语言中的数组来表示线性结构中的顺序表</font></p> 
<h4><a id="1__37"></a>(1). 什么叫数组</h4> 
<p>元素类型相同，大小相同</p> 
<h4><a id="2__40"></a>(2). 顺序表算法的基本操作</h4> 
<p><a href="https://github.com/zhiqiang99/DataStructure/blob/master/Arr.cpp">顺序表算法代码https://github.com/zhiqiang99/DataStructure/blob/master/Arr.cpp</a></p> 
<p>注意以下几点：</p> 
<ul><li> <p>初始化动态分配数组<br> <img src="https://images2.imgbox.com/6a/b5/LQqusJrl_o.png" alt="在这里插入图片描述"></p> </li><li> <p>在合适位置插入元素<br> <img src="https://images2.imgbox.com/d2/6f/68zdksBc_o.png" alt="在这里插入图片描述"></p> </li><li> <p>在合适位置删除元素<br> <img src="https://images2.imgbox.com/bb/dd/r7hHkvdY_o.png" alt="在这里插入图片描述"></p> </li><li> <p>倒置元素的时候<br> 注意while循环里面的 i&lt;j，适用与个数为奇数和偶数的情况<br> 要熟记交换变量内容的三个语句：t = a; a = b; b = t;</p> </li><li> <p>排序元素<br> 没有固定方法，排序的十几种方法都可以使用</p> </li></ul> 
<h4><a id="3__60"></a>(3). 顺序表(物理结构)</h4> 
<ul><li> <p>定义：<br> 用一组地址连续的存储单元依次存储线性表的数据元素</p> </li><li> <p>特点：<br> <img src="https://images2.imgbox.com/a7/97/hYrTjtKj_o.png" alt="在这里插入图片描述"></p> </li><li> <p>顺序表表中元素的逻辑顺序与物理顺序相同</p> </li><li> <p>只要确定了存储线性表的起始位置，线性表中任一数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构</p> </li><li> <p>线性表的顺序存储结构示意图<br> <img src="https://images2.imgbox.com/8e/b5/TnZC3GAP_o.jpg" alt="在这里插入图片描述"></p> </li><li> <p>数组类型也有随机存取的特性，<font color="red">通常用数组来描述数据结构中的顺序存储结构</font></p> <pre><code>  线性表的长度可变，则在C语言中可用动态分配的一维数组
</code></pre> </li><li> <p>顺序表的优缺点<br> <strong>优点</strong>：<br> 顺序表存储结构容易实现随机存取线性表的第i个数据元素的操作<br> 无需为表示表中元素之间的逻辑关系而增加额外的存储空间</p> <p><strong>缺点</strong>：<br> 实现插入或删除操作时要移动大量数据元素<br> 当线性表长度变化较大时，难以确定存储空间的容量<br> 容易造成存储空间的碎片</p> </li><li> <p>顺序表的时间复杂度<br> 若表长为n，算法ListInsert_Sq和ListDelete_Sq的时间复杂度为O（n）<br> 求表长和取第i个数据元素的时间复杂度O（1）<br> 算法LocalElem_Sq的时间复杂度为O（L.length）</p> </li><li> <p>线性表的动态分配顺序存储结构<br> 静态分配数组大小和空间事前固定了，空间满了之后再添加就会溢出，一般我们都是采用动态分配</p> <pre><code class="prism language-c"><span class="token comment">//------线性表的动态分配顺序存储结构---------</span>
 
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LIST_INIT_SIZE</span> <span class="token expression"><span class="token number">100</span>	</span><span class="token comment">//线性表存储空间的初始分配了 </span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LISTINCREMENT</span> <span class="token expression"><span class="token number">10</span> 	</span><span class="token comment">//线性表存储空间的分配增量</span></span>
<span class="token keyword">struct</span> <span class="token class-name">Sqlist</span>
<span class="token punctuation">{<!-- --></span>
	ElemType <span class="token operator">*</span>elem<span class="token punctuation">;</span>		<span class="token comment">//存储空间基址	 </span>
	<span class="token keyword">int</span> length<span class="token punctuation">;</span>			<span class="token comment">//当前长度（数组有效元素个数） </span>
	<span class="token keyword">int</span> listsize<span class="token punctuation">;</span>		<span class="token comment">//当前分配的存储容量 （以sizeof(ElemType)为单位） </span>
	<span class="token keyword">int</span> incrementsize	<span class="token comment">//增补空间</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <p><img src="https://images2.imgbox.com/7a/b9/TZW4BZbG_o.png" alt="在这里插入图片描述"></p> </li><li> <p>检验顺序表中各个基本操作函数是否正确</p> <p><a href="https://github.com/zhiqiang99/DataStructure/blob/master/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%A3%80%E9%AA%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E5%90%84%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE.c">顺序表的操作，C语言详细代码：https://github.com/zhiqiang99/DataStructure/blob/master</a></p> </li></ul> 
<ol><li>图示：定义两个数据元素（2,6）、12个存储空间的顺序表<br> <img src="https://images2.imgbox.com/2b/a7/djDSzNkN_o.png" alt="在这里插入图片描述"></li><li>图示：初始化构造一个空的顺序线性表L<br> <img src="https://images2.imgbox.com/54/f4/VU1XUb4w_o.png" alt="在这里插入图片描述"></li><li>图示：销毁顺序线性表L<br> <img src="https://images2.imgbox.com/db/ac/rVvBgdM5_o.png" alt="在这里插入图片描述"></li><li>图示：在顺序表中插入元素<br> <img src="https://images2.imgbox.com/be/3a/ihR1ofes_o.png" alt="在这里插入图片描述"></li><li>图示：在顺序表中删除元素<br> <img src="https://images2.imgbox.com/50/67/dEL62dwI_o.png" alt="在这里插入图片描述"></li><li>图示：归并顺序表La和顺序表Lb得到一个新的顺序表Lc<br> <img src="https://images2.imgbox.com/37/f8/n5llkib5_o.png" alt="在这里插入图片描述"></li></ol> 
<ul><li> <p>顺序表的合并</p> <p><a href="https://github.com/zhiqiang99/DataStructure/blob/master/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6.c">顺序表的合并，C语言代码详解：https://github.com/zhiqiang99/DataStructure/blob/master</a></p> </li></ul> 
<h3><a id="2__130"></a>2. 离散存储[链表]</h3> 
<h4><a id="1__131"></a>(1). 定义</h4> 
<ul><li>n个节点离散分配</li><li>彼此通过指针相连</li><li>每个节点只有一个前驱节点，每个节点只有一个后续节点</li><li>首节点没有前驱节点，尾节点没有后续节点</li></ul> 
<h5><a id="1__137"></a>1. 专业术语</h5> 
<ul><li> <p>首节点：第一个有效节点</p> </li><li> <p>尾节点：最后一个有效节点</p> </li><li> <p><font color="red">头结点：第一个有效节点之前的那个节点</font></p> <pre><code>头节点并不存放有效节点
加一个没有实际含义的头结点的目的主要为了方便对链表的操作
头结点的数据类型和首节点类型一样
</code></pre> </li><li> <p>头指针：指向头结点的指针变量，指示链表中第一个节点的存储位置</p> </li><li> <p>尾指针：指向尾结点的指针变量</p> </li></ul> 
<p><img src="https://images2.imgbox.com/2e/bc/oQJHkFx3_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2__150"></a>2. 确定一个链表需要几个参数</h5> 
<p>如果希望通过一个函数来对链表进行处理，我们至少需要接受链表的哪些参数：</p> 
<ul><li><font color="red">只需要一个参数：头指针</font></li><li>因为我们通过头指针可以推出链表的其他所有信息</li></ul> 
<h5><a id="3__155"></a>3. 每一个链表节点的数据类型如何表示</h5> 
<p><img src="https://images2.imgbox.com/a0/35/GTfivvZ1_o.jpg" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c">每个节点数据类型：

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> data<span class="token punctuation">;</span>  <span class="token comment">//数据域</span>
	<span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span> pNext<span class="token punctuation">;</span> <span class="token comment">//指针域</span>
<span class="token punctuation">}</span>NODE<span class="token punctuation">,</span> <span class="token operator">*</span>PNODE

<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
NODE等价于<span class="token keyword">struct</span> <span class="token class-name">Node</span>类型
PNODE等价于<span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span> 类型
</code></pre> 
<h4><a id="2__171"></a>(2). 分类</h4> 
<p><img src="https://images2.imgbox.com/d0/9e/qVXZNxDU_o.jpg" alt="在这里插入图片描述"></p> 
<h5><a id="1__173"></a>1. 单链表</h5> 
<p>定义</p> 
<ul><li>通过一组任意的存储单元来存储线性表中的数据元素</li></ul> 
<p>单链表单个节点结构<br> <img src="https://images2.imgbox.com/f5/6f/pjNlGq5J_o.jpg" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> data<span class="token punctuation">;</span>  <span class="token comment">//数据域</span>
	<span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span> pNext<span class="token punctuation">;</span> <span class="token comment">//指针域</span>
<span class="token punctuation">}</span>NODE<span class="token punctuation">,</span> <span class="token operator">*</span>PNODE

NODE等价于<span class="token keyword">struct</span> <span class="token class-name">Node</span>类型
PNODE等价于<span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span> 类型
</code></pre> 
<p>优点：</p> 
<ul><li>不需要大量连续存储单元</li></ul> 
<p>缺点：</p> 
<ul><li>附加指针域，浪费空间</li><li>非随机存取的存储结构</li></ul> 
<p>带头结点的单链表<br> <img src="https://images2.imgbox.com/cc/07/dp8htq5e_o.jpg" alt="在这里插入图片描述"></p> 
<ul><li> <p>带头结点的好处</p> <pre><code>1. 第一个数据节点的操作和其他位置上操作相同，无需进行特殊处理
2. 无论链表是否为空，其头指针都指向头结点的非空指针
</code></pre> </li></ul> 
<p><font color="red"><strong>单链表上基本算法操作的实现：</strong><br> <a href="https://gitee.com/zhiqiang99/data-structure/blob/master/List/LinkList/list.cpp" rel="nofollow">https://gitee.com/zhiqiang99/data-structure/blob/master/List/LinkList/list.cpp</a></font></p> 
<ol><li> <p>采用头插法建立单链表<br> <img src="https://images2.imgbox.com/0b/4e/T3OG9GvJ_o.png" alt="在这里插入图片描述"></p> <pre><code class="prism language-cpp">核心代码<span class="token operator">:</span>

s<span class="token operator">-&gt;</span>next <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> <span class="token comment">//s指向结构体变量中的next这个成员（这个next成员为结构体型指针变量，它指向了头指针L所指向结构体变量中的next成员所指的结构体）</span>
<span class="token comment">//可以这么理解：s的next指向L的next所指的节点</span>
L<span class="token operator">-&gt;</span>next <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">//将新结点插入表中，L为头指针</span>
</code></pre> </li><li> <p>采用尾插法建立单链表</p> <p><img src="https://images2.imgbox.com/a8/2d/WDXSd48V_o.png" alt="在这里插入图片描述"></p> <pre><code class="prism language-cpp">核心代码：

r<span class="token operator">-&gt;</span>next<span class="token operator">=</span>s<span class="token punctuation">;</span>
r<span class="token operator">=</span>s<span class="token punctuation">;</span> <span class="token comment">//r指向新的表尾结点</span>
</code></pre> </li><li> <p>按序号查找结点值</p> </li><li> <p>按值查找表结点</p> </li><li> <p>插入结点操作<br> <img src="https://images2.imgbox.com/ea/43/zIY5ihKv_o.png" alt="在这里插入图片描述"></p> <pre><code class="prism language-cpp">核心代码：

p<span class="token operator">=</span><span class="token function">GetElem</span> <span class="token punctuation">(</span>L<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">//査找插入位置的前驱结点</span>
s<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> 	<span class="token comment">//图 2.7中操作步骤 1</span>
p<span class="token operator">-&gt;</span>next<span class="token operator">=</span>s<span class="token punctuation">;</span> 			<span class="token comment">//图 2.7中操作步骤2</span>
</code></pre> </li><li> <p>删除结点操作<br> <img src="https://images2.imgbox.com/37/e6/eXlDIAkz_o.png" alt="在这里插入图片描述"></p> <pre><code class="prism language-cpp">核心代码：

p<span class="token operator">=</span><span class="token function">GetElem</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//查找删除位置的前驱结点</span>
q<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>		<span class="token comment">//令q指向被删除结点    =:表示指向的意思，指向的是这个节点的整体</span>
p<span class="token operator">-&gt;</span>next<span class="token operator">=</span>q<span class="token operator">-&gt;</span>next	<span class="token comment">//将*q结点从链中“断开”</span>
<span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//释放结点的存储空间①</span>
</code></pre> </li><li> <p>求表长操作</p> </li></ol> 
<h5><a id="2__260"></a>2. 双链表</h5> 
<p>定义</p> 
<ul><li> <p>每个节点都有两个指针域，分别指向其前驱节点和后继节点<br> <img src="https://images2.imgbox.com/64/ca/g48uzdtP_o.jpg" alt="在这里插入图片描述"></p> </li><li> <p>与单链表的算法区别</p> <pre><code>  按值查找和按位查找与单链表相同
  插入和删除操作不同
</code></pre> </li></ul> 
<p><font color="red"><strong>双链表上基本算法操作的实现</strong><br> <a href="https://" rel="nofollow">加代码</a></font></p> 
<ol><li> <p>双链表的插入操作<br> <img src="https://images2.imgbox.com/51/23/BwpdfWMR_o.png" alt="在这里插入图片描述"></p> <pre><code class="prism language-cpp">核心代码：语句不唯一，<span class="token number">1</span>、<span class="token number">2</span>必须在<span class="token number">4</span>之前

s<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> <span class="token comment">//将结点*s插入到结点*p之后</span>
p<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>s<span class="token punctuation">;</span>
s<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>p<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>next<span class="token operator">=</span>s<span class="token punctuation">;</span>
</code></pre> </li><li> <p>双链表的删徐操作<br> <img src="https://images2.imgbox.com/c5/7f/oyiganqw_o.png" alt="在这里插入图片描述"></p> <pre><code class="prism language-cpp">核心代码：

p<span class="token operator">-&gt;</span>next<span class="token operator">=</span>q<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
q<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>p<span class="token punctuation">;</span>
<span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//释放结点空间</span>
</code></pre> </li></ol> 
<h5><a id="3__295"></a>3. 循环链表</h5> 
<p>能通过任何一个节点找到其他所有的节点</p> 
<p><img src="https://images2.imgbox.com/75/38/PAZOSKP0_o.jpg" alt="在这里插入图片描述"><br> 循环单链表的定义</p> 
<ul><li>尾节点的指针域next指向头结点的单链表，形成一个环，即表中没有指针域为null的节点</li></ul> 
<p><img src="https://images2.imgbox.com/16/01/cVaB9zTW_o.jpg" alt="在这里插入图片描述"></p> 
<p>循环单链表的算法操作</p> 
<ul><li> <p>判断是否为空</p> <pre><code>  看头结点的指针是否指向它本身
</code></pre> </li><li> <p>判断动态指针是否达到表尾节点</p> <pre><code>  看p－&gt;next是否指向其表头节点
</code></pre> </li></ul> 
<p><a href="https://" rel="nofollow">加代码</a></p> 
<p>循环双链表定义</p> 
<ul><li>尾节点的指针域next指向头结点，且头结点的指针域prior指向尾节点的双链表</li></ul> 
<p><img src="https://images2.imgbox.com/8e/1a/lmrGREMg_o.jpg" alt="在这里插入图片描述"><br> 循环双链表的算法操作<br> <a href="https://" rel="nofollow">加代码</a></p> 
<h5><a id="4__320"></a>4. 静态链表</h5> 
<p>定义</p> 
<ul><li>借助数组来描述线性表的链式存储结构，节点也有数据域和指针域，但这里指针是节点的相对地址（数组下标），且也要预先分配一块连续的内存空间</li></ul> 
<p><img src="https://images2.imgbox.com/a0/d0/leHADsoo_o.jpg" alt="在这里插入图片描述"><br> 静态链表数据结构的描述</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">50</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>
	ElemType data<span class="token punctuation">;</span>
	<span class="token keyword">int</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>SLinkList<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> 
<p>静态链表的优缺点：</p> 
<ul><li>优点：线性表的插入和删除不需要移动元素，仅修改指针</li><li>缺点：需预先分配一个较大的空间，进行空间扩充比较困难</li></ul> 
<p>静态链表的算法操作<br> <a href="https://" rel="nofollow">加代码</a></p> 
<h3><a id="3__342"></a>3. 顺序表和链表的比较</h3> 
<p><img src="https://images2.imgbox.com/b5/ba/Pl0kLPdr_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1__345"></a>(1). 顺序表</h4> 
<h5><a id="1__346"></a>1. 优点</h5> 
<ul><li> <p>可以随机存取，存取速度很快</p> </li><li> <p>存储密度＝1</p> <pre><code>  存储密度＝（节点数据本身所占的存储量）/（节点结构所占的存储总量）
</code></pre> </li></ul> 
<h5><a id="2__351"></a>2. 缺点</h5> 
<ul><li>插入删除需要移动大量元素很慢</li><li>事先必须知道长度</li><li>存储空间不便于扩充</li></ul> 
<h4><a id="2__356"></a>(2). 链表</h4> 
<h5><a id="1__357"></a>1. 优点</h5> 
<ul><li>空间没有限制</li><li>插入删除元素很快</li></ul> 
<h5><a id="2__360"></a>2. 缺点</h5> 
<ul><li>只能顺序存取，存取速度很慢</li><li>需要额外空间（指针域）来表示数据元素之间的逻辑结构</li><li>存储密度&lt;1</li></ul> 
<h2><a id="__366"></a>三. 数据结构和算法</h2> 
<h3><a id="1__367"></a>1. 算法种类</h3> 
<ul><li>遍历</li><li>查找</li><li>清空</li><li>销毁</li><li>求长度</li><li>排序</li><li>删除节点</li><li>插入节点</li></ul> 
<h3><a id="2__377"></a>2. 什么是数据结构</h3> 
<h4><a id="1__378"></a>(1). 狭义</h4> 
<p><font color="blue">数据结构是专门研究数据存储的问题</font></p> 
<p><font color="blue">数据结构包含两个方面：个体的存储+个体关系的存储</font></p> 
<ul><li>从某种角度而言：数据的存储最核心的就是个体关系的存储，个体的存储可以忽略不计</li></ul> 
<h4><a id="2__386"></a>(2). 广义</h4> 
<p><font color="blue">数据结构既包含数据的存储也包含数据的操作</font></p> 
<h3><a id="3__389"></a>3. 什么算法</h3> 
<h4><a id="1__390"></a>(1). 狭义</h4> 
<ul><li>算法是对存储数据的操作</li><li>算法和数据的存储方式密切相关</li></ul> 
<h4><a id="2__394"></a>(2). 广义</h4> 
<p>算法和数据存储方式无关<br> <font color="red">这就是泛型</font></p> 
<ul><li><font color="red">泛型就是利用某种技术达到的效果就是i：不同的存储方式，执行的操作是一样的</font></li><li><font color="red">再次讨论到底什么是泛型：同一逻辑结构，无论该逻辑结构物理存储是什么样子的，我们可以对它执行相同的操作</font></li></ul> 
<h3><a id="4__400"></a>4. 学习算法的方法</h3> 
<p>理解底层数学逻辑</p> 
<p>怎么理解？</p> 
<ul><li>抓住流程</li><li>理解每个语句功能</li><li>试数</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/79e997faff1b182544f980300f9558e4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网络运维系列：GoDaddy Shell DDNS配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/14551ab4b45ebe171b26f73cd329753d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python程序化生成三维场景【PyPRT】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>