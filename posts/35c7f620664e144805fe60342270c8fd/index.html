<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>用React&#43;Antd写一个后台小项目 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="用React&#43;Antd写一个后台小项目" />
<meta property="og:description" content="安装React脚手架不多说了,上一个代码:
npx create-react-app my-app 一.使用SCSS预处理器
装包:yarn add sass -D 需要安装,react中内置了SASS的配置,所以装包就行,生产环境不需要这个包,加-D;
创建全局样式文件:index.scss
body{ margin: 0; } #root{ height: 100%; } 二.配置基础路由
安装路由:react-router-dom;
pages下创建layout和login两个文件夹
App.js中代码:
import React from &#39;react&#39; import { BrowserRouter, Routes, Route } from &#39;react-router-dom&#39; import Layout from &#39;./pages/Layout&#39; import Login from &#39;./pages/Login&#39; export default function App() { return ( //配置路由 &lt;BrowserRouter&gt; &lt;div&gt; &lt;Routes&gt; {/* 创建路由path和对应组件关系 */} &lt;Route path=&#39;/&#39; element={&lt;Layout/&gt;}&gt;&lt;/Route&gt; &lt;Route path=&#39;/login&#39; element={&lt;Login/&gt;}&gt;&lt;/Route&gt; &lt;/Routes&gt; &lt;/div&gt; &lt;/BrowserRouter&gt; ) } 三.antd组件库的使用" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/35c7f620664e144805fe60342270c8fd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-23T14:54:23+08:00" />
<meta property="article:modified_time" content="2023-11-23T14:54:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">用React&#43;Antd写一个后台小项目</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <p>安装React脚手架不多说了,上一个代码:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">npx create-react-app my-app</code></code></pre> 
 <p><strong>一.使用SCSS预处理器</strong></p> 
 <ol><li style="margin-left:1.4em;"> <p>装包:yarn add sass -D 需要安装,react中内置了SASS的配置,所以装包就行,生产环境不需要这个包,加-D;</p> </li></ol> 
 <ol><li style="margin-left:1.4em;"> <p>创建全局样式文件:index.scss</p> </li></ol> 
 <pre><code class="language-plain">
<code class="language-plaintext">body{
    margin: 0;
}
#root{
    height: 100%;
}</code></code></pre> 
 <p>二.<strong>配置基础路由</strong></p> 
 <ol><li style="margin-left:1.4em;"> <p>安装路由:react-router-dom;</p> </li></ol> 
 <ol><li style="margin-left:1.4em;"> <p>pages下创建layout和login两个文件夹</p> </li></ol> 
 <p>App.js中代码:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import React from 'react'
import { BrowserRouter, Routes, Route } from 'react-router-dom'
import Layout from './pages/Layout'
import Login from './pages/Login'
export default function App() {
  return (
    //配置路由
    &lt;BrowserRouter&gt;
      &lt;div&gt;
        &lt;Routes&gt;
          {/* 创建路由path和对应组件关系 */}
          &lt;Route path='/' element={&lt;Layout/&gt;}&gt;&lt;/Route&gt;
          &lt;Route path='/login' element={&lt;Login/&gt;}&gt;&lt;/Route&gt;
          
      &lt;/Routes&gt;
    &lt;/div&gt;
    &lt;/BrowserRouter&gt;

  )
}

</code></code></pre> 
 <p>三.<strong>antd组件库的使用</strong></p> 
 <pre><code class="language-plain">
<code class="language-plaintext">npm i antd -S</code></code></pre> 
 <p>导入antd样式文件</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import 'antd/dist/antd.min.css'</code></code></pre> 
 <h3 style="text-align:left;"><strong>四.配置别名路径(不做了,我的报错)</strong></h3> 
 <ol><li style="margin-left:1.4em;"> <p>用@代替根路径src</p> </li></ol> 
 <ol><li style="margin-left:1.4em;"> <p>.安装修改CRA配置的包:yarn add -D @craco/craco;</p> </li></ol> 
 <ol><li style="margin-left:1.4em;"> <p>项目根目录下创建文件 craco.config.js</p> </li></ol> 
 <pre><code class="language-plain">
<code class="language-plaintext">//添加自定义对于webpack的配置
const path = require('path')
module.exports = {
    //webpack配置
    webpack: {
        //配置别名
        alias: {
            //约定:使用@表示src文件所在路径
            '@':path.resolve(__dirname,'src')
        }
    }
}</code></code></pre> 
 <p>package.json</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">//将 start/build/test 三个命令改为craco方式
 "scripts": {
    "start": "craco start",
    "build": "craco build",
    "test": "craco test",
    "eject": "react-scripts eject"
  },</code></code></pre> 
 <p>五.<strong>@别名路径提示</strong></p> 
 <p>在根目录下创建jsconfig.json配置文件</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">{
    "compilerOptions":{
        "baseUrl":"./",
        "paths":{
            "@/*":["src/*"]
        }
    }
}</code></code></pre> 
 <p>六.<strong>登录模块</strong></p> 
 <p>(1)登录表单: pages/Login/index.js:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { Card } from 'antd'
import logo from '../../assets/images/logo.png'
import './index.scss'//导入样式文件
export default function Login() {
    return (
        &lt;div className="login"&gt;
            &lt;Card className="login-container"&gt;
                &lt;img className="login-logo" src={logo} alt="" /&gt;
                {/* 登录表单 */}
                
          &lt;/Card&gt;
        &lt;/div&gt;
    )
}</code></code></pre> 
 <p>样式文件index.scss</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">.login {
    width: 100%;
    height: 100%;
    position: absolute;
    left: 0;
    top: 0;
    background: center/cover url('../../assets/images/login.png');
  
    .login-logo {
      width: 200px;
      height: 60px;
      display: block;
      margin: 0 auto 20px;
    }
  
    .login-container {
      width: 440px;
      height: 360px;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 50px rgba(0, 0, 0, 0.1);
    }
  
    .login-checkbox-label {
      color: #1890ff;
    }
  }
  </code></code></pre> 
 <p>(2)<strong>创建表单结构+添加校验功能</strong></p> 
 <p>为Form.Item添加rules属性,用来添加表单校验.</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { Card, Form, Input, Checkbox, Button,message } from 'antd'
import logo from '../../assets/images/logo.png'
import './index.scss'//导入样式文件
export default function Login() {
    return (
        &lt;div className="login"&gt;
            &lt;Card className="login-container"&gt;
                &lt;img className="login-logo" src={logo} alt="" /&gt;
                {/* 登录表单 */}
                {/* 子项用到的触发事件 需要在Form中都声明一下才可以 */}
                &lt;Form
                    validateTrigger={['onBlur', 'onChange']}
                    initialValues={<!-- -->{
                        remember: true,
                        mobile: '13811111111',
                        code: '246810'
                    }}

                &gt;
                    &lt;Form.Item
                        name="mobile"
                        rules={[
                            {
                                required: true,
                                message: '请输入手机号',
                            },
                            {
                                pattern: /^1[3-9]\d{9}$/,
                                message: '请输入正确的手机号',
                                validateTrigger: 'onBlur'//失焦时触发
                            }
                        ]}
                    &gt;
                        &lt;Input size="large" placeholder="请输入手机号" /&gt;
                    &lt;/Form.Item&gt;
                    &lt;Form.Item
                        name="code"
                        rules={[
                            {
                                required: true,
                                message: '请输入密码',
                            },
                            {
                                len: 6,
                                message: '请输入6位密码',
                                validateTrigger: 'onBlur'
                            }
                        ]}
                    &gt;
                        &lt;Input size="large" placeholder="请输入验证码" /&gt;
                    &lt;/Form.Item&gt;
                    &lt;Form.Item
                        name="remember"
                        valuePropName="checked"

                    &gt;
                        &lt;Checkbox className="login-checkbox-label"&gt;
                            我已阅读并同意「用户协议」和「隐私条款」
            &lt;/Checkbox&gt;
                    &lt;/Form.Item&gt;

                    &lt;Form.Item&gt;
                        &lt;Button type="primary" htmlType="submit" size="large" block&gt;
                            登录
            &lt;/Button&gt;
                    &lt;/Form.Item&gt;
                &lt;/Form&gt;

            &lt;/Card&gt;
        &lt;/div&gt;
    )
}</code></code></pre> 
 <p>(3)<strong>获取登录表单数据</strong></p> 
 <p>1.为Form组件添加onFinish属性,该事件会在点击登录按钮时触发;</p> 
 <p>2.创建onFinish函数,通过函数参数values拿到表单值,</p> 
 <ol><li style="margin-left:1.4em;"> <p>Form组件添加initialValues属性,来初始化表单值.</p> </li></ol> 
 <pre><code class="language-plain">
<code class="language-plaintext">     function onFinish(values) {
        //values:放置的是所有表单项中用户输入的内容
        console.log(values);
    }
   &lt;Form
                    validateTrigger={['onBlur', 'onChange']}
                    initialValues={<!-- -->{
                        remember: true,
                        mobile: '13811111111',
                        code: '246810'
                    }}
                    onFinish={onFinish}
                    onFinishFailed={onFinishFailed} //失败时的提示,不常用

                &gt;
                  &lt;/Form&gt;</code></code></pre> 
 <p>(4)<strong>登录axios统一封装处理</strong></p> 
 <pre><code class="language-plain">
<code class="language-plaintext">npm i axios -S</code></code></pre> 
 <p>1.创建utils/http.js文件;</p> 
 <p>2.创建axios实例,配置baseURL,请求拦截器,响应拦截器;</p> 
 <p>在utils/http.js中,统一导出http.</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">// 封装axios
// 实例化  请求拦截器 响应拦截器

import axios from 'axios'
const http = axios.create({
    baseURL: 'http://geek.itheima.net/v1_0',
    timeout: 5000
})
// 添加请求拦截器
http.interceptors.request.use((config) =&gt; {
    return config
}, (error) =&gt; {
    return Promise.reject(error)
})
// 添加响应拦截器
http.interceptors.response.use((response) =&gt; {
    // 2xx 范围内的状态码都会触发该函数。
    // 对响应数据做点什么
    return response
}, (error) =&gt; {
    // 超出 2xx 范围的状态码都会触发该函数。
    // 对响应错误做点什么
    console.dir(error)

    return Promise.reject(error)
})
export { http }</code></code></pre> 
 <p>(5)配置登录Mobx</p> 
 <p>Mobx类似redux和vuex.</p> 
 <p>装包:yarn add mobx mobx-react-lite,管理用户登录的store</p> 
 <p>store/login.Store.js中:(接口应该是有错了,报400错误)</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">// login 模块
import { makeAutoObservable } from 'mobx'
import { http } from '../utils'
class LoginStore {
    token = ''
    constructor() {
        //响应式
        makeAutoObservable(this)
    }
    getToken = async ({ mobile, code }) =&gt; {
        //调用登录接口
        const res = await http.post('http://geek.itheima.net/v1_0/authorizations', {
            mobile, code
        })
        //存入token
        this.token = res.data.token
        
    }
}
export default LoginStore</code></code></pre> 
 <p>store/index.js中,管理所有的模块</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">// 把所有的模块做统一处理
// 导出一个统一的方法 useStore
import React from "react"
import LoginStore from './login.Store'
class RootStore{
    constructor() {
        this.loginStore = new LoginStore()
    }
}


// 实例化根
// 导出useStore context
const rootStore = new RootStore()
const context = React.createContext(rootStore)
const useStore = () =&gt; React.useContext(context)

export { useStore }</code></code></pre> 
 <p>(6)<strong>token持久化</strong></p> 
 <p>1.封装工具函数</p> 
 <p>创建utils/token.js</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">// 封装ls存取token

const key = 'pc-key'

const setToken = (token) =&gt; {
  return window.localStorage.setItem(key, token)
}

const getToken = () =&gt; {
  return window.localStorage.getItem(key)
}

const removeToken = () =&gt; {
  return window.localStorage.removeItem(key)
}

export {
  setToken,
  getToken,
  removeToken
}</code></code></pre> 
 <p>在utils/index.js统一封装的工具函数中:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">// 先把所有的工具函数导出的模块在这里导入
// 然后再统一导出
import { http } from './http'
import {
  setToken,
  getToken,
  removeToken
} from './token'




export {
  http,
  setToken,
  getToken,
  removeToken
}
</code></code></pre> 
 <p>在store/login.Store.js中新增下列代码:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { setToken,getToken} from '../utils'

  token =getToken() || ''//取的时候优先从本地拿token
  setToken(this.token)//往本地存一份</code></code></pre> 
 <p>(7)<strong>请求拦截器注入token</strong></p> 
 <p>在utils/http.js中新增下列代码</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import {getToken} from './token'//新增
// 添加请求拦截器
http.interceptors.request.use((config) =&gt; {
    const token = getToken()//新增
    if (token) {                    //新增
        config.headers.Authorization = `Bearer ${token}`
    }
    return config
}, (error) =&gt; {
    return Promise.reject(error)
})</code></code></pre> 
 <p>(8)<strong>路由鉴权实现</strong></p> 
 <p>思路:自己封装AuthRoute路由鉴权高阶组件,实现未登陆拦截,并返回到登录页面.</p> 
 <p>判断本地是否有token,有的话,就返回子组件,否则就重定向到登录Login.</p> 
 <p>components/AuthComponent.js中:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">// 1. 判断token是否存在
// 2. 如果存在 直接正常渲染
// 3. 如果不存在 重定向到登录路由

// 高阶组件:把一个组件当成另外一个组件的参数传入
// 然后通过一定的判断 返回新的组件
import { getToken } from '../utils'
import { Navigate } from 'react-router-dom'
function AuthComponent({ children }) {
    const isToken = getToken()
    if (isToken) {
        return &lt;&gt;{children}&lt;/&gt;
    } else {
        return &lt;Navigate to='/login' replace&gt;&lt;/Navigate&gt;
    }
}
// &lt;AuthComponent&gt; &lt;Layout/&gt; &lt;/AuthComponent&gt;
// 登录：&lt;&gt;&lt;Layout/&gt;&lt;/&gt;--登录就渲染对应的组件
// 非登录：&lt;Navigate to="/login" replace /&gt;

export {
    AuthComponent
}</code></code></pre> 
 <p>在App.js中:(接口有误,我自己项目就不添加这步了)</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { AuthComponent } from './components/AuthComponent'
  &lt;Routes&gt;

                    {/* 创建路由path和对应组件关系 */}
                    {/* Layout需要鉴权处理的 */}
                    {/* 这里的Layout一定不能写死 要根据是否登录进行判断 */}
                    &lt;Route path='/' element={
                        &lt;AuthComponent&gt;//包裹一下
                            &lt;Layout /&gt;
                        &lt;/AuthComponent&gt;

                    }&gt;&lt;/Route&gt;
                        {/* 这个不需要,登录页嘛 */}
                    &lt;Route path='/login' element={&lt;Login /&gt;}&gt;&lt;/Route&gt;

                &lt;/Routes&gt;</code></code></pre> 
 <p>看下登录页面的效果静态图:</p> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/ee/78/7USxr5OR_o.png" width="1200"> 
   </div> 
  </div> 
 </div> 
 <p></p> 
 <p>五.<strong>layout模块</strong></p> 
 <p>看下要实现的效果图:</p> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/ea/33/CsdZo2vp_o.png" width="247"> 
   </div> 
  </div> 
 </div> 
 <p></p> 
 <p>(1)<strong>解决layout首页显示高度的问题</strong></p> 
 <p>App.scss中:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">.App{
    height: 100vh;
}</code></code></pre> 
 <p>Layout/index.js结构:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { Layout, Menu, Popconfirm } from 'antd'
import { Outlet, Link } from 'react-router-dom'

import {
  HomeOutlined,
  DiffOutlined,
  EditOutlined,
  LogoutOutlined
} from '@ant-design/icons'
import './index.scss'

const { Header, Sider } = Layout

const GeekLayout = () =&gt; {
 
  return (
    &lt;Layout&gt;
      &lt;Header className="header"&gt;
        &lt;div className="logo" /&gt;
        &lt;div className="user-info"&gt;
          &lt;span className="user-name"&gt;用户名&lt;/span&gt;
          &lt;span className="user-logout"&gt;
            &lt;Popconfirm
             
              title="是否确认退出？" okText="退出" cancelText="取消"&gt;
             &lt; LogoutOutlined/&gt; 退出
            &lt;/Popconfirm&gt;
          &lt;/span&gt;
        &lt;/div&gt;
      &lt;/Header&gt;
      &lt;Layout&gt;
        &lt;Sider width={200} className="site-layout-background"&gt;
          {/* 高亮原理：defaultSelectedKeys === item key */}
          {/* 获取当前激活的path路径？ */}
          {/* 
             defaultSelectedKeys: 初始化渲染的时候生效一次
             selectedKeys: 每次有值更新时都会重新渲染视图
          */}
          &lt;Menu
            mode="inline"
            theme="dark"
           
           
            style={<!-- -->{ height: '100%', borderRight: 0 }}
          &gt;
            &lt;Menu.Item icon={&lt;HomeOutlined /&gt;} key="/"&gt;
              &lt;Link to='/'&gt;数据概览&lt;/Link&gt;
            &lt;/Menu.Item&gt;
            &lt;Menu.Item icon={&lt;DiffOutlined /&gt;} key="/article"&gt;
              &lt;Link to="/article"&gt;内容管理&lt;/Link&gt;
            &lt;/Menu.Item&gt;
            &lt;Menu.Item icon={&lt;EditOutlined /&gt;} key="/publish"&gt;
              &lt;Link to='/publish'&gt; 发布文章&lt;/Link&gt;
            &lt;/Menu.Item&gt;
          &lt;/Menu&gt;
        &lt;/Sider&gt;
        &lt;Layout className="layout-content" style={<!-- -->{ padding: 20 }}&gt;
          {/* 二级路由出口 */}
          &lt;Outlet /&gt;
        &lt;/Layout&gt;
      &lt;/Layout&gt;
    &lt;/Layout&gt;
  )
}

export default GeekLayout</code></code></pre> 
 <p>样式index.scss</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">.ant-layout {
    height: 100%;
  }
  
  .header {
    padding: 0;
  }
  
  .logo {
    width: 200px;
    height: 60px;
    background: url('../../assets//images/logo.png') no-repeat center / 160px auto;
  }
  
  .layout-content {
    overflow-y: auto;
  }
  
  .user-info {
    position: absolute;
    right: 0;
    top: 0;
    padding-right: 20px;
    color: #fff;
  
    .user-name {
      margin-right: 20px;
    }
  
    .user-logout {
      display: inline-block;
      cursor: pointer;
    }
  }
  .ant-layout-header {
    padding: 0 !important;
  }
  </code></code></pre> 
 <p>(2)<strong>二级路由跳转</strong></p> 
 <p>新建Home,Article和Publish三个文件</p> 
 <p>在App.js中引入,并注册二级路由,默认展示Home页:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import Article from './pages/Article'
import Home from './pages/Home'
import Publish from './pages/Publish'

 &lt;Route path='/' element={&lt;Layout /&gt;}&gt;
             &lt;Route index element={&lt;Home/&gt;}&gt;&lt;/Route&gt;
               &lt;Route path='article' element={&lt;Article/&gt;}&gt;&lt;/Route&gt;
                 &lt;Route path='publish' element={&lt;Publish/&gt;}&gt;&lt;/Route&gt;
   &lt;/Route&gt;</code></code></pre> 
 <p>此处注意,必须要在Layout/index.js中,Link可以实现跳转到响应的页面</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { Outlet} from 'react-router-dom'//这是出口,不写的话页面什么也没有</code></code></pre> 
 <p>(3)<strong>路由跳转配置</strong></p> 
 <p>Layout/index.js中</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { Link } from 'react-router-dom'

            &lt;Menu.Item icon={&lt;HomeOutlined /&gt;} key="/"&gt;
              &lt;Link to='/'&gt;数据概览&lt;/Link&gt;
            &lt;/Menu.Item&gt;
            &lt;Menu.Item icon={&lt;DiffOutlined /&gt;} key="/article"&gt;
              &lt;Link to="/article"&gt;内容管理&lt;/Link&gt;
            &lt;/Menu.Item&gt;
            &lt;Menu.Item icon={&lt;EditOutlined /&gt;} key="/publish"&gt;
              &lt;Link to='/publish'&gt; 发布文章&lt;/Link&gt;
            &lt;/Menu.Item&gt;
          &lt;/Menu&gt;</code></code></pre> 
 <p>(4)<strong>菜单反向高亮</strong></p> 
 <p>Layout/index.js中</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { useLocation } from 'react-router-dom'

 const {pathname} = useLocation()//解构一下
  {/* 高亮原理：defaultSelectedKeys === item key */}
          {/* 获取当前激活的path路径？ */}
          {/* 
             defaultSelectedKeys: 初始化渲染的时候生效一次
             selectedKeys: 每次有值更新时都会重新渲染视图
      */}
      
        &lt;Menu
            mode="inline"
            theme="dark"
           defaultSelectedKeys={[pathname]} //这里是
           
            style={<!-- -->{ height: '100%', borderRight: 0 }}
          &gt;
            &lt;Menu.Item icon={&lt;HomeOutlined /&gt;} key="/"&gt;//每个key也是
              &lt;Link to='/'&gt;数据概览&lt;/Link&gt;
            &lt;/Menu.Item&gt;
            &lt;Menu.Item icon={&lt;DiffOutlined /&gt;} key="/article"&gt;//每个key也是
              &lt;Link to="/article"&gt;内容管理&lt;/Link&gt;
            &lt;/Menu.Item&gt;
            &lt;Menu.Item icon={&lt;EditOutlined /&gt;} key="/publish"&gt;//每个key也是
              &lt;Link to='/publish'&gt; 发布文章&lt;/Link&gt;
            &lt;/Menu.Item&gt;
          &lt;/Menu&gt;
</code></code></pre> 
 <p>(5)<strong>展示用户信息</strong></p> 
 <p>store/user.Store.js中:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { makeAutoObservable } from 'mobx'
import {http} from '../utils'
class UserStore{
    userInfo = {}
    constructor() {
        makeAutoObservable(this)
    }
    getUserInfo =async () =&gt; {
        //调用接口
        const res = await http.get('/user/profile')
        this.userInfo=res.data
    }
}
export default UserStore</code></code></pre> 
 <p>store/index.js中:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import UserStore from './user.Store'</code></code></pre> 
 <pre><code class="language-plain">
<code class="language-plaintext">Layout/index.js中:</code></code></pre> 
 <pre><code class="language-plain">
<code class="language-plaintext">import {observer} from 'mobx-react-lite' //引入中间件
import {useStore} from '../../store'
import { useEffect } from 'react'
+  const {userStore}=useStore()
+ useEffect(() =&gt; {
    userStore.getUserInfo()
  },[userStore])//填入userStore仅仅是让他不提醒没有使用
  
    &lt;span className="user-name"&gt;用户名&lt;/span&gt;//正常这里的用户名是{<!-- -->{userStore.userInfo.name}}
    +export default observer(GeekLayout) //observer解决用户名一刷新就丢失的问题</code></code></pre> 
 <p>(6)<strong>退出登录模块</strong></p> 
 <p>store/login.Store.js中:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { http ,setToken,getToken,+removeToken} from '../utils'
+ loginOut = () =&gt; {
        this.token = ''
        removeToken()
    }
   </code></code></pre> 
 <p>Layout/index.js中:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { Outlet, Link, useLocation, +useNavigate } from 'react-router-dom'

 //点击退出的回调
  const navigate = useNavigate()
  const onConfirm = () =&gt; {
    //退出登录 清空token 返回登录页
    loginStore.loginOut()
    navigate('/login')
  }
  
    &lt;Popconfirm
             + onConfirm={onConfirm}
              title="是否确认退出？" okText="退出" cancelText="取消"&gt;
              &lt; LogoutOutlined /&gt; 退出
            &lt;/Popconfirm&gt;</code></code></pre> 
 <p>(7)<strong>处理Token失效</strong></p> 
 <p>思路:在响应拦截器中处理token失效</p> 
 <p>**难点:怎么在组件之外实现退出登录返回首页:</p> 
 <p>来一个链接,详细讲解的:</p> 
 <p><a class="kdocs-link" href="https://github.com/remix-run/react-router/issues/8264" title="在组件之外实现退出登录返回首页">在组件之外实现退出登录返回首页</a></p> 
 <pre><code class="language-plain">
<code class="language-plaintext">//示例代码
import { createBrowserHistory } from 'history';
import { +unstable_HistoryRouter as HistoryRouter } from 'react-router-dom';

let history = createBrowserHistory();

function App() {
  return (
    &lt;HistoryRouter history={history}&gt;
      // The rest of your app
    &lt;/HistoryRouter&gt;
  );
}

history.push("/foo");</code></code></pre> 
 <p>安装包:yarn add history (这一部分我就在这展示,要不然我就登录不上去了)</p> 
 <p>常规的js文件中,那些useXXX文件都是失效的,所以得从history 中引入一个方法,需要在路由中配置</p> 
 <p>在util中新建history.js</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { createBrowserHistory} from 'history'
const history = createBrowserHistory()

export {history}</code></code></pre> 
 <p>在util/http.js中:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext"> import { history } from './history'
 if (error.response.status === 401) {
        // 跳回到登录 reactRouter默认状态下 并不支持在组件之外完成路由跳转
        // 需要自己来实现
        console.log('login')
        history.push('/login')
    }</code></code></pre> 
 <p>在App.js中:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">+import { +unstable_HistoryRouter as HistoryRouter , Routes, Route } from 'react-router-dom'
+ &lt;HistoryRouter history={history}&gt;
 
   &lt;/HistoryRouter&gt;</code></code></pre> 
 <p>六.<strong>首页echart实现</strong></p> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/89/af/tuehhHEo_o.png" width="1200"> 
   </div> 
  </div> 
 </div> 
 <pre><code class="language-plain">
<code class="language-plaintext">yarn add echarts</code></code></pre> 
 <p><a class="kdocs-link" href="https://echarts.apache.org/handbook/zh/basics/import/" rel="nofollow" title="echarts官网">echarts官网</a></p> 
 <p>components中新建Bar.js:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">// 封装图表bar组件
import { useEffect, useRef } from 'react'
import * as echarts from 'echarts';
export default function Bar({title,xData,yData,style}) {
    const domRef = useRef()
    const chartInit = () =&gt; {
        // 基于准备好的dom，初始化echarts实例
        const myChart = echarts.init(domRef.current);
        // 绘制图表
        myChart.setOption({
            title: {
                text: title
            },
            tooltip: {},
            xAxis: {
                data: xData
            },
            yAxis: {},
            series: [
                {
                    name: '销量',
                    type: 'bar',
                    data: yData
                }
            ]
        });
    }
    //执行这个初始化的函数
    useEffect(() =&gt; {
     chartInit()   
    },[])
    return (
        &lt;div&gt;
            {/* 准备一个挂载节点 */}
            &lt;div ref={domRef} style={style}&gt;&lt;/div&gt;
        &lt;/div&gt;
    )
}</code></code></pre> 
 <p>Home/index.js中:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">// 思路：
// 1. 看官方文档 把echarts加入项目  
// 如何在react获取dom -&gt; useRef
// 在什么地方获取dom节点 -&gt; useEffect
// 2. 不抽离定制化的参数 先把最小化的demo跑起来
// 3. 按照需求，哪些参数需要自定义 抽象出来
import Bar from '../../components/Bar'

export default function Home() {

    return (
        &lt;div&gt;
            {/* 渲染Bar组件 */}
            &lt;Bar
                title='主流框架满意度'
                xData={['react', 'vue', 'angular']}
                yData={[30, 40, 50]}
                style={<!-- -->{ width: '500px', height: '400px' }} /&gt;
            &lt;Bar
                title='主流框架使用度'
                xData={['react', 'vue', 'angular']}
                yData={[60, 70, 80]}
                style={<!-- -->{ width: '300px', height: '200px' }} /&gt;
        &lt;/div&gt;
    )
}</code></code></pre> 
 <p>七.<strong>内容管理</strong></p> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/8d/14/ddEPkykf_o.png" width="1200"> 
   </div> 
  </div> 
 </div> 
 <p>(1)<strong>筛选区结构</strong></p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { Link } from 'react-router-dom'
import { Card, Breadcrumb, Form, Button, Radio, DatePicker, Select } from 'antd'
import 'moment/locale/zh-cn'
import locale from 'antd/es/date-picker/locale/zh_CN'
import './index.scss'

const { Option } = Select
const { RangePicker } = DatePicker
const Article = () =&gt; {
    const onFinish = (values) =&gt; {
        console.log(values);
    }
    return (
        &lt;div&gt;
            {/* 筛选区域 */}
            &lt;Card
                title={
                    &lt;Breadcrumb separator="&gt;"&gt;
                        &lt;Breadcrumb.Item&gt;
                            &lt;Link to="/home"&gt;首页&lt;/Link&gt;
                        &lt;/Breadcrumb.Item&gt;
                        &lt;Breadcrumb.Item&gt;内容管理&lt;/Breadcrumb.Item&gt;
                    &lt;/Breadcrumb&gt;
                }
                style={<!-- -->{ marginBottom: 20 }}
            &gt;
                &lt;Form
                    onFinish={onFinish}
                    initialValues={<!-- -->{ status: null }}&gt;
                    &lt;Form.Item label="状态" name="status"&gt;
                        &lt;Radio.Group&gt;
                            &lt;Radio value={null}&gt;全部&lt;/Radio&gt;
                            &lt;Radio value={0}&gt;草稿&lt;/Radio&gt;
                            &lt;Radio value={1}&gt;待审核&lt;/Radio&gt;
                            &lt;Radio value={2}&gt;审核通过&lt;/Radio&gt;
                            &lt;Radio value={3}&gt;审核失败&lt;/Radio&gt;
                        &lt;/Radio.Group&gt;
                    &lt;/Form.Item&gt;

                    &lt;Form.Item label="频道" name="channel_id"&gt;
                        &lt;Select
                            placeholder="请选择文章频道"
                            style={<!-- -->{ width: 120 }}
                        &gt;

                        &lt;/Select&gt;
                    &lt;/Form.Item&gt;

                    &lt;Form.Item label="日期" name="date"&gt;
                        {/* 传入locale属性 控制中文显示*/}
                        &lt;RangePicker locale={locale}&gt;&lt;/RangePicker&gt;
                    &lt;/Form.Item&gt;

                    &lt;Form.Item&gt;
                        &lt;Button type="primary" htmlType="submit" style={<!-- -->{ marginLeft: 80 }}&gt;
                            筛选
              &lt;/Button&gt;
                    &lt;/Form.Item&gt;
                &lt;/Form&gt;
            &lt;/Card&gt;
            {/* 文章列表区域 */}
            &lt;Card title={`根据筛选条件共查询到  条结果：`}&gt;

            &lt;/Card&gt;
        &lt;/div&gt;
    )
}
export default Article</code></code></pre> 
 <p>(2)<strong>表格区域结构</strong></p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { +Table,+Tag, +Space,Card, Breadcrumb, Form, Button, Radio, DatePicker, Select } from 'antd'
import { EditOutlined, DeleteOutlined } from '@ant-design/icons'
import img404 from '../../assets/images/error.png'

 const columns = [
        {
          title: '封面',
          dataIndex: 'cover',
          width: 120,
          render: cover =&gt; {
            return &lt;img src={cover.images[0] || img404} width={80} height={60} alt="" /&gt;
          }
        },
        {
          title: '标题',
          dataIndex: 'title',
          width: 220
        },
        {
          title: '状态',
          dataIndex: 'status',
          render: data =&gt; &lt;Tag color='green'&gt;审核通过&lt;/Tag&gt;
        },
        {
          title: '发布时间',
          dataIndex: 'pubdate'
        },
        {
          title: '阅读数',
          dataIndex: 'read_count'
        },
        {
          title: '评论数',
          dataIndex: 'comment_count'
        },
        {
          title: '点赞数',
          dataIndex: 'like_count'
        },
        {
          title: '操作',
          render: data =&gt; {
            return (
              &lt;Space size="middle"&gt;
                &lt;Button
                  type="primary"
                  shape="circle"
                  icon={&lt;EditOutlined /&gt;}
                  /&gt;
                &lt;Button
                  type="primary"
                  danger
                  shape="circle"
                  icon={&lt;DeleteOutlined /&gt;}
                 
                /&gt;
              &lt;/Space&gt;
            )
          },
          fixed: 'right'
        }
      ]
    const data = [
        {
            id: '8218',
            comment_count: 0,
            cover: {
                images:['http:geek.itheima.net/resources/images/15.jpg']
            },
            like_count: 0,
            pubdate: '2019-03-11 09:00:00',
            read_count: 2,
            status: 2,
            title:'理想化处置方案'
        }
    ]
    
     {/* 文章列表区域 */}
            &lt;Card title={`根据筛选条件共查询到  条结果：`}&gt;
                &lt;Table
                    rowKey="id"
                    columns={columns}
                    dataSource={data}
                /&gt;
            &lt;/Card&gt;</code></code></pre> 
 <p>(3)<strong>频道列表渲染</strong></p> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/55/fe/rFp8jc32_o.png" width="346"> 
   </div> 
  </div> 
 </div> 
 <p>Article/index.js中:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { http } from '../../utils/http'
 //频道列表管理
    const [channelList, setChannelList] = useState([])
    const loadChannelList = async () =&gt; {
        const res = await http.get('/channels')
        console.log('1',res);
        setChannelList(res.data.data.channels)
    }
    useEffect(() =&gt; {
        loadChannelList()
    }, [])
    
      &lt;Form.Item label="频道" name="channel_id"&gt;
               &lt;Select
                placeholder="请选择文章频道"
                 style={<!-- -->{ width: 120 }}
                  &gt;
                     {
                       channelList.map(channel =&gt; &lt;Option key={channel.id} value={channel.id}&gt;{channel.name}&lt;/Option&gt;)
                      }
                   &lt;/Select&gt;
          &lt;/Form.Item&gt;</code></code></pre> 
 <p>(4)<strong>获取文章列表</strong></p> 
 <p>Article/index.js中:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">//文章列表管理  统一管理数据 将来修改给setArticleData传对象
    const [list, setList] = useState({
        list: [],//文章列表
        count: 0//文章数量
    })

    //文章参数管理
    const [params, setParams] = useState({
        page: 1,
        per_page: 10
    })

    //如果异步请求函数需要依赖一些数据的变化而重新执行
    //推荐把它写到内部
    //统一不抽离函数到外面,只要涉及到异步请求的函数,都放到useEffect内部
    //本质区别:写到外面每次组件更新都会重新进行函数初始化,是一次性能浪费
    //而写到useEffect中,只会在依赖项发送变化时,函数才会重新进行初始化
    useEffect(() =&gt; {
        const loadList = async () =&gt; {
            const res = await http.get('/mp/articles', { params })
            console.log('2', res);
        }
        loadList()
    }, [params])</code></code></pre> 
 <p>(5)<strong>渲染文章列表</strong></p> 
 <p>Article/index.js中:接口走不通,在这写一下过程把,代码我是直接铺设自己的数据了</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">+    useEffect(() =&gt; {
        const loadList = async () =&gt; {
            const res = await http.get('/mp/articles', { params })
            const { results, total_count } = res.data
            setArticleData({
              list: results,
              count: total_count
            })
          
        }
        loadList()
    }, [params])
    
    + &lt;Card title={`根据筛选条件共查询到 ${articleData.count} 条结果：`}&gt;
    + dataSource={articleData.list}</code></code></pre> 
 <p>(6)<strong>筛选功能实现</strong></p> 
 <p>思路:1.为表单添加onFinish属性,监听表单提交;</p> 
 <p>2.根据接口字段格式要求,格式化参数的格式;</p> 
 <ol><li style="margin-left:1.4em;"> <p>修改params,触发接口重新发送.</p> </li></ol> 
 <pre><code class="language-plain">
<code class="language-plaintext"> &lt;Form
   + onFinish={onFinish}
   &lt;/Form&gt;
   
     const onFinish = (values) =&gt; {
        console.log(values);
        const { channel_id, date, status } = values
        //数据处理
        const _params = {}
        if (status !== -1) {//-1代表全部的意思
            _params.status=status
        }
        if (channel_id) {
            _params.channel_id=channel_id
        }
        if (date) {//begin_pubdate后端要求
            _params.begin_pubdate=data[0].format('YYYY-MM-DD') 
            _params.end_pubdate=data[1].format('YYYY-MM-DD') 
        }
        //修改params数据,引起接口的重新发送 对象的合并是一个整体覆盖 改了对象的整体应用
        setParams({//这样的话就不是整体替换了
            ...params,
            ..._params
        })
    }</code></code></pre> 
 <p>(7)<strong>分页器功能</strong></p> 
 <pre><code class="language-plain">
<code class="language-plaintext"> //改变分页
 +   const pageChange = (page) =&gt; {
        setParams({
            ...params,
            page
        })
    }
&lt;Table
          rowKey="id"
          columns={columns}
          dataSource={articleData.list}
          +pagination={
            {
              pageSize: params.per_page,
              total: articleData.count,
              onChange: pageChange,
              current: params.page
            }
          }
          bordered
        /&gt;</code></code></pre> 
 <p>(8)<strong>文章删除功能</strong></p> 
 <pre><code class="language-plain">
<code class="language-plaintext">  // 删除文章
    const delArticle = async (data) =&gt; {
        await http.delete(`/mp/articles/${data.id}`)
        // 刷新一下列表
        setParams({
            ...params,
            page: 1
        })
    }
&lt;Button
     type="primary"
      danger
      shape="circle"
      icon={&lt;DeleteOutlined /&gt;}
      +onClick={() =&gt; delArticle(data)}
            /&gt;</code></code></pre> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/8d/0a/z2TJzcXI_o.png" width="1200"> 
   </div> 
  </div> 
 </div> 
 <p></p> 
 <p>(9)<strong>跳转到编辑页</strong></p> 
 <p></p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { Link, +useNavigate } from 'react-router-dom'
   //跳转到编辑页
    const navigate = useNavigate()//必须写这个地方,写到内部就报错了
    const goPublish = (data) =&gt; {
        navigate(`/publish?id=${data.id}`)
    }
  render: data =&gt; {
                return (
                    &lt;Space size="middle"&gt;
                        &lt;Button
                            type="primary"
                            shape="circle"
                            icon={&lt;EditOutlined /&gt;}
                         +   onClick={() =&gt; goPublish(data)}
                        /&gt;
                      
                    &lt;/Space&gt;
                )
            },</code></code></pre> 
 <p>八.<strong>发布文章结构搭建</strong></p> 
 <p>(1)<strong>基本结构搭建</strong></p> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/69/24/GFNRyZWy_o.png" width="1200"> 
   </div> 
  </div> 
 </div> 
 <p></p> 
 <p>Publish/index.js中:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import {
    Card,
    Breadcrumb,
    Form,
    Button,
    Radio,
    Input,
    Upload,
    Space,
    Select,
    message
} from 'antd'
import { PlusOutlined } from '@ant-design/icons'
import { Link } from 'react-router-dom'

import './index.scss'



const { Option } = Select
const Publish = () =&gt; {

    return (
        &lt;div className="publish"&gt;
            &lt;Card
                title={
                    &lt;Breadcrumb separator="&gt;"&gt;
                        &lt;Breadcrumb.Item&gt;
                            &lt;Link to="/home"&gt;首页&lt;/Link&gt;
                        &lt;/Breadcrumb.Item&gt;
                        &lt;Breadcrumb.Item&gt;文章&lt;/Breadcrumb.Item&gt;
                    &lt;/Breadcrumb&gt;
                }
            &gt;
                &lt;Form
                    labelCol={<!-- -->{ span: 4 }}
                    wrapperCol={<!-- -->{ span: 16 }}
                    initialValues={<!-- -->{ type: 1, content: '' }}


                &gt;
                    &lt;Form.Item
                        label="标题"
                        name="title"
                        rules={[{ required: true, message: '请输入文章标题' }]}
                    &gt;
                        &lt;Input placeholder="请输入文章标题" style={<!-- -->{ width: 400 }} /&gt;
                    &lt;/Form.Item&gt;
                    &lt;Form.Item
                        label="频道"
                        name="channel_id"
                        rules={[{ required: true, message: '请选择文章频道' }]}
                    &gt;
                        &lt;Select placeholder="请选择文章频道" style={<!-- -->{ width: 400 }}&gt;

                            &lt;Option key='' value=''&gt;1&lt;/Option&gt;


                        &lt;/Select&gt;
                    &lt;/Form.Item&gt;

                    &lt;Form.Item label="封面"&gt;
                        &lt;Form.Item name="type"&gt;
                            &lt;Radio.Group &gt;
                                &lt;Radio value={1}&gt;单图&lt;/Radio&gt;
                                &lt;Radio value={3}&gt;三图&lt;/Radio&gt;
                                &lt;Radio value={0}&gt;无图&lt;/Radio&gt;
                            &lt;/Radio.Group&gt;
                        &lt;/Form.Item&gt;
                      &lt;Upload
                            name="image"
                            listType="picture-card"
                            className="avatar-uploader"
                            showUploadList
                            action="http://geek.itheima.net/v1_0/upload"




                        &gt;
                            &lt;div style={<!-- -->{ marginTop: 8 }}&gt;
                                &lt;PlusOutlined /&gt;
                            &lt;/div&gt;
                        &lt;/Upload&gt;

                    &lt;/Form.Item&gt;
                    {/* 这里的富文本组件 已经被Form.Item控制 */}
                    {/* 它的输入内容 会在onFinished回调中收集起来 */}
                    &lt;Form.Item
                        label="内容"
                        name="content"
                        rules={[{ required: true, message: '请输入文章内容' }]}
                    &gt;
                      
                    &lt;/Form.Item&gt;

                    &lt;Form.Item wrapperCol={<!-- -->{ offset: 4 }}&gt;
                        &lt;Space&gt;
                            &lt;Button size="large" type="primary" htmlType="submit"&gt;
                                文章
                &lt;/Button&gt;
                        &lt;/Space&gt;
                    &lt;/Form.Item&gt;
                &lt;/Form&gt;
            &lt;/Card&gt;
        &lt;/div&gt;
    )
}

export default Publish</code></code></pre> 
 <p>样式index.scss:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">.publish {
    position: relative;
    .ql-container {//富文本的;类名
      height: 400px !important;
    }
  }
  
  .ant-upload-list {
    .ant-upload-list-picture-card-container,
    .ant-upload-select {
      width: 146px;
      height: 146px;
    }
  }
  </code></code></pre> 
 <p>(2)<strong>富文本编辑器实现</strong></p> 
 <p>1.安装富文本编辑器yarn add react-quill;</p> 
 <p>2.导入富文本编辑器以及样式文件,并渲染;</p> 
 <ol><li style="margin-left:1.4em;"> <p>通过Form组件的initialValues为富文本设置初始值,否则会报错.</p> </li></ol> 
 <p><a class="kdocs-link" href="https://github.com/zenoamaro/react-quill#with-webpack-or-create-react-app" title="富文本编辑器">富文本编辑器</a></p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import ReactQuill from 'react-quill';
import 'react-quill/dist/quill.snow.css';

 &lt;Form.Item
                        label="内容"
                        name="content"
                        rules={[{ required: true, message: '请输入文章内容' }]}
                    &gt;
                      +  &lt;ReactQuill theme="snow" /&gt;
                    &lt;/Form.Item&gt;</code></code></pre> 
 <p>(3)<strong>重构频道获取</strong></p> 
 <p>1.频道列表专门封装</p> 
 <p>store中新建channel.Store.js</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { makeAutoObservable } from 'mobx'
import {http} from '../utils'
class ChannelStore{
    channelList = []
    constructor() {
        makeAutoObservable(this)
    }
      // article publish 哪里调用这个函数呢？
    loadChannelList = async() =&gt; {
        const res = await http.get('/channels')
        this.channelList=res.data.data.channels
    }
}
export default ChannelStore</code></code></pre> 
 <ol><li style="margin-left:1.4em;"> <p>改造内容管理Article中的频道列表</p> </li></ol> 
 <pre><code class="language-plain">
<code class="language-plaintext"> //频道列表管理
  -  const [channelList, setChannelList] = useState([])
  -  const loadChannelList = async () =&gt; {
     -   const res = await http.get('/channels')
     -   console.log('1',res);
     -   setChannelList(res.data.data.channels)
    }
  -  useEffect(() =&gt; {
  -      loadChannelList()
  -  }, [])
  //替换成
  +import {observer} from 'mobx-react-lite'
  + const {channelStore}=useStore()
   {
   + channelStore.channelList.map(channel =&gt; &lt;Option key={channel.id} value={channel.id}&gt;{channel.name}&lt;/Option&gt;)
    }
    +export default observer(Article)</code></code></pre> 
 <ol><li style="margin-left:1.4em;"> <p>在发布文章Publish.js中使用:(和上面一样的操作)</p> </li></ol> 
 <pre><code class="language-plain">
<code class="language-plaintext"> +import {observer} from 'mobx-react-lite'
  + const {channelStore}=useStore()
   {
   + channelStore.channelList.map(channel =&gt; &lt;Option key={channel.id} value={channel.id}&gt;{channel.name}&lt;/Option&gt;)
    }
   +export default observer(Publish)</code></code></pre> 
 <p>(4)<strong>基础上传实现</strong></p> 
 <pre><code class="language-plain">
<code class="language-plaintext">   +import { useState } from 'react';
     + const { channelStore } = useStore()
    //存放上传图片的列表(在最后一次阶段才能拿到图片的响应路径,控制台输出第三次的时候)
    //也就是图片是分阶段上传的 这里区别Vue 成功失败都在这里显示
    +const [fileList, setFileList] = useState([])
    +const onUploadChange = ({fileList}) =&gt; {
        console.log(fileList);
        setFileList(fileList)
    }
   &lt;Upload
                            name="image"
                            listType="picture-card"
                            className="avatar-uploader"
                            showUploadList
                            action="http://geek.itheima.net/v1_0/upload"
                           + fileList={fileList}
                           + onChange={onUploadChange}
                           
                        &gt;
                            &lt;div style={<!-- -->{ marginTop: 8 }}&gt;
                                &lt;PlusOutlined /&gt;
                            &lt;/div&gt;
                        &lt;/Upload&gt;</code></code></pre> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/b1/55/xis4KIAV_o.png" width="413"> 
   </div> 
  </div> 
 </div> 
 <p>(5)<strong>控制封面数量</strong></p> 
 <pre><code class="language-plain">
<code class="language-plaintext">   //切换图片
    const [imgCount, setImgCount] = useState()
    const radioChange = (e) =&gt; {
        console.log(e.target.value);
        setImgCount(e.target.value)
    }
    &lt;Form.Item name="type"&gt;
     &lt;Radio.Group  +onChange={radioChange}&gt;
          &lt;Radio value={1}&gt;单图&lt;/Radio&gt;
           &lt;Radio value={3}&gt;三图&lt;/Radio&gt;
           &lt;Radio value={0}&gt;无图&lt;/Radio&gt;
           &lt;/Radio.Group&gt;
               {//判断是否是无图,无图就不展示上传了
                            imgCount &gt; 0 &amp;&amp; (
                                &lt;Upload
                                    name="image"
                                    listType="picture-card"
                                    className="avatar-uploader"
                                    showUploadList
                                    action="http://geek.itheima.net/v1_0/upload"
                                    fileList={fileList}
                                    onChange={onUploadChange}

                                &gt;
                                    &lt;div style={<!-- -->{ marginTop: 8 }}&gt;
                                        &lt;PlusOutlined /&gt;
                                    &lt;/div&gt;
                                &lt;/Upload&gt;
                            )
                        }</code></code></pre> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/5d/14/Jok4D4MQ_o.png" width="339"> 
   </div> 
  </div> 
 </div> 
 <p>(6)<strong>控制最大上传数量</strong></p> 
 <p>1.修改Upload组件的maxCount(最大数量)属性控制最大上传数量;</p> 
 <ol><li style="margin-left:1.4em;"> <p>控制multiple(支持多图选择属性)控制是否支持选择多张图片.</p> </li></ol> 
 <pre><code class="language-plain">
<code class="language-plaintext"> &lt;Upload
                                    name="image"
                                    listType="picture-card"
                                    className="avatar-uploader"
                                    showUploadList
                                    action="http://geek.itheima.net/v1_0/upload"
                                    fileList={fileList}
                                    onChange={onUploadChange}
                                   + multiple={imgCount &gt; 1}
                                   + maxCount={imgCount}  最大数量
                                &gt;
                                    &lt;div style={<!-- -->{ marginTop: 8 }}&gt;
                                        &lt;PlusOutlined /&gt;
                                    &lt;/div&gt;
                                &lt;/Upload&gt;</code></code></pre> 
 <p>(7)<strong>发布文章实现</strong></p> 
 <p>接口有误,正常的话点击发布后会在文章管理Table中多一条数据.</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">  //发布文章
    const onFinish = async(values) =&gt; {
        console.log(values);
         // 数据的二次处理 重点是处理cover字段
        const { channel_id, content, title, type } = values
        const params = {
            channel_id, content, title, type,
            cover: {
                type: type,
                images:fileList.map(item=&gt;item.response.data.url)
            }
        }
        console.log(params);
        await http.post('/mp/articles?draft=false', params)
    }
    
       &lt;Form
                    labelCol={<!-- -->{ span: 4 }}
                    wrapperCol={<!-- -->{ span: 16 }}
                    initialValues={<!-- -->{ type: 1, content: '1234' }}
                   + onFinish={onFinish}

            &gt;</code></code></pre> 
 <p>(8)<strong>暂存图片列表实现</strong></p> 
 <p>思路:在上传完毕之后通过ref存储所有图片,需要几张就显示几张,其实是把ref当仓库,需要几张拿几张.</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { useState, +useRef } from 'react';

const Publish = () =&gt; {
      // 使用useRef声明一个暂存仓库
    +const cacheImgList = useRef()
    const [fileList, setFileList] = useState([])
    const onUploadChange = ({ fileList }) =&gt; {
        console.log(fileList);
        setFileList(fileList)
        //同时把图片列表存入仓库一份
       + cacheImgList.current = fileList
    }
    
      //切换图片
    const [imgCount, setImgCount] = useState()
    const radioChange = (e) =&gt; {
       + const rawValue = e.target.value
        setImgCount(rawValue)
        //从仓库取对应的图片数量,交给渲染图片列表的fileList
        //通过调用setFileList
        if (cacheImgList.current.length === 0) {
            return false
        }

      +  if (rawValue === 1) {
            const img = cacheImgList.current ? cacheImgList.current[0] : []
            setFileList([img])
     +   } else if (rawValue === 3) {
            setFileList(cacheImgList.current)
        }
    }
}</code></code></pre> 
 <p>(9)<strong>编辑文章-适配文案</strong></p> 
 <p>思路:1.通过路由参数拿到文章id;</p> 
 <p>2.根据文章id是否存在判断是否是编辑状态;</p> 
 <ol><li style="margin-left:1.4em;"> <p>如果是编辑状态,展示编辑时的文案信息.</p> </li></ol> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { Link, +useSearchParams } from 'react-router-dom'
 //编辑功能
    const [params] = useSearchParams()
    const id = params.get('id')
    console.log('文章id是', id);
    
      &lt;Card
                title={
                    &lt;Breadcrumb separator="&gt;"&gt;
                        &lt;Breadcrumb.Item&gt;
                            &lt;Link to="/home"&gt;首页&lt;/Link&gt;
                        &lt;/Breadcrumb.Item&gt;
                       + &lt;Breadcrumb.Item&gt;{id ? '编辑' : '发布'}文章&lt;/Breadcrumb.Item&gt;
                    &lt;/Breadcrumb&gt;
                }
            &gt;
               &lt;Button size="large" type="primary" htmlType="submit"&gt;
                                {id ? '编辑' : '发布'}  文章
                &lt;/Button&gt;
          &lt;/Card&gt;</code></code></pre> 
 <p>(10)<strong>回显基础数据</strong></p> 
 <p>因为接口错误,目前实现的效果是点击内容管理的编辑会跑到发布文章页,除了上传图片,剩下的内容都能回显出来.</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">   //编辑功能
    const [params] = useSearchParams()
    const id = params.get('id')
    console.log('文章id是', id);
    // 数据回填  id调用接口  1.表单回填 2.暂存列表 3.Upload组件fileList
   + const form = useRef(null)
    useEffect(() =&gt; {
        const loadDetail = async () =&gt; {
            const res = await http.get(`/mp/articles/${id}`)
            //表单数据回填,实例方法
       +     form.current.setFieldsValue(res.data)
            console.log(res);
        }
        if (id) {//id存在的话,才发起编辑
            loadDetail()
            console.log('form', form.current);
        }
        
    }, [id])
    
       &lt;Form
                    labelCol={<!-- -->{ span: 4 }}
                    wrapperCol={<!-- -->{ span: 16 }}
                    initialValues={<!-- -->{ type: 1, content: '1234' }}
                    onFinish={onFinish}
                 +   form={form}
                &gt;</code></code></pre> 
 <p>(11)<strong>回显upload上传图片</strong></p> 
 <pre><code class="language-plain">
<code class="language-plaintext">   //编辑功能
    const [params] = useSearchParams()
    const id = params.get('id')
    console.log('文章id是', id);
    // 数据回填  id调用接口  1.表单回填 2.暂存列表 3.Upload组件fileList
    const form = useRef(null)
    useEffect(() =&gt; {
        const loadDetail = async () =&gt; {
            const res = await http.get(`/mp/articles/${id}`)
            //表单数据回填,实例方法
            const data = res.data
          +  form.current.setFieldsValue({ ...data, type: data.cover.type })
            //调用setFileList方法回填upload
            +const formatImgList=data.cover.images.map(url =&gt;({url}))
           + setFileList(formatImgList)
            //暂存列表里也存一份(暂存列表和fileList回显列表数据保持一致就能正常显示)
           + cacheImgList.current = formatImgList
        }
        if (id) {//id存在的话,才发起编辑
            loadDetail()
            console.log('form', form.current);
        }

    }, [id])
    </code></code></pre> 
 <p>(12)<strong>点击修改保存提交</strong></p> 
 <pre><code class="language-plain">
<code class="language-plaintext">    const onUploadChange = ({ fileList }) =&gt; {
        console.log(fileList);
        setFileList(fileList)
        //同时把图片列表存入仓库一份
        const formatList = fileList.map(file =&gt; {
            //上传完毕,作数据处理
          +  if (file.response) {
                return {
                   url:file.response.data.url
               } 
            }
            //否则正在上传,不做处理
           + return file
        })
        cacheImgList.current = fileList
    }
    
      //发布文章
    const navigator=useNavigate()
    const onFinish = async (values) =&gt; {
        console.log(values);
        // 数据的二次处理 重点是处理cover字段
        const { channel_id, content, title, type } = values
        const params = {
            channel_id, content, title, type,
            cover: {
                type: type,
             +   images: fileList.map(item =&gt; item.url)
            }
        }
        if (id) {
            await http.post(`/mp/articles/${id}?draft=false`, params)
        } else {
            await http.post('/mp/articles?draft=false', params)
        }
        navigator('/article')
        message.success(`${id?'编辑成功':'发布成功'}`)

    }</code></code></pre> 
 <p>九.<strong>项目打包</strong></p> 
 <p>(1)<strong>打包</strong></p> 
 <pre><code class="language-plain">
<code class="language-plaintext">yarn build</code></code></pre> 
 <p>(2)<strong>打包体积分析</strong></p> 
 <ol><li style="margin-left:1.4em;"> <p>安装分析打包体积的包</p> </li></ol> 
 <pre><code class="language-plain">
<code class="language-plaintext">yarn add source-map-explorer</code></code></pre> 
 <p>2.在package.json中的scripts标签中,添加分析打包体积的命令;</p> 
 <p>3.对项目打包:yarn build,执行过的话这步省略;</p> 
 <p>4.运行分析命令:yarn analyze;</p> 
 <ol><li style="margin-left:1.4em;"> <p>通过浏览器打开的命令,分析图表中的包体积.</p> </li></ol> 
 <pre><code class="language-plain">
<code class="language-plaintext">"scripts":{
    "report":"source-map-explorer 'build/static/js/*.js'"
}</code></code></pre> 
 <p>(3)<strong>CDN配置</strong></p> 
 <p>说明:使用craco 来修改webpack配置,从而实现CDN优化.</p> 
 <p>新建craco.config.js</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">// 添加自定义对于webpack的配置

const path = require('path')
const { whenProd, getPlugin, pluginByName } = require('@craco/craco')

module.exports = {
  // webpack 配置
  webpack: {
    // 配置别名
    alias: {
      // 约定：使用 @ 表示 src 文件所在路径
      '@': path.resolve(__dirname, 'src')
    },
    // 配置webpack
    // 配置CDN
    configure: (webpackConfig) =&gt; {
      // webpackConfig自动注入的webpack配置对象
      // 可以在这个函数中对它进行详细的自定义配置
      // 只要最后return出去就行
      let cdn = {
        js: [],
        css: []
      }
      // 只有生产环境才配置
      whenProd(() =&gt; {
        // key:需要不参与打包的具体的包
        // value: cdn文件中 挂载于全局的变量名称 为了替换之前在开发环境下
        // 通过import 导入的 react / react-dom
        webpackConfig.externals = {
          react: 'React',
          'react-dom': 'ReactDOM'
        }
        // 配置现成的cdn 资源数组 现在是公共为了测试
        // 实际开发的时候 用公司自己花钱买的cdn服务器
        cdn = {
          js: [
            'https://cdn.bootcdn.net/ajax/libs/react/17.0.2/umd/react.production.min.js',
            'https://cdn.bootcdn.net/ajax/libs/react-dom/17.0.2/umd/react-dom.production.min.js',
          ],
          css: []
        }
      })

      // 都是为了将来配置 htmlWebpackPlugin插件 将来在public/index.html注入
      // cdn资源数组时 准备好的一些现成的资源
      const { isFound, match } = getPlugin(
        webpackConfig,
        pluginByName('HtmlWebpackPlugin')
      )

      if (isFound) {
        // 找到了HtmlWebpackPlugin的插件
        match.userOptions.cdn = cdn
      }

      return webpackConfig
    }
  }
}</code></code></pre> 
 <pre><code class="language-plain">
<code class="language-plaintext">public/index.html中:</code></code></pre> 
 <pre><code class="language-plain">
<code class="language-plaintext">  &lt;body&gt;
  &lt;!-- 加载第三发包的 CDN 链接 
  
    这个代码写到head里有可能 也有可能写到body之上 取决于依赖dom完成生成
  --&gt;
  &lt;% htmlWebpackPlugin.options.cdn.js.forEach(cdnURL=&gt; { %&gt;
    &lt;script src="&lt;%= cdnURL %&gt;"&gt;&lt;/script&gt;
    &lt;% }) %&gt;</code></code></pre> 
 <p>再次执行yarn build</p> 
 <p>(4)<strong>路由懒加载</strong></p> 
 <p>1.在App.js组件中,导入Suspense组件(异步加载);</p> 
 <p>2.在路由Router内部,使用Suspense组件包裹组件内容;</p> 
 <p>3.为Suspense组件提供fallback属性,指定loading占位内容;</p> 
 <ol><li style="margin-left:1.4em;"> <p>导入lazy函数,并修改为懒加载方式导入路由组件.</p> </li></ol> 
 <p>App.js:</p> 
 <pre><code class="language-plain">
<code class="language-plaintext">import { lazy, Suspense } from 'react'
// 按需导入组件
const Login = lazy(() =&gt; import('./pages/Login'))
const Layout = lazy(() =&gt; import('./pages/Layout'))
const Home = lazy(() =&gt; import('./pages/Home'))
const Article = lazy(() =&gt; import('./pages/Article'))
const Publish = lazy(() =&gt; import('./pages/Publish'))

 &lt;Suspense
                    fallback={
                        &lt;div
                            style={<!-- -->{
                                textAlign: 'center',
                                marginTop: 200
                            }}
                        &gt;
                            loading...
                        &lt;/div&gt;
                    }
                &gt;
                 &lt;Routes&gt;
                   ...
                   &lt;/Routes&gt;
      &lt;/Suspense&gt;</code></code></pre> 
 <p>觉得还不错的话,动动动您的小手点个赞呗!!</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/601c3c57ac7597b274bb9b7c7c40550e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle通过MyBatis执行批量插入与更新问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c4999b8c99c559526729d63bc15efb31/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">「 系统设计 」 为什么要做架构分层？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>