<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux生产者消费者模型(POSIX信号量) - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux生产者消费者模型(POSIX信号量)" />
<meta property="og:description" content="目录
一.生产者消费者模型
1.基本概念
2.模型特点
3.模型优点 二.基于BlockingQueue的生产者消费者模型
1.基本概念
2.单生产者、单消费者为例进行模拟实现 3.基于计算任务的生产者消费者模型
三.POSIX信号量
1.基本概念
2.信号量函数
三. 二元信号量模拟实现互斥功能 四.基于环形队列的生产者消费者模型
1.生产者和消费者关心不同资源
2.需要遵守的两个原则
3.代码模拟实现
4.信号量保护环形队列 一.生产者消费者模型 1.基本概念 生产者消费者模式就是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过这个容器来通讯，所以生产者生产完数据之后不用等待消费者处理，直接将生产的数据放到这个容器当中，消费者也不用找生产者要数据，而是直接从这个容器里取数据，这个容器就相当于一个缓冲区，平衡了生产者和消费者的处理能力，这个容器实际上就是用来给生产者和消费者解耦的。 2.模型特点 (1)生产者消费者模型是多线程同步与互斥的一个经典场景，其特点如下：
三种关系： 生产者和生产者（互斥关系）、消费者和消费者（互斥关系）、生产者和消费者（互斥关系、同步关系）。两种角色： 生产者和消费者。（通常由进程或线程承担）一个交易场所： 通常指的是内存中的一段缓冲区。（可以自己通过某种方式组织起来） 我们用代码编写生产者消费者模型的时候，本质就是对这三个特点进行维护。
(2)生产者和生产者、消费者和消费者、生产者和消费者，它们之间为什么会存在互斥关系？
介于生产者和消费者之间的容器可能会被多个执行流同时访问，因此我们需要将该临界资源用互斥锁保护起来。其中，所有的生产者和消费者都会竞争式的申请锁，因此生产者和生产者、消费者和消费者、生产者和消费者之间都存在互斥关系。 (3)生产者和消费者之间为什么会存在同步关系？
如果让生产者一直生产，那么当生产者生产的数据将容器塞满后，生产者再生产数据就会生产失败。反之，让消费者一直消费，那么当容器当中的数据被消费完后，消费者再进行消费就会消费失败。虽然这样不会造成任何数据不一致的问题，但是这样会引起另一方的饥饿问题，是非常低效的。我们应该让生产者和消费者访问该容器时具有一定的顺序性，比如让生产者先生产，然后再让消费者进行消费。 注意： 互斥关系保证的是数据的正确性，而同步关系是为了让多线程之间协同起来。
(4)让消费者和生产者协同工作，合适的时候可能一直运行，生产者和消费者并不会因为要互相等待对方的结果而阻塞，相当于双方可以并发执行.
(5)为什么要有生产者消费者模型？ 本质是用代码进行解耦的过程
3.模型优点 解耦。支持并发。支持忙闲不均 (哪边的线程忙可以多分配一些线程) (1)如果我们在主函数中调用某一函数，那么我们必须等该函数体执行完后才继续执行主函数的后续代码，因此函数调用本质上是一种紧耦合。
(2)对应到生产者消费者模型中，函数传参实际上就是生产者生产的过程，而执行函数体实际上就是消费者消费的过程，但生产者只负责生产数据，消费者只负责消费数据，在消费者消费期间生产者可以同时进行生产，因此生产者消费者模型本质是一种松耦合。
二.基于BlockingQueue的生产者消费者模型 1.基本概念 在多线程编程中阻塞队列(Blocking Queue)是一种常用于实现生产者和消费者模型的数据结构。其与普通的队列区别在于，当队列为空时，从队列获取元素的操作将会被阻塞，直到队列中被放入了元素当队列满时，往队列里存放元 素的操作也会被阻塞，直到有元素被从队列中取出(以上的操作都是基于不同的线程来说的，线程在对阻塞队列进行操作时会被阻塞) 2.单生产者、单消费者为例进行模拟实现 (1) 生产和消费步调一致，生产一个消费一个
①BlockQueue.hpp
#pragma oncec #include &lt;iostream&gt; #include &lt;pthread.h&gt; #include &lt;queue&gt; #include &lt;unistd.h&gt; #define NUM 5 template&lt;class T&gt; class BlockQueue { private: bool IsFull() { return _q." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/8fa2f134e7cb7d12a1a8ef73e699c746/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-04T12:39:27+08:00" />
<meta property="article:modified_time" content="2022-07-04T12:39:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux生产者消费者模型(POSIX信号量)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B" rel="nofollow">一.生产者消费者模型</a></p> 
<p id="1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">1.基本概念</a></p> 
<p id="2.%E6%A8%A1%E5%9E%8B%E7%89%B9%E7%82%B9-toc" style="margin-left:80px;"><a href="#2.%E6%A8%A1%E5%9E%8B%E7%89%B9%E7%82%B9" rel="nofollow">2.模型特点</a></p> 
<p id="%C2%A03.%E6%A8%A1%E5%9E%8B%E4%BC%98%E7%82%B9%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A03.%E6%A8%A1%E5%9E%8B%E4%BC%98%E7%82%B9%C2%A0" rel="nofollow">3.模型优点 </a></p> 
<p id="%E4%BA%8C.%E5%9F%BA%E4%BA%8EBlockingQueue%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E5%9F%BA%E4%BA%8EBlockingQueue%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B" rel="nofollow">二.基于BlockingQueue的生产者消费者模型</a></p> 
<p id="1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">1.基本概念</a></p> 
<p id="2.%E5%8D%95%E7%94%9F%E4%BA%A7%E8%80%85%E3%80%81%E5%8D%95%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%BA%E4%BE%8B%E8%BF%9B%E8%A1%8C%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:80px;"><a href="#2.%E5%8D%95%E7%94%9F%E4%BA%A7%E8%80%85%E3%80%81%E5%8D%95%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%BA%E4%BE%8B%E8%BF%9B%E8%A1%8C%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">2.单生产者、单消费者为例进行模拟实现 </a></p> 
<p id="3.%E5%9F%BA%E4%BA%8E%E8%AE%A1%E7%AE%97%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B-toc" style="margin-left:80px;"><a href="#3.%E5%9F%BA%E4%BA%8E%E8%AE%A1%E7%AE%97%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B" rel="nofollow">3.基于计算任务的生产者消费者模型</a></p> 
<p id="%E4%B8%89.POSIX%E4%BF%A1%E5%8F%B7%E9%87%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%89.POSIX%E4%BF%A1%E5%8F%B7%E9%87%8F" rel="nofollow">三.POSIX信号量</a></p> 
<p id="1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">1.基本概念</a></p> 
<p id="2.%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%87%BD%E6%95%B0" rel="nofollow">2.信号量函数</a></p> 
<p id="%E4%B8%89.%20%E4%BA%8C%E5%85%83%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E5%8A%9F%E8%83%BD%C2%A0%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%20%E4%BA%8C%E5%85%83%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E5%8A%9F%E8%83%BD%C2%A0%C2%A0" rel="nofollow">三. 二元信号量模拟实现互斥功能  </a></p> 
<p id="%E5%9B%9B.%E5%9F%BA%E4%BA%8E%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E5%9F%BA%E4%BA%8E%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B" rel="nofollow">四.基于环形队列的生产者消费者模型</a></p> 
<p id="1.%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E5%85%B3%E5%BF%83%E4%B8%8D%E5%90%8C%E8%B5%84%E6%BA%90-toc" style="margin-left:80px;"><a href="#1.%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E5%85%B3%E5%BF%83%E4%B8%8D%E5%90%8C%E8%B5%84%E6%BA%90" rel="nofollow">1.生产者和消费者关心不同资源</a></p> 
<p id="%C2%A02.%E9%9C%80%E8%A6%81%E9%81%B5%E5%AE%88%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8E%9F%E5%88%99-toc" style="margin-left:80px;"><a href="#%C2%A02.%E9%9C%80%E8%A6%81%E9%81%B5%E5%AE%88%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8E%9F%E5%88%99" rel="nofollow">2.需要遵守的两个原则</a></p> 
<p id="3.%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#3.%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">3.代码模拟实现</a></p> 
<p id="4.%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%C2%A0-toc" style="margin-left:80px;"><a href="#4.%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%C2%A0" rel="nofollow">4.信号量保护环形队列 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span style="color:#0d0016;"><strong>一.生产者消费者模型</strong></span></h2> 
<h4 id="1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span style="color:#0d0016;"><strong>1.基本概念</strong></span></h4> 
<ul><li>生产者消费者模式就是通过一个容器来<strong>解决生产者和消费者的强耦合问题</strong>。</li><li>生产者和消费者彼此之间不直接通讯，而通过这个容器来通讯，所以生产者生产完数据之后不用等待消费者处理，直接将生产的数据放到这个容器当中，消费者也不用找生产者要数据，而是直接从这个容器里取数据，<strong>这个容器就相当于一个缓冲区</strong>，平衡了生产者和消费者的处理能力，这个容器实际上就是用来<strong>给生产者和消费者解耦的。</strong></li></ul> 
<p><img alt="" height="322" src="https://images2.imgbox.com/e0/cd/g0GAd324_o.png" width="743"></p> 
<p>                </p> 
<h4 id="2.%E6%A8%A1%E5%9E%8B%E7%89%B9%E7%82%B9"><span style="color:#0d0016;"><strong>2.模型特点</strong></span></h4> 
<p><span style="color:#0d0016;">(1)生产者消费者模型是多线程同步与互斥的一个经典场景，其特点如下：</span></p> 
<ul><li><span style="color:#0d0016;">三种关系： 生产者和生产者（互斥关系）、消费者和消费者（互斥关系）、生产者和消费者（互斥关系、同步关系）。</span></li><li><span style="color:#0d0016;">两种角色： 生产者和消费者。（通常由进程或线程承担）</span></li><li><span style="color:#0d0016;">一个交易场所： 通常指的是<strong>内存中的一段缓冲区</strong>。（可以自己通过某种方式组织起来）</span></li></ul> 
<p><span style="color:#0d0016;"><strong>我们用代码编写生产者消费者模型的时候，本质就是对这三个特点进行维护</strong>。</span></p> 
<p></p> 
<p><span style="color:#0d0016;">(2)生产者和生产者、消费者和消费者、生产者和消费者，它们之间为什么会存在互斥关系？</span></p> 
<ul><li>介于生产者和消费者之间的容器可能会被多个执行流同时访问，因此我们需要将该临界资源用互斥锁保护起来。</li><li>其中，所有的生产者和消费者都会竞争式的申请锁，因此生产者和生产者、消费者和消费者、生产者和消费者之间都存在互斥关系。</li></ul> 
<p>                         </p> 
<p><span style="color:#0d0016;">(3)生产者和消费者之间为什么会存在同步关系？</span></p> 
<ul><li>如果让生产者一直生产，那么当生产者生产的数据将容器塞满后，生产者再生产数据就会生产失败。</li><li>反之，让消费者一直消费，那么当容器当中的数据被消费完后，消费者再进行消费就会消费失败。</li><li>虽然这样不会造成任何数据不一致的问题，但是这样会引起另一方的饥饿问题，是非常低效的。我们应该让生产者和消费者访问该容器时具有一定的顺序性，比如让生产者先生产，然后再让消费者进行消费。</li></ul> 
<p><span style="color:#0d0016;"><strong>注意： 互斥关系保证的是数据的正确性，而同步关系是为了让多线程之间协同起来。</strong></span></p> 
<p></p> 
<p><span style="color:#0d0016;">(4)让消费者和生产者协同工作，合适的时候可能一直运行，生产者和消费者并不会因为要互相等待对方的结果而阻塞，相当于双方可以并发执行.</span></p> 
<p><span style="color:#0d0016;">(5)为什么要有生产者消费者模型？     本质是用代码进行解耦的过程</span><br>                                 </p> 
<h4 id="%C2%A03.%E6%A8%A1%E5%9E%8B%E4%BC%98%E7%82%B9%C2%A0"><span style="color:#0d0016;"><strong> 3.模型优点 </strong></span></h4> 
<ul><li>解耦。</li><li>支持并发。</li><li>支持忙闲不均 (哪边的线程忙可以多分配一些线程)</li></ul> 
<p><span style="color:#0d0016;">(1)如果我们在主函数中调用某一函数，那么我们必须等该函数体执行完后才继续执行主函数的后续代码，因此<strong>函数调用本质上是一种紧耦合</strong>。</span></p> 
<p><span style="color:#0d0016;">(2)对应到生产者消费者模型中，函数传参实际上就是生产者生产的过程，而执行函数体实际上就是消费者消费的过程，但生产者只负责生产数据，消费者只负责消费数据，在消费者消费期间生产者可以同时进行生产，因此<strong>生产者消费者模型本质是一种松耦合</strong>。</span></p> 
<p></p> 
<p>                </p> 
<p></p> 
<p>                </p> 
<h2 id="%E4%BA%8C.%E5%9F%BA%E4%BA%8EBlockingQueue%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span style="color:#0d0016;"><strong>二.基于BlockingQueue的生产者消费者模型</strong></span></h2> 
<h4><span style="color:#0d0016;"><strong>1.基本概念</strong></span></h4> 
<ul><li><span style="color:#333333;">在多线程编程中阻塞队列</span><span style="color:#333333;">(Blocking Queue)</span><span style="color:#333333;">是一种常用于实现生产者和消费者模型的数据结构。</span></li><li><span style="color:#333333;">其与普通的队列区别在于，当队列为空时，从队列获取元素的操作将会被阻塞，直到队列中被放入了元素</span></li><li><span style="color:#333333;">当队列满时，往队列里存放元 素的操作也会被阻塞，直到有元素被从队列中取出(</span><span style="color:#333333;">以上的操作都是基于不同的线程来说的，线程在对阻塞队列进行操作时会被阻塞)</span></li></ul> 
<p><img alt="" height="548" src="https://images2.imgbox.com/85/37/C8Uvrg40_o.png" width="1107"></p> 
<p>                 </p> 
<h4 id="2.%E5%8D%95%E7%94%9F%E4%BA%A7%E8%80%85%E3%80%81%E5%8D%95%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%BA%E4%BE%8B%E8%BF%9B%E8%A1%8C%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%C2%A0"><span style="color:#0d0016;"><strong>2.单生产者、单消费者为例进行模拟实现 </strong></span></h4> 
<p><span style="color:#0d0016;">(1) 生产和消费步调一致，生产一个消费一个</span></p> 
<p><span style="color:#0d0016;">①BlockQueue.hpp</span></p> 
<pre><code class="language-cpp">#pragma oncec

#include &lt;iostream&gt;
#include &lt;pthread.h&gt;
#include &lt;queue&gt;
#include &lt;unistd.h&gt;

#define NUM 5

template&lt;class T&gt;
class BlockQueue
{
private:
	bool IsFull()
	{
		return _q.size() == _cap;
	}
	bool IsEmpty()
	{
		return _q.empty();
	}

public:
	BlockQueue(int cap = NUM)
		: _cap(cap)
	{
		pthread_mutex_init(&amp;_mutex, nullptr);
		pthread_cond_init(&amp;_full, nullptr);
		pthread_cond_init(&amp;_empty, nullptr);
	}
	~BlockQueue()
	{
		pthread_mutex_destroy(&amp;_mutex);
		pthread_cond_destroy(&amp;_full);
		pthread_cond_destroy(&amp;_empty);
	}

public:
	//向阻塞队列插入数据（生产者调用）
	void Push(const T&amp; data)
	{
		pthread_mutex_lock(&amp;_mutex);
		while (IsFull()){
			//不能进行生产，直到阻塞队列可以容纳新的数据
			pthread_cond_wait(&amp;_full, &amp;_mutex);
		}
		_q.push(data);
		pthread_cond_signal(&amp;_empty); //唤醒在empty条件变量下等待的消费者线程

		pthread_mutex_unlock(&amp;_mutex);
	}

	//从阻塞队列获取数据（消费者调用）
	void Pop(T&amp; data)
	{
		pthread_mutex_lock(&amp;_mutex);
		while (IsEmpty()){
			//不能进行消费，直到阻塞队列有新的数据
			pthread_cond_wait(&amp;_empty, &amp;_mutex);
		}
		data = _q.front();
		_q.pop();

		pthread_cond_signal(&amp;_full); //唤醒在full条件变量下等待的生产者线程

		pthread_mutex_unlock(&amp;_mutex);
	}

private:
	std::queue&lt;T&gt; _q; //阻塞队列
	int _cap; //阻塞队列容纳数据的最大个数
	pthread_mutex_t _mutex;
	pthread_cond_t _full;  
	pthread_cond_t _empty; 
};
</code></pre> 
<p><span style="color:#0d0016;">程序说明:  </span></p> 
<ul><li>由于我们实现的是单生产者、单消费者的生产者消费者模型，因此我们不需要维护生产者和生产者之间的关系，也不需要维护消费者和消费者之间的关系，我们只需要维护生产者和消费者之间的同步与互斥关系即可。</li><li>将BlockingQueue当中存储的数据模板化，方便以后需要时进行复用。</li><li>这里设置BlockingQueue存储数据的上限为5，当阻塞队列中存储了五组数据时生产者就不能进行生产了，此时生产者就应该被阻塞。</li><li>阻塞队列是会被生产者和消费者同时访问的临界资源，因此我们需要用一把互斥锁将其保护起来。</li><li>生产者线程要向阻塞队列当中Push数据，前提是阻塞队列里面有空间，若阻塞队列已经满了，那么此时该生产者线程就需要进行等待，直到阻塞队列中有空间时再将其唤醒。</li><li>消费者线程要从阻塞队列当中Pop数据，前提是阻塞队列里面有数据，若阻塞队列为空，那么此时该消费者线程就需要进行等待，直到阻塞队列中有新的数据时再将其唤醒。</li><li>因此在这里我们需要用到两个条件变量，一个条件变量用来描述队列为空，另一个条件变量用来描述队列已满。<strong>当阻塞队列满了的时候，要进行生产的生产者线程就应该在full条件变量下进行等待；当阻塞队列为空的时候，要进行消费的消费者线程就应该在empty条件变量下进行等待。</strong></li><li>不论是生产者线程还是消费者线程，它们都是先申请到锁进入临界区后再判断是否满足生产或消费条件的，如果对应条件不满足，那么对应线程就会被挂起。但此时该线程是拿着锁的，为了避免死锁问题，在调用pthread_cond_wait函数时就需要传入当前线程手中的互斥锁，<strong>此时当该线程被挂起时就会自动释放手中的互斥锁，而当该线程被唤醒时又会自动获取到该互斥锁。</strong></li><li>当生产者生产完一个数据后，意味着阻塞队列当中至少有一个数据，而此时可能有消费者线程正在empty条件变量下进行等待，因此当生产者生产完数据后需要唤醒在empty条件变量下等待的消费者线程。</li><li>当消费者消费完一个数据后，意味着阻塞队列当中至少有一个空间，而此时可能有生产者线程正在full条件变量下进行等待，因此当消费者消费完数据后需要唤醒在full条件变量下等待的生产者线程。</li></ul> 
<p>                                 </p> 
<p><span style="color:#fe2c24;"><strong>判断是否满足生产消费条件时不能用if，而应该用while：</strong></span></p> 
<ul><li><span style="color:#0d0016;">pthread_cond_wait函数是让当前执行流进行等待的函数，是函数就意味着有可能调用失败，调用失败后该执行流就会继续往后执行,就会出现错误(没有数据还拿，没有空间还放)。</span></li><li><span style="color:#0d0016;">在多消费者的情况下，<strong>当生产者生产了一个数据后如果使用pthread_cond_broadcast函数唤醒消费者，就会一次性唤醒多个消费者，但待消费的数据只有一个，此时其他消费者就被伪唤醒了。</strong></span></li><li><span style="color:#0d0016;">为了避免出现上述情况，我们就要让线程被唤醒后再次进行判断，确认是否真的满足生产消费条件，因此这里必须要用while进行判断。</span><br>  </li></ul> 
<p>②main.cc</p> 
<pre><code class="language-cpp">#include "BlockQueue.hpp"

void* Producer(void* arg)
{
	BlockQueue&lt;int&gt;* bq = (BlockQueue&lt;int&gt;*)arg;
	//生产者不断进行生产
	while (true){
		sleep(1);
		int data = rand() % 100 + 1;
		bq-&gt;Push(data); //生产数据
		std::cout &lt;&lt; "Producer: " &lt;&lt; data &lt;&lt; std::endl;
	}
}

void* Consumer(void* arg)
{
	BlockQueue&lt;int&gt;* bq = (BlockQueue&lt;int&gt;*)arg;
	//消费者不断进行消费
	while (true){
		sleep(1);
		int data = 0;
		bq-&gt;Pop(data); //消费数据
		std::cout &lt;&lt; "Consumer: " &lt;&lt; data &lt;&lt; std::endl;
	}
}

int main()
{
	srand((unsigned int)time(nullptr));//生成随机数

	pthread_t producer, consumer;
	BlockQueue&lt;int&gt;* bq = new BlockQueue&lt;int&gt;;

	//创建生产者线程和消费者线程
	pthread_create(&amp;producer, nullptr, Producer, bq);
	pthread_create(&amp;consumer, nullptr, Consumer, bq);

	//join生产者线程和消费者线程
	pthread_join(producer, nullptr);
	pthread_join(consumer, nullptr);

	delete bq;
	return 0;
}</code></pre> 
<p>程序说明:</p> 
<ul><li>阻塞队列要让生产者线程向队列中Push数据，让消费者线程从队列中Pop数据，因此这个阻塞队列必须要让这两个线程同时看到，所以我们在创建生产者线程和消费者线程时，需要将该阻塞队列作为线程执行例程的参数进行传入。</li></ul> 
<p>                </p> 
<p><span style="color:#0d0016;">③结果 : 生产者是每隔一秒生产一个数据，所以消费者是每隔一秒消费一个数据，因此运行代码后我们可以看到生产者和消费者的执行步调是一致的。</span></p> 
<p><img alt="" height="323" src="https://images2.imgbox.com/46/3c/Ea7mYKHT_o.png" width="884"></p> 
<p>        </p> 
<p><span style="color:#0d0016;"> (2)生产快，消费慢</span></p> 
<p><span style="color:#0d0016;">①代码: 只需要改变main.cc中的执行函数</span></p> 
<pre><code class="language-cpp">void* Producer(void* arg)
{
	BlockQueue&lt;int&gt;* bq = (BlockQueue&lt;int&gt;*)arg;
	//生产者不断进行生产
	while (true){
		int data = rand() % 100 + 1;
		bq-&gt;Push(data); //生产数据
		std::cout &lt;&lt; "Producer: " &lt;&lt; data &lt;&lt; std::endl;
	}
}

void* Consumer(void* arg)
{
	BlockQueue&lt;int&gt;* bq = (BlockQueue&lt;int&gt;*)arg;
	//消费者不断进行消费
	while (true){
		sleep(1);
		int data = 0;
		bq-&gt;Pop(data); //消费数据
		std::cout &lt;&lt; "Consumer: " &lt;&lt; data &lt;&lt; std::endl;
	}
}</code></pre> 
<p><span style="color:#0d0016;"> ②结果: 生产者生产的很快，运行后一瞬间生产者就将阻塞队列打满了，此时生产者想要再进行生产就只能在full条件变量下进行等待，直到消费者消费完一个数据后，生产者才会被唤醒进而继续进行生产，生产者生产完一个数据后又会进行等待，因此后续生产者和消费者的步调又变成一致的了 ; 顺序消费。</span></p> 
<p><img alt="" height="401" src="https://images2.imgbox.com/a9/85/5oEurvOT_o.png" width="726"></p> 
<p>                                                        </p> 
<p><span style="color:#0d0016;">(3)生产慢，消费快</span></p> 
<p><span style="color:#0d0016;">①代码</span></p> 
<pre><code class="language-cpp">void* Producer(void* arg)
{
	BlockQueue&lt;int&gt;* bq = (BlockQueue&lt;int&gt;*)arg;
	//生产者不断进行生产
	while (true){
		sleep(1);
		int data = rand() % 100 + 1;
		bq-&gt;Push(data); //生产数据
		std::cout &lt;&lt; "Producer: " &lt;&lt; data &lt;&lt; std::endl;
	}
}
void* Consumer(void* arg)
{
	BlockQueue&lt;int&gt;* bq = (BlockQueue&lt;int&gt;*)arg;
	//消费者不断进行消费
	while (true){
		int data = 0;
		bq-&gt;Pop(data); //消费数据
		std::cout &lt;&lt; "Consumer: " &lt;&lt; data &lt;&lt; std::endl;
	}
}</code></pre> 
<p><span style="color:#0d0016;">②结果 : 虽然消费者消费的很快，但一开始阻塞队列中是没有数据的，因此消费者只能在empty条件变量下进行等待，直到生产者生产完一个数据后，消费者才会被唤醒进而进行消费，消费者消费完这一个数据后又会进行等待，因此生产者和消费者的步调就是一致的。</span></p> 
<p><img alt="" height="409" src="https://images2.imgbox.com/4c/1a/1WIUhnxn_o.png" width="1057"></p> 
<p>                </p> 
<p><span style="color:#0d0016;">(4) 生产/消费超过一定高低水位线再通知另一方</span></p> 
<p><span style="color:#0d0016;">①代码 : 生产者生产快不sleep，消费者消费慢sleep</span></p> 
<pre><code class="language-cpp">//向阻塞队列插入数据（生产者调用）
void Push(const T&amp; data)
{
	pthread_mutex_lock(&amp;_mutex);
	while (IsFull()){
		//不能进行生产，直到阻塞队列可以容纳新的数据
		pthread_cond_wait(&amp;_full, &amp;_mutex);
	}
	_q.push(data);

    //高低水位线
	if (_q.size() &gt;= _cap / 2){
		pthread_cond_signal(&amp;_empty); //唤醒在empty条件变量下等待的消费者线程
	}

	pthread_mutex_unlock(&amp;_mutex);
}

//从阻塞队列获取数据（消费者调用）
void Pop(T&amp; data)
{
	pthread_mutex_lock(&amp;_mutex);
	while (IsEmpty()){
		//不能进行消费，直到阻塞队列有新的数据
		pthread_cond_wait(&amp;_empty, &amp;_mutex);
	}
	data = _q.front();
	_q.pop();

    //高低水位线
	if (_q.size() &lt;= _cap / 2){
		pthread_cond_signal(&amp;_full); //唤醒在full条件变量下等待的生产者线程
	}

	pthread_mutex_unlock(&amp;_mutex);
}
</code></pre> 
<p><span style="color:#0d0016;">②结果 :运行代码后生产者还是一瞬间将阻塞队列打满后进行等待，但此时不是消费者消费一个数据就唤醒生产者线程，而是当阻塞队列当中的数据小于队列容器的一半时，才会唤醒生产者线程进行生产。</span></p> 
<p><img alt="" height="475" src="https://images2.imgbox.com/f3/5a/G2Vet2ky_o.png" width="1060"></p> 
<p>                </p> 
<h4 id="3.%E5%9F%BA%E4%BA%8E%E8%AE%A1%E7%AE%97%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span style="color:#0d0016;"><strong>3.基于计算任务的生产者消费者模型</strong></span></h4> 
<p><span style="color:#0d0016;">(1)代码 </span></p> 
<p><span style="color:#0d0016;">①Task.hpp : 定义一个Task类，这个类当中包含一个Run成员函数，该函数代表着如何让消费者处理拿到的数据</span>。</p> 
<pre><code class="language-cpp">#pragma once
#include &lt;iostream&gt;

class Task
{
public:
	Task(int x = 0, int y = 0, int op = 0)
		: _x(x), _y(y), _op(op)
	{}
	~Task()
	{}

	void Run()
	{
		int result = 0;
		switch (_op)
		{
		case '+':
			result = _x + _y;
			break;
		case '-':
			result = _x - _y;
			break;
		case '*':
			result = _x * _y;
			break;
		case '/':
			if (_y == 0){
				std::cout &lt;&lt; "Warning: div zero!" &lt;&lt; std::endl;
				result = -1;
			}
			else{
				result = _x / _y;
			}
			break;
		case '%':
			if (_y == 0){
				std::cout &lt;&lt; "Warning: mod zero!" &lt;&lt; std::endl;
				result = -1;
			}
			else{
				result = _x % _y;
			}
			break;
		default:
			std::cout &lt;&lt; "error operation!" &lt;&lt; std::endl;
			break;
		}
		std::cout &lt;&lt; _x &lt;&lt; _op &lt;&lt; _y &lt;&lt; "=" &lt;&lt; result &lt;&lt; std::endl;
	}

private:
	int _x;
	int _y;
	char _op;
};
</code></pre> 
<p><span style="color:#0d0016;">②main.cc : 对线程执行函数稍作修改, 此时生产者放入阻塞队列的数据就是一个Task对象，而消费者从阻塞队列拿到Task对象后，就可以用该对象调用Run成员函数进行数据处理。</span></p> 
<pre><code class="language-cpp">void* Producer(void* arg)
{
	BlockQueue&lt;Task&gt;* bq = (BlockQueue&lt;Task&gt;*)arg;
	const char* arr = "+-*/%";
	//生产者不断进行生产
	while (true){
		int x = rand() % 100;
		int y = rand() % 100;
		char op = arr[rand() % 5];
		Task t(x, y, op);
		bq-&gt;Push(t); //生产数据
		std::cout &lt;&lt; "producer task done" &lt;&lt; std::endl;
	}
}

void* Consumer(void* arg)
{
	BlockQueue&lt;Task&gt;* bq = (BlockQueue&lt;Task&gt;*)arg;
	//消费者不断进行消费
	while (true){
		sleep(1);
		Task t;
		bq-&gt;Pop(t); //消费数据
		t.Run(); //处理数据
	}
}</code></pre> 
<p>                 </p> 
<p>(2)结果 : 运行代码，当阻塞队列被生产者打满后消费者被唤醒，此时消费者在消费数据时执行的就是计算任务，当阻塞队列当中的数据被消费到低水位线时又会唤醒生产者进行生产。</p> 
<p><img alt="" height="442" src="https://images2.imgbox.com/03/af/QhcgIbPT_o.png" width="981"></p> 
<p>                </p> 
<p><span style="color:#0d0016;"> (3)小结</span></p> 
<p><span style="color:#0d0016;">我们想让生产者消费者模型处理某一种任务时，大体的框架已经搭建好了，就只需要提供对应的Task类，然后让该Task类提供一个对应的Run成员函数告诉我们应该如何处理这个任务即可</span></p> 
<p></p> 
<p></p> 
<p>                                </p> 
<p>                </p> 
<p>        </p> 
<p></p> 
<p>                </p> 
<h2 id="%E4%B8%89.POSIX%E4%BF%A1%E5%8F%B7%E9%87%8F"><span style="color:#0d0016;"><strong>三.POSIX信号量</strong></span></h2> 
<h4>1.基本概念</h4> 
<ul><li><strong>信号量（信号灯）本质是一个计数器，是描述临界资源中资源数目的计数器，<span style="color:#fe2c24;">信号量能够更细粒度的对临界资源进行管理</span>。</strong></li><li>每个执行流在进入临界区之前都应该先申请信号量，申请成功就有了操作特定的临界资源的权限，当操作完毕后就应该释放信号量</li><li>信号量存在的价值 : 1.进行同步与互斥    2.更细粒度的临界资源的管理<br>  </li></ul> 
<p><span style="color:#0d0016;">(1)为什么要有信号量？ 提高效率</span></p> 
<ul><li>当我们仅用一个互斥锁对临界资源进行保护时，相当于我们将这块临界资源看作一个整体，同一时刻只允许一个执行流对这块临界资源进行访问。</li><li>如果我们将这块临界资源再分割为多个区域，当多个执行流需要访问临界资源时，这些执行流访问的是临界资源的不同区域，那么我们可以让这些执行流同时访问临界资源的不同区域，此时不会出现数据不一致等问题。        </li></ul> 
<p><span style="color:#0d0016;">(2)信号量的PV操作：</span></p> 
<ul><li>P操作：我们将申请信号( count-- )量称为P操作，申请信号量的本质就是申请获得临界资源中某块资源的使用权限，当申请成功时临界资源中资源的数目应该减一，因此P操作的本质就是让计数器减一。</li><li>V操作：我们将释放信号量( count++ )称为V操作，释放信号量的本质就是归还临界资源中某块资源的使用权限，当释放成功时临界资源中资源的数目就应该加一，因此V操作的本质就是让计数器加一。</li></ul> 
<p><span style="color:#0d0016;">(3)PV操作必须是原子操作</span></p> 
<ul><li>多个执行流为了访问临界资源会竞争式的申请信号量，因此信号量是会被多个执行流同时访问的，也就是说信号量本质也是临界资源。</li><li>但信号量本质就是用于保护临界资源的，我们不可能再用信号量去保护信号量，所以信号量的PV操作必须是原子操作。</li><li>内存当中变量的++、--操作并不是原子操作，因此信号量不可能只是简单的对一个全局变量进行++、--操作。</li></ul> 
<p><span style="color:#0d0016;">(4)申请信号量失败被挂起等待</span></p> 
<ul><li>当执行流在申请信号量时，可能此时信号量的值为0，也就是说信号量描述的临界资源已经全部被申请了，此时该执行流就应该在该信号量的等待队列当中进行等待，直到有信号量被释放时再被唤醒。</li><li> 信号量的本质是计数器，但不意味着只有计数器，信号量还包括一个等待队列。</li></ul> 
<p><span style="color:#0d0016;">(5)信号量结构的大致理解伪代码:</span></p> 
<p><img alt="" height="338" src="https://images2.imgbox.com/d1/9f/QaAIeJyu_o.png" width="913"></p> 
<p>                 </p> 
<h4 id="2.%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%87%BD%E6%95%B0"><span style="color:#0d0016;"><strong>2.信号量函数</strong></span></h4> 
<p>(1) 初始化</p> 
<blockquote> 
 <p><span style="color:#0d0016;">函数 :  int sem_init(sem_t *sem, int pshared, unsigned int value);<br><br> 参数：</span></p> 
 <ul><li><span style="color:#0d0016;">sem：需要初始化的信号量。</span></li><li><span style="color:#0d0016;">pshared：传入0值表示线程间共享，传入非零值表示进程间共享(常用0)</span></li><li><span style="color:#0d0016;">value：信号量的初始值（计数器的初始值）。</span></li></ul> 
 <p></p> 
 <p><span style="color:#0d0016;">返回值： 初始化信号量成功返回0，失败返回-1。</span></p> 
 <p><br><span style="color:#0d0016;">注意： POSIX信号量和System V信号量作用相同，都是用于同步操作，达到无冲突的访问共享资源目的，但POSIX信号量可以用于线程间同步。</span></p> 
</blockquote> 
<p><span style="color:#0d0016;">(2)销毁</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;">函数 : int sem_destroy(sem_t *sem);</span><br>  </p> 
 <p><span style="color:#0d0016;">参数： sem：需要销毁的信号量。</span></p> 
 <p></p> 
 <p><span style="color:#0d0016;">返回值：销毁信号量成功返回0，失败返回-1。</span></p> 
</blockquote> 
<p><span style="color:#0d0016;">(3)等待信号量（申请信号量 ,P()）</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;">函数 : int sem_wait(sem_t *sem);</span></p> 
 <p><br><span style="color:#0d0016;">参数：sem：需要等待的信号量。</span></p> 
 <p><br><span style="color:#0d0016;">返回值：</span></p> 
 <ul><li><span style="color:#0d0016;">等待信号量成功返回0，信号量的值减一</span></li><li><span style="color:#0d0016;">等待信号量失败返回-1，信号量的值保持不变</span></li></ul> 
</blockquote> 
<p><span style="color:#0d0016;">(4)发布信号量（释放信号量,V()）</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;">函数 : int sem_post(sem_t *sem);<br><br> 参数：sem：需要发布的信号量。</span></p> 
 <p><br><span style="color:#0d0016;">返回值：</span></p> 
 <ul><li><span style="color:#0d0016;">发布信号量成功返回0，信号量的值加一</span></li><li><span style="color:#0d0016;">发布信号量失败返回-1，信号量的值保持不变</span></li></ul> 
</blockquote> 
<p></p> 
<p>        </p> 
<p>                </p> 
<p>                </p> 
<p></p> 
<h2 id="%E4%B8%89.%20%E4%BA%8C%E5%85%83%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E5%8A%9F%E8%83%BD%C2%A0%C2%A0"><span style="color:#0d0016;"><strong>三. 二元信号量模拟实现互斥功能  </strong></span></h2> 
<ul><li>信号量本质是一个计数器，如果将信号量的初始值设置为1，那么此时该信号量叫做二元信号量。</li><li>信号量的初始值为1，说明信号量所描述的临界资源只有一份，此时信号量的作用基本等价于互斥锁。</li></ul> 
<p></p> 
<p><span style="color:#0d0016;">示例，实现一个多线程抢票系统，使用二元信号量模拟实现多线程互斥,，让每个线程在访问全局变量tickets之前先申请信号量，访问完毕后再释放信号量，此时二元信号量就达到了互斥的效果。</span></p> 
<p>1.代码</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;

class Sem{
public:
	Sem(int num)
	{
		sem_init(&amp;_sem, 0, num);
	}
	~Sem()
	{
		sem_destroy(&amp;_sem);
	}
	void P()
	{
		sem_wait(&amp;_sem);
	}
	void V()
	{
		sem_post(&amp;_sem);
	}
private:
	sem_t _sem;
};


Sem sem(1); //二元信号量
int tickets = 1000;

void* TicketGrabbing(void* arg)
{
	std::string name = (char*)arg;
	while (true){
		sem.P();
		if (tickets &gt; 0){
			usleep(1000);
			std::cout &lt;&lt; name &lt;&lt; " get a ticket, tickets left: " &lt;&lt; --tickets &lt;&lt; std::endl;
			sem.V();
		}
		else{
			sem.V();
			break;
		}
	}
	std::cout &lt;&lt; name &lt;&lt; " quit..." &lt;&lt; std::endl;
	pthread_exit((void*)0);
}

int main()
{
	pthread_t tid1, tid2, tid3, tid4;
	pthread_create(&amp;tid1, nullptr, TicketGrabbing, (void*)"thread 1");
	pthread_create(&amp;tid2, nullptr, TicketGrabbing, (void*)"thread 2");
	pthread_create(&amp;tid3, nullptr, TicketGrabbing, (void*)"thread 3");
	pthread_create(&amp;tid4, nullptr, TicketGrabbing, (void*)"thread 4");
	
	pthread_join(tid1, nullptr);
	pthread_join(tid2, nullptr);
	pthread_join(tid3, nullptr);
	pthread_join(tid4, nullptr);
	return 0;
}</code></pre> 
<p>2.结果 : 未出现数据不一致问题 </p> 
<p><img alt="" height="321" src="https://images2.imgbox.com/2b/d8/2icLhYma_o.png" width="727"></p> 
<p></p> 
<p>                </p> 
<p>                </p> 
<p>                        </p> 
<p></p> 
<h2 id="%E5%9B%9B.%E5%9F%BA%E4%BA%8E%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span style="color:#0d0016;"><strong>四.基于环形队列的生产者消费者模型</strong></span></h2> 
<h4 id="1.%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E5%85%B3%E5%BF%83%E4%B8%8D%E5%90%8C%E8%B5%84%E6%BA%90"><strong><span style="color:#0d0016;">1.生产者和消费者关心不同资源</span></strong></h4> 
<p><span style="color:#0d0016;">(1)生产者关注的是空间资源，消费者关注的是数据资源</span></p> 
<ul><li>生产者关注的是环形队列当中是否有空间（blank），只要有空间生产者就可以进行生产。</li><li>消费者关注的是环形队列当中是否有数据（data），只要有数据消费者就可以进行消费。</li></ul> 
<p>         </p> 
<p><span style="color:#0d0016;">(2)blank_sem和data_sem的初始值设置</span></p> 
<p><span style="color:#0d0016;">现在我们用信号量来描述环形队列当中的空间资源（blank_sem）和数据资源（data_sem），在我们初始信号量时给它们设置的初始值是不同的：</span></p> 
<ul><li>blank_sem的初始值我们应该设置为环形队列的容量，因为刚开始时环形队列当中全是空间。</li><li>data_sem的初始值我们应该设置为0，因为刚开始时环形队列当中没有数据。</li></ul> 
<p>                 </p> 
<p><span style="color:#0d0016;">(3)生产者和消费者申请和释放资源</span></p> 
<p><span style="color:#0d0016;">①生产者申请空间资源，释放数据资源</span></p> 
<p><span style="color:#0d0016;">对于生产者来说，生产者每次生产数据前都需要先申请blank_sem：</span></p> 
<ul><li>如果blank_sem的值不为0，则信号量申请成功，此时生产者可以进行生产操作。</li><li>如果blank_sem的值为0，则信号量申请失败，此时生产者需要在blank_sem的等待队列下进行阻塞等待，直到环形队列当中有新的空间后再被唤醒。</li></ul> 
<p><span style="color:#0d0016;">当生产者生产完数据后，应该释放data_sem：</span></p> 
<ul><li>虽然生产者在进行生产前是对blank_sem进行的P操作，但是当生产者生产完数据，应该对data_sem进行V操作而不是blank_sem。</li><li>生产者在生产数据前申请到的是blank位置，当生产者生产完数据后，该位置当中存储的是生产者生产的数据，在该数据被消费者消费之前，该位置不再是blank位置，而应该是data位置。</li><li>当生产者生产完数据后，意味着环形队列当中多了一个data位置，因此我们应该对data_sem进行V操作。</li></ul> 
<p>                         </p> 
<p><span style="color:#0d0016;">②消费者申请数据资源，释放空间资源</span></p> 
<p><span style="color:#0d0016;">对于消费者来说，消费者每次消费数据前都需要先申请data_sem：</span></p> 
<ul><li><span style="color:#0d0016;">如果data_sem的值不为0，则信号量申请成功，此时消费者可以进行消费操作。</span></li><li><span style="color:#0d0016;">如果data_sem的值为0，则信号量申请失败，此时消费者需要在data_sem的等待队列下进行阻塞等待，直到环形队列当中有新的数据后再被唤醒。</span></li></ul> 
<p><span style="color:#0d0016;">当消费者消费完数据后，应该释放blank_sem：</span></p> 
<ul><li>虽然消费者在进行消费前是对data_sem进行的P操作，但是当消费者消费完数据，应该对blank_sem进行V操作而不是data_sem。</li><li>消费者在消费数据前申请到的是data位置，当消费者消费完数据后，该位置当中的数据已经被消费过了，再次被消费就没有意义了，为了让生产者后续可以在该位置生产新的数据，我们应该将该位置算作blank位置，而不是data位置。</li><li>当消费者消费完数据后，意味着环形队列当中多了一个blank位置，因此我们应该对blank_sem进行V操作。</li></ul> 
<p>                 </p> 
<h4 id="%C2%A02.%E9%9C%80%E8%A6%81%E9%81%B5%E5%AE%88%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8E%9F%E5%88%99"><span style="color:#0d0016;"><strong> 2.需要遵守的两个原则</strong></span></h4> 
<p><span style="color:#0d0016;">(1)生产者和消费者不能对同一个位置进行访问(互斥)</span></p> 
<ul><li>如果生产者和消费者访问的是环形队列当中的同一个位置，那么此时生产者和消费者就相当于同时对这一块临界资源进行了访问，这当然是不允许的。</li><li>而如果生产者和消费者访问的是环形队列当中的不同位置，那么此时生产者和消费者是可以同时进行生产和消费的，此时不会出现数据不一致等问题。</li></ul> 
<p><span style="color:#0d0016;">(2)无论是生产者还是消费者，都不应该将对方套一个圈以上(格子的数量有限)</span></p> 
<ul><li>生产者从消费者的位置开始一直按顺时针方向进行生产，如果生产者生产的速度比消费者消费的速度快，那么当生产者绕着消费者生产了一圈数据后再次遇到消费者，此时生产者就不应该再继续生产了，因为再生产就会覆盖还未被消费者消费的数据。</li><li>同理，消费者从生产者的位置开始一直按顺时针方向进行消费，如果消费者消费的速度比生产者生产的速度快，那么当消费者绕着生产者消费了一圈数据后再次遇到生产者，此时消费者就不应该再继续消费了，因为再消费就会消费到缓冲区中保存的废弃数据。<br>  </li></ul> 
<p>                         </p> 
<h4 id="3.%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span style="color:#0d0016;"><strong>3.代码模拟实现</strong></span></h4> 
<p><span style="color:#0d0016;">(1) 代码</span></p> 
<p><span style="color:#0d0016;">①RingQueue.hpp</span></p> 
<pre><code class="language-cpp">#pragma once

#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;
#include &lt;vector&gt;

#define NUM 10

template&lt;class T&gt;
class RingQueue
{
private:
	//P操作
	void P(sem_t&amp; s)
	{
		sem_wait(&amp;s);
	}
	//V操作
	void V(sem_t&amp; s)
	{
	    sem_post(&amp;s);
	}
public:
	RingQueue(int cap = NUM)
		: _cap(cap), _p_pos(0), _c_pos(0)
	{
		_q.resize(_cap);
		sem_init(&amp;_blank_sem, 0, _cap); //blank_sem初始值设置为环形队列的容量
		sem_init(&amp;_data_sem, 0, 0); //data_sem初始值设置为0
	}
	~RingQueue()
	{
	sem_destroy(&amp;_blank_sem);
	sem_destroy(&amp;_data_sem);
	}

public:
	//向环形队列插入数据（生产者调用）
	void Push(const T&amp; data)
	{
		P(_blank_sem); //生产者关注空间资源
		_q[_p_pos] = data;
		V(_data_sem); //生产

		//更新下一次生产的位置
		_p_pos++;
		_p_pos %= _cap;
	}

	//从环形队列获取数据（消费者调用）
	void Pop(T&amp; data)
	{
		P(_data_sem); //消费者关注数据资源
		data = _q[_c_pos];
		V(_blank_sem);

		//更新下一次消费的位置
		_c_pos++;
		_c_pos %= _cap;
	}

private:
	std::vector&lt;T&gt; _q; //环形队列
	int _cap; //环形队列的容量上限
	int _p_pos; //生产位置
	int _c_pos; //消费位置
	sem_t _blank_sem; //描述空间资源
	sem_t _data_sem; //描述数据资源
};</code></pre> 
<p><span style="color:#0d0016;">程序解释: </span></p> 
<ul><li>当不设置环形队列的大小时，我们默认将环形队列的容量上限设置为10。</li><li>代码中的RingQueue是用vector实现的，生产者每次生产的数据放到vector下标为p_pos的位置，消费者每次消费的数据来源于vector下标为c_pos的位置。</li><li>生产者每次生产数据后p_pos都会进行++，标记下一次生产数据的存放位置，++后的下标会与环形队列的容量进行取模运算，实现“环形”的效果。</li><li>消费者每次消费数据后c_pos都会进行++，标记下一次消费数据的来源位置，++后的下标会与环形队列的容量进行取模运算，实现“环形”的效果。</li><li>p_pos只会由生产者线程进行更新，c_pos只会由消费者线程进行更新，对这两个变量访问时不需要进行保护，因此代码中将p_pos和c_pos的更新放到了V操作之后，就是为了尽量减少临界区的代码 , 提高效率</li><li>这里也可以设置高低水位线，数据/空格子数量达到一定程度再消费<br>  </li></ul> 
<p><span style="color:#0d0016;">②main.cc实现单生产者，单消费者模型</span></p> 
<pre><code class="language-cpp">#include "RingQueue.hpp"

void* Producer(void* arg)
{
	RingQueue&lt;int&gt;* rq = (RingQueue&lt;int&gt;*)arg;
	while (true){
		sleep(1);
		int data = rand() % 100 + 1;
		rq-&gt;Push(data);
		std::cout &lt;&lt; "Producer: " &lt;&lt; data &lt;&lt; std::endl;
	}
}

void* Consumer(void* arg)
{
	RingQueue&lt;int&gt;* rq = (RingQueue&lt;int&gt;*)arg;
	while (true){
		sleep(1);
		int data = 0;
		rq-&gt;Pop(data);
		std::cout &lt;&lt; "Consumer: " &lt;&lt; data &lt;&lt; std::endl;
	}
}

int main()
{
	srand((unsigned int)time(nullptr));

	pthread_t producer, consumer;
	RingQueue&lt;int&gt;* rq = new RingQueue&lt;int&gt;;
	pthread_create(&amp;producer, nullptr, Producer, rq);
	pthread_create(&amp;consumer, nullptr, Consumer, rq);
	
	pthread_join(producer, nullptr);
	pthread_join(consumer, nullptr);
	delete rq;
	return 0;
}</code></pre> 
<ul><li> 环形队列要让生产者线程向队列中Push数据，让消费者线程从队列中Pop数据，因此这个环形队列必须要让这两个线程同时看到，所以我们在创建生产者线程和消费者线程时，需要将环形队列作为线程执行例程的参数进行传入</li></ul> 
<p>                 </p> 
<p><span style="color:#0d0016;">(2)结果</span></p> 
<p><span style="color:#0d0016;">①生产者消费者同步</span></p> 
<p><img alt="" height="380" src="https://images2.imgbox.com/a3/c2/7X7jvpGf_o.png" width="1167"></p> 
<p><span style="color:#0d0016;">②生产快消费慢</span></p> 
<p><img alt="" height="562" src="https://images2.imgbox.com/51/df/PFHsApqm_o.png" width="1200"></p> 
<ul><li>生产者生产的很快，运行代码后一瞬间生产者就将环形队列打满了，此时生产者想要再进行生产，但空间资源已经为0了，于是生产者只能在blank_sem的等待队列下进行阻塞等待，直到由消费者消费完一个数据后对blank_sem进行了V操作，生产者才会被唤醒进而继续进行生产。</li><li>但由于生产者的生产速度很快，生产者生产完一个数据后又会进行等待，因此后续生产者和消费者的步调又变成一致的了。</li></ul> 
<p>                 </p> 
<p><span style="color:#0d0016;">③生产慢消费快 </span></p> 
<p><img alt="" height="352" src="https://images2.imgbox.com/2d/03/2W8BOBdi_o.png" width="1104"></p> 
<ul><li>虽然消费者消费的很快，但一开始环形队列当中的数据资源为0，因此消费者只能在data_sem的等待队列下进行阻塞等待，直到生产者生产完一个数据后对data_sem进行了V操作，消费者才会被唤醒进而进行消费。</li><li>但由于消费者的消费速度很快，消费者消费完一个数据后又会进行等待，因此后续生产者和消费者的步调又变成一致的了。</li></ul> 
<p>                                        </p> 
<h4 id="4.%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%C2%A0">4.信号量保护环形队列 </h4> 
<p><span style="color:#0d0016;">(1)在blank_sem和data_sem两个信号量的保护后，该环形队列中不可能会出现数据不一致的问题。</span></p> 
<p><span style="color:#0d0016;">①因为只有当生产者和消费者指向同一个位置并访问时，才会导致数据不一致的问题，而此时生产者和消费者在对环形队列进行写入或读取数据时，只有两种情况会指向同一个位置：</span></p> 
<ul><li><span style="color:#0d0016;">环形队列为空时</span></li><li><span style="color:#0d0016;">环形队列为满时</span></li></ul> 
<p><span style="color:#0d0016;">②但是在这两种情况下，生产者和消费者不会同时对环形队列进行访问：</span></p> 
<ul><li><span style="color:#0d0016;">当环形队列为空的时，消费者一定不能进行消费，因为此时数据资源为0</span></li><li><span style="color:#0d0016;">当环形队列为满的时，生产者一定不能进行生产，因为此时空间资源为0</span></li></ul> 
<p><span style="color:#0d0016;">                         </span></p> 
<p><span style="color:#0d0016;">(2)当环形队列为空和满时，我们已经<strong>通过信号量保证了生产者和消费者的串行化过程</strong>。而除了这两种情况之外，生产者和消费者指向的都不是同一个位置，因此该环形队列当中不可能会出现数据不一致的问题。并且大部分情况下生产者和消费者指向并不是同一个位置，因此大部分情况下该环形队列可以让生产者和消费者并发的执行.</span><br>  </p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0ecf9f62f02f28082b316891a61bd75f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SQLserver连接IDEA报错 java.lang.ClassNotFoundException: com.microsoft.sqlserver.jdbc.SQLServerDriver问题解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f06be36507f7ab33fe043ac0bd399685/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">centos stream 8 升级和切换python版本的简单方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>