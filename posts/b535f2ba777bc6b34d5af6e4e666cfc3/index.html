<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Go学习圣经：队列削峰&#43;批量写入 超高并发原理和实操 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Go学习圣经：队列削峰&#43;批量写入 超高并发原理和实操" />
<meta property="og:description" content="说在前面： 本文是《Go学习圣经》 的第二部分。
第一部分请参见：Go学习圣经：0基础精通GO开发与高并发架构（1）
现在拿到offer超级难，甚至连面试电话，一个都搞不到。
尼恩的技术社群中（50&#43;），很多小伙伴凭借 “左手云原生&#43;右手大数据”的绝活，拿到了offer，并且是非常优质的offer，据说年终奖都足足18个月。
从Java高薪岗位和就业岗位来看，云原生、K8S、GO 现在对于 高级工程师/架构师来说，越来越重要。尼恩从架构师视角出发，基于自己的尼恩 3高架构师知识体系和知识宇宙，写一本《GO学习圣经》
最终的学习目标 咱们的目标，不仅仅在于 GO 应用编程自由，更在于 GO 架构自由。
前段时间，一个2年小伙伴希望涨薪到18K， 尼恩把GO 语言的项目架构，给他写入了简历，导致他的简历金光闪闪，脱胎换股，完全可以去拿头条、腾讯等30K的offer， 年薪可以直接多 20W。
足以说明，GO 架构的含金量。
另外，前面尼恩的云原生是没有涉及GO的，但是，没有GO的云原生是不完整的。
所以， GO语言、GO架构学习完了之后，咱们在去打个回马枪，完成云原生的第二部分: 《Istio &#43; K8S CRD的架构与开发实操》 , 帮助大家彻底穿透云原生。
本文目录 文章目录 说在前面：最终的学习目标本文目录 并发编程Go 协程创建Go 协程（Goroutine）Go标准库 协程同步Mutex互斥锁同步WaitGroup 等待组Cond（条件变量） channel 通道channel 通道（/信道）的两个基本操作附录：make 函数如何使用？range遍历 和 通道关闭 closeclose Channel 的一些说明 多通道查询select 语句/通道的多路复用Go的select 和 OS的select 对比非阻塞查询 带缓冲的通道 Java BlockingQueue 和 Go channel 对比学习SynchronousQueue VS 无缓冲channelLinkedBlockingQueue VS 缓冲通道 buffered channel操作对比go rocketmq 编程实例：使用 RocketMQ 的 Go 客户端来发送和接收消息消息发送和接受的验证启动 rocketmq启动 go 实例 附录：Go 模块的安装和使用启用 Go 模块创建新项目go." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/b535f2ba777bc6b34d5af6e4e666cfc3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-24T21:22:05+08:00" />
<meta property="article:modified_time" content="2023-05-24T21:22:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Go学习圣经：队列削峰&#43;批量写入 超高并发原理和实操</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_3"></a>说在前面：</h3> 
<p>本文是《Go学习圣经》 的第二部分。</p> 
<p>第一部分请参见：<a href="https://blog.csdn.net/crazymakercircle/article/details/130803296">Go学习圣经：0基础精通GO开发与高并发架构（1）</a></p> 
<p>现在<strong>拿到offer超级难</strong>，甚至连面试电话，一个都搞不到。</p> 
<p>尼恩的技术社群中（50+），很多小伙伴凭借 “左手云原生+右手大数据”的绝活，拿到了offer，并且是非常优质的offer，<strong>据说年终奖都足足18个月</strong>。</p> 
<p>从Java高薪岗位和就业岗位来看，云原生、K8S、GO 现在对于 高级工程师/架构师来说，越来越重要。尼恩从架构师视角出发，基于自己的尼恩 3高架构师知识体系和知识宇宙，写一本《GO学习圣经》</p> 
<img src="https://images2.imgbox.com/16/b1/SxyTyG3V_o.png" width="500"> 
<h3><a id="_21"></a>最终的学习目标</h3> 
<p>咱们的目标，不仅仅在于 GO 应用编程自由，更在于 GO 架构自由。</p> 
<p>前段时间，<strong>一个2年小伙伴希望涨薪到18K， 尼恩把GO 语言的项目架构，给他写入了简历，导致他的简历金光闪闪，脱胎换股，完全可以去拿头条、腾讯等30K的offer， 年薪可以直接多 20W</strong>。</p> 
<p>足以说明，GO 架构的含金量。</p> 
<p>另外，前面尼恩的云原生是没有涉及GO的，但是，没有GO的云原生是不完整的。</p> 
<p>所以， GO语言、GO架构学习完了之后，咱们在去打个回马枪，完成云原生的第二部分: <strong>《Istio + K8S CRD的架构与开发实操》</strong> , 帮助大家彻底穿透云原生。</p> 
<img src="https://images2.imgbox.com/b3/14/OFkeShgU_o.jpg" width="500"> 
<h3><a id="_44"></a>本文目录</h3> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_3" rel="nofollow">说在前面：</a></li><li><a href="#_21" rel="nofollow">最终的学习目标</a></li><li><a href="#_44" rel="nofollow">本文目录</a></li></ul> 
  </li><li><a href="#_47" rel="nofollow">并发编程</a></li><li><ul><li><a href="#Go__51" rel="nofollow">Go 协程</a></li><li><ul><li><a href="#Go_Goroutine_77" rel="nofollow">创建Go 协程（Goroutine）</a></li><li><a href="#Go__123" rel="nofollow">Go标准库 协程同步</a></li><li><a href="#Mutex_137" rel="nofollow">Mutex互斥锁同步</a></li><li><a href="#WaitGroup__197" rel="nofollow">WaitGroup 等待组</a></li><li><a href="#Cond_264" rel="nofollow">Cond（条件变量）</a></li></ul> 
   </li><li><a href="#channel__367" rel="nofollow">channel 通道</a></li><li><ul><li><a href="#channel__373" rel="nofollow">channel 通道（/信道）的两个基本操作</a></li><li><a href="#make__441" rel="nofollow">附录：make 函数如何使用？</a></li><li><a href="#range___close_482" rel="nofollow">range遍历 和 通道关闭 close</a></li><li><ul><li><a href="#close_Channel__556" rel="nofollow">close Channel 的一些说明</a></li></ul> 
    </li><li><a href="#select__567" rel="nofollow">多通道查询select 语句/通道的多路复用</a></li><li><ul><li><a href="#Goselect__OSselect__626" rel="nofollow">Go的select 和 OS的select 对比</a></li><li><a href="#_636" rel="nofollow">非阻塞查询</a></li></ul> 
    </li><li><a href="#_701" rel="nofollow">带缓冲的通道</a></li></ul> 
   </li><li><a href="#Java__BlockingQueue__Go__channel__772" rel="nofollow">Java BlockingQueue 和 Go channel 对比学习</a></li><li><ul><li><a href="#SynchronousQueue_VS_channel_818" rel="nofollow">SynchronousQueue VS 无缓冲channel</a></li><li><a href="#LinkedBlockingQueue_VS__buffered___channel_839" rel="nofollow">LinkedBlockingQueue VS 缓冲通道 buffered channel</a></li><li><a href="#_849" rel="nofollow">操作对比</a></li><li><a href="#go__rocketmq__893" rel="nofollow">go rocketmq 编程</a></li><li><ul><li><a href="#_RocketMQ__Go__911" rel="nofollow">实例：使用 RocketMQ 的 Go 客户端来发送和接收消息</a></li><li><a href="#_1012" rel="nofollow">消息发送和接受的验证</a></li><li><a href="#_rocketmq_1014" rel="nofollow">启动 rocketmq</a></li><li><a href="#_go__1025" rel="nofollow">启动 go 实例</a></li></ul> 
    </li><li><a href="#Go__1064" rel="nofollow">附录：Go 模块的安装和使用</a></li><li><ul><li><a href="#_Go__1082" rel="nofollow">启用 Go 模块</a></li><li><a href="#_1092" rel="nofollow">创建新项目</a></li><li><a href="#gomod_1119" rel="nofollow">go.mod</a></li><li><a href="#_1173" rel="nofollow">安装第三方库</a></li><li><a href="#_1216" rel="nofollow">下载依赖项</a></li><li><a href="#_1228" rel="nofollow">管理依赖项</a></li></ul> 
    </li><li><a href="#GoLand__Go_go_mod_1248" rel="nofollow">GoLand 中使用 Go 模块（go mod）管理依赖项</a></li><li><ul><li><a href="#_Go__1252" rel="nofollow">**打开或创建一个 Go 项目**</a></li><li><a href="#_1280" rel="nofollow">添加依赖项</a></li><li><a href="#require_1302" rel="nofollow">解决require内依赖全部飘红问题</a></li><li><a href="#_1318" rel="nofollow">管理依赖关系</a></li><li><a href="#_1336" rel="nofollow">构建和运行项目</a></li></ul> 
   </li></ul> 
   </li><li><a href="#gorm_mysql_1350" rel="nofollow">gorm 操作mysql</a></li><li><ul><li><a href="#ORM_1352" rel="nofollow">什么是ORM？</a></li><li><a href="#gorm_1373" rel="nofollow">gorm介绍</a></li><li><a href="#gorm_1385" rel="nofollow">gorm安装</a></li><li><a href="#gorm_1425" rel="nofollow">gorm模型定义</a></li><li><a href="#3gorm_1470" rel="nofollow">3、gorm模型标签</a></li><li><a href="#_1496" rel="nofollow">定义表名</a></li><li><a href="#gormModel_1519" rel="nofollow">gorm.Model</a></li><li><a href="#_1546" rel="nofollow">自动更新时间</a></li></ul> 
   </li><li><a href="#gorm_1574" rel="nofollow">gorm连接数据库</a></li><li><ul><li><a href="#1DSN_Data_Source_Name_1586" rel="nofollow">1、配置DSN (Data Source Name)</a></li><li><a href="#2gormOpen_1642" rel="nofollow">2、使用gorm.Open连接数据库</a></li><li><a href="#3gorm_1679" rel="nofollow">3、gorm调试模式</a></li><li><a href="#4gorm_1695" rel="nofollow">4、gorm连接池</a></li></ul> 
   </li><li><a href="#CRUD_1774" rel="nofollow">CRUD操作</a></li><li><ul><li><a href="#_1778" rel="nofollow">插入数据</a></li><li><a href="#_1801" rel="nofollow">查询数据</a></li><li><a href="#_1826" rel="nofollow">更新数据</a></li><li><a href="#_1847" rel="nofollow">删除数据</a></li><li><a href="#gomysql_1869" rel="nofollow">go与mysql数据类型关系</a></li><li><a href="#mysql_1873" rel="nofollow">mysql日期时间格式</a></li><li><a href="#go__mysql_TIMESTAMP_1877" rel="nofollow">go 存储 mysql TIMESTAMP格式</a></li></ul> 
   </li><li><a href="#__DB_1896" rel="nofollow">高并发实操： 消息队列削峰解耦+ 批量写入DB</a></li><li><ul><li><a href="#_1898" rel="nofollow">为什么要使用消息队列</a></li><li><ul><li><a href="#_1910" rel="nofollow">削峰</a></li><li><a href="#_1923" rel="nofollow">解耦</a></li><li><a href="#_1942" rel="nofollow">异步</a></li></ul> 
    </li><li><a href="#GO_1958" rel="nofollow">实操：用GO实现消息队列削峰解耦</a></li><li><a href="#MySQL_2033" rel="nofollow">为什么应该使用批量插入来提高MySQL性能？</a></li><li><a href="#GO_2059" rel="nofollow">实操：用GO实现批量写入</a></li><li><a href="#_2131" rel="nofollow">执行效果</a></li></ul> 
   </li><li><a href="#Golang__GC_2139" rel="nofollow">Golang GC垃圾回收器</a></li><li><ul><li><a href="#Cache__Buffer_2141" rel="nofollow">Cache 和 Buffer的区别</a></li><li><a href="#Golang_GC_2165" rel="nofollow">Golang GC发展史</a></li></ul> 
   </li><li><a href="#_5W_2196" rel="nofollow">还有 5W字待发布</a></li><li><a href="#_2207" rel="nofollow">参考资料</a></li><li><a href="#_PDF_2222" rel="nofollow">技术自由的实现路径 PDF：</a></li><li><ul><li><ul><li><a href="#__2224" rel="nofollow">实现你的 架构自由：</a></li><li><a href="#___2242" rel="nofollow">实现你的 响应式 自由：</a></li><li><a href="#_spring_cloud__2250" rel="nofollow">实现你的 spring cloud 自由：</a></li><li><a href="#_linux__2261" rel="nofollow">实现你的 linux 自由：</a></li><li><a href="#___2267" rel="nofollow">实现你的 网络 自由：</a></li><li><a href="#___2275" rel="nofollow">实现你的 分布式锁 自由：</a></li><li><a href="#___2283" rel="nofollow">实现你的 王者组件 自由：</a></li><li><a href="#___2295" rel="nofollow">实现你的 面试题 自由：</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_47"></a>并发编程</h2> 
<p>Go 将并发结构作为核心语言的一部分提供。</p> 
<h3><a id="Go__51"></a>Go 协程</h3> 
<p>Go 协程（Goroutine）是 Go 语言中的一种轻量级线程实现。</p> 
<p>Go 协程（Goroutine）通过在单个线程内同时运行多个函数来实现并发，从而避免了线程切换的开销，并且能够更加高效地利用系统资源。</p> 
<p>与传统的线程模型不同，Go 协程不是由操作系统内核调度的，而是由 Go 运行时（runtime）自己调度的。</p> 
<p>为啥是轻量级线程呢？Go 协程（Goroutine）可以避免因为线程调度引起的额外开销，并且能够更好地控制协程的数量和调度机制。</p> 
<p>创建一个协程非常简单，只需要在函数调用前面添加 go 关键字即可，例如：</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这段代码会创建一个新的协程，并在其中执行匿名函数中的代码。</p> 
<p>这个协程会在后台运行，不会阻塞主线程的执行。</p> 
<h4><a id="Go_Goroutine_77"></a>创建Go 协程（Goroutine）</h4> 
<p>Go 程（goroutine）是由 Go 运行时管理的轻量级线程。</p> 
<p>创建一个协程非常简单，只需要在函数调用前面添加 go 关键字即可</p> 
<pre><code class="prism language-go"><span class="token keyword">go</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span>
</code></pre> 
<p>上面的代码，会启动一个新的 Go 协程（Goroutine）去执行 f(x, y, z) 函数， <code>x</code>, <code>y</code> 和 <code>z</code> 的求值发生在当前的 Go协 程中，而 <code>f</code> 的执行发生在新的 Go 协程中。</p> 
<p>下面是一个例子</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> cocurrent

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">say</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
		time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"字符 %s: %d  \n"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> i<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">GoroutineDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">go</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token string">"sync world "</span><span class="token punctuation">)</span>
	<span class="token function">say</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/80/cb/cegpYNUi_o.png" alt=""></p> 
<p>执行的结果</p> 
<p><img src="https://images2.imgbox.com/d7/9a/KGbJdDoF_o.png" alt=""></p> 
<p>Go 协程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。</p> 
<h4><a id="Go__123"></a>Go标准库 协程同步</h4> 
<p>Go 标准库中提供了多种同步机制，可以满足不同场景下的需求。以下是 Go 中常用的同步机制：</p> 
<ol><li>Mutex：互斥锁，用于保护临界区（critical section）代码，只允许一个协程进入临界区执行代码，其他协程需要等待。使用 sync.Mutex 类型来定义互斥锁。</li><li>RWMutex：读写锁，用于保证在读操作时允许多个协程同时访问资源，在写操作时只允许一个协程进入临界区修改资源。使用 sync.RWMutex 类型来定义读写锁。</li><li>WaitGroup：等待组，用于等待一组并发协程执行完成后再继续执行。使用 sync.WaitGroup 类型来定义等待组。</li><li>Cond：条件变量，用于在协程之间同步和通信。使用 sync.Cond 类型来定义条件变量。</li><li>Once：单次执行，用于确保某个操作只会被执行一次。使用 sync.Once 类型来定义单次执行。</li></ol> 
<p>这些同步机制都可以帮助我们更好地控制协程的执行顺序和并发访问共享资源的安全性。在实际开发中，我们需要根据具体情况选择合适的同步机制，并且要注意避免死锁等问题。</p> 
<h4><a id="Mutex_137"></a>Mutex互斥锁同步</h4> 
<p>这里涉及的概念叫做 互斥（mutual exclusion） ，我们通常使用互斥锁（Mutex）这一数据结构来提供这种机制。</p> 
<p>Go 中的 Mutex（互斥锁）是一种最基本的同步机制，用于保护临界区代码，只允许一个协程进入临界区执行代码，其他协程需要等待。在 Go 标准库中，可以使用 sync.Mutex 类型来定义互斥锁。</p> 
<p>Go 标准库中提供了 <a href="https://go-zh.org/pkg/sync/#Mutex" rel="nofollow"><code>sync.Mutex</code></a> 互斥锁类型及其两个方法：</p> 
<ul><li><code>Lock</code></li><li><code>Unlock</code></li></ul> 
<p>我们可以通过在代码前调用 <code>Lock</code> 方法，在代码后调用 <code>Unlock</code> 方法来保证一段代码的互斥执行。参见 <code>Inc</code> 方法。</p> 
<p>我们也可以用 <code>defer</code> 语句来保证互斥锁一定会被解锁。参见 <code>Value</code> 方法。</p> 
<blockquote> 
 <p>sync.Mutex类似于java 里边的 Lock 显示锁。 关于java显示锁，请参见 尼恩《Java 高并发核心编程 卷2 加强版》</p> 
</blockquote> 
<p>啰嗦一下，sync.Mutex 类型包含两个方法：</p> 
<ol><li>Lock()：获得互斥锁，如果当前锁已经被其他协程获得，就会一直等待，直到锁被释放为止。</li><li>Unlock()：释放互斥锁，允许其他协程获得锁并进入临界区。</li></ol> 
<p>下面是一个使用 Mutex 实现协程同步的例子：</p> 
<pre><code class="prism language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"sync"</span>
<span class="token punctuation">)</span>

<span class="token keyword">var</span> counter <span class="token builtin">int</span>

<span class="token keyword">func</span> <span class="token function">MutexDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup
	<span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex
	wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			counter<span class="token operator">++</span>
			mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Counter:"</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个例子中，我们创建了一个计数器 counter，并启动了 100 个协程对其进行累加操作。由于对 counter 的访问是并发的，因此需要使用互斥锁 mu 来保护它，以避免不同协程之间的竞争条件。</p> 
<p>在每个协程中，首先使用 mu.Lock() 方法获得互斥锁，然后对 counter 进行加 1 操作，并最终使用 mu.Unlock() 方法释放互斥锁。由于只有一个协程可以同时获得互斥锁并进入临界区，因此可以保证对 counter 的操作是安全的。</p> 
<p>最后，我们使用 sync.WaitGroup 来等待所有协程执行完毕，并输出最终的计数器值。</p> 
<h4><a id="WaitGroup__197"></a>WaitGroup 等待组</h4> 
<p>在 Go 中，可以使用 sync.WaitGroup 来等待一组协程完成执行。</p> 
<blockquote> 
 <p>sync.WaitGroup 类似于java 里边的闭锁。 关于java闭锁，请参见 尼恩《Java 高并发核心编程 卷2 加强版》</p> 
</blockquote> 
<p>sync.WaitGroup 类型提供了三个方法：</p> 
<ol><li>Add(delta int)：将 WaitGroup 的计数器加上 delta 值。如果 delta 是负数，则会 panic。</li><li>Done()：将 WaitGroup 的计数器减 1。相当于 Add(-1)。</li><li>Wait()：阻塞当前协程，直到 WaitGroup 的计数器为 0。</li></ol> 
<p>下面是一个使用 sync.WaitGroup 实现并发下载的例子：</p> 
<pre><code class="prism language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"sync"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    urls <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{<!-- --></span>
        <span class="token string">"https://www.google.com"</span><span class="token punctuation">,</span>
        <span class="token string">"https://www.bing.com"</span><span class="token punctuation">,</span>
        <span class="token string">"https://www.yahoo.com"</span><span class="token punctuation">,</span>
        <span class="token string">"https://www.baidu.com"</span><span class="token punctuation">,</span>
        <span class="token string">"https://www.amazon.com"</span><span class="token punctuation">,</span>
        <span class="token string">"https://www.apple.com"</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup

    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> url <span class="token operator">:=</span> <span class="token keyword">range</span> urls <span class="token punctuation">{<!-- --></span>
        wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token function">download</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"All downloads completed."</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">download</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Downloading %s...\n"</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span>
    <span class="token comment">// 模拟下载操作</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个例子中，我们定义了一个 urls 列表，包含了需要下载的网址。</p> 
<p>然后创建了一个 sync.WaitGroup 对象 wg，并通过调用 wg.Add(1) 把计数器置为 1。</p> 
<p>接着使用 for 循环遍历 urls 列表，对每个网址都启动一个新的协程，并在协程中调用 download() 函数来下载网页内容。</p> 
<p>在协程中，通过 defer wg.Done() 将 WaitGroup 的计数器减 1，表示当前协程已经完成了下载任务。</p> 
<p>最后，主程序调用 wg.Wait() 来等待所有协程执行完毕，并输出提示信息表示所有下载任务都已经完成了。</p> 
<h4><a id="Cond_264"></a>Cond（条件变量）</h4> 
<p>Go 中的 Cond（条件变量）是一种同步机制，用于在协程之间同步和通信。</p> 
<p>Cond 是基于 Mutex 和 WaitGroup 实现的，它可以让一个或多个协程等待某个条件满足后再执行下一步操作。</p> 
<p>在 Go 标准库中，可以使用 sync.Cond 类型来定义条件变量。</p> 
<p>sync.Cond 类型包含三个方法：</p> 
<ol><li>Broadcast()：唤醒所有正在等待条件变量的协程。</li><li>Signal()：唤醒一个正在等待条件变量的协程。</li><li>Wait()：阻塞当前协程，并解锁 Mutex，直到收到 Broadcast 或 Signal 信号后才会被唤醒并重新获得 Mutex。</li></ol> 
<p>下面是一个使用 Cond 实现生产者-消费者模型的例子：</p> 
<pre><code class="prism language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"sync"</span>
<span class="token punctuation">)</span>

<span class="token keyword">const</span> capacity <span class="token operator">=</span> <span class="token number">5</span>

<span class="token keyword">var</span> queue <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>
<span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex
<span class="token keyword">var</span> cond <span class="token operator">=</span> sync<span class="token punctuation">.</span><span class="token function">NewCond</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mu<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup
    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>

    <span class="token comment">// 生产者协程</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> capacity<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
            mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

            <span class="token keyword">for</span> <span class="token function">len</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span> <span class="token operator">==</span> capacity <span class="token punctuation">{<!-- --></span>
                cond<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            queue <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> i<span class="token punctuation">)</span>
            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Produce:"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>

            <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{<!-- --></span>
                cond<span class="token punctuation">.</span><span class="token function">Signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// 消费者协程</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> capacity<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
            mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

            <span class="token keyword">for</span> <span class="token function">len</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
                cond<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            item <span class="token operator">:=</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
            queue <span class="token operator">=</span> queue<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Consume:"</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span>

            <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span> <span class="token operator">==</span> capacity<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">{<!-- --></span>
                cond<span class="token punctuation">.</span><span class="token function">Signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个例子中，我们定义了一个长度为 5 的队列，然后创建了两个协程，一个用来生产数据，另一个用来消费数据。</p> 
<p>在协程中，使用 sync.Mutex 和 sync.Cond 对象来保护和同步共享资源。</p> 
<p>在生产者协程中，首先调用 mu.Lock() 获取互斥锁，然后使用 for 循环判断队列是否已满，</p> 
<ul><li>如果已满则调用 cond.Wait() 阻塞当前协程，等待消费者协程唤醒。</li><li>如果队列未满，则将数据插入队列并打印生产的数据。</li></ul> 
<p>在插入数据后，如果队列原来为空，则调用 cond.Signal() 唤醒一个正在等待条件变量的协程。最后，使用 mu.Unlock() 释放互斥锁。</p> 
<p>在消费者协程中，首先调用 mu.Lock() 获取互斥锁，然后使用 for 循环判断队列是否为空</p> 
<ul><li>如果为空则调用 cond.Wait() 阻塞当前协程，等待生产者协程唤醒。</li><li>如果队列非空，则取出队头元素并打印消费的数据。</li></ul> 
<p>在取出数据后，如果队列原来已满，则调用 cond.Signal() 唤醒一个正在等待条件变量的协程。</p> 
<p>最后，使用 mu.Unlock() 释放互斥锁。</p> 
<h3><a id="channel__367"></a>channel 通道</h3> 
<p>除了标准库 <a href="https://go-zh.org/pkg/sync/" rel="nofollow"><code>sync</code></a> 包提供了协程 同步能力，还可以使用channel 来实现。</p> 
<p>channel 是一种特殊的数据类型，可以用来在协程之间传递数据，并且能够实现阻塞式等待和唤醒功能。</p> 
<h4><a id="channel__373"></a>channel 通道（/信道）的两个基本操作</h4> 
<p>和映射与切片一样，channel 通道在使用前必须创建：</p> 
<pre><code class="prism language-go">ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
</code></pre> 
<p>使用 make 函数创建 channel 时，第一个参数为 channel 类型，第二个参数为缓冲区大小（可选）。注意，第二个参数是可选的。</p> 
<p>channel 通道在创建的时候， 类型参数表示 通道里边 值的类型。所以，通道是带有类型的管道，你可以通过它用信道操作符 <code>&lt;-</code> 来发送或者接收值。</p> 
<pre><code class="prism language-go">ch <span class="token operator">&lt;-</span> v    <span class="token comment">// 将 v 发送至信道 ch。</span>
v <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch  <span class="token comment">// 从 ch 接收值并赋予 v。</span>
</code></pre> 
<p>“箭头” &lt;- 就是数据流的方向。默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。</p> 
<p>在使用 channel 进行同步时，一般有两种基本的操作：</p> 
<ol><li>发送数据到 channel：通过 channel 的 &lt;- 操作符向其中发送一个值，例如：</li></ol> 
<pre><code class="prism language-go">ch <span class="token operator">&lt;-</span> <span class="token string">"hello"</span>
</code></pre> 
<ol start="2"><li>从 channel 接收数据：通过 channel 的 &lt;- 操作符从其中接收一个值，例如：</li></ol> 
<pre><code class="prism language-go">msg <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch
</code></pre> 
<p>当调用 &lt;- 操作符时，如果 channel 中没有数据可用，则当前协程会被阻塞，直到有数据可用为止。</p> 
<p>下面是一个使用 channel 实现协程同步的例子：</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>

    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Sending message..."</span><span class="token punctuation">)</span>
        ch <span class="token operator">&lt;-</span> <span class="token string">"Hello, world!"</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Message sent!"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    msg <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Received message:"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个例子中，我们创建了一个字符串类型的 channel，然后启动了一个新的协程。</p> 
<p>在协程中，先打印一条信息表示正在发送消息，然后将消息发送到 channel 中。发送完成后，再打印一条信息表示消息已经发送完毕。</p> 
<p>在主程序中，我们等待从 channel 中接收到消息，并将其保存到变量 msg 中。接收到消息后，再打印一条信息表示已经接收到了消息，并输出这个消息的内容。</p> 
<p>注意，在这个例子中，主程序会被阻塞，直到从 channel 中接收到了消息为止。就是这句：</p> 
<pre><code class="prism language-go">msg <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch
</code></pre> 
<p>这是因为主程序使用 &lt;- ch 操作符从 channel 中接收数据时，如果 channel 中没有数据可用，它会一直阻塞等待，直到有数据可用为止。</p> 
<h4><a id="make__441"></a>附录：make 函数如何使用？</h4> 
<p>在 Go 中，make 函数用于创建一个类型为 slice、map 或 channel 的对象，并返回其引用。make 函数的语法如下：</p> 
<pre><code class="prism language-go"><span class="token function">make</span><span class="token punctuation">(</span>Type<span class="token punctuation">,</span> size<span class="token punctuation">)</span>
</code></pre> 
<p>其中 Type 表示要创建的对象类型，size 则表示对象大小或缓冲区大小（仅适用于 channel）。具体来说，make 函数有以下三种用法：</p> 
<p>1.创建 slice：使用 make 函数创建 slice 时，第一个参数为 slice 类型，第二个参数为 slice 的长度（数量），第三个参数为 slice 的容量（可选）。例如：</p> 
<pre><code class="prism language-go"><span class="token comment">// 创建长度为 10，容量为 20 的 int 类型 slice</span>
s <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
</code></pre> 
<p>2.创建 map：使用 make 函数创建 map 时，第一个参数为 map 类型，不需要指定大小。例如：</p> 
<pre><code class="prism language-go"><span class="token comment">// 创建 string 到 int 的映射表</span>
m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
</code></pre> 
<p>3.创建 channel：使用 make 函数创建 channel 时，第一个参数为 channel 类型，第二个参数为缓冲区大小（可选）。例如：</p> 
<pre><code class="prism language-go"><span class="token comment">// 创建一个无缓冲的 channel</span>
ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>


<span class="token comment">// 创建一个可以缓存 10 个字符串的 channel</span>
ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
</code></pre> 
<p>除此之外，make 函数还可以用于创建一些类型的值，例如 string、array 和 struct 等。</p> 
<p>但是，在这些情况下，通常更推荐使用字面量语法来创建相应的值。</p> 
<h4><a id="range___close_482"></a>range遍历 和 通道关闭 close</h4> 
<p>在 Go 中，可以使用 <code>close</code> 函数来关闭通道。关闭通道后，发送方不能再向通道中发送数据，但是接收方仍然可以从通道中接收数据，直到通道中所有的数据都被读取完毕。</p> 
<p>如果要关闭通道，生产者/发送者可通过 <code>close</code> 函数关闭一个信道，来表示没有需要发送的值了。</p> 
<p>close函数的使用方法，非常简单，具体如下：</p> 
<pre><code class="prism language-go"> <span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
</code></pre> 
<p>消费者/接收者如何判定呢？</p> 
<p>在消费的时候， 可以通过接收表达式返回的第二个参数，来测试信道是否被关闭， 两个返回值版本的接收表达式如下：</p> 
<pre><code class="prism language-go">v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch
</code></pre> 
<p>若两个返回值中，如果没有值可以接收、且信道已被关闭，第一个值为0值，第二个值 <code>ok</code> 会被设置为 <code>false</code>。</p> 
<p>其中 ok 是一个 bool 类型，可以通过它来判断 channel 是否已经关闭，如果 channel 关闭该值为 false ，此时 v 接收到的是 channel 类型的零值。比如：channel 是传递的 int， 那么 v 就是 0 ；如果是结构体，那么 v 就是结构体内部对应字段的零值。</p> 
<p><strong>注意：</strong></p> 
<ul><li><strong>只有发送者才能关闭信道，而接收者不能。</strong></li><li><strong>向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</strong></li></ul> 
<p>在 Go 中，可以使用 <code>range</code> 来遍历通道中的数据。使用 <code>range</code> 遍历通道时，会一直等待通道中有新的数据可读取，直到通道被关闭或者显式地使用 <code>break</code> 终止循环。</p> 
<p>简单来说，循环 <code>for i := range c</code> 会不断从信道接收值，直到它被关闭。</p> 
<p><em>还要注意：</em> 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 <code>range</code> 循环。</p> 
<p>下面是一个使用 <code>range</code> 遍历通道的示例：</p> 
<pre><code class="prism language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>

    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
            ch <span class="token operator">&lt;-</span> i
            time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">for</span> x <span class="token operator">:=</span> <span class="token keyword">range</span> ch <span class="token punctuation">{<!-- --></span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Received:"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Done"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个例子中，我们创建了一个无缓冲的 channel <code>ch</code>，并启动了一个协程向 <code>ch</code> 中发送数据。</p> 
<p>在主程序中，使用 <code>range</code> 遍历 <code>ch</code> 中的数据，并打印接收到的数据。</p> 
<p>当协程向 <code>ch</code> 中发送完数据后，通过 <code>close</code> 函数关闭 <code>ch</code>。</p> 
<p>在使用 <code>range</code> 遍历通道时，如果通道未关闭，则循环会一直等待直到通道被关闭。当通道被关闭后，循环会自动终止，无需使用其他方式来判断通道是否已经关闭。同时，如果在循环中使用 <code>break</code> 终止循环，则需要注意在终止前将通道关闭，否则可能会导致死锁等问题。</p> 
<p>需要注意的是，使用 <code>range</code> 遍历通道时，如果通道中已经没有数据可读取，则循环会被阻塞，直到有新的数据可读取或者通道被关闭。因此，在使用 <code>range</code> 遍历通道时，需要确保在发送方将所有数据发送完毕后及时关闭通道，否则可能会导致循环一直阻塞等待。</p> 
<h5><a id="close_Channel__556"></a>close Channel 的一些说明</h5> 
<p>channel 不需要通过 close 来释放资源，这个是它与 socket、file 等不一样的地方，对于 channel 而言，唯一需要 close 的就是我们想通过 close 触发 channel 读事件。</p> 
<ul><li>close channel对 channel阻塞无效，写了数据不读，直接 close，还是会阻塞的。</li><li>如果 channel 已经被关闭，继续往它发送数据会导致 panic <code>send on closed channel</code></li><li>closed 的 channel，再次关闭 close 会 panic</li><li>close channel 的推荐使用姿势是在发送方来执行，因为 channel 的关闭只有接收端能感知到，但是发送端感知不到，因此一般只能在发送端主动关闭。而且大部分时候可以不执行 close，只需要读写即可。</li><li>从一个已经 close 的 channel中读取数据，是可以读取的，读到的数据为 0</li><li>读取的 channel 如果被关闭，并不会影响正在读的数据，它会将所有数据读取完毕，在读取完已发送的数据后会返回元素类型的零值(zero value)。</li></ul> 
<h4><a id="select__567"></a>多通道查询select 语句/通道的多路复用</h4> 
<p><code>select</code> 语句使一个 Go 程可以等待多个channel通信操作。</p> 
<p><code>select</code> 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。</p> 
<p>在 Go 中，可以使用 <code>select</code> 语句来等待多个 channel 中的数据，并执行相应的操作。</p> 
<p>当有多个 channel 中的数据可读取时，<code>select</code> 语句会随机选择一个可用的 channel，并执行对应的操作。</p> 
<p>下面是一个示例代码，演示如何使用 <code>select</code> 语句查询多个 channel 中的数据：</p> 
<pre><code class="prism language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
    ch2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>

    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
            ch1 <span class="token operator">&lt;-</span> i
            time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
            ch2 <span class="token operator">&lt;-</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"Message %d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
            time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">select</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">case</span> x <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch1<span class="token punctuation">:</span>
            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Received from ch1:"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>
        <span class="token keyword">case</span> x <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch2<span class="token punctuation">:</span>
            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Received from ch2:"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Done"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个示例代码中，我们创建了两个 channel <code>ch1</code> 和 <code>ch2</code>，分别用于发送 <code>int</code> 类型和 <code>string</code> 类型的数据。</p> 
<p>在两个协程中，分别向 <code>ch1</code> 和 <code>ch2</code> 中发送数据，并间隔一秒钟。</p> 
<p>在主函数中，使用 <code>select</code> 语句查询 <code>ch1</code> 和 <code>ch2</code> 中的数据，并打印接收到的数据。在循环中共查询 10 次，由于两个协程的间隔时间不同，因此可能会先从 <code>ch1</code> 中接收到数据，也可能会先从 <code>ch2</code> 中接收到数据。最后，当所有数据被读取完毕后，程序输出 <code>Done</code>。</p> 
<p>需要注意的是，在使用 <code>select</code> 语句查询多个 channel 时，如果多个 channel 同时有数据可读取，则随机选择一个 channel，并执行对应的操作。</p> 
<p>因此，在设计程序逻辑时，需要考虑到 channel 的使用顺序可能会发生变化。此外，如果在 <code>select</code> 语句中同时等待多个 channel，而其中一个 channel 被关闭了，则程序仍然会等待其它的 channel，并在有数据可读取时执行相应的操作。</p> 
<h5><a id="Goselect__OSselect__626"></a>Go的select 和 OS的select 对比</h5> 
<p>Go语言中的select 和操作系统中的系统调用select比较相似。</p> 
<p>C语言的select系统调用可以同时监听多个文件描述符的可读或者可写的状态，Go 语言的select可以让Goroutine同时等待多个Channel可读或可写，在多个文件或Channel状态改变之前，select会一直阻塞当前线程或Goroutine。</p> 
<p>select是与switch相似的控制结构，不过select的case中的表达式必须都是channel的收发操作。当select中的多个case同时被触发时，会随机执行其中一个。</p> 
<p>通常情况下，select语言会阻塞goroutine并等待多个Channel中的一个达到可以收发的状态。但如果有default语句，可以实现非阻塞，就是当多个channel都不能执行的时候，运行default。</p> 
<h5><a id="_636"></a>非阻塞查询</h5> 
<p>select 默认是阻塞的，如果所有的通道都没有数据，那么 函数就会被阻塞。</p> 
<p>如何不进行阻塞呢？ 在 Go 中，<code>select</code> 语句还可以使用 <code>default</code> 分支，用于在没有任何 channel 可读取时执行默认操作。当所有被查询的 channel 都没有数据可读取时，<code>select</code> 会立即执行 <code>default</code> 分支，从而实现不会被阻塞。</p> 
<p>换句话来说，当 <code>select</code> 中的其它分支都没有准备好时，<code>default</code> 分支就会执行。所以，为了在尝试在接收时不发生阻塞，可使用 <code>default</code> 分支, 使用的方式如下：</p> 
<pre><code class="prism language-go"><span class="token keyword">select</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">case</span> i <span class="token operator">:=</span> <span class="token operator">&lt;-</span>c<span class="token punctuation">:</span>
    <span class="token comment">// 使用 i</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
    <span class="token comment">// 从 c 中接收会阻塞时执行</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>下面是一个示例代码，演示如何使用 <code>default</code> 分支：</p> 
<pre><code class="prism language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>

    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span>
        <span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">for</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">select</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">case</span> x<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{<!-- --></span>
                fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Channel closed"</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span>
            <span class="token punctuation">}</span>
            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Received:"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>
        <span class="token keyword">default</span><span class="token punctuation">:</span>
            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"No data received"</span><span class="token punctuation">)</span>
            time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Done"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个示例代码中，我们创建了一个无缓冲的通道 <code>ch</code>，并在一个协程中等待 3 秒钟后关闭通道。</p> 
<p>在主函数中，使用 <code>select</code> 语句监听 <code>ch</code> 中的数据，并打印接收到的数据。</p> 
<p>由于 <code>ch</code> 一开始并没有数据可读取，因此 <code>select</code> 会立即执行 <code>default</code> 分支，并打印提示信息。在 <code>ch</code> 被关闭后，通过判断第二个返回值 <code>ok</code> 的值来确定通道是否已经关闭。如果通道已经关闭，则跳出循环并输出结束信息。</p> 
<p>需要注意的是，在使用 <code>default</code> 分支时，需要考虑到程序的实际需求，并合理设置等待时长。</p> 
<p>如果等待时间过短，则可能会频繁地执行 <code>default</code> 分支，导致性能损失；如果等待时间过长，则可能会导致数据延迟等问题。</p> 
<p>此外，在使用 <code>default</code> 分支时，需要注意区分通道中的零值和通道已经关闭两种情况，以避免出现不必要的错误。</p> 
<h4><a id="_701"></a>带缓冲的通道</h4> 
<p>在 Go 中，可以使用带缓冲的 channel 来实现协程之间的同步和通信。channel 可以是 <em>带缓冲的</em>。</p> 
<p>如何创建带缓冲通道呢？ 将缓冲长度作为第二个参数提供给 <code>make</code> 来初始化一个带缓冲的信道</p> 
<p>在创建带缓冲的 channel 时，需要在 channel 类型后面添加一个整数，表示缓冲区大小。例如：</p> 
<pre><code class="prism language-go"><span class="token comment">// 创建一个可以缓存 10 个字符串的 channel</span>
ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
</code></pre> 
<p>在这个例子中，我们创建了一个可以缓存 10 个字符串的 channel ch。</p> 
<ul><li>当有协程向 ch 发送数据时，如果缓冲区未满，则可以直接将数据写入缓冲区；否则，发送操作会被阻塞，直到有协程从 ch 中读取数据为止。</li><li>同样地，当有协程从 ch 中读取数据时，如果缓冲区非空，则可以直接从缓冲区读取数据；否则，接收操作会被阻塞，直到有协程向 ch 中发送数据为止。</li></ul> 
<p>带缓冲的通道的特点是：</p> 
<ul><li>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。</li><li>当缓冲区为空时，接受方会阻塞。</li></ul> 
<p>带缓冲的 channel 是一种有固定缓冲区大小的 channel，当缓冲区满时，向 channel 发送数据会被阻塞，直到有协程从 channel 中接收数据为止。相反，当缓冲区为空时，从 channel 接收数据也会被阻塞，直到有协程向 channel 中发送数据为止。</p> 
<p>下面是一个使用带缓冲的 channel 实现生产者-消费者模型的例子：</p> 
<pre><code class="prism language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
<span class="token punctuation">)</span>

<span class="token keyword">const</span> capacity <span class="token operator">=</span> <span class="token number">5</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> capacity<span class="token punctuation">)</span>
    done <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>

    <span class="token comment">// 生产者协程</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> capacity<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
            ch <span class="token operator">&lt;-</span> i
            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Produce:"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        done <span class="token operator">&lt;-</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// 消费者协程</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> capacity<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
            item <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch
            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Consume:"</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        done <span class="token operator">&lt;-</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token operator">&lt;-</span>done
    <span class="token operator">&lt;-</span>done
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个例子中，我们创建了一个缓冲区大小为 5 的 channel ch，然后创建了两个协程，一个用来生产数据（向 ch 中发送数据），另一个用来消费数据（从 ch 中接收数据）。</p> 
<p>当所有数据都被生产和消费完毕后，使用两个 done channel 来通知主程序结束。</p> 
<p>在生产者协程中，首先向 ch 中发送数据，并打印生产的数据。如果缓冲区已满，则发送操作会被阻塞，等待消费者协程从 ch 中读取数据。在最后一个数据被生产和发送完毕后，通过 done channel 向主程序发送结束信号。</p> 
<p>在消费者协程中，首先从 ch 中接收数据，并打印消费的数据。如果缓冲区为空，则接收操作会被阻塞，等待生产者协程向 ch 中发送数据。在最后一个数据被消费完毕后，通过 done channel 向主程序发送结束信号。</p> 
<h3><a id="Java__BlockingQueue__Go__channel__772"></a>Java BlockingQueue 和 Go channel 对比学习</h3> 
<p>Java 中的 <code>BlockingQueue</code> 和 Go 中的 channel 都是用于实现线程之间的通信的工具，但是它们在一些方面存在差异 , 主要有3点：</p> 
<ul><li>1：实现方式</li></ul> 
<p>Java 中的 <code>BlockingQueue</code> 是一个接口，它有多个不同的实现类，如 <code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code> 等。这些实现类都是基于数组或链表等数据结构实现的，提供了一些阻塞式的队列操作方法。</p> 
<p>Go 中的 channel 是语言内置的类型，直接由编译器实现。在底层，channel 是使用 waitgroup、mutex、cond 等同步原语实现的，而不是基于数据结构实现的。</p> 
<ul><li>2：缓存机制</li></ul> 
<p>Java 的 <code>BlockingQueue</code> 有两种类型：有界阻塞队列和无界阻塞队列。有界阻塞队列的大小是固定的，当队列元素数量达到上限时，生产者线程会被阻塞，直到队列中有空位。无界阻塞队列没有容量限制，在添加元素时不会被阻塞，但是获取元素时可能会被阻塞。</p> 
<p>Go 的 channel 也可以分为两种类型：带缓存的 channel 和非缓存的 channel。带缓存的 channel 可以缓存一定数量的元素，当缓冲区满时，发送操作会被阻塞。非缓存的 channel 不允许缓存元素，每个元素只能被发送和接收一次。</p> 
<ul><li>3：阻塞机制</li></ul> 
<p>Java 的 <code>BlockingQueue</code> 提供了多种阻塞式队列操作方法，如 <code>put</code> 和 <code>take</code> 等。其中，<code>put</code> 方法会在队列已满时阻塞直到有空位，而 <code>take</code> 方法会在队列为空时阻塞直到有元素可取。</p> 
<p>Go 的 channel 通过阻塞操作实现协程之间的同步和通信。当发送或接收操作无法进行时，协程会被阻塞，并暂停执行，直到对应的操作可以进行为止。</p> 
<p>Java 的 <code>BlockingQueue</code> 和 Go 的 channel 在实现方式和应用场景不同，但是它们也有一些相同点。主要有4点：</p> 
<ul><li>1：用途相同</li></ul> 
<p>Java 的 <code>BlockingQueue</code> 和 Go 的 channel 都是用于协程之间的通信和同步。它们允许多个协程在不同的时间段进行读写操作，并提供了阻塞式的方法来确保线程安全和正确性。</p> 
<ul><li>2：阻塞机制相同</li></ul> 
<p>Java 的 <code>BlockingQueue</code> 和 Go 的 channel 都通过阻塞操作来实现协程之间的同步。当队列为空或已满时，生产者线程和消费者线程都会被阻塞，直到对应的条件得到满足为止。</p> 
<ul><li>3：线程安全性相同</li></ul> 
<p>Java 的 <code>BlockingQueue</code> 和 Go 的 channel 都是线程安全的。它们都提供了阻塞式的方法，可以确保多个协程在不同的时间段进行读写操作时不会发生竞态条件等问题。</p> 
<ul><li>4：可靠性相同</li></ul> 
<p>Java 的 <code>BlockingQueue</code> 和 Go 的 channel 都是可靠的。它们都能够确保协程之间的通信和同步。同时，在使用过程中也可以通过异常捕获等方法来处理潜在的错误，并保证程序的正确性和健壮性。</p> 
<p>综上所述，Java 的 <code>BlockingQueue</code> 和 Go 的 channel 在用途、阻塞机制、线程安全性和可靠性等方面存在相同点，这些共同点也是它们成为编写多线程程序时的优秀工具的原因之一。</p> 
<h4><a id="SynchronousQueue_VS_channel_818"></a>SynchronousQueue VS 无缓冲channel</h4> 
<p>go 中channel 分为缓冲通道和非缓冲通道（容量为0）。</p> 
<p>Go 语言的无缓冲channel，只有在发送操作和接收操作配对上了，发送方和接收方才能得以继续执行，否则将会阻塞在发送或者接收操作。</p> 
<p>Go 语言的无缓冲channel，本质上就是以同步的方式来传递数据。</p> 
<p>所以， Go 语言的无缓冲channel 正是 Java 中的 SynchronousQueue 具有的特性。</p> 
<table><thead><tr><th></th><th>零容量 无缓冲</th><th>有限容量</th></tr></thead><tbody><tr><td>Go</td><td>unbuffered channel</td><td>buffered channel</td></tr><tr><td>Java</td><td>SynchronousQueue</td><td>LinkedBlockingQueue</td></tr></tbody></table> 
<h4><a id="LinkedBlockingQueue_VS__buffered___channel_839"></a>LinkedBlockingQueue VS 缓冲通道 buffered channel</h4> 
<p>缓冲通道，顾名思义，就是能起到缓冲作用的数据类型。</p> 
<p>相对于非缓冲通道发送操作如果没有配对的接收操作则会阻塞的情况，缓冲通道在容量未满的时候允许发送操作发送成功之后立即执行后续的操作而不阻塞。</p> 
<p>Java 中的 LinkedBlockingQueue 也具有这一特性，从命名来看就是底层基于链表的阻塞队列。</p> 
<h4><a id="_849"></a>操作对比</h4> 
<p>Go中，可以使用 len 获取通道的 长度，cap 函数 获取通道的 容量，下面是一个例子：</p> 
<pre><code class="prism language-go">unbufChan <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>           <span class="token comment">// 创建一个非缓冲通道</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"容量为%d\n"</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>unbufChan<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 容量为0</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"长度为%d\n"</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>unbufChan<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 长度为0</span>

bufChan <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>        <span class="token comment">// 创建一个缓冲通道</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"容量为%d\n"</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>bufChan<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 容量为8</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"长度为%d\n"</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>bufChan<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 长度为0</span>
bufChan <span class="token operator">&lt;-</span> <span class="token number">1</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"容量为%d\n"</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>bufChan<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 容量为8</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"长度为%d\n"</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>bufChan<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 长度为1</span>

</code></pre> 
<p>对于 Go 语言的非缓冲通道，其容量也总是为0</p> 
<p><em>其中队列（或通道）的长度代表它当前包含的元素值的个数。当队列（或通道）已满时，其长度与容量相同。</em></p> 
<p>SynchronousQueue VS 无缓冲channel 的长度和 容量比较：</p> 
<table><thead><tr><th></th><th>容量</th><th>长度</th><th>剩余容量</th></tr></thead><tbody><tr><td>SynchonousQueue</td><td>0</td><td>0</td><td>0</td></tr><tr><td>unbuffered channel</td><td>0</td><td>0</td><td>0</td></tr></tbody></table> 
<p>LinkedBlockingQueue VS 缓冲通道 buffered channel 的长度和 容量比较：</p> 
<table><thead><tr><th></th><th>容量</th><th>长度</th><th>剩余容量</th></tr></thead><tbody><tr><td>LinkedBlockingQueue</td><td>构造函数指定的capacity</td><td>size()</td><td>remainingCapacity()</td></tr><tr><td>buffered channel</td><td>cap(ch)</td><td>len(ch)</td><td>cap(ch) - len(ch)</td></tr></tbody></table> 
<p>其中队列（或通道）的长度代表它当前包含的元素值的个数。当队列（或通道）已满时，其长度与容量相同。</p> 
<h4><a id="go__rocketmq__893"></a>go rocketmq 编程</h4> 
<p>Apache RocketMQ 是一个开源的、分布式的消息中间件系统，支持高吞吐量和高可用性的消息传递。</p> 
<p>在 Go 编程中，可以使用 Apache RocketMQ 的 Go 客户端来实现与 RocketMQ 的交互。</p> 
<p>golang 模块安装</p> 
<pre><code class="prism language-shell">go get github.com/apache/rocketmq-client-go/v2
</code></pre> 
<p>尼恩提示：</p> 
<p>在 goland 工具中的 模块安装过程，请参考后面的附录。</p> 
<h5><a id="_RocketMQ__Go__911"></a>实例：使用 RocketMQ 的 Go 客户端来发送和接收消息</h5> 
<p>下面是一个简单的示例代码，演示如何使用 RocketMQ 的 Go 客户端来发送和接收消息：</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> batchprocess

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"context"</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"github.com/apache/rocketmq-client-go/v2"</span>
	<span class="token string">"log"</span>
	<span class="token string">"time"</span>

	<span class="token string">"github.com/apache/rocketmq-client-go/v2/consumer"</span>
	<span class="token string">"github.com/apache/rocketmq-client-go/v2/primitive"</span>
	<span class="token string">"github.com/apache/rocketmq-client-go/v2/producer"</span>
<span class="token punctuation">)</span>

<span class="token comment">// 创建生产者</span>
<span class="token keyword">const</span> NAME_NODE <span class="token operator">=</span> <span class="token string">"192.168.56.121:9876"</span>
<span class="token keyword">const</span> TOPIC <span class="token operator">=</span> <span class="token string">"test"</span>

<span class="token keyword">func</span> <span class="token function">RocketMQDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

	producer<span class="token punctuation">,</span> err <span class="token operator">:=</span> rocketmq<span class="token punctuation">.</span><span class="token function">NewProducer</span><span class="token punctuation">(</span>
		producer<span class="token punctuation">.</span><span class="token function">WithNameServer</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{<!-- --></span>NAME_NODE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		producer<span class="token punctuation">.</span><span class="token function">WithRetry</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"create producer error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	err <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"start producer error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">defer</span> producer<span class="token punctuation">.</span><span class="token function">Shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// 发送消息</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
		msg <span class="token operator">:=</span> <span class="token operator">&amp;</span>primitive<span class="token punctuation">.</span>Message<span class="token punctuation">{<!-- --></span>
			Topic<span class="token punctuation">:</span> TOPIC<span class="token punctuation">,</span>
			Body<span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"Hello RocketMQ"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token punctuation">}</span>
		res<span class="token punctuation">,</span> err <span class="token operator">:=</span> producer<span class="token punctuation">.</span><span class="token function">SendSync</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"send message error: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"send message success: %v\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 创建消费者</span>
	c<span class="token punctuation">,</span> err <span class="token operator">:=</span> rocketmq<span class="token punctuation">.</span><span class="token function">NewPushConsumer</span><span class="token punctuation">(</span>
		consumer<span class="token punctuation">.</span><span class="token function">WithNameServer</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{<!-- --></span>NAME_NODE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		consumer<span class="token punctuation">.</span><span class="token function">WithGroupName</span><span class="token punctuation">(</span><span class="token string">"test-group"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"create consumer error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	err <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">Subscribe</span><span class="token punctuation">(</span>TOPIC<span class="token punctuation">,</span> consumer<span class="token punctuation">.</span>MessageSelector<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">,</span>
		<span class="token keyword">func</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> msgs <span class="token operator">...</span><span class="token operator">*</span>primitive<span class="token punctuation">.</span>MessageExt<span class="token punctuation">)</span> <span class="token punctuation">(</span>consumer<span class="token punctuation">.</span>ConsumeResult<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> msg <span class="token operator">:=</span> <span class="token keyword">range</span> msgs <span class="token punctuation">{<!-- --></span>
				log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"receive message: topic=%s, body=%s\n"</span><span class="token punctuation">,</span>
					msg<span class="token punctuation">.</span>Topic<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>Body<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> consumer<span class="token punctuation">.</span>ConsumeSuccess<span class="token punctuation">,</span> <span class="token boolean">nil</span>
		<span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"subscribe error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	err <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"start consumer error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">defer</span> c<span class="token punctuation">.</span><span class="token function">Shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这段代码中，首先生产者并用其向 RocketMQ 中的 <code>test</code> 主题发送了一条消息。然后创建了一个消费者，订阅了 <code>test</code> 主题，并在回调函数中处理接收到的消息。</p> 
<p>在这个示例中，首先创建了一个 RocketMQ 生产者，并通过 <code>WithNameServer</code> 和 <code>WithRetry</code> 分别设置了 NameServer 地址和重试次数等配置项。</p> 
<p>然后，在循环中创建了一个消息对象，并调用 <code>SendSync</code> 方法发送同步消息。该方法的第一个参数是上下文对象，可以使用 context.Background() 创建；第二个参数是消息对象。如果发送成功，则返回一个 SendResult 对象，否则返回一个非空的错误对象。</p> 
<p>最后，使用 time.Sleep() 方法等待一秒钟，以便观察发送结果。在真实的应用程序中，可以根据需要调整等待时间。</p> 
<p>综上所述，在 RocketMQ 的 Go 版本客户端 rocketmq-client-go 中，可以使用 <code>SendSync</code> 方法发送同步消息，并通过返回值和错误对象获取发送结果。</p> 
<p><strong>需要注意的是: 在使用 RocketMQ 的 Go 客户端时，必须先安装和配置好 RocketMQ 的服务端，并将 Go 客户端库引入到项目中。同时，也需要根据实际情况进行配置和参数设置，以确保程序能够正常运行。</strong></p> 
<h5><a id="_1012"></a>消息发送和接受的验证</h5> 
<h5><a id="_rocketmq_1014"></a>启动 rocketmq</h5> 
<p>使用尼恩的一键启动环境</p> 
<p><img src="https://images2.imgbox.com/7a/b2/q9w5Sm9U_o.png" alt=""></p> 
<p>启动之后的效果<br> <img src="https://images2.imgbox.com/4d/57/pojkVQgD_o.png" alt=""></p> 
<h5><a id="_go__1025"></a>启动 go 实例</h5> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"crazymakercircle.com/awesomeProject/batchprocess"</span>
	<span class="token string">"fmt"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"\tcocurrent RocketMQDemo  :"</span><span class="token punctuation">)</span>

	<span class="token comment">//cocurrent.GoroutineDemo()</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"\tcocurrent MutexDemo  :"</span><span class="token punctuation">)</span>

	batchprocess<span class="token punctuation">.</span><span class="token function">RocketMQDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用goland 直接执行</p> 
<p>发送消息效果</p> 
<p><img src="https://images2.imgbox.com/22/ee/4c4SiITi_o.png" alt=""></p> 
<p>消费消息效果</p> 
<p><img src="https://images2.imgbox.com/64/58/LlcjaH8I_o.png" alt=""></p> 
<h4><a id="Go__1064"></a>附录：Go 模块的安装和使用</h4> 
<p>Go 模块是 Go 语言1.11版本后引入的官方包管理工具，可以自动管理依赖项和版本。</p> 
<p>一个<em>模块</em>是一些以版本作为单元相关的包的集合。模块记录精确的依赖要求并创建可复制的构建。</p> 
<p>通常，版本控制存储库仅包含在存储库根目录中定义的一个模块。（<a href="https://github.com/golang/go/wiki/Modules#faqs--multi-module-repositories">单个存储库中支持多个模块</a>，但是通常，与每个存储库中的单个模块相比，这将导致正在进行的工作更多）。</p> 
<p>总结存储库，模块和软件包之间的关系：</p> 
<ul><li>一个存储库包含一个或多个Go模块。</li><li>每个模块包含一个或多个Go软件包。</li><li>每个软件包都在一个目录中包含一个或多个Go源文件。</li></ul> 
<p>下面是使用 Go 模块安装和管理第三方库的步骤：</p> 
<h5><a id="_Go__1082"></a>启用 Go 模块</h5> 
<p>在使用 Go 模块之前，需要先启用 Go 模块功能。</p> 
<p>可以通过设置 <code>GO111MODULE</code> 环境变量来控制 Go 是否使用模块。要启用模块，请将该环境变量设置为 <code>on</code>，例如：</p> 
<pre><code class="prism language-bash">$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">GO111MODULE</span><span class="token operator">=</span>on
</code></pre> 
<h5><a id="_1092"></a>创建新项目</h5> 
<p>在开始开发项目之前，需要创建一个新的项目目录，并在其中初始化 Go 模块。</p> 
<p>可以使用 <code>go mod init</code> 命令来完成初始化操作，例如：</p> 
<pre><code class="prism language-bash">$ go mod init crazymakercircle.com/awesomeProject
</code></pre> 
<p><img src="https://images2.imgbox.com/fc/d1/wqhllxmC_o.png" alt=""></p> 
<p>这个命令会创建一个新的 Go 模块，并在当前目录中生成一个名为 <code>go.mod</code> 的文件。</p> 
<p>打开看看<br> <img src="https://images2.imgbox.com/9a/12/Rfpn7XGh_o.png" alt=""></p> 
<h5><a id="gomod_1119"></a>go.mod</h5> 
<p>模块由Go源文件树定义，该<code>go.mod</code>文件在树的根目录中。模块源代码可能位于GOPATH之外。</p> 
<p>在 Go 1.11 版本之后，Go 引入了官方的包管理工具 Go modules。使用 Go modules 可以更好地管理项目中的依赖项和版本，避免了 GOPATH 和 vendor 目录等传统的包管理方式中存在的一些问题。</p> 
<p>在使用 Go modules 时，需要在项目根目录中创建一个名为 <code>go.mod</code> 的文件，并在其中定义模块路径和依赖项等信息。</p> 
<p>下面是一个示例的 <code>go.mod</code> 文件：</p> 
<pre><code class="prism language-go">module example<span class="token punctuation">.</span>com<span class="token operator">/</span>myproject

<span class="token keyword">go</span> <span class="token number">1.16</span>

require <span class="token punctuation">(</span>
    github<span class="token punctuation">.</span>com<span class="token operator">/</span>gin<span class="token operator">-</span>gonic<span class="token operator">/</span>gin v1<span class="token punctuation">.</span><span class="token number">7.4</span>
    github<span class="token punctuation">.</span>com<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">-</span>sql<span class="token operator">-</span>driver<span class="token operator">/</span>mysql v1<span class="token punctuation">.</span><span class="token number">6.0</span>
<span class="token punctuation">)</span>
</code></pre> 
<p>在这个文件中，第一行指定了当前模块的名称，即 <code>example.com/myproject</code>。</p> 
<p>注意，这个名称应该是唯一的，以便其他项目可以引用该模块。</p> 
<p>第二行指定了所使用的 Go 版本，即 <code>go 1.16</code>。</p> 
<p>下面的 <code>require</code> 块定义了所有依赖项及其版本信息。</p> 
<p>每个依赖项都由一个完整的包名称和版本号组成，例如 <code>github.com/gin-gonic/gin v1.7.4</code>。这个版本号表示需要使用的确切版本，也可以使用语义化版本号范围来指定版本，例如 <code>github.com/gin-gonic/gin v1.7.x</code>。</p> 
<p>mod文件 有四种指令：<code>module</code>，<code>require</code>，<code>replace</code>，<code>exclude</code>。</p> 
<p>在 Go modules 中，一个模块可以包含多个软件包，每个软件包都有一个唯一的导入路径。这个导入路径由模块路径和从 <code>go.mod</code> 到软件包目录的相对路径共同确定。</p> 
<p>假设有一个名为 <code>example.com/myproject</code> 的模块，其中包含两个软件包 <code>foo</code> 和 <code>bar</code>，它们的目录结构如下：</p> 
<pre><code class="prism language-go">myproject<span class="token operator">/</span>
  <span class="token operator">|</span><span class="token operator">-</span> <span class="token keyword">go</span><span class="token punctuation">.</span>mod
  <span class="token operator">|</span><span class="token operator">-</span> foo<span class="token operator">/</span>
      <span class="token operator">|</span><span class="token operator">-</span> foo<span class="token punctuation">.</span><span class="token keyword">go</span>
  <span class="token operator">|</span><span class="token operator">-</span> bar<span class="token operator">/</span>
      <span class="token operator">|</span><span class="token operator">-</span> bar<span class="token punctuation">.</span><span class="token keyword">go</span>
</code></pre> 
<p>在这个例子中，软件包 <code>foo</code> 的导入路径为 <code>example.com/myproject/foo</code>，软件包 <code>bar</code> 的导入路径为 <code>example.com/myproject/bar</code>。</p> 
<p>这个导入路径由模块路径 <code>example.com/myproject</code> 和相对路径 <code>foo</code> 或 <code>bar</code> 共同组成。</p> 
<p>注意，在 Go modules 中，所有软件包的导入路径都将模块路径共享为公共前缀。这个公共前缀可以帮助防止命名冲突和混淆。</p> 
<p>总之，模块中所有软件包的导入路径是由模块路径和从 <code>go.mod</code> 到软件包目录的相对路径共同决定的。对于不同的软件包，它们的相对路径是不同的，但它们共享相同的模块路径前缀。</p> 
<h5><a id="_1173"></a>安装第三方库</h5> 
<p>在 Go 模块中安装第三方库与在传统的 GOPATH 中安装方式略有不同。可以使用 <code>go get</code> 命令来安装第三方库并将其添加到当前项目的依赖项中，例如：</p> 
<pre><code class="prism language-bash">$ go get github.com/gin-gonic/gin@v1.7.4
</code></pre> 
<p>这个命令会下载指定版本的 gin 库，并将其添加到当前项目的依赖项中。</p> 
<pre><code class="prism language-bash">go get github.com/apache/rocketmq-client-go/v2
</code></pre> 
<p>此外，还可以使用 <code>go get</code> 命令下载最新版本的库，并将其添加到依赖项中，例如：</p> 
<pre><code class="prism language-bash">$ go get github.com/gin-gonic/gin
</code></pre> 
<p>这个命令会下载指定版本的 rocketmq-client-go库，并将其添加到当前项目的依赖项中。</p> 
<p>比如，安装 RocketMQ client 依赖</p> 
<pre><code class="prism language-bash">go get github.com/apache/rocketmq-client-go/v2
</code></pre> 
<p><img src="https://images2.imgbox.com/1f/17/drLXXYU5_o.png" alt=""></p> 
<p>如果下载不来，或者设置代理试试，打开你的终端并执行（Go 1.13 及以上）</p> 
<pre><code class="prism language-bash">go <span class="token function">env</span> -w <span class="token assign-left variable">GO111MODULE</span><span class="token operator">=</span>on
go <span class="token function">env</span> -w <span class="token assign-left variable">GOPROXY</span><span class="token operator">=</span>https://goproxy.cn,direct
</code></pre> 
<h5><a id="_1216"></a>下载依赖项</h5> 
<p>当安装了第三方库后，还需要将其下载到本地计算机上。</p> 
<p>可以使用 <code>go mod download</code> 命令来下载所有依赖项，例如：</p> 
<pre><code class="prism language-bash">$ go mod download
</code></pre> 
<p>这个命令会下载当前项目依赖的所有库及其版本。</p> 
<h5><a id="_1228"></a>管理依赖项</h5> 
<p>在开发过程中，可能需要升级或删除某些依赖项。可以使用 <code>go mod tidy</code> 命令来清理不再使用的依赖项，例如：</p> 
<pre><code class="prism language-bash">$ go mod tidy
</code></pre> 
<p>这个命令会分析项目代码并移除未使用的库。</p> 
<p>同时，还可以使用 <code>go get -u</code> 命令来升级依赖项到最新版本，例如：</p> 
<pre><code class="prism language-bash">$ go get -u github.com/gin-gonic/gin
</code></pre> 
<p>这个命令会下载并安装 gin 库的最新版本，并更新 go.mod 文件中的版本号。</p> 
<p>综上所述，使用 Go 模块安装和管理第三方库非常方便，可以自动解决依赖关系和版本问题，大大简化了项目的依赖管理。</p> 
<h4><a id="GoLand__Go_go_mod_1248"></a>GoLand 中使用 Go 模块（go mod）管理依赖项</h4> 
<p>在 GoLand 中使用 Go 模块（go mod）管理依赖项，可以通过以下步骤进行操作：</p> 
<h5><a id="_Go__1252"></a><strong>打开或创建一个 Go 项目</strong></h5> 
<p>在 GoLand 中打开或创建一个 Go 项目，并确保该项目启用了 Go 模块功能。</p> 
<p>要启用 Go modules，可以通过菜单栏中的 File &gt; Settings &gt; Go &gt; Go Modules 来启用 Go modules。</p> 
<p>在这个对话框中，可以选择全局或项目级别的 Go modules 设置。建议选择项目级别的设置，以避免影响其他项目。</p> 
<p><img src="https://images2.imgbox.com/a9/85/qbrXc0rV_o.png" alt=""></p> 
<p>初始化 Go modules</p> 
<p>在启用 Go modules 后，需要初始化 Go modules。可以在终端中切换到项目目录，然后执行以下命令来初始化 Go modules：</p> 
<pre><code class="prism language-bash">go mod init crazymakercircle.com/awesomeProject
</code></pre> 
<p>这个命令会创建一个新的 Go 模块，并在当前目录中生成一个名为 <code>go.mod</code> 的文件。</p> 
<p><img src="https://images2.imgbox.com/92/55/Ia7NT0hB_o.png" alt=""></p> 
<h5><a id="_1280"></a>添加依赖项</h5> 
<p>在 GoLand 中添加依赖项非常简单。可以使用 <code>go get</code> 命令来安装第三方库并将其添加到当前项目的依赖项中。例如，在 GoLand 的终端窗口中输入以下命令：</p> 
<pre><code class="prism language-bash">$ go get github.com/gin-gonic/gin
</code></pre> 
<p>这个命令会下载并安装 Gin HTTP 框架，并将其添加到 go.mod 文件中。在此之后，即可在代码中引用 gin 库。</p> 
<p>比如，安装 RocketMQ client 依赖</p> 
<pre><code class="prism language-bash">go get github.com/apache/rocketmq-client-go/v2
</code></pre> 
<p><img src="https://images2.imgbox.com/df/be/cLZICscT_o.png" alt=""></p> 
<h5><a id="require_1302"></a>解决require内依赖全部飘红问题</h5> 
<p>解决go.mod文件中require内依赖全部飘红</p> 
<p><img src="https://images2.imgbox.com/60/e9/5XvZTetT_o.png" alt=""></p> 
<p>设置 go 模块化，并设置环境变量 GOPROXY=https://goproxy.cn,direct</p> 
<p><img src="https://images2.imgbox.com/0e/45/IRsG83QL_o.png" alt=""></p> 
<p>ok了</p> 
<p><img src="https://images2.imgbox.com/8d/78/oWZO8MhH_o.png" alt=""></p> 
<h5><a id="_1318"></a>管理依赖关系</h5> 
<p>在开发过程中，可能需要升级或删除某些依赖项。可以使用 <code>go get -u</code> 命令来升级依赖项到最新版本，并更新 go.mod 文件中的版本号，例如：</p> 
<pre><code class="prism language-bash">$ go get -u github.com/gin-gonic/gin
</code></pre> 
<p>除此之外，还可以使用 GoLand 自带的依赖关系管理工具，包括自动生成和维护 go.mod 和 go.sum 文件、自动提示缺失的依赖项以及检查依赖项的版本等。</p> 
<p>比如：</p> 
<pre><code class="prism language-bash"> go get -u github.com/apache/rocketmq-client-go/v2
</code></pre> 
<h5><a id="_1336"></a>构建和运行项目</h5> 
<p>在完成依赖项的添加和管理后，即可构建和运行项目。可以使用 GoLand 的集成工具来构建和运行项目，例如：</p> 
<ul><li>点击菜单栏中的 Run 按钮或使用快捷键 Shift + F10 来运行程序；</li><li>在编辑器窗口中右键单击并选择 Run ‘main’ 选项来运行程序；</li><li>在终端中输入 <code>go build</code> 命令来编译项目，并使用 <code>./&lt;executable&gt;</code> 命令来运行可执行文件。</li></ul> 
<p>综上所述，GoLand 提供了便捷的工具来支持使用 Go 模块管理依赖项，包括自动化生成和维护 go.mod 和 go.sum 文件、自动提示缺失的依赖项以及检查依赖项的版本等，大大简化了项目的依赖管理。</p> 
<h3><a id="gorm_mysql_1350"></a>gorm 操作mysql</h3> 
<h4><a id="ORM_1352"></a>什么是ORM？</h4> 
<p>ORM框架操作数据库都需要预先定义模型，模型可以理解成数据模型，作为操作数据库的媒介。</p> 
<p>例如：</p> 
<ul><li>从数据库读取的数据会先保存到预先定义的模型对象，然后我们就可以从模型对象得到我们想要的数据。</li><li>插入数据到数据库也是先新建一个模型对象，然后把想要保存的数据先保存到模型对象，然后把模型对象保存到数据库。</li></ul> 
<p>在golang中gorm模型定义是通过struct实现的，这样我们就可以通过gorm库实现struct类型和mysql表数据的映射。</p> 
<p>提示：gorm负责将对模型的读写操作翻译成sql语句，然后gorm再把数据库执行sql语句后返回的结果转化为我们定义的模型对象。</p> 
<h4><a id="gorm_1373"></a>gorm介绍</h4> 
<p>GORM是Golang目前比较热门的数据库ORM操作库，对开发者也比较友好，使用非常方便简单，使用上主要就是把struct类型和数据库表记录进行映射，操作数据库的时候不需要直接手写Sql代码，</p> 
<p>GORM库github地址: https://github.com/go-gorm/gorm</p> 
<h4><a id="gorm_1385"></a>gorm安装</h4> 
<p>操作MySQL需要安装两个包：</p> 
<ul><li>MySQL驱动包</li><li>GORM包 使用go get命令安装依赖包</li></ul> 
<pre><code class="prism language-go"><span class="token comment">//安装MySQL驱动</span>
<span class="token keyword">go</span> get <span class="token operator">-</span>u gorm<span class="token punctuation">.</span>io<span class="token operator">/</span>driver<span class="token operator">/</span>mysql
<span class="token comment">//安装gorm包</span>
<span class="token keyword">go</span> get <span class="token operator">-</span>u gorm<span class="token punctuation">.</span>io<span class="token operator">/</span>gorm
</code></pre> 
<p><img src="https://images2.imgbox.com/df/92/3uwg8l8Q_o.png" alt=""></p> 
<p>go.md里边，加了依赖<br> <img src="https://images2.imgbox.com/31/c2/bANdjR2J_o.png" alt=""></p> 
<p>导入包</p> 
<pre><code class="prism language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"bytes"</span>
	<span class="token string">"fmt"</span>
	<span class="token boolean">_</span> <span class="token string">"gorm.io/driver/mysql"</span>
	<span class="token boolean">_</span> <span class="token string">"gorm.io/gorm"</span>
	<span class="token string">"sync"</span>
	<span class="token string">"time"</span>
<span class="token punctuation">)</span>	
</code></pre> 
<h4><a id="gorm_1425"></a>gorm模型定义</h4> 
<p>gorm模型定义主要就是在struct类型定义的基础上增加字段标签说明实现，下面看个完整的例子。</p> 
<p>假如有个sample表，表结构如下</p> 
<pre><code class="prism language-sql">
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>sample<span class="token punctuation">`</span> <span class="token punctuation">(</span>
<span class="token punctuation">`</span>id<span class="token punctuation">`</span>  <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'主键'</span> <span class="token punctuation">,</span>
<span class="token punctuation">`</span>title<span class="token punctuation">`</span>  <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8 <span class="token keyword">COLLATE</span> utf8_bin <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'标题'</span> <span class="token punctuation">,</span>
<span class="token punctuation">`</span>create_time<span class="token punctuation">`</span>  <span class="token keyword">datetime</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span> <span class="token punctuation">,</span>
<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span>
<span class="token keyword">DEFAULT</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin
ROW_FORMAT<span class="token operator">=</span>DYNAMIC
<span class="token punctuation">;</span>
</code></pre> 
<p>模型定义如下</p> 
<pre><code class="prism language-go"><span class="token comment">//字段注释说明了gorm库把struct字段转换为表字段名长什么样子。</span>
<span class="token keyword">type</span> Sample <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	Id    <span class="token builtin">int64</span>  <span class="token comment">//表字段名为：id</span>
	Title <span class="token builtin">string</span>   <span class="token comment">//表字段名为：title</span>

	<span class="token comment">//字段定义后面使用两个反引号``包裹起来的字符串部分叫做标签定义，这个是golang的基础语法，不同的库会定义不同的标签，有不同的含义</span>
	CreateTime <span class="token builtin">int64</span> <span class="token string">`gorm:"column:create_time"`</span> <span class="token comment">//表字段名为：create_time</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>默认gorm对struct字段名使用Snake Case命名风格转换成mysql表字段名(需要转换成小写字母)。</p> 
<p>根据gorm的默认约定，上面例子只需要使用gorm:"column:create_time"标签定义为CreateTime字段指定表字段名，其他使用默认值即可。</p> 
<p>提示：Snake Case命名风格，就是各个单词之间用下划线（_）分隔，例如： CreateTime的Snake Case风格命名为create_time</p> 
<h4><a id="3gorm_1470"></a>3、gorm模型标签</h4> 
<p>通过上面的例子，大家看到可以通过类似gorm:"column:createtime"这样的标签定义语法，定义struct字段的列名（表字段名）。</p> 
<pre><code class="prism language-go">gorm标签语法：gorm<span class="token punctuation">:</span><span class="token string">"标签定义"</span>
</code></pre> 
<p>标签定义部分，多个标签定义可以使用分号（;）分隔，例如定义列名：</p> 
<pre><code class="prism language-go">gorm<span class="token punctuation">:</span><span class="token string">"column:列名"</span>
</code></pre> 
<p>gorm常用标签如下：</p> 
<table><thead><tr><th>标签</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>column</td><td>指定列名</td><td>gorm:“column:createtime”</td></tr><tr><td>primaryKey</td><td>指定主键</td><td>gorm:“column:id; PRIMARY_KEY”</td></tr><tr><td>-</td><td>忽略字段</td><td>gorm:“-” 可以忽略struct字段，被忽略的字段不参与gorm的读写操作</td></tr></tbody></table> 
<h4><a id="_1496"></a>定义表名</h4> 
<p>可以通过定义struct类型的TableName函数实现定义模型的表名</p> 
<p>接上面的例子：</p> 
<pre><code class="prism language-go"><span class="token comment">//设置表名，可以通过给Food struct类型定义 TableName函数，返回一个字符串作为表名</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>v Sample<span class="token punctuation">)</span> <span class="token function">TableName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token string">"sample"</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>建议:</p> 
<p>默认情况下都给模型定义表名，有时候定义模型只是单纯的用于接收手写sql查询的结果，这个时候是不需要定义表名；手动通过gorm函数Table()指定表名，也不需要给模型定义TableName函数。</p> 
<h4><a id="gormModel_1519"></a>gorm.Model</h4> 
<p>GORM 定义一个 gorm.Model 结构体，其包括字段 ID、CreatedAt、UpdatedAt、DeletedAt。</p> 
<pre><code class="prism language-go"><span class="token comment">// gorm.Model 的定义</span>
<span class="token keyword">type</span> Model <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    ID        <span class="token builtin">uint</span>           <span class="token string">`gorm:"primaryKey"`</span>
    CreatedAt time<span class="token punctuation">.</span>Time
    UpdatedAt time<span class="token punctuation">.</span>Time
    DeletedAt gorm<span class="token punctuation">.</span>DeletedAt <span class="token string">`gorm:"index"`</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以将它嵌入到我们的结构体中，就以包含这几个字段，类似继承的效果。</p> 
<pre><code class="prism language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    gorm<span class="token punctuation">.</span>Model <span class="token comment">// 嵌入gorm.Model的字段</span>
    Name <span class="token builtin">string</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_1546"></a>自动更新时间</h4> 
<p>GORM 约定使用 CreatedAt、UpdatedAt 追踪创建/更新时间。</p> 
<p>如果定义了<strong>这种字段</strong>，GORM 在创建、更新时会自动填充当前时间。</p> 
<p>要使用不同名称的字段，您可以配置 autoCreateTime、autoUpdateTime 标签</p> 
<p>如果想要保存 UNIX（毫/纳）秒时间戳，而不是 time，只需简单地将 time.Time 修改为 int 即可。</p> 
<p>例子：</p> 
<pre><code class="prism language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    CreatedAt time<span class="token punctuation">.</span>Time <span class="token comment">// 默认创建时间字段， 在创建时，如果该字段值为零值，则使用当前时间填充</span>
    UpdatedAt <span class="token builtin">int</span>       <span class="token comment">// 默认更新时间字段， 在创建时该字段值为零值或者在更新时，使用当前时间戳秒数填充</span>
    Updated   <span class="token builtin">int64</span> <span class="token string">`gorm:"autoUpdateTime:nano"`</span> <span class="token comment">// 自定义字段， 使用时间戳填纳秒数充更新时间</span>
    Updated   <span class="token builtin">int64</span> <span class="token string">`gorm:"autoUpdateTime:milli"`</span> <span class="token comment">//自定义字段， 使用时间戳毫秒数填充更新时间</span>
    Created   <span class="token builtin">int64</span> <span class="token string">`gorm:"autoCreateTime"`</span>      <span class="token comment">//自定义字段， 使用时间戳秒数填充创建时间</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="gorm_1574"></a>gorm连接数据库</h3> 
<p>gorm支持多种数据库，这里主要介绍mysql,连接mysql主要有两个步骤:</p> 
<p>1）配置DSN (Data Source Name)</p> 
<p>2）使用gorm.Open连接数据库</p> 
<h4><a id="1DSN_Data_Source_Name_1586"></a>1、配置DSN (Data Source Name)</h4> 
<p>gorm库使用dsn作为连接数据库的参数，dsn翻译过来就叫数据源名称，用来描述数据库连接信息。</p> 
<p>一般都包含数据库连接地址，账号，密码之类的信息。</p> 
<p>DSN格式：</p> 
<pre><code class="prism language-cobol"><span class="token punctuation">[</span>username<span class="token punctuation">[</span><span class="token operator">:</span>password<span class="token punctuation">]</span>@<span class="token punctuation">]</span><span class="token punctuation">[</span>protocol<span class="token punctuation">[</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">/</span>dbname<span class="token punctuation">[</span><span class="token operator">?</span>param1<span class="token operator">=</span>value1<span class="token operator">&amp;</span><span class="token operator">...</span><span class="token operator">&amp;</span>paramN<span class="token operator">=</span>valueN<span class="token punctuation">]</span>
</code></pre> 
<p>mysql连接dsn例子：</p> 
<pre><code class="prism language-go"><span class="token comment">//mysql dsn格式</span>
<span class="token comment">//涉及参数:</span>
<span class="token comment">//username   数据库账号</span>
<span class="token comment">//password   数据库密码</span>
<span class="token comment">//host       数据库连接地址，可以是Ip或者域名</span>
<span class="token comment">//port       数据库端口</span>
<span class="token comment">//Dbname     数据库名</span>
username<span class="token punctuation">:</span>password@<span class="token function">tcp</span><span class="token punctuation">(</span>host<span class="token punctuation">:</span>port<span class="token punctuation">)</span><span class="token operator">/</span>Dbname?charset<span class="token operator">=</span>utf8<span class="token operator">&amp;</span>parseTime<span class="token operator">=</span>True<span class="token operator">&amp;</span>loc<span class="token operator">=</span>Local
 
<span class="token comment">//填上参数后的例子</span>
<span class="token comment">//username = root</span>
<span class="token comment">//password = 123456</span>
<span class="token comment">//host     = localhost</span>
<span class="token comment">//port     = 3306</span>
<span class="token comment">//Dbname   = tizi365</span>
<span class="token comment">//后面K/V键值对参数含义为：</span>
<span class="token comment">//  charset=utf8 客户端字符集为utf8</span>
<span class="token comment">//  parseTime=true 支持把数据库datetime和date类型转换为golang的time.Time类型</span>
<span class="token comment">//  loc=Local 使用系统本地时区</span>
root<span class="token punctuation">:</span><span class="token number">123456</span>@<span class="token function">tcp</span><span class="token punctuation">(</span>localhost<span class="token punctuation">:</span><span class="token number">3306</span><span class="token punctuation">)</span><span class="token operator">/</span>tizi365?charset<span class="token operator">=</span>utf8<span class="token operator">&amp;</span>parseTime<span class="token operator">=</span>True<span class="token operator">&amp;</span>loc<span class="token operator">=</span>Local
 
<span class="token comment">//gorm 设置mysql连接超时参数</span>
<span class="token comment">//开发的时候经常需要设置数据库连接超时参数，gorm是通过dsn的timeout参数配置</span>
<span class="token comment">//例如，设置10秒后连接超时，timeout=10s</span>
<span class="token comment">//下面是完成的例子</span>
root<span class="token punctuation">:</span><span class="token number">123456</span>@<span class="token function">tcp</span><span class="token punctuation">(</span>localhost<span class="token punctuation">:</span><span class="token number">3306</span><span class="token punctuation">)</span><span class="token operator">/</span>tizi365?charset<span class="token operator">=</span>utf8<span class="token operator">&amp;</span>parseTime<span class="token operator">=</span>True<span class="token operator">&amp;</span>loc<span class="token operator">=</span>Local<span class="token operator">&amp;</span>timeout<span class="token operator">=</span><span class="token number">10</span>s
 
<span class="token comment">//设置读写超时时间</span>
<span class="token comment">// readTimeout - 读超时时间，0代表不限制</span>
<span class="token comment">// writeTimeout - 写超时时间，0代表不限制</span>
root<span class="token punctuation">:</span><span class="token number">123456</span>@<span class="token function">tcp</span><span class="token punctuation">(</span>localhost<span class="token punctuation">:</span><span class="token number">3306</span><span class="token punctuation">)</span><span class="token operator">/</span>tizi365?charset<span class="token operator">=</span>utf8<span class="token operator">&amp;</span>parseTime<span class="token operator">=</span>True<span class="token operator">&amp;</span>loc<span class="token operator">=</span>Local<span class="token operator">&amp;</span>timeout<span class="token operator">=</span><span class="token number">10</span>s<span class="token operator">&amp;</span>readTimeout<span class="token operator">=</span><span class="token number">30</span>s<span class="token operator">&amp;</span>writeTimeout<span class="token operator">=</span><span class="token number">60</span>s
</code></pre> 
<h4><a id="2gormOpen_1642"></a>2、使用gorm.Open连接数据库</h4> 
<p>有了上面配置的dsn参数，就可以使用gorm连接数据库，下面是连接数据库的例子</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main
 
<span class="token keyword">import</span> <span class="token punctuation">(</span>
  <span class="token string">"gorm.io/driver/mysql"</span>
  <span class="token string">"gorm.io/gorm"</span>
<span class="token punctuation">)</span>
 
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//配置MySQL连接参数</span>
	username <span class="token operator">:=</span> <span class="token string">"root"</span>  <span class="token comment">//账号</span>
	password <span class="token operator">:=</span> <span class="token string">"123456"</span> <span class="token comment">//密码</span>
	host <span class="token operator">:=</span> <span class="token string">"127.0.0.1"</span> <span class="token comment">//数据库地址，可以是Ip或者域名</span>
	port <span class="token operator">:=</span> <span class="token number">3306</span> <span class="token comment">//数据库端口</span>
	Dbname <span class="token operator">:=</span> <span class="token string">"tizi365"</span> <span class="token comment">//数据库名</span>
	timeout <span class="token operator">:=</span> <span class="token string">"10s"</span> <span class="token comment">//连接超时，10秒</span>
	
	<span class="token comment">//拼接下dsn参数, dsn格式可以参考上面的语法，这里使用Sprintf动态拼接dsn参数，因为一般数据库连接参数，我们都是保存在配置文件里面，需要从配置文件加载参数，然后拼接dsn。</span>
	dsn <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s:%s@tcp(%s:%d)/%s?charset=utf8&amp;parseTime=True&amp;loc=Local&amp;timeout=%s"</span><span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">,</span> host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> Dbname<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span>
	<span class="token comment">//连接MYSQL, 获得DB类型实例，用于后面的数据库读写操作。</span>
	db<span class="token punctuation">,</span> err <span class="token operator">:=</span> gorm<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>mysql<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>dsn<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>gorm<span class="token punctuation">.</span>Config<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"连接数据库失败, error="</span> <span class="token operator">+</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//延时关闭数据库连接</span>
	<span class="token keyword">defer</span> db<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="3gorm_1679"></a>3、gorm调试模式</h4> 
<p>为了方便调试，了解gorm操作到底执行了怎么样的sql语句，开发的时候需要打开调试日志，这样gorm会打印出执行的每一条sql语句。</p> 
<p>使用Debug函数执行查询即可</p> 
<pre><code class="prism language-sql">result :<span class="token operator">=</span> db<span class="token punctuation">.</span>Debug<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">Where</span><span class="token punctuation">(</span><span class="token string">"username = ?"</span><span class="token punctuation">,</span> <span class="token string">"tizi365"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">First</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>u<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="4gorm_1695"></a>4、gorm连接池</h4> 
<p>在高并发实践中，为了提高数据库连接的使用率，避免重复建立数据库连接带来的性能消耗，会经常使用数据库连接池技术来维护数据库连接。</p> 
<p>gorm自带了数据库连接池使用非常简单只要设置下数据库连接池参数即可。</p> 
<p>数据库连接池使用例子：</p> 
<p>定义tools包，负责数据库初始化工作（备注：借助连接池说明，一般在操作数据库时，可以将数据库连接单独封装成一个包）</p> 
<pre><code class="prism language-go"><span class="token comment">// 定义一个工具包，用来管理gorm数据库连接池的初始化工作。</span>
<span class="token keyword">package</span> tools

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"gorm.io/driver/mysql"</span>
	<span class="token string">"gorm.io/gorm"</span>
<span class="token punctuation">)</span>

<span class="token comment">// 定义全局的db对象，我们执行数据库操作主要通过他实现。</span>
<span class="token keyword">var</span> _db <span class="token operator">*</span>gorm<span class="token punctuation">.</span>DB

<span class="token comment">// 包初始化函数，golang特性，每个包初始化的时候会自动执行init函数，这里用来初始化gorm。</span>
<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

	<span class="token comment">//配置MySQL连接参数</span>
	host <span class="token operator">:=</span> <span class="token string">"192.168.56.121"</span> <span class="token comment">//数据库地址，可以是Ip或者域名</span>
	username <span class="token operator">:=</span> <span class="token string">"root"</span>       <span class="token comment">//账号</span>
	password <span class="token operator">:=</span> <span class="token string">"123456"</span>     <span class="token comment">//密码</span>
	port <span class="token operator">:=</span> <span class="token number">3306</span>             <span class="token comment">//数据库端口</span>
	Dbname <span class="token operator">:=</span> <span class="token string">"store"</span>        <span class="token comment">//数据库名</span>
	timeout <span class="token operator">:=</span> <span class="token string">"10s"</span>         <span class="token comment">//连接超时，10秒</span>

	<span class="token comment">//拼接下dsn参数, dsn格式可以参考上面的语法，这里使用Sprintf动态拼接dsn参数，因为一般数据库连接参数，我们都是保存在配置文件里面，需要从配置文件加载参数，然后拼接dsn。</span>
	dsn <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s:%s@tcp(%s:%d)/%s?charset=utf8&amp;parseTime=True&amp;loc=Local&amp;timeout=%s"</span><span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">,</span> host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> Dbname<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span>

	<span class="token comment">// 声明err变量，下面不能使用:=赋值运算符，否则_db变量会当成局部变量，导致外部无法访问_db变量</span>
	<span class="token keyword">var</span> err <span class="token builtin">error</span>
	<span class="token comment">//连接MYSQL, 获得DB类型实例，用于后面的数据库读写操作。</span>
	_db<span class="token punctuation">,</span> err <span class="token operator">=</span> gorm<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>mysql<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>dsn<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>gorm<span class="token punctuation">.</span>Config<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"连接数据库失败, error="</span> <span class="token operator">+</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	sqlDB<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> _db<span class="token punctuation">.</span><span class="token function">DB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">//设置数据库连接池参数</span>
	sqlDB<span class="token punctuation">.</span><span class="token function">SetMaxOpenConns</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">//设置数据库连接池最大连接数</span>
	sqlDB<span class="token punctuation">.</span><span class="token function">SetMaxIdleConns</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>  <span class="token comment">//连接池最大允许的空闲连接数，如果没有sql任务需要执行的连接数大于20，超过的连接会被连接池关闭。</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取gorm db对象，其他包需要执行数据库查询的时候，只要通过tools.getDB()获取db对象即可。</span>
<span class="token comment">// 不用担心协程并发使用同样的db对象会共用同一个连接，db对象在调用他的方法的时候会从数据库连接池中获取新的连接</span>
<span class="token keyword">func</span> <span class="token function">GetDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>gorm<span class="token punctuation">.</span>DB <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> _db
<span class="token punctuation">}</span>
</code></pre> 
<p>使用例子：</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main
<span class="token comment">//导入tools包</span>
<span class="token keyword">import</span> tools
 
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//获取DB</span>
    db <span class="token operator">:=</span> tools<span class="token punctuation">.</span><span class="token function">GetDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token comment">//执行数据库查询操作</span>
    u <span class="token operator">:=</span> User<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token comment">//自动生成sql： SELECT * FROM `users`  WHERE (username = 'tizi365') LIMIT 1</span>
	db<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span><span class="token string">"username = ?"</span><span class="token punctuation">,</span> <span class="token string">"tizi365"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">First</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>u<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注意：使用连接池技术后，千万不要使用完db后调用db.Close关闭数据库连接，这样会导致整个数据库连接池关闭，导致连接池没有可用的连接。</p> 
<h3><a id="CRUD_1774"></a>CRUD操作</h3> 
<p>gorm 是一个 Go 语言的 ORM（Object Relational Mapping）库，可以方便地操作数据库。下面是 gorm 模块的使用步骤：</p> 
<h4><a id="_1778"></a>插入数据</h4> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">InsertDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

	<span class="token comment">// 创建 Sample 实例</span>
	Sample <span class="token operator">:=</span> Sample<span class="token punctuation">{<!-- --></span>Id<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> Title<span class="token punctuation">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span> CreateTime<span class="token punctuation">:</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
	<span class="token comment">//获取DB</span>
	MysqlDB <span class="token operator">:=</span> tools<span class="token punctuation">.</span><span class="token function">GetDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// 添加数据</span>
	MysqlDB<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Sample<span class="token punctuation">)</span>

	<span class="token comment">// 获取添加后的自增 ID</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>Sample<span class="token punctuation">.</span>Id<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>执行结果</p> 
<p><img src="https://images2.imgbox.com/76/20/B7ScuvSK_o.png" alt=""></p> 
<h4><a id="_1801"></a>查询数据</h4> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">SearchDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//获取DB</span>
	db <span class="token operator">:=</span> tools<span class="token punctuation">.</span><span class="token function">GetDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">//获取第一个 Sample 记录</span>
	<span class="token keyword">var</span> firstSample Sample
	db<span class="token punctuation">.</span><span class="token function">First</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>firstSample<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"('%d','%s','%s');"</span><span class="token punctuation">,</span> firstSample<span class="token punctuation">.</span>Id<span class="token punctuation">,</span> firstSample<span class="token punctuation">.</span>Title<span class="token punctuation">,</span> firstSample<span class="token punctuation">.</span>CreateTime<span class="token punctuation">)</span>
	<span class="token comment">// 条件查询</span>
	<span class="token keyword">var</span> sample Sample
	db<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span><span class="token string">"title = ?"</span><span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">First</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sample<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"('%d','%s','%s');"</span><span class="token punctuation">,</span> firstSample<span class="token punctuation">.</span>Id<span class="token punctuation">,</span> firstSample<span class="token punctuation">.</span>Title<span class="token punctuation">,</span> firstSample<span class="token punctuation">.</span>CreateTime<span class="token punctuation">)</span>

	<span class="token comment">// 查询所有 Sample 记录</span>
	<span class="token keyword">var</span> samples <span class="token punctuation">[</span><span class="token punctuation">]</span>Sample
	db<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>samples<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/20/16/bBcGSkLK_o.png" alt=""></p> 
<h4><a id="_1826"></a>更新数据</h4> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">UpdateDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//获取DB</span>
	db <span class="token operator">:=</span> tools<span class="token punctuation">.</span><span class="token function">GetDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">//获取第一个 Sample 记录</span>
	<span class="token keyword">var</span> sample Sample
	db<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span><span class="token string">"title = ?"</span><span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">First</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sample<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"('%d','%s','%s');"</span><span class="token punctuation">,</span> sample<span class="token punctuation">.</span>Id<span class="token punctuation">,</span> sample<span class="token punctuation">.</span>Title<span class="token punctuation">,</span> sample<span class="token punctuation">.</span>CreateTime<span class="token punctuation">)</span>

	<span class="token comment">// 更新指定字段</span>
	db<span class="token punctuation">.</span><span class="token function">Model</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sample<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Update</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>

	<span class="token comment">// 更新多个字段</span>
	db<span class="token punctuation">.</span><span class="token function">Model</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sample<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Updates</span><span class="token punctuation">(</span>Sample<span class="token punctuation">{<!-- --></span>Id<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span> Title<span class="token punctuation">:</span> <span class="token string">"李四"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_1847"></a>删除数据</h4> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">DeleteDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//获取DB</span>
	db <span class="token operator">:=</span> tools<span class="token punctuation">.</span><span class="token function">GetDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">//获取第一个 Sample 记录</span>
	<span class="token keyword">var</span> sample Sample
	db<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span><span class="token string">"title = ?"</span><span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">First</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sample<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"('%d','%s','%s');"</span><span class="token punctuation">,</span> sample<span class="token punctuation">.</span>Id<span class="token punctuation">,</span> sample<span class="token punctuation">.</span>Title<span class="token punctuation">,</span> sample<span class="token punctuation">.</span>CreateTime<span class="token punctuation">)</span>

	<span class="token comment">// 删除 sample 记录</span>
	db<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sample<span class="token punctuation">)</span>
	<span class="token comment">// 根据条件删除多个记录</span>
	db<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span><span class="token string">"title = ?"</span><span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Sample<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这些是 gorm 模块的基本使用方法，可以根据实际需求进行调整和扩展。</p> 
<h4><a id="gomysql_1869"></a>go与mysql数据类型关系</h4> 
<p><img src="https://images2.imgbox.com/db/66/WKMYzLK4_o.png" alt=""></p> 
<h4><a id="mysql_1873"></a>mysql日期时间格式</h4> 
<p><img src="https://images2.imgbox.com/3c/f7/O8ACeyFn_o.png" alt=""></p> 
<h4><a id="go__mysql_TIMESTAMP_1877"></a>go 存储 mysql TIMESTAMP格式</h4> 
<pre><code class="prism language-go">存：
<span class="token keyword">type</span> TestTime <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>
CreatedAt      time<span class="token punctuation">.</span>Time 
<span class="token punctuation">}</span>

m<span class="token operator">:=</span><span class="token function">new</span><span class="token punctuation">(</span>TestTime<span class="token punctuation">)</span>
m<span class="token punctuation">.</span>CreatedAt<span class="token operator">:=</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

取：
<span class="token keyword">go</span> orm 取TestTime结构体数据
str<span class="token operator">:=</span>orm_data<span class="token punctuation">.</span>CreatedAt<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"2006-01-02 15:04:05"</span><span class="token punctuation">)</span>
str <span class="token operator">==</span> <span class="token string">"2019-08-27 09:35:13"</span>
</code></pre> 
<h3><a id="__DB_1896"></a>高并发实操： 消息队列削峰解耦+ 批量写入DB</h3> 
<h4><a id="_1898"></a>为什么要使用消息队列</h4> 
<p>三个最主要的应用场景：解耦、异步、削峰</p> 
<ul><li>削峰填谷（最主要的作用）可以削去到达系统的峰值流量，让业务逻辑的处理更加缓和；但是会造成请求处理的延迟</li><li>异步处理可以简化业务流程中的步骤，提升系统性能； 
  <ul><li>需要分清同步流程和异步流程的边界</li><li>消息存在着丢失的风险</li></ul> </li><li>解耦合可以将系统和系统解耦开，这样两个系统的任何变更都不会影响到另一个系统</li></ul> 
<h5><a id="_1910"></a>削峰</h5> 
<p>传统模式：并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常</p> 
<p><img src="https://images2.imgbox.com/56/63/HmO5LkiN_o.png" alt=""></p> 
<p>消息队列模式：系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。</p> 
<p>在生产中，这个短暂的高峰期积压是允许的。</p> 
<p><img src="https://images2.imgbox.com/24/b1/nsrEoDQ1_o.png" alt=""></p> 
<h5><a id="_1923"></a>解耦</h5> 
<p>传统模式:系统间耦合性太强，如下图所示，</p> 
<p>系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统A还需要修改代码，过于麻烦！</p> 
<p><img src="https://images2.imgbox.com/9b/eb/g3MYGdyp_o.png" alt=""></p> 
<p>消息队列模式：将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统A不需要做任何修改</p> 
<p><img src="https://images2.imgbox.com/95/3b/7P4yQRlo_o.png" alt=""></p> 
<h5><a id="_1942"></a>异步</h5> 
<p>传统模式：一些非必要的业务逻辑以同步的方式运行，太耗费时间。</p> 
<p><img src="https://images2.imgbox.com/15/3a/GRodYvP6_o.png" alt=""></p> 
<p>消息队列模式： 将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快相应速度。</p> 
<p><img src="https://images2.imgbox.com/e0/dd/viPsVC9d_o.png" alt=""></p> 
<h4><a id="GO_1958"></a>实操：用GO实现消息队列削峰解耦</h4> 
<p>用GO实现消息队列削峰解耦，参考代码如下：</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> batchprocess


<span class="token comment">// 创建生产者</span>
<span class="token keyword">const</span> SAMPLE_TOPIC <span class="token operator">=</span> <span class="token string">"sample"</span>

<span class="token keyword">func</span> <span class="token function">ProducerStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

	producer<span class="token punctuation">,</span> err <span class="token operator">:=</span> rocketmq<span class="token punctuation">.</span><span class="token function">NewProducer</span><span class="token punctuation">(</span>
		producer<span class="token punctuation">.</span><span class="token function">WithNameServer</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{<!-- --></span>NAME_NODE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		producer<span class="token punctuation">.</span><span class="token function">WithRetry</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">)</span>
<span class="token operator">...</span>

	<span class="token comment">// 发送消息，无限循环</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>

		sample <span class="token operator">:=</span> Sample<span class="token punctuation">{<!-- --></span>Id<span class="token punctuation">:</span> <span class="token function">int64</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Title<span class="token punctuation">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span> CreateTime<span class="token punctuation">:</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
		<span class="token comment">//序列化</span>
		json<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sample<span class="token punctuation">)</span>

		msg <span class="token operator">:=</span> <span class="token operator">&amp;</span>primitive<span class="token punctuation">.</span>Message<span class="token punctuation">{<!-- --></span>
			Topic<span class="token punctuation">:</span> SAMPLE_TOPIC<span class="token punctuation">,</span>
			Body<span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token punctuation">}</span>
		res<span class="token punctuation">,</span> err <span class="token operator">:=</span> producer<span class="token punctuation">.</span><span class="token function">SendSync</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"send Sample error: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"send Sample success: %v\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">ConsumerStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

	<span class="token comment">// 创建消费者</span>
	c<span class="token punctuation">,</span> err <span class="token operator">:=</span> rocketmq<span class="token punctuation">.</span><span class="token function">NewPushConsumer</span><span class="token punctuation">(</span>
		consumer<span class="token punctuation">.</span><span class="token function">WithNameServer</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{<!-- --></span>NAME_NODE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		consumer<span class="token punctuation">.</span><span class="token function">WithGroupName</span><span class="token punctuation">(</span><span class="token string">"test-group"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">)</span>

	err <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">Subscribe</span><span class="token punctuation">(</span>SAMPLE_TOPIC<span class="token punctuation">,</span> consumer<span class="token punctuation">.</span>MessageSelector<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">,</span>
		<span class="token keyword">func</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> msgs <span class="token operator">...</span><span class="token operator">*</span>primitive<span class="token punctuation">.</span>MessageExt<span class="token punctuation">)</span> <span class="token punctuation">(</span>consumer<span class="token punctuation">.</span>ConsumeResult<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

			<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> msg <span class="token operator">:=</span> <span class="token keyword">range</span> msgs <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">var</span> sample Sample
				err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>Body<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sample<span class="token punctuation">)</span>
				<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
					fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
				<span class="token punctuation">}</span>
				fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>sample<span class="token punctuation">)</span>

				messageMysqlChan <span class="token operator">&lt;-</span> sample <span class="token comment">// 加入通道</span>
				log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"receive Sample: topic=%s, body=%s\n"</span><span class="token punctuation">,</span>
					msg<span class="token punctuation">.</span>Topic<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>Body<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> consumer<span class="token punctuation">.</span>ConsumeSuccess<span class="token punctuation">,</span> <span class="token boolean">nil</span>
		<span class="token punctuation">}</span><span class="token punctuation">)</span>

	wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>执行的效果如下（后面尼恩会在 穿透云原生视频中，进行详细介绍）：</p> 
<p><img src="https://images2.imgbox.com/db/fb/NOjPeRXO_o.png" alt=""></p> 
<h4><a id="MySQL_2033"></a>为什么应该使用批量插入来提高MySQL性能？</h4> 
<p>MySQL是一种常用的开源关系数据库管理系统（RDBMS），常用于建立网站和应用程序后端的数据存储和管理系统。但随着数据量的增大，MySQL的性能也会逐渐下降，此时需要使用批量插入来提高MySQL性能。</p> 
<p>批量插入是指一次性向MySQL数据库中插入多条记录，相对于逐个插入单条记录，批量插入可以大大提高MySQL的性能。那么，为什么应该使用批量插入呢？以下是几个原因。</p> 
<ol><li>减少网络往返次数</li></ol> 
<p>MySQL是一种客户端/服务器模式的数据库，在客户端插入一条记录时，需要与MySQL服务器建立一次网络连接，而这个过程将耗费时间和带宽。如果每插入一条记录就要建立一次网络连接，那么对于大批量的数据插入将会非常低效。通过批量插入，可以减少网络连接次数，从而提高MySQL的性能。</p> 
<ol start="2"><li>减少SQL语句的解析次数</li></ol> 
<p>MySQL中，每条SQL语句都需要进行解析并编译成执行计划，这个过程也需要耗费时间。如果逐个插入单条记录，那么每条SQL语句都需要解析和编译，而使用批量插入，只需要解析和编译一次SQL语句即可，从而减少了SQL语句的解析次数，提高MySQL的性能。</p> 
<ol start="3"><li>减少磁盘I/O操作</li></ol> 
<p>MySQL将数据存储在磁盘上，每次向磁盘写入一条记录都将会进行一次磁盘I/O操作。如果逐个插入单条记录，那么每次插入都将会进行一次磁盘I/O操作，而使用批量插入，多条记录将会一起写入磁盘，从而减少了磁盘I/O操作，提高了MySQL的性能。</p> 
<ol start="4"><li>减少锁的竞争</li></ol> 
<p>在MySQL中，插入一条记录时需要获取表级锁或行级锁，如果逐个插入单条记录，那么每次插入都将会竞争锁资源，从而影响MySQL的性能。使用批量插入时，多条记录被看做一个事务，只需要获取一次锁，从而减少了锁的竞争，提高了MySQL的性能。</p> 
<p>以上是使用批量插入来提高MySQL性能的几个原因。但是，批量插入也存在一些缺点，例如批量插入一起错误时很难进行回滚操作，可能导致数据的不一致性。因此，在使用批量插入时，需谨慎考虑。</p> 
<p>总而言之，使用批量插入是提高MySQL性能的有效方式，可以减少网络连接次数、SQL语句的解析次数、磁盘I/O操作和锁的竞争，从而提高MySQL的性能。但是，在使用批量插入时也需要注意一些可能的缺陷。</p> 
<h4><a id="GO_2059"></a>实操：用GO实现批量写入</h4> 
<pre><code class="prism language-go"><span class="token keyword">package</span> batchprocess

<span class="token keyword">func</span> <span class="token function">StartBatchWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	messageMysqlChan <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> Sample<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
	insertedFlags <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int64</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">)</span>

	<span class="token keyword">go</span> <span class="token function">batchMessageReceive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token function">batchStartTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
接收消息的逻辑，只负责接收消息
*/</span>
<span class="token keyword">func</span> <span class="token function">batchMessageReceive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">select</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">case</span> oneMessage <span class="token operator">:=</span> <span class="token operator">&lt;-</span>messageMysqlChan<span class="token punctuation">:</span>
			mesLock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			tmpMessage <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>tmpMessage<span class="token punctuation">,</span> oneMessage<span class="token punctuation">)</span>
			mesLock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">batch</span><span class="token punctuation">(</span>batchMessage <span class="token punctuation">[</span><span class="token punctuation">]</span>Sample<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>batchMessage<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  空消息"</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">var</span> buffer bytes<span class="token punctuation">.</span>Buffer
	sql <span class="token operator">:=</span> <span class="token string">"insert into `sample` (`id`,`title`,`create_time`) values"</span>
	<span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> buffer<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">for</span> index<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> batchMessage <span class="token punctuation">{<!-- --></span>

		<span class="token comment">/*查看元素在集合中是否存在 */</span>
		<span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> insertedFlags<span class="token punctuation">[</span>value<span class="token punctuation">.</span>Id<span class="token punctuation">]</span> <span class="token comment">/*如果确定是处理过 */</span>
		<span class="token keyword">if</span> ok <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">continue</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			insertedFlags<span class="token punctuation">[</span>value<span class="token punctuation">.</span>Id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> index <span class="token operator">==</span> <span class="token function">len</span><span class="token punctuation">(</span>batchMessage<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">{<!-- --></span>
			buffer<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"('%d','%s','%s');"</span><span class="token punctuation">,</span> value<span class="token punctuation">.</span>Id<span class="token punctuation">,</span> value<span class="token punctuation">.</span>Title<span class="token punctuation">,</span> value<span class="token punctuation">.</span>CreateTime<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"2006-01-02 15:04:05"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			buffer<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"('%d','%s','%s'),"</span><span class="token punctuation">,</span> value<span class="token punctuation">.</span>Id<span class="token punctuation">,</span> value<span class="token punctuation">.</span>Title<span class="token punctuation">,</span> value<span class="token punctuation">.</span>CreateTime<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"2006-01-02 15:04:05"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//获取DB</span>
	MysqlDB <span class="token operator">:=</span> tools<span class="token punctuation">.</span><span class="token function">GetDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	err <span class="token operator">:=</span> MysqlDB<span class="token punctuation">.</span><span class="token function">Exec</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Error
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"插入数据库失败："</span><span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>

		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"插入数据库成功,一共插入的条数： %d："</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>batchMessage<span class="token punctuation">)</span><span class="token punctuation">)</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"祝贺"</span><span class="token punctuation">)</span>

	<span class="token punctuation">}</span>
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_2131"></a>执行效果</h4> 
<p>执行的效果如下（后面尼恩会在 穿透云原生视频中，进行详细介绍）：</p> 
<p><img src="https://images2.imgbox.com/98/42/2XNs6wvF_o.png" alt=""></p> 
<h3><a id="Golang__GC_2139"></a>Golang GC垃圾回收器</h3> 
<h4><a id="Cache__Buffer_2141"></a>Cache 和 Buffer的区别</h4> 
<p>在理解垃圾回收之前,我们先理解一下Cache 和 Buffer，这两个都是缓存，这两者之间有什么区别呢？</p> 
<p>buffer：缓冲</p> 
<p>用于存储速度不同步的设备或优先级不同的设备之间传输数据；通过buffer可以减少进程间通信需要等待的时间，当存储速度快的设备与存储速度慢的设备进行通信时，存储慢的数据先把数据存放到buffer，达到一定程度存储快的设备再读取buffer的数据，在此期间存储快的设备CPU可以做其他的事情。</p> 
<pre><code>A buffer is something that has yet to be "written" to disk.
</code></pre> 
<p>cache：缓存</p> 
<p>是高速缓存，是位于CPU和主内存之间的容量较小但速度很快的存储器，因为CPU的速度远远高于主内存的速度，CPU从内存中读取数据需等待很长的时间，而 Cache保存着CPU刚用过的数据或循环使用的部分数据，这时从Cache中读取数据会更快，减少了CPU等待的时间，提高了系统的性能。</p> 
<pre><code>A cache is something that has been "read" from the disk and stored for later use.
</code></pre> 
<p>buffer是用于存放将要输出到disk（块设备）的数据,进行流量整形，把突发的大数量较小规模的 I/O 整理成平稳的小数量较大规模的 I/O，以<strong>减少响应次数</strong>，而cache是存放从disk上读出的数据,为了弥补高速设备和低速设备的鸿沟而引入的中间层，最终起到<strong>加快访问速度</strong>的作用。。二者都是为提高IO性能而设计的。</p> 
<p>而Go标准库Buffer是一个可变大小的字节缓冲区,可以用Wirte和Read方法操作它.</p> 
<h4><a id="Golang_GC_2165"></a>Golang GC发展史</h4> 
<p>通常在编程中的垃圾指内存中不再使用的内存区域，自动发现与释放这种内存区域的过程就是垃圾回收。</p> 
<p>内存资源是有限的，而垃圾回收可以让内存重复使用，并且减轻开发者对内存管理的负担，减少程序中的内存问题。</p> 
<p>我们透过这个来看下Go垃圾回收发展史:</p> 
<ul><li>go1.1，提高效率和垃圾回收精确度。</li><li>go1.3，提高了垃圾回收的精确度。</li><li>go1.4，之前版本的runtime大部分是使用C写的，这个版本大量使用Go进行了重写，让GC有了扫描stack的能力，进一步提高了垃圾回收的精确度。</li><li>go1.5，目标是降低GC延迟，采用了并发标记和并发清除，三色标记，write barrier，以及实现了更好的回收器调度，设计文档1，文档2，以及这个版本的[Go talk]。</li><li>go1.6，小优化，当程序使用大量内存时，GC暂停时间有所降低。</li><li>go1.7，小优化，当程序有大量空闲goroutine，stack大小波动比较大时，GC暂停时间有显著降低。</li><li>go1.8，write barrier切换到hybrid write barrier，以消除STW中的re-scan，把STW的最差情况降低到50us，设计文档。</li></ul> 
<p>混合屏障的优势在于它允许堆栈扫描永久地使堆栈变黑（没有STW并且没有写入堆栈的障碍），这完全消除了堆栈重新扫描的需要，从而消除了对堆栈屏障的需求。重新扫描列表。特别是堆栈障碍在整个运行时引入了显着的复杂性，并且干扰了来自外部工具（如GDB和基于内核的分析器）的堆栈遍历。</p> 
<p>此外，与Dijkstra风格的写屏障一样，混合屏障不需要读屏障，因此指针读取是常规的内存读取; 它确保了进步，因为物体单调地从白色到灰色再到黑色。</p> 
<p>混合屏障的缺点很小。它可能会导致更多的浮动垃圾，因为它会在标记阶段的任何时刻保留从根（堆栈除外）可到达的所有内容。然而，在实践中，当前的Dijkstra障碍可能几乎保留不变。混合屏障还禁止某些优化：特别是，如果Go编译器可以静态地显示指针是nil，则Go编译器当前省略写屏障，但是在这种情况下混合屏障需要写屏障。这可能会略微增加二进制大小。</p> 
<ul><li>go1.9，提升指标主要是:</li></ul> 
<ol><li>过去 <code>runtime.GC</code>, <code>debug.SetGCPercent</code>, 和 <code>debug.FreeOSMemory</code>都不能触发并发GC，他们触发的GC都是阻塞的，go1.9可以了，变成了在垃圾回收之前只阻塞调用GC的goroutine。</li><li><code>debug.SetGCPercent</code>只在有必要的情况下才会触发GC。</li></ol> 
<ul><li>go.1.10，小优化，加速了GC，程序应当运行更快一点点。</li><li>go1.12，显著提高了堆内存存在大碎片情况下的sweeping性能，能够降低GC后立即分配内存的延迟。</li></ul> 
<h3><a id="_5W_2196"></a>还有 5W字待发布</h3> 
<p>本文，仅仅是《Golang 圣经》 的第一部分。</p> 
<p>《Golang 圣经》后面的内容 更加精彩，涉及到<strong>高并发、分布式微服务架构、 WEB开发架构</strong>，具体请关注进展，请关注《技术自由圈》 公众号。</p> 
<p>如果需要领取 《Golang 圣经》， 请关注《技术自由圈》 公众号，发送暗号 “领电子书” 。</p> 
<p>最后，如果学习过程中遇到问题，可以来尼恩的 万人高并发社群中交流。</p> 
<h3><a id="_2207"></a>参考资料</h3> 
<ul><li><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Na.C3.AFve_mark-and-sweep" rel="nofollow">Tracing Garbage Collection - wikipedia</a></li><li><a href="http://www.cs.utexas.edu/users/mckinley/395Tmm/talks/Mar-30-Dijkstra.pdf" rel="nofollow">On-the-fly Garbage Collection: an exercise in cooperation.</a></li><li><a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" rel="nofollow">Garbage Collection</a></li><li><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" rel="nofollow">Tracing Garbage Collection</a></li><li><a href="https://www.youtube.com/watch?v=P1rU_9IB414" rel="nofollow">Copying Garbage Collection</a></li><li><a href="https://www.youtube.com/watch?v=pJHISaOW6Vc" rel="nofollow">Generational Garbage Collection</a></li><li><a href="https://github.com/KeKe-Li/book/blob/master/Go/go-gc.pdf">Golang Gc Talk</a></li><li><a href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md">Eliminate Rescan</a></li></ul> 
<h3><a id="_PDF_2222"></a>技术自由的实现路径 PDF：</h3> 
<h5><a id="__2224"></a>实现你的 架构自由：</h5> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/129204455">吃透8图1模板，人人可以做架构</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/129410795">10Wqps评论中台，如何架构？B站是这么做的！！！</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/128848309">阿里二面：千万级、亿级数据，如何性能优化？ 教科书级 答案来了</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/128725701">峰值21WQps、亿级DAU，小游戏《羊了个羊》是怎么架构的？</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/129145200">100亿级订单怎么调度，来一个大厂的极品方案</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/128697096">2个大厂 100亿级 超大流量 红包 架构方案</a>》</p> 
<p><em>… 更多架构文章，正在添加中</em></p> 
<h5><a id="___2242"></a>实现你的 响应式 自由：</h5> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/129022714">响应式圣经：10W字，实现Spring响应式编程自由</a>》</p> 
<p>这是老版本 《<a href="https://blog.csdn.net/crazymakercircle/article/details/124120506">Flux、Mono、Reactor 实战（史上最全）</a>》</p> 
<h5><a id="_spring_cloud__2250"></a>实现你的 spring cloud 自由：</h5> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/129559428">Spring cloud Alibaba 学习圣经</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/123420859">分库分表 Sharding-JDBC 底层原理、核心实战（史上最全）</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/125135726">一文搞定：SpringBoot、SLF4j、Log4j、Logback、Netty之间混乱关系（史上最全）</a>》</p> 
<h5><a id="_linux__2261"></a>实现你的 linux 自由：</h5> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/128932396">Linux命令大全：2W多字，一次实现Linux自由</a>》</p> 
<h5><a id="___2267"></a>实现你的 网络 自由：</h5> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/114527369">TCP协议详解 (史上最全)</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/129334254">网络三张表：ARP表, MAC表, 路由表，实现你的网络自由！！</a>》</p> 
<h5><a id="___2275"></a>实现你的 分布式锁 自由：</h5> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/116425814">Redis分布式锁（图解 - 秒懂 - 史上最全）</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/85956246">Zookeeper 分布式锁 - 图解 - 秒懂</a>》</p> 
<h5><a id="___2283"></a>实现你的 王者组件 自由：</h5> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/128264803">队列之王： Disruptor 原理、架构、源码 一文穿透</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/128123114">缓存之王：Caffeine 源码、架构、原理（史上最全，10W字 超级长文）</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/113751575">缓存之王：Caffeine 的使用（史上最全）</a>》</p> 
<p>《<a href="https://blog.csdn.net/crazymakercircle/article/details/126579528">Java Agent 探针、字节码增强 ByteBuddy（史上最全）</a>》</p> 
<h5><a id="___2295"></a>实现你的 面试题 自由：</h5> 
<p><a href="https://blog.csdn.net/crazymakercircle/article/details/124790425">4000页《尼恩Java面试宝典 》 40个专题</a></p> 
<p>以上尼恩 架构笔记、面试题 的PDF文件更新，请到下面《技术自由圈》公号取↓↓↓</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5c0d80ea30e7b0a26f75eb01b7a6c050/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">奇怪的AndroidStudio报错--checkDebugAarMetadata--修改SDK版本为33成功修复</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/70f85e7e72ab0c65eb6c89e4e4d4af85/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Qt中QString转string中文乱码问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>