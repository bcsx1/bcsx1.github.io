<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JS 《》 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JS 《》" />
<meta property="og:description" content="前端全部面试题 https://blog.csdn.net/qq_40055200/article/details/104637574
1.基本数据类型有哪几种?(高频)了解包装对象吗？
undefined,null,boolean,string,number,Symbol(es6)
2.包装对象 定义：基础数据类型临时创建的对象 (1).哪些基本数据类型有/没有包装对象？
有：数字，字符串，布尔
没有：null,undefined
(2).包装对象和基本数据类型的转换，举例子：
// 基本数据类型转换为包装对象 var v1 = new Number(123); var v2 = new String(&#39;abc&#39;); var v3 = new Boolean(true); typeof v1 // &#34;object&#34; typeof v2 // &#34;object&#34; typeof v3 // &#34;object&#34; // 包装对象转换为基本数据类型 new Number(123).valueOf() // 123 new String(&#39;abc&#39;).valueOf() // &#34;abc&#34; new Boolean(true).valueOf() // true v1.toString(); // &#39;123&#39; v1&#43; &#39;&#39;; // &#39;123&#39; （4)包装对象的应用场景及优缺点
为什么null,undefined不能创建成包装对象（不用看）
在 JavaScript 中，null 和 undefined 是特殊的值，而不是对象。它们是原始类型，在内部被硬编码为特定的值。因此，它们没有对应的构造函数，也就没有包装对象。在尝试访问它们的属性或方法时，会直接抛出 TypeError 错误。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/919fe0be53b97c6bd76be512878e23af/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-01T14:08:57+08:00" />
<meta property="article:modified_time" content="2023-12-01T14:08:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JS 《》</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#956fe7;"><strong>前端全部面试题 </strong></span> </p> 
<blockquote> 
 <p><a href="https://blog.csdn.net/qq_40055200/article/details/104637574" title="https://blog.csdn.net/qq_40055200/article/details/104637574">https://blog.csdn.net/qq_40055200/article/details/104637574</a></p> 
</blockquote> 
<blockquote> 
 <p><strong>1.基本数据类型有哪几种?(高频)了解包装对象吗？</strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">undefined,null,boolean,string,number,Symbol(es6)</span></p> 
<blockquote> 
 <p><strong>2.包装对象 </strong></p> 
</blockquote> 
<p>定义：<span style="color:#4da8ee;">基础数据类型临时创建的对象 </span></p> 
<p><span style="color:#0d0016;">(1).哪些基本数据类型有/没有包装对象？</span></p> 
<p><span style="color:#4da8ee;">有：数字，字符串，布尔</span></p> 
<p><span style="color:#4da8ee;">没有：null,undefined</span></p> 
<p><span style="color:#0d0016;">(2).包装对象和基本数据类型的转换，举例子：</span></p> 
<pre><code>// 基本数据类型转换为包装对象
var v1 = new Number(123);
var v2 = new String('abc');
var v3 = new Boolean(true);

typeof v1 // "object"
typeof v2 // "object"
typeof v3 // "object"

// 包装对象转换为基本数据类型
new Number(123).valueOf()  // 123
new String('abc').valueOf() // "abc"
new Boolean(true).valueOf() // true
v1.toString(); // '123'
v1+ ''; // '123'
</code></pre> 
<p>（4)包装对象的应用场景及优缺点</p> 
<p></p> 
<blockquote> 
 <p>为什么null,undefined不能创建成包装对象（不用看）</p> 
</blockquote> 
<p>在 JavaScript 中，null 和 undefined 是特殊的值，而不是对象。它们是原始类型，在内部被硬编码为特定的值。因此，它们没有对应的构造函数，也就没有包装对象。在尝试访问它们的属性或方法时，会直接抛出 TypeError 错误。</p> 
<p>与之不同的是，JavaScript 中的其他原始类型，如字符串、数字和布尔值，都有对应的构造函数 String、Number 和 Boolean，用于创建它们的包装对象。这些包装对象与原始值之间可以进行相互转换，即可以将原始类型的值转换为包装对象，也可以将包装对象转换为原始类型的值。</p> 
<p>但是需要注意的是，虽然 JavaScript 中 null 和 undefined 没有包装对象，但是在严格模式下（'use strict'），对 null 和 undefined 进行隐式转换会抛出 TypeError 错误，这是为了防止代码不规范或出现潜在 Bug。因此，在使用 null 和 undefined 时需要特别注意它们的处理方式。</p> 
<blockquote> 
 <p><strong>3.引用数据类型有哪些?(高频)</strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">对象（Object）</span>：即 <code>{}</code> 组成的键值对集合。例如：<code>var obj = {name: 'Lucy', age: 18};</code>。</p> 
<p><span style="color:#4da8ee;">数组（Array）</span>：即 <code>[]</code> 组成的有序集合。例如：<code>var arr = [1, 2, 3];</code>。</p> 
<p><span style="color:#4da8ee;">函数（Function）</span>：即通过 <code>function</code> 关键字声明的函数。例如：<code>function sum(a, b) { return a + b; }</code>。</p> 
<p>日期（Date）：即 <code>new Date()</code> 创建的日期对象。例如：<code>var date = new Date();</code>。</p> 
<p>正则表达式（RegExp）：即 <code>new RegExp()</code> 创建的正则对象。例如：<code>var regexp = new RegExp('^abc$');</code>。</p> 
<p>Map 和 Set：即 <code>new Map()</code> 和 <code>new Set()</code> 创建的集合对象。例如：<code>let map = new Map(); map.set('name', 'Lucy');</code>。</p> 
<blockquote> 
 <p>4.说几条写JS的基本规范？ （不用看）</p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">不要在一行声明多个变量</span></li><li><span style="color:#4da8ee;">少用全局函数、变量</span></li><li><span style="color:#4da8ee;">switch语句必须带default分支</span></li><li><span style="color:#4da8ee;">用===/!==来比较true/false或数值</span></li></ul> 
<blockquote> 
 <p><strong>5.JS的typeof返回哪些数据类型(高频)</strong></p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">undefined</span></li><li><span style="color:#4da8ee;">string</span></li><li><span style="color:#4da8ee;">boolean</span></li><li><span style="color:#4da8ee;">number</span></li><li><span style="color:#4da8ee;">symbol(ES6)</span></li><li><span style="color:#4da8ee;">Object</span></li><li><span style="color:#4da8ee;">Function</span></li></ul> 
<blockquote> 
 <p><strong>6.强制类型转换(高频)</strong></p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">转成字符串:1.toString() 2.拼接字符串</span></li><li><span style="color:#4da8ee;">转成数字: parseInt(),parseFloat();Numbem()</span></li><li><span style="color:#4da8ee;">parseInt()   parseFloat()   专门用来对付字符串</span></li><li><span style="color:#4da8ee;">除了0、NaN、空串、null、undefined其余都是true。对象也会转换为true</span></li></ul> 
<pre><code>// toString()
var a=1;
console.log(a.toString());//输出结果为黑色的1

// 字符串拼接
var a=1;
var b=a+'';
console.log(b);//输出结果为黑色的1

// 使用Number
var a="123";
a=Number(a);
console.log(typeof  a);     结果：number

 如果:
var a="abc";
a=Number(a);
console.log(a);    结果：NaN

注意：如果是纯数字的字符串，则直接转换为数字，如果字符串中有非数字的内容，则转换为NaN,如果字符串是一个空串或者是一个全是空格的字符串，则转换为0；

Number(true)="1"     Number(Null)=0   Number(undefined)="NaN"

var a = "123px";
a=parseInt(a);
console.log(typeof a);    结果：number
console.log(a);               结果：123 
var b=true;
b=parseInt(b);
console.log(typeof b);    结果：number
console.log(b);               结果：NaN

// 如果对非string使用parseInt()或parseFloat()它会先将其转换为string，然后再操作。 转成boolean直接就用boolean;

使用Boolean()函数
var a= 123;
a=Boolean(a);
console.log(typeof a);   结果：boolean
console.log(a);              结果：true</code></pre> 
<p><a href="https://blog.csdn.net/qq_40471415/article/details/88837412" title="js强制类型转换_Baron的博客-CSDN博客_js 类型强转">js强制类型转换_Baron的博客-CSDN博客_js 类型强转</a></p> 
<p><a href="https://blog.csdn.net/qq_41999617/article/details/81174185" title="JS基础之强制类型转换_每文的博客-CSDN博客_js强制类型转换">JS基础之强制类型转换_每文的博客-CSDN博客_js强制类型转换</a></p> 
<blockquote> 
 <p><strong>7.隐式类型转换</strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">分为数据类型隐式类型转换 </span></p> 
<ol><li><span style="color:#4da8ee;">转换为boolean类型</span></li><li><span style="color:#4da8ee;">转换为number类型</span></li><li><span style="color:#4da8ee;">转换为string类型</span></li></ol> 
<pre><code>```
console.log(1+'2') //12 string
console.log(1-'2')//-1 number
console.log(10-'kkb') //NaN 
console.log(10-'10a') //NaN
console.log(10*'20') //200 number
console.log('10'*'20') //200 number
console.log(2/'1') //2 number
console.log('2'/'1') //2 number
console.log('2'/'kkb') //NaN

```</code></pre> 
<p><span style="color:#4da8ee;">== 也会进行隐式类型的转换</span></p> 
<pre><code>```
console.log(1+'2') //12 string
console.log(1-'2')//-1 number
console.log(10-'kkb') //NaN 
console.log(10-'10a') //NaN
console.log(10*'20') //200 number
console.log('10'*'20') //200 number
console.log(2/'1') //2 number
console.log('2'/'1') //2 number
console.log('2'/'kkb') //NaN
console.log(NaN==NaN) //false
console.log(undefined==null) //true
console.log(null==null) //true
console.log(null==undefined) //true
undefined == undefined //true

```</code></pre> 
<p><span style="color:#4da8ee;">扩展：通过==比较两边的值是否相等的结果？1==’1’；null==undefined</span></p> 
<p><span style="color:#4da8ee;">场景：if语句选择结构</span></p> 
<p><a href="https://blog.csdn.net/m0_57135756/article/details/124024502" title="【Js】JavaScript数据类型隐式转换_js隐式类型转换_快乐水续航的博客-CSDN博客">【Js】JavaScript数据类型隐式转换_js隐式类型转换_快乐水续航的博客-CSDN博客</a></p> 
<blockquote> 
 <p><strong>8.“=="和“===”区别(高频)</strong></p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">前者会自动转换类型，在判断是否相等</span></li><li><span style="color:#4da8ee;">后者不会自动转换类型，直接去比较</span></li></ul> 
<pre><code>1=="1"
null==undefined;//==true</code></pre> 
<blockquote> 
 <p>==为什么可以自动转换数据类型，===不可以 (不用说）</p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">==符号在判断左右两边数据是否相等时，如果数据类型一致，直接比较值即可</span></li><li><span style="color:#4da8ee;">===是直接比较值</span></li></ul> 
<blockquote> 
 <p><strong>8.逻辑运算符：与,或,非</strong></p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">|| : 只要其中有一个为true，整体结果是true； </span></li><li><span style="color:#4da8ee;">&amp;&amp; : 只要有一个是false，整体结果是false； </span></li><li><span style="color:#4da8ee;">!：取 （比较：转布尔，在取反）</span></li></ul> 
<blockquote> 
 <p><strong>9.null和undefined是否相等?null和undefined的区别？(高频)</strong></p> 
</blockquote> 
<pre><code>console.log(null==undefined)//true
console.log(null===undefined)//false</code></pre> 
<p>不同点： </p> 
<ul><li><span style="color:#4da8ee;"> null：没有定义的时候是null值，报错是not found，null表示"无",转成数值时为0</span></li><li><span style="color:#4da8ee;"> undefined：只是初始化，创建变量，但是没有赋值，undefined是一个表示"无"的原始值,转为数值时为NaN</span></li><li><span style="color:#4da8ee;">typeof null // 'object';typeof undefined // 'undefined'</span></li></ul> 
<p>相同点：</p> 
<p> <span style="color:#4da8ee;">       都是js的基本类型</span></p> 
<p><span style="color:#4da8ee;">        if语句中自动转为false</span></p> 
<p> <a href="https://blog.csdn.net/weixin_43932309/article/details/125772954" title="js：null与undefined的区别_js undefined和null的区别_枯藤黑鸦的博客-CSDN博客">js：null与undefined的区别_js undefined和null的区别_枯藤黑鸦的博客-CSDN博客</a></p> 
<blockquote> 
 <p><strong>10.JS四种检测(高频)</strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">typeOf原理：通过判断前三位的值来判断变量的数据类型</span></p> 
<ul><li>000：对象</li><li>010：浮点数</li><li>100：字符串</li><li>110：布尔</li><li>1：整数</li><li>null：所有机器码均为0</li><li>undefined：用 −2^30 整数来表示</li></ul> 
<p><span style="color:#4da8ee;">instanceof原理：通过原型链来判断一个对象是否为某个类的实例。通过判断object的__proto__属性指向的原型对象是否等于constructor的prototype属性指向的原型对象来实现的。</span></p> 
<p><span style="color:#4da8ee;">constructor原理：</span></p> 
<p><img alt="" height="765" src="https://images2.imgbox.com/24/91/rF12kURS_o.png" width="1200"></p> 
<p><span style="color:#4da8ee;">Object.prototype.toString.call([]) 原理：是返回一个表示对象类型的字符串，例如对于数组来说，返回的是<code>"[object Array]"</code>。这个方法的原理是调用<code>Object.prototype.toString</code>方法，并将需要检测类型的对象作为参数传递给它。因为该方法是原型链上的方法，所以可以直接使用。</span></p> 
<p><span style="color:#4da8ee;">Array.isArray</span></p> 
<pre><code>// typeOf：只能检测基本数据类型,不能区分判断 数组、null、对象
typeof 1;//'number'
typeof true;//'boolean'
typeof '';//'string'
typeof undefined;//'undefined'
typeof function (){};'function'
typeof null // Object

// instanceOf：检测当前实例是否属于某个类的方法 
A instanceof B：判断A是否为B的实例对象，从而判断A是否为B类型
var arr = [];
arr instanceof Array;//true
function Person(name, age) {
  this.name = name;
  this.age = age;
}

const john = new Person("John", 30);

console.log(john instanceof Person); // 输出 true



// constructor：检测属性是否存在于构造函数的原型上，用_proto_在原型上
var arr = [];
arr.constructor === Array;//true

// Object.prototype.toString.call([]); 最准确的方式；用来检测数据类型的
console.log(Object.prototype.toString.call(1));//[object Number]
console.log(Object.prototype.toString.call(''));//[object String]
console.log(Object.prototype.toString.call(true));//[object Boolean]
console.log(Object.prototype.toString.call(null));// [object Null]
console.log(Object.prototype.toString.call(undefined));//[object Undefined]
console.log(Object.prototype.toString.call([]));// [object Array]

Array.isArray() 用于确定传递的值是否是一个 Array。
Array.isArray([1, 2, 3]);  
// true
Array.isArray({foo: 123}); 
// false
Array.isArray("foobar");   
// false
Array.isArray(undefined);  
// false</code></pre> 
<blockquote> 
 <p><strong> js 判断类型的几种方法及其优缺点</strong></p> 
</blockquote> 
<p><a href="https://blog.csdn.net/weixin_43989656/article/details/129665179" title="js 判断类型的几种方法及其优缺点_js判断数据类型的方法及优缺点_Ji'an的博客-CSDN博客">js 判断类型的几种方法及其优缺点_js判断数据类型的方法及优缺点_Ji'an的博客-CSDN博客</a></p> 
<blockquote> 
 <p><strong>11.看下列代码,输出什么？解释原因。</strong> </p> 
</blockquote> 
<pre><code>var a = null;
alert(typeof a); //object</code></pre> 
<p>原理，<span style="color:#4da8ee;">js中二进制前三位都为 0 的话会被判断为 object 类型， null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“ object ”。 </span></p> 
<blockquote> 
 <p><strong>12.看下列代码,输出什么？解释原因。</strong></p> 
</blockquote> 
<pre><code>var undefined;//此时undefined这个变量的值是undefined
undefined == null; // true
1 == true;   // true
此时会把布尔类型的值转换为数字类型 true=1 false=0
2 == true;   // false
0 == false;  // true
0 == '';     // true
NaN == NaN;  // false isNaN
[] == false; // true   解释：会把[]和false都通过Number()转换为数字类型
[] == ![];   // true   解释：![]：false
[]==[];//false</code></pre> 
<blockquote> 
 <p>13.判断空字符串,undefiend,null(不用考）</p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">if(undefined == null){    }        //返回的是true</span></li><li><span style="color:#4da8ee;">if(undefined == ' '){}                // 返回的是false</span></li><li><span style="color:#4da8ee;">if(null == ' '){}                       // 返回的是false</span></li></ul> 
<p><strong>控制台</strong></p> 
<ul><li><span style="color:#4da8ee;">' '为字符串</span></li><li><span style="color:#4da8ee;">typeof null ==================&gt; Object</span></li><li><span style="color:#4da8ee;">typeof ' ' ====================&gt; String</span></li></ul> 
<blockquote> 
 <p><strong>14.undefiend和null字符在if语句找那个,都会自动变成false =============&gt;让他们变成true,前面要加!(取反)</strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;"> if(!null) == if(!undefined)  == true</span></p> 
<blockquote> 
 <p><strong>15.Array,Object放在if语句中自动转成true(高频)</strong></p> 
</blockquote> 
<p>为什么？</p> 
<p><span style="color:#4da8ee;">数据类型实现自动转换 </span></p> 
<blockquote> 
 <p><strong>16.break，continue, return区别(高频)</strong></p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">break:立即结束语句，并跳出语句；主要用于循环和switch</span></li><li><span style="color:#4da8ee;">continue:停止当前语句，并继续执行；continue只能用于循环</span></li><li><span style="color:#4da8ee;">return:停止函数</span></li></ul> 
<pre><code>// break
for(var i = 0;i &lt;= 10; i++){
    if(i == 6){
        break;
    }
    console.log(i);  //12345
}

// continue
for(var i = 0;i &lt;= 10; i++){
    if(i == 6){
        continue;
    }
    console.log(i);  //1234578910
}</code></pre> 
<blockquote> 
 <p><strong>17.for…in..和for…of..的区别？-----（需要完善）</strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">for...in用于遍历数组或者对象的属性；；；；for...of遍历循环数组</span></p> 
<p><span style="color:#4da8ee;"><code>for(变量 in 对象){<!-- --></code> 在此执行代码 }</span></p> 
<ul><li><span style="color:#4da8ee;">for...of遍历获取的是对象的键值, for...in获取的是对象的键名;</span></li><li><span style="color:#4da8ee;">for...in会遍历对象的整个原型链, 性能非常差不推荐使用,而for...of只遍历当前对象不会遍历原型链;</span></li><li><span style="color:#4da8ee;">对于数组的遍历,for...in会返回数组中所有可枚举的属性(包括原型链上可枚举的属性),for...of只返回数组的下标对应的属性值;</span></li></ul> 
<p>总结：<span style="color:#4da8ee;">for...in循环主要是为了遍历对象而生,不适用遍历数组; for....of循环可以用来遍历数组、类数组对象、字符串、Set、Map以及Generator对象</span></p> 
<pre><code>// for ... in
let arr = [1, 2, 3, 4, 5]
Array.prototype.id = 123
arr.name = 'Jessica'
for (let index in arr) {
	console.log(index, arr[index]);//遍历[1,2,3,4,5,Jessica,123]
}


// for ... of 
let arr = [1, 2, 3, 4, 5]
Array.prototype.id = 321
arr.name = 'Mars'
for (let value of arr) {
	console.log(value);//只能拿到[1,2,3,4,5]
}</code></pre> 
<blockquote> 
 <p><strong>18.map，forEach区别(高频)</strong></p> 
</blockquote> 
<p>相同点：</p> 
<ul><li><span style="color:#4da8ee;">都是循环遍历数组中的每一项</span></li><li><span style="color:#4da8ee;">每次执行匿名函数，都支持3个参数，参数分别是item（当前每一项），index（索引值），arr（原数组）</span></li><li><span style="color:#4da8ee;">只能遍历数组</span></li><li><span style="color:#4da8ee;">匿名函数中this都指向window </span></li></ul> 
<p>不同点：<span style="color:#4da8ee;">map有返回值,不会改变原数组;forEach没有返回值,对原数组数据直接进行修改</span></p> 
<p><span style="color:#4da8ee;">map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值（map进行处理之后返回一个新的数组）</span></p> 
<p><span style="color:#4da8ee;">map方法不会改变原始数组</span></p> 
<pre><code>var arr = [0,2,4,6,8];
var str = arr.map(function(item,index,arr){
console.log(this); //Window
console.log(this);
console.log(item);
console.log('原数组arr：',arr); // 会执行五次
return item/2;},this);console.log(str); //[0,1,2,3,4]</code></pre> 
<p><span style="color:#4da8ee;">forEach方法用于调用数组的每个元素，将元素传给回调函数</span></p> 
<p><span style="color:#4da8ee;">注意，forEach是不会返回有意义的值的。我们在回调函数中直接修改arr的值。</span></p> 
<pre><code>arr.forEach((value, key) =&gt; {
 return arr[key] = value * value;
});</code></pre> 
<blockquote> 
 <p><strong>数组怎么实现map </strong></p> 
</blockquote> 
<pre><code>// 自定义map函数实现
Array.prototype.myMap = function(callback){
  const newArray = [];
  for(let i = 0; i &lt; this.length; i++){
    newArray.push(callback(this[i], i, this));
  }
  return newArray;
};

// 示例：将数组中的每个元素乘以二
const arr = [1, 2, 3, 4];
const newArr = arr.myMap(item =&gt; item * 2);
console.log(newArr); // [2, 4, 6, 8]</code></pre> 
<p> 在上面的示例中，我们通过在 <code>Array</code> 原型对象上定义一个 <code>myMap</code> 函数来实现数组的map方法。该函数接收一个回调函数作为参数，然后在遍历数组的过程中，对每个元素进行回调操作并将结果存入新的数组中，最后将新的数组返回。</p> 
<p>需要注意的是，回调函数一共可以接收三个参数：当前元素，当前元素的索引，以及原数组本身。这三个参数虽然都可以使用，但是只有第一个参数是必选的，因为它表示要操作的当前元素。另外，map方法不会改变原有的数组，而是返回一个新的数组。</p> 
<blockquote> 
 <p><strong>map和weakMap的区别 </strong></p> 
</blockquote> 
<p> <a href="https://juejin.cn/post/6940945178899251230" rel="nofollow" title="「2021」高频前端面试题汇总之JavaScript篇（上） - 掘金">「2021」高频前端面试题汇总之JavaScript篇（上） - 掘金</a></p> 
<blockquote> 
 <p><strong>19.循环(while,do...while,for,for...in，for...of,continue,break,label)</strong></p> 
</blockquote> 
<pre><code>// while 先判断---------&gt;后执行
var i = 0;
while(i &lt; 100){
console.log('i为' + i)
}

// do......while 先执行-------------&gt;再判断
var x = 3;
var i = 1;
do {
console.log(i);
i++;
} while (i &lt; x)

// for循环
// for...in    ----&gt;用于对象遍历
var person = {name: "张”}
for(var key in person){
if(person.hasownproperty){
}
}

//  for...of：语句在可迭代对象（包括Array,Map,Set,argument等）上创建了一个循环
let arr = [3, 5, 7];
arr.foo = "hello";

for (let i in arr) {
   console.log(i); // 输出 "0", "1", "2", "foo"
}

for (let i of arr) {
   console.log(i); // 输出 "3", "5", "7"
}</code></pre> 
<blockquote> 
 <strong>20.Number的方法</strong> 
</blockquote> 
<ul><li><span style="color:#4da8ee;"><code>isNaN</code> : 检查数字是否非法    // console.log(isNaN(123))   // false</span></li><li><span style="color:#4da8ee;"><code>Number</code> :将其他数据类型的值强制转换成number类型； </span></li><li><span style="color:#4da8ee;"><code>parseInt</code> :经常用于字符串提取数字的方法； </span></li><li><span style="color:#4da8ee;"><code>parseFloat</code>:和parseInt 用法一样；区别是多识别一位小数点 </span></li><li><span style="color:#4da8ee;"><code>toFixed</code> : 保留小数点位数的方法;返回值是一个字符串；</span></li></ul> 
<blockquote> 
 <p><strong>21.字符串的方法(13个)</strong></p> 
</blockquote> 
<ol><li><span style="color:#4da8ee;"><code>toUpperCase</code> : 把小写字母转成大写 </span></li><li><span style="color:#4da8ee;"><code>toLowerCase</code> 把大写转小写 </span></li><li><code>charAt</code> : 通过索引获取字符 </li><li><code>charCodeAt</code> : 通过索引获取对应字符的Unicode编码； </li><li><span style="color:#4da8ee;"><code>substr</code> : 截取 substr(m,n) 从索引m开始，截取n个字符； </span></li><li><span style="color:#4da8ee;"><code>substring</code>: substring(m,n) ：从索引m开始，截取到索引n，不包含n; (不支持负数) </span></li><li><span style="color:#4da8ee;"><code>slice(m,n)</code>: substring; 从索引m开始，截取到索引n，不包含n (支持负数) </span></li><li><code>indexOf</code> : 检测字符在字符串中第一次出现的索引位置； </li><li><code>lastIndexOf</code> : 检测字符在字符串中最后一次出现的索引位置； </li><li><span style="color:#4da8ee;"><code>split</code>: 把字符串按照特定的字符分隔数组中的每一项； </span></li><li><span style="color:#4da8ee;"><code>replace</code>:替换;原有字符串不变；用新字符替换旧的字符 </span></li><li><span style="color:#4da8ee;"><code>concat</code> : 拼接 </span></li></ol> 
<blockquote> 
 <p><strong>22.字符串的运算</strong></p> 
</blockquote> 
<p><code>-<span style="color:#4da8ee;"> * /</span></code><span style="color:#4da8ee;">: 会先把字符串转换成数字，然后再进行计算</span></p> 
<blockquote> 
 <p>23.DOM四种类型的节点 </p> 
</blockquote> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>TYPE</td><td>nodeType</td><td>nodeName</td><td>nodeValue</td></tr><tr><td>元素节点</td><td>1</td><td>大写的标签名</td><td>null</td></tr><tr><td>文本节点</td><td>3</td><td>text</td><td>文本内容</td></tr><tr><td>注释节点</td><td>8</td><td>comment</td><td>注释内容</td></tr><tr><td>document</td><td>9</td><td>document</td><td>null</td></tr></tbody></table> 
<p>空格和换行都是文本节点；</p> 
<blockquote> 
 <p><strong>24.DOM节点的属性（</strong>DOM操作的常用API<strong>）</strong></p> 
</blockquote> 
<p><a href="https://blog.csdn.net/weixin_43613849/article/details/121560210" title="DOM操作的常用API_Doe的博客-CSDN博客_操作dom的常用api">DOM操作的常用API_Doe的博客-CSDN博客_操作dom的常用api</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6b/56/s2p3tZl0_o.png">  </p> 
<p>节点查找API</p> 
<pre><code>1.document.getElementById ：根据ID查找元素，大小写敏感，如果有多个结果，只返回第一个；
2.document.getElementByClassName:根据类名查找，多个类名用空格分隔，返回一个 HTMLCollection。
3.document.getElementsByTagName:根据标签查找元素， * 表示查询所有标签，返回一个 HTMLCollection.
4.document.getElementsByName ：根据元素的name属性查找，返回一个 NodeList 。
5.document.querySelector ：返回单个Node，如果匹配到多个结果，只返回第一个。
6.document.querySelectorAll ：返回一个 NodeList
7.document.forms ：获取当前页面所有form，返回一个 HTMLCollection</code></pre> 
<p> 节点创建API</p> 
<ol><li><span style="color:#4da8ee;"><code>document.getElementById</code>:通过ID名来获取元素 </span></li><li><span style="color:#4da8ee;"><code>document.getElementsByTagName</code>: 通过标签名来获取元素 </span></li><li><span style="color:#4da8ee;"><code>document.getElementsByClassName()</code>; 类数组集合； </span></li><li><span style="color:#4da8ee;"><code>document.getElementsByName</code>;通过name属性来获取元素； </span></li><li><span style="color:#4da8ee;"><code>document.documentElement</code> 获取当前的html </span></li><li>body :获取页面的body元素； </li><li><span style="color:#4da8ee;"><code>document.querySelector()</code>;如果是id名加#，如果是class名加. </span></li><li><span style="color:#4da8ee;"><code>document.querySelectorAll()</code>;获取所有的元素</span></li><li><span style="color:#4da8ee;">createDocumentFragment() // 创建一个DOM片段</span></li><li><span style="color:#4da8ee;">createElement() // 创建一个具体的元素</span></li><li><span style="color:#4da8ee;">createTextNode() // 创建一个文本节点</span></li><li><span style="color:#4da8ee;">appendChild(node)</span></li><li><span style="color:#4da8ee;">removeChild(node)</span></li><li><span style="color:#4da8ee;">replaceChild(new,old)</span></li><li><span style="color:#4da8ee;">insertBefore(new,old) // 在已有的子节点前插入一个新的子节点</span></li><li><span style="color:#4da8ee;">getElementsByTagName() // 通过标签名称</span></li><li><span style="color:#4da8ee;">getElementsByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</span></li><li><span style="color:#4da8ee;">getElementById() // 通过元素Id，唯一性</span></li><li><span style="color:#4da8ee;"><code>childNodes</code> : 获取当前元素所有的子节点； </span></li><li><span style="color:#4da8ee;"><code>children</code> : 获取当前元素的子元素节点； </span></li><li><span style="color:#4da8ee;"><code>firstChild</code> : 获取第一子节点； </span></li><li><span style="color:#4da8ee;"><code>lastChild</code> :获取最后一个子节点 </span></li><li><code>previousSibling</code> : 获取上一个哥哥节点 </li><li><code>nextSibling</code> : 获取下一个弟弟节点 </li><li><code>parentNode</code>: 获取当前元素的父亲节点；</li><li>instanceof</li><li>isArray</li><li>concat():拼接字符串</li><li>slice():对字符串进行分割</li><li>split():把字符串分割成字符串数组 </li><li>toLowerCase():把字符串转换为小写</li><li>toUpperCase():把字符串转换为大写</li><li>charAt():返回指定字符的位置</li><li>indexOf():检索字符串</li><li>replace:替换与正则表达式匹配的字符串</li></ol> 
<blockquote> 
 <p><strong>25.已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？(不使用第三方框架)</strong></p> 
</blockquote> 
<pre><code>document.getElementById("ID").value
</code></pre> 
<blockquote> 
 <p><strong>26.怎么检测数组？</strong></p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">Array.isArray()</span></li><li><span style="color:#4da8ee;"><code>instanceof</code>运算符或原型链检测方法来判断一个对象是否为数组</span></li><li><span style="color:#4da8ee;">Object.prototype.toString.call(arr)</span></li></ul> 
<pre><code>// Array.isArray
let arr = [1, 2, 3];

if (Array.isArray(arr)) {
    console.log('arr是数组');
} else {
    console.log('arr不是数组');
}

// instanceof
let arr = [1, 2, 3];

if (arr instanceof Array) {
    console.log('arr是数组');
} else {
    console.log('arr不是数组');
}

// 原型链方法
if (Object.prototype.toString.call(arr) === '[object Array]') {
    console.log('arr是数组');
} else {
    console.log('arr不是数组');
}</code></pre> 
<blockquote> 
 <p><strong>27.改变数组长度的方法有哪些？</strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">shift、unshift、pop、push</span> </p> 
<blockquote> 
 <p><strong>28.数组的方法(高频)(数组能够调用的函数有哪些？ </strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">在js中，数组是一组按照顺序排列的值的集合。数组可以包含任意类型，可以是数字，字符串，对象。数组可以通过索引访问，数组有很多方法</span></p> 
<p><span style="color:#4da8ee;">length():返回数组的长度</span></p> 
<p><span style="color:#4da8ee;">push()尾部添加，返回数组长度(向数组末尾新增一项；可以传多个)</span></p> 
<pre><code>var arr = ["Lily","lucy","Tom"];
var count = arr.push("Jack","Sean");
console.log(count); // 5
console.log(arr); // ["Lily", "lucy", "Tom", "Jack", "Sean"]</code></pre> 
<p><span style="color:#4da8ee;">pop()尾部删除，返回被删除的元素（删除数组的最后一项；不需要传参数；）</span></p> 
<pre><code>var item = arr.pop();
console.log(item); // Sean
console.log(arr); // ["Lily", "lucy", "Tom", "Jack"]</code></pre> 
<p><span style="color:#4da8ee;">unshift()头部添加 ，返回数组长度</span></p> 
<pre><code>var arr = ["Lily","lucy","Tom"];
var count = arr.unshift("Jack","Sean");
console.log(count); // 5
console.log(arr); //["Jack", "Sean", "Lily", "lucy", "Tom"]</code></pre> 
<p><span style="color:#4da8ee;">shift()头部删除，返回被删除的元素</span></p> 
<pre><code>var item = arr.shift();
console.log(item); // Jack
console.log(arr); // ["Sean", "Lily", "lucy", "Tom"]</code></pre> 
<p><span style="color:#4da8ee;">reverse():反转数组项的顺序</span></p> 
<pre><code>var arr = [13, 24, 51, 3];
console.log(arr.reverse()); //[3, 51, 24, 13]
console.log(arr); //[3, 51, 24, 13](原数组改变)
</code></pre> 
<p><span style="color:#4da8ee;">concat()：数组的拼接 。构建成一个新的数组,原数组并未改变.</span></p> 
<pre><code>var arr = [1,3,5,7];
var arrCopy = arr.concat(9,[11,13]);
console.log(arrCopy); //[1, 3, 5, 7, 9, 11, 13]
console.log(arr); // [1, 3, 5, 7](原数组未被修改)
</code></pre> 
<p><span style="color:#4da8ee;">slice(m,n): 数组的截取 ,从数组索引m开始，截取到索引n，但是不包含n;[前包后不包] ,原有数组不发生改变<br> slice(m) : 从索引m开始，截取到末尾； </span></p> 
<p><span style="color:#4da8ee;">slice()方法可以接受一或两个参数</span></p> 
<pre><code>var arr = [1,3,5,7,9,11];
var arrCopy = arr.slice(1);
var arrCopy2 = arr.slice(1,4);
var arrCopy3 = arr.slice(1,-2);
var arrCopy4 = arr.slice(-4,-1);
console.log(arr); //[1, 3, 5, 7, 9, 11](原数组没变)
console.log(arrCopy); //[3, 5, 7, 9, 11]
console.log(arrCopy2); //[3, 5, 7]
console.log(arrCopy3); //[3, 5, 7]
console.log(arrCopy4); //[5, 7, 9]
</code></pre> 
<p>indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。<br> lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。<br> 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。</p> 
<pre><code>var arr = [1,3,5,7,7,5,3,1];
console.log(arr.indexOf(5)); //2
console.log(arr.lastIndexOf(5)); //5
console.log(arr.indexOf(5,2)); //2
console.log(arr.lastIndexOf(5,4)); //2
console.log(arr.indexOf("5")); //-1
</code></pre> 
<p><span style="color:#4da8ee;"> forEach()对数组进行遍历循环，</span>对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。</p> 
<pre><code>var arr = [1, 2, 3, 4, 5];
arr.forEach(function(x, index, a){
console.log(x + '|' + index + '|' + (a === arr));
});
// 输出为：
// 1|0|true
// 2|1|true
// 3|2|true
// 4|3|true
// 5|4|true
</code></pre> 
<p>map()指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。(有返回值)</p> 
<pre><code>var arr = [1, 2, 3, 4, 5];
var arr2 = arr.map(function(item){
return item*item;
});
console.log(arr2); //[1, 4, 9, 16, 25]
</code></pre> 
<p><span style="color:#4da8ee;">splice(m,n): 删除数组中的某几项 .从索引开始，删除n个 <br> splice(m) : 从索引m开始删除到末尾； <br> splice(0): <br> splice(m,x,n);替换从索引m开始，删除x个，用n替换； </span><br> 原有数组发生改变 </p> 
<pre><code>var fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.splice(2,0,"Lemon","Kiwi");

// Banana,Orange,Lemon,Kiwi,Apple,Mango</code></pre> 
<p><span style="color:#4da8ee;">slice():方法以新的数组对象，返回数组中被选中的元素，不会改变原数组，方法选择从给定的 <em>start</em> 参数开始的元素，并在给定的 <em>end</em> 参数处结束，但不包括。</span></p> 
<pre><code>var fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
var citrus = fruits.slice(1, 3);</code></pre> 
<p><span style="color:#4da8ee;"> sort()：</span>按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。</p> 
<p>在排序时，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， sort()方法比较的也是字符串，因此会出现以下的这种情况：</p> 
<pre><code>var arr1 = ["a", "d", "c", "b"];
console.log(arr1.sort()); // ["a", "b", "c", "d"]
arr2 = [13, 24, 51, 3];
console.log(arr2.sort()); // [13, 24, 3, 51]
console.log(arr2); // [13, 24, 3, 51](元数组被改变)
</code></pre> 
<p>为了解决上述问题，sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数：</p> 
<pre><code>function compare(value1, value2) {
if (value1 &lt; value2) {
return -1;
} else if (value1 &gt; value2) {
return 1;
} else {
return 0;
}
}
arr2 = [13, 24, 51, 3];
console.log(arr2.sort(compare)); // [3, 13, 24, 51]
</code></pre> 
<p>如果需要通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可：</p> 
<pre><code>function compare(value1, value2) {
if (value1 &lt; value2) {
return 1;
} else if (value1 &gt; value2) {
return -1;
} else {
return 0;
}
}
arr2 = [13, 24, 51, 3];
console.log(arr2.sort(compare)); // [51, 24, 13, 3]
</code></pre> 
<p><span style="color:#4da8ee;">filter()过滤”功能，</span>数组中的每一项运行给定函数，返回满足过滤条件组成的数组。</p> 
<pre><code>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var arr2 = arr.filter(function(x, index) {
return index % 3 === 0 || x &gt;= 8;
}); 
console.log(arr2); //[1, 4, 7, 8, 9, 10]
</code></pre> 
<p><span style="color:#4da8ee;">every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。</span></p> 
<pre><code>var arr = [1, 2, 3, 4, 5];
var arr2 = arr.every(function(x) {
return x &lt; 10;
}); 
console.log(arr2); //true
var arr3 = arr.every(function(x) {
return x &lt; 3;
}); 
console.log(arr3); // false
</code></pre> 
<p><span style="color:#4da8ee;">some()</span></p> 
<pre><code>var arr = [1, 2, 3, 4, 5];
var arr2 = arr.some(function(x) {
return x &lt; 3;
}); 
console.log(arr2); //true
var arr3 = arr.some(function(x) {
return x &lt; 1;
}); 
console.log(arr3); // false
</code></pre> 
<blockquote> 
 <p><strong>indexOf实现 </strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;"><code>indexOf()</code>方法返回数组中指定元素的第一个匹配项的索引。如果未找到该元素，则返回-1。 </span></p> 
<pre><code>Array.prototype.myIndexOf = function(item) {
  for (let i = 0; i &lt; this.length; i++) {
    if (this[i] === item) {
      return i;
    }
  }
  return -1;
};</code></pre> 
<blockquote> 
 <p><strong>数组排序 </strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">sort方法</span></p> 
<pre><code>const a = [{age:51},{age:23},{age:53},{age:12}]

// 答案
function sort(arr){
    return arr.sort(({age:a},{age,b}) =&gt; a - b);
}</code></pre> 
<blockquote> 
 <p><strong>29.对象的方法？ （高频）</strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">js中，对象是一组无序的键值对，可以通过方法来操作这些键值对</span>。常见方法有</p> 
<pre><code>// Object.keys():该方法返回一个对象的所有key值组成的数组
const obj = {a: 1, b: 2, c: 3};
const keys = Object.keys(obj);
console.log(keys); // ['a', 'b', 'c']

// Object.values():改方法返回一个对象所有的value值组成的数组
const obj = {a: 1, b: 2, c: 3};
const values = Object.values(obj);
console.log(values); // [1, 2, 3]

// Object.entries():该方法返回由一个对象的所有键值对组成的数组
const obj = {a: 1, b: 2, c: 3};
const entries = Object.entries(obj);
console.log(entries); // [['a', 1], ['b', 2], ['c', 3]]

// Object.assign()：用于浅拷贝，返回目标对象
const obj1 = {a: 1};
const obj2 = {b: 2};
const mergedObj = Object.assign(obj1, obj2);
console.log(mergedObj); // {a: 1, b: 2}

// Object.hasOwnProperty():检查对象是否具有指定属性（不包括原型链上的属性）
const obj = {a: 1, b: 2, c: 3};
console.log(obj.hasOwnProperty('a')); // true
console.log(obj.hasOwnProperty('toString')); // false

// Object.freeze():该方法将对象冻结，即防止对象被修改（属性值不能被修改、添加、删除），并返回被冻结的对象。
const obj = {a: 1, b: 2, c: 3};
Object.freeze(obj);
obj.a = 4; // 不生效
console.log(obj); // {a: 1, b: 2, c: 3}
</code></pre> 
<p><a href="https://blog.csdn.net/csdssdn/article/details/124204439" title="JS对象中常见的方法_要不要买菜啊的博客-CSDN博客_js对象常用方法">JS对象中常见的方法_要不要买菜啊的博客-CSDN博客_js对象常用方法</a></p> 
<blockquote> 
 <p><strong>30.数组去重(高频)</strong></p> 
</blockquote> 
<pre><code>// new Set
let arr1 = [1, 2, 3, 1, 2, 3, '1', '1'];
let newArr1 = [...new Set(arr1)];
console.log(newArr1);

let A = [1,2,3]
let B = [2,3,4]
let union = [...new Set([...a,...b])

// 双for循环：双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。
var arr = [1,2,3,4,5,6,54,5,67]
function unique(arr){
for(let i = 0; i&lt; arr.length;i++){
for(let j = i + 1; j&lt; arr.length;j++){
if(arr[i] == arr[j]){
  arr.splice(j,i)    // 第一个等同于第二个，splice方法删除第二个
}
}
}
return arr;
}

// 利用indexOf去重
思路：新建一个空数组，for循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。
function unique(arr){
    if(!Array.isArray(arr){
        console.log('type error');
        return;
    }   
    var array = [];
    for(var i = 0; i &lt; arr.length;i++){
        if(array.indexOf(arr[i]) === -1){
            array.push(arr[i]);
        }
    } 
    return array;
}

var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
 // [1, "true", true, 15, false, undefined, null, NaN, NaN, "NaN", 0, "a", {…}, {…}]  //NaN、{}没有去重</code></pre> 
<p><a href="https://segmentfault.com/a/1190000016418021?utm_source=tag-newest" rel="nofollow" title="https://segmentfault.com/a/1190000016418021?utm_source=tag-newest">https://segmentfault.com/a/1190000016418021?utm_source=tag-newest</a></p> 
<blockquote> 
 <p><strong>31.split() join() 的区别(高频)</strong></p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">split():把一个字符串分割成字符串数组，并返回。例如:“hello".split("")   // ["h", "e", "l", "l", "o"]</span></li><li><span style="color:#4da8ee;">join():把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的,并返回</span></li></ul> 
<pre><code>在本例中，我们将创建一个数组，然后把它的所有元素放入一个字符串：

&lt;script type="text/javascript"&gt;
var arr = new Array(3)
arr[0] = "George"
arr[1] = "John"
arr[2] = "Thomas"
console.log(arr.join())
&lt;/script&gt;
输出：George,John,Thomas</code></pre> 
<blockquote> 
 <p><strong>32.js精度误差</strong></p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">toFixed()方法,使用不同函数分别计算(+,-,*,/)</span></li></ul> 
<pre><code>var a = 1;
var b = 2.344544;
consoel.log((a+b).toFixed(2))
</code></pre> 
<ul><li><span style="color:#4da8ee;">小数点[(变量 * 10) / 10])  先乘10再除以10</span></li></ul> 
<blockquote> 
 <p><strong>33. 什么是数组？什么是对象？</strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">数组是带索引值的，对象是键值对</span></p> 
<pre><code>let arr = [1,2,3]
arr.forEach(item,index =&gt;{console.log(index)})

let obj = {
     name:'ss'
}
console.log(obj)</code></pre> 
<blockquote> 
 <p><strong>34.伪数组 </strong></p> 
</blockquote> 
<p>定义：<span style="color:#4da8ee;">是个对象，拥有length属性且属性值必须是number类型，其他属性(索引)为非负整数；不具有数组所具有的push,pop，forEach等方法;伪数组长度不可变，真数组的长度是动态可变的</span></p> 
<pre><code>// 真数组
var obj = {}
var obj = {length:3}

// 伪数组
var obj = {0: '12', length: 1}
var obj = {99: 'abc',length: 100}</code></pre> 
<blockquote> 
 <p><strong>35.说一下怎么把类数组转换为数组? </strong></p> 
</blockquote> 
<p>说后2个即可 </p> 
<pre><code>// 通过call调用数组的slice方法来实现转换
Array.prototype.slice.call(arrayLike)

// 通过call调用数组的splice方法来实现转换
Array.prototype.splice.call(arrayLike,0)

//通过apply调用数组的concat方法来实现转换
Array.prototype.concat.apply([],arrayLike)

//通过Array.from方法来实现转换
Array.from(arrayLike)</code></pre> 
<blockquote> 
 <p><strong>36.Array.from()</strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">将一个类数组对象（伪数组）或者可遍历对象转成一个真正的数组，es6新增的</span></p> 
<p><span style="color:#4da8ee;">new map和new set的使用场景</span></p> 
<pre><code>// 伪数组：拥有一个length属性和若干索引的任意对象
可迭代对象：可以获取对象中元素，如Map和Set等

Array.from('foo')  // ['f','o','o']

const set = new Set(['foo','bar','baz','foo'])
Array.from(set) // ['foo','bar','baz']

const map = new Map([[1,2],[2,4],[4,8]])
Array.from(map) // [[1,2],[2,4],[4,8]]

Array.from([1, 2, 3], x =&gt; x + x); //[2,4,6]</code></pre> 
<blockquote> 
 <p><strong>37.Object.create() 实现基本原理</strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">以一个已有的对象为原型(prototype)创建并返回一个新对象 </span></p> 
<pre><code>const obj = {
  a: 1,
  b: 2
};

const obj2 = Object.create(obj, {
  c: {
    value: 3,
    writable: true,
    enumerable: true,
    configurable: true
  }
});

console.log(obj2.a); // 1
console.log(obj2.b); // 2
console.log(obj2.c); // 3
</code></pre> 
<p></p> 
<blockquote> 
 <p><strong>38.说一下怎么取出数组最多的一项？ </strong></p> 
</blockquote> 
<p><a href="https://blog.csdn.net/weixin_34074740/article/details/91472999" title="js找出数组中出现最多的元素和次数_weixin_34074740的博客-CSDN博客">js找出数组中出现最多的元素和次数_weixin_34074740的博客-CSDN博客</a></p> 
<blockquote> 
 <p>39.检测浏览器版本版本有哪些方式？ （不用考）</p> 
</blockquote> 
<p><span style="color:#4da8ee;">根据 navigator.userAgent // UA.toLowerCase().indexOf('chrome')</span></p> 
<blockquote> 
 <p><strong>40.如果实现一个超链接下载功能</strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;"> 添加download属性</span></p> 
<pre><code>&lt;a href="url" download="filename"&gt;下载&lt;/a&gt;</code></pre> 
<p><span style="color:#4da8ee;">实现思路</span></p> 
<pre><code>// createElement创建节点a
// 插入节点a
// 给a节点设置href属性
// 调用click点击事件
&lt;script&gt;
  var a=document.createElement("a");
   document.body.appendChild(a);
   a.setAttribute('href','openlayerexample.zip');   
   a.click();
&lt;/script&gt;</code></pre> 
<p><strong>// 如何实现上传图片功能</strong></p> 
<pre><code>&lt;div id="pic"&gt;
    图片:&lt;div id="headPic"&gt;&lt;img src="../../imgs/def.jpg" &gt;&lt;/div&gt;
    &lt;input type="file" id="fil"&gt;
&lt;/div&gt;

// js代码
     let fil = document.querySelector('#fil') // 文件框，只不过隐藏了起来
     let headPic = document.querySelector('#headPic') //图片上传框

	 headPic.addEventListener('click', function () {
        fil.click()  //点击上传图片，文件上传框打开
    })

    //头像上传
    fil.addEventListener('change', function (e) {//注意，头像上传时用的时change事件
        // console.log(this.files[0]);  //文件的信息都放在files里 
        let fd = new FormData()
        fd.append('imgurl', this.files[0])
        //原生ajax实现实现图片上传
        let xhr = new XMLHttpRequest() //创建ajax对象
        xhr.open('post', 'http://139.9.177.51:5000' + '/book/upload')
        xhr.send(fd)  //将格式处理好的数据，作为参数发送
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
                let data = JSON.parse(xhr.responseText);
                console.log(data);

                img.src = 'http://139.9.177.51:5000' + data.imgurl
            }
        }
    })
</code></pre> 
<blockquote> 
 <p> <strong>41.说一下innerHTML 与 innerText的作用与区别？</strong> </p> 
</blockquote> 
<ul><li>作用：<span style="color:#4da8ee;">都可以获取或者设置元素的内容</span></li><li>区别：<span style="color:#4da8ee;">innerHTML可以解析内容中的html标签</span></li><li><span style="color:#4da8ee;">innerText不能解析内容中的html标签</span></li></ul> 
<blockquote> 
 <p>42.JavaScript 由以下三部分组成：（不用考）</p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">ECMAScript（语法部分）：JS语言基础</span></li><li><span style="color:#4da8ee;">DOM（文档对象模型）：规定了访问 HTML 和 XML 的方法</span></li><li><span style="color:#4da8ee;">BOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法</span></li></ul> 
<blockquote> 
 <p>43.什么是标识符？（不用考）</p> 
</blockquote> 
<p><span style="color:#4da8ee;">在JS中，可以自定义命名的东西都属性标识符；比如变量名，函数名，参数名都是标识符</span></p> 
<blockquote> 
 <p>44.DOM 元素e的 e.getAttribute(propName)和 e.propName 有什么区别和联系（不用考）</p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">e.getAttribute：获取的是标签上属性</span>;<span style="color:#4da8ee;">可以通过e.setAttribute(propName, propValue)设置标签上属性</span></li><li><span style="color:#4da8ee;">e.propName：获取的是元素对象上属性</span></li></ul> 
<pre><code>form控件中&lt;input id="input" value="hello"/&gt;  
document.getElementById("input").getAttribute("value")    //hellow
document.getElementById("input").value    //""  用户输入的值  
</code></pre> 
<blockquote> 
 <p><strong>45.offsetWidth/offsetHeight,clientWidth/clientHeight,scrollWidth/scrollHeight 的区别?</strong></p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">offsetWidth/offsetHeight 返回值包含 content + padding + border + 包含滚动条</span></li><li><span style="color:#4da8ee;">clientWidth/clientHeight 返回值只包含 content + padding，如果有滚动条，也不包含滚动条</span></li><li><span style="color:#4da8ee;">scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸</span></li></ul> 
<p><strong>怎么获取鼠标位置</strong></p> 
<p>当鼠标在页面中移动时，会触发mousemove事件，在事件处理中，可以通过event.clientX和event.clientY属性来获取鼠标在浏览器中的坐标位置</p> 
<pre><code>document.addEventListener('mousemove', function(event) { 
     var x = event.clientX; 
     var y = event.clientY;
     console.log('鼠标位置：x=' + x + ', y=' + y);
});
</code></pre> 
<p>给一个div获取距离上面和左面的距离 </p> 
<blockquote> 
 <p>46.target 和 currentTarget 区别（不用考）</p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">都是事件对象上的属性</span></li><li><span style="color:#4da8ee;">event.target：返回触发事件的元素（</span>e.target可以实现事件委托，通过事件冒泡给父元素添加事件监听。<span style="color:#4da8ee;">）</span></li><li><span style="color:#4da8ee;">event.currentTarget：返回绑定事件的元素(相当于事件中this)</span></li></ul> 
<blockquote> 
 <p>47.for和forEach谁更快，为什么？（不用看）</p> 
</blockquote> 
<p><span style="color:#4da8ee;">for 更快。</span></p> 
<ul><li><span style="color:#4da8ee;">forEach每次都要创建一个函数来调用，而for不会创建函数，函数需要独立的作用域，会有额外的开销</span></li><li><span style="color:#4da8ee;">for循环可以使用break跳出循环，但forEach不能。</span></li><li><span style="color:#4da8ee;">for循环可以控制循环起点（i初始化的数字决定循环的起点），forEach只能默认从索引0开始。</span></li></ul> 
<blockquote> 
 <p><strong>48.如何阻止冒泡 和 默认事件 </strong></p> 
</blockquote> 
<div> 
 <pre><code>停止冒泡: 
window.event ? window.event.cancelBubble = true : e.stopPropagation();
阻止默认事件: 
window.event ? window.event.returnValue = false : e.preventDefault();</code></pre> 
</div> 
<p><strong>阻止默认事件:</strong><span style="color:#4da8ee;">return false </span></p> 
<blockquote> 
 <p>49.documen.write 和 innerHTML 的区别（不用考）</p> 
</blockquote> 
<ul><li id="uc973deaa"><span style="color:#4da8ee;">document.write 只能重绘整个页面</span></li><li id="u00a79cc7"><span style="color:#4da8ee;">innerHTML 可以重绘页面的某一部分</span></li></ul> 
<blockquote> 
 <p><strong>50.如何判断一个对象是不是空对象？ </strong></p> 
</blockquote> 
<p> 方法一：<span style="color:#4da8ee;">将对象转成字符串，再判断是否等于“{}”</span></p> 
<div> 
 <pre><code>let obj = {}
console.log(JSON.stringify(obj) === "{}");</code></pre> 
</div> 
<p>方法二：<span style="color:#4da8ee;">for in循环</span></p> 
<div> 
 <pre><code>let result = function(obj){
    for(let key in obj){
        return false; // 若不为空，可遍历，返回false
    }
    return true;   
}
console.log(result(obj)) // 返回true</code></pre> 
</div> 
<p> 方法三：<span style="color:#4da8ee;">Object.keys()方法，返回对象的属性名组成的一个数组，若长度为0，则为空对象</span></p> 
<div> 
 <pre><code>console.log(Object.keys(obj).length===0);//返回true</code></pre> 
</div> 
<p>方法四：<span style="color:#4da8ee;">Object.getOwnPropertyNames方法获取对象的属性名，存到数组中，若长度为0，则为空对象</span></p> 
<div> 
 <pre><code>console.log(Object.getOwnPropertyNames(obj).length==0);//返回true</code></pre> 
</div> 
<blockquote> 
 <p><strong>51.for..in 和 object.keys的区别 </strong></p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">Object.keys()：遍历对象的key,返回一个数组，数组值为对象自有的属性，不会包括继承原型的属性</span></li><li><span style="color:#4da8ee;">for in :以任意顺序遍历一个对象的属性，包括自身属性，以及继承自原型的属性</span></li></ul> 
<div> 
 <pre><code>Object.prototype.aaa = 'aaa';
let obj = {
  a: '1',
  b: '2'
}
Object.keys(obj).forEach(item =&gt; {
  console.log(item) // a,b
})
for (const key in obj) {
  console.log(key) // a,b,aaa
}
for (const key in obj) {
  if (Object.hasOwnProperty.call(obj, key)) {
    console.log(key) // a,b
  }
}</code></pre> 
</div> 
<p><span style="color:#4da8ee;">注意：两种方法都无法遍历到以<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FSymbol" rel="nofollow" title="Symbol">Symbol</a>为键(key)的属性 </span></p> 
<blockquote> 
 <p><strong>52.介绍js有哪些内置对象？ </strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">Object是JS中所有对象的父对象</span><br> 数据封装类对象：<span style="color:#4da8ee;">Array、Boolean、Number、String、Object</span><br> 其他对象：<span style="color:#4da8ee;">Function、Arguments、Math、Date、Error、RegExp </span></p> 
<blockquote> 
 <p><strong>53.怎样判断2个对象相等:</strong>JSON.stringfiy == JSON.stringify(obj)</p> 
</blockquote> 
<p><a href="https://blog.csdn.net/codingLeader/article/details/123232737" title="js比较俩个对象是否相等_逩跑鍀小学生的博客-CSDN博客_js对比两个对象值是否相同">js比较俩个对象是否相等_逩跑鍀小学生的博客-CSDN博客_js对比两个对象值是否相同</a></p> 
<blockquote> 
 <p><strong>54.说下什么是IIFE函数</strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">IIFE(立即调用函数表达式)是一个在定义时就会立即执行的函数。</span></p> 
<p><span style="color:#0d0016;">语法：</span>(function() { // 此处为代码块 })();</p> 
<pre><code>(function(name) {
  console.log('Hello ' + name + '!');
})('World');</code></pre> 
<p>场景：</p> 
<ul><li><span style="color:#4da8ee;">避免变量名冲突：在多人开发或引入第三方库时，可能会出现变量名冲突的情况。使用 IIFE 可以在函数内声明变量，用于避免同名变量的冲突。</span></li><li><span style="color:#4da8ee;">模拟块级作用域：JavaScript 中并没有块级作用域，使用 IIFE 可以模拟块级作用域，避免变量污染全局作用域。</span></li></ul> 
<blockquote> 
 <p><strong>55.JS中的Array.prototype.splice()和Array.prototype.slice()方法作用与区别</strong></p> 
</blockquote> 
<p>Array.prototype.splice() 方法<span style="color:#4da8ee;">用于删除数组中的元素并用新元素替换它们，可以改变原数组</span>，其语法为：</p> 
<pre><code>array.splice(start[, deleteCount[, item1[, item2[, ...]]]])

// 参数说明
start：指定删除/插入的起始位置，如果是负数，表示从数组末尾开始的位置。
deleteCount：可选参数，表示要删除的元素个数，如果省略或为0，则不删除元素，只进行插入操作。
item1, item2,...：可选参数，表示要插入的新元素。</code></pre> 
<p>Array.prototype.slice() 方法<span style="color:#4da8ee;">用于从数组中截取一段指定的元素组成一个新数组，不会改变原数组，</span>其语法为：</p> 
<pre><code>array.slice([begin[, end]])
// 参数说明
begin：可选参数，表示截取起始位置的索引值，如果省略，则从头开始截取。
end：可选参数，表示截取结束位置的索引值（不包含该位置元素），如果省略，则截取到数组末尾。</code></pre> 
<p> 区别：</p> 
<ul><li><span style="color:#4da8ee;">splice() 方法会改变原数组，slice() 方法不会改变原数组。</span></li><li><span style="color:#4da8ee;">splice() 方法可以进行删除和插入操作，而 slice() 只能进行截取操作。</span></li><li><span style="color:#4da8ee;">splice() 方法的第二个参数是要删除的元素个数，slice() 方法的第二个参数是要截取到的位置。</span></li><li><span style="color:#4da8ee;">slice() 方法返回的是一个新数组，splice() 方法返回的是被删除的元素组成的数组。</span></li></ul> 
<blockquote> 
 <p><strong>56.浏览器对象有哪些</strong></p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">navigator：含有正在使用的Navigator的名称、版本属性，</span></li><li><span style="color:#4da8ee;">window：最高等级的对象，拥有整个窗口的属性;</span></li><li><span style="color:#4da8ee;">document：包含基于文档内容的属性</span></li><li><span style="color:#4da8ee;">location：含有基于当前的URL的属性。</span></li><li><span style="color:#4da8ee;">history：包含客户机先前已经请求过的URL。</span></li></ul> 
<blockquote> 
 <p><strong>57.在JS中编码与解码URL</strong></p> 
</blockquote> 
<ul><li id="uccdd6959"><span style="color:#4da8ee;">encodeURI() 可以对字符串编码</span></li><li id="u90623f12"><span style="color:#4da8ee;">.decodeURI() 可以对字符串解码</span></li></ul> 
<p>应用场景 </p> 
<p> <a href="https://blog.csdn.net/qq_55286942/article/details/125425715" title="2022最全最新前端面试题（附加解答）_心如天然薄荷清凉的博客-CSDN博客_前端面试题">2022最全最新前端面试题（附加解答）_心如天然薄荷清凉的博客-CSDN博客_前端面试题</a></p> 
<blockquote> 
 <p><strong>58.0.1 + 0.2 === 0.3 嘛？为什么？</strong> </p> 
</blockquote> 
<p><span style="color:#4da8ee;">不等于</span></p> 
<p><span style="color:#4da8ee;">在两数相加时，会先转换成二进制，0.1 和 0.2 转换成二进制的时候尾数会发生无限循环，JS 引擎对二进制进行截断，所以造成精度丢失。</span></p> 
<blockquote> 
 <p><strong>59.Number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办 （不用看）</strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">Math.pow(2, 53) ，53 为有效数字，会发生截断，等于 JS 能支持的最大数字。 </span></p> 
<blockquote> 
 <p><strong>60.NaN 是什么，用 typeof 会输出什么？ </strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">Not a Number，表示非数字，typeof NaN === 'number'  // true</span></p> 
<blockquote> 
 <p><strong>61.写一个function，清除字符串前后的空格。（兼容所有浏览器）</strong></p> 
</blockquote> 
<p>使用自带接口<span style="color:#4da8ee;">trim()</span>，考虑兼容性(IE9以下浏览器不支持)：<br> 考点：1、原型扩展 2、正则表达式 3、字符串的replace方法</p> 
<div> 
 <pre><code>if(typeof String.prototype.trim !=”function”){
String.prototype.trim=function(){
return this.replace(/^\s+|\s+$/g,”“);
}
}
var str="hello";</code></pre> 
</div> 
<blockquote> 
 <p><strong>62.前端错误如何捕获，promise的错误是如何捕获的 ？前端监控怎么做？</strong></p> 
</blockquote> 
<p><strong> 1.为什么要处理异常？</strong></p> 
<p><span style="color:#4da8ee;">异常处理是保证程序运行稳定和安全的重要机制，其目的在于当程序出现错误或异常时，能够及时地处理异常信息，防止程序崩溃或出现不可预计的错误，从而保证程序的健壮性和可靠性。</span></p> 
<p><strong>2.需要处理哪些异常？</strong></p> 
<ul><li><span style="color:#4da8ee;">语法错误：比如拼写错误、不完整的语句等导致代码无法解析的错误。</span></li><li><span style="color:#4da8ee;">引用错误（Reference Errors）：访问未声明的变量或未定义的函数等。</span></li><li><span style="color:#4da8ee;">范围错误（Range Errors）：使用了不合法的索引值或长度值等，超出了合法的范围。</span></li><li><span style="color:#4da8ee;">类型错误（Type Errors）：操作了不合法的数据类型，比如给字符串赋值为数字等。</span></li><li><span style="color:#4da8ee;">URI 错误（URI Errors）：URI 相关函数使用不正确的时候抛出的错误。</span></li></ul> 
<p><strong>3.针对异常措施进行处理 </strong></p> 
<ul><li><span style="color:#4da8ee;">try...catch...finally语句：这种方法通过try代码块捕获可能出现异常的代码，并在catch代码块中处理异常。如果有finally块，则无论try代码块是否有异常，finally块都将被执行。</span></li><li><span style="color:#4da8ee;">onerror事件处理程序：这种方法通过设置onerror事件处理程序来捕获未捕获的异常。当JavaScript代码中出现错误时，该事件处理程序会自动触发，并将错误信息传递给处理程序。</span></li></ul> 
<pre><code>// 1.try...catch...finally
try {
  // 可能会出现异常的代码
} catch (error) {
  // 处理异常
} finally {
  // 最后要执行的代码
}

// window.onerror
window.onerror = function(message, source, lineno, colno, error) {
  // 处理错误
}</code></pre> 
<p><strong>11.错误上报</strong></p> 
<blockquote> 
 <p><strong>63.什么是json:</strong><span style="color:#4da8ee;">前后台交互的一种数据格式</span></p> 
</blockquote> 
<blockquote> 
 <p><strong>64.什么是DOM和BOM</strong></p> 
</blockquote> 
<p><strong>DOM</strong>  <span style="color:#4da8ee;">指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</span></p> 
<p><strong>BOM</strong>  <span style="color:#4da8ee;">指的是浏览器对象模型(window)，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。</span></p> 
<p><span style="color:#4da8ee;">BOM:浏览器对象模型,提供操作浏览器的相关方法</span></p> 
<ul><li><span style="color:#4da8ee;">Window窗口对象</span></li><li><span style="color:#4da8ee;">Location地址对象</span></li><li><span style="color:#4da8ee;">History历史对象</span></li><li><span style="color:#4da8ee;">Navigator版本信息对象</span></li><li><span style="color:#4da8ee;">Screen屏幕独享</span></li><li><span style="color:#4da8ee;">Document文档对象</span></li><li><span style="color:#4da8ee;">DOM:文档对象模型, 提供操作文档的相关方法 </span></li></ul> 
<p>BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对<br> 象的子对象。</p> 
<blockquote> 
 <p><strong>65.描述一些常见的网页事件 </strong></p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">Onclick:单击事件(鼠标左键)</span></li><li><span style="color:#4da8ee;">Onload:加载事件</span></li><li><span style="color:#4da8ee;">Onchange:内容改变事件</span></li><li><span style="color:#4da8ee;">Onscroll:滚动事件</span></li><li><span style="color:#4da8ee;">Onmouseenter / onmouseover:鼠标进入事件</span></li><li><span style="color:#4da8ee;">Onmouseleave / onmouseout:鼠标离开事件 </span></li></ul> 
<blockquote> 
 <p><strong>66.什么是window对象? 什么是document对象?</strong></p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">Window是浏览器对象、Window对象是浏览器自动定义的顶层对象</span></li><li><span style="color:#4da8ee;">Document对象是文档的根节点。Window.document属性就是指向这个对象(只要浏览器开始载入HTML文档、这个对象就开始存在了、可以直接调用)、表示窗口中显示的当前文档对象 </span></li></ul> 
<blockquote> 
 <p><strong>67.JS中如何将页面重定向到另一个页面？</strong></p> 
</blockquote> 
<ul><li><span style="color:#4da8ee;">location.href:<code>window.location.href=“https://www.onlineinterviewquestions.com/”</code></span></li><li><span style="color:#4da8ee;">location.replace:<code>window.location.replace("https://www.onlineinterviewquestions.com"</code>)</span></li></ul> 
<blockquote> 
 <p>​<strong>68.前端模块化</strong></p> 
</blockquote> 
<p>模块化开发时一种管理方式，也是一种解决问题的方案。一个模块就是实现某个特定功能的文件。我们可以很方便的使用别人的代码，想要什么模块，就引入那个模块。</p> 
<p>CommonJS:</p> 
<p><code>CommonJS</code> 主要用在 <code>node</code> 开发上，每个文件就是一个模块，每个文件都有自己的一个作用域。通过<code>module.exports</code> 暴露 <code>public</code> 成员。<code>CommonJS</code> 通过 <code>require</code> 引入模块依赖，<code>require</code> 函数可以引入 <code>node</code> 的内置模块、自定义模块和 <code>npm</code> 等第三方模块。</p> 
<p>定义模块：</p> 
<pre><code>// 定义模块 math.js
var basicNum = 0;
function add(a, b) {
  return a + b;
}
// 在这里写上需要向外暴露的函数、变量
module.exports = { 
  add: add,
  basicNum: basicNum
}</code></pre> 
<p>加载模块</p> 
<pre><code>// 引入 math.js 模块
var math = require('./math');
math.add(2, 3); // 5</code></pre> 
<p><a href="https://juejin.cn/post/7203968787325960229" rel="nofollow" title="聊聊 js 模块化(CommonJS, AMD, UMD, CMD, ES6) - 掘金">聊聊 js 模块化(CommonJS, AMD, UMD, CMD, ES6) - 掘金</a></p> 
<blockquote> 
 <p id="head3"><strong>69.为什么需要模块化和模块化规范?</strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">模块化可以解决代码之间的变量、函数、对象等命名的<strong>冲突/污染</strong>问题，良好的模块化设计可以<strong>降低代码之间的耦合关系</strong>，提高代码的可维护性、可扩展性以及复用性。</span></p> 
<blockquote> 
 <p><strong>70.设计模式有哪些？（说发布订阅模式和工厂模式）</strong></p> 
</blockquote> 
<ul><li> <p><span style="color:#4da8ee;">发布订阅模式:一种消息模式，它定义了一种解耦的方法，使得多个对象间可以轻松地交换消息而不需要显式的依赖关系。在发布订阅模式中，消息的发送者称为发布者（Publisher），而消息的接收者称为订阅者（Subscriber）。发布者通知订阅者有关于特定事件的消息，而订阅者只需要监听它们感兴趣的这些事件即可。</span><br><span style="color:#4da8ee;">这种设计模式可以大大降低程序模块之间的耦合度，便于更加灵活的扩展和维护。</span></p> </li></ul> 
<pre><code>// 定义一个发布者
class Publisher {
  constructor() {
    this.subscribers = [];
  }

  // 添加订阅者
  addSubscriber(subscriber) {
    this.subscribers.push(subscriber);
  }

  // 移除订阅者
  removeSubscriber(subscriber) {
    const index = this.subscribers.indexOf(subscriber);
    if (index !== -1) {
      this.subscribers.splice(index, 1);
    }
  }

  // 通知所有订阅者
  notify(data) {
    this.subscribers.forEach(subscriber =&gt; subscriber.update(data));
  }
}

// 定义一个订阅者
class Subscriber {
  constructor(name) {
    this.name = name;
  }

  update(data) {
    console.log(`${this.name} received data: ${data}`);
  }
}

// 测试用例
const publisher = new Publisher();

const subscriber1 = new Subscriber('subscriber1');
const subscriber2 = new Subscriber('subscriber2');

publisher.addSubscriber(subscriber1);
publisher.addSubscriber(subscriber2);

publisher.notify('Hello world!');

publisher.removeSubscriber(subscriber1);

publisher.notify('How are you?');

在上面的示例中，我们定义了两个类，Publisher和Subscriber。Publisher类用于添加和删除订阅者，并通知所有已添加的订阅者。Subscriber类用于接收并处理发布者发送的消息。

创建实例后，我们将subscriber1和subscriber2添加到publisher中，然后发送两条消息，第一条是Hello world!，第二条是How are you?，此时subscriber1已被移除。

最终的控制台输出结果为：
subscriber1 received data: Hello world!
subscriber2 received data: Hello world!
subscriber2 received data: How are you?
可以看到，subscriber1和subscriber2都收到了第一条消息。然后，subscriber1被移除，只有subscriber2在接收第二条消息。这就是发布订阅模式的基本流程。</code></pre> 
<ul><li> <p><span style="color:#4da8ee;">单例模式 :是一个类只能实例化一次，并提供全局访问这个实例的方案。常用于管理全局状态、缓存、日志等。</span></p> </li><li> <p>单例模式可以有效的节省内存空间，同时避免出现多个实例导致的状态不一致问题，常用于需要在全局范围内有效共享实例等场景。</p> </li></ul> 
<pre><code>// 单例模式：只是实例化一次。每次返回的实例都是同一对象

function person(name){
    this.name = name
}
 
var getInstance = (function(){
    var instance
    return function(name){
        if(!instance) instance = new person(name)
        return instance
    }
})()
 
var person1 = getInstance('zhangsan') 
var person2 = getInstance('lisi')
console.log(person1.name); //zhangsan
console.log(person2.name); //zhangsan
console.log(person1 === person2);  //true</code></pre> 
<ul><li> <p><span style="color:#4da8ee;">工厂模式 :一种创建对象的方式，原理是通过工厂函数（也称创建函数或构造器函数）来封装对象的创建过程，以实现灵活、高效的对象创建和管理。工厂函数可以是一个简单的对象创建函数，也可以是一个返回新对象的函数，其创建过程与构造函数类似，但不需要使用 new 关键字。</span></p> </li></ul> 
<pre><code>function createPerson(name, age, gender) {
  return {
    name: name,
    age: age,
    gender: gender,
    sayHello: function() {
      console.log('Hello, my name is ' + this.name);
    }
  };
}

var alice = createPerson('Alice', 25, 'female');
var bob = createPerson('Bob', 30, 'male');

console.log(alice.name); // Alice
console.log(bob.age); // 30
alice.sayHello(); // Hello, my name is Alice
bob.sayHello(); // Hello, my name is Bob</code></pre> 
<p><a href="https://zhuanlan.zhihu.com/p/474296206" rel="nofollow" title="JavaScript 设计模式（三）：工厂模式 - 知乎">JavaScript 设计模式（三）：工厂模式 - 知乎</a></p> 
<blockquote> 
 <p><strong>71.如何做工程上的优化 </strong> </p> 
</blockquote> 
<p>前端工程化：对前端进行一些流程的标准化，让开发更有效率</p> 
<p>可以从4个维度谈谈</p> 
<ol><li>模块化</li><li>组件化</li><li>规范化</li><li>自动化</li></ol> 
<blockquote> 
 <p><strong>72.什么是变量预解析 </strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">解释器执行变量提升的过程就是变量的预解析 </span></p> 
<blockquote> 
 <p><strong>73.请描述一下 location.go(-1) 和 history.go(-1) 有什么区别 </strong></p> 
</blockquote> 
<ul><li>两个函数都可以用于页面回到上一页， location.go() 需要插件支持*</li><li><span style="color:#4da8ee;">location.go(-1)回到上一页并且刷新页面</span></li><li><span style="color:#4da8ee;">history.go(-1) ，回到上一页7</span><strong>.JS代码中如何跳转页面?如何刷新当前页面? </strong></li></ul> 
<p><span style="color:#4da8ee;">reload() 方法</span>:<span style="color:#4da8ee;">用于刷新当前文档;</span><span style="color:#4da8ee;">类似于你浏览器上的刷新页面按钮。</span></p> 
<blockquote> 
 <p><strong>74.数组的方法concat、slice是深拷贝还是浅拷贝</strong> </p> 
</blockquote> 
<p><span style="color:#4da8ee;">对一维数组来说是深拷贝，对多维数组来说是浅拷贝</span></p> 
<blockquote> 
 <p><strong>75.事件可以绑定，那么事件可以取消吗 </strong></p> 
</blockquote> 
<pre><code>1.对象属性绑定的事件，取消
    &lt;script&gt;
        // 绑定事件
        _btn.onclick = function() {}
        // 取消事件
        _btn.onclick = null
    &lt;/script&gt;
2.标准语法绑定事件，取消
  &lt;script&gt;
        function handler(){
            // 事件处理函数
        }
        // 绑定事件
        _btn.addEventListener("click", handler)
        // 取消指定事件
        _btn.removeEventListener("click", handler)
    &lt;/script&gt;
</code></pre> 
<blockquote> 
 <p>白屏和首屏 </p> 
</blockquote> 
<p><span style="color:#4da8ee;">白屏指的是用户在访问一个网站时，在屏幕上看到的空白时间段，通常是指页面加载的过程中，浏览器显示的是一个空白的页面，直到网页的实际内容开始渲染出来。</span></p> 
<p><span style="color:#4da8ee;">首屏时间（First Paint Time）是指用户第一次看到页面上有渲染内容的时间点，也可以说是页面开始渲染时为用户渲染展示的首屏内容所需要的时间。</span></p> 
<p>通常来说，会有多种因素影响网站的白屏和首屏时间，其中包括但不限于：</p> 
<ol><li> <p>网络连接速度：一个网页需要下载多少数据量以及用户所处的网络带宽都会影响到页面的加载速度。</p> </li><li> <p>网页的体积：网页中含有多少图片、视频、脚本、样式等都会影响到页面的加载速度。</p> </li><li> <p>服务器响应速度：网站服务器的响应速度也会影响页面的加载速度。</p> </li></ol> 
<p><span style="color:#4da8ee;">为了减少白屏和首屏时间，一些前端技术被提出。其中，代码分割技术是提高页面加载速度的重要手段之一。webpack 中的代码分割技术就是通过把代码分割成小块，按需加载而实现的。</span></p> 
<p>具体来说，webpack 对JavaScript 文件进行代码分割的方式有两种：</p> 
<ol><li> <p>同步分割：使用 import 语句，将代码拆分成多个文件，并可以根据需要进行加载。</p> </li><li> <p>异步分割：采用 import() 函数动态地从服务器中加载代码块，按需进行加载。</p> </li></ol> 
<p>这样，通过代码分割，webpack 可以让页面加载时仅加载必需的代码，而其余代码通过按需加载的方式进行加载，从而提升加载速度，减少页面的白屏和首屏时间。</p> 
<blockquote> 
 <p><strong>76.白屏和首屏时间(</strong>如何计算白屏和首屏时间？onload事件发生了什么？)</p> 
</blockquote> 
<p>白屏时间：<span style="color:#4da8ee;">从用户输入网址并点击回车，到浏览器开始显示内容（出现第一个字符或元素）的时间。</span>（通常认为，浏览器开始渲染 &lt;body&gt; 或者解析完 &lt;head&gt; 的时间是白屏结束的时间点。）</p> 
<p>首屏时间：<span style="color:#4da8ee;">从用户输入网址并点击回车，到首屏内容（第一个页面）渲染完成的时间</span></p> 
<p></p> 
<p><span style="color:#0d0016;">白屏结束时间 = FP事件触发时间</span></p> 
<p><span style="color:#0d0016;">首屏结束时间 = FCP事件触发时间</span></p> 
<p><span style="color:#0d0016;">FP（First Paint）表示渲染出第一个像素点的时间。FP一般在HTML解析完成或者解析一部分时候触发。</span></p> 
<p><span style="color:#0d0016;">FCP（First Contentful Paint）表示渲染出第一个内容的时间，这里的“内容”可以是文本、图片、canvas。</span></p> 
<p>Onload Event，它代表页面中依赖的所有资源：DOM、图片、CSS、Flash等都加载完。</p> 
<pre><code>// 指标计算方法
// FP
const fp = performance.getEntries('paint').filter(entry =&gt; entry.name == 'first-paint')[0].startTime;


// FCP
const fcp = performance.getEntries('paint').filter(entry =&gt; entry.name == 'first-contentful-paint')[0].startTime;


// Onload Event
const l = performance.timing.loadEventEnd - performance.timing.navigationStart;</code></pre> 
<blockquote> 
 <p><strong>77.表单可以跨域吗 </strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">可以跨域，在被提交的接口所在的服务器上进行相应的设置，以允许跨域请求，</span>设置有几种方式：</p> 
<ul><li><span style="color:#4da8ee;">在请求的接口上设置允许跨域请求的header头，如允许跨域的域名，请求方法等信息</span></li><li><span style="color:#4da8ee;">在被提交的接口响应头中加Access-Control-Allow-Origin字段，指定允许的跨域请求来源域名</span></li></ul> 
<pre><code>router.all('*', function(req, res, next) {
    res.header("Access-Control-Allow-Origin", "*"); // 允许所有来源访问
    res.header("Access-Control-Allow-Headers", "X-Requested-With");
    res.header("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS"); // 允许跨域请求的方法
    next();
});</code></pre> 
<p> 注意：跨域的表单提交可能会带来一些安全问题，例如被跨域访问的接口可能会被非法访问、CSRF 等攻击，因此在开发中需要谨慎处理。</p> 
<blockquote> 
 <p><strong>78.搜索请求如何处理（防抖）</strong></p> 
</blockquote> 
<p>搜索请求防抖可以通过以下步骤进行处理：</p> 
<ul><li><span style="color:#4da8ee;">监听搜索框的输入事件，例如keyup或者input事件。</span></li><li><span style="color:#4da8ee;">事件处理函数中，设置一个定时器（通常为300ms - 500ms），定时器回调函数中执行搜索操作。</span></li><li>每次输入事件发生时，如果定时器尚未到达设定时间，立即清除上一次的定时器，并重新设置一个新的定时器。</li><li>如果定时器已到达设定的时间，执行搜索操作，并清除定时器。</li></ul> 
<p>通过这种方式，可以将用户输入的一连串字符进行合并，并在一定时间内只发送一次搜索请求，从而减轻服务器的压力，优化搜索功能的体验。</p> 
<blockquote> 
 <p><strong>79.搜索请求中文如何请求</strong></p> 
</blockquote> 
<p>在进行搜索请求时，需要将<span style="color:#4da8ee;">中文进行URL编码</span>，即将中文字符转换成%XX的形式。其中XX表示该字符的ASCII 码</p> 
<p><span style="color:#4da8ee;">JS提供了encodeURIComponent()函数</span>，可以将字符串进行 URL 编码。以下是使用示例：</p> 
<pre><code>let keyword = '中文关键词';
let encodedKeyword = encodeURIComponent(keyword);
console.log(encodedKeyword); // %E4%B8%AD%E6%96%87%E5%85%B3%E9%94%AE%E8%AF%8D</code></pre> 
<p> 此时获取到的 <code>encodedKeyword</code> 即可用于拼接请求 URL。注意，<span style="color:#4da8ee;">在服务器端需要对 URL 进行解码，可以使用 <code>decodeURIComponent()</code> 函数。</span></p> 
<blockquote> 
 <p>80.js鼠标事件，键盘事件 </p> 
</blockquote> 
<ol><li><span style="color:#4da8ee;">keyup 按键弹起的时候触发</span></li><li><span style="color:#4da8ee;">keydown 按键按下的时候触发</span></li><li><span style="color:#4da8ee;">keypress 按键按下的时候触发，它识别不了shift、Ctrl这样的功能键</span></li></ol> 
<p> 三个事件的执行顺序：keydown——keypress——keyup</p> 
<p>鼠标：</p> 
<p><span style="color:#4da8ee;">click 单击鼠标左键时触发，右键按下则不会触发<br> dblclick 双击鼠标左键时触发，右键按下则不会触发<br> mousedown 鼠标按钮被按下时触发，左右键都可以触发</span><br> mouseout 鼠标指针位于某个元素上且将要移出元素的边界时触发<br> mouseover 鼠标指针移出某个元素到另一个元素上时触发<br><span style="color:#4da8ee;">mousemove 鼠标在某个元素上触发<br> mouseleave 鼠标指针移出元素时触发</span><br> mouseenter 鼠标指针移动到元素上时触发<br> contextmenu 用户点击鼠标右键打开上下文菜单时触发</p> 
<blockquote> 
 <p><strong>&lt;a&gt;标签默认事件禁掉之后做了什么才实现了跳转</strong></p> 
</blockquote> 
<p>下面不用看===== </p> 
<blockquote> 
 <p><strong>72.什么是cookie?</strong></p> 
</blockquote> 
<p>cookie 是网站应用开发中，服务器给浏览器客户端记录文本数据的一个对象；记录数据的时候有如下特点：</p> 
<ul><li><span style="color:#4da8ee;">数据格式： key=value ，保存的数据只能是文本数据</span></li><li><span style="color:#4da8ee;">有过期时间： expires=xxxx        </span></li><li><span style="color:#4da8ee;">不设置过期时间，称为临时 cookie ，会话结束数据删除</span></li><li><span style="color:#4da8ee;">设置过期时间，称为永久 cookie ，过期时间一到立即删除</span></li><li><span style="color:#4da8ee;">可以包含路径，给不同的路径保存不同的 cookie</span></li><li><span style="color:#4da8ee;">一个网站，大部分浏览器限制最多保存50个 key=value 键值对</span></li><li><span style="color:#4da8ee;">一个网站，大部分浏览器限制最多保存 4K 数据缺点 存储量太小，只有4KB</span></li></ul> 
<p><span style="color:#4da8ee;">缺点 每次HTTP请求都会发送到服务端，影响获取资源的效率<br> 缺点 需要自己封装获取、设置、删除cookie的方法<br> 缺点 当超过单个域名限制之后，再设置cookie，浏览器就会清除以前设置的cookie。IE和Opera 会清理近期最少使用的cookie，FF会随机清理cookie</span></p> 
<p><a href="https://blog.csdn.net/sinat_36184075/article/details/105646140" title="Cookie的工作原理和应用详解_不才Jerry的博客-CSDN博客_cookie的工作原理">Cookie的工作原理和应用详解_不才Jerry的博客-CSDN博客_cookie的工作原理</a></p> 
<blockquote> 
 <p><strong>73.如何使用 JS 删除 cookie</strong></p> 
</blockquote> 
<ul><li id="u928c7d71"><span style="color:#4da8ee;">如果要删除cookie以便后续尝试读取cookie，则只需将过期日期设置为过去的时间。</span></li><li id="u0b7441ed"><span style="color:#4da8ee;">咱们应该定义cookie路径以确保删除正确的cookie。</span></li><li id="uf763274c"><span style="color:#4da8ee;">如果未指定路径，某些浏览器将不允许咱们删除cookie</span></li></ul> 
<blockquote> 
 <p> 54.getComputedStyle()和getPropertyValue()</p> 
</blockquote> 
<p></p> 
<ul><li><span style="color:#0d0016;">getComputedStyle()方法用于获取指定元素的css样式</span></li><li><span style="color:#0d0016;">// 获取的样式是元素在浏览器中最终渲染效果的样式</span></li><li><span style="color:#0d0016;">// getPropertyValue()方法返回指定的css属性的值</span></li></ul> 
<div> 
 <pre><code>&lt;style&gt;
#elem-container{
    width: 300px;
    height: 300px;
    background-color:red;
}
&lt;/style&gt;
&lt;div id="elem-container"&gt;测试&lt;/div&gt;
&lt;script&gt;
    let elem = document.getElementById("elem-container")
    let theCSSprop = window.getComputedStyle(elem,null)
    console.log(theCSSprop.width)
    console.log(theCSSprop.backgroundColor)
    console.log(theCSSprop.getPropertyValue("height"))
&lt;/script&gt;</code></pre> 
</div> 
<blockquote>
  84.如何获取鼠标在窗口的位置? 
</blockquote> 
<p>属性及其兼容性<br> 属性 说明 兼容性</p> 
<ul><li><span style="color:#4da8ee;">clientX 以浏览器窗口左上顶角为原点，定位 x 轴坐标 所有浏览器，不兼容 Safari</span></li><li><span style="color:#4da8ee;">clientY 以浏览器窗口左上顶角为原点，定位 y 轴坐标 所有浏览器，不兼容 Safari</span></li><li><span style="color:#4da8ee;">offsetX 以当前事件的目标对象左上顶角为原点，定位 x 轴坐标 所有浏览器，不兼容 Mozilla</span></li><li><span style="color:#4da8ee;">offsetY 以当前事件的目标对象左上顶角为原点，定位 y 轴坐标 所有浏览器，不兼容 Mozilla</span></li><li><span style="color:#4da8ee;">pageX 以 document 对象（即文档窗口）左上顶角为原点，定位 x 轴坐标 所有浏览器，不兼容 IE</span></li><li><span style="color:#4da8ee;">pageY 以 document 对象（即文档窗口）左上顶角为原点，定位 y 轴坐标 所有浏览器，不兼容 IE</span></li><li><span style="color:#4da8ee;">screenX 计算机屏幕左上顶角为原点，定位 x 轴坐标 所有浏览器</span></li><li><span style="color:#4da8ee;">screenY 计算机屏幕左上顶角为原点，定位 y 轴坐标 所有浏览器</span></li></ul> 
<p>layerX 最近的绝对定位的父元素（如果没有，则为 document 对象）左上顶角为元素，定位 x 轴坐标 Mozilla 和 Safari<br> layerY 最近的绝对定位的父元素（如果没有，则为 document 对象）左上顶角为元素，定位 y 轴坐标 Mozilla 和 Safari</p> 
<blockquote> 
 <p>什么是工程化？ </p> 
</blockquote> 
<p>前端工程可以定义为，将工程方法系统化地应用到前端开发中， 以系统、严谨、可量化的方法开发、运营、维护前端应用程序。</p> 
<p>前端工程化流程：<br>     创建项目 =&gt; 编码 =&gt; 预览/测试 =&gt; 提交 =&gt; 部署<br>     创建项目：<br>         在项目开发初期，我们可以实用工具自动创建一些脚手架、<br>         模板、通用等文件；还能够创建项目结构、创建特定类型文件。<br>      编码 ：<br>          在正式堆代码的时候，可能会有多人协同开发的场景；这时候需<br>          要我们制定编码规范来约束开发人员的编码风格，并使用工具来<br>          代替人为约定。除此之外，还可以使用一些自动化工具来替我们<br>          自动构建、自动编译打包。<br>      预览/测试：<br>           在开发本地调试的时候，我们可以使用一些工具来模拟服务器场<br>           景并实现热更新、热加载；即代码修改后自动编译构建，浏览器根<br>           据变化自动刷新同时还要方便我们查看源码。<br>      提交：<br>          Git Hooks：可在提交前进行代码质量和风格的检查<br>          Lint-staged 持续集成<br>       部署：<br>           自动化部署：CI/CD<br>           自动化集成：Jenkins 可以调用执行脚本，集成自动化构建、打包、<br>           部署等。<br>         <img alt="" height="648" src="https://images2.imgbox.com/a7/f2/WVWvMIoV_o.png" width="1120"></p> 
<blockquote> 
 <p>74.实现一个简单的观察者模式 </p> 
</blockquote> 
<p>可以说：react中有一种观察者模式 </p> 
<p><a href="https://www.jb51.net/article/230975.htm" rel="nofollow" title="https://www.jb51.net/article/230975.htm">https://www.jb51.net/article/230975.htm</a></p> 
<p>观察者模式一种设计模式</p> 
<p>观察者模式定义了对象间的一对多的依赖关系，当一个对象的状态发送改变时，所有依赖它的对象都将得到状态改变的通知</p> 
<blockquote> 
 <p><strong>73.JS有三类的错误:（ JS 中的主要有哪几类错误）</strong></p> 
</blockquote> 
<ol><li><span style="color:#4da8ee;"><strong>加载时错误</strong>：加载web页面时出现的错误(如语法错误)称为加载时错误，它会动态生成错误。</span></li><li><span style="color:#4da8ee;"><strong>运行时错误</strong>：由于滥用HTML语言中的命令而导致的错误。</span></li><li><span style="color:#4da8ee;"><strong>逻辑错误</strong>：这些错误是由于对具有不同操作的函数执行了错误的逻辑而导致的</span></li></ol> 
<blockquote> 
 <p>说一下slice splice split 的区别?</p> 
</blockquote> 
<p>// slice(start,[end]) // slice(start,[end])方法：该方法是对数组进行部分截取，该方法返回一个新数组 // 参数start是截取的开始数组索引，end参数等于你要取的最后一个字符的位置值加上1（可选）。 // 包含了源函数从start到 end 所指定的元素，但是不包括end元素，比如a.slice(0,3)； // 如果出现负数就把负数与长度相加后再划分。 // slice中的负数的绝对值若大于数组长度就会显示所有数组 // 若参数只有一个，并且参数大于length，则为空。 // 如果结束位置小于起始位置，则返回空数组 // 返回的个数是end-start的个数 // 不会改变原数组 var arr = [1,2,3,4,5,6] /*console.log(arr.slice(3))//[4,5,6] 从下标为0的到3，截取3之后的数 console.log(arr.slice(0,3))//[1,2,3] 从下标为0的地方截取到下标为3之前的数 console.log(arr.slice(0,-2))//[1,2,3,4] console.log(arr.slice(-4,4))//[3,4] console.log(arr.slice(-7))//[1,2,3,4,5,6] console.log(arr.slice(-3,-3))// [] console.log(arr.slice(8))//[]*/ // 个人总结：slice的参数如果是正数就从左往右数，如果是负数的话就从右往左边数， // 截取的数组与数的方向一致，如果是2个参数则截取的是数的交集，没有交集则返回空数组 // ps：slice也可以切割字符串，用法和数组一样，但要注意空格也算字符 // splice(start,deletecount,item) // start：起始位置 // deletecount：删除位数 // item：替换的item // 返回值为被删除的字符串 // 如果有额外的参数，那么item会插入到被移除元素的位置上。 // splice:移除，splice方法从array中移除一个或多个数组，并用新的item替换它们。 //举一个简单的例子 var a=['a','b','c']; var b=a.splice(1,1,'e','f'); console.log(a) //['a', 'e', 'f', 'c'] console.log(b) //['b'] var a = [1, 2, 3, 4, 5, 6]; //console.log("被删除的为：",a.splice(1, 1, 8, 9)); //被删除的为：2 // console.log("a数组元素：",a); //1,8,9,3,4,5,6 // console.log("被删除的为：", a.splice(0, 2)); //被删除的为：1,2 // console.log("a数组元素：", a) //3,4,5,6 console.log("被删除的为：", a.splice(1, 0, 2, 2)) //插入 第二个数为0，表示删除0个 console.log("a数组元素：", a) //1,2,2,2,3,4,5,6 // split(字符串) // string.split(separator,limit)：split方法把这个string分割成片段来创建一个字符串数组。 // 可选参数limit可以限制被分割的片段数量。 // separator参数可以是一个字符串或一个正则表达式。 // 如果separator是一个空字符，会返回一个单字符的数组，不会改变原数组。 var a="0123456"; var b=a.split("",3); console.log(b);//b=["0","1","2"] // 注意：String.split() 执行的操作与 Array.join 执行的操作是相反的。</p> 
<blockquote> 
 <p><strong>说一下JSON.stringify有什么缺点？ </strong></p> 
</blockquote> 
<p><span style="color:#4da8ee;">1.如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对象的形式</span></p> 
<p>2.如果obj里有RegExp(正则表达式的缩写)、Error对象，则序列化的结果将只得到空对象；</p> 
<p><span style="color:#4da8ee;">3、如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；</span></p> 
<p>4、如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null</p> 
<p>5、JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor；</p> 
<p>6、如果对象中存在循环引用的情况也无法正确实现深拷贝； </p> 
<blockquote> 
 <p>70. IE和标准下有哪些兼容性的写法</p> 
</blockquote> 
<p>答案：</p> 
<p>var ev = ev || window.event<br> document.documentElement.clientWidth || document.body.clientWidth<br> Var target = ev.srcElement||ev.target</p> 
<blockquote> 
 <p>中高级开发面试题</p> 
</blockquote> 
<blockquote> 
 <a href="https://blog.csdn.net/qq_40055200/article/details/127551538?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127551538%22%2C%22source%22%3A%22qq_40055200%22%7D" title="https://blog.csdn.net/qq_40055200/article/details/127551538?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127551538%22%2C%22source%22%3A%22qq_40055200%22%7D">https://blog.csdn.net/qq_40055200/article/details/127551538?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127551538%22%2C%22source%22%3A%22qq_40055200%22%7D</a> 
</blockquote> 
<p><a href="https://juejin.cn/post/7073869980411887652#heading-29" rel="nofollow" title="最近两周出去面试遇到的面试题（前端初级、长更） - 掘金">最近两周出去面试遇到的面试题（前端初级、长更） - 掘金</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/95a63028164740619faa549dce9fe34d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python实现校园网自动连接</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fcb2db3bb7144075bee3f25acba6500b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一篇文章带你精通Sql Server 基础语法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>