<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>源码学习时间，Window Manager in Android - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="源码学习时间，Window Manager in Android" />
<meta property="og:description" content="/ 今日科技快讯 /
近日消息，京东百亿补贴被曝已开始少量上线测试，已有用户可看到活动页面！据网友反馈，京东部分商品现已有“百亿补贴”的标签，目前上线的商品包括手机、家电、酒水、食品、服饰等众多品类。
/ 作者简介 /
大家周五好，咱们下周再见，祝大家周末愉快！
本篇文章转自小余的自习室的博客，文章主要分享了Android WindowManager体系的讲解，相信会对大家有所帮助！
原文地址：
https://juejin.cn/post/7166157765570723871
/ 前言 /
大家好，由于工作和面试需要，笔者结合大佬们的经验以及自身对源码理解，写了一篇关于Android framework层：WindowManager体系的讲解。
本篇是Android framework的第一讲，重在讲解Window在被添加到WindowManagerService前的流程。
/ WindowManager体系 /
Android中的窗口体系可以分为下面三部分：
1. Window：可以简单理解为一个窗口，这个窗口承载了需要绘制的View，他是一个抽象类，具体实现类是PhoneWindow。
2. WindowManager：也是一个接口类，继承ViewManager，用来对Window进行管理， 实现类：WindowManagerImpl，其对Window的操作具体是通过WMS来实现的。理解为一个app层面的WMS和Window的中间人。
3. WindowManagerService(WMS)：是系统服务中的一重要成员，WindowManager和WMS通过binder进行通讯，真正对Window添加，更新，删除等操作的执行者。
三者之间关系：
前面分析了窗口体系中的类关系，下面我们从源码角度和分析下：
为了大家不会迷路在源码中，笔者会根据面试中可能被问到的几个问题出发，有目的性的介绍。
问题1：Window和Activity以及WindowManager什么时候建立的关系？
问题2：Window什么时候和View进行关联？
问题3：Window有哪些属性？类型？层级关系？z-order？Window标志？软键盘模式都了解么？
问题4：View是如何一步一步添加到屏幕上的？更新？删除呢？
那么就开始我们的源码（mo）遨（yu）游吧。
1.Window和Activity以及WindowManager什么时候建立的关系？
前面几篇文章我们分析过：Activity在启动的过程中，会调用它的attach方法进行Window的创建。那就直接定位到Activity的attach方法：
final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback) { attachBaseContext(context); ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/7ded01debee87a76a8d919b920f49e8f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-03T08:00:09+08:00" />
<meta property="article:modified_time" content="2023-03-03T08:00:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">源码学习时间，Window Manager in Android</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/0d/ac/RLmiw60L_o.jpg" alt="58e79a4e5cb96cdc82edaa409ba91506.jpeg"><br></p> 
 <p style="text-align:center;">/   今日科技快讯   /</p> 
 <p>近日消息，京东百亿补贴被曝已开始少量上线测试，已有用户可看到活动页面！据网友反馈，京东部分商品现已有“百亿补贴”的标签，目前上线的商品包括手机、家电、酒水、食品、服饰等众多品类。</p> 
 <p style="text-align:center;">/   作者简介   /<br></p> 
 <p>大家周五好，咱们下周再见，祝大家周末愉快！</p> 
 <p>本篇文章转自小余的自习室的博客，文章主要分享了Android WindowManager体系的讲解，相信会对大家有所帮助！</p> 
 <p>原文地址：</p> 
 <blockquote> 
  <p style="text-align:justify;">https://juejin.cn/post/7166157765570723871</p> 
 </blockquote> 
 <p style="text-align:center;">/   前言   /</p> 
 <p style="text-align:left;">大家好，由于工作和面试需要，笔者结合大佬们的经验以及自身对源码理解，写了一篇关于Android framework层：WindowManager体系的讲解。<br></p> 
 <p style="text-align:left;">本篇是Android framework的第一讲，重在讲解Window在被添加到WindowManagerService前的流程。</p> 
 <p style="text-align:center;">/   WindowManager体系   /</p> 
 <p style="text-align:justify;">Android中的窗口体系可以分为下面三部分：</p> 
 <p style="text-align:justify;">1. <strong>Window</strong>：可以简单理解为一个窗口，这个窗口承载了需要绘制的View，他是一个抽象类，具体实现类是PhoneWindow。</p> 
 <p style="text-align:justify;">2. <strong>WindowManager</strong>：也是一个接口类，继承ViewManager，用来对Window进行管理， 实现类：WindowManagerImpl，其对Window的操作具体是通过WMS来实现的。理解为一个app层面的WMS和Window的中间人。</p> 
 <p style="text-align:justify;">3. <strong>WindowManagerService(WMS)</strong>：是系统服务中的一重要成员，WindowManager和WMS通过binder进行通讯，真正对Window添加，更新，删除等操作的执行者。</p> 
 <p style="text-align:justify;">三者之间关系：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/b5/86/n6ksGIFo_o.png" alt="outside_default.png"></p> 
 <p style="text-align:justify;">前面分析了窗口体系中的类关系，下面我们从源码角度和分析下：</p> 
 <p style="text-align:justify;">为了大家不会迷路在源码中，笔者会根据面试中可能被问到的几个问题出发，有目的性的介绍。</p> 
 <ul><li><p style="text-align:justify;"><strong>问题1：</strong>Window和Activity以及WindowManager什么时候建立的关系？</p></li><li><p style="text-align:justify;"><strong>问题2：</strong>Window什么时候和View进行关联？</p></li><li><p style="text-align:justify;"><strong>问题3：</strong>Window有哪些属性？类型？层级关系？z-order？Window标志？软键盘模式都了解么？</p></li><li><p style="text-align:justify;"><strong>问题4：</strong>View是如何一步一步添加到屏幕上的？更新？删除呢？</p></li></ul> 
 <p style="text-align:justify;">那么就开始我们的源码（mo）遨（yu）游吧。</p> 
 <p style="text-align:justify;"><strong>1.Window和Activity以及WindowManager什么时候建立的关系？</strong></p> 
 <p style="text-align:justify;">前面几篇文章我们分析过：Activity在启动的过程中，会调用它的attach方法进行Window的创建。那就直接定位到Activity的attach方法：</p> 
 <pre class="has"><code class="language-go">final void attach(Context context, ActivityThread aThread,
        Instrumentation instr, IBinder token, int ident,
        Application application, Intent intent, ActivityInfo info,
        CharSequence title, Activity parent, String id,
        NonConfigurationInstances lastNonConfigurationInstances,
        Configuration config, String referrer, IVoiceInteractor voiceInteractor,
        Window window, ActivityConfigCallback activityConfigCallback) {
    attachBaseContext(context);
    ...
    mWindow = new PhoneWindow(this, window, activityConfigCallback);//1
    ...
    mWindow.setWindowManager(
            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
            mToken, mComponent.flattenToString(),
            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);//2
}</code></pre> 
 <p>先看attach注释1处：<strong>创建了一个PhoneWindow，并传入当前Activity的this对象</strong>， PhoneWindow类，继承了Window</p> 
 <pre class="has"><code class="language-go">public class PhoneWindow extends Window {
    public PhoneWindow(Context context, Window preservedWindow,
            ActivityConfigCallback activityConfigCallback) {
        //这里最终会调父类Window的构造方法，并传入Activity的实例context。
        this(context);
        //只有Activity的Window才会使用Decor context,其他依赖使用的Context
        mUseDecorContext = true;
        ...
   }

}</code></pre> 
 <p style="text-align:justify;">Window构造方法：</p> 
 <pre class="has"><code class="language-go">public Window(Context context) {
    mContext = context;
    mFeatures = mLocalFeatures = getDefaultFeatures(context);
}</code></pre> 
 <p style="text-align:justify;">PhoneWindow的构造方法中传入当前Activity对象， 并最终在父类Window构造方法中给mContext赋值，<strong>Window得到Activity的引用，由此就建立了Window和Activity的联系。</strong></p> 
 <p style="text-align:justify;">下面继续看attach注释2：mWindow.setWindowManager</p> 
 <p style="text-align:justify;">setWindowManager在PhoneWindow的父类Window中实现：</p> 
 <pre class="has"><code class="language-go">public void setWindowManager(WindowManager wm, IBinder appToken, String appName,
        boolean hardwareAccelerated) {
    //如果wm是空，则创建一个WindowManager服务：注释1
    if (wm == null) {
        wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
    }
    //注释2
    mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);
}</code></pre> 
 <p style="text-align:left;">进入setWindowManager的注释1：</p> 
 <p style="text-align:left;">wm =(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</p> 
 <p style="text-align:left;"><strong>这里的mContext是ContextImpl类的对象：</strong></p> 
 <pre class="has"><code class="language-go">@Override
public Object getSystemService(String name) {
    return SystemServiceRegistry.getSystemService(this, name);
}
进入SystemServiceRegistry的getSystemService方法，name = Context.WINDOW_SERVICE
public static Object getSystemService(ContextImpl ctx, String name) {
    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);//1
    return fetcher != null ? fetcher.getService(ctx) : null;//2
}</code></pre> 
 <p style="text-align:justify;">先看getSystemService方法的注释1：<strong> SYSTEM_SERVICE_FETCHERS是一个HashMap的集合，在哪里初始化的？</strong></p> 
 <p style="text-align:justify;">我们注意到SystemServiceRegistry的static 方法,这个方法内部注册了很多服务，我们可以在方法里面找到name = Context.WINDOW_SERVICE的服务</p> 
 <p style="text-align:justify;"><strong>PS：static方法是在类加载的时候进行初始化的，所以在整个类使用过程中只会执行一次。</strong></p> 
 <pre class="has"><code class="language-go">static {
    ...
    registerService(Context.WINDOW_SERVICE, WindowManager.class,
        new CachedServiceFetcher&lt;WindowManager&gt;() {
    @Override
    public WindowManager createService(ContextImpl ctx) {
        return new WindowManagerImpl(ctx);
    }});
}</code></pre> 
 <p style="text-align:justify;">来看下registerService方法：</p> 
 <pre class="has"><code class="language-go">private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass,
            ServiceFetcher&lt;T&gt; serviceFetcher)</code></pre> 
 <p style="text-align:left;">第三个参数是ServiceFetcher类型对象，实现的createService方法返回了一个WindowManagerImpl对象。</p> 
 <p style="text-align:left;">所以getSystemService方法的<strong>注释1</strong>：fetcher = CachedServiceFetcher对象，且其createService方法返回了一个WindowManagerImpl对象</p> 
 <p style="text-align:left;">回到getSystemService<strong>注释2处</strong>：fetcher.getService(ctx)最终会返回调用到createService方，返回WindowManagerImpl对象。</p> 
 <p style="text-align:left;">继续回到Window的setWindowManager方法的注释2处：</p> 
 <p style="text-align:left;">mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this)，</p> 
 <p style="text-align:left;">进入WindowManagerImpl的createLocalWindowManager方法：</p> 
 <pre class="has"><code class="language-go">public WindowManagerImpl createLocalWindowManager(Window parentWindow) {
    return new WindowManagerImpl(mContext, parentWindow);
}</code></pre> 
 <p style="text-align:left;">这里也是创建了一个WindowManagerImpl，和前面getSystemService创建的WindowManagerImpl区别：这里传入了parentWindow，让WindowManagerImpl持有了Window的引用，可以对此Window进行操作了。</p> 
 <p style="text-align:justify;">总结下Activity的attach方法：</p> 
 <p style="text-align:left;">1. new一个PhoneWindow对象并传入当前Activity引用，建立Window和Activity的一一对应关系。此Window是Window类的子类PhoneWindow的实例。Activity在Window中是以mContext属性存在。</p> 
 <p style="text-align:left;">2. 调用PhoneWindow的setWindowManager方法，在这个方法中让Window和WindowManager建立了一一关系。此WindowManager是WindowManagerImpl的实例、</p> 
 <p style="text-align:justify;">笔者画了一张Window关系类图：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/79/6f/69jpYZ0O_o.png" alt="outside_default.png"></p> 
 <p style="text-align:justify;"><strong>2. Window什么时候和View进行关联？</strong></p> 
 <p style="text-align:justify;">我们来看Activity的setContentView方法</p> 
 <pre class="has"><code class="language-go">public void setContentView(@LayoutRes int layoutResID) {
    getWindow().setContentView(layoutResID);//1
    initWindowDecorActionBar();//2
}</code></pre> 
 <p style="text-align:left;">注释1中的getWindow前面分析了是：PhoneWindow对象 进入PhoneWindow的setContentView方法：</p> 
 <pre class="has"><code class="language-go">public void setContentView(int layoutResID) {
    ...
    if (mContentParent == null) {
        installDecor();//注释1
    } 
    mLayoutInflater.inflate(layoutResID, mContentParent);//注释2
    ...
}

private void installDecor() {
    ...
    if (mDecor == null) {
        mDecor = generateDecor(-1);
    } else {
        mDecor.setWindow(this);
    }
}

protected DecorView generateDecor(int featureId) {
    ...
    return new DecorView(context, featureId, this, getAttributes());
}</code></pre> 
 <p style="text-align:left;">PhoneWindow：setContentView注释1处：创建一个DecorView给当前Window的mDecor。PhoneWindow：setContentView注释2处：解析当前layoutResID为id的xml文件并传递给mContentParent。</p> 
 <p style="text-align:left;"><em>这里的mContentParent其实就是当前Window对应的ContentView。</em></p> 
 <p style="text-align:left;">继续回到Activity的setContentView方法注释2处：initWindowDecorActionBar这里是初始化Window的ActionBar</p> 
 <pre class="has"><code class="language-go">private void initWindowDecorActionBar() {
    Window window = getWindow();

    // Initializing the window decor can change window feature flags.
    // Make sure that we have the correct set before performing the test below.
    window.getDecorView();

    if (isChild() || !window.hasFeature(Window.FEATURE_ACTION_BAR) || mActionBar != null) {
        return;
    }

    mActionBar = new WindowDecorActionBar(this);
    mActionBar.setDefaultDisplayHomeAsUpEnabled(mEnableDefaultActionBarUp);
    ...
}</code></pre> 
 <p style="text-align:left;">通过上面两步骤：我们就给当前Activity的Window创建了一个DecorView，这个DecorView就是当前Window的rootView、并对rootView的ContentView设置了mContentParent 实现了将Window和DecorView绑定。</p> 
 <p style="text-align:left;">如果你够细心，你会发现Activity所有的对View进行的操作几乎都是通过Window进行的。而我们的Activity又是通过AMS来控制生命周期，所以AMS和View的通讯其实就是通过WindowManager这个介子进行的。比如：</p> 
 <pre class="has"><code class="language-go">1.设置主题
public void setTheme(int resid) {
    super.setTheme(resid);
    mWindow.setTheme(resid);
}
2.设置Window属性等
public final boolean requestWindowFeature(int featureId) {
    return getWindow().requestFeature(featureId);
}

3.获取Layout解析器
public LayoutInflater getLayoutInflater() {
    return getWindow().getLayoutInflater();
}</code></pre> 
 <p style="text-align:left;"><strong>3. Window有哪些属性？类型？层级关系？z-order？Window标志？软键盘模式都了解么</strong></p> 
 <p style="text-align:left;">上面我们说过了Window、WindowManager和WMS之间的体系关系，WMS就好比老板，Window就好比员工，老板为了方便管理员工，就给员工定了很多规则.</p> 
 <p style="text-align:left;">这些规则就是Window的属性：<strong>这些属性都定义在WindowManager.LayoutParams类中。</strong></p> 
 <p style="text-align:left;">应用开发中比较常见的，主要有以下几类：</p> 
 <p style="text-align:left;"><strong>1.Window窗口类型（Type）</strong></p> 
 <p style="text-align:left;"><strong>2.Window窗口层级关系（Z-Order）</strong></p> 
 <p style="text-align:left;"><strong>3.Window窗口标志（Flag）</strong></p> 
 <p style="text-align:left;"><strong>4.Window 软键盘模式（SoftInputModel）</strong></p> 
 <p style="text-align:left;">下面我们就分别来讲解下这几种属性</p> 
 <ul><li><p style="text-align:left;"><strong>Window窗口类型（Type）</strong></p></li></ul> 
 <p style="text-align:left;">Window窗口类型有很多种：比如：应用程序窗口，PopupWindow，Toast，Dialog，输入法窗口，系统错误窗口等。总体来说主要分为以下三大类：</p> 
 <p style="text-align:left;"><strong>1.应用程序窗口（Application Window）</strong></p> 
 <p style="text-align:left;"><strong>2.子窗口（Sub Window）</strong></p> 
 <p style="text-align:left;"><strong>3.系统窗口（System Window）</strong></p> 
 <p style="text-align:left;">窗口类型在WindowManager的静态内部类LayoutParams中定义</p> 
 <p style="text-align:justify;"><strong>应用程序窗口</strong></p> 
 <p style="text-align:justify;">应用程序窗口指我们应用程序使用的（非Dialog）界面Window，<strong>如Activity就是一个典型的应用窗口。</strong></p> 
 <pre class="has"><code class="language-go">public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable {
    //应用程序窗口的起始值
    public static final int FIRST_APPLICATION_WINDOW = 1;
    //应用程序窗口的基准值
    public static final int TYPE_BASE_APPLICATION   = 1;
    //标准的应用程序窗口：依附于Activity存在
    public static final int TYPE_APPLICATION        = 2;
    public static final int TYPE_APPLICATION_STARTING = 3;
    public static final int TYPE_DRAWN_APPLICATION = 4;
    //应用程序窗口结束值
    public static final int LAST_APPLICATION_WINDOW = 99;
    ...
}</code></pre> 
 <p style="text-align:justify;">应用程序窗口起始值为1，结束值为99，说明我们应用程序窗口的类型为：1~99. 这个值直接影响了窗口在屏幕中的层级关系，后面再讲。</p> 
 <p style="text-align:justify;"><strong>子窗口</strong></p> 
 <p style="text-align:justify;">子窗口看名字就知道其是一个窗口的子窗口，所以不能独立存在，需要依附于父窗口存在，比如PopupWindow，Dialog等就属于子窗口，子窗口的类型定义如下所示:</p> 
 <pre class="has"><code class="language-go">public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable {
    public static final int FIRST_SUB_WINDOW = 1000;//子窗口类型初始值
    public static final int TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW;
    public static final int TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + 1;
    public static final int TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + 2;
    public static final int TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW + 3;
    public static final int TYPE_APPLICATION_MEDIA_OVERLAY  = FIRST_SUB_WINDOW + 4; 
    public static final int TYPE_APPLICATION_ABOVE_SUB_PANEL = FIRST_SUB_WINDOW + 5;
    public static final int LAST_SUB_WINDOW = 1999;//子窗口类型结束值
    ...
}</code></pre> 
 <p style="text-align:justify;">子窗口的Type值范围为1000到1999.</p> 
 <p style="text-align:justify;"><strong>系统窗口</strong></p> 
 <p style="text-align:justify;">输入法窗口，系统错误提示窗口，Toast等都属于系统窗口，系统窗口的类型定义如下所示：</p> 
 <pre class="has"><code class="language-go">public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable {
    public static final int FIRST_SYSTEM_WINDOW     = 2000;//系统窗口类型初始值
    public static final int TYPE_STATUS_BAR         = FIRST_SYSTEM_WINDOW;//系统状态栏窗口
    public static final int TYPE_SEARCH_BAR         = FIRST_SYSTEM_WINDOW+1;//搜索条窗口
    public static final int TYPE_PHONE              = FIRST_SYSTEM_WINDOW+2;//通话窗口
    public static final int TYPE_SYSTEM_ALERT       = FIRST_SYSTEM_WINDOW+3;//系统ALERT窗口
    public static final int TYPE_KEYGUARD           = FIRST_SYSTEM_WINDOW+4;//锁屏窗口
    public static final int TYPE_TOAST              = FIRST_SYSTEM_WINDOW+5;//TOAST窗口
    ...

    public static final int LAST_SYSTEM_WINDOW      = 2999;//系统窗口类型结束值
}</code></pre> 
 <p style="text-align:justify;">系统窗口的Type值范围为2000到2999。</p> 
 <p style="text-align:left;">对于不同类型的窗口添加过程会有所不同，但是对于WMS处理部分，添加的过程基本上是一样的， WMS对于这三大类的窗口基本是“一视同仁”的。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/57/6d/yFIybM8b_o.png" alt="outside_default.png"></p> 
 <ul><li><p style="text-align:left;"><strong>Window窗口层级关系(Z-Order)</strong></p></li></ul> 
 <p style="text-align:left;">首先我们得有个概念就是窗口是叠加的，可以简单理解为：几页纸按前后顺序叠加在一块。</p> 
 <p style="text-align:left;">我们可以将手机屏幕使用X,Y,Z轴来表示，X,Y表示屏幕的长和宽，而Z轴垂直于屏幕，从屏幕内指向外。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/3a/df/X0Ae2mFJ_o.png" alt="outside_default.png"></p> 
 <p style="text-align:left;">确定窗口的层级关系其实就是确定窗口在Z轴上的位置，这个层级关系就是Z-Order，而Z-Order的排序依据就是前面分析的Window类型值。</p> 
 <p style="text-align:left;">类型值越大，越靠近用户。通过上面分析可知：系统窗口&gt;子窗口&gt;应用程序窗口。这也就是系统窗口会覆盖应用窗口最直接的原因。</p> 
 <p style="text-align:left;">那么如果多个窗口都是应用程序窗口如何显示呢？WMS会结合实际情况，去显示窗口合适的层级。</p> 
 <ul><li><p style="text-align:left;"><strong>Window窗口标志（Flag）</strong></p></li></ul> 
 <p style="text-align:left;">Window Flag用于控制窗口的一些事件：如是否接收触屏事件，窗口显示时是否允许锁屏，窗口可见时屏幕常亮，隐藏窗口等。这里我们列出几个常用的标志：</p> 
 <p style="text-align:left;"><strong>1.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON</strong></p> 
 <p style="text-align:left;">窗口可见时，允许在此窗口锁屏，一般需要结合FLAG_KEEP_SCREEN_ON和FLAG_SHOW_WHEN_LOCKED使用</p> 
 <p style="text-align:left;"><strong>2.FLAG_DIM_BEHIND</strong></p> 
 <p style="text-align:left;">该窗口后面的画面会变模糊，一般会有一个模糊值dimAmount。</p> 
 <p style="text-align:left;"><strong>3.FLAG_NOT_FOCUSABLE</strong></p> 
 <p style="text-align:left;">窗口不能获取焦点，设置这个Flag的同时FLAG_NOT_TOUCH_MODAL也会被设置</p> 
 <p style="text-align:left;"><strong>4.FLAG_NOT_TOUCHABLE</strong></p> 
 <p style="text-align:left;">该窗口获取不到输入事件，不可点击状态。</p> 
 <p style="text-align:left;"><strong>5.FLAG_NOT_TOUCH_MODAL</strong></p> 
 <p style="text-align:left;">在该窗口区域外的触摸事件传递给其他的Window,而自己只会处理窗口区域内的触摸事件</p> 
 <p style="text-align:left;"><strong>6.FLAG_KEEP_SCREEN_ON</strong></p> 
 <p style="text-align:left;">只要窗口可见，屏幕就会一直亮着</p> 
 <p style="text-align:left;"><strong>7.FLAG_LAYOUT_NO_LIMITS</strong></p> 
 <p style="text-align:left;">允许窗口超过屏幕之外</p> 
 <p style="text-align:left;"><strong>8.FLAG_FULLSCREEN</strong></p> 
 <p style="text-align:left;">隐藏所有的屏幕装饰窗口，比如在游戏、播放器中的全屏显示</p> 
 <p style="text-align:left;"><strong>9.FLAG_SHOW_WHEN_LOCKED</strong></p> 
 <p style="text-align:left;">窗口可以在锁屏的窗口之上显示</p> 
 <p style="text-align:left;"><strong>10.FLAG_IGNORE_CHEEK_PRESSES</strong></p> 
 <p style="text-align:left;">当用户的脸贴近屏幕时（比如打电话），不会去响应此事件</p> 
 <p style="text-align:left;"><strong>11.FLAG_TURN_SCREEN_ON</strong></p> 
 <p style="text-align:left;">窗口显示时将屏幕点亮</p> 
 <p style="text-align:left;"><strong>12.FLAG_DISMISS_KEYGUARD</strong></p> 
 <p style="text-align:left;">窗口显示时，键盘会关闭</p> 
 <p style="text-align:left;"><strong>窗口标志Flag的2种设置方式：</strong></p> 
 <p style="text-align:left;">1. 通过Window的addFlags方法</p> 
 <pre class="has"><code class="language-go">Window mWindow =getWindow(); 
mWindow.addFlags(LayoutParams.FLAG_KEEP_SCREEN_ON);</code></pre> 
 <p style="text-align:left;">2. 通过Window的setFlags方法</p> 
 <pre class="has"><code class="language-go">mWindow.setFlags(LayoutParams.FLAG_KEEP_SCREEN_ON,LayoutParams.FLAG_KEEP_SCREEN_ON);</code></pre> 
 <p style="text-align:left;">addFlags方法内部也是调用setFlags</p> 
 <p style="text-align:left;">3.给LayoutParams设置Flag，并通过WindowManager的addView方法进行添加</p> 
 <pre class="has"><code class="language-go">WindowManager.LayoutParams wl = new WindowManager.LayoutParams();
wl.flags = LayoutParams.FLAG_KEEP_SCREEN_ON;
Log.d("TAG","window:"+window.getWindowManager());
WindowManager mWindowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
TextView mTextView=new TextView(this);
mTextView.setText("ttttttttdddddd");
Log.d("TAG","mWindow:"+mWindowManager);
mWindowManager.addView(mTextView,wl);</code></pre> 
 <ul><li><p style="text-align:left;"><strong>Window 软键盘模式（SoftInputModel）</strong></p></li></ul> 
 <p style="text-align:left;">我们的软键盘也是窗口的一种，属于系统窗口，层级较高，所以在一些场景下会覆盖层级较低的应用窗口。</p> 
 <p style="text-align:left;">比如我们的登录场景，如果键盘弹出窗口处理不好，会覆盖输入登录按钮等，这样用户体验会非常糟糕。</p> 
 <p style="text-align:left;">于是WindowManager给我们提供了关于软键盘模式的Window窗口处理方式：</p> 
 <p style="text-align:left;"><strong>1.SOFT_INPUT_STATE_UNSPECIFIED</strong></p> 
 <p style="text-align:left;">没有指定状态,系统会选择一个合适的状态或依赖于主题的设置</p> 
 <p style="text-align:left;"><strong>2.SOFT_INPUT_STATE_UNCHANGED</strong></p> 
 <p style="text-align:left;">不会改变软键盘状态</p> 
 <p style="text-align:left;"><strong>3.SOFT_INPUT_STATE_HIDDEN</strong></p> 
 <p style="text-align:left;">当用户进入该窗口时，软键盘默认隐藏</p> 
 <p style="text-align:left;"><strong>4.SOFT_INPUT_STATE_ALWAYS_HIDDEN</strong></p> 
 <p style="text-align:left;">当窗口获取焦点时，软键盘总是被隐藏</p> 
 <p style="text-align:left;"><strong>5.SOFT_INPUT_ADJUST_RESIZE</strong></p> 
 <p style="text-align:left;">当软键盘弹出时，窗口会调整大小</p> 
 <p style="text-align:left;"><strong>6.SOFT_INPUT_ADJUST_PAN</strong></p> 
 <p style="text-align:left;">当软键盘弹出时，窗口不需要调整大小，要确保输入焦点是可见的</p> 
 <p style="text-align:left;">软键盘模式设置方式：<strong>getWindow().setSoftInputMode</strong></p> 
 <p style="text-align:left;">到这里，我们已经将Window的属性：窗口类型（Type），窗口层级（Z-Order），窗口标志（Flag），软键盘模式（softInputModel)做了一个系统的讲解</p> 
 <p style="text-align:left;"><strong>接下来我们来分析我们的View是如何显示到屏幕上：</strong></p> 
 <p style="text-align:left;"><strong>4.View是如何一步一步添加到屏幕上的？更新？删除呢？</strong></p> 
 <p style="text-align:left;">通过前面我们对WindowManager体系分析知道，我们屏幕中所有的View首先需要经过WindowManager的处理，最后提交给WMS来处理。</p> 
 <p style="text-align:left;">我们先来看WindowManager的父类ViewManager：</p> 
 <pre class="has"><code class="language-go">public interface ViewManager{
    public void addView(View view, ViewGroup.LayoutParams params);
    public void updateViewLayout(View view, ViewGroup.LayoutParams params);
    public void removeView(View view);
}</code></pre> 
 <p style="text-align:left;">ViewManager只提供了三个接口方法：分别对应添加，更新，删除</p> 
 <p style="text-align:left;"><strong>1.addView</strong>：添加一个View到WMS中，第二个参数为当前View的参数。</p> 
 <p style="text-align:left;"><strong>2.updateViewLayout</strong>：更新当前View，第二个参数为需要更新的view参数</p> 
 <p style="text-align:left;"><strong>3.removeView</strong>：删除当前View</p> 
 <p style="text-align:left;">而这几个方法具体实现是在WindowManagerImpl类中（前面分析过） 直接来看WindowManagerImpl的三个对应方法:</p> 
 <pre class="has"><code class="language-go">public final class WindowManagerImpl implements WindowManager{
    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();
    @Override
    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
        applyDefaultToken(params);
        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);
    }

    @Override
    public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
        applyDefaultToken(params);
        mGlobal.updateViewLayout(view, params);
    }    
    @Override
    public void removeView(View view) {
        mGlobal.removeView(view, false);
    }
    ...
}</code></pre> 
 <p style="text-align:left;">可以看到这三个方法都是委托给了WindowManagerGlobal进行处理，这是设计模式中的<strong>桥接模式</strong>。</p> 
 <p style="text-align:left;">进入WindowManagerGlobal中：先分析addView：</p> 
 <pre class="has"><code class="language-go">public void addView(View view, ViewGroup.LayoutParams params,
        Display display, Window parentWindow) {
    ...
    ViewRootImpl root;
    //将params强转为WindowManager.LayoutParams类型
    final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;
    synchronized (mLock) {

        //创建一个ViewRootImpl对象
        root = new ViewRootImpl(view.getContext(), display);
        //给View设置LayoutParams参数
        view.setLayoutParams(wparams);


        //存储view到mViews列表
        mViews.add(view);
        //存储root到mRoots列表
        mRoots.add(root);
        //存储wparams到mParams列表
        mParams.add(wparams);

        // do this last because it fires off messages to start doing things
        try {
            root.setView(view, wparams, panelParentView);
        } catch (RuntimeException e) {
            // BadTokenException or InvalidDisplayException, clean up.
            if (index &gt;= 0) {
                removeViewLocked(index, true);
            }
            throw e;
        }
    }
}</code></pre> 
 <p style="text-align:left;">1.首先创建一个ViewRootImpl对象root。</p> 
 <p style="text-align:left;">2.然后将当前view，当前params以及1中创建的ViewRootImpl对象root分别存储到对应的List列表中，注意这三者的index是一一对应的。</p> 
 <p style="text-align:left;">3.调用root的setView方法</p> 
 <p style="text-align:left;">ViewRootImpl身负了很多职责：</p> 
 <p style="text-align:left;"><strong>1.管理View树，且其是View的根</strong></p> 
 <p style="text-align:left;"><strong>2.触发三大绘制流程：测量，布局，绘制</strong></p> 
 <p style="text-align:left;"><strong>3.输入事件中转站</strong></p> 
 <p style="text-align:left;"><strong>4.管理Surface</strong></p> 
 <p style="text-align:left;"><strong>5.负责与WMS通讯</strong></p> 
 <p style="text-align:left;">我们来看ViewRootImpl的setView方法：</p> 
 <pre class="has"><code class="language-go">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
    ...
    requestLayout();//注释1
    ...
    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mInputChannel);//注释2
    ...
}</code></pre> 
 <p style="text-align:left;">来看setView的注释1：<strong>requestLayout</strong>，屏幕绘制部分</p> 
 <p style="text-align:left;">我们在前面一篇文章<strong>《"一文读懂"系列：Android屏幕刷新机制》</strong>(https://juejin.cn/post/7163858831309537294)已经对原理进行解析过了，这里我们再大概说下: requestLayout内部主要使用垂直同步信号VSync的方式，在收到GPU提供的VSync信号后，会触发View的三大绘制layout，mesure，draw流程... 需要知道完整机制的可以调到原文查看</p> 
 <p style="text-align:left;">这里我们重点来看setView的注释2：<strong>mWindowSession.addToDisplay</strong></p> 
 <p style="text-align:left;">顾名思义：addToDisplay就是将Window添加到屏幕上，如何添加的呢？</p> 
 <p style="text-align:left;">mWindowSession是IWindowSession类型的，它是一个binder对象，用于进程间通讯，IWindowSession是C端代理，在S端使用的是Session类实现。addToDisplay运行在WMS进程中。</p> 
 <pre class="has"><code class="language-go">mWindowSession = WindowManagerGlobal.getWindowSession();
public static IWindowSession getWindowSession() {
    synchronized (WindowManagerGlobal.class) {
        if (sWindowSession == null) {
            try {
                InputMethodManager imm = InputMethodManager.getInstance();
                IWindowManager windowManager = getWindowManagerService();//1
                sWindowSession = windowManager.openSession(//2
                        new IWindowSessionCallback.Stub() {
                                @Override
                                public void onAnimatorScaleChanged(float scale) {
                                        ValueAnimator.setDurationScale(scale);
                                }
                        },
                        imm.getClient(), imm.getInputContext());
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        return sWindowSession;
    }
}</code></pre> 
 <p style="text-align:left;">注释1处：返回一个WMS对象的代理类。在注释2处调用WMS的代理类的openSession方法</p> 
 <p style="text-align:left;">定位到WMS的openSession方法：</p> 
 <pre class="has"><code class="language-go">@Override
public IWindowSession openSession(IWindowSessionCallback callback, IInputMethodClient client,
        IInputContext inputContext) {
    if (client == null) throw new IllegalArgumentException("null client");
    if (inputContext == null) throw new IllegalArgumentException("null inputContext");
    Session session = new Session(this, callback, client, inputContext);
    return session;
}</code></pre> 
 <p style="text-align:left;">可以看到返回的就是一个Session对象。</p> 
 <p style="text-align:left;">所以之前的mWindowSession.addToDisplay方法调用的就是Session类的addToDisplay方法</p> 
 <p style="text-align:left;"><strong>此时已经进入了WMS进程：</strong></p> 
 <pre class="has"><code class="language-go">public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,
        int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets,
        Rect outOutsets, InputChannel outInputChannel) {
    return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,
            outContentInsets, outStableInsets, outOutsets, outInputChannel);
}</code></pre> 
 <p style="text-align:left;">这里的mService = WMS服务，最终又回调到WMS中去了：</p> 
 <p style="text-align:left;">调用WMS的addWindow方法添加Window，在WMS眼里，一切View都是以Window形式存在的， 剩下的工作就交由WMS进行处理了：在WMS中会为这个Window分配Surface，并确定显示层级， 可见负责显示界面的是画布Surface，而不是窗口本身，WMS将他管理的Surface交由SurfaceFlinger处理，SurfaceFlinger将这些Surface合并后放入到buffer中，屏幕会定时从buffer中获取显示数据，显示到屏幕上。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/fc/52/hs6mqshq_o.jpg" alt="df0117e737d60546dcf19f46be7646b8.jpeg"></p> 
 <p style="text-align:left;">同理我们再来分析下View删除流程：</p> 
 <p style="text-align:left;">定位到WindowManagerGlobal的removeView</p> 
 <pre class="has"><code class="language-go">public void removeView(View view, boolean immediate) {
    ...
    synchronized (mLock) {
        int index = findViewLocked(view, true);//1
        View curView = mRoots.get(index).getView();//2
        removeViewLocked(index, immediate);//3
        if (curView == view) {
                return;
        }
        throw new IllegalStateException("Calling with view " + view
                        + " but the ViewAncestor is attached to " + curView);
    }
}
private int findViewLocked(View view, boolean required) {
    final int index = mViews.indexOf(view);
    if (required &amp;&amp; index &lt; 0) {
        throw new IllegalArgumentException("View=" + view + " not attached to window manager");
    }
    return index;
}</code></pre> 
 <p style="text-align:left;">在注释1处获取view在mViews中的索引，在注释2处通过索引获取当前mRoots列表中view。<strong>在注释3处调用removeViewLocked，这个是重点移出方法。</strong></p> 
 <pre class="has"><code class="language-go">private void removeViewLocked(int index, boolean immediate) {
    ...
    boolean deferred = root.die(immediate);
    if (view != null) {
        view.assignParent(null);
        if (deferred) {
                mDyingViews.add(view);
        }
    }
}</code></pre> 
 <p style="text-align:left;">看root.die方法：</p> 
 <pre class="has"><code class="language-go">boolean die(boolean immediate) {
    ...
    //如果是同步移除，则立即调用doDie方法
    if (immediate &amp;&amp; !mIsInTraversal) {
        doDie();
        return false;
    }
    ...
    //异步移除，发出一个msg进行移除
    mHandler.sendEmptyMessage(MSG_DIE);
    return true;
}</code></pre> 
 <p style="text-align:left;">不管是同步还是异步，最终都会调用doDie方法进行移除。 进行doDie方法：</p> 
 <pre class="has"><code class="language-go">void doDie() {
    ...
    synchronized (this) {
        if (mAdded) {
                dispatchDetachedFromWindow();//1
        }
        ..
    }
    WindowManagerGlobal.getInstance().doRemoveView(this);//4
}</code></pre> 
 <p style="text-align:left;">doDie注释1： 这个方法里面做一些对资源销毁的操作：</p> 
 <pre class="has"><code class="language-go">void dispatchDetachedFromWindow() {
    if (mView != null &amp;&amp; mView.mAttachInfo != null) {
        //这里可以看出我们可以在View销毁前，在View的dispatchDetachedFromWindow做一些资源释放操作
        mView.dispatchDetachedFromWindow();
    }

    //销毁硬件渲染线程
    destroyHardwareRenderer();
    //将mView的root置为mull
    mView.assignParent(null);
    mView = null;
    mAttachInfo.mRootView = null;
    //释放当前Surface
    mSurface.release();
    //核心移除View的方法。
    try {
            mWindowSession.remove(mWindow);
    } catch (RemoteException e) {
    }
    //移除同步屏障以及View的绘制task
    unscheduleTraversals();
}</code></pre> 
 <p style="text-align:left;">mWindowSession.remove(mWindow)</p> 
 <p style="text-align:left;">在addView流程分析过：<strong>mWindowSession是WMS进程中的Session类</strong></p> 
 <p style="text-align:left;">Session.java</p> 
 <pre class="has"><code class="language-go">public void remove(IWindow window) {
    mService.removeWindow(this, window);
}</code></pre> 
 <p style="text-align:left;">在 Session 中直接调用了 WindowManagerService 的 removeWindow(Session session, IWindow client) 方法。</p> 
 <p style="text-align:left;">WindowManagerService</p> 
 <pre class="has"><code class="language-go">public void removeWindow(Session session, IWindow client) {
    synchronized(mWindowMap) {
        // 得到 windowstate 对象
        WindowState win = windowForClientLocked(session, client, false);
        if (win == null) {
            return;
        }
        // 进行移除 window 操作
        removeWindowLocked(win);
    }
}</code></pre> 
 <p style="text-align:left;">先得到 WindowState 对象，再调用 removeWindowLocked 去移除该 WindowState 。而具体的 removeWindowLocked 代码我们在这就不深入了，可以自行研究。</p> 
 <p style="text-align:left;">至此，整个 Window 移除机制也分析完毕了。</p> 
 <p style="text-align:center;">/   总结   /</p> 
 <p style="text-align:left;">本篇文章基于Window模型以及源码对Window在整个Android FrameWork体系中所涉及的知识点以及作用做了一个整体的归纳，篇幅问题，关于WMS中如何对Window的操作放在之后进行讲解。</p> 
 <p>推荐阅读：</p> 
 <p><a href="" rel="nofollow">我的新书，《第一行代码 第3版》已出版！</a><br></p> 
 <p><a href="" rel="nofollow">Kotlin Flow响应式编程，StateFlow和SharedFlow</a><br></p> 
 <p><a href="" rel="nofollow">深入探究Kotlin的可见性控制，从internal入手</a><br></p> 
 <p style="text-align:center;">欢迎关注我的公众号</p> 
 <p style="text-align:center;">学习技术或投稿</p> 
 <p><img src="https://images2.imgbox.com/bc/cc/BBaRywE7_o.png" alt="outside_default.png"></p> 
 <p style="text-align:center;"><img height="123" width="123" src="https://images2.imgbox.com/43/4f/whsDMt0B_o.png" alt="03969ff3cdbb1646dbb0b9d773c9b3bf.jpeg"></p> 
 <p style="text-align:center;">长按上图，识别图中二维码即可关注</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9f4781ea17c7665b14c447ecb1cba8ce/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">拉取私有仓库镜像配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e6335a451d6f5068e66b46a503df659a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">写入性能：TDengine 最高达到 InfluxDB 的 10.3 倍，TimeScaleDB 的 6.74 倍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>