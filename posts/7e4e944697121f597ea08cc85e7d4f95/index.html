<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言基础知识总结 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言基础知识总结" />
<meta property="og:description" content="一、数值类型 1.各种进制之间的转换：（二进制，八进制，十进制，十六进制） 1）对于应用程序，数据参与计算的都是以十进制执行的，故数据类型定义的都是十进制的； 2）对于底层都是以二进制（因为十六进制易于读取，两者易于转换）呈现的； 3）对于二进制、八进制、十六进制，其没有对应的数据类型来展现，故只能以字符的形式保存。 2.各种定义数值的处理：（质数，素数，奇数，偶数，丑数等等） 1）质素(素数) 1&gt;题型1：打印1-N内所有质数 /* 1.判别该数是否为质数 */ bool isPrime(int n) { if(n == 2 || n == 3) { return true; } for(int i = 2; i &lt;= n/2; i&#43;&#43;) { if(n % i == 0) { return false; } } return true; } /* 2.循环遍历每一个小于N的数 */ vector&lt;int&gt; arr; for(int i = 2; i &lt; n; i&#43;&#43;) { if(isPrime(i)) { arr.push_back(i); } } 2&gt;题型2：打印N的质素 vector&lt;int&gt; arr; for(int i = 2; i &lt; n;) { if(n % i == 0) { arr." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/7e4e944697121f597ea08cc85e7d4f95/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-08-11T19:54:26+08:00" />
<meta property="article:modified_time" content="2016-08-11T19:54:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言基础知识总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div></div> 一、数值类型 
<br> 
<span style="white-space:pre"></span>1.各种进制之间的转换：（二进制，八进制，十进制，十六进制） 
<br> 
<span style="white-space:pre"></span>1）对于应用程序，数据参与计算的都是以十进制执行的，故数据类型定义的都是十进制的； 
<br> 
<span style="white-space:pre"></span>2）对于底层都是以二进制（因为十六进制易于读取，两者易于转换）呈现的； 
<br> 
<span style="white-space:pre"></span>3）对于二进制、八进制、十六进制，其没有对应的数据类型来展现，故只能以字符的形式保存。 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>2.各种定义数值的处理：（质数，素数，奇数，偶数，丑数等等） 
<br> 
<span style="white-space:pre"></span>1）质素(素数) 
<br> 
<span style="white-space:pre"></span>1&gt;题型1：打印1-N内所有质数 
<br> 
<span style="white-space:pre"></span>/* 1.判别该数是否为质数 */ 
<br> 
<span style="white-space:pre"></span>bool isPrime(int n) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>if(n == 2 || n == 3) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>return true; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>for(int i = 2; i &lt;= n/2; i++) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>if(n % i == 0) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>return false; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>return true; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>/* 2.循环遍历每一个小于N的数 */ 
<br> 
<span style="white-space:pre"></span>vector&lt;int&gt; arr; 
<br> 
<span style="white-space:pre"></span>for(int i = 2; i &lt; n; i++) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>if(isPrime(i)) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>arr.push_back(i); 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>2&gt;题型2：打印N的质素 
<br> 
<span style="white-space:pre"></span>vector&lt;int&gt; arr; 
<br> 
<span style="white-space:pre"></span>for(int i = 2; i &lt; n;) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>if(n % i == 0) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>arr.push_back(i); 
<br> 
<span style="white-space:pre"></span>n = n / i; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>else 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>i++; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>2）奇偶数 
<br> 
<span style="white-space:pre"></span>3）丑数 
<br> 
<span style="white-space:pre"></span>4）求前N个数的和的时间复杂度为o(n)方法 
<br> 
<span style="white-space:pre"></span>注：采用的方式是直接替换头和尾，如果采用双层循环，时间复杂度就为o(n2) 
<br> 
<span style="white-space:pre"></span>for(int j = 0; j &lt; c; j++){ 
<br> 
<span style="white-space:pre"></span>                
<br> 
<span style="white-space:pre"></span>           num += arr[j];            
<br> 
<span style="white-space:pre"></span>       } 
<br> 
<span style="white-space:pre"></span>       if(num &lt;= t){ 
<br> 
<span style="white-space:pre"></span>                
<br> 
<span style="white-space:pre"></span>               count++; 
<br> 
<span style="white-space:pre"></span>       } 
<br> 
<span style="white-space:pre"></span>       for(int k = c; k &lt; n; k++){ 
<br> 
<span style="white-space:pre"></span>                
<br> 
<span style="white-space:pre"></span>num -= arr[k - c]; 
<br> 
<span style="white-space:pre"></span>           num += arr[k]; 
<br> 
<span style="white-space:pre"></span>           if(num &lt;= t){ 
<br> 
<span style="white-space:pre"></span>                
<br> 
<span style="white-space:pre"></span>               count++; 
<br> 
<span style="white-space:pre"></span>           } 
<br>         } 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>3.结构体定义的使用 
<br> 
<span style="white-space:pre"></span>1）struct node 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span> 
<span style="white-space:pre"></span>int num; 
<br> 
<span style="white-space:pre"></span> 
<span style="white-space:pre"></span>struct node *next; 
<br> 
<span style="white-space:pre"></span>}; 
<br> 
<span style="white-space:pre"></span>此时定义node结构体变量时，必须写成struct node *nod； 
<br> 
<span style="white-space:pre"></span>2）typedef struct node 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span> 
<span style="white-space:pre"></span>int num; 
<br> 
<span style="white-space:pre"></span> 
<span style="white-space:pre"></span>struct node *next; 
<br> 
<span style="white-space:pre"></span>}node; 
<br> 
<span style="white-space:pre"></span>此时定义node结构体变量时，可以写成node *nod； 
<br> 
<span style="white-space:pre"></span>同时必须注意后面必须加上冒号，这是一个语句。 
<br> 
<span style="white-space:pre"></span> 
<br> 二、字符串处理 
<br> 
<span style="white-space:pre"></span>1.字符串的定义： 
<br> 
<span style="white-space:pre"></span>1）char str1[] = "HelloWorld";  // 通过字符数组来定义字符串"HelloWorld"，其实包含两个存储空间：1.首先是在栈去分配了一段存储空间，用来存储字符串；2.同时此常量字符串存储在静态数据区。 
<br> 
<span style="white-space:pre"></span>2）char *str2  = "HelloWorld";  // 通过字符指针来定义字符串"HelloWorld"，其也包含两个存储空间：1.首先是在栈上为指针分配存储空间，用来存放指针变量；2.同时常量字符串存储在静态数据区。 
<br> 
<span style="white-space:pre"></span> 3）#define str3 "HelloWorld";   // 通过宏定义来定义字符串"HelloWorld"，等价于str3="HelloWorld" 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>2.字符串的输入： 
<br> 
<span style="white-space:pre"></span>1）常规字串输入： 
<br> 
<span style="white-space:pre"></span>1&gt;采用scanf()函数实现输入操作：必须要取地址，将字符串存入地址中；其不能识别空格，tab等按键。 
<br> 
<span style="white-space:pre"></span>2）带空格的字串输入 
<br> 
<span style="white-space:pre"></span> 1&gt;采用gets()函数实现输入操作：可以识别空格和tab等按键；其变量只要是地址名字即可，不要写成取地址的方式； 
<br> 
<span style="white-space:pre"></span> 2&gt;由于scanf()输入字符串时默认空格作为结束符，故要输入带有空格的字符串时，采用以下格式：scanf("%[^\n]",str)。 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>3.字符串的输出： 
<br> 
<span style="white-space:pre"></span>1）常规字串输出 
<br> 
<span style="white-space:pre"></span>1&gt;printf("%s",a[i]);  它的输出是从a中第i号字符开始输出，直到字符串结束符'\0'输出结束。 
<br> 
<span style="white-space:pre"></span>2）固定长度字串输出：须知字串长度，采用循环输出 
<br> 
<span style="white-space:pre"></span>3）带空格字串输出：须知字串长度，采用循环输出 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>4.字符串作为参数传递： 
<br> 
<span style="white-space:pre"></span> 1）传递的是地址，数组也是一样，传递的是地址； 
<br> 
<span style="white-space:pre"></span> 2）对于结构体变量而言，要操作结构内部变量，必须根据地址来操作； 
<br> 
<span style="white-space:pre"></span> 3）操作数的位数最大为64位，故要实现结构体的单位操作，必须重新编写操作函数。 
<br> 
<span style="white-space:pre"></span>  
<br> 
<span style="white-space:pre"></span>5.字符串函数的使用：字符串函数大全见：附录1：字符串函数大全 
<br> 
<span style="white-space:pre"></span>1）将字符串转换成数值； 
<br> 
<span style="white-space:pre"></span>1&gt;实现方式一 
<br> 
<span style="white-space:pre"></span>double atoi(int n,char* str) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>int len=n; 
<br> 
<span style="white-space:pre"></span>double num=0;   
<span style="white-space:pre"></span>//定义变量时，一定要初始化 
<br> 
<span style="white-space:pre"></span>for(int i=0;i&lt;len;i++) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>num+=(str[i]-'0')*pow(10.0,--len);   //pow（）函数返回的是double型，故num必须定义为double型，或者对pow（）函数进行强制类型转换 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>return num; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>2&gt;实现方式二 
<br> 
<span style="white-space:pre"></span>double atoi(int n,char* str) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>int len=n; 
<br> 
<span style="white-space:pre"></span>double num=0;   
<span style="white-space:pre"></span>//定义变量时，一定要初始化 
<br> 
<span style="white-space:pre"></span>for(int i=0;i&lt;len;i++) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>num=num*10+str[i]-'0'； 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>return num; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>问题：1.为什么要减去'0'? 
<br> 
<span style="white-space:pre"></span>曰：计算器存储运算时，均采用的是二进制表示，故对于所有的字母和常用符号，必须约定自己的一套编码规则，于是ASCII码应运而生。而特别是对于数字，ASCII和整型之间相差的数值是48，即一个'0'字符。 
<br> 
<span style="white-space:pre"></span>而对于ASCII和数值其显示结果是没有任何区别的，即对于显示，其采用的二进制数值是一样的，而两者的不同，主要在于应用运算上的不同，此时的值也是不同的。 
<br> 
<span style="white-space:pre"></span>2.当数值超过double的范围时，即大数怎么处理？ 
<br> 
<span style="white-space:pre"></span>曰：此时只能做简单的显示，如果是要做运算，必须采用字符的形式来重新进行运算法则的编写。 
<br> 
<span style="white-space:pre"></span>2）将数值转换成字符串 
<br> 
<span style="white-space:pre"></span>1&gt;实现方式一 
<br> 
<span style="white-space:pre"></span>char* itoa(int m,char *a) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>int i; 
<br> 
<span style="white-space:pre"></span>while(m&gt;0) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>a[i++]=m%10+'0'; 
<br> 
<span style="white-space:pre"></span>m/=10; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>return a; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>2&gt;实现方式二 
<br> 
<span style="white-space:pre"></span>char* itoa(int m,char *a) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>char b[11]="0123456789"; 
<br> 
<span style="white-space:pre"></span>int i=0; 
<br> 
<span style="white-space:pre"></span>scanf("%d",&amp;m); 
<br> 
<span style="white-space:pre"></span>while(m&gt;0) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>a[i++]=b[m%10]; 
<br> 
<span style="white-space:pre"></span>m/=10; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>return a; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>6.字符串数组的操作 
<br> 
<span style="white-space:pre"></span>1&gt;在C++中string可以直接当做变量来处理； 
<br> 
<span style="white-space:pre"></span>2&gt;可以通过new string[n]来申请器长度； 
<br> 
<span style="white-space:pre"></span>3&gt;对于string字符串的传递可以跟变量的传递一样操作； 
<br> 
<span style="white-space:pre"></span>4&gt;具体实现如下： 
<br> 
<span style="white-space:pre"></span>int stringPrint(int num,const string str[]) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>for(int i = 0; i &lt; num; i++) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>cout &lt;&lt; str[i] &lt;&lt; endl; 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>return 0; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>int mian(void) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>int num; 
<br> 
<span style="white-space:pre"></span>string* p; 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>cin &gt;&gt; num; 
<br> 
<span style="white-space:pre"></span>p = new string[num]; 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>for(int i = 0; i &lt; num; i++) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>cin &gt;&gt; p[i]; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>stringPrint(num,p); 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>delete []p;  // 对于申请的连续地址空间释放时一定要注意 
<br> 
<span style="white-space:pre"></span>return 0; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 三、数据结构 
<br> 
<span style="white-space:pre"></span>1.数组 
<br> 
<span style="white-space:pre"></span>1）数组定义：数组定义时，必须指定大小，从而编译器为其分配固定大小的内存空间，内存连续分配； 
<br> 
<span style="white-space:pre"></span>2）数组初始化：最好为其初始化，如果没有初始化，其会保存垃圾数据； 
<br> 
<span style="white-space:pre"></span>3）数组的输入：数组实现数据输入时，一般采用循环输入； 
<br> 
<span style="white-space:pre"></span>4）数组的输出：输出一般也采用循环输出； 
<br> 
<span style="white-space:pre"></span>5）数组作为参数传递： 
<br> 
<span style="white-space:pre"></span>1&gt;数组做参数，无法按值传递。这是由C/C++函数的实现机制决定的。 
<br> 
<span style="white-space:pre"></span>2&gt;传数组给一个函数，数组类型自动转换为指针类型，因而传的实际是地址,因此对其进行操作时，可以对数组值进行修改。所以为了避免数组值的修改，应该使用const固定。 
<br> 
<span style="white-space:pre"></span>下面三种函数声明完全等同： 
<br> 
<span style="white-space:pre"></span>void func(const int array[10]) 
<br> 
<span style="white-space:pre"></span>void func(const int array[]) 
<br> 
<span style="white-space:pre"></span>void func(const int *array) 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>2.链表 
<br> 
<span style="white-space:pre"></span>1）定义：一种物理存储单元上非连续、非顺序的存储结构。 
<br> 
<span style="white-space:pre"></span> 2）优势： 
<br> 
<span style="white-space:pre"></span>1&gt;不定长，可以根据数据存储需要，不断添加和删除； 
<br> 
<span style="white-space:pre"></span>2&gt;存储空间不用连续。 
<br> 
<span style="white-space:pre"></span>3)链表的一般操作： 
<br> 
<span style="white-space:pre"></span>1）链表的创建： 
<br> 
<span style="white-space:pre"></span>a.创建一个新节点node 
<br> 
<span style="white-space:pre"></span>nod=(node*)malloc(sizeof(node)); 
<br> 
<span style="white-space:pre"></span>nod-&gt;val=val; 
<br> 
<span style="white-space:pre"></span>nod-&gt;next=NULL; 
<br> 
<span style="white-space:pre"></span>/* 判断内存分配是否为空 */ 
<br> 
<span style="white-space:pre"></span>if(nod==NULL) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>return 0; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>b.头指针head，用于对单向链表的遍历,该地址指向链表的头部 
<br> 
<span style="white-space:pre"></span>if(head=NULL) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>head=nod; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>c.位置指针p，保存指针位置 
<br> 
<span style="white-space:pre"></span>else 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>p-&gt;next=nod; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>p=nod; 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>2）链表的插入： 
<br> 
<span style="white-space:pre"></span>a.对于单向链表，先从头开始遍历，找到要操作节点的前一个节点 
<br> 
<span style="white-space:pre"></span>node* listInsert(node* head,int k) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>int i=2; 
<br> 
<span style="white-space:pre"></span>node* p=NULL; 
<br> 
<span style="white-space:pre"></span>node* nod=NULL; 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>p=head; 
<br> 
<span style="white-space:pre"></span>nod=(node*)malloc(sizeof(node)); 
<br> 
<span style="white-space:pre"></span>nod-&gt;val=val; 
<br> 
<span style="white-space:pre"></span>nod-&gt;next=NULL; 
<br> 
<span style="white-space:pre"></span>/* 输入查询节点数必须大于0 */ 
<br> 
<span style="white-space:pre"></span>if(k&lt;1) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>return NULL; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>/* 当输入为1时，查询的是头节点 */ 
<br> 
<span style="white-space:pre"></span>if(k==1) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>nod-&gt;next=p; 
<br> 
<span style="white-space:pre"></span>head=nod; 
<br> 
<span style="white-space:pre"></span>return head; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>while(p!=NULL&amp;i&lt;k) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>p=p-&gt;next; 
<br> 
<span style="white-space:pre"></span>i++; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>nod-&gt;next=p-&gt;next; 
<br> 
<span style="white-space:pre"></span>p-next=nod; 
<br> 
<span style="white-space:pre"></span>return head; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>3）链表的删除： 
<br> 
<span style="white-space:pre"></span>node* listDelete(node* head,int k) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>int i=2; 
<br> 
<span style="white-space:pre"></span>node* p=NULL; 
<br> 
<span style="white-space:pre"></span>node* q=NULL; 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>p=head; 
<br> 
<span style="white-space:pre"></span>/* 输入查询节点数必须大于0 */ 
<br> 
<span style="white-space:pre"></span>if(k&lt;1) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>return NULL; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>/* 当输入为1时，查询的是头节点 */ 
<br> 
<span style="white-space:pre"></span>if(k==1) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>head=nod-&gt;next; 
<br> 
<span style="white-space:pre"></span>free(p); 
<br> 
<span style="white-space:pre"></span>return head; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>/* 开始查询要删除的节点的前一个节点 */ 
<br> 
<span style="white-space:pre"></span>while(p!=NULL&amp;i&lt;k) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>p=p-&gt;next; 
<br> 
<span style="white-space:pre"></span>i++; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>q=p-&gt;next; 
<br> 
<span style="white-space:pre"></span>p-&gt;next=q-&gt;next; 
<br> 
<span style="white-space:pre"></span>free(q); 
<br> 
<span style="white-space:pre"></span>return head; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>4）链表的打印： 
<br> 
<span style="white-space:pre"></span>int listPrint(node* head) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>while(head!=NULL) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>printf("%x--%d",head,head-&gt;val); 
<br> 
<span style="white-space:pre"></span>head=head-&gt;next; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>return 0; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>5）链表的逆序打印 
<br> 
<span style="white-space:pre"></span>1&gt;递归实现 
<br> 
<span style="white-space:pre"></span>int printList1(Node* head) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>if(head != NULL) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>if(head-&gt;next != NULL) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>printList1(head-&gt;next); 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>cout &lt;&lt; head-&gt;val &lt;&lt; "--0x" &lt;&lt; head &lt;&lt; endl; 
<br> 
<span style="white-space:pre"></span>return 0; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>2&gt;堆栈实现 
<br> 
<span style="white-space:pre"></span>int printList2(Node* head) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>stack&lt;Node*&gt; st; 
<br> 
<span style="white-space:pre"></span>while(head != NULL) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>st.push(head); 
<br> 
<span style="white-space:pre"></span>head = head-&gt;next; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>while(!st.empty()) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>cout &lt;&lt; st.top()-&gt;val &lt;&lt; "--0x" &lt;&lt; st.top() &lt;&lt; endl; 
<br> 
<span style="white-space:pre"></span>st.pop(); 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>return 0; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>6）链表的逆序实现 
<br> 
<span style="white-space:pre"></span>Node* ReverseLink(Node* head) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>    Node* prev = NULL; 
<br> 
<span style="white-space:pre"></span>Node* next; 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>while(head != NULL) 
<br> 
<span style="white-space:pre"></span>{ 
<span style="white-space:pre"> </span> 
<br> 
<span style="white-space:pre"></span>next = head-&gt;next; 
<br> 
<span style="white-space:pre"></span>head-&gt;next = prev; 
<br> 
<span style="white-space:pre"></span>prev = head; 
<br> 
<span style="white-space:pre"></span>head = next; 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>    return prev; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>4.要及时释放内存空间，malloc()和free()两个函数要配合使用。 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>3.栈 
<br> 
<span style="white-space:pre"></span>1）定义：先进后出,限定只能在表的一端进行插入和删除操作的线性表; 
<br> 
<span style="white-space:pre"></span>2）线性表分类： 
<br> 
<span style="white-space:pre"></span> 1&gt;顺序线性表 (也就是用数组实现的,在内存中顺序排列,通过改变数组序号来实现压栈和出栈) 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>a.定义一个结构体,保存栈的基本信息 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>typedef struct sqStack 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>{ 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>int size; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>int* sp; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>int* top; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>}sqStack; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>b.栈初始化，定义栈的大小和指针 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>int stackInit(sqStack s) 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>{ 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>s-&gt;top=(int*)malloc(sizeof(int)*n); 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>s-&gt;sp=s-&gt;top; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>} 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>c.压栈 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>int push(sqStack* s,int val) 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>{ 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>s-&gt;val=val; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>s-&gt;sp++; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>return 0; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>} 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>d.出栈 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>int pop(sqStack* s) 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>{ 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>int val=0; 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>s-&gt;sp--; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>val=s-&gt;val; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>return val; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>} 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span> 
<br> 
<span style="white-space:pre"></span> 2&gt;链表 (主要是对链表表头进行操作) 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>a.定义一个结构体,作为栈的节点 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>typedef struct sqStack 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>{ 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>int val; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>struct sqStack* next; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>}sqStack; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>b.栈初始化 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>sqStack* stackInit() 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>{ 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>sqStack* s; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>return s; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>} 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>c.压栈 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>sqStack* push(sqStack* s,int val) 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>{ 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>sqStack* nod=NULL; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>nod=(sqStack*)malloc(sizeof(sqStack)); 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>if(nod==NULL) 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>{ 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>return NULL; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>} 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>nod-&gt;val=val; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>nod-&gt;next=s; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>s=nod; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>return s; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>} 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>d.出栈 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>sqStack* pop(sqStack* s) 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>{ 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>sqStack* nod=NULL; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>int val=0; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span> 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>val=s-&gt;val; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>nod=s; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>s=s-&gt;next; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>free(nod); 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>return val; 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>} 
<br> 
<span style="white-space:pre"></span>3&gt;栈的实现：可以采用两种方式，可以分别采用顺序表或者链表实现。 
<br> 
<span style="white-space:pre"></span>4&gt;应用： 
<br> 
<span style="white-space:pre"></span>a.四则运算 
<br> 
<span style="white-space:pre"></span>b.符号检测 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>4.队列 
<br> 
<span style="white-space:pre"></span>1）定义：先进先出,限定只能在表的一端进行插入和在另一端进行删除操作的线性表; 
<br> 
<span style="white-space:pre"></span>2）队列的实现：可以采用两种方式，可以分别采用顺序表或者链表实现。 
<br> 
<span style="white-space:pre"></span>3）应用： 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>5.二叉树 
<br> 
<span style="white-space:pre"></span>1）基本概念： 
<br> 
<span style="white-space:pre"></span>1&gt;定义：每个结点最多有两棵子树，左子树和右子树，次序不可以颠倒 
<br> 
<span style="white-space:pre"></span>2&gt;性质： 
<br> 
<span style="white-space:pre"></span>a.非空二叉树的第n层上至多有2^(n-1)个元素 
<br> 
<span style="white-space:pre"></span>b.深度为h的二叉树至多有2^h-1个结点 
<br> 
<span style="white-space:pre"></span>3&gt;其他概念： 
<br> 
<span style="white-space:pre"></span>a.满二叉树： 
<br> 
<span style="white-space:pre"></span>b.完全二叉树： 
<br> 
<span style="white-space:pre"></span>2）存储结构 
<br> 
<span style="white-space:pre"></span>1&gt;顺序存储：将数据结构存在一块固定的数组中 
<br> 
<span style="white-space:pre"></span>#define LENGTH 100   
<br> 
<span style="white-space:pre"></span>typedef char datatype;   
<br> 
<span style="white-space:pre"></span>typedef struct node 
<br> 
<span style="white-space:pre"></span>{   
<br> 
<span style="white-space:pre"></span>    
<span style="white-space:pre"> </span>datatype data;   
<br> 
<span style="white-space:pre"></span>    
<span style="white-space:pre"> </span>int lchild,rchild;   
<br> 
<span style="white-space:pre"></span>    
<span style="white-space:pre"> </span>int parent;   
<br> 
<span style="white-space:pre"></span>}Node;     
<br> 
<span style="white-space:pre"></span>Node tree[LENGTH];   
<br> 
<span style="white-space:pre"></span>int length;   
<br> 
<span style="white-space:pre"></span>int root;  
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>2&gt;链式存储： 
<br> 
<span style="white-space:pre"></span>typedef char datatype;   
<br> 
<span style="white-space:pre"></span>typedef struct BinNode 
<br> 
<span style="white-space:pre"></span>{   
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"></span>datatype data;   
<br> 
<span style="white-space:pre"></span>    
<span style="white-space:pre"> </span>struct BinNode* lchild;   
<br> 
<span style="white-space:pre"></span>    
<span style="white-space:pre"> </span>struct BinNode* rchild;   
<br> 
<span style="white-space:pre"></span>}BinNode;   
<br> 
<span style="white-space:pre"></span>typedef BinNode* bintree;          //bintree本身是个指向结点的指针  
<br> 
<span style="white-space:pre"></span>  
<br> 
<span style="white-space:pre"></span>3）二叉树的遍历 
<br> 
<span style="white-space:pre"></span>1&gt;前序遍历：根节点-&gt;左子树-&gt;右子树 
<br> 
<span style="white-space:pre"></span>2&gt;中序遍历：左子树-&gt;根节点-&gt;右子树 
<br> 
<span style="white-space:pre"></span>3&gt;后序遍历：左子树-&gt;右子树-&gt;根节点 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>4）遍历的实现 
<br> 
<span style="white-space:pre"></span>1&gt;递归实现 
<br> 
<span style="white-space:pre"></span>1&gt;二叉树的创建 
<br> 
<span style="white-space:pre"></span>a.创建二叉树节点 
<br> 
<span style="white-space:pre"></span>typedef struct BiTree 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>char chr; 
<br> 
<span style="white-space:pre"></span>struct BiTree* lchild; 
<br> 
<span style="white-space:pre"></span>struct BiTree* rchild; 
<br> 
<span style="white-space:pre"></span>}BiTree; 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>b.创建二叉树 
<br> 
<span style="white-space:pre"></span>BiTree* CreateBiTree() 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>char chr; 
<br> 
<span style="white-space:pre"></span>BiTree* T=NULL; 
<br> 
<span style="white-space:pre"></span>scanf("%c",&amp;chr); 
<br> 
<span style="white-space:pre"></span>if(chr!=' ') 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>T=(BiTree*)malloc(sizeof(BiTree)); 
<br> 
<span style="white-space:pre"></span>if(T==NULL) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>printf("Memory is failed!\n"); 
<br> 
<span style="white-space:pre"></span>return NULL; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>T-&gt;chr=chr; 
<br> 
<span style="white-space:pre"></span>T-&gt;lchild=CreateBiTree(); 
<br> 
<span style="white-space:pre"></span>T-&gt;rchild=CreateBiTree(); 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>return T; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>2&gt;前序遍历 
<br> 
<span style="white-space:pre"></span>int preOlderTraverse(BiTree* T) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>if(T) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>printf("%c",T-&gt;chr); 
<br> 
<span style="white-space:pre"></span>preOlderTraverse(T-&gt;lchild); 
<br> 
<span style="white-space:pre"></span>preOlderTraverse(T-&gt;rchild); 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>return 0; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>3&gt;中序遍历 
<br> 
<span style="white-space:pre"></span>int inOlderTraverse(BiTree* T) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>if(T) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>inOlderTraverse(T-&gt;lchild); 
<br> 
<span style="white-space:pre"></span>printf("%c",T-&gt;chr); 
<br> 
<span style="white-space:pre"></span>inOlderTraverse(T-&gt;rchild); 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>return 0; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>4&gt;后序遍历 
<br> 
<span style="white-space:pre"></span>int postOlderTraverse(BiTree* T) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>if(T) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>postOlderTraverse(T-&gt;lchild); 
<br> 
<span style="white-space:pre"></span>postOlderTraverse(T-&gt;rchild); 
<br> 
<span style="white-space:pre"></span>printf("%c",T-&gt;chr); 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>return 0; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>2&gt;非递归实现 
<br> 
<span style="white-space:pre"></span>1&gt;创建堆栈 
<br> 
<span style="white-space:pre"></span>a.创建节点 
<br> 
<span style="white-space:pre"></span>typedef struct sqStack 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>BiTree* Bt; 
<br> 
<span style="white-space:pre"></span>struct sqStack* sp; 
<br> 
<span style="white-space:pre"></span>}sqStack; 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>b.push()函数实现 
<br> 
<span style="white-space:pre"></span>int push(sqStack** S,BiTree* Bt) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>sqStack* Stack=NULL; 
<br> 
<span style="white-space:pre"></span>Stack=(sqStack*)malloc(sizeof(sqStack)); 
<br> 
<span style="white-space:pre"></span>if(Stack==NULL) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>printf("Memory is failed!\n"); 
<br> 
<span style="white-space:pre"></span>return 0; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>Stack-&gt;Bt=Bt; 
<br> 
<span style="white-space:pre"></span>Stack-&gt;Bt-&gt;lchild=Bt-&gt;lchild; 
<br> 
<span style="white-space:pre"></span>Stack-&gt;Bt-&gt;rchild=Bt-&gt;rchild; 
<br> 
<span style="white-space:pre"></span>Stack-&gt;sp=(*S); 
<br> 
<span style="white-space:pre"></span>(*S)=Stack; 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>return 0; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>c.pop()函数实现 
<br> 
<span style="white-space:pre"></span>BiTree* pop(sqStack** S) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>BiTree* Bt=NULL; 
<br> 
<span style="white-space:pre"></span>sqStack* Stack=NULL; 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>Bt=(*S)-&gt;Bt; 
<br> 
<span style="white-space:pre"></span>Stack=(*S); 
<br> 
<span style="white-space:pre"></span>(*S)=(*S)-&gt;sp; 
<br> 
<span style="white-space:pre"></span>free(Stack); 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>return Bt; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>2&gt;二叉树的创建 
<br> 
<span style="white-space:pre"></span>a.创建二叉树节点 
<br> 
<span style="white-space:pre"></span>typedef struct BiTree 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>char chr; 
<br> 
<span style="white-space:pre"></span>struct BiTree* lchild; 
<br> 
<span style="white-space:pre"></span>struct BiTree* rchild; 
<br> 
<span style="white-space:pre"></span>}BiTree; 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>b.创建二叉树 
<br> 
<span style="white-space:pre"></span>BiTree* CreateBiTree() 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>BiTree* T=NULL; 
<br> 
<span style="white-space:pre"></span>char chr; 
<br> 
<span style="white-space:pre"></span>scanf("%c",&amp;chr); 
<br> 
<span style="white-space:pre"></span>if(chr!='#') 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>T=(BiTree*)malloc(sizeof(BiTree)); 
<br> 
<span style="white-space:pre"></span>if(T==NULL) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>printf("Memroy is failed!\n"); 
<br> 
<span style="white-space:pre"></span>return NULL; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>T-&gt;chr=chr; 
<br> 
<span style="white-space:pre"></span>T-&gt;lchild=CreateBiTree(); 
<br> 
<span style="white-space:pre"></span>T-&gt;rchild=CreateBiTree(); 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>return T; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>3&gt;前序遍历 
<br> 
<span style="white-space:pre"></span>int preOlderVisitBiTree(sqStack* S,BiTree* T) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>if(!T) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>printf("The BiTree is empty!\n"); 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>else 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>while(T||S) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>while(T) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>printf("%c",T-&gt;chr); 
<br> 
<span style="white-space:pre"></span>push(&amp;S,T); 
<br> 
<span style="white-space:pre"></span>T=T-&gt;lchild; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>T=pop(&amp;S); 
<br> 
<span style="white-space:pre"></span>T=T-&gt;rchild; 
<span style="white-space:pre"> </span> 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>return 0; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>4&gt;中序遍历 
<br> 
<span style="white-space:pre"></span>int inOlderVisitBiTree(sqStack* S,BiTree* T) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>if(!T) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>printf("The BiTree is empty!\n"); 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>else 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>while(T||S) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>while(T) 
<br> 
<span style="white-space:pre"></span>{ 
<br> 
<span style="white-space:pre"></span>push(&amp;S,T); 
<br> 
<span style="white-space:pre"></span>T=T-&gt;lchild; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>T=pop(&amp;S); 
<br> 
<span style="white-space:pre"></span>printf("%c",T-&gt;chr); 
<br> 
<span style="white-space:pre"></span>T=T-&gt;rchild; 
<span style="white-space:pre"> </span> 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span>return 0; 
<br> 
<span style="white-space:pre"></span>} 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>5&gt;后序遍历 
<br> 
<span style="white-space:pre"></span> 
<br> 四、排序 
<br> 
<span style="white-space:pre"></span>1.插入排序 
<span style="white-space:pre"> </span> 
<br> 
<span style="white-space:pre"></span>2.希尔排序 
<span style="white-space:pre"> </span> 
<br> 
<span style="white-space:pre"></span>3.冒泡排序 
<span style="white-space:pre"> </span> 
<br> 
<span style="white-space:pre"></span>4.快速排序 
<span style="white-space:pre"> </span> 
<br> 
<span style="white-space:pre"></span>5.选择排序 
<span style="white-space:pre"> </span> 
<br> 
<span style="white-space:pre"></span>6.堆排序 
<span style="white-space:pre"> </span> 
<br> 
<span style="white-space:pre"></span>7.归并排序 
<span style="white-space:pre"> </span> 
<br> 
<span style="white-space:pre"></span>8.基数排序 
<br> 
<br> 
<br> 五、注意事项 
<br> 
<span style="white-space:pre"></span>1.头文件包含问题 
<br> 
<span style="white-space:pre"></span>2.内存分配问题 
<br> 
<span style="white-space:pre"></span> 
<br> 六.简单的编程习惯 
<br> 
<span style="white-space:pre"></span>1）当系统较为复杂时，为了防止头文件被重复引用，应当用 i f ndef / def i ne/ endi f 结构产生预处理块 
<br> 
<span style="white-space:pre"></span>2）当编译器引用了未被初始化的变量，可能导致程序错误。故尽可能在定义变量时初始化该变量 
<br> 
<span style="white-space:pre"></span>3）应当将修饰符 * 和 ＆ 紧靠变量名，避免误解 
<br> 
<span style="white-space:pre"></span>4）常量命名使用全大写；变量的名字应当使用“名词”或者“形容词＋名词”，形式为float oldValue；全局函数的名字应当使用“动词”或者“动词＋名词”（动宾词组），形式为DrawBox(); 
<br> 
<span style="white-space:pre"></span>5）if语句条件的使用： 
<br> 
<span style="white-space:pre"></span>a.布尔变量与零值比较 
<br> 
<span style="white-space:pre"></span>bool flag; 
<br> 
<span style="white-space:pre"></span>if(flag)     
<span style="white-space:pre"></span>//表示flag为真 
<br> 
<span style="white-space:pre"></span>if(!flag)     
<span style="white-space:pre"> </span> //表示flag为假 
<br> 
<span style="white-space:pre"></span>b.整型变量与零值比较 
<br> 
<span style="white-space:pre"></span>int flag; 
<br> 
<span style="white-space:pre"></span>if(flag==0)     //表示flag为真 
<br> 
<span style="white-space:pre"></span>if(flag!=0)     //表示flag为假 
<br> 
<span style="white-space:pre"></span>c.浮点变量与零值比较 
<br> 
<span style="white-space:pre"></span>float flag； 
<br> 
<span style="white-space:pre"></span>if((flag&gt;=-EPSINON) &amp;&amp; (flag&lt;=EPSINON))  //EPSINON是允许的误差精度 
<br> 
<span style="white-space:pre"></span>d.指针变量与零值比较 
<br> 
<span style="white-space:pre"></span>int *p； 
<br> 
<span style="white-space:pre"></span>if(p == NULL) 
<span style="white-space:pre"> </span>//p与NULL显式比较，强调p是指针变量 
<br> 
<span style="white-space:pre"></span>if(p != NULL) 
<br> 
<span style="white-space:pre"></span>6）#defined和const都是定义常量的关键字。const主要是C++新增的，其相对于#defined的好处的是定义的常量有数据类型，同时可以进行调试。 
<br> 
<span style="white-space:pre"></span>7）如果参数是指针，且仅作输入用，则应在类型前加 const ，以防止该指针在函数体内被意外修改。 
<br> 
<span style="white-space:pre"></span>例如： 
<br> 
<span style="white-space:pre"></span>void StringCopy(char *strDestination，const char *strSource); 
<br> 
<span style="white-space:pre"></span>8）return语句不可返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁；如果一定要使用内存，可以定义堆空间，这个不会自动释放，必须认为释放 
<br> 
<span style="white-space:pre"></span>9）内存分配的问题： 
<br> 
<span style="white-space:pre"></span>内存分配的三种方式： 
<br> 
<span style="white-space:pre"></span>a.从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量,常量 
<br> 
<span style="white-space:pre"></span>b.在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 
<br> 
<span style="white-space:pre"></span>c.从堆上分配。亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。 
<br> 
<span style="white-space:pre"></span>内存分配的常见问题： 
<br> 
<span style="white-space:pre"></span>a.内存分配不成功：在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL)或if(p! =NULL)进行防错处理 
<br> 
<span style="white-space:pre"></span>b.使用free或delete释放了内存后，没有将指针设置为 NULL。导致产生“野指针” 
<br> 
<span style="white-space:pre"></span>c.对于调用函数中的指针，跳出之后，指针也被释放了，但为了避免出现问题，最后是释放内存之后最好还是初始化为NULL 
<br> 
<span style="white-space:pre"></span>10）指针和数组 
<br> 
<span style="white-space:pre"></span>a.内容的复制： 
<br> 
<span style="white-space:pre"></span>//数组内容的复制 
<br> 
<span style="white-space:pre"></span>char a[]= "hello"; 
<br> 
<span style="white-space:pre"></span>char b[10]={0}; 
<br> 
<span style="white-space:pre"></span> strcpy(b,a); 
<br> 
<span style="white-space:pre"></span> if(strcmp(b,a)==0) 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>.... 
<br> 
<span style="white-space:pre"></span>//指针内容的复制 
<br> 
<span style="white-space:pre"></span>char a[]= "hello"; 
<br> 
<span style="white-space:pre"></span>char *p; 
<br> 
<span style="white-space:pre"></span>int len=0; 
<br> 
<span style="white-space:pre"></span>len= strlen(a); 
<br> 
<span style="white-space:pre"></span>p=(char *)malloc(sizeof(char)*(len+1)); 
<br> 
<span style="white-space:pre"></span>strcpy(p,a); 
<br> 
<span style="white-space:pre"></span>if(strcmp(p,a)==0) 
<br> 
<span style="white-space:pre"></span>.... 
<br> 
<span style="white-space:pre"></span>b.数组的理解 
<br> 
<span style="white-space:pre"></span>数组也可以理解为一个固定内存大小的变量,故: 
<br> 
<span style="white-space:pre"></span>int a[100]; 
<br> 
<span style="white-space:pre"></span>sizeof(a); 
<br> 
<span style="white-space:pre"></span>计算是是整个数组的大小，但是在对数组进行操作时，由于其他的各种赋值函数都是使用int等进行操作的，故不能直接对数组进行赋值，必须采用strcpy()等函数 
<span style="white-space:pre"></span>  
<br> 
<span style="white-space:pre"></span>11）关于C语言效率的问题 
<br> 
<span style="white-space:pre"></span>a.以空间换时间 
<br> 
<span style="white-space:pre"></span>b.数学方法解决问题，找寻规律 
<br> 
<span style="white-space:pre"></span>c.使用位操作,使用移位运算来代替四则运算 
<br> 
<span style="white-space:pre"></span>d.汇编嵌入 
<br> 
<span style="white-space:pre"></span>12）关于程序时间复杂度的计算 
<br> 
<span style="white-space:pre"></span>a.复杂度与时间效率的关系 
<br> 
<span style="white-space:pre"></span>c &lt; log2n &lt; n &lt; n*log2n &lt; n2 &lt; n3 &lt; 2n &lt; 3n &lt; n! （c是一个常量） 
<br> 
<span style="white-space:pre"></span>|--------------------------|--------------------------|-------------| 
<br> 
<span style="white-space:pre"></span>较好                     一般              较差 
<br> 
<span style="white-space:pre"></span>其中c是一个常量，如果一个算法的复杂度为c 、 log2n 、n 、 n*log2n,那么这个算法时间效率比较高 ,如果是 2n , 3n ,n!,那么稍微大一些的n就会令这个算法不能动了，居于中间的几个则差强人意。 
<br> 
<span style="white-space:pre"></span>b.计算时间复杂度的具体 
<br> 
<span style="white-space:pre"></span>⑴找出算法中的基本语句。算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。 
<br> 　　 
<span style="white-space:pre"> </span>⑵计算基本语句的执行次数的数量级。只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。 
<br> 　　 
<span style="white-space:pre"> </span>⑶用大Ο记号表示算法的时间性能。将基本语句执行次数的数量级放入大Ο记号中。 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>13）关于volatile关键字的理解 
<br> 
<span style="white-space:pre"></span>a.对于volatile类型的变量，系统每次用到他的时候都是直接从对应的内存当中提取，而不会利用cache当中的原有数值（或者采用寄存器中的值），以适应它的未知何时会发生的变化，系统对这种变量的处理不会做优化——显然也是因为它的数值随时都可能变化的情况。 
<br> 
<span style="white-space:pre"></span>b.一般说来，volatile用在如下的几个地方： 
<br> 
<span style="white-space:pre"></span>1&gt;中断服务程序中修改的供其它程序检测的变量需要加volatile； 
<br> 
<span style="white-space:pre"></span>2&gt;多任务环境下各任务间共享的标志应该加volatile； 
<br> 
<span style="white-space:pre"></span>3&gt;存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义； 
<br> 
<span style="white-space:pre"></span>另外，以上这几种情况经常还要同时考虑数据的完整性（相互关联的几个标志读了一半被打断了重写），在1中可以通过关中断来实现，2 中可以禁止任务调度，3中则只能依靠硬件的良好设计了。 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span> 
<div></div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/54055f0a842fda4027cf4c40c32d1d9c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">unity中关于rigidbody成员AddForce方法和AddTorque方法介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fc2534f5145d943d4ee05d14fa630694/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux misc设备驱动理解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>