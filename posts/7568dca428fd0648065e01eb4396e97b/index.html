<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java基础 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java基础" />
<meta property="og:description" content="1、@RestController @Controller相同点和不同点 @RestController和@Controller是Spring MVC中用于创建web控制器的两个核心注解，它们在定义控制器时有着不同的用途和行为。以下是它们的主要相似之处和区别：
相同点 组件扫描：两者都会被 Spring 的组件扫描机制识别，这意味着当你在类上使用这些注解时，Spring 会在启动时自动注册这些类作为 Spring 应用上下文中的 Bean。请求映射：两者都可以配合@RequestMapping或其派生的注解（如@GetMapping, @PostMapping等）来处理特定的HTTP请求。依赖注入：都可以利用Spring的依赖注入特性，比如通过@Autowired注入所需的依赖。 不同点 响应体处理：@RestController是@Controller和@ResponseBody注解的组合。在@RestController中，每个方法都隐含地定义为返回一个响应体，这意味着它会自动进行消息转换。而在@Controller注解中，你需要指定@ResponseBody来表明方法的返回结果应该直接写入HTTP响应体中，而不是被解析为跳转路径。用途： @Controller通常用于传统的MVC控制器，其中方法返回的是视图名称（例如JSP页面的路径），而视图负责渲染模型数据。@RestController用于创建RESTful控制器，它返回的对象数据直接写入HTTP响应体，通常用于构建API。这意味着你通常不会从@RestController方法返回视图名称。 消息转换：由于@RestController的方法默认加上了@ResponseBody，因此返回的对象会自动转换为JSON或XML等。在@Controller中，你需要指定@ResponseBody（或使用@RestControllerAdvice）来实现相同的效果。 源码级别的区别 @RestController的定义如下：
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Controller @ResponseBody public @interface RestController { @AliasFor(annotation = Controller.class) String value() default &#34;&#34;; } 如你所见，@RestController内部标注了@Controller和@ResponseBody，这意味着它继承了这两个注解的特性。
而@Controller的定义如下：
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Component public @interface Controller { @AliasFor(annotation = Component.class) String value() default &#34;&#34;; } @Controller被标注为一个常规的组件，但没有指定返回值的处理方式，因此你需要使用@ResponseBody或返回一个视图名称。
总结 在Spring MVC中，你会根据应用的不同需求选择使用@Controller或@RestController。如果你正在构建一个HTML界面，可能会选择@Controller来返回视图。而如果你在构建一个服务于客户端如移动应用、前端框架（如React或Angular）的后端API，那么@RestController会是一个更好的选择，因为它默认返回JSON或XML响应。
Java中每一个对象都可以作为锁，这是synchronized实现同步的基础 普通同步方法（实例方法），锁是当前实例对象 ，进入同步代码前要获得当前实例的锁
静态同步方法，锁是当前类的class对象 ，进入同步代码前要获得当前类对象的锁
同步方法块，锁是括号里面的对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。
2、springboot starter机制 Spring Boot的Starter机制是其核心特性之一，旨在简化依赖管理和自动配置，以便快速启动和运行Spring应用程序。Starter依赖是预定义的依赖集合，这些集合帮助你在项目中包含所需的Spring及相关技术的库。
Starter的特点 依赖传递：每个Starter都是一个Maven项目，它包含了需要启动某个功能所需的依赖库。当你在项目中包含一个Starter时，这个Starter相关的依赖也会被传递性地添加到你的项目中。自动配置：Spring Boot会利用Starter中包含的依赖来提供自动配置。这通常是通过@Configuration类实现的，该类中定义了条件化的Bean声明，只有在特定条件满足时这些Bean才会被创建。约定优于配置：使用Starter时，Spring Boot会提供一组默认配置，这些通常是基于约定的最佳实践。你可以通过在application." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/7568dca428fd0648065e01eb4396e97b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-17T18:46:06+08:00" />
<meta property="article:modified_time" content="2023-12-17T18:46:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java基础</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="font_size4_colorFF00001RestController_Controllerfont_1"></a><font size="4" color="##FF0000">1、@RestController @Controller相同点和不同点</font></h3> 
<p><code>@RestController</code>和<code>@Controller</code>是Spring MVC中用于创建web控制器的两个核心注解，它们在定义控制器时有着不同的用途和行为。以下是它们的主要相似之处和区别：</p> 
<h4><a id="_4"></a>相同点</h4> 
<ul><li><strong>组件扫描</strong>：两者都会被 Spring 的组件扫描机制识别，这意味着当你在类上使用这些注解时，Spring 会在启动时自动注册这些类作为 Spring 应用上下文中的 Bean。</li><li><strong>请求映射</strong>：两者都可以配合<code>@RequestMapping</code>或其派生的注解（如<code>@GetMapping</code>, <code>@PostMapping</code>等）来处理特定的HTTP请求。</li><li><strong>依赖注入</strong>：都可以利用Spring的依赖注入特性，比如通过<code>@Autowired</code>注入所需的依赖。</li></ul> 
<h4><a id="_9"></a>不同点</h4> 
<ul><li><strong>响应体处理</strong>：<code>@RestController</code>是<code>@Controller</code>和<code>@ResponseBody</code>注解的组合。在<code>@RestController</code>中，每个方法都隐含地定义为返回一个响应体，这意味着它会自动进行消息转换。而在<code>@Controller</code>注解中，你需要指定<code>@ResponseBody</code>来表明方法的返回结果应该直接写入HTTP响应体中，而不是被解析为跳转路径。</li><li><strong>用途</strong>： 
  <ul><li><code>@Controller</code>通常用于传统的MVC控制器，其中方法返回的是视图名称（例如JSP页面的路径），而视图负责渲染模型数据。</li><li><code>@RestController</code>用于创建RESTful控制器，它返回的对象数据直接写入HTTP响应体，通常用于构建API。这意味着你通常不会从<code>@RestController</code>方法返回视图名称。</li></ul> </li><li><strong>消息转换</strong>：由于<code>@RestController</code>的方法默认加上了<code>@ResponseBody</code>，因此返回的对象会自动转换为JSON或XML等。在<code>@Controller</code>中，你需要指定<code>@ResponseBody</code>（或使用<code>@RestControllerAdvice</code>）来实现相同的效果。</li></ul> 
<h4><a id="_16"></a>源码级别的区别</h4> 
<p><code>@RestController</code>的定义如下：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">TYPE</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token annotation punctuation">@Controller</span>
<span class="token annotation punctuation">@ResponseBody</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">RestController</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> <span class="token class-name">Controller</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token class-name">String</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如你所见，<code>@RestController</code>内部标注了<code>@Controller</code>和<code>@ResponseBody</code>，这意味着它继承了这两个注解的特性。</p> 
<p>而<code>@Controller</code>的定义如下：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">TYPE</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Controller</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> <span class="token class-name">Component</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token class-name">String</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>@Controller</code>被标注为一个常规的组件，但没有指定返回值的处理方式，因此你需要使用<code>@ResponseBody</code>或返回一个视图名称。</p> 
<h4><a id="_49"></a>总结</h4> 
<p>在Spring MVC中，你会根据应用的不同需求选择使用<code>@Controller</code>或<code>@RestController</code>。如果你正在构建一个HTML界面，可能会选择<code>@Controller</code>来返回视图。而如果你在构建一个服务于客户端如移动应用、前端框架（如React或Angular）的后端API，那么<code>@RestController</code>会是一个更好的选择，因为它默认返回JSON或XML响应。</p> 
<h3><a id="font_size4_colorFF0000Javasynchronizedfont_52"></a><font size="4" color="##FF0000">Java中每一个对象都可以作为锁，这是synchronized实现同步的基础</font></h3> 
<p><strong>普通同步方法（实例方法），锁是当前实例对象 ，进入同步代码前要获得当前实例的锁<br> 静态同步方法，锁是当前类的class对象 ，进入同步代码前要获得当前类对象的锁<br> 同步方法块，锁是括号里面的对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</strong></p> 
<h3><a id="font_size4_colorFF00002springboot_starterfont_59"></a><font size="4" color="##FF0000">2、springboot starter机制</font></h3> 
<p>Spring Boot的Starter机制是其核心特性之一，旨在简化依赖管理和自动配置，以便快速启动和运行Spring应用程序。Starter依赖是预定义的依赖集合，这些集合帮助你在项目中包含所需的Spring及相关技术的库。</p> 
<h4><a id="Starter_64"></a>Starter的特点</h4> 
<ul><li><strong>依赖传递</strong>：每个Starter都是一个Maven项目，它包含了需要启动某个功能所需的依赖库。当你在项目中包含一个Starter时，这个Starter相关的依赖也会被传递性地添加到你的项目中。</li><li><strong>自动配置</strong>：Spring Boot会利用Starter中包含的依赖来提供自动配置。这通常是通过<code>@Configuration</code>类实现的，该类中定义了条件化的Bean声明，只有在特定条件满足时这些Bean才会被创建。</li><li><strong>约定优于配置</strong>：使用Starter时，Spring Boot会提供一组默认配置，这些通常是基于约定的最佳实践。你可以通过在<code>application.properties</code>或<code>application.yml</code>中设置属性来覆盖默认配置。</li></ul> 
<h4><a id="_69"></a>如何工作</h4> 
<p>当你在项目中添加了一个Starter依赖，并且启动你的Spring Boot应用程序时，以下是发生的事情：</p> 
<ol><li><strong>依赖解析</strong>：Maven或Gradle会解析项目的依赖，并将Starter及其传递性依赖添加到类路径中。</li><li><strong>启动引导</strong>：Spring Boot应用程序在启动时会创建一个<code>ApplicationContext</code>，并且会查找类路径下的所有<code>META-INF/spring.factories</code>文件。</li><li><strong>自动配置</strong>：<code>spring.factories</code>文件中会列出一系列自动配置类，这些类使用<code>@Configuration</code>注释进行标注，并且通过<code>@Conditional</code>相关的注解进行条件化配置。</li><li><strong>条件匹配</strong>：Spring Boot会根据环境（如类路径中的类、Bean的存在、属性值等）评估这些配置类的条件注解。</li><li><strong>Bean创建</strong>：如果条件匹配，相关的配置类会被实例化，并且将它们声明的Bean创建并注册到<code>ApplicationContext</code>中。</li></ol> 
<h4><a id="Starter_78"></a>Starter示例</h4> 
<p>Spring Boot提供了许多官方的Starters，例如：</p> 
<ul><li><strong>spring-boot-starter-web</strong>：用于构建Web应用程序，包括RESTful应用程序，使用Spring MVC。</li><li><strong>spring-boot-starter-data-jpa</strong>：包含Spring Data JPA和Hibernate等，用于数据库访问。</li><li><strong>spring-boot-starter-security</strong>：提供Spring Security支持，用于实现安全控制。</li><li><strong>spring-boot-starter-test</strong>：包含测试相关的库，如JUnit、Spring Test、AssertJ等。</li></ul> 
<h4><a id="Starter_86"></a>创建自定义Starter</h4> 
<p>你也可以创建自己的Starter，步骤通常如下：</p> 
<ol><li><strong>创建Maven项目</strong>：作为Starter的容器。</li><li><strong>添加依赖</strong>：包含你希望Starter自动配置的库。</li><li><strong>编写自动配置</strong>：使用<code>@Configuration</code>类，并根据需要添加<code>@Conditional</code>注解。</li><li><strong>定义<code>spring.factories</code></strong>：在<code>META-INF/spring.factories</code>文件中指定自动配置类。</li><li><strong>打包和发布</strong>：将Starter打包成JAR文件，并将其发布到Maven仓库，以便其他人使用。</li></ol> 
<h4><a id="_95"></a>总结</h4> 
<p>Spring Boot的Starter提供了一个快速集成复杂技术栈的方式，通过预定义的依赖和自动配置，大幅简化了Spring应用程序的开发和配置过程。这些Starters遵循"约定优于配置"的原则，同时也提供了足够的灵活性来覆盖默认配置，以满足不同的业务需求。</p> 
<h3><a id="font_size4_colorFF0000SpringBootApplicationfont_98"></a><font size="4" color="##FF0000">SpringBootApplication</font></h3> 
<p>在Spring Boot应用程序中，<code>@SpringBootApplication</code>注解是一个方便的注解，它包含了<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>注解的集合。这个注解提供了一种快速启动Spring应用程序的方法，它封装了多项功能，让我们一一来深入理解。</p> 
<h4><a id="Configuration_101"></a>@Configuration</h4> 
<p><code>@Configuration</code>注解表明该类使用Spring基于Java的配置。类中被<code>@Bean</code>标记的方法将被实例化为Spring容器中的Bean，并且配置依赖注入。</p> 
<h4><a id="EnableAutoConfiguration_104"></a>@EnableAutoConfiguration</h4> 
<p><code>@EnableAutoConfiguration</code>告诉Spring Boot根据添加的jar依赖自动配置项目。例如，如果<code>spring-boot-starter-web</code>依赖是项目的一部分，那么Spring Boot会自动配置与Spring MVC相关的内容。这个注解是自动配置的关键，它让Spring Boot应用程序可以根据类路径下的类、Bean的定义以及各种属性设置来“猜测”你可能需要的配置。</p> 
<h4><a id="ComponentScan_107"></a>@ComponentScan</h4> 
<p><code>@ComponentScan</code>注解告诉Spring在包中查找其他组件、配置和服务，然后注册为Bean。默认情况下，它会扫描当前类所在的包和子包。</p> 
<h4><a id="EnableAutoConfiguration_110"></a>深入<code>@EnableAutoConfiguration</code></h4> 
<p><code>@EnableAutoConfiguration</code>的本质是根据类路径中的类和Spring Boot的各项配置来决策哪些配置是需要的。这个自动配置过程是通过<code>spring.factories</code>文件来实现的，它通常位于jar包的<code>META-INF</code>目录下。</p> 
<p>Spring Boot会查找所有classpath中的<code>META-INF/spring.factories</code>文件，并读取其中<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>键下配置的值。这些值是自动配置类的全限定名，Spring Boot会创建这些类的实例，并执行相关的自动配置。</p> 
<h4><a id="_116"></a>自动配置的条件化</h4> 
<p>Spring Boot的自动配置都是条件化的，即只有在特定条件满足时，相应的自动配置才会生效。这是通过<code>@Conditional</code>注解以及它的各种派生注解（如<code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>等）来实现的。这些注解可以结合使用，形成复杂的条件逻辑。</p> 
<p>例如，<code>DataSourceAutoConfiguration</code>是在类路径上有<code>DataSource</code>类和<code>EmbeddedDatabaseType</code>类时才会自动配置。而如果用户定义了自己的<code>DataSource</code> Bean，则默认的数据源自动配置将不会应用。</p> 
<h4><a id="_122"></a>覆盖自动配置</h4> 
<p>尽管Spring Boot的自动配置提供了很大的便利，但有时你可能需要覆盖某些自动配置。Spring Boot允许你通过多种方式进行自定义，包括：</p> 
<ul><li>在<code>application.properties</code>或<code>application.yml</code>中通过设置属性来覆盖自动配置的默认值。</li><li>添加自己的<code>@Configuration</code>类，声明自己的Bean，甚至可以使用<code>@Primary</code>注解来指定优先的Bean。</li><li>使用<code>@ComponentScan</code>的<code>excludeFilters</code>属性或<code>@EnableAutoConfiguration</code>的<code>exclude</code>属性来排除特定的自动配置类。</li></ul> 
<h4><a id="SpringBootApplication_130"></a>@SpringBootApplication示例</h4> 
<p>在Spring Boot应用程序的入口类上通常可以看到<code>@SpringBootApplication</code>注解的使用，比如：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyApplication</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">MyApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个例子中，<code>@SpringBootApplication</code>注解对于快速启动和自动配置应用程序至关重要。它整合了Spring的核心功能，通过一个单独的注解来启用，使Spring Boot成为一个非常易于使用和高度“开箱即用”的框架。</p> 
<h3><a id="font_size4_colorFF00003font_145"></a><font size="4" color="##FF0000">3、死锁</font></h3> 
<p>死锁是计算机科学中多线程或多进程编程的一个概念，它发生在一组进程或线程中，每个成员都在等待另一个成员释放资源或完成操作，但是没有一个能够继续前进，因为它们都在相互等待。这导致所有进程或线程都无法继续执行它们的任务。</p> 
<p>要发生死锁，通常需要满足以下四个条件，这被称为死锁的四个必要条件：</p> 
<h4><a id="1__152"></a>1. 互斥条件</h4> 
<p>资源不能被多个进程共享，只能由一个进程在任何时刻使用。每个资源要么已经分配给一个进程，要么就是可用的。</p> 
<h4><a id="2__155"></a>2. 持有并等待条件</h4> 
<p>进程至少持有一个资源，并且正在等待获取其他进程所持有的额外资源。</p> 
<h4><a id="3__158"></a>3. 不可剥夺条件</h4> 
<p>已经分配给一个进程的资源不能被强制从那个进程中剥夺；只有当进程自己释放资源时，资源才会变得可用。</p> 
<h4><a id="4__161"></a>4. 循环等待条件</h4> 
<p>有一组进程(P1, P2, …, Pn)，P1在等待P2持有的资源，P2在等待P3持有的资源，依此类推，直到Pn在等待P1持有的资源，这样就形成了一个循环等待的环路。</p> 
<h4><a id="_164"></a>死锁的例子</h4> 
<p>考虑一个简单的例子，其中有两个进程（P1和P2）和两个资源（R1和R2）。进程P1持有资源R1并请求资源R2，同时进程P2持有资源R2并请求资源R1。如果每个进程都不释放其当前持有的资源，那么这两个进程都将无法继续进行，因为它们要求的资源都被对方持有。</p> 
<h4><a id="_167"></a>死锁处理</h4> 
<p>处理死锁的常见策略分为四类：</p> 
<h5><a id="1__170"></a>1. 死锁预防</h5> 
<p>预防死锁的策略旨在通过确保系统永远不会进入可能导致死锁的状态来避免死锁。这通常涉及破坏产生死锁的四个条件中的至少一个。</p> 
<h5><a id="2__173"></a>2. 死锁避免</h5> 
<p>与预防不同，避免策略允许这些条件存在，但是系统会尝试组织资源分配，使得系统永不进入不安全状态。银行家算法是解决死锁问题的一个著名的避免策略。</p> 
<h5><a id="3__176"></a>3. 死锁检测</h5> 
<p>在死锁检测策略中，系统允许死锁发生，并通过一些检测机制来检测是否已经发生了死锁。一旦检测到死锁，就可以采取一些措施解决。</p> 
<h5><a id="4__179"></a>4. 死锁恢复</h5> 
<p>一旦死锁被检测到，系统需要恢复到一个安全状态并重新开始执行。恢复策略可能包括终止一个或多个进程，或者剥夺一些资源。</p> 
<h4><a id="_182"></a>死锁解决方案</h4> 
<p>解决死锁问题通常涉及以下措施：</p> 
<ul><li>终止进程：最直接的解决方法是直接终止一个或多个导致死锁的进程。</li><li>资源剥夺：强制从一个进程中取走资源并分配给其他进程。</li><li>进程回退：将一个或多个进程回退到足以打破循环等待的状态。</li></ul> 
<p>处理死锁的最佳方法取决于应用程序的具体需求和资源的性质。设计良好的系统会尽量避免死锁的发生，或者能够有效地检测并解决死锁问题。</p> 
<h3><a id="font_size4_colorFF00004font_190"></a><font size="4" color="##FF0000">4、事务</font></h3> 
<p>事务是数据库管理系统中的一个基本概念，它是一个独立的工作单位，由一系列操作组成，这些操作要么完全执行，要么完全不执行。在关系型数据库中，事务用来确保数据库的完整性和一致性。一个事务可以是一次简单的单一操作，如更新一个记录，也可以是多个操作的组合，如更新多个记录或执行多个不同的数据库操作。</p> 
<p>事务的主要特性通常由ACID原则定义，该原则包括以下四个部分：</p> 
<h4><a id="1_Atomicity_196"></a>1. 原子性（Atomicity）</h4> 
<p>原子性确保事务中的所有操作要么全部完成，要么全部不完成。如果事务中的一个操作失败，整个事务将回滚到开始状态，所有已经执行的操作都将撤销。</p> 
<h4><a id="2_Consistency_199"></a>2. 一致性（Consistency）</h4> 
<p>一致性确保事务从一个一致的状态转换到另一个一致的状态。在事务开始和完成时，数据库的完整性约束都必须保持一致。</p> 
<h4><a id="3_Isolation_202"></a>3. 隔离性（Isolation）</h4> 
<p>隔离性保证事务的操作和其他并发事务的操作是隔离的。这意味着一个事务的中间状态不应该被其他事务所看到。</p> 
<h4><a id="4_Durability_205"></a>4. 持久性（Durability）</h4> 
<p>持久性确保一旦事务完成，它对数据库的改变是永久性的，即使系统发生故障也不会丢失。</p> 
<h4><a id="_208"></a>事务的隔离级别</h4> 
<p>数据库事务的隔离级别定义了一个事务可能必须和其他并发事务隔离的程度。隔离级别通常有以下四种：</p> 
<ul><li>读未提交（Read Uncommitted）: 在这个级别，一个事务可以读取另一个事务尚未提交的数据。这可能导致脏读（Dirty Read）。</li><li>读提交（Read Committed）: 这个级别确保一个事务只可以读取另一个事务已经提交的数据。这可以避免脏读，但仍然可能出现不可重复读（Non-Repeatable Read）。</li><li>可重复读（Repeatable Read）: 在这个级别，一个事务在整个过程中可以多次读取同一数据，并且保证结果一致，即使其他事务在这段时间内提交了更新。这可以避免脏读和不可重复读，但仍然可能出现幻读（Phantom Read）。</li><li>可串行化（Serializable）: 这是最高的隔离级别，它完全隔离事务，使得事务只能一个接一个地执行，而不是并行执行。这可以避免脏读、不可重复读和幻读。</li></ul> 
<h4><a id="_217"></a>事务的管理</h4> 
<p>事务的管理通常涉及以下操作：</p> 
<ul><li>开始事务（BEGIN TRANSACTION）: 声明事务的开始。</li><li>提交事务（COMMIT）: 完成事务中的所有操作，并将其永久保存到数据库中。</li><li>回滚事务（ROLLBACK）: 撤销事务中的所有操作，并放弃所有未保存的更改。</li></ul> 
<h4><a id="_225"></a>事务的实现</h4> 
<p>数据库通过各种技术来实现事务的管理和保证ACID特性，包括：</p> 
<ul><li>锁定机制：来确保当其他事务进行读/写操作时，数据的一致性可以得到维护。</li><li>日志记录：每一个被事务影响的数据项都会在日志中记录下来，在系统故障时可以用来恢复数据到一个一致的状态。</li><li>多版本并发控制（MVCC）：一种避免在读取数据时进行锁定的方法，使得读写操作可以更加并行地执行。</li></ul> 
<p>数据库事务是一个复杂的主题，需要在保证数据完整性和系统性能之间找到平衡。正确理解和使用事务对于开发安全、稳定和高效的数据库应用程序至关重要。</p> 
<p><strong>事务的并发问题</strong></p> 
<p>1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据<br> 　　<br> 　　2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。<br> 　　<br> 　　3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p> 
<p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p> 
<h3><a id="font_size4_colorFF00005font_245"></a><font size="4" color="##FF0000">5、线程</font></h3> 
<p>在线程模型中，线程是轻量级的执行单元，它们在进程的上下文中并发执行。深入理解线程涉及探讨它们的行为、特性和实现方式。</p> 
<h4><a id="_249"></a>线程的关键特性点</h4> 
<p>以下是线程的关键特性点，每一点都对理解线程的工作方式至关重要：</p> 
<ol><li> <p><strong>并发性</strong>: 线程允许多个任务几乎同时发生，促进了多核处理器上的并行处理和在单核处理器上的时间分片。</p> </li><li> <p><strong>独立性</strong>: 每个线程都有其独立的程序计数器、堆栈和局部变量，但它们共享进程级别的资源，如内存和文件。</p> </li><li> <p><strong>轻量级</strong>: 线程的创建和上下文切换通常比完整的进程轻量，因为它们共享更多的状态和资源。</p> </li><li> <p><strong>通信</strong>: 线程间的通信（线程同步）可以通过共享内存和适当的同步机制来实现，这包括锁、等待/通知机制、信号量等。</p> </li><li> <p><strong>线程池</strong>: 为避免频繁地创建和销毁线程带来的开销，线程池维护一组预先初始化的线程，这些线程可以被多个任务重用。</p> </li><li> <p><strong>优先级</strong>: 大多数操作系统和线程库支持线程优先级，它影响线程获取CPU时间的顺序。高优先级的线程比低优先级的线程更有可能被选中执行。</p> </li><li> <p><strong>守护线程</strong>: 一些线程可以被设置成守护线程，这种线程通常用于服务性的任务。当只剩下守护线程时，JVM会退出。</p> </li></ol> 
<h4><a id="_266"></a>线程的状态</h4> 
<p>线程的状态描述了线程在任何给定时间的行为。在线程的生命周期中，线程可以处于以下状态：</p> 
<ol><li> <p><strong>新建(New)</strong>: 线程被创建后，但还没有调用<code>start()</code>方法。</p> </li><li> <p><strong>就绪(Runnable)</strong>: 线程已经调用了<code>start()</code>方法，等待CPU分配时间片。</p> </li><li> <p><strong>运行(Running)</strong>: 线程获取了CPU时间片，正在执行。</p> </li><li> <p><strong>阻塞(Blocked)</strong>: 线程因为等待一个监视器锁（进入同步块）而被阻塞。</p> </li><li> <p><strong>等待(Waiting)</strong>: 线程等待另一个线程执行特定的（通常是状态变化）操作。</p> </li><li> <p><strong>超时等待(Timed Waiting)</strong>: 线程等待另一个线程执行操作到一定的时间。</p> </li><li> <p><strong>终止(Terminated)</strong>: 线程的运行结束。</p> </li></ol> 
<h4><a id="_283"></a>线程的同步</h4> 
<p>在多线程程序中，同步对于保持数据一致性和避免竞态条件至关重要。同步可以通过以下方式来实现：</p> 
<ol><li> <p><strong>互斥锁(Mutex)</strong>: 确保一次只有一个线程可以访问某个资源。</p> </li><li> <p><strong>信号量(Semaphore)</strong>: 限制可以同时访问资源或执行一段代码的线程数。</p> </li><li> <p><strong>监视器(Monitor)</strong>: 一种更高级的同步机制，通常与<code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>方法一起使用。</p> </li><li> <p><strong>并发集合</strong>: 线程安全的数据结构，如<code>java.util.concurrent</code>中的集合。</p> </li><li> <p><strong>原子变量</strong>: 利用特定的硬件指令来保证变量操作的原子性。</p> </li></ol> 
<h4><a id="_296"></a>线程的问题</h4> 
<p>不当的线程管理可能导致以下问题：</p> 
<ol><li> <p><strong>竞态条件(Race Condition)</strong>: 两个或多个线程同时访问共享资源，并尝试同时修改它。</p> </li><li> <p><strong>死锁(Deadlock)</strong>: 多个线程相互等待对方持有的锁，导致永久阻塞。</p> </li><li> <p><strong>饥饿(Starvation)</strong>: 一个或多个线程无法获取必要的资源，因而无法执行，通常是因为线程优先级不当。</p> </li><li> <p><strong>活锁(Livelock)</strong>: 线程不断重试一个操作，但总是失败，因为其他线程也在做相同的事情。</p> </li><li> <p><strong>上下文切换(Context Switching)</strong>: 线程切换可能引起的性能开销，特别是在高负载或大量线程时。</p> </li></ol> 
<p>线程和并发编程是一个复杂的主题，它要求开发者对同步、资源共享和任务调度有深刻的理解。适当的线程使用策略可以使软件设计更加清晰，系统更加高效。<br> <strong>线程三大特性:原子性、可见性、有序性</strong></p> 
<p><strong>原子性</strong>：即一个操作或多个操作要么全部执行并且执行过程中不被任何因素打断，要么就不执行</p> 
<p>原子性其实就是保证数据一致，线程安全的一部分</p> 
<p><strong>可见性</strong>：当多个线程同时访问一个变量时，一个线程修改了这个变量的值，其它线程能立即看得到它修改的值，volatile关键字解决线程之间的可见性，强制线程每次读取该值的时候都去“主内存”中读取</p> 
<p><strong>有序性</strong>：执行的顺序按照代码的先后顺序执行</p> 
<h3><a id="font_size4_colorFF00006FactoryBeanBeanFactory_font_320"></a><font size="4" color="##FF0000">6、FactoryBean和BeanFactory 有什么区别？</font></h3> 
<p><code>FactoryBean</code>和<code>BeanFactory</code>是Spring框架中完全不同的概念，但它们都与Spring容器中bean的创建和管理有关。下面，我们将详细探讨它们的相同点和不同点。</p> 
<h4><a id="_324"></a>相同点</h4> 
<p>实际上，<code>FactoryBean</code>和<code>BeanFactory</code>的相同点非常有限，主要是它们都与Spring容器中bean的创建有关联。它们都参与到了Spring容器管理对象实例的生命周期中。</p> 
<h4><a id="_327"></a>不同点</h4> 
<p>不同点比较多，可以从各个方面详细深入地探讨：</p> 
<h5><a id="1__330"></a>1. 概念层面</h5> 
<ul><li><strong>BeanFactory</strong>: 它是Spring的基础设施，是Spring IoC容器的核心接口，负责管理bean的生命周期，包括bean的创建、销毁、装配以及其他服务。</li><li><strong>FactoryBean</strong>: 它是一个可以生成或修饰对象实例的工厂模式实现，用于创建特殊的bean。<code>FactoryBean</code>本身定义在Spring IoC容器中，但它产生的对象不一定必须由Spring IoC容器管理。</li></ul> 
<h5><a id="2__334"></a>2. 用途和功能</h5> 
<ul><li><strong>BeanFactory</strong>: 作为IoC容器，用于创建和管理容器中的所有bean。它主要用于加载和管理bean实例，以及延迟加载（懒加载）。</li><li><strong>FactoryBean</strong>: 设计用来创建复杂对象，当直接配置对象实例过于复杂时，通过实现<code>FactoryBean</code>接口来简化配置。它是一个可以返回不同对象实例的bean。</li></ul> 
<h5><a id="3__338"></a>3. 实现和扩展</h5> 
<ul><li><strong>BeanFactory</strong>: 通过直接或间接实现<code>BeanFactory</code>接口的方式来扩展，比如常见的<code>ApplicationContext</code>接口，它提供了更多高级特性如事件传播、AOP支持等。</li><li><strong>FactoryBean</strong>: 通过实现<code>FactoryBean</code>接口，并重写<code>getObject()</code>方法来返回一个特定的对象实例。</li></ul> 
<h5><a id="4__342"></a>4. 行为</h5> 
<ul><li><strong>BeanFactory</strong>: 通常不会直接使用<code>BeanFactory</code>，而是会使用它的实现，比如<code>ApplicationContext</code>，来获得和管理bean。</li><li><strong>FactoryBean</strong>: 当通过<code>BeanFactory</code>获取到<code>FactoryBean</code>的实例时，你得到的对象是<code>FactoryBean#getObject()</code>方法返回的对象，而不是<code>FactoryBean</code>实例本身。</li></ul> 
<h5><a id="5__346"></a>5. 访问方式</h5> 
<ul><li><strong>BeanFactory</strong>: 你可以通过<code>getBean()</code>方法直接从<code>BeanFactory</code>中获取bean。</li><li><strong>FactoryBean</strong>: 当从<code>BeanFactory</code>请求<code>FactoryBean</code>产生的bean时，你需要使用bean的名称。如果需要访问<code>FactoryBean</code>实例本身，则需要在bean的名称前加上<code>&amp;</code>。</li></ul> 
<h4><a id="_350"></a>例子</h4> 
<p>以下是一个<code>FactoryBean</code>的例子，展示如何使用它来创建复杂对象：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ComplexObjectFactoryBean</span> <span class="token keyword">implements</span> <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ComplexObject</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">ComplexObject</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 实例化复杂对象，可能包括配置复杂的初始化逻辑</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ComplexObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token class-name">ComplexObject</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在Spring的配置中注册这个<code>FactoryBean</code>：</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>complexObject<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>example.ComplexObjectFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre> 
<p>当请求<code>complexObject</code>时，实际上得到的将是<code>ComplexObjectFactoryBean#getObject()</code>方法返回的<code>ComplexObject</code>实例。如果你需要访问<code>ComplexObjectFactoryBean</code>本身，你应该请求<code>&amp;complexObject</code>。</p> 
<p>在比较<code>FactoryBean</code>和<code>BeanFactory</code>时，最重要的是理解<code>BeanFactory</code>是创建和管理bean的容器，而<code>FactoryBean</code>是用来创建复杂对象的模板或工厂类，它们在Spring框架中扮演着截然不同的角色。</p> 
<h3><a id="font_size4_colorFF00007JDKCGLibfont_382"></a><font size="4" color="##FF0000">7、JDK和CGLib的区别</font></h3> 
<p>在Java开发中，JDK动态代理和CGLib动态代理是实现AOP（面向切面编程）和代理模式的两种常见方式。它们都可以在运行时创建代理对象，但是底层实现和使用场景有所不同。</p> 
<h4><a id="_386"></a>相同点</h4> 
<p>JDK动态代理和CGLib动态代理在用途上相似，都用于创建动态代理对象，允许开发者在不改变原有代码结构的情况下，增加或改变某些功能。这在AOP编程中尤为常见，比如在方法执行前后添加日志或事务处理。</p> 
<h4><a id="_389"></a>不同点</h4> 
<p>JDK动态代理和CGLib动态代理之间有一些关键区别：</p> 
<h5><a id="1__392"></a>1. 实现机制</h5> 
<ul><li><strong>JDK动态代理</strong>：使用反射包<code>java.lang.reflect</code>中的<code>Proxy</code>类和<code>InvocationHandler</code>接口来创建代理对象。它只能对实现了接口的类创建代理。</li><li><strong>CGLib动态代理</strong>：通过继承目标类来创建子类的方式实现。它不需要目标类实现接口。</li></ul> 
<h5><a id="2__396"></a>2. 性能</h5> 
<ul><li><strong>JDK动态代理</strong>：由于JDK动态代理是基于接口的，它在调用过程中使用反射机制，会有一定的性能开销。</li><li><strong>CGLib动态代理</strong>：性能通常优于JDK动态代理（尤其是在方法调用频繁时），因为它使用<code>FastClass</code>机制来直接调用方法，而不是通过反射。</li></ul> 
<h5><a id="3__400"></a>3. 使用限制</h5> 
<ul><li><strong>JDK动态代理</strong>：只能对接口或接口的实现类进行代理，不能对普通类进行代理。</li><li><strong>CGLib动态代理</strong>：可以代理没有实现接口的类，但是不能对<code>final</code>类或<code>final</code>方法进行代理，因为它们不能被子类覆盖。</li></ul> 
<h5><a id="4__404"></a>4. 使用场景</h5> 
<ul><li><strong>JDK动态代理</strong>：适用于有接口定义的情况，如果你的类没有实现任何接口，则无法使用JDK代理。</li><li><strong>CGLib动态代理</strong>：适用于没有实现接口的类，或者对类的代理比接口的代理更有意义的场合。</li></ul> 
<h5><a id="5__408"></a>5. 实现复杂度</h5> 
<ul><li><strong>JDK动态代理</strong>：使用相对简单，只需要实现<code>InvocationHandler</code>接口并重写<code>invoke</code>方法。</li><li><strong>CGLib动态代理</strong>：通过使用字节码处理库ASM，可以在运行时创建新的类。因此，它的使用通常比JDK动态代理更复杂。</li></ul> 
<h5><a id="6__412"></a>6. 第三方库依赖</h5> 
<ul><li><strong>JDK动态代理</strong>：作为Java标准库的一部分，不需要额外的依赖。</li><li><strong>CGLib动态代理</strong>：需要引入CGLib库以及其依赖的ASM字节码操作库。</li></ul> 
<h4><a id="_416"></a>示例</h4> 
<h5><a id="JDK_418"></a>JDK动态代理</h5> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MyInterface</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterfaceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MyInterface</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Doing something..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInvocationHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span> target<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MyInvocationHandler</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 在目标方法执行前后可以添加额外的操作</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Before method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name">MyInterface</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MyInterface</span><span class="token punctuation">)</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>
        <span class="token class-name">MyInterface</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token class-name">MyInterface</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token keyword">new</span> <span class="token class-name">MyInvocationHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyInterfaceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="CGLib_454"></a>CGLib动态代理</h5> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyConcreteClass</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Doing something..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name">Enhancer</span> enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span><span class="token class-name">MyConcreteClass</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> proxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 在目标方法执行前后可以添加额外的操作</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Before method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> result <span class="token operator">=</span> proxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">MyConcreteClass</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MyConcreteClass</span><span class="token punctuation">)</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>总结来说，JDK动态代理和CGLib动态代理都是实现动态代理的有效手段，但是它们有不同的使用场景和限制。通常情况下，如果目标对象是一个实现了接口的类，可以优先考虑使用JDK动态代理，因为它是Java自带的，不需要额外的库。如果目标对象是一个没有实现接口的普通类，或者需要通过继承来增强行为，则可以使用CGLib动态代理。</p> 
<p>Spring在选择用JDK还是CGLib的依据</p> 
<p>当Bean实现接口时，Spring就会用JDK的动态代理<br> 当Bean没有实现接口时，Spring使用CGLib来实现<br> 可以强制使用CGLib（在Spring配置中加入&lt;aop:aspectj-autoproxy proxy-target-class=“true”/&gt;）</p> 
<h3><a id="font_size4_colorFF00008Javafont_485"></a><font size="4" color="##FF0000">8、Java类的加载过程</font></h3> 
<p>在Java中，类的加载是通过类加载器（ClassLoader）完成的。Java虚拟机（JVM）在运行时会通过一个特定的类加载器实例来加载Java类。这一过程通常分为以下几个阶段：加载（Loading）、链接（Linking）、和初始化（Initialization）。</p> 
<h4><a id="Loading_488"></a>加载（Loading）</h4> 
<p>在加载阶段，类加载器负责从文件系统、网络或其他来源读取Java类的二进制数据，并将这些数据转为<code>java.lang.Class</code>类的实例。在这个过程中，类加载器会检查这个类是否已经被加载过，因为同一个类只能被加载一次。</p> 
<p>加载时，类加载器主要执行以下步骤：</p> 
<ol><li>通过全类名来定位此类的二进制流。</li><li>将这个二进制流代表的类加载到JVM中。</li><li>将这个流转换成<code>java.lang.Class</code>类的一个实例。</li></ol> 
<p>例如，当你调用<code>Class.forName("com.example.MyClass")</code>时，就会触发类加载。</p> 
<h4><a id="Linking_498"></a>链接（Linking）</h4> 
<p>链接阶段又分为验证（Verification）、准备（Preparation）和解析（Resolution）三个子步骤。</p> 
<ol><li><strong>验证（Verification）</strong>: 确保被加载的类符合JVM规范，没有安全问题。</li><li><strong>准备（Preparation）</strong>: JVM为类变量分配内存，并设置默认初始值。</li><li><strong>解析（Resolution）</strong>: JVM将所有的符号引用转换为直接引用。</li></ol> 
<h4><a id="Initialization_505"></a>初始化（Initialization）</h4> 
<p>在初始化阶段，JVM负责执行类的静态初始化块以及静态字段的初始化。这一步骤是执行构造器之前的最后一步，即执行<code>&lt;clinit&gt;()</code>方法的过程。</p> 
<p>现在，我们来看一下JVM内部是如何使用类加载器来加载类的。</p> 
<p>以<code>ClassLoader.loadClass(String name)</code>方法为例：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 首先检查请求的类是否已被加载</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 如果没有加载，则委托给父类加载器</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// 如果没有父类加载器，则委托给启动类加载器（Bootstrap ClassLoader）</span>
                    c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// ClassNotFoundException thrown if class not found</span>
                <span class="token comment">// from the non-null parent class loader</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 如果类还没被加载，则调用本地的findClass方法来加载类</span>
                c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 链接类</span>
            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这个<code>loadClass</code>方法描述了类加载的入口点，具体的类加载动作发生在<code>findClass</code>方法中。</p> 
<p>当类被加载后，它们会被缓存。如果之后再次需要加载，JVM会返回缓存中的类，而不是重新加载。</p> 
<p>这只是一个高层次的概述，如果需要深入了解类加载器的实现，你可以直接查看OpenJDK的源代码。由于类加载器的实现可能根据不同的JVM实现（比如OpenJDK、Oracle JDK等）有所不同，具体细节可能会发生变化。</p> 
<h3><a id="font_size4_colorFF0000font_557"></a><font size="4" color="##FF0000">双亲委派</font></h3> 
<p>双亲委派模型（Parent Delegation Model）是Java 类加载器寻找类的一种机制。其核心思想是：当一个类加载器收到类加载请求时，它不会自己首先去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一层的加载器都是如此。只有当父类加载器反馈无法完成这个加载（它的搜索范围中没有找到所需的类）时，子类加载器才会尝试自己去加载。</p> 
<p>这个模型的优点是防止内存中出现多份同样的字节码，并确保Java核心库的类型安全。双亲委派模型在<code>java.lang.ClassLoader</code>中实现。</p> 
<p>下面是<code>ClassLoader</code>中与双亲委派模型相关的<code>loadClass</code>方法的简化版源码：</p> 
<pre><code class="prism language-java"><span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 首先，检查该类是否已经被加载</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 如果没有被加载，尝试从父类加载器中加载</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// 如果父类加载器为空，则使用启动类加载器（Bootstrap ClassLoader）</span>
                    c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 如果父类加载器抛出ClassNotFoundException</span>
                <span class="token comment">// 表示父类加载器无法完成加载请求</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 如果父类加载器无法加载该类，则当前类加载器尝试加载</span>
                c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 链接已经被加载的类</span>
            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这段代码大致流程如下：</p> 
<ol><li><strong>同步锁定（Synchronization）</strong>: 防止多个线程同时加载同一个类。</li><li><strong>检查类是否加载（Check Loaded）</strong>: 检查请求加载的类是否已经被加载。</li><li><strong>委托给父类加载器（Delegate to Parent）</strong>: 如果类没有被加载，委托给父类加载器尝试加载。</li><li><strong>使用启动类加载器（Use Bootstrap ClassLoader）</strong>: 如果父类加载器是<code>null</code>，意味着当前加载器是系统类加载器，它会尝试用启动类加载器来加载类。</li><li><strong>当前类加载器加载（Load Class Itself）</strong>: 如果父类加载器不能加载该类，则当前类加载器尝试自己去加载。</li><li><strong>链接类（Resolve Class）</strong>: 如果<code>resolve</code>标志为<code>true</code>，则链接请求加载的类。</li></ol> 
<p>需要注意的是，<code>findClass</code>方法是<code>ClassLoader</code>中的一个抽象方法，由其子类具体实现。在<code>findClass</code>方法中，类加载器通常会根据给定的类名，将.class文件读入内存，转换成<code>Class</code>对象。如果<code>findClass</code>也无法完成类加载，它会抛出<code>ClassNotFoundException</code>。</p> 
<p>在某些情形下，比如Java Agent，热部署等功能的实现中会绕开双亲委派模型，或者在OSGi环境中，每一个Bundle有自己的类加载器，这种情况下双亲委派模型会被设计得更加灵活。</p> 
<p>总的来说，双亲委派模型是确保Java程序稳定运行的关键机制之一，它防止了核心库被随意篡改，同时也避免了类加载器之间的冲突。</p> 
<h3><a id="font_size4_colorFF00009hashfont_614"></a><font size="4" color="##FF0000">9、如何解决hash冲突</font></h3> 
<p>有以下几种常见的解决hash冲突的方法：</p> 
<p><strong>链地址法（Chaining）</strong>：将哈希表中每个桶中的元素使用链表等数据结构链接起来，当产生哈希冲突时，将新元素插入到链表的末尾。</p> 
<p>这是最常用的解决哈希冲突的方法。</p> 
<p><strong>开放地址法（Open Addressing）</strong>：当发生哈希冲突时，尝试在哈希表中找到另一个空闲的桶。</p> 
<p>具体有以下几种实现方法：</p> 
<p>线性探测：在哈希表中依次查找下一个空闲的桶。</p> 
<p>二次探测：在哈希表中使用二次探测函数查找下一个空闲的桶。</p> 
<p>双重哈希：使用另一个哈希函数计算下一个空闲的桶。</p> 
<p><strong>再哈希法（Rehashing）</strong>：当发生哈希冲突时，使用另一个哈希函数计算出另一个哈希值，然后将元素插入到对应的桶中。</p> 
<p><strong>建立公共溢出区（Overflow Area）</strong>：当发生哈希冲突时，将冲突的元素插入到一个公共溢出区中，需要时再通过遍历这个溢出区来查找元素。这种方法会增加查找的时间复杂度，不太常用。</p> 
<p>在散列数据结构中，哈希冲突（Hash Collision）是指两个或更多的输入值在经过哈希函数处理后得到了相同的哈希值。由于哈希表的大小是有限的，而可能的输入值通常是无限的，哈希冲突是不可避免的。</p> 
<p>为了解决哈希冲突，有几种常用的策略：</p> 
<h4><a id="1_Separate_Chaining_647"></a>1. 分离链接（Separate Chaining）</h4> 
<p>分离链接是处理哈希冲突的一种直接方法。在这种策略中，每个哈希桶（bucket）本身是一个链表（或者是其他形式的动态数据结构，如树）。当一个新的条目与该位置上的现有条目发生冲突时，它会被添加到链表的末尾。</p> 
<p>例如，假设我们有一个哈希表，有以下哈希函数和元素：</p> 
<pre><code>Hash Function: h(x) = x mod 10
Elements: 12, 22, 32
</code></pre> 
<p>因为所有的元素都会映射到同一个值（2），所以哈希表中的索引2将指向一个链表，包含值12，22和32。</p> 
<h4><a id="2_Open_Addressing_659"></a>2. 开放寻址（Open Addressing）</h4> 
<p>在开放寻址策略中，所有的元素都存储在哈希表的数组里。当一个新的元素被插入且其哈希值对应的槽已经被占用时，哈希表尝试找一个空槽来存放这个新元素。这通过一系列的探测（probing）操作完成，比如线性探测（linear probing）、二次探测（quadratic probing）或双重哈希（double hashing）。</p> 
<p>以线性探测为例，如果位置<code>i</code>被占用，算法会检查<code>i+1</code>，<code>i+2</code>，依此类推，直到找到一个空位置。</p> 
<h4><a id="3_Double_Hashing_664"></a>3. 双重哈希（Double Hashing）</h4> 
<p>双重哈希是开放寻址的一个变体，但是它使用了两个哈希函数。当第一个哈希函数<code>h1</code>产生冲突时，它会使用第二个哈希函数<code>h2</code>。新的位置将会是原始哈希值加上第二个哈希函数的倍数。</p> 
<p>这个算法会产生一个探测序列，如果<code>h2</code>设计得当，这个序列可以访问哈希表中的每个槽，减少了聚集的可能性。</p> 
<h4><a id="4_Rehashing_669"></a>4. 再散列（Rehashing）</h4> 
<p>随着元素不断加入，哈希表的负载因子（即表中已有的元素数与位置总数的比例）会不断上升，从而增加冲突的概率。当负载因子超过某个阈值（如0.7）时，可以通过再散列来减少冲突，即创建一个更大的哈希表，并将所有现有元素重新映射到新表中。</p> 
<h4><a id="5__672"></a>5. 使用更好的哈希函数</h4> 
<p>选择一个良好的哈希函数至关重要，它可以最大程度地减少冲突的发生。一个好的哈希函数应该能够将输入数据均匀分布到所有哈希桶中。</p> 
<h4><a id="_675"></a>实现示例</h4> 
<p>以Java中的<code>HashMap</code>为例，该结构内部使用了一种称作“数组+链表+红黑树”的结构：当链表的长度过长（默认超过8）时，链表将转换为红黑树，以提高搜索效率。以下是Java中<code>HashMap</code>解决哈希冲突的一个简化片段：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    <span class="token comment">// 如果表为空或者大小为0，进行扩容处理</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">// 计算索引i，并对其进行赋值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 链表处理</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 默认是8，链表转红黑树的阈值</span>
                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> 
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                p <span class="token operator">=</span> e<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 如果已经存在，替换旧值</span>
            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这段代码中，<code>HashMap</code>使用链表处理冲突，当链表长度过大时，会将链表转换为红黑树以提高性能。此外，该实现也考虑了扩容逻辑，以适应不断增加的数据量。</p> 
<p>处理哈希冲突的方法有很多，选择哪一种取决于具体的应用场景，包括数据的分布、频率、哈希表的大小、内存限制等因素。</p> 
<h3><a id="font_size4_colorFF000010font_733"></a><font size="4" color="##FF0000">10、抽象类和接口</font></h3> 
<p>抽象类（Abstract Class）和接口（Interface）都是Java面向对象编程中实现抽象的两个关键概念。它们有一些相似之处，也有许多不同之处。</p> 
<h4><a id="_737"></a>相同点</h4> 
<ol><li><strong>不可以被实例化</strong>：既抽象类也接口都不能被实例化，它们通常用作其他类的基础。</li><li><strong>包含抽象方法</strong>：抽象类和接口都可以包含抽象方法，即没有方法体的方法，具体的实现需要由子类或实现类完成。</li><li><strong>被继承/实现的目的</strong>：它们都被用作基类，子类/实现类应提供相应的方法实现。</li></ol> 
<h4><a id="_742"></a>不同点</h4> 
<ol><li> <p><strong>方法声明</strong>：</p> 
  <ul><li><strong>抽象类</strong>：可以包含具体方法（有方法体的方法）和抽象方法。</li><li><strong>接口</strong>（在Java 8之前）：只能包含抽象方法。从Java 8开始，接口也可以包含默认方法和静态方法。</li></ul> </li><li> <p><strong>成员变量</strong>：</p> 
  <ul><li><strong>抽象类</strong>：可以包含各种访问修饰符的字段，字段可以是非final的，也可以是非static的。</li><li><strong>接口</strong>：只能包含静态和final变量（常量）。</li></ul> </li><li> <p><strong>构造函数</strong>：</p> 
  <ul><li><strong>抽象类</strong>：可以有构造函数。</li><li><strong>接口</strong>：不能有构造函数。</li></ul> </li><li> <p><strong>继承和实现</strong>：</p> 
  <ul><li><strong>抽象类</strong>：一个类只能继承一个抽象类，因为Java不支持多重继承。</li><li><strong>接口</strong>：一个类可以实现多个接口。</li></ul> </li><li> <p><strong>访问修饰符</strong>：</p> 
  <ul><li><strong>抽象类</strong>：方法和成员变量可以有任何访问修饰符。</li><li><strong>接口</strong>：在Java 8之前，方法默认是public的，且不能有其他访问修饰符。从Java 9开始，接口可以包含私有方法。</li></ul> </li><li> <p><strong>多继承</strong>：</p> 
  <ul><li><strong>抽象类</strong>：不能实现多继承。</li><li><strong>接口</strong>：支持多继承，即一个接口可以继承多个其他接口。</li></ul> </li><li> <p><strong>实现（Implementation）</strong>：</p> 
  <ul><li><strong>抽象类</strong>：子类使用<code>extends</code>关键字继承抽象类，并提供抽象方法的实现。</li><li><strong>接口</strong>：类使用<code>implements</code>关键字实现接口，必须提供接口中所有方法的实现，除非它是一个抽象类。</li></ul> </li><li> <p><strong>设计目的</strong>：</p> 
  <ul><li><strong>抽象类</strong>：用于捕获子类的通用特征，并提供一个部分实现的类层次结构。</li><li><strong>接口</strong>：用于定义不同类之间的约定或协议，是实现多种功能的一种方式，不涉及实现。</li></ul> </li><li> <p><strong>版本兼容性</strong>：</p> 
  <ul><li><strong>抽象类</strong>：如果后续需要添加新的方法，可能会破坏已有的类体系结构。</li><li><strong>接口</strong>：在Java 8之后，可以通过默认方法和静态方法添加新功能而不影响实现接口的类。</li></ul> </li></ol> 
<p>根据以上特点，你可以根据具体需求选择使用抽象类还是接口。如果你要定义一个基础的事物或者提供一个共同的实现，并且知道它将不需要与其他继承结构共存，那么抽象类可能是一个好选择。相反，如果你要定义一组可能由不同类以多种方式实现的行为，或者提供一个插件式的扩展机制，那么接口将是更好的选择。。</p> 
<h3><a id="font_size4_colorFF0000Feignfont_781"></a><font size="4" color="##FF0000">Feign原理</font></h3> 
<p>Feign是一个声明式的Web服务客户端，它的目标是简化HTTP API客户端的开发。其工作原理是，开发者定义一个接口并用注解修饰它的方法和参数来配置对应的HTTP请求，Feign在程序启动时会扫描并解析这些注解，生成代理类。当调用接口中的方法时，Feign通过这个代理类构建并发送HTTP请求到服务提供者，并将响应结果映射到接口方法的返回值上。</p> 
<p>下面将更加详细地解释Feign的内部工作原理，并结合源码进行讲解。</p> 
<h4><a id="Feign_786"></a>Feign的工作流程概述</h4> 
<ol><li><strong>定义服务接口</strong>：开发者编写一个接口，使用Feign的注解来声明服务提供者的REST API。</li><li><strong>创建Feign.Builder</strong>：使用<code>Feign.Builder</code>来创建Feign的客户端实例。</li><li><strong>构建RequestTemplate</strong>：当程序启动时，Feign通过注解解析生成<code>RequestTemplate</code>，它包含了构建请求所需的所有信息，例如URL、HTTP方法和查询参数等。</li><li><strong>生成代理类</strong>：Feign使用JDK动态代理生成接口的代理实现类。</li><li><strong>发送请求</strong>：当代理接口的方法被调用时，Feign根据<code>RequestTemplate</code>生成HTTP请求，并通过Client接口的实现类（比如使用OkHttp、HttpClient等）发送请求。</li><li><strong>处理响应</strong>：Feign接收到HTTP响应后，使用<code>Decoder</code>将响应内容反序列化成接口方法的返回类型。</li></ol> 
<h4><a id="_794"></a>源码解析</h4> 
<p>下面是一个简化版的Feign工作原理的源码解析，显示了从接口定义到请求发送的主要步骤：</p> 
<pre><code class="prism language-java"><span class="token comment">// Step 1: 定义服务接口</span>
<span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span><span class="token string">"stores"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">StoreClient</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"/stores"</span><span class="token punctuation">)</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Store</span><span class="token punctuation">&gt;</span></span> <span class="token function">getStores</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Step 2: 创建Feign客户端实例</span>
<span class="token class-name">StoreClient</span> storeClient <span class="token operator">=</span> <span class="token class-name">Feign</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                               <span class="token punctuation">.</span><span class="token function">client</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OkHttpClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                               <span class="token punctuation">.</span><span class="token function">encoder</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GsonEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                               <span class="token punctuation">.</span><span class="token function">decoder</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GsonDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                               <span class="token punctuation">.</span><span class="token function">target</span><span class="token punctuation">(</span><span class="token class-name">StoreClient</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"http://localhost:8000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Step 3 &amp; 4: Feign的Builder会构建RequestTemplate并生成动态代理类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Feign</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Builder</span> <span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">target</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> apiType<span class="token punctuation">,</span> <span class="token class-name">String</span> url<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 省略了解析注解和创建RequestTemplate的复杂细节</span>
            <span class="token comment">// ...</span>
            
            <span class="token comment">// 创建动态代理</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>apiType<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span> apiType <span class="token punctuation">}</span><span class="token punctuation">,</span>
                    <span class="token keyword">new</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token annotation punctuation">@Override</span>
                        <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
                                <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
                            <span class="token comment">// 省略处理代码...</span>
                            
                            <span class="token comment">// 创建请求</span>
                            <span class="token class-name">Request</span> request <span class="token operator">=</span> <span class="token function">buildRequestFromTemplate</span><span class="token punctuation">(</span>template<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            
                            <span class="token comment">// 发送请求</span>
                            <span class="token class-name">Response</span> response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            
                            <span class="token comment">// 解码响应</span>
                            <span class="token keyword">return</span> <span class="token function">decode</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上述源码示例中，<code>Feign.builder()</code>部分用于创建Feign的客户端，并配置了它的编码器、解码器和HTTP客户端。Feign使用动态代理生成<code>StoreClient</code>的实现，在调用<code>getStores</code>方法时，Feign会根据注解信息生成HTTP请求，并通过配置好的客户端发送请求。</p> 
<p>Feign内部使用了几个关键组件来实现其功能：</p> 
<ul><li><strong>Contract</strong>：负责解析接口上的注解，生成元数据。</li><li><strong>RequestTemplate</strong>：存储HTTP请求所需的所有信息，如服务地址、HTTP方法、请求头和请求体。</li><li><strong>Client</strong>：是一个接口，负责发送HTTP请求。Feign可以使用不同的实现，如默认的Java HTTP连接、Apache HttpClient或OkHttp。</li><li><strong>Encoder</strong>：用于将方法参数等数据编码到请求体中。</li><li><strong>Decoder</strong>：用于将HTTP响应体解码为Java对象。</li><li><strong>InvocationHandlerFactory</strong>：创建动态代理的处理器，这个处理器负责将方法调用转化为HTTP请求。</li></ul> 
<p>在实际的Feign实现中，代码会更加复杂，因为它需要处理多种注解、请求参数、请求头、错误处理等各种场景。然而，上述代码和解释提供了一个关于Feign工作原理的简化视图。</p> 
<h3><a id="font_size4_colorFF0000Ribbonfont_859"></a><font size="4" color="##FF0000">Ribbon</font></h3> 
<p>Ribbon是Netflix开源的一个客户端负载均衡器，它可以在客户端程序中根据某种策略将请求分发到多个不同的服务实例。Ribbon通常与Eureka等服务发现组件配合使用，可以动态地从服务注册中心获取服务实例列表。</p> 
<h4><a id="Ribbon_862"></a>Ribbon的关键组件</h4> 
<ul><li><strong>IClientConfig</strong>：配置接口，存储客户端配置信息，如超时时间、重试次数等。</li><li><strong>ILoadBalancer</strong>：负载均衡器接口，主要实现类为<code>BaseLoadBalancer</code>，它包含了服务实例列表和负载均衡算法。</li><li><strong>IPing</strong>：健康检查接口，用于确定服务实例是否可用。</li><li><strong>IRule</strong>：负载均衡规则接口，包含了不同的负载均衡算法，如轮询、随机、响应时间权重等。</li></ul> 
<h4><a id="_869"></a>负载均衡算法</h4> 
<p>Ribbon提供了多种负载均衡算法，以下是一些常见的算法：</p> 
<ul><li><strong>RoundRobinRule</strong>：轮询策略，按顺序循环选择服务实例。</li><li><strong>RandomRule</strong>：随机策略，随机选择服务实例。</li><li><strong>WeightedResponseTimeRule</strong>：根据响应时间计算所有服务的权重，响应时间越快的实例权重越大，选择权重高的实例。</li><li><strong>BestAvailableRule</strong>：选择一个最小的并发请求的服务实例。</li></ul> 
<h4><a id="Ribbon_878"></a>Ribbon的工作流程</h4> 
<p>Ribbon的工作流程主要包含以下几个步骤：</p> 
<ol><li>在客户端配置Ribbon客户端，并指定负载均衡的策略。</li><li>客户端通过<code>LoadBalancerClient</code>发起请求。</li><li><code>ILoadBalancer</code>选择一个服务实例。</li><li>使用<code>IRule</code>决定使用哪个服务器。</li><li>发起实际的服务调用。</li></ol> 
<h4><a id="_888"></a>源码解析</h4> 
<p>以下是一个简化版的Ribbon工作原理的源码示例：</p> 
<pre><code class="prism language-java"><span class="token comment">// 配置Ribbon客户端</span>
<span class="token class-name">IClientConfig</span> ribbonClientConfig <span class="token operator">=</span> <span class="token class-name">DefaultClientConfigImpl</span><span class="token punctuation">.</span><span class="token function">getClientConfigWithDefaultValues</span><span class="token punctuation">(</span><span class="token string">"clientName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ILoadBalancer</span> loadBalancer <span class="token operator">=</span> <span class="token class-name">LoadBalancerBuilder</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">withClientConfig</span><span class="token punctuation">(</span>ribbonClientConfig<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">buildFixedServerListLoadBalancer</span><span class="token punctuation">(</span>servers<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 定义一个轮询策略</span>
<span class="token class-name">IRule</span> roundRobinRule <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RoundRobinRule</span><span class="token punctuation">(</span>loadBalancer<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用负载均衡器选取一个服务实例</span>
<span class="token class-name">Server</span> server <span class="token operator">=</span> roundRobinRule<span class="token punctuation">.</span><span class="token function">choose</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用RestTemplate或者其他HTTP客户端发送请求</span>
<span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"http://"</span> <span class="token operator">+</span> server<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> server<span class="token punctuation">.</span><span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"/"</span><span class="token punctuation">;</span>
<span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> response <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForEntity</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在这段代码中，我们创建了一个配置对象<code>IClientConfig</code>，然后创建了一个负载均衡器<code>ILoadBalancer</code>，并且提供了一个服务实例列表。接着，我们定义了一个轮询策略<code>IRule</code>。在发送请求时，我们使用<code>IRule</code>的<code>choose</code>方法来选取一个服务实例，然后构建请求URL，并使用<code>RestTemplate</code>发送请求。</p> 
<h4><a id="_912"></a>轮询算法示例</h4> 
<p>以轮询算法<code>RoundRobinRule</code>为例，下面简化的示例展示了它的工作原理：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RoundRobinRule</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractLoadBalancerRule</span> <span class="token punctuation">{<!-- --></span>
    
    <span class="token keyword">private</span> <span class="token class-name">AtomicInteger</span> nextServerCyclicCounter<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">RoundRobinRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        nextServerCyclicCounter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Server</span> <span class="token function">choose</span><span class="token punctuation">(</span><span class="token class-name">ILoadBalancer</span> lb<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>lb <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Server</span> server <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>server <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> count<span class="token operator">++</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Server</span><span class="token punctuation">&gt;</span></span> reachableServers <span class="token operator">=</span> lb<span class="token punctuation">.</span><span class="token function">getReachableServers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Server</span><span class="token punctuation">&gt;</span></span> allServers <span class="token operator">=</span> lb<span class="token punctuation">.</span><span class="token function">getAllServers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> upCount <span class="token operator">=</span> reachableServers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> serverCount <span class="token operator">=</span> allServers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>upCount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>serverCount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            
            <span class="token keyword">int</span> nextServerIndex <span class="token operator">=</span> <span class="token function">incrementAndGetModulo</span><span class="token punctuation">(</span>serverCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
            server <span class="token operator">=</span> allServers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>nextServerIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            <span class="token keyword">if</span> <span class="token punctuation">(</span>server <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            
            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span><span class="token function">isReadyToServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            
            server <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token keyword">return</span> server<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">incrementAndGetModulo</span><span class="token punctuation">(</span><span class="token keyword">int</span> modulo<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> current <span class="token operator">=</span> nextServerCyclicCounter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> next <span class="token operator">=</span> <span class="token punctuation">(</span>current <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> modulo<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextServerCyclicCounter<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的<code>RoundRobinRule</code>实现中，<code>choose</code>方法会根据当前的索引选择一个服务实例并返回。<code>incrementAndGetModulo</code>方法确保索引是循环递增的，且能在多线程环境中安全地使用。</p> 
<p>请注意，实际的Ribbon源码要复杂得多，它包含了更多的功能和异常处理逻辑。此外，随着Spring Cloud Netflix项目进入维护模式，Ribbon已经停止了更新，官方推荐使用其它替代方案，比如Spring Cloud的<code>LoadBalancerClient</code>或<code>Spring Cloud LoadBalancer</code>模块。</p> 
<h3><a id="font_size4_colorFF0000Nginxfont_979"></a><font size="4" color="##FF0000">Nginx</font></h3> 
<p>Nginx是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/SMTP代理服务器。Nginx以其高性能、稳定性、简单的配置文件和低资源消耗而闻名。在许多用例中，Nginx用作负载均衡器，通过分发网络流量到多个服务器，以提高网站、应用程序的总体性能和可靠性。</p> 
<h4><a id="Nginx_982"></a>Nginx的关键特性包括：</h4> 
<ul><li><strong>处理静态文件，索引文件以及自动索引</strong>；打开文件描述符缓存。</li><li><strong>反向代理</strong>；通过HTTP、HTTPS、FastCGI、uwsgi、SCGI、memcached或GRPC等协议支持负载均衡。</li><li><strong>负载均衡</strong>；使用不同策略分发流量（如轮询、最少连接、IP哈希等）。</li><li><strong>容错和健康检查</strong>；检测后端服务器是否健康，自动剔除不健康节点。</li><li><strong>缓存和压缩</strong>；减少数据传输量和响应延迟。</li><li><strong>认证</strong>；基本的HTTP认证以及与外部认证服务器的集成。</li><li><strong>重写和重定向</strong>；修改请求和应答。</li></ul> 
<h4><a id="Nginx_991"></a>Nginx内部工作原理</h4> 
<p>Nginx使用一个事件驱动的架构来高效地处理大量并发连接。其工作模式如下：</p> 
<ol><li><strong>主进程（master process）</strong>：读取和评估配置文件，维护一组工作进程（worker processes）。</li><li><strong>工作进程（worker processes）</strong>：处理实际的请求。Nginx的工作进程是多进程的，每个进程都是独立的，不需要线程间的锁定操作。</li></ol> 
<h4><a id="_997"></a>负载均衡策略</h4> 
<p>Nginx支持多种负载均衡策略，包括但不限于：</p> 
<ul><li><strong>轮询（Round Robin）</strong>：请求按时间顺序逐一分配到不同的后端服务器。</li><li><strong>最少连接（Least Connections）</strong>：优先分配给连接数最少的服务器。</li><li><strong>IP哈希（IP Hash）</strong>：根据请求的IP地址来分配，可以在同一用户的会话中保持对同一后端服务器的访问。</li></ul> 
<h4><a id="Nginx_1004"></a>Nginx源码概览</h4> 
<p>Nginx的源码是用C语言编写的，由于它的复杂性和灵活性，这里不会展示完整的源码。但是，我们可以简要查看与负载均衡相关的几个关键文件：</p> 
<ul><li><strong>ngx_http_upstream_round_robin.c</strong>：实现轮询负载均衡算法的源文件。</li><li><strong>ngx_http_upstream_least_conn.c</strong>：实现最少连接负载均衡算法的源文件。</li><li><strong>ngx_http_upstream_ip_hash.c</strong>：实现基于IP哈希的负载均衡算法的文件。</li></ul> 
<h4><a id="_1011"></a>负载均衡算法示例</h4> 
<p>下面是一个简化的例子，展示了Nginx如何在配置文件中定义轮询负载均衡：</p> 
<pre><code class="prism language-nginx">http {
    upstream myapp1 {
        server srv1.example.com;
        server srv2.example.com;
        server srv3.example.com;
    }

    server {
        location / {
            proxy_pass http://myapp1;
        }
    }
}
</code></pre> 
<p>在上述配置中，有一个<code>upstream</code>块定义了名为<code>myapp1</code>的服务器组，将请求按轮询的方式分发到三个后端服务器上。每个<code>server</code>指令代表了一个后端服务器的地址。</p> 
<h4><a id="_1032"></a>注意</h4> 
<p>由于Nginx是一个开源项目，其源码是公开的，但解析和理解整个Nginx源码需要深厚的C语言功底，对网络编程和操作系统多进程/多线程模型有较好的理解，并且它的代码库非常庞大。通常，负载均衡的相关逻辑会涉及到复杂的数据结构和算法，以及对底层系统调用的优化，这些都是Nginx性能优良的原因之一。如果有兴趣深入了解Nginx的源码，推荐直接参考其官方代码库和相关文档。</p> 
<h3><a id="font_size4_colorFF0000RibbonNginxfont_1035"></a><font size="4" color="##FF0000">Ribbon和Nginx</font></h3> 
<p>Ribbon和Nginx都可以用作系统中的负载均衡器，但它们的设计理念、运行环境和功能特性有显著差异。以下是Ribbon和Nginx的相同点和不同点的详细对比：</p> 
<h4><a id="_1038"></a>相同点</h4> 
<ol><li><strong>负载均衡功能</strong>：Ribbon和Nginx都提供了负载均衡功能，能够将客户端的请求分发到后端的多个服务器上。</li><li><strong>多种负载均衡策略</strong>：它们都支持多种负载均衡策略，如轮询、最少连接数等。</li><li><strong>服务消费者</strong>：在分布式系统中，Ribbon和Nginx都扮演服务消费者的角色，向服务提供者发起请求。</li></ol> 
<h4><a id="_1043"></a>不同点</h4> 
<ol><li> <p><strong>运行环境</strong>：</p> 
  <ul><li><strong>Ribbon</strong> 是一个客户端负载均衡库，它在客户端运行，通常与Spring Cloud和Netflix OSS配合使用，适用于微服务架构。</li><li><strong>Nginx</strong> 是一个服务器端的反向代理服务器，通常作为独立的进程在服务器上运行，能够处理HTTP、HTTPS请求，也可以作为邮件代理服务器。</li></ul> </li><li> <p><strong>架构位置</strong>：</p> 
  <ul><li><strong>Ribbon</strong> 是进程内的负载均衡器，它是以库的形式存在于每个服务消费者的应用程序中。</li><li><strong>Nginx</strong> 作为外部代理运行，独立于应用程序，通常部署在应用服务器的前端。</li></ul> </li><li> <p><strong>语言和集成</strong>：</p> 
  <ul><li><strong>Ribbon</strong> 是用Java编写的，易于与Java应用程序集成，特别是在Spring Cloud生态系统中。</li><li><strong>Nginx</strong> 是用C编写的，配置通常通过编辑其文本配置文件完成，与应用程序语言无关。</li></ul> </li><li> <p><strong>功能性</strong>：</p> 
  <ul><li><strong>Ribbon</strong> 只提供了HTTP客户端的负载均衡功能，需要与其他组件如Eureka搭配使用，进行服务发现。</li><li><strong>Nginx</strong> 是一个全功能的Web服务器，提供了静态内容的服务、反向代理、缓存、SSL终端、gzip压缩和Web应用防火墙等功能。</li></ul> </li><li> <p><strong>高可用性和伸缩性</strong>：</p> 
  <ul><li><strong>Ribbon</strong> 的设计理念是在客户端实现智能路由，这就要求客户端能够动态感知后端服务的变化。</li><li><strong>Nginx</strong> 可以通过配置upstream模块实现高可用性和伸缩性，但更新配置通常需要重新加载配置文件。</li></ul> </li><li> <p><strong>动态性</strong>：</p> 
  <ul><li><strong>Ribbon</strong> 可以实时地从服务注册中心获取服务列表，并且可以在运行时更改其负载均衡策略。</li><li><strong>Nginx</strong> 的配置相对静态，虽然也可以通过服务发现机制动态更新服务列表，但这常需要额外的模块支持和更复杂的配置。</li></ul> </li></ol> 
<p>总结来说，Ribbon是一个面向服务消费者的库，在客户端提供负载均衡；而Nginx是一个功能更为丰富的服务器端代理和Web服务器，不仅提供负载均衡，还提供了其他的网络层和应用层的服务。在微服务架构中，Ribbon通常用于客户端负载均衡，而Nginx更多用作入口网关，提供路由、认证、SSL终端等功能。</p> 
<h3><a id="font_size4_colorFF000011RibbonFeignOpenFeignfont_1070"></a><font size="4" color="##FF0000">11、Ribbon、Feign和OpenFeign的区别</font></h3> 
<p>Ribbon、Feign和OpenFeign都是微服务架构中用于服务间调用的工具，它们各自有着不同的特点和用途。在Spring Cloud微服务架构中，这些工具通常被用于实现客户端负载均衡、服务声明和服务调用。</p> 
<h4><a id="Ribbon_1073"></a>Ribbon</h4> 
<p>Ribbon 是一个客户端负载均衡器，它提供了一系列的配置项如连接超时、重试等，可以与服务发现组件如Eureka结合使用。Ribbon的主要作用是在客户端实现对于多个服务实例的负载均衡。当服务消费者调用服务提供者时，Ribbon可以根据特定的负载均衡算法（如轮询、随机等）从服务注册中心获取服务列表，然后选择一个服务实例进行调用。</p> 
<p>Ribbon主要特点：</p> 
<ul><li>客户端负载均衡</li><li>支持多种负载均衡策略</li><li>可以和Eureka等服务发现工具联合使用</li><li>配置熔断机制，提高系统的弹性</li><li>直接与HTTP客户端整合，如Apache HttpClient和OkHttp</li></ul> 
<h4><a id="Feign_1083"></a>Feign</h4> 
<p>Feign 是一个声明式的Web服务客户端，让编写Web服务客户端变得更加简单。它的目标是通过简化HTTP API客户端的编程工作来减少开发者的负担。使用Feign时，开发者只需要创建一个接口并注解它，Feign会自动处理方法的实现。</p> 
<p>Feign的主要特点：</p> 
<ul><li>声明式的服务调用客户端，易于使用</li><li>支持可插拔的注解特性，包括Feign注解和JAX-RS注解</li><li>支持可插拔的HTTP编码器和解码器</li><li>支持Hystrix和它的熔断器</li><li>使用反射方式根据注解和接口生成请求模板和实现</li></ul> 
<h4><a id="OpenFeign_1093"></a>OpenFeign</h4> 
<p>OpenFeign是Spring Cloud在Feign的基础上支持的一个库，它使用Spring MVC的注解来实现Feign的HTTP请求，使得编写HTTP客户端更加方便。实质上，OpenFeign是Feign的进一步封装，它整合了Spring Cloud的特性，使得Feign的使用更加容易和规范化。</p> 
<p>OpenFeign的主要特点：</p> 
<ul><li>集成了Ribbon，使用Ribbon作为客户端负载均衡工具</li><li>支持和Eureka等服务发现组件自动集成</li><li>通过提供一系列的Spring Cloud注解简化了HTTP客户端的开发</li><li>可以使用Spring MVC的注解来定义服务绑定</li><li>支持服务熔断的能力，通过整合Hystrix实现</li></ul> 
<h4><a id="Ribbon__FeignOpenFeign_1103"></a>Ribbon 与 Feign/OpenFeign的关系</h4> 
<ul><li>Ribbon通常作为底层的客户端负载均衡工具，可以单独使用，也可以被Feign或OpenFeign使用。</li><li>Feign和OpenFeign通常用于定义HTTP客户端的接口，它们也会使用Ribbon来实现对服务提供者的调用。</li><li>OpenFeign是对Feign的增强，提供了更紧密的Spring Cloud集成，主要是通过支持Spring MVC的注解来简化了Feign的使用。</li></ul> 
<p>总的来说，Ribbon、Feign和OpenFeign都是在微服务架构下进行服务间通信的工具，它们可以组合使用。Ribbon提供了客户端的负载均衡能力，而Feign提供了简洁的HTTP客户端声明，OpenFeign则在Feign的基础上提供了更好的Spring Cloud集成支持。</p> 
<h3><a id="font_size4_colorFF000012font_1109"></a><font size="4" color="##FF0000">12、红黑树</font></h3> 
<p>红黑树（Red-Black Tree）是一种自平衡二叉查找树，它在插入和删除操作时通过特定的旋转和重新着色来保持树的平衡，从而保证了最坏情况下的时间复杂度为O(log n)。红黑树的每个节点都包含一个颜色属性，可以是红色或黑色，并且树必须满足以下性质：</p> 
<ol><li>每个节点要么是红的，要么是黑的。</li><li>根节点是黑的。</li><li>每个叶子节点（NIL节点，空节点）是黑的。</li><li>如果一个节点是红的，那么它的两个子节点都是黑的（红色节点不能相邻）。</li><li>对于每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点。</li></ol> 
<p>这些性质确保了从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。因此，红黑树是相对接近平衡的二叉树。</p> 
<h4><a id="_1120"></a>源码实现</h4> 
<p>红黑树的源码实现通常包含节点的定义、旋转操作、插入操作、删除操作等。下面是一个简化的红黑树节点的定义和旋转操作的示例，这里以C语言为例：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>left<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>right<span class="token punctuation">;</span>
    <span class="token keyword">int</span> color<span class="token punctuation">;</span> <span class="token comment">// 1 -&gt; Red, 0 -&gt; Black</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 左旋转示例</span>
<span class="token keyword">void</span> <span class="token function">leftRotate</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>y <span class="token operator">=</span> x<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
    x<span class="token operator">-&gt;</span>right <span class="token operator">=</span> y<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token operator">-&gt;</span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        y<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>parent <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    y<span class="token operator">-&gt;</span>parent <span class="token operator">=</span> x<span class="token operator">-&gt;</span>parent<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-&gt;</span>parent <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token operator">*</span>root <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> x<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        x<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>left <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        x<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>right <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    y<span class="token operator">-&gt;</span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>
    x<span class="token operator">-&gt;</span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 右旋转示例</span>
<span class="token keyword">void</span> <span class="token function">rightRotate</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>x <span class="token operator">=</span> y<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
    y<span class="token operator">-&gt;</span>left <span class="token operator">=</span> x<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-&gt;</span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        x<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    x<span class="token operator">-&gt;</span>parent <span class="token operator">=</span> y<span class="token operator">-&gt;</span>parent<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token operator">-&gt;</span>parent <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token operator">*</span>root <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> y<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        y<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>right <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        y<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    x<span class="token operator">-&gt;</span>right <span class="token operator">=</span> y<span class="token punctuation">;</span>
    y<span class="token operator">-&gt;</span>parent <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_1171"></a>插入操作</h4> 
<p>插入操作包括两个主要步骤：标准的二叉查找树插入和红黑树修复。以下是插入操作后可能需要进行的一些修复操作的简化示例：</p> 
<ol><li><strong>重新着色</strong>：如果一个父节点和一个叔叔节点都是红色的，则改变它们的颜色。</li><li><strong>旋转</strong>：如果父节点是红色，但叔叔节点是黑色或不存在，可能需要进行旋转。</li></ol> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">insertFixUp</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>z<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 当前节点的父节点是红色</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>z <span class="token operator">!=</span> <span class="token operator">*</span>root <span class="token operator">&amp;&amp;</span> z<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>color <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>z<span class="token operator">-&gt;</span>parent <span class="token operator">==</span> z<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>y <span class="token operator">=</span> z<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token operator">-&gt;</span>color <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 叔叔节点是红色，只需进行重新着色</span>
                z<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>color <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                y<span class="token operator">-&gt;</span>color <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                z<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>color <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                z <span class="token operator">=</span> z<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>parent<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>z <span class="token operator">==</span> z<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// 当前节点是其父节点的右子节点，左旋</span>
                    z <span class="token operator">=</span> z<span class="token operator">-&gt;</span>parent<span class="token punctuation">;</span>
                    <span class="token function">leftRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 进行右旋</span>
                z<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>color <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                z<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>color <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token function">rightRotate</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> z<span class="token operator">-&gt;</span>parent<span class="token operator">-&gt;</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 对称操作...</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token operator">-&gt;</span>color <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 根节点必须是黑色</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码是高度抽象的，实际的红黑树实现要考虑更多的边界条件。此外，删除操作比插入操作更复杂，因为它可能会破坏红黑树的更多性质，需要进行更多的修复工作。</p> 
<p>在现代编程语言如Java或C++中，标准库通常提供了红黑树的实现，例如Java中的<code>TreeMap</code>和<code>TreeSet</code>，C++ STL中的<code>map</code>、<code>multimap</code>、<code>set</code>和<code>multiset</code>。</p> 
<p>请注意，红黑树的完整实现需要处理许多特殊的情况，需要对算法和数据结构有深入了解。如果有兴趣深入学习红黑树的源码实现，可以查看相关开源项目或教科书中的示例代码。</p> 
<h3><a id="font_size4_colorFF000013Springfont_1220"></a><font size="4" color="##FF0000">13、Spring</font></h3> 
<p><strong>Spring的核心特性是什么？Spring优点？</strong></p> 
<p>Spring的核心是控制反转（IoC）和面向切面（AOP）</p> 
<p>Spring优点：</p> 
<p>（1）方便解耦，简化开发 （高内聚低耦合）</p> 
<p>Spring就是一个大工厂（容器），可以将所有对象创建和依赖关系维护，交给Spring管理</p> 
<p>spring工厂是用于生成bean</p> 
<p>（2）AOP编程的支持</p> 
<p>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能</p> 
<p>（3） 声明式事务的支持</p> 
<p>只需要通过配置就可以完成对事务的管理，而无需手动编程</p> 
<p>（4） 方便程序的测试</p> 
<p>Spring对Junit4支持，可以通过注解方便的测试Spring程序</p> 
<p>（5）方便集成各种优秀框架</p> 
<p>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz等）的直接支持</p> 
<p>（6） 降低JavaEE API的使用难度</p> 
<p>Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低</p> 
<p>spring框架中需要引用哪些jar包，以及这些jar包的用途<br> 4 + 1 ： 4个核心（beans、core、context、expression） + 1个依赖（commons-loggins…jar）</p> 
<p><strong>理解AOP、IoC的基本原理</strong></p> 
<p>**IOC：控制反转（IoC）与依赖注入（DI）**是同一个概念，<br> 控制反转的思想：</p> 
<p>传统的 java 开发模式中，当需要一个对象时，我们会自己使用 new 或者 getInstance 等直接或者间接调用构造方法创建一个对象。</p> 
<p>而在 spring 开发模式中，spring 容器使用了工厂模式为我们创建了所需要的对象，不需要我们自己创建了，直接调用 spring 提供的对象就可以了</p> 
<p><strong>引入IOC的目的：</strong></p> 
<p>（1）脱开、降低类之间的耦合；</p> 
<p>（2）倡导面向接口编程、实施依赖倒换原则；</p> 
<p>（3）提高系统可插入、可测试、可修改等特性</p> 
<p><strong>AOP：面向切面编程（AOP）</strong></p> 
<p>面向切面编程思想：</p> 
<p>在面向对象编程（oop）思想中，我们将事物纵向抽成一个个的对象。而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个切面，对这个切面进行一些如权限控制、事物管理，记录日志等公用操作处理的过程。</p> 
<p>切面：简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p> 
<p>AOP 底层：动态代理。</p> 
<p>如果是接口采用 JDK 动态代理，如果是类采用CGLIB 方式实现动态代理。</p> 
<p><strong>AOP的一些场景应用；</strong></p> 
<p>Authentication 权限</p> 
<p>Caching 缓存</p> 
<p>Context passing 内容传递</p> 
<p>Error handling 错误处理</p> 
<p>Lazy loading　懒加载</p> 
<p>Debugging　　调试</p> 
<p>logging, tracing, profiling and monitoring　记录跟踪　优化　校准</p> 
<p>Performance optimization　性能优化</p> 
<p>Persistence　　持久化</p> 
<p>Resource pooling　资源池</p> 
<p>Synchronization　同步</p> 
<p>Transactions 事务</p> 
<p><strong>spring注入的几种方式</strong></p> 
<p>（1）构造方法注入</p> 
<p>（2）setter注入</p> 
<p>（3）基于注解</p> 
<p><strong>Spring中自动装配的方式有哪些</strong></p> 
<p>no：不进行自动装配，手动设置Bean的依赖关系。</p> 
<p>byName：根据Bean的名字进行自动装配。</p> 
<p>byType：根据Bean的类型进行自动装配。</p> 
<p>constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。</p> 
<p>autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。</p> 
<p>（自动装配没有自定义装配方式那么精确，而且不能自动装配简单属性（基本类型、字符串等），在使用时应注意。）</p> 
<p><strong>@Resource 和 @Autowired 区别？分别用在什么场景？</strong></p> 
<p>（1）共同点：两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p> 
<p>（2）不同点：</p> 
<p>@Autowired</p> 
<p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p> 
<p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。</p> 
<p>@Resource</p> 
<p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。</p> 
<p>@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。</p> 
<p>如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p> 
<h3><a id="font_size4_colorFF000014sessionfont_1361"></a><font size="4" color="##FF0000">14、session何时被删除</font></h3> 
<p>在Web应用程序中，会话（Session）是用来存储用户会话所需数据的一种方式。它允许服务器在多个请求之间维护用户状态。Session的删除或失效主要有以下几种情况：</p> 
<ol><li> <p><strong>超时</strong>：大多数Web应用程序框架和服务器都有一种机制来设置会话的超时时间。如果用户在指定时间内没有进行新的请求，会话就会到期并自动删除。默认的超时时间因技术栈不同而异，例如，在Java的Servlet API中，默认的超时时间通常为30分钟。</p> </li><li> <p><strong>手动删除</strong>：应用程序代码可以主动调用特定的方法来删除会话。例如，在Java中，可以通过<code>HttpSession.invalidate()</code>方法来失效一个会话。</p> </li><li> <p><strong>服务器重启</strong>：如果服务器或应用程序重启，未持久化的会话信息通常会丢失。但一些服务器和框架支持会话持久化，可以在重启后恢复会话。</p> </li><li> <p><strong>浏览器关闭</strong>：在某些情况下，如果会话依赖于客户端的cookie来维护，那么关闭浏览器可能会删除这些cookie，从而终止会话。这取决于cookie的类型，如果是会话cookie（不设置过期时间），则浏览器关闭时通常会被删除。</p> </li><li> <p><strong>会话存储清理</strong>：为了防止服务器上的会话存储变得过大，许多Web服务器都会定期清理旧的或不活跃的会话。</p> </li><li> <p><strong>用户登出</strong>：在用户主动登出应用程序时，通常会程序性地结束用户的会话，来保护用户的安全。</p> </li><li> <p><strong>容量限制</strong>：如果应用程序设置了会话存储的容量限制，一旦达到这个限制，一些旧的会话可能会被删除，以便为新会话腾出空间。</p> </li><li> <p><strong>会话替换策略</strong>：在一些高负载的系统中，为了保证性能和资源使用，可能会实现某种会话替换策略，例如LRU（最近最少使用）算法，会自动删除最不活跃的会话。</p> </li></ol> 
<h4><a id="_1380"></a>实现细节</h4> 
<p>在不同的语言和框架中，会话的超时和删除的实现方式可能会有所不同。以下是一些常见的实现细节：</p> 
<ul><li><strong>Java Servlet API</strong>：可以在web.xml中或通过<code>HttpSession</code> API设置会话超时。</li><li><strong>ASP.NET</strong>：可以在Web.config文件或通过代码设置会话状态。</li><li><strong>PHP</strong>：可以在php.ini文件、通过<code>session_set_cookie_params()</code>或在代码中设置会话超时。</li><li><strong>Node.js</strong>：在使用Express框架及其中间件如express-session时，可以配置会话的存储、超时和删除策略。</li></ul> 
<h4><a id="_1388"></a>代码示例</h4> 
<p>以下是Java Servlet API中设置会话超时的代码示例：</p> 
<pre><code class="prism language-java"><span class="token class-name">HttpSession</span> session <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
session<span class="token punctuation">.</span><span class="token function">setMaxInactiveInterval</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token operator">*</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置会话超时时间为30分钟</span>
</code></pre> 
<p>会话超时是Web应用程序安全的重要方面之一，但设置超时值时需要在用户体验和安全性之间做出权衡。如果超时太短，用户可能会因为频繁的重新登录而感到不便；如果超时太长，又可能增加未授权访问的风险。</p> 
<h3><a id="font_size4_colorFF000015font_1397"></a><font size="4" color="##FF0000">15、线程池</font></h3> 
<p>线程池的7个核心参数如下：</p> 
<p><strong>1、核心线程数（CorePoolSize）</strong>：线程池中所拥有的线程数，即使线程处于空闲状态，也会一直存在，除非设置了allowCoreThreadTimeOut参数。</p> 
<p><strong>2、最大线程数（MaximumPoolSize）</strong>：线程池中所允许的最大线程数，当任务数超过了核心线程数并且工作队列已满时，线程池就会创建新的线程来执行任务，直到最大线程数达到上限。</p> 
<p><strong>3、线程空闲时间（keepAliveTime）</strong>：当线程池中的线程数量超过了核心线程数时，如果这些线程在指定的时间内没有执行任务，那么这些线程就会被回收，直到线程池中的线程数等于核心线程数。</p> 
<p><strong>4、时间单位（unit）</strong>：用于指定线程空闲时间的时间单位，例如毫秒、秒、分钟等。</p> 
<p><strong>5、工作队列（workQueue）</strong>：用于存放等待执行的任务的阻塞队列，当线程池中的线程已满时，新的任务会被存放到工作队列中等待执行。</p> 
<p><strong>6、线程工厂（threadFactory）</strong>：用于创建新的线程，可以自定义线程的名称、优先级、是否为守护线程等属性。</p> 
<p><strong>7、饱和策略（handler）</strong>：当线程池和工作队列都已满时，用于处理新的任务的策略，常见的策略有直接抛出异常、丢弃任务、丢弃队列中最早的任务、将任务分配给调用线程来执行等。<br> 线程的生命周期</p> 
<p>线程池饱和策略是指当线程池中所有线程都在工作且工作队列也已经满了时，新提交的任务该如何处理。常见的线程池饱和策略包括：</p> 
<p><strong>线程池的拒绝策略</strong></p> 
<p><strong>1.ThreadPoolExecutor.AbortPolicy （使用最好使用默认的拒绝策略。）</strong><br> 线程池的默认拒绝策略为AbortPolicy，即丢弃任务并抛出RejectedExecutionException异常（即后面提交的请求不会放入队列也不会直接消费并抛出异常）；</p> 
<p><strong>2.ThreadPoolExecutor.DiscardPolicy</strong><br> 丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃（也不会抛出任何异常，任务直接就丢弃了）。</p> 
<p><strong>3.ThreadPoolExecutor.DiscardOldestPolicy</strong><br> 丢弃队列最前面的任务，然后重新提交被拒绝的任务（丢弃掉了队列最前的任务，并不抛出异常，直接丢弃了）。</p> 
<p><strong>4.ThreadPoolExecutor.CallerRunsPolicy</strong><br> 由调用线程处理该任务（不会丢弃任务，最后所有的任务都执行了，并不会抛出异常）</p> 
<p><img src="https://images2.imgbox.com/d0/43/LsLEdgs0_o.png" alt="在这里插入图片描述"><br> <strong>线程池工作原理：</strong><br> <img src="https://images2.imgbox.com/cf/6d/hE4OH9MY_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="font_size4_colorFF000016JSP9font_1438"></a><font size="4" color="##FF0000">16、JSP有9个内置对象</font></h3> 
<p><strong>JSP有9个内置对象：</strong></p> 
<ul><li>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</li><li>response：封装服务器对客户端的响应；</li><li>pageContext：通过该对象可以获取其他对象；</li><li>session：封装用户会话的对象；</li><li>application：封装服务器运行环境的对象；</li><li>out：输出服务器响应的输出流对象；</li><li>config：Web应用的配置对象；</li><li>page：JSP页面本身（相当于Java程序中的this）；</li><li>exception：封装页面抛出异常的对象。<br> <img src="https://images2.imgbox.com/66/9b/iBAlgVC1_o.png" alt="在这里插入图片描述"><br> <strong>四大域对象: page&lt;request&lt;session&lt;application</strong></li></ul> 
<p>JSP中的四种作用域分别是：</p> 
<p>page作用域：在当前JSP页面中有效，即只能在当前JSP页面的任何地方访问。可以使用pageContext对象来访问page作用域中的变量。</p> 
<p>request作用域：在同一个HTTP请求中有效，即在同一个请求中的所有JSP页面和Servlet之间共享。可以使用request对象来访问request作用域中的变量。</p> 
<p>session作用域：在同一个HTTP会话中有效，即在同一个浏览器会话期间的所有请求之间共享。可以使用session对象来访问session作用域中的变量。</p> 
<p>application作用域：在整个Web应用程序中有效，即在所有JSP页面和Servlet之间共享。可以使用application对象来访问application作用域中的变量。</p> 
<p><strong>Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁</strong></p> 
<h3><a id="font_size4_colorFF000017font_1467"></a><font size="4" color="##FF0000">17、修饰代码块时，执行的顺序</font></h3> 
<p><strong>修饰代码块时，执行的顺序</strong></p> 
<p>（加载的顺序）如下：</p> 
<p>父类静态变量<br> 父类静态代码块<br> 子类静态变量<br> 子类静态代码块<br> 父类普通变量<br> 父类普通代码块<br> 父类构造函数<br> 子类普通变量<br> 子类普通代码块<br> 子类构造函数</p> 
<p>总结一下就是，静态的先被加载（在这个基础上，父类优先于子类，在父类优先于子类的基础上，变量优先于代码块优先于构造函数（有的话））</p> 
<h3><a id="font_size4_colorFF000018Mysqlfont_1485"></a><font size="4" color="##FF0000">18、Mysql</font></h3> 
<p><strong>什么是慢查询？</strong><br> 所有执行时间超过 long_query_time 秒的所有查询或不适用于索引的查询。</p> 
<p>long_query_time默认时间是10秒，即超过10秒的查询都认为是慢查询。</p> 
<p><strong>当创建(a,b,c)复合索引时，想要索引生效的话，只能使用 a和ab、ac和abc三种组合！</strong></p> 
<p><strong>回表就是先通过数据库索引扫描出数据所在的行，再通过行主键id取出索引中未提供的数据，即基于非主键索引的查询需要多扫描一棵索引树.<br> 回表查询，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。</strong></p> 
<p><strong>聚集索引和非聚集索引的根本区别是表记录的排列顺序与索引的排列顺序是否一致</strong></p> 
<p><strong>聚集索引</strong><br> 聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。</p> 
<p><strong>非聚集索引</strong><br> 非聚集索引制定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。</p> 
<p>mysql引擎<br> <img src="https://images2.imgbox.com/63/90/V6mI1saV_o.png" alt="在这里插入图片描述"><br> <strong>MySQL</strong><br> Innodb引擎，Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。</p> 
<p>它的设计的目标就是处理大数据容量的数据库系统。它本身实际上是基于Mysql后台的完整的系统。</p> 
<p>Mysql运行的时候，Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是，该引擎是不支持全文搜索的。</p> 
<p>同时，启动也比较的慢，它是不会保存表的行数的。当进行Select count(*) from table指令的时候，需要进行扫描全表。</p> 
<p>所以当需要使用数据库的事务时，该引擎就是首选。由于锁的粒度小，写操作是不会锁定全表的。所以在并发度较高的场景下使用会提升效率的。</p> 
<p>MyIASM引擎，它是MySql的默认引擎，但不提供事务的支持，也不支持行级锁和外键。</p> 
<p>因此当执行Insert插入和Update更新语句时，即执行写操作的时候需要锁定这个表。所以会导致效率会降低。</p> 
<p>不过和Innodb不同的是，MyIASM引擎是保存了表的行数，于是当进行Select count(*) from table语句时，可以直接的读取已经保存的值而不需要进行扫描全表。</p> 
<p>所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的。可以将MyIASM作为数据库引擎的首先。</p> 
<p>c.大容量的数据集时趋向于选择Innodb。因为它支持事务处理和故障的恢复。Innodb可以利用数据日志来进行数据的恢复。主键的查询在Innodb也是比较快的。</p> 
<p>d.大批量的插入语句时（这里是INSERT语句）在MyIASM引擎中执行的比较的快，但是UPDATE语句在Innodb下执行的会比较的快，尤其是在并发量大的时候。</p> 
<p><strong>oracle</strong><br> oracle中不存在引擎的概念，数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。</p> 
<p>OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。</p> 
<p>OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。</p> 
<p>OLTP 系统强调数据库内存效率，强调内存各种指标的命令率，强调绑定变量，强调并发操作；</p> 
<p>OLAP 系统则强调数据分析，强调SQL执行市场，强调磁盘I/O，强调分区等。</p> 
<p>MyIASM引擎，它是MySql的默认引擎，但不提供事务的支持，也不支持行级锁和外键。</p> 
<p>Innodb引擎，Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。</p> 
<p>MySQL默认是自动提交</p> 
<p>Oracle默认不自动提交，需要用户手动提交，需要在写commit;指令或者点击commit按钮</p> 
<p><strong>mysql的默认隔离可重复读，Oracle的默认隔离读已提交</strong> 互联网项目将隔离级别设为读已提交</p> 
<p><strong>浅克隆</strong>： 被Clone的对象的所有变量都含有原来对象相同的值，而引用变量还是原来对用的引用【拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。】</p> 
<p><strong>深克隆：</strong> 被克隆对象的所有变量都含有原来的对象相同的值，引用变量也重新复制了一份【不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象】</p> 
<p><strong>CAS 实现：</strong><br> Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。</p> 
<p>**版本号控制：**一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。</p> 
<p>当数据被修改时，version 值会+1。当线程A要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p> 
<p>Oracle数据库可以以字节或者字符来存储字符串的，一般来说默认是存储字节<br> UTF-8：一个汉字 = 3个字节，英文一个字母占用一个字节<br> GBK： 一个汉字 = 2个字节，英文一个字母占用一个字节</p> 
<p>总结：oracle 中varchar2(10) 既10个字节3个汉字<br> mysql 中varchar(10) 既10个字符10个汉字</p> 
<p><strong>锁</strong><br> Synchronized，它就是一个：非公平，悲观，独享，互斥，可重入的重量级锁<br> ReentrantLock，它是一个：默认非公平但可实现公平的，悲观，独享，互斥，可重入，重量级锁。<br> ReentrantReadWriteLocK，它是一个，默认非公平但可实现公平的，悲观，写独享，读共享，读写，可重入，重量级锁。</p> 
<p><strong>http和https区别 ssl证书加密</strong></p> 
<h3><a id="font_size4_colorFF000019RabbitMQfont_1577"></a><font size="4" color="##FF0000">19、RabbitMQ</font></h3> 
<p><strong>RabbitMQ消息堆积怎么处理？</strong><br> 答：<br> 增加消费者的处理能力(例如优化代码)，或减少发布频率<br> 单纯升级硬件不是办法，只能起到一时的作用</p> 
<p>考虑使用队列最大长度限制，RabbitMQ 3.1支持<br> 给消息设置年龄，超时就丢弃</p> 
<p>默认情况下，rabbitmq消费者为单线程串行消费，设置并发消费两个关键属性concurrentConsumers和prefetchCount，concurrentConsumers设置的是对每个listener在初始化的时候设置的并发消费者的个数，prefetchCount是每次一次性从broker里面取的待消费的消息的个数</p> 
<p>建立新的queue，消费者同时订阅新旧queue</p> 
<p>生产者端缓存数据，在mq被消费完后再发送到mq</p> 
<p>打破发送循环条件，设置合适的qos值，当qos值被用光，而新的ack没有被mq接收时，就可以跳出发送循环，去接收新的消息；</p> 
<p>消费者主动block接收进程，消费者感受到接收消息过快时主动block，利用block和unblock方法调节接收速率，当接收线程被block时，跳出发送循环。</p> 
<p>新建一个topic，partition是原来的10倍；然后写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue；</p> 
<p>接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据；等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的consumer机器来消费消息；</p> 
<p><strong>RabbitMQ的消息丢失解决方案？</strong><br> 答：<br> 消息持久化：Exchange 设置持久化：durable:true；Queue 设置持久化；Message持久化发送。<br> ACK确认机制：消息发送确认；消息接收确认。</p> 
<p>常见6种负载均衡算法：轮询，随机，源地址哈希，加权轮询，加权随机，最小连接数。<br> nginx5种负载均衡算法：轮询，weight，ip_hash，fair（响应时间），url_hash<br> dubbo负载均衡算法：随机，轮询，最少活跃调用数，一致性Hash</p> 
<p><strong>竞态条件</strong>：指设备或系统出现不恰当的执行时序，而得到不正确的结果。</p> 
<p>G1垃圾收集参数 -XX:MaxGCPauseMillis=N,（默认200毫秒，与throughput收集器有所不同）<br> 吞吐量跟MaxGCPauseMillis之间做一个平衡。如果MaxGCPauseMillis设置的过小，那么GC就会频繁，吞吐量就会下降。如果MaxGCPauseMillis设置的过大，应用程序暂停时间就会变长。G1的默认暂停时间是200毫秒，我们可以从这里入手，调整合适的时间。<br> <img src="https://images2.imgbox.com/c3/99/RqS5CyBC_o.png" alt="在这里插入图片描述"></p> 
<p>TDD：测试驱动开发（Test-Driven Development）<br> BDD：行为驱动开发（Behavior Driven Development）<br> ATDD：验收测试驱动开发（Acceptance Test Driven Development）<br> DDD：领域驱动开发（Domain Drive Design）</p> 
<h3><a id="font_size4_colorFF000020font_1623"></a><font size="4" color="##FF0000">20、粘包、拆包</font></h3> 
<p><strong>粘包、拆包发生原因</strong></p> 
<p>1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。</p> 
<p>2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。</p> 
<p>3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。</p> 
<p>4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</p> 
<p><strong>粘包、拆包解决办法</strong></p> 
<p>通过以上分析，我们清楚了粘包或拆包发生的原因，那么如何解决这个问题呢？</p> 
<p>解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个：</p> 
<p>1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</p> 
<p>2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</p> 
<p>3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</p> 
<h3><a id="font_size4_colorFF000021XSSSQLCSRFfont_1646"></a><font size="4" color="##FF0000">21、什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？</font></h3> 
<ul><li><strong>XSS</strong>（Cross Site Script，跨站脚本攻击）是向网页中注入恶意脚本在用户浏览网页时在用户浏览器中执行恶意脚本的攻击方式。</li></ul> 
<p>跨站脚本攻击分有两种形式：</p> 
<p>反射型攻击（诱使用户点击一个嵌入恶意脚本的链接以达到攻击的目标，目前有很多攻击者利用论坛、微博发布含有恶意脚本的URL就属于这种方式）</p> 
<p>持久型攻击（将恶意脚本提交到被攻击网站的数据库中，用户浏览网页时，恶意脚本从数据库中被加载到页面执行，QQ邮箱的早期版本就曾经被利用作为持久型跨站脚本攻击的平台）。</p> 
<p>XSS虽然不是什么新鲜玩意，但是攻击的手法却不断翻新，防范XSS主要有两方面：消毒（对危险字符进行转义）和HttpOnly（防范XSS攻击者窃取Cookie数据）。</p> 
<ul><li><strong>SQL注入攻击</strong>是注入攻击最常见的形式（此外还有OS注入攻击（Struts 2的高危漏洞就是通过OGNL实施OS注入攻击导致的）），当服务器使用请求参数构造SQL语句时，恶意的SQL被嵌入到SQL中交给数据库执行。</li></ul> 
<p>SQL注入攻击需要攻击者对数据库结构有所了解才能进行，攻击者想要获得表结构有多种方式：</p> 
<p>（1）如果使用开源系统搭建网站，数据库结构也是公开的（目前有很多现成的系统可以直接搭建论坛，电商网站，虽然方便快捷但是风险是必须要认真评估的）；</p> 
<p>（2）错误回显（如果将服务器的错误信息直接显示在页面上，攻击者可以通过非法参数引发页面错误从而通过错误信息了解数据库结构，Web应用应当设置友好的错误页，一方面符合最小惊讶原则，一方面屏蔽掉可能给系统带来危险的错误回显信息）；</p> 
<p>（3）盲注。防范SQL注入攻击也可以采用消毒的方式，通过正则表达式对请求参数进行验证，此外，参数绑定也是很好的手段，这样恶意的SQL会被当做SQL的参数而不是命令被执行，JDBC中的PreparedStatement就是支持参数绑定的语句对象，从性能和安全性上都明显优于Statement。</p> 
<ul><li><strong>CSRF攻击</strong>（Cross Site Request Forgery，跨站请求伪造）是攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。</li></ul> 
<p>CSRF的原理是利用浏览器的Cookie或服务器的Session，盗取用户身份.</p> 
<p>防范CSRF的主要手段是识别请求者的身份，主要有以下几种方式：</p> 
<p>（1）在表单中添加令牌（token）；</p> 
<p>（2）验证码；</p> 
<p>（3）检查请求头中的Referer（前面提到防图片盗链接也是用的这种方式）。</p> 
<p>令牌和验证都具有一次消费性的特征，因此在原理上一致的，但是验证码是一种糟糕的用户体验，不是必要的情况下不要轻易使用验证码，目前很多网站的做法是如果在短时间内多次提交一个表单未获得成功后才要求提供验证码，这样会获得较好的用户体验。</p> 
<h3><a id="font_size4_colorFF000022ClassforNameclassloaderfont_1682"></a><font size="4" color="##FF0000">22、反射中，Class.forName和classloader的区别</font></h3> 
<p>在Java反射机制中，<code>Class.forName()</code>和类加载器（ClassLoader）都可以用来加载类，但它们之间存在一些关键的区别。下面我详细深入地解释这两者的差异，并提供相关的源码上下文。</p> 
<h4><a id="ClassforName_1686"></a>Class.forName()</h4> 
<p><code>Class.forName()</code>是一个静态方法，当你知道一个类的全路径名时，你可以使用这个方法来动态加载这个类。<code>Class.forName()</code>不仅将类加载到JVM中，而且还会对类进行初始化，即执行静态代码块。</p> 
<pre><code class="prism language-java"><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.example.MyClass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这行代码做了两件事情：</p> 
<ol><li><strong>加载类</strong>：将<code>com.example.MyClass</code>类加载到JVM中。</li><li><strong>初始化类</strong>：执行<code>com.example.MyClass</code>类的静态初始化器，即运行静态代码块和静态字段初始化。</li></ol> 
<p><code>Class.forName()</code>有一个重载版本，允许你指定是否初始化类：</p> 
<pre><code class="prism language-java"><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.example.MyClass"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在这个重载方法中，第二个参数是一个布尔值，表示是否要初始化类。第三个参数是使用的ClassLoader。</p> 
<h4><a id="ClassLoader_1707"></a>ClassLoader</h4> 
<p><code>ClassLoader</code>是Java中的一个抽象类，它负责动态加载类和资源。不同的类加载器有不同的加载策略。例如，系统类加载器会加载classpath上的类，网络类加载器可以加载网络上的类等。</p> 
<p>使用ClassLoader加载类通常是这样的：</p> 
<pre><code class="prism language-java"><span class="token class-name">ClassLoader</span> classLoader <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"com.example.MyClass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>loadClass()</code>方法做的事情：</p> 
<ol><li><strong>加载类</strong>：将<code>com.example.MyClass</code>类加载到JVM中。</li><li><strong>不初始化类</strong>：与<code>Class.forName()</code>不同，使用ClassLoader加载类时，默认不会初始化类。也就是说，静态代码块不会执行。</li></ol> 
<h4><a id="_1723"></a>源码层面的区别</h4> 
<p>在JDK的源码中，我们可以看到<code>Class.forName()</code>最终也是通过ClassLoader来实现类的加载的，但在加载完毕后会立即初始化类：</p> 
<pre><code class="prism language-java"><span class="token comment">// Class.java 的部分源码</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">forName</span><span class="token punctuation">(</span><span class="token class-name">String</span> className<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> caller <span class="token operator">=</span> <span class="token class-name">Reflection</span><span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">forName0</span><span class="token punctuation">(</span>className<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span>caller<span class="token punctuation">)</span><span class="token punctuation">,</span> caller<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 这是一个本地方法，涉及到JVM内部的实现</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">forName0</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> initialize<span class="token punctuation">,</span>
                                        <span class="token class-name">ClassLoader</span> loader<span class="token punctuation">,</span>
                                        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> caller<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">;</span>
</code></pre> 
<p>而ClassLoader的<code>loadClass()</code>方法则通常不负责类的初始化：</p> 
<pre><code class="prism language-java"><span class="token comment">// ClassLoader.java 的部分源码</span>
<span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// First, check if the class has already been loaded</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// ClassNotFoundException thrown if class not found</span>
            <span class="token comment">// from the non-null parent class loader</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// If still not found, then invoke findClass in order</span>
            <span class="token comment">// to find the class.</span>
            c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，<code>resolve</code>参数表示是否要链接类，这是类加载过程中的一个步骤，但即使是链接，也不会导致类的初始化；初始化是发生在链接之后的另一个阶段。</p> 
<h4><a id="_1776"></a>总结</h4> 
<ul><li><code>Class.forName()</code>会加载并初始化类，它更常用于加载JDBC驱动程序和需要立即执行静态代码块的场景。</li><li><code>ClassLoader.loadClass()</code>只会加载类而不会初始化，这在很多需要动态加载但不需要立即执行静态代码块的场景中非常有用。</li></ul> 
<p>选择使用哪一个通常取决于你是否需要初始化类。如果你需要触发静态初始化，那么使用<code>Class.forName()</code>；如果你只是想加载类而不初始化它们，那么使用ClassLoader的<code>loadClass()</code>方法更为合适。</p> 
<h3><a id="font_size4_colorFF000023font_1784"></a><font size="4" color="##FF0000">23、微服务</font></h3> 
<p><strong>微服务的优点:</strong><br> 代码的独立。各自团队负责各自微服务的代码维护，互相不会影响，也不容易造成代码冲突。</p> 
<p>也包括code review、还有功能测试。下载代码也不需要下载全部的代码。</p> 
<p>如果共用代码，有的功能没有开发好，有的小功能已经开发好了，已经开发好的功能没法单独上线。除非采用很多分支，拆分上线。</p> 
<p>微服务系统间的独立。系统之间相对独立，非核心系统的发版或者异常，不会影响整个系统核心业务的运行。更加敏捷。</p> 
<p>数据的独立。各自服务负责各自的数据，特别是机密数据不需要开放给无关的人员。</p> 
<p>业务的切分，降低了单个服务的复杂性，负责某一服务的开发人员，只需要了解自己相关的业务。快速上手，focus在各自的业务上。</p> 
<p>人的独立。团队管理更方便。比如招一个人负责商品的服务，则该小伙伴不需要了解支付、优惠券、库存相关的业务场景，只需要清楚商品相关的业务规则就可以了</p> 
<p>产出于Spring大家族，Spring在企业级开发框架中无人能敌，来头很大，可以保证后续的更新、完善</p> 
<p>组件丰富，功能齐全。Spring Cloud 为微服务架构提供了非常完整的支持。例如、配置管理、服务发现、断路器、微服务网关等；</p> 
<p>Spring Cloud 社区活跃度很高，教程很丰富，遇到问题很容易找到解决方案<br> 服务拆分粒度更细，耦合度比较低，有利于资源重复利用，有利于提高开发效率</p> 
<p>可以更精准的制定优化服务方案，提高系统的可维护性</p> 
<p>减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发</p> 
<p>微服务可以是跨平台的，可以用任何一种语言开发</p> 
<p>适于互联网时代，产品迭代周期更短</p> 
<p>**Eureka：**各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里</p> 
<p>**Ribbon：**服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台</p> 
<p>**Feign：**基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求</p> 
<p>**Hystrix：**发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题</p> 
<p>**Zuul：**如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务</p> 
<p><strong>微服务通常使用以下组件来实现实时更新配置：</strong></p> 
<p>配置中心：微服务架构中的配置中心可以集中管理所有微服务的配置。例如，Spring Cloud Config、Consul、ZooKeeper等。</p> 
<p>消息总线：使用消息总线来通知微服务应用程序配置已更改。例如，Spring Cloud Bus、Kafka等。</p> 
<p>服务注册中心：微服务可以在服务注册中心中注册并发现其他微服务。例如，Eureka、Consul、ZooKeeper等。<br> 通过使用这些组件，微服务可以在不需要重启服务的情况下更新配置。当配置更改时，配置中心将通知服务应用程序，并通过消息总线将更改传播到所有微服务。这使得微服务架构更加灵活和可扩展。</p> 
<h3><a id="font_size4_colorFF000023redisfont_1835"></a><font size="4" color="##FF0000">23、redis</font></h3> 
<p><strong>maxmemory-policy 六种方式</strong></p> 
<p>volatile-lru：只对设置了过期时间的key进行LRU（默认值）</p> 
<p>allkeys-lru ： 删除lru算法的key</p> 
<p>volatile-random：随机删除即将过期key</p> 
<p>allkeys-random：随机删除</p> 
<p>volatile-ttl ： 删除即将过期的</p> 
<p>noeviction ： 永不过期，返回错误</p> 
<p><strong>I/O 多路复用模型</strong>是利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，<br> 于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p> 
<p>这里“多路”指的是多个网络连接，</p> 
<p>“复用”指的是复用同一个线程。</p> 
<p>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），<br> 且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p> 
<p><strong>缓存穿透</strong></p> 
<p>描述：</p> 
<p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p> 
<p>解决方案：</p> 
<p>1、接口校验。在正常业务流程中可能会存在少量访问不存在 key 的情况，但是一般不会出现大量的情况，所以这种场景最大的可能性是遭受了非法攻击。可以在最外层先做一层校验：用户鉴权、数据合法性校验等，例如商品查询中，商品的ID是正整数，则可以直接对非正整数直接过滤等等。</p> 
<p>2、缓存空值。当访问缓存和DB都没有查询到值时，可以将空值写进缓存，但是设置较短的过期时间，该时间需要根据产品业务特性来设置。</p> 
<p>3、布隆过滤器。使用布隆过滤器存储所有可能访问的 key，不存在的 key 直接被过滤，存在的 key 则再进一步查询缓存和数据库。</p> 
<p><strong>缓存击穿</strong></p> 
<p>描述：</p> 
<p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p> 
<p>解决方案：</p> 
<p>设置热点数据永远不过期。</p> 
<p>加互斥锁</p> 
<p><strong>缓存雪崩</strong></p> 
<p>描述：</p> 
<p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，</p> 
<p>缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p> 
<p>解决方案：</p> 
<p>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</p> 
<p>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</p> 
<p>设置热点数据永远不过期。</p> 
<p>FIFO ，first in first out ，最先进入缓存的数据在缓存空间不够情况下(超出最大元素限制时)会被首先清理出去</p> 
<p>LFU ， Less Frequently Used ，一直以来最少被使用的元素会被被清理掉。这就要求缓存的元素有一个hit 属性，在缓存空间不够得情况下,hit 值最小的将会被清出缓存。</p> 
<p>LRU ，Least Recently Used ，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，</p> 
<h3><a id="font_size4_colorFF000024font_1910"></a><font size="4" color="##FF0000">24、什么是双亲委派机制</font></h3> 
<p>双亲委派机制（Parent Delegation Model）是Java类加载器（ClassLoader）的一个基本行为，它是Java为了保证Java应用的稳定运行和安全所采用的一种机制。这个机制是在Sun公司的工程师们在JDK 1.2时期引入的。下面我会详细介绍双亲委派机制的工作原理和目的。</p> 
<h4><a id="_1914"></a>工作原理：</h4> 
<p>当一个ClassLoader需要加载一个类时，它不会先尝试自己去加载这个类，而是把这个请求委派给父类加载器去执行。如果父类加载器无法完成这个加载（它不认识这个类），子类加载器才会尝试自己去加载。</p> 
<p>通常情况下，Java使用的类加载器有：</p> 
<ol><li><strong>引导类加载器（Bootstrap ClassLoader）</strong>：它是最顶层的类加载器，负责加载JVM基础核心类库（如<code>rt.jar</code>），无法直接被Java代码访问。</li><li><strong>扩展类加载器（Extension ClassLoader）</strong>：它负责加载JVM扩展目录中的类库。</li><li><strong>系统类加载器（System ClassLoader）</strong>：它根据Java应用的classpath来加载Java类。</li></ol> 
<h4><a id="_1924"></a>双亲委派模型的具体流程：</h4> 
<ol><li>当<code>System ClassLoader</code>需要加载一个类时，它不会自己直接去加载，而是委托给其父类加载器（<code>Extension ClassLoader</code>）去尝试加载。</li><li><code>Extension ClassLoader</code>接到请求后，也不会自己直接去加载，而是委托给<code>Bootstrap ClassLoader</code>去尝试加载。</li><li>如果<code>Bootstrap ClassLoader</code>可以完成这个类的加载，就返回给<code>Extension ClassLoader</code>，然后再返回给<code>System ClassLoader</code>。这个时候，整个加载请求就完成了。</li><li>如果<code>Bootstrap ClassLoader</code>无法加载这个类（比如它不是核心类库中的类），请求就会返回给<code>Extension ClassLoader</code>。<code>Extension ClassLoader</code>会尝试去加载这个类，如果它也失败了，请求最终会返回给<code>System ClassLoader</code>。</li><li><code>System ClassLoader</code>最后会尝试自己去classpath上加载这个类。如果还是失败，就会抛出<code>ClassNotFoundException</code>异常。</li></ol> 
<h4><a id="_1932"></a>目的：</h4> 
<p>双亲委派模型的设计有以下目的：</p> 
<ol><li><strong>避免类的重复加载</strong>：由于在委派链上的类加载器都是单例的，因此一个类一旦被加载，就可以被所有的子加载器所共享。</li><li><strong>保护程序安全</strong>：防止核心API被随意篡改。例如，通过自定义String类来进行替换，如果没有双亲委派机制，那么自定义的String类可能会代替核心库中的String，这可能会造成严重的安全问题。</li><li><strong>保护程序稳定运行</strong>：通过保证使用的都是同一个版本的类（通过同一个类加载器加载）来避免类的冲突。</li></ol> 
<h4><a id="_1940"></a>代码实现：</h4> 
<p>在JDK源码中，<code>ClassLoader</code>类中的<code>loadClass</code>方法就实现了双亲委派模型：</p> 
<pre><code class="prism language-java"><span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 首先，检查请求的类是否已经被加载过</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// 如果存在父类加载器，则委托父类加载器加载</span>
                    c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// 如果没有父类加载器，则使用引导类加载器进行加载</span>
                    c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 如果父类加载器和引导类加载器都不能完成加载，那么异常被捕获</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 如果所有的上级加载器都不能完成加载，当前加载器尝试自己加载这个类</span>
                c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 链接请求的类</span>
            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_1978"></a>双亲委派模型的破坏：</h4> 
<p>尽管双亲委派模型对于Java类加载机制十分重要，但在某些场景下需要打破这一模型。比如，OSGi环境中的类加载器行为、Java的SPI（Service Provider Interface）机制、热部署功能等，这些场景下就需要设计特殊的类加载器来满足特殊需求。</p> 
<p>以上就是双亲委派机制的详细介绍。它是Java类加载架构的一个关键特性，对于理解Java的类加载器行为和避免常见的类加载问题非常重要。</p> 
<p><strong>只有当链表中的元素个数大于8(此时 node有9个)，并且数组的长度大于等于64时才会将链表转为红黑树。</strong></p> 
<h3><a id="font_size4_colorFF000025font_1987"></a><font size="4" color="##FF0000">25、定时框架</font></h3> 
<p><strong>什么是XXL-JOB？</strong></p> 
<p>XXL-JOB是一个轻量级分布式任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。</p> 
<p>现已开放源代码并接入多家公司线上产品线，开箱即用。</p> 
<p><strong>Java主流三大定时器技术选型</strong><br> 选型时原则：少服务器 后期维护方便 增加任务省事而且快捷 不涉及启停服务</p> 
<p>1、Quartz</p> 
<p>优点：支持集群部署</p> 
<p>缺点：没有自带的管理界面；调度逻辑和执行任务耦合在一起；维护需要重启服务</p> 
<p>总结：针对目前项目情况，利弊相同</p> 
<p>2、xxl-job</p> 
<p>优点：支持集群部署；提供运维界面维护成本小；自带错误预警；相对elastic-job来说不需要额外的组件（zookeeper）；支持调度策略；支持分片；文档齐全</p> 
<p>缺点：相对Quartz来说需要多部署调度中心</p> 
<p>总结：针对目前项目情况，利大于弊</p> 
<p>3、elastic-job</p> 
<p>优点：支持集群部署；维护成本小</p> 
<p>缺点：elastic-job需要zookeeper，zookeeper集群高可用至少需要三台服务器</p> 
<p>总结：针对目前项目情况，弊大于利</p> 
<p>小结：综合选型原则及三个定时任务框架的优缺点和目前项目的状况，建议选用xxl-job。</p> 
<p><strong>XXL-JOB的一些特性：</strong></p> 
<p>1、执行失败可以查看日志</p> 
<p>2、支持邮件报警</p> 
<p>3、路由策略支持轮询等策略，可以减轻执行服务器的压力</p> 
<p>4、轮询时间等参数修改后立即生效</p> 
<p>5、执行器有问题或新增，快速识别</p> 
<p>6、调度中心高可用，调度中心可以集群部署（集群部署的机器时钟必须同步），如果调度中心没有做负载在执行器的配置中需要配多个地址，如果调度中心配置负载则执行器配置负载地址即可</p> 
<p>7、执行器高可用（执行器可以集群部署）</p> 
<h3><a id="font_size4_colorFF000026font_2045"></a><font size="4" color="##FF0000">26、线程安全的定义？</font></h3> 
<p><strong>线程安全的定义？</strong></p> 
<p>线程安全是多线程编程中的一个概念，它描述了一段代码、一系列操作或者整个程序在多线程环境中执行时的安全性。如果一段代码是线程安全的，它可以同时被多个线程安全地调用，而不会产生不一致的结果或者破坏数据结构。</p> 
<h4><a id="_2051"></a>线程安全的定义：</h4> 
<p>线程安全通常涉及以下几个方面：</p> 
<ol><li> <p><strong>原子性（Atomicity）</strong>：一个操作或者多个操作要么全部执行，要么全不执行，不会停留在中间状态。在编程中，原子操作通常通过锁或者原子变量实现。</p> </li><li> <p><strong>可见性（Visibility）</strong>：一个线程对共享变量的修改，可以被其他线程立即看到。Java中可以通过<code>volatile</code>关键字、<code>synchronized</code>关键字或者<code>java.util.concurrent</code>包下的工具来保证可见性。</p> </li><li> <p><strong>有序性（Ordering）</strong>：程序中的指令执行顺序可能会被编译器或者处理器优化打乱，但是从并发的角度看，这些指令的执行顺序应该是有逻辑的和可预期的。在Java中，<code>volatile</code>关键字和<code>happens-before</code>原则是保证指令有序性的常用机制。</p> </li></ol> 
<p>当一段代码是线程安全的，它会正确地处理多线程间的原子性、可见性和有序性，从而保证并发执行时的正确性。</p> 
<h4><a id="_2063"></a>线程安全的实现：</h4> 
<p>在Java中，实现线程安全的常见方法有：</p> 
<ol><li><strong>使用synchronized关键字</strong>：它提供了一种锁机制，能够保证同一时刻只有一个线程执行某个方法或者代码块。</li></ol> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="2"><li><strong>使用ReentrantLock</strong>：<code>java.util.concurrent.locks.Lock</code>接口及其实现提供了比<code>synchronized</code>更灵活的锁定机制。</li></ol> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">Lock</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">ReentrantLock</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> count<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="3"><li><strong>使用volatile关键字</strong>：这可以保证共享变量的可见性，当一个线程修改了这个变量的值，新值对于其他线程来说是立即可见的。</li></ol> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Flag</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> flag<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>flag <span class="token operator">=</span> flag<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFlagSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> flag<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="4"><li> <p><strong>使用并发集合</strong>：<code>java.util.concurrent</code>包提供了一系列的线程安全集合类，如<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>等。</p> </li><li> <p><strong>使用原子变量</strong>：<code>java.util.concurrent.atomic</code>包提供了一系列原子变量，如<code>AtomicInteger</code>、<code>AtomicLong</code>等，这些类利用CAS（Compare-and-Swap）操作提供了无锁的线程安全编程方法。</p> </li></ol> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span></span><span class="token class-name">AtomicInteger</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">AtomicInteger</span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        count<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="6"><li><strong>不可变对象</strong>：创建不可变的对象，这些对象一旦创建，其状态就不可改变。因此，它们自然是线程安全的。</li></ol> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ImmutableValue</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">ImmutableValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_2165"></a>线程安全的重要性：</h4> 
<p>在多线程应用程序中，线程安全是至关重要的，因为数据竞争和并发修改可能导致不一致的状态，从而导致应用程序的失败。通过确保代码是线程安全的，可以避免这些问题，保证程序的稳定性和可靠性。</p> 
<p>综上所述，线程安全需要考虑多个方面，而且在Java中有多种方法可以实现线程安全。选择哪种方法取决于具体情况，考虑到性能、简便性以及其他因素。</p> 
<h3><a id="font_size4_colorFF000027jvm20font_2170"></a><font size="4" color="##FF0000">27、jvm调优的20个参数及作用</font></h3> 
<p>1、-Xms：设置JVM初始堆大小，如-Xms512m表示初始堆大小为512MB。</p> 
<p>2、-Xmx：设置JVM最大堆大小，如-Xmx1024m表示最大堆大小为1GB。</p> 
<p>通常情况下我们会把Xms和Xmx参数设成一样的值，可以减少内存抖动频率，内存抖动会额外消耗cpu时间，设成一样的值可以在最小化不必要的内存分配和减少垃圾回收频率之间平衡，从而提高应用程序的性能和稳定性。</p> 
<p>3、-Xmn：设置年轻代大小，如-Xmn256m表示年轻代大小为256MB。</p> 
<p>4、-XX:PermSize：设置永久代初始大小，如-XX:PermSize=256m表示永久代初始大小为256MB。</p> 
<p>5、-XX:MaxPermSize：设置永久代最大大小，如-XX:MaxPermSize=512m表示永久代最大大小为512MB。</p> 
<p>6、-XX:NewSize：设置新生代初始大小，如-XX:NewSize=128m表示新生代初始大小为128MB。</p> 
<p>7、-XX:MaxNewSize：设置新生代最大大小，如-XX:MaxNewSize=256m表示新生代最大大小为256MB。</p> 
<p>8、-XX:SurvivorRatio：设置年轻代中Eden区和Survivor区的比例，如-XX:SurvivorRatio=8表示Eden区和Survivor区的比例为8:1。</p> 
<p>9、-XX:MaxTenuringThreshold：设置对象晋升老年代的最大阈值，如-XX:MaxTenuringThreshold=10表示对象存活次数达到10次时，将晋升到老年代。</p> 
<p>10、-XX:NewRatio：设置年轻代和老年代的比例，如-XX:NewRatio=2表示年轻代和老年代的比例为1:2。</p> 
<p>11、-XX:ParallelGCThreads：设置并行垃圾收集器的线程数，如-XX:ParallelGCThreads=8表示并行垃圾收集器的线程数为8个。</p> 
<p>12、-XX:+UseConcMarkSweepGC：开启CMS垃圾收集器。</p> 
<p>13、-XX:+UseParallelGC：开启并行垃圾收集器。</p> 
<p>14、-XX:+UseSerialGC：开启串行垃圾收集器。</p> 
<p>15、-XX:+UseG1GC：开启G1垃圾收集器。</p> 
<p>16、-XX:+HeapDumpOnOutOfMemoryError：发生内存溢出时生成Heap Dump文件。</p> 
<p>17、-XX:HeapDumpPath：设置Heap Dump文件生成路径。</p> 
<p>18、-XX:+PrintGCDetails：输出GC的详细信息。</p> 
<p>19、-XX:+PrintGCDateStamps：输出GC的时间戳。</p> 
<p>20、-XX:+PrintCommandLineFlags：输出JVM启动时的参数信息。</p> 
<h3><a id="font_size4_colorFF000028_10font_2215"></a><font size="4" color="##FF0000">28、 发生内存溢出的10种场景？</font></h3> 
<p>内存溢出（OutOfMemoryError，简称OOM）是指程序在申请内存时，没有足够的内存空间供其使用，发生的错误。在Java中，内存溢出通常是指堆内存（Heap Space）不足，但也有可能是其他部分内存空间不足。以下是常见的一些内存溢出场景及其可能的原因：</p> 
<ol><li> <p><strong>Java堆内存溢出</strong>：</p> <pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不断创建对象，并保持引用，导致GC无法回收，最终堆内存不足</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>永久代或元空间溢出</strong>：</p> <pre><code class="prism language-java"><span class="token comment">// 在Java 8之前，永久代会因为加载了大量的类或者大量的反射操作而溢出</span>
<span class="token comment">// 在Java 8中，永久代已经被元空间（Metaspace）所取代</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> classes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"SomeClass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    classes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>栈内存溢出</strong>：</p> <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recursiveMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">recursiveMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归调用，没有退出条件，会造成栈内存溢出</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>本地方法栈溢出</strong>：</p> <pre><code class="prism language-java"><span class="token comment">// 本地方法栈溢出一般发生在调用本地方法时，无限递归或者大量线程调用本地方法可能导致</span>
<span class="token comment">// 本地方法栈溢出的代码示例不容易提供，因为它涉及到JNI（Java Native Interface）调用</span>
</code></pre> </li><li> <p><strong>直接内存溢出</strong>：</p> <pre><code class="prism language-java"><span class="token comment">// 使用NIO进行大量直接内存分配，可能导致直接内存溢出</span>
<span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分配1GB直接内存</span>
</code></pre> </li><li> <p><strong>内存泄漏</strong>：</p> <pre><code class="prism language-java"><span class="token comment">// 长生命周期的对象持有短生命周期对象的引用，导致短生命周期对象无法被GC回收</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemoryLeak</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> leakList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        leakList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对象实际上已经不再需要，却仍然被保存在列表中</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>过多线程</strong>：</p> <pre><code class="prism language-java"><span class="token comment">// 创建过多的线程，每个线程都会占用一定的栈内存，可能导致内存溢出</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>数据库连接耗尽</strong>：</p> <pre><code class="prism language-java"><span class="token comment">// 如果数据库连接不释放，会导致连接对象无法回收</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Connection</span> conn <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 忘记调用 conn.close();</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>大量动态生成类</strong>：</p> <pre><code class="prism language-java"><span class="token comment">// 动态生成大量的类，可以通过CGLIB或Javassist等库实现</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Enhancer</span> enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span><span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    enhancer<span class="token punctuation">.</span><span class="token function">setUseCache</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> proxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> proxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">MyClass</span> myClass <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MyClass</span><span class="token punctuation">)</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>大量静态内容</strong>：</p> <pre><code class="prism language-java"><span class="token comment">// 静态内容（如静态集合类）的生命周期与应用程序一样长，如果不断向里面添加内容，会导致内存不足</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticContentHolder</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> staticList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addToList</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        staticList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li></ol> 
<p>以上代码示例都是造成内存溢出的潜在原因。在实际开发中，内存溢出问题的解决通常需要对代码进行详细的分析，并使用像Java虚拟机工具接口（JVMTI）、Java Mission Control、VisualVM、MAT（Memory Analyzer Tool）等工具来分析内存使用情况，从而找出内存泄漏或者溢出的根本原因。</p> 
<h3><a id="font_size4_colorFF000029_font_2323"></a><font size="4" color="##FF0000">29、 泛型</font></h3> 
<p>泛型是Java语言提供的一个编译时特性，它允许程序员编写能够适用于多种数据类型的代码。泛型的主要好处是提供了类型安全性和避免了类型转换的麻烦。</p> 
<h4><a id="_2327"></a>泛型的基本概念：</h4> 
<ul><li><strong>类型参数化</strong>：能够将类型作为参数传递给类和方法。</li><li><strong>类型擦除</strong>：Java的泛型是在编译期实现的，编译器将类型信息擦除，并添加类型转换代码。</li><li><strong>通配符</strong>：使用?表示未知类型。通配符可以有上界（<code>? extends T</code>）和下界（<code>? super T</code>）。</li></ul> 
<h4><a id="_2333"></a>泛型类：</h4> 
<p>一个典型的泛型类的定义如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> t<span class="token punctuation">;</span> <span class="token comment">// T stands for "Type"</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>t <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的例子中，<code>T</code>是一个类型变量，它将在创建<code>Box</code>类的实例时被实际的类型替换。</p> 
<p>使用泛型类：</p> 
<pre><code class="prism language-java"><span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> integerBox <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stringBox <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

integerBox<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 自动装箱</span>
stringBox<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Integer</span> intValue <span class="token operator">=</span> integerBox<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不需要类型转换</span>
<span class="token class-name">String</span> stringValue <span class="token operator">=</span> stringBox<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不需要类型转换</span>
</code></pre> 
<h4><a id="_2366"></a>泛型方法：</h4> 
<p>泛型也可以应用于方法。一个泛型方法可能被定义在一个非泛型类中。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Utility</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">T</span> element <span class="token operator">:</span> array<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>element <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用泛型方法：</p> 
<pre><code class="prism language-java"><span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intArray <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> stringArray <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">Utility</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token function">printArray</span><span class="token punctuation">(</span>intArray<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 指定类型</span>
<span class="token class-name">Utility</span><span class="token punctuation">.</span><span class="token function">printArray</span><span class="token punctuation">(</span>stringArray<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 类型推断</span>
</code></pre> 
<h4><a id="_2391"></a>泛型的边界：</h4> 
<p>泛型可以限定类型变量的上界（extends）或下界（super）。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Stats</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Stats</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>nums <span class="token operator">=</span> nums<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">average</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">T</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            sum <span class="token operator">+=</span> num<span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum <span class="token operator">/</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的例子中，类型参数<code>T</code>必须是<code>Number</code>或其子类。这允许在方法<code>average</code>中安全地调用<code>doubleValue</code>。</p> 
<h4><a id="_2415"></a>泛型通配符：</h4> 
<p>使用通配符<code>?</code>可以让你编写能够适应不同类型的泛型代码。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printList</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> elem <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>elem <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>printList</code>方法可以接收任何类型的<code>List</code>作为参数，无论这个<code>List</code>的元素类型是什么。</p> 
<h4><a id="_2430"></a>泛型的局限性：</h4> 
<ul><li><strong>类型擦除</strong>：运行时类型查询只能使用原始类型。泛型类型参数在运行时不可用，因为它们会被擦除。</li><li><strong>静态上下文中的类型参数</strong>：不能在静态变量或方法中引用类型参数。</li><li><strong>原始类型</strong>：使用泛型时，不能使用基本数据类型（int, long, double等），必须使用它们的包装类（Integer, Long, Double等）。</li><li><strong>创建泛型数组</strong>：由于类型擦除，无法创建特定泛型类型的数组，<code>T[] array = new T[10];</code>会引起编译错误。</li></ul> 
<h4><a id="_2437"></a>泛型和反射：</h4> 
<p>由于擦除，泛型类型信息在运行时不可获取，这限制了反射的使用。然而，可以通过其他手段在运行时获取到泛型的类型信息，例如通过子类化一个参数化类型。</p> 
<h4><a id="_2441"></a>总结：</h4> 
<p>泛型是Java编程中的一个强大工具，它提供了编译时类型安全性并且阻止了类型转换的错误。了解泛型如何工作以及如何有效地使用它们是一个Java开发者必需的技能。在使用泛型时，需要考虑类型擦除以及它对你的代码可能产生的影响。</p> 
<h3><a id="font_size4_colorFF0000PECSfont_2447"></a><font size="4" color="##FF0000">PECS原则</font></h3> 
<p>PECS原则是指“Producer Extends, Consumer Super”，这是由Joshua Bloch在他的著作《Effective Java》中提出的一种泛型设计指导原则。PECS原则用来指导泛型通配符的使用，以便获得最佳的灵活性和类型安全。</p> 
<h4><a id="_2450"></a>详细解释：</h4> 
<ul><li> <p><strong>Producer Extends</strong>：如果你需要一个提供（生产）元素给你的集合，那么你应该使用带有<code>extends</code>通配符的泛型。它意味着这个集合可以安全地读取其中的元素，因为这些元素都是这个通配符指定的类型的子类型。</p> </li><li> <p><strong>Consumer Super</strong>：如果你需要一个消费（接收）元素的集合，那么你应该使用带有<code>super</code>通配符的泛型。它允许你安全地向集合中写入元素，因为这些元素都是这个通配符指定的类型的父类型。</p> </li></ul> 
<h4><a id="PECS_2456"></a>为什么使用PECS原则？</h4> 
<p>在泛型中，集合的类型参数指定了集合可以持有的元素的类型。但是，泛型是不可变的，这意味着<code>List&lt;String&gt;</code>并不是<code>List&lt;Object&gt;</code>的子类型。这给集合的赋值和参数传递带来了限制。为了提供更多的灵活性，Java提供了泛型通配符。</p> 
<p>使用<code>? extends T</code>可以为泛型类型创建一个上界，表示这个通配符可以是T或T的任何子类。同样，<code>? super T</code>创建了一个下界，表示这个通配符可以是T或T的任何父类。</p> 
<h4><a id="_2462"></a>示例：</h4> 
<p>假设我们有一个类<code>Fruit</code>，以及两个子类<code>Apple</code>和<code>Orange</code>。</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Orange</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> t<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Box</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">this</span><span class="token punctuation">.</span>t <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> t<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">this</span><span class="token punctuation">.</span>t <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>现在，让我们看看PECS原则如何应用于这些类：</p> 
<h5><a id="Producer_Extends_2481"></a>Producer Extends:</h5> 
<p>如果我们有一个方法需要读取（生产）水果，我们将使用<code>extends</code>：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printFruits</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span><span class="token punctuation">&gt;</span></span> fruits<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Fruit</span> fruit <span class="token operator">:</span> fruits<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fruit<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// fruits.add(new Apple()); // 错误！不能添加元素</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里的<code>List&lt;? extends Fruit&gt;</code>可以接受<code>List&lt;Fruit&gt;</code>、<code>List&lt;Apple&gt;</code>或<code>List&lt;Orange&gt;</code>作为参数。我们可以从中读取数据，因为我们知道列表中的每个元素至少是<code>Fruit</code>类的对象。</p> 
<h5><a id="Consumer_Super_2496"></a>Consumer Super:</h5> 
<p>如果我们需要写入（消费）水果，我们将使用<code>super</code>：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addApple</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Apple</span><span class="token punctuation">&gt;</span></span> fruits<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    fruits<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 正确！我们可以添加一个苹果或它的子类</span>
    <span class="token comment">// Fruit fruit = fruits.get(0); // 错误！不能确切知道返回类型</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里的<code>List&lt;? super Apple&gt;</code>可以接受<code>List&lt;Fruit&gt;</code>或<code>List&lt;Apple&gt;</code>作为参数。我们可以向其添加<code>Apple</code>或其子类的实例。</p> 
<h4><a id="PECS_2509"></a>PECS原则的好处：</h4> 
<ul><li><strong>最大化灵活性</strong>：通过将限制放在恰当的位置，你可以编写更灵活的代码。</li><li><strong>提高类型安全</strong>：使用PECS原则，编译器可以帮助你避免在运行时出现<code>ClassCastException</code>。</li><li><strong>易于理解</strong>：代码的使用者可以通过方法签名更容易地理解代码。比如<code>printFruits</code>方法显然不会修改传入的列表，而<code>addApple</code>方法则可能会这样做。</li></ul> 
<h4><a id="_2515"></a>总结：</h4> 
<p>PECS原则是处理生产者和消费者的泛型集合时提供指导的有效工具。它通过边界通配符的正确使用，使得你的API更加灵活和类型安全。在编写泛型代码时，总是考虑是使用<code>extends</code>还是<code>super</code>，以确保你的代码既具有好的兼容性，也易于维护。</p> 
<h3><a id="font_size4_colorFF0000objectfont_2518"></a><font size="4" color="##FF0000">为什么不用object替换泛型</font></h3> 
<p>使用<code>Object</code>替换泛型确实是在Java中泛型出现之前所做的做法。然而，泛型引入后，它们提供了许多有点，这些优势使得泛型比使用Object更加强大和灵活。这些优势包括：</p> 
<h4><a id="_2521"></a>类型安全</h4> 
<p>泛型提供了编译时的类型检查。如果你使用泛型，当你尝试将错误类型的对象放入集合时，编译器会提醒你。使用<code>Object</code>，这些错误会在运行时发生，可能会导致<code>ClassCastException</code>。</p> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> strings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
strings<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>
strings<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译错误，类型安全</span>

<span class="token class-name">List</span> objects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
objects<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>
objects<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK，但是失去了类型安全</span>
</code></pre> 
<h4><a id="_2535"></a>避免强制类型转换</h4> 
<p>泛型避免了在取出元素时进行强制类型转换，因为编译器能够通过泛型知道集合中的元素类型。</p> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> strings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
strings<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 没有强制类型转换</span>

<span class="token class-name">List</span> objects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
objects<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> objects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 需要强制类型转换</span>
</code></pre> 
<p>使用<code>Object</code>，每次从集合中取出元素时，你都需要进行类型转换，这不仅增加了代码的复杂性，还增加了运行时出错的风险。</p> 
<h4><a id="API_2551"></a>API清晰性</h4> 
<p>泛型使得API更加清晰，因为它直接在代码中指定了操作的数据类型。</p> 
<pre><code class="prism language-java"><span class="token comment">// 没有泛型</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">processItems</span><span class="token punctuation">(</span><span class="token class-name">List</span> items<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 有泛型</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">processItems</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Item</span><span class="token punctuation">&gt;</span></span> items<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在第二个例子中，通过查看方法的签名，你可以立即知道这个方法期望接受什么类型的元素。</p> 
<h4><a id="_2569"></a>重用性</h4> 
<p>泛型代码可以很容易地重用，因为它们可以与多种数据类型一起工作。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> t<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">this</span><span class="token punctuation">.</span>t <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> t<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的<code>Box</code>类可以用于存储任何类型的对象，而不是只能存储<code>Object</code>类型的对象。</p> 
<h4><a id="_2584"></a>促进更好的设计</h4> 
<p>泛型鼓励编程人员更深入地考虑类型，从而写出更通用且可重用的代码。它还可以帮助避免某些设计中的不良做法，例如过度使用<code>instanceof</code>检查和强制类型转换。</p> 
<h4><a id="_2588"></a>代码优化</h4> 
<p>编译器在编译带泛型的代码时会进行类型擦除，将泛型类型参数替换为它们的边界或<code>Object</code>。这意味着泛型不会对运行时的性能产生影响。泛型的引入基本上是一种无成本的抽象。</p> 
<h4><a id="_2592"></a>总结</h4> 
<p>尽管使用<code>Object</code>可以实现类似的功能，但泛型提供了更好的类型检查、更清晰的API、减少了强制类型转换的需要，以及更灵活的代码重用性。此外，它们使得代码更加安全、可读、易于维护，并且没有引入任何运行时开销。因此，泛型是一种比使用<code>Object</code>更好的选择。</p> 
<h3><a id="font_size4_colorFF000030_font_2596"></a><font size="4" color="##FF0000">30、 静态代理和动态代理</font></h3> 
<p><strong>静态代理和动态代理的区别</strong></p> 
<p>1、静态代理通常只代理一个类，动态代理是代理一个接口下的多个实现类。</p> 
<p>2、静态代理事先知道要代理的是什么，而动态代理不知道要代理什么东西，只有在运行时才知道。</p> 
<p>3、动态代理是实现JDK里的InvocationHandler接口的invoke方法，但注意的是代理的是接口，也就是你的业务类必须要实现接口，通过Proxy里的newProxyInstance得到代理对象。</p> 
<p>4、还有一种动态代理CGLIB，代理的是类，不需要业务类继承接口，通过派生的子类来实现代理。通过在运行时，动态修改字节码达到修改类的目的。</p> 
<p>静态代理</p> 
<p>​ 某个对象提供一个代理，代理角色固定，以控制对这个对象的访问。 代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。代理类负责请求的预处理、过滤、将请求分派给委托类处理、以及委托类执行完请求后的后续处理。</p> 
<p>静态代理的特点</p> 
<p>1、目标角色固定</p> 
<p>2、在应用程序执行前就得到目标角色</p> 
<p>3、代理对象会增强目标对象的行为</p> 
<p>4、有可能存在多个代理 引起"类爆炸"（缺点）</p> 
<p>动态代理</p> 
<p>​ 相比于静态代理，动态代理在创建代理对象上更加的灵活，动态代理类的字节码在程序运行时，由Java反射机制动态产生。它会根据需要，通过反射机制在程序运行期，动态的为目标对象创建代理对象，无需程序员手动编写它的源代码。</p> 
<p>动态代理的特点</p> 
<p>1、目标对象不固定</p> 
<p>2、在应用程序执行时动态创建目标对象</p> 
<p>3、代理对象会增强目标对象的行为</p> 
<h3><a id="font_size4_colorFF000031_Javafont_2635"></a><font size="4" color="##FF0000">31、 Java有哪些引用类型？</font></h3> 
<p>Java有四种引用类型，包括强引用、软引用、弱引用和虚引用。</p> 
<p>1、强引用：最普通的引用，只要强引用还存在，垃圾回收器就永远不会回收被引用的对象。</p> 
<p>2、软引用：用来描述一些可能还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有把对象回收掉，那么在系统堆内存发生严重溢出时，才会把这些对象列入回收范围。</p> 
<p>3、弱引用：也是用来描述非必需对象的，它和软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期——仅在当前内存足够的情况下，垃圾回收器才不会回收它。当内存空间不足时，垃圾回收器可以回收这些对象。</p> 
<p>4、虚引用：是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。唯一的用处就是能在这个对象被收集器回收时收到一个系统通知。</p> 
<h3><a id="font_size4_colorFF000032Contendedfont_2646"></a><font size="4" color="##FF0000">32、@Contended作用和优缺点？</font></h3> 
<p>@Contended是Java 8中引入的一个注解，用于减少多线程环境下的“伪共享”现象，以提高程序的性能。</p> 
<p>它的作用是使被标注的对象独占缓存行，不会和任何变量或者对象共享缓存行。这样做可以避免处理器缓存行大小不同带来的影响，做到Java语言的初衷：平台无关性。</p> 
<p>@Contended的优点是可以提高程序的性能，通过减少“伪共享”现象，使得程序在多线程环境下的执行效率更高。</p> 
<p>然而，@Contended也存在一些缺点。</p> 
<p>首先，它默认只在JDK内部起作用，如果需要在程序代码中使用@Contended注解，需要开启JVM参数-XX:-RestrictContended才能生效。</p> 
<p>其次，被@Contended标注的对象会独占缓存行，这可能会增加内存占用和处理器缓存争用，从而对系统性能产生负面影响。</p> 
<p>因此，在使用@Contended注解时，需要根据实际情况权衡利弊，以选择最适合的应用场景。</p> 
<h3><a id="font_size4_colorFF000033ThreadLocalfont_2661"></a><font size="4" color="##FF0000">33、ThreadLocal</font></h3> 
<p><code>ThreadLocal</code> 是 Java 中一个用于实现线程局部存储的类。它允许你创建的变量只能被同一个线程访问。因此，即使多个线程都使用相同的 <code>ThreadLocal</code> 对象创建了副本，它们也不会相互干扰。这在进行并发编程时是非常有用的，尤其是在使用无状态的对象时，例如日期格式化。</p> 
<h4><a id="ThreadLocal__2665"></a>ThreadLocal 的工作原理</h4> 
<p>每个线程都有一个自己的 <code>ThreadLocalMap</code>（一个简化的 Map 类型的数据结构），它以弱引用的方式存储了线程局部变量的副本。<code>ThreadLocal</code> 对象作为键，线程局部变量的副本作为值。</p> 
<p>当线程终止并且没有其他对这个线程对象的引用时，由于是弱引用，<code>ThreadLocal</code> 键会被垃圾收集器回收。</p> 
<h4><a id="ThreadLocal__2671"></a>ThreadLocal 类的核心部分</h4> 
<p>以下是 <code>ThreadLocal</code> 类的核心方法：</p> 
<ul><li><code>set(T value)</code>：将当前线程的局部变量副本设置为指定的值。</li><li><code>get()</code>：返回当前线程的局部变量副本。</li><li><code>remove()</code>：移除当前线程的局部变量副本。</li><li><code>initialValue()</code>：返回该线程局部变量的初始值，默认是 <code>null</code>。</li></ul> 
<h4><a id="ThreadLocal__2680"></a>ThreadLocal 源码的核心部分</h4> 
<p>在 Java 源码中，<code>ThreadLocal</code> 的实现大概可以分为以下几个部分。这里只呈现部分关键代码和概念：</p> 
<h5><a id="ThreadLocal__2684"></a>ThreadLocal 类</h5> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ... 其他成员 ...</span>

    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">ThreadLocalMap<span class="token punctuation">.</span>Entry</span> e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
                <span class="token class-name">T</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">return</span> result<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         <span class="token class-name">ThreadLocalMap</span> m <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
             m<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ... 其他方法 ...</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="ThreadLocalThreadLocalMap__2723"></a>ThreadLocal.ThreadLocalMap 类</h5> 
<p><code>ThreadLocal.ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的一个内部类，它的实现类似于一个简化版的 <code>Map</code>，专门为每个线程存储其局部变量副本。</p> 
<pre><code class="prism language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ... 其他成员 ...</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Object</span> value<span class="token punctuation">;</span>

        <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
            value <span class="token operator">=</span> v<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Entry</span> <span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// ... 实现查找 ...</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// ... 实现赋值 ...</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ... 其他方法 ...</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_2754"></a>源码概要</h4> 
<ol><li><code>ThreadLocal</code> 实例基本上是一个键。真正的值存储在 <code>Thread</code> 对象自己的 <code>ThreadLocalMap</code> 中。</li><li><code>ThreadLocalMap</code> 使用 <code>ThreadLocal</code> 的弱引用作为键。对于每个键-值关系，键是 <code>ThreadLocal</code> 的弱引用，值是对应的线程局部对象。</li><li><code>initialValue()</code> 默认实现返回 <code>null</code>，但可以重写以返回线程首次访问变量时的初始值。</li><li><code>get()</code> 方法会从当前线程的 <code>ThreadLocalMap</code> 中获取与 <code>ThreadLocal</code> 实例关联的值。</li><li><code>set(T value)</code> 会将值与当前线程的 <code>ThreadLocal</code> 实例关联。</li><li><code>remove()</code> 会删除当前线程的 <code>ThreadLocalMap</code> 中与 <code>ThreadLocal</code> 实例关联的值。</li></ol> 
<h4><a id="ThreadLocal__2763"></a>ThreadLocal 使用注意事项</h4> 
<ol><li><strong>内存泄漏</strong>：由于 <code>ThreadLocalMap</code> 的生命周期与线程一样长，所以如果线程是线程池中的线程，而且不被销毁，那么存在内存泄漏的风险。</li><li><strong>性能问题</strong>：过多的使用 <code>ThreadLocal</code> 可能会导致性能问题，因为每个线程都需要维护自己的 <code>ThreadLocalMap</code>。</li></ol> 
<p>使用 <code>ThreadLocal</code> 时，您应该始终记住在不再需要存储在 <code>ThreadLocal</code> 中的数据时调用 <code>remove()</code> 方法，特别是在使用线程池的情况下，以避免任何潜在的内存泄漏。</p> 
<p><code>ThreadLocal</code> 在一些特定的场景下非常有用，例如，在需要保持线程安全的情况下，为每个线程保持数据库连接或用户会话信息。然而，正确地管理 <code>ThreadLocal</code> 变得很重要，因为不当使用可能导致内存泄漏。</p> 
<h3><a id="font_size4_colorFF000034font_2772"></a><font size="4" color="##FF0000">34、竞态条件</font></h3> 
<p>竞态条件（Race Condition）是指系统的输出依赖于不受控制的事件序列或时序的情况。在并发编程中，当多个进程或线程访问共享数据并且试图同时修改它时，就可能发生竞态条件。如果事件的发生顺序不正确，程序就可能导致不可预测的结果或破坏数据的完整性。</p> 
<h4><a id="_2775"></a>理解竞态条件</h4> 
<p>竞态条件通常发生在以下情况中：</p> 
<ol><li><strong>共享数据</strong>：多个线程或进程共享同一块数据资源。</li><li><strong>多个线程修改数据</strong>：至少有一个线程修改数据资源，而其他线程可能读取或写入同一个资源。</li><li><strong>交替执行</strong>：线程的执行顺序由操作系统的调度算法决定，这通常是不确定的。</li></ol> 
<h4><a id="_2783"></a>举例说明竞态条件</h4> 
<p>假设有两个线程，它们都要更新同一个银行账户余额。如果两个线程同时检查余额，然后基于当前值计算新的余额，并尝试将这个更新的值写会到账户中，就可能出现问题。</p> 
<p>如果两个线程几乎同时读取到账户余额为$100，然后它们各自都要在余额上增加$50，理论上最后的余额应该是$200。但是，由于竞态条件，如果它们没有适当的协调机制，可能都读取到$100，各自计算出新的金额$150，并将其写回，最后结果只有$150存入账户，$50就这样丢失了。</p> 
<h4><a id="_2789"></a>竞态条件的类型</h4> 
<ol><li><strong>检查后操作</strong>（Check-Then-Act）：先检查条件，然后基于条件执行操作。如果在检查与操作之间状态改变了，那么操作可能是基于过时的信息。</li><li><strong>读取-修改-写入</strong>（Read-Modify-Write）：当一个线程读取一个值，修改它，然后写回时，如果另一个线程在同一时间做同样的事情，就可能会发生竞态条件。</li></ol> 
<h4><a id="_2794"></a>如何避免竞态条件</h4> 
<p>解决竞态条件的关键在于同步，确保在给定时间内只有一个线程可以访问和修改共享资源。以下是一些常见的同步技术：</p> 
<ol><li><strong>互斥锁（Mutex）</strong>：使用互斥锁可以确保同一时间只有一个线程能进入临界区。</li><li><strong>信号量（Semaphores）</strong>：信号量可以控制对共享资源的访问，通过使用计数器来允许多少个线程可以同时访问资源。</li><li><strong>监视器（Monitors）</strong>：在Java中，<code>synchronized</code>关键字可以用来创建监视器，用于控制对对象的并发访问。</li><li><strong>原子操作</strong>：使用能够保证原子性的数据结构或操作（如 <code>AtomicInteger</code> 类）。</li><li><strong>顺序一致性</strong>：内存模型可以保证顺序一致性，确保程序执行的顺序和预期的一致。</li><li><strong>事务内存（Transactional Memory）</strong>：一些系统提供了事务内存支持，它可以让一组操作或者是全部成功，或者是全部不发生，以此来避免竞态条件。</li></ol> 
<h4><a id="_2805"></a>竞态条件的检测和工具</h4> 
<p>在开发过程中，竞态条件可能不容易被发现，因为它们的发生通常依赖于特定的时序条件。有一些工具和技术可以帮助检测竞态条件：</p> 
<ol><li><strong>静态分析工具</strong>：能够在代码编写时检查潜在的同步问题。</li><li><strong>动态分析工具</strong>：如 Valgrind、Helgrind 等，可以在程序运行时检查竞态条件。</li></ol> 
<p>总的来说，竞态条件是并发编程中常见的问题，它们对程序的正确性构成了严重威胁。通过合理的设计和使用同步机制，可以避免竞态条件的发生。开发人员需要对这些概念有深入的理解，并在实际编程中注意相关问题。</p> 
<h3><a id="font_size4_colorFF000035font_2814"></a><font size="4" color="##FF0000">35、当前读和快照读的区别</font></h3> 
<p>在数据库系统以及数据一致性领域，特别是在事务数据库中，“当前读”（Current Read）和"快照读"（Snapshot Read）是两种常见的数据读取策略。它们各自有不同的用途和特点，针对不同的场景选择合适的读取策略对于保证数据的一致性和事务的隔离性非常关键。</p> 
<h4><a id="Current_Read_2818"></a>当前读（Current Read）</h4> 
<p>当前读是指读取最新版本的数据，也就是说，当一个事务尝试读取一行数据时，它将会得到该数据最近一次被提交的值。如果该数据项正在由另一个未提交的事务持有锁，则当前读操作通常会被阻塞，直至该锁被释放。</p> 
<ul><li><strong>锁定行为</strong>：为了保证读取的数据是最新的，当前读操作通常会对所涉及的数据行加锁。在SQL标准中，这对应了锁定读命令，如<code>SELECT ... FOR UPDATE</code>。</li><li><strong>一致性和隔离性</strong>：当前读可以防止不一致性和脏读（即读取到其他未提交事务的数据），并且在许多隔离级别下都是必须的，如可重复读（Repeatable Read）和串行化（Serializable）。</li><li><strong>性能影响</strong>：由于加锁的需要，当前读可能会导致较高的锁争用，从而影响并发性能。</li></ul> 
<h4><a id="Snapshot_Read_2826"></a>快照读（Snapshot Read）</h4> 
<p>快照读是指读取数据的某一历史版本，这个版本反映了事务开始时或特定时间点的数据状态。这意味着，即使数据在事务执行期间被其他事务修改，事务还是能看到一致的“快照”。</p> 
<ul><li><strong>无锁操作</strong>：快照读通常不需要对数据进行加锁，因为它们访问的是数据的旧版本。</li><li><strong>一致性视图</strong>：快照读能够提供一个事务一致性视图，从而不会看到其他并发事务所做的修改，这有助于减少锁争用并提高并发性能。</li><li><strong>多版本并发控制（MVCC）</strong>：许多支持快照读的数据库管理系统使用MVCC来实现，能够在不锁定资源的情况下，提供一致性的读取。</li></ul> 
<h4><a id="_2834"></a>区别和应用场景</h4> 
<ul><li><strong>事务隔离级别</strong>：当前读通常用于较高的隔离级别（如可重复读和串行化），而快照读则用于较低隔离级别（如读已提交）。</li><li><strong>数据可见性</strong>：当前读保证了读取到的数据是最新的，而快照读可能读取到旧版本的数据。</li><li><strong>锁争用和性能</strong>：快照读由于其无锁操作特点，通常具有更好的并发性能，但在一些情况下可能会牺牲一致性。</li><li><strong>应用场景</strong>：如果应用程序需要处理最新数据并且可以容忍锁等待，则应该使用当前读。如果应用程序可以处理稍微陈旧的数据，并且优先考虑系统的吞吐量和响应时间，则应该使用快照读。</li><li><strong>实现方式</strong>：当前读的实现通常简单，因为它只需要传统的锁机制。而快照读则依赖于数据库管理系统的复杂实现，如MVCC，这需要额外的存储空间来保存数据的多个版本。</li></ul> 
<h4><a id="_2842"></a>结论</h4> 
<p>选择当前读还是快照读取决于应用的具体需求、事务的隔离级别要求以及对性能的影响。数据库管理员和开发人员需要根据不同的工作负载和一致性要求来选择最适合的读取策略。在现代数据库中，快照读的MVCC模型由于其高并发性能和较好的读取一致性保证，常常是默认的选择。</p> 
<h3><a id="font_size4_colorFF000036font_2845"></a><font size="4" color="##FF0000">36、待补充</font></h3> 
<h3><a id="font_size4_colorFF000037font_2849"></a><font size="4" color="##FF0000">37、尽情期待</font></h3>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/acf4d171f4165410fa5de8ff42901eb1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Win11 PS无法拖动文件到任务栏打开</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/76179793c93b0aa0ba1c967f31bd9771/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2678. 老人的数目</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>