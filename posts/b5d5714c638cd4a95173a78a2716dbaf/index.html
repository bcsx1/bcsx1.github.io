<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[机器学习笔记] 混淆矩阵（Confusion Matrix） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[机器学习笔记] 混淆矩阵（Confusion Matrix）" />
<meta property="og:description" content="混淆矩阵（Confusion Matrix） 在机器学习领域，混淆矩阵（Confusion Matrix），又称为可能性矩阵或错误矩阵。混淆矩阵是可视化工具，特别用于监督学习，在无监督学习一般叫做匹配矩阵。在图像精度评价中，主要用于比较分类结果和实际测得值，可以把分类结果的精度显示在一个混淆矩阵里面。
混淆矩阵的结构一般如下图表示的方法。
混淆矩阵要表达的含义：
混淆矩阵的每一列代表了预测类别，每一列的总数表示预测为该类别的数据的数目；每一行代表了数据的真实归属类别，每一行的数据总数表示该类别的数据实例的数目；每一列中的数值表示真实数据被预测为该类的数目。 True Positive（TP）：真正类。样本的真实类别是正类，并且模型识别的结果也是正类。
False Negative（FN）：假负类。样本的真实类别是正类，但是模型将其识别为负类。
False Positive（FP）：假正类。样本的真实类别是负类，但是模型将其识别为正类。
True Negative（TN）：真负类。样本的真实类别是负类，并且模型将其识别为负类。 该矩阵可用于易于理解的二类分类问题，但通过向混淆矩阵添加更多行和列，可轻松应用于具有3个或更多类值的问题。
举例 如有150个样本数据，预测为类I，类II，类III 各为50个。分类结束后得到的混淆矩阵为：
每一行之和表示该类别的真实样本数量，每一列之和表示被预测为该类别的样本数量。
第一行第一列中的43表示有43个实际归属第一类的实例被预测为第一类，同理，第一行第二列的2表示有2个实际归属为第一类的实例被错误预测为第二类。
混淆矩阵是对分类问题的预测结果的总结。使用计数值汇总正确和不正确预测的数量，并按每个类进行细分，这是混淆矩阵的关键所在。混淆矩阵显示了分类模型的在进行预测时会对哪一部分产生混淆。它不仅可以让您了解分类模型所犯的错误，更重要的是可以了解哪些错误类型正在发生。正是这种对结果的分解克服了仅使用分类准确率所带来的局限性。
从混淆矩阵得到分类指标 从混淆矩阵当中，可以得到更高级的分类指标：Accuracy（精确率），Precision（正确率或者准确率），Recall（召回率），Specificity（特异性），Sensitivity（灵敏度）。
计算方法 对于二分类问题，可以将样例根据其真实类别与机器学习器预测类别的组合划分为：
样例总数 = TP &#43; FP &#43; TN &#43; FN。
则可以计算指标：
精确率（Accuracy）：精确率是最常用的分类性能指标。可以用来表示模型的精度，即模型识别正确的个数/样本的总个数。一般情况下，模型的精度越高，说明模型的效果越好。
Accuracy = (TP&#43;TN)/(TP&#43;FN&#43;FP&#43;TN)
正确率或者准确率（Precision）：又称为查准率，表示在模型识别为正类的样本中，真正为正类的样本所占的比例。一般情况下，查准率越高，说明模型的效果越好。
Precision = TP/(TP&#43;FP)
召回率（Recall）：又称为查全率，召回率表现出在实际正样本中，分类器能预测出多少。
Recall（召回率） = Sensitivity（敏感指标，True Positive Rate，TPR）= 查全率
表示的是，模型正确识别出为正类的样本的数量占总的正类样本数量的比值。一般情况下，Recall越高，说明有更多的正类样本被模型预测正确，模型的效果越好。
Recall = TP/(TP&#43;FN)
查准率和查全率是一对矛盾的指标。一般来说，查准率高时，查全率旺旺偏低；二查全率高时，查准率往往偏低。
精确率（Accuracy）和正确率（Precision）的区别
Accuracy，不管是哪个类别，只要预测正确，其数量都放在分子上，而分母是全部数据量，说明这个精确率是对全部数据的判断。
而正确率在分类中对应的是某个类别，分子是预测该类别正确的数量，分母是预测为该类别的全部的数量。
或者说，Accuracy是对分类器整体上的精确率的评价，而Precision是分类器预测为某一个类别的精确的评价。
Specificity（特异性）：特异性指标，表示的是模型识别为负类的样本的数量，占总的负类样本数量的比值。
负正类率（False Positive Rate, FPR），计算公式为：FPR=FP/(TN&#43;FP)，计算的是模型错识别为正类的负类样本占所有负类样本的比例，一般越低越好。
Specificity = 1 - FPR Fβ_Score：Fβ的物理意义就是将正确率和召回率的一种加权平均，在合并的过程中，召回率的权重是正确率的β倍。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/b5d5714c638cd4a95173a78a2716dbaf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-24T01:38:51+08:00" />
<meta property="article:modified_time" content="2020-03-24T01:38:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[机器学习笔记] 混淆矩阵（Confusion Matrix）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>混淆矩阵（Confusion Matrix）</h4> 
<p>在机器学习领域，混淆矩阵（Confusion Matrix），又称为可能性矩阵或错误矩阵。混淆矩阵是可视化工具，特别用于监督学习，在无监督学习一般叫做匹配矩阵。在图像精度评价中，主要用于比较分类结果和实际测得值，可以把分类结果的精度显示在一个混淆矩阵里面。</p> 
<p>混淆矩阵的结构一般如下图表示的方法。</p> 
<p>混淆矩阵要表达的含义：</p> 
<ul><li>混淆矩阵的每一列代表了预测类别，每一列的总数表示预测为该类别的数据的数目；</li><li>每一行代表了数据的真实归属类别，每一行的数据总数表示该类别的数据实例的数目；每一列中的数值表示真实数据被预测为该类的数目。</li></ul> 
<p><img alt="" height="500" src="https://images2.imgbox.com/90/3f/QvODqqK7_o.jpg" width="500"></p> 
<p> True Positive（TP）：真正类。样本的真实类别是正类，并且模型识别的结果也是正类。</p> 
<p> False Negative（FN）：假负类。样本的真实类别是正类，但是模型将其识别为负类。</p> 
<p> False Positive（FP）：假正类。样本的真实类别是负类，但是模型将其识别为正类。</p> 
<p> True Negative（TN）：真负类。样本的真实类别是负类，并且模型将其识别为负类。 </p> 
<p> <span style="color:#f33b45;"><strong>该矩阵可用于易于理解的二类分类问题，但通过向混淆矩阵添加更多行和列，可轻松应用于具有3个或更多类值的问题。</strong></span></p> 
<hr> 
<h4>举例</h4> 
<p>如有150个样本数据，预测为类I，类II，类III 各为50个。分类结束后得到的混淆矩阵为：</p> 
<p><img alt="" src="https://images2.imgbox.com/35/4a/tH0pzWHN_o.png"></p> 
<p>每一行之和表示该类别的真实样本数量，每一列之和表示被预测为该类别的样本数量。</p> 
<p>第一行第一列中的43表示有43个实际归属第一类的实例被预测为第一类，同理，第一行第二列的2表示有2个实际归属为第一类的实例被错误预测为第二类。</p> 
<p>混淆矩阵是对分类问题的预测结果的总结。使用计数值汇总正确和不正确预测的数量，并按每个类进行细分，这是混淆矩阵的关键所在。混淆矩阵显示了分类模型的在进行预测时会对哪一部分产生混淆。它不仅可以让您了解分类模型所犯的错误，更重要的是可以了解哪些错误类型正在发生。正是这种对结果的分解克服了仅使用分类准确率所带来的局限性。</p> 
<hr> 
<h4>从混淆矩阵得到分类指标</h4> 
<p>从混淆矩阵当中，可以得到更高级的分类指标：Accuracy（精确率），Precision（正确率或者准确率），Recall（召回率），Specificity（特异性），Sensitivity（灵敏度）。</p> 
<h4>计算方法</h4> 
<p>对于二分类问题，可以将样例根据其真实类别与机器学习器预测类别的组合划分为：</p> 
<p>样例总数 = TP + FP + TN + FN。</p> 
<p>则可以计算指标：<img alt="总样例数 = TP + FP + TN + FN" class="mathcode" src="https://images2.imgbox.com/c9/59/qcM8EYCX_o.gif"></p> 
<p><strong>精确率（Accuracy）：</strong>精确率是最常用的分类性能指标。可以用来表示模型的精度，即模型识别正确的个数/样本的总个数。一般情况下，模型的精度越高，说明模型的效果越好。</p> 
<p><strong><span style="color:#3399ea;">Accuracy = (TP+TN)/(TP+FN+FP+TN)</span></strong></p> 
<p> </p> 
<p><strong>正确率或者准确率（Precision）：</strong>又称为查准率，表示在模型识别为正类的样本中，真正为正类的样本所占的比例。一般情况下，查准率越高，说明模型的效果越好。</p> 
<p><strong><span style="color:#3399ea;">Precision = TP/(TP+FP)</span></strong></p> 
<p> </p> 
<p><strong>召回率（Recall）：</strong>又称为查全率<strong>，</strong>召回率表现出在实际正样本中，分类器能预测出多少。</p> 
<p>Recall（召回率） = Sensitivity（敏感指标，True Positive Rate，TPR）= 查全率</p> 
<p>表示的是，模型正确识别出为正类的样本的数量占总的正类样本数量的比值。一般情况下，Recall越高，说明有更多的正类样本被模型预测正确，模型的效果越好。</p> 
<p><span style="color:#3399ea;"><strong>Recall = TP/(TP+FN)</strong></span></p> 
<p> </p> 
<p><span style="color:#f33b45;">查准率和查全率是一对矛盾的指标。一般来说，查准率高时，查全率旺旺偏低；二查全率高时，查准率往往偏低。</span></p> 
<p><span style="color:#f33b45;"><strong>精确率（Accuracy）和正确率（Precision）的区别</strong></span></p> 
<p>Accuracy，不管是哪个类别，只要预测正确，其数量都放在分子上，而分母是全部数据量，说明这个精确率是对全部数据的判断。<br> 而正确率在分类中对应的是某个类别，分子是预测该类别正确的数量，分母是预测为该类别的全部的数量。<br> 或者说，Accuracy是对分类器整体上的精确率的评价，而Precision是分类器预测为某一个类别的精确的评价。</p> 
<p><strong>Specificity（特异性）：</strong>特异性指标，表示的是模型识别为负类的样本的数量，占总的负类样本数量的比值。</p> 
<p><strong>负正类率（False Positive Rate, FPR），</strong>计算公式为：FPR=FP/(TN+FP)，计算的是模型错识别为正类的负类样本占所有负类样本的比例，一般越低越好。</p> 
<p><strong><span style="color:#3399ea;">Specificity = 1 - FPR </span></strong></p> 
<p> </p> 
<p><strong>Fβ_Score：</strong>Fβ的物理意义就是将正确率和召回率的一种加权平均，在合并的过程中，召回率的权重是正确率的β倍。</p> 
<p>F1分数认为召回率和正确率同等重要，F2分数认为召回率的重要程度是正确率的2倍，而F0.5分数认为召回率的重要程度是正确率的一半。<span style="color:#f33b45;"><strong>比较常用的是F1分数（F1 Score），是统计学中用来衡量二分类模型精确度的一种指标。</strong></span></p> 
<p><strong>F1_Score：</strong>数学定义为 F1分数（F1-Score），又称为<strong>平衡 F分数（Balanced Score）</strong>，<strong><span style="color:#3399ea;">它被定义为正确率和召回率的调和平均数。</span></strong>在 β=1 的情况，F1-Score的值是从0到1的，1是最好，0是最差。</p> 
<p><strong><span style="color:#f33b45;">因此我们知道，计算Precision，Recall，Specificity等只是计算某一分类的特性，而Accuracy和F1-Score是判断分类模型总体的标准。</span></strong></p> 
<hr> 
<h4>关于AUC</h4> 
<p><a href="http://fastml.com/what-you-wanted-to-know-about-auc/" rel="nofollow">http://fastml.com/what-you-wanted-to-know-about-auc/</a></p> 
<p>AUC, or Area Under Curve, is a metric for binary classification. It’s probably the second most popular one, after accuracy. Unfortunately, it’s nowhere near as intuitive. That is, until you have read this article.</p> 
<p>Accuracy deals with ones and zeros, meaning you either got the class label right or you didn’t. But many classifiers are able to quantify their uncertainty about the answer by outputting a probability value. To compute accuracy from probabilities you need a threshold to decide when zero turns into one. The most natural threshold is of course 0.5.</p> 
<p>Let’s suppose you have a quirky classifier. It is able to get all the answers right, but it outputs 0.7 for negative examples and 0.9 for positive examples. Clearly, a threshold of 0.5 won’t get you far here. But 0.8 would be just perfect.</p> 
<p>That’s the whole point of using AUC - it considers all possible thresholds. Various thresholds result in different true positive/false positive rates. As you decrease the threshold, you get more true positives, but also more false positives. The relation between them can be plotted:</p> 
<p><img alt="" src="https://images2.imgbox.com/2e/a3/PgkxsstC_o.png"></p> 
<p>Image credit: Wikipedia</p> 
<p>From a random classifier you can expect as many true positives as false positives. That’s the dashed line on the plot. AUC score for the case is 0.5. A score for a perfect classifier would be 1. Most often you get something in between.</p> 
<hr> 
<p>下面是网络上找到一些资料</p> 
<hr> 
<h4>ROC/AUC的概念</h4> 
<h4 id="1.-%E7%81%B5%E6%95%8F%E5%BA%A6%EF%BC%8C%E7%89%B9%E5%BC%82%E5%BA%A6%EF%BC%8C%E7%9C%9F%E6%AD%A3%E7%8E%87%EF%BC%8C%E5%81%87%E6%AD%A3%E7%8E%87">1. 灵敏度，特异度，真正率，假正率</h4> 
<p>在正式介绍ROC/AUC之前，我们还要再介绍两个指标，<strong>这两个指标的选择也正是ROC和AUC可以无视样本不平衡的原因。</strong>这两个指标分别是：<strong>灵敏度和（1-特异度），也叫做真正率（TPR）和假正率（FPR）</strong>。</p> 
<p>灵敏度（Sensitivity） = <strong>TP/(TP+FN)</strong></p> 
<p>特异度（Specificity） = <strong>TN/(FP+TN)</strong></p> 
<ul><li>其实我们可以发现灵敏度和召回率是一模一样的，只是名字换了而已。</li><li>由于我们比较关心正样本，所以需要查看有多少负样本被错误地预测为正样本，所以使用（1-特异度），而不是特异度。</li></ul> 
<p>真正率（TPR） = 灵敏度 = <strong>TP/(TP+FN)</strong></p> 
<p>假正率（FPR） = 1- 特异度 = <strong>FP/(FP+TN)</strong></p> 
<p>下面是真正率和假正率的示意，我们发现<strong>TPR和FPR分别是基于实际表现1和0出发的，也就是说它们分别在实际的正样本和负样本中来观察相关概率问题。</strong>正因为如此，所以无论样本是否平衡，都不会被影响。还是拿之前的例子，总样本中，90%是正样本，10%是负样本。我们知道用准确率是有水分的，但是用TPR和FPR不一样。这里，TPR只关注90%正样本中有多少是被真正覆盖的，而与那10%毫无关系，同理，FPR只关注10%负样本中有多少是被错误覆盖的，也与那90%毫无关系，所以可以看出：<strong>如果我们从实际表现的各个结果角度出发，就可以避免样本不平衡的问题了，这也是为什么选用TPR和FPR作为ROC/AUC的指标的原因。</strong></p> 
<hr> 
<p>学习中看到一篇文章中提出了一个问题，关于：<strong>特异性（Specificity）和灵敏度（Sensitivity）</strong></p> 
<p><strong>记录下来，还没有理解。</strong></p> 
<p>考虑一个二分类的情况，类别为1和0，我们将1和0分别作为正类（positive）和负类（negative），则实际分类的结果有4种，表格如下：</p> 
<p><img alt="" src="https://images2.imgbox.com/6f/6d/t7ARNnFF_o.png"></p> 
<p>从这个表格中可以引出一些其它的评价指标：</p> 
<ul><li><strong>ACC</strong>：classification accuracy，描述分类器的分类准确率<br> 计算公式为：ACC=(TP+TN)/(TP+FP+FN+TN)</li><li><strong>BER</strong>：balanced error rate<br> 计算公式为：BER=1/2*(FPR+FN/(FN+TP))</li><li><strong>TPR</strong>：true positive rate，描述识别出的所有正例占所有正例的比例<br> 计算公式为：TPR=TP/ (TP+ FN)</li><li><strong>FPR</strong>：false positive rate，描述将负例识别为正例的情况占所有负例的比例<br> 计算公式为：FPR= FP / (FP + TN)</li><li><strong>TNR</strong>：true negative rate，描述识别出的负例占所有负例的比例<br> 计算公式为：TNR= TN / (FP + TN)</li><li><strong>PPV</strong>：<a href="https://link.jianshu.com/?t=https://en.wikipedia.org/wiki/Positive_predictive_value" rel="nofollow">Positive predictive value</a><br> 计算公式为：PPV=TP / (TP + FP)</li><li><strong>NPV</strong>：<a href="https://link.jianshu.com/?t=https://en.wikipedia.org/wiki/Negative_predictive_value" rel="nofollow">Negative predictive value</a><br> 计算公式：NPV=TN / (FN + TN)<br> 其中<strong>TPR</strong>即为敏感度（sensitivity），<strong>TNR</strong>即为特异度（specificity）。</li></ul> 
<blockquote> 
 <p>维基百科的附图：</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/06/cd/e9Q0DXIA_o.png"></p> 
<p> </p> 
<p>如下是截取的wiki上的一个截图（https://en.wikipedia.org/wiki/Confusion_matrix） </p> 
<p><img alt="" src="https://images2.imgbox.com/6a/47/Mrc4aqSp_o.png"></p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/753ae69cb5e1b4a357101a8750460844/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android 手动设置屏幕方向后不能自动转屏问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fcddabf5779314b7de4d4f42299f45f5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">高精度运算（大数运算）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>