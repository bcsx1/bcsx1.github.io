<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;11】C&#43;&#43; STL（面试复习整理-2.0） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C&#43;&#43;11】C&#43;&#43; STL（面试复习整理-2.0）" />
<meta property="og:description" content="目录
1、六大组件介绍
2、容器
顺序容器
vector
list
deque
三、关联容器
map
四、set
适配器
stack
queue &amp; priority_queue
3、红黑树为底层的容器及红黑树
红黑树为底层的容器
红黑树
hash表为底层的容器及hash表
hash表为底层的容器
hash表冲突解决
六、各个容器的使用场景
1、六大组件介绍 STL六大组件
容器：数据结构，用来存放数据
算法：常用算法
迭代器：容器和算法之间的胶合剂，“范型指针”
仿函数：一种重载了operator()的类，使得这个类的使用看上去像一个函数
配置器：为容器分配并管理内存
适配器：修改其他组件接口 （stack、queue、qriority_queue）
2、容器 顺序容器 vector 底层为数组，支持随机访问，节点大小是动态的，支持下标访问。随机存取效率很高（O(1)），插入效率不高。
扩容原理：以原大小的两倍配置一份新空间，将原空间数据拷贝过来，会导致迭代器失效
常用函数
size()：当前vector元素个数
capacity()：vector已分配空间容量
reserve()：预分配空间,分配空间小于现有空间，不改变空间容量
resize()：改变size大小，不改变容量大小
#include&lt;iostream&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include&lt;vector&gt; using namespace std; void Push(vector&lt;int&gt; &amp;vec,int i){ vec.push_back(i); cout&lt;&lt;&#34;vector放入&#34;&lt;&lt;i&lt;&lt;&#34;个元素时&#34;&lt;&lt;endl; cout&lt;&lt;&#34;vec.size()=&#34;&lt;&lt;vec.size()&lt;&lt;&#34;	vec.capacity()=&#34;&lt;&lt;vec.capacity()&lt;&lt;endl; } int main(){ vector&lt;int&gt; vec; cout&lt;&lt;&#34;vector未放入元素时&#34;&lt;&lt;endl; cout&lt;&lt;&#34;vec.size()=&#34;&lt;&lt;vec.size()&lt;&lt;&#34;	vec.capacity()=&#34;&lt;&lt;vec.capacity()&lt;&lt;endl; for(int i=1;i&lt;4;i&#43;&#43;){ Push(vec,i); } cout&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/3a7f1d49d5c217522a7dae9d1060ef4e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-15T00:58:46+08:00" />
<meta property="article:modified_time" content="2022-09-15T00:58:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;11】C&#43;&#43; STL（面试复习整理-2.0）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D" rel="nofollow">1、六大组件介绍</a></p> 
<p id="2%E3%80%81%E5%AE%B9%E5%99%A8-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E5%AE%B9%E5%99%A8" rel="nofollow">2、容器</a></p> 
<p id="%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8" rel="nofollow">顺序容器</a></p> 
<p id="vector-toc" style="margin-left:80px;"><a href="#vector" rel="nofollow">vector</a></p> 
<p id="list-toc" style="margin-left:80px;"><a href="#list" rel="nofollow">list</a></p> 
<p id="deque-toc" style="margin-left:80px;"><a href="#deque" rel="nofollow">deque</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8" rel="nofollow">三、关联容器</a></p> 
<p id="map-toc" style="margin-left:80px;"><a href="#map" rel="nofollow">map</a></p> 
<p id="%E5%9B%9B%E3%80%81set-toc" style="margin-left:80px;"><a href="#%E5%9B%9B%E3%80%81set" rel="nofollow">四、set</a></p> 
<p id="%E9%80%82%E9%85%8D%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E9%80%82%E9%85%8D%E5%99%A8" rel="nofollow">适配器</a></p> 
<p id="stack-toc" style="margin-left:80px;"><a href="#stack" rel="nofollow">stack</a></p> 
<p id="queue%20%26%20priority_queue-toc" style="margin-left:80px;"><a href="#queue%20%26%20priority_queue" rel="nofollow">queue &amp; priority_queue</a></p> 
<p id="3%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%BA%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%BA%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91" rel="nofollow">3、红黑树为底层的容器及红黑树</a></p> 
<p id="%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%BA%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%BA%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%B9%E5%99%A8" rel="nofollow">红黑树为底层的容器</a></p> 
<p id="%E7%BA%A2%E9%BB%91%E6%A0%91-toc" style="margin-left:80px;"><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91" rel="nofollow">红黑树</a></p> 
<p id="hash%E8%A1%A8%E4%B8%BA%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8Ahash%E8%A1%A8-toc" style="margin-left:0px;"><a href="#hash%E8%A1%A8%E4%B8%BA%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8Ahash%E8%A1%A8" rel="nofollow">hash表为底层的容器及hash表</a></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="hash%E8%A1%A8%E4%B8%BA%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#hash%E8%A1%A8%E4%B8%BA%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%B9%E5%99%A8" rel="nofollow">hash表为底层的容器</a></p> 
<p id="hash%E8%A1%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3-toc" style="margin-left:80px;"><a href="#hash%E8%A1%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3" rel="nofollow">hash表冲突解决</a></p> 
<p id="%E5%85%AD%E3%80%81%E5%90%84%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E5%90%84%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">六、各个容器的使用场景</a></p> 
<hr id="hr-toc"> 
<h2 id="1%E3%80%81%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D">1、六大组件介绍</h2> 
<p><a href="https://www.cnblogs.com/welen/articles/3533008.html" rel="nofollow" title="STL六大组件">STL六大组件</a><br> 容器：数据结构，用来存放数据<br> 算法：常用算法<br> 迭代器：容器和算法之间的胶合剂，“范型指针”<br> 仿函数：一种重载了operator()的类，使得这个类的使用看上去像一个函数<br> 配置器：为容器分配并管理内存<br> 适配器：修改其他组件接口 （stack、queue、qriority_queue）</p> 
<p></p> 
<h2 id="2%E3%80%81%E5%AE%B9%E5%99%A8">2、容器</h2> 
<h3 id="%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8">顺序容器</h3> 
<h4 id="vector">vector</h4> 
<p><br> 底层为数组，支持随机访问，节点大小是动态的，支持下标访问。随机存取效率很高（O(1)），插入效率不高。<br> 扩容原理：以原大小的两倍配置一份新空间，将原空间数据拷贝过来，<span style="color:#f33b45;">会导致迭代器失效</span></p> 
<p>常用函数<br> size()：当前vector元素个数<br> capacity()：vector已分配空间容量<br> reserve()：预分配空间,分配空间小于现有空间，不改变空间容量<br> resize()：改变size大小，不改变容量大小<br>  </p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include&lt;vector&gt;

using namespace std;

void Push(vector&lt;int&gt; &amp;vec,int i){
	vec.push_back(i);
	cout&lt;&lt;"vector放入"&lt;&lt;i&lt;&lt;"个元素时"&lt;&lt;endl; 
	cout&lt;&lt;"vec.size()="&lt;&lt;vec.size()&lt;&lt;"	vec.capacity()="&lt;&lt;vec.capacity()&lt;&lt;endl;
}

int main(){
	vector&lt;int&gt; vec;
	
	cout&lt;&lt;"vector未放入元素时"&lt;&lt;endl; 
	cout&lt;&lt;"vec.size()="&lt;&lt;vec.size()&lt;&lt;"	vec.capacity()="&lt;&lt;vec.capacity()&lt;&lt;endl;
	
	for(int i=1;i&lt;4;i++){
		Push(vec,i);
	}
	cout&lt;&lt;"vec中元素现为"&lt;&lt;endl; 
	vector&lt;int&gt;::iterator iter=vec.begin();
	while(iter!=vec.end()){
		cout&lt;&lt;*iter++&lt;&lt;" ";
	}
	cout&lt;&lt;endl;

	vec.resize(2);
	cout&lt;&lt;"在vec.resize(2)后"&lt;&lt;endl; 
	cout&lt;&lt;"vec.size()="&lt;&lt;vec.size()&lt;&lt;"	vec.capacity()="&lt;&lt;vec.capacity()&lt;&lt;endl;
	cout&lt;&lt;"vec中元素变为"&lt;&lt;endl; 
	iter=vec.begin();
	while(iter!=vec.end()){
		cout&lt;&lt;*iter++&lt;&lt;" ";
	}
	cout&lt;&lt;endl;
	
	vec.reserve(3);
	cout&lt;&lt;"在vec.reserve(3)后"&lt;&lt;endl; 
	cout&lt;&lt;"vec.size()="&lt;&lt;vec.size()&lt;&lt;"	vec.capacity()="&lt;&lt;vec.capacity()&lt;&lt;endl;
	
	vec.reserve(5);
	cout&lt;&lt;"在vec.reserve(5)后"&lt;&lt;endl; 
	cout&lt;&lt;"vec.size()="&lt;&lt;vec.size()&lt;&lt;"	vec.capacity()="&lt;&lt;vec.capacity()&lt;&lt;endl;
	return 0;
} 
</code></pre> 
<pre><code class="language-cpp">结果为：
vector未放入元素时
vec.size()=0    vec.capacity()=0
vector放入1个元素时
vec.size()=1    vec.capacity()=1
vector放入2个元素时
vec.size()=2    vec.capacity()=2
vector放入3个元素时
vec.size()=3    vec.capacity()=4
vec中元素现为
1 2 3
在vec.resize(2)后
vec.size()=2    vec.capacity()=4
vec中元素变为
1 2
在vec.reserve(3)后
vec.size()=2    vec.capacity()=4
在vec.reserve(5)后
vec.size()=2    vec.capacity()=5
</code></pre> 
<p><span style="color:#f33b45;">若是循环体内包含向vector对象添加元素的语句，则不能使用范围for循环。因为范围for语句不应改变其所遍历序列的额大小。原因如下：</span></p> 
<pre><code class="language-cpp"> 1 vector&lt;int&gt; v={1,2,3,4,5,6,7,8,9};
 2 for(auto &amp;r: v)
 3 {
 4     r*=2;
 5 }
 6 
 7 等价于
 8 for(auto beg=v.begin(),end=v.end();beg !=end;++beg)
 9 {
10     auto &amp;r=*beg;
11     r*=2;
12 }</code></pre> 
<p><span style="color:#f33b45;"><u><strong> 即在范围for语句中，预存了end()的值，一旦在序列中添加（删除）元素，end函数的值就可能变的无效了。</strong></u></span></p> 
<p><strong>由于vector的动态内存变化的机制，在插入和删除时，<span style="color:#f33b45;">需要考虑迭代的是否有效问题</span></strong></p> 
<p>《数组和vector、array三者区别和联系》：<a href="https://blog.csdn.net/bandaoyu/article/details/85066924" title="【C++容器】数组和vector、array三者区别和联系_bandaoyu的博客-CSDN博客_array vector">【C++容器】数组和vector、array三者区别和联系_bandaoyu的博客-CSDN博客_array vector</a></p> 
<p></p> 
<p>2、vector优缺点<br> 优点：<br> 1)使用连续的存储空间，访问速度快。<br> 2) 支持随机访问，可以通过[ ]操作符和at()方法访问数据。<br> 3）可以不指定内存大小即可实现对像数组一样的操作，实际内部实现vector是预先分配了一块固定大小的内存，当超过该内存块时，vector会重新找一块更大的内存，并把当前的释放掉。<br><em>（之前写过两篇文章对vector内存进行过剖析，感兴趣可以看看：<br> 文章1：https://blog.csdn.net/toby54king/article/details/86737201，<br> 文章2：https://blog.csdn.net/toby54king/article/details/88543270）</em><br> 4)可以快速的在尾部进行插入和删除，即通过push_back() 和pop_back()方法。</p> 
<p>缺点：<br> 1)vector内部进行插入删除操作效率低。<br> 2) 只能在vector的尾部进行push和pop。<br> 3) 添加数据占用内存超过vector预先分配的大小时，需要重新分配、拷贝与释放。<br> 原文链接：https://blog.csdn.net/toby54king/article/details/104979593</p> 
<p></p> 
<p><strong>vector代码示例</strong></p> 
<pre><code class="language-cpp">// TestVector.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;

using namespace std;

// 打印函数
void MyPrintf(int &amp;elem)
{
	cout &lt;&lt; elem &lt;&lt; ", ";
}

// 修改元素函数
void MyAdd(int &amp;elem)
{
	elem = elem + 10;
}

int main()
{
	cout &lt;&lt; "------------------------C++序列化容器vector的使用--------------------" &lt;&lt; endl;
	// 1、增加元素
	cout &lt;&lt; "-----------------------vector增加元素--------------------" &lt;&lt; endl;
	vector&lt;int&gt; myVector;
	for (int i=0; i&lt;10; i++)
	{
		//myVector.push_back(i);
		myVector.emplace_back(i); // C++11
	}
	for_each(myVector.begin(),myVector.end(), MyPrintf);
	cout &lt;&lt; endl;

	// 2、排序元素
	cout &lt;&lt; "-----------------------vector排序元素--------------------" &lt;&lt; endl;
	sort(myVector.begin(), myVector.end(), greater&lt;int&gt;());
	for_each(myVector.begin(), myVector.end(), MyPrintf);
	cout &lt;&lt; endl;

	// 3、修改元素
	cout &lt;&lt; "-----------------------vector修改元素--------------------" &lt;&lt; endl;
	for_each(myVector.begin(), myVector.end(), MyAdd);
	for_each(myVector.begin(), myVector.end(), MyPrintf);
	cout &lt;&lt; endl;

	// 4、查找元素
	cout &lt;&lt; "-----------------------vector查找元素--------------------" &lt;&lt; endl;
	vector&lt;int&gt;::iterator index;
	index = find(myVector.begin(), myVector.end(), 10); // 查找元素10
	// 注意：元素的索引从0开始的
	cout &lt;&lt; "元素10的索引index是： " &lt;&lt; (index - myVector.begin()) &lt;&lt; endl;
	index = find_if(myVector.begin(), myVector.end(), bind2nd(less&lt;int&gt;(),15));
	cout &lt;&lt; "第一个小于15的元素索引index是： " &lt;&lt; (index - myVector.begin()) &lt;&lt; endl;

	// 5、删除元素
	cout &lt;&lt; "-----------------------vector删除元素--------------------" &lt;&lt; endl;
	while (!myVector.empty())
	{
		int backNum = myVector.back();
		cout &lt;&lt; backNum &lt;&lt; ", ";
		myVector.pop_back();
	}
	cout &lt;&lt; endl;
	
    std::cout &lt;&lt; "Hello World!\n";
	getchar();
}
</code></pre> 
<p>运行结果： </p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/14/a9/o1Gj9rmM_o.png"></p> 
<p></p> 
<h4 id="list">list</h4> 
<p><br> 底层为双向链表，内存空间不连续，只能通过指针访问数据，<strong>插入删除高效</strong>，不支持下标访问，list对于随机访问速度慢。适用于对象需要大量删除插入操作的环境。<br> list的iterator不支持+，+=，&lt;操作</p> 
<p>list.sort()：合并前两个元素，合并后两个元素，两个子序列合并，序列大小变化顺序为2-&gt;4-&gt;8-&gt;16…完成排序（O(log(n))）<br>  </p> 
<p>2、list优缺点<br> 优点：<br> 1)不使用连续存储空间来完成动态操作。<br> 2)内部进行插入和删除操作非常方便。<br> 3)可以在两端进行插入和删除操作。<br> 4])不需要预先分配内存空间。</p> 
<p>缺点：<br> 1)不能进行内部的随机访问，因为不支持下标索引。<br> 2)<span style="color:#f33b45;"><strong>比verctor占用内存多，因为要存储其前驱和后继节点的信息</strong></span>。<br> 原文链接：https://blog.csdn.net/toby54king/article/details/104979593</p> 
<p><strong>list代码示例</strong></p> 
<pre><code class="language-cpp">// Testlist.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;

using namespace std;

// 打印函数
void MyPrintf(int &amp;elem)
{
	cout &lt;&lt; elem &lt;&lt; ", ";
}

// 修改元素函数
void MyAdd(int &amp;elem)
{
	elem = elem + 10;
}

int main()
{
	cout &lt;&lt; "------------------------C++序列化容器list的使用--------------------" &lt;&lt; endl;
	// 1、增加元素
	cout &lt;&lt; "-----------------------list增加元素--------------------" &lt;&lt; endl;
	list&lt;int&gt; myList;
	for (int i = 0; i &lt; 10; i++)
	{
		//myList.push_back(i);
		myList.emplace_back(i); // C++11
	}
	for_each(myList.begin(), myList.end(), MyPrintf);
	cout &lt;&lt; endl;

	// 2、排序元素
	cout &lt;&lt; "-----------------------list排序元素--------------------" &lt;&lt; endl;
	myList.sort(greater&lt;int&gt;());
	for_each(myList.begin(), myList.end(), MyPrintf);
	cout &lt;&lt; endl;

	// 3、修改元素
	cout &lt;&lt; "-----------------------list修改元素--------------------" &lt;&lt; endl;
	for_each(myList.begin(), myList.end(), MyAdd);
	for_each(myList.begin(), myList.end(), MyPrintf);
	cout &lt;&lt; endl;
	// list反序排列
	cout &lt;&lt; "-----------------------list反序排列元素--------------------" &lt;&lt; endl;
	myList.reverse();
	for_each(myList.begin(), myList.end(), MyPrintf);
	cout &lt;&lt; endl;

	// 4、查找元素
	cout &lt;&lt; "-----------------------list查找元素--------------------" &lt;&lt; endl;
	list&lt;int&gt;::iterator index;
	index = find(myList.begin(), myList.end(), 10); // 查找元素10
	if (index != myList.end())
	{
		cout &lt;&lt; "找到元素10了，删除该元素" &lt;&lt; endl;
		myList.remove(10);
	}
	for_each(myList.begin(), myList.end(), MyPrintf);
	cout &lt;&lt; endl;
	index = find_if(myList.begin(), myList.end(), bind2nd(greater&lt;int&gt;(), 15));
	if (index != myList.end())
	{
		cout &lt;&lt; "第一个大于15的元素找到了" &lt;&lt; endl;
	}

	// 5、删除元素
	cout &lt;&lt; "-----------------------list删除元素--------------------" &lt;&lt; endl;
	myList.remove_if(bind2nd(equal_to&lt;int&gt;(), 15)); // 删除等于15的元素
	cout &lt;&lt; "-----------------------list删除等于15的元素后--------------------" &lt;&lt; endl;
	for_each(myList.begin(), myList.end(), MyPrintf);
	cout &lt;&lt; endl;
	cout &lt;&lt; "删除所有的元素" &lt;&lt; endl;
	while (!myList.empty())
	{
		int backNum = myList.back();
		cout &lt;&lt; backNum &lt;&lt; ", ";
		myList.pop_back();
	}
	cout &lt;&lt; endl;

	std::cout &lt;&lt; "Hello World!\n";
	getchar();
}
</code></pre> 
<p>运行结果：</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/61/aa/y78pJTic_o.png"></p> 
<p><strong>STL 中list的sort()方法使用总结</strong></p> 
<p>1、list中数据类型为基本类型，例如为整数类型排序：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt; 
#include &lt;list&gt;
using namespace std;
 
int main()
{
    list&lt;int&gt; num;
    num.push_back( 1 );
    num.push_back( 3 );
    num.push_back( 2 );
    num.push_back( 9 );
    num.push_back( 5 );
    num.sort();
    list&lt;int&gt;::iterator vi;
    for( vi=num.begin();vi!=num.end();vi++) 
    {
        cout  &lt;&lt; *vi &lt;&lt; endl;
    } 
    
    return 0;
}</code></pre> 
<p>输出为：</p> 
<p><img alt="" src="https://images2.imgbox.com/51/be/oNmKwhek_o.png"></p> 
<p>2、list中的类型为自定义类型</p> 
<p>比方说是一个自定义的类，那么如果想为这个类所生成的对象排序的话，因为list.sort()默认排序需要重载 &lt; 操作符。所以我们必须在类对象里重载这个操作符。例子如下：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt; 
#include &lt;list&gt;
using namespace std;
 
 
class student
 {
    public:
      int age;
      student()
      {}
      student(int a)
      {
          this-&gt;age=a;
      }
  public:
      bool operator &lt; (student b)
     {
           return this-&gt;age &lt; b.age;
     }
 
     bool operator &gt; (student b)
     {
           return this-&gt;age &gt; b.age;
     } 
 
 }; 
 
int main()
{
    list&lt;student&gt; num;
    num.push_back( student(1) );
    num.push_back( student(5));
    num.push_back( student(2));
    num.push_back( student(6));
    num.sort();
   // sort(num.begin(),num.end());
    list&lt;student&gt;::iterator vi;
 
    for( vi=num.begin();vi!=num.end();vi++) 
    {
        cout  &lt;&lt; vi-&gt;age &lt;&lt; endl;
    }
    num.clear();
    
}</code></pre> 
<p>输出为：</p> 
<p><img alt="" src="https://images2.imgbox.com/73/4d/ugBpC672_o.png"></p> 
<p>总结：事实上，list有两个版本的sort成员函数：   </p> 
<p>  一个是不带参数的sort()，用来实现升序排列；另一个嘛，另一个是带参数的sort(greater&lt;T&gt;   pr)，用来实现降序排列。后者的greater实际上是被VC实作好的一个二元函数（binary   funtion)对象，具体可以参见参考文档[1]</p> 
<p></p> 
<p>3、自定义规则进行排序</p> 
<p>3.1 使用函数对象 (参考[2]）</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;list&gt;
using namespace std;
 
class A{
public:
 int a,b;
 A(int t1,int t2){a=t1,b=t2;}
};
 
 
struct node{
 bool operator()(const A&amp; t1,const A&amp; t2){
  return t1.a&lt;t2.a;    //会产生升序排序,若改为&gt;,则变为降序
 }
};
 
int main() {
 list&lt;A&gt; list_a;
 A a1(1,2), a2(4,6), a3(2,8);
 list_a.push_back(a1);
 list_a.push_back(a2);
 list_a.push_back(a3);
 
 list_a.sort(node()); //排序操作； 
 
 list&lt;A&gt;::iterator ite;
 ite=list_a.begin();
 for(int i=0;i&lt;3;i++)  {cout&lt;&lt;ite-&gt;a&lt;&lt;endl; ite++;}
 
 return 0;
 
}</code></pre> 
<pre><code class="language-html">输出为
</code></pre> 
<p><img alt="" src="https://images2.imgbox.com/0a/69/hc3zlGCO_o.png"></p> 
<p></p> 
<p>3.2 使用回调函数自定义排序规则：（参考[3]）</p> 
<pre><code class="language-cs">#include&lt;iostream&gt;
#include&lt;list&gt;
using namespace std;

class A
{
public:
    int a, b;
    A(int t1, int t2)
    {
        a = t1, b = t2;
    }
};

bool compare(A a1, A a2)
{
    return a1.a &lt; a2.a;  //会产生升序排列，若改为&gt;,则会产生降序；
}

int main()
{
    list&lt;A&gt; list_a;
    A a1(1, 2), a2(4, 6), a3(2, 8);
    list_a.push_back(a1);
    list_a.push_back(a2);
    list_a.push_back(a3);

    list_a.sort(compare); //排序操作；

    list&lt;A&gt;::iterator ite;
    ite = list_a.begin();
    for(int i = 0; i &lt; 3; i++)
    {
        cout &lt;&lt; ite-&gt;a &lt;&lt; endl;
        ite++;
    }

    return 0;

}</code></pre> 
<p>输出为：</p> 
<p><img alt="" src="https://images2.imgbox.com/ba/c6/KOjqzXIK_o.png"></p> 
<p></p> 
<p>注：使用C-Free中的gcc版本 ：4.9.2</p> 
<h4 id="deque">deque</h4> 
<p><br> 1、deque概述<br> deque属于序列式容器，采用动态数组来管理序列中的元素，提供了对序列随机访问的功能，可以在序列的两端进行快速的插入和删除，并可以根据需要调整自身的大小，是典型的双端队列。</p> 
<p>（双向队列，一个中央控制器+多个缓冲区，支持首尾快速增删，支持随机访问。）</p> 
<p>2、deque优缺点<br> 优点：<br> 1)<span style="color:#f33b45;"><strong>支持随机访问，可以通过[ ]操作符和at()方法访问数据</strong></span>。<br> 2)<span style="color:#f33b45;"><strong>可以在两端方便的进行插入和删除操作</strong></span>。<br> 3)容器deque的迭代指针属于智能型指针。<br> 3)容器deque的迭代器属于随机存取迭代器。</p> 
<p>缺点：<br> 1)<span style="color:#f33b45;"><strong>占用内存多</strong></span>，<span style="color:#f33b45;">要通过迭代器来维护内存的整体连续，实际内部并不是连续的</span>。<br> 2)<span style="color:#f33b45;">在中间进行插入和删除时比较慢。</span></p> 
<p></p> 
<p><span style="color:#f33b45;">（</span>emplace_back和push_back的区别：</p> 
<p>相同点：两者都是向容器内添加数据</p> 
<p>不同点：当数据为类的对象时，emplace_back相对push_back可以避免额外的移动和复制操作。<a href="https://blog.csdn.net/p942005405/article/details/84764104" title="c++11 之emplace_back 与 push_back的区别_ppipp1109的博客-CSDN博客_emplace_back push_back">c++11 之emplace_back 与 push_back的区别_ppipp1109的博客-CSDN博客_emplace_back push_back</a>）</p> 
<pre><code class="language-cpp">#// TestDeque.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include &lt;iostream&gt;
#include &lt;deque&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;

using namespace std;

// 打印函数
void MyPrintf(int &amp;elem)
{
	cout &lt;&lt; elem &lt;&lt; ", ";
}

// 修改元素函数
void MyAdd(int &amp;elem)
{
	elem = elem + 10;
}

int main()
{
	cout &lt;&lt; "------------------------C++序列化容器deque的使用--------------------" &lt;&lt; endl;
	// 1、增加元素
	cout &lt;&lt; "-----------------------deque增加元素--------------------" &lt;&lt; endl;
	deque&lt;int&gt; myDeque;
	for (int i = 0; i &lt; 10; i++)
	{
		//myDeque.push_back(i);
		//myDeque.push_front(i);
		//myDeque.emplace_front(i); // C++11 头部增加元素
		myDeque.emplace_back(i); // C++11 尾部增加元素
	}
	for_each(myDeque.begin(), myDeque.end(), MyPrintf);
	cout &lt;&lt; endl;

	// 2、排序元素
	cout &lt;&lt; "-----------------------deque排序元素--------------------" &lt;&lt; endl;
	sort(myDeque.begin(), myDeque.end(), greater&lt;int&gt;());
	for_each(myDeque.begin(), myDeque.end(), MyPrintf);
	cout &lt;&lt; endl;

	// 3、修改元素
	cout &lt;&lt; "-----------------------deque修改元素--------------------" &lt;&lt; endl;
	for_each(myDeque.begin(), myDeque.end(), MyAdd);
	for_each(myDeque.begin(), myDeque.end(), MyPrintf);
	cout &lt;&lt; endl;
	cout &lt;&lt; "-----------------------打印myDeque2中的元素-----------------------" &lt;&lt; endl;
	deque&lt;int&gt; myDeque2;
	myDeque2.assign(myDeque.rbegin(),myDeque.rend());
	for_each(myDeque.begin(), myDeque.end(), MyPrintf);
	cout &lt;&lt; endl;

	// 4、查找元素
	cout &lt;&lt; "-----------------------deque查找元素--------------------" &lt;&lt; endl;
	deque&lt;int&gt;::iterator index;
	index = find(myDeque.begin(), myDeque.end(), 10); // 查找元素10
	// 注意：元素的索引从0开始的
	cout &lt;&lt; "元素10的索引index是： " &lt;&lt; (index - myDeque.begin()) &lt;&lt; endl;
	index = find_if(myDeque.begin(), myDeque.end(), bind2nd(less&lt;int&gt;(), 15));
	cout &lt;&lt; "第一个小于15的元素索引index是： " &lt;&lt; (index - myDeque.begin()) &lt;&lt; endl;

	// 5、删除元素
	cout &lt;&lt; "-----------------------deque删除元素--------------------" &lt;&lt; endl;
	while (!myDeque.empty())
	{
		int backNum = myDeque.back();
		cout &lt;&lt; backNum &lt;&lt; ", ";
		myDeque.pop_back();
	}
	cout &lt;&lt; endl;

	std::cout &lt;&lt; "Hello World!\n";
	getchar();
}
</code></pre> 
<p>运行结果：<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/c8/94/3YIkgBmV_o.png"><br> 原文链接：https://blog.csdn.net/toby54king/article/details/104979593</p> 
<h3 id="%E4%B8%89%E3%80%81%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8">三、关联容器</h3> 
<h4 id="map">map</h4> 
<p><strong>1、map概述</strong><br> map是采用红黑树实现的key-value一对一映射的关联容器，红黑树能够自动对数据进行排序，因此map内部所有的数据都是有序的；作为键值key的元素不允许重复，比较函数只对元素的键值进行比较，元素的各项数据可以通过键值进行查找、重新赋值等操作；可以使用键值key作为下标来获取对应的值；map默认的排序准则是从小到大。</p> 
<p><strong>2、map优缺点</strong><br> 优点:<br> 1)map的数据结构采用红黑树自身是有序的,插入数据时会自动排序。<br> 2)内部结构采用红黑树，<strong>红黑树的时间复杂度是在log(n)</strong>，时间复杂度低，效率高。<br> 3)<strong>索引方便，可以通过下标key方便的进行存取</strong>。</p> 
<p>缺点:<br> 1)map内部采用红黑数实现，<span style="color:#f33b45;"><strong>需要额外空间保存节点，会占用多余的空间</strong></span>，典型的以“空间换时间”。<br><span style="color:#f33b45;">2)通过key值索引时，如果key值不存在，map会直接插入一个key-value键值对。</span></p> 
<pre><code class="language-cpp">// Testmap.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;

using namespace std;

// 打印函数
void MyPrintf(pair&lt;int, double&gt; mpair)
{
	cout &lt;&lt; "( " &lt;&lt; mpair.first &lt;&lt; "," &lt;&lt; mpair.second &lt;&lt; ") " &lt;&lt; endl;
}

// 以value值进行排序
bool CompVector(pair&lt;int, double&gt; mpair1, pair&lt;int, double&gt; mpair2)
{
	return mpair1.second &gt; mpair2.second;
}

int main()
{
	cout &lt;&lt; "------------------------C++关联容器map的使用--------------------" &lt;&lt; endl;
	// 1、增加元素
	cout &lt;&lt; "-----------------------map增加元素--------------------" &lt;&lt; endl;
	map&lt;int, double&gt; myMap;
	for (int i = 0; i &lt; 10; i++)
	{
		double fNum = i + 0.5;
		myMap.insert(pair&lt;int, double&gt;(i,fNum));
	}
	for_each(myMap.begin(), myMap.end(), MyPrintf);
	cout &lt;&lt; endl;


	// 2、排序元素
	cout &lt;&lt; "------map排序元素，map没有提供直接排序的函数,需要借助vector排序-------" &lt;&lt; endl;
	vector&lt;pair&lt;int, double&gt; &gt;mapVector(myMap.begin(), myMap.end());
	sort(mapVector.begin(), mapVector.end(), CompVector);
	for_each(mapVector.begin(), mapVector.end(), MyPrintf);
	cout &lt;&lt; endl;

	// 3、修改元素
	cout &lt;&lt; "-----------------------map修改元素--------------------" &lt;&lt; endl;
	for (int i = 0; i &lt; 10; i++)
	{
		double fNum = i + 10.1;
		myMap[i]=fNum;
	}
	for_each(myMap.begin(), myMap.end(), MyPrintf);
	cout &lt;&lt; endl;

	// 4、查找元素
	cout &lt;&lt; "-----------------------map查找元素--------------------" &lt;&lt; endl;
	map&lt;int,double&gt;::iterator iterFind;
	iterFind = myMap.find(1); // key值为1的元素
	if (iterFind != myMap.end())
	{
		cout &lt;&lt; "找到了key值为1的元素: " &lt;&lt; iterFind-&gt;second &lt;&lt; endl;;
	}
	
	// 随机查找元素功能的函数lower_bound和upper_bound
	iterFind = myMap.lower_bound(3); // 从键值key的最小开始，注意下标从0开始，即正序
	cout &lt;&lt; "lower_bound(3): " &lt;&lt; "(" &lt;&lt; iterFind-&gt;first &lt;&lt; ", " &lt;&lt; iterFind-&gt;second &lt;&lt; ")" &lt;&lt; endl;
	iterFind = myMap.upper_bound(4);// 从键值key的最大开始，注意下标从最大开始，即倒序
	cout &lt;&lt; "upper_bound(4): " &lt;&lt; "(" &lt;&lt; iterFind-&gt;first &lt;&lt; ", " &lt;&lt; iterFind-&gt;second &lt;&lt; ")" &lt;&lt; endl;

	// 5、删除元素
	cout &lt;&lt; "-----------------------map删除元素--------------------" &lt;&lt; endl;
	// 删除第一个元素
	cout &lt;&lt; "-----------------------删除map第一个元素--------------------" &lt;&lt; endl;
	myMap.erase(myMap.begin());
	for_each(myMap.begin(), myMap.end(), MyPrintf);
	// 删除所有的元素
	cout &lt;&lt; "-----------------------删除map中所有的元素--------------------" &lt;&lt; endl;
	myMap.erase(myMap.begin(),myMap.end());
	if (myMap.empty())
	{
		cout &lt;&lt; "map中所有的元素都已经删除！" &lt;&lt; endl;
	}

	std::cout &lt;&lt; "Hello World!\n";
	getchar();
}
</code></pre> 
<p>运行结果：</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/7d/29/J4AjcfPl_o.png"><br> 原文链接：https://blog.csdn.net/toby54king/article/details/104979593</p> 
<p></p> 
<h4 id="%E5%9B%9B%E3%80%81set">四、set</h4> 
<p><br> 1、set概述<br> set属于关联型容器，能够按顺序存储一组值，该集合是一个有序的链表，元素以升序的顺序存储，集合中的每一个值都不允许重复，其内部实现与map一样，可以认为是一种key = value的特殊map。</p> 
<p>2、set优缺点<br> 优点：<br> 1)set会自动排序功能。<br> 2)内存采用红黑树，查询效率高。</p> 
<p>缺点：<br> 1)<strong>不能直接修改 set 容器中元素的值，修改set容器中的某个值，需要先删除该元素，再插入新元素</strong>。<br> 2)需要额外空间保存节点，会占用多余的空间。</p> 
<p>3、set代码示例</p> 
<pre><code class="language-cpp">// TestSet.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;

using namespace std;

// 打印函数
void MyPrintf(int elem)
{
    cout &lt;&lt; elem &lt;&lt; ", ";
}

int main()
{
    cout &lt;&lt; "------------------------C++关联容器set的使用--------------------" &lt;&lt; endl;
    // 1、增加元素
    cout &lt;&lt; "-----------------------set增加元素--------------------" &lt;&lt; endl;
    set&lt;int&gt; myset;
    for (int i = 0; i &lt; 10; i++)
    {
        myset.insert(i);
    }
    for_each(myset.begin(), myset.end(), MyPrintf);
    cout &lt;&lt; endl;


    // 2、排序元素
    cout &lt;&lt; "------set排序元素，set没有提供直接排序的函数,需要借助vector排序-------" &lt;&lt; endl;
    vector&lt;int&gt; setVector(myset.begin(), myset.end());
    sort(setVector.begin(), setVector.end(), greater&lt;int&gt;());
    for_each(setVector.begin(), setVector.end(), MyPrintf);
    cout &lt;&lt; endl;

    // 3、查找元素
    cout &lt;&lt; "-----------------------set查找元素--------------------" &lt;&lt; endl;
    set&lt;int&gt;::iterator iterFind;
    iterFind = myset.find(1); // key值为1的元素
    if (iterFind != myset.end())
    {
        cout &lt;&lt; "找到了key值为1的元素: " &lt;&lt; *iterFind &lt;&lt; endl;;
    }

    // 随机查找元素功能的函数lower_bound和upper_bound
    iterFind = myset.lower_bound(3); // 从键值key的最小开始，注意下标从0开始，即正序
    cout &lt;&lt; "lower_bound(3): " &lt;&lt; *iterFind &lt;&lt; endl;
    iterFind = myset.upper_bound(4);// 从键值key的最大开始，注意下标从最大开始，即倒序
    cout &lt;&lt; "upper_bound(4): " &lt;&lt; *iterFind &lt;&lt; endl;

    // 4、删除元素
    cout &lt;&lt; "-----------------------set删除元素--------------------" &lt;&lt; endl;
    // 删除第一个元素
    cout &lt;&lt; "-----------------------删除set第一个元素--------------------" &lt;&lt; endl;
    myset.erase(myset.begin());
    for_each(myset.begin(), myset.end(), MyPrintf);
    cout &lt;&lt; endl;
    // 删除所有的元素
    cout &lt;&lt; "-----------------------删除set中所有的元素--------------------" &lt;&lt; endl;
    myset.erase(myset.begin(), myset.end());
    if (myset.empty())
    {
        cout &lt;&lt; "set中所有的元素都已经删除！" &lt;&lt; endl;
    }

    std::cout &lt;&lt; "Hello World!\n";
    getchar();
}
</code></pre> 
<p>运行结果：<br><img alt="" src="https://images2.imgbox.com/e3/97/1STn3qvb_o.png"><br> 原文链接：https://blog.csdn.net/toby54king/article/details/104979593</p> 
<h3 id="%E9%80%82%E9%85%8D%E5%99%A8">适配器</h3> 
<h4 id="stack">stack</h4> 
<p><br> 底层为deque/list，封闭头部，不使用vector作为底层的原因是vector扩容耗时。</p> 
<p></p> 
<h4 id="queue%20%26%20priority_queue">queue &amp; priority_queue</h4> 
<p><br> queue：底层为deque/list，封闭头部，不使用vector作为底层的原因是vector扩容耗时。<br> priority_queue：优先队列，以vector为底层，以heap为处理规则管理底层实现。</p> 
<p></p> 
<h2 id="3%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%BA%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91">3、红黑树为底层的容器及红黑树</h2> 
<h3 id="%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%BA%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%B9%E5%99%A8"><br> 红黑树为底层的容器</h3> 
<table><tbody><tr><td></td><td>有序</td><td>元素可重复</td></tr><tr><td>set</td><td>是</td><td>否</td></tr><tr><td>multiset</td><td>是</td><td>是</td></tr><tr><td>map</td><td>是</td><td>否</td></tr><tr><td>multimap</td><td>是</td><td>是</td></tr></tbody></table> 
<p>插入删除，查找时间复杂度为O(log(n))<br> 作为关联容器，set不同于map的地方在于，set的key就是value。</p> 
<p></p> 
<h4 id="%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</h4> 
<p><br> 红黑树的特点：根节点是黑色，叶节点是黑色的null节点，任意节点到其叶节点经过的黑色节点数量是相同的。<br> 去除掉黑色null节点，红黑树是一层黑一层红。<br> 红黑树是近平衡的二叉搜索树，和平衡二叉搜索树相比，红黑树的平衡没有那么平衡，插入后可以保证调整三次之间可以使树达到平衡条件。</p> 
<p></p> 
<h2 id="hash%E8%A1%A8%E4%B8%BA%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8F%8Ahash%E8%A1%A8">hash表为底层的容器及hash表</h2> 
<h4><a name="t12"></a><a id="hash_128"></a></h4> 
<h3 id="hash%E8%A1%A8%E4%B8%BA%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%B9%E5%99%A8">hash表为底层的容器</h3> 
<table><thead><tr><th></th><th>有序</th><th>元素可重复</th></tr></thead><tbody><tr><td>hash_set</td><td>否</td><td>否</td></tr><tr><td>hash_multiset</td><td>否</td><td>是</td></tr><tr><td>hash_map</td><td>否</td><td>否</td></tr><tr><td>hash_multimap</td><td>否</td><td>是</td></tr></tbody></table> 
<p>查询时间复杂度O(1)</p> 
<h4 id="hash%E8%A1%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3"><a name="t13"></a><a id="hash_137"></a>hash表冲突解决</h4> 
<p>1、扩大每个桶的容量<br> 2、闭地址：桶后增加溢出链<br> 3、开地址；寻找下一个有空间的桶</p> 
<p>原文链接：https://blog.csdn.net/Chuwei_xu/article/details/89321692 </p> 
<p></p> 
<h2 id="%E5%85%AD%E3%80%81%E5%90%84%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">六、各个容器的使用场景</h2> 
<p><br> 1、容器使用场景<br> vector：当需要高效的随机存取数据时，而不在乎插入和删除的效率，可以使用vector。<br> list：当需要大量的插入和删除数据时，而不关心随机存取，可以使用list。<br> map：当需要以键值对的方式存储数据时，可以使用map。<br> set:当需要存储不重复的数据时，可以使用set。<br> deque:当需要随机存取数据时，<strong>还关心两端数据的插入和删除</strong>，可以使用deque。</p> 
<p>2、C++官方网址<br> C++的容器使用类模板实现，各个容器提供的方法也非常多，限于篇幅不可能一一列举出来，文中只是列举了部分使用方法，具体每个容器的使用方法可以根据官方提供的网址查看，官方网址：http://www.cplusplus.com/reference/vector/vector/?kw=vector<br><br> 原文链接：https://blog.csdn.net/toby54king/article/details/104979593</p> 
<p></p> 
<h2>三十分钟掌握STL </h2> 
<p></p> 
<p> （不错的介绍：<a href="https://blog.csdn.net/yas12345678/article/details/52601454" title="https://blog.csdn.net/yas12345678/article/details/52601454）">https://blog.csdn.net/yas12345678/article/details/52601454）</a></p> 
<p>STL封装了许多复杂的数据结构算法和大量常用数据结构操作。vector封装数组，list封装了链表，map和set封装了二叉树等,</p> 
<h4></h4> 
<h2 id="set%20%EF%BC%88%E5%B9%B3%E8%A1%A1%E6%A3%80%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%89"><strong>set （</strong>平衡检索二叉树：红黑树）</h2> 
<p></p> 
<p>set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序，</p> 
<p>C++ STL中标准关联容器set, multiset, map, multimap内部采用的就是一种非常高效的平衡检索二叉树：红黑树</p> 
<h3 id="%C2%A0%E5%85%B3%E4%BA%8Eset%E6%9C%89%E4%B8%8B%E9%9D%A2%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%9A"> <strong>关于set有下面几个问题：</strong></h3> 
<h4 id="%EF%BC%881%EF%BC%89%E4%B8%BA%E4%BD%95map%E5%92%8Cset%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E6%95%88%E7%8E%87%E6%AF%94%E7%94%A8%E5%85%B6%E4%BB%96%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8%E9%AB%98%EF%BC%9F"><strong>（1）为何map和set的插入删除效率比用其他序列容器高？</strong></h4> 
<p>大部分人说，很简单，因为对于关联容器来说，不需要做内存拷贝和内存移动。说对了，确实如此。set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。结构图可能如下：</p> 
<p></p> 
<p>　　A<br> 　  / \<br> 　 B C<br> 　/ \ / \<br>   D E F G</p> 
<p>因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点也OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。</p> 
<p></p> 
<h4 id="%EF%BC%882%EF%BC%89%E4%B8%BA%E4%BD%95%E6%AF%8F%E6%AC%A1insert%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%BB%A5%E5%89%8D%E4%BF%9D%E5%AD%98%E7%9A%84iterator%E4%B8%8D%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><strong>（2）为何每次insert之后，以前保存的<strong><a href="https://www.baidu.com/s?wd=iter&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" rel="nofollow" title="iter">iter</a></strong>ator不会失效？</strong></h4> 
<p>iterator这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)。</p> 
<p>相对于vector来说，每一次删除和插入，指针都有可能失效，调用push_back在尾部插入也是如此。<strong>因为为了保证内部数据的连续存放</strong>，iterator指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使时push_back的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。<strong>特别时在和find等算法在一起使用的时候，牢记这个原则：不要使用过期的iterator。</strong></p> 
<h4 id="%EF%BC%883%EF%BC%89%E5%BD%93%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E5%A2%9E%E5%A4%9A%E6%97%B6%EF%BC%8Cset%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E6%90%9C%E7%B4%A2%E9%80%9F%E5%BA%A6%E5%8F%98%E5%8C%96%E5%A6%82%E4%BD%95%EF%BC%9F"><strong>（3）当数据元素增多时，set的插入和搜索速度变化如何？</strong></h4> 
<p>set中查找是使用二分查找，时间复杂度是logN，1000个，最多需要查找10次（2^10 &gt;=1000)</p> 
<p></p> 
<p>和 set/multiset 类似，map/multimap key不能改，但是 data 可以改,因此map仍然具有自动排序的功能。</p> 
<p>map 的 key 必须独一无二,而 multimap 的 key 可以重复。</p> 
<p></p> 
<p>原文：<a href="http://net.pku.edu.cn/~yhf/UsingSTL.htm" rel="nofollow" title="http://net.pku.edu.cn/~yhf/UsingSTL.htm">http://net.pku.edu.cn/~yhf/UsingSTL.htm</a></p> 
<p></p> 
<h2 id="STL%E6%A6%82%E8%BF%B0"><br> STL概述</h2> 
<p>STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但这种分离确实使得STL变得非常通用。例如，由于STL的sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组。<br> 要点</p> 
<p>STL算法作为模板函数提供。为了和其他组件相区别，在本书中STL算法以后接一对圆括弧的方式表示，例如sort()。</p> 
<p>STL另一个重要特性是它不是面向对象的。为了具有足够通用性，STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。你在STL中找不到任何明显的类继承关系。这好像是一种倒退，但这正好是使得STL的组件具有广泛通用性的底层特征。另外，由于STL是基于模板，内联函数的使用使得生成的代码短小高效。</p> 
<p>提示</p> 
<p>确保在编译使用了STL的程序中至少要使用-O优化来保证内联扩展。STL提供了大量的模板类和函数，可以在OOP和常规编程中使用。<strong>所有的STL的大约50个算法都是完全通用的，而且不依赖于任何特定的数据类型</strong>（算法和数据类型分开）。</p> 
<p></p> 
<p><strong>三个基本的STL组件：</strong></p> 
<p>1）提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象。</p> 
<p>2）<strong>容器</strong>是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。</p> 
<p>3）<strong>算法</strong>是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象。函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用。<br> 头文件</p> 
<p>为了避免和其他头文件冲突， STL的头文件不再使用常规的.h扩展。为了包含标准的string类，迭代器和算法，用下面的指示符：</p> 
<pre class="has"><code class="language-cpp">#include &lt;string&gt;

#include &lt;iterator&gt;

#include &lt;algorithm&gt;</code></pre> 
<p>如果你查看STL的头文件，你可以看到象iterator.h和stl_iterator.h这样的头文件。由于这些名字在各种STL实现之间都可能不同，你应该避免使用这些名字来引用这些头文件。为了确保可移植性，使用相应的没有.h后缀的文件名。表1列出了最常使用的各种容器类的头文件。该表并不完整，对于其他头文件，我将在本章和后面的两章中介绍。</p> 
<p>表 1. STL头文件和容器类</p> 
<table><thead><tr><td> <p><strong>#include</strong></p> </td><td> <p><strong>Container Class</strong></p> </td></tr></thead><tbody><tr><td> <p>&lt;deque&gt;</p> </td><td> <p>deque</p> </td></tr><tr><td> <p>&lt;list&gt;</p> </td><td> <p>list</p> </td></tr><tr><td> <p>&lt;map&gt;</p> </td><td> <p>map, multimap</p> </td></tr><tr><td> <p>&lt;queue&gt;</p> </td><td> <p>queue, priority_queue</p> </td></tr><tr><td> <p>&lt;set&gt;</p> </td><td> <p>set, multiset</p> </td></tr><tr><td> <p>&lt;stack&gt;</p> </td><td> <p>stack</p> </td></tr><tr><td> <p>&lt;vector&gt;</p> </td><td> <p>vector, vector&lt;bool&gt;</p> </td></tr></tbody></table> 
<h2></h2> 
<h2 id="%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</h2> 
<p><u>迭代器提供对一个容器中的对象的访问方法</u>，并且定义了容器中对象的范围。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器不仅仅是指针，因此你不能认为他们一定具有地址值。例如，一个数组索引，也可以认为是一种迭代器。</p> 
<p>迭代器有各种不同的创建方法。程序可能把迭代器作为一个变量创建。一个STL容器类可能为了使用一个特定类型的数据而创建一个迭代器。作为指针，必须能够使用*操作符类获取数据。你还可以使用其他数学操作符如++。典型的，++操作符用来递增迭代器，以访问容器中的下一个对象。如果迭代器到达了容器中的最后一个元素的后面，则迭代器变成past-the-end值。使用一个past-the-end值得指针来访问对象是非法的，就好像使用NULL或为初始化的指针一样。</p> 
<p>提示</p> 
<p>STL不保证可以从另一个迭代器来抵达一个迭代器。例如，当对一个集合中的对象排序时，如果你在不同的结构中指定了两个迭代器，第二个迭代器无法从第一个迭代器抵达，此时程序注定要失败。这是STL灵活性的一个代价。STL不保证检测毫无道理的错误。</p> 
<h2 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><strong>迭代器的类型</strong></h2> 
<p>对于STL数据结构和算法，你可以使用五种迭代器。下面简要说明了这五种类型：</p> 
<p>·        Input iterators 提供对数据的只读访问。</p> 
<p>·        Output iterators 提供对数据的只写访问</p> 
<p>·        Forward iterators 提供读写操作，并能向前推进迭代器。</p> 
<p>·        Bidirectional iterators提供读写操作，并能向前和向后操作。</p> 
<p>·        Random access iterators提供读写操作，并能在数据中随机移动。</p> 
<p>尽管各种不同的STL实现细节方面有所不同，还是可以将上面的迭代器想象为一种类继承关系。从这个意义上说，下面的迭代器继承自上面的迭代器。由于这种继承关系，你可以将一个Forward迭代器作为一个output或input迭代器使用。同样，如果一个算法要求是一个bidirectional 迭代器，那么只能使用该种类型和随机访问迭代器。</p> 
<h2 id="%E6%8C%87%E9%92%88%E8%BF%AD%E4%BB%A3%E5%99%A8">指针迭代器</h2> 
<p>正如下面的小程序显示的，一个指针也是一种迭代器。该程序同样显示了STL的一个主要特性——它不只是能够用于它自己的类类型，而且也能用于任何C或C++类型。Listing 1, iterdemo.cpp, 显示了如何把指针作为迭代器用于STL的find()算法来搜索普通的数组。</p> 
<pre><code class="language-cpp">表 1. iterdemo.cpp
#include &lt;iostream.h&gt;
#include &lt;algorithm&gt;
using namespace std;
#define SIZE 100
int iarray[SIZE];
int main()
{
  iarray[20] = 50;
  int* ip = find(iarray, iarray + SIZE, 50);
  if (ip == iarray + SIZE)
    cout &lt;&lt; "50 not found in array" &lt;&lt; endl;
  else
    cout &lt;&lt; *ip &lt;&lt; " found in array" &lt;&lt; endl;
  return 0;
}</code></pre> 
<p></p> 
<p>程序中定义了尺寸为SIZE的全局数组。由于是全局变量，所以运行时数组自动初始化为零。下面的语句将在索引20位置处地元素设置为50,并使用find()算法来搜索值50:</p> 
<pre><code class="language-cpp">iarray[20] = 50;
int* ip = find(iarray, iarray + SIZE, 50);</code></pre> 
<p>find()函数接受三个参数。头两个定义了搜索的范围。表达式iarray指向数组的第一个元素。而第二个参数iarray + SIZE等同于past-the-end 值，也就是数组中最后一个元素的后面位置。第三个参数是待定位的值，也就是50。find()函数返回和前两个参数相同类型的迭代器，这儿是一个指向整数的指针ip。</p> 
<p>提示</p> 
<p>必须记住STL使用模板。因此，STL函数自动根据它们使用的数据类型来构造。</p> 
<p>为了判断find()是否成功，例子中测试ip和 past-the-end 值是否相等：</p> 
<p>if (ip == iarray + SIZE) ...</p> 
<p>如果表达式为真，则表示在搜索的范围内没有指定的值。否则就是指向一个合法对象的指针，这时可以用下面的语句显示：:</p> 
<p>cout &lt;&lt; *ip &lt;&lt; " found in array" &lt;&lt; endl;</p> 
<p>测试函数返回值和NULL是否相等是不正确的。不要象下面这样使用：</p> 
<p>int* ip = find(iarray, iarray + SIZE, 50);</p> 
<p>if (ip != NULL) ...  // ??? incorrect</p> 
<p>当使用STL函数时，只能测试ip是否和past-the-end 值是否相等。尽管在本例中ip是一个C++指针,其用法也必须符合STL迭代器的规则。</p> 
<h2 id="%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><br> 容器迭代器</h2> 
<p>尽管C++指针也是迭代器，但用的更多的是容器迭代器。容器迭代器用法和iterdemo.cpp一样，但和将迭代器申明为指针变量不同的是，你可以使用容器类方法来获取迭代器对象。<strong>两个典型的容器类方法是begin()和end()</strong>。它们在大多数容器中表示整个容器范围。<strong>其他一些容器还使用rbegin()和rend()方法提供反向迭代器</strong>，以按反向顺序指定对象范围。</p> 
<p>下面的程序创建了一个矢量容器（STL的和数组等价的对象），并使用迭代器在其中搜索。该程序和前一章中的程序相同。</p> 
<p>Listing 2. vectdemo.cpp</p> 
<p>#include &lt;iostream.h&gt;</p> 
<p>#include &lt;algorithm&gt;</p> 
<p>#include &lt;vector&gt;</p> 
<p></p> 
<p>using namespace std;</p> 
<p></p> 
<p>vector&lt;int&gt; intVector(100);</p> 
<p></p> 
<p>void main()</p> 
<p>{<!-- --></p> 
<p>  intVector[20] = 50;</p> 
<p>  vector&lt;int&gt;::iterator intIter =</p> 
<p>    find(intVector.begin(), intVector.end(), 50);</p> 
<p>  if (intIter != intVector.end())</p> 
<p>    cout &lt;&lt; "Vector contains value " &lt;&lt; *intIter &lt;&lt; endl;</p> 
<p>  else</p> 
<p>    cout &lt;&lt; "Vector does not contain 50" &lt;&lt; endl;</p> 
<p>}</p> 
<p></p> 
<p>注意用下面的方法显示搜索到的数据：</p> 
<p>cout &lt;&lt; "Vector contains value " &lt;&lt; *intIter &lt;&lt; endl;</p> 
<p></p> 
<h2 id="%E5%B8%B8%E9%87%8F%E8%BF%AD%E4%BB%A3%E5%99%A8">常量迭代器</h2> 
<p></p> 
<p>和指针一样，你可以给一个迭代器赋值。例如，首先申明一个迭代器：</p> 
<p>vector&lt;int&gt;::iterator first;</p> 
<p>该语句创建了一个vector&lt;int&gt;类的迭代器。下面的语句将该迭代器设置到intVector的第一个对象，并将它指向的对象值设置为123：:</p> 
<p>first = intVector.begin();</p> 
<p>*first = 123;</p> 
<p>这种赋值对于大多数容器类都是允许的，除了只读变量。为了防止错误赋值，可以申明迭代器为：</p> 
<p>const vector&lt;int&gt;::iterator result;</p> 
<p>result = find(intVector.begin(), intVector.end(), value);</p> 
<p>if (result != intVector.end())</p> 
<p>  *result = 123;  // ???</p> 
<p>警告</p> 
<p>另一种防止数据被改变得方法是将容器申明为const类型。</p> 
<p>『呀！在VC中测试出错,正确的含义是result成为常量而不是它指向的对象不允许改变，如同int *const p;看来这作者自己也不懂』</p> 
<h2 id="%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%BC%96%E7%A8%8B">使用迭代器编程</h2> 
<p>你已经见到了迭代器的一些例子，现在我们将关注每种特定的迭代器如何使用。由于使用迭代器需要关于STL容器类和算法的知识，在阅读了后面的两章后你可能需要重新复习一下本章内容。</p> 
<h4></h4> 
<p>输入迭代器</p> 
<p>输入迭代器是最普通的类型。输入迭代器至少能够使用==和!=测试是否相等；使用*来访问数据；使用++操作来递推迭代器到下一个元素或到达past-the-end 值。</p> 
<p>为了理解迭代器和STL函数是如何使用它们的，现在来看一下find()模板函数的定义：</p> 
<p>template &lt;class InputIterator, class T&gt;</p> 
<p>InputIterator find(</p> 
<p>  InputIterator first, InputIterator last, const T&amp; value) {<!-- --></p> 
<p>    while (first != last &amp;&amp; *first != value) ++first;</p> 
<p>    return first;</p> 
<p>  }</p> 
<p>注意</p> 
<p>在find()算法中，注意如果first和last指向不同的容器，该算法可能陷入死循环。</p> 
<h4 id="%E8%BE%93%E5%87%BA%E8%BF%AD%E4%BB%A3%E5%99%A8">输出迭代器</h4> 
<p>输出迭代器缺省只写，通常用于将数据从一个位置拷贝到另一个位置。由于输出迭代器无法读取对象，因此你不会在任何搜索和其他算法中使用它。要想读取一个拷贝的值，必须使用另一个输入迭代器（或它的继承迭代器）。</p> 
<p>Listing 3. outiter.cpp</p> 
<p>#include &lt;iostream.h&gt;</p> 
<p>#include &lt;algorithm&gt;   // Need copy()</p> 
<p>#include &lt;vector&gt;      // Need vector</p> 
<p></p> 
<p>using namespace std;</p> 
<p></p> 
<p>double darray[10] =</p> 
<p>  {1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9};</p> 
<p></p> 
<p>vector&lt;double&gt; vdouble(10);</p> 
<p></p> 
<p>int main()</p> 
<p>{<!-- --></p> 
<p>  vector&lt;double&gt;::iterator outputIterator = vdouble.begin();</p> 
<p>  copy(darray, darray + 10, outputIterator);</p> 
<p>  while (outputIterator != vdouble.end()) {<!-- --></p> 
<p>    cout &lt;&lt; *outputIterator &lt;&lt; endl;</p> 
<p>    outputIterator++;</p> 
<p>  }</p> 
<p>  return 0;</p> 
<p>}</p> 
<p>注意</p> 
<p>当使用copy()算法的时候，你必须确保目标容器有足够大的空间，或者容器本身是自动扩展的。</p> 
<h4 id="%E5%89%8D%E6%8E%A8%E8%BF%AD%E4%BB%A3%E5%99%A8">前推迭代器</h4> 
<p>前推迭代器能够读写数据值，并能够向前推进到下一个值。但是没法递减。replace()算法显示了前推迭代器的使用方法。</p> 
<p>template &lt;class ForwardIterator, class T&gt;</p> 
<p>void replace (ForwardIterator first,</p> 
<p>              ForwardIterator last,</p> 
<p>              const T&amp; old_value,</p> 
<p>              const T&amp; new_value);</p> 
<p>使用replace()将[first,last]范围内的所有值为old_value的对象替换为new_value。:</p> 
<p>replace(vdouble.begin(), vdouble.end(), 1.5, 3.14159);</p> 
<h4 id="%E5%8F%8C%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8">双向迭代器</h4> 
<p>双向迭代器要求能够增减。如reverse()算法要求两个双向迭代器作为参数:</p> 
<p>template &lt;class BidirectionalIterator&gt;</p> 
<p>void reverse (BidirectionalIterator first,</p> 
<p>              BidirectionalIterator last);</p> 
<p>使用reverse()函数来对容器进行逆向排序:</p> 
<p>reverse(vdouble.begin(), vdouble.end());</p> 
<h4 id="%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%BF%AD%E4%BB%A3%E5%99%A8">随机访问迭代器</h4> 
<p>随机访问迭代器能够以任意顺序访问数据，并能用于读写数据（不是const的C++指针也是随机访问迭代器）。<br> STL的排序和搜索函数使用随机访问迭代器。随机访问迭代器可以使用关系操作符作比较。</p> 
<p>random_shuffle() 函数随机打乱原先的顺序。申明为：</p> 
<p>template &lt;class RandomAccessIterator&gt;</p> 
<p>void random_shuffle (RandomAccessIterator first,</p> 
<p>                     RandomAccessIterator last);</p> 
<p>使用方法：</p> 
<p>random_shuffle(vdouble.begin(), vdouble.end());</p> 
<h2 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8A%80%E6%9C%AF">迭代器技术</h2> 
<p>要学会使用迭代器和容器以及算法，需要学习下面的新技术。</p> 
<h4 id="%E6%B5%81%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8">流和迭代器</h4> 
<p>本书的很多例子程序使用I/O流语句来读写数据。例如：</p> 
<p>int value;</p> 
<p>cout &lt;&lt; "Enter value: ";</p> 
<p>cin &gt;&gt; value;</p> 
<p>cout &lt;&lt; "You entered " &lt;&lt; value &lt;&lt; endl;</p> 
<p>对于迭代器，有另一种方法使用流和标准函数。理解的要点是将输入/输出流作为容器看待。因此，任何接受迭代器参数的算法都可以和流一起工作。</p> 
<p>Listing 4. outstrm.cpp</p> 
<p>#include &lt;iostream.h&gt;</p> 
<p>#include &lt;stdlib.h&gt;    // Need random(), srandom()</p> 
<p>#include &lt;time.h&gt;      // Need time()</p> 
<p>#include &lt;algorithm&gt;   // Need sort(), copy()</p> 
<p>#include &lt;vector&gt;      // Need vector</p> 
<p></p> 
<p>using namespace std;</p> 
<p></p> 
<p>void Display(vector&lt;int&gt;&amp; v, const char* s);</p> 
<p></p> 
<p>int main()<br> {<!-- --></p> 
<p>  // Seed the random number generator</p> 
<p>  srandom( time(NULL) );</p> 
<p></p> 
<p>  // Construct vector and fill with random integer values</p> 
<p>  vector&lt;int&gt; collection(10);</p> 
<p>  for (int i = 0; i &lt; 10; i++)</p> 
<p>    collection[i] = random() % 10000;;</p> 
<p></p> 
<p>  // Display, sort, and redisplay</p> 
<p>  Display(collection, "Before sorting");</p> 
<p>  sort(collection.begin(), collection.end());</p> 
<p>  Display(collection, "After sorting");</p> 
<p>  return 0;</p> 
<p>}</p> 
<p></p> 
<p>// Display label s and contents of integer vector v</p> 
<p>void Display(vector&lt;int&gt;&amp; v, const char* s)</p> 
<p>{<!-- --></p> 
<p>  cout &lt;&lt; endl &lt;&lt; s &lt;&lt; endl;</p> 
<p>  copy(v.begin(), v.end(),</p> 
<p>    ostream_iterator&lt;int&gt;(cout, "\t"));</p> 
<p>  cout &lt;&lt; endl;</p> 
<p>}</p> 
<p>函数Display()显示了如何使用一个输出流迭代器。下面的语句将容器中的值传输到cout输出流对象中:</p> 
<p>copy(v.begin(), v.end(),</p> 
<p>  ostream_iterator&lt;int&gt;(cout, "\t"));</p> 
<p>第三个参数实例化了ostream_iterator&lt;int&gt;类型，并将它作为copy()函数的输出目标迭代器对象。“\t”字符串是作为分隔符。运行结果：</p> 
<p>$ g++ outstrm.cpp</p> 
<p>$ ./a.out</p> 
<p>Before sorting</p> 
<p>677   722   686   238   964   397   251   118   11    312</p> 
<p>After sorting</p> 
<p>11    118   238   251   312   397   677   686   722   964</p> 
<p>这是STL神奇的一面『确实神奇』。为定义输出流迭代器，STL提供了模板类ostream_iterator。这个类的构造函数有两个参数：一个ostream对象和一个string值。<br> 因此可以象下面一样简单地创建一个迭代器对象：</p> 
<p>ostream_iterator&lt;int&gt;(cout, "\n")</p> 
<p>该迭代起可以和任何接受一个输出迭代器的函数一起使用。</p> 
<h4 id="%E6%8F%92%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8">插入迭代器</h4> 
<p>插入迭代器用于将值插入到容器中。它们也叫做适配器，因为它们将容器适配或转化为一个迭代器，并用于copy()这样的算法中。例如，一个程序定义了一个链表和一个矢量容器:</p> 
<p>list&lt;double&gt; dList;</p> 
<p>vector&lt;double&gt; dVector;</p> 
<p>通过使用front_inserter迭代器对象，可以只用单个copy()语句就完成将矢量中的对象 插入到链表前端的操作：</p> 
<p>copy(dVector.begin(), dVector.end(), front_inserter(dList));</p> 
<p>三种插入迭代器如下：</p> 
<p>·        普通插入器 将对象插入到容器任何对象的前面。</p> 
<p>·        Front inserters 将对象插入到数据集的前面——例如，链表表头。</p> 
<p>·        Back inserters 将对象插入到集合的尾部——例如，矢量的尾部，导致矢量容器扩展。</p> 
<p>使用插入迭代器可能导致容器中的其他对象移动位置，因而使得现存的迭代器非法。例如，将一个对象插入到矢量容器将导致其他值移动位置以腾出空间。一般来说，插入到象链表这样的结构中更为有效，因为它们不会导致其他对象移动。</p> 
<p>Listing 5. insert.cpp</p> 
<p>#include &lt;iostream.h&gt;</p> 
<p>#include &lt;algorithm&gt;</p> 
<p>#include &lt;list&gt;</p> 
<p></p> 
<p>using namespace std;</p> 
<p></p> 
<p>int iArray[5] = { 1, 2, 3, 4, 5 };</p> 
<p></p> 
<p>void Display(list&lt;int&gt;&amp; v, const char* s);</p> 
<p></p> 
<p>int main()</p> 
<p>{<!-- --></p> 
<p>  list&lt;int&gt; iList;</p> 
<p></p> 
<p>  // Copy iArray backwards into iList</p> 
<p>  copy(iArray, iArray + 5, front_inserter(iList));</p> 
<p>  Display(iList, "Before find and copy");</p> 
<p></p> 
<p>  // Locate value 3 in iList</p> 
<p>  list&lt;int&gt;::iterator p =</p> 
<p>    find(iList.begin(), iList.end(), 3);</p> 
<p></p> 
<p>  // Copy first two iArray values to iList ahead of p<br>   copy(iArray, iArray + 2, inserter(iList, p));</p> 
<p>  Display(iList, "After find and copy");</p> 
<p>  return 0;</p> 
<p>}</p> 
<p></p> 
<p>void Display(list&lt;int&gt;&amp; a, const char* s)</p> 
<p>{<!-- --></p> 
<p>  cout &lt;&lt; s &lt;&lt; endl;</p> 
<p>  copy(a.begin(), a.end(),</p> 
<p>    ostream_iterator&lt;int&gt;(cout, " "));</p> 
<p>  cout &lt;&lt; endl;</p> 
<p>}</p> 
<p>运行结果如下：</p> 
<p>$ g++ insert.cpp</p> 
<p>$ ./a.out</p> 
<p>Before find and copy</p> 
<p>5 4 3 2 1</p> 
<p>After find and copy</p> 
<p>5 4 1 2 3 2 1</p> 
<p>可以将front_inserter替换为back_inserter试试。</p> 
<p>如果用find()去查找在列表中不存在的值，例如99。由于这时将p设置为past-the-end 值。最后的copy()函数将iArray的值附加到链表的后部。</p> 
<h4 id="%E6%B7%B7%E5%90%88%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%87%BD%E6%95%B0"><br> 混合迭代器函数</h4> 
<p>在涉及到容器和算法的操作中，还有两个迭代器函数非常有用：</p> 
<p>·        advance() 按指定的数目增减迭代器。</p> 
<p>·        distance() 返回到达一个迭代器所需（递增）操作的数目。</p> 
<p>例如：</p> 
<p>list&lt;int&gt; iList;</p> 
<p>list&lt;int&gt;::iterator p =</p> 
<p>  find(iList.begin(), iList.end(), 2);</p> 
<p>cout &lt;&lt; "before: p == " &lt;&lt; *p &lt;&lt; endl;</p> 
<p>advance(p, 2);  // same as p = p + 2;</p> 
<p>cout &lt;&lt; "after : p == " &lt;&lt; *p &lt;&lt; endl;</p> 
<p></p> 
<p>int k = 0;</p> 
<p>distance(p, iList.end(), k);</p> 
<p>cout &lt;&lt; "k == " &lt;&lt; k &lt;&lt; endl;</p> 
<p></p> 
<p>advance()函数接受两个参数。第二个参数是向前推进的数目。对于前推迭代器，该值必须为正，而对于双向迭代器和随机访问迭代器，该值可以为负。</p> 
<p>使用 distance()函数来返回到达另一个迭代器所需要的步骤。</p> 
<p>注意</p> 
<p>distance()函数是迭代的，也就是说，它递增第三个参数。因此，你必须初始化该参数。未初始化该参数几乎注定要失败。</p> 
<h2 id="%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">函数和函数对象</h2> 
<p><strong>STL中，函数被称为算法，</strong>也就是说它们和标准C库函数相比，它们更为通用。STL算法通过重载operator()函数实现为模板类或模板函数。这些类用于创建函数对象，对容器中的数据进行各种各样的操作。下面的几节解释如何使用函数和函数对象。<br> 函数和断言</p> 
<p>经常需要对容器中的数据进行用户自定义的操作。例如，你可能希望遍历一个容器中所有对象的STL算法能够回调自己的函数。例如</p> 
<pre class="has"><code class="language-cpp">#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;     // Need random(), srandom()
#include &lt;time.h&gt;       // Need time()
#include &lt;vector&gt;       // Need vector
#include &lt;algorithm&gt;    // Need for_each()


#define VSIZE 24        // Size of vector
vector&lt;long&gt; v(VSIZE);  // Vector object


// Function prototypes

void initialize(long &amp; ri);
void show(const long &amp; ri);
bool isMinus(const long &amp; ri); // Predicate function


int main()

{

    srandom( time(NULL) );  // Seed random generator

    for_each(v.begin(), v.end(), initialize);//调用普通函数  for_each() C++ 11

    cout &lt;&lt; "Vector of signed long integers" &lt;&lt; endl;

    for_each(v.begin(), v.end(), show);

    cout &lt;&lt; endl;

    // Use predicate function to count negative values

    int count = 0;

    vector&lt;long&gt;::iterator p;

    p = find_if(v.begin(), v.end(), isMinus);//调用断言函数

    while (p != v.end())
    {

        count++;

        p = find_if(p + 1, v.end(), isMinus);

    }

    cout &lt;&lt; "Number of values: " &lt;&lt; VSIZE &lt;&lt; endl;
    cout &lt;&lt; "Negative values : " &lt;&lt; count &lt;&lt; endl;

    return 0;
}


// Set ri to a signed integer value
void initialize(long &amp; ri)
{

    ri = ( random() - (RAND_MAX / 2) );
    //  ri = random();
}


// Display value of ri
void show(const long &amp; ri)
{
    cout &lt;&lt; ri &lt;&lt; "  ";
}


// Returns true if ri is less than 0
bool isMinus(const long &amp; ri)
{
    return (ri &lt; 0);
}

</code></pre> 
<p>所谓断言函数，就是返回bool值的函数。</p> 
<h2 id="%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><strong>函数对象</strong></h2> 
<p>除了给STL算法传递一个<u>回调函数</u>，你还可能需要传递一个<u>类<strong>对象</strong></u>以便执行更复杂的操作。这样的一个对象就叫做<u>函数对象</u>。实际上<strong>函数对象就是一个类</strong>，<u>但它和回调函数一样可以被回调</u>。例如，在函数对象每次被for_each()或find_if()函数调用时可以保留统计信息。函数对象是通过重载operator()()实现的。如果TanyClass定义了opeator()(),那么就可以这么使用：<br>  </p> 
<pre class="has"><code class="language-cpp">TAnyClass object;  // Construct object

object();          // Calls TAnyClass::operator()() function

for_each(v.begin(), v.end(), object);</code></pre> 
<p>STL定义了几个函数对象。由于它们是模板，所以能够用于任何类型，包括C/C++固有的数据类型，如long。有些函数对象从名字中就可以看出它的用途，如plus()和multiplies()。类似的greater()和less-equal()用于比较两个值。</p> 
<p>注意</p> 
<p>有些版本的ANSI C++定义了times()函数对象，而GNU C++把它命名为multiplies()。使用时必须包含头文件&lt;functional&gt;。</p> 
<p>一个有用的函数对象的应用是accumulate() 算法。该函数计算容器中所有值的总和。记住这样的值不一定是简单的类型，通过重载operator+()，也可以是类对象。</p> 
<pre class="has"><code class="language-cpp">Listing 8. accum.cpp  

#include &lt;iostream.h&gt;
#include &lt;numeric&gt;      // Need accumulate()
#include &lt;vector&gt;       // Need vector
#include &lt;functional&gt;   // Need multiplies() (or times())


#define MAX 10
vector&lt;long&gt; v(MAX);    // Vector object


int main()

{

  // Fill vector using conventional loop

  for (int i = 0; i &lt; MAX; i++)

    v[i] = i + 1;


  // Accumulate the sum of contained values

  long sum = accumulate(v.begin(), v.end(), 0);

  cout &lt;&lt; "Sum of values == " &lt;&lt; sum &lt;&lt; endl;


  // Accumulate the product of contained values

  long product =

    accumulate(v.begin(), v.end(), 1, multiplies&lt;long&gt;());//注意这行

  cout &lt;&lt; "Product of values == " &lt;&lt; product &lt;&lt; endl;

  return 0;

}</code></pre> 
<p>编译输出如下：</p> 
<p>$ g++ accum.cpp</p> 
<p>$ ./a.out</p> 
<p>Sum of values == 55</p> 
<p>Product of values == 3628800</p> 
<p>『注意使用了函数对象的accumulate()的用法。accumulate() 在内部将每个容器中的对象和第三个参数作为multiplies函数对象的参数,multiplies(1,v)计算乘积。VC中的这些模板的源代码如下：</p> 
<pre class="has"><code class="language-cpp">        // TEMPLATE FUNCTION accumulate

template&lt;class _II, class _Ty&gt; inline

    _Ty accumulate(_II _F, _II _L, _Ty _V)

    {for (; _F != _L; ++_F)

        _V = _V + *_F;

    return (_V); }

        // TEMPLATE FUNCTION accumulate WITH BINOP

template&lt;class _II, class _Ty, class _Bop&gt; inline

    _Ty accumulate(_II _F, _II _L, _Ty _V, _Bop _B)

    {for (; _F != _L; ++_F)

        _V = _B(_V, *_F);

    return (_V); }

        // TEMPLATE STRUCT binary_function

template&lt;class _A1, class _A2, class _R&gt;

    struct binary_function {

    typedef _A1 first_argument_type;

    typedef _A2 second_argument_type;

    typedef _R result_type;

    };

        // TEMPLATE STRUCT multiplies

template&lt;class _Ty&gt;

    struct multiplies : binary_function&lt;_Ty, _Ty, _Ty&gt; {

    _Ty operator()(const _Ty&amp; _X, const _Ty&amp; _Y) const

        {return (_X * _Y); }

    };</code></pre> 
<p>引言：如果你想深入了解STL到底是怎么实现的，最好的办法是写个简单的程序，将程序中涉及到的模板源码给copy下来，稍作整理，就能看懂了。所以没有必要去买什么《STL源码剖析》之类的书籍，那些书可能反而浪费时间。』</p> 
<p></p> 
<p>///-----------------------------------------------------------2018-11-14-----练习至此</p> 
<p></p> 
<h2 id="%E5%8F%91%E7%94%9F%E5%99%A8%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><strong>发生器 函数对象</strong></h2> 
<p><strong>（</strong><strong>函数对象就是一个类</strong>，<u>但它和回调函数一样可以被回调</u>。<strong>）</strong></p> 
<p>有一类有用的<strong>函数对象</strong>是“发生器”(generator)。这类函数有自己的内存，也就是说它能够从先前的调用中记住一个值。例如随机数发生器函数。</p> 
<p>普通的C程序员使用静态或全局变量 “记忆”上次调用的结果。但这样做的缺点是该函数无法和它的数据相分离『还有个缺点是要用TLS才能线程安全』。显然，使用类来封装一块：“内存”更安全可靠。</p> 
<p>（线程局部存储（Thread Local Storage，TLS）用来将数据与一个正在执行的指定线程关联起来<a href="https://www.cnblogs.com/stli/archive/2010/11/03/1867852.html" rel="nofollow" title="https://www.cnblogs.com/stli/archive/2010/11/03/1867852.html）">https://www.cnblogs.com/stli/archive/2010/11/03/1867852.html）</a></p> 
<p>先看一下例子：</p> 
<pre class="has"><code class="language-cpp">Listing 9. randfunc.cpp

#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;    // Need random(), srandom()
#include &lt;time.h&gt;      // Need time()
#include &lt;algorithm&gt;   // Need random_shuffle()
#include &lt;vector&gt;      // Need vector
#include &lt;functional&gt;  // Need ptr_fun()


using namespace std;

// Data to randomize
int iarray[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

vector&lt;int&gt; v(iarray, iarray + 10);


// Function prototypes
void Display(vector&lt;int&gt;&amp; vr, const char *s);

unsigned int RandInt(const unsigned int n);


int main()
{

  srandom( time(NULL) );  // Seed random generator

  Display(v, "Before shuffle:");

  pointer_to_unary_function&lt;unsigned int, unsigned int&gt; ptr_RandInt 
  = ptr_fun(RandInt);  // Pointer to RandInt()//注意这行

  random_shuffle(v.begin(), v.end(), ptr_RandInt);

  Display(v, "After shuffle:");

  return 0;

}


// Display contents of vector vr
void Display(vector&lt;int&gt;&amp; vr, const char *s)
{

  cout &lt;&lt; endl &lt;&lt; s &lt;&lt; endl;

  copy(vr.begin(), vr.end(), ostream_iterator&lt;int&gt;(cout, " "));

  cout &lt;&lt; endl;

}



// Return next random value in sequence modulo n
unsigned int RandInt(const unsigned int n)
{

  return random() % n;

}</code></pre> 
<p>编译运行结果如下：</p> 
<p>$ g++ randfunc.cpp</p> 
<p>$ ./a.out</p> 
<p>Before shuffle:</p> 
<p>1 2 3 4 5 6 7 8 9 10</p> 
<p>After shuffle:</p> 
<p>6 7 2 8 3 5 10 1 9 4</p> 
<p>首先用下面的语句申明一个对象：</p> 
<p>pointer_to_unary_function&lt;unsigned int, unsigned int&gt;</p> 
<p>  ptr_RandInt = ptr_fun(RandInt);</p> 
<p>这儿使用STL的单目函数模板定义了一个变量ptr_RandInt，并将地址初始化到我们的函数RandInt()。单目函数接受一个参数，并返回一个值。现在random_shuffle()可以如下调用：</p> 
<p>random_shuffle(v.begin(), v.end(), ptr_RandInt);</p> 
<p>在本例子中，发生器只是简单的调用rand()函数。</p> 
<p></p> 
<p>关于常量引用的一点小麻烦（不翻译了，VC下将例子中的const去掉）</p> 
<h2 id="%E5%8F%91%E7%94%9F%E5%99%A8%E5%87%BD%E6%95%B0%E7%B1%BB%E5%AF%B9%E8%B1%A1">发生器函数类对象</h2> 
<p>下面的例子说明发生器函数类对象的使用。</p> 
<pre class="has"><code class="language-cpp">Listing 10. fiborand.cpp

#include &lt;iostream.h&gt;
#include &lt;algorithm&gt;   // Need random_shuffle()
#include &lt;vector&gt;      // Need vector
#include &lt;functional&gt;  // Need unary_function

using namespace std;



// Data to randomize
int iarray[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

vector&lt;int&gt; v(iarray, iarray + 10);

// Function prototype
void Display(vector&lt;int&gt;&amp; vr, const char *s);


// The FiboRand template function-object class
template &lt;class Arg&gt;

class FiboRand : public unary_function&lt;Arg, Arg&gt; {

  int i, j;

  Arg sequence[18];

public:

  FiboRand();

  Arg operator()(const Arg&amp; arg);

};



void main()

{

  FiboRand&lt;int&gt; fibogen;  // Construct generator object

  cout &lt;&lt; "Fibonacci random number generator" &lt;&lt; endl;

  cout &lt;&lt; "using random_shuffle and a function object" &lt;&lt; endl;

  Display(v, "Before shuffle:");

  random_shuffle(v.begin(), v.end(), fibogen);

  Display(v, "After shuffle:");

}



// Display contents of vector vr
void Display(vector&lt;int&gt;&amp; vr, const char *s)

{

  cout &lt;&lt; endl &lt;&lt; s &lt;&lt; endl;

  copy(vr.begin(), vr.end(),

    ostream_iterator&lt;int&gt;(cout, " "));

  cout &lt;&lt; endl;

}



// FiboRand class constructor
template&lt;class Arg&gt;

FiboRand&lt;Arg&gt;::FiboRand()

{

  sequence[17] = 1;

  sequence[16] = 2;

  for (int n = 15; n &gt; 0; n—)

    sequence[n] = sequence[n + 1] + sequence[n + 2];

  i = 17;

  j = 5;

}



// FiboRand class function operator
template&lt;class Arg&gt;

Arg FiboRand&lt;Arg&gt;::operator()(const Arg&amp; arg)

{

  Arg k = sequence[i] + sequence[j];

  sequence[i] = k;

  i--;

  j--;

  if (i == 0) i = 17;

  if (j == 0) j = 17;

  return k % arg;

}

编译运行输出如下:

$ g++ fiborand.cpp

$ ./a.out

Fibonacci random number generator

using random_shuffle and a function object

Before shuffle:

1 2 3 4 5 6 7 8 9 10

After shuffle:

6 8 5 4 3 7 10 1 9</code></pre> 
<p>该程序用完全不同的方法使用使用rand_shuffle。Fibonacci 发生器封装在一个类中，该类能从先前的“使用”中记忆运行结果。在本例中，类FiboRand 维护了一个数组和两个索引变量I和j。</p> 
<p>FiboRand类继承自unary_function() 模板:</p> 
<p>template &lt;class Arg&gt;</p> 
<p>class FiboRand : public unary_function&lt;Arg, Arg&gt; {...</p> 
<p>Arg是用户自定义数据类型。该类还定以了两个成员函数，一个是构造函数，另一个是operator()（）函数，该操作符允许random_shuffle()算法象一个函数一样“调用”一个FiboRand对象。</p> 
<h2 id="%E7%BB%91%E5%AE%9A%E5%99%A8%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">绑定器 函数对象</h2> 
<p><strong>函数对象就是一个类</strong>，<u>但它和回调函数一样可以被回调</u>。</p> 
<p>一个绑定器使用另一个函数对象f()和参数值V创建一个函数对象。被绑定函数对象必须为双目函数，也就是说有两个参数,A和B。STL 中的帮定器有：</p> 
<p>·        bind1st() 创建一个函数对象，该函数对象将值V作为第一个参数A。</p> 
<p>·        bind2nd()创建一个函数对象，该函数对象将值V作为第二个参数B。</p> 
<p>举例如下：</p> 
<pre class="has"><code class="language-cpp">Listing 11. binder.cpp

#include &lt;iostream.h&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;list&gt;



using namespace std;



// Data
int iarray[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

list&lt;int&gt; aList(iarray, iarray + 10);



int main()

{

  int k = 0;

  count_if(aList.begin(), aList.end(),

    bind1st(greater&lt;int&gt;(), 8), k);

  cout &lt;&lt; "Number elements &lt; 8 == " &lt;&lt; k &lt;&lt; endl;

  return 0;

}</code></pre> 
<p>Algorithm count_if()计算满足特定条件的元素的数目。 这是通过将一个函数对象和一个参数捆绑到为一个对象，并将该对象作为算法的第三个参数实现的。 注意这个表达式:</p> 
<p>bind1st(greater&lt;int&gt;(), 8)</p> 
<p>该表达式将greater&lt;int&gt;()和一个参数值8捆绑为一个函数对象。由于使用了bind1st()，所以该函数相当于计算下述表达式：</p> 
<p>8 &gt; q</p> 
<p>表达式中的q是容器中的对象。因此，完整的表达式</p> 
<p>count_if(aList.begin(), aList.end(),</p> 
<p>  bind1st(greater&lt;int&gt;(), 8), k);</p> 
<p>计算所有小于或等于8的对象的数目。</p> 
<h2 id="%E5%90%A6%E5%AE%9A%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><br><strong>否定函数对象</strong></h2> 
<p>所谓否定(negator)函数对象（函数对象就是一个类），就是它从另一个函数对象创建而来，如果原先的函数返回真，则否定函数对象返回假。有两个否定函数对象：not1()和not2()。not1()接受单目函数对象，not2()接受双目函数对象。否定函数对象通常和帮定器一起使用。例如，上节中用bind1nd来搜索q&lt;=8的值：</p> 
<p>  count_if(aList.begin(), aList.end(),</p> 
<p>    bind1st(greater&lt;int&gt;(), 8), k);</p> 
<p>如果要搜索q&gt;8的对象，则用bind2st。而现在可以这样写：</p> 
<p>start = find_if(aList.begin(), aList.end(),</p> 
<p>  not1(bind1nd(greater&lt;int&gt;(), 6)));</p> 
<p>你必须使用not1，因为bind1nd返回单目函数。</p> 
<h2 id="%E6%80%BB%E7%BB%93%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%20(STL)"><br> 总结：使用标准模板库 (STL)</h2> 
<p>尽管很多程序员仍然在使用标准C函数，但是这就好像骑着毛驴寻找Mercedes一样。你当然最终也会到达目标，但是你浪费了很多时间。</p> 
<p>尽管有时候使用标准C函数确实方便(如使用sprintf()进行格式化输出)。但是C函数不使用异常机制来报告错误，也不适合处理新的数据类型。而且标准C函数经常使用内存分配技术，没有经验的程序员很容易写出bug来。.</p> 
<p>C++标准库则提供了更为安全，更为灵活的数据集处理方式。STL最初由HP实验室的Alexander Stepanov和Meng Lee开发。最近，C++标准委员会采纳了STL，尽管在不同的实现之间仍有细节差别。</p> 
<p>STL的最主要的两个特点：数据结构和算法的分离，非面向对象本质。访问对象是通过象指针一样的迭代器实现的；容器是象链表，矢量之类的数据结构，并按模板方式提供；算法是函数模板，用于操作容器中的数据。由于STL以模板为基础，所以能用于任何数据类型和结构。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/10f552c57be092fd3e8272cf06750b9c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">酒店管理系统/基于ssm的酒店管理系统/基于javaweb的酒店管理系统的设计与实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/81892424e9ebfd823ad55993e0e469a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">为你的阿里云服务器配置一个域名并成功访问（入门版</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>