<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>23 种设计模式详解 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="23 种设计模式详解" />
<meta property="og:description" content="目录
1、设计模式汇总一览表
2、创建型设计模式详细介绍
（1）单例模式(Singleton)
（2）抽象工厂模式(AbstractFactory)
（3）原型模式(Prototype)：深克隆、浅克隆
（4）建造者模式(Builder)
（5）FactoryMethod工厂方法模式
3、结构型模式详细介绍
（1）外观模式(Facade)
（2）桥接模式(Bridge)
（3）组合模式(Composite)
（4）享元模式(Fly weight Pattern)
（5）代理模式(Proxy)
（6）适配器模式(Adapter)
（7）装饰模式(Decorator)
4、行为型模式详细介绍
（1）观察者模式(Observer)
（2）迭代器模式(Iterator)
（3）模板方法模式(Template Method)
（4）策略模式(Strategy)
（5）责任链模式(Chain of Responsibility)
（6）命令模式(Command)
（7）解释器模式(Interpreter)
（8）访问者模式(Visitor)
（9）中介者模式(Mediator)
（10）备忘录模式(Memento)
（11）状态模式(State)
设计模式（DesignPattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。
使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。
1、设计模式汇总一览表 创建型 模式 用于创建对象 单例模式抽象工厂模式原型模式 建造者模式
工厂方法模式 共5种 ——背诵口诀 ： 单抽元件（建）厂 结构型 模式 处理类或对象的组合 外观模式桥接模式组合模式享元模式代理模式适配器模式装饰器模式 共7种 —— 背诵口诀 ： 外侨（桥）组员（元）戴（代）配饰。 行为型 模式 描述类与对象怎样交互、怎样分配职责 观察者模式模板方法模式迭代器模式策略模式责任链模式命令模式解释器模式 访问者模式
中介者模式备忘录模式状态模式 共11种 —— 背诵口诀 ： 观摩（模）对（迭）策， 责令解放（访）， 戒（介）忘台（态）。 设计模式为什么要分为创建型、结构型、行为型？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/9a129156ca374ec5d14d68d68883e06b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-21T13:33:52+08:00" />
<meta property="article:modified_time" content="2023-04-21T13:33:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">23 种设计模式详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B1%87%E6%80%BB%E4%B8%80%E8%A7%88%E8%A1%A8-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B1%87%E6%80%BB%E4%B8%80%E8%A7%88%E8%A1%A8" rel="nofollow">1、设计模式汇总一览表</a></p> 
<p id="2%E3%80%81%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D" rel="nofollow">2、创建型设计模式详细介绍</a></p> 
<p id="%EF%BC%881%EF%BC%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton%EF%BC%89-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton%EF%BC%89" rel="nofollow">（1）单例模式(Singleton)</a></p> 
<p id="%EF%BC%882%EF%BC%89AbstractFactory%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89AbstractFactory%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F" rel="nofollow">（2）抽象工厂模式(AbstractFactory)</a></p> 
<p id="%EF%BC%883%EF%BC%89Prototype%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%B7%B1%E5%85%8B%E9%9A%86%E3%80%81%E6%B5%85%E5%85%8B%E9%9A%86-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89Prototype%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%B7%B1%E5%85%8B%E9%9A%86%E3%80%81%E6%B5%85%E5%85%8B%E9%9A%86" rel="nofollow">（3）原型模式(Prototype)：深克隆、浅克隆</a></p> 
<p id="%EF%BC%884%EF%BC%89%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F(Builder)-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%28Builder%29" rel="nofollow">（4）建造者模式(Builder)</a></p> 
<p id="%EF%BC%885%EF%BC%89FactoryMethod%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%EF%BC%885%EF%BC%89FactoryMethod%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F" rel="nofollow">（5）FactoryMethod工厂方法模式</a></p> 
<p id="3%E3%80%81%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D" rel="nofollow">3、结构型模式详细介绍</a></p> 
<p id="1%E3%80%81Facade%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#1%E3%80%81Facade%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F" rel="nofollow">（1）外观模式(Facade)</a></p> 
<p id="2%E3%80%81Bridge%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#2%E3%80%81Bridge%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F" rel="nofollow">（2）桥接模式(Bridge)</a></p> 
<p id="%EF%BC%883%EF%BC%89Composite%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89Composite%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F" rel="nofollow">（3）组合模式(Composite)</a></p> 
<p id="%EF%BC%884%EF%BC%89%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F(Fly%20weight%20Pattern)-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%28Fly%20weight%20Pattern%29" rel="nofollow">（4）享元模式(Fly weight Pattern)</a></p> 
<p id="5%E3%80%81Proxy%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#5%E3%80%81Proxy%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F" rel="nofollow">（5）代理模式(Proxy)</a></p> 
<p id="%EF%BC%886%EF%BC%89Adapter%EF%BC%88%E7%B1%BB%EF%BC%89%E9%80%82%E9%85%8D%E5%99%A8-toc" style="margin-left:80px;"><a href="#%EF%BC%886%EF%BC%89Adapter%EF%BC%88%E7%B1%BB%EF%BC%89%E9%80%82%E9%85%8D%E5%99%A8" rel="nofollow">（6）适配器模式(Adapter)</a></p> 
<p id="7%E3%80%81Decorator%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#7%E3%80%81Decorator%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F" rel="nofollow">（7）装饰模式(Decorator)</a></p> 
<p id="4%E3%80%81%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D" rel="nofollow">4、行为型模式详细介绍</a></p> 
<p id="1%E3%80%81Observer%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#1%E3%80%81Observer%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F" rel="nofollow">（1）观察者模式(Observer)</a></p> 
<p id="%EF%BC%882%EF%BC%89Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F" rel="nofollow">（2）迭代器模式(Iterator)</a></p> 
<p id="3%E3%80%81Template%C2%A0Method%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#3%E3%80%81Template%C2%A0Method%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95" rel="nofollow">（3）模板方法模式(Template Method)</a></p> 
<p id="%EF%BC%884%EF%BC%89%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F(Strategy)-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%28Strategy%29" rel="nofollow">（4）策略模式(Strategy)</a></p> 
<p id="%EF%BC%885%EF%BC%89Chain%20of%C2%A0Responsibility%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%EF%BC%885%EF%BC%89Chain%20of%C2%A0Responsibility%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F" rel="nofollow">（5）责任链模式(Chain of Responsibility)</a></p> 
<p id="6%E3%80%81Command%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#6%E3%80%81Command%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F" rel="nofollow">（6）命令模式(Command)</a></p> 
<p id="%EF%BC%887%EF%BC%89Interpreter%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%EF%BC%887%EF%BC%89Interpreter%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F" rel="nofollow">（7）解释器模式(Interpreter)</a></p> 
<p id="8%E3%80%81Visitor%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#8%E3%80%81Visitor%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F" rel="nofollow">（8）访问者模式(Visitor)</a></p> 
<p id="9%E3%80%81Mediator%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#9%E3%80%81Mediator%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F" rel="nofollow">（9）中介者模式(Mediator)</a></p> 
<p id="10%E3%80%81Memento%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#10%E3%80%81Memento%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F" rel="nofollow">（10）备忘录模式(Memento)</a></p> 
<p id="%EF%BC%8811%EF%BC%89State%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%EF%BC%8811%EF%BC%89State%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F" rel="nofollow">（11）状态模式(State)</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p><span style="color:#000000;">        设计模式（DesignPattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。</span></p> 
<p><strong><span style="color:#000000;">        使用设计模式的目的：</span></strong><span style="color:#000000;">为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</span></p> 
<h3 id="1%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B1%87%E6%80%BB%E4%B8%80%E8%A7%88%E8%A1%A8">1、设计模式汇总一览表</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:654px;"><tbody><tr><td style="width:107px;"> 
    <div> 
     <span style="color:#000000;">创建型</span> 
     <span style="color:#000000;">模式</span> 
    </div> </td><td style="width:151px;"> 
    <div> 
     <span style="color:#000000;">用于创建对象</span> 
    </div> </td><td style="width:395px;"> 
    <ul><li><span style="color:#f33b45;">单</span>例模式</li><li><span style="color:#f33b45;">抽</span>象工厂模式</li><li><span style="color:#f33b45;">原</span>型模式</li><li> <p><span style="color:#f33b45;">建</span>造者模式</p> </li><li>工<span style="color:#f33b45;">厂</span>方法模式</li></ul> 
    <div> 
     <span style="color:#86ca5e;">共5种 ——背诵口诀</span> 
     <span style="color:#0070c0;">：</span> 
    </div> 
    <div> 
     <span style="color:#0070c0;">单抽元件（建）厂</span> 
    </div> </td></tr><tr><td style="width:107px;"> 
    <div> 
     <span style="color:#000000;">结构型</span> 
     <span style="color:#000000;">模式</span> 
    </div> </td><td style="width:151px;"> 
    <div> 
     <span style="color:#000000;">处理类或对象的组合</span> 
    </div> </td><td style="width:395px;"> 
    <ul><li><span style="color:#f33b45;">外</span>观模式</li><li><span style="color:#f33b45;">桥</span>接模式</li><li><span style="color:#f33b45;">组</span>合模式</li><li>享<span style="color:#f33b45;">元</span>模式</li><li><span style="color:#f33b45;">代</span>理模式</li><li>适<span style="color:#f33b45;">配</span>器模式</li><li>装<span style="color:#f33b45;">饰</span>器模式</li></ul> 
    <div> 
     <span style="color:#86ca5e;">共7种 —— 背诵口诀</span> 
     <span style="color:#0070c0;">：</span> 
    </div> 
    <div> 
     <span style="color:#0070c0;">外侨（桥）组员（元）戴（代）配饰。</span> 
    </div> </td></tr><tr><td style="width:107px;"> 
    <div> 
     <span style="color:#000000;">行为型</span> 
     <span style="color:#000000;">模式</span> 
    </div> </td><td style="width:151px;"> 
    <div> 
     <span style="color:#000000;">描述类与对象怎样交互、怎样分配职责</span> 
    </div> </td><td style="width:395px;"> 
    <ul><li><span style="color:#f33b45;">观</span>察者模式</li><li><span style="color:#f33b45;">模</span>板方法模式</li><li><span style="color:#f33b45;">迭</span>代器模式</li><li><span style="color:#f33b45;">策</span>略模式</li><li><span style="color:#f33b45;">责</span>任链模式</li><li><span style="color:#f33b45;">命</span>令模式</li><li><span style="color:#f33b45;">解</span>释器模式</li><li> <p><span style="color:#f33b45;">访</span>问者模式</p> </li><li>中<span style="color:#f33b45;">介</span>者模式</li><li>备<span style="color:#f33b45;">忘</span>录模式</li><li>状<span style="color:#f33b45;">态</span>模式</li></ul> 
    <div> 
     <span style="color:#86ca5e;">共11种 —— 背诵口诀</span> 
     <span style="color:#0070c0;">：</span> 
    </div> 
    <div> 
     <span style="color:#0070c0;">观摩（模）对（迭）策，</span> 
    </div> 
    <div> 
     <span style="color:#0070c0;">责令解放（访），</span> 
    </div> 
    <div> 
     <span style="color:#0070c0;">戒（介）忘台（态）。</span> 
    </div> </td></tr></tbody></table> 
<p id="%E4%BA%94%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E4%B8%BA%E5%88%9B%E5%BB%BA%E5%9E%8B%E3%80%81%E7%BB%93%E6%9E%84%E5%9E%8B%E3%80%81%E8%A1%8C%E4%B8%BA%E5%9E%8B%EF%BC%9F"><strong>设计模式为什么要分为创建型、结构型、行为型？</strong></p> 
<p>        设计模式按照功能和用途可以分为创建型、结构型和行为型三种类型，这种分类方式主要是为了方便设计模式的理解和应用。</p> 
<ol><li> <p>创建型模式：<span style="color:#fe2c24;">创建型模式主要关注对象的创建过程，包括如何创建对象、如何组合和表示对象等</span>。创建型模式包括单例模式、工厂模式、抽象工厂模式、建造者模式和原型模式等。通过创建型模式，可以更加灵活地创建和组合对象，同时也可以隐藏对象的创建细节，提高代码的复用性和可维护性。</p> </li><li> <p>结构型模式：<span style="color:#fe2c24;">结构型模式主要关注对象的组成和关系，包括如何将类和对象组合成更大的结构，以及如何简化对象之间的交互</span>。结构型模式包括适配器模式、装饰器模式、代理模式、组合模式、桥接模式、外观模式和享元模式等。通过结构型模式，可以更好地组织代码，使得代码更加清晰和易于理解，同时也可以提高代码的重用性和可维护性。</p> </li><li> <p>行为型模式：<span style="color:#fe2c24;">行为型模式主要关注对象之间的交互和通信，包括如何定义对象的职责和行为，以及如何协调不同对象之间的工作</span>。行为型模式包括模板方法模式、策略模式、命令模式、责任链模式、状态模式、观察者模式、中介者模式和访问者模式等。通过行为型模式，可以更好地解耦对象之间的依赖关系，使得代码更加灵活和可扩展，同时也可以提高代码的可读性和可维护性。</p> </li></ol> 
<p>        总之，设计模式按照功能和用途的不同进行分类，有助于我们更好地理解和应用它们，同时也有助于我们选择合适的设计模式来解决具体的问题。</p> 
<h3 id="2%E3%80%81%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D">2、创建型设计模式详细介绍</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:654px;"><tbody><tr><td style="width:60px;"><strong>目的</strong></td><td style="width:100px;"><strong>设计模式</strong></td><td style="width:331px;"><strong>简要说明</strong></td><td style="width:162px;"><strong>可改版的方面</strong></td></tr><tr><td colspan="1" rowspan="5" style="width:60px;"> <p>创</p> <p>建</p> <p>型</p> </td><td style="width:100px;"> 
    <div> 
     <span style="color:#000000;">Singleton</span> 
    </div> 
    <div> 
     <div> 
      <span style="color:#000000;">单例</span> 
     </div> 
    </div> </td><td style="width:331px;"> 
    <div> 
     <span style="color:#f33b45;">保证一个类仅有一个实例</span> 
     <span style="color:#000000;">，并提供一个访问它的全局访问点。</span> 
    </div> </td><td style="width:162px;"> 
    <div> 
     <span style="color:#000000;">类的单个实例</span> 
    </div> </td></tr><tr><td style="width:100px;"> 
    <div> 
     <div> 
      <span style="color:#000000;">Abstract Factory</span> 
     </div> 
     <div> 
      <span style="color:#000000;">抽象工厂</span> 
     </div> 
    </div> </td><td style="width:331px;"> 
    <div> 
     <span style="color:#000000;">提供一个创建一系列相关或相互依赖对象的</span> 
     <span style="color:#f33b45;">接口</span> 
     <span style="color:#000000;">，而</span> 
     <span style="color:#f33b45;">无需指定它们具体的类</span> 
     <span style="color:#000000;">。</span> 
    </div> </td><td style="width:162px;"> 
    <div> 
     <span style="color:#000000;">产品对象族</span> 
    </div> </td></tr><tr><td style="width:100px;"> 
    <div> 
     <div> 
      <span style="color:#000000;">Prototype</span> 
     </div> 
     <div> 
      <span style="color:#000000;">原型</span> 
     </div> 
    </div> </td><td style="width:331px;"> 
    <div> 
     <span style="color:#000000;">用原型实例</span> 
     <span style="color:#f33b45;">指定创建对象的种类</span> 
     <span style="color:#000000;">，并且通过拷贝这个原型来创建新的象。</span> 
    </div> </td><td style="width:162px;"> 
    <div> 
     <span style="color:#000000;">实例化类的对象</span> 
    </div> </td></tr><tr><td style="width:100px;"> 
    <div> 
     <div> 
      <span style="color:#000000;">Builder</span> 
     </div> 
     <div> 
      <span style="color:#000000;">建造者</span> 
     </div> 
    </div> </td><td style="width:331px;"> 
    <div> 
     <span style="color:#000000;">将一个复杂的对象的</span> 
     <span style="color:#f33b45;">构建与它的表示分离</span> 
     <span style="color:#000000;">，使得</span> 
     <span style="color:#f33b45;">同样的构建</span> 
     <span style="color:#000000;">过程可以创建</span> 
     <span style="color:#f33b45;">不同的表示</span> 
     <span style="color:#000000;">。</span> 
    </div> </td><td style="width:162px;"> 
    <div> 
     <span style="color:#000000;">如何建立一个组合对象</span> 
    </div> </td></tr><tr><td style="width:100px;"> 
    <div> 
     <div> 
      <span style="color:#000000;">Abstract Method</span> 
     </div> 
     <div> 
      <span style="color:#000000;">工厂方法</span> 
     </div> 
    </div> </td><td style="width:331px;"> 
    <div> 
     <span style="color:#000000;">定义一个用于创建对象的</span> 
     <span style="color:#f33b45;">接口</span> 
     <span style="color:#000000;">，让</span> 
     <span style="color:#f33b45;">子类决定将哪一个类实例化</span> 
     <span style="color:#000000;">。使一个类的实例化延迟到其子类。</span> 
    </div> </td><td style="width:162px;"> 
    <div> 
     <span style="color:#000000;">实例化子类对象</span> 
    </div> </td></tr></tbody></table> 
<h4 id="%EF%BC%881%EF%BC%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton%EF%BC%89">（1）单例模式(Singleton)</h4> 
<p id="1%E3%80%81Singleton%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">        单例模式（Singleton）确保一个类只有一个实例，并提供一个全局访问点来访问该实例。单例模式通常用于控制资源的访问，例如数据库连接或线程池。</p> 
<p>        单例模式的核心是一个静态变量，用于存储类的唯一实例。这个变量必须是私有的，并且必须在类内部实例化。类的构造函数必须是私有的，以确保只能在类内部创建实例。最后，类必须提供一个公共的静态方法，用于访问实例。下面是类图示例：</p> 
<p class="img-center"><img alt="" height="299" src="https://images2.imgbox.com/40/fc/bgEZgJbq_o.png" width="600"></p> 
<h4 id="%EF%BC%882%EF%BC%89AbstractFactory%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">（2）抽象工厂模式(AbstractFactory)</h4> 
<p id="%EF%BC%883%EF%BC%89AbstractFactory%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">        抽象工厂模式提供了一种创建一组相关或相互依赖对象的方法，而无需指定它们的具体类。抽象工厂模式通过将对象的创建委托给工厂对象来实现这一点，这些工厂对象负责实例化具体类的对象。</p> 
<p>        抽象工厂模式的核心是抽象工厂接口和具体工厂类。抽象工厂接口定义了一组用于创建一组相关对象的抽象方法。具体工厂类实现抽象工厂接口，并实现这些方法来创建具体的对象。客户端代码只需要使用抽象工厂接口来创建对象，而无需关心具体的实现。下面是类图示例：</p> 
<p class="img-center"><img alt="" height="449" src="https://images2.imgbox.com/7f/5e/YtyEchb8_o.png" width="650"></p> 
<h4 id="%EF%BC%883%EF%BC%89Prototype%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%B7%B1%E5%85%8B%E9%9A%86%E3%80%81%E6%B5%85%E5%85%8B%E9%9A%86">（3）原型模式(Prototype)：深克隆、浅克隆</h4> 
<p id="3%E3%80%81Prototype%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%B7%B1%E5%85%8B%E9%9A%86%E3%80%81%E6%B5%85%E5%85%8B%E9%9A%86">        原型模式提供了一种通过克隆现有对象来创建新对象的方法。原型模式基于一个已经存在的对象，通过对其进行复制来创建新的对象，而不是通过实例化一个类来创建对象。</p> 
<p>        在原型模式中，我们首先定义一个原型接口或者抽象类，该接口或抽象类定义了用于克隆自身的方法。然后，我们实现一个或多个具体的原型类，这些类实现了原型接口或抽象类，并重写了克隆方法以实现对象的复制。</p> 
<h4 id="%EF%BC%884%EF%BC%89%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F(Builder)">（4）建造者模式(Builder)</h4> 
<p id="%EF%BC%884%EF%BC%89%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Builder%EF%BC%89">        建造者模式通过将对象构建过程分解为一系列步骤来创建复杂对象。该模式允许我们使用相同的构建过程来创建不同类型的对象。</p> 
<p>        在建造者模式中，我们定义一个抽象建造者类，该类定义了用于构建复杂对象的一组抽象方法。然后，我们实现一个或多个具体的建造者类，这些类实现了抽象建造者类中定义的方法，并提供了一种用于构建特定类型对象的构建过程。最后，我们定义一个指导者类，该类使用抽象建造者类中的方法来控制构建过程，并将最终的对象返回给客户端。下面是类图示例：</p> 
<p class="img-center"><img alt="" height="287" src="https://images2.imgbox.com/f2/f9/ImlThrR4_o.png" width="600"></p> 
<div> 
 <h4 id="%EF%BC%885%EF%BC%89FactoryMethod%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">（5）FactoryMethod工厂方法模式</h4> 
 <p>        工厂方法模式提供了一种将对象的创建委托给子类的方式。在工厂方法模式中，我们定义一个创建对象的接口，但让子类决定实例化哪个类。工厂方法将对象的实例化延迟到子类中，从而使得客户端代码在不必指定具体类的情况下，创建了一个特定类的实例。</p> 
 <p>        在工厂方法模式中，通常会定义一个抽象的工厂类，其中包含了一个抽象的工厂方法，该方法返回一个产品的抽象接口。具体的产品类将会实现该抽象接口，并在工厂方法中返回相应的实例。下面是类图示例：</p> 
 <p class="img-center"><img alt="" height="405" src="https://images2.imgbox.com/0e/ab/gUXZwAPQ_o.png" width="600"></p> 
 <h3 id="3%E3%80%81%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D">3、结构型模式详细介绍</h3> 
</div> 
<table border="1" cellpadding="1" cellspacing="1" style="width:654px;"><tbody><tr><td style="width:60px;"><strong>目的</strong></td><td style="width:100px;"><strong>设计模式</strong></td><td style="width:331px;"><strong>简要说明</strong></td><td style="width:162px;"><strong>可改版的方面</strong></td></tr><tr><td colspan="1" rowspan="7"> <p>结 </p> <p>构</p> <p>型</p> </td><td> 
    <div> 
     <div> 
      <span style="color:#000000;">Facade</span> 
     </div> 
     <div> 
      <span style="color:#000000;">外观模式</span> 
     </div> 
    </div> </td><td> 
    <div> 
     <span style="color:#f33b45;">为子系统中的一组接口提供一个一致的界面</span> 
     <span style="color:#000000;">，外观模式通过提供一个高层接口，隔离了外部系统与子系统间复杂的交互过程，使得复杂系统的子系统更易使用。</span> 
    </div> 
    <div> 
     <div></div> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">与子系统的接口</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <span style="color:#000000;">Bridge</span> 
    </div> 
    <div> 
     <span style="color:#000000;">桥接</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#f33b45;">将抽象部分与它的实现部分分离</span> 
     <span style="color:#000000;">，使它们都可以独立地变化。</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">对象的实现</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <span style="color:#000000;">Composite</span> 
    </div> 
    <div> 
     <span style="color:#000000;">组合模式</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">将对象组合成树形结构以表示“</span> 
     <span style="color:#f33b45;">部分-整体</span> 
     <span style="color:#000000;">”的层次结构。</span> 
    </div> 
    <div> 
     <span style="color:#000000;">Composite使得客户对单个对象和复合对象的使用具有一致性。</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">对象的结构和组合</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <div> 
      <span style="color:#000000;">Fly weight Pattern</span> 
     </div> 
     <div> 
      <span style="color:#000000;">享元模式</span> 
     </div> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">运用</span> 
     <span style="color:#f33b45;">共享技术</span> 
     <span style="color:#000000;">有效地支持大量</span> 
     <span style="color:#f33b45;">细粒度</span> 
     <span style="color:#000000;">的对象。</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">对象的存储代价</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <div> 
      <span style="color:#000000;">Proxy</span> 
     </div> 
     <div> 
      <span style="color:#000000;">代理模式</span> 
     </div> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">为其他对象提供一种代理以控制对这个对象的问。</span> 
    </div> 
    <div> 
     <span style="color:#000000;">代理模式使用代理对象完成用户请求，</span> 
     <span style="color:#f33b45;">屏蔽用户对真实对象的访问</span> 
     <span style="color:#000000;">。</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">如何访问对象对象位置</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <div> 
      <span style="color:#000000;">Adapter</span> 
      <span style="color:#000000;">（类）</span> 
     </div> 
     <div> 
      <span style="color:#000000;">适配器</span> 
     </div> 
    </div> </td><td><span style="color:#000000;">将一个类的接口转换成客户希望的另外一个接口。Adapter模式</span><span style="color:#f33b45;">使得原本由于接口不兼容而不能一起工作的那些类，可以一起工作</span>。</td><td> 
    <div> 
     <span style="color:#000000;">与对象的接口</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <div> 
      <span style="color:#000000;">Decorator</span> 
     </div> 
     <div> 
      <span style="color:#000000;">装饰模式</span> 
     </div> 
    </div> </td><td> 
    <div> 
     <span style="color:#f33b45;">动态地给一个对象添加一些额外的职责</span> 
     <span style="color:#000000;">。就扩展功能而言，Decorator模式比生成子类方式更为活。</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">无子类对象责任</span> 
    </div> </td></tr></tbody></table> 
<h4 id="1%E3%80%81Facade%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F">（1）外观模式(Facade)</h4> 
<p>        外观模式为子系统中的一组接口提供了一个统一的接口，以简化客户端与子系统之间的交互。外观模式提供了一个高层次的接口，以便客户端可以更方便地使用子系统的功能。</p> 
<p>        在外观模式中，我们定义了一个外观类，该类封装了子系统中的一组接口。客户端代码只需要与外观类进行交互，而不需要直接与子系统的接口进行交互。外观类负责将客户端请求委托给适当的子系统对象进行处理，并返回结果给客户端。下面是类图示例：</p> 
<p class="img-center"><img alt="" height="418" src="https://images2.imgbox.com/0c/3f/ZRb1Kgff_o.png" width="500"></p> 
<h4 id="2%E3%80%81Bridge%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F">（2）桥接模式(<span style="color:#000000;">Bridge</span>)</h4> 
<p>        桥接模式将抽象部分与实现部分分离开来，以便它们可以独立地变化。桥接模式通过创建一个桥接接口来实现这一目的，该接口将抽象部分和实现部分分离开来，使得它们可以独立地进行变化。</p> 
<p>        在桥接模式中，我们首先定义了一个抽象接口，该接口定义了一组抽象方法，用于表示需要实现的功能。然后，我们定义了一个实现接口，该接口实现了抽象接口，并提供了具体的实现。最后，我们创建一个桥接接口，该接口将抽象接口和实现接口结合在一起，以便它们可以进行交互。下面是类图示例：</p> 
<p class="img-center"><img alt="" height="320" src="https://images2.imgbox.com/55/78/7FaQmrnb_o.png" width="700"></p> 
<h4 id="%EF%BC%883%EF%BC%89Composite%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F">（3）组合模式(<span style="color:#000000;">Composite</span>)</h4> 
<p>        组合模式允许我们将对象组合成树形结构来表示“整体/部分”层次结构。组合模式将对象分为两个类型：叶节点和组合节点。叶节点表示单个对象，而组合节点表示由多个对象组成的组合。</p> 
<p>        在组合模式中，我们首先定义了一个抽象基类，该类定义了一组共同的操作，用于表示组合中的对象。然后，我们定义了两个子类：叶节点和组合节点。叶节点表示单个对象，而组合节点表示由多个对象组成的组合。<span style="color:#000000;">  </span></p> 
<div> 
 <h4 id="%EF%BC%884%EF%BC%89%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F(Fly%20weight%20Pattern)">（4）享元模式(<span style="color:#000000;">Fly weight Pattern</span>)</h4> 
 <p>        享元模式旨在通过共享尽可能多的数据来最小化内存使用和对象创建。它适用于需要创建大量类似对象的场景，其中对象之间的区别仅在于它们的内部状态。</p> 
 <p>        在享元模式中，我们通过将对象分为内部状态和外部状态两部分来最小化内存使用和对象创建。内部状态是对象可共享的状态，而外部状态是随对象变化而变化的状态。</p> 
 <p>        享元模式的核心思想是缓存对象。在第一次创建对象时，我们将其存储在缓存中。在之后需要相同对象时，我们从缓存中获取它们，而不是重新创建它们。</p> 
 <p class="img-center"><img alt="" height="378" src="https://images2.imgbox.com/2f/37/mwsU7sdN_o.png" width="600"></p> 
 <h4 id="5%E3%80%81Proxy%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">（5）代理模式(<span style="color:#000000;">Proxy</span>)</h4> 
 <p>        代理模式允许我们为其他对象提供一个替代品或占位符，以控制对这个对象的访问。它适用于需要控制对某个对象的访问时，例如在访问某个重要对象时需要进行权限检查。</p> 
 <p>        在代理模式中，我们定义了一个代理类，它充当了客户端和实际对象之间的中介。代理类保存了一个对实际对象的引用，并提供了与实际对象相同的接口，以便客户端可以通过代理访问实际对象。在客户端请求时，代理类会拦截请求，并在实际对象执行请求之前进行某些操作，例如权限检查或缓存数据等。</p> 
 <p class="img-center"><img alt="" height="401" src="https://images2.imgbox.com/7e/31/4T9QXIO5_o.png" width="600"></p> 
 <h4 id="%EF%BC%886%EF%BC%89Adapter%EF%BC%88%E7%B1%BB%EF%BC%89%E9%80%82%E9%85%8D%E5%99%A8">（6）适配器模式(<span style="color:#000000;">Adapter</span>)</h4> 
 <p>        适配器模式允许我们将不兼容的对象接口转换为客户端需要的接口，以便它们可以在一起工作。适配器模式的目的是使原本不兼容的接口可以协同工作，而无需修改它们的源代码。</p> 
 <p>        在适配器模式中，我们定义了一个适配器类，它实现了客户端所需要的目标接口，并将实际对象的接口转换为目标接口。适配器类保存了一个对实际对象的引用，并通过在目标接口和实际对象接口之间进行转换，使它们可以进行交互。</p> 
 <p>        适配器模式有两种实现方式：类适配器和对象适配器。类适配器使用多重继承来适配接口，而对象适配器使用组合来适配接口。类适配器适配器适用于适配一个类的接口，而对象适配器适用于适配一个对象的接口。</p> 
 <p class="img-center"><img alt="" height="308" src="https://images2.imgbox.com/7d/e2/1NNkfGLE_o.png" width="700"></p> 
</div> 
<h4 id="7%E3%80%81Decorator%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F">（7）装饰模式(<span style="color:#000000;">Decorator</span>)</h4> 
<p>        装饰模式允许我们在不改变现有对象的情况下，动态地向其添加行为。装饰模式通过将对象放入包装器中来实现这一目的，同时保持包装器接口与原始对象接口相同。</p> 
<p>        在装饰模式中，我们定义了一个装饰器基类和一个具体组件类。装饰器基类实现了与组件相同的接口，并将组件对象作为其成员变量。具体装饰器类继承自装饰器基类，并在其成员变量上添加额外的功能。</p> 
<p>        通过使用装饰模式，我们可以将多个装饰器链式地链接在一起，以便实现复杂的行为。由于装饰器模式是基于组合而非继承的，因此它可以动态地添加或删除行为，而无需更改原始对象的代码。</p> 
<p class="img-center"><img alt="" height="510" src="https://images2.imgbox.com/df/01/lMcKISR2_o.png" width="600"></p> 
<h3 id="4%E3%80%81%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D">4、行为型模式详细介绍</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:654px;"><tbody><tr><td style="width:60px;"><strong>目的</strong></td><td style="width:100px;"><strong>设计模式</strong></td><td style="width:331px;"><strong>简要说明</strong></td><td style="width:162px;"><strong>可改版的方面</strong></td></tr><tr><td colspan="1" rowspan="11"> <p>行</p> <p>为</p> <p>型</p> </td><td> 
    <div> 
     <div> 
      <span style="color:#000000;">Observer</span> 
     </div> 
     <div> 
      <span style="color:#000000;">观察者模式</span> 
     </div> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">观察者模式</span> 
     <span style="color:#f33b45;">定义了对象间的一种一对多依赖关系</span> 
     <span style="color:#000000;">，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">信赖于另一对象的对象数量，信对象如何保持最新数据</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <div> 
      <span style="color:#000000;">Template Method</span> 
     </div> 
     <div> 
      <span style="color:#000000;">模板方法</span> 
     </div> 
    </div> </td><td> 
    <div> 
     <span style="color:#f33b45;">定义一个操作中的算法的骨架</span> 
     <span style="color:#000000;">，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个</span> 
    </div> 
    <div> 
     <span style="color:#000000;">算法的结构即可重定义该算法的某些特定步骤。</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">算法的步骤</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <div> 
      <span style="color:#000000;">Iterator</span> 
     </div> 
     <div> 
      <span style="color:#000000;">迭代器模式</span> 
     </div> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">提供一种方法顺序访问一个聚合对象中各个元素，</span> 
     <span style="color:#000000;">而又</span> 
     <span style="color:#f33b45;">无须暴露该对象的内部表示</span> 
     <span style="color:#000000;">。</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">如何访问、遍历聚集的元素</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <div> 
      <span style="color:#000000;">Strategy</span> 
     </div> 
     <div> 
      <span style="color:#000000;">策略模式</span> 
     </div> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模</span> 
    </div> 
    <div> 
     <span style="color:#000000;">式</span> 
     <span style="color:#f33b45;">让算法独立于使用它的客户而独立变化</span> 
     <span style="color:#000000;">。</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">算法</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <div> 
      <span style="color:#000000;">Chain of Responsibility</span> 
     </div> 
     <div> 
      <span style="color:#000000;">责任链模式</span> 
     </div> 
    </div> </td><td> 
    <div> 
     <span style="color:#f33b45;">避免请求发送者与接收者耦合在一起</span> 
     <span style="color:#000000;">，让多个对象都有可能接收请求，将这些对象连接成一条链并且沿着这条链传递请求，直到有对象处理它为止。</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">可满足请求的对象</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <div> 
      <span style="color:#000000;">Command</span> 
     </div> 
     <div> 
      <span style="color:#000000;">命令模式</span> 
     </div> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">将一个请求封装成一个对象，从而使得用不同的请求对客户进行参数化；对请求排队或</span> 
     <span style="color:#f33b45;">记录请求日志</span> 
     <span style="color:#000000;">，以及</span> 
     <span style="color:#f33b45;">支持可撤销的操作</span> 
     <span style="color:#000000;">。</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">何时及如何满足一个请求</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <div> 
      <span style="color:#000000;">Interpreter</span> 
     </div> 
     <div> 
      <span style="color:#000000;">解释器模式</span> 
     </div> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来</span> 
     <span style="color:#f33b45;">解释语言中的句子</span> 
     <span style="color:#000000;">。</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">语言的语法和解释</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <div> 
      <span style="color:#000000;">Visitor</span> 
     </div> 
     <div> 
      <span style="color:#000000;">访问者模式</span> 
     </div> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作</span> 
    </div> 
    <div> 
     <span style="color:#000000;">用与这些元素的新操作。即对于某个对象或者一组对象，</span> 
     <span style="color:#f33b45;">不同的访问者，产生的结果不同</span> 
     <span style="color:#000000;">，执行</span> 
    </div> 
    <div> 
     <span style="color:#000000;">操作也不同。</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">无须改变其类而可应用于对象的操作</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <div> 
      <span style="color:#000000;">Mediator</span> 
     </div> 
     <div> 
      <span style="color:#000000;">中介者模式</span> 
     </div> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">用一个中介对象来封装一系列的对象交互，</span> 
     <span style="color:#f33b45;">中介者使各对象不需要显式地相互引用</span> 
     <span style="color:#000000;">，从而使其耦合松散，而且可以独立地改变它们之间的交互。</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">对象之间如何交互以及哪些对象交互</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <div> 
      <span style="color:#000000;">Memento</span> 
     </div> 
     <div> 
      <span style="color:#000000;">备忘录模式</span> 
     </div> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">何时及哪些私有信息存储在对象之外</span> 
    </div> </td></tr><tr><td> 
    <div> 
     <div> 
      <span style="color:#000000;">State</span> 
     </div> 
     <div> 
      <span style="color:#000000;">状态模式</span> 
     </div> 
    </div> </td><td> 
    <div> 
     <span style="color:#f33b45;">允许一个对象在其内部状态改变时改变它的行为</span> 
     <span style="color:#000000;">。对象看起来似乎修改了它的类。</span> 
    </div> </td><td> 
    <div> 
     <span style="color:#000000;">对象的状态</span> 
    </div> </td></tr></tbody></table> 
<h4 id="1%E3%80%81Observer%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">（1）观察者模式(<span style="color:#000000;">Observer</span>)</h4> 
<p>        观察者模式允许对象之间建立一对多的依赖关系，当一个对象的状态发生改变时，其所有依赖对象都将得到通知并自动更新。</p> 
<p>        在观察者模式中，有两种类型的对象：观察者和被观察者。被观察者维护了一个观察者列表，并提供了用于添加、删除和通知观察者的接口。观察者定义了接收通知并响应的方法。</p> 
<p>        当被观察者状态发生改变时，它将遍历其观察者列表并调用每个观察者的更新方法。观察者的更新方法将执行响应的操作以响应被观察者状态的变化。</p> 
<p class="img-center"><img alt="" height="291" src="https://images2.imgbox.com/93/fa/x87UEIiU_o.png" width="700"></p> 
<h4 id="%EF%BC%882%EF%BC%89Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F">（2）迭代器模式(<span style="color:#000000;">Iterator</span>)</h4> 
<p>        迭代器模式提供一种方法访问一个容器对象中的各个元素，而又不需要暴露该对象的内部表示。通过使用迭代器模式，可以支持对容器中的元素进行多种遍历操作，如顺序遍历、倒序遍历、部分遍历等。</p> 
<p>        在迭代器模式中，有两个主要的对象：迭代器和容器。容器负责维护元素集合，并提供用于获取迭代器的接口。迭代器负责遍历容器中的元素，并提供用于判断是否还有下一个元素、获取当前元素等操作的接口。</p> 
<h4 id="3%E3%80%81Template%C2%A0Method%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95">（3）模板方法模式(<span style="color:#000000;">Template Method</span>)</h4> 
<p>        模板方法模式定义了一个操作中的算法框架，而将一些步骤延迟到子类中实现。模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p> 
<p>        模板方法模式由抽象类和具体实现类组成。抽象类定义了一个模板方法，该方法定义了算法的框架，并规定了一些基本方法和抽象方法。具体实现类实现了抽象类中的抽象方法，并可以重写基本方法，但不能重写模板方法。</p> 
<h4 id="%EF%BC%884%EF%BC%89%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F(Strategy)">（4）策略模式(<span style="color:#000000;">Strategy</span>)</h4> 
<p>        策略模式定义了一系列算法（策略），并将其封装成独立的对象，使得它们可以在不同的上下文中互换使用，从而使得算法的变化独立于使用算法的客户。</p> 
<p>        在策略模式中，有三个主要的对象：策略接口、具体策略类和上下文对象。策略接口定义了一组算法操作的接口，具体策略类实现了策略接口中的算法操作，而上下文对象则维护了一个策略对象的引用，并将具体的算法操作委托给策略对象来执行。</p> 
<p class="img-center"><img alt="" height="304" src="https://images2.imgbox.com/3a/ac/jKMPVdqC_o.png" width="700"></p> 
<h4 id="%EF%BC%885%EF%BC%89Chain%20of%C2%A0Responsibility%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F">（5）责任链模式(<span style="color:#000000;">Chain of Responsibility</span>)</h4> 
<p>        责任链模式允许将请求沿着处理链进行传递，直到其中某个处理者能够处理它为止。在责任链模式中，请求被沿着一条链传递，每个处理者都有机会来处理请求，或将请求传递给下一个处理者。</p> 
<p>        在责任链模式中，有三个主要的对象：抽象处理者、具体处理者和客户端。抽象处理者定义了处理请求的接口，具体处理者实现了抽象处理者的接口，并负责处理请求或将请求传递给下一个处理者，而客户端则创建处理链并将请求发送到处理链的起始点。</p> 
<h4 id="6%E3%80%81Command%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F">（6）命令模式(<span style="color:#000000;">Command</span>)</h4> 
<p>        命令模式允许将请求封装为对象，从而使得可以将请求参数化、将请求放入队列中、记录请求日志、提供可撤销操作等。在命令模式中，将请求发送者和请求接收者解耦，使得它们不需要知道彼此的存在，而是通过命令对象进行通信。</p> 
<p>        在命令模式中，有四个主要的对象：抽象命令、具体命令、命令接收者和命令发送者。抽象命令定义了命令的接口，具体命令实现了抽象命令的接口，并包含了命令接收者的引用，命令接收者实现了具体命令所定义的操作，而命令发送者创建具体命令并将其发送给命令接收者。</p> 
<p class="img-center"><img alt="" height="315" src="https://images2.imgbox.com/b4/1f/9DPm0smh_o.png" width="600"></p> 
<h4 id="%EF%BC%887%EF%BC%89Interpreter%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F">（7）解释器模式(<span style="color:#000000;">Interpreter</span>)</h4> 
<p>        解释器模式提供了一种定义语言文法并解释语法的方式。在解释器模式中，我们定义一种语言的文法，并且实现一个解释器，用来解释语言中的表达式。</p> 
<p>        在解释器模式中，我们通常有以下三种角色：</p> 
<ol><li> <p>抽象表达式（Abstract Expression）：定义了一个抽象的接口，用于解释语法规则中的终结符和非终结符。</p> </li><li> <p>终结符表达式（Terminal Expression）：实现了抽象表达式接口，并定义了一个终结符的解释操作。</p> </li><li> <p>非终结符表达式（Nonterminal Expression）：实现了抽象表达式接口，并定义了一个非终结符的解释操作，它通常由多个终结符和非终结符组成。</p> </li></ol> 
<p>        在解释器模式中，我们将整个语言都看作一个抽象语法树，每一个节点都是一个表达式，而每一个叶子节点都是终结符表达式，每一个非叶子节点都是非终结符表达式。当我们需要解释一段语言时，我们只需要将这段语言转化成抽象语法树，并按照树的结构进行解释即可。</p> 
<h4 id="8%E3%80%81Visitor%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F">（8）访问者模式(<span style="color:#000000;">Visitor</span>)</h4> 
<p>        访问者模式能够将算法与数据结构分离开来。访问者模式的核心思想是：在不改变数据结构的前提下，增加新的操作。</p> 
<p>        在访问者模式中，我们通常有以下两种角色：</p> 
<ol><li> <p>抽象访问者（Abstract Visitor）：定义了对数据结构中的元素进行操作的方法。</p> </li><li> <p>具体访问者（Concrete Visitor）：实现了抽象访问者接口，并且提供了具体的操作逻辑。</p> </li></ol> 
<p>        在访问者模式中，我们还需要定义两个角色：</p> 
<ol><li> <p>抽象元素（Abstract Element）：定义了一个接口，用于访问者访问该元素。</p> </li><li> <p>具体元素（Concrete Element）：实现了抽象元素接口，并且提供了接受访问者访问的方法。</p> </li></ol> 
<p>        在访问者模式中，访问者对象将会遍历整个数据结构，并且依次访问每一个元素。当访问者访问到一个元素时，它会根据具体元素的类型来调用相应的操作方法。由于访问者模式将数据结构和操作分离开来，因此我们能够在不改变数据结构的前提下，增加新的操作，这样就提高了代码的可扩展性和可维护性。</p> 
<h4 id="9%E3%80%81Mediator%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F">（9）中介者模式(<span style="color:#000000;">Mediator</span>)</h4> 
<p>        中介者模式通过将对象之间的交互委托给中介者对象来减少对象之间的直接耦合。中介者模式的核心思想是通过将对象之间的复杂关系转化为中介者对象和各个对象之间的简单关系，从而提高系统的灵活性和可维护性。</p> 
<p>        在中介者模式中，有一个中介者对象，它封装了一些处理对象之间交互的逻辑。各个对象可以通过中介者对象来交互，而不是直接与其他对象交互。当某个对象需要与其他对象进行通信时，它会向中介者对象发送请求，中介者对象会将请求转发给其他对象，然后将响应返回给请求对象。</p> 
<p>        中介者模式的主要优点是它能够减少对象之间的耦合，从而提高系统的灵活性和可维护性。它还能够将复杂的对象之间的交互关系转化为中介者对象和各个对象之间的简单关系，使得系统更加易于理解和维护。主要缺点是中介者对象可能会变得复杂和难以维护，因为它需要处理大量的对象之间的交互。</p> 
<h4 id="10%E3%80%81Memento%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F">（10）备忘录模式(<span style="color:#000000;">Memento</span>)</h4> 
<p>        备忘录模式允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。备忘录对象是用来保存其他对象的内部状态，并在需要的时候恢复该状态。</p> 
<p>        备忘录模式通常由三个主要组件组成：Originator（原发器），Memento（备忘录）和Caretaker（管理者）。Originator是要保存和恢复状态的对象，Memento是用于存储状态的对象，Caretaker是用于管理Memento的对象。</p> 
<p>        在备忘录模式中，Originator创建Memento对象，将其内部状态复制到该对象中，然后将该对象传递给Caretaker进行管理。当需要恢复状态时，Caretaker将Memento对象传递给Originator，Originator从该对象中提取状态并将其应用于自身。</p> 
<p>        备忘录模式的主要优点是它允许在不影响对象的封装性的情况下保存和恢复状态。它还提供了一种方法来撤销操作，因为它允许将对象返回到之前的状态。主要缺点是它可能会占用大量内存，特别是在需要保存大量状态的情况下。</p> 
<h4 id="%EF%BC%8811%EF%BC%89State%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F">（11）状态模式(State)</h4> 
<p>        状态模式允许对象在其内部状态发生改变时改变其行为。状态模式的核心思想是将对象的状态封装在单独的类中，使得对象能够在运行时根据不同状态执行不同的行为。</p> 
<p class="img-center"><img alt="" height="285" src="https://images2.imgbox.com/70/03/DzxxMXrU_o.png" width="600"></p> 
<p>        状态模式通常由三个主要组件组成：Context（上下文），State（状态）和ConcreteState（具体状态）。Context是包含状态对象的主体，它提供了一些用于操作状态对象的接口。State是一个抽象基类，它定义了一些用于操作状态的方法。ConcreteState是继承自State的具体状态类，它实现了State定义的方法。</p> 
<p>        在状态模式中，当一个对象的状态发生改变时，它将调用Context对象的方法，然后Context对象将请求转发给当前的状态对象，状态对象然后执行相应的操作。当状态发生改变时，Context对象将将其当前状态切换到新状态。</p> 
<p>        状态模式的主要优点是它能够减少重复的代码，同时也能提高代码的可维护性和可扩展性。它还能够消除一些条件语句，使得代码更加清晰和易于理解。主要缺点是它可能会增加类的数量，并且可能会导致对象的行为变得复杂和难以理解。</p> 
<p>附：《<a class="link-info" href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html" rel="nofollow" title="设计模式">设计模式</a>》</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d8b93c9f0d0af667bb148b6ea898bd81/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AJAX版本、响应数据、超时设置、同步异步</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b235c2994dfff6aa7dda7d6f48080f99/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WSL2启动时卡住无法启动</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>