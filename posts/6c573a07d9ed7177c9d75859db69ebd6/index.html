<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Android -- 面试】Android 知识点（四大组件） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Android -- 面试】Android 知识点（四大组件）" />
<meta property="og:description" content="目录 文章目录 目录ActivityFragmentServiceBroadcast ReceiverContentProvider Activity 1. 说下 Activity 的生命周期？
参考回答：
在 Activity 的生命周期涉及到七大方法，分别是：
onCreate() 表示 Activity 正在创建，常做初始化工作，如 setContentView 界面资源、初始化数据
onStart() 表示 Activity 正在启动，这时 Activity 可见但不在前台，无法和用户交互
onResume() 表示 Activity 获得焦点，此时 Activity 可见且在前台并开始活动
onPause() 表示 Activity 正在停止，可做 数据存储、停止动画等操作
onStop() 表示 Activity 即将停止，可做稍微重量级回收工作，如取消网络连接、注销广播接收器等
onDestroy() 表示 Activity 即将销毁，常做回收工作、资源释放
另外，当 Activity 由后台切换到前台，由不可见到可见时会调用 onRestart()，表示 Activity 重新启动
2. 说下 Activity 的四种启动模式？
参考回答：
standard 标准模式：每次启动一个 Activity 就会创建一个新的实例
singleTop 栈顶复用模式：如果新 Activity 已经位于任务栈的栈顶，就不会重新创建，并回调
onNewIntent(intent) 方法
singleTask 栈内复用模式：只要该 Activity 在一个任务栈中存在，都不会重新创建，并回调" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/6c573a07d9ed7177c9d75859db69ebd6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-21T17:48:25+08:00" />
<meta property="article:modified_time" content="2022-06-21T17:48:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Android -- 面试】Android 知识点（四大组件）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>目录</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_0" rel="nofollow">目录</a></li><li><ul><li><ul><li><a href="#Activity_6" rel="nofollow">Activity</a></li><li><a href="#Fragment_79" rel="nofollow">Fragment</a></li><li><a href="#Service_104" rel="nofollow">Service</a></li><li><a href="#Broadcast_Receiver_154" rel="nofollow">Broadcast Receiver</a></li><li><a href="#ContentProvider_167" rel="nofollow">ContentProvider</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="Activity_6"></a>Activity</h4> 
<p><strong>1. 说下 Activity 的生命周期？</strong><br> 参考回答：<br> 在 Activity 的生命周期涉及到七大方法，分别是：<br> onCreate() 表示 Activity 正在创建，常做初始化工作，如 setContentView 界面资源、初始化数据<br> onStart() 表示 Activity 正在启动，这时 Activity 可见但不在前台，无法和用户交互<br> onResume() 表示 Activity 获得焦点，此时 Activity 可见且在前台并开始活动<br> onPause() 表示 Activity 正在停止，可做 数据存储、停止动画等操作<br> onStop() 表示 Activity 即将停止，可做稍微重量级回收工作，如取消网络连接、注销广播接收器等<br> onDestroy() 表示 Activity 即将销毁，常做回收工作、资源释放<br> 另外，当 Activity 由后台切换到前台，由不可见到可见时会调用 onRestart()，表示 Activity 重新启动</p> 
<p><strong>2. 说下 Activity 的四种启动模式？</strong><br> 参考回答：<br> standard 标准模式：每次启动一个 Activity 就会创建一个新的实例<br> singleTop 栈顶复用模式：如果新 Activity 已经位于任务栈的栈顶，就不会重新创建，并回调<br> onNewIntent(intent) 方法<br> singleTask 栈内复用模式：只要该 Activity 在一个任务栈中存在，都不会重新创建，并回调<br> onNewIntent(intent) 方法。如果不存在，系统会先寻找是否存在需要的栈，如果不存在该栈，就创建一个任务栈，并把该 Activity 放进去；如果存在，就会创建到已经存在的栈中<br> singleInstance 单实例模式：具有此模式的Activity只能单独位于一个任务栈中，且此任务栈中只有唯一一个实例</p> 
<p><strong>3. onStart()和onResume()/onPause()和onStop()的区别？</strong><br> 参考回答：<br> onStart() 与 onStop() 是从 Activity 是否可见这个角度调用的，onResume() 和 onPause()是从 Activity 是否显示在前台这个角度来回调的，在实际使用没其他明显区别。</p> 
<p><strong>4. Activity A启动另一个Activity B会回调哪些方法？如果Activity B是完全透明呢？如果启动的是一个Dialog呢？</strong><br> 参考回答：<br> Activity A 启动另一个 Activity B 会回调的方法：Activity A 的 onPause() --&gt; Activity B 的onCreate()–&gt;onStart()–&gt;onResume()–&gt;Activity A的 onStop()；如果Activity B是完全透明的，则最后不会调用 Activity A 的 onStop()；如果是对话框 Activity，同后种情况。</p> 
<p><strong>5. 谈谈onSaveInstanceState()方法？何时会调用？</strong><br> 参考回答：<br> 当非人为终止 Activity 时，比如系统配置发生改变时导致 Activity 被杀死并重新创建、资源内存不足导致低优先级的 Activity 被杀死，会调用 onSavaInstanceState() 来保存状态。该方法调用在 onStop 之前，但和 onPause 没有时序关系。</p> 
<p><strong>6. onSaveInstanceState()与onPause()的区别？</strong><br> 参考回答：<br> onSaveInstanceState() 适用于对临时性状态的保存，而 onPause() 适用于对数据的持久化保存。</p> 
<p><strong>7. 如何避免配置改变时 Activity 重建？</strong><br> 参考回答：<br> 为了避免由于配置改变导致 Activity 重建，可在 AndroidManifest.xml 中对应的 Activity 中设置android:configChanges=“orientation|screenSize”。此时再次旋转屏幕时，该 Activity 不会被系统杀死和重建，只会调用 onConfigurationChanged 。因此，当配置程序需要响应配置改变，指定 configChanges 属性，重写 onConfigurationChanged 方法即可。</p> 
<p><strong>8. 优先级低的 Activity 在内存不足被回收后怎样做可以恢复到销毁前状态？</strong><br> 参考回答：<br> 优先级低的 Activity 在内存不足被回收后重新打开会引发 Activity 重建。Activity 被重新创建时会调用 onRestoreInstanceState（该方法在onStart之后），并将 onSavaInstanceState 保存的 Bundle 对象作为参数传到onRestoreInstanceState与onCreate方法。因此可通过onRestoreInstanceState(Bundle savedInstanceState)和onCreate((Bundle savedInstanceState)来判断 Activity 是否被重建，并取出数据进行恢复。但需要注意的是，在onCreate取出数据时一定要先判断 savedInstanceState 是否为空。另外，谷歌更推荐使用 onRestoreInstanceState 进行数据恢复。</p> 
<p><strong>9. 谈谈singleTop和singleTask的区别以及应用场景？</strong><br> 参考回答：<br> singleTop 和 singleTask 的大致区别有：<br> singleTop：同个 Activity 实例在栈中可以有多个，即可能重复创建；该模式的 Activity 会默认进入启动它所属的任务栈，即不会引起任务栈的变更；为防止快速点击时多次 startActivity，可以将目标 Activity 设置为 singleTop<br> singleTask：同个 Activity 实例在栈中只有一个，即不存在重复创建；可通过 android：taskAffinity 设定该 Activity 需要的任务栈，即可能会引起任务栈的变更；常用于主页和登陆页</p> 
<p><strong>10. onNewIntent()调用时机？</strong><br> 参考回答：<br> 启动模式为 singleTop 或 singleTask 的 Activity 在以下情况会回调 onNewIntent()：<br> singleTop：如果新 Activity 已经位于任务栈的栈顶，就不会重新创建，并回调 onNewIntent(intent) 方法<br> singleTask：只要该 Activity 在一个任务栈中存在，都不会重新创建，并回调 onNewIntent(intent) 方法</p> 
<p><strong>11. 了解哪些Activity启动模式的标记位？</strong><br> 参考回答：<br> 常见的两个标记为：<br> FLAG_ACTIVITY_SINGLE_TOP:对应singleTop启动模式<br> FLAG_ACTIVITY_NEW_TASK ：对应singleTask模式</p> 
<p><strong>12. 如何启动其他应用的 Activity ？</strong><br> 参考回答：<br> 在保证有权限访问的情况下，通过隐式 Intent 进行目标Activity的IntentFilter匹配，原则是：<br> 一个 intent 只有同时匹配某个 Activity 的 intent-filter 中的 action、category、data才算完全匹配，才能启动该Activity。<br> 一个Activity可以有多个 intent-filter，一个 intent只要成功匹配任意一组 intent-filter，就可以启动该Activity。</p> 
<p><strong>13. Activity 的启动过程？</strong><br> 参考回答：<br> 调用 startActivity() 后经过重重方法会转移到 ActivityManagerService 的 startActivity()，并通过一个 IPC 回到 ActivityThread 的内部类 ApplicationThread 中，并调用其scheduleLaunchActivity()将启动Activity的消息发送并交由Handler H处理。Handler H对消息的处理会调用handleLaunchActivity()-&gt;performLaunchActivity()得以完成Activity对象的创建和启动。</p> 
<h4><a id="Fragment_79"></a>Fragment</h4> 
<p><strong>14. 谈一谈 Fragment 的生命周期？</strong><br> 参考回答：<br> Fragment 从创建到销毁整个生命周期中涉及到的方法依次为：onAttach()-&gt;onCreate()-&gt; onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume()-&gt;onPause()-&gt;onStop()-&gt;onDestroyView()-&gt;onDestroy()-&gt;onDetach()，其中和Activity有不少名称相同作用相似的方法，而不同的方法有:<br> onAttach()：当Fragment和Activity建立关联时调用<br> onCreateView()：当Fragment创建视图时调用<br> onActivityCreated()：当与Fragment相关联的Activity完成onCreate()之后调用<br> onDestroyView()：在Fragment中的布局被移除时调用<br> onDetach()：当Fragment和Activity解除关联时调用</p> 
<p><strong>15. Activity和Fragment的异同？</strong><br> 参考回答：<br> Activity 和 Fragment 的相似点在于，它们都可包含布局、可有自己的生命周期，Fragment 可看似迷你活动。<br> 不同点是，由于 Fragment 是依附在 Activity 上的，多了些和宿主Activity相关的生命周期方法，如onAttach()、onActivityCreated()、onDetach()；另外，Fragment的生命周期方法是由宿主Activity而不是操作系统调用的，Activity中生命周期方法都是protected，而Fragment都是public，也能印证了这一点，因为Activity需要调用Fragment那些方法并管理它。</p> 
<p><strong>16. Activity 和 Fragment 的关系？</strong><br> 参考回答：<br> 正如 Fragment 的名字“碎片”，它的出现是为了解决 Android 碎片化 ，它可作为Activity界面的组成部分，可在Activity运行中实现动态地加入、移除和交换。<br> 一个 Activity中可同时出现多个Fragment，一个Fragment也可在多个Activity中使用。<br> 另外，Activity的FragmentManager负责调用队列中Fragment的生命周期方法，只要Fragment的状态与Activity的状态保持了同步，宿主Activity的FragmentManager便会继续调用其他生命周期方法以继续保持Fragment与Activity的状态一致。</p> 
<p><strong>17. 何时会考虑使用Fragment？</strong><br> 参考回答：<br> 非常经典的例子，即用两个Fragment封装两个界面模块，这样只使一套代码就能适配两种设备，达到两种界面效果；单一场景切换时使用Fragment更轻量化，如ViewPager和Fragment搭配使用</p> 
<h4><a id="Service_104"></a>Service</h4> 
<p><strong>18. 谈一谈Service的生命周期？</strong><br> 参考回答：在Service的生命周期涉及到六大方法，分别是：<br> onCreate（）：服务第一次被创建时调用<br> onStartComand（）：服务启动时调用<br> onBind（）：服务被绑定时调用<br> onUnBind（）：服务被解绑时调用<br> onDestroy（）：服务停止时调用</p> 
<p><strong>19. Service的两种启动方式？区别在哪？</strong><br> 参考回答：<br> 第一种，其他组件调用Context的 startService() 方法可以启动一个Service，并回调服务中的onStartCommand()。如果该服务之前还没创建，那么回调的顺序是onCreate()-&gt;onStartCommand()。服务启动了之后会一直保持运行状态，直到 stopService() 或 stopSelf() 方法被调用，服务停止并回调onDestroy()。另外，无论调用多少次startService()方法，只需调用一次stopService()或stopSelf()方法，服务就会停止了。<br> 第二种，其它组件调用Context的 bindService() 可以绑定一个Service，并回调服务中的onBind()方法。类似地，如果该服务之前还没创建，那么回调的顺序是onCreate()-&gt;onBind()。之后，调用方可以获取到onBind()方法里返回的IBinder对象的实例，从而实现和服务进行通信。只要调用方和服务之间的连接没有断开，服务就会一直保持运行状态，直到调用了 unbindService() 方法服务会停止，回调顺序onUnBind()-&gt;onDestroy()。</p> 
<p><strong>20. 一个Activty先start一个Service后，再bind时会回调什么方法？此时如何做才能回调Service的destory()方法？</strong><br> 参考回答：<br> startService()启动Service之后，再bindService()绑定，此时只会回调onBind()方法；若想回调Service的destory()方法，需要同时调用 stopService()和 unbindService()方法才能让服务销毁掉。</p> 
<p><strong>21. Service如何和Activity进行通信？</strong><br> 参考回答：</p> 
<ul><li>通过bindService()可以实现Activity调用Service中的方法，</li><li>通过广播实现Service向Activity发送消息</li></ul> 
<p><strong>22. 用过哪些系统Service？</strong><br> 参考回答：<br> <a href="https://upload-images.jianshu.io/upload_images/5494434-2588ec70045e4ab2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" rel="nofollow">常用系统服务</a></p> 
<p><strong>23. 是否能在Service进行耗时操作？如果非要可以怎么做？</strong><br> 参考回答：<br> Service默认并不会运行在子线程中，也不运行在一个独立的进程中，它同样执行在主线程中（UI线程）。换句话说，不要在Service里执行耗时操作，除非手动打开一个子线程，否则有可能出现主线程被阻塞（ANR）的情况。</p> 
<p><strong>24. AlarmManager能实现定时的原理？</strong><br> 参考回答：<br> 通过调用 AlarmManager 的 set() 方法就可以设置一个定时任务，并提供三个参数（工作类型，定时任务触发的时间，PendingIntent对象）。其中第三个PendingIntent对象是关键，一般会调用它的 getBroadcast() 方法来获取一个能够执行广播的PendingIntent。这样当定时任务被触发的时候，广播接收器的onReceive()方法就可以得到执行。即通过服务和广播的循环触发实现定时服务。</p> 
<p><strong>25. 前台服务是什么？和普通服务的不同？如何去开启一个前台服务？</strong><br> 参考回答：<br> 和一般运行在后台的服务不同，前台服务的服务状态可以被用户一眼看到。它和普通服务最大的区别是，前者会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果，且当系统内存不足服务被杀死时，通知会被移除。实现一个前台服务也非常简单，和发送一个通知非常类似，只不过在构建好一个Notification之后，不需要NotificationManager将通知显示出来，而是调用了 startForeground() 方法。</p> 
<p><strong>26. 是否了解ActivityManagerService，谈谈它发挥什么作用？</strong><br> 参考回答：<br> ActivityManagerService是Android中最核心的服务 ， 主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块类似。</p> 
<p><strong>27. 如何保证Service不被杀死？</strong><br> 参考回答：<br> 可以采取以下几种解决方法：<br> 在 Service 的onStartCommand()中设置flages值为START_STICKY，使得Service被杀死后尝试再次启动Service<br> 提升Service优先级，比如设置为一个前台服务<br> 在Activity的onDestroy()通过发送广播，并在广播接收器的onReceive()中启动Service</p> 
<h4><a id="Broadcast_Receiver_154"></a>Broadcast Receiver</h4> 
<p><strong>28. 广播有几种形式？什么特点？</strong><br> 参考回答：<br> 普通广播：一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此它们接收的先后是随机的。<br> 有序广播：一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递，所以此时的广播接收器是有先后顺序的，且优先级（priority）高的广播接收器会先收到广播消息。有序广播可以被接收器截断使得后面的接收器无法收到它。<br> 本地广播：发出的广播只能够在应用程序的内部进行传递，并且广播接收器也只能接收本应用程序发出的广播。<br> 粘性广播：这种广播会一直滞留，当有匹配该广播的接收器被注册后，该接收器就会收到此条广播。</p> 
<p><strong>29. 广播的两种注册形式？区别在哪？</strong><br> 参考回答：<br> 广播的注册有两种方法：一种在活动里通过代码动态注册，另一种在配置文件里静态注册。两种方式的相同点是都完成了对接收器以及它能接收的广播值这两个值的定义；<br> 不同点是动态注册的接收器必须要在程序启动之后才能接收到广播，而静态注册的接收器即便程序未启动也能接收到广播，比如想接收到手机开机完成后系统发出的广播就只能用静态注册了。</p> 
<h4><a id="ContentProvider_167"></a>ContentProvider</h4> 
<p><strong>30. ContentProvider了解多少？</strong><br> 参考回答：<br> 作为四大组件之一，ContentProvider主要负责存储和共享数据。与文件存储、SharedPreferences存储、SQLite数据库存储这几种数据存储方法不同的是，后者保存下的数据只能被该应用程序使用，而前者可以让不同应用程序之间进行数据共享，它还可以选择只对哪一部分数据进行共享，从而保证程序中的隐私数据不会有泄漏风险。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4f0493b525d1f7a77549dbbe1d1d45cc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">macOS环境下ping通github.com（丢包率0%），以及安装homebrew</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eccf01476b0054956da79a48ee4ea25a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Servlet】什么是Servlet；常见状态码；Servlet API；Cookie和Session</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>