<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Verilog组合逻辑和时序逻辑的比较 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Verilog组合逻辑和时序逻辑的比较" />
<meta property="og:description" content="VerilogHDL语言分为面向综合和面向仿真两大类语句，且可综合语句远少于仿真语句，读者可能会有可综合设计相对简单的感觉。然而事实刚好与此相反，这是因为：首先，可综合设计是用来构建硬件平台的，因此对设计的指标要求很高，包括资源、频率和功耗，这都需要通过代码来体现；其次，在实际开发中要利用基本VerilogHDL语句完成种类繁多的硬件开发，给设计人员带来了很大的挑战。所有的仿真语句只是为了可综合设计的验证而存在。为了让读者深入地理解可综合设计、灵活运用已学内容，本章将可综合设计中的基本知识点和难点提取出来，融入VerilogHDL语法以及开发工具等诸多方面，以深入浅出的方式向读者说明设计中的难点本质。 8.1 组合逻辑和时序逻辑 数字电路根据逻辑功能的不同特点，可以分成两大类，一类叫组合逻辑电路（简称组合电路），另一类叫做时序逻辑电路（简称时序电路）。掌握组合逻辑和时序逻辑的区分手段与实现方法是数字系统设计的基本要求。 8.1.1 组合逻辑设计 1．组合逻辑概念 组合逻辑是VerilogHDL设计中的一个重要组成部分。从电路本质上讲，组合逻辑电路的特点是输出信号只是当前时刻输入信号的函数，与其他时刻的输入状态无关。无存储电路，也没有反馈电路，其典型结构如图8-1所示。从电路行为上看，其特征就是输出信号的变化仅仅与输入信号的电平有关，不涉及对信号跳变沿的处理。 尽管组合电路在功能上千差万别，可是其分析方法却有很多相似之处。给定逻辑电路后，得到其输入与输出的直接表达式，将输入组合全部带入表达式中计算得到输出结果，并以真值表的形式表达出来，最后根据真值表说明电路功能。 组合逻辑电路的设计就是在给定逻辑功能的前提下，通过某种设计渠道，得到满足功能要求且最简单的逻辑电路。基于HDL 语言和EDA工具的组合逻辑电路的设计流程如图8-2 所示。 其中逻辑抽象和HDL编程是重点环节。在很多情况下，逻辑问题都是通过文字描述的，逻辑抽象就是对设计对象的输入与输出信号间的因果关系，用逻辑函数的方法表示出来。HDL语言编程就是直接通过语句来实现抽象结果。 2．组合逻辑的Verilog HDL 描述 根据组合逻辑的电路行为，可以得到两种常用的RTL 级描述方式。第一种是always模块的触发事件为电平敏感信号列表；第二种就是用assign 关键字描述的数据流赋值语句。 （1）always 模块的敏感表为电平敏感信号的电路 这种方式的组合电路应用非常广泛，几乎可以完成对所有组合逻辑电路的建模。always模块的敏感列表为所有判断条件信号和输入信号，但一定要注意敏感列表的完整性。在always模块中可以使用if、case 和for 等各种RTL关键字结构。由于赋值语句有阻塞赋值和非阻塞赋值两类，建议读者使用阻塞赋值语句“=”，详细原因将在8.3.1 节进行说明。 always 模块中的信号必须定义为reg 型，不过最终的实现结果中并没有寄存器。这是由于在组合逻辑电路描述中，将信号定义为reg型，只是为了满足语法要求。下面给出一个组合逻辑实例。 【例8-1】通过Verilog HDL 语言实现一个2 输入比较器，输入分别为d1、d2，输出分别为f1（d1&gt;d2时为高电平）、f2（d1 = d2 时为高电平）、f3（d1 可以看出，组合逻辑就对应着电平触发事件电路。上述程序在ISE中综合后的RTL级结构图如图8-3所示，可以看出，虽然将输出信号f1、f2以及f3声明为寄存器变量，并且在always模块中进行赋值操作，但在组合逻辑设计中，并没有综合成D触发器。 上述程序在ISESimulator中的仿真结果如图8-4所示，只要敏感信号电平发生变化，always语句块中所有语句都会被重新执行一次。 （2）assign语句描述的电路 利用条件符“?”可以描述一些相对简单的组合逻辑电路，信号只能被定义为wire型。当组合逻辑比较复杂时，需要很多条assign语句或者多重嵌套“?”，使得代码可读性极差，因此此时推荐第一种组合逻辑建模方式。下面给出一个由assign关键字描述的组合逻辑实例。 【例8-2】通过assign语句实现例8-1的比较器。 在ISE中查看其综合后的RTL级结构示意图，可以发现和图8-3一样，其仿真结果也和例8-1的一致。 3．组合逻辑电路的注意事项 （1）敏感信号列表 在组合逻辑设计中，读者必须重点对待敏感信号列表。敏感信号列表出现在always块中，其典型行为级的含义为：只要敏感信号列表内的信号发生电平变化，则always模块中的语句就执行一次，因此设计人员必须将所有的输入信号和条件判断信号都列在信号列表中。有时， 不完整的信号列表会造成不同的仿真和综合结果，因此需要保证敏感信号的完备性。在实际的PLD 器件开发中，EDA工具都会默认将所有的输入信号和条件判断语句作为触发信号，增减敏感信号列表中的信号不会对最终的执行结果产生影响，因此读者如果期望在设计中通过修改敏感信号来得到不同的逻辑，那就大错特错了。当敏感信号不完备时，会使得仿真结果不一样，这是因为仿真器在工作时不会自动补充敏感信号表。如果缺少信号，则无法触发和该信号相关的仿真进程，也就得不到正确的仿真结果。 因此，为了确保仿真和最终实现结果一致，必须要保证组合逻辑电路always敏感信号列表的完备性。如果设计人员在设计中，认为列举信号麻烦，则采用下面的语句。 此时，综合工具和仿真工具会自动将所有的敏感信号自动加入敏感信号列表。ISE 也支持这一用法。 （2）不要在组合逻辑中引入环路 在组合逻辑中引入环路会导致电路产生振荡、毛刺以及冲突等问题，从而降低设计的稳定性和可靠性，因此要彻底避免环路。 图8-5给出一个简单的环路设计，把一个寄存器输出通过组合逻辑后，再次通过两级组合逻辑处理反馈给该组合逻辑的引脚时，就会产生组合环路，要避免该组合环路，可以采用图8-6所示的逻辑设计示意图，不仅功能结构一致，还取消了组合逻辑环路。 之所以称逻辑环路是一种高风险设计，其原因如下： 首先，环回逻辑的延时完全依靠组合逻辑门延迟和布线延迟。一旦这些传播时延有所变化，则环路的整体逻辑将彻底失效。 其次，环路的时序分析是个死循环过程。目前的EDA开发工具为了计算环路的时序逻辑都会主动割断时序路径，引入许多不确定的因素。 目前的综合工具都会给出逻辑环路的警告（CombinationalLoops），因此设计人员必须对软件工具的此类报告特别在意。如果一定要实现环路，则需要通过时序逻辑的寄存器来完成。 8.1.2 时序逻辑设计 1．时序逻辑电路的基本知识 时序逻辑是Verilog HDL设计中另一类重要应用。从电路特征上看来，其特点为任意时刻的输出不仅取决于该时刻的输入，而且还和电路原来的状态有关。电路里面有存储元件（各类触发器，在FPGA芯片结构中只有D 触发器）用于记忆信息，如图8-7所示。从电路行为上讲，不管输入如何变化，仅当时钟的沿（上升沿或下降沿）到达时，才有可能使输出发生变化。 从图8-7 可以看出，时序逻辑电路由组合逻辑电路和存储电路这两部分组成，其中存储电路由各类触发器（JK 触发器、D 触发器以及T触发器等类型）构成，并将组合逻辑的部分输出反馈到输入逻辑的输入端口。 时序电路可通过表达式（电路输出端的输出逻辑表达式、存储电路触发器输出端的驱动或激励表达式，以及表示触发器状态的状态方程）、状态转移表、状态转移图、时序图以及HDL行为描述语言等来描述。若将输入变量和各级触发器状态的全部组合列出，分别代入各级触发器的状态方程和电路的输出方程，则可以计算出各级触发器的次态值和当前输出值，把相应的计算结果列成真值表就可得到状态转移表。对于读者最关心的HDL行为描述代码，可在时序图的基础上快速得到。 分析一个时序电路，就是要找出给定时序电路的逻辑功能。具体地说，就是要求找出电路的状态和输出状态（一般指进位输出、借位输出等）在输入变量和时钟信号作用下的变化规律。为了直观地说明上述方法，下面给出一个简单的时序逻辑电路，通过分析得到其常用的描述形式。 【例8-3】完成图8-8 所示的简单时序逻辑电路的分析。 （1）首先，列出输出方程、驱动方程，即 由于电路采用T 型触发器，因此其特征方程为： 将驱动方程代入特征方程，可以得到式（8-4）所示的状态方程。 （2）计算并列出状态转移表 图示电路有一个输入X和1级触发器，因此输入与触发器初态的取值组合只有4组，即00、01、10和11。把这些取值带入式（8-4）和式（8-1），可计算出触发器的次态和电路的输出值，其相应的状态转移表如表8-1所列。 （3）画出状态转移图和时序图 状态转移图直观、形象地显示出了时序逻辑电路的特点和逻辑功能，本例的状态转移图如图8-9所示。其中，圆圈内的数字表示电路的状态，箭头表示状态转换的方向，箭头旁注明了状态转换的输入条件和输出结果，输入条件位为斜线上方，而输出结果位于斜线下方。 时序图就是通过数字信号波形直观表示时序逻辑电路的特点和逻辑功能，可根据状态方程、状态转移表等多方面得到，用于判断设计结果的正确性。图8-10（a）、（b）分别给出了触发器初始状态为0和1的时序图。 从图8-10中可以看出以下两点：首先，时序电路的输出信号不仅取决于电路当时的输入，还取决于电路原来的状态，体现了“记忆”特性。其次，在同步时序逻辑电路中，触发器由时钟信号CP来触发，控制其翻转时刻，而对触发器翻转到何种状态并无影响。 2．时序逻辑的Verilog HDL描述 时序电路的行为决定了其只能通过always块语句实现，通过关键词“posedge”和“negedge”来捕获时钟信号的上升沿和下降沿。在always语句块中可以使用任何可综合的标志符。下面首先以D触发器为例，给出基本单元触发器的VerilogHDL实例，读者可自行完成其余常用触发器（RS触发器、JK触发器以及T触发器等）的Verilog HDL实现。 【例8-4】通过Verilog HDL实现D触发器。 同步D触发器的功能为：输入D只能在时序信号clk的沿变化时才能被写入到存储器中，替换以前的值，常用于数据延迟以及数据存储模块中。由于D触发器只有一个输入端，在许多情况下，可使触发器之间的连接变得非常简单，因此使用十分广泛。 上述程序在ISE中综合后的RTL级结构图如图8-11所示。 上述程序的仿真结果如图8-12所示。从中可以看出，在时钟上升沿，D触发器都将输入数据接收并寄存。 在给出时序逻辑设计最基本的电路后，下面给出图8-8所示电路的Verilog HDL实现，和例8-3的描述方法进行比较。 【例8-5】通过Verilog HDL语言实现例8-3所示电路。 程序在ISE综合后的RTL级结构图如图8-13所示，可以看出，其和图8-8是一致的，达到了设计的目的。 上述程序的仿真结果如图8-14所示，验证了程序的正确性。 在利用Verilog HDL描述时序电路时有以下几个问题需要注意。 （1）在描述时序电路的always块中的reg型信号都会被综合成寄存器，这是和组合逻辑电路所不同的。 （2）时序逻辑中推荐使用非阻塞赋值“&lt;=”，原因将在8." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/ee39552bfdb38429756f5fe2750fe677/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-07-02T09:54:53+08:00" />
<meta property="article:modified_time" content="2017-07-02T09:54:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Verilog组合逻辑和时序逻辑的比较</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    VerilogHDL语言分为面向综合和面向仿真两大类语句，且可综合语句远少于仿真语句，读者可能会有可综合设计相对简单的感觉。然而事实刚好与此相反，这是因为：首先，可综合设计是用来构建硬件平台的，因此对设计的指标要求很高，包括资源、频率和功耗，这都需要通过代码来体现；其次，在实际开发中要利用基本VerilogHDL语句完成种类繁多的硬件开发，给设计人员带来了很大的挑战。所有的仿真语句只是为了可综合设计的验证而存在。为了让读者深入地理解可综合设计、灵活运用已学内容，本章将可综合设计中的基本知识点和难点提取出来，融入VerilogHDL语法以及开发工具等诸多方面，以深入浅出的方式向读者说明设计中的难点本质。 
<br> 
<br> 8.1 组合逻辑和时序逻辑 
<br> 数字电路根据逻辑功能的不同特点，可以分成两大类，一类叫组合逻辑电路（简称组合电路），另一类叫做时序逻辑电路（简称时序电路）。掌握组合逻辑和时序逻辑的区分手段与实现方法是数字系统设计的基本要求。 
<br> 8.1.1 组合逻辑设计 
<br> 1．组合逻辑概念 
<br> 组合逻辑是VerilogHDL设计中的一个重要组成部分。从电路本质上讲，组合逻辑电路的特点是输出信号只是当前时刻输入信号的函数，与其他时刻的输入状态无关。无存储电路，也没有反馈电路，其典型结构如图8-1所示。从电路行为上看，其特征就是输出信号的变化仅仅与输入信号的电平有关，不涉及对信号跳变沿的处理。 
<br> 
<br> 
<br> 
<br> 尽管组合电路在功能上千差万别，可是其分析方法却有很多相似之处。给定逻辑电路后，得到其输入与输出的直接表达式，将输入组合全部带入表达式中计算得到输出结果，并以真值表的形式表达出来，最后根据真值表说明电路功能。 
<br> 组合逻辑电路的设计就是在给定逻辑功能的前提下，通过某种设计渠道，得到满足功能要求且最简单的逻辑电路。基于HDL 语言和EDA工具的组合逻辑电路的设计流程如图8-2 所示。 
<br> 
<br> 
<br> 
<br> 其中逻辑抽象和HDL编程是重点环节。在很多情况下，逻辑问题都是通过文字描述的，逻辑抽象就是对设计对象的输入与输出信号间的因果关系，用逻辑函数的方法表示出来。HDL语言编程就是直接通过语句来实现抽象结果。 
<br> 2．组合逻辑的Verilog HDL 描述 
<br> 根据组合逻辑的电路行为，可以得到两种常用的RTL 级描述方式。第一种是always模块的触发事件为电平敏感信号列表；第二种就是用assign 关键字描述的数据流赋值语句。 
<br> （1）always 模块的敏感表为电平敏感信号的电路 
<br> 这种方式的组合电路应用非常广泛，几乎可以完成对所有组合逻辑电路的建模。always模块的敏感列表为所有判断条件信号和输入信号，但一定要注意敏感列表的完整性。在always模块中可以使用if、case 和for 等各种RTL关键字结构。由于赋值语句有阻塞赋值和非阻塞赋值两类，建议读者使用阻塞赋值语句“=”，详细原因将在8.3.1 节进行说明。 
<br> always 模块中的信号必须定义为reg 型，不过最终的实现结果中并没有寄存器。这是由于在组合逻辑电路描述中，将信号定义为reg型，只是为了满足语法要求。下面给出一个组合逻辑实例。 
<br> 【例8-1】通过Verilog HDL 语言实现一个2 输入比较器，输入分别为d1、d2，输出分别为f1（d1&gt;d2时为高电平）、f2（d1 = d2 时为高电平）、f3（d1 
<br> 
<br> 
<br> 
<br> 可以看出，组合逻辑就对应着电平触发事件电路。上述程序在ISE中综合后的RTL级结构图如图8-3所示，可以看出，虽然将输出信号f1、f2以及f3声明为寄存器变量，并且在always模块中进行赋值操作，但在组合逻辑设计中，并没有综合成D触发器。 
<br> 
<br> 
<br> 
<br> 上述程序在ISESimulator中的仿真结果如图8-4所示，只要敏感信号电平发生变化，always语句块中所有语句都会被重新执行一次。 
<br> （2）assign语句描述的电路 
<br> 利用条件符“?”可以描述一些相对简单的组合逻辑电路，信号只能被定义为wire型。当组合逻辑比较复杂时，需要很多条assign语句或者多重嵌套“?”，使得代码可读性极差，因此此时推荐第一种组合逻辑建模方式。下面给出一个由assign关键字描述的组合逻辑实例。 
<br> 
<br> 
<br> 
<br> 【例8-2】通过assign语句实现例8-1的比较器。 
<br> 
<br> 
<br> 
<br> 在ISE中查看其综合后的RTL级结构示意图，可以发现和图8-3一样，其仿真结果也和例8-1的一致。 
<br> 3．组合逻辑电路的注意事项 
<br> （1）敏感信号列表 
<br> 在组合逻辑设计中，读者必须重点对待敏感信号列表。敏感信号列表出现在always块中，其典型行为级的含义为：只要敏感信号列表内的信号发生电平变化，则always模块中的语句就执行一次，因此设计人员必须将所有的输入信号和条件判断信号都列在信号列表中。有时， 
<br> 不完整的信号列表会造成不同的仿真和综合结果，因此需要保证敏感信号的完备性。在实际的PLD 器件开发中，EDA工具都会默认将所有的输入信号和条件判断语句作为触发信号，增减敏感信号列表中的信号不会对最终的执行结果产生影响，因此读者如果期望在设计中通过修改敏感信号来得到不同的逻辑，那就大错特错了。当敏感信号不完备时，会使得仿真结果不一样，这是因为仿真器在工作时不会自动补充敏感信号表。如果缺少信号，则无法触发和该信号相关的仿真进程，也就得不到正确的仿真结果。 
<br> 因此，为了确保仿真和最终实现结果一致，必须要保证组合逻辑电路always敏感信号列表的完备性。如果设计人员在设计中，认为列举信号麻烦，则采用下面的语句。 
<br> 
<br> 
<br> 
<br> 此时，综合工具和仿真工具会自动将所有的敏感信号自动加入敏感信号列表。ISE 也支持这一用法。 
<br> （2）不要在组合逻辑中引入环路 
<br> 在组合逻辑中引入环路会导致电路产生振荡、毛刺以及冲突等问题，从而降低设计的稳定性和可靠性，因此要彻底避免环路。 
<br> 
<br> 
<br> 
<br> 图8-5给出一个简单的环路设计，把一个寄存器输出通过组合逻辑后，再次通过两级组合逻辑处理反馈给该组合逻辑的引脚时，就会产生组合环路，要避免该组合环路，可以采用图8-6所示的逻辑设计示意图，不仅功能结构一致，还取消了组合逻辑环路。 
<br> 
<br> 
<br> 
<br> 之所以称逻辑环路是一种高风险设计，其原因如下： 
<br> 首先，环回逻辑的延时完全依靠组合逻辑门延迟和布线延迟。一旦这些传播时延有所变化，则环路的整体逻辑将彻底失效。 
<br> 其次，环路的时序分析是个死循环过程。目前的EDA开发工具为了计算环路的时序逻辑都会主动割断时序路径，引入许多不确定的因素。 
<br> 目前的综合工具都会给出逻辑环路的警告（CombinationalLoops），因此设计人员必须对软件工具的此类报告特别在意。如果一定要实现环路，则需要通过时序逻辑的寄存器来完成。 
<br> 
<br> 8.1.2 时序逻辑设计 
<br> 1．时序逻辑电路的基本知识 
<br> 时序逻辑是Verilog HDL设计中另一类重要应用。从电路特征上看来，其特点为任意时刻的输出不仅取决于该时刻的输入，而且还和电路原来的状态有关。电路里面有存储元件（各类触发器，在FPGA芯片结构中只有D 触发器）用于记忆信息，如图8-7所示。从电路行为上讲，不管输入如何变化，仅当时钟的沿（上升沿或下降沿）到达时，才有可能使输出发生变化。 
<br> 从图8-7 可以看出，时序逻辑电路由组合逻辑电路和存储电路这两部分组成，其中存储电路由各类触发器（JK 触发器、D 触发器以及T触发器等类型）构成，并将组合逻辑的部分输出反馈到输入逻辑的输入端口。 
<br> 时序电路可通过表达式（电路输出端的输出逻辑表达式、存储电路触发器输出端的驱动或激励表达式，以及表示触发器状态的状态方程）、状态转移表、状态转移图、时序图以及HDL行为描述语言等来描述。若将输入变量和各级触发器状态的全部组合列出，分别代入各级触发器的状态方程和电路的输出方程，则可以计算出各级触发器的次态值和当前输出值，把相应的计算结果列成真值表就可得到状态转移表。对于读者最关心的HDL行为描述代码，可在时序图的基础上快速得到。 
<br> 分析一个时序电路，就是要找出给定时序电路的逻辑功能。具体地说，就是要求找出电路的状态和输出状态（一般指进位输出、借位输出等）在输入变量和时钟信号作用下的变化规律。为了直观地说明上述方法，下面给出一个简单的时序逻辑电路，通过分析得到其常用的描述形式。 
<br> 【例8-3】完成图8-8 所示的简单时序逻辑电路的分析。 
<br> 
<br> 
<br> 
<br> （1）首先，列出输出方程、驱动方程，即 
<br> 
<br> 
<br> 
<br> 由于电路采用T 型触发器，因此其特征方程为： 
<br> 
<br> 
<br> 
<br> 将驱动方程代入特征方程，可以得到式（8-4）所示的状态方程。 
<br> 
<br> 
<br> 
<br> （2）计算并列出状态转移表 
<br> 图示电路有一个输入X和1级触发器，因此输入与触发器初态的取值组合只有4组，即00、01、10和11。把这些取值带入式（8-4）和式（8-1），可计算出触发器的次态和电路的输出值，其相应的状态转移表如表8-1所列。 
<br> 
<br> 
<br> 
<br> （3）画出状态转移图和时序图 
<br> 状态转移图直观、形象地显示出了时序逻辑电路的特点和逻辑功能，本例的状态转移图如图8-9所示。其中，圆圈内的数字表示电路的状态，箭头表示状态转换的方向，箭头旁注明了状态转换的输入条件和输出结果，输入条件位为斜线上方，而输出结果位于斜线下方。 
<br> 
<br> 
<br> 
<br> 时序图就是通过数字信号波形直观表示时序逻辑电路的特点和逻辑功能，可根据状态方程、状态转移表等多方面得到，用于判断设计结果的正确性。图8-10（a）、（b）分别给出了触发器初始状态为0和1的时序图。 
<br> 
<br> 
<br> 
<br> 从图8-10中可以看出以下两点：首先，时序电路的输出信号不仅取决于电路当时的输入，还取决于电路原来的状态，体现了“记忆”特性。其次，在同步时序逻辑电路中，触发器由时钟信号CP来触发，控制其翻转时刻，而对触发器翻转到何种状态并无影响。 
<br> 2．时序逻辑的Verilog HDL描述 
<br> 时序电路的行为决定了其只能通过always块语句实现，通过关键词“posedge”和“negedge”来捕获时钟信号的上升沿和下降沿。在always语句块中可以使用任何可综合的标志符。下面首先以D触发器为例，给出基本单元触发器的VerilogHDL实例，读者可自行完成其余常用触发器（RS触发器、JK触发器以及T触发器等）的Verilog HDL实现。 
<br> 【例8-4】通过Verilog HDL实现D触发器。 
<br> 同步D触发器的功能为：输入D只能在时序信号clk的沿变化时才能被写入到存储器中，替换以前的值，常用于数据延迟以及数据存储模块中。由于D触发器只有一个输入端，在许多情况下，可使触发器之间的连接变得非常简单，因此使用十分广泛。 
<br> 
<br> 
<br> 
<br> 上述程序在ISE中综合后的RTL级结构图如图8-11所示。 
<br> 上述程序的仿真结果如图8-12所示。从中可以看出，在时钟上升沿，D触发器都将输入数据接收并寄存。 
<br> 
<br> 
<br> 
<br> 在给出时序逻辑设计最基本的电路后，下面给出图8-8所示电路的Verilog HDL实现，和例8-3的描述方法进行比较。 
<br> 【例8-5】通过Verilog HDL语言实现例8-3所示电路。 
<br> 
<br> 
<br> 
<br> 程序在ISE综合后的RTL级结构图如图8-13所示，可以看出，其和图8-8是一致的，达到了设计的目的。 
<br> 
<br> 
<br> 
<br> 上述程序的仿真结果如图8-14所示，验证了程序的正确性。 
<br> 
<br> 
<br> 
<br> 在利用Verilog HDL描述时序电路时有以下几个问题需要注意。 
<br> （1）在描述时序电路的always块中的reg型信号都会被综合成寄存器，这是和组合逻辑电路所不同的。 
<br> （2）时序逻辑中推荐使用非阻塞赋值“&lt;=”，原因将在8.3节详细说明。 
<br> （3）时序逻辑的敏感信号列表只需要加入所用的时钟触发沿即可，其余所有的输入和条件判断信号都不用加入，这是因为时序逻辑是通过时钟信号的跳变沿来控制的。 
<br> 
<br> 8.1.3 组合逻辑电路中的竞争与冒险 
<br> 1．什么是竞争与冒险 
<br> 信号在组合逻辑电路内部通过连线和逻辑单元时，都有一定的延时。延时的大小与连线的长短和逻辑单元的数目有关，同时还受器件的制造工艺、工作电压、温度等条件的影响。此外，信号的高低电平转换也需要一定的过渡时间。由于存在这两方面因素，多路信号的电平值发生变化时，在信号变化的瞬间，组合逻辑的输出有先后顺序，并不是同时变化，往往会出现一些不正确的尖峰信号，这些尖峰信号称为“毛刺”，如图8-15所示。如果一个组合逻辑电路中有“毛刺”出现，就说明该电路存在“冒险”。 
<br> 需要注意的是，冒险信号的脉冲宽度很小，常常只有数纳秒或数十纳秒，其频带带宽可达数百兆赫兹或更宽。在板级调试时，如果示波器的上限频率较低，会将幅度较大的毛刺显示为幅度较小的毛刺，甚至不易被察觉。这都是在实际开发中捕获毛刺应该注意的问题。 
<br> 冒险按产生形式的不同可以分为静态冒险和动态冒险两大类。静态冒险是指输入有变化，而输出不应变化时产生的单个窄脉冲；动态冒险则指的是输入变化时，输出也应变化时产生的冒险。参考文献[4]指出，动态冒险是由静态冒险引起的，因此存在动态冒险的电路也存在静态冒险。 
<br> 静态冒险根据产生条件的不同，分为功能冒险和逻辑冒险两大类。当有两个或两个以上输入信号同时产生变化时，在输出端产生毛刺，这种冒险称为功能冒险。如果只有一个变量产生变化时出现的冒险则是逻辑冒险。 
<br> 冒险往往会影响到逻辑电路的稳定性。清零和置位端口对毛刺信号十分敏感，任何一点毛刺都可能会使系统出错，因此判断逻辑电路中是否存在冒险以及如何避免冒险是设计人员必须要考虑的问题。 
<br> 
<br> 
<br> 
<br> 2．冒险产生的原因 
<br> 由于动态冒险主要是由静态冒险引起的，消除了静态冒险，动态冒险也就自然消除了，因此下面介绍静态冒险的检查和消除。 
<br> 判断一个逻辑电路在某些输入信号发生变化时是否会产生冒险，首先要判断信号是否会同时变化，然后判断在信号同时变化的时候，是否会产生冒险，这可以通过逻辑函数的卡诺图或逻辑函数表达式来进行判断。 
<br> （1）功能冒险的检查 
<br> 功能冒险是由电路的逻辑功能引起的，只要输入信号不是按照循环码的规律变化，组合逻辑就可能产生功能冒险，且不能通过修改设计加以消除，只能通过对输出采用时钟采样来消除。 
<br> （2）逻辑冒险的检查 
<br> 检查电路是否产生逻辑冒险的方法有两种，即代数法和卡诺图法。 
<br> ① 代数法。如果一个组合逻辑函数表达式F，在某些条件下能化简成或的形式，在A产生变化时，就可能产生静态逻辑冒险。 
<br> ② 卡诺图法。在组合逻辑的卡诺图中，若存在素项圈相切，则可能会产生逻辑冒险。如图8-16 所示的卡诺图，AC 和两个素项环相切，在B= C =1时，A 由1 变为0时，将产生逻辑冒险。 
<br> 3．竞争与冒险在Verilog HDL 设计中的体现 
<br> 【例8-6】详细分析Verilog HDL 程序内在的逻辑冒险现象。 
<br> 首先，给出一段示例代码。 
<br> 
<br> 
<br> 
<br> 程序在ISE中综合后的RTL级结构图如图8-17所示。 
<br> 
<br> 
<br> 
<br> 上述程序在ISESimulator中的仿真结果如图8-18所示。从图8-18所示的仿真波形可以看出，由于“A、B、C、D”4个输入信号高低电平变换不是同时发生的，这导致输出信号“Out”出现了毛刺。由于无法保证所有连线的长度一致，所以即使4个输入信号在输入端同时变化，但经过可编程逻辑器件内部的走线，到达或门的时间也是不一样的，毛刺必然产生。简单地说，只要输入信号同时变化，组合逻辑必将产生毛刺。将它们的输出直接连接到时钟输入端、清零或置位端口的设计方法是错误的，这可能会导致严重的后果。所以必须检查设计中所有时钟、清零和置位等对毛刺敏感的输入端口，确保输入不会含有任何毛刺。 
<br> 
<br> 
<br> 
<br> 4．毛刺的消除 
<br> 毛刺并不是对所有的输入都有危害，例如D触发器的D输入端，只要毛刺不出现在时钟的上升沿并且不满足数据的建立和保持时间，就不会对系统造成危害，我们可以说D触发器的D输入端对毛刺不敏感。根据这个特性，应当在系统中尽可能采用同步电路，这是因为同步电路信号的变化都发生在时钟沿，只要毛刺不出现在时钟的沿口并且不满足数据的建立和保持时间，就不会对系统造成危害（由于毛刺很短，多为几纳秒，基本上都不可能满足数据的建立和保持时间）。 
<br> 因此可以通过改变设计，破坏毛刺产生的条件，来减少毛刺的发生。例如，在数字电路设计中，常常采用格雷码计数器取代普通的二进制计数器，这是因为格雷码计数器的输出每次只有一位跳变，消除了竞争冒险的发生条件，避免了毛刺的产生。目前，主要有两种基本的采样方法，即脉冲选择法和时序逻辑保持法。 
<br> （1）脉冲选择法 
<br> 该方法在输出信号的保持时间内，用一定宽度的高电平脉冲与输出信号做逻辑“与”运算，由此获取输出信号的电平值。例8-7说明了这种方法，采样脉冲信号从输入引脚“Sample”引入。 
<br> 【例8-7】通过脉冲选择法修改例8-6电路中的毛刺。 
<br> 
<br> 
<br> 
<br> 程序的综合结果如图8-19所示，其中“Tout_bmp”模块封装了除脉冲选择以外的全部电路，脉冲选择通过与门来实现。 
<br> 程序的仿真结果如图8-20所示，从其仿真波形上可以看出，毛刺信号出现在“Tout”引脚上，而“Out”引脚上的毛刺已被消除了。 
<br> 
<br> 
<br> 
<br> 以上方法可以大大减少毛刺，但它并不能完全消除毛刺，有时，必须手工修改电路来去除毛刺。通常使用“采样”的方法。一般说来，冒险出现在信号发生电平转换的时刻，也就是说在输出信号的建立时间内会发生冒险，而在输出信号的保持时间内是不会有毛刺信号出现的。如果在输出信号的保持时间内对其进行“采样”，就可以消除毛刺信号的影响。 
<br> （2）时序逻辑保持法 
<br> 脉冲选择法最大的缺点是必须人为地保证sample信号在合适的时间产生，另一种更常见的方法即为时序逻辑保持法，其利用D触发器的D输入端对毛刺信号不敏感的特点，在输出信号的保持时间内，用触发器读取组合逻辑的输出信号，这种方法类似于将异步电路转化为同步电路。下面给出一个应用实例。 
<br> 【例8-8】通过D触发器来消除例8-6所示电路的冒险现象。 
<br> 
<br> 
<br> 
<br> 上述程序综合后的RTL级结构图如图8-21所示，同样其中“Tout_bmp”模块封装了除脉冲选择以外的全部电路，时序逻辑保持通过D触发器来实现。 
<br> 程序的仿真结果如图8-22所示，从其仿真波形上可以看出，毛刺信号出现在“Tout”引脚上，而“Out”引脚上的毛刺已被消除了，无需外部输入采样控制信号。 
<br> 
<br> 
<br> 
<br> 8.1.4 时序逻辑的时钟选择策略 
<br> 从8.1.2节可知，时钟对于时序逻辑是至关重要的，时钟的任何一个随机的抖动都会导致电路重新执行一次，使得逻辑时序发生错误跳转，因此时钟的质量对时序逻辑是至关重要的。设计时序电路的第一步就是选择性能优良的时钟信号。 
<br> 1．Xilinx FPGA时钟资源说明 
<br> 全局时钟和第二全局时钟资源是FPGA芯片的重要资源之一，合理地利用该资源可以改善设计的综合和实现效果；如果使用不当，不但会影响设计的工作频率和稳定性等，甚至会导致设计的综合、实现过程出错。 
<br> （1）全局时钟 
<br> 在Xilinx系列FPGA产品中，全局时钟网络是一种全局布线资源，它可以保证时钟信号到达各个目标逻辑单元的时延基本相同。其时钟分配树结构如图8-23所示。 
<br> 
<br> 
<br> 
<br> 针对不同类型的器件，Xilinx公司提供的全局时钟网络在数量、性能等方面略有区别。但一般以全铜工艺实现，差分全局时钟控制技术将歪斜与抖动降至最低；再加上专用时钟缓冲与驱动结构，从而可使全局时钟到达芯片内部所有的逻辑可配置单元，且I/O单元以及块RAM的时延和抖动最小，以满足高速同步电路对时钟触发沿的苛刻需求。 
<br> 在FPGA设计中，FPGA全局时钟路径需要专用的时钟缓冲和驱动，具有最小偏移和最大扇出能力，因此最好的时钟方案是由专用的全局时钟输入引脚驱动的单个主时钟，去控制设计项目中的每一个触发器。只要可能就应尽量在设计项目中采用全局时钟，因为对于一个设计项目来说，全局时钟是最简单和最可预测的时钟。 
<br> （2）第二全局时钟 
<br> 第二全局时钟属于长线资源，分布于芯片内部的行、列栅栏（Bank）上，其长度和驱动能力仅次于全局时钟资源，也可驱动芯片内部任何一个逻辑资源，其抖动和时延指标仅次于全局时钟信号。在设计中，一般将高频率、高扇出的时钟使能信号以及高速路径上的关键信号指定为全局第二时钟信号。需要注意的是，第二全局时钟资源和全局时钟资源的区别：使用全局时钟资源并不占用逻辑资源，也不会影响其他布线资源；而第二全局时钟资源占用的是芯片内部的资源，需要占用部分逻辑资源，各个部分的布线会相互影响，因此建议在逻辑设计占用资源不超过芯片资源70%时使用。2．全局时钟的使用 
<br> XilinxFPGA中的全局时钟采用全铜工艺实现，并设计了专用时钟缓冲与驱动结构，可到达芯片内部任何一个逻辑单元，包括可配置逻辑单元（CLB）、I/O管脚、内嵌的块RAM以及硬核乘法器等模块，且时延和抖动都最小。因此，对于FPGA设计而言，全局时钟是最简单和最可预测的时钟。最好的时钟方案就是：由专用的全局时钟输入引脚驱动单个全局时钟，并用后者去控制设计中的每一个触发器，如图8-24所示。 
<br> 
<br> 
<br> 
<br> 目前的主流芯片都集成了专用时钟资源与数字延迟锁相环，且数目众多。如面向中低端应用的Spartan3E系列FPGA，最多可提供16个全局时钟输入端口和8个数字时钟管理模块（DCM）；面向高端的Virtex4/5系列芯片，可以提供多达数十个全局时钟输入端口和DCM模块。全局时钟主要有以下两种组合。 
<br> （1）IBUFG/ IBUFGDS +BUFG的方法 
<br> IBUFG后面连接BUFG的方法是最基本的全局时钟资源使用方法，由于IBUFG组合BUFG相当于BUFGP，因此这种使用方法也称为BUFGP方法。其相应的语法格式如下： 
<br> IBUFG CLKIN_IBUFG_INST (.I(CLKIN_IN), 
<br> .O(CLKIN_IBUFG)); 
<br> 调用BUFG原语，将CLKIN_IBUFGDS转成最终输出，其典型使用方法如下： 
<br> BUFG CLK_BUFG_INST (.I(CLKIN_IBUFGDS), 
<br> .O(CLK_OUT)); 
<br> 当输入时钟信号为差分信号时，需要使用IBUFGDS代替IBUFG，相应的语法格式如下： 
<br> //调用IBUFGDS原语，将差分时钟转换成单端输出CLKIN_IBUFGDS 
<br> IBUFGDS CLKIN_IBUFGDS_INST (.I(CLKIN_P_IN), 
<br> .IB(CLKIN_N_IN), 
<br> .O(CLKIN_IBUFGDS)); 
<br> //调用BUFG原语，将CLKIN_IBUFGDS转成最终输出 
<br> BUFG CLK_BUFG_INST (.I(CLKIN_IBUFGDS), 
<br> .O(CLK_OUT)); 
<br> //示例结束 
<br> 需要注意的是，当信号从全局时钟管脚输入，不论其是否为时钟信号，都必须使用IBUFG或IBUFGDS；反之，如果对信号使用了IBUFG或IBUFGDS硬件原语，则该信号一定要从全局时钟管脚输入，否则在布局布线时会报错。IBUFG和IBUFGDS的输入端仅仅与芯片的专用全局时钟输入管脚有物理连接，与普通IO和其他内部CLB等没有物理连接。 
<br> （2）LOGIC+BUFG的方法 
<br> BUFG不但可以驱动IBUFG的输出，还可以驱动其他普通信号的输出。当某个信号（时钟、使能、快速路径）的扇出非常大，并且要求抖动延迟最小时，可以使用BUFG驱动该信号，使该信号利用全局时钟资源。但需要注意的是，普通IO的输入或普通片内信号进入全局时钟布线层需要一个固有的延时，一般在10ns左右，即普通IO和普通片内信号从输入到BUFG输出有一个约10ns左右的固有延时，但是BUFG的输出到片内所有单元（IOB、CLB、选择性块RAM）的延时可以忽略不计，认为其为“0”ns[5]。 
<br> 相应的调用语法如下： 
<br> //调用BUFG原语，将内部输入CLK_IN转成最终输出CLK_OUT 
<br> BUFG CLK_BUFG_INST (.I(CLK_IN), 
<br> .O(CLK_OUT)); 
<br> //示例结束 
<br> 在软件代码中，可通过调用原语IBUFGP来使用全局时钟。IBUFGP的基本用法如下： 
<br> IBUFGP U1(.I(clk_in), .O(clk_out)); 
<br> 全局时钟网络对FPGA设计性能的影响很大，所以建议设计中的主时钟全部走全局时钟网络。 
<br> 3．第二全局时钟的使用 
<br> 第二全局时钟信号的驱动能力和时钟抖动延迟等指标仅次于全局时钟信号。Xilinx的FPGA中一般有比较丰富的第二全局时钟资源（很多器件有24个第二全局时钟资源），以满足高速、复杂时序逻辑设计的需要。在设计中，一般将频率较高，扇出数目较多的时钟、使能、高速路径信号指定为第二全局时钟信号[5]。 
<br> 第二全局时钟资源的使用方法比较简单，可通过在约束编辑器的专用约束（Misc）选项卡中，指定所选信号使用低抖动延迟资源“LowSkew”来制定。但最直接的方法是直接在指导Xilinx实现步骤的用户约束文件（UCF）中添加“USELOWSKEWLINES”约束命令。在约束编辑器中的操作等效于在用户约束文件中添加如下内容。 
<br> NET "s1" USELOWSKEWLINES; 
<br> NET "s2" USELOWSKEWLINES; 
<br> NET "s3" USELOWSKEWLINES;
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a6ed86bda506c3cea5ca7620e1ef6706/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;判断一个序列是否为堆（最大堆、最小堆）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ecc09bbc95cf3d0759c14abaef5caac1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">android中自定义画布Canvas的实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>