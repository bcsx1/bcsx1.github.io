<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Erlang语法知识点学习总结 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Erlang语法知识点学习总结" />
<meta property="og:description" content="1、退出,输入 haut().
2、-module
3、module_name:function_name( arguments ) 例如调用tut:double(10),说明调用tut模块的double函数。
4、模块名为tut
-module(tut).
-export( [double/1, fact/1] ).
double(X)-&gt;
2 * X.
fact(1) -&gt;
1; fact(N) -&gt;
N*fact(N-1).
分号表示函数还未结束。
点号表示函数已经结束。
变量必须以大写字母开头，小写开头的为字符串。
5、元组
可以返回多个值
-module(tut).
-export( [double/1] ).
double(X) -&gt;
{X*2, X*3, X*4}.
6、
列表赋值
10&gt; [One,Two|Rest]=[1,2,3,4,5,6].
[1,2,3,4,5,6]
11&gt; One.
1
12&gt; Two.
2
13&gt; Rest.
[3,4,5,6]
14&gt;
获取列表的长度
-module(tut).
-export( [get_length/1] ).
get_length([] ) -&gt;
0;
get_length([First|Rest]) -&gt;
1&#43;get_length(Rest).
字符串输出采用ASCII表示
&gt;[97,98,99].
&#34;abc&#34;
7、百分号表示注释
8、格式化输出" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/f7504a338be312cb95caf9d1c7a972e0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-30T14:52:58+08:00" />
<meta property="article:modified_time" content="2018-07-30T14:52:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Erlang语法知识点学习总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1、退出,输入 haut().<br> 2、-module<br> 3、module_name:function_name( arguments ) <br>    例如调用tut:double(10),说明调用tut模块的double函数。</p> 
<p>4、模块名为tut<br> -module(tut).<br> -export( [double/1, fact/1] ).<br> double(X)-&gt;<br>     2 * X.<br> fact(1) -&gt;<br>     1;      <br> fact(N) -&gt;<br>     N*fact(N-1).</p> 
<p>分号表示函数还未结束。<br> 点号表示函数已经结束。<br> 变量必须以大写字母开头，小写开头的为字符串。</p> 
<p><br> 5、元组</p> 
<p>可以返回多个值<br> -module(tut).<br> -export( [double/1] ).<br> double(X) -&gt;<br>   {X*2, X*3, X*4}.<br>     <br> 6、<br> 列表赋值<br> 10&gt; [One,Two|Rest]=[1,2,3,4,5,6].<br> [1,2,3,4,5,6]<br> 11&gt; One.<br> 1<br> 12&gt; Two.<br> 2<br> 13&gt; Rest.<br> [3,4,5,6]<br> 14&gt;</p> 
<p>获取列表的长度<br> -module(tut).<br> -export( [get_length/1] ).<br> get_length([] ) -&gt;<br>     0;<br> get_length([First|Rest]) -&gt;<br>     1+get_length(Rest).</p> 
<p>字符串输出采用ASCII表示<br> &gt;[97,98,99].<br> "abc"</p> 
<p>7、百分号表示注释<br> 8、格式化输出<br> 标准函数io:format<br> io:format("my name is ~w, my age is ~w~n", [biao, 20]).</p> 
<p>9、/返回浮点数 <br>    div 整数除  rem 求余<br> 10、'a' 等同于 a<br> 11、元组嵌套赋值<br> 1&gt;F = {first, guo}.<br> {first,guo}<br> 2&gt; L = {last, biao}.<br> {last,biao}<br> 3&gt; Name = {person, F, L }.<br> {person,{first,guo},{last,biao}}</p> 
<p><br> 12、元组元素提取,采用占位符(下划线)<br> 6&gt; Name.<br> {person,{first,guo},{last,biao}}<br> 7&gt; {_,{_,N1},{_,N2}} = Name.<br> {person,{first,guo},{last,biao}}<br> 8&gt; N1.<br> guo<br> 9&gt; N2.<br> biao<br> 10&gt;</p> 
<p>13、获取列表的元素值 [H|T]<br> 10&gt; ThingstoBuy=[{apple, 5}, {pear,10}, {orange, 20} ].<br> [{apple,5},{pear,10},{orange,20}]<br> 11&gt; [Buy1|Others] = ThingstoBuy.<br> [{apple,5},{pear,10},{orange,20}]<br> 12&gt; Buy1.<br> {apple,5}<br> 13&gt; Others.<br> [{pear,10},{orange,20}]</p> 
<p>14、字符串=整数列表<br> Hello = "hello"<br> 整数列表中，所有的整数都是可打印字符时，才转为字符串。<br> 15&gt; [1,2,3].<br> [1,2,3]<br> 17&gt; [97,98,99].<br> "abc"<br> 使用$来表示一个字符的ASCII值（Latin-1)<br> 18&gt; [$s-32, $i, $r].<br> "Sir"<br> 又例如<br> 23&gt; [H|T]="cat".<br> "cat"<br> 24&gt; H.<br> 99<br> 25&gt; T.<br> "at"</p> 
<p>18、释放所有的变量绑定。f().</p> 
<p>19、Erlang提供的命令。<br>  pwd()打印当前路径，</p> 
<p>切换当前目录到C盘根目录<br> 1&gt;  cd("e:/erlang_src").<br> &lt;input type="button" e:/erlang_src<br> ok</p> 
<p>20、fun定义匿名函数，并可以赋给一个变量。类似函数指针。<br> 14&gt; Double = fun(X)-&gt;2*X end.<br> #Fun&lt;erl_eval.6.80247286&gt;<br> 15&gt; Double(2).<br> 4&gt;</p> 
<p>21、把fun作为参数传入<br> 例如标准库中的lists:map(F,L).<br> 把F应用到列表的每个元素，并返回新列表。<br> 17&gt; lists:map(Double, [1,2,3,4]).<br> [2,4,6,8]</p> 
<p>标准库lists:filter(P, L ).<br> 把列表的每个元素作为P的参数，返回为TRUE的，才被放到结果列表中。<br> 小例子：查找奇数列表中的奇数。<br> 是否等于的测试符号：" =:= "<br> 25&gt; Even = fun(X) -&gt; X rem 2 /= 0 end.<br> #Fun&lt;erl_eval.6.80247286&gt;<br> 26&gt; Even(2).<br> false<br> 27&gt; lists:filter(Even,[1,2,3,4,5,6,7,8,9]).<br> [1,3,5,7,9]</p> 
<p><br> 22、比较操作符<br> 全等于 =:=   例如 1=:=1.0 false<br> 等于 ==  例如 1==1.0 true<br> 不等于 /=</p> 
<p>23、返回fun的函数。<br> 28&gt; Fruits=[apple,orange,pear].<br> [apple,orange,pear]<br> 29&gt; Test=fun(L)-&gt;( fun(X) -&gt; lists:member(X,L) end) end.<br> #Fun&lt;erl_eval.6.80247286&gt;<br> 31&gt; Isfruits = Test( Fruits ).<br> #Fun&lt;erl_eval.6.80247286&gt;<br> 32&gt; Isfruits( apple ).<br> true</p> 
<p>23、for循环,Erlang中无循环控制，需要自定义的控制结构<br> -module(for).<br> -export([for/3]).<br> for(MAX,MAX,F) -&gt; [F(MAX)];<br> for(I,MAX,F) -&gt; [F(I) | for(I+1,MAX,F)].</p> 
<p>39&gt; c(for).<br> {ok,for}<br> 40&gt; for:for(1,10,fun(I)-&gt;I*2 end).<br> [2,4,6,8,10,12,14,16,18,20]</p> 
<p>在模块中，<br> 如果使用-import(for, [for/3] ) 在使用for函数时，就不需要指定模块名。</p> 
<p>24、列表解析<br> L=[1,2,3,4,5,6].<br> [1,2,3,4,5,6]<br> 42&gt; [2*X || X &lt;- L].<br> [2,4,6,8,10,12]<br> 43&gt;</p> 
<p>例如<br> [2*X || X &lt;- L] <br> 由F(X)组成的列表，其中X是L的每个元素。</p> 
<p>又例如<br> 49&gt;  L=[{orange, 8}, {apple, 5}, {pear, 10} ].<br> [{orange,8},{apple,5},{pear,10}]<br> 50&gt;  [{Name, Number*2} || {Name,Number} &lt;- L].<br> [{orange,16},{apple,10},{pear,20}]<br> 注意{Name,Number}用于和L中的元素进行匹配。</p> 
<p><br> 25、过滤器<br> 51&gt; [X || {a, X} &lt;- [{a,1}, {b,2}, {a,3}] ].<br> [1,3]<br> 过滤出为a的值。</p> 
<p>过滤出奇数的另外一种实现。<br> 53&gt; L = [1,2,3,4,5,6,7,8,9].<br> [1,2,3,4,5,6,7,8,9]<br> 54&gt; [X || X &lt;- L, X rem 2 /= 0].<br> [1,3,5,7,9]<br> 55&gt;</p> 
<p>[X || QUALIFIER1,QUARLIFIER2...].<br> QUALIFIER1...如果是  X &lt;- L形式则为生成器。<br> 如果是布尔表达式则为过滤器。</p> 
<p>26、快速排序算法<br> -module(qsort).<br> -export([qsort/1]).<br> qsort([]) -&gt; [];<br> qsort([Head|L] ) -&gt; <br>                                         qsort([X || X &lt;- L, X &lt; Head])<br>                     ++ [Head] ++<br>                     qsort([X || X &lt;- L, X &gt;= Head] ).<br> 27、lists:seq(1,N) 返回1-N的整数列表。毕达哥拉斯三元组。</p> 
<p>28、断言。可以用于简单的变量测试和比较。断言语句使用when关键字开头。<br> -module(maths).<br> -export([max/2]).<br> max(X, Y) when X &gt; Y -&gt; X;<br> max(X, Y) -&gt; Y.</p> 
<p>29、断言谓词。<br> is_atom(X)<br> is_integer(X)<br> is_list(X)<br> is_function(X,N)<br> is_tuple(X) 是否元组<br> is_record(X,Tag,N)</p> 
<p>30、断言内建函数（BIF)<br> abs(X)<br> element(N,X) 元组X的第N个元素<br> hd(X) 列表X的头部<br> tl(X) 列表X的尾部,除第一个元素以外的剩余元素。<br> length(X) 列表的长度<br> node() 当前节点  node(X) 创建节点<br> round(X) 四舍五入为整数<br> self() 当前进程的进程标示符<br> size(X) 元组的大小<br> 例如：<br> 67&gt; L=[1,2,3,4,5,6,7].<br> [1,2,3,4,5,6,7]<br> 68&gt; hd(L).<br> 1<br> 69&gt; tl(L).<br> [2,3,4,5,6,7]</p> 
<p>31、用分号分隔的断言表示 or<br>     用逗号分隔的断言表示 and<br> assert(X,Y) when is_integer(X), X&gt;5, X&gt;Y -&gt; [X,Y];  % and 操作<br> assert(X,Y) -&gt; [Y,X].</p> 
<p>32、andalso，orelse用于构建稍微复杂一些的断言。</p> 
<p>33、记录的定义保存在.hrl文件中，这样可以被多个module共享，以保证是同一份定义。<br> 在命令行中使用记录之前，先要读取记录hrl文件，命令为 rr("xxx.hrl").</p> 
<p>34、record定义，表名字为todo，字段有status，who，memo<br> -record( todo, {status=ok, who = biao, memo=test}).  --&gt;保存在record.hrl中.</p> 
<p>插入三条记录<br> 76&gt; X1=#todo{status=bad,who=zb,memo=test2}.<br> #todo{status = bad,who = zb,memo = test2}<br> 77&gt; X2=#todo{}.<br> #todo{status = ok,who = biao,memo = test}<br> 78&gt; X3=X2#todo{who=biaobiao}.       %复制一条记录，然后修改who的值<br> #todo{status = ok,who = biaobiao,memo = test}</p> 
<p>rf(todo).<br> 去掉记录的定义，然后打印X2，会发现其实是元组。</p> 
<p>35、提出RECORD记录值。<br>    第一种方法。#todo{who=W, memo=M, status=S} = X3.<br>    第二种方法。X3#todo.W    X3#toto.M<br>    <br> 36、case..of..end分支<br> 例子：自定义filter<br> filter(P, [H|T]) -&gt; <br>         case P(H) of<br>            true -&gt; [H|filter(P, T)];<br>            false-&gt;filter(P,T)<br>         end;<br> filter(P,[]) -&gt; [].</p> 
<p>13&gt; IsBig = fun(X) -&gt;  X &gt; 10 end.<br> #Fun&lt;erl_eval.6.80247286&gt;<br> 14&gt; maths:filter(IsBig, [1,3,4,11,20]).<br> [11,20]</p> 
<p>37、条件分支if..end<br> iftest(X) -&gt;<br>     if<br>         X == 1 -&gt;<br>             "return 1";<br>       X == 2 -&gt;<br>         "return 2";<br>       true -&gt;<br>         "return other"<br>     end.<br> 38、try .of. catch.. after..end  为 case的增强版，带有异常捕捉功能。<br>     三种类型的异常exit/throw/error<br>     异常捕捉例子：</p> 
<p>-module(try_test).<br> -export([demo1/0,generate_exception/1,catcher/1]).<br> generate_exception(1) -&gt; a;<br> generate_exception(2) -&gt; throw(a);<br> generate_exception(3) -&gt; exit(a);<br> generate_exception(4) -&gt; {'EXIT', a};<br> generate_exception(5) -&gt; erlang:error(a).</p> 
<p>demo1() -&gt; <br>         [catcher(I) || I &lt;- [1,2,3,4,5]].</p> 
<p>catcher(N) -&gt;<br>       try generate_exception(N) of<br>          Val -&gt; { N, normal, Val}     %%如果没有异常，这个generate_exception(N)的值就和VAL进行匹配。<br>       catch <br>         throw:X -&gt; {N, caught, throw, X };<br>         exit:X -&gt; {N, caught, exit, X };<br>         error:X -&gt; { N, caught, error, X }<br>       after<br>         io:format("test").<br>       end.<br>       <br> 运行结果：<br> 6&gt; try_test:demo1().<br> [{1,normal,a},<br>  {2,caught,throw,a},<br>  {3,caught,exit,a},<br>  {4,normal,{'EXIT',a}},<br>  {5,caught,error,a}]<br>  <br> 39、erlang:error提高错误信息的质量。<br>  <br> sqrt(X) when X &lt; 0 -&gt;<br>      erlang:error( { sqrtNagativeArgumentError, X } );<br> sqrt(X) -&gt;<br>      math:sqrt(X).<br>      <br> 运行后，有如下提示:<br> 7&gt; maths:sqrt(-1).<br> ** exception error: {sqrtNagativeArgumentError,-1}<br>      in function  maths:sqrt/1</p> 
<p>40、函数返回值，<br>     {ok, Val} 或者  {error, Why}  调用者模式匹配后进行处理。<br>     例如：<br>     <br> 41、erlang中的小于等于：" =&lt; ", 大于等于: "&gt;="<br> 例如：<br> %%输出不同的结果<br> getValue(X) when X &gt;= 1, X =&lt; 100  <br>      -&gt; {ok, 'less than 100'};<br> getValue(X)<br>        -&gt; {error, 'larger than 100' }.<br> %%调用getValue对结果输出<br> deal(X) -&gt;<br>     case getValue(X) of<br>         {ok, Info } -&gt;<br>                 io:format("ok print info: ~w~n", [Info]);<br>       {error, Info} -&gt;<br>             io:format("error print info: ~w~n", [Info])<br>      end.<br> 42、捕获任何异常的写法 ( _:_ )。<br>     try expr of<br>        模式匹配 -&gt; ...<br>     catch<br>       _:- -&gt;  异常处理<br>     end.<br> 43、使用 erlang:get_stacktrace() 打印函数调用的栈信息。<br>     demo2() -&gt;<br>     try generate_exception(2)<br>     catch<br>       throw:X -&gt;<br>           {X, erlang:get_stacktrace()}<br>     end.<br> 44、BIF并非erlang编写，而是虚拟机上的基本操作，包含在erlang模块中，<br>     并自动导入,所以使用时不需要用前缀,例如 erlang:tuple_to_list/1<br>     cat 和 'cat' 是一样的，为一个常量。</p> 
<p>元组转化为列表<br> 3&gt; tuple_to_list({1, "cat", "hello"}).<br> [1,"cat","hello"]</p> 
<p>获取当前时间<br> 4&gt; time().<br> {11,11,2}</p> 
<p>45、二进制数据中的整数，必须是0-255.<br>     超出255，会从0开始，例如256输出会变成0， 257变成1.<br>     erlang的函数注释：@spec func( arg1, arg2 ...) -&gt; val  <br>     <br> 46、列表转成二进制数据。<br> @spec list_to_binary( L ) -&gt; binary().<br> 11&gt; list_to_binary([1,2,3]).<br> &lt;&lt;1,2,3&gt;&gt;<br> 12&gt; list_to_binary([&lt;&lt;1,2,3&gt;&gt;, 1,2,3,&lt;&lt;4,5,6&gt;&gt;]).<br> &lt;&lt;1,2,3,1,2,3,4,5,6&gt;&gt;<br> 13&gt;</p> 
<p>47、列表分割<br> @spec split_binary(BIN, POS) -&gt; {BIN1,BIN2}<br> 13&gt; split_binary(&lt;&lt;1,2,3,4,5,6&gt;&gt;, 3).<br> {&lt;&lt;1,2,3&gt;&gt;,&lt;&lt;4,5,6&gt;&gt;}</p> 
<p>48、@spec term_to_binary(BIN) -&gt; Term<br> 把任何erlang值转成二进制，把格式也存入二进制中，用于文件传输和网络传输，<br> 可以还原的。<br> 17&gt; term_to_binary({"cat", "abc"}).<br> &lt;&lt;131,104,2,107,0,3,99,97,116,107,0,3,97,98,99&gt;&gt;<br> 18&gt; binary_to_term(&lt;&lt;131,104,2,107,0,3,99,97,116,107,0,3,97,98,99&gt;&gt;).<br> {"cat","abc"}</p> 
<p>49、二进制的字节长度<br> @spec size(BIN) -&gt; Int<br> 19&gt; size(&lt;&lt;1,2,3,4,5,6&gt;&gt;).<br> 6</p> 
<p>50、比特语法<br> 例子，用16位存储RGB</p> 
<p>用16位存储，Red和Blue为5为，Green 6位<br> 20&gt; Red = 10.<br> 10<br> 21&gt; Green = 20.<br> 20<br> 22&gt; Blue = 30.<br> 30<br> 23&gt; Color = &lt;&lt;Red:5, Green:6, Blue:5&gt;&gt;.<br> &lt;&lt;82,158&gt;&gt;</p> 
<p>采用模式匹配提出值<br> 24&gt; &lt;&lt;R:5, G:6, B:5&gt;&gt; = Color.<br> &lt;&lt;82,158&gt;&gt;<br> 25&gt; R.<br> 10<br> 26&gt; G.<br> 20<br> 27&gt; B.<br> 30<br> 28&gt;</p> 
<p>51、比特语法表达式中的元素，有一项指明计算机系统的字节序。<br>     big/little/native.  默认为big，运行时根据CPU来确定字节序则选native<br>     在不同机器之间进行整数、二进制之间的解包和封包，需要使用正确的字节序。<br>     例如&lt;&lt;123456:32/big, 45678:16/little&gt;&gt;<br> 52、全局宏定义，使用问号获取。</p> 
<p>-define(BUFFER, 2048).<br> getDefine() -&gt;<br>     ?BUFFER * 2.<br> 测试结果:<br> 38&gt; maths:getDefine().<br> 4096</p> 
<p>53、apply可以动态调用BIF，例如apply(erlang, atom_to_list, [hello]).<br>     <br>      模块属性<br>     -import( lists, [map/2] ).<br>     引入lists:map/2, 在模块中调用就不需要指明前缀lists<br>     <br>     -export([getDefine/2]).<br>     只有导出函数，在模块外部才能被访问到。<br>  <br>     -compile(export_all).<br>     如果要把模块中的函数全部导出，可以使用-compile来代替-export.<br>     <br>     -vsn(1.0).<br>     表示模块的版本。<br> 54、自定义的模块属性。<br>     例如-author( biao ).<br>     使用maths:module_info().可以输出所有这些信息项。<br>     <br>         50&gt; maths:module_info(attributes).<br>         [{vsn,[1.0]}]<br>         51&gt; beam_lib:chunks("maths", [attributes]). %使用系统模块来获取。<br>         {ok,{maths,[{attributes,[{vsn,[1.0]}]}]}}<br>     从以上结果抽取对应的值。<br>  <br> beam_lib:chunks用来提取模块的属性，然后用以下函数可以提出属性值。   <br> -module(extract).<br> -export([extract/2]).<br> extract(File, Key) -&gt;<br>     case beam_lib:chunks(File, [attributes]) of<br>         {ok, {File,[{attributes,L}]}}  -&gt;<br>            case lookup( Key, L ) of<br>                    {ok, Val} -&gt; Val;<br>                    error -&gt; exit(notFound)<br>            end;<br>          _ -&gt;<br>            exit( badFile )<br>     end.<br>                           <br> lookup(Key, [{Key,Val}|_]) -&gt; {ok,Val};<br> lookup(Key, [_|T]) -&gt; lookup(Key, T);<br> lookup(Key, [] ) -&gt; error.<br>     <br> 输出：<br> 53&gt; extract:extract(maths, vsn).<br> [1.0]</p> 
<p>55、块表达式。<br>      begin<br>        expr1,<br>        expr2<br>   end.<br>  返回的是最后一条expr的值。</p> 
<p>56、布尔表达式<br> 63&gt; not true.<br> false<br> 64&gt; true and false.<br> false<br> 65&gt; true or false.<br> true<br> 66&gt; (2&gt;1) or (3&gt;4).<br> true</p> 
<p>erlang的预处理器是epp</p> 
<p>57、转义符<br> \b 退格<br> \d 删除<br> \s 空格 \t tab  \n 换行 \r回车 <br> \^X 代表 CTRL+X ,X为A-Z或a-z<br> \'单引号  \" 双引号 \\反斜杠 \C字母的ascii值。<br> \NNN \NN \N 表示八进制数。</p> 
<p>58、函数引用，使用fun funcname/argnum<br> -module(funRef).<br> -export([double/1,double2/1]).<br> square(X) -&gt; X*X.  <br> double(L)-&gt;lists:map(fun square/1, L).  %引用本地<br> double2(L) -&gt; lists:map( fun maths:sqrt/1, L ). %引用其他模块</p> 
<p>59、包含文件，把文件引入当前模块，例如hrl文件<br>    -include( File ).<br>    -include_lib("kernel/include/file.hrl"). 包含lib下最新kernel下的file.hrl.<br>    <br> 60、中缀操作符++ -- <br> 72&gt; [1,2,3]++[4,5,6].<br> [1,2,3,4,5,6]<br> 73&gt; [1,2,3,3,3,4,5,3]--[3,3].<br> [1,2,3,4,5,3]<br> 74&gt; [1,2,3,4,3,3]--[3,3,3,3].<br> [1,2,4]</p> 
<p>61、宏定义<br> -define( BUFFER, 2048).<br> -define( Test(A, B), {A,B,A,B}).<br> 预定义宏。<br> print()-&gt;<br>     io:format("~p,~p,~p~n", [?FILE,?MODULE,?LINE]).<br> 87&gt; funRef:print().<br> "./funRef.erl",funRef,7</p> 
<p>宏的流程控制，编译开关。<br> -module(macro).<br> -export([start/0,loop/1]).</p> 
<p>-ifdef(debug).<br> -define(TRACE(X), io:format("Trace ~p~p:~p~n", [?MODULE,?LINE,X])).<br> -else.<br> -define(TRACE(X), void).<br> -endif.</p> 
<p>start() -&gt; loop(5).</p> 
<p>loop(0) -&gt; void;<br> loop(N) -&gt;<br>     ?TRACE(N),<br>     loop(N-1).<br> 编译运行：<br> 107&gt; c(macro,{d, debug}).  %%引入debug定义<br> {ok,macro}<br> 108&gt; macro:start().<br> Trace macro14:5<br> Trace macro14:4<br> Trace macro14:3<br> Trace macro14:2<br> Trace macro14:1<br> void <br>  </p> 
<p>62、在模式中使用匹配操作符。<br>  test({name,Name}=Z|T) -&gt;<br>     f(Z)...<br> 63、K进制整数的表示方法。<br> 15#11.<br> 15进制，其值为16.<br> $a,$\^c,表示ascii值。</p> 
<p>64、进程字典，由一系列的键值对组成。<br> 3&gt; get().<br> []<br> 4&gt; put(x,20).  %把x的值设置为20，并把原来的值返回。<br> undefined<br> 5&gt; put(x,30).<br> 20<br> 6&gt; get(x).<br> 30<br> 7&gt; put(y,40).<br> undefined<br> 8&gt; get().  %返回所有的进程字典<br> [{y,40},{x,30}]<br> 9&gt; erase(x).  %删除字典x<br> 30<br> 10&gt; get().<br> [{y,40}]<br> 11&gt; erase().<br> [{y,40}]</p> 
<p>尽量少用进程字典，一般用于只读的一些参数设置。一次性写入的变量。</p> 
<p>65、erlang:make_ref().创建一个唯一标签。<br>     全局唯一。匹配时使用的。<br> 13&gt; Data = make_ref().<br> #Ref&lt;0.0.0.64&gt;<br> 14&gt; Data.<br> #Ref&lt;0.0.0.64&gt;</p> 
<p>66、短路布尔表达式。andalso  orelse  而 （and，or两个都要求值）。<br>     比较表达式：<br>     X =&lt; Y  小于等于<br>     X /= Y 不等于    仅适用于整数和浮点数的比较。<br>     X =:= Y 全等于   适用于所有的比较。和C++中的==一样。<br>     X =/= Y 不全等于  适用于所有的比较。和C++中的==一样。<br>     X == Y  等于   仅适用于整数和浮点数的比较。</p> 
<p><br> 67、下划线变量。<br>     只使用一次的变量，例如open(File,_Mode) 等价于 open(File, _)<br>     退出shell 输入q().等同于init:stop().<br> 68、加载路径：<br>       code:add_patha(Dir).加到开头。<br>       code:add_pathz(Dir).加到结尾。<br>       code:all_loaded(). 已加载的路径。<br>       code:get_path().查找路径设定值。<br>       code:clash().检查加载错误。<br>     <br>     命令行增加加载路径:erl -pa Dir1 -pa Dir2 ....<br>     获取erlang所需的home目录 init:get_argument(home).<br> 69、命令行脚本。<br>     erl -noshell -s hello start -s init stop.<br>     用非交互式方式，调用hello:start()，然后调用init:stop().<br>     命令行中执行任意一个函数<br>     erl -eval 'io:format("test").' -noshell -s init stop.<br> 70、一个相关的makefile<br> .SUFFIXES: .erl .beam<br> .erl .beam:<br>     erlc -W $&lt;<br>     <br> ERL= erl -boot start_clean<br> MODS = module1 module2 module3</p> 
<p>all: compile<br>     ${ERL} -pa './dir' -s module1 start<br>     compile:${MODS:%=%.beam}<br>     <br> clean:<br>     rm -rf *.beam erl_crash.dump<br>     <br> erlang虚拟机的错误信息。<br> webtool:start().可以看到地址。<br> 1&gt; webtool:start().<br> WebTool is available at http://localhost:8888/<br> Or  http://127.0.0.1:8888/<br> {ok,&lt;0.34.0&gt;}</p> 
<p><br> 71、ERLANG中进程和操作系统是不同的，ERLANG中的进程是程序语言，并不属于操作系统。<br> 每个进程都是独立运行的ERLANG虚拟机。<br> Pid = spawn(Fun).产生一个新进程对Fun求值。<br> Pid ! M  把消息M发送给Pid进程，返回M.<br> Pid1 ！ Pid2 ！ Pid3 ！ M..群发消息。<br> receive ... Other .. end. 接受消息。</p> 
<p>72、创建一个求面积的服务进程。</p> 
<p>-module(area).<br> -export([loop/0,rpc/2]).</p> 
<p>%%客户端<br> rpc(Pid, Request) -&gt;<br>   Pid ! {self(), Request },<br>   receive<br>       {Pid, Response} -&gt; <br>           io:format("get response: ~p~n", [Response]);<br>       _Other -&gt; <br>            _Other<br>   end.<br>   </p> 
<p><br> %%服务端<br> loop() -&gt;<br>     receive<br>        {From, {rectangle, W, H}} -&gt; <br>            From ! {self(), W * H},<br>            loop();<br>        {From, {circle, R} } -&gt;<br>            From ! {self(), 3.14*R*R},<br>            loop();<br>        {From, _Other} -&gt;<br>                 From ! {self(),"i don't know~~"},<br>               loop()<br>     end.<br> 运行情况：<br> 14&gt; Pid = spawn(fun area:loop/0).<br> &lt;0.62.0&gt;<br> 16&gt; area:rpc(Pid, {rectangle, 4, 5}).<br> get response: 20<br> ok<br> 17&gt; area:rpc(Pid, {circle, 3}).<br> get response: 28.259999999999998<br> ok</p> 
<p>注意：Pid ! M 本身是会返回消息M,所以在输出中也会体现。<br> self()表示当前进程的进程号</p> 
<p>73、erlang允许的最大进程数。<br> 18&gt; erlang:system_info(process_limit).<br> 32768<br> 要增加这个上限，再启动时使用+P参数<br> C:\Documents and Settings\Administrator&gt;erl +P 50000<br> 2&gt; erlang:system_info(process_limit).<br> 50000</p> 
<p><br> 74、计算创建进程消耗的CPU时间和实际时间。<br> -module(elapse).<br> -compile(export_all).<br> compute(N) -&gt;<br>     Max = erlang:system_info( process_limit ),<br>     io:format("max process limit is: ~p~n", [Max] ),<br>     <br>     statistics(runtime),  %%开始统计CPU消耗时间<br>     statistics(wall_clock),  %%开始统计实际消耗时间<br>     <br>     L = for( 1, N, fun() -&gt; spawn( fun() -&gt; wait() end ) end  ), %%启动N个进程。<br>     io:format("in"),<br>     {_,Time1} = statistics( runtime ),       %%统计时间<br>     {_,Time2} = statistics( wall_clock ),    %%统计时间<br>     <br>     lists:foreach( fun( Pid ) -&gt; Pid ! die end, L ),<br>     <br>     U1 = Time1 * 1000/N,<br>     U2 = Time2 * 1000/N,<br>     <br>     io:format("elapse ~p(um) CPU Time and ~p(um) Wall Time.", [U1, U2] ).<br>      <br> wait() -&gt;<br>     receive<br>         die -&gt; void<br>     end.</p> 
<p>for( N, N, F ) -&gt; [F()];<br> for( I, N, F ) -&gt; [F() | for(I+1,N,F)].  %%注意这里的for，不要写成F<br>     <br>     <br> 75、receive 进程等待的超时时间设置。<br> -module(wait).<br> -compile( export_all ).<br> waiting( Time ) -&gt; <br>     receive <br>        Time when Time &gt; 100 -&gt;<br>             'time is larger than 100';<br>        _ -&gt;<br>                'other time'<br>     after Time -&gt;     <br>        'no request...'<br>     end.<br>        <br> 等待Time毫秒后，如果没有接收到合适的请求，则执行after后面的语句。<br> after后面的箭头，极易遗漏！</p> 
<p>76、只有超时的receive语句<br> 例如让当前的进程停止T ms<br> -module(sleep).<br> -export([sleep/1]).<br> sleep(T) -&gt;<br>    receive <br>    after <br>       T -&gt; void<br>    end.</p> 
<p>77、永远等待 infinity<br> sleep()-&gt;<br>     receive<br>     after <br>        infinity -&gt;<br>            void<br>     end.<br>    <br> 78、注册进程：发布一个进程标示符，以便其他进程与之通信。<br>     register(AnAtom, Pid ).<br>     unregister(AnAtom).<br>     whereis(AnAtom) -&gt; Pid | undefined 判断原子AnAtom是否已被注册。<br>     registered() -&gt; [] 返回系统中所有已注册的名称列表。<br>     <br>     例如：</p> 
<p>6&gt;  Pid = spawn(fun area:loop/0).<br> &lt;0.42.0&gt;<br> 7&gt; register( area, Pid).<br> 可以看做是别名，进程退出时，自动取消注册。</p> 
<p>79、spawn( Fun) 创建一个进程、执行Fun对应的函数。<br>  -module(clock).<br> -compile(export_all).</p> 
<p>start(Time, Fun) -&gt; <br>     register( clock, spawn( fun() -&gt; tick( Time, Fun) end ) ).   %%创建一个进程，并给出别名，然后进程执行tick函数。</p> 
<p>stop() -&gt;<br>     clock ! stop.</p> 
<p>tick( Time, Fun ) -&gt;<br>       receive <br>           stop -&gt; void<br>       after <br>           Time -&gt;                     %% 不断地等待，超时后打印一条记录，又接着回调tick<br>              Fun(),<br>              tick(Time, Fun)<br>       end.   </p> 
<p>执行结果如下：<br> 27&gt;<br> clock:start(1000, fun()-&gt;io:format("test") end ).<br> true<br> 28&gt; test28&gt; test28&gt; test28&gt; test28&gt; test28&gt; test28&gt; test28<br> 28&gt; test28&gt; test28&gt; test28&gt;<br> clock:stop().<br> teststop    </p> 
<p>80、使用MFA创建进程。<br>     spawn( Mod, Function, Args ).<br>     link(Pid) 把当前进程和Pid进程链接。<br>     unlink(Pid) 取消链接<br>     exit(Why)  退出，并广播这个Why原因内容。<br>     exit(Pid, Why) 向Pid发送退出信号。<br>     erlang:monitor(process, Pid) 建立一个监视器。监视器是单向的，而链接是双向。<br>     BIF函数：process_flag( trap_exit, true).把当前进程变成系统进程。<br>     系统进程可以捕获别的进程的退出状态。<br>     <br> 81、<br> 进程正常结束，发出normal信号，他的进程集合屏蔽这种信号。<br> 进程非正常结束，他的进程集中的非系统进程都会退出，系统进程才能处理这种信号。<br> 进程收到kill信号，不管是否是系统进程，全部退出，并且广播。</p> 
<p>82、三种进程模式<br>    Pid = spawn( fun() -&gt; ... end ). 被创建的进程消亡，当前进程毫无察觉。<br>    Pid = spawn_link( fun() -&gt; ... end ).被创建的进程非正常消亡，当前进程也会退出。<br>    <br>    被创建的进程退出，当前进程做错误处理。<br>    process_flag(trap_exit, true),  %先变成系统进程。<br>    PID = spawn_link( fun() -&gt; .. end ),<br>    loop().<br>    <br>    loop( State) -&gt;<br>       receive<br>           {'EXIT', Pid, Reason } -&gt;<br>               ...<br>          loop( State1 );<br>        ...<br>       end.<br>    <br>    <br>    <br> 83、存活进程例子<br> -module(onexit).<br> -compile( export_all).</p> 
<p>keep_alive( Name, Fun )-&gt;   %创建一个进程注册为Name，然后执行Fun函数。<br>      register( Name, Pid = spawn( Fun) ),<br>      on_exit( Pid, fun(_Why) -&gt; keep_alive(Name, Fun) end ).</p> 
<p>% 把当前进程和Pid链接，然后进程异常退出时，捕获并调用Fun函数处理。<br> on_exit(Pid, Fun) -&gt;    <br>     process_flag( trap_exit, true),<br>     link( Pid ),<br>     receive<br>         { 'EXIT', Pid, Why } -&gt; Fun(Why)<br>   end.<br>   <br> 84、创建一个名字服务。<br> -module(kvs).<br> -compile(export_all).<br> %启动：创建一个服务进程，循环等待处理，并给予别名kvs<br> start() -&gt; <br>     register(kvs, spawn( fun() -&gt; loop() end )).</p> 
<p>%向服务端发起变更请求，并接收结果<br> store(Key, Value) -&gt;<br>    kvs ! {self(), {store, Key, Value}},<br>    receive<br>       {kvs, Reply} -&gt; Reply<br>    end.<br> %向服务器发起查询请求，并接收结果<br> lookup(Key) -&gt;<br>      kvs ! {self(), {lookup, Key}},<br>      receive<br>        {kvs, Reply} -&gt; Reply<br>      end.</p> 
<p>%接收客户端请求，并把结果发给客户端<br> loop()-&gt;<br>    receive<br>        {From, {store, Key,Value} } -&gt;<br>                    put( Key, Value ),<br>                    From ! {kvs, true},<br>                    loop();<br>        {From, {lookup, Key} } -&gt;<br>             From ! {kvs, get(Key) },<br>             loop()<br>    end.</p> 
<p>运行结果：<br> 18&gt; kvs:start().<br> true<br> 19&gt; kvs:store(money, 100).<br> true<br> 20&gt; kvs:store(name, biao).<br> true<br> 21&gt; kvs:lookup(name).<br> biao<br> 22&gt; kvs:lookup(money).<br> 100</p> 
<p>85、启动节点时，给予名字。同一台机器。<br>     erl -sname Name<br> C:\Documents and Settings\Administrator&gt;erl -sname biao1<br> Eshell V5.8.4  (abort with ^G)<br> (biao1@biao)1&gt; cd ("e:/erlang_src").<br> e:/erlang_src<br> ok</p> 
<p>在第一个节点上运行服务<br> (biao1@biao)2&gt; kvs:start().<br> true </p> 
<p>在第二个节点上，远程发送消息来调用<br> (biao2@biao)3&gt; rpc:call(biao1@biao, kvs, store, [sex, male]).<br> true<br> (biao2@biao)4&gt; rpc:call(biao1@biao, kvs, lookup, [name]).<br> biao</p> 
<p><br> 86、在局域网内的不同机器之间。<br> erl -name biao1 -setcookie abc    <br> 运行在两个不同的网络上，需要用全名。需要DNS服务。<br> 两个节点之间需要使用相同的cookie。<br> 在/etc/hosts可以添加域名入口，内容格式为 网络IP地址 主机名或者域名  [主机名别名]。</p> 
<p>erl -sname biao1  <br> 表示短名，在同一台机器或者在局域网内，直接用短名即可。</p> 
<p>87、判断节点（NODE)之间是否连通。<br>     net_adm:ping(Node).<br>     <br>     设置erlang节点的cookie<br>     erlang:set_cookie(node(), abc).<br>     spawn( Node, Fun ) -&gt; Pid<br>     spawn( Node, Mod, Func, Arg ) -&gt; Pid<br>     spawn_link( Node, Fun ) -&gt; Pid<br>     spawn_link( Node, Mod, Func, Arg) -&gt; Pid.</p> 
<p>    node()-&gt;Node. 返回本地节点的名字。<br>     nodes() -&gt;Node[] 返回与当前节点连接的所有节点。<br>     monitor_node(Node, Flag ) 当前进程监视Node，如果Flag为true则打开，Flag为false则关闭。<br>     当前进程会收到信号{nodeup, Node}, {nodedown, Node }<br>     is_alive() -&gt; bool() 本地节点状态是否正常。<br>     {RegName,Node} ! Msg 向节点Node的RegName进程发消息。<br>         <br> 88、在因特网上两个节点通信<br>     A、确保4396端口是通的，Erlang的epmd会使用这个端口。<br>     B、ERLANG端口使用。启动时erl -name .. -setcookie .. -kernel inet_dist_listen_min Min inet_dist_listen_max Max.<br>     C、节点之间必须拥有相同的cookie，具有相同cookie的相连接的节点群称为ERLANG集群。<br>     <br> 89、apply(M,F,A),这个可以实现，模块函数的配置化。<br>     rpc:call(Node, Mod, Function, Args) -&gt; Result | {badrpc, Reason}<br>     erl -setcookie ABCEDEF<br> 90、lib_chan模块，用来控制能够启动哪些进程。这个应该是第三方的包。<br>     start_server()-&gt;true  启动一个服务。<br>     start_server( Conf) -&gt; 按照配置启动一个服务。</p> 
<p>    配置文件内容是一系列的元组，<br>     {port, NNN }  服务器的监听端口为NNN<br>     {service, S,password, P, mfa, SomeMod,SomeFunc,SomeArgs}<br>     定义由密码P保护的服务S,如果服务启动，则由SomeMod:SomeFunc(MM,ArgsC,SomeArgs}创建的进程会出处理来自客户端的消息。<br>     MM: 代理进程Pid，用于向客户端发消息<br>     ArgC:来自客户机的调用参数。  <br>     connect(Host, port, S, P, ArgC) -&gt; {ok, Pid} | {error, Why}  <br>     <br> 91、Socket套接字</p> 
<p><br> -module(socket_test).<br> -compile(export_all).</p> 
<p>get_url() -&gt;<br>    get_url( "www.google.com" ).</p> 
<p>get_url( Host ) -&gt;<br>    %% 调用connect连接Host:80,产生一个套接字，<br>    %% 采用二级制传输，{packet, 0}意味着原封不动地返回TCP数据。<br>    {ok, Socket} = gen_tcp:connect( Host, 80, [binary, {packet, 0}] ),<br>    <br>    %% 把消息发送到套接字<br>    gen_tcp:send( Socket, "Get/HTTP/1.0\r\n\r\n"),<br>    <br>    %% 进程接收套接字返回的消息<br>    receive_data( Socket, [] ).<br>    <br> receive_data( Socket, Result ) -&gt;<br>    receive<br>       %% 每次收到的Bin消息都放到列表的头部<br>          {tcp, Socket, Bin } -&gt; <br>                  receive_data( Socket, [Bin|Result] );<br>                  <br>          %%接收完毕，把数据反转并转化为二级制数据<br>          {tcp_closed, Socket } -&gt;<br>                  list_to_binary( lists:reverse(Result) )<br>    end.<br>    <br> 运行情况：<br> 8&gt; socket_test:get_url().<br> &lt;&lt;"HTTP/1.0 405 Method Not Allowed\r\nContent-Type: text/html; charset=UTF-8\r\n<br> Content-Length: 11815\r\nDate: Fri, 19 Aug 20"...&gt;&gt;<br> 9&gt;</p> 
<p>92、创建一个监听8888端口的服务<br> 服务端<br> -module(compute_server).<br> -compile(export_all).</p> 
<p>start_server() -&gt;<br>    %% 监听8888端口，并返回一个监听套接字Listen<br>    %% 字节流中的头部是4个字节<br>    {ok,Listen} = gen_tcp:listen(8888, [binary, {packet, 4}, {reuseaddr, true}, {active, true}]),<br>    <br>    %%开始监听8888端口，等待连接<br>    %%有新连接进来，产生一个新的连接套接字Socket<br>    {ok, Socket} = gen_tcp:accept(Listen),<br>    <br>    %%连接成功后，关掉监听器,新建的Socket不会受到影响。<br>    gen_tcp:close( Listen ),<br>    loop( Socket ).<br>    <br> loop( Socket ) -&gt;<br>    receive<br>       {tcp, Socket, Bin } -&gt;<br>           io:format("receive binary: ~p~n", [Bin]),<br>           Str = binary_to_term( Bin ),<br>           io:format("receive value: ~p~n", [Str]),<br>           Reply = Str,<br>           io:format("server reply: ~p~n", [Reply]),<br>           gen_tcp:send(Socket, term_to_binary(Reply) ),<br>           loop( Socket );<br>       {tcp_closed, Socket } -&gt;<br>           io:format("server socket closed.~n")<br>    end. <br>      <br>      <br> 客户端：<br> -module(compute_client).<br> -compile(export_all).</p> 
<p>send( Str ) -&gt;<br>    {ok, Socket} = gen_tcp:connect("localhost", 8888, [binary, {packet, 4}]),<br>    ok = gen_tcp:send(Socket, term_to_binary( Str) ),<br>    receive<br>       {tcp, Socket, Bin } -&gt;<br>           io:format("client receive binary: ~p~n", [Bin] ),<br>           Val = binary_to_term( Bin ),<br>           io:format("client receive value: ~p~n", [Val] ),<br>           gen_tcp:close( Socket )<br>    end.<br>   <br> 运行情况<br> 客户端<br> 2&gt; compute_client:send("abc").<br> client receive binary: &lt;&lt;131,107,0,3,97,98,99&gt;&gt;<br> client receive value: "abc"<br> ok</p> 
<p>服务端<br> 7&gt; compute_server:start_server().<br> receive binary: &lt;&lt;131,107,0,3,97,98,99&gt;&gt;<br> receive value: "abc"<br> server reply: "abc"<br> server socket closed.<br> ok</p> 
<p>93、主动套接字<br>    创建时设置{active, true}<br>    数据到达时，系统向控制进程发送{ tcp, Socket, Data }<br>    控制进程无法控制流量。<br>  <br>    用于异步服务器，客户端不会被阻塞。<br>    <br> 94、被动套接字<br>     {actvie, false}<br>     gen_tcp:recv(Socket, N) 接收来自套接字的数据。N为接收的字节数，如果N=0，则接收所有的<br>     调用recv时，客户端会被阻塞。<br>     只能等待一个套接字的消息。<br>     <br> 95、混合型Socket<br>     {active, once } <br>     主动接收一条消息，然后系统处于阻塞状态，<br>     必须调用inet:setopts(Socket, [{active, once}] )<br>     <br> 96、inet:peername(Socket) -&gt;{ok, {Ip, Port}} | {error, Why} 查看连接的来源。</p> 
<p>97、ets 表类型<br>     set 键不能相同。<br>     order set 排序的set<br>     bag  可以有相同的键，但不能有两个相同的元组。<br>     duplicate bag 可以有相同的键值，也可以有两个相同的元组。<br>   <br> 98、set ordered_set,bag,duplicat_bag 操作<br> -module(ets_test).<br> -export([start/0]).<br> start() -&gt;<br>    %%注意第一个参数为 fun test/1，即调用test函数<br>    lists:foreach( fun test/1, [set, ordered_set, bag, duplicate_bag]).</p> 
<p>test( Mode ) -&gt;<br>    %%创建一个tab表，返回表ID<br>    TabID = ets:new( tab, [Mode] ),<br>    ets:insert(TabID, {a, 1}),<br>    ets:insert(TabID, {b, 2}),<br>    ets:insert(TabID, {a, 1}),<br>    ets:insert(TabID, {a, 3}),<br>    ets:insert(TabID, {a, 2}),<br>    <br>    %% 把表数据转成列表。<br>    List = ets:tab2list(TabID),<br>    <br>    %% 13位宽度显示。<br>    io:format("~13w =&gt; ~p~n", [Mode, List]),<br>    <br>    %%删除表，释放空间<br>    ets:delete( TabID ).<br>    <br> 运行：<br> 4&gt; ets_test:start().<br>           set =&gt; [{b,2},{a,2}]<br>   ordered_set =&gt; [{a,2},{b,2}]<br>           bag =&gt; [{b,2},{a,1},{a,3},{a,2}]<br> duplicate_bag =&gt; [{b,2},{a,1},{a,1},{a,3},{a,2}]<br> ok</p> 
<p>99、@spec ets:new(Name, [Opt]) -&gt; TabID<br>     Name 一个原子<br>     Opt取值有<br>         1) set | ordered_set | bag | duplicate_bag<br>         2) private 私有表，只有所有者进程才能读写。<br>         3) public 公开表<br>         4) protected 只有所有者进程能写，其余知道表名字的进程可以读。<br>         5) named_table 命名表，后续可以使用Name来操作这个表<br>         6) {keypos,1} 设置键的位置。在record中使用。<br>    ets:new的默认设置为<br>    [set,protected, {keypos, 1}]</p> 
<p>100、把服务器的公共部分、不怎么变化的部分放在一个文件中，<br>      然后把变化的部分(业务逻辑）放在另外一个文件中，<br>      通过回调实现解耦。<br>      <br> 服务端例子：<br> -module(server1).<br> -export([start/2,rpc/2]).</p> 
<p>%% 创建一个进程，并且进程注册名是Name，传入一个Mod模块名。<br> start(Name, Mod ) -&gt;<br>    register( Name, spawn( fun() -&gt; loop(Name, Mod, Mod:init() ) end ) ).</p> 
<p>%% 进程Name, 循环接收消息，并调用Mod:handle(..,State)<br> loop( Name, Mod, State ) -&gt;<br>   receive <br>       { From, Request } -&gt;<br>           {Response, State1} = Mod:handle(Request, State),<br>           From ! {Name, Response},<br>           loop( Name, Mod, State1)<br>   end.</p> 
<p>%% 客户端向Name进程发送Request消息<br> rpc( Name, Request ) -&gt;<br>     Name ! {self(), Request},<br>     receive<br>         {Name, Response} -&gt; Response<br>     end.           <br>           <br>           <br> 被回调的Mod模块<br> -module(name_server).<br> -compile(export_all).<br> -import(server1, [rpc/2]).</p> 
<p>%%被服务器回调的程序代码,可以把服务器代码当做一个模板<br> init() -&gt; dict:new().                                   </p> 
<p>handle( { add, Name, Place }, Dict ) -&gt;<br>     {ok, dict:store( Name, Place,Dict) };<br> handle( { whereis, Name }, Dict ) -&gt;<br>     {dict:find(Name, Dict), Dict}.</p> 
<p>被回调的部分可以看做是接口。<br> 运行情况如下：<br> 10&gt; server1:start(myserver, name_server).<br> true<br> 11&gt; server1:rpc(myserver, {add, biao, 'at home'}).<br> ok<br> 12&gt; server1:rpc(myserver, {whereis, biao}).<br> {ok,'at home'}</p> 
<p>101、支持事务的服务端程序<br>      在handle处理异常时，给客户端发退出指令。<br> -module(server2).<br> -compile(export_all).</p> 
<p>%% 创建一个进程，并且进程注册名是Name，传入一个Mod模块名。<br> start( Name, Mod ) -&gt;<br>    register( Name, spawn( fun() -&gt; loop(Name, Mod, Mod:init())end )).</p> 
<p>%% 进程Name, 循环接收消息，并调用Mod:handle(..,State)<br> loop( Name, Mod, OldState ) -&gt;<br>   receive <br>       {From, Request } -&gt;<br>          try Mod:handle( Request, OldState ) of<br>             {Response, NewState} -&gt;<br>                From ! {Name, ok, Response },<br>                loop( Name, Mod, NewState )<br>           catch <br>             _:Why -&gt;<br>                io:format("Server ~p request ~p~n"<br>                          "caused exception ~p~n", <br>                          [Name, Request, Why] ),<br>                From ! {Name, crash },<br>                loop( Name, Mod, OldState )<br>          end<br>   end.</p> 
<p>%% 客户端向Name进程发送Request消息<br> rpc( Name, Request ) -&gt;<br>     Name ! {self(), Request},<br>     receive<br>         {Name, crash} -&gt; exit( rpc );<br>         {Name, ok, Response} -&gt; Response<br>     end.           <br>           </p> 
<p>102、一个空服务器，然后根据传入的指令进行操作。</p> 
<p>服务端<br> -module(server5).<br> -compile(export_all).<br> start() -&gt;<br>      spawn( fun() -&gt; wait() end ).</p> 
<p>wait() -&gt;<br>      receive<br>         {become, F} -&gt; F()<br>      end.<br>      <br> rpc( Pid, Q) -&gt;<br>     Pid ! { self(), Q },<br>     receive<br>         {Pid, Reply} -&gt; Reply<br>     end.<br>     <br> 具体的服务操作，把功能部分解耦出来。<br> -module(fac_server5).<br> -compile(export_all).<br> loop() -&gt;<br>     receive<br>         {From, {fac, N} } -&gt;<br>             From ! {self(), fac(N)},<br>             loop();<br>         {become, Something} -&gt;<br>             Something()<br>     end.<br>     <br> fac(0) -&gt; 1;<br> fac(N) -&gt; N * fac(N-1).</p> 
<p>运行情况：<br> 2&gt; Pid = server5:start().<br> &lt;0.33.0&gt;<br> 3&gt; Pid !  {become, fun fac_server5:loop/0 }.<br> {become,#Fun&lt;fac_server5.loop.0&gt;}<br> 4&gt; server5:rpc(Pid, {fac, 3}).<br> 6<br> 5&gt; server5:rpc(Pid, {fac, 5}).<br> 120</p> 
<p>103、服务器模板gen_server.<br> 需要在开头使用 -behaviour( gen_server).<br> 回调函数有：<br> init/1  初始化，返回一个状态，作为handle_call的输入<br> handle_call/3  回调主体，模式匹配。<br> handle_cast/2<br> handle_info/2<br> terminate/2<br> code_change/3</p> 
<p>写个服务器程序，需要以下三步：</p> 
<p>1、确定回调模块的名称。这里为my_bank.</p> 
<p>2、接口说明<br> start() 打开银行<br> stop() 关闭银行<br> new_account(Who) 开户 <br> deposit(Who, Amount) 存钱<br> withdraw(Who,Amount) 取钱</p> 
<p>3、编写回调函数<br> init([]) -&gt; {ok, State }  %这里的State生成后，将传给后面的函数使用，是一个全局的对象<br> handle_call(_Request, _From, State) -&gt; {reply, Reply, State}<br> handle_cast(_Msg, State) -&gt; {noreply, State }<br> handle_info(_Info, State) -&gt; {noreply, State}<br> terminate(_Reason, _State) -&gt; ok<br> code_change(_OldVsn, State, Extra ) -&gt; {ok, State }</p> 
<p><br> 例子：</p> 
<p>%%第一步，确定回调模块名称<br> -module(my_bank).<br> %-behaviour(gen_server).<br> -compile(export_all).</p> 
<p>%%第二步，接口实现<br> %% start_link启动一个本地的服务器{local,Name},第二个参数为回调模块。.<br> %% 首先会调用MOD:init/1<br> start() -&gt; gen_server:start_link({local, ?MODULE}, ?MODULE, [], [] ).<br> %% gen_server:call(?MODULE,Term) 发起对Name服务器的远程调用。    <br> stop() -&gt; gen_server:call(?MODULE, stop ).<br> new_account(Who) -&gt; gen_server:call(?MODULE,{new,Who}).<br> deposit(Who, Amount) -&gt; gen_server:call(?MODULE, {add, Who, Amount}).<br> withdraw(Who,Amount) -&gt; gen_server:call(?MODULE,{remove, Who, Amount}).<br>     </p> 
<p>%%第三步 回调函数实现<br> %%6个回调函数<br> init([]) -&gt;<br>     {ok, ets:new(?MODULE, [set]) }.</p> 
<p>%银行开户<br> handle_call({new, Who}, _From, Tab) -&gt;<br>     Reply = case ets:lookup(Tab, Who) of <br>                     [] -&gt; ets:insert(Tab, {Who, 0}),<br>                                  { welcome, Who };<br>                     [_] -&gt; {Who, you_already_in_bank}<br>                     end,<br>     {reply, Reply, Tab};</p> 
<p>%银行存钱<br> handle_call({add, Who, X}, _From, Tab) -&gt;<br>     Reply = case ets:lookup( Tab, Who ) of <br>                     [] -&gt; you_are_not_in_bank;<br>                     [{Who, Balance}]-&gt;<br>                         NewBalance = Balance + X,<br>                         ets:insert(Tab, {Who, NewBalance}),<br>                         {thanks, Who, your_balance_now_is, NewBalance}<br>                     end,<br>     {reply, Reply, Tab};<br>     <br> %银行取钱<br> handle_call( {remove, Who, X}, _From, Tab ) -&gt;<br>     Reply = case ets:lookup( Tab, Who) of <br>             [] -&gt; you_are_not_in_bank;<br>             [{Who, Balance}] when X =&lt; Balance -&gt;<br>                 NewBalance = Balance - X,<br>                 ets:insert(Tab, {Who, NewBalance} ),<br>                 {thanks, Who, your_balance_now_is, NewBalance};<br>             [{Who, _Balance}] -&gt;<br>                 {sorry, you_havnot_enough_money}<br>             end,<br>     {reply, Reply, Tab };</p> 
<p>%终止服务器程序的方法 handle_call(Stop, From, State) -&gt; {stop,Reason,Reply,Tab}<br> handle_call(stop, _From, Tab ) -&gt;<br>     {stop, normal, stopped, Tab }.<br> handle_cast(_Msg, State) -&gt; {noreply, State }.<br> handle_info(_Info, State) -&gt; {noreply, State }.<br> terminate(_Reason, _State) -&gt; ok.<br> code_change(_OldVsn, State, _Extra) -&gt; {ok, State }.</p> 
<p>104、gen_server:start_link(Name,Mod,InitArgs,Opts)<br> 创建Name服务，调用Mod:init(InitArgs)启动服务。</p> 
<p>105、gen_server:call(Name,Request).调用服务器程序，发起Request请求，会回调handle_call</p> 
<p>106、gen_server:cast(Name,Name) 回调 hanle_cast(_Msg,State)<br>     handle_cast(_Msg,State) -&gt; {noreply, NewState}</p> 
<p>106、handle_info() 用来处理服务器收到的原生消息，例如收到其他进程的{'EXIT',PID,WHAT}.<br>      handle_info(_Info,State) -&gt; {noreply,State}.<br>      <br> 107、在handle_XXX()函数返回{stop, Reason, State} <br> 或者直接终结服务器返回{'EXIT', reason},这些会回调terminate(Reason,NewState).</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6fffd542ea0d646b6575e0c50e775739/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">快手、抖音、微视类短视频SDK接入教程，7步就能搞定</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ec3789ed4e139a1439925e53261fc179/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">四旋翼飞行器的原理研究和建模</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>