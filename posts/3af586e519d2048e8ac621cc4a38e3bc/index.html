<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构-堆栈 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构-堆栈" />
<meta property="og:description" content="数据结构-堆栈 堆栈（Stack）是一组相同数据类型的组合，具有“后进先出”的特性，所有的操作均在顶端进行。
堆栈的简介
“后进先出”可以看做是往米缸里放米，先放进去的后吃，后放进去的在顶端先吃。堆栈是一种抽象数据结构（ADT，Abstract Data Type），具有下列特性：
只能从堆栈的顶端存取数据数据的存取符合后进先出的原则 堆栈的基本运算有5种：
create创建一个空堆栈push把数据存压入堆栈顶端，并返回新堆栈pop从堆栈顶端弹出数据，并返回新堆栈isEmpty判断堆栈是否为空堆栈，若是则返回true，否则返回falsefull判断堆栈是否已满，若是则返回true，否则返回false堆栈的形式可以采用数组结构和链表结构两种方式表示
使用列表实现 以列表实现的好处是算法的设计简单，但是如果堆栈本身的大小是变动的话，而列表大小只能事先规划和声明好，那么列表规划太大会浪费空间，规划太小又不够用，就很烦
判断堆栈是否为空
def isEmpty(): if top == -1: return True else: return False 将指定的数据存入堆栈
def push(data): global top	#全局top global MAXSTACK	#设置最大容量 global stack if top &gt;= MAXSTACK - 1： print(&#34;堆栈已满&#34;) else: top &#43;= 1 stack[top] = data 从堆栈中取出数据
def pop(): global top global stack if isEmpty(): print(&#34;堆栈已空&#34;) else: print(&#34;弹出的元素为：%d&#34; % stack[top]) top = top -1 例子：设计一个数组方针扑克牌洗牌以及发牌的过程，使用随机数来生成扑克牌放入堆栈，放满52张之后使用堆栈功能给4个玩家发牌
import random global top top = -1 k = 0 &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/3af586e519d2048e8ac621cc4a38e3bc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-15T18:39:07+08:00" />
<meta property="article:modified_time" content="2021-05-15T18:39:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构-堆栈</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_0"></a>数据结构-堆栈</h4> 
<p>堆栈（Stack）是一组相同数据类型的组合，具有“<strong>后进先出</strong>”的特性，所有的操作均在顶端进行。</p> 
<ol><li> <p>堆栈的简介</p> <p>“<strong>后进先出</strong>”可以看做是往米缸里放米，先放进去的后吃，后放进去的在顶端先吃。堆栈是一种抽象数据结构（ADT，Abstract Data Type），具有下列特性：</p> 
  <ul><li>只能从堆栈的顶端存取数据</li><li>数据的存取符合后进先出的原则</li></ul> <p>堆栈的基本运算有5种：</p> 
  <table><thead><tr><th>create</th><th>创建一个空堆栈</th></tr></thead><tbody><tr><td>push</td><td>把数据存压入堆栈顶端，并返回新堆栈</td></tr><tr><td>pop</td><td>从堆栈顶端弹出数据，并返回新堆栈</td></tr><tr><td>isEmpty</td><td>判断堆栈是否为空堆栈，若是则返回true，否则返回false</td></tr><tr><td>full</td><td>判断堆栈是否已满，若是则返回true，否则返回false</td></tr></tbody></table><p>堆栈的形式可以采用<strong>数组结构</strong>和<strong>链表结构</strong>两种方式表示</p> 
  <ul><li> <h5><a id="_22"></a>使用列表实现</h5> <p>以列表实现的好处是算法的设计简单，但是如果堆栈本身的大小是变动的话，而列表大小只能事先规划和声明好，那么列表规划太大会浪费空间，规划太小又不够用，就很烦</p> 
    <ul><li> <p>判断堆栈是否为空</p> <pre><code>def isEmpty():
		if top == -1:
				return True
		else:
				return False
</code></pre> </li><li> <p>将指定的数据存入堆栈</p> <pre><code>def push(data):
		global top		#全局top
		global MAXSTACK		#设置最大容量
		global stack
		if top &gt;= MAXSTACK - 1：
				print("堆栈已满")
		else:
				top += 1
				stack[top] = data
</code></pre> </li><li> <p>从堆栈中取出数据</p> <pre><code>def pop():
		global top
		global stack
		if isEmpty():
				print("堆栈已空")
		else:
				print("弹出的元素为：%d" % stack[top])
				top = top -1
</code></pre> </li></ul> <p>例子：设计一个数组方针扑克牌洗牌以及发牌的过程，使用随机数来生成扑克牌放入堆栈，放满52张之后使用堆栈功能给4个玩家发牌</p> <pre><code>import random

global top

top = -1
k = 0

"""
stack:堆栈
MAX:堆栈的最大容量
val:push进去的值
"""
def push(stack,MAX,val):
    global top
    if top &gt;= MAX - 1:
        print("[堆栈已满]")
    else:
        top = top + 1
        stack[top] = val    #将val放到stack中

"""
stack:堆栈
"""
def pop(stack):
    global top
    if top &lt; 0:
        print("[堆栈已空]")
    else:
        top = top - 1
        return stack[top]

"""
old:数组，事先声明的数组
洗牌
"""
def shuffle(old):
    result = []
    while old:
        p = random.randrange(0,len(old))    #随机在old数组长度范围抽取一个数
        result.append(old[p])   #将该数组中对应的数加到result中
        old.pop(p)  #将该数在old数组中删除
    return result

card = [None] * 52   #声明52张牌
card_new = [None] * 52  #声明相同长度的数组用于存放洗牌
stack = [0] * 52    #声明堆栈
for i in range(52):
    card[i] = i + 1 #对card数组元素赋值，赋值为1-52

print("开始洗牌...")

card_new = shuffle(card)    #洗牌，并将结果数组存到card_new中

i = 0
while i != 52:
    push(stack,52,card_new[i])
    i = i + 1

print('开始发牌')
print("[显示各家的牌] 东家\t\t 北家\t\t 西家\t\t 南家")
print('------------------------------------')

while top &gt;= 0:
    style = (stack[top]) % 4    #计算花色
    if style == 0:  #梅花
        ascVal = 'club'
    if style == 1:  #方块
        ascVal = 'diamo'
    if style == 2:  #红心
        ascVal = 'heart'
    elif style == 3:    #黑桃
        ascVal = 'spade'

    print('[%s%3d]\t\t\t' % (ascVal,stack[top] % 13 + 1),end='')
    if top % 4 == 0:
        print()
    top = top - 1
</code></pre> </li><li> <p>使用链表实现堆栈</p> <p>用链表实现堆栈的优点是随时可以动态改变链表长度，能有效利用内存资源，缺点是算法较为复杂</p> <p><strong>使用链表表示堆栈就需要指定一个属性next，链表方向为从上到下</strong></p> 
    <table><thead><tr><th>top</th><th>顶端数据</th></tr></thead><tbody><tr><td>↓</td><td>next指向下一个</td></tr><tr><td>new_data</td><td>下一个数据</td></tr><tr><td>↓</td><td>next指向下一个</td></tr><tr><td>new_data</td><td>下一个数据</td></tr></tbody></table><pre><code>class Node:		#堆栈链表节点的声明
		def __init__(self):
				self.data = 0		#堆栈数据的声明
				self.next = None		#堆栈中用来指向下一个节点
top = None
</code></pre> 
    <ul><li> <p>判断是否为空堆栈</p> <pre><code>def isEmpty():
		global top
		if (top == None):
				return 1
		else:
				return 0
</code></pre> </li><li> <p>将指定的数据压入堆栈</p> <pre><code>def push(data):
		global top
		new_add_node = Node()
		new_add_node.data = data		#将传入的值指定为节点的内容
		new_add_node.next = top			#将新节点指向堆栈的顶端
		top = new_add_node			#将新节点指定为堆栈
</code></pre> </li><li> <p>从堆栈弹出数据</p> <pre><code>def pop():
		global top
		if isEmpty():
				print('这个堆栈是空的')
				return -1
		else:
				ptr = top		#指向堆栈的顶端
				top = top.next		#将堆栈顶端的指针指向下一个节点
				temp = ptr.data			#弹出堆栈的数据
				return temp
</code></pre> </li></ul> </li></ul> </li><li> <h5><a id="_204"></a>堆栈的应用</h5> <p>堆栈在计算机领域的应用相当广泛，主要特性是限制了数据插入与删除的位置和方法，属于有序线性表的应用，堆栈的各种应用列举如下：</p> 
  <ul><li>二叉树和森林的遍历，例如中序遍历（Inorder）、前序遍历（Preorder）等。</li><li>计算机中央处理单元（CPU）的中断处理（Interrupt Handling）</li><li>图形的深度优先（DFS）查找法（或陈伟深度优先搜索法）</li><li>当从递归返回（Return）时，按序从堆栈顶端取出相关值，回到原来执行递归前的状态，再往下继续执行</li><li>算数表达式的转换和求值，例如中序法转换成后序法</li></ul> <p>堆栈的应用有很多，以上只是列举了一部分而已</p> 
  <ul><li> <p>递归算法</p> <p>递归（Recursion）是一种很特殊的算法，其定义是：加入一个函数或子程序是由自身所定义或调用的，就称为递归。递归至少需要两个条件：</p> 
    <ul><li>可以反复执行的递归过程</li><li>一个跳出执行过程的出口</li></ul> <p>比如数学上的阶乘函数，可以看做是典型的递归范例，一般以！来代表阶乘。例如4的阶乘就是4！</p> <p>4！= 4 x 3 x 2 x 1</p> <p>4! = (4 * 3!)----&gt;(4 * 3 * 2!) ------&gt;(4 * 3 * 2 * 1)</p> <p>函数算法表示是</p> <pre><code>def factorial(i):		if i == 0:				return 1		else:				ans = i * factorial(i - 1)		#反复执行递归过程
</code></pre> <p>使用for循环设计一个计算0！~ n!的递归程序</p> <pre><code>sum = 1n = int(input('请输入n=''))for i in range (0,n+1):		for j in range(i ,0,-1):				sum *= j				print('%d != %3d' % (i,sum))		sum = 1
</code></pre> <p>递归算法又可以分为直接递归和间接递归：</p> 
    <ul><li> <p>直接递归（Direct Recursion）：在递归函数中允许直接调用该函数自身</p> <pre><code>def Fun(...):		.......if ....:		Fun(...)		......
</code></pre> </li><li> <p>简介递归（Indirect Recursion）：在递归函数中调用其他递归函数，再从其他递归函数调用回原来的递归函数</p> <pre><code>def Fun1(...):	......if ......:		Fun2(...)		.......		def Fun2(...):		......if ......:		Fun1(...)		......
</code></pre> </li></ul> <p><strong>斐波拉契数列</strong></p> 
    <table><thead><tr><th></th><th>0</th><th>n=0</th></tr></thead><tbody><tr><td>Fn</td><td>1</td><td>n=1</td></tr><tr><td></td><td>Fn-1 + Fn-2</td><td>n=2,3,4,5,…(n为正整数)</td></tr></tbody></table><p>简单来说，这就是一个数列的第零项是0，第一项是1，这个数列其他后续项的值是前两项的数值之和。</p> <pre><code>def fib(n):				if n == 0:				return 0		elif n == 1 or n == 2:				return 1		else:			#否则返回fib(n-1) + fib(n-2)				return (fib(n-1) + fib(n-2))		
</code></pre> <p>例子：设计一个计算第n项斐波拉契数列的递归程序：</p> <pre><code>def fib(n):		if n == 0:				return 0		elif n == 1 or n == 2:				return 1		else:				return (fib(n - 1) + fib(n - 2))				n = int ( input ("请输入n="))for i in range(n + 1):		print('fib(%d) = %d' % (i,fib(i)))
</code></pre> <p><strong>汉诺塔问题</strong></p> <p>汉诺塔问题也是很典型的递归方式和堆栈来解决，因为它满足递归的两大特性：<strong>①有反复执行的过程②有停止的出口</strong></p> <p>汉诺塔的游戏规则就是把一定数量的盘子每次移动一个，全部从第一个桩移动到第三个桩上，在移动的过程中要保证大盘子在下面</p> <p>借助递归的思想，加入有n个盘子，我们可以将n个盘子看做两个组成结构，就是n-1个盘子和一个盘子，每次都是将n-1个盘子移动到第二个桩上，将一个盘子（最大的）移动到第三个桩上，然后将第二个桩变换为第一个桩，继续将剩下的n-1个盘子分为两个结构进行移动，直到不能分为止</p> <p>移动步骤：</p> 
    <ul><li>将n-1个盘子从木桩1移动到木桩2</li><li>将第n个最大的盘子从木桩1移动到木桩3</li><li>将n-1个盘子从木桩2移动到木桩3 
      <ul><li>就是把木桩2当做是木桩1逐次分解进行迭代</li></ul> </li></ul> <p>算法实现：</p> <pre><code>"""
n:需要移动的盘子数量
p1,p2,p3:三根木桩
"""
def hanoi(n,p1,p2,p3):
    if n == 1:
        print("盘子从%d移动到了%d"%(p1,p3))
    else:
        hanoi(n-1,p1,p3,p2)
        print("盘子从%d移动到%d"%(p1,p3))
        hanoi(n-1,p2,p1,p3)

j = int(input("请输入要移动盘子的数量："))
hanoi(j,1,2,3)
</code></pre> </li></ul> </li></ol> 
<p><img src="https://images2.imgbox.com/13/45/JY13wR2B_o.png" alt="在这里插入图片描述"></p> 
<pre><code> 除此之外，关于堆栈的有趣应用还有我们常见的迷宫问题等，都可以通过堆栈实现
</code></pre> 
<ol start="3"><li> <p>算数表达式的表示法</p> <p>根据运算符在表达式中的位置，可以分为3中表示法：</p> 
  <ul><li>中序法(Infix)：运算符在两个操作数之间，；例如A+B、(A+B)*(C+D)等都是中序表示法</li><li>前序法(Prefix):运算符在操作数的前面，例如+AB、*+AB+CD等都是前序表示法</li><li>后序法(Postfix):运算符在操作数的后面，例如AB+、AB+CD+等都是后序表示法</li></ul> <p><strong>中序法转为前序法和后序法</strong></p> <p>中序法转换为前序法或者后序法，可以使用两种方式，即括号转换法和堆栈法。括号转换法适合人工手动操作，堆栈法则普遍用于计算机的操作系统或系统程序中</p> 
  <ul><li> <p><strong>括号转化法</strong>：</p> <p>括号转换法先用括号把中序法表达式的运算符优先级分出来，再进行运算符的移动，最后把括号拿掉就可以完成中序转后序或中序转前序</p> <p><strong>6+2<em>9/3+4</em>2-8</strong>为例</p> 
    <ul><li> <p>中序-&gt;前序（Infix-&gt;Prefix）</p> 
      <ul><li> <p>先把表达式按照运算符优先级以括号括起来</p> </li><li> <p>针对运算符，用括号内的运算符取代所有的左括号，以最近者为优先级</p> </li><li> <p>将所有右括号去掉，即可得到前序法表达的结果</p> <pre><code>(((6+((2*9)/3))+(4*2))-8)
</code></pre> <p>前序式：-++ 6 / * 293 * 428</p> </li></ul> </li><li> <p>中序-&gt;后序（Infix-&gt;Postfix）</p> 
      <ul><li> <p>先把表达式按照运算符优先级以括号括起来</p> </li><li> <p>针对运算符，用用括号内的运算符取代所有的左括号，以最近者为优先级</p> </li><li> <p>将所有左括号去掉，即可得到后序法表达的结果</p> <pre><code>(((6+((2*9)/3))+(4*2))-8)
</code></pre> <p>后序法：629 * 3 /+ 42 *+ 8 -</p> </li></ul> </li></ul> </li><li> <p><strong>堆栈法</strong></p> <p>这个方法必须使用运算符堆栈，也就是使用堆栈来协助进行运算符优先级的转换</p> 
    <ul><li>中序-&gt;前序（Infix-&gt;Prefix） 
      <ul><li>从右向左读进中序法表达式的每个字符（token）</li><li>如果读进的字符为操作数，就直接输出到前序法表达式中</li><li>如果遇到“（”，就弹出堆栈内的运算符，直到弹出一个“）”，两者互相抵消</li><li>“）”的优先级在堆栈内比任何运算符都小，任何运算符的优先级都搞过它，不过在堆栈外却是优先级最高者</li><li>当运算符准备进入堆栈内时，必须和堆栈顶端的运算符比较，如果外面的运算符优先级高于或者等于堆栈顶端的运算符，就压入堆栈，如果优先级低于堆栈顶端的运算符，就把堆栈顶端的运算符弹出，直到堆栈顶端的运算符优先级低于外面的运算符或者堆栈为空时，再把外面这个运算符压入堆栈</li><li>中序法表达式读完之后，如果运算符堆栈不是空的，就将其内部的运算符逐一弹出，输出到前序法表达式中即可</li></ul> </li><li>中序-&gt;后序（Infix-&gt;Postfix） 
      <ul><li>从左到右读进中序法表达式的每个字符（token）</li><li>如果读进的字符为操作数，就直接输出到前序法表达式中</li><li>如果遇到“）”，就弹出堆栈内的运算符，直到弹出一个“（”，两者互相抵消</li><li>“（）”的优先级在堆栈内比任何运算符都小，任何运算符的优先级都搞过它，不过在堆栈外却是优先级最高者</li><li>当运算符准备进入堆栈内时，必须和堆栈顶端的运算符比较，如果外面的运算符优先级高于或者等于堆栈顶端的运算符，就压入堆栈，如果优先级低于堆栈顶端的运算符，就把堆栈顶端的运算符弹出，直到堆栈顶端的运算符优先级低于外面的运算符或者堆栈为空时，再把外面这个运算符压入堆栈</li><li>中序法表达式读完之后，如果运算符堆栈不是空的，就将其内部的运算符逐一弹出，输出到前序法表达式中即可</li></ul> </li></ul> </li></ul> </li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ec3095cde70d1f562790fc75c9ded82d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux安装grub提示符,CentOS7启动故障 进入grub&gt;提示符</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/479396a295ced09672c83096a8f6a95c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot 出现 java.lang.NoClassDefFoundError: org/mybatis/logging/LoggerFactory 错误，解决记录。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>