<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从零开始学习JVM（四）-运行时数据区中的堆 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="从零开始学习JVM（四）-运行时数据区中的堆" />
<meta property="og:description" content="1. 概述 一个JVM实例只存在一个堆内存，堆是Java内存管理的核心区域,同时也是JVM管理的最大一块内存空间，在JVM启动的时候即被创建，其空间大小也就确定了，我们可以根据实际程序情况调节堆内存大小。
《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，简称TLAB）。
《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。数组和对象可能永远不会存储在栈上。因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。堆是GC（Garbage Collectioni，垃圾收集器）执行垃圾回收的重点区域。在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。堆是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。
官方文档：The Java® Virtual Machine
Specification
《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”
堆的内存细分，这里在内存逻辑上将方法区放到堆内存的范畴：
JDK1.7堆空间内部结构如图所示：
JDK1.8堆空间内部结构如图所示：
2. 堆内存大小的设置和OOM Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项“-Xmx”和“-Xms”来进行设置。
“-Xms”用于表示堆区（年轻代&#43;老年代）的起始内存，-X标志JVM的运行参数，ms是memory start，等价于-XX:InitialHeapSize“-Xmx”用于表示堆区的最大内存，等价于-XX:MaxHeapSize 一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutOfMemoryError异常。开发中通常建议将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在Java垃圾回收清理完堆区后不需要重新分隔堆区的大小，从而提高性能。
默认情况下，初始内存大小：物理电脑内存大小/64；最大内存大小：物理电脑内存大小/4.
通过代码查看堆的初始内存大小和最大内存大小
public class HeapSpaceInitial { public static void main(String[] args) { //返回JVM中堆内存总量 long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024; //返回JVM试图使用的最大堆内存量 long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024; System.out.println(&#34;-Xms:&#34; &#43; initialMemory &#43; &#34;M&#34;); System.out.println(&#34;-Xmx:&#34; &#43; maxMemory &#43; &#34;M&#34;); System.out.println(&#34;系统内存大小为：&#34; &#43; initialMemory * 64 / 1024 &#43; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/65565ff071637605f4af669fff765d3c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-17T10:42:16+08:00" />
<meta property="article:modified_time" content="2023-05-17T10:42:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从零开始学习JVM（四）-运行时数据区中的堆</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1__0"></a>1. 概述</h3> 
<p>一个JVM实例只存在一个堆内存，堆是Java内存管理的核心区域,同时也是JVM管理的最大一块内存空间，<mark>在JVM启动的时候即被创建，其空间大小也就确定了，我们可以根据实际程序情况调节堆内存大小</mark>。</p> 
<p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，简称TLAB）。</p> 
<p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。数组和对象可能永远不会存储在栈上。因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。堆是GC（Garbage Collectioni，垃圾收集器）执行垃圾回收的重点区域。在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。<mark>堆是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域</mark>。</p> 
<p><img src="https://images2.imgbox.com/bd/94/Z6hF8LSj_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" rel="nofollow">The Java® Virtual Machine<br> Specification</a></p> 
 <p>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”</p> 
</blockquote> 
<p>堆的内存细分，这里在内存逻辑上将方法区放到堆内存的范畴：<br> <img src="https://images2.imgbox.com/f3/95/GyQTNUvE_o.png" alt="在这里插入图片描述"><br> JDK1.7堆空间内部结构如图所示：<br> <img src="https://images2.imgbox.com/96/55/dr4qu1mx_o.png" alt="在这里插入图片描述"><br> JDK1.8堆空间内部结构如图所示：</p> 
<p><img src="https://images2.imgbox.com/6b/32/d8ulzKup_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_OOM_21"></a>2. 堆内存大小的设置和OOM</h3> 
<p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项“<code>-Xmx</code>”和“<code>-Xms</code>”来进行设置。</p> 
<ul><li>“<code>-Xms</code>”用于表示堆区（年轻代+老年代）的起始内存，-X标志JVM的运行参数，ms是memory start，等价于<code>-XX:InitialHeapSize</code></li><li>“<code>-Xmx</code>”用于表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code></li></ul> 
<p>一旦堆区中的内存大小超过“<code>-Xmx</code>”所指定的最大内存时，将会抛出OutOfMemoryError异常。<mark>开发中通常建议将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在Java垃圾回收清理完堆区后不需要重新分隔堆区的大小，从而提高性能。</mark></p> 
<p>默认情况下，初始内存大小：物理电脑内存大小/64；最大内存大小：物理电脑内存大小/4.</p> 
<p>通过代码查看堆的初始内存大小和最大内存大小</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSpaceInitial</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//返回JVM中堆内存总量</span>
        <span class="token keyword">long</span> initialMemory <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">;</span>
        <span class="token comment">//返回JVM试图使用的最大堆内存量</span>
        <span class="token keyword">long</span> maxMemory <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-Xms:"</span> <span class="token operator">+</span> initialMemory <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-Xmx:"</span> <span class="token operator">+</span> maxMemory <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"系统内存大小为："</span> <span class="token operator">+</span> initialMemory <span class="token operator">*</span> <span class="token number">64</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"G"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"系统内存大小为："</span> <span class="token operator">+</span> maxMemory <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"G"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>自行设置初始内存大小和最大内存大小为640M,<code>++PrintGCDetails</code>参数设置打印GC信息</p> 
<p><img src="https://images2.imgbox.com/c1/20/Z4csryYL_o.png" alt="在这里插入图片描述"><br> 执行代码输出</p> 
<pre><code class="prism language-java"><span class="token operator">-</span><span class="token class-name">Xms</span><span class="token operator">:</span><span class="token number">613</span>M
<span class="token operator">-</span><span class="token class-name">Xmx</span><span class="token operator">:</span><span class="token number">613</span>M
<span class="token class-name">Heap</span>
 <span class="token class-name">PSYoungGen</span>      total <span class="token number">190976</span>K<span class="token punctuation">,</span> used <span class="token number">16384</span>K <span class="token punctuation">[</span><span class="token number">0x00000000f2b00000</span><span class="token punctuation">,</span> <span class="token number">0x0000000100000000</span><span class="token punctuation">,</span> <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>
  eden space <span class="token number">163840</span>K<span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000f2b00000</span><span class="token punctuation">,</span><span class="token number">0x00000000f3b00250</span><span class="token punctuation">,</span><span class="token number">0x00000000fcb00000</span><span class="token punctuation">)</span>
  from space <span class="token number">27136</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fe580000</span><span class="token punctuation">,</span><span class="token number">0x00000000fe580000</span><span class="token punctuation">,</span><span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>
  <span class="token keyword">to</span>   <span class="token namespace">space</span> <span class="token number">27136</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fcb00000</span><span class="token punctuation">,</span><span class="token number">0x00000000fcb00000</span><span class="token punctuation">,</span><span class="token number">0x00000000fe580000</span><span class="token punctuation">)</span>
 <span class="token class-name">ParOldGen</span>       total <span class="token number">437248</span>K<span class="token punctuation">,</span> used <span class="token number">0</span>K <span class="token punctuation">[</span><span class="token number">0x00000000d8000000</span><span class="token punctuation">,</span> <span class="token number">0x00000000f2b00000</span><span class="token punctuation">,</span> <span class="token number">0x00000000f2b00000</span><span class="token punctuation">)</span>
  object space <span class="token number">437248</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000d8000000</span><span class="token punctuation">,</span><span class="token number">0x00000000d8000000</span><span class="token punctuation">,</span><span class="token number">0x00000000f2b00000</span><span class="token punctuation">)</span>
 <span class="token class-name">Metaspace</span>       used <span class="token number">3092</span>K<span class="token punctuation">,</span> capacity <span class="token number">4496</span>K<span class="token punctuation">,</span> committed <span class="token number">4864</span>K<span class="token punctuation">,</span> reserved <span class="token number">1056768</span>K
  <span class="token keyword">class</span> space    used <span class="token number">338</span>K<span class="token punctuation">,</span> capacity <span class="token number">388</span>K<span class="token punctuation">,</span> committed <span class="token number">512</span>K<span class="token punctuation">,</span> reserved <span class="token number">1048576</span>K
</code></pre> 
<p>为什么指定了堆的初始内存大小和最大内存大小为640M，但是输出的却是613M呢？<br> 这是因为堆空间中的年轻代分为From区和To区即s0和s1区，从GC日志来看堆的内存大小计算为：年轻代（伊甸园Eden区+From区/To区）+老年代(163840K+27136K+437248K=613.5M).</p> 
<h3><a id="3__69"></a>3. 年轻代与老年代</h3> 
<p>存储在JVM中的Java对象可以被划分为两类，分别是：</p> 
<ul><li>生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li><li>对象的生命周期非常长，在某些极端的情况下还能够与JVM的生命周期保存一致。</li></ul> 
<p>Java堆区进一步细分的话，可以划分为年轻代（YongGen）和老年代（OldGen），其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）。<br> <img src="https://images2.imgbox.com/0f/03/G7B9tmLM_o.png" alt="在这里插入图片描述"></p> 
<p>配置新生代与老年代在堆结构的占比：</p> 
<ul><li>默认<code>-XX:NewRatio=2</code>，表示新生代占1，老年代占2，新生代占整个堆的1/3，</li><li>可以修改<code>-XX:NewRatio=4,</code>表示新生代占1，老年代占4，新生代占整个堆的1/5。但是<mark>该参数在开发中一般不会调</mark>。<br> <img src="https://images2.imgbox.com/16/35/mXp0pDKB_o.png" alt="在这里插入图片描述"></li></ul> 
<p>在Hotspot虚拟机中，新生代中的Eden空间和另外两个Survivor空间所占的比例是8:1:1。开发人员可以通过选项“<code>-XX:SurvivorRatio</code>”调整这个空间比例。比如<code>-XX：SurvuvirRatio=8</code>（默认参数值）。</p> 
<p>几乎所有的Java对象都是在Eden区被new出来的，绝大部分的Java对象的销毁都在新生代进行了。IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。可以使用选项“<code>-Xmn</code>”设置新生代最大内存大小。这个参数一般使用默认值即可，一般不进行设置，如果同时使用了参数<code>-XX:NewRatio</code>设置新生代和老年代的比例则会使用<code>-Xmn</code>参数设置的新生代最大内存大小。<br> <img src="https://images2.imgbox.com/17/7d/SSkEYvt5_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4__88"></a>4. 对象分配过程</h3> 
<p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p> 
<ol><li>new的对象先放伊甸园区，此区大小有限制</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放在伊甸园区。</li><li>然后将伊甸园区中的剩余对象移动到幸存者0区</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的对象，如果这一次GC没有被回收，就会放到幸存者1区。</li><li>如果再次经历垃圾回收，此时会重新放回幸存者0区</li><li>一般经过15次垃圾回收，仍然存活就进入养老区。可以通过设置参数：<code>-MM:MaxTenuringThreshold=&lt;N&gt;</code>进行设置。</li><li>在养老区的对象相当悠闲，当养老区内存不足时，再次触发GC:Major GC,进行养老区的内存清理。</li><li>若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常。</li></ol> 
<p>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不再永久区/元空间收集。</p> 
<p>新对象申请堆空间的流程图：<br> <img src="https://images2.imgbox.com/7b/03/iNQXLedA_o.png" alt="在这里插入图片描述"><br> 总结</p> 
<ul><li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</li><li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</li></ul> 
<h3><a id="5_Minor_GCMajor_GCFull_GC_109"></a>5. Minor GC、Major GC与Full GC</h3> 
<p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。</p> 
<p>针对<strong>Hotspot VM</strong>的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（<strong>Partial GC</strong>），一种是整堆收集（<strong>FullGC</strong>）</p> 
<ul><li>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：<br> ○ 新生代收集（<strong>Minor GC / Young GC</strong>）：只是新生代的垃圾收集<br> ○ 老年代收集（<strong>Major GC / Old GC</strong>）：只是老年代的圾收集。 目前，只有CMS垃圾收集器会有单独收集老年代的行为。<mark>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收</mark>。<br> ○ 混合收集（<strong>Mixed GC</strong>）：收集整个新生代以及部分老年代的垃圾收集。 （目前，只有G1 垃圾收集器会有这种行为）</li><li>整堆收集（<strong>Full GC</strong>）：收集整个java堆和方法区的垃圾收集。</li></ul> 
<h4><a id="51_Minor_GC_119"></a>5.1 Minor GC</h4> 
<p>年轻代GC（Minor GC）触发机制：当年轻代空间不足时，就会触发Minor GC，每次Minor GC会清理年轻代的内存，这里的年轻代指的是Eden区满，Survivor满不会引发GC。</p> 
<p>因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。Minor GC会引发STW（STOP WORK），暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行。<br> <img src="https://images2.imgbox.com/c2/92/6dLPuwdf_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="52_Major_GC_125"></a>5.2 Major GC</h4> 
<p>老年代Major GC触发机制：<br> Major GC指的是发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就会直接进行Major GC的策略选择过程）。也就是在老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC。</p> 
<p>Major GC的速度一般比Minor GC慢10倍以上，STW的时间更长。如果Major GC后，内存还不足，就报OOM了。Major GC的速度一般会比Minor GC慢10倍以上。</p> 
<h4><a id="53_Full_GC_131"></a>5.3 Full GC</h4> 
<p>Full GC是开发或调优中尽量要避免的。整堆收集Full GC的触发机制，触发Full GC执行的情况有如下五种：</p> 
<ol><li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区，Survivor0（From）区向Survivor1（To）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</li></ol> 
<h3><a id="6__140"></a>6. 堆空间分代思想</h3> 
<p>为什么需要把Java堆分代？不分代就不能正常工作了吗？<br> 经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。堆空间采用分代，分为新生代和老年代：</p> 
<ul><li>新生代：由Eden、两块大小相同的Survivor（又称为from/to，so/s1）构成， to总为空。</li><li>老年代：存放新生代中经历多次GC仍然存活的对象。</li></ul> 
<p><img src="https://images2.imgbox.com/23/77/wNIifhMe_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/09/6e/Imaen5Z5_o.png" alt="在这里插入图片描述"></p> 
<p>其实不分代完全可以，分代的唯一理由就是<strong>优化GC性能</strong>。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放在某个地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p> 
<h3><a id="7__154"></a>7. 内存分配策略</h3> 
<p>如果对象在Eden区出生并经过第一次MinorGC后仍然存活，并且能被Survivor区容纳的话，将被移动到Survivor空间中，并将对象年龄设为1.对象在Survivor区中每经历一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，每个JVM、每个垃圾收集器有所不同），就会晋升到老年代中。对象晋升老年代的年龄阈值，可以通过选项<code>-XX:MaxTenuringThreshold</code>来设置。</p> 
<p>针对不同年龄段的对象分配原则如下所示：</p> 
<ul><li>优先分配到Eden</li><li>Eden放不下的大对象直接分配到老年代（尽量避免程序中出现过多的大对象）</li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。</li><li>空间分配担保： <code>-XX:HandlePromotionFailure</code></li></ul> 
<h3><a id="8_TLAB_164"></a>8. 为对象分配内存：TLAB</h3> 
<p>什么是TLAB（<strong>Thread Local Allocation Buffer</strong>）？<br> 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓冲区域TLAB，它包含在Eden空间内。多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，这种内存分配方式称为快速分配策略。<br> <img src="https://images2.imgbox.com/94/8c/TI2h5Dlc_o.png" alt="在这里插入图片描述"><br> 为什么有TLAB（<strong>Thread Local Allocation Buffer</strong>）？<br> 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据，由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的，为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p> 
<p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。在程序中，开发人员可以通过选项“<code>-XX:UseTLAB</code>”设置是否开启TLAB空间。</p> 
<p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“<code>-XX:TLABWasterTargetPercent</code>”设置TLAB空间所占用Eden空间的百分比大小。<mark>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存</mark>。<br> <img src="https://images2.imgbox.com/71/46/llVqfVEL_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="9__177"></a>9. 堆空间的参数设置</h3> 
<blockquote> 
 <p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html" rel="nofollow">官网地址</a></p> 
</blockquote> 
<table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-XX:PrintFlagsInitial</td><td>查看所有参数的默认初始值</td></tr><tr><td>-XX:PrintFlagsFinal</td><td>查看所有参数的最终值</td></tr><tr><td>-Xms</td><td>初始堆空间内存 （默认为物理内存的1/64）</td></tr><tr><td>-Xmx</td><td>最大堆空间内存 （默认为物理内存的1/4）</td></tr><tr><td>-Xmn</td><td>设置新生代的大小 （初始值及最大值）</td></tr><tr><td>-XX:NewRatio</td><td>配置新生代与老年代在堆结构的占比</td></tr><tr><td>-XX:SurvivorRatio</td><td>设置新生代中Eden和s0/s1空间的比例</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>设置新生代垃圾的最大年龄</td></tr><tr><td>-XX:+PrintGCDetails</td><td>输出详细的GC处理日志</td></tr><tr><td>-XX:+PrintGC/-verbose:gc</td><td>打印GC简要信息</td></tr><tr><td>-XX:HandlePromotionFailure</td><td>是否设置空间分配担保</td></tr></tbody></table> 
<p>关于分配担保：</p> 
<p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p> 
<p>● 如果大于，则此次Minor GC是安全的<br> ● 如果小于，则虚拟机会查看<code>-XX:HandlePromotionFailure</code>设置值是否允许担保失败。</p> 
<p>如果<code>HandlePromotionFailure=true</code>，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于，则改为进行一次Full GC。</p> 
<p>如果<code>HandlePromotionFailure=false</code>，则改为进行一次Full GC。</p> 
<p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为<mark>只要老年代的连续空间大于新生代对象总大小</mark>或者<mark>历次晋升的平均大小就会进行Minor GC</mark>，否则将进行FullGC。</p> 
<h3><a id="10__206"></a>10. 逃逸分析与代码优化</h3> 
<p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p> 
<blockquote> 
 <p>随着JIT编译期的发展与<mark>逃逸分析技术</mark>逐渐成熟，<mark>栈上分配</mark>、<mark>标量替换优化技术</mark>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p> 
</blockquote> 
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<mark>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</mark>.。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p> 
<p>此外，前面提到的基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p> 
<h4><a id="101__215"></a>10.1 逃逸分析概述</h4> 
<p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p> 
<p>逃逸分析的基本行为就是分析对象动态作用域：</p> 
<ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul> 
<p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除。没有发生逃逸的代码示例：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">my_method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">V</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// use v</span>
    <span class="token comment">// ....</span>
    v <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>发生逃逸的代码示例：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StringBuffer</span> <span class="token function">createStringBuffer</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sb<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>更多代码示例：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EscapeAnalysis</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token class-name">EscapeAnalysis</span> obj<span class="token punctuation">;</span>


    <span class="token comment">/**
     * 方法返回EscapeAnalysis，发生逃逸
     *
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">EscapeAnalysis</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> obj <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">EscapeAnalysis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 为成员属性赋值，发生逃逸
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EscapeAnalysis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 对象的作用域仅在当前方法中有效，没有发生逃逸
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">useEscapeAnalysis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">EscapeAnalysis</span> escapeAnalysis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EscapeAnalysis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 引用成员变量的值，发生逃逸
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">useEscapeAnalysis2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">EscapeAnalysis</span> escapeAnalysis <span class="token operator">=</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>在JDK 6u23版本之后，HotSpot中默认就已经开启了逃逸分析。如果使用的是较早版本，开发人员可以通过选项<code>-XX:+DoEscapeAnalysis</code>显式开启逃逸分析，通过选项<code>-XX:+PrintEscapeAnalysis</code>查看逃逸分析的筛选结果。</p> 
<p><strong>结论：栈上分配可以有效减少Java程序中同步负载和堆内存空间分配的压力，所以开发中能使用局部变量的，就不要使用在方法外定义。</strong></p> 
<h4><a id="102__291"></a>10.2 代码优化</h4> 
<blockquote> 
 <p>可参考博客：https://www.cnblogs.com/lisingshen/p/11586160.html</p> 
</blockquote> 
<p>使用逃逸分析，编译器可以对代码做如下优化：</p> 
<ol><li><strong>栈上分配</strong>。将堆分配转化为栈分配，如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</li><li><strong>同步省略</strong>。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li><strong>分离对象或标量替换</strong>。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ol> 
<h5><a id="1021__298"></a>10.2.1 栈上分配</h5> 
<p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。常见的栈上分配的场景有：给成员变量赋值、方法返回值、实例引用传递。</p> 
<h5><a id="1022__300"></a>10.2.2 同步省略</h5> 
<p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。在动态编译同步块的时候，JIT编译器可以借助逃逸分析来<mark>判断同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程</mark>。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁清除。</p> 
<p>举例：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Object</span> hellis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>hellis<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hellis<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Object</span> hellis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hellis<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="1023__322"></a>10.2.3 标量替换</h5> 
<p>标量（Scalar）是指一个无法再分解成更小的数据的数据，Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为它可以分解成其他聚合量和标量。</p> 
<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替，这个过程就是标量替换。</p> 
<p><img src="https://images2.imgbox.com/1e/87/Fs7e5I0z_o.png" alt="在这里插入图片描述"><br> 以上代码，经过标量替换后，就会变成：<br> <img src="https://images2.imgbox.com/ee/c4/A81waNcp_o.png" alt="在这里插入图片描述"><br> 可以看到，Point这个聚合量经过逃逸分析后，发现它并没有逃逸，就被替换成两个标量。标量替换的好处就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。标量替换为栈上分配提供了很好的基础。</p> 
<p>标量替换参数设置：参数<code>-XX:+EliminateAllocations</code>，开启标量替换，允许将对象打散分配在栈上。</p> 
<h4><a id="103__334"></a>10.3 逃逸分析总结</h4> 
<p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</p> 
<p>其根本原因就是<mark>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程</mark>。</p> 
<p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p> 
<p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</p> 
<p>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p> 
<p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p> 
<h3><a id="11__349"></a>11. 堆总结</h3> 
<ol><li> <p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p> </li><li> <p>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</p> </li><li> <p>当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。当GC发生在老年代时则被称为MajorGc或者FullGC。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p> </li></ol> 
<h3><a id="12__355"></a>12. 对象的实例化</h3> 
<h4><a id="121__356"></a>12.1 创建对象的方式</h4> 
<ul><li>new：最常见的方式、Xxx的静态方法，XxxBuilder/XxxFactory的静态方法</li><li>Class的newInstance方法：反射的方式，只能调用空参的构造器，权限必须是public</li><li>Constructor的newInstance(XXX)：反射的方式，可以调用空参、带参的构造器，权限没有要求</li><li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口，实现clone()</li><li>使用序列化：从文件中、从网络中获取一个对象的二进制流</li><li>第三方库 Objenesis</li></ul> 
<h4><a id="122__364"></a>12.2 创建对象的步骤</h4> 
<p>前面所述是从字节码角度看待对象的创建过程，现在从执行步骤的角度来分析：<br> <img src="https://images2.imgbox.com/6c/a6/HWq7l1uY_o.png" alt="在这里插入图片描述"></p> 
<ol><li>判断对象对应的类是否加载、链接、初始化</li></ol> 
<p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以<mark>ClassLoader+包名+类名</mark>为key进行查找对应的class文件。</p> 
<ul><li>如果没有找到文件，则抛出<code>ClassNotFoundException</code>，</li><li>如果找到，则进行类加载，并生成对应的Class类对象。</li></ul> 
<ol start="2"><li>为对象分配空间<br> 首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</li></ol> 
<p><strong>如果内存规整</strong>：虚拟机将采用的是==指针碰撞法（Bump The Point）==来为对象分配内存。</p> 
<ul><li><strong>指针碰撞法（Bump The Point）</strong>：所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</li></ul> 
<p><strong>如果内存不规整</strong>：虚拟机需要维护一个==空闲列表（Free List）==来为对象分配内存。</p> 
<ul><li><strong>空闲列表法（Free List）</strong>：已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。</li></ul> 
<p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p> 
<ol start="3"><li>处理并发安全问题<br> 在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用了两种方式解决并发问题：</li></ol> 
<ul><li>采用**CAS（Compare And Swap）**失败重试、区域加锁；保证指针更新操作的原子性</li><li>**TLAB（Thread Local Allocation Buffer）**把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，成为本地线程分配缓冲区。虚拟机是否使用TLAB：通过设置 <code>-XX:+UseTLAB</code>参数来设定</li></ul> 
<ol start="4"><li> <p>初始化分配到的空间<br> 内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。</p> </li><li> <p>设置对象的对象头<br> 将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p> </li><li> <p>执行init方法进行初始化<br> 在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。因此一般来说，new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</p> </li></ol> 
<p><strong>给对象属性赋值的操作</strong></p> 
<ul><li>属性的默认初始化</li><li>显式初始化</li><li>代码块中初始化</li><li>构造器中初始化</li></ul> 
<p><strong>对象实例化的过程</strong></p> 
<ol><li>加载类元信息</li><li>为对象分配内存</li><li>处理并发问题</li><li>属性的默认初始化（零值初始化）</li><li>设置对象头信息</li><li>属性的显示初始化、代码块中初始化、构造器中初始化</li></ol> 
<h3><a id="13__416"></a>13. 对象的内存布局</h3> 
<p><img src="https://images2.imgbox.com/28/54/Ibxfp39A_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/a0/3e/RFmWfxVj_o.png" alt="在这里插入图片描述"></p> 
<p>代码举例：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Customer</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token number">1001</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token class-name">Account</span> acct<span class="token punctuation">;</span>

    <span class="token punctuation">{<!-- --></span>
        name <span class="token operator">=</span> <span class="token string">"匿名客户"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Customer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomerTest</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Customer</span> cust <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Customer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>代码对应的对象的内存布局如下图所示：<br> <img src="https://images2.imgbox.com/ae/7d/RXb81hGE_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="131_Header_451"></a>13.1 对象头（Header）</h4> 
<p>对象头包含了两部分，分别是运行时元数据（Mark Word）和类型指针。如果是数组，还需要记录数组的长度。</p> 
<p>运行时元数据：</p> 
<ul><li>哈希值（HashCode）</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>偏向时间戳</li></ul> 
<p>类型指针：指向类元数据InstanceKlass，确定该对象所属的类型。</p> 
<h4><a id="132__466"></a>13.2 实例数据</h4> 
<p>它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）</p> 
<ul><li>相同宽度的字段总是被分配在一起</li><li>父类中定义的变量会出现在子类之前</li><li>如果CompactFields参数为true（默认为true）：子类的窄变量可能插入到父类变量的空隙</li></ul> 
<h4><a id="133__474"></a>13.3 对齐填充</h4> 
<p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p> 
<h3><a id="14__476"></a>14. 对象访问定位</h3> 
<p>创建对象的目的是为了使用它，JVM是通过栈帧中的对象引用定位到对象实例地址，然后访问到其内部的对象实例的。<mark>对象访问方式主要有两种：句柄访问和直接指针</mark>。<br> <img src="https://images2.imgbox.com/24/cc/kHlMWn7b_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="141__480"></a>14.1 句柄访问</h4> 
<p><img src="https://images2.imgbox.com/43/97/P1aPKhTB_o.png" alt="在这里插入图片描述"><br> 使用句柄访问的好处：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中对象实例数据指针即可，reference本身不需要被修改。</p> 
<h4><a id="142__484"></a>14.2 直接指针</h4> 
<p>Hotspot虚拟机采用直接指针的方式进行对象访问定位。直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p> 
<p><img src="https://images2.imgbox.com/09/76/1SPXWQvF_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>笔记总结自视频教程：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ" rel="nofollow">尚硅谷宋红康JVM全套教程（详解java虚拟机）</a><br> 参考：<br> 1.《深入理解Java虚拟机》第2版</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d01433a36200b9e1fb5a422008ca357e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">sortablejs插件在el-table中的运用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2aa39efdb8f6ce24d349ef67969875e8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">处理vue3&#43;vite报错：vite.defineConfig is not a function</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>