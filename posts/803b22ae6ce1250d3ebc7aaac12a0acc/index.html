<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43; 学习错误列表 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43; 学习错误列表" />
<meta property="og:description" content="c&#43;&#43; 学习错误列表
这是学习和使用c&#43;&#43;语言过程中，出现的错误及解决方法列表,随着学习和实践深入，此列表将不断更新。
No.1:prog4.cpp(8) : error C2440: “初始化”: 无法从“const int”转换为“int &amp;” 转换丢失限定符
#include &lt;iostream&gt; int main() { const int iSize = 1024; int iCnt = 0; const int &amp;iRefval = iSize;//ok int &amp;iRef = iSize;//不允许非const引用绑定到const对象 const int &amp;icRef = iCnt;//const引用可以绑定到右值 std::cout&lt;&lt;&#34;iRefval:	&#34;&lt;&lt;iRefval&lt;&lt;std::endl; std::cout&lt;&lt;&#34;icRef:	&#34;&lt;&lt;icRef&lt;&lt;std::endl; return 0; } 解决办法: 非const引用绑定到const对象，如果允许的话，那么可以通过非const引用修改const原对象，这个出现一个矛盾，因此c&#43;&#43;不允许执行此操作。解决方法就是使用非const引用绑定到同类型的非const对象，使用const引用绑定到不同但相关的类型的对象或者右值。 No.2: prog2.cpp(8) : error C2664: &#39;__thiscall std::list&lt;int,class std::allocator&lt;int&gt; &gt;::std::list&lt;int,class std::allocator&lt;int&gt; &gt;(unsigned int,const int &amp;, const class std::allocator&lt;int&gt; &amp;)&#39; : cannot convert parameter 1 from &#39;class std::deque&lt;int,class std::allocator&lt;int&gt; &gt;::iterator&#39; to &#39;unsigned int&#39;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/803b22ae6ce1250d3ebc7aaac12a0acc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-03-03T15:25:21+08:00" />
<meta property="article:modified_time" content="2013-03-03T15:25:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43; 学习错误列表</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="text-align:center"> 
 <span style="font-size:24px"><strong>c++ 学习错误列表<br> </strong></span> 
</div> 
<br> 
<p><span style="font-size:18px">这是学习和使用c++语言过程中，出现的错误及解决方法列表,随着学习和实践深入，此列表将不断更新。</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<h3><span style="font-size:18px">No.1:prog4.cpp(8) : <span style="color:#FF0000"> error C2440</span>: “初始化”: 无法从“const int”转换为“int &amp;”</span></h3> 
<p><span style="font-size:18px">        转换丢失限定符</span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main()
{
	const int iSize = 1024;
	int iCnt = 0;
	const int &amp;iRefval = iSize;//ok
	int &amp;iRef = iSize;//不允许非const引用绑定到const对象
	const int &amp;icRef = iCnt;//const引用可以绑定到右值
	std::cout&lt;&lt;"iRefval:	"&lt;&lt;iRefval&lt;&lt;std::endl;
	std::cout&lt;&lt;"icRef:	"&lt;&lt;icRef&lt;&lt;std::endl;
	return 0;
}</code></pre> 
<br> 
<span style="font-size:14px"><strong><span style="color:#FF0000">解决办法:</span></strong>  非const引用绑定到const对象，如果允许的话，那么可以通过非const引用修改const原对象，这个出现一个矛盾，因此c++不允许执行此操作。解决方法就是使用非const引用绑定到同类型的非const对象，使用const引用绑定到不同但相关的类型的对象或者右值。</span> 
<p></p> 
<p><span style="font-size:18px"><br> </span></p> 
<h3><span style="font-size:18px">No.2: prog2.cpp(8) : <span style="color:#ff0000"> <strong>error C2664</strong></span>: '__thiscall std::list&lt;int,class std::allocator&lt;int&gt; &gt;::std::list&lt;int,class std::allocator&lt;int&gt; &gt;(unsigned int,const int &amp;,</span></h3> 
<p><span style="font-size:18px">const class std::allocator&lt;int&gt; &amp;)' : cannot convert parameter 1 from 'class std::deque&lt;int,class std::allocator&lt;int&gt; &gt;::iterator' to 'unsigned int'<br>         No user-defined-conversion operator available that can perform this conversion, or the operator cannot be called<br> </span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-cpp">//prog2.cpp
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;deque&gt;
using namespace std;
void main()
{     
	 //Define a list that holds elements that are deques that hold ints
	 deque&lt;int&gt;   ideque(10,1);
	 list&lt;int&gt;  ilist(ideque.begin(),ideque.end());
	 for(list&lt;int&gt;::const_iterator itbegin=ilist.begin(),itend=ilist.end();itbegin!=itend;++itbegin)
		 cout&lt;&lt;*itbegin&lt;&lt;endl;
}</code></pre> 
<p> </p> 
<p><span style="font-size:18px"><strong><span style="color:#ff0000">解决方法</span></strong>：vc 6.0对模板库支持不够好，使用vs2010编译通过。</span></p> 
<p><span style="font-size:18px"></span> </p> 
<h3><span style="font-size:18px">No.3 TextQuery.cpp(63) : <span style="color:#ff0000"> warning C4172</span>: returning address of local variable or temporary</span><span style="font-size:18px"><br> </span></h3> 
<pre><code class="language-html">//返回单词出现的行号set
const set&lt;int&gt; &amp; TextQuery::RunQuery(string word) const
{     
      map&lt; string,set&lt;int&gt; &gt;::const_iterator it = m_mapWordLine.find(word);
	  if(it != m_mapWordLine.end())
		return it-&gt;second;
	  else
		return set&lt;int&gt;();//emptyset
}</code></pre> 
<p><br>  </p> 
<p><span style="font-size:18px"><span style="color:#ff0000"><strong>解决方法</strong></span>：愿意是返回set对象的const引用以减轻复制set对象的负担，但是这里返回空的set对象的局部引用是错误的，c++ primer 原文采用的方法是返回set对象，不使用引用，这也是一种解决方法。另外使用std::vector&lt;std::string&gt;::size_type  比int型的set好。</span></p> 
<p><span style="font-size:18px"></span> </p> 
<h3><span style="font-size:18px">No.4 printchar.cpp(13) : <span style="color:#ff0000"> error C2440</span>: 'initializing' : cannot convert from 'char *' to 'const class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; *'</span></h3> 
<p><span style="font-size:18px">        Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or function-style cast</span></p> 
<pre><code class="language-html">//输出一行中所有字符
void printchar(string &amp;line)
{
    istringstream iss(line);
	string word;
	while(iss&gt;&gt;word)
	    for(vector&lt;string&gt;::const_iterator itbegin=word.begin(),itend=word.end();itbegin != itend; ++itbegin)
			cout&lt;&lt;*itbegin&lt;&lt;endl;
}
</code></pre> 
<p><span style="font-size:18px"><strong><span style="color:#ff0000">解决方法</span></strong>：标准库string对象可以使用迭代器操作 ，但是其迭代器要正确使用，应该使用string::const_iterator 后者使用下标操作来获取string对象中的字符。</span><br> </p> 
<h3>No.5 <span style="color:#FF0000">fatal error  "vector iterator + offset out of range"</span> "standard C++ libraries out of range "</h3> 
<p><span style="font-size:14px">代码如下：</span></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;iterator&gt;//使用back_inserter 
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
void main()
{     
	 vector&lt;int&gt; ivec;
	 try
	 {   
		fill_n(ivec.begin(),10,1);//error  should use fill_n (back_inserter(ivec), 10, 1); 
	    for(vector&lt;int&gt;::iterator itbegin=ivec.begin(),itend=ivec.end();itbegin!=itend;++itbegin)
		    cout&lt;&lt;*itbegin&lt;&lt;endl;
	 }
	 catch (runtime_error err)
	 {  
		cerr &lt;&lt; "Error: "&lt;&lt;err.what()&lt;&lt;endl;
	 }
	 catch(out_of_range or)
	 {
	     cerr &lt;&lt; "Error: "&lt;&lt;or.what()&lt;&lt;endl;
	 }
	 catch(exception ex)
	 {
	    cerr &lt;&lt; "Error: "&lt;&lt;ex.what()&lt;&lt;endl;
	 }
	  
}
</code></pre> 
<br> 
<span style="font-size:14px"><strong><span style="color:#FF0000">解决方法</span></strong>：fill_n()函数将在vector中从头开始，将指定个数的元素设置为给定的值。fill_n函数假定对指定数量的元素做写操作是安全的。初学者常犯的错误的是：在没有元素的空容器上调用 <tt>fill_n</tt> 函数，因此需要使用back_inserter ，这种插入迭代器。当使用插入迭代器赋值时，则会在容器中添加一个新元素，其值等于赋值运算的右操作数的值。因此需将代码改为：</span> 
<p></p> 
<p><span style="font-size:14px">fill_n (back_inserter(ivec), 10, 1);</span><span style="font-size:14px"><strong><br> </strong></span></p> 
<h3><span style="font-size:14px"><strong>No.6</strong>  prog7.cpp(8) :<strong> <span style="color:#ff0000"> error C2780</span>: </strong>'void __cdecl std::sort(_RI,_RI,_Pr)' : expects 3 arguments - 2 provided</span></h3> 
<p><span style="font-size:14px">        C:\Program Files\Microsoft Visual Studio\VC98\include\algorithm(588) : see declaration of 'sort'<br> prog7.cpp(8) : <span style="color:#ff0000"><strong>error C2782:</strong></span> 'void __cdecl std::sort(_RI,_RI)' : template parameter '_RI' is ambiguous<br>         could be 'class std::reverse_iterator&lt;int *,int,int &amp;,int *,int&gt;'<br>         or       'int *'</span></p> 
<p><span style="font-size:14px">代码如下：</span></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
void main()
{     
	 vector&lt;int&gt; ivec1(10,1);
	 sort(ivec1.begin(), ivec1.rend());//类型不匹配的错误 可以在编译时检查出来
}
</code></pre> 
<br> 
<strong><span style="color:#ff0000">解决方法：</span></strong> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p><span style="font-size:14px">sort函数重载有两个版本，所以出现上面的错误提示，无论哪个版本，要求给定一对迭代器范围，而在标准库中，有输入范围的泛型算法要求其两个迭代器类型完全一样，包括const属性。要么都是const，要么都是非const，否则无法通过编译。</span></p> 
<p><span style="font-size:14px">上述的begin函数返回是普通迭代器，而rend函数返回的是</span><span style="font-size:14px">反向迭代器</span><span style="font-size:14px">，因此两个实参类型不匹配，出现了上述错误，解决方法就是正确的传递实参，使用类型完全一样的迭代器标记范围。</span></p> 
<h3>No.7  ..\sales_item\sales_item.h(24) :<span style="color:#FF0000">error C2804:</span>binary 'operator +' has too many parameters</h3> 
<p><span style="font-size:14px">代码如下：</span></p> 
<pre><code class="language-cpp">// header file Sales_item.h
#include &lt;iostream&gt;
#include &lt;string&gt;
class Sales_item 
{   
	// private members 
	private:
	std::string isbn;
	 unsigned units_sold;
	double revenue;
    //public method
	public:
	..
	 //Overloaded Operator as member function   
	Sales_item&amp; operator+=(const Sales_item&amp;);//Compound Assignment Operators
	Sales_item operator+(const Sales_item&amp; lhs, const Sales_item&amp; rhs);
};
// implement file  Sales_item.cpp
using std::istream;  
using std::ostream;
//Overloaded Operator as nonmember functions
inline Sales_item Sales_item::operator+(const Sales_item&amp; lhs, const Sales_item&amp; rhs)
{
	  Sales_item ret(lhs);  // copy lhs into a local object that we'll return
                  ret += rhs;           // add in the contents of rhs
                return ret; // return ret by value ,not by reference
}</code></pre> 
<p><br>  </p> 
<p><span style="font-size:14px; color:#ff0000"><strong>解决方法</strong><span style="color:#000000">：+操作符包括两个操作数，应该重载为普通非成员函数。</span></span></p> 
<p><span style="font-size:14px; color:#ff0000"><span style="color:#000000">注意重载操作符的形参数目（包括成员函数的隐式 this 指针）与操作符的操作数数目相同。对称的操作符，如算术操作符、相等操作符、关系操作符和位操作符，最好定义为普通非成员函数。因此+应该重载为<span style="font-size:14px">普通非成员函数</span>。这里重载为成员函数时多了一个this形参，故对于+操作符来说，出现参数过多的错误。</span></span></p> 
<p><span style="font-size:14px">即书写为：</span></p> 
<span style="font-size:14px"></span> 
<pre><code class="language-cpp">// header file
Sales_item operator+(const Sales_item&amp; lhs, const Sales_item&amp; rhs);
//implement file
//Overloaded Operator as nonmember functions
inline Sales_item operator+(const Sales_item&amp; lhs, const Sales_item&amp; rhs)
{
	  Sales_item ret(lhs);  // copy lhs into a local object that we'll return
      ret += rhs;           // add in the contents of rhs
      return ret; // return ret by value ,not by reference
}
</code></pre> 
<p><br>  </p> 
<span style="font-size:14px"></span> 
<h3><strong> <span style="font-size:14px">No.8  </span></strong><span style="font-size:14px">Compiling...main.cppLinking...main.obj :<span style="color:#ff0000"><strong>error LNK2001</strong></span>: unresolved external symbol "class std::basic_ostream&lt;char,struct std::char_traits&lt;char&gt; &gt; &amp;<strong><span style="color:#ff0000">__cdecl<span style="color:#ff0000">operator&lt;&lt;</span></span><span style="color:#ff0000">(class std::basic_ostream&lt;char,struct std::char_traits&lt;char&gt; &gt; &amp;,class Sales_item const &amp;)"</span></strong>(</span><a target="_blank" href="mailto:??6@YAAAV?%24basic_ostream@DU%24char_traits@D@std@@@std@@AAV01@ABVSales_item@@@Z" rel="nofollow noopener noreferrer"><span style="font-size:14px">??6@YAAAV?$basic_ostream@DU$char_traits@D@std@@@std@@AAV01@ABVSales_item@@@Z</span></a><span style="font-size:14px">)</span></h3> 
<p><span style="font-size:14px">....(省略后续同类错误)</span></p> 
<p><span style="font-size:14px">Sales_item.exe - 4 error(s), 0 warning(s)</span></p> 
<p><span style="font-size:14px; color:#ff0000"><strong>错误原因之一，在于将inline函数的实现放在了单独的实现文件中了，解决方法：</strong></span></p> 
<p><span style="color:#000000"><span style="font-size:14px">将inline函数的实现放置在头文件中。具体请参考：《<u><a target="_blank" href="http://blog.csdn.net/clever101/article/details/5747626" rel="noopener noreferrer">类的内联函数的实现应该放在哪里</a>》一文。</u></span></span></p> 
<p> </p> 
<h3><span style="font-size:14px"><strong>N0.9</strong> conflict.cpp(7) : <span style="color:#FF0000"> <strong>error C2872</strong></span>: “count”: 不明确的符号</span></h3> 
<p><span style="font-size:14px">        可能是“conflict.cpp(4) : int count”<br>         或       “C:\Program Files\Microsoft Visual Studio 11.0\VC\INCLUDE\xutility(3251) : iterato<br> r_traits&lt;_Iter&gt;::difference_type std::count(_InIt,_InIt,const _Ty &amp;)”<br> conflict.cpp(12) : error C2872: “count”: 不明确的符号<br>         可能是“conflict.cpp(4) : int count”<br>         或       “C:\Program Files\Microsoft Visual Studio 11.0\VC\INCLUDE\xutility(3251) : iterato<br> r_traits&lt;_Iter&gt;::difference_type std::count(_InIt,_InIt,const _Ty &amp;)”</span><br> <br> <br> <span style="font-size:14px">出错代码</span></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int count = 0;
int increment()
{
    return ++count;// error, identifier count is ambiguous
}
int main()
{   
	increment();
	cout&lt;&lt;"count=	"&lt;&lt;count&lt;&lt;endl;
	return 0;
}</code></pre> 
<br> 
<br> 
<span style="font-size:14px">解决办法:  使用命名机制来避免命名冲突，这里count既可以是程序中全局变量count，也可能是<code>std::count</code>，因此引起歧义，导致出错。解决方法:</span> 
<p><span style="font-size:14px">1)尽量少用directive方式来引用命名空间：</span><span style="font-size:14px"><em>(<span style="font-size:14px">directive方式</span>即</em><code>using namespace std;)</code></span></p> 
<span style="font-size:14px">取而代之，使用use std::cout,引用命名空间的成员,而不是将其置为后续名字的默认命名空间。</span> 
<br> 
<p></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

using std::cout;//使用命名空间一个名字
using std::endl;

int count = 0;
int increment()
{
    return ++count;
}
int main()
{   
	increment();
	cout&lt;&lt;"count=	"&lt;&lt;count&lt;&lt;endl;
	return 0;
}</code></pre> 
<br> 
<p></p> 
<p><span style="font-size:14px">2)使用命名空间引用变量,在命名空间中定义变量、函数和类。<br> </span></p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

namespace global {
	int count = 0;//重新定义一个命名空间
}
int increment()
{
    return ++global::count;
}
int main()
{   
	increment();
	cout&lt;&lt;"count=	"&lt;&lt;global::count&lt;&lt;endl;
	return 0;
}</code></pre> 
<br> 
<h3>No.10  <span style="color:#FF0000">error C2664: </span>“find_char”: 不能将参数 1 从“const char [14]”转换为“std::string &amp;</h3> 
<br> 
<p><span style="font-size:14px">出错代码:</span></p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using std::cout;
using std::endl;
using std::string;
//const引用形参举例
//非const引用形参只能与完全同类型的非const对象关联
std::size_t find_char(string &amp;s,char c)
{
   string::size_type i = 0;
   while(i != s.size() &amp;&amp; s[i] != c)
	   ++i;
   if(i == s.size())
	   return string::npos;
   else
	   return i;
}
int main(int argc, char *argv[])
{   
	//字面值常量为const对象，调用出错
	if(find_char("Hello, world.",'.') != string::npos)
	{
		cout&lt;&lt;"a sentence."&lt;&lt;endl;
	}
	return 0;
}</code></pre> 
<br> 
<span style="font-size:14px">解决方法: 如果函数不修改相应实参，应该将引用形参定义为const引用，这样字面值常量、const对象也能调用此函数，避免不必要的限制。</span> 
<p></p> 
<h3>No.11  <span style="color:#FF0000">error C2512:</span> “Foo”: 没有合适的默认构造函数可用</h3> 
<p><span style="font-size:14px">错误信息如下:<br> </span></p> 
<p><span style="font-size:14px">C:\Program Files\Microsoft Visual Studio 11.0\VC\INCLUDE\xmemory0(601) : error C2512: “Foo”: 没有<br> 合适的默认构造函数可用<br>         C:\Program Files\Microsoft Visual Studio 11.0\VC\INCLUDE\xmemory0(600): 编译类 模板 成员函数<br> “void std::allocator&lt;_Ty&gt;::construct(_Ty *)”时<br>         with<br>         [<br>             _Ty=Foo<br>         ]<br>         C:\Program Files\Microsoft Visual Studio 11.0\VC\INCLUDE\xmemory0(751): 参见对正在编译的函数<br>  模板 实例化“void std::allocator&lt;_Ty&gt;::construct(_Ty *)”的引用<br>         with<br>         [<br>             _Ty=Foo<br>         ]<br>         C:\Program Files\Microsoft Visual Studio 11.0\VC\INCLUDE\type_traits(743): 参见对正在编译的<br> 类 模板 实例化“std::allocator&lt;_Ty&gt;”的引用<br>         with<br>         [<br>             _Ty=Foo<br>         ]<br>         C:\Program Files\Microsoft Visual Studio 11.0\VC\INCLUDE\vector(655): 参见对正在编译的类 模<br> 板 实例化“std::is_empty&lt;_Ty&gt;”的引用<br>         with<br>         [<br>             _Ty=std::allocator&lt;Foo&gt;<br>         ]<br>         prog26.cpp(15): 参见对正在编译的类 模板 实例化“std::vector&lt;_Ty&gt;”的引用<br>         with<br>         [<br>             _Ty=Foo<br>         ]</span></p> 
<p><span style="font-size:14px">错误代码:</span></p> 
<p> </p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;vector&gt;
using namespace std;

//顺序容器举例
class Foo
{
public:
	Foo(int i):ival(i){}
private:
	int ival;
};
int main(int argc, char *argv[])
{
	vector&lt;Foo&gt; empty;
	vector&lt;Foo&gt; bad(10);
	vector&lt;Foo&gt; ok(10,1);
	return 0;
}</code></pre> 
<br> 
<span style="font-size:14px">解决办法: 实际上根据c++ primer第四版解释构造空的vector时是不调用对象的构造函数的，但是这里用于 x86 的 Microsoft (R) C/C++ 优化编译器 17.00.61030编译显式错误,可能编译器版本不同结果有所不同。</span> 
<p></p> 
<p><span style="font-size:14px">主要看下面的bad(10)这一行,也同样会报错。错误的原因在于类类型对象没有默认的构造函数，因此无法正确初始化，构造vector失败。解决办法，即是为类添加默认的构造函数。</span></p> 
<h3>No.12  <span style="color:#FF0000">error C2440: “return”: 无法从“const Screen”转换为“Screen &amp;”</span></h3> 
<p><span style="font-size:14px">        转换丢失限定符</span></p> 
<p><span style="font-size:14px">出错代码:例子来自c++ primer 4th<br> </span></p> 
<p></p> 
<pre><code class="language-cpp">Screen&amp; Screen::display(std::ostream&amp; os) const
{	
	os &lt;&lt; contents &lt;&lt; '\n';
	return *this;
}</code></pre> 
<p><span style="font-size:14px">解决办法:  c++语言规定，不能从const成员函数返回指向类对象的普通引用，const成员函数只能返回*this作为一个const引用。因此解决办法即是，把成员函数声明为 const Screen&amp; display(std::ostream &amp;os) const;</span></p> 
<p><br> </p> 
<h3><span style="font-size:14px">No.13 <span style="color:#FF0000">error C2662: </span> “Screen::move”: 不能将“this”指针从“const Screen”转换为“ Screen &amp;” 转换丢失限定符</span><br> </h3> 
<p>出错代码:</p> 
<p></p> 
<pre><code class="language-cpp">//成员函数定义
Screen&amp; Screen::move(index r,index c)
{
	index row = r * width;
	cursor = row + c;
	return *this;
}
const Screen&amp; Screen::display(std::ostream&amp; os) const
{	
	os &lt;&lt; contents &lt;&lt; '\n';
	return *this;
}
//main中处理
myScreen.display(cout).move(4,0).set('#').display(cout);</code></pre> 
<br> 
<p></p> 
<p><span style="font-size:14px">解决办法: 通过返回调用函数的对象的引用，可以将一些操作链接起来简化代码书写。</span></p> 
<p><span style="font-size:14px">这里要注意，display函数返回的是const引用，因此在调用move函数中返回非const引用时无法实现转换导致出错。</span></p> 
<p><span style="font-size:14px">解决的办法就是通过成员函数是否为const实现函数重载，定义两套函数，分别作为const成员函数和非const成员函数。<br> </span></p> 
<p><span style="font-size:14px">代码片段如下:</span></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-cpp">//通过是否为const成员函数实现重载
Screen&amp; display(std::ostream &amp;os)
		{do_display(os);return *this;}
const Screen&amp; display(std::ostream &amp;os) const
		{do_display(os);return *this;}
//提取公共函数
void do_display(std::ostream &amp;os) const
		{os&lt;&lt;contents;}
//main中处理
int main()
{
	Screen myScreen(5,3);
	const Screen blank(5,3);

    //调用非const版本display
	myScreen.display(cout).set('#').display(cout);
	cout &lt;&lt; endl;

	//调用 const版本display
	blank.display(cout);
	return 0;
}</code></pre>这样非常量myScreen调用非const版本的display 
<span style="font-size:14px">函数</span>，而const的blank对象调用const版本的display函数，从而避免了混淆。 
<br> 
<p></p> 
<p><br> </p> 
<h3>No.14 <span style="color:#FF0000">error C2758</span>: “ConstInit::cival”: 必须在构造函数基/成员初始值设定项列表中初始化<br>         prog28.cpp(12) : 参见“ConstInit::cival”的声明</h3> 
<p><span style="font-size:14px">解决办法：类的成员可以在构造函数体类或者构造函数列表中初始化，但是某些类型，例如默认构造函数的类类型成员、const后者引用类型的成员则必须在构造函数初始化列表中进行初始化。例如:</span></p> 
<p></p> 
<pre><code class="language-cpp">//const成员初始化
class ConstInit {
public:
	ConstInit(int i,int j)
	{
	   ival = i;
	   cival = j;
	   rival = ival;
	}
private:
	int ival;
    const int cival;
	int &amp;rival;
};
int main(int argc, char *argv[])
{
	ConstInit ci;
}</code></pre> 
<span style="font-size:14px"><br> 这里引用类型rival以及const类型cival都没有在初始化列表中初始化，因此报错。解决办法就是在初始化列表中初始化这些特殊的类成员。</span>如下例所示: 
<p></p> 
<p></p> 
<pre><code class="language-cpp">//const成员初始化
#include &lt;iostream&gt;
using std::cout;
class ConstInit {
public:
	ConstInit(int i=0):ival(i),cival(i),rival(i){}
private:
	int ival;
    const int cival;
	int &amp;rival;
	//只要初始化表达式是一个常量，可以再定义体中进行初始化
    static const int period = 30;
public:
	static const unsigned int ARRAY[3];//静态常量数组
};
const unsigned int ConstInit::ARRAY[3] = {1,3,5};
int main(int argc, char *argv[])
{
	ConstInit ci;
	cout&lt;&lt;ConstInit::ARRAY[1];
}</code></pre> 
<br> 
<p></p> 
<h3><span style="font-size:14px">No .15 <span style="color:#FF0000">error C2248: “Foo::Foo”: 无法访问 private 成员(在“Foo”类中声明)</span></span></h3> 
<p><span style="font-size:14px">        prog29.cpp(12) : 参见“Foo::Foo”的声明<br>         prog29.cpp(7) : 参见“Foo”的声明</span></p> 
<p>出错代码:</p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using std::cout;
using std::endl;
//为了禁止复制，类必须显式声明其复制构造函数为private
//要禁止类的友元和成员复制对象，可以声明但不定义复制构造函数
class Foo
{
public:
	Foo(int i=0):ival(i){}
    int getVal() const {return ival;}
private:
	Foo(const Foo&amp; orig){ival = orig.ival;};//声明为私有
private:
	int ival;
};
int main(int argc, char *argv[])
{
	Foo foo1(1);//ok,调用构造函数
	cout&lt;&lt;foo1.getVal()&lt;&lt;endl;

	Foo foo2;
	foo2 = foo1;//ok,使用合成的赋值操作符
	cout&lt;&lt;foo2.getVal()&lt;&lt;endl;

	Foo foo3(foo1);//error,无法调用复制构造函数
	cout&lt;&lt;foo3.getVal()&lt;&lt;endl;
	return 0;
}</code></pre> 
<br> 
<p><span style="font-size:14px">解决办法： 这里旨在说明三种初始化方式，foo1使用构造函数初始化，foo2使用默认值调用构造函数，而foo3代用私有的复制构造函数因而产生错误。注意，为了禁止复制，类必须显式声明其复制构造函数为private；要禁止类的友元和成员复制对象，可以声明但不定义复制构造函数。遇到这种错误，说明赋值构造函数函数的使用不当。</span></p> 
<h3><span style="font-size:14px">No.16<span style="color:#FF0000"> 与复制构造函数相关的错误</span>.例如:<span style="font-size:14px"><span style="font-size:14px">0x77D9FCAA (ntdll.dll) (prog31.exe 中)处有未经处理的异常: 0xC0000374:<span style="color:#FF0000">堆已损坏。</span> (参数: 0x77DC6668)。</span></span><br> </span></h3> 
<p><span style="font-size:14px">这种错误可能就是与内存有关的释放问题。这里的错误示例代码主要是为了说明复制构造函数，尤其是含有指针类型或者有成员表示在构造函数中分配的其他资源的情况下应该应当被正确处理。</span></p> 
<p><span style="font-size:14px">错误示例代码:</span></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using std::cout;
using std::endl;
//复制构造函数举例1
//此例包含指针成员，没有复制构造函数出错

struct Node
{
	Node(char *n="",int a = 0)
	{  
       name = strdup(n);
       strcpy(name,n);
	   age = a ;
	}
	~Node()
	{   
		delete[] name;
	}
	char *name;
	int age;
};
int main()
{
	Node node1("Roger",20),node2(node1);
	//print Roger 20 Roger 20
	cout&lt;&lt;node1.name&lt;&lt;" "&lt;&lt;node1.age&lt;&lt;" "
		&lt;&lt;node2.name&lt;&lt;" "&lt;&lt;node2.age&lt;&lt;endl;

	strcpy(node2.name,"Wendy");
	node2.age = 30;
	//print Wendy 20 Wendy 30
	cout&lt;&lt;node1.name&lt;&lt;" "&lt;&lt;node1.age&lt;&lt;" "
		&lt;&lt;node2.name&lt;&lt;" "&lt;&lt;node2.age&lt;&lt;endl;
}</code></pre> 
<br> 
<span style="font-size:14px"><br> 注意，这里的strdup函数是C语言中函数，它会根据串长用malloc分配内存的，返回分配的内存首地址。</span> 
<br> 
<p></p> 
<p><span style="font-size:14px">这段程序执行时输出:</span></p> 
<p><span style="font-size:14px">Roger 20 Roger 20<br> Wendy 20 Wendy 30<br> 并产生错误:</span></p> 
<p><span style="font-size:14px">0x77D9FCAA (ntdll.dll) (prog31.exe 中)处有未经处理的异常: 0xC0000374: 堆已损坏。 (参数: 0x77DC6668)。</span></p> 
<p><span style="font-size:14px"><br> </span></p> 
<p><span style="font-size:14px"><strong>解决办法:</strong>包含指针类型或者构造函数中包含资源分配的类，需要定义自己的复制构造函数而不是依赖编译器合成的复制构造函数。</span></p> 
<p><span style="font-size:14px">这里依赖编译器合成的复制构造函数，从node1构造node2时，node2.name指针进行简单的重定向，定向到node1.name所指向的字符串，因此二者共享同一份字符串地址，因此再执行strcpy(node2.name,"Wendy");出现了数据不一致行的错误，两者的name全部都是Wendy,而年龄更新却是正确的。同样，由于共享同一份字符串地址，在析构函数中释放同一份内存两次，导致堆已损坏的错误。当然，如果在析构函数中删除name数组空间后，将name指针置为空，不会产生堆损坏错误。但是在析构函数中将指针置为空，将隐藏程序bug,与复制构造函数相关的错误依然存在。</span></p> 
<p></p> 
<p><span style="font-size:14px">因此解决的办法，就是正确定义Node类如下:</span></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using std::cout;
using std::endl;
//复制构造函数举例2

struct Node
{
	Node(char *n="",int a = 0)
	{  
       name = strdup(n);
       strcpy(name,n);
	   age = a ;
	}
	//复制构造函数
	Node(const Node&amp; node)
	{  
	   name = strdup(node.name);
	   age = node.age;
	}
	//赋值操作符
	Node&amp; operator=(const Node&amp; n)
	{   
		if(this != &amp;n)
		{
			if(name != NULL)
				delete [] name;//释放先前空间
		    name = strdup(n.name);//重新分配内存
			age = n.age;
		}
	    return *this;
	}
	//析构函数
	~Node()
	{
		delete[] name;
	}
	char *name;
	int age;
};
int main()
{
	Node node1("Roger",20),node2(node1),node3("Tom",22);
	//print Roger 20 Roger 20
	cout&lt;&lt;node1.name&lt;&lt;" "&lt;&lt;node1.age&lt;&lt;" "
		&lt;&lt;node2.name&lt;&lt;" "&lt;&lt;node2.age&lt;&lt;endl;
	
	strcpy(node2.name,"Wendy");
	node2.age = 30;
	//print Roger 20 Wendy 30
	cout&lt;&lt;node1.name&lt;&lt;" "&lt;&lt;node1.age&lt;&lt;" "
		&lt;&lt;node2.name&lt;&lt;" "&lt;&lt;node2.age&lt;&lt;endl;

	//赋值操作符
	node2 = node3;
	//print Tom 22 Tom 22
	cout&lt;&lt;node2.name&lt;&lt;" "&lt;&lt;node2.age&lt;&lt;" "
		&lt;&lt;node3.name&lt;&lt;" "&lt;&lt;node3.age&lt;&lt;endl;
    
	return 0;
}</code></pre> 
<br> 这里因为可以由三法则(Rule of Three)即一个类如果需要析构函数，则该类几乎也必然需要定义自己的复制构造函数和赋值操作符解释。重新运行程序，即可得到正确结果并避免堆损坏错误。 
<br> 
<p></p> 
<h3><span style="font-size:14px"><span style="color:#FF0000">No.17   error C2664: “std::list&lt;_Ty&gt;::list(const std::allocator&lt;_Ty&gt; &amp;)”: 不能将参数 1 从</span></span></h3> 
<h3><span style="font-size:14px"><span style="color:#FF0000">“std::vector&lt;_Ty&gt;”转换为“const std::allocator&lt;_Ty&gt; &amp;”</span></span></h3> 
<p><span style="font-size:14px">        with<br>         [<br>             _Ty=int<br>         ]<br>         原因如下: 无法从“std::vector&lt;_Ty&gt;”转换为“const std::allocator&lt;_Ty&gt;”<br>         with<br>         [<br>             _Ty=int<br>         ]<br>         没有可用于执行该转换的用户定义的转换运算符，或者无法调用该运算符<br> prog33.cpp(13) : error C2664: “std::vector&lt;_Ty&gt;::vector(const std::allocator&lt;_Ty&gt; &amp;)”: 不能将参数<br> 1 从“std::vector&lt;_Ty&gt;”转换为“const std::allocator&lt;_Ty&gt; &amp;”<br>         with<br>         [<br>             _Ty=double<br>         ]<br>         and<br>         [<br>             _Ty=int<br>         ]<br>         and<br>         [<br>             _Ty=double<br>         ]<br>         原因如下: 无法从“std::vector&lt;_Ty&gt;”转换为“const std::allocator&lt;_Ty&gt;”<br>         with<br>         [<br>             _Ty=int<br>         ]<br>         and<br>         [<br>             _Ty=double<br>         ]<br>         没有可用于执行该转换的用户定义的转换运算符，或者无法调用该运算符</span></p> 
<p>错误代码:</p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
using std::vector;
using std::list;
using std::cout;
//容器初始化举例
int main()
{
	vector&lt;int&gt;	ivec;//使用默认构造函数
	vector&lt;int&gt;	ivec2(ivec);//初始化为同型容器的副本
	list&lt;int&gt;	ilist(ivec);//错误，容器类型不同
	vector&lt;double&gt;	dvec(ivec);//错误，容器元素类型不同
    
	return 0;
}</code></pre>解决办法:  c++标准库中不允许容器初始化为不同类型或者容器元素类型不同的容器的副本。如果需要从其他容器的元素初始化容器，可以使用一对迭代范围的构造函数初始化。例如: 
<p></p> 
<pre><code class="language-cpp">vector&lt;int&gt;    ivec;

list&lt;int&gt;   ilist(ivec.begin(),ivec.end());
 vector&lt;double&gt;    dvec(ivec.begin(),ivec.end());</code></pre> 
<p><span style="font-size:14px"><br> </span></p> 
<h3><span style="font-size:14px"><span style="color:#FF0000">No.18 与迭代器失效相关的错误</span>，例如:0x008D1127 处有未经处理的异常(在 prog34.exe 中): 0xC0000005: 读取位置 0x010AC000 时发生访问冲突。</span></h3> 
<p><span style="font-size:14px">错误代码:</span></p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

using std::vector;
using std::cout;
using std::endl;
//迭代器失效举例-避免存储end操作返回的迭代器
int main()
{
	vector&lt;int&gt;	ivec;
	ivec.push_back(3);
	ivec.push_back(5);
	ivec.push_back(7);
	vector&lt;int&gt;::iterator end = ivec.end();
    
	for(vector&lt;int&gt;::iterator first = ivec.begin();first != end;++first)
		cout&lt;&lt;*first&lt;&lt;endl;
	
	ivec.insert(ivec.begin(),1);
	//cause fatal error
	for(vector&lt;int&gt;::iterator first = ivec.begin();first != end;++first)
		cout&lt;&lt;*first&lt;&lt;endl;
	return 0;
}
</code></pre> 
<br> 
<span style="font-size:14px"><strong>解决办法:</strong>  这里保存了end操作返回的迭代器，然后又在容器中执行插入操作，导致迭代器失效，因而第二次的输出操作无法正常结束导致死循环，产生访问冲突。要警惕迭代器失效的操作，c++ primer建议假设迭代器失效是最安全的做法。这里可以在for语句中重新获取迭代器，以避免此类错误。</span> 
<br> 
<p></p> 
<h3><span style="font-size:14px">No.19 <span style="color:#FF0000">...VC\INCLUDE\iterator(93) : error C2039: “push_front”:</span></span></h3> 
<h3><span style="font-size:14px"> 不是“std::vector&lt;_Ty&gt;”的成员</span></h3> 
<span style="font-size:14px">        with<br>         [<br>             _Ty=int<br> </span> 
<p><span style="font-size:14px">        ]</span></p> 
<p><span style="font-size:14px">错误代码:</span></p> 
<pre><code class="language-cpp">int ia[] = {1,5,3,3,4};
const int array_size = sizeof(ia)/sizeof(*ia);
list&lt;int&gt; ilist(ia,ia+array_size);
vector&lt;int&gt; temp;
copy(ilist.begin(),ilist.end(),
front_inserter(temp));//使用push_front插入,导致错误</code></pre> 
<br> 
<p><span style="font-size:14px">解决办法: 迭代器与底层容器之间的操作实际上存在限制关系，也就是说并不是所有的容器都支持诸如push_front之类的操作。这里front_inserter将使用push_front方法来向vector插入元素，但是vector并不支持push_front操作。因此，解决的方法就是使用back_inserter 或者inserter函数返回的插入迭代器来进行操作。</span></p> 
<h3>NO.20 类模板使用时 TestDrive.obj : <span style="color:#FF0000">error LNK2019: 无法解析的外部符号 "public: __thiscall LinkedList&lt;int&gt;::~LinkedList&lt;i<br> nt&gt;(void)" (??1?$LinkedList@H@@QAE@XZ)，该符号在函数 _main 中被引用.</span></h3> 
<p><span style="font-size:14px">错误代码:</span></p> 
<p><span style="font-size:14px">LikedList.h</span></p> 
<p></p> 
<pre><code class="language-cpp">#ifndef _PAIR_H_
#define _PAIR_H_
#include &lt;string&gt;
template &lt;class T&gt; 
class Node
{  
public:
	Node(T dat,Node *n=NULL):data(dat),next(n){}
public:
	T data;
	Node *next;
};
template &lt;class T&gt; 
class LinkedList
{
public:
	 LinkedList():head(NULL){}
	 ~LinkedList();//free space here
     void add(T e);//add element
	 std::string toString();//print content
public:
	Node&lt;T&gt; *head;
};
#endif</code></pre>LinkedList.cpp 
<p></p> 
<p></p> 
<pre><code class="language-cpp">#include "LinkedList.h"
//free space
template &lt;class T&gt; LinkedList&lt;T&gt;::~LinkedList()
{
   Node&lt;T&gt; * ptr = head;
   while(ptr != NULL)
   {
      Node&lt;T&gt; * tmp = ptr-&gt;next;
	  delete ptr;
	  ptr = tmp;
   }
}
template &lt;class T&gt; void LinkedList&lt;T&gt;::add(T e)
{
    Node&lt;T&gt; *node = new Node&lt;T&gt;(e);
	node-&gt;next = head;
	head = node;//update head
}
template &lt;class T&gt; std::string LinkedList&lt;T&gt;::toString()
{
   std::string asString("List:["); 
   for(Node&lt;T&gt;* ptr = head;ptr != NULL;ptr = ptr-&gt;next)
		asString += std::to_string(ptr-&gt;data);
   asString += "]";
   return asString;
}</code></pre> 
<br> 
<br> TestDrive.cpp 
<p></p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include "LinkedList.h"

int main()
{
	LinkedList&lt;int&gt; list;
	list.add(1);
	list.add(2);
	list.add(3);
	std::cout&lt;&lt;list.toString()&lt;&lt;std::endl;
	return 0;
}</code></pre> 
<br> 
<span style="font-size:14px">解决办法: 模板类文件编译要采取一些手段。</span> 
<p></p> 
<p><span style="font-size:14px">主要有两种方式，方式一在头文件中包含类的实现，合并成一个文件来编译.</span></p> 
<p><span style="font-size:14px">方式二，通过使用export关键字，让编译器知道要记住给定的模板定义。当然要看编译器支持否，我的vs2013编译提示， warning C4237: 目前还不支持“export”关键字，但已保留该关键字供将来使用。因此这里使用方式一,例如代码:</span></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-cpp">#ifndef _PAIR_H_
#define _PAIR_H_
#include &lt;string&gt;
template &lt;class T&gt; 
class Node
{  
public:
	Node(T dat,Node *n=NULL):data(dat),next(n){}
public:
	T data;
	Node *next;
};
template &lt;class T&gt; 
class LinkedList
{
public:
	 LinkedList():head(NULL){}
	 ~LinkedList();//free space here
     void add(T e);//add element
	 std::string toString();//print content
public:
	Node&lt;T&gt; *head;
};

template &lt;class T&gt; LinkedList&lt;T&gt;::~LinkedList()
{
   Node&lt;T&gt; * ptr = head;
   while(ptr != NULL)
   {
      Node&lt;T&gt; * tmp = ptr-&gt;next;
	  delete ptr;
	  ptr = tmp;
   }
}
template &lt;class T&gt; void LinkedList&lt;T&gt;::add(T e)
{
    Node&lt;T&gt; *node = new Node&lt;T&gt;(e);
	node-&gt;next = head;
	head = node;//update head
}
template &lt;class T&gt; std::string LinkedList&lt;T&gt;::toString()
{
   std::string asString("List:["); 
   for(Node&lt;T&gt;* ptr = head;ptr != NULL;ptr = ptr-&gt;next)
		asString += std::to_string(ptr-&gt;data);
   asString += "]";
   return asString;
}
#endif
</code></pre>测试结果: 
<p></p> 
<p><span style="font-size:14px">List:[321].<br> </span></p> 
<h3>No 21: 类成员变量和函数重名问题  <span style="color:#FF0000"> error C2365: “ArrayStack&lt;T&gt;::top”: 重定义；以前的定义是“成员函数”</span><br> </h3> 
<p><span style="font-size:14px">这个错误发生纯属意外，但是让人纠结了半天。在c++中类的成员变量和函数是不可以重名的，这与java之中不同。例如使用数组实现一个栈时，ArrayStack类的top指针成员和基类的函数top重名，导致的错误，一开始让人莫名其妙。</span></p> 
<p><span style="font-size:14px">错误代码:</span></p> 
<p><span style="font-size:14px">Stack基类中声明了函数top:<br> </span></p> 
<p></p> 
<pre><code class="language-cpp">template&lt;typename T&gt;
class Stack
{
public:
      virtual ~Stack(){};
      virtual void push(T data)=0;
	  virtual T pop()=0;
	  virtual T top()=0;
      virtual bool isEmpty()=0;
      virtual void clear() = 0;
	  virtual int getSize()=0;
};</code></pre> 
<br> 
<span style="font-size:14px"></span> 
<p></p> 
<p><span style="font-size:14px">利用数组实现时:</span></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-cpp">template&lt;typename T = int&gt;

class ArrayStack : public Stack&lt;T&gt;
{
public:
	  T top()
	  {
	     if(top == base)
		{
		   throw std::logic_error("top at empty stack");
		}
		return *(top-1);
	  }
	  //other member function
private:
	  T *base,*top;
      int capacity;
};</code></pre> 
<br> 
<br> 
<p></p> 
<p><span style="font-size:14px"><br> 因为<span style="color:#FF0000"><strong>类使用了指针top,同时实现了函数top，重名错误</strong></span>，因此导致了编译器给出如下错误信息:</span></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-plain">d:\ds\stack\ArrayStack.h(79) : error C2365: “ArrayStack&lt;T&gt;::top”: 重定义；以前的定义是“成员函数”

        d:\ds\stack\ArrayStack.h(58) : 参见“ArrayStack&lt;T&gt;::top”的声明
        d:\ds\stack\ArrayStack.h(81): 参见对正在编译的类 模板 实例化“ArrayStack&lt;T&gt;”的引用
d:\ds\stack\ArrayStack.h(79) : error C2365: “ArrayStack&lt;T&gt;::top”: 重定义；以前的定义是“成员函数”

        with
        [
            T=int
        ]
        d:\ds\stack\ArrayStack.h(58) : 参见“ArrayStack&lt;T&gt;::top”的声明
        with
        [
            T=int
        ]
        StackTest.cpp(6): 参见对正在编译的类 模板 实例化“ArrayStack&lt;T&gt;”的引用
        with
        [
            T=int
        ]</code></pre> 
<span style="font-size:14px">解决办法，遵照合理的命名规则。</span> 
<br> 
<p></p> 
<h3><span style="font-size:14px"><span style="color:#FF0000"><strong>No.22 使用标准库sort等方法却未定义关系操作符  algorithm(3618) : error C2784: “bool std::</strong></span></span></h3> 
<h3><span style="font-size:14px"><span style="color:#FF0000"><strong>operator &lt;</strong></span>(const std::basic_string&lt;_Elem,_Traits,_Alloc&gt; &amp;,const _Elem *)”: 未能从“Person”为“con</span></h3> 
<p><span style="font-size:14px">st std::basic_string&lt;_Elem,_Traits,_Alloc&gt; &amp;”推导 模板 参数<br> ...(省略)<br> algorithm(3619) : error C2676: 二进制“&lt;”:“Person”不定义该运算符或到预定义运算符可接收的类型的转换</span></p> 
<p><br> </p> 
<p><span style="font-size:14px">错误代码示例：</span></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

class Person
{
public:
	// default constructor
	Person() : age(0) {}
	Person(int age, std::string name) {
		this-&gt;age = age; this-&gt;name = name;
	}
	int age;
	std::string name;
};

int main()
{
	std::vector&lt;Person&gt; vecPerson;
	vecPerson.push_back(Person(24,"Calvin"));
	vecPerson.push_back(Person(30,"Benny"));
	vecPerson.push_back(Person(28,"Alison"));

	std::sort(vecPerson.begin(),vecPerson.end());
	//using c++11
    for(const Person&amp; p : vecPerson)
		std::cout&lt;&lt;p.age&lt;&lt;", "&lt;&lt;p.name&lt;&lt;std::endl;

	return 0;
}</code></pre> 
<span style="color:#FF0000"><strong>解决办法:</strong></span> 定义STL算法需要的关系操作符。在上例中，sort算法默认使用std::less，而std::less使用类的&lt;操作符，因此可以定义一个全局的 
<span style="font-size:14px">重载&lt;操作符</span>的函数来满足sort算法需求，如下: 
<p></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-cpp">inline bool operator&lt;(const Person&amp; a, const Person&amp; b)
{
	return a.age &lt; b.age;
}</code></pre> 
<br> 
<span style="font-size:14px">程序输出:</span> 
<p></p> 
<p><span style="font-size:14px">24, Calvin<br> 28, Alison<br> 30, Benny</span></p> 
<h3><span style="font-size:14px">No.23  error C2661: <span style="color:#FF0000"> “std::less&lt;_Ty&gt;::less”: 没有重载函数接受 2 个参数</span></span></h3> 
<p><span style="font-size:14px">Std::less&lt;T&gt;是一个函数对象，错误在于没有正确的使用函数对象。</span></p> 
<p><span style="font-size:14px">错误代码示例:</span></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-cpp">template&lt;typename T,typename Compare=std::less&lt;T&gt; &gt;
class PriorityQueue : public Queue&lt;T&gt;
{
   template&lt;typename T,typename Compare&gt;
T PriorityQueue&lt;T,Compare&gt;::dequeue()
{
	if(index == 0)
	{
	   std::cerr&lt;&lt;"logic error : dequeue at empty queue. "&lt;&lt;std::endl;
	   throw std::logic_error("dequeue at empty queue");
	}
	//pick up one with highest priority 
	int highIndex = 0;
	for(int i = 1;i &lt; index ;i++)	// O(n)
	{
		if(	Compare( queue[i],queue[highIndex] ) )
			highIndex = i;
	}
	T result = queue[highIndex];
	index--;
	queue[highIndex] = queue[index];	//put the last element to the removed position
	
	return result;
}
}</code></pre> 
<br> 
<span style="color:#FF0000">错误的代码出现在: if(    Compare( queue[i],queue[highIndex] ) )。</span> 
<p></p> 
<p><span style="font-size:14px">Compare是一个函数对象，函数对象使用方式两种:</span></p> 
<p><span style="font-size:14px">第一种,显式构造一个函数对象，然后使用它,例如：</span></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-cpp">std::less&lt;Key&gt; a;  //定义一个函数对象

if(a(x,y)) ...   </code></pre> 
<br> 
<span style="font-size:14px">第二种，在使用时构造，例如：</span> 
<p></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-cpp">if(std::less&lt;Key&gt;()(x,y)) ...</code></pre> 
<br> 
<span style="font-size:14px">对于上述代码中，<span style="color:#000099"><strong>解决办法</strong></span>：代码更正为：if(    Compare()( queue[i],queue[highIndex] ) )。<br> </span> 
<span style="font-size:14px"><br> </span> 
<h3><span style="color:#FF0000">No.24  自增变量传递参数引起的段错误 (核心已转储)</span></h3> 
<h3></h3> 
<p><span style="color:#FF0000"></span><span style="font-size:14px">这里给出我书写一段代码引起的段错误：</span></p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;list&gt;
using namespace std;
void printList(list&lt;int&gt;::iterator itCur,list&lt;int&gt;::iterator end);

int main()
{
   list&lt;int&gt; iList;
   for(int i = 0;i &lt; 10 ;i++)
       iList.push_back(i);
   printList(iList.begin(),iList.end());
}
void printList(list&lt;int&gt;::iterator itCur,list&lt;int&gt;::iterator end)
{
    if( itCur == end)
    {
      std::cout&lt;&lt;std::endl;
      return;
    }
    std::cout&lt;&lt;*itCur&lt;&lt;" ";
    printList(itCur++,end);
}
</code></pre> 
<span style="font-size:14px">这段程序中，利用尾递归输出链表，实际上将进入死循环，导致输出时linux下提示段错误。在传递参数时，利用printList(itCur++,end)却没有达到预期效果，原因是后置自增变量用错了，这个错误很低级，需要引起注意。</span> 
<p></p> 
<p><span style="font-size:14px">解决办法，就是通过++itCur后者*itCur++来传递正确的参数。</span></p> 
<h3><span style="color:#FF0000">No.25   栈使用已经改变的数据引起的不一致问题</span></h3> 
<p><span style="font-size:14px">这是一个不经留意犯的错误。</span></p> 
<p><span style="font-size:14px">错误代码如下:</span></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-plain">while(!stack.empty()) {
    		    	  if(top == stack.top()-&gt;left  &amp;&amp;  stack.top()-&gt;right != 0) {
    		    		     stack.push(stack.top()-&gt;right);
    		    		     visit(stack.top()-&gt;right);//should visit last top right,not the new top right
    		    		     break;
    		    	   }else {
    		    		     top = stack.top();
    		    		     stack.pop();
    		    	   }
    		    }</code></pre> 
<br> 这里visit的本意是访问当前栈顶的右子树，结果因为与stack.push弄错了顺序，导致访问的是新的栈顶的右子树，从而导致出错。 
<p></p> 
<p><span style="font-size:14px">这里没有意识到，stack.top-&gt;right本身已经改变了，使用不一致的数据导致出错。</span></p> 
<h3><span style="font-size:14px"><span style="color:#FF0000">No.26 segmentation fault</span><br> </span></h3> 
<p><span style="font-size:14px">段错误，简而言之，是由于你使用已经释放的内存，写入只读的内存引起的错误。参考自:<a target="_blank" href="http://stackoverflow.com/questions/2346806/what-is-segmentation-fault" rel="nofollow noopener noreferrer">SO segmentation fault</a><br> </span></p> 
<p><span style="font-size:14px">例子1:解引用空指针</span></p> 
<p></p> 
<pre><code class="language-cpp">int main()
{
   //dereference a null pointer,can cause segmentation fault
   int *p = 0;
   *p = 1;
   return 0;
}
</code></pre> 
<br> 
<span style="font-size:14px">例子2: 写入只读内存</span> 
<br> 
<p></p> 
<p></p> 
<pre><code class="language-cpp">int main()
{
    // write to a portion of memory that has marked as read-only
    char *str = "Foo";// compiler marks the constant string as read-only
    *str = 'b';//which means this is illegal and results in a segfault
    return 0;
}
</code></pre> 
<br> 
<span style="font-size:14px">关于segfault更多内容，可以参考: <a target="_blank" href="http://www.cnblogs.com/hello--the-world/archive/2012/05/31/2528326.html" rel="nofollow noopener noreferrer"> C/C++中的段错误</a>.</span> 
<br> 
<p></p> 
<p><br> </p> 
<p><span style="color:#FF0000"><strong><span style="font-size:14px">No.27 warning:  xxx  will be initialized after [-Wreorder]</span></strong></span></p> 
<p><span style="font-size:14px">c++使用参数列表进行初始话时，初始化<span style="font-size:14px">成员变量</span>的顺序和声明的顺序相同，如果在写参数列表时没有按照声明的顺序写，则出现此警告。</span></p> 
<p><span style="font-size:14px">这个警告是为了避免在参数列表初始化时，值之间初始化产生依赖的错误。解决方法就是按照声明的顺序书写参数初始化列表。</span></p> 
<p></p> 
<pre><code class="language-cpp">Class C {
   int a;
   int b;
   C():b(1),a(2){} //warning, should be C():a(2),b(1)
}
</code></pre> 
<br> 
<span style="font-size:14px">或者取消警告： -Wno-reorder.</span> 
<br> 
<p></p> 
<p><br> </p> 
<p><span style="font-size:14px; color:#FF0000">No.28 error: ‘std::ios_base::ios_base(const std::ios_base&amp;)’ is private<br>      ios_base(const ios_base&amp;);<br>     synthesized method ‘std::basic_ostream&lt;char&gt;::basic_ostream(const std::basic_ostream&lt;char&gt;&amp;)’ first required here<br>    return s;</span><br> </p> 
<p><span style="font-size:14px">这个错误的原因大概是std::ios_base类的拷贝构造函数是私有的，从return s语句返回时缺少一个合成的构造拷贝构造函数完成流的复制。</span></p> 
<p><span style="font-size:14px">错误代码示例:</span></p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

struct Person {
   std::string name;
   Person(std::string n):name(n){}
};
// should return a reference to std::ostream
std::ostream operator&lt;&lt;(std::ostream&amp; s,const Person &amp;p) {
  s &lt;&lt; p.name;
  return s;
}

int main() {
   Person p(std::string("Tom"));
   std::cout&lt;&lt;p&lt;&lt;std::endl;
}
</code></pre> 
<span style="font-size:14px">重载输出操作符时，由于流对象不能复制，因此如果以值(by value)形式返回时，无法完成从s到std::osream的复制，因此导致上述错误。</span> 
<p></p> 
<p><span style="font-size:14px"><span style="color:#FF0000"><strong>解决方法</strong></span>是返回流的引用，即改变函数的返回类型为:std::ostream&amp;即可。</span></p> 
<p><br> </p> 
<p><span style="font-size:14px">No 29 . <span style="color:#FF0000"><span class="question-hyperlink">passing xxx as 'this' argument of xxx discards qualifiers</span></span><br> </span></p> 
<p><span style="font-size:14px">这是由于常量对象调用了非常量成员函数引起的错误,错误原因在于常量对象只能调用常量成员函数(因为常量成员函数约定不对非静态成员进行修改).</span></p> 
<p><a target="_blank" href="http://stackoverflow.com/questions/5973427/error-passing-xxx-as-this-argument-of-xxx-discards-qualifiers" rel="nofollow noopener noreferrer"><span style="font-size:14px">来自 stackoverflow的例子:<br> </span></a></p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;set&gt;

using namespace std;

class StudentT {

public:
    int id;
    string name;
public:
    StudentT(int _id, string _name) : id(_id), name(_name) {
    }
    int getId() {    //  应该声明为const成员
        return id;
    }
    string getName() { // 应该声明为const成员
        return name;
    }
};

inline bool operator&lt; (StudentT s1, StudentT s2) {
    return  s1.getId() &lt; s2.getId();
}

int main() {

    set&lt;StudentT&gt; st;
    StudentT s1(0, "Tom");
    StudentT s2(1, "Tim");
    st.insert(s1);
    st.insert(s2);
    set&lt;StudentT&gt; :: iterator itr;
    for (itr = st.begin(); itr != st.end(); itr++) {
        cout &lt;&lt; itr-&gt;getId() &lt;&lt; " " &lt;&lt; itr-&gt;getName() &lt;&lt; endl;
    }
    return 0;
}
</code></pre> 
<br> 
<span style="font-size:14px">这个例子中,加入set的StudentT对象都变成const对象了,那么调用getId等方法时只能调用其const版本,因为没有定义这个版本,因此编译器提示错误.</span> 
<p></p> 
<p><span style="font-size:14px">解决方法就是将getId和getName方法声明为const成员,即在函数末尾加上const关键字.</span><br> </p> 
<p><span style="font-size:14px"><span style="color:#FF0000"><strong>No.30 error: cannot dynamic_cast ‘b’ (of type ‘class Base*’) to type ‘class Derived&lt;int&gt;*’ (source type is not polymorphic)</strong></span><br> 在将父类型转换为子类型时,可以使用static_cast和dynamic_cast.如果使用dynamic_cast,它要求父类必须为多态的,即要求至少有一个虚函数,因此需要仔细检查类定义中有无虚函数,例如可以将析构函数设置为虚函数.</span></p> 
<p><span style="font-size:14px">更正后的代码为(来自: <a target="_blank" href="http://stackoverflow.com/questions/18873871/c-converting-a-base-class-pointer-to-a-derived-class-pointer" rel="nofollow noopener noreferrer"> <span class="question-hyperlink">c++ - converting a base class pointer to a derived class pointer</span></a><a target="_blank" href="http://stackoverflow.com/questions/18873871/c-converting-a-base-class-pointer-to-a-derived-class-pointer" rel="nofollow noopener noreferrer">)</a>:</span></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Base {
public:
  Base() {};
 virtual  ~Base() {}; // make it polymorphic
};

template&lt;class T&gt;
class Derived: public Base {
  T _val;
public:
  Derived() {}
  Derived(T val): _val(val) {}
  T raw() {return _val;}
};

int main()
{
  Base * b = new Derived&lt;int&gt;(1);
  Derived&lt;int&gt; * d = dynamic_cast&lt;Derived&lt;int&gt;* &gt;(b);
  cout &lt;&lt; d-&gt;raw() &lt;&lt; endl;
  return 0;
}
</code></pre> 
<br> 
<span style="color:#FF0000"><strong><span style="font-size:14px">No.31  error: conversion from ‘SmallInt’ to ‘long double’ is ambiguous<br> </span></strong></span> 
<p></p> 
<p><span style="font-size:14px">当实参与形参匹配的过程中,如果提供了多个转换操作符,而每个转换操作符都不能与形参类型匹配,需要额外的标准转换时,则没有哪种转换明显优于另一种,则编译器提示这个转换存在二义性,例如(来自c++ primer 4th):</span></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-cpp">// this example show paramaters matching process
// note SmallInt is a bad design
#include &lt;iostream&gt;
using namespace std;
class SmallInt {
public:
    SmallInt(int x=0):val(x){ cout &lt;&lt; "int ctor" &lt;&lt; endl; }
    SmallInt(double x):val(x){ cout &lt;&lt; "double ctor" &lt;&lt; endl;}
    operator int() const { cout &lt;&lt; "int conversion " &lt;&lt; endl;return val;}
    operator double() const { cout &lt;&lt; "double conversion" &lt;&lt; endl; return val;}
private:
    std::size_t val;
};

void compute(int x){}
void fp_compute(double x){}
void extended_compute(long double x){}

int main() {
  SmallInt si;
  compute(si); // using SmallInt::operator int() const
  fp_compute(si); // using SmallInt::operator double() const
  extended_compute(si); // error: ambiguous

  return 0;
}
</code></pre> 
<br> 
<span style="font-size:14px">这里的extended_compute函数需要long double类型,而SmallInt两个转换函数,都不能直接转换为long double,必须后接标准转换,因此没有哪种转换优于另一种,导致二义性错误.一般地,对一个类设置两个内置类型之间的转换,是不好的做法,这个例子的设计主要是为了说明这个缺陷.<br> </span> 
<p></p> 
<p><span style="color:#FF0000"><strong><span style="font-size:14px">No.32  <span style="font-size:14px">/usr/include/c++/4.9/bits/stl_iterator_base_types.h:165:53: error: ‘int’ is not a class, struct, or union type<br> </span><br> </span></strong></span></p> 
<p><span style="font-size:14px">先看下面的代码(来自: <a target="_blank" href="http://stackoverflow.com/questions/14322310/using-of-vector-in-c" rel="nofollow noopener noreferrer"> SO</a>):</span></p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;

using namespace std;

double distance(int a, int b)
{
    return fabs(a-b);
}

int main()
{
    vector&lt;int&gt; age;
    age.push_back(10);
    age.push_back(15);

    cout &lt;&lt; distance(age[0],age[1]);
    return 0;
}
</code></pre> 
<span style="font-size:14px">这段代码初看起来并无错误,编译时提示上述错误,原因在于使用std命名空间,而std命名空间中已经有了<span class="namespace" title="namespace std">std::</span>distance函数.</span> 
<p></p> 
<p><span style="font-size:14px">原型为:</span></p> 
<p></p> 
<pre><code class="language-cpp">template&lt;class InputIterator&gt;
  typename iterator_traits&lt;InputIterator&gt;::difference_type
    distance (InputIterator first, InputIterator last);</code></pre> 
<br> 
<span style="font-size:14px">这个函数要求两个参数至少都满足<a target="_blank" href="http://www.cplusplus.com/reference/iterator/InputIterator/" rel="nofollow noopener noreferrer">InPut Iterator</a>约束,y而age[0]为int类型,不满足这个约束,因此导致上面的错误信息.</span> 
<p></p> 
<p><span style="font-size:14px">这段代码的错误之处,在于std命名空间中的distance屏蔽了本地的distance函数,解决方法即为,显式调用本地方法,例如使用</span></p> 
<p><span style="font-size:14px">::distance(age[0],age[1])</span></p> 
<p><span style="font-size:14px">或者将distance放在一个命名空间中,例如:</span></p> 
<p></p> 
<pre><code class="language-cpp">namespace foo
{
  double distance(int a, int b)
  {
    return fabs(a-b);
  }
}

int main()
{
   foo::distance(x,y); //now you're calling your own distance function.
}</code></pre> 
<br> 
<span style="font-size:14px">或者不使用命名空间std,显式声明std::vector也可以解决.</span> 
<p></p> 
<p><span style="font-size:18px; color:#FF0000">No.33  auto_ptr is not dereferencable</span></p> 
<p><span style="font-size:18px">如下图所示:</span></p> 
<p><span style="font-size:18px; color:#FF0000"><img src="https://images2.imgbox.com/19/df/QU4j9jUs_o.png" alt=""></span></p> 
<p><span style="font-size:18px">错误代码示例:</span></p> 
<p><span style="font-size:18px; color:#FF0000"></span></p> 
<pre><code class="language-cpp">// Example : Transferring ownership from
//            one auto_ptr to another
void testAutoPtr6()
{
	std::auto_ptr&lt;TC&gt; pt1(new TC);
	std::auto_ptr&lt;TC&gt; pt2;

	pt1-&gt;someFunc(); // OK

	pt2 = pt1;  // now pt2 owns the pointer, and pt1 does not
	std::cout &lt;&lt; "Content of pt1 is " &lt;&lt; pt1.get() &lt;&lt; std::endl;
	std::cout &lt;&lt; "Content of pt2 is " &lt;&lt; pt2.get() &lt;&lt; std::endl;

	pt2-&gt;someFunc(); // OK

	pt1-&gt;someFunc(); // error! following a null pointer

} // as we go out of scope, pt2's destructor
// deletes the pointer, but pt1's does nothing</code></pre> 
<br> 
<span style="font-size:14px; color:#000000">auto_ptr在拷贝时会转移内存控制权，例子中pt1赋值给pt2后，将内存管理权转移给pt2, 此时pt1指针为NULL.</span> 
<br> 
<p></p> 
<p><span style="font-size:14px; color:#FF0000">No.34   _block_type_is_valid(phead- nblockuse)</span></p> 
<p><span style="font-size:14px">出现这种错误的原因有多个，基本原因有四个<span style="color:#FF0000"><span style="color:#000000">, 可以参见:<a target="_blank" href="Debug" rel="nofollow noopener noreferrer">SO</a>。</span></span></span></p> 
<p><span style="font-size:14px"><span style="color:#FF0000"><span style="color:#000000">错误如下:</span></span></span></p> 
<p><span style="font-size:14px"><span style="color:#FF0000"><span style="color:#000000"></span><img src="https://images2.imgbox.com/58/25/H2nKxtQx_o.png" alt=""></span></span></p> 
<p><span style="font-size:14px">比较常见的错误时，把多个对象的数组当做一个对象删除了，例如:</span></p> 
<p><span style="font-size:14px"><span style="color:#FF0000"></span></span></p> 
<pre><code class="language-cpp">void testSharedPtr1()
{
	//std::shared_ptr&lt;TC&gt; pt(new TC[5]);	// will crash , since default desctrctor using delete
	std::shared_ptr&lt;TC&gt; sptr1(new TC[5],
		[](TC* p) { delete[] p; });
}</code></pre> 
<br> 
<p><span style="color:#000000">这里std::shared_ptr默认使用delete删除，因此会导致出现上述错误。使用lamda表达式可以解决。</span></p> 
<p><br> </p> 
<p><span style="color:#000000"><span style="font-size:14px; color:#FF0000">No:35 error C2280: 'std::mutex::mutex(const std::mutex &amp;)' : attempting to reference a deleted function</span><br> </span></p> 
<p></p> 
<p><span style="font-size:14px"><code>std::mutex是noncopyable的结构，因此不存在拷贝构造函数，所以这里错误提示引用已经删除的函数。</code></span></p> 
<p><span style="font-size:14px"><code>错误示例代码如下：</code></span></p> 
<p><code></code><img src="https://images2.imgbox.com/cf/0e/tqWfVARg_o.png" alt=""></p> 
<p><br> </p> 
<p><span style="color:#FF0000"><strong><span style="font-size:14px">解决方法：</span></strong></span></p> 
<p><span style="color:#FF0000"><strong><span style="font-size:14px">     </span></strong><span style="font-size:14px; color:#000000">将包含std::mutex的类的拷贝构造函数和赋值操作符重载函数，自定义或者标记为delete.</span></span></p> 
<p><span style="font-size:14px">例如:</span></p> 
<p><span style="color:#FF0000"><strong><span style="font-size:14px">    </span></strong></span></p> 
<pre><code class="language-cpp">class Account {
public:
	Account(int id_, double ba = 0.0) :id(id_), balance(ba){}

	void withdraw(double amount){
		balance -= amount;
	}

	void deposit(double amount){
		balance += amount;
	}
	void printInfo() const {
		std::cout &lt;&lt; "Account id: " &lt;&lt; id &lt;&lt; " balance: " &lt;&lt; balance &lt;&lt; std::endl;
	}
	Account(const Account&amp; other) = delete;
	Account&amp; operator=(const Account&amp; other) = delete;
	friend void transfer(Account&amp; from, Account&amp; to, double amount);
private:
	double balance;
	int id;
	std::mutex m;
};</code></pre> 
<br> 
<br> 
<p></p> 
<p><br> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6c1e673512d23158905440dac2e427c9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux下wireshare 找不到网卡解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/283729bd6591d8ab0c82a7dbad6b97cb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网页文字中间加横线</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>