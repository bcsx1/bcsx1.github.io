<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端面试题（JavaScript基础篇） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="前端面试题（JavaScript基础篇）" />
<meta property="og:description" content="前端面试题，JavaScript基础篇共收录面试题57道。 1、介绍JavaScript的基本数据类型？ 基本数据类型：Number、String、Boolean、Null、Undefinedobject是JavaScript中所有对象的父对象数据封装类对象：object、Array、Boolean、Number、String其它对象：Function、Arguments、Math、Date、Error、RegExp其它数据类型：Symbol 2、浅谈JavaScript中变量和函数声明的提升？ 在JavaScript中变量和函数的声明会提升到最顶部执行函数的提升高于变量的提升函数内部如果用var声明了相同名称的外部变量，函数将不会向上寻找匿名函数不会提升不同&lt;script&gt;块中的函数互不影响 3、什么是闭包，闭包有什么特性？ 闭包就是能够读取其它函数内部变量的函数闭包是指有权访问另一个函数作用域中变量的函数，创建闭包最常见的方式就是在一个函数内部创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用域链闭包的特性 函数内再嵌套函数内部函数可以引用外部的参数或变量参数和变量不会被垃圾回收机制回收 4、说说对闭包的理解和闭包的作用 使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，增大内存使用量，使用不当很容易造成内存泄漏。在JS中，函数即闭包，只有函数才会产生作用域的概念闭包的最大用处有2个，一个是可以读取函数内部的变量，另一个就是可以让这些变量始终保持在内存中闭包的另一个用处是封装对象的私有属性和方法好处：能够实现封装和缓存坏处：就是消耗内存、不正当使用会造成内存溢出的问题 使用闭包的注意点
由于闭包会使得函数中的变量都保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 5、说说对This对象的理解 this总是指向函数的直接调用者，而非间接调用者如果有new关键字，this指向new出来的那个对象在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象window 6、说说对事件模型的理解 W3C中定义时间的发生精力三个阶段 捕获阶段目标阶段冒泡阶段冒泡型事件：当你使用事件冒泡时，子元素先触发，父元素后触发捕获型事件：当你使用事件捕获时，父元素先触发，子元素后触发DOM事件流：同时支持两种事件模型，捕获型事件和冒泡型事件阻止冒泡：在W3C中，使用stopPropagation()方法；在IE下设置cancelBubble = true阻止捕获：阻止事件的默认行为，例如click - &lt;a&gt;后的跳转。在W3C中，使用preventDefault()方法，在IE下设置window.event.returnValue = false 7、new 操作符具体干了什么？ 创建一个空对象，并且this变量引用该对象，同时还继承了该函数的原型属性和方法被加入到this引用的对象中新创建的对象由this所引用，并且最后隐式的返回this 8、说说栈和堆的理解，以及它们的区别？ 栈内存：栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命后期都很短堆内存：存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆内存中，堆内存的都是放的实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也不会消失，还可以使用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，有垃圾回收机制不定时的收取 栈和堆的区别：
栈内存存储的是局部变量，而堆内存存储的是实体栈内存更新速度要快于堆内存，因为局部变量的生命周期都很短栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收 9、JS数组和对象的遍历方式，以及几种方式的比较 for in 循环for 循环forEach 循环 这里的forEach回调中两个参数分别为：value , indexforEach无法遍历对象IE不支持该方法；FireFox和Chrome支持forEach无法使用break ，continue跳出循环，且使用return是跳过本次循环for-in 需要分析出array的每个属性，这个操作性能开销很大。用在key已知的数组上是不划算的。所以尽量不要用for-in，除非你不清楚要处理哪些属性，例如JSON对象这样的情况for循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当array里存放的都是DOM元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低 10、map和forEach的区别 forEach方法，是最基本的方法，就是遍历与循环，默认有3个参数：分别是遍历的数组内容item、数组索引index、当前遍历的数组Arraymap方法，基本用法与forEach一致，但不同的是，它会返回一个新的数组，所以callback需要有return值，如果没有，会返回undefined 11、谈一谈箭头函数与普通函数的区别？ 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象不可以当做构造函数，也就是不可以使用new命令，否则会抛出一个错误 不可以使用arguments对象，该对象在函数体内不存在，如果要用，可以使用Rest参数代替不可以使用yield命令，因为箭头函数不可以用作Generator函数（遍历器函数） 12、JavaScript定义类的4中方法 工厂方法 function creatPerson(name, age) { var obj = new Object(); obj.name = name; obj.age = age; obj.sayName = function () { alert(this.name); } return obj; } 构造函数方法 function Person(name, age) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/4588d2209b6918467f5ab50bc8f396ce/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-17T15:44:25+08:00" />
<meta property="article:modified_time" content="2022-02-17T15:44:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端面试题（JavaScript基础篇）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8CJavaScript%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%B1%E6%9C%89%E9%9D%A2%E8%AF%95%E9%A2%9862%E9%81%93%E3%80%82"><span style="color:#fe2c24;">前端面试题，JavaScript基础篇共收录面试题57道。</span></h4> 
<h4 id="1%E3%80%81%E4%BB%8B%E7%BB%8DJavaScript%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F">1、介绍JavaScript的基本数据类型？</h4> 
<ul><li>基本数据类型：Number、String、Boolean、Null、Undefined</li><li>object是JavaScript中所有对象的父对象</li><li>数据封装类对象：object、Array、Boolean、Number、String</li><li>其它对象：Function、Arguments、Math、Date、Error、RegExp</li><li>其它数据类型：Symbol</li></ul> 
<h4 id="2%E3%80%81%E6%B5%85%E8%B0%88JavaScript%E4%B8%AD%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E6%8F%90%E5%8D%87%EF%BC%9F">2、浅谈JavaScript中变量和函数声明的提升？</h4> 
<ul><li>在JavaScript中变量和函数的声明会提升到最顶部执行</li><li>函数的提升高于变量的提升</li><li>函数内部如果用var声明了相同名称的外部变量，函数将不会向上寻找</li><li>匿名函数不会提升</li><li>不同&lt;script&gt;块中的函数互不影响</li></ul> 
<h4 id="3%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%8C%E9%97%AD%E5%8C%85%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%EF%BC%9F">3、什么是闭包，闭包有什么特性？</h4> 
<ul><li>闭包就是能够读取其它函数内部变量的函数</li><li>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包最常见的方式就是在一个函数内部创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用域链</li><li>闭包的特性 
  <ul><li>函数内再嵌套函数</li><li>内部函数可以引用外部的参数或变量</li><li>参数和变量不会被垃圾回收机制回收</li></ul></li></ul> 
<h4 id="4%E3%80%81%E8%AF%B4%E8%AF%B4%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8">4、说说对闭包的理解和闭包的作用</h4> 
<ul><li>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，增大内存使用量，使用不当很容易造成内存泄漏。在JS中，函数即闭包，只有函数才会产生作用域的概念</li><li>闭包的最大用处有2个，一个是可以读取函数内部的变量，另一个就是可以让这些变量始终保持在内存中</li><li>闭包的另一个用处是封装对象的私有属性和方法</li><li>好处：能够实现封装和缓存</li><li>坏处：就是消耗内存、不正当使用会造成内存溢出的问题</li></ul> 
<p><strong>   使用闭包的注意点</strong></p> 
<ul><li>由于闭包会使得函数中的变量都保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。</li><li>解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li></ul> 
<h4 id="5%E3%80%81%E8%AF%B4%E8%AF%B4%E5%AF%B9This%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3">5、说说对This对象的理解</h4> 
<ul><li>this总是指向函数的直接调用者，而非间接调用者</li><li>如果有new关键字，this指向new出来的那个对象</li><li>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象window</li></ul> 
<h4 id="6%E3%80%81%E8%AF%B4%E8%AF%B4%E5%AF%B9%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3">6、说说对事件模型的理解</h4> 
<ul><li>W3C中定义时间的发生精力三个阶段 
  <ul><li>捕获阶段</li><li>目标阶段</li><li>冒泡阶段</li></ul></li><li>冒泡型事件：当你使用事件冒泡时，子元素先触发，父元素后触发</li><li>捕获型事件：当你使用事件捕获时，父元素先触发，子元素后触发</li><li>DOM事件流：同时支持两种事件模型，捕获型事件和冒泡型事件</li><li>阻止冒泡：在W3C中，使用stopPropagation()方法；在IE下设置cancelBubble = true</li><li>阻止捕获：阻止事件的默认行为，例如click - &lt;a&gt;后的跳转。在W3C中，使用preventDefault()方法，在IE下设置window.event.returnValue = false</li></ul> 
<h4 id="7%E3%80%81new%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F">7、new 操作符具体干了什么？</h4> 
<ul><li>创建一个空对象，并且this变量引用该对象，同时还继承了该函数的原型</li><li>属性和方法被加入到this引用的对象中</li><li>新创建的对象由this所引用，并且最后隐式的返回this</li></ul> 
<h4 id="8%E3%80%81%E8%AF%B4%E8%AF%B4%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">8、说说栈和堆的理解，以及它们的区别？</h4> 
<ul><li>栈内存：栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命后期都很短</li><li>堆内存：存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆内存中，堆内存的都是放的实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也不会消失，还可以使用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，有垃圾回收机制不定时的收取</li></ul> 
<p><strong>   栈和堆的区别：</strong></p> 
<ul><li>栈内存存储的是局部变量，而堆内存存储的是实体</li><li>栈内存更新速度要快于堆内存，因为局部变量的生命周期都很短</li><li>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收</li></ul> 
<h4 id="9%E3%80%81JS%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83">9、JS数组和对象的遍历方式，以及几种方式的比较</h4> 
<ul><li>for in 循环</li><li>for 循环</li><li>forEach 循环 
  <ul><li>这里的forEach回调中两个参数分别为：value , index</li><li>forEach无法遍历对象</li><li>IE不支持该方法；FireFox和Chrome支持</li><li>forEach无法使用break ，continue跳出循环，且使用return是跳过本次循环</li><li>for-in 需要分析出array的每个属性，这个操作性能开销很大。用在key已知的数组上是不划算的。所以尽量不要用for-in，除非你不清楚要处理哪些属性，例如JSON对象这样的情况</li><li>for循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当array里存放的都是DOM元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低</li></ul></li></ul> 
<h4 id="10%E3%80%81map%E5%92%8CforEach%E7%9A%84%E5%8C%BA%E5%88%AB">10、map和forEach的区别</h4> 
<ul><li>forEach方法，是最基本的方法，就是遍历与循环，默认有3个参数：分别是遍历的数组内容item、数组索引index、当前遍历的数组Array</li><li>map方法，基本用法与forEach一致，但不同的是，它会返回一个新的数组，所以callback需要有return值，如果没有，会返回undefined</li></ul> 
<h4 id="11%E3%80%81%E8%B0%88%E4%B8%80%E8%B0%88%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">11、谈一谈箭头函数与普通函数的区别？</h4> 
<ul><li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象</li><li>不可以当做构造函数，也就是不可以使用new命令，否则会抛出一个错误 </li><li>不可以使用arguments对象，该对象在函数体内不存在，如果要用，可以使用Rest参数代替</li><li>不可以使用yield命令，因为箭头函数不可以用作Generator函数（遍历器函数）</li></ul> 
<h4 id="12%E3%80%81JavaScript%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%844%E4%B8%AD%E6%96%B9%E6%B3%95">12、JavaScript定义类的4中方法</h4> 
<ul><li>工厂方法 <pre><code class="language-javascript">function creatPerson(name, age) {
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.sayName = function () {
        alert(this.name);
    }
    return obj;
}</code></pre> </li></ul> 
<ul><li>构造函数方法 <pre><code class="language-javascript">function Person(name, age) {
    this.name = name;
    this.age = age;
    this.sayName = function () {
        alert(this.name);    
    }
}</code></pre> </li></ul> 
<ul><li>原型方法 <pre><code class="language-javascript">function Person () {};
Person.prototype = {
    constructor: Person,
    name: "ZhangSan",
    age: "20",
    sayName: function () {
        alert(this.name);
    }
}</code></pre> </li></ul> 
<ul><li>组合使用构造函数和原型方法 <pre><code class="language-javascript">function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype = {
    constructor: Person,
    sayName: function () {
        alert(this.name);
    }
}</code></pre> </li></ul> 
<h4 id="13%E3%80%81JavaScript%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%843%E4%B8%AD%E6%96%B9%E6%B3%95">13、JavaScript实现继承的3中方法</h4> 
<ul><li>借用构造函数法 <pre><code class="language-javascript">function SuperType(name) {
    this.name = name;
    this.sayName = function () {
        alert(this.name);
    }
}

function SubType(name, age) {
    SuperType.call(this, name); // 这里借用了父类的构造函数
    this.age = age;
}</code></pre> </li></ul> 
<ul><li>对象冒充 <pre><code class="language-javascript">function SuperType(name) {
    this.name = name;
    this.sayName = function() {
        alert(this.name);
    }
}

function SubType(name, age) {
    this.supertype = SuperType; // 在这里使用了对象冒充
    this.supertype(name);
    this.age = age;
}</code></pre> </li></ul> 
<ul><li>组合继承 <pre><code class="language-javascript">function SuperType(name) {
    this.name = name;
}

SuperType.prototype = {
    sayName: function () {
        alert(this.name);
    }
}    

function SubType(name, age) {
    SuperType.call(this, name); // 在这里继承了属性
    this.age = age;
}

SubType.prototype = new SuperType(); // 这里继承方法</code></pre> </li></ul> 
<h4 id="14%E3%80%81%E5%AF%B9%E5%8E%9F%E7%94%9FJavascript%E4%BA%86%E8%A7%A3%E7%A8%8B%E5%BA%A6">14、对原生Javascript了解程度</h4> 
<ul><li>数据类型、运算、对象、Function、继承、闭包、作用域、原型链、时间、RegExp、JSON、Ajax、DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript</li></ul> 
<h4 id="15%E3%80%81JS%E5%8A%A8%E7%94%BB%E4%B8%8ECSS%E5%8A%A8%E7%94%BB%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%AE%9E%E7%8E%B0">15、JS动画与CSS动画区别及相应实现</h4> 
<ul><li>CSS3动画的优点 
  <ul><li>在性能上会烧毁好些，浏览器会对CSS3的动画做一些优化</li><li>代码相对简单</li></ul></li><li>CSS3动画的缺点 
  <ul><li>在动画控制上不够灵活</li><li>兼容性不好</li></ul></li><li>JavaScript的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容IE6，并且功能强大。对于一些复杂的控制动画，使用JavaScript会比较靠谱。而在实现一些小的交互动效的时候，可以考虑CSS。</li></ul> 
<h4 id="16%E3%80%81%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">16、谈一谈你理解的函数式编程</h4> 
<ul><li>简单说，“函数式编程”是一种“编程范式”，也就是如何编写程序的方法论</li><li>它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是“第一等公民”、只用“表达式”</li></ul> 
<h4 id="17%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3">17、说说你对作用域链的理解</h4> 
<ul><li>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，访问到window对象即会终止，作用域链向下访问是不被允许的</li><li>作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期</li></ul> 
<h4 id="18%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFJavaScript%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F">18、什么是JavaScript原型，原型链？有什么特点？</h4> 
<ul><li>每个对象都在其内部初始化一个属性，就是prototype（原型），当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。</li><li>关系：instance.constructor.prototype = instance.__proto__</li><li>JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变</li><li>当我们需要一个属性时，JavaScript引擎会先看当前对象中是否有这个属性，如果没有就会找他的prototype中是否有这个属性，如此递推下去，直到Object内建对象</li></ul> 
<h4 id="19%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%9F">19、说说什么是事件代理？</h4> 
<ul><li>事件代理，又称之为事件委托。是JavaScript中绑定事件的常用技巧。顾名思义，“事件代理”就是把原本需要监听的事件委托给父元素，由父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件地理的好处是可以提高性能。</li><li>可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒</li><li>可以实现新增子对象时无需再次对其绑定</li></ul> 
<h4 id="20%E3%80%81%E8%AF%B4%E8%AF%B4Ajax%E5%8E%9F%E7%90%86%EF%BC%9F">20、说说Ajax原理？</h4> 
<ul><li>Ajax的原理简单来说实在用户和服务器之间加了一个中间层（AJAX引擎），由XMLHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据</li><li>Ajax的过程只涉及JavaScript、XMLHttpRequest和DOM。XMLHttpRequest是Ajax的核心机制</li><li>Ajax的优点： 
  <ul><li>通过异步模式提升了用户体验</li><li>优化了浏览器和服务器之间的传输，减少了不必要的数据往返，减少了带宽占用</li><li>Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载</li><li>Ajax可以实现局部刷新</li></ul></li><li>Ajax的缺点： 
  <ul><li>安全问题，Ajax暴露了与服务器的交互细节</li><li>对搜索引擎的支持比较弱</li></ul></li><li>Ajax的请求过程： <pre><code class="language-javascript">// 1、创建连接
var xhr = null;
xhr = new XMLHttpRequest();
// 2、连接服务器
xhr.open('get', url, true);
// 3、发送请求
xhr.send(null);
// 4、接受请求
xhr.onreadystatechange = function () {
    if (xhr.readyState == 4) {
        if (xhr.status == 200) {
            success(xhr.responseText);
        } else {
            // false
            fail &amp;&amp; fail(xhr.status);
        }
    }
}</code></pre> </li></ul> 
<h4 id="21%E3%80%81%E8%AF%B4%E8%AF%B4%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%9F">21、说说如何解决跨域问题？</h4> 
<ul><li>首先了解下浏览器的同源策略，他是一种约定，是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，浏览器会很容易收到XSS、CSFR等攻击。所谓同源策略是值“协议+域名+端口”三者相同，即便两个不同的域名指向同一个IP地址，也非同源</li><li> 通过jsonp跨域</li><li>document.domain + iframe跨域</li><li>nginx代理跨域</li><li>nodejs中间件代理跨域</li><li>后端在头部信息里面设置安全域名解决跨域</li></ul> 
<h4 id="22%E3%80%81%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDJS%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">22、异步加载JS的方式有哪些？</h4> 
<ul><li>defer，只支持IE</li><li>async</li><li>创建script，插入到DOM中，加载完毕后callback <pre><code class="language-javascript">// 异步加载地图
export default function MapLoader() {
    return new Promise((resolve, reject) =&gt; {
        if (window.AMap) {
            resolve(window.AMap);
        } else {
            var script = document.createElement('script');
            script.type = 'text/javascript';
            script.async = ture;
            script.src = '';
            script.onerror = reject;
            document.head.appendChild(script);
        }
        window.initAMap = () =&gt; {
            resolve(window.AMap);
        }
    })
}</code></pre> </li></ul> 
<h4 id="23%E3%80%81%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F">23、哪些操作会造成内存泄漏？</h4> 
<ul><li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li><li>setTimeout的第一个参数使用字符而非函数的话，会引发内存泄漏</li><li>闭包使用不当</li></ul> 
<h4 id="24%E3%80%81%E4%BB%8B%E7%BB%8DJS%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9F">24、介绍JS有哪些内置对象？</h4> 
<ul><li>Object是JavaScript中所有对象的父对象</li><li>数据封装类对象：Object、Array、Boolean、Number、String</li><li>其它对象：Function、Arguments、Math、Date、RegExp、Error</li></ul> 
<h4 id="25%E3%80%81%E8%AF%B4%E5%87%A0%E6%9D%A1%E5%86%99JavaScript%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83">25、说几条写JavaScript的基本规范</h4> 
<ul><li>不要在同一行声明多个变量</li><li>请使用 === / !== 号来比较 true / false 或者数值</li><li>使用对象字面量替代 new Array这种形式</li><li>不要使用全局函数</li><li>Switch 语句必须带有 default 分支</li><li>if 语句必须使用大括号</li><li>for-in 循环中的变量应该使用var关键字明确限定作用域，从而避免作用域污染</li></ul> 
<h4 id="26%E3%80%81eval%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F">26、eval是做什么的？</h4> 
<ul><li>它的功能是把对应的字符串解析成JS代码并运行</li><li>应该避免使用eval，不安全，非常耗性能（2次，一次解析成JS语句，一次执行）</li><li>有JSON字符串转换为JSON对象的时候可以用eval <pre><code class="language-javascript">var obj = eval('(' + str + ')');</code></pre> </li></ul> 
<h4 id="27%E3%80%81null%20%E5%92%8C%20undefined%20%E7%9A%84%E5%8C%BA%E5%88%AB">27、null 和 undefined 的区别</h4> 
<ul><li>undefined表示不存在这个值</li><li>undefined是一个表示“无”的原始值或者表示“缺少值”，就是此处应该有一个值，但是还没定义。当尝试读取时就会返回undefined</li><li>例如变量被声明了，但没有赋值时，就等于undefined</li><li>null表示一个对象被定义了，值为“空值”</li><li>null是一个对象，一个空对象，没有任何属性和方法</li><li>例如作为函数的参数，表示该函数的参数不是对象</li><li>在验证null时，一定要使用===，因为==无法分辨null和undefined</li></ul> 
<h4 id="28%E3%80%81%E8%AF%B4%E8%AF%B4%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%3F">28、说说同步和异步的区别?</h4> 
<ul><li>同步：指的是同一时间只会执行一个任务，只有当前任务执行结束才会执行下一个任务</li><li>异步：指的是多个任务按照你编码的顺序执行任务，但是任务的完成顺序不一定和开始的顺序相同，也就是在此期间可以进行其它操作，常用的异步实现方法有回调、Promise</li></ul> 
<h4 id="29%E3%80%81defer%20%E5%92%8C%20async%20%E5%B9%B6%E8%A1%8C%E5%8A%A0%E8%BD%BDjs%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">29、defer 和 async 并行加载js文件的区别？</h4> 
<ul><li>defer 并行加载 js 文件，会按照页面上 script 标签的顺序执行</li><li>async 并行加载js文件，下载完成立即执行，不会按照页面上 script 标签的顺序执行</li></ul> 
<h4 id="30%E3%80%81%5B%221%22%2C%20%222%22%2C%20%223%22%5D.map(parseInt)%20%C2%A0%E7%AD%94%E6%A1%88%E6%98%AF%E5%A4%9A%E5%B0%91%3F">30、<span style="color:#2c3e50;">["1", "2", "3"].map(parseInt) </span> 答案是多少?</h4> 
<ul><li>答案是 [1,NaN,NaN]，因为parseInt需要两个参数(val, radix)，其中radix表示解析时用的基数，radix是一个介于2-36之间的整数，返回解析后的整数值。如果被解析参数的第一个字符无法被转化成数值类型，则返回NaN。</li><li>map 传了 3 个 (element, index, array)，对应的radix不合法导致解析失败</li><li>解析过程： <pre><code class="language-javascript">parseInt('1', 0); // radix为0时，使用默认的10进制。
parseInt('2', 1); // radix值在2-36，无法解析，返回NaN
parseInt('3', 2); // 基数为2，2进制数表示的数中，最大值小于3，无法解析，返回NaN</code></pre> </li></ul> 
<h4 id="31%E3%80%81use%20strict%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%9C%E7%94%A8%EF%BC%9F">31、use strict的理解和作用？</h4> 
<ul><li>use strict 是一种ECMAscript5 添加的运行模式，这种模式是的JavaScript在更严格的条件下运行，使JS编码更加规范化的模式，清除JavaScript语法的一些不合理、不严谨之处，减少一些怪异行为</li></ul> 
<h4 id="32%E3%80%81%E8%AF%B4%E8%AF%B4%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%99%90%E5%88%B6">32、说说严格模式的限制</h4> 
<ul><li> <p>变量必须声明后再使用</p> </li><li> <p>函数的参数不能有同名属性，否则报错</p> </li><li> <p>不能使用with语句</p> </li><li> <p>禁止this指向全局对象</p> </li></ul> 
<h4 id="33%E3%80%81%E8%AF%B4%E8%AF%B4ES6%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7">33、说说ES6新增了哪些特性</h4> 
<ul><li>新增模板字符串，为JavaScript提供了简单的字符串插值功能</li><li>箭头函数</li><li>for-of，用来遍历数据，例如数组中的值</li><li>arguments对象可被不定参数和默认参数完美替代</li><li>ES6将Promise对象纳入规范，提供了原生的Promise对象</li><li>增加了let和const命令，用来什么变量</li><li>增加了块级作用域，let命令实际上就增加了块级作用域</li><li>还有就是引入了module模块的概念</li></ul> 
<h4 id="34%E3%80%81%E8%AF%B4%E8%AF%B4%E5%AF%B9JSON%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%9F">34、说说对JSON的了解？</h4> 
<ul><li>JSON是一种轻量级的数据交换格式</li><li>他是基于JavaScript的一个子集。数据格式简单，易于读写，占用带宽小</li><li>JSON字符串转换为JSON对象： <pre><code class="language-javascript">var obj = eval('(' + str + ')');
var obj = str.parseJSON();
var obj = JSON.parse(str);</code></pre> </li><li>JSON对象转换为JSON字符串： <pre><code class="language-javascript">var last = obj.toJSONString();
var last = JSON.stringify(obj);</code></pre> </li></ul> 
<h4 id="35%E3%80%81%E8%AF%B4%E8%AF%B4JS%E5%BB%B6%E6%97%B6%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">35、说说JS延时加载的方式有哪些？</h4> 
<ul><li>defer 和 async、动态创建DOM的方式（用的最多）、按需异步载入js</li></ul> 
<h4 id="36%E3%80%81%E8%AF%B4%E8%AF%B4attribute%20%E5%92%8C%20property%C2%A0%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">36、说说attribute 和 property 的区别是什么？</h4> 
<ul><li>attribute 是dom元素在文档中作为html标签拥有的属性</li><li>property 是dom元素在js中作为对象用户的属性</li><li>对于html的标准属性来说，attribute 和 property 是同步的，是会自动更新的</li><li>但是对于自定义的属性来说，他们是不同步的</li></ul> 
<h4 id="37%E3%80%81%E8%AF%B4%E8%AF%B4let%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">37、说说let的区别是什么？</h4> 
<ul><li>let 命令不存在变量提升，如果再let前使用，会导致报错</li><li>如果块区中使用let 和 const 命令，就会形成封闭作用域</li><li>不允许重复声明，因此，不允许在函数内部重复声明参数</li></ul> 
<h4 id="38%E3%80%81%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87JS%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%9F">38、如何通过JS判断一个数组？</h4> 
<ul><li>instanceof方法 <pre><code class="language-javascript">// instanceof运算符是用来测试一个对象是否在其原型链原型构造函数的属性
var arr = [];
arr instanceof Array; // true</code></pre> </li><li>constructor方法 <pre><code class="language-javascript">// constructor属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数
var arr = [];
arr.constructor == Array; // true</code></pre> </li></ul> 
<ul><li>isArray()方法 <pre><code class="language-javascript">var a = new Array(123);
var b = new Date();
console.log(Array.isArray(a)); // true
console.log(Array.isArray(b)); // false</code></pre> </li></ul> 
<h4 id="39%E3%80%81%E8%AF%B4%E8%AF%B4var%E3%80%81let%E3%80%81const%E7%9A%84%E5%8C%BA%E5%88%AB">39、说说var、let、const的区别</h4> 
<ul><li>var  
  <ul><li>支持变量声明与解析</li><li>存在变量提升</li><li>不支持块级作用域</li><li>允许重复声明 </li></ul></li><li>let 
  <ul><li>不支持变量声明与解析</li><li>不存在变量提升</li><li>支持块级作用域</li><li>不允许重复声明</li></ul></li><li>const 
  <ul><li>不支持变量声明与解析</li><li>不存在变量提升</li><li>支持块级作用域</li><li>不允许重复声明，声明变量必须赋值，一旦确定不允许被修改，但如果是复合类型时，只改变某个value项是可以的</li></ul></li></ul> 
<h4 id="40%E3%80%81JavaScript%20%E4%B8%AD%20callee%20%E5%92%8C%20caller%20%E7%9A%84%E4%BD%9C%E7%94%A8">40、JavaScript 中 callee 和 caller 的作用</h4> 
<ul><li>caller 是返回一个对函数的引用，该函数调用了当前函数</li><li>callee 是返回正在被执行的 function 函数，也就是所指定的 function 对象的正文</li></ul> 
<h4 id="41%E3%80%81%E8%AF%B4%E8%AF%B4%20window.onload%20%E5%92%8C%20%24(document).ready%20%E7%9A%84%E5%8C%BA%E5%88%AB">41、说说 window.onload 和 $(document).ready 的区别</h4> 
<ul><li>window.onload()方法是必须等到页面包括图片的所有元素加载完毕后才能执行</li><li>$(document).ready() 是 DOM 结构绘制完毕后执行，不必等到加载完毕</li></ul> 
<h4 id="42%E3%80%81JavaScript%20%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95">42、JavaScript 数组去重方法</h4> 
<ul><li>利用for嵌套for，然后splice去重（ES5中常用） <pre><code class="language-javascript">function unique(arr) {
    for (var i = 0; i &lt; arr.length; i++) {
        for (var j = i + 1; j &lt; arr.length; j++) {
            if (arr[i] === arr[j]) { // 第一个等同于第二个，删除第二个
                arr.splice(j, 1);
                j--;
            }
        }
    }
    return arr;
}
var arr = [1, 1, 'true', 'true', true, true, 15, false, undefined, undefined, null];
console.log(unique(arr));</code></pre> </li><li>利用ES6 Set去重（ES6中常用） <pre><code class="language-javascript">function unique(arr) {
    return Array.from(new Set(arr));
}
var arr = [1, 1, 'true', 'true', true, true, 15, false, undefined, undefined, null];
console.log(unique(arr));</code></pre> </li><li>利用indexOf去重 <pre><code class="language-javascript">function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error');
        return;
    }
    var array = [];
    for (var i = 0; i &lt; arr.length; i++) {
        if (array.indexOf(arr[i]) === -1) {
            array.push(arr[i]);
        }
    }
    return array;
}
var arr = [1, 1, 'true', 'true', true, true, 15, false, undefined, undefined, null];
console.log(unique(arr));</code></pre> </li><li>利用soft()去重 <pre><code class="language-javascript">function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error');
        return;
    }
    arr = arr.sort();
    var array = [arr[0]];
    for (var i = 1; i &lt; arr.length; i++) {
        if (arr[i] !== arr[i - 1]) {
            array.push(arr[i]);
        }
    }
    return array;
}
var arr = [1, 1, 'true', 'true', true, true, 15, false, undefined, undefined, null];
console.log(unique(arr));</code></pre> </li><li>利用对象的属性不能相同的特点进行去重 <pre><code class="language-javascript">function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error');
        return;
    }
    var array = [];
    var obj = {};
    for (var i = 0; i &lt; arr.length; i++) {
        if (!obj[arr[i]]) {
            array.push(arr[i]);
            obj[arr[i]] = 1;
        } else {
            obj[arr[i]]++;
        }
    }
    return array;
}
var arr = [1, 1, 'true', 'true', true, true, 15, false, undefined, undefined, null];
console.log(unique(arr));</code></pre> </li></ul> 
<h4>43、浏览器缓存</h4> 
<ul><li>浏览器缓存分为强缓存和协商缓存，当客户端请求某个资源时，获取缓存的流程如下 
  <ul><li>先根据这个资源的一些http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器</li><li> 强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些 request header 验证这个资源是否命中协商缓存，称为 http 再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源</li><li>强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；区别是，强缓存不会发送请求到服务器，协商缓存会</li><li>当协商缓存也没有命中时，服务器就会将资源发送回客户端</li><li>当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存</li><li>当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存</li></ul></li></ul> 
<p>        <strong>强缓存       </strong></p> 
<ul><li>Expires 该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字串，代表缓存资源的过期时间</li><li>Cache-Control:max-age 该字段是http1.1 的规范，强缓存利用其max-age 值来判断缓存资源的最大生命周期，它的值单位为秒</li></ul> 
<p>    <strong>    协商缓存</strong></p> 
<ul><li>Last-Modified 值为资源最后更新时间，随服务器response返回</li><li>If-Modified-Since 通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存</li><li>ETag 表示资源内容的唯一标识，随服务器response 返回</li><li>If-None-Match 服务器通过比较请求头部的 If-None-Match 与当前资源的 ETag 是否一致来判断资源是否在两次请求直接有过修改，如果没有修改，则命中协商缓存</li></ul> 
<h4>44、防抖/节流的理解</h4> 
<ul><li>防抖：在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。可以通过函数防抖来实现 
  <ul><li>开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为null，就可以再次点击了</li><li>对于延时执行函数来说的实现：每次调用防抖函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数。</li></ul></li></ul> 
<pre><code class="language-javascript">// *使用 underscore 的源码来解释防抖动
// *underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func才会执行
// *@param { function } func 回调函数
// *@param { number } wait 表示时间窗口的间隔
// *@param { boolean } immediate 设置为true时，是否立即调用函数
// *@param { function } 返回客户调用函数

_.debounce = function (func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    var later = function () {
        // 现在和上一次时间戳比较
        var last = _.now() - timestamp;
        // 如果当前时间间隔少于设定时间且大于0就重新设置定时器
        if (last &lt; wait &amp;&amp; last &gt;= 0) {
            timeout = setTimeout(later, wait - last);
        } else {
            // 否则的话就是时间到了，执行回调函数
            timeout = null;
            if (!immediate) {
                result = func.apply(context, args);
                if (!timeout) context = args = null;
            }
        }
    };

    return function () {
        context = this;
        args = arguments;
        // 获得时间戳
        timestamp = _.now();
        // 如果定时器不存在且立即执行函数
        var callNow = immediate &amp;&amp; !timeout;
        // 如果定时器不存在就创建一个
        if (!timeout) timeout = setTimeout(later, wait);
        if (callNow) {
            // 如果需要立即执行函数的话，通过 apply 执行
            result = func.apply(context, args);
            context = args = null;
        }
        return result;
    }
}</code></pre> 
<ul><li>节流：防抖动和节流本质是不一样的。防抖动是将多次执行变成最后一次执行，节流是将多次执行变成每隔一段时间执行</li></ul> 
<pre><code class="language-javascript">/**
* underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait
* @param { function } func 回调函数
* @param { number } wait 表示时间窗口的间隔
* @param { object } options 如果想忽略开始函数的的调用，传入{ leading: false }。
* 如果想忽略结尾函数的调用，传入{ trailing: false }
* 两者不能共存，否则函数不能执行
* @return { function } 返回客户调用函数
**/

_.throttle = function (func, wait, options) {
    var context, args, result; var timeout = null; var previous = 0;
    // 如果 options 没传则设为空对象 if (!options) options = {}; 
    // 定时器回调函数
    var later = function () {
        // 如果设置了 leading，就将 previous 设为 0 
        // 用于下面函数的第一个 if 判断
        previous = options.leading === false ? 0 : _.now();
        result = func.apply(context, args);
        if (!timeout) context = args = null;
    };
    return function () {
        var now = _.now();
        // 首次进入前者肯定为 true
        // 如果需要第一次不执行函数
        // 就将上次时间戳设为当前的
        // 这样在接下来计算 remaining 的值时会大于 0  if (!previous &amp;&amp; options.leading === false) previous = now;  
        // 计算剩余时间
        var remaining = wait - (now - previous);
        context = this; args = arguments;
        // 如果当前调用已经大于上次调用时间 + wait
        // 如果设置了 trailing，只会进入这个条件
        // 如果没有设置 leading，那么第一次会进入这个条件
        // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了
        // 其实还是会进入的，因为定时器的延时
        // 并不是准确的时间，很可能你设置了 2 秒  
        // 但是他需要 2.2 秒才触发，这时候就会进入这个条件
        if (remaining &lt;= 0 || remaining &gt; wait) {
            // 如果存在定时器就清理掉否则会调用二次回调
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            } previous = now; result = func.apply(context, args);
            if (!timeout) context = args = null;
        } else if (!timeout &amp;&amp; options.trailing !== false) {
            // 判断是否设置了定时器和 trailing
            // 没有的话就开启一个定时器
            // 并且不能，不能同时设置 leading 和 trailing
            timeout = setTimeout(later, remaining);
        } return result;
    };
};</code></pre> 
<h4>45、JavaScript 变量提升</h4> 
<ul><li>当执行JS代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境</li><li>因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，方便大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入到内存中，变量只什么并且赋值为undefined。所以在第二阶段，也就是代码执行阶段，我们可以直接提前使用。</li></ul> 
<h4>46、实现Storage，使得该对象为单例，以及使用方式</h4> 
<pre><code class="language-javascript">var instance = null;
class Storage {
    static getInstance() {
        if (!instance) {
            instance = new Storage();
        }
        return instance;
    }
    setItem = (key, value) =&gt; localStorage.setItem(key, value);
    getItem = key =&gt; localStorage.getItem(key);
}</code></pre> 
<h4>47、说说你对事件流的理解</h4> 
<ul><li>事件流分为两种：捕获事件流和冒泡事件流</li><li>捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找到执行目标节点</li><li>冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，知道查到根节点</li></ul> 
<h4>48、说说从输入URL到看到页面发生的全过程</h4> 
<ul><li>首先浏览器主线程接管，开了一个下载线程</li><li>然后进行HTTP请求（DNS查询、IP寻址等），中间会有三次握手，等待响应，开始下载，响应报文</li><li>将下载完的内容转交给Renderer进程管理</li><li>Renderer进程开始解析css rule tree 和 dom tree，这两个过程是并行的，所以一般我们把link标签放在页面顶部</li><li>解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器就会去下载这些内容，遇到适用缓存的使用缓存，不使用缓存的重新下载资源</li><li>css rule tee 和 dom tree 生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制</li><li>绘制结束后，关闭TCP连接，过程又四次挥手</li></ul> 
<h4>49、做一个Dialog组件，说说你的设计思路？它应该有什么功能？</h4> 
<ul><li>该组件需要提供 hook 指定渲染位置，默认渲染在body下面</li><li>然后该组件可以指定外层样式，如宽度等</li><li>组件外层还需要一层mask来遮住底层内容，点击mask可以执行传进来的onCancel函数关闭Dialog</li><li>另外组件是可控的，需要传入visible来表示是否可见</li><li>然后Dialog可以能要自定义头部和底部，默认有头部和底部，底部有一个确认按钮和取消按钮，按钮文字可以传入，按钮可以传入是否显示。确认按钮会执行外部传进来的onOk事件，取消按钮会执行外部传进来的onCancel事件</li><li>当组件的visible为true的时候，设置body的overflow为hidden，隐藏body的滚动条，反之显示滚动条</li><li>组件高度可能大于页面高度，组件内部需要滚动条</li><li>只有当组件的visible有变化且为true时，才重新渲染组件内的所有内容</li></ul> 
<h4>50、说说Ajax、fetch、axios之间的区别</h4> 
<ul><li>Ajax请求 
  <ul><li>本身是针对MVC的编程，不合符现在前端的MVVM浪潮</li><li>基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案</li><li>JQuery整个项目太大，单纯使用Ajax却要引入整个JQuery非常的不合理（采取个性打包的方案又不能享受CDN服务）</li></ul></li><li>fetch请求 
  <ul><li>fetch只对网络请求报错，对400,500都当做是请求成功，需要封装去处理</li><li>fetch默认不会带cookie，需要添加配置项</li><li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject实现超时控制并不能阻止请求过程继续在后台运行，造成了资源的浪费</li><li>fetch没有办法监测请求的进度，而XHR可以</li></ul></li><li>axios请求 
  <ul><li>从浏览器中创建XMLHttpRequest</li><li>从node.js发出http请求</li><li>支持 Promise</li><li>支持拦截请求和响应</li><li>支持转换请求和响应数据</li><li>支持取消请求</li><li>自动转换JSON数据</li><li>客户端防止CSRF/XSRF</li></ul></li></ul> 
<h4>51、说说内存泄漏</h4> 
<ul><li>定义：程序中动态分配的堆内存由于某种原因程序未释放或无法释放引发的各种问题</li><li>JavaScript中可能出现内存泄漏的情况，结果：变慢、崩溃、延迟大等</li><li>JavaScript中可能出现内存泄漏的原因： 
  <ul><li>全局变量</li><li>DOM清空时，还存在引用</li><li>IE中使用闭包</li><li>定时器未清除</li><li>子元素存在引起的内存泄漏</li></ul></li></ul> 
<h4>52、JavaScript自定义事件</h4> 
<ul><li>document.createEvent() 创建事件模型</li><li>event.initEvent() 初始化事件</li><li>element.dispatchEvent() 触发事件</li></ul> 
<h4>53、JavaScript数组排序的几种方式？</h4> 
<ul><li>冒泡排序：每次比较相邻的两个数，如果后一个比前一个小，换位置 <pre><code class="language-javascript">var arr = [3,1,5,6,8,2,9,7,4];
function bubbleSort(arr) {
    for (var i = 0; i &lt; arr.length; i++) {
        for (var j = 0; j &lt; arr.length - i - 1; j++) {
            if (arr[j + 1] &lt; arr[j]) {
                var temp;
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    return arr;
}
console.log(bubbleSort(arr));</code></pre> </li></ul> 
<h4>54、JavaScript数组一行代码去重方法？</h4> 
<ul><li>Set方法去重 <pre><code class="language-javascript">var arr = [1, 1, 'true', 'true', true, true, 15, false, undefined, undefined, null];
Array.prototype.unique = function () {
    return [...new Set(this)];
}
console.log(arr.unique(arr));</code></pre> </li></ul> 
<h4>55、JavaScript如何判断一个对象是否为数组？</h4> 
<pre><code class="language-javascript">// 方法一
function isArray(arg) {
    if (typeof arg === 'object') {
        return Object.prototype.toSting.call(arg) === '[object Array]';
    }
    return false;
}

// 方法二
function isArray2(arg) {
    return Array.isArray(arg);
}</code></pre> 
<h4>56、script 的引入方式</h4> 
<ul><li>html静态引入&lt;script&gt;</li><li>js 动态插入 &lt;script&gt;</li><li>&lt;script defer&gt;：异步加载，元素解析完成之后执行</li><li>&lt;script async&gt;： 异步加载，但执行时会阻塞元素渲染</li></ul> 
<h4>57、什么是变量对象</h4> 
<ul><li>变量对象，是执行上下文中的一部分，可以抽象为一种数据作用域，其实也可以理解为就是一个简单的对象，它存储着该执行文件上下文中所有的变量和函数声明（不包含函数表达式）</li><li>活动对象（AO）：当变量对象所处的上下文为 active EC 是，成为活动对象</li></ul> 
<p></p> 
<p><span style="color:#0d0016;">有错请指正，侵删</span></p> 
<p><a class="link-info" href="https://download.csdn.net/download/weixin_39690316/80975883" title="查看全部面试题">查看全部面试题</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b468ced44e10fb4a2039b2fb082817da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PCL去除地面</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ab900e4c82cffa7de9ffa3ec174dc4ec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java 线程详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>