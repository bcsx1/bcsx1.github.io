<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>全面、详细、通俗易懂的C语言语法和标准库 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="全面、详细、通俗易懂的C语言语法和标准库" />
<meta property="og:description" content="系列文章目录 一、基于WSL2和Clion搭建Win下C开发环境
二、make、makeFile、CMake、CMakeLists的使用
三、全面、详细、通俗易懂的C语言语法和标准库
文章目录 系列文章目录前言变量变量的作用域变量的性质变量的声明和定义声明符和声明说明符存储类型符类型限定符类型说明符基本类型自定义类型扩展类型 正确认识变量 不完整类型变量的初始化和赋值 表达式和运算符左值和右值表达式中的类型转换隐式转换强制转换 typedef运算符sizeof运算符 预处理器宏定义带参数的宏多表达式、多语句的宏宏中的运算符预定义的宏 条件编译#if...#endif#ifdef/#ifndef...#endifdefined 文件包含头文件#include 其他指令#error#line 数组字符串字符串常量字符串变量&lt;string.h&gt; 结构空位对齐结构中的位域灵活数组成员 联合枚举函数函数的声明和定义函数的原型函数参数的传值方式可变参数列表和&lt;stdarg.h&gt;__func__ 指针指针变量指向指针的指针取地址运算符和间接寻址运算符空指针通用指针受限指针内存的动态分配与释放指针与数组指针与结构指针与函数 输入输出&lt;stdio.h&gt;流文件操作格式化输入输出字符的输入输出行的输入输出块的输入输出字符串的输入输出 错误处理&lt;assert.h&gt;&lt;signal.h&gt;&lt;setjmp.h&gt; 其它标准库&lt;stddef.h&gt;&lt;stdbool.h&gt;&lt;ctype.h&gt;&lt;stdlib.h&gt;数值转换伪随机数生成与环境通信搜索和排序 前言 本文并不是一篇C语言入门文章，它包含几乎所有C99语法及常用标准库的基本知识，请放心食用。
变量 在C语言中通过变量来代指内存中一个具体的存储空间。一个变量由以下几部分组成：
变量类型：变量存储值的类型变量名：变量的名字变量值：变量存储的值变量地址：变量的地址 变量的作用域 作用域指的是变量生效的范围。C 语言的变量作用域有以下两种：
文件作用域：文件作用域指的是，在源码文件顶层声明的变量，从声明的位置到文件结束都有效。块作用域： 块作用域指的是由大括号{}组成的代码块，它形成一个单独的作用域。凡是在块作用域里面声明的变量，只在当前代码块有效，代码块外部不可见。代码块可以嵌套，即代码块内部还有代码块，这时就形成了多层的块作用域。它的规则是：内层代码块可以使用外层声明的变量，但外层不可以使用内层声明的变量。如果内层的变量与外层同名，那么会在当前作用域覆盖外层变量。 变量的性质 在C语言中每个变量都具有以下性质：
存储期限：存储期限决定了为变量释放内存空间的时间： 自动存储期限：具有自动存储期限的变量会在所属程序块被执行时获得内存空间，在结束时释放内存空间。静态存储期限：具有静态存储期限的变量在程序运行的整个期间都会占用内存空间。动态内存：内存分配在堆上，根据需求自行释放。 链接：链接决定了变量在文件之间的共享范围： 内部链接：具有内部链接的变量只在所属文件内起作用。外部链接：具有外部链接的变量可以在不同文件内起作用。无链接：无链接的变量只在所属文件的所属块作用域内起作用。 变量的默认存储期限和链接与变量的作用域有关：
块作用域的变量具有自动存储权限并且无链接。文件作用域的变量具有静态存储权限和外部链接。 变量的声明和定义 在使用变量之前一定要对其进行定义和声明：
变量的声明：变量的声明用于指定变量的声明说明符和声明符，在程序中一个变量可以被声明多次。变量的定义：变量的定义用于为变量分配存储空间，在程序中一个变量只能被定义一次。 通常情况下变量的声明和变量的定义是同时发生的，但在使用extern关键字并且在它不失效的情况下，只有变量的声明而没有变量的定义。
声明符和声明说明符 声明符用于指明变量名，声明说明符分为以下三类，它们有各自的作用：
存储类型符：用于指明变量的性质类型限定符：用于修饰限定变量类型说明符：用于指明变量的类型 存储类型符 存储类型符在变量声明中最多出现一种，并且必须在声明说明符的最前面。
auto：auto修饰的变量具有自动存储期限、块作用域并且无连接，它只对块作用域的变量有效，因为对于块作用域的变量它是默认的。
static：static修饰的文件作用域的变量具有静态存储期限、文件作用域和内部链接；static修饰的块作用域的变量具有静态存储期限、块作用域并且无连接。
extern：extern用于在当前作用域引入其它文件中定义的变量。extern声明的变量会具有静态存储期限和外部连接并且不会占用内存空间。但如果在引入变量时又对变量进行了初始化，那么extern将失效。
register：register的性质和auto完全一致。但使用register声明的变量会请求编译器把它存储在寄存器中，并且由于寄存器没有地址，所以对register声明的变量使用取地址运算符是非法的，但该请求不一定得到应允。 类型限定符 const：const修饰的变量是只读的，不能被修改，因此也别成为常量。volatile：volatile关键字通常用于声明指向易变内存空间的指针，它告诉编译器该内存空间的数据是易变的，所以不要对其及逆行优化，并且在每次通过指针取值时都必须从内存中直接获取。restrict：见下文受限指针。 类型说明符 基本类型 基本类型包含以下三类：
整数类型：C语言允许使用十进制、八进制和十六进制书写整数类型值，其中八进制必须以0开头，十六进制必须以0x开头。编译器默认将整数常量当作int型处理，可以通过添加后缀的方式使编译器改变默认处理类型。在不加后缀的情况下，如果int型存不下十进制数，那么编译器会依次尝试、long int、long long int。对于八进制和十六进制，编译器会依次尝试unsigned int、long int、unsigned long int、long long int、unsigned long long int。 类型说明符后缀short int-unsigned short int-int-unsigned intulong intlunsigned long intullong long intllunsigned long long intull 浮点类型：编译器默认将浮点常量当作double型处理，可以通过添加后缀的方式使编译器改变默认处理类型。 类型说明符后缀floatfdouble-long doublel 字符类型：编译器将字符类型当作小整数类型处理。 类型说明符后缀char- 自定义类型 自定义类型包含以下几种，主体内容在下文：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/bdcc4567fb0ed1dcf8dc38718c1ddb97/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-17T17:40:40+08:00" />
<meta property="article:modified_time" content="2023-09-17T17:40:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">全面、详细、通俗易懂的C语言语法和标准库</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>系列文章目录</h2> 
<p>一、基于WSL2和Clion搭建Win下C开发环境<br> 二、make、makeFile、CMake、CMakeLists的使用<br> 三、全面、详细、通俗易懂的C语言语法和标准库<br> </p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_0" rel="nofollow">系列文章目录</a></li><li><a href="#_5" rel="nofollow">前言</a></li><li><a href="#_7" rel="nofollow">变量</a></li><li><ul><li><a href="#_18" rel="nofollow">变量的作用域</a></li><li><a href="#_24" rel="nofollow">变量的性质</a></li><li><a href="#_38" rel="nofollow">变量的声明和定义</a></li><li><a href="#_44" rel="nofollow">声明符和声明说明符</a></li><li><ul><li><a href="#_49" rel="nofollow">存储类型符</a></li><li><a href="#_59" rel="nofollow">类型限定符</a></li><li><a href="#_63" rel="nofollow">类型说明符</a></li><li><ul><li><a href="#_64" rel="nofollow">基本类型</a></li><li><a href="#_92" rel="nofollow">自定义类型</a></li><li><a href="#_97" rel="nofollow">扩展类型</a></li></ul> 
    </li><li><a href="#_106" rel="nofollow">正确认识变量</a></li></ul> 
   </li><li><a href="#_121" rel="nofollow">不完整类型</a></li><li><a href="#_127" rel="nofollow">变量的初始化和赋值</a></li></ul> 
  </li><li><a href="#_133" rel="nofollow">表达式和运算符</a></li><li><ul><li><a href="#_139" rel="nofollow">左值和右值</a></li><li><a href="#_141" rel="nofollow">表达式中的类型转换</a></li><li><ul><li><a href="#_143" rel="nofollow">隐式转换</a></li><li><a href="#_156" rel="nofollow">强制转换</a></li></ul> 
   </li><li><a href="#typedef_161" rel="nofollow">typedef运算符</a></li><li><a href="#sizeof_167" rel="nofollow">sizeof运算符</a></li></ul> 
  </li><li><a href="#_173" rel="nofollow">预处理器</a></li><li><ul><li><a href="#_175" rel="nofollow">宏定义</a></li><li><ul><li><a href="#_181" rel="nofollow">带参数的宏</a></li><li><a href="#_187" rel="nofollow">多表达式、多语句的宏</a></li><li><a href="#_200" rel="nofollow">宏中的运算符</a></li><li><a href="#_210" rel="nofollow">预定义的宏</a></li></ul> 
   </li><li><a href="#_221" rel="nofollow">条件编译</a></li><li><ul><li><a href="#ifendif_223" rel="nofollow">#if...#endif</a></li><li><a href="#ifdefifndefendif_234" rel="nofollow">#ifdef/#ifndef...#endif</a></li><li><a href="#defined_249" rel="nofollow">defined</a></li></ul> 
   </li><li><a href="#_257" rel="nofollow">文件包含</a></li><li><ul><li><a href="#_259" rel="nofollow">头文件</a></li><li><a href="#include_261" rel="nofollow">#include</a></li></ul> 
   </li><li><a href="#_278" rel="nofollow">其他指令</a></li><li><ul><li><a href="#error_279" rel="nofollow">#error</a></li><li><a href="#line_284" rel="nofollow">#line</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_293" rel="nofollow">数组</a></li><li><a href="#_313" rel="nofollow">字符串</a></li><li><ul><li><a href="#_315" rel="nofollow">字符串常量</a></li><li><a href="#_329" rel="nofollow">字符串变量</a></li><li><a href="#ltstringh_334" rel="nofollow">&lt;string.h&gt;</a></li></ul> 
  </li><li><a href="#_363" rel="nofollow">结构</a></li><li><ul><li><a href="#_402" rel="nofollow">空位对齐</a></li><li><a href="#_408" rel="nofollow">结构中的位域</a></li><li><a href="#_418" rel="nofollow">灵活数组成员</a></li></ul> 
  </li><li><a href="#_428" rel="nofollow">联合</a></li><li><a href="#_430" rel="nofollow">枚举</a></li><li><a href="#_465" rel="nofollow">函数</a></li><li><ul><li><a href="#_466" rel="nofollow">函数的声明和定义</a></li><li><a href="#_478" rel="nofollow">函数的原型</a></li><li><a href="#_485" rel="nofollow">函数参数的传值方式</a></li><li><a href="#ltstdargh_492" rel="nofollow">可变参数列表和&lt;stdarg.h&gt;</a></li><li><a href="#9595func9595_508" rel="nofollow">__func__</a></li></ul> 
  </li><li><a href="#_511" rel="nofollow">指针</a></li><li><ul><li><a href="#_513" rel="nofollow">指针变量</a></li><li><a href="#_518" rel="nofollow">指向指针的指针</a></li><li><a href="#_524" rel="nofollow">取地址运算符和间接寻址运算符</a></li><li><a href="#_534" rel="nofollow">空指针</a></li><li><a href="#_540" rel="nofollow">通用指针</a></li><li><a href="#_542" rel="nofollow">受限指针</a></li><li><a href="#_544" rel="nofollow">内存的动态分配与释放</a></li><li><a href="#_578" rel="nofollow">指针与数组</a></li><li><a href="#_668" rel="nofollow">指针与结构</a></li><li><a href="#_683" rel="nofollow">指针与函数</a></li></ul> 
  </li><li><a href="#ltstdioh_697" rel="nofollow">输入输出&lt;stdio.h&gt;</a></li><li><ul><li><a href="#_698" rel="nofollow">流</a></li><li><a href="#_730" rel="nofollow">文件操作</a></li><li><a href="#_782" rel="nofollow">格式化输入输出</a></li><li><a href="#_885" rel="nofollow">字符的输入输出</a></li><li><a href="#_898" rel="nofollow">行的输入输出</a></li><li><a href="#_909" rel="nofollow">块的输入输出</a></li><li><a href="#_917" rel="nofollow">字符串的输入输出</a></li></ul> 
  </li><li><a href="#_925" rel="nofollow">错误处理</a></li><li><ul><li><a href="#ltasserth_926" rel="nofollow">&lt;assert.h&gt;</a></li><li><a href="#ltsignalh_932" rel="nofollow">&lt;signal.h&gt;</a></li><li><a href="#ltsetjmph_969" rel="nofollow">&lt;setjmp.h&gt;</a></li></ul> 
  </li><li><a href="#_976" rel="nofollow">其它标准库</a></li><li><ul><li><a href="#ltstddefh_1005" rel="nofollow">&lt;stddef.h&gt;</a></li><li><a href="#ltstdboolh_1022" rel="nofollow">&lt;stdbool.h&gt;</a></li><li><a href="#ltctypeh_1029" rel="nofollow">&lt;ctype.h&gt;</a></li><li><a href="#ltstdlibh_1051" rel="nofollow">&lt;stdlib.h&gt;</a></li><li><ul><li><a href="#_1053" rel="nofollow">数值转换</a></li><li><a href="#_1072" rel="nofollow">伪随机数生成</a></li><li><a href="#_1078" rel="nofollow">与环境通信</a></li><li><a href="#_1093" rel="nofollow">搜索和排序</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_5"></a>前言</h2> 
<p>本文并不是一篇C语言入门文章，它包含几乎所有C99语法及常用标准库的基本知识，请放心食用。</p> 
<h2><a id="_7"></a>变量</h2> 
<p>在C语言中通过变量来代指内存中一个具体的存储空间。一个变量由以下几部分组成：</p> 
<ul><li>变量类型：变量存储值的类型</li><li>变量名：变量的名字</li><li>变量值：变量存储的值</li><li>变量地址：变量的地址</li></ul> 
<p><img src="https://images2.imgbox.com/e6/14/KYcYu5Lg_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_18"></a>变量的作用域</h3> 
<p>作用域指的是变量生效的范围。C 语言的变量作用域有以下两种：</p> 
<ul><li>文件作用域：文件作用域指的是，在源码文件顶层声明的变量，从声明的位置到文件结束都有效。</li><li>块作用域： 
  <ul><li>块作用域指的是由大括号<code>{}</code>组成的代码块，它形成一个单独的作用域。凡是在块作用域里面声明的变量，只在当前代码块有效，代码块外部不可见。</li><li>代码块可以嵌套，即代码块内部还有代码块，这时就形成了多层的块作用域。它的规则是：内层代码块可以使用外层声明的变量，但外层不可以使用内层声明的变量。如果内层的变量与外层同名，那么会在当前作用域覆盖外层变量。</li></ul> </li></ul> 
<h3><a id="_24"></a>变量的性质</h3> 
<p>在C语言中每个变量都具有以下性质：</p> 
<ul><li>存储期限：存储期限决定了为变量释放内存空间的时间： 
  <ul><li>自动存储期限：具有自动存储期限的变量会在所属程序块被执行时获得内存空间，在结束时释放内存空间。</li><li>静态存储期限：具有静态存储期限的变量在程序运行的整个期间都会占用内存空间。</li><li>动态内存：内存分配在堆上，根据需求自行释放。</li></ul> </li><li>链接：链接决定了变量在文件之间的共享范围： 
  <ul><li>内部链接：具有内部链接的变量只在所属文件内起作用。</li><li>外部链接：具有外部链接的变量可以在不同文件内起作用。</li><li>无链接：无链接的变量只在所属文件的所属块作用域内起作用。</li></ul> </li></ul> 
<p>变量的<strong>默认</strong>存储期限和链接与变量的作用域有关：</p> 
<ul><li>块作用域的变量具有自动存储权限并且无链接。</li><li>文件作用域的变量具有静态存储权限和外部链接。</li></ul> 
<h3><a id="_38"></a>变量的声明和定义</h3> 
<p>在使用变量之前一定要对其进行定义和声明：</p> 
<ul><li>变量的声明：变量的声明用于指定变量的声明说明符和声明符，在程序中一个变量可以被声明多次。</li><li>变量的定义：变量的定义用于为变量分配存储空间，在程序中一个变量只能被定义一次。</li></ul> 
<p>通常情况下变量的声明和变量的定义是同时发生的，但在使用<code>extern</code>关键字并且在它不失效的情况下，只有变量的声明而没有变量的定义。</p> 
<h3><a id="_44"></a>声明符和声明说明符</h3> 
<p>声明符用于指明变量名，声明说明符分为以下三类，它们有各自的作用：</p> 
<ul><li>存储类型符：用于指明变量的性质</li><li>类型限定符：用于修饰限定变量</li><li>类型说明符：用于指明变量的类型</li></ul> 
<h4><a id="_49"></a>存储类型符</h4> 
<p>存储类型符在变量声明中最多出现一种，并且必须在声明说明符的最前面。</p> 
<ul><li><code>auto</code>：<code>auto</code>修饰的变量具有自动存储期限、块作用域并且无连接，它只对块作用域的变量有效，因为对于块作用域的变量它是默认的。<br> <img src="https://images2.imgbox.com/37/57/RcFLGPXN_o.png" alt="在这里插入图片描述"></li><li><code>static</code>：<code>static</code>修饰的文件作用域的变量具有静态存储期限、文件作用域和内部链接；<code>static</code>修饰的块作用域的变量具有静态存储期限、块作用域并且无连接。<br> <img src="https://images2.imgbox.com/ee/2e/AMVX5z37_o.png" alt="在这里插入图片描述"></li><li><code>extern</code>：<code>extern</code>用于在当前作用域引入其它文件中定义的变量。<code>extern</code>声明的变量会具有静态存储期限和外部连接并且不会占用内存空间。但如果在引入变量时又对变量进行了初始化，那么<code>extern</code>将失效。<br> <img src="https://images2.imgbox.com/ec/d5/JPTo4ZXF_o.png" alt="在这里插入图片描述"></li><li><code>register</code>：<code>register</code>的性质和<code>auto</code>完全一致。但使用<code>register</code>声明的变量会请求编译器把它存储在寄存器中，并且由于寄存器没有地址，所以对<code>register</code>声明的变量使用取地址运算符是非法的，但该请求不一定得到应允。</li></ul> 
<h4><a id="_59"></a>类型限定符</h4> 
<ul><li><code>const</code>：<code>const</code>修饰的变量是只读的，不能被修改，因此也别成为常量。</li><li><code>volatile</code>：<code>volatile</code>关键字通常用于声明指向易变内存空间的指针，它告诉编译器该内存空间的数据是易变的，所以不要对其及逆行优化，并且在每次通过指针取值时都必须从内存中直接获取。</li><li><code>restrict</code>：见下文<a href="https://editor.csdn.net/md/?articleId=123223176#_468" rel="nofollow">受限指针</a>。</li></ul> 
<h4><a id="_63"></a>类型说明符</h4> 
<h5><a id="_64"></a>基本类型</h5> 
<p>基本类型包含以下三类：</p> 
<ul><li>整数类型：C语言允许使用十进制、八进制和十六进制书写整数类型值，其中八进制必须以<code>0</code>开头，十六进制必须以<code>0x</code>开头。编译器默认将整数常量当作<code>int</code>型处理，可以通过添加后缀的方式使编译器改变默认处理类型。在不加后缀的情况下，如果<code>int</code>型存不下十进制数，那么编译器会依次尝试、<code>long int</code>、<code>long long int</code>。对于八进制和十六进制，编译器会依次尝试<code>unsigned int</code>、<code>long int</code>、<code>unsigned long int</code>、<code>long long int</code>、<code>unsigned long long int</code>。</li></ul> 
<table><thead><tr><th>类型说明符</th><th>后缀</th></tr></thead><tbody><tr><td>short int</td><td>-</td></tr><tr><td>unsigned short int</td><td>-</td></tr><tr><td>int</td><td>-</td></tr><tr><td>unsigned int</td><td>u</td></tr><tr><td>long int</td><td>l</td></tr><tr><td>unsigned long int</td><td>ul</td></tr><tr><td>long long int</td><td>ll</td></tr><tr><td>unsigned long long int</td><td>ull</td></tr></tbody></table> 
<ul><li>浮点类型：编译器默认将浮点常量当作<code>double</code>型处理，可以通过添加后缀的方式使编译器改变默认处理类型。</li></ul> 
<table><thead><tr><th>类型说明符</th><th>后缀</th></tr></thead><tbody><tr><td>float</td><td>f</td></tr><tr><td>double</td><td>-</td></tr><tr><td>long double</td><td>l</td></tr></tbody></table> 
<ul><li>字符类型：编译器将字符类型当作小整数类型处理。</li></ul> 
<table><thead><tr><th>类型说明符</th><th>后缀</th></tr></thead><tbody><tr><td>char</td><td>-</td></tr></tbody></table> 
<h5><a id="_92"></a>自定义类型</h5> 
<p>自定义类型包含以下几种，主体内容在下文：</p> 
<ul><li>结构</li><li>联合</li><li>枚举</li></ul> 
<h5><a id="_97"></a>扩展类型</h5> 
<p>扩展类型就是从基本类型和自定义类型或扩展类型扩展的类型，当一个变量的类型说明符中出现<code>*</code>和<code>[]</code>时就说明该变量是一个扩展类型，其中：</p> 
<ul><li><code>*</code>表示该变量是一个指针变量，它存储着一个指针，扩展自的类型表示指针指向内存存储值的类型。</li><li><code>[]</code>表示该变量是一个数组变量，是一片连续的存储空间，它存储着指向数组第一个元素的指针，扩展自的类型表示连续存储空间中存储值的类型。</li></ul> 
<p>很多时候类型说明符中也会出现<code>()</code>，它的作用是区别优先级，它们三者的优先级如下：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ( 
         
        
          ) 
         
        
          &gt; 
         
        
          [ 
         
        
          ] 
         
        
          &gt; 
         
        
          ∗ 
         
        
       
         ()&gt;[]&gt;* 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.4653em;"></span><span class="mord">∗</span></span></span></span></span></span></p> 
<h4><a id="_106"></a>正确认识变量</h4> 
<p>对于一眼看不出来的变量声明，可以使用以下方法进行分析：</p> 
<ul><li>以标识符为中心由内往外读声明符。</li><li>在做选择时，优先级始终是<code>()</code>大于<code>[]</code>大于<code>*</code>。</li></ul> 
<p>下面举几个例子：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>funPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先是一个指针--指向了一个函数</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>funPtrArr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先是一个数组--后存储了指针--指针指向一个函数</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>funPtrArrPtr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先是一个指针--指针指向一个数组--数组存储着指针--指针指向一个函数</span>
</code></pre> 
<h3><a id="_121"></a>不完整类型</h3> 
<p>不完整类型是在编写C语言大型程序时极其重要工具，C语言对不完整类型的描述是：描述了变量，但缺少定义变量大小所需要的信息。不完整类型将会在程序的其它地方将信息补充完整。这就起到了很好的类型封装作用。由于编译器不知道不完整类型的大小，所以它的使用是受限的：</p> 
<ul><li>不能使用不完整类型来定义变量，但可以定义一个指向不完整类型的指针。</li><li>不能对不完整类型使用<code>sizeof</code>运算符。</li><li>数组、结构和联合的成员不可以具有不完整类型。</li><li>函数的形式参数不可以具有不完整类型。</li></ul> 
<h3><a id="_127"></a>变量的初始化和赋值</h3> 
<p>在使用变量前不仅要对其进行定义和声明，还要对其进行初始化和赋值：</p> 
<ul><li>变量的初始化：变量的初始化发生在变量定义时且只会被执行一次，它分为自动初始化和手动初始化。 
  <ul><li>自动初始化：只有具有静态存储期限的变量在定义时会基于类型自动初始化零值。</li><li>手动初始化：具有静态存储期限的变量的手动初始化值必须是常量。</li></ul> </li><li>变量的赋值：变量的赋值发生在变量定义之后。</li></ul> 
<h2><a id="_133"></a>表达式和运算符</h2> 
<p>表达式是表示如何计算的公式，任何一个表达式后加上一个分号就变成了一个语句。一些特殊的表达式如下：</p> 
<ul><li>常量表达式：不能包含变量和函数调用的表达式，常用于<code>case</code>语句后。</li><li>逗号表达式：可以使用逗号将多个表达式分隔而组成一个新的表达式，这个新表达式的值为最后一个子表达式的值，其它子表达式的值都将被抛弃。</li></ul> 
<h3><a id="_139"></a>左值和右值</h3> 
<p>左值表示一个内存空间，不能是常量或者表达式的计算结果。左值以外的值都是右值。赋值运算符要求它的左操作数必须是左值。</p> 
<h3><a id="_141"></a>表达式中的类型转换</h3> 
<p>在C语言中类型转换分为两种：第一种是编译器自己就能处理的隐式转换，第二种是使用强制运算符的显示转换。</p> 
<h4><a id="_143"></a>隐式转换</h4> 
<p>当发生下列情况会发生隐式转换:</p> 
<ul><li>算术表达式或逻辑表达式中操作数的类型不相同：此时会将操作数转换成适用于两个数值的最小类型: 
  <ul><li>当任意操作数为浮点类型时，会按照<code>float</code>、<code>double</code>、<code>long double</code>的顺序转换。</li><li>当两个操作数都不是浮点类型时，首先将两个操作数中能转换为<code>int</code>型的转换为<code>int</code>型，如果此时两个操作数的类型相同，过程结束。否则依次尝试以下规则: 
    <ul><li>如果两个操作数都是有符号数或无符号数，将类型小的操作数转换为类型大的操作数的同类型；</li><li>如果无符号数的存储范围大于等于有符号数的存储范围，则将有符号操作数转换为无符号操作数的类型；</li><li>如果有符号数可以表示所有无符号数，则将无符号操作数转换为有符号操作数的类型。</li></ul> </li></ul> </li><li>赋值运算符右侧表达式的类型和左侧变量的类型不匹配：唯一的转换原则是把赋值运算右边的表达式转换成左边变量的类型。</li><li>函数调用时实参和形参类型不匹配：如何转化实际参数的规则与编译器是否在调用前遇到函数的原型有关: 
  <ul><li>如果编译器在调用前遇见函数原型，那么就进行上文第一种的转换；</li><li>如果编译器在调用前没有遇见函数原型，那么就会把<code>float</code>类型实参转换为<code>double</code>类型，把<code>char</code>和<code>short int</code>类型实参转化为<code>int</code>型。</li></ul> </li><li><code>return</code>语句中表达式类型和函数返回值类型不匹配：进行上文第一种的转换。</li></ul> 
<h4><a id="_156"></a>强制转换</h4> 
<p>强制类型转换使用强制转换表达式进行转化，强制类型转换，当将大类型数据转换为小类型数据时会发生数据丢失。</p> 
<pre><code class="prism language-bash"><span class="token punctuation">(</span>type<span class="token punctuation">)</span>expression
</code></pre> 
<h3><a id="typedef_161"></a>typedef运算符</h3> 
<p><code>typedef</code>可以用来定义数据类型，<code>typedef</code>定义的类型会被编译器加入到它所识别的类型名列表。</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token operator">&lt;</span>primitiveType<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>newType<span class="token operator">&gt;</span>
</code></pre> 
<h3><a id="sizeof_167"></a>sizeof运算符</h3> 
<p><code>sizeof</code>表达式用于计算存储类型、常量、变量和表达式值的字节数，它的值一个<code>size_t</code>类型的值，这是一种无符号整数类型，所以在使用<code>sizeof</code>表达式时最好将它的值转换为<code>unsigned long</code>类型。</p> 
<pre><code class="prism language-c"><span class="token keyword">sizeof</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
</code></pre> 
<h2><a id="_173"></a>预处理器</h2> 
<p>C程序在编译之前会先使用预处理器处理代码。预处理器首先会清理代码，进行删除注释、多行语句合成一个逻辑行等工作。然后执行预处理指令。预处理指令以<code>#</code>号开头默认在行尾结束，如果需要在下一行延续指令，那么必须在当前行的末尾使用<code>\</code>进行换行，它可以出现在源文件的任何地方，且不需要以分号结尾。根据指令的作用可以将预处理指令分为宏定义指令、条件编译指令、文件包含指令以及其它指令。</p> 
<h3><a id="_175"></a>宏定义</h3> 
<p>宏定义的格式如下，宏的替换列表也可以包含对其它宏的调用。一个宏不可以被定义两遍，除非新的定义和旧的定义是一样的。当预处理器遇见宏定义时，会将文件中的宏（标识符）全部替换为替换列表。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">标识符 替换列表</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">标识符</span></span>
</code></pre> 
<h4><a id="_181"></a>带参数的宏</h4> 
<p>宏定义也可以带有参数，参数列表也可以为空，参数没有类型，也没有类型检查。标识符和左括号之间必须没有空格，如果有空格，预处理器会将括号右边的内容全部视为替换列表。如果在替换列表中使用了参数，那么每个参数都应该放在括号中，这么做可以保证替换前后的语义一致。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>  <span class="token expression">标识符<span class="token punctuation">(</span>x1<span class="token punctuation">,</span>x2<span class="token punctuation">,</span>x3<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>   替换列表</span></span>
</code></pre> 
<p>在调用宏时可以少传任意数量的参数，但实参列表必须要有和全参调用一样多的逗号。宏也支持可变参数列表，语法和函数相同，<code>__VA_ARGS__</code>是一个专门的标识符，只能出现在具有可变参数列表的宏的替换列表中，代表所有与省略号相对应的参数。</p> 
<h4><a id="_187"></a>多表达式、多语句的宏</h4> 
<p>当需要在宏定义中包含多个表达式时，可以使用逗号运算符进行分隔：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">标识符 <span class="token punctuation">(</span>expr1<span class="token punctuation">,</span>expr2<span class="token punctuation">)</span></span></span>
</code></pre> 
<p>当需要在宏定义中包含多条语句时，可以将语句放在<code>do-while</code>循环中，并将条件设置为假：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">标识符       </span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token keyword">do</span><span class="token punctuation">{<!-- --></span>             </span><span class="token punctuation">\</span>
		<span class="token expression">expr1； 	</span><span class="token punctuation">\</span>
		<span class="token expression">expr2<span class="token punctuation">;</span>  	</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
</code></pre> 
<h4><a id="_200"></a>宏中的运算符</h4> 
<p><code>#</code>运算符将宏的一个参数转换为字符串字面量。如果空参数成为该运算符的操作数，那么运算结果将是一个空串。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">input</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token function">scanf</span><span class="token punctuation">(</span>#a</span><span class="token string">"is%d"</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">b</span></span></span><span class="token string">"is%d"</span><span class="token expression"><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span></span></span>
</code></pre> 
<p><code>##</code>运算符可以将两个记号粘合在一起成为一个记号。如果该运算符之后的一个参数为空，那么它将被不可见的位置标记代替，</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">same</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">(</span>i</span><span class="token punctuation">##</span><span class="token expression">a<span class="token punctuation">)</span></span></span>
<span class="token keyword">int</span> <span class="token function">same</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">same</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">same</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等价于 int i1,i2,i3;</span>
</code></pre> 
<h4><a id="_210"></a>预定义的宏</h4> 
<p>C语言中一些常用的预定义宏如下：</p> 
<table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>__LINE __</td><td>当前程序行的行号，表示为整型常量</td></tr><tr><td>__FILE __</td><td>当前源文件名，表示字符串型常量</td></tr><tr><td>__DATE__</td><td>编译程序的日期，表示为<code>mm dd yy</code> 形式的字符串常量</td></tr><tr><td>__TIME __</td><td>编译程序的时间 ，表示<code>hh:mm:ss</code>形式的字符串型常量</td></tr><tr><td>__STDC __</td><td>如果编译器符合C标准，那么它的值为1</td></tr><tr><td>__STDC_VERSION __</td><td>支持的C标准版本</td></tr></tbody></table> 
<h3><a id="_221"></a>条件编译</h3> 
<p>条件编译是指根据预处理器所执行的测试结果来包含或排除程序的片段的行为。</p> 
<h4><a id="ifendif_223"></a>#if…#endif</h4> 
<p>当编译器遇见<code>#if</code>命令时，会计算常量表达式的值，如果常量表达式的值为假，那么它们之间的程序段将在预处理时从源代码中删除，否则就保留在程序中。值得注意的是<code>#if</code>命令会把没有定义的标识符当作值为零的宏对待。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">常量表达式</span></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression">常量表达式</span></span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<h4><a id="ifdefifndefendif_234"></a>#ifdef/#ifndef…#endif</h4> 
<p><code>#ifdef</code>和<code>#ifndef</code>命令会判断一个标识符是否是一个定义过的宏。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">标识符</span></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">标识符</span></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<h4><a id="defined_249"></a>defined</h4> 
<p><code>defined</code>是一个预处理运算符，如果它的参数是一个定义过的宏，就会返回<code>1</code>，否则返回<code>0</code>。因此<code>#ifdef</code>和<code>#ifndef</code>指令可以通过以下形式代替：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">defined 标识符</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token operator">!</span>defined 标识符</span></span>
</code></pre> 
<h3><a id="_257"></a>文件包含</h3> 
<p>多数情况下一个程序要分为多个源文件，其中一个源文件必须包含一个<code>main</code>函数，这个<code>main</code>函数会被启动代码调用，而启动代码是由编译器添加到程序中的，是程序和操作系统之间的桥梁。</p> 
<h4><a id="_259"></a>头文件</h4> 
<p>为了在多个源文件之间共享信息，可以把这些信息放到一个单独的文件中，然后使用<code>#include</code>命令把该文件的内容带到每个源文件中，把按照这种方式包含的文件称为头文件。通常会为每一个<code>.c</code>源文件创建相对应的同名头文件并且在源文件中包含同名头文件，然后再建立一个总的头文件将其它头文件都包含进去。如果要共享一个函数，那么首先将函数定义在一个源文件中，然后在同名头文件中包含这个函数的声明。如果要共享一个变量，那么首先将变量声明在一个源文件中，然后在同名头文件中使用<code>extern</code>关键字进行声明，<code>extern</code>关键字会告诉编译器该变量是在程序中的其它位置定义的，因此不需要为它分配内存空间，在数组的声明时可以省略数组的长度。</p> 
<h4><a id="include_261"></a>#include</h4> 
<p><code>#include</code>命令告诉预处理器打开指定的文件，并把这些文件的内容插入到当前文件中。该命令有三种格式：</p> 
<ul><li>第一种格式用于包含C库中的头文件，预处理器在执行此指令时直接搜索系统头文件所在的目录；</li><li>第二种格式用于包含自己编写的头文件，预处理器在执行此文件时先搜索当前目录，然后再搜索系统头文件所在的目录；</li><li>第三种格式中的记号就是宏定义的标识符，也就是将头文件名用宏定义一个记号。</li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;文件名&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"文件名"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token expression">记号</span></span>
</code></pre> 
<p>有时一个源文件可能重复包含相同的头文件，这可能会产生编译错误，如果有一个名为<code>test</code>的头文件那么可以在该文件中通过条件编译来解决问题：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">TEST_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TEST_H</span></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<h3><a id="_278"></a>其他指令</h3> 
<h4><a id="error_279"></a>#error</h4> 
<p><code>#error</code>可以让预处理器抛出一个错误，终止编译。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">error</span> <span class="token expression">消息</span></span>
</code></pre> 
<h4><a id="line_284"></a>#line</h4> 
<p><code>#line</code>指令可以使程序行从<code>n</code>开始编号，且该指令行不参与编号：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">line</span> <span class="token expression">n </span><span class="token comment">//n为整数</span></span>
</code></pre> 
<p>它还可以带一个文件名字符串，那么指令后边的行会被认为来自该文件：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">line</span> <span class="token expression">n fileName</span><span class="token comment">//n为整数</span></span>
</code></pre> 
<h2><a id="_293"></a>数组</h2> 
<p>数组变量代表内存中一片连续的存储空间，其中存储着相同类型的元素，在定义数组时，必须给出数组的大小：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//每有一个维度就增加一个括号</span>
</code></pre> 
<p>可以通过<code>{}</code>初始化数组，初始化时可以按照数组元素定义的顺序提供值，也可以直接在<code>{}</code>罗列出数组的元素值。并且提供的元素值可以少于数组元素的数量，但是不能为空，没有提供的元素会用零作为初始值，如果在定义数组变量时同时进行初始化，可以省略数组长度（多维数组只能省略第一维的长度）。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//[1,0,0,0,0]</span>
<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//[0,1,0,0,0,5]</span>
</code></pre> 
<p>数组变量本质是指向数组第一维元素的指针，并且编译器一旦为数组变量分配地址，这个地址就绑定这个数组变量了，这种绑定关系是不变的。因此数组变量不能作为左值出现，所以只能通过索引的方式为数组变量赋值：</p> 
<pre><code class="prism language-c">arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
</code></pre> 
<p>C语言还支持变长数组，变长数组的长度在程序执行时计算而不是在程序编译时计算，长度变量不能是一个被<code>const</code>修饰的具有静态存取期限的变量。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> length<span class="token punctuation">;</span>
<span class="token keyword">int</span> arr<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> 
<p>变长数组的限制在于它没有静态存储期限并且不能初始化式。</p> 
<h2><a id="_313"></a>字符串</h2> 
<p>字符串是用双引号括起来的字符序列，并以一个空字符<code>\0</code>来标识字符串的结束。C语言把字符串作为字符数组处理，当编译器在程序中遇到长度为<code>n</code>的字符串时，它会为字符串分配长度为<code>n+1</code>的内存空间，这块空间将用于存储字符串中的字符以及一个用来标志字符串末尾的空字符。</p> 
<h3><a id="_315"></a>字符串常量</h3> 
<p>使用字符指针初始化的字符串称为字符串常量，字符串常量是不可改变的，原因是系统会将字符串常量保存在内存的常量区，这个区是不允许用户修改的，因此在声明字符串常量时可以习惯性的加上<code>const</code>：</p> 
<pre><code class="prism language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>ch<span class="token operator">=</span><span class="token string">"abcdef"</span><span class="token punctuation">;</span>
</code></pre> 
<p>如果一行写不开可以在第一行以<code>\</code>结尾，第二行顶格写完：</p> 
<pre><code class="prism language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>ch<span class="token operator">=</span><span class="token string">"abc\
def"</span><span class="token punctuation">;</span>
</code></pre> 
<p>或者将它们分别用双引号引起来仅以空白字符分割，编译器会自动把它们打包成一个字符串常量：</p> 
<pre><code class="prism language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>ch<span class="token operator">=</span><span class="token string">"abc"</span> <span class="token string">"def"</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_329"></a>字符串变量</h3> 
<p>使用字符数组初始化的字符串称为字符串变量，字符串变量可以修改。在初始化的时候字符数组的长度应该比字符串的长度长一，也可以不指定数组长度。编译器会自动追加空字符来标识结尾。</p> 
<pre><code class="prism language-c"><span class="token keyword">char</span> ch<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"abcdef"</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="ltstringh_334"></a>&lt;string.h&gt;</h3> 
<p><code>&lt;string.h&gt;</code>头文件提供了一些字符串处理函数。</p> 
<pre><code class="prism language-c"><span class="token comment">//字符串复制</span>
<span class="token comment">//将src中前n个字符复制到dest，并返回dest。</span>
<span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> restrict dest<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict src<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">strncpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> restrict dest<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict src<span class="token punctuation">,</span><span class="token class-name">size_t</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">//字符串拼接</span>
<span class="token comment">//将src中前n个字符拼接到dest的末尾，并返回dest。</span>
<span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">strcat</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> restrict dest<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict src<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">strncat</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> restrict dest<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict src<span class="token punctuation">,</span><span class="token class-name">size_t</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//字符串比较</span>
<span class="token comment">//将s1和s2进行对比</span>
<span class="token keyword">int</span> <span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s1<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">strncmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s1<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s2<span class="token punctuation">,</span><span class="token class-name">size_t</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//字符串搜索</span>
<span class="token comment">//在s中正向或反向搜索字符c，返回一个指向s中第一个c的指针</span>
<span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">strchr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">strrchr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//返回一个指向s1中任意一个字符匹配的最左边的一个字符</span>
<span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">strpbrk</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s1<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//返回s1中第一个属于或不属于s2的字符的下标</span>
<span class="token class-name">size_t</span> <span class="token function">strspn</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s1<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">size_t</span> <span class="token function">strcspn</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s1<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//返回一个指向s1中第一次出现s2的指针</span>
<span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">strstr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s1<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//返回s的长度</span>
<span class="token class-name">size_t</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_363"></a>结构</h2> 
<p>结构的成员可以类型不同，并且每个成员都有自己的名字，选择结构成员时需要指定成员的名字。结构的成员在内存中按顺序存储。声明结构和定义结构变量有以下几种形式，常用的形式是第三种。</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> <span class="token operator">*</span> name<span class="token punctuation">;</span>
	<span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>person<span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> <span class="token operator">*</span> name<span class="token punctuation">;</span>
	<span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>Person<span class="token punctuation">;</span>

Person person<span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">Person</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> <span class="token operator">*</span> name<span class="token punctuation">;</span>
	<span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Person</span> person<span class="token punctuation">;</span>
</code></pre> 
<p>结构变量初始化时按照成员定义的顺序提供值，但是提供的成员值可以少于结构成员的数量，剩下的成员会用零作为初始值。</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">Person</span> person<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">"eric"</span><span class="token punctuation">,</span><span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Person</span> person<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token string">"eric"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>一个结构变量只能通过另一个结构变量进行赋值，这时会生成一个全新的副本。系统会分配一块新的内存空间，大小与原来的变量相同，把每个属性都复制过去，即原样生成了一份数据：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">Person</span> person1<span class="token punctuation">,</span> person2 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
        <span class="token string">"eric"</span><span class="token punctuation">,</span>
        <span class="token number">18</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
person1 <span class="token operator">=</span> person2<span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_402"></a>空位对齐</h3> 
<p>结构变量占用的存储空间，不是各个属性存储空间的总和，而是最大内存占用属性的存储空间的倍数，其他属性会添加空位（即不使用的字节）与之对齐。这样可以提高读写效率。由于这个特性，在有必要的情况下，定义结构体时，可以采用存储空间递增的顺序，定义每个属性，这样就能节省一些空间。这也导致了结构变量不能作为左值出现，因为即使结构变量对应，结构中的空位也不一定对应。所以在赋值时只能通过结构成员进行：</p> 
<pre><code class="prism language-java">person<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">"eric"</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_408"></a>结构中的位域</h3> 
<p>可以通过以下形式给结构成员指定它们要占用的<code>bit</code>位：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">BitFields</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> field1<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span>       <span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> field2<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>那么就将这样的成员称为位域，位域即一片在逻辑上连续的<code>bit</code>位，它在物理内存上连不连续由具体的实现决定，所以位域通常是没有地址的，C语言也禁止将取址运算符作用于位域。结构中位域的类型必须是<code>int</code>、<code>unsigned int,</code>或<code>signed int</code> ，但是最好是指明位域有无符号性，以免产生二义性。C语言还允许省略位域的名字，未命名的位域常作为位域间的填充，以保证其它位域存储在适当位置。</p> 
<h3><a id="_418"></a>灵活数组成员</h3> 
<p>当结构的最后一个成员是数组时，其长度是可以忽略的，那么这种结构成员就称为灵活数组成员。灵活数组成员是一种特殊的不完整类型，它的特殊之处在于：</p> 
<ul><li>灵活数组成员必须出现在结构的最后，而且结构必须至少还有一个其它成员。</li><li>复制包含灵活数组的结构时，其它结构成员都会被复制，但不会复制灵活数组本身。</li><li>在使用<code>sizeof</code>运算符来确定结构的字节数量时会忽略灵活数组的大小。</li><li>可以使用包含灵活数组的结构定义变量。</li><li>包含灵活数组的结构可以作为函数参数。</li></ul> 
<p>灵活数组成员的意义在于可以动态分配结构的内存大小。</p> 
<h2><a id="_428"></a>联合</h2> 
<p>联合和结构类似，它内部可以包含各种成员，但编译器只会给联合分配能够存下联合中最大成员的内存空间，所有联合成员共用这一片内存空间，因此联合成员在这内存空间内会相互影响彼此覆盖。联合的定义、初始化和赋值和结构相同，唯一的不同在于在进行联合变量的初始化时只能初始化第一个成员。</p> 
<h2><a id="_430"></a>枚举</h2> 
<p>枚举是一种由枚举常量组成的结构，在声明枚举时必须为每个常量命名：</p> 
<pre><code class="prism language-c"><span class="token keyword">enum</span> <span class="token punctuation">{<!-- --></span>
	PASS<span class="token punctuation">,</span>
	FAILED
<span class="token punctuation">}</span>status<span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{<!-- --></span>
	PASS<span class="token punctuation">,</span>
	FAILED
<span class="token punctuation">}</span>Status<span class="token punctuation">;</span>

Status status<span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-c"><span class="token keyword">enum</span> <span class="token class-name">Status</span><span class="token punctuation">{<!-- --></span>
	PASS<span class="token punctuation">,</span>
	FAILED
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">enum</span> <span class="token class-name">Status</span> status<span class="token punctuation">;</span>
</code></pre> 
<p>C语言会把枚举常量当作整数处理，默认情况下，编译器会把<code>0,1,2,...</code>赋值给枚举中的常量，也可以在声明时手动赋值，当没有为枚举常量指定值时，它的值默认比前一个常量值大一。</p> 
<pre><code class="prism language-c"><span class="token keyword">enum</span> <span class="token class-name">Status</span><span class="token punctuation">{<!-- --></span>
	PASS<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>
	FAILED<span class="token operator">=</span><span class="token number">0</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在为枚举变量初始化或赋值时，它的值只能是枚举常量：</p> 
<pre><code class="prism language-c">Status status<span class="token operator">=</span>PASS<span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_465"></a>函数</h2> 
<h3><a id="_466"></a>函数的声明和定义</h3> 
<p>在调用一个函数之前必须对其进行声明或定义：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在声明和定义一个函数时有以下几点要注意：</p> 
<ul><li>可以使用<code>static</code>和<code>extern</code>修饰函数，使用<code>static</code>声明和定义的函数具有内部连接，使用<code>extern</code>声明和定义的函数具有外部连接，默认情况下函数具有外部连接。</li><li>函数的形参具有和块作用域变量一样的默认性质。可以使用<code>const</code>修饰参数变量，表示函数内部不得修改该参数变量。</li><li>函数的返回类型不能是数组类型。</li></ul> 
<h3><a id="_478"></a>函数的原型</h3> 
<p>函数原型是指每个函数的返回类型、函数名和参数类型。其他信息都不需要，也不用包括函数体，具体的函数实现可以后面再补上。通过使用函数原型，就可以避免将所有函数都定义在<code>main</code>函数之前，一般来说，每个源码文件的头部，都会给出当前脚本使用的所有函数的原型。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">fun</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_485"></a>函数参数的传值方式</h3> 
<p>C语言中所有函数的参数都是按值传递的。并且数组类型的形参并不代表一个数组变量，因为当数组类型作为实参传递时，实际传递的是数组第一个元素的地址而不是数组的副本。因此<code>sizeof</code>运算符不能通过数组形参计算出数组的长度。所以当函数包含数组类型的形参时，最好在包含一个指示数组长度的形参。当变长数组作为形参时，这一要求就是硬性的，并且最好使用以下形式定义函数：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> length<span class="token punctuation">,</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="ltstdargh_492"></a>可变参数列表和&lt;stdarg.h&gt;</h3> 
<p>C语言允许函数据有可变参数列表，它的定义方式如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可变参数列列表必须有一个固定形参，并且<code>...</code>必须是形参列表的最后一个。<code>&lt;stdarg.h&gt;</code>头文件提供了处理函数可变形参的方法。</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">char</span><span class="token operator">*</span> va_list<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">va_start</span><span class="token punctuation">(</span>va_list ap<span class="token punctuation">,</span>可变列表前的参数<span class="token punctuation">)</span><span class="token punctuation">;</span>
类型 <span class="token function">va_arg</span><span class="token punctuation">(</span>va_list ap<span class="token punctuation">,</span>类型<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">va_copy</span><span class="token punctuation">(</span>va_list dest<span class="token punctuation">,</span>va_list src<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">va_end</span><span class="token punctuation">(</span>va_list ap<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>其中<code>va_list</code>是可变参数列表，所有非固定形参都存储在其中。<code>va_start</code>会指定可变参数列表的起始位置，<code>va_arg</code>会依次返回可变参数列表的每一个参数，并且可以指定我们希望的参数类型。<code>va_copy</code>用于将<code>src</code>中剩下的参数复制给<code>dest</code>。<code>va_end</code>用于清理资源，<code>va_start</code>和<code>va_copy</code>的使用必须和<code>va_end</code>成对出现。</p> 
<h3><a id="9595func9595_508"></a>__func__</h3> 
<p>每一个函数都可以访问<code>__func__</code>标识符，它的行为像一个存储当前正在执行的函数名称的字符串变量。</p> 
<h2><a id="_511"></a>指针</h2> 
<p>上文提到，每个变量都有一个内存地址，在C语言中，指针用来表示变量的地址。</p> 
<h3><a id="_513"></a>指针变量</h3> 
<p>指针变量就是存储指针的变量。C语言要求指针变量只能存储一种指向内存中特定类型变量的指针，指针变量的声明与普通变量基本一致，唯一的不同就是要在指针变量前加一个星号。指针变量的大小与它的类型无关，只与操作系统的寻址位数相关，如果是64位操作系统，那么指针变量的大小将为8字节。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token operator">*</span> p<span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_518"></a>指向指针的指针</h3> 
<p>指针变量也是有地址的，那么把指针变量的地址称为指向指针的指针，存储指向指针的指针的指针变量的定义方式如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span> p；
</code></pre> 
<p>以此类推通过增加星号的个数就可以定义指向指向指针的指针的指针变量。</p> 
<h3><a id="_524"></a>取地址运算符和间接寻址运算符</h3> 
<p>取地址运算符<code>&amp;</code>可以将某个变量的地址赋值给一个指针变量：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">;</span>
p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
</code></pre> 
<p>一旦指针变量指向了变量，那么就可以通过间接寻址运算符<code>*</code>访问指针指向的变量了：</p> 
<pre><code class="prism language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_534"></a>空指针</h3> 
<p>空指针是不指向任何地方的指针，用宏<code>NULL</code>来表示，在C语言中所有非空指针都为真，只有空指针为假。在声明指针变量时，最好使用空指针进行初始化：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_540"></a>通用指针</h3> 
<p><code>void *</code> 类型的指针变量存储的指针是通用指针，本质上它只是内存地址。通用指针可以被赋值给任何类型的指针变量。通用指针变量也可以被任何类型的指针赋值。</p> 
<h3><a id="_542"></a>受限指针</h3> 
<p>使用<code>restrict</code>关键字声明的指针叫做受限指针，如果受限指针指向的变量在之后需要修改，那么该变量不允许通过除该指针之外的任何方式访问。<code>restrict</code>是一种对编译器优化的建议，有没有<code>restrict</code>程序的行为不会发生变化。</p> 
<h3><a id="_544"></a>内存的动态分配与释放</h3> 
<p>内存的动态分配需要使用<code>&lt;stdlib.h&gt;</code>头中的函数：</p> 
<pre><code class="prism language-c"><span class="token comment">//分配内存块，但不对内存块进行初始化。</span>
<span class="token comment">//size:字节数</span>
<span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//分配内存块，并对内存块进行零值初始化。</span>
<span class="token comment">//nmemb:元素个数</span>
<span class="token comment">//size:元素大小</span>
<span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">calloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> nmemb<span class="token punctuation">,</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//调整先前分配内存块的大小。</span>
<span class="token comment">//ptr:指向来自这三个函数分配的内存空间</span>
<span class="token comment">//size:新内存空间的大小</span>
<span class="token comment">//一但该函数返回，必须对指向原内存块的指针进行更新，因为该函数可能将内存块移动到了其他地方。</span>
<span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> ptr<span class="token punctuation">,</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>内存分配函数分配的内存块全部来自一个称为堆的存储池，程序可能分配了内存块但丢失了指向这些内存块的指针，这就会造成内存泄漏现象，因此在使用完内存之后就必须使用<code>free</code>函数进行手动释放：</p> 
<pre><code class="prism language-c"><span class="token comment">//ptr:指向来自这三个函数分配的内存空间</span>
<span class="token keyword">void</span> <span class="token function">free</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>原本指向被<code>free</code>函数释放的内存空间的指针就变成了悬空指针，它们不会指向任何地方。在<code>&lt;string.h&gt;</code>头文件还有一些有关内存操作的函数：</p> 
<pre><code class="prism language-c"><span class="token comment">//将src中前n个字节拷贝到dest中，并返回dest，如果src和dest存在内存重叠，那么结果将是未定义的</span>
<span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> restrict dest<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> restrict src<span class="token punctuation">,</span><span class="token class-name">size_t</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//将将src中前n个字节拷贝到dest中，并返回dest，不受内存重叠影响</span>
<span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">memmove</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> dest<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> src<span class="token punctuation">,</span><span class="token class-name">size_t</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//比较s1和s2前n个字节的大小</span>
<span class="token keyword">int</span> <span class="token function">memcmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> s1<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> s2<span class="token punctuation">,</span><span class="token class-name">size_t</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//返回一个指向s中第一次出现字节c的指针</span>
<span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">memchr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> s<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">,</span><span class="token class-name">size_t</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//将s中前n个字节设置为c</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">memset</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>s<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">,</span><span class="token class-name">size_t</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_578"></a>指针与数组</h3> 
<p>当指针指向数组的元素时，就可以对指针进行算数和逻辑运算。</p> 
<ul><li>指针加上整数：如果指针加上一个整数<code>i</code>，那么指针将向前移动<code>i</code>个单位。</li><li>指针减去整数：如果指针减去一个整数<code>i</code>，那么指针将向后移动<code>i</code>个单位。</li><li>两个指针相减：结果为两个指针之间的距离。</li><li>两个指针比较：比较的是各自的内存地址哪一个更大。</li></ul> 
<p>一定要注意，这里提到的单位与指针的类型相关，请看下面的例子：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
            <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token punctuation">{<!-- --></span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token punctuation">{<!-- --></span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p3<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">;</span>
    <span class="token function">distance</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1</span>
    <span class="token function">distance</span><span class="token punctuation">(</span>p2<span class="token punctuation">,</span> p2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3</span>
    <span class="token function">distance</span><span class="token punctuation">(</span>p3<span class="token punctuation">,</span> p3 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//9</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--p2行遍历--\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d,"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>p2 <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     * --p2行遍历--
     * 1,2,3,
     * 4,5,6,
     * 7,8,9,
     */</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--p3行遍历--\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d,"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>p3 <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     * --p3行遍历--
     * 1,2,3,
     * 4,5,6,
     * 7,8,9,
     */</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--p2列遍历--\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d,"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>p2 <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     * --p2列遍历--
     * 1,4,7,
     * 2,5,8,
     * 3,6,9,
     */</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--p3列遍历--\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d,"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>p3 <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     * --p3列遍历--
     * 1,4,7,
     * 2,5,8,
     * 3,6,9,
     */</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%ld\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>b <span class="token operator">-</span> a<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_668"></a>指针与结构</h3> 
<p>当一个指针指向结构变量时，可以使用右箭头选择操作符访问结构变量中的成员：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">test</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">test</span> var<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token operator">*</span>ptr<span class="token punctuation">;</span>
ptr<span class="token operator">=</span><span class="token operator">&amp;</span>var<span class="token punctuation">;</span>
</code></pre> 
<p>那么下面两个表达式是一样的：</p> 
<pre><code class="prism language-c"><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">.</span>a
ptr<span class="token operator">-&gt;</span>a
</code></pre> 
<p>结构变量在嵌套自身时只能定义一个指针类型数据，因为只有指针变量的大小编译器是已知的，始终为计算机的字长，并且此结构在声明时必须使用结构标记的方式。</p> 
<h3><a id="_683"></a>指针与函数</h3> 
<p>每一个函数都有一个地址，那么把函数的地址称为指向函数的指针，存储指向函数的指针的指针变量的定义方式如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>通过以下方式给指针变量赋值，这是因为当函数名后面没有括号时，编译器会产生一个指向该函数的指针，而不会产生函数调用的代码。</p> 
<pre><code class="prism language-c">p<span class="token operator">=</span>fun<span class="token punctuation">;</span>
</code></pre> 
<p>在使用指针变量调用函数时，可以通过以下两种方式：</p> 
<pre><code class="prism language-c"><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">p</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="ltstdioh_697"></a>输入输出&lt;stdio.h&gt;</h2> 
<h3><a id="_698"></a>流</h3> 
<p>在C语言中术语流表示任意输入的源或任意输出的目的地。流可以是键盘、鼠标、屏幕、硬盘以及网卡等。在Linux中万物皆文件，所以也可以说流就是文件，因此在C语言中对流的访问都是通过文件指针<code>FILE *</code>实现的。<code>&lt;stdio.h&gt;</code>头文件定义了三个标准流，这些流可以直接使用，不需要对其进行声明、打开或关闭。</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">xxx</span> FILE<span class="token punctuation">;</span>

<span class="token comment">//文件末尾标志</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EOF</span> <span class="token expression"><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>

<span class="token comment">//缓冲区模式</span>
<span class="token comment">//当缓冲区为空时，从流读入数据，当缓冲区满时，向流写入数据。对于没有交互式设备相连的流来说是默认的</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_IOFBF</span> <span class="token expression"><span class="token number">0x0000</span> </span></span>
<span class="token comment">//每次从流读入一行数据或向流写入一行数据</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_IOLBF</span> <span class="token expression"><span class="token number">0x0040</span></span></span>
<span class="token comment">//直接从流读入数据或直接向流写入数据</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_IONBF</span> <span class="token expression"><span class="token number">0x0004</span></span></span>

<span class="token comment">//偏移基准</span>
<span class="token comment">//文件的当前位置</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEEK_CUR</span>    <span class="token expression"><span class="token number">1</span></span></span>
<span class="token comment">//文件的结束处</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEEK_END</span>    <span class="token expression"><span class="token number">2</span></span></span>
<span class="token comment">//文件的起始处</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEEK_SET</span>    <span class="token expression"><span class="token number">0</span></span></span>

FILE<span class="token operator">*</span> <span class="token function">__acrt_iob_func</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> _Ix<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//标准输入流，默认是键盘</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">stdin</span>  <span class="token expression"><span class="token punctuation">(</span><span class="token function">__acrt_iob_func</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token comment">//标准输出流，默认是屏幕</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">stdout</span> <span class="token expression"><span class="token punctuation">(</span><span class="token function">__acrt_iob_func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token comment">//标准错误流，默认是屏幕</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">stderr</span> <span class="token expression"><span class="token punctuation">(</span><span class="token function">__acrt_iob_func</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
</code></pre> 
<h3><a id="_730"></a>文件操作</h3> 
<p><code>&lt;stdio.h&gt;</code>头文件支持操作字符文件和二进制文件，本质上说所有文件都是二进制文件，只是字符文件中字节表示一个字符而二进制文件中单个字节没有什么意义。文件都存放在磁盘中，每次读写文件都直接访问磁盘是非常消耗系统资源的，因此就需要使用内存充当缓冲区来进行优化。以写文件为例：把输入流的数据写入到缓冲区，当缓冲区满了或关闭流时缓冲区就会自动将数据刷新到磁盘中。每个流都有与之相关的错误指示器和文件末尾指示器，当打开流时就会重置这些指示器，当遇见错误或文件末尾时就会设置这些指示器，一旦设置了指示器，它就会保持这种状态直到显式清除。每个流都有一个相关联的文件位置，当打开文件时，会将文件位置设置在文件开头或结尾(追加方式打开)，在执行读写操作时文件位置会自动推进。</p> 
<pre><code class="prism language-c"><span class="token comment">//打开文件，其中mode表示要对文件采取的操作，</span>
<span class="token comment">//rb:打开文件用于读;wb:打开文件用于写(文件不需要存在);ab:打开文件用于追加写(文件不需要存在);</span>
<span class="token comment">//rb+:打开文件用于读和覆盖写;wb+:打开文件用于读和覆盖写(文件不需要存在);ab+:打开文件用于读和追加写(文件不需要存在);</span>
<span class="token comment">//将上述模式中的b去掉二进制文件的模式</span>
<span class="token comment">//对于含有+的模式而言，如果没有调用文件定位函数就不能从读膜室切换为写模式</span>
<span class="token comment">//对于含有+的模式而言，如果没有调用文件定位函数或fflush函数就不能从写膜室切换为读模式</span>
FILE<span class="token operator">*</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict fileName<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//关闭文件，失败返回EOF</span>
<span class="token keyword">int</span> <span class="token function">fclose</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//为已经打开的流附加上一个文件，返回stream</span>
FILE<span class="token operator">*</span> <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict fileName<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict mode<span class="token punctuation">,</span>FILE<span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//创建一个临时文件并用wb+模式打开，当关闭文件或结束程序时消失</span>
FILE<span class="token operator">*</span> <span class="token function">tmpfile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//产生临时文件名，并保存到s中，如果s是空指针，那么就保存到一个静态变量中并返回指向这个变量的指针</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">tmpnam</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//刷新stream的缓冲区</span>
<span class="token keyword">int</span> <span class="token function">fflush</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//用于设置缓冲区</span>
<span class="token comment">//buffer:指定缓冲区的地址</span>
<span class="token comment">//mode:缓冲区的模式</span>
<span class="token comment">//size:缓冲区的大小</span>
<span class="token keyword">void</span> <span class="token function">setbuf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> restrict stream<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span> restrict buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">setvbuf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> restrict stream<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span> restrict buffer<span class="token punctuation">,</span><span class="token keyword">int</span> mode<span class="token punctuation">,</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//删除文件</span>
<span class="token keyword">int</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//修改文件名</span>
<span class="token keyword">int</span> <span class="token function">rename</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> oldFileName<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> newFileName<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">feof</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">ferror</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//clearerr方法是显式清除这两种指示器的方式之一</span>
<span class="token keyword">void</span> <span class="token function">clearerr</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//ftell返回当前的文件位置</span>
<span class="token keyword">long</span> <span class="token function">ftell</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//将文件位置设置到文件起始处</span>
<span class="token keyword">void</span> <span class="token function">rewind</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//以origin为基准，将文件位置偏移offset</span>
<span class="token keyword">int</span> <span class="token function">fseek</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> stream<span class="token punctuation">,</span><span class="token keyword">long</span> offset<span class="token punctuation">,</span><span class="token keyword">int</span> origin<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//是一个有符号的整数类型</span>
<span class="token keyword">typedef</span> xxx <span class="token class-name">fpos_t</span><span class="token punctuation">;</span>
<span class="token comment">//将文件位置存储到position中</span>
<span class="token keyword">int</span> <span class="token function">fgetpos</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> stream<span class="token punctuation">,</span><span class="token class-name">fpos_t</span> <span class="token operator">*</span> position<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//设置文件的位置为position</span>
<span class="token keyword">int</span> <span class="token function">fsetpos</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> stream<span class="token punctuation">,</span><span class="token class-name">fpos_t</span> <span class="token keyword">const</span> <span class="token operator">*</span> position<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_782"></a>格式化输入输出</h3> 
<pre><code class="prism language-c"><span class="token comment">//向标准流输入输出</span>
<span class="token keyword">int</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict format<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict format<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//向指定流输入输出</span>
<span class="token keyword">int</span> <span class="token function">fprintf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> restrict stream<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict format<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fscanf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> restrict stream<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict format<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>printf</code>函数的格式串可以包含普通字符和转换说明，普通字符会原样输出，转换说明描述了如何把剩余的实参转换为字符串格式显示出来。转换说明符由百分号开头和跟随其后的最多五个部分组成：</p> 
<pre><code class="prism language-c"><span class="token operator">%</span> 标志 最小字段宽度 精度 长度修饰符 转换说明符
</code></pre> 
<ul><li>标志及其作用如下：</li></ul> 
<table><thead><tr><th>标志</th><th>作用</th></tr></thead><tbody><tr><td>-</td><td>在字段内左对齐，默认是右对齐</td></tr><tr><td>+</td><td>有符号转换得到的数以<code>+</code>或<code>-</code>开头</td></tr><tr><td>空格</td><td>有符号转换得到的非负数前面加空格</td></tr><tr><td>#</td><td>以八进制数、十六进制非零数以及浮点数始终有小数点，不能删除由g或G转换输出的数的小数点</td></tr><tr><td>0</td><td>用前导<code>0</code>在数的字段宽度内进行填充，如果转换是<code>d</code>、<code>i</code>、<code>o</code>、<code>u</code>、<code>x</code>，并且指定了精度，那么可以忽略该标志</td></tr></tbody></table> 
<ul><li>最小字段宽度：如果数据项太小无法达到这一宽度，那么会对字段进行填充，默认会在数据项左侧添加空格使其右对齐。字段宽度可以是整数也可以是字符<code>*</code>，如果是字符<code>*</code>那么字段宽度由下一个参数决定。</li><li>精度：精度的含义依赖于转换说明符，如果转换说明符是<code>d</code>、<code>i</code>、<code>o</code>、<code>u</code>、<code>x</code>、，那么精度表示最小位数；如果是<code>a</code>、<code>e</code>、<code>f</code>、那么精度表示小数点后的位数；如果是、<code>g</code>，那么精度表示有效数字的个数，如果是<code>s</code>，那么精度表示最大字节数。精度是由小数点后跟一个整数或者字符<code>*</code>构成的，如果出现字符<code>*</code>那么精度由下一个参数决定。</li><li>长度修饰符：长度修饰符表明待显示的数据项类型的长度大于或小于特定转换说明中的正常值。</li></ul> 
<table><thead><tr><th>长度修饰符</th><th>转换说明符</th><th>含义</th></tr></thead><tbody><tr><td>hh</td><td>dioux</td><td>signed char、unsigned char</td></tr><tr><td></td><td>n</td><td>signed char *</td></tr><tr><td>h</td><td>dioux</td><td>short int、unsigned short int</td></tr><tr><td></td><td>n</td><td>short int *</td></tr><tr><td>l</td><td>dioux</td><td>long int、unsigned long int</td></tr><tr><td></td><td>n</td><td>long int *</td></tr><tr><td></td><td>c</td><td>wint_t</td></tr><tr><td></td><td>s</td><td>wchar_t</td></tr><tr><td></td><td>aefg</td><td>无作用</td></tr><tr><td>ll</td><td>dioux</td><td>long long int、unsigned long long int</td></tr><tr><td></td><td>n</td><td>long long int *</td></tr><tr><td>j</td><td>dioux</td><td>intmax_t、uintmax_t</td></tr><tr><td></td><td>n</td><td>intmax_t *</td></tr><tr><td>z</td><td>dioux</td><td>size_t</td></tr><tr><td></td><td>n</td><td>size_t*</td></tr><tr><td>t</td><td>dioux</td><td>ptrdiff_t</td></tr><tr><td></td><td>n</td><td>ptrdiff_t</td></tr><tr><td>L</td><td>aefg</td><td>long double</td></tr></tbody></table> 
<ul><li>转换说明符：</li></ul> 
<table><thead><tr><th>转换说明符</th><th>说明</th></tr></thead><tbody><tr><td>d、i</td><td>把<code>int</code>类型值转换为十进制形式</td></tr><tr><td>o、u、x</td><td>把无符号整数转换为八进制、十进制或十六进制形式</td></tr><tr><td>f</td><td>把<code>double</code>类型值转换为十进制形式，默认保留小数点后六位</td></tr><tr><td>e</td><td>把<code>double</code>类型值转换为科学计数法形式，默认保留小数点后六位</td></tr><tr><td>g</td><td>把<code>double</code>类型值转换为f形式或<code>e</code>形式，当数值的指数部分小于<code>-4</code>或大于等于精度值时会选择<code>e</code>形式显式，默认尾部的<code>0</code>不显示，且小数点仅在后边跟有数字时才显示出来。</td></tr><tr><td>c</td><td>显式无符号字符的<code>int</code>类型值</td></tr><tr><td>s</td><td>显式由实参指向的字符</td></tr><tr><td>p</td><td>把<code>void *</code> 显示为可打印形式</td></tr><tr><td>n</td><td>相应的实参必须是指向<code>int</code>型的指针，在该实参中存储<code>printf</code>函数已经输出的字符数量，本身不显示输出</td></tr><tr><td>%</td><td>写字符<code>%</code></td></tr></tbody></table> 
<p><code>scanf</code>函数的格式串表示的是<code>scanf</code>函数在读取输入时试图匹配的模式，如果一旦发现输入与格式串不匹配，那么函数就会立即返回，不匹配的数据将会被放回等待下次读取。<code>scanf</code>函数的格式串由以下三部分组成：<br> `</p> 
<ul><li>转换说明：和<code>printf</code>函数的转换说明类似，大多数转换说明都会跳过输入项开始处的空白字符(<code>%[</code>、<code>%c</code>和<code>%n</code>除外)。</li><li>空白字符：<code>scanf</code>函数的格式串中的一个或多个连续的空白字符和输入流中的零个或多个空白字符匹配。</li><li>非空白字符：除了<code>%</code>之外的所有非空白字符都必须和输入流中的相同字符匹配。</li></ul> 
<p><code>scanf</code>函数的转换说明符组成部分如下：</p> 
<pre><code class="prism language-c"><span class="token operator">%</span> 字符<span class="token operator">*</span> 最大字段宽度 长度修饰符
</code></pre> 
<ul><li>字符*：赋值屏蔽，读入此数据项但是不把它赋值给对象，也不包含在函数返回的计数中。</li><li>最大字段宽度：限制输入项中的字符数量，如果达到这个最大值，那么此数据项的转换将结束，转换开始处跳过的空白字符不进行统计。</li><li>长度修饰符：表明用于存储输入数据项的变量的类型与特定转换说明中的常见类型长度不一致。</li></ul> 
<table><thead><tr><th>长度修饰符</th><th>转换说明符</th><th>含义</th></tr></thead><tbody><tr><td>hh</td><td>diouxn</td><td>signed char *、unsigned char *</td></tr><tr><td>h</td><td>diouxn</td><td>short int *、unsigned short int *</td></tr><tr><td>l</td><td>diouxn</td><td>long int *、unsigned long int *</td></tr><tr><td></td><td>aefg</td><td>double *</td></tr><tr><td></td><td>cs[ ]</td><td>wchar_t *</td></tr><tr><td>ll</td><td>diouxn</td><td>long long int *、unsigned long long int *</td></tr><tr><td>j</td><td>diouxn</td><td>intmax_t *、uintmax_t *</td></tr><tr><td>z</td><td>diouxn</td><td>size_t *</td></tr><tr><td>t</td><td>diouxn</td><td>ptrdiff_t *</td></tr><tr><td>L</td><td>aefg</td><td>long double *</td></tr></tbody></table> 
<ul><li>转换说明符：</li></ul> 
<table><thead><tr><th>转换说明符</th><th>说明</th></tr></thead><tbody><tr><td>d</td><td>匹配十进制整数</td></tr><tr><td>i</td><td>匹配整数</td></tr><tr><td>o、u、x</td><td>匹配无符号八进制、十进制或十六进制整数</td></tr><tr><td>a、e、f、g</td><td>匹配单精度浮点数</td></tr><tr><td>c</td><td>匹配单个字符</td></tr><tr><td>s</td><td>匹配非空字符串</td></tr><tr><td>[ ]</td><td>匹配来自集合的非空字符序列，然后在末尾添加空字符，实参是指向字符数组的指针，可以使用<code>^</code>进行前置否定</td></tr><tr><td>p</td><td>以<code>printf</code>函数的输出格式匹配指针值</td></tr><tr><td>n</td><td>相应的实参必须是指向<code>int</code>型的指针，把目前为止读到的字符数量存储到该实参</td></tr><tr><td>%</td><td>匹配字符<code>%</code></td></tr></tbody></table> 
<h3><a id="_885"></a>字符的输入输出</h3> 
<pre><code class="prism language-c"><span class="token comment">//向标准流输入输出</span>
<span class="token keyword">int</span> <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token keyword">int</span> character<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//向指定流输入输出</span>
<span class="token keyword">int</span> <span class="token function">putc</span><span class="token punctuation">(</span><span class="token keyword">int</span> character<span class="token punctuation">,</span>FILE <span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">getc</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token keyword">int</span> character<span class="token punctuation">,</span>FILE <span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fgetc</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//把从流中读入的字符放回并清空文件末尾指示器</span>
<span class="token keyword">int</span> <span class="token function">ungetc</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span>FILE <span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_898"></a>行的输入输出</h3> 
<pre><code class="prism language-c"><span class="token comment">//向标准流输入输出</span>
<span class="token comment">//puts在写入完成时会添加一个换行符</span>
<span class="token keyword">int</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//gets函数遇见换行符停止并舍弃换行符</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">gets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//向指定流输入输出</span>
<span class="token keyword">int</span> <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> restrict <span class="token operator">*</span> s<span class="token punctuation">,</span>FILE <span class="token operator">*</span> restrict stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">fgets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> restrict s<span class="token punctuation">,</span><span class="token keyword">int</span> maxCount<span class="token punctuation">,</span>FILE <span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_909"></a>块的输入输出</h3> 
<pre><code class="prism language-c"><span class="token comment">//ptr:数组地址</span>
<span class="token comment">//size:数组元素大小</span>
<span class="token comment">//nmemb:元素数量</span>
<span class="token class-name">size_t</span> <span class="token function">fread</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> restrict ptr<span class="token punctuation">,</span><span class="token class-name">size_t</span> size<span class="token punctuation">,</span><span class="token class-name">size_t</span> nmemb<span class="token punctuation">,</span>FILE <span class="token operator">*</span> restrict stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">size_t</span> <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> restrict ptr<span class="token punctuation">,</span><span class="token class-name">size_t</span> size<span class="token punctuation">,</span><span class="token class-name">size_t</span> nmemb<span class="token punctuation">,</span> FILE <span class="token operator">*</span> restrict stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_917"></a>字符串的输入输出</h3> 
<pre><code class="prism language-c"><span class="token comment">//将格式化串输出到buffer中</span>
<span class="token keyword">int</span> <span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> restrict buffer<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict format<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">snprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> restrict buffer<span class="token punctuation">,</span><span class="token class-name">size_t</span> n<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict format<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//从buffer中输入</span>
<span class="token keyword">int</span> <span class="token function">sscanf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict buffer<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict format<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_925"></a>错误处理</h2> 
<h3><a id="ltasserth_926"></a>&lt;assert.h&gt;</h3> 
<p>每次执行<code>assert</code>时，都会检查它的参数值是否为假。如果参数为假那么<code>assert</code>就会向<code>stderr</code>写一条消息并调用<code>abort</code>函数终止程序。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">assert</span><span class="token expression"><span class="token punctuation">(</span>expression<span class="token punctuation">)</span> xxx</span></span>
</code></pre> 
<p><code>assert</code>一般用于调试阶段，因此会在生产时期禁止它，禁止的方式很容易，只需要在包含<code>&lt;assert.h&gt;</code>头文件之前定义宏<code>NDEBUG</code>即可。</p> 
<h3><a id="ltsignalh_932"></a>&lt;signal.h&gt;</h3> 
<p><code>&lt;signaal.h&gt;</code>头文件提供了信号处理的工具，信号有两种类型：运行时错误和发生在程序之外的事件，大多数信号是异步的。<code>&lt;signaal.h&gt;</code>头文件定义了一系列的宏来表示不同的信号：</p> 
<pre><code class="prism language-c"><span class="token comment">//中断信号</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIGINT</span> <span class="token expression"><span class="token number">2</span>   </span></span>
<span class="token comment">//无效指令</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIGILL</span> <span class="token expression"><span class="token number">4</span>  </span></span>
<span class="token comment">//浮点数异常</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIGFPE</span> <span class="token expression"><span class="token number">8</span></span></span>
<span class="token comment">//无效存储访问</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIGSEGV</span> <span class="token expression"><span class="token number">11</span></span></span>
<span class="token comment">//终止请求</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIGTERM</span> <span class="token expression"><span class="token number">15</span></span></span>
<span class="token comment">//Ctrl-Break sequence</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIGBREAK</span> <span class="token expression"><span class="token number">21</span>  </span></span>
<span class="token comment">//异常终止</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIGABRT</span> <span class="token expression"><span class="token number">22</span></span></span>
<span class="token comment">//与其它平台兼容的SIGABRT</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIGABRT_COMPAT</span> <span class="token expression"><span class="token number">6</span>   </span></span>
</code></pre> 
<p><code>signal</code>函数第一个参数是信号编码，第二个参数是一个指向信号发生时处理这一信号的函数的指针。当一个信号产生并调用特定的处理函数时，信号的编码会作为参数传给处理函数。在信函处理函数内只能调用<code>signal</code>函数和<code>reise</code>函数，并且不能使用具有静态存储权限的变量。如果信号是由<code>abort</code>函数或<code>raise</code>函数引发的，那么信号处理函数可以调用库函数或使用具有静态存储权限的变量。但是不能调用<code>raise</code>函数。一旦处理函数返回，程序会在信号发生点恢复并继续执行，但如果信号是<code>SIGABRT</code>，程序会直接终止；如果信号是<code>SIGFPE</code>、<code>SIGILL</code>和<code>SIGSEGV</code>，那么处理函数返回的结果是未定义的。<code>signal</code>函数的返回值是一个指向前一个处理函数的指针。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>也可以使用一些预定义的处理函数：</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> _crt_signal_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIG_DFL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>_crt_signal_t<span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span>     </span><span class="token comment">// 默认行为</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIG_IGN</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>_crt_signal_t<span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">)</span>     </span><span class="token comment">// 忽视信号</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIG_GET</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>_crt_signal_t<span class="token punctuation">)</span><span class="token number">2</span><span class="token punctuation">)</span>     </span><span class="token comment">// 返回当前值</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIG_SGE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>_crt_signal_t<span class="token punctuation">)</span><span class="token number">3</span><span class="token punctuation">)</span>     </span><span class="token comment">// signal gets error</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIG_ACK</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>_crt_signal_t<span class="token punctuation">)</span><span class="token number">4</span><span class="token punctuation">)</span>     </span><span class="token comment">// 告知收到</span></span>
</code></pre> 
<p><code>raise</code>函数可以模拟信号的产生：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">raise</span><span class="token punctuation">(</span><span class="token keyword">int</span> signal<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="ltsetjmph_969"></a>&lt;setjmp.h&gt;</h3> 
<p>通常情况下函数会返回到它被调用的位置，但是<code>&lt;setjmp.h&gt;</code>头文件可以使一个函数直接跳转到另一个函数而不需要返回。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">setjmp</span><span class="token punctuation">(</span>jmp_buf env<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">longjmp</span><span class="token punctuation">(</span>jmp_buf env<span class="token punctuation">,</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>setjmp</code>用来标记程序中的一个位置，它接收一个<code>jmp_buf</code> 类型的参数，<code>setjmp</code>会将当前环境存储到该变量中。然后返回零。<code>longjmp</code>可以跳转到<code>setjmp</code>标记的位置。该函数的参数是使用<code>setjmp</code>函数时的同一个<code>jmp_buf</code>变量，该函数首先根据<code>jmp_buf</code>变量的内容恢复当前的环境，然后从<code>setjmp</code>宏中返回，此时<code>setjmp</code>宏返回的是<code>val</code>。如果<code>val</code>的值是<code>0</code>那么<code>setjmp</code>将返回<code>1</code>。</p> 
<h2><a id="_976"></a>其它标准库</h2> 
<p>截至C99版本，C语言中的标准库有以下24个，大多数编译器都会使用更大的库，但他们不属于标准库的范畴。</p> 
<table><thead><tr><th>库名</th><th>说明</th></tr></thead><tbody><tr><td>&lt;assert.h&gt;</td><td>诊断</td></tr><tr><td>&lt;ctype.h&gt;</td><td>字符处理</td></tr><tr><td>&lt;errno.h&gt;</td><td>错误</td></tr><tr><td>&lt;float.h&gt;</td><td>浮点类型的特性</td></tr><tr><td>&lt;limite.h&gt;</td><td>整数类型的大小</td></tr><tr><td>&lt;locale.h&gt;</td><td>本地化</td></tr><tr><td>&lt;math.h&gt;</td><td>数学计算</td></tr><tr><td>&lt;setjmp.h&gt;</td><td>非本地跳转</td></tr><tr><td>&lt;signal.h&gt;</td><td>非本地跳转</td></tr><tr><td>&lt;stdarg.h&gt;</td><td>可变参数</td></tr><tr><td>&lt;stddef.h&gt;</td><td>常用定义</td></tr><tr><td>&lt;stdio.h&gt;</td><td>输入输出</td></tr><tr><td>&lt;stdlib.h&gt;</td><td>常用实用程序</td></tr><tr><td>&lt;string.h&gt;</td><td>字符串处理</td></tr><tr><td>&lt;time.h&gt;</td><td>时间和日期</td></tr><tr><td>&lt;complex.h&gt;</td><td>复数算数</td></tr><tr><td>&lt;fenv.h&gt;</td><td>浮点环境</td></tr><tr><td>&lt;inttypes.h&gt;</td><td>整数类型格式转换</td></tr><tr><td>&lt;iso646.h&gt;</td><td>拼写转换</td></tr><tr><td>&lt;stdbool.h&gt;</td><td>布尔类型和值</td></tr><tr><td>&lt;stdint.h&gt;</td><td>整数类型</td></tr><tr><td>&lt;tgmath.h&gt;</td><td>泛型数学</td></tr><tr><td>&lt;wchar.h&gt;</td><td>扩展的宽字节和多字节实用工具</td></tr><tr><td>&lt;wctype.h&gt;</td><td>宽字符分类和映射实用工具</td></tr></tbody></table> 
<h3><a id="ltstddefh_1005"></a>&lt;stddef.h&gt;</h3> 
<p><code>&lt;stddef.h&gt;</code>头文件提供了常用的类型和宏的定义：</p> 
<pre><code class="prism language-c"><span class="token comment">//空指针</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token comment">//s是一个结构类型，m是一个结构成员</span>
<span class="token comment">//计算结构的起点到指定成员间的字节数</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">offsetof</span><span class="token expression"><span class="token punctuation">(</span>s<span class="token punctuation">,</span>m<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token comment">//是一个有符号的整数类型</span>
<span class="token comment">//当指针相减时结果的类型</span>
<span class="token keyword">typedef</span> xxx <span class="token class-name">ptrdiff_t</span>
<span class="token comment">//是一个无符号的整数类型</span>
<span class="token comment">//sizeof运算符返回的类型</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> xxx <span class="token class-name">size_t</span>

<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token class-name">wchar_t</span>
</code></pre> 
<h3><a id="ltstdboolh_1022"></a>&lt;stdbool.h&gt;</h3> 
<p>&lt;stdbool.h&gt;头文件提供了布尔相关的宏：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">bool</span>	<span class="token expression"><span class="token keyword">_Bool</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">false</span>	<span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">true</span>	<span class="token expression"><span class="token number">1</span></span></span>
</code></pre> 
<h3><a id="ltctypeh_1029"></a>&lt;ctype.h&gt;</h3> 
<p><code>&lt;ctype.h&gt;</code>头文件提供了字符分类函数和字符大小写映射函数，这些函数都接收一个<code>int</code>类型的参数，将一个<code>char</code>类型的实数传入时会进行类型的隐式转换，由于<code>char</code>类型的有无符号性有具体的实现决定，因此这个隐式转换的结果也是不确定的，所以在使用前应该先将实参转换为<code>unsigned char</code>类型。</p> 
<pre><code class="prism language-c"><span class="token comment">//是否是字母或数字</span>
<span class="token keyword">int</span> <span class="token function">isalnum</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//是否是字母</span>
<span class="token keyword">int</span> <span class="token function">isalpha</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//是否是十进制数字</span>
<span class="token keyword">int</span> <span class="token function">isdigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//是否是十六进制数字</span>
<span class="token keyword">int</span> <span class="token function">isxdigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//是否是小写字母</span>
<span class="token keyword">int</span> <span class="token function">islower</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//是否是大写字母</span>
<span class="token keyword">int</span> <span class="token function">isupper</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//是否是空白字符</span>
<span class="token keyword">int</span> <span class="token function">isspace</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//转换为大写字母</span>
<span class="token keyword">int</span> <span class="token function">tolower</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//转换为小写字符</span>
<span class="token keyword">int</span> <span class="token function">toupper</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="ltstdlibh_1051"></a>&lt;stdlib.h&gt;</h3> 
<p><code>&lt;stdlib.h&gt;</code>头文件提供了一些通用的实用工具。</p> 
<h4><a id="_1053"></a>数值转换</h4> 
<p>数值转换函数用于将含有数值的字符串转换为整数形式。每个函数都会跳过字符串开始处的空白字符，在遇到第一个不属于数的字符处停止。如果不能转换那么函数返回零。</p> 
<pre><code class="prism language-c"><span class="token keyword">double</span> <span class="token function">atof</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>nptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">atoi</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>nptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">atol</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>nptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">atoll</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>nptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">double</span> <span class="token function">strtod</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict nptr<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span> restrict endptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> <span class="token function">strtof</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict nptr<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span> restrict endptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> <span class="token keyword">double</span> <span class="token function">strtold</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict nptr<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span> restrict endptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">strtol</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict nptr<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span> restrict endptr<span class="token punctuation">,</span><span class="token keyword">int</span> base<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">strtoll</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict nptr<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span> restrict endptr<span class="token punctuation">,</span><span class="token keyword">int</span> base<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">strtoul</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict nptr<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span> restrict endptr<span class="token punctuation">,</span><span class="token keyword">int</span> base<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">strtoull</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict nptr<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span> restrict endptr<span class="token punctuation">,</span><span class="token keyword">int</span> base<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_1072"></a>伪随机数生成</h4> 
<p>这两个函数都可以返回一个<code>0</code>到<code>RAND_MAX</code>的伪随机数。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">srand</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> seed<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_1078"></a>与环境通信</h4> 
<pre><code class="prism language-c"><span class="token comment">//注册一个在程序结束时调用的钩子函数</span>
<span class="token keyword">int</span> <span class="token function">atexit</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//程序异常结束，不会调用钩子函数</span>
<span class="token keyword">void</span> <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//程序正常结束并返回一个状态码</span>
<span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//程序正常结束并返回一个状态码，但不会调用钩子函数</span>
<span class="token keyword">void</span> <span class="token function">_Exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//获取用户环境中的字符串</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">getenv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//运行另一个程序，返回被运行程序结束时的状态码</span>
<span class="token keyword">int</span> <span class="token function">system</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_1093"></a>搜索和排序</h4> 
<p><code>bsearch</code>函数用于数组内搜索元素，<code>qsort</code>函数用于排序数组。</p> 
<pre><code class="prism language-c"><span class="token comment">//key ：指向要搜索的元素</span>
<span class="token comment">//base：指向数组</span>
<span class="token comment">//nmemb：数组元素的个数</span>
<span class="token comment">//size：数组元素的大小</span>
<span class="token comment">//compar：比较函数</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">bsearch</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> base<span class="token punctuation">,</span><span class="token class-name">size_t</span> nmemb<span class="token punctuation">,</span><span class="token class-name">size_t</span> size<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>compar<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">qsort</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>base<span class="token punctuation">,</span><span class="token class-name">size_t</span> nmemb<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>compar<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bb13022302bdb2af9803850629776e71/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SSD算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/98b64b65a1dc6140c9cb054a165db5d5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[已解决]使用Pytorch的DataSet、DataLoad时报错：stack expects each tensor to be equal size..。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>