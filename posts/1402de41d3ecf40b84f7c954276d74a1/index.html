<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Zookeeper- 总结 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Zookeeper- 总结" />
<meta property="og:description" content="Zookeeper- 总结 如想了解更多更全面的Java必备内容可以阅读：所有JAVA必备知识点面试题文章目录：
JAVA必备知识点面试题 文章目录 Zookeeper- 总结1、Http和RPC的区别？2、Google的GFS(google file system)集群中是怎么进行master选举的？3、说说zookeeper是什么？4、Zookeeper提供了哪些常用的功能？5、什么是leader选举和原子广播？6、说说你对Zookeeper节点和节点状态信息的理解？7、说说Zookeeper中Watcher作用？8、Zookeeper是如何实现服务的注册与发现？9、Zookeeper中watcher机制的特性是什么？10、Zookeeper原生提供了哪些监听事件？11、Curator提供了几种Watcher来监听节点的变化？12、Zookeeper分布式锁的实现原理？13、curator提供了哪些常用的Zookeeper分布式锁的封装?14、leader节点和各个follower节点如何保证数据一致性？15、各个follower在收到COMMIT命令前leader就挂了，导致数据不一致情况，Zookeeper是怎么处理的？16、Zookeeper是如何保证事务的顺序一致性的？17、什么情况下会进行leader选举？18、Zookeeper下Server 工作状态？19、Zookeeper服务器角色有哪些？20、服务器启动时的leader选举实现原理？21、运行过程中leader节点宕机，整个集群无法处理写请求，如何快速从其他节点里面选举出新的leader呢？22、什么是ACL权限控制机制？23、Chroot特性是什么?24、zookeeper负载均衡和nginx负载均衡区别？25、集群最少要几台机器，集群规则是怎样的?26、集群支持动态添加机器吗？27、chubby是什么？28、ZAB和Paxos算法的联系与区别？29、Zookeeper的典型应用场景？ 1、Http和RPC的区别？ RPC(Remote Produce Call 远程过程调用)：自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型。
Http：网络传输协议：基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。
相同点：底层通讯都是基于socket，都可以实现远程调用，都可以实现服务调用服务
不同点：
RPC：当使用RPC框架实现服务间调用的时候，要求服务提供方和服务消费方 都必须使用统一的RPC框架，要么都dubbo，要么都cxf
跨操作系统在同一编程语言内使用
优势：调用快、处理快
应用：dubbo、cxf、（RMI远程方法调用）Hessianhttp：当使用http进行服务间调用的时候，无需关注服务提供方使用的编程语言，也无需关注服务消费方使用的编程语言，服务提供方只需要提供restful风格的接口，服务消费方按照restful的原则请求服务即可。
跨系统跨编程语言的远程调用框架
优势：通用性强
应用：httpClient 2、Google的GFS(google file system)集群中是怎么进行master选举的？ 在Google有一个文件系统GFS(google file system)，需要从多个gfs server中选出一个master server。
GFS就是使用Google Chubby来解决这个问题的。【Google Chubby 不开源】
所有的server通过Paxos协议到Chubby server上的一个节点上创建同一个文件，当然，最终只有一个server能够成功创建这个文件，这个server就成为了master，它会在这个文件中写入自己的地址，这样其它的server通过读取这个文件就能知道被选出的master的地址。
3、说说zookeeper是什么？ ZooKeeper：是一个高可靠的分布式协调中间件。它是Google Chubby的一个开源实现。
ZooKeeper分为服务器端（Server）和客户端（Client）客户端，客户端可以连接到整个ZooKeeper的任意服务器上（除非参数zookeeper.leaderServes=no，leader不允许接受客户端连接）
客户端使用并维护一个TCP连接，通过这个连接发送请求、接受响应、获取观察的事件以及发送心跳。如果这个TCP连接中断，客户端将自动尝试连接到另外的ZooKeeper服务器。
ZooKeeper服务端启动时，将从实例中选举一个leader，Leader负责处理事务请求、数据同步等操作，一个更新操作成功的标志是当且仅当超过半数以上Server在内存中成功修改数据。
Zookeeper集群间通过Zab协议（Zookeeper Atomic Broadcast）来保持数据的一致性。Zab协议包含两个阶段：leader选举/崩溃恢复(leader election)阶段 和 原子广播(Atomic Brodcast)阶段。
4、Zookeeper提供了哪些常用的功能？ Watcher监听心跳监测主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程。分布式锁：提供两种锁：独占锁、共享锁。命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。ACL对节点权限控制 5、什么是leader选举和原子广播？ 集群启动，在集群中将选举出一个leader，其他的机器则称为follower，所有的写操作都被传送给leader，并通过广播将所有的更新告诉给follower。当leader崩溃或者leader失去大多数的follower时，需要重新选举出一个新的leader，让所有的服务器都恢复到高可用状态。当leader被选举出来，且大多数服务器完成了和leader的状态同步后，leader选举的过程就结束了，就将会进入到原子广播的过程。原子广播是同步leader和follower之间的信息，保证数据在集群中各个节点的一致性。 6、说说你对Zookeeper节点和节点状态信息的理解？ Zookeeper每一个节点称之为ZNode，是Zookeeper的最小单元。每个ZNode上都可以保存数据以及挂载子节点。构成一个层次化的树形结构。
ZNode节点类型：
#### zookeeper-3.5.3 CreateMode类源码如下： public enum CreateMode { //【持久化节点】：创建后会一直存在 zookeeper 服务器上，直到主动删除 PERSISTENT (0, false, false, false, false), //【持久化有序节点】：每个节点都会为它的一级子节点维护一个顺序 PERSISTENT_SEQUENTIAL (2, false, true, false, false), //【短暂的临时节点】：临时节点的生命周期和客户端的会话绑定在一起，当客户端会话失效该节点自动清理 EPHEMERAL (1, true, false, false, false), //【短暂的临时有序节点】：在临时节点的基础上多了一个顺序性 EPHEMERAL_SEQUENTIAL (3, true, true, false, false), //容器节点：是特殊用途的节点，用于leader、lock等方法。当容器的最后一个子元素被删除时，该容器将成为将来某个时候服务器删除的候选对象。 CONTAINER (4, false, false, true, false), //客户端断开连接后不会自动删除Znode，如果该Znode没有子节点且在给定TTL时间内无修改，该Znode将会被删除；TTL单位是毫秒，必须大于0且小于或等于EphemeralType." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/1402de41d3ecf40b84f7c954276d74a1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-05T23:53:07+08:00" />
<meta property="article:modified_time" content="2021-05-05T23:53:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Zookeeper- 总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Zookeeper__0"></a>Zookeeper- 总结</h3> 
<hr> 
<p>如想了解更多更全面的Java必备内容可以阅读：<strong>所有JAVA必备知识点面试题文章目录：</strong></p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> <a href="https://blog.csdn.net/shishishilove/article/details/107451998">JAVA必备知识点面试题</a></li></ul> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#Zookeeper__0" rel="nofollow">Zookeeper- 总结</a></li><li><ul><li><ul><li><a href="#1HttpRPC_10" rel="nofollow">1、Http和RPC的区别？</a></li><li><a href="#2GoogleGFSgoogle_file_systemmaster_25" rel="nofollow">2、Google的GFS(google file system)集群中是怎么进行master选举的？</a></li><li><a href="#3zookeeper_32" rel="nofollow">3、说说zookeeper是什么？</a></li><li><a href="#4Zookeeper_43" rel="nofollow">4、Zookeeper提供了哪些常用的功能？</a></li><li><a href="#5leader_51" rel="nofollow">5、什么是leader选举和原子广播？</a></li><li><a href="#6Zookeeper_57" rel="nofollow">6、说说你对Zookeeper节点和节点状态信息的理解？</a></li><li><a href="#7ZookeeperWatcher_109" rel="nofollow">7、说说Zookeeper中Watcher作用？</a></li><li><a href="#8Zookeeper_118" rel="nofollow">8、Zookeeper是如何实现服务的注册与发现？</a></li><li><a href="#9Zookeeperwatcher_132" rel="nofollow">9、Zookeeper中watcher机制的特性是什么？</a></li><li><a href="#10Zookeeper_136" rel="nofollow">10、Zookeeper原生提供了哪些监听事件？</a></li><li><a href="#11CuratorWatcher_146" rel="nofollow">11、Curator提供了几种Watcher来监听节点的变化？</a></li><li><a href="#12Zookeeper_169" rel="nofollow">12、Zookeeper分布式锁的实现原理？</a></li><li><a href="#13curatorZookeeper_182" rel="nofollow">13、curator提供了哪些常用的Zookeeper分布式锁的封装?</a></li><li><a href="#14leaderfollower_209" rel="nofollow">14、leader节点和各个follower节点如何保证数据一致性？</a></li><li><a href="#15followerCOMMITleaderZookeeper_225" rel="nofollow">15、各个follower在收到COMMIT命令前leader就挂了，导致数据不一致情况，Zookeeper是怎么处理的？</a></li><li><a href="#16Zookeeper_229" rel="nofollow">16、Zookeeper是如何保证事务的顺序一致性的？</a></li><li><a href="#17leader_238" rel="nofollow">17、什么情况下会进行leader选举？</a></li><li><a href="#18ZookeeperServer__241" rel="nofollow">18、Zookeeper下Server 工作状态？</a></li><li><a href="#19Zookeeper_248" rel="nofollow">19、Zookeeper服务器角色有哪些？</a></li><li><a href="#20leader_263" rel="nofollow">20、服务器启动时的leader选举实现原理？</a></li><li><a href="#21leaderleader_282" rel="nofollow">21、运行过程中leader节点宕机，整个集群无法处理写请求，如何快速从其他节点里面选举出新的leader呢？</a></li><li><a href="#22ACL_291" rel="nofollow">22、什么是ACL权限控制机制？</a></li><li><a href="#23Chroot_315" rel="nofollow">23、Chroot特性是什么?</a></li><li><a href="#24zookeepernginx_318" rel="nofollow">24、zookeeper负载均衡和nginx负载均衡区别？</a></li><li><a href="#25_321" rel="nofollow">25、集群最少要几台机器，集群规则是怎样的?</a></li><li><a href="#26_324" rel="nofollow">26、集群支持动态添加机器吗？</a></li><li><a href="#27chubby_329" rel="nofollow">27、chubby是什么？</a></li><li><a href="#28ZABPaxos_333" rel="nofollow">28、ZAB和Paxos算法的联系与区别？</a></li><li><a href="#29Zookeeper_341" rel="nofollow">29、Zookeeper的典型应用场景？</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h5><a id="1HttpRPC_10"></a>1、Http和RPC的区别？</h5> 
<p><strong>RPC(Remote Produce Call 远程过程调用)</strong>：自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型。<br> <strong>Http：网络传输协议</strong>：基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。</p> 
<p><strong>相同点</strong>：底层通讯都是基于socket，都可以实现远程调用，都可以实现服务调用服务<br> <strong>不同点</strong>：</p> 
<ul><li>RPC：当使用RPC框架实现服务间调用的时候，要求服务提供方和服务消费方 都必须使用统一的RPC框架，要么都dubbo，要么都cxf<br> 跨操作系统在同一编程语言内使用<br> 优势：调用快、处理快<br> 应用：dubbo、cxf、（RMI远程方法调用）Hessian</li><li>http：当使用http进行服务间调用的时候，无需关注服务提供方使用的编程语言，也无需关注服务消费方使用的编程语言，服务提供方只需要提供restful风格的接口，服务消费方按照restful的原则请求服务即可。<br> 跨系统跨编程语言的远程调用框架<br> 优势：通用性强<br> 应用：httpClient</li></ul> 
<h5><a id="2GoogleGFSgoogle_file_systemmaster_25"></a>2、Google的GFS(google file system)集群中是怎么进行master选举的？</h5> 
<p>在Google有一个文件系统GFS(google file system)，需要从多个gfs server中选出一个master server。</p> 
<p>GFS就是使用Google Chubby来解决这个问题的。<strong>【Google Chubby 不开源】</strong></p> 
<p>所有的server通过Paxos协议到Chubby server上的一个节点上创建同一个文件，当然，最终只有一个server能够成功创建这个文件，这个server就成为了master，它会在这个文件中写入自己的地址，这样其它的server通过读取这个文件就能知道被选出的master的地址。</p> 
<h5><a id="3zookeeper_32"></a>3、说说zookeeper是什么？</h5> 
<p><strong>ZooKeeper</strong>：是一个高可靠的分布式协调中间件。它是Google Chubby的一个开源实现。</p> 
<p>ZooKeeper分为服务器端（Server）和客户端（Client）客户端，客户端可以连接到整个ZooKeeper的任意服务器上（除非参数zookeeper.leaderServes=no，leader不允许接受客户端连接）</p> 
<p>客户端使用并维护一个TCP连接，通过这个连接发送请求、接受响应、获取观察的事件以及发送心跳。如果这个TCP连接中断，客户端将自动尝试连接到另外的ZooKeeper服务器。</p> 
<p>ZooKeeper服务端启动时，将从实例中选举一个leader，Leader负责处理事务请求、数据同步等操作，一个更新操作成功的标志是当且仅当超过半数以上Server在内存中成功修改数据。</p> 
<p>Zookeeper集群间通过Zab协议（Zookeeper Atomic Broadcast）来保持数据的一致性。Zab协议包含两个阶段：leader选举/崩溃恢复(leader election)阶段 和 原子广播(Atomic Brodcast)阶段。</p> 
<h5><a id="4Zookeeper_43"></a>4、Zookeeper提供了哪些常用的功能？</h5> 
<ul><li><strong>Watcher监听</strong></li><li><strong>心跳监测</strong></li><li><strong>主节点选举</strong>：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程。</li><li><strong>分布式锁</strong>：提供两种锁：独占锁、共享锁。</li><li><strong>命名服务</strong>：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</li><li><strong>ACL对节点权限控制</strong></li></ul> 
<h5><a id="5leader_51"></a>5、什么是leader选举和原子广播？</h5> 
<ol><li>集群启动，在集群中将选举出一个leader，其他的机器则称为follower，所有的写操作都被传送给leader，并通过广播将所有的更新告诉给follower。</li><li>当leader崩溃或者leader失去大多数的follower时，需要重新选举出一个新的leader，让所有的服务器都恢复到高可用状态。</li><li>当leader被选举出来，且大多数服务器完成了和leader的状态同步后，leader选举的过程就结束了，就将会进入到原子广播的过程。</li><li>原子广播是同步leader和follower之间的信息，保证数据在集群中各个节点的一致性。</li></ol> 
<h5><a id="6Zookeeper_57"></a>6、说说你对Zookeeper节点和节点状态信息的理解？</h5> 
<p>Zookeeper每一个节点称之为<strong>ZNode</strong>，<strong>是Zookeeper的最小单元</strong>。每个ZNode上都可以<strong>保存数据</strong>以及<strong>挂载子节点</strong>。构成一个层次化的树形结构。<br> ZNode节点类型：</p> 
<pre><code class="prism language-javascript">#### zookeeper<span class="token operator">-</span><span class="token number">3.5</span><span class="token number">.3</span>  CreateMode类源码如下：
<span class="token keyword">public</span> <span class="token keyword">enum</span> CreateMode <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//【持久化节点】：创建后会一直存在 zookeeper 服务器上，直到主动删除</span>
    <span class="token constant">PERSISTENT</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	
    <span class="token comment">//【持久化有序节点】：每个节点都会为它的一级子节点维护一个顺序</span>
    <span class="token constant">PERSISTENT_SEQUENTIAL</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	
    <span class="token comment">//【短暂的临时节点】：临时节点的生命周期和客户端的会话绑定在一起，当客户端会话失效该节点自动清理</span>
    <span class="token constant">EPHEMERAL</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	
    <span class="token comment">//【短暂的临时有序节点】：在临时节点的基础上多了一个顺序性</span>
    <span class="token constant">EPHEMERAL_SEQUENTIAL</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	
    <span class="token comment">//容器节点：是特殊用途的节点，用于leader、lock等方法。当容器的最后一个子元素被删除时，该容器将成为将来某个时候服务器删除的候选对象。</span>
    <span class="token constant">CONTAINER</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	
    <span class="token comment">//客户端断开连接后不会自动删除Znode，如果该Znode没有子节点且在给定TTL时间内无修改，该Znode将会被删除；TTL单位是毫秒，必须大于0且小于或等于EphemeralType.MAX_TTL。</span>
    <span class="token constant">PERSISTENT_WITH_TTL</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	
    <span class="token comment">//有序的PERSISTENT_WITH_TTL</span>
    <span class="token constant">PERSISTENT_SEQUENTIAL_WITH_TTL</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	···
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>「注意」有序性</strong>：创建ZNode时设置顺序标识，ZNode名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护。</p> 
<p>每个ZNode节点除了存储数据内容以外，还存储了数据节点本身的一些状态信息，通过get 命令可以获得状态信息的详细内容。</p> 
<pre><code class="prism language-javascript">#### zookeeper<span class="token operator">-</span><span class="token number">3.5</span><span class="token number">.3</span>  Stat类源码如下：
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Stat</span> <span class="token keyword">implements</span> <span class="token class-name">Record</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">private</span> long czxid<span class="token punctuation">;</span><span class="token comment">//即Created ZXID，表示该数据节点被创建时的事务ID</span>
  <span class="token keyword">private</span> long mzxid<span class="token punctuation">;</span><span class="token comment">//即Modified ZXID，表示该节点最后一次被更新时的事务ID</span>
  <span class="token keyword">private</span> long ctime<span class="token punctuation">;</span><span class="token comment">//即Created Time，表示节点被创建的时间</span>
  <span class="token keyword">private</span> long mtime<span class="token punctuation">;</span><span class="token comment">//即Modified Time，表示该节点最后一次被更新的时间</span>
  <span class="token keyword">private</span> int version<span class="token punctuation">;</span><span class="token comment">//当前节点被改动的次数(数据节点的版本号)</span>
  <span class="token keyword">private</span> int cversion<span class="token punctuation">;</span><span class="token comment">//当前节点的子节点改动的次数(数据节点的版本号)</span>
  <span class="token keyword">private</span> int aversion<span class="token punctuation">;</span><span class="token comment">//当前节点的ACL改动次数(数据节点的版本号)</span>
  <span class="token keyword">private</span> long ephemeralOwner<span class="token punctuation">;</span><span class="token comment">//创建该临时节点的会话的sessionID。如果该节点是持久节点，那么这个属性值为0</span>
  <span class="token keyword">private</span> int dataLength<span class="token punctuation">;</span><span class="token comment">//当前节点的数据长度</span>
  <span class="token keyword">private</span> int numChildren<span class="token punctuation">;</span><span class="token comment">//当前节点子节点的个数</span>
  <span class="token keyword">private</span> long pzxid<span class="token punctuation">;</span><span class="token comment">//表示该节点的子节点列表最后一次被修改时的事务ID。注意，只有子节点列表变更了才会变更pzxid，子节点内容变更不会影响pzxid</span>
  
  ···
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="7ZookeeperWatcher_109"></a>7、说说Zookeeper中Watcher作用？</h5> 
<p><strong>watch机制</strong>：客户端会对某个节点注册一个watcher事件，当该节点发生变化时，这些客户端会收到注册中心的通知，然后客户端可以根据节点变化来做出业务上的改变等。</p> 
<p><strong>watcher</strong>：是zooKeeper中一个非常核心功能 ，客户端watcher可以监控节点的数据变化以及它子节点的变化，一旦这些状态发生变化，zooKeeper服务端就会通知所有在这个节点上设置过watcher的客户端 ，从而每个客户端都很快感知。</p> 
<p><strong>应用场景</strong>：可以做 <strong>注册中心</strong> 和 <strong>配置中心</strong> 以及 <strong>分布式锁</strong> 动态感知变化随之做响应的逻辑处理。</p> 
<h5><a id="8Zookeeper_118"></a>8、Zookeeper是如何实现服务的注册与发现？</h5> 
<p>Zookeeper的服务注册与发现：主要应用的是Zookeeper的ZNode节点数据模型和watcher机制，大致的流程如下:</p> 
<ul><li> <p><strong>服务提供者（Provider）</strong>：启动时，会向服务注册中心(Zookeeper)注册服务信息，也就是创建一个节点。</p> </li><li> <p><strong>服务消费者（Consumer）</strong>：启动时，根据自身配置的依赖服务信息，向服务注册中心(Zookeeper)获取注册的服务信息并设置watch监听，获取到注册的服务信息之后，将服务提供者的信息缓存在本地。根据本地缓存中的服务注册信息构建服务调用请求，并根据负载均衡策略（随机负载均衡，Round－Robin负载均衡等）来转发请求。</p> <p>当收到服务注册中心(Zookeeper)通知服务有更新时（<strong>通知只会收到一次</strong>，如果想继续监听可以通过循环注册来实现），会在本地缓存中更新服务信息。</p> </li><li> <p><strong>服务注册中心(Zookeeper)</strong>：主要提供所有服务注册信息存储；</p> <p>通过心跳去监测服务服务提供者提供的服务信息是否有更新；</p> <p>如果服务信息有更新，同时负责将更新信息实时通知给这个服务设置过watch监听的服务消费者。<br> <img src="https://images2.imgbox.com/ca/fe/XuA80Rd7_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h5><a id="9Zookeeperwatcher_132"></a>9、Zookeeper中watcher机制的特性是什么？</h5> 
<p><strong>【一次性】</strong> 当数据发生改变的时候，那么zookeeper会产生一个watch事件并发送到客户端，但是客户端只会收到一次这样的通知，如果以后这个数据再发生变化，那么之前设置watch的客户端不会再次收到消息。因为他是一次性的；如果要实现永久监听，可以通过循环注册来实现。</p> 
<h5><a id="10Zookeeper_136"></a>10、Zookeeper原生提供了哪些监听事件？</h5> 
<table><thead><tr><th align="left">zookeeper事件</th><th align="left">事件含义</th></tr></thead><tbody><tr><td align="left">EventType.NodeCreated</td><td align="left">当 node-x 这个节点被创建时，该事件被触发。</td></tr><tr><td align="left">EventType.NodeDeleted</td><td align="left">当 node-x 这个节点被删除时，该事件被触发。</td></tr><tr><td align="left">EventType.NodeDataChanged</td><td align="left">当 node-x 这个节点的数据发生变更时，该事件被触发。</td></tr><tr><td align="left">EventType.NodeChildrenChanged</td><td align="left">当 node-x 这个节点的直接子节点被创建、被删除、子节点数据发生变更时，该事件被触发。</td></tr><tr><td align="left">EventType.None</td><td align="left">当 zookeeper 客户端的连接状态发生变更时，即 KeeperState.Expired、KeeperState.Disconnected、KeeperState.SyncConnected、KeeperState.AuthFailed 状态切换时，描述的事件类型为 EventType.None。</td></tr></tbody></table> 
<h5><a id="11CuratorWatcher_146"></a>11、Curator提供了几种Watcher来监听节点的变化？</h5> 
<p><strong>Curator</strong>：是Netflix公司开源的一套zookeeper客户端框架，解决了很多Zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册Watcher、NodeExistsException异常等等。</p> 
<pre><code class="prism language-javascript">####对zookeeper的底层api的一些封装
<span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>curator<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>curator<span class="token operator">-</span>framework<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>version<span class="token operator">&gt;</span><span class="token number">4.0</span><span class="token number">.0</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>

####封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式Barrier
<span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>curator<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>curator<span class="token operator">-</span>recipes<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>version<span class="token operator">&gt;</span><span class="token number">4.0</span><span class="token number">.0</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>dependencies<span class="token operator">&gt;</span>
</code></pre> 
<ul><li><strong>NodeCache</strong>：监视当前结点的创建、更新、删除，并将结点的数据缓存在本地。</li><li><strong>PathChildCache</strong>：监视一个路径下子结点的创建、删除、更新。</li><li><strong>TreeCache</strong>：PathChildCache 和 NodeCache 的“合体”，监视路径下的创建、更新、删除事件，并缓存路径下所有孩子结点的数据。</li></ul> 
<h5><a id="12Zookeeper_169"></a>12、Zookeeper分布式锁的实现原理？</h5> 
<ul><li> <p>【方式一】：<strong>利用Zookeeper节点的特性(同级节点的唯一性)来实现独占锁</strong><br> <strong>原理</strong>：多个进程往Zookeeper的指定节点下创建一个相同名称的节点，只有一个能成功（抢到锁），其他的都创建失败（未抢到锁）；创建失败的节点全部通过Zookeeper的watcher机制，监听Zookeeper这个子节点的变化，一旦监听到子节点的删除事件，则再次触发所有进程去创建一个相同名称的节点，从而或者锁，不断重复这个过程。</p> <p><strong>弊端</strong>：会产生“惊群效应”，简单来说，就是如果存在许多的客户端在等待获取锁，当成功获取到锁的进程释放该节点后，所有处于等待状态的客户端都会被唤醒，这个时候zookeeper在短时间内发送大量子节点变更事件给所有待获取锁的客户端，然后实际情况是只会有一个客户端获得锁。如果在集群规模比较大的情况下，会对 zookeeper 服务器的性能产生比较的影响。<br> <img src="https://images2.imgbox.com/a6/19/6Ko76AK4_o.png" alt="在这里插入图片描述"></p> </li><li> <p>【方式二】：<strong>利用临时有序节点来实现分布式锁</strong><br> <strong>原理</strong>：每个客户端都往指定的节点下，注册一个临时有序节点，越早创建的节点，节点的顺序编号就越小，那么我们可以判断子节点中最小的节点设置为获得锁。<br> 如果自己的节点不是所有子节点中最小的，意味着还没有获得锁。每个节点只需要监听比自己小的节点，当比自己小的节点删除以后，客户端会收到watcher事件，此时再次判断自己的节点是不是所有子节点中最小的，如果是则获得锁，否则就不断重复这个过程，这样就不会导致惊群效应。<br> <img src="https://images2.imgbox.com/dc/7d/FTiriLry_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h5><a id="13curatorZookeeper_182"></a>13、curator提供了哪些常用的Zookeeper分布式锁的封装?</h5> 
<p>提供了三个常用的分布式锁的实现，都实现了InterProcessLock接口。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InterProcessLock</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//获取锁</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> throws Exception<span class="token punctuation">;</span>
    <span class="token comment">//获取锁</span>
    <span class="token keyword">public</span> boolean <span class="token function">acquire</span><span class="token punctuation">(</span>long time<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> throws Exception<span class="token punctuation">;</span>
    <span class="token comment">//释放锁</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> throws Exception<span class="token punctuation">;</span>
    <span class="token comment">//是否在在这个过程中获得的锁</span>
    boolean <span class="token function">isAcquiredInThisProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li> <p><strong>InterProcessMutex</strong>：分布式可重入排它锁,利用构造方法传入锁节点path，在path下创建临时顺序节点实现。通过ConcurrentMap&lt;Thread, LockData&gt;记录线程与锁信息的映射关系。</p> <p>Zookeeper中一个临时顺序节点对应一个“锁”，但让锁生效激活需要排队（公平锁），激活条件：同级目录子节点，名称排序最小（排队，公平锁）。</p> <p>每个节点会监听上一个节点，如果上一个节点释放锁，会唤醒当前线程继续竞争锁，正常情况下能直接获得锁，因为锁是公平的。</p> </li><li> <p><strong>InterProcessSemaphoreMutex</strong>：分布式排它锁</p> </li><li> <p><strong>InterProcessReadWriteLock</strong>：分布式读写锁</p> </li></ul> 
<h5><a id="14leaderfollower_209"></a>14、leader节点和各个follower节点如何保证数据一致性？</h5> 
<p><strong>注意</strong>：leader 节点可以处理事务请求和非事务请求，follower 节点只能处理非事务请求，如果 follower 节点接收到非事务请求，会把这个请求转发给 Leader 服务器。</p> 
<p>在ZooKeeper中，主要依赖<strong>ZAB协议来实现分布式数据一致性</strong>，基于该协议，ZooKeeper实现了一种广播机制来保持集群中各个副本之间的数据一致性。</p> 
<p><strong>ZAB 协议的消息广播机制是简化版本的2PC协议，这种协议只需要集群中过半的节点响应提交即可</strong>。</p> 
<p>说明：消息广播机制和完整的2pc事务不一样的地方在于，zab协议不能终止事务，follower节点要么ACK给leader，要么抛弃leader，只需要保证过半数的节点响应这个消息并提交了即可，虽然在某一个时刻follower节点和leader节点的状态会不一致，但是也是这个特性提升了集群的整体性能。当然这种数据不一致的问题，zab协议提供了一种恢复模式来进行数据恢复。</p> 
<p><strong>原子广播的实现数据一致性原理</strong>：</p> 
<ol><li>leader接收到消息请求后，将消息赋予一个全局唯一的64位自增id，叫：zxid，通过zxid的大小比较既可以实现。</li><li>leader为每个follower准备了一个FIFO队列（通过TCP协议来实现，以实现了全局有序这一个特点），将带有zxid的消息作为一个提案（proposal）分发给所有的follower。</li><li>当follower接收到proposal，先把proposal写到磁盘，写入成功以后再向leader回复一个 ack。</li><li>当leader接收到合法数量（超过半数节点）的ACK后，leader就会向这些follower发送commit命令，同时会在本地执行该消息。</li><li>当follower收到消息的commit命令以后，会提交该消息。<br> <img src="https://images2.imgbox.com/c8/9c/vpWeWS62_o.png" alt="在这里插入图片描述"></li></ol> 
<h5><a id="15followerCOMMITleaderZookeeper_225"></a>15、各个follower在收到COMMIT命令前leader就挂了，导致数据不一致情况，Zookeeper是怎么处理的？</h5> 
<p>进入崩溃恢复/leader选举模式，选举新的leader。<br> 在旧的leader挂前，已经发出COMMIT命令的事务能够正确提交，还没来得及发出COMMIT命令的事务丢弃/删除。</p> 
<h5><a id="16Zookeeper_229"></a>16、Zookeeper是如何保证事务的顺序一致性的？</h5> 
<p><strong>zxid（事务id）</strong>：为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。</p> 
<p><strong>zxid是64位数字</strong>，</p> 
<ul><li><strong>高32位是epoch编号</strong>，每经过一次Leader选举产生一个新的leader，新的leader会将epoch号+1;</li><li><strong>低32位是消息计数器</strong>，每接收到一条消息这个值+1，新leader选举后这个值重置为0。</li></ul> 
<p>epoch：可以理解为当前集群所处的年代或者周期，每个leader就像皇帝，都有自己的年号，所以每次改朝换代，leader变更之后，都会在前一个年代的基础上加1。这样就算旧的leader崩溃恢复之后，也没有人听他的了，因为follower只听从当前年代的leader的命令。</p> 
<h5><a id="17leader_238"></a>17、什么情况下会进行leader选举？</h5> 
<ul><li><strong>服务器启动时</strong>；<strong>运行过程中leader节点宕机</strong>。</li></ul> 
<h5><a id="18ZookeeperServer__241"></a>18、Zookeeper下Server 工作状态？</h5> 
<p>服务器具有四种状态，分别是 LOOKING、FOLLOWING、LEADING、OBSERVING。</p> 
<ul><li><strong>LOOKING</strong>：寻找Leader状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入Leader选举状态。</li><li><strong>FOLLOWING</strong>：跟随者状态。表明当前服务器角色是Follower。</li><li><strong>LEADING</strong>：领导者状态。表明当前服务器角色是Leader。</li><li><strong>OBSERVING</strong>：观察者状态。表明当前服务器角色是Observer。</li></ul> 
<h5><a id="19Zookeeper_248"></a>19、Zookeeper服务器角色有哪些？</h5> 
<p><strong>Leader</strong></p> 
<ol><li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性</li><li>集群内部各服务的调度者</li></ol> 
<p><strong>Follower</strong></p> 
<ol><li>处理客户端的非事务请求，转发事务请求给Leader服务器</li><li>参与事务请求Proposal的投票</li><li>参与Leader选举投票</li></ol> 
<p><strong>Observer</strong></p> 
<ol><li>3.0版本以后，引入的一个服务器角色，在不影响集群事务处理能力的基础上提升集群的非事务处理能力</li><li>处理客户端的非事务请求，转发事务请求给Leader服务器</li><li>不参与任何形式的投票</li></ol> 
<h5><a id="20leader_263"></a>20、服务器启动时的leader选举实现原理？</h5> 
<p>每个节点启动的时候状态都是 LOOKING，处于观望状态，接下来就开始进行选主流程</p> 
<p>【若进行 Leader 选举，则至少需要两台机器，一般设置集群个数为单数】</p> 
<p>假设有三台服务器Server1、Server2、Server3。<br> 在集群初始化阶段，当有一台服务器Server1启动时，其单独无法进行和完成Leader选举，当第二台服务器Server2启动时，此时两台机器可以相互通信，每台机器都试图找到Leader，于是进入Leader选举过程。过程如下：</p> 
<ol><li> <p>每个Server发出一个投票。由于是初始情况，Server1和Server2都会将自己作为Leader服务器来进行投票，每次投票会包含所推举的服务器的myid和ZXID、epoch，使用(myid,ZXID,epoch)来表示，此时Server1的投票为(1,0)，Server2的投票为(2,0)，然后各自将这个投票发给集群中其他机器。</p> </li><li> <p>接受来自各个服务器的投票。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票（epoch）、是否来自LOOKING状态的服务器。</p> </li><li> <p>处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投<br> 票进行PK，PK规则如下</p> 
  <ol><li>优先比较epoch</li><li>其次检查ZXID。ZXID比较大的服务器优先作为Leader</li><li>如果ZXID相同，那么就比较myid。myid较大的服务器作为Leader服务器。</li></ol> <p>对于Server1而言，它的投票是(1,0)，接收Server2的投票为(2,0)，首先会比较两者的ZXID，均为0，再比较myid，此时Server2的myid最大，于是更新自己的投票为(2,0)，然后重新投票，对于Server2而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可。</p> </li><li> <p>统计投票。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于Server1、Server2而言，都统计出集群中已经有两台机器接受了(2,0)的投票信息，此时便认为已经选出了Leader。</p> </li><li> <p>改变服务器状态。一旦确定了Leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为FOLLOWING，如果是Leader，就变更为LEADING。</p> </li></ol> 
<h5><a id="21leaderleader_282"></a>21、运行过程中leader节点宕机，整个集群无法处理写请求，如何快速从其他节点里面选举出新的leader呢？</h5> 
<p>当leader失去与过半follower节点联系，可能是leader节点和follower节点之间产生了网络分区等等原因，那么此时的leader不再是合法的leader了，接着就会进入到崩溃恢复/leader选举模式：<br> 崩溃恢复状态下zab协议需要做两件事：</p> 
<ol><li>选举出新的leader：<br> 变更状态。Leader挂后，余下的非Observer服务器都会将自己的服务器状态变更为LOOKING，然后开始进入Leader选举过程。<br> 这时候的Leader选举和启动时期的Leader选举基本过程是一致的。</li><li>数据同步</li></ol> 
<h5><a id="22ACL_291"></a>22、什么是ACL权限控制机制？</h5> 
<p>Zookeeper作为一个分布式协调框架，内部存储了一些分布式系统运行时的状态的数据，比如leader选举、比如分布式锁。对这些数据的操作会直接影响到分布式系统的运行状态。</p> 
<p>因此，为了保证zookeeper中的数据的安全性，避免误操作带来的影响，提供了一套ACL权限控制机制来保证数据的安全。</p> 
<p>ACL(Access Control List)包括三个方面：</p> 
<p><strong>权限模式</strong>：</p> 
<ol><li>IP：从IP地址粒度进行权限控制</li><li>Digest：最常用，用类似于username:password的权限标识来进行权限配置，便于区分不同应用来进行权限控制</li><li>World：最开放的权限控制方式，是一种特殊的digest模式，只有一个权限标识“world:anyone”</li><li>Super：超级用户</li></ol> 
<p><strong>授权对象</strong>：指权限赋予的用户或一个指定的实体，不同的权限模式下，授权对象不同<br> <img src="https://images2.imgbox.com/f9/27/B4Zl9qHw_o.png" alt="在这里插入图片描述"></p> 
<p><strong>权限</strong>：指通过权限检查后可以被允许的操作</p> 
<ul><li>Create：允许对子节点Create操作</li><li>Read：允许对本节点GetChildren和GetData操作</li><li>Write：允许对本节点SetData操作</li><li>Delete：允许对子节点Delete操作</li><li>Admin：允许对本节点setAcl操作</li></ul> 
<h5><a id="23Chroot_315"></a>23、Chroot特性是什么?</h5> 
<p>3.2.0版本后，添加了Chroot特性，该特性允许每个客户端为自己设置一个命名空间。如果一个客户端设置了Chroot，那么该客户端对服务器的任何操作，都将会被限制在其自己的命名空间下。</p> 
<h5><a id="24zookeepernginx_318"></a>24、zookeeper负载均衡和nginx负载均衡区别？</h5> 
<p>zookeeper的负载均衡是可以调控，nginx只是能调权重，其他需要可控的都需要自己写插件；但是nginx的吞吐量比zk大很多，应该说按业务选择用哪种方式。</p> 
<h5><a id="25_321"></a>25、集群最少要几台机器，集群规则是怎样的?</h5> 
<p>集群规则为2N+1台，N&gt;0，即3台。</p> 
<h5><a id="26_324"></a>26、集群支持动态添加机器吗？</h5> 
<p>全部重启：关闭所有Zookeeper服务，修改配置之后启动。不影响之前客户端的会话。<br> 逐个重启：在过半存活即可用的原则下，一台机器重启不影响整个集群对外提供服务。这是比较常用的方式。<br> 3.5版本开始支持动态扩容。</p> 
<h5><a id="27chubby_329"></a>27、chubby是什么？</h5> 
<p>chubby是google的，完全实现paxos算法，不开源。<br> zookeeper是chubby的开源实现，使用zab协议，paxos算法的变种。</p> 
<h5><a id="28ZABPaxos_333"></a>28、ZAB和Paxos算法的联系与区别？</h5> 
<p>相同点：</p> 
<ol><li>两者都存在一个类似于Leader进程的角色，由其负责协调多个Follower进程的运行</li><li>Leader进程都会等待超过半数的Follower做出正确的反馈后，才会将一个提案进行提交</li><li>ZAB协议中，每个Proposal中都包含一个epoch值来代表当前的Leader周期，Paxos中名字为Ballot</li></ol> 
<p>不同点：ZAB用来构建高可用的分布式数据主备系统（Zookeeper），Paxos是用来构建分布式一致性状态机系统。</p> 
<h5><a id="29Zookeeper_341"></a>29、Zookeeper的典型应用场景？</h5> 
<ul><li>数据发布/订阅</li><li>负载均衡</li><li>命名服务</li><li>分布式协调/通知</li><li>集群管理</li><li>Master选举</li><li>分布式锁</li><li>分布式队列</li></ul> 
<p>·····<br> 内容后续不断更新中~~~</p> 
<p>====================================================================</p> 
<p>······<br> 帮助他人，快乐自己，最后，感谢您的阅读！<br> 所以如有纰漏或者建议，还请读者朋友们在评论区不吝指出！</p> 
<p><a href="http://myxiangwei.sxl.cn/" rel="nofollow">个人网站</a>…知识是一种宝贵的资源和财富，益发掘，更益分享…</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/16efe72cc131b1a3cf22371c74108c7c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux设置网卡采集模式,参考ethtool写了个Linux设置、获取网卡模式的接口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8c70574c92038fd2ca1c2dd5767f9545/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux安装kde桌面环境,在Debian 10（Buster）上安装KDE桌面环境的方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>