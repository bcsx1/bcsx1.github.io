<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Hbase相关 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Hbase相关" />
<meta property="og:description" content="Hbase相关 1.HBase 来源于哪篇博文？2. 下面对 HBase 的描述哪些是正确的？3.HBase 依靠（）存储底层数据4. HBase 依赖（）提供消息通信机制5.HBase 依赖（）提供强大的计算能力6. MapReduce 与 HBase 的关系，哪些描述是正确的？7.下面哪些选项正确描述了HBase 的特性？8.下面哪些概念是 HBase 框架中使用的？9. LSM 含义是?10.下面对 LSM 结构描述正确的是？ A、C11.LSM 更能保证哪种操作的性能？B12.LSM 的读操作和写操作是独立的？A13.LSM 结构的数据首先存储在（）。 B14.HFile 数据格式中的 Data 字段用于（）。A15.HFile 数据格式中的 MetaIndex 字段用于（）。D16.HFile 数据格式中的 Magic 字段用于（）。A17. HFile 数据格式中的 KeyValue 数据格式，下列选项描述正确的是（）。A、D18.HFile 数据格式中的 KeyValue 数据格式中 Value 部分是（）。C19. HBase 中的批量加载底层使用（）实现。A20.HBase 性能优化包含下面的哪些选项？A、B、C、D21.Rowkey 设计的原则，下列哪些选项的描述是正确的？A、B、C22.HBase 构建二级索引的实现方式有哪些？ A、B23.关于 HBase 二级索引的描述，哪些是正确的？A、B24.下列关于 Bloom Filter 的描述正确的是？A、C25.HBase 官方版本可以安装在什么操作系统上？A、B、C26.HBase 虚拟分布式模式需要（）个节点？A27.HBase 分布式模式最好需要（）个节点？C28.下列哪些选项是安装 HBase 前所必须安装的？A、B29.解压.tar.gz 结尾的 HBase 压缩包使用的 Linux 命令是？A30.HBase 的特点是什么？31.HBase 和 Hive 的区别详解？两者是什么？两者的特点限制应⽤场景总结 32." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/eb45b1817ca558f909c84d1a18f7f2c6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-03T19:37:37+08:00" />
<meta property="article:modified_time" content="2023-12-03T19:37:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Hbase相关</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Hbase相关</h4> 
 <ul><li><a href="#1HBase__1" rel="nofollow">1.HBase 来源于哪篇博文？</a></li><li><a href="#2__HBase__12" rel="nofollow">2. 下面对 HBase 的描述哪些是正确的？</a></li><li><a href="#3HBase__18" rel="nofollow">3.HBase 依靠（）存储底层数据</a></li><li><a href="#4_HBase__24" rel="nofollow">4. HBase 依赖（）提供消息通信机制</a></li><li><a href="#5HBase__30" rel="nofollow">5.HBase 依赖（）提供强大的计算能力</a></li><li><a href="#6_MapReduce__HBase__36" rel="nofollow">6. MapReduce 与 HBase 的关系，哪些描述是正确的？</a></li><li><a href="#7HBase__42" rel="nofollow">7.下面哪些选项正确描述了HBase 的特性？</a></li><li><a href="#8_HBase__47" rel="nofollow">8.下面哪些概念是 HBase 框架中使用的？</a></li><li><a href="#9_LSM__52" rel="nofollow">9. LSM 含义是?</a></li><li><a href="#10_LSM__AC_58" rel="nofollow">10.下面对 LSM 结构描述正确的是？ A、C</a></li><li><a href="#11LSM_B_64" rel="nofollow">11.LSM 更能保证哪种操作的性能？B</a></li><li><a href="#12LSM_A_70" rel="nofollow">12.LSM 的读操作和写操作是独立的？A</a></li><li><a href="#13LSM__B_75" rel="nofollow">13.LSM 结构的数据首先存储在（）。 B</a></li><li><a href="#14HFile__Data_A_81" rel="nofollow">14.HFile 数据格式中的 Data 字段用于（）。A</a></li><li><a href="#15HFile__MetaIndex_D_87" rel="nofollow">15.HFile 数据格式中的 MetaIndex 字段用于（）。D</a></li><li><a href="#16HFile__Magic_A_92" rel="nofollow">16.HFile 数据格式中的 Magic 字段用于（）。A</a></li><li><a href="#17_HFile__KeyValue_AD_98" rel="nofollow">17. HFile 数据格式中的 KeyValue 数据格式，下列选项描述正确的是（）。A、D</a></li><li><a href="#18HFile__KeyValue__Value_C_103" rel="nofollow">18.HFile 数据格式中的 KeyValue 数据格式中 Value 部分是（）。C</a></li><li><a href="#19_HBase_A_109" rel="nofollow">19. HBase 中的批量加载底层使用（）实现。A</a></li><li><a href="#20HBase_ABCD_114" rel="nofollow">20.HBase 性能优化包含下面的哪些选项？A、B、C、D</a></li><li><a href="#21Rowkey_ABC_119" rel="nofollow">21.Rowkey 设计的原则，下列哪些选项的描述是正确的？A、B、C</a></li><li><a href="#22HBase__AB_124" rel="nofollow">22.HBase 构建二级索引的实现方式有哪些？ A、B</a></li><li><a href="#23_HBase_AB_129" rel="nofollow">23.关于 HBase 二级索引的描述，哪些是正确的？A、B</a></li><li><a href="#24_Bloom_Filter_AC_134" rel="nofollow">24.下列关于 Bloom Filter 的描述正确的是？A、C</a></li><li><a href="#25HBase_ABC_139" rel="nofollow">25.HBase 官方版本可以安装在什么操作系统上？A、B、C</a></li><li><a href="#26HBase_A_144" rel="nofollow">26.HBase 虚拟分布式模式需要（）个节点？A</a></li><li><a href="#27HBase_C_149" rel="nofollow">27.HBase 分布式模式最好需要（）个节点？C</a></li><li><a href="#28_HBase_AB_154" rel="nofollow">28.下列哪些选项是安装 HBase 前所必须安装的？A、B</a></li><li><a href="#29targz__HBase__Linux_A_159" rel="nofollow">29.解压.tar.gz 结尾的 HBase 压缩包使用的 Linux 命令是？A</a></li><li><a href="#30HBase__164" rel="nofollow">30.HBase 的特点是什么？</a></li><li><a href="#31HBase__Hive__171" rel="nofollow">31.HBase 和 Hive 的区别详解？</a></li><li><ul><li><ul><li><a href="#_172" rel="nofollow">两者是什么？</a></li><li><a href="#_175" rel="nofollow">两者的特点</a></li><li><a href="#_178" rel="nofollow">限制</a></li><li><a href="#_181" rel="nofollow">应⽤场景</a></li><li><a href="#_184" rel="nofollow">总结</a></li></ul> 
  </li></ul> 
  </li><li><a href="#32HBase__190" rel="nofollow">32.HBase 适⽤于怎样的情景？</a></li><li><a href="#33_HBase__rowKey__199" rel="nofollow">33.描述 HBase 的 rowKey 的设计原则？</a></li><li><ul><li><ul><li><a href="#1rowkey_200" rel="nofollow">1.业务原则：必须严格按照业务需求来设计rowkey</a></li><li><a href="#2_211" rel="nofollow">2.唯⼀原则</a></li><li><a href="#3rowkeyrowkey_213" rel="nofollow">3.==组合原则==：根据业务需求，将经常被查询的列放在rowkey中，共同构成rowkey</a></li><li><a href="#4_275" rel="nofollow">4.`⻓度原则`</a></li><li><a href="#5_285" rel="nofollow">5.散列原则</a></li></ul> 
  </li></ul> 
  </li><li><a href="#34_HBase__scan__get__327" rel="nofollow">34.描述 HBase 中 scan 和 get 的功能以及实现的异同？</a></li><li><a href="#35_HBase__scan__setCache__setBatch___334" rel="nofollow">35.请描述 HBase 中 scan 对象的 setCache 和 setBatch ⽅法的使 ⽤？</a></li><li><a href="#36_HBase__cell__341" rel="nofollow">36.请详细描述 HBase 中⼀个 cell 的结构？</a></li><li><a href="#37_HBase__compact___344" rel="nofollow">37.简述 HBase 中 compact ⽤途是什么，什么时候触发，分为哪两 种，有什么区别，有哪些相关配置参数？</a></li><li><a href="#38_HBase__353" rel="nofollow">38.每天百亿数据存⼊ HBase，如何保证数据的存储正确和在规定 的时间⾥全部录⼊完毕，不残留数据？</a></li><li><a href="#39HBase__web__364" rel="nofollow">39.HBase 如何给 web 前端提供接⼝来访问？</a></li><li><a href="#40_HBase__366" rel="nofollow">40.请列举⼏个 HBase 优化⽅法？</a></li><li><ul><li><ul><li><a href="#1_367" rel="nofollow">1）减少调整</a></li><li><a href="#2_373" rel="nofollow">2）减少启停</a></li><li><a href="#3_379" rel="nofollow">3）减少数据量</a></li><li><a href="#4_384" rel="nofollow">4）合理设计</a></li></ul> 
  </li></ul> 
  </li><li><a href="#41HBase__RowFilter__BloomFilter__398" rel="nofollow">41.HBase 中 RowFilter 和 BloomFilter 原理？</a></li><li><ul><li><ul><li><a href="#1RowFilter__399" rel="nofollow">1）RowFilter 原理简析</a></li><li><a href="#2BloomFilter__417" rel="nofollow">2）BloomFilter 原理简析</a></li></ul> 
  </li></ul> 
  </li><li><a href="#42HBase__427" rel="nofollow">42.HBase 的导⼊导出⽅式?</a></li><li><a href="#43Region__438" rel="nofollow">43.Region 如何预建分区？</a></li><li><a href="#44HRegionServer__451" rel="nofollow">44.HRegionServer 宕机如何处理？</a></li><li><a href="#45HBase__459" rel="nofollow">45.==HBase 读写流程？==</a></li><li><ul><li><ul><li><a href="#_460" rel="nofollow">读：</a></li><li><a href="#_465" rel="nofollow">写：</a></li></ul> 
  </li></ul> 
  </li><li><a href="#46HBase__476" rel="nofollow">46.HBase 内部机制是什么？</a></li><li><a href="#47HTable_API__482" rel="nofollow">47.HTable API 有没有线程安全问题，在程序中是单例还是多例？</a></li><li><a href="#48Hbase__memstore__485" rel="nofollow">48.Hbase 中的 memstore 是⽤来做什么的？</a></li><li><a href="#49_HBase__489" rel="nofollow">49.如何提⾼ HBase 客户端的读写性能？请举例说明</a></li><li><a href="#50HBase__495" rel="nofollow">50.HBase 集群安装注意事项?</a></li><li><a href="#51_region___502" rel="nofollow">51.直接将时间戳作为⾏健，在写⼊单个 region 时候会发⽣热点问 题，为什么呢？</a></li><li><a href="#52_HBase__region__region___504" rel="nofollow">52.请描述如何解决 HBase 中 region 太⼩和 region 太⼤带来的冲 突？</a></li><li><a href="#53_508" rel="nofollow">53.解释⼀下布隆过滤器原理</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1HBase__1"></a>1.HBase 来源于哪篇博文？</h2> 
<ul><li>A TheGoogle File System</li><li>B MapReduce</li><li>C <code>BigTable</code></li><li>D Chubby</li><li>解析 
  <ul><li>谷歌的发布的三篇论文：21世纪前三架马车</li><li>分布式文件系统：GFS =&gt; HDFS</li><li>分布式计算：MapReduce =&gt; MAPReduce</li><li>分布式列式存储数据库：BigTable[Chubby] =&gt; Hbase[Zookeeper]</li></ul> </li></ul> 
<h2><a id="2__HBase__12"></a>2. 下面对 HBase 的描述哪些是正确的？</h2> 
<ul><li>A 不是开源的</li><li>B <code>是面向列的</code></li><li>C <code>是分布式的</code></li><li>D <code>是一种 NoSQL 数据库</code></li></ul> 
<h2><a id="3HBase__18"></a>3.HBase 依靠（）存储底层数据</h2> 
<ul><li>A <code>HDFS</code></li><li>B Hadoop</li><li>C Memory</li><li>D MapReduce</li></ul> 
<h2><a id="4_HBase__24"></a>4. HBase 依赖（）提供消息通信机制</h2> 
<ul><li>A <code>Zookeeper</code></li><li>B Chubby</li><li>C RPC</li><li>D Socket</li></ul> 
<h2><a id="5HBase__30"></a>5.HBase 依赖（）提供强大的计算能力</h2> 
<ul><li>AZookeeper</li><li>B Chubby</li><li>C RPC</li><li>D<code>MapReduce</code></li></ul> 
<h2><a id="6_MapReduce__HBase__36"></a>6. MapReduce 与 HBase 的关系，哪些描述是正确的？</h2> 
<ul><li>A 两者不可或缺，MapReduce 是 HBase 可以正常运行的保证</li><li>B <code>两者不是强关联关系，没有 MapReduce，HBase 可以正常运行</code></li><li>C<code>MapReduce 可以直接访问 HBase</code></li><li>D 它们之间没有任何关系</li></ul> 
<h2><a id="7HBase__42"></a>7.下面哪些选项正确描述了HBase 的特性？</h2> 
<ul><li>A <code>高可靠性</code></li><li>B <code>高性能</code></li><li>C <code>面向列</code></li><li>D <code>可伸缩</code></li></ul> 
<h2><a id="8_HBase__47"></a>8.下面哪些概念是 HBase 框架中使用的？</h2> 
<ul><li>A HDFS</li><li>B GridFS</li><li>C<code>Zookeeper</code></li><li>D EXT3</li></ul> 
<h2><a id="9_LSM__52"></a>9. LSM 含义是?</h2> 
<ul><li>A <code>日志结构合并树</code></li><li>B 二叉树</li><li>C 平衡二叉树</li><li>D 长平衡二叉树</li></ul> 
<h2><a id="10_LSM__AC_58"></a>10.下面对 LSM 结构描述正确的是？ A、C</h2> 
<ul><li>A <code>顺序存储</code></li><li>B 直接写硬盘</li><li>C <code>需要将数据 Flush 到磁盘</code></li><li>D 是一种搜索平衡树</li></ul> 
<h2><a id="11LSM_B_64"></a>11.LSM 更能保证哪种操作的性能？B</h2> 
<ul><li>A 读</li><li>B <code>写</code></li><li>C 随机读</li><li>D 合并</li></ul> 
<h2><a id="12LSM_A_70"></a>12.LSM 的读操作和写操作是独立的？A</h2> 
<ul><li>A <code>是</code>。</li><li>B 否。</li><li>C LSM 并不区分读和写</li><li>D LSM 中读写是同一种操作</li></ul> 
<h2><a id="13LSM__B_75"></a>13.LSM 结构的数据首先存储在（）。 B</h2> 
<ul><li>A 硬盘上</li><li>B <code>内存中</code></li><li>C 磁盘阵列中</li><li>D 闪存中</li></ul> 
<h2><a id="14HFile__Data_A_81"></a>14.HFile 数据格式中的 Data 字段用于（）。A</h2> 
<ul><li>A <code>存储实际的 KeyValue 数据</code></li><li>B 存储数据的起点</li><li>C 指定字段的长度</li><li>D 存储数据块的起点</li></ul> 
<h2><a id="15HFile__MetaIndex_D_87"></a>15.HFile 数据格式中的 MetaIndex 字段用于（）。D</h2> 
<ul><li>A Meta 块的长度</li><li>B Meta 块的结束点</li><li>C Meta 块数据内容</li><li>D <code>Meta 块的起始点</code></li></ul> 
<h2><a id="16HFile__Magic_A_92"></a>16.HFile 数据格式中的 Magic 字段用于（）。A</h2> 
<ul><li>A <code>存储随机数，防止数据损坏</code></li><li>B 存储数据的起点</li><li>C 存储数据块的起点</li><li>D 指定字段的长度</li></ul> 
<h2><a id="17_HFile__KeyValue_AD_98"></a>17. HFile 数据格式中的 KeyValue 数据格式，下列选项描述正确的是（）。A、D</h2> 
<ul><li>A <code>是 byte[]数组</code></li><li>B 没有固定的结构</li><li>C 数据的大小是定长的</li><li>D<code>有固定的结构</code></li></ul> 
<h2><a id="18HFile__KeyValue__Value_C_103"></a>18.HFile 数据格式中的 KeyValue 数据格式中 Value 部分是（）。C</h2> 
<ul><li>A 拥有复杂结构的字符串</li><li>B 字符串</li><li>C <code>二进制数据</code></li><li>D 压缩数据</li></ul> 
<h2><a id="19_HBase_A_109"></a>19. HBase 中的批量加载底层使用（）实现。A</h2> 
<ul><li>A <code>MapReduce</code></li><li>B Hive</li><li>C Coprocessor</li><li>D BloomFilter</li></ul> 
<h2><a id="20HBase_ABCD_114"></a>20.HBase 性能优化包含下面的哪些选项？A、B、C、D</h2> 
<ul><li>A <code> 读优化</code></li><li>B <code>写优化</code></li><li>C <code>配置优化</code></li><li>D <code>JVM 优化</code></li></ul> 
<h2><a id="21Rowkey_ABC_119"></a>21.Rowkey 设计的原则，下列哪些选项的描述是正确的？A、B、C</h2> 
<ul><li>A <code>尽量保证越短越好</code></li><li>B <code>可以使用汉字</code></li><li>C <code>可以使用字符串</code></li><li>D 本身是无序的</li></ul> 
<h2><a id="22HBase__AB_124"></a>22.HBase 构建二级索引的实现方式有哪些？ A、B</h2> 
<ul><li>A <code>MapReduce</code></li><li>B <code>Coprocessor</code></li><li>C BloomFilter</li><li>D Filter</li></ul> 
<h2><a id="23_HBase_AB_129"></a>23.关于 HBase 二级索引的描述，哪些是正确的？A、B</h2> 
<ul><li>A <code>核心是倒排表</code></li><li>B <code>二级索引概念是对应 Rowkey 这个“一级”索引</code></li><li>C 二级索引使用平衡二叉树</li><li>D 二级索引使用 LSM 结构</li></ul> 
<h2><a id="24_Bloom_Filter_AC_134"></a>24.下列关于 Bloom Filter 的描述正确的是？A、C</h2> 
<ul><li>A <code>是一个很长的二进制向量和一系列随机映射函数</code></li><li>B 没有误算率</li><li>C <code>有一定的误算率</code></li><li>D 可以在 Bloom Filter 中删除元素</li></ul> 
<h2><a id="25HBase_ABC_139"></a>25.HBase 官方版本可以安装在什么操作系统上？A、B、C</h2> 
<ul><li>A <code>CentOS</code></li><li>B <code> Ubuntu</code></li><li>C <code>RedHat</code></li><li>D Windows</li></ul> 
<h2><a id="26HBase_A_144"></a>26.HBase 虚拟分布式模式需要（）个节点？A</h2> 
<ul><li>A <code>1</code></li><li>B 2</li><li>C 3</li><li>D 最少 3 个</li></ul> 
<h2><a id="27HBase_C_149"></a>27.HBase 分布式模式最好需要（）个节点？C</h2> 
<ul><li>A 1</li><li>B 2</li><li>C <code>3</code></li><li>D 最少</li></ul> 
<h2><a id="28_HBase_AB_154"></a>28.下列哪些选项是安装 HBase 前所必须安装的？A、B</h2> 
<ul><li>A <code>操作系统</code></li><li>B <code>JDK</code></li><li>C ShellScript</li><li>D JavaCode</li></ul> 
<h2><a id="29targz__HBase__Linux_A_159"></a>29.解压.tar.gz 结尾的 HBase 压缩包使用的 Linux 命令是？A</h2> 
<ul><li>A <code>tar-zxvf</code></li><li>B tar -zx</li><li>C tar -s</li><li>D tar -nf</li></ul> 
<h2><a id="30HBase__164"></a>30.HBase 的特点是什么？</h2> 
<ul><li>1）数据量大：⼀个表可以有数⼗亿⾏，上百万列；</li><li>2）不同行，列可以不同：每⾏都有⼀个可排序的主键和任意多的列，列可以根据需要动态的增加，同⼀张表中不同的⾏可以有截然不同的列；</li><li>3）<code>⾯向列存储</code>：⾯向列（族）的存储和权限控制，列（族）独⽴检索；</li><li>4）稀疏：<code>空（null）列并不占⽤存储空间，表可以设计的⾮常稀疏</code>；</li><li>5）数据<code>多版本</code>：每个单元中的数据可以有多个版本，默认情况下版本号⾃动分配，是单元格插⼊时的<code>时间戳</code>；</li><li>6）数据类型单⼀：Hbase 中的数据都是字节，没有类型。</li></ul> 
<h2><a id="31HBase__Hive__171"></a>31.HBase 和 Hive 的区别详解？</h2> 
<h4><a id="_172"></a>两者是什么？</h4> 
<ul><li><code>Hive </code>是⼀个构建在 Hadoop 基础设施之上的<code>数据仓库</code>。通过 Hive 可以使⽤ HQL语⾔查询存放在 HDFS 上的数据。<code>HQL 是⼀种类 SQL 语⾔，这种语⾔最终被转化为Map/Reduce</code>. 虽然 Hive 提供了 SQL 查询功能，但是 Hive 不能够进⾏交互查询–因为它只能够在 Haoop 上批量的执⾏ Hadoop。</li><li><code>HBase</code> 是⼀种 <code>Key/Value 系统</code>，它<code>运⾏在 HDFS 之上</code>。和 Hive 不⼀样，<code>Hbase 的能够在它的数据库上实时运⾏，⽽不是运⾏ MapReduce 任务</code>。<code>Hbase 被分区为表格，表格⼜被进⼀步分割为列簇</code>。列簇必须使⽤ schema 定义，列簇将某⼀类型列集合起来（列不要求schema 定义）。例如，“message”列簇可能包含：“to”, ”from” “date”, “subject”, 和”body”. 每⼀个 key/value 对在 Hbase 中被定义为⼀个 cell，每⼀个 key 由 row-key，列簇、列和时间戳。在 Hbase 中，⾏是 key/value 映射的集合，这个映射通过 row-key 来唯⼀标识。Hbase 利⽤Hadoop 的基础设施，可以利⽤通⽤的设备进⾏⽔平的扩展。</li></ul> 
<h4><a id="_175"></a>两者的特点</h4> 
<ul><li>Hive 帮助熟悉 SQL 的⼈运⾏ MapReduce 任务。因为它是 JDBC 兼容的，同时，它也能够和现存的 SQL ⼯具整合在⼀起。运⾏ Hive 查询会花费很⻓时间，因为它会默认遍历表中所有的数据。虽然有这样的缺点，⼀次遍历的数据量可以通过 Hive 的分区机制来控制。分区允许在数据集上运⾏过滤查询，这些数据集存储在不同的⽂件夹内，查询的时候只遍历指定⽂件夹（分区）中的数据。这种机制可以⽤来，例如，只处理在某⼀个时间范围内的⽂件，只要这些⽂件名中包括了时间格式。</li><li>HBase 通过存储 key/value 来⼯作。它⽀持四种主要的操作：增加或者更新⾏，查看⼀个范围内的 cell，获取指定的⾏，删除指定的⾏、列或者是列的版本。版本信息⽤来获取历史数据（每⼀⾏的历史数据可以被删除，然后通过 Hbase compactions 就可以释放出空间）。虽然 HBase 包括表格，但是 schema 仅仅被表格和列簇所要求，列不需要 schema。Hbase 的表格包括增加/计数功能。</li></ul> 
<h4><a id="_178"></a>限制</h4> 
<ul><li><code>Hive ⽬前不⽀持更新操作</code>。另外，由于 hive 在 hadoop 上运⾏批量操作，它需要花费很⻓的时间，通常是⼏分钟到⼏个⼩时才可以获取到查询的结果。Hive 必须提供预先定义好的 schema 将⽂件和⽬录映射到列，并且 Hive 与 ACID 不兼容。</li><li>HBase 查询是通过特定的语⾔来编写的，这种语⾔需要重新学习。类 SQL 的功能可以通过 Apache Phonenix 实现，但这是以必须提供 schema 为代价的。另外，Hbase 也并不是兼容所有的 ACID 特性，虽然它⽀持某些特性。最后但不是最重要的–为了运⾏ Hbase，Zookeeper是必须的，zookeeper 是⼀个⽤来进⾏分布式协调的服务，这些服务包括配置服务，维护元信息和命名空间服务。</li></ul> 
<h4><a id="_181"></a>应⽤场景</h4> 
<ul><li>Hive 适合⽤来对⼀段时间内的数据进⾏分析查询，例如，⽤来计算趋势或者⽹站的⽇志。<code>Hive 不应该⽤来进⾏实时的查询</code>。因为它需要很⻓时间才可以返回结果。</li><li><code>Hbase ⾮常适合⽤来进⾏⼤数据的实时查询</code>。Facebook ⽤ Hbase 进⾏消息和实时的分析。它也可以⽤来统计 Facebook 的连接数。</li></ul> 
<h4><a id="_184"></a>总结</h4> 
<ul><li>Hive 和 Hbase 是两种基于 Hadoop 的不同技术</li><li>Hive 是⼀种类 SQL 的引擎，并且运⾏MapReduce 任务</li><li>Hbase 是⼀种在 Hadoop 之上的 NoSQL 的 Key/vale 数据库。</li><li>当然，这两种⼯具是可以同时使⽤的。就像⽤ Google 来搜索，⽤ FaceBook 进⾏社交⼀样，Hive 可以⽤来进⾏统计查询，HBase 可以⽤来进⾏实时查询，数据也可以从 Hive 写到 Hbase，设置再从Hbase 写回 Hive。</li></ul> 
<h2><a id="32HBase__190"></a>32.HBase 适⽤于怎样的情景？</h2> 
<ul><li><code>半结构化或⾮结构化数据</code> 
  <ul><li>对于数据结构字段不够确定或杂乱⽆章很难按⼀个概念去进⾏抽取的数据适合⽤HBase。以上⾯的例⼦为例，当业务发展需要存储 author 的 email，phone，address 信息时RDBMS 需要停机维护，⽽ HBase ⽀持动态增加。</li></ul> </li><li><code>记录⾮常稀疏</code> 
  <ul><li>RDBMS 的⾏有多少列是固定的，为 null 的列浪费了存储空间。⽽如上⽂提到的，HBase为 null 的 Column 不会被存储，这样既节省了空间⼜提⾼了读性能。</li></ul> </li><li><code>多版本数据</code> 
  <ul><li>如上⽂提到的根据 Row key 和 Column key 定位到的 Value 可以有任意数量的版本值，因此对于需要存储变动历史记录的数据，⽤ HBase 就⾮常⽅便了。⽐如上例中的 author 的Address 是会变动的，业务上⼀般只需要最新的值，但有时可能需要查询到历史值。</li></ul> </li><li><code>超⼤数据量</code> 
  <ul><li>当数据量越来越⼤，RDBMS 数据库撑不住了，就出现了读写分离策略，通过⼀个 Master专⻔负责写操作，多个 Slave 负责读操作，服务器成本倍增。随着压⼒增加，Master 撑不住了，这时就要分库了，把关联不⼤的数据分开部署，⼀些 join 查询不能⽤了，需要借助中间层。随着数据量的进⼀步增加，⼀个表的记录越来越⼤，查询就变得很慢，于是⼜得搞分表，⽐如按 ID 取模分成多个表以减少单个表的记录数。经历过这些事的⼈都知道过程是多么的折腾。采⽤ HBase 就简单了，只需要加机器即可，HBase 会⾃动⽔平切分扩展，跟 Hadoop的⽆缝集成保障了其数据可靠性（HDFS）和海量数据分析的⾼性能（MapReduce）。</li></ul> </li></ul> 
<h2><a id="33_HBase__rowKey__199"></a>33.描述 HBase 的 rowKey 的设计原则？</h2> 
<h4><a id="1rowkey_200"></a>1.业务原则：必须严格按照业务需求来设计rowkey</h4> 
<ul><li>有别于传统数据库的设计 
  <ul><li><code>主键：只要有一列能区分每一行的唯一性，就可以作为主键</code> 
    <ul><li>自增int类型</li><li>学生id</li><li>学生身份证号码</li><li>准考证号码</li></ul> </li></ul> </li><li><code>Hbase的rowkey不仅仅只有唯一性，还要考虑业务</code> 
  <ul><li>用什么作为rowkey的前缀，就可以走索引查询</li><li><code>将最常用的查询条件作为前缀</code></li><li>例如：经常按照日期查询这张表，就用日期作为rowkey前缀</li></ul> </li></ul> 
<h4><a id="2_211"></a>2.唯⼀原则</h4> 
<ul><li>必须在设计上保证其唯⼀性。</li></ul> 
<h4><a id="3rowkeyrowkey_213"></a>3.<mark>组合原则</mark>：根据业务需求，将经常被查询的列放在rowkey中，共同构成rowkey</h4> 
<ul><li>在查询时，<code>将最常用的一些查询条件的列，放在rowkey中，让常用查询可以走索引</code></li><li>本身数据中还是有这些列的 
  <ul><li>userid/time/orderid/productid</li></ul> </li><li>商品表 
  <ul><li>rowkey：type_productid_name 
    <ul><li>水果 _ 001_ 荔枝 
      <ul><li>type：水果</li><li>productid：001</li><li>name：荔枝</li><li>颜色</li><li>价格</li></ul> </li><li>水果 _ 002_ 西瓜</li><li>数码 _ 003 _ 手机</li></ul> </li></ul> </li><li>查询所有的水果</li></ul> 
<pre><code class="prism language-java">scan<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrefiexFilter</span><span class="token punctuation">(</span><span class="token string">"水果"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<ul><li>查询水果中001这个商品的信息</li></ul> 
<pre><code class="prism language-java">scan<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrefiexFilter</span><span class="token punctuation">(</span><span class="token string">"水果_001"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<ul><li>订单表 
  <ul><li>后台：rowkey：orderId_userId_timestamp 
    <ul><li>ddfkjdlkfjdj_001_1593570797 
      <ul><li>userid</li><li>serverTime</li><li>orderid</li><li>price</li><li>productid</li><li>paytype</li><li>……</li></ul> </li><li>dffjklfksdss_002_1593570797</li><li>fklfjklfsklds_003_1593570797</li><li>dfdifjdkfjdd_004_1593570798</li><li>dffdsdseerd_001_1593570799</li><li>满足索引的 
      <ul><li>查询某个订单的信息</li><li>查询某个订单对应用户在某个时间的信息</li></ul> </li><li>如果我只知道时间，能不能查询？ 
      <ul><li>可以查询，但是不走索引，走全表扫描，对时间这一列进行过滤</li><li>scan tbname {valuefilter {serverTime= 20200101}}</li><li>因为时间在rowkey中，但不是前缀，不能做前缀匹配的索引查询</li></ul> </li></ul> </li></ul> </li><li>用户：rowkey：userId_timestamp_orderId 
  <ul><li>001_1593570797_ddfkjdlkfjdj 
    <ul><li>userid</li><li>serverTime</li><li>orderid</li><li>price</li><li>productid</li><li>paytype</li><li>……</li></ul> </li><li>001_1593570799_dffdsdseerd</li><li>002_1593570797_dffjklfksdss</li><li>003_1593570797_fklfjklfsklds</li><li>004_</li><li>满足索引查询 
    <ul><li>用户登录，能查询所有的订单</li><li>用户登录，根据用户名查询这个用户在任何一个时间的订单</li></ul> </li></ul> </li></ul> 
<h4><a id="4_275"></a>4.<code>⻓度原则</code></h4> 
<ul><li>如果rowkey越长，在底层进行查询比较时候就比较慢</li><li>在满足业务需求的情况下，越短越好</li><li><code>rowkey在底层每一列的存储中都有，是冗余的</code></li><li>如果长度真的无法缩短，<code>可以使用编码变成16位或者32位的rowkey</code></li><li>Rowkey 是⼀个⼆进制码流，Rowkey 的⻓度被很多开发者建议说设计在 10~100 个字节，不过建议是越短越好，不要超过 16 个字节。 
  <ul><li>原因如下：</li><li>（1）数据的持久化⽂件 HFile 中是按照 KeyValue 存储的，如果 Rowkey 过⻓⽐如 100个字节，1000 万列数据光 Rowkey 就要占⽤ 100*1000 万=10 亿个字节，将近 1G 数据，这会极⼤影响 HFile 的存储效率；</li><li>（2）MemStore 将缓存部分数据到内存，如果 Rowkey 字段过⻓内存的有效利⽤率会降低，系统将⽆法缓存更多的数据，这会降低检索效率。因此 Rowkey 的字节⻓度越短越好。</li><li>（3）⽬前操作系统是都是 64 位系统，内存 8 字节对⻬。控制在 16 个字节，8 字节的整数倍利⽤操作系统的最佳特性。</li></ul> </li></ul> 
<h4><a id="5_285"></a>5.散列原则</h4> 
<ul><li>如果Rowkey 是按时间戳的⽅式递增，不要将时间放在⼆进制码的前⾯，建议将 <code>Rowkey的⾼位作为散列字段，由程序循环⽣成，低位放时间字段</code>，这样将提⾼数据均衡分布在每个Regionserver 实现负载均衡的⼏率。如果没有散列字段，⾸字段直接是时间信息将产⽣所有新数据都在⼀个 RegionServer 上堆积的热点现象，这样在做数据检索的时候负载将会集中在个别 RegionServer，降低查询效率。</li><li>rowkey：时间 _ 订单Id _ 用户id 
  <ul><li>1593570797_dffjklfksdss_002</li><li>1593570797_fklfjklfsklds_003</li><li>1593570798_dfdifjdkfjdd_003</li><li>1593570799_dffdsdseerd_001</li><li>1593570800</li><li>1593570801</li><li>1593570802</li><li>……</li><li>1600000000：</li><li>|</li><li>2000000000</li><li>按照时间作为前缀，写入表中</li><li><code>因为region是有序的，如果rowkey也是有序的，必然会产生热点</code></li></ul> </li><li>必须将rowkey构建散列，常用的方式 
  <ul><li>推荐使用<code>不连续的字段作为前缀</code> 
    <ul><li>userid</li></ul> </li><li><code>编码</code>：将连续的rowkey编码以后作为rowkey 
    <ul><li>1593570797：12qwert4</li><li>1593570798：asdfg789</li><li>读取数据时需要解码</li><li>MD5、CRC32</li><li>8位、16位、32位</li></ul> </li><li><code>反转</code>：读取时需要再反转回来 
    <ul><li>0080753951</li><li>1080793951</li><li>2080753951</li><li>3080753951</li><li>4080753951</li><li>5080753951</li><li>……</li><li>9080753951</li><li>0180753951</li><li>1180753951</li></ul> </li><li><code>加随机数</code> 
    <ul><li>不推荐，给定一个固定的随机范围0-9</li><li>0_1593570797_dffjklfksdss_002</li><li>9_1593570797_dffjklfksdss_003</li><li>牺牲很大的读取的代价 
      <ul><li>读取数据时，必须挨个试</li></ul> </li></ul> </li></ul> </li></ul> 
<h2><a id="34_HBase__scan__get__327"></a>34.描述 HBase 中 scan 和 get 的功能以及实现的异同？</h2> 
<ul><li>HBase 的查询实现只提供两种⽅式：</li><li>1）<code>按指定RowKey获取唯⼀⼀条记录，get⽅法</code>（org.apache.hadoop.hbase.client.Get）Get 的⽅法处理分两种 : 设置了 ClosestRowBefore 和没有设置 ClosestRowBefore 的rowlock。主要是⽤来保证⾏的事务性，即<code>每个 get 是以⼀个 row 来标记的</code>。⼀个 row 中可以有很多 family 和 column。</li><li>2）<code>按指定的条件获取⼀批记录，scan ⽅法</code>(org.apache.Hadoop.hbase.client.Scan）实现条件查询功能使⽤的就是 scan ⽅式。 
  <ul><li>（1）scan 可以通过 setCaching 与 setBatch ⽅法提⾼速度(以空间换时间)；</li><li>（2）scan 可以通过 setStartRow 与 setEndRow 来限定范围([start，end)start 是闭区间，end 是开区间)。范围越⼩，性能越⾼。</li><li>（3）scan 可以通过 setFilter ⽅法添加过滤器，这也是分⻚、多条件查询的基础。</li></ul> </li></ul> 
<h2><a id="35_HBase__scan__setCache__setBatch___334"></a>35.请描述 HBase 中 scan 对象的 setCache 和 setBatch ⽅法的使 ⽤？</h2> 
<ul><li>setCache ⽤于设置缓存，即设置⼀次 RPC 请求可以获取多⾏数据。对于缓存操作，如果⾏的数据量⾮常⼤，多⾏数据有可能超过客户端进程的内存容量，由此引⼊批量处理这⼀解决⽅案。</li><li>setBatch ⽤于设置批量处理，批量可以让⽤户选择每⼀次ResultScanner 实例的 next 操作要取回多少列，例如，在扫描中设置 setBatch(5)，则⼀次 next()返回的 Result 实例会包括5列。如果⼀⾏包括的列数超过了批量中设置的值，则可以将这⼀⾏分⽚，每次 next 操作返回⼀⽚，当⼀⾏的列数不能被批量中设置的值整除时，最后⼀次返回的 Result 实例会包含⽐较少的列，如，⼀⾏ 17 列，batch 设置为 5，则⼀共返回 4 个 Result 实例，这 4 个实例中包括的列数分别为 5、5、5、2。</li><li>组合使⽤扫描器缓存和批量⼤⼩，可以让⽤户⽅便地控制扫描⼀个范围内的⾏键所需要的 RPC 调⽤次数。Cache 设置了服务器⼀次返回的⾏数，⽽ Batch 设置了服务器⼀次返回的列数。</li><li>① Batch 参数决定了⼀⾏数据分为⼏个 Result，它只针对⼀⾏数据，Batch 再⼤，也只能将⼀⾏的数据放⼊⼀个 Result 中。所以当⼀⾏数据有 10列，⽽ Batch 为 100 时，也只能将⼀⾏的所有列都放⼊⼀个 Result，不会混合其他⾏；</li><li>② 缓存值决定⼀次 RPC 返回⼏个 Result，根据 Batch 划分的 Result 个数除以缓存个数可以得到 RPC 消息个数（之前定义缓存值决定⼀次返回的⾏数，这是不准确的，准确来说是决定⼀次 RPC 返回的 Result 个数，由于在引⼊ Batch 之前，⼀⾏封装为⼀个 Result，因此定义缓存值决定⼀次返回的⾏数，但引⼊ Batch 后，更准确的说法是缓存值决定了⼀次 RPC返回的 Result 个数）；</li><li>RPC 请求次数 = （⾏数 * 每⾏列数） / Min（每⾏的列数，批量⼤⼩） / 扫描器缓存</li></ul> 
<h2><a id="36_HBase__cell__341"></a>36.请详细描述 HBase 中⼀个 cell 的结构？</h2> 
<ul><li>HBase 中通过 row 和 columns 确定的为⼀个存贮单元称为 cell。</li><li>Cell：由<code>{row key, column(=&lt;family&gt; + &lt;label&gt;), version}</code>唯⼀确定的单元。<code>cell </code>中的数据是<code>没有类型</code>的，全部是<code>字节码形式存贮</code>。</li></ul> 
<h2><a id="37_HBase__compact___344"></a>37.简述 HBase 中 compact ⽤途是什么，什么时候触发，分为哪两 种，有什么区别，有哪些相关配置参数？</h2> 
<ul><li>在 hbase 中<code>每当有 memstore 数据 flush 到磁盘之后，就形成⼀个 storefile，当 storeFile的数量达到⼀定程度后，就需要将 storefile ⽂件来进⾏ compaction 操作</code>。</li><li>Compact 的作⽤： 
  <ul><li>① <code>合并⽂件</code></li><li>② <code>清除过期，多余版本的数据</code></li><li>③ <code>提⾼读写数据的效率</code></li></ul> </li><li>HBase 中实现了两种 compaction 的⽅式：<code>minor and major</code>. 这两种 compaction ⽅式的区别是：<br> 1、<code>Minor </code>操作只⽤来做部分⽂件的合并操作以及包括 minVersion=0 并且设置 ttl 的过期版本清理，<code>不做任何删除数据、多版本数据的清理⼯作。</code><br> 2、<code>Major </code>操作是对 Region 下的 HStore 下的所有 StoreFile 执⾏合并操作，<code>最终的结果是整理合并出⼀个⽂件。</code></li></ul> 
<h2><a id="38_HBase__353"></a>38.每天百亿数据存⼊ HBase，如何保证数据的存储正确和在规定 的时间⾥全部录⼊完毕，不残留数据？</h2> 
<ul><li>需求分析： 
  <ul><li>1）百亿数据：证明数据量⾮常⼤；</li><li>2）存⼊ HBase：证明是跟 HBase 的写⼊数据有关；</li><li>3）保证数据的正确：要设计正确的数据结构保证正确性；</li><li>4）在规定时间内完成：对存⼊速度是有要求的。</li></ul> </li><li>解决思路： 
  <ul><li>1）数据量百亿条，什么概念呢？假设⼀整天 60x60x24 = 86400 秒都在写⼊数据，那么每秒的写⼊条数⾼达 100万条，HBase 当然是⽀持不了每秒百万条数据的，所以这百亿条数据可能不是通过实时地写⼊，⽽是批量地导⼊。批量导⼊推荐使⽤ BulkLoad ⽅式（推荐阅读：Spark 之读写 HBase），性能是普通写⼊⽅式⼏倍以上；</li><li>2）存⼊ HBase：普通写⼊是⽤ JavaAPI put 来实现，批量导⼊推荐使⽤ <code>BulkLoad</code>；</li><li>3）保证数据的正确：这⾥需要考虑 RowKey 的设计、预建分区和列族设计等问题；</li><li>4）在规定时间内完成也就是存⼊速度不能过慢，并且当然是越快越好，使⽤ BulkLoad。</li></ul> </li></ul> 
<h2><a id="39HBase__web__364"></a>39.HBase 如何给 web 前端提供接⼝来访问？</h2> 
<ul><li>使⽤ JavaAPI 来编写 WEB 应⽤，使⽤ HBase 提供的 RESTFul 接⼝。</li></ul> 
<h2><a id="40_HBase__366"></a>40.请列举⼏个 HBase 优化⽅法？</h2> 
<h4><a id="1_367"></a>1）减少调整</h4> 
<ul><li>减少调整这个如何理解呢？HBase 中有⼏个内容会动态调整，如 region（分区）、HFile，所以通过⼀些⽅法来减少这些会带来 I/O 开销的调整。</li><li>1.1<code>Region</code> 
  <ul><li>如果没有<code>预建分区</code>的话，那么随着 region 中条数的增加，region 会进⾏分裂，这将增加I/O 开销，所以解决⽅法就是<code>根据你的 RowKey 设计来进⾏预建分区，减少 region 的动态分裂</code>。</li></ul> </li><li>1.2<code>HFile</code> 
  <ul><li>HFile 是数据底层存储⽂件，在每个 memstore 进⾏刷新时会⽣成⼀个 HFile，当 HFile增加到⼀定程度时，会将属于⼀个 region 的 HFile 进⾏合并，这个步骤会带来开销但不可避免，但是合并后 HFile ⼤⼩如果⼤于设定的值，那么 HFile 会重新分裂。为了减少这样的⽆谓的 I/O 开销，<code>建议估计项⽬数据量⼤⼩，给 HFile 设定⼀个合适的值。</code></li></ul> </li></ul> 
<h4><a id="2_373"></a>2）减少启停</h4> 
<ul><li>数据库事务机制就是为了更好地实现批量写⼊，较少数据库的开启关闭带来的开销，那么 HBase 中也存在频繁开启关闭带来的问题。</li><li>2.1<code>关闭 Compaction，在闲时进⾏⼿动 Compaction</code>。 
  <ul><li>因为 HBase 中存在 Minor Compaction 和 Major Compaction，也就是对 HFile 进⾏合并，所谓合并就是 I/O 读写，⼤量的 HFile 进⾏肯定会带来 I/O 开销，甚⾄是 I/O ⻛暴，所以为了避免这种不受控制的意外发⽣，建议关闭⾃动 Compaction，在闲时进⾏ compaction。</li></ul> </li><li>2.2<code>批量数据写⼊时采⽤ BulkLoad</code>。 
  <ul><li>如果通过 HBase-Shell 或者 JavaAPI 的 put 来实现⼤量数据的写⼊，那么性能差是肯定并且还可能带来⼀些意想不到的问题，所以当需要写⼊⼤量离线数据时建议使⽤ BulkLoad</li></ul> </li></ul> 
<h4><a id="3_379"></a>3）减少数据量</h4> 
<ul><li>虽然我们是在进⾏⼤数据开发，但是如果可以通过某些⽅式在保证数据准确性同时减少数据量，何乐⽽不为呢？</li><li>3.1<code>开启过滤，提⾼查询速度</code> 
  <ul><li>开启 BloomFilter，BloomFilter 是列族级别的过滤，在⽣成⼀个 StoreFile 同时会⽣成⼀个 MetaBlock，⽤于查询时过滤数据</li></ul> </li><li>3.2<code>使⽤压缩</code>：⼀般推荐使⽤ Snappy 和 LZO 压缩</li></ul> 
<h4><a id="4_384"></a>4）合理设计</h4> 
<ul><li>在⼀张 HBase 表格中 RowKey 和 ColumnFamily 的设计是⾮常重要，好的设计能够提⾼性能和保证数据的准确性</li><li>4.1RowKey 设计：应该具备以下⼏个属性 
  <ul><li>散列性：散列性能够保证相同相似的 rowkey 聚合，相异的 rowkey 分散，有利于查询。</li><li>简短性：rowkey 作为 key 的⼀部分存储在 HFile 中，如果为了可读性将 rowKey 设计得过⻓，那么将会增加存储压⼒。</li><li>唯⼀性：rowKey 必须具备明显的区别性。</li><li>业务性：举例来说： 
    <ul><li>假如我的查询条件⽐较多，⽽且不是针对列的条件，那么 rowKey 的设计就应该⽀持多条件查询。</li><li>如果我的查询要求是最近插⼊的数据优先，那么 rowKey 则可以采⽤加上 Long.Max-时间戳的⽅式，这样 rowKey 就是递减排列。</li></ul> </li></ul> </li><li>4.2列族的设计 
  <ul><li>列族的设计需要看应⽤场景</li><li>多列族设计的优劣：</li><li>优势：HBase 中数据时按列进⾏存储的，那么查询某⼀列族的某⼀列时就不需要全盘扫描，只需要扫描某⼀列族，减少了读 I/O；其实多列族设计对减少的作⽤不是很明显，适⽤于<code>读多写少</code>的场景</li><li>劣势：降低了写的 I/O 性能。原因如下：数据写到 store 以后是先缓存在 memstore 中，同⼀个region中存在多个列族则存在多个store，每个store都⼀个memstore，当memstore进⾏ flush 时，属于同⼀个 region 的 store 中的 memstore 都会进⾏ flush，增加 I/O 开销。</li></ul> </li></ul> 
<h2><a id="41HBase__RowFilter__BloomFilter__398"></a>41.HBase 中 RowFilter 和 BloomFilter 原理？</h2> 
<h4><a id="1RowFilter__399"></a>1）RowFilter 原理简析</h4> 
<ul><li>RowFilter 顾名思义就是对 rowkey 进⾏过滤，那么 rowkey 的过滤⽆⾮就是相等（EQUAL）、⼤于(GREATER)、⼩于(LESS)，⼤于等于(GREATER_OR_EQUAL)，⼩于等于(LESS_OR_EQUAL)和不等于(NOT_EQUAL)⼏种过滤⽅式。Hbase 中的 RowFilter 采⽤⽐较符结合⽐较器的⽅式来进⾏过滤。<br> ⽐较器的类型如下： 
  <ul><li>BinaryComparator</li><li>BinaryPrefixComparator</li><li>NullComparator</li><li>BitComparator</li><li>RegexStringComparator</li><li>SubStringComparator</li></ul> </li><li>例如</li></ul> 
<pre><code class="prism language-scala"> Filter rowFilter <span class="token operator">=</span> <span class="token keyword">new</span> RowFilter<span class="token punctuation">(</span>CompareFilter<span class="token punctuation">.</span>CompareOp<span class="token punctuation">.</span>EQUAL<span class="token punctuation">,</span><span class="token keyword">new</span> BinaryComparator<span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span>toBytes<span class="token punctuation">(</span>rowKeyValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 Scan scan <span class="token operator">=</span> <span class="token keyword">new</span> Scan<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 scan<span class="token punctuation">.</span>setFilter<span class="token punctuation">(</span>rowFilter<span class="token punctuation">)</span>
</code></pre> 
<ul><li>在上⾯例⼦中，⽐较符为 EQUAL，⽐较器为 BinaryComparator</li></ul> 
<h4><a id="2BloomFilter__417"></a>2）BloomFilter 原理简析</h4> 
<ul><li>主要功能：提供随机读的性能</li><li>存储开销：BloomFilter 是列族级别的配置，⼀旦表格中开启 BloomFilter，那么在⽣成 StoreFile 时同时会⽣成⼀份包含 BloomFilter 结构的⽂件 MetaBlock，所以会增加⼀定的存储开销和内存开销</li><li>粒度控制：ROW 和 ROWCOL</li><li>BloomFilter 的原理: 
  <ul><li>① 内部是⼀个 bit 数组，初始值均为 0</li><li>② 插⼊元素时对元素进⾏ hash 并且映射到数组中的某⼀个 index，将其置为 1，再进⾏多次不同的 hash 算法，将映射到的 index 置为 1，同⼀个 index 只需要置 1 次。</li><li>③ 查询时使⽤跟插⼊时相同的 hash 算法，如果在对应的 index 的值都为 1，那么就可以认为该元素可能存在，注意，只是可能存在</li><li>④ 所以 BlomFilter 只能保证过滤掉不包含的元素，⽽不能保证误判包含</li><li>设置：<code>在建表时对某⼀列设置 BloomFilter 即可</code></li></ul> </li></ul> 
<h2><a id="42HBase__427"></a>42.HBase 的导⼊导出⽅式?</h2> 
<ul><li>1）导⼊： 
  <ul><li>bin/hbase org.apache.hadoop.hbase.mapreduce.Driver <code>import</code> 表名 路径</li><li>路径：来源</li><li>本地路径 file:///path</li><li>HDFS hdfs://cluster1/path</li></ul> </li><li>2）导出： 
  <ul><li>bin/hbase org.apache.hadoop.hbase.mapreduce.Driver <code>export</code> 表名 路径</li><li>路径：⽬的地</li><li>本地路径 file:///path</li><li>HDFS hdfs://cluster1/path</li></ul> </li></ul> 
<h2><a id="43Region__438"></a>43.Region 如何预建分区？</h2> 
<ul><li><code>预分区</code>的⽬的主要是在<code>创建表的时候指定分区数，提前规划表有多个分区，以及每个分区的区间范围</code>，这样在存储的时候 rowkey 按照分区的区间存储，可以<code>避免 region 热点</code>问题。<br> 通常有两种⽅案：</li><li>⽅案 1:shell ⽅法</li></ul> 
<pre><code class="prism language-sql"><span class="token keyword">create</span> <span class="token string">'tb_splits'</span><span class="token punctuation">,</span> {NAME <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token string">'cf'</span><span class="token punctuation">,</span>VERSIONS<span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">3</span>}<span class="token punctuation">,</span>{SPLITS <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token string">'10'</span><span class="token punctuation">,</span><span class="token string">'20'</span><span class="token punctuation">,</span><span class="token string">'30'</span><span class="token punctuation">]</span>}
</code></pre> 
<ul><li>⽅案 2: JAVA 程序控制 
  <ul><li>2.1取样，先随机⽣成⼀定数量的 rowkey,将取样数据按升序排序放到⼀个集合⾥；</li><li>2.2根据预分区的 region 个数，对整个集合平均分割，即是相关的 splitKeys；</li><li>2.3HBaseAdmin.createTable(HTableDescriptor tableDescriptor,byte[][]splitkeys)可以指定预分区的 splitKey，即是指定 region 间的 rowkey 临界值。</li></ul> </li></ul> 
<h2><a id="44HRegionServer__451"></a>44.HRegionServer 宕机如何处理？</h2> 
<ul><li>1）ZooKeeper 会监控 HRegionServer 的上下线情况，当 ZK 发现某个 HRegionServer 宕机之后会通知 HMaster 进⾏失效备援；</li><li>2）该 HRegionServer 会停⽌对外提供服务，就是它所负责的 region 暂时停⽌对外提供服务；</li><li>3）HMaster 会将该 HRegionServer 所负责的 region 转移到其他 HRegionServer 上，并且会对 HRegionServer 上存在 memstore 中还未持久化到磁盘中的数据进⾏恢复；</li><li>4） 这个恢复的⼯作是由 WAL 重播来完成，这个过程如下： 
  <ul><li>4.1wal 实际上就是⼀个⽂件，存在/hbase/WAL/对应 RegionServer 路径下。</li><li>4.2宕机发⽣时，读取该 RegionServer 所对应的路径下的 wal ⽂件，然后根据不同的region 切分成不同的临时⽂件 recover.edits。</li><li>4.3当 region 被分配到新的 RegionServer 中，RegionServer 读取 region 时会进⾏是否存在recover.edits，如果有则进⾏恢复。</li></ul> </li></ul> 
<h2><a id="45HBase__459"></a>45.<mark>HBase 读写流程？</mark></h2> 
<h4><a id="_460"></a>读：</h4> 
<ul><li>① HRegionServer 保存着 meta 表以及表数据，要访问表数据，⾸先 Client 先去访问zookeeper，从 <code>zookeeper </code>⾥⾯获取 meta 表所在的位置信息，即<code>找到这个 meta 表在哪个HRegionServer 上保存着</code>。</li><li>② 接着 Client 通过刚才获取到的 HRegionServer 的 IP 来<code>访问 Meta 表所在的HRegionServer</code>，从⽽读取到 Meta，进⽽获取到 Meta 表中存放的元数据。</li><li>③ Client 通过元数据中存储的信息，访问对应的 HRegionServer，然后<code>扫描所在HRegionServer 的 Memstore 和 Storefile 来查询数据</code>。</li><li>④ 最后 HRegionServer 把查询到的数据<code>响应</code>给 Client。</li></ul> 
<h4><a id="_465"></a>写：</h4> 
<ul><li>① Client 先访问<code> zookeeper</code>，<code>找到 Meta 表</code>，并获取 Meta 表元数据。</li><li>② 确定当前将要写⼊的数据所对应的 HRegion 和 HRegionServer 服务器。</li><li>③ Client <code>向该 HRegionServer 服务器发起写⼊数据请求</code>，然后 HRegionServer 收到请求并响应。</li><li>④ Client <code>先把数据写⼊到 HLog</code>，以防⽌数据丢失。</li><li>⑤ 然后将数据写⼊到 <code>Memstore</code>。</li><li>⑥ 如果 HLog 和 Memstore 均写⼊成功，则这条数据写⼊成功</li><li>⑦ 如果 <code>Memstore 达到阈值，会把 Memstore 中的数据 flush 到 Storefile 中</code>。</li><li>⑧ 当 <code>Storefile 越来越多，会触发 Compact 合并操作，把过多的 Storefile 合并成⼀个⼤的 Storefile</code>。</li><li>⑨ 当<code> Storefile 越来越⼤，Region 也会越来越⼤，达到阈值后，会触发 Split 操作，将Region ⼀分为⼆</code>。</li></ul> 
<h2><a id="46HBase__476"></a>46.HBase 内部机制是什么？</h2> 
<ul><li>Hbase 是⼀个能适应联机业务的数据库系统</li><li><code>物理存储</code>：hbase 的<code>持久化数据是将数据存储在 HDFS 上</code>。</li><li><code>存储管理</code>：<code>⼀个表是划分为很多 region 的，这些 region 分布式地存放在很多 regionserver上 Region 内部还可以划分为 store，store 内部有 memstore 和 storefile</code>。</li><li><code>版本管理</code>：<code>hbase 中的数据更新本质上是不断追加新的版本，通过 compact 操作来做版本间的⽂件合并 Region 的 split</code>。</li><li><code>集群管理</code>：<code>ZooKeeper + HMaster + HRegionServer</code>。</li></ul> 
<h2><a id="47HTable_API__482"></a>47.HTable API 有没有线程安全问题，在程序中是单例还是多例？</h2> 
<ul><li>在单线程环境下使⽤ hbase 的 htable 是没有问题，但是突然⾼并发多线程情况下就可能出现问题。</li><li><code>HTable 不是线程安全的</code>。建议使⽤同⼀个HBaseConfiguration 实例来创建 HTable 实例，这样可以共享 ZooKeeper 和 socket 实例。</li></ul> 
<h2><a id="48Hbase__memstore__485"></a>48.Hbase 中的 memstore 是⽤来做什么的？</h2> 
<ul><li>hbase 为了<code>保证随机读取的性能</code>，所以 <code>hfile ⾥⾯的 rowkey 是有序</code>的。当客户端的请求在到达 regionserver 之后，为了保证写⼊ rowkey 的有序性，所以不能将数据⽴刻写⼊到 hfile中，⽽是将每个变更操作保存在内存中，也就是 memstore 中。memstore 能够很⽅便的⽀持操作的随机插⼊，并保证所有的操作在内存中是有序的。<code>当 memstore 达到⼀定的量之后，会将 memstore ⾥⾯的数据 flush 到 hfile 中，这样能充分利⽤ hadoop 写⼊⼤⽂件的性能优势，提⾼写⼊性能</code>。</li><li>由于 <code>memstore 是存放在内存</code>中，如果 regionserver 因为某种原因死了，会导致内存中数据丢失。所有<code>为了保证数据不丢失</code>，<code>hbase 将更新操作在写⼊ memstore 之前会写⼊到⼀个write ahead log(WAL)</code>中。WAL ⽂件是追加、顺序写⼊的，WAL 每个 regionserver 只有⼀个，同⼀个 regionserver 上所有 region 写⼊同⼀个的 WAL ⽂件。这样当某个 regionserver 失败时，可以通过 WAL ⽂件，将所有的操作顺序重新加载到 memstore 中。</li></ul> 
<h2><a id="49_HBase__489"></a>49.如何提⾼ HBase 客户端的读写性能？请举例说明</h2> 
<ul><li>1 <code>开启 bloomfilter 过滤器</code>，开启 bloomfilter ⽐没开启要快 3、4倍</li><li>2 Hbase 对于内存有特别的需求，在<code>硬件允许的情况下配⾜够多的内存给它</code></li><li>3 通过修改 hbase-env.sh 中的export HBASE_HEAPSIZE=3000 #这⾥默认为 1000m</li><li>4 <code>增⼤ RPC 数量</code> 
  <ul><li>通过修改 hbase-site.xml 中的 hbase.regionserver.handler.count 属性，可以适当的放⼤RPC 数量，默认值为 10 有点⼩。</li></ul> </li></ul> 
<h2><a id="50HBase__495"></a>50.HBase 集群安装注意事项?</h2> 
<ul><li>1.HBase 需要 HDFS 的⽀持，因此安装 HBase 前确保 Hadoop 集群安装完成；</li><li>2.HBase 需要 ZooKeeper 集群的⽀持，因此安装 HBase 前确保 ZooKeeper 集群安装完成；</li><li>3.注意 HBase 与 Hadoop 的版本兼容性；</li><li>4.注意 hbase-env.sh 配置⽂件和 hbase-site.xml 配置⽂件的正确配置；</li><li>5.注意 regionservers 配置⽂件的修改；</li><li>6.注意集群中的各个节点的时间必须同步，否则启动 HBase 集群将会报错；</li></ul> 
<h2><a id="51_region___502"></a>51.直接将时间戳作为⾏健，在写⼊单个 region 时候会发⽣热点问 题，为什么呢？</h2> 
<ul><li><code>region 中的 rowkey 是有序存储</code>，<code>若时间⽐较集中。就会存储到⼀个 region 中，这样⼀个 region 的数据变多，其它的 region 数据很少，加载数据就会很慢</code>，直到 region 分裂，此问题才会得到缓解。</li></ul> 
<h2><a id="52_HBase__region__region___504"></a>52.请描述如何解决 HBase 中 region 太⼩和 region 太⼤带来的冲 突？</h2> 
<ul><li><code>Region值过⼤</code>会发⽣多次<code> compaction</code>，将数据读⼀遍并重写⼀遍到 hdfs 上，占⽤ io</li><li><code>region值过⼩</code>会造成多次 <code>split</code>，region 会下线，影响访问服务</li><li>最佳的解决⽅法是调整 hbase.hregion.max.filesize 为 256m。</li></ul> 
<h2><a id="53_508"></a>53.解释⼀下布隆过滤器原理</h2> 
<ul><li>Bloom Filter 是⼀种空间效率很⾼的随机数据结构，它利⽤<code>位数组</code>很简洁地<code>表示⼀个集合</code>，并能<code>判断⼀个元素是否属于这个集合</code>。Bloom Filter 的这种⾼效是有⼀定代价的：在判断⼀个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter 不适合那些“零错误”的应⽤场合。⽽在<code>能容忍低错误率的应⽤场合</code>下，Bloom Filter 通过极少的错误换取了存储空间的极⼤节省。</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8682d517ad9cd22d4681e020bd23c469/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Doris--数据表建表语法&amp;数据划分（分区&amp;分桶）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/749c3966f54a168e52e4f6e1bba58f31/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spark--优化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>