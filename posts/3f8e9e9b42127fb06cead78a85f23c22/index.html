<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>PyAutoGUI——让所有GUI都自动化 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="PyAutoGUI——让所有GUI都自动化" />
<meta property="og:description" content="目录
1.简介
1.1 目的
1.2 例子
1.4 保护措施（Fail-Safes）
2 安装与依赖
3.速查表（小抄，Cheat Sheet）
3.1 常用函数
3.2 保护措施
3.3 鼠标函数
3.4 键盘函数
3.5 消息弹窗函数
3.6 截屏函数
4 常用函数
5 鼠标控制函数
5.1 屏幕与鼠标位置
5.2 鼠标行为
5.3 鼠标拖拽
5.4 缓动/渐变（Tween / Easing）函数
5.5 鼠标单击
5.6 鼠标按下和松开函数
5.7 滚轮滚动函数
6 键盘控制函数
6.1 typewrite()输入函数
6.2 press()，keyDown()和keyUp()函数
6.3 hotkey()函数
6.4 KEYBOARD_KEYS
7 消息弹窗函数
7.1 alert()函数
7.2 The confirm() Function
7.3 The prompt() Function
7.4 The password() Function" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/3f8e9e9b42127fb06cead78a85f23c22/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-23T14:32:06+08:00" />
<meta property="article:modified_time" content="2022-11-23T14:32:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">PyAutoGUI——让所有GUI都自动化</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#1.%E7%AE%80%E4%BB%8B" rel="nofollow">1.简介</a></p> 
<p id="1.1-%E7%9B%AE%E7%9A%84-toc" style="margin-left:40px;"><a href="#1.1-%E7%9B%AE%E7%9A%84" rel="nofollow">1.1 目的</a></p> 
<p id="1.2-%E4%BE%8B%E5%AD%90-toc" style="margin-left:40px;"><a href="#1.2-%E4%BE%8B%E5%AD%90" rel="nofollow">1.2 例子</a></p> 
<p id="1.4-%E4%BF%9D%E6%8A%A4%E6%8E%AA%E6%96%BD%EF%BC%88Fail-Safes%EF%BC%89-toc" style="margin-left:40px;"><a href="#1.4-%E4%BF%9D%E6%8A%A4%E6%8E%AA%E6%96%BD%EF%BC%88Fail-Safes%EF%BC%89" rel="nofollow">1.4 保护措施（Fail-Safes）</a></p> 
<p id="2-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BE%9D%E8%B5%96-toc" style="margin-left:0px;"><a href="#2-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BE%9D%E8%B5%96" rel="nofollow">2 安装与依赖</a></p> 
<p id="3.%E9%80%9F%E6%9F%A5%E8%A1%A8%EF%BC%88%E5%B0%8F%E6%8A%84%EF%BC%8CCheat-Sheet%EF%BC%89-toc" style="margin-left:40px;"><a href="#3.%E9%80%9F%E6%9F%A5%E8%A1%A8%EF%BC%88%E5%B0%8F%E6%8A%84%EF%BC%8CCheat-Sheet%EF%BC%89" rel="nofollow">3.速查表（小抄，Cheat Sheet）</a></p> 
<p id="3.1-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.1-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0" rel="nofollow">3.1 常用函数</a></p> 
<p id="3.2-%E4%BF%9D%E6%8A%A4%E6%8E%AA%E6%96%BD-toc" style="margin-left:80px;"><a href="#3.2-%E4%BF%9D%E6%8A%A4%E6%8E%AA%E6%96%BD" rel="nofollow">3.2 保护措施</a></p> 
<p id="3.3-%E9%BC%A0%E6%A0%87%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.3-%E9%BC%A0%E6%A0%87%E5%87%BD%E6%95%B0" rel="nofollow">3.3 鼠标函数</a></p> 
<p id="3.4-%E9%94%AE%E7%9B%98%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.4-%E9%94%AE%E7%9B%98%E5%87%BD%E6%95%B0" rel="nofollow">3.4 键盘函数</a></p> 
<p id="3.5-%E6%B6%88%E6%81%AF%E5%BC%B9%E7%AA%97%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.5-%E6%B6%88%E6%81%AF%E5%BC%B9%E7%AA%97%E5%87%BD%E6%95%B0" rel="nofollow">3.5 消息弹窗函数</a></p> 
<p id="3.6-%E6%88%AA%E5%B1%8F%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.6-%E6%88%AA%E5%B1%8F%E5%87%BD%E6%95%B0" rel="nofollow">3.6 截屏函数</a></p> 
<p id="4-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#4-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0" rel="nofollow">4 常用函数</a></p> 
<p id="5-%E9%BC%A0%E6%A0%87%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#5-%E9%BC%A0%E6%A0%87%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0" rel="nofollow">5 鼠标控制函数</a></p> 
<p id="5.1-%E5%B1%8F%E5%B9%95%E4%B8%8E%E9%BC%A0%E6%A0%87%E4%BD%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#5.1-%E5%B1%8F%E5%B9%95%E4%B8%8E%E9%BC%A0%E6%A0%87%E4%BD%8D%E7%BD%AE" rel="nofollow">5.1 屏幕与鼠标位置</a></p> 
<p id="5.2-%E9%BC%A0%E6%A0%87%E8%A1%8C%E4%B8%BA-toc" style="margin-left:40px;"><a href="#5.2-%E9%BC%A0%E6%A0%87%E8%A1%8C%E4%B8%BA" rel="nofollow">5.2 鼠标行为</a></p> 
<p id="5.3-%E9%BC%A0%E6%A0%87%E6%8B%96%E6%8B%BD-toc" style="margin-left:40px;"><a href="#5.3-%E9%BC%A0%E6%A0%87%E6%8B%96%E6%8B%BD" rel="nofollow">5.3 鼠标拖拽</a></p> 
<p id="5.4-%E7%BC%93%E5%8A%A8/%E6%B8%90%E5%8F%98%EF%BC%88Tween-/-Easing%EF%BC%89%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#5.4-%E7%BC%93%E5%8A%A8/%E6%B8%90%E5%8F%98%EF%BC%88Tween-/-Easing%EF%BC%89%E5%87%BD%E6%95%B0" rel="nofollow">5.4 缓动/渐变（Tween / Easing）函数</a></p> 
<p id="5.5-%E9%BC%A0%E6%A0%87%E5%8D%95%E5%87%BB-toc" style="margin-left:40px;"><a href="#5.5-%E9%BC%A0%E6%A0%87%E5%8D%95%E5%87%BB" rel="nofollow">5.5 鼠标单击</a></p> 
<p id="5.6-%E9%BC%A0%E6%A0%87%E6%8C%89%E4%B8%8B%E5%92%8C%E6%9D%BE%E5%BC%80%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#5.6-%E9%BC%A0%E6%A0%87%E6%8C%89%E4%B8%8B%E5%92%8C%E6%9D%BE%E5%BC%80%E5%87%BD%E6%95%B0" rel="nofollow">5.6 鼠标按下和松开函数</a></p> 
<p id="5.7-%E6%BB%9A%E8%BD%AE%E6%BB%9A%E5%8A%A8%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#5.7-%E6%BB%9A%E8%BD%AE%E6%BB%9A%E5%8A%A8%E5%87%BD%E6%95%B0" rel="nofollow">5.7 滚轮滚动函数</a></p> 
<p id="6-%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#6-%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0" rel="nofollow">6 键盘控制函数</a></p> 
<p id="6.1-typewrite()%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#6.1-typewrite%28%29%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0" rel="nofollow">6.1 typewrite()输入函数</a></p> 
<p id="6.2-press()%EF%BC%8CkeyDown()%E5%92%8CkeyUp()%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#6.2-press%28%29%EF%BC%8CkeyDown%28%29%E5%92%8CkeyUp%28%29%E5%87%BD%E6%95%B0" rel="nofollow">6.2 press()，keyDown()和keyUp()函数</a></p> 
<p id="6.3-hotkey()%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#6.3-hotkey%28%29%E5%87%BD%E6%95%B0" rel="nofollow">6.3 hotkey()函数</a></p> 
<p id="6.4-KEYBOARD_KEYS-toc" style="margin-left:40px;"><a href="#6.4-KEYBOARD_KEYS" rel="nofollow">6.4 KEYBOARD_KEYS</a></p> 
<p id="7-%E6%B6%88%E6%81%AF%E5%BC%B9%E7%AA%97%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#7-%E6%B6%88%E6%81%AF%E5%BC%B9%E7%AA%97%E5%87%BD%E6%95%B0" rel="nofollow">7 消息弹窗函数</a></p> 
<p id="7.1-alert()%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#7.1-alert%28%29%E5%87%BD%E6%95%B0" rel="nofollow">7.1 alert()函数</a></p> 
<p id="7.2-The-confirm()-Function-toc" style="margin-left:40px;"><a href="#7.2-The-confirm%28%29-Function" rel="nofollow">7.2 The confirm() Function</a></p> 
<p id="7.3-The-prompt()-Function-toc" style="margin-left:40px;"><a href="#7.3-The-prompt%28%29-Function" rel="nofollow">7.3 The prompt() Function</a></p> 
<p id="7.4-The-password()-Function-toc" style="margin-left:40px;"><a href="#7.4-The-password%28%29-Function" rel="nofollow">7.4 The password() Function</a></p> 
<p id="8-%E6%88%AA%E5%B1%8F%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#8-%E6%88%AA%E5%B1%8F%E5%87%BD%E6%95%B0" rel="nofollow">8 截屏函数</a></p> 
<p id="8.1-Ubuntu%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:40px;"><a href="#8.1-Ubuntu%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">8.1 Ubuntu注意事项</a></p> 
<p id="8.2-screenshot()%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#8.2-screenshot%28%29%E5%87%BD%E6%95%B0" rel="nofollow">8.2 screenshot()函数</a></p> 
<p id="8.3-%E5%AE%9A%E4%BD%8D%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#8.3-%E5%AE%9A%E4%BD%8D%E5%87%BD%E6%95%B0" rel="nofollow">8.3 定位函数</a></p> 
<p id="8.3.1-%E7%81%B0%E5%BA%A6%E5%80%BC%E5%8C%B9%E9%85%8D-toc" style="margin-left:80px;"><a href="#8.3.1-%E7%81%B0%E5%BA%A6%E5%80%BC%E5%8C%B9%E9%85%8D" rel="nofollow">8.3.1 灰度值匹配</a></p> 
<p id="8.3.2-%E5%83%8F%E7%B4%A0%E5%8C%B9%E9%85%8D-toc" style="margin-left:80px;"><a href="#8.3.2-%E5%83%8F%E7%B4%A0%E5%8C%B9%E9%85%8D" rel="nofollow">8.3.2 像素匹配</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>本教程译自大神<a href="http://inventwithpython.com/" rel="nofollow" title="Al Sweigart">Al Sweigart</a>的<a href="https://pyautogui.readthedocs.org/" rel="nofollow" title="PyAutoGUI">PyAutoGUI</a>项目，Python自动化工具，更适合处理GUI任务，网页任务推荐：</p> 
<ul><li><a href="https://selenium-python.readthedocs.org/" rel="nofollow" title="Selenium">Selenium</a>+Firefox记录（Chromedriver和Phantomjs也很给力，Phantomjs虽然是无头浏览器，但有时定位不准），然后用Python写单元测试</li><li><a href="http://www.python-requests.org/en/latest/" rel="nofollow" title="request">request</a>处理get/post请求写一堆代码自动化处理，都在后台运行，不用运行浏览器，非常适合处理表单</li></ul> 
<p>没有<a href="http://www.sikuli.org/" rel="nofollow" title="sikuli">sikuli</a>功能多，但是Python让生活更简单，<a href="http://cn.pycon.org/2015/" rel="nofollow" title="人生苦短，Python当歌">人生苦短，Python当歌</a>。</p> 
<p>同时推荐一本Python网络数据采集（图灵社区取的名字^_^）的基础书籍<a href="http://shop.oreilly.com/product/0636920034391.do" rel="nofollow" title="Ryan Mitchell的《Web Scraping with Python》">Ryan Mitchell的《Web Scraping with Python》</a>，可以和PyAutoGUI结合使用。</p> 
<p>tl;dr</p> 
<p>2015-08-17：输入中文bug没有解决，目前的解决方案是Python 2.X环境下安装<a href="https://github.com/asweigart/pyperclip" title="pyperclip">pyperclip</a>和pyautogui，用复制粘贴来实现。</p> 
<p>In [ ]:</p> 
<pre>import pyperclip
import pyautogui

#  PyAutoGUI中文输入需要用粘贴实现
#  Python 2版本的pyperclip提供中文复制
def paste(foo):
    pyperclip.copy(foo)
    pyautogui.hotkey('ctrl', 'v')

foo = u'学而时习之'
#  移动到文本框
pyautogui.click(130,30)
paste(foo)
</pre> 
<h2 id="1.%E7%AE%80%E4%BB%8B">1.简介</h2> 
<h3 id="1.1-%E7%9B%AE%E7%9A%84">1.1 目的</h3> 
<p>PyAutoGUI是一个纯Python的GUI自动化工具，其目的是可以用程序自动控制鼠标和键盘操作，多平台支持（Windows，OS X，Linux）。可以用<code>pip</code>安装，Github上有<a href="https://github.com/asweigart/pyautogui" title="源代码">源代码</a>。</p> 
<p>下面的代码让鼠标移到屏幕中央。</p> 
<p>In [ ]:</p> 
<pre>import pyautogui
screenWidth, screenHeight = pyautogui.size()
pyautogui.moveTo(screenWidth / 2, screenHeight / 2)
</pre> 
<p>PyAutoGUI可以模拟鼠标的移动、点击、拖拽，键盘按键输入、按住操作，以及鼠标+键盘的热键同时按住等操作，可以说手能动的都可以。</p> 
<h3 id="1.2-%E4%BE%8B%E5%AD%90">1.2 例子</h3> 
<p>In [ ]:</p> 
<pre>import pyautogui
screenWidth, screenHeight = pyautogui.size()
currentMouseX, currentMouseY = pyautogui.position()
pyautogui.moveTo(100, 150)
pyautogui.click()
#  鼠标向下移动10像素
pyautogui.moveRel(None, 10)
pyautogui.doubleClick()
#  用缓动/渐变函数让鼠标2秒后移动到(500,500)位置
#  use tweening/easing function to move mouse over 2 seconds.
pyautogui.moveTo(1800, 500, duration=2, tween=pyautogui.easeInOutQuad)
#  在每次输入之间暂停0.25秒
pyautogui.typewrite('Hello world!', interval=0.25)
pyautogui.press('esc')
pyautogui.keyDown('shift')
pyautogui.press(['left', 'left', 'left', 'left', 'left', 'left'])
pyautogui.keyUp('shift')
pyautogui.hotkey('ctrl', 'c')
</pre> 
<p>In [ ]:</p> 
<pre>distance = 200
while distance &gt; 0:
    pyautogui.dragRel(distance, 0, duration=0.5) # 向右
    distance -= 5
    pyautogui.dragRel(0, distance, duration=0.5) # 向下
    pyautogui.draIn gRel(-distance, 0, duration=0.5) # 向左
    distance -= 5
    pyautogui.dragRel(0, -distance, duration=0.5) # 向上
</pre> 
<h3 id="1.4-%E4%BF%9D%E6%8A%A4%E6%8E%AA%E6%96%BD%EF%BC%88Fail-Safes%EF%BC%89">1.4 保护措施（Fail-Safes）</h3> 
<p>就像《魔法师的学徒》(Sorcerer’s Apprentice)会担水的扫帚，可以担水，却无力阻止水漫浴室。你的程序也可能会失控（即使是按照你的意思执行的），那时就需要中断。如果鼠标还在自动操作，就很难在程序窗口关闭它。</p> 
<p>为了能够及时中断，PyAutoGUI提供了一个保护措施。当<code>pyautogui.FAILSAFE = True</code>时，如果把鼠标光标在屏幕左上角，PyAutoGUI函数就会产生<code>pyautogui.FailSafeException</code>异常。如果失控了，需要中断PyAutoGUI函数，就把鼠标光标在屏幕左上角。要禁用这个特性，就把<code>FAILSAFE</code>设置成<code>False</code>：</p> 
<p>In [ ]:</p> 
<pre>import pyautogui
pyautogui.FAILSAFE = False
</pre> 
<p>通过把<code>pyautogui.PAUSE</code>设置成<code>float</code>或<code>int</code>时间（秒），可以为所有的PyAutoGUI函数增加延迟。默认延迟时间是0.1秒。在函数循环执行的时候，这样做可以让PyAutoGUI运行的慢一点，非常有用。例如：</p> 
<p>In [ ]:</p> 
<pre>import pyautogui
pyautogui.PAUSE = 2.5
pyautogui.moveTo(100,100); pyautogui.click()
</pre> 
<p>所有的PyAutoGUI函数在延迟完成前都处于阻塞状态（block）。（未来计划增加一个可选的非阻塞模式来调用函数。）</p> 
<p><strong>建议<code>PAUSE</code>和<code>FAILSAFE</code>一起使用。</strong></p> 
<h2 id="2-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BE%9D%E8%B5%96">2 安装与依赖</h2> 
<p>PyAutoGUI支持Python 2.x和Python 3.x</p> 
<ul><li>Windows：PyAutoGUI没有任何依赖，因为它用Python的<code>ctypes</code>模块所以不需要<code>pywin32</code></li></ul> 
<pre><code>pip3 install pyautogui
</code></pre> 
<ul><li>OS X：PyAutoGUI需要<a href="http://pythonhosted.org/pyobjc/install.html" rel="nofollow" title="PyObjC">PyObjC</a>运行AppKit和Quartz模块。这个模块在PyPI上的按住顺序是<code>pyobjc-core</code>和<code>pyobjc</code></li></ul> 
<pre><code>sudo pip3 install pyobjc-core
sudo pip3 install pyobjc
sudo pip3 install pyautogui
</code></pre> 
<ul><li>Linux：PyAutoGUI需要<code>python-xlib</code>（Python 2）、<code>python3-Xlib</code>（Python 3）</li></ul> 
<pre><code>sudo pip3 install python3-xlib
sudo apt-get scrot
sudo apt-get install python-tk
sudo apt-get install python3-dev
sudo pip3 install pyautogui```
</code></pre> 
<h3 id="3.%E9%80%9F%E6%9F%A5%E8%A1%A8%EF%BC%88%E5%B0%8F%E6%8A%84%EF%BC%8CCheat-Sheet%EF%BC%89">3.速查表（小抄，Cheat Sheet）</h3> 
<h4 id="3.1-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">3.1 常用函数</h4> 
<p>In [ ]:</p> 
<pre>import pyautogui
#  当前鼠标的坐标
pyautogui.position()
</pre> 
<p>Out[ ]:</p> 
<pre>(123, 372)</pre> 
<p>In [ ]:</p> 
<pre>#  当前屏幕的分辨率（宽度和高度）
pyautogui.size()
</pre> 
<p>Out[ ]:</p> 
<pre>(1920, 1080)</pre> 
<p>In [ ]:</p> 
<pre>#  (x,y)是否在屏幕上
x, y = 122, 244
pyautogui.onScreen(x, y)
</pre> 
<p>Out[ ]:</p> 
<pre>True</pre> 
<h4 id="3.2-%E4%BF%9D%E6%8A%A4%E6%8E%AA%E6%96%BD">3.2 保护措施</h4> 
<p>PyAutoGUI函数增加延迟为2.5秒：</p> 
<p>In [ ]:</p> 
<pre>import pyautogui
pyautogui.PAUSE = 2.5
</pre> 
<p>当pyautogui.FAILSAFE = True时，如果把鼠标光标在屏幕左上角，PyAutoGUI函数就会产生pyautogui.FailSafeException异常。</p> 
<p>In [ ]:</p> 
<pre>import pyautogui
pyautogui.FAILSAFE = True
</pre> 
<h4 id="3.3-%E9%BC%A0%E6%A0%87%E5%87%BD%E6%95%B0">3.3 鼠标函数</h4> 
<p>坐标系的原点是左上角。X轴（水平）坐标向右增大，Y轴（竖直）坐标向下增大。</p> 
<p>In [ ]:</p> 
<pre>num_seconds = 1.2
#  用num_seconds秒的时间把光标移动到(x, y)位置
pyautogui.moveTo(x, y, duration=num_seconds)
#  用num_seconds秒的时间把光标的X轴（水平）坐标移动xOffset，
#  Y轴（竖直）坐标向下移动yOffset。
xOffset, yOffset = 50, 100
pyautogui.moveRel(xOffset, yOffset, duration=num_seconds)
</pre> 
<p><code>click()</code>函数就是让鼠标点击，默认是单击左键，参数可以设置：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.click(x=moveToX, y=moveToY, clicks=num_of_clicks, interval=secs_between_clicks, button='left')
</pre> 
<p>其中，<code>button</code>属性可以设置成<code>left</code>，<code>middle</code>和<code>right</code>。</p> 
<p>所有的点击都可以用这个函数，不过下面的函数可读性更好：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.rightClick(x=moveToX, y=moveToY)
pyautogui.middleClick(x=moveToX, y=moveToY)
pyautogui.doubleClick(x=moveToX, y=moveToY)
pyautogui.tripleClick(x=moveToX, y=moveToY)
</pre> 
<p><code>scroll</code>函数控制鼠标滚轮的滚动，<code>amount_to_scroll</code>参数表示滚动的格数。正数则页面向上滚动，负数则向下滚动：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.scroll(clicks=amount_to_scroll, x=moveToX, y=moveToY)
</pre> 
<p>每个按键按下和松开两个事件可以分开处理：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.mouseDown(x=moveToX, y=moveToY, button='left')
pyautogui.mouseUp(x=moveToX, y=moveToY, button='left')
</pre> 
<h4 id="3.4-%E9%94%AE%E7%9B%98%E5%87%BD%E6%95%B0">3.4 键盘函数</h4> 
<p>键盘上可以按的键都可以调用：</p> 
<p>In [ ]:</p> 
<pre>#  每次键入的时间间隔
secs_between_keys = 0.1
pyautogui.typewrite('Hello world!\n', interval=secs_between_keys)
</pre> 
<p>多个键也可以：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.typewrite(['a', 'b', 'c', 'left', 'backspace', 'enter', 'f1'], interval=secs_between_keys)
</pre> 
<p>按键名称列表：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.KEYBOARD_KEYS[:10]
</pre> 
<p>Out[ ]:</p> 
<pre>['\t', '\n', '\r', ' ', '!', '"', '#', '$', '%', '&amp;']</pre> 
<p>键盘的一些热键像<code>Ctrl-S</code>或<code>Ctrl-Shift-1</code>都可以用<code>hotkey()</code>函数来实现：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.hotkey('ctrl', 'a') # 全选
pyautogui.hotkey('ctrl', 'c') # 复制
pyautogui.hotkey('ctrl', 'v') # 粘贴
</pre> 
<p>每个按键的按下和松开也可以单独调用：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.keyDown(key_name)
pyautogui.keyUp(key_name)
</pre> 
<h4 id="3.5-%E6%B6%88%E6%81%AF%E5%BC%B9%E7%AA%97%E5%87%BD%E6%95%B0">3.5 消息弹窗函数</h4> 
<p>如果你需要消息弹窗，通过单击OK暂停程序，或者向用户显示一些信息，消息弹窗函数就会有类似JavaScript的功能：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.alert('这个消息弹窗是文字+OK按钮')
pyautogui.confirm('这个消息弹窗是文字+OK+Cancel按钮')
pyautogui.prompt('这个消息弹窗是让用户输入字符串，单击OK')
</pre> 
<p>Out[ ]:</p> 
<pre>''</pre> 
<p>在<code>prompt()</code>函数中，如果用户什么都不输入，就会返回<code>None</code>。</p> 
<h4 id="3.6-%E6%88%AA%E5%B1%8F%E5%87%BD%E6%95%B0">3.6 截屏函数</h4> 
<p>PyAutoGUI用Pillow/PIL库实现图片相关的识别和操作。</p> 
<p>在Linux里面，你必须执行<code>sudo apt-get install scrot</code>来使用截屏特性。</p> 
<p>In [ ]:</p> 
<pre>#  返回一个Pillow/PIL的Image对象
pyautogui.screenshot()
pyautogui.screenshot('foo.png')
</pre> 
<p>如果你有一个图片文件想在上面做点击操作，你可以用<code>locateOnScreen()</code>函数来定位。</p> 
<p>In [ ]:</p> 
<pre>#  返回(最左x坐标，最顶y坐标，宽度，高度)
pyautogui.locateOnScreen('pyautogui/looks.png')
</pre> 
<p>Out[ ]:</p> 
<pre>(0, 1040, 48, 40)</pre> 
<p><code>locateAllOnScreen()</code>函数会寻找所有相似图片，返回一个生成器：</p> 
<p>In [ ]:</p> 
<pre>for i in pyautogui.locateAllOnScreen('pyautogui/looks.png'):
    print(i)
</pre> 
<pre>(0, 1040, 48, 40)
</pre> 
<p>In [ ]:</p> 
<pre>list(pyautogui.locateAllOnScreen('pyautogui/looks.png'))
</pre> 
<p>Out[ ]:</p> 
<pre>[(0, 1040, 48, 40)]</pre> 
<p><code>locateCenterOnScreen()</code>函数会返回图片在屏幕上的中心XY轴坐标值：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.locateCenterOnScreen('pyautogui/looks.png')
</pre> 
<p>Out[ ]:</p> 
<pre>(24, 1060)</pre> 
<p>如果没找到图片会返回<code>None</code>。</p> 
<blockquote> 
 <p>定位比较慢，一般得用1~2秒</p> 
</blockquote> 
<h2 id="4-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">4 常用函数</h2> 
<ul><li><code>position()</code>：返回整数元组(x, y)，分别表示鼠标光标所在位置的XY轴坐标</li><li><code>size()</code>：返回显示器的尺寸整数元组(x, y)。未来将加入多屏支持</li></ul> 
<h2 id="5-%E9%BC%A0%E6%A0%87%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0">5 鼠标控制函数</h2> 
<h3 id="5.1-%E5%B1%8F%E5%B9%95%E4%B8%8E%E9%BC%A0%E6%A0%87%E4%BD%8D%E7%BD%AE">5.1 屏幕与鼠标位置</h3> 
<p>屏幕位置使用X和Y轴的笛卡尔坐标系。原点<code>(0,0)</code>在左上角，分别向右、向下增大。</p> 
<p>如果屏幕像素是1920×1080，那么右下角的坐标是<code>(1919, 1079)</code>。</p> 
<p>分辨率大小可以通过<code>size()</code>函数返回整数元组。光标的位置用<code>position()</code>返回。例如：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.size()
</pre> 
<p>Out[ ]:</p> 
<pre>(1920, 1080)</pre> 
<p>In [ ]:</p> 
<pre>pyautogui.position()
</pre> 
<p>Out[ ]:</p> 
<pre>(272, 688)</pre> 
<p>下面是Python 3版本的光标位置记录程序：</p> 
<p>In [ ]:</p> 
<pre># ! python 3
import pyautogui
print('Press Ctrl-C to quit')
try:
    while True:
        x, y = pyautogui.position()
        positionStr = 'X: {} Y: {}'.format(*[str(x).rjust(4) for x in [x, y]])
        print(positionStr, end='')
        print('\b' * len(positionStr), end='', flush=True)
except KeyboardInterrupt:
    print('\n')
</pre> 
<p>Python 2版本是：</p> 
<p>In [ ]:</p> 
<pre># ! python
import pyautogui, sys
print('Press Ctrl-C to quit.')
try:
    while True:
        x, y = pyautogui.position()
        positionStr = 'X: ' + str(x).rjust(4) + ' Y: ' + str(y).rjust(4)
        print positionStr,
        print '\b' * (len(positionStr) + 2),
        sys.stdout.flush()
except KeyboardInterrupt:
    print '\n'
</pre> 
<p>要检查XY坐标是否在屏幕上，需要用<code>onScreen()</code>函数来检验，如果在屏幕上返回<code>True</code>：</p> 
<p>In [ ]:</p> 
<pre>import pyautogui
pyautogui.onScreen(0, 0)
</pre> 
<p>Out[ ]:</p> 
<pre>True</pre> 
<p>In [ ]:</p> 
<pre>pyautogui.onScreen(0, -1)
</pre> 
<p>Out[ ]:</p> 
<pre>False</pre> 
<p>In [ ]:</p> 
<pre>pyautogui.onScreen(0, 2080)
</pre> 
<p>Out[ ]:</p> 
<pre>False</pre> 
<p>In [ ]:</p> 
<pre>pyautogui.onScreen(1920, 1080)
</pre> 
<p>Out[ ]:</p> 
<pre>False</pre> 
<p>In [ ]:</p> 
<pre>pyautogui.onScreen(1919, 1079)
</pre> 
<p>Out[ ]:</p> 
<pre>True</pre> 
<h3 id="5.2-%E9%BC%A0%E6%A0%87%E8%A1%8C%E4%B8%BA">5.2 鼠标行为</h3> 
<p><code>moveTo()</code>函数会把鼠标光标移动到指定的XY轴坐标处。如果传入<code>None</code>值，则表示使用当前光标的对象轴坐标值。</p> 
<p>In [ ]:</p> 
<pre>pyautogui.moveTo(100, 200)     # 光标移动到(100, 200)位置
pyautogui.moveTo(None, 500)   # 光标移动到(100, 500)位置
pyautogui.moveTo(600, None)   # 光标移动到(600, 500)位置
</pre> 
<p>一般鼠标光标都是瞬间移动到指定的位置，如果你想让鼠标移动的慢点，可以设置持续时间：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.moveTo(100, 200, duration=2)     # 用2秒把光标移动到(100, 200)位置
</pre> 
<p>默认的持续时间<code>pyautogui.MINIMUM_DURATION</code>是0.1秒，如果你设置的时间比默认值还短，那么就会瞬间执行。</p> 
<p>如果你想让光标以当前位置为原点，进行相对移动，就用<code>pyautogui.moveRel()</code>函数。例如：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.moveTo(100, 200) #把光标移动到(100, 200)位置
pyautogui.moveRel(0, 50)   #向下移动50
pyautogui.moveRel(30, 0, 2)   #向右移动30
pyautogui.moveRel(30, None)   #向右移动30
</pre> 
<h3 id="5.3-%E9%BC%A0%E6%A0%87%E6%8B%96%E6%8B%BD">5.3 鼠标拖拽</h3> 
<p>PyAutoGUI的<code>dragTo()</code>和<code>dragRel()</code>函数与<code>moveTo()</code>和<code>moveRel()</code>函数类似。另外，他们有一个<code>button</code>参数可以设置成<code>left</code>，<code>middle</code>和<code>right</code>三个键。例如：</p> 
<p>In [ ]:</p> 
<pre>#  按住鼠标左键，把鼠标拖拽到(100, 200)位置
pyautogui.dragTo(100, 200, button='left')
#  按住鼠标左键，用2秒钟把鼠标拖拽到(300, 400)位置
pyautogui.dragTo(300, 400, 2, button='left')
#  按住鼠标右键，用2秒钟把鼠标拖拽到(30,0)位置
pyautogui.dragTo(30, 0, 2, button='right')
</pre> 
<h3 id="5.4-%E7%BC%93%E5%8A%A8/%E6%B8%90%E5%8F%98%EF%BC%88Tween-/-Easing%EF%BC%89%E5%87%BD%E6%95%B0">5.4 缓动/渐变（Tween / Easing）函数</h3> 
<p>缓动/渐变函数的作用是让光标的移动更炫。如果你不需要用到的话，你可以忽略这些。</p> 
<p>缓动/渐变函数可以改变光标移动过程的速度和方向。通常鼠标是匀速直线运动，这就是线性缓动/渐变函数。PyAutoGUI有30种缓动/渐变函数，可以通过<code>pyautogui.ease*?</code>查看。其中，<code>pyautogui.easeInQuad()</code>函数可以用于<code>moveTo()</code>，<code>moveRel()</code>，<code>dragTo()</code>和<code>dragRel()</code>函数，光标移动呈现先慢后快的效果，整个过程的时间还是和原来一样。而<code>pyautogui.easeOutQuad</code>函数的效果相反：光标开始移动很快，然后慢慢减速。<code>pyautogui.easeOutElastic</code>是弹簧效果，首先越过终点，然后再反弹回来。例如：</p> 
<p>In [ ]:</p> 
<pre>#  开始很慢，不断加速
pyautogui.moveTo(100, 100, 2, pyautogui.easeInQuad)
#  开始很快，不断减速
pyautogui.moveTo(100, 100, 2, pyautogui.easeOutQuad)
#  开始和结束都快，中间比较慢
pyautogui.moveTo(100, 100, 2, pyautogui.easeInOutQuad)
#  一步一徘徊前进
pyautogui.moveTo(100, 100, 2, pyautogui.easeInBounce)
#  徘徊幅度更大，甚至超过起点和终点
pyautogui.moveTo(100, 100, 2, pyautogui.easeInElastic)
</pre> 
<p>这些效果函数是模仿Al Sweigart的<a href="https://github.com/asweigart/pytweening" title="PyTweening">PyTweening</a>模块，可以直接使用，不需要额外安装。</p> 
<p>如果你想创建自己的效果，也可以定义一个函数，其参数是(0.0,1.0)，表示起点和终点，返回值是介于[0.0,1.0]之间的数。</p> 
<h3 id="5.5-%E9%BC%A0%E6%A0%87%E5%8D%95%E5%87%BB">5.5 鼠标单击</h3> 
<p><code>click()</code>函数模拟单击鼠标左键一次的行为。例如：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.click()
</pre> 
<p>如果单机之前要先移动，可以把目标的XY坐标值传入函数：</p> 
<p>In [ ]:</p> 
<pre>#  先移动到(100, 200)再单击
pyautogui.click(x=100, y=200, duration=2)
</pre> 
<p>可以通过<code>button</code>参数设置<code>left</code>，<code>middle</code>和<code>right</code>三个键。例如：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.click(button='right')
</pre> 
<p>要做多次单击可以设置<code>clicks</code>参数，还有<code>interval</code>参数可以设置每次单击之间的时间间隔。例如：</p> 
<p>In [ ]:</p> 
<pre>#  双击左键
pyautogui.click(clicks=2)
#  两次单击之间停留0.25秒
pyautogui.click(clicks=2, interval=0.25)
#  三击右键
pyautogui.click(button='right', clicks=2, interval=0.25)
</pre> 
<p>为了操作方便，PyAutoGUI提供了<code>doubleClick()</code>，<code>tripleClick()</code>和<code>rightClick()</code>来实现双击、三击和右击操作。</p> 
<h3 id="5.6-%E9%BC%A0%E6%A0%87%E6%8C%89%E4%B8%8B%E5%92%8C%E6%9D%BE%E5%BC%80%E5%87%BD%E6%95%B0">5.6 鼠标按下和松开函数</h3> 
<p><code>mouseDown()</code>和<code>mouseUp()</code>函数可以实现鼠标按下和鼠标松开的操作。两者参数相同，有<code>x</code>，<code>y</code>和<code>button</code>。例如：</p> 
<p>In [ ]:</p> 
<pre>#  鼠标左键按下再松开
pyautogui.mouseDown(); pyautogui.mouseUp() 
#  按下鼠标右键
pyautogui.mouseDown(button='right') 
#  移动到(100, 200)位置，然后松开鼠标右键
pyautogui.mouseUp(button='right', x=100, y=200) 
</pre> 
<h3 id="5.7-%E6%BB%9A%E8%BD%AE%E6%BB%9A%E5%8A%A8%E5%87%BD%E6%95%B0">5.7 滚轮滚动函数</h3> 
<p>鼠标滚轮滚动可以用<code>scroll()</code>函数和<code>clicks</code>次数参数来模拟。不同平台上的<code>clicks</code>次数不太一样。还有<code>x</code>和<code>y</code>参数可以在滚动之前定位到(x, y)位置。例如：</p> 
<p>In [ ]:</p> 
<pre>#  向上滚动10格
pyautogui.scroll(10)
#  向下滚动10格
pyautogui.scroll(-10)
#  移动到(100, 100)位置再向上滚动10格
pyautogui.scroll(10, x=100, y=100)
</pre> 
<p>在OS X和Linux平台上，PyAutoGUI还可以用<code>hscroll()</code>实现水平滚动。例如：</p> 
<p>In [ ]:</p> 
<pre>#  向右滚动10格
pyautogui.hscroll(10)
#  向左滚动10格
pyautogui.hscroll(-10)
</pre> 
<p><code>scroll()</code>函数是<code>vscroll()</code>的一个包装（<code>wrapper</code>），执行竖直滚动。</p> 
<h3 id="6-%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0">6 键盘控制函数</h3> 
<h3 id="6.1-typewrite()%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0">6.1 <code>typewrite()</code>输入函数</h3> 
<p>键盘控制的主要函数就是<code>typewrite()</code>。这个函数可以实现字符输入。要在两次输入间增加时间间隔，可以用<code>interval</code>参数。例如：</p> 
<p>In [ ]:</p> 
<pre>#  输入Hello world!
pyautogui.typewrite('Hello world!')
#  每次输入间隔0.25秒，输入Hello world!
pyautogui.typewrite('Hello world!', interval=0.25)
</pre> 
<p><code>typewrite()</code>函数只能用于单个字符键，不能按SHITF和F1这些功能键。</p> 
<h3 id="6.2-press()%EF%BC%8CkeyDown()%E5%92%8CkeyUp()%E5%87%BD%E6%95%B0">6.2 <code>press()</code>，<code>keyDown()</code>和<code>keyUp()</code>函数</h3> 
<p>要按那些功能键，可以用<code>press()</code>函数把<code>pyautogui.KEYBOARD_KEYS</code>里面按键对应的字符串输入进去。例如：</p> 
<p>In [ ]:</p> 
<pre>#  ENTER键
pyautogui.press('enter')
#  F1键
pyautogui.press('f1')
#  左方向键
pyautogui.press('left')
</pre> 
<p><code>press()</code>函数其实是<code>keyDown()</code>和<code>keyUp()</code>函数的包装，模拟的按下然后松开两个动作。这两个函数可以单独调用。例如，按下<code>shift</code>键的同时按3次左方向键：</p> 
<p>In [ ]:</p> 
<pre>#  按下`shift`键
pyautogui.keyDown('shift')
pyautogui.press('left')
pyautogui.press('left')
pyautogui.press('left')
#  松开`shift`键
pyautogui.keyUp('shift')
</pre> 
<p>和<code>typewrite()</code>函数一样，可以用数组把一组键传入<code>press()</code>。例如：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.press(['left', 'left', 'left'])
</pre> 
<h3 id="6.3-hotkey()%E5%87%BD%E6%95%B0">6.3 <code>hotkey()</code>函数</h3> 
<p>为了更高效的输入热键，PyAutoGUI提供了<code>hotkey()</code>函数来绑定若干按键：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.hotkey('ctrl', 'shift', 'ese')
</pre> 
<p>等价于：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.keyDown('ctrl')
pyautogui.keyDown('shift')
pyautogui.keyDown('esc')
pyautogui.keyUp('esc')
pyautogui.keyUp('shift')
pyautogui.keyUp('ctrl')
</pre> 
<h3 id="6.4-KEYBOARD_KEYS">6.4 KEYBOARD_KEYS</h3> 
<p>下面就是<code>press()</code>，<code>keyDown()</code>，<code>keyUp()</code>和<code>hotkey()</code>函数可以输入的按键名称：</p> 
<p>In [ ]:</p> 
<pre>print(pyautogui.KEYBOARD_KEYS)
</pre> 
<pre>['\t', '\n', '\r', ' ', '!', '"', '#', '$', '%', '&amp;', "'", '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '&lt;', '=', '&gt;', '?', '@', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', 'accept', 'add', 'alt', 'altleft', 'altright', 'apps', 'backspace', 'browserback', 'browserfavorites', 'browserforward', 'browserhome', 'browserrefresh', 'browsersearch', 'browserstop', 'capslock', 'clear', 'convert', 'ctrl', 'ctrlleft', 'ctrlright', 'decimal', 'del', 'delete', 'divide', 'down', 'end', 'enter', 'esc', 'escape', 'execute', 'f1', 'f10', 'f11', 'f12', 'f13', 'f14', 'f15', 'f16', 'f17', 'f18', 'f19', 'f2', 'f20', 'f21', 'f22', 'f23', 'f24', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'final', 'fn', 'hanguel', 'hangul', 'hanja', 'help', 'home', 'insert', 'junja', 'kana', 'kanji', 'launchapp1', 'launchapp2', 'launchmail', 'launchmediaselect', 'left', 'modechange', 'multiply', 'nexttrack', 'nonconvert', 'num0', 'num1', 'num2', 'num3', 'num4', 'num5', 'num6', 'num7', 'num8', 'num9', 'numlock', 'pagedown', 'pageup', 'pause', 'pgdn', 'pgup', 'playpause', 'prevtrack', 'print', 'printscreen', 'prntscrn', 'prtsc', 'prtscr', 'return', 'right', 'scrolllock', 'select', 'separator', 'shift', 'shiftleft', 'shiftright', 'sleep', 'stop', 'subtract', 'tab', 'up', 'volumedown', 'volumemute', 'volumeup', 'win', 'winleft', 'winright', 'yen', 'command', 'option', 'optionleft', 'optionright']
</pre> 
<h3 id="7-%E6%B6%88%E6%81%AF%E5%BC%B9%E7%AA%97%E5%87%BD%E6%95%B0">7 消息弹窗函数</h3> 
<p>PyAutoGUI通过Tkinter实现了4种纯Python的消息弹窗函数，和JavaScript类似。</p> 
<h3 id="7.1-alert()%E5%87%BD%E6%95%B0">7.1 alert()函数</h3> 
<p>In [ ]:</p> 
<pre>pyautogui.alert(text='', title='', button='OK')
</pre> 
<p>Out[ ]:</p> 
<pre>'OK'</pre> 
<p>显示一个简单的带文字和OK按钮的消息弹窗。用户点击后返回<code>button</code>的文字。</p> 
<h3 id="7.2-The-confirm()-Function">7.2 The confirm() Function</h3> 
<p>In [ ]:</p> 
<pre>#  OK和Cancel按钮的消息弹窗
pyautogui.confirm(text='', title='', buttons=['OK', 'Cancel'])
#  10个按键0-9的消息弹窗
pyautogui.confirm(text='', title='', buttons=range(10))
</pre> 
<p>Out[ ]:</p> 
<pre>'0'</pre> 
<p>显示一个简单的带文字、OK和Cancel按钮的消息弹窗，用户点击后返回被点击button的文字，支持自定义数字、文字的列表。</p> 
<h3 id="7.3-The-prompt()-Function">7.3 The prompt() Function</h3> 
<p>In [ ]:</p> 
<pre>pyautogui.prompt(text='', title='' , default='')
</pre> 
<p>可以输入的消息弹窗，带OK和Cancel按钮。用户点击OK按钮返回输入的文字，点击Cancel按钮返回<code>None</code>。</p> 
<h3 id="7.4-The-password()-Function">7.4 The password() Function</h3> 
<p>In [ ]:</p> 
<pre>pyautogui.password(text='', title='', default='', mask='*')
</pre> 
<p>样式同<code>prompt()</code>，用于输入密码，消息用<code>*</code>表示。带OK和Cancel按钮。用户点击OK按钮返回输入的文字，点击Cancel按钮返回<code>None</code>。</p> 
<h3 id="8-%E6%88%AA%E5%B1%8F%E5%87%BD%E6%95%B0">8 截屏函数</h3> 
<p>PyAutoGUI可以截屏并保存为图片文件，然后定位这些截屏在屏幕上的位置。与<a href="http://www.sikuli.org/" rel="nofollow" title="sikuli">sikuli</a>类似，把屏幕上的按键截取下来，然后定位，就可以执行点击等操作了。</p> 
<p>截屏功能需要安装Pillow模块。OS X用<code>screencapture</code>命令，是系统自带的。Linux用户用<code>scrot</code>命令，可以通过<code>sudo apt-get install scrot</code>安装。</p> 
<h3 id="8.1-Ubuntu%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">8.1 Ubuntu注意事项</h3> 
<p>由于Ubuntu上安装Pillow时缺少PNG和JPEG依赖，所以安装比较复杂，具体可以看<a href="http://conda.pydata.org/miniconda.html" rel="nofollow" title="Ubuntu论坛">Ubuntu论坛</a>。不过用<a href="http://conda.pydata.org/miniconda.html" rel="nofollow" title="miniconda">miniconda</a>可以解决这些问题，如果Ubuntu或Mint上安装了miniconda，可以直接<code>conda install pillow</code>来安装。</p> 
<h3 id="8.2-screenshot()%E5%87%BD%E6%95%B0">8.2 <code>screenshot()</code>函数</h3> 
<p><code>screenshot()</code>函数会返回<code>Image</code>对象（参考<a href="http://python-pillow.github.io/" rel="nofollow" title="Pillow或PIL模块文档">Pillow或PIL模块文档</a>），也可以设置文件名：</p> 
<p>In [ ]:</p> 
<pre>import pyautogui
im1 = pyautogui.screenshot()
im2 = pyautogui.screenshot('my_screenshot.png')
</pre> 
<p>在一个1920×1080的屏幕上，<code>screenshot()</code>函数要消耗100微秒——不快也不慢。</p> 
<p>如果你不需要截取整个屏幕，还有一个可选的<code>region</code>参数。你可以把截取区域的左上角XY坐标值和宽度、高度传入截取。</p> 
<p>In [ ]:</p> 
<pre>im = pyautogui.screenshot(region=(0, 0, 300 ,400))
</pre> 
<h3 id="8.3-%E5%AE%9A%E4%BD%8D%E5%87%BD%E6%95%B0">8.3 定位函数</h3> 
<p>可以定位截图在屏幕上的坐标位置。比如，你需要在计算器里输入： 转存失败重新上传取消</p> 
<p>如果你不知道按钮的位置，就不能用<code>moveTo()</code>定位和<code>click()</code>点击。而且每次计算器的位置可能会变化，这时即使有来坐标也不好用了。但是如果你有要点击按钮的截图，比如数字<code>7</code>： 转存失败重新上传取消</p> 
<p>你可以调用<code>pyautogui.locateOnScreen('calc7key.png')</code>函数来获得<code>7</code>的屏幕坐标。返回的是一个元组<code>(top, left, width, height)</code>。这个元组可以用<code>pyautogui.center()</code>函数来获取截图屏幕的中心坐标。如果截图没找到，<code>pyautogui.locateOnScreen()</code>函数返回<code>None</code>：</p> 
<p>In [ ]:</p> 
<pre>import pyautogui
button7location = pyautogui.locateOnScreen('pyautogui/calc7key.png')
button7location
</pre> 
<p>Out[ ]:</p> 
<pre>(1226, 546, 29, 28)</pre> 
<p>In [ ]:</p> 
<pre>button7x, button7y = pyautogui.center(button7location)
button7x, button7y
</pre> 
<p>Out[ ]:</p> 
<pre>(1240, 560)</pre> 
<p>In [ ]:</p> 
<pre>pyautogui.click(button7x, button7y) 
</pre> 
<p><code>locateCenterOnScreen()</code>等价于上面的前两布操作，直接获得截屏屏幕中心坐标：</p> 
<p>In [ ]:</p> 
<pre>import pyautogui
x, y = pyautogui.locateCenterOnScreen('pyautogui/calc7key.png')
pyautogui.click(x, y)
</pre> 
<p>在1920×1080的屏幕上，定位函数需要1~2秒时间。对视频游戏（LOL、DOTA）来说就太慢了，但是上班干活还是绰绰有余。</p> 
<p>还是几个定位函数。都是从左上角原点开始向右向下搜索截图位置：</p> 
<ul><li>locateOnScreen(image, grayscale=False)：返回找到的第一个截图<code>Image</code>对象在屏幕上的坐标<code>(left, top, width, height)</code>，如果没找到返回<code>None</code></li><li>locateCenterOnScreen(image, grayscale=False)：返回找到的第一个截图<code>Image</code>对象在屏幕上的中心坐标<code>(x, y)</code>，如果没找到返回<code>None</code></li><li>locateAllOnScreen(image, grayscale=False)：返回找到的所有相同截图<code>Image</code>对象在屏幕上的坐标<code>(left, top, width, height)</code>的生成器</li><li>locate(needleImage, haystackImage, grayscale=False)：返回找到的第一个截图<code>Image</code>对象在<code>haystackImage</code>里面的坐标<code>(left, top, width, height)</code>，如果没找到返回<code>None</code></li><li>locateAll(needleImage, haystackImage, grayscale=False)：返回找到的所有相同截图<code>Image</code>对象在<code>haystackImage</code>里面的坐标<code>(left, top, width, height)</code>的生成器</li></ul> 
<p>两个<code>locateAll*</code>函数都可以用<code>for</code>循环和<code>list()</code>输出：</p> 
<p>In [ ]:</p> 
<pre>for pos in pyautogui.locateAllOnScreen('pyautogui/calc7key.png'):
    print(pos)
</pre> 
<pre>(1227, 546, 29, 28)
</pre> 
<p>In [ ]:</p> 
<pre>list(pyautogui.locateAllOnScreen('pyautogui/calc7key.png'))
</pre> 
<p>Out[ ]:</p> 
<pre>[(1227, 546, 29, 28)]</pre> 
<h4 id="8.3.1-%E7%81%B0%E5%BA%A6%E5%80%BC%E5%8C%B9%E9%85%8D">8.3.1 灰度值匹配</h4> 
<p>可以把<code>grayscale</code>参数设置为<code>True</code>来加速定位（大约提升30%），默认为<code>False</code>。这种去色（desaturate）方法可以加速定位，但是也可能导致假阳性（false-positive）匹配：</p> 
<p>In [ ]:</p> 
<pre>import pyautogui
button7location = pyautogui.locateOnScreen('pyautogui/calc7key.png', grayscale=True)
button7location
</pre> 
<p>Out[ ]:</p> 
<pre>(1227, 546, 29, 28)</pre> 
<h4 id="8.3.2-%E5%83%8F%E7%B4%A0%E5%8C%B9%E9%85%8D">8.3.2 像素匹配</h4> 
<p>要获取截屏某个位置的RGB像素值，可以用<code>Image</code>对象的<code>getpixel()</code>方法：</p> 
<p>In [ ]:</p> 
<pre>import pyautogui
im = pyautogui.screenshot()
im.getpixel((100, 200))
</pre> 
<p>Out[ ]:</p> 
<pre>(255, 255, 255)</pre> 
<p>也可以用PyAutoGUI的<code>pixel()</code>函数，是之前调用的包装：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.pixel(100, 200)
</pre> 
<p>Out[ ]:</p> 
<pre>(255, 255, 255)</pre> 
<p>如果你只是要检验一下指定位置的像素值，可以用<code>pixelMatchesColor()</code>函数，把X、Y和RGB元组值穿入即可：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.pixelMatchesColor(100, 200, (255, 255, 255))
</pre> 
<p>Out[ ]:</p> 
<pre>True</pre> 
<p>In [ ]:</p> 
<pre>pyautogui.pixelMatchesColor(100, 200, (255, 255, 245))
</pre> 
<p>Out[ ]:</p> 
<pre>False</pre> 
<p><code>tolerance</code>参数可以指定红、绿、蓝3种颜色误差范围：</p> 
<p>In [ ]:</p> 
<pre>pyautogui.pixelMatchesColor(100, 200, (255, 255, 245), tolerance=10)
</pre> 
<p>Out[ ]:</p> 
<pre>True</pre> 
<p>In [ ]:</p> 
<pre>pyautogui.pixelMatchesColor(100, 200, (248, 250, 245), tolerance=10)
</pre> 
<p>Out[ ]:</p> 
<pre>True</pre> 
<p>In [ ]:</p> 
<pre>pyautogui.pixelMatchesColor(100, 200, (205, 255, 245), tolerance=10)
</pre> 
<p>Out[ ]:</p> 
<pre>False</pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/91b7e4cf4c6b0b959baa226cd04e24ac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深度学习基础学习-1x1卷积核的作用（CNN中）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d9de9e9ea66c33f501083c4933f8ddeb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">都要2023年了，不会还有人不知道redis为什么快吧</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>