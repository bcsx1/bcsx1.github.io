<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java操作ElasticSearch相关内容 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java操作ElasticSearch相关内容" />
<meta property="og:description" content="Java连接ES 创建Maven工程 导入依赖 &lt;dependencies&gt; &lt;!-- 1. elasticsearch--&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;6.5.4&lt;/version&gt; &lt;/dependency&gt; ​ &lt;!-- 2. elasticsearch的高级API--&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;6.5.4&lt;/version&gt; &lt;/dependency&gt; ​ &lt;!-- 3. junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; ​ &lt;!-- 4. lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.22&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建测试类，连接ES public class ESClient { ​ public static RestHighLevelClient getClient(){ ​ // 创建HttpHost对象 HttpHost httpHost = new HttpHost(&#34;192.168.199.109&#34;,9200); ​ // 创建RestClientBuilder RestClientBuilder clientBuilder = RestClient.builder(httpHost); ​ // 创建RestHighLevelClient RestHighLevelClient client = new RestHighLevelClient(clientBuilder); ​ // 返回 return client; } ​ } Java操作索引 创建索引 代码如下" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/c049c6db2bfa1260dc123b5a8312092e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-11T23:11:17+08:00" />
<meta property="article:modified_time" content="2020-08-11T23:11:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java操作ElasticSearch相关内容</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><span style="color:#f33b45;">Java连接ES</span></h3> 
<blockquote> 
 <h3><span style="color:#f33b45;">创建Maven工程</span></h3> 
</blockquote> 
<blockquote> 
 <h3><span style="color:#f33b45;">导入依赖</span></h3> 
</blockquote> 
<pre><code class="language-XML">&lt;dependencies&gt;
    &lt;!--        1. elasticsearch--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt;
        &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt;
        &lt;version&gt;6.5.4&lt;/version&gt;
    &lt;/dependency&gt;
​
    &lt;!--        2. elasticsearch的高级API--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;
        &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;
        &lt;version&gt;6.5.4&lt;/version&gt;
    &lt;/dependency&gt;
​
    &lt;!--        3. junit--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
    &lt;/dependency&gt;
​
    &lt;!--        4. lombok--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.16.22&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre> 
<blockquote> 
 <h3><span style="color:#f33b45;">创建测试类，连接ES</span></h3> 
</blockquote> 
<pre><code class="language-java">public class ESClient {
​
    public static RestHighLevelClient getClient(){
​
        // 创建HttpHost对象
        HttpHost httpHost = new HttpHost("192.168.199.109",9200);
​
        // 创建RestClientBuilder
        RestClientBuilder clientBuilder = RestClient.builder(httpHost);
​
        // 创建RestHighLevelClient
        RestHighLevelClient client = new RestHighLevelClient(clientBuilder);
​
        // 返回
        return client;
    }
​
}</code></pre> 
<p> </p> 
<p> </p> 
<h3><span style="color:#f33b45;">Java操作索引</span></h3> 
<h3><span style="color:#f33b45;">创建索引</span></h3> 
<blockquote> 
 <p>代码如下</p> 
</blockquote> 
<pre><code class="language-java">public class Demo2 {
​
    RestHighLevelClient client = ESClient.getClient();
    String index = "person";
    String type = "man";
​
    @Test
    public void createIndex() throws IOException {
        //1. 准备关于索引的settings
        Settings.Builder settings = Settings.builder()
                .put("number_of_shards", 3)
                .put("number_of_replicas", 1);
​
        //2. 准备关于索引的结构mappings
        XContentBuilder mappings = JsonXContent.contentBuilder()
                .startObject()
                    .startObject("properties")
                        .startObject("name")
                            .field("type","text")
                        .endObject()
                        .startObject("age")
                            .field("type","integer")
                        .endObject()
                        .startObject("birthday")
                            .field("type","date")
                            .field("format","yyyy-MM-dd")
                        .endObject()
                    .endObject()
                .endObject();
​
​
        //3. 将settings和mappings封装到一个Request对象
        CreateIndexRequest request = new CreateIndexRequest(index)
                .settings(settings)
                .mapping(type,mappings);
​
        //4. 通过client对象去连接ES并执行创建索引
        CreateIndexResponse resp = client.indices().create(request, RequestOptions.DEFAULT);
​
        //5. 输出
        System.out.println("resp:" + resp.toString());
​
    }
​
}</code></pre> 
<h3><span style="color:#f33b45;">检查索引是否存在</span></h3> 
<blockquote> 
 <p>代码如下</p> 
</blockquote> 
<pre><code class="language-java">@Test
public void exists() throws IOException {
    //1. 准备request对象
    GetIndexRequest request = new GetIndexRequest();
    request.indices(index);
​
    //2. 通过client去操作
    boolean exists = client.indices().exists(request, RequestOptions.DEFAULT);
​
​
    //3. 输出
    System.out.println(exists);
}</code></pre> 
<h3><span style="color:#f33b45;">删除索引</span></h3> 
<blockquote> 
 <p>代码如下</p> 
</blockquote> 
<pre><code class="language-java">@Test
public void delete() throws IOException {
    //1. 准备request对象
    DeleteIndexRequest request = new DeleteIndexRequest();
    request.indices(index);
​
    //2. 通过client对象执行
    AcknowledgedResponse delete = client.indices().delete(request, RequestOptions.DEFAULT);
​
    //3. 获取返回结果
    System.out.println(delete.isAcknowledged());
}</code></pre> 
<h3><span style="color:#f33b45;">Java操作文档</span></h3> 
<h3><span style="color:#f33b45;"> 添加文档操作</span></h3> 
<blockquote> 
 <p>代码如下</p> 
</blockquote> 
<pre><code class="language-java">public class Demo3 {
​
    ObjectMapper mapper = new ObjectMapper();
    RestHighLevelClient client = ESClient.getClient();
    String index = "person";
    String type = "man";
​
    @Test
    public void createDoc() throws IOException {
        //1. 准备一个json数据
        Person person = new Person(1,"张三",23,new Date());
        String json = mapper.writeValueAsString(person);
​
        //2. 准备一个request对象（手动指定id）
        IndexRequest request = new IndexRequest(index,type,person.getId().toString());
        request.source(json, XContentType.JSON);
​
        //3. 通过client对象执行添加
        IndexResponse resp = client.index(request, RequestOptions.DEFAULT);
​
        //4. 输出返回结果
        System.out.println(resp.getResult().toString());
    }
​
}
</code></pre> 
<h3> <span style="color:#f33b45;">修改文档</span></h3> 
<blockquote> 
 <p>代码如下</p> 
</blockquote> 
<pre><code class="language-java">@Test
public void updateDoc() throws IOException {
    //1. 创建一个Map，指定需要修改的内容
    Map&lt;String,Object&gt; doc = new HashMap&lt;&gt;();
    doc.put("name","张大三");
    String docId = "1";
​
    //2. 创建request对象，封装数据
    UpdateRequest request = new UpdateRequest(index,type,docId);
    request.doc(doc);
​
    //3. 通过client对象执行
    UpdateResponse update = client.update(request, RequestOptions.DEFAULT);
​
    //4. 输出返回结果
    System.out.println(update.getResult().toString());
}</code></pre> 
<p> </p> 
<h3><span style="color:#f33b45;"> 删除文档</span></h3> 
<blockquote> 
 <p>代码如下</p> 
</blockquote> 
<pre><code class="language-java">@Test
public void deleteDoc() throws IOException {
    //1. 封装Request对象
    DeleteRequest request = new DeleteRequest(index,type,"1");
​
    //2. client执行
    DeleteResponse resp = client.delete(request, RequestOptions.DEFAULT);
​
    //3. 输出结果
    System.out.println(resp.getResult().toString());
}</code></pre> 
<p> </p> 
<h3> <span style="color:#f33b45;">Java批量操作文档</span></h3> 
<h3><span style="color:#f33b45;"> 批量添加</span></h3> 
<blockquote> 
 <p>代码如下</p> 
</blockquote> 
<pre><code class="language-java">@Test
public void bulkCreateDoc() throws IOException {
    //1. 准备多个json数据
    Person p1 = new Person(1,"张三",23,new Date());
    Person p2 = new Person(2,"李四",24,new Date());
    Person p3 = new Person(3,"王五",25,new Date());
​
    String json1 = mapper.writeValueAsString(p1);
    String json2 = mapper.writeValueAsString(p2);
    String json3 = mapper.writeValueAsString(p3);
​
    //2. 创建Request，将准备好的数据封装进去
    BulkRequest request = new BulkRequest();
    request.add(new IndexRequest(index,type,p1.getId().toString()).source(json1,XContentType.JSON));
    request.add(new IndexRequest(index,type,p2.getId().toString()).source(json2,XContentType.JSON));
    request.add(new IndexRequest(index,type,p3.getId().toString()).source(json3,XContentType.JSON));
​
    //3. 用client执行
    BulkResponse resp = client.bulk(request, RequestOptions.DEFAULT);
​
    //4. 输出结果
    System.out.println(resp.toString());
}</code></pre> 
<p> </p> 
<h3> <span style="color:#f33b45;">批量删除</span></h3> 
<blockquote> 
 <p>代码如下</p> 
</blockquote> 
<pre><code class="language-java">@Test
public void bulkDeleteDoc() throws IOException {
    //1. 封装Request对象
    BulkRequest request = new BulkRequest();
    request.add(new DeleteRequest(index,type,"1"));
    request.add(new DeleteRequest(index,type,"2"));
    request.add(new DeleteRequest(index,type,"3"));
​
    //2. client执行
    BulkResponse resp = client.bulk(request, RequestOptions.DEFAULT);
​
    //3. 输出
    System.out.println(resp);
}</code></pre> 
<h2>ElasticSearch的各种查询</h2> 
<hr> 
<h3> <span style="color:#f33b45;">term&amp;terms查询</span></h3> 
<h3><span style="color:#f33b45;"> term查询</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">term的查询是代表完全匹配，搜索之前不会对你搜索的关键字进行分词，对你的关键字去文档分词库中去匹配内容。</span></p> 
</blockquote> 
<pre><code class="language-html hljs"># term查询
POST /sms-logs-index/sms-logs-type/_search
{
  "from": 0,     # limit ？
  "size": 5,      # limit x,?
  "query": {
    "term": {
      "province": {
        "value": "北京"
      }
    }
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// Java代码实现方式
@Test
public void termQuery() throws IOException {
    //1. 创建Request对象
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定查询条件
    SearchSourceBuilder builder = new SearchSourceBuilder();
    builder.from(0);
    builder.size(5);
    builder.query(QueryBuilders.termQuery("province","北京"));
​
    request.source(builder);
​
    //3. 执行查询
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 获取到_source中的数据，并展示
    for (SearchHit hit : resp.getHits().getHits()) {
        Map&lt;String, Object&gt; result = hit.getSourceAsMap();
        System.out.println(result);
    }
}
</code></pre> 
<h3><span style="color:#f33b45;"> terms查询</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">terms和term的查询机制是一样，都不会将指定的查询关键字进行分词，直接去分词库中匹配，找到相应文档内容。</span></p> 
 <p><span style="color:#f33b45;">terms是在针对一个字段包含多个值的时候使用。属性值多</span></p> 
 <p><span style="color:#f33b45;">term：where province = 北京；</span></p> 
 <p><span style="color:#f33b45;">terms：where province = 北京 or province = ？or province = ？</span></p> 
</blockquote> 
<pre><code class="language-html hljs"># terms查询
POST /sms-logs-index/sms-logs-type/_search
{
  "query": {
    "terms": {
      "province": [
        "北京",
        "山西",
        "武汉"
      ]
    }
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// Java实现
@Test
public void termsQuery() throws IOException {
    //1. 创建request
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 封装查询条件
    SearchSourceBuilder builder = new SearchSourceBuilder();
    builder.query(QueryBuilders.termsQuery("province","北京","山西"));
​
    request.source(builder);
​
    //3. 执行查询
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 输出_source
    for (SearchHit hit : resp.getHits().getHits()) {
        System.out.println(hit.getSourceAsMap());
    }
}</code></pre> 
<p> </p> 
<h3> <span style="color:#f33b45;">match查询</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">match查询属于高层查询，他会根据你查询的字段类型不一样，采用不同的查询方式。</span></p> 
 <ul><li> <p><span style="color:#f33b45;">查询的是日期或者是数值的话，他会将你基于的字符串查询内容转换为日期或者数值对待。</span></p> </li><li> <p><span style="color:#f33b45;">如果查询的内容是一个不能被分词的内容（keyword），match查询不会对你指定的查询关键字进行分词。</span></p> </li><li> <p><span style="color:#f33b45;">如果查询的内容时一个可以被分词的内容（text），match会将你指定的查询内容根据一定的方式去分词，去分词库中匹配指定的内容。</span></p> </li></ul> 
 <p><span style="color:#f33b45;">match查询，实际底层就是多个term查询，将多个term查询的结果给你封装到了一起。</span></p> 
</blockquote> 
<h3> <span style="color:#f33b45;">match_all查询</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">查询全部内容，不指定任何查询条件。</span></p> 
</blockquote> 
<pre><code class="language-html hljs"># match_all查询
POST /sms-logs-index/sms-logs-type/_search
{
  "query": {
    "match_all": {}
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">//  java代码实现
@Test
public void matchAllQuery() throws IOException {
    //1. 创建Request
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定查询条件
    SearchSourceBuilder builder = new SearchSourceBuilder();
    builder.query(QueryBuilders.matchAllQuery());
    builder.size(20);           // ES默认只查询10条数据，如果想查询更多，添加size
    request.source(builder);
​
    //3. 执行查询
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 输出结果
    for (SearchHit hit : resp.getHits().getHits()) {
        System.out.println(hit.getSourceAsMap());
    }
    System.out.println(resp.getHits().getHits().length);
​
​
}
</code></pre> 
<h3> <span style="color:#f33b45;">match查询</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">指定一个Field作为筛选的条件</span></p> 
</blockquote> 
<pre><code class="language-html hljs"># match查询
POST /sms-logs-index/sms-logs-type/_search
{
  "query": {
    "match": {
      "smsContent": "收货安装"
    }
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">@Test
public void matchQuery() throws IOException {
    //1. 创建Request
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定查询条件
    SearchSourceBuilder builder = new SearchSourceBuilder();
    //-----------------------------------------------
    builder.query(QueryBuilders.matchQuery("smsContent","收货安装"));
    //-----------------------------------------------
    request.source(builder);
    //3. 执行查询
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 输出结果
    for (SearchHit hit : resp.getHits().getHits()) {
        System.out.println(hit.getSourceAsMap());
    }
}</code></pre> 
<p> </p> 
<h3> <span style="color:#f33b45;">布尔match查询</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">基于一个Field匹配的内容，采用and或者or的方式连接</span></p> 
</blockquote> 
<pre><code class="language-html hljs"># 布尔match查询
POST /sms-logs-index/sms-logs-type/_search
{
  "query": {
    "match": {
      "smsContent": {
        "query": "中国 健康",
        "operator": "and"      # 内容既包含中国也包含健康
      }
    }
  }
}
​
​
# 布尔match查询
POST /sms-logs-index/sms-logs-type/_search
{
  "query": {
    "match": {
      "smsContent": {
        "query": "中国 健康",
        "operator": "or"        # 内容包括健康或者包括中国
      }
    }
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// Java代码实现
@Test
public void booleanMatchQuery() throws IOException {
    //1. 创建Request
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定查询条件
    SearchSourceBuilder builder = new SearchSourceBuilder();
    //-----------------------------------------------                               选择AND或者OR
    builder.query(QueryBuilders.matchQuery("smsContent","中国 健康").operator(Operator.OR));
    //-----------------------------------------------
    request.source(builder);
    //3. 执行查询
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 输出结果
    for (SearchHit hit : resp.getHits().getHits()) {
        System.out.println(hit.getSourceAsMap());
    }
}</code></pre> 
<p> </p> 
<h3> <span style="color:#f33b45;">multi_match查询</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">match针对一个field做检索，multi_match针对多个field进行检索，多个field对应一个text。</span></p> 
</blockquote> 
<pre><code class="language-html hljs"># multi_match 查询
POST /sms-logs-index/sms-logs-type/_search
{
  "query": {
    "multi_match": {
      "query": "北京",                    # 指定text
      "fields": ["province","smsContent"]    # 指定field们
    }
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// java代码实现
@Test
public void multiMatchQuery() throws IOException {
    //1. 创建Request
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定查询条件
    SearchSourceBuilder builder = new SearchSourceBuilder();
    //-----------------------------------------------
    builder.query(QueryBuilders.multiMatchQuery("北京","province","smsContent"));
    //-----------------------------------------------
    request.source(builder);
    //3. 执行查询
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 输出结果
    for (SearchHit hit : resp.getHits().getHits()) {
        System.out.println(hit.getSourceAsMap());
    }
}</code></pre> 
<p> </p> 
<h3><span style="color:#f33b45;"> 其他查询</span></h3> 
<h3><span style="color:#f33b45;"> id查询</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">根据id查询 where id = ?</span></p> 
</blockquote> 
<pre><code class="language-html hljs"># id查询
GET /sms-logs-index/sms-logs-type/1</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// Java代码实现
@Test
public void findById() throws IOException {
    //1. 创建GetRequest
    GetRequest request = new GetRequest(index,type,"1");
​
    //2. 执行查询
    GetResponse resp = client.get(request, RequestOptions.DEFAULT);
​
    //3. 输出结果
    System.out.println(resp.getSourceAsMap());
}</code></pre> 
<p> </p> 
<h3><span style="color:#f33b45;"> ids查询</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">根据多个id查询，类似MySQL中的where id in（id1，id2，id2...）</span></p> 
</blockquote> 
<pre><code class="language-html hljs"># ids查询
POST /sms-logs-index/sms-logs-type/_search
{
  "query": {
    "ids": {
      "values": ["1","2","3"]
    }
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// Java代码实现
@Test
public void findByIds() throws IOException {
    //1. 创建SearchRequest
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定查询条件
    SearchSourceBuilder builder = new SearchSourceBuilder();
    //----------------------------------------------------------
    builder.query(QueryBuilders.idsQuery().addIds("1","2","3"));
    //----------------------------------------------------------
    request.source(builder);
​
    //3. 执行
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 输出结果
    for (SearchHit hit : resp.getHits().getHits()) {
        System.out.println(hit.getSourceAsMap());
    }
}</code></pre> 
<p> </p> 
<h3> <span style="color:#f33b45;">prefix查询</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">前缀查询，可以通过一个关键字去指定一个Field的前缀，从而查询到指定的文档</span>。</p> 
</blockquote> 
<pre><code class="language-html hljs">#prefix 查询
POST /sms-logs-index/sms-logs-type/_search
{
  "query": {
    "prefix": {
      "corpName": {
        "value": "途虎"
      }
    }
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// Java实现前缀查询
@Test
public void findByPrefix() throws IOException {
    //1. 创建SearchRequest
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定查询条件
    SearchSourceBuilder builder = new SearchSourceBuilder();
    //----------------------------------------------------------
    builder.query(QueryBuilders.prefixQuery("corpName","盒马"));
    //----------------------------------------------------------
    request.source(builder);
​
    //3. 执行
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 输出结果
    for (SearchHit hit : resp.getHits().getHits()) {
        System.out.println(hit.getSourceAsMap());
    }
}</code></pre> 
<p> </p> 
<h3> <span style="color:#f33b45;">fuzzy查询</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">模糊查询，我们输入字符的大概，ES就可以去根据输入的内容大概去匹配一下结果。</span></p> 
</blockquote> 
<pre><code class="language-html hljs"># fuzzy查询
POST /sms-logs-index/sms-logs-type/_search
{
  "query":
    {
    "fuzzy": {
      "corpName": {
        "value": "盒马先生",
        "prefix_length": 2          # 指定前面几个字符是不允许出现错误的
      }
    }
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// Java代码实现Fuzzy查询
@Test
public void findByFuzzy() throws IOException {
    //1. 创建SearchRequest
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定查询条件
    SearchSourceBuilder builder = new SearchSourceBuilder();
    //----------------------------------------------------------
    builder.query(QueryBuilders.fuzzyQuery("corpName","盒马先生").prefixLength(2));
    //----------------------------------------------------------
    request.source(builder);
​
    //3. 执行
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 输出结果
    for (SearchHit hit : resp.getHits().getHits()) {
        System.out.println(hit.getSourceAsMap());
    }
}</code></pre> 
<p> </p> 
<h3><span style="color:#f33b45;"> wildcard查询</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">通配查询，和MySQL中的like是一个套路，可以在查询时，在字符串中指定通配符* 和占位符？，*的范围比？广泛</span></p> 
</blockquote> 
<pre><code class="language-html hljs"># wildcard 查询
POST /sms-logs-index/sms-logs-type/_search
{
  "query": {
    "wildcard": {
      "corpName": {
        "value": "中国*"    # 可以使用*和？指定通配符和占位符
      }
    }
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// Java代码实现Wildcard查询
@Test
public void findByWildCard() throws IOException {
    //1. 创建SearchRequest
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定查询条件
    SearchSourceBuilder builder = new SearchSourceBuilder();
    //----------------------------------------------------------
    builder.query(QueryBuilders.wildcardQuery("corpName","中国*"));
    //----------------------------------------------------------
    request.source(builder);
​
    //3. 执行
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 输出结果
    for (SearchHit hit : resp.getHits().getHits()) {
        System.out.println(hit.getSourceAsMap());
    }
}</code></pre> 
<p> </p> 
<h3> <span style="color:#f33b45;">range查询</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">范围查询，只针对数值类型，对某一个Field进行大于或者小于的范围指定</span></p> 
</blockquote> 
<pre><code class="language-html hljs"># range 查询
POST /sms-logs-index/sms-logs-type/_search
{
  "query": {
    "range": {
      "fee": {
        "gt": 5,
        "lte": 10
         # 可以使用 gt：&gt;      gte：&gt;=     lt：&lt;     lte：&lt;=
      }
    }
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// Java实现range范围查询
@Test
public void findByRange() throws IOException {
    //1. 创建SearchRequest
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定查询条件
    SearchSourceBuilder builder = new SearchSourceBuilder();
    //----------------------------------------------------------
    builder.query(QueryBuilders.rangeQuery("fee").lte(10).gte(5));
    //----------------------------------------------------------
    request.source(builder);
​
    //3. 执行
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 输出结果
    for (SearchHit hit : resp.getHits().getHits()) {
        System.out.println(hit.getSourceAsMap());
    }
}</code></pre> 
<pre><code class="language-html hljs">​</code></pre> 
<p> </p> 
<h3> <span style="color:#f33b45;">regexp查询</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">正则查询，通过你编写的正则表达式去匹配内容。</span></p> 
 <p><a href="" rel="nofollow">Ps：prefix，fuzzy，wildcard和regexp查询效率相对比较低，要求效率比较高时，避免去使用</a></p> 
</blockquote> 
<pre><code class="language-html hljs"># regexp 查询
POST /sms-logs-index/sms-logs-type/_search
{
  "query": {
    "regexp": {
      "mobile": "180[0-9]{8}"    # 编写正则
    }
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// Java代码实现正则查询
@Test
public void findByRegexp() throws IOException {
    //1. 创建SearchRequest
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定查询条件
    SearchSourceBuilder builder = new SearchSourceBuilder();
    //----------------------------------------------------------
    builder.query(QueryBuilders.regexpQuery("mobile","139[0-9]{8}"));
    //----------------------------------------------------------
    request.source(builder);
​
    //3. 执行
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 输出结果
    for (SearchHit hit : resp.getHits().getHits()) {
        System.out.println(hit.getSourceAsMap());
    }
}</code></pre> 
<p> </p> 
<h3><span style="color:#f33b45;"> 深分页Scroll</span></h3> 
<blockquote> 
 <p>ES对from + size是有限制的，from和size二者之和不能超过1W</p> 
 <p>原理：</p> 
 <ul><li> <p>from+size在ES查询数据的方式：</p> 
   <ul><li> <p>第一步现将用户指定的关键进行分词。</p> </li><li> <p>第二步将词汇去分词库中进行检索，得到多个文档的id。</p> </li><li> <p>第三步去各个分片中去拉取指定的数据。耗时较长。</p> </li><li> <p>第四步将数据根据score进行排序。耗时较长。</p> </li><li> <p>第五步根据from的值，将查询到的数据舍弃一部分。</p> </li><li> <p>第六步返回结果。</p> </li></ul></li><li> <p>scroll+size在ES查询数据的方式：</p> 
   <ul><li> <p>第一步现将用户指定的关键进行分词。</p> </li><li> <p>第二步将词汇去分词库中进行检索，得到多个文档的id。</p> </li><li> <p>第三步将文档的id存放在一个ES的上下文中。</p> </li><li> <p>第四步根据你指定的size的个数去ES中检索指定个数的数据，拿完数据的文档id，会从上下文中移除。</p> </li><li> <p>第五步如果需要下一页数据，直接去ES的上下文中，找后续内容。</p> </li><li> <p>第六步循环第四步和第五步</p> </li></ul></li></ul> 
 <p><a href="" rel="nofollow">Scroll查询方式，不适合做实时的查询</a></p> 
</blockquote> 
<pre><code class="language-html hljs"># 执行scroll查询，返回第一页数据，并且将文档id信息存放在ES上下文中，指定生存时间1m
POST /sms-logs-index/sms-logs-type/_search?scroll=1m
{
  "query": {
    "match_all": {}
  },
  "size": 2,
  "sort": [                 # 排序
    {
      "fee": {
        "order": "desc"
      }
    }
  ]
}
​
# 根据scroll查询下一页数据
POST /_search/scroll
{
  "scroll_id": "&lt;根据第一步得到的scorll_id去指定&gt;",
  "scroll": "&lt;scorll信息的生存时间&gt;"
}
​
​
# 删除scroll在ES上下文中的数据
DELETE /_search/scroll/scroll_id</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// Java实现scroll分页
@Test
public void scrollQuery() throws IOException {
    //1. 创建SearchRequest
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定scroll信息
    request.scroll(TimeValue.timeValueMinutes(1L));
​
    //3. 指定查询条件
    SearchSourceBuilder builder = new SearchSourceBuilder();
    builder.size(4);
    builder.sort("fee", SortOrder.DESC);
    builder.query(QueryBuilders.matchAllQuery());
    
    request.source(builder);
​
    //4. 获取返回结果scrollId，source
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    String scrollId = resp.getScrollId();
    System.out.println("----------首页---------");
    for (SearchHit hit : resp.getHits().getHits()) {
        System.out.println(hit.getSourceAsMap());
    }
​
​
    while(true) {
        //5. 循环 - 创建SearchScrollRequest
        SearchScrollRequest scrollRequest = new SearchScrollRequest(scrollId);
​
        //6. 指定scrollId的生存时间
        scrollRequest.scroll(TimeValue.timeValueMinutes(1L));
​
        //7. 执行查询获取返回结果
        SearchResponse scrollResp = client.scroll(scrollRequest, RequestOptions.DEFAULT);
​
        //8. 判断是否查询到了数据，输出
        SearchHit[] hits = scrollResp.getHits().getHits();
        if(hits != null &amp;&amp; hits.length &gt; 0) {
            System.out.println("----------下一页---------");
            for (SearchHit hit : hits) {
                System.out.println(hit.getSourceAsMap());
            }
        }else{
            //9. 判断没有查询到数据-退出循环
            System.out.println("----------结束---------");
            break;
        }
    }
​
​
    //10. 创建CLearScrollRequest
    ClearScrollRequest clearScrollRequest = new ClearScrollRequest();
​
    //11. 指定ScrollId
    clearScrollRequest.addScrollId(scrollId);
​
    //12. 删除ScrollId
    ClearScrollResponse clearScrollResponse = client.clearScroll(clearScrollRequest, RequestOptions.DEFAULT);
​
    //13. 输出结果
    System.out.println("删除scroll：" + clearScrollResponse.isSucceeded());
​
}
</code></pre> 
<h3> <span style="color:#f33b45;">delete-by-query</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">根据term，match等查询方式去删除大量的文档</span></p> 
 <p><a href="" rel="nofollow">Ps：如果你需要删除的内容，是index下的大部分数据，推荐创建一个全新的index，将保留的文档内容，添加到全新的索引</a></p> 
</blockquote> 
<pre><code class="language-html hljs"># delete-by-query
POST /sms-logs-index/sms-logs-type/_delete_by_query
{
  "query": {
    "range": {
      "fee": {
        "lt": 4
      }
    }
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// Java代码实现
@Test
public void deleteByQuery() throws IOException {
    //1. 创建DeleteByQueryRequest
    DeleteByQueryRequest request = new DeleteByQueryRequest(index);
    request.types(type);
​
    //2. 指定检索的条件    和SearchRequest指定Query的方式不一样
    request.setQuery(QueryBuilders.rangeQuery("fee").lt(4));
​
    //3. 执行删除
    BulkByScrollResponse resp = client.deleteByQuery(request, RequestOptions.DEFAULT);
​
    //4. 输出返回结果
    System.out.println(resp.toString());
​
}
</code></pre> 
<h3><span style="color:#f33b45;"> 复合查询</span></h3> 
<h3><span style="color:#f33b45;"> bool查询</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">复合过滤器，将你的多个查询条件，以一定的逻辑组合在一起。</span></p> 
 <ul><li> <p><span style="color:#f33b45;">must： 所有的条件，用must组合在一起，表示And的意思</span></p> </li><li> <p><span style="color:#f33b45;">must_not：将must_not中的条件，全部都不能匹配，标识Not的意思</span></p> </li><li> <p><span style="color:#f33b45;">should：所有的条件，用should组合在一起，表示Or的意思</span></p> </li></ul> 
</blockquote> 
<pre><code class="language-html hljs"># 查询省份为武汉或者北京
# 运营商不是联通
# smsContent中包含中国和平安
# bool查询
POST /sms-logs-index/sms-logs-type/_search
{
  "query": {
    "bool": {
      "should": [
        {
          "term": {
            "province": {
              "value": "北京"
            }
          }
        },
        {
          "term": {
            "province": {
              "value": "武汉"
            }
          }
        }
      ],
      "must_not": [
        {
          "term": {
            "operatorId": {
              "value": "2"
            }
          }
        }
      ],
      "must": [
        {
          "match": {
            "smsContent": "中国"
          }
        },
        {
          "match": {
            "smsContent": "平安"
          }
        }
      ]
    }
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// Java代码实现Bool查询
@Test
public void BoolQuery() throws IOException {
    //1. 创建SearchRequest
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定查询条件
    SearchSourceBuilder builder = new SearchSourceBuilder();
    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
    // # 查询省份为武汉或者北京
    boolQuery.should(QueryBuilders.termQuery("province","武汉"));
    boolQuery.should(QueryBuilders.termQuery("province","北京"));
    // # 运营商不是联通
    boolQuery.mustNot(QueryBuilders.termQuery("operatorId",2));
    // # smsContent中包含中国和平安
    boolQuery.must(QueryBuilders.matchQuery("smsContent","中国"));
    boolQuery.must(QueryBuilders.matchQuery("smsContent","平安"));
​
    builder.query(boolQuery);
    request.source(builder);
​
    //3. 执行查询
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 输出结果
    for (SearchHit hit : resp.getHits().getHits()) {
        System.out.println(hit.getSourceAsMap());
    }
}</code></pre> 
<p> </p> 
<h3><span style="color:#f33b45;"> boosting查询</span></h3> 
<blockquote> 
 <p>boosting查询可以帮助我们去影响查询后的score。</p> 
 <ul><li> <p>positive：只有匹配上positive的查询的内容，才会被放到返回的结果集中。</p> </li><li> <p>negative：如果匹配上和positive并且也匹配上了negative，就可以降低这样的文档score。</p> </li><li> <p>negative_boost：指定系数，必须小于1.0</p> </li></ul> 
 <p>关于查询时，分数是如何计算的：</p> 
 <ul><li> <p>搜索的关键字在文档中出现的频次越高，分数就越高</p> </li><li> <p>指定的文档内容越短，分数就越高</p> </li><li> <p>我们在搜索时，指定的关键字也会被分词，这个被分词的内容，被分词库匹配的个数越多，分数越高</p> </li></ul> 
</blockquote> 
<pre><code class="language-html hljs"># boosting查询  收货安装
POST /sms-logs-index/sms-logs-type/_search
{
  "query": {
    "boosting": {
      "positive": {
        "match": {
          "smsContent": "收货安装"
        }
      },
      "negative": {
        "match": {
          "smsContent": "王五"
        }
      },
      "negative_boost": 0.5
    }
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// Java实现Boosting查询
@Test
public void BoostingQuery() throws IOException {
    //1. 创建SearchRequest
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定查询条件
    SearchSourceBuilder builder = new SearchSourceBuilder();
    BoostingQueryBuilder boostingQuery = QueryBuilders.boostingQuery(
            QueryBuilders.matchQuery("smsContent", "收货安装"),
            QueryBuilders.matchQuery("smsContent", "王五")
    ).negativeBoost(0.5f);
​
    builder.query(boostingQuery);
    request.source(builder);
​
    //3. 执行查询
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 输出结果
    for (SearchHit hit : resp.getHits().getHits()) {
        System.out.println(hit.getSourceAsMap());
    }
}</code></pre> 
<p> </p> 
<h3> <span style="color:#f33b45;">filter查询</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">query，根据你的查询条件，去计算文档的匹配度得到一个分数，并且根据分数进行排序，不会做缓存的。</span></p> 
 <p><span style="color:#f33b45;">filter，根据你的查询条件去查询文档，不去计算分数，而且filter会对经常被过滤的数据进行缓存</span>。</p> 
</blockquote> 
<pre><code class="language-html hljs"># filter查询
POST /sms-logs-index/sms-logs-type/_search
{
  "query": {
    "bool": {
      "filter": [
        {
          "term": {
            "corpName": "盒马鲜生"
          }
        },
        {
          "range": {
            "fee": {
              "lte": 4
            }
          }
        }
      ]
    }
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// Java实现filter操作
@Test
public void filter() throws IOException {
    //1. SearchRequest
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 查询条件
    SearchSourceBuilder builder = new SearchSourceBuilder();
    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
    boolQuery.filter(QueryBuilders.termQuery("corpName","盒马鲜生"));
    boolQuery.filter(QueryBuilders.rangeQuery("fee").lte(5));
​
    builder.query(boolQuery);
    request.source(builder);
​
    //3. 执行查询
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 输出结果
    for (SearchHit hit : resp.getHits().getHits()) {
        System.out.println(hit.getSourceAsMap());
    }
​
​
}</code></pre> 
<p> </p> 
<h3> <span style="color:#f33b45;">高亮查询</span></h3> 
<blockquote> 
 <p>高亮查询就是你用户输入的关键字，以一定的特殊样式展示给用户，让用户知道为什么这个结果被检索出来。</p> 
 <p>高亮展示的数据，本身就是文档中的一个Field，单独将Field以highlight的形式返回给你。</p> 
 <p>ES提供了一个highlight属性，和query同级别的。</p> 
 <ul><li> <p><span style="color:#f33b45;">fragment_size</span>：指定高亮数据展示多少个字符回来。</p> </li><li> <p><span style="color:#f33b45;">pre_tags</span>：指定前缀标签，举个栗子&lt; font color="red" &gt;</p> </li><li> <p><span style="color:#f33b45;">post_tags</span>：指定后缀标签，举个栗子&lt; /font &gt;</p> </li><li> <p><span style="color:#f33b45;">fields</span>：指定哪几个Field以高亮形式返回</p> </li></ul> 
</blockquote> 
<h3><br><span style="color:#f33b45;">RESTful实现</span> </h3> 
<pre><code class="language-html hljs"># highlight查询
POST /sms-logs-index/sms-logs-type/_search
{
  "query": {
    "match": {
      "smsContent": "盒马"
    }
  },
  "highlight": {
    "fields": {
      "smsContent": {}
    },
    "pre_tags": "&lt;font color='red'&gt;",
    "post_tags": "&lt;/font&gt;",
    "fragment_size": 10
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// Java实现高亮查询
@Test
public void highLightQuery() throws IOException {
    //1. SearchRequest
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定查询条件（高亮）
    SearchSourceBuilder builder = new SearchSourceBuilder();
    //2.1 指定查询条件
    builder.query(QueryBuilders.matchQuery("smsContent","盒马"));
    //2.2 指定高亮
    HighlightBuilder highlightBuilder = new HighlightBuilder();
    highlightBuilder.field("smsContent",10)
            .preTags("&lt;font color='red'&gt;")
            .postTags("&lt;/font&gt;");
    builder.highlighter(highlightBuilder);
​
    request.source(builder);
​
    //3. 执行查询
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 获取高亮数据，输出
    for (SearchHit hit : resp.getHits().getHits()) {
        System.out.println(hit.getHighlightFields().get("smsContent"));
    }
}
</code></pre> 
<h3> <span style="color:#f33b45;">聚合查询</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">ES的聚合查询和MySQL的聚合查询类似，ES的聚合查询相比MySQL要强大的多，ES提供的统计数据的方式多种多样</span>。</p> 
</blockquote> 
<pre><code class="language-html hljs"># ES聚合查询的RESTful语法
POST /index/type/_search
{
    "aggs": {
        "名字（agg）": {
            "agg_type": {
                "属性": "值"
            }
        }
    }
}</code></pre> 
<p> </p> 
<h3> <span style="color:#f33b45;">去重计数查询</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">去重计数，即Cardinality，第一步先将返回的文档中的一个指定的field进行去重，统计一共有多少条</span></p> 
</blockquote> 
<pre><code class="language-html hljs"># 去重计数查询 北京 上海 武汉 山西
POST /sms-logs-index/sms-logs-type/_search
{
  "aggs": {
    "agg": {
      "cardinality": {
        "field": "province"
      }
    }
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">//  Java代码实现去重计数查询
@Test
public void cardinality() throws IOException {
    //1. 创建SearchRequest
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定使用的聚合查询方式
    SearchSourceBuilder builder = new SearchSourceBuilder();
    builder.aggregation(AggregationBuilders.cardinality("agg").field("province"));
​
    request.source(builder);
​
    //3. 执行查询
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 获取返回结果
    Cardinality agg = resp.getAggregations().get("agg");
    long value = agg.getValue();
    System.out.println(value);
}
</code></pre> 
<h3><span style="color:#f33b45;"> 范围统计</span></h3> 
<blockquote> 
 <p>统计一定范围内出现的文档个数，比如，针对某一个Field的值在 0~100,100~200,200~300之间文档出现的个数分别是多少。</p> 
 <p>范围统计可以针对普通的数值，针对时间类型，针对ip类型都可以做相应的统计。</p> 
 <p>range，date_range，ip_range</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#f33b45;">数值统计</span></p> 
</blockquote> 
<pre><code class="language-html hljs"># 数值方式范围统计
POST /sms-logs-index/sms-logs-type/_search
{
  "aggs": {
    "agg": {
      "range": {
        "field": "fee",
        "ranges": [
          {
            "to": 5
          },
          {
            "from": 5,    # from有包含当前值的意思  
            "to": 10
          },
          {
            "from": 10
          }
        ]
      }
    }
  }
}</code></pre> 
<blockquote> 
 <p><span style="color:#f33b45;">时间范围统计</span></p> 
</blockquote> 
<pre><code class="language-html hljs"># 时间方式范围统计
POST /sms-logs-index/sms-logs-type/_search
{
  "aggs": {
    "agg": {
      "date_range": {
        "field": "createDate",
        "format": "yyyy", 
        "ranges": [
          {
            "to": 2000
          },
          {
            "from": 2000
          }
        ]
      }
    }
  }
}</code></pre> 
<blockquote> 
 <p><span style="color:#f33b45;">ip统计方式</span></p> 
</blockquote> 
<pre><code class="language-html hljs"># ip方式 范围统计
POST /sms-logs-index/sms-logs-type/_search
{
  "aggs": {
    "agg": {
      "ip_range": {
        "field": "ipAddr",
        "ranges": [
          {
            "to": "10.126.2.9"
          },
          {
            "from": "10.126.2.9"
          }
        ]
      }
    }
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// Java实现数值 范围统计
@Test
public void range() throws IOException {
    //1. 创建SearchRequest
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定使用的聚合查询方式
    SearchSourceBuilder builder = new SearchSourceBuilder();
    //---------------------------------------------
    builder.aggregation(AggregationBuilders.range("agg").field("fee")
                                        .addUnboundedTo(5)
                                        .addRange(5,10)
                                        .addUnboundedFrom(10));
    //---------------------------------------------
    request.source(builder);
​
    //3. 执行查询
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 获取返回结果
    Range agg = resp.getAggregations().get("agg");
    for (Range.Bucket bucket : agg.getBuckets()) {
        String key = bucket.getKeyAsString();
        Object from = bucket.getFrom();
        Object to = bucket.getTo();
        long docCount = bucket.getDocCount();
        System.out.println(String.format("key：%s，from：%s，to：%s，docCount：%s",key,from,to,docCount));
    }
}</code></pre> 
<p> </p> 
<h3><span style="color:#f33b45;"> 统计聚合查询</span></h3> 
<blockquote> 
 <p>他可以帮你查询指定Field的最大值，最小值，平均值，平方和等</p> 
 <p>使用：extended_stats</p> 
</blockquote> 
<pre><code class="language-html hljs"># 统计聚合查询
POST /sms-logs-index/sms-logs-type/_search
{
  "aggs": {
    "agg": {
      "extended_stats": {
        "field": "fee"
      }
    }
  }
}</code></pre> 
<blockquote> 
 <p>代码实现方式</p> 
</blockquote> 
<pre><code class="language-java">// Java实现统计聚合查询
@Test
public void extendedStats() throws IOException {
    //1. 创建SearchRequest
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定使用的聚合查询方式
    SearchSourceBuilder builder = new SearchSourceBuilder();
    //---------------------------------------------
    builder.aggregation(AggregationBuilders.extendedStats("agg").field("fee"));
    //---------------------------------------------
    request.source(builder);
​
    //3. 执行查询
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 获取返回结果
    ExtendedStats agg = resp.getAggregations().get("agg");
    double max = agg.getMax();
    double min = agg.getMin();
    System.out.println("fee的最大值为：" + max + "，最小值为：" + min);
}</code></pre> 
<blockquote> 
 <p>其他的聚合查询方式查看官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.5/index.html" rel="nofollow">https://www.elastic.co/guide/en/elasticsearch/reference/6.5/index.html</a></p> 
</blockquote> 
<p> </p> 
<h3><span style="color:#f33b45;"> 地图经纬度搜索</span></h3> 
<blockquote> 
 <p>ES中提供了一个数据类型 geo_point，这个类型就是用来存储经纬度的。</p> 
 <p>创建一个带geo_point类型的索引，并添加测试数据</p> 
</blockquote> 
<pre><code class="language-html hljs"># 创建一个索引，指定一个name，locaiton
PUT /map
{
  "settings": {
    "number_of_shards": 5,
    "number_of_replicas": 1
  },
  "mappings": {
    "map": {
      "properties": {
        "name": {
          "type": "text"
        },
        "location": {
          "type": "geo_point"
        }
      }
    }
  }
}
​
​
# 添加测试数据
PUT /map/map/1
{
  "name": "天安门",
  "location": {
    "lon": 116.403981,
    "lat": 39.914492 
  }
}
​
​
PUT /map/map/2
{
  "name": "海淀公园",
  "location": {
    "lon": 116.302509,
    "lat": 39.991152 
  }
}
​
PUT /map/map/3
{
  "name": "北京动物园",
  "location": {
    "lon": 116.343184,
    "lat": 39.947468 
  }
}</code></pre> 
<p> </p> 
<h3><span style="color:#f33b45;"> ES的地图检索方式</span></h3> 
<table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>geo_distance</td><td>直线距离检索方式</td></tr><tr><td>geo_bounding_box</td><td>以两个点确定一个矩形，获取在矩形内的全部数据</td></tr><tr><td>geo_polygon</td><td>以多个点，确定一个多边形，获取多边形内的全部数据</td></tr></tbody></table> 
<p> </p> 
<h3><span style="color:#f33b45;">基于RESTful实现地图检索</span></h3> 
<blockquote> 
 <p><span style="color:#f33b45;">geo_distance</span></p> 
</blockquote> 
<pre><code class="language-html hljs"># geo_distance
POST /map/map/_search
{
  "query": {
    "geo_distance": {
      "location": {             # 确定一个点
        "lon": 116.433733,
        "lat": 39.908404
      },
      "distance": 3000,          # 确定半径
      "distance_type": "arc"     # 指定形状为圆形
    }
  }
}</code></pre> 
<blockquote> 
 <p><span style="color:#f33b45;">geo_bounding_box</span></p> 
</blockquote> 
<pre><code class="language-html hljs"># geo_bounding_box
POST /map/map/_search
{
  "query": {
    "geo_bounding_box": {
      "location": {
        "top_left": {               # 左上角的坐标点
          "lon": 116.326943,
          "lat": 39.95499
        },
        "bottom_right": {            # 右下角的坐标点
          "lon": 116.433446,
          "lat": 39.908737
        }
      }
    }
  }
}</code></pre> 
<blockquote> 
 <p><span style="color:#f33b45;">geo_polygon</span></p> 
</blockquote> 
<pre><code class="language-html hljs"># geo_polygon
POST /map/map/_search
{
  "query": {
    "geo_polygon": {
      "location": {
        "points": [                 # 指定多个点确定一个多边形
          {
            "lon": 116.298916,
            "lat": 39.99878
          },
          {
            "lon": 116.29561,
            "lat": 39.972576
          },
          {
            "lon": 116.327661,
            "lat": 39.984739
          }
        ]
      }
    }
  }
}</code></pre> 
<h3> <span style="color:#f33b45;">Java实现geo_polygon</span></h3> 
<pre><code class="language-java">// 基于Java实现geo_polygon查询
@Test
public void geoPolygon() throws IOException {
    //1. SearchRequest
    SearchRequest request = new SearchRequest(index);
    request.types(type);
​
    //2. 指定检索方式
    SearchSourceBuilder builder = new SearchSourceBuilder();
    List&lt;GeoPoint&gt; points = new ArrayList&lt;&gt;();
    points.add(new GeoPoint(39.99878,116.298916));
    points.add(new GeoPoint(39.972576,116.29561));
    points.add(new GeoPoint(39.984739,116.327661));
    builder.query(QueryBuilders.geoPolygonQuery("location",points));
​
    request.source(builder);
​
    //3. 执行查询
    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);
​
    //4. 输出结果
    for (SearchHit hit : resp.getHits().getHits()) {
        System.out.println(hit.getSourceAsMap());
    }
}</code></pre> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/da1a5192ce9692371ccc52185cb97d18/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">count(*)的理解（mysql45讲）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/51f345454a130603f7620e627a55e558/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">会计学原理学习笔记——第三章——账户与复式记账（3.2资金筹集业务的核算——借入资本的核算）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>