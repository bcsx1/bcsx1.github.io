<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构02附录01：顺序表考研习题[C&#43;&#43;] - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构02附录01：顺序表考研习题[C&#43;&#43;]" />
<meta property="og:description" content="图源：文心一言
考研笔记整理~🥝🥝
之前的博文链接在此：数据结构02：线性表[顺序表&#43;链表]_线性链表-CSDN博客~🥝🥝
本篇作为线性表的代码补充，每道题提供了优解和暴力解算法，供小伙伴们参考~🥝🥝
第1版：无情地Push Chat GPT老师写代码、分析GPT老师写的代码并思考弱智解~🧩🧩 编辑：梅头脑🌸
参考用书：王道考研《2024年 数据结构考研复习指导》
📇目录 📇目录
🧵2010统考真题
🧩题目
🌰优解 📇优解思路
⌨️优解代码
⌨️优解演算 🌰暴力解
📇暴力解思路
⌨️暴力解代码
⌨️暴力解演算
🧵2011统考真题
🧩题目
🌰优解 📇优解思路
⌨️优解代码
⌨️优解演算 🌰暴力解
📇暴力解思路
⌨️暴力解代码
⌨️暴力解演算
🧵2013统考真题
🧩题目
🌰优解 📇优解思路
⌨️优解代码
⌨️优解演算 🌰暴力解
📇暴力解思路
⌨️暴力解代码
⌨️暴力解演算
🧵2018统考真题
🧩题目
🌰优解 📇优解思路
⌨️优解代码
🧵2020统考真题
🧩题目
🌰优解 📇优解思路
⌨️优解代码
🌰暴力解
📇暴力解思路
⌨️暴力解代码
🔚结语
🧵2010统考真题 🧩题目 设将n个整数存放到一维数组R中。设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p个位置，即将R的数据由(X0，X1，…，Xn-1)变换为(Xp，Xp&#43;1，…Xn-1，X0，X1，…，Xp-1)。
🌰优解 📇优解思路 算法思想： 将数组p(n-p)转化为数组(n-p)p，(n-p)p=(p-1(n-p)-1)-1；因此分别反转前p项，后n-p项，最后整体反转p-1(n-p)-1；reverse函数用于反转数组中指定范围的元素，它通过交换两端的元素来实现反转。时间复杂度：O(n)，其中n是数组的长度，因为需要反转数组的两部分和整体数组。空间复杂度：O(1)，因为算法只使用了固定的额外空间来存储一些临时变量，与数组的长度无关。 ⌨️优解代码 #include &lt;iostream&gt; using namespace std; // 反转数组中指定范围的元素 void reverse(int arr[], int start, int end) { // 使用双指针法将数组中指定范围的元素进行反转 // start 指向要反转的范围的起始位置，end 指向要反转的范围的末尾位置 while (start &lt; end) { // 交换 start 和 end 位置的元素 int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; // 向中间移动双指针 start&#43;&#43;; end--; } } // 执行循环左移操作 void rotateLeft(int arr[], int n, int p) { // 将左移位数取模以确保它在数组长度范围内 p = p % n; if (p == 0) return; // 如果左移位数为0，直接返回，不需要进行操作 reverse(arr, 0, p - 1); // 反转前半部分 reverse(arr, p, n - 1); // 反转后半部分 reverse(arr, 0, n - 1); // 整体反转 } int main() { const int n = 10; // 数组长度为10 const int p = 3; // 左移3位 int arr[n] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; // 初始化数组元素 rotateLeft(arr, n, p); // 执行左移操作 // 输出结果 cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/ef19355fe78b78c5edb9276ce6266795/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-17T22:51:34+08:00" />
<meta property="article:modified_time" content="2023-11-17T22:51:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构02附录01：顺序表考研习题[C&#43;&#43;]</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p class="img-center"><img alt="" height="512" src="https://images2.imgbox.com/97/80/AHHpd51f_o.png" width="512"></p> 
<p style="text-align:center;">  图源：文心一言</p> 
<p>考研笔记整理~🥝🥝</p> 
<p style="margin-left:.0001pt;text-align:justify;">之前的博文链接在此：<a href="https://blog.csdn.net/weixin_42789937/article/details/130831265?spm=1001.2014.3001.5501" title="数据结构02：线性表[顺序表+链表]_线性链表-CSDN博客">数据结构02：线性表[顺序表+链表]_线性链表-CSDN博客</a>~🥝🥝</p> 
<p style="margin-left:.0001pt;text-align:justify;">本篇作为线性表的代码补充，每道题提供了优解和暴力解算法，供小伙伴们参考~🥝🥝</p> 
<ul><li>第1版：无情地Push Chat GPT老师写代码、分析GPT老师写的代码并思考弱智解~🧩🧩</li></ul> 
<p><strong>编辑：</strong>梅头脑🌸</p> 
<p><strong>参考用书：</strong><a href="https://so.csdn.net/so/search?q=%E7%8E%8B%E9%81%93&amp;spm=1001.2101.3001.7020" title="王道">王道</a>考研《2024年 数据结构考研复习指导》</p> 
<hr> 
<h2 id="%E7%9B%AE%E5%BD%95" style="background-color:transparent;">📇目录</h2> 
<p id="%E7%9B%AE%E5%BD%95-toc" style="margin-left:0px;"><a href="#%E7%9B%AE%E5%BD%95" rel="nofollow">📇目录</a></p> 
<p id="%F0%9F%A7%B5%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%F0%9F%A7%B5%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">🧵2010统考真题</a></p> 
<p id="%F0%9F%A7%A9%E9%A2%98%E7%9B%AE-toc" style="margin-left:40px;"><a href="#%F0%9F%A7%A9%E9%A2%98%E7%9B%AE" rel="nofollow">🧩题目</a></p> 
<p id="%F0%9F%8C%B0%E4%BC%98%E8%A7%A3%C2%A0-toc" style="margin-left:40px;"><a href="#%F0%9F%8C%B0%E4%BC%98%E8%A7%A3%C2%A0" rel="nofollow">🌰优解 </a></p> 
<p id="%F0%9F%93%87%E4%BC%98%E8%A7%A3%E6%80%9D%E8%B7%AF-toc" style="margin-left:80px;"><a href="#%F0%9F%93%87%E4%BC%98%E8%A7%A3%E6%80%9D%E8%B7%AF" rel="nofollow">📇优解思路</a></p> 
<p id="%C2%A0%E2%8C%A8%EF%B8%8F%E4%BC%98%E8%A7%A3%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%8C%A8%EF%B8%8F%E4%BC%98%E8%A7%A3%E4%BB%A3%E7%A0%81" rel="nofollow"> ⌨️优解代码</a></p> 
<p id="%C2%A0%E2%8C%A8%EF%B8%8F%E4%BC%98%E8%A7%A3%E6%BC%94%E7%AE%97%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%8C%A8%EF%B8%8F%E4%BC%98%E8%A7%A3%E6%BC%94%E7%AE%97%C2%A0" rel="nofollow"> ⌨️优解演算 </a></p> 
<p id="%F0%9F%8C%B0%E6%9A%B4%E5%8A%9B%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%F0%9F%8C%B0%E6%9A%B4%E5%8A%9B%E8%A7%A3" rel="nofollow">🌰暴力解</a></p> 
<p id="%F0%9F%93%87%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%80%9D%E8%B7%AF-toc" style="margin-left:80px;"><a href="#%F0%9F%93%87%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%80%9D%E8%B7%AF" rel="nofollow">📇暴力解思路</a></p> 
<p id="%E2%8C%A8%EF%B8%8F%E6%9A%B4%E5%8A%9B%E8%A7%A3%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E2%8C%A8%EF%B8%8F%E6%9A%B4%E5%8A%9B%E8%A7%A3%E4%BB%A3%E7%A0%81" rel="nofollow">⌨️暴力解代码</a></p> 
<p id="%C2%A0%E2%8C%A8%EF%B8%8F%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%BC%94%E7%AE%97-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%8C%A8%EF%B8%8F%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%BC%94%E7%AE%97" rel="nofollow">⌨️暴力解演算</a></p> 
<p id="%F0%9F%A7%B52011%E7%BB%9F%E8%80%83%E7%9C%9F%E9%A2%98-toc" style="margin-left:0px;"><a href="#%F0%9F%A7%B52011%E7%BB%9F%E8%80%83%E7%9C%9F%E9%A2%98" rel="nofollow">🧵2011统考真题</a></p> 
<p id="%F0%9F%A7%A9%E9%A2%98%E7%9B%AE-toc" style="margin-left:40px;"><a href="#%F0%9F%A7%A9%E9%A2%98%E7%9B%AE" rel="nofollow">🧩题目</a></p> 
<p id="%F0%9F%8C%B0%E4%BC%98%E8%A7%A3%C2%A0-toc" style="margin-left:40px;"><a href="#%F0%9F%8C%B0%E4%BC%98%E8%A7%A3%C2%A0" rel="nofollow">🌰优解 </a></p> 
<p id="%F0%9F%93%87%E4%BC%98%E8%A7%A3%E6%80%9D%E8%B7%AF-toc" style="margin-left:80px;"><a href="#%F0%9F%93%87%E4%BC%98%E8%A7%A3%E6%80%9D%E8%B7%AF" rel="nofollow">📇优解思路</a></p> 
<p id="%C2%A0%E2%8C%A8%EF%B8%8F%E4%BC%98%E8%A7%A3%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%8C%A8%EF%B8%8F%E4%BC%98%E8%A7%A3%E4%BB%A3%E7%A0%81" rel="nofollow"> ⌨️优解代码</a></p> 
<p id="%C2%A0%E2%8C%A8%EF%B8%8F%E4%BC%98%E8%A7%A3%E6%BC%94%E7%AE%97%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%8C%A8%EF%B8%8F%E4%BC%98%E8%A7%A3%E6%BC%94%E7%AE%97%C2%A0" rel="nofollow"> ⌨️优解演算 </a></p> 
<p id="%F0%9F%8C%B0%E6%9A%B4%E5%8A%9B%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%F0%9F%8C%B0%E6%9A%B4%E5%8A%9B%E8%A7%A3" rel="nofollow">🌰暴力解</a></p> 
<p id="%F0%9F%93%87%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%80%9D%E8%B7%AF-toc" style="margin-left:80px;"><a href="#%F0%9F%93%87%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%80%9D%E8%B7%AF" rel="nofollow">📇暴力解思路</a></p> 
<p id="%E2%8C%A8%EF%B8%8F%E6%9A%B4%E5%8A%9B%E8%A7%A3%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E2%8C%A8%EF%B8%8F%E6%9A%B4%E5%8A%9B%E8%A7%A3%E4%BB%A3%E7%A0%81" rel="nofollow">⌨️暴力解代码</a></p> 
<p id="%C2%A0%E2%8C%A8%EF%B8%8F%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%BC%94%E7%AE%97-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%8C%A8%EF%B8%8F%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%BC%94%E7%AE%97" rel="nofollow">⌨️暴力解演算</a></p> 
<p id="%F0%9F%A7%B52013%E7%BB%9F%E8%80%83%E7%9C%9F%E9%A2%98-toc" style="margin-left:0px;"><a href="#%F0%9F%A7%B52013%E7%BB%9F%E8%80%83%E7%9C%9F%E9%A2%98" rel="nofollow">🧵2013统考真题</a></p> 
<p id="%F0%9F%A7%A9%E9%A2%98%E7%9B%AE-toc" style="margin-left:40px;"><a href="#%F0%9F%A7%A9%E9%A2%98%E7%9B%AE" rel="nofollow">🧩题目</a></p> 
<p id="%F0%9F%8C%B0%E4%BC%98%E8%A7%A3%C2%A0-toc" style="margin-left:40px;"><a href="#%F0%9F%8C%B0%E4%BC%98%E8%A7%A3%C2%A0" rel="nofollow">🌰优解 </a></p> 
<p id="%F0%9F%93%87%E4%BC%98%E8%A7%A3%E6%80%9D%E8%B7%AF-toc" style="margin-left:80px;"><a href="#%F0%9F%93%87%E4%BC%98%E8%A7%A3%E6%80%9D%E8%B7%AF" rel="nofollow">📇优解思路</a></p> 
<p id="%C2%A0%E2%8C%A8%EF%B8%8F%E4%BC%98%E8%A7%A3%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%8C%A8%EF%B8%8F%E4%BC%98%E8%A7%A3%E4%BB%A3%E7%A0%81" rel="nofollow"> ⌨️优解代码</a></p> 
<p id="%C2%A0%E2%8C%A8%EF%B8%8F%E4%BC%98%E8%A7%A3%E6%BC%94%E7%AE%97%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%8C%A8%EF%B8%8F%E4%BC%98%E8%A7%A3%E6%BC%94%E7%AE%97%C2%A0" rel="nofollow"> ⌨️优解演算 </a></p> 
<p id="%F0%9F%8C%B0%E6%9A%B4%E5%8A%9B%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%F0%9F%8C%B0%E6%9A%B4%E5%8A%9B%E8%A7%A3" rel="nofollow">🌰暴力解</a></p> 
<p id="%F0%9F%93%87%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%80%9D%E8%B7%AF-toc" style="margin-left:80px;"><a href="#%F0%9F%93%87%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%80%9D%E8%B7%AF" rel="nofollow">📇暴力解思路</a></p> 
<p id="%E2%8C%A8%EF%B8%8F%E6%9A%B4%E5%8A%9B%E8%A7%A3%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E2%8C%A8%EF%B8%8F%E6%9A%B4%E5%8A%9B%E8%A7%A3%E4%BB%A3%E7%A0%81" rel="nofollow">⌨️暴力解代码</a></p> 
<p id="%C2%A0%E2%8C%A8%EF%B8%8F%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%BC%94%E7%AE%97-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%8C%A8%EF%B8%8F%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%BC%94%E7%AE%97" rel="nofollow">⌨️暴力解演算</a></p> 
<p id="%F0%9F%A7%B52018%E7%BB%9F%E8%80%83%E7%9C%9F%E9%A2%98-toc" style="margin-left:0px;"><a href="#%F0%9F%A7%B52018%E7%BB%9F%E8%80%83%E7%9C%9F%E9%A2%98" rel="nofollow">🧵2018统考真题</a></p> 
<p id="%F0%9F%A7%A9%E9%A2%98%E7%9B%AE-toc" style="margin-left:40px;"><a href="#%F0%9F%A7%A9%E9%A2%98%E7%9B%AE" rel="nofollow">🧩题目</a></p> 
<p id="%F0%9F%8C%B0%E4%BC%98%E8%A7%A3%C2%A0-toc" style="margin-left:40px;"><a href="#%F0%9F%8C%B0%E4%BC%98%E8%A7%A3%C2%A0" rel="nofollow">🌰优解 </a></p> 
<p id="%F0%9F%93%87%E4%BC%98%E8%A7%A3%E6%80%9D%E8%B7%AF-toc" style="margin-left:80px;"><a href="#%F0%9F%93%87%E4%BC%98%E8%A7%A3%E6%80%9D%E8%B7%AF" rel="nofollow">📇优解思路</a></p> 
<p id="%C2%A0%E2%8C%A8%EF%B8%8F%E4%BC%98%E8%A7%A3%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%8C%A8%EF%B8%8F%E4%BC%98%E8%A7%A3%E4%BB%A3%E7%A0%81" rel="nofollow"> ⌨️优解代码</a></p> 
<p id="%F0%9F%A7%B52020%E7%BB%9F%E8%80%83%E7%9C%9F%E9%A2%98-toc" style="margin-left:0px;"><a href="#%F0%9F%A7%B52020%E7%BB%9F%E8%80%83%E7%9C%9F%E9%A2%98" rel="nofollow">🧵2020统考真题</a></p> 
<p id="%F0%9F%A7%A9%E9%A2%98%E7%9B%AE-toc" style="margin-left:40px;"><a href="#%F0%9F%A7%A9%E9%A2%98%E7%9B%AE" rel="nofollow">🧩题目</a></p> 
<p id="%F0%9F%8C%B0%E4%BC%98%E8%A7%A3%C2%A0-toc" style="margin-left:40px;"><a href="#%F0%9F%8C%B0%E4%BC%98%E8%A7%A3%C2%A0" rel="nofollow">🌰优解 </a></p> 
<p id="%F0%9F%93%87%E4%BC%98%E8%A7%A3%E6%80%9D%E8%B7%AF-toc" style="margin-left:80px;"><a href="#%F0%9F%93%87%E4%BC%98%E8%A7%A3%E6%80%9D%E8%B7%AF" rel="nofollow">📇优解思路</a></p> 
<p id="%C2%A0%E2%8C%A8%EF%B8%8F%E4%BC%98%E8%A7%A3%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%8C%A8%EF%B8%8F%E4%BC%98%E8%A7%A3%E4%BB%A3%E7%A0%81" rel="nofollow"> ⌨️优解代码</a></p> 
<p id="%F0%9F%8C%B0%E6%9A%B4%E5%8A%9B%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%F0%9F%8C%B0%E6%9A%B4%E5%8A%9B%E8%A7%A3" rel="nofollow">🌰暴力解</a></p> 
<p id="%F0%9F%93%87%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%80%9D%E8%B7%AF-toc" style="margin-left:80px;"><a href="#%F0%9F%93%87%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%80%9D%E8%B7%AF" rel="nofollow">📇暴力解思路</a></p> 
<p id="%E2%8C%A8%EF%B8%8F%E6%9A%B4%E5%8A%9B%E8%A7%A3%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E2%8C%A8%EF%B8%8F%E6%9A%B4%E5%8A%9B%E8%A7%A3%E4%BB%A3%E7%A0%81" rel="nofollow">⌨️暴力解代码</a></p> 
<p id="%F0%9F%94%9A%E7%BB%93%E8%AF%AD-toc" style="margin-left:0px;"><a href="#%F0%9F%94%9A%E7%BB%93%E8%AF%AD" rel="nofollow">🔚结语</a></p> 
<hr> 
<h2 id="%F0%9F%A7%B5%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><strong>🧵</strong>2010统考真题</h2> 
<h3 id="%F0%9F%A7%A9%E9%A2%98%E7%9B%AE">🧩题目</h3> 
<blockquote> 
 <p>设将n个整数存放到一维数组R中。设计一个在时间和空间两方面都尽可能高效的算法。<strong>将R中保存的序列循环左移p个位置</strong>，即将R的数据由(X0，X1，…，Xn-1)变换为(Xp，Xp+1，…Xn-1，X0，X1，…，Xp-1)。</p> 
</blockquote> 
<h3 id="%F0%9F%8C%B0%E4%BC%98%E8%A7%A3%C2%A0"><strong>🌰优解</strong> </h3> 
<h4 id="%F0%9F%93%87%E4%BC%98%E8%A7%A3%E6%80%9D%E8%B7%AF">📇优解思路</h4> 
<blockquote> 
 <ul><li style="text-align:justify;"><strong>算法思想：</strong> 
   <ul><li style="text-align:justify;">将数组p(n-p)转化为数组(n-p)p，(n-p)p=(p-1(n-p)-1)-1；</li><li style="text-align:justify;">因此分别反转前p项，后n-p项，最后整体反转p-1(n-p)-1；</li><li style="text-align:justify;">reverse函数用于反转数组中指定范围的元素，它通过交换两端的元素来实现反转。</li></ul></li><li style="text-align:justify;"><strong>时间复杂度：</strong>O(n)，其中n是数组的长度，因为需要反转数组的两部分和整体数组。</li><li style="text-align:justify;"><strong>空间复杂度：</strong>O(1)，因为算法只使用了固定的额外空间来存储一些临时变量，与数组的长度无关。</li></ul> 
</blockquote> 
<h4 id="%C2%A0%E2%8C%A8%EF%B8%8F%E4%BC%98%E8%A7%A3%E4%BB%A3%E7%A0%81"> <strong>⌨️</strong>优解<strong>代码</strong></h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// 反转数组中指定范围的元素
void reverse(int arr[], int start, int end) {
    // 使用双指针法将数组中指定范围的元素进行反转
    // start 指向要反转的范围的起始位置，end 指向要反转的范围的末尾位置

    while (start &lt; end) {
        // 交换 start 和 end 位置的元素
        int temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;

        // 向中间移动双指针
        start++;
        end--;
    }
}

// 执行循环左移操作
void rotateLeft(int arr[], int n, int p) {
    // 将左移位数取模以确保它在数组长度范围内
    p = p % n;
    if (p == 0) return; // 如果左移位数为0，直接返回，不需要进行操作
    reverse(arr, 0, p - 1); // 反转前半部分
    reverse(arr, p, n - 1); // 反转后半部分
    reverse(arr, 0, n - 1); // 整体反转
}

int main() {
    const int n = 10; // 数组长度为10
    const int p = 3; // 左移3位

    int arr[n] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; // 初始化数组元素

    rotateLeft(arr, n, p); // 执行左移操作

    // 输出结果
    cout &lt;&lt; "左移后的数组为: ";
    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    }

    return 0;
}</code></pre> 
<p><img alt="" height="202" src="https://images2.imgbox.com/29/1e/KfoBQXJS_o.png" width="1200"></p> 
<h4 id="%C2%A0%E2%8C%A8%EF%B8%8F%E4%BC%98%E8%A7%A3%E6%BC%94%E7%AE%97%C2%A0"> <strong>⌨️优解演算</strong> </h4> 
<blockquote> 
 <ul><li>初始轮 arr[n] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; temp = NULL；</li><li>第一轮 arr[n] = {2, 1, 0, 3, 4, 5, 6, 7, 8, 9}; temp = 0；</li><li>第二轮 arr[n] = {2, 1, 0, 9, 8, 7, 6, 5, 4, 3}; temp = 3；temp = 4；temp = 5；</li><li>第三轮 arr[n] = {3, 4, 5, 6, 7, 8, 9, 0, 1, 2}; temp = 2；temp = 1；temp = 0；temp = 9；temp = 8；</li></ul> 
</blockquote> 
<h3 id="%F0%9F%8C%B0%E6%9A%B4%E5%8A%9B%E8%A7%A3"><strong>🌰</strong>暴力解</h3> 
<h4 id="%F0%9F%93%87%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%80%9D%E8%B7%AF">📇暴力解思路</h4> 
<blockquote> 
 <ul><li style="text-align:justify;"><strong>算法思想：</strong> 
   <ul><li style="text-align:justify;">创建一个临时数组 temp，用于存储前p个元素。</li><li style="text-align:justify;">将后面的元素向前移动p个位置，留出前p个位置用于粘贴临时数组的内容。</li><li style="text-align:justify;">将临时数组中的元素复制回原数组的末尾。</li></ul></li><li style="text-align:justify;"><strong>时间复杂度：</strong>O(n)，因为我们额外使用了一个临时数组 temp 来存储前p个元素。这个临时数组的大小与左移的位数p相等，因此空间复杂度是O(p)，而在最坏情况下，p可以等于n，所以空间复杂度可以达到O(n)。</li><li style="text-align:justify;"><strong>空间复杂度：</strong>O(n)，理由同上。</li></ul> 
</blockquote> 
<h4 id="%E2%8C%A8%EF%B8%8F%E6%9A%B4%E5%8A%9B%E8%A7%A3%E4%BB%A3%E7%A0%81"><strong>⌨️</strong>暴力解<strong>代码</strong></h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void rotateLeft(int arr[], int n, int p) {
    int temp[p]; // 创建一个临时数组用于存储前p个元素

    // 复制前p个元素到临时数组中
    for (int i = 0; i &lt; p; i++) {
        temp[i] = arr[i];
    }

    // 将后面的元素向前移动p个位置
    for (int i = p; i &lt; n; i++) {
        arr[i - p] = arr[i];
    }

    // 将临时数组中的元素复制回原数组末尾
    for (int i = 0; i &lt; p; i++) {
        arr[n - p + i] = temp[i];
    }
}

int main() {
    const int n = 10; // 数组长度为10
    const int p = 3; // 左移3位

    int arr[n] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; // 初始化数组元素

    rotateLeft(arr, n, p); // 执行左移操作

    // 输出结果
    cout &lt;&lt; "左移后的数组为: ";
    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    }

    return 0;
}</code></pre> 
<p><img alt="" height="202" src="https://images2.imgbox.com/28/c9/yU8e3sBW_o.png" width="1200"></p> 
<h4 id="%C2%A0%E2%8C%A8%EF%B8%8F%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%BC%94%E7%AE%97" style="background-color:transparent;"><strong>⌨️暴力解演算</strong></h4> 
<blockquote> 
 <ul><li>初始轮 arr[n] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; temp[p] = NULL；</li><li>第一轮 arr[n] = {2, 1, 0, 3, 4, 5, 6, 7, 8, 9}; temp[p] = {2, 1, 0}；</li><li>第二轮 arr[n] = {3, 4, 5, 6, 7, 8, 9, 7, 8, 9}; temp[p] = {2, 1, 0}；</li><li>第三轮 arr[n] = {3, 4, 5, 6, 7, 8, 9, 0, 1, 2}; temp[p] = {2, 1, 0}；</li></ul> 
</blockquote> 
<p></p> 
<hr> 
<h2 id="%F0%9F%A7%B52011%E7%BB%9F%E8%80%83%E7%9C%9F%E9%A2%98"><strong>🧵</strong>2011统考真题</h2> 
<h3>🧩题目</h3> 
<blockquote> 
 <p>一个长度为L的升序序列S，处在第[L/2]个位置的元素称为S的中位数。例如，若序列S1=（11,13,15,17,19），则S1的中位数是15，<strong>两个序列的中位数是他们所有元素的升序序列的中位数。</strong>例如若S2=（2,4,6,8,10），则S1和S2的中位数是11。现在有两个等长的升序序列A和B，试设计在一个时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。</p> 
</blockquote> 
<h3><strong>🌰优解</strong> </h3> 
<h4>📇优解思路</h4> 
<blockquote> 
 <ul><li style="text-align:justify;"><strong>算法思想：</strong> 
   <ul><li style="text-align:justify;">检查A和B的中间位置的元素，分别记为a_mid和b_mid。 
     <ul><li style="text-align:justify;"> <p>如果a_mid等于b_mid，那么它们就是两个序列的中位数，直接返回a_mid或b_mid都可以。</p> </li><li style="text-align:justify;"> <p>如果a_mid小于b_mid，说明A的中位数位于A的后半部分和B的前半部分之间，将A的前半部分和B的后半部分丢弃，继续在剩下的部分中查找中位数。</p> </li><li style="text-align:justify;"> <p>如果a_mid大于b_mid，说明B的中位数位于B的后半部分和A的前半部分之间，将B的前半部分和A的后半部分丢弃，继续在剩下的部分中查找中位数。</p> </li></ul></li><li style="text-align:justify;">重复上述步骤，直到找到中位数。</li></ul></li><li style="text-align:justify;"><strong>时间复杂度：</strong>O(log(min(La, Lb)))，其中La和Lb分别是序列A和B的长度。这是因为在每一步中，我们都将输入规模减少一半。</li><li style="text-align:justify;"><strong>空间复杂度：</strong>O(1)，因为它只使用了一些变量来存储中间结果，而不需要额外的数据结构。</li><li style="text-align:justify;"><strong>备注：</strong>这段程序好像不能在网上的在线编译器跑，会显示“‘INT_MIN’ was not declared in this scope”。</li></ul> 
</blockquote> 
<h4> <strong>⌨️</strong>优解<strong>代码</strong></h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// 函数：findMedianSortedArrays
// 参数：两个升序数组A和B，以及它们的长度La和Lb
// 返回值：两个数组的中位数
double findMedianSortedArrays(int A[], int B[], int La, int Lb) {
    // 确保La小于等于Lb，方便后续处理
    if (La &gt; Lb) {
        swap(A, B);
        swap(La, Lb);
    }

    // 初始化左边界和右边界，以及两数组的中位数的位置（结果向下取整）
    int left = 0, right = La;
    int halfLen = (La + Lb + 1) / 2;

    // 使用二分查找在数组A中找到合适的位置
    while (left &lt; right) {
        int i = left + (right - left) / 2;
        int j = halfLen - i;

        int round = 1;
        // cout &lt;&lt; "Round " &lt;&lt; round++ &lt;&lt; ":" &lt;&lt; endl;
        // cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; ", j = " &lt;&lt; j &lt;&lt; endl;

        // 通过比较A[i]和B[j-1]来调整i的位置
        if (A[i] &lt; B[j - 1])
            left = i + 1;
        else
            right = i;

        // cout &lt;&lt; "After comparison, left = " &lt;&lt; left &lt;&lt; ", right = " &lt;&lt; right &lt;&lt; endl &lt;&lt; endl;
    }

    // 计算中位数所在的位置
    int i = left, j = halfLen - left;

    // 计算四个关键值，用于求解中位数
    int AleftMax = (i == 0) ? INT_MIN : A[i - 1];   //如果i等于0（也就是A的左边界），那么将AleftMax设为整型的最小值 INT_MIN（通常是-2147483648）。否则，将AleftMax设为A中下标为i-1的元素的值。
    int ArightMin = (i == La) ? INT_MAX : A[i];
    int BleftMax = (j == 0) ? INT_MIN : B[j - 1];
    int BrightMin = (j == Lb) ? INT_MAX : B[j];

    // cout &lt;&lt; "Final values:" &lt;&lt; endl;
    // cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; ", j = " &lt;&lt; j &lt;&lt; endl;
    // cout &lt;&lt; "AleftMax = " &lt;&lt; AleftMax &lt;&lt; ", ArightMin = " &lt;&lt; ArightMin &lt;&lt; endl;
    // cout &lt;&lt; "BleftMax = " &lt;&lt; BleftMax &lt;&lt; ", BrightMin = " &lt;&lt; BrightMin &lt;&lt; endl;

    // 根据数组总长度的奇偶性返回中位数
    if ((La + Lb) % 2 == 1)
        return max(AleftMax, BleftMax);
    else
        return (max(AleftMax, BleftMax) + min(ArightMin, BrightMin)) / 2.0;
}

int main() {
    int A[] = {11, 13, 15, 17, 19}; // 第一个升序数组
    int B[] = {2, 4, 6, 8, 20};    // 第二个升序数组
    int La = sizeof(A) / sizeof(A[0]); // 第一个数组的长度，将数组占用内存的总字节数除以第一个元素占用的字节数，我们得到了数组中元素的个数，也就是数组的长度。
    int Lb = sizeof(B) / sizeof(B[0]); // 第二个数组的长度

    double median = findMedianSortedArrays(A, B, La, Lb); // 调用函数计算中位数

    cout &lt;&lt; "中位数是: " &lt;&lt; median &lt;&lt; endl; // 输出中位数

    return 0;
}</code></pre> 
<p><img alt="" height="275" src="https://images2.imgbox.com/92/a0/bHiQXp0J_o.png" width="1200"></p> 
<h4> <strong>⌨️优解演算</strong> </h4> 
<blockquote> 
 <ul><li> <p>初始：<br> int A[] = {11, 13, 15, 17, 19};<br> int B[] = {2, 4, 6, 8, 20};<br> int La = 5;<br> int Lb = 5;<br> halfLen = (La + Lb + 1) / 2 = (5 + 5 + 1) / 2 = 11 / 2 = 5;<br> left = 0;<br> right = La = 5;</p> <p></p> </li><li> <p>第一轮循环：<br> i = 0 + ( 5 - 0 ) / 2 = 2, j = 5 - 2 = 3;<br> A[i = 2] = 15, B[j - 1 = 2] = 6;<br> A[i] 大于 B[j - 1]，所以更新 right = i = 2</p> <p></p> </li><li> <p>第二轮循环：<br> i = 0 + ( 2 - 0 ) / 2 = 1, j = 5 - 1 = 4;<br> A[i = 1] = 13, B[4 - 1 = 3] = 8;<br> A[i] 大于 B[j - 1]，所以更新 right = i = 1</p> <p></p> </li><li> <p>第三轮循环：<br> i = 0 + ( 1 - 0 ) / 2 = 0, j = 5 - 0 = 5;<br> A[i = 0] = 11, B[5 - 1 = 4] = 20;<br> A[i] 小于 B[j - 1]，所以更新 left = j = 1</p> <p></p> </li><li> <p>不满足while循环条件，跳出:<br> i = j = 1; j = 5-1 = 4;<br> AleftMax = A[i-1] = 11, ArightMin = A[1] = 13；<br> BleftMax = B[j-1] = 8, BrightMin = B[j] = 20；</p> <p>(La + Lb) % 2 = (5 + 5) % 2 = 10 % 2 = 0;<br> max(AleftMax, BleftMax) + min(ArightMin, BrightMin)) / 2.0 = max(11+13)/2 =12</p> </li></ul> 
</blockquote> 
<h3><strong>🌰</strong>暴力解</h3> 
<h4>📇暴力解思路</h4> 
<blockquote> 
 <ul><li style="text-align:justify;"><strong>算法思想：</strong>将两个数组合并后排序，然后找到合并后数组的中位数；</li><li style="text-align:justify;"><strong>时间复杂度：</strong>O(La + Lb)；</li><li style="text-align:justify;"><strong>空间复杂度：</strong>O(La + Lb)；</li></ul> 
</blockquote> 
<h4><strong>⌨️</strong>暴力解<strong>代码</strong></h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

double findMedianSortedArrays(int A[], int B[], int La, int Lb) {
    // 将数组A和数组B合并到一个新的数组C中
    vector&lt;int&gt; C;
    int i = 0, j = 0;
    while (i &lt; La &amp;&amp; j &lt; Lb) {
        if (A[i] &lt;= B[j]) {
            C.push_back(A[i]);
            i++;
        } else {
            C.push_back(B[j]);
            j++;
        }
    }
    while (i &lt; La) {
        C.push_back(A[i]);
        i++;
    }
    while (j &lt; Lb) {
        C.push_back(B[j]);
        j++;
    }

    // 计算合并后数组C的长度
    int Lc = C.size();

    // 计算中位数的位置
    int mid = Lc / 2;

    if (Lc % 2 == 1) {
        return C[mid];
    } else {
        return (C[mid - 1] + C[mid]) / 2.0;
    }
}

int main() {
    int A[] = {11, 13, 15, 17, 19};
    int B[] = {2, 4, 6, 8, 20};
    int La = sizeof(A) / sizeof(A[0]);
    int Lb = sizeof(B) / sizeof(B[0]);

    double median = findMedianSortedArrays(A, B, La, Lb);

    cout &lt;&lt; "中位数是: " &lt;&lt; median &lt;&lt; endl;

    return 0;
}</code></pre> 
<h4 style="background-color:transparent;"><strong>⌨️暴力解演算</strong></h4> 
<blockquote> 
 <ul><li>int A[] = {11, 13, 15, 17, 19};  int B[] = {2, 4, 6, 8, 20};</li><li>vector&lt;int&gt; C = {2, 4, 6, 8, 11, 13, 15, 17, 19};<br> Lc = （C[4 ]+ C[5]）/2 = 12;</li></ul> 
</blockquote> 
<p></p> 
<hr> 
<h2 id="%F0%9F%A7%B52013%E7%BB%9F%E8%80%83%E7%9C%9F%E9%A2%98" style="background-color:transparent;"><strong>🧵</strong>2013统考真题</h2> 
<h3>🧩题目</h3> 
<blockquote> 
 <p>已知一个整数序列A=（a0，a1，…，an）,其中0≤ai≤n。<strong>若存在ap1=ap2=…=apm=x 且 m &gt; n/2 (0≤pk＜n，1≤k≤m)，则称x为A的主元素。</strong>例如A=（0,5,5,3,5,7,5,5），则5为主元素；又如A=（0,5,5,3,5,1,5,7），则A中没有主元素。假设A中的n个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出A的主元素。若存在主元素，则输出该元素；否则输出-1。</p> 
</blockquote> 
<h3><strong>🌰优解</strong> </h3> 
<h4>📇优解思路</h4> 
<blockquote> 
 <ul><li style="text-align:justify;"><strong>算法思想：</strong>"摩尔投票算法" 
   <ul><li style="text-align:justify;">遍历数组并维护一个候选主元素以及一个计数器；</li><li style="text-align:justify;">在遍历过程中，如果计数器为零，就将当前元素设为候选主元素；否则，如果当前元素与候选主元素相同，计数器增加，否则计数器减少。最后剩下的候选主元素可能就是主元素；</li><li style="text-align:justify;">但还需要再次遍历数组确认它是否真的满足主元素的条件。</li></ul></li><li style="text-align:justify;"><strong>时间复杂度：</strong>O(n)，其中n是输入数组的长度。算法需要进行两次遍历，每次遍历的时间复杂度都是O(n)。</li><li style="text-align:justify;"><strong>空间复杂度：</strong>O(1)，因为它只使用了常数级别的额外空间来存储候选主元素和计数器，而不随输入规模变化。</li></ul> 
</blockquote> 
<h4> <strong>⌨️</strong>优解<strong>代码</strong></h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int findMajorityElement(int A[], int n) {
    int candidate = -1;
    int count = 0;

    // 第一轮遍历，选出候选主元素
    for (int i = 0; i &lt; n; i++) {
        // cout &lt;&lt; "candidate = A[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; candidate &lt;&lt; ", count = " &lt;&lt; count &lt;&lt; endl;
        if (count == 0) {
            candidate = A[i];
            count = 1;
        } else {
            if (A[i] == candidate) {
                count++;
            } else {
                count--;
            }
        }
    }

    // 第二轮遍历，确认候选主元素是否真的是主元素
    count = 0;
    for (int i = 0; i &lt; n; i++) {
        if (A[i] == candidate) {
            count++;
        }
    }

    // cout &lt;&lt; "count = " &lt;&lt; count &lt;&lt; endl;
    if (count &gt; n / 2) {
        return candidate;
    } else {
        return -1;
    }
}

int main() {
    int A[] = {0, 5, 5, 3, 5, 7, 5, 5};
    int B[] = {0, 5, 5, 3, 5, 1, 5, 7};
    int La = sizeof(A) / sizeof(A[0]);
    int Lb = sizeof(B) / sizeof(B[0]);

    int resultA = findMajorityElement(A, La);
    int resultB = findMajorityElement(B, Lb);

    if (resultA != -1) {
        cout &lt;&lt; "数组A的主元素是：" &lt;&lt; resultA &lt;&lt; endl;
    } else {
        cout &lt;&lt; "数组A没有主元素" &lt;&lt; endl;
    }

    if (resultB != -1) {
        cout &lt;&lt; "数组B的主元素是：" &lt;&lt; resultB &lt;&lt; endl;
    } else {
        cout &lt;&lt; "数组B没有主元素" &lt;&lt; endl;
    }

    return 0;
}</code></pre> 
<p><img alt="" height="226" src="https://images2.imgbox.com/36/87/01QEHfkV_o.png" width="1200"></p> 
<h4> <strong>⌨️优解演算</strong> </h4> 
<blockquote> 
 <ul><li> <p>数组A<br> candidate = A[0] = -1, count = 0<br> candidate = A[1] = 0, count = 1<br> candidate = A[2] = 0, count = 0<br> candidate = A[3] = 5, count = 1<br> candidate = A[4] = 5, count = 0<br> candidate = A[5] = 5, count = 1<br> candidate = A[6] = 5, count = 0<br> candidate = A[7] = 5, count = 1<br> count = 5，count ＞ 8/2</p> <p></p> </li><li> <p>数组B<br> candidate = A[0] = -1, count = 0<br> candidate = A[1] = 0, count = 1<br> candidate = A[2] = 0, count = 0<br> candidate = A[3] = 5, count = 1<br> candidate = A[4] = 5, count = 0<br> candidate = A[5] = 5, count = 1<br> candidate = A[6] = 5, count = 0<br> candidate = A[7] = 5, count = 1<br> count = 4，count ≤ 8/2</p> </li></ul> 
</blockquote> 
<h3><strong>🌰</strong>暴力解</h3> 
<h4>📇暴力解思路</h4> 
<blockquote> 
 <ul><li style="text-align:justify;"><strong>算法思想：</strong> 
   <ul><li style="text-align:justify;">统计每种元素的出现次数，然后找到出现次数最多的元素。</li><li style="text-align:justify;">第一遍遍历数组，统计每种元素的出现次数，可以使用一个哈希表或者数组来存储。</li><li style="text-align:justify;">第二遍遍历统计结果，找到出现次数最多的元素。</li><li style="text-align:justify;">检查该元素的出现次数是否大于总长度除以2，如果满足条件，则它是主元素，否则不存在主元素。</li></ul></li><li style="text-align:justify;"><strong>时间复杂度：</strong>O(n)，其中n是输入数组的长度。</li><li style="text-align:justify;"><strong>空间复杂度：</strong>O(n)，取决于不同元素的数量，最坏情况下可能会达到O(n)。</li></ul> 
</blockquote> 
<h4><strong>⌨️</strong>暴力解<strong>代码</strong></h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
using namespace std;

int findMajorityElement(int A[], int n) {
    // 使用哈希表 counter 统计每个元素的出现次数
    unordered_map&lt;int, int&gt; counter;

    // 第一次遍历，统计每个元素的出现次数
    for (int i = 0; i &lt; n; i++) {
        counter[A[i]]++;
    }

    // 测试：输出哈希表的值
    // cout &lt;&lt; "Counter:" &lt;&lt; endl;
    // for (auto&amp; pair : counter) {
    //     cout &lt;&lt; pair.first &lt;&lt; ": " &lt;&lt; pair.second &lt;&lt; endl;
    // }

    // 找到出现次数最多的元素
    int maxCount = 0;
    int majorityElement = -1;

    for (auto&amp; pair : counter) {           // 声明一个名为 pair 的变量，它的类型会根据 counter 中的元素类型自动推断（因为我们使用了 auto）。pair 实际上是一个键值对，包括一个键（pair.first）和一个值（pair.second）。

        // 测试：输出所有参数的值
        // cout &lt;&lt; "pair.first = " &lt;&lt; pair.first &lt;&lt; ", pair.second = " &lt;&lt; pair.second &lt;&lt; endl;
        // cout &lt;&lt; "maxCount = " &lt;&lt; maxCount &lt;&lt; ", majorityElement = " &lt;&lt; majorityElement &lt;&lt; endl;

        if (pair.second &gt; maxCount) {       // 比较当前键值对的值（也就是元素出现的次数 pair.second）和 maxCount 的大小
            maxCount = pair.second;         // 如果当前元素出现的次数大于 maxCount，则更新 maxCount 和 majorityElement
            majorityElement = pair.first;   // 将当前元素作为候选主元素
        }
    }


    // 检查出现次数是否大于总长度的一半
    if (maxCount &gt; n / 2) {
        return majorityElement;
    } else {
        return -1;
    }
}

int main() {
    int A[] = {0, 5, 5, 3, 5, 7, 5, 5};
    int B[] = {0, 5, 5, 3, 5, 1, 5, 7};
    int La = sizeof(A) / sizeof(A[0]);
    int Lb = sizeof(B) / sizeof(B[0]);

    int resultA = findMajorityElement(A, La);
    int resultB = findMajorityElement(B, Lb);

    if (resultA != -1) {
        cout &lt;&lt; "数组A的主元素是：" &lt;&lt; resultA &lt;&lt; endl;
    } else {
        cout &lt;&lt; "数组A没有主元素" &lt;&lt; endl;
    }

    if (resultB != -1) {
        cout &lt;&lt; "数组B的主元素是：" &lt;&lt; resultB &lt;&lt; endl;
    } else {
        cout &lt;&lt; "数组B没有主元素" &lt;&lt; endl;
    }

    return 0;
}</code></pre> 
<h4 style="background-color:transparent;"><strong>⌨️暴力解演算</strong></h4> 
<blockquote> 
 <ul><li>数组A模拟：<br> Counter:<br> 3: 1<br> 7: 1<br> 0: 1<br> 5: 5<br> pair.first = 3, pair.second = 1<br> maxCount = 0, majorityElement = -1<br> pair.first = 7, pair.second = 1<br> maxCount = 1, majorityElement = 3<br> pair.first = 0, pair.second = 1<br> maxCount = 1, majorityElement = 3<br> pair.first = 5, pair.second = 5<br> maxCount = 1, majorityElement = 3<br> 数组A的主元素是：5</li></ul> 
 <p></p> 
 <ul><li>数组B模拟：<br> Counter:<br> 1: 1<br> 3: 1<br> 7: 1<br> 0: 1<br> 5: 4<br> pair.first = 1, pair.second = 1<br> maxCount = 0, majorityElement = -1<br> pair.first = 3, pair.second = 1<br> maxCount = 1, majorityElement = 1<br> pair.first = 7, pair.second = 1<br> maxCount = 1, majorityElement = 1<br> pair.first = 0, pair.second = 1<br> maxCount = 1, majorityElement = 1<br> pair.first = 5, pair.second = 4<br> maxCount = 1, majorityElement = 1<br> 数组B没有主元素</li></ul> 
</blockquote> 
<hr> 
<h2 id="%F0%9F%A7%B52018%E7%BB%9F%E8%80%83%E7%9C%9F%E9%A2%98" style="background-color:transparent;"><strong>🧵</strong>2018统考真题</h2> 
<h3>🧩题目</h3> 
<blockquote> 
 <p>给定一个含n个整数的数组，请设计一个在时间上尽可能高效的算法，<strong>找出数组中未出现的最小正整数。</strong>例如，数组{-5,3,2,3}中未出现的最小正整数是1，数组{1,2,3}中未出现的最小正整数是4。</p> 
</blockquote> 
<h3><strong>🌰优解</strong> </h3> 
<h4 style="background-color:transparent;">📇优解思路</h4> 
<blockquote> 
 <ul><li style="text-align:justify;"><strong>算法思想：</strong>"哈希表标记" 
   <ul><li style="text-align:justify;">利用数组本身来进行标记，将数组元素放置到其对应的位置上；</li><li style="text-align:justify;">然后再遍历一次数组找出第一个不符合规则的位置，即未出现的最小正整数。</li></ul></li><li style="text-align:justify;"><strong>时间复杂度：</strong>O(n)，因为最多需要遍历两次数组。</li><li style="text-align:justify;"><strong>空间复杂度：</strong>O(n)，使用了一个大小与输入数组相同的数组进行操作，因此空间复杂度是线性的，与输入数组的大小成正比。</li><li style="text-align:justify;"><strong>备注：</strong>这个算法思想应该还是挺容易想到的，因此没有暴力解。</li></ul> 
</blockquote> 
<h4> <strong>⌨️</strong>优解<strong>代码</strong></h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();

    // 将数组元素放置到其对应的位置上
    for (int i = 0; i &lt; n; ++i) {
        while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i]) {
            swap(nums[i], nums[nums[i] - 1]);
        }
    }

    // 再次遍历数组，找出第一个不符合规则的位置
    for (int i = 0; i &lt; n; ++i) {
        if (nums[i] != i + 1) {
            return i + 1;
        }
    }

    return n + 1; // 如果数组本身符合规则，则返回数组长度加1
}

int main() {
    vector&lt;int&gt; arr1 = {-5, 3, 2, 3};
    vector&lt;int&gt; arr2 = {1, 2, 3};

    int missing1 = firstMissingPositive(arr1);
    int missing2 = firstMissingPositive(arr2);

    cout &lt;&lt; "数组{-5, 3, 2, 3}中未出现的最小正整数是：" &lt;&lt; missing1 &lt;&lt; endl;
    cout &lt;&lt; "数组{1, 2, 3}中未出现的最小正整数是：" &lt;&lt; missing2 &lt;&lt; endl;

    return 0;
}</code></pre> 
<p><img alt="" height="226" src="https://images2.imgbox.com/22/c4/iPoQMNqG_o.png" width="1200"></p> 
<hr> 
<h2 id="%F0%9F%A7%B52020%E7%BB%9F%E8%80%83%E7%9C%9F%E9%A2%98"><strong>🧵</strong>2020统考真题</h2> 
<h3>🧩题目</h3> 
<blockquote> 
 <p>定义<strong>三元组(a,b,c)(a,b,c均为整数)的距离D=|a-b| + |b-c| + |c-a|</strong>。给定3个非空整数集合S1、S2和S3，按升序分别存储在3个数组中。请设计一个尽可能高效的算法，计算并输出所有可能得三元组(a,b,c)(a∈S1，b∈S2，c∈S3)中的最小距离、例如S1={-1,0,9}，S2={-25,-10,-10,11}，S3={2,9,17,30,41}，则最小距离为2，相应的三元组为(9,10,9)。</p> 
</blockquote> 
<h3><strong>🌰优解</strong> </h3> 
<h4>📇优解思路</h4> 
<blockquote> 
 <ul><li style="text-align:justify;"><strong>通用思路：</strong>在求解距离的问题中，通常的做法是通过遍历或者适当的比较来不断更新最小值。这种方法通常会在处理多个元素之间的关系时有效，尤其是在找到最小值或最大值时。</li><li style="text-align:justify;"><strong>算法思想：</strong> 
   <ul><li style="text-align:justify;">选择S1、S2和S3中的一个数作为其中一个元素（比如选择S1中的元素作为a）；</li><li style="text-align:justify;">然后在S2和S3中使用两个指针分别找到与a最接近的b和c，从而计算距离，并维护最小距离；</li></ul></li><li style="text-align:justify;"><strong>时间复杂度：</strong>O(n)，emm...如果忽略那段蠢萌的vector输出的话；</li><li style="text-align:justify;"><strong>空间复杂度：</strong>O(1)，除了用于存储输入数组外，算法中没有使用额外的辅助空间。</li></ul> 
</blockquote> 
<h4> <strong>⌨️</strong>优解<strong>代码</strong></h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;  // 在本示例中，INT_MAX 和 INT_MIN 分别用于初始化最小距离变量为最大可能值，以便在计算距离时进行比较，并找到最小值。
using namespace std;

int minDistanceTriplet(vector&lt;int&gt;&amp; S1, vector&lt;int&gt;&amp; S2, vector&lt;int&gt;&amp; S3) {
    int minDistance = INT_MAX;
    int i = 0, j = 0, k = 0;
    int size1 = S1.size(), size2 = S2.size(), size3 = S3.size();

    while (i &lt; size1 &amp;&amp; j &lt; size2 &amp;&amp; k &lt; size3) {
        int a = S1[i], b = S2[j], c = S3[k];
        int currentDistance = abs(a - b) + abs(b - c) + abs(c - a);
        minDistance = min(minDistance, currentDistance);

        // 找到与当前 a 最接近的 b
        if (a &lt;= b &amp;&amp; a &lt;= c) {
            i++;
        } else if (b &lt;= a &amp;&amp; b &lt;= c) {
            j++;
        } else {
            k++;
        }
    }

    return minDistance;
}

void printTriplet(int a, int b, int c) {
    cout &lt;&lt; "三元组为: (" &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; ", " &lt;&lt; c &lt;&lt; ")" &lt;&lt; endl;
}

int main() {
    vector&lt;int&gt; S1 = {-1, 0, 9};
    vector&lt;int&gt; S2 = {-25, -10, 10, 11};
    vector&lt;int&gt; S3 = {2, 9, 17, 30, 41};

    int minDist = minDistanceTriplet(S1, S2, S3);

    cout &lt;&lt; "最小距离为: " &lt;&lt; minDist &lt;&lt; endl;

    // 输出三元组
    // 遍历三元组的索引，根据索引取得对应元素输出
    for (int i = 0; i &lt; S1.size(); ++i) {
        for (int j = 0; j &lt; S2.size(); ++j) {
            for (int k = 0; k &lt; S3.size(); ++k) {
                int a = S1[i], b = S2[j], c = S3[k];
                int currentDistance = abs(a - b) + abs(b - c) + abs(c - a);
                if (currentDistance == minDist) {
                    printTriplet(a, b, c);
                }
            }
        }
    }

    return 0;
}</code></pre> 
<p><img alt="" height="322" src="https://images2.imgbox.com/91/35/L4HtH4sa_o.png" width="1200"></p> 
<h3><strong>🌰</strong>暴力解</h3> 
<h4>📇暴力解思路</h4> 
<blockquote> 
 <ul><li style="text-align:justify;"><strong>算法思想：</strong> 
   <ul><li style="text-align:justify;">使用三重循环来遍历所有可能的三元组；</li><li style="text-align:justify;">计算每个三元组的距离并更新最小值；</li></ul></li><li style="text-align:justify;"><strong>时间复杂度：</strong>O(n)，其中n是输入数组的长度；</li><li style="text-align:justify;"><strong>空间复杂度：</strong>O(1)。</li></ul> 
</blockquote> 
<h4 style="background-color:transparent;"><strong>⌨️</strong>暴力解<strong>代码</strong></h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;  // 在本示例中，INT_MAX 和 INT_MIN 分别用于初始化最小距离变量为最大可能值，以便在计算距离时进行比较，并找到最小值。
using namespace std;

int minDistanceTriplet(vector&lt;int&gt;&amp; S1, vector&lt;int&gt;&amp; S2, vector&lt;int&gt;&amp; S3) {
    int minDistance = INT_MAX;
    for (int i = 0; i &lt; S1.size(); ++i) {
        for (int j = 0; j &lt; S2.size(); ++j) {
            for (int k = 0; k &lt; S3.size(); ++k) {
                int a = S1[i], b = S2[j], c = S3[k];
                int currentDistance = abs(a - b) + abs(b - c) + abs(c - a);
                minDistance = min(minDistance, currentDistance);
            }
        }
    }
    return minDistance;
}


void printTriplet(int a, int b, int c) {
    cout &lt;&lt; "三元组为: (" &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; ", " &lt;&lt; c &lt;&lt; ")" &lt;&lt; endl;
}

int main() {
    vector&lt;int&gt; S1 = {-1, 0, 9};
    vector&lt;int&gt; S2 = {-25, -10, 10, 11};
    vector&lt;int&gt; S3 = {2, 9, 17, 30, 41};

    int minDist = minDistanceTriplet(S1, S2, S3);

    cout &lt;&lt; "最小距离为: " &lt;&lt; minDist &lt;&lt; endl;

    // 输出三元组
    // 遍历三元组的索引，根据索引取得对应元素输出
    for (int i = 0; i &lt; S1.size(); ++i) {
        for (int j = 0; j &lt; S2.size(); ++j) {
            for (int k = 0; k &lt; S3.size(); ++k) {
                int a = S1[i], b = S2[j], c = S3[k];
                int currentDistance = abs(a - b) + abs(b - c) + abs(c - a);
                if (currentDistance == minDist) {
                    printTriplet(a, b, c);
                }
            }
        }
    }

    return 0;
}</code></pre> 
<hr> 
<h2 id="%F0%9F%94%9A%E7%BB%93%E8%AF%AD">🔚结语</h2> 
<p>博文到此结束，写得模糊或者有误之处，欢迎小伙伴留言讨论与批评，督促博主优化内容{例如有错误、难理解、不简洁、缺功能}等，博主会顶锅前来修改~😶‍🌫️</p> 
<p>我是梅头脑，本片博文若有帮助，欢迎小伙伴动动可爱的小手<strong>默默给个赞支持一下</strong>，收到点赞的话，博主肝文的动力++~🌟🌟</p> 
<p><a class="has-card" href="https://blog.csdn.net/weixin_42789937/category_12262100.html?spm=1001.2014.3001.5482" title="数据结构_梅头脑_的博客-CSDN博客"><span class="link-card-box"><span class="link-title">数据结构_梅头脑_的博客-CSDN博客</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/20/a2/pIMZNRsQ_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/weixin_42789937/category_12262100.html?spm=1001.2014.3001.5482</span></span></a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f8413a33324537fbeb4e3651b630541c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">modbusRTU通信简单实现（使用NModbus4通信库）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f1797146ac234ac03dcee22ef753f872/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于程序员的税前薪资与谈薪雷区</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>