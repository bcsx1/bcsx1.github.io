<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构 | 【树与二叉树】考研相关结论与习题 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构 | 【树与二叉树】考研相关结论与习题" />
<meta property="og:description" content="相关结论 二叉树遍历
1、在二叉树结点的先序序列,中序序列和后序序列中,所有叶子结点的先后顺序完全相同。
2、 L、D、R分别表示遍历左子树、访问根结点和遍历右子树， 则先(根)序遍历二叉树的顺序是DLR， 中(根)序遍历二叉树的顺序是LDR， 后(根)序遍历二叉树的顺序是LRD， 还有层次遍历二叉树。
这些方法的时间复杂度都是O(n)，n为结点个数。
3、设n，m为一棵二叉树上的两个结点，中序遍历时，n在m前的条件是n在m左方。
设n，m为一棵二叉树上的两个结点，后序遍历时，n在m前的充分条件是n是m子孙。
4、前序序列和中序序列相同的二叉树为空树或任一结点均无左孩子的非空二叉树； 中序序列和后序序列相同的二叉树为空树或任一结点均无右孩子的非空二叉树； 前序序列和后序序列相同的二叉树为空树或仅有一个结点的二叉树。
递归算法使用与树的高度成比例的栈空间。如果我们在每个结点中存储指向父结点的指针，那样可以使用迭代算法，只使用常数级空间实现所有这些遍历。然而，指向父结点的指针占用更多的空间。这只在需要指向父节点的指针或栈空间有限时才使用。
深度优先遍历在深度优先顺序中，我们希望从根结点访问最远的结点。和图的深度优先搜索不同的是，不需记住访问过的每一个结点，因为树中不会有环。前序，中序和后序遍历都是深度优先遍历的特例。
广度优先遍历和深度优先遍历不同，广度优先遍历会先访问离根节点最近的节点。 二叉树的广度优先遍历又称按层次遍历。算法借助队列实现。
有序树转化为二叉树
如果T2是由有序树T转换而来的二叉树，那么T中结点的前序就是T2中结点的前序，T中结点的后序就是T2中结点的中序。
线索二叉树 1、二叉树是一种逻辑结构。线索二叉树是一种物理结构。
2、线索二叉树明确指明了在存储过程中的数据存放方式，就是物理结构了。(物理结构=存储结构)
注意:既指明了存储结构，又指明了逻辑结构的情况就是单独的“物理结构”。
3、n个结点的线索二叉树含有的线索数为n&#43;1。
4、一颗任意的二叉树，也任意使用先序/中序/后序线索化，则线索化后其空链域最多有2个。
5、两个结点，在前序和后序中的前后关系不同，证明二者是父子关系；如果相同，二者是兄弟关系 。
6、后序线索二叉树中不能求后序后继 ，先序线索二叉树中不能求先序前驱。
树与森林
1、设F是一个森林，B是由F变换得的二叉树。若F中有n个非终端结点，则B中右指针域为空的结点有n&#43;1个。每一个非终端结点，一定会有且仅有一个孩子结点没有右邻兄弟，即右指针领域为空。
2、树与二叉树的转换：没有右侧指针的结点数 = 根节点 &#43; 非叶节点数量
树转换为二叉树时，树中每一个分支结点的 所有子结点中最右子结点 无右孩子， 根结点转换后也 没有右孩子。因此，对应二叉树中无右孩子的结点个数=分支结点个数（ 非终端结点）&#43;1
哈夫曼树与并查集
1、在有n个叶子结点的哈夫曼树（度为2）中，非叶子结点的个数为n-1。
相关例题 1、二叉树相关计算 1、一棵完全二叉树上有1001个结点，其中叶结点的个数是（）
A.250 B.500 C.254 D.501 解：法1： 结点总数为1001，奇数，故n1=0。由n=n0&#43;n1&#43;n2；n2=n0-1得：n=n0&#43;n1&#43;n0-1,即1001=2*n0-1,得 n0=1002/2=501.
法2： 完全二叉树的最后一个结点编号为1001，由于其为奇数，因此其双亲结点编号为(1001-1)/2=500（若为偶数则直接除以2），双亲之后的结点都是叶结点，因此总叶结点n0=最后一个编号-其双亲编号=1001-500=501.
法3： 此完全二叉树深度为:log2(n)向下取整&#43;1=10.其前9层满数，第9层结点数为2^(9-1)=256，则前9层的总结点数为：(2^9)-1=511，因此第10层的叶结点数为：1001-511=490，则第9层非叶结点个数为490/2=245（2对1），则第9层结点个数为：256-245=11。因此总叶结点为：第9层的&#43;第10层的=11&#43;490=501
答案：D
总结一下：完全二叉树的最后一个结点的编号是n，则它的父结点的编号为[n/2]，则叶子结点个数为n-[n/2]。
2、一棵有n个结点采用链式存储的二叉树中，共有（ ）个指针域为空。
A.n&#43;1 B.n C.n-1 D.n-2 解：每个节点有两个指针（左右指针），所以其有2n个指针用于指向孩子节点" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/505963cb800909371cd03f075b11d49a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-25T21:08:00+08:00" />
<meta property="article:modified_time" content="2022-10-25T21:08:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构 | 【树与二叉树】考研相关结论与习题</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<h2 style="text-align:center;">相关结论</h2> 
<p></p> 
<p><strong>二叉树遍历</strong></p> 
<p><span style="background-color:#fefcd8;">1、在二叉树结点的先序序列,中序序列和后序序列中,所有叶子结点的先后顺序完全相同。</span></p> 
<p>2、 L、D、R分别表示遍历左子树、访问根结点和遍历右子树，     <br>       则先(根)序遍历二叉树的顺序是DLR，      <br>       中(根)序遍历二叉树的顺序是LDR，     <br>       后(根)序遍历二叉树的顺序是LRD，     <br>       还有层次遍历二叉树。</p> 
<p>      这些方法的时间复杂度都是O(n)，n为结点个数。</p> 
<p>3、设n，m为一棵二叉树上的两个结点，中序遍历时，n在m前的条件是n在m左方。</p> 
<p>      设n，m为一棵二叉树上的两个结点，后序遍历时，n在m前的充分条件是n是m子孙。</p> 
<p>4、前序序列和中序序列相同的二叉树为空树或任一结点均无左孩子的非空二叉树；    <br>       中序序列和后序序列相同的二叉树为空树或任一结点均无右孩子的非空二叉树；     <br>       前序序列和后序序列相同的二叉树为空树或仅有一个结点的二叉树。</p> 
<p></p> 
<p>递归算法使用与树的高度成比例的栈空间。如果我们在每个结点中存储指向父结点的指针，那样可以使用迭代算法，只使用常数级空间实现所有这些遍历。然而，指向父结点的指针占用更多的空间。这只在需要指向父节点的指针或栈空间有限时才使用。</p> 
<p>深度优先遍历在深度优先顺序中，我们希望从根结点访问最远的结点。和图的深度优先搜索不同的是，不需记住访问过的每一个结点，因为树中不会有环。前序，中序和后序遍历都是深度优先遍历的特例。<br> 广度优先遍历和深度优先遍历不同，广度优先遍历会先访问离根节点最近的节点。 二叉树的广度优先遍历又称按层次遍历。算法借助队列实现。</p> 
<p></p> 
<p><strong>有序树转化为二叉树</strong></p> 
<p>如果T2是由有序树T转换而来的二叉树，那么T中结点的前序就是T2中结点的前序，T中结点的后序就是T2中结点的中序。</p> 
<p></p> 
<p><strong>线索二叉树 </strong></p> 
<p>1、二叉树是一种逻辑结构。<span style="background-color:#fefcd8;">线索二叉树是一种物理结构。</span></p> 
<p>2、线索二叉树明确指明了在存储过程中的数据存放方式，就是物理结构了。(物理结构=存储结构)</p> 
<p>      注意:既指明了存储结构，又指明了逻辑结构的情况就是单独的“物理结构”。</p> 
<p><span style="background-color:#fefcd8;">3、n个结点的线索二叉树含有的线索数为n+1。</span></p> 
<p>4、一颗任意的二叉树，也任意使用先序/中序/后序线索化，则线索化后其空链域最多有2个。</p> 
<p><span style="color:#be191c;"><span style="background-color:#fef2f0;">5、两个结点，在前序和后序中的前后关系不同，证明二者是父子关系；如果相同，二者是兄弟关系 。</span></span></p> 
<p>6、<span style="background-color:#fefcd8;">后序线索二叉树中不能求后序后继 ，先序线索二叉树中不能求先序前驱。</span></p> 
<p></p> 
<p><strong>树与森林</strong></p> 
<p>1、设F是一个森林，B是由F变换得的二叉树。若F中有n个非终端结点，则B中右指针域为空的结点有n+1个。<span style="background-color:#fefcd8;">每一个非终端结点，一定会有且仅有一个孩子结点没有右邻兄弟，即右指针领域为空。</span></p> 
<p>2、树与二叉树的转换：<span style="background-color:#fefcd8;">没有右侧指针的结点数 = 根节点 + 非叶节点数量</span></p> 
<p>树转换为二叉树时，树中每一个分支结点的 所有子结点中最右子结点 无右孩子， 根结点转换后也 没有右孩子。因此，对应二叉树中无右孩子的结点个数=分支结点个数（ 非终端结点）+1</p> 
<p><strong><img alt="" height="225" src="https://images2.imgbox.com/27/30/lIsbfhtE_o.png" width="444"></strong></p> 
<p></p> 
<p><strong>哈夫曼树与并查集</strong></p> 
<p>1、在有n个叶子结点的哈夫曼树（度为2）中，非叶子结点的个数为n-1。</p> 
<hr> 
<p></p> 
<h2 style="text-align:center;"> 相关例题</h2> 
<p></p> 
<h3>1、二叉树相关计算</h3> 
<blockquote> 
 <p><strong>1、一棵完全二叉树上有1001个结点，其中叶结点的个数是（）</strong></p> 
 <pre><strong>A.250    B.500    C.254    D.501</strong></pre> 
</blockquote> 
<p>解：法1：    结点总数为1001，奇数，故n1=0。由n=n0+n1+n2；n2=n0-1得：n=n0+n1+n0-1,即1001=2*n0-1,得 n0=1002/2=501.</p> 
<p>法2： 完全二叉树的最后一个结点编号为1001，由于其为奇数，因此其双亲结点编号为(1001-1)/2=500（若为偶数则直接除以2），双亲之后的结点都是叶结点，因此总叶结点n0=最后一个编号-其双亲编号=1001-500=501.</p> 
<p>法3： 此完全二叉树深度为:log2(n)向下取整+1=10.其前9层满数，第9层结点数为2^(9-1)=256，则前9层的总结点数为：(2^9)-1=511，因此第10层的叶结点数为：1001-511=490，则第9层非叶结点个数为490/2=245（2对1），则第9层结点个数为：256-245=11。因此总叶结点为：第9层的+第10层的=11+490=501</p> 
<p>答案：D</p> 
<p><strong>总结一下</strong>：<span style="color:#ed7976;">完全二叉树的最后一个结点的编号是n，则它的父结点的编号为[n/2]，则叶子结点个数为n-[n/2]。</span></p> 
<p></p> 
<hr> 
<blockquote> 
 <p><strong>2、一棵有n个结点采用链式存储的二叉树中，共有（ ）个指针域为空。</strong></p> 
 <pre><strong>A.n+1    B.n    C.n-1    D.n-2</strong></pre> 
</blockquote> 
<p>解：每个节点有两个指针（左右指针），所以其有2n个指针用于指向孩子节点</p> 
<p>除根节点外，每出现一个节点会占用其父节点的一个指针域，所以占据n-1个指针域</p> 
<p>所以剩下的空指针域为2n-(n-1)=n+1</p> 
<p>答案：A</p> 
<hr> 
<blockquote> 
 <p><strong>3、已知一棵有2011 个结点的树，其叶结点个数为 116，该树对应的二叉树中无右孩子的结点的个数是（ ）。</strong></p> 
</blockquote> 
<p>A.115 B.116 C.1895 D.1896</p> 
<p>解：法一：</p> 
<p>树——&gt;二叉树，大孩子变左孩子，兄弟变右孩子<br> 因此对应的二叉树没有右孩子，说明该节点在树里右边没有兄弟，也就是说，该节点是其父节点最右边的孩子。有多少个有孩子的节点，就有多少个“最右的孩子节点”，因此2011-116=1895<br> 此外，对于根节点而言，它没有父节点当然也没有兄弟，因此也是没有右孩子的。所以+1=1896</p> 
<p>解释一波&amp;quot;有多少个有孩子的节点，就有多少个&amp;ldquo;最右的孩子节点&amp;quot;这句话，因为树没有左右之分所以有孩子可以说一定有右孩子节点</p> 
<p>  </p> 
<p>法二：</p> 
<p style="text-align:center;"><img alt="" height="265" src="https://images2.imgbox.com/b3/63/oUxNN6hG_o.png" width="338"></p> 
<p style="text-align:center;"><img alt="" height="419" src="https://images2.imgbox.com/6b/b2/aKHs1df8_o.png" width="323"></p> 
<p>答案：D</p> 
<hr> 
<blockquote> 
 <p><strong>4、已知一棵完全二叉树的第 6 层（设根为第 1 层）有 8 个叶结点，则完全二叉树的结点个数最多是 (          )。</strong></p> 
</blockquote> 
<p>解：如果第六层是满的话，那么第6层将会有32个节点，题目说只有8个叶节点，那只有两种情况：</p> 
<p>1.6层只有8个节点，都是叶节点</p> 
<p>2.6层节点满了，但有8个节点没有子节点，只能作为叶节点。</p> 
<p>由于题目求更多：所以考虑第2钟情况：</p> 
<p>这时候 前6层节点数为32+16+...+1 =63</p> 
<p>第7层节点数：（32-8）*2=48 ——第6层节点数共32个，减去8个叶节点数，每个再带有两个子节点，相加——111</p> 
<p>答案：111</p> 
<p></p> 
<p><strong><span style="color:#ed7976;">注：</span></strong></p> 
<p><strong><span style="color:#ed7976;">完全二叉树</span></strong>是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。</p> 
<p><span style="color:#ed7976;"><strong>(1)所有的叶结点都出现在第k层或k-l层（层次最大的两层）</strong></span></p> 
<p>(2)对任一结点，如果其右子树的最大层次为L，则其左子树的最大层次为L或L+l。</p> 
<p>一棵二叉树至多只有最下面的两层上的结点的度数可以小于2，并且最下层上的结点都集中在该层最左边的若干位置上，则此二叉树成为完全二叉树，并且最下层上的结点都集中在该层最左边的若干位置上，而在最后一层上，右边的若干结点缺失的二叉树，则此二叉树成为完全二叉树。</p> 
<hr> 
<blockquote> 
 <p><strong> 5、对于任意一棵高度为 5 且有 10 个结点的二叉树，若采用顺序存储结构保存，每个结点占 1 个存储单元（仅存放结点的数据信息），则存放该二叉树需要的存储单元的数量至少是：</strong></p> 
 <p><strong>A、31    B、16    C、15    D、10</strong></p> 
</blockquote> 
<p>解析：<strong><span style="color:#ed7976;">因为是顺序存储结构保存，所以需要的存储单元是给定高度的全部结点都要考虑。</span></strong><br> 高度为5的满二叉树共有：<br> 25-1=31个结点<br> 31*1个存储单元=31；</p> 
<hr> 
<blockquote> 
 <p><strong>6、一个深度为h的满k叉树有如下性质：第h层上的结点都是叶子结点，其余各层上每个结点都有k棵非空子树。如果按层次顺序(同层自左至右)从1开始对全部结点编号，问：<br> (1)各层的结点数目是多少?<br> (2)编号为i的结点的双亲结点(若存在)的编号是多少?<br> (3)编号为i的结点的第j个孩子结点(若存在)的编号是多少?<br> (4)编号为i的结点的有右兄弟的条件是什么? 其右兄弟的编号是多少?</strong></p> 
</blockquote> 
<p><img alt="" height="113" src="https://images2.imgbox.com/51/22/VmltWbft_o.png" width="308"></p> 
<p>解：</p> 
<p>(3)编号为i的结点的第j个孩子结点(若存在)的编号是多少?</p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/09/9a/iE1GpIuC_o.png" width="784"></p> 
<p>假设i的位置如上，j 是 i 的第一个子节点。<br> i 的前面有（i-1）个节点，每一个节点有k 个子节点，<br> 所以j 前面有（（i-1）*k）+1 个节点，为什么要加1呢，<br> 因为（i-1）*k 没有包括根节点，<br> 所以j 前面的节点再加一，（（i-1）*k）+2 就是j 节点的编号。</p> 
<p>（ （ i − 1 ） ∗ k ） + 2 （（i-1）*k）+2 （（i−1）∗k）+2</p> 
<p>衍生问题，如果问的是i的第k个孩子的编号怎么办？</p> 
<p>第一个孩子 （ i − 1 ） ∗ k ） + 2 （i-1）*k）+2 （i−1）∗k）+2<br> 那么第k个孩子 （ i − 1 ） ∗ k ） + 2 + k − 1 （i-1）*k）+2 + k -1 （i−1）∗k）+2+k−1</p> 
<p>(2)编号为i的结点的双亲结点(若存在)的编号是多少?</p> 
<p style="text-align:center;"><img alt="" height="346" src="https://images2.imgbox.com/3c/4d/avBjEN2O_o.png" width="729"></p> 
<p></p> 
<p>这次就是求i 的父节点j 的编号，我只会使用数学的推算方法，联想不出来这个题。<br> 因为i是j子节点，所以可以用j 来求i 的编号，<br> i = ( ( j − 1 ) ∗ k ) + 2 i=((j-1)*k)+2 i=((j−1)∗k)+2<br> i − 2 = ( j − 1 ) ∗ k i-2=(j-1)*k i−2=(j−1)∗k<br> ( i − 2 ) / k = j − 1 (i-2)/k=j-1 (i−2)/k=j−1<br> j = ( ( i − 2 ) / k ) + 1 j=((i-2)/k)+1 j=((i−2)/k)+1</p> 
<p>第三题就是通过第二题得到的结果，逆向推理得到的结果。</p> 
<p style="text-align:center;"><img alt="" height="364" src="https://images2.imgbox.com/74/91/b93mSYE2_o.png" width="703"></p> 
<p>图中红色的就是没有右兄弟，除了红色的节点，其他的节点都有右兄弟<br> 通过图片可以发现，只要i 不是每个节点的最右节点，<br> 换个说法，只要i 不是双亲的第k个孩子就有右兄弟<br> 对于任意的节点p ，其k 个子节点的编号是p*k+1<br> 则有：<br> i ! = p ∗ k + 1 i!= p*k+1 i!=p∗k+1<br> i − 1 ! = p ∗ k i-1 != p*k i−1!=p∗k<br> 最后结果可以写成：<br> ( i − 1 ) % k ! = 0 (i-1)\% k !=0 (i−1)%k!=0<br> 其实就是保证当前节点减一不是k的倍数，就可以保证该节点是有右兄弟的。<br>  </p> 
<hr> 
<p></p> 
<h3>2、二叉树遍历与线索二叉树</h3> 
<p></p> 
<blockquote> 
 <p><strong>7、______线索树的遍历仍然需要栈的支持。</strong></p> 
</blockquote> 
<p>解：</p> 
<p style="text-align:center;"><img alt="" height="219" src="https://images2.imgbox.com/26/42/9fw1znVK_o.png" width="406"></p> 
<p>如果是<span style="background-color:#fefcd8;">普通的二叉树，不管是递归算法（隐含递归栈），还是非递归算法（使用栈）都是需要栈的支持的。</span></p> 
<p>那么，现在不需要了，<span style="background-color:#fefcd8;">原因：使用了线索二叉树。</span></p> 
<p>遍历关键 —— 找到你的下一个是谁。</p> 
<p><span style="background-color:#fefcd8;">叶子结点全部有线索了，所以只需要考虑非叶子结点能都找到后继。</span></p> 
<p>如上图所示，后序线索树遍历时，最后访问根节点。如果是从右孩子x返回访问父节点<br> 由于节点x的右孩子不一定为空，此时右指针无法指向其后继，因此通过指针可能无法遍历整棵树<br> 如图中，节点中数字表示遍历顺序。<br> a、节点6的右指针指向其右孩子5，而不指向其后序后继节点7<br> b、因此后序遍历还需要栈的支持，而前序和中序可以不用。</p> 
<hr> 
<blockquote> 
 <p><strong>8、在二叉树中有两个结点m和n，若m是n的祖先，则使用_____遍历可以找到从m到n的路径。</strong></p> 
</blockquote> 
<p>答案：后序遍历</p> 
<p>不少人误认为“路径”是visit()输出的序列顺序，而<span style="color:#be191c;"><span style="background-color:#fefcd8;">“<strong>路径”是遍历过程中栈中元素的顺序</strong></span></span>。</p> 
<p>后序遍历中m是第一个入栈最后一个出栈，当n入栈时在栈中就会有m→n的路径。</p> 
<p>前中序在n入栈前它的祖父结点早就出栈了。前序是一定没有；中序是有可能有（主题这个图片就是没有的情况）；后序是一定有。</p> 
<p></p> 
<p>首先需要理解的是，<span style="color:#ed7976;">前中后序遍历都是通过递归的方式，将后来需要用到的结点保存在栈中</span>，</p> 
<p>比如下面这颗树：</p> 
<p><img alt="" height="160" src="https://images2.imgbox.com/73/74/tv522hBX_o.png" width="111"></p> 
<p>如果是前序遍历，根左右，过程是：</p> 
<p>根节点m入栈并输出，访问m的左孩子a，a入栈并输出，访问a的左孩子c，c入栈并输出，c没有左孩子，无元素入栈，c没有右孩子，无元素入栈，c出栈，此时栈顶元素为a，访问a元素的右孩子d，d入栈并输出，d没有左孩子，无元素入栈，d没有右孩子，无元素入栈，d出栈，a左右子树都访问完了所以出栈，现在栈顶元素是m，m已经没有作用了所以出栈，访问m的右孩子b，m的右孩子b入栈并输出，接着访问b的左孩子e，e入栈并输出……</p> 
<p>如果中序遍历，左根右，过程是：</p> 
<p>根节点m入栈，访问m的左孩子，所以m的左孩子a入栈，访问a的左孩子，所以a的左孩子c入栈，c没有左孩子，c现在输出并出栈，c没有右孩子所以没有元素入栈，现在栈顶元素是a，a输出并出栈，a的右孩子d入栈，此时d没有左孩子所以没有元素入栈，d输出并出栈，d没有右孩子所以没有元素入栈，现在栈顶元素是m，m输出，此时m已经没有作用了所以出栈，m的右孩子b入栈，访问b的左孩子，所以b的左孩子e入栈……</p> 
<p>所以在前序和中序的过程中，如果n在m的右子树部分，遍历过程中找到了n，但是m已经不在栈中，因为栈中只会保留等会需要用到的e和b结点，而m已经完成了访问根结点和m的左子树的任务，已经被出栈，所以无法追溯n如何走到m</p> 
<p>但是后序遍历就不一样啦，后序的顺序是左右根，所以只要m的左右子树还没遍历完成，m就不能出栈，在遍历m的左右子树过程中，无论在m的左边还是右边找到了n，都可以直接返回然后根据栈中的路径让n找到回到m的路，这样就能找到m到n的路径～</p> 
<p>所以一旦n在m的右子树，且离的较远，m就会在前序和中序的过程中因为已经完成了访问左、访问根的任务，而被栈遗忘，让找到了n的时候也不知怎么回到m……而只有后序会让作为祖先（子树的根）的m永远被铭记直到n找到m为止…</p> 
<p><br> 动图：<a href="https://www.cnblogs.com/xiaolu81/p/14901081.html" rel="nofollow" title="在二叉树中有两个结点m和n，若m是n的祖先，则使用后序遍历可以找到从m到n的路径 - 鱼大鹿 - 博客园">在二叉树中有两个结点m和n，若m是n的祖先，则使用后序遍历可以找到从m到n的路径 - 鱼大鹿 - 博客园</a></p> 
<p></p> 
<hr> 
<blockquote> 
 <p><strong>9、 若X是二叉中序线索树中一个有左孩子的结点，且x不为根，则x的前驱为（ ）</strong></p> 
 <p><strong>A.X的双亲        B．X的右子树中最左的结点</strong></p> 
 <p><strong>C.X的左子树中最右结点        D．X的左子树中最右叶结点</strong></p> 
</blockquote> 
<p>【解析】</p> 
<p>中序遍历:LNR，有左孩子则其前驱应为其左子树的最后一个结点。</p> 
<p>问题转变:寻找一个子树的最后一个结点。</p> 
<p>怎么找?——循环访问右孩子直到没有右孩子的那个结点，就是最后一个结点。</p> 
<p>综上，首先确定是左子树，然后确定是该左子树的最右结点。</p> 
<p>注意:不是最右叶结点，思考情况<span style="color:#ed7976;">最右结点入果有左孩子</span>? 也可以。</p> 
<p>【答案】C</p> 
<hr> 
<blockquote> 
 <p><strong>10、若一棵二叉树的前序遍历序列和后序遍历序列分别为1,2,3,4和4,3,2,1，则该二叉树的中序遍历序列不会是（）</strong></p> 
 <p><strong>A.1,2,3,4     B.2,3,4,1     C. 3,2,4,1     D. 4,3,2,1</strong></p> 
</blockquote> 
<p>【解析】</p> 
<p>法一：最简单的做法就是选项的中序+题干前序得到树然后判断后序是否正确。</p> 
<p><img alt="" height="164" src="https://images2.imgbox.com/60/39/DdpIKg3D_o.png" width="444"></p> 
<p>法二：</p> 
<p>前序:根左右：根左，根右，左右;</p> 
<p>后序:左右根：左根，右根，左右;</p> 
<p><span style="background-color:#fefcd8;">两个结点，在前序和后序中的前后关系不同，证明二者是父子关系；如果相同，二者是兄弟关系。</span></p> 
<p>1,2,3,4与4,3,2,1两两关系都不相同，所以肯定是4个父子关系。所以1一定是根节点。那么1要么在最左，要么在最右。ABCCD均符合。</p> 
<p>然后再看 2,3,4,和4,3,2那么2为根节点，那么2要么在最左，要么在最右。C错误。</p> 
<hr> 
<blockquote> 
 <p><strong>11、先序序列为a,b,c,d 的不同二叉树的个数是 （） 。</strong></p> 
</blockquote> 
<p>【解析】</p> 
<p>前序序列和中序序列的关系相当于以前序序列为入栈次序，以中序序列为出栈次序。</p> 
<p><span style="background-color:#fefcd8;">转化为“以序列a, b, c, d为入栈次序，则出栈序列的个数为多少”。</span></p> 
<p>对于n个不同元素进栈，出栈序列的个数为<img alt="" height="53" src="https://images2.imgbox.com/0e/24/mW0Xu4ql_o.png" width="141"></p> 
<p><span style="color:#ed7976;"><strong>卡特兰数的应用</strong></span>：<img alt="" height="49" src="https://images2.imgbox.com/e7/87/G9qyGsxB_o.png" width="55"></p> 
<ul><li>出栈次序</li><li>n个节点的二叉树构成</li><li>凸多边形的三角形划分</li><li>括号匹配，网格两点之间抵达方案等</li></ul> 
<hr> 
<p></p> 
<h3>3、树与森林</h3> 
<blockquote> 
 <p><strong>12、设F是一个森林，B是由F变换得的二叉树。若F中有n个非终端结点，则B中右指针域为空的结点有____个。</strong></p> 
</blockquote> 
<p>【解析】</p> 
<p><strong>法一：</strong></p> 
<p>①    森林的非终端结点一定是二叉树的非终端结点，森林的叶子结点一定是二叉树的<span style="background-color:#fefcd8;">空左指针结点</span>（值得注意的是，森林的叶子到二叉树里，可能是叶子也可能不是，这取决于有没有兄弟）</p> 
<p>②    设森林F的终端结点数为f，总结点数 f + n。二叉树B每个结点有两个指针，总指针数 2（f + n）</p> 
<p>③    二叉树B除去根结点，都是某个结点的孩子， 也就是总有：某个结点必有指针指向他，因此占用指针数为 f + n – 1，减1是因为根结点不用指针指向</p> 
<p>④    剩余空指针数为 2（f + n）- （f + n - 1）= f + n + 1 个</p> 
<p>⑤    f 个终端结点没有孩子，因此转换为二叉树B后，这些结点的左指针必为空，所以空的左指针域为f 个，除此之外都不可能是空左指针的结点</p> 
<p>综上，二叉树B 中右指针域为空的结点有 ( f + n + 1 ) - f = n + 1</p> 
<p><strong>法二：</strong></p> 
<p>根据森林转换为二叉树的"左孩子右兄弟"的表示法，即对于每棵二叉树，每个结点的右指针指向其右邻兄弟。</p> 
<p>针对<span style="background-color:#fefcd8;">每一个非终端结点，一定会有且仅有一个孩子结点没有右邻兄弟，即右指针领域为空。</span>因此N个非终端结点，就有N个右指域为空。</p> 
<p>看院单棵二叉树，再来看这些二叉树是怎么连接成一棵二叉树的。</p> 
<p>原理是：将后一棵二叉树的根节点作为前一棵二叉树的右孩子连接起来，所以只有最后一棵二叉树的根结点没有右孩子，即右指域为空。</p> 
<p>因此综上:N个非终端结点，就有(N+1)个结点的右指针域为空。</p> 
<hr> 
<blockquote> 
 <p><strong>13、已知一棵有2011个结点的树，其叶结点个数为116，该树对应的二叉树中无右孩子的结点个数是()</strong></p> 
 <p><strong>A. 115     B. 116      C. 1895      D. 1896</strong></p> 
</blockquote> 
<p>【解析】</p> 
<p><strong>法一： </strong></p> 
<p><img alt="" height="259" src="https://images2.imgbox.com/10/1a/nEISIat0_o.png" width="673"></p> 
<p>直接找有几对亲兄弟即可。</p> 
<p>如果一个结点不是叶节点。那么就会有孩子，这些孩子就是一组亲兄弟。</p> 
<p><span style="background-color:#fefcd8;">没有右侧指针的结点数=根节点+非叶节点数量</span></p> 
<p><a href="https://www.bilibili.com/video/av588468688?vd_source=28d49458bb72323ebce5ca6baa42371a" rel="nofollow" title="5-1. 已知一棵有 2011个结点的树，其叶结点个数为116，该树对应的二叉树中无右孩子的结点个数是 （ ）。【2011年全国试题6（2分）】 A.115 B_哔哩哔哩_bilibili">5-1. 已知一棵有 2011个结点的树，其叶结点个数为116，该树对应的二叉树中无右孩子的结点个数是 （ ）。【2011年全国试题6（2分）】 A.115 B_哔哩哔哩_bilibili</a></p> 
<p><strong>法二：</strong></p> 
<p><img alt="" height="378" src="https://images2.imgbox.com/82/00/AE0aBSOk_o.png" width="989"></p> 
<hr> 
<h3>4、哈夫曼树与并查集</h3> 
<blockquote> 
 <p><strong>14、若度为m的哈夫曼树中，叶子结点个数为n，则非叶子结点的个数为（）</strong></p> 
 <p><img alt="" height="33" src="https://images2.imgbox.com/7a/88/0IYemnWb_o.png" width="519"></p> 
</blockquote> 
<p>【解析】</p> 
<p><strong>法一：</strong></p> 
<p>度为m的哈夫曼树意味着在这棵树中仅有度为0的结点和度为m的结点。</p> 
<p>一开始，n个数据（需要处理的叶子结点)，进行一次处理是m合1</p> 
<p>那么一次处理对应：需要处理的数据减少 m-1，非叶子结点+1.</p> 
<p>一共需要处理n-1个数据，一次处理m-1个，处理一次非叶子结点个数+1.</p> 
<p>问:有多少非叶子结点? C向上取整。</p> 
<p><strong>法二：</strong></p> 
<p>因为度为m的哈夫曼树中，节点的度只有0或m。假设非叶节点（即度为m的节点）个数为a,由题意知叶结点个数（即度为0节点个数）是n。在该哈夫曼树中度为m的节点有m个分支，度为0的节点有0个分支。</p> 
<p>因为  树的总结点数=总分支数+1，所以有  n+a=a*m+n*0 +1 ，化简后有a=(n-1)/(m-1)</p> 
<hr> 
<blockquote> 
 <p><strong>15、下列选项给出的从根分别到两个叶子结点路径上的权值序列，能属于同一棵哈夫曼树的是：</strong></p> 
 <p><strong>A. 24,10,5 和24,10,7<br> B. 24,10,5和24,12,7<br> C. 24,10,10和24,14,11<br> D. 24,10,5和24,14,6</strong></p> 
</blockquote> 
<p> <a href="https://blog.csdn.net/u011240016/article/details/53083846" title="哈弗曼树的路径问题_DrCrypto的博客-CSDN博客">哈弗曼树的路径问题_DrCrypto的博客-CSDN博客</a></p> 
<hr> 
<p><a href="https://blog.csdn.net/u014034497/article/details/61512027" title="数据结构—树与二叉树篇II_fir_dameng的博客-CSDN博客">数据结构—树与二叉树篇II_fir_dameng的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/liuchuo/article/details/88413073" title="在二叉树中有两个结点m和n，若m是n的祖先，则使用后序遍历可以找到从m到n的路径_柳婼的博客-CSDN博客_在二叉树中有两个结点m和n,如果m是n的祖先">在二叉树中有两个结点m和n，若m是n的祖先，则使用后序遍历可以找到从m到n的路径_柳婼的博客-CSDN博客_在二叉树中有两个结点m和n,如果m是n的祖先</a></p> 
<p><a href="https://blog.csdn.net/weixin_40646509/article/details/102828109?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-4-102828109.pc_agg_new_rank&amp;utm_term=%E4%B8%80%E6%A3%B5%E9%AB%98%E5%BA%A6%E4%B8%BAh%E7%9A%84%E6%BB%A1m%E5%8F%89%E6%A0%91%E6%9C%89%E5%A6%82%E4%B8%8B%E6%80%A7%E8%B4%A8&amp;spm=1000.2123.3001.4430" title="数据结构-满k叉树例题_ChinaSugarMan的博客-CSDN博客_一个深度为h的满k叉树">数据结构-满k叉树例题_ChinaSugarMan的博客-CSDN博客_一个深度为h的满k叉树</a><br><a href="https://blog.csdn.net/ouyangjinbin/article/details/51075893" title="有关树的几个经典问题_蓝旭晨枫╮-CSDN博客_后序线索树的遍历仍需要栈的支持">有关树的几个经典问题_蓝旭晨枫╮-CSDN博客_后序线索树的遍历仍需要栈的支持</a></p> 
<p><a href="https://www.cnblogs.com/ww01/p/14783283.html" rel="nofollow" title="设F是森林，B是由F转换得到的二叉树，F中有n个非终端结点，B中右指针域为空的结点有_______n+1_______ - 有蚊子 - 博客园">设F是森林，B是由F转换得到的二叉树，F中有n个非终端结点，B中右指针域为空的结点有_______n+1_______ - 有蚊子 - 博客园</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f9720480f3d8024df6fd52aee0056b58/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IDEA2021.3版本如何创建web项目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/04d93eda33f6d7813b6ff830cb920fb5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PyTorch深度学习框架（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>