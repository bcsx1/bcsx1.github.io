<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法提升：并查集的十个经典题目 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法提升：并查集的十个经典题目" />
<meta property="og:description" content="目录
最长连续序列
被围绕的区域
岛屿数量
岛屿的最大面积
朋友圈问题
除法求值（hard）
情侣牵手（hard）
打砖块（hard）
最大人工岛（hard）
相似字符串组（hard）
最长连续序列 题目
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
示例 1：
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
示例 2：
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
提示：
0 &lt;= nums.length &lt;= 105
-109 &lt;= nums[i] &lt;= 109
解析
并查集绝大多数的题目属于只要你知道有并查集这个东西就非常easy ，这个题之所以放在第一个就是想说并查集的强大。
搞一个并查集把所有的节点初始化在里面；遍历每一个节点，如果key &#43;1 也在存在，就把该节点挂在key&#43;1 的节点下（union操作）遍历size map，看哪个key对应的size 最大； 代码
#include &lt;iostream&gt; #include &lt;unordered_map&gt; #include &lt;vector&gt; using namespace std; class UnionFind { public: unordered_map&lt;int,int&gt; ancestor_; // 用来存储祖先的 unordered_map&lt;int, size_t&gt; size_; // 用来存储每一个集合的大小的 public: //并查集初始化 UnionFind(const vector&lt;int&gt;&amp; vec) { for(auto c:vec) { ancestor_." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/28acba5ecb84cd4d5a5e28ac310e2a2f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-30T17:45:32+08:00" />
<meta property="article:modified_time" content="2022-10-30T17:45:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法提升：并查集的十个经典题目</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97-toc" style="margin-left:0px;"><a href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97" rel="nofollow">最长连续序列</a></p> 
<p id="%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F-toc" style="margin-left:0px;"><a href="#%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F" rel="nofollow">被围绕的区域</a></p> 
<p id="%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-toc" style="margin-left:0px;"><a href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F" rel="nofollow">岛屿数量</a></p> 
<p id="%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF-toc" style="margin-left:0px;"><a href="#%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF" rel="nofollow">岛屿的最大面积</a></p> 
<p id="%E6%9C%8B%E5%8F%8B%E5%9C%88%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E6%9C%8B%E5%8F%8B%E5%9C%88%E9%97%AE%E9%A2%98" rel="nofollow">朋友圈问题</a></p> 
<p id="%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC%EF%BC%88hard%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC%EF%BC%88hard%EF%BC%89" rel="nofollow">除法求值（hard）</a></p> 
<p id="%E6%83%85%E4%BE%A3%E7%89%B5%E6%89%8B%EF%BC%88hard%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E6%83%85%E4%BE%A3%E7%89%B5%E6%89%8B%EF%BC%88hard%EF%BC%89" rel="nofollow">情侣牵手（hard）</a></p> 
<p id="%E6%89%93%E7%A0%96%E5%9D%97%EF%BC%88hard%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E6%89%93%E7%A0%96%E5%9D%97%EF%BC%88hard%EF%BC%89" rel="nofollow">打砖块（hard）</a></p> 
<p id="%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B%EF%BC%88hard%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B%EF%BC%88hard%EF%BC%89" rel="nofollow">最大人工岛（hard）</a></p> 
<p id="%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84%EF%BC%88hard%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84%EF%BC%88hard%EF%BC%89" rel="nofollow">相似字符串组（hard）</a></p> 
<p id="e3O90-toc" style="margin-left:40px;"></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97">最长连续序列</h2> 
<p>题目</p> 
<p id="u7d5ad3a6">给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p> 
<p id="ucdbc1e6f"></p> 
<p id="ue0fcca39">请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p> 
<p id="ud96d181b"></p> 
<p id="ud5f79f0d">示例 1：</p> 
<p id="u6ca04990">输入：nums = [100,4,200,1,3,2]</p> 
<p id="u0c7c5fe9">输出：4</p> 
<p id="u5fdc78cb">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</p> 
<p id="u139cb1c4"></p> 
<p id="ueb816a72">示例 2：</p> 
<p id="ua3e9c814">输入：nums = [0,3,7,2,5,8,4,6,0,1]</p> 
<p id="ue0b1bed7">输出：9</p> 
<p id="ua0e13f2d"></p> 
<p id="u3dc61e55">提示：</p> 
<p id="u6f6d0a75">0 &lt;= nums.length &lt;= 105</p> 
<p id="ua8d10dfa">-109 &lt;= nums[i] &lt;= 109</p> 
<p id="u1bd9fede"></p> 
<p>解析</p> 
<p id="u933ae81f"></p> 
<p id="uaf468bcf">并查集绝大多数的题目属于只要你知道有并查集这个东西就非常easy ，这个题之所以放在第一个就是想说并查集的强大。</p> 
<ol><li id="uc0de0d07">搞一个并查集把所有的节点初始化在里面；</li><li id="ufd343845">遍历每一个节点，如果key +1 也在存在，就把该节点挂在key+1 的节点下（union操作）</li><li id="u5ae9c030">遍历size map，看哪个key对应的size 最大；</li></ol> 
<p>代码</p> 
<pre id="vKKe0">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
using namespace std;

class UnionFind {
public:
    unordered_map&lt;int,int&gt; ancestor_; // 用来存储祖先的
    unordered_map&lt;int, size_t&gt; size_;  // 用来存储每一个集合的大小的

public:
    //并查集初始化
    UnionFind(const vector&lt;int&gt;&amp; vec) {
        for(auto c:vec) {
            ancestor_.insert({c,c});
            size_.insert({c,1});
        }
    }

    // 查找元素属于哪一个集合
    int Find(int c) {
        //这里假设传入的字符C都是集合中已经存在的值
        int ancestor  = -1;
        int findc = c;
        while(ancestor!= findc) {
            ancestor = findc;
            findc = ancestor_[ancestor];
        }
        //这里可以做一个优化，把这个树化扁平，以减少未来的查找时间复杂度
        ancestor_[c] = ancestor;
        return ancestor;
    }

	
    void Union(int u1, int u2) {
        // 找到他们的祖先
        int anc1 = Find(u1);
        int anc2 = Find(u2);

        // 如果祖先相同就不做任何事情
        if (anc1 == anc2) return ;

        // 判断谁的size 大 &amp;&amp; 若u1 size == u2 size，将u2挂在u1上
        int maxu = size_[anc1] &gt;= size_[anc2] ? anc1:anc2;
        int minu = maxu == anc1? anc2:anc1;

        ancestor_[minu] = maxu;
    }
};


class solution {
public:
int function(vector&lt;int&gt; vec) {
        int max = 0;
        int maxkey  =0;
        UnionFind u = UnionFind(vec);
        for(auto [key,value]: u.ancestor_) {
            if (u.ancestor_.find(key+1)!=u.ancestor_.end()) {
                u.Union(key,key+1);
            }
        }
        for(auto [key,value]:u.size_) {
            if(max &lt; value) {
                max = value;
                maxkey = key;
            }
        }
        return max;
}
};</pre> 
<h2 id="%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F">被围绕的区域</h2> 
<p><a href="https://leetcode-cn.com/problems/surrounded-regions/" rel="nofollow" title="力扣">力扣</a></p> 
<p>题目</p> 
<p id="ufe3ae827">给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。</p> 
<p id="uc75857cf"></p> 
<p id="u549f9ec8"><strong>示例 1：</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ce/55/0Pqt6Bbh_o.png"></p> 
<ul><li id="u859776dd">输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]</li><li id="u5365cb5d">输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]</li><li id="uaa717930">解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</li></ul> 
<p id="u4e03357f"></p> 
<p id="u98a744e5"><strong>示例 2：</strong></p> 
<ul><li id="ub71efcd7">输入：board = [["X"]]</li><li id="u197b925c">输出：[["X"]]</li></ul> 
<p id="u8fdc4b73"></p> 
<p id="u6ee4f19b">提示：</p> 
<ul><li id="ue52a1035">m == board.length</li><li id="u22edd489">n == board[i].length</li><li id="u1a17a53e">1 &lt;= m, n &lt;= 200</li><li id="ubea4a9be">board[i][j] 为 'X' 或 'O'</li></ul> 
<p id="u6bf694a5"></p> 
<p>解析</p> 
<p id="uee69e5cb">题意：</p> 
<ul><li id="u4d496d9e">本题中的矩阵一共有三种元素</li></ul> 
<ul><li> 
  <ul><li id="u6a1a7259">x</li><li id="udca05967">被x包围的o</li><li id="u6b8408a0">没有被x包围的o</li></ul></li></ul> 
<ul><li id="u91ca69d5">本题要求将所有被<strong>x</strong>包围的<strong>o</strong>都变成<strong>x</strong></li></ul> 
<p id="ua84641c2"></p> 
<p id="u8b4c708f">分析：</p> 
<p id="u1f4175ea"></p> 
<ul><li id="ue8cf0937">由题意可以知道，关键在于区分两种<strong>不同状态</strong>的O。那么本题本质是：<strong>一个矩阵中有 3 个不同的元素，但是目前有2种元素（O）被混淆在一起，需要把这三种元素区分开来</strong>。</li><li id="u47960669">首先区分O和X很简单，关键是怎么区分“被x包围的o”和“没有被x包围的o”</li><li id="u68aab488">题目中解释说：<strong>任何边界上的</strong><strong>O</strong><strong>都不会被填充为</strong><strong>X</strong>。我们可以想到，所有的不被包围的O都直接或者间接的与边界上的O相连，因此问题转换为，<strong>如何寻找和边界</strong><strong>联通</strong><strong>的 O</strong>。</li><li id="u5d1e26e9">因此，我们可以用<strong>并查集</strong>的方法来做。那并查集中应该怎么区分两种状态的'O'呢？可以这样做：</li></ul> 
<ul><li> 
  <ul><li id="u56b97171">将那些与边界相连的'O'联通到一个虚拟节点dummy</li><li id="u98db8af9">因此，那些不与dummy相连的就是不需要替换的'O'</li></ul></li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a7/0f/QZaXTcw9_o.png"></p> 
<p id="u6c583d21"></p> 
<p id="u37421f0f">实现：</p> 
<ul><li id="uf20920b4">UnionFind底层可以是多种数据结构，比如一维数组、二维数组、map......，这里我们用一维数组来实现</li><li id="u7f481ab8">但是题目中给定的是一个二维矩阵，那么二维矩阵应该怎么用一维数据来表说呢？<strong>二维数组(x, y)可以转换成x * n + y 这个数(m是棋盘的行数，n是棋盘的列树)</strong>。这是二维坐标映射到一维的常用技巧</li><li id="uede31be9">如何来表示dummy呢？我们将二维数组转换到一维数组，其坐标映射范围是索引[ 0， m ∗ n − 1 ]，那么我们就让dummy占据索引m * n不就行了吗？</li><li id="u49c5ab4d">问题：为什么本题要选择使用一维数组来实现UnionFind？</li></ul> 
<ul><li> 
  <ul><li id="u7da85d5b">有因为 1 &lt;= m, n &lt;= 200，它比较小，预处理消耗的空间也比较小，用一维数组来实现不会有什么性能问题</li><li id="u3903c4cc">如果m * n比较大时，那么如果用一维数组来实现UnionFind会经历很重的初始化，这时建议用map</li></ul></li></ul> 
<p id="ud04513d6"></p> 
<p id="u6ec95e39">大流程：</p> 
<ul><li id="u7eec879b">定义一个指标转换函数</li></ul> 
<pre id="YkZdG">    static int index(int i, int j, int w){
        //x、y 表示二维坐标值，w 表示矩阵宽度。
        return i * w + j;
    }</pre> 
<ul><li id="u958a853a">初始化并查集，大小为矩阵的大小加一，多出的那一个作为所有边界节点的父节点dummy</li><li id="ue5db0483">遍历二维参数数组，如果当前值为O，说明它可能会被替换，这时候我们就要开始做区分了：</li></ul> 
<ul><li> 
  <ul><li id="u56299ff5">如果当前O的横坐标或者纵坐标是边界索引，那么直接将当前O与dummy相连</li><li id="u956caf33">如果当前O不是边界节点，那么看它的上下左右，只要它的四周(有一个/多个)是O，就把它们之间打通。通过这样，如果有一个和边界直接或者间接的相连，那么就一定能联通dummy</li></ul></li></ul> 
<ul><li id="ucbd2f39d">再遍历一次二维数组，将与dummy不相连的O改成X</li></ul> 
<p id="ucc1ef279"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6f/83/xh106jzD_o.png"></p> 
<p>代码</p> 
<pre id="iQ1lC">class Solution {
    class UnionFind{
    private:
        std::vector&lt;int&gt; parent_;
        std::vector&lt;int&gt; size_;
        std::vector&lt;int&gt; help_;
        int cnt_;
    public:
        UnionFind(int N){
            cnt_ = N;
            parent_.resize(N);
            size_.resize(N);
            help_.resize(N);
            for (int i = 0; i &lt; N; ++i) {
                parent_[i] = i;
                size_[i] = 1;
            }
        }

        void merge(int i,  int j){
            int ri = findRoot(i);
            int rj = findRoot(j);
            if(ri != rj){
                if(size_[ri] &gt;= size_[rj]){
                    parent_[rj] = ri;
                    size_[ri] += size_[rj];
                }else{
                    parent_[ri] = rj;
                    size_[rj] += size_[ri];
                }
                --cnt_;
            }
        }

        bool isConnected(int i, int j){
            return findRoot(i) == findRoot(j);
        }
    private:
        int findRoot(int i){
            int hi = 0;
            while (parent_[i] != i){
                help_[hi++] = i;
                i = parent_[i];
            }
            for (hi--;  hi &gt;= 0; --hi) {
                parent_[help_[hi]] = i;
            }
            return i;
        }
    };

private:
    static int index(int i, int j, int w){
        //x、y 表示二维坐标值，w 表示矩阵宽度。
        return i * w + j;
    }
public:
    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        if(board.empty()){
            return;
        }

        int m = board.size();         // 矩阵行数
        int n = board[0].size();      // 矩阵列数(宽度)，即第一行元素数
        UnionFind unionFind(m * n + 1);          //  初始化并查集，大小为矩阵大小+1, 给 dummy 留⼀个额外位置
        int dummy = m * n;              // dummy索引


        // 与边角上的`O`相连的 O 与 dummy 连通
        std::vector&lt;std::vector&lt;int&gt;&gt; dirs {<!-- -->{1, 0},{-1, 0},{0, 1}, {0, -1}};
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (board[i][j] == 'O') {
                    // 边界节点是O
                    if (i == 0 || j == 0 || i == m - 1 || j == n - 1) {
                        unionFind.merge(index(i, j, n), dummy);
                    } else {
                        // 非边界节点是O，那么看它上下左右是否有O
                        for (auto dir : dirs) {
                            int x = i + dir[0];
                            int y = j + dir[1];
                            if (board[x][y] == 'O') {  //如果是，那么将它们打通
                                unionFind.merge(index(i, j, n), index(x, y, n));
                            }
                        }
                    }
                }
            }
        }



        // 所有不和 dummy 连通的 O， 都要被替换
        for (int i = 1; i &lt; m - 1; i++){
            for (int j = 1; j &lt; n - 1; j++){
                if (board[i][j] == 'O'){
                    if (!unionFind.isConnected(index(i, j, n), dummy)){
                        board[i][j] = 'X';
                    }
                }
            }
        }
    }
};


</pre> 
<h2 id="%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F">岛屿数量</h2> 
<p><a href="https://leetcode-cn.com/problems/number-of-islands/" rel="nofollow" title="力扣">力扣</a></p> 
<p>题目</p> 
<p id="uc93fd265">给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中<strong>岛屿的数量</strong>。</p> 
<p id="uaf06fe6d">岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p> 
<p id="u71526b5e">此外，你可以假设该网格的四条边均被水包围。</p> 
<p id="u4b34dedf"></p> 
<p id="u2513f06b">示例 1：</p> 
<pre id="yGFDt">输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1</pre> 
<p id="u9198a104"><strong>示例 2：</strong></p> 
<pre id="eWrZv">输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3</pre> 
<p id="u6ee6d0e6"><strong>提示：</strong></p> 
<ul><li id="u0a788a74">m == grid.length</li><li id="ud0ef323d">n == grid[i].length</li><li id="u7ac5f6c9">1 &lt;= m, n &lt;= 300</li><li id="ue413cd6d">grid[i][j] 的值为 '0' 或 '1'</li></ul> 
<p id="u4e2d66f2"></p> 
<p id="u0d7a1b3e"></p> 
<p>解析</p> 
<ul><li id="u125611f7">题目要求：找到矩阵中 “岛屿的数量” ，上下左右相连的 1 都被认为是连续岛屿。</li><li id="u91e09686">怎么找呢？我们可以将所有相连的1都<strong>打通</strong>，最后数有几个<strong>联通分量</strong>即可</li><li id="u09ffc361">因此，我们用并查集来解决这个问题。UnionFind底层可以是多种数据结构，比如一维数组、二维数组、map......，这里我们用<strong>一维数组</strong>来实现，其大致流程如下：</li></ul> 
<ul><li> 
  <ul><li id="u2b8dd0ed">遍历给定的二维数组，将所有的1都看成是一个单独的岛屿</li><li id="u13fac753">然后将上下所有相连的1都打通：</li></ul></li></ul> 
<ul><li> 
  <ul><li> 
    <ul><li id="uabdd750b">遍历给定的二维数组，对于每一个1，只看它的左边和上边，如果发现有1，就做merge操作（为甚只看左边和上边，因为右边和下边是对称的，而我们从左到右，从上到下遍历，所以不会重复和遗落）</li></ul></li></ul></li></ul> 
<ul><li id="uf42771bc">比如，示例二中从下图中我们可以看出，一共有3个联通分离，所以一共有三个岛屿</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/01/ab/mNz1KKqy_o.png"></p> 
<p id="u26e58a7c"></p> 
<p>代码</p> 
<pre id="VySRA">class Solution {


    class UnionFind{
    private:
        std::vector&lt;int&gt; parent_;
        std::vector&lt;int&gt; size_;
        std::vector&lt;int&gt; help_;
        int cnt_{};
        int wid_;
        
        int index(int i, int j) const{
            return i * wid_ + j;         //x、y 表示二维坐标值，w 表示矩阵宽度。
        }

        int findRoot(int i){
            int hi = 0;
            while (parent_[i] != i){
                help_[hi++] = i;
                i = parent_[i];
            }
            for (hi--;  hi &gt;= 0; --hi) {
                parent_[help_[hi]] = i;
            }
            return i;
        }
    public:
        explicit UnionFind(vector&lt;vector&lt;char&gt;&gt;&amp; board){
            int m = board.size();         // 矩阵行数
            int n = board[0].size();      // 矩阵列数(宽度)，即第一行元素数
            parent_.resize(m * n);
            size_.resize(m * n);
            help_.resize(m * n);
            wid_ = n;
            for (int i = 0; i &lt; m; ++i) {
                for (int j = 0; j &lt; n; ++j) {
                    if(board[i][j] == '1'){
                        int idx = index(i, j);
                        parent_[idx] = idx;
                        size_[idx] = 1;
                        ++cnt_;
                    }
                }
            }
        }

        void merge(int i1,  int j1, int i2, int j2){
            int i = index(i1, j1);
            int j = index(i2, j2);
            int ri = findRoot(i);
            int rj = findRoot(j);
            if(ri != rj){
                if(size_[ri] &gt;= size_[rj]){
                    parent_[rj] = ri;
                    size_[ri] += size_[rj];
                }else{
                    parent_[ri] = rj;
                    size_[rj] += size_[ri];
                }
                --cnt_;
            }
        }

        int count() const {
            return cnt_;
        }

        bool isConnected(int i, int j){
            return findRoot(i) == findRoot(j);
        }
    };


public:
    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        if(board.empty()){
            return 0;
        }

        int m = board.size();         // 矩阵行数
        int n = board[0].size();      // 矩阵列数(宽度)，即第一行元素数

        UnionFind unionFind(board);

        // 第一列（除了(0, 0)外）
        for (int i = 1; i &lt; m; ++i) {
            if(board[i - 1][0] == '1' &amp;&amp; board[i][0] == '1'){
                unionFind.merge(i - 1, 0, i, 0);
            }
        }

        // 第一行（除了(0, 0)外）
        for (int j = 1; j &lt; n; ++j) {
            if(board[0][j - 1] == '1' &amp;&amp; board[0][j] == '1'){
                unionFind.merge(0, j - 1, 0, j);
            }
        }

        
        for (int i = 1; i &lt; m; ++i) {
            for (int j = 1; j &lt; n; ++j) {
                if(board[i][j] == '1' ){  //  只看左&amp;上
                    if(board[i - 1][j] == '1'){
                        unionFind.merge(i, j, i - 1, j);
                    }
                    if(board[i][j - 1] == '1'){
                        unionFind.merge(i, j, i, j - 1);
                    }
                }
            }
        }

        return unionFind.count();
    }
};

</pre> 
<h2 id="%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF">岛屿的最大面积</h2> 
<p><a href="https://leetcode.cn/problems/max-area-of-island/" rel="nofollow" title="力扣">力扣</a></p> 
<p>题目</p> 
<p id="u8cb5d4d4">给你一个大小为 m x n 的二进制矩阵 grid 。</p> 
<p id="uc436c8c3"></p> 
<p id="u17213d40">岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p> 
<p id="uf85d9e21"></p> 
<p id="u11559ff9">岛屿的面积是岛上值为 1 的单元格的数目。</p> 
<p id="u5300e59e"></p> 
<p id="u1a8cc150">计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p> 
<p id="u89ea8c8c"></p> 
<p id="u590f91d7">示例 1：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c6/52/CX3csbjN_o.png"></p> 
<p id="u431047de"></p> 
<p id="ue6b47773">输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]</p> 
<p id="u69b2606f">输出：6</p> 
<p id="ucae574b0">解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。</p> 
<p id="udeafaa67">示例 2：</p> 
<p id="uc5ebbf8c">输入：grid = [[0,0,0,0,0,0,0,0]]</p> 
<p id="uf6316b35">输出：0</p> 
<p id="ub1010723"></p> 
<p id="u037f4be0">提示：</p> 
<p id="u318b64bd">m == grid.length</p> 
<p id="u64ea74c2">n == grid[i].length</p> 
<p id="u91478e41">1 &lt;= m, n &lt;= 50</p> 
<p id="ubbffbe27">grid[i][j] 为 0 或 1</p> 
<p id="u326a92f9"></p> 
<p>解析</p> 
<p id="ud79e16a1">岛屿问题升级版本，一个非常典型的并查集题目，用并查集把相邻点一合并，然后提取最大size 的集合，输出size。</p> 
<p id="u9ba1be17">当然也可以使用图的遍历算法做。</p> 
<p>代码</p> 
<pre id="l1wYb">class Solution {
private:
    vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt;ancestor_;
    vector&lt;vector&lt;int&gt;&gt; size_;

public:
    bool isZeroAll (vector&lt;vector&lt;int&gt;&gt;&amp; grid) {

        for(auto line :grid) {
            for(int i : line) {
                if (i!=0) return false;
            }
        }
        return true;
    }
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        if(isZeroAll(grid)) return 0;
        init(grid);
        for(int i = 0 ; i&lt;grid.size();i++) {
            for(int j= 0;j&lt;grid[0].size();j++) {
                if(grid[i][j] == 1 ) {
                    if(i+1 &lt; grid.size() &amp;&amp; grid[i+1][j] == 1) merge({i,j},{i+1,j});
                    if(j+1 &lt; grid[0].size() &amp;&amp; grid[i][j+1] == 1) merge({i,j},{i,j+1});
                }
            }
        }
        int max =0;
        for(auto line : size_) {
            for(int size : line) {
                max = max&gt;=size? max:size;
            }
        }
    return max;
    }

    void init(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        ancestor_.resize(grid.size());
        size_.resize(grid.size());
        
        for(int i = 0; i &lt; grid.size();i++ ) {
            ancestor_[i].resize(grid[0].size());
            size_[i].resize(grid[0].size());
            for(int j = 0;j&lt;grid[0].size();j++) {
                ancestor_[i][j] = {i,j};
                size_[i][j] = 1;
            }
        }

    }
    pair&lt;int,int&gt; findAncestor(pair&lt;int,int&gt; point) {
        pair&lt;int,int&gt; p = point;
        while(1) {
            pair&lt;int,int&gt;  anc = ancestor_[p.first][p.second];
            if(anc.first == p.first &amp;&amp; anc.second == p.second) {
                return p;
            }
            p = anc;
        }

    }

    void merge(pair&lt;int,int&gt; p1, pair&lt;int,int&gt; p2) {
        pair&lt;int,int&gt; a1 = findAncestor(p1);
        pair&lt;int,int&gt; a2 = findAncestor(p2);
        if(a1 == a2) return;
        pair&lt;int,int&gt; amax = size_[a1.first][a1.second] &gt; size_[a2.first][a2.second]?ancestor_[a1.first][a1.second] :ancestor_[a2.first][a2.second] ;
        pair&lt;int,int&gt; amin = amax == ancestor_[a1.first][a1.second]?ancestor_[a2.first][a2.second]:ancestor_[a1.first][a1.second];
        size_[amax.first][amax.second] += size_[amin.first][amin.second];
     //   size_[amin.first][amin.second] = 0;
        ancestor_[amin.first][amin.second] = {amax.first,amax.second};

    }
};</pre> 
<h2 id="%E6%9C%8B%E5%8F%8B%E5%9C%88%E9%97%AE%E9%A2%98">朋友圈问题</h2> 
<p><a href="https://leetcode-cn.com/problems/friend-circles/" rel="nofollow" title="力扣">力扣</a></p> 
<p>题目</p> 
<p id="u6a4438c6">班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p> 
<p id="ub25a1334"></p> 
<p id="u78cd9a0e">给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p> 
<p id="u17baf4f8"></p> 
<p id="uba3bb2bd">示例 1：</p> 
<ul><li id="uda8dacf9">输入：</li></ul> 
<p id="u91bc509d">[[1,1,0],</p> 
<p id="u41baf534">[1,1,0],</p> 
<p id="u1f3d4dfe">[0,0,1]]</p> 
<ul><li id="u126220ef">输出：2</li><li id="ua1fae246">解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。</li></ul> 
<p id="ud173dc63">第2个学生自己在一个朋友圈。所以返回 2 。</p> 
<p id="u0c856fc7">示例 2：</p> 
<ul><li id="ua418f14e">输入：</li></ul> 
<p id="u298e59e0">[[1,1,0],</p> 
<p id="ue70c6cdd">[1,1,1],</p> 
<p id="uf6d77a62">[0,1,1]]</p> 
<ul><li id="u3d88906f">输出：1</li><li id="u36717890">解释：已知学生 0 和学生 1 互为朋友，学生 1 和学生 2 互为朋友，所以学生 0 和学生 2 也是朋友，所以他们三个在一个朋友圈，返回 1 。</li></ul> 
<p id="u91c18fa2"></p> 
<p id="u54dde2b7"></p> 
<p id="ubec2743c">提示：</p> 
<ul><li id="u56daba77">1 &lt;= N &lt;= 200</li><li id="u70d93d08">M[i][i] == 1</li><li id="u0807b8cd">M[i][j] == M[j][i]</li></ul> 
<p>解析</p> 
<p id="u8cf1e2bb">题意：给定一个二维数组，它一定是一个<strong>正方形</strong></p> 
<ul><li id="uaa2e950c">二维数组的索引可以看成是朋友圈的编号</li><li id="u61636f59">二维数组的值表示朋友之间的关系：1表示认识，0表示不认识</li></ul> 
<ul><li> 
  <ul><li id="u1e6c1564">M[i][j] = 1，表示i认识j</li><li id="ua9d62e68">由题意可以推测，M[i][j] = 1，那么M[j][i]也为1，也就是j认识i</li></ul></li></ul> 
<ul><li id="u64d83572">也就是说：</li></ul> 
<ul><li> 
  <ul><li id="ue35aede7">对角线一定全是1，因为自己是认识自己的</li></ul></li></ul> 
<ul><li> 
  <ul><li> 
    <ul><li id="u379db300">M[i][i] = 1</li></ul></li></ul></li></ul> 
<ul><li> 
  <ul><li id="ua1fa8392">而且这个矩阵是对称的</li></ul></li></ul> 
<ul><li> 
  <ul><li> 
    <ul><li id="ub63e3d73">M[i][j] = 1</li><li id="u6c9bcc62">M[i][j] = 1</li></ul></li></ul></li></ul> 
<ul><li id="uea64dcc3">求有几个朋友圈？</li></ul> 
<p id="u51d05a08"></p> 
<p id="ud500f429">分析：</p> 
<ul><li id="u6d08a310">这是一道经典的并查集问题。举个例子，如下图</li><li id="u7a079bb1">我们先根据二维数组生成一个并查集。</li><li id="u4425c6aa">刚开始时，有集合（{1}）、（{2}）、（{3}）、（{4}</li><li id="ud7c00ed0">然后一行行遍历数组</li></ul> 
<ul><li> 
  <ul><li id="u0b1770d0">刚开始第一行，对于0：</li></ul></li></ul> 
<ul><li> 
  <ul><li> 
    <ul><li id="u123b01aa">0和0是认识自己的，之前已经有了<strong>(0)</strong>，不用管</li><li id="u01bd9518">0和1不认识，不用管</li><li id="u92985f58">0和2认识，因此<strong>(0)</strong>合并<strong>（{2}）</strong>，得到<strong>{（0，2）}</strong></li><li id="u0d57f097">0和3不认识，不用管</li><li id="u0749692c">0和4认识，因此<strong>(0)</strong>合并<strong>（{2, 4}）</strong>，得到<strong>{（0，2, 4）}</strong></li></ul></li></ul></li></ul> 
<ul><li> 
  <ul><li id="ud27a0a75">然后第二行，对于1：</li></ul></li></ul> 
<ul><li> 
  <ul><li> 
    <ul><li id="ucafeed45">1和0不认识</li><li id="u6d4a318c">1和1认识，之前已经有了<strong>(1)</strong>，不用管</li><li id="uc4b647bf">1和2不认识</li><li id="u6dfd0128">1和3认识，合并<strong>（{1}）（{3}）</strong>得到<strong>{（1，3）}</strong></li><li id="u0de76d4d">1和4不认识</li></ul></li></ul></li></ul> 
<ul><li> 
  <ul><li id="u2372d849">然后第三行，对于2：</li></ul></li></ul> 
<ul><li> 
  <ul><li> 
    <ul><li id="u695f0c7c">2和0认识：原来应该得到{<!-- --><strong>(2，0)}</strong>，这个{<!-- --><strong>(2，0)}</strong>已经在第一行中出现过了，所以不用管</li><li id="u04e0b910">2和1不认识，不用管</li><li id="u9c79cbdb">2自己认识自己，不用管</li><li id="u70c0e22a">.....</li></ul></li></ul></li></ul> 
<ul><li> 
  <ul><li id="uafea63b7">然后第四行，对于3，同上</li><li id="u8f55d5ca">最后第五行，对于4，同上</li></ul></li></ul> 
<ul><li id="u9c165e69">也就是说：最终生成了两个集合： ${（0，2、4）、（1，3）}$，所以朋友圈的个数是2</li><li id="ub6dcfb59">又因为这个矩阵高度对称，所以根据这个集合生成并查集时，只遍历右上角或者左下角就可以了</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1a/e4/EuppKIhI_o.png"></p> 
<p id="ufc1940cd">流程：</p> 
<ul><li id="uc7a0a104">先根据N生成集合{0}、{1}、{2}、{3}......{N-1}</li><li id="uefb9a217">遍历矩阵的右上角，如果发现M[i][j] == 1，那么就将i和j合并</li><li id="udc7fef5a">最终返回联通量</li></ul> 
<p id="ub84a33fa"></p> 
<p id="u43ffbc52"></p> 
<p>代码</p> 
<pre id="N1lht">class Solution {
    class UnionFind{
    private:
        std::vector&lt;int&gt; parent_; // parent[i] = k ： i的父亲是k
        std::vector&lt;int&gt; size_;   // size[i] = k ： 如果i是代表节点，size[i]才有意义( i所在的集合大小是多少)，否则无意义
        std::vector&lt;int&gt; help_;  //  辅助结构
        int cnt_;               //一共有多少个集合
        
    public:
        explicit UnionFind(int n){
            cnt_ = n;
            parent_.resize(n);
            size_.resize(n);
            help_.resize(n);
            for (int i = 0; i &lt; n; ++i) {
                parent_[i] = i;
                size_[i] = 1;
            }
        }

        // 返回i的代表节点
        // 这个过程要做路径压缩
        int findRoot(int i){
            int hi = 0;
            while (i != parent_[i]){
                help_[hi++] = parent_[i];
                i = parent_[i];
            }
            for (hi--; hi &gt;= 0; --hi) {
                parent_[help_[hi]] = i;
            }
            return i;
        }

        void merge(int i, int j){
            int f1 = findRoot(i);
            int f2 = findRoot(j);
            if(f1 != f2){
                if(size_[f1] &gt;= size_[f2]){
                    parent_[f2] = f1;
                    size_[f1] = size_[f1] + size_[f2];
                }else{
                    parent_[f1] = f2;
                    size_[f2] = size_[f2] + size_[f1];
                }
                --cnt_;
            }
        }

        int counts() const{
            return cnt_;
        }
    };
    
public:
    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) {
        int N = isConnected.size();
        UnionFind unionFind(N);   //先初始化集合： {0} {1} {2} {N-1}
        // 遍历这个二维数组的右上角
        for (int i = 0; i &lt; N; ++i) {
            for (int j = i + 1; j &lt; N; ++j) {
                if(isConnected[i][j] == 1){  // i和j相互认识就合并
                    unionFind.merge(i, j);
                }
            }
        }

        // 有多少个集合就表示有多少个朋友圈
        return unionFind.counts();
    }
};
</pre> 
<h2 id="%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC%EF%BC%88hard%EF%BC%89">除法求值（hard）</h2> 
<p><a href="https://leetcode.cn/problems/evaluate-division/" rel="nofollow" title="力扣">力扣</a></p> 
<p>题目</p> 
<p id="uc2975097">给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。</p> 
<p id="u402f46cc"></p> 
<p id="uf7040af5">另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。</p> 
<p id="uf8f0bf8b"></p> 
<p id="u9040c3d9">返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。</p> 
<p id="u5c831e80"></p> 
<p id="u03ed7444">注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p> 
<p id="u1b25278c"></p> 
<p id="u94e70b14"></p> 
<p id="ud12e5e50"></p> 
<p id="ue3e66b87">示例 1：</p> 
<p id="u265f4752"></p> 
<p id="u2b980ced">输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]</p> 
<p id="u6b7bb03a">输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]</p> 
<p id="u22446531">解释：</p> 
<p id="ubadd6567">条件：a / b = 2.0, b / c = 3.0</p> 
<p id="u86d77136">问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?</p> 
<p id="u739c3824">结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]</p> 
<p id="u23c1c7eb">示例 2：</p> 
<p id="ua70f62b0"></p> 
<p id="u1310a3aa">输入：equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]</p> 
<p id="ub34d5466">输出：[3.75000,0.40000,5.00000,0.20000]</p> 
<p id="uce4ef8c9">示例 3：</p> 
<p id="u9d2b45fa"></p> 
<p id="u916b12c1">输入：equations = [["a","b"]], values = [0.5], queries = [["a","b"],["b","a"],["a","c"],["x","y"]]</p> 
<p id="ua66cbea2">输出：[0.50000,2.00000,-1.00000,-1.00000]</p> 
<p id="u82b808f8"></p> 
<p id="u365747ff"></p> 
<p id="u83e2f74b">提示：</p> 
<p id="u9d8092bc"></p> 
<p id="u105a847f">1 &lt;= equations.length &lt;= 20</p> 
<p id="u267ebd47">equations[i].length == 2</p> 
<p id="u62f2ba45">1 &lt;= Ai.length, Bi.length &lt;= 5</p> 
<p id="uaa7666be">values.length == equations.length</p> 
<p id="ude5d6b66">0.0 &lt; values[i] &lt;= 20.0</p> 
<p id="ub441c096">1 &lt;= queries.length &lt;= 20</p> 
<p id="ua5f3818d">queries[i].length == 2</p> 
<p id="uda03b097">1 &lt;= Cj.length, Dj.length &lt;= 5</p> 
<p id="uc516e83b">Ai, Bi, Cj, Dj 由小写英文字母与数字组成</p> 
<p id="uc552d8be"></p> 
<p id="ua6eae082"></p> 
<p>解析</p> 
<p id="u9fc9d9cf">本题用图来实现算mid级别的难度，但是如果用并查集就是hard级别。</p> 
<p id="ub9f67483">这个题目看到了二维数组：equations、queries，一个代表给出的条件，一个代表要求的内容，大概的思路就是从equations 中的除法关系推出queries的关系，这里有一个很重要的信息，就是“除法”，加减乘除都是属于四则运算，只要是单个符号出现，或者加减一起出现或者乘除一起出现都是满足结合率和分配律的，换句话说就是具备传染性。</p> 
<p id="uec8a7fa8">二维数组，元素之间的关系具备传染性，且可以得到两个元素之间的关系（不是权），典型的图论解决的范畴，所以在这个题目中，可以直接使用图的搜索算法做：</p> 
<ol><li id="ua0d34961">构建一个双向图，然后需要存储双向的关系，比如说a/b = 2， 那么a - &gt; b = 2, b-&gt;a = 0.5；</li><li id="u79c31e39">把图关系建立完毕之后，从queries 中找到一个值：x，然后开始广度寻找（为什么使用广度，因为在这里效率高）；</li><li id="u01f85366">直到找到queries 中y值，然后把路过的关系相乘，如果遍历完找不到y，就返回 -1，结束；</li></ol> 
<p id="ubb0713d2">PS：</p> 
<p id="u2d687cdd">1. 可以在构建图的时候搞一个hash，在queries 的时候先看数在不在。</p> 
<ol><li id="u7ccbcbfe">需要在走过一个节点的时候标记这个节点已经走过了，不然会陷入无限循环。</li></ol> 
<p id="u3c00f098"></p> 
<p id="u7352aabf"></p> 
<p id="u60ee5e96"></p> 
<p id="u4e02970e">解决之后开始想优化方法：</p> 
<p id="u6a81875d">求最短路径：从有向图找路径这个题目来说，首先想到的就是上面做的BFS、DFS这样的搜索算法，然后稍微高级一点就是找找最短路径，这里是不带权的最短路径，所以一些经典的算法基本上都可以使用，比如prim、狄杰斯特拉、弗洛伊德之类的；</p> 
<p id="u4f2c61fe"></p> 
<p id="u0a7216ab">但是不管再怎么求最短路径其实都是有时间复杂度都是比较高的，所以可以考虑用空间去换时间，这里可以使用到带权的并查集。</p> 
<p id="u00d3d648"></p> 
<p id="u31650981">带权并查集的使用思路很简单：</p> 
<p id="u1efb6199">比如 x/y = A，x的节点作为头和y的节点合并 权值设置为A；</p> 
<p id="u3b292cd7">之后 z/y = B，那么z节点、y节点分别去现有集合find，发现y在之前的集合中已经存在，然后这一对变量就直接加入，并换算得到x/z = A/B，然后x的祖先就是x，y、z 的祖先均为x。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/40/98/FEy1N07K_o.png"></p> 
<p id="u79470720">如果 之后来的是m/n = C，m与n的祖先都是自己，与之前的集合没有公共祖先，就自己形成一个集合 n的祖先为m；</p> 
<p id="u82038b7f">然后来了 m/x = D, m的祖先是自己，是一个集合，x的祖先也是自己，也是一个集合，就将两个集合合并；</p> 
<p id="u889f23e0">最后讲形成多个集合，每个集合都有一个公共祖先。</p> 
<p id="u51e88351">queries 中取出数后，就可以直接看两个数是不是同一个祖先，如果是的话，就可以直接计算拿出结果，如果不是一个公共祖先就返回 -1.</p> 
<p id="ud4784506">这样的话查找的时间复杂度会非常低，变成常数时间O（1）</p> 
<p>代码</p> 
<pre id="jfcJ2">class Solution {
public:
    int findf(vector&lt;int&gt;&amp; f, vector&lt;double&gt;&amp; w, int x) {
        if (f[x] != x) {
            int father = findf(f, w, f[x]);
            w[x] = w[x] * w[f[x]];
            f[x] = father;
        }
        return f[x];
    }

    void merge(vector&lt;int&gt;&amp; f, vector&lt;double&gt;&amp; w, int x, int y, double val) {
        int fx = findf(f, w, x);
        int fy = findf(f, w, y);
        f[fx] = fy;
        w[fx] = val * w[y] / w[x];
    }

    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {
        int nvars = 0;
        unordered_map&lt;string, int&gt; variables;

        int n = equations.size();
        for (int i = 0; i &lt; n; i++) {
            if (variables.find(equations[i][0]) == variables.end()) {
                variables[equations[i][0]] = nvars++;
            }
            if (variables.find(equations[i][1]) == variables.end()) {
                variables[equations[i][1]] = nvars++;
            }
        }
        vector&lt;int&gt; f(nvars);
        vector&lt;double&gt; w(nvars, 1.0);
        for (int i = 0; i &lt; nvars; i++) {
            f[i] = i;
        }

        for (int i = 0; i &lt; n; i++) {
            int va = variables[equations[i][0]], vb = variables[equations[i][1]];
            merge(f, w, va, vb, values[i]);
        }
        vector&lt;double&gt; ret;
        for (const auto&amp; q: queries) {
            double result = -1.0;
            if (variables.find(q[0]) != variables.end() &amp;&amp; variables.find(q[1]) != variables.end()) {
                int ia = variables[q[0]], ib = variables[q[1]];
                int fa = findf(f, w, ia), fb = findf(f, w, ib);
                if (fa == fb) {
                    result = w[ia] / w[ib];
                }
            }
            ret.push_back(result);
        }
        return ret;
    }
};
</pre> 
<h2 id="%E6%83%85%E4%BE%A3%E7%89%B5%E6%89%8B%EF%BC%88hard%EF%BC%89">情侣牵手（hard）</h2> 
<p><a href="https://leetcode.cn/problems/couples-holding-hands/" rel="nofollow" title="力扣">力扣</a></p> 
<p>题目</p> 
<p id="u5ce82825">n 对情侣坐在连续排列的 2n 个座位上，想要牵到对方的手。</p> 
<p id="uc6950593">人和座位由一个整数数组 row 表示，其中 row[i] 是坐在第 i 个座位上的人的 ID。情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)。</p> 
<p id="u81952d40">返回 最少交换座位的次数，以便每对情侣可以并肩坐在一起。 每次交换可选择任意两人，让他们站起来交换座位。</p> 
<p id="ua36a23ac">示例 1:</p> 
<p id="u3c1c435e">输入: row = [0,2,1,3]</p> 
<p id="ueb4b7603">输出: 1</p> 
<p id="ue90225a5">解释: 只需要交换row[1]和row[2]的位置即可。</p> 
<p id="uf4859a03">示例 2:</p> 
<p id="u75840ebb">输入: row = [3,2,0,1]</p> 
<p id="ube0e8fae">输出: 0</p> 
<p id="u9e4bbefa">解释: 无需交换座位，所有的情侣都已经可以手牵手了。</p> 
<p id="ubf0cb3ff"></p> 
<p id="ucfe7221c"></p> 
<p id="u6c9c3c8d">提示:</p> 
<p id="u9d9c6785">2n == row.length</p> 
<p id="uc85bfe50">2 &lt;= n &lt;= 30</p> 
<p id="uac2a9c25">n 是偶数</p> 
<p id="ua03622d3">0 &lt;= row[i] &lt; 2n</p> 
<p id="u254e1fbd">row 中所有元素均无重复</p> 
<p id="u48103300"></p> 
<p>解析</p> 
<p id="u63f8d61b">这个题目作为hard 有点名不副实，只需要搞明白一个点就很清晰了。</p> 
<p id="u225056f1">那就是 （2i，2i+1）构成一对情侣，所以可以给情侣对编号，比如N这个value就属于N/2 这个情侣对</p> 
<p id="u6e6efe4e"></p> 
<p id="u73e5de11">步骤：（假设就是数组下标% 2 等于0的为女朋友、为1的是男朋友）</p> 
<ol><li id="uc8dddc49">遍历数组找到女朋友，求出该值对应的情侣对，然后检查本来应该出现男朋友的位置，现在是哪个情侣对的</li><li id="u759b34a0">将这两个情侣对进行 merge，代表需要把人交换过来；</li><li id="u3fe56712">将所有的情侣对都遍历一遍之后，提取所有的集合，将集合的size - 1 ，就是要交换的次数</li></ol> 
<p id="u90fbe0fa"></p> 
<p>代码</p> 
<pre id="KQd4P">class Solution {
private:
    vector&lt;int&gt;ancestor_;
    vector&lt;int&gt;size_;

public:
    int minSwapsCouples(vector&lt;int&gt;&amp; row) {
        init(row);
        for(int i =0;i&lt;row.size();i+=2) {
            merge(row[i]/2,row[i+1]/2);
        }
        int count = 0;
        for(int s :size_) {
            count+=(s-1);
        }
        return count;
    }

    void init(vector&lt;int&gt;&amp; row) {
        ancestor_.resize(row.size()/2);
        size_.resize(row.size()/2);
        for(int i =0;i&lt;row.size()/2;i++) {
            ancestor_[i] = i;
            size_[i] =1;
        }
    }
    int findAncestor(int point) {
        int p = point;
        while(1) {
            int  anc = ancestor_[p];
            if(anc == p) {
                return p;
            }
            p = anc;
        }

    }

    void merge(int p1, int p2) {
        int a1 = findAncestor(p1);
        int a2 = findAncestor(p2);
        if(a1 ==a2) return;
        int amax = size_[a1] &gt; size_[a2]?ancestor_[a1] :ancestor_[a2] ;
        int amin = amax == ancestor_[a1]?ancestor_[a2]:ancestor_[a1];
        size_[amax] += size_[amin];
        size_[amin] = 1;
        ancestor_[amin] =amax;

    }
};


</pre> 
<h2 id="%E6%89%93%E7%A0%96%E5%9D%97%EF%BC%88hard%EF%BC%89">打砖块（hard）</h2> 
<p><a href="https://leetcode.cn/problems/bricks-falling-when-hit/" rel="nofollow" title="力扣">力扣</a></p> 
<p>题目</p> 
<p id="ua936bf74">有一个 m x n 的二元网格 grid ，其中 1 表示砖块，0 表示空白。砖块 稳定（不会掉落）的前提是：</p> 
<ul><li id="u31926104">一块砖直接连接到网格的顶部，或者</li><li id="uc4cc0d06">至少有一块相邻（4 个方向之一）砖块 稳定 不会掉落时</li></ul> 
<p id="u4cf842a7">给你一个数组 hits ，这是需要依次消除砖块的位置。每当消除 hits[i] = (rowi, coli) 位置上的砖块时，对应位置的<strong>砖块</strong>（若存在）会消失，然后其他的砖块可能因为这一消除操作而 掉落 。一旦砖块掉落，它会 <strong>立即</strong> 从网格 grid 中消失（即，它不会落在其他稳定的砖块上）。</p> 
<p id="u7d0323dd"></p> 
<p id="ucfffd960">返回一个数组 result ，其中 result[i] 表示第 i 次消除操作对应掉落的砖块数目。</p> 
<p id="u396295c0"></p> 
<p id="u46daa28f">注意，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。</p> 
<p id="u111c6cce"></p> 
<p id="u03a6583c"><strong>示例 1：</strong></p> 
<ul><li id="u818b4f89">输入：grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]</li><li id="u3b429f8f">输出：[2]</li><li id="u5210f62c">解释：网格开始为：</li></ul> 
<p id="u49bbad4f">[[1,0,0,0]，</p> 
<p id="u7154bade">[1,1,1,0]]</p> 
<p id="u9f9fe1c1">消除 (1,0) 处加粗的砖块，得到网格：</p> 
<p id="uf85830aa">[[1,0,0,0]</p> 
<p id="u53c93422">[0,1,1,0]]</p> 
<p id="u593ce4aa">两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：</p> 
<p id="u5ce4cc6e">[[1,0,0,0],</p> 
<p id="ua8dfb883">[0,0,0,0]]</p> 
<p id="ub51dcc7d">因此，结果为 [2] 。</p> 
<p id="udbfabe37"></p> 
<p id="u3bff4614"><strong>示例 2：</strong></p> 
<ul><li id="u3f5827af">输入：grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]</li><li id="u008d5620">输出：[0,0]</li><li id="u5a694803">解释：网格开始为：</li></ul> 
<p id="u077d3e15">[[1,0,0,0],</p> 
<p id="u677e30c4">[1,1,0,0]]</p> 
<p id="ucb8a914a">消除 (1,1) 处加粗的砖块，得到网格：</p> 
<p id="ubed6e941">[[1,0,0,0],</p> 
<p id="uac5b6217">[1,0,0,0]]</p> 
<p id="u1726258f">剩下的砖都很稳定，所以不会掉落。网格保持不变：</p> 
<p id="u24b933bd">[[1,0,0,0],</p> 
<p id="u959b798d">[1,0,0,0]]</p> 
<p id="u55209011">接下来消除 (1,0) 处加粗的砖块，得到网格：</p> 
<p id="u6486ba1c">[[1,0,0,0],</p> 
<p id="u924509d3">[0,0,0,0]]</p> 
<p id="uedc7ecd6">剩下的砖块仍然是稳定的，所以不会有砖块掉落。</p> 
<p id="u1311462d">因此，结果为 [0,0] 。</p> 
<p id="u31e2fc8f"></p> 
<p>解析</p> 
<p id="u01d4a3a7">分析：</p> 
<p id="ufd078e51">（1）什么样子的【砖块】不会掉落？</p> 
<ul><li id="u09b849ec">两种可能：</li></ul> 
<ul><li> 
  <ul><li id="u1aef8683">【砖块】位于第0行</li><li id="ufd324eeb">与第0行的【砖块】直接或者间接的相连</li></ul></li></ul> 
<p id="ue2020fed"></p> 
<p id="uf163b3a3">（2）每一枪（hits[i]）会带来什么后果？</p> 
<ul><li id="u4ecb9d5d">当前位置[hits[i][0]，hits[i][1]]不是【砖块】，没有影响</li><li id="u3a344d4f">当前位置是[hits[i][0]，hits[i][1]]【砖块】，那么有如下可能：</li></ul> 
<ul><li> 
  <ul><li id="ud0b116f7">仅仅<strong>打碎</strong>了【当前砖块】</li><li id="ucfa65200">除了<strong>打碎</strong>了【当前砖块】，还有一些【砖块】需要<strong>掉落</strong></li></ul></li></ul> 
<p id="ued50847a">（3）打碎和掉落分别是什么意思？</p> 
<ul><li id="u2e6a2a4b">我们无法收集到被打碎的砖块</li><li id="u2e260b38">一旦砖块掉落：</li></ul> 
<ul><li> 
  <ul><li id="u40271b22">它会立即从网格中消失，被我们收集到（它不会落在其他稳定的砖块上），意思是下面的这种情况不会出现</li><li id="u64d2bc28">我们这时会收集到2个掉落的砖块</li></ul></li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2f/7d/PTCbaMzF_o.png"></p> 
<p id="ufa718bb0">（4）如何判断砖块是否会掉落呢？</p> 
<ul><li id="u3c9505fa">和玩打砖块游戏一样，设置一个天花板，如果敲掉之后一组不再和天花板连接，它们就会掉下来</li><li id="u816dd86c">于是一种很直观的思路如下：</li></ul> 
<ul><li> 
  <ul><li id="uc8e23533">把所有的砖块建立一个并查集，集合的数量肯定为1</li><li id="u6052bc07">每敲掉一个地方，把它和四周的砖块断开连接</li><li id="u61bfe212">断开后原来的集合可能变成多块，也可能还是一块</li><li id="ue1a792c2">判断哪块会掉落并求所有掉落连通块的大小</li></ul></li></ul> 
<p id="u37ecaff9"></p> 
<p id="ub5554e31">（5）上面的思路有什么问题？</p> 
<ul><li id="uc4132a4a">断开连接：</li></ul> 
<ul><li> 
  <ul><li id="ua89c061d">并查集擅长的事情是合并集合，而不是断开集合。</li><li id="u52bb665d">因为在合并的过程中会有节点之间连接信息的损失，比如添加一条即将成环的边的时候，或者在做路径压缩的时候</li></ul></li></ul> 
<p id="u20b8f7d6"></p> 
<p id="u048a64e2">（6）怎么办？</p> 
<ul><li id="u375aaebb">可以逆向思考，利用并查集擅长合并的特点，从最后一次敲砖块，向前进行合并</li></ul> 
<ul><li> 
  <ul><li id="u59ba94a6">预先敲掉要敲掉的所有砖块，把剩下的砖块建立并查集</li><li id="u8d30eff1">从最后一次敲击开始向前遍历</li></ul></li></ul> 
<ul><li> 
  <ul><li> 
    <ul><li id="ue2fcc276">填回被敲掉的砖</li><li id="u765814d5">和上下左右四个邻居的砖块合并</li><li id="u025673c3">合并后-合并前的数量就是这次掉落的数量</li></ul></li></ul></li></ul> 
<ul><li id="ufa78854a">即反过来思考，将问题打碎砖块会掉落多少个砖块转化成补上砖块会新增多少个砖块粘到房顶</li></ul> 
<p id="u7ae532f5"></p> 
<p id="u18c9fcbd">思路：这道题我们可以用接在天花板上的砖的数量变化为收集答案</p> 
<p id="u40ce6f76"></p> 
<p id="u67904ed5">看个例子：</p> 
<p id="u74d65d0a">（1）先预处理grid</p> 
<ul><li id="ue302ee75">正序遍历hits，预先敲掉要敲掉的所有砖块</li></ul> 
<ul><li> 
  <ul><li id="u0c093f87">如果发现某个位置真的有砖块，那么就将这个位置变为2</li><li id="u0a4ec298">如果没有砖块，不用关心，因为它不会影响最终的结果</li></ul></li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f0/a2/7wLZu9sQ_o.png"></p> 
<p id="uba6c5205">（2）把剩下的砖块建立并查集</p> 
<ul><li id="u03a928c1">这里并查集的底层数据结构我们用二维数组来实现</li><li id="uc63c80bf">遍历grid，对每一个1独立做成一个集合</li></ul> 
<ul><li> 
  <ul><li id="uc90369e3">一开始，每一个1都是一个小集合，只属于自己，谁也不和谁相连</li><li id="u046ec145">在并查集中增加一个结构，让集合拥有一个属性：该集合是否与天花板相连。初始时，第0行的集合都与天花板相连</li><li id="u1123b493">在并查集中，还需要额外记录现在天花板上一共有多少个砖头</li></ul></li></ul> 
<ul><li id="uf0bb82a6">对每一个集合上下左右合并</li></ul> 
<ul><li> 
  <ul><li id="u501bff5a">让所有的1合并</li><li id="uba9e157d">注意，合并的过程中注意要更新属性和天花板连接的砖头数量</li></ul></li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f7/ed/9LRMj1PE_o.png"></p> 
<p id="u72f4a6e4">（3）逆序遍历hits，补上砖块，计算出会增多少个砖块粘到房顶</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/46/d2/V11UnwHi_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/69/a8/qzmDHQOJ_o.png"></p> 
<p id="ua13873c8">（3）很明显，hit的位置导致砖头掉落要分情况讨论</p> 
<ul><li id="u63c4c486">如果遍历hits发现某个grid不是2，说明打到了空白上，这个时候不会引起集合合并，什么也不会影响</li><li id="u76dc7fba">如果遍历hits发现某个grid是2，说明这个地方原本是有砖块的，那么掉落砖块数量 = now - pre - 1</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9e/5b/uBqNK38y_o.png"></p> 
<p id="u2e2d971e"></p> 
<p>代码</p> 
<pre id="yS8vq">class Solution {
    class UnionFind {
        int N;
        int M_;
        int cellingAll_; // 有多少块砖，连到了天花板上
        vector&lt;vector&lt;int&gt;&gt; grid_; // 原始矩阵，因为炮弹的影响，1 -&gt; 2
        std::vector&lt;bool&gt; cellingSet_;// cellingSet_[i] = true; i 是头节点，所在的集合是天花板集合
        std::vector&lt;int&gt; parent_;
        std::vector&lt;int&gt; size_;
        std::vector&lt;int&gt; help_;

        void initSpace(vector&lt;vector&lt;int&gt;&gt; &amp;matrix) {
            grid_ = matrix;
            N = grid_.size(), M_ = grid_[0].size();
            int all = N * M_;
            cellingAll_ = 0;
            cellingSet_.resize(all);
            parent_.resize(all);
            size_.resize(all);
            help_.resize(all);
            for (int row = 0; row &lt; N; ++row) {
                for (int col = 0; col &lt; M_; ++col) {
                    if (grid_[row][col] == 1) {
                        int index = row * M_ + col;
                        parent_[index] = index;
                        size_[index] = 1;
                        if (row == 0) {
                            cellingSet_[index] = true;
                            cellingAll_++;
                        }
                    }
                }
            }
        }

        void initConnect(){
            for (int row = 0; row &lt; N; ++row) {
                for (int col = 0; col &lt; M_; ++col) {
                    merge(row, col, row - 1, col);
                    merge(row, col, row + 1, col);
                    merge(row, col, row, col - 1);
                    merge(row, col, row, col + 1);
                }
            }
        }

        bool valid(int row, int col) {
            return row &gt;= 0 &amp;&amp; row &lt; N &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; M_ &amp;&amp; grid_[row][col] == 1;
        }

        void merge(int r1, int c1, int r2, int c2) {
            if(valid(r1, c1) &amp;&amp; valid(r2, c2)){
                int father1 = find(r1, c1);
                int father2 = find(r2, c2);
                if(father1 != father2){
                    int size1 = size_[father1];
                    int size2 = size_[father2];
                    bool status1 = cellingSet_[father1];
                    bool status2 = cellingSet_[father2];
                    if (size1 &lt;= size2) {
                        parent_[father1] = father2;
                        size_[father2] = size1 + size2;
                        if (status1 ^ status2) {
                            cellingSet_[father2] = true;
                            cellingAll_ += status1 ? size2 : size1;
                        }
                    } else {
                        parent_[father2] = father1;
                        size_[father1] = size1 + size2;
                        if (status1 ^ status2) {
                            cellingSet_[father1] = true;
                            cellingAll_ += status1 ? size2 : size1;
                        }
                    }
                }


            }
        }

        int find(int row, int col){
            int stackSize = 0;
            int idx = row * M_ + col;
            while (idx != parent_[idx]){
                help_[stackSize++] = idx;
                idx = parent_[idx];
            }
            while (stackSize != 0){
                parent_[help_[--stackSize]] = idx;
            }
            return idx;
        }

    public:
        UnionFind(vector&lt;vector&lt;int&gt;&gt; &amp;matrix) {
            initSpace(matrix);
            initConnect();
        }

        int cellingNum() {
            return cellingAll_;
        }


        int finger(int row, int col){
            // 填上grid
            grid_[row][col] = 1;
            // 对当前行对应的那个集合操作
            int cur = row * M_ + col;  // 这个位置对应的集合
            if (row == 0) {  // 如果当前是天花板上的砖块
                cellingSet_[cur] = true;
                cellingAll_++;
            }

            parent_[cur] = cur;
            size_[cur] = 1;
            int pre = cellingAll_;
            merge(row, col, row - 1, col);
            merge(row, col, row + 1, col);
            merge(row, col, row, col - 1);
            merge(row, col, row, col + 1);
            int now = cellingAll_;
            if (row == 0) { 
                return now - pre;  //pre之前已经加过1了
            } else {  
                return now == pre ? 0 : now - pre - 1;
            }
        }
    };
public:
    vector&lt;int&gt; hitBricks(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;int&gt;&gt;&amp; hits) {
        // 预处理，正序敲掉砖块
        for (int i = 0; i &lt; hits.size(); ++i) {
            if (grid[hits[i][0]][hits[i][1]] == 1) {
                grid[hits[i][0]][hits[i][1]] = 2;
            }
        }

        // 逆序补回砖块
        UnionFind unionFind  (grid);
        std::vector&lt;int&gt; ans(hits.size());
        for (int i = hits.size() - 1; i &gt;= 0; --i) {
            if (grid[hits[i][0]][hits[i][1]] == 2) {  // 只有当前位置有砖块时才去合并
                ans[i] = unionFind.finger(hits[i][0], hits[i][1]);
            }
        }
        return ans;
    }
};
</pre> 
<h2 id="%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B%EF%BC%88hard%EF%BC%89">最大人工岛（hard）</h2> 
<p><a href="https://leetcode.cn/problems/making-a-large-island/submissions/" rel="nofollow" title="力扣">力扣</a></p> 
<p>题目</p> 
<p id="ud9cecd93">给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。</p> 
<p id="ue48b3523"></p> 
<p id="u5c42bb6b">返回执行此操作后，grid 中最大的岛屿面积是多少？</p> 
<p id="uf002bbaa"></p> 
<p id="u7da200fc">岛屿 由一组上、下、左、右四个方向相连的 1 形成。</p> 
<p id="uf62fd104">示例 1:</p> 
<p id="ufd90808a">输入: grid = [[1, 0], [0, 1]]</p> 
<p id="u3026e086">输出: 3</p> 
<p id="u87d15fa5">解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。</p> 
<p id="uc5ebf957">示例 2:</p> 
<p id="uf558ee75">输入: grid = [[1, 1], [1, 0]]</p> 
<p id="u7444d477">输出: 4</p> 
<p id="u9de15a95">解释: 将一格0变成1，岛屿的面积扩大为 4。</p> 
<p id="u88252dbc">示例 3:</p> 
<p id="u835dca44">输入: grid = [[1, 1], [1, 1]]</p> 
<p id="ue671f2c6">输出: 4</p> 
<p id="ue77ec4e4">解释: 没有0可以让我们变成1，面积依然为 4。</p> 
<p id="ua210d5f9"></p> 
<p id="u93dddd04">提示：</p> 
<p id="ue880b7a6">n == grid.length</p> 
<p id="u33982045">n == grid[i].length</p> 
<p id="ud7a1ef98">1 &lt;= n &lt;= 500</p> 
<p id="ubd000395">grid[i][j] 为 0 或 1</p> 
<p id="u232a793c"></p> 
<p>解析</p> 
<p id="ua48683e7">首先看到二维数组就可以直接想到图算法，图算法中最常见的算法就是BFS、DFS，本题也确实可以使用图的遍历算法做：</p> 
<p id="ufad5b190">使用遍历图中为0的节点，假设反转为1然后利用BFS做面积计算，直到找完全部的值，然后求最大值作为面积。</p> 
<p id="u4426badc"></p> 
<p id="u6b6d554e">然后就是优化，每一个节点都去做图的遍历找面积，有很多浪费的步骤：</p> 
<ol><li id="ub01e6abf">假设a、b两个几点都挨着同一片岛，那么遍历a的时候会遍历一次面积，b的时候又会遍历一次面积；</li><li id="u4b0a8269">假设a是一个孤立点，旁边没有点，那它就算是反转了也无济于事；</li></ol> 
<p id="ub6449c71"></p> 
<p id="u853cb96e">上述的重点就是第一个，重复遍历岛的面积，所以需要一个数据结构把之前的岛的面积存下来，那么就可以顺理成章的使用并查集做这个工作了；</p> 
<p id="u519041b9"></p> 
<p id="ucede265b"></p> 
<p id="u09ccfc68"></p> 
<p id="u1f73a944">步骤：</p> 
<ol><li id="uc4cf5287">遍历每一个点，找联通域，利用并查集形成岛集合；</li><li id="uf2954eb3">遍历每一个点，判断是否为非孤立空白点2；</li></ol> 
<ol><li> 
  <ol><li id="u589305e9">若不是跳过</li><li id="uc887a2f3">若是，找上下左右4个点的祖先（属于哪个岛集合），然后把不同岛的岛size相加，记录 （max&gt; =nowSize ? max:nowSize）</li></ol></li></ol> 
<ol><li id="u06efbf05">输出最大值</li></ol> 
<p id="u97d635a1"></p> 
<p>代码</p> 
<pre id="PHXNf">class Solution {
public:
    const static inline vector&lt;int&gt; dirs = {-1, 0, 1, 0, -1};

    int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int n = grid.size();
        vector&lt;int&gt; p(n * n);
        vector&lt;int&gt; size(n * n, 1);
        iota(p.begin(), p.end(), 0);

        function&lt;int(int)&gt; find;
        find = [&amp;](int x) {
            if (p[x] != x) {
                p[x] = find(p[x]);
            }
            return p[x];
        };

        int ans = 1;
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (grid[i][j]) {
                    for (int k = 0; k &lt; 4; ++k) {
                        int x = i + dirs[k], y = j + dirs[k + 1];
                        if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; grid[x][y]) {
                            int pa = find(x * n + y), pb = find(i * n + j);
                            if (pa == pb) continue;
                            p[pa] = pb;
                            size[pb] += size[pa];
                            ans = max(ans,size[pb]);
                        }
                    }
                }
            }
        }
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (!grid[i][j]) {
                    int t = 1;
                    unordered_set&lt;int&gt; vis;
                    for (int k = 0; k &lt; 4; ++k) {
                        int x = i + dirs[k], y = j + dirs[k + 1];
                        if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; grid[x][y]) {
                            int root = find(x * n + y);
                            if (!vis.count(root)) {
                                vis.insert(root);
                                t += size[root];
                            }
                        }
                    }
                    ans = max(ans, t);
                }
            }
        }
        return ans;
    }
};</pre> 
<h2 id="%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84%EF%BC%88hard%EF%BC%89">相似字符串组（hard）</h2> 
<p>题目</p> 
<p id="u9575a508">如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。</p> 
<p id="u8296f270"></p> 
<p id="ua6ca195f">例如，"tars" 和 "rats" 是相似的 (交换 0 与 2 的位置)； "rats" 和 "arts" 也是相似的，但是 "star" 不与 "tars"，"rats"，或 "arts" 相似。</p> 
<p id="u544c4fbf"></p> 
<p id="u90b5a4da">总之，它们通过相似性形成了两个关联组：{"tars", "rats", "arts"} 和 {"star"}。注意，"tars" 和 "arts" 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</p> 
<p id="u0e10d4b5"></p> 
<p id="ue66f3c74">给你一个字符串列表 strs。列表中的每个字符串都是 strs 中其它所有字符串的一个字母异位词。请问 strs 中有多少个相似字符串组？</p> 
<p id="u14fa5e87"></p> 
<p id="udb07ab61"> 示例 1：</p> 
<ul><li id="u19f865e5">输入：strs = ["tars","rats","arts","star"]</li><li id="u4535536a">输出：2</li></ul> 
<p id="u960a8394"></p> 
<p id="u57372cc8">示例 2：</p> 
<ul><li id="u8dadfec3">输入：strs = ["omv","ovm"]</li><li id="uda471b56">输出：1</li></ul> 
<p id="uc0ad8ed4"></p> 
<p id="u237f7b3f">提示：</p> 
<ul><li id="uf174bcbe">1 &lt;= strs.length &lt;= 300</li><li id="u93165c58">1 &lt;= strs[i].length &lt;= 300</li><li id="uec57f6f8">strs[i] 只包含小写字母。</li><li id="u4ee15724">strs 中的所有单词都具有相同的长度，且是彼此的字母异位词。</li></ul> 
<p id="ua58c1921"></p> 
<p id="u982e90c6"></p> 
<p>解析</p> 
<p id="uff8eabc5">题目大意：给出一个字符串数组，要求找出这个数组中，“不相似”的字符串有多少种？</p> 
<p id="u4a720d3f">“相似字符串”的定义：</p> 
<ul><li id="u5ff36811">如果A和B字符串只需要交换一次字母的位置就能变成两个相等的字符串，那么A和B是相似的</li><li id="ud9ad9343">即：A和B相似，有两种情况：</li></ul> 
<ul><li> 
  <ul><li id="u0e58300f">A == B</li><li id="u2e0b6562">A和B只有两个字符不相等，其他字符都相等，这样交换一次才能完全相等</li></ul></li></ul> 
<ul><li id="u760441ff">而且题目中说了，字符串数组是“字母异位词”，即字符的种类和个数都完全一样，只是顺序不同</li></ul> 
<p id="udbe79e90">那么，什么叫做“相似字符串组呢”？即相似字符串组中的每个字符串都有另外至少一个字符串和它相似。比如对于 {“tars”, “rats”, “arts”} 这个相似字符串组而言，相似关系是 “tars” &lt;=&gt; “rats” &lt;=&gt; “arts” 。</p> 
<p id="u498f2325">可以看到“相似字符串组之间的关系有传递性，对于这种群组分类问题，是并查集的经典应用场合：</p> 
<ul><li id="u23444bb7">我们可以将每个字符串看成是一个节点</li><li id="u792ea7d0">如果两个字符串<strong>相似</strong>，就将它们merge</li><li id="ubbf97b76">最后数有多少个联通分量即可。</li></ul> 
<p id="u77c46294">怎么判断字符串A和字符串B是否相似呢？只要按位置对比字符，若不相等则 diff 自增1，若 diff 大于2了直接返回 false，因为只有 diff 正好等于2或者0的时候才相似。</p> 
<p id="uf4afbbc8"></p> 
<p id="u6a3d942a">这个题目作为hard 有点名不副实，理解清楚题意即可</p> 
<p id="u2fa0521f"></p> 
<p id="ue69e7b4c">PS： 这个题目有一个点比较关键，就是会存在重复的字符串，如果没有重复的字符串，就可以不用并查集，直接做一个compare函数做相似判断，然后O（N^2），做一次一一对比，求相似对就可以了；</p> 
<p id="u1430e7e8">但是因为有相似的数组，所以会出现重复记录的情况，因此需要利用并查集提前知道是否存在已经被记录的相同字符串。</p> 
<p>代码</p> 
<pre id="JlRYm">class Solution {
    class UnionFind{
    private:
        std::vector&lt;int&gt; parent_; // parent[i] = k ： i的父亲是k
        std::vector&lt;int&gt; size_;   // size[i] = k ： 如果i是代表节点，size[i]才有意义( i所在的集合大小是多少)，否则无意义
        std::vector&lt;int&gt; help_;  //  辅助结构
        int cnt_;               //一共有多少个集合

        int findRoot(int i){
            int hi = 0;
            while (i != parent_[i]){
                help_[hi++] = parent_[i];
                i = parent_[i];
            }
            for (hi--; hi &gt;= 0; --hi) {
                parent_[help_[hi]] = i;
            }
            return i;
        }
    public:
        explicit UnionFind(int n){
            cnt_ = n;
            parent_.resize(n);
            size_.resize(n);
            help_.resize(n);
            for (int i = 0; i &lt; n; ++i) {
                parent_[i] = i;
                size_[i] = 1;
            }
        }




        void merge(int i, int j){
            int f1 = findRoot(i);
            int f2 = findRoot(j);
            if(f1 != f2){
                if(size_[f1] &gt;= size_[f2]){
                    parent_[f2] = f1;
                    size_[f1] = size_[f1] + size_[f2];
                }else{
                    parent_[f1] = f2;
                    size_[f2] = size_[f2] + size_[f1];
                }
                --cnt_;
            }
        }

        int counts() const{
            return cnt_;
        }

        bool isConnected(int i, int j){
            return findRoot(i) == findRoot(j);
        }
    };

public:
    int numSimilarGroups(vector&lt;string&gt;&amp; strs) {
        int N = strs.size();
        UnionFind unionFind(N);
        for (int i = 0; i &lt; N; ++i) {
            for (int j = 0; j &lt; N; ++j) {
                // 已经连接了，不用判断相似性
                if(unionFind.isConnected(i, j)){
                    continue;
                }

                if(isSimilar(strs[i], strs[j])){
                    unionFind.merge(i, j);
                }
            }
        }

        return unionFind.counts();
    }

private:
    bool isSimilar(const string&amp; A,const string&amp; B){
        int diff = 0;
        for(int i = 0; i &lt; A.size(); i++){
            if(A[i] == B[i]){
                continue;
            }
            diff++;
        }
        return diff &lt;= 2;
    }
};
</pre> 
<h3 id="e3O90"></h3>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/302377404059f3bf045b018633a9a5c2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">error An unexpected error occurred: “https://registry.npmjs.org/ant-design-vue/解决方案：</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/750cbd4dd90e0a62817910690d7decf4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">图像采集——OV5640摄像头简介、硬件电路及上电控制的Verilog代码实现并进行modelsim仿真</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>