<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——常见的定义 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构——常见的定义" />
<meta property="og:description" content="问题答案Ο标记法（大Ο标记法）是一种用于衡量算法时间复杂度的表示方法。它描述了算法在最坏情况下的运行时间增长率。当我们使用Ο标记法时，我们关注的是算法的上界，即算法的运行时间不会超过Ο(f(n))，其中 f(n) 是输入规模 n 的某个函数。Ω标记法（大Ω标记法）与Ο标记法相反，它描述了算法在最好情况下的运行时间增长率。当我们使用Ω标记法时，我们关注的是算法的下界，即算法的运行时间不会低于Ω(g(n))，其中 g(n) 是输入规模 n 的某个函数。Θ标记法（大Θ标记法）结合了Ο标记法和Ω标记法，它描述了算法的运行时间的紧确界。当我们使用Θ标记法时，我们关注的是算法的上界和下界，即算法的运行时间在Θ(h(n)) 的范围内，其中 h(n) 是输入规模 n 的某个函数线性表的定义：线性表是由 n (n≥0) 个具有相同数据类型的元素组成的有限序列。其中，n 表示线性表的长度，可以为零。线性表中的元素之间存在一对一的关系，即每个元素都有唯一的前驱和后继，除了第一个元素没有前驱，最后一个元素没有后继。顺序表的定义及其特点：顺序表是一种使用连续的存储空间来存储线性表元素的数据结构。顺序表的特点包括：
元素在内存中的存储是连续的，可以通过下标直接访问元素。
元素的插入和删除操作可能需要移动其他元素，因为顺序表的长度是固定的。
顺序表适用于元素的访问频繁，但插入和删除操作较少的场景。链式表的定义及其特点链式表是一种使用链式存储结构来存储线性表元素的数据结构。链式表的特点包括：
元素在内存中的存储是非连续的，每个元素都包含一个指针，指向下一个元素的位置。
插入和删除操作简单高效，只需要修改指针的指向，不需要移动其他元素。
链式表的长度可以动态变化，不受固定长度的限制。
链式表适用于频繁进行插入和删除操作的场景，但访问元素需要遍历链表。线性表的应用：线性表是一种基本的数据结构，在计算机科学和软件开发中有广泛的应用。一些常见的应用包括：
数组：线性表的一种实现方式，广泛用于存储和操作一维数据。
链表：线性表的另一种实现方式，常用于实现栈、队列、链表等数据结构。
栈和队列：基于线性表的特定操作规则，用于实现各种算法和数据结构。
字符串处理：线性表可以用于存储和操作字符串，例如搜索、替换、拼接等操作。
数据库：线性表的概念在数据库中被广泛应用，例如表格中的行和列就可以看作是线性表的结构。栈的定义：栈是一种特殊的线性表，具有后进先出（LIFO）的特点。它只允许在表的一端进行插入和删除操作，该端称为栈顶。栈顶是唯一允许访问的元素，新元素插入到栈顶，而删除操作也是从栈顶删除元素。队列的定义队列也是一种特殊的线性表，具有先进先出（FIFO）的特点。它允许在表的一端（队尾）插入元素，而在另一端（队首）删除元素。新元素插入到队尾，而删除操作从队首删除元素。顺序栈的定义及其特点：顺序栈是使用数组实现的栈。它的特点包括：
使用数组作为底层数据结构，通过下标直接访问栈中的元素。
栈的大小是固定的，需要提前指定栈的最大容量。
插入和删除操作只能在栈顶进行，时间复杂度为O(1)。
当栈满时无法插入新元素，称为栈上溢。
当栈为空时无法删除元素，称为栈下溢。链式栈的定义及其特点：链式栈是使用链表实现的栈。它的特点包括：
使用链表作为底层数据结构，每个节点包含数据和指向下一个节点的指针。
栈的大小可以动态变化，不受固定容量的限制。
插入和删除操作只在栈顶进行，时间复杂度为O(1)。
不会发生栈上溢和栈下溢的情况，因为链表的长度可以根据需要进行动态调整。顺序队列的定义及其特点：顺序队列是使用数组实现的队列。它的特点包括：
使用数组作为底层数据结构，通过下标直接访问队列中的元素。
队列的大小是固定的，需要提前指定队列的最大容量。
插入操作在队尾进行，删除操作在队首进行，时间复杂度为O(1)。
当队列满时无法插入新元素，称为队列上溢。
当队列为空时无法删除元素，称为队列下溢。链式队列的定义及其特点：链式队列是使用链表实现的队列。它的特点包括：
使用链表作为底层数据结构，每个节点包含数据和指向下一个节点的指针。
队列的大小可以动态变化，不受固定容量的限制。
插入操作在队尾进行，删除操作在队首进行，时间复杂度为O(1)。
不会发生队列上溢和队列下溢的情况，因为链表的长度可以根据需要进行动态调整。栈和队列的应用：栈和队列是常用的数据结构，它们在许多应用中发挥重要作用，例如：
栈常用于表达式求值、函数调用和递归算法等场景。
队列常用于任务调度、缓冲区管理和广度优先搜索等场景。
栈和队列常用于编译器的实现，如语法分析和中间代码生成。
栈和队列在操作系统中的调度算法和内存管理中也有广泛应用。
栈和队列还可以用于解决各种算法问题，如迷宫求解和图的遍历等。二叉树的定义：二叉树是一种特殊的树结构，其中每个节点最多有两个子节点，分别称为左子节点和右子节点。二叉树的子树也是二叉树。每个节点最多有两个子节点，但可以没有子节点。树的定义：树是一种非线性的数据结构，由节点和边组成。树中有一个特殊的节点称为根节点，其他节点通过边连接起来形成层次结构。树中的节点可以有任意数量的子节点。森林的定义：森林是由多个互不相交的树组成的集合。每个树都是独立的，没有共享的节点。二叉树的实现：顺序存储结构：可以使用数组来实现二叉树。通过数组的索引关系，可以快速访问二叉树的节点。对于节点的左子节点，可以通过计算索引的方式找到；对于节点的右子节点，可以通过计算索引的方式找到。顺序存储结构在完全二叉树中效果较好，但对于非完全二叉树会造成空间浪费。
链式存储结构：使用节点对象和指针来表示二叉树。每个节点包含数据和指向左右子节点的指针。通过指针的关系，可以遍历和操作二叉树。链式存储结构比较灵活，适用于各种二叉树的情况。二叉树的遍历：先序遍历（Preorder Traversal）：根节点 -&gt; 左子树 -&gt; 右子树
中序遍历（Inorder Traversal）：左子树 -&gt; 根节点 -&gt; 右子树
后序遍历（Postorder Traversal）：左子树 -&gt; 右子树 -&gt; 根节点" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/07fd7e26ef44aaf4bf6770b86d2a9920/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-25T11:02:11+08:00" />
<meta property="article:modified_time" content="2023-12-25T11:02:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——常见的定义</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <table cellspacing="0"><tbody><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">问题</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">答案</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">Ο标记法（大Ο标记法）</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">是一种用于衡量算法时间复杂度的表示方法。它描述了算法在最坏情况下的运行时间增长率。当我们使用Ο标记法时，我们关注的是<strong>算法的上界</strong>，即算法的运行时间不会超过Ο(f(n))，其中 f(n) 是输入规模 n 的某个函数。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">Ω标记法（大Ω标记法）</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">与Ο标记法相反，它描述了算法在<strong>最好情况下</strong>的运行时间增长率。当我们使用Ω标记法时，我们关注的是算法的下界，即算法的运行时间不会低于Ω(g(n))，其中 g(n) 是输入规模 n 的某个函数。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">Θ标记法（大Θ标记法）</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">结合了Ο标记法和Ω标记法，它描述了算法的运行时间的<strong>紧确界</strong>。当我们使用Θ标记法时，我们关注的是算法的上界和下界，即算法的运行时间在Θ(h(n)) 的范围内，其中 h(n) 是输入规模 n 的某个函数</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">线性表的定义：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">线性表是由 n (n≥0) 个具有相同数据类型的元素组成的<strong>有限序列</strong>。其中，n 表示线性表的长度，可以为零。线性表中的元素之间存在一对一的关系，即每个元素都有唯一的前驱和后继，除了第一个元素没有前驱，最后一个元素没有后继。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">顺序表的定义及其特点：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">顺序表是一种使用连续的存储空间来存储线性表元素的数据结构。顺序表的特点包括：<br><br> 元素在内存中的存储是连续的，可以通过下标直接访问元素。<br> 元素的插入和删除操作可能需要移动其他元素，因为顺序表的长度是固定的。<br> 顺序表适用于元素的访问频繁，但插入和删除操作较少的场景。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">链式表的定义及其特点</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">链式表是一种使用链式存储结构来存储线性表元素的数据结构。链式表的特点包括：<br><br> 元素在内存中的存储是非连续的，每个元素都包含一个指针，指向下一个元素的位置。<br> 插入和删除操作简单高效，只需要修改指针的指向，不需要移动其他元素。<br> 链式表的长度可以动态变化，不受固定长度的限制。<br> 链式表适用于频繁进行插入和删除操作的场景，但访问元素需要遍历链表。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">线性表的应用：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">线性表是一种基本的数据结构，在计算机科学和软件开发中有广泛的应用。一些常见的应用包括：<br><br> 数组：线性表的一种实现方式，广泛用于存储和操作一维数据。<br> 链表：线性表的另一种实现方式，常用于实现栈、队列、链表等数据结构。<br> 栈和队列：基于线性表的特定操作规则，用于实现各种算法和数据结构。<br> 字符串处理：线性表可以用于存储和操作字符串，例如搜索、替换、拼接等操作。<br> 数据库：线性表的概念在数据库中被广泛应用，例如表格中的行和列就可以看作是线性表的结构。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">栈的定义：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">栈是一种特殊的线性表，具有后进先出（LIFO）的特点。它只允许在表的一端进行插入和删除操作，该端称为栈顶。栈顶是唯一允许访问的元素，新元素插入到栈顶，而删除操作也是从栈顶删除元素。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">队列的定义</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;"><span style="color:#2c3c59;">队列也是一种特殊的线性表，具有先进先出（</span><span style="color:#2c3c59;">FIFO</span><span style="color:#2c3c59;">）的特点。它允许在表的一端（队尾）插入元素，而在另一端（队首）删除元素。新元素插入到队尾，而删除操作从队首删除元素。</span></span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">顺序栈的定义及其特点：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">顺序栈是使用数组实现的栈。它的特点包括：<br><br> 使用数组作为底层数据结构，通过下标直接访问栈中的元素。<br> 栈的大小是固定的，需要提前指定栈的最大容量。<br> 插入和删除操作只能在栈顶进行，时间复杂度为O(1)。<br> 当栈满时无法插入新元素，称为栈上溢。<br> 当栈为空时无法删除元素，称为栈下溢。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">链式栈的定义及其特点：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">链式栈是使用链表实现的栈。它的特点包括：<br><br> 使用链表作为底层数据结构，每个节点包含数据和指向下一个节点的指针。<br> 栈的大小可以动态变化，不受固定容量的限制。<br> 插入和删除操作只在栈顶进行，时间复杂度为O(1)。<br> 不会发生栈上溢和栈下溢的情况，因为链表的长度可以根据需要进行动态调整。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">顺序队列的定义及其特点：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">顺序队列是使用数组实现的队列。它的特点包括：<br><br> 使用数组作为底层数据结构，通过下标直接访问队列中的元素。<br> 队列的大小是固定的，需要提前指定队列的最大容量。<br> 插入操作在队尾进行，删除操作在队首进行，时间复杂度为O(1)。<br> 当队列满时无法插入新元素，称为队列上溢。<br> 当队列为空时无法删除元素，称为队列下溢。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">链式队列的定义及其特点：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">链式队列是使用链表实现的队列。它的特点包括：<br><br> 使用链表作为底层数据结构，每个节点包含数据和指向下一个节点的指针。<br> 队列的大小可以动态变化，不受固定容量的限制。<br> 插入操作在队尾进行，删除操作在队首进行，时间复杂度为O(1)。<br> 不会发生队列上溢和队列下溢的情况，因为链表的长度可以根据需要进行动态调整。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">栈和队列的应用：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">栈和队列是常用的数据结构，它们在许多应用中发挥重要作用，例如：<br><br> 栈常用于表达式求值、函数调用和递归算法等场景。<br> 队列常用于任务调度、缓冲区管理和广度优先搜索等场景。<br> 栈和队列常用于编译器的实现，如语法分析和中间代码生成。<br> 栈和队列在操作系统中的调度算法和内存管理中也有广泛应用。<br> 栈和队列还可以用于解决各种算法问题，如迷宫求解和图的遍历等。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">二叉树的定义：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">二叉树是一种特殊的树结构，其中每个节点最多有两个子节点，分别称为左子节点和右子节点。二叉树的子树也是二叉树。每个节点最多有两个子节点，但可以没有子节点。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">树的定义：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">树是一种非线性的数据结构，由节点和边组成。树中有一个特殊的节点称为根节点，其他节点通过边连接起来形成层次结构。树中的节点可以有任意数量的子节点。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">森林的定义：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">森林是由多个互不相交的树组成的集合。每个树都是独立的，没有共享的节点。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">二叉树的实现：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">顺序存储结构：可以使用数组来实现二叉树。通过数组的索引关系，可以快速访问二叉树的节点。对于节点的左子节点，可以通过计算索引的方式找到；对于节点的右子节点，可以通过计算索引的方式找到。顺序存储结构在完全二叉树中效果较好，但对于非完全二叉树会造成空间浪费。<br><br> 链式存储结构：使用节点对象和指针来表示二叉树。每个节点包含数据和指向左右子节点的指针。通过指针的关系，可以遍历和操作二叉树。链式存储结构比较灵活，适用于各种二叉树的情况。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">二叉树的遍历：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">先序遍历（Preorder Traversal）：根节点 -&gt; 左子树 -&gt; 右子树<br> 中序遍历（Inorder Traversal）：左子树 -&gt; 根节点 -&gt; 右子树<br> 后序遍历（Postorder Traversal）：左子树 -&gt; 右子树 -&gt; 根节点<br> 层序遍历（Level Order Traversal）：按层次从上到下、从左到右遍历节点</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">二叉搜索树（Binary Search Tree）</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">一种特殊的二叉树，左子节点的值小于根节点的值，右子节点的值大于根节点的值。它支持高效的插入、删除和查找操作，常用于实现有序的数据集合。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">2-3-4树</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">一种多叉树，每个节点可以存储2个、3个或4个关键字，并且保持树的平衡。它是B树的一种变种，用于实现高效的查找和插入操作。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">B树</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">一种平衡的多路搜索树，用于处理大量数据和磁盘存储。B树的特点是每个节点可以存储多个关键字，可以自动调整树的结构以保持平衡。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">B+树</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">一种变种的B树，常用于数据库索引。与B树相比，B+树在内部节点只存储关键字，而数据都存储在叶子节点上，提高了查询效率。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">Huffman编码</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">一种用于数据压缩的算法，基于二叉树的构建和遍历。它通过将出现频率高的字符用较短的编码表示，从而实现数据的高效压缩。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">堆（Heap）</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">一种特殊的二叉树结构，分为最大堆和最小堆。堆常用于优先队列的实现，可以高效地找到最大或最小的元素。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">平衡二叉树的定义</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">平衡二叉树是一种特殊的二叉树，它的左子树和右子树的高度差不超过1。平衡二叉树的目的是保持树的平衡，避免出现极端情况下的不平衡，提高插入、删除和查找操作的效率。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">平衡因子的定义：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">平衡因子是指二叉树的左子树高度减去右子树高度的值。平衡因子可以为-1、0或1，如果平衡因子的绝对值大于1，则说明树不平衡。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">平衡二叉树的旋转操作：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">平衡二叉树可以通过旋转操作来调整树的结构，使其保持平衡。常见的旋转操作包括左旋和右旋，通过交换节点的位置来改变树的结构。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">树和森林的存储结构：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">树和森林可以使用链式存储结构来表示。每个节点包含数据和指向子节点的指针。多个树可以通过指针进行连接形成森林。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">树和森林的遍历：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">树的遍历方式包括先序遍历、中序遍历和后序遍历，与二叉树的遍历类似。森林的遍历可以通过对每个树进行遍历来实现。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">森林与二叉树的转换：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">森林可以通过将每个树转换为二叉树来实现。具体的转换方法是，对于每个树的节点，将其第一个子节点作为左子节点，将其兄弟节点作为右子节点，形成二叉树。通过这种方式，可以将森林转换为等价的二叉树。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">森林结构的应用：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">森林结构常用于并查集（Disjoint Set）的实现。并查集是一种用于处理不相交集合的数据结构，通过森林结构来表示各个集合，并提供合并和查找操作，用于解决集合的合并和查询问题。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">图的定义：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">图是由节点（顶点）和连接节点的边组成的一种数据结构。图可以用来表示各种实际问题中的关系和连接。图可以是有向的（边有方向）或无向的（边无方向），可以是带权重的（边具有权重）或无权重的。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">图的实现：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">图可以使用邻接矩阵或邻接表来进行实现。<br><br> 邻接矩阵：使用二维数组来表示图的连接关系。矩阵的行和列分别表示图中的节点，矩阵的元素表示节点之间的连接关系。对于无向图，邻接矩阵是对称的；对于有向图，邻接矩阵不一定对称。邻接矩阵适用于节点数量较少且边的数量相对较多的稠密图。<br><br> 邻接表：使用链表或数组的列表来表示图的连接关系。每个节点对应一个链表或数组，链表或数组中存储与该节点直接相连的节点。邻接表适用于节点数量较多且边的数量相对较少的稀疏图。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">图的基本操作包括：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">添加节点和边：向图中添加新的节点和边。<br> 删除节点和边：从图中删除指定的节点和边。<br> 查询节点和边：查询图中是否存在指定的节点和边。<br> 获取节点的邻居：获取与指定节点直接相连的节点。<br> 获取图的顶点数和边数：统计图中节点和边的数量。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">图的两种遍历：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">深度优先搜索（Depth-First Search，DFS）：从图的某个节点开始，沿着一条路径尽可能深入地访问节点，直到无法继续深入，然后回溯到上一个节点，继续访问其他路径。DFS使用栈来保存待访问的节点。<br><br> 广度优先搜索（Breadth-First Search，BFS）：从图的某个节点开始，首先访问该节点，然后依次访问该节点的所有邻居节点，再依次访问邻居节点的邻居节点，以此类推。BFS使用队列来保存待访问的节点。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">图的基本应用：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">最小生成树（Minimum Spanning Tree）：在无向带权图中，最小生成树是连接所有节点并且总权重最小的树。常用的算法有Prim算法和Kruskal算法。<br><br> 最短路径（Shortest Path）：在有向或无向带权图中，最短路径是指两个节点之间权重最小的路径。常用的算法有Dijkstra算法和Bellman-Ford算法。<br><br> 拓扑排序（Topological Sorting）：拓扑排序是对有向无环图进行排序，使得所有的边的起点在排序中都排在终点的前面。拓扑排序常用于任务调度、依赖关系分析等场景。<br><br> 关键路径（Critical Path）：关键路径是在有向带权图中，从起点到终点的最长路径。关键路径上的任务决定了整个项目的最短完成时间，常用于项目管理和进度控制。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">查找的定义：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">查找是指在一个数据集合中寻找特定元素的过程。在计算机科学中，查找是一种常见的操作，用于确定某个元素是否存在于给定的数据结构中，并且可能返回该元素的位置或其他相关信息。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">顺序查找法（Sequential Search）</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">顺序查找是一种简单直接的查找方法。它从数据集合的第一个元素开始，逐个比较每个元素，直到找到目标元素或遍历完整个数据集合。如果找到目标元素，返回其位置；如果遍历完整个数据集合仍未找到目标元素，则返回不存在的标记。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;"><span style="color:#2c3c59;">折半查找法（</span><span style="color:#2c3c59;">Binary Search</span><span style="color:#2c3c59;">）</span></span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">折半查找是一种高效的查找方法，但要求数据集合必须是有序的。它通过将数据集合分成两半，并与目标元素进行比较，以确定目标元素可能存在的区间。然后，根据比较结果，将查找范围缩小到可能包含目标元素的一半，并重复这个过程，直到找到目标元素或确定不存在。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">散列（Hash）技术</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">散列技术是一种基于散列函数的查找方法。散列函数将元素映射到一个固定大小的散列地址（索引），并将元素存储在该地址处。当要查找元素时，通过散列函数计算出元素的散列地址，并在该地址处查找元素。散列技术通常用于实现散列表（Hash Table）数据结构，提供快速的查找操作。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">排序的定义：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">排序是将一组数据按照特定规则重新排列的过程，使得数据按照升序或降序的方式有序排列。排序算法是计算机科学中的基本操作，广泛应用于各种应用场景，例如数据分析、数据库操作、搜索算法等。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">排序可以分为两种类型：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">内排序（Internal Sorting）：<br> 内排序是指所有待排序的数据可以全部加载到内存中进行排序。内排序算法的主要挑战是如何在有限的内存空间中高效地进行排序。<br><br> 外排序（External Sorting）：<br> 外排序是指待排序的数据量太大，无法一次性全部加载到内存中进行排序。外排序算法通过在内存和外部存储（如硬盘）之间多次读写数据，以及利用合适的数据结构和算法来完成排序。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">排序的稳定性定义：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">排序算法的稳定性指的是对于具有相同关键字的元素，在排序前后它们的相对位置是否保持不变。如果排序算法能够保持相同关键字元素的相对顺序，则称该排序算法是稳定的；否则，称该排序算法是不稳定的</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">直接插入排序（Insertion Sort）：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">从第二个元素开始，将当前元素插入已排序的子数组中的适当位置。<br> 重复上述步骤，直到所有元素都被插入到正确的位置。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;"><span style="color:#2c3c59;">冒泡排序（</span><span style="color:#2c3c59;">Bubble Sort</span><span style="color:#2c3c59;">）：</span></span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">从第一个元素开始，比较相邻的两个元素，如果顺序错误，则交换它们的位置。<br> 重复上述步骤，直到没有需要交换的元素。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">简单选择排序（Selection Sort）：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">找到未排序部分中的最小元素，将其与未排序部分的第一个元素交换位置。<br> 重复上述步骤，直到所有元素都被排序。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">Shell排序（Shell Sort）：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">根据一定的间隔将待排序的元素分组，对每个分组进行插入排序。<br> 逐渐缩小间隔，重复上述步骤，直到间隔为1，完成最后一次插入排序。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">快速排序（Quick Sort）</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">选择一个基准元素，将小于基准的元素放在左边，大于基准的元素放在右边。<br> 对左右两个子数组递归地应用相同的步骤，直到每个子数组只有一个元素或为空。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">堆排序（Heap Sort）：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">将待排序的序列构建为一个最大堆（或最小堆）。<br> 依次将堆顶元素与堆的最后一个元素交换，并重新调整堆，重复此过程直到整个序列有序。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">归并排序（Merge Sort）：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">将待排序的序列递归地划分为两个子序列，对每个子序列进行排序。<br> 将两个有序子序列合并为一个有序序列。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">基数排序（Radix Sort）：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">将待排序的元素按照各个位上的数字进行排序，从低位到高位依次进行。<br> 对每个位上的数字进行计数排序，重复上述步骤，直到所有位都被处理。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">K路归并排序（K-way Merge Sort）：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">将待排序的序列分成K个子序列，对每个子序列进行排序。<br> 将K个有序子序列合并为一个有序序列。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;"><span style="color:#2c3c59;">矩阵的定义：</span></span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">矩阵是一个按照行和列排列的二维数组。它由m行n列的元素组成，其中每个元素可以是数字、符号、字符或其他类型的数据。矩阵通常用于表示和处理多维数据，例如图像处理、线性代数、网络分析等领域。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">串的定义：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#2c3c59;"><span style="color:#2c3c59;">串是由零个或多个字符组成的有限序列。它是一种常见的数据类型，用于表示文本、字符串、</span><span style="color:#2c3c59;">DNA</span><span style="color:#2c3c59;">序列等。串中的字符可以是字母、数字、符号或其他字符。</span></span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">特殊矩阵的压缩存储：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">特殊矩阵是指具有特定规律或特殊性质的矩阵，例如对称矩阵、上三角矩阵、下三角矩阵等。由于特殊矩阵中存在大量的重复元素或零元素，可以使用压缩存储方法来减少存储空间。<br><br> 一种常见的特殊矩阵压缩存储方法是对称矩阵的压缩存储。对称矩阵是指满足A[i][j] = A[j][i]的矩阵。在压缩存储中，只需要存储矩阵的上（或下）三角部分的元素和对应的行（或列）索引即可。这样可以减少一半的存储空间。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">稀疏矩阵的三元组表示法：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">稀疏矩阵是指大部分元素为零的矩阵。为了节省存储空间，可以使用三元组表示法来表示稀疏矩阵。三元组表示法使用三个数组来存储非零元素的值、行索引和列索引。<br><br> 具体而言，对于一个m行n列的稀疏矩阵，可以定义三个数组：<br><br> value数组：存储非零元素的值，长度为非零元素的个数。<br> row数组：存储非零元素对应的行索引，长度为非零元素的个数。<br> col数组：存储非零元素对应的列索引，长度为非零元素的个数。<br> 通过这种方式，可以紧凑地表示稀疏矩阵，并且只需存储非零元素的信息，大大减少了存储空间的使用。</span></td></tr><tr><td style="vertical-align:middle;width:166px;"><span style="color:#000000;">串的模式匹配：</span></td><td style="vertical-align:middle;width:683px;"><span style="color:#000000;">串的模式匹配是指在一个较长的文本串中查找一个较短的模式串的过程。模式匹配算法用于确定模式串在文本串中的出现位置或判断是否存在匹配。<br> 一种常见的模式匹配算法是KMP算法（Knuth-Morris-Pratt算法）。KMP算法通过预处理模式串构建一个部分匹配表（Partial Match Table），然后利用这个表在文本串中进行匹配。KMP算法的关键思想是在匹配过程中，当出现不匹配的字符时，利用部分匹配表中的信息，跳过一些无需重新比较的字符，从而提高匹配效率。<br><br> 其他常见的模式匹配算法还包括朴素的暴力匹配算法、Boyer-Moore算法、Rabin-Karp算法等。每种算法都有其特点和适用场景，选择合适的模式匹配算法取决于数据规模、匹配要求和性能需求等因素。</span></td></tr></tbody></table>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/093dfc16b757b3b3e6e8cda5c3f7725d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">正运动技术荣获CMCD三项大奖，持续自主自研助力智能制造！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bc370da50be4cc028a465587dbd70d67/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue框架引入Element-Ui</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>