<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【面试宝典】2023前端面试题 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【面试宝典】2023前端面试题" />
<meta property="og:description" content="文章目录 一、HTML1、简述一下对HTML语义化的理解？2、标签上 title 与 alt 属性的区别是什么？3、href 与 src？4、HTML新特性？5、Localstorage、SessionStorage、cookie区别6、HTML5 的离线储存的使用和原理？7、常见的浏览器内核8、你对web标准以及W3C的理解？9、行内元素和块级元素有哪些？img属于什么元素10、表单中readonly和disabled的区别？11、如何进行网站性能优化？12、如何写出高性能的 HTML？13、iframe 的优缺点？ 二、CSS1、css3新特性？2、什么是盒子模型3、CSS选择器以及优先级的理解？4、谈谈你对回流和重绘的理解？5、实现元素隐藏的方式6、css 预处理器7、垂直居中几种方式？8、简明说一下 CSS link 与 @import 的区别和用法？9、display:none和visibility:hidden的区别？10、rgba和opacity的透明效果有什么不同？11、行内元素与块级元素有什么区别？12、清除浮动的方式13、引入样式表CSS的方式有几种？分别是什么？优先级是什么？13、如何实现浏览器响应式布局？ 三、JS1、JS数据类型2、如何判断js的数据类型3、创建对象的几种方式4、js内置的常用对象有哪些？并列举该对象的常用方法5、===与 = =的区别6、怎么判断两个对象相等7、函数提升与变量提升的区别8、什么是闭包？9、箭头函数的特点10、简述this的含义11、js中new操作符主要干了什么？12、js中call、apply、bind作用和区别13、什么是作用域？全局作用域和局部作用域？14、什么是事件冒泡？怎么阻止事件冒泡？15、什么是事件委托？16、面向对象的特点？17、简述深浅拷贝以及深拷贝的方法18、防抖与节流19、ajax过程？20、请解释一下 JavaScript 的同源策略21、如何解决跨域？22、内存泄漏23、javascript的内存(垃圾)回收机制？23、什么是原型、原型链？24、get与post的区别25、let、var、const区别26、promise对象简述27、async、await 四、VUE1.vue的双向绑定原理2.MVVM、MVC3.vue的优点4.为什么vue组件中的data是一个函数***为什么使用return返回？ 5.VUE全家桶6.v-for中key的作用7.vue2的缺点8.什么是虚拟dom，为什么要使用虚拟dom9.v-for和v-if能否一起使用10.computed和watch的区别watch都有哪些属性 11.v-if和v-show的区别12.vue的生命周期13.vue的指令15.vue组件如何进行传值的？16.组件中写name会有什么作用？17.父子组件嵌套时生命周期哦钩子函数的执行顺序18、vuex19、谈谈你对keep-alive的理解20、vue-router路由模式有几种？21、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？22、谈一谈你对 nextTick 的理解？23、$nextTick的使用24、请说出 vue-cli 工程中每个文件夹和文件的用处?25、Vuex 页面刷新数据丢失怎么解决？26、Vuex 为什么要分模块并且加命名空间？27、vue 中使用了哪些设计模式？28、你都做过哪些 Vue 的性能优化？ 五、其他内容1、性能优化的几个方面?2、异步加载?3、加载方式4、预加载5、DNS预解析6、懒执行7、懒加载 一、HTML 1、简述一下对HTML语义化的理解？ 用正确的标签做正确的事情。
HTML语义化让页面的内容结构化，结构更清晰，便于浏览器、搜索引擎解析；即使在没有css样式的情况下，也以一种文档格式显示，并且是容易阅读的
搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于seo优化
使阅读源代码的人更容易将网站分块，便于阅读维护理解
2、标签上 title 与 alt 属性的区别是什么？ 通常当鼠标滑动到元素上的时候显示
alt 是img标签 的特有属性，是图片内容的等价描述，
用于图片无法加载显示、读屏器阅读图片。可提图片高可访问性，
除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。
3、href 与 src？ href (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。（目的不是为了引用资源，而是为了建立联系，让当前标签能够链接到目标地址。）src source（缩写），指向外部资源的位置，指向的内容将会应用到文档中当前标签所在位置。href与src的区别:1、请求资源类型不同：href 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；2、作用结果不同：href 用于在当前文档和引用资源之间确立联系；src 用于替换当前内容；3、浏览器解析方式不同：当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。 4、HTML新特性？ 新增用于绘画的 canvas 和 svg 元素" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/f4de21b35939ab82ff007c3034e77d7c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-14T18:13:25+08:00" />
<meta property="article:modified_time" content="2023-02-14T18:13:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【面试宝典】2023前端面试题</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#HTML_1" rel="nofollow">一、HTML</a></li><li><ul><li><a href="#1HTML_2" rel="nofollow">1、简述一下对HTML语义化的理解？</a></li><li><a href="#2_title__alt__7" rel="nofollow">2、标签上 title 与 alt 属性的区别是什么？</a></li><li><a href="#3href__src_12" rel="nofollow">3、href 与 src？</a></li><li><a href="#4HTML_20" rel="nofollow">4、HTML新特性？</a></li><li><a href="#5LocalstorageSessionStoragecookie_31" rel="nofollow">5、Localstorage、SessionStorage、cookie区别</a></li><li><a href="#6HTML5__51" rel="nofollow">6、HTML5 的离线储存的使用和原理？</a></li><li><a href="#7_99" rel="nofollow">7、常见的浏览器内核</a></li><li><a href="#8webW3C_116" rel="nofollow">8、你对web标准以及W3C的理解？</a></li><li><a href="#9img_143" rel="nofollow">9、行内元素和块级元素有哪些？img属于什么元素</a></li><li><a href="#10readonlydisabled_152" rel="nofollow">10、表单中readonly和disabled的区别？</a></li><li><a href="#11_163" rel="nofollow">11、如何进行网站性能优化？</a></li><li><a href="#12_HTML_190" rel="nofollow">12、如何写出高性能的 HTML？</a></li><li><a href="#13iframe__285" rel="nofollow">13、iframe 的优缺点？</a></li></ul> 
  </li><li><a href="#CSS_301" rel="nofollow">二、CSS</a></li><li><ul><li><a href="#1css3_302" rel="nofollow">1、css3新特性？</a></li><li><a href="#2_334" rel="nofollow">2、什么是盒子模型</a></li><li><a href="#3CSS_348" rel="nofollow">3、CSS选择器以及优先级的理解？</a></li><li><a href="#4_365" rel="nofollow">4、谈谈你对回流和重绘的理解？</a></li><li><a href="#5_387" rel="nofollow">5、实现元素隐藏的方式</a></li><li><a href="#6css__395" rel="nofollow">6、css 预处理器</a></li><li><a href="#7_400" rel="nofollow">7、垂直居中几种方式？</a></li><li><a href="#8_CSS_link__import__414" rel="nofollow">8、简明说一下 CSS link 与 @import 的区别和用法？</a></li><li><a href="#9displaynonevisibilityhidden_419" rel="nofollow">9、display:none和visibility:hidden的区别？</a></li><li><a href="#10rgbaopacity_422" rel="nofollow">10、rgba和opacity的透明效果有什么不同？</a></li><li><a href="#11_424" rel="nofollow">11、行内元素与块级元素有什么区别？</a></li><li><a href="#12_434" rel="nofollow">12、清除浮动的方式</a></li><li><a href="#13CSS_448" rel="nofollow">13、引入样式表CSS的方式有几种？分别是什么？优先级是什么？</a></li><li><a href="#13_464" rel="nofollow">13、如何实现浏览器响应式布局？</a></li></ul> 
  </li><li><a href="#JS_475" rel="nofollow">三、JS</a></li><li><ul><li><a href="#1JS_476" rel="nofollow">1、JS数据类型</a></li><li><a href="#2js_481" rel="nofollow">2、如何判断js的数据类型</a></li><li><a href="#3_568" rel="nofollow">3、创建对象的几种方式</a></li><li><a href="#4js_581" rel="nofollow">4、js内置的常用对象有哪些？并列举该对象的常用方法</a></li><li><a href="#5___663" rel="nofollow">5、===与 = =的区别</a></li><li><a href="#6_670" rel="nofollow">6、怎么判断两个对象相等</a></li><li><a href="#7_677" rel="nofollow">7、函数提升与变量提升的区别</a></li><li><a href="#8_691" rel="nofollow">8、什么是闭包？</a></li><li><a href="#9_699" rel="nofollow">9、箭头函数的特点</a></li><li><a href="#10this_704" rel="nofollow">10、简述this的含义</a></li><li><a href="#11jsnew_714" rel="nofollow">11、js中new操作符主要干了什么？</a></li><li><a href="#12jscallapplybind_718" rel="nofollow">12、js中call、apply、bind作用和区别</a></li><li><a href="#13_727" rel="nofollow">13、什么是作用域？全局作用域和局部作用域？</a></li><li><a href="#14_734" rel="nofollow">14、什么是事件冒泡？怎么阻止事件冒泡？</a></li><li><a href="#15_737" rel="nofollow">15、什么是事件委托？</a></li><li><a href="#16_740" rel="nofollow">16、面向对象的特点？</a></li><li><a href="#17_744" rel="nofollow">17、简述深浅拷贝以及深拷贝的方法</a></li><li><a href="#18_756" rel="nofollow">18、防抖与节流</a></li><li><a href="#19ajax_759" rel="nofollow">19、ajax过程？</a></li><li><a href="#20_JavaScript__766" rel="nofollow">20、请解释一下 JavaScript 的同源策略</a></li><li><a href="#21_770" rel="nofollow">21、如何解决跨域？</a></li><li><a href="#22_775" rel="nofollow">22、内存泄漏</a></li><li><a href="#23javascript_784" rel="nofollow">23、javascript的内存(垃圾)回收机制？</a></li><li><a href="#23_790" rel="nofollow">23、什么是原型、原型链？</a></li><li><a href="#24getpost_820" rel="nofollow">24、get与post的区别</a></li><li><a href="#25letvarconst_826" rel="nofollow">25、let、var、const区别</a></li><li><a href="#26promise_834" rel="nofollow">26、promise对象简述</a></li><li><a href="#27asyncawait_841" rel="nofollow">27、async、await</a></li></ul> 
  </li><li><a href="#VUE_854" rel="nofollow">四、VUE</a></li><li><ul><li><a href="#1vue_856" rel="nofollow">1.vue的双向绑定原理</a></li><li><a href="#2MVVMMVC_866" rel="nofollow">2.MVVM、MVC</a></li><li><a href="#3vue_873" rel="nofollow">3.vue的优点</a></li><li><a href="#4vuedata_876" rel="nofollow">4.为什么vue组件中的data是一个函数***</a></li><li><ul><li><a href="#return_881" rel="nofollow">为什么使用return返回？</a></li></ul> 
   </li><li><a href="#5VUE_884" rel="nofollow">5.VUE全家桶</a></li><li><a href="#6vforkey_888" rel="nofollow">6.v-for中key的作用</a></li><li><a href="#7vue2_891" rel="nofollow">7.vue2的缺点</a></li><li><a href="#8domdom_895" rel="nofollow">8.什么是虚拟dom，为什么要使用虚拟dom</a></li><li><a href="#9vforvif_903" rel="nofollow">9.v-for和v-if能否一起使用</a></li><li><a href="#10computedwatch_908" rel="nofollow">10.computed和watch的区别</a></li><li><ul><li><a href="#watch_927" rel="nofollow">watch都有哪些属性</a></li></ul> 
   </li><li><a href="#11vifvshow_933" rel="nofollow">11.v-if和v-show的区别</a></li><li><a href="#12vue_939" rel="nofollow">12.vue的生命周期</a></li><li><a href="#13vue_957" rel="nofollow">13.vue的指令</a></li><li><a href="#15vue_978" rel="nofollow">15.vue组件如何进行传值的？</a></li><li><a href="#16name_995" rel="nofollow">16.组件中写name会有什么作用？</a></li><li><a href="#17_1000" rel="nofollow">17.父子组件嵌套时生命周期哦钩子函数的执行顺序</a></li><li><a href="#18vuex_1010" rel="nofollow">18、vuex</a></li><li><a href="#19keepalive_1020" rel="nofollow">19、谈谈你对keep-alive的理解</a></li><li><a href="#20vuerouter_1025" rel="nofollow">20、vue-router路由模式有几种？</a></li><li><a href="#21_vuerouter__hash__history__1049" rel="nofollow">21、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</a></li><li><a href="#22_nextTick__1066" rel="nofollow">22、谈一谈你对 nextTick 的理解？</a></li><li><a href="#23nextTick_1071" rel="nofollow">23、$nextTick的使用</a></li><li><a href="#24_vuecli__1074" rel="nofollow">24、请说出 vue-cli 工程中每个文件夹和文件的用处?</a></li><li><a href="#25Vuex__1085" rel="nofollow">25、Vuex 页面刷新数据丢失怎么解决？</a></li><li><a href="#26Vuex__1092" rel="nofollow">26、Vuex 为什么要分模块并且加命名空间？</a></li><li><a href="#27vue__1103" rel="nofollow">27、vue 中使用了哪些设计模式？</a></li><li><a href="#28_Vue__1114" rel="nofollow">28、你都做过哪些 Vue 的性能优化？</a></li></ul> 
  </li><li><a href="#_1131" rel="nofollow">五、其他内容</a></li><li><ul><li><a href="#1_1132" rel="nofollow">1、性能优化的几个方面?</a></li><li><a href="#2_1138" rel="nofollow">2、异步加载?</a></li><li><a href="#3_1142" rel="nofollow">3、加载方式</a></li><li><a href="#4_1145" rel="nofollow">4、预加载</a></li><li><a href="#5DNS_1153" rel="nofollow">5、DNS预解析</a></li><li><a href="#6_1162" rel="nofollow">6、懒执行</a></li><li><a href="#7_1166" rel="nofollow">7、懒加载</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="HTML_1"></a>一、HTML</h2> 
<h3><a id="1HTML_2"></a>1、简述一下对HTML语义化的理解？</h3> 
<blockquote> 
 <p>用正确的标签做正确的事情。<br> HTML语义化让页面的内容结构化，结构更清晰，便于浏览器、搜索引擎解析；即使在没有css样式的情况下，也以一种文档格式显示，并且是容易阅读的<br> 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于seo优化<br> 使阅读源代码的人更容易将网站分块，便于阅读维护理解</p> 
</blockquote> 
<h3><a id="2_title__alt__7"></a>2、标签上 title 与 alt 属性的区别是什么？</h3> 
<blockquote> 
 <p>通常当鼠标滑动到元素上的时候显示<br> alt 是img标签 的特有属性，是图片内容的等价描述，<br> 用于图片无法加载显示、读屏器阅读图片。可提图片高可访问性，<br> 除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</p> 
</blockquote> 
<h3><a id="3href__src_12"></a>3、href 与 src？</h3> 
<blockquote> 
 <ul><li>href (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。（目的不是为了引用资源，而是为了建立联系，让当前标签能够链接到目标地址。）</li><li>src source（缩写），指向外部资源的位置，指向的内容将会应用到文档中当前标签所在位置。</li><li>href与src的区别:</li><li>1、请求资源类型不同：href 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；</li><li>2、作用结果不同：href 用于在当前文档和引用资源之间确立联系；src 用于替换当前内容；</li><li>3、浏览器解析方式不同：当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。</li></ul></blockquote> 
<h3><a id="4HTML_20"></a>4、HTML新特性？</h3> 
<blockquote> 
 <p>新增用于绘画的 canvas 和 svg 元素<br> 新增 video（视频） 和 audio（音频） 标签<br> 新增客户端数据存储新方法：sessionStorage、localStorage<br> 新增多个语义化标签元素：<br> ·header、nav、article、section、aside、footer<br> 表单的增强应用：<br> ·表单元素 input 的 type 属性扩充：<br> ·date、time、email、url、search、range、month、color、number ·表单元素 input 通过属性进行表单验证：<br> ·required（必填项）、pattern（正则表达式验证表单输入）<br> 新增地理定位 - Geolocation API 用于获得用户的地理位置</p> 
</blockquote> 
<h3><a id="5LocalstorageSessionStoragecookie_31"></a>5、Localstorage、SessionStorage、cookie区别</h3> 
<blockquote> 
 <p>1、cookie<br> （1）本身用于客户端和服务端通信<br> （2）但是它有本地存储的功能，于是就被“借用”<br> （3）document.cookie = …获取和修改即可<br> （4）cookie用于存储的缺点<br> ①存储量太小，只有4kb<br> ②所有http请求都带着，会影响获取资源的效率<br> ③api简单，需要封装才能用document.cookie</p> 
</blockquote> 
<blockquote> 
 <p>2、localStorage,sesseionStorage<br> （1）html5专门为存储而设计，最大容量5M<br> （2）api简单易用<br> （3）lcoalStorage.setItem(key, value);localStorage.getItem(key);<br> （4）ios safari隐藏模式下:localStorage.getItem会报错，建议统一使用try-catch封装</p> 
</blockquote> 
<blockquote> 
 <p>3、sessionStorage用于本地存储一个会话（session）中的数据，<br> 这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。<br> 因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。<br> 而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p> 
</blockquote> 
<h3><a id="6HTML5__51"></a>6、HTML5 的离线储存的使用和原理？</h3> 
<pre><code class="prism language-html">相似存储

localStorage 长期存储数据，浏览器关闭后数据不丢失； sessionStorage 数据在浏览器关闭后自动删除。

离线的存储

两种方式

HTML5 的离线存储.appcache文件【废弃】
service-worker 的标准
HTML5 的离线存储.appcache文件【废弃】

在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。

原理：HTML5 的离线存储是基于一个新建的。appcache 文件的缓存机制（不是存储技术），通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。

之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。

如何使用

1、页面头部像下面一样加入一个 manifest 的属性
2、在 cache.manifest 文件的编写离线存储的资源

CACHE MANIFEST
#v0.11
CACHE:
js/app.js
css/style.css
NETWORK:
resourse/logo.png
FALLBACK:
/ /offline.html
 

3、在离线状态时，操作 window.applicationCache 进行需求实现。

service-worker

可以参考

http://www.alloyteam.com/2019/07/web-applications-offline/
https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers
————————————————
版权声明：本文为CSDN博主「孙叫兽」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_41937552/article/details/111591669
</code></pre> 
<h3><a id="7_99"></a>7、常见的浏览器内核</h3> 
<pre><code class="prism language-html">**Trident内核：**代表浏览器是ie浏览器，因此Trident内核又称E内核，
  此内核只能用于Windows平台，并且不是开源的。

**Gecko内核：**代表浏览器是Firefox浏览器。Gecko内核是开源的，
  最大优势是可以跨平台。

**Webkit内核:代表浏览器是Safari(苹果的浏览器)以及低版本的谷歌浏览器，
  是开源的项目。

**Presto内核：**代表浏览器是Opera浏览器(中文译为“欧朋浏览器”)，
  Presto内核是世界公认最快的渲染速度的引擎，但是在2013年之后，
  Open宣布加入谷歌阵营，弃用了该内核。

**Blink内核：**由谷歌和Opera开发，2013年4月发布，现在Chrome内核是Blink。
</code></pre> 
<h3><a id="8webW3C_116"></a>8、你对web标准以及W3C的理解？</h3> 
<pre><code class="prism language-html">web标准：

    web标准主要分为结构、表现、行为3部分

    结构：指我们平时在body里面写的标签，主要是由HTML标签组成

    表现：指更加丰富HTML标签样式，主要由CSS样式组成

    行为：指页面和用户的交互，主要由JS部分组成
W3C：

W3C对web标准提出了规范化的要求，即代码规范

对结构的要求

1、标签字母要小写

2、标签要闭合

3、标签不允许随意嵌套
对表现和行为的要求

1、建议使用外链CSS和js脚本，实现结构与表现分离、结构与行为分离，
能提高页面的渲染效率，更快地显示网页内容
</code></pre> 
<h3><a id="9img_143"></a>9、行内元素和块级元素有哪些？img属于什么元素</h3> 
<blockquote> 
 <p>特点：<br> 块级元素：独占一行；可设置宽高；margin 和 padding 均有效；<br> 行内元素：不独占一行，可在一行显示；设置宽高无效；margin 上下无效、左右有效；padding 均有效；<br> 行内块元素：不独占一行，可在一行显示；可以设置宽高；margin 和 padding 均有效；<br> 转换：<br> 转为块元素：display: block;<br> 转为行内元素： display: inline;<br> 转为行内块元素：display: inline-block;</p> 
</blockquote> 
<h3><a id="10readonlydisabled_152"></a>10、表单中readonly和disabled的区别？</h3> 
<blockquote> 
 <p>共同点：能够使用户不能改变表单中的内容</p> 
</blockquote> 
<blockquote> 
 <p>不同点：<br> 1、readonly只对input和textarea有效，但是disabled对所有的表单元素都是有效的，<br> 包括radio、checkbox<br> 2、readonly可以获取到焦点，只是不能修改。<br> disabled设置的文本框无法获取焦点<br> 3、如果表单的字段是disabled，则该字段不会发送（表单传值）和序列化</p> 
</blockquote> 
<h3><a id="11_163"></a>11、如何进行网站性能优化？</h3> 
<pre><code class="prism language-html">content 方面
减少 HTTP 请求：合并文件、CSS 精灵、inline Image
减少 DNS 查询：DNS 缓存、将资源分布到恰当数量的主机名
减少 DOM 元素数量
Server 方面
使用 CDN
配置 Etag
对组件使用 Gzip 压缩
Cookie 方面
减少cookie大小
css 方面
将样式表放到页面顶部
不使用 CSS 表达式
使用 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span><span class="token punctuation">&gt;</span></span> 不使用 @import
Javascript 方面
将脚本放到页面底部
将 javascript 和 css 从外部引入
压缩 javascript 和 css
删除不需要的脚本
减少 DOM 访问
图片方面
优化图片：根据实际颜色需要选择色深、压缩
优化 css 精灵
不要在 HTML 中拉伸图片
</code></pre> 
<h3><a id="12_HTML_190"></a>12、如何写出高性能的 HTML？</h3> 
<pre><code class="prism language-html">避免使用 Iframe

Iframe 也叫内联 frame，可以把一个 HTML 文档嵌入到另一个文档中。使用 iframe 的好处是被嵌入的文档可以完全独立于其父文档，
凭借此特点我们通常可以使浏览器模拟多线程，需要注意的是使用 iframe 并不会增加同域名下的并行下载数，
浏览器对同域名的连接总是共享浏览器级别的连接池，即使是跨窗口或跨标签页，这在所有主流浏览器都是如此。
也因为这样这让 iframe 带来的好处大打折扣。

在页面加载过程中 iframe 元素会阻塞父文档 onload 事件的触发，而开发者程序通常会在 onload 事件触发时初始化 UI 操作。
例如，设置登录区域的焦点。因为用户习惯等待这一操作，所以尽可能的让 onload 事件触发从而使用户的等待时间变短是非常重要的。
另外开发者会把一些重要的行为绑定在 unload 事件上，而不幸的是在一些浏览器中，只有当 onload 事件触发后 unload 事件才能触发，
如果 onload 事件长时间未触发，而用户已经离开当前页面，那么 unload 事件也将永远得不到触发。
 那是否有方案可以让 onload 事件不被 iframe 阻塞吗？有个简单的解决方案来避免 onload 事件被阻塞，
 使用 JavaScript 动态的加载 iframe 元素或动态设置 iframe 的 src 属性：

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>iframe1</span> <span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">&gt;</span></span>
document.getElementById(‘iframe1’).setAttribute(‘src’， ‘url’);
但其仅在高级浏览器 中有效，对于 Internet Explorer 8 及以下的浏览器无效。
除此之外我们必须知道 iframe 是文档内最消耗资源的元素之一，在 Steve Souders 的测试中 ，在测试页面中分别加载 100 个 A、DIV、
SCRIPT、STYLE 和 IFRAME 元素，并且分别在 Chrome、Firefox、Internet Explorer、Opera、Safari 中运行了 10 次。
结果显示创建 iframe 元素的开销比创建其他类型的 DOM 元素要高 1~2 个数量级。在测试中所有的 DOM 元素都是空的，
如加载大的脚本或样式块可能比加载某些 iframe 元素耗时更长，但从基准测试结果来看，即使是空的 iframe，其开销也是非常昂贵的，
鉴于 iframe 的高开销，我们应尽量避免使用。尤其是对于移动设备，对于目前大部分还是只有有限的 CPU 与内存的情况下，
更应避免使用 iframe。

避免空链接属性

空的链接属性是指 img、link、script、ifrrame 元素的 src 或 href 属性被设置了，但是属性却为空。如<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span><span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>，
我们创建了一个图片，并且暂时设置图片的地址为空，希望在未来动态的去修改它。但是即使图片的地址为空，
浏览器依旧会以默认的规则去请求空地址：

Internet Explorer 8 及以下版本浏览器只在 img 类型元素上出现问题，IE 会把 img 的空地址解析为当前页面地址的目录地址。
例如：如果当前页面地址为 http://example.com/dir/page.html，IE 会把空地址解析为 http://example.com/dir/ 地址并请求。
早些版本的 Webkit 内核浏览器 与 Firefox 会把空地址解析为当前页面的地址。如果页面内有多个空链接属性元素，
当前页面的服务器则会被请求多次，增加服务器的负载。相较桌面浏览器对内核的更新升级较积极，
这个问题在 ios 与 android 系统的移动浏览器上问题可能较严重。幸运的是所有主流浏览器面对 iframe 的 src 属性为空时，
会把空地址解析为 about:blank 地址，而不会向服务器发出额外的请求。



避免节点深层级嵌套

深层级嵌套的节点在初始化构建时往往需要更多的内存占用，并且在遍历节点时也会更慢些，这与浏览器构建 DOM 文档的机制有关。
例如下面 HTML 代码：

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>
Hello World
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>example.png<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
通过浏览器 HTML 解析器的解析，浏览器会把整个 HTML 文档的结构存储为 DOM 树结构。
当文档节点的嵌套层次越深，构建的 DOM 树层次也会越深。


缩减 HTML 文档大小

提高下载速度最显而易见的方式就是减少文件的大小，特别是压缩内嵌在 HTML 文档中的 JavaScript 和 CSS 代码，
这能使得页面体积大幅精简。除此之外减少 HTML 文档大小还可以采取下面几种方法：

删掉 HTM 文档对执行结果无影响的空格空行和注释
避免 Table 布局
使用 HTML5
显式指定文档字符集

HTML 页面开始时指定字符集，有助于浏览器可以立即开始解析 HTML 代码。HTML 文档通常被解析为一序列的带字符集编码信息的字符串
通过 internet 传送。字符集编码在 HTTP 响应头中，或者 HTML 标记中指定。浏览器根据获得的字符集，
把编码解析为可以显示在屏幕上的字符。如果浏览器不能获知页面的编码字符集，一般都会在执行脚本和渲染页面前，把字节流缓存，
然后再搜索可进行解析的字符集，或以默认的字符集来解析页面代码，这会导致消耗不必要的时间。
为了避免浏览器把时间花费在搜寻合适的字符集来进行解码，所以最好在文档中总是显式的指定页面字符集。

显式设置图片的宽高

当浏览器加载页面的 HTML 代码时，有时候需要在图片下载完成前就对页面布局进行定位。

如果 HTML 里的图片没有指定尺寸（宽和高），或者代码描述的尺寸与实际图片的尺寸不符时，
浏览器则要在图片下载完成后再 “回溯” 该图片并重新显示，这会消耗额外时间。

所以，最好为页面里的每一张图片都指定尺寸，不管是在页面 HTML 里的<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span><span class="token punctuation">&gt;</span></span> 标签，还是在 CSS 里。

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hello.png<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>400<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>300<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
避免脚本阻塞加载

当浏览器在解析常规的 script 标签时，它需要等待 script 下载完毕，再解析执行，而后续的 HTML 代码只能等待。
为了避免阻塞加载，应把脚步放到文档的末尾，如把 script 标签插入在 body 结束标签之前：

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>example.js<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

————————————————
版权声明：本文为CSDN博主「孙叫兽」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_41937552/article/details/111591669
</code></pre> 
<h3><a id="13iframe__285"></a>13、iframe 的优缺点？</h3> 
<blockquote> 
 <p>优点：</p> 
 <ul><li>解决加载缓慢的第三方内容如图标和广告等的加载问题</li><li>Security sandbox</li><li>并行加载脚本</li><li> 缺点： 
 </li><li>iframe会阻塞主页面的Onload事件</li><li>即时内容为空，加载也需要时间</li><li>没有语意</li></ul></blockquote> 
<h2><a id="CSS_301"></a>二、CSS</h2> 
<h3><a id="1css3_302"></a>1、css3新特性？</h3> 
<blockquote> 
 <p>颜色：新增 RGBA，HSLA 模式,新增透明度<br> 盒子阴影：（box-shadow）<br> 边框：<br> 边框圆角：（border-radius）<br> 边框阴影：（box-shadow）<br> 边框图片：（border-image）<br> 弹性盒子模型：（box-sizing：border-box;）<br> 背景：<br> background-size ：设置背景图片的尺寸<br> background-origin ：设置背景图片的原点（定位、位置）<br> background-clip ：设置背景图片的裁切区域，以”，”分隔，可以设置多背<br> 景，用于自适应布局。<br> 渐变：<br> linear-gradient：（线性渐变）<br> radial-gradient ：（径向渐变）<br> 新增过渡效果：<br> transition，配合动态伪类使用<br> 自定义动画：<br> animation 定义动画：@keyframes 动画名称<br> 媒体查询@media，多栏布局: @media screen and (width:500px) {<!-- --><br> …<br> }<br> 2D 转换：<br> transform：translate(x，y) 移动<br> rotate(x，y) 旋转<br> skew(x，y) 翻转<br> scale(x，y) 缩放<br> 3D 转换<br> 字体图标 ： font-face<br> 弹性布局 ：flex<br> 新增多种选择器（结构伪类选择器、动态伪类选择器、属性选择器等）</p> 
</blockquote> 
<h3><a id="2_334"></a>2、什么是盒子模型</h3> 
<blockquote> 
 <p>盒模型分为两类：标准盒模型和怪异盒模型（IE 盒模型）<br> 盒模型的组成部分（由外向内）：<br> margin（外边距）+ border（边框）+ padding（内边距）+ content（盒子内容大小）<br> 注：<br> 标准盒模型的 width 指的是内容 content 的宽度，height 指的是 content 的高度<br> 怪异盒模型的 width 指的是内容、边框、内边距总的宽度（content + border + padding）；<br> height 指的是内容、边框、内边距总的高度<br> 盒子转换方式：<br> 如果 doctype 协议缺失，会由浏览器自己界定。<br> 在 IE 浏览器中 IE9 以下（IE6、IE7、IE8）的版本触发怪异模式，其他浏览器中会默认<br> 为 W3C 标准模式。<br> box-sizing: content-box 标准盒模型<br> box-sizing: border-box IE 盒模型</p> 
</blockquote> 
<h3><a id="3CSS_348"></a>3、CSS选择器以及优先级的理解？</h3> 
<pre><code class="prism language-html">常用的CSS选择器

    ID选择器、类选择器、标签选择器、属性选择器、伪类选择器、后代选择器

权重划分

  在同一层级下：

  !important &gt; 内联样式 &gt; ID选择器 &gt; 类选择器 &gt; （标签选择器、伪类选择器、属性选择器）

不同层级下：

    正常来说权重值越高的优先级越高，但是一直以来没有具体的权重值划分，
    所以目前大多数开发中层级越深的优先级越高
</code></pre> 
<h3><a id="4_365"></a>4、谈谈你对回流和重绘的理解？</h3> 
<blockquote> 
 <p>什么是回流？<br><br> 当一个元素自身的宽高，布局，显示或隐藏，或元素内部的文字结构发生变化<br> ，导致需要重新构建页面的时候，就产生了回流复制</p> 
</blockquote> 
<blockquote> 
 <p>什么是重绘？<br><br> 当一个元素自身的宽高，布局，及显示或隐藏没有改变，<br> 而只是改变了元素的外观风格的时候，就产生了重绘</p> 
</blockquote> 
<blockquote> 
 <p>什么时候会进行回流？<br><br> 添加或者删除可见的 DOM 元素的时候<br> 元素的位置发生改变<br> 元素的尺寸发生改变<br> 内容改变<br> 页面第一次渲染的时候</p> 
</blockquote> 
<blockquote> 
 <p>什么时候会进行重绘？<br><br> 列举一些相关的 CSS 样式：color、background、<br> background-size、visibility、box-shadow</p> 
</blockquote> 
<h3><a id="5_387"></a>5、实现元素隐藏的方式</h3> 
<pre><code class="prism language-html">opacity：0; /* 设置透明度为 0 */
display：none; /* 设置透明度为 0 */
visibility：hidden; /* 设置透明度为 0 */
transform:scale(0) /* CSS3 的新特性，让元素缩小至 0 */
z-index:-9999; /* 设置元素的层级，需给元素设置定位 position : absolute; */
</code></pre> 
<h3><a id="6css__395"></a>6、css 预处理器</h3> 
<pre><code class="prism language-html">less
sass
</code></pre> 
<h3><a id="7_400"></a>7、垂直居中几种方式？</h3> 
<blockquote> 
 <p>单行文本: line-height = height<br> 图片: vertical-align: middle;<br> 盒子：1. 定位（子绝父相）实现垂直居中<br> 父元素：相对定位；<br> 子元素：绝对定位；<br> top:calc(50% - 子元素自身的一半) /<em>子元素需具备高度</em>/<br> left:calc(50% - 子元素自身的一半) /<em>子元素需具备宽度</em>/<br> 2. 定位+transform: translate(-50%, -50%)（常用）<br> 3. fixed 定位居中<br> 4. flex 弹性布局居中(常用)<br> 给父盒子设置 display:flex; justify-content:center; align-items:center;</p> 
</blockquote> 
<h3><a id="8_CSS_link__import__414"></a>8、简明说一下 CSS link 与 @import 的区别和用法？</h3> 
<blockquote> 
 <p>link 是 XHTML 标签，除了加载CSS外，还可以定义 RSS 等其他事务；@import 属于 CSS 范畴，只能加载 CSS。<br> link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。<br> link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持。<br> link 支持使用 Javascript 控制 DOM 去改变样式；而@import不支持。</p> 
</blockquote> 
<h3><a id="9displaynonevisibilityhidden_419"></a>9、display:none和visibility:hidden的区别？</h3> 
<blockquote> 
 <p>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。<br> visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p> 
</blockquote> 
<h3><a id="10rgbaopacity_422"></a>10、rgba和opacity的透明效果有什么不同？</h3> 
<blockquote> 
 <p>opacity 会继承父元素的 opacity 属性，而 RGBA 设置的元素的后代元素不会继承不透明属性。</p> 
</blockquote> 
<h3><a id="11_424"></a>11、行内元素与块级元素有什么区别？</h3> 
<blockquote> 
 <p>① 排列方式：<br> 行内元素间会在同一行进行排列（水平方向）；<br> 块级元素独占一行，垂直向下排列（垂直方向）<br> ②宽高和内外边距：<br> 行内元素设置宽高无效，宽高随文本内容的变化而变化，但可以设置行高；<br> 行内元素设置内外边距（margin 和 padding）上下无效，左右有效；<br> ③元素嵌套：<br> 块级元素可以包含行内元素和块级元素，还可以容纳内联元素和其他元素；<br> 行内元素不能包含块级元素，只能容纳文本或者其他行内元素</p> 
</blockquote> 
<h3><a id="12_434"></a>12、清除浮动的方式</h3> 
<blockquote> 
 <p>1 给浮动元素的父元素添加高度（不推荐）<br> 2 给父盒子添加 overflow:hidden;来清除浮动（不推荐）<br> 3 空标签法：给父盒子内部的最后面添加一个空标签（必须为块级标签），并给空标<br> 签设置 clear:both;（不推荐）<br> 4.双伪元素清除浮动（推荐）：<br> .clearfix::before,.clearfix::after {<!-- --><br> content: ’’;<br> clear: both;<br> display: block;<br> height: 0;<br> visibility: hidden;<br> zoom: 1;//兼容IE6<br> }</p> 
</blockquote> 
<h3><a id="13CSS_448"></a>13、引入样式表CSS的方式有几种？分别是什么？优先级是什么？</h3> 
<blockquote> 
 <p>在HTML中常用以下四种方式定义CSS<br><br> inline（内联式，也称行内样式）、<br> embedding（嵌入式）、<br> linking（外部引用式）<br> 导入样式表（@import ）。<br><br> <b>详细</b><br> 一：内联式/行内样式：使用该属性可以直接指定样式，当然，该样式仅能用于该元素的内容，对于另一个同名的元素则不起作用。<br> 二：嵌入式（style）：用户可在HTML文档头部定义多个style元素，实现多个样式表。<br> 三：外部引用式（link）<br><br> ①可以在多个文档间共享样式表，对于较大规模的网站，将CSS样式定义独立成一个一个的文档，可有效地提高效率，并有利于对网站风格的维护。<br> ②可以改变样式表，而无需更改HTML文档，这也与HTML语言内容与形式分开的原则相一致。<br> ③可以根据介质有选择的加载样式表。<br> 四：导入样式表：@import url(“css/base.css”);<br><br> 优先级:就近原则<br><br> <b>内联式&gt;内嵌式&gt;外部引用式&gt;导入样式表</b></p> 
</blockquote> 
<h3><a id="13_464"></a>13、如何实现浏览器响应式布局？</h3> 
<pre><code class="prism language-html">常用如下
    使用媒体查询（@media）
    使用flex弹性布局
    使用百分比单位
    使用rem单位
    使用VH、HW单位

推荐一种冷门万能自适应方式：tranfrom:scale(动态比值)
</code></pre> 
<h2><a id="JS_475"></a>三、JS</h2> 
<h3><a id="1JS_476"></a>1、JS数据类型</h3> 
<blockquote> 
 <p>基本数据类型<br> Number、String、Boolean、Null、Undefined、Symbol、bigInt<br> 引用数据类型<br> object、Array、Date、Function、RegExp</p> 
</blockquote> 
<h3><a id="2js_481"></a>2、如何判断js的数据类型</h3> 
<blockquote> 
 <p>判断方法<br> typeof<br> typeof 可以用来区分除了 Null 类型以外的原始数据类型，对象类型的可以从普通对象里面<br> 识别出函数：</p> 
</blockquote> 
<pre><code class="prism language-html">typeof undefined // "undefined"
typeof null // "object"
typeof 1 // "number"
typeof "1" // "string"
typeof Symbol() // "symbol"
typeof function() {} // "function"
typeof {} // "object"

</code></pre> 
<blockquote> 
 <p>问题一：typeof 不能识别 null，如何识别 null？<br> 答案：如果想要判断是否为 null，可以直接使用===全等运算符来判断（或者使用下面的<br> Object.prototype.toString 方法）：</p> 
</blockquote> 
<pre><code class="prism language-html">let a = null
a === null // true
</code></pre> 
<blockquote> 
 <p>问题二：typeof 作用于未定义的变量，会报错吗？<br> 答案：不会报错，返回"undefined"。</p> 
</blockquote> 
<pre><code class="prism language-html">typeof randomVariable // "undefined" 
</code></pre> 
<blockquote> 
 <p>问题三：typeof Number(1)的返回值是什么？<br> 答案：“number”。注意 Number 和 String 作为普通函数调用的时候，是把参数转化为相 应<br> 的原始数据类型，也就是类似于做一个强制类型转换的操作，而不是默认当做构造函数 调<br> 用。注意和 Array 区分，Array(…)等价于 new Array(…)</p> 
</blockquote> 
<pre><code class="prism language-html">typeof Number(1) // "number"
typeof String("1") // "string" Array(1, 2, 3)
// 等价于
new Array(1, 2, 3)
</code></pre> 
<blockquote> 
 <p>问题四：typeof new Number(1)的返回值是什么？<br> 答案：“object”。</p> 
</blockquote> 
<pre><code class="prism language-html">typeof new Number(1) // "object"
typeof new String(1) // "object"
</code></pre> 
<blockquote> 
 <p>instanceof<br> instanceof 不能用于判断原始数据类型的数据：<br> 3 instanceof Number // false<br> ‘3’ instanceof String // false<br> true instanceof Boolean // false<br> instanceof 可以用来判断对象的类型：<br> var date = new Date()<br> date instanceof Date // true var number = new Number()<br> number instanceof Number // true var string = new String()<br> string instanceof String // true</p> 
</blockquote> 
<p>需要注意的是，instanceof 的结果并不一定是可靠的，因为在 ECMAScript7 规范中可以通过自定义 Symbol.hasInstance 方法来覆盖默认行为。</p> 
<pre><code class="prism language-html">Object.prototype.toString
Object.prototype.toString.call(undefined).slice(8, -1) // "Undefined" 
Object.prototype.toString.call(null).slice(8, -1) // "Null" 
Object.prototype.toString.call(3).slice(8, -1) // "Number" 
Object.prototype.toString.call(new Number(3)).slice(8, -1) // "Number" 
Object.prototype.toString.call(true).slice(8, -1) // "Boolean" 
Object.prototype.toString.call('3').slice(8, -1) // "String" 
Object.prototype.toString.call(Symbol()).slice(8, -1) // "Symbol"
</code></pre> 
<p>由上面的示例可知，该方法没有办法区分数字类型和数字对象类型，同理还有字符串类型和字符串对象类型、布尔类型和布尔对象类型<br> 另外，ECMAScript7 规范定义了符号 Symbol.toStringTag，你可以通过这个符号自定义Object.prototype.toString 方法的行为：</p> 
<pre><code class="prism language-html">'use strict' 
var number = new Number(3)
number[Symbol.toStringTag] = 'Custom' Object.prototype.toString.call(number).slice(8, -1) // "Custom"
function a () {}
a[Symbol.toStringTag] = 'Custom'
 Object.prototype.toString.call(a).slice(8, -1) // "Custom" 
 var array = []
array[Symbol.toStringTag] = 'Custom' 
Object.prototype.toString.call(array).slice(8, -1) // "Custom" 
</code></pre> 
<p>因为 Object.prototype.toString 方法可以通过 Symbol.toStringTag 属性来覆盖默认行 为，所以使用这个方法来判断数据类型也不一定是可靠的</p> 
<pre><code class="prism language-html">Array.isArray
Array.isArray(value)可以用来判断 value 是否是数组：
Array.isArray([]) // true
Array.isArray({}) // false
(function () {console.log(Array.isArray(arguments))}()) // false
</code></pre> 
<h3><a id="3_568"></a>3、创建对象的几种方式</h3> 
<blockquote> 
 <p>创建方法<br> 1、字面量对象 // 默认这个对象的原型链指向 object var o1 = {name: ‘01’};<br> 2、通过 new Object 声明一个对象<br> var o11 = new Object({name: ‘011’});<br> 3、使用显式的构造函数创建对象<br> var M = function(){this.name=‘o2’};<br> var o2 = new M();<br> o2.<strong>proto</strong>=== M.prototype<br> o2 的构造函数是 M<br> o2 这个普通函数，是 M 这个构造函数的实例<br> 4、object.create() var P = {name:‘o3’};<br> var o3 = Object.create§;</p> 
</blockquote> 
<h3><a id="4js_581"></a>4、js内置的常用对象有哪些？并列举该对象的常用方法</h3> 
<blockquote> 
 <p>Array数组、Boolean、Date、Error、Math、Number、Obejct、RegExp、String、Function</p> 
</blockquote> 
<blockquote> 
 <p><strong>Array</strong><br> reverse() 将数组中各元素颠倒顺序<br> delete 运算符 只能删除数组元素的值，而所占空间还在，总长度没变(arr.length)<br> shift() 删除数组中第一个元素，返回删除的那个值，并将长度减 1<br> pop() 删除数组中最后一个元素，返回删除的那个值，并将长度减 1<br> unshift() 往数组前面添加一个或多个数组元素，长度要改变。arrObj.unshift(“a” ，<br> “b，“c”)<br> push() 往数组结尾添加一个或多个数组元素，长度要改变。arrObj.push(“a” ，“b”，<br> “c”)<br> concat( ) 连接数组<br> slice( ) 返回数组的一部分<br> sort( ) 对数组元素进行排序<br> splice( ) 插入、删除或替换数组的元素</p> 
</blockquote> 
<blockquote> 
 <p>Boolean 布尔对象<br> Boolean.toString( ) 将布尔值转换成字符串<br> Boolean.valueOf( ) Boolean 对象的布尔值</p> 
</blockquote> 
<blockquote> 
 <p>Date<br> Date.getDate( ) 返回一个月中的某一天<br> Date.getDay( ) 返回一周中的某一天<br> Date.getFullYear( ) 返回 Date 对象的年份字段<br> Date.getHours( ) 返回 Date 对象的小时字段<br> Date.getMilliseconds( ) 返回 Date 对象的毫秒字段<br> Date.getMinutes( ) 返回 Date 对象的分钟字段<br> Date.getMonth( ) 返回 Date 对象的月份字段<br> Date.getSeconds( ) 返回 Date 对象的秒字段<br> Date.getTime( ) 返回 Date 对象的毫秒表示</p> 
</blockquote> 
<blockquote> 
 <p>Error<br> Error 异常对象<br> Error.message 可以读取的错误消息<br> Error.name 错误的类型<br> Error.toString( ) 把 Error 对象转换成字符串<br> EvalError 在不正确使用 eval()时抛出<br> SyntaxError 抛出该错误用来通知语法错误<br> RangeError 在数字超出合法范围时抛出<br> ReferenceError 在读取不存在的变量时抛出<br> TypeError 当一个值的类型错误时，抛出该异常<br> URIError 由 URl 的编码和解码方法抛出<br> Math<br> Math.ceil() 向上取整(整数加 1，小数去掉)<br> Math.floor() 向下取整(直接去掉小数)<br> Math.round() 四舍五入</p> 
</blockquote> 
<blockquote> 
 <p>Number<br> Number.toString( ) 将—个数字转换成字符串<br> Number.valueOf( ) 返回原始数值</p> 
</blockquote> 
<blockquote> 
 <p>Object<br> Object.toString( ) 定义一个对象的字符串表示</p> 
</blockquote> 
<blockquote> 
 <p>RegExp<br> RegExp.exec( ) 通用的匹配模式<br> RegExp.global 正则表达式是否全局匹配<br> RegExp.ignoreCase 正则表达式是否区分大小写<br> RegExp.lastIndex 下次匹配的起始位置<br> RegExp.source 正则表达式的文本<br> RegExp.test( ) 检测一个字符串是否匹配某个模式<br> RegExp.toString( ) 把正则表达式转换成字符串</p> 
</blockquote> 
<blockquote> 
 <p>String<br> substr() 在原始字符串，返回一个子字符串<br> substring() 在原始字符串，返回一个子字符串<br> split() 将一个字符串转成数组<br> concat( ) 连接字符串<br> lastIndexOf( ) 从后向前检索一个字符串</p> 
</blockquote> 
<blockquote> 
 <p>Function<br> Function.apply( ) 将函数作为一个对象的方法调用<br> Function.arguments[] 传递给函数的参数<br> Function.call( ) 将函数作为对象的方法调用<br> Function.caller 调用当前函数的函数<br> Function.length 已声明的参数的个数<br> Function.prototype 对象类的原型<br> Function.toString( ) 把函数转换成字符串</p> 
</blockquote> 
<h3><a id="5___663"></a>5、===与 = =的区别</h3> 
<blockquote> 
 <p>===：三个等号我们称为等同符，当等号两边的值为相同类型的时候，直接比较等号两边<br> 的值，值相同则返回 true，若等号两边的值类型不同时直接返回 false。也就是说三个等号<br> 既要判断值也要判断类型是否相等<br> = =：两个等号我们称为等值符，当等号两边的值为相同类型时比较值是否相同，类型不同<br> 时会发生类型的自动转换，转换为相同的类型后再作比较。也就是说两个等号只要值相等<br> 就可以</p> 
</blockquote> 
<h3><a id="6_670"></a>6、怎么判断两个对象相等</h3> 
<blockquote> 
 <p>思路是要遍历对象的所有键名和键值是否都一致</p> 
</blockquote> 
<blockquote> 
 <p>1、判断两个对象是否指向同一内存<br> 2、使用 Object.getOwnPropertyNames 获取对象所有键名数组<br> 3、判断两个对象的键名数组是否相等<br> 4、遍历键名，判断键值是否都相等</p> 
</blockquote> 
<h3><a id="7_677"></a>7、函数提升与变量提升的区别</h3> 
<blockquote> 
 <p>变量提升<br> 简单说就是在 JavaScript 代码执行前引擎会先进行预编译，预编译期间会将变量声明与函数声明提 升至其对应作用域的最顶端，函数内声明的变量只会提升至该函数作用域最顶层当函数内部定义的一个变量与外部相同时，那么函数体内的这个变量就会被升到最顶端<br> 举例来说：<br> console.log(a); //<br> undefined var a = 3; //预编译后的代码结构可以看做如下运行顺序 var a; // 将变量 a 的声明提升至最顶端，赋值逻辑不提升。 console.log(a); // undefined a = 3; // 代码执行到原位置即执行原赋值逻辑<br> 函数提升<br> 函数提升只会提升函数声明式写法，函数表达式的写法不存在函数提升<br> 函数提升的优先级大于变量提升的优先级，即函数提升在变量提升之上</p> 
</blockquote> 
<blockquote> 
 <p>在js中变量和函数的声明会提升到最顶部执行<br> 函数的提升高于变量的提升<br> 函数内部如果用 var 声明了相同名称的外部变量，函数将不再向上寻找。<br> 匿名函数不会提升。</p> 
</blockquote> 
<h3><a id="8_691"></a>8、什么是闭包？</h3> 
<blockquote> 
 <p>闭包就是能够读取其他函数内部变量的函数<br> 闭包基本上就是一个函数内部返回一个函数<br><br> 特点：1.函数嵌套函数<br><br> ​ 2.内部函数可以访问外部变量<br><br> ​ 3.参数和变量不会被回收（回收牵扯出全局变量和局部变量，因为全局变量在页面关闭后销毁，比较占内存资源。局部变量在函数执行完毕后销毁，闭包保护局部变量不会在函数执行完被回收也就是销毁）</p> 
</blockquote> 
<p>不能滥用闭包，会导致内存泄漏（本应该会回收的变量没有被回收）</p> 
<h3><a id="9_699"></a>9、箭头函数的特点</h3> 
<blockquote> 
 <p>不需要function关键字来创建函数<br> 省略return关键字<br> 改变this指向</p> 
</blockquote> 
<h3><a id="10this_704"></a>10、简述this的含义</h3> 
<blockquote> 
 <p>this 指的是调用函数的那个对象<br> this 在没有运行之前不能知道代表谁;js的this 指向是不确定的；<br> 和定义没有关系，和执行有关.执行的时候，点前面是谁，this 就是谁；<br> 自执行函数里面的this 代表的是 window<br> 定时器书写的时候，window可以省略掉；定时器执行的时候，里面的this 代表的也是 window ；<br> this 是js的一个关键字，随着函数使用场合不同，this 的值会发生变化。<br> 如果有new关键字，this指向new出来的对象<br> 在事件中，this指向触发这个事件的对象</p> 
</blockquote> 
<h3><a id="11jsnew_714"></a>11、js中new操作符主要干了什么？</h3> 
<blockquote> 
 <p>创建一个空对象，并且this变量引用该对象，同时还继承了该函数的原型<br> 属性和方法被加入到this引用的对象中<br> 新创建的对象this所引用，并且最后隐式返回this</p> 
</blockquote> 
<h3><a id="12jscallapplybind_718"></a>12、js中call、apply、bind作用和区别</h3> 
<blockquote> 
 <p>Call<br> 第一个参数是this指向的新环境 第二个参数及以后的参数，是传递给调用者新环境的参数，调用者此时在新环境被中执行 第一个参数可以为函数也可以为this，如果为null,则表示执行window 用来改变this指向</p> 
</blockquote> 
<blockquote> 
 <p>Apply<br> 第一个参数是this指向的新环境 第二个参数要传递给新环境的参数数组</p> 
</blockquote> 
<blockquote> 
 <p>Bind<br> 第一个参数是this指向的新环境 第二个参数要传递给新环境的参数 返回一个改变this 指向的新函数，对原函数没有影响</p> 
</blockquote> 
<h3><a id="13_727"></a>13、什么是作用域？全局作用域和局部作用域？</h3> 
<blockquote> 
 <p>概念：代码（变量）可以使用的范围就是作用域。主要是为了提高程序的可靠性，也是为了减少命名冲突<br><br> 全局作用域和局部作用域<br> 全局作用域：指的是整个js文件，定义在全局中的全局变量，可以在局部作用域中使用，函数内部没有声明直接赋值的变量也叫全局变量<br> 局部作用域：主要指的是函数作用域，函数内部也就是局部作用域<br> 在函数内部var定义的变量-，叫做局部变量，局部变量无法被外部获取</p> 
</blockquote> 
<h3><a id="14_734"></a>14、什么是事件冒泡？怎么阻止事件冒泡？</h3> 
<blockquote> 
 <p>概念：当我们点击子元素触发父元素的事件，这种现象，我们叫做事件冒泡，即由子元素向祖先元素传播，就像气泡从水底上浮<br> event.stopPropagation();阻止事件冒泡</p> 
</blockquote> 
<h3><a id="15_737"></a>15、什么是事件委托？</h3> 
<blockquote> 
 <p>通俗的讲，子代有事，让父级执行，当我们点击li时，子元素会通过事件的冒泡来触发父元素的事件，主要是通过事件冒泡<br> <strong>原理：</strong> 不要给每个子节点单独设置事件监听器，而是事件监听设置在其父节点上，然后利用冒泡原理影响设置每个子节点</p> 
</blockquote> 
<h3><a id="16_740"></a>16、面向对象的特点？</h3> 
<blockquote> 
 <p>​ 抽象：把主要特征跟问题抽象出来<br><br> ​ 封装：把方法写在内部，外部调用<br><br> ​ 继承：可以从父类继承方法和属性，而子类又有自己独特的属性</p> 
</blockquote> 
<h3><a id="17_744"></a>17、简述深浅拷贝以及深拷贝的方法</h3> 
<blockquote> 
 <p>浅拷贝：基本数据类型拷贝的是值，引用数据类型拷贝的是地址<br> 深拷贝：引用数据类型拷贝的是开辟新地址中的值</p> 
</blockquote> 
<blockquote> 
 <p>深拷贝的方法<br> 对象和字符串的相转化<br> ​ var a = JSON.stringify(one);//先转字符串再转对象​ var b = JSON.parse(a);<br><br> 封装开辟新地址的函数<br> ​ function deepCopy(obj){​ var objs = JSON.stringify(obj);​ var newObj = JSON.parse(objs);​ return newObj;​ }<br><br> 数组的解决方法<br> 数组的解决方法，只要有返回新数组的均可以解决这个问题<br> slice、 concat 、split等</p> 
</blockquote> 
<h3><a id="18_756"></a>18、防抖与节流</h3> 
<blockquote> 
 <p><strong>节流</strong> ：在频繁接触的函数中，指的是在一定时间中只执行一次，适应于所有频繁触发的事件<br> <strong>防抖</strong> ： 在频繁触发的函数中，只执行最后一次，主要思路，当事件一段事件没有继续触发时，我们的事件处理函数才会执行一次</p> 
</blockquote> 
<h3><a id="19ajax_759"></a>19、ajax过程？</h3> 
<blockquote> 
 <p>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.<br> (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.<br> (3)设置响应HTTP请求状态变化的函数.<br> (4)发送HTTP请求.<br> (5)获取异步调用返回的数据.<br> (6)使用JavaScript和DOM实现局部刷新.</p> 
</blockquote> 
<h3><a id="20_JavaScript__766"></a>20、请解释一下 JavaScript 的同源策略</h3> 
<blockquote> 
 <p>概念:同源策略是客户端脚本（尤其是Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。<br> 这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。<br> 指一段脚本只能读取来自同一来源的窗口和文档的属性。</p> 
</blockquote> 
<h3><a id="21_770"></a>21、如何解决跨域？</h3> 
<blockquote> 
 <p>jsonp跨域<br> document.domain + iframe 跨域<br> nodejs中间件代理跨域cros<br> 后端在头部信息里面设置安全域名</p> 
</blockquote> 
<h3><a id="22_775"></a>22、内存泄漏</h3> 
<blockquote> 
 <p>定义：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放引发的各种问题。<br> js中可能出现的内存泄漏情况：结果：变慢，崩溃，延迟大等<br> js中可能出现的内存泄漏原因<br> 全局变量<br> dom 清空时，还存在引用<br> 定时器未清除<br> 子元素存在引起的内存泄露</p> 
</blockquote> 
<h3><a id="23javascript_784"></a>23、javascript的内存(垃圾)回收机制？</h3> 
<blockquote> 
 <p>垃圾回收器会每隔一段时间找出那些不再使用的内存，然后为其释放内存<br><br> 一般使用标记清除方法(mark and sweep), 当变量进入环境标记为进入环境，离开环境标记为离开环境<br> 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了<br><br> 还有引用计数方法(reference counting), 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。<br><br> 在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的， 也就是说只要涉及BOM及DOM就会出现循环引用问题。</p> 
</blockquote> 
<h3><a id="23_790"></a>23、什么是原型、原型链？</h3> 
<blockquote> 
 <p>1.任何对象都有 proto 隐式原型, 等于 构造函数 的 prototype</p> 
 <pre><code class="prism language-html">const obj = {}
obj.__proto__ === Object.prototype // true
</code></pre> 
 <p>2.任何函数都有 prototype 显示原型 等于 原型对象(就是一个普通对象包含公共属性)<br> *(通过Function.prototype.bind方法构造出来的函数是个例外，它没有prototype属性)</p> 
 <pre><code class="prism language-html">function Person () {}
Person.prototype = 原型对象
Person.prototype.constructor === Person // true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>
const person1 = new Person
person1.__proto__ === Person.prototype // true
person1.constructor == Person // true
</code></pre> 
 <p>3.对象还具有 constructor 属性，指向构造函数（Person.prototype.constructor == Person）<br> 4.原型链是依赖于__proto__, 查找一个属性会沿着 proto 原型链向上查找，直到找到为止。<br> 5.特殊</p> 
 <pre><code class="prism language-html">// 原型链最终点是 null 
Object.prototype.__proto__ === null // true
obj.__proto__.__proto__ === null // true
</code></pre> 
 <p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，<br> 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，<br> 于是就这样一直找下去，也就是我们平时所说的原型链的概念。<br> 关系：instance.constructor.prototype = instance.proto<br> 特点：<br> JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p> 
</blockquote> 
<h3><a id="24getpost_820"></a>24、get与post的区别</h3> 
<blockquote> 
 <p>get 通过地址栏拼接参数，但是因为地址栏长度有限，所以get传输数据也有限<br> post 没有数据传输大小的限制<br> get不需要设置请求头post需要设置请求头<br> get请求数据可能被缓存post不会<br> get只能URL编码，post支持的编码格式众多</p> 
</blockquote> 
<h3><a id="25letvarconst_826"></a>25、let、var、const区别</h3> 
<table><thead><tr><th>var</th><th>let</th><th>const</th></tr></thead><tbody><tr><td>只有全局作用域和函数作用域</td><td>有块级作用域</td><td>有块级作用域</td></tr><tr><td>存在变量提升</td><td>不存在变量提升</td><td>不存在变量提升</td></tr><tr><td>可以重复声明</td><td>不能重复声明</td><td>不能重复声明</td></tr><tr><td>没有死区</td><td>存在暂时性死区</td><td>存在暂时性死区</td></tr><tr><td>可以先声明后赋值</td><td>可以先声明 后赋值</td><td>声明即赋值</td></tr></tbody></table> 
<h3><a id="26promise_834"></a>26、promise对象简述</h3> 
<blockquote> 
 <p>三种状态：pending(进行中)，fulfilled(已成功)，reject(已失败)<br><br> promise是es6引入异步编程新解决方案，语法上promise是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。<br><br> Promise构建出来的实例存在以下方法： then() 是实例状态发生改变时的回调函数，第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数 catch() 用于指定发生错误时的回调函数 finally() 用于指定不管 Promise 对象最后状态如何，都会执行的操作<br><br> 1）promise构造函数：promise（excutor）{}<br> 2）promise.protiotype.then方法<br> 3）promise.prototype.catch方法</p> 
</blockquote> 
<h3><a id="27asyncawait_841"></a>27、async、await</h3> 
<blockquote> 
 <p>async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。是Generator函数的语法糖，并对Generator函数进行了改进。<br><br> 改进：</p> 
 <ul><li>内置执行器，无需手动执行 next() 方法。</li><li>更好的语义</li><li>更广的适用性：co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</li><li>返回值是 Promise，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用。</li><li>async 隐式返回 Promise 作为结果的函数，那么可以简单理解为，await后面的函数执行完毕时，await会产生一个微任务(Promise.then是微任务)。</li></ul></blockquote> 
<h2><a id="VUE_854"></a>四、VUE</h2> 
<h3><a id="1vue_856"></a>1.vue的双向绑定原理</h3> 
<blockquote> 
 <p>答：通过数据劫持结合订阅者发布模式，通过Object.defineProperty()，为各个属性定义get、set方法，在数据发生改变时，给订阅者发布消息，触发相应的事件回调</p> 
</blockquote> 
<blockquote> 
 <p>每一个组件实例都有相应的watch程序实例，他会在组件渲染的过程中把属性记录为依赖，之后当依赖向的setter被调用时，会通知watch重新计算，从而导致它关联的组件得以更新</p> 
</blockquote> 
<blockquote> 
 <p>响应式：<br> 数据响应式：vue采用的是数据劫持结合开发者订阅模式的方式，通过Object.defineProperty()来劫持，set、get在数据变动的时候，发布给订阅者，触发响应式回调</p> 
</blockquote> 
<blockquote> 
 <p>页面响应式：媒体查询、弹性盒子、百分比布局</p> 
</blockquote> 
<h3><a id="2MVVMMVC_866"></a>2.MVVM、MVC</h3> 
<blockquote> 
 <p>答：注意：mvvm是vue的设计思想<br><br> ​ M：model，指的是后端传递的数据<br><br> ​ V：view，指的是视图，也就是所看到的的界面<br><br> ​ VM：view Model，视图模型，他是连接的view和model的桥梁，主要是处理业务逻辑对象<br><br> ​ MVC： m：模型 v：视图 c：controller控制器，处理逻辑</p> 
</blockquote> 
<h3><a id="3vue_873"></a>3.vue的优点</h3> 
<blockquote> 
 <p>答：轻量级、组件化、数据双向绑定、虚拟DOM、单页面应用（SPA：一个项目只有一个web页面应用，加载单个HTML页面，并在用户与程序发生交互时，更新该页面的局部内容，但不刷新页面）</p> 
</blockquote> 
<h3><a id="4vuedata_876"></a>4.为什么vue组件中的data是一个函数***</h3> 
<blockquote> 
 <p>组件间数据相互不被影响<br><br> 答：js中对象是一个引用数据类型，每一个组件都是一个vue的实例，组件共享data属性，只要一个实例对对象进行操作，其他的组件实例中的额数据也会发生变化。<br><br> 组件中的data写成一个函数，数据就会以函数的形式定义，这样每一个组件实例就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，各个组件实例维护各自的数据。</p> 
</blockquote> 
<h4><a id="return_881"></a>为什么使用return返回？</h4> 
<blockquote> 
 <p>不使用return会造成这个变量（数据）在项目中，变得全局可见，造成变量污染，使用return包裹，只会在当前组件中可用，不会影响到其他组件</p> 
</blockquote> 
<h3><a id="5VUE_884"></a>5.VUE全家桶</h3> 
<blockquote> 
 <p>vue全家桶包括：vue-router、vuex、vue-resouerce，再加上vue-cil和sass样式和组件库，就是一个完整测vue项目的核心构成<br><br> 概括起来就是项目构建工具+路由+状态管理+http请求工具+样式管理/组件库</p> 
</blockquote> 
<h3><a id="6vforkey_888"></a>6.v-for中key的作用</h3> 
<blockquote> 
 <p>答：key代表的是唯一、在项目中如果使用for不加key会报警告，渲染时会出现错误，key的作用是为了更高效的更新虚拟dom，其目的就是为了让vue可以区分</p> 
</blockquote> 
<h3><a id="7vue2_891"></a>7.vue2的缺点</h3> 
<blockquote> 
 <p>答：vue2是通过object.defineProperty()方法来进行数据的劫持，对象新增或者直接通过下标修改数组，界面不会自动更新<br><br> 解决方法：$set(要操作的数组或者对象，下标或键值，要添加的内容)</p> 
</blockquote> 
<h3><a id="8domdom_895"></a>8.什么是虚拟dom，为什么要使用虚拟dom</h3> 
<blockquote> 
 <p>答：虚拟dom本质是一个js对象，用于描述视图界面结构，在vue中每个组件都有一个render函数，每一个函数都会返回一个虚拟dom数，这也意味着每一个组件都对应着一个虚拟dom树</p> 
</blockquote> 
<blockquote> 
 <p>真实的dom操作会带来大量的性能损耗，当操作节点过多时，会极大的导致渲染速度变慢，虚拟dom在数据发生改变时，新的dom树会和老的对比，然后vue中会帮我们找出最小的更新量，更新必要的虚拟dom，最后通过虚拟dom来修改真实dom</p> 
</blockquote> 
<blockquote> 
 <p>diff算法：<br><br> ​ 比较新旧虚拟dom，如果节点类型相同，则比较数据，修改数据；如果节点不同，直接插入新的节点，如果给每一个节点都设置了唯一的key，就可以准确找到需要改变的内容，否则就会出现修改一个地方导致其他地方都改变的情况。</p> 
</blockquote> 
<h3><a id="9vforvif_903"></a>9.v-for和v-if能否一起使用</h3> 
<blockquote> 
 <p>答：尽可能的v-if和v-show不要同时使用，v-for是渲染数组或者对象的，v-for的优先级高，导致每循环一次就回去v-if一次，因为v-if是通过创建和销毁来完成显示隐藏的，所以会造成不停的销毁和创建 ，造成页面的卡顿</p> 
</blockquote> 
<blockquote> 
 <p>解决方法：在v-for的外层或者内层包裹一个元素来使用v-if</p> 
</blockquote> 
<h3><a id="10computedwatch_908"></a>10.computed和watch的区别</h3> 
<blockquote> 
 <p>答：<br> computed：计算属性，并且有缓存，只有她所依赖的属性值发生变化computed才会重新计算，并且支持同步<br><br> watch：监听器，不支持缓存（可以在data中直接使用），监听的数据发生变化才会触发，watch支持异步，监听的函数可以接收两个参数，一个是最新的值，另一个是改变之前的值<br><br> 计算属性computed :<br> 支持缓存，只有依赖数据发生改变，才会重新进行计算<br> 不支持异步，当computed内有异步操作时无效，无法监听数据的变化<br><br> 侦听属性watch：<br> 1.不支持缓存，数据变，直接会触发相应的操作；<br> 2.watch支持异步；<br> 3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</p> 
</blockquote> 
<blockquote> 
 <p>2、使用场景<br><br> computed<br><br> 　　　　当一个属性受多个属性影响的时候就需要用到computed<br> 　　　　最典型的例子： <mark>购物车商品结算</mark>的时候<br> watch<br> 　　　　当一条数据影响多条数据的时候就需要用watch，<mark>搜索数据</mark></p> 
</blockquote> 
<h4><a id="watch_927"></a>watch都有哪些属性</h4> 
<blockquote> 
 <p>1）当监听一个基本数据类型时，直接使用<br><br> 2）当监听一个引用数据类型时，执行回调且回调函数名字（handler）不可更改（or默认？）<br><br> 开启深度监听：deep：true<br><br> 开始初始执行handler函数：immediate：true</p> 
</blockquote> 
<h3><a id="11vifvshow_933"></a>11.v-if和v-show的区别</h3> 
<blockquote> 
 <p>v-if：是真正的条件渲染，同时他也是惰性的，如果在初始渲染时条件为假，则什么也不做，直到第一次变为真时，才会开始渲染，条件切换过程会发生销毁和重建<br><br> 具有更高的切换开销，如果在运行是条件很少改变，使用v-if比较好<br><br> v-show：不管初始条件是什么，元素总是会被选二胺，并且知识简单的基于css（display：none/block）进行切换<br> 具有更高的初始开销，如果切换非常频繁，则使用v-show比较好</p> 
</blockquote> 
<h3><a id="12vue_939"></a>12.vue的生命周期</h3> 
<blockquote> 
 <p>答：<br> 概念：vue实例从创建到销毁的过程就是生命周期，也就是从开始创建，初始化数据，编译模板，挂载dom-&gt;渲染，更新-&gt;渲染，卸载等一系列过程<br><br> beforeCreate()：vue实例创建之前调用<br><br> created()：vue实例创建完成<br><br> beforeMount()：视图编译之前<br><br> mounted()：视图编译完成，vuedom加载之后<br><br> beforeUpdate()：数据改变之前<br><br> updated()：数据改变之后<br><br> beforeDestory()：vue销毁之前<br><br> destory()：vue销毁之后<br></p> 
</blockquote> 
<blockquote> 
 <p>第一次页面加载触发的-生命周期<br><br> beforeCreate()：vue实例创建之前调用<br><br> created()：vue实例创建完成<br><br> beforeMount()：视图编译之前<br><br> mounted()：视图编译完成，vuedom加载之后<br></p> 
</blockquote> 
<h3><a id="13vue_957"></a>13.vue的指令</h3> 
<blockquote> 
 <p>v-model：主要用于表单类的双向绑定，本质是一个语法糖，可以理解为一个快捷方式，是通过v-bind、v-on来实现的<br> 主要有三个修饰符：<br> ​ .number 将输入的字符转为有效的数字，不加则是默认字符串类型<br> ​ .lazy 取代input，监听change事件，当发生改变的时候才会触发<br> ​ .trim 过滤首尾空格<br><br> v-for：列表循环遍历、数组、对象、字符串、数字均可以<br><br> v-if：用来确定标签是否渲染<br><br> v-show：根据表达式的真假值，切换元素的display：block/none，当条件变化时该指令触发过渡效果<br><br> v-text：更新元素的textCount，如果需要更新部分textCount，则需要使用插值{<!-- -->{Mustache}}<br><br> v-on：绑定事件监听器，事件类型由参数指定，表达方式可以是一个方法的名字或者是一个内联语句，如果没有修饰符也可以省略 简写形式@<br><br> v-bind：主要是用来动态绑定属性，简写为：<br><br> v-slot：提供具名插槽或者需要接收prop的插槽，缩写为#<br><br> v-once：值渲染元素和组件一次，随后的重新渲染，元素/组件及其所有的子节点被视为静态内容并跳过，这可以用于优化更新性能<br><br> 14.常见的修饰符及其作用<br> .stop：等同于js中event.stopPropagation(),防止事件冒泡<br> .prevent ：等同于js中event.preventDefault()，阻止默认行为<br> .capture：当元素发生冒泡时，先触发带有修饰符的元素，若有多个修饰符，则由内而外触发。如 div1中嵌套div2中嵌套div3.capture中嵌套div4，那么执行顺序为：div3=》div4=》div2=》div1<br> .slef：只触发自己范围内的事件，不包含子元素<br> .once：只触发一次</p> 
</blockquote> 
<h3><a id="15vue_978"></a>15.vue组件如何进行传值的？</h3> 
<blockquote> 
 <p>答：1.父组件向子组件传递数据<br> ​ 父组件内设置要传的数据，在父组件中引用的子组件上绑定一个自定义属性并把数据绑定在自定义属性上，在子组件添加props接收即可<br> ​ 2.子组件向父组件传递数据<br><br> ​ 子组件通过vue实例方法$ emit进行触发并且可以携带参数，父组件监听使用@（v-on）绑定的事件进行监听，然后方法处理<br><br> ​ 3.兄弟组件之间传递数据<br><br> ​ 3.1 引入第三方 new vue 定义为 eventBus<br><br> ​ 3.2）在组件中 created 中订阅方法 eventBus.$ on(“自定义事件名”,methods 中的方法名)<br><br> ​ 3.3) 在另一个兄弟组件中的 methods 中写函数，在函数中发布 eventBus 订阅的方法<br><br> ​ eventBus.$emit("自定义事件名”)<br><br> ​ 3.4) 在组件的 template 中绑定事件(比如 click)<br><br> ​ 4.祖孙之间的传值<br><br> ​ provide 定义的对象会加载到子组件或者孙子组件中<br><br> ​ inject 接收祖先组件中provide函数return出的内容<br><br> ​ 5.可以通过vuex传值<br><br> ​ 6.可以使用本地存储进行传值（cookie、localstorge、sessionStorage）<br></p> 
</blockquote> 
<h3><a id="16name_995"></a>16.组件中写name会有什么作用？</h3> 
<blockquote> 
 <p>项目使用keep-alive时，可搭配组件name进行缓存过滤<br> DOM做递归组件时需要调用自身的name<br> vue-dectools 调试工具里显示的组件名称是由vue中组件name决定的</p> 
</blockquote> 
<h3><a id="17_1000"></a>17.父子组件嵌套时生命周期哦钩子函数的执行顺序</h3> 
<blockquote> 
 <p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：<br><br> 加载渲染过程 :<br> 父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted<br> 子组件更新过程 :<br> 父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated<br> 父组件更新过程 :<br> 父 beforeUpdate -&gt; 父 updated<br> 销毁过程 :<br> 父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p> 
</blockquote> 
<h3><a id="18vuex_1010"></a>18、vuex</h3> 
<blockquote> 
 <p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。<br><br> （1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br> （2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。<br> 主要包括以下几个模块：<br></p> 
 <ul><li>State =&gt; 基本数据，定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter =&gt; 从基本数据派生的数据，允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation =&gt; 是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action =&gt; 像一个装饰器，包裹mutations，使之可以异步。用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li><li>Module =&gt; 模块化Vuex，允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul></blockquote> 
<h3><a id="19keepalive_1020"></a>19、谈谈你对keep-alive的理解</h3> 
<blockquote> 
 <p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p> 
 <ul><li>一般结合路由和动态组件一起使用，用于缓存组件；</li><li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li><li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li></ul></blockquote> 
<h3><a id="20vuerouter_1025"></a>20、vue-router路由模式有几种？</h3> 
<blockquote> 
 <p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p> 
</blockquote> 
<pre><code class="prism language-html">switch (mode) {
  case 'history':
    this.history = new HTML5History(this, options.base)
    break
  case 'hash':
    this.history = new HashHistory(this, options.base, this.fallback)
    break
  case 'abstract':
    this.history = new AbstractHistory(this, options.base)
    break
  default:
    if (process.env.NODE_ENV !== 'production') {
      assert(false, `invalid mode: ${mode}`)
    }
}
</code></pre> 
<blockquote> 
 <p>其中，3 种路由模式的说明如下：</p> 
 <ul><li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li><li>history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li><li>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li></ul></blockquote> 
<h3><a id="21_vuerouter__hash__history__1049"></a>21、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h3> 
<blockquote> 
 <p>（1）hash 模式的实现原理<br> 早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：<br> https://www.word.com#search<br> hash 路由模式的实现主要是基于下面几个特性:</p> 
 <ul><li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li><li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li><li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li><li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li><li> （2）history 模式的实现原理 
 <br>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。 **唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：** window.history.pushState(null, null, path); window.history.replaceState(null, null, path); 
 <br> history 路由模式的实现主要基于存在下面几个特性： 
 </li><li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li><li>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li><li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li></ul></blockquote> 
<h3><a id="22_nextTick__1066"></a>22、谈一谈你对 nextTick 的理解？</h3> 
<blockquote> 
 <p>当你修改了data的值然后马上获取这个dom元素的值，<br> 是不能获取到更新后的值，你需要使用$nextTick这个回调，<br> 让修改后的data值渲染更新到dom元素之后在获取，才能成功。</p> 
</blockquote> 
<h3><a id="23nextTick_1071"></a>23、$nextTick的使用</h3> 
<blockquote> 
 <p>在data()中的修改后，页面中无法获取data修改后的数据，<br> 使用$nextTick时，当data中的数据修改后，可以实时的渲染页面</p> 
</blockquote> 
<h3><a id="24_vuecli__1074"></a>24、请说出 vue-cli 工程中每个文件夹和文件的用处?</h3> 
<blockquote> 
 <p>build 文件夹是保存一些 webpack 的初始化配置。<br> config 文件夹保存一些项目初始化的配置<br> node_modules 是 npm 加载的项目依赖的模块<br> src 目录是我们要开发的目录:<br> assets 用来放置图片<br> components 用来放组件文件<br> app.vue 是项目入口文件<br> main.js 项目的核心文件</p> 
</blockquote> 
<h3><a id="25Vuex__1085"></a>25、Vuex 页面刷新数据丢失怎么解决？</h3> 
<blockquote> 
 <p>需要做 vuex 数据持久化，一般使用本地储存的方案来保存数据，<br> 可以自己设计存储方案，也可以使用第三方插件。<br> 推荐使用 vuex-persist插件，<br> 它是为 Vuex 持久化储存而生的一个插件。不需要你手动存取 storage，<br> 而是直接将状态保存至 cookie 或者 localStorage中。</p> 
</blockquote> 
<h3><a id="26Vuex__1092"></a>26、Vuex 为什么要分模块并且加命名空间？</h3> 
<blockquote> 
 <p>模块： 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。<br> 当应用变得非常复杂时，store 对象就有可能会变得相当臃肿。<br> 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。<br> 每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。</p> 
</blockquote> 
<blockquote> 
 <p>命名空间： 默认情况下，模块内部的 action、mutation、getter<br> 是注册在全局命名空间的 — 这样使得多个模块能够对同一 mutation 或 action 做出响应。<br> 如果希望你的模块具有更高的封装度和复用性，<br> 你可以通过添加 namespaced:true 的方式使其成为带命名的模块。<br> 当模块被注册后，他所有 getter、action、及 mutation 都会自动根据模块注册的路径调整命名。</p> 
</blockquote> 
<h3><a id="27vue__1103"></a>27、vue 中使用了哪些设计模式？</h3> 
<blockquote> 
 <p>1、工厂模式 - 传入参数即可创建实例<br> 虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode。<br> 2、单例模式 - 整个程序有且仅有一个实例<br> vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉。<br> 3、发布-订阅模式。（vue 事件机制）<br> 4、观察者模式。（响应式数据原理）<br> 5、装饰器模式（@装饰器的用法）<br> 6、策略模式，策略模式指对象有某个行为，但是在不同的场景中，<br> 该行为有不同的实现方案 - 比如选项的合并策略。</p> 
</blockquote> 
<h3><a id="28_Vue__1114"></a>28、你都做过哪些 Vue 的性能优化？</h3> 
<blockquote> 
 <p>这里只列举针对 Vue 的性能优化，整个项目的性能优化是一个大工程。<br> 对象层级不要过深，否则性能就会差。<br> 不需要响应式的数据不要放在 data 中（可以使用 Object.freeze() 冻结数据）<br> v-if 和 v-show 区分使用场景<br> computed 和 watch 区分场景使用<br> v-for 遍历必须加 key，key最好是id值，且避免同时使用 v-if<br> 大数据列表和表格性能优化 - 虚拟列表 / 虚拟表格<br> 防止内部泄露，组件销毁后把全局变量和时间销毁<br> 图片懒加载<br> 路由懒加载<br> 异步路由<br> 第三方插件的按需加载<br> 适当采用 keep-alive 缓存组件<br> 防抖、节流的运用<br> 服务端渲染 SSR or 预渲染</p> 
</blockquote> 
<h2><a id="_1131"></a>五、其他内容</h2> 
<h3><a id="1_1132"></a>1、性能优化的几个方面?</h3> 
<blockquote> 
 <p>资源压缩合并,减少HTTP请求<br> 非核心代码异步加载<br> 利用浏览器缓存<br> 使用CDN<br> 预解析DNS</p> 
</blockquote> 
<h3><a id="2_1138"></a>2、异步加载?</h3> 
<blockquote> 
 <p>动态脚本加载<br> defer<br> async</p> 
</blockquote> 
<h3><a id="3_1142"></a>3、加载方式</h3> 
<blockquote> 
 <p>defer是在html解析完毕才执行,如果有多个则按加载顺序执行<br> async是加载完毕后立即执行,如果是多个,执行顺序与加载顺序无关</p> 
</blockquote> 
<h3><a id="4_1145"></a>4、预加载</h3> 
<blockquote> 
 <p>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，<br> 但是希望尽早获取，这时候就可以使用预加载。<br> 预加载其实是声明式的 fetch ，强制浏览器请求资源，<br> 并且不会阻塞 onload 事件，可以使用以下代码开启预加载<br> link rel=“preload” href=“http://example.com”<br> 预加载可以一定程度上降低首屏的加载时间，<br> 因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</p> 
</blockquote> 
<h3><a id="5DNS_1153"></a>5、DNS预解析</h3> 
<pre><code class="prism language-html">DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>x-dns-prefetch-control<span class="token punctuation">'</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>on<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dns-prefetch<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>//yuchengkai.cn<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>

在https协议中默认a标签不会开启预解析,因此需要手动设置meta
</code></pre> 
<h3><a id="6_1162"></a>6、懒执行</h3> 
<blockquote> 
 <p>懒执行就是将某些逻辑延迟到使用时再计算。<br> 该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，<br> 就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。</p> 
</blockquote> 
<h3><a id="7_1166"></a>7、懒加载</h3> 
<pre><code class="prism language-html">懒加载就是将不关键的资源延后加载。

懒加载的原理就是只加载自定义区域（通常是可视区域，
但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，
先设置图片标签的 src 属性为一张占位图，
将真实的图片资源放入一个自定义属性中，当进入自定义区域时，
就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。

懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6b05aaa68b446a6a488d609dcca87ec1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux服务器查看cpu和内存</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/348629d25f603739b5c24cc9abe18d11/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">用C&#43;&#43;编写出表白成功率最高的代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>