<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;中的继承 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;中的继承" />
<meta property="og:description" content="目录
一.继承的概念及定义
继承的概念
继承的定义
继承关系和访问限定符
​编辑
继承基类成员访问方式的变化
​编辑
二.基类和派生类对象赋值转换
总结：
三.继承中的作用域
四.子类的默认成员函数
五.继承与友元
六. 继承与静态成员
七.菱形继承及菱形虚拟继承
菱形继承
二义性与数据冗余
使用虚拟继承解决菱形继承的二义性与数据冗余
八.继承的总结和反思
3. 继承和组合
一.继承的概念及定义 继承的概念 继承 (inheritance) 机制是面向对象程序设计 使代码可以复用 的最重要的手段，它允许程序员在 保 持原有类(父类，也叫做基类)特性的基础上进行扩展 ，增加功能，这样产生新的类，称派生类(子类)。继承 呈现了面向对象 程序设计的层次结构 ，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用， 继 承是类设计层次的复用。 举例理解： 现在要用C&#43;&#43;写一个学校管理系统，在里面有学生类与老师类。根据常识，这些类里均有性别，姓名，年龄等相同的属性，如果在定义类时，把这些在每一个类中都写一份不免会使代码冗余，但这些属性又是不可缺少的。这里C&#43;&#43;采用，将两个类里相同的部分（成员变量或函数）提取出来，放到一个新定义的类里（父类）.学生类与老师类通过继承获取父类里的属性。 这里我们把Person类叫做父类（基类）。
Student与Teacher类叫做子类（派生类）
继承的本质可以看成类设计层次的复用。
继承的定义 定义格式：
下面我们看到Person是父类，也称作基类。Student是子类，也称作派生类
继承关系和访问限定符 继承基类成员访问方式的变化 总结：
1. 基类 private 成员在派生类中无论以什么方式继承都是不可见的。这里的 不可见是指基类的私 有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类面 都不能去访问它 。 2. 基类 private 成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在 派生类中能访问，就定义为protected 。 可以看出保护成员限定符是因继承才出现的 。 3. 实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。基类的其他 成员在子类的访问方式 == Min( 成员在基类的访问限定符，继承方式 ) ， public &gt; protected &gt; private 。 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/4851c7fe82e2894b521697804f160665/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-23T23:32:41+08:00" />
<meta property="article:modified_time" content="2023-12-23T23:32:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;中的继承</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80.%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9A%E4%B9%89-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9A%E4%B9%89" rel="nofollow">一.继承的概念及定义</a></p> 
<p id="%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">继承的概念</a></p> 
<p id="%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">继承的定义</a></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6-toc" style="margin-left:40px;"><a href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6" rel="nofollow">继承关系和访问限定符</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:0px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">​编辑</a></p> 
<p id="%E7%BB%A7%E6%89%BF%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%98%E5%8C%96-toc" style="margin-left:40px;"><a href="#%E7%BB%A7%E6%89%BF%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%98%E5%8C%96" rel="nofollow">继承基类成员访问方式的变化</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:0px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">​编辑</a></p> 
<p id="%E4%BA%8C.%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E8%BD%AC%E6%8D%A2-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E8%BD%AC%E6%8D%A2" rel="nofollow">二.基类和派生类对象赋值转换</a></p> 
<p id="%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">总结：</a></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%89.%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F" rel="nofollow">三.继承中的作用域</a></p> 
<p id="%E5%9B%9B.%E5%AD%90%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E5%AD%90%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" rel="nofollow">四.子类的默认成员函数</a></p> 
<p id="%E4%BA%94.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8F%8B%E5%85%83-toc" style="margin-left:0px;"><a href="#%E4%BA%94.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8F%8B%E5%85%83" rel="nofollow">五.继承与友元</a></p> 
<p id="%E5%85%AD.%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98-toc" style="margin-left:0px;"><a href="#%E5%85%AD.%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98" rel="nofollow">六. 继承与静态成员</a></p> 
<p id="%E4%B8%83.%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E5%8F%8A%E8%8F%B1%E5%BD%A2%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF-toc" style="margin-left:0px;"><a href="#%E4%B8%83.%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E5%8F%8A%E8%8F%B1%E5%BD%A2%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF" rel="nofollow">七.菱形继承及菱形虚拟继承</a></p> 
<p id="%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF-toc" style="margin-left:40px;"><a href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF" rel="nofollow">菱形继承</a></p> 
<p id="%E4%BA%8C%E4%B9%89%E6%80%A7%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E4%B9%89%E6%80%A7%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99" rel="nofollow">二义性与数据冗余</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E8%A7%A3%E5%86%B3%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BA%8C%E4%B9%89%E6%80%A7%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99-toc" style="margin-left:40px;"><a href="#%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E8%A7%A3%E5%86%B3%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BA%8C%E4%B9%89%E6%80%A7%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99" rel="nofollow">使用虚拟继承解决菱形继承的二义性与数据冗余</a></p> 
<p id="%E5%85%AB.%E7%BB%A7%E6%89%BF%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E5%8F%8D%E6%80%9D-toc" style="margin-left:0px;"><a href="#%E5%85%AB.%E7%BB%A7%E6%89%BF%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E5%8F%8D%E6%80%9D" rel="nofollow">八.继承的总结和反思</a></p> 
<p id="3.%20%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88-toc" style="margin-left:40px;"><a href="#3.%20%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88" rel="nofollow">3. 继承和组合</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9A%E4%B9%89"><span style="color:#fe2c24;">一.继承的概念及定义</span></h2> 
<h3 id="%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span style="color:#ad720d;"><strong>继承的概念 </strong></span></h3> 
<div></div> 
<div> 
 <div> 
  <span style="color:#777777;"><strong>继承</strong></span> 
  <span style="color:#777777;">(inheritance)</span> 
  <span style="color:#777777;">机制是面向对象程序设计</span> 
  <span style="color:#777777;"><strong><span style="background-color:#ffd900;">使代码可以复用</span></strong></span> 
  <span style="color:#777777;">的最重要的手段，它允许程序员在</span> 
  <span style="color:#777777;"><strong><span style="background-color:#ffd900;">保 </span></strong></span> 
 </div> 
 <div> 
  <span style="color:#777777;"><strong><span style="background-color:#ffd900;">持原有类(父类，也叫做基类)特性的基础上进行扩展</span></strong></span> 
  <span style="color:#777777;">，增加功能，这样<span style="background-color:#ffd900;">产生新的类，称派生类(子类)</span>。继承</span> 
  <span style="color:#777777;"><strong>呈现了面向对象 </strong></span> 
 </div> 
 <div> 
  <span style="color:#777777;"><strong>程序设计的层次结构</strong></span> 
  <span style="color:#777777;">，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，</span> 
  <span style="color:#777777;"><strong><span style="background-color:#ffd900;">继 </span></strong></span> 
 </div> 
 <div> 
  <span style="color:#777777;"><strong><span style="background-color:#ffd900;">承是类设计层次的复用。</span></strong></span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#777777;"><strong>举例理解：</strong></span> 
 </div> 
</div> 
<div></div> 
<div>
  现在要用C++写一个学校管理系统，在里面有学生类与老师类。根据常识，这些类里均有性别，姓名，年龄等相同的属性，如果在定义类时，把这些在每一个类中都写一份不免会使代码冗余，但这些属性又是不可缺少的。这里C++采用，将两个类里相同的部分（成员变量或函数）提取出来，放到一个新定义的类里（父类）.学生类与老师类通过继承获取父类里的属性。 
</div> 
<div style="text-align:center;"> 
 <img alt="" src="https://images2.imgbox.com/55/ed/nEASUng5_o.png"> 
</div> 
<div></div> 
<blockquote> 
 <p>这里我们把Person类叫做父类（基类）。</p> 
 <p>Student与Teacher类叫做子类（派生类）</p> 
</blockquote> 
<p><span style="background-color:#ffd900;">继承的本质可以看成类设计层次的复用</span>。</p> 
<h3 id="%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9A%E4%B9%89"><span style="color:#ad720d;">继承的定义</span></h3> 
<p><span style="color:#ad720d;">定义格式：</span></p> 
<p><span style="color:#777777;">下面我们看到</span><span style="color:#777777;">Person</span><span style="color:#777777;">是父类，也称作基类。</span><span style="color:#777777;">Student</span><span style="color:#777777;">是子类，也称作派生类</span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/57/fe/ow98OowI_o.png"></p> 
<h2></h2> 
<h3 id="%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6"><span style="color:#ad720d;">继承关系和访问限定符</span></h3> 
<h2 id="%E2%80%8B%E7%BC%96%E8%BE%91" style="text-align:center;"><img alt="" src="https://images2.imgbox.com/08/30/LpqV9VTP_o.png"></h2> 
<h3 id="%E7%BB%A7%E6%89%BF%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%98%E5%8C%96"><span style="color:#ad720d;">继承基类成员访问方式的变化</span></h3> 
<h2 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8b/91/MoJHJ2Mu_o.png"></h2> 
<p><strong>总结：</strong></p> 
<blockquote> 
 <div> 
  <span style="color:#777777;">1. </span> 
  <span style="color:#777777;">基类</span> 
  <span style="color:#777777;">private</span> 
  <span style="color:#777777;">成员在派生类中无论以什么方式继承都是不可见的。这里的</span> 
  <span style="color:#777777;"><strong>不可见是指基类的私 </strong></span> 
  <span style="color:#777777;"><strong>有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类面 </strong></span> 
 </div> 
 <div> 
  <span style="color:#777777;"><strong>都不能去访问它</strong></span> 
  <span style="color:#777777;">。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#777777;">2. </span> 
  <span style="color:#777777;">基类</span> 
  <span style="color:#777777;">private</span> 
  <span style="color:#777777;">成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在 派生类中能访问，就定义为protected</span> 
  <span style="color:#777777;">。</span> 
  <span style="color:#777777;"><strong>可以看出保护成员限定符是因继承才出现的</strong></span> 
  <span style="color:#777777;">。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#777777;">3. </span> 
  <span style="color:#777777;">实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。<span style="background-color:#ffd900;">基类的其他 成员在子类的访问方式 == Min(</span></span> 
  <span style="color:#777777;"><span style="background-color:#ffd900;">成员在基类的访问限定符，继承方式</span></span> 
  <span style="color:#777777;"><span style="background-color:#ffd900;">)</span></span> 
  <span style="color:#777777;"><span style="background-color:#ffd900;">，</span></span> 
  <span style="color:#777777;"><span style="background-color:#ffd900;">public &gt; protected </span></span> 
 </div> 
 <div> 
  <span style="color:#777777;"><span style="background-color:#ffd900;">&gt; private</span></span> 
  <span style="color:#777777;"><span style="background-color:#ffd900;">。 </span></span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#777777;">4. </span> 
  <span style="color:#777777;">使用关键字</span> 
  <span style="color:#777777;"><span style="background-color:#ffd900;">class</span></span> 
  <span style="color:#777777;"><span style="background-color:#ffd900;">时默认的继承方式是</span></span> 
  <span style="color:#777777;"><span style="background-color:#ffd900;">private</span></span> 
  <span style="color:#777777;">，使用</span> 
  <span style="color:#777777;"><span style="background-color:#ffd900;">struct</span></span> 
  <span style="color:#777777;"><span style="background-color:#ffd900;">时默认的继承方式是</span></span> 
  <span style="color:#777777;"><span style="background-color:#ffd900;">public</span></span> 
  <span style="color:#777777;">，</span> 
  <span style="color:#777777;"><strong>不过 </strong></span> 
 </div> 
 <div> 
  <span style="color:#777777;"><strong>最好显示的写出继承方式</strong></span> 
  <span style="color:#777777;">。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#777777;">5. </span> 
  <span style="color:#777777;"><strong>在实际运用中一般使用都是</strong></span> 
  <span style="color:#777777;"><strong>public</strong></span> 
  <span style="color:#777777;"><strong>继承，几乎很少使用</strong></span> 
  <span style="color:#777777;"><strong>protetced/private</strong></span> 
  <span style="color:#777777;"><strong>继承</strong></span> 
  <span style="color:#777777;">，也不提倡 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">使用</span> 
  <span style="color:#777777;">protetced/private</span> 
  <span style="color:#777777;">继承，因为</span> 
  <span style="color:#777777;">protetced/private</span> 
  <span style="color:#777777;">继承下来的成员都只能在派生类的类里 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">面使用，实际中扩展维护性不强</span> 
 </div> 
</blockquote> 
<p>注：同时在这里我们也可以看出protected与private的区别（总结的第二点）。同时，在派生类里虽然不能使用基类被private修饰的变量与函数，但是我们可以通过基类的public函数调用出来。</p> 
<p>私有(private)与不可见的区别：</p> 
<blockquote> 
 <p>   私有：在类里面可以使用，类外面不能直接使用。</p> 
 <p>不可见：在类里类外都不可直接使用。</p> 
</blockquote> 
<p>代码演示：</p> 
<pre><code class="language-cpp">class person
{
public:
	void Print()
	{
		cout &lt;&lt; _name &lt;&lt; endl;
		cout &lt;&lt; _age;
	}
protected: 
	string _name="wxh";
private:
	int _age=10;
};

class student:public person
{
protected:
	int _stunum=1;
public:
};



int main()
{
	student s;
	s.Print();
	return 0;
}</code></pre> 
<h2 id="%E4%BA%8C.%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E8%BD%AC%E6%8D%A2" style="background-color:transparent;"><span style="color:#fe2c24;">二.基类和派生类对象赋值转换</span></h2> 
<div> 
 <span style="color:#777777;"><strong>派生类对象 </strong></span> 
 <span style="color:#777777;">可以赋值给 </span> 
 <span style="color:#777777;"><strong>基类的对象</strong></span> 
 <span style="color:#777777;"><strong> / </strong></span> 
 <span style="color:#777777;"><strong>基类的指针</strong></span> 
 <span style="color:#777777;"><strong> / </strong></span> 
 <span style="color:#777777;"><strong>基类的引用</strong></span> 
 <span style="color:#777777;">。这里有个形象的说法叫切片 </span> 
</div> 
<div> 
 <span style="color:#777777;">或者切割。寓意把派生类中父类那部分切来赋值过去。 </span> 
</div> 
<div> 
 <span style="color:#777777;">基类对象不能赋值给派生类对象。 </span> 
</div> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/48/fe/stPm3baq_o.png"></p> 
<p>代码演示：</p> 
<pre><code class="language-cpp">class Person
{
protected :
 string _name; // 姓名
    string _sex;  // 性别
    int _age; // 年龄
};
class Student : public Person
{
public :
 int _No ; // 学号
};
void Test ()
{
 Student sobj ;
 // 1.子类对象可以赋值给父类对象/指针/引用
 Person pobj = sobj ;
 Person* pp = &amp;sobj;
 Person&amp; rp = sobj;
    
 //2.基类对象不能赋值给派生类对象
    sobj = pobj;
    
    // 3.基类的指针可以通过强制类型转换赋值给派生类的指针
    pp = &amp;sobj
    Student* ps1 = (Student*)pp; // 这种情况转换时可以的。
    ps1-&gt;_No = 10;
    
    pp = &amp;pobj;
 Student* ps2 = (Student*)pp; // 这种情况转换时虽然可以，但是会存在越界访问的问
题
    ps2-&gt;_No = 10;
}</code></pre> 
<h2 id="%E6%80%BB%E7%BB%93%EF%BC%9A">总结：</h2> 
<blockquote> 
 <p><span style="background-color:#ffd900;">子类对象可以赋值给父类对象，父类指针，父类引用</span>。这种操作叫做赋值兼容/切片/切割。可以理解为，专门将子类里的父类成员提取出来，赋值给父类对象。这不是类型转换不需要临时对象，而是天然的赋值行为(这也是为什么父类对象不用const修饰的原因)。特别：<strong><span style="background-color:#ffd900;">这种赋值仅限public继承！！！</span></strong></p> 
</blockquote> 
<blockquote> 
 <p><span style="background-color:#ffd900;">只能将子类对象赋值给父类对象</span>，不能将父类对象赋值给子类对象。</p> 
 <p>但是父类的指针与引用可以通过强制转换，赋值给子类对象，但是<span style="color:#0d0016;">会存在越界访问的问 题</span></p> 
</blockquote> 
<blockquote> 
 <div> 
  <span style="color:#777777;">基类的指针或者引用可以通过强制类型转换赋值给派生类的指针或者引用。但是必须是基类 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">的指针是指向派生类对象时才是安全的。这里基类如果是多态类型，可以使用</span> 
  <span style="color:#777777;">RTTI(Run</span> 
 </div> 
 <div> 
  <span style="color:#777777;">Time Type Information)</span> 
  <span style="color:#777777;">的</span> 
  <span style="color:#4183c4;">dynamic_cast </span> 
  <span style="color:#777777;">来进行识别后进行安全转换。（</span> 
  <span style="color:#777777;">ps</span> 
  <span style="color:#777777;">：这个我们后 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">面再讲解，这里先了解一下） </span> 
 </div> 
</blockquote> 
<h2></h2> 
<h2 id="%E4%B8%89.%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span style="color:#fe2c24;">三.继承中的作用域</span></h2> 
<p></p> 
<div> 
 <span style="color:#777777;">1. </span> 
 <span style="color:#777777;">在继承体系中</span> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">基类</span></strong></span> 
 <span style="color:#777777;"><span style="background-color:#ffd900;">和</span></span> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">派生类</span></strong></span> 
 <span style="color:#777777;"><span style="background-color:#ffd900;">都有</span></span> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">独立的作用域</span></strong></span> 
 <span style="color:#777777;"><span style="background-color:#ffd900;">。 </span></span> 
</div> 
<div> 
 <span style="color:#777777;">2. </span> 
 <span style="color:#777777;"><span style="background-color:#ffd900;">子类和父类中有同名成员</span>，</span> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏， </span></strong></span> 
</div> 
<div> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">也叫重定义</span>。</strong></span> 
 <span style="color:#777777;">（在子类成员函数中，可以</span> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">使用 基类</span></strong></span> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">::</span></strong></span> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">基类成员 显示访问</span></strong></span> 
 <span style="color:#777777;"><span style="background-color:#ffd900;">） </span></span> 
</div> 
<div> 
 <span style="color:#777777;">3. </span> 
 <span style="color:#777777;">需要注意的是如果是<span style="background-color:#ffd900;">成员函数的隐藏</span>，只需要<span style="background-color:#ffd900;">函数名相同就构成隐藏</span>。 </span> 
</div> 
<div> 
 <span style="color:#777777;">4. </span> 
 <span style="color:#777777;">注意在实际中在</span> 
 <span style="color:#777777;"><strong>继承体系里</strong></span> 
 <span style="color:#777777;">面最好</span> 
 <span style="color:#777777;"><strong>不要定义同名的成员</strong></span> 
 <span style="color:#777777;">。 </span> 
</div> 
<div></div> 
<pre><code class="language-cpp">// Student的_num和Person的_num构成隐藏关系，可以看出这样代码虽然能跑，但是非常容易混淆
class Person
{
protected :
 string _name = "小李子"; // 姓名
 int _num = 111;   // 身份证号
};
class Student : public Person
{
public:
 void Print()
 {
 cout&lt;&lt;" 姓名:"&lt;&lt;_name&lt;&lt; endl;
 cout&lt;&lt;" 身份证号:"&lt;&lt;Person::_num&lt;&lt; endl;
 cout&lt;&lt;" 学号:"&lt;&lt;_num&lt;&lt;endl;
 }
protected:
 int _num = 999; // 学号
};
void Test()
{
 Student s1;
 s1.Print();
};</code></pre> 
<p>注：<span style="background-color:#ffd900;">在父类与子类中，同名的成员函数是隐藏关系！！！</span></p> 
<pre><code class="language-cpp">// B中的fun和A中的fun不是构成重载，因为不是在同一作用域
// B中的fun和A中的fun构成隐藏，成员函数满足函数名相同就构成隐藏。
class A
{
public:
 void fun()
 {
 cout &lt;&lt; "func()" &lt;&lt; endl;
 }
};
class B : public A
{
public:
 void fun(int i)
 {
 A::fun();
 cout &lt;&lt; "func(int i)-&gt;" &lt;&lt;i&lt;&lt;endl;
 }
};
void Test()
{
 B b;
 b.fun(10);
b.A::fun();
};</code></pre> 
<h2 id="%E5%9B%9B.%E5%AD%90%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" style="background-color:transparent;"><span style="color:#fe2c24;"><strong>四.子类的默认成员函数 </strong></span></h2> 
<div> 
 <span style="color:#777777;">1. </span> 
 <span style="color:#777777;"><span style="background-color:#ffd900;">子类的构造函数必须调用父类的构造函数初始化父类的那一部分成员</span>。<span style="background-color:#ffd900;">如果父类没有默认 </span></span> 
</div> 
<div> 
 <span style="color:#777777;"><span style="background-color:#ffd900;">的构造函数，则必须在子类构造函数的初始化列表阶段显示调用。</span></span> 
</div> 
<p></p> 
<p>无默认构造函数：</p> 
<pre><code class="language-cpp">class person
{
public:
	person(const char* name)
		:_name(name)
	{
		cout &lt;&lt; "person" &lt;&lt; endl;
	}
protected:
	const char* _name;
};

class student:public person
{
public:
	student(const char* name="张三")
		:person(name)
		,_age(10)
	{
		cout &lt;&lt; "student" &lt;&lt; endl;
	}

private:
	int _age;
};</code></pre> 
<p>有默认构造：</p> 
<pre><code class="language-cpp">class person
{
public:
	person()
	{
		cout &lt;&lt; "person" &lt;&lt; endl;
	}
protected:
	const char* _name;
};

class student:public person
{
public:
	student()
		:_age(10)
	{
		cout &lt;&lt; "student" &lt;&lt; endl;
	}

private:
	int _age;
};</code></pre> 
<div> 
 <span style="color:#0d0016;"><span style="background-color:#ffd900;">2. 派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化</span></span> 
</div> 
<p></p> 
<pre><code class="language-cpp">class person
{
public:
	person(const person&amp; s)
	{
		cout &lt;&lt; "person(const person&amp;)" &lt;&lt; endl;
	}
protected:
	const char* _name;
};

class student:public person
{
public:
	student(const student&amp; s)
		:person(s)
		,_age(10)
	{
		cout &lt;&lt; "student(const student&amp;)" &lt;&lt; endl;
	}
private:
	int _age;
};</code></pre> 
<p><span style="background-color:#6eaad7;">注：在子类的拷贝构造调用父类的拷贝构造，在传参时使用了切片传入父类对象。</span></p> 
<div></div> 
<div> 
 <span style="color:#777777;"><span style="background-color:#ffd900;">3. </span></span> 
 <span style="color:#777777;"><span style="background-color:#ffd900;">子类的</span></span> 
 <span style="color:#777777;"><span style="background-color:#ffd900;">operator=</span></span> 
 <span style="color:#777777;"><span style="background-color:#ffd900;">必须要调用父类的</span></span> 
 <span style="color:#777777;"><span style="background-color:#ffd900;">operator=</span></span> 
 <span style="color:#777777;"><span style="background-color:#ffd900;">完成基类的复制。</span></span> 
</div> 
<pre><code class="language-cpp">class Person
{
public:
	Person&amp; operator=(const Person&amp; p)
	{
		cout &lt;&lt; "Person operator=(const Person&amp; p)" &lt;&lt; endl;
		if (this != &amp;p)
			_name = p._name;
		return *this;
	}
protected:
	string _name; 
};


class Student : public Person
{
public:
	Student&amp; operator=(const Student&amp; s)
	{
		if (&amp;s != this)
		{
			Person::operator=(s);
			_id = s._id;
		}
		cout &lt;&lt; "Student&amp; operator=(const Student&amp; s)" &lt;&lt; endl;

		return *this;
	}
protected:
	int _id;
};</code></pre> 
<p>注：子类与父类的operator=是隐藏关系，因此在调用是要指明类域</p> 
<p></p> 
<div> 
 <span style="color:#777777;">4. </span> 
 <span style="color:#777777;"><span style="background-color:#ffd900;">子类的析构函数</span>会在被调用完成后自动调用父类的析构函数清理父类成员。因为这样才能 </span> 
</div> 
<div> 
 <span style="color:#777777;">保证子类对象<span style="background-color:#ffd900;">先清理子类成员再清理父类成员的顺序。</span> </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#777777;">5. </span> 
 <span style="color:#777777;"><span style="background-color:#ffd900;">子类对象初始化先调用父类构造再调子类构造</span>。 </span> 
</div> 
<div> 
 <span style="color:#777777;">6. </span> 
 <span style="color:#777777;">子类对象析构清理先调用子类析构再调父类的析构。 </span> 
</div> 
<div> 
 <span style="color:#777777;">7. </span> 
 <span style="color:#777777;">因为后续一些场景析构函数需要构成重写，重写的条件之一是函数名相同</span> 
 <span style="color:#777777;">(</span> 
 <span style="color:#777777;">这个我们后面会讲 </span> 
</div> 
<div> 
 <span style="color:#777777;">解</span> 
 <span style="color:#777777;">)</span> 
 <span style="color:#777777;">。那么<span style="background-color:#ffd900;">编译器会对析构函数名进行特殊处理，处理成</span></span> 
 <span style="color:#777777;"><span style="background-color:#ffd900;">destrutor()</span></span> 
 <span style="color:#777777;">，所以子类析构函数不加 </span> 
</div> 
<div> 
 <span style="color:#777777;">virtual</span> 
 <span style="color:#777777;">的情况下，<span style="background-color:#ffd900;">子类析构函数和父类析构函数构成隐藏关系</span></span> 
</div> 
<pre><code class="language-cpp">class Person
{
public:
	~Person()
	{
		cout &lt;&lt; "~Person()" &lt;&lt; endl;
	}
protected:
	string _name; 
};

class Student : public Person
{
public:
	// 由于多态的原因，析构函数统一会被处理成destructor
	// 父子类的析构函数构成隐藏
	// 为了保证析构安全，先子后父
	// 父类析构函数不需要显示调用，子类析构函数结束时会自动调用父类析构
	// 保证先子后父
	~Student()
	{
		//Person::~Person();
		cout &lt;&lt; "~Student()" &lt;&lt; endl;
	}

protected:
	int _id;
};</code></pre> 
<p>注：子类的析构函数与父类的析构函数是隐藏的关系。</p> 
<p>总结：</p> 
<blockquote> 
 <p>子类的成员要看作两部分：1，继承父类的.2子类特有的。</p> 
 <p>在子类使用默认成员函数时，要分别处理这两部分。1调用父类的处理。2要具体根据需求去确定如何处理。（在做处理时要注意，这两部分的先后顺序）</p> 
 <p><span style="background-color:#4da8ee;">构造函数：先父后子</span></p> 
 <p><span style="background-color:#4da8ee;">析构函数：先子后父</span></p> 
</blockquote> 
<p></p> 
<h2 id="%E4%BA%94.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8F%8B%E5%85%83"><span style="color:#fe2c24;">五.继承与友元</span></h2> 
<div> 
 <span style="color:#777777;"><span style="background-color:#38d8f0;">友元关系不能继承</span></span> 
 <span style="color:#777777;">，也就是说父类友元不能访问子类私有和保护成员</span> 
</div> 
<p></p> 
<pre><code class="language-cpp">
class Person
{
public:
 friend void Display(const Person&amp; p, const Student&amp; s);
protected:
 string _name; // 姓名
};
class Student : public Person
{
protected:
 int _stuNum; // 学号
};
void Display(const Person&amp; p, const Student&amp; s)
{
 cout &lt;&lt; p._name &lt;&lt; endl;
 cout &lt;&lt; s._stuNum &lt;&lt; endl;
}
void main()
{
 Person p;
 Student s;
 Display(p, s);
}</code></pre> 
<p></p> 
<h2 id="%E5%85%AD.%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span style="color:#fe2c24;"><strong>六. 继承与静态成员</strong></span></h2> 
<div> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">父类定义了</span></strong></span> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">static</span></strong></span> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">静态成员，则整个继承体系里面只有一个这样的成员</span></strong></span> 
 <span style="color:#777777;">。无论派生出多少个子 </span> 
</div> 
<div> 
 <span style="color:#777777;">类，都只有一个</span> 
 <span style="color:#777777;">static</span> 
 <span style="color:#777777;">成员实例</span> 
 <span style="color:#777777;">。</span> 
</div> 
<pre><code class="language-cpp">class Person
{
public :
 Person () {++ _count ;}
protected :
 string _name ; // 姓名
public :
 static int _count; // 统计人的个数。
};
int Person :: _count = 0;
class Student : public Person
{
protected :
 int _stuNum ; // 学号
};
class Graduate : public Student
{
protected :
 string _seminarCourse ; // 研究科目
};
void TestPerson()
{
 Student s1 ;
 Student s2 ;
 Student s3 ;
 Graduate s4 ;
 cout &lt;&lt;" 人数 :"&lt;&lt; Person ::_count &lt;&lt; endl;
 Student ::_count = 0;
 cout &lt;&lt;" 人数 :"&lt;&lt; Person ::_count &lt;&lt; endl;
}</code></pre> 
<p>注：在子类里可以使用父类的静态成员，但是要记住<span style="background-color:#ffd900;">子类与父类使用的是同一个静态变量</span>。</p> 
<p>在使用时可以<span style="background-color:#ffd900;">父类类名::静态变量名</span>，也可以<span style="background-color:#ffd900;">子类类名::静态变量名</span></p> 
<h2 id="%E4%B8%83.%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E5%8F%8A%E8%8F%B1%E5%BD%A2%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF"><span style="color:#fe2c24;">七.菱形继承<strong>及菱形虚拟继承</strong></span></h2> 
<h3 id="%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span style="color:#ad720d;">菱形继承</span></h3> 
<div> 
 <span style="color:#777777;"><strong>单继承：一个子类只有一个直接父类时称这个继承关系为单继承</strong></span> 
</div> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5d/95/rNZ5bpNp_o.png"></p> 
<div> 
 <span style="color:#777777;"><strong>多继承：一个子类有两个或以上直接父类时称这个继承关系为多继承 </strong></span> 
</div> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a4/e3/xKXk1KrS_o.png"></p> 
<div> 
 <span style="color:#777777;"><strong>菱形继承：菱形继承是多继承的一种特殊情况。 </strong></span> 
</div> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/35/12/iTrIFYb6_o.png"></p> 
<p>代码：</p> 
<pre><code class="language-cpp">class Person
{
public :
 string _name ; // 姓名
};


class Student : public Person
{
protected :
 int _num ; //学号
};
class Teacher : public Person
{
protected :
 int _id ; // 职工编号
};


class Assistant : public Student, public Teacher
{
protected :
 string _majorCourse ; // 主修课程
};</code></pre> 
<p></p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f4/db/S4njjM2W_o.png"></p> 
<p></p> 
<div> 
 <span style="color:#777777;"><strong>菱形继承的问题：从对象成员模型构造，可以看出菱形继承有数据冗余和二义性的问题。 </strong></span> 
</div> 
<div> 
 <span style="color:#777777;"><strong>在</strong></span> 
 <span style="color:#777777;"><strong>Assistant</strong></span> 
 <span style="color:#777777;"><strong>的对象中</strong></span> 
 <span style="color:#777777;"><strong>Person</strong></span> 
 <span style="color:#777777;"><strong>成员会有两份。</strong></span> 
</div> 
<p></p> 
<h3 id="%E4%BA%8C%E4%B9%89%E6%80%A7%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99"><span style="color:#ad720d;">二义性与数据冗余</span></h3> 
<pre><code class="language-cpp">void Test ()
{
 // 这样会有二义性无法明确知道访问的是哪一个
 Assistant a ;
a._name = "peter";
// 需要显示指定访问哪个父类的成员可以解决二义性问题，但是数据冗余问题无法解决
 a.Student::_name = "xxx";
 a.Teacher::_name = "yyy";
}</code></pre> 
<p>由于Assistant类中有两个_name成员，如果直接调用赋值，无法识别你想要用那个，存在二义性，</p> 
<p>这是需要指明调用成员的类域。但是仍然无法解决数据冗余</p> 
<h3 id="%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E8%A7%A3%E5%86%B3%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BA%8C%E4%B9%89%E6%80%A7%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99"><span style="color:#ad720d;">使用虚拟继承解决菱形继承的二义性与数据冗余</span></h3> 
<p>这里我们需要知道为什么菱形继承会产生二义性与冗余：父类继承了相同的类，而多继承导致子类继承了多分相同的成员。</p> 
<p>那又该如何解决呢？</p> 
<p>这里c++中采用了增加<strong><span style="background-color:#ffd900;">关键字virtual</span></strong></p> 
<p><strong>菱形继承</strong></p> 
<pre><code class="language-cpp">class Person
{
public :
 string _name ; // 姓名
};
class Student :  public Person
{
protected :
 int _num ; //学号
};
class Teacher :  public Person
{
protected :
 int _id ; // 职工编号
};
class Assistant : public Student, public Teacher
{
protected :
 string _majorCourse ; // 主修课程
};
void Test ()
{
 Assistant a ;
 a._name = "peter";
}</code></pre> 
<p>通过调试观察d的内容：</p> 
<p><strong><span style="background-color:#ffd900;">未使用virtual：</span></strong></p> 
<p><img alt="" src="https://images2.imgbox.com/2f/98/moJnnUVB_o.png"></p> 
<p>明显看出了数据冗余。</p> 
<p><strong><span style="background-color:#ffd900;">使用virtual:</span></strong><br><img alt="" src="https://images2.imgbox.com/71/79/yAncETzA_o.png"></p> 
<div> 
 <span style="color:#777777;">下图是菱形虚拟继承的内存对象成员模型：这里可以分析出</span> 
 <span style="color:#777777;">D</span> 
 <span style="color:#777777;">对象中将</span> 
 <span style="color:#777777;">A</span> 
 <span style="color:#777777;">放到的了对象组成的最下 </span> 
</div> 
<div> 
 <span style="color:#777777;">面，这个</span> 
 <span style="color:#777777;">A</span> 
 <span style="color:#777777;">同时属于</span> 
 <span style="color:#777777;">B</span> 
 <span style="color:#777777;">和</span> 
 <span style="color:#777777;">C</span> 
 <span style="color:#777777;">，那么</span> 
 <span style="color:#777777;">B</span> 
 <span style="color:#777777;">和</span> 
 <span style="color:#777777;">C</span> 
 <span style="color:#777777;">如何去找到公共的</span> 
 <span style="color:#777777;">A</span> 
 <span style="color:#777777;">呢？</span> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">这里是通过了</span></strong></span> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">B</span></strong></span> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">和</span></strong></span> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">C</span></strong></span> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">的两个指针，指 </span></strong></span> 
</div> 
<div> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">向的一张表。这两个指针叫虚基表指针，这两个表叫虚基表。虚基表中存的偏移量。通过偏移量 </span></strong></span> 
</div> 
<div> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">可以找到下面的</span></strong></span> 
 <span style="color:#777777;"><strong><span style="background-color:#ffd900;">A</span></strong></span> 
</div> 
<p></p> 
<h2 id="%E5%85%AB.%E7%BB%A7%E6%89%BF%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E5%8F%8D%E6%80%9D"><span style="color:#fe2c24;"><strong>八.继承的总结和反思 </strong></span></h2> 
<div> 
 <span style="color:#777777;">1. </span> 
 <span style="color:#777777;"><strong>很多人说</strong></span> 
 <span style="color:#777777;"><strong>C++</strong></span> 
 <span style="color:#777777;"><strong>语法复杂，其实多继承就是一个体现。有了多继承</strong></span> 
 <span style="color:#777777;">，就存在菱形继承，有了菱 </span> 
</div> 
<div> 
 <span style="color:#777777;">形继承就有菱形虚拟继承，底层实现就很复杂。所以一般不建议设计出多继承，一定不要设 </span> 
</div> 
<div> 
 <span style="color:#777777;">计出菱形继承。否则在复杂度及性能上都有问题。 </span> 
</div> 
<div> 
 <span style="color:#777777;">2. </span> 
 <span style="color:#777777;">多继承可以认为是</span> 
 <span style="color:#777777;">C++的缺陷之一，很多后来的</span> 
 <span style="color:#777777;">语言都没有多继承，如</span> 
 <span style="color:#777777;">Java</span> 
 <span style="color:#777777;">。</span> 
</div> 
<p></p> 
<h3 id="3.%20%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88"><span style="color:#ad720d;">3. <strong>继承和组合 </strong></span></h3> 
<div> 
 <span style="color:#777777;">public</span> 
 <span style="color:#777777;">继承是一种</span> 
 <span style="color:#777777;"><strong>is-a</strong></span> 
 <span style="color:#777777;">的关系。也就是说每个派生类对象都是一个基类对象。 </span> 
</div> 
<div> 
 <span style="color:#777777;">组合是一种</span> 
 <span style="color:#777777;"><strong>has-a</strong></span> 
 <span style="color:#777777;">的关系。假设</span> 
 <span style="color:#777777;">B</span> 
 <span style="color:#777777;">组合了</span> 
 <span style="color:#777777;">A</span> 
 <span style="color:#777777;">，每个</span> 
 <span style="color:#777777;">B</span> 
 <span style="color:#777777;">对象中都有一个</span> 
 <span style="color:#777777;">A</span> 
 <span style="color:#777777;">对象。</span> 
</div> 
<p></p> 
<div> 
 <span style="color:#4183c4;">优先使用对象组合，而不是类继承 </span> 
 <span style="color:#777777;">。</span> 
</div> 
<p></p> 
<div> 
 <span style="color:#777777;">继承允许你根据基类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称 </span> 
</div> 
<div> 
 <span style="color:#777777;">为白箱复用</span> 
 <span style="color:#777777;">(white-box reuse)</span> 
 <span style="color:#777777;">。术语</span> 
 <span style="color:#777777;">“</span> 
 <span style="color:#777777;">白箱</span> 
 <span style="color:#777777;">”</span> 
 <span style="color:#777777;">是相对可视性而言：在继承方式中，基类的 </span> 
</div> 
<div> 
 <span style="color:#777777;">内部细节对子类可见 。继承一定程度破坏了基类的封装，基类的改变，对派生类有很 </span> 
</div> 
<div> 
 <span style="color:#777777;">大的影响。派生类和基类间的依赖关系很强，耦合度高。 </span> 
</div> 
<div></div> 
<div></div> 
<div> 
 <span style="color:#777777;">对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象 </span> 
</div> 
<div> 
 <span style="color:#777777;">来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复 </span> 
</div> 
<div> 
 <span style="color:#777777;">用</span> 
 <span style="color:#777777;">(black-box reuse)</span> 
 <span style="color:#777777;">，因为对象的内部细节是不可见的。对象只以</span> 
 <span style="color:#777777;">“</span> 
 <span style="color:#777777;">黑箱</span> 
 <span style="color:#777777;">”</span> 
 <span style="color:#777777;">的形式出现。 </span> 
</div> 
<div> 
 <span style="color:#777777;">组合类之间没有很强的依赖关系，耦合度低。优先使用对象组合有助于你保持每个类被 </span> 
</div> 
<div> 
 <span style="color:#777777;">封装。 </span> 
</div> 
<div></div> 
<div></div> 
<div> 
 <span style="color:#777777;">实际尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也有用武之地的，有 </span> 
</div> 
<div> 
 <span style="color:#777777;">些关系就适合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用 </span> 
</div> 
<div> 
 <span style="color:#777777;">继承，可以用组合，就用组合。</span> 
</div> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a3857f90dc456e3fd75840d4e30f8082/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">分布式搜索引擎03</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4ff30fb25562a24e82da2daded52d34d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">案例142:基于微信小程序的点餐系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>