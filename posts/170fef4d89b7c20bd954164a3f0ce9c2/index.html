<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>iOS日常问题记录 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="iOS日常问题记录" />
<meta property="og:description" content="1、iOS8集成极光推送造成应用闪退问题，报错如下,把UserNotifications.framework的status状态改为Optional可选即可。
dyld: Library not loaded: /System/Library/Frameworks/UserNotifications.framework/UserNotifications Referenced from: /var/containers/Bundle/Application/********-****-****-****-************/****.app/**** Reason: image not found 2、iOS导航条隐藏后无法支持手势侧滑
&lt;UIGestureRecognizerDelegate,UINavigationControllerDelegate&gt; - (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; [self.navigationController setNavigationBarHidden:YES animated:NO]; self.navigationController.interactivePopGestureRecognizer.delegate = self; self.navigationController.interactivePopGestureRecognizer.enabled = YES; self.navigationController.delegate=self; } 这样解决后发现导航根视图侧滑后页面跳转错乱，解决办法是在跟视图关闭手势
- (void)navigationController:(UINavigationController *)navigationController didShowViewController:(UIViewController *)viewController animated:(BOOL)animated { if (viewController == navigationController.viewControllers[0]) { navigationController.interactivePopGestureRecognizer.enabled = NO; }else { navigationController.interactivePopGestureRecognizer.enabled = YES; } } 导航侧滑手势监听，包含WKWebView设置setAllowsBackForwardNavigationGestures手势返回事件监听
-(BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer{ return YES; } 3、AFNetwork错误解析
NSDictionary * errorInfo = error.userInfo; if ([[errorInfo allKeys] containsObject: @&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/170fef4d89b7c20bd954164a3f0ce9c2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-26T15:24:35+08:00" />
<meta property="article:modified_time" content="2023-09-26T15:24:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">iOS日常问题记录</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>1、iOS8集成极光推送造成应用闪退问题，报错如下,把UserNotifications.framework的status状态改为Optional可选即可。</p> 
<pre><code>dyld: Library not loaded: /System/Library/Frameworks/UserNotifications.framework/UserNotifications
  Referenced from: /var/containers/Bundle/Application/********-****-****-****-************/****.app/****
  Reason: image not found
</code></pre> 
<p>2、iOS导航条隐藏后无法支持手势侧滑</p> 
<pre><code>&lt;UIGestureRecognizerDelegate,UINavigationControllerDelegate&gt;
</code></pre> 
<pre><code>- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    [self.navigationController setNavigationBarHidden:YES animated:NO];
    self.navigationController.interactivePopGestureRecognizer.delegate = self;
    self.navigationController.interactivePopGestureRecognizer.enabled = YES;
    self.navigationController.delegate=self;
   
}
</code></pre> 
<p>这样解决后发现导航根视图侧滑后页面跳转错乱，解决办法是在跟视图关闭手势</p> 
<pre><code>- (void)navigationController:(UINavigationController *)navigationController
       didShowViewController:(UIViewController *)viewController
                    animated:(BOOL)animated
{
    if (viewController == navigationController.viewControllers[0])
    {
        navigationController.interactivePopGestureRecognizer.enabled = NO;
    }else {
        navigationController.interactivePopGestureRecognizer.enabled = YES;
    }
}
</code></pre> 
<p>导航侧滑手势监听，包含WKWebView设置setAllowsBackForwardNavigationGestures手势返回事件监听</p> 
<pre><code>-(BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer{
   
    return YES;
}
</code></pre> 
<p>3、AFNetwork错误解析</p> 
<pre><code>NSDictionary * errorInfo = error.userInfo;
if ([[errorInfo allKeys] containsObject: @"com.alamofire.serialization.response.error.data"]){
   NSData * errorData = errorInfo[@"com.alamofire.serialization.response.error.data"];
   NSDictionary * errorDict =  [NSJSONSerialization JSONObjectWithData: errorData options:NSJSONReadingAllowFragments error:nil];
    [SVProgressHUD showInfoWithStatus:[errorDict objectForKey:@"ExceptionMessage"]];
}
</code></pre> 
<p>请求头传值token</p> 
<pre><code>AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
manager.requestSerializer = [AFJSONRequestSerializer serializer];//请求
[manager.requestSerializer setValue:token forHTTPHeaderField:@"Authorization"];
</code></pre> 
<p>请求返回为非json时</p> 
<pre><code>manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"application/json", @"text/html",@"image/png",nil];
manager.responseSerializer = [AFHTTPResponseSerializer serializer];
</code></pre> 
<p>4、xcode更新后项目报错如下</p> 
<pre><code>Conflicting types for 'xmlParseMemory'
</code></pre> 
<p>解决方法在报错文件中引入头文件如下：</p> 
<pre><code>#include &lt;libxml/parser.h&gt;
#include &lt;libxml/xmlmemory.h&gt;
</code></pre> 
<p>5、iOS导航栏设置背景色, 返回按钮图片在下面另存为即可</p> 
<pre><code>- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    [self.navigationController setNavigationBarHidden:NO animated:NO];
    self.navigationController.navigationBar.barTintColor = [UIColor colorWithRed:75/255.0 green:89/255.0 blue:121/255.0 alpha:1];
    // 设置返回按钮
    UIButton *backButton = [UIButton buttonWithType:UIButtonTypeCustom];
    [backButton setImage:[UIImage imageNamed:@"bar_back"] forState:UIControlStateNormal];
    [backButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
    [backButton addTarget:self action:@selector(back) forControlEvents:UIControlEventTouchUpInside];
    
    [backButton sizeToFit];
    
    // 注意:一定要在按钮内容有尺寸的时候,设置才有效果
    backButton.contentEdgeInsets = UIEdgeInsetsMake(0, -25, 0, 0);
    
    // 设置返回按钮
    self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:backButton];

//默认返回按钮
//self.navigationController.navigationBar.tintColor =[UIColor whiteColor];
//self.navigationController.navigationBar.titleTextAttributes=[NSDictionary //dictionaryWithObject:[UIColor whiteColor] forKey:UITextAttributeTextColor];
//self.tabBarController.tabBar.selectedImageTintColor=[UIColor whiteColor];

}
</code></pre> 
<p><img src="https://images2.imgbox.com/44/22/l3tUbnwu_o.png" alt="bar_back.png"></p> 
<p>iOS15后</p> 
<pre><code>- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    
    CGRect rectStatus = [[UIApplication sharedApplication] statusBarFrame];
    UIView *statusBarView = [[UIView alloc] initWithFrame:CGRectMake(0, -rectStatus.size.height, self.view.bounds.size.width, rectStatus.size.height)];
    //设置状态栏颜色
    statusBarView.backgroundColor=[UIColor whiteColor];
    // 添加到 navigationBar 上
    [self.navigationController.navigationBar addSubview:statusBarView];
    
    self.navigationController.navigationBar.translucent = YES;
    [self.navigationController setNavigationBarHidden:NO animated:NO];
    // 导航背景色
    self.navigationController.navigationBar.backgroundColor = [UIColor whiteColor];
    //  导航返回按钮颜色
    self.navigationController.navigationBar.tintColor = [UIColor blackColor];
    // 导航字体颜色
    self.navigationController.navigationBar.titleTextAttributes=[NSDictionary dictionaryWithObject:[UIColor blackColor] forKey:UITextAttributeTextColor];

    self.title = @"人脸采集";
}

</code></pre> 
<p>6、微信支付客户端加签</p> 
<pre><code>#pragma mark ======获取当前时间戳=======

+ (NSString*)getCurrentTime {
    
    NSDate*datenow = [NSDate date];
    
    NSString*timeSp = [NSString stringWithFormat:@"%ld", (long)[datenow timeIntervalSince1970]];
    
    NSTimeZone*zone = [NSTimeZone timeZoneWithName:@"Asia/Beijing"];
    
    NSInteger interval = [zone secondsFromGMTForDate:datenow];
    
    NSDate*localeDate = [datenow dateByAddingTimeInterval:interval];
    
    NSString*timeSpp = [NSString stringWithFormat:@"%f", [localeDate timeIntervalSince1970]];
    
    return timeSpp;
    
}
</code></pre> 
<pre><code>//创建package签名
+(NSString*) createMd5Sign:(NSMutableDictionary*)dict
{
    NSMutableString *contentString  =[NSMutableString string];
    NSArray *keys = [dict allKeys];
    //按字母顺序排序
    NSArray *sortedArray = [keys sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) {
        return [obj1 compare:obj2 options:NSNumericSearch];
    }];
    //拼接字符串
    for (NSString *categoryId in sortedArray) {
        if (   ![[dict objectForKey:categoryId] isEqualToString:@""]
            &amp;&amp; ![categoryId isEqualToString:@"sign"]
            &amp;&amp; ![categoryId isEqualToString:@"key"]
            )
        {
            [contentString appendFormat:@"%@=%@&amp;", categoryId, [dict objectForKey:categoryId]];
        }
        
    }
    //添加key字段
    [contentString appendFormat:@"key=%@", @""];
    //得到MD5 sign签名
    NSString *md5Sign =[contentString MD5];
    
    return [md5Sign uppercaseString];
}
</code></pre> 
<pre><code>+(long)getRandomNumber:(int)from to:(int)to
{
    return (long)(from + (arc4random() % (to - from + 1)));
}
</code></pre> 
<pre><code>+ (NSString *)jumpToBizPay:(NSDictionary*)paramter {
    //调起微信支付
    PayReq* req             = [[PayReq alloc] init];
    //微信支付分配的商户号
    req.partnerId           = @"";
    /** 预支付订单 从服务器获取 */
    req.prepayId            = [paramter objectForKey:@"prepayID"];
    /** 随机串，防重发 */
    req.nonceStr            = [NSString stringWithFormat:@"%ld",[WXApiRequestHandler getRandomNumber:100 to:100000000]];
    /** 时间戳，防重发 */
    req.timeStamp           = [[WXApiRequestHandler getCurrentTime]intValue];
    /** 商家根据财付通文档填写的数据和签名 &lt;暂填写固定值Sign=WXPay&gt;*/
    req.package             = @"Sign=WXPay";
    /** 商家根据微信开放平台文档对数据做的签名, 可从服务器获取，也可本地生成*/
    NSMutableDictionary *dic = [[NSMutableDictionary alloc]init];
    [dic setObject:@"" forKey:@"appid"];
    [dic setObject:req.partnerId forKey:@"partnerid"];
    [dic setObject:req.prepayId forKey:@"prepayid"];
    [dic setObject:req.package forKey:@"package"];
    [dic setObject:req.nonceStr forKey:@"noncestr"];
    [dic setObject:[NSString stringWithFormat:@"%u",(unsigned int)req.timeStamp] forKey:@"timestamp"];
    req.sign                = [WXApiRequestHandler createMd5Sign:dic];
    
    [WXApi sendReq:req];

    return @"";
}
</code></pre> 
<p>7、支付宝加签</p> 
<pre><code>#define ALI_NOTIFY_URL      @""
#define ALI_APPID           @""
#define ALI_RSA2PRIVATEKEY  @""

@implementation OrderPay
//
//选中商品调用支付宝极简支付
//
- (void)toAliPay:(NSDictionary*)paramter blockcompletion:(BackDic)backResultDic{
    //重要说明
    //这里只是为了方便直接向商户展示支付宝的整个支付流程；所以Demo中加签过程直接放在客户端完成；
    //真实App里，privateKey等数据严禁放在客户端，加签过程务必要放在服务端完成；
    //防止商户私密数据泄露，造成不必要的资金损失，及面临各种安全风险；
/*============================================================================*/
    /*=======================需要填写商户app申请的===================================*/
    /*============================================================================*/
    NSString *appID = ALI_APPID;
    
    // 如下私钥，rsa2PrivateKey 或者 rsaPrivateKey 只需要填入一个
    // 如果商户两个都设置了，优先使用 rsa2PrivateKey
    // rsa2PrivateKey 可以保证商户交易在更加安全的环境下进行，建议使用 rsa2PrivateKey
    // 获取 rsa2PrivateKey，建议使用支付宝提供的公私钥生成工具生成，
    // 工具地址：https://doc.open.alipay.com/docs/doc.htm?treeId=291&amp;articleId=106097&amp;docType=1
    NSString *rsa2PrivateKey = ALI_RSA2PRIVATEKEY;
    NSString *rsaPrivateKey = @"";
    /*============================================================================*/
    /*============================================================================*/
    /*============================================================================*/
    
    //partner和seller获取失败,提示
    if ([appID length] == 0 ||
        ([rsa2PrivateKey length] == 0 &amp;&amp; [rsaPrivateKey length] == 0))
    {
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"提示"
                                                        message:@"缺少appId或者私钥。"
                                                       delegate:self
                                              cancelButtonTitle:@"确定"
                                              otherButtonTitles:nil];
        [alert show];
        return;
    }
    
    /*
     *生成订单信息及签名
     */
    //将商品信息赋予AlixPayOrder的成员变量
    Order* order = [Order new];
    
    // NOTE: app_id设置
    order.app_id = appID;
    
    // NOTE: 支付接口名称
    order.method = @"alipay.trade.app.pay";
    
    // NOTE: 参数编码格式
    order.charset = @"utf-8";
    
    // NOTE: 当前时间点
    NSDateFormatter* formatter = [NSDateFormatter new];
    [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    order.timestamp = [formatter stringFromDate:[NSDate date]];
    
    //NOTE:回调
    order.notify_url = ALI_NOTIFY_URL;
    order.passback_params = [NSString stringWithFormat:@"%@",[paramter objectForKey:@"tradeID"]];
    // NOTE: 支付版本
    order.version = @"1.0";
    
    // NOTE: sign_type 根据商户设置的私钥来决定
    order.sign_type = (rsa2PrivateKey.length &gt; 1)?@"RSA2":@"RSA";
    
    // NOTE: 商品数据
    order.biz_content = [BizContent new];
    order.biz_content.body = [paramter objectForKey:@"body"];
    order.biz_content.subject = [paramter objectForKey:@"title"];
    order.biz_content.out_trade_no = [paramter objectForKey:@"tradeID"]; //订单ID（由商家自行制定）
    order.biz_content.timeout_express = @"30m"; //超时时间设置
    order.biz_content.total_amount = [NSString stringWithFormat:@"%@",[paramter objectForKey:@"totalPrice"]]; //商品价格
    
    //将商品信息拼接成字符串
    NSString *orderInfo = [order orderInfoEncoded:NO];
    NSString *orderInfoEncoded = [order orderInfoEncoded:YES];
    NSLog(@"orderSpec = %@",orderInfo);
    
    // NOTE: 获取私钥并将商户信息签名，外部商户的加签过程请务必放在服务端，防止公私钥数据泄露；
    //       需要遵循RSA签名规范，并将签名字符串base64编码和UrlEncode
    NSString *signedString = nil;
    RSADataSigner* signer = [[RSADataSigner alloc] initWithPrivateKey:((rsa2PrivateKey.length &gt; 1)?rsa2PrivateKey:rsaPrivateKey)];
    if ((rsa2PrivateKey.length &gt; 1)) {
        signedString = [signer signString:orderInfo withRSA2:YES];
    } else {
        signedString = [signer signString:orderInfo withRSA2:NO];
    }
    
    // NOTE: 如果加签成功，则继续执行支付
    if (signedString != nil) {
        //应用注册scheme,在AliSDKDemo-Info.plist定义URL types
        NSString *appScheme = @"chinafortuneparkalidemo";
        
        // NOTE: 将签名成功字符串格式化为订单字符串,请严格按照该格式
        NSString *orderString = [NSString stringWithFormat:@"%@&amp;sign=%@",
                                 orderInfoEncoded, signedString];
        
        // NOTE: 调用支付结果开始支付
        [[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(NSDictionary *resultDic) {
            backResultDic(resultDic);
            if ([[resultDic objectForKey:@"resultStatus"] intValue] ==9000) {
                
                [SVProgressHUD showSuccessWithStatus:@"支付成功!"];
            }else{
                [SVProgressHUD showErrorWithStatus:@"支付失败!"];
            }
        }];
    }
}
</code></pre> 
<p>8、网络环境监测</p> 
<pre><code>// 2.设置网络状态改变后的处理
            [[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
                // 当网络状态改变了, 就会调用这个block
                switch (status) {
                    case AFNetworkReachabilityStatusUnknown: // 未知网络
                        NSLog(@"未知网络");
                        break;
                        
                    case AFNetworkReachabilityStatusNotReachable: // 没有网络(断网)
                        NSLog(@"没有网络(断网)");
                        break;
                        
                    case AFNetworkReachabilityStatusReachableViaWWAN: // 手机自带网络
                    {
                    }
                        break;
                        
                    case AFNetworkReachabilityStatusReachableViaWiFi: // WIFI
                    {
                    }
                        break;
                }
            }];
            [[AFNetworkReachabilityManager sharedManager] startMonitoring];
</code></pre> 
<p>9、mp4视频播放</p> 
<pre><code>#import &lt;MediaPlayer/MediaPlayer.h&gt;

//本地视频
//NSString *urlStr=[[NSBundle mainBundle] pathForResource:@"xxx.mp4" ofType:nil];
//NSURL * videoURL =[NSURL fileURLWithPath:urlStr];

//在线视频
NSURL *videoURL = URL;
MPMoviePlayerViewController *moviePlayerController = [[MPMoviePlayerViewController alloc] initWithContentURL:videoURL];
moviePlayerController.moviePlayer.movieSourceType = MPMovieSourceTypeFile;
moviePlayerController.moviePlayer.shouldAutoplay = YES;
[moviePlayerController.moviePlayer prepareToPlay];
[moviePlayerController.moviePlayer play];
[self presentViewController:moviePlayerController animated:YES completion:nil];
</code></pre> 
<p>AVFoundation播放视频</p> 
<pre><code>#import &lt;AVKit/AVKit.h&gt;
#import &lt;AVFoundation/AVFoundation.h&gt;
AVPlayerViewController *playerViewController = [[AVPlayerViewController alloc] init];
playerViewController.player = [AVPlayer playerWithURL:[NSURL fileURLWithPath:savedImagePath]];
[_delegate presentViewController:playerViewController animated:YES completion:nil];
[playerViewController.player play];
</code></pre> 
<p>10、确认弹出框</p> 
<pre><code>UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"提示" message:@"手机网络是否播放" preferredStyle:UIAlertControllerStyleAlert];
[alertController addAction:([UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) {
                            
                        }])];
[alertController addAction:([UIAlertAction actionWithTitle:@"确认" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
                        }])];
[self presentViewController:alertController animated:YES completion:nil];
</code></pre> 
<p>11、生成高清二维码</p> 
<pre><code> // 1. 创建一个二维码滤镜实例(CIFilter)
    CIFilter *filter = [CIFilter filterWithName:@"CIQRCodeGenerator"];
    // 滤镜恢复默认设置
    [filter setDefaults];
    
    // 2. 给滤镜添加数据
    NSString *string = qcode;
    NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];
    // 使用KVC的方式给filter赋值
    [filter setValue:data forKeyPath:@"inputMessage"];
    
    // 3. 生成二维码
    CIImage *image = [filter outputImage];
    _testimageView=[[UIImageView alloc]initWithFrame:CGRectMake(0, 0, kWindowWidth, kWindowWidth)];
    // 4. 显示二维码
    _testimageView.image = [self createNonInterpolatedUIImageFormCIImage:image withSize:kWindowWidth];
    [self.view addSubview:_testimageView];
</code></pre> 
<pre><code>**
 * 根据CIImage生成指定大小的UIImage
 *
 * @param image CIImage
 * @param size 图片宽度
 */
- (UIImage *)createNonInterpolatedUIImageFormCIImage:(CIImage *)image withSize:(CGFloat) size
{
    CGRect extent = CGRectIntegral(image.extent);
    CGFloat scale = MIN(size/CGRectGetWidth(extent), size/CGRectGetHeight(extent));
    // 1.创建bitmap;
    size_t width = CGRectGetWidth(extent) * scale;
    size_t height = CGRectGetHeight(extent) * scale;
    CGColorSpaceRef cs = CGColorSpaceCreateDeviceGray();
    CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, cs, (CGBitmapInfo)kCGImageAlphaNone);
    CIContext *context = [CIContext contextWithOptions:nil];
    CGImageRef bitmapImage = [context createCGImage:image fromRect:extent];
    CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone);
    CGContextScaleCTM(bitmapRef, scale, scale);
    CGContextDrawImage(bitmapRef, extent, bitmapImage);
    // 2.保存bitmap到图片
    CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef);
    CGContextRelease(bitmapRef);
    CGImageRelease(bitmapImage);
    return [UIImage imageWithCGImage:scaledImage];
}
</code></pre> 
<p>12、状态栏让视图下移20px</p> 
<pre><code>  //网页
    UIView* stausBg =[[UIView alloc] initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, 20)];
    stausBg.backgroundColor = [UIColor clearColor];
    [self.view addSubview:stausBg];
</code></pre> 
<pre><code>- (void)setAdjustmentNever
{
    if (@available(iOS 11.0, *)) {
        [[UIScrollView appearance] setContentInsetAdjustmentBehavior:UIScrollViewContentInsetAdjustmentNever];
    }
}

- (void)setAdjustmentAutomatic
{
    if (@available(iOS 11.0, *)) {
        [[UIScrollView appearance] setContentInsetAdjustmentBehavior:UIScrollViewContentInsetAdjustmentAutomatic];
    }
}

</code></pre> 
<p>13、获取iOS唯一标识<br> NSUUID,卸载后重新安装会该值会改变</p> 
<pre><code>NSString *uuid = [[NSUUID UUID] UUIDString];
</code></pre> 
<p>IDFV-identifierForVendor获取广告位标识，卸载后不会改变但上架App Store如果未接入广告服务可能会被拒</p> 
<pre><code>#import &lt;AdSupport/ASIdentifierManager.h&gt;

NSString *deviceID = [[ASIdentifierManager sharedManager].advertisingIdentifier UUIDString];
</code></pre> 
<p>以上各方法均为最终解决问题，经查阅资料写了下面的类才获取唯一标识UUID，卸载不变(2018-9-29更新)</p> 
<pre><code>#import &lt;Foundation/Foundation.h&gt;
#import &lt;Security/Security.h&gt;


@interface UUIDStrengthen : NSObject
/**
 本方法是得到 UUID 后存入系统中的 keychain 的方法
 不用添加 plist 文件
 程序删除后重装,仍可以得到相同的唯一标示
 但是当系统升级或者刷机后,系统中的钥匙串会被清空,此时本方法失效
 */
-(NSString *)getDeviceIDInKeychain;
@end
</code></pre> 
<pre><code>//
//  UUIDStrengthen.m
//  bitech
//
//  Created by BITECH on 2018/9/29.
//  Copyright © 2018年 bitech. All rights reserved.
//

#import "UUIDStrengthen.h"

@implementation UUIDStrengthen
-(NSString *)getDeviceIDInKeychain
{
    NSString *getUDIDInKeychain = (NSString *)[self load:@"com.myapp.udid.test"];
    
    NSLog(@"从keychain中获取到的 UDID_INSTEAD %@",getUDIDInKeychain);
    if (!getUDIDInKeychain ||[getUDIDInKeychain isEqualToString:@""]||[getUDIDInKeychain isKindOfClass:[NSNull class]]) {
        CFUUIDRef puuid = CFUUIDCreate( nil );
        CFStringRef uuidString = CFUUIDCreateString( nil, puuid );
        NSString * result = (NSString *)CFBridgingRelease(CFStringCreateCopy( NULL, uuidString));
        CFRelease(puuid);
        CFRelease(uuidString);
        NSLog(@"\n \n \n _____重新存储 UUID _____\n \n \n  %@",result);
        [self save:@"com.myapp.udid.test" data:result];
        getUDIDInKeychain = (NSString *)[self load:@"com.myapp.udid.test"];
    }
    NSLog(@"最终 ———— UDID_INSTEAD %@",getUDIDInKeychain);
    return getUDIDInKeychain;
}

#pragma mark - private

- (NSMutableDictionary *)getKeychainQuery:(NSString *)service {
    return [NSMutableDictionary dictionaryWithObjectsAndKeys:
            (id)kSecClassGenericPassword,(id)kSecClass,
            service, (id)kSecAttrService,
            service, (id)kSecAttrAccount,
            (id)kSecAttrAccessibleAfterFirstUnlock,(id)kSecAttrAccessible,
            nil];
}

- (void)save:(NSString *)service data:(id)data {
    //Get search dictionary
    NSMutableDictionary *keychainQuery = [self getKeychainQuery:service];
    //Delete old item before add new item
    SecItemDelete((CFDictionaryRef)keychainQuery);
    //Add new object to search dictionary(Attention:the data format)
    [keychainQuery setObject:[NSKeyedArchiver archivedDataWithRootObject:data] forKey:(id)kSecValueData];
    //Add item to keychain with the search dictionary
    SecItemAdd((CFDictionaryRef)keychainQuery, NULL);
}

- (id)load:(NSString *)service {
    id ret = nil;
    NSMutableDictionary *keychainQuery = [self getKeychainQuery:service];
    //Configure the search setting
    //Since in our simple case we are expecting only a single attribute to be returned (the password) we can set the attribute kSecReturnData to kCFBooleanTrue
    [keychainQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData];
    [keychainQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];
    CFDataRef keyData = NULL;
    OSStatus status =  SecItemCopyMatching((CFDictionaryRef)keychainQuery, (CFTypeRef *)&amp;keyData);
    if (status == noErr) {
        @try {
            ret = [NSKeyedUnarchiver unarchiveObjectWithData:(__bridge NSData *)keyData];
        } @catch (NSException *e) {
            NSLog(@"Unarchive of %@ failed: %@", service, e);
            return @"解析设备错误，请返回页面重新获取";
        } @finally {
        }
    } else if (status != errSecItemNotFound) {
       return @"查询设备错误，请返回页面重新获取";
    }
    if (keyData)
    CFRelease(keyData);
    return ret;
}

- (void)delete:(NSString *)service {
    NSMutableDictionary *keychainQuery = [self getKeychainQuery:service];
    SecItemDelete((CFDictionaryRef)keychainQuery);
}
@end

</code></pre> 
<pre><code>NSString *deviceID = [[UUIDStrengthen alloc]getDeviceIDInKeychain];
if([deviceID isEqualToString:@"查询设备错误，请滑动返回页面重新获取"]||[deviceID isEqualToString:@"解析设备错误，请滑动返回页面重新获取"]){
      [SVProgressHUD showInfoWithStatus:deviceID];
      [self performSelector:@selector(dismiss) withObject:nil afterDelay:2.0f];
} else {
      [wkWebView evaluateJavaScript:[NSString stringWithFormat:@"iosSetLocation('%f','%f','%s','%@')",location.coordinate.latitude,location.coordinate.longitude,"str",deviceID] completionHandler:nil];
 }
</code></pre> 
<p>14、iOS原生实现人脸识别</p> 
<pre><code>#import &lt;AVFoundation/AVFoundation.h&gt;
#import "SVProgressHUD.h"
#import &lt;AssetsLibrary/ALAsset.h&gt;

#import &lt;AssetsLibrary/ALAssetsLibrary.h&gt;

#import &lt;AssetsLibrary/ALAssetsGroup.h&gt;

#import &lt;AssetsLibrary/ALAssetRepresentation.h&gt;
</code></pre> 
<pre><code>@interface CameralViewController ()&lt;AVCaptureVideoDataOutputSampleBufferDelegate, AVCaptureMetadataOutputObjectsDelegate&gt;
{
    WBProgressBlock _successBlock;
}
@property (nonatomic, strong) AVCaptureSession *captureSession;
@property (nonatomic, strong) AVCaptureDevice *captureDevice;
@property (nonatomic, strong) AVCaptureDeviceInput *captureVideoDeviceInput;
@property (nonatomic, strong) AVCaptureMetadataOutput *metaDataOutput;
@property (nonatomic, strong) AVCaptureVideoDataOutput *captureOutput;
@property (nonatomic, strong) AVCaptureConnection *captureConnection;
@property (nonatomic, strong) AVCaptureVideoPreviewLayer *previewLayer;
@property (nonatomic, strong) NSMutableArray &lt;UIView *&gt; *faceViewArrM;

@end
</code></pre> 
<pre><code>@implementation CameralViewController
-(instancetype)initWithBitechSuccess:(void (^)(NSString *filepath))success;
{
    self =[super init];
    _successBlock = success;
    return self;
}

- (void)viewDidLoad {
    [super viewDidLoad];
    self.faceViewArrM = [NSMutableArray array];
    _hasFace=NO;
    _isShowPic=NO;
    self.captureSession = [[AVCaptureSession alloc] init];
    if ([self.captureSession canSetSessionPreset:AVCaptureSessionPresetHigh]) {
        self.captureSession.sessionPreset = AVCaptureSessionPresetHigh;
    }
    else {
        self.captureSession.sessionPreset = AVCaptureSessionPreset1280x720;
    }
    
    //    for (AVCaptureDevice *device in [AVCaptureDevice devices]) {
    //        if ([device hasMediaType:AVMediaTypeVideo]) {
    //            if (device.position == AVCaptureDevicePositionFront) {
    //                self.captureDevice = device;
    //            }
    //        }
    //    }
    self.captureDevice = [self cameroWithPosition:AVCaptureDevicePositionFront];
    
    //添加输入
    [self addVideoInput];
    
    //添加输出
    [self addVideoOutput];
    
    //添加预览图层
    [self addPreviewLayer];
    
    [self.captureSession commitConfiguration];
    [self.captureSession startRunning];
}


//获取可用的摄像头
- (AVCaptureDevice *)cameroWithPosition:(AVCaptureDevicePosition)position{
    
    if (@available(iOS 10.2, *)) {
        AVCaptureDeviceDiscoverySession *dissession = [AVCaptureDeviceDiscoverySession discoverySessionWithDeviceTypes:@[AVCaptureDeviceTypeBuiltInDualCamera,AVCaptureDeviceTypeBuiltInTelephotoCamera,AVCaptureDeviceTypeBuiltInWideAngleCamera] mediaType:AVMediaTypeVideo position:position];
        for (AVCaptureDevice *device in dissession.devices) {
            if ([device position] == position ) {
                return device;
            }
        }
    } else {
        NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo];
        for (AVCaptureDevice *device in devices) {
            if ([device position] == position) {
                return device;
            }
        }
    }
    return nil;
}


- (void)addVideoInput
{
    NSError *error;
    self.captureVideoDeviceInput = [AVCaptureDeviceInput deviceInputWithDevice:self.captureDevice error:&amp;error];
    if (error) {
        return;
    }
    if ([self.captureSession canAddInput:self.captureVideoDeviceInput]) {
        [self.captureSession addInput:self.captureVideoDeviceInput];
    }
}

- (void)addVideoOutput
{
    self.metaDataOutput = [[AVCaptureMetadataOutput alloc] init];
    [self.metaDataOutput setMetadataObjectsDelegate:self queue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)];
    self.captureOutput=[[AVCaptureVideoDataOutput alloc] init];
    [self.captureOutput setSampleBufferDelegate:self queue:dispatch_queue_create("sample",NULL)];
    if ([self.captureSession canAddOutput:self.metaDataOutput]) {
        [self.captureSession addOutput:self.metaDataOutput];
    }
    if ([self.captureSession canAddOutput:self.captureOutput]) {
        [self.captureSession addOutput:self.captureOutput];
    }
    
    self.metaDataOutput.metadataObjectTypes =  @[AVMetadataObjectTypeFace];
    NSString     *key           = (NSString *)kCVPixelBufferPixelFormatTypeKey;
    NSNumber     *value         = [NSNumber numberWithUnsignedInt:kCVPixelFormatType_32BGRA];
    NSDictionary *videoSettings = [NSDictionary dictionaryWithObject:value forKey:key];
    
    [self.captureOutput setVideoSettings:videoSettings];
    
    //设置链接管理对象
    self.captureConnection = [self.metaDataOutput connectionWithMediaType:AVMediaTypeVideo];
    //视频旋转方向设置
    self.captureConnection.videoScaleAndCropFactor = self.captureConnection.videoMaxScaleAndCropFactor;;
    if ([self.captureConnection isVideoOrientationSupported]){
        
        [self.captureConnection setVideoOrientation:AVCaptureVideoOrientationPortrait];
        
    }
    //视频稳定设置
    if ([self.captureConnection isVideoStabilizationSupported]) {
        self.captureConnection.preferredVideoStabilizationMode = AVCaptureVideoStabilizationModeAuto;
    }
}

- (void)addPreviewLayer
{
    self.previewLayer = [AVCaptureVideoPreviewLayer layerWithSession:self.captureSession];
    [self.previewLayer setVideoGravity:AVLayerVideoGravityResizeAspect];
    self.previewLayer.frame = self.view.bounds;
    [self.view.layer addSublayer:self.previewLayer];
    
    self.faceLayer=[[CALayer alloc]init];
    self.faceLayer.borderColor=[UIColor redColor].CGColor;
    self.faceLayer.borderWidth=1;
    [self.view.layer addSublayer:self.faceLayer];
}

#pragma mark -  AVCaptureVideoDataOutputSampleBufferDelegate

- (void)captureOutput:(AVCaptureOutput *)output didOutputMetadataObjects:(NSArray&lt;__kindof AVMetadataObject *&gt; *)metadataObjects fromConnection:(AVCaptureConnection *)connection
{
    NSLog(@"检测到了人脸，数目为%lu", (unsigned long)metadataObjects.count);
    if (metadataObjects.count &gt; 0) {
        _hasFace=YES;
        NSLog(@"%@", metadataObjects);
        NSMutableArray *bounds = [NSMutableArray arrayWithCapacity:0];
        for (AVMetadataFaceObject *faceobject in metadataObjects) {
            AVMetadataObject *face = [output transformedMetadataObjectForMetadataObject:faceobject connection:connection];
            [bounds addObject:[NSValue valueWithCGRect:face.bounds]];
        }
        
        for (NSValue *rect in bounds) {
            CGRect r = [rect CGRectValue];
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                int swidth =  self.view.frame.size.width;
                int sheight = self.view.frame.size.height;
                self.faceLayer.hidden=NO;
                self.faceLayer.frame=CGRectMake(swidth*r.origin.y, sheight*r.origin.x, swidth*r.size.height, sheight*r.size.width);
            });
        }
    }
    else {
        _hasFace=NO;
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            self.faceLayer.hidden=YES;
        });
    }
}
- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection
{
    if (!_isShowPic) {
        //转换成UIImage
        UIImage *image = [self getImageBySampleBufferref:sampleBuffer];
        //这里不考虑性能 直接怼Image
        dispatch_async(dispatch_get_main_queue(), ^{
            _pictureImageView.image = image;
        });
    }
}
// 将获取的数据转换成图片，网上很多转换方式转出来的图片都是错误的，最后找到这个方法

- (UIImage *)getImageBySampleBufferref:(CMSampleBufferRef)sampleBuffer

{
// 方法1
    CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);
    CVPixelBufferLockBaseAddress(imageBuffer,0);
    uint8_t *baseAddress = (uint8_t *)CVPixelBufferGetBaseAddress(imageBuffer);
    size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);
    size_t width = CVPixelBufferGetWidth(imageBuffer);
    size_t height = CVPixelBufferGetHeight(imageBuffer);
    
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef newContext = CGBitmapContextCreate(baseAddress, width, height, 8, bytesPerRow, colorSpace,                                                  kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);
    
    CGImageRef newImage = CGBitmapContextCreateImage(newContext);
    
    CGContextRelease(newContext);
    CGColorSpaceRelease(colorSpace);

    UIImage *image= [UIImage imageWithCGImage:newImage scale:1.0 orientation:UIImageOrientationLeftMirrored];
    // release
    CGImageRelease(newImage);
    
    return image;
    
// 方法2
//    CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);
//
//    /*Lock the image buffer*/
//
//    CVPixelBufferLockBaseAddress(imageBuffer,0);
//
//    /*Get information about the image*/
//
//    uint8_t *baseAddress = (uint8_t *)CVPixelBufferGetBaseAddress(imageBuffer);
//
//    size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);
//
//    size_t width = CVPixelBufferGetWidth(imageBuffer);
//
//    size_t height = CVPixelBufferGetHeight(imageBuffer);
//    /*We unlock the  image buffer*/
//
//    CVPixelBufferUnlockBaseAddress(imageBuffer,0);
//    /*Create a CGImageRef from the CVImageBufferRef*/
//
//    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
//
//    CGContextRef newContext = CGBitmapContextCreate(baseAddress, width, height, 8, bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);
//
//    CGImageRef newImage = CGBitmapContextCreateImage(newContext);
//
//
//
//    /*We release some components*/
//
//    CGContextRelease(newContext);
//
//    CGColorSpaceRelease(colorSpace);
//    UIImage *image= [UIImage imageWithCGImage:newImage scale:1.0 orientation:UIImageOrientationRight];
//
//    NSLog(@"%@", image);
//    /*We relase the CGImageRef*/
//
//    CGImageRelease(newImage);
//
//    return image;
    
}

</code></pre> 
<p>图片转成base64串</p> 
<pre><code>UIImage *image = _pictureImageView.image;
NSData *imageData = UIImageJPEGRepresentation(image, 0.3f);
NSString *imageBase64Str = [imageData base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];
</code></pre> 
<p>15、监测网络是否畅通（有网络请求数据不成功）</p> 
<pre><code>if ([self checkNetworkCanUse]) {
        NSLog(@"网络畅通");
}else{
      NSLog(@"网络不通");
}
</code></pre> 
<pre><code>#define kAppleUrlTocheckWifi @"http://captive.apple.com"
-(BOOL)checkNetworkCanUse{
    
    // 1.将网址初始化成一个OC字符串对象
    NSString *urlStr = kAppleUrlTocheckWifi;
    // 如果网址中存在中文,进行URLEncode
    NSString *newUrlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
    // 2.构建网络URL对象, NSURL
    NSURL *url = [NSURL URLWithString:newUrlStr];
    // 3.创建网络请求
    NSURLRequest *request = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:3];
    // 创建同步链接
    NSURLResponse *response = nil;
    NSError *error = nil;
    NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];
    
    NSString* result1 = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];
    //解析html页面
    NSString *str = [self flattenHTML:result1];
    //除掉换行符
    NSString *nstr = [str stringByReplacingOccurrencesOfString:@"\n" withString:@""];
    
    if ([nstr isEqualToString:@"SuccessSuccess"])
    {
        // NSLog(@"可以上网了");
        //   [PronetwayGeneralHandle shareHandle].NetworkCanUse = YES;
        return YES;
    }else {
        // NSLog(@"未联网");
        //[self showNetworkStatus:@"未联网"];
        //   [PronetwayGeneralHandle shareHandle].NetworkCanUse = NO;
        return NO;
    }
}
</code></pre> 
<p>16、扫描二维码跳转appstore</p> 
<pre><code>https://itunes.apple.com/app/id1371231677
// itms-apps://itunes.apple.com/cn/app/id1371231677?mt=8
</code></pre> 
<p>17、base64与图片互转</p> 
<pre><code>// 64base字符串转图片

- (UIImage *)stringToImage:(NSString *)str {
   //html获取的base64需要截取后才能使用
    NSArray *arr=[str componentsSeparatedByString:@"base64,"];
    NSData *decodedImageData = [[NSData alloc]initWithBase64EncodedString:arr[1] options:NSDataBase64DecodingIgnoreUnknownCharacters];
    
    UIImage *decodedImage = [UIImage imageWithData:decodedImageData];
    _showImageView.image = decodedImage;
    
    return decodedImage;
    
}

// 图片转64base字符串

- (NSString *)imageToString:(UIImage *)image {
    
    NSData *imagedata = UIImagePNGRepresentation(image);
    
    NSString *image64 = [imagedata base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];
    return image64;
}
</code></pre> 
<p>18、iOS上传服务器图片旋转问题</p> 
<pre><code>-(UIImage *)fixOrientation:(UIImage *)aImage {
    // No-op if the orientation is already correct
    if (aImage.imageOrientation ==UIImageOrientationUp)
        return aImage;
    // We need to calculate the proper transformation to make the image upright.
    // We do it in 2 steps: Rotate if Left/Right/Down, and then flip if Mirrored.
    CGAffineTransform transform =CGAffineTransformIdentity;
    switch (aImage.imageOrientation) {
        case UIImageOrientationDown:
        case UIImageOrientationDownMirrored:
            transform = CGAffineTransformTranslate(transform, aImage.size.width, aImage.size.height);
            transform = CGAffineTransformRotate(transform, M_PI);
            break;
        case UIImageOrientationLeft:
        case UIImageOrientationLeftMirrored:
            transform = CGAffineTransformTranslate(transform, aImage.size.width,0);
            transform = CGAffineTransformRotate(transform, M_PI_2);
            break;
        case UIImageOrientationRight:
        case UIImageOrientationRightMirrored:
            transform = CGAffineTransformTranslate(transform, 0, aImage.size.height);
            transform = CGAffineTransformRotate(transform, -M_PI_2);
            break;
        default:
            break;
    }
    switch (aImage.imageOrientation) {
        case UIImageOrientationUpMirrored:
        case UIImageOrientationDownMirrored:
            
            transform = CGAffineTransformTranslate(transform, aImage.size.width,0);
            transform = CGAffineTransformScale(transform, -1, 1);
            break;
        case UIImageOrientationLeftMirrored:
        case UIImageOrientationRightMirrored:
            transform = CGAffineTransformTranslate(transform, aImage.size.height,0);
            transform = CGAffineTransformScale(transform, -1, 1);
            break;
        default:
            break;
    }
    // Now we draw the underlying CGImage into a new context, applying the transform
    // calculated above.
    CGContextRef ctx =CGBitmapContextCreate(NULL, aImage.size.width, aImage.size.height,
                                            CGImageGetBitsPerComponent(aImage.CGImage),0,
                                            CGImageGetColorSpace(aImage.CGImage),
                                            CGImageGetBitmapInfo(aImage.CGImage));
    CGContextConcatCTM(ctx, transform);
    switch (aImage.imageOrientation) {
        case UIImageOrientationLeft:
        case UIImageOrientationLeftMirrored:
        case UIImageOrientationRight:
        case UIImageOrientationRightMirrored:
            CGContextDrawImage(ctx,CGRectMake(0,0,aImage.size.height,aImage.size.width), aImage.CGImage);
            break;
        default:
            CGContextDrawImage(ctx,CGRectMake(0,0,aImage.size.width,aImage.size.height), aImage.CGImage);
            break;
    }
    // And now we just create a new UIImage from the drawing context
    CGImageRef cgimg =CGBitmapContextCreateImage(ctx);
    UIImage *img = [UIImage imageWithCGImage:cgimg];
    CGContextRelease(ctx);
    CGImageRelease(cgimg);
    return img;
}

</code></pre> 
<p>19、appstore隐私策略</p> 
<pre><code>一、总则
1.1 XXXX的所有权和运营权归XXXX所有。
1.2 用户在注册之前，应当仔细阅读本协议，并同意遵守本协议后方可成为注册用户。一旦注册成功，则用户与XXXX之间自动形成协议关系，用户应当受本协议 的约束。用户在使用特殊的服务或产品时，应当同意接受相关协议后方能使用。
1.3 本协议则可由XXXX随时更新，用户应当及时关注并同意本站不承担通知义务。本站的通知、公告、声明或其它类似内容是本协议的一部分。

二、服务内容
 2.1 XXXX的具体内容由本站根据实际情况提供。
 2.2 本站仅提供相关的网络服务，除此之外与相关网络服务有关的设备(如个人电脑、手机、及其他与接入互联网或移动网有关的装置)及所需的费用(如为接入互联 网而支付的电话费及上网费、为使用移动网而支付的手机费)均应由用户自行负担。
 三、用户帐号
 3.1 经本站注册系统完成注册程序并通过身份认证的用户即成为正式用户，可以获得本站规定用户所应享有的一切权限；未经认证仅享有本站规定的部分会员权限 。保宝网有权对会员的权限设计进行变更。
 3.2 用户只能按照注册要求使用真实手机号注册。用户有义务保证密码和帐号的安全，用户利用该密码和帐号所进行的一切活动引起的任何损失或损害，由用户自 行承担全部责任，本站不承担任何责任。如用户发现帐号遭到未授权的使用或发生其他任何安全问题，应立即修改帐号密码并妥善保管，如有必要，请通知本站。 因黑客行为或用户的保管疏忽导致帐号非法使用，本站不承担任何责任。
 四、使用规则
 4.1 遵守中华人民共和国相关法律法规，包括但不限于《中华人民共和国计算机信息系统安全保护条例》、《计算机软件保护条例》、《最高人民法院关于审理涉 及计算机网络著作权纠纷案件适用法律若干问题的解释(法释[2004]1号)》、《全国人大常委会关于维护互联网安全的决定》、《互联网电子公告服务管理规定》、 《互联网新闻信息服务管理规定》、《互联网著作权行政保护办法》和《信息网络传播权保护条例》等有关计算机互联网规定和知识产权的法律和法规、实施办法 。
 4.2 用户对其自行发表、上传或传送的内容负全部责任，所有用户不得在本站任何页面发布、转载、传送含有下列内容之一的信息，否则本站有权自行处理并不通 知用户：

 (1)违反宪法确定的基本原则的；
 (2)危害国家安全，泄漏国家机密，颠覆国家政权，破坏国家统一的；
 (3)损害国家荣誉和利益的；
 (4)煽动民族仇恨、民族歧视，破坏民族团结的；
 (5)破坏国家宗教政策，宣扬邪教和封建迷信的；
 (6)散布谣言，扰乱社会秩序，破坏社会稳定的；
 (7)散布淫秽、色情、赌博、暴力、恐怖或者教唆犯罪的；
 (8)侮辱或者诽谤他人，侵害他人合法权益的；
 (9)煽动非法集会、结社、游行、示威、聚众扰乱社会秩序的；
 (10)以非法民间组织名义活动的；
 (11)含有法律、行政法规禁止的其他内容的。
 4.3 用户承诺对其发表或者上传于本站的所有信息(即属于《中华人民共和国著作权法》规定的作品，包括但不限于文字、图片、音乐、电影、表演和录音录像制品 和电脑程序等)均享有完整的知识产权，或者已经得到相关权利人的合法授权；如用户违反本条规定造成本站被第三人索赔的，用户应全额补偿本站一切费用(包括 但不限于各种赔偿费、诉讼代理费及为此支出的其它合理费用)；
 4.4 当第三方认为用户发表或者上传于本站的信息侵犯其权利，并根据《信息网络传播权保护条例》或者相关法律规定向本站发送权利通知书时，用户同意本站可 以自行判断决定删除涉嫌侵权信息，除非用户提交书面证据材料排除侵权的可能性，本站将不会自动恢复上述删除的信息；
 (1)不得为任何非法目的而使用网络服务系统；
 (2)遵守所有与网络服务有关的网络协议、规定和程序； (3)不得利用本站进行任何可能对互联网的正常运转造成不利影响的行为；
 (4)不得利用本站进行任何不利于本站的行为。
 4.5 如用户在使用网络服务时违反上述任何规定，本站有权要求用户改正或直接采取一切必要的措施(包括但不限于删除用户张贴的内容、暂停或终止用户使用网络 服务的权利)以减轻用户不当行为而造成的影响。


 五、隐私保护
 5.1 本站不对外公开或向第三方提供单个用户的注册资料及用户在使用网络服务时存储在本站的非公开内容，但下列情况除外：
 (1)事先获得用户的明确授权；
 (2)根据有关的法律法规要求；
 (3)按照相关政府主管部门的要求；
 (4)为维护社会公众的利益。
 5.2 本站可能会与第三方合作向用户提供相关的网络服务，在此情况下，如该第三方同意承担与本站同等的保护用户隐私的责任，则本站有权将用户的注册资料等 提供给该第三方。
 5.3 在不透露单个用户隐私资料的前提下，本站有权对整个用户数据库进行分析并对用户数据库进行商业上的利用。


 六、版权声明
 6.1 本站的文字、图片、音频、视频等版权均归XXXX享有或与作者共同享有，未经本站许可，不得任意转载。
 6.2 本站特有的标识、版面设计、编排方式等版权均属XXXX享有，未经本站许可，不得任意复制或转载。
 6.3 使用本站的任何内容均应注明“来源于XXXX” 及署上作者姓名，按法律规定需要支付稿酬的，应当通知本站及作者及支付稿酬，并独立承担一切法律责任。
 6.4 本站享有所有作品用于其它用途的优先权，包括但不限于网站、电子杂志、平面出版等，但在使用前会通知作者，并按同行业的标准支付稿酬。
 6.5 本站所有内容仅代表作者自己的立场和观点，与本站无关，由作者本人承担一切法律责任。
 6.6 恶意转载本站内容的，本站保留将其诉诸法律的权利。


 七、责任声明
 7.1 用户明确同意其使用本站网络服务所存在的风险及一切后果将完全由用户本人承担，保宝网对此不承担任何责任。
 7.2 本站无法保证网络服务一定能满足用户的要求，也不保证网络服务的及时性、安全性、准确性。
 7.3 本站不保证为方便用户而设置的外部链接的准确性和完整性，同时，对于该等外部链接指向的不由本站实际控制的任何网页上的内容，本站不承担任何责任。
 7.4 对于因不可抗力或本站不能控制的原因造成的网络服务中断或其它缺陷，本站不承担任何责任，但将尽力减少因此而给用户造成的损失和影响。
 7.5 对于站向用户提供的下列产品或者服务的质量缺陷本身及其引发的任何损失，本站无需承担任何责任：
 (1)本站向用户免费提供的各项网络服务；
 (2)本站向用户赠送的任何产品或者服务。
 7.6 本站有权于任何时间暂时或永久修改或终止本服务(或其任何部分)，而无论其通知与否，本站对用户和任何第三人均无需承担任何责任。


 八、附则
 8.1 本协议的订立、执行和解释及争议的解决均应适用中华人民共和国法律。
 8.2 如本协议中的任何条款无论因何种原因完全或部分无效或不具有执行力，本协议的其余条款仍应有效并且有约束力。
 8.3 本协议解释权及修订权归XXXX所有。
</code></pre> 
<p>20、iOS上架获取专用密码地址<br> <a href="https://appleid.apple.com/#!&amp;page=signin" rel="nofollow">专用密码</a></p> 
<pre><code>https://appleid.apple.com/#!&amp;page=signin
</code></pre> 
<p>21、瑞谷老项目CGRectMake被锁死，使用下面替换</p> 
<pre><code>    webviewn.size=CGSizeMake(self.view.frame.size.width,scrollView.frame.size.height);
    webviewn.center=CGPointMake(sender.currentPage*self.view.frame.size.width+self.view.frame.size.width/2, scrollView.frame.size.height/2);

    // 方式1
//    self.label.frame = CGRectMake(200, 100, 100, 60);
    
    // 方式2
    self.label.frame = (CGRect){<!-- -->{100, 100}, {100, 100}};

</code></pre> 
<p>22、自定义极光推送提示音<br> (1)转换mp3到caf</p> 
<pre><code>afconvert /System/Library/Sounds/Submarine.aiff ~/Desktop/sub.caf -d ima4 -f caff -v
</code></pre> 
<p>(2)拖入bundle resources中<br> <img src="https://images2.imgbox.com/d2/d1/6r9yXtin_o.png" alt="拖入项目"><br> (3)极光后台测试<br> <img src="https://images2.imgbox.com/e0/4c/xOdH4oCw_o.png" alt="极光"></p> 
<p>23、检测当前应用是否开启定位并跳转设置</p> 
<pre><code>#pragma mark 判断是否打开定位没有提示设置

-(void)determineWhetherTheAPPOpensTheLocation{
   
   if (!([CLLocationManager locationServicesEnabled] &amp;&amp; ([CLLocationManager authorizationStatus] == kCLAuthorizationStatusAuthorizedWhenInUse || [CLLocationManager authorizationStatus] == kCLAuthorizationStatusNotDetermined || [CLLocationManager authorizationStatus] == kCLAuthorizationStatusAuthorizedAlways))) {
       //定位功能不可用
       // 初始化对话框
       UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"提示" message:@"请到设置-&gt;隐私-&gt;定位服务中开启【未来城】定位服务，以便于距离筛选能够准确获得你的位置信息" preferredStyle:UIAlertControllerStyleAlert];
       // 确定注销
       UIAlertAction *okAction = [UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDefault handler:^(UIAlertAction *_Nonnull action) {
             [[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];
       }];
       UIAlertAction *cancelAction =[UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:nil];
       
       [alert addAction:okAction];
       [alert addAction:cancelAction];
       // 弹出对话框
       [self presentViewController:alert animated:true completion:nil];
   }
}
</code></pre> 
<p>24、首次网络加载失败，从新请求数据</p> 
<pre><code> //开启定时器
    if (!m_netSpeed) {
        m_netSpeed=[NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(checkNetworkCanUse) userInfo:nil repeats:YES];
        //        [[NSRunLoop mainRunLoop] addTimer:m_netSpeed forMode:NSDefaultRunLoopMode];
    }
</code></pre> 
<pre><code>
#define kAppleUrlTocheckWifi @"http://captive.apple.com"
-(BOOL)checkNetworkCanUse{
    // 1.将网址初始化成一个OC字符串对象
    NSString *urlStr = kAppleUrlTocheckWifi;
    // 如果网址中存在中文,进行URLEncode
    NSString *newUrlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
    // 2.构建网络URL对象, NSURL
    NSURL *url = [NSURL URLWithString:newUrlStr];
    // 3.创建网络请求
    NSURLRequest *request = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:4];
    // 创建同步链接
    NSURLResponse *response = nil;
    NSError *error = nil;
    NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];
    
    NSString* result1 = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];
    //解析html页面
    NSString *str = [self flattenHTML:result1];
    //除掉换行符
    NSString *nstr = [str stringByReplacingOccurrencesOfString:@"\n" withString:@""];
    
    if ([nstr isEqualToString:@"SuccessSuccess"])
    {
        // NSLog(@"可以上网了");
        //   [PronetwayGeneralHandle shareHandle].NetworkCanUse = YES;
        if (m_netSpeed.valid==YES)
        {
            [m_netSpeed invalidate];
            m_netSpeed=nil;
            [self refreshWebView];
        }
        return YES;
    } else {
        // NSLog(@"未联网");
        //[self showNetworkStatus:@"未联网"];
        //   [PronetwayGeneralHandle shareHandle].NetworkCanUse = NO;
        return NO;
    }
}

//过滤后台返回字符串中的标签
- (NSString *)flattenHTML:(NSString *)html {
    
    NSScanner *theScanner;
    NSString *text = nil;
    
    theScanner = [NSScanner scannerWithString:html];
    
    while ([theScanner isAtEnd] == NO) {
        // find start of tag
        [theScanner scanUpToString:@"&lt;" intoString:NULL] ;
        // find end of tag
        [theScanner scanUpToString:@"&gt;" intoString:&amp;text] ;
        // replace the found tag with a space
        //(you can filter multi-spaces out later if you wish)
        html = [html stringByReplacingOccurrencesOfString:
                [NSString stringWithFormat:@"%@&gt;", text]
                                               withString:@""];
    }
    return html;
}

-(void)refreshWebView {
    [wkWebView reload];
}


</code></pre> 
<p>25、检测iOS越狱</p> 
<pre><code>    if ([self isJailBreak] || [self isJailBreak2] || [self isJailBreak3]) {
        [SVProgressHUD showInfoWithStatus:@"该设备已越狱，请谨慎使用！"];
        [self performSelector:@selector(dismiss) withObject:nil afterDelay:1.5f];
    }
</code></pre> 
<pre><code>#define ARRAY_SIZE(a) sizeof(a)/sizeof(a[0])
#define USER_APP_PATH                 @"/User/Applications/"
const char* jailbreak_tool_pathes[] = {
    "/Applications/Cydia.app",
    "/Library/MobileSubstrate/MobileSubstrate.dylib",
    "/bin/bash",
    "/usr/sbin/sshd",
    "/etc/apt"
};
- (BOOL)isJailBreak
{
    for (int i=0; i&lt;ARRAY_SIZE(jailbreak_tool_pathes); i++) {
        if ([[NSFileManager defaultManager] fileExistsAtPath:[NSString stringWithUTF8String:jailbreak_tool_pathes[i]]]) {
            NSLog(@"The device is jail broken!");
            return YES;
        }
    }
    NSLog(@"The device is NOT jail broken!");
    return NO;
}

- (BOOL)isJailBreak2
{
    if ([[NSFileManager defaultManager] fileExistsAtPath:USER_APP_PATH]) {
        NSLog(@"The device is jail broken!");
        NSArray *applist = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:USER_APP_PATH error:nil];
        NSLog(@"applist = %@", applist);
        return YES;
    }
    NSLog(@"The device is NOT jail broken!");
    return NO;
}
- (BOOL)isJailBreak3
{
    if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@"cydia://"]]) {
        NSLog(@"The device is jail broken!");
        return YES;
    }
    NSLog(@"The device is NOT jail broken!");
    return NO;
}
</code></pre> 
<p>26、iOS检测是否被调试</p> 
<pre><code>#import &lt;sys/sysctl.h&gt;
if (checkDebugger()) {
        asm("mov X0,#0\n"
            "mov w16,#1\n"
            "svc #0x80"
            );
    }
</code></pre> 
<pre><code>bool checkDebugger(){
    //控制码
    int name[4];//放字节码-查询信息
    name[0] = CTL_KERN;//内核查看
    name[1] = KERN_PROC;//查询进程
    name[2] = KERN_PROC_PID; //通过进程id查进程
    name[3] = getpid();//拿到自己进程的id
    //查询结果
    struct kinfo_proc info;//进程查询信息结果
    size_t info_size = sizeof(info);//结构体大小
    int error = sysctl(name, sizeof(name)/sizeof(*name), &amp;info, &amp;info_size, 0, 0);
    assert(error == 0);//0就是没有错误
    
    //结果解析 p_flag的第12位为1就是有调试
    //p_flag 与 P_TRACED =0 就是有调试
    return ((info.kp_proc.p_flag &amp; P_TRACED) !=0);
    
}
</code></pre> 
<p>27、反动态注入</p> 
<p>对于 insert_dylib，我们可以通过在 Xcode的Build Settings中找到“Other Linker Flags”在其中加上</p> 
<pre><code>-Wl,-sectcreate,__RESTRICT,__restrict,/dev/null
</code></pre> 
<p>28、<a href="https://blog.csdn.net/yiyaaixuexi/article/details/29201699">iOS代码混淆</a></p> 
<p>29、集成极光im时报错</p> 
<pre><code>Remove the build settings from the target
</code></pre> 
<p>pod install 报这个错误</p> 
<p>解决办法 target Build Settings -&gt; Other linker flags -&gt; double click . Add $(inherited)</p> 
<p>添加prefix head文件<br> 解决办法 target Build Settings -&gt; prefix head -&gt; ${SRCROOT}/PrefixHeader.pch</p> 
<p>30、极光推送启动跳转</p> 
<pre><code>NSDictionary *pushInfo = [launchOptions objectForKey:UIApplicationLaunchOptionsRemoteNotificationKey];
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(6 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
         NSString *custom = [pushInfo valueForKey:@"custom"];
           NSString *jusername = [custom valueForKey:@"jusername"];
           UIViewController* currentView = self.window.visibleViewController;
           if ([[currentView class] isSubclassOfClass:[HomeViewController class]]) {
               if (jusername) {
                   dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                       [(HomeViewController*)currentView sendMessageToUsername:jusername];
                   });
               }
           }
    });
</code></pre> 
<p>点击消息弹框跳转</p> 
<pre><code>// iOS 10 Support  app点击推送消息时
- (void)jpushNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler {
    // Required
    NSDictionary * userInfo = response.notification.request.content.userInfo;
    NSString *tableid = [userInfo valueForKey:@"tableid"]; //推送显示的内容
    
    NSString *tablename = [userInfo valueForKey:@"tablename"];
    
    NSString *custom = [userInfo valueForKey:@"custom"];
    NSString *jusername = [custom valueForKey:@"jusername"];
    
    
    UIViewController* currentView = self.window.visibleViewController;
    if ([[currentView class] isSubclassOfClass:[HomeViewController class]] || [[currentView class] isSubclassOfClass:[GroupTableViewController class]] || [[currentView class] isSubclassOfClass:[ConversationTableViewController class]]) {
        if (tableid) {
            [(HomeViewController*)currentView goToMssageViewControllerWith:tableid and:tablename];
        }
        if (jusername) {
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                [(HomeViewController*)currentView sendMessageToUsername:jusername];
            });
        }
    }

    if([response.notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) {
        [JPUSHService handleRemoteNotification:userInfo];
    }
    completionHandler();  // 系统要求执行这个方法
}
</code></pre> 
<p>31、UITableViewController的使用<br> uitableviewcontroller中使用</p> 
<pre><code>[self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@"wbcellconversation"];
</code></pre> 
<pre><code>[self.tableView registerNib:[UINib nibWithNibName:@"GroupTableViewCell"bundle:nil]forCellReuseIdentifier:@"wbcellconversation"];
</code></pre> 
<p>cell注册</p> 
<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
     GroupTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"wbcellconversation" forIndexPath:indexPath];
    cell.tTextLabel.text = @"";
    cell.bTextLabel.text=@"";
    cell.accessoryType =UITableViewCellAccessoryDisclosureIndicator;
    return cell;
}
</code></pre> 
<p>去除底部网格</p> 
<pre><code>UIView *v = [[UIView alloc] initWithFrame:CGRectZero];
[self.tableView setTableFooterView:v];
</code></pre> 
<p>点击效果取消</p> 
<pre><code>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
    [tableView deselectRowAtIndexPath:indexPath animated:NO];
}
</code></pre> 
<p>黑暗模式下cell去除分割线</p> 
<pre><code>#import "GroupTableViewCell.h"

@implementation GroupTableViewCell
- (void)awakeFromNib {
    [super awakeFromNib];
    // Initialization code
}
- (void)setSelected:(BOOL)selected animated:(BOOL)animated {
    [super setSelected:selected animated:animated];

    // Configure the view for the selected state
    self.hLabel.backgroundColor = [UIColor redColor] ;
}
- (void)addSubview:(UIView *)view
{
    if (![view isKindOfClass:[NSClassFromString(@"_UITableViewCellSeparatorView") class]] &amp;&amp; view)
          [super addSubview:view];
}
- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated {
    [super setHighlighted:highlighted animated:animated];
    //自己的label及自己要设置的label背景色
    self.hLabel.backgroundColor = [UIColor redColor] ;
}
@end
</code></pre> 
<h6><a id="32iOSautomatically_manage_signingprovisioning_profile_1409"></a>32、iOS自动签名证书automatically manage signing怎么更新provisioning profile到期时间</h6> 
<blockquote> 
 <p>1.Xcode切到相应的target的General tab下，然后点击(!)按钮展示provisioning profile文件详情，然后拖动左上角的profile图标到桌面获取provisioning profile文件名。</p> 
</blockquote> 
<blockquote> 
 <p>2.打开~/Library/MobileDevice/Provisioning Profiles目录，然后删除相同文件名的provisioning profile文件。</p> 
</blockquote> 
<h6><a id="33ipv6_1414"></a>33、ipv6适配</h6> 
<p><a href="https://github.com/wg689/Solve-App-Store-Review-Problem/blob/master/ipv6.md">ipv6审核被拒绝的解决方案</a><br> <a href="http://ipv6-test.com/validate.php" rel="nofollow">ipv6测试</a><br> <a href="http://free-proxy.cz/zh/web-proxylist/country/US/all/ping/all" rel="nofollow">在线代理</a></p> 
<h6><a id="34iOS_1419"></a>34、iOS上架被拒记录</h6> 
<p>1、项目页面中无用按钮或者空白页面未移出（微信登录按钮、无效路由）</p> 
<p>2、项目中含有测试图片及demo、test等测试数据或者数据内容、功能重复</p> 
<p>3、提供展示图片和app本身页面不符（6.5、5.5）</p> 
<p>4、app内有接口报错或者弹出更新提示</p> 
<p>5、提供测试账号错误</p> 
<p>6、项目中没有支付，苹果检测到支付api（支付宝）</p> 
<p>7、NAT64（ipv6）环境下访问不通（接口)</p> 
<p>8、定位、拍照、获取语音授权提示不够详细</p> 
<ul><li>Privacy - Camera Usage Description 我们需要在扫码，上传照片等服务中使用您的相机</li><li>Privacy - Microphone Usage Description 访问您的麦克风，进行语音录制</li><li>Privacy - Contacts Usage Description 访问您的通讯录，为您匹配好友</li><li>Privacy - Location Always Usage Description 我们需要获取您的位置，以便根据您的位置定位到距您最近的园区</li><li>Privacy - Photo Library Usage Description 访问您的相册，进行照片上传</li><li>Privacy - Location When In Use Usage Description 我们需要获取您的位置，以便根据您的位置定位到距您最近的园区<br> 9、集成了微信第三方登录,没有集成苹果登录<br> 10、app内包含了第三方可发布内容,没有举报投诉机制<br> 11、iOS上线却伤出口合规证明<br> App Uses Non-Exempt Encryption NO</li></ul> 
<p><img src="https://images2.imgbox.com/69/00/0hYye5xe_o.png" alt=""><br> 12、录音功能提供哪里使用了录音视频，后台语音未关闭</p> 
<p><img src="https://images2.imgbox.com/53/e5/DJRZq7xW_o.png" alt=""></p> 
<p>13、绝不承认自己app是针对特定企业,否则会让你走Apple Business Manager<br> 14、审核用假的包,并解释当前app简单原因</p> 
<pre><code>该app是针对大众开发使用的产品,首期开放功能有资讯、评论,消息查看等,登录后用户可进行资讯交流,账号管理等,这是我们第一个版本,后续功能会逐步完善,给用户提供更多可玩性,可交流的功能.
The app is a product developed and used for the public. The first phase of open functions includes information, comments, message viewing, etc. After logging in, users can exchange information, account management, etc., this is our first version, and subsequent functions will be gradually improved. Users provide more playable and communicative functions.
</code></pre> 
<h6><a id="35iOS_1458"></a>35、iOS获取键盘高度</h6> 
<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(changeFramePoint:) name:UIKeyboardDidChangeFrameNotification object:nil];
</code></pre> 
<pre><code>-(void)changeFramePoint:(NSNotification *)notification{
        NSDictionary *userInfo = [notification userInfo];
         CGSize value = [[userInfo objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue].size;
        CGFloat keyBoardHight = value.height;  // 得到键盘弹出后的键盘视图所在y坐标
        if (KIsiPhoneX || KIsiPhoneXR || KIsiPhoneX_MAX) {
            [wkWebView evaluateJavaScript:[NSString stringWithFormat:@"setCommentHeight('%@')",[NSString stringWithFormat:@"%f",keyBoardHight-34]] completionHandler:nil];
        }else{
            [wkWebView evaluateJavaScript:[NSString stringWithFormat:@"setCommentHeight('%@')",[NSString stringWithFormat:@"%f",keyBoardHight]] completionHandler:nil];
        }
}
</code></pre> 
<h6><a id="36iOSFailed_to_set_plugin_placeholders_for_comxxxxxxxxxxxxxxxxxxxxxExtension_1474"></a>36、iOS启动报错Failed to set plugin placeholders for com.xxxxxxxxxx.xxxxxxxxxxxExtension</h6> 
<p>I had the same problem today. In my situation I had a different identifier in my original app than in the extension identifier “base”. The extension has to have the same identifier as the original app plus something else. E.g:</p> 
<p>Dummy App: com.company.dummy-app<br> Dummy App Extension: com.company.dummy-app.extensionName</p> 
<p>After Xcode told me that, I changed my wrong names to look like above and then the problem occured.<br> The problem was, that I had “automatic manage signing” turned on but xcode didn’t recognize that I changed the identifier.</p> 
<p>Solution:<br> Just change the identifier again and chek if in “automatic manage signing” a new provisonig profile was created.<br> Deleting derived data may also helps.<br> <a href="https://developer.apple.com/forums/thread/89065" rel="nofollow">https://developer.apple.com/forums/thread/89065</a></p> 
<h6><a id="37iOS__No_profile_for_team_xxxx_matching_xxx_found_1487"></a>37、iOS 真机调试 No profile for team ‘xxxx’ matching ‘xxx’ found:</h6> 
<p>检查下下面两个是不是都改成自己的bundle id了<br> <img src="https://images2.imgbox.com/9d/33/fuuMGoum_o.png" alt="1"></p> 
<h6><a id="38_1491"></a>38、人像采集页面搭建</h6> 
<pre><code>#import &lt;UIKit/UIKit.h&gt;
typedef void (^WBProgressBlock)(NSString *progress);
@interface CameralViewController : UIViewController
-(instancetype)initWithBitechSuccess:(void (^)(NSString *filepath))success;
@end
</code></pre> 
<pre><code>//
//  CameralViewController.m
//  React_BiPark_E01_Mobile
//
//  Created by BITECH on 2018/9/29.
//  Copyright © 2018年 bitech. All rights reserved.
//

#import "CameralViewController.h"
#import &lt;AVFoundation/AVFoundation.h&gt;
#import "SVProgressHUD.h"
#import &lt;AssetsLibrary/ALAsset.h&gt;

#import &lt;AssetsLibrary/ALAssetsLibrary.h&gt;

#import &lt;AssetsLibrary/ALAssetsGroup.h&gt;

#import &lt;AssetsLibrary/ALAssetRepresentation.h&gt;
#import &lt;sys/utsname.h&gt;//要导入头文件
#import &lt;sys/sysctl.h&gt;
#import &lt;mach/mach.h&gt;
@interface CameralViewController ()&lt;AVCaptureVideoDataOutputSampleBufferDelegate, AVCaptureMetadataOutputObjectsDelegate&gt;
{
    WBProgressBlock _successBlock;
    UIImage *_sampleBufferImage;
}
@property (nonatomic, retain) AVCaptureSession *captureSession;
@property (nonatomic, retain) AVCaptureDevice *captureDevice;
@property (nonatomic, retain) AVCaptureDeviceInput *captureVideoDeviceInput;
@property (nonatomic, retain) AVCaptureMetadataOutput *metaDataOutput;
@property (nonatomic, retain) AVCaptureVideoDataOutput *captureOutput;
@property (nonatomic, retain) AVCaptureConnection *captureConnection;
@property (nonatomic, retain) AVCaptureVideoPreviewLayer *previewLayer;



@property(retain,readwrite,nonatomic)CALayer *faceLayer;

@property(assign,readwrite,nonatomic)BOOL hasFace;
@property(assign,readwrite,nonatomic)BOOL isShowPic;

@end

@implementation CameralViewController
-(instancetype)initWithBitechSuccess:(void (^)(NSString *filepath))success;
{
    self =[super init];
    _successBlock = success;
    return self;
}
-(void)didReceiveMemoryWarning
{
    [super didReceiveMemoryWarning];
    if ([self.view window] == nil)
    {
        [SVProgressHUD dismiss];
        self.view = nil;
        self.faceLayer=nil;
        self.captureSession=nil;
        _sampleBufferImage=nil;
        self.captureDevice=nil;
        self.captureVideoDeviceInput=nil;
        self.metaDataOutput=nil;
        self.captureOutput=nil;
        self.captureConnection=nil;
        self.previewLayer=nil;
    }
}
- (void)viewDidLoad {
    [super viewDidLoad];
    self.view.backgroundColor=[UIColor blackColor];
    
    _hasFace=NO;
    _isShowPic=NO;
    self.captureSession = [[AVCaptureSession alloc] init];

    struct utsname systemInfo;
    uname(&amp;systemInfo);
    NSString *deviceModel = [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding];
    if ([deviceModel isEqualToString:@"iPhone9,1"] || [deviceModel isEqualToString:@"iPhone9,2"] || [deviceModel isEqualToString:@"iPhone9,3"] || [deviceModel isEqualToString:@"iPhone9,4"]){
        self.captureSession.sessionPreset = AVCaptureSessionPreset352x288;
    } else {
        self.captureSession.sessionPreset = AVCaptureSessionPresetMedium;
    }

    self.captureDevice = [self cameroWithPosition:AVCaptureDevicePositionFront];
    
    //添加输入
    [self addVideoInput];
    
    //添加输出
    [self addVideoOutput];
    
    //添加预览图层
    [self addPreviewLayer];
    
    [self.captureSession commitConfiguration];
    [self.captureSession startRunning];
}


//获取可用的摄像头
- (AVCaptureDevice *)cameroWithPosition:(AVCaptureDevicePosition)position{
    
    if (@available(iOS 10.2, *)) {
        AVCaptureDeviceDiscoverySession *dissession = [AVCaptureDeviceDiscoverySession discoverySessionWithDeviceTypes:@[AVCaptureDeviceTypeBuiltInDualCamera,AVCaptureDeviceTypeBuiltInTelephotoCamera,AVCaptureDeviceTypeBuiltInWideAngleCamera] mediaType:AVMediaTypeVideo position:position];
        for (AVCaptureDevice *device in dissession.devices) {
            if ([device position] == position ) {
                return device;
            }
        }
    } else {
        NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo];
        for (AVCaptureDevice *device in devices) {
            if ([device position] == position) {
                return device;
            }
        }
    }
    return nil;
}


- (void)addVideoInput
{
    NSError *error;
    self.captureVideoDeviceInput = [AVCaptureDeviceInput deviceInputWithDevice:self.captureDevice error:&amp;error];
    if (error) {
        return;
    }
    if ([self.captureSession canAddInput:self.captureVideoDeviceInput]) {
        [self.captureSession addInput:self.captureVideoDeviceInput];
    }
}

- (void)addVideoOutput
{
    self.metaDataOutput = [[AVCaptureMetadataOutput alloc] init];
    [self.metaDataOutput setMetadataObjectsDelegate:self queue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)];
    self.captureOutput=[[AVCaptureVideoDataOutput alloc] init];
    [self.captureOutput setSampleBufferDelegate:self queue:dispatch_queue_create("sample",NULL)];
    if ([self.captureSession canAddOutput:self.metaDataOutput]) {
        [self.captureSession addOutput:self.metaDataOutput];
    }
    if ([self.captureSession canAddOutput:self.captureOutput]) {
        [self.captureSession addOutput:self.captureOutput];
    }
    
    self.metaDataOutput.metadataObjectTypes =  @[AVMetadataObjectTypeFace];
    NSString     *key           = (NSString *)kCVPixelBufferPixelFormatTypeKey;
    NSNumber     *value         = [NSNumber numberWithUnsignedInt:kCVPixelFormatType_32BGRA];
    NSDictionary *videoSettings = [NSDictionary dictionaryWithObject:value forKey:key];
    
    [self.captureOutput setVideoSettings:videoSettings];
    
    //设置链接管理对象
    self.captureConnection = [self.metaDataOutput connectionWithMediaType:AVMediaTypeVideo];
    //视频旋转方向设置
    self.captureConnection.videoScaleAndCropFactor = self.captureConnection.videoMaxScaleAndCropFactor;;
    if ([self.captureConnection isVideoOrientationSupported]){
        
        [self.captureConnection setVideoOrientation:AVCaptureVideoOrientationPortrait];
        
    }
    //视频稳定设置
    if ([self.captureConnection isVideoStabilizationSupported]) {
        self.captureConnection.preferredVideoStabilizationMode = AVCaptureVideoStabilizationModeOff;
    }
}

- (void)addPreviewLayer
{
    self.previewLayer = [AVCaptureVideoPreviewLayer layerWithSession:self.captureSession];
    [self.previewLayer setVideoGravity:AVLayerVideoGravityResizeAspect];
    self.previewLayer.frame = CGRectMake(0, 200, self.view.frame.size.width, self.view.frame.size.width);
    [self.view.layer addSublayer:self.previewLayer];
    
    self.view.backgroundColor = [UIColor whiteColor];
    
    UIImageView *imageView=[[UIImageView alloc]initWithFrame:CGRectMake(0, 100,self.view.frame.size.width, self.view.frame.size.width *1.3)];
    imageView.image=[UIImage imageNamed:@"facecameral.png"];
    [self.view addSubview:imageView];
    
    
    UIButton *button1=[[UIButton alloc]initWithFrame:CGRectMake(self.view.frame.size.width-60, 30, 50, 40)];
    [button1 setTitle:@"关闭" forState:UIControlStateNormal];
    button1.titleLabel.font = [UIFont systemFontOfSize:14];
    [button1 setTitleColor:[UIColor blackColor]forState:UIControlStateNormal];
    [button1 addTarget:self action:@selector(closeCameral) forControlEvents:UIControlEventTouchUpInside];
    [self.view addSubview:button1];

    UIButton *button=[[UIButton alloc]initWithFrame:CGRectMake(self.view.frame.size.width/2-60, self.view.frame.size.height -100, 120, 50)];
    [button setBackgroundColor:[UIColor colorWithRed:(CGFloat)51/255.0 green:155/255.0 blue:211/255.0 alpha:1]];
    button.layer.cornerRadius= 5;
    button.layer.masksToBounds=YES;
    [button setTitle:@"采集本人人脸" forState:UIControlStateNormal];
    button.titleLabel.font = [UIFont systemFontOfSize:12];
    [button addTarget:self action:@selector(cameralClick) forControlEvents:UIControlEventTouchUpInside];
    [self.view addSubview:button];
    
    
}
-(void)closeCameral{
    [self.navigationController popViewControllerAnimated:YES];
}
-(void)cameralClick{
    [self sureClick];
}
-(void)cancelClick{
    _isShowPic=NO;
}
-(void)sureClick{
    //转换成UIImage
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSData *imageData = UIImagePNGRepresentation(_sampleBufferImage);
        NSString *imageBase64Str = [imageData base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];
        _successBlock(imageBase64Str);//图片base64串
    });
    [self closeCameral];
}

- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection
{
    _sampleBufferImage = [self getImageBySampleBufferref:sampleBuffer];
}
// 将获取的数据转换成图片，网上很多转换方式转出来的图片都是错误的，最后找到这个方法

- (UIImage *)getImageBySampleBufferref:(CMSampleBufferRef)sampleBuffer

{
    CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);
    CVPixelBufferLockBaseAddress(imageBuffer,0);
    uint8_t *baseAddress = (uint8_t *)CVPixelBufferGetBaseAddress(imageBuffer);
    size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);
    size_t width = CVPixelBufferGetWidth(imageBuffer);
    size_t height = CVPixelBufferGetHeight(imageBuffer);
    
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef newContext = CGBitmapContextCreate(baseAddress, width, height, 8, bytesPerRow, colorSpace,                                                  kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);
    
    CGImageRef newImage = CGBitmapContextCreateImage(newContext);
    
    CGContextRelease(newContext);
    CGColorSpaceRelease(colorSpace);
    
    UIImage *image= [UIImage imageWithCGImage:newImage scale:1.0 orientation:UIImageOrientationLeftMirrored];
    // release
    CGImageRelease(newImage);
    
    return image;
    
}


- (void)dismiss {
    [SVProgressHUD dismiss];
}

@end

</code></pre> 
<p><img src="https://images2.imgbox.com/6d/01/3MXekMrr_o.png" alt="1"></p> 
<h6><a id="38_1763"></a>38、上架审核检测国外外网是否能访问</h6> 
<p><a href="https://www.webpagetest.org/" rel="nofollow">https://www.webpagetest.org/</a><br> <a href="https://www.36ce.net" rel="nofollow">https://www.36ce.net</a><br> <a href="https://tools.pingdom.com/#62b416cf03000000" rel="nofollow">https://tools.pingdom.com/#62b416cf03000000</a><br> <a href="http://17ce.com" rel="nofollow">http://17ce.com</a><br> 持续更新中…</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/931059c231eec7d0c928caa2c633226b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring MVC 之 Restful 风格请求⽀持</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/86010bef4a6ef11b6a07ba939578237f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">多线程《1》JMM基础知识---volatile的可见性和一致性</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>