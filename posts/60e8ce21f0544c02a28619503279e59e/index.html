<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>50个C/C&#43;&#43;面试题 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="50个C/C&#43;&#43;面试题" />
<meta property="og:description" content="面试题1：变量的声明和定义有什么区别 为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，但是只在一个地方定义。加入extern修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。 说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。 面试题2：写出bool 、int、 float、指针变量与“零值”比较的if语句 bool型数据： if( flag ) { A; } else { B； } int型数据： if( 0 != flag ) { A; } else { B； } 指针型数： if( NULL == flag ) { A; } else { B； } float型数据： if ( ( flag &gt;= NORM ) &amp;&amp; ( flag &lt;= NORM ) ) { A； } 注意：应特别注意在int、指针型变量和“零值”比较的时候，把“零值”放在左边，这样当把“==”误写成“=”时，编译器可以报错，否则这种逻辑错误不容易发现，并且可能导致很严重的后果。 面试题3：sizeof和strlen的区别 sizeof和strlen有以下区别： sizeof是一个操作符，strlen是库函数。 sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为‘\0‘的字符串作参数。  编译器在编译时就计算出了sizeof的结果。而strlen函数必须在运行时才能计算出来。并且sizeof
计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。  数组做sizeof的参数不退化，传递给strlen就退化为指针了。 注意：有些是操作符看起来像是函数，而有些函数名看起来又像操作符，这类容易混淆的名称一定要加以区分，否则遇到数组名这类特殊数据类型作参数时就很容易出错。最容易混淆为函数的操作符就是sizeof。 面试题4：C语言的关键字 static 和 C&#43;&#43; 的关键字 static 有什么区别 在C中static用来修饰局部静态变量和外部静态变量、函数。而C&#43;&#43;中除了上述功能外，还用来定义类的成员变量和函数。即静态成员和静态成员函数。 注意：编程时static的记忆性，和全局性的特点可以让在不同时期调用的函数进行通信，传递信息，而C&#43;&#43;的静态成员则可以在多个对象实例间进行通信，传递信息。 面试题5：Ｃ中的malloc和Ｃ＋＋中的new有什么区别 malloc和new有以下不同： （1）new、delete 是操作符，可以重载，只能在C&#43;&#43;中使用。 （2）malloc、free是函数，可以覆盖，C、C&#43;&#43;中都可以使用。 （3）new 可以调用对象的构造函数，对应的delete调用相应的析构函数。 （4）malloc仅仅分配内存，free仅仅回收内存，并不执行构造和析构函数 （5）new、delete返回的是某种数据类型指针，malloc、free返回的是void指针。 注意：malloc申请的内存空间要用free释放，而new申请的内存空间要用delete释放，不要混用。因为两者实现的机理不同。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/60e8ce21f0544c02a28619503279e59e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-04-11T22:14:33+08:00" />
<meta property="article:modified_time" content="2015-04-11T22:14:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">50个C/C&#43;&#43;面试题</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="font-family:Microsoft YaHei; font-size:18px; color:#000099"><strong>面试题1：变量的声明和定义有什么区别 </strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，但是只在一个地方定义。加入extern修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。 </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>说明：</strong>很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><span style="font-size:18px; color:#000099"><strong>面试题2：写出bool 、int、 float、指针变量与“零值”比较的if语句 </strong></span></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>bool型数据： </strong></span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">if( flag ) {  A; } else {  B； } </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>int型数据：</strong> </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">if( 0 != flag ) {  A; } else {  B； } </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>指针型数：</strong> </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">if( NULL == flag ) {  A; } else {  B； } </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>float型数据：</strong> </span><br> <span style="font-size:14px">if ( ( flag &gt;= NORM ) &amp;&amp; ( flag &lt;= NORM ) ) {  A； </span><br> <br> <span style="font-size:14px">} </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>注意：</strong>应特别注意在int、指针型变量和“零值”比较的时候，把“零值”放在左边，这样当把“==”误写成“=”时，编译器可以报错，否则这种逻辑错误不容易发现，并且可能导致很严重的后果。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><span style="font-size:18px; color:#000099"><strong>面试题3：sizeof和strlen的区别 </strong></span></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">sizeof和strlen有以下区别： </span><br> <span style="font-size:14px">sizeof是一个操作符，strlen是库函数。 </span><br> <span style="font-size:14px">sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为‘\0‘的字符串作参数。  编译器在编译时就计算出了sizeof的结果。而strlen函数必须在运行时才能计算出来。并且sizeof</span><br> <span style="font-size:14px">计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。  数组做sizeof的参数不退化，传递给strlen就退化为指针了。 </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>注意：</strong>有些是操作符看起来像是函数，而有些函数名看起来又像操作符，这类容易混淆的名称一定要加以区分，否则遇到数组名这类特殊数据类型作参数时就很容易出错。最容易混淆为函数的操作符就是sizeof。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><span style="font-size:18px; color:#000099"><strong>面试题4：C语言的关键字 static 和 C++ 的关键字 static 有什么区别 </strong></span></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">在C中static用来修饰局部静态变量和外部静态变量、函数。而C++中除了上述功能外，还用来定义类的成员变量和函数。即静态成员和静态成员函数。 </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>注意：</strong>编程时static的记忆性，和全局性的特点可以让在不同时期调用的函数进行通信，传递信息，而C++的静态成员则可以在多个对象实例间进行通信，传递信息。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><span style="font-size:18px; color:#000099">面试题5：Ｃ中的malloc和Ｃ＋＋中的new有什么区别</span><span style="font-size:14px"> </span></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">malloc和new有以下不同： </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">（1）new、delete 是操作符，可以重载，只能在C++中使用。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">（2）malloc、free是函数，可以覆盖，C、C++中都可以使用。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">（3）new 可以调用对象的构造函数，对应的delete调用相应的析构函数。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">（4）malloc仅仅分配内存，free仅仅回收内存，并不执行构造和析构函数 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">（5）new、delete返回的是某种数据类型指针，malloc、free返回的是void指针。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>注意：</strong>malloc申请的内存空间要用free释放，而new申请的内存空间要用delete释放，不要混用。因为两者实现的机理不同。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><span style="font-size:18px; color:#000099"><strong>面试题6：写一个“标准”宏MIN </strong></span></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">#define min(a,b)((a)&lt;=(b)?(a):(b)) </span><br> <span style="font-size:14px"><strong>注意：</strong>在调用时一定要注意这个宏定义的副作用，如下调用：  </span><br> <span style="font-size:14px">((++*p)&lt;=(x)?(++*p):(x)。 </span><br> <span style="font-size:14px">p指针就自加了两次，违背了MIN的本意。 </span><br> <br> <br> </span> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题7：一个指针可以是volatile吗 </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">可以，因为指针和普通变量一样，有时也有变化程序的不可控性。常见例：子中断服务子程序修改一个指向一个buffer的指针时，必须用volatile来修饰这个指针。 </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>说明：</strong>指针是一种普通的变量，从访问上没有什么不同于其他变量的特性。其保存的数值是个整型数据，和整型变量不同的是，这个整型数据指向的是一段内存地址。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><span style="font-size:18px; color:#000099"><strong>面试题8：a和&amp;a有什么区别 </strong></span></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">请写出以下代码的打印结果，主要目的是考察a和&amp;a的区别。 </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">#include&lt;stdio.h&gt; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">void main( void ) </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">{  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>int a[5]={1,2,3,4,5};  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>int *ptr=(int *)(&amp;a+1);   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>printf("%d,%d",*(a+1),*(ptr-1));  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>return; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">} </span></span></p> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px"> </span><br> <span style="font-size:14px">输出结果：2，5。 </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>注意：</strong>数组名a可以作数组的首地址，而&amp;a是数组的指针。思考，将原式的int *ptr=(int *)(&amp;a+1);改为int *ptr=(int *)(a+1);时输出结果将是什么呢？ </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题9：简述C、C++程序编译的内存分配情况 </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">C、C++中内存分配方式可以分为三种： </span><br> <span style="font-size:14px">（1）从静态存储区域分配： </span><br> <span style="font-size:14px"><span style="white-space:pre"></span>内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。速度快、不容易出错，因为有系统会善后。例如全<span style="white-space:pre"></span>局变量，static变量等。 </span><br> <span style="font-size:14px">（2）在栈上分配： </span><br> <span style="font-size:14px"><span style="white-space:pre"></span>在执行函数时，函数内局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于<span style="white-space:pre"></span>处理器的指令集中，效率很高，但是分配的内存容量有限。 </span><br> <span style="font-size:14px">（3）从堆上分配： </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>即动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在何时用free或delete释放内存。<span style="white-space:pre"></span>动态内存的生存期由程序员决定，使用非常灵活。如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄<span style="white-space:pre"></span>漏，另外频繁地分配和释放不同大小的堆空间将会产生堆内碎块。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>一个C、C++程序编译时内存分为5大存储区：堆区、栈区、全局区、文字常量区、程序代码区。 </span><br> <span style="font-size:14px"> </span><br> </span> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题10：简述strcpy、sprintf与memcpy的区别</span></strong><span style="font-size:14px"> </span></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">三者主要有以下不同之处： </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">（1）操作对象不同，strcpy的两个操作对象均为字符串，sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串，<span style="white-space:pre"></span>memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">（2）执行效率不同，memcpy最高，strcpy次之，sprintf的效率最低。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">（3）实现功能不同，strcpy主要实现字符串变量间的拷贝，sprintf主要实现其他数据类型格式到字符串的转化，memcpy主要是内<span style="white-space:pre"></span>存块间的拷贝。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>说明：</strong>strcpy、sprintf与memcpy都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来选择合适的函数实现拷贝功能。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题11：设置地址为0x67a9的整型变量的值为0xaa66 </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">int *ptr;  </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">ptr = (int *)0x67a9;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">*ptr = 0xaa66;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>说明：</strong>这道题就是强制类型转换的典型例子，无论在什么平台地址长度和整型数据的长度是一样的，即一个整型数据可以强制转换成地址指针类型，只要有意义即可。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题12：面向对象的三大特征 </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">面向对象的三大特征是封装性、继承性和多态性： </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>封装性：</strong>将客观事物抽象成类，每个类对自身的数据和方法实行protection（private， protected，public）。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>继承性：</strong>广义的继承有三种实现形式：实现继承（使用基类的属性和方法而无需额外编码的能力)、可</span></span></p> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>     视继承(子窗体使用父窗体的外观和实现代码)、接口继承(仅使用属性和方法,实现滞后到子类实现)。 </span><br> <span style="font-size:14px"><strong>多态性：</strong>是将父类对象设置成为和一个或更多它的子对象相等的技术。用子类对象给父类对象赋值</span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">             之后，父类对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>说明：</strong>面向对象的三个特征是实现面向对象技术的关键，每一个特征的相关技术都非常的复杂，程序员应该多看、多练。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><span style="font-size:18px; color:#000099"><strong>面试题13：C++的空类有哪些成员函数 </strong></span></span></h2> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">缺省构造函数。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">缺省拷贝构造函数。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">缺省析构函数。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">缺省赋值运算符。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">缺省取址运算符。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">缺省取址运算符 const。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> </span></span></p> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>注意：</strong>有些书上只是简单的介绍了前四个函数。没有提及后面这两个函数。但后面这两个函数也是空类的默认函数。另外需要注意的是，只有当实际使用这些函数的时候，编译器才会去定义它们。 </span><br> <br> </span> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题14：谈谈你对拷贝构造函数和赋值运算符的认识 </span></strong></span></h2> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">拷贝构造函数和赋值运算符重载有以下两个不同之处： </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">（1）拷贝构造函数生成新的类对象，而赋值运算符不能。 </span></span></p> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">（2）由于拷贝构造函数是直接构造一个新的类对象，所以在初始化这个对象之前不用检验源对象是否和新建对象相同。而赋值运算<span style="white-space:pre"></span>符则需要这个操作，另外赋值运算中如果原来的对象中有内存分配要先把内存释放掉 </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>注意：</strong>当有类中有指针类型的成员变量时，一定要重写拷贝构造函数和赋值运算符，不要使用默认的。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题15：用C++设计一个不能被继承的类 </span></strong></span></h2> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">template &lt;typename T&gt; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">class A </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">{  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">friend T; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">private:  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>A() {}  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>~A() {} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">};  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">class B : virtual public A&lt;B&gt; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">{ </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">public:  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>B() {}  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>~B() {} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">}; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">class C : virtual public B </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">{ </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">public:  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>C() {}  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>~C() {} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">}; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">void main( void ) </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">{  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>B b;  //C c;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>return; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>注意：</strong>构造函数是继承实现的关键，每次子类对象构造时，首先调用的是父类的构造函数，然后才是自己的。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题16：访问基类的私有虚函数 </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px"></span></span> 
<span style="font-family:Microsoft YaHei; font-size:14px">写出以下程序的输出结果： <br> </span> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">#include &lt;iostream.h&gt; </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">class A </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">{  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>virtual void g()  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>cout &lt;&lt; "A::g" &lt;&lt; endl;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">private:  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>virtual void f()  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>cout &lt;&lt; "A::f" &lt;&lt; endl;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">}; </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">class B : public A</span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> {  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>void g()  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>cout &lt;&lt; "B::g" &lt;&lt; endl;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>}  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>virtual void h()  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>cout &lt;&lt; "B::h" &lt;&lt; endl;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">}; </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">typedef void( *Fun )( void ); </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">void main() </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">{  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>B b;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>Fun pFun;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>for(int i = 0  i &lt; 3; i++)  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>pFun = ( Fun )*( ( int* ) * ( int* )( &amp;b ) + i );   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>pFun();  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>}  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">} </span></p> 
<span style="font-family:Microsoft YaHei; font-size:14px"> <br> 输出结果： <br> B::g A::f B::h <br> </span> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><strong>注意：</strong>本题主要考察了面试者对虚函数的理解程度。一个对虚函数不了解的人很难正确的做出本题。在学习面向对象的多态性时一定要深刻理解虚函数表的工作原理。 </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> </span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题17：简述类成员函数的重写、重载和隐藏的区别 </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">（1）重写和重载主要有以下几点不同。 </span><br> <span style="font-size:14px"><strong>范围的区别：</strong>被重写的和重写的函数在两个类中，而重载和被重载的函数在同一个类中。 </span><br> <span style="font-size:14px"><strong>参数的区别：</strong>被重写函数和重写函数的参数列表一定相同，而被重载函数和重载函数的参数列表一定不同。 </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>virtual的区别：</strong>重写的基类中被重写的函数必须要有virtual修饰，而重载函数和被重载函数可以被</span><span style="font-size:14px">virtual修饰，也可以没有。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> </span></span></p> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">（2）隐藏和重写、重载有以下几点不同。 </span><br> <span style="font-size:14px"><strong>与重载的范围不同：</strong>和重写一样，隐藏函数和被隐藏函数不在同一个类中。 </span><br> <span style="font-size:14px"><strong>参数的区别：</strong>隐藏函数和被隐藏的函数的参数列表可以相同，也可不同，但是函数名肯定要相同。</span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">当参数不相同时，无论基类中的参数是否被virtual修饰，基类的函数都是被隐藏，而不是被重写。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong><br> </strong></span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>说明：</strong>虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完全不同的，覆盖是动态态绑定的多态，而重载是静态绑定的多态。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题18：简述多态实现的原理 </span></strong></span></h2> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">编译器发现一个类中有虚函数，便会立即为此类生成虚函数表 vtable。虚函数表的各表项为指向对应虚函数的指针。编译器还会在此类中隐含插入一个指针vptr（对vc编译器来说，它插在类的第一个位置上）指向虚函数表。调用此类的构造函数时，在类的构造函数中，编译器会隐含执行vptr与vtable的关联代码，将vptr指向对应的vtable，将类与此类的vtable联系了起来。另外在调用类的构造函数时，指向基础类的指针此时已经变成指向具体的类的this指针，这样依靠此this指针即可得到正确的vtable，。如此才能真正与函数体进行连接，这就是动态联编，实现多态的基本原理。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>注意：</strong>一定要区分虚函数，纯虚函数、虚拟继承的关系和区别。牢记虚函数实现原理，因为多态C++面试的重要考点之一，而虚函数是实现多态的基础。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><span style="font-size:18px; color:#000099"><strong>面试题19：链表和数组有什么区别 </strong></span></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">数组和链表有以下几点不同： </span><br> <span style="font-size:14px">（1）存储形式：数组是一块连续的空间，声明时就要确定长度。链表是一块可不连续的动态空间，长度可变，每个结点要保存相邻<span style="white-space:pre"></span>结点指针。 </span><br> <span style="font-size:14px">（2）数据查找：数组的线性查找速度快，查找操作直接使用偏移地址。链表需要按顺序检索结点，效率低。 </span><br> <span style="font-size:14px">（3）数据插入或删除：链表可以快速插入和删除结点，而数组则可能需要大量数据移动。 </span><br> <span style="font-size:14px">（4）越界问题：链表不存在越界问题，数组有越界问题。 </span><br> <span style="font-size:14px"><strong>说明：</strong>在选择数组或链表数据结构时，一定要根据实际需要进行选择。数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间。 </span></span> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题20：怎样把一个单链表反序 </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei; font-size:14px">（1）反转一个链表。循环算法。 <br> List reverse(List   n)  </span> 
<p></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">{  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>if(!n)       //判断链表是否为空，为空即退出。 <br>  <span style="white-space:pre"> </span>{  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>return n;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br>  <span style="white-space:pre"> </span>list cur = n.next;  //保存头结点的下个结点   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>list pre = n;     //保存头结点 <br>  <span style="white-space:pre"> </span>list tmp;<br>  <span style="white-space:pre"> </span>pre.next = null;     //头结点的指针指空，转换后变尾结点  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>while ( NULL != cur.next )   //循环直到</span><span style="font-family:'Microsoft YaHei'; font-size:14px">cur.next为空  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>tmp = cur;  //实现如图10.3—图10.5所示 <br>   <span style="white-space:pre"></span>tmp.next = pre     <br> <span style="white-space:pre"></span>pre = tmp; <br>    <span style="white-space:pre"> </span>cur = cur.next;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br>  <span style="white-space:pre"> </span>return tmp;   //f返回头指针 <br> } <br> （2）反转一个链表。递归算法。 <br> List *reverse( List *oldList, List *newHead = NULL )  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">{  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>List *next = oldList-&gt; next;   //记录上次翻转后的链表  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>oldList-&gt; next = newHead;   //将当前结点插入到翻转后链表的开头  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>newHead = oldList;     //递归处理剩余的链表   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>return ( next==NULL )? newHead: reverse( t, newHead );  <br> } </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> <strong>说明：</strong>循环算法就是图10.2—图10.5的移动过程，比较好理解和想到。递归算法的设计虽有一点难度，但是理解了循环算法，再设计递归算法就简单多了。 </span></p> 
<p><span style="font-family:Microsoft YaHei"><br> </span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题 21：简述队列和栈的异同 </span></strong></span></h2> 
<p></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是“后进先出”。 <br> <strong>注意：</strong>区别栈区和堆区。堆区的存取是“顺序随意”，而栈区是“后进先出”。栈由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。分配方式类似于链表。 <br> 它与本题中的堆和栈是两回事。堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域。 </span></p> 
<p><span style="font-family:Microsoft YaHei"><br> </span></p> 
<h2><span style="font-family:Microsoft YaHei"><span style="font-size:18px; color:#000099">面试题22：能否用两个栈实现一个队列的功能</span><span style="font-size:14px"> </span></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">结点结构体： </span><br> <span style="font-size:14px">typedef struct node </span></span> 
<p></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">{  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>int data;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>node *next; </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">}node,*LinkStack; </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> 创建空栈： <br> LinkStack CreateNULLStack( LinkStack &amp;S) </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">{  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>S = (LinkStack)malloc( sizeof( node ) );     //申请新结点 <br>  <span style="white-space:pre"> </span>if( NULL == S) <br>  <span style="white-space:pre"> </span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>printf("Fail to malloc a new node.\n"); <br>   <span style="white-space:pre"></span>return NULL; <br> <span style="white-space:pre"></span> } </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br>   <span style="white-space:pre"></span>S-&gt;data = 0;         //初始化新结点 <br>  <span style="white-space:pre"> </span>S-&gt;next = NULL;   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>return S; <br> } <br> 栈的插入函数： <br> LinkStack Push( LinkStack &amp;S, int data) </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">{  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>if( NULL == S)       //检验栈 <br>  <span style="white-space:pre"> </span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>printf("There no node in stack!");   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>return NULL; <br>  <span style="white-space:pre"> </span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br>   <span style="white-space:pre"></span>LinkStack p = NULL; <br>  <span style="white-space:pre"> </span>p = (LinkStack)malloc( sizeof( node ) ); //申请新结点 </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br>  <span style="white-space:pre"> </span>if( NULL == p)  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>printf("Fail to malloc a new node.\n");   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>return S; </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br>  <span style="white-space:pre"> </span>if( NULL == S-&gt;next)  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>p-&gt;next = NULL;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>}  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>else  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>p-&gt;next = S-&gt;next;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br>  <span style="white-space:pre"> </span>p-&gt;data = data;       //初始化新结点  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>S-&gt;next = p;     //插入新结点   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>return S; <br> } <br> 出栈函数： <br> node Pop( LinkStack &amp;S) </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">{  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>node temp;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>temp.data = 0;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>temp.next = NULL;   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>if( NULL == S)       //检验栈 <br>  <span style="white-space:pre"> </span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>printf("There no node in stack!");   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>return temp; </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br>  <span style="white-space:pre"> </span>temp = *S; <br> <br>  <span style="white-space:pre"> </span>if( S-&gt;next == NULL ) </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>printf("The stack is NULL,can't pop!\n");   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>return temp;   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br>   <span style="white-space:pre"></span>LinkStack p = S -&gt;next;  //节点出栈 <br>  <span style="white-space:pre"> </span>S-&gt;next = S-&gt;next-&gt;next;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>temp = *p;   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>free( p );  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>p = NULL;   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>return temp;   <br> } </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> 双栈实现队列的入队函数： <br> LinkStack StackToQueuPush( LinkStack &amp;S, int data)</span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> {  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>node n;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>LinkStack S1 = NULL; </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>CreateNULLStack( S1 );      //创建空栈   <br>  <span style="white-space:pre"> </span>while( NULL != S-&gt;next )   //S出栈入S1 <br>  <span style="white-space:pre"> </span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>n = Pop( S );  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>Push( S1, n.data );  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br>  <span style="white-space:pre"> </span>Push( S1, data );        //新结点入栈 <br>   <span style="white-space:pre"></span>while( NULL != S1-&gt;next )   //S1出栈入S <br>  <span style="white-space:pre"> </span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>n = Pop( S1 );   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>Push( S, n.data ); <br>  <span style="white-space:pre"> </span>} <br>   <span style="white-space:pre"></span>return S; <br> } <br> <strong>说明：</strong>用两个栈能够实现一个队列的功能，那用两个队列能否实现一个队列的功能呢？结果是否定的，因为栈是先进后出，将两个栈连在一起，就是先进先出。而队列是现先进先出，无论多少个连在一起都是先进先出，而无法实现先进后出。 </span></p> 
<p><span style="font-family:Microsoft YaHei"><br> </span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题23：计算一颗二叉树的深度 </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">深度的计算函数： </span><br> <span style="font-size:14px">int depth(BiTree T) </span></span> 
<p></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">{  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>if(!T) </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>return 0;      //判断当前结点是否为叶子结点 <br> <br>  <span style="white-space:pre"> </span>int d1= depth(T-&gt;lchild);    //求当前结点的左孩子树的深度  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>int d2= depth(T-&gt;rchild);  //求当前结点的右孩子树的深度 <br>  <span style="white-space:pre"> </span>return (d1&gt;d2?d1:d2)+1; <br> } <br> <strong>注意：</strong>根据二叉树的结构特点，很多算法都可以用递归算法来实现。 </span><br> </p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> </span></p> 
<p></p> 
<h2><span style="font-family:Microsoft YaHei; font-size:18px; color:#000099"><strong>面试题24：编码实现直接插入排序 </strong></span></h2> 
<span style="font-family:Microsoft YaHei; font-size:14px">直接插入排序编程实现如下： <br> #include&lt;iostream.h&gt; </span> 
<p></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">void main( void ) </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">{  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>int ARRAY[10] = { 0, 6, 3, 2, 7, 5, 4, 9, 1, 8 };   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>int i,j;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>for(  i = 0; i &lt; 10; i++)  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>cout&lt;&lt;ARRAY[i]&lt;&lt;" "; </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>}   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>cout&lt;&lt;endl;   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>for( i = 2; i &lt;= 10; i++ )    //将ARRAY[2],…,ARRAY[n]依次按序插入  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>{      </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>if(ARRAY[i] &lt; ARRAY[i-1])   //如果ARRAY[i]大于一切有序的数值，          //ARRAY[i]将保持原位不动 <br>   <span style="white-space:pre"></span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>ARRAY[0] = ARRAY[i];  //将ARRAY[0]看做是哨兵,是ARRAY[i]的副本 <br>    <span style="white-space:pre"> </span>j = i - 1; <br>     <span style="white-space:pre"></span>do</span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>{      //从右向左在有序区ARRAY[1．．i-1]中          //查找ARRAY[i]的插入位置 <br>    <span style="white-space:pre"> </span>ARRAY[j+1] = ARRAY[j];  //将数值大于ARRAY[i]记录后移    </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>j--;  <br>    <span style="white-space:pre"> </span>}</span><span style="font-family:'Microsoft YaHei'; font-size:14px">while( ARRAY[0] &lt; ARRAY[j] );     </span></p> 
<p><span style="font-family:'Microsoft YaHei'; font-size:14px"><br> </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>ARRAY[j+1]=ARRAY[0];  //ARRAY[i]插入到正确的位置上 <br>   <span style="white-space:pre"></span>} <br>  <span style="white-space:pre"> </span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br>   <span style="white-space:pre"></span>for(  i = 0; i &lt; 10; i++) <br>  <span style="white-space:pre"> </span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>cout&lt;&lt;ARRAY[i]&lt;&lt;" "; </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>cout&lt;&lt;endl; <br> }<br> <strong>注意：</strong>所有为简化边界条件而引入的附加结点（元素）均可称为哨兵。引入哨兵后使得查找循环条件的时间大约减少了一半，对于记录数较大的文件节约的时间就相当可观。类似于排序这样使用频率非常高的算法，要尽可能地减少其运行时间。所以不能把上述算法中的哨兵视为雕虫小技。<br> </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> </span></p> 
<p></p> 
<h2><span style="font-family:Microsoft YaHei; font-size:18px; color:#000099"><strong>面试题25：编码实现冒泡排序 </strong></span></h2> 
<span style="font-family:Microsoft YaHei; font-size:14px">冒泡排序编程实现如下： <br> #include &lt;stdio.h&gt; </span> 
<p></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">#define LEN 10   <br>  <br> //数组长度 <br> void main( void ) </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">{  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>int ARRAY[10] = { 0, 6, 3, 2, 7, 5, 4, 9, 1, 8 }; //待排序数组  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>printf( "\n" ); <br>  <span style="white-space:pre"> </span>for( int a = 0; a &lt; LEN; a++ ) //打印数组内容 <br>  <span style="white-space:pre"> </span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>printf( "%d ", ARRAY[a] );  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br>  <span style="white-space:pre"> </span>int i = 0;  int j = 0; <br>  <span style="white-space:pre"> </span>bool isChange;       //设定交换标志 <br>  <span style="white-space:pre"> </span>for( i = 1; i &lt; LEN; i++ )  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>{         //最多做LEN-1趟排序 <br>  <span style="white-space:pre"> </span>isChange = 0;      //本趟排序开始前,交换标志应为假 <br>   <span style="white-space:pre"></span>for( j = LEN-1; j &gt;= i; j-- )   //对当前无序区ARRAY[i..LEN]自下向上扫描 <br>   <span style="white-space:pre"></span>{    </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>if( ARRAY[j+1] &lt; ARRAY[j] )     </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>{       //交换记录 <br>     <span style="white-space:pre"></span>ARRAY[0] = ARRAY[j+1];  //ARRAY[0]不是哨兵,仅做暂存单元 <br>    <span style="white-space:pre"> </span>ARRAY[j+1] = ARRAY[j];     </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>ARRAY[j] = ARRAY[0];    <br> <span style="white-space:pre"></span>isChange = 1;    //发生了交换,故将交换标志置为真 <br>    <span style="white-space:pre"> </span>}   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br>   <span style="white-space:pre"></span>printf( "\n" ); <br>   <span style="white-space:pre"></span>for( a = 0; a &lt; LEN; a++)  //打印本次排序后数组内容 <br>   <span style="white-space:pre"></span>{    </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>printf( "%d ", ARRAY[a] );   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>} <br>   <br> <span style="white-space:pre"></span>if( !isChange )     //本趟排序未发生交换,提前终止算法 <br>   <span style="white-space:pre"></span>{    </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>break;   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>}  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>}  <br>  <span style="white-space:pre"> </span>printf( "\n" );  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>return; <br> } <br> </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> </span></p> 
<p></p> 
<h2><span style="font-family:Microsoft YaHei"><span style="font-size:18px; color:#000099"><strong>面试题26：编码实现直接选择排序 </strong></span></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">#include"stdio.h" </span></span> 
<p></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">#define LEN 9 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">void main( void ) </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">{  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>int ARRAY[LEN]={ 5, 6, 8, 2, 4, 1, 9, 3, 7 };   //待序数组 </span><br> <span style="font-size:14px">  <span style="white-space:pre"></span>printf("Before sorted:\n"); </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>for( int m = 0; m &lt; LEN; m++ )      //打印排序前数组 </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>printf( "%d  ", ARRAY[m] );  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br>  <span style="white-space:pre"> </span>for (int i = 1; i &lt;= LEN - 1; i++)  </span><span style="font-size:14px">//选择排序 </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>int t = i - 1;    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>int temp = 0;    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>for (int j = i; j &lt; LEN; j++)    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>if (ARRAY[j] &lt; ARRAY[t])   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{      </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>t = j;    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> <span style="white-space:pre"></span>}   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> <span style="white-space:pre"></span>}    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>if (t != (i - 1))   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> <span style="white-space:pre"></span>temp = ARRAY[i - 1];    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>ARRAY[i - 1] = ARRAY[t];    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>ARRAY[t] = temp;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> <span style="white-space:pre"></span>}  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>} </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>printf( "\n" ); </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>printf("After sorted:\n");  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>for( i = 0; i &lt; LEN; i++ )       //打印排序后数组 </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>printf( "%d  ", ARRAY[i] );  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>} </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>printf( "\n" ); </span><br> <span style="font-size:14px">} </span><br> <span style="font-size:14px"><strong>注意：</strong>在直接选择排序中，具有相同关键码的对象可能会颠倒次序，因而直接选择排序算法是一种不稳定的排序方法。在本例中只是例举了简单的整形数组排序，肯定不会有什么问题。但是在复杂的数据元素序列组合中，只是根据单一的某一个关键值排序，直接选择排序则不保证其稳定性，这是直接选择排序的一个弱点</span><br> </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> </span></p> 
<p></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题27：编程实现堆排序 </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">堆排序编程实现： </span><br> <span style="font-size:14px">#include &lt;stdio.h&gt; </span><br> <span style="font-size:14px">void createHeep(int ARRAY[],int sPoint, int Len)  </span><span style="font-size:14px">//生成大根堆 </span><br> <span style="font-size:14px">{  </span></span> 
<p></p> 
<p><span style="font-size:14px; font-family:'Microsoft YaHei'"><span style="white-space:pre"></span>while( ( 2 * sPoint + 1 ) &lt; Len )  </span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>int mPoint = 2 * sPoint + 1;    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>if( ( 2 * sPoint + 2 ) &lt; Len )   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{     </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>if(ARRAY[ 2 * sPoint + 1 ] &lt; ARRAY[ 2 * sPoint + 2 ] )    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{     </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>mPoint = 2*sPoint+2;    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>}   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>}   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>if(ARRAY[ sPoint ] &lt; ARRAY[ mPoint ])   //堆被破坏，需要重新调整   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>int tmpData= ARRAY[ sPoint ];  </span><span style="font-size:14px">//交换sPoint与mPoint的数据 </span><br> <span style="font-size:14px">   <span style="white-space:pre"> </span>ARRAY[ sPoint ] = ARRAY[ mPoint ];    </span><br> <span style="font-size:14px"><span style="white-space:pre"></span>ARRAY[ mPoint ] = tmpData; </span><br> <span style="font-size:14px">    <span style="white-space:pre"></span>sPoint = mPoint     </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>} </span><br> <span style="font-size:14px">  <span style="white-space:pre"></span>else     </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{  </span><br> <br> <span style="font-size:14px"> <span style="white-space:pre"> </span>break;   </span><span style="font-size:14px">//堆未破坏，不再需要调整  </span><br> <span style="font-size:14px">  <span style="white-space:pre"></span>} </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>}  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>return; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">}   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> void heepSort( int ARRAY[], int Len )      //堆排序 </span><br> <span style="font-size:14px">{  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>int i=0; </span><br> <span style="font-size:14px">  <span style="white-space:pre"></span>for ( i = ( Len / 2 - 1 ); i &gt;= 0; i-- )     //将Hr[0，Lenght-1]建成大根堆 </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>createHeep(ARRAY, i, Len);  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br>  <span style="white-space:pre"> </span>for ( i = Len - 1; i &gt; 0; i-- )  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>int tmpData = ARRAY[0];      //与最后一个记录交换 </span><br> <span style="font-size:14px">  <span style="white-space:pre"></span>ARRAY[0] = ARRAY[i];   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>ARRAY[i] = tmpData;   </span><br> <span style="font-size:14px"><span style="white-space:pre"></span>createHeep( ARRAY, 0, i ); </span><span style="font-size:14px">//将H.r[0..i]重新调整为大根堆   </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>}   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>return; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">}  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> int main( void ) </span><br> <span style="font-size:14px">{  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>int ARRAY[] ={ 5, 4, 7, 3, 9, 1, 6, 8, 2};   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>printf("Before sorted:\n");   </span><span style="font-size:14px">//打印排序前数组内容 </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>for ( int i = 0; i &lt; 9; i++ )  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>printf("%d ", ARRAY[i]);  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>} </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>printf("\n"); </span><br> <span style="font-size:14px">  <span style="white-space:pre"></span>heepSort( ARRAY, 9 );       //堆排序 </span><br> <span style="font-size:14px">  </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>printf("After sorted:\n"); //打印排序后数组内容 </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>for( i = 0; i &lt; 9; i++ )  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>printf( "%d ", ARRAY[i] );   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>} </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>printf( "\n" );  return 0; </span><br> <span style="font-size:14px">} </span><br> <span style="font-size:14px"><strong>说明：</strong>堆排序，虽然实现复杂，但是非常的实用。另外读者可是自己设计实现小堆排序的算法。虽然和大堆排序的实现过程相似，但是却可以加深对堆排序的记忆和理解。</span></span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> </span></p> 
<p></p> 
<h2><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong><span style="color:#000099">面试题28：编程实现基数排序 </span></strong></span></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">#include &lt;stdio.h&gt; </span></span> 
<p></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">#include &lt;malloc.h&gt; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">#define LEN 8 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> typedef struct node       //队列结点 <br> {  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>int data;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>struct node * next; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">}node,*QueueNode;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> typedef struct Queue   //队列 <br> {  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>QueueNode front;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>QueueNode rear; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">}Queue,*QueueLink;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> QueueLink CreateNullQueue( QueueLink &amp;Q)  //创建空队列 <br> {  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>Q = NULL; <br>  <span style="white-space:pre"> </span>Q = ( QueueLink )malloc( sizeof( Queue ) );  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>if( NULL == Q )  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>printf("Fail to malloc null queue!\n");   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>return NULL;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>}</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br>  <span style="white-space:pre"> </span>Q-&gt;front = ( QueueNode )malloc( sizeof( node ) );  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>Q-&gt;rear  = ( QueueNode )malloc( sizeof( node ) );  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>if( NULL == Q-&gt;front || NULL == Q-&gt;rear )  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>printf("Fail to malloc a new queue's fornt or rear!\n");   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>return NULL;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>}  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>Q-&gt;rear = NULL;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>Q-&gt;front-&gt;next= Q-&gt;rear;    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>return Q; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> int lenData( node data[], int len)     //计算队列中各结点的数据的最大位数 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">{  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>int m = 0;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>int temp = 0;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>int d;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>for( int i = 0; i &lt; len; i++)  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>d = data[i].data;   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>while( d &gt; 0)   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>d /= 10;    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>temp ++;   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>}   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>if( temp &gt; m )   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>m = temp;   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>}   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>temp = 0;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>}  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>return m; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> QueueLink Push( QueueLink &amp;Q , node node )  //将数据压入队列 <br> {  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>QueueNode p1,p; <br>  <span style="white-space:pre"> </span>p =( QueueNode )malloc( sizeof( node ) );  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>if( NULL == p )  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>printf("Fail to malloc a new node!\n");   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>return NULL;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>} <br>  <span style="white-space:pre"> </span>p1 = Q-&gt;front; <br>  <span style="white-space:pre"> </span>while(p1-&gt;next != NULL)  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{<!-- --></span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>p1 = p1-&gt;next;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>}</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> <br>  <span style="white-space:pre"> </span>p-&gt;data = node.data;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>p1-&gt;next = p; <br>  <span style="white-space:pre"> </span>p-&gt;next = Q-&gt;rear; <br>  <span style="white-space:pre"> </span>return NULL; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">} <br> <br> </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">node Pop( QueueLink &amp;Q) //数据出队列 <br> {  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>node temp;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>temp.data = 0;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>temp.next = NULL;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>QueueNode p;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>p = Q-&gt;front-&gt;next;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>if( p != Q-&gt;rear )  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>temp = *p;   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>Q-&gt;front-&gt;next = p-&gt;next;   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>free( p );   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>p = NULL;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>}  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>return temp; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> int IsEmpty( QueueLink Q) </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">{  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>if( Q-&gt;front-&gt;next == Q-&gt;rear )  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>return 0;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>}  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>return 1; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> int main( void ) </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>int i = 0;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>int Max = 0;       //记录结点中数据的最大位数 <br>  <span style="white-space:pre"> </span>int d = 10;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>int power = 1;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>int k = 0; <br>  <span style="white-space:pre"> </span>node Array[LEN] ={<!-- -->{450, NULL}, {32,NULL}, { 781,NULL}, { 57 ,NULL},      </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>      {145,NULL},{ 613,NULL},{ 401,NULL},{ 594,NULL}};   //队列结点数<span style="font-family:'Microsoft YaHei'; font-size:14px">组</span> </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br>  <span style="white-space:pre"> </span>QueueLink Queue[10]; <br>  <span style="white-space:pre"> </span>for( i = 0; i &lt; 10; i++)  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{<!-- --></span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>CreateNullQueue( Queue[i]);   //初始化队列数组 <br>  <span style="white-space:pre"> </span>} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br>  <span style="white-space:pre"> </span>for( i = 0; i &lt; LEN; i++)  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>printf("%d  ",Array[i].data);  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>}   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>printf("\n");   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>Max = lenData( Array, LEN );    //计算数组中关键字的最大位数 <br>  <span style="white-space:pre"> </span>printf("%d\n",Max); </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br>   <span style="white-space:pre"></span>for(int j = 0; j &lt; Max; j++)     //按位排序 <br>  <span style="white-space:pre"> </span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>if(j == 0) power = 1;   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>else power = power *d; <br>    <span style="white-space:pre"> </span>for(i = 0; i &lt; LEN; i++)   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>k = Array[i].data /power - (Array[i].data/(power * d)) * d;    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>Push( Queue[k], Array[i] );  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span> <span style="white-space:pre"></span>}   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> <br>   <span style="white-space:pre"></span>for(int l = 0, k = 0; l &lt; d; l++)   //排序后出队列重入数组   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>while( IsEmpty( Queue[l] ) )   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> <span style="white-space:pre"></span>{     </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>Array[k++] = Pop( Queue[l] );    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>}   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>}</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> <br>   <span style="white-space:pre"></span>for( int t = 0; t &lt; LEN; t++)   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>{    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>printf("%d  ",Array[t].data);   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>} <br>   <span style="white-space:pre"></span>printf("\n"); <br> <span style="white-space:pre"></span>} <br>   <span style="white-space:pre"></span>return 0; <br> } <br> <strong>说明：</strong>队列为基数排序的实现提供了很大的方便，适当的数据机构可以减少算法的复杂度，让更多的算法实现更容易。</span></span></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题29：谈谈你对编程规范的理解或认识 </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">编程规范可总结为：程序的可行性，可读性、可移植性以及可测试性。 </span><br> <span style="font-size:14px"><strong>说明：</strong>这是编程规范的总纲目，面试者不一定要去背诵上面给出的那几个例子，应该去理解这几个例子说明的问题，想一想，自己如何解决可行性、可读性、可移植性以及可测试性这几个问题，结合以上几个例子和自己平时的编程习惯来回答这个问题。 </span></span> 
<p></p> 
<p><span style="font-family:Microsoft YaHei"><br> </span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题30：short i = 0; i = i + 1L；这两句有错吗 </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">代码一是错的，代码二是正确的。 </span><br> <span style="font-size:14px"><strong>说明：</strong>在数据安全的情况下大类型的数据向小类型的数据转换一定要显示的强制类型转换。 </span></span> 
<p></p> 
<p><span style="font-family:Microsoft YaHei"><br> </span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题31：&amp;&amp;和&amp;、||和|有什么区别 </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">（1）&amp;和|对操作数进行求值运算，&amp;&amp;和||只是判断逻辑关系。 </span><br> <span style="font-size:14px">（2）&amp;&amp;和||在在判断左侧操作数就能确定结果的情况下就不再对右侧操作数求值。 </span><br> <span style="font-size:14px"><strong>注意：</strong>在编程的时候有些时候将&amp;&amp;或||替换成&amp;或|没有出错，但是其逻辑是错误的，可能会导致不可预想的后果（比如当两个操作数一个是1另一个是2时）。</span></span> 
<p></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> </span><br> </span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题32：C++的引用和C语言的指针有什么区别 </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">指针和引用主要有以下区别： </span><br> <span style="font-size:14px">（1）引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。 </span><br> <span style="font-size:14px">（2）引用初始化以后不能被改变，指针可以改变所指的对象。 </span><br> <span style="font-size:14px">（3）不存在指向空值的引用，但是存在指向空值的指针。 </span></span> 
<p></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> <strong>注意：</strong>引用作为函数参数时，会引发一定的问题，因为让引用作参数，目的就是想改变这个引用所指向地址的内容，而函数调用时传入的是实参，看不出函数的参数是正常变量，还是引用，因此可能会引发错误。所以使用时一定要小心谨慎。</span><br> </span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题33：在二元树中找出和为某一值的所有路径 </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">输入一个整数和一棵二元树。从树的根结点开始往下访问，一直到叶结点所经过的所有结点形成一条路径。打印出和与输入整数相等的所有路径。例如，输入整数9和如下二元树： </span><br> <span style="font-size:14px">                     3                    </span></span> 
<p></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>   /   \                   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">                  2     6 </span><br> <span style="font-size:14px">                 /  \                </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">               5     4 </span><br> <span style="font-size:14px">则打印出两条路径：3，6和3，2，4。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">【答案】 </span><br> <span style="font-size:14px">typedef struct path </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">{  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>BiTNode* tree;   </span><span style="font-size:14px">//结点数据成员  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>struct path* next;      //结点指针成员 </span><br> <span style="font-size:14px">}PATH,*pPath; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> 初始化树的结点栈： </span><br> <span style="font-size:14px">void init_path( pPath* L ) </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">{  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>*L = ( pPath )malloc( sizeof( PATH ) );  //创建空树 </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>( *L )-&gt;next = NULL;  </span><br> <span style="font-size:14px">} </span><br> <span style="font-size:14px">树结点入栈函数： </span><br> <span style="font-size:14px">void push_path(pPath H, pBTree T)</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> {  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>pPath p = H-&gt;next;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>pPath q = H;   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>while( NULL != p ) </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>q = p; </span><br> <span style="font-size:14px">  <span style="white-space:pre"></span>p = p-&gt;next; </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br>   <span style="white-space:pre"></span>p = ( pPath )malloc( sizeof( PATH ) );  //申请新结点 </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>p-&gt;next = NULL;     //初始化新结点 </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>p-&gt;tree = T;    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>q-&gt;next = p;   </span><br> <span style="font-size:14px"> </span><br> <span style="font-size:14px">//新结点入栈 </span><br> <span style="font-size:14px">} </span><br> <span style="font-size:14px">树结点打印函数： </span><br> <span style="font-size:14px">void print_path( pPath L ) </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">{  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>pPath p = L-&gt;next;    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>while( NULL != p )     //打印当前栈中所有数据 </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>printf("%d, ", p-&gt;tree-&gt;data);   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>p = p-&gt;next;  </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>}  </span><br> <span style="font-size:14px">} </span><br> <span style="font-size:14px">树结点出栈函数： </span><br> <span style="font-size:14px">void pop_path( pPath H ) </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">{  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>pPath p = H-&gt;next;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>pPath q = H;   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>if( NULL == p )      //检验当前栈是否为空 </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>printf("Stack is null!\n");   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>return;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br>  <span style="white-space:pre"> </span>p = p-&gt;next; </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>while( NULL != p )     //出栈 </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>q = q-&gt;next;   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>p = p-&gt;next;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br>  <span style="white-space:pre"> </span>free( q-&gt;next );      //释放出栈结点空间 </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>q-&gt;next = NULL;  </span><br> <span style="font-size:14px">} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> 判断结点是否为叶子结点： </span><br> <span style="font-size:14px">int IsLeaf(pBTree T) </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">{  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>return ( T-&gt;lchild == NULL )&amp;&amp;( T-&gt;rchild==NULL ); </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> 查找符合条件的路径： </span><br> <span style="font-size:14px">int find_path(pBTree T, int sum, pPath L) </span><br> <span style="font-size:14px">{  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>push_path( L, T);  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>record += T-&gt;data;  </span><br> <span style="font-size:14px">  <span style="white-space:pre"></span>if( ( record == sum ) &amp;&amp; ( IsLeaf( T ) ) )  </span><span style="font-size:14px">//打印符合条件的当前路径 </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>print_path( L );    </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>printf( "\n" );  </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br>   <span style="white-space:pre"></span>if( T-&gt;lchild != NULL )     //递归查找当前节点的左孩子 </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>find_path( T-&gt;lchild, sum, L);  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br>  <span style="white-space:pre"> </span>if( T-&gt;rchild != NULL )      //递归查找当前节点的右孩子 </span><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>{   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>find_path( T-&gt;rchild, sum, L); </span><br> <span style="font-size:14px"><span style="white-space:pre"></span>} </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br>   <span style="white-space:pre"></span>record -= T-&gt;data;   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>pop_path(L);   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>return 0; </span><br> <span style="font-size:14px">} </span><br> <span style="font-size:14px">注意：</span><span style="font-size:14px">数据结构一定要活学活用，例如本题，把所有的结点都压入栈，而不符合条件的结点弹出栈，很容易实现了有效路径的查找。虽然用链表也可以实现，但是用栈更利于理解这个问题，即适当的数据结构为更好的算法设计提供了有利的条件。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> </span><br> </span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题34：写一个“标准”宏MIN </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">写一个“标准”宏MIN，这个宏输入两个参数并且返回较小的一个。 </span></span> 
<p></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">【答案】 </span><br> <span style="font-size:14px">#define min(a,b)((a)&lt;=(b)?(a):(b)) </span><br> <span style="font-size:14px"><strong>注意：</strong>在调用时一定要注意这个宏定义的副作用，如下调用：  </span><br> <span style="font-size:14px">((++*p)&lt;=(x)?(++*p):(x)。 </span><br> <span style="font-size:14px">p指针就自加了两次，违背了MIN的本意。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><span style="font-size:18px; color:#000099">面试题35：typedef和define有什么区别 </span></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">（1）用法不同：typedef用来定义一种数据类型的别名，增强程序的可读性。define主要用来定义常量，以及书写复杂使用频繁的<span style="white-space:pre"></span>宏。 <br> （2）执行时间不同：typedef是编译过程的一部分，有类型检查的功能。define是宏定义，是预编译的部分，其发生在编译之前，<span style="white-space:pre"></span>只是简单的进行字符串的替换，不进行类型的检查。 <br> （3）作用域不同：typedef有作用域限定。define不受作用域约束，只要是在define声明后的引用都是正确的。 <br> （4）对指针的操作不同：typedef和define定义的指针时有很大的区别。 <br> <strong>注意：</strong>typedef定义是语句，因为句尾要加上分号。而define不是语句，千万不能在句尾加分号。</span></span> 
<p></p> 
<span style="font-family:Microsoft YaHei"><br> </span> 
<h2><span style="font-family:Microsoft YaHei"><span style="font-size:18px; color:#000099"><strong>面试题36：关键字const是什么 </strong></span></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">const用来定义一个只读的变量或对象。主要优点：便于类型检查、同宏定义一样可以方便地进行参数的修改和调整、节省空间，避免不必要的内存分配、可为函数重载提供参考。 </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>说明：</strong>const修饰函数参数，是一种编程规范的要求，便于阅读，一看即知这个参数不能被改变，实现时不易出错。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei; color:#000099"><span style="background-color:rgb(255,255,255)"><span style="font-size:18px">面试题37：static有什么作用</span><span style="font-size:14px"> </span></span></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">static在C中主要用于定义全局静态变量、定义局部静态变量、定义静态函数。在C++中新增了两种作用：定义静态数据成员、静态函数成员。 </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>注意：</strong>因为static定义的变量分配在静态区，所以其定义的变量的默认值为0，普通变量的默认值为随机数，在定义指针变量时要特别注意。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题38：extern有什么作用 </span></strong></span></h2> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">extern标识的变量或者函数声明其定义在别的文件中，提示编译器遇到此变量和函数时在其它模块中寻找其定义。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><span style="font-size:18px; color:#000099"><strong>面试题39：流操作符重载为什么返回引用 </strong></span></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">在程序中，流操作符&gt;&gt;和&lt;&lt;经常连续使用。因此这两个操作符的返回值应该是一个仍旧支持这两个操作符的流引用。其他的数据类型都无法做到这一点。 </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>注意：</strong>除了在赋值操作符和流操作符之外的其他的一些操作符中，如+、-、*、/等却千万不能返回引用。因为这四个操作符的对象都是右值，因此，它们必须构造一个对象作为返回值。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题40：简述指针常量与常量指针区别</span></strong><span style="font-size:14px"> </span></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。常量指针是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。 </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>注意：</strong>无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题41：数组名和指针的区别 </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">请写出以下代码的打印结果： </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">#include &lt;iostream.h&gt; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">#include &lt;string.h&gt; </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">void main(void) </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">{  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>char str[13]="Hello world!"; </span></span></p> 
<span style="font-family:Microsoft YaHei"><br> <span style="font-size:14px"> <span style="white-space:pre"> </span>char *pStr="Hello world!";   </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> <span style="white-space:pre"></span>cout&lt;&lt;sizeof(str)&lt;&lt;endl;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>cout&lt;&lt;sizeof(pStr)&lt;&lt;endl;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>cout&lt;&lt;strlen(str)&lt;&lt;endl;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>cout&lt;&lt;strlen(pStr)&lt;&lt;endl;   </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>return; </span></span></p> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">} </span><br> <span style="font-size:14px">【答案】 打印结果： </span><br> <span style="font-size:14px">13 4 12 12 </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>注意：</strong>一定要记得数组名并不是真正意义上的指针，它的内涵要比指针丰富的多。但是当数组名当做参数传递给函数后，其失去原来的含义，变作普通的指针。另外要注意sizeof不是函数，只是操作符。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei; font-size:18px; color:#000099"><strong>面试题42：如何避免“野指针” </strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">“野指针”产生原因及解决办法如下： </span><br> <span style="font-size:14px">（1）指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向NULL。 </span><br> <span style="font-size:14px">（2）指针 p 被 free 或者 delete 之后，没有置为 NULL。解决办法：指针指向的内存空间被释放后指针应该指向NULL。 </span><br> <span style="font-size:14px">（3）指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向NULL。 </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>注意：</strong>“野指针”的解决方法也是编程规范的基本原则，平时使用指针时一定要避免产生“野指针”，在使用指针前一定要检验指针的合法性。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题43：常引用有什么作用 </span></strong></span></h2> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">常引用的引入主要是为了避免使用变量的引用时，在不知情的情况下改变变量的值。常引用主要用于定义一个普通变量的只读属性的别名、作为函数的传入形参，避免实参在调用函数中被意外的改变。 </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><strong>说明：</strong>很多情况下，需要用常引用做形参，被引用对象等效于常对象，不能在函数中改变实参的值，这样的好处是有较高的易读性和较小的出错率。 </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> </span></p> 
<h2><span style="font-family:Microsoft YaHei; font-size:18px; color:#000099">面试题44：编码实现字符串转化为数字 </span></h2> 
<span style="font-family:Microsoft YaHei; font-size:14px">编码实现函数atoi()，设计一个程序，把一个字符串转化为一个整型数值。例如数字：“5486321”，转化成字符：5486321。 <br> 【答案】 <br> </span> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">int myAtoi(const char * str)</span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">{ </span></p> 
<span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>int num = 0;       //保存转换后的数值 <br>  <span style="white-space:pre"> </span>int isNegative = 0;  <br>  <br> <span style="white-space:pre"></span>//记录字符串中是否有负号 <br>  <span style="white-space:pre"> </span>int n =0; <br> </span> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>char *p = str;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>if(p == NULL)       //判断指针的合法性 </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>return -1;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> </span></p> 
<span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>while(*p++ != '\0')      //计算数字符串度 <br> </span> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>n++;  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> </span></p> 
<span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>p = str; <br>  <span style="white-space:pre"> </span>if(p[0] == '-')       //判断数组是否有负号 <br> </span> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>isNegative = 1; </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> </span></p> 
<span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>char temp = '0'; <br> </span> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>for(int i = 0  i &lt; n; i++)  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>{<!-- --></span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>char temp = *p++;   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>if(temp &gt; '9' ||temp &lt; '0')    //滤除非数字字符 </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">  <span style="white-space:pre"> </span>{<!-- --></span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>continue; </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>} </span></p> 
<p></p> 
<p></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">  <span style="white-space:pre"> </span>if(num !=0 || temp != '0')    //滤除字符串开始的0字符   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>{   </span></p> 
<span style="font-family:Microsoft YaHei; font-size:14px">  <span style="white-space:pre"> </span>temp -= 0x30; <br>  <br> <span style="white-space:pre"></span>//将数字字符转换为数值 <br> </span> 
<p><span style="font-family:Microsoft YaHei; font-size:14px">     <span style="white-space:pre"></span>num += temp *int( pow(10 , n - 1 -i) );   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>} </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>}  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"> </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>if(isNegative)        //如果字符串中有负号，将数值取反 </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>return (0 - num);  </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>}  else </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>{   </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><span style="white-space:pre"></span>return num;       //返回转换后的数值 </span></p> 
<span style="font-family:Microsoft YaHei; font-size:14px"> <span style="white-space:pre"></span>} <br> } <br> </span> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><strong>注意：</strong>此段代码只是实现了十进制字符串到数字的转化，读者可以自己去实现2进制，8进制，10进制，16进制的转化。 </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> </span></p> 
<h2><span style="font-family:Microsoft YaHei"><span style="font-size:18px; color:#000099"><strong>面试题45：简述strcpy、sprintf与memcpy的区别 </strong></span></span></h2> 
<span style="font-family:Microsoft YaHei; font-size:14px">三者主要有以下不同之处： <br> （1）操作对象不同，strcpy的两个操作对象均为字符串，sprintf的操作源对象可以是多种数据类型，<br> <span style="white-space:pre"></span>目的操作对象是字符串，memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。 <br> （2）执行效率不同，memcpy最高，strcpy次之，sprintf的效率最低。 <br> （3）实现功能不同，strcpy主要实现字符串变量间的拷贝，sprintf主要实现其他数据类型格式到字符串的转化，memcpy主要是内<span style="white-space:pre"></span>存块间的拷贝。 <br> </span> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><strong>说明：</strong>strcpy、sprintf与memcpy都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来选择合适的函数实现拷贝功能。 </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> </span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题46：用C编写一个死循环程序 </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">while(1) { } </span><br> </span> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><strong>说明：</strong>很多种途径都可实现同一种功能，但是不同的方法时间和空间占用度不同，特别是对于嵌入式软件，处理器速度比较慢，存储空间较小，所以时间和空间优势是选择各种方法的首要考虑条件。 </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> </span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题47：编码实现某一变量某位清0或置1 </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清a的bit 3，在以上两个操作中，要保持其他位不变。 </span><br> <span style="font-size:14px">【答案】 </span><br> <span style="font-size:14px">#define BIT3 (0x1 &lt;&lt; 3 ) Satic int a; </span><br> <span style="font-size:14px">设置a的bit 3: </span><br> <span style="font-size:14px">void set_bit3( void ) {  a |= BIT3;      //将a第3位置1 </span><br> <span style="font-size:14px">} </span><br> <span style="font-size:14px">清a的bit 3 </span><br> <span style="font-size:14px">void set_bit3( void ) {  a &amp;= ~BIT3;      //将a第3位清零 </span><br> <span style="font-size:14px">} </span><br> </span> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><strong>说明：</strong>在置或清变量或寄存器的某一位时，一定要注意不要影响其他位。所以用加减法是很难实现的。 </span></p> 
<p><span style="font-family:Microsoft YaHei; font-size:14px"><br> </span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题48：评论下面这个中断函数 </span></strong></span></h2> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展——让标准C支持中断。具体代表事实是，产生了一个新的关键字__interrupt。下面的代码就使用了__interrupt关键字去定义一个中断服务子程序(ISR)，请评论以下这段代码。 </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">__interrupt double compute_area (double radius) </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"> {  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>double area = PI * radius * radius;  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>printf(" Area = %f", area);  </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><span style="white-space:pre"></span>return area;  </span></span></p> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">} </span><br> <span style="font-size:14px">【答案】 </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">这段中断服务程序主要有以下四个问题： </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">（1）ISR 不能返回一个值。 </span></span></p> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px">（2）ISR 不能传递参数。 </span><br> </span> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">（3）在ISR 中做浮点运算是不明智的。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">（4）printf()经常有重入和性能上的问题。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>注意：</strong>本题的第三个和第四个问题虽不是考察的重点，但是如果能提到这两点可给面试官留下一个好印象。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题49：构造函数能否为虚函数 </span></strong></span></h2> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">构造函数不能是虚函数。而且不能在构造函数中调用虚函数，因为那样实际执行的是父类的对应函数，因为自己还没有构造好。析构函数可以是虚函数，而且，在一个复杂类结构中，这往往是必须的。析构函数也可以是纯虚函数，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>说明：</strong>虚函数的动态绑定特性是实现重载的关键技术，动态绑定根据实际的调用情况查询相应类的虚函数表，调用相应的虚函数。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<h2><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px; color:#000099">面试题50：谈谈你对面向对象的认识 </span></strong></span></h2> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px">面向对象可以理解成对待每一个问题，都是首先要确定这个问题由几个部分组成，而每一个部分其实就是一个对象。然后再分别设计这些对象，最后得到整个程序。传统的程序设计多是基于功能的思想来进行考虑和设计的，而面向对象的程序设计则是基于对象的角度来考虑问题。这样做能够使得程序更加的简洁清晰。 </span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:14px"><br> </span></span></p> 
<span style="font-family:Microsoft YaHei"><span style="font-size:14px"><strong>说明：</strong>编程中接触最多的“面向对象编程技术”仅仅是面向对象技术中的一个组成部分。发挥面向对象技术的优势是一个综合的技术问题，不仅需要面向对象的分析，设计和编程技术，而且需要借助必要的建模和开发工具。</span></span>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/686676fcf52a665d47d676033119438c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Hbase:namespace异常处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fe86275d4d69065bf0eaeca479a762f8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">版本管理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>