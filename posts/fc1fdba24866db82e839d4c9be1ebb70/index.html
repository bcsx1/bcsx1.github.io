<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>WPF入门教程系列002-WPF布局 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="WPF入门教程系列002-WPF布局" />
<meta property="og:description" content="WPF入门教程系列002-WPF布局 文章目录 WPF入门教程系列002-WPF布局1.WPF窗体1.1. 无边框窗体1.2. 异形窗体 2.WPF布局2.1.WPF的布局处理：2.2.布局原则：2.3.布局过程： 3.布局控件3.1 .Border控件3.1.1.属性3.1.2.案例 3.2.DockPanel控件3.2.1 .属性3.2.2.案例 3.3.StackPanel控件3.3.1.属性3.3.2.案例 3.4.WrapPanel控件3.4.1.属性3.4.2.案例 3.5.Grid控件3.5.1.属性3.5.2.案例 3.6.UniformGrid控件3.6.1.属性3.6.2.案例 3.7.Canvas控件3.7.1.属性3.7.2.案例 3.8.InkCanvas控件3.8.1.属性3.8.2.案例 1.WPF窗体 WPF（Windows Presentation Foundation）窗体是一种用于创建图形用户界面的框架。它允许开发者使用XAML（可扩展标记语言）来描述窗口、控件和布局，从而实现丰富的交互效果。本文将从无边框窗体和异形窗体两个方面介绍WPF窗体。
1.1. 无边框窗体 无边框窗体是指在WPF窗体中不显示边框的窗口。要创建一个无边框窗体，可以使用Window类的WindowStyle属性，并将其设置为None。以下是一个简单的无边框窗体示例：
&lt;Window x:Class=&#34;WpfApp1.MainWindow&#34; xmlns=&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34; xmlns:x=&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34; Title=&#34;MainWindow&#34; Height=&#34;350&#34; Width=&#34;525&#34; WindowStyle=&#34;None&#34;&gt; &lt;Grid&gt; &lt;TextBlock Text=&#34;Hello, World!&#34; HorizontalAlignment=&#34;Center&#34; VerticalAlignment=&#34;Center&#34;/&gt; &lt;/Grid&gt; &lt;/Window&gt; 在这个示例中，我们设置了WindowStyle属性为None，使得窗口没有边框。同时，我们还添加了一个TextBlock控件，用于显示“Hello, World!”文本。
1.2. 异形窗体 异形窗体是指在WPF窗体中，窗口的形状不是矩形的。要创建一个异形窗体，可以使用Window类的ResizeMode属性，并将其设置为NoResize或CanResizeWithSnap。以下是一个简单的异形窗体示例：
&lt;Window x:Class=&#34;WpfApp1.MainWindow&#34; xmlns=&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34; xmlns:x=&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34; Title=&#34;MainWindow&#34; Height=&#34;350&#34; Width=&#34;525&#34; ResizeMode=&#34;NoResize&#34;&gt; &lt;Grid&gt; &lt;TextBlock Text=&#34;Hello, World!&#34; HorizontalAlignment=&#34;Center&#34; VerticalAlignment=&#34;Center&#34;/&gt; &lt;/Grid&gt; &lt;/Window&gt; 在这个示例中，我们设置了ResizeMode属性为NoResize，使得窗口不能调整大小。同时，我们还添加了一个TextBlock控件，用于显示“Hello, World!”文本。
2.WPF布局 2.1.WPF的布局处理： WPF 提供了多种布局方式来处理控件的位置和大小。这些布局方式可以基于坐标和大小进行调整，也可以使用流式布局。以下是常见的布局方式：
绝对布局（基于坐标和大小）：可以使用 Canvas 控件来实现绝对布局。通过设置控件的 Canvas." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/fc1fdba24866db82e839d4c9be1ebb70/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-09T14:06:55+08:00" />
<meta property="article:modified_time" content="2023-11-09T14:06:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">WPF入门教程系列002-WPF布局</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="WPF002WPF_0"></a>WPF入门教程系列002-WPF布局</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#WPF002WPF_0" rel="nofollow">WPF入门教程系列002-WPF布局</a></li><li><ul><li><a href="#1WPF_2" rel="nofollow">1.WPF窗体</a></li><li><ul><li><a href="#11__6" rel="nofollow">1.1. 无边框窗体</a></li><li><a href="#12__24" rel="nofollow">1.2. 异形窗体</a></li></ul> 
   </li><li><a href="#2WPF_42" rel="nofollow">2.WPF布局</a></li><li><ul><li><a href="#21WPF_44" rel="nofollow">2.1.WPF的布局处理：</a></li><li><a href="#22_56" rel="nofollow">2.2.布局原则：</a></li><li><a href="#23_68" rel="nofollow">2.3.布局过程：</a></li></ul> 
   </li><li><a href="#3_76" rel="nofollow">3.布局控件</a></li><li><ul><li><a href="#31_Border_78" rel="nofollow">3.1 .Border控件</a></li><li><ul><li><a href="#311_82" rel="nofollow">3.1.1.属性</a></li><li><a href="#312_92" rel="nofollow">3.1.2.案例</a></li></ul> 
    </li><li><a href="#32DockPanel_142" rel="nofollow">3.2.DockPanel控件</a></li><li><ul><li><a href="#321__146" rel="nofollow">3.2.1 .属性</a></li><li><a href="#322_150" rel="nofollow">3.2.2.案例</a></li></ul> 
    </li><li><a href="#33StackPanel_192" rel="nofollow">3.3.StackPanel控件</a></li><li><ul><li><a href="#331_196" rel="nofollow">3.3.1.属性</a></li><li><a href="#332_206" rel="nofollow">3.3.2.案例</a></li></ul> 
    </li><li><a href="#34WrapPanel_245" rel="nofollow">3.4.WrapPanel控件</a></li><li><ul><li><a href="#341_249" rel="nofollow">3.4.1.属性</a></li><li><a href="#342_259" rel="nofollow">3.4.2.案例</a></li></ul> 
    </li><li><a href="#35Grid_312" rel="nofollow">3.5.Grid控件</a></li><li><ul><li><a href="#351_318" rel="nofollow">3.5.1.属性</a></li><li><a href="#352_329" rel="nofollow">3.5.2.案例</a></li></ul> 
    </li><li><a href="#36UniformGrid_409" rel="nofollow">3.6.UniformGrid控件</a></li><li><ul><li><a href="#361_415" rel="nofollow">3.6.1.属性</a></li><li><a href="#362_422" rel="nofollow">3.6.2.案例</a></li></ul> 
    </li><li><a href="#37Canvas_440" rel="nofollow">3.7.Canvas控件</a></li><li><ul><li><a href="#371_444" rel="nofollow">3.7.1.属性</a></li><li><a href="#372_461" rel="nofollow">3.7.2.案例</a></li></ul> 
    </li><li><a href="#38InkCanvas_518" rel="nofollow">3.8.InkCanvas控件</a></li><li><ul><li><a href="#381_522" rel="nofollow">3.8.1.属性</a></li><li><a href="#382_530" rel="nofollow">3.8.2.案例</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1WPF_2"></a>1.WPF窗体</h3> 
<p>WPF（Windows Presentation Foundation）窗体是一种用于创建图形用户界面的框架。它允许开发者使用XAML（可扩展标记语言）来描述窗口、控件和布局，从而实现丰富的交互效果。本文将从无边框窗体和异形窗体两个方面介绍WPF窗体。</p> 
<h4><a id="11__6"></a>1.1. 无边框窗体</h4> 
<p>无边框窗体是指在WPF窗体中不显示边框的窗口。要创建一个无边框窗体，可以使用<code>Window</code>类的<code>WindowStyle</code>属性，并将其设置为<code>None</code>。以下是一个简单的无边框窗体示例：</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Window</span> <span class="token attr-name"><span class="token namespace">x:</span>Class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>WpfApp1.MainWindow<span class="token punctuation">"</span></span>
        <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.microsoft.com/winfx/2006/xaml/presentation<span class="token punctuation">"</span></span>
        <span class="token attr-name"><span class="token namespace">xmlns:</span>x</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.microsoft.com/winfx/2006/xaml<span class="token punctuation">"</span></span>
        <span class="token attr-name">Title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>MainWindow<span class="token punctuation">"</span></span> <span class="token attr-name">Height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>350<span class="token punctuation">"</span></span> <span class="token attr-name">Width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>525<span class="token punctuation">"</span></span>
        <span class="token attr-name">WindowStyle</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>None<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Grid</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextBlock</span> <span class="token attr-name">Text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Hello, World!<span class="token punctuation">"</span></span> <span class="token attr-name">HorizontalAlignment</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Center<span class="token punctuation">"</span></span> <span class="token attr-name">VerticalAlignment</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Center<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Grid</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Window</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>在这个示例中，我们设置了<code>WindowStyle</code>属性为<code>None</code>，使得窗口没有边框。同时，我们还添加了一个<code>TextBlock</code>控件，用于显示“Hello, World!”文本。</p> 
<h4><a id="12__24"></a>1.2. 异形窗体</h4> 
<p>异形窗体是指在WPF窗体中，窗口的形状不是矩形的。要创建一个异形窗体，可以使用<code>Window</code>类的<code>ResizeMode</code>属性，并将其设置为<code>NoResize</code>或<code>CanResizeWithSnap</code>。以下是一个简单的异形窗体示例：</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Window</span> <span class="token attr-name"><span class="token namespace">x:</span>Class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>WpfApp1.MainWindow<span class="token punctuation">"</span></span>
        <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.microsoft.com/winfx/2006/xaml/presentation<span class="token punctuation">"</span></span>
        <span class="token attr-name"><span class="token namespace">xmlns:</span>x</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.microsoft.com/winfx/2006/xaml<span class="token punctuation">"</span></span>
        <span class="token attr-name">Title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>MainWindow<span class="token punctuation">"</span></span> <span class="token attr-name">Height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>350<span class="token punctuation">"</span></span> <span class="token attr-name">Width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>525<span class="token punctuation">"</span></span>
        <span class="token attr-name">ResizeMode</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>NoResize<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Grid</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextBlock</span> <span class="token attr-name">Text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Hello, World!<span class="token punctuation">"</span></span> <span class="token attr-name">HorizontalAlignment</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Center<span class="token punctuation">"</span></span> <span class="token attr-name">VerticalAlignment</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Center<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Grid</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Window</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>在这个示例中，我们设置了<code>ResizeMode</code>属性为<code>NoResize</code>，使得窗口不能调整大小。同时，我们还添加了一个<code>TextBlock</code>控件，用于显示“Hello, World!”文本。</p> 
<h3><a id="2WPF_42"></a>2.WPF布局</h3> 
<h4><a id="21WPF_44"></a>2.1.WPF的布局处理：</h4> 
<p>WPF 提供了多种布局方式来处理控件的位置和大小。这些布局方式可以基于坐标和大小进行调整，也可以使用流式布局。以下是常见的布局方式：</p> 
<ul><li> <p>绝对布局（基于坐标和大小）：可以使用 Canvas 控件来实现绝对布局。通过设置控件的 <code>Canvas.Left</code>、<code>Canvas.Top</code>、<code>Canvas.Right</code> 和 <code>Canvas.Bottom</code> 属性，可以精确地指定控件在容器中的位置和大小。</p> </li><li> <p>相对布局：可以使用 Grid 控件来实现相对布局。通过定义行和列，并使用 Grid.Row 和 Grid.Column 属性，可以将控件放置在网格中的特定单元格位置。</p> </li><li> <p>堆叠布局：可以使用 StackPanel 控件来实现堆叠布局。StackPanel 可以水平或垂直地堆叠子控件，使它们按照一定顺序排列。</p> </li><li> <p>流式布局：可以使用 WrapPanel 或 FlowDocument 控件来实现流式布局。WrapPanel 可以自动换行，根据可用空间将子控件按行或列进行排列。FlowDocument 是用于处理大量文本内容的特殊布局控件，可以根据内容自动调整大小和换行。</p> </li></ul> 
<h4><a id="22_56"></a>2.2.布局原则：</h4> 
<p>在进行 WPF 布局时，可以遵循以下原则：</p> 
<ul><li> <p>灵活性：WPF 布局系统是灵活的，可以自动适应不同的窗口大小和分辨率。使用相对布局和流式布局可以帮助实现灵活性。</p> </li><li> <p>可重用性：使用面向对象的思想，将布局逻辑进行封装和复用，以便在多个界面或应用程序中共享。</p> </li><li> <p>分离关注点：将布局与逻辑代码分离，使代码更易于维护和测试。使用 MVVM（Model-View-ViewModel）模式可以进一步分离布局和业务逻辑。</p> </li><li> <p>响应式设计：使用布局容器和控件的属性、样式和绑定来实现响应式设计，以便在运行时根据布局变化自动调整控件的位置和大小。</p> </li></ul> 
<h4><a id="23_68"></a>2.3.布局过程：</h4> 
<p>WPF 布局过程包括以下步骤：</p> 
<ul><li>测量（Measure）：布局系统从上到下递归地测量每个控件的大小需求。控件的测量过程基于控件自身的属性、布局容器的约束条件以及控件的子元素。每个控件根据其内容和布局规则计算出所需的最小大小。</li><li>排列（Arrange）：布局系统从上到下递归地安排每个控件的位置。在排列阶段，控件的实际大小和位置被确定，并根据父容器的布局规则进行调整。</li><li>渲染（Render）：布局系统将排列后的控件发送给渲染引擎进行绘制。渲染引擎使用控件的外观和样式信息，将控件绘制到屏幕上。</li></ul> 
<h3><a id="3_76"></a>3.布局控件</h3> 
<h4><a id="31_Border_78"></a>3.1 .Border控件</h4> 
<p>在日常布局中，Border控件常用于美化界面元素，例如，将一个按钮或文本框用边框装饰起来，增加视觉效果。同时，通过调整Border的CornerRadius属性，可以使边框具有圆角效果。若要在Border中显示多个子控件，可以将一个附加的Panel控件放置在父Border中，然后将子控件放置在该Panel控件中。</p> 
<h5><a id="311_82"></a>3.1.1.属性</h5> 
<ul><li>BorderBrush：用于设置边框的颜色。</li><li>BorderThickness：用于设置边框的宽度。</li><li>BorderPadding：用于设置边框的内部边距。</li><li>CornerRadius：用于设置边框的圆角半径。</li><li>Background：此属性设置Border用来绘制背景的Brush对象。</li><li>Padding：指定Border内部内容与边框之间的空白区域。</li><li>Margin：指定Border与其父元素之间的空白区域。</li></ul> 
<h5><a id="312_92"></a>3.1.2.案例</h5> 
<ol><li>创建边框和分隔线：通过设置Border的BorderBrush和BorderThickness属性，可以创建具有不同颜色和厚度的边框，用于分隔不同的区域或突出显示特定元素。</li></ol> 
<pre><code class="prism language-xaml">&lt;Border BorderBrush="Black" BorderThickness="1"&gt;
    &lt;!-- 子元素内容 --&gt;
&lt;/Border&gt;
</code></pre> 
<ol start="2"><li>创建圆角边框：通过设置Border的CornerRadius属性，可以创建具有圆角边框的元素，给界面增加一些柔和和现代感。</li></ol> 
<pre><code class="prism language-xaml">&lt;Border BorderBrush="Black" BorderThickness="1" CornerRadius="5"&gt;
    &lt;!-- 子元素内容 --&gt;
&lt;/Border&gt;
</code></pre> 
<ol start="3"><li>创建背景装饰：通过设置Border的Background属性，可以为元素提供背景色或背景图像，增加界面的美观性。</li></ol> 
<pre><code class="prism language-xaml">&lt;Border Background="LightGray"&gt;
    &lt;!-- 子元素内容 --&gt;
&lt;/Border&gt;
</code></pre> 
<p>下面是结合属性的几个案例：</p> 
<ol><li>创建一个有边框和背景颜色的按钮：</li></ol> 
<pre><code class="prism language-xaml">&lt;Button Width="100" Height="30"&gt;
    &lt;Border BorderBrush="Black" BorderThickness="1" Background="LightBlue"&gt;
        &lt;TextBlock Text="Click me" HorizontalAlignment="Center" VerticalAlignment="Center"/&gt;
    &lt;/Border&gt;
&lt;/Button&gt;
</code></pre> 
<ol start="2"><li>创建一个圆角边框的图片显示框：</li></ol> 
<pre><code class="prism language-xaml">&lt;Grid&gt;
    &lt;Border BorderBrush="Black" BorderThickness="1" CornerRadius="10" Padding="5" Margin="10"&gt;
        &lt;Image Source="image.jpg" Stretch="UniformToFill"/&gt;
    &lt;/Border&gt;
&lt;/Grid&gt;
</code></pre> 
<p>这些案例演示了如何使用Border控件的属性来创建不同的界面效果。你可以根据自己的需求调整属性值，以实现所需的布局和装饰效果。</p> 
<h4><a id="32DockPanel_142"></a>3.2.DockPanel控件</h4> 
<p>DockPanel控件是WPF中常用的布局控件之一，它可以根据指定的方式将子元素停靠在容器的不同位置，如顶部、底部、左侧、右侧或中间。DockPanel提供了一种简单而灵活的方式来创建常见的界面布局。</p> 
<h5><a id="321__146"></a>3.2.1 .属性</h5> 
<ul><li>LastChildFill：指定是否将最后一个子元素填充剩余空间。当设置为True时，最后一个子元素将占据剩余的可用空间；当设置为False时，最后一个子元素将根据其自身大小进行布局，而不会填充剩余空间。</li></ul> 
<h5><a id="322_150"></a>3.2.2.案例</h5> 
<ol><li>布局控件停靠：通过设置子元素的DockPanel.Dock属性来指定子元素的停靠位置。可以将子元素停靠在顶部、底部、左侧、右侧或中间。</li></ol> 
<pre><code class="prism language-xaml">&lt;DockPanel&gt;
    &lt;Button Content="Top" DockPanel.Dock="Top"/&gt;
    &lt;Button Content="Bottom" DockPanel.Dock="Bottom"/&gt;
    &lt;Button Content="Left" DockPanel.Dock="Left"/&gt;
    &lt;Button Content="Right" DockPanel.Dock="Right"/&gt;
    &lt;Button Content="Center"/&gt;
&lt;/DockPanel&gt;
</code></pre> 
<ol start="2"><li>创建自适应布局：通过设置LastChildFill属性为True，可以使最后一个子元素填充剩余空间，实现自适应布局。</li></ol> 
<pre><code class="prism language-xaml">&lt;DockPanel LastChildFill="True"&gt;
    &lt;Button Content="Top" DockPanel.Dock="Top"/&gt;
    &lt;Button Content="Bottom" DockPanel.Dock="Bottom"/&gt;
    &lt;Button Content="Left" DockPanel.Dock="Left"/&gt;
    &lt;Button Content="Right" DockPanel.Dock="Right"/&gt;
    &lt;Button Content="Center"/&gt;
&lt;/DockPanel&gt;
</code></pre> 
<ol start="3"><li>嵌套布局：DockPanel可以嵌套在其他布局控件内部，实现更复杂的布局结构。</li></ol> 
<pre><code class="prism language-xaml">&lt;Grid&gt;
    &lt;DockPanel&gt;
        &lt;Button Content="Top" DockPanel.Dock="Top"/&gt;
        &lt;Button Content="Bottom" DockPanel.Dock="Bottom"/&gt;
        &lt;Button Content="Left" DockPanel.Dock="Left"/&gt;
        &lt;Button Content="Right" DockPanel.Dock="Right"/&gt;
        &lt;Button Content="Center"/&gt;
    &lt;/DockPanel&gt;
&lt;/Grid&gt;
</code></pre> 
<p>以上是DockPanel控件的介绍和使用案例。通过设置子元素的DockPanel.Dock属性和调整LastChildFill属性，你可以灵活地创建各种布局效果，满足不同的界面设计需求。</p> 
<h4><a id="33StackPanel_192"></a>3.3.StackPanel控件</h4> 
<p>StackPanel控件是WPF中常用的布局控件之一。它以堆叠的方式排列其子元素，可以将子元素水平或垂直地放置在一起。StackPanel提供了一种简单而有效的方式来创建线性布局。</p> 
<h5><a id="331_196"></a>3.3.1.属性</h5> 
<ul><li>Orientation：指定StackPanel中子元素的排列方向。可以设置为Horizontal（水平排列）或Vertical（垂直排列）。</li><li>HorizontalAlignment和VerticalAlignment：指定StackPanel相对于其父元素的水平和垂直对齐方式。</li><li>Margin：指定StackPanel与其父元素之间的空白区域。</li><li>Background：指定StackPanel的背景颜色或背景图像。</li><li>HorizontalContentAlignment和VerticalContentAlignment：指定StackPanel中子元素的水平和垂直内容对齐方式。</li></ul> 
<p>在日常布局中，StackPanel控件常用于以下方面：</p> 
<h5><a id="332_206"></a>3.3.2.案例</h5> 
<ol><li>创建水平布局：通过将StackPanel的Orientation属性设置为Horizontal，可以将子元素水平排列在一行内。</li></ol> 
<pre><code class="prism language-xaml">&lt;StackPanel Orientation="Horizontal"&gt;
    &lt;Button Content="Button 1"/&gt;
    &lt;Button Content="Button 2"/&gt;
    &lt;Button Content="Button 3"/&gt;
&lt;/StackPanel&gt;
</code></pre> 
<ol start="2"><li>创建垂直布局：通过将StackPanel的Orientation属性设置为Vertical，可以将子元素垂直排列在一列内。</li></ol> 
<pre><code class="prism language-xaml">&lt;StackPanel Orientation="Vertical"&gt;
    &lt;Button Content="Button 1"/&gt;
    &lt;Button Content="Button 2"/&gt;
    &lt;Button Content="Button 3"/&gt;
&lt;/StackPanel&gt;
</code></pre> 
<ol start="3"><li>嵌套布局：StackPanel可以嵌套在其他布局控件内部，实现更复杂的布局结构。</li></ol> 
<pre><code class="prism language-xaml">&lt;Grid&gt;
    &lt;StackPanel Orientation="Vertical"&gt;
        &lt;Button Content="Button 1"/&gt;
        &lt;StackPanel Orientation="Horizontal"&gt;
            &lt;Button Content="Button 2"/&gt;
            &lt;Button Content="Button 3"/&gt;
        &lt;/StackPanel&gt;
        &lt;Button Content="Button 4"/&gt;
    &lt;/StackPanel&gt;
&lt;/Grid&gt;
</code></pre> 
<p>通过设置Orientation属性和嵌套StackPanel，并结合其他属性的调整，你可以灵活地创建各种线性布局效果，满足不同的界面设计需求。无论是水平排列还是垂直排列，StackPanel都能提供简单而有效的布局方式。</p> 
<h4><a id="34WrapPanel_245"></a>3.4.WrapPanel控件</h4> 
<p>WrapPanel控件是WPF中常用的布局控件之一，它提供了一种自动换行的布局方式。WrapPanel会按照从左到右、从上到下的顺序排列其子元素，并在达到容器边界时自动换行。</p> 
<h5><a id="341_249"></a>3.4.1.属性</h5> 
<ul><li>Orientation：指定WrapPanel的排列方向，可以是水平（默认值）或垂直。</li><li>HorizontalAlignment：指定WrapPanel内部子元素在水平方向上的对齐方式。</li><li>VerticalAlignment：指定WrapPanel内部子元素在垂直方向上的对齐方式。</li><li>ItemWidth：指定WrapPanel内部子元素的固定宽度，用于控制每行的宽度。</li><li>ItemHeight：指定WrapPanel内部子元素的固定高度，用于控制每列的高度。</li><li>MinWidth：指定WrapPanel的最小宽度。</li><li>MinHeight：指定WrapPanel的最小高度。</li></ul> 
<h5><a id="342_259"></a>3.4.2.案例</h5> 
<p>案例一：流式布局</p> 
<p>WrapPanel通过自动换行的方式，适应不同尺寸的容器，并使子元素按照预期顺序排列。这在需要动态布局的情况下非常有用，例如显示一系列标签或缩略图。</p> 
<pre><code class="prism language-xaml">&lt;!--这个案例中，我们创建了一个WrapPanel，并在其中放置了一系列按钮。WrapPanel会自动调整按钮的位置，使其按照从左到右、从上到下的顺序排列。每个按钮之间有5个像素的外边距。--&gt;
&lt;WrapPanel&gt;
    &lt;Button Content="Button 1" Margin="5" /&gt;
    &lt;Button Content="Button 2" Margin="5" /&gt;
    &lt;Button Content="Button 3" Margin="5" /&gt;
    &lt;Button Content="Button 4" Margin="5" /&gt;
    &lt;Button Content="Button 5" Margin="5" /&gt;
&lt;/WrapPanel&gt;
</code></pre> 
<p>案例二：图片画廊</p> 
<p>通过将图片放置在WrapPanel中，可以创建一个图片画廊效果。当窗口尺寸发生变化时，WrapPanel会自动调整行数和列数，以适应容器大小，并保持图片的纵横比。</p> 
<pre><code class="prism language-xaml">&lt;!--这个案例中，我们将一系列图片放置在WrapPanel中，设置图片的固定宽度和高度，并设置图片之间的外边距。当窗口尺寸发生变化时，WrapPanel会根据容器大小自动调整行数和列数，以适应窗口，并保持图片的纵横比。--&gt;
&lt;WrapPanel&gt;
    &lt;Image Source="image1.jpg" Width="150" Height="100" Margin="5" /&gt;
    &lt;Image Source="image2.jpg" Width="150" Height="100" Margin="5" /&gt;
    &lt;Image Source="image3.jpg" Width="150" Height="100" Margin="5" /&gt;
    &lt;Image Source="image4.jpg" Width="150" Height="100" Margin="5" /&gt;
    &lt;Image Source="image5.jpg" Width="150" Height="100" Margin="5" /&gt;
&lt;/WrapPanel&gt;
</code></pre> 
<p>案例三：标签云</p> 
<p>使用WrapPanel可以实现标签云的布局效果，其中每个标签作为WrapPanel的子元素，根据可用空间自动换行和调整位置。</p> 
<pre><code class="prism language-xaml">&lt;!--这个案例中，我们创建了一个标签云效果，使用WrapPanel作为容器，并在其中放置了一系列标签(Label)。每个标签具有相同的背景颜色（浅蓝色），并设置了外边距。WrapPanel会根据可用空间自动换行和调整位置，显示标签云的效果。--&gt;
&lt;WrapPanel&gt;
    &lt;Label Content="Tag1" Background="LightBlue" Margin="5" /&gt;
    &lt;Label Content="Tag2" Background="LightBlue" Margin="5" /&gt;
    &lt;Label Content="Tag3" Background="LightBlue" Margin="5" /&gt;
    &lt;Label Content="Tag4" Background="LightBlue" Margin="5" /&gt;
    &lt;Label Content="Tag1" Background="LightBlue" Margin="5" /&gt;
    &lt;Label Content="Tag2" Background="LightBlue" Margin="5" /&gt;
    &lt;Label Content="Tag3" Background="LightBlue" Margin="5" /&gt;
    &lt;Label Content="Tag4" Background="LightBlue" Margin="5" /&gt;
    &lt;Label Content="Tag5" Background="LightBlue" Margin="5" /&gt;
    &lt;Label Content="Tag6" Background="LightBlue" Margin="5" /&gt;
    &lt;Label Content="Tag7" Background="LightBlue" Margin="5" /&gt;
&lt;/WrapPanel&gt;
</code></pre> 
<h4><a id="35Grid_312"></a>3.5.Grid控件</h4> 
<p>Grid控件是WPF中常用的布局控件之一，它提供了一个网格布局，可以将界面划分为行和列，并在每个单元格中放置控件或元素。</p> 
<p>Grid控件的布局是基于行和列的定义，您可以在XAML中指定行和列的数量、大小、对齐方式等属性。每个控件或元素可以跨越多个行和列，以实现复杂的布局。</p> 
<h5><a id="351_318"></a>3.5.1.属性</h5> 
<ul><li>RowDefinitions：定义Grid的行，可以指定行的数量、高度、对齐方式等。</li><li>ColumnDefinitions：定义Grid的列，可以指定列的数量、宽度、对齐方式等。</li><li>Grid.Row：指定控件或元素所在的行索引。</li><li>Grid.Column：指定控件或元素所在的列索引。</li><li>Grid.RowSpan：指定控件或元素跨越的行数。</li><li>Grid.ColumnSpan：指定控件或元素跨越的列数。</li><li>HorizontalAlignment：指定控件或元素在单元格中的水平对齐方式。</li><li>VerticalAlignment：指定控件或元素在单元格中的垂直对齐方式。</li></ul> 
<h5><a id="352_329"></a>3.5.2.案例</h5> 
<p>案例一：简单网格布局</p> 
<p>Grid控件提供了一种灵活的网格布局方式，可以将界面划分为行和列，并在每个单元格中放置控件或元素。这使得我们可以以自由的方式创建复杂的布局结构。</p> 
<pre><code class="prism language-xaml">&lt;!--这个案例中，我们创建了一个简单的网格布局，其中包含两行和两列。第一行和第一列的大小根据内容自动调整，而第二行和第二列的大小会根据剩余空间进行伸缩。我们在每个单元格中放置了一个文本块(TextBlock)和一个文本框(TextBox)。--&gt;
&lt;Grid&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="Auto" /&gt;
        &lt;RowDefinition Height="*" /&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width="Auto" /&gt;
        &lt;ColumnDefinition Width="*" /&gt;
    &lt;/Grid.ColumnDefinitions&gt;

    &lt;TextBlock Grid.Row="0" Grid.Column="0" Text="姓名：" /&gt;
    &lt;TextBox Grid.Row="0" Grid.Column="1" /&gt;

    &lt;TextBlock Grid.Row="1" Grid.Column="0" Text="地址：" /&gt;
    &lt;TextBox Grid.Row="1" Grid.Column="1" /&gt;
&lt;/Grid&gt;
</code></pre> 
<p>案例二：表格布局</p> 
<p>通过使用Grid控件，可以实现表格布局的效果，将数据以行和列的形式显示。每个单元格可以放置文本、图像或其他控件，使得数据呈现更加清晰和整齐。</p> 
<pre><code class="prism language-xaml">&lt;!--这个案例中，我们使用Grid控件创建了一个简单的表格布局。其中，第一行定义了表头，显示了"ID"、"姓名"和"年龄"三列的标题。接下来的两行显示了具体的数据，每个单元格都是一个文本块(TextBlock)。。--&gt;
&lt;Grid&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="Auto" /&gt;
        &lt;RowDefinition Height="Auto" /&gt;
        &lt;RowDefinition Height="Auto" /&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width="Auto" /&gt;
        &lt;ColumnDefinition Width="Auto" /&gt;
        &lt;ColumnDefinition Width="Auto" /&gt;
    &lt;/Grid.ColumnDefinitions&gt;

    &lt;TextBlock Grid.Row="0" Grid.Column="0" Text="ID" /&gt;
    &lt;TextBlock Grid.Row="0" Grid.Column="1" Text="姓名" /&gt;
    &lt;TextBlock Grid.Row="0" Grid.Column="2" Text="年龄" /&gt;

    &lt;TextBlock Grid.Row="1" Grid.Column="0" Text="1" /&gt;
    &lt;TextBlock Grid.Row="1" Grid.Column="1" Text="John" /&gt;
    &lt;TextBlock Grid.Row="1" Grid.Column="2" Text="25" /&gt;

    &lt;TextBlock Grid.Row="2" Grid.Column="0" Text="2" /&gt;
    &lt;TextBlock Grid.Row="2" Grid.Column="1" Text="Jane" /&gt;
    &lt;TextBlock Grid.Row="2" Grid.Column="2" Text="30" /&gt;
&lt;/Grid&gt;
</code></pre> 
<p>案例三：响应式布局</p> 
<p>Grid控件允许我们使用行和列的定义来自适应不同的屏幕尺寸和分辨率。我们可以通过设置行和列的大小、比例和对齐方式，使布局在不同设备上具有良好的可读性和可用性。</p> 
<pre><code class="prism language-xaml">&lt;!--这个案例中，我们创建了一个响应式布局，其中内容区域占据了整个可用空间。无论窗口尺寸如何变化，内容区域都会自动填充剩余空间。提交按钮则位于网格的右下角。--&gt;
&lt;Grid&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="*" /&gt;
        &lt;RowDefinition Height="Auto" /&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width="*" /&gt;
        &lt;ColumnDefinition Width="Auto" /&gt;
    &lt;/Grid.ColumnDefinitions&gt;

    &lt;TextBlock Grid.Row="0" Grid.Column="0" Text="内容区域" /&gt;

    &lt;Button Grid.Row="1" Grid.Column="1" Content="提交" /&gt;
&lt;/Grid&gt;
</code></pre> 
<h4><a id="36UniformGrid_409"></a>3.6.UniformGrid控件</h4> 
<p>UniformGrid控件是WPF中的一种特殊网格布局控件，它提供了一种均匀分布子元素的布局方式。与普通的Grid控件不同，UniformGrid控件会自动将子元素均匀地分布在行和列中，使它们具有相同的大小。</p> 
<p>UniformGrid控件的布局是基于行和列的定义，您可以在XAML中指定行和列的数量。与Grid控件不同的是，UniformGrid控件会自动调整子元素的大小以适应每个单元格的大小，从而实现均匀分布的效果。</p> 
<h5><a id="361_415"></a>3.6.1.属性</h5> 
<ul><li>Rows：指定UniformGrid控件的行数。</li><li>Columns：指定UniformGrid控件的列数。</li><li>HorizontalAlignment：指定子元素在单元格中的水平对齐方式。</li><li>VerticalAlignment：指定子元素在单元格中的垂直对齐方式。</li></ul> 
<h5><a id="362_422"></a>3.6.2.案例</h5> 
<p>下面是一个简单的示例，演示了UniformGrid控件的使用：</p> 
<pre><code class="prism language-xaml">&lt;!--在这个示例中，UniformGrid控件被用来创建一个2行3列的布局。在每个单元格中，我们放置了一个按钮(Button)元素。UniformGrid控件会自动将这些按钮均匀地分布在2行3列的布局中，使它们具有相同的大小和间距。--&gt;
&lt;UniformGrid Rows="2" Columns="3"&gt;
    &lt;Button Content="按钮1" /&gt;
    &lt;Button Content="按钮2" /&gt;
    &lt;Button Content="按钮3" /&gt;
    &lt;Button Content="按钮4" /&gt;
    &lt;Button Content="按钮5" /&gt;
    &lt;Button Content="按钮6" /&gt;
&lt;/UniformGrid&gt;
</code></pre> 
<p>好的，让我重新回答您关于Canvas控件的问题。</p> 
<h4><a id="37Canvas_440"></a>3.7.Canvas控件</h4> 
<p>Canvas控件是WPF中常用的布局控件之一，它提供了自由定位的布局方式，允许您在其中放置控件或元素，并通过指定它们的位置和大小来精确控制它们的布局。</p> 
<h5><a id="371_444"></a>3.7.1.属性</h5> 
<p>Canvas控件具有以下常用属性：</p> 
<ul><li>Background：用于设置Canvas的背景颜色。</li><li>ClipToBounds：指定是否裁剪超出Canvas边界的子元素。</li><li>IsItemsHost：指定是否作为ItemsControl的主机。</li><li>AllowDrop：指定是否允许从其他控件拖放元素到Canvas上。</li><li>Children：用于访问Canvas中的子元素集合。</li></ul> 
<p>此外，Canvas控件还提供了一些用于定位子元素的特定属性：</p> 
<ul><li>Canvas.Left：指定子元素相对于Canvas左侧的位置。</li><li>Canvas.Top：指定子元素相对于Canvas顶部的位置。</li><li>Canvas.Right：指定子元素相对于Canvas右侧的位置。</li><li>Canvas.Bottom：指定子元素相对于Canvas底部的位置。</li></ul> 
<h5><a id="372_461"></a>3.7.2.案例</h5> 
<p>案例一：自由定位按钮</p> 
<p>Canvas控件允许您通过设置子元素的位置属性来自由定位它们。在下面的示例中，我们创建了一个Canvas控件，并将两个按钮放置在其中，分别位于指定的位置。</p> 
<pre><code class="prism language-xaml">&lt;Canvas&gt;
    &lt;Button Content="按钮1" Canvas.Left="100" Canvas.Top="50" /&gt;
    &lt;Button Content="按钮2" Canvas.Left="200" Canvas.Top="100" /&gt;
&lt;/Canvas&gt;
</code></pre> 
<p>案例二：动态绘制图形</p> 
<p>Canvas控件常用于动态绘制图形，您可以使用画布上的绘图工具（如Path、Rectangle等）创建形状，并通过设置其位置和尺寸属性来控制绘制的图形。</p> 
<pre><code class="prism language-xaml">&lt;Canvas&gt;
    &lt;Rectangle Canvas.Left="50" Canvas.Top="50" Width="100" Height="50" Fill="Red" /&gt;
    &lt;Ellipse Canvas.Left="150" Canvas.Top="150" Width="80" Height="80" Fill="Blue" /&gt;
&lt;/Canvas&gt;
</code></pre> 
<p>案例三：拖放操作</p> 
<p>Canvas控件可以与拖放操作结合使用，允许您从其他控件拖动元素到Canvas上，并在Canvas中放置它们。以下是一个简单的示例，演示了将文本框从StackPanel拖放到Canvas上的操作。</p> 
<pre><code class="prism language-xaml">&lt;StackPanel&gt;
    &lt;TextBox Text="可拖动的文本框" PreviewMouseLeftButtonDown="TextBox_PreviewMouseLeftButtonDown" /&gt;
&lt;/StackPanel&gt;
&lt;Canvas AllowDrop="True" Drop="Canvas_Drop"&gt;
    &lt;!--这里可以放置拖放后的元素--&gt;
&lt;/Canvas&gt;
</code></pre> 
<pre><code class="prism language-csharp"><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TextBox_PreviewMouseLeftButtonDown</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> sender<span class="token punctuation">,</span> <span class="token class-name">MouseButtonEventArgs</span> e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name">TextBox</span> textBox <span class="token operator">=</span> <span class="token punctuation">(</span>TextBox<span class="token punctuation">)</span>sender<span class="token punctuation">;</span>
    DragDrop<span class="token punctuation">.</span><span class="token function">DoDragDrop</span><span class="token punctuation">(</span>textBox<span class="token punctuation">,</span> textBox<span class="token punctuation">.</span>Text<span class="token punctuation">,</span> DragDropEffects<span class="token punctuation">.</span>Move<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Canvas_Drop</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> sender<span class="token punctuation">,</span> <span class="token class-name">DragEventArgs</span> e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name"><span class="token keyword">string</span></span> text <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">)</span>e<span class="token punctuation">.</span>Data<span class="token punctuation">.</span><span class="token function">GetData</span><span class="token punctuation">(</span>DataFormats<span class="token punctuation">.</span>StringFormat<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">TextBox</span> textBox <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TextBox</span> <span class="token punctuation">{<!-- --></span> Text <span class="token operator">=</span> text <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token class-name">Canvas</span> canvas <span class="token operator">=</span> <span class="token punctuation">(</span>Canvas<span class="token punctuation">)</span>sender<span class="token punctuation">;</span>
    canvas<span class="token punctuation">.</span>Children<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>textBox<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Canvas<span class="token punctuation">.</span><span class="token function">SetLeft</span><span class="token punctuation">(</span>textBox<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">GetPosition</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">.</span>X<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Canvas<span class="token punctuation">.</span><span class="token function">SetTop</span><span class="token punctuation">(</span>textBox<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">GetPosition</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">.</span>Y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>好的，以下是关于InkCanvas控件的介绍：</p> 
<h4><a id="38InkCanvas_518"></a>3.8.InkCanvas控件</h4> 
<p>InkCanvas控件是WPF中用于绘制和捕捉手写笔迹的控件。它提供了一个可以自由绘制的画布，并支持使用数字笔或触摸设备进行手写输入。InkCanvas控件是创建手写笔迹、签名、绘图应用程序等的理想选择。</p> 
<h5><a id="381_522"></a>3.8.1.属性</h5> 
<ul><li>Background：用于设置InkCanvas的背景颜色。</li><li>DefaultDrawingAttributes：指定默认的绘制属性，如笔刷颜色、粗细等。</li><li>Strokes：用于访问InkCanvas中的笔迹集合。</li><li>EditingMode：指定InkCanvas的编辑模式，如绘制、擦除等。</li><li>EraserShape：指定橡皮擦的形状，如圆形、矩形等。</li></ul> 
<h5><a id="382_530"></a>3.8.2.案例</h5> 
<p>案例一：绘制手写笔迹</p> 
<p>通过InkCanvas控件，您可以捕捉用户的手写笔迹。下面的示例展示了如何创建一个简单的InkCanvas，并允许用户在其中绘制。</p> 
<pre><code class="prism language-xaml">&lt;InkCanvas /&gt;
</code></pre> 
<p>案例二：设置默认绘制属性</p> 
<p>您可以通过DefaultDrawingAttributes属性设置默认的绘制属性，如笔刷颜色、粗细等。以下示例将InkCanvas的默认绘制属性设置为红色笔刷和较粗的笔宽。</p> 
<pre><code class="prism language-xaml">&lt;InkCanvas&gt;
    &lt;InkCanvas.DefaultDrawingAttributes&gt;
        &lt;DrawingAttributes Color="Red" Width="5" /&gt;
    &lt;/InkCanvas.DefaultDrawingAttributes&gt;
&lt;/InkCanvas&gt;
</code></pre> 
<p>案例三：擦除手写笔迹</p> 
<p>InkCanvas控件支持擦除手写笔迹。您可以将EditingMode属性设置为EraseByPoint或EraseByStroke来启用擦除功能。以下示例演示了如何在InkCanvas中启用擦除功能。</p> 
<pre><code class="prism language-xaml">&lt;InkCanvas EditingMode="EraseByPoint" /&gt;
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/972090fbcd3ee2bfe5bbdf5b5a1a05e2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端构建工具vite与webpack详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d6ff0a9922d6944a0e121bfe6cfe8657/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">安装pycharm中第三方库不成功（以pesq为例）的解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>