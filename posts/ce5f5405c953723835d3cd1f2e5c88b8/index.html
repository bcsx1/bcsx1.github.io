<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RTMPdump（libRTMP） 源代码分析 9： 接收消息（Message）（接收视音频数据） - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RTMPdump（libRTMP） 源代码分析 9： 接收消息（Message）（接收视音频数据）" />
<meta property="og:description" content="=====================================================
RTMPdump(libRTMP) 源代码分析系列文章：
RTMPdump 源代码分析 1： main()函数
RTMPDump (libRTMP) 源代码分析2：解析RTMP地址——RTMP_ParseURL()
RTMPdump (libRTMP) 源代码分析3： AMF编码
RTMPdump (libRTMP) 源代码分析4： 连接第一步——握手 (HandShake)
RTMPdump (libRTMP) 源代码分析5： 建立一个流媒体连接 (NetConnection部分)
RTMPdump (libRTMP) 源代码分析6： 建立一个流媒体连接 (NetStream部分 1)
RTMPdump (libRTMP) 源代码分析7： 建立一个流媒体连接 (NetStream部分 2)
RTMPdump (libRTMP) 源代码分析8： 发送消息 (Message)
RTMPdump (libRTMP) 源代码分析9： 接收消息 (Message) (接收视音频数据)
RTMPdump (libRTMP) 源代码分析10： 处理各种消息 (Message)
=====================================================
函数调用结构图 RTMPDump (libRTMP)的整体的函数调用结构图如下图所示。
单击查看大图
详细分析 前一篇文章分析了RTMPdump（libRTMP） 的发送消息（Message）方面的源代码：RTMPdump（libRTMP） 源代码分析 8： 发送消息（Message）
在这里在研究研究接收消息（Message）的源代码，接收消息最典型的应用就是接收视音频数据了，因为视频和音频分别都属于RTMP协议规范中的一种消息。在这里主要分析接收视音频数据。
RTMPdump中完成视音频数据的接收（也可以说是视音频数据的下载）的函数是：RTMP_Read()。
RTMPdump主程序中的Download()函数就是通过调用RTMP_Read()完成数据接收，从而实现下载的。
那么我们马上开始吧，首先看看RTMP_Read()函数：
//FLV文件头 static const char flvHeader[] = { &#39;F&#39;, &#39;L&#39;, &#39;V&#39;, 0x01, 0x00,	/* 0x04代表有音频, 0x01代表有视频 */ 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00 }; #define HEADERBUF	(128*1024) int RTMP_Read(RTMP *r, char *buf, int size) { int nRead = 0, total = 0; /* can&#39;t continue */ fail: switch (r-&gt;m_read." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/ce5f5405c953723835d3cd1f2e5c88b8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-10-23T15:46:12+08:00" />
<meta property="article:modified_time" content="2013-10-23T15:46:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RTMPdump（libRTMP） 源代码分析 9： 接收消息（Message）（接收视音频数据）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p>=====================================================</p> 
<p>RTMPdump(libRTMP) 源代码分析系列文章：</p> 
<p><a target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/12952977" rel="noopener noreferrer"><span style="color: rgb(51, 102, 255);">RTMPdump 源代码分析 1： main()函数</span></a></p> 
<p><a target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/12953833" rel="noopener noreferrer"><span style="color:#3366ff;">RTMPDump (libRTMP) 源代码分析2：解析RTMP地址——RTMP_ParseURL()</span></a></p> 
<p><a target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/12954145" rel="noopener noreferrer"><span style="color:#3366ff;">RTMPdump (libRTMP) 源代码分析3： AMF编码</span></a></p> 
<p><a target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/12954329" rel="noopener noreferrer"><span style="color:#3366ff;">RTMPdump (libRTMP) 源代码分析4： 连接第一步——握手 (HandShake)</span></a></p> 
<p><a target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/12957291" rel="noopener noreferrer"><span style="color:#3366ff;">RTMPdump (libRTMP) 源代码分析5： 建立一个流媒体连接  (NetConnection部分)</span></a></p> 
<p><a target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/12957877" rel="noopener noreferrer"><span style="color:#3366ff;">RTMPdump (libRTMP) 源代码分析6： 建立一个流媒体连接  (NetStream部分 1)</span></a></p> 
<p><a target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/12958617" rel="noopener noreferrer"><span style="color:#3366ff;">RTMPdump (libRTMP) 源代码分析7： 建立一个流媒体连接  (NetStream部分 2)</span></a></p> 
<p><a target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/12958747" rel="noopener noreferrer"><span style="color:#3366ff;">RTMPdump (libRTMP) 源代码分析8： 发送消息 (Message)</span></a></p> 
<p><a target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/12971635" rel="noopener noreferrer"><span style="color:#3366ff;">RTMPdump (libRTMP) 源代码分析9： 接收消息 (Message)  (接收视音频数据)</span></a></p> 
<p><a target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/12972399" rel="noopener noreferrer"><span style="color:#3366ff;">RTMPdump (libRTMP) 源代码分析10： 处理各种消息 (Message)</span></a></p> 
<p>=====================================================</p> 
<p><br></p> 
<h3>函数调用结构图</h3> 
<p>RTMPDump (libRTMP)的整体的函数调用结构图如下图所示。</p> 
<p style="text-align: center;"><a target="_blank" href="https://img-my.csdn.net/uploads/201602/10/1455087168_7199.png" rel="nofollow noopener noreferrer"><img src="https://images2.imgbox.com/be/60/Ty97uN1R_o.png" alt=""><br></a></p> 
<p style="text-align: center;"><a target="_blank" href="https://img-my.csdn.net/uploads/201602/10/1455087168_7199.png" rel="nofollow noopener noreferrer">单击查看大图</a></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h3>详细分析</h3> 
<p>前一篇文章分析了RTMPdump（libRTMP） 的发送消息（Message）方面的源代码：<a target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/12958747" rel="noopener noreferrer">RTMPdump（libRTMP） 源代码分析 8： 发送消息（Message）</a></p> 
<p>在这里在研究研究接收消息（Message）的源代码，接收消息最典型的应用就是接收视音频数据了，因为视频和音频分别都属于RTMP协议规范中的一种消息。在这里主要分析接收视音频数据。</p> 
<p>RTMPdump中完成视音频数据的接收（也可以说是视音频数据的下载）的函数是：RTMP_Read()。<br></p> 
<p>RTMPdump主程序中的Download()函数就是通过调用RTMP_Read()完成数据接收，从而实现下载的。</p> 
<p>那么我们马上开始吧，首先看看RTMP_Read()函数：</p> 
<p></p> 
<pre><code class="language-cpp">//FLV文件头
static const char flvHeader[] = { 'F', 'L', 'V', 0x01,
  0x00,				/* 0x04代表有音频, 0x01代表有视频 */
  0x00, 0x00, 0x00, 0x09,
  0x00, 0x00, 0x00, 0x00
};

#define HEADERBUF	(128*1024)
int
RTMP_Read(RTMP *r, char *buf, int size)
{
  int nRead = 0, total = 0;

  /* can't continue */
fail:
  switch (r-&gt;m_read.status) {
  case RTMP_READ_EOF:
  case RTMP_READ_COMPLETE:
    return 0;
  case RTMP_READ_ERROR:  /* corrupted stream, resume failed */
    SetSockError(EINVAL);
    return -1;
  default:
    break;
  }

  /* first time thru */
  if (!(r-&gt;m_read.flags &amp; RTMP_READ_HEADER))
    {
      if (!(r-&gt;m_read.flags &amp; RTMP_READ_RESUME))
	{
	//分配内存，指向buf的首部和尾部
	  char *mybuf = (char *) malloc(HEADERBUF), *end = mybuf + HEADERBUF;
	  int cnt = 0;
	  //buf指向同一地址
	  r-&gt;m_read.buf = mybuf;
	  r-&gt;m_read.buflen = HEADERBUF;

	  //把Flv的首部复制到mybuf指向的内存
	  //RTMP传递的多媒体数据是“砍头”的FLV文件
	  memcpy(mybuf, flvHeader, sizeof(flvHeader));
	  //m_read.buf指针后移flvheader个单位
	  r-&gt;m_read.buf += sizeof(flvHeader);
	  //buf长度增加flvheader长度
	  r-&gt;m_read.buflen -= sizeof(flvHeader);
	  //timestamp=0，不是多媒体数据
	  while (r-&gt;m_read.timestamp == 0)
	    {
		//读取一个Packet，到r-&gt;m_read.buf
		//nRead为读取结果标记
	      nRead = Read_1_Packet(r, r-&gt;m_read.buf, r-&gt;m_read.buflen);
		  //有错误
	      if (nRead &lt; 0)
		{
		  free(mybuf);
		  r-&gt;m_read.buf = NULL;
		  r-&gt;m_read.buflen = 0;
		  r-&gt;m_read.status = nRead;
		  goto fail;
		}
	      /* buffer overflow, fix buffer and give up */
	      if (r-&gt;m_read.buf &lt; mybuf || r-&gt;m_read.buf &gt; end) {
	      	mybuf = (char *) realloc(mybuf, cnt + nRead);
		memcpy(mybuf+cnt, r-&gt;m_read.buf, nRead);
		r-&gt;m_read.buf = mybuf+cnt+nRead;
	        break;
	      }
		  //
		  //记录读取的字节数
	      cnt += nRead;
		  //m_read.buf指针后移nRead个单位
	      r-&gt;m_read.buf += nRead;
	      r-&gt;m_read.buflen -= nRead;
		  //当dataType=00000101时，即有视频和音频时
		  //说明有多媒体数据了
	      if (r-&gt;m_read.dataType == 5)
	        break;
	    }
	  //读入数据类型
	  //注意：mybuf指针位置一直没动
	  //mybuf[4]中第 6 位表示是否存在音频Tag。第 8 位表示是否存在视频Tag。 
	  mybuf[4] = r-&gt;m_read.dataType;
	  //两个指针之间的差
	  r-&gt;m_read.buflen = r-&gt;m_read.buf - mybuf;
	  r-&gt;m_read.buf = mybuf;
	  //这句很重要！后面memcopy
	  r-&gt;m_read.bufpos = mybuf;
	}
	  //flags标明已经读完了文件头
      r-&gt;m_read.flags |= RTMP_READ_HEADER;
    }

  if ((r-&gt;m_read.flags &amp; RTMP_READ_SEEKING) &amp;&amp; r-&gt;m_read.buf)
    {
      /* drop whatever's here */
      free(r-&gt;m_read.buf);
      r-&gt;m_read.buf = NULL;
      r-&gt;m_read.bufpos = NULL;
      r-&gt;m_read.buflen = 0;
    }

  /* If there's leftover data buffered, use it up */
  if (r-&gt;m_read.buf)
    {
      nRead = r-&gt;m_read.buflen;
      if (nRead &gt; size)
	nRead = size;
	  //m_read.bufpos指向mybuf
      memcpy(buf, r-&gt;m_read.bufpos, nRead);
      r-&gt;m_read.buflen -= nRead;
      if (!r-&gt;m_read.buflen)
	{
	  free(r-&gt;m_read.buf);
	  r-&gt;m_read.buf = NULL;
	  r-&gt;m_read.bufpos = NULL;
	}
      else
	{
	  r-&gt;m_read.bufpos += nRead;
	}
      buf += nRead;
      total += nRead;
      size -= nRead;
    }
  //接着读
  while (size &gt; 0 &amp;&amp; (nRead = Read_1_Packet(r, buf, size)) &gt;= 0)
    {
      if (!nRead) continue;
      buf += nRead;
      total += nRead;
      size -= nRead;
      break;
    }
  if (nRead &lt; 0)
    r-&gt;m_read.status = nRead;

  if (size &lt; 0)
    total += size;
  return total;
}</code></pre> 
<br>程序关键的地方都已经注释上了代码，在此就不重复说明了。有一点要提一下：RTMP传送的视音频数据的格式和FLV（FLash Video）格式是一样的，把接收下来的数据直接存入文件就可以了。但是这些视音频数据没有文件头，是纯视音频数据，因此需要在其前面加上FLV格式的文件头，这样得到的数据存成文件后才能被一般的视频播放器所播放。FLV格式的文件头是13个字节，如代码中所示。 
<p></p> 
<p><br></p> 
<p>RTMP_Read()中实际读取数据的函数是Read_1_Packet()，它的功能是从网络上读取一个RTMPPacket的数据，来看看它的源代码吧：<br></p> 
<p></p> 
<pre><code class="language-cpp">/* 从流媒体中读取多媒体packet。
 * Returns -3 if Play.Close/Stop, -2 if fatal error, -1 if no more media
 * packets, 0 if ignorable error, &gt;0 if there is a media packet
 */
static int
Read_1_Packet(RTMP *r, char *buf, unsigned int buflen)
{
  uint32_t prevTagSize = 0;
  int rtnGetNextMediaPacket = 0, ret = RTMP_READ_EOF;
  RTMPPacket packet = { 0 };
  int recopy = FALSE;
  unsigned int size;
  char *ptr, *pend;
  uint32_t nTimeStamp = 0;
  unsigned int len;
  //获取下一个packet
  rtnGetNextMediaPacket = RTMP_GetNextMediaPacket(r, &amp;packet);
  while (rtnGetNextMediaPacket)
    {
      char *packetBody = packet.m_body;
      unsigned int nPacketLen = packet.m_nBodySize;

      /* Return -3 if this was completed nicely with invoke message
       * Play.Stop or Play.Complete
       */
      if (rtnGetNextMediaPacket == 2)
	{
	  RTMP_Log(RTMP_LOGDEBUG,
	      "Got Play.Complete or Play.Stop from server. "
	      "Assuming stream is complete");
	  ret = RTMP_READ_COMPLETE;
	  break;
	}
	  //设置dataType
      r-&gt;m_read.dataType |= (((packet.m_packetType == 0x08) &lt;&lt; 2) |
			     (packet.m_packetType == 0x09));
	  //MessageID为9时，为视频数据，数据太小时。。。
      if (packet.m_packetType == 0x09 &amp;&amp; nPacketLen &lt;= 5)
	{
	  RTMP_Log(RTMP_LOGDEBUG, "ignoring too small video packet: size: %d",
	      nPacketLen);
	  ret = RTMP_READ_IGNORE;
	  break;
	}
	  //MessageID为8时，为音频数据，数据太小时。。。
      if (packet.m_packetType == 0x08 &amp;&amp; nPacketLen &lt;= 1)
	{
	  RTMP_Log(RTMP_LOGDEBUG, "ignoring too small audio packet: size: %d",
	      nPacketLen);
	  ret = RTMP_READ_IGNORE;
	  break;
	}

      if (r-&gt;m_read.flags &amp; RTMP_READ_SEEKING)
	{
	  ret = RTMP_READ_IGNORE;
	  break;
	}
#ifdef _DEBUG
      RTMP_Log(RTMP_LOGDEBUG, "type: %02X, size: %d, TS: %d ms, abs TS: %d",
	  packet.m_packetType, nPacketLen, packet.m_nTimeStamp,
	  packet.m_hasAbsTimestamp);
      if (packet.m_packetType == 0x09)
	RTMP_Log(RTMP_LOGDEBUG, "frametype: %02X", (*packetBody &amp; 0xf0));
#endif

      if (r-&gt;m_read.flags &amp; RTMP_READ_RESUME)
	{
	  /* check the header if we get one */
		//此类packet的timestamp都是0
	  if (packet.m_nTimeStamp == 0)
	    {
		//messageID=18，数据消息（AMF0）
	      if (r-&gt;m_read.nMetaHeaderSize &gt; 0
		  &amp;&amp; packet.m_packetType == 0x12)
		{
		//获取metadata
		  AMFObject metaObj;
		  int nRes =
		    AMF_Decode(&amp;metaObj, packetBody, nPacketLen, FALSE);
		  if (nRes &gt;= 0)
		    {
		      AVal metastring;
		      AMFProp_GetString(AMF_GetProp(&amp;metaObj, NULL, 0),
					&amp;metastring);

		      if (AVMATCH(&amp;metastring, &amp;av_onMetaData))
			{
			  /* compare */
			  if ((r-&gt;m_read.nMetaHeaderSize != nPacketLen) ||
			      (memcmp
			       (r-&gt;m_read.metaHeader, packetBody,
				r-&gt;m_read.nMetaHeaderSize) != 0))
			    {
			      ret = RTMP_READ_ERROR;
			    }
			}
		      AMF_Reset(&amp;metaObj);
		      if (ret == RTMP_READ_ERROR)
			break;
		    }
		}

	      /* check first keyframe to make sure we got the right position
	       * in the stream! (the first non ignored frame)
	       */
	      if (r-&gt;m_read.nInitialFrameSize &gt; 0)
		{
		  /* video or audio data */
		  if (packet.m_packetType == r-&gt;m_read.initialFrameType
		      &amp;&amp; r-&gt;m_read.nInitialFrameSize == nPacketLen)
		    {
		      /* we don't compare the sizes since the packet can
		       * contain several FLV packets, just make sure the
		       * first frame is our keyframe (which we are going
		       * to rewrite)
		       */
		      if (memcmp
			  (r-&gt;m_read.initialFrame, packetBody,
			   r-&gt;m_read.nInitialFrameSize) == 0)
			{
			  RTMP_Log(RTMP_LOGDEBUG, "Checked keyframe successfully!");
			  r-&gt;m_read.flags |= RTMP_READ_GOTKF;
			  /* ignore it! (what about audio data after it? it is
			   * handled by ignoring all 0ms frames, see below)
			   */
			  ret = RTMP_READ_IGNORE;
			  break;
			}
		    }

		  /* hande FLV streams, even though the server resends the
		   * keyframe as an extra video packet it is also included
		   * in the first FLV stream chunk and we have to compare
		   * it and filter it out !!
		   */
		  //MessageID=22，聚合消息
		  if (packet.m_packetType == 0x16)
		    {
		      /* basically we have to find the keyframe with the
		       * correct TS being nResumeTS
		       */
		      unsigned int pos = 0;
		      uint32_t ts = 0;

		      while (pos + 11 &lt; nPacketLen)
			{
			  /* size without header (11) and prevTagSize (4) */
			  uint32_t dataSize =
			    AMF_DecodeInt24(packetBody + pos + 1);
			  ts = AMF_DecodeInt24(packetBody + pos + 4);
			  ts |= (packetBody[pos + 7] &lt;&lt; 24);

#ifdef _DEBUG
			  RTMP_Log(RTMP_LOGDEBUG,
			      "keyframe search: FLV Packet: type %02X, dataSize: %d, timeStamp: %d ms",
			      packetBody[pos], dataSize, ts);
#endif
			  /* ok, is it a keyframe?:
			   * well doesn't work for audio!
			   */
			  if (packetBody[pos /*6928, test 0 */ ] ==
			      r-&gt;m_read.initialFrameType
			      /* &amp;&amp; (packetBody[11]&amp;0xf0) == 0x10 */ )
			    {
			      if (ts == r-&gt;m_read.nResumeTS)
				{
				  RTMP_Log(RTMP_LOGDEBUG,
				      "Found keyframe with resume-keyframe timestamp!");
				  if (r-&gt;m_read.nInitialFrameSize != dataSize
				      || memcmp(r-&gt;m_read.initialFrame,
						packetBody + pos + 11,
						r-&gt;m_read.
						nInitialFrameSize) != 0)
				    {
				      RTMP_Log(RTMP_LOGERROR,
					  "FLV Stream: Keyframe doesn't match!");
				      ret = RTMP_READ_ERROR;
				      break;
				    }
				  r-&gt;m_read.flags |= RTMP_READ_GOTFLVK;

				  /* skip this packet?
				   * check whether skippable:
				   */
				  if (pos + 11 + dataSize + 4 &gt; nPacketLen)
				    {
				      RTMP_Log(RTMP_LOGWARNING,
					  "Non skipable packet since it doesn't end with chunk, stream corrupt!");
				      ret = RTMP_READ_ERROR;
				      break;
				    }
				  packetBody += (pos + 11 + dataSize + 4);
				  nPacketLen -= (pos + 11 + dataSize + 4);

				  goto stopKeyframeSearch;

				}
			      else if (r-&gt;m_read.nResumeTS &lt; ts)
				{
				  /* the timestamp ts will only increase with
				   * further packets, wait for seek
				   */
				  goto stopKeyframeSearch;
				}
			    }
			  pos += (11 + dataSize + 4);
			}
		      if (ts &lt; r-&gt;m_read.nResumeTS)
			{
			  RTMP_Log(RTMP_LOGERROR,
			      "First packet does not contain keyframe, all "
			      "timestamps are smaller than the keyframe "
			      "timestamp; probably the resume seek failed?");
			}
		    stopKeyframeSearch:
		      ;
		      if (!(r-&gt;m_read.flags &amp; RTMP_READ_GOTFLVK))
			{
			  RTMP_Log(RTMP_LOGERROR,
			      "Couldn't find the seeked keyframe in this chunk!");
			  ret = RTMP_READ_IGNORE;
			  break;
			}
		    }
		}
	    }

	  if (packet.m_nTimeStamp &gt; 0
	      &amp;&amp; (r-&gt;m_read.flags &amp; (RTMP_READ_GOTKF|RTMP_READ_GOTFLVK)))
	    {
	      /* another problem is that the server can actually change from
	       * 09/08 video/audio packets to an FLV stream or vice versa and
	       * our keyframe check will prevent us from going along with the
	       * new stream if we resumed.
	       *
	       * in this case set the 'found keyframe' variables to true.
	       * We assume that if we found one keyframe somewhere and were
	       * already beyond TS &gt; 0 we have written data to the output
	       * which means we can accept all forthcoming data including the
	       * change between 08/09 &lt;-&gt; FLV packets
	       */
	      r-&gt;m_read.flags |= (RTMP_READ_GOTKF|RTMP_READ_GOTFLVK);
	    }

	  /* skip till we find our keyframe
	   * (seeking might put us somewhere before it)
	   */
	  if (!(r-&gt;m_read.flags &amp; RTMP_READ_GOTKF) &amp;&amp;
	  	packet.m_packetType != 0x16)
	    {
	      RTMP_Log(RTMP_LOGWARNING,
		  "Stream does not start with requested frame, ignoring data... ");
	      r-&gt;m_read.nIgnoredFrameCounter++;
	      if (r-&gt;m_read.nIgnoredFrameCounter &gt; MAX_IGNORED_FRAMES)
		ret = RTMP_READ_ERROR;	/* fatal error, couldn't continue stream */
	      else
		ret = RTMP_READ_IGNORE;
	      break;
	    }
	  /* ok, do the same for FLV streams */
	  if (!(r-&gt;m_read.flags &amp; RTMP_READ_GOTFLVK) &amp;&amp;
	  	packet.m_packetType == 0x16)
	    {
	      RTMP_Log(RTMP_LOGWARNING,
		  "Stream does not start with requested FLV frame, ignoring data... ");
	      r-&gt;m_read.nIgnoredFlvFrameCounter++;
	      if (r-&gt;m_read.nIgnoredFlvFrameCounter &gt; MAX_IGNORED_FRAMES)
		ret = RTMP_READ_ERROR;
	      else
		ret = RTMP_READ_IGNORE;
	      break;
	    }

	  /* we have to ignore the 0ms frames since these are the first
	   * keyframes; we've got these so don't mess around with multiple
	   * copies sent by the server to us! (if the keyframe is found at a
	   * later position there is only one copy and it will be ignored by
	   * the preceding if clause)
	   */
	  if (!(r-&gt;m_read.flags &amp; RTMP_READ_NO_IGNORE) &amp;&amp;
	  	packet.m_packetType != 0x16)
	    {			/* exclude type 0x16 (FLV) since it can
				 * contain several FLV packets */
	      if (packet.m_nTimeStamp == 0)
		{
		  ret = RTMP_READ_IGNORE;
		  break;
		}
	      else
		{
		  /* stop ignoring packets */
		  r-&gt;m_read.flags |= RTMP_READ_NO_IGNORE;
		}
	    }
	}

      /* calculate packet size and allocate slop buffer if necessary */
      size = nPacketLen +
	((packet.m_packetType == 0x08 || packet.m_packetType == 0x09
	  || packet.m_packetType == 0x12) ? 11 : 0) +
	(packet.m_packetType != 0x16 ? 4 : 0);

      if (size + 4 &gt; buflen)
	{
	  /* the extra 4 is for the case of an FLV stream without a last
	   * prevTagSize (we need extra 4 bytes to append it) */
	  r-&gt;m_read.buf = (char *) malloc(size + 4);
	  if (r-&gt;m_read.buf == 0)
	    {
	      RTMP_Log(RTMP_LOGERROR, "Couldn't allocate memory!");
	      ret = RTMP_READ_ERROR;		/* fatal error */
	      break;
	    }
	  recopy = TRUE;
	  ptr = r-&gt;m_read.buf;
	}
      else
	{
	  ptr = buf;
	}
      pend = ptr + size + 4;

      /* use to return timestamp of last processed packet */

      /* audio (0x08), video (0x09) or metadata (0x12) packets :
       * construct 11 byte header then add rtmp packet's data */
      if (packet.m_packetType == 0x08 || packet.m_packetType == 0x09
	  || packet.m_packetType == 0x12)
	{
	  nTimeStamp = r-&gt;m_read.nResumeTS + packet.m_nTimeStamp;
	  prevTagSize = 11 + nPacketLen;

	  *ptr = packet.m_packetType;
	  ptr++;
	  ptr = AMF_EncodeInt24(ptr, pend, nPacketLen);

#if 0
	    if(packet.m_packetType == 0x09) { /* video */

	     /* H264 fix: */
	     if((packetBody[0] &amp; 0x0f) == 7) { /* CodecId = H264 */
	     uint8_t packetType = *(packetBody+1);

	     uint32_t ts = AMF_DecodeInt24(packetBody+2); /* composition time */
	     int32_t cts = (ts+0xff800000)^0xff800000;
	     RTMP_Log(RTMP_LOGDEBUG, "cts  : %d\n", cts);

	     nTimeStamp -= cts;
	     /* get rid of the composition time */
	     CRTMP::EncodeInt24(packetBody+2, 0);
	     }
	     RTMP_Log(RTMP_LOGDEBUG, "VIDEO: nTimeStamp: 0x%08X (%d)\n", nTimeStamp, nTimeStamp);
	     }
#endif

	  ptr = AMF_EncodeInt24(ptr, pend, nTimeStamp);
	  *ptr = (char)((nTimeStamp &amp; 0xFF000000) &gt;&gt; 24);
	  ptr++;

	  /* stream id */
	  ptr = AMF_EncodeInt24(ptr, pend, 0);
	}

      memcpy(ptr, packetBody, nPacketLen);
      len = nPacketLen;

      /* correct tagSize and obtain timestamp if we have an FLV stream */
      if (packet.m_packetType == 0x16)
	{
	  unsigned int pos = 0;
	  int delta;

	  /* grab first timestamp and see if it needs fixing */
//	  nTimeStamp = AMF_DecodeInt24(packetBody + 4);
	//  nTimeStamp |= (packetBody[7] &lt;&lt; 24);
//	  delta = packet.m_nTimeStamp - nTimeStamp;

	  while (pos + 11 &lt; nPacketLen)
	    {
	      /* size without header (11) and without prevTagSize (4) */
	      uint32_t dataSize = AMF_DecodeInt24(packetBody + pos + 1);
	      nTimeStamp = AMF_DecodeInt24(packetBody + pos + 4);
	      nTimeStamp |= (packetBody[pos + 7] &lt;&lt; 24);

//	      if (delta)
//		{
//		  nTimeStamp += delta;
//		  AMF_EncodeInt24(ptr+pos+4, pend, nTimeStamp);
//		  ptr[pos+7] = nTimeStamp&gt;&gt;24;
//		}

	      /* set data type */
	      r-&gt;m_read.dataType |= (((*(packetBody + pos) == 0x08) &lt;&lt; 2) |
				     (*(packetBody + pos) == 0x09));

	      if (pos + 11 + dataSize + 4 &gt; nPacketLen)
		{
		  if (pos + 11 + dataSize &gt; nPacketLen)
		    {
		      RTMP_Log(RTMP_LOGERROR,
			  "Wrong data size (%lu), stream corrupted, aborting!",
			  dataSize);
		      ret = RTMP_READ_ERROR;
		      break;
		    }
		  RTMP_Log(RTMP_LOGWARNING, "No tagSize found, appending!");

		  /* we have to append a last tagSize! */
		  prevTagSize = dataSize + 11;
		  AMF_EncodeInt32(ptr + pos + 11 + dataSize, pend,
				  prevTagSize);
		  size += 4;
		  len += 4;
		}
	      else
		{
		  prevTagSize =
		    AMF_DecodeInt32(packetBody + pos + 11 + dataSize);

#ifdef _DEBUG
		  RTMP_Log(RTMP_LOGDEBUG,
		      "FLV Packet: type %02X, dataSize: %lu, tagSize: %lu, timeStamp: %lu ms",
		      (unsigned char)packetBody[pos], dataSize, prevTagSize,
		      nTimeStamp);
#endif

		  if (prevTagSize != (dataSize + 11))
		    {
#ifdef _DEBUG
		      RTMP_Log(RTMP_LOGWARNING,
			  "Tag and data size are not consitent, writing tag size according to dataSize+11: %d",
			  dataSize + 11);
#endif

		      prevTagSize = dataSize + 11;
		      AMF_EncodeInt32(ptr + pos + 11 + dataSize, pend,
				      prevTagSize);
		    }
		}

	      pos += prevTagSize + 4;	/*(11+dataSize+4); */
	    }
	}
      ptr += len;

      if (packet.m_packetType != 0x16)
	{
	  /* FLV tag packets contain their own prevTagSize */
	  AMF_EncodeInt32(ptr, pend, prevTagSize);
	}

      /* In non-live this nTimeStamp can contain an absolute TS.
       * Update ext timestamp with this absolute offset in non-live mode
       * otherwise report the relative one
       */
      /* RTMP_Log(RTMP_LOGDEBUG, "type: %02X, size: %d, pktTS: %dms, TS: %dms, bLiveStream: %d", packet.m_packetType, nPacketLen, packet.m_nTimeStamp, nTimeStamp, r-&gt;Link.lFlags &amp; RTMP_LF_LIVE); */
      r-&gt;m_read.timestamp = (r-&gt;Link.lFlags &amp; RTMP_LF_LIVE) ? packet.m_nTimeStamp : nTimeStamp;

      ret = size;
      break;
    }

  if (rtnGetNextMediaPacket)
    RTMPPacket_Free(&amp;packet);

  if (recopy)
    {
      len = ret &gt; buflen ? buflen : ret;
      memcpy(buf, r-&gt;m_read.buf, len);
      r-&gt;m_read.bufpos = r-&gt;m_read.buf + len;
      r-&gt;m_read.buflen = ret - len;
    }
  return ret;
}</code></pre> 
<br>函数功能很多，重要的地方已经加上了注释，在此不再细分析。Read_1_Packet()里面实现从网络中读取视音频数据的函数是RTMP_GetNextMediaPacket()。下面我们来看看该函数的源代码： 
<p></p> 
<p></p> 
<pre><code class="language-cpp">int
RTMP_GetNextMediaPacket(RTMP *r, RTMPPacket *packet)
{
  int bHasMediaPacket = 0;

  while (!bHasMediaPacket &amp;&amp; RTMP_IsConnected(r)
	 &amp;&amp; RTMP_ReadPacket(r, packet))
    {
      if (!RTMPPacket_IsReady(packet))
	{
	  continue;
	}

      bHasMediaPacket = RTMP_ClientPacket(r, packet);

      if (!bHasMediaPacket)
	{
	  RTMPPacket_Free(packet);
	}
      else if (r-&gt;m_pausing == 3)
	{
	  if (packet-&gt;m_nTimeStamp &lt;= r-&gt;m_mediaStamp)
	    {
	      bHasMediaPacket = 0;
#ifdef _DEBUG
	      RTMP_Log(RTMP_LOGDEBUG,
		  "Skipped type: %02X, size: %d, TS: %d ms, abs TS: %d, pause: %d ms",
		  packet-&gt;m_packetType, packet-&gt;m_nBodySize,
		  packet-&gt;m_nTimeStamp, packet-&gt;m_hasAbsTimestamp,
		  r-&gt;m_mediaStamp);
#endif
	      continue;
	    }
	  r-&gt;m_pausing = 0;
	}
    }

  if (bHasMediaPacket)
    r-&gt;m_bPlaying = TRUE;
  else if (r-&gt;m_sb.sb_timedout &amp;&amp; !r-&gt;m_pausing)
    r-&gt;m_pauseStamp = r-&gt;m_channelTimestamp[r-&gt;m_mediaChannel];

  return bHasMediaPacket;
}</code></pre> 
<br>这里有两个函数比较重要：RTMP_ReadPacket()以及RTMP_ClientPacket()。这两个函数中，前一个函数负责从网络上读取数据，后一个负责处理数据。这部分与建立RTMP连接的网络流（NetStream）的时候很相似，参考： 
<a target="_blank" href="http://blog.csdn.net/leixiaohua1020/article/details/12957877" style="line-height:30px; font-family:'Microsoft YaHei'; text-decoration:none" rel="noopener noreferrer"><span style="font-size: 14px; color: rgb(102, 0, 0);">RTMPdump（libRTMP） 源代码分析 6： 建立一个流媒体连接 （NetStream部分 1）</span></a> 
<p></p> 
<p>RTMP_ClientPacket()在前文中已经做过分析，在此不再重复叙述。在这里重点分析一下RTMP_ReadPacket()，来看看它的源代码。<br></p> 
<p></p> 
<pre><code class="language-cpp">//读取收下来的Chunk
int
RTMP_ReadPacket(RTMP *r, RTMPPacket *packet)
{
	//packet 存读取完后的的数据
	//Chunk Header最大值18
  uint8_t hbuf[RTMP_MAX_HEADER_SIZE] = { 0 };
	//header 指向的是从Socket中收下来的数据
  char *header = (char *)hbuf;
  int nSize, hSize, nToRead, nChunk;
  int didAlloc = FALSE;

  RTMP_Log(RTMP_LOGDEBUG2, "%s: fd=%d", __FUNCTION__, r-&gt;m_sb.sb_socket);
  //收下来的数据存入hbuf
  if (ReadN(r, (char *)hbuf, 1) == 0)
    {
      RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header", __FUNCTION__);
      return FALSE;
    }
  //块类型fmt
  packet-&gt;m_headerType = (hbuf[0] &amp; 0xc0) &gt;&gt; 6;
  //块流ID（2-63）
  packet-&gt;m_nChannel = (hbuf[0] &amp; 0x3f);
  header++;
  //块流ID第1字节为0时，块流ID占2个字节
  if (packet-&gt;m_nChannel == 0)
    {
      if (ReadN(r, (char *)&amp;hbuf[1], 1) != 1)
	{
	  RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header 2nd byte",
	      __FUNCTION__);
	  return FALSE;
	}
	  //计算块流ID（64-319）
      packet-&gt;m_nChannel = hbuf[1];
      packet-&gt;m_nChannel += 64;
      header++;
    }
  //块流ID第1字节为0时，块流ID占3个字节
  else if (packet-&gt;m_nChannel == 1)
    {
      int tmp;
      if (ReadN(r, (char *)&amp;hbuf[1], 2) != 2)
	{
	  RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header 3nd byte",
	      __FUNCTION__);
	  return FALSE;
	}
      tmp = (hbuf[2] &lt;&lt; 8) + hbuf[1];
	  //计算块流ID（64-65599）
      packet-&gt;m_nChannel = tmp + 64;
      RTMP_Log(RTMP_LOGDEBUG, "%s, m_nChannel: %0x", __FUNCTION__, packet-&gt;m_nChannel);
      header += 2;
    }
  //ChunkHeader的大小（4种）
  nSize = packetSize[packet-&gt;m_headerType];

  if (nSize == RTMP_LARGE_HEADER_SIZE)	/* if we get a full header the timestamp is absolute */
    packet-&gt;m_hasAbsTimestamp = TRUE;	//11字节的完整ChunkMsgHeader的TimeStamp是绝对值

  else if (nSize &lt; RTMP_LARGE_HEADER_SIZE)
    {				/* using values from the last message of this channel */
      if (r-&gt;m_vecChannelsIn[packet-&gt;m_nChannel])
	memcpy(packet, r-&gt;m_vecChannelsIn[packet-&gt;m_nChannel],
	       sizeof(RTMPPacket));
    }

  nSize--;

  if (nSize &gt; 0 &amp;&amp; ReadN(r, header, nSize) != nSize)
    {
      RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header. type: %x",
	  __FUNCTION__, (unsigned int)hbuf[0]);
      return FALSE;
    }

  hSize = nSize + (header - (char *)hbuf);

  if (nSize &gt;= 3)
    {
	//TimeStamp(注意 BigEndian to SmallEndian)(11，7，3字节首部都有)
      packet-&gt;m_nTimeStamp = AMF_DecodeInt24(header);

      /*RTMP_Log(RTMP_LOGDEBUG, "%s, reading RTMP packet chunk on channel %x, headersz %i, timestamp %i, abs timestamp %i", __FUNCTION__, packet.m_nChannel, nSize, packet.m_nTimeStamp, packet.m_hasAbsTimestamp); */
	//消息长度(11，7字节首部都有)
      if (nSize &gt;= 6)
	{
	  packet-&gt;m_nBodySize = AMF_DecodeInt24(header + 3);
	  packet-&gt;m_nBytesRead = 0;
	  RTMPPacket_Free(packet);
	//(11，7字节首部都有)
	  if (nSize &gt; 6)
	    {
		  //Msg type ID
	      packet-&gt;m_packetType = header[6];
		  //Msg Stream ID
	      if (nSize == 11)
		packet-&gt;m_nInfoField2 = DecodeInt32LE(header + 7);
	    }
	}
	  //Extend TimeStamp
      if (packet-&gt;m_nTimeStamp == 0xffffff)
	{
	  if (ReadN(r, header + nSize, 4) != 4)
	    {
	      RTMP_Log(RTMP_LOGERROR, "%s, failed to read extended timestamp",
		  __FUNCTION__);
	      return FALSE;
	    }
	  packet-&gt;m_nTimeStamp = AMF_DecodeInt32(header + nSize);
	  hSize += 4;
	}
    }

  RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)hbuf, hSize);

  if (packet-&gt;m_nBodySize &gt; 0 &amp;&amp; packet-&gt;m_body == NULL)
    {
      if (!RTMPPacket_Alloc(packet, packet-&gt;m_nBodySize))
	{
	  RTMP_Log(RTMP_LOGDEBUG, "%s, failed to allocate packet", __FUNCTION__);
	  return FALSE;
	}
      didAlloc = TRUE;
      packet-&gt;m_headerType = (hbuf[0] &amp; 0xc0) &gt;&gt; 6;
    }

  nToRead = packet-&gt;m_nBodySize - packet-&gt;m_nBytesRead;
  nChunk = r-&gt;m_inChunkSize;
  if (nToRead &lt; nChunk)
    nChunk = nToRead;

  /* Does the caller want the raw chunk? */
  if (packet-&gt;m_chunk)
    {
      packet-&gt;m_chunk-&gt;c_headerSize = hSize;
      memcpy(packet-&gt;m_chunk-&gt;c_header, hbuf, hSize);
      packet-&gt;m_chunk-&gt;c_chunk = packet-&gt;m_body + packet-&gt;m_nBytesRead;
      packet-&gt;m_chunk-&gt;c_chunkSize = nChunk;
    }

  if (ReadN(r, packet-&gt;m_body + packet-&gt;m_nBytesRead, nChunk) != nChunk)
    {
      RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet body. len: %lu",
	  __FUNCTION__, packet-&gt;m_nBodySize);
      return FALSE;
    }

  RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)packet-&gt;m_body + packet-&gt;m_nBytesRead, nChunk);

  packet-&gt;m_nBytesRead += nChunk;

  /* keep the packet as ref for other packets on this channel */
  if (!r-&gt;m_vecChannelsIn[packet-&gt;m_nChannel])
    r-&gt;m_vecChannelsIn[packet-&gt;m_nChannel] = (RTMPPacket *) malloc(sizeof(RTMPPacket));
  memcpy(r-&gt;m_vecChannelsIn[packet-&gt;m_nChannel], packet, sizeof(RTMPPacket));
  //读取完毕
  if (RTMPPacket_IsReady(packet))
    {
      /* make packet's timestamp absolute */
      if (!packet-&gt;m_hasAbsTimestamp)
	packet-&gt;m_nTimeStamp += r-&gt;m_channelTimestamp[packet-&gt;m_nChannel];	/* timestamps seem to be always relative!! */

      r-&gt;m_channelTimestamp[packet-&gt;m_nChannel] = packet-&gt;m_nTimeStamp;

      /* reset the data from the stored packet. we keep the header since we may use it later if a new packet for this channel */
      /* arrives and requests to re-use some info (small packet header) */
      r-&gt;m_vecChannelsIn[packet-&gt;m_nChannel]-&gt;m_body = NULL;
      r-&gt;m_vecChannelsIn[packet-&gt;m_nChannel]-&gt;m_nBytesRead = 0;
      r-&gt;m_vecChannelsIn[packet-&gt;m_nChannel]-&gt;m_hasAbsTimestamp = FALSE;	/* can only be false if we reuse header */
    }
  else
    {
      packet-&gt;m_body = NULL;	/* so it won't be erased on free */
    }

  return TRUE;
}</code></pre> 
<br>函数代码看似很多，但是并不是很复杂，可以理解为在从事“简单重复性劳动”（和搬砖差不多）。基本上是一个字节一个字节的读取，然后按照RTMP协议规范进行解析。具体如何解析可以参考RTMP协议规范。 
<p></p> 
<p>在RTMP_ReadPacket()函数里完成从Socket中读取数据的函数是ReadN()，继续看看它的源代码：</p> 
<p></p> 
<pre><code class="language-cpp">//从HTTP或SOCKET中读取数据
static int
ReadN(RTMP *r, char *buffer, int n)
{
  int nOriginalSize = n;
  int avail;
  char *ptr;

  r-&gt;m_sb.sb_timedout = FALSE;

#ifdef _DEBUG
  memset(buffer, 0, n);
#endif

  ptr = buffer;
  while (n &gt; 0)
    {
      int nBytes = 0, nRead;
      if (r-&gt;Link.protocol &amp; RTMP_FEATURE_HTTP)
        {
	  while (!r-&gt;m_resplen)
	    {
	      if (r-&gt;m_sb.sb_size &lt; 144)
	        {
		  if (!r-&gt;m_unackd)
		    HTTP_Post(r, RTMPT_IDLE, "", 1);
		  if (RTMPSockBuf_Fill(&amp;r-&gt;m_sb) &lt; 1)
		    {
		      if (!r-&gt;m_sb.sb_timedout)
		        RTMP_Close(r);
		      return 0;
		    }
		}
	      HTTP_read(r, 0);
	    }
	  if (r-&gt;m_resplen &amp;&amp; !r-&gt;m_sb.sb_size)
	    RTMPSockBuf_Fill(&amp;r-&gt;m_sb);
          avail = r-&gt;m_sb.sb_size;
	  if (avail &gt; r-&gt;m_resplen)
	    avail = r-&gt;m_resplen;
	}
      else
        {
          avail = r-&gt;m_sb.sb_size;
	  if (avail == 0)
	    {
	      if (RTMPSockBuf_Fill(&amp;r-&gt;m_sb) &lt; 1)
	        {
	          if (!r-&gt;m_sb.sb_timedout)
	            RTMP_Close(r);
	          return 0;
		}
	      avail = r-&gt;m_sb.sb_size;
	    }
	}
      nRead = ((n &lt; avail) ? n : avail);
      if (nRead &gt; 0)
	{
	  memcpy(ptr, r-&gt;m_sb.sb_start, nRead);
	  r-&gt;m_sb.sb_start += nRead;
	  r-&gt;m_sb.sb_size -= nRead;
	  nBytes = nRead;
	  r-&gt;m_nBytesIn += nRead;
	  if (r-&gt;m_bSendCounter
	      &amp;&amp; r-&gt;m_nBytesIn &gt; r-&gt;m_nBytesInSent + r-&gt;m_nClientBW / 2)
	    SendBytesReceived(r);
	}
      /*RTMP_Log(RTMP_LOGDEBUG, "%s: %d bytes\n", __FUNCTION__, nBytes); */
#ifdef _DEBUG
      fwrite(ptr, 1, nBytes, netstackdump_read);
#endif

      if (nBytes == 0)
	{
	  RTMP_Log(RTMP_LOGDEBUG, "%s, RTMP socket closed by peer", __FUNCTION__);
	  /*goto again; */
	  RTMP_Close(r);
	  break;
	}

      if (r-&gt;Link.protocol &amp; RTMP_FEATURE_HTTP)
	r-&gt;m_resplen -= nBytes;

#ifdef CRYPTO
      if (r-&gt;Link.rc4keyIn)
	{
	  RC4_encrypt((RC4_KEY *)r-&gt;Link.rc4keyIn, nBytes, ptr);
	}
#endif

      n -= nBytes;
      ptr += nBytes;
    }

  return nOriginalSize - n;
}</code></pre> 
<br>ReadN()中实现从Socket中接收数据的函数是RTMPSockBuf_Fill()，看看代码吧（又是层层调用）。 
<br> 
<p></p> 
<p></p> 
<pre><code class="language-cpp">//调用Socket编程中的recv（）函数，接收数据
int
RTMPSockBuf_Fill(RTMPSockBuf *sb)
{
  int nBytes;

  if (!sb-&gt;sb_size)
    sb-&gt;sb_start = sb-&gt;sb_buf;

  while (1)
    {
	//缓冲区长度：总长-未处理字节-已处理字节
	//|-----已处理--------|-----未处理--------|---------缓冲区----------|
	//sb_buf        sb_start    sb_size     
      nBytes = sizeof(sb-&gt;sb_buf) - sb-&gt;sb_size - (sb-&gt;sb_start - sb-&gt;sb_buf);
#if defined(CRYPTO) &amp;&amp; !defined(NO_SSL)
      if (sb-&gt;sb_ssl)
	{
	  nBytes = TLS_read((SSL *)sb-&gt;sb_ssl, sb-&gt;sb_start + sb-&gt;sb_size, nBytes);
	}
      else
#endif
	{
	//int recv( SOCKET s, char * buf, int len, int flags);
	//s：一个标识已连接套接口的描述字。
	//buf：用于接收数据的缓冲区。 
	//len：缓冲区长度。
	//flags：指定调用方式。
	//从sb_start（待处理的下一字节） + sb_size（）还未处理的字节开始buffer为空，可以存储
		nBytes = recv(sb-&gt;sb_socket, sb-&gt;sb_start + sb-&gt;sb_size, nBytes, 0);
	}
      if (nBytes != -1)
	{
	//未处理的字节又多了
	  sb-&gt;sb_size += nBytes;
	}
      else
	{
	  int sockerr = GetSockError();
	  RTMP_Log(RTMP_LOGDEBUG, "%s, recv returned %d. GetSockError(): %d (%s)",
	      __FUNCTION__, nBytes, sockerr, strerror(sockerr));
	  if (sockerr == EINTR &amp;&amp; !RTMP_ctrlC)
	    continue;

	  if (sockerr == EWOULDBLOCK || sockerr == EAGAIN)
	    {
	      sb-&gt;sb_timedout = TRUE;
	      nBytes = 0;
	    }
	}
      break;
    }

  return nBytes;
}</code></pre> 
<br>从RTMPSockBuf_Fill()代码中可以看出，调用了系统Socket的recv()函数接收RTMP连接传输过来的数据。 
<br> 
<p></p> 
<p><br></p> 
<p></p> 
<p style="margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; line-height:21px; font-family:微软雅黑,Verdana,sans-serif,宋体; font-size:13px">rtmpdump源代码（Linux）：<a target="_blank" href="http://download.csdn.net/detail/leixiaohua1020/6376561" rel="noopener noreferrer">http://download.csdn.net/detail/leixiaohua1020/6376561</a></p> 
<p style="margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; line-height:21px; font-family:微软雅黑,Verdana,sans-serif,宋体; font-size:13px">rtmpdump源代码（VC 2005 工程）：<a target="_blank" href="http://download.csdn.net/detail/leixiaohua1020/6563163" rel="noopener noreferrer">http://download.csdn.net/detail/leixiaohua1020/6563163</a></p> 
<br> 
<p><br></p> 
<p><br></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2f9ee631a002e6e7762f3eb6bbca7c76/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RTMPdump（libRTMP） 源代码分析 8： 发送消息（Message）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/046b5564c83783ce6f5f5d59c533e3c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RTMPdump（libRTMP） 源代码分析 10： 处理各种消息（Message）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>