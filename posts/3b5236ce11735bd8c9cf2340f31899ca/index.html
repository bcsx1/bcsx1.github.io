<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>关于Android 12 适配，看这篇就够了 - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="关于Android 12 适配，看这篇就够了" />
<meta property="og:description" content="一：功能和 API 概览 Android 12 面向开发者引入了一些出色的新功能和 API。以下几部分内容可帮助您了解适用于您的应用的功能并开始使用相关 API。
有关新增、修改和移除的 API 的详细列表，请参阅 API 差异报告。如需详细了解新的 API，请访问 Android API 参考文档 - 新 API 会突出显示以方便查看。此外，如需了解平台变更可能会在哪些方面影响您的应用，请务必查看会影响以 Android 12 为目标平台的应用和所有应用的 Android 12 行为变更。
新体验 微件改进 Android 12 改进了现有的 Widgets API，以改善平台和启动器中的用户和开发者体验。我们编写了一个指南，帮助您确保您的微件与 Android 12 兼容并使用新功能对其进行更新。
如需了解详情，请参阅 Android 12 微件改进。
音频耦合触感反馈效果 Android 12 应用可使用手机的振动器产生来自音频会话的触感反馈。这可让您获得更身临其境的游戏和音频体验。例如，触感反馈效果增强的铃声有助于识别来电者，或者赛车游戏可以模拟在崎岖地形驾驶的感觉。
如需了解详情，请参阅 HapticGenerator 参考文档。
启动画面 API Android 12 为所有应用引入了新的应用启动动画，包括启动时的进入应用运动、显示应用图标的启动画面，以及向应用本身的过渡。如需了解详情，请参阅启动画面 API。
允许按来电重要性排名的新通话通知 Android 12 为通话添加了新的通知样式 Notification.CallStyle。使用此模板可让您的应用指明正在进行的通话的重要性，方法是在状态栏中显示一个显眼的条状标签，在其中显示通话的时间；用户可以点按此条状标签以返回他们的通话。
由于来电和进行中的通话对用户来说最为重要，因此这些通知在通知栏中排名最高。这种排名还让系统有可能将这些优先处理的通话转接到其他设备。
为所有类型的通话实现以下代码。
Kotlin
// Create a new call with the user as caller." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/3b5236ce11735bd8c9cf2340f31899ca/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-12T15:37:24+08:00" />
<meta property="article:modified_time" content="2021-08-12T15:37:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">关于Android 12 适配，看这篇就够了</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E4%B8%80%EF%BC%9A%E5%8A%9F%E8%83%BD%E5%92%8C%20API%20%E6%A6%82%E8%A7%88">一：功能和 API 概览</h2> 
<p>Android 12 面向开发者引入了一些出色的新功能和 API。以下几部分内容可帮助您了解适用于您的应用的功能并开始使用相关 API。</p> 
<p>有关新增、修改和移除的 API 的详细列表，请参阅 <a href="https://developer.android.google.cn/sdk/api_diff/s-dp1/changes" rel="nofollow">API 差异报告</a>。如需详细了解新的 API，请访问 <a href="https://developer.android.google.cn/reference" rel="nofollow">Android API 参考文档</a> - 新 API 会突出显示以方便查看。此外，如需了解平台变更可能会在哪些方面影响您的应用，请务必查看会影响<a href="https://developer.android.google.cn/about/versions/12/behavior-changes-12" rel="nofollow">以 Android 12 为目标平台的应用</a>和<a href="https://developer.android.google.cn/about/versions/12/behavior-changes-all" rel="nofollow">所有应用</a>的 Android 12 行为变更。</p> 
<h3 id="experiences">新体验</h3> 
<h4 id="widgets">微件改进</h4> 
<p>Android 12 改进了现有的 Widgets API，以改善平台和启动器中的用户和开发者体验。我们编写了一个指南，帮助您确保您的微件与 Android 12 兼容并使用新功能对其进行更新。</p> 
<p>如需了解详情，请参阅 <a href="https://developer.android.google.cn/about/versions/12/features/widgets" rel="nofollow">Android 12 微件改进</a>。</p> 
<h4 id="haptics">音频耦合触感反馈效果</h4> 
<p>Android 12 应用可使用手机的振动器产生来自音频会话的触感反馈。这可让您获得更身临其境的游戏和音频体验。例如，触感反馈效果增强的铃声有助于识别来电者，或者赛车游戏可以模拟在崎岖地形驾驶的感觉。</p> 
<p>如需了解详情，请参阅 <a href="https://developer.android.google.cn/reference/android/media/audiofx/HapticGenerator" rel="nofollow">HapticGenerator</a> 参考文档。</p> 
<h4 id="splash-screen">启动画面 API</h4> 
<p>Android 12 为所有应用引入了新的应用启动动画，包括启动时的进入应用运动、显示应用图标的启动画面，以及向应用本身的过渡。如需了解详情，请参阅<a href="https://developer.android.google.cn/about/versions/12/features/splash-screen" rel="nofollow">启动画面 API</a>。</p> 
<h4 id="new-calls">允许按来电重要性排名的新通话通知</h4> 
<p>Android 12 为通话添加了新的通知样式 <a href="https://developer.android.google.cn/reference/android/app/Notification.CallStyle" rel="nofollow"><code>Notification.CallStyle</code></a>。使用此模板可让您的应用指明正在进行的通话的重要性，方法是在状态栏中显示一个显眼的条状标签，在其中显示通话的时间；用户可以点按此条状标签以返回他们的通话。</p> 
<p>由于来电和进行中的通话对用户来说最为重要，因此这些通知在通知栏中排名最高。这种排名还让系统有可能将这些优先处理的通话转接到其他设备。</p> 
<p>为所有类型的通话实现以下代码。</p> 
<p><a href="https://developer.android.google.cn/about/versions/12/features#kotlin" rel="nofollow" id="aria-tab-kotlin">Kotlin</a></p> 
<pre><code>// Create a new call with the user as caller.
val incoming_caller = Person.Builder()
    .setName("Jane Doe")
    .setImportant(true)
    .build()</code></pre> 
<p><a href="https://developer.android.google.cn/about/versions/12/features#java" rel="nofollow" id="aria-tab-java">Java</a><br>  </p> 
<pre><code>// Create a new call with the user as caller.
Person incoming_caller = new Person.Builder()
    .setName("Jane Doe")
    .setImportant(true)
    .build();</code></pre> 
<p>使用 <a href="https://developer.android.google.cn/reference/android/app/Notification.CallStyle#forIncomingCall%28android.app.Person,%20android.app.PendingIntent,%20android.app.PendingIntent%29" rel="nofollow"><code>forIncomingCall()</code></a> 为来电创建通话样式通知。</p> 
<p><a href="https://developer.android.google.cn/about/versions/12/features#kotlin" rel="nofollow">Kotlin</a></p> 
<pre><code>// Create a call style notification for an incoming call.
val builder = Notification.Builder(context, CHANNEL_ID)
    .setContentIntent(contentIntent)
    .setSmallIcon(smallIcon)
    .setStyle(
         Notification.CallStyle.forIncomingCall(caller, declineIntent, answerIntent))
    .addPerson(incoming_caller)</code></pre> 
<p><a href="https://developer.android.google.cn/about/versions/12/features#java" rel="nofollow">Java</a></p> 
<pre><code>// Create a call style notification for an incoming call.
Notification.Builder builder = Notification.Builder(context, CHANNEL_ID)
    .setContentIntent(contentIntent)
    .setSmallIcon(smallIcon)
    .setStyle(
        Notification.CallStyle.forIncomingCall(caller, declineIntent, answerIntent))
    .addPerson(incoming_caller);</code></pre> 
<p>使用 <a href="https://developer.android.google.cn/reference/android/app/Notification.CallStyle#forOngoingCall%28android.app.Person,%20android.app.PendingIntent%29" rel="nofollow"><code>forOngoingCall()</code></a> 为进行中的通话创建通话样式通知。</p> 
<p><a href="https://developer.android.google.cn/about/versions/12/features#kotlin" rel="nofollow">Kotlin</a></p> 
<p></p> 
<pre><code>// Create a call style notification for an ongoing call.
val builder = Notification.Builder(context, CHANNEL_ID)
    .setContentIntent(contentIntent)
    .setSmallIcon(smallIcon)
    .setStyle(
         Notification.CallStyle.forOnGoingCall(caller, hangupIntent))
    .addPerson(second_caller)</code></pre> 
<p><a href="https://developer.android.google.cn/about/versions/12/features#java" rel="nofollow">Java</a></p> 
<p></p> 
<pre><code class="language-html hljs">// Create a call style notification for an ongoing call.
Notification.Builder builder = Notification.Builder(context, CHANNEL_ID)
    .setContentIntent(contentIntent)
    .setSmallIcon(smallIcon)
    .setStyle(
        Notification.CallStyle.forOnGoingCall(caller, hangupIntent))
    .addPerson(second_caller);
</code></pre> 
<p>使用 <a href="https://developer.android.google.cn/reference/android/app/Notification.CallStyle#forScreeningCall%28android.app.Person,%20android.app.PendingIntent,%20android.app.PendingIntent%29" rel="nofollow"><code>forScreeningCall()</code></a> 为过滤来电创建通话样式通知。</p> 
<p><a href="https://developer.android.google.cn/about/versions/12/features#kotlin" rel="nofollow">Kotlin</a></p> 
<pre><code>// Create a call style notification for an ongoing call.
val builder = Notification.Builder(context, CHANNEL_ID)
    .setContentIntent(contentIntent)
    .setSmallIcon(smallIcon)
    .setStyle(
         Notification.CallStyle.forOnGoingCall(caller, hangupIntent))
    .addPerson(second_caller)</code></pre> 
<p><a href="https://developer.android.google.cn/about/versions/12/features#java" rel="nofollow">Java</a></p> 
<p></p> 
<pre><code class="language-html hljs">Notification.Builder builder = Notification.Builder(context, CHANNEL_ID)
    .setContentIntent(contentIntent)
    .setSmallIcon(smallIcon)
    .setStyle(
        Notification.CallStyle.forScreeningCall(caller, hangupIntent, answerIntent))
    .addPerson(second_caller);
</code></pre> 
<h4 id="enriched_image_support_for_notifications">通知的丰富图片支持</h4> 
<p>在 Android 12 中，您现在可以通过在 <a href="https://developer.android.google.cn/reference/android/app/Notification.MessagingStyle#MessagingStyle%28android.app.Person%29" rel="nofollow"><code>MessagingStyle()</code></a> 和 <a href="https://developer.android.google.cn/reference/android/app/Notification.BigPictureStyle#BigPictureStyle%28%29" rel="nofollow"><code>BigPictureStyle()</code></a> 通知中提供动画图片来丰富应用的通知体验。此外，您的应用现在还可以让用户在从通知栏回复消息时发送图片消息。</p> 
<h4 id="rounded_corner_apis">圆角 API</h4> 
<p>Android 12 引入了 <a href="https://developer.android.google.cn/reference/android/view/RoundedCorner" rel="nofollow"><code>RoundedCorner</code></a> 和 <a href="https://developer.android.google.cn/reference/android/view/WindowInsets?hl=en#getRoundedCorner%28int%29" rel="nofollow"><code>WindowInsets.getRoundedCorner(int position)</code></a>，它们可以提供圆角的半径和中心点。借助这些 API，您的应用可以避免界面元素在带有圆角的屏幕上被截断。</p> 
<p>在您的应用中实现这些 API 时，它们对具有非圆角屏幕的设备没有影响。</p> 
<p style="text-align:center;"><img alt="图片显示了一个圆角，并标注了半径和中心点" src="https://images2.imgbox.com/9d/bb/jaw5EcYj_o.png" width="200"></p> 
<p>如需实现此功能，请相对于应用的边界通过 <code>WindowInsets.getRoundedCorner(int position)</code> 获取 <code>RoundedCorner</code> 信息。如果应用未占据整个屏幕，则该 API 通过让圆角的中心点基于应用的窗口边界来应用圆角。</p> 
<p>以下代码段展示了一个简单的示例，说明了一个应用通过根据来自 <code>RoundedCorner</code> 的信息设置视图的外边距来避免界面截断。在本例中，它是右上角的圆角。</p> 
<p></p> 
<pre><code>// Get the top-right rounded corner from WindowInsets.
final WindowInsets insets = getRootWindowInsets();
final RoundedCorner topRight = insets.getRoundedCorner(POSITION_TOP_RIGHT);
if (topRight == null) {
   return;
}

// Get the location of the close button in window coordinates.
int [] location = new int[2];
closeButton.getLocationInWindow(location);
final int buttonRightInWindow = location[0] + closeButton.getWidth();
final int buttonTopInWindow = location[1];

// Find the point on the quarter circle with a 45 degree angle.
final int offset = (int) (topRight.getRadius() * Math.sin(Math.toRadians(45)));
final int topBoundary = topRight.getCenter().y - offset;
final int rightBoundary = topRight.getCenter().x + offset;

// Check whether the close button exceeds the boundary.
if (buttonRightInWindow &lt; rightBoundary &amp;&amp; buttonTopInWindow &gt; topBoundary) {
   return;
}

// Set the margin to avoid truncating.
int [] parentLocation = new int[2];
getLocationInWindow(parentLocation);
FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) closeButton.getLayoutParams();
lp.rightMargin = Math.max(buttonRightInWindow - rightBoundary, 0);
lp.topMargin = Math.max(topBoundary - buttonTopInWindow, 0);
closeButton.setLayoutParams(lp);
</code></pre> 
<h4 id="pip-improvements">画中画 (PiP) 改进</h4> 
<p>Android 12 针对画中画 (PiP) 模式引入了新功能。如需了解详情，请参阅<a href="https://developer.android.google.cn/about/versions/12/features/pip-improvements" rel="nofollow">画中画改进</a>。</p> 
<h4 id="immersive-mode-improvements">沉浸模式下的手势导航改进</h4> 
<p>Android 12 简化了沉浸模式，使手势导航更易于操作且与其他活动体验（例如观看视频和阅读图书）更加一致。应用仍然可以在全屏游戏体验中<a href="https://developer.android.google.cn/reference/android/view/WindowInsetsController#BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE" rel="nofollow">防止意外手势</a>，以免用户在玩游戏时意外退出游戏；所有其他全屏或沉浸式体验现在都允许用户通过滑动手势进行导航。</p> 
<p>为了实现这一点，从 Android 12 开始，我们已弃用非粘性沉浸式体验（<a href="https://developer.android.google.cn/reference/android/view/WindowInsetsController#BEHAVIOR_SHOW_BARS_BY_TOUCH" rel="nofollow"><code>BEHAVIOR_SHOW_BARS_BY_TOUCH</code></a>、<a href="https://developer.android.google.cn/reference/android/view/WindowInsetsController#BEHAVIOR_SHOW_BARS_BY_SWIPE" rel="nofollow"><code>BEHAVIOR_SHOW_BARS_BY_SWIPE</code></a>）的现有行为。它们已被默认行为 (<a href="https://developer.android.google.cn/reference/android/view/WindowInsetsController#BEHAVIOR_DEFAULT" rel="nofollow"><code>BEHAVIOR_DEFAULT</code></a>) 取代，即在隐藏系统栏后，允许使用滑动手势。此标志会根据模式显示不同的视觉和功能行为：</p> 
<ul><li>在“三按钮”模式下，视觉和功能行为与 Android 12 之前的版本中的沉浸模式相同。</li><li>在手势导航模式下，行为如下： 
  <ul><li>在视觉上，它与 Android 11 及更低版本中的沉浸模式相同。</li><li>从功能上讲，即使系统栏被隐藏，也允许使用手势；只需滑动屏幕一次便可调用系统返回操作，而 Android 11 需要滑动两次。下拉通知栏或转到主屏幕无需另外滑动屏幕。</li></ul></li></ul> 
<p>Android 12 的粘性沉浸模式 (<a href="https://developer.android.google.cn/reference/android/view/WindowInsetsController#BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE" rel="nofollow"><code>BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE</code></a>) 没有任何变化。请注意此功能的以下向后兼容性：</p> 
<ul><li>如果应用以 Android 11 及更低版本为目标平台，则在 Android 12 上运行时： 
  <ul><li><code>BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE</code> 展示出的功能和呈现出的视觉效果相同。</li><li>默认值会映射到 <a href="https://developer.android.google.cn/reference/android/view/WindowInsetsController#BEHAVIOR_SHOW_BARS_BY_SWIPE" rel="nofollow"><code>BEHAVIOR_SHOW_BARS_BY_SWIPE</code></a>。</li></ul></li><li>如果应用以 Android 12 为目标平台，则在 Android 11（API 级别 30）及更低版本上运行时： 
  <ul><li>展示出的功能和呈现出的视觉效果应该是相同的，但 <a href="https://developer.android.google.cn/reference/android/view/WindowInsetsController#BEHAVIOR_SHOW_BARS_BY_TOUCH" rel="nofollow"><code>BEHAVIOR_SHOW_BARS_BY_TOUCH</code></a> 映射到 <a href="https://developer.android.google.cn/reference/android/view/WindowInsetsController#BEHAVIOR_SHOW_BARS_BY_SWIPE" rel="nofollow"><code>BEHAVIOR_SHOW_BARS_BY_SWIPE</code></a> 的情况除外。</li><li>务必更新您的 SDK 级别，以获得新的默认设置 (<a href="https://developer.android.google.cn/reference/android/view/WindowInsetsController#BEHAVIOR_SHOW_BARS_BY_SWIPE" rel="nofollow"><code>BEHAVIOR_SHOW_BARS_BY_SWIPE</code></a>)。否则，<a href="https://developer.android.google.cn/reference/android/view/WindowInsetsController#BEHAVIOR_SHOW_BARS_BY_TOUCH" rel="nofollow"><code>BEHAVIOR_SHOW_BARS_BY_TOUCH</code></a> 仍然是默认设置。</li></ul></li></ul> 
<h4 id="unified-content-api">富媒体内容插入</h4> 
<p>Android 12 引入了一个新的统一 API，可让您从任何可用来源（剪贴板、键盘或拖放操作）接收富媒体内容。</p> 
<p>如需了解详情，请参阅<a href="https://developer.android.google.cn/about/versions/12/features/unified-content-api" rel="nofollow">用于接收内容的统一 API</a>。</p> 
<h3 id="camera">摄像头</h3> 
<h4 id="camera-sensor-support">Quad Bayer 摄像头传感器支持</h4> 
<p>如今，许多 Android 设备都配备了超高分辨率摄像头传感器（通常采用 Quad/Nona Bayer 模式），这些传感器在图片质量和弱光性能方面提供了极大的灵活性。Android 12 引入了新的平台 API，可让第三方应用充分利用这些多功能传感器。<a href="https://developer.android.google.cn/reference/android/hardware/camera2/CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR" rel="nofollow">新 API</a> 支持这些传感器的独特行为，并且考虑到它们在全分辨率或“最大分辨率”模式下而不是“默认”模式下运行时可能支持不同的流配置和组合。</p> 
<h3 id="graphics">图形和图片</h3> 
<h4 id="provide_apps_direct_access_to_tombstone_traces">让应用能够直接访问 Tombstone 跟踪记录</h4> 
<p>从 Android 12 开始，您可以通过 <a href="https://developer.android.google.cn/reference/android/app/ApplicationExitInfo#getTraceInputStream%28%29" rel="nofollow"><code>ApplicationExitInfo.getTraceInputStream()</code></a> 方法以<a href="https://developers.google.cn/protocol-buffers/" rel="nofollow">协议缓冲区</a>的形式访问应用的原生代码崩溃 Tombstone。协议缓冲区使用<a href="https://android.googlesource.com/platform/system/core/+/refs/heads/master/debuggerd/proto/tombstone.proto" rel="nofollow">此架构</a>进行序列化。以前，只有通过 <a href="https://developer.android.google.cn/studio/command-line/adb" rel="nofollow">Android 调试桥</a> (adb) 才能访问此信息。</p> 
<p>以下示例说明了如何在您的应用中实现此功能：</p> 
<p></p> 
<pre><code>ActivityManager activityManager: ActivityManager = getSystemService(Context.ACTIVITY_SERVICE);
MutableList&lt;ApplicationExitInfo&gt; exitReasons = activityManager.getHistoricalProcessExitReasons(/* packageName = */ null, /* pid = */ 0, /* maxNum = */ 5);
for ( ApplicationExitInfo aei: exitReasons ) {
    if ( aei.getReason() == REASON_CRASH_NATIVE ) {
        // Get the tombstone input stream.
        InputStream tombstoneInputStream = aei.getTraceInputStream();
        // The tombstone parser built with protoc uses the tombstone schema, then parses the trace.
        Tombstone tombstone = Tombstone.parseFrom(trace);
    }
}
</code></pre> 
<h4 id="avif">AVIF 图片支持</h4> 
<p>Android 12 引入了对使用 AV1 图片文件格式 (AVIF) 的图片的支持。AVIF 是一种使用 AV1 编码的图片和图片序列的容器格式。它利用了视频压缩的帧内编码内容。与以前的图片格式（例如 JPEG）相比，这种格式可显著提升相同文件大小下的图片质量。如需深入了解此格式的优势，请参阅 Jake Archibald 的<a href="https://jakearchibald.com/2020/avif-has-landed/" rel="nofollow">博文</a>。</p> 
<h4 id="rendereffect">更简单的模糊处理、颜色滤镜及其他效果</h4> 
<p>Android 12 添加了新的 <a href="https://developer.android.google.cn/reference/android/graphics/RenderEffect" rel="nofollow"><code>RenderEffect</code></a>，它可将常见的图片效果（如模糊处理、颜色滤镜、Android 着色器效果及更多效果）应用于 <a href="https://developer.android.google.cn/reference/android/view/View" rel="nofollow"><code>View</code></a> 和渲染层次结构。效果可以组合为连锁效果（构成一种内外效果）或混合效果。由于处理能力有限，不同的 Android 设备可能支持该功能，也可能不支持。</p> 
<p>也可以通过调用 <a href="https://developer.android.google.cn/reference/android/view/View#setRenderEffect%28android.graphics.RenderEffect%29" rel="nofollow"><code>View.setRenderEffect(RenderEffect)</code></a> 将效果应用于 <code>View</code> 的底层 <a href="https://developer.android.google.cn/reference/android/graphics/RenderNode" rel="nofollow"><code>RenderNode</code></a>。</p> 
<p>如需实现 <code>RenderEffect</code>，请编写以下代码：</p> 
<p></p> 
<pre><code>view.setRenderEffect(RenderEffect.createBlurEffect(radiusX, radiusY, SHADER_TILE_MODE))
</code></pre> 
<h4 id="image-decoder">原生动画图片解码</h4> 
<p>在 Android 12 中，NDK <a href="https://developer.android.google.cn/ndk/reference/group/image-decoder" rel="nofollow"><code>ImageDecoder</code></a> API 已进行了扩展，可以对使用以下文件格式的图片的所有帧和时间数据进行解码：动画 <a href="https://en.wikipedia.org/wiki/GIF" rel="nofollow">GIF</a> 和动画 <a href="https://developers.google.cn/speed/webp" rel="nofollow">WebP</a> 文件格式。在 Android 11 中引入该 API 时，该 API 仅从这些格式的动画中解码第一张图片。</p> 
<p>使用 <code>ImageDecoder</code>（而非第三方库）可进一步<a href="https://developer.android.google.cn/topic/performance/reduce-apk-size#minimize" rel="nofollow">缩减 APK 大小</a>，并从未来与安全性和性能相关的更新中受益。</p> 
<p>如需详细了解该 API，请参阅 <a href="https://developer.android.google.cn/ndk/reference/group/image-decoder" rel="nofollow">API 参考文档</a>和 <a href="https://github.com/android/ndk-samples/tree/develop/webp/image-decoder">GitHub 上的示例</a>。</p> 
<h3 id="media">媒体</h3> 
<h4 id="transcoding">兼容的媒体转码</h4> 
<p>Android 12 可以自动将设备上录制的 <a href="https://en.wikipedia.org/wiki/High_Efficiency_Video_Coding" rel="nofollow">HEVC(H.265)</a> 和 <a href="https://en.wikipedia.org/wiki/High-dynamic-range_video" rel="nofollow">HDR</a>（HDR10 和 HDR10+）视频转码为 AVC (H.264)，AVC (H.264) 是与标准播放器广泛兼容的格式。因此，当现代编解码器可用且不会影响与旧应用的兼容性时，便会利用现代编解码器。</p> 
<p>如需了解详情，请参阅<a href="https://developer.android.google.cn/about/versions/12/features/compatible-media-transcoding" rel="nofollow">兼容的媒体转码</a>。</p> 
<h4 id="performance-class">性能等级</h4> 
<p>从 Android 12 开始，Android 引入了一种称为“性能等级”的标准。性能等级指定超出 Android 基准要求的硬件功能。每个 Android 设备都会声明其支持的性能等级。开发者可以在运行时检查设备的性能等级，并提供充分利用设备功能的升级体验。</p> 
<p>如需了解详情，请参阅<a href="https://developer.android.google.cn/about/versions/12/features/performance-class" rel="nofollow">性能等级</a>。</p> 
<h4 id="video-encoding">视频编码改进</h4> 
<p>Android 12 定义了一组标准键来控制视频编码的量化参数 (QP) 值，这样可让开发者避免供应商专用代码。</p> 
<p><a href="https://developer.android.google.cn/reference/android/media/MediaFormat#KEY_VIDEO_QP_B_MAX" rel="nofollow"><code>MediaFormat</code></a> API 以及 <a href="https://developer.android.google.cn/ndk/reference/group/media" rel="nofollow">NDK 媒体库</a>中提供了这些新键。</p> 
<p>从 Android 12 开始，视频编码器强制执行一个最低质量阈值。这样可保证用户在对场景复杂性较高的视频进行编码时不会体验到极低的质量。</p> 
<h4 id="audio-focus">音频焦点</h4> 
<p>从 Android 12 开始，当一个应用在另一个应用具有焦点且正在播放音频的同时请求音频焦点时，框架会淡出正在播放音频的应用。</p> 
<p>如需了解详情，请参阅<a href="https://developer.android.google.cn/about/versions/12/features/audio-focus-improvements" rel="nofollow">音频焦点改进</a>。</p> 
<h4 id="mediadrm">MediaDrm 更新</h4> 
<p>为了确定当前的 <code>MediaDrm</code> API 是否需要安全的解码器组件，您必须按照以下步骤操作：</p> 
<ol><li>创建 <code>MediaDrm</code>。</li><li>打开会话以获取会话 ID。</li><li>使用会话 ID 创建 <code>MediaCrypto</code>。</li><li>调用 <code>MediaCrypto.requiresSecureDecoderComponent(mimeType)</code>。</li></ol> 
<p>借助新方法 <code>requiresSecureDecoder(@NonNull String mime)</code> 和 <code>requiresSecureDecoder(@NonNull String mime, @SecurityLevel int level)</code>，您可以在创建 <code>MediaDrm</code> 后立即确定这一点。</p> 
<h3 id="security-privacy">安全和隐私设置</h3> 
<h4 id="bluetooth-permissions">蓝牙权限</h4> 
<p>Android 12 引入了 <a href="https://developer.android.google.cn/reference/android/Manifest.permission#BLUETOOTH_SCAN" rel="nofollow"><code>BLUETOOTH_SCAN</code></a>、<a href="https://developer.android.google.cn/reference/android/Manifest.permission#BLUETOOTH_ADVERTISE" rel="nofollow"><code>BLUETOOTH_ADVERTISE</code></a> 和 <a href="https://developer.android.google.cn/reference/android/Manifest.permission#BLUETOOTH_CONNECT" rel="nofollow"><code>BLUETOOTH_CONNECT</code></a> 权限。这些权限可让以 Android 12 为目标平台的应用更轻松地<a href="https://developer.android.google.cn/guide/topics/connectivity/bluetooth" rel="nofollow">与蓝牙设备互动</a>，尤其是不需要访问设备位置信息的应用。</p> 
<p><strong>注意</strong>：<a href="https://developer.android.google.cn/guide/topics/connectivity/companion-device-pairing" rel="nofollow">配套设备管理器</a>提供了一种更精简的方法来连接到配套设备。系统会代表您的应用提供配对界面。如果您想要更好地控制配对和连接体验，请使用新的蓝牙权限。</p> 
<p>如需了解详情，请参阅有关<a href="https://developer.android.google.cn/about/versions/12/features/bluetooth-permissions" rel="nofollow">新蓝牙权限</a>的指南。</p> 
<h4 id="privacy-dashboard">隐私信息中心</h4> 
<p></p> 
<p><strong>图 1.</strong> “位置信息使用情况”屏幕，“隐私信息中心”的一部分。</p> 
<p>在搭载 Android 12 的受支持设备上，系统设置中会显示“隐私信息中心”屏幕。在此屏幕上，用户可以访问一些单独的屏幕，这些屏幕显示了应用何时访问位置、摄像头和麦克风信息。每个屏幕都会显示一个时间轴，指明不同的应用何时访问过特定类型的数据。图 1 显示了位置信息的数据访问时间轴。</p> 
<p>您的应用可以向用户提供一个理由，帮助他们了解为什么您的应用访问位置、摄像头或麦克风信息。此理由可以显示在新的“隐私信息中心”屏幕和/或您应用的权限屏幕上。</p> 
<p>显示数据访问的理由</p> 
<p>如需解释为什么您的应用访问位置、摄像头和麦克风信息，请完成以下步骤：</p> 
<ol><li> <p>添加一个 activity，它在启动后会提供某种理由，说明为什么您的应用执行特定类型的数据访问操作。</p> <p>如果您的应用以 Android 12 或更高版本为目标平台，则您必须明确地<a href="https://developer.android.google.cn/about/versions/12/behavior-changes-12#exported" rel="nofollow">为 <code>android:exported</code> 属性定义一个值</a>。</p> </li><li> <p>向新添加的 activity 添加以下 intent 过滤器：</p> <p></p> <pre><code class="language-html hljs">&lt;!-- android:exported required if you target Android 12. --&gt;
&lt;activity android:name=".DataAccessRationaleActivity"
          android:permission="android.permission.START_VIEW_PERMISSION_USAGE"
          android:exported="true"&gt;
       &lt;!-- VIEW_PERMISSION_USAGE shows a selectable information icon on
            your app permission's page in system settings.
            VIEW_PERMISSION_USAGE_FOR_PERIOD shows a selectable information
            icon on the Privacy Dashboard screen. --&gt;
    &lt;intent-filter
       android:action="android.intent.action.VIEW_PERMISSION_USAGE"
       android:action="android.intent.action.VIEW_PERMISSION_USAGE_FOR_PERIOD" ... &gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre> </li><li> <p>决定您的数据访问理由 activity 应显示什么内容。例如，您可以显示应用的网站或帮助中心文章。如需提供更详细的解释来说明您的应用访问的数据类型以及访问发生的时间，请处理系统在调用权限使用 intent 时包含的 extra：</p> 
  <ul><li>如果系统调用 <code>ACTION_VIEW_PERMISSION_USAGE</code>，您的应用可以检索 <a href="https://developer.android.google.cn/reference/android/content/Intent#EXTRA_PERMISSION_GROUP_NAME" rel="nofollow"><code>EXTRA_PERMISSION_GROUP_NAME</code></a> 的值。</li><li>如果系统调用 <code>ACTION_VIEW_PERMISSION_USAGE_FOR_PERIOD</code>，您的应用可以检索 <code>EXTRA_PERMISSION_GROUP_NAME</code>、<a href="https://developer.android.google.cn/reference/android/content/Intent#EXTRA_ATTRIBUTION_TAGS" rel="nofollow"><code>EXTRA_ATTRIBUTION_TAGS</code></a>、<a href="https://developer.android.google.cn/reference/android/content/Intent#EXTRA_START_TIME" rel="nofollow"><code>EXTRA_START_TIME</code></a> 和 <a href="https://developer.android.google.cn/reference/android/content/Intent#EXTRA_END_TIME" rel="nofollow"><code>EXTRA_END_TIME</code></a> 的值。</li></ul></li></ol> 
<p>根据您添加的 intent 过滤器，用户会在某些屏幕上看到应用的名称旁边有一个信息图标：</p> 
<ul><li>如果您添加包含 <code>VIEW_PERMISSION_USAGE</code> 操作的 intent 过滤器，用户会在系统设置中的应用权限页面上看到该图标。</li><li>如果您添加包含 <code>VIEW_PERMISSION_USAGE_FOR_PERIOD</code> 操作的 intent 过滤器，每当您的应用显示在“隐私信息中心”屏幕中，用户都会在应用的名称旁边看到该图标。</li></ul> 
<p>当用户选择该图标时，系统会启动应用的理由 activity。</p> 
<h4 id="hide-application-overlay-windows">隐藏应用叠加窗口</h4> 
<p>为了让开发者能够更好地控制用户在与开发者的应用互动时会看到什么内容，Android 12 引入了隐藏由具有 <a href="https://developer.android.google.cn/reference/android/Manifest.permission#SYSTEM_ALERT_WINDOW" rel="nofollow"><code>SYSTEM_ALERT_WINDOW</code></a> 权限的应用绘制的叠加窗口的功能。</p> 
<p>声明 <a href="https://developer.android.google.cn/reference/android/Manifest.permission#HIDE_OVERLAY_WINDOWS" rel="nofollow"><code>HIDE_OVERLAY_WINDOWS</code></a> 权限后，应用可以调用 <a href="https://developer.android.google.cn/reference/android/view/Window#setHideOverlayWindows%28boolean%29" rel="nofollow"><code>setHideOverlayWindows()</code></a> 以指明当应用自己的窗口可见时所有 <a href="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY" rel="nofollow"><code>TYPE_APPLICATION_OVERLAY</code></a> 类型的窗口都应隐藏。在显示敏感屏幕（如交易确认流程）时，应用可能会选择这样做。</p> 
<p>显示 <code>TYPE_APPLICATION_OVERLAY</code> 类型窗口的应用应考虑可能更适合其用例的替代方案，如<a href="https://developer.android.google.cn/guide/topics/ui/picture-in-picture" rel="nofollow">画中画</a>或<a href="https://developer.android.google.cn/guide/topics/ui/bubbles" rel="nofollow">气泡</a>。</p> 
<h4 id="safer-grant-signature-perms">已知签名者权限保护标志</h4> 
<p>Android 12 引入了<a href="https://developer.android.google.cn/guide/topics/permissions/overview#signature" rel="nofollow">签名级权限</a>的 <a href="https://developer.android.google.cn/reference/android/R.attr#knownCerts" rel="nofollow"><code>knownCerts</code></a> 属性。此属性可让您在声明时引用已知<a href="https://developer.android.google.cn/studio/publish/app-signing#certificates" rel="nofollow">签名证书</a>的摘要。</p> 
<p>您的应用可以声明此属性，并在给定签名级权限的 <a href="https://developer.android.google.cn/reference/android/R.attr#protectionLevel" rel="nofollow"><code>protectionLevel</code></a> 属性中使用新的 <code>knownSigner</code> 标志。当您的应用执行此操作时，如果某个发起请求的应用的签名谱系中的任何签名者（包括当前签名者）与使用 <code>knownCerts</code> 属性中的权限声明的某个摘要匹配，则系统会向该发起请求的应用授予权限。</p> 
<p><code>knownSigner</code> 标志可让设备和应用向其他应用授予签名权限，而不必在设备制造和装运时为应用签名。</p> 
<h4 id="device-properties-verification">设备属性认证</h4> 
<p>Android 12 扩展了一组应用，当这些应用生成新密钥时，可以验证<a href="https://source.android.google.cn/security/keystore/attestation#attestation-certificate" rel="nofollow">认证证书</a>中的设备属性。</p> 
<p>自 Android 9（API 级别 28）起，使用 <a href="https://source.android.google.cn/security/keystore" rel="nofollow">Keymaster 4.0</a> 或更高版本的<a href="https://developer.android.google.cn/guide/topics/admin/device-admin" rel="nofollow">设备政策所有者 (DPO)</a> 可以验证这些认证证书中的设备属性。从 Android 12 开始，任何以 Android 12 为目标平台的应用都可以使用 <a href="https://developer.android.google.cn/reference/android/security/keystore/KeyGenParameterSpec.Builder#setDevicePropertiesAttestationIncluded%28boolean%29" rel="nofollow"><code>setDevicePropertiesAttestationIncluded()</code></a> 方法执行此验证。</p> 
<p>生成的设备属性包含以下 <a href="https://developer.android.google.cn/reference/android/os/Build" rel="nofollow"><code>Build</code></a> 字段：</p> 
<ul><li><code>BRAND</code></li><li><code>DEVICE</code></li><li><code>MANUFACTURER</code></li><li><code>MODEL</code></li><li><code>PRODUCT</code></li></ul> 
<h4 id="notification-secure">安全锁定屏幕通知操作</h4> 
<p>Android 12 向 <code>Notification.Action.Builder</code> 添加了新的 <a href="https://developer.android.google.cn/reference/android/app/Notification.Action.Builder#setAuthenticationRequired%28boolean%29" rel="nofollow"><code>setAuthenticationRequired</code></a> 标志。此标志可让您为锁定设备上的通知增添一层额外的安全保障。</p> 
<p>将此标志应用于给定的<a href="https://developer.android.google.cn/guide/topics/ui/notifiers/notifications#Actions" rel="nofollow">通知操作</a>且值为 <code>true</code> 时，在锁定设备上调用该操作的用户始终都会收到身份验证请求。以前，只有在用户对通知操作的调用启动了 activity 或者是直接回复时，系统才会请求在锁定设备上进行身份验证。</p> 
<p>如需实现此功能，请向通知操作添加 <code>setAuthenticationRequired</code>：</p> 
<p></p> 
<pre><code>Notification n1 = new Notification.Builder(context, NotificationListenerVerifierActivity.TAG)
...
.addAction(new Notification.Action.Builder(R.drawable.ic_stat_charlie,
context.getString(R.string.action_test_title), makeBroadcastIntent(context))

// Make sure this notification action will always request authentication when
// invoked from a lock screen
.setAuthenticationRequired(true).build())

.build();
</code></pre> 
<h3 id="connectivity">连接性</h3> 
<h4 id="bandwidth-estimation">带宽估测改进</h4> 
<p>在 Android 12 中，由 <a href="https://developer.android.google.cn/reference/android/net/NetworkCapabilities#getLinkDownstreamBandwidthKbps%28%29" rel="nofollow"><code>getLinkDownstreamBandwidthKbps()</code></a> 和 <a href="https://developer.android.google.cn/reference/android/net/NetworkCapabilities#getLinkUpstreamBandwidthKbps%28%29" rel="nofollow"><code>getLinkUpstreamBandwidthKbps()</code></a> 提供的带宽估测功能针对 Wi-Fi 和移动网络连接都得到了改进。现在，返回的值表示用户在设备上的所有应用中的每个运营商或 WiFi SSID、网络类型和信号电平的全时加权平均吞吐量。这样可返回对预期吞吐量的更准确且更实际的估测数据，提供对应用冷启动的估测数据，并且与使用其他吞吐量估测方法相比需要更少的周期。</p> 
<h4 id="keep-awake">使配套应用保持唤醒状态</h4> 
<p>为了满足让配套应用保持运行状态以管理设备的需求，Android 12 引入了具有以下作用的 API：</p> 
<ul><li>当配套设备处于范围内时，让您可以唤醒某个应用。</li><li>保证该过程在设备处于范围内时将继续运行。</li></ul> 
<p>如需使用相应的 API，必须使用<a href="https://developer.android.google.cn/reference/android/companion/CompanionDeviceManager" rel="nofollow">配套设备管理器</a>连接您的设备。如需了解详情，请参阅 <a href="https://developer.android.google.cn/reference/android/companion/CompanionDeviceManager#startObservingDevicePresence%28java.lang.String%29" rel="nofollow"><code>CompanionDeviceManager.startObservingDevicePresence()</code></a> 和 <a href="https://developer.android.google.cn/reference/android/companion/CompanionDeviceService#onDeviceAppeared%28java.lang.String%29" rel="nofollow"><code>CompanionDeviceService.onDeviceAppeared()</code></a>。</p> 
<h4 id="cdm-profiles">配套设备管理器配置文件</h4> 
<p>现在，以 Android 12 及更高版本为目标平台的合作伙伴应用在连接到手表时可以使用配套设备配置文件。使用配置文件可将一组设备类型专用权限的授予操作捆绑在一个步骤中，从而简化注册过程。</p> 
<p style="text-align:center;"><img alt="手机的屏幕截图，显示了请求授予权限的提示" src="https://images2.imgbox.com/66/b1/sfCFudQt_o.png" width="300"></p> 
<p>设备连接后就会向配套应用授予捆绑的权限，且这些权限仅在设备关联时持续有效。删除应用或移除关联时会移除权限。</p> 
<p>如需了解详情，请参阅 <a href="https://developer.android.google.cn/reference/android/companion/AssociationRequest.Builder#setDeviceProfile%28java.lang.String%29" rel="nofollow"><code>AssociationRequest.Builder.setDeviceProfile()</code></a>。</p> 
<h4 id="wifi-aware-enhancements">Wi-Fi 感知 (NAN) 增强功能</h4> 
<p>Android 12 增强了 Wi-Fi 感知功能：</p> 
<ul><li>在搭载 Android 12 及更高版本的设备上，您可以使用 <a href="https://developer.android.google.cn/reference/android/net/wifi/aware/DiscoverySessionCallback#onServiceLost%28android.net.wifi.aware.PeerHandle,%20int%29" rel="nofollow"><code>onServiceLost()</code></a> 回调，以便在应用因服务停止或超出范围而导致已发现的服务丢失时收到提醒。</li><li>设置多个数据路径（NAN 数据路径）的方式将发生变化以提高效率。较低的版本使用 L2 消息功能来交换发起方的对等信息，由此导致了延迟。在搭载 Android 12 及更高版本的设备上，可以将响应方（服务器）配置为接受任何对等方，也就是说，它不需要预先知道发起方信息。这可加快数据路径启动，并只需一个网络请求即可实现多个点对点链接。</li><li>为了防止框架因资源不足而拒绝发现请求或连接请求，在搭载 Android 12 及更高版本的设备上，您可以调用 <a href="https://developer.android.google.cn/reference/android/net/wifi/aware/WifiAwareManager#getAvailableAwareResources%28%29" rel="nofollow"><code>WifiAwareManager.getAvailableAwareResources()</code></a>。通过此方法的返回值，您可以获得可用数据路径的数量、可用发布会话的数量以及可用的订阅会话数量。</li></ul> 
<h4 id="concurrent-connections">并发点对点 + 互联网连接</h4> 
<p>以 Android 12 及更高版本为目标平台的设备在具有硬件支持的设备上运行时，在与对等设备建立连接时，使用<a href="https://developer.android.google.cn/guide/topics/connectivity/wifi-bootstrap" rel="nofollow">点对点连接</a>不会断开与现有 Wi-Fi 的连接。如需检查是否支持此功能，请使用 <a href="https://developer.android.google.cn/reference/android/net/wifi/WifiManager#isMultiStaConcurrencySupported%28%29" rel="nofollow"><code>WifiManager.isMultiStaConcurrencySupported()</code></a>。</p> 
<h3 id="storage">存储</h3> 
<p>Android 12 引入了对存储管理 API 的几项变更，下面几部分对此进行了介绍。</p> 
<h4 id="recordings-directory">语音录音的新目录</h4> 
<p>系统会将存储在新 <a href="https://developer.android.google.cn/reference/android/os/Environment#DIRECTORY_RECORDINGS" rel="nofollow"><code>Environment.DIRECTORY_RECORDINGS</code></a> 文件夹中的音频文件识别为录音。当您的应用对系统的媒体库执行查询时，您可以使用 <a href="https://developer.android.google.cn/reference/android/provider/MediaStore.Audio.AudioColumns#IS_RECORDING" rel="nofollow"><code>IS_RECORDING</code></a> 标志来检索录音。</p> 
<h4 id="media-management-access">媒体管理访问权限</h4> 
<p>用户可能会信任特定的应用来执行媒体管理，如频繁地修改媒体文件。如果您的应用以 Android 11（API 级别 30）或更高版本为目标平台且不是设备的默认图库应用，则每次您的应用尝试修改或删除文件时，您都必须向用户显示一个确认对话框。</p> 
<p>如果您的应用以 Android 12 为目标平台，您可以请求用户向您的应用授予执行以下各项操作的权限，而无需针对每项文件操作提示用户：</p> 
<ul><li>使用 <a href="https://developer.android.google.cn/reference/android/provider/MediaStore#createWriteRequest%28android.content.ContentResolver,%20java.util.Collection%3Candroid.net.Uri%3E%29" rel="nofollow"><code>createWriteRequest()</code></a> 修改文件。</li><li>使用 <a href="https://developer.android.google.cn/reference/android/provider/MediaStore#createTrashRequest%28android.content.ContentResolver,%20java.util.Collection%3Candroid.net.Uri%3E,%20boolean%29" rel="nofollow"><code>createTrashRequest()</code></a> 将文件移入和移出回收站。</li><li>使用 <a href="https://developer.android.google.cn/reference/android/provider/MediaStore#createDeleteRequest%28android.content.ContentResolver,%20java.util.Collection%3Candroid.net.Uri%3E%29" rel="nofollow"><code>createDeleteRequest()</code></a> 删除文件。</li></ul> 
<p>为此，请完成以下步骤：</p> 
<ol><li> <p>在应用的清单文件中声明新的 <a href="https://developer.android.google.cn/reference/android/Manifest.permission#MANGE_MEDIA" rel="nofollow"><code>MANAGE_MEDIA</code></a> 权限和 <a href="https://developer.android.google.cn/reference/android/Manifest.permission#READ_EXTERNAL_STORAGE" rel="nofollow"><code>READ_EXTERNAL_STORAGE</code></a> 权限。</p> <p>为了调用 <code>createWriteRequest()</code> 而不显示确认对话框，请同时声明 <a href="https://developer.android.google.cn/reference/android/Manifest.permission#ACCESS_MEDIA_LOCATION" rel="nofollow"><code>ACCESS_MEDIA_LOCATION</code></a> 权限。</p> </li><li> <p>在您的应用中，向用户显示一个界面，说明为什么他们可能需要向您的应用授予媒体管理访问权限。</p> </li><li> <p>调用 <a href="https://developer.android.google.cn/reference/android/provider/Settings#ACTION_REQUEST_MANAGE_MEDIA" rel="nofollow"><code>ACTION_REQUEST_MANAGE_MEDIA</code></a> intent 操作。这样会将用户引导至系统设置中的<strong>媒体管理应用</strong>屏幕。在此处，用户可以授予特殊应用访问权限。</p> </li></ol> 
<h4 id="app-storage-access">应用存储访问权限</h4> 
<p>应用可以声明并创建一个自定义 activity，该 activity 在启动后可让用户管理应用存储在用户设备上的数据。应用可以在清单文件中使用 <a href="https://developer.android.google.cn/guide/topics/manifest/application-element#space" rel="nofollow"><code>android:manageSpaceActivity</code></a> 属性声明此自定义“管理空间”activity。文件管理器应用可以启动此“管理空间”activity，即使应用未导出该 activity（即，该 activity 将 <a href="https://developer.android.google.cn/guide/topics/manifest/activity-element#exported" rel="nofollow"><code>android:exported</code></a> 设置为 <code>false</code>）也是如此。</p> 
<p>在 Android 12 中，同时具有 <a href="https://developer.android.google.cn/reference/android/Manifest.permission#MANAGE_EXTERNAL_STORAGE" rel="nofollow"><code>MANAGE_EXTERNAL_STORAGE</code></a> 权限和 <a href="https://developer.android.google.cn/reference/android/Manifest.permission#QUERY_ALL_PACKAGES" rel="nofollow"><code>QUERY_ALL_PACKAGES</code></a> 权限的应用（如文件管理应用）可使用新的 <a href="https://developer.android.google.cn/reference/android/os/storage/StorageManager#getManageSpaceActivityIntent%28java.lang.String,%20int%29" rel="nofollow"><code>getManageSpaceActivityIntent()</code></a> 将用户引导至其他应用的自定义“管理空间”activity（如果为该应用定义了一个）。</p> 
<p><code>getManageSpaceActivityIntent()</code> 方法接受软件包名称和请求代码，它返回以下某一项：</p> 
<ul><li><a href="https://developer.android.google.cn/reference/android/app/PendingIntent" rel="nofollow"><code>PendingIntent</code></a> - 如果具有指定软件包名称的应用已定义自定义“管理空间”activity。调用 <code>getManageSpaceActivityIntent()</code> 方法的应用随后可以调用返回的 intent 以将用户引导至该自定义 activity。</li><li><code>null</code> - 如果具有指定软件包名称的应用未定义“管理空间”activity。</li></ul> 
<h4 id="extended-file-access">扩展的文件访问权限支持</h4> 
<p>除了对 <code>ExternalStorageProvider</code> URI 的现有支持以外，<a href="https://developer.android.google.cn/reference/android/provider/MediaStore#getMediaUri%28android.content.Context,%20android.net.Uri%29" rel="nofollow"><code>getMediaUri()</code></a> 方法现在还支持 <code>MediaDocumentsProvider</code> URI。现在，系统在返回这些 URI 之前将其授予调用方。</p> 
<p>此外，由 <a href="https://developer.android.google.cn/reference/android/provider/MediaStore#createWriteRequest%28android.content.ContentResolver,%20java.util.Collection%3Candroid.net.Uri%3E%29" rel="nofollow"><code>createWriteRequest()</code></a> 授予的媒体 URI 现在支持 <a href="https://developer.android.google.cn/reference/java/io/File" rel="nofollow"><code>File</code></a> 类中的 API。这些 API 提供了读取、写入、重命名和删除文件的功能。</p> 
<h3 id="core">核心功能</h3> 
<h4 id="automatic-app-updates">自动更新应用</h4> 
<p>Android 12 针对使用 <a href="https://developer.android.google.cn/reference/android/content/pm/PackageInstaller" rel="nofollow"><code>PackageInstaller</code></a> API 的应用引入了 <a href="https://developer.android.google.cn/reference/android/content/pm/PackageInstaller.SessionParams#setRequireUserAction%28int%29" rel="nofollow"><code>setRequireUserAction()</code></a> 方法。此方法可让安装程序应用执行应用更新而无需用户确认操作。</p> 
<h4 id="soc-info">设备芯片组信息</h4> 
<p>Android 12 向 <code>android.os.Build</code> 添加了两个常量，它们可通过 SDK 公开 SoC 芯片组供应商和型号信息。您可以通过分别调用 <code>Build.SOC_MANUFACTURER</code> 和 <code>Build.SOC_MODEL</code> 来检索此信息。</p> 
<h2 id="%E8%A1%8C%E4%B8%BA%E5%8F%98%E6%9B%B4%EF%BC%9A%E6%89%80%E6%9C%89%E5%BA%94%E7%94%A8">二：</h2> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%EF%BC%9A%E5%8A%9F%E8%83%BD%E5%92%8C%20API%20%E6%A6%82%E8%A7%88-toc" style="margin-left:0px;"><a href="#%E4%B8%80%EF%BC%9A%E5%8A%9F%E8%83%BD%E5%92%8C%20API%20%E6%A6%82%E8%A7%88" rel="nofollow">一：功能和 API 概览</a></p> 
<p id="experiences-toc" style="margin-left:40px;"><a href="#experiences" rel="nofollow">新体验</a></p> 
<p id="widgets-toc" style="margin-left:80px;"><a href="#widgets" rel="nofollow">微件改进</a></p> 
<p id="haptics-toc" style="margin-left:80px;"><a href="#haptics" rel="nofollow">音频耦合触感反馈效果</a></p> 
<p id="splash-screen-toc" style="margin-left:80px;"><a href="#splash-screen" rel="nofollow">启动画面 API</a></p> 
<p id="new-calls-toc" style="margin-left:80px;"><a href="#new-calls" rel="nofollow">允许按来电重要性排名的新通话通知</a></p> 
<p id="enriched_image_support_for_notifications-toc" style="margin-left:80px;"><a href="#enriched_image_support_for_notifications" rel="nofollow">通知的丰富图片支持</a></p> 
<p id="rounded_corner_apis-toc" style="margin-left:80px;"><a href="#rounded_corner_apis" rel="nofollow">圆角 API</a></p> 
<p id="pip-improvements-toc" style="margin-left:80px;"><a href="#pip-improvements" rel="nofollow">画中画 (PiP) 改进</a></p> 
<p id="immersive-mode-improvements-toc" style="margin-left:80px;"><a href="#immersive-mode-improvements" rel="nofollow">沉浸模式下的手势导航改进</a></p> 
<p id="unified-content-api-toc" style="margin-left:80px;"><a href="#unified-content-api" rel="nofollow">富媒体内容插入</a></p> 
<p id="camera-toc" style="margin-left:40px;"><a href="#camera" rel="nofollow">摄像头</a></p> 
<p id="camera-sensor-support-toc" style="margin-left:80px;"><a href="#camera-sensor-support" rel="nofollow">Quad Bayer 摄像头传感器支持</a></p> 
<p id="graphics-toc" style="margin-left:40px;"><a href="#graphics" rel="nofollow">图形和图片</a></p> 
<p id="provide_apps_direct_access_to_tombstone_traces-toc" style="margin-left:80px;"><a href="#provide_apps_direct_access_to_tombstone_traces" rel="nofollow">让应用能够直接访问 Tombstone 跟踪记录</a></p> 
<p id="avif-toc" style="margin-left:80px;"><a href="#avif" rel="nofollow">AVIF 图片支持</a></p> 
<p id="rendereffect-toc" style="margin-left:80px;"><a href="#rendereffect" rel="nofollow">更简单的模糊处理、颜色滤镜及其他效果</a></p> 
<p id="image-decoder-toc" style="margin-left:80px;"><a href="#image-decoder" rel="nofollow">原生动画图片解码</a></p> 
<p id="media-toc" style="margin-left:40px;"><a href="#media" rel="nofollow">媒体</a></p> 
<p id="transcoding-toc" style="margin-left:80px;"><a href="#transcoding" rel="nofollow">兼容的媒体转码</a></p> 
<p id="performance-class-toc" style="margin-left:80px;"><a href="#performance-class" rel="nofollow">性能等级</a></p> 
<p id="video-encoding-toc" style="margin-left:80px;"><a href="#video-encoding" rel="nofollow">视频编码改进</a></p> 
<p id="audio-focus-toc" style="margin-left:80px;"><a href="#audio-focus" rel="nofollow">音频焦点</a></p> 
<p id="mediadrm-toc" style="margin-left:80px;"><a href="#mediadrm" rel="nofollow">MediaDrm 更新</a></p> 
<p id="security-privacy-toc" style="margin-left:40px;"><a href="#security-privacy" rel="nofollow">安全和隐私设置</a></p> 
<p id="bluetooth-permissions-toc" style="margin-left:80px;"><a href="#bluetooth-permissions" rel="nofollow">蓝牙权限</a></p> 
<p id="privacy-dashboard-toc" style="margin-left:80px;"><a href="#privacy-dashboard" rel="nofollow">隐私信息中心</a></p> 
<p id="hide-application-overlay-windows-toc" style="margin-left:80px;"><a href="#hide-application-overlay-windows" rel="nofollow">隐藏应用叠加窗口</a></p> 
<p id="safer-grant-signature-perms-toc" style="margin-left:80px;"><a href="#safer-grant-signature-perms" rel="nofollow">已知签名者权限保护标志</a></p> 
<p id="device-properties-verification-toc" style="margin-left:80px;"><a href="#device-properties-verification" rel="nofollow">设备属性认证</a></p> 
<p id="notification-secure-toc" style="margin-left:80px;"><a href="#notification-secure" rel="nofollow">安全锁定屏幕通知操作</a></p> 
<p id="connectivity-toc" style="margin-left:40px;"><a href="#connectivity" rel="nofollow">连接性</a></p> 
<p id="bandwidth-estimation-toc" style="margin-left:80px;"><a href="#bandwidth-estimation" rel="nofollow">带宽估测改进</a></p> 
<p id="keep-awake-toc" style="margin-left:80px;"><a href="#keep-awake" rel="nofollow">使配套应用保持唤醒状态</a></p> 
<p id="cdm-profiles-toc" style="margin-left:80px;"><a href="#cdm-profiles" rel="nofollow">配套设备管理器配置文件</a></p> 
<p id="wifi-aware-enhancements-toc" style="margin-left:80px;"><a href="#wifi-aware-enhancements" rel="nofollow">Wi-Fi 感知 (NAN) 增强功能</a></p> 
<p id="concurrent-connections-toc" style="margin-left:80px;"><a href="#concurrent-connections" rel="nofollow">并发点对点 + 互联网连接</a></p> 
<p id="storage-toc" style="margin-left:40px;"><a href="#storage" rel="nofollow">存储</a></p> 
<p id="recordings-directory-toc" style="margin-left:80px;"><a href="#recordings-directory" rel="nofollow">语音录音的新目录</a></p> 
<p id="media-management-access-toc" style="margin-left:80px;"><a href="#media-management-access" rel="nofollow">媒体管理访问权限</a></p> 
<p id="app-storage-access-toc" style="margin-left:80px;"><a href="#app-storage-access" rel="nofollow">应用存储访问权限</a></p> 
<p id="extended-file-access-toc" style="margin-left:80px;"><a href="#extended-file-access" rel="nofollow">扩展的文件访问权限支持</a></p> 
<p id="core-toc" style="margin-left:40px;"><a href="#core" rel="nofollow">核心功能</a></p> 
<p id="automatic-app-updates-toc" style="margin-left:80px;"><a href="#automatic-app-updates" rel="nofollow">自动更新应用</a></p> 
<p id="soc-info-toc" style="margin-left:80px;"><a href="#soc-info" rel="nofollow">设备芯片组信息</a></p> 
<p id="%E8%A1%8C%E4%B8%BA%E5%8F%98%E6%9B%B4%EF%BC%9A%E6%89%80%E6%9C%89%E5%BA%94%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E8%A1%8C%E4%B8%BA%E5%8F%98%E6%9B%B4%EF%BC%9A%E6%89%80%E6%9C%89%E5%BA%94%E7%94%A8" rel="nofollow">二：</a></p> 
<p style="margin-left:0px;"><a href="#%E8%A1%8C%E4%B8%BA%E5%8F%98%E6%9B%B4%EF%BC%9A%E6%89%80%E6%9C%89%E5%BA%94%E7%94%A8" rel="nofollow">行为变更：所有应用</a></p> 
<p id="user_experience-toc" style="margin-left:40px;"><a href="#user_experience" rel="nofollow">用户体验</a></p> 
<p id="overscroll-toc" style="margin-left:80px;"><a href="#overscroll" rel="nofollow">滚动效果</a></p> 
<p id="foreground-service-notification-delay-toc" style="margin-left:80px;"><a href="#foreground-service-notification-delay" rel="nofollow">前台服务通知用户体验延迟</a></p> 
<p style="margin-left:80px;"><a href="#immersive-mode-improvements" rel="nofollow">沉浸模式下的手势导航改进</a></p> 
<p id="web-intent-resolution-toc" style="margin-left:80px;"><a href="#web-intent-resolution" rel="nofollow">网络 intent 解析</a></p> 
<p id="restrictive-app-standby-bucket-toc" style="margin-left:80px;"><a href="#restrictive-app-standby-bucket" rel="nofollow">限制性应用待机模式存储分区</a></p> 
<p id="displaymetrics-toc" style="margin-left:80px;"><a href="#displaymetrics" rel="nofollow">Display#getRealSize 和 getRealMetrics：废弃和沙盒</a></p> 
<p style="margin-left:40px;"><a href="#graphics" rel="nofollow">图形和图片</a></p> 
<p id="refresh-rate-toc" style="margin-left:80px;"><a href="#refresh-rate" rel="nofollow">改进了刷新率切换</a></p> 
<p style="margin-left:40px;"><a href="#security-privacy" rel="nofollow">安全和隐私设置</a></p> 
<p id="mic-camera-toggles-toc" style="margin-left:80px;"><a href="#mic-camera-toggles" rel="nofollow">麦克风和摄像头切换开关</a></p> 
<p id="mic-camera-indicators-toc" style="margin-left:80px;"><a href="#mic-camera-indicators" rel="nofollow">麦克风和摄像头指示标志</a></p> 
<p id="close-system-dialogs-toc" style="margin-left:80px;"><a href="#close-system-dialogs" rel="nofollow">应用无法关闭系统对话框</a></p> 
<p id="untrusted-touch-events-toc" style="margin-left:80px;"><a href="#untrusted-touch-events" rel="nofollow">不受信任的触摸事件被屏蔽</a></p> 
<p id="permission-package-visibility-toc" style="margin-left:80px;"><a href="#permission-package-visibility" rel="nofollow">权限软件包可见性</a></p> 
<p id="bouncy-castle-toc" style="margin-left:80px;"><a href="#bouncy-castle" rel="nofollow">移除了 Bouncy Castle 实现</a></p> 
<p id="clipboard-access-notifications-toc" style="margin-left:80px;"><a href="#clipboard-access-notifications" rel="nofollow">剪贴板访问通知</a></p> 
<p style="margin-left:40px;"><a href="#connectivity" rel="nofollow">连接性</a></p> 
<p id="passpoint-updates-toc" style="margin-left:80px;"><a href="#passpoint-updates" rel="nofollow">Passpoint 更新</a></p> 
<p id="non-sdk-restrictions-toc" style="margin-left:40px;"><a href="#non-sdk-restrictions" rel="nofollow">更新后的非 SDK 接口限制</a></p> 
<hr id="hr-toc"> 
<h2>行为变更：所有应用</h2> 
<p>Android 12 平台包含一些行为变更，这些变更可能会影响您的应用。以下行为变更将影响在 Android 12 上运行的<em>所有应用</em>，无论采用哪种 <code>targetSdkVersion</code> 都不例外。您应该测试您的应用，然后根据需要进行修改，以适当地支持这些变更。</p> 
<p>此外，请务必查看<a href="https://developer.android.google.cn/about/versions/12/behavior-changes-12" rel="nofollow">仅影响以 Android 12 为目标平台的应用的行为变更</a>列表。</p> 
<h3 id="user_experience">用户体验</h3> 
<h4 id="overscroll">滚动效果</h4> 
<p>滚动事件的行为在 Android 12 中发生了变化。如需了解详情，请参阅<a href="https://developer.android.google.cn/about/versions/12/overscroll" rel="nofollow">滚动效果</a>。</p> 
<h4 id="foreground-service-notification-delay">前台服务通知用户体验延迟</h4> 
<p>为了在 Android 12 上提供针对短时间运行的<a href="https://developer.android.google.cn/guide/components/foreground-services" rel="nofollow">前台服务</a>的流畅体验，系统可以为某些前台服务延迟 10 秒显示前台服务通知。此更改使某些短期任务在显示通知之前完成。</p> 
<p>如果某项前台服务至少具有以下特征之一，则系统会在服务启动后立即显示相关通知：</p> 
<ul><li>该服务与包含<a href="https://developer.android.google.cn/training/notify-user/build-notification#Actions" rel="nofollow">操作按钮</a>的通知相关联。</li><li>该服务的 <a href="https://developer.android.google.cn/guide/topics/manifest/service-element#foregroundservicetype" rel="nofollow"><code>foregroundServiceType</code></a> 为 <code>mediaPlayback</code>、<code>mediaProjection</code> 或 <code>phoneCall</code>。</li><li>该服务根据通知的<a href="https://developer.android.google.cn/reference/android/app/Notification#category" rel="nofollow">类别属性</a>中的定义，提供与通话、导航或媒体播放相关的用例。</li><li>该服务通过在设置通知时将 <code>FOREGROUND_SERVICE_IMMEDIATE</code> 传入 <a href="https://developer.android.google.cn/reference/android/app/Notification.Builder#setForegroundServiceBehavior%28int%29" rel="nofollow"><code>setForegroundServiceBehavior()</code></a>，已停用行为变更。</li></ul> 
<h4>沉浸模式下的手势导航改进</h4> 
<p>Android 12 简化了沉浸模式，使手势导航更简单且与其余活动体验（例如观看视频和阅读图书）更加一致。如需了解详情，请参阅<a href="https://developer.android.google.cn/about/versions/12/features#immersive-mode-improvements" rel="nofollow">功能页面</a>上的相应条目。</p> 
<h4 id="web-intent-resolution">网络 intent 解析</h4> 
<p>为了在用户选择网页链接时提供更流畅的体验，如果某个给定的网络 intent 包含未批准的网域，Android 12 会在用户的默认浏览器中打开该 intent。您的应用可以使用以下某种方法来获准处理网域：</p> 
<ul><li>使用 <a href="https://developer.android.google.cn/training/app-links/verify-site-associations" rel="nofollow">Android App Links</a> 验证网域。</li><li>请求用户将您的应用与网域相关联。</li></ul> 
<p>如果您的应用调用网络 intent，不妨考虑添加一个提示或对话框，要求用户确认操作。</p> 
<p>详细了解<a href="https://developer.android.google.cn/about/versions/12/web-intent-resolution" rel="nofollow">网络 intent 解析的变更</a>。</p> 
<h4 id="restrictive-app-standby-bucket">限制性应用待机模式存储分区</h4> 
<p><a href="https://developer.android.google.cn/topic/performance/appstandby" rel="nofollow">应用待机模式存储分区</a>有助于系统根据使用应用的时间新近度和频率来确定应用的资源请求的优先级。</p> 
<p>每个存储分区代表一个优先级。低优先级意味着系统会对运行您的应用施加更多限制。</p> 
<p>从 Android 12 开始，有一个名为“受限”的新存储分区。在所有存储分区中，受限存储分区的优先级最低（限制最高）。存储分区按优先级从高到低的顺序排列如下：</p> 
<ol><li>活跃：应用目前正在使用中，或者最近刚刚使用过</li><li>工作集：会定期使用应用</li><li>常用：会经常使用应用，但不是每天都使用</li><li>极少使用：不经常使用应用</li><li>受限</li></ol> 
<p>除了使用模式之外，系统还会考虑应用的行为，以决定是否要将您的应用放在受限存储分区中。如果您的应用更负责地使用系统资源，就不太可能被放在受限存储分区中。</p> 
<p>如果用户直接与您的应用互动，系统会将其放在一个限制较少的存储分区中。</p> 
<p>电源管理限制</p> 
<p>如果系统将您的应用放在受限存储分区中，会受到以下限制：</p> 
<ul><li>您每天可以在 10 分钟的批处理会话中<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager" rel="nofollow">运行作业</a>一次。在此会话期间，系统会将您应用的作业与其他应用的作业分组在一起。</li><li>与系统将您的应用放在限制较少的存储分区中相比，您的应用可以运行较少的<a href="https://developer.android.google.cn/about/versions/12/foreground-services#expedited-jobs" rel="nofollow">加急作业</a>。</li><li>您应用的不精确的<a href="https://developer.android.google.cn/training/scheduling/alarms" rel="nofollow">闹钟</a>每天传送一次。您在调用 <a href="https://developer.android.google.cn/reference/android/app/AlarmManager#set%28int,%20long,%20android.app.PendingIntent%29" rel="nofollow"><code>set()</code></a>、<a href="https://developer.android.google.cn/reference/android/app/AlarmManager#setInexactRepeating%28int,%20long,%20long,%20android.app.PendingIntent%29" rel="nofollow"><code>setInexactRepeating()</code></a>、<a href="https://developer.android.google.cn/reference/android/app/AlarmManager#setAndAllowWhileIdle%28int,%20long,%20android.app.PendingIntent%29" rel="nofollow"><code>setAndAllowWhileIdle()</code></a> 或 <a href="https://developer.android.google.cn/reference/android/app/AlarmManager#setWindow%28int,%20long,%20long,%20java.lang.String,%20android.app.AlarmManager.OnAlarmListener,%20android.os.Handler%29" rel="nofollow"><code>setWindow()</code></a> 方法时创建不精确的闹钟。</li><li>您的应用每天可以及时接收五条高优先级 <a href="https://firebase.google.cn/docs/cloud-messaging" rel="nofollow">Firebase Cloud Messaging (FCM)</a> 消息。所有后续 FCM 消息都按普通优先级传送，因此如果设备在节能模式下，这些消息可能会延迟。</li></ul> 
<p><strong>注意</strong>：与其他存储分区不同，即使设备正在充电，受限存储分区也会受到这些电源管理限制。不过，当设备正在充电、处于空闲状态以及在不按流量计费的网络上时，系统会放宽限制。</p> 
<p>允许运行前台服务</p> 
<p>如果系统将您的应用放在受限存储分区中，您的应用仍可运行<a href="https://developer.android.google.cn/guide/components/foreground-services" rel="nofollow">前台服务</a>。不过，如果您的应用以 Android 12 为目标平台，它仍会受到<a href="https://developer.android.google.cn/about/versions/12/foreground-services" rel="nofollow">前台服务启动限制</a>的影响。</p> 
<p>检查您的应用是否在受限存储分区中</p> 
<p>如需检查系统是否已将您的应用放在受限存储分区中，请调用 <a href="https://developer.android.google.cn/reference/android/app/usage/UsageStatsManager#getAppStandbyBucket%28%29" rel="nofollow"><code>getAppStandbyBucket()</code></a>。如果此方法的返回值为 <code>STANDBY_BUCKET_RESTRICTED</code>，则您的应用在受限存储分区中。</p> 
<p>测试受限存储分区行为</p> 
<p>如需测试您的应用在系统将其放在受限存储分区中时的行为，您可以手动将您的应用移至该存储分区。为此，请在终端窗口中运行以下命令：</p> 
<p></p> 
<pre><code class="language-html">adb shell am set-standby-bucket PACKAGE_NAME restricted
</code></pre> 
<h4 id="displaymetrics">Display#getRealSize 和 getRealMetrics：废弃和沙盒</h4> 
<p>Android 设备有许多不同的外形规格，如大屏设备、平板电脑和可折叠设备。为了针对每种设备适当地呈现内容，您的应用需要确定屏幕或显示屏尺寸。随着时间的推移，Android 提供了不同的 API 来检索此信息。在 Android 11 中，我们引入了 <a href="https://developer.android.google.cn/reference/android/view/WindowMetrics" rel="nofollow"><code>WindowMetrics</code></a> API 并废弃了以下方法：</p> 
<ul><li><a href="https://developer.android.google.cn/reference/android/view/Display#getSize%28android.graphics.Point%29" rel="nofollow"><code>Display.getSize()</code></a></li><li><a href="https://developer.android.google.cn/reference/android/view/Display#getMetrics%28android.util.DisplayMetrics%29" rel="nofollow"><code>Display.getMetrics()</code></a></li></ul> 
<p>在 Android 12 中，我们继续建议使用 <code>WindowMetrics</code>，并且正在逐步废弃以下方法：</p> 
<ul><li><a href="https://developer.android.google.cn/reference/android/view/Display#getRealSize%28android.graphics.Point%29" rel="nofollow"><code>Display.getRealSize()</code></a></li><li><a href="https://developer.android.google.cn/reference/android/view/Display#getRealMetrics%28android.util.DisplayMetrics%29" rel="nofollow"><code>Display.getRealMetrics()</code></a></li></ul> 
<p>为了缓解应用使用 Display API 检索应用边界的行为，Android 12 添加了一种新的沙盒机制来更正这些 API 返回的信息。这可能会对将此信息与 <code>MediaProjection</code> 一起使用的应用产生影响。</p> 
<p>应用应使用 <code>WindowMetrics</code> API 查询其窗口的边界，并使用 <a href="https://developer.android.google.cn/reference/android/content/res/Configuration#densityDpi" rel="nofollow"><code>Configuration.densityDpi</code></a> 查询当前的密度。</p> 
<p>为了与较低的 Android 版本实现更广泛的兼容性，您可以使用 Jetpack <a href="https://developer.android.google.cn/jetpack/androidx/releases/window" rel="nofollow"><code>WindowManager</code></a> 库，它包含一个 <a href="https://developer.android.google.cn/reference/androidx/window/WindowMetrics" rel="nofollow"><code>WindowMetrics</code></a> 类，该类支持 Android 4.0（API 级别 14）及更高版本。</p> 
<p>关于如何使用 WindowMetrics 的示例</p> 
<p>首先，确保应用的 activity <a href="https://developer.android.google.cn/guide/topics/ui/multi-window" rel="nofollow">完全可调整大小</a>。</p> 
<p>activity 应依赖于来自 activity 上下文的 <code>WindowMetrics</code> 来执行任何与界面相关的工作，特别是 <a href="https://developer.android.google.cn/reference/androidx/window/WindowManager#getCurrentWindowMetrics%28%29" rel="nofollow"><code>WindowManager.getCurrentWindowMetrics()</code></a>。</p> 
<p>如果您的应用创建了 <code>MediaProjection</code>，则必须正确地调整边界的大小，因为投影会捕捉显示内容。如果应用完全可调整大小，则 activity 上下文会返回正确的边界，如下所示：</p> 
<p></p> 
<pre><code>WindowMetrics projectionMetrics = activityContext
        .getSystemService(WindowManager.class).getMaximumWindowMetrics();
</code></pre> 
<p>如果应用并非完全可调整大小，则必须从 <code>WindowContext</code> 实例查询边界，并使用 <a href="https://developer.android.google.cn/reference/androidx/window/WindowManager#getMaximumWindowMetrics%28%29" rel="nofollow"><code>WindowManager.getMaximumWindowMetrics()</code></a> 检索应用可用的最大显示区域的 <code>WindowMetrics</code>。</p> 
<p></p> 
<pre><code>Context windowContext = mContext.createWindowContext(mContext.getDisplay(),
        TYPE_APPLICATION, null /* options */);
WindowMetrics projectionMetrics = windowContext.getWindowManager()
        .getMaximumWindowMetrics();
</code></pre> 
<p><strong>注意</strong>：使用 <code>MediaProjection</code> 的任何库也应遵循此建议，并查询应用窗口的相应 <code>WindowMetrics</code>。</p> 
<h3>图形和图片</h3> 
<h4 id="refresh-rate">改进了刷新率切换</h4> 
<p>在 Android 12 中，无论显示屏是否支持无缝过渡到新的刷新率，都会发生使用 <a href="https://developer.android.google.cn/reference/android/view/Surface#setFrameRate%28float,%20int,%20boolean%29" rel="nofollow"><code>setFrameRate()</code></a> 实现的刷新率变化；无缝过渡是指没有任何视觉中断，比如一两秒钟的黑屏。以前，如果显示屏不支持无缝过渡，它在调用 <code>setFrameRate()</code> 后通常会继续使用同一刷新率。您可以调用 <a href="https://developer.android.google.cn/reference/android/view/Display.Mode#getAlternativeRefreshRates%28%29" rel="nofollow"><code>getAlternativeRefreshRates()</code></a> 来提前确定向新刷新率的过渡是否有可能是无缝过渡。通常，会在刷新率切换完成后调用回调 <a href="https://developer.android.google.cn/reference/android/hardware/display/DisplayManager.DisplayListener#onDisplayChanged%28int%29" rel="nofollow"><code>onDisplayChanged()</code></a>，但对于某些外接显示屏，会在非无缝过渡期间调用该回调。</p> 
<p>以下示例说明了您可以如何实现此行为：</p> 
<p><a href="https://developer.android.google.cn/about/versions/12/behavior-changes-all#kotlin" rel="nofollow">Kotlin</a></p> 
<pre><code class="language-Kotlin">// Determine whether the transition will be seamless.
// Non-seamless transitions may cause a 1-2 second black screen.
val refreshRates = this.display?.mode?.alternativeRefreshRates
        val willbeSeamless = Arrays.asList&lt;FloatArray&gt;(refreshRates).contains(newRefreshRate)

// Set the frame rate even if the transition will not be seamless.
surface.setFrameRate(newRefreshRate, FRAME_RATE_COMPATIBILITY_FIXED_SOURCE, CHANGE_FRAME_RATE_ALWAYS)</code></pre> 
<pre><code class="language-html">Java

</code></pre> 
<pre><code class="language-java">// Determine whether the transition will be seamless.
// Non-seamless transitions may cause a 1-2 second black screen.
Display display = context.getDisplay(); // API 30+
Display.Mode mode = display.getMode();
float[] refreshRates = mode.getAlternativeRefreshRates();
boolean willbeSeamless = Arrays.asList(refreshRates).contains(newRefreshRate);

// Set the frame rate even if the transition will not be seamless.
surface.setFrameRate(newRefreshRate, FRAME_RATE_COMPATIBILITY_FIXED_SOURCE, CHANGE_FRAME_RATE_ALWAYS);</code></pre> 
<pre></pre> 
<h3>安全和隐私设置</h3> 
<h4 id="mic-camera-toggles">麦克风和摄像头切换开关<br><br>  </h4> 
<p></p> 
<p><strong>图 1.</strong> “快捷设置”中的麦克风和摄像头切换开关。</p> 
<p>在 Android 12 中，<a href="https://developer.android.google.cn/about/versions/12/behavior-changes-all#mic-camera-toggles-check-device-support" rel="nofollow">受支持的设备</a>允许用户通过按一个切换开关选项，为设备上的所有应用启用和停用摄像头和麦克风使用权限。用户可以从<a href="https://support.google.com/android/answer/9083864" rel="nofollow">快捷设置</a>访问可切换的选项（如图 1 所示），也可以从系统设置中的“隐私设置”屏幕访问。</p> 
<p>摄像头和麦克风切换开关会影响设备上的所有应用：</p> 
<ul><li>当用户关闭摄像头使用权限后，应用会收到空白的摄像头画面。</li><li> <p>当用户关闭麦克风使用权限后，应用会收到无声音频。此外，无论您是否声明 <a href="https://developer.android.google.cn/reference/android/Manifest.permission#HIGH_SAMPLING_RATE_SENSORS" rel="nofollow"><code>HIGH_SAMPLING_RATE_SENSORS</code></a> 权限，<a href="https://developer.android.google.cn/about/versions/12/behavior-changes-12#motion-sensor-rate-limiting" rel="nofollow">移动传感器都有采样率限制</a>。</p> <p><strong>注意</strong>：当用户拨打应急服务电话（如 911）时，系统会开启麦克风使用权限。此行为可保护用户安全。</p> </li></ul> 
<p>当用户关闭摄像头或麦克风的使用权限，然后启动需要使用摄像头或麦克风信息的应用时，系统会提醒用户，设备范围的切换开关已关闭。</p> 
<p>检查给定的设备是否支持麦克风和摄像头切换开关</p> 
<p>如需检查设备是否支持麦克风和摄像头切换开关，请添加以下代码段中所示的逻辑：</p> 
<p><a href="https://developer.android.google.cn/about/versions/12/behavior-changes-all#kotlin" rel="nofollow">Kotlin</a></p> 
<pre><code class="language-Kotlin">val sensorPrivacyManager = applicationContext
        .getSystemService(SensorPrivacyManager::class.java)
        as SensorPrivacyManager
val supportsMicrophoneToggle = sensorPrivacyManager
        .supportsSensorToggle(Sensors.MICROPHONE)
val supportsCameraToggle = sensorPrivacyManager
        .supportsSensorToggle(Sensors.CAMERA)</code></pre> 
<pre><code class="language-html">Java

</code></pre> 
<pre><code class="language-java">SensorPrivacyManager sensorPrivacyManager = getApplicationContext()
        .getSystemService(SensorPrivacyManager.class);
boolean supportsMicrophoneToggle = sensorPrivacyManager
        .supportsSensorToggle(Sensors.MICROPHONE);
boolean supportsCameraToggle = sensorPrivacyManager
        .supportsSensorToggle(Sensors.CAMERA);</code></pre> 
<p>检查响应麦克风和摄像头切换开关的应用行为</p> 
<p>麦克风和摄像头切换开关不应影响您的应用处理 <a href="https://developer.android.google.cn/reference/android/Manifest.permission#CAMERA" rel="nofollow"><code>CAMERA</code></a> 和 <a href="https://developer.android.google.cn/reference/android/Manifest.permission#RECORD_AUDIO" rel="nofollow"><code>RECORD_AUDIO</code></a> 权限的方式，前提是您<a href="https://developer.android.google.cn/guide/topics/permissions/overview#best-practices" rel="nofollow">遵循关于 Android 权限的最佳做法</a>。</p> 
<p>特别是，确保您的应用做到以下几点：</p> 
<ul><li>等到用户向您的应用授予 <code>CAMERA</code> 权限后再使用设备的摄像头。</li><li>等到用户向您的应用授予 <code>RECORD_AUDIO</code> 权限后再使用设备的麦克风。</li></ul> 
<h4 id="mic-camera-indicators">麦克风和摄像头指示标志</h4> 
<p></p> 
<p> 麦克风和摄像头指示标志，显示了最近的数据访问。</p> 
<p>在搭载 Android 12 的设备上，当应用使用麦克风或摄像头时，图标会出现在状态栏中。如果应用处于<a href="https://developer.android.google.cn/training/system-ui/immersive#immersive" rel="nofollow">沉浸模式</a>，则图标会出现在屏幕的右上角。用户可以打开“快捷设置”，并选择图标以查看哪些应用当前正在使用麦克风或摄像头。图 2 显示了包含图标的示例屏幕截图。</p> 
<p>为了提供更好的用户体验，在用户明确向您的应用授予权限之前，请勿使用麦克风或摄像头。</p> 
<h4 id="close-system-dialogs">应用无法关闭系统对话框</h4> 
<p>为了加强用户与应用和系统互动时的控制，从 Android 12 开始，弃用了 <a href="https://developer.android.google.cn/reference/android/content/Intent#ACTION_CLOSE_SYSTEM_DIALOGS" rel="nofollow"><code>ACTION_CLOSE_SYSTEM_DIALOGS</code></a> intent 操作。除了<a href="https://developer.android.google.cn/about/versions/12/behavior-changes-all#close-system-dialogs-exceptions" rel="nofollow">一些特殊情况</a>之外，当应用尝试<a href="https://developer.android.google.cn/guide/components/intents-filters" rel="nofollow">调用包含此操作的 intent</a> 时，系统会基于应用的目标 SDK 版本执行以下操作之一：</p> 
<ul><li>如果应用以 Android 12 为目标平台，则会发生 <a href="https://developer.android.google.cn/reference/java/lang/SecurityException" rel="nofollow"><code>SecurityException</code></a>。</li><li> <p>如果应用以 Android 11（API 级别 30）或更低版本为目标平台，则系统不会执行 intent，并且 <a href="https://developer.android.google.cn/studio/command-line/logcat" rel="nofollow">Logcat</a> 中会显示以下消息：</p> <p></p> <pre><code class="language-html">E ActivityTaskManager Permission Denial: \
android.intent.action.CLOSE_SYSTEM_DIALOGS broadcast from \
com.package.name requires android.permission.BROADCAST_CLOSE_SYSTEM_DIALOGS, \
dropping broadcast.
</code></pre> </li></ul> 
<p>异常</p> 
<p>在以下情况下，应用仍然可以在 Android 12 上关闭系统对话框：</p> 
<ul><li>您的应用运行的是<a href="https://developer.android.google.cn/training/testing/unit-testing/instrumented-unit-tests" rel="nofollow">插桩测试</a>。</li><li> <p>您的应用以 Android 11 或更低版本为目标平台，并在<a href="https://material.io/design/platform-guidance/android-notifications#behavior" rel="nofollow">抽屉式通知栏</a>顶部显示一个窗口。</p> <p><strong>注意</strong>：如果您的应用以 Android 12 为目标平台，在这种情况下您无需使用 <code>ACTION_CLOSE_SYSTEM_DIALOGS</code>。这是因为，如果在窗口位于抽屉式通知栏的顶部时您的应用调用 <a href="https://developer.android.google.cn/reference/android/content/Context#startActivity%28android.content.Intent%29" rel="nofollow"><code>startActivity()</code></a>，系统会自动关闭抽屉式通知栏。</p> </li><li> <p>您的应用以 Android 11 或更低版本为目标平台。此外，用户已与通知互动，可能使用了通知的<a href="https://developer.android.google.cn/training/notify-user/build-notification#Actions" rel="nofollow">操作按钮</a>，您的应用正在处理<a href="https://developer.android.google.cn/guide/components/services" rel="nofollow">服务</a>或<a href="https://developer.android.google.cn/guide/components/broadcasts" rel="nofollow">广播接收器</a>来响应该用户操作。</p> </li><li> <p>您的应用以 Android 11 或更低版本为目标平台并且具有有效的<a href="https://developer.android.google.cn/guide/topics/ui/accessibility/service" rel="nofollow">无障碍服务</a>。如果您的应用以 Android 12 为目标平台并且想要关闭通知栏，请改用 <a href="https://developer.android.google.cn/reference/android/accessibilityservice/AccessibilityService#GLOBAL_ACTION_DISMISS_NOTIFICATION_SHADE" rel="nofollow"><code>GLOBAL_ACTION_DISMISS_NOTIFICATION_SHADE</code></a> 无障碍操作。</p> </li></ul> 
<h4 id="untrusted-touch-events">不受信任的触摸事件被屏蔽</h4> 
<p>为了维持系统安全并保持良好的用户体验，Android 12 会阻止应用使用<a href="https://developer.android.google.cn/training/gestures" rel="nofollow">触摸事件</a>，使用触摸事件时叠加层会以不安全的方式遮掩应用。 换言之，系统会屏蔽穿透某些窗口的触摸操作，但<a href="https://developer.android.google.cn/about/versions/12/behavior-changes-all#untrusted-touch-events-exceptions" rel="nofollow">有一些例外情况</a>。</p> 
<p>受影响的应用</p> 
<p>此变更会影响选择让触摸操作穿透其窗口的应用，例如使用 <a href="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams#FLAG_NOT_TOUCHABLE" rel="nofollow"><code>FLAG_NOT_TOUCHABLE</code></a> 标志。包括但不限于以下示例：</p> 
<ul><li>需要 <a href="https://developer.android.google.cn/reference/android/Manifest.permission#SYSTEM_ALERT_WINDOW" rel="nofollow"><code>SYSTEM_ALERT_WINDOW</code></a> 权限并使用 <code>FLAG_NOT_TOUCHABLE</code> 标志的叠加层，例如使用 <a href="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY" rel="nofollow"><code>TYPE_APPLICATION_OVERLAY</code></a> 的窗口。</li><li>使用 <code>FLAG_NOT_TOUCHABLE</code> 标志的 activity 窗口。</li></ul> 
<p>异常</p> 
<p>在以下情况下，允许执行“穿透”触摸操作：</p> 
<ul><li><strong>应用中的互动</strong>。您的应用会显示叠加层，并且只有当用户与您的应用进行互动时才会显示叠加层。</li><li> <p><strong>可信窗口</strong>。包括但不限于以下窗口：</p> 
  <ul><li><a href="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams#TYPE_ACCESSIBILITY_OVERLAY" rel="nofollow">无障碍窗口</a></li><li><a href="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams#TYPE_INPUT_METHOD" rel="nofollow">输入法 (IME) 窗口</a></li><li><a href="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams#FLAG_NOT_TOUCHABLE" rel="nofollow">Google 助理窗口</a></li></ul><p><strong>注意</strong>：类型为 <a href="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY" rel="nofollow"><code>TYPE_APPLICATION_OVERLAY</code></a> 的窗口<strong>不受</strong>信任。</p> </li><li> <p><strong>不可见窗口</strong>。窗口的根视图是 <a href="https://developer.android.google.cn/reference/android/view/View#GONE" rel="nofollow"><code>GONE</code></a> 或 <a href="https://developer.android.google.cn/reference/android/view/View#INVISIBLE" rel="nofollow"><code>INVISIBLE</code></a>。</p> </li><li> <p><strong>全透明窗口</strong>。窗口的 <a href="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams#alpha" rel="nofollow"><code>alpha</code></a> 属性为 0.0。</p> </li><li> <p><strong>足够半透明的系统警报窗口</strong>。当组合后的不透明度小于或等于系统针对触摸的最大遮掩不透明度时，系统会将一组系统警报窗口视为足够半透明。在 Android 12 Beta 版中，这一最大不透明度为 0.8。此值在未来的 Beta 版中可能会发生变化。</p> </li></ul> 
<p>在不受信任的触摸操作被屏蔽时能够检测到</p> 
<p>如果系统屏蔽触摸操作，<a href="https://developer.android.google.cn/studio/command-line/logcat" rel="nofollow">Logcat</a> 会记录以下消息：</p> 
<p></p> 
<pre><code>Untrusted touch due to occlusion by PACKAGE_NAME
</code></pre> 
<p>测试变更</p> 
<p>在搭载 Android 12 开发者预览版 3 的设备上，默认情况下会屏蔽不受信任的触摸操作。如需允许不受信任的触摸操作，请在终端窗口中运行以下 <a href="https://developer.android.google.cn/studio/command-line/adb" rel="nofollow">ADB 命令</a>：</p> 
<p></p> 
<pre><code class="language-html"># A specific app
adb shell am compat disable BLOCK_UNTRUSTED_TOUCHES com.example.app

# All apps
# If you'd still like to see a Logcat message warning when a touch would be
# blocked, use 1 instead of 0.
adb shell settings put global block_untrusted_touches 0
</code></pre> 
<p>如需将行为还原为默认设置（不受信任的触摸操作被屏蔽），请运行以下命令：</p> 
<p></p> 
<pre><code class="language-html"># A specific app
adb shell am compat reset BLOCK_UNTRUSTED_TOUCHES com.example.app

# All apps
adb shell settings put global block_untrusted_touches 2
</code></pre> 
<h4 id="permission-package-visibility">权限软件包可见性</h4> 
<p>在搭载 Android 12 的设备上，根据应用对其他应用的<a href="https://developer.android.google.cn/training/package-visibility" rel="nofollow">软件包可见性</a>，以 Android 11（API 级别 30）或更高版本为目标平台且调用以下某种方法的应用会收到一组过滤后的结果：</p> 
<ul><li><a href="https://developer.android.google.cn/reference/android/content/pm/PackageManager#getAllPermissionGroups%28int%29" rel="nofollow"><code>getAllPermissionGroups()</code></a></li><li><a href="https://developer.android.google.cn/reference/android/content/pm/PackageManager#getPermissionGroupInfo%28java.lang.String,%20int%29" rel="nofollow"><code>getPermissionGroupInfo()</code></a></li><li><a href="https://developer.android.google.cn/reference/android/content/pm/PackageManager#getPermissionInfo%28java.lang.String,%20int%29" rel="nofollow"><code>getPermissionInfo()</code></a></li><li><a href="https://developer.android.google.cn/reference/android/content/pm/PackageManager#queryPermissionsByGroup%28java.lang.String,%20int%29" rel="nofollow"><code>queryPermissionsByGroup()</code></a></li></ul> 
<h4 id="bouncy-castle">移除了 Bouncy Castle 实现</h4> 
<p>Android 12 移除了之前废弃的加密算法（包括所有 AES 算法）的许多 <a href="https://www.bouncycastle.org/" rel="nofollow">BouncyCastle</a> 实现。系统改用这些算法的 <a href="https://github.com/google/conscrypt">Conscrypt</a> 实现。</p> 
<p>如果符合以下任何条件，则此变更会影响您的应用：</p> 
<ul><li><strong>您的应用使用 512 位的密钥大小</strong>。Conscrypt 不支持此密钥大小。如有必要，请更新您应用的加密逻辑以使用其他密钥大小。</li><li> <p><strong>您的应用将无效的密钥大小与 <code>KeyGenerator</code> 一起使用</strong>。与 BouncyCastle 相比，Conscrypt 的 <a href="https://developer.android.google.cn/reference/javax/crypto/KeyGenerator" rel="nofollow"><code>KeyGenerator</code></a> 实现会对密钥参数执行额外的验证。例如，Conscrypt 不允许您的应用生成 64 位 AES 密钥，因为 AES 仅支持 128 位、192 位和 256 位密钥。</p> <p>BouncyCastle 允许生成大小无效的密钥，但如果稍后这些密钥与 <a href="https://developer.android.google.cn/reference/javax/crypto/Cipher" rel="nofollow"><code>Cipher</code></a> 一起使用，验证会失败。如果使用 Conscrypt，验证失败的时间会更早。</p> </li><li> <p><strong>您使用并非 12 字节的大小初始化伽罗瓦/计数器模式 (GCM) 加密</strong>。Conscrypt 的 <a href="https://developer.android.google.cn/reference/javax/crypto/spec/GCMParameterSpec" rel="nofollow"><code>GcmParameterSpec</code></a> 实现要求初始化为 12 字节，这是 NIST 推荐的做法。</p> </li></ul> 
<h4 id="clipboard-access-notifications">剪贴板访问通知</h4> 
<p>在 Android 12 中，当某个应用首次调用 <a href="https://developer.android.google.cn/reference/android/content/ClipboardManager#getPrimaryClip%28%29" rel="nofollow"><code>getPrimaryClip()</code></a> 以访问来自其他应用的 <code>ClipData</code> 时，系统会显示一条消息框消息，通知用户此次剪贴板访问。</p> 
<p>消息框消息内的文本包含以下格式：<code>APP pasted from your clipboard.</code></p> 
<p>检索剪贴说明时未显示消息</p> 
<p>您的应用可能会调用 <a href="https://developer.android.google.cn/reference/android/content/ClipboardManager#getPrimaryClipDescription%28%29" rel="nofollow"><code>getPrimaryClipDescription()</code></a> 以接收有关剪贴板上当前数据的信息。当您的应用调用此方法时，系统不会显示消息框消息。</p> 
<p>Android 12 增强了此方法以检测下面这些额外的详细信息：</p> 
<ul><li>使用 <a href="https://developer.android.google.cn/reference/android/content/ClipDescription#isStyledText%28%29" rel="nofollow"><code>isStyledText()</code></a> 检测样式化文本。</li><li>使用 <a href="https://developer.android.google.cn/reference/android/content/ClipDescription#getConfidenceScore%28java.lang.String%29" rel="nofollow"><code>getConfidenceScore()</code></a> 检测文本的不同分类，如网址。</li></ul> 
<h3>连接性</h3> 
<h4 id="passpoint-updates">Passpoint 更新</h4> 
<p>Android 12 中添加了以下 API：</p> 
<ul><li><a href="https://developer.android.google.cn/reference/android/net/wifi/WifiManager#isPasspointTermsAndConditionsSupported%28%29" rel="nofollow"><code>isPasspointTermsAndConditionsSupported()</code></a>：“条款及条件”是一项 <a href="https://developer.android.google.cn/guide/topics/connectivity/passpoint" rel="nofollow">Passpoint</a> 功能，允许网络部署将不安全的强制门户（使用开放网络）替换为安全的 Passpoint 网络。当要求用户接受条款及条件时，系统会向用户显示一条通知。如果应用建议的 Passpoint 网络受条款及条件制约，应用必须先调用此 API，以确保设备支持该功能。如果设备不支持该功能，就不能连接到此网络，并且必须建议一个替代网络或旧网络。</li><li> <p><a href="https://developer.android.google.cn/reference/android/net/wifi/WifiManager#isDecoratedIdentitySupported%28%29" rel="nofollow"><code>isDecoratedIdentitySupported()</code></a>：对带有前缀修饰的网络进行身份验证时，修饰的身份前缀允许网络运营商更新网络访问标识符 (NAI)，以通过 AAA 网络内的多个代理执行显式路由（如需详细了解这一点，请参阅 <a href="https://datatracker.ietf.org/doc/html/rfc7542" rel="nofollow">RFC 7542</a>）。</p> <p>Android 12 实现了此功能，以符合 <a href="https://wballiance.com/wp-content/uploads/2021/03/WBA-PPS-MO-Extensions-v1.0.0.pdf" rel="nofollow">PPS-MO 扩展的 WBA 规范</a>。如果应用建议的 Passpoint 网络需要修饰的身份，应用必须先调用此 API，以确保设备支持该功能。如果设备不支持该功能，身份就不会进行修饰，并且对网络的身份验证可能会失败。</p> </li></ul> 
<p>如需创建 Passpoint 建议，应用必须使用 <a href="https://developer.android.google.cn/reference/android/net/wifi/hotspot2/PasspointConfiguration" rel="nofollow"><code>PasspointConfiguration</code></a>、<a href="https://developer.android.google.cn/reference/android/net/wifi/hotspot2/pps/Credential" rel="nofollow"><code>Credential</code></a> 和 <a href="https://developer.android.google.cn/reference/android/net/wifi/hotspot2/pps/HomeSp" rel="nofollow"><code>HomeSp</code></a> 类。这些类描述了 <a href="https://www.wi-fi.org/downloads-registered-guest/Passpoint_Specification_Package_v3.2.zip/35974" rel="nofollow">Wi-Fi Alliance Passpoint 规范</a>中定义的 Passpoint 配置文件。</p> 
<h3 id="non-sdk-restrictions">更新后的非 SDK 接口限制</h3> 
<p>Android 12 包含更新后的受限制非 SDK 接口列表（基于与 Android 开发者之间的协作以及最新的内部测试）。在限制使用非 SDK 接口之前，我们会尽可能确保有可用的公开替代方案。</p> 
<p>如果您的应用并非以 Android 12 为目标平台，其中一些变更可能不会立即对您产生影响。然而，虽然您目前仍可以使用一些非 SDK 接口（<a href="https://developer.android.google.cn/guide/app-compatibility/restrictions-non-sdk-interfaces#list-names" rel="nofollow">具体取决于应用的目标 API 级别</a>），但只要您使用任何非 SDK 方法或字段，终归存在导致应用出问题的显著风险。</p> 
<p>如果您不确定自己的应用是否使用了非 SDK 接口，则可以<a href="https://developer.android.google.cn/guide/app-compatibility/restrictions-non-sdk-interfaces#test-for-non-sdk" rel="nofollow">测试您的应用</a>来进行确认。如果您的应用依赖于非 SDK 接口，您应该开始计划迁移到 SDK 替代方案。然而，我们知道某些应用具有使用非 SDK 接口的有效用例。如果您无法为应用中的某项功能找到使用非 SDK 接口的替代方案，应<a href="https://developer.android.google.cn/guide/app-compatibility/restrictions-non-sdk-interfaces#feature-request" rel="nofollow">请求新的公共 API</a>。</p> 
<p>如需详细了解此 Android 版本中的变更，请参阅 <a href="https://developer.android.google.cn/about/versions/12/non-sdk-12" rel="nofollow">Android 12 中有关限制非 SDK 接口的更新</a>。如需全面了解有关非 SDK 接口的详细信息，请参阅<a href="https://developer.android.google.cn/guide/app-compatibility/restrictions-non-sdk-interfaces" rel="nofollow">对非 SDK 接口的限制</a>。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/537d7137e898ca301e944f78df4cefa6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">战地一显示枪械被服务器停用,战地2里禁用武器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c046029b8cccb3ebefccf5a002f34ce3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">QScrollBar滚动条</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>