<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>八股文--MySql - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="八股文--MySql" />
<meta property="og:description" content="扫码关注公众号获取更多内容
索引
1. 索引是什么？
2. 索引有哪些优缺点？
3. MySQL有哪几种索引类型？
4. 说一说索引的底层实现？
5. 为什么索引结构默认使用B&#43;Tree，而不是B-Tree，Hash，二叉树，红黑树？
6. 讲一讲聚簇索引与非聚簇索引？
7. 非聚簇索引一定会回表查询吗？
8. 联合索引是什么？为什么需要注意联合索引中的顺序？
9. 讲一讲MySQL的最左前缀原则?
10. 讲一讲前缀索引？
11. 了解索引下推吗？
12. 怎么查看MySQL语句有没有用到索引？
13. 为什么官方建议使用自增长主键作为索引？
14. 如何创建索引？
15. 创建索引时需要注意什么？
16. 建索引的原则有哪些？
17. 使用索引查询一定能提高查询的性能吗？
18. 什么情况下不走索引（索引失效）？
基础
1. 数据库的三范式是什么？
2. MySQL 支持哪些存储引擎?
3. 超键、候选键、主键、外键分别是什么？
4. SQL 约束有哪几种？
5. MySQL 中的 varchar 和 char 有什么区别？
6. MySQL中 in 和 exists 区别
7. drop、delete与truncate的区别
8. 什么是存储过程？有哪些优缺点？
9. MySQL 执行查询的过程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/8ab7ca5498820253993221dc950efd54/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-08T15:29:07+08:00" />
<meta property="article:modified_time" content="2021-10-08T15:29:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">八股文--MySql</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:right;">扫码关注公众号获取更多内容</p> 
<h3 id="%E2%80%8B" style="text-align:right;"><img alt="" height="204" src="https://images2.imgbox.com/d7/61/XABbKtn1_o.png" width="205"></h3> 
<p id="%E7%B4%A2%E5%BC%95-toc" style="margin-left:40px;"><a href="#%E7%B4%A2%E5%BC%95" rel="nofollow" title="索引">索引</a></p> 
<p id="1.%20%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"><a href="#1.%20%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow" title="1. 索引是什么？">1. 索引是什么？</a></p> 
<p id="2.%20%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F-toc" style="margin-left:40px;"><a href="#2.%20%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F" rel="nofollow" title="2. 索引有哪些优缺点？">2. 索引有哪些优缺点？</a></p> 
<p id="3.%20MySQL%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%EF%BC%9F-toc" style="margin-left:40px;"><a href="#3.%20MySQL%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%EF%BC%9F" rel="nofollow" title="3. MySQL有哪几种索引类型？">3. MySQL有哪几种索引类型？</a></p> 
<p id="4.%20%E8%AF%B4%E4%B8%80%E8%AF%B4%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9F-toc" style="margin-left:40px;"><a href="#4.%20%E8%AF%B4%E4%B8%80%E8%AF%B4%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9F" rel="nofollow" title="4. 说一说索引的底层实现？">4. 说一说索引的底层实现？</a></p> 
<p id="5.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8B%2BTree%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AFB-Tree%EF%BC%8CHash%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F-toc" style="margin-left:40px;"><a href="#5.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8B%2BTree%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AFB-Tree%EF%BC%8CHash%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F" rel="nofollow" title="5. 为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？">5. 为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？</a></p> 
<p id="6.%20%E8%AE%B2%E4%B8%80%E8%AE%B2%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%9F-toc" style="margin-left:40px;"><a href="#6.%20%E8%AE%B2%E4%B8%80%E8%AE%B2%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%9F" rel="nofollow" title="6. 讲一讲聚簇索引与非聚簇索引？">6. 讲一讲聚簇索引与非聚簇索引？</a></p> 
<p id="7.%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F-toc" style="margin-left:40px;"><a href="#7.%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F" rel="nofollow" title="7. 非聚簇索引一定会回表查询吗？">7. 非聚簇索引一定会回表查询吗？</a></p> 
<p id="8.%20%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%9F-toc" style="margin-left:40px;"><a href="#8.%20%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%9F" rel="nofollow" title="8. 联合索引是什么？为什么需要注意联合索引中的顺序？">8. 联合索引是什么？为什么需要注意联合索引中的顺序？</a></p> 
<p id="9.%20%E8%AE%B2%E4%B8%80%E8%AE%B2MySQL%E7%9A%84%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%3F-toc" style="margin-left:40px;"><a href="#9.%20%E8%AE%B2%E4%B8%80%E8%AE%B2MySQL%E7%9A%84%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%3F" rel="nofollow" title="9. 讲一讲MySQL的最左前缀原则?">9. 讲一讲MySQL的最左前缀原则?</a></p> 
<p id="10.%20%E8%AE%B2%E4%B8%80%E8%AE%B2%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%EF%BC%9F-toc" style="margin-left:40px;"><a href="#10.%20%E8%AE%B2%E4%B8%80%E8%AE%B2%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%EF%BC%9F" rel="nofollow" title="10. 讲一讲前缀索引？">10. 讲一讲前缀索引？</a></p> 
<p id="11.%20%E4%BA%86%E8%A7%A3%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E5%90%97%EF%BC%9F-toc" style="margin-left:40px;"><a href="#11.%20%E4%BA%86%E8%A7%A3%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E5%90%97%EF%BC%9F" rel="nofollow" title="11. 了解索引下推吗？">11. 了解索引下推吗？</a></p> 
<p id="12.%20%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8BMySQL%E8%AF%AD%E5%8F%A5%E6%9C%89%E6%B2%A1%E6%9C%89%E7%94%A8%E5%88%B0%E7%B4%A2%E5%BC%95%EF%BC%9F-toc" style="margin-left:40px;"><a href="#12.%20%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8BMySQL%E8%AF%AD%E5%8F%A5%E6%9C%89%E6%B2%A1%E6%9C%89%E7%94%A8%E5%88%B0%E7%B4%A2%E5%BC%95%EF%BC%9F" rel="nofollow" title="12. 怎么查看MySQL语句有没有用到索引？">12. 怎么查看MySQL语句有没有用到索引？</a></p> 
<p id="13.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%98%E6%96%B9%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9E%E9%95%BF%E4%B8%BB%E9%94%AE%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%EF%BC%9F-toc" style="margin-left:40px;"><a href="#13.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%98%E6%96%B9%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9E%E9%95%BF%E4%B8%BB%E9%94%AE%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%EF%BC%9F" rel="nofollow" title="13. 为什么官方建议使用自增长主键作为索引？">13. 为什么官方建议使用自增长主键作为索引？</a></p> 
<p id="14.%20%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F-toc" style="margin-left:40px;"><a href="#14.%20%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F" rel="nofollow" title="14. 如何创建索引？">14. 如何创建索引？</a></p> 
<p id="15.%20%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"><a href="#15.%20%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow" title="15. 创建索引时需要注意什么？">15. 创建索引时需要注意什么？</a></p> 
<p id="16.%20%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-toc" style="margin-left:40px;"><a href="#16.%20%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" rel="nofollow" title="16. 建索引的原则有哪些？">16. 建索引的原则有哪些？</a></p> 
<p id="17.%20%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E4%B8%80%E5%AE%9A%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%80%A7%E8%83%BD%E5%90%97%EF%BC%9F-toc" style="margin-left:40px;"><a href="#17.%20%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E4%B8%80%E5%AE%9A%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%80%A7%E8%83%BD%E5%90%97%EF%BC%9F" rel="nofollow" title="17. 使用索引查询一定能提高查询的性能吗？">17. 使用索引查询一定能提高查询的性能吗？</a></p> 
<p id="18.%20%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E8%B5%B0%E7%B4%A2%E5%BC%95%EF%BC%88%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%EF%BC%89%EF%BC%9F-toc" style="margin-left:40px;"><a href="#18.%20%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E8%B5%B0%E7%B4%A2%E5%BC%95%EF%BC%88%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%EF%BC%89%EF%BC%9F" rel="nofollow" title="18. 什么情况下不走索引（索引失效）？">18. 什么情况下不走索引（索引失效）？</a></p> 
<p id="%E5%9F%BA%E7%A1%80-toc" style="margin-left:40px;"><a href="#%E5%9F%BA%E7%A1%80" rel="nofollow" title="基础">基础</a></p> 
<p id="1.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"><a href="#1.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow" title="1. 数据库的三范式是什么？">1. 数据库的三范式是什么？</a></p> 
<p id="2.%20MySQL%20%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%3F-toc" style="margin-left:40px;"><a href="#2.%20MySQL%20%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%3F" rel="nofollow" title="2. MySQL 支持哪些存储引擎?">2. MySQL 支持哪些存储引擎?</a></p> 
<p id="3.%20%E8%B6%85%E9%94%AE%E3%80%81%E5%80%99%E9%80%89%E9%94%AE%E3%80%81%E4%B8%BB%E9%94%AE%E3%80%81%E5%A4%96%E9%94%AE%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"><a href="#3.%20%E8%B6%85%E9%94%AE%E3%80%81%E5%80%99%E9%80%89%E9%94%AE%E3%80%81%E4%B8%BB%E9%94%AE%E3%80%81%E5%A4%96%E9%94%AE%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow" title="3. 超键、候选键、主键、外键分别是什么？">3. 超键、候选键、主键、外键分别是什么？</a></p> 
<p id="4.%20SQL%20%E7%BA%A6%E6%9D%9F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F-toc" style="margin-left:40px;"><a href="#4.%20SQL%20%E7%BA%A6%E6%9D%9F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F" rel="nofollow" title="4. SQL 约束有哪几种？">4. SQL 约束有哪几种？</a></p> 
<p id="5.%20MySQL%20%E4%B8%AD%E7%9A%84%20varchar%20%E5%92%8C%20char%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:40px;"><a href="#5.%20MySQL%20%E4%B8%AD%E7%9A%84%20varchar%20%E5%92%8C%20char%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow" title="5. MySQL 中的 varchar 和 char 有什么区别？">5. MySQL 中的 varchar 和 char 有什么区别？</a></p> 
<p id="6.%20MySQL%E4%B8%AD%20in%20%E5%92%8C%20exists%20%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#6.%20MySQL%E4%B8%AD%20in%20%E5%92%8C%20exists%20%E5%8C%BA%E5%88%AB" rel="nofollow" title="6. MySQL中 in 和 exists 区别">6. MySQL中 in 和 exists 区别</a></p> 
<p id="7.%20drop%E3%80%81delete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#7.%20drop%E3%80%81delete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow" title="7. drop、delete与truncate的区别">7. drop、delete与truncate的区别</a></p> 
<p id="8.%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F-toc" style="margin-left:40px;"><a href="#8.%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F" rel="nofollow" title="8. 什么是存储过程？有哪些优缺点？">8. 什么是存储过程？有哪些优缺点？</a></p> 
<p id="9.%20MySQL%20%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#9.%20MySQL%20%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%BF%87%E7%A8%8B" rel="nofollow" title="9. MySQL 执行查询的过程">9. MySQL 执行查询的过程</a></p> 
<p id="%E4%BA%8B%E5%8A%A1-toc" style="margin-left:40px;"><a href="#%E4%BA%8B%E5%8A%A1" rel="nofollow" title="事务">事务</a></p> 
<p id="1.%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%EF%BC%9F-toc" style="margin-left:40px;"><a href="#1.%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%EF%BC%9F" rel="nofollow" title="1. 什么是数据库事务？">1. 什么是数据库事务？</a></p> 
<p id="2.%20%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%85%B7%E6%9C%89%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81-toc" style="margin-left:40px;"><a href="#2.%20%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%85%B7%E6%9C%89%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81" rel="nofollow" title="2. 介绍一下事务具有的四个特征">2. 介绍一下事务具有的四个特征</a></p> 
<p id="3.%20%E8%AF%B4%E4%B8%80%E4%B8%8BMySQL%20%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-toc" style="margin-left:40px;"><a href="#3.%20%E8%AF%B4%E4%B8%80%E4%B8%8BMySQL%20%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" rel="nofollow" title="3. 说一下MySQL 的四种隔离级别">3. 说一下MySQL 的四种隔离级别</a></p> 
<p id="4.%20%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%8F%E8%AF%BB%EF%BC%9F%E5%B9%BB%E8%AF%BB%EF%BC%9F%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%9F-toc" style="margin-left:40px;"><a href="#4.%20%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%8F%E8%AF%BB%EF%BC%9F%E5%B9%BB%E8%AF%BB%EF%BC%9F%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%9F" rel="nofollow" title="4. 什么是脏读？幻读？不可重复读？">4. 什么是脏读？幻读？不可重复读？</a></p> 
<p id="5.%20%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#5.%20%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" rel="nofollow" title="5. 事务的实现原理">5. 事务的实现原理</a></p> 
<p id="6.%20MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BB%8B%E7%BB%8D%E4%B8%8B%EF%BC%9F-toc" style="margin-left:40px;"><a href="#6.%20MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BB%8B%E7%BB%8D%E4%B8%8B%EF%BC%9F" rel="nofollow" title="6. MySQL事务日志介绍下？">6. MySQL事务日志介绍下？</a></p> 
<p id="redo%20log-toc" style="margin-left:80px;"><a href="#redo%20log" rel="nofollow" title="redo log">redo log</a></p> 
<p id="undo%20log-toc" style="margin-left:80px;"><a href="#undo%20log" rel="nofollow" title="undo log">undo log</a></p> 
<p id="7.%20%E4%BB%80%E4%B9%88%E6%98%AFMySQL%E7%9A%84%20binlog%EF%BC%9F-toc" style="margin-left:40px;"><a href="#7.%20%E4%BB%80%E4%B9%88%E6%98%AFMySQL%E7%9A%84%20binlog%EF%BC%9F" rel="nofollow" title="7. 什么是MySQL的 binlog？">7. 什么是MySQL的 binlog？</a></p> 
<p id="8.%20%E5%9C%A8%E4%BA%8B%E5%8A%A1%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%90%97%EF%BC%9F-toc" style="margin-left:40px;"><a href="#8.%20%E5%9C%A8%E4%BA%8B%E5%8A%A1%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%90%97%EF%BC%9F" rel="nofollow" title="8. 在事务中可以混合使用存储引擎吗？">8. 在事务中可以混合使用存储引擎吗？</a></p> 
<p id="9.%20MySQL%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84%3F-toc" style="margin-left:40px;"><a href="#9.%20MySQL%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84%3F" rel="nofollow" title="9. MySQL中是如何实现事务隔离的?">9. MySQL中是如何实现事务隔离的?</a></p> 
<p id="10.%20%E4%BB%80%E4%B9%88%E6%98%AF%20MVCC%EF%BC%9F-toc" style="margin-left:40px;"><a href="#10.%20%E4%BB%80%E4%B9%88%E6%98%AF%20MVCC%EF%BC%9F" rel="nofollow" title="10. 什么是 MVCC？">10. 什么是 MVCC？</a></p> 
<p id="11.%20MVCC%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#11.%20MVCC%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" rel="nofollow" title="11. MVCC 的实现原理">11. MVCC 的实现原理</a></p> 
<p id="%E9%94%81-toc" style="margin-left:40px;"><a href="#%E9%94%81" rel="nofollow" title="锁">锁</a></p> 
<p id="1.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0%E9%94%81%3F-toc" style="margin-left:40px;"><a href="#1.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0%E9%94%81%3F" rel="nofollow" title="1. 为什么要加锁?">1. 为什么要加锁?</a></p> 
<p id="2.%20%E6%8C%89%E7%85%A7%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%86%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-toc" style="margin-left:40px;"><a href="#2.%20%E6%8C%89%E7%85%A7%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%86%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" rel="nofollow" title="2. 按照锁的粒度分数据库锁有哪些？">2. 按照锁的粒度分数据库锁有哪些？</a></p> 
<p id="3.%20%E4%BB%8E%E9%94%81%E7%9A%84%E7%B1%BB%E5%88%AB%E4%B8%8A%E5%88%86MySQL%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81%E5%91%A2%EF%BC%9F-toc" style="margin-left:40px;"><a href="#3.%20%E4%BB%8E%E9%94%81%E7%9A%84%E7%B1%BB%E5%88%AB%E4%B8%8A%E5%88%86MySQL%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81%E5%91%A2%EF%BC%9F" rel="nofollow" title="3. 从锁的类别上分MySQL都有哪些锁呢？">3. 从锁的类别上分MySQL都有哪些锁呢？</a></p> 
<p id="4.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F-toc" style="margin-left:40px;"><a href="#4.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F" rel="nofollow" title="4. 数据库的乐观锁和悲观锁是什么？怎么实现的？">4. 数据库的乐观锁和悲观锁是什么？怎么实现的？</a></p> 
<p id="5.%20InnoDB%E5%BC%95%E6%93%8E%E7%9A%84%E8%A1%8C%E9%94%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F-toc" style="margin-left:40px;"><a href="#5.%20InnoDB%E5%BC%95%E6%93%8E%E7%9A%84%E8%A1%8C%E9%94%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F" rel="nofollow" title="5. InnoDB引擎的行锁是怎么实现的？">5. InnoDB引擎的行锁是怎么实现的？</a></p> 
<p id="6.%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F-toc" style="margin-left:40px;"><a href="#6.%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F" rel="nofollow" title="6. 什么是死锁？怎么解决？">6. 什么是死锁？怎么解决？</a></p> 
<p id="7.%20%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB-toc" style="margin-left:40px;"><a href="#7.%20%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB" rel="nofollow" title="7. 隔离级别与锁的关系">7. 隔离级别与锁的关系</a></p> 
<p id="8.%20%E4%BC%98%E5%8C%96%E9%94%81%E6%96%B9%E9%9D%A2%E7%9A%84%E6%84%8F%E8%A7%81%EF%BC%9F-toc" style="margin-left:40px;"><a href="#8.%20%E4%BC%98%E5%8C%96%E9%94%81%E6%96%B9%E9%9D%A2%E7%9A%84%E6%84%8F%E8%A7%81%EF%BC%9F" rel="nofollow" title="8. 优化锁方面的意见？">8. 优化锁方面的意见？</a></p> 
<p id="Mysql%E4%BC%98%E5%8C%96-toc" style="margin-left:40px;"><a href="#Mysql%E4%BC%98%E5%8C%96" rel="nofollow" title="Mysql优化">Mysql优化</a></p> 
<p id="1.%20%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%8F%8A%E4%BC%98%E5%8C%96SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%EF%BC%9F-toc" style="margin-left:40px;"><a href="#1.%20%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%8F%8A%E4%BC%98%E5%8C%96SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%EF%BC%9F" rel="nofollow" title="1. 如何定位及优化SQL语句的性能问题？">1. 如何定位及优化SQL语句的性能问题？</a></p> 
<p id="2.%20%E5%A4%A7%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96-toc" style="margin-left:40px;"><a href="#2.%20%E5%A4%A7%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96" rel="nofollow" title="2. 大表数据查询，怎么优化">2. 大表数据查询，怎么优化</a></p> 
<p id="3.%20%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%3F-toc" style="margin-left:40px;"><a href="#3.%20%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%3F" rel="nofollow" title="3. 超大分页怎么处理?">3. 超大分页怎么处理?</a></p> 
<p id="4.%20%E7%BB%9F%E8%AE%A1%E8%BF%87%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F%E5%AF%B9%E6%85%A2%E6%9F%A5%E8%AF%A2%E9%83%BD%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E8%BF%87%EF%BC%9F-toc" style="margin-left:40px;"><a href="#4.%20%E7%BB%9F%E8%AE%A1%E8%BF%87%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F%E5%AF%B9%E6%85%A2%E6%9F%A5%E8%AF%A2%E9%83%BD%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E8%BF%87%EF%BC%9F" rel="nofollow" title="4. 统计过慢查询吗？对慢查询都怎么优化过？">4. 统计过慢查询吗？对慢查询都怎么优化过？</a></p> 
<p id="5.%20%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE-toc" style="margin-left:40px;"><a href="#5.%20%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE" rel="nofollow" title="5. 如何优化查询过程中的数据访问">5. 如何优化查询过程中的数据访问</a></p> 
<p id="6.%20%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2-toc" style="margin-left:40px;"><a href="#6.%20%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2" rel="nofollow" title="6. 如何优化关联查询">6. 如何优化关联查询</a></p> 
<p id="7.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96-toc" style="margin-left:40px;"><a href="#7.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96" rel="nofollow" title="7. 数据库结构优化">7. 数据库结构优化</a></p> 
<p id="8.%20MySQL%E6%95%B0%E6%8D%AE%E5%BA%93cpu%E9%A3%99%E5%8D%87%E5%88%B0500%25%E7%9A%84%E8%AF%9D%E4%BB%96%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F-toc" style="margin-left:40px;"><a href="#8.%20MySQL%E6%95%B0%E6%8D%AE%E5%BA%93cpu%E9%A3%99%E5%8D%87%E5%88%B0500%25%E7%9A%84%E8%AF%9D%E4%BB%96%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F" rel="nofollow" title="8. MySQL数据库cpu飙升到500%的话他怎么处理？">8. MySQL数据库cpu飙升到500%的话他怎么处理？</a></p> 
<p id="9.%20%E5%A4%A7%E8%A1%A8%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F-toc" style="margin-left:40px;"><a href="#9.%20%E5%A4%A7%E8%A1%A8%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F" rel="nofollow" title="9. 大表怎么优化？">9. 大表怎么优化？</a></p> 
<hr id="hr-toc"> 
<h3 id="%E7%B4%A2%E5%BC%95" style="text-align:center;"><strong><span style="color:#a2e043;">索引</span></strong></h3> 
<h3 id="1.%20%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">1. 索引是什么？</h3> 
<p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p> 
<p>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。而且索引是一个文件，它是要占据物理空间的。</p> 
<p>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了。</p> 
<h3 id="2.%20%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F">2. 索引有哪些优缺点？</h3> 
<p>索引的优点</p> 
<ul><li> <p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p> </li><li> <p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p> </li></ul> 
<p>索引的缺点</p> 
<ul><li> <p>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</p> </li><li> <p>空间方面：索引需要占物理空间。</p> </li></ul> 
<h3 id="3.%20MySQL%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%EF%BC%9F">3. MySQL有哪几种索引类型？</h3> 
<p>1、从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式，</p> 
<p>2、从应用层次来分：普通索引，唯一索引，复合索引。</p> 
<ul><li> <p>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引</p> </li><li> <p>唯一索引：索引列的值必须唯一，但允许有空值</p> </li><li> <p>复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</p> </li><li> <p>聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。</p> </li><li> <p>非聚簇索引：不是聚簇索引，就是非聚簇索引</p> </li></ul> 
<p>3、根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引。</p> 
<h3 id="4.%20%E8%AF%B4%E4%B8%80%E8%AF%B4%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9F">4. 说一说索引的底层实现？</h3> 
<p>Hash索引</p> 
<p>基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。</p> 
<blockquote> 
 <p>图片来源：https://www.javazhiyin.com/40232.html</p> 
</blockquote> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/0a/a9/BPplyBtC_o.png"></p> 
<p>B-Tree索引（MySQL使用B+Tree）</p> 
<p>B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。</p> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/84/0b/TVHGMVI8_o.png"></p> 
<p>B+Tree索引</p> 
<p>是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。</p> 
<p>B+tree性质：</p> 
<ul><li> <p>n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</p> </li><li> <p>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p> </li><li> <p>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</p> </li><li> <p>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</p> </li><li> <p>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p> </li></ul> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/d4/e2/f0ufJlzw_o.png"></p> 
<h3 id="5.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8B%2BTree%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AFB-Tree%EF%BC%8CHash%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F">5. 为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？</h3> 
<p>B-tree：从两个方面来回答</p> 
<ul><li> <p>B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B(B-)树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对<code>IO读写次数就降低</code>了。</p> </li><li> <p>由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在<code>区间查询</code>的情况，所以通常B+树用于数据库索引。</p> </li></ul> 
<p>Hash：</p> 
<ul><li> <p>虽然可以快速定位，但是没有顺序，IO复杂度高；</p> </li></ul> 
<ul><li> <p>基于Hash表实现，只有Memory存储引擎显式支持哈希索引 ；</p> </li><li> <p>适合等值查询，如=、in()、&lt;=&gt;，不支持范围查询 ；</p> </li><li> <p>因为不是按照索引值顺序存储的，就不能像B+Tree索引一样利用索引完成排序 ；</p> </li><li> <p>Hash索引在查询等值时非常快 ；</p> </li><li> <p>因为Hash索引始终索引的所有列的全部内容，所以不支持部分索引列的匹配查找 ；</p> </li><li> <p>如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 。</p> </li></ul> 
<p>二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。</p> 
<p>红黑树：树的高度随着数据量增加而增加，IO代价高。</p> 
<h3 id="6.%20%E8%AE%B2%E4%B8%80%E8%AE%B2%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%9F">6. 讲一讲聚簇索引与非聚簇索引？</h3> 
<p>在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引，即将数据存储与索引放到了一块，找到索引也就找到了数据。</p> 
<p>而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引、二级索引。</p> 
<p>聚簇索引与非聚簇索引的区别：</p> 
<ul><li> <p>非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键（行号）</p> </li><li> <p>对于InnoDB来说，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。第一次索引一般是顺序IO，回表的操作属于随机IO。需要回表的次数越多，即随机IO次数越多，我们就越倾向于使用全表扫描 。</p> </li><li> <p>通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。当然，如果是覆盖索引的话，查一次即可</p> </li><li> <p>注意：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。</p> </li></ul> 
<h3 id="7.%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F">7. 非聚簇索引一定会回表查询吗？</h3> 
<p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为"覆盖索引"。</p> 
<p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行<code>select score from student where score &gt; 90</code>的查询时，在索引的叶子节点上，已经包含了score 信息，不会再次进行回表查询。</p> 
<h3 id="8.%20%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%9F">8. 联合索引是什么？为什么需要注意联合索引中的顺序？</h3> 
<p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p> 
<p>具体原因为:</p> 
<p>MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p> 
<p>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p> 
<h3 id="9.%20%E8%AE%B2%E4%B8%80%E8%AE%B2MySQL%E7%9A%84%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%3F">9. 讲一讲MySQL的最左前缀原则?</h3> 
<p>最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p> 
<p>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p> 
<h3 id="10.%20%E8%AE%B2%E4%B8%80%E8%AE%B2%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%EF%BC%9F">10. 讲一讲前缀索引？</h3> 
<p>因为可能我们索引的字段非常长，这既占内存空间，也不利于维护。所以我们就想，如果只把很长字段的前面的公共部分作为一个索引，就会产生超级加倍的效果。但是，我们需要注意，order by不支持前缀索引 。</p> 
<p>流程是：</p> 
<p>先计算完整列的选择性 :<code> select count(distinct col_1)/count(1) from table_1</code></p> 
<p>再计算不同前缀长度的选择性 :<code>select count(distinct left(col_1,4))/count(1) from table_1</code></p> 
<p>找到最优长度之后，创建前缀索引 :<code> create index idx_front on table_1 (col_1(4))</code></p> 
<h3 id="11.%20%E4%BA%86%E8%A7%A3%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E5%90%97%EF%BC%9F">11. 了解索引下推吗？</h3> 
<p>MySQL 5.6引入了索引下推优化。默认开启，使用SET optimizer_switch = ‘index_condition_pushdown=off’;可以将其关闭。</p> 
<ul><li> <p>有了索引下推优化，可以在减少回表次数</p> </li><li> <p>在InnoDB中只针对二级索引有效</p> </li></ul> 
<p>官方文档中给的例子和解释如下：</p> 
<p>在 people_table中有一个二级索引(zipcode，lastname，address)，查询是SELECT * FROM people WHERE zipcode=’95054′ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’;</p> 
<ul><li> <p>如果没有使用索引下推技术，则MySQL会通过zipcode=’95054’从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断数据是否符合条件</p> </li><li> <p>如果使用了索引下推技术，则MYSQL首先会返回符合zipcode=’95054’的索引，然后根据lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。</p> </li></ul> 
<h3 id="12.%20%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8BMySQL%E8%AF%AD%E5%8F%A5%E6%9C%89%E6%B2%A1%E6%9C%89%E7%94%A8%E5%88%B0%E7%B4%A2%E5%BC%95%EF%BC%9F">12. 怎么查看MySQL语句有没有用到索引？</h3> 
<p>通过explain，如以下例子：</p> 
<p><code>EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND title='Senior Engineer' AND from_date='1986-06-26';</code></p> 
<table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>filtered</th><th>rows</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>titles</td><td>null</td><td>const</td><td>PRIMARY</td><td>PRIMARY</td><td>59</td><td>const,const,const</td><td>10</td><td>1</td><td></td></tr></tbody></table> 
<ul><li> <p>id：在⼀个⼤的查询语句中每个SELECT关键字都对应⼀个唯⼀的id ，如explain select * from s1 where id = (select id from s1 where name = 'egon1');第一个select的id是1，第二个select的id是2。有时候会出现两个select，但是id却都是1，这是因为优化器把子查询变成了连接查询 。</p> </li><li> <p>select_type：select关键字对应的那个查询的类型，如SIMPLE,PRIMARY,SUBQUERY,DEPENDENT,SNION 。</p> </li><li> <p>table：每个查询对应的表名 。</p> </li><li> <p>type：<code>type</code> 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 <code>type</code> 字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等。如const(主键索引或者唯一二级索引进行等值匹配的情况下),ref(普通的⼆级索引列与常量进⾏等值匹配),index(扫描全表索引的覆盖索引) 。</p> <p>通常来说, 不同的 type 类型的性能关系如下: <code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code> <code>ALL</code> 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的. 而 <code>index</code> 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</p> </li><li> <p>possible_key：查询中可能用到的索引*(可以把用不到的删掉，降低优化器的优化时间)* 。</p> </li><li> <p>key：此字段是 MySQL 在当前查询时所真正使用到的索引。</p> </li><li> <p>filtered：查询器预测满足下一次查询条件的百分比 。</p> </li><li> <p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数. 这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好。</p> </li><li> <p>extra：表示额外信息，如Using where,Start temporary,End temporary,Using temporary等。</p> </li></ul> 
<h3 id="13.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%98%E6%96%B9%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9E%E9%95%BF%E4%B8%BB%E9%94%AE%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%EF%BC%9F">13. 为什么官方建议使用自增长主键作为索引？</h3> 
<p>结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。</p> 
<p>插入连续的数据：</p> 
<blockquote> 
 <p>图片来自：https://www.javazhiyin.com/40232.html</p> 
</blockquote> 
<p></p> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/b5/9f/brfcjSZN_o.gif"></p> 
<p>插入非连续的数据：</p> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/7e/ce/9IhgJkeX_o.gif"></p> 
<h3 id="14.%20%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F">14. 如何创建索引？</h3> 
<p>创建索引有三种方式。</p> 
<p>1、 在执行CREATE TABLE时创建索引</p> 
<pre>CREATE TABLE user_index2 (
	id INT auto_increment PRIMARY KEY,
	first_name VARCHAR (16),
	last_name VARCHAR (16),
	id_card VARCHAR (18),
	information text,
	KEY name (first_name, last_name),
	FULLTEXT KEY (information),
	UNIQUE KEY (id_card)
);
</pre> 
<p>2、 使用ALTER TABLE命令去增加索引。</p> 
<pre>ALTER TABLE table_name ADD INDEX index_name (column_list);</pre> 
<p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p> 
<p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p> 
<p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。3、 使用CREATE INDEX命令创建。</p> 
<pre>CREATE INDEX index_name ON table_name (column_list);</pre> 
<h3 id="15.%20%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F">15. 创建索引时需要注意什么？</h3> 
<ul><li> <p>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</p> </li><li> <p>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</p> </li><li> <p>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</p> </li></ul> 
<h3 id="16.%20%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><strong>16. 建索引的原则有哪些？</strong></h3> 
<p>1、最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p> 
<p>2、=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p> 
<p>3、尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</p> 
<p>4、索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。</p> 
<p>5、尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p> 
<h3 id="17.%20%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E4%B8%80%E5%AE%9A%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%80%A7%E8%83%BD%E5%90%97%EF%BC%9F"><strong>17. 使用索引查询一定能提高查询的性能吗？</strong></h3> 
<p>通常通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p> 
<p>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。这意味着每条记录的I* NSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</p> 
<ul><li> <p>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%。</p> </li><li> <p>基于非唯一性索引的检索。</p> </li></ul> 
<h3 id="18.%20%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E8%B5%B0%E7%B4%A2%E5%BC%95%EF%BC%88%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%EF%BC%89%EF%BC%9F"><strong>18. 什么情况下不走索引（索引失效）？</strong></h3> 
<p>1、使用!= 或者 &lt;&gt; 导致索引失效</p> 
<p>2、类型不一致导致的索引失效</p> 
<p>3、函数导致的索引失效</p> 
<p>如：</p> 
<pre>SELECT * FROM `user` WHERE DATE(create_time) = '2020-09-03';</pre> 
<p>如果使用函数在索引列，这是不走索引的。</p> 
<p>4、运算符导致的索引失效</p> 
<pre>SELECT * FROM `user` WHERE age - 1 = 20;</pre> 
<p>如果你对列进行了（+，-，*，/，!）, 那么都将不会走索引。</p> 
<p>5、OR引起的索引失效</p> 
<pre>SELECT * FROM `user` WHERE `name` = '张三' OR height = '175';</pre> 
<p>OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效，如果OR连接的是同一个字段，那么索引不会失效，反之索引失效。</p> 
<p>6、模糊搜索导致的索引失效</p> 
<pre>SELECT * FROM `user` WHERE `name` LIKE '%冰';</pre> 
<p>当<code>%</code>放在匹配字段前是不走索引的，放在后面才会走索引。</p> 
<p>7、NOT IN、NOT EXISTS导致索引失效</p> 
<p></p> 
<p></p> 
<h3 id="%E5%9F%BA%E7%A1%80" style="text-align:center;"><span style="color:#a2e043;"><strong>基础</strong></span></h3> 
<h3 id="1.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><strong>1. 数据库的三范式是什么？</strong></h3> 
<ul><li> <p>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</p> </li><li> <p>第二范式：要求实体的属性完全依赖于主关键字。所谓完全 依赖是指不能存在仅依赖主关键字一部分的属性。</p> </li><li> <p>第三范式：任何非主属性不依赖于其它非主属性。</p> </li></ul> 
<h3 id="2.%20MySQL%20%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%3F"><strong>2. MySQL 支持哪些存储引擎?</strong></h3> 
<p>MySQL 支持多种存储引擎,比如 InnoDB,MyISAM,Memory,Archive 等等.在大多数的情况下,直接选择使用 InnoDB 引擎都是最合适的,InnoDB 也是 MySQL 的默认存储引擎。</p> 
<p>MyISAM 和 InnoDB 的区别有哪些：</p> 
<ul><li> <p>InnoDB 支持事务，MyISAM 不支持</p> </li><li> <p>InnoDB 支持外键，而 MyISAM 不支持</p> </li><li> <p>InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高；MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。</p> </li><li> <p>Innodb 不支持全文索引，而 MyISAM 支持全文索引，查询效率上 MyISAM 要高；</p> </li><li> <p>InnoDB 不保存表的具体行数，MyISAM 用一个变量保存了整个表的行数。</p> </li><li> <p>MyISAM 采用表级锁(table-level locking)；InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p> </li></ul> 
<h3 id="3.%20%E8%B6%85%E9%94%AE%E3%80%81%E5%80%99%E9%80%89%E9%94%AE%E3%80%81%E4%B8%BB%E9%94%AE%E3%80%81%E5%A4%96%E9%94%AE%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><strong>3. 超键、候选键、主键、外键分别是什么？</strong></h3> 
<ul><li> <p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p> </li><li> <p>候选键：是最小超键，即没有冗余元素的超键。</p> </li><li> <p>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p> </li><li> <p>外键：在一个表中存在的另一个表的主键称此表的外键。</p> </li></ul> 
<h3 id="4.%20SQL%20%E7%BA%A6%E6%9D%9F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><strong>4. SQL 约束有哪几种？</strong></h3> 
<ul><li> <p>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</p> </li><li> <p>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</p> </li><li> <p>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</p> </li><li> <p>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</p> </li><li> <p>CHECK: 用于控制字段的值范围。</p> </li></ul> 
<h3 id="5.%20MySQL%20%E4%B8%AD%E7%9A%84%20varchar%20%E5%92%8C%20char%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><strong>5. MySQL 中的 varchar 和 char 有什么区别？</strong></h3> 
<p>char 是一个定长字段,假如申请了<code>char(10)</code>的空间,那么无论实际存储多少内容.该字段都占用 10 个字符,而 varchar 是变长的,也就是说申请的只是最大长度,占用的空间为实际字符长度+1,最后一个字符存储使用了多长的空间.</p> 
<p>在检索效率上来讲,char &gt; varchar,因此在使用中,如果确定某个字段的值的长度,可以使用 char,否则应该尽量使用 varchar.例如存储用户 MD5 加密后的密码,则应该使用 char。</p> 
<h3 id="6.%20MySQL%E4%B8%AD%20in%20%E5%92%8C%20exists%20%E5%8C%BA%E5%88%AB"><strong>6. MySQL中 in 和 exists 区别</strong></h3> 
<p>MySQL中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p> 
<p>如果查询的两个表大小相当，那么用in和exists差别不大。如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</p> 
<h3 id="7.%20drop%E3%80%81delete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>7. drop、delete与truncate的区别</strong></h3> 
<p>三者都表示删除，但是三者有一些差别：</p> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/cb/16/BoOte4Z9_o.png"></p> 
<h3 id="8.%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><strong>8. 什么是存储过程？有哪些优缺点？</strong></h3> 
<p>存储过程是一些预编译的 SQL 语句。</p> 
<p>1、更加直白的理解：存储过程可以说是一个记录集，它是由一些 T-SQL 语句组成的代码块，这些 T-SQL 语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。</p> 
<p>2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量 T_SQL 语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全</p> 
<p>但是,在互联网项目中,其实是不太推荐存储过程的,比较出名的就是阿里的《Java 开发手册》中禁止使用存储过程,我个人的理解是,在互联网项目中,迭代太快,项目的生命周期也比较短,人员流动相比于传统的项目也更加频繁,在这样的情况下,存储过程的管理确实是没有那么方便,同时,复用性也没有写在服务层那么好。</p> 
<h3 id="9.%20MySQL%20%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%BF%87%E7%A8%8B"><strong>9. MySQL 执行查询的过程</strong></h3> 
<ol><li> <p>客户端通过 TCP 连接发送连接请求到 MySQL 连接器，连接器会对该请求进行权限验证及连接资源分配</p> </li><li> <p>查缓存。（当判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用 SQL 语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。）</p> </li><li> <p>语法分析（SQL 语法是否写错了）。如何把语句给到预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义。</p> </li><li> <p>优化。是否使用索引，生成执行计划。</p> </li><li> <p>交给执行器，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。</p> </li></ol> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/2d/ad/br4H33mj_o.png"></p> 
<p>更新语句执行会复杂一点。需要检查表是否有排它锁，写 binlog，刷盘，是否执行 commit。</p> 
<h3 id="%E4%BA%8B%E5%8A%A1" style="text-align:center;"><span style="color:#a2e043;"><strong>事务</strong></span></h3> 
<h3 id="1.%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%EF%BC%9F"><strong>1. 什么是数据库事务？</strong></h3> 
<p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p> 
<p>事务最经典也经常被拿出来说例子就是转账了。</p> 
<p>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p> 
<h3 id="2.%20%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%85%B7%E6%9C%89%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81"><strong>2. 介绍一下事务具有的四个特征</strong></h3> 
<p>事务就是一组原子性的操作，这些操作要么全部发生，要么全部不发生。事务把数据库从一种一致性状态转换成另一种一致性状态。</p> 
<ul><li> <p>原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做</p> </li><li> <p>一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。</p> </li><li> <p>隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的//操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p> </li><li> <p>持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</p> </li></ul> 
<h3 id="3.%20%E8%AF%B4%E4%B8%80%E4%B8%8BMySQL%20%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><strong>3. 说一下MySQL 的四种隔离级别</strong></h3> 
<ul><li> <p>Read Uncommitted（读取未提交内容）</p> </li></ul> 
<p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p> 
<ul><li> <p>Read Committed（读取提交内容）</p> </li></ul> 
<p>这是大多数数据库系统的默认隔离级别（但不是 MySQL 默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓 的 不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的 commit，所以同一 select 可能返回不同结果。</p> 
<ul><li> <p>Repeatable Read（可重读）</p> </li></ul> 
<p>这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。</p> 
<ul><li> <p>Serializable（可串行化）</p> </li></ul> 
<p>通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/ca/d2/uZb1DuAe_o.png"></p> 
<p>MySQL 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</p> 
<p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p> 
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。</p> 
<p>InnoDB 存储引擎在 分布式事务 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</p> 
<h3 id="4.%20%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%8F%E8%AF%BB%EF%BC%9F%E5%B9%BB%E8%AF%BB%EF%BC%9F%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%9F"><strong>4. 什么是脏读？幻读？不可重复读？</strong></h3> 
<p>1、脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据</p> 
<p>2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致。</p> 
<p>3、幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p> 
<p>不可重复读侧重于修改，幻读侧重于新增或删除（多了或少量行），脏读是一个事务回滚影响另外一个事务。</p> 
<h3 id="5.%20%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><strong>5. 事务的实现原理</strong></h3> 
<p>事务是基于重做日志文件(redo log)和回滚日志(undo log)实现的。</p> 
<p>每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。</p> 
<p>每当有修改事务时，还会产生 undo log，如果需要回滚，则根据 undo log 的反向语句进行逻辑操作，比如 insert 一条记录就 delete 一条记录。undo log 主要实现数据库的一致性。</p> 
<h3 id="6.%20MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BB%8B%E7%BB%8D%E4%B8%8B%EF%BC%9F"><strong>6. MySQL事务日志介绍下？</strong></h3> 
<p>innodb 事务日志包括 redo log 和 undo log。</p> 
<p>undo log 指事务开始之前，在操作任何数据之前，首先将需操作的数据备份到一个地方。redo log 指事务中操作的任何数据，将最新的数据备份到一个地方。</p> 
<p>事务日志的目的：实例或者介质失败，事务日志文件就能派上用场。</p> 
<h4 id="redo%20log"><strong>redo log</strong></h4> 
<p>redo log 不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入 redo 中。具体的落盘策略可以进行配置 。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。RedoLog 是为了实现事务的持久性而出现的产物。</p> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/11/73/vsAFmL8b_o.png"></p> 
<h4 id="undo%20log"><strong>undo log</strong></h4> 
<p>undo log 用来回滚行记录到某个版本。事务未提交之前，Undo 保存了未提交之前的版本数据，Undo 中的数据可作为数据旧版本快照供其他并发事务进行快照读。是为了实现事务的原子性而出现的产物,在 MySQL innodb 存储引擎中用来实现多版本并发控制。</p> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/d9/81/PecgwNGl_o.png"></p> 
<h3 id="7.%20%E4%BB%80%E4%B9%88%E6%98%AFMySQL%E7%9A%84%20binlog%EF%BC%9F"><strong>7. 什么是MySQL的 binlog？</strong></h3> 
<p>MySQL的 binlog 是记录所有数据库表结构变更（例如 CREATE、ALTER TABLE）以及表数据修改（INSERT、UPDATE、DELETE）的二进制日志。binlog 不会记录 SELECT 和 SHOW 这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看 MySQL 执行过的所有语句。</p> 
<p>MySQL binlog 以事件形式记录，还包含语句所执行的消耗的时间，MySQL 的二进制日志是事务安全型的。binlog 的主要目的是复制和恢复。</p> 
<p>binlog 有三种格式，各有优缺点：</p> 
<ul><li> <p>statement： 基于 SQL 语句的模式，某些语句和函数如 UUID, LOAD DATA INFILE 等在复制过程可能导致数据不一致甚至出错。</p> </li><li> <p>row： 基于行的模式，记录的是行的变化，很安全。但是 binlog 会比其他两种模式大很多，在一些大表中清除大量数据时在 binlog 中会生成很多条语句，可能导致从库延迟变大。</p> </li><li> <p>mixed： 混合模式，根据语句来选用是 statement 还是 row 模式。</p> </li></ul> 
<h3 id="8.%20%E5%9C%A8%E4%BA%8B%E5%8A%A1%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%90%97%EF%BC%9F"><strong>8. 在事务中可以混合使用存储引擎吗？</strong></h3> 
<p>尽量不要在同一个事务中使用多种存储引擎，MySQL服务器层不管理事务，事务是由下层的存储引擎实现的。</p> 
<p>如果在事务中混合使用了事务型和非事务型的表（例如InnoDB和MyISAM表）,在正常提交的情况下不会有什么问题。</p> 
<p>但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。所以，为每张表选择合适的存储引擎非常重要。</p> 
<h3 id="9.%20MySQL%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84%3F"><strong>9. MySQL中是如何实现事务隔离的?</strong></h3> 
<p>读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行，效率太差。</p> 
<p>MySQL 在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 Next-Key 锁实现的。</p> 
<p>详细原理看这篇文章：https://haicoder.net/note/MySQL-interview/MySQL-interview-MySQL-trans-level.html</p> 
<h3 id="10.%20%E4%BB%80%E4%B9%88%E6%98%AF%20MVCC%EF%BC%9F"><strong>10. 什么是 MVCC？</strong></h3> 
<p>MVCC， 即多版本并发控制。MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p> 
<h3 id="11.%20MVCC%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><strong>11. MVCC 的实现原理</strong></h3> 
<p>对于 InnoDB ，聚簇索引记录中包含 3 个隐藏的列：</p> 
<ul><li> <p>ROW ID：隐藏的自增 ID，如果表没有主键，InnoDB 会自动按 ROW ID 产生一个聚集索引树。</p> </li><li> <p>事务 ID：记录最后一次修改该记录的事务 ID。</p> </li><li> <p>回滚指针：指向这条记录的上一个版本。</p> </li></ul> 
<p>我们拿上面的例子，对应解释下 MVCC 的实现原理，如下图：</p> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/75/0b/gmmQ9Xfn_o.png"></p> 
<p>如图，首先 insert 语句向表 t1 中插入了一条数据，a 字段为 1，b 字段为 1， ROW ID 也为 1 ，事务 ID 假设为 1，回滚指针假设为 null。当执行 update t1 set b=666 where a=1 时，大致步骤如下：</p> 
<ul><li> <p>数据库会先对满足 a=1 的行加排他锁；</p> </li><li> <p>然后将原记录复制到 undo 表空间中；</p> </li><li> <p>修改 b 字段的值为 666，修改事务 ID 为 2；</p> </li><li> <p>并通过隐藏的回滚指针指向 undo log 中的历史记录；</p> </li><li> <p>事务提交，释放前面对满足 a=1 的行所加的排他锁。</p> </li></ul> 
<p>在前面实验的第 6 步中，session2 查询的结果是 session1 修改之前的记录，这个记录就是来自 undolog 中。</p> 
<p>因此可以总结出 MVCC 实现的原理大致是：</p> 
<p>InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。</p> 
<p>MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。通过 MVCC，保证了事务 ACID 中的 I（隔离性）特性。</p> 
<p></p> 
<h3 id="%E9%94%81" style="text-align:center;"><span style="color:#a2e043;">锁</span></h3> 
<h3 id="1.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0%E9%94%81%3F"><strong>1. 为什么要加锁?</strong></h3> 
<p>当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。</p> 
<p>保证多用户环境下保证数据库完整性和一致性。</p> 
<h3 id="2.%20%E6%8C%89%E7%85%A7%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%86%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><strong>2. 按照锁的粒度分数据库锁有哪些？</strong></h3> 
<p>在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p> 
<p>行级锁</p> 
<ul><li> <p>行级锁是MySQL中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p> </li><li> <p>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p> </li></ul> 
<p>表级锁</p> 
<ul><li> <p>表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p> </li><li> <p>开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p> </li></ul> 
<p>页级锁</p> 
<ul><li> <p>页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁</p> </li><li> <p>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p> </li></ul> 
<p>MyISAM和InnoDB存储引擎使用的锁：</p> 
<ul><li> <p>MyISAM采用表级锁(table-level locking)。</p> </li><li> <p>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</p> </li></ul> 
<h3 id="3.%20%E4%BB%8E%E9%94%81%E7%9A%84%E7%B1%BB%E5%88%AB%E4%B8%8A%E5%88%86MySQL%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81%E5%91%A2%EF%BC%9F"><strong>3. 从锁的类别上分MySQL都有哪些锁呢？</strong></h3> 
<p>从锁的类别上来讲，有共享锁和排他锁。</p> 
<ul><li> <p>共享锁: 又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p> </li><li> <p>排他锁: 又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p> </li></ul> 
<p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p> 
<p>锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。</p> 
<p>他们的加锁开销从大到小，并发能力也是从大到小。</p> 
<h3 id="4.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><strong>4. 数据库的乐观锁和悲观锁是什么？怎么实现的？</strong></h3> 
<p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p> 
<ul><li> <p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p> </li><li> <p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p> </li></ul> 
<p>两种锁的使用场景</p> 
<p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p> 
<p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p> 
<h3 id="5.%20InnoDB%E5%BC%95%E6%93%8E%E7%9A%84%E8%A1%8C%E9%94%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><strong>5. InnoDB引擎的行锁是怎么实现的？</strong></h3> 
<p>InnoDB是基于索引来完成行锁</p> 
<p>例: select * from tab_with_index where id = 1 for update;</p> 
<p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起</p> 
<h3 id="6.%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><strong>6. 什么是死锁？怎么解决？</strong></h3> 
<p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p> 
<p>常见的解决死锁的方法</p> 
<p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p> 
<p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p> 
<p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p> 
<p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p> 
<h3 id="7.%20%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB"><strong>7. 隔离级别与锁的关系</strong></h3> 
<p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p> 
<p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p> 
<p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p> 
<p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p> 
<h3 id="8.%20%E4%BC%98%E5%8C%96%E9%94%81%E6%96%B9%E9%9D%A2%E7%9A%84%E6%84%8F%E8%A7%81%EF%BC%9F"><strong>8. 优化锁方面的意见？</strong></h3> 
<ul><li> <p>使用较低的隔离级别</p> </li><li> <p>设计索引，尽量使用索引去访问数据，加锁更加精确，从而减少锁冲突</p> </li><li> <p>选择合理的事务大小，给记录显示加锁时，最好一次性请求足够级别的锁。列如，修改数据的话，最好申请排他锁，而不是先申请共享锁，修改时在申请排他锁，这样会导致死锁</p> </li><li> <p>不同的程序访问一组表的时候，应尽量约定一个相同的顺序访问各表，对于一个表而言，尽可能的固定顺序的获取表中的行。这样大大的减少死锁的机会。</p> </li><li> <p>尽量使用相等条件访问数据，这样可以避免间隙锁对并发插入的影响</p> </li><li> <p>不要申请超过实际需要的锁级别</p> </li><li> <p>数据查询的时候不是必要，不要使用加锁。MySQL的MVCC可以实现事务中的查询不用加锁，优化事务性能：MVCC只在committed read（读提交）和 repeatable read （可重复读）两种隔离级别</p> </li><li> <p>对于特定的事务，可以使用表锁来提高处理速度活着减少死锁的可能。</p> </li></ul> 
<h3 id="Mysql%E4%BC%98%E5%8C%96" style="text-align:center;"><span style="color:#a2e043;">Mysql优化</span></h3> 
<h3 id="1.%20%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%8F%8A%E4%BC%98%E5%8C%96SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%EF%BC%9F"><strong>1. 如何定位及优化SQL语句的性能问题？</strong></h3> 
<p>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，对于查询语句，最重要的优化方式就是使用索引。</p> 
<p>而执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。</p> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/16/19/R08mmR8M_o.png"></p> 
<h3 id="2.%20%E5%A4%A7%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96"><strong>2. 大表数据查询，怎么优化</strong></h3> 
<ul><li> <p>优化shema、sql语句+索引；</p> </li><li> <p>第二加缓存，memcached, redis；</p> </li><li> <p>主从复制，读写分离；</p> </li><li> <p>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</p> </li><li> <p>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</p> </li></ul> 
<h3 id="3.%20%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%3F"><strong>3. 超大分页怎么处理?</strong></h3> 
<p>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于<code>select * from table where age &gt; 20 limit 1000000</code>,10 这种查询其实也是有可以优化的余地的. 这条语句需要 load1000000 数据然后基本上全部丢弃,只取 10 条当然比较慢. 当时我们可以修改为<code>select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</code>.这样虽然也 load 了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快。</p> 
<p>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.</p> 
<p>在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.</p> 
<blockquote> 
 <p>【推荐】利用延迟关联或者子查询优化超多分页场景。</p> 
 <p>说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。</p> 
 <p>正例：先快速定位需要获取的id段，然后再关联：</p> 
 <p>SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</p> 
</blockquote> 
<h3 id="4.%20%E7%BB%9F%E8%AE%A1%E8%BF%87%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F%E5%AF%B9%E6%85%A2%E6%9F%A5%E8%AF%A2%E9%83%BD%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E8%BF%87%EF%BC%9F"><strong>4. 统计过慢查询吗？对慢查询都怎么优化过？</strong></h3> 
<p>在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</p> 
<p>慢查询的优化首先要搞明白慢的原因是什么？是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？</p> 
<p>所以优化也是针对这三个方向来的，</p> 
<ul><li> <p>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</p> </li><li> <p>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</p> </li><li> <p>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</p> </li></ul> 
<h3 id="5.%20%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><strong>5. 如何优化查询过程中的数据访问</strong></h3> 
<ul><li> <p>访问数据太多导致查询性能下降</p> </li><li> <p>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</p> </li><li> <p>确认MySQL服务器是否在分析大量不必要的数据行</p> </li><li> <p>查询不需要的数据。解决办法：使用limit解决</p> </li><li> <p>多表关联返回全部列。解决办法：指定列名</p> </li><li> <p>总是返回全部列。解决办法：避免使用SELECT *</p> </li><li> <p>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</p> </li><li> <p>是否在扫描额外的记录。解决办法：使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</p> </li><li> <p>改变数据库和表的结构，修改数据表范式</p> </li><li> <p>重写SQL语句，让优化器可以以更优的方式执行查询。</p> </li></ul> 
<h3 id="6.%20%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2"><strong>6. 如何优化关联查询</strong></h3> 
<ul><li> <p>确定ON或者USING子句中是否有索引。</p> </li><li> <p>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</p> </li></ul> 
<h3 id="7.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96"><strong>7. 数据库结构优化</strong></h3> 
<p>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</p> 
<p>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p> 
<ol><li> <p>将字段很多的表分解成多个表</p> </li></ol> 
<p>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</p> 
<p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p> 
<ol><li> <p>增加中间表</p> </li></ol> 
<p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p> 
<p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p> 
<ol><li> <p>增加冗余字段</p> </li></ol> 
<p>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</p> 
<p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p> 
<p>注意：</p> 
<p>冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</p> 
<h3 id="8.%20MySQL%E6%95%B0%E6%8D%AE%E5%BA%93cpu%E9%A3%99%E5%8D%87%E5%88%B0500%25%E7%9A%84%E8%AF%9D%E4%BB%96%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><strong>8. MySQL数据库cpu飙升到500%的话他怎么处理？</strong></h3> 
<p>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 MySQLd 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</p> 
<p>如果是 MySQLd 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</p> 
<p>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</p> 
<p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。</p> 
<h3 id="9.%20%E5%A4%A7%E8%A1%A8%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><strong>9. 大表怎么优化？</strong></h3> 
<p>类似的问题：某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</p> 
<p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p> 
<ul><li> <p>限定数据的范围：务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p> </li><li> <p>读/写分离：经典的数据库拆分方案，主库负责写，从库负责读；</p> </li><li> <p>缓存：使用MySQL的缓存，另外对重量级、更新少的数据可以考虑；</p> </li><li> <p>通过分库分表的方式进行优化，主要有垂直分表和水平分表。</p> </li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/410a28508880a23568e5ed3b1554c343/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PCL-OpenCV冲突的解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2a6fae13afeead108bf0c2499cb3ebe6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">windows10安装python依赖，报错can‘t create or remove files in install directory</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>