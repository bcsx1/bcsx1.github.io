<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ecc2d431ef87cb92ae64297462c02a4/" rel="bookmark">
			手机通讯录好备份，那微信通讯录怎么备份出来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6-8
众所周知的是，手机通讯录是很好备份的，但是微信不行，手机本身就带有备份功能，换手机可以快速地迁移通讯录，比如下面这个就是小米手机自带的备份功能，简单好用
但是现在生意可都在微信上做了，微信又有封号、交接工作的可能，微信上的通讯录怎么导出来，就是个大问题，因为微信本身就不提供这种功能。
本文就是解决这个问题的，可以快速的帮你把微信的通讯录导出来，让你可以方便地在另一个微信上加人，如果微信你要交回给公司，或者担心微信封号，可以用这个方法备份数据。
以下是详细的备份方法 1，这里要使用的方法主要是解析微信保存在本地的数据文件，从数据文件里把通讯录导出来，所以首先要找到微信保存数据的地方，电脑上登录微信后，点击微信窗口左下角【菜单】-【设置】
2，会打开微信的设置窗口，在设置窗口中点【文件管理】-【打开文件夹】
3，经过上面这一步，就打开了微信的数据文件夹了，你的通讯录就保存在这里，但是人是看不到它的，需要软件解析才行，文件夹如下图所示
4，然后复制这个文件夹的路径下来，下面会用到这个路径的
5，经过上面这一步后，就拿到了微信的数据文件夹了，下面使用软件把通讯录导出来，首先获取《微信通讯录抽水机》软件，解压后可以放在桌面上，然后双击软件图标，打开软件
该工具可以在以下参考资料中获取：
【微信通讯录抽水机】软件，一键导出/备份微信通讯录的小工具，搞私域、搞网销客户交接的小帮手-软件资源-天才小网管
6，软件打开后的界面是下面这样的
7，需要写两个文件夹路径，第一个格子【微信个人数据文件夹】粘贴上面复制的路径进去，第二个格子【导出保存到的文件夹】选择一个你导出后保存的地方，我一般选桌面，最终填写如下
8，然后直接点【一键导出所有联系人】，稍等片刻，搞定
9，导出完成后，软件会在你选择的文件夹里保存导出后的文件，并且会帮你自动打开表格文件，可以看到导出的效果
10，这个软件还包含一些其它的功能，举例如下，其它的自行探索即可
10.1 可以导出头像 10.2 可以导出备注的手机号 10.3 可以导出备注的文字 10.4 可以导出联系人的个性签名 11，到这里就已经导出了微信的所有通讯录联系人，操作还是非常简单的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17c2befa70edaba76508ecf102a1d626/" rel="bookmark">
			博弈论学习笔记（3）——完全信息动态博弈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在这个部分，我们学习的是完全信息动态博弈。主要内容包括扩展式博弈、子博弈精炼Nash均衡、重复博弈和子博弈精炼Nash均衡的应用。
一、扩展式博弈 1、扩展式博弈 1）扩展式博弈是什么 扩展式博弈是博弈问题的一种规范性描述，扩展式博弈注重对参与人在博弈过程中所遇到决策问题的序列结构的详细分析。
2）扩展式博弈包含的要素 3）博弈树是什么 博弈树是扩展式博弈中简单直观的一种描述方式。其由结和有向枝构成。
4）信息集是什么 对于信息集的描述，注意区分以下三种情况：
5）完美记忆是什么 2、扩展式博弈的战略及其Nash均衡 1）扩展式博弈中的战略 参与人的战略就是参与人在博弈中的行动规则，它规定了参与人在博弈中每一种轮到自己行动的情形下，应该采取的行动。而在博弈树中，参与人在博弈中每一种轮到自己行动的情形又可以用一个信息集来表示，因此，参与人在扩展式博弈中的战略实际上就是参与人在每个信息集上的行动规则。
2）由扩展式描述得到战略式描述 3、战略式博弈 VS 扩展式博弈 1）战略式博弈本质上是静态模型 战略式假设所有的参与人同时选择战略并得到博弈的结果，至于博弈中参与人何时行动、行动时又如何行动等等，战略式博弈并不考虑。
2）扩张式博弈本质上是动态模型 扩展式博弈不仅直观地给出了博弈的结果，而且还对博弈的过程进行详尽的描述。
可以给出博弈中参与人的行动顺序，以及参与人行动时的决策环境和行动空间。
3）两种博弈描述形式的比较 给出博弈问题的扩展式描述(如博弈树)，我们就可得到博弈问题的战略式描述。
给出博弈问题的战略式描述，我们也能构造出博弈问题的扩展式描述。
二、子博弈精炼Nash均衡 1、子博弈精炼Nash均衡 1）将Nash均衡作为扩展式博弈的解会有什么问题 Nash均衡是一个静态均衡，将Nash均衡作为扩展式博弈的解同样会遇到Nash均衡的多重性问题，而且在多个Nash均衡中有些明显不合理。
2）子博弈的概念 子博弈就是原博弈的一部分，它始于原博弈中一个位于单结信息集中的决策结 X ，并由决策结 X 及其后续结共同组成。
子博弈可以作为一个独立的博弈进行分析，并且与原博弈具有相同的信息结构。
3）子博弈精炼Nash均衡的定义 4）Kuhn定理 每个有限的扩展式博弈都存在子博弈精炼Nash均衡。
虽然Kuhn定理保证了子博弈精炼Nash均衡的存在性，但Kuhn定理并不能确保我们所讨论的有限的扩展式博弈都只存在惟一的子博弈精炼Nash均衡。
5）解的多重性问题 2、子博弈精炼Nash均衡的求解 1）求解有限扩展式博弈的一般步骤 找出博弈的所有子博弈；
按照博弈进程的“反方向”逐一求解各个子博弈，即最先求解最底层的子博弈，再求解上一层的子博弈，......，直至原博弈。也就是说，在求解每一个子博弈时，该子博弈要么不含有其它任何子博弈，要么所含子博弈都已被求解。
2）逆向归纳法 3）完美信息与完全信息 4)子博弈精炼Nash均衡 VS Nash均衡 3、承诺行动与要挟诉讼 1）承诺行动 承诺行动就是在博弈开始之前参与人采取的某种改变自己支付或行动空间的行动，该行动可使原本不可信的威胁变得可信。
在许多情况下，承诺行动对参与人来讲是有利的，因为它能使博弈的精炼均衡发生有利于自己的改变。
需要注意的是，参与人的承诺行动是有成本的（沉没成本），否则这种承诺就不可信。
2）要挟诉讼 所谓要挟诉讼是指那种原告几乎不可能胜诉而其惟一的目的可能是希望通过私了得到一笔赔偿的诉讼。
博弈的结果似乎与人们观测到的现实并不相符，因为现实中人们常常看到各种“要挟”的发生。在上述模型中，“要挟”之所以没有成果，关键在于原告将会起诉的威胁并不可信。
原告需要采取承诺行动，来使自己的威胁变得可信。
具体的扩展式博弈过程详见PPT。
4、子博弈精炼Nash均衡的合理性讨论 1）与人们直觉的差异 2）逆向归纳法对理性的要求 如同前面所定义的博弈的解一样，子博弈精炼Nash均衡不仅要求“参与人完全理性”，而且要求“参与人完全理性”为共同知识，否则就无法使用逆向归纳法求解子博弈精炼Nash均衡。
三、重复博弈 1、有限重复博弈 1）重复博弈的例子 多阶段的动态博弈，在博弈的每个阶段，重复同样的博弈。重复博弈关心的是将来可信的威胁或承诺如何影响到当前的行动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17c2befa70edaba76508ecf102a1d626/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dce53a8ccf45f0db322155cd8cd3d1fe/" rel="bookmark">
			华为OD机试 - 需要打开多少监控器（Java &amp; JS &amp; Python &amp; C）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 某长方形停车场，每个车位上方都有对应监控器，当且仅当在当前车位或者前后左右四个方向任意一个车位范围停车时，监控器才需要打开；
给出某一时刻停车场的停车分布，请统计最少需要打开多少个监控器；
输入描述 第一行输入m，n表示长宽，满足1 &lt; m,n &lt;= 20；
后面输入m行，每行有n个0或1的整数，整数间使用一个空格隔开，表示该行已停车情况，其中0表示空位，1表示已停；
输出描述 最少需要打开监控器的数量；
用例 输入3 3
0 0 0
0 1 0
0 0 0输出5说明无 题目解析 本题题意比较难以理解，但是画一幅图给大家看下就懂了
停车（1）的位置必须要打开监控器，另外停车位置的上下左右位置（1或0）的监控器也要打开，问最终需要打开多少个监控器？
即，求解上面图示种有颜色的格子数量。
解题思路如下：
遍历矩阵每一个元素，
如果元素值为1，对应位置的监控器就要打开。如果元素值为0，则需要进一步检查其上下左右四个位置，只要这四个位置有一个元素值为1，则当前位置的监控器需要打开 JavaScript算法源码 const rl = require("readline").createInterface({ input: process.stdin }); var iter = rl[Symbol.asyncIterator](); const readline = async () =&gt; (await iter.next()).value; void (async function () { const [m, n] = (await readline()).split(" ").map(Number); const matrix = []; for (let i = 0; i &lt; m; i++) { matrix.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dce53a8ccf45f0db322155cd8cd3d1fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d2ccac7ff219472d5ff8c00cb78686/" rel="bookmark">
			CSDN中Markdown调整图片大小和位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN中Markdown调整图片大小和位置 调整大小 当上传完图片，看到如下的连接
在![在这里插入图片描述](https://img-blog.csdnimg.cn/b6991f46058a4d9d937b0c0588fa8732.png)的png后面加 =300x300（注意等号前面有空格）就可以调整大小，当然具体调整多大你自己可以调整数字尺寸。
只改动宽度: =300x
只改动高度: =x300
调整位置 在![在这里插入图片描述](https://img-blog.csdnimg.cn/b6991f46058a4d9d937b0c0588fa8732.png)的png后加，#pic_center（#号前没空格，直接跟在png后面），一定在尺寸前加。
居中对齐：#pic_center
左对齐：#pic_left
右对齐：#pic_right
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c683d5bcf861c9a5522c0480203be33/" rel="bookmark">
			stm32CubeMX，配合Keil，使用HAL库（或标准库）方式进行串口通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 今天我们学习STM32CubeMX串口的操作，以及HAL库串口的配置，我们会详细的讲解各个模块的使用和具体功能，并且基于HAL库实现Printf函数功能重定向，USART中断接收，本系列教程将HAL库与STM32CubeMX结合在一起讲解，使您可以更快速的学会各个模块的使用
文章目录 引言前言一、串口通信介绍1. 串口通信2. 串口通信的分类：2.1 串行通信2.2 并行通信 3. 串行通信4.STM32的串口通信接口5.数据传输的格式/通信协议6.USART的使用步骤 二、准备工具三、通过STM32CubeMX配置项目四、HAL库USART函数库介绍1.串口发送/接收函数1.1.串口发送数据函数1.2.中断接收数据函数 2.串口中断函数2.1 串口接收中断回调函数2.2 串口中断处理函数 3.串口查询函数4.重定义printf函数（以串口UART1为例） 五、在keil5配置代码1.打开通过CubeMX创建的项目2.测试重定向的printf函数3.测试串口中断(发送"*"打印，发送"#"停止)3.1 要求：3.2 思路：3.3 运行效果3.4使用Keil的软件仿真逻辑分析仪功能观察串口输出波形 总结参考 前言 例如：随着人工智能的不断发展，机器学习这门技术也越来越重要，很多人都开启了学习机器学习，本文就介绍了机器学习的基础内容。
一、串口通信介绍 1. 串口通信 串口通信是指外设和计算机间，通过数据信号线 、地线、控制线等，按位进行传输数据的一种通讯方式，如SPI通信、USART通信、EEPROM通信等。简单讲，串口通信实现了上位机（PC）与下位机（如STM32）之间的信息交互。
上位机（PC）通过串口调试助手等实现数据的接收和发送；
下位机（STM32）通过printf()、getchar()等函数实现字符或字符串的接收和发送。
2. 串口通信的分类： 处理器与外部设备通信有两种方式：
2.1 串行通信 数据按位顺序依次传输，如8个数据位依次传输，速度慢，但占用引脚资源少。
​ 按照数据传送方向，又分为：
单工：数据传输只支持数据在一个方向上传输。（只收不发或者只发不收，模式固定）
单双工：允许数据在两个方向上传输，但是在某一时刻，只允许数据在一个方向上传输。（能发能收，但不能同时进行）
全双工：允许数据同时在两个方向上传输。（能发能收，且能同时进行）
2.2 并行通信 数据各个位同时传输，如8个数据位同时传输，占用引脚资源慢，但速度快。
3. 串行通信 串行通信按通信的方式可分为：
同步通信：带时钟同步信号传输，如SPI、IIC通信等
异步通信：不带时钟同步信号，如UART(通用异步收发器)、单总线等。
4.STM32的串口通信接口 UART：通用异步收发器
USART：通用同步/异步收发器（两种模式可切换）
STM32F103系列提供5路串口，包含3个 USART 和2个 UART 。
串口的引脚如下图所示：
5.数据传输的格式/通信协议 串行通信一定要有适合的通信协议。
通信协议指通信双方之间为完成信息交互所必须遵守的一种规则和约定。比如两个人约定在何时交流、用中文还是英文交流、交流什么内容。
1.起始位
​ 当未有数据发送时，数据线处于逻辑“1”状态；先发出一个逻辑“0”信号，表示开始传输字符。
2.数据位
​ 紧随起始位之后，数据位表示真正要发送或接收的信息，位数一般有8位或9位
3.奇偶校验位
​ 数据位末尾可以选择是否添加奇偶校验位，用于检测数据传输是否正确
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c683d5bcf861c9a5522c0480203be33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60985793ce254eee7eaeb1c9a2b6620e/" rel="bookmark">
			Python三维模型处理基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本专栏（地址：”https://blog.csdn.net/suiyingy/category_12462636.html“）将介绍Python在三维模型处理基础方面的应用，包括探索三角面片、三维模型体积计算、面积计算、视角投影、动画制作、表面重建、异常点检测与优化、模型贴图、基于Django与Three.js的三维模型Web可视化以及OBJ模型合并等内容。通过详细的介绍和代码示例，读者可以了解如何使用Python进行三维模型处理以及相关应用的实现方法。此外，还会对未来三维模型处理领域的发展进行展望。
python三维点云深度学习算法请前往专栏《Python三维点云实战宝典》，专栏地址为“https://blog.csdn.net/suiyingy/category_11740467.html”。更多三维、二维感知算法和金融量化分析算法请关注“乐乐感知学堂”微信公众号，并将持续进行更新。
提纲：
1. 引言（已完成） Python三维模型处理基础-引言-CSDN博客
”https://blog.csdn.net/suiyingy/article/details/133670751“
- 背景介绍
- 三维模型处理的重要性与应用领域
2. 探索三角面片：实现现实场景的数字化（已完成） 详解三角面片：实现现实场景的数字化_Coding的叶子的博客-CSDN博客
“https://blog.csdn.net/suiyingy/article/details/133711034”
- 简述三角面片的概念与作用
- 探索数字化场景的方法与技术
- 介绍相关的Python库与工具
3. 三维模型体积计算（已完成） 三维模型体积计算及其注意事项_Coding的叶子的博客-CSDN博客
”https://blog.csdn.net/suiyingy/article/details/133785266“
- 三维模型体积计算的原理与方法
- 提供Python代码示例与实现步骤
4. 三维模型法向量计算（已完成） 三维模型法向量计算及注意事项-CSDN博客
”https://blog.csdn.net/suiyingy/article/details/133816356“
- 三维模型法向量计算的原理与方法
- 三维模型法向量可视化方法
- 提供Python代码示例与实现步骤
5. 三维模型面积计算（已完成） 三维模型表面积计算方法-CSDN博客
“https://blog.csdn.net/suiyingy/article/details/133971359”
- 解释三维模型面积计算的原理与应用场景
- 演示如何使用Python进行面积计算的步骤与代码示例
6. 三维模型视角投影（已完成） 三维模型相机视角投影详细介绍及python程序解析-CSDN博客
“https://blog.csdn.net/suiyingy/article/details/134043042”
- 介绍三维模型视角投影的基本概念与流程
- 提供Python库与工具来实现视角投影操作的方法
7. 使用simple_3dviz进行三维模型投影（已完成） 使用simple_3dviz进行三维模型投影-CSDN博客
"https://blog.csdn.net/suiyingy/article/details/134122733"
7. 三维模型动画制作 - 说明三维模型动画制作的基本原理与方法
- 介绍一些常用的Python工具与库来实现动画效果
8. 三维模型表面重建 - 解释表面重建的概念与目的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60985793ce254eee7eaeb1c9a2b6620e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77d44a9ac2cdaaec0c9460cd63f5193c/" rel="bookmark">
			模拟IIC通讯协议（stm32）（硬件iic后面在补）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、IIC基础知识总结。 1、IIC通讯需要两条线就可以，SCL、SDA。
2、IIC的数据传输的速率，不同的ic是不同的，根据电平维持的延时函数的时间来确定IIC数据传输的速率.
3、IIC的延时函数可以使用延时函数，延时函数一般使用系统滴答时钟产生延时，也是在Sysclk频率总线的基础上产生的延时。这个延时和“__NOP();”指令产生的延时是一样的，“__NOP();”也是依靠Sysclk频率产生延时。使用场景：“__NOP();”指令是一个汇编指令的运行产生延时，是占用cpu的，短时间且精确的延时是可以使用的；较长时间的精准的延时还是需要使用系统滴答时钟的定时器实现延时的。
4、标准的IIC传输节拍信号是由7种的：起始信号、停止信号、产生ACK应答信号、产生NACK应答信号、等待ACK应答信号、接收1byte字节信号、发送1byte字节信号。
5、在标准IIC信号中分为两种形式：边沿信号，上升沿或者下降沿（起始信号、停止信号）。电平信号，高电平或者低电平（产生ACK应答信号、产生NACK应答信号、等待ACK应答信号、接收1byte字节信号、发送1byte字节信号）。
6、上面的两类信号，也就是7种信号中，SDA的信号必须在SCL为高电平的时候有效。
7、在上面的7种基础信号的基础上，根据不同的芯片封装不同的数据发送和接收的函数，下面将简单介绍一般的数据发送和接收协议形式，大部分ic芯片都是相同的。
ic数据的发送：
（1）发送起始位。
（2）发送写控制字节，写控制字节的最后一位表示“写”，其他的位表示IC的id。
（3）等待IC的ACK回应。
（4）发送地址字节。
（5）等待IC的ACK回应。
（6）发送写入的数据字节。
（7）等待IC的ACK回应。
（8）如果单字节写入，只能写入一次，Pag页的写入，5，6可以进行多次。
（9）最后给IC发送停止位。
ic数据的接收：
（1）发送起始位。
（2）发送写控制字节，写控制字节的最后一位表示“写”，其他的位表示IC的id。
（3）等待IC的ACK回应。
（4）写入地址高字节（如果是16位地址数据）。
（5）等待IC的ACK回应。
（6）写入地址低字节
（7）等待IC的ACK回应。
（8）发送起始位。
（9）发送读控制字节，读控制字节的最后一位表示“读”，其他的位表示IC的id。
（10）等待IC的ACK回应。
（11）接收数据。
（12）数据没有接收完毕，继续接收，发送ACK回应信号。
（13）接收数据。
（14）数据接收完毕，发送NACK回应信号。
（15）发送停止位。
8、停止信号，最后保持SCL为高电平；其他信号，函数结束的最后一定要保持SCL为低电平。
二、IIC使用引脚的配置电平的配置。 1、SDA的GPIO输入 static void i2c_sda_in(void) { GPIO_InitTypeDef gpio_cfg; __HAL_RCC_GPIOB_CLK_ENABLE(); gpio_cfg.Pin = bus_i2c-&gt;sda_pin; gpio_cfg.Mode = GPIO_MODE_INPUT; // gpio_cfg.Pull = GPIO_PULLUP; HAL_GPIO_Init((GPIO_TypeDef*)bus_i2c-&gt;sda_port, &amp;gpio_cfg); } 2、SDA的GPIO输出 static void i2c_sda_out(void) { GPIO_InitTypeDef gpio_cfg; __HAL_RCC_GPIOB_CLK_ENABLE(); gpio_cfg.Pin = bus_i2c-&gt;sda_pin; gpio_cfg.Mode = GPIO_MODE_OUTPUT_OD; gpio_cfg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77d44a9ac2cdaaec0c9460cd63f5193c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c25bcdcdd6ef94c0b4c95ae684be87/" rel="bookmark">
			Android Studio学习02：App首页布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目标 1、做一个APP首页，包括顶部图片、顶部菜单栏、中部消息模块、底部Tab按钮。学习 ScrollView, RelativeLayout，以及插件之间的穿插使用。
源码链接：https://github.com/junqiduhang/TEST
二、实验步骤 1.页面内容 页面上可以分为四个部分：顶部图片模块、顶部菜单模块、待办消息模块和底部Tab按钮
2.页面设计 为能够比较明显的显示各控件的相对位置，设置最外层父布局背景色为灰色，内层控件背景颜色均为白色
2.1整体父布局 ①新建ScrollView，指定长宽
**ScrollView使用场景：**如果一个页面内容很多，需要往下（或者左右）滑动才能显示全内容，可以使用滚动视图ScrollView。
②新建ScrollView 内部父布局LinearLayout，设置长宽，垂直方向为竖直
顶部图片、顶部菜单和代办消息模块都放到内部父布局。在应用场景中，不同于底部tab栏，这三者是属于同一个整体的，需要随着视图滚动而上下移动，而底部tab栏不随视图滚动而上下移动
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:background="#F5F5F5"&gt; &lt;ScrollView android:layout_width="match_parent" android:layout_height="700dp"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt; &lt;/LinearLayout&gt; 效果
2.2创建顶部首页显示栏 创建TextView控件：设置宽高、设置文字“首页”、设置字体样式、设置字体颜色字体、文字居中
&lt;TextView android:layout_width="match_parent" android:layout_height="50dp" android:gravity="center" android:text="首页" android:textColor="#333" android:textSize="18dp" android:textStyle="bold" /&gt; 效果
2.3创建顶部图片 将素材包的图片移到app/res/mipmap下
创建ImageView控件：设置长宽，增大与左右边界的距离，设置图片路径@mipmap/图片名
&lt;ImageView android:background="#FFFFFF" android:layout_width="match_parent" android:layout_height="200dp" android:layout_marginLeft="10dp" android:layout_marginRight="10dp" android:src="@mipmap/test_img" /&gt; 效果
2.4菜单栏模块 导入图片素材，这里以创建一个菜单选项为例，剩余菜单选项复制此菜单选项控件，修改图标和标签即可
首先创建LinearLayout父布局，设置长宽，垂直方向设置为横向，设置背景色为白色，将整个控件分为四部分weightSum=“4”
&lt;LinearLayout android:background="#FFFFFF" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="10dp" android:layout_marginRight="10dp" android:orientation="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95c25bcdcdd6ef94c0b4c95ae684be87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6a3e063068f1d0a2050c4d3851cca60/" rel="bookmark">
			Hadoop3.x集群搭建by虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：通过本篇博客，你可以搭建起一个具有3个虚拟机结点：node1、node2和node3的hadoop集群，当然包括yarn的配置，这并不复杂，实测可用。在此基础上，可以搭建hive以及impala，不需要为兼容性担心。不过本篇博客不涉及hive和impala。
希望本篇文章对您有用！
相关软件链接：https://pan.baidu.com/s/1y_dCAACBdbSEPztiQrLHVA?pwd=h00i
提取码：h00i
一、材料准备 1、操作系统：CentOs7
版本如下
CentOS-7-x86_64-DVD-1810.iso tip：建议版本保持一致
镜像站：archive.kernel.org
2、Hadoop
hadoop-3.3.4.tar.gz tip：建议版本保持一致，如果有搭建hive需求，建议使用此版本
3、虚拟机环境：VMware® Workstation 17 Pro
4、XShell和Xftp（可选）
（1）XShell用于远程连接
（2）Xftp用于win和linux文件传输
当然也可以使用win下cmd的ssh和scp实现上述需求
网址：家庭/学校免费 - NetSarang Website (xshell.com)
5、JDK
jdk-8u361-linux-x64.tar.gz tip：建议使用此版本
二、基本环境 1、安装虚拟机 step1：使用VM自带的自动安装即可
初始用户建议命名为hadoop
安装完成后进入桌面如图所示⬇⬇⬇
step2：根据step1中安装的虚拟机完全克隆三台虚拟机，名称分别为node1，node2和node3
建议调整node1配置为：2核4线程；4GB内存；20G硬盘
node2和node3配置为：1核2线程；2GB内存；20G硬盘
2、虚拟机基本环境配置 在安装hadoop之前，需要做ip映射、ssh免密登录等操作
切换为root
su root （1）修改主机名
三台主机分别执行
hostnamectl set-hostname node1 hostnamectl set-hostname node2 hostnamectl set-hostname node3 （2）静态IP
需要修改或添加：BOOTPROTO、IPADDR、NETMASK、DNS1、GATEWAY。有的教程只让修改前两项可能导致无法联网😥😥，当然不妨碍安装hadoop。
图示为node1修改后内容
vim /etc/sysconfig/network-scripts/ifcfg-ens33 node2：192.168.88.101
node3：192.168.88.102
重启网卡
三台主机都要做
systemctl restart network （3）配置主机名映射
在linux中
三台主机都要做，这样以后需要输入IP的地方，可以直接用如node1替代
vim /etc/hosts 添加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6a3e063068f1d0a2050c4d3851cca60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aec2d44ffc256158416eee17f1a05452/" rel="bookmark">
			Hive3.1.3配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：本文主要讲解hive的远程安装方式，承接该文章。本文章主要包括安装mysql（用于存放hive元数据）和安装hive。
希望能够对您有用！
一、准备 相关软件链接：https://pan.baidu.com/s/1y_dCAACBdbSEPztiQrLHVA?pwd=h00i
1、已配置完hadoop环境
指hadoop，yarn能够正常启动和关闭
建议：hadoop-3.3.4.tar.gz
jdk：jdk-8u361-linux-x64.tar.gz
可参考：https://blog.csdn.net/junqiduhang/article/details/134125116
2、下载hive安装包并上传到hadoop名称节点
需要注意的是hadoop3.x才能使用hive3.x，否则启动hive会报错。
https://dlcdn.apache.org/hive/ 二、安装MySQL 1、卸载Centos7自带mariadb rpm -qa|grep mariadb # mariadb-libs-5.5.60-1.el7_5.x86_64 rpm -e mariadb-libs-5.5.60-1.el7_5.x86_64 --nodeps 2、创建mysql安装包存放点 mkdir -p /export/software/mysql 上传mysql-5.7.29安装包到上述文件夹下、解压
tar xvf mysql-5.7.29-1.el7.x86_64.rpm-bundle.tar 3、执行安装 yum -y install libaio rpm -ivh mysql-community-common-5.7.29-1.el7.x86_64.rpm mysql-community-libs-5.7.29-1.el7.x86_64.rpm mysql-community-client-5.7.29-1.el7.x86_64.rpm mysql-community-server-5.7.29-1.el7.x86_64.rpm 4、初始化mysql mysqld --initialize 更改所属组
chown mysql:mysql /var/lib/mysql -R 5、启动mysql systemctl start mysqld.service 查看生成的临时root密码
cat /var/log/mysqld.log # 3DgiqJPekr&gt;i 额，注意前面有个空格不要 这行日志的最后就是随机生成的临时密码
[Note] A temporary password is generated for root@localhost: 3DgiqJPekr&gt;i 修改mysql root密码、授权远程访问
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aec2d44ffc256158416eee17f1a05452/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8b2a336a895448f3a057785c97e3629/" rel="bookmark">
			Java基于SpringBoot的线上考试系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 摘 要 基于 SpringBoot 的在线考试系统网站，功能模块具有课程管理、成绩管理、教师管理、学生管理、考试管理以及基本信息的管理等，通过将系统分为管理员、授课教师以及学生，从不同的身份角度来对用户提供便利，将科技与教学模式结合所带来的优势更加普遍化，不断得到发展。
在线考试系统网站的使用是更为便捷的，互联网的普及在这个社会是非常成功的，小到个人的交际交流，大到公司企业员工的交流，都已经离不开科技，所以，在这么成熟的平台上，各种类型的网站也就应运而生，基于无法直接满足无纸化系统的用户需求，加上SpringBoot的成熟技术，基于SpringBoot的在线考试系统网站也就自然而然的在这个时代产生。并且为用户解决了很大的困扰，也为国家减轻了人力和物力。
原文地址:https://it1314.top/article/1058/
2 技术路线 使用框架：springboot
开发语言：Java、
框架：springboot，
JDK版本：JDK1.8 ，
服务器：tomcat7或者8 ，
数据库：mysql 5.7，
数据库工具：Navicat11，
开发软件：eclipse/myeclipse/idea，
浏览器：谷歌浏览器，
3 功能模块需求分析 本网站最大的特点就功能全面，且结构简单，具有时代特征，为了能够解决社会中被人们所忽略的情况，以及适应于在时代的不断发展下的对教育教学模式有新需求的人们，在线考试系统网站将实现以下基本功能。
4 具体分析 前台 学生登录：
如果没有账号，首先需要以学生的身份进行注册，即输入姓名、性别、密码以及班级，注册成功之后输入账户名和密码进行登录，进入考试系统。
首页：
在首页信息框中，将展示该学生用户的姓名以及所有完成的试卷信息，在下方展示试卷的类型，以及对该试卷的一个整体评价。在右上方，设置了考试模块与记录模块。
记录模块：
在记录模块中，学生用户在完成试卷之后进行提交将立即得到该试卷的成绩结果，并且所有完成的试卷信息将保存在记录模块中，便于后期的管理，以及对自身的学习水平有一个很好的认识。该结果将展示准确率以及得分情况，并且点击详情按钮，可以查看没得选项的正确答案的解析，使学生用户得到自我检查，提高水平。
考试模块：
在考试模块中，学生用户点击考试按钮，将出现授课教师发布的需要及时完成的试卷，点击下方的开始按钮，即可进入考试系统，在考试系统左边，显示考试开始时间以及结束时间，在学生完成所有题目之后点击提交，即可查看最终的得分，结果将以正确率以及具体得分数值显示。这大大的为试卷批改的工作人员带来了便利，同时方便方便了整体的管理操作。
后台： 管理员登录：
首先以管理员的身份输入账户名和密码进行登录。
首页：
在首页信息框中，将展示所有登录该在线考试系统用户数量、所完成的试题的总数量以及共录入的试卷的总套数。同时在下方，设置了公告信息栏模块，将在线考试系统的实时信息及时的通知所有用户。并且为了给所有的学生用户给予荣誉以及竞争性，设置了榜单模块功能，基于高分高准确率，对所有学生的做题情况以此标准进行排名，该模块将降序展示学生的排名、姓名、考试类型、总得分以及以1为满点给出点。
学生管理：
在学生管理中，可实现批量录入学生信息，查看学生信息功能。用户填写完个人信息，即姓名、账号、性别、邮箱、密码以及所在班级，管理员可以查看每个用户的具体信息状态，并且可对其信息进行重新编辑以及删除操作，可点击编辑信息按钮，填入相应的信息即可修改一条用户信息，然后点击确认即可完成，并且还有选择显示密码。
教师管理：
在教师管理功能中，可实现查询教师信息、查询教师所带课程。在该列表中可查看教师用户的所有信息，包括姓名、账号、邮箱、密码，更重要的是，将该用户的所具有的权限设置了类型划分，即作为管理员与普通，对于不同身份所赋予的权限功能不同。当发现需要修改的信息时，管理员可以对用户的信息进行编辑或者删除操作。
班级管理：
在班级管理中，主要以教师用户作为班级划分的对象，在整个列表中，将显示班级名，即专业名称，班主任姓名，通过该列表可以有效且方便的查询每个老师所在的班级，这样可对该课程信息进行更好的管理。同时，管理员也可以进行编辑和删除功能，点击班级添加按钮就可以对其进行添加。
试题管理：
在试题管理模块中，可实现添加考试信息、考试信息存档功能。在该信息列表中，将展示试题的所有题型，试题的知识类型，具体的题目以及所有参考选项的具体内容，并在后一栏给出正确的参考答案，同时，这也给予了管理员的编辑与删除的功能。在列表信息的上方，设置了试题添加模块，以及可根据试题知识类型的名称进行筛选查看，为后续的编辑与删除的管理操作给予了很大的便利。
试卷管理：
在试卷管理中，主要以试卷作为划分的对象，在整个列表中，会展示所有题型的得分情况。包含单选题、多项题以及判断题得分情况。同时，管理员也可以对该课程信息进行编辑和删除操作，在上方点击班级添加按钮可以对其进行添加功能并且可以进一步对试题进行管理，即对所有的试题可通过人工或者随机组成一套试卷，可通过输入试题科目类型以及试题的数量进行试卷生成。
考试管理：
在考试管理中，以管理员的身份可以增加考试信息，点击添加按钮，会以模态框的形式展示给用户输入的表单数据，用户输入相应的数据，即试题类型、开始考试时间以及结束时间，便可以添加成功。同时，也可根据试卷的完成情况显示目前的试卷状态，管理员由权对其进行删除操作。
记录管理：
在记录模块中，学生用户在完成试卷之后进行提交将立即得到该试卷的成绩结果，并且所有完成的试卷信息将保存在记录模块中，便于后期的管理，以及对自身的学习水平有一个很好的认识。该结果将展示准确率以及得分情况，管理员可以对其数据信息进行删除以及添加操作。
5 功能实现 5.1 系统实现概述 在将项目拉取下来之前，往往都是先要把环境部署好的，不然辛辛苦苦将项目的配置项配置好，发现是因为环境问题而无法运行起来了。响应式的网站系统的开发是采用前后端分离的模式，需要完成项目的需求分析、系统设计、测试、部署等开发过程，故该系统选择java面向对象开发语言、前端使用html+css和JavaScript开发模式、数据库采用MySQL技术，采用SpringBoot框架、微服务分布式开发，以及前端的vue框架。在以前的模式是需要配置集成环境，但现在由于技术的更新换代，已经不需要这么复杂的操作了。
5.2 功能实现 5.2.1 后台 5.2.1.1后台登录 首先以管理员的身份输入账户名和密码进行登录。如下图所示：
5.2.1.2首页 在首页信息框中，将展示所有登录该在线考试系统用户数量、所完成的试题的总数量以及共录入的试卷的总套数。同时在下方，设置了公告信息栏模块，将在线考试系统的实时信息及时的通知所有用户。并且为了给所有的学生用户给予荣誉以及竞争性，设置了榜单模块功能，基于高分高准确率，对所有学生的做题情况以此标准进行排名，该模块将降序展示学生的排名、姓名、考试类型、总得分以及以1为满点给出点。
5.2.1.3学生管理 在学生管理中，可实现批量录入学生信息，查看学生信息功能。用户填写完个人信息，即姓名、账号、性别、邮箱、密码以及所在班级，管理员可以查看每个用户的具体信息状态，并且可对其信息进行重新编辑以及删除操作，可点击编辑信息按钮，填入相应的信息即可修改一条用户信息，然后点击确认即可完成，并且还有选择显示密码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8b2a336a895448f3a057785c97e3629/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42581ad5ae4a2a116dfa326f77d02f61/" rel="bookmark">
			Vue3父子传参props和$emit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. props 父传子，用 props 传数据给子组件有两种方法，如下
方法一，混合写法
// Parent.vue 传送 &lt;child :msg1="msg1" :msg2="msg2"&gt;&lt;/child&gt; &lt;script&gt; import child from "./child.vue" import { ref, reactive } from "vue" export default { data(){ return { msg1:"这是传级子组件的信息1" } }, setup(){ // 创建一个响应式数据 // 写法一 适用于基础类型 ref 还有其他用处，下面章节有介绍 const msg2 = ref("这是传级子组件的信息2") // 写法二 适用于复杂类型，如数组、对象 const msg2 = reactive(["这是传级子组件的信息2"]) return { msg2 } } } &lt;/script&gt; // Child.vue 接收 &lt;script&gt; export default { props: ["msg1", "msg2"],// 如果这行不写，下面就接收不到 setup(props) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42581ad5ae4a2a116dfa326f77d02f61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3e29e80cef79872d36865a28c96a2fe/" rel="bookmark">
			数字IC设计入门（四）—— 异步FIFO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异步FIFO设计 一、设计目的二、设计思路三、接口信号定义四、设计代码五、testbench文件六、仿真结果 一、设计目的 设计一个读写时钟不同的异步FIFO。
二、设计思路 FIFO设计的重难点是如何产生空满标志，在之前的同步FIFO设计中采用的是将地址扩展一位，通过比较最高位以及其他低位来得到空满标志，当最高位相反低位相同时说明写指针追了读指针一圈，FIFO写满；当所有位相同时，已将FIFO内所有数据读出，此时为空。
而异步FIFO也将采取这种思路，但是由于涉及到写指针在写时钟域下产生，读指针在读时钟域产生，比较时我们需要将两者放在一个时候域下进行比较，那此时就分为如下两种情况：
1.在读时钟域下读写指针比较，产生empty标志；
2.在写时钟域下读写指针比较，产生empty标志；
这么做的原因在于，将写指针同步到读时钟域后，此时和读指针比较其实已经不是现在实时的写指针了，意味着此时同步过来的写指针可能是5，而实际的已经变为了7，但是进行比较之后如果读指针也恰为5则产生empty，相当于更加“保险”，避免了读“空”的情况。将读指针同步到写时钟域下，读指针会滞后实际值几个周期，但这样避免了写满之后再写的情况。
考虑到多bit数据（即异步FIFO中的读写地址）跨时钟域时出现亚稳态概率高，再由于读写地址每次加1为连续变化，因此在将读写地址同步到另一个时钟域时先对其转换变为格雷码，因为格雷码每次只变化一位，可以有效改善亚稳态情况。
所以设计过程一共分为如下几个部分：
①读写地址产生；
②读写地址二进制转格雷码；
③读写地址同步到对方时钟域；
④空满标志判断；
三、接口信号定义 信号方向说明w_ckin写时钟r_clkin读时钟rst_nin复位信号wr_enin写使能rd_enin读使能w_data[7:0]out8bit写数据r_data[7:0]out8bit读数据fullout满信号emptyout空信号 四、设计代码 module asy_fifo #( parameter WIDTH = 8, parameter DEPTH = 16 ) ( input w_clk, input r_clk, input rst_n, input wr_en, input rd_en, input [WIDTH-1:0] w_data, output reg [WIDTH-1:0] r_data, output full, output empty ); localparam addr_width = $clog2(DEPTH); reg w_rst_n; reg r_rst_n; reg r_ff1; reg w_ff1; reg [WIDTH-1:0] fifo_data[DEPTH-1:0]; wire [addr_width-1:0] waddr; reg [addr_width:0] waddr_bin; wire [addr_width:0] waddr_gray; reg [addr_width:0] waddr_gray_f1; reg [addr_width:0] waddr_gray_f2; //reg [addr_width:0] waddr_bin_2; //复位信号处理 always @(posedge w_clk or negedge rst_n) begin if(~rst_n) begin {w_rst_n,w_ff1} &lt;= 2'b0; end else begin {w_rst_n,w_ff1} &lt;= {w_ff1,1'b1}; end end always @(posedge w_clk or negedge rst_n) begin if(~rst_n) begin {r_rst_n,r_ff1} &lt;= 2'b0; end else begin {r_rst_n,r_ff1} &lt;= {r_ff1,1'b1}; end end assign waddr = waddr_bin[addr_width-1:0]; //写地址产生 always @(posedge w_clk or negedge w_rst_n) begin if(~w_rst_n) begin waddr_bin &lt;= 0; end else if(wr_en &amp; ~full)begin waddr_bin &lt;= waddr_bin + 1'b1; end end //写地址转换成格雷码 assign waddr_gray = waddr_bin ^ (waddr_bin&gt;&gt;1); //同步处理 always @(posedge r_clk or negedge r_rst_n) begin if(~r_rst_n) begin waddr_gray_f1 &lt;= 0; waddr_gray_f1 &lt;= 0; end else begin waddr_gray_f1 &lt;= waddr_gray; waddr_gray_f2 &lt;= waddr_gray_f1; end end wire [addr_width-1:0] raddr; reg [addr_width:0] raddr_bin; wire [addr_width:0] raddr_gray; reg [addr_width:0] raddr_gray_f1; reg [addr_width:0] raddr_gray_f2; //reg [addr_width-1:0] raddr_bin_2; assign raddr = raddr_bin[addr_width-1:0]; //读地址产生 always @(posedge r_clk or negedge r_rst_n) begin if(~r_rst_n) begin raddr_bin &lt;= 0; end else if(rd_en &amp; ~empty)begin raddr_bin &lt;= raddr_bin + 1'b1; end end //读地址转换成格雷码 assign raddr_gray = raddr_bin ^ (raddr_bin&gt;&gt;1); //同步处理 always @(posedge w_clk or negedge w_rst_n) begin if(~w_rst_n) begin raddr_gray_f1 &lt;= 0; raddr_gray_f2 &lt;= 0; end else begin raddr_gray_f1 &lt;= raddr_gray; raddr_gray_f2 &lt;= raddr_gray_f1; end end //产生空满标志 assign empty = (waddr_gray_f2 == raddr_gray)?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3e29e80cef79872d36865a28c96a2fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b323ef6f5fa366195c5412179280509/" rel="bookmark">
			数字IC设计入门（三）—— 同步FIFO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FIFO介绍 FIFO即First In First out，顾名思义就是先进先出，他是用来存储数据的，先存入的数据会被先读出，数据读出的顺序和数据写入的顺序相同，所以一般用作数据缓冲。例如FIFO前级模块的数据处理速率为100Mbps，后级模块的处理速率为50Mbps，这时候显然不能直接将前级数据直连到后级模块，此时就可以利用FIFO将数据暂存起来，后级模块处理时便从中读出并且不影响数据写入，也不用担心后级模块处理数据过程中数据终端的情况，因为写入速率是快于读出的速率。
而FIFO又分为同步FIFO和异步FIFO。同步FIFO指的是读写使用同一个人时钟，异步FIFO指的就是读写时钟不同。显然同步FIFO先对于异步FIFO实现起来更加简单一些，不需要考虑跨时钟域的亚稳态问题。
同步FIFO设计思路 FIFO其实就是一个存储器，那么如何实现先进先出呢？首先我们需要明确读写是独立的， 而数据的存储一般需要进行寻址，因此我们可以将地址分为读地址和写地址，每次写入数据时写地址自增，读地址不变；每次读数据时读地址自增，写地址不变，以此来完成对读写数据当前顺序的确定。
既然是存储器那必然有一个存储容量，达到存储容量后就不能写入数据了，都则会造成数据丢失。那如何确定何时达到了存储容量呢？假设FIFO的深度为100，那当写地址为99时（地址从0开始增加）就已经达到存储容量吗？显然不是，因为在这个过程中可能数据也会被读出，就好比泳池注水和排水的过程。如果写数据的过程中有数据读出，那么当写地址增加到99后，下一个写地址又会变为0（因为读数据顺序和写地址顺序一样，先从哪写的就先从哪出，既然数据被读出那一定是地址0的数据先被读出，然后是地址1的数据以此类推），之后又开始自增。那何时才是真的写满FIFO了呢，，可以将读写比作两个人围着操场跑步，两人从同一起点出发，他们之间差的距离就是目前已经存储的数据个数，每次跑完一圈回到起点的过程就是上面读写地址从99变为0，只有当前面的那个人快看到慢的那个人的背影，即将超过跑的慢的人时，这时候就已经比他快了一圈，而操场的一圈就代表FIFO的深度（存储容量），这时候就已经存满了。
如何标志FIFO满的状态 根据上面的描述，当写地址要追上读地址的时候就是写满FIFO了，那可以用已经写的地址数量（注意不是写地址，而是已经写的数量，写地址只有0-99）减去已经读的地址数量就好了。这样比较简单，但是有一个问题，因为读写数据可能一直在进行，我们得给多大的位宽才行呢？这个问题是没有办法的，如果读写速率相同并且一直在进行，那么已经写的地址数量/读的地址数量的位宽是没有边界的。但是我们需要明确，写地址只会比读地址最多快一圈，因为FIFO写满后我们就不能让数据继续写入了。因此只需要对地址位宽扩展一位，就能够得到FIFO中现存数据的数量了。下面举个例子说明：
比如读写地址数量从0-31，即FIFO的深度为32，那么读写地址的范围为5’b0-5’b11111(十进制为0-31)，那么对其进行扩展一位，地址就变为6’b0-6’b011111，当写地址写满一圈后继续增加时就变为6’b100000,而读地址还处在第一圈，假设其地址为6’b0xxxxx,其实扩展的这一位就代表目前读写地址处在哪一圈，当写地址继续增加到6’b111111时，再增加就变为6’b000000，假设读地址也读完了第一圈，那读地址为6’b1xxxxx，这时候最高位又不一样，就说明最高位代表了读写地址有没有在同一轮次（也就是跑步的两人是不是都在跑第x圈），因此这时候就可以通过扩展的这一位和写地址、读地址来得到FIFO中现存数据的个数。如果最高位不同，那写地址比读地址快一圈，原本的5位写地址+FIFO深度减去原本的5位读地址，就是现存数据的数量，当现存数据等于FIFO深度时，就拉高写满信号，停止数据写入。（也可以直接利用扩展后的写地址减去读地址得到FIFO现存数据量，即使写地址小于读地址，差值是负数，但是用补码表示依然可以得到正确的数量如写地址为6’b0 00011,读地址为6’b1 00011，写地址减去读地址得到6’b100000,此时读写指针处于同一位置，也就是说写入的数量为FIFO的深度，此时FIFO写满了）
代码实现 FIFO设计代码如下：
module FIFO_sync #( parameter DEPTH = 32, parameter DEPTH_WIDTH = 5, parameter WIDTH = 32 ) ( input clk, input rst_n, input wr_en, input [WIDTH-1:0]wr_data, input rd_en, output reg [WIDTH-1:0]rd_data, output reg rd_data_valid, output full, output almost_full, output empty, output almost_empty, output [DEPTH_WIDTH:0]data_count ); wire [DEPTH_WIDTH-1:0] wr_addr; reg [DEPTH_WIDTH:0] wr_addr_bit; wire [DEPTH_WIDTH-1:0] rd_addr; reg [DEPTH_WIDTH:0] rd_addr_bit; reg [DEPTH-1:0]memory[WIDTH-1:0]; integer i; //写数据 //写地址 always @(posedge clk or negedge rst_n) begin if(~rst_n) begin wr_addr_bit &lt;= {(DEPTH_WIDTH+1){1'b0}}; end else if(wr_en) begin wr_addr_bit &lt;= wr_addr_bit+1'b1; end else begin wr_addr_bit &lt;= wr_addr_bit; end end assign wr_addr=wr_addr_bit[DEPTH_WIDTH-1:0]; //将数据写入存储单元 always @(posedge clk or negedge rst_n) begin if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b323ef6f5fa366195c5412179280509/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f50aa48d0dee49e1ce24cf03f0918576/" rel="bookmark">
			Verilog实现呼吸流水灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 设计目的
实现一个呼吸流水灯，在1s内由暗变亮，下1s再由亮变暗。
二、 设计思路
设计一个占空比逐步增加的方波，实现由暗变亮；然后占空比逐渐变小，实现由亮变暗。每一个led灯完成这样的操作后，切换到下一个led实现流水效果。
三、 实现逻辑概述
首先假定占空比的减小速率为0.1％，于是先将1s分成1000个ms，每一个ms之间占空比的差值为0.1。
在每一个1ms内，显然我们要实现指定占空比的方波，因此我们设定一个计数器从0开始计数，比如在第一个1ms内我们希望占空比为0，led在整个1ms内为高电平，在第二个1ms内占空比为99.9%（低电平持续时间占0.1%），因此我们在计数器小于1时拉低led，之后拉高；在第三个1ms计数器小于3时拉低，以此类推，我们可以发现，每次count的比较对象从0增长到1000，恰好可以对应我们此时计数器所处的第几个ms，因此可以直接通过比较这两个计数器的值来决定led是处于低电平还是高电平。
除此之外，为了方便观察，我们希望在每个1ms内，指定占空比的方波可以维持的稍微就一些方便观察，因此我们设计了一个中间计数器count_us。由于时钟周期为10ns，而之前我们已经将1s分为了1000ms，接下来我们对1ms做如下处理，从底层向上看，之前我们提到通过比较count和第几个1ms来决定其占空比，因此count的阈值对应1000，这样一来需要花费100010即10000ns可以得到一次指定占空比的方波，而之前已经分成了1000份1ms，因此我们可以让该指定占空比的方波在这个1ms内重复1s/100010000ns=100次，来满足设计要求，同时也方便观察。
所以我们将三个计数器依次设置为count_ms、count_us、count_num，分别表示目前是第几个1ms、当前1ms的第几个方波、当前方波的计数值。
总结如下：
各个1ms内的100个cycle相同，将指定方波波形重复100次。
四、实现代码
（1）设计文件
module breathe #( parameter TIME_US = 100 , parameter TIME_MS = 1000 , parameter NUMBER = 1000 ) ( input sys_clk_p, input sys_clk_n, input rst_n, output reg [7:0] led ); wire enable; reg enable_reg; always@(posedge clk or negedge rst_n) begin if(~rst_n)begin enable_reg&lt;=0; end else enable_reg &lt;= enable; end reg [9:0] count_phase; //计数何时到达1us，每到1us时归0 reg [9:0] count_us; //单位为1us，计数到1ms时归0 reg [9:0] count_ms; //单位为1ms，计数到1s时归0 //计时至1us always @(posedge clk or negedge rst_n) begin if(~rst_n) begin count_phase &lt;= 0; end else if(count_phase == NUMBER - 1)begin count_phase &lt;= 0 ; end else if(enable) count_phase &lt;= count_phase + 1; end //计时至1ms always @(posedge clk or negedge rst_n) begin if(~rst_n) begin count_us &lt;= 0; end else if(count_us== TIME_US - 1 &amp;&amp; count_phase == NUMBER - 1)begin //每计数到1000个us归0，然后开始新一轮占空比 count_us &lt;= 0; end else if(count_phase == NUMBER - 1) count_us &lt;= count_us + 1; end reg flag_1s = 0; //计时至1s always@(posedge clk or negedge rst_n) begin if(~rst_n) count_ms &lt;= 0; else if(count_ms == TIME_MS &amp;&amp; ~flag_1s &amp;&amp; count_us == TIME_US - 1 &amp;&amp; count_phase == NUMBER - 1) begin count_ms &lt;= count_ms - 1 ; flag_1s &lt;= 1; end else if(count_ms == 0 &amp;&amp; flag_1s &amp;&amp; count_us == TIME_US - 1 &amp;&amp; count_phase == NUMBER - 1) begin count_ms &lt;= count_ms + 1 ; flag_1s &lt;= 0; end else if(count_us == TIME_US - 1 &amp;&amp; ~flag_1s &amp;&amp; count_phase == NUMBER - 1) count_ms &lt;= count_ms + 1; else if(count_us == TIME_US - 1 &amp;&amp; flag_1s &amp;&amp; count_phase == NUMBER - 1) count_ms &lt;= count_ms - 1; end reg flag_1s_reg; wire flag_neg; assign led_on = (count_phase &lt; count_ms &amp;&amp; enable)?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f50aa48d0dee49e1ce24cf03f0918576/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/208d2f9b7293022ffb5e5fe8f221a418/" rel="bookmark">
			用 Java 实现断点续传 (HTTP) | java教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用 Java 实现断点续传 (HTTP)
断点续传是一种实现文件下载的机制，可以在中断下载后从上次下载的地方继续下载。在 HTTP 请求中实现断点续传与常规下载有所不同。
假设我们的目标是使用 Java 实现断点续传功能，以下是关键要点：
断点续传原理 当浏览器请求从服务器下载文件时，通常会发起以下请求：
GET /down.zip HTTP/1.1 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/msword, application/vnd.ms-powerpoint, */* Accept-Language: zh-cn Accept-Encoding: gzip, deflate User-Agent: Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0) Connection: Keep-Alive 服务器接收到请求后，会寻找并提取文件信息，并返回给浏览器相应的信息，例如：
200 Content-Length=106786028 Accept-Ranges=bytes Date=Mon, 30 Apr 2001 12:56:11 GMT ETag=W/"02ca57e173c11:95b" Content-Type=application/octet-stream Server=Microsoft-IIS/5.0 Last-Modified=Mon, 30 Apr 2001 12:56:11 GMT 为了实现断点续传，客户端浏览器需要向 Web 服务器发送一个带有起始位置的请求信息。例如，下面的请求表明从字节位置 2000070 开始下载：
GET /down.zip HTTP/1.0 User-Agent: NetFox RANGE: bytes=2000070- Accept: text/html, image/gif, image/jpeg, *; q=.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/208d2f9b7293022ffb5e5fe8f221a418/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/868de64b615dd7440165b5d4667f22ac/" rel="bookmark">
			Freertos tick 不响应中断的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码环境 babyos+freertos 操作方法 通过 shell 操作eeprom 的写操作
问题现象 整个系统会卡在延时函数这里，卡的原因是rtos 的tick中断不响应了。
shell不响应外部命令 系统是正常运行的。
解决方法 成功的方法 ms延时由依赖tick改为us的堵塞延时；
这里改为堵塞延时的副作用是 系统会堵塞在这里，现在这个应用场景这样做是没问题的，因为我们再人为调参数。
失败的方法 ms 延时改为rtos延时；
这时候如果写入的是4个字节，正常运行；
如果写入50个字节，系统就会卡死在
void vPortEnterCritical( void ) 分析：eeprom 的写操作 需要ms级别的延时，如果涉及到eeprom 的写操作中，会涉及到很对5ms 的延时；
rtos的延时就会发生一次任务切换，改为us堵塞延时正常了，原因之一就是任务切换太频繁了。
对于任务切换太频繁导致进入void vPortEnterCritical( void )的方法，我是使用堵塞延时；其他方法应该也有，这里我就不去研究了。
总结 记录一些这次经历，也是有收获的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/277e4acc349c5fbb3593f1defb1b22d0/" rel="bookmark">
			2 移动链表中的最大值到尾部
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写函数MoveMaxToTail()，实现查找单链表中值最大的结点，并将其移动到链表尾部，注意其他结点的相对次序不变。要求尽量具有较高的时间效率。
例如输入8 12 46 30 5，输出为8 12 30 5 46
函数接口定义： void MoveMaxToTail (LinkList H );
裁判测试程序样例： #include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
typedef int DataType; struct Node
{
DataType data; struct Node* next; };
typedef struct Node *PNode; typedef struct Node *LinkList; void MoveMaxToTail(head);
LinkList SetNullList_Link() {
LinkList head = (LinkList)malloc(sizeof(struct Node));
if (head != NULL) head-&gt;next = NULL;
else printf("alloc failure");
return head; }
void CreateList_Tail(struct Node* head)
{
PNode p = NULL;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/277e4acc349c5fbb3593f1defb1b22d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd7dc36917870bcf590676794075ad27/" rel="bookmark">
			GCC compile error: expected ‘=‘, ‘,‘, ‘；‘, ‘asm‘ or ‘__attribute__‘ before ‘typedef‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gcc编译的时候“忽然”出现的，按照网上的教程找了头文件有没有忘了#和句尾的；。发现都正常，全文找了一遍，结果发现是license之前多了一个i........
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90284375a9201443f1d787983cdd5b36/" rel="bookmark">
			Python 面向对象--人狗大战（教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目实训
多条狗，多个人，有名字，品种，年龄，攻击力
狗可以咬人，人可以打狗
当有多个实体的情况下，就可以使用模板的形式来使用；
定义一个函数dog，将需要的参数写入字典data，返回data，就完成了模板
再d1给到dog所需要的参数name，d_type也就是实体了，实体可以有很多个
再进行输出print
因为每条狗的攻击力是不一样的，所以写一个字典，来判断攻击力
二哈的攻击力为20，藏獒的攻击力为70
再在data字典下return上写一个if判断来自动区分攻击力
这里好了就输出试一试
能正常输出那么代码也就没有问题了
接下来就生成人，人和dog角色的模板是一样的
定义一个函数person，有两个参数name和age
血量(life_val)是和dog角色一样的100
if 判读age(年龄)&gt;=18，也就是成年人攻击力为50，当age不&gt;=18就为未成年，攻击力为30
最后return data
写完了，那么就输出看一下，18=18，经过判断attack=50
接下来就写游戏交互，交互就可以写成一个函数，dog_bite（狗咬人）
1：定义一个函数dog_bite有两个参数dog_obj和person_obj
2：人的血量减去狗的攻击等于剩余的血量，这个就是咬人动作
3：输出狗的[name]咬了人[name]，人掉血[attack_val],还有血量[life_val];
（说的可能不是很明白，看输出就懂了）
4：输出
人打狗其实是一样的，这里就省去步骤，直接看代码
到现在这个代码还没有完全结束，dog_bite不是只属于dog的，person_beat也不是只属于person的,person可以使用dog_bite这个动作,dog也能使用person_beat这个动作；
在这里person使用了dog_bite的动作
这样的话整个就乱 了
要改成dog_bite只能被dog使用，person_beat只能被person使用；就要给到一个限制
咱们可以把咬人的动作放到函数dog下
这样的话在外面是没办法调用dog_bite这个函数的；如果想在执行函数的时候不调用dog_bite，在后面可以调用dog_bite函数，你可以把dog_bite存在data里面（为了可以在函数外部可以调用dog_bite方法），这样在dog_bite函数里就可以不要传dog_obj的值（将dog_bite的dog_obj改成data）,现在dog_bite的动作就只属于dog了
Person_beat这个函数也是一样的，这里就直接看代码了（参考修改dog_bite）
这样dog_bite就是专属dog的，person_beat就专属person的
Person person_beat，dog dog_bite就会报错
正常输出试一下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b32067bbe4c1c87bfb5c040af585302/" rel="bookmark">
			vue3大屏项目(带地图)如何做响应式，适配不同尺寸电脑，直接看第三种方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.方案一：使用淘宝插件：flexble.js搭配pxtorem(编辑器插件)， 需要一个一个去ctrl+d去将px转为rem，太麻烦 2.方案二：使用autofit.js：不适用于地图(echarts、cesium、arcgis)，原因：在三维中，点击房屋模型，弹窗的位置会发生偏移 3.方案三：使用postcss-pxtorem，不用手动将px转rem，适用于地图，不会发生偏移问题 一：下载依赖："postcss-pxtorem": "^6.0.0","postcss": "^8.4.31","postcss-loader": "^7.3.3",
二：在package.json同级下新建一个postcss.config.js文件，内容如下
export default { 'plugins': { // to edit target browsers: use "browserslist" field in package.json 'autoprefixer': {}, 'postcss-pxtorem': { rootValue: 16, // 结果为：设计稿元素尺寸/16，比如元素宽320px,最终页面会换算成 20rem propList: ['*'] } } } 三：在utils文件夹下新建一个rem.js文件，代码如下
// 设置 rem 函数 function setRem() { // 1920 默认大小16px; 1920px = 120rem ;每个元素px基础上/16 const screenWidth = 1920 const scale = screenWidth / 16 const htmlWidth = document.documentElement.clientWidth || document.body.clientWidth // 得到html的Dom元素 const htmlDom = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b32067bbe4c1c87bfb5c040af585302/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc52a54336728234af093005857aa75f/" rel="bookmark">
			linux系统创建新用户，并提升至root权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在root权限下，输入命令：
useradd -m + 用户名 // 将在/home目录下创建同名文件夹
passwd + 用户名 //为指定的用户名设置密码
这时，该新用户是没有root权限的。我们需提升权限，仍然在root权限下：
1、chmod u+w /etc/sudoers // 输入修改权限命令
2、vim /etc/sudoers // 编辑文件，并按i键进入insert模式
3、输入`用户名 ALL=(ALL )ALL` // 在` root ALL=(ALL)ALL`下一行
4、按 ESC 键退出insert模式，然后输入:wq!关闭并保存
5、chmod 440 /etc/sudoers // 恢复权限
到此，大功告成！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a979e53acd35286febb4aa3bd62be847/" rel="bookmark">
			hasura-cli终端运用-迁移和元数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.迁移和元数据(migrations&amp;metadata) 迁移是负责重新创建同样的数据库架构，每个迁移都有两个名为up.sql和down.sql的文件来表示，其中包含了一些sql脚本，up.sql包含了当你应用某些特定的迁移时应该执行这些脚本，例如：
down.sql包含了当你想要回滚时应该执行的的脚本，例如：
除了迁移我们还有很多其他的东西需要追踪，例如：权限(permissions)、关联关系(relationships)、事件触发器等和其他用于描述暴露数据API的东西，但它们并不属于迁移，因为它们不是数据库，而这些正是元数据发挥作用的地方，元数据是由元数据文件夹下的yml文件，或者说是由元数据文件夹表示的
2.终端hasura-cli 终端安装有两种方式：
一种是直接安装，具体方式可以在官网进行查看：hasura-cli另外一种方式是在docker-compose.yml里面进行配置 version: '3' services: ... hasura: image: hasura/graphql-engine:latest.cli-migrations-v3 ... volumes: hda-data: latest是hasura最新的版本，v3是终端的版本
docker方式的配置可以进入到hasura的容器中进行验证，输入：hasura-cli，也可以直接使用docker-compose exec hasura hasura-cli
可以通过运行hasura-cli version查看cli版本
通过运行hasura-cli init 进行初始化，在初始化之前可以先在config.yml文件里面进行配置迁移和元数据的文件夹路径和执行地址
version: 3 endpoint: http://hasura:8080 admin_secret: myadminsecretkey metadata_directory: metadata migrations_directory: migrations actions: kind: synchronous handler_webhook_baseurl: http://hasura:8080 在工作目录下或者在容器里面进行初始化：
hasura init [文件夹名称]
例如：hasura init hasura-server
3.元数据导出 在hasura终端下执行：hasura metadata export
在metadata文件夹下的action.graphql文件会添加hasura的执行脚本，对应的yml文件里面都会生成元数据的可执行脚本语句
4.检查迁移和元数据状态 在hasura终端下执行：hasura migrate status
源码状态Present意味着这个迁移在我们的源代码或迁移文件夹中存在，如果看到Not Present意味着该迁移已经在服务器上应用，但在源代码中并不存在，数据库状态显示不存在意味着虽然迁移存在，它还没有应用到数据库中，因为hasura amie grade create 只创建了迁移，但还没有应用它。为了同步源代码的数据库我们必须应用迁移来做到这一点，通常情况下我们只需要执行
hasura migrate apply 但在特殊情况下直接执行将会报错，因为hasura运行迁移脚本试图重新创建已经存在的表
有两种方法来解决这个问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a979e53acd35286febb4aa3bd62be847/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17da834bdbda705e653293d0c8c5b367/" rel="bookmark">
			安装及管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Linux三大类
Rpm
查询
安装
卸载
Yum
如何实现安装服务
搭建过程
编译安装
Linux三大类 1.Rpm 类似360软件工具（红帽公司开发）
2.编译安装 将源代码编译成可执行文件（二进制包安装） 自由度高 难度大
3.yum 最后用的还是rpm（升级版本）
Rpm 查询 rpm-q httpd 查询 httpd软件包是否安装 rpm -ql httpd 文件列表
rpm -qc httpd 查询httpd软件的配置文件
rpm -i httpd 查询软件的基础信息
安装 rpm-ivh 软件包
i 安装
v 显示过程
h 人性化
卸载 rpm-e 软件名
挂载：用系统中的某个文件夹和外来硬件设备做关联，使用这个文件夹等于使用该硬件设备。
所有的外来硬件设备，想在linux中使用必须挂载
Yum yum 仓库 自动解决依赖关系
如何实现安装服务 client/server
rpm -qc httpd 查询httpd软件的配置文件
搭建过程 本地 自己既是服务端 也是客户端
本地
自己建
服务端必须要有两个文件夹
repodata 必须叫这个名字
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17da834bdbda705e653293d0c8c5b367/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4acfedef7aefc5f50d7efe100e73ee52/" rel="bookmark">
			在matlab中使用PTB时遇到的问题以及解决方法（随时更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题1：错误使用 Screen
methods：
问题2：图片太大，PTB函数无法呈现
methods：
问题1：错误使用 Screen See error message printed above.
出错 PsychImaging (line 2470)
[win, winRect] = Screen('OpenWindow', screenid, clearcolor, winRect, pixelSize,
numbuffers, stereomode, multiSample, imagingMode, specialFlags, clientRect,
fbOverrideRect, vrrParams);
出错 tACS_IAF_bp (line 44)
[window, windowRect] = PsychImaging('OpenWindow', screenNumber, black);
methods： 在 [window, windowRect] = PsychImaging('OpenWindow', screenNumber, black);之前添加Screen('Preference', 'ConserveVRAM', 64);
% Open an on screen window Screen('Preference', 'ConserveVRAM', 64); [window, windowRect] = PsychImaging('OpenWindow', screenNumber, black); 问题2：图片太大，PTB函数无法呈现 methods： 使用imresize调整图片大小
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4acfedef7aefc5f50d7efe100e73ee52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74a48c7e5f9f0be9572f6392f9e1e069/" rel="bookmark">
			Windows键 &#43; Shift &#43; S 截图图片保存位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 地址
C:\Users\Administrator\AppData\Local\Packages\MicrosoftWindows.Client.CBS_cw5n1h2txyewy\TempState\ScreenClip 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04a7534f55d2ba06d8ff84f54414e7ba/" rel="bookmark">
			Centos虚拟机安装配置与MobaXterm工具及Linux常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Centos操作系统
1.1 Centos介绍
1.2 Centos虚拟机安装
1.3 配置centos的镜像 1.4 虚拟机开机初始设置 1.4.1 查看网络配置
1.4.2 编辑网络配置 二、MobaXterm工具
2.1 MobaXterm介绍
2.2 MobaXterm安装 2.3 切换国内源
三、Linux常用命令和模式
3.1 查看网络配置
3.2 文件管理
3.3 vi或vim编辑器
3.3.1 命令模式
3.3.2 编辑模式
3.3.3 末行模式
TIps：VMWare虚拟机快照还原功能
一、Centos操作系统 1.1 Centos介绍 CentOS（Community Enterprise Operating System）是一种基于Linux的操作系统，它是由社区开发和维护的免费开源软件。CentOS是基于Red Hat Enterprise Linux（RHEL）的源代码构建的，因此它与RHEL非常相似，提供了稳定、可靠和安全的操作系统环境。
CentOS是一种稳定、可靠和安全的开源操作系统，它基于RHEL构建，并提供了广泛的兼容性和软件包管理功能。CentOS适用于各种用途，特别是在服务器环境中，它拥有一个活跃的社区，为用户提供支持和帮助。
1.2 Centos虚拟机安装 安装虚拟机需要提供虚拟机管理、迁移、快照和恢复、虚拟化网络以及云计算等功能的产品，这里推荐VMWare，其安装步骤以及虚拟机安装与同，可参考该文章 --&gt;VMWare虚拟机安装与环境配置 下面就是Centos虚拟机的创建，可看第三章，安装配置Conetos虚拟机时只需修改如下选项：
1.3 配置centos的镜像 注意下载到非中文路径名文件夹下
Centos 镜像下载：https://wiki.centos.org/Download.html
1.4 虚拟机开机初始设置 1、点击开启虚拟机，利用上下键选择第二个 Test this media &amp; install CentOS 7 , 然后回车。
设配初始化中...
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04a7534f55d2ba06d8ff84f54414e7ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d50d469cb417d82234f2d529e93010e/" rel="bookmark">
			数字IC设计入门（二）——门控时钟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		门控时钟的定义
时钟门控(Clock-Gating)一直以来都是降低微处理器功耗的重要手段,主要针对寄存器翻转带来的动态功耗，在某一时段不需要使用时钟时，通过使能信号将时钟关闭，从而降低其所带来的功耗。
常见的门控时钟：
①直接利用与门实现
如下图：
这样实现起来比较简单，但是同样也伴随着一些问题。如果使能信号在时钟上升沿的时候拉低，那最后会出现下面这样的情况，产生毛刺，这是非常危险的情况。所以要采取一种方法，能够消除这种毛刺。
②利用锁存器实现
根据第一种方法中的情况，在时钟信号为高时突然使能信号为低，造成输出的时钟突然拉低，那么可以从这方面考虑来解决这个问题：使能信号只能在时钟低电平时才能拉低。这样的话，源时钟低电平时本身产生的时钟信号就为低电平，并且即使没有使能这个时钟，输出的时钟也为低电平，这样就不会产生毛刺。
那么如何实现将使能信号只在低电平时才会变低呢？其实就是让使能信号只会在时钟低电平时更新就行，可以通过低电平敏感的锁存器来实现。
③利用寄存器实现门控时钟
也可以采用寄存器进行打拍，让使能信号在每个周期内保持一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88f81e1fff9835626a7756cd0e51efe8/" rel="bookmark">
			ubuntu实现自动挂载u盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu实现自动挂载u盘 但是，有些设施可以在没有图形工具的情况下进行复制，并且在系统上占用的空间非常小。
例如，在我的设置中，我已经实现了USB自动挂载服务，而无需使用任何外部工具/服务，只有udev和systemd。
编写shell脚本 nano /usr/local/bin/usb-mount.sh #!/bin/bash ACTION=$1 DEVBASE=$2 DEVICE="/dev/${DEVBASE}" # See if this drive is already mounted MOUNT_POINT=$(/bin/mount | /bin/grep ${DEVICE} | /usr/bin/awk '{ print $3 }') do_mount() { if [[ -n ${MOUNT_POINT} ]]; then # Already mounted, exit exit 1 fi # Get info for this drive: $ID_FS_LABEL, $ID_FS_UUID, and $ID_FS_TYPE eval $(/sbin/blkid -o udev ${DEVICE}) # Figure out a mount point to use LABEL=${ID_FS_LABEL}-${DEVBASE} if [[ -z "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88f81e1fff9835626a7756cd0e51efe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27785a27a86cb9858de02c964a43b122/" rel="bookmark">
			JS获取阿里云oss私有图片需要通过SDK加签名访问问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、问题背景二、了解一些概念1. 防盗链2. 公有和私有两种链接的区别 三、浏览器安装SDK四、js的SDK对url加签名实现方法实现示例 五、另外1. 跨域问题 六、文章用到的官方文档链接 一、问题背景 我们项目中平时需求都是上传一张原始图片到阿里云OSS公共空间，通过简单的url携带参数的形式，获取各种操作之后的图片，很方便的。图片允许任何人（包括匿名访问者）都可以对该 Bucket 中的文件进行读操作。文件URL的格式为 https://BucketName.Endpoint/ObjectName。其中，ObjectName需填写包含文件夹以及文件后缀在内的该文件的完整路径。
但是这次的需求是上传公司的印章，属于比较隐私的，不想让没有访问权限的人读，所以需要上传到私有空间，但是上传私有空间，则必须进行 签名 操作。私有文件URL的格式为https://BucketName.Endpoint/Object?签名参数。
引用官方文档的原话 对于不允许匿名访问的私有图片文件，不支持通过文件URL直接添加参数的方式处理图片，您需要通过SDK的方式将图片处理操作加入签名URL中。
好了，下一步我们就去找SDK，通过SDK在 url 中加签名。
二、了解一些概念 在开始之前先了解几个概念。
1. 防盗链 直接从数据库拿到的url是不能访问oss的图片的，由于oss是按照点击请求收费的，把oss设置为私有能防止网络黑客攻击而导致费用增加。通过签名算法给url加上签名标签和访问时效，给url一个临时授权才能访问到，过了访问时间这个url又变成无效，即防盗链。
数据库中拿到的url访问oss的图片会提示 403 没有权限（如果上传到公共空间是可以直接访问oss图片的）
简单来说，阿里云OSS 将文件夹的权限设置成私有的情况下，就需要先获取到签名才可以访问。类似一些用户的身份证照片，比较隐私的图片等。都可以设置防盗链来防止黑客获取。
2. 公有和私有两种链接的区别 数据库拿到的和oss设置为公共可读的链接
https:/yourbucket-public.oss-cn-hangzhou.aliyuncs.com/seal/tKUPnBPQc.jpg oss设置为私密的链接和我们通过签名算法得到的链接
http://yourbucket-private.oss-cn-hangzhou.aliyuncs.com/seal/tKUPnBPQc.jpg?OSSAccessKeyId=****79acT97KJAbPuhx***&amp;Expires=1698472190&amp;Signature=****ZJLpRwmJa1DKfn4zqGltk**** 可以看到有三个参数OSSAccessKeyId（即AccessKeyId）、Expires（链接失效时间）、Signature（签名算法获得的签名）
三、浏览器安装SDK OSS官方文档 在URL中包含签名 提供各语言SDK生成签名URL的方法，但是没找到javaScript的SDK !!!
别着急，地址在这 OSS Browser.js SDK的安装
其实仔细看文档的话都有的。关于浏览器上传oss的文档都在这的。
四、js的SDK对url加签名实现方法 一开始我还是按照传 公有空间 那样处理的url，比如 https:/yourbucket-private.oss-cn-hangzhou.aliyuncs.com/seal/tKUPnBPQc.jpg
图片倒是能上传到OSS上，但是页面上的图片报错 403 Forbidden，导致上传的图片在前端页面上显示不出来，原因是没有权限读取私有空间的存储。
错误效果如下：
幸得同事告知传 私有空间 的话url需要加签名，实际需要这种url。
实现示例 1）使用npm安装SDK开发包
npm install ali-oss 2）进行初始化配置，这四个参数都是必填项
const OSS = require('ali-oss'); export const client = new OSS({ // 填写Bucket所在地域。以华东1（杭州）为例，Region填写为oss-cn-hangzhou。 region: 'oss-cn-hangzhou', // 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户。 accessKeyId: yourAccessid, accessKeySecret: yourAccesskey, // 填写存储空间名称。 bucket: 'your-private' }) 3）需要的地方调用 signatureUrl() 方法进行签名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27785a27a86cb9858de02c964a43b122/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6019227c96518b9da4cd5ff3c449a55/" rel="bookmark">
			空间分析通常用到哪些开源库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		空间分析是地理信息系统（GIS）中的一个重要领域，用于研究和处理地理空间数据。以下是一些常用的开源库，用于进行空间分析：
1. GDAL/OGR：GDAL（Geospatial Data Abstraction Library）是一个强大的开源库，用于读取、写入和处理各种地理数据格式，包括栅格和矢量数据。OGR（OpenGIS Simple Features Reference Implementation）则是GDAL的矢量数据处理模块。GDAL/OGR提供了一些常用的空间分析功能，如坐标转换、缓冲区分析、叠加分析等。
2. Shapely：Shapely是一个用于处理几何对象的Python库，它提供了一些方便的函数和类，用于进行空间分析。Shapely支持点、线、面等几何对象的创建、编辑和分析，如距离计算、面积计算、交集计算等。
3. GeoPandas：GeoPandas是一个基于Pandas的Python库，用于处理地理数据。它提供了一些方便的函数和类，用于读取、处理和分析矢量数据。GeoPandas支持空间索引、空间查询、叠加分析等功能。
4. PySAL：PySAL（Python Spatial Analysis Library）是一个用于空间分析的Python库，它提供了一些常用的空间分析方法和工具，如空间自相关分析、空间回归、空间聚类等。PySAL还支持各种空间数据格式和空间索引结构。
5. Rasterio：Rasterio是一个用于处理栅格数据的Python库，它提供了一些方便的函数和类，用于读取、处理和分析栅格数据。Rasterio支持栅格数据的读写、坐标转换、重采样、叠加分析等功能。
这些开源库提供了各种空间分析方法和工具，可用于处理不同类型的地理空间数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5bf62e754e4399394f3f3570398d3ef/" rel="bookmark">
			简单解决 Error updating database. Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 insert操作时莫名报错
org.springframework.jdbc.BadSqlGrammarException: ### Error updating database. Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'record ( oid, number, operator, operator_describe ) VALUES ( 28, 'AS16986482811111' at line 1 ### The error may exist in com/xxx/xxx/order/dao/OrderOperatingRecordDao.java (best guess) ### The error may involve com.xxx.xxx.order.dao.OrderOperatingRecordDao.insert-Inline ### The error occurred while setting parameters ### SQL: INSERT INTO order_operating record ( oid, number, operator, operator_describe ) VALUES ( ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5bf62e754e4399394f3f3570398d3ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9143dbcde69e93f2c21844bc8bfe0cb/" rel="bookmark">
			【论文阅读】End-to-End Spatio-Temporal Action Localisation with Video Transformers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 摘要和结论引言模型框架Vision EncoderTubelet Decoder(factorise Queries CA MHSA)Training objectiveMatching 摘要和结论 e2e，纯基于Transformer的模型，输入视频输出tubelets。无论是 对单个帧的稀疏边界框监督 还是 完整的小管注释。在这两种情况下，它都会预测连贯的tubelets作为输出。此外，我们的端到端模型不需要以建议的形式进行额外的预处理，或者在非最大抑制方面进行后处理。（DETR） 引言 该模型的初始阶段是一个视觉编码器。接下来是一个解码器，它处理学习到的潜在查询，这些查询代表视频中的每个参与者，进入输出小管——输入视频剪辑每个时间步的边界框和动作类序列。
我们的模型是通用的，因为我们可以使用完全标记的管注释或稀疏关键帧注释（当只标记有限数量的关键帧时）来训练它。在后一种情况下，我们的网络仍然预测小管道，并在没有明确监督的情况下，学会将演员的检测从一帧关联到下一帧。我们的因子分解query、解码器架构和损失中的小管道匹配的公式促进了这种行为，这些都包含时间归纳偏差。
模型框架 我们的模型由一个视觉编码器组成，然后是一个解码器，该解码器将学习到的查询令牌处理为输出小管道。我们在解码器中加入了时间归纳偏差，以在较弱的监督下提高准确性和小管道预测。
Vision Encoder 将X处理为x。移除时空聚合步骤，同时如果时间的patch的尺寸大于1，则双线性插值来维持时间的分辨率。
Tubelet Decoder(factorise Queries CA MHSA) 解码器由L层组成，每个层对查询query执行一系列自注意操作，并在查询和编码器输出之间进行交叉注意。我们修改了时空定位场景的查询、自注意和交叉注意操作。 以包括额外的时间归纳偏差，并提高准确性，具体如下：
Queries： q ∈ R_T ×S×d，factorise the queries分解query到时间和空间（qs ∈ R_S×d，qt ∈ R_T×d）。我们只需在所有帧上重复空间查询，并将它们添加到每个位置对应的时间嵌入中。(在每个位置，将查询向量与对应的时间嵌入相加。)
Decoder layer： factorise the self- and cross-attention layers across space and time respectively.分别分解空间和时间上的自我注意层和交叉注意层。具体来说，在MHSA中，Q K V 分别在时间和空间维度上独立计算两次。类似地，我们修改了交叉关注操作，以便只有来自同一时间索引的tubelet查询和主干功能相互关注。
我们的解码器层由因子分解的自注意（SA）（左）和交叉注意（CA）（右）操作组成，旨在提供时空归纳偏差并减少计算。这两种操作都将注意力限制在与查询令牌相同的空间和时间切片上，如给定查询令牌（品红色）的感受野（蓝色）所示
Localisation and classification heads：
我们通过将一个小的前馈网络应用于解码器 z 的输出来获得网络 y = (b, a) 的最终预测，遵循 DETR。边界框序列 b 使用 3 层 MLP 获得，并由 Tubelet 中每一帧的框中心、宽度和高度参数化。单层线性投影用于获取类 logits a。当我们预测每帧固定数量的 S 个边界框时，S 大于帧中地面实况实例的最大数量，我们还包括一个额外的类标签 ∅，它表示没有动作类别的小管可以分配给的“背景”类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9143dbcde69e93f2c21844bc8bfe0cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44ef4f1f153d053ea51c3d46a63d36f0/" rel="bookmark">
			AD（Altium Designer）的一些功能操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看PCB图 隐藏其他层显示 方法一：在pcb文件视图下，按下字母L，弹出如下框，选择view options，在single layer modes里面选择，hide other layers选项，就可以隐藏其他层显示了。
方法二：shitf+s快捷键。单层显示
快捷键： 一、通用快捷键 1、放大缩小：常用方法，ctrl+鼠标滚轮，鼠标中键+移动鼠标，pgup、pgup。
2、切换不同的布线层：ctrl+shift+鼠标滚轮
3、在SCH或者PCB 同一平面内左右翻转：ctrl+X
4、在SCH或者PCB 同一平面内上下翻转：ctrl+Y 5、放置元件的时候变换方向：在放置的时候按空格键，或选中的时候再按空格键都可以
6、改变走线方向：shift+空格
7、选择全部：SA
8、全部取消：XA
9、删除：先按ED，再选择要删除的对象
10、测量距离：RM
11、调整图片显示满屏：VF
12、刷新：VR
13、换层：+-
14、看单面板：shift+s
15、鼠标进入选中状态：EH
16、公英转换：Q
17、以鼠标为中心刷新：home
18、定位到原点：ctrl+end在画pcb库时经常用
19、拖动时保持连线关系不变：ctrl+鼠标左键
20、缩小整张视图：VD
21、终止当前正在进行的操作：eas
22、左箭头——光标左移1个电气栅格
23、右箭头——鼠标右移1个电气栅格
24、上箭头，下箭头同理
25、ctrl+方向键可以移动元件
26、shift+右键，光标右移10个栅格，同理左键左移
27、ctrl+1以零件原来的尺寸显示图纸
28、ctrl+shft+T(top)：上对齐
29、ctrl+shft+B(bottom):下对齐
30、ctrl+shft+L(left):左对齐
31、ctrl+shft+T(right):右对齐
32、ctrl+shft+H(horizonta):水平方向上等距
33、ctrl+shft+V(vertical):竖直方向上的等距
33、ctrl+shft+V(vertical):竖直方向上的等距
34、在PCB电气层之间切换（小键盘上的*）。在交互布线的过程中，按此键则换层并自动添加过孔。
35、Tab键在交互布线或放置元件、过孔等对象的过程中修改对象属性。
36、Backspace键在交互布线（手动布线）的过程中，放弃上一步操作。
37、主键盘上的1在交互布线的过程中，切换布线方法（设定每次单击鼠标布1段线还是2段线）。
38、主键盘上的2在交互布线的过程中，添加一个过孔，但不
39、Shift+S切换单层显示和多层显示换层。
40、Shift+C清除当前过滤器。（当显示一片灰暗时，可恢复正常显示）。
41、 Ctrl+鼠标左键高亮显示同网络名的对象（鼠标左键必须点到有网络名的对象）
42、 Ctrl+R一次复制，并可连续多次粘贴。
43、 Ctrl+C复制
44、 Ctrl+V粘贴
45、 Ctrl+S保存文档。
46、Ctrl+M 测量距离
二、SCH 快捷键 1、画原理图时按住ctrl，线跟着元器件运动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44ef4f1f153d053ea51c3d46a63d36f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337b6fac24bd579d809d14a99b4f5272/" rel="bookmark">
			Android开发：Android颜色透明度换算表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、背景二、颜色值标准格式三、透明度 四、透明度计算 一、背景 作为一名Android开发人员，在每次开发的时候，UI会在设计图中标注颜色值，或者会直接给出颜色值，如：#FF2309，但是有时候为了达到某种效果，需要在颜色值前面添加透明度，如：40%|的透明度。还有一种情况就是交给UI验收的时候，说界面和设计图不符，让自己回去做对比，往往和透明度的值有关系，我的天！整个人都不好了，透明度怎么计算？怎么搞？
一定要和UI对接好，UI给的是透明度不透明度的值，很重要！！！
二、颜色值标准格式 Android中的颜色值标准格式为RGB/ARGB标准，使用时通常以“#”字符开头，以16进制表示。
如：#RGB、#RRGGBB、#ARGB、#AARRGGBB。R：红色；G：绿色；B：蓝色；A:透明度，如果不含A，说明完全透明（即默认100%，完全不透明）。
三、透明度 一定要和UI对接好，UI给的是透明度不透明度的值，很重要！！！
口语说的透明度从0%~100%，换算成二进制为256个值（0-255），计算机上用16进制表示为（00-ff）。透明就是0，不透明就是255,如果50%|透明就是127（256的一半是128，但因为是从0开始，所以实际上是127）。
透明度 和 不透明度 是两个概念， 它们加起来是1，或者100%
ARGB 中的透明度alpha，表示的是不透明度。
四、透明度计算 需要不透明度值的，可以自己算：透明度值 + 不透明度值 = 100%
如果你的UI设计师给的视觉稿标注是：颜色#FFFFFF，透明度40% 。那你的计算方式应该是：
将透明度转换成不透明度。不透明度为：60%
不透明度乘以255。 我们得到结果：153
将计算结果转换成16进制。得到最终的不透明度：99
将不透明度和颜色值拼接成ARGB格式。得到最终的颜色值： #99FFFFFF
所以，你的UI设计师要的颜色是：#99FFFFFF
如果UI给的是透明度值A%，则计算公式：255(100% - A%) ，将计算结果转为16进，对照表1：*
表一：
透明度16进制表示100 %0099 %0398 %0597 %0796 %0A95 %0D94 %0F93 %1292 %1491 %1790 %1A89 %1C88 %1E87 %2186 %2485 %2684 %2983 %2B82 %2E81 %3080 %3379 %3678 %3877 %3B76 %3D75 %4074 %4273 %4572 %4771 %4A70 %4D69 %4F68 %5267 %5466 %5765 %5964 %5C63 %5E62 %6161 %6360 %6659 %6958 %6B57 %6E56 %7055 %7354 %7553 %7852 %7A51 %7D50 %8049 %8248 %8547 %8746 %8A45 %8C44 %8F43 %9142 %9441 %9640 %9939 %9C38 %9E37 %A136 %A335 %A634 %A833 %AB32 %AD31 %B030 %B329 %B528 %B827 %BA26 %BD25 %BF24 %C223 %C422 %C721 %C920 %CC19 %CF18 %D117 %D416 %D615 %D914 %DB13 %DE12 %E011 %E310 %E69 %E88 %EB7 %ED6 %F05 %F24 %F53 %F72 %FA1 %FC0 %FF 举个例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/337b6fac24bd579d809d14a99b4f5272/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3d8df306cca22986259b443b7eef65c/" rel="bookmark">
			【JVM】垃圾回收机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【JVM】垃圾回收机制 文章目录 【JVM】垃圾回收机制1. 方法区的回收2. 堆的回收2.1 引用计数法2.2 可达性分析算法 3. 对象引用3.1 强引用3.2 软引用3.3 弱引用3.4 虚引用和终结器引用 4. 垃圾回收算法4.1 标记清除算法4.2 复制算法4.3 标记整理算法4.4 分代垃圾回收算法 5. 垃圾回收器5.1 年轻代-Serial垃圾回收器5.2 老年代-SerialOld垃圾回收器5.3 年轻代-ParNew垃圾回收器5.4 老年代-CMS(Concurrent Mark Sweep)垃圾回收器5.5 年轻代-Parallel Scavenge垃圾回收器5.6 老年代-Parallel Old垃圾回收器5.7 G1垃圾回收器5.8 总结 1. 方法区的回收 方法区中能够回收的内容主要是不再使用的类。我们知道类的生命周期有七个部分，最后一个就是卸载。
判定一个类可以被卸载，需要同时满足三个条件：
此类的所有实例对象都已经被回收了，也就是说在堆中已经不存在该类的实例对象以及子类对象了。
Class&lt;?&gt; clazz = loader.loadClass("com.zhj.A"); Object o = clazz.newInstance(); o = null; 加载该类的类加载器已经被回收了。
URLClassLoader loader = new URLClassLoader(new URL[]{new URL("file:D:\\lib\\")}); loader = null; 该类对应的 java.lang.Class 对象没有在任何地方被引用。
Class&lt;?&gt; clazz = loader.loadClass("com.zhj.A"); clazz = null; 我们知道，项目当中我们自己创建的类都是由应用程序类加载器来进行加载的，而应用程序类加载器是不会被置为null的，也就是说这个类无法被卸载。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3d8df306cca22986259b443b7eef65c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fa15b2a38d400ac42f3445d23030f25/" rel="bookmark">
			大语言模型之十八-商业思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大语言模型在翻译、知识问答、写作、摘要、搜索、代码开发等场景得到了广泛的应用，一些策略是将大语言模型集成到公司的现有产品，比如微软的Office接入ChatGPT。
当前大语言模型盈利情况堪忧，今年 5 月有媒体曝出因去年开发出 ChatGPT，OpenAI 亏损 5.4 亿美元，微软在 GitHub Copilot拥有 150 万用户的基础上，每月仍倒贴每位用户 20 美元。
前面博客主要内容围绕着优秀的基座模型、模型量化以及fine-tune等技术，其核心思想是降低中小公司的技术门槛和使用成本。
本质上，大语言模型是利用现有资源, 快速地将数据转化为企业生产力，数据是是第一出发点，如何提炼和使用公司数据，是应用和商业化不得不考虑的点。
基座模型训练成本 训练一个基座模型的成本最包括计算资源、数据、研发人员，总的来说从数据采集清洗，到模型开发训练、模型管理，再到云端及离线推理服务管理等AI开发过程的全生命周期都涉及相关费用，此外还有法务、安全等
OpenAI的ChatGPT模型使用了微软算力平台，微软的基础算力平台使用了数以千计的英伟达GPU，使用基于英伟达量子 InfiniBand 通信网络连接在一起，用于高性能计算，据彭博社报道，微软在该ChatGPT项目上已经花费了数亿美元。
国盛证券曾经估算，GPT-3训练一次的成本约为140万美元，对于一些更大的LLM模型，训练成本介于200万美元至1200万美元之间。
当训练一个 65B 参数的开源大语言模型Llama模型时，在 2048 A100 GPU 和 80GB 的内存上处理大约 380 个 token /秒/GPU，这意味着在1.4T 标记的数据集上进行训练大约需要 21 天。2048 个 GPU * 21*24 * 1$ ~ 100w刀，这还是确定数据集和参数后一次的训练成本。
数据成本
国外诸多问答社区、社交平台纷纷加入数据收费的队伍中，如 Reddit 对每 5000 万次 API 请求收费 1.2 万美元；Twitter 推出最便宜的套餐是每月需支付 4.2 万美元，用户可以访问 5000 万条推文；
大语言模型公司 除了互联网巨头，国内外有很多的大语言模型公司，互联公司利用自身的算力、人才、数据和成熟业务优势，能够很快训练出自己的基座模型，并且在基座模型的基础上针对自身业务微调成垂类模型在业务上使用。
互联网巨头公司竞争第一咖位是生态，其次才是结合自身业务垂类应用，Meta以开源的方式吸引大批开发者，建立生态系统，不仅能让Llama2实现快速迭代，还能帮助Meta借此机会建立自己的技术壁垒，在目前的模型之争中抢占优势，构建类似Android一样的开放系统，微软的DeepSpeed、谷歌的BERT等都是以开源构建生态为目标，国内受制于人才和整个AI工具链的完善度不足，在生态系统这一竞争下已经被国外拉开差距，远远落后。
竞争的第二咖位结合自身业务垂类应用是巨头公司不得不考虑的事，将大语言模型嵌入现有产品中，以提供工具的易用性，提高客户生产力，增强产品竞争力，如微软365集成ChatGPT，github接入Copilot，百度将AI搜索接入现有引擎等等。
很多创业公司跟着风口拿到了融资，但是因自身的资金、数据和人才所限，想搞大一统的模型只会迎来毁灭，因而在搞基座模型（我并不看好)，或者在优秀的基座模型上fine-tune模型的同时，也在找应用场景、收集用户数据快速迭代，期望找到赢利点，通过fine-tune的垂类大模型落地，这瞄准的是一些小企业，他们自身条件所限而无法私有化模型，比较人力成本是很贵的，当然也可以是在toC端去尝试用户（比如情感聊天、小说写作等)，创业小公司应该紧盯着这类B端和C端的痛点和需求，避开和巨头公司的正面抗争。
还有一类企业，将数据和经验看的非常重，毕竟一个企业的核心竞争力是是私有的数据和经验，其自身经济条件虽然不足以支撑从基座模型做起，但是在巨头开源构建生态的同时，私有化部署的成本也在不断降低，比如国内的中国移动等老牌国企，这类公司更倾向于fine-tune后构建/部署自己的大模型。对他们来说构建自己构建的好处有以下几点：
1.成本，比如基于开源的大语言模型，那么比直接使用toB的服务成本将更加低廉；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fa15b2a38d400ac42f3445d23030f25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec85503da6ac61aba76f8addfc60e3a7/" rel="bookmark">
			大模型之十九-对话机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大语言模型的最早应用是Chatbot，其实我最早接触语义理解在2014年，2014年做智能音箱的时候，那时也是国内第一批做智能音箱的，在现在看起来当时的智能音箱比较傻，很多问题无法回答，长下文效果也不好，多轮对话效果就更差了，那时对话使用的主要技术是基于规则+知识图谱，所以主要还是停留在命令词识别基础上的交互，比如放音乐类、操控智能家电以及问天气等有限的几个范畴，更多的扮演的事assistent角色，开放式聊天做的并不好。
当时是设计阶段就决定了对话的上限，虽然我们当时模仿的Amazon Alexa如今“进化”出了数以万计的技能，但是相对于LLM，这些技能显得有些过时，如何将LLM接入Alex也是亚马逊不得不面临的事。
时至今日大型预训练的语言模型（如GPT、BERT等）使得对话机器人取得了显著的进展。这些模型通过在大规模文本数据上进行预训练，可以生成具有语法正确性、语义连贯性、具有记忆能力多轮对话的文本回复，除了生成自由对话回复的模型，还有一些任务导向的对话系统，如客服机器人、智能助理等。这时在运行时才会决定对话的上限，聊天机器人再次被认为是客户服务、营销和内部运营的潜在游戏规则改变者。
在训练模型的时候，常常提到模型的泛化能力，泛化能力使得模型可以高质量回复训练集中并不存在的内容，即可以将模型的训练过程看成是记忆+学习的过程，记忆是可以记住训练集中的内容，而学习就是根据训练集中的内容举一反三、触类旁通。在一个训练好的模型，如果触发高质量的记忆+学习能力以获得高质量的回复是信息获取类的核心竞争力之一。
就当前的大语言模型的产品形态而言，基于我所处的行业和工作性质认知，我认为集成大语言模型的工具类应用将是第一波享受大语言模型红利的应用场景。尽管微软基于大语言模型的代码补全github copilot还处在亏损的阶段，但是150万这一庞大的付费用户规模，已经验证了大量用户愿意为此买单，对于copilot生产代码的质量是至关重要的。
对于大语言模型可从五方面出发：数据、训练、预测推理、应用和架构，这也是AI模型开发应用过程中最核心的五大要素。本篇主要是大语言模型的对话机器人这一应用。
大语言模型的用户价值 总结来说，使用大语言模型的目的可以归为一下几类：
1.信息获取：提供及时、准确、可信的信息和答案，用户可以问问题、需求建议获取特定领域的知识，这好处在于可以快速获取信息而不需要再浏览搜索结果或者在工具间切换，突出优势是方便，这在信息爆炸的时代是非常突出的重点的，
2.娱乐和消遣：重点是消遣，这里必须突破的点是如何促进用户的多巴胺分泌，显示生活中黄赌毒都能促进大量的多巴胺分泌，同样一样东西，具有两面性，取决于人怎样使用，好比刷抖音/快手，有些人是获取知识，而有些人就是为了看不费脑子的爽图和短视频，如何在这一个过程中让用户不费脑子的消遣是产品设计的重点，但凡需要一些思考，就可能流失一部分用户，但是如果能够挖掘用户的兴趣点，比如有些小朋友喜欢脑筋急转弯，虽然费脑子，猜不中，但是小朋友却很喜欢玩，并且乐此不疲，虽然猜不中，但是总想征服下一个谜底，这个游戏的设计非常有挑战性。
3.社交互动：这是人的情感需求，需要提供的事情绪价值，高质量的共情是这个点必须突破的核心所在。这是满足人的社交需求，在一些情况下，如孤独感、需要倾诉和陪伴是，对话机器人可以提供一种无压力和包容性的交流环境。
不同用户在不同场景对于时间的看法是不一样的，对于互联网等科技工作者，在工作的时间，需要高质量的信息获取以便提升工作的产出和结果，而在下班之后的时间有些人人用来社交、有些人用来娱乐，有些人用来进修，不同的选择对于时间的价值期许是不一样的。
以高铁候车大厅为例，坐在凳子上等车的人中，约85%都盯着手机，其中以30岁左右的人比例最高，在干的事情，主要为聊天（人面对面聊天），和手机交互，和电脑pad交互（极少），吃喝、带娃以及发呆（盯着大屏或者其他场景看），手机占了90%的时间，主要使用的APP主要为微信、抖音、微博、游戏、电话、购物等这几大类，如果想要占据这些人的时间，那么娱乐类是重点。
如果是办公室的白领场景，那么这些人沟通外界的方式更多的是电脑，且在家也多有个人电脑，办公场景更多的需要高做出高质量选择，高质量的信息获取就至关重要，对于程序员、财务、律师、金融、医疗等不同的类型的白领又需要特定领域的知识。
所以在设计一个ChatBot的时候，需要想清楚服务于什么用户（核心用户），刚性需求是什么（痛点），典型的场景（什么时候用，就是你想吞噬用户什么场景的时间，是高铁候车大厅还是程序员办公室工作场景？）以及竞品优势是什么。
大语言模型现状 像GPT-4这样的LLM的出现彻底改变了聊天机器人的设计格局，这些高级模型利用人工智能来理解上下文并生成类似人类的响应。这种转变对聊天机器人设计具有重大影响。
当前各家的模型还处在初始阶段，基本上是模型即服务的状态，通过测试在模型层面上回复质量就是层次不齐的，而对于相同的模型，采用不同retrieve方法引导生成的回复，质量也是不一样的。这种retrieve方法是交互范式的改变。
很多产品将对话机器人以web主打的形式接入公司的官网或者是浏览器插件的形式提供AI功能，web仍然是构建对话机器人的最简单、最干净的方式，并提供设计对话机器人的最大自由度。围绕着的也会有各类平台的app，以增加对话机器人的触及度。
不同的场景中，用户对对自身时间价值的看法是不一样的，期望产生的价值也是不一样的，当前大一统的对话机器人并不能很好的覆盖通用的日常场景，就目前而言并不认为大语言模型会一统所有场景，比如现在吃饭会打开一个APP，购物会打开一个app，比如饿了么，现在的交互范式是我主动搜索，然后下拉一个个看评分看详细介绍，个性化并不智能，大模型可以做到更了解一个人
商业盈利当前仍不是重点，圈地是重点，但是商业化已经在流量以及会员制付费的模式上尝试，并取得了一些进展。
设计师现在可以更专注于完善聊天机器人的对话能力，在特定领域训练它，并确保它为最终用户提供价值，从而产生更具吸引力和更有效的用户体验。
信息获取类都是如此，信息的质量将是大语言模型之间竞争的核心，为了提升大语言模型的回复质量，由此引出了扩充高质量数据集、Fine-tune、RAG、联网信息获取都是在提升回复质量。
大模型进化的方向 用户将从聊天中获取怎样的价值，或者说聊天机器人给用户在什么场景提供怎样的潜在价值是是出发点，换句话说满足了了人性中哪点或哪几点，相对于本我、自我、超我的马斯洛分层模型，我更喜欢用人性劣根性的七宗罪来提炼价值。
设计对话机器人是艺术和科学的融合，结合了用户界面设计UI、用户体验UX、交互设计ID和大模型训练。是用户针对其痛点场景的第一解决方案，产品自始至终的设计都应该牢记对用户提供价值。最核心的是理解用户需求，用户是不懂技术的，让用户学习如何写好prompt的产品体验是不合理的，如果在用户不感知的情况下帮助用户生成高质量的prompt，表面上式我想要，深挖到最后，都可以归结到人性层面，所以有时候用户的问，并不是用户真正想的问题，所以挖掘背后的问并为用户写出正确的Prompt是产品设计中必须考虑的点。
从表面的形式上看，未来大模型发展的趋势如下：
1.各种插件引入，给大模型补充数据、技能，搜索、地图、财经、天气数据等；增加在数据专业性和时效性；
2.应对隐私和幻觉，隐私包括个人电话、地址相关账号登信息的泄露，也包括公司的一些文档、信息、资料等泄露，幻觉是生成可靠的回复，当前的大语言模型是可能生成实事性的错误或者捏造相关事实。
对于幻觉，当前采用如下两种方法居多。
Fine-Tuning Retrieval Augmented Generation (RAG). 3.由于部分大语言模型对话已经退出，因而当前已经收集到了海量的真实对话数据，理解机器人失败的原因仍然至关重要。分析见解不仅增强了用户体验，还揭示了聊天机器人设计中的潜在陷阱。通过研究机器人在用户旅程或对话流程中的不足之处，我们可以相应地完善和改进设计。
4.头部互联网公司继续领跑，并且在已有业务和通用对话机器人继续尝试，具有行业数据（金融、医疗、法律、软件等）将会构建行业大语言模型并司内尝试使用；
5.预计24年底到25年上半年，头部互联网通公司根据已有对话机器人收集的数据分析后，大概率会反应过来其以前的通用大模型全品类聊天注定是失败的产品，构建个人助理（类似企业高管的个人助理，只不过这里是大语言模型）大模型才是出路，并且即可可能成长为一下阿里、腾讯、字节，如果是上面三家中的一家，那么市值翻个好几倍也不在话下，个所以如何构建好个人场景的衣食住行等相关服务至关重要，这对于大公司是有优势的，比如字节跳动，旗下的抖音有电商、本地生活、休闲娱乐以及住房等多个维度的产品矩阵，当然在一两个领域里能成功已经是非常大的成功了，比如食这个领域里干掉美团，其实美团的体量很大，但是美团的壁垒并不高。
6.当前规模的大模型门槛越来越低，生态会越来越好，更多的中小公司会依靠大模型带来的能力，将企业提升一个等级，这在民营企业中最有可能出现。
7.未来大模型的规模会越来越大，涌现的能力会令人越来越吃惊，全民拥抱大模型的时代将在10年后来临，当前正处于大模型的进化、技术应用普及阶段。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f21e9019ede6801cd3d2e72c389e723/" rel="bookmark">
			OSEK-任务调度机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下图所示，在调度表中有很多 Expiry Points，下面是一个20ms的调度表。有每2.5ms触发一次2.5ms的TASK，以及等等其他按照时间的TASK触发；并且根据配置也可以看出，所有的任务都是基于全抢占模式触发的，也就是说，如果任务没有执行完，但是又更高优先级的任务进来了，此时，旧的任务将挂起，先执行新来的高优先级任务，等到高优先级任务执行完，再去执行旧的低优先级任务；但是这样触发有一个前提，第一个是两个任务都是在同一个Expiry Points点触发，此时按照全抢占模式处理。还有一个就是在达到期点 Expiry Points 时，旧的任务没有执行完，但是新的任务优先级又比较低，此时依旧会处理旧的高优先级任务，直到完成，新任务会等待下一个调度周期才会获得执行机会。除此之外，如果新的任务优先级比旧的任务的优先级高，会执行高优先级任务，旧的低优先级任务会等到下一个周期再去执行。
理解一个概念，调度表的周期性任务与alarm周期性任务，假设调度表任务的周期性与alarm任务的周期性是一致的，并且在各个周期性任务执行后，有更高优先级的周期性任务。如果到了触发时间，有高优先级的任务抢占了低优先级的任务，调度表触发的任务会将任务挂起，之后等到下一个周期在重新执行（前提条件是达到了Expiry Points），而alarm触发的任务是等高优先级任务执行完，就立即执行低优先级任务。
调度策略：
全抢占式：
非抢占式：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c07f12fea5c7ce7eb19631605fdad994/" rel="bookmark">
			Android Studio报错Caused by: org.codehaus.groovy.control.MultipleCompilationErrorsException: startup f
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上安卓Android课的时候，用自己的Android Studio打开老师发的项目文件，报错出现
Caused by: org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
和
Unsupported Java. Your build is currently configured to use Java 17.0.6 and Gradle 6.7.1.
Possible solution:
- Upgrade Gradle wrapper to 7.2 version and re-import the project
的问题，自己查阅资料百度出的解决方案，感觉挺有成就的，在这个记录一下。
1.打开新项目，选择要打开的项目，并信任此项目 2.点击“OK”(这个是程序没有在Android安装的文件中找到sdk，但是在其他地方找到了，询问受否同意打开找到的sdk) （如果下载Gradle速度过慢，可以手动下载，具体请跳转至：Android Studio手动下载Gradle文件放到指定目录_gradle下载后应该放在哪个文件夹-CSDN博客https://blog.csdn.net/u011046452/article/details/107529346
3.出现报错信息： Caused by: org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
和
Unsupported Java. Your build is currently configured to use Java 17.0.6 and Gradle 6.7.1.
Possible solution:
- Upgrade Gradle wrapper to 7.2 version and re-import the project
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c07f12fea5c7ce7eb19631605fdad994/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8955ced17084555ef896ac7e8c0e7a5/" rel="bookmark">
			安装pip install pointnet2_ops_lib/.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装这个的时候一直报错
总结原因还是版本不一致的问题，参考的博客https://blog.csdn.net/weixin_45144684/article/details/132525431
最后在这个链接里面https://anaconda.org/nvidia/cuda-toolkit成果安装11.5的粗大tookit就成功了，
最后附上所有包的版本
# Name Version Build Channel _libgcc_mutex 0.1 conda_forge defaults _openmp_mutex 4.5 2_gnu defaults argparse 1.4.0 pypi_0 pypi ca-certificates 2023.08.22 h06a4308_0 https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main certifi 2023.7.22 pypi_0 pypi charset-normalizer 3.3.1 pypi_0 pypi cuda-cccl 11.5.62 0 nvidia/label/cuda-11.5.0 cuda-command-line-tools 11.5.0 0 nvidia/label/cuda-11.5.0 cuda-compiler 11.5.0 0 nvidia/label/cuda-11.5.0 cuda-cudart 11.5.50 h79feb7f_0 nvidia/label/cuda-11.5.0 cuda-cudart-dev 11.5.50 h2215e51_0 nvidia/label/cuda-11.5.0 cuda-cuobjdump 11.5.50 h3fb44dc_0 nvidia/label/cuda-11.5.0 cuda-cupti 11.5.57 h2e3e70b_0 nvidia/label/cuda-11.5.0 cuda-cuxxfilt 11.5.50 he5660e7_0 nvidia/label/cuda-11.5.0 cuda-driver-dev 11.5.50 0 nvidia/label/cuda-11.5.0 cuda-gdb 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8955ced17084555ef896ac7e8c0e7a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44d0684b3e3af84e0bf4adc301cbfa22/" rel="bookmark">
			linux账号和权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
用户：
权限：
Linux安全模型
用户账户类型
lisi：x:1004:1004::/home/lisi:/bin/bash
useradd/usermod（添加/移除）
​编辑
passwd
文件三种权限
chmod
chown
umask
uid的类型
用户： useradd 添加用户
passwd 修改密码
usermod 修改用户属性
权限： chmod
chown
Linux安全模型 Authentication: 认证，验证用户身份
Authorization: 授权，不同的用户设置不同权限
Accouting|Audition: 审计
当用户登录成功时，系统会自动分配令牌 token，包括: 用户标识和组成员等信息
双因子验证
用户账户类型 用户的 (uid) 身份证（可以相同） 动分配Linux中每个用户是通过 Userld (UID)来唯一标识的新建普通用户1-60000超级管理员:root,0uid为0 lisi 程序用户:1-499 (CentOS 6以前)，1-999 (CentoS 7以后)不登录的用户系统默认的情况是给程序使用的对守护进程获取资源进行权限分配 普通用户: 500+ (Centos6以前)，1000+ (Centos7以后)
。超级用户 。普通用户 。程序用户
lisi：x:1004:1004::/home/lisi:/bin/bash lisi 用户名
x 密码占位符
1004 uid
1004 组id
： 备注信息
home/lisi 家目录位置
/bin/bash 默认加载shell类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44d0684b3e3af84e0bf4adc301cbfa22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c5773669596127fa2e4a367c4b4baff/" rel="bookmark">
			vue中的watch和$watch的用法实际场景和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mounted() { this.watch_WX_DialogVisible(); }, watch: { 'basicInfoData.salesPlatform'(val) { this.detailBasicInfoForm[2][0].params.advanceLabel = '店铺：' + val; this.detailBasicInfoForm[2][0].params.advanceCascade.salesPlatform = val; this.clearPrintTemplate(); if (val === 'ANNTO' &amp;&amp; this.basicInfoData.platformCarrierCode === 'SF') { this.initPrinter(); } this.$set(this.detailBasicInfoForm[2][0].params, 'advanceNotSearch', val === 'WX'); }, }, methods: { // 监听微信打印模板事件 watch_WX_DialogVisible() { this.$watch( function () { return this.$refs.detailForm.$refs.advanceIns[1].$refs.advanceDialog.dialogVisible; }, function (newval) { if (newval &amp;&amp; this.basicInfoData.salesPlatform === 'WX') { this.$set(this.$refs.detailForm.$refs.advanceIns[1].$refs.advanceDialog.searchObj, 'keyword', this.basicInfoData.platformCarrierCode || ''); this.$refs.detailForm.$refs.advanceIns[1].$refs.advanceDialog.fetchData(); } } } 1.Vue 中，$watch 是一个用于深度观察一个对象或者一个 Vue 实例属性的方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c5773669596127fa2e4a367c4b4baff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12aa0b8a631c04534826db6bf2eb2a99/" rel="bookmark">
			10-5 查询年龄18-20之间的学生信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题目要求编写SQL语句，
检索出 stu表中年龄在18-20之间的学生记录。
注意: 计算年龄时以年计算，不考虑出生月份。假定当前日期为‘2020-03-01'。
表结构: 请在这里写定义表结构的SQL语句。例如：
CREATE TABLE `stu` ( `sno` char(4) NOT NULL, `sname` char(8) NOT NULL, `sex` tinyint(1) DEFAULT NULL, `mno` char(2) DEFAULT NULL, `birdate` datetime DEFAULT NULL, `memo` text, PRIMARY KEY (`sno`) ); 表样例 请在这里给出上述表结构对应的表样例。例如
stu表：
输出样例: 请在这里给出输出样例。例如：
我的答案：
select distinct sno as ‘学号’, sname as ‘姓名’ , sex as ‘性别’, mno as ‘专业’ , YEAR('2020-03-01') - YEAR(birdate) as ‘年龄’, memo as ‘备注’ from stu where YEAR('2020-03-01') - YEAR(birdate) between 18 and 20 order by sno asc; 总结：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12aa0b8a631c04534826db6bf2eb2a99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/945243c2dfe54e084b5479c4553b2e0d/" rel="bookmark">
			Unity聚光灯、点光源无效（看上去无效）的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.检查自己的物体是否太大（比如尺寸超过100m），光源相较于物体显得特别特别小
解决方法：Unity内修改物体比例，或者建模软件中重新调好比例再导出
2.
内置渲染管线：
检查Unity编辑器内——编辑——项目设置——质量——渲染——光源对象数量限制（Pixel Light Count）
URP：
编辑器——编辑——项目设置——质量——点击渲染下的渲染管线资产——点击下方项目大纲中所跳转到的文件——查看右侧检查器——照面——每对象限制
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82b475807a5558349b1592c21e503129/" rel="bookmark">
			Linux驱动——设备注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、在虚拟总线上注册设备
二、添加设备到平台总线
一、在虚拟总线上注册设备 vim include/linux/platform_device.h” 打开“platform_device” 所在文件。
如下图所示， 就在第一页中， 就可以看到结构体“platform_device” 。
在结构体“platform_device” 中
第一个参数“name” ， 是一个字符指针， 驱动初始化前需要和注册驱动的“name” 字段匹配的参数；
第二个参数“id” ， 表示子设备编号， 一个设备如果有多个子设备号， 则需写入子设备号数量， 如果只有一个则用-1 表示；
第三个参数“device” ， 表示结构体内嵌的设备结构体； 第四个参数 num_resource， 表示设备使用的资源数组；
这些参数不一定全部使用， 在大多数驱动中， 需要写的只有设备名*name 和设备编号 id， 常用的还有资源数组*resource， 后面的参数在用到的时候再介绍。
二、添加设备到平台总线 使用命令“vim arch/arm/mach-exynos/mach-itop4412.c” ， 打开平台文件。
在上图红色方框中， 注册平台设备结构体“platform_device” 中， 只调用了两个参数“*name” 和“id”。如下图所示， 仿照着这段代码在它前面添加一个设备“hello_ctl” 。
这里还需要确认一下， 是否有“HELLO_CTL” 宏定义， 只有定义了这个宏， 在生成内核的时候才会将其编译到内核。
在 前 面 关 于 Kconfig 实 验 中 ， 已 经 添 加 了 “ HELLO_CTL ” 宏 ， 如 下 图 所 示 ， 使 用 命 令 “ vim drivers/char/Kconfig ” 打开前面定义过“HELLO_CTL” 的配置文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82b475807a5558349b1592c21e503129/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1318585d972872b4ab8be64c79f05b6/" rel="bookmark">
			【docker】数据卷：docker run和k8s同步宿主机与容器文件的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
Docker容器卷是一个特殊目录，它存放在宿主机的文件系统中，可供一个或多个容器使用。这种卷绕过了联合文件系统（Union File System），可以提供很多有用的特性。例如，对数据卷的修改会立即生效，对数据卷的更新不会影响镜像，此外，数据卷会在容器被删除后依然存在。
卷的本质是文件或者目录，其设计目的就是解决数据的持久化问题，使得数据独立于容器的生存周期。这样即使容器被删除，对应的数据文件也不会消失，从而实现了数据 persistency。
docker run：
docker run ：创建一个新的容器并运行一个命令，是将镜像放入容器并启动容器。
docker run一般需要跟几个参数，如下所示：
docker run -d -v /root/:/root/:ro -v /etc/:/etc/ -v /var/log/:/var/log/ -v /etc/localtime:/etc/localtime:ro --net=host --privileged=true --name neutron-deployment xxxxxx /bin/bash -c "while true; do ls /root ;sleep 1;done" 举个例子，前面的 /root/ 是宿主机目录，后面的 /root/ 是容器内的目录。这个命令将宿主机的 /root/ 目录挂载到容器的 /root/ 目录上，并且以只读方式（:ro）进行挂载。 之后的root目录下文件，宿主机跟容器就是双向同步了。xxxx是镜像名称，自行修改。
-i: 以交互模式运行容器，通常与 -t 同时使用；
-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；
–name: 为容器指定一个名称；
-p: 指定端口映射，格式为：主机(宿主)端口:容器端口；
-e: 设置环境变量；
-d:运行的镜像名，并返回容器ID；
但是有时候我们是用kubectl apply 来拉起镜像
在yaml中
注意下面的containers下面的 volumeMounts是容器中的目录，下面的volumes是宿主机中的目录，他们的名字name要一致，相当于也是跟docker run一样的效果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1318585d972872b4ab8be64c79f05b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc0822c3f8dd40e9a8c23d56a8578568/" rel="bookmark">
			idea使用MyBatisX插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.MyBatisX功能 (1).实现mapper和xml的跳转
(2).自动生成java文件，比如mapper、service、dao、pojo
2.安装MyBatisX插件 install后然后重启idea即可
3.使用MyBatieX实现mapper和xml跳转 （1）.点击mapper中的红色图标即可跳转到对应的xml方法
（2）.点击对应的xml中蓝色图标即可跳转到mapper方法
4.通过idea链接数据源 （1）.在idea右侧点击Database，选择数据源
（2）.输入数据源账号密码、url
（3）.配置完成后在idea右侧即可看到数据源信息
5.使用MyBatieX实现自动生成代码 （1）.在表名上面右键点击，然后点击MybatisX-Genrator
（2）.配置生成数据表对应的实体类
（3）.配置生成数据表对应的xml、service代码等，配置完后点击finish
（4）.查看生成的java代码对应的service、pojo、xml就生成了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1751ae8ddc3e05fa695037e9153d5f87/" rel="bookmark">
			Paper reading: Inject Semantic Concepts into Image Tagging for Open-Set Recognition
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过注入语义概念到图像标记（inject semantic concepts into image tagging），提出识别一切+的模型(Recognize anything plus model， RAM++), 一个具有强的开集识别能力的图像识别模型。
RAM++模型能够利用图像-标签-文本三者之间的关系，整合image-text alignment 和 image-tagging 到一个统一的交互框架里。
框架图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7def7f41afcc71f126edc4766c22dd5c/" rel="bookmark">
			org.apache.ibatis.binding.BindingException: Invalid bound statement (not found) 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)
这两天被这个报错给纠缠了很久，搜索了很多解决办法，比如：
①mapper接口方法和xml中的id要对应
②application配置文件中扫描包的路径要写对
③xml中namespace的路径要写对
…
但还是未能解决我的这个问题，今天无意间点开target文件夹，突然发现，xml所在的文件夹目录层级有问题。。定义的层级是mapper/mysql/*.xml ，所以理应显示的效果是mapper文件夹打开可看到mysql文件夹，再打开就可以看到所有xml文件，但我的target里面只有命名为mapper.mysql的包（没有实现包分层），所以就可能导致namespace里的路径和target目录当中的路径不匹配而无法解析mapper。
最终我删除对应的包，重新创建之后就可以了！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/68/">«</a>
	<span class="pagination__item pagination__item--current">69/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/70/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>