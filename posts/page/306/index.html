<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45afc6cd47a1b22c078da1ee165cd688/" rel="bookmark">
			[3]工作流框架：Flowable Restful API 一览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 在前面的两个章节中《[1]工作流框架：Flowable基本安装》和《[2]工作流框架：支持MySQL的Flowable安装》两个章节中，笔者介绍了如何安装和配置工作流引擎；配置完成后，我们就能看到Flowable的API的Swagger文档了，这个章节笔者就带大家一起领略一下Flowable工作的流暴露出来的restful API。
Flowable Restful API 总览 Flowable API总共分为下面几大类：
Process[流程]IDM[Identity Management]DMN [Decision Model and Notation]CMMN [Case Management Model and Notation]Even RegistryForm[表单]Content [内容]App [应用]External Worker [外部执行者] 如果本地通过非内存数据库部署好后，在浏览器地址栏输入： http://127.0.0.1:8080/flowable-rest/docs/?url=specfile/cmmn/flowable-swagger-cmmn.json#
之后，就可以可以到所以的工作流引擎的API的Swagger文档了！
Process API Process API应该是整个Flowable流程引擎的核心，其包括下面的部分：
IDM[Identity Management] API 主要包括和权限管理相关的API，包括组，权限，用户的管理！
DMN [Decision Model and Notation] API CMMN [Case Management Model and Notation] API Even Registry API Form[表单] Content App External Worker 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea199f2eebdf81fa2dd0be8b80dec0d0/" rel="bookmark">
			使用IntelliJ IDEA 社区版开发Android 应用安装和设置指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要开始开发Android应用程序，必须建立一个合适的开发环境。它有助于开发人员使用创建应用程序所需的工具，并确保所有操作/流程以顺畅的方式进行。IDE（集成开发环境）是一个完整的应用程序套件，提供编写和编辑源代码、构建可执行文件和调试等服务。IntelliJ IDEA是用于开发 android 应用程序的流行 IDE 之一。本文介绍了在计算机系统上安装和设置 IntelliJ IDEA IDE 的分步方法，以开始Android 应用程序开发之旅。 第 1 步：下载并安装 Oracle Java 开发工具包 (JDK) 用Java编程语言编写Android应用程序源文件，需要安装JDK 。它是一个库和编译器的集合，将在系统上运行 java 代码。访问此链接以下载与您的计算机系统兼容的 JDK 文件。不要混淆 JRE 和 JDK，两者是不同的东西，这里只要求 JDK。 第 2 步：下载并安装 Android 软件开发工具包 (SDK) Android SDK是开发 android 应用程序所需的所有软件开发工具和库的集合。SDK 工具是编写程序代码所必需的，它还有助于测试代码文件。这些特性保证了开发过程的顺利进行。要使用Android Studio以外的 IDE ，必须单独下载 Android SDK 包。 访问此链接并向下导航到“仅限命令行工具”部分。选择合适的SDK工具包，点击包名。 以下链接也可用于下载相同的内容：
视窗： https ://dl.google.com/android/repository/sdk-tools-windows-4333796.zipMacOSX：https ://dl.google.com/android/repository/sdk-tools-darwin-4333796.zipLinux： https ://dl.google.com/android/repository/sdk-tools-linux-4333796.zip 下载 SDK 工具的 zip 文件后，将内容解压到目录C:\Android\android-sdk。此外，导航到C:\Android\android-sdk\tools\bin并在该目录中打开命令提示符（在 Windows 中，清理顶部文件资源管理器栏并输入“cmd”，然后按 Enter）。
在命令提示符下，运行以下命令下载 android 包：
sdkmanager “平台;android-25” 执行此命令以更新所有内容： sdkmanager –更新
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea199f2eebdf81fa2dd0be8b80dec0d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0b6fea2a80dc612292235e61f10745a/" rel="bookmark">
			C#批量导入数据到excel表格中的实现方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.导入第三方引用
如下图所示，我引用的Microsoft.Office.Interop.Excel版本号为12.0.4518.1014，主要是为了更好的实现低版本的office
2.开始实现代码
引用部分：
using DataCollection.model;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Data.OleDb;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using log4net;
using System.IO;
using System.Web;
using Microsoft.Office.Interop.Excel;
using Application = Microsoft.Office.Interop.Excel.Application;
using System.Reflection;
其中，参数string ExcelName为已经存在的某个目录下的excel文件，例如@"D:\GDTemp\Temp2.xlsx"，int x,int y为最初实现某个单元格赋值的x,y坐标，此方法中未使用，value为给某个单元格赋值的值，此方法中未使用。
private void SetCellValue(string ExcelName,int x,int y,string value)//x行，y列
{
Application App = new Application();
object missing = Missing.Value;//获取缺少的object类型值
//打开指定的Excel文件
Workbook openwb = App.Workbooks.Open(ExcelName, missing, missing, missing, missing,
missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0b6fea2a80dc612292235e61f10745a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19ff5722ce9345e28fe44389c35d0535/" rel="bookmark">
			第十八周作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第十八周作业 1.简述keepalived工作原理2.编译安装haproxy3.总结haproxy各调度算法的实现方式及其应用场景4.使用haproxy的ACL实现基于文件后缀名的动静分离" 1.简述keepalived工作原理 Keepalived高可用对之间是通过VRRP进行通信的，VRRP是通过竞选机制来确定主备的，主的优先级高于备，因此，工作时主会优先获得所有的资源，备节点处于等待状态，当主挂了的时候，备节点就会接管主节点的资源，然后顶替主节点对外提供服务。
功能：
基于vrrp协议完成地址流动为vip地址所在的节点生成ipvs规则(在配置文件中预先定义)为ipvs集群的各RS做健康状态检测基于脚本调用接口完成脚本中定义的功能，进而影响集群事务，以此支持nginx、haproxy等服务 2.编译安装haproxy 3.总结haproxy各调度算法的实现方式及其应用场景 4.使用haproxy的ACL实现基于文件后缀名的动静分离" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84f4a99df5f3f4f3463b819641d8e120/" rel="bookmark">
			Nessus基本操作-活跃主机扫描
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 主机发现概念目的扫描类型扫描方式 主机发现---活跃主机扫描创建流程 主机发现概念 目的 通过对网络进行扫描，找出活动主机、开放端口、操作系统类型
扫描类型 Host enumeration 枚举主机
OS Identification 操作系统识别
Port scan（common ports）通用端口扫描
Port scan（all port）所有端口扫描
扫描方式 TCP（Transmission Control Protocol）传输控制协议
在Nessus中，主要使用的是TCP SYS扫描，也称为半开放扫描，这种方式不会与目标主机建立完整的连接，及完整的三次握手。
在扫描过程中，源主机向目标发送一个TCP SYN（SYS + 端口号）包请求建立连接，如果目标回应TCP SYN/ACK包，则说明目标主机正在监听扫描的端口，然后源主机会向目标发送一个RST包替换掉ACK包，断开连接，如果目标回应TCP RST包，则说明目标端口关闭。
注意：防火墙如果过滤了指定端口，则返回信息不可信
ARP（Address Resolution Protocol）地址解析协议
在Nessus中，如果目标和Nessus在同一局域网，则会自动使用ARP扫描的方式， ARP扫描会通过网络发送ARP广播，如果目标回应则说明目标存在，反之不存在。
注意：因发送的是广播包，所以可能存在用户实施欺骗，造成ARP攻击。
ICMP（Internet Control Message Protocol，Internet控制报文协议）
在Nessus中，ICMP扫描方式是通过向目标发送ICMP echo请求来实现主机发现的，如果收到目标返回的echo响应，则说明主机在线，反之不在线。
注意：防火墙如果过滤了ICMP协议，则返回信息不可信
主机发现—活跃主机扫描 创建流程 Scans—New Scan—Host Discovery—配置BASIC General—DISCOVERY Scan Type选择Host enumeration—Save—Launch
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e09f5c7d09d23203712162d170f3290/" rel="bookmark">
			C&#43;&#43;中vector容器的常见用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、关于vector vector是一个动态的序列容器，相当于一个size可变的数组。相比于数组，vector会消耗更多的内存以有效的动态增长。vector能更快的索引元素(就像数组一样)，而且能相对高效的在尾部插入和删除元素。
当需要使用vector的时候，需要包含头文件：#include &lt;vector&gt;，一般加上using namespace std;
如果不加，则在调用时候必须用std::vector&lt;...&gt;这样的形式，即在vector前加上std::，这表示运用的是std命名空间下的vector容器。
二、常见用法(以int类型为例) 1.声明及初始化
vector&lt;int&gt; a; //声明一个int型向量a vector&lt;int&gt; a(10); //声明一个初始大小为10的向量 vector&lt;int&gt; a(10, 1); //声明一个初始大小为10且初始值都为1的向量 vector&lt;int&gt; b(a); //声明并用向量a初始化向量b vector&lt;int&gt; b(a.begin(), a.begin()+3); //将a向量中从第0个到第2个(共3个)作为向量b的初始值 int n[] = {1, 2, 3, 4, 5}; vector&lt;int&gt; a(n, n+5); //将数组n的前5个元素作为向量a的初值 vector&lt;int&gt; a(&amp;n[1], &amp;n[4]); //将n[1] - n[4]范围内的元素作为向量a的初值 2.添加元素
vector&lt;int&gt; a; a.push_back(1); //在尾部加入一个数据 a.push_back(2); a.pop_back(); //删除最后一个数据 a.insert(a.begin(), 0); //在a.begin()之前加入0 a.erase(a.begin()); //将a.begin()的元素删除 a.erase(a.begin() + 1, a.end()); //将第二个元素以后的元素均删除 3.判断vector是否为空
vector&lt;int&gt; a; if(a.empty()){ a.push_back(1); } 4.遍历访问vector
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e09f5c7d09d23203712162d170f3290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e9564324ace24e7e66055944f63bbea/" rel="bookmark">
			如果 __name__ == ‘__main__‘: 在 Python 中做什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是什么if __name__ = '__main__'意思？
您有时可以在Python脚本中看到这一点，通常这是您的 Python 程序开始的地方。
在许多其他语言中，计算机程序以 main() 函数开始。在 Python 中也是如此。
主要价值 让我们做一个快速练习，以掌握 main 函数和if 语句的细节。
&lt;span style="color:var(--syntax-text-color)"&gt;&lt;span style="color:var(--syntax-text-color)"&gt;&lt;code&gt;&lt;span style="color:var(--syntax-declaration-color)"&gt;print&lt;/span&gt;&lt;span style="color:var(--syntax-text-color)"&gt;(&lt;/span&gt;&lt;span style="color:var(--syntax-string-color)"&gt;"module_name :{}"&lt;/span&gt;&lt;span style="color:var(--syntax-text-color)"&gt;.&lt;/span&gt;&lt;span style="color:var(--syntax-text-color)"&gt;format&lt;/span&gt;&lt;span style="color:var(--syntax-text-color)"&gt;(&lt;/span&gt;&lt;span style="color:var(--syntax-text-color)"&gt;__name__&lt;/span&gt;&lt;span style="color:var(--syntax-text-color)"&gt;))&lt;/span&gt; &lt;/code&gt;&lt;/span&gt;&lt;/span&gt; 运行 Python文件并将文件作为 python3 脚本执行
此示例中应用程序的结果表明变量名称具有主值。
&lt;span style="color:var(--syntax-text-color)"&gt;&lt;span style="color:var(--syntax-text-color)"&gt;&lt;code&gt;&lt;span style="color:var(--syntax-error-color)"&gt;&gt;&gt;&gt;&lt;/span&gt; &lt;span style="color:var(--syntax-declaration-color)"&gt;print&lt;/span&gt;&lt;span style="color:var(--syntax-text-color)"&gt;(&lt;/span&gt;&lt;span style="color:var(--syntax-string-color)"&gt;"module_name :{}"&lt;/span&gt;&lt;span style="color:var(--syntax-text-color)"&gt;.&lt;/span&gt;&lt;span style="color:var(--syntax-text-color)"&gt;format&lt;/span&gt;&lt;span style="color:var(--syntax-text-color)"&gt;(&lt;/span&gt;&lt;span style="color:var(--syntax-text-color)"&gt;__name__&lt;/span&gt;&lt;span style="color:var(--syntax-text-color)"&gt;))&lt;/span&gt; &lt;span style="color:var(--syntax-text-color)"&gt;module_name&lt;/span&gt; &lt;span style="color:var(--syntax-text-color)"&gt;:&lt;/span&gt;&lt;span style="color:var(--syntax-text-color)"&gt;__main__&lt;/span&gt; &lt;/code&gt;&lt;/span&gt;&lt;/span&gt; 那么这个主要是什么？
if name == " main ": 怎么办？ 测试上述条件时，必须验证该文件是直接由python运行还是由python导入。
解释证明了这一点。
&lt;span style="color:var(--syntax-text-color)"&gt;&lt;span style="color:var(--syntax-text-color)"&gt;&lt;code&gt; &lt;span style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e9564324ace24e7e66055944f63bbea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/443bbda7e8687c43ef5686cf9eef21da/" rel="bookmark">
			Linux C/C&#43;&#43; 实现HTTP请求器（TCP客户端）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到别爱的CSDN
文章目录 前言一、HTTP是什么？二、具体实现（全部代码）总结参考资料 前言 提示：以下是本篇文章正文内容，下面案例可供参考
一、HTTP是什么？ HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网
（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。HTTP 是一个基于
TCP/IP 通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。
工作原理：
HTTP 协议工作于客户端-服务端架构上。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端
即 WEB 服务器发送所有请求。
Web 服务器有：Apache 服务器，IIS 服务器（Internet Information Services）等。
Web 服务器根据接收到的请求后，向客户端发送响应信息。
HTTP 默认端口号为 80，但是你也可以改为 8080 或者其他端口。
客户端请求消息一般格式
二、具体实现（全部代码） 代码如下（示例）：
#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; #include&lt;sys/socket.h&gt; #include&lt;netinet/in.h&gt; #include&lt;arpa/inet.h&gt; #include&lt;unistd.h&gt; #include&lt;netdb.h&gt; #include&lt;fcntl.h&gt; #define HTTP_VERSION	"HTTP/1.1" #define	CONNETION_TYPE "Connection: close\r\n" #define BUFFER_SIZE	4096	char* host_to_ip(const char* hostname) { struct hostent* host_entry = gethostbyname(hostname);//dns //14.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/443bbda7e8687c43ef5686cf9eef21da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/514b1b8ddf8dcab1eb9ccde1877ba070/" rel="bookmark">
			如何搭建C语言环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下文章来源于：公_众_号开源电子网
读取更多技术文章，请扫码关注
如何搭建C语言环境 前言 C语言作为嵌入式开发的必备掌握技能，嵌入式能力的提升速度很大程度在于C语言的掌握能力。正所谓：工欲善其事，必先利其器。学习C语言，第一件动手的事情就是搭建环境了。现在很多人都用VS Code去编程，C语言也可以开发，之前推文也有VScode搭建C语言环境的推文。VS Code开发C语言局限性在于不能调试代码，所以在这里我们介绍CodeBlocks软件作为开发C语言的软件。
在本推文附件中有CodeBlock 17.12安装软件，这里搭建的环境为Win10 64位，建议大家最好都使用Windows系统的电脑来搭建，不管是Win7还是Win8等，操作步骤都一样。
软件包链接：https://pan.baidu.com/s/17fNojKbt0AQZN_99anK9EA
提取码：voo1
1.CodeBlocks下载 下载链接为: http://www.codeblocks.org/downloads/26
打开链接之后,选择下载codeblocks-17.12mingw-setup.exe文件,如下图所示。
（当然，现在版本会有更新的，看自己选择）
2. 软件安装 安装过程也很简单,就是一路Next的操作,我这里准备把其安装到我的D:\baseSoftware目录下。
直接双击codeblocks-17.12mingw-setup.exe文件，弹出如下对话框：
直接点击Next,接着进入到如下界面:
直接点击I Agree按钮即可,接着进入到如下界面:
什么都不要去动,直接点击Next按钮,接着进入到如下界面
在这里,请根据自己的需求,选择合适的安装路径,选择好之后,直接点击Install按钮进行安装,接下来就是等此软件安装完成,在安装过程中,会弹出对话框询问我们,是否立即启动CodeBlocks,我们先选择否即可,最后软件安装完成之后,如下图所示:
接着点击Next按钮,最后再点击Finish按钮结束安装。
3. 软件使用 接下来,我们需要打开CodeBlock软件来新建工程了,初次打开CodeBlock软件,会弹出如下界面:
当看到这个界面时,不要惊慌,这是在自动检测编译器,我们直接点击OK按钮即可.打开软件之后,点击菜单栏左上角的File-&gt;New-&gt;Project…来弹出项目新建向导,我们选择Console应用,如下图所示:
在这里插入图片描述
接着点击Go按钮,又会弹到另外一个对话框,点击Next按钮,接着进入到语言选择对话框,如下图所示:
在这里插入图片描述
这里我们选择C语言,然后再点击Next按钮,又会进入到项目信息输入对话框,如下图所示:
这里我们把项目名输入为hello_world,然后选择项目的存放路径到HelloWorld目录下,最后就是一路的Next操作来完成项目的创建.项目创建完成之后,默认只有一个main.c文件,如下图所示:
这个软件真好，直接帮我们生成了helloworld代码，那我们就可以迎来了我们的第一次编译,我们点击 图标来编译（或者Ctrl+F9）。
正常情况如下：
故意犯错如下：
最终弹出一个窗口显示“Hello world!”，即printf打印的内容。
当你发现重新编译运行，不显示打印信息，错误码为4258096，那么你可以用管理员身份重新打开软件，编译运行即可。
最后介绍CodeBlock调试功能的配置使用。
调试代码是编程能力的重要组成部分。鼠标电机菜单栏上的红色三角形或者快捷键F8进入调试模式。也许你会出现以下错误提示。
这个错误是说你没有安装调试需要的工具“GDB”或“MSVC”。我们选择安装“GDB”。
首先，我们要在系统中安装MinGW,安装方法很简单，这里我们提供安装包给大家。
安装好之后，打开菜单“Settings -&gt; Debugger…”,进入如下界面。
点击“Excutable path”后面的路径按钮，进入刚安装的MinGW下的bin目录，选择gdb.exe。点击“OK”
此时，再此按F8,成果进入调试模式。在下方的Debugger窗口中，会打印调试过程的日志信息。
快捷键是提高编程效率的神器，这里也把CodeBlocks的基本快捷键附上。
Ctrl+Shift+C：注释掉当前行或选中块
Ctrl+Shift+X：解除注释
Tab：缩进当前行或选中块
Shift+Tab：减少缩进按住
Ctrl，滚动鼠标滚轮，放大或缩小字体编译与运行部分
Ctrl + F9：编译
Ctrl + F10：运行上次成功编译后的程序
Ctrl +　Shift + F9:编译当前文件（而不是当前打开的工程项目）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/514b1b8ddf8dcab1eb9ccde1877ba070/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/741de92544e7118100f0353daab79b62/" rel="bookmark">
			QtAV 播放rtsp视频流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT | 聊聊QT与直播流播放——从QMediaPlayer到Qt-AV - Oliver-cs - 博客园
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2bcd7b3f58a6d23dece709f5be870a7/" rel="bookmark">
			STL详解（很全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概述
STL六大组件简介 三大组件介绍
1.容器
2.算法
3.迭代器 常用容器
1. string容器
string容器基本概念
string容器常用操作 2. vector容器
vector容器基本概念
vector迭代器
vector的数据结构
vector常用API操作
3. deque容器
deque容器基本概念 deque容器实现原理
deque常用API
4. stack容器
stack容器基本概念
stack没有迭代器
stack常用API
5. queue容器
queue容器基本概念
queue没有迭代器
queue常用API 6. list容器
list容器基本概念
list容器的迭代器 list容器的数据结构
list常用API
7. set/multiset容器
set容器基本概念
multiset容器基本概念
set常用API 对组(pair)
8. map/multimap容器
map/multimap基本概念 map/multimap常用API
STL容器使用时机
概述 长久以来，软件界一直希望建立一种可重复利用的东西，以及一种得以制造出”可重复运用的东西”的方法，从函数(functions)，类别(classes),函数库(function libraries),类别库(class libraries)、各种组件，从模块化设计，到面向对象(object oriented )，为的就是复用性的提升。
复用性必须建立在某种标准之上。但是在许多环境下，就连软件开发最基本的数据结构(data structures) 和算法(algorithm)都未能有一套标准。大量程序员被迫从事大量重复的工作，竟然是为了完成前人已经完成而自己手上并未拥有的程序代码，这不仅是人力资源的浪费，也是挫折与痛苦的来源。
为了建立数据结构和算法的一套标准，并且降低他们之间的耦合关系，以提升各自的独立性、弹性、交互操作性(相互合作性,interoperability),诞生了STL。
STL(Standard Template Library,标准模板库)，是惠普实验室开发的一系列软件的统称。现在主要出现在 c++中，但是在引入 c++之前该技术已经存在很长时间了。
STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2bcd7b3f58a6d23dece709f5be870a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fd57b202dc466bf22af5865d9bce952/" rel="bookmark">
			[Java 一道简单的排序题]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一次考试中，每个学生的成绩都不相同，现知道了每个学生的学号和成绩，求考第k名学生的学号和成绩。
第一行有两个整数，分别是学生的人数n（1≤n≤100）n（1≤n≤100），和求第k名学生的k（1≤k≤n）k（1≤k≤n）。
其后有nn行数据，每行包括一个学号（整数）和一个成绩（浮点数），中间用一个空格分隔。
其实这道题就是复习一下，排序输出。
```Java import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n =sc.nextInt(); int index =sc.nextInt(); int [] number =new int[n]; double [] score =new double[n]; for (int i = 0; i &lt; number.length; i++) { number[i] =sc.nextInt(); score[i] =sc.nextDouble(); } for (int i = 0; i &lt; score.length-1; i++) { for (int j = 0; j &lt; score.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fd57b202dc466bf22af5865d9bce952/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/237d7e0239b442c199be83595182a11f/" rel="bookmark">
			PEmicro GDB Launch Failure : Could not bind socket.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：今天使用NXP的S32D编译工程后，使用PE工具下载时，报一下错误：
PEmicro GDB Launch Failure : Could not bind socket. Address and port are already in use. Another GDB Server debug session may be using the same Server Port number. To run simultaneous debug sessions, please specify a unique Server Port and GDBMI Port in the Debug Configuration for each project. If another session is not running simultaneously, make sure that the chosen port is available and that pegdbserver_console and the arm-none-eabi-gdb processes have terminated.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/237d7e0239b442c199be83595182a11f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1358e6c01b4e3a52f7d9afb953f58a9e/" rel="bookmark">
			linux驱动开发-platform_get_resource函数实现细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先暂存：
http://blog.sina.com.cn/s/blog_636a55070101mced.html
https://www.cnblogs.com/sky-heaven/p/4800848.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/939cf06f6eb0f44a0347be14c9729afa/" rel="bookmark">
			二分——切绳子(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述： 有 n 条绳子，它们的长度分别为 Li，如果从它们中切割出 m 条长度相同的绳子，这 m 条绳子每条最长能有多长？
输入格式： 第一行两个整数 n和 m。
接下来 n行，每行一个实数，描述了每条绳子的长度 Li。
数据范围：1&lt;=n&lt;m&lt;=10000;1&lt;=Li&lt;=100000.
输出格式： 切割后每条绳子的最大长度，保留 6位小数。
实例： 输入：
4 11 8.02 7.43 4.57 5.39 输出：
2.00 解题思路： 从n条绳子里切割，最长切割出来也应该是n条中最长的那个max，所以根据二分的思想，切割后每条绳子的左右边界分别是0，max。然后根据这个先取一个假定的mid，在区间里找到能满足切割条数为m的最大长度。
参考代码： #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int N = 1001; double a[N]; int n, m; double ans; int check(int k) { int count = 0; for(int i=0;i&lt;n;i++) { count += a[i] / k;//这个绳长可以得到几个 } if (count&gt;=m)//如果可以达到需求 return 1; else return 0; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) { double t; cin &gt;&gt; t; a[i] = 100 * t;//将绳长都变成整数值，结果除以100.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/939cf06f6eb0f44a0347be14c9729afa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58593116c8859336712d30de68db7404/" rel="bookmark">
			C语言中的【常量】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【常量】 “常量”的广义概念是：‘不变化的量’。例如：在计算机程序运行时，不会被程序修改的量。
以上是百度百科上对常量的部分定义。C语言的学习过程中将会接触很多的常量，不同类型的常量其定义、用法等会有所差异。要搞清楚他们的相似与不同是能熟练掌握他们的必要条件哦~
以下是对C语言常量的一些简单的整理介绍。
【分类】 C语言中常量大致可以分成：
字面常量 如整数常量、浮点常量、字符常量（单引号中的）、字符串常量（双引号中的）
const修饰的常变量 定义格式为
const + 数据类型 + 名称 = 值
比如：const int a = 5;
*常变量的值在初始化后不能改变其值，这体现了它的常量的特性。在一定情况下又能体现其变量的特性，如定义数组时，数组大小不能使用常变量来定义。如 int arr[10] = {0};这样的定义是对的，但const int n = 10;int arr[n] = {0};则不行。
#define定义的标识符常量 格式为
#define + 名称 + 值
如： # define PI 3.14
一般写在函数外面与#include写在一起。这种定义不需要加“=”哦！
枚举常量 格式为
enum + 名称{符号变量a,符号变量b,符号变量c,...}；
如：enum WEEK {Mon,Tue,Wed,Thu,Fri,Sat,Sun};
第一个枚举值代表0，第二个代表1，以此类推，依次增加1。也可以自定义其中的值enum WEEK {Mon=1,Tue,Wed,Thu,Fri,Sat,Sun};这样就可以做到星期几的值就是几。
【特性】 常量在定义之后不能修改。
这就是关于c语言常量的介绍啦！这里有一个网址值得推荐一下，可以帮助补充理解~
C 常量 | 菜鸟教程 (runoob.com)
欢迎交流讨论~一起加油！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21787dc858183cabe812440031c09b36/" rel="bookmark">
			人脸检测常见方式---视频，图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人脸检测常见方式---视频，图片 前言一、opencv是什么？二、人脸检测---摄像头版1.引入库2.具体代码3.解析2.具体代码3.解析4.结果展示 总结 前言 寒假放假了，在家太无聊。学着写个人脸检测玩玩。。
提示：以下是本篇文章正文内容，下面案例可供参考
一、opencv是什么？ OpenCV的全称是Open Source Computer Vision Library，是一个跨平台的计算机视觉库。OpenCV是由英特尔公司发起并参与开发，以BSD许可证授权发行，可以在商业和研究领域中免费使用。OpenCV可用于开发实时的图像处理、计算机视觉以及模式识别程序。该程序库也可以使用英特尔公司的IPP进行加速处理。
总而言之，我们需要用到opencv里面的库进行人脸检测。另外，如果你没有安装，还需要先安装。
conda install opencv-python 二、人脸检测—摄像头版 1.引入库 代码如下：
import cv2 2.具体代码 代码如下：
import cv2 #人脸检测---摄像头版 def video_demo(): capture=cv2.VideoCapture(0) #参数为0，表示默认摄像头 while(True): #读取摄像头里的内容 ret,frame=capture.read() #返回ret和frame，ret表示有没有抓取到图片，frame代表一帧图片 frame=cv2.flip(frame,1) #对图像进行翻转，0代表垂直，1代表水平，-1代表垂直水平 #显示每一帧 face_patterns=cv2.CascadeClassifier('.\cascades\haarcascade_frontalface_alt.xml') #是一个分类器，有haar和lbp两种特征；自带人脸检测器 #人脸检测函数，frame是图片，scaleFactor表示从minSize开始，每次窗口扩大10%知道默认最大值；minNeighbor表示一个物体最少多少标记认为是人脸 faces=face_patterns.detectMultiScale(frame,scaleFactor=1.1,minNeighbors=4,minSize=(100,100)) #返回值为左上角坐标以及长和宽 print(faces) for(x,y,w,h) in faces: cv2.rectangle(frame,(x,y),(x+w,y+h),(0,255,0),2) #在图像上绘制矩形 (x,y)左上坐标,(x+w,y+h)右下坐标，(0,255,0)颜色，2矩阵厚度 cv2.imshow("jiemain",frame) #图形界面一闪而过 c = cv2.waitKey(1) # 延迟，来保证图片显示 if c == 27: break video_demo() 3.解析 face_patterns=cv2.CascadeClassifier('.\cascades\haarcascade_frontalface_alt.xml') #是一个分类器，有haar和lbp两种特征；自带人脸检测器 opencv中有一个分类器CascadeClassifier，在这个分类器里面有很多已经训练好的检测模型，不仅有关于脸的，还有鼻子，眼睛，身体等等。(在文章结尾附上链接)
faces=face_patterns.detectMultiScale(frame,scaleFactor=1.1,minNeighbors=4,minSize=(100,100)) detectMultiScale是分类下的一个检测器，里面的参数以及返回结果会稍微难懂一点，但是不用担心我会尽可能简单描述出来。
frame：代表要检测的图片；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21787dc858183cabe812440031c09b36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5210c69253123c5adce51c0bbc22973a/" rel="bookmark">
			Python数据分析常用的类库matlab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NumPy
NumPy（Numerical Python）是Python科学计算的基础包，它可以提供以下功能。
■ 快速高效的多维数组对象ndarray。
■ 用于对数组执行元素级计算和直接对数组执行数学运算的函数。
■ 用于读写硬盘上基于数组的数据集的工具。
■ 线性代数运算、傅里叶变换，以及随机数生成。
■ 用于将C、C++、Fortran代码集成到Python的工具。
除了为Python提供快速的数组处理能力，NumPy在数据分析方面还有另外一个主要作用，即作为算法之间传递数据的容器。对于数值型数据，NumPy数组在存储和处理数据时要比内置的Python数据结构高效得多。此外，由高级语言（如C和Fortran）编写的库可以直接操作NumPy数组中的数据，无须进行任何数据复制工作。
pandas是Python数据分析的核心库，它是基于NumPy构建的含有复杂数据结构和工具的数据分析包。pandas最初是被作为金融数据分析工具而开发出来的，因此，它为时间序列分析提供了很好的支持。pandas纳入大量库和标准数据模型，提供了大量的可快速便捷处理数据的函数和高效操作数据集所需的工具。
类似于NumPy的核心是ndarray，pandas则是围绕着Series和DataFrame这两个核心数据结构展开的，而Series和DataFrame分别对应于一维的序列和二维的表结构。pandas提供了复杂精细的索引功能，以便快捷地完成重塑、切片、聚合和选取数据子集等操作。
Matplotlib
Matplotlib是最流行的用于绘制数据图表的Python库，它非常适合创建出版物中用的图表。Matplotlib提供了一整套与MATLAB相似的命令API，十分适合交互式地进行制图，而且也可以方便地将它作为绘图控件，嵌入GUI应用程序中。通过Matplotlib的pyplot子库提供的与MATLAB类似的绘图API，可方便用户快速绘制2D图表，例如直方图、条形图、散点图等。
Matplotlib还提供了名为pylab的模块，其中包括了许多NumPy和pyplot中常用的函数，方便用户快速进行计算和绘图。Matplotlib与IPython结合提供了一个非常好的交互式数据绘图环境，绘制的图表也是交互式的，用户可以利用绘图窗口工具栏中的相应工具放大图表的某个区域，或对某个图表进行平移浏览。
SciPy
SciPy是一组专门用于科学计算的开源Python库，它构建于NumPy的基础上，提供了一个用于在Python中进行科学计算的工具集。SciPy经常与NumPy、pandas、Matplotlib和IPython这些核心库一起使用，SciPy主要包括8个包，这些包分别对应着不同的科学计算领域，SciPy主要包括的包见表。
scikit-learn
scikit-learn是一个简单有效的数据挖掘和数据分析工具，可供用户在各种环境下重复使用，而且scikit-learn是建立在NumPy、SciPy和Matplotlib的基础上的，对一些常用的算法进行了封装。scikit-learn的基本功能主要分为六大部分：分类、回归、聚类、数据降维、模型选择和数据预处理。在数据量不大的情况下，scikit-learn可以解决大部分问题。对算法不精通的用户在执行建模任务时，并不需要自行编写所有算法，只需要简单地调用scikit-learn库里的模块就可以了。6. IPython
IPython是Python科学计算标准工具集的组成部分，它为交互式和探索式计算提供了一个高效的开发环境。它是一个增强的Pythonshell，目的是提高编写、测试、调试Python代码的速度，主要用于交互式数据处理和利用Matplotlib对数据进行可视化处理。除了标准的基本终端的Pythonshell外，该项目还提供了如下功能。
■ 一个类似于Mathematica的数据分析型软件，具有Notebook编辑窗口，即通过Web浏览器连接IPython。
■ 一个基于Qt框架的GUI控制台，其中含有绘图、多行编辑和语法高亮显示等功能。
■ 用于交互式并行和分布式计算的基本框架。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba7e69e2af50bf8dda1999840682f965/" rel="bookmark">
			安装python3.10.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载python3.10.1 1.百度搜索Python,找到Python官网,点击进入也可以点击下面链接，直接跳转 Pyhton官网
2.点击Downloads，选择windows,进入版本界面 3.点击红点进入下载界面，这里列出了不同版本的Python3.10.1，我们选择对应自己win的版本下载即可 二、安装Python3.10.1 1.打开在浏览器中下载好的安装包，将下方两个选项打勾，然后下一步 2.将Install for all users选项打钩,其他的选项保持默认,这里可以点击Browse,根据自己的需求选择安装目录，确认好位置点击install安装 3.进度条完成,会显示下面的菜单,表示已经安装成功了,现在点击Close即可,Python3.10.1已经安装成功了 三、验证安装结果 1.在计算机“开始”菜单栏中搜索“python”,找到并单击打开“Python3.10（64-bit）”项目。 2.也可以“win+R”再输入“cmd”打开控制台窗口,在控制台中国执行“python”命令进入Python环境 使用quit()、exit()命令或组合键“Ctrl+Z”可退出Python环境，亦可以直接关闭控制台窗口或Python解释器窗口以退出Python环境
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ea847ff3e4d8a02b16d45543b27ad45/" rel="bookmark">
			linux elasticsearch 7 启动失败 Killed ES_JVM_OPTS 参数调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Intro./config/jvm.options 修改 elasticsearch 启动的内存参数 Intro 阿里云 Ubuntu 20
1核1GB的ECS(Elastic Compute Service 弹性计算服务)。
JDK环境已经配置好。
试图启动 elasticsearch 7.16.2
可是会报错：
/opt/elasticsearch-7.16.2$ ./bin/elasticsearch warning: usage of JAVA_HOME is deprecated, use ES_JAVA_HOME Future versions of Elasticsearch will require Java 11; your Java version from [/opt/jdk1.8.0_181/jre] does not meet this requirement. Consider switching to a distribution of Elasticsearch with a bundled JDK. If you are already using a distribution with a bundled JDK, ensure the JAVA_HOME environment variable is not set.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ea847ff3e4d8a02b16d45543b27ad45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7e35a2eb99ac753ac4c9146f266b550/" rel="bookmark">
			通俗地解释为什么Java中接口的成员变量必须用static final 修饰
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先上一段Java接口的代码 public interface MyAInterface{ public static final int NAME = "zhangsan"; public abstract void show(); } 然后解释成员变量为什么必须是static final修饰的常量呢？ static
必须。因为接口是可以多继承的。如果一个类实现了两个接口，且两个接口都具有相同名字的变量，此时这个变量可以被实现类使用，那么如果不是static的，这个变量来自哪一个接口就会产生歧义，所以实现类使用接口中的变量必须通过接口名指定，也就只能定为static的。
看下面的例子：
public interface iface1 { int a = 10; } public interface iface2 { int a = 9; } public class impl implements iface1, iface2 { public static void main(String args[]){ System.out.println(a); } } 此时，会报编译错误，因为a有歧义。
final
既然必须是static修饰的，那么所有子类共享。而接口是一种抽象， 所以一个子类修改了值会影响到其他所有子类，因此就不应该允许子类修改这个值，所以也必须定义为final。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4e38fcf9ed5ed0a6fd62aa65fe91ee5/" rel="bookmark">
			使用Apache Commons CSV工具将List＜Map＜String,Object＞＞写入csv并保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求如题
源数据类型：List&lt;Map&lt;String,String&gt;&gt;或者List&lt;Map&lt;String,Object&gt;&gt;
想将这样的数据写入csv并保存到某个位置
方法：
借助Apache Commons CSV工具来转换
1、引入依赖
&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-csv&lt;/artifactId&gt; &lt;version&gt;1.9.0&lt;/version&gt; &lt;/dependency&gt; 2、list2csv函数
其中涉及到Apache Commons CSV的操作参考了https://www.baeldung.com/apache-commons-csv
/** * @Description: convert list&lt;Map&lt;&gt;&gt; to csv * @Param: list&lt;Map&lt;&gt;&gt;,pathName * @return: */ public void list2csv(List&lt;Map&lt;String,String&gt;&gt; list,String pathName) throws IOException { List&lt;String&gt; headerList = new ArrayList&lt;&gt;(); for (String s : list.get(0).keySet()) { headerList.add(s); } String[] csvHeader = headerList.toArray(new String[headerList.size()]); FileWriter out = new FileWriter(pathName); //要写入的位置 如D:/test.csv try (CSVPrinter printer = new CSVPrinter(out, CSVFormat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4e38fcf9ed5ed0a6fd62aa65fe91ee5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b5f131fa3ca07d904a636c8aabee1c0/" rel="bookmark">
			【正点原子FPGA连载】 第三十一章 交通灯实验-摘自【正点原子】领航者ZYNQ之FPGA开发指南_V2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）实验平台：正点原子领航者ZYNQ开发板
2）平台购买地址：https://item.taobao.com/item.htm?&amp;id=606160108761
3）全套实验源码+手册+视频下载地址：http://www.openedv.com/thread-301505-1-1.html
4）对正点原子FPGA感兴趣的同学可以加群讨论：994244016
5）关注正点原子公众号，获取最新资料更新
第三十一章 交通灯实验 交通信号灯是一种生活中非常常见的公共设施，它在马路上的路口、斑马线等位置起着疏导交通的作用，本章我们将使用交通信号灯模块来再现它的功能。
本章包括以下几个部分：
1.1 简介
1.2 实验任务
1.3 硬件设计
1.4 程序设计
1.5 下载验证
1.1 简介
交通信号灯往往由红、绿、黄三种颜色的灯组成。红灯亮的时候，禁止通行；绿灯亮的时候，可以通行；黄灯亮的时候，提示通行时间已经结束，马上要转换为红灯。
本次实验要再现的交通信号灯为十字路口处的信号灯，它由两对信号灯组成。信号灯实物如图 7.5.13.1所示：
图 7.5.13.1 交通信号灯
图 7.5.13.2为十字路口交通信号灯简化示意图：
图 7.5.13.2 十字路口信号灯示意图
单独一个方向上的信号灯点亮顺序是：红灯熄灭后绿灯亮，绿灯熄灭后黄灯亮，黄灯熄灭后红灯亮，这样一直循环下去。另外，同一方向上的一对信号灯亮的颜色一致，且显示的时间是一样的。
为了模拟交通信号灯的功能，制作了表 31.1.1信号灯状态转换表：
表 31.1.1 交通信号灯状态转换表
表 31.1.1中，设定一个周期内，红灯发光30s，绿灯发光27s，黄灯发光3s。以东西方向信号灯状态为例，红灯发光的时间等于黄灯与绿灯发光的时间和。所以一个完整的状态转换周期是红灯发光的时间的两倍，也就是60s。
在东西方向红色信号灯发光的30s内，南北方向由绿灯切换到了黄灯；在南北方向红色信号灯发光的30s内，东西方向也由绿灯切换到了黄灯。因此我们将东西和南北方向信号灯同时保持在固定状态的时间段，划为一个状态。由此产生了循环往复的4个状态：
1、东西方向红灯亮27s，南北方向绿灯亮27s，然后切换到状态2；
2、东西方向红灯亮3s，南北方向黄灯亮3s，然后切换到状态3；
3、东西方向绿灯亮27s，南北方向红灯亮27s，然后切换到状态4；
4、东西方向黄灯亮3s，南北方向红灯亮3s，然后切换到状态1。
如图 7.5.13.3为交通信号灯的状态转换图：
图 7.5.13.3 交通信号灯状态转换图
另外，以东西方向为例：一个周期内，红灯发光30s，绿灯发光27s，黄灯发光3s。那么在红灯发光期间，数码管上显示的数字要从29递减到0；同理，绿灯发光期间，数码管上显示的数字要从26递减到0；黄灯发光的时候，数码管上显示的数字要从2递减到0。
1.2 实验任务
本节实验任务是通过领航者ZYNQ开发板和外接的交通信号灯扩展模块，再现交通信号灯的功能。
1.3 硬件设计
我们的领航者ZYNQ开发板上左边的J3扩展口可以用来外接交通信号灯扩展模块，交通信号灯扩展模块的原理图如图 7.5.13.1所示。
图 7.5.13.1 交通信号灯原理图
由上图可知，交通信号灯扩展模块四个方向共12个LED灯，而我们使用6个LED控制信号来驱动12个LED灯，这是因为东西方向或者南北方向LED灯的亮灭状态总是一致的，所以我们将东西方向或者南北方向颜色相同的LED灯并联在一起，这样设计的好处是减少了交通信号灯扩展模块LED控制信号的引脚。
上图中四个共阳型数码管分别对应四个路口，每个路口用两位数码管显示当前状态的剩余时间。我们知道，在十字路口中，东西方向或者南北方向数码管显示的时间总是一样的。以东西方向为例，正因为这两个方向显示的时间一致，所以这两个方向的数码管，它们的十位可以用同一个位选信号来控制，个位用另一个位选信号来控制，这样的话，就可以实现两个位选信号控制东西方向共4位数码管的亮灭，南北方向的数码管同理。这样设计的好处是减少了交通信号灯扩展模块位选信号的引脚。
需要注意的是，数码管由PNP型三极管驱动，当三极管的基极为低电平时，数码管相应的位被选通，所以交通信号灯扩展模块的位选信号是低电平有效的。
交通信号灯实物图如图 7.5.13.2所示，我们本章实验设定交通信号灯的方向为上北下南，左西右东。
图 7.5.13.2 交通信号灯实物图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b5f131fa3ca07d904a636c8aabee1c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46b2a5e0c91df4e944713f80386ee31b/" rel="bookmark">
			c语言格式化输入/输出%hhd、%hhx等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ printf sprintf等： 格式字符串的一般形式：[标志][输出最小宽度][. 精度][长度] 类型 （其中方括号[] 中的项为可选项。）
各项意义：
1) 类型：类型字符用以表示输出数据的类型，其格式符和意义如下表所示：
格式字符 意义 d以十进制形式输出带符号整数(正数不输出符号) o以八进制形式输出无符号整数(不输出前缀 0) x,X以十六进制形式输出无符号整数(不输出前缀 Ox) u以十进制形式输出无符号整数 f以小数形式输出单、双精度实数 e,E以指数形式输出单、双精度实数 g,G以%f 或%e 中较短的输出宽度输出单、双精度实数 c输出单个字符 s输出字符串 2) 标志：标志字符为-、 +、 #、空格四种，其意义下表所示：
标 志 意义 -结果左对齐，右边填空格 +输出符号(正号或负号) 空格输出值为正时冠以空格，为负时冠以负号 # 对 c,s,d,u 类无影响；对 o 类, 在输出时加前缀 o；对 x 类, 在输出时加前缀 0x；
对 e,g,f 类当结果有小数时才给出小数点
3) 输出最小宽度: 用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或 0。
4) 精度: 精度格式符以“. ”开头，后跟十进制整数。本项的意义是：如果输出数字，则表示小数的位数；如果输出的是字符，则表示输出字符的个数；若实际位数大于所定义的精度数，则截去超过的部分。
5) 长度: 长度格式符为 h,l 两种， h 表示按短整型量输出， l 表示按长整型量输出。
scanf： 格式字符串的一般形式：%[*][输入数据宽度][长度] 类型 （其中有方括号[] 的项为任选项。）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46b2a5e0c91df4e944713f80386ee31b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e79b96d0098629af2cc20eea1819e7fe/" rel="bookmark">
			Android使用adb命令安装应用-连接usb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		adb命令最全，墙都不扶，就服他，好东西要记录和分享
全网最全adb命令_国内某知名游戏公司小菜鸡工程师-CSDN博客
接下来开始正文
一、配置adb的环境变量
如果没有配置，请移步Java配置环境变量_jing_80的博客-CSDN博客，配置完成，接着往下看。
二、打开开发者模式、打开usb调试
1、检查设备是否连接，输入命令 adb devices 这里有个小坑，如果显示adb: usage: unknown command device，请先检查一下命令行是否输对了，一定是devices，而不是device，加s的
显示如下，说明设备正常连接了
2、开始安装apk，输入命令adb install D:\release.apk（红色部分为apk路径）
显示如下，说明正常安装成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c46f1c8f86db6ab4a981bd851460cb98/" rel="bookmark">
			阿里P6、P7、P8级别需要多少年工作经验？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然各个大厂在去年疯狂的裁员，但是依然改变不了大厂是求职第一首选的事实。尤其是毕业后通过校招进入大厂，再跳槽的话，简历可是含金量相当高的哇！
话说回来，大厂虽然很香，但是想要进去还是有很高的门槛的。拿阿里来举例，一般情况下，毕业后校招进阿里的，普遍定级为P5。
P6定义为有一些工作经验，可以独当一面的同学。P5校招进来的同学，快则2~3年，慢则4~5年，基本上都能升到P6。在其他公司有个几年工作经验，社招进阿里的，一般以P6作为门槛。偷偷的告诉大家，从千锋毕业的学员中，有去了阿里直接就被定级为P6了，简直是不要太优秀！
P7是个分水岭。网上流传的35岁是走还是留，大致的分界线就在P6/P7之间。P7的定位是专家、小组长，能够带领4~5个人小团队的那种。也就是从P7开始，你不能只会敲代码了，必须要有团队管理能力。
P6升P7是很多阿里人的痛。因为真正在阿里从P6升到P7的，大致也就20~30%左右。一般30岁前能升到P7的可以说是很厉害了，是所有程序员中前5%的水平了。大部分的P7都是社招进来的，在一般的小公司是一个经理或总监的水平。
P7升P8就更难了。这个晋升一般会在35岁左右，基本上是凭个人努力或者能力能晋升的最高一个层级。升不上去的人，普遍都会出去另谋出路或者创业。P8的title是高级专家，是负责一小块阿里的业务的，要带20~30人小团队。到了这一职级，出去去一些AB轮的初创公司，基本都可以朝着CTO的方向走了。去一些独角兽企业，当个部门老大也是有机会的。
P8层级，基本上就是一个人凭借能力和努力，能够达到的天花板。P8升P9，光靠努力和能力是不够的。更重要的，看机遇。
▲传说中阿里各职级薪资
P9的title是总监，要求是 “无中生有”，面向未来创建一块有影响力的业务。这个难度，和公司内部创业是差不多的。你得赶上风口，赶上业务的上升期，凑齐天时、地利、人和。既然类比创业，一定是个高风险、不确定的事情。能不能成功，不仅仅靠能力，更多的是眼光和运气。
要想冲进大厂成为高P，首先是技术。只要你技术过硬，你就是一个会发光的金子。学姐呕心沥血、废寝忘食的打造了一个只为程序员提升的学习小程序——免费学习站。
内含16大学科的学习视频，每个学科均按照学习路线图讲解，详细到自学都能求职的程度。毫不夸张的说，你想学习的每个知识点，用到的每一个工具，最新的前沿技术等等，在小程序里均可以一站式解决！！！！！
上下滚动了解小程序
扫码快来找我免费领取哦
不仅如此，小程序里还会有很多隐藏福利，“一站式”可不是说说这么简单的。兄弟萌，趁着小程序现阶段所有视频全都免费学，冲鸭！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65a39054c9349cbf4ebe1bd9f2ffbdd0/" rel="bookmark">
			高并发短信平台实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01、短信介绍 在项目介绍的时候，已经定义了austin项目的核心功能：发送消息
我认为，短信是在一整个消息推送平台里最重要的一个消息类型了（毕竟关联了很多重要的业务场景），想想我们日常使用APP时的场景：
验证码：登录注册、支付等等重要场景通知类：用户订单信息、重要信息通知用户、重要信息通知商家等等场景营销类：运营在特定时间内发送营销短信，影响业务的KPI指标完成（不过这个相对就没那么重要）... （试想下，如果系统挂了10分钟，会怎么样）
发送短信在消息推送平台里比较容易实现的一种消息类型了，我会在这篇文章中让你体会发送消息如果要做得比较好也并没有那么的简单和容易，以及能够体会到为什么我在介绍austin项目的时候需要引入那么多的中间件。
（一切从一条短信开始）
02、发送短信必要准备 隔着上次的系统架构图也有好几天了，先复习下我们austin系统的整个流程
由于是初步实现，所以我先开个接口直接调用austin-handler模块，只要在austin-handler模块下实现发送短信的逻辑就好了。
我们要发送短信，一般直接接入短信渠道商就好了。以我的理解，发短信的过程是这样的：
正好前几天在群里，有个兄弟的就是在公司做短信渠道商的相关业务的。他说接口有20W QPS并发量（之前在搞各种的中间件优化避免消息的堆积），他进去了才知道发送一条短信原来是会经过这么多的流程（我复制下他原话）
我现在才知道，原来一条短信发到我们手机，经过了不知道多少流程，包括黑名单检查风控检查，关键字检查，退订检查，模板检查，客户账号检查，路由网关检查，通道检查，状态报告检查，运营商检查。。。。。。。
一般我们要去评估是否使用某短信渠道商来发送，考量的点有两个：成本和成功率。这里应该还是比较好理解的，短信渠道商有很多，他们都需要赚钱，我们作为接入方需要省钱（那自然就有有价格的差异性）。如果某一个渠道商又便宜发送成功率又高，那当然用他作为主要渠道啊！
这次我选择的是腾讯云作为austin项目下初步发送短信的渠道商。
我这次选择的理由很简单：我进去短信产品了以后，他免费给了我100条发送短信的体验卡（应该是人人都有的？我不可能是天命之子吧）。
我发现有很多小伙伴在跟着我的步伐在做的，我肯定不能把自己的短信账号和密码直接公开给大家体验的。所以到时候你们感兴趣可以用自己的账号体验一波。
麻烦@腾讯云给我打下广告费。@阿里云貌似有？（但入口太难找，罢了）@华为云我还没登录体验过，等等我！
想要发送一条短信又或是接入一个短信渠道商必不可少的两个点：短信模板和短信签名。看不懂？没事，我以具体的一条测试短信为例：
有了短信签名可以让用户知道这可能是谁发过来的短信，有了短信模板可以让发送垃圾短信的概率大大减少。
有人可能就会问了：那我每发一条短信，都需要有对应模板的话，那我维护起来不就非常麻烦？这毕竟是一个推送平台啊！每次有业务需要发送新的文案，还得去对应的渠道商后台申请模板吗？
本来我以为这是正常的，没想到，如果你是公司的话，还能谈的（🐶一般人我还不告诉他）。所以，可能会有通用短信模板的存在。
但不管怎么样，短信渠道商还是会校验各种逻辑（该验证的还是会验证，你乱发消息把你的账号给限流和设置抽样人工验证文案，这样就得不偿失了）
03、功能实现 调用第三方API可能会有两种选择：HTTP调用和内嵌SDK（如果平台方有做SDK的话）。
我以前一般都是直接HTTP调用的，因为这样我的代码就不用内嵌别人家的SDK了（内嵌SDK意味着会引入其他依赖）。于是我就直接从他提供接入文档入手，尝试使用HTTP进行接入。
嗯，我花了两天多，还没接入成功。我直呼顶不住，再这样下去，催更的人都要来我家敲门了！
腾讯云接口用HTTP验签也太太太复杂了吧！原来他的注不是在吓唬我：
我搞了两个晚上已经心灰意冷了，只能妥协用他们提供的SDK了，再加上自动生成代码，嘎嘎很快地就成功了（我好奇有没有勇士曾经按照最新的API文档用HTTP接入过他们的接口）
具体的代码我就不贴了，按照惯例大家在文末(阅读原文)找到Gitee链接🔗看就好了。
跟着项目做的小伙伴，只要在配置文件改下账号信息和调用下接口，就能收到自己的短信了。（问题应该不大，有问题来群里问就好了）
04、为什么austin是消息平台 实现发送短信是一件很简单的事（从它占文章篇幅即可推断出），发送其他渠道的消息其实也很简单。从本质上讲，就是对接API调用发送接口进行发送。
作为一般项目，发完消息就没有后续了，但如果作为一个「平台」而言，这是远远不够的。
4.1 调用发送短信接口后，如果用户反馈收不到怎么办？
我们只调用了发送短信的接口，没有记录接口的返回信息（也就没有发送凭证），当别人找过来的时候，我们也无济于事（我们什么都没记录，什么都不知道）。
解决方案：我们需要存储把发送的记录给存起来，也需要有接口把短信的回执拉回来并存储，并在推送后台提供相关的页面给予快速查询。
4.2 某个短信渠道商挂了怎么办？
别以为我们的依赖是阿里云、腾讯云或者华为云这种大公司，他们提供的产品不是万无一失的，挂也是很正常的事。那如果我们只依赖一个短信渠道，它挂了，是不是相当于我们就挂了。
解决方案：短信需要接入多个渠道商，调用接口失败需要继续调用其他渠道商，支持动态分配渠道商的流量（一旦有提前预警，直接切换渠道商）
4.3 这个月短信花了多少钱，我怎么知道？
接入的短信后台都有对应的统计，但我们量大的话是需要「对账」，以我们的发送记录与回执统计跟短信的后台进行统计。
毕竟都是钱啊，不能全部信他们的啊。我曾经就有遇到过，对方的账单跟我们自己统计的数量有比较大的出入，后来排查发现他们的统计是存在问题的。
解决方案：将短信的发送和回执数据导入到Hive，每个月跑一次Hive脚本统计进行对账
4.4 现在调用短信的量大吗？
第三方接口一般都会有限流的，比如在腾讯云官网上看到对发送接口有3000QPS的限制。我们是需要知道现在各种类型的消息的发送情况是怎么样的，是否有限流的操作。如果限流了，是不是可以告诉业务方可能是原因目前发送量过大导致触发限流。
系统上有完备的监控，你知道了各种的系统指标数据，自己才不会慌。（排查问题有监控会很容易定位）
要是某一天有人跟你说你的系统挂了，你不会还傻乎乎地去服务器上看日志吧？打开监控看下有没有流量，流量正不正常不就一眼就能看到了吗。
解决方案：监控从接口调用到消息下发整个过程的数据（主要是接口QPS和下发人数）
4.5 业务方不小心连续发了两次怎么办？
业务方使用不当，不小心连续推送了两次，如果没有任何限制，那就真的下发了两次。试想下，如果你点了下验证码，霎时间，收到了两条一模一样的短信，你是什么感受？
解决方案：作为平台需要有这种兜底的功能（尽可能避免由于业务使用不恰当，导致出现事故）
4.6 这条短信谁发的啊？
客服反馈：用户接收到了一条短信（用户对具体短信的细节不理解）。客服看着短信也两眼懵逼，公司那么大，不知道由哪个业务团队下发出来的。现在只有短信的文案，怎么能快速找到下发短信的团队呢。
我们需要让所有经过austin项目的消息都有一个「载体」（说白了就是模板），有了模板之后，业务方在接入的时候需要填写各类的信息，有了这些信息再配合搜索引擎就可以快速定位出信息。
"溯源"在很多时候都很有用（比如：你提供了一个HTTP接口，如果没对业务做任何的限制。或许有朝一日，你希望对该接口进行大改动，但你不知道现在有谁进行调用，就会很头疼）
解决方案：给接入方套”模板“，有了模板才能溯源，才能做数据追踪，模板是作为平台的基石。（下一篇等我建表的时候，我会再来跟大家详细说说对应的业务）
4.7 经常要接入短信渠道怎么办？
商务又找到了便宜的短信渠道了，接入一下看看效果吧？这可是实打实省钱的啊！每次写一个类（接入短信就相当于写一个类），我都要重启发布上线吗？这不靠谱吧？
解决方案：上规则引擎将业务代码抽离，无须上下线即可实现功能。
05、总结 实现功能很简单，但在实现功能的过程中代码的健壮性、稳定性以及灵活性如果你都考虑到了，那面试的过程中还怕什么？出去面试，就说我基于现有的场景引入了分布式配置中心，大大提高了工作效率。出去面试，就说我对整个系统进行完备的监控和告警，在这个过程中线上无任何故障，平时遇到问题，我的解决思路是怎么样的等等等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/391ff77f33ce142ec998d1dd87c1bc3f/" rel="bookmark">
			微信小程序学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 项目结构WXML 和 HTML 的区别WXSS 和 CSS 的区别小程序启动的过程页面渲染的过程小程序中组件的分类常用的视图容器类组件常用的基础内容组件其他常用组件 小程序 API 的 3 大分类局部样式 项目结构 pages 存放所有小程序的页面utils 存放工具性质的模块（例如：格式化时间的自定义模块）app.js 小程序项目的入口文件app.json 小程序项目的全局配置文件app.wxss 小程序项目的全局样式文件project.config.json 项目的配置文件sitemap.json 用来配置小程序及其页面是否允许被微信索引 WXML 和 HTML 的区别 ① 标签名称不同
HTML （div, span, img, a）WXML（view, text, image, navigator） ② 属性节点不同
&lt;a href="#"&gt;超链接&lt;/a&gt; &lt;navigator url="/pages/home/home"&gt;&lt;/navigator&gt; ③ 提供了类似于 Vue 中的模板语法
数据绑定列表渲染条件渲染 WXSS 和 CSS 的区别 ① 新增了 rpx 尺寸单位
CSS 中需要手动进行像素单位换算，例如 remWXSS 在底层支持新的尺寸单位 rpx，在不同大小的屏幕上小程序会自动进行换算 ② 提供了全局的样式和局部样式
项目根目录中的 app.wxss 会作用于所有小程序页面局部页面的 .wxss 样式仅对当前页面生效 ③ WXSS 仅支持部分 CSS 选择器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/391ff77f33ce142ec998d1dd87c1bc3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e76e6ba24f86f1a593f4f05a3be6a39/" rel="bookmark">
			UNITY零基础学习 month1 day15
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UNITY零基础学习 month1 day14 C#语言基础枚举简单枚举枚举的多选数据类型转换 类和对象类和对象创建类创建对象 成员变量值类型与引用类型 字段:存储数据构造函数this关键字类数组类结构 C#语言基础 枚举 简单枚举 列举某种数据的所有取值作用：增强代码的可读性，限定取值语法：enum 名字 {值1，值2，值3，值4}枚举元素默认为int类型，准许使用的枚举类型有byte、sbyte、short、ushort、int、uint、long或者ulong每个枚举元素都是有枚举值的。默认情况下，第一个枚举的值为0，后面每个枚举的值一次递增1，可以修改值，后面枚举数的值依次递增 枚举的多选 选择多个枚举值
使用运算符**|**（按位或运算），例如：（Info.io | Info.stream）
两个对应的二进制位中有一个为1，则结果为1
条件：
任意多个枚举值做|（按位或）运算的结果不能与其他枚举值相同定义枚举时，使用[Flags]特性修饰（增强代码可读性，标记可多选） 判断标志枚举是否包含指定枚举值
使用运算符**&amp;**（按位与）
00000011 &amp; 00000001 ==》00000001
数据类型转换 //int ==&gt; Enum PersonStyle style01 = (PersonStyle)2; //Enum ==&gt; int int enumNumber = (int)(PersonStyle.Beauty | PersonStyle.Handsome); //string ==&gt; Enum PersonStyle style02 = (PersonStyle)Enum.Parse(typeof(PersonStyle), "beauty"); //Enum ==&gt; string string strEnum = PersonStyle.Handsome.ToString(); 类和对象 类和对象 面向对象：一种软件开发的思想，指导程序员如何分析、解决问题类是一个抽象概念，即为生活中的“类别”对象是类的具体实例，即归属于某个类别的“个体”名词类型的共性，作为数据成员动词类型的共性，作为方法成员 类的具体形式：
namespace day07练习 { /// &lt;summary&gt; /// 用户类 /// &lt;/summary&gt; class User { //字段 //属性 //构造函数 //方法 } } 创建类 语法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e76e6ba24f86f1a593f4f05a3be6a39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f69da3392c6e566043d96a3cbee609c1/" rel="bookmark">
			i2c spi 读写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下SPI Flash-W25Q64驱动调试_heat.huang的博客-CSDN博客_linux spi调试工具
Linux MTD子系统学习（一）_枫潇潇-CSDN博客_linux mtd
Linux MTD子系统学习（二）_枫潇潇-CSDN博客_linux mtd spi
Linux MTD子系统学习（三）_枫潇潇-CSDN博客_mtd_device_register
Linux MTD子系统学习（四）_枫潇潇-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa33b98d6c332b69b51ccdb7edac40a/" rel="bookmark">
			马的遍历（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目
题目描述 有一个 n×m 的棋盘，在某个点 (x,y) 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。
输入格式 输入只有一行四个整数，分别为 n,m,x,y。
输出格式 一个 n×m 的矩阵，代表马到达某个点最少要走几步（左对齐，宽 5 格，不能到达则输出 −1）。
输入输出样例 输入 #1复制
3 3 1 1 输出 #1复制
0 3 2 3 -1 1 2 1 4 说明/提示 数据规模与约定 对于全部的测试点，保证 1≤x≤n≤400，1≤y≤m≤400。
题解 1.这是一个要用BFS的题，我试了一下DFS，DFS是一条路走到黑，这个题目只能用BFS。
2.三个数组，方向数组，标记数组，编号数组。
3.方向数组，我们不难发现日字走有八个方向，每个方向的x,y都与要走的点x0,y0,平方差为5；所以方向数组是fx[8][2]={{1,2},{2,1},{-1,2},{2,-1},{1,-2},{-2,1},{-1,-2},{-2,-1}};
4.编号数组的初值设为-1，改变是队列head编号+1，这个我想了很久，一直卡在这里。
5.注意排序，一开始ac20，就是因为排序是错的。
代码如下
#include"stdio.h" #include"math.h" int book[409][409]={0},s[409][409]={-1}; int fx[8][2]={{1,2},{2,1},{-1,2},{2,-1},{1,-2},{-2,1},{-1,-2},{-2,-1}}; int n,m; struct node{ int x; int y; int s; }; int main() { int x0,y0,i,j; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;x0,&amp;y0); struct node d[160010]; for(i=1;i&lt;=n;i++) { for(j=1;j&lt;=m;j++) { s[i][j]=-1; } } int head,tail; head=tail=0; d[tail].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aa33b98d6c332b69b51ccdb7edac40a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e5d5925565d48f0d7e2e83c54cc6162/" rel="bookmark">
			Git高效管理LaTeX版本毕业论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么使用Git和LaTeX Git一个版本管理工具，而写论文的过程中我们会遇到很多风险和需求，包括但不限于：
论文文件损坏或丢失论文内容或结构大改实验室电脑书写，但回宿舍自己电脑想接着写查重的时候需要删除一些内容，如封面、致谢等 这些所有的问题，都可以通过Git的版本控制、分支管理以及远程仓库解决。
为了配合Git，使用LaTeX是一个更合理的选择，因为Word的docx是二进制压缩的，不符合Git针对文本增量进行管理的设计。当然Word完全可以使用Git，只不过相当于每次都是管理一个新文件，很浪费存储空间，具体可见为什么其他办公领域不使用git?-知乎。
而且LaTeX就写作体验来讲肯定是比Word好的。当然，前提是你最好有LaTeX的模板，不然自己编写模板很麻烦，所以这里感谢一下我校前辈的贡献，前人栽树，后人乘凉~
环境和软件准备 首先是LaTeX的写作环境，可以参考我上一篇进行配置。Git的话网上教程也是一大堆，菜鸟教程这一篇可以参照一下，当然如果不会Git可以顺便把其他内容也了解一下，学一下应该一天就能会。
还可以准备一个Github或者Gitee账户，用于远程备份你的论文。
使用LaTeX和Git进行管理 这里我将以应用场景为主题来讲解如何使用LaTeX和Git，也方便大家对两者结合的优势有一个更直观的了解。
论文版本控制 可以看到我基本上一天会进行好几次的版本保存，方便能够随时回溯。commit频率的话，可以是一个section，也可以一天、半天交一次，方便你进行版本控制就行。所以当文章写到一半需要修改时，我都是直接大刀阔斧直接删或者剪切，因为根本不怕之前写的内容没有，大不了可以回退找回。
那么先来讲一下本地的版本控制方法，定位到你的文件处理，命令行：
git init git add . git commit -m"first commit" 这三个命令是最基础的命令，分别是：
git init - 初始化仓库，只要一次就好；git add . - 添加当前修改的所有文件到暂存区；git commit - 将暂存区内容添加到仓库中，形成一次提交。 可以看看菜鸟教程的图：
其实完成一部分内容（比如一个section）就可以进行一次commit，这样也方便你管理。
Git版本管理是依照commit的，那么如果想要抛弃这次所有修改：
git checkout . 想回退到某个版本：
git reset 你的commit_id reset有一些讲究，可以参照这篇Git Reset 三种模式。
commit id可以通过git log查看，可以上下键翻阅内容，按q退出。
至此，你可以在你本机上随意修改文章内容，也不用担心之前的文章内容被不小心删了，只要你有一个经常commit的习惯就行。
远程库保存 因为我笔记本是Mac，环境有很多问题，比如字库就比较垃圾，很多生僻字都有问题。所以我在最终提交的时候使用了实验室的台式机进行编译，这时远程库就怕上用处了，比用U盘拷来拷去优雅百倍，而且由于.git文件的存在，其实我们的项目也不适合用U盘。同时，有了远程库，也不用担心本机文件损坏或者是电脑直接坏了，因为换个地方重新下载一次就好了。
一开始说过要准备一个GitHub或Gitee账号，其实都一样，自己搭的Git服务器也行，我这边以GitHub为例。远程仓库需要进行配置，要添加你的账号到本机环境中，最好设置一下SSH密钥，省得以后都要输入密码，可以参照菜鸟教程Github配置。
我这边创建了一个private的库（你想public也行。。。），名为thesis，因为之前我们本地已经有了自己的仓库，所以参照他的提示提交main分支：
git remote add origin git@github.com:你的账户名/thesis.git git branch -M main git push -u origin main 提交后，你就可以看到自己的仓库中有文件了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e5d5925565d48f0d7e2e83c54cc6162/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad295061365cf81406b53a657bea076e/" rel="bookmark">
			Power BI——数据建模案例分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念： 从多个表格、多个来源的数据中，根据不同的维度，不同的逻辑来聚合分析数据；而提取数据的前提是要将这些数据表建立关系，这个建立关系的过程就是数据建模。
二、案例： 比如有个电子产品专卖店，销售产品有三类：手机、电脑、平板，每一类又分别来自三个品牌：小米、苹果、三星，那么这个店销售的产品共计 9 个，其销售明细也是记录这些产品每天的销售数据，
为了能分析每个品牌的销售金额，或者分析每个产品类别的销售情况，其实还应该设计个
产品明细表以及对应的品牌表和种类表，像这样的：
分析以上4个表的关系：品牌表和产品类别表分别和产品明细表中的品牌与产品种类相对应，而产品明细表中的产品编号和销售明细表中的产品编号相对应。
在 Power BI Desktop 中建立一个模型，导入以后点击关系，出现这 4 张表：
可以看出产品明细表和销售明细表之间已经有一条线，这是由于表格导入后，PowerBI 会自动检测关系并联接，没有检测到的表，可以点击一个表中的字段托到另一个表的对应字段上，就可以建立关系了，把类别表、品牌表和产品明细表建立关系后，关系图如下：
点击进入查看建立模型的相关参数，点击关系连接线，两边的表对应的连接字段会框选，双击关系线，进入编辑关系窗口：
编辑关系窗口可以看出关联的两个表和对应的字段，也可以更改联结的字段；下面还有两个可选项，基数和交叉筛选方向
**基数就是两个连接字段的对应关系，分为多对一、一对一和一对多，一对多和多对一其实是一样的，实际上就是两种关系：
1）多对一（*：1）：这是最常见的类型，代表一个表中的关系列有重复值，而在另一个表中是单一值
2）一对一（1：1）：两个表是一对一的关系，列中的每个值在两个表中都是唯一的
3）具有唯一值的表通常称为“查找表”，而具有多个值的表称为“引用表”。在上述的关系图上，产品明细表上类别手机、平板、电脑都不是唯一的，每个品牌都有这种类型，是个引用表；但类别表上，几种类别都是唯一值，因此这两个表是多对一的关系，类别表也就是查找表
**交叉筛选方向是表示数据筛选的流向，有两种类型：
1） 双向：两个表可以互相筛选
2） 单向：一个表只能对另一个表筛选，而不能反向这个稍微有点抽象，以后可以根据实例来理解。
根据刚才建立的数据模型，可以做一下分析，比如统计各品牌产品的销售额：
在销售明细表中并不能直接统计出按品牌的销售额，可以先建一个度量值，在建模选项卡下，点击新建度量值，公式栏输入：销售额 = sum(‘销售明细表’[金额])，然后[销售额]这个度量值就建立了，在右边字段区可以看到
为了在画布上直观的看到各品牌销售额，在可视化里添加“卡片图”，把度量值字段放进去，可以看到卡片图的数字来了
这个数字是整体销售金额，因为还没有做任何筛选，为了看出各品牌的销售金额，现在添加一个品牌的切片器
点击不同的品牌，数值跟着变化，通过这个例子，可以看出：
1）展现的数字并不是一个表得出的，根据之前建立的关系模型，销售明细表中的数据被品牌表中的[品牌名称]字段所筛选，展现出来不同品牌的销售额，这就是数据模型的威力
2）品牌销售额是通过[销售额]这个度量值，加入到卡片图中，并可与切片器交互，展现不同的数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e9dc71a40f0ae3bab8b6089a52f2e43/" rel="bookmark">
			python多环境管理（venv与virtualenv）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 我们经常会遇见这样的场景：
1、各个项目使用的python版本不相同
由于Python的解释器版本众多，各版本之间差异非常大。特别是python2和python3，互不兼容。
有些项目可能用的python2.7，有些项目可能用的是python3.6，有些则使用的3.8等，但是它们却需要运行在同一个服务器环境中。（docker除外，docker容器可以隔离不同的项目环境。）
2、系统依赖自带的解释器
系统的一些服务组件一般也会依赖Python环境。不同的Linux发行版自带的Python也不同。如ubuntu16自带2.7和3.5版本, Centos7依赖python2.7。而系统很多组件都依赖自带的解释器，比如yum等，你不能轻易删除这个版本，一旦删除或者更改都可能造成系统出问题。
3、依赖默认的解释器路径冲突
比如Centos7系统自带的python是2.7，系统很多组件比如yum依赖的都是2.7这个版本。但是我们发现这些工具开头使用的都是：#!/usr/bin/python。
而一些新的使用python开发的服务组件，它们依赖的确实python3.6以上的版本，但是它们一些代码开头用的也是这个引用：#!/usr/bin/python。
它们都是用python这一个引用，却没有使用python2、python3这样分开，这就很容易导致它们的一些python引用冲突。
4、依赖冲突。（最常见）
我们都知道python的软件包依赖经常是个很头疼的问题，经常因为这个问题导致到家在安装一些python环境或者服务组件时失败。
而不同的python解释器版本，对软件包依赖库的管理也是个问题。
比如sqlalchemy这个包，有些项目使用的python2.7版本，它需要依赖这个库，有些项目使用的python3.6版本，它也需要依赖这个库，有些项目使用的python3.8版本，它同样也需要依赖这个库，
但是头疼的是，这三者它们依赖的这个包版本还不一致。sqlalchemy从0.1-2.0有众多版本。
这时候如果你在系统上直接使用pip install sqlalchemy的话，它只能选择安装一个版本，但是这样其他两个项目是无法使用这个版本，就会出现依赖冲突的问题。
由于 Python 的依赖库管理是中心化的，而且大版本上的不兼容且长期并行，就出现了这么一个独特的话题。
你的环境隔离了吗？
二、多环境隔离解决方案 那么有没有一个终极的解决办法能在管理不同解释器版本的同时控制不同的包环境呢?
有的，Python 社区已经涌现了众多这种工具。
Python 多环境隔离，可以让你的每个项目拥有独立的依赖库，即 site-packages。
三、venv 为什么把 venv 放在第一个，因为它是自 3.3 版本之后添加的官方库，自 3.6 版本之后，成为官方推荐的多环境管理工具。也就是说，你不需要安装任何第三方库就可以实现多环境管理了。
注意：python3.3版本之后自带的模块，只支持3.3版本之后的，不支持2.x
1、虚拟环境管理 使用venv创建虚拟隔离环境：
python3 -m venv /data/myproj 它会创建/data/myproj目录，下面如下：
ll /data/myproj 如下图：
bin下面是pip、python等一些可执行环境，
pyvenv.cfg 是我们的配置文件，为什么叫 pyvenv，因为这个库的前身就叫 pyvenv。
而我们的 site-packages 就在 lib 目录下。
激活虚拟环境:
cd /data/myproj source ./bin/activate 如下图，命令行最前面会显示环境名。
激活后，你使用的python，指向的就是虚拟环境里的python了，如下：
在虚拟环境下安装包，启动项目
(myproj) [root@ops-130 myproj]# pip install sqlalchemy 发现安装的包会放在当前环境目录下的lib里面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e9dc71a40f0ae3bab8b6089a52f2e43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac04689972fb104b13fe66966bd5c508/" rel="bookmark">
			WebSocket学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是WebSocket？socket又是什么？ 1、什么是socket？ 我们知道，在网络中的两个应用程序（进程）需要全双工相互通信（全双工即双方可同时向对方发送消息），需要用到的就是socket，它能够提供端对端通信，对于程序员来讲，他只需要在某个应用程序的一端（暂且称之为客户端）创建一个socket实例并且提供它所要连接一端（暂且称之为服务端）的IP地址和端口，而另外一端（服务端）创建另一个socket并绑定本地端口进行监听，然后客户端进行连接服务端，服务端接受连接之后双方建立了一个端对端的TCP连接，在该连接上就可以双向通讯了，而且一旦建立这个连接之后，通信双方就没有客户端服务端之分了，提供的就是端对端通信了。我们可以采取这种方式构建一个桌面版的im程序，让不同主机上的用户发送消息。从本质上来说，socket并不是一个新的协议，它只是为了便于程序员进行网络编程而对tcp/ip协议族通信机制的一种封装。
2、什么是WebSocket？ WebSocket是一种在单个TCP连接上进行全双工通信的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。
WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。
Websocket是html5规范中的一个部分，它借鉴了socket这种思想，为web应用程序客户端和服务端之间（注意是客户端服务端）提供了一种全双工通信机制。同时，它又是一种新的应用层协议，websocket协议是为了提供web应用程序和服务端全双工通信而专门制定的一种应用层协议，通常它表示为：ws://echo.websocket.org/?encoding=text HTTP/1.1，可以看到除了前面的协议名和http不同之外，它的表示地址就是传统的url地址。
Websocket其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充。如下图：
可以看出两者有交集，但是并不是全部，另外Html5是指的一系列新的API，或者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。
通俗来说，你可以用HTTP协议传输非html数据
再简单来说，层级不一样。
二、websocket具有以下几个方面的优势： （1）建立在 TCP 协议之上，服务器端的实现比较容易。
（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
（3）数据格式比较轻量，性能开销小，通信高效。
（4）可以发送文本，也可以发送二进制数据。
（5）没有同源限制，客户端可以与任意服务器通信。
（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。
本协议有两部分：握手和数据传输。
握手是给予http协议的。
来自客户端的握手看起来如以下形式：
来自客户端的握手看起来如以下形式：
三、客户端（浏览器）实现 1、WebSocket对象
实现WebSockets的web浏览器将通过WebSocket对象公开所有必需的客户端功能（主要指支持html5的浏览器）。
以下API用于创建WebSocket对象：
var ws = new WebSocket（url）； //参数url格式说明：ws：//ip地址：端口号/资源名称 2、WebSocket事件
3、WebSocket方法
四、服务端实现 图源
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a21dbd80217bb7cdb529981f1ec9f4f/" rel="bookmark">
			mac显示/关闭隐藏文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Command+Shift+. 可以显示隐藏文件、文件夹，再按一次，恢复隐藏；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df8fec4930ca57167fcf570370f54db7/" rel="bookmark">
			解决报错：[Vue warn]: Invalid prop: type check failed for prop “width“. Expected Number with value 450
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我在父组件给子组件传值的时候发生了错误，
这个报错并没有影响功能，我传递的宽度width，在子组件获取到了。但是有报错看着很不舒服，经过仔细检查发现，在width前面加上v-bind,就可以解决这个报错：
v-bind:也可以直接缩写成:
小贴士： v-bind绑定的是动态的表达式，而非固定的字符串，在v-bind后，就可以动态获取数据。 可以将v-bind理解为： 被v-bind修饰的都是动态获取的值。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69869cded9b7cd5021fcc20921af01bc/" rel="bookmark">
			ubuntu设置开机默认内核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu 内核自动更新很烦人，经常一更新安装的驱动又没了。
1.关闭自动更新
apt-mark hold linux-image-generic linux-headers-generic
2.修改默认启动内核：
sudo gedit /etc/default/grub (1)修改 GRUB_DEFAULT = "1&gt;2" (按shift 或者Esc 键可以查看，&gt;两侧的两级目录都是从0开始的序号，也可以 GRUB_TIMEOUT = 10 (设置个延时方便进入时选择所需的内核) )
(2)sudo update-grub (使设置生效)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/809c28c3f92be92a6dd90ddb5b80bc37/" rel="bookmark">
			【linux kernel】linux系统调用实践（Arm架构）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
本文链接：https://blog.csdn.net/iriczhao/article/details/122464226
文章目录 一、开篇二、添加一个自定义的系统调用。（2-1）在（/arch/arm/include/asm/unistd.h）文件修改syscall的数量（2-2）在（/arch/arm/include/uapi/asm/unistd.h）文件中修改系统调用号（2-3）在（/arch/arm/kernel/calls.S）文件中添加系统调用的函数指针（2-4）在（/include/linux/syscalls.h）文件声明自定义的系统调用接口（2-5）在（/kernel/sys.c）文件中定义自定义的系统调用 三、设计系统调用应用程序 一、开篇 在《【linux kernel】系统调用机制分析》一文中，分析了linux 内核的系统调用机制。本文将利用这个机制，进行系统调用的相关实践，以加深对linux 内核的系统调用机制的理解，文章内容如下：
（1）添加一个自定义的系统调用处理函数。
（2）设计系统调用应用程序。
（注）本文以Arm架构为例，linux kernel 版本：4.1.15
二、添加一个自定义的系统调用。 【思路概览】
​ 添加自定义的系统调用，需要以下几个步骤（注：代码部分由Git查看）：
（2-1）在（/arch/arm/include/asm/unistd.h）文件修改syscall的数量 ​ 注意：数量修正时不是加1，而是加4，这个主要是因为padding对齐的原因。
+#define __NR_syscalls (392) --- a/arch/arm/include/asm/unistd.h +++ b/arch/arm/include/asm/unistd.h @@ -19,7 +19,7 @@ * This may need to be greater than __NR_last_syscall+1 in order to * account for the padding in the syscall table */ -#define __NR_syscalls (388) +#define __NR_syscalls (392) /* * *NOTE*: This is a ghost syscall private to the kernel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/809c28c3f92be92a6dd90ddb5b80bc37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6970b9f3b2be85ce971487561a3cca38/" rel="bookmark">
			Origin无法修改语言为灰色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		帮助-更改语言栏为灰色，无法直接修改语言？
1.win+R打开运行，输入regedit然后回车打开注册表编辑器
2.找到HKEY_CURRENT_USER\Software\OriginLab\Origin 9.8
3.空白处点击右键新建&gt;&gt;字符串值&gt;&gt;名字设置为Language
4.对新建的字符串值双击进行修改：
Language=C 代表中文
Language=E 代表中文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28214ae3489dbf86531929d83b600cbb/" rel="bookmark">
			通过Blinker实现小爱同学控制台灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用ESP8266实现小爱同学控制灯的熄灭以及亮度。 一、准备材料 1、带有小爱同学的设备（小爱音箱、小米手机等等）
2、ESP8266模块
二、基于vscode的ESP8266开发环境搭建 搭建环境参考
1、博客 图文手把手教程--ESP8266开发环境搭建(开发平台VSCODE+PlatformIO，框架Arduino、RTOS_SDK)
2、视频VScode(PlatfromIO)嵌入式开发(ESP32)(ESP8266)(STM32)
三、在blinker中绑定设备 1、下载手机端blinker程序
2、在blinker中添加设备并且获得密钥
四、程序编写 1、在PlatformIO工程中添加blinker库
1.下载blinker库（如果这个链接无法下载则使用备用下载链接）
2.将下载好的库添加到PlatformIO工程中
1）复制解压后的库
2）将库复制到工程中的库下
2、程序编写
#define BLINKER_WIFI #define BLINKER_MIOT_LIGHT //设置小爱灯类库 #define BLINKER_ALIGENIE_LIGHT //设置天猫灯类库 //#define BLINKER_APCONFIG //支持APconfig配网 #include &lt;Blinker.h&gt; //#include &lt;TimerOne.h&gt; //#include &lt;MsTimer2.h&gt; //定时器库的 头文件 //#include &lt;Ticker.h&gt; //定时器库的 头文件 //Ticker flipper; //实例化定时器对象 #define LED_BUILTIN 2 //LED const int buttonPin = 0; //按键 ​ char auth[] = "34dd0f500434"; //将密钥复制进来 char ssid[] = "TP-LINK_0099"; //接入WIFI名称 char pswd[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28214ae3489dbf86531929d83b600cbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ea8086d2aa93a9ea5467a12f1fc8dc2/" rel="bookmark">
			vscode中用快捷键 Alt &#43; Shift &#43; F 格式化代码不生效的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode中用快捷键 Alt + Shift + F 格式化代码不生效（文件中 script脚本部分的代码没有格式化）的问题 在 vscode 中书写代码，有时候缩进格式不一致，代码没有对齐，看起来既不美观，又影响排查错误，按快捷键 Alt + Shift + F 格式化代码时不生效，甚至提示 “HTML” 文件有多个格式化程序。选择默认格式化程序以继续，如下图中所示：
解决方法：
检查是否安装了 Beautify 插件，如果没有安装，先按照以下步骤安装 2. 安装好了以后，打开 vscode 的本地设置，如下图所示：
3. 在setting.json文件中加上这部分代码
"beautify.language": { "js": { "type": [ "javascript", "json", ], "filename": [".jshintrc", ".jsbeautifyrc"] // "ext": ["js", "json"] // ^^ to set extensions to be beautified using the javascript beautifier }, "css": [ "css", "less", "scss" ], "html": [ "htm", "html", "vue" ] // ^^ providing just an array sets the VS Code file type }, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ea8086d2aa93a9ea5467a12f1fc8dc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0b3be3e6be74a819b9e14587969813e/" rel="bookmark">
			关于 Flink, 我读了这些书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		真正做点事的时候，发现时间过的贼快
这两周，业余时间都在看 Flink. 项目实时处理的需求，越来越多，维稳策略下，团队选择了 Flink. 所以，我觉得非常有必要，自己先搭环境玩起来。
共计22小时，每天拿出大约2小时左右，上手做下例子。当然，还仅仅只能做简单开发，对于特别场景的应用，止步于算法和数据结构。从应用架构上，其实 Flink与 Spark 并没有太多的差异。看几个例子，很快就能上手写一写。
但，就如我之前的文章所写，学任何技术，千万不要沉迷于基础入门的案例，一开始就要朝着高端例子研究。为的就是暴露自己的斤两，知道目前自己在什么位置。通过自己的努力，一步步攻克那些里程碑。
以前，我经常为自己能写出上千行的 SQL，并把它们控制在 5s 以内返回结果，而狂喜不已，甚至有些横着走的心态。
但随着阅读的增加，知道有些人类，改写了引擎的轮子，拿到了纳斯达克交易所的门票，才发现自己，愚蠢至极。从此我警告自己，“不要熵死！”
很多朋友疑惑，学Flink,是不是要先有 Hadoop/Hive/Spark基础。依我看，即使不会，问题也不大。它提供的功能，还是分量处理。把宏大的流量，分散到各个处理节点，通过Transformation算子，做些统计，预测和告警。
之所以认为，要学Flink, 必须要先学 Hadoop/Hive/Spark,可能受教条化的老学究影响。那代老学究就是这么过来的，他们经历的大数据历史，从2006年的 Hadoop 开始, 一路经历了 Hive，Spark 项目，固化的认为，Flink 也必须先摸索一遍大数据三件套
大可不必。经过这几天的摸索，我发现，完整的 Flink 程序，由一个 Java 或 Scala 的程序入口开始，一般是一个静态（static）的 main 函数。在main函数中，定义了下面几个核心步骤。
①设置执行环境。
②读取一到多个数据源。
③根据业务逻辑对数据流进行转换。
④将结果输出到 Sink。
⑤调用作业执行函数。
上述步骤或者说配置，就是标准的 Flink 应用必备设计。无论多么复杂的 Flink 程序，都包含了这些程序
所以，我大胆尝试下，摒弃以往的学法，没有哭哈哈从头到尾读书, 也忘记大数据三件套的先入理念，直接阅读 wordcount 源代码，给自己设定几个改造场景，然后去完成编码：
1）拿到 wordcounter 的例子源代码 2）将其 sink 目标改成 MySQL 的一张表： wordcounter 3) 官方的 WC 案例，是分组计算，那我们的改造例子，就完成全量计算 4） 再改造下，将counter数大于 5 的记录，都找出来
5） 再改造下，把原始记录存在 MySQL的 wordrecord中，用 Flink去分组计算，并存入 MySQL 的 wordcounter 表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0b3be3e6be74a819b9e14587969813e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbc53bd94ccd1b6839b9b292d9f7661d/" rel="bookmark">
			MATLAB学习--Switch 模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Switch 模块
Switch模块是-.个选择开关模块,可根据判断条件选择多个输入端口中的某个进行输出。图所示为CommonlyUsedBlocks中具有3个输入端口.1个输出端口的Switch模块图标。模块的3个端口中,第1个和第3个端口为输出端口提供输出值,输出端口输出第1个输人口还是第3个输人口的值由第2个输人口的值和条件关系共同决定。参数对话框中的条件关系选择对第2个端口进行条件判断,如果判断为真，则输出口输出第1个端口的信号;否则输出第3个输人端口的信号。对第2个端口进行判断的条件关系有3种选择:
①第2个端口大于或等于某个阈值。
②第2个端口大于某个阈值。
③第2个端口不等于0。
阈值( Threshold)在Switch参数对话框的参数中设置。当用户选择条件关系后,该判断，
条件会显示到模块框图上。
参考：https://blog.csdn.net/qq_45769063/article/details/106174446
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b984946dc50acbb4203d1a958f9e373/" rel="bookmark">
			Linux网络编程之文件传输2--带有MD5验证文件的完整性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：这是在Linux中的，MD5的计算使用了oepnssl库，要注意你的Linux有没有，编译是要加库-lcrypto,
运行结果：
代码：
/* 文件传输 客户端向服务器传送文件2.0 */ #include&lt;stdio.h&gt; #include&lt;unistd.h&gt; #include&lt;fcntl.h&gt; #include&lt;sys/stat.h&gt; #include&lt;sys/types.h&gt; #include&lt;sys/socket.h&gt; #include&lt;arpa/inet.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;sys/stat.h&gt; #include&lt;openssl/md5.h&gt; #define PORT 7777 #define IP "127.0.0.1" typedef struct file_imformation{ char file_name[120]; unsigned long int file_length; unsigned char md5[16]; }FILE_IMFORMATION; int file_transfer(int fd,char* path,unsigned long int file_size); int file_imformation_transfer(int server_fd); int get_file_md5(char *file_url,unsigned char md5 []); int compare_str(char arr1[],char arr2[],int len); int main(int argc,char* argv[]){ int fd; struct sockaddr_in daddr; int err; //建立套接字 fd = socket(AF_INET,SOCK_STREAM,0); if(fd &lt; 0){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b984946dc50acbb4203d1a958f9e373/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44fdb91aeaf910cca13c76132650e958/" rel="bookmark">
			yolov5的TensorRT部署【tensorrt&#43;cudnn@主机】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、版本问题 （1）TensorRT的ONNX解释器是针对Pytorch版本编译的，如果版本不对应可能导致转模型时出现错误。
（2）主机环境：pytorch1.8.1+cuda11.1
2、Pytorch2ONNX 主机上exp305权重可用，尝试转ONNX，命令如下：
python export.py --weights runs/train/exp305/weights/best.pt --img 640 --include engine onnx 成功导出best.onnx到runs/train/exp305/best.onnx
3、YOLO2TensorRT export可以直接导出tensorrt，参数是--include engine，自动下载了tensorrt-0.0.1
包不能用：
No module named 'tensorrt'
安装下载TensorRT(这里是错误方法，可直接跳到下面正确方法) 参照别人的版本：
尝试更换tensorrt版本：
pip uninstall tensorrt 因为看到英伟达官网上只有8.2有ubuntu20.02版本，所以下载了这个版本
下载安装了trt8.2，仍然不行，no module named 'tensorrt'：
用dpkg安装：
还是不行。
版本不对需要不同的依赖：
准备重新来，卸载deb包：
查找tensorrt包：
dpkg -l |grep tensorrt 卸载这个包：
sudo dpkg -P nv-tensorrt-repo-ubuntu2004-cuda11.4-trt8.2.1.8-ga-20211117 dpkg -r 卸载。
dpkg -P 彻底卸载，包括配置文件等。
卸载完之后用dpkg找不到包了：
尝试下载别人博客中的版本：
下载了这个：
下面是正确安装方法：TensorRT 解压：
tar zxf TensorRT-8.0.1.6.Linux.x86_64-gnu.cuda-11.3.cudnn8.2.tar.gz 移动：
sudo mv TensorRT-8.0.1.6 /opt 环境变量
gedit ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44fdb91aeaf910cca13c76132650e958/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e34201518cff9e34300f7a483f37be0d/" rel="bookmark">
			我的 Java 入门项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的 Java 入门项目 我入门 Java 是在2019年10月入的，当时已经学完了 C语言，因此这个入门项目只用了一个下午
工具：IDEA + MariaDB + Navicat + Tomcat + maven
SQL 文件 CREATE DATABASE `book` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; SET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; DROP TABLE IF EXISTS `employees_cn`; /*!40101 SET @saved_cs_client = @@character_set_client */; /*!40101 SET character_set_client = utf8 */; CREATE TABLE `employees_cn` ( `employee_id` int(11) NOT NULL AUTO_INCREMENT, `employee_name` varchar(255) COLLATE utf8_bin DEFAULT NULL, `employee_address` varchar(255) COLLATE utf8_bin DEFAULT NULL, `employee_price` int(10) DEFAULT NULL, PRIMARY KEY (`employee_id`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=49 DEFAULT CHARSET=utf8 COLLATE=utf8_bin ROW_FORMAT=DYNAMIC; INSERT INTO `employees_cn` VALUES (1,'张伟','北京',20000), (6,'周通','上海',17500), (14,'王飞','赣州',28000), (17,'马超','佛山',20000), (18,'刘备','抚州',15000), (20,'李兰','北京',20000), (21,'李兰妈','株洲',46000), (22,'周杰','深圳',20000), (23,'丁宁','天津',1500), (24,'张飞','上饶',25000), (25,'周杰','深圳',20000), (48,'孙红雷','哈尔滨',30000); 创建 JavaWeb 项目 新建工程后，maven会下载一些文件，没多大，大家耐心等待即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e34201518cff9e34300f7a483f37be0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a99c5b49022eed28f46c22732e753558/" rel="bookmark">
			vue公共删除组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.由于很多组件都要做删除功能，所以提取一个公共组件delBtn
&lt;template&gt; &lt;el-button type="danger" @click="del"&gt;删除&lt;/el-button&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { del() { this.$confirm("你确定要删除吗?", "提示", { confirmButtonText: "删除", cancelButtonText: "取消", confirmButtonClass:"el-button el-button--danger", type: "warning" }) .then(() =&gt; { //用户点了确定，通知父组件该删了 this.$emit("confirm") }) .catch(() =&gt; {}); } } }; &lt;/script&gt; 2.components/index.js 注册
//删除组件 import delBtn from "./delBtn.vue" Vue.component("delBtn",delBtn) 3.role/list.vue 调用
&lt;del-btn @confirm="del(scope.row.id)"&gt;&lt;/del-btn&gt; //31.删除 del(id) { reqRoleDel({ id: id }).then(res =&gt; { if (res.data.code == 200) { successalert(res.data.msg); this.$emit("init"); } }); }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/841506cc45732ec2be44dbcca1baf8d7/" rel="bookmark">
			Query string parameters 请求url携带参数写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请求url携带参数写法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb765b1d344feb27dbef2a41e0d0dbb9/" rel="bookmark">
			Linux网络编程之文件传输，基于c语言的网络编程，在Linux下实现文件传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		带MD5完整性验证功能的文件传输：https://blog.csdn.net/weixin_45640148/article/details/122391285
功能描述：
基于C/S模式下的，客户端可以向服务器端上传文件，上传过程显示上传进度
运行结果：
运行前注意事项：
1.服务器端的文件默认保存位置需要修改，在服务器代码部分的static char filepath[50] = “/home/ffj/fileTtest/”;，改为任意一个存在路径（需要对该路径具有读写执行权限，建议使用root用户运行程序。）
2.要先运行服务器，再运行客户端。
运行过程:
gcc -o server.out fileTServer.c
gcc -o client.out fileT.c
终端一：
./server.out
终端二：
./client.out
流程图描述：
实验代码：
服务器端fileTServer.c
```c /* 文件传输 服务器接收客户端传输文件2.0 */ #include&lt;stdio.h&gt; #include&lt;unistd.h&gt; #include&lt;fcntl.h&gt; #include&lt;sys/stat.h&gt; #include&lt;sys/types.h&gt; #include&lt;sys/socket.h&gt; #include&lt;arpa/inet.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #define BACKLOG 3 #define PORT 7777 #define IP "127.0.0.1" int file_access(int fd); int file_imformation_accept(int fd,char buff[],unsigned long int *file_size); //默认接收文件路径 static char filepath[50] = "/home/ffj/fileTtest/"; struct file_imformation{ char file_name[120]; unsigned long int file_length; }; int main(int argc,char* argv[]){ int fd; struct sockaddr_in daddr; char buff[1024]; int err; //建立套接字 fd = socket(AF_INET,SOCK_STREAM,0); if(fd &lt; 0){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb765b1d344feb27dbef2a41e0d0dbb9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/305/">«</a>
	<span class="pagination__item pagination__item--current">306/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/307/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>