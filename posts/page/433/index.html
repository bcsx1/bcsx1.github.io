<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb6604529278ab0d4ccde747486742b6/" rel="bookmark">
			Excel VBA之MD5验证密码介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MD5是一种不可逆的验证文件完整性的Message——Digest 算法，由MIT的实验室最早提出来，想了解历史的可以自行查阅，对于MD5不可逆的主要原因是Hash算法不可逆，其具体操作里的算法有求余Mod 操作，可以想象若都对数据对64求余，若余数为1，原始值可能为65，129……等无限多种可能，这也决定了MD5算法不可逆。
具体的一个MD5的Excel VBA验证密码算法：
Option Explicit Private Const OFFSET_4 = 4294967296# Private Const MAXINT_4 = 2147483647 Private State(4) As Long Private ByteCounter As Long Private ByteBuffer(63) As Byte Private Const S11 = 7 Private Const S12 = 12 Private Const S13 = 17 Private Const S14 = 22 Private Const S21 = 5 Private Const S22 = 9 Private Const S23 = 14 Private Const S24 = 20 Private Const S31 = 4 Private Const S32 = 11 Private Const S33 = 16 Private Const S34 = 23 Private Const S41 = 6 Private Const S42 = 10 Private Const S43 = 15 Private Const S44 = 21 Public Function MD5_String(Expression As String) As String MD5Init MD5Update LenB(StrConv(Expression, vbFromUnicode)), StringToArray(Expression) MD5Final MD5_String = GetValues() End Function Public Function MD5_File(FileName As String) As String On Error GoTo ErrorHandler Dim FileO As Integer FileO = FreeFile Call FileLen(FileName) Open FileName For Binary Access Read As #FileO MD5Init Do While Not EOF(FileO) Get #FileO, , ByteBuffer If Loc(FileO) &lt; LOF(FileO) Then ByteCounter = ByteCounter + 64 MD5Transform ByteBuffer End If Loop ByteCounter = ByteCounter + (LOF(FileO) Mod 64) Close #FileO MD5Final MD5_File = GetValues ErrorHandler: Exit Function End Function Private Function StringToArray(InString As String) As Byte() Dim i As Integer, bytBuffer() As Byte ReDim bytBuffer(LenB(StrConv(InString, vbFromUnicode))) bytBuffer = StrConv(InString, vbFromUnicode) StringToArray = bytBuffer End Function Private Function GetValues() As String GetValues = LongToString(State(1)) &amp; LongToString(State(2)) &amp; LongToString(State(3)) &amp; LongToString(State(4)) End Function Private Function LongToString(Num As Long) As String Dim a As Byte, b As Byte, c As Byte, d As Byte a = Num And &amp;HFF&amp; If a &lt; 16 Then LongToString = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb6604529278ab0d4ccde747486742b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7b082b20af16f5b469a2b324facf5c1/" rel="bookmark">
			详解react hooks(含高阶组件)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 面试中出现的关于hooks的题目 1. 简单介绍下什么是hooks，hooks产生的背景？hooks的优点？ hooks是针对在使用react时存在以下问题而产生的：
组件之间复用状态逻辑很难，在hooks之前，实现组件复用，一般采用高阶组件和 Render Props，它们本质是将复用逻辑提升到父组件中，很容易产生很多包装组件，带来嵌套地域。组件逻辑变得越来越复杂，尤其是生命周期函数中常常包含一些不相关的逻辑，完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。复杂的class组件，使用class组件，需要理解 JavaScript 中 this 的工作方式，不能忘记绑定事件处理器等操作，代码复杂且冗余。除此之外，class组件也会让一些react优化措施失效。 针对上面提到的问题，react团队研发了hooks，它主要有两方面作用：
用于在函数组件中引入状态管理和生命周期方法取代高阶组件和render props来实现抽象和可重用性 优点也很明显：
避免在被广泛使用的函数组件在后期迭代过程中，需要承担一些副作用，而必须重构成类组件，它帮助函数组件引入状态管理和生命周期方法。Hooks 出现之后，我们将复用逻辑提取到组件顶层，而不是强行提升到父组件中。这样就能够避免 HOC 和 Render Props 带来的「嵌套地域」避免上面陈述的class组件带来的那些问题 2. 知道hoc和render props吗，它们有什么作用？有什么弊端？ Render Props 组件和高阶组件主要用来实现抽象和可重用性。
弊端就是高阶组件和 Render Props 本质上都是将复用逻辑提升到父组件中，很容易产生很多包装组件，带来的「嵌套地域」。由于所有抽象逻辑都被其他 React 组件所隐藏，应用变成了一棵没有可读性的组件树。而那些可见的组件也很难在浏览器的 DOM 中进行跟踪。
2.1 Render Props 什么是Render Props
render props模式是一种非常灵活复用性非常高的模式，它可以把特定行为或功能封装成一个组件，提供给其他组件使用让其他组件拥有这样的能力。他把组件可以动态渲染的地方暴露给外部，你不用再关注组件的内部实现，只要把数据通过函数传出去就好。
使用场景：
通用业务逻辑的抽取当两个平级组件之间需要单向依赖的时候，比如两个同级组件A、B，A组件需要跟随B组件的内部状态来改变自己的内部状态，我们就说A依赖B；或者B依赖A render props demo参考
2.2 Hoc hoc的应用demo
hoc是 React 中用于重用组件逻辑的高级技术，它是一个函数，能够接受一个组件并返回一个新的组件。
实现高阶组件的两种方式：
属性代理。高阶组件通过包裹的React组件来操作props反向继承。高阶组件继承于被包裹的React组件 2.2.1属性代理 a. 什么是属性代理 属性代理组件继承自React.Component，通过传递给被包装的组件props得名
// 属性代理，把高阶组件接收到的属性传递给传进来的组件 function HOC(WrappedComponent) { return class PP extends React.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7b082b20af16f5b469a2b324facf5c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8f566ce16b2b2dec9fa5340c8dc2225/" rel="bookmark">
			目标检测 | 已开源！全新水下目标检测算法SWIPENet&#43;IMA框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“AI算法修炼营”，选择“星标”公众号
精选作品，第一时间送达
论文地址：https://arxiv.org/abs/2005.11552.pdf
代码地址：https://github.com/LongChenCV/SWIPENet
近年来，基于深度学习的方法在标准的目标检测中取得了可喜的性能。水下目标检测仍具有以下几点挑战：（1）水下场景的实际应用中目标通常很小，含有大量的小目标；（2）水下数据集和实际应用中的图像通常是模糊的，图像中具有异构的噪声。
为了解决小目标检测和噪声这两个问题，本文首先提出了一种新颖的神经网络架构，即用于小物体检测的样本加权混合网络（SWIPENet）。SWIPENet由高分辨率和语义丰富的超特征图组成，可以显着提高小物体检测的准确性。此外，提出了一种新的样本加权损失函数，该函数可以为SWIPENet建模样本权重，它使用一种新颖的样本重新加权（Sample re-weighting）算法，即Invert Multi-Class Invert Adaboost（IMA），以减少噪声对提出的SWIPENet的影响。
在两个水下机器人拾取竞赛数据集URPC2017和URPC2018进行的实验表明，与几种最先进的目标检测方法相比，本文提出的SWIPENet+IMA框架在检测精度上取得了较好的性能。
简介
水下目标检测旨在对水下场景中的物体进行定位和识别。这项研究由于在海洋学、水下导航等领域的广泛应用而引起了持续的关注。但是，由于复杂的水下环境和光照条件，这仍然是一项艰巨的任务。
基于深度学习的物体检测系统已在各种应用中表现出较好的性能，但在处理水下目标检测方面仍然感到不足，主要有原因是：可用的水下目标检测数据集稀少，实际应用中的水下场景的图像杂乱无章，并且水下环境中的目标物体通常很小，而当前基于深度学习的目标检测器通常无法有效地检测小物体，或者对小目标物体的检测性能较差。同时，在水下场景中，与波长有关的吸收和散射问题大大降低了水下图像的质量，从而导致了可见度损失，弱对比度和颜色变化等问题。
本文提出的方法：SWIPENet
卷积神经网络的下采样的使用能够带来强大的语义信息，从而导致许多分类任务的成功。然而，下采样操作对于目标检测任务来说是不够的，目标检测任务不仅需要识别物体的类别，而且还需要在空间上定位其位置。在应用了几次下采样操作之后会导致特征图的空间分辨率太粗糙，从而无法处理小物体的检测。
在本文中，提出了SWIPENet网络结构，该网络充分利用了受DSSD启发的几种高分辨率和语义丰富的Hyper 特征图。 先来介绍一下DSSD网络。
SSD利用了感受野与分辨率不同的6个特征图进行后续分类与回归网络的计算，DSSD保留了这6个特征图，但对这6个特征图进一步进行了融合处理，然后将融合后的结果送入后续分类与回归网络，如下图所示。具体做法是，将最深层的特征图直接用作分类与回归，接着，该特征经过一个反卷积模块，并与更浅一层的特征进行逐元素相乘，将输出的特征用于分类与回归计算。类似地，继续将该特征与浅层特征进行反卷积与融合，共计输出6个融合后的特征图，形成一个沙漏式的结构，最后给分类与回归网络做预测。
DSSD具体的反卷积模块如下图所示。这里深特征图的大小是H×W×512，浅特征图的大小为2H×2W×D。深特征图经过反卷积后尺寸与浅特征图相同，再经过一些卷积、ReLU与BN操作后，两者进行逐元素的相乘，最后经过一个ReLU模块，得到最终需要的特征图。
在得到特征图后，DSSD也改进了分类与回归的预测模块。SSD的预测模块是直接使用3×3卷积，而DSSD则对比了多种方法，最终选择了下图所示的计算方式，包含了一个残差单元，主路和旁路进行逐元素相加，然后再接到分类与回归的预测模块中。
可以看出，DSSD通过多个上采样反卷积层增强了SSD目标检测框架，以提高特征图的分辨率。在DSSD体系结构中，首先，构造多个下采样卷积层以提取有利于对象分类的高语义特征图。经过几次下采样操作后，特征图太粗糙而无法提供足够的信息来进行精确的小对象定位，因此，添加了多个上采样反卷积层和skip connection来恢复特征图的高分辨率。但是，即使恢复了分辨率，下采样操作丢失的详细信息也无法完全恢复。
为了改进DSSD，本文所提出的SWIPENet网络使用空洞卷积层来获得强语义信息，而不会丢失支持对象定位的详细信息。图2说明了提出的SWIPENet的基本结构，它由多个基本卷积块（红色），空洞卷积块（绿色），反卷积块（蓝色）和新的样本加权损失（灰色）组成。 SWIPENet的主干网络采用的标准VGG16模型（在Conv53layer上被截断）。与DSSD不同的是，在网络上添加了四个具有ReLU激活的空洞卷积层，可以在不牺牲特征图分辨率的情况下获得较大的感受野（较大的感受野会带来强语义信息）。同时，skip connection将低层的精细细节传递给高层特征图。最后，在反卷积层上构造了多个Hyper Feature Map。SWIPENet的分类和回归预测模块上部署了三个不同的反卷积层，即Deconv12，Deconv22和Deconv32（在图2中表示为Deconvx2），它们的大小逐渐增加并预测多个尺度的对象。在三个反卷积层中定义了6个默认框和相对于原始默认框形状的4个坐标偏移，并使用3×3卷积产生C + 1类别的分数（C表示类别的数量，1指示背景类）。
Sample-weighting loss
本文提出了一种新颖的样本加权损失函数，可以在SWIPENeT中对样本权重进行建模。样本加权损失使SWIPENet可以专注于学习高权重样本，而忽略低权重样本。它能够与新颖的样本加权算法Invert Multi-Class Invert Adaboost配合使用，通过减少权重来减少可能的噪声对SWIPENet的影响。
样本加权损失L由用于边界框分类的损失Lcls和用于边界框回归的损失Lreg组成，Lcls使用softmax损失函数而Lreg使用L1平滑损失实现。
样本权重通过调整反向传播中使用的参数的梯度来影响SWIPENet的特征学习。
通过使用样本权重损失，使得SWIPENeT的特征学习主要由高权重样本决定，而低权重样本的特征学习则被忽略。
样本重加权可用于解决嘈杂的数据问题。它通常为每个样本分配一个权重，然后优化样本加权的训练损失。
Invert Multi-Class Invert Adaboost（IMA）
SWIPENet可能会丢失或错误地检测到训练集中的某些对象，这些目标对象可能被视为噪声数据。这是因为含有噪声的数据非常模糊，并且与背景相似，因此容易被忽略或检测为背景。如果我们使用这些嘈杂的数据训练SWIPENet，则性能可能会受到影响， SWIPENet无法将背景与物体区分开来。图3显示了示例测试图像及其通过SWIPENet的不正确检测。
为了解决这个问题，受文章《Inverse boosting pruning trees for depression detection on Twitter》（https://arxiv.org/abs/1906.00398）的启发提出一种IMA算法，以减少不确定对象的权重，以提高SWIPENet的检测精度。
IMA算法首先顺序训练多个基本分类器，并根据其错误率Em分配权重值α。然后，将由前面的分类器分类错误的样本分配较高的权重，从而使后面的分类器专注于学习这些样本。最后，将所有弱基础分类器组合在一起，形成具有相应权重的整体分类器。IMA还训练了M次SWIPENet，然后将它们整合为一个统一模型。不同的是，在每次训练迭代中，IMA都会减少丢失对象的权重，以减少这些“干扰”样本的影响。
IMA算法同时定义了一个线性映射函数将IMA权重映射到样本加权损失中使用的权重。
实验结果
更多细节可以参考论文原文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/305f5bc084d5e940a4f46b735a70ee4f/" rel="bookmark">
			【Matlab】一个超简单的生成顺序数组的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比如我想生成一个1到100的一维数组。
可以先定义一个长度为100的数组，然后接着一个for循环，就可以实现。
不过略显复杂，复杂的我都不想打个示例了。
下面介绍一个方法，在MATLAB里，一句话生成任意长度的顺序数组
A = （1:10） 数组的起点和终点都可以自己设置，默认间隔为1
如果想改变数组递增间隔，也可以简单实现
至此，我们实现在matlab中生成任意起点、任意终点、任意长度和任意间隔的任意数组~
猜你喜欢：👇🏻
⭐【Matlab】一种超简单的二维矩阵降维方法
⭐【Matlab】如何提取矩阵中特定位置的元素？
⭐【Matlab】如何简单实现数组间交集，并集和补集？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2624ff7d3f106acfd5d11083670f2d13/" rel="bookmark">
			使用Springboot框架，like模糊查询，无结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Springboot框架，like模糊查询，无结果 AND en.report_name LIKE CONCAT(’%’,#{report},’%’ )
查询无结果，但是在数据库执行sql能查询出结果
解决办法：在数据库url加上编码方式characterEncoding=utf8解决问题
spring.datasource.url=jdbc:mysql://localhost:3306/mydb?characterEncoding=utf8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66a6abb571d9f7782a9002cdc1d76f90/" rel="bookmark">
			堆的定义与基本操作接口：建堆、插入、删除、排序（C&#43;&#43;实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		堆的定义：
堆是一颗完全二叉树，树中每个节点的值都不小于（或不大于）其左右孩子结点的值。其中，如果父节点的值大于或等于孩子节点的值，则称之为大顶堆。如果父节点的值小于或等于孩子节点的值，则称之为小顶堆。
堆一般用优先队列来实现。
#include &lt;queue&gt; // 一般声明 priority_queue&lt;int&gt; q1; /* 自定义优先级比较函数时的声明方式： 参数1：队列中的元素类型 参数2：元素使用的容器 参数3：比较函数：可以自定义 */ priority_queue&lt;int, vector&lt;int&gt;, less&lt;&gt;&gt; q2; 在实际解题中，使用STL中的优先队列后，我们就可以忽略堆的内部实现，直接使用其接口即可。
下面我们看看关于堆的内部实现：
对于完全二叉树，可以使用数组来进行存储。这样节点就是按照层序的方式存储于数组中，其中第1个节点存储与1号位，并且第i号位的节点的左孩子就是2i号位，右孩子就是（2i+1）号位。
堆的表示（使用数组）：
const int maxn = 100; int n;	// 堆中元素的个数 int heap[maxn];	// 堆：完全二叉树 堆节点的调整：向下调整，排序时使用。向下调整的依据时，堆中父节点的权值要比子节点大，否则交换之。当然，在交换的过程中，要选择左右子节点中权值较大者，进行交换。交换完成后，继续向下比较，直到无左右孩子，或者，父节点的权值已经比孩子权值都大，则对于此节点的调整完成。
// 向下调整 // low为欲调整节点的下标，high为堆中最后一个元素的下标 void downAdjust(int low, int high) { int i = low; int j = 2 * low; while (j &lt;= high) { if (j + 1 &lt;= high &amp;&amp; heap[j + 1] &gt; heap[j]) { j = j + 1; // 右孩子比左孩子大 } // 左右孩子中的最大值比父节点的值大：将其与父节点交换 if (heap[j] &gt; heap[i]) { swap(heap[j], heap[i]); i = j; j = i * 2; } else { break; } } } 建堆：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66a6abb571d9f7782a9002cdc1d76f90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c25ea8a5fd24c19941d8615e5d327b1/" rel="bookmark">
			在线程池中使用无界阻塞队列会发生什么问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在远程服务异常的情况下，使用无界队列是否会导致内存异常飙升？
当线程在执行任务时需要调用远程服务，当调用远程服务异常时，就会导致线程处理每个任务都需要等待很长的时间；
处理任务的速度慢，产生任务的速度快，而任务队列是没有边界的，就会导致队列变得越来越大，从而导致内存飙升，还可能导致OOM内存溢出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f3d9993787f05fc20695a320fdfacab/" rel="bookmark">
			SQL_INSERT,UPDTE,DELETE语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL_INSERT,UPDTE,DELETE语句 1、添加数据:insert语句。2、修改数据:update语句。3、删除数据:delete语句。4、总结。 1、添加数据:insert语句。 语法 insert into 表名(字段1,字段2,字段3...字段N) values(值1,值2,值3....值N) 案例 -- 向employee_info表添加数据。 insert into employee_info(emp_name,emp_salary,emp_dept) values('张学友',18000,'行政部') -- 日期类型，注意格式 insert into north_american_box_office(riqi,dangripiaofang,zhongwenpianming) values('2020-05-20',250,'情圣3') -- 日期类型，可以使用函数 insert into north_american_box_office(riqi,dangripiaofang,zhongwenpianming) values(current_date(),250,'情圣3') 2、修改数据:update语句。 语法 update 表名 set 字段1 = 新值1,字段2 = 新值2 ... 字段n = 新值n where 条件 案例 -- 如果id_card_no 为null -- 那么将id_card_no 修改为 ‘xxxx’ -- 将phone_number修改为‘zzzz’ update employee_info set id_card_no = 'xxxx',phone_number = 'zzzz' where id_card_no is null update employee_info set emp_salary = emp_salary + 10000 where emp_dept = '研发部' 3、删除数据:delete语句。 语法 delete from 表名 where 条件 案例 -- 将employee_info表中emp_name为‘李信’的字段删除。 delete from employee_info where emp_name = '李信' 4、总结。 一个SQL语句中不要加入“分号”，血的教训。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c258408337ae1eda871b6860648f43fa/" rel="bookmark">
			数据结构笔记——线索二叉树找前驱/后继
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、中序线索二叉树找中序后继
二、中序线索二叉树中找中序前驱
三、先序线索二叉树找先序后继
四、先序线索二叉树找先序前驱
五、后序线索二叉树找后序前驱
六、后序线索二叉树找后序后继
七、总结
一、中序线索二叉树找中序后继 在中序线索二叉树中找到指定结点*p的中序后继next
①若p-&gt;rtag == 1,则next = p-&gt;rchild
②若p-&gt;rtag == 0
//找到以P为跟的子树中，第一个被中序遍历的结点 ThreadNode *Firstnode(ThreadNode *p){ //循环找到最左下结点（不一定是叶子结点） while(p-&gt;ltag == 0) p = p-&gt;lchild; return p; } //在中序线索二叉树中找到结点p的后继结点 ThreadNode *Nextnode(ThreadNode *p){ //右子树中最左下结点 if(p-&gt;rtag == 0) return Firstnode(p-&gt;rchild); else return p-&gt;rchild; } //对中序线索二叉树进行中序遍历（利用线索实现的非递归算法） 空间复杂度O(1) void Inorder(ThreadNode *T){ for(ThreadNode *p = Firstnode(T);p != NULL; p = Nextnode(p)) visit(p); } 二、中序线索二叉树中找中序前驱 在中序线索二叉树中找到指定结点*p的中序前驱pre
①若p-&gt;ltag == 1,则pre = p-&gt;lchild
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c258408337ae1eda871b6860648f43fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27fc11ceea25b8f1bd851652b40fd465/" rel="bookmark">
			线程池中的核心配置参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于使用
newFixedThreadPool(3); 来创建线程池时，底层创建线程池的方式为：
代表线程池的类为ThreadPoolExecutor。
1、第一个参数为corePoolSize：假设为3，当任务提交过来时，如果线程池中的线程数小于corePoolSize，则会创建新的线程执行该任务；当线程池中的线程数达到3个后，新提交的任务会进入queue队列等待。
2、第二个参数为maximumPoolSize：假设queue队列中只能存放200个任务，当队列被装满时，新来的任务放不进去，则可以创建额外的线程去处理后续提交的任务；maximumPoolSize代表可以创建的额外线程数量。
3、第三个参数为keepAliveTime：当任务都执行完之后，创建出的额外线程的空闲时间，在空闲时间后额外线程会被销毁。
4、第四个参数为queue：用来定义等待任务队列的属性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8792181138068a0a47f93bb974dbe7ab/" rel="bookmark">
			操作系统的进程调度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定义调度策略的准备 操作系统具有底层的机制与上层的调度策略，低层级制例如上下文切换已经在上一篇文章中有所了解，那么上层的策略调度又是什么呢？首先，我们如果要定义一种调度策略，自然首先要思考策略的运行环境以及调度指标。策划你的运行环境就是策略在执行期间会出现的情况，例如：
1. 每一个进程开始执行的时间
2. 每一个进程持续执行的时间
3. 执行中的进程是否会出现空转等待的情况
4. 在调用进程之前操作系统是否就能确认进程的相关信息
。。。。。。
等等，这些都是操作系统为进程制定策略之前需要考虑的问题；
另外对于制定出来的调度策略，还要有明确的衡量指标，包括：
1.周转时间（turnaround time）
周转时间就是任务完成的时间减去任务开始的时间，对于操作系统来说也就是进程执行占用CPU的时间。用公式表示就是：
周转时间 = 完成时间 - 开始时间
如果假设所有进程都从同一时刻开始执行，那么周转时间就等于完成时间；
对于同时需要执行的多个进程来讲，还可以计算他们的平均周转时间（average turnaround time），例如当前有A、B、C三个进程，如果ABC都是从0时刻开始执行，每个要执行10s，那么平均周转时间就等于： （（10-0）+（10-0）+（10-0））/3 = 10s;
2.响应时间（response time）
响应时间定义为从进程到达操作系统到首次运行的时间，用公式表示就是：
响应时间 = 首次运行时间 - 开始时间
例如：有三个进程ABC，其中A在时刻0到达，B和C分别在10与20到达，如果三个进程都需要执行20s，那么也就是A会在20s时执行完毕，开始执行B，B在40s时执行结束开始执行C，C在60s时执行结束。对应的响应时间就是：A 0; B 40 - 20 = 20； C 60 - 10 = 50；
二、先进先出（FIFO） 有了环境假设与衡量指标之后就可以开始定义策略了，在上面计算响应时间的时候ABC的例子其实就是一种策略，ABC按照来的顺序依次执行，只有等到前一个执行结束后一个才可以开始执行，这就是最基本的调度算法：先进先出调度（First In First Out, FIFO）,也被称为先到先服务。这种算法便于理解也便于实现。那么试着衡量一下它：
情况1. 有3个进程ABC，假设几乎都在时刻0到达操作系统，但是A最先C最后，
那么可以得到他们的平均周转时间为：((10-0)+(20-0)+(30-0) )/3 = 20s，平均响应时间为：（(0-0)+(10-0)+(20-0)）/3 = 10;
简单来看还可以，那么再来一个例子：
情况2：还是3个进程ABC， 仍然假设几乎都在时刻0到达操作系统，A最先C最后，但是这次A要执行100s,
那么计算平均周转时间：((100-0)+(110-0)+(120-0))/3=110,平均响应时间：((0-0)+(100-0)+(110-0))/3 = 70;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8792181138068a0a47f93bb974dbe7ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bf5c300851875fad21b2e2ad8863996/" rel="bookmark">
			最实用的Modelsim初级使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大侠带来最实用的Modelsim初级使用教程，话不多说，上货。
一、 Modelsim简介 Modelsim仿真工具是Model公司开发的。它支持Verilog、VHDL以及他们的混合仿真，它可以将整个程序分步执行，使设计者直接看到他的程序下一步要执行的语句，而且在程序执行的任何步骤任何时刻都可以查看任意变量的当前值，可以在Dataflow窗口查看某一单元或模块的输入输出的连续变化等，比quartus自带的仿真器功能强大的多，是目前业界最通用的仿真器之一。
对于初学者，modelsim自带的教程是一个很好的选择，在Help-&gt;SE PDF Documentation-&gt;Tutorial里面.它从简单到复杂、从低级到高级详细地讲述了modelsim的各项功能的使用，简单易懂。但是它也有缺点，就是它里面所有事例的初期准备工作都已经放在example文件夹里，直接将它们添加到modelsim就可以用，它假设使用者对当前操作的前期准备工作都已经很熟悉，所以初学者往往不知道如何做当前操作的前期准备。
二、 安装 同许多其他软件一样，Modelsim SE 同样需要合法的License,通常我们用Kengen产生license.dat。
1、解压安装工具包开始安装，安装时选择Full product安装。当出现Install Hardware Security Key Driver时选择否。当出现Add Modelsim To Path选择是。出现Modelsim License Wizard时选择Close。
2、在C盘根目录新建一个文件夹flexlm，用Keygen产生一个License.dat,然后复制到该文件夹下。若License通过，但是打开ModelSim仍出错，则将系统时间调到2008年之前，重新生成License，再将时间调回来即可。
3、修改系统的环境变量。右键点击桌面我的电脑图标，属性-&gt;高级-&gt;环境变量-&gt;（系统变量）新建。按下图所示内容填写，变量值内如果已经有别的路径了，请用";"将其与要填的路径分开。LM_LICENSE_FILE = c:\flexlm\license.dat
4、安装完毕，可以运行。
注意：
1、电脑的用户名不能为中文； 2、安装路径不能出现中文和空格，只能有数字、英文字母和下划线"_"组成 3、若计算机还需要使用ModelSim-Altera 6.4a (Quartus II 9.0)，可不需做任何额外的设定，ModelSim SE 6.3g会自动抓到这个系统变量，并使用这个license file；反之亦然。
图1 设置modelsim所需环境变量（用户）
关联 Quartus II 和 modelsim 操作
① 完成上述工作之后需要在 Quartus II 中设置 modelsim 路径，Quartus II 菜单Tools ——&gt;General——&gt;EDA Tool Options，进行相关设置，如modelsim：C:\Modeltech_6.3g\win32 如图2所示。
图2 设置modelsim路径
② 在Quartus II建立工程时，设置 modelsim 作为仿真软件，或者是在Assignments——&gt;EDA Tool Settings进行设置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bf5c300851875fad21b2e2ad8863996/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de2eaed62b9ed7866158afac8950b8a0/" rel="bookmark">
			知识图谱用于推荐系统问题（MKR，KTUP，KGAT）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前一篇文章介绍了知识图谱用于推荐系统问题（CKE，RippleNet），这一篇博文目整理对KG和RC融合的更加深入的两篇文章MKR，KTUP。MKR利用一个Cross单元使两者融合，KTUP则是相互补全相互增强的思路。
Multi-task Learning for KG enhanced Recommendation (MKR)
交替学习文章以更好的融合KG和RC。模型图如下：
左边是推荐任务。用户和物品的特征表示作为输入，预测点击率y右边是知识图谱任务。三元组的头结点h和关系r表示作为输入，预测的尾节点t两者的交互由一个cross-feature-sharing units完成 cross-feature-sharing units：由于物品向量和实体向量实际上是对同一个对象的两种描述，他们之间的信息交叉共享可以让两者都获得来自对方的额外信息，从而弥补了自身的信息稀疏性的不足。
计算细节如下。先cross，让v和e外积得到Cl的cross feature：
然后基于词再分别计算下一层的v和e，由权重w控制混合的程度：
最后的损失函数由两部分组成。
Unifying Knowledge Graph Learning and Recommendation:Towards a Better Understanding of User Preferences
统一知识图谱和推荐系统，出自何向南团队在WWW 2019的论文。
知识在提供有关物品的丰富信息方面显示出巨大的潜力，将知识图谱(KG)引入推荐系统去加强用户-物品的交互，有望提高推荐的准确性和可解释性。而这篇论文的主要动机是KG往往有可能是不完整的。如上图所示，Robert Zemeckis和Death Becomes Her之间的红色虚线可能就是缺失的关系。那么假设某用户喜欢Back to The Future和Forrest Gump，我们可以通过相关的实体和关系来理解用户对导演的偏好。但是在关系缺少的条件下，虽然已经准确地捕捉到了用户对电影的偏好，但我们仍然可能无法向用户推荐Death Becomes Her这部电影。
所以在使用KG做推荐时，考虑其不完整的性质是至关重要的，更有趣的是，作者提出KG的补全是否能反过来受益于用户-物品的交互。也就是说如果有一些喜欢这部电影的用户也喜欢Robert Zemeckis导演的其他电影，我们可以预测Robert Zemeckis是Death Becomes Her的导演，即用交互来补全KG。
所以一方面利用KG可以帮助更好的理解用户偏好另一方面，用户-物品的交互可以补全KG，增强KG中缺少的事实 最终使两个部分都得到加强。
算法模型图主要如上，首先利用KG帮助理解用户-物品的行为以得到偏好，然后基于超平面，完成增强项目和偏好与实体和关系的嵌入来共同学习两项任务，其中KG直接增强用户-物品交互，而反向传播微调补全KG。接下来是对它每个部分的细致理解。
KG Embedding
KG Embedding目的是将实体和关系映射到低维连续的向量空间，从而简化KG的相关计算。主要有如下图所示的两种嵌入方法：
TransE：对于KG中的三元组（h,r,t)，尾部实体t的嵌入向量应该接近头实体h的嵌入向量加上一个取决于关系r的向量，简单来说就是 h+r≈t。在理解用户偏好过程中，相应的也就会有用户和物品之间的“关系”应该是用户喜欢该物品，即用户的偏好，于是就有上图的（a）结果，u+p≈i。 TransE简单有效，但是它并不能处理1-N，N-1, N-N的问题。比如，一个导演指导了多部电影，根据头节点h（导演），关系r（指导），尾节点t（电影）进行模型训练，那么这些电影向量的距离是很近的，而事实上他们是完全不同的实体。同理，只要物品嵌入i、i’是相似的，那么不管用户u的偏好p是什么，都会得到一样的结果。
TransH：所以TransH把关系r表示成两个向量，这样对于不同的关系r节点有不同的表示。即把h和t 投影到一个超平面，得到投影向量h⊥和r⊥，然后关系作为在这两个投影向量之间的平移。对于每一种关系都要训练出一个超平面和与之对应的关系r。公式如下： u ⊥ = u − w p T u W p u^{⊥}=u-w_p^TuW_p u⊥=u−wpT​uWp​ i ⊥ = i − w p T i w p i^{⊥}=i-w_p^Tiw_p i⊥=i−wpT​iwp​ 用户-物品的交互和KG嵌入是相似的，所以同样的应该通过偏好进行超平面投影，在超平面上相似的物品会被用户喜欢，这才是正确的结论。所以首先分别对用户-物品和KG的实体都进行嵌入，KG的嵌入损失：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de2eaed62b9ed7866158afac8950b8a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c93963af7867263a1e1e322a5d3928a8/" rel="bookmark">
			为什么 DNS 同时支持 TCP 和 UDP ？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、看到的现象二、实际真相三、用 UDP 还是 TCP ？1、TCP 只有在以下两种情况下，才会使用 TCP 协议1.1 当响应长度超过 512 字节时1.2 DNS 主名字服务器和辅助服务器之间执行区域传送时 2、DNS 在域名解析时使用 UDP 协议2.1 UDP 速度更快2.2 DNS 请求和响应通常很小，适合 UDP 段2.3 可在应用层弥补 UDP 不可靠的缺点 四、为什么抓包看到几乎都是 UDP ？ 一、看到的现象 1、tcpdump 抓包观察到的例子，所见之处， proto 几乎都是 UDP
2、即使通过 tcpdump -i eth1 -vnn tcp port 53 指定去抓 TCP 的包， 等好久也看不到输出…
抓包过程摘录如下：
tcpdump -i eth1 -vnn port 53 tcpdump: listening on eth1, link-type EN10MB (Ethernet), capture size 65535 bytes 16:34:31.205315 IP (tos 0x0, ttl 64, id 44025, offset 0, flags [DF], proto UDP (17), length 61) 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c93963af7867263a1e1e322a5d3928a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff4e425f336978824d950937fcad3e32/" rel="bookmark">
			Beam学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Beam学习笔记 编程指导 https://beam.apache.org/documentation/programming-guide/
创建驱动程序，定义pipeline，包括输入、转换、输出，以及执行参数（主要包括runner，决定pipeline运行的后端）
创建pipeline，设置参数创建初始的PCollection对PCollection应用PTransform：可以对PCollection中每个元素进行修改、过滤、分组、分析等操作，输出新的PCollection；PTransform可以很复杂，自由组合输出最终的PCollection到外部数据源在真实的Runner上运行pipeline 抽象出了
Pipeline：囊括了从头到尾的整个数据处理任务，包括读取输入数据，转换该数据以及写入输出数据。其描述了由PCollection为节点，PTransform为边组成的DAG。PCollection：分布式数据集，不可变，有界或无界（流式数据）PTransform：表示数据处理操作或步骤，输入1个或多个PCollection，对每个元素做处理，输出0个或多个PCollectionI/O Source和Sink PTransform的IO库，用来将数据读取或写入各种外部存储系统的库 Pipeline PipelineOptions options = PipelineOptionsFactory.fromArgs(args).withValidation().create();
解析命令行获取参数 .withValidation验证必填参数是否存在，参数是否合法
扩展参数
通过getter和setter，用注解提供help说明和默认值
public interface MyOptions extends PipelineOptions { @Description("Input for the pipeline") @Default.String("gs://my-bucket/input") String getInput(); void setInput(String input); @Description("Output for the pipeline") @Default.String("gs://my-bucket/output") String getOutput(); void setOutput(String output); } // 注册使用 PipelineOptionsFactory.register(MyOptions.class); MyOptions options = PipelineOptionsFactory.fromArgs(args) .withValidation() .as(MyOptions.class); PCollection TextIO.Read
reads from an external text file and returns a PCollection whose elements are of type String, each String represents one line from the text file
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff4e425f336978824d950937fcad3e32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a734fa1f998f42d8df0c58c5f16d7a4/" rel="bookmark">
			微信小程序埋点技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.埋点技术 是为了让商家知道客户操作的步骤 来判读客户的需求 从而促进成交
2.对于微信小程序埋点有两种方式 a.特定的函数 组件上传 b.通过api
参考:
https://developers.weixin.qq.com/miniprogram/analysis/custom/#%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BC%96%E8%BE%91%E4%B8%8E%E5%8F%91%E5%B8%83
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e341abacc12b8a1cfda23b5e625bf92/" rel="bookmark">
			An Efficient Design and Implementation of LSM-Tree based Key-Value Store on Open-Channel SSD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 各种键值（KV）存储被广泛用于数据管理以支持Internet服务，因为它们提供了比关系数据库系统更高的效率，可伸缩性和可用性。基于日志结构的合并树（LSM-tree）的KV存储吸引了越来越多的关注，因为它们可以消除随机写入并保持可接受的读取性能。最近，随着NAND闪存每单位价格的下降，固态磁盘（SSD）已在企业级数据中心中广泛采用，以提供高I / O带宽和低访问延迟。但是，将基于LSM树的KV存储与SSD幼稚地组合起来效率低下，因为无法充分利用SSD内启用的高度并行性。当前基于LSM树的KV存储在设计时未假设SSD的多通道架构。
为了解决这一不足，我们建议使用LOCS系统，该系统配备了定制的SSD设计，可向应用程序公开其内部闪存通道，以与基于LSM树的KV存储（尤其是LevelDB）配合使用。我们扩展LevelDB以显式利用SSD的多个通道来利用其丰富的并行性。我们优化并发I / O请求的调度和调度策略，以进一步提高数据访问效率。与在常规SSD上运行库存LevelDB的情况相比，应用所有建议的优化技术后，存储系统的吞吐量可以提高4倍以上。
介绍 随着Web 2.0应用程序和云计算的飞速发展，大规模分布式存储系统被广泛部署以支持Internet范围的服务。为了存储超大规模数据和服务高并发访问，使用传统的关系数据库管理系统（RDBMS）作为数据存储可能不是一个有效的选择[15]。对于许多Web应用程序而言，RDBMS的许多特性和功能（例如事务一致性保证和支持复杂的SQL查询）不是必需的。因此，在大数据时代出现了一种新的存储架构，即键值（KV）存储。
键值存储将一组键映射到关联的值，可以将其视为分布式哈希表。与传统的RDBMS [37] [29]相比，无需提供数据库系统通常所需的特性和功能，KV存储可以提供更高的性能，更好的可伸缩性和更高的可用性。他们在数据中心中起着至关重要的作用，以支持许多Internet服务，包括Google的BigTable [18]，Facebook的Cassandra [28]，亚马逊的Dynamo [22]和Github的Redis [4]。
B +树是传统数据库和某些KV store中使用的通用结构。因为它的高扇出有助于减少查询操作的I / O操作数量。但是，使用数据结构支持随机插入和更新的效率非常低。当需要对数据存储进行大量更改时，使用B +树将导致大量昂贵的磁盘搜索并显着降低性能。日志结构的合并树（LSM-tree）[32]是一种针对写入进行优化的数据结构，包括插入，修改和删除。基本思想是通过聚合内存中的多个更新并将它们作为批处理转储到存储中，从而将随机写入转换为顺序写入。传入的数据项被存储在主存储器中保留的缓冲区中，并根据它们的键进行排序。当缓冲区已满时，其所有数据将整体写入到存储中。有很多流行的KV商店都采用基于LSM树的数据管理，包括BigTable [18]，Cassandra [28]，Hbase [9]和LevelDB [10]。
最初提出KV商店时，硬盘驱动器（HDD）被视为其主要目标存储设备。近年来，随着NAND闪存技术的发展，基于闪存的固态磁盘（SSD）的单位容量价格一直在下降。因此，SSD在当今的数据中心中变得越来越流行。与HDD相比，SSD提供更高的吞吐量和更低的延迟，特别是对于随机操作。但是，SSD也有其自身的局限性：随机写入的性能大大落后于顺序写入操作和读取操作的性能，这主要是由于产生了昂贵的垃圾回收[31]。如前所述，由于基于LSM树的KV存储可以有效地消除随机写入，因此，将基于LSM树的KV存储与基于NAND闪存的SSD集成在一起，从而实现读写I的高吞吐量被证明是有希望的/ O操作。
尽管研究人员已经意识到将基于LSM树的KV商店与SSD结合起来的潜在优势[11]，但据我们所知，在以前的工作中尚未对该主题进行很好的研究。实际上，这两种技术的简单集成效率不高。一方面，基于LSM树的KV存储中的数据移动过程最初是为HDD（而非SSD）设计的。由于硬盘驱动器只有一个磁盘头，因此KV存储将向硬盘驱动器串行发出I / O请求。我们需要提高并发级别，以便利用SSD的随机读取性能优势。另一方面，SSD丰富的内部并行性尚未得到充分利用。尽管现代的SSD通常包含多个通道，但SSD控制器硬件仅提供与操作系统的一个块设备接口，并且内部通道之间的I / O请求的调度和分派对于软件层而言是隐藏的。这使得基于LSM树的KV商店不知道SSD的多通道体系结构，并且根据基于LSM树的KV商店的数据访问模式，未优化SSD控制器做出的调度和调度决策。
为了解决这些问题，我们建议使用一种定制的SSD（称为SDF [33]），该SSD仅在最近才可用，以便与基于LSM的流行KV商店LevelDB一起使用[10]。 SDF最初是在百度的数据中心设计和采用的，而百度是中国最大的互联网搜索公司。它提供了独特的功能，其中对内部闪存通道的访问是开放的，并且可以由应用程序管理以充分利用SSD的高带宽。为了利用此独特功能，我们修改了LevelDB以应用许多优化。同时，我们观察到在这种新颖的系统中，调度策略对I / O性能具有至关重要的影响。因此，我们研究如何通过优化的调度和调度策略来提高吞吐量，并考虑使用LevelDB的访问模式的特征。我们的系统称为LOCS，是“ Open Channel SSD上基于LSM树的KV存储”的缩写。
这是将基于LSM树的KVstore与可在应用程序中直接访问其内部通道的开放通道SSD集成的第一项工作。我们扩展了LevelDB以支持多线程I / O访问，以利用SDF中丰富的并行性此外，我们优化了LevelDB的写请求流量控制机制，以利用设备内并行性来提高吞吐量。我们研究了I / O请求调度和调度策略的影响，并提出了相应的优化技术以进一步改进我们提供了广泛的实验结果，表明LOCS可以胜过原始LevelDB与具有类似硬件组织的传统SSD设计的原始集成。结果还表明，使用我们的请求调度和调度优化技术可以进一步提高I / O性能。 本文的其余部分安排如下。第2节介绍了LevelDB，并简要描述了开放通道SSD设计（SDF）。在第3节中，我们描述如何扩展LevelDB，以便它可以与SDF一起有效地工作。此外，我们提出了几种用于调度和调度策略的优化技术，以提高I / O性能。我们还演示了LOCS提供的灵活性。第4节提供了广泛的实验和比较。我们将在第5节中介绍相关文献，然后在第6节中得出结论。
背景 levelDB
当用户在LevelDB中插入键值对时，它将首先保存在日志文件中。然后将其插入到内存中的分类结构中，该结构称为MemTable，用于保存最新更新。当传入数据项的大小达到最大容量时，MemTable将转换为只读的不可变MemTable。将创建一个新的MemTable来累积新的更新。同时，后台线程开始将Immutable MemTable转储到磁盘中并生成新的Sorted String Table文件（SSTable）。删除是其中存储删除标记的更新的特例。
SSTable存储一系列按其键排序的数据项。 SSTable的集合被组织为一系列级别，如图1所示。最年轻的级别Level 0是通过将Immutable MemTable从主内存写入磁盘而产生的。因此，级别0中的SSTables可以包含重叠键。但是，在其他级别，SSTable的关键范围是不重叠的。每个级别对SSTable的最大数量有限制，或者等效地，对数据总量也有限制，因为每个SSTable在级别中具有固定的大小。限制随着级别数以指数速率增长。例如，级别1的最大数据量将不超过10 MB，级别2的最大数据量将不超过100 MB。
为了将存储的数据保持在优化的布局中，将执行压缩过程。后台压缩线程将监视SSTable文件。当级别L的总大小超过其限制时，压缩线程将从级别L中选择一个SSTable，并从下一个级别L + 1中选择所有重叠的SSTable。这些文件用作压缩的输入，并合并在一起以生成一系列新的L + 1级文件。当输出文件达到预定义的大小（默认为2 MB）时，将创建另一个新的SSTable。压缩后将丢弃所有输入。请注意，从级别0到级别1的压缩与其他级别之间的处理不同。当级别0的SSTables的数量超过上限（默认为4）时，将触发压缩。如果某些压缩文件相互重叠，则压缩可能涉及多个0级文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e341abacc12b8a1cfda23b5e625bf92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/642fa5c9cafe3030dfb97fc2e760869e/" rel="bookmark">
			docker 集群搭建及使用docker compose 搭建es集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录下docker 集群搭建及使用docker compose 搭建es集群的过程 一．创建虚拟机二．配置网络三．安装docker四．Swarm配置五．搭建Portainer可视化界面六．使用docker compose搭建elk集群七.踩过的坑 一．创建虚拟机 硬盘64G，内存24G，CPU4，网络适配器网桥，系统安装时设置root用户密码
二．配置网络 vi /etc/sysconfig/network-scripts/ ifcfg-ens33 打开编辑ifcfg-ens33文件；将ONBOOT=no改为yes，将BOOTPROTO=dhcp改为BOOTPROTO=static,并在后面增加几内容：按实际网络情况配置）
IPADDR=192.168.0.225
NETMASK=255.255.255.0
GATEWAY=192.168.0.1
DNS1=119.29.29.29 ；service network restart 重启网络服务；Ifconfig 查看网络配置；systemctl stop firewalld &amp; systemctl disable firewalld 关闭防火墙并禁止开机启动； 三．安装docker 安装工具包 yum install -y yum-utils设置远程仓库 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo安装 yum install docker-ce启动 service docker start 加入开机启动 chkconfig docker on查看版本 docker version校验 docker run hello-world 四．Swarm配置 初始化swarm，在manager（或leader）机器上执行swarm init命令
docker swarm init --advertise-addr 主机ip
运行后将会获得token 如：
Docker swarm join \
–tokenSWMTKN-1-0038kiadp6vm1xrhxjgnao61a04s1m2st0g4p003xv34qn5g27-6ernode3 ur c6fcwrsamnkhdty
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/642fa5c9cafe3030dfb97fc2e760869e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62f1a7d95a9ac3d3590a882103e49d94/" rel="bookmark">
			P5724 【深基4.习5】求极差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述
给出 n(n≤100) 和 n 个整数 ai(0≤ai ≤1000)，求这 n 个整数中的极差是什么。极差的意思是一组数中的最大值减去最小值的差。
输入格式
无
输出格式
无
输入输出样例
输入 #1
6 1 1 4 5 1 4
输出 #1
4
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #include&lt;cstdio&gt; using namespace std; int n,mi = 0,t = 0,ma = 0, m = 0; int main(){ cin &gt;&gt; n; cin &gt;&gt; m; mi = m; ma = m; for (int i = 1; i &lt; n; i++) { cin &gt;&gt; t; if( t &lt; mi) { mi = t; } if ( t &gt; ma) { ma = t; } } cout &lt;&lt; ma - mi; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80079a5b5ddcb76da16b6c478557af75/" rel="bookmark">
			如何重复执行一条命令直至运行成功？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们的日常工作中，需要我们重复做的工作简直不能太多。比如，我们想要确认网络是否是连通的，传统的做法就是使用 ping 命令不停去测试某个地址（比如百度）。网络比较好还好说，但如果网络很差，那么就需要一直去运行 ping 命令。
作为程序员，重复性的工作怎么能忍呢？只要是重复性的工作，就有可能使用编程的方式来解决！
下面良许就介绍两种方法重复执行一条命令直至运行成功。
（PS：本文适合初学者，高手可绕道）
解决重复性的工作，自然而然会想到循环 。在 Shell 里，循环无非 3 种：for、while、until 。在本文里，我们使用后两种循环：while 、until 。
关于这两种循环，有编程基础的小伙伴应该是比较熟悉的了，这里再复习一下。
对于 while 循环，在循环条件是 true 的情况下，它会重复执行循环体（包含在 do ... done结构体里），直到循环条件变成 false 。
而对于 untile 循环，刚好与 while 循环相反，在循环条件是 false 的情况下，它会重复执行循环体（包含在 do ... done 结构体里），直到循环条件变成 true 。
好了，复习完基础知识，我们再来看看如何用这两个循环实现我们的目的。
1. 使用 while 循环
还是以重复测试网络连通性为例。我们可以使用以下命令来解放我们的双手：
$ while ! ping -c 3 baidu.com ; do sleep 2 ; done ; echo succeed 对于这条命令，它将重复执行 ping 命令，如果不成功，则 sleep 2 秒之后继续尝试，直到成功。成功之后，将在终端打印 succeed 字样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80079a5b5ddcb76da16b6c478557af75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/749ca014c5fd63c05233c5e06074f376/" rel="bookmark">
			原生feign的使用之一（post请求 &#43; body）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：本文讲的是原生feign，不是结合spring使用feign
场景描述 在开发的时候遇到一个问题：由于种种原因，需要使用原生feign发起一个post请求，请求体是json格式。
解决方案
见 https://github.com/OpenFeign/feign 的 readme 中 Encoders 部分
测试 先启一个服务，代码很简单
@PostMapping(value = "/address/create") @ResponseBody public String createAddress(@RequestBody Address address) { System.out.println(address.getCountry() + "-----" + address.getProvince()); return "OK"; } Address 类
@Getter @Setter @NoArgsConstructor @AllArgsConstructor public class Address { private String country; private String province; } 上面是服务端的代码，下面看一下客户端的代码
定义 feign 客户端，这里边有两个方法，分别用于测试上图中说的两种情况
public interface AddressClient { @RequestLine("POST /address/create") @Headers("Content-Type: application/json") String createAddress(String content); @RequestLine("POST /address/create") @Headers("Content-Type: application/json") String createAddress(Address address); } 开始测试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/749ca014c5fd63c05233c5e06074f376/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/970356da14daf5103297ca2c53e14e26/" rel="bookmark">
			iOS自动打包问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.遇到问题： *********requires a provisioning profile with the Push Notifications feature******** 解决办法：
脚本文件exportTest.plist添加这个栏目
注意是exportTest.plist，不是项目的info.plist文件
一般手动打包生成的文件夹里面都会有exportTest.plist这个文件
2.又遇到问题 xcodebuild: error: Unknown build action '点金/VL4.0/LOLADFNeverGiveUp.xcworkspace'. 原因：
我的文件夹命名为“12 爱订房”，编译器忽略了“12 ”，明显就是命名不规范，名字里不应该有空格
解决办法：
修改文件夹名字，规范点
3.遇到问题 note: Using new build systemerror: Could not delete `/Users/caolaoshi/widely_publicize/CBBnice/build` because it was not created by the build system.
将这个文件夹删了，重新打包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/378fa8dfcb492772a147c8d864296aa3/" rel="bookmark">
			Error: EBUSY: resource busy or locked 报错（vue）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用 npm i 安装依赖的时候报错 Error: EBUSY: resource busy or locked, lstat ‘C:\swapfile.sys’。
下面是我总结的一些有效方法：
方法一：删除 node_modules，然后再安装（npm i）；
方法二：删除 node_modules，运行 npm cache clean 或者 npm cache clean --force 命令， 然后安装；
方法三：升级一下node版本，删除node_modules，然后再安装。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4ed04fa98cede92dc229c1d7191ecc3/" rel="bookmark">
			Docker教程（一）入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是 Docker 官网的介绍是“Docker is the world’s leading software container platform.” 官方给Docker的定位是一个应用容器平台。
Docker 是一个容器平台的领导者 Docker 容器平台 Docker 应用容器平台
application项目 Mysql Redis MongoDB ElasticSeacrh …
application项目 Docker 应用容器平台 Mysql Redis mongoDB ElasticSearch tomcat nginx…
2.为什么是Docker 合作开发的时候，在本机可以跑，别人的电脑跑不起来
这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、spring等等。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序直接打包成镜像，直接运行在容器中即可。
服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了
这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。
公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器
在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。
3.Docker和虚拟机区别 关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。
比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存-&gt;虚拟物理内存-&gt;真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存-&gt;真正物理内存。
传统虚拟机Docker容器磁盘占用几个GB到几十个GB左右几十MB到几百MB左右CPU内存占用虚拟操作系统非常占用CPU和内存Docker引擎占用极低启动速度（从开机到运行项目）几分钟（从开启容器到运行项目）几秒安装管理需要专门的运维技术安装、管理方便应用部署每次部署都费时费力从第二次部署开始轻松简捷耦合性多个应用服务安装到一起，容易互相影响每个应用服务一个容器，达成隔离系统依赖无需求相同或相似的内核，目前推荐是Linux 4.Docker 的核心 镜像: 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等容器: 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写仓库:用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置dockerFile:docker生成镜像配置文件,用来书写自定义镜像的一些配置tar:一个对镜像打包的文件,日后可以还原成镜像 4.Docker的安装(centos7.x) 5.1 卸载原有 docker $ sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4ed04fa98cede92dc229c1d7191ecc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dde2365d8e9b7993987246c8b2cbcbd/" rel="bookmark">
			jmap在Linux下无法使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Linxu下使用jmap出现以下情况:
解决办法:
echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfe2390e6c481d0d832d1affca045d77/" rel="bookmark">
			京东运维面经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、lvs、nginx做负载均衡，是对什么做的转发，怎么做的转发；
2、怎么做mysql的负载均衡；
3、给你一百台机器怎么给做监控；
对学的知识点和项目中技术要清楚为什么这么做，明白原理的本质是要干什么。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a70458eaf8b8ff729255437850912acb/" rel="bookmark">
			前缀和、哈希用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路：遇到这种连续子数组的问题，通常有的方法：
滑动窗口法（先通过移动right到达包涵要求的解，然后left再优化，而这个题目不符合这种要求）动态规划（最长连续上升子序列）前缀和 1.【leetcode560】和为K的子数组
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
示例 1 :
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
说明 :
数组的长度为 [1, 20,000]。
数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。
思路：前缀和根本思路在于推导presum[j] - presum[i - 1] = sum(i, j)，如果presum[j] - presum[i - 1]=k,那么presum在生成的过程中，利用哈希表查找是否存在presum-k的元素存在，记录presum-k存在的次数即为和presum组合的子数组的个数；还要注意边界即一个元素也需要记录个数。
class Solution: def subarraySum(self, nums: List[int], k: int) -&gt; int: hashmap = {0:1} presum = 0 res = 0 for i in range(len(nums)): presum += nums[i] if presum - k in hashmap: res += hashmap[presum - k] hashmap[presum] = hashmap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a70458eaf8b8ff729255437850912acb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/813bc42ba38f261dd19bf0215276c44a/" rel="bookmark">
			PV、TPS、QPS是怎么计算出来的？-性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		术语说明：
QPS = req/sec = 请求数/秒
【QPS计算PV和机器的方式】
QPS统计方式 [一般使用 http_load 进行统计]
QPS = 总请求数 / ( 进程总数 * 请求时间 )
QPS: 单个进程每秒请求服务器的成功次数
单台服务器每天PV计算
公式1：每天总PV = QPS * 3600 * 6
公式2：每天总PV = QPS * 3600 * 8
服务器计算
服务器数量 = ceil( 每天总PV / 单台服务器每天总PV )
【峰值QPS和机器计算公式】
原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间
公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器
问：每天300w PV 的在单台机器上，这台机器需要多少QPS？
答：( 3000000 * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/813bc42ba38f261dd19bf0215276c44a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a7aacdbf0211a243b76f4e0f377692d/" rel="bookmark">
			微信小程序如何自定义字体wx.loadFontFace
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.加载网络字体资源
Page({ /** * 页面的初始数据 */ data: { loaded :false }, // 字体 loadFontFace() { wx.loadFontFace({ global:true, // 版本 2.10.0 后 全局app.js 使用 family: 'font', source: 'url("https://xxx.com/font/font.TTF")',// 不是真的链接 success: (res) =&gt; { console.log(res.status) this.setData({ loaded: true }) }, fail: function (res) { this.setData({ loaded: false }) }, complete: function (res) { } }); }, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) { this.loadFontFace() }, }) 2.局部使用字体
.font-loaded { font-family: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a7aacdbf0211a243b76f4e0f377692d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/947ddef138a270368e2d55d4e4a978ee/" rel="bookmark">
			SQL_MySQL常用函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL_MySQL常用函数 1、聚合函数。2、字符串函数。2.1 length(str) : 统计字节长度；char_length(str) : 统计字符长度(字符个数)。2.2 sub_str(s,n,len):从字符串s的n位置开始截取长度为len的字符。2.3 right(s,n) : 从字符串s的右端（从后往前）截取n个字符；left(s,n) : 从字符串s的左端（从前往后）截取n个字符。2.4 insert(s1,x,len,s2 )将字符串s1中x位置开始len长度的字符内容，使用s2来替换。2.5 replace(s,s1,s2)将字符串s中的s1内容替换为s2. 3、日期函数。3.1 current_date() : 当前系统日期；current_time() : 当前系统时间；now() : 当前系统日期 + 时间。3.2 分别获取各个部分的日期值。3.3 按照表达式，获取日期时间的各个部分值 1、聚合函数。 求和sum()、平均值avg()、最大值max()、最小值min()、个数统计count()。
-- 统计指定电影的上映期间的累计票房和、平均票房 select sum(leijipiaofang),avg(leijipiaofang) from north_american_box_office where zhongwenpianming like'%速度与激情%' -- 统计指定电影的最长上映天数，最短上映天数 select max(shangyingtianshu),min(shangyingtianshu) from north_american_box_office where zhongwenpianming like '%速度与激情%' 2、字符串函数。 2.1 length(str) : 统计字节长度；char_length(str) : 统计字符长度(字符个数)。 -- 查询员工姓名的字符长度和员工身份证的字节长度。 select emp_name, char_length(emp_name), id_card_no, length(id_card_no) from employee_info -- 举例 ：查找employee_info表中身份证号码不正确的数据 select * from employee_info where char_length(id_card_no) not in(18 , 15) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/947ddef138a270368e2d55d4e4a978ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e496f14db44babf480e22ac7dfdcf1c0/" rel="bookmark">
			中望CAD.NET二次开发（C#）_第01篇_环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中望CAD版本：2020
VS版本：2013
一、创建类库项目
二、添加引用
添加对ZwDatabaseMgd.dll和ZwManaged.dll的引用
（这两个DLL位于中望CAD安装目录下）
三、导入命名空间
using ZwSoft.ZwCAD.Runtime; using ZwSoft.ZwCAD.DatabaseServices; using ZwSoft.ZwCAD.EditorInput; using ZwSoft.ZwCAD.ApplicationServices; 四、在默认类Class1中添加如下代码
[CommandMethod("Hello")] public void Hello() { Editor ed = ZwSoft.ZwCAD.ApplicationServices.Application.DocumentManager.MdiActiveDocument.Editor; ed.WriteMessage("欢迎进入.NET开发中望CAD的世界！"); } 五、编译程序。
六、启动中望CAD，在命令行中输入netload，加载编译生成的ClassLibrary1.dll
七、在命令行中输入Hello，命令行中会显示“欢迎进入.NET开发中望CAD的世界！”
完整代码如下
using System; using System.Collections.Generic; using System.Linq; using System.Text; using ZwSoft.ZwCAD.Runtime; using ZwSoft.ZwCAD.DatabaseServices; using ZwSoft.ZwCAD.EditorInput; using ZwSoft.ZwCAD.ApplicationServices; namespace ClassLibrary1 { public class Class1 { [CommandMethod("Hello")] public void Hello() { Editor ed = ZwSoft.ZwCAD.ApplicationServices.Application.DocumentManager.MdiActiveDocument.Editor; ed.WriteMessage("欢迎进入.NET开发中望CAD的世界！"); } } } 小编QQ：3088489873
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b8f125135f460e7137df231542683a8/" rel="bookmark">
			平衡二叉搜索树的插入与删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下内容主要参考了严蔚敏版的《数据结构》教材，但是教材里面只介绍了插入操作没有介绍删除操作，刚好在这篇文章里面有介绍删除操作且他好像也是参考严蔚敏版的《数据结构》教材里面的内容，因此我的删除操作主要参考于他这篇文章。
二叉树中的一个节点的平衡因子为其左子树的高度减去其右子树的高度的值。如果一颗二叉树中所有节点的平衡因子的绝对值都小于2则这颗二叉树是一颗平衡的二叉树，否则该二叉树是不平衡的。在这里我们同时假定这里的二叉树是二叉搜索树。平衡二叉搜索树和不平衡二叉搜索树的例子见图1。
图 1. 如果首先不去理会二叉树的平衡性，则插入与删除操作就是二叉搜索树的插入与删除。对于插入操作，首先是在二叉树中查找有没有要插入的元素如果有则返回，不进行任何操作，如果没有则新建一节点并将该节点插入到某个节点（查找待插入元素时遇到的空节点父节点）的左孩子或右孩子。对于删除操作，如果二叉搜索树中不存在待删除的元素，则立即返回不做任何操作。如果待删除的元素在二叉搜索树中只有左子树或只有右子树，则将其左子树或右子树设为待删除的元素父节点的左子树或右子树（这要看待删除元素是其父节点的左孩子还是右孩子）。此种情况的例子见图2。
图 2. 如果待删除节点既有左孩子又有右孩子，此时可以用在中序遍历中该节点的直接前驱或者直接后继替代该节点。如果是用其直接前驱替代该节点，则该直接前驱必定是该节点左子树中最右的节点，也是其左子树中值最大的节点且其右子树为空。替代完之后删除前驱节点即可，此时转换为删除只有左子树或只有右子树的节点的情况。如果是用其直接后继替代该节点，则该直接后继必定是该节点右子树中最左的节点，也是其左子树中值最小的节点且为叶子节点。替代完之后删除后继节点即可，此时转换为删除叶子节点的情况。此种情况的例子见图3。
图 3. 如果待删除节点既有左孩子又有右孩子。若待删除节点为其父节点的左孩子，节点S为待删除节点在中序遍历序列中的直接前驱（节点S的右孩子为空），则可以将待删除节点的左子树设为其父节点的左子树，将待删除节点的右子树设为节点S的右子树。若待删除节点为其父节点的左孩子，节点S为待删除节点在中序遍历序列中的直接后继（节点S的左孩子为空），则可以将待删除节点的右子树设为其父节点的左子树，将待删除节点的左子树设为节点S的左子树。此种情况的例子见图4。若待删除节点为其父节点的右孩子，节点S为待删除节点在中序遍历序列中的直接后继（节点S的左孩子为空），则可以将待删除节点的右子树设为其父节点的右子树，将待删除节点的左子树设为节点S的左子树。若待删除节点为其父节点的右孩子，节点S为待删除节点在中序遍历序列中的直接前驱（节点S的右孩子为空），则可以将待删除节点的左子树设为其父节点的右子树，将待删除节点的右子树设为节点S的右子树。此种情况的例子见图5。
图 4. 图 5. 在以下平衡二叉搜索树删除算法的实现中，如果待删除节点既有左孩子又有右孩子，我们用在中序遍历中该节点的直接前驱替代该节点。
在平衡二叉搜索树中插入或删除节点后，如果没有改变平衡性则不必理会。如果出现不平衡的情况则必须进行调整使得其恢复平衡特性。假设由于在平衡二叉搜索树中插入节点D而失去平衡的最小子树根节点为A（即离插入节点D最近且平衡因子绝对值超过1的祖先节点），则失去平衡后进行调整的规律可以归纳为以下四种情况，分别如图6、7、8、9所示：
左平衡处理：单向右旋恢复平衡（在节点A的左孩子的左子树中插入节点使得以A为根节点的子树失去平衡）左平衡处理：单向左旋+单向右旋恢复平衡（在节点A的左孩子的右子树中插入节点使得以A为根节点的子树失去平衡）右平衡处理：单向左旋恢复平衡（在节点A的右孩子的右子树中插入节点使得以A为根节点的子树失去平衡）右平衡处理：单向右旋+单向左旋恢复平衡（在节点A的右孩子的左子树中插入节点使得以A为根节点的子树失去平衡） 图 6. 图 7. 图 8. 图 9. 从以上操作可以看出一共有两种平衡处理（左平衡处理：在节点A的左子树中插入节点使得树不在平衡，右平衡处理：在节点A的右子树中插入节点使得树不再平衡，）以及两种旋转操作（左旋以及右旋）。两种平衡处理分别对应函数 B i n a r y S e a r c h N o d e ∗ l e f t B a l a n c e ( B i n a r y S e a r c h N o d e ∗ r o o t , B i n a r y S e a r c h N o d e ∗ f a t h e r ) BinarySearchNode* leftBalance(BinarySearchNode* root, BinarySearchNode* father) BinarySearchNode∗leftBalance(BinarySearchNode∗root,BinarySearchNode∗father)和 B i n a r y S e a r c h N o d e ∗ r i g h t B a l a n c e ( B i n a r y S e a r c h N o d e ∗ r o o t , B i n a r y S e a r c h N o d e ∗ f a t h e r ) BinarySearchNode* rightBalance(BinarySearchNode * root, BinarySearchNode * father) BinarySearchNode∗rightBalance(BinarySearchNode∗root,BinarySearchNode∗father),两种旋转操作分别对应函数 B i n a r y S e a r c h N o d e ∗ R _ R o t a t e ( B i n a r y S e a r c h N o d e ∗ r o o t , B i n a r y S e a r c h N o d e ∗ f a t h e r ) BinarySearchNode* R\_Rotate(BinarySearchNode* root, BinarySearchNode* father) BinarySearchNode∗R_Rotate(BinarySearchNode∗root,BinarySearchNode∗father)和 B i n a r y S e a r c h N o d e ∗ L _ R o t a t e ( B i n a r y S e a r c h N o d e ∗ r o o t , B i n a r y S e a r c h N o d e ∗ f a t h e r ) BinarySearchNode* L\_Rotate(BinarySearchNode* root, BinarySearchNode* father) BinarySearchNode∗L_Rotate(BinarySearchNode∗root,BinarySearchNode∗father)。对于具体的实现请看源码解释。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b8f125135f460e7137df231542683a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60dc606b7ad90275bfcfe3ebb71f7aef/" rel="bookmark">
			H5移动端输入框随键盘上移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		textarea置底展示问题 ios 中的输入体验永远伴随着一个问题，就是当唤起键盘后，整个页面会被键盘压缩，也就是说页面的高度变小，并且所有的fixed全部变为了absolute。
android效果：
使用 fixed 定位。
可见 android 中唤起键盘是覆盖在页面上，不会压缩页面。
在 ios 上的效果：
那么如果我们需要将输入框固定在屏幕下方，而当键盘被唤起同时输入框固定在键盘上方（如下图样式）该如何解决呢？
首先我们来看下 ios 的表现。
可以看出，键盘会将页面顶上去。那么如果希望可以将输入框和键盘完全贴合，我们可以使用div模拟一个假的输入框，使用定位将真正的输入框隐藏掉，当点击假的输入框的时候，将真正的输入框定位到键盘上方，并且手动获取输入框焦点。
在实现过程中需要注意下面几个问题：
1、真正的输入框的位置计算：
首先记录无键盘时的 window.innerHeight，当键盘弹出后再获取当前的 window.innerHeight ，两者的差值即为键盘的高度，那么定位真输入框自然就很容易了。
2、在 ios 下手动获取焦点不可以用 click 事件，需要使用 tap 事件才可以手动触发
$('#fake-input').on($.os.ios?'tap' : 'click', function() { initHeight = window.innerHeight; $('#input').focus(); }); 3、当键盘收起的时候我们需要将真输入框再次隐藏掉，除了使用失去焦点（blur）方法，还有什么方法可以判断键盘是否收起呢？
这里可以使用 setInterval 监听，当当前 window.innerHeight 和整屏高度相等的时候判断为键盘收起。
注意：键盘弹起需要一点时间，所以计算当前屏幕高度也需要使用setInterval。
4、因为 textarea 中的文字不能置底显示，当输入超过一行textarea需要自动调整高度，因此将scrollHeight赋值给textarea的height。当删除文字的时候需要height也有变化，因此每次input都先将height置0，然后再赋值。
$('#textarea').css('height', 0); $('#textarea').css('height', $('#textarea')[0].scrollHeight); 仿原生效果 解决webview中input被遮挡后webview整体在iOS壳子中向上滚动,而不是仅input随着键盘抬高问题
js中代码:
&lt;div id="commentInputDiv" onClick={() =&gt; { $("#commentInputItem").show(); $("#commentInputDiv").hide(); const handler = window["webkit"] &amp;&amp; webkit &amp;&amp; webkit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60dc606b7ad90275bfcfe3ebb71f7aef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a0fe827eca87956cecc445c29d626b/" rel="bookmark">
			CentOS开机时出现GRUB引导错误怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS在开机的时候，突然出现了GRUB引导错误，导致系统进入不了，遇到这种情况很多人就束手无策了，其实这类的问题不难解决，请按照以下步骤进行操作即可。 解决办法：使用CentOS安装光盘进行开机GRUB引导修复 具体操作： 1.使用CentOS系统光盘引导计算机（系统盘要与原来安装的系统版本相同 2.按F5进入系统修复模式，出现下面的界面 3.输入：linux rescue 回车 4.默认OK，选择Continue出现下面的界面 5.输入：chroot /mnt/sysimage ，回车 #将当前目录切换到原来系统的根目录 6.继续输入：grub 回车，出现下面的界面 输入：root （hd0，0） 回车 #注意root与（hd0，0） 之间必须要有空格 继续输入：setup （hd0） 回车 #注意root与（hd0） 之间必须要有空格 再次输入：quit 回车 #退出grub模式 最后输入：reboot #重启系统 拿出光盘，grub修复完毕，可以正常进入系统 备注：如果通过上面的操作还是无法正常进入系统 可以在 输入：chroot /mnt/sysimage 之后继续输入 vi /boot/grub/grub.conf #编辑，添加以下内容（CentOS 5.9为例） # grub.conf generated by anaconda # # Note that you do not have to rerun grub after making changes to this file # NOTICE： You have a /boot partition. This means that # all kernel and initrd paths are relative to /boot/， eg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44a0fe827eca87956cecc445c29d626b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4b261444f31446e0cf1fb8f088ee8e5/" rel="bookmark">
			react next.js打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在打包的时候如果遇到以下问题，
原因可能是引入第三方库配置时导致的
解决：
删除 .babelrc中 style:css
新建_app.js文件
import App from 'next/app' import 'antd/dist/antd.css' export default App 然后重启再npm run build打包就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f92f39326e89a8d5e6d390dfb9b58faa/" rel="bookmark">
			ConcurrentHashMap实现线程安全的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当多个线程去访问同一个数据时，为了保证线程安全，可以进行synchronized加锁，使用CAS机制进行安全的累加。
考虑当多个线程同时去读写一个HashMap时，如何保证集合内元素的数据安全？
假设使用synchronized加锁机制，同一时间只能有一个线程对HashMap进行put操作，效率明显是很低的，因为数组里有很多个元素，除非是对同一个元素进行put操作，否则是没必要让线程串行执行的。
一、JDK1.7中的ConcurrentHashMap 实现线程安全的原理：分段加锁
将原集合底层的数组拆分成很多个小数组：
[数组]——&gt;[数组1]，[数组2]，[数组3]，[数组4]…
每个数组都会对应一把不同的锁；
只有当多个线程操作同一个小数组时，才会发生线程串行的情形。
二、JDK1.8中的ConcurrentHashMap JDK1.8之后，进行了锁粒度的细化
又变成了一个大数组，假设两个线程同时对数组的第一个位置进行put操作，则会采取CAS策略，保证线程并发的安全性，同一时间只有一个线程成功执行CAS操作；
在插入元素的过程中，会给插入的数组元素加上synchronized锁，再基于链表和红黑树插入数据，也就是数组的一个元素对应了一把锁。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d24d563a9607d1a4fce0488f1f783696/" rel="bookmark">
			Flink_探究Flink on YARN模式下TaskManager的内存分配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：
https://www.jianshu.com/p/4e4c188f5d7b
一个问题 我们使用如下的参数提交了Flink on YARN作业（per-job模式）。
/opt/flink-1.9.0/bin/flink run \ --detached \ --jobmanager yarn-cluster \ --yarnname "x.y.z" \ --yarnjobManagerMemory 2048 \ --yarntaskManagerMemory 4096 \ --yarnslots 2 \ --parallelism 20 \ --class x.y.z \ xyz-1.0.jar 该作业启动了10个TaskManager，并正常运行。来到该任务的Web界面，随便打开一个TaskManager页面，看看它的内存情况。
可见，虽然我们在参数中设置了TaskManager的内存为4GB大，但是上图显示的JVM堆大小只有2.47GB，另外还有一项“Flink Managed Memory”为1.78GB。在用VisualVM监控YarnTaskExecutorRunner时，会发现其JVM内存参数被如下设置：
显然Xmx+MaxDirectMemorySize才是我们在启动参数中设定的TM内存大小（4GB）。那么为什么会这样设置？“Flink Managed Memory”又是什么鬼？下面就来弄懂这些问题。
TaskManager内存布局 如下图所示。
为了减少object overhead，Flink主要采用序列化的方式存储各种对象。序列化存储的最小单位叫做MemorySegment，底层为字节数组，大小由taskmanager.memory.segment-size参数指定，默认32KB大。下面分别介绍各块内存：
网络缓存（Network Buffer）：用于网络传输及与网络相关的动作（shuffle、广播等）的内存块，由MemorySegment组成。从Flink 1.5版本之后，网络缓存固定分配在堆外，这样可以充分利用零拷贝等技术。与它相关的三个参数及我们的设定值如下： # 网络缓存占TM内存的默认比例，默认0.1 taskmanager.network.memory.fraction: 0.15 # 网络缓存的最小值和最大值 ，默认64MB和1GB taskmanager.network.memory.min: 128mb taskmanager.network.memory.max: 1gb 托管内存（Flink Managed Memory）：用于所有Flink内部算子逻辑的内存分配，以及中间数据的存储，同样由MemorySegment组成，并通过Flink的MemoryManager组件管理。它默认在堆内分配，如果开启堆外内存分配的开关，也可以在堆内、堆外同时分配。与它相关的两个参数如下： # 堆内托管内存占TM堆内内存的比例，默认0.7 taskmanager.memory.fraction: 0.7 # 是否允许分配堆外托管内存，默认不允许 taskmanager.memory.off-heap: false 由此也可见，Flink的内存管理不像Spark一样区分Storage和Execution内存，而是直接合二为一，更加灵活。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d24d563a9607d1a4fce0488f1f783696/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7962d915fe92dd92b9a269f19fcda7e/" rel="bookmark">
			leetcode--287寻找重复数（001）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。
示例 1: 输入: [1,3,4,2,2] 输出: 2 示例 2: 输入: [3,1,3,4,2] 输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 方法1：二分法
因为题目的要求比较多，所以hash不能使用，最开始采用暴力解法，也通过了，但实际上暴力解法时间复杂度是O(n2)。
采用二分法时间复杂度是O(nlogn)。之所以用到二分法，需要我们注意到一个条件 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间。那么找到1-n的mid数，然后遍历数组，看小于等于mid的个数，如果个数小于等于mid，则说明在[mid+1,n]里面寻找，否则在[1，mid]里面，然后不断缩小寻找到的区间。
class Solution { public: int findDuplicate(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int left = 1, right = n; while(left &lt; right){ int mid = left + (right - left)/2; int cnt = 0; for(int num : nums) //循环O(nlogn)次。 if(num &lt;= mid) cnt++; if(cnt &lt;= mid) left = mid + 1; else right = mid; } return right; } }; 方法2：快慢指针（看了好久）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7962d915fe92dd92b9a269f19fcda7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd05195cebd97cf251a9ccef22c781bf/" rel="bookmark">
			Android DNS Resolver
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DNS 解析器（DNS Resolver） DNS 解析器模块可保护用户免受 DNS 拦截和配置更新攻击，并改进了 DNS 解析的网络性能。此模块包含用于实现 DNS 桩解析器的代码，该解析器可将 www.google.com 等名称转换为 IP 地址（例如 2001:db8::1）。DNS 桩解析器支持 Java API 元素（如 InetAddress#getAllByName 和 Network#getAllByName）以及原生网络功能，且可发送和接收 DNS 查询以及缓存结果。
Android 10 中的变化 在搭载 Android 9 及更低版本的设备上，DNS 解析器代码分布在 Bionic 和 netd 上。DNS 查找操作集中在 netd 守护程序中，以便进行系统级缓存，而应用在 Bionic 中调用函数（例如 getaddrinfo）。查询会通过 UNIX 套接字发送到 /dev/socket/dnsproxyd，再到 netd 守护程序，该守护程序会解析请求并再次调用 getaddrinfo，以发出 DNS 查找请求，然后它会缓存结果以供其他应用使用。DNS 解析器实现主要包含在 bionic/libc/dns/ 中，部分包含在 system/netd/server/dns 中。
Android 10 将 DNS 解析器代码移至 system/netd/resolv,，将其转换为 C++，然后对代码进行了翻新和重构。由于应用兼容性方面的原因，Bionic 中的代码继续存在，但系统不会再调用它们。以下源文件路径受到重构的影响：
bionic/libc/dnssystem/netd/clientsystem/netd/server/dnssystem/netd/server/DnsProxyListener.*system/netd/resolv （1）获取ip地址（域名–&gt;IP地址）
ConnectivityService.updateDnses() -&gt;
DnsManager.setDnsConfigurationForNetwork() -&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd05195cebd97cf251a9ccef22c781bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5edb3cf08f16aa20e5ff83d6374eb448/" rel="bookmark">
			书友汇德天帮助小白正确区分plot,subplot,subplots三个命令之间关系！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 对于一个知识点学习，我一直本着多看，多想，多分析的态度，一方面，通过思考可以让模糊的知识变清晰，另一方面，通过思考可以让你有办法找到更多的想法，遵循你的想法去寻找你想要的答案！ 关于Matplotlib数据分析绘制图形我们已经有过几篇文章的介绍，但是个人觉得所介绍的内容还不足以让大家彻底把问题弄清晰，因为决定沿着知识的轨迹，继续寻找能够让大家更好理解的方式，从而能够快速的找到问题的答案。
python可视化数据化分析离不开画图，在系统中经常会导入Matplotlib库中的子模块pyplot来进行图形的绘画工作。
#导入模块,为了简化把模块重新命名plt import matplotlib.pyplot as plt 我们就从这里开始讲起！
1、系统在导入plt简化模块后，会自动的命名，这里我们如果只有一个绘图区域使用，使用系统默认的最简单了！上干货！ #系统直接利用模块来进行坐标点（1，3）和点(2,4)进行连线 plt.plot([1,2],[3,4]) plt.show() 绘制后的效果图形展示：
2、一块画布仅仅画一幅图，显示远远不能满足需要，所以对于画布分割就显得非常重要这时需要用到另外的命令 知识拆分：
subplot()函数
这个命令可以在系统画布上，分割多个不同的区域，并对每一个区域进行独立操作subplot(2,2)，这是一个把画布分成2行，2列的子画布分割，如果想使用其中一个区域，应该这样定义subplot(2,2,1)，最后面的1表示，当前使用第一个画布区域进行绘图。我们对第一区域重新命名为ax1,并在这个区域上绘制一条直线
#系统直接利用坐标点（1,3）和点(2,4)进行连线 #模块导入 import matplotlib.pyplot as plt #开始分割画布绘图 ax1 = plt.subplot(2,2,1) ax1.plot([1,2],[3,4]) plt.show() 4、我们仅仅是使用了一个区域，按照分布我们可以有四个区域，这里我们只讲解两个，另外两个大家可以自己练习。
6、对第二区域进行同样的直线绘制，我们对第二区域命名为ax2，这里要注意一下subplot要定位好分割区（2,2,2)，也就是把前面的1改为2，这样系统才能正确把两个绘制区域显示出来
import matplotlib.pyplot as plt ax1 = plt.subplot(2,2,1) ax1.plot([1,2],[3,4]) ax2 = plt.subplot(2,2,2) ax2.plot([1,2],[3,4]) plt.show() 3、另外还有一个命令，subplots()也可以对画布进行分割，并进行绘制，那么这个和我们第2个部分所讲的区别在哪里呢？ 知识拆分：
subplots()函数，把画布分割区域放入数组，也就是说我们可以通过索引的方式对每一个分割区进行独立操作。
6、比如我们先来把画布分割成2行3列结构
fig,axs = plt.subplots(2,3) 7、大家注意这里的命名很简单，但是等号左边有fig,axs这是什么意思？
fig，是我们重新为画布起的新名字，也就是我们现在不用系统默认的名称，重新命名。
8、axs这个名称呢，你可以理解成是把这2行3列，6个分割区定义的一个总名称，我们前面不是说，分割区域被放入数组中了吗，那一会你就可以按照这个总名称+数字索引的方式对每一个分割绘图区域进行修改和操作，特别方便，
9、按照我们分割的绘图区域，分别给单独的绘图区域起名字如下，前面0表示行，这里有0，1两行，0行后面有0,1,2表示3列对应编号内容
axs[0,0].set_title('子图1') axs[0,1].set_title('子图2') axs[0,2].set_title('子图3') axs[1,0].set_title('子图4') axs[1,1].set_title('子图5') axs[1,2].set_title('子图6') 10、接下来我们再给0行的第一个分割区axs[0,0]和第二个分割区axs[0,1]，画上两条线
axs[0,0].plot([1,2], [3,4]) axs[0,1].plot([1,2], [3,4]) 从上面的三点分析，我们最后明白，对于不同的实际工作需要，Python给到我们非常灵活的绘图区域定义的能力，这极大的方便了我们的工作，但由于使用的命令繁多，也常常令大家眼花缭乱，所以在这里根据我的理解给大家认真的做了分析，后面，我们会结合实际使用需要，依次给大家完善的课程内容！关注，转发，点赞！您的支持是我们写下去的动力。
感谢屏幕前的亲爱的你！让我们学习路上共同前行！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e577453cfad5a1c41e311927ad5884a/" rel="bookmark">
			c中输入一个十进制数，输出它的八进制二进制以及十六进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码：
#include &lt;stdio.h&gt; int main() {	int i; scanf("%d",&amp;i); printf("八进制为：%o\n",i); printf("十六进制为：%x\n",i); printf("十六进制为：%X\n",i); return 0; } 可以看出来，16进制小写‘x’输出的字母就是小写的，大写‘X’输出的字母就是大写的
想要以16进制或者8进制输入时：
以16进制为例，将输入语句改为：
scanf("%x",&amp;i); b：二进制
o：八进制
d：十进制
x，X：16进制
程序里是体现不出二进制的哦！
下面两种转换方法
递归转换进制（int型）
#include&lt;stdio.h&gt; int fact(int n) { if(n&lt;2) //将 2 换成其它数如 8 就可输出 8 进制的结果 return n; else { return fact(n/2)*10+n%2; //将二进制结果整个输出 } } int main() { int n; scanf("%d",&amp;n); printf("%d",fact(n)); return 0; } 循环：
#include&lt;stdio.h&gt; main() { int k,a[101],i=0; printf("请你输入一个十进制整数\n"); scanf("%d",&amp;k); while (k&gt;0) { a[i]=k%2; k/=2; i++; } for(i=i-1;i&gt;=0;i--) //i=i-1 的原因 ，条件k&gt;0为假结束循环，但i++已经运行了，所以 i=i-1 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e577453cfad5a1c41e311927ad5884a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d267a239cde002c6c5eb5c8a29071fb4/" rel="bookmark">
			05-《Product-based Neural Networks for User Response Prediction》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. PNN Product-based Neural Networks，简称PNN，由上海交通大学在2016年提出。用于CTR预测。
PNN，使用embedding layer学习categorial data的分布式表示；使用product layer去捕获interfield categories的交叉模式；使用connected laye去探索高阶特征交叉。
在此之前，DNN在分类和回归任务中有很好的性能。
DNN可以自动学习更有表现力的特征表示，并提供很好的预测性能。基于连接的embedding vector基础上，建立MLPs可以探索特征交叉。但是DNN存在两个问题：（1）嵌入的初始化的质量在很大程度上受到因子分解机的限制；（2）感知器层的“add”操作对于探索多个字段中categorical数据的交叉可能不是很有用。
有工作已经证明，不同fields的特征依赖关系，可以通过特性向量“product”操作而不是“add”操作来有效探索。
通过在product layer使用inner product和outer product，文章提出了两种PNN模型：IPNN，OPNN。
一些定义：
我们使用表示第i个隐藏层的维度。
内积公式：
Input 首先，原始样本数据是多类别的categorial数据，如用户信息（City，Hour），出版社信息（Domain，Ad slot），广告信息（Ad create ID，Campania ID）等。这些数据都需要经过one-hot编码，变成特征向量（feature vector ），即Filed1，Fidld2等等。
EMbedding Layer 特征向量输入进该层，得到embedding vector。Feature1就代表着Field1的嵌入向量。我们称Featrue1为,Feature2为.
。x是Input中的ont-hot 特征向量。
Product Layer 通过嵌入层提供的“1”,这样一个常量信号，该层不仅可以产生二次信号p，还能生成线性信号z。
我们可以看到，z中的每一个向量元素，其实就是上一层嵌入向量，即复制，它没有经过任何改变。，代表这特征交叉，g函数可以有不同的实现方式。之前提到的IPNN和OPNN，就是分别将g函数设为内积和外积。
Hidden Layer 1 该层的输入包括的线性信号以及二次线性。 Hidden Layer 2 CTR ，
损失函数 2. Inner Product-based Neural Network IPNN中定义product layer的特征交叉为向量内积。我们可以知道，此时的P是一个N*N的矩阵，Z是N*M的矩阵。
那么，L1层公式，其空间复杂度为O（D1*N*（M+N）），其时间复杂度为O（N*N（D1 +M））.
我们可以学习FM的思想，通过矩阵分解来降低复杂度：。那么：
如此，时间复杂度就变成了D1*M*N。
3. Outer Product-based Neural Network OPNN，在product layer以向量外积作为特征交叉，生成的交叉项是一个矩阵（在IPNN中是一个数字），维度是M*M。
为了减少负责度，论文使用了叠加的思想，它重新定义了p矩阵：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fcc72f2bf4f849bec4eeb4308a54f93/" rel="bookmark">
			1. Pytorch入门教程——总览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近正式开始学习深度学习，而作为现在最流行的深度学习框架PyTorch，相信使用过的人都会被其轻便和快速等特点深深吸引，因此这个系列博客介绍了如何快速入门PyTorch。
学习一门新的语言或者框架最快速的方法自然是边看代码边看教程，于是我遍寻GitHub，终于找到了一个既简单又详细的PyTorch入门教程。该教程提供了完整的代码并添加了详细的注释，一步步循循善诱的引导读者快速入门PyTorch。但教程中有一些错误而且是全英文注释，因此我将此教程进行了翻译并重新整理，更详细的添加了自己理解的一些内容。最后我将原教程进行分拆，主要分为了8个内容，意图引导Pytorch初学者能够快速的入门，对Pytorch的基本操作有个全面的了解。
原教程github地址
本教程代码地址及需要的数据集
链接:https://pan.baidu.com/s/1CiZwfWrZqZSdx1c4MSaIHQ 密码:0izy
一、准备 在进入本教程前，需要有一些基本准备工作。
熟悉python，尤其要熟悉Numpy和Pandas库的使用；最好有一些软件开发经验，如果有良好的编程背景，就能够很好的入门；安装含有Python 3.x的Anaconda和Jupyter notebook；最好有Nvidia GPU(比如GTX 1080)，如果没有也没关系，但训练时间会变长。当然你也可以在网上租用服务器或者远程GPU服务器；读者应该对深度学习和神经网络的一些基本概念比较熟悉。比如线性函数，非线性函数(Relu等)，反向传播，梯度和梯度下降算法，损失函数，以及神经网络的权重怎么更新。对于CNN来说，应了解基本的卷积和池化操作。我们的教程将覆盖Pytorch张量(Tensor)，张量操作，以及迁移学习和Pytorch相关的所有概念。 二、Pytorch介绍 Pytorch是来自Facebook的一种相对比较新的深度学习框架，已经快速的在开发社区中流行开来。它的主要优点是它的灵活性和神经网络运行时更好的控制能力。另一个关键优势是它广泛使用了Python的编程习惯，入门比较简单，而不像Tensorflow定义了自己的语法和编程风格。
三、数据集 我们使用Cifar10数据集。该数据集包含了60000张图片，被分成10类。每张图片大小是28x28。由于这些图片比较小，较为模糊，导致成为分类任务中比较困难的数据集之一。该数据集的一些基准：
https://benchmarks.ai/cifar-10
有一个2014年的Cifar10竞赛，在
https://www.kaggle.com/c/cifar-10
四、目标 在学完该教程后，读者应该能够：
使用Pytorch创建一个API(一组类和实用函数)，来预处理和准备用于训练，验证和预测的图像数据集；构造并使用API有效地将Pytorch中的迁移学习应用于图像数据集进行分类；获取一些技巧，使用三种不同的预训练模型，通过有效地组合它们来实现比单个模型更高的精度，从而在Cifar10获得非常高的精度；了解如何使用Pytorch为深度学习任务创建自己的类，并将它们用作其他应用程序的组件。 五、教程大纲 本教程将按以下步骤进行：
创建Cifar10 Pytorch数据集；数据集预处理，准备训练；创建一个基类来构建一个基本的神经网络；创建一个派生自基类的全连接类；创建一个派生自基类的迁移学习类；在Cifar10数据集上训练两个不同的预训练迁移模型；使用单个模型和集成模型在数据集上进行验证，预测；在Kaggle给出的更大的测试集进行预测。 注意：接下来所有代码都在jupyter notebook中运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2337c488488760585f63f9c4769ebb0/" rel="bookmark">
			如何在数据流中轻松检测异常值-离群值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一种简单的方法，可通过Python实现在数据流中查找异常值
在上一篇文章中，我解释了流算法的概念，并给出了许多如何应用流算法的示例。 其中之一是在不保存数据流元素的情况下计算数据流的滚动平均值。 现在，我想扩展这个示例，并在异常值检测的背景下向您展示另一种流算法的用例。
当我们监视机器的功耗以检测任何异常行为时，可能会出现类似的问题。 如果我们发现异常值有所增加（异常观察），则可能表明这台机器的默认值，可能值得检查。
定义和示例 离群值可以通过多种方式定义。 在本文中，我们将使用以下定义：
如果数字数据流中的元素与到目前为止所见元素的平均值不在3个标准偏差之内，则该元素被视为离群值。
这需要一个小例子。 假设我们按顺序获得数据3、2、4、3、5、3、2、10、2、3、1。 让我们进一步假设，我们从零的均值和方差（以及因此的标准差）开始，即，如果不等于零，则始终将第一个元素视为离群值。
因此，将3视为离群值，因为3&gt; 0 3 * 0。 现在，我们根据到目前为止看到的元素（仅是数字3）更新均值和方差。因此，新均值是3，方差是0。
然后我们看到2。我们有2&gt; 3 3 * 0，所以2也被认为是离群值。 这是有道理的，因为到目前为止我们只看到了3，所以其他任何数字都不适合该模式。 平均值更新为（3 2）/2=2.5，方差更新为（（3-2.5）²（2-2.5）²）/2=0.25，这意味着标准偏差为0.5。
现在我们看到4。由于2.5–3 *0.5≤4≤2.53 * 0.5，因此该数字不是异常值（即正常值）。 平均值更新为（3 2 4）/ 3 = 3，方差更新为（（3–3）²（2–3）²（4–3）²）/ 3 = 2/3，因此标准偏差为 约0.81。
以下数字3、5、3、2被认为是正常的。 凭直觉，我们将下面的数字10视为离群值。 让我们看看该算法的作用。 此时的平均值约为3.1，标准偏差约为1。由于10&gt; 3.1 3 * 1，因此我们希望将10视为离群值。
如果继续最后三个元素，您将看到它们都是正常的。
问题：要计算平均值和标准偏差，我们必须记住到目前为止看到的所有元素。 如果我们有一个每天输出成千上万个元素的系统，那么这不是一个选择。
救援的流式算法 解决此问题的一种方法是使用流算法，该算法在从数据流中每个被扫描元素之后更新其内部状态。 内部状态由到目前为止在任何点看到的所有元素的均值和方差组成，从看到任何元素之前的均值和方差为零开始。 确切地说，在看到数据流的第n个元素之后，令mₙ为平均值，vₙ为方差，并附加定义m₀=v₀= 0。
计算均值 在我有关流算法的文章中，我们看到了如何仅使用旧的均值，正在扫描的最新元素以及到目前为止看到的元素数量来更新均值。 这意味着我们只需要随时使用这种方法存储两个数字，而不是像幼稚的方法那样存储n。 让我再次显示它，将数据流的第i个传入元素表示为aᵢ：
这个公式不难开发，对吧？ 有了它，我们就有了我们期望的元素大小的基线。 现在，我们只需要可以用均值围绕的标准偏差即可将输入的示例分类为离群值和正常数据点。 我们通过计算方差来做到这一点，然后取其平方根即可达到标准偏差。
计算方差 在这种情况下，我们也可以轻松找到递归公式。 首先，看到n个元素后的方差为
让我们尝试再次根据n，vₙ和最新元素来写。 由于方差取决于均值，因此我们也要包含mₙ。 在开始之前，让我们重新安排这个公式，以使事情变得更容易：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2337c488488760585f63f9c4769ebb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/060a322092d1ce7775c91d793f401491/" rel="bookmark">
			3. Pytorch入门教程——数据集预处理，准备训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这个部分，将介绍以下内容：
理解数据载入器(Dataloaders)的概念和Pytorch数据载入器API；将图片数据集分成训练，验证和测试集；创建Pytorch Dataloaders加载图片用于训练，验证和测试；使用Pytorch API来定义变换(Transforms)进行数据集预处理，更有效的进行训练；使用Pytorch API将所有图片转变成Pytorch Tensors；使用图片的平均值和标准差来归一化数据集。 一、数据载入器(Data Loaders) 1. Pytorch Dataloaders充当Python生成器的对象。在进行训练和验证时，它们以块或批的形式提供数据。我们可以实例化Dataloader对象并将我们的数据集传递给它们。dataloader在内部存储数据集对象。
当应用请求下一批数据时，dataloader使用其存储的数据集作为Python迭代器来获取数据的下一个元素。然后它聚合一批数据并将其返回给应用。
下面是一个调用Dataloader构造函数的例子:
num_train = len(train_dataset) indices = list(range(num_train)) train_loader = torch.utils.data.DataLoader(train_dataset, batch_size=50,sampler=SubsetRandomSampler(indices),num_workers=0) len(train_loader) 10000
这里，我们为批大小为50的训练数据集创建一个Dataloader对象；sampler参数指定了我们在构建批处理时要对数据进行采样的策略；在torch.utils.data.sampler有不同的采样器。这个解释很简单。您可以通过在Pytorch文档https://pytorch.org/docs/stable/data.html#torch.utils.data.Sampler中了解它们；num_workers参数指定在加载数据时希望使用多少进程(或核心)。这在加载大型数据集时提供了并行性。默认值为0，表示加载主进程中的所有数据。 Dataloader以批的数量作为长度。我们创建了批大小为50的Dataloader，在训练数据集中有50000个图像，所以我们的Dataloader长度等于1000个批。
2. 分割数据
现在我们写一个函数将我们的数据分割成训练，验证和测试集，并创建它们相应的dataloaders
''' 这个函数将训练和测试数据集作为参数。 测试数据可以为None，在这种情况下，它将训练数据分割成三个数据集，训练，测试和验证集。 如果test_data不是none，它只是将训练集分割成训练和验证集，并从测试集创建一个单独的dataloader。 ''' def split_image_data(train_data, test_data=None, batch_size=20, num_workers=0, valid_size=0.2, sampler=SubsetRandomSampler): num_train = len(train_data) ''' 它使用Python range函数在训练集的长度上创建一个索引列表 ''' indices = list(range(num_train)) np.random.shuffle(indices) ''' 它根据给定的验证集大小(valid_size参数)分割索引列表，该参数的默认值为0.2(为验证而预留的训练数据的20%) ''' split = int(np.floor(valid_size * num_train)) train_idx, valid_idx = indices[split:], indices[:split] ''' 它使用RandomSubsetSampler构造函数来打乱训练和验证集索引 ''' train_sampler = sampler(train_idx) valid_sampler = sampler(valid_idx) ''' 如果给出一个单独的测试集，它只会从该测试集创建一个Dataloader。 如果没有给出测试集，则进一步将训练索引(这些索引是通过将原始的train_set分割为训练和验证索引获得的)分割为一组训练和测试索引。注意，测试索引的大小等于验证集。 这导致了一套新的索引和从训练集得到的采样的测试集。 ''' if test_data is not None: test_loader = DataLoader(test_data, batch_size=batch_size, num_workers=num_workers) else: train_idx, test_idx = train_idx[split:],train_idx[:split] train_sampler = sampler(train_idx) test_sampler = sampler(test_idx) test_loader = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/060a322092d1ce7775c91d793f401491/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67a9e31eadcfad03ebc59d226e57733d/" rel="bookmark">
			中文乱码问题整理总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、字符编码
2、乱码产生的原因
3、乱码解决方案
3.1、解决HTML页面中的中文问题：
3.2、解决JSP页面中的中文问题
3.3、解决Servlet响应结果的中文问题
3.4解决页面数据传输的中文问题
3.5、解决HTTP(get)请求中的中文问题
3.6、解决MySQL数据库的中文问题
3.7、实现加解密过程中，报文是乱码：设置编码格式可能有误。
3.8、在本地测试是正常的，但是发布到测试环境后会乱码的问题
1、字符编码 在计算机中任何数据都是以二进制存储的，要存储一个字符就要对它进行编码，用一个二进制数与这对应，这种对应的规则，就是字符的编码。编码的规则有很多 种，一种规则所编码的“字符”的集合就叫做“字符集”。在制定编码标准的时候，“字符的集合”和“编码”一般都是同时制定的，因此，平时我们所说的“字符 集”，例如GB2312、GBK和JIS等，除了有“字符的集合”这层含义外，同时也包含了“编码”的含义。
最早出现的编码是ASCII码，因为早期计算机系统只支持英语。后来每个国家（或区域）规定了计算机信息交换用的字符编码集，例如中国的GB2312等作 为自己国家/区域内信息处理的基础。在程序读取字符到输出字符的过程中，就需要在不同的字符集之间进行转换，这个时候就容易出现乱码，因此要了解乱码是如 何产生的，首先要了解各种字符编码。下面对这些编码做一个简单介绍。
1）、ASCII ASCII码是《美国标准信息交换码》，简称ASCII，它总共规定了128个字符号所对应的数字代码，使用了7位二进制的位来表示这些数字。其中包含了英文的大小写字母、数字和标点符号常用的字符，数字代号从0~127。
2）、ISO8859 ASCII码解决了英语国家的字符问题，可是欧洲各个国家的字符问题还没有解决，例如法语中就有许多英语中没有的字符，为了解决该问题，国际标准化组织的 ISO8859标准应运而生，在ISO8859的编码表中，编号0~127与ASCII保持兼容，编号128~159共32个编码保留给扩充定义的32个 扩充控制码，160为空格，161~255的95个数字用于新增加的字符代码。由于在一张码表中只能增加95种字符的代码，因此ISO8859实际上不是 一张码表，而是一系列标准，包括14个字符码表。例如，西欧的常用字符就包含在ISO8859-1字符表中，在ISO8859-7中则包含了ASCII和 现代希腊语字符。
3）、GB2312和GBK GB2312是中国国家标准汉字信息交换用编码，简称国标码，标准号为GB2312-80。
中国的文字不是拼音文字，汉字的个数的数万之多，远远超过区区256个字符，ISO8859无能为力，但是通过借鉴ISO8859的编码思想，研 究人员解决了中文的编码问题。GB2312使用两个字节来表示一个中文，在每个字符的256种可能中，为了与ASCII保持兼容，低于128的我们不使 用。借鉴ISO8859的设计方案，只使用从160以后的96个数字，两个字节分成高位和低位，高位的取值范围从176~247共72个，低位从 161~254共94个，这样，两个字节就有72*94＝6768种可能，即可表示6768种汉字。
BG2312-80仅收录了6763个汉字，还有许多汉字没有被收录进去，为了对更多的字符进行编码，全国信息技术化技术委员会于1995年12月1日颁 布了《汉字内码扩展规范》，简称GBK。在GBK1.0中共收录了21886个汉字和图形符号，微软公司的window95系统的简体中文版开始即支持 GBK编码。GBK向下与GB2312完全兼容，向上支持ISO10646国际标准。
（4）、UNICODE
每个国家和地区都规定了计算机信息交换编码，这就造成了不同编码国家、地区之间交流上的困难，如果全世界都使用统一的编码表就好了，为此UNICODE组 织发布了UNICODE编码。这种编码使用双字节符号数对每一个字符进行编码，在UNICODE3.0.1中包含了49194个字符，将 来，UNICODE中还会增加更多的字符。UNICODE的全称是“Universal Multiple-Octet Coded Character Set”，简称UCS。
（5）、UTF-8
使用UNICODE编码，一个英文字符也要占据两个字节，对于英文信息而言就增加了一倍数据量，为了减少存储和传输英文数据的数据量，美国人又制定了一系 列用于传输和保存UNICODE的编码标准UTF，这些编码称为UCS传输格式码，也就是将UCS的编码通过一定的转换来达到使用的目的。常见的有 UTF-7、UTF-8、UTF-16等。其中UTF-8编码得到了广泛的应用，UTF-8的全名是UCS Transformation Format 8，即UCS编码的8位传输格式，就是使用单字节的方式对UCS进行编码，使UNICODE编码能够在单字节的设备上正常进行处理。
UTF-8编码是变长的编码，对不同的UNICODE可能编成不同的长度。
从理论上来说，这些根据字符集设置而进行的字符转换不应该产生太多的问题，而事实上由于应用程序的实际运行环境不同，UNICODE和各个本地字符集的补充、完善以及系统或应用程序实现的不规范，转码时还是会经常出现问题而导致乱码。
2、乱码产生的原因 Java语言内部是用UNICODE表示字符的，遵守UNICODE V2.0。Java程序无论是以字符流读/写磁盘文件，还是向URL转接写HTML信息，或从URL连接读取参数值，都会由UNICODE作为中介和本地字符编码进行转换。
在WEB应用中，浏览器、WEB服务器、WEB应用程序和数据库等各个部分都有可能使用不用的字符集，字符在不同的字符集之间进行转换时，就有可能出现乱码问题。例如一个中文字符“中”要转换为ISO-8859-1编码，在Java中先读取到的是中文字符的GBK编码“0xD6D0”，转换为 UNICODE码为“0x4E2D”，再从UNICODE编码转换ISO-8859-1编码，如果ISO-8859-1编码中没有对应的 “0xD6D0”,于是就得到“0x3F”，也就是我们经常在页面上看到一堆“？”的原因。
在WEB应用中，乱码可能在多个环节产生，下面针对可能出现乱码的几个环节，给出解决的方案。
3、乱码解决方案 1）、JSP页面最基本的乱码问题
运行下面的代码，会发现页面上出现的是乱码。
&lt;%@ page language="java" pageEncoding="UTF-8"%&gt; &lt;%@ page contentType="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67a9e31eadcfad03ebc59d226e57733d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/956db08c8aa588d5f01542362c139572/" rel="bookmark">
			【小工具】字节数据 的 解析与转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们网络传输的过程中，底层都是字节数据的传输，
但是，我们若是想要获知字节的内容，却无法通过直接输出获得
因此，在本篇博文中，本人来给出一个小工具，来方便我们直接读取字节数据的内容
字节数据 与 字符串 的 相互转换： 字节数据 --&gt; 字符串： public static final String HEX = "0123456789ABCDEF"; public static String binaryToString(byte[] buffer, int offset, int len) { StringBuffer result = new StringBuffer(); for (int index = offset; index &lt; offset + len; index++) { byte val = buffer[index]; result.append(HEX.charAt((val &gt;&gt; 4) &amp; 0x0F));	// 一个字节 有 8位(即：两个16进制) 构成 result.append(HEX.charAt(val &amp; 0x0F)); } return result.toString(); } 那么，接下来是 将字符串转换为字节数据的代码：
字符串 --&gt; 字节数据： public static final String HEX = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/956db08c8aa588d5f01542362c139572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eca04009ee0a368eedbe466e9241d2c4/" rel="bookmark">
			K8S 的 5种控制器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pod通过控制器实现应用的运维，如伸缩、升级等，控制器决定了创建pod资源的方式和类型，在集群上管理和运行容器的对象通过label-selector 相关联。
控制器 又称之为工作负载，分别包含以下类型控制器：
5种控制器类型 1： Deployment
2： StatefulSet
3： DaemonSet
4：Job
5： CronJob
第一种控制器类型：deployment 特点：
部署无状态应用，只关心数量，不论角色等，称无状态
管理Pod和ReplicaSet
具有上线部署、副本设定、滚动升级、回滚等功能
提供声明式更新，例如只更新一个新的image
应用场景: web 服务
示例：
# vim nginx-deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment labels: app: nginx spec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.15.4 ports: - containerPort: 80 Replicaset是副本数，回滚就是通过此来实现 创建资源 # kubectl create -f nginx-deployment.yaml 查看创建的pod资源、控制器和副本 # kubectl get pods,deploy,rs 查看历史版本 # kubectl rollout history deployment/nginx-deployment 第二种控制器类型： SatefulSet 特点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eca04009ee0a368eedbe466e9241d2c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72418dad7cdaa21c1a31e2d5104c891d/" rel="bookmark">
			大厂面经-js基础篇(必包/this)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 必包 1.1 什么是必包 知乎上看到一个解释，觉得说的很好，就放在这吧
（比如我们在a函数里面返回b函数，当 b 函数执行的时候，a函数上下文已经被销毁了啊，但是我们依然能读取到a作用域下的值？这是因为作用域链导致的，b函数引用了 a函数活动对象中的值的时候，即使 a的执行上下文被销毁了，但是 js依然会让 a函数活动对象活在内存中，b函数依然可以通过 b 函数的作用域链找到它，正是因为 js 做到了这一点，从而实现了闭包这个概念）
1.1 必包的两种主要形式 函数作为返回值函数作为参数传递 1.2 必包的应用场景以及副作用 可以读取函数内部的变量让这些变量的值始终保持在内存中实现变量的私有化，可以将私有变量放在一个函数里，然后以闭包的形式，在该函数里创建特权函数来访问和操纵这些变量。 function MyObject(){ //私有变量 var privateVariable = 10; //私有函数 function privateFunction(){ return false; } //特权方法 this.publicMethod = function(){ privateVariable++; return privateFunction(); }; } 副作用：
由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，解决方法是，在退出函数之前，将不使用的局部变量全部删除。
1.3 关于必包的常出现的考题 function fun(n,o) { console.log(o) return { fun:function(m){ return fun(m,n); } }; } // 参考https://www.cnblogs.com/xxcanghai/p/4991870.html 有点难 var name = "The Window"; var object = { name : "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72418dad7cdaa21c1a31e2d5104c891d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68b74f8af5c0d542ea006a1389cc21dc/" rel="bookmark">
			C&#43;&#43;知识点2——指针、引用基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引用：
1.引用就是对象或变量的别名，但引用不是对象或变量
int a=10; int &amp;b=a;
这里面，b就是变量a的另一个名字，对b操作就是对a操作，对a操作，b也会变化
void testreference() { int a=10; int &amp;b=a; b=5; cout&lt;&lt;a&lt;&lt;b&lt;&lt;endl; a=4; cout&lt;&lt;a&lt;&lt;b&lt;&lt;endl; } 2.因为引用一定是某个变量的别名，引用一定是和变量绑定在一起的，所以引用必须初始化
int a=10; int &amp;b; 3.因为引用不是对象，但是引用又要绑定一个对象，所以不能定义引用的引用
int a=10; int &amp;b=a; int &amp;(&amp;c)=a; 4.因为操作引用就是操作变量或者对象本身，所以对于内置类型，变量和其引用之间的类型要适配
int a=10; float &amp;b=a; 5.因为引用必须和变量进行绑定，所以非const引用不能绑定字面值
int a=10; int &amp;b=20; 所以，引用的基本特性就五个：1.不是对象，2.必须初始化，3.不能定义引用的引用，4.类型适配，5.不能绑定字面值
指针
6.指针就是变量的地址，可以通过引用访问变量，也可以通过指针访问变量，但是指针是对象，而引用不是，这是二者的根本区别
void testpointer() { int a=10; int *p=&amp;a; int *q; cout&lt;&lt;p&lt;&lt;endl&lt;&lt;q&lt;&lt;endl; } 通过上述代码，可以知道，指针可以不初始化（只是为了演示，不要这样做），但是引用必须初始化
另外，&amp;符号既能表示引用，也是取地址符号，当&amp;出现在=左侧时，是引用，在=右边就是取地址
7.因为指针是一个对象，所以可以定义指针的指针，但是不能定义引用的引用
void testpointer() { int a=10;; int *p=&amp;a; int *q; int **pp = &amp;p; cout&lt;&lt;p&lt;&lt;endl&lt;&lt;q&lt;&lt;endl; cout&lt;&lt;pp&lt;&lt;endl; } 所以，指针的引用的不同点就是：1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68b74f8af5c0d542ea006a1389cc21dc/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/432/">«</a>
	<span class="pagination__item pagination__item--current">433/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/434/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>