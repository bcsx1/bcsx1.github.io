<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c53b490d3be768000ed4af70b66f679/" rel="bookmark">
			从 Google Gemini 到 OpenAI Q*（Q-Star）：调研重塑生成人工智能（AI）的研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、主要内容三、总结 🍉 CSDN 叶庭云：https://yetingyun.blog.csdn.net/
一、前言 这篇综述探讨了生成式人工智能不断发展的前景，重点关注混合专家（MoE）、多模态学习的变革性影响，以及对通用人工智能（AGI）发展的猜测。它批判性地审视了生成式 AI 的现状和未来轨迹，探讨了谷歌的 Gemini 和预期的 OpenAI Q* 项目等创新如何重塑各个领域的研究重点和应用，包括对生成式 AI 研究分类法的影响分析。
它评估了这些技术的计算挑战、可扩展性和对现实世界的影响，同时强调了它们在推动医疗保健、金融和教育等领域取得重大进展方面的潜力。它还探讨了以人工智能为主题的预印本和人工智能生成的预印本激增所带来的新学术挑战，研究了它们对同行评审过程和学术交流的影响。该研究强调了在人工智能开发中融入伦理和以人为本的方法的重要性，确保与社会规范和福利保持一致，并概述了未来人工智能研究的战略，重点是在生成式 AI 中平衡和有意识地使用 MoE、多模态和 AGI。
论文题目：《From Google Gemini to OpenAI Q*: A Survey of Reshaping the Generative Artificial Intelligence (AI) Research Landscape》
论文地址：https://arxiv.org/abs/2312.10868v1
二、主要内容 引领生成式人工智能新时代：研究趋势与伦理考量
随着大语言模型（LLMs）（如 GPT-4、Gemini、Claude 等）的发展，生成式人工智能取得了显著的成功。谷歌 Gemini 等模型的引入进一步完善了人工智能系统的能力。这些进步给业界和学术界带来了革命性的变化，同时也重新引发了关于人工智能对人类和意识的潜在威胁的批判性讨论。这篇综述提供了一份全面的调查报告，探讨了这些发展是如何重塑不同领域的研究和应用的。
生成式人工智能创新的最前沿是混合专家（MoE）、多模态等技术，这些技术可以对信息进行动态路由和专门处理。能够处理文本、图像、音频和视频等各种数据格式的多模态人工智能系统正变得越来越重要。被称为 Q*（Q-Star）的投机项目将 LLM 的能力与先进算法相结合，为动态研究环境做出了贡献。这些技术上的进步正在为人工智能发展中稳健的多模态方法铺平道路。
生成式人工智能的影响远远超出了技术界限，影响着就业环境和社会经济结构。 这些技术在推动创新和经济增长的同时，也引发了伦理问题。要使人工智能符合社会规范和福祉，就必须制定战略，注重伦理发展，并有意识地使用新兴的人工智能模型，如 MoE、多模态和通用智人工智能（AGI）的进展。
在高级学习领域，自监督学习、元学习和微调等领域仍然至关重要。随着人工智能模型向 AGI 演进，多模态和 MoE 领域出现了新的研究重点。这些研究重点包括揭示偏差缓解技术、保护数据隐私以及探索人工智能与人类伦理之间的协同作用。人工智能相关预印本的激增，尤其是在计算机科学领域，标志着研究传播模式的转变。然而，这种研究成果的快速交流引发了验证方面的担忧，因为它可能导致未经审查的信息肆意传播。学术界现在面临的挑战是，如何根据这种生成式人工智能研究的快速发展来完善研究方向并调整同行评审机制。
由于可用知识数量庞大，大量的预印本使得进行证据综述变得极具挑战性。我们亟需讨论如何管理以人工智能为主题的研究论文日益增多的 “混乱” 局面，以及传统同行评审制度面临的压力。必须探索同行评审和研究传播的新模式，以维护生成式人工智能时代科学研究的可信度。
三、总结 这项调查强调了生成式人工智能研究的关键时刻，其特点是创新正在改变人工智能系统的能力。技术发展与人类价值之间的平衡至关重要，这就需要开展多学科研究，将伦理、社会学和技术视角交织在一起。未来人工智能的进步必须以负责任的态度加以引导，以确保它们在符合伦理标准和社会福祉的前提下提升人类的体验。
要点总结：
本文探讨了生成式人工智能（如大语言模型）和 Google Gemini 等技术的最新进展对各个领域的影响。回顾了混合专家和多模态人工智能系统等创新，并提到了 Q*（Q-Star）等项目在推进人工智能研究方面的潜力。调查探讨了生成式人工智能对社会和伦理的影响，讨论了伦理发展与人类福祉相一致的必要性。研究强调了高级学习和研究的重要领域，如自监督学习、元学习和微调，考虑减少偏见和关注数据隐私的必要性。论文探讨了人工智能预印本的快速增长所带来的挑战以及由此对同行评审制度造成的压力，并敦促建立新的研究验证机制。 📚️ 参考链接：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c53b490d3be768000ed4af70b66f679/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc8debb3e403ea7b089149f2e1de9f53/" rel="bookmark">
			后端主流框架-SpringMvc-day2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中的文件上传 1 文件上传 文件上传：指的是将本地的文件复制到服务器上；
SpringMvc中的文件上传是对原生文件上传的封装，目的是，较少代码量，提高开发效率；
文件上传三要素：
表单的提交的方式必须是POST请求（get请求对提交的数据）
表单中必须有一个文件上传项:&lt;input type=“file” name=“upload”/&gt;，文件上传项必须有name属性和值；
表单的enctype属性的值必须是multipart/form-data
1.1 添加jar文件 由于SpringMVC自己没有实现文件上传，它使用的是apache.commons.fileupload com.springsource.org.apache.commons.fileupload-1.2.0.jarcom.springsource.org.apache.commons.io-1.4.0.jar &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt; &lt;/dependency&gt; 1.2 jsp页面 1.3 配置上传解析器 SpringMVC使用MultipartFile来进行文件上传，所以我们首先要配置MultipartResolver，用于处理表单中的file，如果没有配置就会报如下错误：提示告诉开发者你没有配置文件上传解析器：
配置MultipartResolver：注意id="multipartResolver"的id值不能乱写
&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 设置上传文件的最大尺寸为1MB --&gt; &lt;property name="maxUploadSize"&gt; &lt;!-- spring el写法：1MB --&gt; &lt;value&gt;#{1024*1024}&lt;/value&gt; &lt;/property&gt; &lt;!-- 效果同上 --&gt; &lt;property name="maxUploadSize" value="1048576" /&gt; &lt;/bean&gt; 1.4 后台处理 @Controller public class UploadController { @RequestMapping(value="/upload",method=RequestMethod.POST) public String uploadFile(MultipartFile fileUpload,String name,HttpServletRequest req) throws FileNotFoundException, IOException { System.out.println("普通表单获取方式：" + name); //上传表单信息：注意MultipartFile对象的名称必须与上传表单项的name属性值一致 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc8debb3e403ea7b089149f2e1de9f53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1a0cf92de8d3d8f8ae10b064cae0365/" rel="bookmark">
			Unity中Shader 齐次坐标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、什么是齐次坐标二、齐次坐标增加分量 w 的意义1、当 w ≠ \neq = 0时：2、当 w = 0时：3、用方程组，直观的看一下w的意义 前言 在之前的文章中，我们进行了正交相机视图空间转化到裁剪空间的推导。
Unity中Shader裁剪空间推导（在Shader中实现） 在这篇文章中，我们进行透视相机视图空间转化到裁剪空间的推导的前置准备——齐次坐标是什么。
一、什么是齐次坐标 齐次坐标：就是将一个原本是 n 维的向量 用一个n + 1维向量来表示
二、齐次坐标增加分量 w 的意义 (x,y,z) -&gt; (x,y,z,w) 1、当 w ≠ \neq = 0时： 可以把式子化简为 (x/w,y/w,z/w,1)
用(1,2,3)为例，以下式子都是等价的:
(1,2,3)(1,2,3,1)(2,4,6,2)(3,6,9,3)(……) 2、当 w = 0时： (x,y,z,0)表示的是一个无穷远的点
3、用方程组，直观的看一下w的意义 Ax + By + C = 0(不动的那条线)Ax + By + D = 0(下面移动的那条线) 若 C ≠ \neq = D，则方程无解若 C = D，则表示的是同一直线
此时，我们使用 x w 代替 x \frac{x}{w}代替x wx​代替x, y w 代替 y \frac{y}{w}代替y wy​代替y A x w + B y w + C = 0 A\frac{x}{w} + B \frac{y}{w} + C = 0 Awx​+Bwy​+C=0 A x w + B y w + D = 0 A\frac{x}{w} + B \frac{y}{w} + D = 0 Awx​+Bwy​+D=0 -&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1a0cf92de8d3d8f8ae10b064cae0365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49fc81278140aa324217885e797f41e3/" rel="bookmark">
			chatGPT的Function calling示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import json import os from openai import OpenAI client = OpenAI( api_key = os.getenv("OPENAI_API_KEY"), ) # Example dummy function hard coded to return the same weather # In production, this could be your backend API or an external API def get_current_weather(location, unit="fahrenheit"): """Get the current weather in a given location""" if "tokyo" in location.lower(): return json.dumps({"location": "Tokyo", "temperature": "10", "unit": unit}) elif "san francisco" in location.lower(): return json.dumps({"location": "San Francisco"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49fc81278140aa324217885e797f41e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6431ac458f82255221ef9820137dfb1/" rel="bookmark">
			微信小程序动画层级问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 微信小程序ios端动画元素层级不正常
描述 在一个组件内，有css动画元素和静止元素，
android端是按照dom顺序展示的，
ios端动画元素在静止元素的上层，
设置z-index也无效
解决方案 可以在静止元素上增加 transform: translateZ(1px);处理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ef09d727c44939d01489b60278faff6/" rel="bookmark">
			【贪心算法】专题练习一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到Cefler的博客😁
🕌博客主页：那个传说中的man的主页
🏠个人专栏：题目解析
🌎推荐文章：题目大解析（3）
前言
1.什么是贪心算法？——贪婪+鼠目寸光
贪心策略：解决问题的策略，局部最优-&gt;全局最优
(1)即把解决问题的过程分为若干步
(2)解决每一步的时候吗，都选择当前看起来“最优的”解法
（3）希望得到全局最优解
2.贪心算法的特点
(1) 贪心策略的提出是没有标准以及模板的
(2) 可能每一道题的贪心策略都是不同的
(3)贪心策略的正确性：可能会出错；正确的贪心策略，我们是需要“证明的”
3.证明贪心策略的方法:数学中见过的所有证明方法
4.学习贪心的方向
(1):遇到不会的贪心题，很正常，把心态放平
(2):把策略当成经验吸收
(3):能证明则证明贪心策略的正确性
目录 👉🏻柠檬水找零证明 👉🏻将数组和减半的最少操作次数证明priority_queue注意事项 👉🏻最大数👉🏻摆动序列 👉🏻柠檬水找零 原题链接：柠檬水找零
mycode:
class Solution { public: bool lemonadeChange(vector&lt;int&gt;&amp; bills) { int five = 0,ten = 0,twenty = 0; for(auto e:bills) { if(e==5) { five++; } else if(e==10) { ten++; if(--five&lt;0) return false; } else if(e==20) { twenty++; //10+5 &amp;&amp; 5+5+5 都不可以才找零失败 int tmp1 = ten,tmp2 = five,tmp3 = five; if(--tmp1&gt;=0&amp;&amp;--tmp2&gt;=0) { --ten; --five; } else if((tmp3-=3)&gt;=0) { five-=3; } else return false; } } return true; } }; 证明 交换论证法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ef09d727c44939d01489b60278faff6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0549b16e2d1cd4a8175cbf6911a034e2/" rel="bookmark">
			zabbix 批量添加主机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zabbix 批量添加主机 1.1::通过本教程起到抛砖引玉效果，希望各位朋友受益良多。
1.2::如您有任何问题请联系作者，QQ1284524409。
1.3::以下提供的任何软件仅供学习交流使用。
1.4::**项目地址**
jihulib项目地址
#!/usr/bin/python
# coding:utf-8
import json
import urllib2
from urllib2 import URLError
import sys, argparse
import xlrd
defaultencoding = 'utf-8'
if sys.getdefaultencoding() != defaultencoding:
reload(sys)
sys.setdefaultencoding(defaultencoding)
class zabbix_api:
def __init__(self):
self.url = 'http://127.0.0.1/zabbix/api_jsonrpc.php' # 修改URL
self.header = {"Content-Type":"application/json"}
self.user_login()
def user_login(self):
data = json.dumps({
"jsonrpc": "2.0",
"method": "user.login",
"params": {
"user": "Admin", # web页面登录用户名
"password": "zabbix" # web页面登录密码
},
"id": 0
})
request = urllib2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0549b16e2d1cd4a8175cbf6911a034e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb491ef9c275bb0c16b291e7d1593999/" rel="bookmark">
			【1】Docker详解与部署微服务实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker 详解 Docker 简介 Docker 是一个开源的容器化平台，可以帮助开发者将应用程序和其依赖的环境打包成一个可移植、可部署的容器。Docker 的主要目标是通过容器化技术实现应用程序的快速部署、可移植性和可扩展性，从而简化应用程序的开发、测试和部署过程。
容器化是一种虚拟化技术，它通过在操作系统层面隔离应用程序和其依赖的运行环境，使得应用程序可以在一个独立的、封闭的环境中运行，而不受底层操作系统和硬件的影响。与传统的虚拟机相比，容器化具有以下优势：
轻量级 容器与宿主机共享操作系统内核，因此容器本身非常轻量级，启动和停止速度快，资源占用少。
可移植性 容器可以在任何支持相应容器运行时的系统上运行，无需关注底层操作系统的差异，提供了高度的可移植性。
快速部署 容器化应用程序可以通过简单的操作进行打包、分发和部署，减少了部署过程的复杂性和时间成本。
弹性扩展 可以根据应用程序的需求快速创建、启动和停止容器实例，实现应用程序的弹性扩展和负载均衡。
环境隔离 每个容器都具有独立的运行环境，容器之间相互隔离，不会相互干扰，提供了更好的安全性和稳定性。
Docker 和传统虚拟机区别：
虚拟机是一个主机模拟出多个主机，需要先拥有独立的系统。传统虚拟机，利用 hypervisor，模拟出独立的硬件和系统，在此之上创建应用。docker 是在主机系统中建立多个应用及配套环境，把应用及配套环境独立打包成一个单位，是进程级的隔离。
Docker 架构 Docker daemon（Docker 守护进程） Docker daemon 是一个运行在宿主机（DOCKER-HOST）的后台进程。可通过 Docker 客户端与之通信。
Client（Docker 客户端） Docker 客户端是 Docker 的用户界面，它可以接受用户命令和配置标识，并与 Docker daemon 通信。图中， docker build 等都是 Docker 的相关命令。
Images（ Docker镜像） Docker 镜像是一个只读模板，它包含创建 Docker 容器的说明。它和系统安装光盘有点像，使用系统安装光盘可以安装系统，同理，使用 Docker 镜像可以运行 Docker 镜像中的程序。
Container（容器） 容器是镜像的可运行实例。镜像和容器的关系有点类似于面向对象中，类和对象的关系。可通过 Docker API 或者 CLI 命令来启停、移动、删除容器。
Registry Docker Registry 是一个集中存储与分发镜像的服务。构建完 Docker 镜像后，就可在当前宿主机上运行。但如果想要在其他机器上运行这个镜像，就需要手动复制。此时可借助 Docker Registry 来避免镜像的手动复制。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb491ef9c275bb0c16b291e7d1593999/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/870a4b47e88050fed39d44b623d234d3/" rel="bookmark">
			JAVA设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA设计模式 1.设计模式相关内容介绍1.1设计模式概述1.1.1 设计模式的分类 1.2类图1.1.1 类的表示方式1.2.2 类和类之间的表达方式1.2.2.1 关联关系1.2.2.2 聚合关系1.2.2.3 组合关系1.2.2.4 依赖关系1.2.2.5 继承关系1.2.2.6 实现关系 1.3软件设计原则1.3.1 开闭原则1.3.2 里式代换原则1.3.3 依赖倒转原则1.3.4 接口隔离原则1.3.5 合成复用原则 2.创建者模式2.1单例模式2.1.1 单例模式的实现2.1.2 序列化和反射会破坏单例模式1.2.3 Runtime饿汉式 2.3工厂方法模式2.3.1简单工厂模式2.3.2 工厂方法模式2.3.3 抽象工厂模式2.3.4 反射+读配置文件实现解耦2.3.5 iterator 使用工厂类 2.4原型模式2.4.1原型模式实现2.4.2深克隆 2.5 建造者模式2.5.1 建造者模式的使用2.5.2 模式扩展（链式调用）2.5.3 创建者模式对比 3. 结构型模式3.1代理模式3.1.1 静态代理3.1.2 JDK代理3.1.3 CGLIB动态代理3.1.4 CGLIB动态代理3.1.5 优缺点和使用场景 3.2适配器模式3.2.1 代码实现3.2.2 对象模式适配器3.2.3 适配器应用场景和JDK源码解析 3.3装饰者模式3.3.1 代码实现3.3.2 好处3.3.3代理和装饰者的区别 3.4桥接模式3.4.1 代码实现3.4.2 好处和使用场景 3.5外观模式3.5.1优缺点和使用场景 3.6 享元模式3.6.1 享元模式的应用3.6.2 优缺点和使用场景 4. 行为型模式4.1模板方法模式4.1.1模板方法实现4.1.2 优缺点和适用场景4.1.3 JDK源码解析 4.2 策略模式4.2.1案例实现4.2.2 策略模式优缺点 4.3 命令模式4.3.1案例实现4.3.2 优缺点以及使用场景 4.4职责链模式4.4.1职责链模式代码实现4.4.2职责链模式优缺点 4.5状态模式4.5.1 优缺点和使用场景 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/870a4b47e88050fed39d44b623d234d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cf5fdc8c419a059f9d5cd73a782f0d8/" rel="bookmark">
			Unity坦克大战开发全流程——开始场景——排行榜数据逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始场景——排行榜数据逻辑
排行榜单条数据
排行榜列表
然后在数据管理类中声明一个对应的字段
初始化数据
然后再在上一节课所编写的UpdatePanelInfo函数中处理数据更新的逻辑
时间换算算法
然后再在数据管理类中编写一个在排行榜中添加数据的方法以提供给外部
直到当前RankInfo、GameDataMgr、RankPanel的代码如下
using System.Collections; using System.Collections.Generic; using UnityEngine; /// &lt;summary&gt; /// 单条排行榜信息 /// &lt;/summary&gt; public class RankInfo { public string name; public int score; public int time; public RankInfo(string name, int score, int time) { this.name = name; this.score = score; this.time = time; } public RankInfo() { } } /// &lt;summary&gt; /// 排行榜列表 /// &lt;/summary&gt; public class RankList { public List&lt;RankInfo&gt; list; } using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cf5fdc8c419a059f9d5cd73a782f0d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8d62d4b611601901658fd6397892535/" rel="bookmark">
			ensp中的云无法与公网通信的一例解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ensp的云又和公网不通了，照着网上查找的，重装了winpcap4.13、virtualbox5.2.44、enspV100R003C00SPC100版本还是不行，进入virtualbox，删了虚拟网卡又新建，也还是不行。
想到进入ensp时，有个提示：要放开防火墙，于是检查了下防火墙，看到应用程序里有几条ensp允许的配置，突然想到，原来C盘空间不足，我重装到D盘了，会不会是ensp在安装时，检测到防火墙里有自己的选项，就不再通知系统放行了呢？于是在防火墙上把ensp的项都删了，再重新启动ensp，果然系统跳出通知：是否允许ensp联网？点了允许后，再打开有云的拓朴，果然能ping通和云相连的设备了。
至此已经可以了，但是又有个问题：就是ensp里的连的设备ping不通公网，难道只有单向通信吗？问了东天大佬，说防火墙没放icmp，看了防火墙，果然是我太小心了，ping都不给别人ping的，因为都是本机，所以才忽略了只要过网卡，就要过墙。放开文件和打印机共享（回显请求）后，云里的设备也正常通公网了。
东天大佬另外教了我个技巧：在windows设备管理器里安装一个过时的硬件：Microsoft KM-TEST环回适配器，配个地址当网关，在云里用udp和这个环回卡建立连接，也可以的，这样virtualbox不行了，也可以了。当然，如果你安装有vmware，里面也可以连vmware的虚拟网卡也行的！
放张图，udp相当于ensp自己，云就相当于ensp和本机的虚拟网卡做了桥接：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abedb5630ed2c3ab842c8d2aa6808483/" rel="bookmark">
			C#高级 01.Net多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.基本概念 1.什么是线程？
线程是操作系统中能独立运行的最小单位，也是程序中能并发执行的一段指令序列线程是进程的一部分，一个进程可以包含多个线程，这些线程共享进程资源进程有线程入口，也可以创建更多的线程
2.为什么要有多线程？批量重复任务希望同时进行（重复访问数组中的元素）多个不同任务希望同时进行，互不打扰（多个线程需要做轮询操作）
3.什么是线程池？一组预设创建的线程，可以被重复使用来执行多个任务避免频繁的创建和销毁线程，减少线程创建和销毁开销，提高系统性能和效率异步编程默认使用线程池
4.什么是线程安全？线程安全：多个线程访问共享资源时，对共享资源的访问会导致数据不一致或者不可预期的结果。同步机制：用于协调多个线程之间执行顺序和互斥访问共享资源，确保线程按照特定的顺序执行，避免竞态条件和数据不一致问题原子操作：执行过程中不会被中断的操作，只能完全执行和完全不执行，不存在中间状态；多线程环境下，原子操作能保证数据的一致性和可靠性。
5.实现方式线程：thread线程池：threadpool异步编程： async await自带方法： Parallel（For、Foreach、Invoke）PLINQ(AsParallel、AsSequential、AsOrdered) 二：线程池 1.线程的创建
创建Thread实例，并传入ThreadStart委托—&gt;还可以配置线程，如是否为后台线程（Deamon = true）调用Thread.Start方法
2.线程终止调用Thread.Join方法,等待线程结束调用Thread.Interrupt方法，终端线程执行
3.线程的挂起与恢复thread.Suspend以及Thread.Resume较新版本.NET中，这两个方法已经被标记为Obsolete,且调用会报错推荐使用锁、信号灯方式实现这一逻辑 三：线程安全与同步机制 Thread-Safety 原子操作锁与信号量
lock &amp; Monitor
Mutex
Semaphore
WaitHandle
ManualResetEvent
AutoResetEvent
ReaderWriterLock轻量级
SemaphoreSlim
ManualResetEventSlim
ReaderWriterLockSlim不要自己造轮子
线程安全的单例：Lazy
线程安全的集合类型：ConcurrentBag、ConcurrentStack、ConcurrentQueue、ConcurrentDictionary
阻塞集合：BlockingCollection
通道：Channel
原子操作：Interlocked
周期任务：PeriodicTimer 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25cf046161391f3268f525e78d91f0d1/" rel="bookmark">
			2023华为OD机试真题(C&#43;&#43;语言) 真题目录介绍，机试真题 B&#43;C&#43;D卷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🚀前言🚀其他华为OD机试题清单一、什么是华为OD，什么是华为OD机试？二、华为OD面试流程？三、华为OD机试通过率高吗？四、华为OD薪资待遇？🚀五、怎么刷题？通过华为OD机试？华为OD原题刷题列表🔰部分思路及代码参考演示🔰本专栏刷题列表：2023华为OD机试真题（C++语言） B+C+D卷 📝最后作者：KJ.JK 🚀前言 本文是2023华为OD机试真题(C++语言)专栏的目录贴（持续更新中…）
🚀其他华为OD机试题清单 🔥2023华为OD机试真题(C C++ Java Py JS) B+C+D卷🔥
🔥2023华为OD机试真题(C语言) B+C+D卷🔥
🔥2023华为OD机试真题(Python语言) B+C+D卷🔥
🔥2023华为OD机试真题(Java 语言) B+C+D卷🔥
🔥2023华为OD机试真题(C++语言)B+C+D卷🔥
🔥2023华为OD机试真题(JS 语言) B+C+D卷🔥
🔥2023华为OD机试真题(Golang语言) B+C+D卷🔥
🔥2023华为OD机试真题(C++ Java Python) 🔥
一、什么是华为OD，什么是华为OD机试？ 华为OD是Outsourcing Dispacth模式，是华为和外企德科联合招聘的简称。目前华为大多数是OD招聘。OD模式也是华为提出的一种新的用工形式，每年都会从OD项目挑优秀员工转为正编。所有OD和正式员工一样对待，没有差别，部门平时开会、评审等活动都是一起参加的，是同薪同酬，都是由华为的HR直接定的薪资，看的是我们技术能力。华为是大企业，能到华为上班也是有能力的，每个部门都有好多职位，是金子，在哪都会发光。薪资对华为OD也是有绝对的优势，在互联网一线的大厂中，华为的工作环境和薪资都是很好的，OD其实简单说就是外包，现在有很多公司都在给华为供给外包服务，比如中软，因为华为有很多业务部门，去年一个很熟的猎头给我推荐了几个技术岗位的华为OD都通过了
而华为OD机试是指华为公司的在线笔试，是华为公司用于筛选招聘岗位候选人的一种考核方式，
华为OD机试通常由多个题目组成，包括算法设计、编程、调试等多个环节，考察候选人的基础知识、实际能力和算法编写能力等多个方面，是华为招聘流程中非常重要的一环
二、华为OD面试流程？ 华为OD面试流程一般包括以下几个步骤：
1、笔试：考察候选人的基础知识、算法设计和编程能力等多个方面，题目通常包括算法题、编程题、数据结构题等
2、性格测试(综合测试)：这部分是用来评估候选人的性格特质，以便更好地了解其适应能力、沟通能力和团队合作能力等
3、技术一面：该面试官通常是该项目组的技术负责人，主要考察候选人对技术的理解和实际应用能力。面试内容通常包括代码题和项目问题解决，围绕计算机/编程基础+项目经验+代码能力进行考察，如应届生无项目经验，重点复习八股文+刷算法题
4、HR面：围绕求职动机、稳定性、薪酬期望、Gap经历、延毕等异常情况进行考察
5、终面：终面是在参加完所有面试后进行的最后一轮面试，，主要考察候选人的综合素质和领导潜力；其中，笔试和性格测试是比较常见的部分，而技术一面和群面则比较特殊，通常会根据不同的岗位和项目有所不同，最终的面试结果也会根据个人的表现和竞争情况而定，不会限制通过人数
全流程线上进行，一般机考通过后2-3周内出offer，特殊情况时间过长的话需要积极联系接口人HR
三、华为OD机试通过率高吗？ 据华为官方公布的数据，华为OD机试的通过率约为75%。具体来说，华为OD机试一共有五个级别，从D1到D5，对应13到17级，每个级别的题目数量和难度都有所不同。在过去的招聘中，据说只有25%左右的候选人能够通过第一轮机试。第二轮性格测试也是招聘流程中的重要环节，会刷掉一部分人。不过，华为表示，最终的通过率取决于候选人的实际表现和竞争情况，不会限制通过人数
此外，华为还将机试分为上机考试和在线作业两部分，上机考试主要考察算法设计和编程能力，在线作业主要考察算法思维和解决问题的能力。华为表示，在线作业部分是考察候选人的综合能力，包括解决问题的能力、沟通能力和团队合作能力等。
综合来看，华为OD机试的通过率虽然不是100%，但是也是在高水平范围内的。对于候选人来说，需要全面提升自己的能力，才能更好地通过机试
四、华为OD薪资待遇？ 薪资结构：
1、基本工资+绩效工资+年终奖（2-4个月，一般绩效A-4个月，B-2个月）；
2、D1-D5分别对应华为13-17级，参考范围10-40K；
3、试用期内（6个月）工资不打折，按B绩效发绩效工资，转正时重新评绩效，一般分A、B、C三档（主要A或B，C概率较小），和正式员工分开评，半年评一次；
4、五险一金基数按基本工资，公积金比例5%-12%，具体看base地。
5、福利补贴：带薪年假、入职&amp;年度免费体检、免费夜宵、班车/加班打车免费、下午茶、节假日礼品等
13级薪资：9k-13k
14级薪资：13k-17k
15级薪资：17k-21k
16级薪资：21k-25k
17级薪资：25k-29k
🚀五、怎么刷题？通过华为OD机试？华为OD原题刷题列表 🔥2023华为OD机试真题(C C++ Java Py) B卷🔥
🔥2023华为OD机试真题(C语言)🔥
🔥2023华为OD机试真题(Python语言)🔥
🔥2023华为OD机试真题(Java 语言)🔥
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25cf046161391f3268f525e78d91f0d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/447db2b04043cedb4ff67545db8a99a9/" rel="bookmark">
			Electron安装时提示 Generated checksum for “electron-xxx.zip” did not match expected checksum 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Generated checksum for “electron-xxx.zip” did not match expected checksum 解决方法: 通过在执行npm时增加环境配置 ELECTRON_SKIP_BINARY_DOWNLOAD=1 来跳过二进制文件下载 或者使用淘宝镜像下载: cnpm install --disturl=https://npm.taobao.org/mirror --registry=https://registry.npmmirror.com
# 调试模式安装electron npm install --save-dev --verbose electron # npm ELECTRON_SKIP_BINARY_DOWNLOAD=1 npm install # yarn #ELECTRON_SKIP_BINARY_DOWNLOAD=1 yarn install 使用 --verbose 标志来显示下载进度:
npm install --verbose electron
其他方式:
删除相关的缓存文件后重新安装
macOS: ~/Library/Caches/electron/ 删除相关的缓存文件
操作系统-Windows 10
$LOCALAPPDATA/electron/Cache or ~/AppData/Local/electron/Cache/
淘宝镜像下载 Motrix 问题复现和解决实例
执行
yarn 问题:
Error: Generated checksum for "electron-v22.3.9-darwin-x64.zip" did not match expected checksum.
完整错误日志:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/447db2b04043cedb4ff67545db8a99a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/702bd50d028eb09d87f90607805f7927/" rel="bookmark">
			vue2中的指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue2中的指令 视图线 &amp; 数据线
v-xxx：指令，就相当于给标签（或组件）设置“自定义属性”
对视图进行编译的时候，识别v-xxx，对不同指令做不同处理。
v-html &amp; v-text 非表单元素设置内容，表单元素设置内容设置value
v-html.trim修饰符:传参
一般用法：非表单元素设置内容都用小胡子，需要识别html字符串才用v-html，v-text用得少。
v-show &amp; v-if（v-else v-else-if） 控制元素显示/隐藏
v-show：display:none
v-if：移除dom结构。元素的渲染/渲染
源码实现：
视图编译，v-if/v-show等编译成一个对象，对象中指令的名字、值，渲染的时候根据指令的名字和值来控制。v-show通过el.style.displey=none或''；v-if是removeNode/appendNode
v-if/v-else-if/v-else
元素必须紧挨
v-for 循环创建元素。
in的值可以是数组（最常用）、数字、对象等
视图编译先编译v-for，循环每一项创建一个li，v-for立即创建；
v-if立即销毁
v-on* 讲一下methods
使用bind改变this
@click="fn" fn直接是一个函数，事件触发执行fn函数
把指令解析成事件对象，内部addEventListener做了很多处理
fn()，并不是立即执行而是点击才执行。给函数了传递参数，这样就不需要bind那些，因为是根据vue内部视图编译机制有关。
手写$event就把事件对象传过去；基于addEventListener dom2级事件做的
修饰符：.stop .prevent
self不会阻止事件传播，会判断事件源是否是当前元素本身
和react的区别：
合成事件绑定，通过事件委托。root/document，冒泡/捕获阶段。
v-for+@click：性能会不好；建议使用事件委托
v-bind指令* 非字符串一定要使用v-bind
v-model* MVVM：
数据驱动视图渲染视图改变，对应状态也跟着改变 :value &amp; $emit('input')
把状态值先放在文本框/组件中然后@input监听更新value v-model原理：
先把状态值赋给组件的value属性组件自己加个input事件监听，触发时手动修改状态值 对于表单操作来讲，vue会更简单。管理系统，表单多，用vue开发会更方便。toB会优先选择vue。
技术团队实力 &amp; 老大的爱好
修饰符：
.lazy: 改为change，节流
.number: parseFloat处理
.trim: 去除首尾空格
给组件设置v-model指令，有一套单独的处理机制：
radio 一组：
每个radio都要设置value，v-model和哪个value匹配哪个就选中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/702bd50d028eb09d87f90607805f7927/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f67817a36e5e257e3eca0f2597ef729f/" rel="bookmark">
			普通人学Python有什么用？能干什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“ 我想学 Python，但是学完 Python 后都能干啥 ？”
相信不少 Python 的初学者，都会遇到上面的这些问题。很多的答案会涌入我们的脑海，因为Python实在是能做太多事情了。但是慢慢静下心来思考，我发现Python主要有三个方面的应用
Python主要有以下四大主要应用
网络爬虫
web开发
人工智能
接下来的文章将和大家详解聊聊这几个方面，正在学Python的朋友也请继续看下去，或许能对你将来的学习之路有所帮助呢。
1、网络爬虫
01
什么叫网络爬虫？
​ 网络爬虫又称网络蜘蛛，是指按照某种规则在网络上爬取所需内容的脚本程序。众所周知，每个网页通常包含其他网页的入口，网络爬虫则通过一个网址依次进入其他网址获取所需内容。
02
爬虫有什么用？
做为通用搜索引擎网页收集器；（google,baidu）
做垂直搜索引擎；.
科学研究：在线人类行为，在线社群演化，人类动力学研究，计量社会学，复杂网络，数据挖掘，等领域的实证研究都需要大量数据，网络爬虫是收集相关数据的利器；
偷窥，hacking，发垃圾邮件……
爬虫是搜索引擎的第一步也是最容易的一步。
03
用什么语言写爬虫？
C，C++：高效率，快速，适合通用搜索引擎做全网爬取。缺点，开发慢，写起来又臭又长
脚本语言：Perl, Python, Java, Ruby。简单，易学，良好的文本处理能方便网页内容的细致提取，但效率往往不高，适合对少量网站的聚焦爬取。
04
为什么最终选择Python？
用c#,java写的爬虫。区别不大，原理就是利用好正则表达式。只不过是平台问题。后来了解到很多爬虫都是用python写的，于是便一发不可收拾。Python优势很多，总结两个要点：
1、抓取网页本身的接口
相比与其他静态编程语言，如java，c#，C++，python抓取网页文档的接口更简洁；相比其他动态脚本语言，如perl，shell，python的urllib2包提供了较为完整的访问网页文档的API。（当然ruby也是很好的选择）
此外，抓取网页有时候需要模拟浏览器的行为，很多网站对于生硬的爬虫抓取都是封杀的。这是我们需要模拟user agent的行为构造合适的请求，譬如模拟用户登陆、模拟session/cookie的存储和设置。在python里都有非常优秀的第三方包帮你搞定，如Requests，mechanize
2、网页抓取后的处理
抓取的网页通常需要处理，比如过滤html标签，提取文本等。python的beautifulsoap提供了简洁的文档处理功能，能用极短的代码完成大部分文档的处理。
其实以上功能很多语言和工具都能做，但是用python能够干得最快，最干净。
Life is short， u need python.
2、web开发
01
什么是web开发呢？
​ WEB开发就比较好理解了，就是开发网页程序，不需要安装桌面程序直接通过浏览器进行操作的程序。
​ WEB框架是指那些为了提高WEB程序开发效率而开发出来的中间件基础平台，开发人员不需要从0开始写代码，而是通过调用框架来开发程序，以节省时间和成本。
02
那web开发需要用到哪些知识呢？
1、python基础，最基础的知识点：条件判断，循环，函数，类这些知识；
2、数据库基础知识，数据存在哪里？就是在数据库里，数据库的增删改查是会使用到的。
补充一点，Django和Flask等基于Python的Web框架最近在Web开发中非常流行。
这些Web框架可以帮助你用Python编写服务器端代码(后端代码)。这是在你的额服务器上运行的代码，而不是运行在用户设备和浏览器的代码(前端代码)。
Life is short， u need python.
3、人工智能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f67817a36e5e257e3eca0f2597ef729f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7e961615908443c3735e1ce936faa6e/" rel="bookmark">
			智慧农业-基于区块链技术的食品安全溯源解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于区块链
区块链采用了一种基于密码学的分布式账本系统，使得信息在传输和存储过程中变得高度加密和安全。通过使用哈希算法和去中心化的共识机制，将每一个交易都记录在不同的区块中，形成一个链式结构。这意味着一旦交易信息被记录，就几乎无法更改和篡改。对于金融交易或数据存储来说，这种特性能够大大提高信息的安全性，减少了数据被黑客攻击和篡改的可能性。
区块链技术在透明性方面也有独特优势。由于区块链上的交易信息具有公开可见的特点，任何人都可以查看和验证信息，这增强了交易的透明度。相比传统的中央化数据库，区块链的透明性使得任何人都可以了解到交易的真实情况，从而减少了潜在的欺诈行为。无论是消费者、企业还是政府机构，都能够更加信任区块链上的交易数据，并且能够及时发现和纠正任何违规行为。
区块链技术的去中心化特点也是备受瞩目的。传统的中央化系统通常由一个中心机构或集团控制，而区块链是一种分布式的网络结构，没有一个中心控制机构。这意味着没有单一的点可以被攻击或操纵，从而显著降低了系统被攻击的风险。此外，去中心化的特性也使得区块链技术更加具有民主化和包容性，任何个体和组织都能够参与到网络中，共同维护和管理整个系统。
随着人们对食品安全和质量的关注日益增加，智慧农业以及基于区块链技术的食品安全溯源解决方案逐渐成为人们关注的焦点。区块链技术作为一项新兴技术，被广泛应用于各个领域，包括食品安全领域。本文将探讨智慧农业如何利用区块链技术构建食品安全溯源解决方案，以提供可信的食品信息和保障消费者的健康。
食品安全问题一直是人们十分关心的一个话题。许多食品安全事故的发生往往给人们的生命健康带来严重威胁。在传统的食品供应链中，信息的不透明和数据的篡改是导致食品安全问题的重要原因之一。而区块链技术的去中心化、不可篡改和透明性的特点恰好能够解决传统食品供应链中的这些问题。
智慧农业利用区块链技术的核心目标是建立一个可信的食品溯源系统。该系统将追溯食品的生产、运输、加工等环节，并将这些信息记录在区块链上。每一个环节的数据都会被加密，并通过共识机制被验证和确认。这样一来，在食品供应链的每一个环节都能够确保数据的完整性和真实性。当消费者购买食品时，只需扫描食品上的二维码，便可获取到该食品的完整溯源信息，并且可以确认该食品的真实性和安全性。
智慧农业的区块链溯源解决方案可以带来多重好处。首先，消费者能够获取到真实、准确的食品信息，对于过敏体质的人群来说，这将是一项重要的保障。其次，当食品安全问题发生时，溯源系统能够快速定位问题的环节，降低食品安全风险。此外，溯源系统还可以用于打击假冒伪劣食品，维护市场秩序，并提高消费者的信任度。
然而，智慧农业的区块链溯源解决方案也面临一些挑战和问题。首先，建立一个完善的溯源系统需要各个环节主体的全力合作，确保数据的真实性和及时性。其次，数据的存储和处理也是一项巨大的挑战。由于区块链的数据不可篡改的特性，存储和处理大量的数据将会成为一个技术上的难题。此外，隐私问题也需要引起重视。在共享数据的过程中，如何保护个人隐私将是一个需要解决的问题。
综上所述，智慧农业利用区块链技术的食品安全溯源解决方案具有重要的意义和潜力。它将为消费者提供可信的食品信息，保障消费者的健康和权益。然而，要实现这一目标，我们需要各个环节主体的共同努力和创新技术的支持。只有这样，智慧农业的区块链溯源解决方案才能够在食品安全领域发挥更大的作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72fe1b2b7a53ac440ed5e941c2581f7f/" rel="bookmark">
			uniapp中两个app互相跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如,appA需要跳转到appB里面
第一步配置,android不用配置的，主要是配置ios的白名单
appB中
appA中
第二步代码
handleJump() { if (plus.runtime.isApplicationExist({ pname: 'com.', //安卓包名 action: 'https://a' //ios地址 })) { if (plus.os.name == 'Android') { plus.runtime.launchApplication({ pname: 'com.'//安卓包名 }, (e) =&gt; { //打开失败时 uni.showToast({ title: e.message, icon: 'none' }); console.log('Open system default browser failed: ' + e.message) } ) } else if (plus.os.name == 'iOS') { plus.runtime.launchApplication({ action: 'https://a' //ios地址 }, (e) =&gt; { //打开失败时 uni.showToast({ title: e.message, icon: 'none' }); console.log('Open system default browser failed: ' + e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72fe1b2b7a53ac440ed5e941c2581f7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b4b2e82f144d88c913ba60b9191b596/" rel="bookmark">
			16-网络安全框架及模型-BiBa完整性模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
BiBa完整性模型
1 背景概述
2 模型原理
3 主要特性
4 优势和局限性
5 应用场景
BiBa完整性模型 1 背景概述 Biba完整性模型是用于保护数据完整性的模型，它的主要目标是确保数据的准确性和一致性，防止未授权的修改和破坏。在这个模型中，完整性级别被用来描述数据的重要性和对数据完整性的需求。高完整性级别表示数据具有更高的重要性，低完整性级别表示数据的重要性较低。
Biba完整性模型采用主体、客体和完整性级别来描述安全策略要求。主体是指访问数据的用户或程序，客体是指被访问的数据或资源。完整性级别则用于描述数据的重要性和对数据完整性的需求。在Biba完整性模型中，主体只能对客体进行修改访问，且必须满足一定的条件，即主体的完整性级别必须不小于客体的完整性级别。同时，主体不能对客体进行读取访问，除非客体的完整性级别高于主体的完整性级别。
Biba完整性模型不关心机密性问题，而是专注于数据的完整性问题。机密性问题是指保护敏感数据不被泄露给未授权的实体，而完整性问题是指保护数据的准确性和一致性，防止未授权的修改和破坏。
Biba完整性模型具有三个安全特性：简单完整性、*特性和调用特性。简单完整性要求主体对客体进行访问的必要条件是主体的完整性级别小于客体的完整性级别，即主体不能向下读。*特性要求主体的完整性级别小于客体的完整性级别，不能修改客体，即主体不能向上写。调用特性要求主体的完整性级别小于另一个主体的完整性级别，不能调用另一个主体。
总的来说，Biba完整性模型是一个用于保护数据完整性的模型，它采用主体、客体和完整性级别来描述安全策略要求，而不考虑机密性问题。这个模型的主要目标是确保数据的准确性和一致性，防止未授权的修改和破坏。
2 模型原理 Biba完整性模型是一个用于保护数据完整性的模型，它通过主体、客体和完整性级别的管理，实现了对数据完整性的严格控制和保护。该模型的主要作用是确保数据的准确性和一致性，防止未授权的修改和破坏。
Biba完整性模型不直接关心数据的安全级别和机密性，而是侧重于防止数据从低完整性级别流向高完整性级别。这是通过比较主体的完整性级别和客体的完整性级别来实现的。如果主体的完整性级别不小于客体的完整性级别，则主体可以修改客体。这确保了只有具备足够权限的主体才能修改相应的客体，从而保护数据的完整性和一致性。
Biba完整性模型的作用机制是基于主体、客体和完整性级别的管理。每个主体和客体都被分配一个完整性级别，完整性级别由密级和范畴两部分组成。根据数据的完整性和敏感度要求，可以设置不同的完整性级别，并采取相应的管理和控制措施。通过这种方式，Biba完整性模型能够区分不同重要性和敏感度的数据，并根据需要进行不同的管理和控制。
Biba完整性模型的作用原理是基于对数据的完整性和机密性的严格管理和控制。通过主体和客体的完整性级别的管理，实现对数据完整性的控制和保护。这有助于防止对系统数据的非授权修改和破坏，保护敏感信息和关键数据的安全性。同时，Biba完整性模型还可以与其他安全模型结合使用，共同构建更加完善和安全的计算机系统安全体系。
综上所述，Biba完整性模型的作用原理是通过对主体、客体和完整性级别的管理，实现对数据完整性的控制和保护。这有助于保护敏感信息和关键数据的安全性，是计算机系统安全领域中的重要研究方向之一。
3 主要特性 Biba完整性模型是一种用于保护数据完整性的安全模型，主要应用于计算机系统中的信息管理。以下是Biba完整性模型的三个安全特性的详细解释：
1.简单完整性
简单完整性是Biba完整性模型中最基础的安全特性，要求主体的完整性级别不小于客体的完整性级别。这意味着，如果一个主体尝试访问一个客体，该主体的完整性级别必须至少与客体的完整性级别相等或更高。简单完整性通过以下方式防止未授权的访问和数据泄露：
主体只能读取与自己完整性级别相等的客体，而不能向下读取比自己完整性级别更低的客体。这确保了只有具备足够权限的主体才能访问相应的客体，从而保护数据的完整性和一致性。
简单完整性通过限制主体向下读取的能力，防止了低完整性级别的数据被高完整性级别的主体所读取，从而防止敏感信息的泄露。
2.*特性
*特性是Biba模型中用于防止数据被修改的安全机制。当主体的完整性级别小于客体的完整性级别时，主体不能修改客体。*特性通过以下方式防止数据被未授权修改或损坏：
主体只能修改与自己完整性级别相等的客体，而不能向上写入比自己完整性级别更高的客体。这有助于防止数据从低完整性级别流向高完整性级别，进一步增强了数据完整性的保护。
*特性通过限制主体向上写入的能力，防止了高完整性级别的数据被低完整性级别的主体所修改，从而防止了重要数据的篡改和破坏。
3.调用特性
调用特性是Biba模型中用于控制不同主体之间的调用关系的安全机制。如果一个主体的完整性级别小于另一个主体的完整性级别，那么第一个主体不能调用第二个主体。调用特性通过以下方式防止未授权的访问和潜在的安全风险：
主体只能调用与自己完整性级别相等的另一个主体，而不能调用比自己完整性级别更高的主体。这有助于防止不具备足够权限的主体对其他主体进行调用，从而保护系统的安全性和稳定性。
调用特性通过控制不同主体之间的调用关系，防止了潜在的安全风险和恶意攻击的传播。这有助于维护系统的整体安全性和稳定性。
综上所述，Biba完整性模型的三个安全特性通过严格控制主体的访问和修改权限以及控制不同主体之间的调用关系，实现了对数据完整性的保护。这些特性共同构成了Biba模型的核心，为计算机系统中的信息管理提供了重要的安全保障。
4 优势和局限性 Biba完整性模型的优势和局限性如下：
优势：
防止非授权修改：Biba模型主要用于防止非授权修改信息，以保护系统的信息完整性。通过采用主体、客体、完整性级别描述安全策略要求，该模型能够防止数据从低完整性级别流向高完整性级别，有助于防止数据被篡改或损坏。
适用于多种场景：Biba模型可以应用于多种场景，如信息管理系统、网络安全、数据库管理等，能够为这些场景提供有效的数据完整性保护。
简单易用：Biba模型采用简单的安全策略要求，易于理解和实施，适合用于大型系统的数据完整性保护。
局限性：
无法处理动态变化的数据：Biba模型在处理数据动态变化时的完整性保护方面存在局限性。例如，对于数据的生成、修改和删除等操作，Biba模型可能无法提供有效的完整性保护。
无法处理跨多个系统的数据完整性：Biba模型主要关注单个系统内的数据完整性，无法处理跨多个系统的数据完整性保护问题。在实际应用中，需要将Biba模型应用于跨系统的数据完整性保护，以确保不同系统之间的数据一致性和完整性。
无法处理高完整性应用需要处理低完整性输入的情况：Biba模型无法处理高完整性应用需要处理低完整性输入的情况，例如sshd等需要接收网络输入的情况。在实际应用中，需要确保高完整性应用与低完整性输入之间的安全交互，防止潜在的安全风险和恶意攻击的传播。
度量程序本身的缺陷：Biba模型的度量程序本身可能存在缺陷，这可能导致未授权的访问和数据泄露。在实际应用中，需要度量程序本身的缺陷并采取相应的措施来防止未授权的访问和数据泄露。
对低完整性进程的攻击的局限性：由于Biba模型的局限性，低完整性进程可能利用漏洞对高完整性进程进行攻击，破坏系统的安全性。在实际应用中，需要采取有效的措施防止低完整性进程的攻击，提高系统的安全性。
部署和实施的复杂性：Biba完整性模型的部署和实施可能涉及多个方面的配置和管理，具有一定的复杂性和技术难度。需要专业的安全团队进行支持和维护。
合规性和监管要求：在某些行业和应用场景中，数据完整性的保护可能受到严格的合规性和监管要求。Biba完整性模型的实施需要符合相关法律法规和监管要求，并提供必要的证据和文档支持。
性能和可用性的权衡：Biba完整性模型的实施可能会对系统的性能和可用性产生一定的影响。需要在保证数据完整性的同时，考虑性能和可用性的权衡，避免对业务造成过多的影响。
因此，在实际部署应用中，需要根据具体场景和需求进行选择和调整，并配合其他安全措施，共同构建更加完善和安全的计算机系统安全体系。
5 应用场景 Biba完整性模型主要适用于需要防止数据篡改或损坏的场景，特别是在那些对信息完整性要求较高的领域。以下是一些可能的应用场景：
金融交易系统：在金融交易系统中，数据的完整性和准确性至关重要。Biba完整性模型可以用于确保交易数据在传输和存储过程中的完整性，防止数据被篡改或损坏。
医疗保健系统：医疗保健系统中包含大量敏感信息，如患者病历、诊断结果等。Biba完整性模型可以用于保护这些信息的完整性，确保数据不被非法修改或泄露。
电子政务系统：政府机构处理大量敏感信息，如公民个人信息、国家安全数据等。Biba完整性模型可以帮助政府机构确保数据的完整性，防止数据被篡改或滥用。
电子商务系统：在电子商务系统中，商品的描述、价格、库存等信息需要保持完整和准确。Biba完整性模型可以用于确保这些信息的完整性，为消费者提供可靠的购物体验。
工业控制系统：在工业控制系统中，数据的完整性直接影响到生产过程的安全和稳定。Biba完整性模型可以用于保护这些数据的完整性，防止生产过程中的异常或事故。
需要注意的是，Biba完整性模型的应用场景取决于具体的需求和限制条件，如数据的安全要求、系统的复杂性和规模等。在实际应用中，需要根据具体情况进行选择和调整。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55beeba1f6fbf0bcd1972597250a56f7/" rel="bookmark">
			医学影像知识（三）：三维医学影像各向同性与各向异性的对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 医学影像中各向同性 (Isotropy)和各向异性 (Anisotropy)概念不同文件中像素间距存放位置DICOM文件NIfTI文件 各向同性和各向异性概念理解 各向同性和各向异性优劣势各向同性各向异性 在深度学习前的预处理 医学影像中各向同性 (Isotropy)和各向异性 (Anisotropy)概念 在讨论CT、MR和PET等医学断层扫描技术时，一个重要的考虑因素是图像在x、y、z三个方向上的像素间距是否一致。这些方向分别代表人体的不同方位：x方向是左右，y方向是前后，而z方向是上下（头脚）方向。
不同文件中像素间距存放位置 DICOM文件 DICOM 是一种广泛使用的医学影像文件格式，用于存储、传输和交换医学影像信息。
在DICOM文件中，像素间距和层厚（对应于z轴的间距）是作为元数据保存的。这些信息可以在DICOM标头中找到。
像素间距（Pixel Spacing）：通常记录了x和y方向的像素间距，以毫米为单位。
层间距（Slice Thickness） 和 层间隔（Slice Spacing）：描述了z方向上的间距。
NIfTI文件 NIfTI 是另一种常用的文件格式，特别是在神经影像学和研究领域。
NIfTI文件格式支持三维（甚至四维）数据的存储，并包含有关影像数据的空间定位和方向的详细信息。
像素间距信息（包括x、y、z轴）通常存储在文件的**头部信息（header）**中。
NIfTI格式提供了一种标准化的方法来描述和存储影像数据的空间维度和分辨率。
了解和使用这些像素间距信息对于许多应用至关重要，特别是在需要精确测量（如体积计算）、图像重建、图像配准或深度学习应用中。正确地解释和处理这些参数对于确保影像数据的准确性和一致性非常重要。例如，当将影像数据用于三维可视化或机器学习模型训练时，考虑各向异性或将数据转换为各向同性可能是必要的步骤。
各向同性和各向异性概念理解 通常情况下，CT图像在x和y方向（即水平层面）的像素间距较小，分辨率较高，大约为0.5mm。而在z方向（即纵向，从头到脚的方向）的像素间距，也就是层间距，通常较大，约在1到3mm之间。
这种在不同方向上分辨率的差异，会对后续的图像分析和处理产生影响。例如，在进行图像卷积或其他类型的图像处理时，处理各向同性（即各个方向上分辨率一致）的图像更为方便。为此，医学影像的预处理阶段通常包括一步关键的图像插值过程，以调整像素间距，实现xyz三个方向的像素间距一致。
这个调整过程主要有两种方法：上采样和下采样。
上采样：这种方法旨在将像素间距统一调整为最小间距（即最高分辨率）。例如，将CT图像的像素间距调整为与xy方向（水平层面）一致，统一设置为0.5mm。上采样的优点在于它能最大限度地保留原始图像的信息，但缺点是会产生更大的数据量，这可能给后续的数据处理和计算带来压力。需要注意的是，当水平方向和纵向的间距差异较大时，通过插值生成的中间层面可能不包含真实的图像信息。
下采样：这种方法是将像素间距调整为最大间距（即最低分辨率）。例如，将CT图像的像素间距调整为与z方向（纵向）一致，统一设置为1mm。下采样的优点是可以减少生成的数据量，便于后续处理和计算。但其缺点是可能会丢失一些图像细节。特别是当z方向的扫描间距相对较大时（如3mm或更大），下采样通常是更合适的选择。
因此，在选择上采样或下采样时，需要根据具体的应用场景、所需的图像质量和处理能力进行权衡。上采样能保留更多的图像细节，适用于对图像质量要求较高的场景；而下采样在减少数据量方面更有优势，适用于需要快速处理大量数据的场景。这两种方法的选择取决于具体的医学应用需求和研究目标。
各向同性和各向异性优劣势 各向同性 优势
空间一致性: 可以获得更一致、均匀的图像质量，便于识别和分析。
三维重建: 各向同性图像非常适合进行三维重建，因为所有方向的分辨率一致，可以获得更准确的三维模型。
准确的测量: 由于在所有方向上的均匀性，对结构的测量（如长度、体积）更为准确。
劣势
高数据要求: 要获得高质量的各向同性图像，需要更高的扫描分辨率，可能导致更长的扫描时间和更大的数据量。
可能的辐射剂量增加: 在某些情况下，为了获得更高的分辨率，可能需要增加辐射剂量，特别是在CT扫描中。
各向异性 优势
快速扫描: 较低的分辨率可以减少扫描所需时间。
减少数据量: 由于分辨率较低，产生的数据量较小，有利于数据存储和处理。
降低辐射剂量: 在某些情况下，可以通过降低扫描分辨率来减少辐射暴露。
劣势
空间失真: 可能导致图像的某些部分显示不够清晰或出现失真。
三维重建困难: 各向异性图像的三维重建可能不够准确，因为不同方向的分辨率不一致。
测量误差: 在进行结构测量时，由于不同方向的分辨率不同，可能导致测量误差。
在深度学习前的预处理 重采样: 将各向异性图像重采样为各向同性图像，以确保在所有方向上的一致性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55beeba1f6fbf0bcd1972597250a56f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17ae6d76230b01f4c2f20aceca2192f5/" rel="bookmark">
			QT基础与细节理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本博客旨在记录QT学习过程中的一些细节知识理解，由于问题的产生并非成体系，所以前期的记录可能会无序一些。烦请读者参阅目录进行快速的问题定位与跳转
QT基础与细节理解 前言正文部分QT基础：正确理解: QWidget(parent), ui(new Ui::ui_mywidget)QT基础：梳理图片拖动背后的逻辑QT基础：键盘事件中的AutoRepeat()到底在做什么QT基础：插件应该如何优雅的生成和加载QT基础：QOpenGL中，绘图坐标与材质坐标分别是怎样的QT基础：怎么快速发布QT程序QGraphicsItem碰撞检测Q&amp;A详析如何使得QWidget嵌入QGraphicsScene以备View显示，却不被Scene所管理QSlider的sliderMoved和valueChanged信号的不同妙用mouseDoubleClickEvent如何区分左右键双击 正文部分 QT基础：正确理解: QWidget(parent), ui(new Ui::ui_mywidget) 先摘抄一个定义完备的基本窗口项目，项目的结构如下：
- mywidget.pro --- qmake项目管理文件 - mywidget.h --- 基本窗口头文件 - mywidget.cpp --- 基本窗口类文件 - main.cpp --- 主类文件 - mywidget.ui --- 基本窗口样式文件 其中，mywidget.cpp中有参构造函数的写法引起我的注意：
MyWidget::MyWidget(QWidget *parent) : QWidget(parent), ui(new Ui::ui_mywidget) 经过查阅资料，得知这是C++的一种参数初始化方式—参数初始化表，在正式进入构造函数前，会依次执行冒号后的初始化内容：
QWidget(parent) — 表征派生类MyWidget调用基类QWidget的有参构造方法QWidget(QWidget *parent)，用于将由派生类初始化的对象注册为parent的子窗口（如果parent非空）ui(new Ui::ui_mywidget) — 等价于Ui::ui_mywidget *ui = new Ui::ui_mywidget（也可以使用后者的写法，因为此参数的初始化不强调顺序），即完成指针变量ui的初始化工作 通过上述解析，我们可以清晰地认识到以下两个问题：
冒号后的内容是C++的参数初始化表其有直接进行的函数调用，也有表征赋值的右值引用 QT基础：梳理图片拖动背后的逻辑 本小节内容来自《QT Creator第三版》5.3.2
要完成一个图片的拖动工作，关键在于四个基本虚函数的重写：
void mousePressEvent(QMouseEvent *event); // 鼠标按下事件void dragEnterEvent(QDragEnterEvent *event); // 拖动进入事件void dragMoveEvent(QDragMoveEvent *event); // 拖动事件void dropEvent(QDropEvent *event); // 放下事件 这里要区分一下dragEnterEvent和dragMoveEvent，前一个只在拖动开始时，和刚进入目标控件时调用，后一个则是在拖动过程中被不断的调用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17ae6d76230b01f4c2f20aceca2192f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9a4bc02667cc419ffa1bb93f7d0691c/" rel="bookmark">
			Keil5 新建STM32工程步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//************************新建工程************************//
新建文件夹“STM32project”。
打开“Keil5”。
选择“Project”，选择“New uVision Project”，选择“STM32project”文件夹。
输入文件名，选择芯片型号。
//************************启动文件************************//
打开“STM32project”文件夹，新建“Start”文件夹。
复制STM32启动文件，粘贴到“STM32project”文件夹里面的“Start”文件夹。
右键工程，选择“Add Group”，重命名“Start”。
右键“Start”，选择“Add Existing Files to Group ‘Start’”，
选择“Start”文件夹，文件类型选择“All files”，选择文件，选择“Add”。
选择“Options for Target”，选择“C/C++”，选择“Include Paths”，选择“New”，
选择“...”，选择“Start”文件夹，选择“OK”。
//************************用户文件************************//
打开“STM32project”文件夹，新建“User”文件夹。
右键工程，选择“Add Group”，重命名“User”。
右键“User”，选择“Add New Item to Group ‘User’”，
选择“C File”，输入文件名“main”，选择路径文件夹目录下“User”，选择“Add”。
//************************库函数文件************************//
打开“STM32project”文件夹，新建“Library”文件夹。
复制STM32库函数文件，粘贴到“STM32project”文件夹里面的“Library”文件夹。
右键工程，选择“Add Group”，重命名“Library”。
右键“Library”，选择“Add Existing Files to Group ‘Library’”，
选择“Library”文件夹，文件类型选择“All files”，选择文件，选择“Add”。
复制文件，粘贴到“STM32project”文件夹里面的“User”文件夹。
右键“User”，选择“Add Existing Files to Group ‘User’”，
选择“User”文件夹，文件类型选择“All files”，选择文件，选择“Add”。
选择“Options for Target”，选择“C/C++”，选择“Include Paths”，选择“New”，
选择“...”，选择“Library”文件夹，选择“OK”。
选择“Options for Target”，选择“C/C++”，选择“Include Paths”，选择“New”，
选择“...”，选择“User”文件夹，选择“OK”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9a4bc02667cc419ffa1bb93f7d0691c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81a6e3a40110bcff0d7ac3f0114304a0/" rel="bookmark">
			都说Python是万能的，但要是不知道它的五个主要用途，等于白学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大约是从16年开始Python就已经在国内被炒热了，你会在微信文章的广告里看到无数0元学Python、XXX如何通过学会Python实现月薪从5k到3w的广告。
当然，作为祖国未来的希望，Python也不会放过刚被“减负”的中小学生，现在小学生的教材里面都已经有Python了。。
但为什么全网都在说“人人都需要学Python”，仿佛它是万能的一样？
其实，Python之所以会被炒热，是因为从14、15年开始，大家都开始关注互联网行业，在这之中，程序员的高薪又是最受关注的，而相比其他语言，Python会比较简单且入门快，是不少程序员入门的首选语言。
如果你想学Python，或者你刚开始学习Python，那么你可能会问：“我能用Python做什么？”
这个问题不好回答，因为Python有很多用途。
但是随着时间，我发现有Python主要有以下五大主要应用：
一、Web开发 Python的诞生历史比Web还要早，由于Python是一种解释型的脚本语言，开发效率高，所以非常适合用来做Web开发。
像Django和Flask这样基于Python的Web框架最近在web开发中变得非常流行。
这些web框架帮助你用Python创建服务器端代码（后端代码）。这些代码在你的服务器上而不是在用户设备以及浏览器上（前端代码）运行。如果你不熟悉后端代码和前端代码之间的区别，可以参阅下面脚注。
但我为什么需要web框架呢？
那是因为web框架让构建通用后端逻辑变得更简单了。这包括把不同的URL映射到Python代码块、处理数据库和生成用户在浏览器中看到的HTML文件。
我应该用哪个Python web框架？
Django和Flask是两种最流行的Python web框架。如果您刚刚开始学习，那么可以用它们中的任何一个。
二、网络爬虫 许多人对编程的热情始于好奇，终于停滞。
网络爬虫是Python比较常用的一个场景。Google在早期大量地使用Python语言作为网络爬虫的基础，带动了整个Python语言的应用发展。以前国内很多人用采集器搜刮网上的内容，现在用Python收集网上的信息比以前容易很多了，如：
从各大网站爬取商品折扣信息，比较获取最优选择；
爬取网易云音乐某一类歌曲的所有评论，生成词云；
按条件筛选获得豆瓣的电影书籍信息并生成表格……
几乎每个人学习爬虫之后都能够通过爬虫去做一些好玩有趣的事（在合法合规的情况下）。
三、人工智能 人工智能是现在非常火的一个方向，AI热潮让Python语言的未来充满了无限的潜力。现在释放出来的几个非常有影响力的AI框架，大多是Python的实现，为什么呢？
因为Python有很多库很方便做人工智能，比如numpy, scipy做数值计算的，sklearn做机器学习的，pybrain做神经网络的，matplotlib将数据可视化的。在人工智能大范畴领域内的数据挖掘、机器学习、神经网络、深度学习等方面都是主流的编程语言，得到广泛的支持和应用。
四、数据分析 数据分析处理方面，Python有很完备的生态环境。“大数据”分析中涉及到的分布式计算、数据可视化、数据库操作等，Python中都有成熟的模块可以选择完成其功能。对于Hadoop-MapReduce和Spark，都可以直接使用Python完成计算逻辑，这无论对于数据科学家还是对于数据工程师而言都是十分便利的。
五、自动化运维 Python能满足绝大部分自动化运维的需求，又能做后端C/S架构，又能用WEB框架快速开发出高大上的WEB界面，只有当你自己有能力做出一套运维自动化系统的时候，你的价值才体现出来。
总结
看到这么多应用场景是不是觉得Python非常厉害，但是Python通常不作为工程语言出现，换言之正规的软件生产不使用它，主要用java, c#, xml, c，至于为什么，因为这是软件工程的需要。
而且Python不具有完整的语法检查，但这也不影响Python现在的地位，因为Python入门快，简单，学习成本相对低，有很丰富的支持库可以被直接调用以高效地完成不同需求的工作，所以越来越多的人开始加入Python大军。
-END-
学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后给大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
包括：Python激活码+安装包、Python web开发，Python爬虫，Python数据分析，人工智能、机器学习、自动化测试带你从零基础系统性的学好Python！
👉[CSDN大礼包：《python安装工具&amp;全套学习资料》免费分享]（安全链接，放心点击）
👉Python学习大礼包👈 👉Python学习路线汇总👈 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取哈）
👉Python必备开发工具👈 温馨提示：篇幅有限，已打包文件夹，获取方式在：文末
👉Python实战案例👈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
👉Python书籍和视频合集👈 观看零基础学习书籍和视频，看书籍和视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉Python面试刷题👈 👉Python副业兼职路线👈 这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以点击链接免费领取或者保存图片到wx扫描二v码免费领取 【保证100%免费】
👉[CSDN大礼包：《python安装工具&amp;全套学习资料》免费分享]（安全链接，放心点击）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b92dd205acd4154f72e6c6d628004fc9/" rel="bookmark">
			【Echarts】使用echarts和echarts-wordcloud生成词云图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载echarts和echarts-wordcloud
地址：https://download.csdn.net/download/qq_25285531/88663006
可直接下载放在项目中使用
二、词云数据
词云数据是对象的格式，可以从后端获取，这里以下面数据为例
$list3 = array( array('name' =&gt; '粉丝团', 'value' =&gt; '8'), array('name' =&gt; '发热我', 'value' =&gt; '15'), array('name' =&gt; '天', 'value' =&gt; '54'), array('name' =&gt; '人', 'value' =&gt; '83'), array('name' =&gt; '太热', 'value' =&gt; '15'), array('name' =&gt; 't热', 'value' =&gt; '11'), array('name' =&gt; '特瑞', 'value' =&gt; '65'), array('name' =&gt; '太热', 'value' =&gt; '65'), array('name' =&gt; '亚特人团', 'value' =&gt; '65'), array('name' =&gt; '东方化工', 'value' =&gt; '57'), array('name' =&gt; 'h规范', 'value' =&gt; '15'), array('name' =&gt; 'h规范', 'value' =&gt; '95'), array('name' =&gt; '粉丝团', 'value' =&gt; '90'), array('name' =&gt; '好地方', 'value' =&gt; '54'), array('name' =&gt; '给太热', 'value' =&gt; '70'), array('name' =&gt; '依托', 'value' =&gt; '50'), array('name' =&gt; 'y太热', 'value' =&gt; '58'), array('name' =&gt; '梵蒂冈', 'value' =&gt; '88'), array('name' =&gt; 'y他', 'value' =&gt; '11'), array('name' =&gt; '要让他', 'value' =&gt; '21'), array('name' =&gt; '和', 'value' =&gt; '92'), array('name' =&gt; '粉广泛的丝团', 'value' =&gt; '85'), array('name' =&gt; 'iuy', 'value' =&gt; '8'), array('name' =&gt; '广泛大概', 'value' =&gt; '58'), array('name' =&gt; 'g放到', 'value' =&gt; '75'), array('name' =&gt; '范德萨范德萨', 'value' =&gt; '55'), array('name' =&gt; 'g放到', 'value' =&gt; '12'), array('name' =&gt; 'r二维图', 'value' =&gt; '25'), array('name' =&gt; '吧v', 'value' =&gt; '15'), array('name' =&gt; '哦iu有', 'value' =&gt; '75'), array('name' =&gt; '哦iu有', 'value' =&gt; '65'), array('name' =&gt; '广泛的', 'value' =&gt; '5'), array('name' =&gt; 't热天坛人', 'value' =&gt; '55'), array('name' =&gt; '发大水了', 'value' =&gt; '15'), array('name' =&gt; 't热', 'value' =&gt; '5'), array('name' =&gt; '范德萨', 'value' =&gt; '25'), array('name' =&gt; '范德萨', 'value' =&gt; '55'), array('name' =&gt; 'rfew ', 'value' =&gt; '25'), array('name' =&gt; 'fgd ', 'value' =&gt; '35'), array('name' =&gt; 'hgf', 'value' =&gt; '95'), array('name' =&gt; '个人', 'value' =&gt; '85'), array('name' =&gt; 'y他', 'value' =&gt; '5'), array('name' =&gt; '范德萨', 'value' =&gt; '84'), array('name' =&gt; ' 也让', 'value' =&gt; '18'), array('name' =&gt; '范德萨', 'value' =&gt; '19'), array('name' =&gt; '烦烦烦', 'value' =&gt; '62'), ); 三、生成词云
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b92dd205acd4154f72e6c6d628004fc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47aae1c728752bdffbaf3ec8bd69a1b7/" rel="bookmark">
			oracle ORA-01704: string literal too long ORACLE数据库clob类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当oracle数据表中有clob类型字段时候，insert或update的sql语句中，超过长度就会报错
ORA-01704: string literal too long
update xxx set xxx = ' &lt;div&gt;&lt;h1&gt;123&lt;/h1&gt;&lt;/div&gt; ' where id= 100; 可以修改为
DECLARE str varchar2(10000); BEGIN str := '&lt;div&gt;&lt;h1&gt;123&lt;/h1&gt;&lt;/div&gt;'; update xxx set xxx = str where id= 100;; END; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9599f8d7089cee9c22838a3fdc030cf5/" rel="bookmark">
			Scannet v2 数据集介绍以及子集下载展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scannet v2 数据集介绍以及子集下载展示 文章目录 Scannet v2 数据集介绍以及子集下载展示参考数据集简介子集scannet_frames_25kscannet_frames_test 下载脚本 download_scannetv2.py 参考 scannet数据集简介和下载-CSDN博客
scannet v2 数据集下载_scannetv2数据集_蓝羽飞鸟的博客-CSDN博客
ScanNet数据集下载与导出颜色图、深度图、内参、位姿数据-CSDN博客
simplerecon/data_scripts/scannet_wrangling_scripts at main · nianticlabs/simplerecon (github.com)
数据集简介 数据集Github地址 ScanNet/ScanNet (github.com)
ScanNet 是一个 RGB-D 视频数据集，包含 1500 多次扫描中的 250 万个视图，并使用 3D 相机姿势、表面重建和实例级语义分割进行注释 。 ScanNet V2数据集一共1.2T 。（但其实不用全下载，按照对应的任务有选择的下载）
RGB-D 传感器是一种特定类型的深度感应设备，与RGB（红色、绿色和蓝色）传感器相机配合使用。 它通过在每个像素的基础上使用深度信息（与传感器的距离相关）来增强传统图像，即RGBD = RGB + Depth Map。
子集 由于整份数据较大，有1.2T，作者提供了下载较小子集的选项scannet_frames_25k（约25,000帧，从完整数据集中大约每100帧进行二次采样）通过ScanNet数据下载，有5.6G，还有基准评估scannet_frames_test。
scannet_frames_25k.zip ~5.6G，1513 份 scans（即 RGB-D 序列，这里简单当成 videos），包含训练集和测试集，训练集1201，验证集312scannet_frames_test.zip ~618mb ,100份，用作测试集 #下载scannet_frames_25k python download_scannetv2.py -o data --preprocessed_frames #下载scannet_frames_test python download_scannetv2.py -o data --test_frames_2d scannet_frames_25k scannet_frames_test 下载脚本 download_scannetv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9599f8d7089cee9c22838a3fdc030cf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/631664a9c2dac8402bce972e630af174/" rel="bookmark">
			Spring Boot快速搭建一个简易商城项目【一展示商城首页篇】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：今天我来使用Spring Boot快速搭建一个简易商城项目以下是相关的思路流程，如果有更好的思路，欢迎大佬评论留言！！！
一，实现思路： 创建 Spring Boot 项目： 使用 Spring Initializr（https://start.spring.io/）创建一个新的 Spring Boot 项目，添加 Web、JPA、freemack（或其他模板引擎Thymeleaf）、MySQL（或其他数据库）的依赖。
设计数据库结构： 设计商城所需的数据库表，比如商品表、订单表、用户表等。使用 JPA 或者 MyBatis 等持久层框架来实现对数据库的访问与操作。
创建实体类： 根据数据库设计创建对应的实体类，并使用注解来映射到数据库表，同时定义实体之间的关联关系。
编写业务逻辑： 创建服务类来处理商城的业务逻辑，比如商品的增删改查，用户的注册登录，订单的生成与支付等。
创建控制器： 编写控制器来响应前端页面的请求，接收参数并调用服务层完成相应的业务逻辑处理，然后返回结果给前端页面。
创建前端页面： 使用 Thymeleaf 或其他前端模板引擎创建商城的前端页面，包括商品展示页、购物车、订单页面等。
测试与调试： 对整个项目进行测试与调试，确保各项功能正常运行。
部署与发布： 将项目打包成可执行的 JAR 包，部署到服务器上并启动项目。
以上是一个简单的商城项目的搭建流程。在实际开发中，还需要考虑安全性、性能优化、异常处理等方面的内容。希望这些步骤能够对你有所帮助！如果还有其他问题，请随时提问。
二，使用到的相关技术点： Spring Boot：作为基础框架，用于快速构建应用程序的后端。
MySQL（或其他数据库）：作为数据存储后端，用于存储商品、订单、用户等信息。
Spring Web：用于构建 Web 应用程序，处理 HTTP 请求和响应。
Freemack：用于创建商城的前端页面，实现页面与后端数据的交互。
Spring Security：用于处理用户认证、授权等安全相关的功能。
RESTful API：如果你打算提供给其他应用程序使用的接口，可以考虑使用 RESTful 风格的 API。
Swagger：用于生成 API 文档，方便前端开发人员了解后端接口的使用方法。
Lombok：简化 Java 代码的开发，通过注解的方式来减少冗长的代码。
Log4j/Logback：用于日志记录，方便排查问题和追踪应用程序运行状态。
三，具体步骤： pom文件：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/631664a9c2dac8402bce972e630af174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b25fce40e0e71a58202032dc68048962/" rel="bookmark">
			开源项目解读 —— Self-Operating Computer Framework # 长期主义 # 价值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		价值：生成主函数业务逻辑函数思维导图，帮助理解，PR到开源项目，希望帮助大家理解IPA工作原理，国内没有好的开源项目，我就来翻译分析解读，给大家抛砖引玉。思维导图打算用文心一言配合其思维导图插件实现。
开源链接：OthersideAI/self-operating-computer: A framework to enable multimodal models to operate a computer. (github.com)
目录
目录
整体代码框架 核心代码逻辑
capture_screen_with_cursor # 用光标捕获屏幕
capture_mini_screenshot_with_cursor # 将截图和网格一起保存
add_grid_to_image # 给图像配上网格 keyboard_type# 用于通过程序模拟键盘输入
search # 模拟在操作系统中搜索文本。具体来说，它会模拟按下“开始”键（在Windows中）或“Command”和“空格”键（在MacOS中），然后输入提供的文本并按下“Enter”键。
keyboard_type# 用于通过程序模拟键盘输入
"extract_json_from_string" and "convert_percent_to_decimal"# 从json提取字符与把百分数转换为小数点
draw_label_with_background # 在屏幕上绘制一个网格，并在网格的每个交叉点上添加百分比标签。该函数可以捕获在 Linux 和 macOS 系统上工作。
click_at_percentage # 在屏幕上点击指定百分比的位置
mouse_click # 在屏幕上点击指定百分比的位置
summarize # 用于使用预先训练好的模型来生成摘要。该函数可以捕获屏幕截图并将其作为输入提供给模型。该函数可以尝试使用两个预训练模型：`gpt-4-vision-preview` 和 `gemini-pro-vision`。
parse_response # 用于该函数解析与 AI 对话交互的响应。该函数可以捕获不同的响应类型，例如点击、输入文本或搜索查询。总之，`parse_response` 函数将响应解析为字典，其中包含一个表示响应类型的字符串和一个与响应类型相关的数据
get_next_action_from_gemini_pro_vision # 该函数使用预训练的模型`gemini-pro-vision`生成下一个操作。该函数可以捕获屏幕截图并将其作为输入提供给模型。
get_next_action_from_openai # 该函数使用 OpenAI 的 GPT-4 模型生成下一个操作。该函数可以捕获屏幕截图并将其作为输入提供给模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b25fce40e0e71a58202032dc68048962/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f0bdfe5c546870b9fe2f4bcb721dea4/" rel="bookmark">
			探秘2D地图与数据可视化融合的创新力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在信息时代，数据可视化与2D地图的结合为我们的生活和工作带来了深刻的变革。这一强大的组合不仅为我们提供了全新的视角，更为各行各业的发展和决策提供了更为精准的指导。下面我就以可视化从业者的视角，来简单聊聊数据可视化和2D地图的结合。
首先，结合2D地图的数据可视化为城市规划和管理等带来了变化。通过将各类数据以图形和色彩的方式叠加在2D地图上，城市规划者能够直观地了解到人口密度、交通流量、用地分布等重要信息。这使得城市规划更科学、更合理，有助于提高城市的宜居性和可持续性。
另外，结合2D地图的数据可视化在应急管理和公共服务领域也有着重要的应用。例如，在自然灾害发生时，相关部门可以通过2D地图结合实时数据迅速了解受灾区域，有针对性地展开救援工作。在公共服务方面，有关部门可以通过2D地图可视化展示医疗资源、教育资源的分布情况，更科学地做出决策调整。
此外，数据可视化结合2D地图在科学研究和环境监测中也有广泛应用。科学家可以通过地图上的可视化数据更好地分析地球变化、气候趋势等信息，推动科学研究的进步。在环境监测方面，结合2D地图的数据可视化可以实时监控空气质量、水质情况等，为环保工作提供科学依据。
这里惯例推荐一下山海鲸可视化这款数据可视化软件，它的数据可视化相关编辑功能全部可以免费使用，并且没有任何限制，甚至如果你制作的是纯二维项目，那么私有化部署也是完全免费的。那么三维项目呢？尽管三维项目无法像二维项目一样免费部署，但是仍然可以免费编辑制作，只是最终导出后会存在水印。不过与同类产品相比，山海鲸可视化的免费化程度可以说是相当高了。
综合来看，数据可视化结合2D地图的强强联合为我们的生活带来了巨大的便利和创新。无论是在城市规划、商业决策、应急管理还是科学研究领域，这一技术组合都为我们提供了更清晰、更直观的信息呈现方式，推动了各行各业的发展。未来，随着技术的不断进步，这种结合势必为我们带来更多的惊喜和变革。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f02980e83dadd1f8d21acc853c10ab41/" rel="bookmark">
			Fiddler工具 — 1.Fiddler介绍与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Fiddler简介 Fiddler是强大的抓包工具之一，它能记录所有客户端和服务器之间的HTTP和HTTPS请求，是web调试的利器。Fiddler是位于客户端和服务端之间的HTTP代理，它的原理是以web代理服务器的形式进行工作的，使用的代理地址是：127.0.0.1，端口默认为8888，我们也可以通过设置进行修改。Fiddler可以抓取支持HTTP代理的任意程序的数据包，如果要抓取https会话，要先安装证书。 说明：
代理就是在客户端和服务器之间设置一道关卡，客户端先将请求数据发送出去后，代理服务器会将数据包进行拦截，代理服务器再冒充客户端发送数据到服务器；
同理，服务器将响应数据返回，代理服务器也会将数据拦截，再返回给客户端。
如果你想学习fiddler抓包，我这边给你推荐一套视频，这个视频可以说是B站播放全网第一的fiddler抓包教程，同时在线人数到达1000人，并且还有笔记可以领取及各路大神技术交流：798478386 2024备战金三银四，最新版fiddler抓包实战教程！_哔哩哔哩_bilibili2024备战金三银四，最新版fiddler抓包实战教程！共计8条视频，包括：1、fiddler和F12抓包对比、2、Fiddler工作原理、3、配置证书抓取https包等，UP主更多精彩视频，请关注UP账号。https://www.bilibili.com/video/BV19j411J7oc/?spm_id_from=333.337.search-card.all.click
2、Fiddler功能 Fiddler可以针对特定的HTTP请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据。
其他功能包括：
监控浏览器所有的HTTP/HTTPS流量。查看、分析请求内容细节。伪造客户端请求和服务器响应。测试网站的性能。解密HTTPS的web会话。全局、局部断点功能。可进行第三方插件功能扩展。 3、Fiddler工作原理 （1）先来了解一下B/S架构
编写程序部署到web服务器。web服务器运行在服务器上，绑定ip地址并监听某端口，接收和处理HTTP请求。客户端通过HTTP协议的请求，获取服务器上的网页、文档等资源。 （2）Fiddler工作原理
Fiddler的工作原理，是它在客户端和服务端之间搭建了一层proxy，所有的请求都会经过它。也就是说：客户端的所有请求都要先经过Fiddler，然后转发到相应的服务器。反之，服务器端的所有响应，也都会先经过Fiddler然后发送到客户端，所以web客户端和服务器的请求如下图所示：
（3）Fiddler工作原理进阶说明
使用Fiddler的话，需要先设置浏览器的代理地址，才可以抓取到浏览器的数据包。而方便的是，在你启动该工具后，它就已经自动帮你设置好浏览器的代理了。当关闭Fiddler后，它又将浏览器代理还原了。当然如果发现没有自动设置浏览器代理的话，那就得自己动手去浏览器进行设置代理操作了，例如火狐浏览器。（可自行百度每个浏览器是如何设置代理的），反正一定要设置相应的代理，否则Fiddler是无法捕获到HTTP请求的。 说明：
在Windows系统中，浏览器访问网站时，默认是访问Windows中的系统代理。
而当Fiddler一打开时，就会代替这个系统代理。
在Fiddler点击Tools —&gt; Options... —&gt; Connections选项中
上图说明：
Fiddler listens on port：Fiddler监听的端口是8888。Act as system proxy on startup：Fiddler在启动时充当系统代理。 注意：
Google浏览器和IE浏览器默认访问的系统代理，Fiddler 就会自动代替。而火狐浏览器需要自己手动配置。Fiddler监听的端口是可以自定义配置的，1024到65535的端口都可以，只要不冲突即可。 下面我们以Google浏览器来进行说明：
打开谷歌浏览器，进入设置页面。 点击在左上的的三条横线 —&gt; 高级 —&gt; 系统 —&gt; 点击打开代理设置。
在连接选项中点击局域网设置，可以看到左边代理服务器没有勾选。
当我们打开Fiddler后，在来查看上面代理服务器的状态，如下：
在Fiddler点击Tools —&gt; Options... —&gt; Connections选项
我们可以看到Fiddler端口就是8888。
这说明Fiddler自动配置了浏览器的系统代理。
4、Fiddler安装 （1）Fiddler许可协议
在安装之前，您必须同意此许可。
（2）选择Fiddler安装目录
（3）点击Install安装
（4）点击Close完成安装
（5）把Fiddler启动文件配置到桌面
Fiddler安装完成后，在桌面是没有快捷启动方式的，需要到Fiddler的安装目录中，把Fiddler.exe文件发送到桌面。
（6）打开Fiddler软件
在打开Fiddler时会有一个弹窗，如下图：
可以自行翻译，选择No即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1feb42f904d5212f4266facd67853e2c/" rel="bookmark">
			Java在SpringCloud中自定义Gateway负载均衡策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java在SpringCloud中自定义Gateway负载均衡策略 一、前言 spring-cloud-starter-netflix-ribbon已经不再更新了，最新版本是2.2.10.RELEASE，最后更新时间是2021年11月18日，详细信息可以看maven官方仓库：org.springframework.cloud/spring-cloud-starter-netflix-ribbon，SpringCloud官方推荐使用spring-cloud-starter-loadbalancer进行负载均衡。
背景：大文件上传做切片文件上传；
流程：将切片文件上传到服务器，然后进行合并任务，合并完成之后上传到对象存储；现在服务搞成多节点以后，网关默认走轮循，但是相同的服务在不同的机器上，这样就会导致切片文件散落在不同的服务器上，会导致文件合并失败；所以根据一个标识去自定义gateway对应服务的负载均衡策略，可以解决这个问题；
我的版本如下：
&lt;spring-boot.version&gt;2.7.3&lt;/spring-boot.version&gt;
&lt;spring-cloud.version&gt;2021.0.4&lt;/spring-cloud.version&gt;
&lt;spring-cloud-alibaba.version&gt;2021.0.4.0&lt;/spring-cloud-alibaba.version&gt;
二、参考默认实现 springCloud原生默认的负载均衡策略是这个类：
org.springframework.cloud.loadbalancer.core.RoundRobinLoadBalancer
我们参考这个类实现自己的负载均衡策略即可，RoundRobinLoadBalancer实现了ReactorServiceInstanceLoadBalancer这个接口，实现了choose这个方法，如下图：
在choose方法中调用了processInstanceResponse方法，processInstanceResponse方法中调用了getInstanceResponse方法，所以我们我们可以复制RoundRobinLoadBalancer整个类，只修改getInstanceResponse这个方法里的内容就可以实现自定义负载均衡策略。
三、实现代码 原理：根据请求头当中设备的唯一标识传递到下游，唯一标识做哈希取余，可以指定对应的服务器节点，需要的服务设置自定义负载策略，不需要的服务设置默认的轮循机制即可
package com.wondertek.gateway.loadBalancer; import cn.hutool.core.util.ObjectUtil; import com.wondertek.web.exception.enums.HttpRequestHeaderEnum; import lombok.extern.slf4j.Slf4j; import org.springframework.cloud.gateway.filter.GatewayFilterChain; import org.springframework.cloud.gateway.filter.GlobalFilter; import org.springframework.core.Ordered; import org.springframework.http.server.reactive.ServerHttpRequest; import org.springframework.stereotype.Component; import org.springframework.web.server.ServerWebExchange; import reactor.core.publisher.Mono; @Slf4j @Component public class RequestFilter implements GlobalFilter, Ordered { @Override public int getOrder() { // 应该小于LoadBalancerClientFilter的顺序值 return Ordered.HIGHEST_PRECEDENCE; } @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { ServerHttpRequest request = exchange.getRequest(); String clientDeviceUniqueCode = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1feb42f904d5212f4266facd67853e2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dc9fcba550a6909173504bdd9680a7c/" rel="bookmark">
			【http】HTTP/1.0、HTTP/1.1和HTTP/2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨ 专栏介绍 在当今互联网时代，计算机网络已经成为了人们生活和工作中不可或缺的一部分。而要实现计算机之间的通信和数据传输，就需要依靠各种网络协议来进行规范和约束。无论是浏览网页、发送电子邮件还是进行在线交流，都离不开各种各样的网络协议。在本专栏中，我们将深入学习各种常见的网络协议，如HTTP、TCP/IP、UDP、DNS等。我们将探索这些协议的工作原理、数据包结构、状态管理以及与其他协议的关系。此外，我们还将介绍网络安全和加密技术，以及常见的网络攻击和防御方法。通过学习这些内容，你将能够更好地理解计算机网络的运作原理，并能够应用这些知识来解决实际问题和优化网络性能。让我们一起开始探索网络协议的奥秘吧！点击订阅网络协议专栏
文章目录 ✨ 专栏介绍引言1. HTTP/1.0特性：优点：缺点： 2. HTTP/1.1特性：优点：缺点： 3. HTTP/2.0特性：优点：缺点： 总结😶 写在结尾`前端设计模式专栏``Vue专栏``JavaScript（ES6）专栏` 引言 本文将对HTTP协议的三个重要版本进行比较，包括HTTP/1.0、HTTP/1.1和HTTP/2.0。我们将探讨它们的特性、优缺点，并通过示例来说明它们在实际应用中的差异。最后，我们将总结各个版本的优势和适用场景。
1. HTTP/1.0 特性： 请求和响应格式：
HTTP/1.0使用文本格式来传输请求和响应。请求由请求行、请求头和可选的请求体组成，而响应由状态行、响应头和实体组成。
支持多种HTTP方法：HTTP/1.0支持多种HTTP方法，包括GET、POST、HEAD、PUT、DELETE等。这些方法允许客户端与服务器进行不同类型的交互。
请求头和响应头：HTTP/1.0引入了请求头和响应头，用于传递关于请求或响应的附加信息。例如，请求头可以包含用户代理信息、Cookie等，而响应头可以包含内容类型、内容长度等。
状态码：HTTP/1.0引入了状态码来表示服务器对请求的处理结果。常见的状态码包括200（成功）、404（未找到）、500（服务器内部错误）等。
持久连接：在HTTP/1.0之前，每个请求都需要建立一个新的TCP连接。而在HTTP/1.0中，引入了持久连接（keep-alive）机制，允许在一个TCP连接上发送多个请求和响应。这样可以减少连接建立和关闭的开销，提高性能。
缓存控制：HTTP/1.0引入了一些缓存控制机制，允许客户端和服务器进行缓存的管理。例如，通过设置响应头中的Cache-Control字段，可以指定缓存的行为。
无状态：HTTP/1.0是无状态协议，即服务器不会保留客户端之前的请求信息。每个请求都是独立的，服务器只根据当前请求来处理。
优点： 简单易用: HTTP/1.0使用文本格式传输数据，易于理解和调试。
兼容性好: 由于HTTP/1.0是最早的版本之一，它具有广泛的兼容性，并且可以与旧版本的服务器和客户端进行通信。。
缺点： 性能较低：每个请求都需要建立和关闭TCP连接，导致了较高的延迟。而且每个请求只能获取一个资源，不能同时获取多个资源。
无法复用连接：由于每个请求都需要一个独立的TCP连接，在高并发情况下会导致服务器资源消耗过大。
由于每个请求都是独立的连接，因此会带来下面的问题：
连接的建立和销毁都会占用服务器和客户端的资源，造成内存资源的浪费连接的建立和销毁都会消耗时间，造成响应时间的浪费无法充分利用带宽，造成带宽资源的浪费 2. HTTP/1.1 特性： 持久连接：HTTP/1.1默认启用持久连接（keep-alive），允许在一个TCP连接上发送多个请求和响应。这样可以减少连接建立和关闭的开销，提高性能。
管道化（pipelining）：HTTP/1.1引入了管道化机制，允许客户端发送多个请求而无需等待每个请求的响应。这样可以减少延迟，并提高网络利用率。
分块传输编码（chunked transfer encoding）：HTTP/1.1支持分块传输编码，允许服务器将响应分成多个块进行传输。这样可以在接收到部分响应时就开始渲染页面，而不需要等待整个响应完成。
虚拟主机支持：HTTP/1.1支持虚拟主机，允许在同一个IP地址上托管多个域名，并根据请求中的Host头部字段来区分不同的网站。
缓存控制增强：HTTP/1.1引入了更多的缓存控制机制，例如通过Cache-Control头部字段来指定缓存的行为，以及通过ETag和If-None-Match头部字段来进行缓存验证。
断点续传：HTTP/1.1支持断点续传，允许客户端在下载大文件时可以从上次中断的地方继续下载，而不需要重新下载整个文件。
优点： 性能改进：持久连接和管道化机制减少了连接建立和关闭的开销，提高了性能。更高效的网络利用率：管道化机制允许同时发送多个请求，提高了网络利用率。更灵活的缓存控制：HTTP/1.1引入了更多的缓存控制机制，使得缓存更加灵活和高效。 缺点： 队头阻塞（head-of-line blocking）：由于HTTP/1.1使用单个TCP连接来发送多个请求和响应，如果某个请求或响应被阻塞或丢失，后续的请求或响应也会被阻塞。这种情况称为队头阻塞，可能导致性能下降。无法处理大量并发请求：由于HTTP/1.1仍然使用单个TCP连接来处理请求和响应，当有大量并发请求时会导致服务器资源消耗过大。 HTTP1.1允许在响应到达之前发送下一个请求，这样可以大幅缩减带宽限制时间，但这样做会存在队头阻塞的问题。由于多个请求使用的是同一个TCP连接，服务器必须按照请求到达的顺序进行响应，于是，导致了一些后发出的请求，无法在处理完成后响应，产生了等待的时间，而这段时间的带宽可能是空闲的，这就造成了带宽的浪费。
3. HTTP/2.0 特性： 1. 二进制传输：HTTP/2.0使用二进制格式而不是文本格式来传输数据。这样可以提高传输效率和解析速度。
2. 多路复用（multiplexing）：HTTP/2.0允许在一个TCP连接上同时发送多个请求和响应。这样可以减少连接建立和关闭的开销，并提高网络利用率。
3. 头部压缩：HTTP/2.0使用HPACK算法对请求和响应头部进行压缩，减少了数据传输的大小。
4. 服务器推送（server push）：HTTP/2.0允许服务器在客户端请求之前主动推送相关资源。这样可以减少客户端发送额外请求的次数，提高页面加载速度。
5. 流量控制：HTTP/2.0引入了流量控制机制，允许客户端和服务器控制数据流的速率，避免了过载或拥塞情况的发生。
6. 优先级（priority）：HTTP/2.0允许客户端指定请求的优先级，以确保重要资源能够更快地加载。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dc9fcba550a6909173504bdd9680a7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5cd4d39491e694136c364ed15b72530/" rel="bookmark">
			LINUX 解决系统卡死：扩大内存交换分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近电脑总是卡住，让我很是苦恼。运行程序时发现可能是内存占满之后导致界面卡住。下面是在我16G内存的电脑上折腾的过程与结果：
查看当前的交换内存大小free -m（单位：-m选项表示以兆字节（MB）为单位显示内存使用量） total used free shared buff/cache available Mem: * * * * * * Swap: 2047 0 2047 在Linux系统中，/proc/swaps文件是一个虚拟文件，用于显示当前系统上的交换分区（swap partition）和交换文件（swap file）的信息。你可以使用以下命令查看/proc/swaps文件的内容：
cat /proc/swaps 注意，/proc目录下的文件和文件夹都是虚拟文件系统，它们提供了对内核和系统信息的访问。因此，/proc/swaps文件实际上并不是一个真正的文件，而是通过内核动态生成的。
该文件的内容包含了每个交换设备的详细信息，每行对应一个交换设备。每行的字段如下： Filename：交换设备的路径或文件名。Type：交换设备的类型，可以是"partition"（分区）或"file"（文件）。Size：交换设备的大小。Used：已使用的交换空间大小。Priority：交换设备的优先级。如果系统没有启用交换分区或交换文件，则/proc/swaps文件将为空。
关闭交换分区 sudo swapoff 上一步输出的Filename
创建一个swapfile文件 sudo dd if=/dev/zero of=swapfile bs=1024 count=10000000 ，其大小为 bs x count = 1024 × 10000000 = 10G
这是一个使用 dd 命令创建交换文件（swap file）的命令。 解释如下： dd: 是一个用于复制和转换文件的命令。 if=/dev/zero: if 表示输入文件，这里指定为 /dev/zero，它是一个特殊的设备文件，读取该文件会返回无限个零字节。 of=swapfile: of 表示输出文件，这里指定为 swapfile，即要创建的交换文件的名称。 bs=1024: bs 表示块大小（block size），这里设置为 1024 字节，表示每次读取和写入的数据块大小为 1024 字节。 count=10000000: count 表示要复制的块数，这里设置为 10000000，表示要复制 10000000 个块，即总共创建一个大小为 10GB 的交换文件。 综上所述，该命令的作用是以超级用户权限创建一个名为 swapfile 的交换文件，文件大小为 10GB。交换文件在某些情况下可以用作虚拟内存的扩展，用于处理系统内存不足的情况。 sudo chmod 600 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5cd4d39491e694136c364ed15b72530/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00b55b89f4c9773629e378b504958e89/" rel="bookmark">
			RuntimeError: GET was unable to find an engine to execute this computation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CUDA版本是11.1，虚拟环境中安装的torch是2.0.0，首先调用torch出现问题ImportError: libcupti.so.11.7:cannot open shared object file: No such file or directory该问题的解决办法如下：
检查是否存在该文件
locate libcupti.so.11.7 在该虚拟环境中重新安装torch，还是没生成nvidia这个文件。
从其他的文件中将文件拷贝到虚拟环境的对应包下。
解决上述问题后又出现问题RuntimeError: GET was unable to find an engine to execute this computation该问题解决方法：
检测torch和cuda是否能用
import torch print(torch.__version__) print(torch.cuda.is_available()) 测试
import torch print(torch.cuda.is_available()) num_gpu =1 # Decide which device to run on device = torch.device("cuda:0" if (torch.cuda.is_available() and num_gpu &gt; 0) else "cpu") print(device) print(torch.cuda.get_device_name(0)) print(torch.rand(3,3).cuda()) 检查cudnn是否可用
print(torch.backends.cudnn.version()) 官网下载cuda
CUDA官网下载
cuda安装
下载解压cudnn
Local Installers for Windows and Linux, Ubuntu(x86_64, armsbsa)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00b55b89f4c9773629e378b504958e89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b450eff9aa1056a8f9762a1f573cb7f2/" rel="bookmark">
			[设计模式]某一个流程中，经理可以指定其他人员代替经理审批流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以使用代理模式来实现经理可以指定其他人员代替审批流程的功能。代理模式允许通过一个代理对象来控制对原始对象的访问，从而在不改变原始对象的情况下，增加额外的逻辑处理。
在这个场景中，我们可以定义一个抽象的审批流程接口，例如 ApprovalProcess，其中包括审批的方法。然后定义一个 Manager 类作为原始对象，实现 ApprovalProcess 接口。Manager 类中可以定义一个包含代理对象的成员变量，例如 ProxyApprovalProcess。在需要指定他人代替审批的情况下，经理可以调用 ProxyApprovalProcess 的相关方法，将审批委托给其他人员进行处理。
以下是一个简单的示例代码：
// 抽象审批流程接口 public interface ApprovalProcess { void approve(); } // 经理类 public class Manager implements ApprovalProcess { private ApprovalProcess proxyApprovalProcess; public Manager() { this.proxyApprovalProcess = new ProxyApprovalProcess(); } @Override public void approve() { // 判断是否需要指定他人代审 if (需要指定他人代审) { proxyApprovalProcess.approve(); } else { // 经理自己审批的逻辑 } } } // 代理审批流程类 public class ProxyApprovalProcess implements ApprovalProcess { private ApprovalProcess otherPerson; public void setOtherPerson(ApprovalProcess person) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b450eff9aa1056a8f9762a1f573cb7f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d9e9f8cdc9ee083648a67bd2b4cc23b/" rel="bookmark">
			大厂前端面试题总结（百度、字节跳动、腾讯、小米.....），附上热乎面试经验！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先简单介绍下自己，我“平平无奇小天才”一枚，毕业于南方普通985普通学生，有幸去百度、字节面试，感觉大公司就是不一样，印象最深的是字节，所以有必要总结一下面试经验，以及面试中遇到的一些问题，以便大家参考：
本文目录 投简历的过程面试前做出的准备快要面试时做出的准备面试前奏，其实很紧张面试题目大厂面试特点面试总结最后 投简历的过程 首先肯定是找一个简洁不浮夸却有很精美的简历模板，然后将自己的信息填上去，主要的就是：姓名、电话、照片、擅长的技术栈、教育经历、实习经历、项目经历、证书、社交网站。这里要强调的是：不太熟悉的东西别往上写，没用的东西别往上写。
然后就是投简历的渠道问题了，这里我要给个建议，最好找别人内推一下，因为这样更快让你的简历被看到，避免长时间没有音讯。不过要提的是，找的内推人一定要靠谱！一定要靠谱！要找那种能给你一些简历修改建议的，会帮你跟进后续流程的，部门hc真的充足的人，而不是找那种广撒网的，因为他们根本没时间管你，可能你投进去，反而卡了流程（真的感同身受）
面试前做出的准备 我在面试前准备以下几点东西，似乎都解决了面试的部分问题
面试前我查阅了其他大佬写的字节跳动的面经以及面试题目，寻找题目解答，把它们总结了下来，用了一天一夜的时间，把它们整理成了文档。
我做了一份详细的自我介绍，通过项目开发经历来总结出了我的一些优点和开发经验，用讲故事的形式说明情况，最后点明故事中表现了自己具有哪些素质，点明自己为什么可以做前端的工作。字节跳动的宗旨“和优秀的人一起做有挑战的事情”也被我用到了自我介绍中，“我认为我是优秀的人，也喜欢做有挑战的事情，更喜欢与优秀的人为伍”“我希望搭上字节跳动这架火箭”等等。
快要面试时做出的准备 快要面试了，第一次面试，有些紧张，但还是像平常考试一样，将总结下来的面试题目总结、前端遇到问题的总结又看了一遍，把自己做好的自我介绍熟悉的过几遍，给自己亲近的朋友发条消息获得她的祝福，又站在电脑桌前活动了一下身子，头脑顿时清醒利索了许多。
面试前奏，其实很紧张 由于紧张怕错过面试，早早的便坐在了电脑桌前。面试官迟到了一会，就给我发起了面试视频邀请，终于开始了。
迎面是一个挺帅气的哥哥，简单的打了一下招呼，就进入了自我介绍的环节。由于自我介绍我已经熟悉过几遍了，自我介绍的效果看起来效果还是不错的。
开始问我项目经历的细节以及自我介绍中的细节，由于项目经历确实是自己亲身经历过的事情，并且我一般项目完成时都会做一下总结，所以也能够答个头头是道。个人感觉是这样的，至于面试官怎么想的，我就不清楚了， 说不定是那种我就静静的看着你装逼的情况。
由于篇幅限制，下方面试题目仅展示了部分， 有需要的朋友可以 戳此传送门即可获取完整版的 PDF 哦 面试题目 来了来了，开始问技术的问题了。 1.你对Vue的理解有多少
因为我在简历的项目经历中写了一个Vue项目，于是他问的时候就把我在项目中对Vue的理解和面试前准备的Vue总结结合起来回答。
用css2和css3分别写一下垂直居中和水平居中 这道题我不会，并不知道css2和css3有什么区别以及写法，只会css3，我脑袋里有面试前总结的垂直居中和水平居中其中的两种方式，我就给他讲了一讲，倒是他没有再问下去，可能看出来我不会了吧。这也体现出了面试前知识点总结复习的重要性，不然你不会的东西你连说都不会说。
2.使用Float进行布局容易产生什么问题？解决方式呢？
子元素在设置 float 后会脱离文档流，造成父元素高度塌陷 解决方式：
父元素设置高度
清除浮动
&lt;div class="outter"&gt; &lt;div class="inner"&gt;&lt;/div&gt; &lt;div style="clear: both;"&gt;&lt;/div&gt; &lt;/div&gt; // test.css .outter { width:200px; background:#3FF; border:1px solid #000;} .inner { float:left; width:120px; height:80px; background:#FF3; } 3.你对计算机网络的认识怎么样
又是一道探底的题，判断能否从这里给你出题考察你
4.讲述一下计算机网络的七层
应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
5.HTTPS是什么
HTTPS即加密的HTTP，HTTPS并不是一个新协议，而是HTTP+SSL（TLS）。原本HTTP先和TCP（假定传输层是TCP协议）直接通信，而加了SSL后，就变成HTTP先和SSL通信，再由SSL和TCP通信，相当于SSL被嵌在了HTTP和TCP之间
6.介绍几种常见的状态码
2XX系列：代表请求已成功被服务器接收、理解、并接受。
200状态码：表示请求已成功，请求所希望的响应头或数据体将随此响应返回
201状态码：表示请求成功并且服务器创建了新的资源，且其 URI 已经随Location 头信息返回。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d9e9f8cdc9ee083648a67bd2b4cc23b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43758887394d7a2151576644eff36ec4/" rel="bookmark">
			cfa一级考生复习经验分享系列（十五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		备考背景：
本科211石油理科背景；无金融方面专业知识及工作经验；在职期间备考；有效备考时间2个月；12月一级考试10A。
复习进度及教材选择 首先说明，关于教材的经验分享针对非金融背景考生。
第一阶段：7-9月
浪费时间，经验教训切记！刚报名完考试的时候，朋友帮我买了kaplan notes，附赠了notes的官方中文讲解视频，我在7月份起就开始陆陆续续看讲解视频，但是发现一个问题：note的讲解是完全对照notes课本的，但是针对非金融/经济/财务专业背景的考生，特别是对我本人而言，经济学、财务报表分析、股权部分就很难理解，听不太懂，所以学习的积极性被打压的比较厉害，恍恍惚惚到了9月份，虽然全部的notes课程都已经听完了，但是有效吸收的内容可能10%都不到，因为不理解的内容是根本记不住的。
第二阶段：9-10月
这个时候我开始着急了，也怪自己前面复习只盯着notes，没有去找其他的复习资料，从9月中下旬开始听JC的基础班课程，我个人感受是JC的老师讲课非常明白，没有基础也能听得懂，并且比较针对考点，抓知识点的时候更有针对性。因为时间非常紧迫，我又是在职工作的，所以以1.6倍速听，并结合JC的PPT讲义做笔记，到10月底就从头到尾全部听完一遍了。（如果有4个月备考时间的话，尽量看2遍，我没有时间看强化班课程，如果时间有多的考生也可以再看一遍强化班课程。）
第三阶段：11月
开始刷原版书课后题和JC的百题，各刷了两遍，还多出一个礼拜我把kaplan官网上附送的QBANK全部刷完了。
原版书课后题☆☆☆☆☆：每看完一个topic就做课后题，我因为开始看JC的课程只有2个月时间了，所以没有第一时间做课后题，这样对巩固知识点其实并不太有效，最好办法是学完一个topic就做对应的课后题，最后一个月刷题的时候再做一遍。
JC百题☆☆☆☆：题目基本都是从历年经典的mock题中挑选出来的，和最后的真题题型也比较像。
QBANK题库☆：题型和考点都非常刁钻且不常见，不建议做，但是因为题巨多，对我提升做题速度很有帮助。
第四阶段：12月
第一个礼拜我买了PZ千人计划，40多个小时的考点串讲，非常有用，把所有的知识点都串起来再强化记忆，这个时候就已经有融会贯通的感觉了。剩余时间我刷了2016-2019年6月的mock题，刷了一遍，正确率已经能保证在85-90%，120道题平均1个半小时可以完成。
总结：
我个人建议像我这样的非本专业考试不要一上来复习就看note，非常打击自信心和积极性，备考选用以下材料即可：JC课程+原版书课后题+JC百题+近3年mock题+PZ千人计划+ethic handbook。在职考生推荐复习时间4个月，比较充足，2个月时间复习太过紧张强度很大。
10科复习顺序：
简单：Quantity – portfolio - corporate finance
最难：financial reporting – economics
较难：equity- fix income – alternative &amp; derivative
最后：ethic 重点说一下ethic，一定要放在最后复习，我最早看note的时候先复习ethic，但是缺乏对金融产品和行为的理解，案例基本上看不懂，复习效率很低，但是当所有其他科目全部学完以后，再回头看ethic，就自然能看明白案例。Ethic复习不推荐看课程视频，直接听喜马拉雅APP何璇老师的道德课程音频，我是每天上下班路上听，1.5倍速，听了2遍，何璇老师对案例的讲解非常详细，对加深案例理解非常有帮助；同时，配合ethic handbook把所有的案例都阅读了一遍，加深理解，加快阅读速度。能完成上述学习，ethic通过一般是没有问题的。
考后心得：
1.关于刷题：
刷题非常重要，一级题目非常多，如果速度跟不上，会影响考试进度和考试心理。我最后一个月刚开始刷题的时候，由于知识点记得不牢固，做题非常慢，勉勉强强1分半能做一道题，自己预计这个速度在考场里非常有可能完不成试卷，所以我后面刷题之前，每天都会抽1个小时来复习自己的PPT笔记，滚动记忆知识点，在刷题的时候再次强化，慢慢做题速度就提升了，过完一个月刷mock题的时候，我已经能在1个半小时内完成120道题目了，最后在考试的时候也是正常发挥，上下场都多出了1个半小时。
刷题的目的是，最后做题的时候，看到这个题目能知道考察什么知识点，用什么公式，其他几个选项为什么错。所以我在刷题的过程中，错题一定是标注出来的，单独整理成错题集，另外把错题中不正确的剩下两个选项里包含的知识点也全部整理出来，反复看，这样刷题才有用。
2.关于知识点：
CFA官方推荐的复习时间应该是在200H-300H，临时抱佛脚可能会让你通过考试，但是不会让你保准通过考试。所以每一个知识点都要记得很清楚，相近概念能进行区分，特别是equity\fix income\alternative，我在考场里做完真题的感觉就是知识点的考察比课后题以及Mock题要更全面更仔细，如果相关知识点有一点点没记清楚，或者记混了，就答不对，所以复习的时候，我非常推荐在最后一个月刷题的时候，同步复习听课的笔记，把知识点滚动记忆在脑子里，一个月时间的短暂强化记忆应付考试是非常有用的。
3.关于心态：
我刚开始听note课程的时候也听不太懂，最后到了9月中下旬脑子还是一片空白，当时心态非常不好，很急躁。但后面还是能稳定下来，破釜沉舟投入学习，我从开始看JC的课程起，每天下班到家吃完饭从晚上7点一直学到11点半，11月起每天学到12点，十一假期和双休日是全天学习从没断过，虽然说2个月时间挺短的，但是一直坚持下来，我所有既定的学习目标都全部完成了，课听完，题刷完，知识点全部巩固好，最后上考场的时候也一点不慌，心态好不好其实说穿了就是自己考试准备的好不好，希望也给非金融专业的考生们一点信心，我认为CFA考试是一个完全不会辜负你的考试，大家今年6月考试加油！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6784dcf34b860722dd7ed1165cbfd025/" rel="bookmark">
			2023前端面试题合集（附答案）持续更新中...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023前端面试合集 js基础类1.什么是原型链及原型链存在的意义2.什么是作用域？3.什么是闭包？4.浏览器的渲染过程5.数据类型简介：6.深浅拷贝7.css水平居中的几种方法8.你知道数组有哪些实用高阶函数吗?9.call、apply、bind的区别 Vue类10.vue2和vue3的区别11.route和router的区别12.vue路由两种模式的区别13.keep-alive的生命周期14.mvvm的优势：15.虚拟DOM的作用16.vue如何实现性能优化17.路由的守卫18.Vue 组件中 data 为什么必须是函数？19.ES6的新特性有哪些？20.模块化开发的好处：21.JSON.stringify深拷贝的缺点22.防抖和节流,有什么区别？23.JS中promise对象的作用与使用24.async-await语法25.宏任务和微任务26.v-model和sync修饰符有什么区别27.typescript和javascript区别28.ts中type和interface的区别29.JS的原型与原型链30.什么是虚拟DOM31. vuex Mutations为什么必须是同步32.js事件循环 js基础类 1.什么是原型链及原型链存在的意义 (1).什么是原型链
答:原型链就是每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系就被称为原型链。
简单理解：原型链就是在当前对象中找不到定义的话，会在当前对象的原型对象上继续查找，直至undefined。
(2).原型和原型链存在的意义是什么？
答:实例对象可以共享构造函数原型属性和方法，节省内存。构造函数原型上的属性和方法越多，节省内存越大。
2.什么是作用域？ 作用域分为：1.全局作用域,2. 函数作用域, 3.块级作用域
答:作用域是在运行时代码中的某些特定部分变量，函数和对象的可访问性，作用域决定了代码区块中变量和其他资源的可见性。
3.什么是闭包？ 能够访问其他函数内部变量的函数，被称为闭包。
那种场景会用到，一些事件函数的封装.
闭包本身会带来常驻内存，引用后不会及时销毁.
4.浏览器的渲染过程 当我们在浏览器里输入一个 URL 后，最终会呈现一个完整的网页。会经历以下几个步骤：
1、HTML 的加载
页面上输入 URL 后，会先拿到 HTML 文件。HTML是一个页面的基础，所以会在最开始的时候下载它，下载完毕后就开始对它进行解析
2、其他静态资源的下载
HTML 在解析的过程中，如果发现 HTML 文本里面有一些外部的资源链接，比如 CSS、JS 和图片等，会立即启用别的线程下载这些静态资源。在 head 中遇到 JS 文件时，HTML 的解析会停 下来，等 JS 文件下载结束并且执行完，HTML 的解析工作再接着来，防止 JS 修改已经完成的解析结果
由上得知，JS 文件放在 head 中属于同步加载，会阻塞 DOM 树的构建，进而影响页面的加载。当 JS 文件较多时，页面白屏的时间也会变长
5.数据类型简介： js常用的基本数据类型包括undefined - - (未定义)、null- - (空的)、number - - (数字)、boolean- - (布尔值)、string- - (字符串)、Symbol - - (符号)；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6784dcf34b860722dd7ed1165cbfd025/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca155e24b5076350b3b364d862f77c30/" rel="bookmark">
			机器学习中异常值的处理方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
3Sigma、Z-Score、box plot、Grubbs假设检验四种分布异常值检验方法可以帮助在数据中识别异常值，而在机器学习中，异常值的检测对模型性能和结果的准确性具有重要影响。
3 Sigma法： 原理：通过计算数据的均值和标准差，然后确定在正态分布中距离均值3个标准差之外的数据点，将其视为异常值。
对机器学习的作用：可以在数据预处理阶段使用，帮助剔除明显偏离正常范围的数据点，提高模型的鲁棒性。
Z-score法： 原理：类似于3 Sigma法，通过计算数据点与均值的偏差，以标准差为单位表示。超过阈值的数据点被认为是异常值。
对机器学习的作用：用于标准化数据，帮助模型更好地处理不同尺度的特征，同时检测和处理异常值。
Boxplot（箱线图）： 原理：利用数据的四分位数范围和箱线图的上下边缘来识别异常值。数据点落在箱线图之外的被认为是异常值。
对机器学习的作用：可以用于可视化异常值的分布情况，帮助数据分析和清理。在模型训练前，可以基于箱线图的结果选择是否去除异常值。
Grubbs假设检验： 原理：基于假设检验，Grubbs检验用于检测样本中是否存在显著的异常值，通过计算统计值和比较与临界值的关系。
对机器学习的作用：提供了一种统计学上的检验手段，可以更严格地判断数据中的异常值。在需要较高精度的应用中，可以考虑使用Grubbs检验来识别异常值。
在机器学习中，这些异常值检测方法有助于：
提高模型的鲁棒性，减少异常值对模型的负面影响。
改善数据质量，使得模型更加可靠。
在数据预处理阶段，更好地理解数据的分布特征，选择合适的数据清理策略。
在模型评估和解释结果时，排除异常值对评估结果的干扰，提高结果的可解释性。
代码实现
from ucimlrepo import fetch_ucirepo # fetch dataset wine = fetch_ucirepo(id=109) # data (as pandas dataframes) X = wine.data.features y = wine.data.targets # metadata print(wine.metadata) # variable information print(wine.variables) 访问UCI机器学习数据集为实验进行数据支撑。这些数据是对意大利同一地区种植的葡萄酒进行化学分析的结果，但来自三个不同的品种。该分析确定了三种葡萄酒中每一种中发现的13种成分的数量。对其中连续型数据进行异常值检验。
Sigma法
import pandas as pd # 定义函数 detect_outliers，接受两个参数：DataFrame 和需要检查的列名 def detect_outliers(df, column_names): # 初始化一个空的 Index，用于存储异常值的索引 outlier_indices = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca155e24b5076350b3b364d862f77c30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccf402d60bdf8c758a43c99c46e616f7/" rel="bookmark">
			机器学习中字符特征的处理方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在机器学习中，处理字符变量的方式主要有以下几种：
独热编码（One-Hot Encoding）：将字符变量转换为二进制向量，向量的长度为字符变量的取值数量。每个取值对应向量中的一个元素，该元素值为1，其余元素值为0。标签编码（Label Encoding）：将字符变量转换为整数，整数取值从1开始，按字符变量的取值顺序递增。这种方法适用于机器学习算法不需要考虑类别顺序的情况。序号编码（Ordinal Encoding）：将字符变量转换为整数，整数取值从0开始，按字符变量的取值顺序递增。与标签编码不同，序号编码保留了类别之间的顺序关系。哈希编码（Hash Encoding）：将字符变量通过哈希函数转换为整数。哈希函数可以将任意长度的输入映射到固定长度的输出，因此可以处理取值数量不固定的字符变量。 在R语言中，可以使用以下包进行字符变量处理：
dummy包：用于进行哑变量处理，可以自动检查输入数据集对象中的字符型/因子型变量，并全量输出字符型/因子型变量的哑变量编码结果。model.matrix函数：R语言内置包stat中的model.matrix函数，可以处理分类变量的哑变量处理过程。caret包中的dummyVars函数：可以用于创建哑变量，可以选择保留比较基准类之外的所有哑变量。 在Stata中，可以使用encode命令将字符型变量转换为数值型变量，并添加值标签。此外，还可以使用sencode命令将字符型变量按字母顺序或其他非字母顺序编码为数值型变量。
哑变量和标签编码都是将分类变量转换为数值变量，以便在机器学习模型中使用。下面分别举例说明：
哑变量（One-Hot Encoding） 假设有一个水果数据集，包含以下字段：ID（整型）、Fruit（字符型，取值包括：苹果、香蕉、橙子）。
将Fruit字段转换为哑变量后的数据集如下：
IDFruit_苹果Fruit_香蕉Fruit_橙子110020103001 应用场景：哑变量适用于分类变量有明确的先后顺序或类别之间没有数量关系的场景。例如，在研究水果口感时，不同种类的水果可以认为是互斥的，因此可以使用哑变量来表示水果种类。
对模型准确度的影响：使用哑变量可以提高模型的准确度，因为在模型中可以识别出不同种类的水果之间的差异。但如果分类变量的类别过多，可能会导致模型复杂度过高，从而影响模型的泛化能力。
标签编码（Label Encoding） 将上述水果数据集中的Fruit字段进行标签编码后的数据集如下：
IDFruit112233 应用场景：标签编码适用于分类变量没有明确的先后顺序或类别之间没有数量关系的场景。例如，在研究用户对不同水果的偏好时，可以使用标签编码来表示水果种类。
对模型准确度的影响：标签编码与哑变量类似，都可以提高模型的准确度。但与哑变量相比，标签编码更简洁，且不需要额外的存储空间。但如果分类变量的类别过多，可能会导致模型复杂度过高，从而影响模型的泛化能力。
总体来说，哑变量和标签编码都可以提高模型的准确度，具体选择哪种方法取决于分类变量是否有明确的先后顺序或类别之间是否有数量关系。在没有特殊要求的情况下，可以选择标签编码，因为其更简洁且不需要额外的存储空间。
civilpy：Python数据分析及可视化实例目录929 赞同 · 36 评论文章​编辑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ecb7b705ab3b5f6f8e99e918fdf9c47/" rel="bookmark">
			ArcGIS Pro中Conda环境的Scripts文件解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scripts中包含的文件如下
1. propy.bat 用于在 ArcGIS Pro 外部运行 Python 脚本（扩展名为 .py 的文件）。使用的conda环境是与ArcGIS pro环境同步。propy.bat原理是代替各自python环境下的python.exe，主要区别是propy.bat使用的是与Pro同的环境。
执行的步骤为下： 激活 ArcGIS Pro conda 环境启动 Python运行指定脚本退出 Python 和环境 2. proenv.bat 启动 ArcGIS Pro Python 3 conda 环境/激活 ArcGIS Pro 环境并打开命令提示符窗口
3.proswap.bat 激活conda环境，也就是将当前的conda环境更换为新的conda环境。类似于原始conda命名active的功能。
示例：在本文2.小节中，我们知道当前conda环境为condatest1，我们使用proswap.bat文件将conda环境更换为arcgispro-py3，结果如下
4. 待补充。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cd876cd4b062672ff7870ed3d81c05c/" rel="bookmark">
			PyTorch实战：基于Seq2seq模型处理机器翻译任务(模型预测)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言数据预处理加载字典对象`en2id`和`zh2id`文本分词 加载训练好的Seq2Seq模型模型预测完整代码结束语 引言 随着全球化的深入，翻译需求日益增长。传统的人工翻译方式虽然质量高，但效率低，成本高。机器翻译的出现，为解决这一问题提供了可能。英译中机器翻译任务是机器翻译领域的一个重要分支，旨在将英文文本自动翻译成中文。本博客以《PyTorch自然语言处理入门与实战》第九章的Seq2seq模型处理英译中翻译任务作为基础，附上模型预测模块。
模型的训练及验证模块的详细解析见PyTorch实战：基于Seq2seq模型处理机器翻译任务(模型训练及验证)
数据预处理 加载字典对象en2id和zh2id 在预测阶段中，需要加载模型训练及验证阶段保存的字典对象en2id和zh2id。
代码如下：
import pickle with open("en2id.pkl", 'rb') as f: en2id = pickle.load(f) with open("zh2id.pkl", 'rb') as f: zh2id = pickle.load(f) 文本分词 在对输入文本进行预测时，需要先将文本进行分词操作。参考代码如下：
def extract_words(sentence): """ 从给定的英文句子中提取单词，并去除单词后的标点符号。 Args: sentence (str): 要提取单词的英文句子。 Returns: List[str]: 提取并处理后的单词列表。 """ en_words = [] for w in sentence.split(' '): # 将英文句子按空格分词 w = w.replace('.', '').replace(',', '') # 去除跟单词连着的标点符号 w = w.lower() # 统一单词大小写 if w: en_words.append(w) return en_words # 测试函数 sentence = 'I am Dave Gallo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cd876cd4b062672ff7870ed3d81c05c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04217b38c9fd76cd07d3f4382f309bf4/" rel="bookmark">
			云服务器搭建Typecho个人博客网站，保姆级建站教程，网站搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Linux和宝塔面板搭建Typecho博客网站的教程，网站搭建教程，超详细的纯小白教程。还有模板/主题更换，插件安装的教程。
本文使用的博客程序是Typecho，你也可以换用其他，比如WordPress、Z-Blog、emlog等等，搭建的流畅都差不多的，参照本教程然后自己再摸索一下就会了。
WordPress博客网站搭建教程：https://blog.zeruns.tech/archives/737.html
站长交流群：767557452
什么是个人博客 个人博客是一种在互联网上发布自己的文章、图片、视频等内容的平台，通常以文字为主要形式，但也可以包含其他媒体。
个人博客的用途非常广泛。它可以用来记录博主的日常生活、分享自己的知识和经验、展示自己的作品和技能，以及交流自己的观点和看法。通过个人博客，博主可以与读者建立联系，分享自己的见解和体验，同时也可以从读者那里获得反馈和建议。
博客最初的名称是Weblog，由web和log两个单词组成，按字面意思就为网络日记，后来喜欢新名词的人把这个词的发音故意改了一下，读成we blog，由此，blog这个词被创造出来。中文意思即网志或网络日志，不过，在中国大陆有人往往也将Blog本身和blogger（即博客作者）均音译为“博客”。
Typecho简介 Typecho是一款轻量级的开源博客程序，由type和echo两个词合成而来，这个名称源自开发团队的头脑风暴。其中，“Type”具有打字的意思，象征着博客是一个通过打字在网络上表达自己的平台；“Echo”则意味着回声、反馈、共鸣，同时它也是PHP中最常见、最重要的函数之一。
Typecho基于PHP开发，可以运行在各种平台上，同时支持多种数据库，如Mysql、PostgreSQL、SQLite等。此外，Typecho在GPL version 2许可证下发行，是一款内核强健、扩展方便、体验友好且运行流畅的博客程序，能帮助用户搭建独一无二个人网络日志发布平台，享受创作的快乐。
主要功能
支持多种数据库（MySQL, SQLite, PostgreSQL）支持Markdown语法支持插件支持主题支持自定义字段支持自定义页面 要求
PHP 7.2.0或更高版本数据库（MySQL, SQLite, PostgreSQL） MySQL 5.5.3或更高版本SQLite 3.7.11或更高版本PostgreSQL 9.1或更高版本 Typecho开源链接：https://github.com/typecho/typecho
Typecho文档：https://docs.typecho.org/doku.php
搭建流程概述 注册域名域名备案（如果不使用内地服务器可以忽略）购买云服务器安装宝塔面板创建网站和上传网站源码配置网站 域名注册 什么是域名？
域名可以通俗地理解为互联网上的“门牌号码”或“地址”。每个网站在互联网上都有一个唯一的地址，这个地址就是域名。比如，人们常常访问的“baidu.com”，“taobao.com”等都是域名。它们由一串字符组成，通常包括字母、数字和连接符“-”，并由“.”分隔成几部分。域名的作用是让人们能够更容易地访问和记住网站，而不需要记住复杂的IP地址。同时，域名也具有一定的商业价值，可以作为企业或个人在互联网上的标识和品牌形象。
注册域名
由于目前雨云还没上线域名注册服务（已经在做了），所以还是建议先去腾讯云或阿里云等平台注册域名，当然你也可以使用雨云的免费二级域名。
选择域名要选择可以备案的域名，可备案域名后缀列表：http://www.xinnet.com/service/cjwt/idc/guanli/1589.html
然后到域名控制台进行实名认证就行。如果你用的内地服务器那还需要进行域名备案。
备案的流程就不细说，自己去了解一下就行。
准备 首先需要一台云服务器，要有公网IP的，推荐雨云的：
雨云优惠注册地址：https://www.rainyun.com/zeruns_?s=csdn
优惠码：zeruns
使用优惠码注册后绑定微信可获得5折优惠券
其他服务器推荐：https://blog.zeruns.tech/archives/383.html
注册完账号后进到雨云控制台，云服务器入口可以在后台的 总览 和 云产品 部分找到：
点击购买云服务器，接着选择服务器区域，国内用户建议选择内地机房，因为延迟低网络稳定，比如宿迁和十堰，其中推荐十堰，因为IP便宜，如果预算充足选择宿迁更好（防御高，BGP线路）。但如果你没有备案域名那建议选择香港或美国的服务器。
我域名已经备案了，所以可以选择内地的服务器，我这里选了湖北十堰的。
配置选择2核2G一般够用了，如果你网站用户多就选高点的配置，也可以后期升级配置。
系统选择Debian11，预安装APP选择 [服务器运维面板] 宝塔面板 最新版 ，你也可以不选预安装APP，后面教程有教怎么安装宝塔，选了预安装就会自动帮你装好，然后通过雨云控制台显示的面板地址和账号密码直接登陆就行。
都选好后就可以点击立即购买了，也可以选择1元试用1天。
购买后即可在我的云服务器这里看到你买的云服务器，点击管理。
接着就可以看到云服务器的信息了，在这里重装/切换系统，可以升级配置。
等待服务器创建完成以及预安装APP安装完成。
安装宝塔面板 首先需要通过SSH客户端连接服务器
下载安装并打开ssh客户端软件，ssh客户端软件推荐putty或mobaxterm，还有用win自带的终端或CMD也行。
如果用mobaxterm，在SSH客户端中输入你的服务器的IP地址（雨云控制台获取），还有SSH端口（一般默认是22），然后点击好的或者打开。
然后输入账号并按回车，账号一般默认为root，接着输入密码并按回车确定，输入密码时不会显示出来。
温馨提示：在SSH终端中按住鼠标左键选择文字，然后松开鼠标，再在空白处单击一下，这样就把选中的文字复制了；在SSH终端单击右键即为粘贴。
我这里用windows的终端
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04217b38c9fd76cd07d3f4382f309bf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa547b866acb99db93b7fcd91546a548/" rel="bookmark">
			android studio导入module
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Android Studio中导入一个Module（模块），可以按照以下步骤进行操作：
打开Android Studio，并打开你的项目。在菜单栏中，点击 "File"（文件）-&gt; "New"（新建）-&gt; "Import Module"（导入模块）。在弹出的对话框中，选择要导入的模块的根目录。通常情况下，模块的根目录是包含可用于构建模块的build.gradle文件的文件夹。点击 "Finish"（完成）按钮。 Android Studio将自动导入模块，并将其添加到你的项目中。如果模块中有build.gradle文件，Android Studio会自动将其与主项目的build.gradle文件进行关联。
请注意，导入模块时，确保模块目录不与已有模块或项目目录重复，以避免冲突。
成功导入模块后，你需要在主项目的settings.gradle文件中声明该模块。在settings.gradle文件中，你可以看到类似以下代码的内容：
include ':app' 如果你的模块名为"myModule"，你需要将其添加到settings.gradle文件中，如下所示：
include ':app', ':myModule' 或者
include ':app' include ':myModule' 保存文件后，Android Studio会自动同步项目并将导入的模块包含在构建过程中。
注意： 如果导入的module项目中的app.gradle有applicationId "com.xxx.xxx"需要注释掉，
同时将apply plugin: 'com.android.application'改为apply plugin: 'com.android.library'。
要使用导入的module包中的组件功能，需要在主项目中的build.gradle文件中添加：
dependencies { ... implementation project(':myModule')//导入的module名称 ... } 如果不起效果，重启Android Studio后，你将能够在项目中看到导入的模块，并可以在主项目中使用该模块的功能和资源。
运行时如果有其他错误，请根据错误日志修改配置代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbd910d9fb39702f33cfab5de88fa7f1/" rel="bookmark">
			std::optional和std::variant学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		std::optional C++17引入的一种模板类，主要用来表示一个可以为空的变量。
例如，对于二分查找，传统的方式在找不到时通常返回一个特殊值标记，如返回-1表示找不到item。
int binary_search(const std::vector&lt;int&gt; &amp;list, int item) { size_t low{0}; size_t high{list.size() - 1}; while (low &lt;= high) { auto mid = (low + high); auto guess = list[mid]; if (guess == item) { return mid; } else if (guess &gt; item) { high = mid - 1; } else { low = mid + 1; } } return -1; } 上述方式可能会存在一些问题，因为调用接口的人可能并不会检查函数返回值而直接使用结果，此外不同程序员习惯不同，可能也会使用不同类型的特殊值，从而提高使用成本。
使用optional可以方便得处理上述情况，只需将函数接口稍加修改即可。
std::optional&lt;int&gt; binary_search(const std::vector&lt;int&gt; &amp;list, int item) { size_t low{0}; size_t high{list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbd910d9fb39702f33cfab5de88fa7f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5ea52a90ea371320ce118b86c99f85e/" rel="bookmark">
			网络安全基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是网络安全
（1）网络安全
网络安全指网络系统中的硬件、软件以及系统中的数据受到保护，不因偶然或恶意的原因而遭到破坏、更改、泄露，系统连续可靠正常地运行，网络服务不中断。
网络安全包括：网络设备安全、网络软件安全和网络信息安全。
凡是涉及到网络上信息保密性、完整性、可用性、可认证性、可控性和可审查性的相关理论和技术都是网络安全研究的范畴。那么这“6个特性”是什么意思呢？
/ / 保密性： 确保信息不被泄露或呈现给非授权的人。
/ /完整性： 信息在传输和存储的过程中不丢失、不被修改和破坏。
/ /可用性： 确保合法用户不会无缘故地被拒绝访问信息和资源。
/ /可认证性： 包括对等实体认证和数据源点认证两个方面。
/ / 可控性： 对信息的内容及传播具有可控制力。
/ /可审查性： 出安全问题时提供依据和手段。
讲了这么多，我们到底为啥要研究网络安全呢？这就要从对网络安全的需求说起了。
（2）对网络安全的需求
计算机病毒层出不穷、黑客攻势逐年攀升、常用系统存在安全漏洞、各国加强信息战的研究…这一系列原因都需要我们加强网络安全的研究。
从另一个层面讲，网络安全与我们个人、企业甚至国家的利益息息相关，我们应该引起重视。但是要注意，我们不可能做到绝对的安全，只能尽量做到相对安全。
二、网络安全攻击
（1）网络攻击的分类
网路攻击分为两类：被动攻击和主动攻击。
被动攻击：试图获取和利用系统信息，但不会对系统资源造成破坏。被动攻击难检测，但采取安全防护措施可有效阻止。
主动攻击：试图破坏系统资源，影响系统工作。主动攻击易发现，但难以阻止，所以对付主动攻击应该及时发现，并采取响应措施使系统恢复正常。
（2）网络攻击常见形式
常见的网络攻击有口令窃取、欺骗攻击、缺陷和后门攻击、认证失效、协议缺陷、信息泄露、指数攻击（病毒和蠕虫）和拒绝服务攻击等。
三、安全服务、机制、策略&amp;安全模型
（1）X.800介绍
X.800 建议（recommendation X.800），是CCITT关于开放系统互连安全体系结构的建议，它为开放系统互连（OSI）的安全通信提供一种概念性和功能性的框架，以及在OSI环境下解决网路安全问题的一致性途径。
安全服务通过安全机制实现安全策略。
（2）安全服务
安全服务是一种由系统提供的对资源进行特殊保护的进程或通信服务。
X.800定义了5类安全服务：
（3）安全机制
X.800定义了以下安全机制：
（4）安全服务与安全机制的关系
注：Y表示该机制适合提供该安全服务，-表示不适合。
（5）在OSI层中安全服务的配置情况
注：Y表示提供该安全服务，-表示不提供。
（6）安全策略
安全策略指在某个安全域内，施加给所有与安全相关活动的一套规则。
安全域指某个组织机构的一系列处理进程和通信资源。
（7）安全模型
下面展示的是两种常见的安全模型：
从靠劳力赚钱转变成靠脑力赚钱，想入门网络安全的小白肯定想知道如何学好？ 👉[[[CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源》免费分享]]]（安全链接，放心点击）
对于0基础小白入门：
如果你是零基础小白，想快速入门网络安全是可以考虑的。
一方面是学习时间相对较短，学习内容更全面更集中。
二方面是可以找到适合自己的学习方案
包括： 网络渗透、逆向分析、漏洞攻击、内核安全、移动安全、破解PWN等众多子方向。 带你从零基础系统性的学好网络安全！
👉网安学习成长路线图、网安视频合集👈 网安所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取哈）
观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉精品网安学习书籍👈 当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5ea52a90ea371320ce118b86c99f85e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6baeafc1f811c1ec85ecfc05c290a62/" rel="bookmark">
			GCC内嵌汇编
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你是一个嵌入式开发人员，或者是Linux内核研发人员。可能经常会在内核中遇见如下代码：
/* * CPU interrupt mask handling. */ static inline unsigned long arch_local_irq_save(void) { unsigned long flags; asm volatile( "mrs %0, daif // arch_local_irq_save\n" "msr daifset, #2" : "=r" (flags) : : "memory"); return flags; } 以上代码是ARM架构屏蔽中断的实现。
再比如还会遇到这样的代码：
#define ATOMIC_OP(op, asm_op) \ static inline void atomic_##op(int i, atomic_t *v) \ { \ unsigned long tmp; \ int result; \ \ asm volatile("// atomic_" #op "\n" \ "1: ldxr %w0, %2\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6baeafc1f811c1ec85ecfc05c290a62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dabc805e661136e42ae73e838a586b99/" rel="bookmark">
			LeetCode刷题笔记之字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、反转字符串 1. 344【反转字符串】 **题目：**编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。代码： class Solution { public void reverseString(char[] s) { //交换两个数：a^=b; b^=a; a^=b; //双指针法反转数组 int left = 0; int right = s.length-1; while (left &lt; right){ s[left] ^= s[right]; s[right] ^= s[left]; s[left] ^= s[right]; left++; right--; } } } 2. 541【反转字符串II】 题目： 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 代码： class Solution { public String reverseStr(String s, int k) { char[] charArr = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dabc805e661136e42ae73e838a586b99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dd48b119cc186aef9f7981869f9c656/" rel="bookmark">
			关于Zoom ZTP和AudioCodes Ltd桌面电话缺陷暴露，导致用户遭受窃听的动态情报
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本内容
近期SySS安全研究员发布分析报告显示，Zoom的零接触（ZTP）和AudioCodes Ltd桌面电话配置功能中发现高危漏洞，可以获得对设备的完全远程控制并不受限制的访问可以被武器化，以窃听房间或电话、通过设备并攻击组织网络，甚至构建受感染设备的僵尸网络。
二、相关发声情况
欧盟CERT组织发布推文称Zoom针对某些版本中的漏洞发出严重安全警告。
目前共计公布7个高危漏洞和5个中危漏洞，以敏感信息泄露和拒绝服务攻击漏洞为主。
三、分析研判
根据漏洞分析可知，问题根源在于 Zoom 的 ZTP，它允许 IT 管理员以集中方式配置 VoIP 设备，以便网络攻击组织可以轻松地在需要时监控、排除故障和更新设备。这是通过部署在本地网络内的 Web 服务器来实现的，该服务器为设备提供配置和固件更新。同时发现在从 ZTP 服务检索配置文件的过程中缺乏客户端身份验证机制，从而导致攻击者可能触发从恶意服务器下载恶意固件的情况。总结可知，这些漏洞可用于远程监管任何设备，由于这种攻击具有高度可扩展性，因此会带来巨大的网络危害。
目前我国留学生群体使用Zoom软件进行网络教学数量较为庞大，一旦有用户受到网络安全攻击会造成大量敏感信息泄露，形成极大的危害，给用户和社会带来极大的危害和较高的经济损失。
四、应对策略
1.技术方面：
（1）及时更新操作系统、应用程序和安全软件，以修复已知漏洞并弥补安全漏洞。
（2）采用强大的访问控制措施，限制对敏感数据和系统的访
（3）使用强密码策略，并启用多因素身份验证，以限制未经授权的访问。
（4）部署防火墙和入侵检测系统来监测和阻止恶意网络流量和未经授权的访问尝试。
（5）及时检测异常活动，并采取相应的响应措施。
2.业务方面：
（1）检测人员应对漏洞进行检测确认，并在确认存在漏洞时及时上报给安全团队或管理人员。
（2）当用户受到系统漏洞影响时，及时提供修复补丁以恢复受影响的系统和数据。
3.安全意识培养：
（1）提供网络安全培训和教育，提高员工和用户的安全意识，教授如何识别和应对网络威胁。
（2）培训员工在发现漏洞时采取适当的应对措施。
4.制度方面：
遵守当地法律法规和合规要求，确保网络安全管理符合相关法律法规，并采取合规要求中所述的安全措施。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5726c24a58dec6c9c4b08e5462352ecf/" rel="bookmark">
			Vue 3 中安装并使用 Axios 详细步骤&#43;样例代码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		axios详细步骤 在集成终端打开，使用 npm 或 yarn 安装 Axios：
npm install axios 或
yarn add axios 这将在您的项目中安装 Axios。
在您的 Vue 3 项目中创建一个用于发送 HTTP 请求的模块或文件，比如 http.js。
在 http.js 文件中导入 Axios：
import axios from 'axios'; 创建一个 Axios 实例，并进行必要的配置。您可以根据需要添加全局的默认配置和拦截器等。以下是一个简单的示例：
const http = axios.create({ baseURL: 'http://api.example.com', // 设置基础 URL // 其他配置... }); 这里的 baseURL 是可选的，根据您的需要进行设置。
在需要发送请求的组件中导入 http.js 并使用创建的 Axios 实例发送请求。例如，在组件的方法中使用 http 对象发送 HTTP 请求：
import http from './http'; // ... methods: { fetchData() { http.get('/api/data') .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5726c24a58dec6c9c4b08e5462352ecf/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/12/">«</a>
	<span class="pagination__item pagination__item--current">13/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/14/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>