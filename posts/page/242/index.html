<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/290e6c2a2f54b25e974624527eca7d93/" rel="bookmark">
			终于有人把HDFS架构和读写流程讲明白了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读：HDFS（Hadoop Distributed File System）是一种分布式文件系统，可运行在廉价的硬件上，能够处理超大文件以及提供流式数据操作。HDFS具有易扩展、高度容错、高吞吐量、高可靠性等特征，是处理大型数据集的强有力的工具。
作者：蒋杰 刘煜宏 陈鹏 郑礼雄 陶阳宇 罗韩梅
来源：大数据DT（ID：hzdashuju）
01 HDFS基础
以下是HDFS设计时的目标。
1. 硬件故障
硬件故障对于HDFS来说应该是常态而非例外。HDFS包含数百或数千台服务器（计算机），每台都存储文件系统的一部分数据。事实上，HDFS存在大量组件并且每个组件具有非平凡的故障概率，这意味着某些组件始终不起作用。因此，检测故障并从中快速自动恢复是HDFS的设计目标。
2. 流式数据访问
在HDFS上运行的应用程序不是通常在通用文件系统上运行的通用应用程序，需要对其数据集进行流式访问。HDFS用于批处理而不用于用户的交互式使用，相对于数据访问的低延迟更注重数据访问的高吞吐量。
可移植操作系统接口（Portable Operating System Interface of UNIX, POSIX）标准设置的一些硬性约束对HDFS来说是不需要的，因此HDFS会调整一些POSIX特性来提高数据吞吐率，事实证明是有效的。
3. 超大数据集
在HDFS上运行的应用程序具有大型数据集。HDFS上的一个文件大小一般在吉字节（GB）到太字节（TB）。因此，HDFS需要设计成支持大文件存储，以提供整体较高的数据传输带宽，能在一个集群里扩展到数百上千个节点。一个HDFS实例需要支撑千万计的文件。
4. 简单的一致性模型
HDFS应用需要“一次写入多次读取”访问模型。假设一个文件经过创建、写入和关闭之后就不会再改变了。这一假设简化了数据一致性问题，并可实现高吞吐量的数据访问。MapReduce应用或网络爬虫应用都非常适合这个模型。将来还需要扩充这个模型，以便支持文件的附加写操作。
5. 移动计算而不是移动数据
当应用程序在其操作的数据附近执行时，计算效率更高。当数据集很大时更是如此，这可以最大限度地减少网络拥塞并提高系统的整体吞吐量。HDFS为应用程序提供了接口，使其自身更靠近数据所在的位置。
6. 跨异构硬件和软件平台的可移植性
HDFS的设计考虑到了异构硬件和软件平台间的可移植性，方便了HDFS作为大规模数据应用平台的推广。
从Hadoop这些年的发展来看，HDFS依靠上述特性，成为不断演进变革的大数据体系的坚实基石。
02 HDFS架构
HDFS是一个典型的主/备（Master/Slave）架构的分布式系统，由一个名字节点Namenode(Master) +多个数据节点Datanode(Slave)组成。其中Namenode提供元数据服务，Datanode提供数据流服务，用户通过HDFS客户端与Namenode和Datanode交互访问文件系统。
如图3-1所示HDFS把文件的数据划分为若干个块（Block），每个Block存放在一组Datanode上，Namenode负责维护文件到Block的命名空间映射以及每个Block到Datanode的数据块映射。
▲图3-1 HDFS架构
HDFS客户端对文件系统进行操作时，如创建、打开、重命名等，Namenode响应请求并对命名空间进行变更，再返回相关数据块映射的Datanode，客户端按照流协议完成数据的读写。
HDFS基本概念
HDFS架构比较简单，但涉及概念较多，其中几个重要的概念如下：
1. 块（Block）
Block是HDFS文件系统处理的最小单位，一个文件可以按照Block大小划分为多个Block，不同于Linux文件系统中的数据块，HDFS文件通常是超大文件，因此Block大小一般设置得比较大，默认为128MB。
2. 复制（Replica）
HDFS通过冗余存储来保证数据的完整性，即一个Block会存放在N个Datanode中，HDFS客户端向Namenode申请新Block时，Namenode会根据Block分配策略为该Block分配相应的Datanode replica，这些Datanode组成一个流水线（pipeline），数据依次串行写入，直至Block写入完成。
3. 名字节点（Namenode）
Namenode是HDFS文件系统的管理节点，主要负责维护文件系统的命名空间（Namespace）或文件目录树（Tree）和文件数据块映射（BlockMap），以及对外提供文件服务。
HDFS文件系统遵循POXIS协议标准，与Linux文件系统类似，采用基于Tree的数据结构，以INode作为节点，实现一个目录下多个子目录和文件。INode是一个抽象类，表示File/Directory的层次关系，对于一个文件来说，INodeFile除了包含基本的文件属性信息，也包含对应的Block信息。
数据块映射信息则由BlockMap负责管理，在Datanode的心跳上报中，将向Namenode汇报负责存储的Block列表情况，BlockMap负责维护BlockID到Datanode的映射，以方便文件检索时快速找到Block对应的HDFS位置。
HDFS每一步操作都以FSEditLog的信息记录下来，一旦Namenode发生宕机重启，可以从每一个FSEditLog还原出HDFS操作以恢复整个文件目录树，如果HDFS集群发生过很多变更操作，整个过程将相当漫长。
因此HDFS会定期将Namenode的元数据以FSImage的形式写入文件中，这一操作相当于为HDFS元数据打了一个快照，在恢复时，仅恢复FSImage之后的FSEditLog即可。
由于Namenode在内存中需要存放大量的信息，且恢复过程中集群不可用，HDFS提供HA（主/备Namenode实现故障迁移Failover）以及Federation（多组Namenode提供元数据服务，以挂载表的形式对外提供统一的命名空间）特性以提高稳定性和减少元数据压力。
4. Datanode
Datanode是HDFS文件系统的数据节点，提供基于Block的本地文件读写服务。定期向Namenode发送心跳。Block在本地文件系统中由数据文件及元数据文件组成，前者为数据本身，后者则记录Block长度和校验和（checksum）等信息。扫描或读取数据文件时，HDFS即使运行在廉价的硬件上，也能通过多副本的能力保证数据一致性。
5. FileSystem
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/290e6c2a2f54b25e974624527eca7d93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beea27c45d652da042dace6b47472942/" rel="bookmark">
			《不看后悔系列》建模比赛经验贴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 建模比赛的简要了解
建模目的：
建模流程：
建模需要的能力：
2. 2022东北三省建模比赛A题问题二思路阐述
传统SIR模型
第一步，分析当前模型的基本框架。
第二步，分析题目信息。
第三步，进一步完善模型
第四步，针对问题，设计整体流程
3. 推荐的辅助工具
1. 建模比赛的简要了解 建模目的： 给你一个现象或问题，通过几个问题，反映你分析问题，解决问题的思路和能力。
建模流程： 1.针对问题中的关键字进行搜索，在知网或谷歌学术上搜寻相关论文，了解论文中使用的模型及一系列设定。
2.将题目所给现象的具体内容抽象为一系列的规则，结合上一步寻找到的论文模型进行结合。
3.根据所寻找的论文内容（具体如何使用该模型，引入了哪些变量情况，通过什么方法得出结果，如何证明结果可靠性等等）进行整体流程的设定（针对给定的问题进行模型整体的构建，如何利用模型对问题进行分析等等）
建模需要的能力： 1.代码编译能力，能够构建所需的模型
2.制作图片的能力，利用excel,ppt等等软件制作流程图，结果显示图等等。
3.数据收集能力（如在统计年鉴或相关论文中寻找）
2. 2022东北三省建模比赛A题问题二思路阐述 通过对论文的寻找，舆论传播方面往往使用SIR传染病模型，而针对“信息茧房”往往使用舆论动力学模型。由于SIR模型部分代码更容易寻找，最终选择以SIR模型为基础，将舆论动力学模型部分内容与其进行结合。
传统SIR模型 经典SIR模型是一种传染病模型，此模型能够简单地展现出一种传染病从出现到扩散再到最后逐渐被消灭的过程。该模型假设总节点数保持不变，且每个个体存在于三种可能的人群状态之中，分别为：S，代表易感人群；I，代表感染人群；R，代表恢复人群（假定恢复人群不会再次被感染）。
三类人群状态之间的转换规则如图5-1所示：
SIR模型中除了上述三种人群状态外，还设定了两个常值，分别为感染概率a和恢复概率b。每个时间单位，每个状态为易感人群S的节点若和系统网络中的感染人群I中的节点存在连接，则有a的概率受到感染人群I影响，被感染转换状态，成为感染人群I中的节点。而感染人群I中的节点，在每个单位时间下，则有b的概率，转换自身状态，成为恢复人群R中的节点。
S（t），I（t），R（t）分别代表了当前时间点下，易感人群S总人数，感染人群I总人数及恢复人群R总人数。通过不同人群的占比，我们可以得到当前时刻，感染状态的人群所占总人群的比例，从而了解当前传染病的蔓延程度如何。
第一步，分析当前模型的基本框架。 1.三类身份群体
2.每个节点存在若干连接节点
3.S可以转化为I,I可以转化为R
4.S转化为I和I转化为R的概率固定不变
第二步，分析题目信息。 考虑到第二问所建立的模型还要能够用来分析“尖叫效应”，“回声室效应”，“信息茧房”的形成，因此模型的基本规则设定应该包含以上述三者的抽象规律。
根据分析题目中所给定的“尖叫效应”，“回声室效应”的定义，进行逐一分析，具体过程如下：
1.“网络平台利用大数据。。。分析用户。。信息”，因此模型应体现出“接触信息”这个动作，且个体接触到的信息是受控的，并非完全随机。模型引入连边机制，根据用户所持态度，将其与其他个体进行连边。
2.“大量推送。。。等低俗内容”，因此模型应体现出推送这一举动，且对个体接触的信息类别进行分类并制定不同规则。模型将针对普通信息和低俗信息两类，对用户的初始感染阶段进行分析。
3.“满足人们猎奇心理，还是引发人们的指责批评”，因此个体对待信息会持有正反两个态度。将原先SIR模型中的I,R定义为对某一类信息持消极或积极的两个群体。
1.“在一个相对封闭的媒体环境中，一些意见相似的声音不断重复”，因此SIR模型结合舆论动力学模型中的社区与信任阈值的概念，将I，R群体视为持有不同态度的两个社区，两个社区内部设有相同的较大的信任阈值（更容易受社区内部个体态度的干扰），两个社区之间也设有较小的信任阈值（不容易受到社区外部个体态度的干扰）
2.“走向故步自封甚至偏执极化”，因此模型中设定了态度指数，将个体的态度从0-1进行划分等级，0-0.5为I群体范围，0.5-1为R群体范围。
3.“不知不觉中窄化自己的眼界和理解”，因此模型中设定了改变个体态度指数的机制，每个个体会受到自身所连接的其他个体的态度的影响。
4.“部分商业网站会分析。。用户。。将。。。喜欢的内容提供给用户”，因此模型中设定了基于态度指数相似度为优先的连接机制。
综上所述，此时结合了部分舆论动力学模型理论的SIR模型的基本框架如下：
1.S群体，即尚未接触信息的群体；I群体，即接触信息后持消极态度的群体；R群体，即接触信息后持积极态度的群体。
2.I，R群体中的成员组成了两个持有相悖态度的社区。社区内部信任阈值较高，两个社区之间信任阈值较低。
3.模型中设定了改变个体态度指数的机制，I，R群体中的每个个体都有自己的态度指数，0-0.5为I群体范围，0.5-1为R群体范围。
4.每个个体会受到自身所连接的其他个体的态度的影响，进而存在I,R群体中成员的相互转化。
5.模型中设定了基于态度指数相似度为优先的连接机制，I,R群体中的个体在每个时间单位下会有更大概率与其他持相似态度指数的节点建立连接。
6.在个体接触信息并获得初始态度阶段，应针对低俗类信息和正常信息应制定不同的规则。
第三步，进一步完善模型 通过对题目所给的两个效应的具体规则逻辑化的流程后，已经有了大致的建模思路，但是具体细节仍不完善。
1.设定每个个体态度指数变化的影响因素
考虑到现实网络中，每个人的话语的影响力是不同的，因此根据收集的用户的粉丝量多少引人了节点自身权重的概念。自身权重越大，对其他链接节点的态度指数的影响程度也越高。
2.设定对于低俗信息与普通信息的不同处理方式
定义了影响函数 f(i，j，t)，即在 t 时刻，i 类低俗信息对 j 类别（默认不考虑个体的网络用户身份的影响，统一视为一个类别）的节点最终态度的选择造成的影响函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beea27c45d652da042dace6b47472942/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb1fc204e20c3784219434f6ce95a15c/" rel="bookmark">
			记录一下曲折的apache2修改目录过程（哭泣JPG）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下曲折的apache2修改目录过程（哭泣JPG） 修改目录修改完成 修改目录 输入：vim /etc/apache2/sites-available/000-default.conf 修改：&lt;VirtualHost *:520&gt; (注意这里要改成自己修改后的端口，没修改就算了，我就是因为忘记修改才一直没弄好) # The ServerName directive sets the request scheme, hostname and port that # the server uses to identify itself. This is used when creating # redirection URLs. In the context of virtual hosts, the ServerName # specifies what hostname must appear in the request's Host: header to # match this virtual host. For the default virtual host (this file) this # value is not decisive as it is used as a last resort host regardless.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb1fc204e20c3784219434f6ce95a15c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01c4d71c1a02a35dc062dacfa58eabaf/" rel="bookmark">
			CTF之MISC常用工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件分离 binwalk
foremost
dd
压缩包 伪加密
ARCHPR
图片信息查看 exif
图片隐写 StegSolve
zsteg
steghide
F5-steganography-master
outguess
音频隐写 Audacity
steghide
文件隐写 010 editor
webshell查杀 D盾
二维码扫描 QR Research
宽带路由信息 routerpassview
流量分析 wireshark
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f2d845e97fa71bb08cb642fab9dd745/" rel="bookmark">
			Charset替换字符集String
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 可以用预定义的 StandardCharsets.UTF_8 代码替换其中常量字符集 String 文字（例如，“UTF-8”）的方法和构造函数。
这样可以加快代码的速度，因为Charset为JDK内置，这样字符集查找就变得不必要。 此外，您可能也不需要捕捉 UnsupportedEncodingException。 在这种情况下，catch 块将被自动删除。
示例：
try { byte[] bytes = "str".getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { } 在应用快速修复后：
byte[] bytes = "str".getBytes(StandardCharsets.UTF_8); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a043dbe490be2216193624ce6df8e95d/" rel="bookmark">
			Xception网络结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		活动地址：CSDN21天学习挑战赛
目录 1、从 Inception 到 Xception2、MobileNet vs Xception3、Xception架构4、实验结果5、深度可分离卷积（1）标准卷积（2）深度卷积（3）逐点卷积（4）为什么用深度可分离卷积？ 6、SeparableConv2D() vs DepthwiseConv2D()7、代码实现 1、从 Inception 到 Xception Xception 是 Google 在 2017 年出品的轻量级神经网络，它与 GoogLeNet 中的 Inception 相似，可以认为是 Inception 的一种极端情况。同时，它与 MobileNet 的思想一致，即推动 Depthwise Conv + Pointwise Conv 的使用。另外，在 Xception 中，类似于 ResNet，一些 residual connects 被应用了进来。
最终模型在ImageNet等数据集上都取得了相比Inception v3与Resnet-152更好的结果。当然其模型大小与计算效率相对Inception v3也取得了较大提高。
Figure1是一个典型的 Inception 模块。
我们知道，卷积层的功能是同时学习跨通道相关性和空间相关性，而 Inception 的思想是尝试将这两个相关性的学习分割开来，即：
先用 1x1 conv来着重学习各通道之间的关联，再用 3x3/5x5 conv （两个 3x3 conv 即为 5x5 conv）来学习其不同维度上的单个通道内在空间上的关联（也会学到部分各通道之间的关联）。 考虑一个 Inception 模块的简化版本，只使用一种规格的卷积（例如 3×3 conv），并且不含平均池化。如Figure2所示
而本质上上图2中表示的简化版Inception模块又可被表示为下图3中的形式。可以看出实质上它等价于先使用一个1x1 conv来学习input feature maps之上channels间特征的关联关系，然后再将1x1 conv输出的feature maps进行分割，分别交由下面的若干个3x3 conv来处理其内的空间上元素的关联关系。如下图所示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a043dbe490be2216193624ce6df8e95d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef38f74c11d0c7e060a75faae641625/" rel="bookmark">
			Python学习（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、www.jetbrains.com，python程序开发软件
进去后切换为简体中文。
在开发者工具里找到PyCharm。
点击下载
下载Windows的Commun版本 不用管，直接下一步
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d6758e31fa11b802387296df3b95c93/" rel="bookmark">
			Python学习（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一个程序，向Python世界问好哈哈
计算机并不认识程序，代码可以随便写，但是代码能不能运行就要看有没有解释器了，计算机只能识别二进制代码，我们写的代码电脑是不认识的，所以解释器的作用出来了，解释器就是把我们写的代码转化为计算机可以识别的二进制代码，通过解释器这个纽带，实现人与计算机的交流。 python.exe就是解释器。
运行py文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/995d7b817b2b6ecb62de6058c8916751/" rel="bookmark">
			seata入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式事务seata的使用
一、Seata 是什么
Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。AT模式是阿里首推的模式,阿里云上有商用版本的GTS（Global Transaction Service 全局事务服务）
二、seata的三大角色
在 Seata 的架构中，一共有三个角色：
TC (Transaction Coordinator) - 事务协调者 维护全局和分支事务的状态，驱动全局事务提交或回滚。 TM (Transaction Manager) - 事务管理器 定义全局事务的范围：开始全局事务、提交或回滚全局事务。
RM (Resource Manager) - 资源管理器 管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。 其中，TC 为单独部署的 Server 服务端，TM 和 RM 为嵌入到应用中的 Client 客户端。
1.TM 请求 TC 开启一个全局事务。TC 会生成一个 XID 作为该全局事务的编号。XID，会在微服务的调用链路中传播，保证将多个微服务 的子事务关联在一起。 2.RM 请求 TC 将本地事务注册为全局事务的分支事务，通过全局事务的 XID 进行关联。 3.TM 请求 TC 告诉 XID 对应的全局事务是进行提交还是回滚。 4.TC 驱动 RM 们将 XID 对应的自己的本地事务进行提交还是回滚。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/995d7b817b2b6ecb62de6058c8916751/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92eead7c8e15e65a79e7a71737e91ab1/" rel="bookmark">
			Python3-图片文字识别库ddddocr的使用，验证码的识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 ddddocr简介： ddddocr是一个开源图片识别库，Github地址：
https://github.com/sml2h3/ddddocr
经测试发现，ddddocr在识别验证码类型的图片时，准确率还是很高的。 2 ddddocr的安装： pip install ddddocr
或
pip install ddddocr -i 镜像，例如：
pip install ddddocr -i https://pypi.tuna.tsinghua.edu.cn/simple
常用国内镜像源：
清华：https://pypi.tuna.tsinghua.edu.cn/simple
阿里云：http://mirrors.aliyun.com/pypi/simple/
中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/
华为云：https://mirrors.huaweicloud.com/python/
豆瓣：https://pypi.douban.com/simple/
3 ddddocr的使用： 图片识别举例：
代码： # -*- coding: utf-8 -*- import os import ddddocr # 图片识别函数 def img2text(img_file): ocr = ddddocr.DdddOcr() #法1 # ocr = ddddocr.DdddOcr(det=True) #法2 cPath = os.getcwd() print(cPath) with open(img_file, 'rb') as f: print("file",f) img_bytes = f.read() #获取文字 res = ocr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92eead7c8e15e65a79e7a71737e91ab1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b0c602f69dbcbd31eacaa69a75546d0/" rel="bookmark">
			rsync&#43;inotify实现数据同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本实验环境均为centos 7.2
实验前先关闭防火墙和SELinux
服务端配置如下(192.168.153.129)
1，编辑配置文件
vim /etc/rsyncd.conf 2，编辑密码认证文件
echo xixi:xixi &gt; /etc/rsync.pass chmod 600 /etc/rsync.pass 3，创建用于同步其他客户端的数据存放目录
mkdir /mydata2 4,启动rsyncd服务
systemctl start rsyncd 5,先查看一下 /mydata2目录
客户端配置如下(192.168.153.128)
1,安装自动触发的通知的程序
yum install inotify-tools -y 2，建立password文件
echo xixi &gt; /etc/rsypass chmod 600 /etc/rsypass 3,测试一下是否可以传输文件
rsync -avH --port=873 --progress --delete /mydata/ xixi@192.168.153.129::mydata --password-file=/etc/rsypass 4,在服务端可以看到数据已经同步过来了
5，那么我们就开始编写自动触发脚本,当客户端的数据发生改变,就立刻同步到服务端
#!/bin/bash rsync -avH --port=873 --progress --delete /mydata/ xixi@192.168.153.129::mydata --password-file=/etc/rsypass /usr/bin/inotifywait -mrq --timefmt '%d/%m/%y %H:%M' --format '%T %w%f%e' -e close_write,modify,delete,create,attrib,move /mydata/ | while read file do rsync -avH --port=873 --progress --delete /mydata/ xixi@192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b0c602f69dbcbd31eacaa69a75546d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ced61b01a4fe9f1aafa23a733adf2166/" rel="bookmark">
			判断iOS可执行程序是否为fat格式或bitcode格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		fat格式一般通用于32和64位系统设备，运行时会选择一种架构进行执行，相对来说体积偏大。那么如果在只有可执行文件时，如何判断该文件是否为fat格式呢
判断macho文件是否带fat头 将macho文件拖入010editor，Run Template选择MachO.bt模板，即可判断。
编译不带fat头的macho文件 Info → Deployment Target，设置为11.0以上，不管在Build Settings → Build Active Architecture Only 中设置YES或NO，编译出的macho文件都不带fat头。
编译带fat头的文件 1、需要在Info → Deployment Target，设置为11.0以下（不包括11.0）；
2、在Build Settings → Build Active Architecture Only 中设置NO；
3、两者都设置了，则编译出的是带fat头的macho文件。
Xcode编译bitcode的程序 Build OptionsEnable Bitcode设置为YES，即可以编译成bitcode的程序
判断是否为Bitcode格式 可以使用macOView工具查看程序，含有__LLVM字段的为bitcode格式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3106e0aa51c8a1c603e7f96db1ae25cc/" rel="bookmark">
			c&#43;&#43; 基本计算器的灵活可扩展实现附带UI界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 集成库编译 计算器可视化python UI界面 功能拓展增加新的计算函数增加新的优先级注册操作 计算器c++源码python UI 源码 实现一个可灵活扩充功能的计算器， 面向对象设计
可以灵活添加绝大部分运算操作符
并附带ui 界面方便使用
集成库 编译 g++ -fPIC -shared main.cpp -std=c++17 -o cal.so 计算器可视化 python UI 界面 功能拓展 比如支持 &amp; bit_and 运算 比如 10 &amp; 5
只需要修改如下
增加新的计算函数 class BitAndOperator : public Operator { public: BitAndOperator() : Operator(2) {} private: OPTYPE cal(OPTYPE *buffer) override { return buffer[0] &amp; buffer[1]; } }; 增加新的优先级 int priority(char op) { switch (op) { case '(': return 100000; case '!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3106e0aa51c8a1c603e7f96db1ae25cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab6ffd606d9a60af5356b0f5e1571546/" rel="bookmark">
			Java中如何将Set转List呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转自:
Java中如何将Set转List呢？
下文笔者讲述Java中Set转List的方法分享，如下所示:
实现思路: 方式1： 借助ArrayList进行转换 方式2： 借助List实现类的addAll()方法 例：
Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put("one", "java265.com"); map.put("two", "java265.com-2"); map.put("three", "java265.com-0"); Set&lt;String&gt; set = map.keySet(); //使用ArrayList进行转换 List&lt;String&gt; list1 = new ArrayList&lt;String&gt;(set); for(int i = 0; i &lt; list1.size(); i++){ System.out.println("list1(" + i + ") --&gt; " + list1.get(i)); } //List实现类进行转换 List&lt;String&gt; list2 = new ArrayList&lt;String&gt; (); list2.addAll(set); for(String s : list2){ System.out.println(s); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55dc96e9ea7107726b934a6d5bcc9b42/" rel="bookmark">
			【Argo】通过minikube本地搭建argo环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Minikube
Minikube 是本地版的k8s，可以在这里下载：minikube start
我在MacBook上用homebrew install: brew install minikube # if you have old minikube: you need unlink it first # brew unlink minikube &amp;&amp; minikube link minikube 运行Minikube
下载了minikube之后，运行Minikube如下： % minikube start 😄 Darwin 12.3.1 (arm64) 上的 minikube v1.25.2 ✨ 根据现有的配置文件使用 docker 驱动程序 👍 Starting control plane node minikube in cluster minikube 🚜 Pulling base image ... 🏃 Updating the running docker "minikube" container ... 🐳 正在 Docker 20.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55dc96e9ea7107726b934a6d5bcc9b42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/764a4cd70cb7776ce258f07cc8207ca4/" rel="bookmark">
			本地Argo配置，连接远端Argo Server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装cli并生成token $ brew install argo .... $ argo auth token Bearer xxxxx 配置环境变量 export ARGO_SERVER=xx.xx.xx.xx:2746 export KUBECONFIG=/dev/null export ARGO_NAMESPACE=argo export ARGO_SECURE=false # 我们服务器配置的http，所以不设置为false export ARGO_TOKEN="Bearer xxxxx" # 上面生成的token 测试 $ argo list NAME STATUS AGE DURATION PRIORITY hello-world-2plbj Running 6d 6d 0 配置参考文档
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07838ef88d8e663ef4c814c1656676bd/" rel="bookmark">
			FFT点数、补零对结果的影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		增加点数可提高分辨率（比如之前3Mhz与3.05MHz的频率分辨不出来，增加点数可分辨出来），补零，时域补零相当于频域插值。
clear all; clc; close all; fs=200; % 采样频率 f1=30; f2=65.5; % 两信号频率 N=256; % 信号长度 n=1:N; % 样点索引 t=(n-1)/fs; % 时间刻度 x=cos(2*pi*f1*t)+cos(2*pi*f2*t); % 信号 X1=fft(x); % 按N点进行FFT freq1=(0:N/2)*fs/N; % N点时正频率刻度 X1_abs=abs(X1(1:N/2+1))*2/N; % 信号幅值 L=2*N; % 补零后FFT长度 X2=fft(x,L); % 按L长进行FFT freq2=(0:L/2)*fs/L; % L点时频率刻度 X2_abs=abs(X2(1:L/2+1))*2/N; % 信号幅值 N=512; % 信号长度 n=1:N; % 样点索引 t=(n-1)/fs; % 时间刻度 x=cos(2*pi*f1*t)+cos(2*pi*f2*t); % 信号 X3=fft(x); freq3=(0:N/2)*fs/N; % N点时正频率刻度 X3_abs=abs(X3(1:N/2+1))*2/N; % 信号幅值 % 作图 subplot 311; plot(freq1,X1_abs,'k'); grid; ylim([0 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07838ef88d8e663ef4c814c1656676bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77fce24143ed6b0e1c6eb644ad08ed7d/" rel="bookmark">
			JAVA项目中获取项目路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public static void main(String[] args) { MyUrlDemo muDemo = new MyUrlDemo(); try { muDemo.showURL(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } public void showURL() throws IOException { // 第一种：获取类加载的根路径 D:\git\daotie\daotie\target\classes File f = new File(this.getClass().getResource("/").getPath()); System.out.println(f); // 获取当前类的所在工程路径; 如果不加“/” 获取当前类的加载目录 D:\git\daotie\daotie\target\classes\my File f2 = new File(this.getClass().getResource("").getPath()); System.out.println(f2); // 第二种：获取项目路径 D:\git\daotie\daotie File directory = new File("");// 参数为空 String courseFile = directory.getCanonicalPath(); System.out.println(courseFile); // 第三种： file:/D:/git/daotie/daotie/target/classes/ URL xmlpath = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77fce24143ed6b0e1c6eb644ad08ed7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d717fcd53acf157497a18e0c82f04ef/" rel="bookmark">
			Unity中如何用鼠标（mouse）优雅的把一坨物体拖动（drag）旋转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、网上能见到的拖拽旋转代码 它们都是沿着自身的某两个轴进行rotate，代码通常如下：
float XaxisRotation = Input.GetAxis("Mouse X") * RotationSpeed; //float XaxisRotation = Input.mousePosition.x * RotationSpeed; float YaxisRotation = Input.GetAxis("Mouse Y") * RotationSpeed; //float YaxisRotation = Input.mousePosition.y * RotationSpeed; // 设置旋转的轴心和旋转的量 go.Rotate(Vector3.down, XaxisRotation); go.Rotate(Vector3.right, -YaxisRotation); 结局：
第一次拖拽都是母慈子孝——拖它往左，它就往左转，拖它往右，它就往右转，but（一看见but你就应该想到，要反转了），当物体转到背面后，你会发现：你往左拖，它往右转…简直鸡飞狗跳…
请看下面的效果：
如何修改呢？
二、请先欣赏这种母慈子孝的拖动效果 如何？向左拖向左转，向下拖向下转，始终都不会乱！！！
脚本的参数：
三、实现的思路 旋转前：beginDrag
1、生成旋转的root
2、root对正方向：lookAt摄像机
3、绑定父子关系：要旋转的物体作为root的子物体
旋转中：Drag
1、旋转root，带动子物体旋转
停止旋转：endDrag
1、撤销父子关系
2、销毁root
什么时候拖呢
如上所示，你发现当鼠标悬停到物体上的时候，物体变成红色，此时物体才能拖动
四、代码 using System.Collections.Generic; using UnityEngine; using System.Linq; using System; using static txlib; using UnityEngine.EventSystems; /******************************************* 旋转前：beginDrag 1、生成旋转的root 2、对正方向：正对摄像机 3、绑定父子关系 旋转中：Drag 1、旋转root，带动子物体旋转 停止旋转：endDrag 1、撤销父子关系 2、销毁root *****************************************/ /// &lt;summary&gt; /// 鼠标拖拽物体进行旋转 /// &lt;/summary&gt; public class DragObjectRotate : MonoBehaviour { /// &lt;summary&gt; /// 相机 /// &lt;/summary&gt; public Transform cam; /// &lt;summary&gt; /// 要旋转点的物体 /// &lt;/summary&gt; public Transform objectToRotate; /// &lt;summary&gt; /// 旋转的速度因子 /// &lt;/summary&gt; public float RotationSpeed; /// &lt;summary&gt; /// 旋转物体的root /// &lt;/summary&gt; private Transform rotateRoot; /// &lt;summary&gt; /// 旋转物体的父物体 /// &lt;/summary&gt; private Transform parent; /// &lt;summary&gt; /// 子物体 /// &lt;/summary&gt; public List&lt;GameObject&gt; childrenObjs = new List&lt;GameObject&gt;(); // Start is called before the first frame update void Start() { childrenObjs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d717fcd53acf157497a18e0c82f04ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d08902097d7d26e8b97679e890b879f/" rel="bookmark">
			Execution failed for task ‘:app:kaptDebugKotlin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用room时报的错，gradle里是这样写的：
plugins {	…… id 'kotlin-kapt' } dependencies { …… implementation "androidx.room:room-runtime:2.4.2" kapt "androidx.room:room-compiler:2.4.2" } Execution failed for task ‘:app:kaptDebugKotlin‘.异常
文章说把kapt改成annotationProcesser就可以了，但是还是有问题。
cannot find implementation for XXX. XXX_Impl does not exist
按照流程，先检查了一下注解是否都添加了
@Database：表示数据库.
@Entity：表示数据库中的表。
@DAO：包含用于访问数据库的方法。
果然，少了dao，添加之后没有报错，即不能使用annotationProcesser，因为项目使用的是kotlin语言，遂改成kapt ，成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0ee7be78b4eaac11fbf07e8fb397324/" rel="bookmark">
			C&#43;&#43;语法（三）string字符串的输入、拼接、删除、查找、截取、比较、遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、字符串的输入
// 1、输入不含空格的字符串 string str; cin &gt;&gt; str; // 2、输入包含空格的字符串 string str; // 如果前面有了cin输入，则还需添加如下一句 // getchar(); getline(cin, str); // 3、不停输入字符串，直到遇到回车 string str; // 如果前面有了cin输入回车，则还需添加如下两句句 // cin.clear(); // cin.ignore(); while(cin.peek()!='\n'){ cin &gt;&gt; str; } // 4、不停输入字符串，字符串间以空格分隔，直到遇到回车 string str; while(cin &gt;&gt; str){ cout &lt;&lt; str &lt;&lt; endl; // getchar是用来吸收空格和回车的 if(getchar() == '\n'){ break; } } // 输入 // ni hao ya // 输出 // ni // hao // ya // 2、字符串的拼接（增加）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0ee7be78b4eaac11fbf07e8fb397324/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d3dc9fbb0390688211d59797478878d/" rel="bookmark">
			Real Time Linux简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、 Real Time Linux2、 PREEMPT_RT3、Threaded IRQs 中断线程化4、Xenomai 1、 Real Time Linux 标准的Linux内核中不可中断的系统调用、中断屏蔽等因素，都会导致系统在时间上的不可预测性，对硬实时限制没有保证。目前，针对 real-time Linux 的修改有两种成功的方案。一是直接修改Linux 内核，使其直接具有 real-time 能力；另一是先运行一个 real-time 核心，然后将Linux 内核作为该 real-time 核心的 idle task(空闲任务)来运行。前者称为 PREEMPT-RT kernel，后者称为 dual kernel(如RTLinux、Xenomai等)。
实时操作系统又分为硬实时和软实时： ·硬实时要求在规定的时间内必须完成操作，硬实时系统不允许超时。 ·在软实时里面处理过程超时的后果就没有那么严格。 PREEMPT_RT是Linux内核的一个实时补丁。
Xenomai是一种采用双内核机制的Linux 内核的强实时扩展。优先级高于Linux 内核，它负责处理系统的实时任务。
2、 PREEMPT_RT PREEMPT-RTPatch的核心思想是最小化内核中不可抢占部分的代码，同时将为支持抢占性而必须要修改的代码量最小化。对临界区、中断处理函数、关中断等代码序列进行抢占改进。
PREEMPT_RT补丁的技术细节：
(1) 高分辨率定时器
高分辨率计时器允许精确的定时调度，并消除了计时器对定期调度程序滴答（jiffies） 的依赖性。 (2) 中断线程化,减少ISR处理时的关中断时间
PREEMPT_RT修补程序强制采用线程中断处理程序的机制。因此，所有中断处理程序都在 线程上下文中运行，除非它们用IRQF_NO_THREAD标志标记。这种机制也可以在Linux主 线内核中强制使用，而无需通过内核命令行选项PREEMPT_RT补丁。但是结果行为略有不同。 (3) rt_mutex
主线 Linux 内核中的所有互斥体都被 rt_mutexes 所取代。rt_mutex实现优先级继承 以避免优先级反转。这也适用于睡眠自旋锁和 rwlock。但是，信号量的持有者可以被抢 占，但不参与优先级继承。 在如下的情况下会发生优先级翻转： * 低优先级的任务A获取到一个资源，比如一个锁（L）。 * 中优先级任务B开始执行，抢占了任务A。 * 高优先级任务C尝试获取资源L。因为中优先级的任务B抢占了任务A，（任务A无法 释放锁L）那么高优先级的任务就会阻塞。 优先级翻转是实时系统中必须解决的问题，它可能导致一个高优先级任务被无限期推 迟执行。 PREEMPT_RT中使用优先级继承来解决优先级反转，核心思想是：高优先级任务暂时 将其优先级赠与拥有临界资源(锁)的低优先级任务，从而快速运行加快A对锁的释放。 此处优先级继承是变化的：比如，又有一个优先级更高的任务D也尝试获取锁L，那么 任务C和A的优先级都会暂时提升为任务D的优先级。优先级继承的持续时间是非常短暂的。 因为一旦低优先级任务A释放了锁，它马上就会失去短暂提升的优先级，然后将锁交给任务C。 PREEMPT_RT在一段时间内仅仅允许一个任务读持有读写锁/semaphore(信号量)。允许该任 务递归获取该锁。尽管丧失一些灵活性，却使得优先级继承变得切实可行。 优先级继承使得高优先级任务可以及时地获取锁和semaphore，即便是锁或semaphore 已经被低优先级的任务获取。PREEMPT_RT的优先级继承提供短暂的继承，这是高优先级任务 突然要获取低优先级任务的锁所需要的。compat_semaphore和compat_rw_semaphore可以 用于不需要semaphore优先级继承的事件类的使用场合 (4) RCU
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d3dc9fbb0390688211d59797478878d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c08021ff78dea853627682876300e942/" rel="bookmark">
			ouc2022移动软件开发 实验二：天气查询小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目标 1、掌握服务器域名配置和临时服务器部署；2、掌握 wx.request 接口的用法。
二、实验步骤 1、“和风天气”密钥申请 “和风天气”有着可以提供全球气象数据服务接口的和风天气API，其最新官方网址为和风天气 | 商业气象服务商, 天气预报，灾害预警，台风路径，卫星云图，天气API/SDK/APP, 天气插件, 历史天气, 气象可视化，当我们选择“免费用户”类型，使用邮箱进行注册并激活后可以获取三天之内全球各地区的实时天气，支持的免费接口调用流量基本上可以满足我们这次试验的开发学习要求。密钥申请步骤如下：
我的控制台 --&gt; 应用管理 --&gt; 创建应用 --&gt; 免费用户
填写名称后即可获得密钥，如下图：
2、服务器域名配置 当我们从小程序中读取天气有关的信息时，需要访问“和风天气”的服务器，因此需要对相关域名地址进行服务器配置。所需的域名地址如下：
https://devapi.qweather.com
https://geoapi.qweather.com
进入微信公众平台（微信公众平台）,登陆后进入开发管理 --&gt; 开发设置 --&gt; 服务器域名，点击修改，将上述两个接口添加到“request合法域名”中。结果如下图：
3、项目创建 3.1 类似第一个实验，进行空白项目的创建。
3.2 创建其他文件
单击目录结构左上角的+号创建 images 文件夹，导入图标素材（https://github.com/qwd/Icons/releases/download/v1.1.1/QWeather-Icons-1.1.1.zip），如图：
4、视图设计 4.1 导航栏设计
在 app.json 文件中自定义导航栏标题和背景颜色。更改后的 app.json 文件代码如下：
{ "pages":[ "pages/index/index" ], "window":{ "navigationBarBackgroundColor": "#3883FA", "navigationBarTitleText": "今日天气" }, "style": "v2", "sitemapLocation": "sitemap.json" } 上述代码可以更改所有页面的导航栏标题文本为"今日天气"、背景颜色为蓝色。预览效果如下：
4.2 页面设计
WXML（pages/index/index.wxml）代码如下：
&lt;view class="container"&gt; &lt;picker mode="region" bindchange='regionChange'&gt; &lt;view&gt;{{region}}&lt;/view&gt; &lt;/picker&gt; &lt;text&gt;{{now.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c08021ff78dea853627682876300e942/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b394993a217eeefb8edd2ee896952ff1/" rel="bookmark">
			QComboBox样式-qss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 QComboBox { border: 1px solid gray; border-radius: 3px; padding: 1px 18px 1px 3px; min-width: 6em; } QComboBox::drop-down { subcontrol-origin: padding; subcontrol-position: top right; width: 15px; border-left-width: 1px; border-left-color: darkgray; border-left-style: solid; /* just a single line */ border-top-right-radius: 3px; /* same radius as the QComboBox */ border-bottom-right-radius: 3px; } 下拉箭头的图片
QComboBox::down-arrow { image: url(:/res/work/dateDown.png); } QComboBox QAbstractItemView{ background:rgba(255,255,255,1); border:1px solid rgba(228,228,228,1); border-radius:0px 0px 5px 5px; font-size:14px; outline: 0px; //去虚线 } QComboBox QAbstractItemView::item{ height:36px; color:#666666; padding-left:9px; background-color:#FFFFFF; } QComboBox QAbstractItemView::item:hover{ //悬浮 background-color:#409CE1; color:#ffffff; } QComboBox QAbstractItemView::item:selected{//选中 background-color:#409CE1; color:#ffffff; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ecc6fac18b32281677c3e3b0aa35ea9/" rel="bookmark">
			第 6 章 递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第 6 章 递归 1、递归介绍 1.1、递归应用场景 看个实际应用场景， 迷宫问题(回溯)， 递归(Recursion) 1.2、递归的概念 简单的说: 递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。 1.3、递归调用机制 打印问题 阶乘问题 // 阶乘问题 public static int factorial(int n) { if (n == 1) { return 1; } else { return factorial(n - 1) * n; } } 1.4、递归能解决什么问题 各种数学问题如: 8 皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题(google 编程大赛)各种算法中也会使用到递归， 比如快排， 归并排序， 二分查找， 分治算法等.将用栈解决的问题 --&gt; 递归代码比较简洁 1.5、递归需遵循的规则 执行一个方法时， 就创建一个新的受保护的独立空间(一个线程有自己独立的一个栈空间，每个方法调用对应着一个栈帧)方法的局部变量是独立的， 不会相互影响, 比如 n 变量如果方法中使用的是引用类型变量(比如数组)， 就会共享该引用类型的数据递归必须向退出递归的条件逼近， 否则就是无限递归，出现 StackOverflowError， 死龟了 😃当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。 2、递归-迷宫问题 2.1、代码思路 使用二维数组 map[][] 模拟迷宫约定： 当 map[i][j] 为 0 表示该点没有走过；当为 1 表示墙；2 表示通路可以走 ；3 表示该点已经走过，但是走不通setWay() 方法用于找路，true 表示该路可以走通，false 表示该路走不通在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 一步一步向前试探，如果该点走不通，再回溯每当走到一个点时，将该点置为 2 ，暂时假设该路能走通，至于到底走不走得通，得看后面有没有找到通路 如果后面的路能走通，从最后一个点开始返回，整个 setWay() 递归调用链都返回 true如果后面的路不能走通，那么将当前的点设置为 3 ，表示是死路，走不通，回溯至上一个点，看看其他方向能不能走通 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ecc6fac18b32281677c3e3b0aa35ea9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/877a5efc17b9bb91b1e351b0936f6f9d/" rel="bookmark">
			使用gpio_direction_output()无法设置GPIO原因分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用gpio_direction_output()无法设置GPIO原因分析 在driver中使用gpio_direction_output()设置GPIO3_D7为高电平，但是系统启动之后又被设置为了低电平，问题分析。
查看GPIO电平状态
cat /sys/kernel/debug/gpio 1、首先怀疑是GPIO冲突，可能是多个设备树节点都使用这个GPIO，通过查看log发现并没有GPIO申请冲突的log打印，而且打印gpio_direction_output()这个值的返回值也是设置正确的，所以系统跑的时候应该是运行正常的。
2、初步怀疑是驱动设置为高之后，又被别的地方被拉低，是否为不规范使用导致GPIO导致，所以打算用逻辑分析仪看看是不有我们driver拉高，然后又被拉低。
3、通过逻辑分析仪抓到的波形分析可以看到，我们的driver是有一段时间把这个GPIO拉高的动作的，但是不久之后这个IO后就有一段很长的拉低拉高的波形，这个波形很像数据传输的波形，最后IO口被拉低，然后我们有理由怀疑这个IO口是和控制器冲突了，通过查看这个IO口可以知道GPIO3_D7在RK3399芯片中是I2S0控制器DATA0输出引脚。所以我们需要在设备树中disable这个引脚。
打开\arch\arm64\boot\dts\rockchip\rk3399.dtsi
i2s0 { i2s0_8ch_bus: i2s0-8ch-bus { rockchip,pins = &lt;3 24 RK_FUNC_1 &amp;pcfg_pull_none&gt;, &lt;3 25 RK_FUNC_1 &amp;pcfg_pull_none&gt;, &lt;3 26 RK_FUNC_1 &amp;pcfg_pull_none&gt;, &lt;3 27 RK_FUNC_1 &amp;pcfg_pull_none&gt;, &lt;3 28 RK_FUNC_1 &amp;pcfg_pull_none&gt;, &lt;3 29 RK_FUNC_1 &amp;pcfg_pull_none&gt;, &lt;3 30 RK_FUNC_1 &amp;pcfg_pull_none&gt;; //&lt;3 31 RK_FUNC_1 &amp;pcfg_pull_none&gt;; //泰山项目使用GPIO3_D7作为普通IO，用于ZIGBEE电源使能所以需要注释掉 }; 参考资料 linux 应用层操作GPIO
cat /sys/kernel/debug/gpio
#GPIO3_D7 = 127 = 323 + (4 * 8 - 1) GPIO3就是332 D7就是4*8 其中A = 0, B = 1以此类推D就是4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/877a5efc17b9bb91b1e351b0936f6f9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6ef6da12f28636359ee49e2bf2b72d1/" rel="bookmark">
			移动软件开发实验二——天气查询小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年夏季《移动软件开发》实验报告 一、实验目标 1、掌握服务器域名配置和临时服务器部署；2、掌握wx.request接口的用法
二、实验步骤 1.API密钥申请 2. API确定 先利用picker获取城市，然后得到城市ID之后利用天气接口获取天气即可
3.服务器域名配置 4.页面配置 5.视图设计 三、程序运行结果 API成果获取信息
四、问题总结与体会 ​ 在实验的过程中发了JS文件中不同变量的作用域问题，理解了在函数声明
var that =this 的作用，this在调用wx.request之前是所在的page，由于在接口返回信息中需要使用page对象，而此时的this变成了wx，因此需要保存that
本次实验使得我进一步熟悉了js与html，对于flex弹性布局的理解进一步加深了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b70a32422ca1dbe0f7059f354cee0eb/" rel="bookmark">
			数学建模笔记-第四讲-拟合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 拟合插值和拟合的区别一个小例子最小二乘法Matlab求解最小二乘 拟合优度”线性函数“计算拟合优度代码 Matlab拟合工具箱功能运行拟合函数打印拟合结果生成代码 例题：预测美国人口Matlab随机生成数据拟合随机数例子 论文中的应用课后作业 拟合 插值和拟合的区别 一个小例子 最小二乘法 使用最小二乘法，构建直线使样本点和拟合曲线最接近
arg是参数的意思，argmin是求使括号里值最小的参数值用平方因为方便求导三次方不行，会有负数，出现正负相抵的情况四次方不行，因为太大了，会造成异常值影响大 数学推算：
Matlab求解最小二乘 clear;clc load data1 plot(x,y,'o') % 给x和y轴加上标签 xlabel('x的值') ylabel('y的值') n = size(x,1); k = (n*sum(x.*y)-sum(x)*sum(y))/(n*sum(x.*x)-sum(x)*sum(x)) b = (sum(x.*x)*sum(y)-sum(x)*sum(x.*y))/(n*sum(x.*x)-sum(x)*sum(x)) hold on % 继续在之前的图形上来画图形 grid on % 显示网格线 画y=kx+b
传统的画法：模拟生成x和y的序列，plot(x,y)
这里使用匿名函数
f=@(x) k*x+b; fplot(f,[2.5,7]); legend('样本数据','拟合函数','location','SouthEast') 关于匿名函数使用
% 匿名函数的基本用法。 % handle = @(arglist) anonymous_function % 其中handle为调用匿名函数时使用的名字。 % arglist为匿名函数的输入参数，可以是一个，也可以是多个，用逗号分隔。 % anonymous_function为匿名函数的表达式。 % 举个小例子 % z=@(x,y) x^2+y^2; % z(1,2) % % ans = 5 % fplot函数可用于画出匿名一元函数的图形。 % fplot(f,xinterval) 将匿名函数f在指定区间xinterval绘图。xinterval = [xmin xmax] 表示定义域的范围 拟合优度 评价拟合的好坏
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b70a32422ca1dbe0f7059f354cee0eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56883f2080e44189710d509e6e9dd531/" rel="bookmark">
			闭包 closure
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
闭包是什么
如何产生闭包
产生闭包的条件
闭包的几种常见形式
1. 函数的嵌套之 函数的返回值是函数 (定义)
2. 函数嵌套之 函数的局部变量是函数 (定义)
3. 函数嵌套之 全局变量定义为闭包
4. 函数的参数的方式
5. 循环赋值的方式
6. 迭代器
闭包的作用
1、从外部读取函数内部的变量
2、将创建的变量的值始终保存在内存中
3、封装私有属性和私有方法
闭包面试题
解析
闭包的生命周期
闭包的应用场景
闭包的缺点
缺点
解决办法
补充：内存溢出和内存泄漏
内存溢出
内存泄露
常见的内存泄露:
闭包是什么 《犀牛书》
函数变量保存在函数作用域内部,这种特性成为闭包
《红宝书》
闭包是指有权访问另一个 函数作用域中的变量的函数 （函数没导出）
《你不知道的javascript》
当函数可以记住并访问所在的词法作用域时,就产生了闭包,即使函数是在当前词法作用域之外执行
MDN
闭包可以让你在一个内层函数作用域中访问到其外层函数的作用域
当函数的执行导致函数被定义,并抛出(有些书里会定义未抛出,这个并不强制要求)
function foo(){ var n = 0 } console.log(n) // Uncaught ReferenceError: n is not defined function foo1(){ var m = 0; // m 是一个被foo1()创建的局部变量 function bar1(){// bar1 是内部函数 一个闭包 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56883f2080e44189710d509e6e9dd531/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1620580af921d437f3ed852f2046f5ca/" rel="bookmark">
			mysql存储过程多层游标循环嵌套的写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有遇到一个需求：将有3级主从关联的表数据同步到另外一个有3级主从关联的表中，同步数据的表是第3级子表，而关联关系在第1、2级主表中，由于考虑到到内网数据库可能没法直接访问的限制，所以没有用代码来实现，而是直接用存储过程来实现
最终存储过程的写法如下：
DELIMITER $$ USE `myDb`$$ DROP PROCEDURE IF EXISTS `syncBomSopFromRouteSop`$$ CREATE PROCEDURE `syncBomSopFromRouteSop`(IN tenantId BIGINT(11)) BEGIN #工艺路线ID DECLARE crId BIGINT(11); #生产bomID DECLARE pbrId BIGINT(11); #工序档案ID DECLARE processId VARCHAR(50); #生产bom工序Id DECLARE bomProcessId BIGINT(11); #生产bom数量 DECLARE productionBomNum INT(5); #生产bom工序数量 DECLARE productionBomProcessNum INT(5); DECLARE i INT(4) DEFAULT 1; #DECLARE j INT(4) DEFAULT 1; #定义生产bom游标 DECLARE productionBomCursor CURSOR FOR ( SELECT cr_id,pbr_id FROM jgmes_modeling_production_bom_route WHERE tenant_id=tenantId AND delete_flag=0 AND IFNULL(cr_id,'')&lt;&gt;'' ORDER BY cr_id,pbr_id /*测试1条数据AND pbr_id=86673*/ ); #定义生产bom工序游标 DECLARE bomProcessCursor CURSOR FOR ( SELECT pbp_id bomProcessId,p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1620580af921d437f3ed852f2046f5ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c7057f4d0c14ab0579aba3e17e0f4e2/" rel="bookmark">
			直接选择排序与堆排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、选择排序1、直接选择排序 二、堆排序1、 堆的概念及结构2、向下调整算法3、堆排序的实现 一、选择排序 基本思想:每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完 。
1、直接选择排序 在元素集合array[i]–array[n-1]中选择关键码最大(小)的数据元素若它不是这组元素中的最后一个(第一个)元素，则将它与这组元素中的最后一个（第一个）元素交换在剩余的array[i]–array[n-2]（array[i+1]–array[n-1]）集合中，重复上述步骤，直到集合剩余1个元素。
代码实现:
// 选择排序 void SelectSort(int* a, int n) { for (int i = 0; i &lt; n - 1; i++) { for (int j = n - 1; j&gt;i; j--){ if (a[i] &gt; a[j]) { Swap(&amp;a[i], &amp;a[j]); } } } } 直接选择排序的特性总结：
直接选择排序思考非常好理解，但是效率不是很好。实际中很少使用时间复杂度：O(N^2)空间复杂度：O(1)稳定性：不稳定 二、堆排序 1、 堆的概念及结构 如果有一个关键码的集合K = { ， ， ，…， }，把它的所有元素按完全二叉树的顺序存储方式存储
在一个一维数组中，并满足： &lt;= 且 &lt;= ( &gt;= 且 &gt;= ) i = 0，1，2…，则称为小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c7057f4d0c14ab0579aba3e17e0f4e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dc8e7c8502c596ce9004fbd6f369c30/" rel="bookmark">
			tcpdump抓包，Android抓包不用设置代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用方法 平常我们抓包都是用fidder,charles这些软件进行抓包，但是使用这些软件抓包都需要设置代理，手机还好，但是对于电视，机顶盒等一些Android设备可能设置中没有这些选项怎么进行抓包呢。
此时就需要用到tcpdump来进行抓包。
链接：https://pan.baidu.com/s/1gS-7vLQxACB5B4L-5qt-Tg
提取码：rasv
使用步骤:
1.将tcpdump下载下来
2.adb connect ip[设备ip] //pc与android设备连接
3.adb push tcpdump /data/ //将tcpdum push到data目录 （此步骤需要adb root）
还可以把tcpdump复制进u盘，插到设备上，cp mnt/usb//tcpdump /data/
4.chmod 6755 tcpdump //增加权限
5…/tcpdump -i any -p -s 0 -w /sdcard/capture.pcap //抓取网络包日志
6.exit //退出
7.adb pull /sdcard/capture.pcap //将网络包拉取至本地adb目录中
也可以 cp /sdcard/capture.pcap /mnt/usb// // 复制到u盘
这样就完成了网络包的抓取，之后使用WireShark分析网络包即可
tcpdump简介 tcpdump是一种用来截取网络分组，并输出分组内容的工具。tcpdump抓包工具从筛选条件来分类，主要有三大类。一是针对关键字，譬如主机名（HOST）、网段（NET）、端口（PORT）；二是针对包的方向，譬如源地址（src）、目的地址（dst），且可以支持逻辑运算符号（src and dst、src or dst）。三是针对协议进行抓包，譬如抓取tcp/udp/imcp等协议的数据包。
tcpdump 常用命令参数： -D ：展示可供抓包的端口 -n ：将网络地址以数字形式展示 -nn ：不进行端口名称的转换 -i ：后面跟端口，针对该端口进行抓包 -w ：后面跟文件名，将抓取的数据包保存至某个文件（一般保存为.pcap/.cap文件格式） -v ：展示数据包详细详细 -vv ：展示数据包更详细的信息 -e ：展示数据链路层信息，主要是mac地址 -c ：要抓取的数据包数量 -C ：在将一个原始包写入文件之前，检查文件当前的大小是否超过了参数file_size 中指定的大小。如果超过了指定大小，则关闭当前文件，然后在打开一个新的文件。 -r ：从指定的文件中读取包(这些包一般通过-w生成) -t ：不在每一行中输出时间戳。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d359ae68150ec57c0f457406929ba54/" rel="bookmark">
			Python浮点数数组求和结果不精确问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题
记录一下，最近遇到的带浮点数的数组求和时，结果小数点溢出/有误差/小数点不精确的问题。
场景
a = [100.7, 100.9] print(sum(a)) # 输出：201.60000000000002 原因
Python的浮点数计算是不精确的，因为小数在以二进制形式表示时，计算机进行浮点运算时会产生浮点误差。
解决
方法一：
遇到这种问题，如果直接用内置函数 round() 设置小数点精确度的方式解决
b = round(sum(a), 2) print(b) # 输出：201.6 print(type(b)) # &lt;class 'float'&gt; 虽然这样可以解决这个问题，但是实际上在使用Python计算float类型的数据时还是可能会遇到其他问题。
方法二（推荐）：
使用 decimal.Decimal 对数据类型进行转换后再计算。
from decimal import Decimal # 只能传int或str, 不能传float, 需要对float类型转换为str, 方便点可以都转成str c = [Decimal(str(i)) for i in a] print(c) # [Decimal('100.7'), Decimal('100.9')] print(sum(c)) # Decimal('201.6') print(float(sum(c))) # 201.6 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b60912af1460192e7f74cd1d4bc3a35/" rel="bookmark">
			已经解决：No model name: transformers.modeling_bert
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题参考：No model name: transformers.modeling_bert
在使用transformer库时遇到问题
from transformers.modeling_bert import BertPreTrainedModel, BertModel 代码报错：
from transformers.modeling_bert import BertPreTrainedModel, BertModel ModuleNotFoundError: No module named 'transformers.modeling_bert' 原因：
由于transformers库版本更新之后，modeling_bert所在位置变换了
将代码改为以下，就可解决问题：
from transformers.models.bert.modeling_bert import BertPreTrainedModel, BertModel 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad03af954f6b97ef94905f54b07f2511/" rel="bookmark">
			大疆嵌入式工程师面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天刚刚经历了大疆嵌入式第一轮面试，面试官是个大佬，感觉很不错，但大疆面试问的很深，自己有些答得不是很好，记录一下
一面（8.16号，35min左右） 1.自我介绍
2.你项目中用了多线程与多进程，谈谈你的理解？
3.线程，进程间通信方式？
4.有名管道与匿名管道区别？
5.说一下条件变量怎么实现？
6.信号量机制怎么实现的？该机制可以用于进程间通信吗？信号量机制中PV操作是原子操作吗？
7.nuttx中（项目）原子操作怎么实现？linux中原子操作怎么实现的？讲讲具体流程
8.linux中断流程，谈谈你对中断上下文的理解
9.来谈一下C++中多态
10.纯虚函数与虚函数有哪些区别
11.虚函数是怎么实现的？虚函数表存在哪个地方？
12.怎么访问类中私有变量，友元是单向的还是双向的？友元可以继承吗
13.你怎么理解引用与指针，为什么有了指针还需要引用？
14.C++新特性，你知道哪些？谈谈你对Lambda表达式的理解，谈谈你对智能指针理解，智能指针有什么缺点
15.C++编译过程以及编译后(可执行程序)内存分配，你了解其中bss段吗？
16.可执行程序的后缀是什么？它的内存开始地址是什么？空间范围是多少？
17.你所做的项目nuttx系统有没有虚拟内存的概念，linux中怎么把虚拟地址与物理地址对应，详细展开讲一讲（分页，分段及段页时，要说一下大概实现算法以及它们之间的区别）
18.你写过的代码你对它们优化过吗？用了哪些优化方法？（我回答了一个用移位优化乘除，然后面试官就问你浮点数运算怎么处理，我当时答了采用FPU，但这题确实把我问懵了）
19.你用过GDB调试吗？讲一讲常用命令。如果我编译报错，怎么定位错误位置，你知道gdb怎么进行多线程调试吗？
20.你知道回溯的概念吗？谈一谈栈回溯，采用gdb怎么调试？
21你有没有想问的
一面小结 感觉大疆问的题目很深，很多涉及其底层运行原理，就比如虚拟内存实现方法中，面试官让我具体谈一下分页实现的流程以及算法，所以学习不能只浮于表面，个人感觉这次面的不是很好，如果运气好有二面的话，我会继续更新
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c0ec52915b487e90953c8e4f18a31b8/" rel="bookmark">
			package.json版本号符号^和~前缀的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发中经常会使用npm install 安装依赖包，经常会看到^符号和~符号，现将二者的区别总结如下: "devDependencies": { "@babel/runtime": "~7.12.0", "@dcloudio/types": "*", "@dcloudio/uni-automator": "^2.0.0-32920210927002", "@dcloudio/uni-cli-i18n": "^2.0.0-32920210927002", "@dcloudio/uni-cli-shared": "^2.0.0-32920210927002", "@dcloudio/uni-migration": "^2.0.0-32920210927002", "@dcloudio/uni-template-compiler": "^2.0.0-32920210927002", "@dcloudio/vue-cli-plugin-hbuilderx": "^2.0.0-32920210927002", "@dcloudio/vue-cli-plugin-uni": "^2.0.0-32920210927002", "@dcloudio/vue-cli-plugin-uni-optimize": "^2.0.0-32920210927002", "@dcloudio/webpack-uni-mp-loader": "^2.0.0-32920210927002", "@dcloudio/webpack-uni-pages-loader": "^2.0.0-32920210927002", "@fullhuman/postcss-purgecss": "3.0.0", "@types/video.js": "^7.3.26", "@vue/babel-preset-app": "^4.5.12", "@vue/cli-plugin-babel": "~4.5.0", "@vue/cli-service": "~4.5.0", "autoprefixer": "9.8.6", "babel-plugin-import": "^1.11.0", "cross-env": "^7.0.2", "jest": "^25.4.0", "js-md5": "^0.7.3", "mini-types": "*", "miniprogram-api-typings": "*", "postcss-comment": "^2.0.0", "sass": "^1.32.8", "sass-loader": "10.1.1", "vue-template-compiler": "^2.6.11" }, 注意： 对应上面的版本号以 x.y.z ：为例子
z ：表示一些小的bugfix, 更改z的号；重大更新
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c0ec52915b487e90953c8e4f18a31b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576eda990c897550c65dfa42b651cccb/" rel="bookmark">
			卸载骑安信，超爽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于工作原因，在上一家公司安装了360奇安信安全软件，到了下一个公司还需要安装另一个安全软件，这个必须要卸载，卸载！卸载！
但是卸载需要输入密码，没有密码还输入卸载不了，我曾经联系360的工程师，他们让我开向日葵远程帮我卸载，发现他们也卸载不了，浪费我时间。
无奈，我自己搞定了，这里记录一下卸载不需要输入密码的方法。
首先电脑在开启的情况下，使用window键+R组合键打开运行框，输入“msconfig”，然后按回车。
在打开的系统配置中，找到"引导"选项，然后单击，然后在“安全引导”的选项前打上勾就OK了，然后点击底部的“确定”保存。
然后会出现弹框，我们点击重新电脑，这样进入就是安全模式了，只有进入安全模式修改配置文件才是有效的。
在软件安装中找到这个文件EnBase.dat
把uienable,qtenable全部设置为0，意思就是关闭密码保护，把uipass及qtpass后面的密码都删了，然后保存并关闭这个文件。
接着在电脑中打开控制面板，选择程序，卸载360奇安信软件即可。等待卸载完成。
然后使用window键+R组合键打开运行框，输入“msconfig”，然后按回车。
打开的系统配置中，找到"引导"选项，然后单击，然后在“安全引导”的选项前打上勾取消掉了。
点击确定会提示重启电脑，重启之后就进入正常模式，打开软件中心发现360已经卸载了，这样就算完成了免密码卸载360。觉得还不放心的可以把源文件也删除了。
下面就可以安装新公司的安全软件了，完美！
-----------------------------------
©著作权归作者所有：来自51CTO博客作者孙叫兽杂谈的原创作品，请联系作者获取转载授权，否则将追究法律责任
亲手把360奇安信软件卸载了，爽！
https://blog.51cto.com/sunmenglei/4869103
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/387f390f336c7f15ebe063f793f1f162/" rel="bookmark">
			Windows用virtualBox安装Ubuntu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下载virtualbox后进入virtualbox管理器，选择“新建”
在“名称”写入虚拟机名称，“文件夹”可自行定义虚拟机存放在Windows中的路径，“版本”若Ubuntu版本为32位则选择32位的版本，此处的版本位64位
这里可自行选择虚拟机的内存大小，尽量给多内存（若电脑是8GB，则可以给虚拟机3GB，这样虚拟机运行会比较流畅）
创建虚拟硬盘
选择文件类型
虚拟硬盘选择动态分配内存
给虚拟机分配内存，考虑到虚拟机后面会需要安装各种软件，分配内存不足会影响虚拟机的使用
完成这一步后点击“创建” 进入“存储”项目后，点击没有盘片，再点击光盘按钮，选择一个虚拟光驱，添加Ubuntu ISO映像文件。（在“没有碟片”的属性“分配光驱”中选择第一个选项后将下载的Ubuntu映像文件添加即可）
然后点击“启动”
启动后若出现该界面则下拉选择添加的Ubuntu映像文件，若没有出现则直接进入下一步
虚拟机启动界面
进入虚拟机启动界面后，会出现虚拟机的安装界面
选择语言“中文（简体）和安装Ubuntu后进入下一步
直接点击”继续“
选择”其他选项“后点击”继续“
点击“新建分区表”按钮。（若在界面上无法看到“+”按钮，这是由于计算机的分辨率问题导致的，遇到这种情形时，可以按住键盘的“Alt”键，再把鼠标移动到安装界面上，点住鼠标左键不放，向上拖动界面，就可以看到其他被遮住的部分了。后面在安装过程中，可以用这种方法处理类似问题。）
点击”继续“
选择下图中“空闲”，然后再点击“+”按钮 点击“+”按钮后，会出现如上图的界面，进行如下设置:
大小：512MB
新分区的类型：选择“主分区”选项
新分区的位置：选择“空间起始位置”选项
用于：在下拉列表中选择“交换空间”选项
然后点击“确定”按钮
继续选择下图中“空闲”，然后再点击“+”按钮
点击“+”按钮后，会出现如下图的界面，进行如下设置
大小：不用改动，系统自动设为剩余的空间
新分区的类型：选择“逻辑分区”选项
新分区的位置：选择“空间起始位置”选项
用于：在下拉列表中选择“EXT4日志文件系统”选项
挂载点：在下拉列表中选择“/”选项 完成以上步骤后点击”选择安装“
点击”继续“后进入时区选择，时区选择默认即可，点击“继续”
完成后进入键盘布局，都选择”汉语“后点击”继续“
完成后进入用户与密码设置，完成后点击 ”继续“
完成后系统开始自动安装（不要点击”skip“）
安装完成后，点击“现在重启”，“现在重启”只是重启虚拟机系统
选择设定的用户名后输入密码便可进入虚拟机系统
虚拟机启动后，是小窗口运行的，所支持的分辨率较低，需要进行一些设置来提高分辨率
选择“设备”后在下拉窗口点击“ 安装增强功能”
若出现上方错误则可以手动删除VBox _GAs_6.1.4(点击“确定”后右键点击该图标后在下拉菜单中选择“弹出”）
完成该步后会弹出一个授权窗口，需要输入密码进行授权
可以点击该图标进入终端或者CTRL+t也可进入终端 进入终端输入下列代码并且运行
sudo apt-get install virtualbox-guest-dkms 运行过程中终端会出现该问题，输入y后按回车即可
运行完成后重启虚拟机
重启后进入系统设置，更改分辨率
选择该图标后可进行搜索进入系统设置界面
点击“显示”则进入分辨率设置界面
在这里选择设置好分辨率后点击“应用”
出现该界面后点击“保持当前配置”
到此为止，virtualbox安装Ubuntu完全结束
撒花撒花撒花 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95b2a145ecaa9fffa88204cc07706286/" rel="bookmark">
			VScode ---- vue中HTML代码tab键自动补全插件及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 欢迎访问我的博客地址 : 博客地址
1. 首先在vscode商店中下载并重新加载 HTML Snippets 2. 在设置(settings.json)中搜索 files.associations 配置对象 3. 在 settings.json 对象最后插入代码: "files.associations": { "*.vue": "html" }, "emmet.triggerExpansionOnTab": true, "emmet.includeLanguages": { "vue-html": "html", "vue": "html" } (如图所示) 在 settings.json 文件对象最后插入这段代码 此时, 在html结构中就可以使用tab键自动补全标签 例如: 输入 child 然后按下tab键便可自动补全标签 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0402a537d9cf6f2e9017f2a72ceb460e/" rel="bookmark">
			零束科技打通智驾全域数据闭环，加速智驾场景规模化量产落地！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能驾驶落地的一大阻碍是无穷无尽的Corner Case（极端情况），这些Corner Case所带来的安全隐患一直限制着智能驾驶真正量产，实现智能驾驶技术工程化落地，从而解决数据分布“长尾问题”，已经成为行业共识。打造智能的数据闭环体系，对数据进行高效收集和利用，提高数据循环速度，是智能驾驶技术完成快速迭代的关键点。
全栈赋能，零束打造数据闭环体系
零束智驾计算平台以银河全栈技术解决方案为基础，打造了智能驾驶全域数据闭环体系，以数据驱动核心算法开发迭代，加速智驾场景规模化量产落地。零束智驾数据工场实现了结构化和非结构化数据全域闭环及全套工具链自研，车端支持路采数据以及基于边缘计算的量产众包数据采集方案；数据接入云端后，总线及算法中间数据等结构化数据可以用于仿真场景还原，还原后的场景可以决策规控算法在云端的大规模并行仿真测试；图片、点云等非结构化数据在云端进行标注后用于感知模型的训练、迭代；同时，整包数据还可用于端到端算法的回灌测试；至此，迭代后的算法可以通过OTA再次上车，形成完整的闭环，并可以根据需求再次下发新的采集策略至车端，获取新的数据。
零束智驾数据工场采用四大平台打造全域数据闭环：由数据管理平台统一接入数据，经过解析、筛选、分类、落库后进入AI标注平台进行标注，标注完成的数据流转至训练平台进行感知模型的训练，同时结构化数据也进入到仿真平台进行场景还原，用于决策归控算法的迭代。
数据管理平台
作为数据入口，零束数据管理平台提供了丰富的数据处理服务，所有功能抽象成接口统一的原子化服务，统一的调度平台支持数据处理流程的自定义编排，能够高效处理各种不同类型的数据。同时，处理完成的数据也可通过平台进行高效分类管理。
数据标注平台
数据标注平台是零束为智能驾驶领域提供的一款算法先进、且标注及质检机制成熟的云端工具链产品平台，提供数据高质、高效标注作业下的全生命周期流程管理，支持丰富的手动交互标注、AI自动标注等工具，大幅提升标注效率，能够在低成本模式下高效完成标注作业，迅速累积高质量数据资产。
模型训练平台
零束模型训练平台提供一站式开发、调试、训练、部署服务，支持TensorFlow、PyTorch等多种模型训练框架，能快速进行算法迭代、模型部署、推理验证。同时，零束模型训练平台提供自动化GPU资产管理，可管理数千台GPU主机集群，支持多类型GPU同集群池化、分场景使用，支持GPU虚化，最小颗粒度可达单卡1%，按需使用、充分发挥硬件性能。
仿真测试云平台
零束仿真测试云平台集静态和动态数据导入、测试场景案例编辑、传感器仿真、动力学仿真、可视化测试与回放、在环测试于一体，借助场景转换工具链，能够迅速在云端重建现实场景中发生的Corner Case并进一步丰富场景库，具有加速计算能力以及高数据算力的特性。
快速集结人才，聚焦智能驾驶赛道
为了进一步夯实智能车技术底座，打造舱驾融合的数字化极致体验，今年5月，零束科技快速集结一批汽车智能化高科技人才，正式成立智驾计算平台业务板块，聚焦智能驾驶赛道，成立短短3个月，零束智驾计算平台就已经成功打造了智能驾驶全域数据闭环体系。作为零束银河全栈核心技术底座之一，零束智驾计算平台融合了“全栈电子架构，大算力芯片、高实时软件计算平台、业内领先BEV算法、全域闭环数据工场”等多专业、跨领域核心技术优势，覆盖高速、泊车及城区全场景体验，终局实现从端到端的融合智驾。
零束完整的智驾数据闭环体系极大地提升了智驾功能与产品的闭环迭代升级速度，不断扩展智驾场景“边界”，持续为用户带来新价值。在智能车发展的新赛道上，智能驾驶已经成为企业赢得未来竞争的战略焦点。零束科技将继续加强核心技术的研发和创新，提供技术领先、成本领先和商业模式领先的全栈融合智驾产品解决方案，全面赋能品牌差异化及用户极致体验，助力品牌加速实现不同场景下的智驾产品创新及车型量产落地！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66f847ebbc1285c49734587361ff8851/" rel="bookmark">
			知识表示学习（四）：TransD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.摘要 知识图谱是许多 AI 应用程序的有用资源，但它们远非完整。 以前的工作如 TransE、TransH 和 TransR/CTransR 将关系视为从头实体到尾实体的转换，并且 CTransR 实现了最先进的性能。在本文中，我们提出了一种更细粒度的模型，称为 TransD，它是对 TransR/CTransR 的改进。 在 TransD 中，我们使用两个向量来表示一个命名符号对象（实体和关系）。第一个表示实体（关系）的含义，另一个用于动态构造映射矩阵。与TransR/CTransR相比，TransD不仅考虑了关系的多样性，还考虑了实体。 TransD 参数较少，没有矩阵向量乘法运算，可以应用于大规模图。
二.背景介绍 WordNet、Freebase 和 Yago 等知识图谱在关系提取 (RE)、问答 (Q&amp;A) 等许多 AI 应用中发挥着举足轻重的作用) 等。它们通常包含大量结构化数据，以三元组（头实体、关系、尾实体）的形式（表示为 (h, r, t)），其中关系对两个实体之间的关系进行建模。由于大多数知识图谱要么是协作构建的，要么是（部分）自动构建的，因此它们经常遭受不完整的困扰。知识图谱补全是根据知识图谱中已有的三元组来预测实体之间的关系。在过去的十年中，基于符号和逻辑的知识图谱补全已经做了很多工作，但是对于大规模的知识图谱来说，它们既不易于处理，也不够收敛。最近，这项任务的一种强大方法是将知识图谱的每个元素（实体和关系）编码到低维嵌入向量空间中。这些方法通过代数运算对知识图进行推理。
在这些方法中，TransE (Bordes et al. 2013) 简单有效，并且还实现了最先进的预测性能。它为知识图中的每个实体和关系学习低维嵌入。这些向量嵌入由相同的粗体字母表示。基本思想是每个关系都被视为嵌入空间中的平移。对于一个黄金三元组 (h, r, t)，通过添加嵌入 r，嵌入 h 接近于嵌入 t，即 h + r ≈ t。 TransE 适用于 1 对 1 关系，但在处理 1 对 N、N 对 1 和 N 对 N 关系时存在缺陷。 TransH (Wang et al.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66f847ebbc1285c49734587361ff8851/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c91123af508ec6cace1413cdc9f401ae/" rel="bookmark">
			data functions should return an object:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在涉及props当中，因为涉及到数据没有 return里面所以我就把数据删除了。
导致如下：
后来，发现没有data的函数返回值。
data(){
return{}
}
加上之后就会解决问题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/133247c39dc155f15412585b93d2cb39/" rel="bookmark">
			使用bat批量删除修改子目录文件名后缀，超简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只需要一行命令就能修改当前目录以及子目录文件后缀。
实例：
当前文件夹内有n个子目录，并且每个目录下都有后缀为.7z1的压缩包文件，需要批量修改为.7z。
只需要在当前文件夹新建txt文档。
写入：
@echo off //这行不写也行
for /r %%a in (*.7z1) do ren "%%a" "%%~na.7z"
随后保存为bat格式，双击完成修改。
na.后面写入7z是修改，不写则是删除。
注意后缀不能有中文，否则无效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51b475518360d762f30134aa76b534f2/" rel="bookmark">
			History.pushState(),动态添加历史记录.页面离开如何保存状态?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		History.pushState() History API
在 HTML 文档中，history.pushState() 方法向当前浏览器会话的历史堆栈中添加一个状态（state）。
语法 history.pushState(state, title[, url]) 参数 state
状态对象是一个 JavaScript 对象，它与pushState()创建的新历史记录条目相关联。 每当用户导航到新状态时，都会触发popstate (en-US)事件，并且该事件的状态属性包含历史记录条目的状态对象的副本。
状态对象可以是任何可以序列化的对象。 因为 Firefox 将状态对象保存到用户的磁盘上，以便用户重新启动浏览器后可以将其还原，所以我们对状态对象的序列化表示施加了 2MiB 的大小限制。 如果将序列化表示形式大于此状态的状态对象传递给pushState()，则该方法将引发异常。 如果您需要更多空间，建议您使用 sessionStorage或者localStorage。
title
当前大多数浏览器都忽略此参数，尽管将来可能会使用它。 在此处传递空字符串应该可以防止将来对方法的更改。 或者，您可以为要移动的状态传递简短的标题。
url 可选
新历史记录条目的 URL 由此参数指定。 请注意，浏览器不会在调用pushState() 之后尝试加载此 URL，但可能会稍后尝试加载 URL，例如在用户重新启动浏览器之后。 新的 URL 不必是绝对的。 如果是相对的，则相对于当前 URL 进行解析。 新网址必须与当前网址相同 origin； 否则，pushState()将引发异常。 如果未指定此参数，则将其设置为文档的当前 URL。
描述 从某种程度来说，调用 pushState() 和 window.location = "#foo"基本上一样，他们都会在当前的 document 中创建和激活一个新的历史记录。但是 pushState() 有以下优势：
新的 URL 可以是任何和当前 URL 同源的 URL。但是设置 window.location 只会在你只设置锚的时候才会使当前的 URL。非强制修改 URL。相反，设置 window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51b475518360d762f30134aa76b534f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82ee5fb013587e795bd5f155af70863e/" rel="bookmark">
			python编码错误解决SyntaxError: Non-ASCII character ‘\xe5‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在编写Python时，当使用中文输出或注释时运行脚本，会提示以下错误信息
原因是：Python的默认编码文件是用的ASCII码，而你的python文件中使用了中文等非英语字符。
解决方式一：
在Python源文件的最开始一行，加入一句：
# 等号和冒号都可以 # coding=UTF-8 解决方式二：
在Python源文件的最开始一行，加入一句：
# -*- coding:UTF-8 -*- 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89c0bd32f6651c7924aae007b857805c/" rel="bookmark">
			2022年新出最火接口工具，利用apifox来测试API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
由其他的team做的项目，配置到一个新的环境下。由于项目需要与别的公司的项目接连，所以需要创建公开的API接口，利用apifox来进行测试（postman，jamater都可以）。此次利用apifox来创建测试API接口的测试
1. 在官网下载apifox工具
下载地址和使用文档的URL : https://www.apifox.cn/help/
下载之后需要注册登入自己的账号
2.创建简单API的测试接口可以感觉使用文档来操作　3.前置操作和后置操作
在测试API时首先需要取得一个token，在取得token的时候还需要【SHA256】加密处理，所以需要创建一个前置操作
pm.environment.set("timestamp",""); pm.environment.set("checkValue",""); var timestamp = new Date().getTime(); pm.environment.set("timestamp",timestamp.toString()); pm.environment.set("checkValue",CryptoJS.SHA256("XXXXXX" +timestamp ).toString()); 4.提取全局变量
5.前置操作的结果值
6 在另一个API中利用全局变量
7.当API接口有图片的场合创建的测试的API接口
file：上传图片
token：api认证的凭证
per：需要传递的额外的项目的值可以是json，string，等等其他的项目
追记
JS中利用CryptoJS进行MD5/SHA256/BASE64/AES加解密的方法与示例
MD5加密
CryptoJS.MD5(‘待加密字符串’).toString()
SHA256加密
CryptoJS.SHA256(‘待加密字符串’).toString()
base64加密
CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(‘待加密字符串’))
base64解密
CryptoJS.enc.Base64.parse(“待解密字符串”).toString(CryptoJS.enc.Utf8)
AES简单加密
CryptoJS.AES.encrypt(‘待加密字符串’, ‘秘钥’).toString()
AES简单解密
CryptoJS.AES.decrypt(‘待解密字符串’, ‘秘钥’).toString(CryptoJS.enc.Utf8)
自定义AES加解密函数
以上示例是2个简单aes加解密方案，大部分情况下，我们需要自定义aes加解密更多的参数，比如加密模式、填充等。
const key = CryptoJS.enc.Utf8.parse("秘钥"); //十六位十六进制数作为密钥 const iv = CryptoJS.enc.Utf8.parse('偏移量'); //十六位十六进制数作为密钥偏移量 //解密方法 function Decrypt(word) { let encryptedHexStr = CryptoJS.enc.Hex.parse(word); let srcs = CryptoJS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89c0bd32f6651c7924aae007b857805c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af9462ae067ffc476d155a4c6ea52265/" rel="bookmark">
			Kali Linux渗透测试——信息收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记内容参考安全牛课堂苑房弘老师的Kali Linux渗透测试教程
渗透测试标准(PTES：http://www.pentest-standard.org)的七个阶段：
1.前期交互阶段：讨论确定渗透测试范围、方式、限制条件等
2.情报收集阶段：通过主被动信息收集，获取目标系统的服务、系统配置、网络拓扑等
3.威胁建模阶段：根据收集的信息，确认合适的渗透测试方法
4.漏洞分析阶段：分析目标系统漏洞，编写漏洞利用代码，确定可以突破的攻击点
5.渗透攻击阶段：入侵系统，获取控制权
6.后渗透测试阶段：扩大攻击范围，入侵核心服务器，预置后门，实现持续控守，挖掘目标系统更多具有价值的信息
7.生成渗透测试报告：汇集关键情报、漏洞信息，分析安全防御系统的薄弱环节、补漏及升级方案等
文章目录 一、被动信息收集（一）DNS信息收集（二）搜索引擎信息收集（三）公开漏洞信息平台（四）METADATE 二、主动信息收集（一）主机发现（二）端口扫描（三）服务扫描（四）操作系统识别（五）SNMP扫描（六）SMB扫描（七）SMTP扫描（八）防火墙识别（九）WAF识别（十）WEB目录扫描 一、被动信息收集 被动信息收集即不向目标系统进行探测，不会留下任何痕迹。通过网络、公开渠道进行信息收集 。收集的内容包括IP地址段、域名信息、邮件地址、⽂档图⽚数据、公司地址、公司组织架构、联系电话 / 传真、⼈员姓名 / 职务、目标系统使⽤用的技术架构、公开的商业信息等。
（一）DNS信息收集 1.域名是分级的概念，而FQDN是域名下的主机(如：www.baidu.com)，注意两者不同。
2.域名记录类型：A、CNAME、PTR、MX、NS、TXT、TTL
3.DNS查询工具
nslookup
eg:nslookup -type=ns baidu.com 8.8.8.8dig (相比于nslookup准确性更高，功能更全)
eg:
dig @8.8.8.8 www.sina.com mx：向8.8.8.8服务器请求域名解析
dig +trace baidu.com：由本机迭代查询域名
dig -x &lt;ip&gt; +short：反查ip对应的域名 (PTR记录)，+short可以简略输出，在写批量反查脚本时很有用Amass
由OWASP维护的安全项目，使用多种开源信息收集和主动侦察技术，拥有更强大的资产发现和子域名挖掘功能。Amass下分intel、enum、viz、track、db、dns等六个子命令，intel用于发现目标资产，enum用于枚举子域名，viz将枚举结果可视化，track用于比较两次枚举结果的差异，db用于管理Amass收集的信息库，dns用于解析域名。
传送门：https://github.com/OWASP/Amass
eg:
amass intel -list：列出所有用于发现目标资产的源和获取方式
amass intel -active -src -whois -d sina.com：采用主动扫描技术，横向发现sina.com所属机构的更多资产，并注明信息来源
amass enum -active -ip -d sina.com：采用主动扫描技术，纵向枚举sina.com子域名，并列出域名对应的ip地址
amass enum -active -d sina.com -brute -w subdomains-top1million-5000.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af9462ae067ffc476d155a4c6ea52265/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e00c0e2ed16018e39f0e262931ae4c0b/" rel="bookmark">
			DApp简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是dapp？以下为详细介绍：
中心化应用（App）与去中心化应用（DApp）的区别
中心化应用（web2.0）原理：
前端（H5/小程序/App）=&gt; 发送请求 =&gt; 后端（服务器），
后端 =&gt; 返回内容 =&gt; 前端。
UI表现 &lt;= 通过http请求相互联系 =&gt; 后端服务程序，
后端服务程序=&gt;运行在服务器Nginx/Apache上。
去中心化应用（web3.0）原理：
前端（H5/小程序/App）=&gt; 发送交易，经过用户的加密签名 =&gt; 后端（分布式节点），
后端 =&gt; 返回事件 =&gt; 前端。
UI表现（钱包，DApp浏览器）&lt;= 通过rpc请求（web3.js）相互联系 =&gt; 智能合约，
智能合约 =&gt; 运行在节点EVM上。
以上为dapp详细介绍。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b4c8943db743c402fdd952e6ada5a5c/" rel="bookmark">
			Java中常见的数据结构以及Java集合框架的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的数据结构 数组 数组是多个相同类型数据按一定顺序排列的集合。
结构特点：
数组是有序排列的。数组属于引用数据类型的变量。数组的元素既可以是基本数据类型，也可以是引用数据类型。创建数组对象会在内存中开辟一整块连续的空间。数组的长度一旦确定，就不能修改。 功能特点：可以根据下标进行随机访问，查找快但增删慢
链表 链表是物理存储单元上非连续的、非顺序的存储结构。
链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。
特点：增删快，查找慢
栈 栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。
栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。
队列 队列只允许在表的一端进行插入操作，而在另一端进行删除操作。也就是类似于常见的排队。
一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。
树 树是典型的非线性结构，是n(n&gt;=0)个节点的有限集。n=0时称为空树。n&gt;0时，有限集的元素构成一个具有层次感的数据结构。
区别于线性表一对一的元素关系，树中的节点是一对多的关系。树具有以下特点：
n&gt;0时，根节点是唯一的，不可能存在多个根节点。每个节点有零个至多个子节点；除了根节点外，每个节点有且仅有一个父节点。根节点没有父节点。 堆 堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。
哈希 哈希表（Hash Table）是一种特殊的数据结构，它最大的特点就是可以快速实现查找、插入和删除。
哈希表（Hash Table）：也叫散列表，是根据关键码值（key-value）而直接进行访问的数据结构，也就是我们常用到的map。
哈希函数：也称为是散列函数，是Hash表的映射函数，它可以把任意长度的输入变换成固定长度的输出，该输出就是哈希值。哈希函数能使对一个数据序列的访问过程变得更加迅速有效，通过哈希函数，数据元素能够被很快的进行定位。
图 在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。
和线性表，树的差异:
线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点(Vertex)。线性表可以没有元素，称为空表；树中可以没有节点，称为空树；但是，在图中不允许没有顶点(有穷非空性)。线性表中的各元素是线性关系，树中的各元素是层次关系，而图中各顶点的关系是用边来表示(边集可以为空)。 小结 一般来说，数组、栈、队列、链表、哈希表这几个数据结构是用得比较多的，在具体的项目开发中，一般使用的是Java集合框架中的各种集合接口，如List 接口、set接口以及map接口等等。
Java集合 集合、数组都是对多个数据（对象）进行存储操作的结构，简称Java容器。
数组的缺点 初始化数组时要指定长度 , 且长度不可修改
数组采用连续的地址存储 , 添加和删除效率低下
数组无法直接保存映射关系
数组提供的方法有限
Java集合就像一种容器，可以动态地把多个对象的引用放入容器中集合的元素必须是对象类型，不能是基本数据类型，如果是基本数据类型，此时使用的是包装类（(自动装箱/拆箱） 如 : coll.add(12); == coll.add(Integer.valueOf(12)); 容器分类 容器主要包括Collection 和Map两种，Collection存储着对象的集合，而Map存储着键值对的映射表。
单列集合框架概述 /----Collection接口 : 单列集合 ; 用来存储一个一个的对象 /----List接口 : 元素 有序 可重复; ---&gt;"动态数组" /----ArrayList , LinkedList , Vector /----Set接口 : 元素 无序且不可重复; ---&gt;高中"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b4c8943db743c402fdd952e6ada5a5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b29304ddb77e4078a231dfcf7e63720/" rel="bookmark">
			NeRF神经辐射场学习笔记（六）— NeRF&#43;&#43;论文要点解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NeRF神经辐射场学习笔记（六）— NeRF++论文要点解读 声明论文概述几何-辐射模糊性（shape-radiance ambiguity）反球面参数化（inverted sphere parameterization）参考文献和资料 声明 本人书写本系列博客目的是为了记录我学习三维重建领域相关知识的过程和心得，不涉及任何商业意图，欢迎互相交流，批评指正。
论文概述 NeRF++属于是对NeRF的更深理解和延伸，该文章首先讨论了几何-辐射模糊性（shape-radiance ambiguity）这一现象，并且分析了NeRF对于避免该现象的成功之处；接下来，NeRF++提出了一种参数化方法——反球面参数化（inverted sphere parameterization）来应对360度大规模无界3D场景的渲染，并取得了良好的效果。
几何-辐射模糊性（shape-radiance ambiguity） 几何-辐射模糊性（shape-radiance ambiguity）指的是一种现象：即在缺少正则化处理的情况下，本应该出现结果退化（degenerate solution，不同的shape在训练时都可以得到良好的表现，但是在测试时效果会明显退化）的情况。但是NeRF却避免了这种情况的发生，所以文章分析了NeRF在处理几何-辐射模糊性的成功之处。
首先，文章进行了一种符合输入图像的有效NeRF重建，将NeRF的不透明度场（opacity field）固定在单位球面上为1，在其他地方为0。然后，对于每个训练图像中的每个像素，我们将穿过该像素的光线与球面相交，并定义交点处（以及沿光线方向）的辐射度值为该像素的颜色。而下图则很好地展示了这种模糊现象（左边两图是训练数据的结果，右边两图是预测数据的结果）：
NeRF对这种现象的成功避免，文章给出了解释：NeRF特殊的MLP网络结构不对称地处理着位置信息 x \pmb{x} xx和方向信息 d \pmb{d} dd， d \pmb{d} dd被注入到靠近MLP末端的网络中，这意味着在渲染场景时涉及的MLP参数和非线性激活更少。并且相比于 x \pmb{x} xx的位置编码， d \pmb{d} dd的傅里叶特征（位置编码函数中的L）仅由较低频分量组成，即对于一个固定的 x \pmb{x} xx,辐射度 c ( x , d ) \pmb{c}(\pmb{x}, \pmb{d}) cc(xx,dd)对 d \pmb{d} dd有有限的表示性。
反球面参数化（inverted sphere parameterization） 文章针对360度的无界场景的渲染情况给出了一种反球面参数化的解决方法，即把场景空间划分为两部分——一个内部单位球体（an inner unit sphere）和一个外部反向球体（an outer volume represented by an inverted sphere covering the complement of the inner volume），其中内球体包含前景（foreground）和所有摄像机，外球体包含场景内的其余部分。这两部分是用不同的NeRF独立建模的，内球体的NeRF与传统的NeRF一致，对于外球体的NeRF，我们应用了反球面参数化的解决方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b29304ddb77e4078a231dfcf7e63720/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/241/">«</a>
	<span class="pagination__item pagination__item--current">242/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/243/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>