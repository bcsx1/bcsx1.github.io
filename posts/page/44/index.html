<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ccf5f542359f263d852ae5a3c1a7678/" rel="bookmark">
			vue自我理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把一个vue项目看做一个城市。
vue的大框架+webpack+nodejs的架构就相当于这座城市的整体大地基
里面的哪些页面可以看做是这座城市的建筑
那么相对应关于页面元素展示的v-if、v-else、v-else-if就是建楼盘的时候图纸上有没有 有就是v-if渲染没有就是v-else再或者是v-else-if
v-show就是我建了但我带了隐形道具除非条件允许你别想看到我
v-for就是机器会不会循环建筑一顿楼
v-html就是有个现成的小房子给你丢哪儿了
v-text就是有个毛坯给你丢哪儿了
v-on
v-bind
v-model
v-slot
v-pre
v-cloak
v-once
Router是道路管理系统、route是里面的每条街道
$router 类似于道路导航就是告诉你该怎么走用什么走
$route 每条街道这里记录着这条道路去往哪里源自哪里以及这条街道叫什么名字
Vuex就是街道办事处之类的存在
state是办事处里面的纸张 记录信息
mutation是底层打工人，一转一拨走一下
action是会变通的底层打工人
getter是办公室里面负责记录或整理信息变动的人员，以及变动后会发生什么
module办事处下面再分是分别是哪个街道的办事处
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d233f5dd46b74fde4d6ec95196852a8c/" rel="bookmark">
			Mybatis plus 大数据量查询慢问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据量操作一般用在数据迁移，数据导出，批量处理数据
在实际工作中当中，查询数据过大，我们使用分页查询的方式一页一页的将数据放到内存处理。但有些情况不需要分页的方式查询数据或者分很大一页查询数据时，如果一下子将数据全部加载出来到内存中，很可能会发生OOM(内存溢出)，而且查询会很慢，大量的时间和内存耗费在把数据库查询的结果封装成我们想要的对象。
问题：系统需要从mysql数据库里读取100w数据进行处理，需要怎么做？
常规查询：一次性读取100w数据到jvm内存中，或者分页读取流式查询：建立长连接，利用服务端游标，每次读取一条加载到jvm内存(多次获取，一次一行)游标查询：和流式一样，通过fetchSize参数，控制一次读取多少条数据(多次获取，一次多行) 常规查询 @Mapper public interface BigDataSearchMapper extends BaseMapper&lt;BigDataSearchEntity&gt; { @Select("select * from big_data ${ew.customSqlSegment}") Page&lt;BigDataSearchEntity&gt; pageList(@Param("page) Page&lt;BigDataSearchEntity&gt; page, @Param(Constants.WRAPPER) QueryWrapper&lt;BIgDataSearchEntity&gt; queryWrapper); } 如果不考虑limit深分页优化的情况下，或者等上几十分钟或几小时
流式查询 Mybatis提供一个叫org.apache.ibatis.cursor.Cursor的接口类用于流式查询，这个接口继承了java.io.Closeable和java.lang.Iterable接口，所以Cursor是可关闭，可遍历的。Cursor提供了三个方法：
isOpen()：用于在取数据之前判断Cursor对象是否是打开状态，只有当打开时Cursor才能取数据isConsumed()：用于判断查询结果是否全部取完getCurrentIndex()：返回已经获取了多少条数据 使用流式查询，则要保持对产生结果集的语句所引用的表的并发访问，因为其查询会独占连接
@Mapper public interface BigDataSearchMapper extends BaseMapper&lt;BigDataSearchEntity&gt; { // 一次获取，一次一行 @Select("select * from big_data ${ew.customSqlSegment} ") @Options(resultSetType = ResultSetType.FORWARD_ONLY, fetchSize = 100000) @ResultType(BigDataSearchEntity.class) void listData(@Param(Constants.WRAPPER) QueryWrapper&lt;BigDataSearchEntity&gt; queryWrapper, ResultHandler&lt;BigDataSearchEntity&gt; handler); } 如果有一个很大的查询结果需要遍历处理，又不想一次性将结果集装入客户端内存，就可以考虑使用流式查询；分库分表场景下，单个表的查询结果集虽然不大，但如果某个查询跨了多个库多个表，又要做结果集的合并、排序等动作，依然有可能撑爆内存；详细研究sharding-sphere的代码不难发现，除了group by 与order by字段不一样之外，其它的场景都非常适合使用流式查询，可以最大限度的降低对客户端内存的消耗。
游标查询 对大量数据进行处理时，可以采用游标方式进行数据查询处理。不仅可以节省内存的消耗，而且还不需要一次性取出所有数据，可以进行逐条处理或逐条取出部分批量处理。一次查询指定 fetchSize 的数据，直到把数据全部处理完。
Mybatis 的处理加了两个注解：@Options和@ResultType
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d233f5dd46b74fde4d6ec95196852a8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a81da9e06c87c90df3324355ba30f1f/" rel="bookmark">
			windows系统文件损坏修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 这段时间Windows10 操作系统动不动就蓝屏崩溃，然后重启，底部状态栏经常卡顿点击无反应，给我们的工作带来了特别麻烦的事儿。
二、原因分析 造成这个原因可能比较多的原因，比如软件冲突、系统文件损坏等，但反思最近没有安装新软件，如果软件冲突，在我安装的时候就应该暴露出来，极有可能是系统文件损坏。
三、修复 分享一个修复系统损坏文件的方法即windows自带的sfc命令。
sfc命令，可以扫描并替换系统中所有损坏的文件。
sfc系统文件检查器扫描系统文件，然后自动替换损坏或丢失的系统文件：管理员运行CMD，输入命令：sfc /scannow
同理sfc还有其他的使用方法，比如修复特定文件，比如： sfc /scanfile=c:\windows\system32\ieframe.dll
还比如只执行扫描不进行修复：sfc /verifyonly
sfc修复windows系统的思路，如果文件损坏或丢失，他将从C:/Windows/WinSxS/Backup/中获取。如果这个源被删掉了，他将从Microsoft的网站下载正确的文件。
四、总结 sfc是windows隐藏的一个修复系统文件的工具，在我们windows系统出现问题的时候，首先要冷静，不要立马就去重装系统，我们要去看看有没有其他可以修复系统的工具。这也给我们设计软件的时候给出了一个备份参考，也是应急备份方法，它可以让我们快速修复被损坏的系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/745eda4f45a5bee2dc438a55c79ca190/" rel="bookmark">
			android : 省市区Json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考 getActivity/ProvinceJson
数据 [ { "name": "北京市", "city": [ { "name": "北京市", "area": [ "东城区", "西城区", "海淀区", "朝阳区", "丰台区", "石景山区", "门头沟区", "通州区", "顺义区", "房山区", "大兴区", "昌平区", "怀柔区", "平谷区", "密云区", "延庆区" ] } ] }, { "name": "上海市", "city": [ { "name": "上海市", "area": [ "黄浦区", "浦东新区", "徐汇区", "长宁区", "静安区", "普陀区", "虹口区", "杨浦区", "闵行区", "宝山区", "嘉定区", "金山区", "松江区", "青浦区", "奉贤区", "崇明区" ] } ] }, { "name": "天津市", "city": [ { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/745eda4f45a5bee2dc438a55c79ca190/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e98924a2de5e64aef1bc12db8f9b486d/" rel="bookmark">
			SuperMap许可常见问题及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：lly
SuperMap许可常见问题及解决办法 在使用许可的过程中，大家可能会遇到的各种问题，本文从许可的申请、使用、异常处理三个方面
给大家逐一介绍。
文章目录 SuperMap许可常见问题及解决办法一.试用许可申请二.试用许可生效2.1 Windows下试用许可生效2.2 Linux下试用许可生效2.3 Docker下试用许可生效 三.试用许可常见问题3.1 Windows下试用许可更新失败3.2 Linux下试用许可更新失败 四.正式许可常见问题4.1 Windows下网络锁读取不到4.2 Linux下网络锁读取不到4.3 Docker读取硬件网络锁配置及常见问题4.4 许可模块读取不全4.5 lic9D正式文件锁检测 五.Web许可中心常见问题5.1 Web许可中心如何开启https5.2 如何部署Web许可中心War包5.3 如何连接War包部署Web许可中心 六.驱动常见问题6.1 Windows安装驱动的报错中包含一系列数字，或提示内部错误6.2 Linux中更新许可提示【hasp_feature_expired】6.3 Windows安装驱动报error: -536870329 七.注意事项7.1 切换许可模式7.2 查询正确MAC地址7.3 Linux重启许可服务7.4 查看Linux CPU逻辑核数7.5 Linux生成report文件7.6 其它 一.试用许可申请 可以直接在北京超图软件股份有限公司官网的“SuperMap 技术资源中心”申请试用许可，申请后您将获得：
1.如果申请的是 Web型许可，您将获得 一个 .licc 格式的许可文件
2.如果申请的是 SuperMap GIS 10i&amp;9D 系列产品的许可，您将获得 一个 .lic9d 格式的许可文件
3.如果申请的是 SuperMap GIS 11i 系列产品的许可，您将获得 一个 .licx 格式的许可文件
二.试用许可生效 2.1 Windows下试用许可生效 您可以通过以下两种方式使申请的试用许可生效
方式一：许可中心更新
首次打开 SuperMap 许可中心，该程序会自动安装依赖的驱动，并默认安装一个90天的试用软许可。若是才申请的许可，则可通过在 SuperMap 许可中心，打开“激活更新”页，浏览并选择您获得的许可文件，然后，单击“更新”按钮，即可使许可生效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e98924a2de5e64aef1bc12db8f9b486d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27ece3a12d484e8b0cbc3647e62c69db/" rel="bookmark">
			颜色十六进制代码对照表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 白色 #FFFFFF 2 红色 #FF0000 3 绿色 #00FF00蓝色 #0000FF 5 牡丹红 #FF00FF 6 青色 #00FFFF黄色 #FFFF00 8 黑色 #000000 9 海蓝 #70DB93巧克力色 #5C3317 11 蓝紫色 #9F5F9F 12 黄铜色 #B5A642亮金色 #D9D919 14 棕色 #A67D3D 15 青铜色 #8C78532号青铜色 #A67D3D 17 士官服蓝色#5F9F9F 18 冷铜色 #D98719铜色 #B87333 20 珊瑚红 #FF7F00 21 紫蓝色 #42426F深棕 #5C4033 23 深绿 #2F4F2F 24 深铜绿色 #4A766E深橄榄绿 #4F4F2F 26 深兰花色 #9932CD 27 深紫色 #871F78深石板蓝 #6B238E 29 深铅灰色 #2F4F4F 30 深棕褐色 #97694F深绿松石色 #7093DB 33 暗木色 #855E42 34 淡灰色 #545454土灰玫瑰红色#856363 36 长石色 #D19275 37 火砖色 #8E2323森林绿 #238E23 39 金色 #CD7F32 40 鲜黄色 #DBDB70灰色 #C0C0C0 42 铜绿色 #527F76 43 青黄色 #93DB70猎人绿 #215E21 45 印度红 #4E2F2F 46 土黄色 #9F9F5F浅蓝色 #C0D9D9 48 浅灰色 #A8A8A8 49 浅钢蓝色 #8F8FBD浅木色 #E9C2A6 60 石灰绿色 #32CD32 61 桔黄色 #E47833褐红色 #8E236B 63 中海蓝色 #32CD99 64 中蓝色 #3232CD中森林绿 #6B8E23 66 中鲜黄色 #EAEAAE 67 中兰花色 #9370DB中海绿色 #426F42 69 中石板蓝色#7F00FF 70 中春绿色 #7FFF00中绿松石色 #70DBDB 72 中紫红色 #DB7093 73 中木色 #A68064深藏青色 #2F2F4F 75 海军蓝 #23238E 76 霓虹篮 #4D4DFF霓虹粉红 #FF6EC7 78 新深藏青色#00009C 79 新棕褐色 #EBC79E暗金黄色 #CFB53B 81 橙色 #FF7F00 82 橙红色 #FF2400淡紫色 #DB70DB 84 浅绿色 #8FBC8F 85 粉红色 #BC8F8F李子色 #EAADEA 87 石英色 #D9D9F3 88 艳蓝色 #5959AB鲑鱼色 #6F4242 90 猩红色 #BC1717 91 海绿色 #238E68半甜巧克力色#6B4226 93 赭色 #8E6B23 94 银色 #E6E8FA天蓝 #3299CC 96 石板蓝 #007FFF 97 艳粉红色 #FF1CAE春绿色 #00FF7F 99 钢蓝色 #236B8E 100亮天蓝色 #38B0DE棕褐色 #DB9370 102紫红色 #D8BFD8 103石板蓝色 #ADEAEA浓深棕色 #5C4033 105淡浅灰色 #CDCDCD 106紫罗兰色 #4F2F4F紫罗兰红色 #CC3299 108麦黄色 #D8D8BF 109黄绿色 #99CC32 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6c2dc73bde0d64c1225d0d32063a884/" rel="bookmark">
			尚硅谷JavaWeb电子书城项目(Java&#43;Mysql&#43;Tomcat&#43;Jsp)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己写的在线电子书城项目，可改写，添加功能，如打折，分类，用户管理，评论等功能。
使用方法：
1.使用idea导入项目。
2.数据库要用项目resource文件里的book.sql文件建立。
3.修改jdbc.properites中的数据库信息。
4.使用maven加载pom.xml中的依赖。
5.配置好tomcat容器，运行项目。
有问题请评论区问，我会看。
首页预览:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7442ebca3088de812c3939b7a58d8f16/" rel="bookmark">
			MacOS下C,C&#43;&#43;编译器路径与源码位置(附 bits/stdc&#43;&#43;.h)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		categories: [C_C++]
tags: C++ 写在前面 在下面的位置中写入(先mkdir bits)
stdc++.h文件内容:
参考 gcc 源码 gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/precompiled/stdc%2B%2B.h;
// C++ includes used for precompiling -*- C++ -*- // Copyright (C) 2003-2023 Free Software Foundation, Inc. // // This file is part of the GNU ISO C++ Library. This library is free // software; you can redistribute it and/or modify it under the // terms of the GNU General Public License as published by the // Free Software Foundation; either version 3, or (at your option) // any later version.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7442ebca3088de812c3939b7a58d8f16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b74d689b301ec062165f2977cb61af8a/" rel="bookmark">
			DAY9 指针(1)----对于指针基本概念的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指针是我们学习C语言中绕不开的一个话题。那么指针究竟是什么？为什么它如此重要？它的用法有哪一些呢？接下来进行指针的详解。
1.内存和地址 (1)内存 我们知道，计算机的数据的存储和读取都是在内存中实现的，CPU通过从内存中读取数据从而进行计算，并且通过内存来将计算好的数据存储在其中。
内存被划分为一个一个内存单元，每个内存单元的大小是1字节，也就是8bit位。
(2)地址 我们都知道，bit位和字节的大小可以说是非常小的了，在如此庞大的数据库，内存中，我们需要找到指定的那一段，倘若盲目从头到尾地找是很难找到效率也是很低的，所以我们就需要给内存单元编号，这样我们按照编号来寻找就会很快找到。
那么我们把这个所谓的编号就叫做地址。
地址也就是指针。
所以满足：
内存单元的编号=地址=指针
(3)深入了解存储和编址 事实上，那么多的内存数据是不可能被真正记录下来的，实际上它们都是通过硬件设计完成的。
在连接CPU和内存时，我们有一组线叫做数据总线，每根线只有两态，表示0,1【电脉冲有无】，那么一根线，就能表示2种含义，2根线就能表示4种含义，依次类推。32根地址线，就能表示2^32种含义，每⼀种含义都代表⼀个地址。足够来存放我们所有的内存信息。
地址信息被下达给内存，在内存上，就可以找到该地址对应的数据，将数据在通过数据总线传⼊ CPU内寄存器。
2.指针变量和地址 (1)取地址操作符（&amp;） 相信在scanf(" ",&amp; )的语句中我们已经见过了这个操作符。那么它究竟是干什么用的呢？
我们知道在C语言中创建变量就是在向内存申请空间。
int a = 10; 一个简单的整型变量a实际就是向内存申请了4个字节的空间来存储整数10。
既然有存储操作，那就肯定会有地址。
我们要怎么找到变量a的地址呢？就要用到取地址操作符&amp;。
int a = 10; &amp;a; printf("%p",&amp;a); 通过取地址得到a的地址。
但是需要注意的是：&amp;a取出的是a所占4个字节中地址较小的字节的地址。因为我们只要知道了最小的那个地址，那么四个字节的所有地址也就可以按顺序从而得知了，没有必要全部打印出来。
(2)指针变量 指针是指地址，那么如果我们通过取地址操作符(&amp;)拿到的地址是⼀个数值，这个数值可能也会需要存储起来方便以后再使用。我们会把这样的地址数值存放在：指针变量中。
int a = 10; int* pa = &amp;a;//取出a的地址并存储到指针变量pa中 指针变量顾名思义就是存放指针的变量，存放在指针变量中的值都会被理解为地址。
int * pa = &amp;a;
这个*号的位置只要类型和变量中间即可。
int*中的int是指某种类型，而*就是说明后面的pa是指针变量。
所以指针变量的定义就是：
类型 * 变量名
(3)解引用操作符 既然我们可以使用指针变量将指针保存起来，那么我们要使用的时候应该如何操作呢？
将指针保存的过程我们看作进入一间有编号的房间，那么要使用它的时候我们打开这扇门的过程可以叫做解码，那么也就会用到解引用操作符。
通过解引用这个操作我们就能得到指针所指向的地址里的内容。
int a = 100; int* pa = &amp;a; *pa = 0;//解引用操作符使得pa的值发生了变化，但地址仍然不变 return 0; int* pa定义指针变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b74d689b301ec062165f2977cb61af8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73d660bd9f8c7f0423e450e513dd455d/" rel="bookmark">
			DAY8 操作符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.操作符的定义 操作符是什么？操作符相当于标点符号之类的一系列符号。
在我们日常的语法结构中，
有像+ - * / 这种运算符号；
有表示逻辑关系的一系列术语，例如并且(and)，或者(or)；
有表示动作的动词，像平移，插入；
C语言中的操作符是用来进行各种数学运算、逻辑运算、位运算、赋值等操作的符号，那么看着是不是就和我们日常生活中的这些语法结构很像呢？
其实可以把操作符类比为生活中用于不同用途的工具，例如锤子用来敲打物品，筷子用来吃饭夹菜。
操作符是为了方便工作的，并且用途十分广泛，所以它具有多和灵活的特点。
2.原码 反码 补码 在介绍众多操作符之前，需要知道三个概念。
我们知道，在计算机中，常用的数制是二进制，那么在整数中，二进制的表示方法有三种，它们分别是：原码 反码 补码
有符号整数的表达式包括符号位和数值位，其中最高位也就是最左边那一位是符号位，其他都是数值位。
并且规定：对于符号位，0表示正，1表示负。
那么在我们知道了这些基本知识之后，接下来正式介绍这三种表示方法。
这三种码是数值的表达方式
原码 是打印在屏幕上我们所能看到的
反码 相当于原码的相反数
补码 是用于存储和计算的（因为另外两种计算可能会出现错误，补码可以将符号位和数值位统一处理）
同时这三种表达方式都是以比特位的格式来表达的。
在正整数和负整数中，三种表达方法的定义各不相同。
在正整数中： 原码 反码 补码都相同
在负整数中： 原码：直接将数值按照正负数的形式翻译成⼆进制得到的就是原码。
反码：将原码的符号位不变，其他位依次按位取反就可以得到反码。
补码：反码+1就得到补码。
并且在负整数中，三码满足如图的转换方式，并且需要记住：符号位是不会跟着取反的。
3.操作符的分类 操作符分为
• 算术操作符： + 、- 、* 、/ 、%
• 移位操作符: &gt; • 位操作符: &amp; | ^ `
• 赋值操作符: = 、+= 、 -= 、 *= 、 /= 、%= 、&gt;= 、&amp;= 、|= 、^=
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73d660bd9f8c7f0423e450e513dd455d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68c6ab1ebe380c73d362d8def6054a33/" rel="bookmark">
			《MySQL》索引篇：使用`like %x`索引就一定会失效吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有以下语句。
1.SELECT * FROM t_user WHERE name like '王'; 2.SELECT * FROM t_user WHERE name like '王%'; 3.SELECT * FROM t_user WHERE name like '%王'; 4.SELECT * FROM t_user WHERE name like '%王%'; 表一：有id（主键），name（二级索引），还有其他普通字段。
1、2语句都会走索引。
3、4语句因为用到左模糊匹配会导致索引失效。要查询的剩余数据不在二级索引中，如果通过全扫描二级索引查询部分数据，然后再回表查询剩余数据，还不如一开始就全表扫描来得快。
表二：只有id（主键），name（二级索引）。
1、2语句都会走索引。
3、4语句，因为表只有两个字段，所以 SELECT * 相当于 SELECT id,name ，形成索引覆盖。需要查询的数据在字段name构成的二级索引中，可因为模糊匹配的存在，不能利用索引的有序性，只能对二级索引进行全索引搜索即可，不需要全表扫描。（全索引扫描比全表扫描好一点，但依旧很慢。）
总结：like %x查询的数据都是索引时，形成索引覆盖，会走全扫描二级索引，不会走全表扫描。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55adc1fe87c77f2d3984f8c9722c9a63/" rel="bookmark">
			电脑网页无法打开提示err_connection_refused怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家在使用浏览器的时候有没有遇到过网页崩溃这一类问题，就有网友说自己打不开网页且界面显示“err_connection_reset网络错误”，这是怎么回事？又该怎么解决呢，下面我们就来看看电脑网页无法打开提示err_connection_refused怎么办的解决方法，大家一起来看看吧。
***亲测: 遇到网页打开显示err_connection_refused, 直接用方法二刷新DNS可以解决,方法一没试过;
方法一：组件注册
1、我们使用键盘的快捷键win+R，输入下图英文，点【确定】，如图。
2.如图所示，组件注册成功。
方法二：刷新DNS
1.最后，我们还需要刷新DNS，按下键盘的win+R，在搜索栏中输入“cmd”，如图所示。
2、接着小编直接输入法切换英文，输入【ipconfig/flushdns】，这儿注意下（/的前面有一个空格），如图。
3、输入后我们按下键盘回车键，就可以刷新DNS的，通过这三个检查基本解决“err_connection_reset”网络错误问题！
以上就是电脑网页无法打开提示err_connection_refused怎么办的解决方法，希望能帮助到大家
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7181aa7089e774f8bfb285d51b0bf528/" rel="bookmark">
			Babylonjs学习笔记(十)——拉伸多边形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 pnpm i earcut @types/earcut --save-d
import earcut from "earcut";
const outline = [new Vector3(-0.3, 0, -0.1), new Vector3(0.2, 0, -0.1)]; for (let i = 0; i &lt; 20; i++) { outline.push(new Vector3(0.2 * Math.cos((i * Math.PI) / 40), 0, 0.2 * Math.sin((i * Math.PI) / 40) - 0.1)); } outline.push(new Vector3(0, 0, 0.1)); outline.push(new Vector3(-0.3, 0, 0.1)); const car = MeshBuilder.ExtrudePolygon("car", { shape: outline, depth: 0.2 }, scene, earcut); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0878c406a4a48b8b1f7f9aedfb5fb1a/" rel="bookmark">
			【Database】什么是数据库？常见的数据库类型有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是数据库？常见的数据库类型有哪些？
首先，什么是数据库？把它想象成一个数字游乐场，我们以结构化的方式组织和存储大量信息。现在，让我们来谈谈数据库的主要类型。
关系型数据库： 想象一下，这就像在整齐的表中组织数据一样。把它想象成乖巧的兄弟姐妹，让一切都井井有条。
最为常见的莫过于关系型数据库，通过二维表格来存放数据。支持事务、关联查询等操作。典型代表的关系型数据库有：开源的MySQL、微软的SQLServer、甲骨文的Oracle。
OLAP DB: OLAP DB：联机分析处理 （OLAP） 是一种针对报告和分析目的而优化的技术。
偏向数据分析的OLAP数据库，其特点是：数据量巨大、分布式存储、偏向数据计算、聚合和转换，俗称的数据仓库/大数据分析。主流开源OLAP数据库引擎有：Hive、Sparksql、Druid、Clickhouse、Greeplum等。发散一下：会用到MapReduce一种编程模型，用于大规模数据集（大于1TB）的并行运算），Map表示映射，Reduce表示归约，思想来源函数式编程语言。搭建好之后，不管背后存了多少TB/多少GB/甚至PB数据，只需要在应用层发起一条查询，就会有一堆服务器集群帮你计算（厉害吧 _）。
NoSQL 数据库： 对传统的 SQL 方式说“不”。NoSQL 数据库有四种令人兴奋的风格：
Graph DB： 想想社交网络，人与人之间的关系最为重要。这就像映射谁和谁是朋友一样。
键值存储数据库： 它就像一个百宝箱，每个项目都有其唯一的密钥。找到你需要的东西是小菜一碟。
特点：在一个无序的键值集合中通过 key-value 键-值对 存放你的数据。很明显，key是唯一的、不能重复的（但value可以重复），无序（即不支持key排序）。那有什么好处呢？好处就是搜索查找指定的key非常棒！常见的就有高效缓存 Redis、Memcache等，也俗称NoSQL。Redis支持的value数据类型更为丰富，有：字符串、list列表、哈希表、有序集合。Memcache数据类型则较为单一。
文档数据库： 文档数据库是一种以类似于 JSON 的格式存储信息的数据库。它与传统数据库不同，用于处理文档而不是表格。
Column DB： 想象一下，像厨师准备食材一样对数据进行切片和切块。它既高效又快速。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d27328832cd012d4bbc79944e00350a/" rel="bookmark">
			Chart 9 Adreno GPU的 OpenCL 扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言9.1 OS-dependent vendor extensions9.1.1 Performance hint (cl_qcom_perf_hint)9.1.2 Priority hint for context creation (cl_qcom_priority_hint)9.1.3 Recordable command queue (cl_qcom_recordable_queues)9.1.4 cl_qcom_protected_context9.1.5 cl_qcom_create_buffer_from_image9.1.6 cl_qcom_onchip_global_memory9.1.7 cl_qcom_extended_query_image_info 9.2 Subgroup9.2.1 Subgroup size (wave size) selection9.2.2 Subgroup shuffle 9.3 图像相关操作9.3.1 卷积9.2.3 Box Filter9.3.3 绝对值差之和（SAD）和平方差之和（SSD）9.3.4 Bicubic Filter9.3.5 （强大的）图像矢量化操作9.3.5.1 2x2 read9.3.5.2 4x1 read9.3.5.3 image write 9.3.6 压缩图片 9.4 机器学习9.4.1 SNPE/QNN（神经网络处理引擎）9.4.2 OpenCL ML SDK for Adreno GPU9.4.3 Tensor virtual machine (TVM) and the `cl_qcom_ml_ops` extension9.4.3.1 TVM9.4.3.2 How TVM works with the `cl_qcom_ml_ops` extension9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d27328832cd012d4bbc79944e00350a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1660506449caa962dab0fa63864e4591/" rel="bookmark">
			linux c编程之多线程基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; static pthread_t g_sttest_pthread; static int running = 1; static void *test_thread(void *p) { int status = 0; while (running) { usleep(1000); printf("%s[%d] test_thread \n",__func__,__LINE__); } printf("%s[%d] test_thread \n",__func__,__LINE__); return NULL; } int main() { pthread_create(&amp;g_sttest_pthread, 0, test_thread, NULL); while( 'q' != getchar() ) { usleep(100000); } running = 0; pthread_join(g_sttest_pthread, NULL); return 0; } gcc pthread_test.c -o pthread_test -lpthread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread test_thread[18] test_thread 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0413bf8ef97012c7ec332d3a61d3ff74/" rel="bookmark">
			算法 - 二分搜索法 / 二分法（704）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理： 利用数组的有序性，每次取查找范围的中间点，缩窄一半的查找空间。比较中间值和目标值的大小，直到找到目标值或者查找区间为空时返回。 力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台
题目： 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 提示：
你可以假设 nums 中的所有元素是不重复的。n 将在 [1, 10000]之间。nums 的每个元素都将在 [-9999, 9999]之间 思路： 二分法的前提条件：数组为有序数组，且 数组中无重复元素；
因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的；
注意：区间的定义问题
区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在 while 寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。
写二分法，区间的定义一般为两种，左闭右闭即 [left, right]，或者左闭右开即 [left, right)。
答案： 方法一： 左闭右闭 [left, right]
/** * @param {number[]} nums * @param {number} target * @return {number} */ var search = function (nums, target) { // right是数组最后一个数的下标，num[right]在查找范围内，是左闭右闭区间 let mid = 0, left = 0, right = nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0413bf8ef97012c7ec332d3a61d3ff74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/335f2a02a204a7f28a0f0617488f3ed3/" rel="bookmark">
			天气预报爬虫-多城市-更新版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是直接保存到数据库版本的
import pandas as pd from bs4 import BeautifulSoup import re import time import requests import pymysql import datetime #请求页面方法 def getPage(url): #设置请求头 headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36' } #请求页面 html = requests.get(url,headers=headers) #查看网页状态码，如果为200则为正常 if html.status_code == 200: #返回网页文本内容 return html.text else: return None def getWeekend(year,month,day): week_list = ["星期一","星期二","星期三","星期四","星期五","星期六","星期日"] return week_list[datetime.date(year,month,day).weekday()] def concatDate(dateString): date = re.findall('&gt;(.*?)&lt;/a&gt;',dateString)[0] dateYear = date[:4] dateMonth = date[4:6] dateDay = date[6:] dateString = dateYear+'-'+dateMonth+'-'+dateDay weekendString = getWeekend(int(dateYear),int(dateMonth),int(dateDay)) return dateString,weekendString def analysisPage(url,city): html = getPage(url) page = BeautifulSoup(html,'html.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/335f2a02a204a7f28a0f0617488f3ed3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c208f56448784f63ee61fa098962769/" rel="bookmark">
			git 使用记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		远程仓库为空初始化 初始化本地仓库 git init 在本地仓库书写代码（这里可以编辑一个文本文件做测试，如hello.txt） 执行：git add 要让git管理的文件（git add hello.txt） =&gt;执行完此操作将我们的hello.txt保存到了暂存区 执行：git commit -m '备注信息' =&gt;执行此操作将我们的文件提交到了本地仓库 执行：git remote add origin 自己的仓库地址（如：git remote add origin https://gitee.com/currygl/ttt.git） =&gt;执行此操作将我们的远程仓库和本地仓库绑定（只需要绑定一次，后面的修改提交就不需要了） git push -u origin master =&gt;执行此操作将本地仓库的文件推送到远程仓库 如果远程仓库已有内容 初始化本地仓库 git init 将本地代码库与远程代码库相关联
$ git remote add origin https://gitee.com/qlqaq/projects/仓库名称 把远程仓库的代码更新到当前分支上面
$ git pull --rebase origin master git add 文件名 git commit -m "" 将本地代码推送到指定远程的仓库中
$ git push -u origin master 参考文章
https://www.cnblogs.com/xyfer1018/p/11493718.html
https://blog.csdn.net/qq_38215042/article/details/109406958
删除文件 rm 文件名 git commit -m "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c208f56448784f63ee61fa098962769/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69036cf2135af1c70158a0b5fc186a13/" rel="bookmark">
			uniapp 之 图片保存在相册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;view class="con"&gt; &lt;view class="safeAreaBottom"&gt;&lt;/view&gt; &lt;view class="cont"&gt; &lt;view class="text-center text-30"&gt; 您的邀请码 &lt;/view&gt; &lt;view class="fs-30" style="color: #FF1A1A;text-align: center;margin: 20rpx 0;"&gt; &lt;text v-for="(item,index) in userInfo.invitationCode" :key="index" style="padding: 8rpx 14rpx;margin-right: 9rpx;background: #EFEFEF;"&gt;{{item}}&lt;/text&gt; &lt;/view&gt; &lt;view style="font-size: 24rpx;color: #999;" class="text-center"&gt;邀请的好友也可在注册时直接填写邀请码&lt;/view&gt; &lt;view style="text-align: center;margin: 20rpx 0;"&gt; &lt;image :src="qrPic" style="width: 316rpx;height: 316rpx;"&gt; &lt;/image&gt; &lt;/view&gt; &lt;view&gt; &lt;view style="position: fixed;top: 78%;left: 92rpx;width: 562rpx;"&gt; &lt;u-button text="立即邀请" openType="share" shape="circle" color="#FC7400"&gt;&lt;/u-button&gt; &lt;view style="margin-top: 30rpx;" class="btn" @tap="downloadImg"&gt; 保存图片 &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { userInfo: {}, qrPic: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69036cf2135af1c70158a0b5fc186a13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88d047a5914927a5fcdc1146bbd37c19/" rel="bookmark">
			判断浏览器返回页面，app内嵌h5离开返回页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BFCache是一种浏览器优化，可实现即时前进和后退载入页面。它改善了用户的浏览体验，尤其是那些网络或设备速度较慢的用户。
在APP站内嵌套h5页面,判断进入拨号页返回情况:
我们需要通过visibilitychange
通过在点击时修改一个状态值,回来时和上面的方法进行判断
const isClick=false // 是否点击了离开页面按钮 const isShowPop=false // 是否显示弹窗 document.addEventListener('visibilitychange', () =&gt; { if (document.visibilityState == "visible") { if (isClick) { isShowPop = true } isClick = false } else {} }) 如果是在浏览器里面,判断进入拨号页(三方客服链接)返回情况:
在浏览器里面如果是离开了页面还是可以通过visibilitychange判断,但是跳转的是三方客服链接,那我我们回到页面,页面是会重新刷新的,我们需要知道是否返回了,就需要通过performance.getEntriesByType('navigation')[0].type
同时通过在点击时修改一个状态值,回来时和上面的方法进行判断
const isClick=false // 是否点击了离开页面按钮 const isShowPop=false // 是否显示弹窗 const pageshowFn=(event)=&gt; { const navigationType = performance.getEntriesByType('navigation')[0].type const {persisted = null} = event if (persisted || navigationType == 'back_forward') { isShowPop = true isClick = false } } window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88d047a5914927a5fcdc1146bbd37c19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88dbe7bfb3e69720f13df834bf2be2c8/" rel="bookmark">
			Python获取坐标的常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、列表1.1、列表索引1.2、枚举索引 二、numpy 数组2.1、数组索引2.2、乘法运算：image * mask2.3、条件索引2.3.1、np.argwhere()：返回满足条件的元素的坐标（数组表示）2.3.2、np.where()：返回满足条件的元素的索引（元组表示）2.3.3、np.nonzero()：返回数组中非零元素的索引（元组表示）2.3.4、np.indices()：返回数组中每个维度上索引值的数组（元组表示）2.3.5、np.extract()：提取数组中满足条件的元素并返回一维数组 实战一：获取每一列的最小值：np.min(coordinates, axis=0)实战二：提取坐标（时耗优化）实战三：数据归一化到[0, 255] + 数据类型转换为uint8 一、列表 1.1、列表索引 my_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] row_index = 1 column_index = 2 value_at_index = my_list[row_index][column_index] print(f"列表索引: 在位置 ({row_index}, {column_index}) 的值是 {value_at_index}") # 列表索引: 在位置 (1, 2) 的值是 6 1.2、枚举索引 my_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] for row_index, row_list in enumerate(my_list): # 使用 enumerate 遍历行 for col_index, value in enumerate(row_list): # 使用 enumerate 遍历列 print(f"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88dbe7bfb3e69720f13df834bf2be2c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70dfc5b904a3d29aa52b62c299b78f3d/" rel="bookmark">
			【Web】一张动图告诉你，输入网址之后，发生了什么事情？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		让我们一步一步地来看这个过程。
步骤1： 用户在浏览器中输入一个URL（比如www.csdn.net），然后按下回车键。首先，我们需要将这个URL转换成一个IP地址。通常，这个映射关系会被存储在缓存中，因此浏览器会在多个缓存层中查找IP地址：浏览器缓存、操作系统缓存、本地缓存和ISP（互联网服务提供商）缓存。如果浏览器在缓存中找不到这个映射关系，它会请求DNS（域名系统）解析器来解析这个URL。
步骤2： 如果IP地址在任何缓存中都找不到，浏览器会去DNS服务器执行递归式的DNS查找，直到找到IP地址为止。
步骤3： 现在我们有了服务器的IP地址，浏览器会向服务器发送一个HTTP请求。为了安全访问服务器资源，我们应该始终使用HTTPS。首先，它通过TCP的三次握手与服务器建立TCP连接。然后，它将公钥发送给客户端。客户端使用公钥来加密会话密钥并发送给服务器。服务器使用私钥来解密会话密钥。现在，客户端和服务器可以使用会话密钥来交换加密数据。
步骤4： 服务器处理请求并发送响应。对于成功的响应，状态码是200。响应分为3个部分：HTML、CSS和Javascript。浏览器解析HTML并生成DOM树。它还解析CSS并生成CSSOM树。然后它将DOM树和CSSOM树合并成渲染树。浏览器渲染内容并显示给用户。
这个过程涉及许多复杂的技术，但它让你能够在浏览器中轻松访问网页。无论你是在搜索信息、观看视频还是购物，这个过程都在背后默默运行，使互联网成为可能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e32bcc651fb3d9a1f84bc8f056e7ddc0/" rel="bookmark">
			uniapp 之 图片 视频 文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;view class="" style="padding: 24rpx 0"&gt; &lt;text&gt;相关资料 &lt;text class="fs-26 color-666"&gt;（图片、视频、文档不超过9个）&lt;/text&gt; &lt;/text&gt; &lt;view class="flex align-center" style="margin-top: 17rpx;"&gt; &lt;u-upload accept="all" :fileList="fileList1" @afterRead="afterRead" @delete="deletePic" name="1" multiple :maxCount="9"&gt; &lt;/u-upload&gt; &lt;/view&gt; &lt;/view&gt; submit() { if (this.fileList1.length) { let urls = []; this.fileList1.forEach(el =&gt; { urls.push({ type: el.types, url: el.url, }) }); this.info.pic = JSON.stringify(urls); } uni.showModal({ title: '', content: '确认提交？', success: res =&gt; { if (res.confirm) { // 创建订单 this.$http({ url: "/api", data: this.info, }).then(res1 =&gt; { uni.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e32bcc651fb3d9a1f84bc8f056e7ddc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a1277552462a5b6c40b2972cdf03be6/" rel="bookmark">
			multiplicity连接出现灰色解决方法（一套键鼠控制多台电脑）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果你有多台电脑，鼠标在不同电脑之间切换会很麻烦，需要手动不停地插拔键盘，如果多台设备能够共用一套键盘鼠标，能够大大提高效率，避免不必要的负担，解决方法有两个：
购买 对拷线：该方法不推荐，因为市面上品质层次不齐；如果两台电脑主机之间通过对拷线互联，且其中一台电脑采用了分屏（一台主机连接了两个显示器），可能会存在问题，可以去尝试一下。使用软件实现多设备共用一套键盘鼠标 multiplicity：可以拖动文件，支持多台设备，对两台window比较好，能够将一台电脑上的文件拖到另一台电脑上Synergy：不能拖动文件，但是支持不同系统之间的设备操作，比如linux系统、windows、macos系统之间操作sharemouse（没用过，自行尝试） 由于看重可以拖动文件的功能，我推荐使用 multiplicity，但是在安装使用的过程中出现问题，这里写写我自己的解决方法：
场景：我有两台电脑，一台台式机，一台笔记本，台式机激活了multiplicity，笔记本没有激活，我一般是台式机用作最主要的设备，下面我就用主机表示台式机，副机表示笔记本，防止出现问题
注意：这个过程并不是完全按照官方方法来的，官方的方法，我也测试了，也没有解决我的问题，然后自己摸索的方法，仅供参考，有些步骤可能是不需要的
问题重述：multiplicity连接出现灰色，如图GASDSAF副机的灰色一样
解决步骤：
我的主机和副机连接的是同一个网络，都是公用网络，如下： 在主机中通过win+R打开运行，并输入cmd打开终端 然后通过命令ipconfig查看副机的 ip 地址，有些是局域网的地址，是192.168.xxx.xxx。 在主机上同样重复 2 步骤打开 cmd，在 cmd 终端中输入ping 10.100.xxx.xxx，看看能否 ping 通，如果 ping 通，是如下图： 如果 ping 不通，分别打开主机和副机的设置-&gt;网络和Internet-&gt;高级共享设置，然后把所有选项都勾选上 打开主机和副机的控制面板-&gt;Windows Defender-&gt;高级设置-&gt;入站规则，然后分别双击文件和打印机共享（回显请求—ICMPv4—In）修改属性，选择作用域可以看到远程IP地址下有两个选项，选择任何IP地址，点击确定。注意，三个文件和打印机共享（回显请求—ICMPv4—In）都需要修改。 然后再重复步骤 2、3、4查看是否 ping 通，如果可以。则设置完毕，将主机 multiplicity 软件中的副机设备信息删除，然后在主机 multiplicity 软件中通过如下方式添加副机 打开副机的防火墙，选择防火墙和网络保护-&gt;允许应用通过防火墙。后面步骤8-13都是在副机上操作。 然后在新的窗口中选择允许其他应用 然后选择浏览 如下图所示，选择框中的程序，然后打开 然后点击添加 勾选步骤12中所有添加程序的专用和公用网络 最终在主机中可以看到如下图所示连接成功。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcd5d9e2832c16bf6970b6447e07cc68/" rel="bookmark">
			JS学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. CSS 1.1 文档流 - 所有的元素默认情况下都是在文档流中存在的
- 文档流是网页的最底层
- 元素在文档流中的特点：
- 块元素
1.默认宽度是父元素的全部
2.默认高度被内容（子元素）撑开
3.在页面中自上而下垂直排列
- 内联元素
1.默认高度和宽度都被内容撑开
2.在页面中自左向右水平排列，如果一行不足以容下所有的元素
则换到下一行继续从左向右
1.2 浮动 使用float来设置元素的浮动
- 可选值：
none 默认值，元素不浮动，就在文档流中
left 元素向页面的左侧浮动
right 元素向页面的右侧浮动
- 浮动特点：
1.元素设置浮动以后，会完全脱离文档流，并向页面的左上或右上浮动。
直到遇到父元素的边框或其他的父元素时则停止浮动。
2.如果浮动元素上边是一个没有浮动的块元素，元素不会超过该块元素。
3.浮动元素的浮动位置不能超过他上边浮动的兄弟元素，最多一边齐
4.浮动元素不会覆盖文字，文字会围绕在浮动元素的周围，所以可以通过浮动来实现文字环绕图片的效果。
- 浮动以后元素会完全脱离文档流，脱离文档流以后元素会具有如下特点：
1.块元素不独占一行
2.块元素的宽度和高度都被内容撑开
3.元素不在文档流占用位置
4.内联元素会变成块元素
- 高度塌陷
- 在文档流中元素的高度默认被子元素撑开，当子元素浮动时，子元素会脱离文档流，
此时将不能撑起父元素的高度，会导致父元素的高度塌陷。父元素高度塌陷会导致其他元素的位置上移，导致页面的布局混乱。
- 可以通过开启元素的BFC来处理高度塌陷的问题。
- BFC叫做Block Formatting Context
- 它是一个隐含属性，默认情况是关闭，当开启以后元素会具有如下的特性：
1.父元素的垂直外边距不会和子元素重叠
2.开启BFC的元素不会被浮动元素覆盖
3.父元素可以包含浮动的子元素
- 开启BFC的方式很多：
1.设置元素浮动
2.设置元素绝对定位
3.设置元素为inline-block
4.将元素的overflow设置为一个非默认值
- 一般我们采取副作用比较小的方式
overflow:hidden;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcd5d9e2832c16bf6970b6447e07cc68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96bc478460f3a29f5247982066390b7e/" rel="bookmark">
			JVM源码剖析之registerNatives方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
版本信息：
写在前面：
源码论证：
总结：
版本信息： jdk版本：jdk8u40
写在前面： 在Java类库中很多类都有一个registerNatives的native方法，并且写在static静态代码块中进行初始化调用，有不少的读者应该会对这个方法感兴趣，但是此方法是一个native方法，让不少的读者望而却步，所以笔者写在这一篇关于registerNatives方法的文章～
要真正弄懂registerNatives方法非常的复杂，因为你需要明白 C/C++ 的执行和动态链接库的原理、以及JVM对于动态链接库的封装处理、以及Java语言作为解释性语言JVM的解释器引擎如何对其做处理、以及JVM对于类加载的一个过程，他是如何链接native方法的～
这并不是在劝退各位读者，而是让读者有一个对知识的认知。当然，笔者认为高级的封装是有他的意义存在，屏蔽掉底层的各种复杂的实现。所以笔者也会尽量用通俗易懂的方式介绍registerNatives方法
源码论证： 首先需要说明白registerNatives这个native方法存在的意义：把类中其他native方法的实现映射到JVM虚拟机中内部的方法（native方法的实现是c/c++语言，而JVM也是c++语言实现，所以是完成一个其他native方法的映射）
在JVM的实现Hotspot源码中，一般情况下native层面的源码文件命名是跟类名一致，比如拿Thread.java 类来说，在Hotspot中他的native层面文件就是 Thread.c 。 正好Thread类中也有registerNatives，接下来我们就看到Thread中registerNatives方法的native层面源码实现
/src/share/native/java/lang/Thread.c 文件中
typedef struct { char *name; char *signature; void *fnPtr; } JNINativeMethod; static JNINativeMethod methods[] = { {"start0", "()V", (void *)&amp;JVM_StartThread}, {"stop0", "(" OBJ ")V", (void *)&amp;JVM_StopThread}, {"isAlive", "()Z", (void *)&amp;JVM_IsThreadAlive}, {"suspend0", "()V", (void *)&amp;JVM_SuspendThread}, {"resume0", "()V", (void *)&amp;JVM_ResumeThread}, {"setPriority0", "(I)V", (void *)&amp;JVM_SetThreadPriority}, {"yield", "()V", (void *)&amp;JVM_Yield}, {"sleep", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96bc478460f3a29f5247982066390b7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd59e737c0f98ac187d1e2af7f20f76c/" rel="bookmark">
			网络安全学习之信息泄露
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景以及泄露途径 通常我们会对数据进行备份，比如我们在发布网站的时候会对将要替换的版本进行备份。我们在对重要文件进行修改的时候我们也需要进行备份，如果我们对备份或缓存的文件或信息为做好管理，很容易就导致我们的敏感信息泄露。
那么在网络安全中信息泄露的途径特别多，就包括：网站源码、bak文件 、vim缓存、.DS_Store等等
常见的网站信息泄露就比如：当开发人员在线上环境中对源代码进行了备份操作，开发人员图方便将备份文件放在了 web 目录下，就会引起网站源码泄露。
二、泄露信息发现 我们又怎么去知道哪些信息泄露了呢？通常我们可以使用一些工具：
2.1 对于网站信息扫描 对于网站信息，我们可以使用dirsearch工具
python3 dirsearch.py -u url -e * 就可以对特定url网站进行目录扫描，找出一些隐藏的目录
2.2 对于版本管理git信息扫描 对于我们常用的版本管理工具git，我们可以使用GitHacker 探测是否有隐藏信息
python3 GitHacker.py url/.git 常见的git查看隐藏信息的命令有：
git log 查看git提交信息
git reset --hard git提交的id’
git stash pop stash 是git的堆栈区
2.3 对于版本管理svn SVN泄露 会有一个.svn文件夹
使用dirsearch扫描
git clone https://github.com/kost/dvcs-ripper
使用 dvcs-ripper
脚本： ./rip-svn.pl -v -u url/.svn/
2.4 对于分布式版本工具hg hg泄露，hg是一个分布式版本控制工具，Mercurial分布式版本控制系统，主程序名字是hg，所以简称hg，它是基于python的
./rip-hg.pl -v -u url/.hg
2.5 对于文件隐藏信息 查看文件隐藏泄漏的信息，除了可以直接看文档内容之外，我们还可以借助foremost工具，这是查看文件中是否隐藏了其他文件的方法
三、防范未然 从第二章，我们可得出，信息泄露分为无意和故意两种情况，无意即不小心，由于使用的工具存在缓存，或者这个工具记录了提交信息。另一种就是有意，这是出于某种目的将信息传递出去，比如在一个word文档中隐藏了另外一个资源。那么我们在防止信息泄露过程中，一方面，要规范工具使用流程和使用要求，避免由于工具导致信息泄露。另外一方面，我们要加强对人员的教育，规范操作和信息追踪，以防止人员故意将信息泄露。
四、总结 安全和防护，就像矛和盾的较量，“道高一尺魔高一丈”，是完全没有终点的。今天分享了信息泄露的部分途径，这些途径泄露信息是比较隐蔽的，需要一定的技术能力才能进行追踪。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d95326b5a98c83e23ebc942fb9c955d0/" rel="bookmark">
			【自测试】gtest学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 官网：https://google.github.io/googletest/primer.html
SetUpTestCase和TearDownTestCase已经被弃用了，建议使用SetUpTestSuite和TearDownTestSuite。这两个函数分别在第一个测试用例执行之前和最后一个用例执行完毕之后会被调用。SetUp和TearDown在单独的每个用例执行前、后执行。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/074909415d80f7e53c2571b59d25594e/" rel="bookmark">
			全国地铁城市数据分析（python实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全国地铁城市数据分析（数据清洗+可视化分析)
一确定问题：
由题看出其属于开放问题，没有明确的目的（即可认为无题），其重点是让人发现问题（比如过程中分析时发现数据有哪些实在的问题就可以拿出来单独分析），了解数据处理，数据可视化
但是可以通过该问题比较系统的了解数据分析的过程（实际上这里重点是数据分析中的评估部分）
1.获取数据-采用爬虫访问百度地铁地图获取数据的方法
request+xpath爬虫:
得到url-http://map.amap.com/subway/index.html?&amp;1100发出请求得到响应对象-request模块获取响应对象数据-使用text函数直接获取网页文本。有些数据为json字符串的形式，需要用到json转化解析数据-使用xpath持久化存储-在数据分析中一般将数据保存为csv格式,跟利于处理 在过程中使用了time模块-sleep函数防止网站宕机
主要的3个函数
#3个函数 headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3947.100 Safari/537.36 2345Explorer/10.11.0.20694'} def get_city():#用于得到城市ID和城市名称 url = 'http://map.amap.com/subway/index.html?&amp;1100' time.sleep(2) res = requests.get(url=url, headers=headers) res.raise_for_status() res.encoding = res.apparent_encoding html = res.text Html = etree.HTML(html) # 城市列表 res1 = Html.xpath('/html/body/div[1]/div[1]/div[1]/div[2]/div[1]/a') res2 = Html.xpath('/html/body/div[1]/div[1]/div[1]/div[2]/div[2]/div[2]/a') for i in res1: # 城市ID值 ID = ''.join(i.xpath('.//@id')) # 属性需要加上双斜杠 # 城市拼音名 cityname = ''.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/074909415d80f7e53c2571b59d25594e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2f968c93c6d3676e9d1f771de6a468a/" rel="bookmark">
			疯狂的机器学习实战-银行营销预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习实战-银行营销预测 问题：
数据集：
链接：https://pan.baidu.com/s/1TUOLr8jFbT38p_iUh1iBsQ
提取码：1234
银行营销数据集 这些数据与葡萄牙银行机构的直接营销活动有关。这些直接营销活动是以电话为基础的。通常来说，银行机构的客服人员至少需要联系一次客户来得知客户是否将认购银行的产品（定期存款）。因此，与该数据集对应的任务是分类任务，而分类目标是预测客户是(yes)否(no)认购定期存款（变量y）。 数据集包含四个csv文件: 1) bank-additional-full.csv: 包含所有的样例(41188个)和所有的特征输入(20个)，根据时间排序（从2008年5月到2010年9月）； 2) bank-additional.csv: 从1)中随机选出10%的样例(4119个)； 3) bank-full.csv: 包含所有的样例(41188个)和17个特征输入，根据时间排序。（该数据集是更老的版本，特征输入较少）； 4) bank.csv: 从3)中随机选出10%的样例(4119个)。 数据集的输入变量是20个特征量，分为数值变量（numeric）和分类（categorical）变量， 输出变量为y，即客户是否已经认购定期存款(binary: "yes", "no") 策略：使用四个模型先粗测当前预测准确度，对其中准确度较高的进一步调优
算法简单介绍：
1.KNN算法
通过以某个数据为中心：
 分析离其最近的K个邻居的类别；
 获得该数据可能的类别
 如果取K=1
 待分类样本的类别就是最近邻居的类
2.SVM算法
SVM(Support Vector Machine)中文名为支持向量机，是常见的一种判别方法。在机器学习领域，是一个有监督的学习模型，通常用来进行模式识别、分类以及回归分析。
二维上，就是找一分割线W•X+b =0把两类分开，区分两个类别并且能使间隔（margin）最大
3.AdaBoost算法
该算法其实是一个简单的弱分类算法提升过程，这个过程通过不断的训练，可以提高对数据的分类能力。1. 先通过对N个训练样本的学习得到第一个弱分类器；
2. 将分错的样本和其他的新数据一起构成一个新的N个的训练样本，通过对这个样本的学习得到第二个弱分类器 ；
3. 将1和2都分错了的样本加上其他的新样本构成另一个新的N个的训练样本，通过对这个样本的学习得到第三个弱分类器；
4. 最后，将各个训练得到的弱分类器组合成强分类器。误差率低的弱分类器在最终分类器中占的比例较大，反之较小。
4.随机森林算法
随机森林顾名思义，是用随机的方式建立一个森林，森林里面有很多的决策树组成，随机森林的每一棵决策树之间是没有关联的。在得到森林之后，当有一个新的输入样本进入的时候，就让森林中的每一棵决策树分别进行一下判断，看看这个样本应该属于哪一类（对于分类算法），然后看看哪一类被选择最多，就预测这个样本为那一类。
完整代码见最后：
1.导入数据 #训练集和测试集的导入 trainfile = pd.read_csv(r'.\bank-additional-full.csv', sep=';') testfile = pd.read_csv(r'.\bank-additional.csv', sep=';') 2.数据处理： 缺失值处理： 1.判断有无显示的缺失值（为空值的部分） 2.判断有无隐含缺失值（分析发现存在很多unknown项） 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2f968c93c6d3676e9d1f771de6a468a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/603a6b20537af298f3f4ce8238f05b36/" rel="bookmark">
			未来的云平台设想（非知识分享，纯属一个目前的“白日梦”）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目前云平台的出现，实际上免除了许多设备性能不足的问题，使得部分设备在不具备相应的性能模块也能运行性能需求高的程序，但是由于带宽和客户端到服务器的节点之间的通信状态，其实体验并不是非常完美。
可以设想，未来的一个改进方向是优化数据之间的传输。
那么，未来的优化方向可能会出现什么呢？笔者在此做一次大胆的预测：
传输优化 参考CPU现在的cache概念，作为数据传输的中间节点，如交换机或路由器等，是否存在可以把其中的设备，以RAM的模式，作为数据传输的缓存区域，且虽然玩家数据是保存在数据库的，但是程序的公有函数库是通用的，可以将公有部分按需按比例保存在这附近，甚至，开发商和运营商合作，直接在ISP交汇处建立存储器，使公有函数的调用路径更短。 服务器分布式架构 目前现有的分布式架构，简单而言，可以理解为功能模块单独作为一个服务设备来使用，那为何不能根据使用的频率，将分布式的服务器放在离用户更近的地方，但是当然，凭空造一个机房是不现实的，但是，并不代表不能利用VPN，来为数据传输进行优化呀~ 开发环境的整合 云平台现在是根据不同系统开发出对应的客户端，那以后设备硬件得到了提升，可以设想，会不会以后云是统一建立在自家企业的虚拟环境上，开发团队只需针对我方公司的系统环境进行代码编写即可，而我方公司的云平台则着重本虚拟环境（即虚拟机）在不同系统环境上的兼容或者优化上面，而用户仅需同意下载一个客户端即可。 用户请求封装读取 用户之间的传输的数据是海量的，那么是否能参考Qinq的做法，把用户的请求先封装一个应用头部，将其请求先做一个大致区分，让服务器在读取用户请求时，先了解其请求的分类，从而发向自身的不同功能区域，尽可能减少用户等待的时间。 私有协议的建立 为了方便用户与企业之间的交流，可能未来会出现私有协议这一说法，并不是单纯指网络传输，而是其他与本企业所提供服务相关的协议报文，这种报文更看重功能性，并不需要其他行业的工作者知晓，因此不作为公有协议扩展，但是和本企业服务有关的行业或公司可以共同利用该私有协议优化工作。且建立并非一个非常复杂的过程，高级网络设备中有UI界面引导用户建立自己所需的功能协议，而网络设备公司，为确保不同厂商之间都能兼容，可能只是把协议作为应用层报文的一部分，或则应用层封装，利用路由协议如OSPF，ISIS等，帮助协议和节点之间能正常运作。 设备需求的进一步降低 目前，虽然使用云平台能使许多性能不足的产品也能满足运行需求，但有没有可能，以后云平台的完善，是使得我们手上性能极度不足的产品，仅作为一个输出设备，其本身处理器CPU或GPU所承担的业务量，在数据传输过来的时候已经完成了，可能只是使用了内存或CPU的高级缓存，让程序运行起来罢了。 路由设备作为分布式服务的母服务器 路由设备由于硬件上的扩展，其本身除分发路由外，还能兼任一个大型的服务器，当然由于服务的厂商众多，其内部是利用超融合等概念，让厂商的功能服务器都可以就近搭载到它上面，且为了方便不同厂商的使用，还根据任务热度，从其所连的数据库中替换目前无响应的厂商模块，从而动态切换现在搭载的厂商服务器。 结语 科技飞快发展，在此设想未来也不一定异想天开，多多积累，也许我能为此添一块砖。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0c2058faf396ea6ebefb1edeeaa010a/" rel="bookmark">
			ets:tab2list的不足之处与替代方法，以及gen_server中使用ets的优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ets:tab2list 是 Erlang/OTP 中的一个函数，用于将 ETS（Erlang Term Storage）表转换为列表。ETS 是 Erlang 中的一个内建数据库，允许开发者在内存中存储大量数据。
一、ets:tab2list 的不足之处： 性能问题：对于非常大的 ETS 表，ets:tab2list 可能会消耗大量的内存和时间，因为它一次性地返回整个表的内容。这可能导致长时间的阻塞和高内存使用。不适合生产环境：在生产环境中，频繁地将整个 ETS 表转换为列表可能会导致性能瓶颈。 二、ets:tab2list 替代方法： 1、迭代查询：使用 ets:first/1 和 ets:next/2 函数进行迭代查询，而不是一次性获取整个表的内容。这样可以按需获取数据，降低内存消耗，代码如下：
iterate_ets(Table) -&gt; iterate_ets(Table, ets:first(Table)). iterate_ets(_Table, '$end_of_table') -&gt; done; iterate_ets(Table, Key) -&gt; [{Key, Value}] = ets:lookup(Table, Key), io:format("Key: ~p, Value: ~p~n", [Key, Value]), iterate_ets(Table, ets:next(Table, Key)). 使用这个函数，你可以按需迭代 ETS 表的内容，而不是一次性加载到内存中。
举例：
-module(ets_iterate_example). -compile(export_all). start() -&gt; Tab = ets:new(test_tab, [set, public]), ets:insert(Tab, {1, "one"}), ets:insert(Tab, {2, "two"}), ets:insert(Tab, {3, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0c2058faf396ea6ebefb1edeeaa010a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1b33fa26f14b5acc0af658b1a151c96/" rel="bookmark">
			（Linux内核源码分析）Linux 内核无线子系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux内核源码分析（内存调优/文件系统/进程管理/设备驱动/网络协议栈）
1.全局概览 在开始探索 Linux 无线具体细节之前，让我们先来把握一下 Linux 无线子系统整体结构。如图1,展示了 Linux 无线子系统各个模块之间的抽象关系。
图示中的虚线内展示的是内核空间的情况。用户空间的程序运行在最上层，而硬件相关的设备则在最下面。
图示中左边为以太网设备，右边为 WiFi 设备。
正如图中看到的一样，存在着两种 WiFi 设备，具体是哪一类要看 IEEE802.11 标准的 MLME 如何实现。
如果直接通过硬件实现，那么设备就是硬 MAC （full MAC）设备;如果通过软件的方式实现，那么设备就是软 MAC （soft MAC）设备。现阶段大部分无线设备都是软件实现的软 MAC 设备。
通常我们把 Linux 内核无线子系统看成两大块： cfg80211 和 mac80211 ，它们连通内核其他模块和用户空间的应用程序。
特别指出， cfg80211 在内核空间提供配置管理服务，内核与应用层通过 nl80211 实现配置管理接口。需要记住的是，
硬 MAC 设备和软 MAC 设备都需要 cfg80211 才能工作。而 mac80211 只是一个驱动 API ，它只支持软件实现的软 MAC 设备。
接下来，我们主要关注软 MAC 设备。
Linux 内核无线子系统统一各种 WiFi 设备，并处理 OSI 模型中最底层的 MAC 、 PHY 两层。
若进一步划分， MAC 层可以分为 MAC 高层和 MAC 底层。前者负责管理 MAC 层无线网络的探测发现、身份认证、关联等;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1b33fa26f14b5acc0af658b1a151c96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43bdb30bf049d528aedbbfb261b57b38/" rel="bookmark">
			关于碰撞试验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要参数：
冲击与碰撞试验的主要参数及调整方法 - 百度文库
碰撞试验的技术指标包括：峰值加速度、脉冲持续时间、速度变化量（半正弦波）、每方向碰撞次数。
加速度：冲击的强度，单位为g；一般为30~500g，典型为30g、50g、100g；
脉冲宽度：冲击持续时间，单位为ms；一般为2~18ms，典型为6ms、11ms；
冲击波形：半正弦波、梯形波、锯齿波；
冲击次数：一般测试方向为6轴（±X、±Y、±Z）。
立讯检测 | 广州可靠性——机械冲击试验_加速度100g冲击试验-CSDN博客
机械冲击试验方法有哪几种 - 知乎
机械冲击实验 - 知乎
冲击、碰撞、振动的区别？
冲击测试和碰撞测试的区别 - 知乎
冲击与碰撞试验技术的概述 - 知乎
加速度 脉冲持续时间 碰撞试验的脉冲持续时间指的是碰撞过程中物体之间的接触时间，也称为接触时间。其具体持续时间取决于碰撞的速度、物体的形状、材料和弹性等因素。在实际测试中，脉冲持续时间一般在几毫秒到几十毫秒不等。
碰撞次数 脉冲重复频率 脉冲波形 GB／T 2423.6电工《电子产品环境试验》第2部分中试验方法的试验Eb和导则：碰撞 GB／T 2423.6-1995 电工电子产品环境试验 第2部分：试验方法 试验Eb和导则： 碰撞_17bzw.cn - 道客巴巴 (doc88.com)
《电工电子产品环境试验 第2部分：试验方法 第6部分：碰撞试验》（GB/T 2423.6）
上面这个目前已经被废止，下面这个是现行的国家标准
GB/T 2423.5-2019环境试验 第2部分:试验方法 试验Ea和导则:冲击 GB/T 2423.5-2019 环境试验 第2部分：试验方法 试验Ea和导则：冲击 - 道客巴巴 (doc88.com)
gbt2423.43-2008 电工电子产品环境试验 第2部分_ 试验方法 振动、冲击和类似动力学试验样品的安装
【国家标准】 GB T 2423.43-2008 电工电子产品环境试验 第2部分_ 试验方法 振动、冲击和类似动力学试验样品的安装 标准 - 道客巴巴 (doc88.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43bdb30bf049d528aedbbfb261b57b38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/871c34317b68dbfb5ef98c646f0d51d4/" rel="bookmark">
			【S32DS报错】-4-无法识别到PEMicro驱动，提示Error in services launch sequence PEmicro GDB Launch Failure 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 Error错误提示
2 Error错误原因，以及如何消除Error错误
2.1 下载并安装PEMicro驱动
结尾
【S32K3_MCAL从入门到精通】合集：
S32K3_MCAL从入门到精通https://blog.csdn.net/qfmzhu/category_12519033.html
1 Error错误提示 使用S32DS+PEMicro下载S32K3程序，在Dedug Configurations…,并单击Debug，弹出如下错误：
‘Launching S32K312_LED_Debug_PLASH_PNE' has encountered a problem.
Error in services launch sequence
PEmicro GDB Launch Failure : Unable to auto-detect debug hardware. Please specify on the command-line. If running from Eclipse, check the launch Debug Configuration settings. Halting.
2 Error错误原因，以及如何消除Error错误 错误原因：电脑本地没有安装PEMicro驱动，或者PEMicro驱动不支持该S32k3 MCU芯片，需要更新PEMicro驱动。
在Create，manage，and run confugurations对话框PEMicro Debugger子页的PEMicro Interface Settings中的Port选项无法识别到PE Multilink硬件。
注意：Software Registration提示Please register your software to remove this message。单击Register now，注册一下邮箱即可消除。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/871c34317b68dbfb5ef98c646f0d51d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb869d978db3561db3eb35bbb228e8d0/" rel="bookmark">
			【S32K3环境搭建】-0.5-使用PEmicro Multilink烧录调试程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【S32K3_MCAL从入门到精通】合集：
S32K3_MCAL从入门到精通https://blog.csdn.net/qfmzhu/category_12519033.html
导入一个编译没有报错的S32K312工程。接着在菜单栏中，依次选择Debug下拉箭头 -- &gt; Debug Configuration；
在弹出的Create，manage，and run confugurations对话框，选中GDB PEMicro Interface Debugging，鼠标右键在其上下文中选择New Configuration;
为其命名FreeRTOS_Toggle_Led_Example_S32K312_Debug_FLASH_PNE，以及参考Main子页的设置；
接着在PEMicro Debugger子页中，设置下图信息后，单击Debug按钮，开始烧录调试程序。
单击Resume按钮运行程序。
获取更多“汽车电子资讯”和“工具链使用”，
请关注CSDN博客“汽车电子助手”，做您的好助手。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f76c2b2cb0124808955a3dde0417ec4/" rel="bookmark">
			从理论分析高可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言事前技术层面分布式架构和负载均衡：数据备份与故障转移：故障转移分为两种模式，各有优劣：自动化部署和扩展： 业务层面灾难恢复计划：安全性措施： 事中技术层面 事后技术层面事故分析和改进： 业务层面用户通知和沟通：培训和知识共享： 口语化总结写在最后 前言 高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，通常是指通过设计减少系统不能提供服务的时间。很多公司的高可用目标是4个9，也就是99.99%，这就意味着，系统的年停机时间为8.76个小时。为了保证系统的高可用，我们可以从事前、事中和事后三个时间阶段，从技术和业务两个层面来解决问题。
事前 技术层面 分布式架构和负载均衡： 采用分布式和冗余架构，避免单点故障。
硬件冗余是指在关键的硬件组件上使用多个备份，以防止单个设备的故障导致整个系统瘫痪。例如，在数据中心中，可能会部署多台服务器、多个网络路径、多个电源供应等，确保任何一个组件的失败都不会影响整体服务。硬件冗余通常包括但不限于服务器、存储设备、网络设备和电源。也就是所谓的多活架构，比如同城双活、两地三中心、异地多活
软件冗余则是通过部署多个软件实例或副本来提高系统的可用性。在一个高可用性的环境中，关键服务将在多个服务器或节点上运行，确保即使某个节点出现故障，其他节点仍能继续提供服务。这种做法在微服务架构中尤其常见，其中每个服务可能有多个实例运行在不同的服务器或容器中。
使用负载均衡器平衡流量，确保各个节点的负载均匀。负载均衡是一种分配网络流量和请求到多个服务器或资源的技术。它的目的是优化资源使用、最大化吞吐量、减少响应时间，并避免任何单一资源过载。负载均衡器可以是软件或硬件设备，它在接收到请求时，根据预设的规则将流量分配到后端的服务器群。这些规则可以基于多种因素，如服务器的当前负载、健康状态或地理位置。通过负载均衡，可以在多个服务器之间分散工作负载，增加系统的可用性和可靠性。
硬件负载：通过硬件来进行分流，常见的硬件有比较昂贵的F5和Array等商用的负载均衡器，它的优点就是有专业的维护团队来对这些服务进行维护、缺点就是花销太大，一般在互联网系统较少使用，主要用于金融行业的核心服务；
软件负载：通过软件实现分流，如Nginx/LVS/HAProxy的基于Linux的开源免费的负载均衡软件，这些都是通过软件级别来实现，费用非常低廉。按所处OSI模型的工作层级，可分为7层负载和4层负载。7层负载，是指工作在网络7层，基于URL等应用层信息的负载均衡，主要代表有Nginx。4层负载，就是基于IP+端口的负载均衡，主要代表有LVS。
数据备份与故障转移： 其核心思想是对分布式系统中的节点进行备份，备份会分为冷备和热备。通常将数据中心分为主备两种，主提供业务服务，备不提供服务仅作备份和故障转移。
冷备也就是定时备份，主推或者备拉去备份数据。
热备，也就是对主数据中心做实时性的备份，以便在主数据中心出现故障时进行转移。这时候主备会有同步和异步两种数据复制方式，但因为同步会造成性能的损失，所以通常使用异步，这种情况下会造成一定程度的数据延迟问题。
故障转移分为两种模式，各有优劣： 主动-被动模式下，一台服务器（或服务实例）作为主动节点运行，处理所有请求，而另一台或多台服务器作为被动节点，处于待命状态。当主动节点发生故障时，系统会自动切换到被动节点，后者接管服务，从而减少系统停机时间。这种模式的优点是简单明了，但缺点是备用资源在大部分时间内处于闲置状态。
主动-主动模式中，所有服务器都处于活动状态并处理请求。这种模式提高了资源的利用率，但同时也增加了管理的复杂性。在这种设置中，如果一个节点失败，其他节点需要能够接管其工作负载，而不影响总体性能。这通常需要更复杂的负载均衡和同步机制。
自动化部署和扩展： 自动化是实现高可用性的关键。这包括自动故障检测和恢复、自动扩展和收缩资源以适应负载变化、自动化部署和配置管理。通过自动化，可以减少人为错误，提高运维效率。
监控和警报系统：
有效的监控系统可以实时跟踪应用程序和基础设施的健康状况。这包括监控服务器的性能指标（如CPU使用率、内存使用、网络流量）和应用级指标（如响应时间、错误率）。监控可以帮助及时发现问题并采取措施，防止小问题演变成大问题。
收集和分析应用日志，及时发现潜在问题，快速响应和解决。
设置自动化的警报系统，及时通知团队关于潜在的问题。
业务层面 灾难恢复计划： 制定灾难恢复计划，包括备份恢复、系统迁移和紧急操作步骤，也包括、团队的紧急联系人和步骤，以迅速应对突发事件。
定期对团队成员进行培训及测试灾难恢复计划，确保在实际情况中有效。
安全性措施： 实施严格的身份验证和授权机制，确保只有授权用户能够访问敏感信息以及变更实例。
事中 技术层面 自动化故障检测和恢复：
检查事前配置的自动故障转移策略是否生效，如果不生效启用灾备恢复计划。常规情况下通常需要实施快速版本回滚，最大限度降低损失。
实时监控和日志分析：
实时监控系统的性能，追踪实时指标，避免后续持续发生问题。
通过实时警报系统，及时通知团队关于潜在问题，以便快速响应。
事后 技术层面 事故分析和改进： 进行事故分析，深入了解故障原因。
采取措施，防止类似问题再次发生，进行系统改进。
业务层面 用户通知和沟通： 向用户提供详细的事故报告，解释发生的问题和采取的措施。
收集用户反馈，用于改进系统的用户体验。
培训和知识共享： 将事后的教训纳入培训计划，确保团队学到经验教训。
实施知识共享机制，使团队能够从彼此的经验中学习。
口语化总结 对于保证系统的高可用，我们可以通过事前、事中和事后三个时间阶段以及技术和业务两个层面综合进行处理。事前的准备是最多的，因为我们要尽最大努力去保证不出现问题。技术层面有几点可以做，一是我们可以采用分布式架构，做好冗余，软件方面做好集群部署，硬件方面做好多活策略。二是做好数据备份和自动故障转移。三是做好自动化部署和弹性伸缩，我现在公司是自研了一个DevOps平台，实现了自动化的CICD，暂时没有资源弹性的伸缩，可以手动修改应用节点数量，异地多活策略是在北京福州还有新加坡搭建了服务器。四是监控和告警，我现在公司是用的prometheus+grafana，通过K8s提供的探针来监控服务器或者部分应用的关键指标，配合告警及时通知相关负责人处理。业务层面有两点，一是组建一个紧急响应团队，或者对每个项目的负责人进行专门的灾备培训，定期测试灾备计划的有效性。二是严控操作权限和外部依赖，我现在公司基于自研的开发服务平台，控制权限只有部分角色允许进行服务变更，对于MySQLRedis一类的中间件也只提供固定配置的申请资源。
事中的时候自然是能进行自动故障转移最好，不行的话立刻启动灾备计划。如果是服务变更引起的问题，立刻回滚版本，先保证服务稳定运行。同时也要关注监控指标，避免问题反复。事后技术层面上自然是进行事故分析，对故障原因进行复盘，采取一些技术上的措施进行系统改进。业务层面上就是做好经验教训的培训和知识共享，同时对受影响的用户提供详细的事故报告，做好公关，提供补偿，收集用户的反馈，优化用户体验。
写在最后 一个常见的高可用总结，偏理论，在最后的总结部分加上了具体的实践。如果有机会参与或者在某个完善的架构里，我会结合真实的企业级案例进行讲解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bad28eec0e501bac339a858a287e5a16/" rel="bookmark">
			Java并发(十八)----常见线程安全类及实例分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、常见线程安全类 String
Integer
StringBuffer
Random
Vector
Hashtable
java.util.concurrent （JUC）包下的类
这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。
Hashtable table = new Hashtable(); ​ new Thread(()-&gt;{ table.put("key", "value1"); }).start(); ​ new Thread(()-&gt;{ table.put("key", "value2"); }).start(); 注意：
它们的每个方法是原子的
但它们多个方法的组合不是原子的。
1.1 线程安全类方法的组合 分析下面代码是否线程安全？
Hashtable table = new Hashtable(); // 线程1，线程2 if( table.get("key") == null) { table.put("key", value); } 结论是线程不安全
1.2 不可变类线程安全性 String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的
或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安全的呢？
原因为，原值并没有被改变，而是创建了一个新值，其内部的状态没有改变，因此它们的方法都是线程安全的。
例如下面的代码也是同理。
public class Immutable{ private int value = 0; ​ public Immutable(int value){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bad28eec0e501bac339a858a287e5a16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86f849373ad9b6d29bf9ea35411c3734/" rel="bookmark">
			Ubuntu常用命令汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu常用命令汇总 一、系统信息二、Docker1. Docker服务命令2. 查看docker占用磁盘大小 3. 运行容器三、四、五、六、ssh缺失 一、系统信息 # 显示系统内核信息，包括内核版本、操作系统版本和处理器架构等。 uname -a # 显示操作系统的版本信息，包括发行版、发行版号、Codename和描述等。 lsb_release -a # 显示操作系统的版本信息，包括发行版和版本号等。 cat /etc/issue # 显示CPU的信息，包括型号、频率、核心数和缓存大小等。 cat /proc/cpuinfo # 显示内存信息，包括总内存、可用内存和缓存大小等。 cat /proc/meminfo # 显示文件系统的使用情况，包括总空间、已用空间和可用空间等。 df -h # 显示内存使用情况，包括总内存、已用内存和可用内存等。 free -m # 显示磁盘驱动器的信息，包括磁盘大小、分区和挂载点等。 lsblk # 显示所有PCI设备的信息，包括厂商、设备ID和驱动程序等。 lspci # 显示所有USB设备的信息，包括厂商、设备ID和驱动程序等。 lsusb 二、Docker 1. Docker服务命令 #查看docker状态： systemctl status docker #启动docker服务： systemctl start docker #关闭docker服务： systemctl stop docker #重启docker服务： systemctl restart docker 2. 查看docker占用磁盘大小 docker system df docker system df -v 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86f849373ad9b6d29bf9ea35411c3734/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dedb8f058fcdda2346d09b0deba0084c/" rel="bookmark">
			iOS使用CoreText完成txt阅读器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CoreText是一个高效处理字符和字形转换和进行文字排版的框架，API基于C语言。
常见的CoreText类介绍 （1）、CFAttributedStringRef
属性字符串，用于存储需要绘制的文字字符和字符属性
（2）、CTFramesetterRef
framesetter对应的类型是 CTFramesetter，通过CFAttributedStringRef进行初始化，它作为CTFrame对象的生产工厂，负责根据path生产对应的CTFrame；
（3）、CTFrame
CTFrame是可以通过CTFrameDraw函数直接绘制到context上的，当然你可以在绘制之前，操作CTFrame中的CTLine，进行一些参数的微调；
（3）、CTLine
在CTFrame内部是由多个CTLine来组成的，每个CTLine代表一行；可以看做Core Text绘制中的一行的对象 通过它可以获得当前行的line ascent,line descent ,line leading,还可以获得Line下的所有Glyph Runs；
（4）、CTRun
或者叫做 Glyph Run，每个CTLine又是由多个CTRun组成的，每个CTRun代表一组显示风格一致的文本，是一组共享想相同attributes（属性）的字形的集合体；
渲染流程 当我们需要排版时，可以对字符串设置各种格式，生成NSAttributeString；然后用NSAttributeString去创建CTFramesetter类，CTFramesetter会处理排版信息，然后生成排版后的结果CTFrame；CTFrame是一段或者多段文本，每段文本又由多行文字组成，每行的表示为CTLine；CTLine是一行文本，每行文本由多个CTRun组成，CTRun是一小段连续的字形；CTTypeSetter负责上下文相关排版处理，比如说换行，每个CTFrame中都会有一个CTTypeSetter； 他们之间的关系图如下： 总的来说，CTFramesetter是生成CTFrame的工厂类，初始化参数是attributed string，会在内部创建CTTypesetter并进行实际的排版；
CTLine类似每一行的文字，CTRun是一行中具有相同属性的连续字形，比如说“我正在分享阅读器”，就会由三个CTRun组成，分别是“我正在”、“分享”、“阅读器”（因为“分享”两个字加粗了，否则就会是一个CTRun）。
CoreText的使用流程：
使用core text就是有一个要显示的string，然后定义这个string每个部分的样式生成富文本attributedString由富文本生成 CTFramesetterCTFramesetter得到CTFrame使用绘制（CTFrameDraw）CTFrame 关键函数介绍 由富文本字符串得到CTFramesetter CTFramesetterCreateWithAttributedString(att as CFAttributedString) CFAttributedString是NSAttributedString的CF对象，可以直接强转；
CTFramesetter包含了富文本字符串的布局信息和相关属性，供后续的绘制操作使用。最主要的作用就是生成下面的CTFrame。
通过调用 CTFramesetterCreateWithAttributedString 函数，可以将富文本字符串转换为 Core Text 的布局对象，为后续的绘制操作提供所需的文本排版和属性信息。这样，你就可以使用 Core Text 提供的更多功能来自定义文本的布局、字体、颜色等，并实现高度定制化的文本渲染效果。
CTFramesetterRef 对象并不直接进行绘制操作，它只包含了文本布局的信息。要将文本绘制到图形上下文中，还需要使用 CTFrameDraw 函数创建并绘制 CTFrameRef 对象。
生成CTFrame CTFramesetterCreateFrame(framesetter, CFRangeMake(pageStart, 0), path, nil) 使用 CTFramesetterRef 对象、文本范围、路径和其他参数创建一个 CTFrameRef 对象，
CTFrame是排版数据，可直接通过重写View的drawRect方法渲染到页面上
framesetter：上面创建的CTFramesetterRefstringRange：要使用的文本范围，即 CFRange 结构体。 可以通过设置 CFRangeMake 参数来确定要使用的富文本字符串的起始位置和长度如果范围的长度部分设置为0，比如CFRangeMake(location, 0)，则会尽可能的填满CTFrame，将继续添加行，直到文本或空间用完。path：绘制文本的路径，即 CGPathRef 类型对象。 路径定义了文本应该在画布上的布局方式和区域。一般传渲染View的bounds即可frameAttributes：可选的附加属性字典，提供额外的布局控制和属性设置。 计算分页 CTFrameGetVisibleStringRange(frame) CTFrameGetVisibleStringRange 函数的作用是获取给定文本框架（CTFrame）中可见的文本范围。可见的范围是指在当前文本框架大小和路径下实际可见的文本部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dedb8f058fcdda2346d09b0deba0084c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a8dadd52b294002674631f6e01844f0/" rel="bookmark">
			Ghidra设置主题和字体大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Ghidra调整主题和字体大小设置主题和全局字体大小调整反汇编页面字体大小 Ghidra调整主题和字体大小 ghidra默认字体小,默认主题白色伤眼,摸索找到了设置主题和字体的方法
设置主题和全局字体大小 启动ghidra后选择edit&gt;theme&gt;configure
下拉框选择主题,右上角A+和A-可以调整所有字体大小
调整反汇编页面字体大小 上述操作是设置全局字体,不一定合适,在反汇编页面右键选择properties
选择display,点击font选项便可单独设置反汇编页面的字体大小
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6452b224f70a36e93f91e15860e8e122/" rel="bookmark">
			事业单位选岗技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事业单位选岗技巧
下面这些都是不需要笔试直接面试的岗位，一定不要被自己限制的条件所卡死了，一定要灵活，一定要放的开
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25ae6fee43884b87792bfffbfd438572/" rel="bookmark">
			AI工具导航网站（包含写作、翻译、设计、论文润色去重的AI工具集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能工具导航网站集合了国内外各种热门、创意、有趣、前沿的AI工具盒网站，方便用户迅速访问和体验各种AI应用。网站获取方式在文章最后：
一、写作翻译编程设计AI工具集 「AI写作工具」：这些工具可以帮助用户生成或优化各种类型的文本，例如论文、摘要、标题、简历、邮件等。用户可以根据自己的需求选择不同的AI写作工具，输入相关的信息或关键词，然后得到AI生成的文本，或者对自己的文本进行修改和完善。例如，文心一言可以生成一句话的文案或灵感，ChatGPT可以与用户进行智能的对话，Midjourney可以帮助用户写出高质量的英文论文等。
「AI图像工具」：这些工具可以帮助用户生成或编辑各种类型的图像，例如人脸、风景、动物、卡通等。用户可以根据自己的需求选择不同的AI图像工具，输入相关的信息或图片，然后得到AI生成或修改的图像，或者对自己的图像进行调整和美化。例如，This Person Does Not Exist可以生成不存在的人脸，[Deep Dream Generator]可以将图片转换为梦幻般的风格，[Remove.bg]可以自动去除图片的背景等。
「AI音视频工具」：这些工具可以帮助用户生成或处理各种类型的音频和视频，例如音乐、歌曲、配音、字幕、剪辑等。用户可以根据自己的需求选择不同的AI音视频工具，输入相关的信息或文件，然后得到AI生成或修改的音频和视频，或者对自己的音频和视频进行优化和增强。例如，[OpenAI Jukebox]可以生成任意风格的音乐，[Descript]可以让用户用文字编辑音频和视频，[Lovo]可以让用户用自己的声音制作专属的配音等。
「AI设计工具」：这些工具可以帮助用户生成或改进各种类型的设计，例如LOGO、图标、海报、名片、网页等。用户可以根据自己的需求选择不同的AI设计工具，输入相关的信息或样本，然后得到AI生成或优化的设计，或者对自己的设计进行调整和美化。例如，[Looka]可以让用户轻松创建自己的LOGO，[Figma]可以让用户在线协作设计网页和应用，[Canva]可以让用户制作各种专业的图形和文档等。
「AI编程工具」：这些工具可以帮助用户生成或优化各种类型的代码，例如Python、Java、HTML、CSS等。用户可以根据自己的需求选择不同的AI编程工具，输入相关的信息或代码，然后得到AI生成或修改的代码，或者对自己的代码进行检查和修复。例如，[Codex]可以让用户用自然语言编写代码，[CodeGuru]可以让用户提高代码的质量和性能，[Repl.it]可以让用户在线运行和分享代码等。
「AI阅读」：提供多种AI阅读工具，快速阅读和理解各种文献资料，如论文、报告、新闻等。用户上传或输入文本网址，获得AI的摘要、关键词、问题、答案等，或与AI进行交互式对话，提高阅读效率和理解能力。
「AI翻译」：提供多种AI翻译工具，进行多语言翻译和沟通，如英语、中文、日语、法语等。用户输入或说出内容，获得AI翻译结果，或进行语音对话，实现跨语言交流。
「AI学习」：提供多种AI学习工具，帮助用户学习和掌握各种知识和技能，如数学、编程、设计、音乐等。用户选择不同工具，进行自适应学习，或与AI进行互动教学，提升学习兴趣和效果。
二、学术润色去重功能 「论文润色报告」：提供在线生成工具，帮助用户完成论文润色报告，包括AI的润色建议、修改后的文本和润色报告的格式和内容。
「英文精修」：提供多种AI英文精修工具，根据用户需求选择简单校对、基础润色、深度专业润色，对英文论文进行语法纠正、词汇替换、句式调整等。
「句子改写」：提供多种AI智能英文论文润色工具，对句子进行倒装、精简和词义替换，让用户的表述更丰富、顺畅，产生多种改写结果。
「查重」：提供多种AI查重工具，帮助用户检测论文的抄袭或重复内容，返回查重结果和相似度分数，提供查重报告的格式和内容。
网站链接公众号IT技术视界回复126899获取工具集链接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c45a60335e95ac5b52c76c84ac6e20c6/" rel="bookmark">
			idea无法登录leetcode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：idea版本低了，leetcode插件版本也低了，leecode地址已经由leetcode-cn.com改成了leetcode.cn
解决方法：改配置文件
everything搜索leetcode-config.xml或者找到idea路径下的C:\Users\xxx\AppData\Roaming\JetBrains\IntelliJIdea2021.3\options下的leetcode-config.xml文件
将leetcode-cn.com改成leetcode.cn
还不行，可能是网页版leetcode登录太久了，点退出登录，再登录插件，刷新插件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b47f84cd70b832e9bd53a1aefafd4aa2/" rel="bookmark">
			SpringBoot 集成 Swagger 文档及自定义访问路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Swagger Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。
二、SpringBoot 集成使用 pom &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-models&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt; &lt;version&gt;1.5.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-models&lt;/artifactId&gt; &lt;version&gt;1.5.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; SwaggerConfig.java @Configuration @EnableSwagger2 public class SwaggerConfig { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.bxc.conformity.Swagger.DemoController")) // .paths(PathSelectors.regex("/App/.*|Thirdparty/.*")) .paths(PathSelectors.regex("(/App/.*)|(/Thirdparty/.*)")) .build() .securitySchemes(securitySchemes()) .securityContexts(securityContexts()); } private List&lt;ApiKey&gt; securitySchemes() { List&lt;ApiKey&gt; apiKeyList = new ArrayList(); apiKeyList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b47f84cd70b832e9bd53a1aefafd4aa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dba917aedd5b249088924e5506e6e10/" rel="bookmark">
			Android 蓝牙相关广播介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 蓝牙相关广播介绍 文章目录 Android 蓝牙相关广播介绍一、前言二、相关广播1、蓝牙相关广播（1）蓝牙开关（2）蓝牙断开/连接（3）蓝牙状态（4）蓝牙配对/取消配对（5）从源码看Android系统有哪些广播BluetoothAdapter.java 相关广播:BluetoothDevice.java 相关广播: 2、广播接收代码示例3、广播接收代码示例日志（1）蓝牙打开、关闭日志蓝牙打开：蓝牙关闭： （2）蓝牙请求连接其他蓝牙设备日志（3）其他Android设备请求连接配对设备日志其他Android手机设备配对自己的设备，未确认配对前点击取消配对/不点击处理导致配对超时的情况点击确认配对的情况 （4）蓝牙连接、断开日志从保存状态到连接蓝牙设备断开蓝牙设备，从连接状进入保存状态 （5）蓝牙忘记设备日志（6）日志总结强烈建议像上面示例代码一样，先打印不同状态值对应的关系，再打印具体的状态值，这样就一下子知道获取到的状态值的含义了。 三、蓝牙状态判断1、蓝牙开关状态（1）蓝牙开关状态在 BluetoothAdapter.java 中的定义（2）蓝牙开启状态判断 2、蓝牙连接状态数值3、蓝牙某个设备绑定/连接状态4、蓝牙关键对象 BluetoothDevice（1）获取 BluetoothDevice 对象（2）BluetoothDevice 关键信息 四、其他1、蓝牙配对广播ACTION_PAIRING_REQUEST的说明2、蓝牙广播注册时机说明3、各种状态总结4、其他开发组对于这部分知识的总结（1）Android 蓝牙基本开发知识介绍，包含一些常用的api和广播（3）Android 蓝牙驱动开发（4）蓝牙通讯框架（5）蓝牙广播-硬件信号相关的介绍（6）之前写的蓝牙总结文章，有兴趣可以看看 一、前言 本文主要介绍Android 蓝牙相关的广播，并非硬件相关的蓝牙广播信号，而是蓝牙app中的广播接收器onReceive 的蓝牙相关广播。
最近刚好开发了一下蓝牙相关的功能，所以进行一些知识总结和介绍，本文应该是全网最面的接收Android广播介绍知识的文章。
Android 蓝牙广播是系统应用或者蓝牙功能应用必备知识，网上介绍的较少或者比较片面，所以Android蓝牙相关开发的可以了解和收藏。
二、相关广播 蓝牙相关广播都是在 BluetoothDevice.java 和 BluetoothAdapter.java 中进行了定义。
蓝牙相关广播主要包括：蓝牙开关，蓝牙连接，蓝牙状态改变，蓝牙配对等等等等。
//Android13 中的源码地址：
packages\modules\Bluetooth\framework\java\android\bluetooth\BluetoothDevice.java
packages\modules\Bluetooth\framework\java\android\bluetooth\BluetoothAdapter.java
1、蓝牙相关广播 （1）蓝牙开关 BluetoothAdapter.java 的代码
BluetoothAdapter.ACTION_STATE_CHANGED
/** * Broadcast Action: The state of the local Bluetooth adapter has been * changed. * &lt;p&gt;For example, Bluetooth has been turned on or off.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dba917aedd5b249088924e5506e6e10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16dbdd280a91ad2e9b22cfecd0376d84/" rel="bookmark">
			Android13 不能静态注册的几个广播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android13 不能静态注册的几个广播 文章目录 Android13 不能静态注册的几个广播一、不能静态注册的广播:二、静态注册无法生效的分析1、Intent.java2、其他地方声明了不能静态注册的广播3、为啥静态注册的广播无效？4、其他静态注册无法生效的广播5、其他Android framework 所有广播的定义静态广播注册无效解决详解Android广播Broadcast的启动流程AMS 四大组件之 Broadcast流程分析 本文介绍一些广播相关的知识，主要是静态广播注册无效的介绍。 其实从Android 8.0 就开始有这个问题的，只是本文的源码是基于Android13 分析的。
一、不能静态注册的广播: 其实并不是不能静态注册，只是静态注册会无效而已。
android.intent.action.SCREEN_ON //屏幕亮起 android.intent.action.SCREEN_OFF//屏幕亮起 android.intent.action.BATTERY_CHANGED //电池电量改变 android.intent.action.CONFIGURATION_CHANGED //配置改变，界面语言，设备方向等配置信息 android.intent.action.TIME_TICK //每分钟回调一次 主要是系统安全问题，这些广播都是比较频繁的，或者是重要时机的，避免普通应用乱用。
你以为就完了吗，其实没有！
上面五个广播都是 Intent.java 里面定义的广播，网上很多就说了上面五个，
其实还有其他广播静态注册是无法生效的。
二、静态注册无法生效的分析 1、Intent.java framework\base\core\java\android\content\Intent.java
看其中一个无法静态注册的广播 Intent.ACTION_TIME_TICK 说明
/** * Broadcast Action: The current time has changed. Sent every * minute. You &lt;em&gt;cannot&lt;/em&gt; receive this through components declared * in manifests, only by explicitly registering for it with * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter) * Context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16dbdd280a91ad2e9b22cfecd0376d84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/454c2f732ef72e68f80d7fefae253b57/" rel="bookmark">
			c&#43;&#43;标准库＜locale＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、locale
二、设置locale (std::locale::locale)
三、获取locale的名字 (std::locale::name)
四、设置全局locale(std::locale::global)
五、out.getloc、out.imbue
六、facet
上篇主要讲解了c语言的标准库&lt;locale.h&gt;,本篇文章主要讲解下c++的标准库locale。
真正的国际化来说，仅仅翻译“文字所带的信息”通常是不够的。各种不同的数值、货币、日期…的规格也都必须准守。另外，用来操作字母（latters）的函数，应该根据字符（characters）进行编码（encoding），以确保正确处理特定语言中所有身为字母的字符。根据POSIX和X/Open标准，c程序可使用函数setlocale来设定一个locale。改变locale会对issupper()和toupper()之类的字符分类、操作函数以及printf()之类的I/O函数产生影响。然而C的解决方案毕竟有诸多限制。由于locale是全局属性，所以同时使用一个以上的locale（例如，按英文规则读取浮点数，按照德文写出），即使不是不可能，也得费九牛二虎之力才有希望。此外locales不能扩展，如果某个必须遵守的国家协议未被c locale支持，就没有办法了。最后一点，我们根本不可能为了支持特殊文化而定义新的locales.c++标准程序库利用面向对象方式解决了上述所述问题。首先，“与locale相关的细节”被封装在类型为locale的对象中。仅仅如此这般，在同一时刻运用多个locales的美梦成真。与locales相依的各种操作，将运用响应的locale对象。 例如，我们可以把每一个locale对象安装到每一个I/O stream中，或者的各成员函数便利用该对象迎合相应的规格。详见本文的（五、out.getloc、out.imbue）参考《c++标准程序库》第14章：国际化
一、locale 参见：locale,本文章主要讲解和locale相关的知识，针对facet在本文的《六、facet》只做简单介绍。
A locale is a set of features that are culture-specific, which can be used by programs to be more portable internationally.
In C++, locales are represented by an object of the locale class. Each of these locale objects contains all the information needed to use a set of culture-dependent features.
简单翻译：locales是c++中locale对象的实例。
二、设置locale (std::locale::locale) c++ 11 构造函数，参见std::locale::locale 构造函数，参考书籍《c++标准程序库》第14章：国际化中有中文介绍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/454c2f732ef72e68f80d7fefae253b57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4465fafca816aa08c0ee61e757f593a/" rel="bookmark">
			Centos开机进入grub命令行模式进入不了操作系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：没有linux命令，没有initrd命令，没有init6命令
由于删除了/boot/efi/EFI/centos/grub.cfg ，重启服务器后，无法进入原来正常的系统，进入了grub命令行界面 备注：对于centos7/8/openEuler:
如果是采用的UEFI方式引导的，那系统的GRUB的有效配置文件是 /boot/efi/EFI/centos/grub.cfg；
如果是采用的Legacy方式引导，那对应的GRUB的有效配置文件是/boot/grub2/grub.cfg。
解决办法: 采用系统镜像/U盘Centos，设置开机从镜像/U盘启动，如图进入启动界面
然后点击第二项，进入救援模式。 然后进入如下模式，选择1，继续进行回车，接下来，我们就会进入到一个shell模式中，需要切换根目录，进行系统修复：
1.bash-5.1# chroot /mnt/sysroot/ # 根据输入完1之后的提示进行chroot 2.cd /boot/efi/EFI/centos grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg 或者grub2-mkconfig &gt; /boot/efi/EFI/centos/grub.cfg 3.sync	切记一定要执行，否则重启不生效，再次在救援模式下查看grub.cfg可能会被修改为grub.cfg.new 4.exit + reboot 备注：如果是Legacy方式引导时：
1、chroot /mnt/sysroot/ 切换根目录 2、在/boot/grub2/目录下生成grub.cfg文件 grub2-mkconfig -o /boot/grub2/grub.cfg 或者grub2-mkconfig &gt; /boot/grub2/grub.cfg 3、sync （切记一定要执行，否则重启不生效，再次在救援模式下查看grub.cfg可能会被修改为grub.cfg.new） 4、然后exit退出，再reboot重启。 扩展：
在 CentOS 中，进入救援模式后输入 sync 命令可以将内存中的数据同步到磁盘中。这是因为在正常关机时，操作系统会自动将内存中的数据写入到磁盘中，但在异常关机或重启时，可能会导致部分数据还未及时写入磁盘而发生数据丢失或损坏。
sync 命令的作用是告诉操作系统立即将内存中的数据写入到磁盘中，以强制完成数据同步。这样可以确保在接下来的操作中，已经写入到磁盘中的数据不会丢失或损坏，从而避免数据恢复或修复工作的复杂性和风险。
需要注意的是，sync 命令并不能修复已经损坏或丢失的数据，它只能保证已经写入到磁盘中的数据是完整和正确的。如果您遇到了数据损坏或丢失的问题，可能需要使用更专业的数据恢复工具或服务来解决。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/43/">«</a>
	<span class="pagination__item pagination__item--current">44/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/45/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>