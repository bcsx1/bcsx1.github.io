<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06cf1ac24293f6c26cc24946f46d8527/" rel="bookmark">
			实验七、MOS管分压式偏置共源放大电路的静态和动态参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 搭建MOS管分压式偏置共源放大电路。利用Multisim研究下列问题：
（1）确定一组电路参数，使电路的 Q Q Q 点合适。
（2）若输出电压波形底部失真，则可采取哪些措施？若输出电压波形顶部失真，则可采取哪些措施？调整 Q Q Q 点约在交流负载线的中点。
（3）要想提高电路的电压放大能力，可采取哪些措施？
二、仿真电路 搭建如图1所示电路，选择电源电压 V D D = 15 V V_{DD}=15\,\textrm V VDD​=15V，负载电阻 R L = 5 k Ω R_L=5\,\textrm kΩ RL​=5kΩ。
图 1 MOS管分压式偏置共源放大电路 图1\,\,\textrm{MOS}管分压式偏置共源放大电路 图1MOS管分压式偏置共源放大电路电路中采用虚拟N沟道增强型MOS场效应管，其沟道长度 Channel length = 100 μm、沟道宽度 Channel width = 100 μm，模型参数 V T = U G S ( t h ) = 2 V VT = U_{GS(th)}=2\,\textrm V VT=UGS(th)​=2V， K P = 2 ∗ I D O / U G S ( t h ) 2 = 1 ∗ 1 0 − 3 A/V 2 KP=2*I_{DO}/U^2_{GS(th)}=1*10^{-3}\,\textrm{A/V}^2 KP=2∗IDO​/UGS(th)2​=1∗10−3A/V2。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06cf1ac24293f6c26cc24946f46d8527/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dee8299b6f71a2f102e613d468a81eb/" rel="bookmark">
			FPU与VFP最全面解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文希望能将FPU以及ARM中的FPU介绍清楚。
1. FPU（Floating-Point Unit） 浮点运算单元是处理器内部用于执行浮点数计算的逻辑部件，或者说硬件电路。不是所有的处理器都有该功能。浮点运算满足IEEE 754的标准，所谓IEEE 754标准，定义了浮点数字的存储和计算方式、计算异常等，比如IEEE 754标准准确地定义了单精度（32位）和双精度（64位）浮点格式。
对于含有FPU的处理器，我们可以通过控制编译选项的方式使编译器编译出的代码使用FPU指令。
2. -mfloat-abi=name来指定浮点运算处理方式 gcc为例，对应的-mfloat-abi参数值有三个：soft,softfp,hard。
soft是指所有浮点运算全部在软件层实现，比如ARM提供了一个「浮点支持软件库」用于计算浮点数：fplib。使用软件的方式来计算浮点最终是通过执行了很多的指令来完成一次运算，不仅慢而且程序体积大。fplib提供的 API 以__aeabi开头，比如：__aeabi_fadd：计算两个float型浮点数加法（float占4个字节，32位）softfp是指浮点运算的实际计算是在FPU上来做，但是传递浮点运算的参数是用整形的通用寄存器（r0-r3)来传递的。比如float fadd(float a, float b)，a和b实际上是通过r0,r1传入到被调函数的，结果也是通过r0传出的。hard与softfp的区别是不仅运算实际发生在FPU上，浮点参数的传递使用的也是浮点专用寄存器。以上同样的例子，a和b是通过s0, s1寄存器来传的，结果是通过s0传出的。softfp和hard两种模式不兼容，所以你不能将一个使用softfp方式的库和另外一个使用hard的库或目标文件链接起来。因为如此，armv7有些编译好的库（比如glibc使用softfp)没法在使用另一种使用hard的应用中编译。
使用软件库编译出的代码实例：
使用hard编译出的使用FPU的代码实例：
3. -mfpu=name来指定浮点协处理的类型 在ARM中的FPU被称为VFP(Vector Floating Point),即向量浮点运算，之所以称为“向量”浮点是因为在ARMv6及以前这个扩展不只是用于增加浮点数计算处理，同时也用于类似向量的SIMD浮点数计算处理。在ARMv7架构中，这种使用VFP来处理向量浮点数据的方式不建议采用，相关的功能可以使用“先进SIMD扩展”来替代。而vfp经过几代的发展和完善，出现了vfpv3, vfpv4, fpv5等多个版本，每个版本又可以配置为不同的使用方式，所以，这个-mfpu参数就是指定所采用的vfp硬件。
在文档《Arm Compiler for Embedded Reference Guide》中列举了可以使用的值，可选类型如none, softvfp，vfpv3，vfpv3-d16，vfpv3-d16-fp16，vfpv3xd, neon, vfpv4，fpv4-sp-d16，fpv5-d16，fpv5-sp-d16等。简单从文档中摘出几个：
none, softvfp: Use either -mfpu=none or -mfpu=softvfp to prevent the compiler from using hardware-based floating-point functions. If the compiler encounters floating-point types in the source code, it uses software-based floating-point library functions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dee8299b6f71a2f102e613d468a81eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b0fae468fa290d710bfb41378aa2371/" rel="bookmark">
			C语言 期末合集 pta
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6-1 求最大的偶数和最小的奇数的差 分数 10
全屏浏览题目
切换布局
作者 王跃萍
单位 东北石油大学
求10个数中的最大的偶数和最小的奇数的差。
函数接口定义： int fun(int a[],int n); 函数fun中a、n是用户传入的参数，函数fun的功能是求a数组中的n个数中的最大的偶数和最小的奇数的差，并返回此差值。
裁判测试程序样例： #include&lt;stdio.h&gt; int fun(int a[],int n); int main() {int b[10],i,max,k=0; for(i=0;i&lt;10;i++) scanf("%d",&amp;b[i]); printf("%d\n",fun(b,10)); return 0; } /* 请在这里填写答案 */ 输入样例： 1 2 3 4 5 6 7 8 9 10 输出样例： 9 #include&lt;stdio.h&gt; int fun(int a[],int n){ int max=0,max1=0; for(int i=0;i&lt;10;i++){ if(a[i]%2==0){ if(max&lt;a[i]) max=a[i]; } else{ max1=a[0]; if(max1&gt;a[i]) max1=a[i]; } } if(max&lt;max1) return max1-max; else return max-max1; } 6-2 字符串中的字符用插入法排序 分数 10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b0fae468fa290d710bfb41378aa2371/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ec6fd40f4c752dd3145c4d249dd046f/" rel="bookmark">
			Ubuntu安装显卡驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 本文介绍如何在Ubuntu下比较便捷稳定地安装NVIDIA显卡驱动，其他发行版如Centos不保证有效。本文所有的命令都要求在root用户下进行，否则命令前要加sudo。本教程仅适合于Ubuntu18及以后版本。
禁用nouveau 首先，编辑黑名单配置。
vim /etc/modprobe.d/blacklist.conf 在文件的最后添加下面两行。
blacklist nouveau options nouveau modeset=0 然后，输入下面的命令更新并重启。
update-initramfs -u reboot 重启后输入下面的命令验证是否禁用成功，成功的话这行命令不会有输出。
lsmod | grep nouveau 驱动安装 首先，使用apt卸载已有的驱动，命令如下。
apt-get purge nvidia* 首先，我们可以使用Ubuntu自带的驱动管理工具ubuntu-drivers devices查询Ubuntu当前版本推荐的驱动，结果如下图，有一行出现了recommended字样，这代表系统推荐这个驱动，也就是nvidia-430。
接着，执行下面的自动安装推荐版本驱动的命令即可，这时就会自动安装上面的推荐版本驱动到机器上。
ubuntu-drivers autoinstall 最后，我们重启机器，这里注意，务必重启机器。 重启后不出意外会正常开机，然后输入下面的命令测试驱动安装情况，结果如下图，可以看到成功安装了推荐版本的驱动程序。
nvidia-smi CUDA和NVIDIA驱动对应 截止2021年初，CUDA和驱动的对应情况如下表，安装CUDA前务必考虑驱动的版本是否足够，后续该表还会更新，最新请访问官网。
补充说明 本文介绍的是使用标准仓库进行自动化安装，这是Ubuntu下最简洁的方法，此外还可以使用PPA仓库进行自动化安装或者使用NVIDIA官方驱动程序进行安装（这种方法较为复杂），有兴趣的可以自行查阅。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36a560d5371ad6841460d5f49aa1d76e/" rel="bookmark">
			阿里云轻量服务器--Docker--Mqtt(eclipse-mosquitto)安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 获取镜像：
docker pull eclipse-mosquitto:1.6.14 查看获取的镜像：
docker images 2 安装：
2.1 新建日志和数据目录：
# 配置文件存放 mkdir -p /root/mosquitto/config # 数据文件存放 mkdir -p /root/mosquitto/data # 日志文件存放 mkdir -p /root/mosquitto/log 2.2 创建配置文件：
touch /root/mosquitto/config/mosquitto.conf vim /root/mosquitto/config/mosquitto.conf 插入下面语句：
persistence true persistence_location /mosquitto/data log_dest file /mosquitto/log/mosquitto.log persistence true： 开启持久化 ，默认为false 如果不开，信息，数据，链接会被存到内存中；
persistence_location ：mqtt 容器中 数据持久化的地方，如果不写，会使用当前路径
log_dest file：mqtt 容器日子持久化的地方
2.2 安装：
docker run -d --name=mosquitto --privileged \ -p 1883:1883 -p 9001:9001 \ -v /root/mosquitto/config/mosquitto.conf:/mosquitto/config/mosquitto.conf \ -v /root/mosquitto/data:/mosquitto/data \ -v /root/mosquitto/log:/mosquitto/log \ eclipse-mosquitto:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36a560d5371ad6841460d5f49aa1d76e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b382c83ae71233437c93ad31ecc0861b/" rel="bookmark">
			Unity实现一个可扩展的UGUI无限滑动列表控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		12月20日新增 增加一个可收缩的滑动列表，适用于游戏中的任务系统，成就等
使用说明
创建时需要两个模板slot，一个是button，另一个则是btn下显示的cell
配置如下图添加ExpandableView脚本，新增的IsDefaultExpand用来控制是否展开
11月28日新增 增加可调节的顶部间隙和左侧间隙
采用 缓存池+存储布局坐标 实现的一个可横向或纵向滑动的无限滑动列表 Demo展示：
功能支持：
可以满足大部分如背包，商店商城，工具栏，任务栏窗口等列表功能
支持整个列表刷新或单个对象刷新支持横向多行滑动，可设置行数，左右间隔大小支持纵向多行滑动，可设置行数，左右间隔大小支持通过列表索引定位到列表中的某一位置可以作为基本扩展详细可看源码… 案例测试：
导入Package后的目录结构如下，打开MainDemo场景
场景上有一个TestScript节点挂在了脚本 RecycleViewTest.cs，默认配置了1000个数据和通过索引定位到966位置（暗示上班时常），此处可以修改启动游戏测试。实际开发中，可以参照该脚本中的方法调用对滑动列表进行初始化。
使用方法：
在你制作好的scrollview上挂载脚本 RecycleView.cs，并且详细参数进行设置，如下图：
目前最大支持10行或10列，如果需要配置更多行，则需要去脚本RecycleViewEditor.cs中找到行列设置参数lines进行修改
rv.lines = EditorGUILayout.IntSlider("Row Or Column", rv.lines, 1, 10); 生成你的滑动列表的必要三个步骤：
持有RecycleView对象rv，并注册回调函数 rv.Init(callBackFunc)刷新整个列表（首次调用和数量变化时调用）: ShowList(int count)在回调函数中做具体的显示，操作等 Func(GameObject cell, int index) 示例代码：
public RecycleView VerticalScroll; // 持有对象 void Start() { StartScrollView(); } public void StartScrollView() { VerticalScroll.Init(NormalCallBack); // 注册回调 VerticalScroll.ShowList(ListCount); // 刷新列表 } private void NormalCallBack(GameObject cell, int index) { // 在该方法中做具体的逻辑 } 资源地址：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b382c83ae71233437c93ad31ecc0861b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2523f2520d8c0e0bcfbd507c0c34ac70/" rel="bookmark">
			Java 实现万年历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过Java的基本语法来实现我们的万年历
请看代码
public class CalDate{ public static void main(String[] args）{ Scanner sc = new Scanner(System.in); System.out.println("请输入年："); int year = sc.nextInt(); System.out.println("请输入月份："); int month = sc.nextInt(); //1.计算1900.1.1到输入年的天数 int dayOfYear = 0; for (int i = 1900; i &lt; year; i++){ if (i % 4 == 0 &amp;&amp; i % 100 != 0 || i % 400 == 0){ dayOfYear += 366; }else { dayOfYear += 365; } } //2.计算1月到输入月的天数 int dayOfMonth = 0; for (int i = 1; i &lt; month; i++){ switch (i){ case 1:case 3:case 5:case 7:case 8:case 10:case 12: dayOfMonth += 31; break; case 4:case 6:case 9:case 11: dayOfMonth += 30; break; case 2: if((year%4==0)&amp;&amp;(year%100!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2523f2520d8c0e0bcfbd507c0c34ac70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8462464548649d7283587aa534c41467/" rel="bookmark">
			设计模式——MVC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MVC 设计模式一般指 MVC 框架，M（Model）指数据模型层，V（View）指视图层，C（Controller）指控制层。使用 MVC 的目的是将 M 和 V 的实现代码分离，使同一个程序可以有不同的表现形式。其中，View 的定义比较清晰，就是用户界面。
经典MVC模式中，M是指业务模型，V是指用户界面，C则是控制器，使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。其中，View的定义比较清晰，就是用户界面。
二 编程模式 M即model模型是指模型表示业务规则。在MVC的三个部件中，模型拥有最多的处理任务。被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。
V即View视图是指用户看到并与之交互的界面。比如由html元素组成的网页界面，或者软件的客户端界面。MVC的好处之一在于它能为应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操作的方式。
C即controller控制器是指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。
三 特点 优点 1.耦合性低 视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码，同样，一个应用的业务流程或者业务规则的改变只需要改动MVC的模型层即可。因为模型与控制器和视图相分离，所以很容易改变应用程序的数据层和业务规则。
2.重用性高 MVC模式允许使用各种不同样式的视图来访问同一个服务器端的代码，因为多个视图能共享一个模型，它包括任何WEB（HTTP）浏览器或者无线浏览器（wap），比如，用户可以通过电脑也可通过手机来订购某样产品，虽然订购的方式不一样，但处理订购产品的方式是一样的。由于模型返回的数据没有进行格式化，所以同样的构件能被不同的界面使用。
3.部署快，生命周期成本低 MVC使开发和维护用户接口的技术含量降低。使用MVC模式使开发时间得到相当大的缩减，它使程序员（Java开发人员）集中精力于业务逻辑，界面程序员（HTML和JSP开发人员）集中精力于表现形式上。
4.可维护性高 分离视图层和业务逻辑层也使得WEB应用更易于维护和修改。
缺点 1.完全理解MVC比较复杂。 由于MVC模式提出的时间不长，加上同学们的实践经验不足，所以完全理解并掌握MVC不是一个很容易的过程。
2.调试困难。 因为模型和视图要严格的分离，这样也给调试应用程序带来了一定的困难，每个构件在使用之前都需要经过彻底的测试。
3.不适合小型，中等规模的应用程序 在一个中小型的应用程序中，强制性的使用MVC进行开发，往往会花费大量时间，并且不能体现MVC的优势，同时会使开发变得繁琐。
4.增加系统结构和实现的复杂性 对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。
5.视图与控制器间的过于紧密的连接并且降低了视图对模型数据的访问 视图与控制器是相互分离，但却是联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。
依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bc943b183ed9d5cb887566de2ff9b2c/" rel="bookmark">
			sqlserver一行转为多行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 WITH CTE AS ( SELECT number,id from ExpenseCardNumber ) SELECT a.id,c.number FROM (SELECT id,CONVERT(XML,'&lt;R&gt;&lt;V&gt;' + REPLACE(number,',','&lt;/V&gt;&lt;V&gt;') + '&lt;/V&gt;&lt;/R&gt;') AS Col FROM CTE) a CROSS APPLY(SELECT t.c.value('.','nvarchar(256)') FROM a.Col.nodes('R/V') AS t(c)) AS c(number) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44bd99f53472bbac73d5a6d2ecef60fb/" rel="bookmark">
			Python&#43;Vue计算机毕业设计vue的阅读网站055h5（源码&#43;程序&#43;LW&#43;部署）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该项目含有源码、文档、程序、数据库、配套开发软件、软件安装教程
项目运行环境配置：
Python3.7.7+Django+Mysql5.7+pip list+HBuilderX（Vscode也行）+Vue+Pychram社区版。
项目技术：
Django + Vue +Python+Mysql 等等组成，B/S模式等等。
环境需要
1.运行环境：最好是安装Python3.7.7，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：Python和Python 社区版都可以。推荐Python 社区版;
3.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
技术栈
1. 后端：Python、Vue、Django、Mysql
2. 前端：vue+css+javascript+jQuery+easyUI+highcharts
Python-Django毕设帮助，指导，本源码(见文末)，调试部署
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50fe4521b41652b8dc256f3fa14805d8/" rel="bookmark">
			毕业设计 基于java web 的企业员工信息管理系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、项目设计1. 模块设计2. 实现效果 二、部分源码最后 前言 今天学长向大家分享一个 java wed 毕业设计项目:
企业员工信息管理系统的设计与实现
一、项目设计 1. 模块设计 系统用户分为两级：管理员与普通员工。系统采用基于Web技术的B/S框架进行设计，确立了企业员工信息管理系统主要功能需求有以下几个方面：
①管理公司员工的基本信息：
员工基本信息管理主要负责对员工的基本信息进行管理与更新，基本信息包括姓名，性别，年龄，职位，部门，是否领导，帐号，密码。通过对基本信息的管理，可以清楚的了解员工的信息，及时对员工信息的更新，有助于增加企业对员工的管理。普通员工只能修改自己的密码，不用更改其他信息。
②管理公司的部门信息：
公司部门信息的管理主要用于对员工进行分类，分布于各个部门之下，能够及时并准确的找出该员工目前的工作状态。部门管理主要包括添加部门以及添加子部门，删除部门等操作，便于及时更新部门信息。
③管理员工的出勤信息：
员工出勤信息的管理主要用于对员工的出勤月份以及天数进行管理，便于计算员工的工资等。出勤信息主要包括月份，天数以及员工姓名，管理员可以录入员工的出勤天数，普通员工只能查看而不能进行更改。
④管理员工的工资信息：
员工工资信息的管理主要用于对员工的每个月的工资进行管理，便于对员工的工资进行管理。工资信息主要包括月份，金额以及员工姓名，管理员可以录入员工的工资信息，普通员工只能查看而不能进行更改。
⑤员工的请假审核信息：
员工的请假审核主要用于管理员对员工的请假进行审核并加以回复，便于对员工的请假进行管理。请假主要包括姓名，开始时间，结束时间，请假事由，审核状态以及回复信息，管理员进行回复时说明是否批准以及回复信息，使员工有一个直观的了解，员工可以进行请假申请并查看自己当前请假的状态。
2. 实现效果 二、部分源码 部分代码示例：
登录模块实现的关键代码
public String login(String userName,String userPw,int userType) { System.out.println("userType"+userType); try { Thread.sleep(700); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } String result="no"; if(userType==0)//系统管理员登陆 { String sql="select * from t_admin where userName=? and userPw=?"; Object[] params={userName,userPw}; DB mydb=new DB(); mydb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50fe4521b41652b8dc256f3fa14805d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/678df48cc8b98424c8db51cfd3f4a539/" rel="bookmark">
			用C/C&#43;&#43;实现Base64编码和解码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022.12.19日,看了一下base64原理,然后想用代码实现一下,改了好久的bug终于完美成功了
目录
一.收获
①移位运算符优先级高于与或非
②map容器可以方便查找,但使用时要注意find(keyvalue),是否解引用了空迭代器等
③unsigned char类型移位运算可以不考虑符号位,但是形参使用const char*更有通用性,所以需要进行一个强转
二.代码实现
1.纯c语言版
2.c++版
3.效果图
①编码
②解码
一.收获 ①移位运算符优先级高于与或非 ②map容器可以方便查找,但使用时要注意find(keyvalue),是否解引用了空迭代器等 ③unsigned char类型移位运算可以不考虑符号位,但是形参使用const char*更有通用性,所以需要进行一个强转 二.代码实现 1.纯c语言版 #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; unsigned char* base64_encode(const char* str0) { unsigned char* str = (unsigned char*)str0;	//转为unsigned char无符号,移位操作时可以防止错误 unsigned char base64_map[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";//数组形式,方便修改 long len;	//base64处理后的字符串长度 long str_len;	//源字符串长度 long flag;	//用于标识模3后的余数 unsigned char* res;	//返回的字符串 str_len = strlen((const char*)str); switch (str_len % 3)	//判断模3的余数 { case 0:flag = 0; len = str_len / 3 * 4; break; case 1:flag = 1; len = (str_len / 3 + 1) * 4; break; case 2:flag = 2; len = (str_len / 3 + 1) * 4; break; } res = (unsigned char*)malloc(sizeof(unsigned char) * len + 1); for (int i = 0, j = 0; j &lt; str_len - flag; j += 3, i += 4)//先处理整除部分 { //注意&amp;运算和位移运算的优先级,是先位移后与或非 res[i] = base64_map[str[j] &gt;&gt; 2]; res[i + 1] = base64_map[(str[j] &amp; 0x3) &lt;&lt; 4 | str[j + 1] &gt;&gt; 4]; res[i + 2] = base64_map[(str[j + 1] &amp; 0xf) &lt;&lt; 2 | (str[j + 2] &gt;&gt; 6)]; res[i + 3] = base64_map[str[j + 2] &amp; 0x3f]; } //不满足被三整除时,要矫正 switch (flag) { case 0:break;	//满足时直接退出 case 1:res[len - 4] = base64_map[str[str_len - 1] &gt;&gt; 2];	//只剩一个字符时,右移两位得到高六位 res[len - 3] = base64_map[(str[str_len - 1] &amp; 0x3) &lt;&lt; 4];//获得低二位再右移四位,自动补0 res[len - 2] = res[len - 1] = '='; break;	//最后两个补= case 2: res[len - 4] = base64_map[str[str_len - 2] &gt;&gt; 2];	//剩两个字符时,右移两位得高六位 res[len - 3] = base64_map[(str[str_len - 2] &amp; 0x3) &lt;&lt; 4 | str[str_len - 1] &gt;&gt; 4];	//第一个字符低二位和第二个字符高四位 res[len - 2] = base64_map[(str[str_len - 1] &amp; 0xf) &lt;&lt; 2];	//第二个字符低四位,左移两位自动补0 res[len - 1] = '=';	//最后一个补= break; } res[len] = '\0';	//补上字符串结束标识 return res; } unsigned char findPos(const unsigned char* base64_map, unsigned char c)//查找下标所在位置 { for (int i = 0; i &lt; strlen((const char*)base64_map); i++) { if (base64_map[i] == c) return i; } } unsigned char* base64_decode(const char* code0) { unsigned char* code = (unsigned char*)code0; unsigned char base64_map[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/678df48cc8b98424c8db51cfd3f4a539/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24d0f16888ebdea12d4bce4dd8d1ffc3/" rel="bookmark">
			Android存储之分区存储适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Android存储分区介绍 1.简介 Android 存储分为内部存储（Internal storage）和外部存储（External storage）。有许多用户认为外部存储意味着SD存储卡或外部硬盘，这是完全错误的认识。
内部存储
内部存储是用于存储Android系统本身和应用程序的存储区域，Android设备中的Android系统和应用程序都是存在该内部存储区，例如手机的/system/目录、/data/等目录。 如果没有这一块存储区域是无法运行Android系统和应用程序的。其中data/data/包名/目录是Android系统提供给应用存储数据的内部存储空间，由应用程序创建的SharedPreferences、Sqlite数据库、缓存文件等目录都是保存在该文件夹中。该目录只能由该应用程序自身访问，其他应用程序和用户无法访问存储在此空间中的文件，并且该目录会随着的应用的卸载而被移除。 // 获取手机内部存储空间的绝对路径:/data Environment.getDataDirectory().getAbsolutePath(); 需要注意的一点是如果Android设备被获取到了最高权限(ROOT)那么是可以访问内部存储空间中的文件数据的!
外部存储
手机的内部存储空间通常不会很大，一旦手机的内部存储容量被用完， 可能会出现手机无法使用的情形。因此我们需要将一些比较大的媒体文件放置到机身外部存储中。在早先的手机中是具备一个SD存储卡槽的，插入SD存储卡，系统会将Sd储存卡的存储空间挂载成外部存储空间。不过现在大部分手机已经取消支持SD存储卡扩展功能了。取而代之的是手机会自带一个机身内置存储空间，这个机身存储和SD存储卡的功能是完全一样的，Android系统会将内置存储空间的一部分区域划分为内部存储，另一部分划分为外部存储空间，然后通过 Linux 文件挂载的方式将这些存储空间进行挂载。 // 获取手机外部存储的路径：/storage/emulated/0 Environment.getExternalStorageDirectory().getAbsolutePath() 2.内部存储和外部存储的区别 上文中讲到在以前的安卓手机中内置存储（机身存储）就是内部存储，外部存储就是扩展的SD卡。但目前很多的中高端机器的自带的内置存储都是很大的储存空间了， 因此Android4.4系统及以上的手机将机身内置存储分为了”内部存储internal” 和”外部存储external”两个不同的储存区域，用来存储不同的数据。如果Android4.4系统及以上的手机还支持单独外接SD卡，那么外接的SD卡一定是外部存储。此时手机上是有两个外部存储空间的。那么如何去区分这两个外部存储? Google官方给我们提供了getExternalFilesDirs这样一个API来获取多个外部存储空间， 它返回一个File数组，File数组中就包含了手机自身所带的外部存储和外接SD卡所定义的外部存储了。
if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) { File[] files = getExternalFilesDirs(Environment.MEDIA_MOUNTED); for(File file:files){ Log.e("Environment", file.getAbsolutePath()) } 注意：Android手机是支持外接多个外部存储介质空间的，如果用户在设备上移除了介质，则外部存储可能变为不可用状态。 所以在使用外部存储执行任何工作之前， 最好调用 getExternalStorageState() 以检查介质是否可用。
// 判断外部存储是否可用 if(Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) { ... } 对于Android开发者来说只和外部存储和内部存储打交道，Android提供的开发接口也只是获取内部存储和外部存储的目录地址。而对开发者屏蔽了内置存储卡和外置SD卡相关操作。
结论：内部存储和外部存储可以是在同一块存储介质上面的，只是概念上做了区分，内部存储和外部存储是一块存储介质上的不同区域。
二.Android应用存储目录 1.内部存储空间中的应用私有目录 对于设备中每一个安装的 App，系统都会在内部存储空间的 data/data 目录下以应用包名为名字自动创建与之对应的文件夹。这个文件夹包含了SharedPreferences 和 SQLiteDatabase 持久化应用相关数据等。该文件夹是应用的私有文件夹，其他应用（和用户）不能访问文件夹里面的内容的(Root用户除外)。每个应用访问自己的内部存储是不需要权限的。 当用户卸载该应用时，这些文件也会被移除。
Android SDK 提供有如下方法可以获取并操作内部存储空间下应用私有目录文件的方法，都位于 Application Context 中，供开发者直接调用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24d0f16888ebdea12d4bce4dd8d1ffc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c4b8fb807ab1322c089652f0e7781e4/" rel="bookmark">
			ByteTracker行人跟踪核心代码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		byteTracker中因为目标检测和行人跟踪是解耦的，因此这里主要分析的是byteTracker中的代码。
也即是分析当给定一帧图片frame_id,给定这帧中的box列表，行人跟踪类是怎么跟踪每条轨迹的。
也就是https://github.com/ifzhang/ByteTrack中位于目录tutorials/trades/byte_tracker中的代码。
首先这个代码中最重要的两个类，一个是轨迹类STrack，一个是跟踪类BYTETracker类。
前者是每条轨迹，后者管理目前视频流中的所有轨迹，并在新的一帧到来之后通过调用类方法update更新当前视频流中的轨迹状态（可能有新的轨迹，可能有旧的轨迹失去跟踪目标框，可能有目标框匹配成功，可能有之前丢失目标框的轨迹重新匹配成功）。
之所以写这个代码解读，是因为每次重新捡起来阅读的时候都被各种参数搞得晕头转向，很容易混淆不同参数的含义。索性写个详细的笔记记录一下。
一、轨迹类STrack 这里面保存的都是轨迹自身的状态。跟踪类BYTETracker类通过调用轨迹的属性和方法来进行轨迹状态的管理。
1 属性集合 属性名称类型含义self._tlwh列表保存目标框属性self.is_activatedbool该轨迹是否是激活状态（也就是保持追踪中）,如果是视频流的第一帧，那么第一次update的时候，该属性就是True，如果不是第一帧，那么需要第二次匹配成功的时候才会设置为True（考虑一下误识别的情况，这就可以理解了，只有当连续两帧都匹配成功，才认为这个轨迹可靠）。self.kalman_filter类实例在第一次调用activate()函数时，设置卡尔曼滤波器self.mean, self.covariancendarray保存卡尔曼滤波对于这个轨迹的mean和convariance.其中len(mean)=8(x,y,a,h,va,vy,va,vh),v表示速度，covariance为[8,8]。在第一次调用activate()函数时进行初始化，初始化根据目标框的坐标进行估计self.tlbrndarray如果self.is_activated=True，那么就是根据卡尔曼滤波预测的左上角和右下角坐标,如果self.is_activated=False，那么就是当前检测框观测值的左上角和右下角坐标self.tlwhndarray如果self.is_activated=True，那么就是根据卡尔曼滤波预测的左上角和宽高，如果self.is_activated=False，那么就是当前检测框观测值的左上角和宽高self.scorefloat轨迹分数，采用当前帧的目标框分数作为轨迹分数self.tracklet_lenint轨迹追踪的帧数，初始为0，后面每追踪成功（调用update方法），则+1self.stateTrackStateTrackState.New，Tracked,Lost,Removed四种状态，初始化为new。如果调用activate()/re_activate()/update方法时转换为Tracked状态，调用mark_lost()方法转为Lost状态，调用mark_removed()方法转为Removed方法。self.track_idintself.is_activated=True 轨迹的id，全局唯一标志self.start_frameint第一次调用activate方法时，这个轨迹的frame_idself.frame_idint目前位置，最后一次出现该轨迹的匹配框的帧编号self.end_frameint最后一帧出现该轨迹的帧编号,同frame_id 2. 方法集合 方法名称备注init(self, tlwh, score)每个目标框都会初始化一个track，但是此时的self.is_activated=Falseactivate(self, kalman_filter, frame_id)激活这条轨迹，如果是当前帧是视频流的第一帧，那么设置self.is_activated=True，否则这个属性依旧是False；设置state属性为TrackState.Trackedupdate(self, new_track, frame_id)更新轨迹信息，设置is_activate=True主要更新self.frame_id,self.score,tracklet_len,卡尔曼滤波mean,conv；re_activate(self, new_track, frame_id, new_id=False)重新激活这个轨迹（之前处于丢失状态），重新计算卡尔曼滤波的mean, covariance；重新计算self.tracklet_len；更新self.frame_id,self.score；mark_lost(self)将state参数设置为TrackState.Lost 这里需要注意两个概念：
1. is_activated状态和activate函数的关系：
不是调用了activate函数，轨迹的is_activated状态就是True。
is_activated状态可以理解为该轨迹是否大概率为真实的轨迹。
如果这状态为True，我们会认为这个轨迹是一个真实的轨迹，已经通过多帧的匹配得到的认证，是在追踪逻辑中高优先级的一个轨迹。但是如果这个轨迹是第一次出现，也就是目前只有一帧图片中出现了目标框，那么需要后续帧能够存在匹配的目标框来确保这个轨迹是真实的，而不是检测器的误检，那么此时这个is_activated状态就是False。第一帧数据除外，第一帧数据中的高分目标框默认生成的轨迹is_activated状态就是True。
调用了activate函数是表明当前这个目标框分数较高，很可能是一个新的轨迹的第一帧。
is_activated状态和state状态的关系：
正如上面说了is_activated的含义，state的含义单纯表示当前轨迹在当前帧的状态。
初始化为New；
对于第一次出现且没有匹配轨迹的高分检测框，会调用activate函数初始化一条轨迹，那么状态就是Tracked;
对于能够匹配到目标框的轨迹，通过调用轨迹的update方法，依旧将状态维持为Tracked;
对于当前帧丢失匹配的情况，将状态转为Lost;
对于多帧丢失乃至于超过BYTETracker定义max_time_lost的，则将其state设置为Removed。
二、轨迹追踪类BYTETracker 整个服务维护一个BYTETracker对象，负责当前视频所有轨迹的追踪和维护。其内部的类属性中最上面的三个列表维护了当前视频流中的所有轨迹，其余类属性为各种阈值参数。
属性类 属性名称类型含义self.tracked_strackslist[STrack]维护当前追踪中的轨迹列表self.lost_strackslist[STrack]维护到前一帧为止的追踪中丢失了检测框的轨迹列表self.removed_strackslist[STrack]维护删除的轨迹列表self.frame_idint当前视频流的帧id，默认从1开始，每次调用update方法，+1self.det_threshfloat检测阈值，高于这个阈值且无法在当前轨迹中找到匹配的检测框可以生成一条新的轨迹。self.track_thresh高质量检测框的分数阈值self.match_threshfloat轨迹和目标框匹配的阈值self.low_threshfloat低质量检测框的分数阈值self.max_time_lostint一条轨迹如果在该值数量的帧中都丢失了检测框，则认为这个轨迹丢失 方法类 方法名称备注init()初始化，初始化上述的属性reset(self)对于新的视频流需要重新初始化这个类的属性step(self, output_results)比较复杂，详细见下面 step方法详解 step(self, output_results)函数中的操作
先定义的一些用于保存中间结果的函数内列表
activated_starcks = []#存在的轨迹并且已经出于激活状态is_activate=Truerefind_stracks = []#当前帧中重新找到匹配的轨迹，这些轨迹在之前的状态中为Lost状态lost_stracks = []#当前帧中丢失匹配的轨迹，之前这些轨迹的状态为Trackedremoved_stracks = []#当前帧中需要删除的轨迹，这些轨迹到目前为止的丢失匹配帧数超过了self.max_time_lostunconfirmed = []#存在轨迹但是is_activate=False，但是因为这个轨迹出现的帧数不多（目前这版中认为出现1次的为unconfirmed，两次及以上就是确定的真实轨迹），因此不确定是否能真实（也就是目前还没有激活的轨迹）tracked_stracks = [] #self.tracked_stracks中的轨迹且满足轨迹属性is_activated为True 将当前帧检测到的目标框按照阈值分为detections,det_second,分别表示高质量检测框和低质量检测框;
将当前类中处于追踪状态的轨迹self.tracked_stracks列表，按照属性track.is_activated是否为True划分到tracked_stracks列表和unconfirmed列表中。其中unconfirmed中的轨迹为上一帧中首次出现了高质量目标框，但是因为出现的次数只有一次，所以还不能确定是否真的是一个新轨迹，需要在本帧中进行验证的新轨迹，这类的轨迹称为低优先级轨迹；将tracked_stracks+self.lost_stracks的轨迹集联合起来作为高优先级轨迹，统一更新高优先级轨迹的卡尔曼滤波得到本帧的预测结果。
具体的步骤如下
将高质量检测框和步骤2中的高优先级轨迹的预测框进行计算IOU距离,然后乘上检测框的score作为一个联合分数cost_matrix，显然如果IOU越大且score越大，那么认为检测框和2中的轨迹关联性越大。利用匈牙利算法和阈值self.match_thresh，根据上面计算得到的cost_matrix进行匹配，结果集合分为三个matches, u_track, u_detection，分别表示匹配的（轨迹，目标框），未能匹配的轨迹，未能匹配的高质量检测框对于匹配的（轨迹，目标框），如果轨迹的状态为Tracked，那么更新轨迹状态（调用轨迹的update方法），将这个轨迹添加到activated_starcks列表中对于匹配的（轨迹，目标框），如果轨迹的状态为其他，那么重新激活这个轨迹(调用轨迹的re_activate方法），将这个轨迹添加到refind_stracks列表中将低质量的检测框和步骤1中未能匹配的高优先级轨迹u_track中的追踪中轨迹（不考虑lost_strack中的轨迹），执行步骤1计算cost_matrix，需要注意这里的cost_matrix不需要考虑检测框的score权重。将得到的代价矩阵匈牙利匹配算法，此时匹配的阈值为0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c4b8fb807ab1322c089652f0e7781e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db1d95df5cd6bf11985c50c330f70715/" rel="bookmark">
			2023秋招360公司NLP算法岗面经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：投稿 作者：Sally can wait
编辑：学姐
NLP算法岗面经 作者介绍 中文系转NLP，985应用语言学研三，微软STCA的swe暑期实习，在研究生阶段做过导师给的toB的NLP横向项目（命名实体识别），leetcode刷了600+题。面试360的时间是11月初，距离笔试也过了一个多月，简历被业务反复筛选最后还是约面了。这轮面试是过了，进入排序阶段。
问项目 我复述在研究生阶段做的导师的横向项目的过程，面试官讲到像我做的冷启动文本分类项目，有标注的数据很少，和他们的场景比较像。介绍了一遍他们的项目，主要是做toB和toG的文本分类。
Q：如果任务是识别包含某种医疗手段的违法广告，怎么实现？
A：可以用意图识别的方法，算目标语句的词向量和某个意图向量的相似度，超过某一阈值就算。
Q：自己实现深度学习项目的时候，用了几张卡，大约用时多久
A：用的数据并行，4w条数据，用了几个小时。顺便主动讲了一下数据并行的原理，和模型并行的区别。
Q：有没有部署过推理服务？
A：不知道。
Q：面试官：部署模型之后，请求量很大，要把它做成服务。有tf-serving、torch-serve如果训练模型时候发现显存只占用10%，该如何调整？
A：调大batchsize、增加文本长度、提升小数精度
面试官说还有加深网络层数
Q：反过来如果爆显存了该如何调整？
A：半精度、调小batchsize、减少网络层数、dropout (忘记说梯度累加了)
Q：模型量化有了解吗？
A：不了解。但是实践中改小过模型精度。
听写Linux基础命令
Q：ls, pwd是什么指令？
Q：怎么看一个文件有多少行？（不会）
wc-l
Q：深度学习过程中要看显卡显存占用率？
nvidia-smi
Q：要把python挂到后台执行？
nohup python test.py &amp;
Q：批量替换文件名中的某个单词（不会）
sed
Q：查询之前用过的命令（不会）
history | grep
问NLP基础知识
Q：Word2vec, FastText, BERT 三种模型的embedding是怎么产生的？它们的相同和不同点？
A：相同点：都基于分布式语义，一个词的含义由上下文决定。 不同点：前两者是静态词向量，一个词对应一个embedding。BERT因为有self-attention机制，得到的是语境词向量，上下文不同，目标词位置的向量也不同。
Q：Word2vec, FastText, BERT在词表上有什么不同？怎么处理不在词表中的词（OOV）？
A：Word2vec没法处理OOV。Fasttext和BERT都是能给OOV一个embedding的，方法是subword，也就是拆分了子词。但是BERT的词表是word-piece，用类似于BPE的方法，通过多轮迭代，无监督获得的；而Fasttext就是用n-gram切的。
Q：Word2Vec是如何实现在几万个向量中查询与query词向量最接近的向量的？
A：我一开始说gensim的w2v是有现成的api的most_similar()，但是内部实现方法不确定，肯定不是暴力法。可能是先排序，再类似于搜索树？面试官说可以往聚类的方面想。我就想到可以用聚类的逆操作。先随机生成k个点作为聚类中心，把几万个词向量分成k个类别，再用目标词向量和k个类别做相似度，找到最接近的类别。再对这个类别再分成k类，再分布做相似度计算，直到不能再分。面试官说差不多是这样，faiss、hnsw就是用来做这种事的。
做题：翻转链表和全排列 做题还算顺利。
总结： 面试官全程比较温柔，会给很多提示。最后说，现在hc比较少，但是前面的人可能会鸽。让我先进流程。
祝大家都能拿到满意的offer，祝非毕业年级同学们学有所成~
更多NLP＆其他方向面经可点击卡片关注👇
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef925b46225efe916a3eab3407936ca8/" rel="bookmark">
			微信小程序不同机型底部安全区域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微信小程序开发过程中，有些页面底部按钮是固定在底部的，还有如果是自定义tabbar也是需要固定在底部的，这里有两个问题：
不同机型的底部安全区域不同，如有些苹果手机底部有操作栏，这部分距离需要留出来否则会遮挡内容如果底部有固定定位元素，可能会导致内容区域底部部分元素被固定元素遮挡 问题1 解决方案 利用IOS新增的 env() 和 constant() 特性即可解决，开发者不需要自己动态计算高度，只需将如下CSS代码添加至样式中：
示例代码：
.bottom-wrap { position: fixed; bottom: 0; padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom); } 问题2 解决方案 内容区域设置 padding-bottom，如果底部固定定位元素的高度是 50px ，那么只需要设置css：
.content-wrap { padding-bottom: calc(constant(safe-area-inset-bottom) + 50px); padding-bottom: calc(env(safe-area-inset-bottom) + 50px); } 实现效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b37ee3481e4cbd805aaa7050f7fdcc14/" rel="bookmark">
			若依前端项目配置打包后可更改的请求接口地址url
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 因项目需要，打包后需要更改获取数据的mqtt的ip和端口号。
本项目是基于若依框架，所以项目目录如下：
1.在public文件夹下创建config.json文件，把后续要更改的ip或者baseUrl写在里面
2.在main.js里添加以下代码
// 引入axios import axios from 'axios' function getServerConfig() { return new Promise((resolve, reject) =&gt; { axios .get("/config.json") .then(result =&gt; { Vue.prototype.globalUrl = result.data.globalUrl; Vue.prototype.mqttHost = result.data.mqttHost; Vue.prototype.mqttPort = result.data.mqttPort; resolve(); }) .catch(error =&gt; { console.log(error); reject(); }); }); } async function init() { await getServerConfig(); } init(); 3.在封装mqtt的js文件里引用挂载在原型上的全局变量，注意：直接使用this.mqttHost会报错显示是undefined。
import Vue from 'vue' var vm = new Vue(); //引用的时候，在需要引用变量的地方使用vm.变量名，例如vm.mqttHost 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1727aa9eac03bcb29604d7b32052f5fd/" rel="bookmark">
			在Dll中创建线程？No，大错特错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天的时候，遇到一个面试 ，问我在Dll中的忌讳有什么？我回答的是不能在dll main函数中创建线程和加载动态库，然后下一个问题也接着来了，为什么不能？我说会造成死锁，但是具体的是什么原因造成的死锁，当时只记得看过《Windows 核心编程》，书中有过介绍，但是忘记了，无非就是因为同步问题，线程间会造成互相阻塞状态。具体是什么，今天回来分析一下。
Windows 核心编程中的原话是这样说的：
DLL 必须使用DllMain函数来对自己进行初始化。DllMain函数执行的时候，同一个地址空间的中的其他DLL可能还没有初始化，也就是没有调用其他DLL 的DllMain函数，所以我们应该尽量避免去使用从其他DLL中导入的函数。此外，还应该避免在DllMain中调用LoadLibrary（Ex）和FreeLibrary，因为这些函数可能会产生循环依赖。
为了更好的理解，这里先介绍一下DllMain 函数： BOOL WINAPI DllMain( _In_ HANDLE hInstance, _In_ ULONG fdwReason, LPVOID Reserved ) //dll main 函数 { printf("%p\r\n", hInstance); switch (fdwReason) { case DLL_PROCESS_DETACH: //0 { break; } case DLL_PROCESS_ATTACH: //1 { break; } case DLL_THREAD_ATTACH: //2 { break; } case DLL_THREAD_DETACH: //3 { break; } } return TRUE; } hInstance：该DLL示例的句柄。这个值表示一个虚拟的地址，DLL的文件映像就储存在这个位置。fdwReason：表示调用入口点函数的原因/Reserved：如果DLL是隐式加载的，那么该值不为零，否则为0。 DLL_PROCESS_ATTACH 1
当系统第一次将一个DLL映射到进程的地址空间的时候，会调用DllMain函数，并在fdwReason中传入DLL_PROCESS_ATTACH。若在第一次映射之后，调用LoadLibrary来载入一个已经映射过的DLL后，操作系统只会递增该DLL的引用计数，并不会调用DllMain。
系统中的某个线程必须负责执行DllMian函数中的代码。创建新的线程的时候，系统会分配进程地址空间并将.exe文件的映像映射到进程的地址空间中。然后，系统将创建进程的主线程，并用这个主线程来调用每个DLL的DllMain函数，同时传入DLL_PROCESS_ATTACH。当所有的已经映射的DLL 都完成了DllMain的调用，那么系统就会让主线程取开始执行.exe的C/C++运行时的启动代码，然后执行.exe的入口点函数（main或 WinMain）。
DLL_PROCESS_DETACH 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1727aa9eac03bcb29604d7b32052f5fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df33a115d8263c5fd3cc417016ad137a/" rel="bookmark">
			【Python机器学习】梯度下降法的讲解和求解方程、线性回归实战（Tensorflow、MindSpore平台 附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要全部源码请点赞关注收藏后评论区留言私信~~~
基本思想 迭代关系式是迭代法应用时的关键问题，而梯度下降（Gradient Descent）法正是用梯度来建立迭代关系式的迭代法。 机器学习模型的求解一般可以表示为：
其中，f(x)为机器学习模型的损失函数。
也称为无约束最优化模型。
对于无约束最优化问题argmin┬xf(x)，其梯度下降法求解的迭代关系式为：
式中，x为多维向量，记为x=(x^(1),x^(2),…,x^(n))；α为正实数，称为步长，也称为学习率；df(x)/dx=(■8(■8(∂f(x)/∂x^(1)&amp;∂f(x)/∂x^(2))&amp;■8(⋯&amp;∂f(x)/∂x^(n))))是f(x)的梯度函数。
梯度下降法的几个问题：
1）梯度下降法的结束条件，一般采用：①迭代次数达到了最大设定；②损失函数降低幅度低于设定的阈
2）关于步长α，过大时，初期下降的速度很快，但有可能越过最低点，如果“洼地”够大，会再折回并反复振荡。如果步长过小，则收敛的速度会很慢。因此，可以采取先大后小的策略调整步长，具体大小的调节可根据f(x)降低的幅度或者x前进的幅度进行。
3）关于特征归一化问题，梯度下降法应用于机器学习模型求解时，对特征的取值范围也是敏感的，当不同的特征值取值范围不一样时，相同的步长会导致尺度小的特征前进比较慢，从而走之字型路线，影响迭代的速度，甚至不收敛。
梯度下降法解方程 梯度下降法求解方程示例：为了迭代到取值为0的点，可采取对原函数取绝对值或者求平方作为损失函数。
在MindSpore中，通过mindspore.ops.GradOperation提供对任意函数式自动求导的支持。
在TensorFlow2中，通过GradientTape提供对自动微分的支持，它记录了求微分的过程，为后续自动计算导数奠定了基础。
部分代码如下
### 求方程的根 class loss_func(ms.nn.Cell): # 用方程的平方作为求导目标函数 def __init__(self): super(loss_func, self).__init__() self.mspow = ms.ops.Pow() def construct(self, x): y = self.mspow(x, 3.0) + self.mspow(math.e, x)/2.0 + 5.0*x - 6 y = self.mspow(y, 2) # 方程的输出的平方 return y x = ms.Tensor([0.0], dtype=ms.float32) for i in range(200): # 200次迭代 grad = GradNetWrtX(loss_func())(x) #print(grad) x = x - 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df33a115d8263c5fd3cc417016ad137a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33f05067ded7cf8b92680fd2fc99c174/" rel="bookmark">
			dhu 数据科学与技术 第6次作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 简答题（共2题，100分）
(简答题)
2012—2020年我国人均可支配收入（单位：万元）为[1.47, 1.62, 1.78, 1.94, 2.38, 2.60,2.82, 3.07, 3.21]。按照要求绘制以下图形。 （1）模仿例4-1和例4-3，绘制人均可支配收入折线图（效果如图4-6所示）。数据点用小矩形标记、黑色虚线，并用注解标出最高点，图标题为“Income”，设置坐标轴标题，最后将图形保存为jpg文件。
图4-6 2012—2020年人均可支配收入（单位：万元）
（2）模仿例4-2，使用多个子图分别绘制人均可支配收入的折线图、箱形图及柱状图（效果如图4-7所示）。
【提示】
（1）本实验准备数据时可以使用Series对象或DataFrame对象。
（2）创建的3个子图分别使用(2,2,1)、(2,2,2)和(2,1,2)作为参数。
（3）使用plt.subplots_adjust()调整子图间距离，以便添加图标题。
图4-7 多子图展示各年度人均可支配收入
High-speed rail.csv
import matplotlib.pyplot as plt from pandas import DataFrame import numpy as np import matplotlib # 1) zhfont1 = matplotlib.font_manager.FontProperties(fname="C:\\python\\SourceHanSansSC-Bold.otf") income=[1.47, 1.62, 1.78, 1.94, 2.38, 2.60, 2.82, 3.07, 3.21] data=DataFrame({'income': income},index=['2012','2013','2014','2015','2016','2017','2018','2019','2020']) plt.plot(income,marker = 's',linestyle = 'dotted',c='black') plt.ylabel("Income(RMB Ten Thousand)") plt.xlabel("Year") plt.title("2012-2020 年人均可支配收入", fontproperties=zhfont1) my_y_ticks = np.arange(0.0, 3.5, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33f05067ded7cf8b92680fd2fc99c174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efc696792e1698fea85e54999fb5be56/" rel="bookmark">
			在调用Scanner时的报错的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在调用Scanner时有时会报错,经常一头雾水,报错如下图所示:
这是因为idea在调用时导入错误导致
应该改为这样的:
import java.util.Scanner; 重新调用即可.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb671789c30ea44dcae01fab44faffe0/" rel="bookmark">
			pytest之命名规则和运行方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 默认规则2. 运行方式2.1 main()函数运行2.2 终端运行2.3 使用配置文件运行程序2.3.1 配置文件规则2.3.2 作用和运行规则2.3.3 配置文件格式2.3.4 参数详解-m 标记用例--html生成测试报告 3. 总结 在文章开始前，先了解一下本文章使用到工程结构情况，本栏会围绕该工程进行举例说明。
Test_project工程的根目录有两个模块（主函数main()模块，test_token.py模块）和一个testcase包，testcase包中新建了名为test_login.py模块。
test_token.py模块下有一个test_01的方法，test_login.py模块新建TestLogin类，类包含了test02和test03两个方法。
1. 默认规则 pytest的命名默认规则如下：
1. 模块名必须以test_开头或以_test结尾（如，test_login.py） 2. 测试类必须以Test开头，并且不能有init方法（如，class TestLogin:） 3. 测试方法必须以test开头（如，def test_01()或test02()） 2. 运行方式 pytest运行方式主要有三种，main()函数运行、终端运行和main()结合配置文件方式运行。
2.1 main()函数运行 （1）运行所有测试用例：pytest.main() （2）运行指定路径的用例：pytest.main( ["./路径"] ) （3）运行指定模块的用例：pytest.main( ["模块名.py"] ) （4）运行指定用例：pytest.main( [ " ./路径/模块名：：类名：：方法"] ) main()函数在测试模块中可以省略，在任意一模块中有主函数，满足条件的所有测试用例均可以执行。因此，常常在项目中单独创建一个模块来存放main()函数的代码。
【注】在图中指定只执行test_login.py模块时，前面还增加了模块对应的路径，若不增加，程序无法查询到模块。
2.2 终端运行 （1）运行所有测试用例：pytest （2）运行指定路径的用例：pytest ./路径 （3）运行指定模块的用例：pytest 模块名 （4）运行指定用例：pytest ./路径/模块名：：类名：：方法 没有写main()函数时，可以在pycharm的终端窗口运行测试用例。
在终端运行程序时，需要注意测试用例所在的目录。当测试用例不在根目录时，需要将路径切换到用例模块所在路径，方法是使用cd 命令。
cd命令格式为：cd 路径
如下图，执行testcase包下的test_login.py模块的用例时，需要切换到testcase路径下。
若执行test_login.py模块下的test02方法，则如下图所示。
clear清除终端显示信息 2.3 使用配置文件运行程序 2.3.1 配置文件规则 文件名：pytest.ini。文件名是固定的，不允许更改 存放路径：必须放在根目录 编码格式：ANSI 或UTF-8无 BOM格式编码。可以使用Notepad++修改编码格式，即，点击工具栏“编码(N)”，选择编码格式 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb671789c30ea44dcae01fab44faffe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/671fbe4ad87137617e01a0ab2bc57be7/" rel="bookmark">
			精准医学中的深度学习和影像组学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		影像科正在经历一种范式转变，即使用人工智能与机器集成以及深度学习与影像组学更好地定义组织特征，从而实现计算机科学与影像学的共生关系。研究的目标是使用集成的深度学习和具有影像学参数的影像组学来为患者进行个性化诊断。本文概述了影像学精准医学背景下历史和当前的深度学习和影像组学方法。 本文通过“深度学习”、“影像组学”、“机器学习”、“人工智能”、“卷积神经网络”、“生成对抗网络”、“自动编码器”、“深度信念网络”、“强化学习”和“多参数 MRI'在 PubMed、ArXiv、Scopus、CVPR、SPIE、IEEE Xplore 和 NIPS 中进行文献检索。
结论：总而言之，深度学习和影像组学都是两种快速发展的技术，两者将在未来联合起来产生一个统一的临床决策支持框架，有望彻底改变精准医学领域。本文发表在expert review of precision medicine and drug development杂志。
1、介绍
影像成像方法用于扫描身体的不同区域，以检测和表征潜在的异常病理并帮助临床诊断。这些影像成像程序可以通过局部或全身扫描产生大量复杂的数字成像数据，这会使“读取和解释”图像数据变得非常具有挑战性。计算机科学的发展将导致影像学在医学领域使用先进的计算方法发生范式转变 [1–7].这些计算方法包括先进的机器和深度学习算法 [8,9]加上图像纹理的定量测量，称为影像组学[10–13].通过结合这些计算方法，未来的影像科室将形成计算机科学家和影像科医生（人类专家）之间的独特合作。这种合作将使算法能够在影像学诊断决策制定的各个方面协助影像科医生，例如：识别、分割、不同组织类型的表征以及优先诊断。例如，大脑、胸部、腹部、骨盆和乳房等大型成像数据集可以通过使用深度学习方法快速分类来分为不同的组，影像科医生首先查看潜在的“更差”病例，从而增加影像科医师的准确率和信心。可以进一步开发使用机器学习的其他数据挖掘方法，以将影像学参数与使用电子健康记录从不同来源（如病理学和临床病史）提取的其他信息相结合 [14–17].这些整合的数据类型，将使临床医生更全面地了解患者的健康状况，有助于更准确的诊断并提高对疾病复杂性的理解。当数据汇集在一起时，可以实现个性化的治疗计划和精确的疾病预后，如图1所示.计算影像学的目标是提取图像中的所有定性和定量信息，并开发潜在的非侵入性生物标志物，用于检测和表征患者的疾病。深度学习和影像组学是实现这一目标的计算放射学的新兴领域。
深度学习是一个新的研究领域，涉及受我们大脑中的生物神经网络启发而开发的深度人工神经网络 [4,6,18–42].在影像学中，深度神经网络与生物神经网络一样，试图学习影像学数据的内在表示，例如，在MRI中，诸如脑脊液等流体在 T1WI上是暗的，而在T2WI上是亮的。此信息可以训练深度学习算法来识别模式并执行准确的分割。深度学习在多个领域都取得了优异的成绩，例如。对象检测和识别、文本生成、音乐创作和自动驾驶等等 [1,2,43–49].近年来，深度学习已成为计算机辅助临床和影像决策支持领域的一个活跃研究，取得了一些出色的初步成果以及最新的研究发现。
影像组学是一种纹理数学结构，可以捕获感兴趣组织的空间外观（形状和纹理）在不同类型的图像上使用纹理[10–13,50–53].最近还有一篇相关的综述也说明纹理特征在某些应用中与组织生物学相关 [影像组学特征的生物学意义 54].传统意义上，影像组学特征提供有关放射图像感兴趣区域内的灰度模式、像素间关系、形状和频谱的信息。[50–53,55,56].
将影像组学或深度学习算法从研究成功转化为精准医学临床实践的主要障碍之一就是可解释性。例如，在影像组学中，如果熵（一阶，它是异质性/无序性的量度）或灰度共生矩阵 (GLCM) 熵（基于灰度级相互关系的异质性/无序性的高阶量度某些社区）特征被测量为 6.5，如果这些指标没有控制或正常组织熵值，则很难将生物学意义附加到该熵值。影像组学指标的相同值同质或者异质的判断取决于所选的箱子数量、ROI 的大小以及其他预处理步骤，例如图像过滤，这些都会对值产生影响（请参阅以下）。
同样，由于深度学习本质上是一个“黑匣子”，当该方法将底层组织分割并预测为恶性或良性时，深度学习不会提供其预测背后的解释。医生的可解释性将基于算法以及他们是否会“信任”结果，这是目前的主要挑战。本文回顾了影像组学和深度学习技术，概述了目前最先进的精准医疗算法及其局限性，并对这两种技术在精准医疗中的潜在未来进行了展望。
图1 个性化放射诊断和预后的概念计算放射学框架。
该框架有三个主要组成部分——图像分割、特征提取和综合临床决策支持模型。
2、深度学习
近年来，随着高级优化技术的发展和计算效率的提高，深度学习技术重新流行起来。深度学习已经开始在现代社会的许多不同方面发挥不可或缺的作用，并在各种领域产生了出色的成果，例如物体检测和识别、文本生成、音乐创作和自动驾驶等 [2,43–46,48,49].先进的深度学习将在不久的将来使用计算机辅助临床和放射决策支持对精准医学产生影响。这些方法将概述用于训练、测试和验证临床测试的新方法，以更好地整合医学信息，并为诊断提供新的可视化工具。我们将重点关注深度学习方法的概述和最新技术水平。
从历史上看，深度学习方法是计算机科学中机器学习算法的一个子集。简而言之，机器学习的目标是学习特征并将这些特征转化为类标签以进行分割或分类。机器学习算法在本质上是有监督的或无监督的，线性的或非线性的[57].深度学习和传统机器学习算法之间的主要区别在于，深度学习算法不需要中间特征提取或工程步骤来学习输入 x（例如，放射图像上的灰度强度值）和相应的标签 y（例如，与这些强度值对应的组织类型）。
从概念上讲，机器学习算法使用概率分布 p 在 x 和 y 上对输入 x 和标签 y 之间的关系进行建模，一般来说，学习算法可以根据 p [57,58]。生成模型学习联合概率分布 (x, y) 以估计后验概率 p(y|x)。生成深度学习算法的一些例子包括：生成对抗网络、变分自动编码器和深度信念网络 [40,59]。相比之下，判别模型直接估计后验概率 p(y|x) 而无需计算中间环节概率分布。换句话说，判别模型学习 x 和 y 之间的直接映射。卷积神经网络、堆叠自动编码器和多层感知器是判别式深度学习算法的典型示例 [45,46] 。如果问题要求我们只根据 x 预测标签 y，那么判别模型可能是更好的选择，因为它们不关心 (x, y) 的建模，更有效地为 P(y| x) 建模参数，从而产生一个准确率更高的分类器。但是，如果输入 x 包含大量缺失值或数据点并且需要数据插补，则可能无法使用判别模型。此外，生成模型允许生成新的合成数据并模拟输入数据中的不同关系。例如，如果目标是将病变分类为良性或恶性，则判别式深度学习可能是更好的选择。然而，如果我们的目标是识别病变的内在特征并模拟它们在患者群体中的分布，那么更好的算法选择可能是生成式深度学习算法之一。下面讨论应用于精准医学的常用判别式和生成式深度学习算法。图2简要介绍了深度学习领域的主要进展历史和时间表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/671fbe4ad87137617e01a0ab2bc57be7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d04be0a87a16643f7eb27b25453d38a/" rel="bookmark">
			redis是单线程为什么速度还快
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.完全基于内存，绝大部分请求是纯粹的内存操作，非常快
2.数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的
3.采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
4.使用多路I/O复用模型，非阻塞IO，“多路”的意思是多个网络连接，“复用”的意思是复用同一个线程。采用多路I/O复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且redis在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响redis性能的瓶颈，主要由以上几点造就了redis具有很高的吞吐量
5.使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，redis直接自己构建了vm机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bec0de4bc4d3c3c72e66903b5d2abcb9/" rel="bookmark">
			Postgresql如何创建索引，有什么技巧？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 PostgreSQL 中，可以使用 CREATE INDEX 语句来创建索引。
创建索引的语法如下：
CREATE INDEX index_name ON table_name (column_name); 其中，index_name 是索引的名称，table_name 是要创建索引的表的名称，column_name 是要创建索引的列的名称。
例如，如果要在 users 表的 name 列上创建索引，可以使用以下语句：
CREATE INDEX name_index ON users (name); 在创建索引时，有几点需要注意：
索引是一种对数据库表中数据进行排序的数据结构，可以加快查询的速度。但是，索引也会消耗内存空间，并且在对表进行修改、插入、删除操作时，会增加额外的计算量，所以不能滥用索引。
通常情况下，只有经常被用来查询的列才需要创建索引。
对于数据量较小的表，通常不需要创建索引。
对于较大的表，可以考虑创建多列索引，即在多个列上创建索引。这样可以进一步提升查询速度。
在创建索引之前，应该先对表中的数据进行排序，以便索引能够更有效地工作。
对
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c67244030eb43b5e1932bb781cdfb556/" rel="bookmark">
			blender源代码编译运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实在blender官网上已经给出了编译步骤https://wiki.blender.org/wiki/Building_Blender/Windows，由于在源码编译的过程中还遇到了很多问题，特此记录一下。
文章目录 前提准备代码下载1. blender源码下载2. lib下载 编译 前提准备 Visual Studio2019或者2022(至少选择【Desktop Development with C++】)，我自己是下载的2022版，这里记录了下载的方法及过程https://blog.csdn.net/changyana/article/details/128356682SVN: 我刚开始按照官网的指示下载了SlikSVN，但是最后过程中发现不会用，又卸载了SlikSVN，最后是下载了TortoiseSVN进行使用
https://tortoisesvn.net/downloads.html，这个链接页面有TortoiseSVN的软件安装包，往下滑还有相应语言配置的安装包，建议下载一个中文语言的安装包
如图，这是我下载的两个安装包，分别运行进行安装就可以啦
git（安装时要选择add Git to your PATH）CMake(安装时要选择Add CMake to the system PATH for all users)，由于我之前安装了Qt，里边已经自带下载了cmake，所以本次没有单独去安装。 代码下载 1. blender源码下载 首先就是去github上下载源码：https://github.com/blender/blender
建议使用git命令来下载，而不是直接下载压缩包（这两者的区别是直接下载压缩包的话不利于后续与别人代码分享）
首先就是新建一个专门放blender代码的文件夹，然后进入该文件夹下进行下载blender源码
下载指令git clone https://github.com/blender/blender.git
然后就可以看到已经下载下来的源码。
2. lib下载 然后就是下载lib
打开cmd命令行，将目录切换至克隆的blender文件夹下，执行make update，他就会提醒你缺少lib，然后输入y进行lib的下载。
之后它会报错，【执行上下文错误：远程主机强迫关闭了一个现有的连接】。然后询问我，retry?我输入了y，重试了几次还是报这个错误，所以确定不是网络问题，所以我就输入了n让它结束。
然后就是利用上述下载TortoiseSVN进行手动下载lib。
具体操作如下：
进入lib\win64_vc15文件夹下，注意这个lib文件夹一定要与官网上下载的blender文件夹同级，如图：
如果没有lib文件夹，就自己建一个lib\win64_vc15文件夹。进入该文件夹下，如果里边有内容，就把所有的内容都删除
然后右键，选择svn checkout（就是这里，之前用的官网里的SlikSVN没有这个svn checkout的可视化选项，然后就不知道该怎么操作了，所以就卸载了SlikSVN，安装了TortoiseSVN）
打开之后输入如下网址
https://svn.blender.org/svnroot/bf-blender/trunk/lib/win64_vc15
然后就是等待lib的下载。
不过，由于lib太大了，总是会下载失败。。
解决办法就是：先clear up，再update，具体操作过程，请看我这篇文章：https://blog.csdn.net/changyana/article/details/128364335
然后等它完成！
文件下载好后，就是编译过程
编译 这里使用的是cmake进行编译，关于cmake是否下载成功，win+r输入cmd打开命令行，然后输入cmake --version如果能出现版本信息就表示具有cmake。
如图，在blender源码的文件夹下
在上方输入cmd，按回车打开命令行
可以看到打开的命令行路径刚好就在该文件夹下
然后输入make进行编译
以为会正常进行，但是自己终止了，编译失败。
然后进了下官网https://wiki.blender.org/wiki/Building_Blender/Windows，换了另一种编译方式，嘻嘻。
就在blender文件的目录下，git bash，然后运行.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c67244030eb43b5e1932bb781cdfb556/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6185fc0ff52123144e9b88dd46d3088a/" rel="bookmark">
			gcc与makefile常用操作（绝对常用，也绝对够用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		makefile与gcc常用操作 一、温故知新1、可执行程序的生成过程2、gcc的常用操作 二、make操作三、编写Makefile文件时常用操作注意：在Makefile文件中 空格和缩进是完全不同的，不可以相互转换。1、框架格式2、举例3、优化1). 伪目标 .PHONY2). $ 和 @ 符号的作用3). 变量注意：变量种类 4). 匹配模式 4、Makefile中的条件判断 ifeq ifdef使用：注意事项： 5、Makefile中的循环 foreach6、Makefile中的赋值 = 和 := 总结 一、温故知新 1、可执行程序的生成过程 2、gcc的常用操作 gcc/g++ 命令的基本格式为 gcc -[选项] [文件名] 例如： gcc -c -I /home/inc/ test.c -o test.o gcc -I /home/inc/ -O2 -g3 main.c test.o -o main 二、make操作 make 的基本格式为： make -[选项] [文件名] 例如： make -v make -n make -C /home/erc/ -f Makefile02 -s 三、编写Makefile文件时常用操作 下面会着重介绍编写Makefile文件时经常用到的操作，对于makef的执行规则等更细致全面的知识可以参考Makefile教程（绝对经典，所有问题看这一篇足够了）
注意：在Makefile文件中 空格和缩进是完全不同的，不可以相互转换。 1、框架格式 目标1:依赖 命令 目标2:依赖 命令 目标3:依赖 命令 2、举例 假如说我现在有这么一个程序需要编译：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6185fc0ff52123144e9b88dd46d3088a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15ff6647b5bc8b8a365eccf7d1b739d0/" rel="bookmark">
			Anaconda命令参考，安装tensorflow-gpu、Cuda、cudnn，pytorch、jupyter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Anaconda图形界面打不开了，使用Anaconda Prompt命令行同样干活。
1 管理conda
(1) 查看conda版本
conda --version
(2) 升级conda自身
conda update -n base -c defaults conda
(3) 升级conda当前环境所有包
conda clean --all
conda update --all
(4) conda设置国内源
清华的源：
conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/win-64
注意是http，不是https，url后面要带上平台
(5)显示已安装的源
conda config --show channels
(6) 删除已安装源
conda config --remove channels
(7) 安装包
conda install package=version
(8)查看已安装的包&amp;查找可安装包
pip list 或 conda list
conda search somePackage
(9) 删除环境&amp;移除包
删除someEnv配置环境及其中的包
conda remove -n someEnv --all
删除someEve中的packageName
conda remove -n someEnv packageName
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15ff6647b5bc8b8a365eccf7d1b739d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72ad8d0b24ee378929354d106dc6ca9b/" rel="bookmark">
			Virtex7 Microblaze下DDR3测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创 猫叔 傅里叶的猫 这篇文章我们讲一下Virtex7上DDR3的测试例程，Vivado也提供了一个DDR的example，但却是纯Verilog代码，比较复杂，这里我们把DDR3的MIG的IP Core挂在Microblaze下，用很简单的程序就可以进行DDR3的测试。
但这个工程只是一个简单的测试用例，实际应用中不会这么用的，因此传输效率太低。
新建工程，FPGA选型为xc7v690tffg-1761。
1. 创建Block Design，命名为Microblaze_DDR3。
2. 在bd文件中加入Mircoblaze。
3. 点击Run Block Automation
4. 按照默认配置，确定即可。
5. 出现下面的界面。
6. 添加MIG的IP Core
7. 开始配置DDR，选择Create Design.
8. 这一步是选择Pin脚兼容的FPGA，我们不做选择，直接Next。
9. 选择DDR3.
10. ①选择DDR的工作频率，我们这里让DDR3的频率为1600MHz，所以时钟频率是800MHz；
②选择器件，根据实际情况来选择即可；
③数据位宽，也是根据板卡上的实际位宽进行选择；
④默认即可。
11. 选择AXI总线的位宽，这里我们选择512.
12. ①选择输入时钟频率，虽然DDR的工作时钟是800MHz（在第10步中选择），但我们可以输入一个低频时钟，然后MIG的IP Core中会倍频到所需频率。
②MIG的IP Core默认会输出一个200MHz的时钟，如果还需要其他的时钟输出，可以在这里选择。其他选择默认即可。
13. ①选择输入时钟的方式，这里的输入时钟就是我们上一个页面中的设置的200MHz的输入时钟，如果选择差分或单端，则输入通过FPGA的管脚输入200MHz时钟到MIG的IP Core；如果选择No Buffer，则可以通过FPGA内部的MMCM输出一个200MHz时钟到MIG；这里我选择了No Buffer；
②选择参考时钟的方式，参考时钟频率固定是200MHz，如果选择如果选择差分或单端，则输入通过FPGA的管脚输入200MHz时钟到MIG的IP Core；如果选择No Buffer，则可以通过FPGA内部的MMCM输出一个200MHz时钟到MIG；如果在前一个页面中选择了输入时钟频率是200MHz，则这边会出现一个Use System Clock的选项，因为此时两个时钟频率是相同的嘛。这里我选择了Use System Clock；
③设置输入复位信号的极性，这个要特别注意，尽量选择高有效，因为无论我们选择高复位还是低复位，它的端口名都叫sys_rst，会让人直观就觉得是高复位。我第一次使用时，就没注意到这个选项，默认为低，但在MIG的端口上看到sys_rst这个名字我以为是高有效，结果DDR一直不通。
（备注：对于绝大多数的Xilinx的IP，如果是低有效的复位，端口名字中肯定是有N这个标志的）
14. 这个页面不需要操作。
15. 下面开始分配管脚，我比较习惯于选第二个，无论是第一次分配还是后面再重新分配。
16. 在这一页，可以根据原理图一一分配管脚；如果有现成的xdc/ucf文件，可以直接通过Read XDC/UCF读入，然后再选择Validate验证管脚分配是否正确。
如果Validate成功，则会提示下面的界面。
17. 如果在第13步中，选择了差分或单端输入，则这里会出现下面第一个图；如果选择了No buffer，则这里会出现第二个图。很容易理解，如果选择了通过外部管脚输入时钟，那这里就是让选择具体的管脚。并不是所有的MRCC或者SRCC管脚都可以选的，只能选择跟DDR管脚同一片区域的（比如DDR放在了Bank31 32 33，那么这里的时钟输入管脚就不能选择Bank15）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72ad8d0b24ee378929354d106dc6ca9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f438b74d0fcc955df83d70be6edca8a/" rel="bookmark">
			DevOps实战系列【第七章】：详解Docker私服Harbor篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人亲自录制全套DevOps系列实战教程 ：手把手教你玩转DevOps全栈技术
Harbor私服搭建 讲完Nexus3再来看下harbor，其实大同小异，只不过harbor的管理要比Nexus3更专业、功能更完善，大家按需选择即可，Nexus的优势是他能和Maven仓库复用同一个服务器。
官网：https://goharbor.io/docs/2.6.0/install-config/installation-prereqs/
其实Harbor更适合拿一台虚拟机或物理机来安装，当然也可以集成到k8s，但如果是单台docker服务下安装，就有些不太合适了，
不合适的原因是Harbor需要docker-engine、docker-compose、openssl的支持，即要在装有这些工具包机器上安装Harbor。
有3种安装方案： 直接安装在宿主机[复用docker环境][演示https方式]将harbor安装到容器：手动构建镜像，镜像中安装harbor需要的环境(docker环境等)[演示http方式]将harbor安装到容器：类似jenkins那样，将需要的环境从宿主机映射到容器(该方式我们不再演示) 下边我们先来演示容器中单独部署Harbor仓库
Docker容器部署[http协议版] 下载安装包：从官方(https://github.com/goharbor/harbor/releases)下载harbor稳定版，
离线安装包：harbor-offline-installer-v2.6.2.tgz，大约有769M，如果大家无法访问可以找我索取。
目录：我们依然按照老规矩，将文件拷贝到/docker/harbor目录，目录结构如下，所有资料下文都有。
1.将离线安装包拷贝到目标目录： /docker/harbor/harbor-offline-installer-v2.6.2.tgz
2.事先准备一个harbor的配置文件：harbor.yml 值得关注的属性如下，其他忽略【此处只需要修改hostname和注释掉https，其他默认即可】
# 因为我要宿主机映射访问，所以此处使用宿主机ip，即访问harbor时使用10.10.1.199 hostname: 10.10.1.199 http: port: 9090 # 我们优先演示http协议，所以注释掉https(注释掉) #https: #port: 9443 #certificate: /cert/certificate/path # 生成的证书目录 #private_key: /cert/private/key/path # harbor管理员admin的密码(保持默认) harbor_admin_password: Harbor12345 # 默认存储数据目录 data_volume: /data # 日志配置：日志级别、输出目录(保持默认) log: level: info local: location: /var/log/harbor 3.准备一个docker的配置文件：/etc/docker/daemon.json 主要是把镜像加速和信任列表创建好，否则最好映射到宿主，因为毕竟是容器，删除后容易丢失。
"registry-mirrors": [ "https://mtu7rhzd.mirror.aliyuncs.com", "http://hub-mirror.c.163.com", "https://docker.mirrors.ustc.edu.cn", "https://registry.docker-cn.com" ], "insecure-registries":[ "10.10.1.199:9082", "10.10.1.199:9083", "10.10.1.199:9090" ] 4.创建Dockerfile镜像文件：/docker/harbor/Dockerfile 此处使用阿里云的yum源安装docker，也可以用官方：https://download.docker.com/linux/centos/docker-ce.repo
FROM centos:centos7 LABEL maintainer="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f438b74d0fcc955df83d70be6edca8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce2c21afa22d86d967b63bbb32f496ea/" rel="bookmark">
			AD20的最全安装步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标 在电脑上快速安装AD20
学习内容： 1.下载网址：
AD20:
链接：https://pan.baidu.com/s/1vz9ODTTggdfxKs21KXrWFQ 提取码：0qsd 2.安装步骤
百度网盘下载安装包到电脑上，然后解压文件，解压密码如下
密码：rjaz （1）因为我下载安装包安装到的是E盘新建了一个AD20文件夹，所以有两个AD20文件夹。所以在E盘打开，找到E:\AD20\AD20\Altium Designer 2020\setup\AltiumDesigner20Setup.exe。
备注：.exe为文件扩展名
文件扩展名打开方式：点击查看-------点击显示----------点击文件扩展名，即可。
（2）右击AltiumDesigner20Setup.exe，以管理员身份运行。
（3）打开后允许安装，点击next
（4）选择语言，我这里选择的是中文Chinese，如果想锻炼英语学习能力，可以自由选择语言。然后点击 I accept the agreement。然后点击next
然后出现这样的界面
​​
继续点击next。
（5） 修改安装路径.
这里的安装路径是用来存放工程文件。
我这里是在E盘里面新建了一个AD21空的文件夹，两个文件尽量安装放在同一个空的文件夹里里面。
如果两个文件夹不一样，并且文件夹不为空的话，就有可能无法继续下一步安装，无法点击next。
解决办法：建立一个新的空文件夹来存放两个工程文件。
（5）这个是用户改善计划的一些条款
点击yes，继续next
出现下一个界面，继续点击next，就会安装。
（6）取消勾选这个Run Altium Designer,点击Finish，安装成功。
安装成功后，桌面上不会出现快捷方式，需要进行如下步骤，可以在桌面上添加快捷方式，并且使用。
（7）打开解压后的“Altium Designer 2020”文件夹中的“Crack”文件夹，对文件夹“shfolder.dll”进行复制操作
（8）因为我的电脑是win11系统，大家可以自行参考。
点击开始按钮，或者按键盘上的win键（alt边上的按键），出现如下界面后，点击做上面的更多应用。
然后将下列的AltiumDesigner拖动到桌面即可创建桌面的快捷方式。
创建快捷方式成功之后，右键点击图标，选择打开文件所在的位置
直接粘贴上一步复制的“Altium Designer 2020”文件夹中的“Crack”文件夹，文件夹“shfolder.dll”
（9）双击桌面快捷方式图标，进去之后，点击“Add standalone license file”。 选择文件夹中的“Crack”文件夹中“licenses”文件夹中的任意一个文件，然后点击“打开”
点击右上角的设置按钮
选择“use localized resources”点击如下图所示
然后点击“OK”。
然后右上角关闭该软件之后重新打开。
就可以完成汉化。
这就是安装成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e2833453053a3671cd01f4b63173244/" rel="bookmark">
			软件工程复习知识点汇总（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第一章 软件工程概述
1.1软件
1.2软件危机
1.2.1软件危机的表现与原因
1.2.2软件危机的启示
1.3软件工程
1.3.1软件工程的概念
1.3.2软件工程研究的内容
1.3.3软件工程目标和原则
1.3.4软件工程的发展
1.4软件开发方法
第二章 软件过程
2.1软件过程概述
2.2软件生命周期
2.2.1软件生命周期的概念
2.2.2传统软件生命周期的各个阶段
2.3软件过程模型
2.3.1瀑布模型
2.3.2快速原型模型
2.3.3增量模型
2.3.4螺旋模型
2.3.5喷泉模型
2.3.6基于组件的开发模型
2.3.7统一软件开发过程模型
2.3.8敏捷过程与极限编程（XP）
第三章 可行性研究及需求分析
3.1可行性研究
3.1.1项目立项概述
3.1.2可行性研究的内容
3.1.3可行性研究的步骤
3.2需求分析
3.2.1需求分析的任务
3.2.2需求分析的步骤
3.2.3需求管理
3.2.4需求分析的常用方法
第四章 结构化分析
4.1结构化分析概述
4.2结构化分析方法
4.2.1功能建模
4.2.2数据建模
4.2.3行为模型
4.2.4数据字典
4.2.5加工规格说明
第五章 软件设计
5.1软件设计的基本概念
5.1.1软件设计的意义和目标
5.1.2软件设计的原则
5.1.3软件设计的分类
5.2数据库结构设计
5.3用户界面设计
第一章 软件工程概述 1.1软件 软件是计算机中与硬件相互依存的另一部分，软件包括程序、数据及相关文档的完整集合。
软件的特点：逻辑实体、生产与硬件不同、不会磨损和老化、依赖硬件、手工开发为主、成本高，风险高、涉及社会因素
1.2软件危机 1.2.1软件危机的表现与原因 表现：在软件开发的过程中，会经常出现一些不能按时完成任务、产品质量得不到保证、工作效率低下和开发经费严重超支等现象。计算机软件的开发、维护和应用过程中普遍出现的这一些严重的问题便是软件危机。
原因：
忽视软件开发前期的调研和需求分析工作
缺乏软件开发的经验和有关软件开发数据的积累，使得开发计划很难制定。
开发过程缺乏统一的、规范化的方法论指导
忽视与用户、开发组成员间的及时有效的沟通
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e2833453053a3671cd01f4b63173244/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47a34a9d6ce8f6ecb97788888b01c260/" rel="bookmark">
			JavaFX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：JavaFX是继awt和swing之后新出来的图形界面设计，全方面胜过它们。 一、步骤
1.开发环境，JDK（1.8以上）
2.数据库随便来一个就行（写系统需要，如果只是单纯的玩布局就不需要），建议mysql、sqlserver、oracle等，但是一定要记得导驱动jar包，会maven的朋友也可以使用maven
3.dao分层（一般有四个包）
3.1.application(启动包)
3.2.entity(实体包)
3.3.dao(dao包)
3.4.utils(jdbc帮助类以及一些公共用到的方法的类等等存放的帮助包)
4.先继承我们的Application（javafx的启动类，切记不要导错包）
5.然后重写我们的Application的唯一一个抽象方法public void start（Stage primaryStage）;
6.写出main方法程序入口，在方法体中写入Application.launch(args);
注意：args可以不写进去，也可以直接launch();当然继承了也可以用我们自己的类名.launch();这些都是可以的
7.然后在start方法中写出primaryStage.show();如果没写这一步，就不会有任何的反应，很多人都会觉得自己代码写错了，其实是这步没写。这是最重要的！
8.首先是Stage（舞台）里面一定要放入Scene（场景），Scene（场景）里面一定要放入Pane（布局），Pane里不一定要放入Node（节点或控件），只要完成Stage&lt;--Scene&lt;--Pane，
代码：
Pane pane=new Pane();-----绝对布局 Scene scene=new Scene(pane,900,900);---new一个场景对象 primaryStage.setScene(scene);---设置场景 恭喜你，这三步完成那你就完成了一个窗口了！
二、布局（Pane）
通用常见的方法：
2.1流式布局（FlowPane）
Button login=new Button("登录"); Button exit=new Button("退出"); FlowPane fp=new FlowPane(); //fp.getChildren().add(login); //fp.getChildren().addAll(login,exit); 这就是流式布局的一个基本用法，getChildren()方法是Pane给予子类的一个拿到ObservableList&lt;Node&gt;的一个集合，既然是集合就能add进去。但是流式布局会随着舞台大小的宽度布局，若一行排不下，则会自动换行继续排版，所以这里非常不方便，需要设置合适的舞台宽度并且不允许用户拖拽舞台的大小，需要这个方法：
primaryStage.setResizble(false); 流式布局的排版默认居左上角，顺序与add时的顺序有关
2.2边框布局(BorderPane)
该布局非常特殊，只有上（Top）、下（Bottom）、左（Left）、右（Right）、中（Center）个区域，并且每个区域只能放一个东西，这里我们想利用边框布局完成高难度的窗口就需要用到布局的嵌套了：
BorderPane bp=new BorderPane(); //上：下拉框和查询文本框和查询按钮 ComboBox cb=new ComboBox(); TextField selecttf=new TextField(); Button select=new Button("查询"); HBox h=new HBox(20,cb); h.getChildren().addAll(selecttf,select); h.setAlignment(Pos.CENTER); h.setPadding(new Insets(20,0,20,0)); bp.setTop(h); 这里一般都是用这种形式加入到边框布局的上方，其他方位同理
2.3垂直布局（VBox）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47a34a9d6ce8f6ecb97788888b01c260/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9173e121930f8955e30b2677bfd9548/" rel="bookmark">
			Compose Desktop 初体验之踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从 0 到 1 搞一个 Compose Desktop 版本的玩天气之踩坑 大家好，好久不见，接下来一段时间我会系统性地写一套关于 Compose Desktop 的文章，带大家从头到尾写一个桌面版的天气应用，并且打好包让别人也可以进行使用，接下来就开始吧！先来看下最终的实现效果吧！
视频
效果是不是挺好？哈哈哈！
其实作为一个安卓开发来说，当运行起第一个桌面版程序的时候内心突然感觉回到了最开始学习编程的时候，那种感觉就好像一个多年未见的老友对你说：久违了！特别是使用的技术还都是安卓开发的技术，只是有一些平台原因需要稍做修改的地方就能开发出一个完整的桌面版软件，内心还是非常激动，非常地有成就感，这种感觉太舒服了！
缘起 Compose 为什么会搞 Compose Desktop，这还得从 Jetpack Compose 说起：Google 从 2017 年开始立项开搞 Compose 到第一个正式版本用了四年的时间，那么久的时间，投入了那么多的人力，以及后面投入了大量经费宣传，无一不在告诉安卓开发者 Compose 很重要，这也是之后安卓开发的新方向！所以当第一个 alpha 版本的 Compose 出现的时候我就坐不住了，立马加上依赖尝试了下！刚开始写的时候感觉有点奇怪，毕竟从之前的开发模式变为了全新的声明式开发，但写了不到一周就感受到了 Compose 的优势，编写起来太快了，动画实现起来也太简单了，声明式编程也太方便了。。。。
其实 Compose Desktop 出现的也很早，Jetpack Compose 出来没多久它也就出来了，有很多同行在 Compose Desktop 出来第一个 alpha 版本的时候就开始研究，不过由于我是做安卓开发的，日常工作也不会涉及到桌面开发，况且 Compose Desktop 是 Jetbrains 开发的，并不 Google 开发的，毕竟是模仿 Jetpack Compose 的，未来两边的 API 都有可能对应不上，所以也就一直没有关注。
但是到后来转折点来了，公众号：《Android 开发者》在 2022 年 11 月 30 日早上发了一篇文章，名为：“Jetpack 更新一览 | 2022 Android 开发者峰会”，这篇文章的前半部分没有什么新鲜感，因为这些库我也一直在用，也经常关注着新版本和新功能，但看到文章最后的时候，里面有一段话是这么写的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9173e121930f8955e30b2677bfd9548/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c2128e33941cb56221efad2c7f0c0a4/" rel="bookmark">
			Compose Desktop 初体验之打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从 0 到 1 搞一个 Compose Desktop 版本的玩天气之打包 大家好，前两篇文章大概介绍了下上手 Compose Desktop 和自定义绘制时遇到的一些问题，项目的最终实现效果如下：
视频
代码写好了，该弄的动画也弄了，该请求的网络数据也请求了，该实现的效果也都实现好了，但是！！！咱们得打包出来啊！不打包出来别人如何使用呢？难道说别人想用你开发的桌面应用，结果你给他说你先下载一个 IntelliJ Idae ，然后下载下我的源码，之后把环境配置好，最后运行就可以了！如果下次再想用的时候再运行一次就好了！
这说的是人话嘛😂，肯定不能这样，所以一定要打包！由于 Compose Desktop 不止可以运行在 Mac 中，还可以运行在 Windows 和 Linux 中，所以需要打多个包。那使用 Compose Desktop 应该如何打包呢？且听我慢慢道来！
基本用法 插件中的基本配置单元是一个 application ，application 是什么呢？在第一篇文章中也提到了，就是在 build.gradle.kts 文件中的代码，咱们再来看下：
compose.desktop { application { mainClass = "MainKt" nativeDistributions { targetFormats(TargetFormat.Dmg, TargetFormat.Msi, TargetFormat.Deb) packageName = "Demo" packageVersion = "1.0.0" } } } 一个 application 定义了一组最终二进制文件的共享配置。换句话说，application DSL 允许将一堆文件连同 JDK 分发包打包成一组各种格式（.dmg、.deb、.msi、.exe等）的压缩二进制安装程序。
该插件创建以下任务：
package&lt;FormatName&gt;（例如 packageDmg 或 packageMsi）用于将应用程序打包成相应的格式。这块需要注意的是，目前没有交叉编译支持，因此只能使用特定操作系统构建格式（例如，要构建.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c2128e33941cb56221efad2c7f0c0a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f44f6d81e112a9d42fb40e3f63576e40/" rel="bookmark">
			强化学习学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		献上一篇非常详细的DQN教程（英文版的讲得太好了！）
https://download.csdn.net/download/mossfan/86854634
入门源码（pytorch实现DQN玩gym，根据代码可以很快了解框架运行流程）
https://download.csdn.net/download/mossfan/86902062
强化学习是什么 强化学习（Reinforcement Learning, RL），又称再励学习、评价学习或增强学习，是机器学习的范式和方法论之一，用于描述和解决智能体（agent）在与环境的交互过程中通过学习策略以达成回报最大化或实现特定目标的问题。
强化学习是agent在环境的互动当中为了达成一个目标而进行的学习过程。
强化学习组成元素
基本元素：
agent：‘玩家’
environment
goal
主要元素：
state
action
reward
动作空间（Action Space）：A，可以采取的所有合法动作的集合，所有合法的落子。
状态空间（State Space）：S；所有的状态的集合称为状态空间，所有的棋盘布局。
核心元素
policy：策略
value：state value、state-action value
关系如下
两个特点，一个核心问题
特点
trial and error：试错
delayed reward：延迟奖励
问题
exploration vs exploitation
exploitation：利用就是根据已有的经验去取得最大回报。比如，附近有十家餐馆，你已经去过里边的七家了，你知道这七家中红烧排骨最好吃，所以你会根据已有经验去吃红烧排骨，也不会去尝试另外的三家餐馆。这样是局部最优解。
exploration ：探索是指做你以前从来没有做过的事情，以期望获得更高的回报。 这时候你就要去尝试剩下的三家餐馆，看看有没有更好吃的菜，去寻找全局最优解。
围棋
agent：我
环境：棋局
goal：赢
state：棋盘上棋子的分布情况，afterstate（本次action后的状态）
action：落子
reward：落子后的反应
policy：使赢棋概率最大的行动
value：赢棋的概率，赢棋为1，输为0
多臂老虎机
对比两个老虎机的奖励哪个更好
特点：只有一个状态，没有延迟奖励
agent：玩家，我
environment：老虎机
goal：获得奖励
state：只有一个状态
action：摇一次
reward：服从一定概率分布的随机变量
学习方法 平均误差学习法
Qn+1=Qn+1/n(Rn-Qn)
Q:奖励估计值
Qn+1:New Estimate
Qn:Old Estimate
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f44f6d81e112a9d42fb40e3f63576e40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2adbc00950146a94cee5ea84a3aaec8d/" rel="bookmark">
			[Java] 如何理解和设置ThreadPoolExecutor三大核心属性？什么情况下工作线程数会突破核心线程数？任务拒绝策略都有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言ThreadPoolExecutor类是什么？ThreadPoolExecutor的三大核心属性1. 核心线程数（corePoolSize）属性2. 任务队列（workQueue）属性3. 最大线程数（maximumPoolSize）属性总结：ThreadPoolExecutor执行任务的流程 任务拒绝策略自定义任务拒绝策略 附录样例代码1：allowCoreThreadTimeOut导致应用退出样例代码2：扩展非核心线程逻辑导致的插队问题 结语 前言 ThreadPoolExecutor类是JDK提供给开发者的一个比较常用的多线程任务执行器。也因为比较常用，所以笔者将用本文一文去结合源码梳理掌握ThreadPoolExecutor类的几个核心知识点，相信看过本文之后，你将会更好地掌握ThreadPoolExecutor类。
ThreadPoolExecutor类是什么？ 首先要明确地是ThreadPoolExecutor不是线程池（ThreadPool），而是一个基于线程池的任务执行器服务（Executor Service），主要作用是帮助开发者去利用多个线程去异步地并行执行多个计算任务。
虽然ThreadPoolExecutor在其名称中省略了Service，但ThreadPoolExecutor是AbstractExecutorService的子类，是个货真价实的ExecutorService。
服务（Service）有诸多定义，要精准描述也比较难。这里的ExecutorService不同于我们Spring里面的Service层，而是更类似于我们操作系统或者说企业级系统层面的服务（进程），这类长时间运行地服务的特点就是有启动（start up） 和关闭（shut down） 的概念。而ThreadPoolExecutor也是如此，会在我们应用（进程）内部开启一个常驻服务用于接收计算任务（compute task）去执行（execute），当开发者想要退出应用时，要记得主动关闭已开启的ThreadPoolExecutor，否则你的应用不会主动退出，这是初学者使用ThreadPoolExecutor时比较容易遇到的一个问题。
你可以在下面的源码摘要里看到，ExecutorService接口所定义的shutdown相关的接口。
public class ThreadPoolExecutor extends AbstractExecutorService { /* 略 */ } public abstract class AbstractExecutorService implements ExecutorService { /* 略 */ } public interface ExecutorService extends Executor { void shutdown(); List&lt;Runnable&gt; shutdownNow(); boolean isShutdown(); boolean isTerminated(); /* 略 */ } ThreadPoolExecutor的三大核心属性 ThreadPoolExecutor作为一个工具类，其开发者为我们提供了诸多控制其行为的属性，本章会讲解其中最重要的三个核心属性，你通常会在构造器看到这些属性。
核心线程数（corePoolSize）任务队列（workQueue）最大线程数（maximumPoolSize） 1. 核心线程数（corePoolSize）属性 核心线程数（corePoolSize）这个属性是用于指示ThreadPoolExecutor设置常驻（核心）工作线程的个数。意味着任务数量在比较平稳情况下，最多有corePoolSize个线程用于执行任务。
在ThreadPoolExecutor创建之初，不会立即创建corePoolSize个线程当做核心工作线程。会在前corePoolSize个任务被要求执行时，一个一个被创建，直到创建满corePoolSize个核心工作线程。源码摘要如下：
默认设置下，核心工作线程一旦被创建，即使没有新任务执行也会一直存在。不过如果你通过allowCoreThreadTimeOut(boolean)方法，设置允许核心线程的超时回收特性的话，核心工作线程的数量在没有任务执行时会被逐步回收，如果没有其他运行中的线程保护，核心线程归零时会导致应用直接退出。
如果想尝试导致应用退出的，你可以在文末《样例代码1：allowCoreThreadTimeOut导致应用退出》章节看到相关样例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2adbc00950146a94cee5ea84a3aaec8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cadb17bd9a39561040812a8136b3112/" rel="bookmark">
			用python写一个文件去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以使用 Python 的 set 数据结构来去重文件中的行。
首先，打开文件并读取每一行，将每一行添加到 set 中。由于 set 中的元素是唯一的，因此会自动去重。然后，将 set 中的元素写回文件即可。
下面是一个示例代码：
# 打开文件 with open('input.txt', 'r') as f: # 创建 set lines = set() # 读取每一行并添加到 set 中 for line in f: lines.add(line) # 将 set 中的元素写回文件 with open('output.txt', 'w') as f: for line in lines: f.write(line) 上述代码会读取 input.txt 文件中的所有行，并使用 set 去重后写回 output.txt 文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/effbd4cc470699db712d569c6d34c081/" rel="bookmark">
			利用Python中的Pyinstaller库进行打包时出现错误信息：“ImportError：DLL load failed while importing _iterative：找不到指定的模块。“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目场景： 通常情况下，我们在对用户交付Python脚本的时候，给用户的是可以直接在windows操作系统下直接运行的.exe文件，而源码.py文件需要我们用python的第三方库Pyinstaller进行打包，从而生成我们希望交付给用户的.exe文件。在打包的过程中有个重要因素是我们必须要考虑的————即我们希望打包后生成的.exe文件尽可能的小，这样更便于不同用户之间的交互和传输。为了达到这个目的，我们就需要一个非常干净的环境，在此环境中只安装我们项目中需要的Python标准库和第三方库，其他不需要的库就不安装了。此时，我们就要建立起一个虚拟环境，在这个虚拟环境中安装我们项目所需的库，这样再用Pyinstaller打包生成的.exe文件就很小了。但是在打包的过程中，我们经常会因为使用的Anaconda或者Miniconda的版本不同，会出现各种不同的bug、warning和Error等。下面我就简单介绍以下我自己在打包过程中所遇到的一些问题和解决方案。备注：我用的是Anaconda2020.07，PyCharm2022.01。
二、问题描述 1.问题一： 1.1 这个问题出现的环境版本 （1）虚拟环境中python版本：python3.8.3
（2）虚拟环境中pyinstaller版本：pyinstaller5.7.0
1.2 出现的报错信息如下图所示： 2.问题二： 2.1 这个问题出现的环境版本： （1）虚拟环境中python版本：python3.6.5
（2）虚拟环境中pyinstaller版本：pyinstaller4.10.0
2.2 出现的报错信息如下图所示： 三、原因分析： 1.问题一原因分析： 1.1 原因一：因为scipy和numpy这两个库安装的有问题 在scipy模块的下载页面(网址：https://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy)写着如下图所示的信息，说是在安装scipy之前，需要安装numpy+mkl模块
1.2 原因二：因为Anaconda(Miniconda)版本问题或者操作系统版本问题 如本文开头所介绍的那样，我用的是Anaconda2020.07，PyCharm2022.01，操作系统是windows11
2.问题二原因分析： 2.1 原因：因为库文件sysconfig.py中的_get_sysconfigdata_name函数中的有个参数没有设置 四、解决方案： 1.问题一解决方案： 1.1 原因一解决办法： （1）方案：先安装numpy+mkl模块，再安装scipy。很惭愧，我按照这个方法做了一遍
（2）结果：很惭愧，我按照这个方法做了一遍，并没有奏效，此方案以失败告终！#捂脸#
1.2 原因二解决办法： （1）方案：我在我同事的笔记本上试了一下，他的没有任何问题，Anaconda和PyCharm版本和我的一样，也没有装numpy+mkl模块，唯一的区别在于，我的笔记本操作系统是windows11，他的是windows10，可能windows11的兼容性还未完善好吧。
（2）结果：猜测可能与windows操作系统版本有关系，毕竟在不同操作系统上出现的bug是不一样的，也可能在另外一个操作系统上没有bug。#捂脸#
2.问题二解决方案： 2.1 解决办法： （1）方案：按下windows+R键—&gt;输入cmd，Enter—&gt;conda activate 虚拟环境名，进入虚拟环境下—&gt;输入python，进入python交互界面—&gt;输入import sysconfig，Enter—&gt;输入print(sysconfig.__file__)，Enter—&gt;此时可以查看sysconfig.py的本地路径—&gt;到这个路径下找到sysconfig.py，然后找到里面的_get_sysconfigdata_name函数，将其中的check_exists参数默认值设置为True。即_get_sysconfigdata_name(check_exists=True)。然后保存，再去运行打包命令，就可以了。如下图所示：
（2）结果：问题完美解决!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a40affea9b3d14143bc57058a6269e9c/" rel="bookmark">
			2022年总结：打开新世界，踏上新征程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 于我而言，2022年是我的幸运年，人生发生转折的关键点。同时，也可能是互联网行业、社会经济状况开始扭转的一年。因此，打算在CSDN开始记录下我的第一篇年总结。当然除了是意义特殊外，也还有现实实在的意义，不管是对于程序员还是普通打工人，定期复盘总结 + 目标计划 都是极为重要的事情。
在记录总结我过去一年的时候，我在思考步入职场的我需要怎么去做年总结、怎么去汇报，更好地展示呢，那么我该如何有效地去复盘？于是，我打开GPT，想GPT同学输入以下内容：
从小GPT同学口中，我知道了 总结/复盘 = 回顾（过去） + 提炼（收获与不足） + 改进（提升，制定新目标，新计划）。
当然，它回答地没有采用PACD、SMART、GRAI方法论去思考，但总体还是让我满意，于是我接下来也就按照该方式对我的2022进行总结反思。
二、重要事件回顾 在过去的一年，我主要经历了以下几个事情：
互联网公司后端实习（1月初至2月中） 考研复试准备&amp;成功上岸（3月初至4月初） 春招准备并成功上岸中厂-携程（3月初至5月） 毕业设计准备&amp;顺利毕业（4月至6月） 迷茫期、学习机器学习基础，找公司暑期工作攒经验（5月至6月） 阿里巴巴编程之夏开源实习&amp;学车、考研辅导（6月至8月） 研究生入学事宜&amp;课程学习（9-10月） OceanBase数据库大赛参与（11月） 期末准备、明年暑期实习准备（12月） 一月至二月 刚考研初试结束，编程能力退化、实践经验不足；考研复试还不知道能不能进。担心考研失利，春招的最后稻草也抓不住。于是开始寻找互联网公司，进行投递简历，而此时已经一月，几乎投递完无回应。最后一家创业型公司（导师的朋友开的）刚好在招人，也符合我的技术栈，于是我便爽快地答应了。
虽然公司比较小，但是团队氛围还是比较友好，也被前辈们的奋斗精神所感触、影响。
再来说一下这段时间，我做了些什么。这段时间（1.05-1.21 &amp; 2.7-2.22），我主要和另外一个新入职的小伙伴一起开发了 比较通用性（产品考虑到我们实习生能力有限吧，的确对于医疗业务域的理解十分浅薄）的消息模块。
除了完成开发任务之外，我还做了一下事情：
通过尚硅谷学习MQ、Redis、JVM、SpringCloud采用OneNote进行日规划、总结，项目记录分析 由于我的知识面相对于另外一个伙伴还是丰富不少，因此该模块的开发设计方案以及实现框架，都是我来主导的，这也为我后续的春招奠定了一定的基础。另外，由于我过于乐观的精神，虽然提前完成了开发，但导致开发出现些Bug，测试由原定的1天到后面的2、3天。
吸取的优点 勿只盯安排的任务，需要思维发散全面，从业务、商业需求到技术方案、架构设计、代码实现以及运行整个链路进行思考。明确自己的最终目标，并寻找到采用 OneNote等笔记方式去分析、记录自己的经历。能吃苦、坚持，持续学习。 改进的缺点 代码实现的严谨性不够高，在写代码前 应该多思考、考虑，再通过画图（架构层级图、流程链路请求图、等，需要具有分解和抽象的能力）、文字描述。沟通协作，应该多和团队、上级领导沟通、反馈。 三月至四月 这个期间，在得知擦边进入复试的结果后。基本上保持着高度紧张的状态，每天都在为考研复试准备，同时也为了避免复试被刷，也准备着春招，相继投递美团、小红书、携程等公司。在此期间，主要做了以下事情：
刷牛客（Java、数据库、软件工程）【主线任务】模拟面试（通过牛客模拟面试）、复习复试专业课（数据库、程序设计、软件工程）练习英语面试、读文献收到企业的面试前两天背一下八股文
吸取的优点 开始采用Excel表进行量化每日计划，相比Notion，Excel二维表更加清晰、直观，方便总结思考发现通过牛客网、八股文等方式去巩固基础知识还是不错的。【在此推荐一下小林Coding、阿秀的笔记 ，接下来的暑期实习也开始以此准备起来】 改进的缺点 此阶段状态挺好的，但唯一不足，可能是效率还是比较低下，需要刻意去训练个人的记忆力、思考深度能力 五月至六月 此阶段，主要就是准备毕业设计和毕业的事情了。同时，也收到了携程的Offer，开的也很不错，但是还挺心动的，但是考虑到干三个月就跑不仅对自己麻烦也对公司产生不好的影响，还是拒了，然后再去找一些其他公司实习，期间投递焦点科技、伯索科技等，期间因为担心科研需要，也开始学习了一些机器学习基础知识并在Gitee上面打卡学习记录。最后，比较心仪的伯索结果说招聘过去是做技术支持，想了想这不就是去打杂的嘛，然后就拒了。
吸取的优点/收获 具有强烈的好奇心和干劲儿发现开源新大陆（发现了 开源之夏、编程之夏等开源实习和GitHub的丰富世界） 改进的缺点 专注度不够，需要抓住核心的技术能力，分析问题比较表面，有点追求名利。 七月至八月 这段时间，是我打开新世界的起点。我除了考研辅导、学车之外，成功入选了编程之夏项目，并发现了GitHub的魅力，开始通过GitHub去关注、认识编程的大佬、发现优质的开源项目。
由于之前写过一篇，此处不再赘述，具体的可见关于参与阿里巴巴编程之夏Asoc-Nacos的感悟
九月至十月 该段时间，我主要是进行了研究生课程的学习和经典书籍的啃读。编程之路很长，计算机基础和代码能力等是至关重要的，因此计划这半年主要进行操作系统、计算机网络、数据库等基础扎实。并开始在GitHub进行代码打卡，和改用Notion做笔记。
期间读过的主要课程和书籍包括：
操作系统\系统：CSAPP 30%、Unix入门经典 90%，Linux就该这么学部分30%，深入理解Linux内核部分5%计算机网络：网络怎么连接的50%，及Netty权威指南80%数据库：MySQL高性能数据库部分15%架构工程：凤凰架构、软件工程-DevOps等概念Java并发：Java高并发从入门到精通90%，并发编程的艺术40%JDK源码解读、Tomcat深入剖析大数据相关组件（星环老师讲的，讲的挺好的，对分布式、架构的理解以及大数据生态的理解很有帮助）：zookeeper,hadoop,spark,kafka设计模式：代理模式、工厂模式、单例模式等回顾软件方法学：一门抽象度很高、讲的很抽象！，对问题分析、抽象建模有所启发。 优点及缺点 该时间段能够较好地去专注阅读书籍，也颇受启发。但缺乏实践和定期复盘总结，导致 学习记录很多，复盘总结麻烦，不过还好形成了较为完善的知识体系，为后续的深入学习奠定基础。想法过多，想 开源项目参与、经典书籍阅读、Java后端应用学习深入、科研学习，拓展认知、身体锻炼多方面兼顾，却不能很好地做到时间管理、甚至有点懒散。 十一月 该月主要进行OB的探索。具体见的该博客
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a40affea9b3d14143bc57058a6269e9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d618f2016abc764c408076dd1df48bf8/" rel="bookmark">
			计算数字个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从键盘输入一串字符，输出字符串里的数字字符数。
解：只要变量字符串，判断每个字符是否是数字(a[i]&gt;=‘0’ &amp;&amp; a[i] &lt;=9就是数字）。如果当前位不是数字，但前一个字符是数字，就说明前面有过一个数字了
#include “stdio.h”
int main()
{
char a[100];
int i,num=0;
gets(a);
for(i=0;a[i]!=’\0’;i++)
{
if(a[i]&gt;=‘0’ &amp;&amp; a[i]&lt;=‘9’)
num++;
}
printf("%d",num);
return 0;
}
————————————————
版权声明：本文为CSDN博主「t789_」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/t789_/article/details/117389462
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9501aa3519a4a248d23b466d7d0817e5/" rel="bookmark">
			Android Studio安装和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安卓应用开发 （一）下载Android Studio（二）安装Android Studio1、进入安装向导2、选择安装组件3、选择安装位置4、选择开始菜单文件夹5、按照配置进行安装 （三）启动并配置Android Studio选择不导入先前设置1、Android Studio首次运行2、选择安装类型3、选择默认JDK位置4、选择用户界面主题5、选择安卓SDK组件及安装位置6、模拟器配置（1）模拟器配置（AMD）（2）模拟器配置（Intel HAXM） 7、安装许可协议8、下载组件AMD 下载完成界面Intel HAMX 下载完成界面 9、进入设置对话框进行相关设置（1）设置主题（2）设置滚鼠调节编辑器字号（3）设置编辑器字体（4）设置文件字符编码（5）设置自动导入（6）设置代码完成（7）设置文件头 10、使用SDK管理器下载安卓SDK11、使用AVD管理器创建安卓虚拟机 （五）创建安卓应用1、选择项目基于的模板2、配置项目基本信息3、在虚拟机上测试应用4、在真机上测试应用 （六）设备管理器和SDK管理器1、通过工具栏按钮启动设备管理器2、通过工具栏按钮启动SDK管理器 安装配置完成 （一）下载Android Studio 官网下载链接：https://developer.android.google.cn/studio单击【Download Android Studio】按钮勾选复选框在单击【Download Android Studio Chipmunk 2021.2.1 Patch 1 for Windows】按钮。
打开下载Android-studio文件所在位置。 （二）安装Android Studio 1、进入安装向导 双击安装程序图标，进入安装向导。
2、选择安装组件 采用默认位置 3、选择安装位置 修改安装位置：D:\Android\Android Studio
默认是安装在C:\Program Files\Android\Android Studio，最好改到其它盘，因为C盘是启动盘，不宜安装太多东西，影响启动速度。 4、选择开始菜单文件夹 采用默认设置
5、按照配置进行安装 单击【Install】按钮，就开始安装。
（三）启动并配置Android Studio 启动Android Studio，首先看到启动画面中可爱的金花鼠 选择不导入先前设置 单击【Do not import settings】单选按钮
1、Android Studio首次运行 如果是Android Studio首次运行，会弹出消息框，提示无法访问Android SDK扩展列表
单击【Cancel】按钮
单击【Next】按钮 2、选择安装类型 采用自定义安装类型
3、选择默认JDK位置 采用默认设置
4、选择用户界面主题 根据自己喜欢的界面主题颜色，这里我选择的是light（白色）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9501aa3519a4a248d23b466d7d0817e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc331f489750356628fb0e41b375dbbd/" rel="bookmark">
			Vue练习-翻转世界
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt;
&lt;div&gt;
&lt;!-- 1. 变量准备-静态页面铺设 --&gt;
&lt;h1&gt;{{ msg }}&lt;/h1&gt;
&lt;!-- 2. 绑定点击事件 --&gt;
&lt;button @click="btn"&gt;逆转世界&lt;/button&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
data(){
return {
msg: "Hello, World"
}
},
methods: {
btn(){
// // 3. 截取字符串返回数组
// let arr = this.msg.split("")
// // 4. 翻转
// arr.reverse()
// // 5. 数组拼接起来
// this.msg = arr.join("")
// 简化
this.msg = this.msg.split("").reverse().join("")
}
}
}
&lt;/script&gt;
&lt;style&gt;
&lt;/style&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b42d305fa94cfab18d5bb9cced94e463/" rel="bookmark">
			Springboot跨域处理的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介 作者名：编程界小明哥
简介：CSDN博客专家，从事软件开发多年，精通Java、JavaScript，博主也是从零开始一步步把学习成长、深知学习和积累的重要性，喜欢跟广大ADC一起打野升级，欢迎您关注，期待与您一起学习、成长、起飞！明哥QQ：283582761
测试工具 IDEA
什么是跨域 当一台服务器资源从另一台服务器（不同 的域名或者端口）请求一个资源或者接口，就会发起一个跨域 HTTP 请求。
浏览器出于安全考虑，会限制跨域访问，就是不允许跨域请求资源，要求协议，IP和端口必须都相同，其中有一个不同就会产生跨域问题，这就是同源策略。
跨域举例 请求方响应方是否跨域原因http://www.ming.comhttp://www.ming.com/test.html否协议、域名、端口相同http://www.ming.comhttps://www.ming.com/test.html是协议不同http://www.ming.comhttp://www.minggod.com/test.html是主域名不同http://www.ming.comhttp://haha.ming.com/test.html是主域名相同、子域名不同http://www.ming.com:8080http://www.ming.com:8090/test.html是端口不同 跨域访问实例 后端测试代码
import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class CorsController { @GetMapping("/cors") public String hello(){ return "hello cors"; } } 用浏览器打开，我这里配置的端口是8090
在前端项目中用axios访问时
&lt;template&gt; &lt;span&gt;跨域请求:{{result}}&lt;/span&gt; &lt;/template&gt; &lt;script&gt; import axios from 'axios'; export default { name: "Cors", data(){ return { result:"" } }, methods:{ getTest(){ axios.get("http://localhost:8090/cors").then(res=&gt;{ console.log(res.data) this.result=res.data }) } }, created() { this.getTest(); } } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 报错中的关键词
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b42d305fa94cfab18d5bb9cced94e463/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c1ef2e9f536a6f7009336c7f56515e5/" rel="bookmark">
			nohup命令让服务器上的程序在后台一直运行，退出终端也可以保持程序运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（本博文的方法对于阿里云和腾讯与服务器都适用 ）
场景：
部署一个后端程序（climate-0.0.1-SNAPSHOT.jar）到我腾讯云的服务器上，常规启动命令如下： java -jar climate-0.0.1-SNAPSHOT.jar 上图表示项目部署成功，便可以在浏览器上进行访问
但是关闭终端后，就不能访问了，也就达不到上线的效果。
而我们想项目程序在关闭退出终端后，也一样继续运行，
这时候需要使用 nohup 命令启动（该命令可以在你退出帐户/关闭终端之后继续运行相应的进程）
输入如下命令：
nohup java -jar climate-0.0.1-SNAPSHOT.jar 但是会报错（表示：执行nohup命令的时候，经常会没有写入权限的错误）
1、原因
是因为使用 nohup 会产生日志文件，默认写入到 nohup.out
2、解决
将 nohup 的日志输出到 /dev/null，这个目录会让所有到它这的信息自动消失
nohup java -jar climate-0.0.1-SNAPSHOT.jar &gt; /dev/null 2&gt; /dev/null &amp; 其它解决方法：
就是在末尾直接加一个&amp;就就能够直接在后台运行
nohup java -jar climate-0.0.1-SNAPSHOT.jar &amp; 停止进程
如果想停止进程运行的话，可通过命令（kill -9 进程号PID）进程号来杀死
另外也可以使用 ps -def | grep "进程名" 命令来查找PID。
找到 PID 后，就可以使用 kill PID 来删除。
kill -9 进程号PID 如果发现启动时，查看日志发现端口号被占了
用 lsof -i:[端口号] 查看使用某端口的进程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c1ef2e9f536a6f7009336c7f56515e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33925ad11ee1b3fe83cc2aea213eebc6/" rel="bookmark">
			TypeError: Cannot read properties of undefined (reading ‘style‘)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 vue 中用 document 获取 dom 节点进行节点样式更改的时候有可能会出现 'style' is not definde的错误，
这时候可以在 mounted 里用 $refs 来获取样式，并进行更改：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f360c6809f4ca8b8b15f191555de547b/" rel="bookmark">
			分享：三种年终奖分配方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开放式年终奖分配方案
开放式年终奖分配方案说明：
开放式年终奖是指先确定每个岗位的年度奖金目标，即采取年薪的百分比或月工资的倍数，再分别根据公司绩效系数、部门绩效系数、岗位绩效系数来确定员工的奖金系数，最后目标奖金与员工奖金系数相乘，得出员工年终奖额度。
公式：
员工奖金系数=公司绩效系数X公司绩效权重+部门绩效系数X部门绩效权重+岗位绩效系数X岗位绩效权重
员工个人年度奖金=员工年薪x目标奖金率x员工奖金系数
开放式年终奖分配方案实施步骤：
步骤一：确定公司绩效系数；
步骤二：确定事业部、职能部门绩效系数；
步骤三：确定员工个人岗位绩效系数；
步骤四：员工奖金系数=公司绩效系数*公司绩效权重+事业部、职能部门绩效系数*事业部、职能部门 绩效权重+岗位绩效系数*岗位绩效权重
步骤五：员工个人年度奖金=员工年薪*目标奖金率*员工奖金系数
二、年底双薪制
双薪”是一种奖励员工的形式，即“12+1”或“12+2”的方法，即到年底，公司多发给员工1个月或2个月的工资。奖励的员工应当是当年加入公司并于12月31日前通过试用期的员工。出勤率不良、表现不好或者有违纪行为的员工不能获得此奖金。（多发的工资可以以12个月的平均工资为准。）
“年底双薪制”简单易行，不费周章。但是对于半途离开公司和处在试用期的员工有一定的不合理性，也容易让年内绩效考核系数高的员工产生不公平感。 三、红包薪酬制
通常是由老板决定的，没有固定的规则，可能取决于员工与老板的亲疏、取决于老板对员工的印象、取决于资历，取决于重大贡献等。通常不公开。
红包薪酬的局限性表现在，它极有可能造成员工对老板支付薪酬是否公平的猜测，降低了绩效与薪酬的相当关系。老板也可能通过暗箱操作，凭个人的主观好恶分配报酬，薪酬的激励作用自然弱化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/829d52f93e24db41ace0ace61143a80c/" rel="bookmark">
			数仓开发流程及维度建模过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数仓开发流程
1.数据调研:和业务方沟通进行业务调研和需求分析,充分了解业务场景和业务含义
2.明确数据域:按照业务的特定标准对数据进行划分
3.构建业务总线矩阵:根据业务数据进行分析 抽象出业务过程和维度
4.明确统计指标:对报表需求进行分析 整理出指标体系 包括原子指标 派生指标 和衍生指标
5. 维度模型设计:构建DWD和DM层
6.汇总模型设计: 构建DWS层
7.进行开发调度
维度建模过程
选择业务过程:对业务进行理解 进行详细的需求分析 对业务生命周期进行分析 明确业务步骤
声明粒度:精确定义每一行事实表所代表的业务含义,粒度传递的是与事实表度量相关的细节层次 一般是原子粒度 来保证事实表最大的灵活度
确认维度:业务确定后 可以确认相关维度 应该选择能够清晰描述业务过程所处环境的维度信息
确认事实:确认事实表的度量值
模型选择: 雪花模型: 数据冗余量小 但是业务实现难度大 sql复杂 维护困难
星型模型: 数据冗余量大 业务实现相对简单 关系更加直观 sql逻辑更清晰
DWD建模: 事务事实表: 每条记录事实事务
周期快照事实表: 保存某个业务的全周期变化数据
数据库三范式
第一范式 : 字段必须为原子性 信息不可再分
第二范式 : 联合主键需要完全依赖每个字段
第三范式 : 确保每列都是与主键直接相关而不是间接相关
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d8c4d2e952a93d736fa8e9c82536570/" rel="bookmark">
			[内网渗透]—kerberos&amp;域内提权(pth、wmic)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kerberos Kerberos身份验证流程 - zpchcbd - 博客园 (cnblogs.com)
能用通用的语言介绍下 Kerberos 协议么？ - 知乎 (zhihu.com)
介绍 在 Kerberos 认证中，最主要的问题是如何证明「你是你」的问题，如当一个 Client 去访问 Server 服务器上的某服务时，Server 如何判断 Client 是否有权限来访问自己主机上的服务，同时保证在这个过程中的通讯内容即使被拦截或篡改也不影响通讯的安全性，这正是 Kerberos 解决的问题。在域渗透过程中 Kerberos 协议的攻防也是很重要的存在。
Kerberos 主要是用在域环境下的身份认证协议。
哈希传递(Path The Hash) 哈希传递通过找到与账户相关的密码散列值(NTLM Hash)来攻击。在域环境中，用户登录计算机时使用的大都是域账号，大量计算机在安装时会使用相同的本地管理员账号和密码，如果计算机的本地管理员账号和密码都是相同的，攻击者就能使用哈希传递方法登陆内网中的其他计算机。同时，通过哈希传递攻击，攻击者不需要花时间破解密码散列值。
散列值在Windows中是用来证明身份的，攻击者往往会使用第三方工具来完成任务。在win2012之后的版本，默认内存中不会记录明文密码，因此攻击者往往会使用工具将散列值传递到其他计算机中，进行权限验证，实现对远程计算机的控制。
NTLM Hash进行哈希传递 先通过mimikatz找到域控的NTLM
mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords full" exit 获取ntlm为： 209c6174da490caeb422f3fa5a7ae634
mimikatz "privilege::debug" "sekurlsa::pth /user:administrator /domain:sentiment.com /ntlm:209c6174da490caeb422f3fa5a7ae634 执行后会弹出cmd窗口，此时就拿到了administrator的权限
AES-256密钥进行哈希传递 先通过mimikatz找到域控的aes-256密文
mimikatz "privilege::debug" "sekurlsa::ekeys" 获取秘钥：ehdc2539aac27hffdb3a83dc20d16a7efcf62bb0bb5136454fb48bfbf5d5b0ea
mimikatz "privilege::debug" "sekurlsa::pth /user:Administrator /domain:sentiment /aes256:ehdc2539aac27hffdb3a83dc20d16a7efcf62bb0bb5136454fb48bfbf5d5b0ea 执行后会弹出cmd窗口，此时就拿到了administrator权限
MSF 先生成shell，获取边缘主机的会话
添加内网主机路由
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d8c4d2e952a93d736fa8e9c82536570/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab15dbb00d51c0fb051b89441a9f7e6e/" rel="bookmark">
			HC-SR04超声波测距模块介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超声波简介
超声波是由机械振动产生的, 可在不同介质中以不同的速度传播, 具有定向性好、能量集中、传输过程中衰减较小、反射能力较强等优点。超声波传感器可广泛应用于非接触式检测方法,它不受光线、被测物颜色等影响, 对恶劣的工作环境具有一定的适应能力, 因此在水文液位测量、车辆自动导航、物体识别等领域有着广泛的应用。
超声波测距原理
超声波测距是通过不断检测超声波发射后遇到障碍物所反射的回波, 从而测出发射和接收回波的时间差Δt , 然后求出距离S 。在速度v 已知的情况下,距离S 的计算,公式如下:S = vΔt/ 2在空气中,常温下超声波的传播速度是334 米/秒,但其传播速度V 易受空气中温度、湿度、压强等因素的影响,其中受温度的影响较大,如温度每升高1 ℃, 声速增加约0. 6 米/ 秒。因此在测距精度要求很高的情况下, 应通过温度补偿的方法对传播速度加以校正。已知现场环境温度T 时, 超声波传播速度V 的计算公式如下:
V = 331. 5+0.607T
这样, 只要测得超声波发射和接收回波的时间差Δt 以及现场环境温度T,就可以精确计算出发射点到障碍物之间的距离。
HC-SR04超声波测距模块简介
HC-SR04超声波测距模块可提供2cm-400cm的非接触式距离感测功能，测距精度可达高到3mm；模块包括超声波发射器、接收器与控制电路。
HC-SR04超声波测距模块实物图
HC-SR04超声波测距模块特点
1、典型工作用电压：5V
2、超小静态工作电流：小于5mA
3、感应角度(R3 电阻越大,增益越高,探测角度越大)：
R3 电阻为392,不大于15 度
R3 电阻为472, 不大于30 度
4、探测距离(R3 电阻可调节增益,即调节探测距离)：
R3 电阻为392 2cm-450cm
R3 电阻为472 2cm-700cm
5、高精度：可达0.3cm
6、盲区（2cm）超近
HC-SR04超声波测距模块管脚
VCC（5V）、 Trig（控制端）、 Echo（接收端）、地（GND） 使用方法：控制口发一个10US 以上的高电平,就可以在接收口等待高电平输出。一有输出就可以开定时器计时,当此口变为低电平时就可以读定时器的值,此时就为此次测距的时间,方可算出距离。如此不断的周期测,就可以达到你移动测量的值了。
HC-SR04超声波测距模块工作原理
1、采用IO 触发测距，给至少10us 的高电平信号；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab15dbb00d51c0fb051b89441a9f7e6e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/197/">«</a>
	<span class="pagination__item pagination__item--current">198/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/199/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>