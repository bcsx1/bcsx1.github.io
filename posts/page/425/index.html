<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37063c55c4ce5a8bfb821ae19f0013dd/" rel="bookmark">
			Python   统计Zabbix监控告警表报统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.需求与分析 1.需要每周分析下系统告警汇总信息，加图表展示。
2.思路：调用zabbix api 获取，查询zabbix数据库的alters表来获取。
二.实现方法 1.核心部分是查询数据库提取告警次数，告警级别
坑就是很多网上发的sql是无法准确或者无法提取告警级别，告警次数的。
Trigger: Free disk space is less than 20% on volume / Trigger status: PROBLEM Trigger severity: Warning Trigger URL: Item values: 1. Free disk space on / (percentage) (prod_zhongyi002:vfs.fs.size[/,pfree]): 19.51 % 2. *UNKNOWN* (*UNKNOWN*:*UNKNOWN*): *UNKNOWN* 3. *UNKNOWN* (*UNKNOWN*:*UNKNOWN*): *UNKNOWN* Original event ID: 28211677 恢复OK, 主机:Zabbix server: Too many processes running on Zabbix server已恢复! 告警主机:Zabbix server 告警时间:2020.07.22 04:08:57 告警等级:Warning 告警信息: Too many processes running on Zabbix server 告警项目:proc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37063c55c4ce5a8bfb821ae19f0013dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b2d9a4589c5a840a9edb203db06a877/" rel="bookmark">
			DBeaver备份postgresql问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DBeaver备份postgresql问题 报错 Native client home 'PostgreSQL Binaries' not found 报错 Native client home ‘PostgreSQL Binaries’ not found 编辑数据库链接，编辑，在advanced中重新选择‘本地客户端’
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c22ff4a02ddbc1dc938bccb0d2d4159/" rel="bookmark">
			Maven打包太慢？？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 我们项目在进行Maven打包时，总是费很久时间，时快时慢，针对此问题，一直困扰我，所以今天决定死磕解决它
可以看出这个打包用了4分钟
了解 首先我们要了解Maven打包的方式
这些大家都知道，常用的package install
梳理 我会直接更改一个类，每次测试都直接更新，不编译运行
使用package打包
Maven会把我们项目依赖的jar包下载下来，一般耗时多在这里，如果打包看到这一步很快就到则不是它拖慢
接下来好长时间后才显示打包的Java项目
最后打包成功
可以看出耽误时间的就在下完jar之后的这段时间中，也就是编译为class过程，经过多轮反复测试得出结论
解决 打包速度取决于：
电脑配置，配置越好，越快网速，如果需要远程下载，网速得好使用的的命令package要比install快项目运行编译完一遍再打包会加快很多 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69dd996f8cd067d0fd5c842905efb17d/" rel="bookmark">
			GhostNet 网络原理与 Tensorflow2.0 实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 介绍Ghost ModuleGhost BottleneckGhostNet代码实现1、用类实现2、用函数实现 介绍 在 GhostNet: More Features from Cheap Operations 一文中，作者发现，在一个训练好的深度神经网络中，通常会包含一些相似的特征图，以保证对输入数据有更全面的理解。如下图所示，在 ResNet-50 中，将经过第一个残差块处理后的特征图拿出来，三对相似的特征图示例用相同颜色的框注释。 因此，作者提出：将用于获得这张特征图的卷积核数量减少一半（则得到的特征图的通道数会减少一半），然后将得到的特征图进行线性运算（在下图中用扳手表示），得到缺少的另一半特征图，最后将这两部分特征图合并，得到和原来特征图相同的尺寸。
Ghost Module 下面第一张图是正常的卷积过程；第二张图代表 Ghost 模块，即先用含一半卷积核的正常卷积提取特征图，再将这个特征图放入到线性运算中得到新的特征图，最终合并这两部分。线性运算指的是 3x3 或 5x5 的深度级卷积过程。
Ghost Bottleneck Ghost bottleneck 类似于 ResNet 中的基本残差块，主要由两个堆叠的 Ghost 模块组成。第一个 Ghost 模块用作扩展层，增加通道数。这里将输出通道数与输入通道数之比称为 expansion ratio。第二个 Ghost 模块用来减少通道数，以与 shortcut 路径匹配。然后，使用 shortcut 连接这两个 Ghost 模块的输入和输出。出于效率考虑，Ghost 模块中的初始卷积是点卷积。
GhostNet 代码实现 1、用类实现 import tensorflow as tf from tensorflow.keras.layers import GlobalAveragePooling2D, Conv2D, Concatenate, BatchNormalization, DepthwiseConv2D, Lambda, Reshape, Layer, Activation, add from math import ceil class SEModule(Layer): def __init__(self, filters, ratio): super(SEModule, self).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69dd996f8cd067d0fd5c842905efb17d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e50eb2e8470565b11ea9c7ef7aeccef/" rel="bookmark">
			有哪些反爬机制？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于爬虫用户来说，网站的反爬机制可以说是他们的头号敌人。反爬机制是为了防止爬虫爬取数据过于频繁，给服务器造成过重的负担导致服务器崩溃而设置的机制，它其实也有几种不同的方式，下面我们就来说说。
1、通过UA机制识别爬虫。
UA的全称是User Agent，它是请求浏览器的身份标志，很多网站使用它来作为识别爬虫的标志，如果访问请求的头部中没有带UA那么就会被判定为爬虫，但由于这种要针对这种反爬虫机制十分容易，即随机UA，所以这种反爬机制使用的很少。
2、通过访问频率识别爬虫。
爬虫为了保证效率，往往会在很短的时间内多次访问目标网站，所以可以通过单个IP访问的频率来判断是否为爬虫。并且，这种反爬方式比较难以被反反爬机制反制，只能通过更换代理IP来保证效率，如飞鱼ip代理。
3、通过Cookie和验证码识别爬虫。
Cookie就是指会员制的账号密码登陆验证，这就可以通过限制单账号抓取频率来限制爬虫抓取，而验证码完全是随机的，爬虫脚本无法正确识别，同样可以限制爬虫程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80627bcf77a5d9006b1342e3ca476037/" rel="bookmark">
			运放电路呼吸灯电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电路功能介绍：
本例是一款呼吸灯电路，工作时LED呈现出：暗---渐亮---亮---渐暗---暗---渐亮---亮---周期性变化效果。
电路图：
该电路图主要使用Lm358运放电路元器件和电容（电容实现电压信号的缓慢变化，从而实现，三极管相配合实现三极管开关的缓慢开合控制。
本例是工作在单电源模式下，VCC的工作电压可用9V～12V的电源。
网络节点REF是电阻R1,R2的分压后的基准电压，如果VCC为12V时，REF的电压为固定的6V。
1、电路上电后，U1B的6脚为REF，5脚接至U1A的输出，也就是说U1A的输出是U1B的同相输入信号。
2、当U1B的同相输入信号电压等于REF时，那么U1B将会出现翻转，由0翻转至VCC或者由VCC翻转至0；我们假设此时U1B输出为VCC，高电平。
3、当U1B输出高电平后，U1A的反相输入电压为VCC，要比REF大，所以U1A会出现翻转，输出低电平，但由于电容C1的存在，U1A的输出会由VCC慢慢的往下降。
4、由于U1A的输出接至U1B的同相输入端，所以U1B的5脚电压也由VCC慢慢往下降，当降至与REF相等时，U1B的输出翻转，输出低电平。
5、当U1B输出低电平后，U1A的同相输入端电压要比反相端电压高，所以U1A输出高电平，但由于电容C1的存在，电压会缓慢升高。
6、当U1A的输出升高到REF电压时，U1B的输出翻转变为高电平。后面整个电路反复工作在上述状态。
注意：
我的上述分析，并没有过多的从运放的角度来分析，更多的是从比较器的方面来分析。
不懂的，可以去查找一下运放方波-三角波发生电路，然后根据运放的虚短，虚断来计算一下输出的波形的函数。
图中的电容C1也可用电解电容，用电解电容时需要注意电容的方向。当U1A要输出低电平时，电容C1右端放电；当U1A输出高电平时，电容C1右端充电，所以电解电容方向是左负右正。
整个电路可分为两个部分：
一是由U1B以及外围元件组成的方波信号发生电路；
二是由U1A以及外围元件组成的三角波发生电路；
参考文献：https://www.jichudianlu.com/archives/20
三极管的Base 电流和IC直接的关系，可以通过放大系数在不同的Base电流关系表达出来：
从图可知，当Ib 达到一定值时，放大倍数最大，及IC最大，然后会随着Ib 增大逐渐下降， 而该呼吸灯电路就是由电容实现，Ib电流的缓慢增大和缓慢减小，从而实现Ib 的逐渐变化和IC的连续变化，最终实现呼吸灯的电流的连续变化。
参考三极管电路设计：三极管偏置电路分析方法-电子发烧友网
Base电流的计算以及偏置电路设计可以参考
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7afdbe77e16cad6923d7b2f1423f0de8/" rel="bookmark">
			逆元的定义用处以及简单求法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，逆元的定义 当 ax≡1(modb)， x即为 a 在mod b 意义下的逆元。
逆元的数学符号是 inv ，a 在mod b 意义下的逆元记作 inv(a,b)。注意不要写反了。
简单来说逆元就是在mod某个数意义下的倒数例如5x≡1（mod3）x=2是满足10=1（mod3）所以称2是5在mod3意义下的逆元、
二，逆元的应用 那么逆元有什么用呢？
(a + b) % p = (a%p + b%p) %p （对）
(a - b) % p = (a%p - b%p) %p （对）
(a * b) % p = (a%p * b%p) %p （对）
(a / b) % p = (a%p / b%p) %p （错）
在求余的过程中我们发现只有除法是不能分开运算的，而当a过大时，在计算除法过程中可能会造成比较大的精度损失，所以对于这种情况我们一般会把式子转换成那么(a / b) % p = (a * inv(b) ) % p = (a % p * inv(b) % p) % p来进行计算。这样就解决了除法不能分开计算的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7afdbe77e16cad6923d7b2f1423f0de8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95ac44bc49a49ada3fb9373465709bbf/" rel="bookmark">
			蜂鸟E203系列—— SPI 设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欲观原文，请君移步
参考文章《SPI》
原理图 GPIO 可以通过 IOF0 和 IOF1 功能，使得 SOC 中的外设能够复用 GPIO 的 32 根引脚与芯片外设进行通信，其接口分配表如下所示：
GPIO编号IOF0IOF1GPIO0-PWM0_0GPIO1-PWM0_1GPIO2QSPI1:SS0PWM0_2GPIO3QSPI1:SD0/MOSIPWM0_3GPIO4QSPI1:SD1/MISO-GPIO5QSPI1:SCK-GPIO6QSPI1:SD2-GPIO7QSPI1:SD3-GPIO8QSPI1:SS1-GPIO9QSPI1:SS2-GPIO10QSPI1:SS3PWM2_0GPIO11-PWM2_1GPIO12IIC:SDAPWM2_2GPIO13IIC:SCLPWM2_3GPIO14--GPIO15--GPIO16UART0:RX-GPIO17UART0:TX-GPIO18--GPIO19-PWM1_1GPIO20-PWM1_0GPIO21-PWM1_2GPIO22-PWM1_3GPIO23--GPIO24UART1:RX-GPIO25UART1:TX-GPIO26 QSPI2:SS -GPIO27 QSPI2:SD0/MOSI -GPIO28 QSPI2:SD1/MISO -GPIO29 QSPI2:SCK -GPIO30 QSPI2:SD2 -GPIO31 QSPI2:SD3 - 源码 嵌入式软件通过SPI发送十进制数据 “33” 给底层硬件
/* * spi.c * * Created on: 2020年7月14日 * Author: anytao */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "platform.h" #include &lt;string.h&gt; #include "plic/plic_driver.h" #include "encoding.h" #include &lt;unistd.h&gt; #include "stdatomic.h" #define SPI2_MOSI_GPIO_OFFSET 27 #define SPI2_MISO_GPIO_OFFSET 28 #define SPI2_SCK_GPIO_OFFSET 29 #define SPI2_SCKMODE_CPOL 1 #define SPI2_SCKMODE_CPHA 0 #define SPI2_CS_GPIO_OFFSET 26 // #define DATA_SIZE 20 int8_t spi_tx_data[DATA_SIZE]; void spi_init2() { //GPIO IOF0 //SPI2 IOF0_SPI2_MASK GPIO_REG(GPIO_IOF_SEL)&amp;= ~ ((0x1 &lt;&lt; SPI2_MOSI_GPIO_OFFSET) |(0x1 &lt;&lt; SPI2_SCK_GPIO_OFFSET)|(0x1 &lt;&lt; SPI2_MISO_GPIO_OFFSET)); //GPIO IOF0 Enable //SPI2 IOF (0x1 &lt;&lt; SPI2_CS_GPIO_OFFSET) GPIO_REG(GPIO_IOF_EN)|= ((0x1 &lt;&lt; SPI2_MOSI_GPIO_OFFSET)|(0x1 &lt;&lt; SPI2_SCK_GPIO_OFFSET) |(0x1 &lt;&lt; SPI2_MISO_GPIO_OFFSET)); //禁止MOSI，SCK，CS的输入 GPIO_REG(GPIO_INPUT_EN) &amp;= ~((0x1 &lt;&lt; SPI2_MOSI_GPIO_OFFSET) | (0x1 &lt;&lt; SPI2_SCK_GPIO_OFFSET)|(0x1 &lt;&lt; SPI2_CS_GPIO_OFFSET)); //使能MOSI，SCK，CS的输出 GPIO_REG(GPIO_OUTPUT_EN) |= ((0x1 &lt;&lt; SPI2_MOSI_GPIO_OFFSET) | (0x1 &lt;&lt; SPI2_SCK_GPIO_OFFSET)|(0x1 &lt;&lt; SPI2_CS_GPIO_OFFSET)); //禁止MMISO的输出 GPIO_REG(GPIO_OUTPUT_EN) &amp;= ~(0x1 &lt;&lt; SPI2_MISO_GPIO_OFFSET); //使能MMISO的输入 GPIO_REG(GPIO_INPUT_EN) |= (0x1 &lt;&lt; SPI2_MISO_GPIO_OFFSET); //配置时钟寄存器：SCK的极性和相位，极性为0表示空闲状态为0，时钟的“前沿”为上升沿 //相位为0，则数据在发送端的时钟后沿改变，在接收端的下一个时钟前沿被采样 SPI2_REG(SPI_REG_SCKMODE) &amp;= ~((0x1 &lt;&lt; SPI2_SCKMODE_CPOL)|(0x1 &lt;&lt; SPI2_SCKMODE_CPHA)); //配置时钟频率分频系数寄存器 //若SPI所处时钟域Freq_SPI //则分频系数=Freq_SPI/(2*(div+1)) SPI2_REG(SPI_REG_SCKDIV)=0x08; } void Delay(unsigned int time){ volatile unsigned int repeatcnt=0; repeatcnt=time; while(repeatcnt--); } uint8_t SPI_Send_ReadByte(uint8_t dat) //SPI写数据，返回SPI的读数据 { SPI2_REG(SPI_REG_TXFIFO) = dat; Delay(50); return SPI2_REG(SPI_REG_RXFIFO)&amp;0xff; } void main(){ int i=0; //初始化SPI发送的数组 for(i=0;i&lt;DATA_SIZE;i=i+1){ spi_tx_data[i]=i; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95ac44bc49a49ada3fb9373465709bbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/395b18c846ad1347906b185fa6f6e5ec/" rel="bookmark">
			第十三次训练：Codeforces Round #590 (Div. 3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Codeforces Round #590 (Div. 3) C
题意：两行管道，有六种管道，每个管道都可以旋转，问能不能通到右下角。
从左往右通就好了，从纵向看来，每步（每两个管道）只要如果连通上一步的终点的是一个直管道或者这两个都是弯管道就可以通到下一步。直管道下一步位置不变，两个弯管道位置变化，出现其它情况都会终止通道。所以只需要记录当前管道连通位置，并判断下一位置的管道即可。当然，最后还要看下是不是连通的右下角。
#include&lt;iostream&gt; #include&lt;iomanip&gt; #include&lt;fstream&gt; #include&lt;cstdlib&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;string&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;utility&gt; #include&lt;ostream&gt; #include&lt;istream&gt; typedef long long ll; using namespace std; #define mod 1e9+7 #define PI acos(-1.0) const ll maxn=2*1e5; const int mx=(1&lt;&lt;20)+99; ll n,m,x,ans,aans,pos,a[maxn+10],b[maxn+10]; char c; int main() { cin.tie(0); ios::sync_with_stdio(0); int t; cin&gt;&gt;t; for(int o=1;o&lt;=t;o++) { cin&gt;&gt;n; for(int i=1;i&lt;=2*n;i++) { cin&gt;&gt;c; if(i&gt;n) b[i-n]=int(c-'0'); else a[i]=int(c-'0'); } pos=1; ans=1; for(int i=1;i&lt;=n;i++) { //cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/395b18c846ad1347906b185fa6f6e5ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8edcf0f2ab8aefe74e47a3e71a39332f/" rel="bookmark">
			关于 用户回调期间遇到未经处理的异常（0xC000041D） 的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情形一：错误的原因在“声明了一个类的指针时没有让这个指针指向一个类的实例”，要让这个指针实例化，，就不会报错了.
环境为vs2010
原来只是忘记给类指针new一个实例了
WINDOW编程会有的错误
这个错误出现的原因是因为回调函数当中有某些错误，而且情况比较复杂，错误的可能性有很多，比如数组越界，引用了空指针等。
我出现这个错误的原因在声明了一个类的指针时没有让这个指针指向一个类的实例，在回调函数中通过这个指针去调用这个类的函数，就了发生这种错误，并且会伴有“读取位置 0xxxxxxx 时发生访问冲突”的错误
————————————————
版权声明：本文为CSDN博主「alickr」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/alickr/article/details/49703125
-*-*-*-*-*-*-*-**-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
情形二：
MFC 0xC000041D 回调期间遇到未处理的异常
如果错误发生在OnInitDialog()时，可以尝试检查下DoDataExchange(CDataExchange* pDX)函数中的资源和对应关系是不是重复了。 比如:
... DDX_Control(pDX, IDC_CHECK_IB_SIGNAL, m_checkIbSignal); DDX_Control(pDX, IDC_CHECK_IB_SIGNAL, m_checkIcSignal); ... 还有包括栈溢出之类的问题也有可能是这个原因，少年，要细心啊！
————————————————
版权声明：本文为CSDN博主「少年磊」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/sssaaaannnddd/article/details/72723575
-*-*-*-*-*-*-*-**-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3db36c777f6345e300b79bfe13d6bb4b/" rel="bookmark">
			Servlet抽取BaseServlet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		servlet抽取 在JavaWeb编程的时候，通过servlet进行请求处理的时候，都会继承HttpServlet类重写doGet()或者doPost()方法处理相应的请求，那么就会出现很多的相同部分，如编码集的设置等，那么如何进行这些代码的抽取呢？
Java给我们提供了一个很好的方法，那就是反射。你只需要将要调用的方法指定给BaseServlet，实际处理请求的类继承基础类，进行相应的请求处理。BaseServlet将会通过反射的方式调用该方法。
BaseServlet的抽取 public abstract class BaseServlet extends HttpServlet { //统一使用doPost()方法进行请求的处理 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doPost(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //抽取每个servlet中的公共部分 // 解决post请求中文乱码问题 // 一定要在获取请求参数之前调用才有效 req.setCharacterEncoding("UTF-8"); String action = req.getParameter("action"); try { // 获取action业务鉴别字符串，获取相应的业务 方法反射对象 Method method = this.getClass().getDeclaredMethod(action, HttpServletRequest.class, HttpServletResponse.class); // System.out.println(method); // 调用目标业务 方法 method.invoke(this, req, resp); } catch (Exception e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3db36c777f6345e300b79bfe13d6bb4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d15b6177cf0caf4aa403cf56f3c2686/" rel="bookmark">
			locust小白学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		locust原理和优势 原理是协程并发
• 代码定义用户行为
• 支持分布式执行测试代码，能够模拟百万级别的用户量
• 使用协程执行请求，在单机上支持更高的并发量
快速上手样例 from locust import HttpLocust,TaskSet,task import os import queue #测试任务类 class ImportTest(TaskSet): #编写用户行为，即操作什么 @task def get_blog(self): header = {"token":"加在header的token","cookie":"加在header的cookie"} body = { "domain_name": "facebook.com", "ua": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36", }#body存放需要传递的参数 req = self.client.post("/fbcc/user/single-import-user", headers=header, verify=False, data = body) #补上接口的地址，将header，数据等传入接口 #self.client.get()这是get方法 if req.status_code == 200:#接口的状态码 print("success") else: print("fails") #测试配置 class websitUser(HttpLocust): #定义用户，相当于一个线程组 task_set = ImportTest min_wait = 3000 max_wait = 6000 if __name__=="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d15b6177cf0caf4aa403cf56f3c2686/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d7d035ef1cb0a87b3073dc13c7bbdfd/" rel="bookmark">
			数学建模——主成分分析入门及SPSS使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述
 主成分分析是由Pearson于1901年提出，再由Hotelling于1933年推广的一种多变量统计方法。主成分分析的目的是用较少的变量解释原来资料中的大部分变异，将相关性很高的变量转化为彼此互不独立或者不相关的变量。选出比原始变量少，能解释大部分资料中的变异的几个新变量，即所谓主成分，并用以解释资料的综合性指标。由此可见，主成分分析是一种降维方法。
（图源百度）
 成分的保留：Kaiser主张将特征值小于1的成分放弃，只保留特征值大于1的成分。
 成功标准：能用不超过3~5个成分，解释变异的80%就算成功。
可以看到自变量x_2，x_3的方差为0，对于x_2而言，始终保持为0，没有变化程度，上述表达式完全可以用：y=ax_1+cx_3+d来替代，即x_2失去了变量存在的意义。而对于x_3而言，虽然其数值始终很大，但方差也为0，完全可以用一个常量¬d’’来替代。
这样的两个变量在对y进行表示的过程中其实并没发挥作用，只要使用y=ax_1+c即可表示上述式子。我们将x_2,x_3被淘汰的过程的原理认为是：方差淘汰变量。当然，方差为0这是一个极端的情况，在方差很小的情况下，即数据的整体变化很小，我们也可以认为这个变量没有存在的必要，将其淘汰。
设因变量和自变量存在函数关系：y=ax_1+bx_2+d，假如对应数据②如下：
引入变量z_1,z_2，我们进行这样的线性变换：z_1=x_1+x_2; z_2=x_1-x_2，得到下面的数据表：
我们上述的操作实际是对x_1和x_2进行了一组线性变换，对于变换后的结果z_2也可以被淘汰（原因不再重复，见上）。而假如我们的线性变换改变为：
那么上述的变换用矩阵表示则为：
则上述的线性变化本质上是进行了下面的图像变换：
原图：
变换后：
可以看到，变换之后的结果：z_2变化为0，主要的变化体现在横轴的z_1上。上述的两个例子说明了主成分分析的基本思想：将原先众多具有相关性的指标重新进行线性组合，以代替原先的指标。在图像上即体现为将图像进行一定的旋转变换。而为什么不进行上面的z_1=x_1+x_2; z_2=x_1-x_2？因为这种变换转换到x轴上后个点之间的距离发生了拉伸，具体的理由下面慢慢解释；
假设以x_1为横轴，以x_2为纵轴，有下面图像所示的图形：
可以发现数据点是以x_1方向分布的，在x_2的方向上数据变化并不明显，那么我们根据方差淘汰的思想即可将变量x_2淘汰，只保留x_1；
假如是下图所展示的情况：
椭圆中有一个长轴和一个短轴，称为主轴。在长轴方向，数据的变化明显较大，而短轴方向变化则较小
如果沿着长轴方向设定一个新的坐标系，则新产生的两个变量和原始变量间存在一定的数学换算关系，同时这两个新变量之间彼此不相关，而且长轴变量携带了大部分的数据变化信息，而短轴变量只携带了一小部分变化的信息(变异)
此时，只需要用长轴方向的变量就可以代表原来两个变量的信息，即将短轴方向上的数据抛弃。这样也就把原来的两个变量降维成了一个变量。长短轴相差越大，降维也就越合理。
（3） 在上述的分析中，我们反复提到“数据的变化”，那么如何衡量一组数据的变化大小？自然地，我们联想到了用方差来进行衡量。而主成分分析就是要通过不断的线性组合产生新的变量，使这组变量的方差达到最大。
数学原理分析
设有n个样本,p个指标，则可以构成大小为n×p的样本矩阵x:
假设我们想找一组新的变量：Y_1,Y_2,…,Y_m (m&lt;p)来替代原来的p个指标，且他们满足：
系数u_ij的确定要满足
Y_i与Y_j相互线性无关（(i≠j),i=1,2,…,m,j=1,2,…,m）
Y_1是x_1,x_2,…,x_p的一切线性组合中的方差最大者
Y_2是与z_1不相关的x_1,x_2,…,x_p的所有线性组合中的方差最大者。
以此类推：Y_m是与Y_1,Y_2,…,Y_(m-1)不相关的x_1,x_2,…,x_p的所有线性组合中的方差最大者。
新变量Y_1,Y_2,…,Y_m分别称为原指标x_1,x_2,…,x_p的第一，第二，……，第m主成分。
主成分分析的基本问题
（1） 每一个主成分的系数如何确定
 前提假设
第一主成分的系数满足：
要注意的是X是一个由p个向量组成的变量，所以均值E(X)也是一个n维列向量。cov(X)即对X求其协方差矩阵（这个矩阵是一个半正定阵，一定有n个特征值，即也有n个对应的特征向量）
 第一主成分的系数满足：
由简单推理可以得出：
由上述分析可知，我们要求的系数u_i1,u_i2,…,u_ip使Y_i的方差达到最大，那么这样即是一个约束优化问题，
求
由线性代数的基本知识可对①式做下列变换：
由上式可知，求f即转化为求矩阵Σ的特征值，求系数u_i即求特征值对应的特征向量。
对于Y_i (i=1,2,3,…,m)的方差要求依次增大，则对应特征值依次增大，对应的特征向量依次排列形成相应的矩阵。
（2） 如何保留主成分
方法一：
① 贡献率:第i 个主成分的贡献率为
② 累积贡献率:前m个主成分的累积贡献率为
③ 选择法则:
保留m 个主成分
（3） 如何解释主成分
① 原始指标X_i对各个主成分的贡献
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d7d035ef1cb0a87b3073dc13c7bbdfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e006ce34924998de1deef9985521b75/" rel="bookmark">
			专题1--排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://www.cnblogs.com/fnlingnzb-learner/p/9374732.html
一、排序算法分析 序号排序方法时间复杂度（平均）时间复杂度（最坏）时间复杂度（最好）空间复杂度稳定性01插入排序O(n2)O(n2)O(n)O(1)稳定02希尔排序O(n1.3)O(n2)O(n)O(1)不稳定03选择排序O(n2)O(n2)O(n2)O(1)不稳定04堆排序O(nlogn)O(nlogn)O(nlogn)O(1)不稳定05冒泡排序O(n2)O(n2)O(n)O(1)稳定06快速排序O(nlogn)O(n2)O(nlogn)O(nlogn)不稳定07归并排序O(nlogn)O(nlogn)O(nlogn)O(n)稳定 二、算法实现 01 插入排序 class Solution{ public: void InsertSort(vector&lt;int&gt;&amp; nums){ if(nums.size() &lt; 2 ) return; int i, j; for(int i = 0; i &lt; nums.size(); i++){ for(int j = i; j &gt; 0; j--){ if(nums[j] &lt; nums[j-1]) swap(nums[j], nums[j-1]); else break; } } return; } } 02 希尔排序 class Solution{ public: void ShelltSort(vector&lt;int&gt;&amp; nums){ int n = nums.size(); if(n &lt; 2 ) return; for(int div = n / 2; div &gt;= 1; div /= 2){ //分为几组 for(int k = 0; k &lt; div; k++){ //每组比较 for(int i = div + k; i &lt; n; i+= div){ //控制步长 for(int j = i; j &gt; k; j-= div){ //从后往前比较 if(nums[j] &gt; nums[j-div]) swap(nums[j],nums[j-div]); return; } } 03 选择排序 class Solution{ public: void SelectSort(vector&lt;int&gt;&amp; nums){ int len = nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e006ce34924998de1deef9985521b75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ff54baf2e9d5eb23f813e797e9cd0da/" rel="bookmark">
			Warning: JKS 密钥库使用专用格式。建议使用“keytool -importkeystore......-deststoretype pkcs12“迁移到行业标准格式 PKCS12。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天对AS新项目打包的时候突然出现了一个错误 解决办法： 1.把这句话复制下来，在你的cmd窗口里复制这句话，运行输入你的秘钥口令 2.运行完之后我们的AS正常打包，（有的正常了，有的小伙伴在打包最后一步finish的有时候会报错） 暂时先别管，然后你再重新打包这时候有可能是你的AS没刷新过来，多来几次就行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43947e5dce86da0429e00b06c06260bc/" rel="bookmark">
			python对语音文件加入高斯白噪声（含公式推导）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python对语音文件加入高斯白噪声（带公式推导） 1. 信噪比概念及计算公式2.已知信噪比，如何去产生固定功率的噪声3.完整代码 1. 信噪比概念及计算公式 信噪比（Signal-to-noise ratio，缩写为 SNR 或 S/N），也称作信杂比或讯杂比。
信噪比，为有用信号功率(Power of Signal)与噪声功率(Power of Noise)的比。因此为幅度（Amplitude）比的平方：
S N R = P s i g n a l P n o i s e = ( A s i g n a l A n o i s e ) 2 SNR=\frac{P_{signal}}{P_{noise}}=(\frac{A_{signal}}{A_{noise}})^2 SNR=Pnoise​Psignal​​=(Anoise​Asignal​​)2
它的单位一般使用分贝，其值为十倍对数信号与噪声功率比：
S N R = 10 ⋅ l o g 10 P s i g n a l P n o i s e = 10 ⋅ l o g 10 ( A s i g n a l A n o i s e ) 2 = 20 ⋅ l o g 10 ( A s i g n a l A n o i s e ) SNR=10\cdot log_{10}\frac{P_{signal}}{P_{noise}}=10\cdot log_{10}(\frac{A_{signal}}{A_{noise}})^2=20\cdot log_{10}(\frac{A_{signal}}{A_{noise}}) SNR=10⋅log10​Pnoise​Psignal​​=10⋅log10​(Anoise​Asignal​​)2=20⋅log10​(Anoise​Asignal​​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43947e5dce86da0429e00b06c06260bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8746f87804cf157aa569aefc1babd8e/" rel="bookmark">
			MyBatis与传统JDBC的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是MyBatis？ 简单来说，这是一个在你和数据库打交道的时候能够让你把精力更多的放在SQL语句而不是对象封装上的框架。
更简单的来说，就是能够帮你节省时间、提高效率的工具。就像盖一座小木屋，以前需要自己画图、自己伐木、自己盖房子，但是用了框架，就像请了施工队，只需要自己画图，剩下的交给施工队就OK啦。
思考这样的一个问题 我们的数据库中有一个user表，字段包含name、age、gender、address，相对应的有一个User实体类，有属性name、age、gender、address。
此时我们需要查询到这个表中的所有信息，SQL语句是
select * from user 和数据库进行交互的是UserDao接口，其中有一个方法
public interface UserDao { List&lt;User&gt; findAll (); } 这时该怎么办？
首先创建一个UserDao的实现类UserDaoImpl，实现findAll()方法
public class UserDaoImpl implements UserDao { static { try { Class.forName("com.mysql.cj.jdbc.Driver"); } catch (ClassNotFoundException e) { e.printStackTrace(); } } @Override public List&lt;User&gt; findAll() { Connection connection = null; PreparedStatement statement = null; List&lt;User&gt; users = new ArrayList&lt;&gt;(); try { connection = DriverManager.getConnection("jdbc:mysql:///test?serverTimezone=CTT", "root", "1229"); String sql = "select * from user"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8746f87804cf157aa569aefc1babd8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98d3072f7e44c56b315a69eaa2d2c73f/" rel="bookmark">
			Pycharm的Settings中，Pycharm - Python packaging tools not found问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：pycharm 无法加载pip3安装包报错：python packing tools not found. install packing tools 我的pycharm是加载python2的安装包没问题，但是python3的安装包加载不出来。通过卸载重装pip3都没有用
解决方法：更新一下setuptools就好啦
sudo pip3 install setuptools --upgrade sudo pip install setuptools --upgrade 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1780e052f1b2de5b5309e7c99b1547b2/" rel="bookmark">
			智算之道初赛第二场    第一题    声控灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A.声控灯 http://oj.csen.org.cn/contest/6/17
题目描述 小明正在上楼梯，当小明逐渐接近某层楼的时候，这层楼的声控灯检测到小明的脚步声便会亮起来，当小明逐渐远去的时候，声控灯由于一段时间内没检测到声音又会灭下去。
由于小明是匀速上楼的，而且他的速度把控得刚刚好，脚步声的音量也十分恰当，使得灯的亮灭呈现出这样的状态：他当前所在的楼层的声控灯是亮起的，他即将抵达的下一层楼的声控灯是亮起的，他刚刚离开的那层楼的声控灯也是亮起的。
现在你站在楼的外面，通过窗户看到了灯的亮灭状态，请推断小明现在在几楼？
输入格式 每个测试点包含以下内容：
第一行给出一个整数 T，表示接下来给出 T 组测试数据
每组测试数据包含两行
第一行包含两个数 n , m 表示这栋楼一共有 n 层，当前有 m 盏灯是亮起的，而其余灯都是熄灭的
第二行包含 m 个整数，这些整数按照从小到大的顺序给出亮起的灯的序号
保证输入数据是符合实际情况的
输出格式 输出 T 行，每行包含一个数字，按照输入的顺序依次给出每组测试数据的答案。如果答案不确定，请输出 -1−1
数据规模与约定 对于 50% 的数据，1 ≤ T ≤ 10, 3 ≤ n ≤ 100, m=3
对于100% 的测试点，1 ≤ T ≤ 1000,1 ≤ n ≤ 109 ,1 ≤ m ≤ 3
样例输入 2
5 3
1 2 3
5 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1780e052f1b2de5b5309e7c99b1547b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f78a99406134790d38fa58661e63c7a5/" rel="bookmark">
			jmeter接口自动化（jmeter&#43;jenkins&#43;Ant）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 jmeter安装及配置：安装jmeter并配置好环境变量，在dos窗口输入jmeter并回车，如果可以正常启动，则安装成功了
配置修改jmeter相关文件
配置ANT（ANT触发jmeter脚本）：将jmeter的extras目录下的ant-jmeter-1.1.1.jar复制到ANT的bin目录之下
框架目录结构创建
将ant软件放在jmeter-auto-test下的ant目录下
配置ant的环境变量，配置完成后在dos窗口输入ant -version指令；指令中ant和-之间有空格
获取build.xml和项目结构目录文件链接：
https://pan.baidu.com/s/1HY0YAvLUQGF6lje02NEZaw
提取码：wvum配置build.xml
9.至此框架及配置已经完成
10.可以写个jmeter脚本进行本地运行
11.指定jenkins定时任务去运行自动化测试
至此所有的步骤已经完成，最后提醒各位小伙伴需要注意的几点：1.学习前要对jenkins的搭建及任务创建、任务配置有一定的基础了解；2.学习此文章时注意看整体目录结构；3.文章中很多地方都没有详细讲解，比如邮件配置、jmeter使用等，都需要小伙伴自己去学习，此文章只是讲一个大体的框架；4.最后有哪里不好的或者不妥的请各位大神随时指正，感谢 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f6e648f15114b05753df2231c4e86a1/" rel="bookmark">
			虚幻4基础：UMG控件（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Removed from Focus Path 判断当前的要对哪个控件进行操作。点击一个Button，然后鼠标离开，就会触发该事件。也就是监听用户对一个可交互的控件进行的访问。
Added to Focus Path 这个就和上面的相对应。
On Preview Mouse Button Down 当鼠标敲击控件的时候，可以获取到该控件的坐标。
点击右上方的Designer，放置两个按钮，一个image，一个button。
运行，这个时候按钮会出现在屏幕上面。
然后点击按钮，就会触发这个事件。
另一方面：On Preview Mouse Button Down中的My Geometry也有如下参数：
Get Absolute Size：游戏视口大小
Absolute to Local：世界坐标转化成本地（相对）坐标
Get Local Size：获取相对坐标
Is Under Location：判断是否敲击到这个坐标了
Local to Viewport：相对坐标转换成视口的坐标
Preview Key Down 光标移动过去，键盘敲击点击可交互控件，可以激活该事件。
On Paint Draw Box：绘制一个Box。具体操作如下。
GetPlayerController-&gt;Get Mouse Position Scaled by DPI-&gt;Make Vector 2D(return value-&gt;)Draw Box(position)。
Brush：是Slate的Brush，在Default Value中可以载入自定义的Brush。然后可以调整颜色。
Draw Line（s）：绘制一条线，需要输入点的坐标。
Draw Text：可以以Make Literal Text作为输入text，以上述的鼠标位置作为输入位置，还可以自定义一个字体。
鼠标对控件的操作 On Mouse Button Double Click：双击触发
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f6e648f15114b05753df2231c4e86a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3e05b0ea5f00116d58152c807004b27/" rel="bookmark">
			基于librtmp的AAC audio发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章写过“解决基于librtmp库的rtmp直播服务第一帧图出现比较慢的问题”，针对这个问题，我在上一篇文章中分析过主要是因为播放器调用了ffmpeg中的接口avformat_find_stream_info()。如何加速avformat_find_stream_info()接口函数的返回，可以采用如下方法：1、减少该接口函数的探测时间，不过这样做可能会牺牲探测的准确率；2、如果音视频来源比较单一，可以事先指定某些参数，比如视频编码格式等加速该接口的返回。今天我讲讲我采用的第三种方法：人为增加音频数据，加速该接口函数的返回。
首先封装librtmp推送音频数据接口，代码如下：
int rtmp_client_send_audio(int handle,const char *data,int len, long timetamp){ context_t t = {0,"",NULL}; mutex_lock(&amp;g_mutex); std::map&lt;int, context_t&gt;::iterator it = g_contexts.find(handle); if (it!=g_contexts.end()) { t = it-&gt;second; } mutex_unlock(&amp;g_mutex); if (t.rtmp == NULL) return rc_code_fail; if (data == NULL || len &lt;= 0) return rc_code_fail; RTMPPacket *packet; unsigned char *body; packet = (RTMPPacket *)malloc((sizeof(RTMPPacket)+RTMP_MAX_HEADER_SIZE) + len + 2); memset(packet, 0, (sizeof(RTMPPacket)+RTMP_MAX_HEADER_SIZE)); packet-&gt;m_body = (char*)packet + (sizeof(RTMPPacket)+RTMP_MAX_HEADER_SIZE); body = (unsigned char *) packet-&gt;m_body; body[0] = 0xAF; body[1] = 0x01; memcpy(&amp;body[2],data,len); packet-&gt;m_packetType = RTMP_PACKET_TYPE_AUDIO; packet-&gt;m_nBodySize = len + 2; packet-&gt;m_nChannel = 0x06; packet-&gt;m_nTimeStamp = timetamp; packet-&gt;m_hasAbsTimestamp = 0; packet-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE; packet-&gt;m_nInfoField2 = t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3e05b0ea5f00116d58152c807004b27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cc6c35c25a5cafec8431ae003fe5ec8/" rel="bookmark">
			Elastic Search6.8.0安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CentOs7环境下安装Elastic Search6.8.0，Linux客户端工具为Xshell5，
Eleastic 官网地址为：https://www.elastic.co/cn/
已发布版本下载地址为：https://www.elastic.co/cn/downloads/past-releases#elasticsearch
链接：https://pan.baidu.com/s/1TXRn-2Y1nO4OexEymFeVhw
提取码：4jzb
安装步骤如下：
Note：
安装es前必须安装JDK.
安装启动es不能使用root账户，需要使用普通用户
1.创建普通用户
在linux系统中创建新的组 groupadd morning 创建新的用户morning并将morning用户放入morning组中 useradd morning -g morning 修改es用户密码 passwd morning 2.使用rz命令上传安装文件到linux服务器路径下/opt/software
Note：如果没安装lrzsz，使用root账户登录安装 yum install -y lrzsz
3.解压
tar -zxvf elasticsearch-6.8.0.tar.gz -C ../module/ 4.进入es安装目录查看目录结构
bin 可执行的二进制文件的目录
config 配置文件的目录
lib 运行时依赖的库
logs 运行时日志文件
modules 运行时依赖的模块
plugins 可以安装官方以及第三方插件
5.进入bin目录中启动ES服务 ./elasticsearch
当出现started表示启动成功。
可以进入目录/opt/module/elasticsearch-6.8.0/logs日志 tail -500f elasticsearch.log
6.通过curl测试es是否正常启动 curl http://localhost:9200
7.开启远程访问
vi elasticsearch.yml 将原来network修改为以下配置:
network.host: 0.0.0.0
8.重启启动ES服务，会报以下错误。
9.需要使用root账户修改以下配置
1). /etc/security/limits.conf在最后面追加下面内容
vi /etc/security/limits.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cc6c35c25a5cafec8431ae003fe5ec8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8801e9ecdb87f6efff7e9976202a025/" rel="bookmark">
			【Mysql-3】条件判断函数-CASE WHEN、IF、IFNULL详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在众多SQL中，统计型SQL绝对是让人头疼的一类，之所以如此，是因为这种SQL中必然有大量的判读对比。而条件判断函数就是应对这类需求的利器。本文重点总结CASE WHEN、IF、IFNULL三种函数。
1 CASE WHEN Case when语句能在SQL语句中织入判断逻辑，类似于Java中的if else语句。
CASE WHEN语句分为简单函数和条件表达式。
1、简单函数
CASE 字段 WHEN 预期值 THEN 结果1 ELSE 结果2 END 如果字段值等于预期值，则返回结果1，否则返回结果2。
下面通过一个简单的示例来看一下具体用法。
表score：
场景：在score表中，sex为1表示男性，sex=0表示女性，查询时转换成汉字显示。
SQL语句：
SELECT name,(CASE sex WHEN 0 THEN '女' ELSE '男' END) sex FROM score 结果：
2、条件表达式
CASE的简单函数使用简便，但无法应对较为复杂的场景，这就需要用到条件表达式了，其语法结构如下：
CASE WHEN condition THEN result1 ELSE result2 END 解释一下，语句中的condition是条件判断，如果该判断结果为true，那么CASE语句将返回result，否则返回result2，如果没有ELSE，则返回null。CASE与END之间可以有多个WHEN…THEN…ELSE语句。END表示CASE语句结束。
场景：score 大于等于90为优秀，80-90为良好，60-80为及格，小于60为不及格，用SQL语句统计出每个学生的成绩级别。
SQL:
SELECT name,score,(CASE WHEN score&gt;=90 THEN '优秀' WHEN score&gt;=80 THEN '良好' WHEN score&gt;=60 THEN '及格' ELSE '不及格' END) level FROM score 结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8801e9ecdb87f6efff7e9976202a025/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2e081211cfa11c952790bc67ca119d3/" rel="bookmark">
			原生JavaScript一步步实现焦点轮播图：基本布局-＞边界条件-＞绑定圆点-＞优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		轮播图是在大家学习 JavaScript 时常写的小项目，网络上相关的资源也很多。我在学习的过程中，将写轮播图的经历做一些简单的总结，希望大家在看后能有所收获，如果有不对的地方，请大家在留言区指出。
前言 轮播图是什么 Q:轮播图是什么？ A:简单解释：所谓的轮播图，就是几张图片轮流显示。
我们先随便找个网站访问一下，例如 淘宝网 首页中间这一块。
中间的滚动区域就是轮播图。
哪些知识点 通过轮播图，我们可以巩固(学到)什么知识点呢？
DOM 操作 HTML事件运用定时器无限滚动技巧JavaScript 动画函数递归 注意 个人建议：作为新手的我们，不管要做多么高大上的特效，都先完成静态页面，再去添加动态的处理！！！切记切记！
原理 实现效果 轮播图的实现效果：即在一个窗口，鼠标移入后左右箭头会出现，可以点击动画切换图片，同时下面的小圆点会跟随切换（点击小圆点可以实现同样的功能），可以在此基础上循环播放。
总结：轮播图片具备以下特点：
点击左右两边的箭头切换图片当鼠标移出图片范围，自动间隔时间切换；当鼠标移入图片范围，停止自动切换切换到某一张图片时，底部的圆点样式也跟着改变点击底部圆点也会切换到相应位置的图片 基本布局 我们首先要明白轮播图的实现原理和基本布局：
将一系列大小相等的图片平铺，利用 CSS 布局只显示一张图片，其余隐藏。通过 JS 代码修改图片的偏移量实现切换，按钮绑定切换事件，或者定时器实现自动播放。
初始基本结构如下：
最外层需要有一个容器包裹着（通常是 div，类型定义为 container）容器设置宽高，以及 overflow 为 hidden，超出宽高部分隐藏，容器里面包含着两个容器：imgList 和 btnList 以及两个 a 标签（左右按钮）imgList 中包裹着所有的图片，宽为所有图片的总宽度，position 为 absolute（通过改变 left 来实现图片轮播的效果）btnList 中包裹着轮播图下部的指示圆点，position 也为 absolute 样式可以自己按照自己想要的修改，在此我们主要将关键部分。并且完成代码。
为节省页面空间，之后代码均不格式化，请大家自行修改。
html 结构 html 代码按照我们讲的基本布局完成，代码如下：
&lt;body&gt; &lt;!--主容器--&gt; &lt;div id="container"&gt; &lt;!--图片容器--&gt; &lt;div id="imgList" style="left: -600px"&gt; &lt;img src="img/5.jpg" alt="1" /&gt; &lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2e081211cfa11c952790bc67ca119d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e3956548d1095020228f6c7d6e5b988/" rel="bookmark">
			图片数据量大小计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算公式：宽度✖高度✖波段数✖位深➗8
假设图片的宽高为：52195 41587，波段数为：3，位深：8
数据量大小为：52195✖41587✖3✖8➗8=6,511,900,395 byte=6.06 GB
单位换算： 1 byte=8 bit（位）
1 KB=1024 byte
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdd5820099708008550710f2bc59d72c/" rel="bookmark">
			setTimeout和setImmediate到底谁先执行，本文让你彻底理解Event Loop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者以前面试的时候经常遇到写一堆setTimeout,setImmediate来问哪个先执行。本文主要就是来讲这个问题的，但是不是简单的讲讲哪个先，哪个后。笼统的知道setImmediate比setTimeout(fn, 0)先执行是不够的，因为有些情况下setTimeout(fn, 0)是会比setImmediate先执行的。要彻底搞明白这个问题，我们需要系统的学习JS的异步机制和底层原理。本文就会从异步基本概念出发，一直讲到Event Loop的底层原理，让你彻底搞懂setTimeout,setImmediate，Promise, process.nextTick谁先谁后这一类问题。
同步和异步 同步异步简单理解就是，同步的代码都是按照书写顺序执行的，异步的代码可能跟书写顺序不一样，写在后面的可能先执行。下面来看个例子：
const syncFunc = () =&gt; { const time = new Date().getTime(); while(true) { if(new Date().getTime() - time &gt; 2000) { break; } } console.log(2); } console.log(1); syncFunc(); console.log(3); 上述代码会先打印出1，然后调用syncFunc，syncFunc里面while循环会运行2秒，然后打印出2，最后打印出3。所以这里代码的执行顺序跟我们的书写顺序是一致，他是同步代码：
再来看个异步例子：
const asyncFunc = () =&gt; { setTimeout(() =&gt; { console.log(2); }, 2000); } console.log(1); asyncFunc(); console.log(3); 上述代码的输出是：
可以看到我们中间调用的asyncFunc里面的2却是最后输出的，这是因为setTimeout是一个异步方法。他的作用是设置一个定时器，等定时器时间到了再执行回调里面的代码。所以异步就相当于做一件事，但是并不是马上做，而是你先给别人打了个招呼，说xxx条件满足的时候就干什么什么。就像你晚上睡觉前在手机上设置了一个第二天早上7天的闹钟，就相当于给了手机一个异步事件，触发条件是时间到达早上7点。使用异步的好处是你只需要设置好异步的触发条件就可以去干别的事情了，所以异步不会阻塞主干上事件的执行。特别是对于JS这种只有一个线程的语言，如果都像我们第一个例子那样去while(true)，那浏览器就只有一直卡死了，只有等这个循环运行完才会有响应。
JS异步是怎么实现的 我们都知道JS是单线程的，那单线程是怎么实现异步的呢？事实上所谓的"JS是单线程的"只是指JS的主运行线程只有一个，而不是整个运行环境都是单线程。JS的运行环境主要是浏览器，以大家都很熟悉的Chrome的内核为例，他不仅是多线程的，而且是多进程的：
上图只是一个概括分类，意思是Chrome有这几类的进程和线程，并不是每种只有一个，比如渲染进程就有多个，每个选项卡都有自己的渲染进程。有时候我们使用Chrome会遇到某个选项卡崩溃或者没有响应的情况，这个选项卡对应的渲染进程可能就崩溃了，但是其他选项卡并没有用这个渲染进程，他们有自己的渲染进程，所以其他选项卡并不会受影响。这也是Chrome单个页面崩溃并不会导致浏览器崩溃的原因，而不是像老IE那样，一个页面卡了导致整个浏览器都卡。
对于前端工程师来说，主要关心的还是渲染进程，下面来分别看下里面每个线程是做什么的。
GUI线程 GUI线程就是渲染页面的，他解析HTML和CSS，然后将他们构建成DOM树和渲染树就是这个线程负责的。
JS引擎线程 这个线程就是负责执行JS的主线程，前面说的"JS是单线程的"就是指的这个线程。大名鼎鼎的Chrome V8引擎就是在这个线程运行的。需要注意的是，这个线程跟GUI线程是互斥的。互斥的原因是JS也可以操作DOM，如果JS线程和GUI线程同时操作DOM，结果就混乱了，不知道到底渲染哪个结果。这带来的后果就是如果JS长时间运行，GUI线程就不能执行，整个页面就感觉卡死了。所以我们最开始例子的while(true)这样长时间的同步代码在真正开发时是绝对不允许的。
定时器线程 前面异步例子的setTimeout其实就运行在这里，他跟JS主线程根本不在同一个地方，所以“单线程的JS”能够实现异步。JS的定时器方法还有setInterval，也是在这个线程。
事件触发线程 定时器线程其实只是一个计时的作用，他并不会真正执行时间到了的回调，真正执行这个回调的还是JS主线程。所以当时间到了定时器线程会将这个回调事件给到事件触发线程，然后事件触发线程将它加到事件队列里面去。最终JS主线程从事件队列取出这个回调执行。事件触发线程不仅会将定时器事件放入任务队列，其他满足条件的事件也是他负责放进任务队列。
异步HTTP请求线程 这个线程负责处理异步的ajax请求，当请求完成后，他也会通知事件触发线程，然后事件触发线程将这个事件放入事件队列给主线程执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdd5820099708008550710f2bc59d72c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea44a373befbc71d0649fdfbb858e189/" rel="bookmark">
			敖丙给我回信了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于敖丙 蘑菇街的后端大佬-敖丙，我相信遨游 在CSDN中的很多人都知道他，出身农村，却从大学开始了他的开挂人生，曾经获得过许多大厂的offer，曾经在阿里任职。现在是在蘑菇街的后端岗位。
这张图片里其中一个就是敖丙，如果你不知道是谁，那你需要去读读他的博客了，当然，图里的每一个人都是大佬。
我开始关注他是从今年的一月份，当时刚放寒假，回家后自己经历了一些事情，对于未来越加迷茫，就在csdn里面搜索一些关于程序员话题的文章阅读。当时我无意间翻到了他的一篇名为《昂，我24岁了》的博客，看完后感触颇深，从此我就开始持续的关注这个在我看来短短几年里人生就在开挂的程序员…
对于他的关注起初不是开始于他的技术，而是他的人生故事和写作的那一股尺度拿捏的刚刚好的幽默风趣，直到我多读了几篇他的文章，才发现原来这个大佬不仅仅水文写的好，技术文章也是六的一批。他的github上收录了很多的精彩技术文章，我相信关注过他的人都应该看过。
不得不说的是他的技术分享对于我有很大的帮助，但是我个人更加喜欢听和喜欢看他的人生经历和故事。这也是我对他印象深刻的原因。就好似作者大冰的《我不》、《乖，摸摸头》，写的那么的逼近生活却又带了些许的江湖气息，让你感觉即亲近又陌生。
敖丙回我邮件了！ 这周我和往常一样看他的技术分享和水文，突然产生一个念头，自己也想创建一个公众号写一写技术，分享一下日常，再加上自己最近的压力确实有点大，不知道对于未来应该抱有怎样的态度和想法，于是尝试微信联系他，然后记得他说过微信私信他的人太多，没时间看。于是我想到了邮件，因为敖丙的粉丝给他发文章的时候用的就是邮件，邮件他应该会看。我就抱着试一下的态度给敖丙发了一封邮件。大概的内容就是介绍了一下自己的学习现状和实习现状，同时询问了一下他关于开公众号的看法和对于未来的看法。昨天晚上我下班回寝室的时候真的就收到了它的回信！！！！，我真的没有想到，真的回了，而且我很确定回邮件的就是 他本人，因为邮件里的谈吐我很熟悉，就是我追了半年多的三太子敖丙
以下是他的回信内容:
回复的内容不多，确实很真实，对我也是很大的鼓励。他说的没错，没有好的技术 沉淀确实是写不出好的东西，你写的别人 都能写，那你怎么可能获得更多的关注度？
就像是那些作者们，大冰、村上，路垚，没有经历一些事情，没有体会和理解人生，怎么会有好的作品？当然在这里使用他们做比喻很不恰当，这些神一般的人物怎么能和我们相提并论呢，但是道理不就是 这么个道理吗。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8acf61e48c7861964c73e60175c17715/" rel="bookmark">
			用C语言实现一个简单的一元线性回归算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们用C语言实现一个简单的线性回归算法；在代码前面我们在回顾一下线性回归。
线性回归是回归问题中的一种，线性回归假设目标值与特征是线性相关的，即满足一个多元一次方程式。通过构建损失函数，来求解损失函数最小时的参数W和b。通常表达式可以表示如下：
其中 y 为预测值，自变量X和因变量y是已知的，我们要想实现的是，当一个新增的X出现时，我们要预测y的值。因此我们构建这个函数关系，是通过已知的数据求解函数模型中位置的W和b这两个参数。
我们用均方误差为损失函数即：
将函数带入即为：
我们现在的任务就是求解最小化 L 时的W 和b，即将核心目标优化为
此处我们用梯度下降法进行求解
为了求偏导数，当只有一个样本时，即： 我们这里就简单的处理为求解，至于计算何时结束我们先不做考虑，就简单粗暴给其设定计算次数。
理解了最小误差的求解原理我们就开始上代码了。
LinerRegression.h
#ifndef LINERREGRESSION_LINERREGRESSION_H #define LINERREGRESSION_LINERREGRESSION_H //初始化函数 void set_config(double learning_rate,long int max_iter,int X_Len); //训练 void fit(double *train_x,double *train_y); //计算 double* _f(const double *train_x,double w,double b); //预测 double* predict(double *train_x); //损失 double loss(const double *y_true,const double *y_pred); //求梯度 void _calc_gradient(); //单步更新 void _train_step(); #endif LinerRegression.c
#include &lt;stdio.h&gt; #include &lt;stddef.h&gt; #include &lt;malloc.h&gt; #include "LinerRegression.h" //设置固定学习率 double g_learning_rate = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8acf61e48c7861964c73e60175c17715/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80bc890dbdeff77736b525294262a767/" rel="bookmark">
			读 稻盛和夫《干法》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		周六，下午刚好有空，读完了这本书。从刚开始觉得这本书有点洗脑倾向，越看越能感觉作者的真诚（他就是这么想也是这么做的），颇有收益！并逐一思考自己能做哪些切实的应用、改善。
以下内容是个人笔记，建议阅读原书。
人生苦难（稻盛和夫开始工作的时候，二战结束约10多年，经济还未完全复苏，有很多人还在饿肚子） 苦难既不是我们希望的， 也不是我们招惹来的， 但意想不到的苦
难却接踵而来。 苦难和不幸袭击我们、 折磨我们， 让我们为自己的命
运而怨恨， 甚至灰心丧气， 稍一气馁便被苦难击垮
工作的目的 人工作的目的是为了提升自己的心志——这是我的观点。
工作能够锻炼人性、 磨砺心志， 工作是人生最尊贵、 最重要、 最
有价值的行为。
极度认真的工作 不再发牢骚， 不再说怪话， 我把心思都集中到自己当前的本职工
作中来， 聚精会神， 全力以赴。 这时候我才开始发自内心并用格斗的
气魄， 以积极的态度认真面对自己的工作。
此以后， 我工作的认真程度， 真的可以用“极度”二字来形容。
与此同时， 进公司后要辞职的念头以及“自己的人生将会怎样”之
类的迷惑和烦恼， 都奇迹般地消失了。
自燃型的人的人 所谓“自燃型”的人， 就是从来不会“等别人吩咐了才去干”“因为
有了命令才工作”的人， 而是“在别人吩咐之前自发去干”的主动积极
的人， 他们应该都是热爱工作的人。
在旋涡中心工作 像这样自己主动领头、 带动周围的人把工作有声有色地开展起来的人， 我把他们称
作“在旋涡中心工作的人”。
一个组织里总有这样的人： 没有谁来要求他做， 他却自己主动提
议要干这干那。
…… 如果能开口说出这样的话， 那么此人就是“在旋涡中心工作的
人”， 他就有希望成为团队的领导者。
敢于说这样的话的人， 不是为了装样子给别人看， 而是真的热爱
工作， 有强烈的“问题意识”。 只有这样的人， 才有这种魄力。
热爱工作， 就不会单纯按照上司的指示办， 就会有自己“制造旋
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80bc890dbdeff77736b525294262a767/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41100a616accda2b2908174c67832b37/" rel="bookmark">
			[密码学基础][每个信息安全博士生应该知道的52件事][Bristol Cryptography][第28篇]什么是公钥密码学的IND-CCA安全定义？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一系列博客文章中最新的一篇，该文章列举了“每个博士生在做密码学时应该知道的52件事”:一系列问题的汇编是为了让博士生们在第一年结束时知道些什么。讨论了用于公钥加密的IND-CCA安全性。
IND-CCA安全代表选择明文的不可伪造性。这样的安全方案的思想就是给定一个密文，攻击者不能说出给定密文是什么样的明文加密得到的。在这个模型中，攻击者被允许使用加密问询和解密问询。问询既可以在第三步和第四步之前也可以在之后。公钥的IND-CCA的find-then-guess安全游戏的描述：
IND-CCA安全有另外一个版本，真实还是随机。主要的不同就是第五步中并不是由攻击者输出的消息。而是一个随机的m‘。A必须区分它是真的还是随机的。概率和安全和上述定义基本相同。
这两个定义是等价的，如果一个方案在实数或随机意义上对对手a是IND-CCA安全的，我们可以构造一个对手B用于查找和猜测，这样两个优势都是相等的。类似地，如果一个方案对对手a是发现和猜测安全的，我们可以构造一个这样的对手B使得：
原文链接：http://bristolcrypto.blogspot.com/2015/04/52-things-number-28-what-is-ind-cca.html
转载链接：https://www.cnblogs.com/zhuowangy2k/p/12245569.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a9eab6bb390595a4b66fcd1d414c68b/" rel="bookmark">
			CDN原理以及七牛云设置CDN加速教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理 第一次访问还是直接访问web服务器，我们发送请求数据帧给web服务器时，web服务器的所属IPS会将已经设置了CDN的服务器web内容，在其所有的CDN缓存服务器中备份，当我们向web服务器发送请求时，通过重定向技术，使其访问最近(全局负载均衡技术 – web向所有的CDN缓存服务器进行选择，选择离客户机最近的CDN缓存服务器)的CDN缓存服务器，通过其直接响应达到加速的效果。
教程 详解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79d7625292bf25bb169e2087a18dc620/" rel="bookmark">
			Pycharm远程连接Spark（超详细图文教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Pycharm连接远程服务器上的时候，有很多小的细节，笔者这里总结了一下完整的步骤，希望能帮到大家。连接前一定要保证集群已经可以运行pyspark程序。
1.添加SFTP连接 找到菜单栏Tool -&gt; Deployment -&gt; Configuration设置sftp
点击左上角的+号，添加新的连接
注意，不要勾选Visible only for this project。根据自己的需求填写host、username、password，然后点击Test SFTP connection ，确认能连接（注意：如果这里连接失败，且其他的终端，例如xshell、putty可以成功连接的话，请将pycharm版本切换到2018版本，2019版本的pycharm在这里可能会引起timeout！！！）
然后设置一下项目的路径，点击mapping
点击OK
2.添加SSH Interpreter 找到菜单栏File -&gt; Settings
搜索Project Interpreter，点击齿轮，选择add
选择SSH Interpreter，选择下面的Existing server configuration，选中我们刚刚设置的SSH信息
根据需要修改路径，我这里是linux上默认的python的路径
修改本地与服务器路径
点击finish
3.代码编写 然后写上代码
wordcount.py
# coding=UTF-8 import sys # 设置服务器上py4j库所在的路径 sys.path.append('/home/hadoop/apps/spark/python/lib/py4j-0.10.7-src.zip') from pyspark.sql import SparkSession if __name__ == "__main__": # 如果spark配置了yarn集群，这里的master可以修改为yarn spark = SparkSession.builder \ .master('local') \ .appName('Pycharm Connection') \ .getOrCreate() # wordcount操作，这里文件为hdfs的路径 words = spark.sparkContext \ .textFile("/data/words") \ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79d7625292bf25bb169e2087a18dc620/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9399f82f594c439f94e83b7d9ad61358/" rel="bookmark">
			栈:进栈，出栈，取栈顶元素，判断栈是否为空，置空栈，输出元素个数等 (c语言，数据结构)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		栈:进栈，出栈，取栈顶元素，判断栈是否为空，置空栈，输出元素个数等 注：用switch进行选择操作。
//栈:进栈，出栈，取栈顶元素，判断栈是否为空，置空栈，输出元素个数等。 #include"stdio.h" #define maxsize 100 typedef struct { int datas[maxsize]; int top; }link; void menu(void) { printf("\n///"); printf("\n 1 判栈空 2 进栈 "); printf("\n 3 出栈 4 取栈顶元素 "); printf("\n 5 栈置空 6 求当前元素个数 "); printf("\n 7 显示栈中元素 8 退出"); printf("\n///"); } void initialize(link *a)//初始化函数 { a-&gt;top=0; } int judge(link *a)//判断栈是否为空 { if(a-&gt;top==0) return 0; else return 1; } int enter(link *a,int x)//进栈 { if(a-&gt;top==maxsize-1) { printf("此栈已满\n"); return 0; } else { a-&gt;top++; (a-&gt;datas)[a-&gt;top]=x; return 1; } } int out(link *a,int x)//出栈，栈的特点是*后进先出*，出栈的是最后一个元素 { if(judge(a)==0) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9399f82f594c439f94e83b7d9ad61358/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cecdcc215bf0d478077ceec266906821/" rel="bookmark">
			n个台阶,每次只能走一步或者两步,求多少种走法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最重要的就是最后一步:如果走一步就需要f(n-1)种,如果走两步就需要f(n-2)种 走一个台阶:1种-f(1) 走两个台阶:2种-f(2) 三个台阶:先走一个台阶f1和最后一次走两个台阶:f(1) 先走二个台阶f2和最后一次走一个台阶:f(2) f(3)=f(1)+f(2) 四个台阶:先走三个台阶和最后一次走一个:f(3) 先走两个台阶和最后一次两个台阶:f(2) f(4)=f(2)+f(3) n个台阶:f(n)=f(n-1)+f(n-2) package myjava.递归和迭代; /** * @author wxy * @description 台阶算法,有n个台阶,一次只能走一步或者两步 * 思路: * 1.递归:代码易懂,但是方法调用次数过多,内存消耗大,执行速度慢 * 2.迭代:代码难懂,但是性能快,内存消耗小 * @data 2020/7/17 */ public class Step { public static void main(String[] args) throws Exception { long start = System.currentTimeMillis(); System.out.println(f(40)); //System.out.println(loop(70)); long end = System.currentTimeMillis(); System.out.println(end-start); } /**递归 **/ public static int f(int n) throws Exception { int i = 2; if (n &lt;1){ throw new IllegalArgumentException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cecdcc215bf0d478077ceec266906821/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3aa11eddc6882399b9c810e62813511/" rel="bookmark">
			uni-app 微信小程序全局图片加载失败处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 image的error事件 &lt;image :src="take" @error="imgError('take')"&gt;&lt;/image&gt; 处理 tool.js
/* 图片加载失败处理 that 图片绑定字段所属对象 dat 图片绑定字段 */ export const imgErr = (that,dat)=&gt;{ that[dat] = "../../static/img/sb.png" //默认图片路径 // 默认图片路径如果也加载失败 就没了 不会继续触发 } 单个图片处理 &lt;image :src="take" @error="imgError('take')"&gt;&lt;/image&gt; import {imgErr} from '@/store/tool.js' methods:{ imgError(str){ imgErr(this,str) }, } 多个图片处理 &lt;image v-for="(item,i) in cArr" :src="item" :key="i"@error="imgErrorArr(cArr,i)"&gt;&lt;/image&gt; import {imgErr} from '@/store/tool.js' methods:{ data(){ return{ arr:[ //'xx.jpg','xx2.jpg' ] } } imgError(arr,str){ imgErr(arr,str) }, } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a1a53ee89851ec6dbce30d2700877a/" rel="bookmark">
			Codeforces 1210 D Konrad and Company Evaluation —— 暴力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		This way
题意： 现在有n个人，第i个人的工资一开始是i，现在有一些人相互讨厌，然后如果第x个人和第y个人相互讨厌，并且x的工资比y高，那么x就会向y炫耀。
x,y,z这三个人的组合是危险的，当x会向y炫耀，y会向z炫耀。
每次修改一个人的工资为大于所有人，并且询问你此时有多少种三人组合是危险的
题解： 那么这道题就有一个很暴力的做法，我们通过样例解释可以发现，其实就是一张有向图，然后答案是每个点的入度*出度。之后的话就是修改每个点的入边为出边。如果每次输入暴力修改每个点的入边为出边的话，乍一看是 O ( n 2 ) O(n^2) O(n2)的，但是仔细思考可以发现，每一条边只连接了2个人，并且它会翻转当且仅当修改的是被指向的那个人。
也就是说，如果修改一个人的值会翻转n条边，那么只有在接下来修改n个人的值才能将所有边翻转回来。
所以我断定暴力修改的时间复杂度是O(n)的，然后用vector维护每条边的反边，在删除的时候是O(log)的，所以总的时间复杂度是 O ( n l o g n ) O(nlogn) O(nlogn)的。如果用map维护的话，时间复杂度是 O ( n ∗ q ∗ l o g n ) O(n*q*logn) O(n∗q∗logn)
最终时间复杂度：
#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int N=1e5+5; vector&lt;int&gt;mp[N]; int in[N],out[N]; int main() { int n,m,x,y; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++){ scanf("%d%d",&amp;x,&amp;y); if(x&gt;y)swap(x,y); mp[x].push_back(y),in[x]++,out[y]++; } ll ans=0; for(int i=1;i&lt;=n;i++) ans+=1ll*in[i]*out[i]; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99a1a53ee89851ec6dbce30d2700877a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34b7957215886c0162419d44a5a24d8b/" rel="bookmark">
			虚幻4基础：String的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		String的操作 与Text类似，Trim Trailing是删除尾部空白字符，Trim是删除前面的空白字符，ToUpper变大写，ToLower变小写。
Time Second to String是把时间变成String，Get Time Second起到了计数的作用，将时间传递给Time Second to String。Event Tick需要连接到Print String上，做到高频率输出。
其他: Right Pad，在源字符串后面加字节。例如：
Source String：abc
Ch Count： 0
return value接到Append中的A和B，输出Append的Return Value。
输出为abcabc，在abc的后面填充0个字节，然后跟自己相加，变成abcabc。
如果将Ch Count: 改为12。就意味着在abc后面填充12个字节。变成了abc（中间6个空格）abc。因为一个字符串是2个字节，所以是6个空格。
Right Chop就是从第几个字符开始保留。Right，保留后5个字符串。
Reverse，反向排列。
Replace 和Replace inline没什么区别。都是把一个字符串中，某一个字符修改为另一个值。
String的拆分 Parse Into Array：分割字符串。以某个分隔符切割为数组。
Delemiter：！
string：asdf！1234
return value：qwe和1234
这里用ForEachLoop作为循环把string分割，输出array element
Cull Empty Strings：是否剔除空格字符
与之相对应的是Join String Array，把多个数组以Separator为分隔符，压缩成一个数组。
人宅老师课上说：这两对儿对于服务器和客户端之间的通信比较有用，是打包和解包过程中的一部分。
Mid比较好理解，就是从第i个字符开始，截取j个字符，意味着字符从i到i+j被输出。这个与Get Substring一模一样。
（但是说实话我觉得Get Substring的参数看起来更直观）
Matches Wildcard：查看该string里有没有通配符（*和？）如果有，则返回true。
Is Numeric：看字符串是不是只有数字
Get Character as Number：把字符串转为ASCII码。
Get Character Array from String：把String里的字符串一个一个打印出来。比如输入abcdegf，输出就是a b c d e f g。这里要用循环一个一个打出来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34b7957215886c0162419d44a5a24d8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb5c044bf57123ffffba516bc27d280/" rel="bookmark">
			Python 游戏辅助基础之 AutoPy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 游戏辅助基础之 AutoPy AutoPy 的安装AutoPy 的6个功能模块alert 模块bitmap 模块color 模块key 模块mouse 模块screen 模块 小结 AutoPy 的安装 通过pip安装就好了pip install autopy AutoPy 的6个功能模块 AutoPy有6个功能模块为什么有6个因为官方文档里面就介绍了6个当然从__init__.py中也可以看出来# -*- coding: utf-8 -*- """ AutoPy is a simple, cross-platform GUI automation library for Python. """ from . import alert, bitmap, color, key, mouse, screen __author__ = "Michael Sanders" __version__ = "4.0.0" __all__ = ["alert", "bitmap", "color", "key", "mouse", "screen"] AutoPy is a simple, cross-platform GUI automation library for Python.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfb5c044bf57123ffffba516bc27d280/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93034a04227ee56d75e273988f0b552b/" rel="bookmark">
			php和mysql把时间为‘年月日时分秒’的格式转换为‘年月日‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 php把 ‘年月日时分秒’的格式转换为‘年月日‘
先转换为时间戳-》再转换为‘年月日’
date("Y-m-d",strtotime('2010-03-24 08:15:42')) mysql把‘年月日时分秒’的格式转换为‘年月日‘ date(字段名)
date(time) as addtime 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/612094478a5c451e143877e6be55f615/" rel="bookmark">
			sqlalchemy.orm.exc.UnmappedInstanceError: Class ‘builtins.NoneType‘ is not mapped
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误的为： message = Message.query.filter(message_id == Message.id) db.session.delete(message) db.session.commit() 更改为： message = Message.query.get(message_id) db.session.delete(message) db.session.commit() 先用get通过id号获取记录，再进行删除。
不能用filter来获取记录，再删除，也许可以试试filter(条件).first()？？？这样才可以获取到记录？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfbb11f962ba50fe951e34e40d0c7fac/" rel="bookmark">
			mybatis的SQL注入如何防止、#和$ 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SQL注入 SQL注入是一种攻击手段，它指的是使用构造恶意的SQL语句，欺骗服务器执行SQL命令，让后台的数据库去解析，从而达到入侵目标网络，获取敏感信息的攻击手段。
如何防止sql注入 #{}是经过预编译的，是安全的，${}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。MyBatis的SQL预编译是JDBC中的PreparedStatement类在起作用，PreparedStatement是Statement的子类，它的对象包含了编译好的SQL语句。这种“准备好”的方式不仅能提高安全性，而且在多次执行同一个SQL时，能够提高效率。原因是SQL已编译好，再次执行时无需再编译了。$ {} 这样格式的参数会直接参与SQL编译，从而不能避免注入攻击。但涉及到动态表名和列名时，只能使用${}这样的参数格式。所以，这样的参数需要我们在代码中手工进行过滤处理来防止注入。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f52c4b76c9e32c48a8e5d185c42915a6/" rel="bookmark">
			2048详细逻辑讲解（硬货！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2048虽然只是一个小单机，到处都是，但重要的我们是要锻炼自己的逻辑思维，2048对于一些初入JS的同学而言，很值得参考
话不多说，我们直接上代码：
首先是HTML
&lt;body&gt; &lt;p&gt;2048&lt;/p&gt; &lt;div class="star"&gt;score:&lt;span id="score01"&gt;0&lt;/span&gt;（这里放一个元素在JS里储存它的变量）&lt;/div&gt; &lt;div class="big"&gt; &lt;!-- 第一行 --&gt; &lt;div class="cell n2" id="c00"&gt;2&lt;/div&gt; &lt;div class="cell n" id="c01"&gt;&lt;/div&gt; &lt;div class="cell n4" id="c02"&gt;4&lt;/div&gt; &lt;div class="cell n" id="c03"&gt;&lt;/div&gt; &lt;!-- 第二行 --&gt; &lt;div class="cell n" id="c10"&gt;&lt;/div&gt; &lt;div class="cell n2048" id="c11"&gt;2048&lt;/div&gt;(这里只是做一个简单的视图看看效果，后面会写JS覆盖掉) &lt;div class="cell " id="c12"&gt;&lt;/div&gt; &lt;div class="cell " id="c13"&gt;&lt;/div&gt; &lt;!-- 第三行 --&gt; &lt;div class="cell " id="c20"&gt;&lt;/div&gt; &lt;div class="cell " id="c21"&gt;&lt;/div&gt; &lt;div class="cell " id="c22"&gt;&lt;/div&gt; &lt;div class="cell " id="c23"&gt;&lt;/div&gt; &lt;!-- 第四行 --&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f52c4b76c9e32c48a8e5d185c42915a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1e409e140e764ba77d8ad28f26a0c9c/" rel="bookmark">
			idea 配置spark hive踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.保证本地装有hadoop，并且保证 %HADOOP_HOME%\bin\winutils.exe chmod 777 F:\tmp\hive
2.
SparkSession.builder() .appName(APPname) .config("spark.sql.crossJoin.enabled","true") .master("local") .config("hive.metastore.uris","thrift://171.27.37.86:9083") .enableHiveSupport() .getOrCreate(); 一定要写配置hive的那台节点的ip,我是伪分布。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0317e37a023677dbf301dde7bba22b53/" rel="bookmark">
			Spring Cloud Alibaba - 消息队列（二）（RocketMQ）（windows 下安装以及测试 （很重要））
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Cloud Alibaba - 消息队列（二）（RocketMQ）（windows 下安装以及测试 ） 回溯+诉苦回溯诉苦 安装RocketMQ 这里有坑，天坑，巨大无比的天坑！！！！！！！ 启动NameServer启动BROKER RocketMQ控制台安装测试启动消费者启动生产者 回溯+诉苦 回溯 前面一篇博文讲述了 消息队列 的概念以及 RocketMQ 的架构，这一篇主要讲解使用。
诉苦 博主本来不喜欢写博文，但是发现笔记经常丢，实习生也会经常问，所以觉得写博客记录一下比较好。从写 Spring Cloud Alibaba 以来，已经写了十九篇了，其实其中很多是拆分开的，不然大概四五篇就差不多了，不过这样一来会导致一篇博文太长，违反了单一职责，所以才拆成细粒度一点。
写啊写，写到 RocketMQ 的安装使用的时候，心态炸裂了，坑太多了，别人家的博文都不写详细，害的博主折腾了非常非常久，心态炸裂到仿佛回想起第一次弄Hadoop的时候 ╥﹏╥…
可是人家Hadoop是大项目，开始折腾就折腾了，你说你 RocketMQ 也这么折腾，哎，还是自己能力不足 (;´༎ຶД༎ຶ`)
以下的安装使用，有坑的地方博主会用红色字体标注出来。
安装RocketMQ 首先我们需要安装下载RocketMQ
点击 http://rocketmq.apache.org/ 请根据图片操作。
下载完之后解压
进入到bin目录
这时候需要配置环境变量
JAVA_HOME：这个就不进行详细赘述了，java 必备 技能之一。（待会马上讲，有坑）ROCKETMQ_HOME：变量值需要是MQ的解压路径，比如博主的是：E:\rocketmq-all-4.7.1-bin-release 这里有坑，天坑，巨大无比的天坑！！！！！！！ 这里的环境变量，需要你路径中不能有空格！！！！
ROCKETMQ_HOME 还好说，毕竟是我们自己刚刚解压的。可是！！！JAVA_HOME 就不是了，这个一般是很早以前安装的了，而且！！以前我们安装的时候都是一直点击下一步，无脑安装，这样它是会默认把java安装在
这里面，然而！！它是有空格的！！
无奈之下，博主只好在C盘下直接放一个JAVA，并且把路径指向过去
之后的坑就没那么大了…
启动NameServer 紧接着，在刚才解压下的lib中打开控制台
输入
start mqnamesrv.cmd 启动成功
ps（如果电脑配置内存不够，可以先修改内存大小再启动）
启动BROKER 继续cmd
输入
start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true 启动成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0317e37a023677dbf301dde7bba22b53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b8f133db292f833c4c8ad52a0f42c3c/" rel="bookmark">
			el-checkbox文字超长显示省略号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div class="container"&gt; &lt;h3&gt;checkbox文字超长显示省略号，鼠标移上去显示文字&lt;/h3&gt; &lt;el-checkbox v-for="item in list" :label="item.id" :title="item.id + ' ' + item.name" :key="item.name" border &gt;{{item.id + ' ' + item.name}}&lt;/el-checkbox&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { list: [ { id: 1, name: '张三1111111111111111111111111' }, { id: 2, name: '李四' }, ], } }, } &lt;/script&gt; &lt;style scoped&gt; .container &gt;&gt;&gt; .el-checkbox__label { width: 60px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } &lt;/style&gt; 效果图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c3510de0746d3dafd66d8cbf6837f71/" rel="bookmark">
			签名证书无效”-在vCenter Server Appliance 6.5 / 6.7上使用Shell脚本重新生成和替换已过期的STS证书（76719）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“签名证书无效”-在vCenter Server Appliance 6.5 / 6.7上使用Shell脚本重新生成和替换已过期的STS证书（76719） 上次更新时间：2020/7/8分类：故障排除 24语言： 日本英语 订阅 病征 由于证书过期并显示以下错误，因此vCenter / PSC服务无法启动： 路径：/var/log/vmware/vpxd-svcs/vpxd-svcs.log 错误com.vmware.vim.sso.client.impl.SecurityTokenServiceImpl $ RequestResponseProcessor opId =]服务器拒绝了所提供的时间范围。原因：ns0：InvalidTimeRange：令牌颁发机构拒绝了TimePeriod的发布请求[startTime = Thu Jan 02 09:22:13 EST 2020，endTime = Fri Jan 03 09:22:13 EST 2020] ::签名证书在2020年EST 1月2日星期四09:22:13，证书有效期：TimePeriod [
登录到Web客户端时，观察到以下错误： HTTP状态400 –错误的请求消息BadRequest，签名证书无效 如果由于证书过期而导致vmware-vpxd服务未运行，则访问WebClient或UI Client将显示以下错误消息 503服务不可用 如果可访问WebClient，则可能会抛出错误消息“ 无法替换PSC或VC上的任何证书，因为它无法在注册服务上重新注册服务无法使用lstool从查找服务中手动添加/修改/删除注册无法部署新的PSC并进行跨域重定向无法将新的PSC部署为现有SSO域上的复制伙伴 目的 重新生成和替换STS证书。 原因 当STS（安全令牌服务）证书过期时，会发生这些问题。内部服务和解决方案用户无法获取有效令牌，并且它们无法按预期工作。
当STS证书过期时，它不会发出警告。在某些系统上，此期限可能会在首次部署后的两年内立即发生。
注意事项： 在以下情况下，STS签名证书的使用寿命预计为2年左右。并非所有6.5 U2或更高版本，但仅在6.5版本中仅6.5 U2或更高版本。从U2或更高版本（仅6.5行）开始全新安装PSC / vCenter Server 6.5。新安装的PSC / vCenter Server 6.5 U2或任何更高版本的6.5，并已升级到更高版本，包括6.7和7.0。在PSC或vCenter Server安装后，使用certool替换了STS签名证书。STS签名证书已替换为自定义证书（内部/外部CA签名）。 影响/风险 警告：此脚本将与VMDIR的数据库进行交互。
在运行脚本之前，请同时为SSO域中的所有vCenter Server和Platform Service Controller制作脱机快照。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c3510de0746d3dafd66d8cbf6837f71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43a7331517ef36c8eca8a973da0b8a87/" rel="bookmark">
			games101作业1：旋转与投影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		games101作业01：旋转与投影 内容 本次作业的任务是填写一个旋转矩阵和一个透视投影矩阵。给定三维下三个点 v0(2.0, 0.0, 2.0), v1(0.0, 2.0, 2.0), v2( 2.0, 0.0, 2.0), 你需要将这三个点的坐标变换为屏幕坐标并在屏幕上绘制出对应的线框三角形。通过进行模型、视图、投影、视口等变换来将三角形显示在屏幕上。在提供的代码框架中，我们留下了模型变换和投影变换的部分给你去完成。
get_model_matrix(float rotation_angle):
逐个元素地构建模型变换矩阵并返回该矩阵。在此函数中，你只需要实现三维中绕 z 轴旋转的变换矩阵，而不用处理平移与缩放
get_projection_matrix(float eye_fov, float aspect_ratio, floatzNear, float zFar):
使用给定的参数逐个元素地构建透视投影矩阵并返回该矩阵。
基础知识 视图变换 模型变换（modeling tranformation）：将一个物体自身进行变换（缩放、旋转、位移）视角变换（view tranformation）：根据眼睛来判断物体的相对位置投影变换（projection tranformation）：将三维空间内的物体投影至标准二维平面([-1,1]^2)之上视口变换（viewport transformation）：将处于标准平面映射到屏幕分辨率范围之内，即[-1,1]^2→\rightarrow→[0,width]*[0,height], 其中width和height指屏幕分辨率大小 如下图所示：
模型变换（modeling tranformation） 缩放与位移变换：
旋转变换：
欧拉角：
视角变换（view tranformation） 想要知道眼睛与物体的相对位置，已知眼睛的位置与物体的位置，将眼睛移动到原坐标系的原点，那么此时物体的坐标自然便是相对坐标了！
我们先定义3个东西：眼睛的位置e，观察方向g，视点正上方向t
其中u，v，w分别对应标准坐标系下的x，y，z，示意图如下：
(tips:这里为什么不直接拿 t 当做基底向量是因为摄像机的头可能是歪着看的，就像图中一样 )
接下来将其移动到原世界坐标系
将相机移动到原点通过旋转矩阵将二者坐标系重合
（本文中所有矩阵都是左乘），最右边的矩阵代表第一步操作移至原点，旁边那个矩阵则代表第二步操作将坐标系重合。 投影变换（projection tranformation) 正交投影变换(Orthographic Projection Transformation) 正交投影是相对简单的一种，坐标的相对位置不变，相当于平行映射，我们只需要物体（可视部分，即上图的那个长方体）全部转换到一个[−1,1] ^3的空间之中即可（其中x，y坐标便是投影结果，保留z是为了之后的遮挡检测）
透视投影变换(Perspective Projection Transformation) 透视投影就是好比人眼看东西，遵循近大远小的规则。如下图，左图为透视，右图为正交。
投影过程如下：(x,y,z)-&gt;(x’,y’,z’)
设投影矩阵为M，即：
（如果形象化的描述一下的话，就是利用这个变换矩阵将整个空间压缩了一下，使其对应了真正透视投影的坐标，最后不要忘了要利用正交转换到[−1,1]3[-1,1]^3[−1,1]
3
的空间之内）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43a7331517ef36c8eca8a973da0b8a87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba4e2d43d4970e4f536c2d387224ac85/" rel="bookmark">
			Yarn的架构组件、运行原理和应用提交过程详解（ResourceManager、NodeManager、ApplicationMaster、Container、JobHistoryServer等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述：
Apache Hadoop YARN(Yet Another Resource Negotiator)是Hadoop的子项目，为分离Hadoop2.0资源管理和计算组件而引入，是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台，而Mapreduce等运算程序则相当于运行于操作系统之上的应用程序。
关于Yarn，有几点需要明白的是：
1）实际上，Yarn并不清楚用户所提交程序的运行机制是什么；2）Yarn只负责提供运算资源的调度（用户程序向Yarn申请资源，Yarn就负责分配资源）；3）Yarn中的主管角色是ResourceManager，而具体提供运算资源的角色是NodeManager；4）Yarn框架与运行的用户程序完全解耦，这就意味着在Yarn上面可以运行各种类型的分布式运算程序（Mapreduce只是其中的一种），比如mapreduce、storm程序，spark程序……；5）Spark、Storm等运算框架都可以整合在Yarn上运行，只要他们各自的框架中有符合Yarn规范的资源请求机制即可；6）Yarn就是一个通用的资源调度平台，企业中以前存在的各种运算集群都可以整合在一个物理集群上，提高资源利用率，方便数据共享。 二、架构组件
类似HDFS，YARN也是经典的主从（master/slave）架构
YARN主要由ResourceManager、NodeManager、ApplicationMaster和Container等组件构成，各组件的作用如下图所示：
1、ResourceManager
ResourceManager是YARN中主的角色
RM是一个全局的资源管理器，集群只有一个active的对外提供服务
负责整个系统的资源管理和分配包括处理客户端请求启动/监控 ApplicationMaster监控 NodeManager、资源的分配与调度
它主要由两个组件构成：调度器（Scheduler）应用程序管理器（Applications Manager，ASM） 调度器Scheduler：
调度器根据队列、容量等限制条件（如每个队列分配一定的资源，最多执行一定数量的作业等），将系统中的资源分配给各个正在运行的应用程序。需要注意的是，该调度器是一个“纯调度器” 它不从事任何与具体应用程序相关的工作，比如不负责监控或者跟踪应用的执行状态等，也不负责重新启动因应用执行失败或者硬件故障而产生的失败任务，这些均交由应用程序相关的ApplicationMaster完成。调度器仅根据各个应用程序的资源需求进行资源分配，而资源分配单位用一个抽象概念“资源容器”（Resource Container，简称Container）表示，Container是一个动态资源分配单位，它将内存、CPU、磁盘、网络等资源封装在一起，从而限定每个任务使用的资源量。 应用程序管理器Applications Manager，ASM：
应用程序管理器主要负责管理整个系统中所有应用程序接收job的提交请求为应用分配第一个 Container 来运行 ApplicationMaster 包括应用程序提交与调度器scheduler协商资源以启动 ApplicationMaster监控 ApplicationMaster 运行状态并在失败时重新启动它等 2、NodeManager
NodeManager 是YARN中的 slave角色
NodeManager ：
当一个节点启动时，它会向 ResourceManager 进行注册并告知 ResourceManager 自己有多少资源可用。每个计算节点，运行一个NodeManager进程，通过心跳（每秒 yarn.resourcemanager.nodemanagers.heartbeat-interval-ms ）上报节点的资源状态(磁盘，内存，cpu等使用信息)
功能：接收及处理来自 ResourceManager 的命令请求，分配 Container 给应用的某个任务；NodeManager 监控本节点上的资源使用情况和各个 Container 的运行状态（cpu和内存等资源）负责监控并报告 Container 使用信息给 ResourceManager。定时地向RM汇报以确保整个集群平稳运行，RM 通过收集每个 NodeManager 的报告信息来追踪整个集群健康状态的，而 NodeManager 负责监控自身的健康状态；处理来自 ApplicationMaster 的请求；管理着所在节点每个 Container 的生命周期；
管理每个节点上的日志；在运行期，通过 NodeManager 和 ResourceManager 协同工作，这些信息会不断被更新并保障整个集群发挥出最佳状态。NodeManager 只负责管理自身的 Container，它并不知道运行在它上面应用的信息。负责管理应用信息的组件是 ApplicationMaster 3、Container
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba4e2d43d4970e4f536c2d387224ac85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b928d3cb4e9a2ed151f3f767ffb3c12/" rel="bookmark">
			DVD-R、DVD&#43;R以及DVD-RW和DVD&#43;RW的功能区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.DVD ±R 和DVD ±RW的功能区别 1.有人认为RW就是可擦洗多次使用的，R就是一次性的，其实只是对一部分。
2. 这个还是介绍比较到位的，R的话就是不能擦除的盘；RW是可重复使用的盘。
那么R是不是就是一次性的刻录盘呢？答案是看下面内容。
2. DVD+R 和DVD-R的区别 DVD-R可以认为就是一次性的刻录盘，也就是说无论刻录1M还是刻满，都是只能刻录一次； 而DVD+R虽然是不可擦除的，但是他是可以多次刻录的，直到将盘刻满为止。所以不是通俗意义的一次性盘，而是可以断续多次刻录，当刻满的时候就只能读取了。
3. DVD±RW可以循环使用多少次 我没有亲测过，不过根据网上资料，大概50尺以内的循环使用。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/424/">«</a>
	<span class="pagination__item pagination__item--current">425/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/426/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>