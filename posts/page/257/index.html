<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c11008a42645e89b71c5f0a501e508c/" rel="bookmark">
			（萌新向很详细！）在Anaconda下安装Pytorch环境流程及问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（萌新向很详细！）Anaconda下安装Pytorch环境流程及问题总结
目录
前言
一、Anaconda是什么？Pytorch是什么？
Anaconda是什么？
Pytorch是什么？
二、安装步骤及遇见的问题与解决
1.Anaconda的安装
官网下载
清华源下载
2.Pytorch的配置
打开Anaconda
配置虚拟环境
在Anaconda Navigator中配置
在Anaconda Prompt中配置
在虚拟环境中配置Pytorch
三、检验安装是否成功
检验Anaconda是否安装成功
检验虚拟环境是否配置成功
检验Pytorch是否配置成功
总结
前言 最近导师带着在做一个基于深度学习的项目，让笔者先回去搭建一个基于python3.6的环境，虽然刚开始一头雾水，好在不停地查资料摸索中算是搭建好了虚拟环境，也替身边的一些有困惑的同学解决了问题。趁热打铁，在此记录一下在Anaconda下安装Pytorch环境走的流程以及在每一步中自己以及同学遇见的问题，希望对大家有帮助。
一、Anaconda是什么？Pytorch是什么？ Anaconda是什么？ Anaconda是一个安装、管理python相关包的软件,还自带python、Jupyter Notebook、Spyder,有管理包的conda工具。Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。
总的来说，笔者认为可以将Anaconda看作一个菜市场，我们可以在Anaconda中进行各种数据处理、数据管理、环境搭建、环境管理等。笔者也是选择在Anaconda中搭建虚拟环境。
Pytorch是什么？ Pytorch是torch库的python版本，是由Facebook开源的神经网络框架，与Tensorflow的静态计算图不同，pytorch的计算图是动态的，可以根据计算需要实时改变计算图。我们需要下载在Python环境中下载Pytorch库这样就在环境中建立了Pytorch的神经网络框架。
二、安装步骤及遇见的问题与解决 1.Anaconda的安装 Anaconda的小白级保姆级安装教程网上已经比比皆是了。在此不作详述，只作简单梳理。
官网下载 去Anaconda官网https://www.anaconda.com/distribution/下载exe文件双击exe文件安装(注意事项：1、自定义安装路径，尽量不要选C盘。2、一定要记住步骤1里面的路径，省的以后找不到。3、要勾选“Add anaconda to PATH”添加到环境变量，避免麻烦。) 清华源下载 根据个人情况，官网下载太慢的话推荐清华源下载链接： ​​​
注意事项：注意看Anaconda的版本！！！一个是前面的Anaconda2/3，另一个是后面的版本号。不同的版本号基于的Python环境是不一样的，后期降级很麻烦，所以建议不要下载太新的版本，根据Python的需要下载安装。笔者下载的是5.3.0版本，对应的是Python 3.7。
2.Pytorch的配置 打开Anaconda 这里面经常会出现如下典型问题：
1、找不到Anaconda在哪。安装完Anaconda不会创建桌面快捷方式，所以有些小伙伴就找不到Anaconda在哪。快速的打开方式就是电脑左下角的“开始”然后找到Anaconda栏即可。
2、安装完之后打开卡在loading applications界面，单击后立刻消失并且不再显示。在网上也搜了很多办法，断网是能打开的但是没什么意义，无法根本解决问题。经实测如下方法可以有效解决问题：
在Anaconda文件夹（这就体现了步骤一中记文件夹的重要性）根据如下路径查找到py文件：Lib\site-packages\anaconda_navigator\api\conda_api.py，修改1358行（或者附近，仔细看看）data = yaml.load(f) 改为 data = yaml.safeload(f)
附上附近代码以便查找
​
配置虚拟环境 成功打开Anaconda后我们所在的就是base环境（顾名思义根环境）了，为了安全考虑强烈建议搭建一个虚拟环境后再进行深度学习的进行。配置虚拟环境有如下两种方法：
在Anaconda Navigator中配置 1.成功打开Anaconda Navigator后首先在Channels栏把defaults删除（源的问题防止配置失败）
2.点击右下角的Create创建虚拟环境。可以选择python的版本（笔者下载的是5.3.0版本的Anaconda，最高支持python 3.7），支持低级版本。
注意事项：Name栏中起的是虚拟环境的名字，不要和虚拟环境的功能混淆！！！比如笔者搭建了名为pytorch的环境，只是环境名字叫pytorch，实际与pytorch目前没有任何关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c11008a42645e89b71c5f0a501e508c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff1c32e65544cf5a28d269b656142266/" rel="bookmark">
			手把手实战PyTorch手写数据集MNIST识别项目全流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要
一、认识MNIST手写数据集
二、实战流程
1、加载必要的库
2、定义超参数
3、构建transform，对图像做处理
4、下载、处理、加载数据集
下载、处理数据集
加载数据集
5、构建网络模型
6、定义优化器
7、定义训练方法
8、定义测试方法
9、调用方法7和8
10、运行
三、完整代码
摘要 MNIST手写数据集是跑深度学习模型中很基础的、几乎所有初学者都会用到的数据集，认真领悟手写数据集的识别过程对于深度学习框架有着弥足重要的意义。然而目前各类文章中关于项目完全实战的记录较少，无法满足广大初学者的要求，故本文受B站Tommy启发来手把手从引入库开始进行对整个手写数据集识别的流程，这对于笔者以后的深度学习有着很大的必要性。
一、认识MNIST手写数据集 MNIST 数据集是由 0〜9 手写数字图片和数字标签所组成的，由 60000 个训练样本和 10000 个测试样本组成，每个样本都是一张 28*28 像素的灰度手写数字图片。如下图所示。 可以看到，每个阿拉伯数字都形态各异，而本文的任务就是把它们识别出来。
二、实战流程 1、加载必要的库 MNIST手写识别需要的库有基本库torch、包含了构筑神经网络结构基本元素的包torch.nn、torch.nn.functional、优化器optim、对数据库进行操作的torchvision。
import torch import torch.nn as nn import torch.nn.functional as F import torch.optim as optim from torchvision import datasets, transforms 2、定义超参数 超参数：在机器学习中，超参数是在开始学习过程之前设置值的参数，而不是通过训练得到的参数数据。通常情况下，需要对超参数进行优化，给学习机选择一组最优超参数，以提高学习的性能和效果。
由于实操中数据往往会过多，一次加载不完，内存不够，所以我们将数据切割，选择超参数batch_size（每批处理的数据）为128（根据性能）。
第二个超参数定义一个DEVICE来判断用CPU还是GPU训练。
第三个超参数决定进行几轮训练，本文选择100轮训练.
BATCH_SIZE = 128 DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu") EPOCHS = 20 3、构建transform，对图像做处理 PyTorch内置很多库，直接调用方法transforms即可：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff1c32e65544cf5a28d269b656142266/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/005b065acff9fccfd81077a899024ab0/" rel="bookmark">
			vs中预处理的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中接触到预处理宏定义：
情景一：
#ifdef scheduling_GOAL_OFFSET double goal_offset_x; double goal_offset_y; double goal_offset_theta; #endif 在接口层定义的变量如果想放开使用对应的操作如下：
在属性-预处理器中加上，此时会发现对应的代码变亮
如果是ifndef,要想放开就是在属性-预处理器中删除对应的宏scheduling_GOAL_OFFSET
#ifndef scheduling_GOAL_OFFSET double goal_offset_x; double goal_offset_y; double goal_offset_theta; #endif 总结：就是想打开的时候，无论在预处理器中添加还是删除宏定义，想要的结果就是此操作后代码变亮，被放开。想关闭的时候代码变灰。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aed049afb24c48515e1fa7dccdbaaa0/" rel="bookmark">
			git如何生成ssh密钥 git生成配置ssh密钥key详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git如何生成ssh密钥 ?有不少朋友们在下载git以后，不知道如何使用git软件生成配置密钥key。今天小编就来给大家说明一下git生成配置ssh密钥key详细步骤。
具体步骤如下： 1、在电脑桌面，鼠标右键，选择"Git Bash Here"，打开Git命令窗口；
2、在Git命令窗口中配置用户，输入如下命令：
git config --global user.name "blkj"
其中："blkj"是你自己要填写的用户名
3、继续在Git窗口中配置邮箱，输入如下命令：
git config --global user.email "blkj@boranet.com.cn"
其中："blkj@boranet.com.cn"是用户自己的邮箱地址
4、此时会在C:\Users\Administrator目录下生成.gitconfig配置文件(此文件不能删除)；
5、查看.gitconfig配置文件里的内容；
6、继续在Git命令窗口中输入如下命令，即可生成SSH公钥和私钥
ssh-keygen -t rsa -C "blkj@boranet.com.cn"
7、进入C:\Users\Administrator\.ssh目录下，查看生成的SSH密钥；
8、在Git窗口中输入如下命令，可以查看公钥和私钥
cat ~/.ssh/id_rsa.pub
以上就是git如何生成ssh密钥的方法介绍了，希望对各位朋友们有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45506ce4667e381fdb35eaa159c61539/" rel="bookmark">
			Git生成SSH key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows：
1.创建SSH Key。在windows下查看[c盘-&gt;用户-&gt;用户名-&gt;.ssh]（也有可能是其他盘）下是否有id_rsa、id_rsa.pub文件，如果没有需要手动生成。
打开git bash，在控制台中输入以下命令： $ ssh-keygen -t rsa -C "victordu6694@gmail.com"。
-t 指定密钥类型，默认是 rsa ，可以省略。
-C 设置注释文字，比如邮箱。
-f 指定密钥文件存储文件名。
输入完毕后程序同时要求输入一个密语字符串(passphrase)，空表示没有密语。接着会让输入2次口令(password)，空表示没有口令。3次回车即可完成当前步骤，此时[c盘&gt;用户&gt;自己的用户名&gt;.ssh]目录下已经生成好了。
2.登录github。打开setting-&gt;SSH keys，点击右上角 New SSH key，把生成好的公钥id_rsa.pub放进key输入框中，再为当前的key起一个title来区分每个key。如果已有SSH Key，将已有的id_rsa.pub放入key输入框。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/492b15895e658ef6e27f121c7372b80d/" rel="bookmark">
			cv2.VideoCapture读取视频或摄像头，并进行保存帧图像或视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、语法：cap = cv2.VideoCapture(0) 说明：参数0表示默认为笔记本的内置第一个摄像头，如果需要读取已有的视频则参数改为视频所在路径路径，例如：cap=cv2.VideoCapture('video.mp4')
二、语法：cap.isOpened() 说明：判断视频对象是否成功读取，成功读取视频对象返回True。
三、语法：ret,frame = cap.read() 说明：按帧读取视频，返回值ret是布尔型，正确读取则返回True，读取失败或读取视频结尾则会返回False。frame为每一帧的图像，这里图像是三维矩阵，即frame.shape = (640,480,3)，读取的图像为BGR格式。
四、语法：key = cv2.waitKey(1) 说明：等待键盘输入，参数1表示延时1ms切换到下一帧，参数为0表示显示当前帧，相当于暂停。
五、读取摄像头并保存为视频代码演示： import cv2 def videocapture(): cap=cv2.VideoCapture(0) #生成读取摄像头对象 width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)) #获取视频的宽度 height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)) #获取视频的高度 fps = cap.get(cv2.CAP_PROP_FPS) #获取视频的帧率 fourcc = int(cap.get(cv2.CAP_PROP_FOURCC)) #视频的编码 #定义视频对象输出 writer = cv2.VideoWriter("video_result.mp4", fourcc, fps, (width, height)) while cap.isOpened(): ret, frame = cap.read() #读取摄像头画面 cv2.imshow('video', frame) #显示画面 key = cv2.waitKey(24) writer.write(frame) #视频保存 # 按Q退出 if key == ord('q'): break cap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/492b15895e658ef6e27f121c7372b80d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e9b7b1a0a11b6be32e1b3f3bd3c58ea/" rel="bookmark">
			【LaTeX】IEEE模板中定理、公理和证明语句的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、前言二、原文三、如何使用1. 定理 theorem2. axioms和其他结构3. 证明 proof 四、总结五、参考 一、前言 正如题目所言，笔者第一次使用IEEE的会议LaTex模板，涉及到定理和证明语句时之前的写法不可行，于是笔者研究了模板中自带的文件《How to Use the IEEEtran LATEX Class》文件中XII. THEOREMS AND PROOFS一节，将学习成果记录如下。
二、原文 三、如何使用 用户必须首先通过以下命令声明结构名
\newtheorem{struct_type}{struct_title}[in_counter] 其中，struct_type是用户为结构选择的标识符，struct_title是指结构的标题，in_counter是计数器的可选名称，其编号将与结构编号一起显示，其更新将重置结构计数器。
大多数IEEE论文在整个工作中都使用序列化定理编号，因此通常不指定in_count。
在定义该结构之后，可以通过以下语句使用该结构
\begin{struct_type}[extra_title] . . \end{struct_type} 其中，extra_title是随结构一起显示的可选名称。
1. 定理 theorem \newtheorem{theorem}{\bf Theorem} \begin{theorem}\label{thm1} here is a theorem. \end{theorem} \begin{theorem}[Einstein-Podolsky-Rosenberg]\label{thm2} here is another theorem. \end{theorem} 解释：使用\newtheorem{theorem}{\bf Theorem}定义了定理结构，其中theorem为\begin和\end中填写的标识符。\bf Theorem是结构的标题，比如上述代码就表示我想用加粗的Theorem作为我的标题，你也可以添加其他的格式规范，比如斜体。[Einstein-Podolsky-Rosenberg]可加可不加，给定理起个名字。
PS：如果想要在定理的序列号编号前添加章节编号，请使用如下语句。
PS：如果有一个结构与另一个结构共享其计数器的需求，可自行研究原文。
2. axioms和其他结构 \newtheorem{axioms}{\bf Axioms} \begin{axioms}\label{a1} here is an axioms. \end{axioms} \begin{axioms}\label{a2} here is another axioms. \end{axioms} 同理，只需要修改axioms、Axioms和\begin{axioms}为对应的名称就行了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e9b7b1a0a11b6be32e1b3f3bd3c58ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec42ee78f00b4f40420df8a0bfc0f57/" rel="bookmark">
			remote: HTTP Basic: Access denied 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题原因 Git账号密码有更新时，在终端pull代码提示
remote: HTTP Basic: Access denied fatal: Authentication failed for 'http://git.xxxx.com/xxxxx.git/' 解决方法 一、首先，先生成一个变更后密码的SSH key
打开终端 cd ~/.ssh/ 配置全局的name和email git config --global user.name "xiaoming" 配置全局的name和email git config --global user.email "xiaomin@163.com" ssh-keygen -t rsa -C “你的公司或个人邮箱” ssh-keygen -t rsa -C "xiaomin@163.com" 连续按3下回车键，会提示key的地址查看地址下的文件并复制key的内容 vi 文件地址路径 或 cat 文件地址路径 在Git下找到SSH Keys添加key
以上步骤添加完成后，回到终端git pull 代码时，重新输入用户名和密码就能成功pull了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b74fb7e9dcde02bb5b6fc99f192fc7bd/" rel="bookmark">
			原型链总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结 js中每个实例对象都有一个原型对象，当实例对象本身没有所需要的属性、方法，会从实例对象的原型上寻找，原型对象上没有找到，则会一层一层通过原型链向上查找，直到找到，或者找到原型链的顶层：null
实例对象的__proto__指向原型对象，原型对象的constructor指向实例对象的构造函数，实例对象的构造函数通过prototype指向原型对象，实例对象又是通过构造函数new出来的，所以有这么个三角关系
原型对象的__proto__指向Object.prototype,
Object.prototype的constructor指向Object构造函数,
Object构造函数的__proto__指向构造函数原型，
即指向实例对象的构造函数原型，
构造函数的原型可以通过constructor指向function，
function的__proto__、prototype指向构造函数原型，
function通过new 可以创造Object构造函数，
构造函数原型的__proto__指向Object.prototype,
Object.prototype的原型对象是null
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04e276f72416ccf999a70130c7a25a5a/" rel="bookmark">
			python导入excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言导入单张表格 一、使用步骤1.具体代码2.具体图形展示 总结 前言 导入单张表格 一、使用步骤 1.具体代码 # 1.导入库 import xlwt # 2.创建excel表格类型文件 #用Workbook方法来创建一个excel表格类型文件 # 其中的第一个参数是设置数据的编码格式，这里是’utf-8’的形式， # style_compression设置是否压缩，不是很常用，赋值为0表示不压缩 book = xlwt.Workbook(encoding='utf-8',style_compression=0) # 3.在excel表格类型文件中建立一张sheet表单 # cell_overwrite_ok用于确认同一个cell单元是否可以重设值，这里赋值为True就表示可重设值。 sheet = book.add_sheet('2022年看的电影',cell_overwrite_ok=True) # 4.自定义列名 # 用一个元组col自定义列的数量以及各列的属性名 col = ('电影名称','类型','评分') #5.将列属性元组col写进sheet表单中，三列 for i in range(0,3): sheet.write(0,i,col[i]) #6.数据写入表单 datalist = [['名侦探柯南-绯红色不在场证明', '动漫', '5'], ['电锯惊魂2', '恐怖', '7'], ['电锯惊魂3','恐怖','6'], ['肖生克的救赎','纪录','9']] for i in range(0, 4): data = datalist[i] for j in range(0, 3): sheet.write(i + 1, j, data[j]) #7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04e276f72416ccf999a70130c7a25a5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c565bfeb66825447ca8a7d029cdebfee/" rel="bookmark">
			vue中小数相加精度缺失问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		methods: {
// 小数精度
add(args) {
var lens = args.length;
var d = 0;
var sum = 0;
for (var key in args) {
var str = “” + args[key];
if (str.indexOf(“.”) != -1) {
var temp = str.split(“.”)[1].length;
d = d &lt; temp ? temp : d;
}
}
var m = Math.pow(10, d);
for (var key in args) {
sum += args[key] * m;
}
return sum / m;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c565bfeb66825447ca8a7d029cdebfee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5bb43869c94defe67a474acb761b7d4/" rel="bookmark">
			水仙花数的两种解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题目呈现】
输出1100-999所有的“水仙花数”，所谓的“水仙花数”是指一个三位数其各位数字的立方和等于该数本身，例如153是“水仙花数”，因为：153 = 13 + 53 + 33。
【解法】
【解法一】
在已知范围内（100-999），我们可以通过遍历所有数字，并进行验证。
#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main(void) { for(int i = 100;i&lt;1000;i++) { int hundreds = i/100; int tens = (i%100)/10; int unit = i%10; if(pow(hundreds,3)+pow(tens,3)+pow(unit,3)==i) printf("%d\n",i); } } 【解法二】
先通过三层嵌套循环找到水仙花数，再输出100-999之间的部分。
#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main(void) { for (int i=1;i&lt;10;i++) { for (int j=0;j&lt;10;j++) { for (int k=0;k&lt;10;k++) { int num = pow(i,3)+pow(j,3)+pow(k,3); if (num&lt;100) continue; else if(num&gt;999) break; else if(num ==100*i+10*j+k) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5bb43869c94defe67a474acb761b7d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89de8683e1ab794ebc8866b7f09d620a/" rel="bookmark">
			var、let、const特点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 var、let、const特点总结 var 关键字 有变量提升，有全局作用域、函数作用域的概念没有块级作用域的概念同一作用域可以重复声明全局作用域下var声明的变量会挂载到window对象上 let 关键字 有块级作用域的概念存在暂存性死区不存在变量提升同一作用域中不能重复声明 const 关键字 与 let 特性一致，有两点不同：声明时必须初始化常量的值不能改变 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee4aed7f479a99f66dc10926e8f7587a/" rel="bookmark">
			枚举与#define 宏的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		枚举与#define 宏的区别 枚举类型的使用方法枚举与#define 宏的区别 枚举类型的使用方法 一般的定义方式如下：
enum enum_type_name { ENUM_CONST_1, ENUM_CONST_2, ... ENUM_CONST_n } enum_variable_name; enum_type_name 是自定义的一种数据数据类型名，而 enum_variable_name 为enum_type_name 类型的一个变量，也就是我们平时常说的枚举变量。实际上 enum_type_name类型是对一个变量取值范围的限定，而花括号内是它的取值范围，即 enum_type_name 类型的变量 enum_variable_name 只能取值为花括号内的任何一个值，如果赋给该类型变量的值不在列表中，则会报错或者警告。ENUM_CONST_1、ENUM_CONST_2、… 、ENUM_CONST_n，这些成员都是常量，也就是我们平时所说的枚举常量（常量一般用大写）。
enum 变量类型还可以给其中的常量符号赋值，如果不赋值则会从被赋初值的那个常量开始依次加 1，如果都没有赋值，它们的值从 0 开始依次递增 1。如分别用一个常数表示不同颜色：
enum Color { GREEN = 1, RED, BLUE, GREEN_RED = 10, GREEN_BLUE }ColorVal； 其中各常量名代表的数值分别为：
GREEN = 1 RED = 2 BLUE = 3 GREEN_RED = 10 GREEN_BLUE = 11 枚举与#define 宏的区别 1.#define 宏常量是在预编译阶段进行简单替换。枚举常量则是在编译的时候确定其值。
2.一般在编译器里，可以调试枚举常量，但是不能调试宏常量。
3.枚举可以一次定义大量相关的常量，而#define 宏一次只能定义一个。
1.枚举能做到事，#define 宏能不能都做到？如果能，那为什么还需要枚举？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee4aed7f479a99f66dc10926e8f7587a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a358c4d2c9107c5f9b5f9b4036de370f/" rel="bookmark">
			如何用程序确认当前系统的存储模式？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		union 关键字 union 关键字的用法与 struct 的用法非常类似。
union 维护足够的空间来置放多个数据成员中的“一种”，而不是为每一个数据成员配置空间，在 union 中所有的数据成员共用一个空间，同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址。
union StateMachine { char character; int number; char *str; double exp; }; 一个 union 只配置一个足够大的空间以来容纳最大长度的数据成员，以上例而言，最大长度是 double 型态，所以 StateMachine 的空间大小就是 double 数据类型的大小。
大小端模式对 union 类型数据的影响 union { int i; char a[2]; }*p, u; p = &amp;u; p-&gt;a[0] = 0x39; p-&gt;a[1] = 0x38; p.i 的值应该为多少呢？
其值由系统所采用的 存储模式 和 int 类型 所占存储空间的字节数决定
当int为4字节时
答：当为大端模式时0x39380000
答：当为小端模式时0x00003839
这里需要考虑存储模式：大端模式和小端模式。
大端模式（Big_endian）：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。
小端模式（Little_endian）：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。
union 型数据所占的空间等于其最大的成员所占的空间。对 union 型的成员的存取都是相对于该联合体基地址的偏移量为 0 处开始，也就是联合体的访问不论对哪个变量的存取都是从 union 的首地址位置开始。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a358c4d2c9107c5f9b5f9b4036de370f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4b090b6e8b3fb6b9d855362d193119e/" rel="bookmark">
			[C语言]指针和数组（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、指针数组和数组指针
二、多维数组和多维指针
三、函数与指针
一、指针数组和数组指针
饭前思考
我们先来看一段代码： #include &lt;stdio.h&gt; void test_pointer1() { int array[5]; int matrix[5][5]; int* pa = array; int* pm = matrix; } int main() { test_pointer1(); return 0; } 这里用两个int类型的指针指向两个数组，一个是一维的，一个是二维的，这里编译器没有报错，但是我们想这样是否存在问题？我们已经知道array代表首元素地址，那么matrix又代表什么呢？
数组类型定义
数组类型该如何定义呢？int类型数组是int类型吗？C语言中的数组有自己特定的类型：
（1）数组的类型由元素类型和数组大小共同决定
例：int array[5]的类型为int[5]
（2）C语言用typedef重定义数组类型：
typedef type(name)[size];
例如：
typedef int(AINT5)[5];
typedef float(AFLOAT10)[10];
有了重定义，那么我们可以这样来定义数组了：
AINT5 array_int_5;
AFLOAT10 array_float_10; void test_pointer2() { int int_array[5]; AINT5* p_int_5 = &amp;int_array; int(*p_int_5_2)[5] = &amp;int_array; } 数组指针
（1）数组指针用于指向一个数组
（2） 数组名是数组首元素的起始地址，但并不是数组的起始地址 但并不是数组的起始地址
（3） 通过将取地址符&amp;作用于数组名可以得到数组的起始地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4b090b6e8b3fb6b9d855362d193119e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75e1294c647d6c277af70f278dfbce3c/" rel="bookmark">
			Docker私有仓库增加用户与密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装httpd-tools yum install httpd-tools -y 2、创建用户密码文件 mkdir -p /home/registry/auth htpasswd -Bbn test 123456 &gt; /home/registry/auth/htpasswd 注意：网上有很多是这种方式： docker run --entrypoint htpasswd registry -Bbn username password auth/htpasswd 这个命令指运行docker窗口里的htpasswd命令。
但是现在使用这个命令一直报错：docker: Error response from daemon: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: “htpasswd”: executable file not found in $PATH: unknown.
因此使用httpd-tools来创建用户密码文件
3、创建带用户验证的仓库 docker run -d -p 5000:5000 --restart=always --name registry1 \ -v /home/registry/data:/var/lib/registry \ -v /home/registry/auth:/auth \ -e "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75e1294c647d6c277af70f278dfbce3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8adbf20dc85ce7aeb99c920b21d61347/" rel="bookmark">
			Nuscenes 完整版数据集批量下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nuscenes 完整版数据集批量下载 需求： 高速下载Nuscenes完整版数据集。之前mini版本尝鲜版，采用google浏览器自带工具下载，速度慢，且容易断。
1. 数据地址 官方地址：https://www.nuscenes.org/nuscenes
2. 获取下载链接 参考：如何得到需要下载文件的链接（路径）
具体步骤：
1）点击Asia，然后取消下载。
2）浏览器点击右上角三个点控制按钮，然后点击Downloads。
3）在弹出的Downloads页面，按F12，打开浏览器控制台。
4）点击控制台左上角 方格箭头按钮，然后移动鼠标到左侧的地址上，右侧会出现链接地址。
5）右击链接，选择复制链接地址。
3. 制作下载脚本 参考：
1.ubuntu20.04 批量下载 NuScenes V1.0 full 数据集
2.linux系统下nuScenes数据集快速下载方法
选择要下载的文件夹，新建脚本dataset.sh，内容如下，主要格式为：wget -c -O [数据集名字] [网页下载链接]。
这里下载了完整的训练数据集中的lidar模态部分。
wget -c -O v1.0-trainval01_blobs_lidar.tgz "https://s3.ap-southeast-1.amazonaws.com/asia.data.nuscenes.org/public/v1.0/v1.0-trainval01_blobs_lidar.tgz?AWSAccessKeyId=AKIA6RIK4RRMFUKM7AM2&amp;Signature=buHbpzZWUVrSzlvJsSXphQVZd%2B8%3D&amp;Expires=1656905855" wget -c -O v1.0-trainval02_blobs_lidar.tgz "https://s3.ap-southeast-1.amazonaws.com/asia.data.nuscenes.org/public/v1.0/v1.0-trainval02_blobs_lidar.tgz?AWSAccessKeyId=AKIA6RIK4RRMFUKM7AM2&amp;Signature=aCeQIJg4%2B6pR8G3ykqh4rpk8Hyo%3D&amp;Expires=1656906112" wget -c -O v1.0-trainval03_blobs_lidar.tgz "https://s3.ap-southeast-1.amazonaws.com/asia.data.nuscenes.org/public/v1.0/v1.0-trainval03_blobs_lidar.tgz?AWSAccessKeyId=AKIA6RIK4RRMFUKM7AM2&amp;Signature=JQCfIXeOIy3dv0s5LnNZIvRAmrA%3D&amp;Expires=1656906204" wget -c -O v1.0-trainval04_blobs_lidar.tgz "https://s3.ap-southeast-1.amazonaws.com/asia.data.nuscenes.org/public/v1.0/v1.0-trainval04_blobs_lidar.tgz?AWSAccessKeyId=AKIA6RIK4RRMFUKM7AM2&amp;Signature=SGen1IV7ZFwPz5BQ8YqkplCXvXk%3D&amp;Expires=1656906246" wget -c -O v1.0-trainval05_blobs_lidar.tgz "https://s3.ap-southeast-1.amazonaws.com/asia.data.nuscenes.org/public/v1.0/v1.0-trainval05_blobs_lidar.tgz?AWSAccessKeyId=AKIA6RIK4RRMFUKM7AM2&amp;Signature=HynZB1K4AAkMhAZ%2FOVcpDTxnEPI%3D&amp;Expires=1656906327" wget -c -O v1.0-trainval06_blobs_lidar.tgz "https://s3.ap-southeast-1.amazonaws.com/asia.data.nuscenes.org/public/v1.0/v1.0-trainval06_blobs_lidar.tgz?AWSAccessKeyId=AKIA6RIK4RRMFUKM7AM2&amp;Signature=qH52r4P4MltaDXw68HS64xrZZbg%3D&amp;Expires=1656906361" wget -c -O v1.0-trainval07_blobs_lidar.tgz "https://s3.ap-southeast-1.amazonaws.com/asia.data.nuscenes.org/public/v1.0/v1.0-trainval07_blobs_lidar.tgz?AWSAccessKeyId=AKIA6RIK4RRMFUKM7AM2&amp;Signature=rM6gmdUjwh%2BRe1kIsQ3TibIq6Js%3D&amp;Expires=1656913003" wget -c -O v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8adbf20dc85ce7aeb99c920b21d61347/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/867a7d0d40c5a63a8c16993712de169b/" rel="bookmark">
			将二进制bin文件转换为pcd文件或ply文件（matlab）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function bin2Pcd() clear; files = dir("D:\***\data_object_velodyne\training\velodyne"); % 获取当前文件夹中的所有文件 len = length(files); % 文件数量 name=[]; for ii=1:len % 依次遍历所有的bin文件，将其转换为pcd格式 if (strcmp(files(ii).name, '.') == 1) ... % 跳过.以及..文件夹 || (strcmp(files(ii).name, '..') == 1) continue; end file1D=fopen("D:\***\data_object_velodyne\training\velodyne\"+files(ii).name,"rb"); %获取当前文件 [a,count]=fread(file1D,'float32') % a 文件内容。矩阵a中存储了全部的点（481072行 * 1列。每个数据占一行，每4个数据为一组）；count 文件数量 x = a(1:4:end); %获取矩阵a中所有的x点。第1行开始，步数为4，直到最后一行 y = a(2:4:end); % 获取矩阵a中所有的y点。第2行开始，步数为4，直到最后一行 z = a(3:4:end); % 获取矩阵a中所有的z点。第3行开始，步数为4，直到最后一行 intensity= a(4:4:end); % 强度（反射值）。第4行开始，步数为4，直到最后一行 data = pointCloud([x y z],'intensity',intensity); %根据xyz坐标和强度值，转换为一个点云 pcshow(data); %显示点云 %hh = [files(ii).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/867a7d0d40c5a63a8c16993712de169b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27fa85ff0bc97e355875a11d325d9b61/" rel="bookmark">
			ffmpeg的avformat_open_input()分析过程--以mp4为例（十）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 avformat_open_input（），该函数用于打开多媒体数据并且获取一些信息，它的声明位于libavformat/avformat.h。主要工作
1）通过init_input打开流媒体数据，根据probe探测流媒体最合适的协议类型AVInputFormat，通过open2设置read/write/seek相关回调
2）read_header即根据对应的协议，读取媒体头信息并创建AVStream，并对流媒体进行解析（会对mp4文件进行解析，本文以MP4为例）
框架图 函数和文件对应关系
代码分析 avformat_open_input(http.xxx.m3u8) init_input(s, filename, &amp;tmp)) //提供的文件名信息不能探测格式 av_probe_input_format2(&amp;pd, 0, &amp;score))) io_open(s, &amp;s-&gt;pb, filename, AVIO_FLAG_READ | s-&gt;avio_flags, options)) &lt; 0) io_open_default ffio_open_whitelist ffurl_alloc //探测是HTTP协议 URLProtocol ff_http_protocol url_find_protocol(filename); ffurl_connect //发送HTTP报文头，下载http.xxx.m3u8文件 //读m3u8文件探测解复用是AVInputFormat *iformat ="hls,applehttp" *fmt = av_probe_input_buffer2(s-&gt;pb, &amp;s-&gt;iformat, filename, s, 0, s-&gt;format_probesize); s-&gt;iformat-&gt;read_header(s); //iformat iformat hls.c--&gt;hls_read_header int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options) { AVFormatContext *s = *ps; int i, ret = 0; AVDictionary *tmp = NULL; ID3v2ExtraMeta *id3v2_extra_meta = NULL; if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27fa85ff0bc97e355875a11d325d9b61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf9af7bfb4fba065f4b469dbfc6f930/" rel="bookmark">
			LiveMedia视频平台是如何实现基于网页的语音对讲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前主流的安防厂家的摄像头或者NVR都可以支持语音通道，只要配备拾音器和Mic即可实现和平台的语音交互，甚至渠道机已经内置Mic和扬声器，实现即插即用的的语音交互体验，但是目前主流的安防平台，需要安装CS客户端，或者使用厂家提供的浏览器插件来实现语音对讲，应用厂家如果想实现语音互动、大屏指挥等语音场景业务，需要切换到厂家提供的平台或者页面，无法与自己的业务平台实现完美的兼容。
LiveMedia视频中间件提供了完美的语音互动API，在自身的业务平台上全过程使用HTTP API接口通过视频中间件对前端设备进行语音交互，语音界面可由第三方应用厂家自由定制。实现拓扑如下图示：
平台对讲组实现时序图
上图中网页端中获取麦克风声音数据需要服务端开启https
getUserMedia API简介 HTML5的getUserMedia API为用户提供访问硬件设备媒体（摄像头、视频、音频、地理位置等）的接口，基于该接口，开发者可以在不依赖任何浏览器插件的条件下访问硬件媒体设备。 getUserMedia API最初是navigator.getUserMedia，目前已被最新Web标准废除，变更为navigator.mediaDevices.getUserMedia（），但浏览器支持情况不如旧版API普及。 MediaDevices.getUserMedia（）方法提示用户允许使用一个视频和/或一个音频输入设备，例如相机或屏幕共享和/或麦克风。如果用户给予许可，就返回一个Promise对象，MediaStream对象作为此Promise对象的Resolved［成功］状态的回调函数参数，相应的，如果用户拒绝了许可，或者没有媒体可用的情况下PermissionDeniedError或者NotFoundError作为此Promise的Rejected［失败］状态的回调函数参数。注意，由于用户不会被要求必须作出允许或者拒绝的选择，所以返回的Promise对象可能既不会触发resolve也不会触发 reject。
浏览器兼容性 语法 navigator.mediaDevices.getUserMedia(constraints) .then(function(mediaStream) { ... }) .catch(function(error) { ... }) 示例：HTML 5调用音频 HTML &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;button id="intercomBegin"&gt;开始对讲&lt;/button&gt; &lt;button id="intercomEnd"&gt;关闭对讲&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; javascript 开启本地音频采集、定时20毫秒通过Websocket发送音频PCM数据至LiveMedia中间件
var begin = document.getElementById('intercomBegin'); var end = document.getElementById('intercomEnd'); navigator.mediaDevices.getUserMedia = navigator.mediaDevices.getUserMedia || navigator.mediaDevices.webkitGetUserMedia; var ws = null;//实现WebSocket var record=null;//多媒体对象，用来处理音频 var timeInte = null;//定义一个定时器 begin.onclick = function() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bf9af7bfb4fba065f4b469dbfc6f930/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf4e2d296b2b3a2d8371338a6b4e185d/" rel="bookmark">
			【LaTeX】IEEE会议模板中使用BibTex插入文献（解决报错：Something‘s wrong--perhaps a missing \item. \end{thebibliography}
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、问题描述二、解决方案文件准备使用BibTex插入文献 三、引用参考 一、问题描述 使用IEEE会议论文LaTeX模板时遇到的一个错误，问题描述为：使用Texstudio编译LaTeX模板报错，报错信息提示为Something's wrong--perhaps a missing \item. \end{thebibliography}。出现的原因为IEEE会议论文模板自带的参考文献引用方式为手动插入，即不使用bib格式的参考文献，手动将参考文献调整为合适格式，然后粘贴到文本中，我准备将其换成BibTex方法引用参考文献。
二、解决方案 文件准备 首先进入IEEE的会议论文模板下载页，
下载对应的LaTeX模板和LaTeX参考文献文件。解压并放置到同一个文件夹中
打开conference_101719.tex文件，可以编译成功
5.新建一个mybibfile.bib文件里边写入一个测试文献
使用BibTex插入文献 我的替换步骤为
删除原始参考文献对应内容，即模板中的：
将以下函数添加到原始参考文献对应位置，mybibfile对应上文新建的mybibfile.bib文件。
\bibliographystyle{IEEEtran} \bibliography{IEEEabrv,mybibfile} 再次编译出现报错
Something's wrong--perhaps a missing \item. \end{thebibliography} 删除文件夹中的conference_101719.bbl文件
修改模板中的引用名称
引用方法为：\cite{[该篇文章的别名]}
将
替换为
再次编译——成功
如果本文能给你带来帮助的话，点个赞鼓励一下作者吧！
三、引用参考 [1] IEEE - Manuscript Templates for Conference Proceedings：https://www.ieee.org/conferences/publishing/templates.html
[2] 解决问题：Something’s wrong–perhaps a missing \item. \end{thebibliography}：https://blog.csdn.net/Eskiii/article/details/120832258
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1992434b7dad02d7331a4e4384285f4/" rel="bookmark">
			2021二战跨考哈工程电子信息经验贴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021二战跨考哈工程电子信息经验贴 一.自我介绍
先简单的自我介绍一下，二战跨考考生，20年学的408，21年报考哈工程电子信息，初试成绩420+，数学140+，英语80+，专业课130+。今年哈工程的复试占比变高了，复试变得更加重要（我就是加了复试成绩掉了快20名）。哈工程的复试非常公平，复试时不允许透露个人姓名和毕业学校。考研的人越来越多，生源也越来越好，捡漏也越来越难，所以希望大家一定要脚踏实地的准备，不论初试和复试都要打起十二分的精神。
二.分数线和择校问题
2021年哈工程计算机的分数线如下
可以看到电子信息的分数线相较于去年增长了一百分，总分超过400分的有60个，今年的哈工程可以说是很炸。个人觉得因为太多学校都改考408，像哈工程电子信息这样只考两门专业课的院校未来都会竞争不小。
对于择校问题，不论大家选择了哈工程或是其他高校，一定不要盲目的依据前一年的分数线，同时也要参考学校今年的热度等讯息，像今年的哈工程分数线暴涨，这都是很多因素的结果。
三.初试准备
1.数学二（140+）
推荐课程：高数：汤家凤基础+汤家凤强化+武忠祥十七堂课
线代：汤家凤/李永乐 （李永乐必听）
推荐习题集：汤家凤1800+660+330+张宇真题
2021年修改了考生大纲，但是2021数学二的难度很低，对于2022年的数学难度，我认为可以参考2018,2020的难度，绝对不会简单。对于大纲变化，选择和填空题的分值增加，所以建议660和330一定要做一遍，锻炼选择填空的计算能力，毕竟选择填空没有步骤分，错了直接就是小半道大题。
汤老师会有一点口音，但是跟下来你会发现自己的基础打得牢牢的，真的强推。听课的同时一定要做笔记，标注上自己的问题。一些不太理解的内容可以听一听其他老师的相关章节。
武忠祥十七堂课是我在冲刺阶段，做了几套真题之后发现的宝藏，建议强化做题结束之后听一遍，可以把题型都过一遍，还有很多做题的便捷方法，也是强推。
中途我听过张宇老师的课，我个人的建议是如果跟张宇一定要跟全程。我当时是基础跟的汤老师，强化阶段听了一段时间张宇，感觉很难跟上他的方法，所以就放弃了。但是我身边有一些全程跟张宇老师的同学，成绩也不错。所以大家还是根据自己的接受程度，选择老师。
时间规划（建议）：
暑假之前（现在-7月）：过一遍基础课程和1800基础题（其他基础习题也可以），听课一定要做题，不然就是白听。ps:这个阶段其实很多基础题会有点综合性，做起来有点难，可以适度放弃，等基础过一遍之后回头再做。
暑假期间（7月到9月）：强化课程+1800强化篇+660 强化难度会明显提高许多，做题需要大量的时间。
开学之后（9-10月）：这段时间就是大量做题，听武忠祥老师的十七堂课，如果觉得自己掌握的不错，可以按题型选择性的听。将1800和660的题目做完，整理错题，然后完成330。330题目不多，做起来很快。开始做真题，张宇的真题大全解从87年开始，可以做一些早期的练手。但是个人觉得00年之后的真题更有参考价值，如果时间来不及可以从00开始做。
冲刺阶段（11-12月）：这段时间很多模拟题都应该到手了，所以这段时间要先完成全部真题的练习，并且完全掌握真题的考点，再开始模拟。真题很重要，有助于你熟悉题型和易考考点。由于2022年的数学难度应该不小，比较推荐大家做一做张宇的劝退八套卷和四套卷，是真的难但是也是真的锻炼心态。个人觉得预测卷，李林八套卷、李林四套卷、张宇八套卷和四套卷就已经够了，一定要吃透。其他大家根据自己情况酌情而定，汤家凤老师的预测卷不太推荐，质量不高，感觉团队重心不在预测。
数学学习的战线很长，感觉总是在不会和会中来回切换，希望大家有个良好的心态吧，大家都一样！
2.英语二（80+）
推荐用书：张剑真题全解+两套真题（没有详解的比较便宜）
王江涛高分作文 陈正康单词书
（我大概只买了这些，大家可以根据自己的情况买单词书和长难句等）
推荐课程：唐迟阅读课（强推），王江涛作文课，唐静翻译课，长难句（我听的何凯文，感觉一般，有的同学推荐田静老师）
英语的学习，对于考研前期来说，最主要的任务就是背单词，我个人喜欢用app背，我用的是百词斩app大概过了五六遍考研单词，然后用不背单词app过了一遍（这个app是要求你要拼写出来才算过），最后冲刺阶段用单词书看着例句最后过了一遍，大家可以根据自己适合的方式，看书也好，app也好，背单词这个工作一定要贯穿始终。
如果基础还不错，可以在开始专项练习之前，拿出一套最近的真题模拟一下，看看自己现在的水平，然后再针对性的练习。
英语根据不同人的程度，进度应该有所不同，建议先做英一的真题，配合唐迟的阅读课程，掌握阅读技巧。英一的阅读要比英二稍难一些，英二的真题少，从10年开始才有英一，所以建议大家前期多做英一的阅读进行练习，建议做两遍。英二真题留出3-4套后期模拟，每一套都要研究细致，尤其是近几年的真题，生词难词一定要记住，重复考察的概率很高。
翻译和作文，不建议准备太早。翻译的练习可以在平时做完阅读，精译的时候有意识的练习，后期配合唐静老师的翻译课。作文九十月份开始，背诵王江涛老师的必背作文，对我来说很有效果，后面整理自己的模板。
ps：王江涛老师背诵作文的方法褒贬不一，对我而言很实用，每天睡前背半个小时可以背两篇小作文或者一篇大作文，可以熟悉很多基础用法，了解作文结构，方便自己整理出自己的模板。
3. 专业课（130+）
推荐用书：王道数据结构+操作系统，哈工程真题
推荐课程：（如果跨考无基础的）MOOC陈越老师的数据结构，王道的数据结构和操作系统的课程
ps: 真题建议大家购买程程笔记（原名白皮书）或者FLY团队的都还可以，我个人因为买的第一家真题实在用户体验太差，初试买了三家的资料，后面这两家都还可以。个人强烈建议同学们不要花大价钱买学长给上课的课程，性价比太低，踩雷的概率很大，学姐学长也很忙，修行还是在个人。
哈工程的专业课包括数据结构和操作系统两本书，题型很固定。辅导书可以使用王道的，但是王道面向408考生，难度会更高，建议大家优先做王道的选择题，过一遍知识点再根据真题的题型选择性的做一做王道的大题。建议还是真题为主。
个人觉得今年的专业课难度是有所提升的，考了许多不是经常会考的考点，数据结构还增加了简答题。所以给大家的复习建议是，一定要理解为主，跨考无基础的可以在MOOC上找一些高校老师的课程，王道的课程比较应试。还有就是不要轻易的觉得哪个题型考的少，觉得麻烦就放弃了，大家也都知道，区区一个考试，你怕什么，它就考什么。
哈工程专业课整体难度并不大，大家分值普遍不低，性价比很高，一定要认真准备。
4. 政治（75）
推荐用书：徐涛老师的核心考案/肖秀荣的精讲精练 （一本即可）+肖秀荣1000题+肖四肖八+徐涛背诵笔记/腿姐背诵笔记（一本即可）
推荐课程：徐涛强化课+腿姐冲刺课（一些解题技巧）
政治复习不建议开始太早，最早也不要早过暑假了。我是在暑假期间每天学累了听一两个小时政治课当做休息一下，徐涛老师马原讲的很好，如果时间来得及还是很建议大家听一遍强化课，配合1000题练习。
其实政治备考，最重要的部分是肖四肖八的背诵，最主要就是肖四的背诵。今年的肖老师可以说是杀疯了，押题全中不说，还都集中在肖四第一套。（我的研友只被了第一套，我背了四套，他政治就比我低了6分，可见）但是作为经历过两年考研的人，2020年肖老师并没有这么猛，虽说考研大军全看肖老师发挥，但是还是建议大家时间充裕的话打好基础，系统复习，也顺便培养一下政治素养。
以上就是我的全部初试经验啦，希望大家都能取得好成绩，虽千万人吾往矣，各位加油！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3232a63b03250173e2b813c151a2e89/" rel="bookmark">
			MySQL单表的访问方法和连接的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记大纲 1.单表的访问方法概念1.1 const 访问类型1.2 ref 访问类型1.3 ref_or_null 访问类型1.4 range 访问类型1.5 index 访问类型1.6 all 访问类型 2.索引合并2.1 Intersection 索引合并/交集合并2.2 Union 索引合并2.3 Sort-Union 索引合并2.4 为什么MySQL没有Sort-Intersection 3.连接的原理3.1 驱动表和被驱动表3.2 嵌套循环连接3.3 索引加快连接速度3.4 基于块的嵌套循环连接 1.单表的访问方法概念 MySQL的SQL查询语句对表的访问或者是查询可以有多种方式，每种方式执行的成本、花费的时间大不一样，MySQL定义了很多种表的访问方式或者叫访问类型来。
1.1 const 访问类型 通过主键索引或者唯一二级索引和常数值进行查询的时候因为目标结果是唯一确定的，MySQL认为这种查询效率十分高，成本消耗几乎忽略不计，这种访问方式定义为常数级访问const。
1.2 ref 访问类型 通过二级索引和常数值进行查询的时候，扫描区间是一个单点区间，MySQL讲这种查询方式定义为ref访问类型。
1.3 ref_or_null 访问类型 这种类型是ref的一种特殊存在，区别是它多了一些扫描Null值的扫描区间。
1.4 range 访问类型 如果查询条件对应的不是一个单点区间，而是一个范围区间，那么MySQL定义这种访问方式是range范围访问类型。
1.5 index 访问类型 通过扫码全部二级索引树获取数据的方式定义为index访问类型。索引树里包含了要查询的列，通过遍历索引即可找到结果。
1.6 all 访问类型 遍历整颗主键索引B+Tree。
2.索引合并 MySQL绝大部分情况下一个查询只能用到一个索引，但是某些特殊场景MySQL做了优化，可以利用多个索引来提升查询效率。
2.1 Intersection 索引合并/交集合并 SELECT * FROM user WHERE a = 'a' AND b = 'b'，如果a和b列都是二级索引，在一般情况下MySQL只会选择其中之一来进行查询。但是如果a和b这俩二级索引里面所对应的主键ID是有序的，那么MySQL可以通过交集合并的方式利用a索引匹配到结果集，然后利用b索引匹配到结果集，然后求交集，就是最后的正确结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3232a63b03250173e2b813c151a2e89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d742b3f47060cd2ca2071c95c861420/" rel="bookmark">
			git ssh: Could not resolve hostname github.com: No address associated with hostname
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ssh: Could not resolve hostname github.com: No address associated with hostname 配置github中的ssh keys，验证是否成功，我们可以通过在 Git Bash 中输入 ssh -T git@github.com
# 报错 ssh: Could not resolve hostname github.com: No address associated with hostname 解决办法：
1.ping github.com确定ip地址
ping www.github.com 2.找到windows系统下的hosts文件
路径：C:\Windows\System32\drivers\etc
3.将ping到的ip地址加入hosts文件中
比如：20.205.243.166 github.com 4.如何加入hosts文件中并保存
打开黑窗口以管理员的身份进入，输入notepad,出现下面界面
然后点击文件选择打开，找到hosts文件打开就可以进行修改保存
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/143b978480ee5b0b869ea8929f59f823/" rel="bookmark">
			CVPR2020论文列表（中英对照）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Conditional Channel Gated Networks for Task-Aware Continual Learning 用于任务感知持续学习的条件通道门控网络
Multimodal Categorization of Crisis Events in Social Media 社交媒体中危机事件的多模式分类
Counterfactual Vision and Language Learning 反事实视觉和语言学习
Gold Seeker Information Gain From Policy Distributions for Goal-Oriented Vision-and-Langauge 从面向目标的愿景和语言的政策分配中获取寻金者信息
Image2StyleGAN How to Edit the Embedded Images Image2StyleGAN 如何编辑嵌入的图像
Cross-Modal Deep Face Normals With Deactivable Skip Connections 具有可停用跳跃连接的跨模态深面法线
Hussein Correction Filter for Single Image Super-Resolution Robustifying Off-the-Shelf Deep Super-Resolvers用于单幅图像超分辨率鲁棒化现成深度超分辨率的 Hussein 校正滤波器
Towards Achieving Adversarial Robustness by Enforcing Feature Consistency Across Bit 通过强制跨位特征一致性来实现对抗性鲁棒性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/143b978480ee5b0b869ea8929f59f823/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eb0ac27f878244bbcf32df744dd423b/" rel="bookmark">
			python dict类型底层实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构 HashMap dict 其实叫做字典是属于直译了
我个人比较喜欢叫他hashmap
因为在不同的编程语言中，数据结构都是大同小异的，迁移到其他编程语言的数据结构，这个结构就叫hashmap
写一段python的伪代码
dict[key] = value; 在python中 字典的keyvalue叫做键值对，
hashmap[hash] = value; 在数据结构hashmap中是以hash值作为键的
其实dict的底层也是给变量存了一个hash值，默认是这个变量的id（也就是地址）
__hash__和__eq__的区别 对于一个自定义的Position类
我们可以重载==运算符，令两个x和y都相等的Position类，在执行equal的时候返回True。
def __eq__(self, other): return self.x == other.x and \ self.y == other.y; def __hash__(self, other): #如果只重载__eq__的话，baseObject类会认为__hash__不需要继承，导致没有__hash__函数 return id(self); 但是在hashmap这个结构里，如果想把两个重载了equal的Position类作为相同键值，
要符合hashmap的要求，hashmap数据结构里必须要保证两个equal相等的值，它们的hash也要一样。
hashmap需要比较的第一步是__hash__，而真正存入hashmap键值的是数据结构的地址。
所以hashmap会先去比较两个数据结构的hash，如果两个数据结构的hash是不一样的，那么就认为这两个数据结构是不可能相等的。
想让他们的hash值相同，那么我们最好借用系统给的hash函数，给其中hashable的数据做一个hash，作为我们自定义数据结构的hash。
我们把x和y值变成一个tuple，对他做hash，把这个hash值作为我们自定义object的hash。
def __eq__(self, other): return self.x == other.x and \ self.y == other.y; def __hash__(self, other): #如果只重载__eq__的话，baseObject类会认为__hash__不需要继承，导致没有__hash__函数 return hash((self.x, self.y)); 如果把__eq__重载去掉，那么又会变成两个key值，因为根据hashtable的原理，两个不同的数据结构有可能拥有相同的hash，这个叫hash collision（哈希冲突），在比较完hash之后一定还要比较这两个数据是不是一样的。
哈希冲突：举个例子 如果对于字符串的hash函数是加和运算
an 的ascii码 97 + 110
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4eb0ac27f878244bbcf32df744dd423b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6c73b32e65376122103096a3deb2859/" rel="bookmark">
			【第二次伺服学习总结，速度环P和I的改变】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、测试内容为模型环功能关闭（柔和模式）第一次测试
速度环，P：200，I：3300。
位置环，P：200。
低刚性，低响应，抖动大，响应慢
速度指令中指定速度为1500 ，响应时间为11.56，
最大超调速度值为1523.808，时间为11.58
稳定时间为11.72
数据总结：速度误差最大为23.8，此时时间差为0.02，稳定时间差为0.16
二、第二次测试
速度环，P：800，I：825。
位置环，P：700。
理论上效果应更佳，但实际上抖动严重，报错error-161，驱动器热功率过载，详细原因应该为增益系数设置错误。
三、第三次测试
进行数据测试
速度环，P：200，I：2500。
位置环，P：200。
速度指令中指定速度为1500，响应时间为9.8
最大超调速度值为1526.668，时间为9.84
稳定时间为9.94
数据总结：速度误差最大为26.668，此时时间差为0.04，稳定时间差为0.14
较为明显，整体效果降低
四、第四次测试
速度环，P：300，I：3300。
位置环，P：200。
速度指令中指定速度为1500，响应时间为14.58
最大超调速度值为1521.52，时间为14.6
稳定时间为14.74
数据总结：速度误差最大为21.52，此时时间差为0.02，稳定时间差为0.16
较为明显，整体效果增强
总结：事实说明，P适量增大能够提升整体增益
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d562019a295e7c8d4ac4a36176bfd4ec/" rel="bookmark">
			MyBatisPlus：DML编程控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatisPlus 前面我们讲解了
基于MyBatisPlus完成标准Dao的增删改查功能
掌握MyBatisPlus中的分页及条件查询构建 | 黑马程序员
MyBatisPlus：DQL编程控制（条件查询方式、查询投影、查询条件设定、字段映射与表名映射）
✏点击回顾哦。
一、DML编程控制 查询相关的操作我们已经介绍完了，紧接着我们需要对另外三个，增删改进行内容的讲解。挨个来说明下，首先是新增(insert)中的内容。
1.1 id生成策略控制 前面我们在新增的时候留了一个问题，就是新增成功后，主键ID是一个很长串的内容，我们更想要的是按照数据库表字段进行自增长，在解决这个问题之前，我们先来分析下ID该如何选择:
不同的表应用不同的id生成策略 日志：自增（1,2,3,4，……）购物订单：特殊规则（FQ23948AK3843）外卖单：关联地区日期等信息（10 04 20200314 34 91）关系表：可省略id…… 不同的业务采用的ID生成方式应该是不一样的，那么在MP中都提供了哪些主键生成策略，以及我们该如何进行选择?
在这里我们又需要用到MP的一个注解叫@TableId
知识点1：@TableId 名称@TableId类型属性注解位置模型类中用于表示主键的属性定义上方作用设置当前类中主键属性的生成策略相关属性value(默认)：设置数据库表主键名称
type:设置主键属性的生成策略，值查照IdType的枚举值 1.1.1 环境构建 在构建条件查询之前，我们先来准备下环境
创建一个SpringBoot项目
pom.xml中添加对应的依赖
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;mybatisplus_03_dml&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d562019a295e7c8d4ac4a36176bfd4ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eef0e47869cc60f19f9bf9c4907ee378/" rel="bookmark">
			深度学习论文精读[1]：FCN全卷积网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者最近在集中时间撰写深度学习图像分割一书，需要对语义分割众多经典论文进行回顾和精读。目前在写第五章：基于U形结构的网络结构设计，从语义分割的开山之作FCN开始，重启精读之路。
随着CNN在图像识别中取得巨大成功，一些经典的图像分类网络（AlexNet、VGG、GoogLeNet、ResNet）也逐渐被应用于更加细分的视觉任务中。很多研究者也在探索如何将分类网络进行改造后用于语义分割的密集预测问题（dense predictions）。在更高效的语义分割网络提出之前，学术界用于密集预测任务的模型主要有以下几个特点：
（1）小模型。早期的网络结构受限于数据量和高性能的计算资源，在设计上一般不会使用过大的模型。
（2）分块训练。分块训练（patchwise training）在当时是图像训练的普遍做法，但该方法对于全卷积网络的训练会显得相对低效，但分块训练的优点在于能够规避类别不均衡问题，并且能够缓解密集分块的空间相关性问题。
（3）输入移位与输出交错。该方法可以视为一种输入与输出的变换方法，在OverFeat等结构中被广泛使用。
（4）后处理。对于神经网络输出质量不高的问题，对输出加后处理也是常见做法，常用的后处理方法包括超像素投影（superpixel projection）、随机场正则化（random field regularization）和图像滤波处理等。
可以看到，早期用于目标检测、关键点预测和语义分割等密集预测问题整体来看有两个缺陷，一是无法实现端到端（end-to-end）的流程，模型整体效率不佳；第二个则是不能做到真正的密集预测的特征：像素到像素（pixels-to-pixels）的预测。
全卷积网络（Fully Convolutional Networks, FCN）的提出，正好可以解决早期网络结构普遍存在的上述两个缺陷。FCN在2015年的一篇论文Fully Convolutional Networks for Semantic Segmentation中提出，其主要思路在于用卷积层代替此前分类网络中的全连接层，将全连接层的语义标签输出改为卷积层的语义热图（heatmap）输出，再结合上采样技术实现像素到像素的密集预测。如下图所示，上图为常见分类网络的流程，在五层卷积网络之后有三层全连接网络，最后输出一个包含类别语义信息的输出概率；下图为FCN网络流程，在上图分类网络的基础上，将最后三层全连接层改为卷积层，输出也相应的变为分类预测的热图，这样就为了最后的像素级的密集预测提供了基础。
所以，FCN实现密集预测的关键在于修改全连接层为卷积层，那么具体是如何修改的呢？先来详细分析一下的卷积层和全连接层的特征。卷积层与全连接层最大的区别在于卷积层每次计算时只与输入图像中一个具体的局部做运算，但二者都是做点积计算，其函数形式是类似的。假设给定在指定网络层任意坐标点(i,j)的数据向量Xij，而下一层对应坐标点的数据向量为Yij，有：
其中为卷积核大小或者权重向量长度，s为步长（stride），而f_ks则表示当前层到下一层的映射函数，f_ks既可以表示为卷积层又可以表示为全连接层，所以二者之间的转换是有理论基础的。将全连接层修改为卷积层，从实际操作上来看是容易的，以VGG16中第一个全连接层25088x4096尺寸为例，现将其转化为512x7x7x4096大小的卷积层，即输入大小为7x7x512，卷积核为512个77大小的卷积核，通道数为4096，相应的输出大小为1x1x4096。在PyTorch中测试全连接层与卷积层的转换，如下代码所示。
# 导入PyTorch库 import torch from torch import nn # 指定输入向量 x = torch.rand(25088,) # 定义全连接层 fc = nn.Linear(25088, 4096) # 定义卷积层 conv2d = nn.Conv2d(512, 4096, 7) # 输出全连接层计算 fc_output = fc(x) print(fc_output.size()) # 输入向量变换 x = torch.reshape(x, (1, 512, 7, 7)) # 数据卷积层计算 conv_output = conv2d(x) print(conv_output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eef0e47869cc60f19f9bf9c4907ee378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8494b94ab774ac0d72c2daa1f402dd8/" rel="bookmark">
			【专题】深搜算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接区 安利一发我的博客：WillHou’s Blog
前言 之所以要把深搜(递归)放在栈后面写，是因为深搜的本质就是一个栈。
当我们递归地实现 DFS 时，似乎不需要使用任何栈。但实际上，我们使用的是由系统提供的隐式栈，也称为调用栈（Call Stack）。—— CSDN 大佬 却把清梅嗅
深搜的优点：
代码量小可读性强更容易实现 深搜的缺点：
如果深度太高，容易发生栈溢出容易超时 深搜的使用场景：
在图论中大量使用（实际上深搜的概念就是基于图论的，只不过我们通常把深搜的概念广义化）当你实在做不出来时骗分 概念 DFS 全称是 Depth First Search，中文名是深度优先搜索，是一种用于遍历或搜索树或图的算法。所谓深度优先，就是说每次都尝试向更深的节点走。DFS 常常用来指代用递归函数实现的搜索，但实际上两者并不一样。
应用 先来一个不是这么正经的，感受一下何为递归。
#include &lt;iostream&gt; void tellStory() { puts("从前有座山，山上有座庙，庙里有个老和尚在讲故事，讲的故事是："); tellStory(); } int main() { tellStory(); return 0; } 这个程序永远无法终止，会不停的输出“从前有座山，山上有座庙，庙里有个老和尚在讲故事，讲的故事是：”。
当然，这样的程序完全没有用处。所以，我们尝试对它加入次数限制：
#include &lt;iostream&gt; void tellStory(int times) { if (!times) return ; puts("从前有座山，山上有座庙，庙里有个老和尚在讲故事，讲的故事是："); tellStory(times-1); } int main() { tellStory(10); return 0; } 这样，我们限制它只输出十次。那如果我也想看到这是第几次输出呢？
#include &lt;iostream&gt; void tellStory(int times) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8494b94ab774ac0d72c2daa1f402dd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/103e3726c4523dec4b777100c40f569c/" rel="bookmark">
			MYSQL批量更改数据库表和字段的字符集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、修改所有表中的varchar和char字段以及排序集（dataBaseName修改为库名）
SELECT CONCAT( 'ALTER TABLE `', TABLE_NAME, '` MODIFY `', COLUMN_NAME, '` ', DATA_TYPE, '(', CHARACTER_MAXIMUM_LENGTH, ') CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci', ( CASE WHEN IS_NULLABLE = 'NO' THEN ' NOT NULL' ELSE '' END ), ';' ) FROM information_schema. COLUMNS WHERE TABLE_SCHEMA = 'dataBaseName' AND (DATA_TYPE = 'varchar' OR DATA_TYPE = 'char') 注：修改后关于已添加的字符串类型的注释将会消失，需要重新添加
二、修改所有表的编码及排序集（dataBaseName修改为库名）
SELECT CONCAT( 'ALTER TABLE ', TABLE_NAME, ' CONVERT TO CHARACTER SET utf8mb4;' ) FROM information_schema.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/103e3726c4523dec4b777100c40f569c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d751ee296fd6ae66d2b5dc1e97c2e323/" rel="bookmark">
			阿里云OSS文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		和传统的单体应用不同，这里我们选择将数据上传到分布式文件服务器上。
这里我们选择将图片放置到阿里云上，使用对象存储。
阿里云上使使用对象存储方式：
创建Bucket
上传文件：
上传成功后，取得图片的URL
这种方式是手动上传图片，实际上我们可以在程序中设置自动上传图片到阿里云对象存储。
上传模型：
查看阿里云关于文件上传的帮助： https://help.aliyun.com/document_detail/32009.html?spm=a2c4g.11186623.6.768.549d59aaWuZMGJ
（1）、添加依赖包
在Maven项目中加入依赖项（推荐方式）
在 Maven 工程中使用 OSS Java SDK，只需在 pom.xml 中加入相应依赖即可。以 3.8.0 版本为例，在 内加入如下内容：
com.aliyun.oss aliyun-sdk-oss 3.8.0 （2）、上传文件流 以下代码用于上传文件流：
// Endpoint以杭州为例，其它Region请按实际情况填写。 String endpoint = "http://oss-cn-hangzhou.aliyuncs.com"; // 云账号AccessKey有所有API访问权限，建议遵循阿里云安全最佳实践，创建并使用RAM子账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建。 String accessKeyId = "&lt;yourAccessKeyId&gt;"; String accessKeySecret = "&lt;yourAccessKeySecret&gt;"; // 创建OSSClient实例。 OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); // 上传文件流。 InputStream inputStream = new FileInputStream("&lt;yourlocalFile&gt;"); ossClient.putObject("&lt;yourBucketName&gt;", "&lt;yourObjectName&gt;", inputStream); // 关闭OSSClient。 ossClient.shutdown(); endpoint的取值：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d751ee296fd6ae66d2b5dc1e97c2e323/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f06be36507f7ab33fe043ac0bd399685/" rel="bookmark">
			centos stream 8 升级和切换python版本的简单方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 别再傻乎乎的从源码构建和修改python软连接了！
由于想在腾讯轻量云服务器上部署一个python机器人，需要centos的3.7.3以上的python，但提供的镜像中centos stream8 自带的python版本为3.6.8，不满足要求，所以需要升级python，在经过多次重装系统之后，我终于发现了最快最简单最不容易出错（指误删）的方法。
记录 1.首先切换到超级账户并查看自带的python版本：
sudo -i python3 -V #如果有python2的话也请试一下python -V 2.直接用dnf安装需要的python版本（我这里安装3.9）：
dnf module -y install python39 3.切换你需要的python版本：
alternatives --config python3 会弹出以下提示，打入数字选择新的python，再输入python3 -V，此时版本已经切换到了3.9.7：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fa2f134e7cb7d12a1a8ef73e699c746/" rel="bookmark">
			Linux生产者消费者模型(POSIX信号量)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.生产者消费者模型
1.基本概念
2.模型特点
3.模型优点 二.基于BlockingQueue的生产者消费者模型
1.基本概念
2.单生产者、单消费者为例进行模拟实现 3.基于计算任务的生产者消费者模型
三.POSIX信号量
1.基本概念
2.信号量函数
三. 二元信号量模拟实现互斥功能 四.基于环形队列的生产者消费者模型
1.生产者和消费者关心不同资源
2.需要遵守的两个原则
3.代码模拟实现
4.信号量保护环形队列 一.生产者消费者模型 1.基本概念 生产者消费者模式就是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过这个容器来通讯，所以生产者生产完数据之后不用等待消费者处理，直接将生产的数据放到这个容器当中，消费者也不用找生产者要数据，而是直接从这个容器里取数据，这个容器就相当于一个缓冲区，平衡了生产者和消费者的处理能力，这个容器实际上就是用来给生产者和消费者解耦的。 2.模型特点 (1)生产者消费者模型是多线程同步与互斥的一个经典场景，其特点如下：
三种关系： 生产者和生产者（互斥关系）、消费者和消费者（互斥关系）、生产者和消费者（互斥关系、同步关系）。两种角色： 生产者和消费者。（通常由进程或线程承担）一个交易场所： 通常指的是内存中的一段缓冲区。（可以自己通过某种方式组织起来） 我们用代码编写生产者消费者模型的时候，本质就是对这三个特点进行维护。
(2)生产者和生产者、消费者和消费者、生产者和消费者，它们之间为什么会存在互斥关系？
介于生产者和消费者之间的容器可能会被多个执行流同时访问，因此我们需要将该临界资源用互斥锁保护起来。其中，所有的生产者和消费者都会竞争式的申请锁，因此生产者和生产者、消费者和消费者、生产者和消费者之间都存在互斥关系。 (3)生产者和消费者之间为什么会存在同步关系？
如果让生产者一直生产，那么当生产者生产的数据将容器塞满后，生产者再生产数据就会生产失败。反之，让消费者一直消费，那么当容器当中的数据被消费完后，消费者再进行消费就会消费失败。虽然这样不会造成任何数据不一致的问题，但是这样会引起另一方的饥饿问题，是非常低效的。我们应该让生产者和消费者访问该容器时具有一定的顺序性，比如让生产者先生产，然后再让消费者进行消费。 注意： 互斥关系保证的是数据的正确性，而同步关系是为了让多线程之间协同起来。
(4)让消费者和生产者协同工作，合适的时候可能一直运行，生产者和消费者并不会因为要互相等待对方的结果而阻塞，相当于双方可以并发执行.
(5)为什么要有生产者消费者模型？ 本质是用代码进行解耦的过程
3.模型优点 解耦。支持并发。支持忙闲不均 (哪边的线程忙可以多分配一些线程) (1)如果我们在主函数中调用某一函数，那么我们必须等该函数体执行完后才继续执行主函数的后续代码，因此函数调用本质上是一种紧耦合。
(2)对应到生产者消费者模型中，函数传参实际上就是生产者生产的过程，而执行函数体实际上就是消费者消费的过程，但生产者只负责生产数据，消费者只负责消费数据，在消费者消费期间生产者可以同时进行生产，因此生产者消费者模型本质是一种松耦合。
二.基于BlockingQueue的生产者消费者模型 1.基本概念 在多线程编程中阻塞队列(Blocking Queue)是一种常用于实现生产者和消费者模型的数据结构。其与普通的队列区别在于，当队列为空时，从队列获取元素的操作将会被阻塞，直到队列中被放入了元素当队列满时，往队列里存放元 素的操作也会被阻塞，直到有元素被从队列中取出(以上的操作都是基于不同的线程来说的，线程在对阻塞队列进行操作时会被阻塞) 2.单生产者、单消费者为例进行模拟实现 (1) 生产和消费步调一致，生产一个消费一个
①BlockQueue.hpp
#pragma oncec #include &lt;iostream&gt; #include &lt;pthread.h&gt; #include &lt;queue&gt; #include &lt;unistd.h&gt; #define NUM 5 template&lt;class T&gt; class BlockQueue { private: bool IsFull() { return _q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fa2f134e7cb7d12a1a8ef73e699c746/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ecf9f62f02f28082b316891a61bd75f/" rel="bookmark">
			SQLserver连接IDEA报错 java.lang.ClassNotFoundException: com.microsoft.sqlserver.jdbc.SQLServerDriver问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一点：检查本地sqlserver服务（点击左下角开始找到本地安装的配置管理器）
打开后找到SQL server网络配置里的 MSSQLSERVER的协议
点击进入属性修改IP地址（修改为127.0.0.1）TCP端口为1433
以及检查最底下IPALL的TCP端口是不是一致的（确保一致后点击应用）
修改完毕后检查自己SQL Server（MSSQLSERVER）有没有启动
打开sql server连接到服务器
打开【控制面板】，单击“程序”；单击“打开或关闭Windows功能”，勾选“Telnet客户端”单击“确定”。
连接完打开win+r（输入cmd），输入cmd telent localhost 1433 检测连接
连接成功就出现黑框
idea 在web-inf下新建一个lib【导入sqljdbc42.jar包】
https://www.microsoft.com/zh-cn/download/details.aspx?id=54671（官方连接）
导入后右键sqljdbc42.jar包点击Add as Library
导包后进行测试 （这是我抄的一个大佬的测试，我解决完后忘了大佬是哪个，先跟大佬说声对不起）
@SpringBootTest class SpringbootApplicationTests { private static Connection dbConn = null; @Test void contextLoads() { String dbURL = "jdbc:sqlserver://localhost:1433;DatabaseName=Stu";//这里输入自己的数据库名称（即将Stu改为你自己的数据库名称）其余都可以不做修改 try { //1.加载驱动 Class.forName("com.microsoft.sqlserver.jdbc.SQLServerDriver").newInstance(); System.out.println("加载驱动成功！"); //2.连接 dbConn = DriverManager.getConnection(dbURL, "sa", "123456");//这里的密码改为第一步你所修改的密码，用户名一般就为"sa" System.out.println("连接数据库成功！"); String sql="select sname from dbo.Table_1";//这个语句就是表的查询语句，按照你所建的表修改名称 PreparedStatement statement=null; statement=dbConn.prepareStatement(sql); ResultSet res=null; res=statement.executeQuery(); while(res.next()){ String title=res.getString("sname"); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ecf9f62f02f28082b316891a61bd75f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/792f99759891994941714a7d3b013a5e/" rel="bookmark">
			【MyBatis-Plus】DML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👉 博客主页：准Java全栈开发工程师
👉 00年出生，即将进入职场闯荡，目标赚钱，可能会有人觉得我格局小、觉得俗，但不得不承认这个世界已经不再是以一条线来分割的平面，而是围绕财富旋转的球面，成为有钱人不是为了去掌控球体的转向，而是当有人恶意掌控时，努力保护好家人和自己。
DML 一、id 生成策略AUTO 策略INPUT 策略ASSIGN_ID 策略ASSIGN_UUID 策略 二、简化配置三、多记录操作删除多条数据查询多条数据 四、逻辑删除步骤一：数据库表添加 deleted 列步骤二：实体类添加 deleted 属性测试删除操作配置文件配置相关内容 五、乐观锁1、乐观锁的实现方式2、实现步骤1）数据库表添加列2）实体类添加对应的属性3）添加乐观锁拦截器4）测试5）模拟多线程 一、id 生成策略 MP 提供了自动生成 id 的功能，也就是我们之前在测试添加功能时生成的那一大长串的数据。而对于不同的表，所生成的 id 策略也是不同的，那么我们该如何选择和设置 id 的生成策略呢？在该部分我们需要使用到一个新的注解 @TableId ，该注解用来设置 id 的生成策略，除了过时的策略外，还存在一些较为常用的策略，接下来一一对其进行介绍。 AUTO 策略 AUTO 策略的作用是使用数据库 ID 自增，在使用该策略的时候一定要确保对应的数据库表设置了 ID主键自增，否则无效。
INPUT 策略 INPUT 策略为用户手工自定义 id ，使用该策略时需要取消掉数据库表中的自增属性，即取消勾选 id 自增勾选框，在添加数据时需要手动设置 id 值且必须设置，否则报错，不能成功完成添加操作。
ASSIGN_ID 策略 ASSIGN_ID 策略使用雪花算法生成 id ，这也是 MP 提供的默认的 id 策略，就是我们之前所看到的那一长串的 long 型数据，使用该策略可以不手动设置 id ，但是可以手动设置 id ，如果手动设置，则使用手动设置的 id ，不使用自动生成的。
ASSIGN_UUID 策略 使用 UUID 策略需要注意，主键的类型不能是 Long 类型，而应该改成 String 类型，与此同时，数据库表中主键类型设置为 varchar 类型，且长度要大于 32 ，因为 UUID 生成的主键为 32 位，如果长度小的话就会导致插入失败。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/792f99759891994941714a7d3b013a5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bafac7aa0303ab9bb698d04160ff41ca/" rel="bookmark">
			可靠协调系统Zookeeper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、zookeeper简介1、zookeeper的概述2、 Zookeeper的定义3、 Zookeeper的工作机制4、Zookeeper 的特点5、zookeeper 的数据结构1、统一命名服务2、统一配置管理3、 统一集群管理4、服务器动态上下线5、软负载均衡 三、Zookeeper的选举机制1、第一次启动选举机制2、非第一次启动选举机制 四、部署Zookeeper集群 一、zookeeper简介 1、zookeeper的概述 ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。
ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。
ZooKeeper包含一个简单的原语集，提供Java和C的接口。
ZooKeeper代码版本中，提供了分布式独享锁、选举、队列的接口，代码在$zookeeper_home\src\recipes。其中分布锁和队列有Java和C两个版本，选举只有Java版本。
2、 Zookeeper的定义 Zookeeper是一~个开源的分布式的，为分布式框架提供协调服务的Apache项目。
3、 Zookeeper的工作机制 Zookeeper从设计模式角度来理解:是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。就是说Zookeeper =文件系统+通知机制。 4、Zookeeper 的特点 (1) Zookeeper：一个领导者(Leader) ，多个跟随者(Follower) 组成的集群。
(2) Zookeepe集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。
(3)全局数据一致：每个Server保存一份相同的数据副本，Client无论连接到哪个Server， 数据都是一致的。
(4)更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行，即先进先出。.
(5)数据更新原子性，一次数据更新要么成功，要么失败。
(6)实时性，在一定时间范围内，Client能读到最新数据。
5、zookeeper 的数据结构 ZooKeeper数据模型的结构与Linux文件系统很类似，整体上可以看作是一棵树，每个节点称做–个ZNode。每一个ZNode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识。 二、Zookeeper的应用场景
提供的服务包括:统一命名服务、 统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。 1、统一命名服务 在分布式环境下，经常需要对应用/服务进行统一命名， 便于识别。例如: IP不容 易记住，而域名容易记住。 2、统一配置管理 分布式环境下，配置文件同步非常常见。一般要求一个集群中，所有节点的配置信息是一致的，比如Kafka集群。对配置文件修改后，希望能够快速同步到各个节点上。配置管理可交由ZooKeeper实现。可将配置信息写入ZooKeeper.上的一-个Znode。各个客户端服务器监听这个Znode。一旦Znode中的数据被修改，ZooKeeper将 通知各个客户端服务器。 3、 统一集群管理 分布式环境中，实时掌握每个节点的状态是必要的。可根据节点实时状态做出一-些调整。ZooKeeper可以实现实时监控节点状态变化。可将节点信息写入ZooKeeper.上的一-个ZNode。监听这个ZNode可获取它的实时状态变化。 4、服务器动态上下线 客户端能实时洞察到服务器上下线的变化。 5、软负载均衡 在Zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求。 三、Zookeeper的选举机制 1、第一次启动选举机制 服务器1启动，发起一次选举。服务器1投自己一票。此时服务器1票数一票， 不够半数以上(3票)，选举无法完成，服务器1状态保持为LO0KING;服务器2启动，再发起一次选举。服务器1和2分别投自己一票并交换选票信息:此时服务器1发现服务器2的myid比自己目前投票推举的( 服务器1)大，更改选票为推举服务器2。此时服务器1票数0票，服务器2票数2票，没有半数以上结果，选举无法完成，服务器1，2状态保持LOOKING服务器3启动，发起一次选举。此时服务器1和2都会更改选票为服务器3。此次投票结果:服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数，服务器3当选Leader。服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING;服务器4启动，发起一次选举。此时服务器1，2，3已经不是L00KING状态，不会更改选票信息。交换选票信息结果:服务器3为3票，服务器4为1票。此时服务器4服从多数，更改选票信息为服务器3，并更改状态为FOLLOWING;服务器5启动，同4服从多数，更改选票信息为服务器3，并更改状态为FOLLOWING; 2、非第一次启动选举机制 当ZooKeeper集群中的一台 服务器出现以下两种情况之一时， 就会开始进入Leader选举: 服务器初始化启动。服务器运行期间无法和Leader保持连接。 而当一台机器进入Leader选举流程时，当前集群也可能会处于以下两种状态: 集群中本来就已经存在一个Leader。
对于已经存在Leader的情况，机器试图去选举Leader时，会被告知当前服务器的Leader信息，对于该机器来说，仅仅需要和Leader机器建立连接，并进行状态同步即可。集群中确实不存在Leader
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bafac7aa0303ab9bb698d04160ff41ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fb03ea8a196a7295775490d6db94a0a/" rel="bookmark">
			docker的冷门高级玩法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker 高级操作 文章目录 Docker 高级操作1. 容器的进程2. 命名空间3. chroot4. cgroups4.1 进程的CPU统计信息4.2 进程的内存配置4.3 如何配置cgroups? 5. Seccomp / AppArmor6. Capabilities7. 容器镜像8. 创建空镜像9. 不使用Dockerfile创建镜像 1. 容器的进程 $ docker run -d --name=db redis:alpine $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e2edc005ea6e redis:alpine "docker-entrypoint.s…" 31 seconds ago Up 30 seconds 6379/tcp db #Docker容器启动一个名为redis-server的进程。在主机上，我们可以看到所有正在运行的进程，包括由Docker启动的进程。 $ ps aux | grep redis-server 999 1099 0.3 1.1 29156 11316 ? Ssl 08:50 0:00 redis-server *:6379 docker top db UID PID PPID C STIME TTY TIME CMD 999 1099 1083 0 08:50 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fb03ea8a196a7295775490d6db94a0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71da44473dae2a9dffa9f4bc258f5aac/" rel="bookmark">
			mysql传统主从配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 主从简介1.1 主从作用1.2 主从形式 2. 主从复制原理3. 主从复制配置3.1 mysql安装3.2 mysql主从配置3.2.1 确保从数据库与主数据库里的数据一样3.2.2 在主数据库里创建一个同步账号授权给从数据库使用3.2.3 配置主数据库3.2.4 配置从数据库3.2.5 测试验证 1. 主从简介 1.1 主从作用 实时灾备，用于故障切换
读写分离，提供查询服务
备份，避免影响业务
1.2 主从形式 一主一从主主复制一主多从—扩展系统读取的性能，因为读是在从库读取的多主一从—5.7开始支持联级复制 2. 主从复制原理 主从复制步骤：
主库将所有的写操作记录到binlog日志中并生成一个log dump线程，将binlog日志传给从库的I/O线程
从库生成两个线程，一个I/O线程，一个SQL线程
I/O线程去请求主库的binlog，并将得到的binlog日志写到relay log（中继日志） 文件中
SQL线程，会读取relay log文件中的日志，并解析成具体操作，来实现主从的操作一致，达到最终数据一致的目的
3. 主从复制配置 主从复制配置步骤：
1 确保从数据库与主数据库里的数据一样
2 在主数据库里创建一个同步账号授权给从数据库使用
3 配置主数据库（修改配置文件）
4 配置从数据库（修改配置文件）
需求：
搭建两台MySQL服务器，一台作为主服务器，一台作为从服务器，主服务器进行写操作，从服务器进行读操作
环境说明：
数据库角色IP应用与系统版本有无数据主数据库192.168.106.16centos8/redhat8mysql-5.7有数据从数据库192.168.106.19centos8/redhat8mysql-5.7无数据 3.1 mysql安装 分别在主从两台服务器上安装mysql-5.7版本，此处略过安装步骤，若有疑问请参考《二进制安装MySQL以及密码破解》
3.2 mysql主从配置 3.2.1 确保从数据库与主数据库里的数据一样 为确保从数据库与主数据库里的数据一样，先全备主数据库并还原到从数据库中
//查看主数据库中有那些库 [root@localhost ~]# mysql -uroot -p'123456' -e 'show databases;' mysql: [Warning] Using a password on the command line interface can be insecure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71da44473dae2a9dffa9f4bc258f5aac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c9911402d8161fba995645a383226b4/" rel="bookmark">
			datawhale课程《transformers入门》笔记5：BERT代码总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何应用 BERT 文章目录 如何应用 BERT1.BERT代码总结：1.1 BertTokenizer（Tokenization分词）1.2 BertModel1.3 BertEmbeddings 1.4 BertEncoder1.4.1 BertAttention1.4.2 BertIntermediate1.4.3 BertOutput 1.5BertPooler1.6 总结 尝试 BERT 的最佳方式是通过托管在 Google Colab 上的 BERT FineTuning with Cloud TPUs。 BERT 代码可以运行在 TPU、CPU 和 GPU。 上一章我们查看 了BERT 仓库 中的代码：
1.BERT代码总结： 1.1 BertTokenizer（Tokenization分词） 组成结构：BasicTokenizer和WordPieceTokenizer
BasicTokenizer主要作用：
按标点、空格分割句子，对于中文字符，通过预处理（加空格方式）进行按字分割通过never_split指定对某些词不进行分割处理是否统一小写清理非法字符 WordPieceTokenizer主要作用：
进一步将词分解为子词(subword)，例如，tokenizer 这个词就可以拆解为“token”和“##izer”两部分，注意后面一个词的“##”表示接在前一个词后面subword介于char和word之间，保留了词的含义，又能够解决英文中单复数、时态导致的词表爆炸和未登录词的OOV问题将词根和时态词缀分割，减小词表，降低训练难度 BertTokenizer常用方法：
from_pretrained：从包含词表文件（vocab.txt）的目录中初始化一个分词器；tokenize：将文本（词或者句子）分解为子词列表；convert_tokens_to_ids：将子词列表转化为子词对应的下标列表；convert_ids_to_tokens ：与上一个相反；convert_tokens_to_string：将subword列表按“##”拼接回词或者句子；encode： 对于单个句子输入，分解词，同时加入特殊词形成“[CLS], x, [SEP]”的结构，并转换为词表对应的下标列表；对于两个句子输入（多个句子只取前两个），分解词并加入特殊词形成“[CLS], x1, [SEP], x2, [SEP]”的结构并转换为下标列表； decode：可以将encode方法的输出变为完整句子。 1.2 BertModel BERT 模型有关的代码主要写在/models/bert/modeling_bert.py中，包含 BERT 模型的基本结构和基于它的微调模型等。
BertModel 主要为 transformer encoder 结构，包含三个部分：
embeddings，即BertEmbeddings类的实体，根据单词符号获取对应的向量表示；encoder，即BertEncoder类的实体；pooler，即BertPooler类的实体，这一部分是可选的。 BertModel可以作为编码器（只有自我注意）也可以作为解码器，作为解码器的时候，只需要在自注意力层之间添加了交叉注意力（应该还要加masked机制，屏蔽未来信息）
BertModel常用方法： get_input_embeddings：提取 embedding 中的 word_embeddings，即词向量部分；set_input_embeddings：为 embedding 中的 word_embeddings 赋值；_prune_heads：提供了将注意力头剪枝的函数，输入为{layer_num: list of heads to prune in this layer}的字典，可以将指定层的某些注意力头剪枝。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c9911402d8161fba995645a383226b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/091b7280d033ec0a5dea60b21f1ea419/" rel="bookmark">
			Verilog RTL代码设计规范简单整理总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1宗旨
2 IP的RTL设计文件的建立
3 TOP集成的设计文件的建立
4 文件头
5 宏定义
6 端口定义
6.1 IP设计中的端口定义
6.2 TOP集成中的端口定义
7 TOP模块的集成
8 参数定义
9 RTL设计文件主体
1宗旨 每个IP设计人员严格遵守一个统一的良好的编码规范，在团队协作方面可以提高代码的可读性和可维护性，可以避免自己日后再次看待代码时的不理解、避免同组人员不必要的不理解、避免IP调用者的不理解、避免后期维护者的不理解，从而提高设计和维护效率；为后来的新人提供可学习的资源，提高代码的可以继承性。可以帮助系统或者软件设计人员在调试复杂系统时发现和分析IP代码所存在的问题；设计者之间可以互相利用各自拥有的IP设计资源，以便于实现IP重用的目标。在工具工作方面用以确保编写的代码能被绝大数仿真和综合工具所接受，确保Verilog RTL模块经综合所产生的门级结构与Verilog仿真器所理解的寄存器传输级的HDL代码的行为是一致的，大大减少代码在不同设计、综合和仿真平台之间移植的工作量。在成本方面，降低系统芯片设计的风险，从而降低设计成本。本规范针对于可综合逻辑部件的Verilog代码文件而编写，包括了对IP的RTL文件的建立、TOP集成文件的建立、文件头、宏定义、端口定义、TOP集成互连信号的定义、参数定义以及模块代码主体的基础规范，适用于大部分RTL编码设计情况。
团队成员或者验收人员发现任何不符合本规范的代码有义务向设计者指出不符合规范的地方，帮助提高代码的规范性。
注意：原则上本规范是普遍适用的，但可能会出现个别意外的情况，例如某工具的局限性，这可能会给本规范中个别条款的实施造成一定的困难。
2 IP的RTL设计文件的建立 1 RTL设计文件的名字必须与模块名完全一致，每个文件只能包含一个模块（module-endmodule），其构成为：设计文件名_文件类型.扩展名。设计文件名即为模块名；文件类型（可选，如Verilog文件可以省去）：_parameter为参数文件；_func为函数文件；_task为任务文件；_define为宏定义文件；_undefine为去宏定义文件；_tb为测试文件。 扩展名：（1）单一的数字Verilog文件（以.v为后缀）；（2）单一的模拟Verilog文件（以.va为后缀）；（3）单一的混合Verilog文件（以.vams为后缀）。因为数字编译器无法处理模拟结构或者混合结构；同时，模拟编译器也无法处理数字结构或混合结构的文件，所以从文件名就能区分三种不同类型的文件可以减少混乱。（注：此文的对象是单一的数字Verilog文件）2 模块名和文件名必须具有唯一性，必须由字母和数字和下划线构成，不允许使用连续的下划线，且必须以字母开头，字母必须全部小写，禁止大小写混用，禁止使用转义字符。（注：设计文件必须和对应的测试文件区分开，测试文件用_tb后缀标明）。 例：viterbi_decoder.v文件
3 TOP集成的设计文件的建立 TOP集成即顶层集成，是将系统的多个功能模块例化在一个文件里，该文件即是TOP集成的顶层文件。集成设计文件的名字必须与TOP模块名完全一致，每个文件只能包含一个模块（module-endmodule），其构成为：设计文件名_top.扩展名。
设计文件名即为TOP模块名建议采用project name或者system name。
模块名和文件名必须具有唯一性，必须由字母和数字和下划线构成，不允许使用连续的下划线，且必须以字母开头，字母必须全部小写，禁止大小写混用，禁止使用转义字符。（注：设计文件必须和对应的测试文件区分开，测试文件用_tb后缀标明）。
例：viterbi_top.v文件
4 文件头 每一个可综合的Verilog RTL级电路模块（也适用于测试模块文件）必须具有规范且统一的文件头，以便于将来可用软件对模块代码进行分析处理，同时也便于建立公司内部的设计信息查询系统。文件头放在文件的最开始的地方，其中必须包含的部分有：
1 使用文件头界限标记。文件头第一行用FHEADER START标明，文件头最后一行用FHEADER END标明。标签FHEADER START和FHEADER END一定要用来定义头信息的界限。这是识别文件头的简单方法，表明该头是文件头，便于用文本工具自动的查询存档的资料。
2 文件头中必须包含文件名，用filename标明。这样有助于用文本处理工具自动的查询相关的设计文件。
3 文件头中必须包含联系方式，包括开发小组的名称、作者名字和邮箱。有助于在需要时可以找到原作者询问从设计文档无法理解的问题。
4 文件头包含发布版本历史（如V0.1）和日期。日期格式必须采用YYY-MM-DD。该信息对于顶层集成者是有用的。但本地的修改历史不应该包含其中。
5 建议文件头包含便于搜索的关键字段。该字段应该包含有关模块功能的简要说明，或是能与本模块配合运行的总线和系统名称。关键字可提供快速的搜索机制，便于自动文本处理工具搜索合适的器件。如果没有关键字，该条目应该空着。
6 文件头必须包含一段描述模块功能的说明，有助于对模块功能的理解。
7 建议文件头包含描述模块代码所使用的参数文件的名字和路径。缺省值必须都在参数文件列出，有效值域也必须标出。有助于对Verilog代码的理解和他人对相应文件的查看。
8 建议文件头包含复位策略，说明是同步复位还是异步复位，是内部复位还是外部上电复位，是硬复位还是软复位，以及该模块是否能用单个复位来调试。改善代码的可读性，突出重点和必须的综合步骤。
9 必须标明可综合能力，综合结构的能力必须以固定的YES或NO标明（如：是否该模块可被用于仿真）。
下面所示的文件头只是最小要求。在reuse issue阶段后，还可以再添加其他的文件头，另外有关版权的文件头也应该包括在文件头中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/091b7280d033ec0a5dea60b21f1ea419/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b292dfeffd09c04d4874ce422f08be9a/" rel="bookmark">
			OpenGL之几何、投影、裁剪、视口变换以及全局变换与局部变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、变换的概念 1.1 图形流水线
1.2 变换（Transformation）
变换主要分为四个步骤，主要就是在Vertex operations阶段操作顶点信息，会在流水线中依次进行。
几何变换投影变换裁剪视口变换 三维模型到二维图形的主要变换过程，注意各种窗口的区别。
投影窗口：是一个虚拟的窗口，与具体的硬件设备无关。视口变换：视口与相关的硬件设备有关。 1.3 OpenGL中变换相关的函数
几何变换：glTranslate、glRotate、glScale，这些函数只是计算一个变换矩阵，然后作为参数设置到图形流水线中。投影：glFrustum()、gluPerspective()、glOrtho();视口变换：glFrustum()、gluPerspective()、glOrtho()，glViewport(); 1.4 几何变换
1.4.1 平移
点P(x,y,z)平移到 P’(x’,y’,z’)，平移向量为T(∆x，∆y，∆z)
x’ = x + ∆x;
y’ = y + ∆y;
z’ = z + ∆z;
表达为向量形式为：P’ = P + T;
表达为矩阵形式：
但是上述矩阵表达并不完美，因此可以将其进行齐次化，使得矩阵的表达结构都变得统一，OpenGL中采用4 x 4 的矩阵来表示。
OpenGL中，在调用平移函数glTranslatef(∆x，∆y，∆z)时，就构造了一个平移矩阵。
1.4.2 缩放
点P(x，y，z)经过缩放得到点P’( x’，y’，z’) ，即乘以一个缩放因子：
x’ = x * S x S_x Sx​；
y’ = y * S y S_y Sy​；
z’ = z * S z S_z Sz​；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b292dfeffd09c04d4874ce422f08be9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c5d4b97ca9d2ae716589c3e2d327707/" rel="bookmark">
			百度地图和高德地图打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 百度地图打印
打印百度地图，先选取打印的范围，支持根据中心，指定宽度和高度，或者使用矩形选择工具框选范围，保存为png格式的图片，然后再使用图片打印。同时也支持百度最新个性地图保存为图片再打印。
工具地址：望远网-百度地图打印
2. 高德地图打印
打印高德地图，支持普通高德地图和个性地图或自定义地图，使用矩形选择工具，选择需要打印的范围，保存为png图片，然后再使用图片打印。
工具地址：望远网-高德地图打印
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/219219568c2710231ecb87a74236b246/" rel="bookmark">
			HTML入门笔记1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是阿凉，一个动漫专业转行前端的小白。从今天开始我会在csdn平台开始分享我的学习笔记以及我的学习心得。
HTML的历史以及发展史 HTML是用来标记Web信息如何展示以及其他特性的一种语法规则，它最初于1989年由CERN的Tim Berners-Lee发明。俗称李爵士， HTML基于更古老一些的语言SGML定义，并简化了其中的语言元素。
HTML起手式 在HTML中，我们首行代码应该是下面这段
&lt;!DOCTYPE html&gt; 我们在HTML学习过程中需要注意的是，代码的大小写，在首行代码中，我们的大小写没有既定的写法，但是上面是首行代码的规范写法。
HTML常用标签 &lt;h1&gt;&lt;/h1&gt;~&lt;h6&gt;&lt;/h6&gt;h1到h6是代码中的标题 &lt;div&gt;&lt;/div&gt;div表示层级分块 &lt;section&gt;&lt;/section&gt;section表示章节 &lt;article&gt;&lt;/article&gt;article表示文章内容 &lt;p&gt;&lt;/p&gt;p表示段落 &lt;head&gt;&lt;/head&gt;head表示代码的头部,通常我们会将一些主要标识内容, 不需要放入HTML网页中的代码放在head中 &lt;body&gt;&lt;/body&gt;body是身体的意思,我们的内容代码会放在body中 &lt;main&gt;&lt;/main&gt;main表示主要内容 &lt;aside&gt;&lt;/aside&gt;aside表示侧边栏 &lt;nav&gt;&lt;/nav&gt;nav表示导航条 &lt;ol&gt;&lt;/li&gt;有序列表 &lt;ul&gt;&lt;/li&gt;无序列表 &lt;strong&gt;&lt;/strong&gt;重点显示内容 &lt;a href="链接"&gt;&lt;/a&gt;a可以放我们需要放入的链接 &lt;img src="图片" alt="图片名"&gt;img可以放入我们需要的图片 HTML全局属性 class
contenteditable
hidden
id
style
tabindex
title
以上是HTML中所有标签都有的属性，这些属性是可以由我们程序员更改的属性
上面的内容就是我关于HTML的学习笔记以及心得，以后的日子里我会不定时的更新关于前端的学习心得以及学习笔记，希望这些可以帮助到大家，也希望我可以在前端的路上越走越远。
结束语：这里阿凉，一个想卷，但卷不起来的小白
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02a5386540782259146b2ae6f2f7e585/" rel="bookmark">
			UE源码阅读[1]---由问题入手UE中的延迟渲染
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
延迟渲染：
问题：
UE渲染部分的起点：
怎么样处理多光源
Gbuffer Layout：
RenderBasePass():
GetGBufferRenderTargets()
BasePassPixelShader.usf
GBuffer布局：
处理同屏不同的光照模型：
基本思路：
ShaderPermutation：
FDeferredLightPS：
延迟渲染： 问题： 1.UE 延迟渲染的Gbuffer是什么样的？
2.怎么样处理多光源
3.怎么样处理同屏不同的光照模型
UE渲染部分的起点： UE的渲染部分从GameEngine.h 和 GameEngine.cpp
voidUGameEngine::Tick( float DeltaSeconds, bool bIdleMode ) { [... ...] //检查设置，比如是否是专属服务器，只有命令行 if (!bIdleMode &amp;&amp; !IsRunningDedicatedServer() &amp;&amp; !IsRunningCommandlet() &amp;&amp; FEmbeddedCommunication::IsAwakeForRendering()) { //渲染窗口/所有物体 RedrawViewports(); // 渲染完之后的回调 GetRendererModule().PostRenderAllViewports(); } [... ...] } //上述的RedrawViewports(); void UGameEngine::RedrawViewports( bool bShouldPresent /*= true*/ ) { SCOPE_CYCLE_COUNTER(STAT_RedrawViewports); CSV_SCOPED_TIMING_STAT_EXCLUSIVE(ViewportMisc); if ( GameViewport != NULL ) { GameViewport-&gt;LayoutPlayers(); if ( GameViewport-&gt;Viewport !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02a5386540782259146b2ae6f2f7e585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d5b8e7fa2220080dfc1ccb10bb95eb6/" rel="bookmark">
			攻克哈希的基本概念与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本定义 哈希表的定义简介：：散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希（Hash）表，函数f(key)为哈希(Hash) 函数。
当然哈希表也有缺点，哈希表是基于数组的，我们知道数组创建后扩容成本比较高，所以当哈希表被填满时，性能下降的比较严重。
例子：：例如大家在上学的时候，大家都会有一个学号「1-n号」中的一个号码，如果我们用哈希表来存放班级里面学生信息的话，我们利用学号作为「键」或者「关键字」，这个「键」或者「关键字」就可以直接作为数据的下标，不需要通过哈希函数进行转化。如果我们需要安装学生姓名作为「键」或者「关键字」，这时候我们就需要哈希函数来帮我们转换成数组的下标。
几个关键点：： 1 冲突 ： 如果要实现一个简单的哈希，例如将一个很大的数映射到一定范围内的数值上，那将不可避免的存在冲突的现象，于是为了解决这种冲突，可以使用一些处理冲突的方法，介绍如下俩种处理冲突的方法： 2 若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。。 存储方法 法一：：开放寻址法： 百度百科上是这样定义的：：1. 开放寻址法：Hi=（H（key）+ di） MOD m,i=1,2，…，k（k≤m-1），其中H（key）为散列函数，m为散列表长，di为增量序列，可有下列三种取法：
1.1. di=1,2,3，…，m-1，称线性探测再散列；
1.2. di=1^2,-1^2,2^2,-2^2，⑶^2，…，±（k）^2,（km/2）称二次探测再散列；
1.3. di=伪随机数序列，称伪随机探测再散列。
2. 再散列法：Hi=RHi(key),i=1,2，…，k RHi均是不同的散列函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。
3. 链地址法（拉链法）
4. 建立一个公共溢出区。。
哈哈，反正我不是很能看得懂，对于初学者，我这样理解就行：： 对于开放寻址法： 通常用到的是查找 ， 插入 操作，删除一般在算法题中很是少见。。 之余开放寻址法 ， 可以通俗的将之看成是一个例子：：一个人去上厕所 ， 他需要找一个坑位， 他于是来到了第一个位置，若是这个位置空的，他就使用这个位置，若是这个位置已经被人占用 或是被损坏（即为读取到了所定义的空值），他只能就去下一个位置寻找坑位了，直到找遍每一个坑位，当然，在使用开放寻址法时，一般为了避免冲突的出现，都会多开所需数据范围的俩倍以上，这样就不可能存在同一个坑位的情况了 （特点总结： 以空间换来了时间）
时间复杂度只需要O（1） 只用开一个一维数组。。。。
所以发现，使用开放寻址法的时候只要写一个函数即可实现，
因为他返回的值如果存在就是他所在的位置，要不h（t）就是空值。。（因为足够大的数据空间保证了肯定存在，除非输入的就是所定义之外的“空值”）
以下如图
（来自acwing平台的算法基础课截图）
由此可以解决题目；；
注意：：开放寻址法这里查询和插入操作均用以下的find函数即可实现，因为它返回的值要么是空，要不就是他存储的位置。。。。 #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; //开放寻址法一般开 数据范围的 2~3倍, 这样大概率就没有冲突了 const int N = 2e5 + 3; //大于数据范围的第一个质数 const int null = 0x3f3f3f3f; //规定空指针为 null 0x3f3f3f3f int h[N]; int find(int x) { int t = (x % N + N) % N; while (h[t] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d5b8e7fa2220080dfc1ccb10bb95eb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d788df36291da2cbc5c9924690c3ac72/" rel="bookmark">
			【译】 Libbpf：初学者指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（原文链接：https://www.containiq.com/post/libbpf）
本文讨论了 libbpf 及其在开发 BPF 工具和应用程序时相对于 BCC 的优势。包括代码示例和入门指南。
BPF 应用程序让工程师可以直接了解操作系统的底层。这些应用程序可以通过内核子系统中的挂钩（hooks）来监控性能和访问资源。
不过，在内核应用程序上工作是一种微妙的平衡。你需要确保在一系列系统上的兼容性，并避免任何过时或弃用的东西。BCC 可以简化该过程，但 libbpf 的优势使其在许多情况下成为更好的解决方案。
在本文中，你将了解 libbpf 与 BCC 的不同之处、如何使用它，以及在你决定进行切换时它提供了什么。我们来看看：
BCC及其问题什么是 libbpf？Libbpf 和 BPF CO-RELibbpf 相对于 BCC 的优势libbpf 是如何工作的？你为什么要使用它？开始使用 libbpf 什么是 BPF？ Berkeley Packet Filter 或BPF最初是一个虚拟机，它允许程序员更安全、更轻松地访问低级内核功能。根据Netflix 工程师 Brendan Gregg的说法，它后来演变成“通用内核执行引擎” 。它确保程序不会崩溃或无限期地运行，这是程序员与操作系统交互方式的重大变化。
BPF 的效率意味着它被用来驱动一些最大的站点。Facebook在每台服务器上运行着 40 多个 BPF 程序，有时多达一百个。
BCC 是使用 BPF 的老牌玩家，而 libbpf 是新来的。
BCC及其问题 BCC 或BPF Compiler Collection使用扩展的 BPF 来更轻松地创建低级程序。C 是一种常见的语言选择，但 Lua、Python、C++ 和 Rust 都是可行的替代方案。
它提供了大量示例和工具以及有用的错误消息，有助于确保你的 BPF 程序是正确的。
但是，BCC 也有缺点。它嵌入编译器组件，例如 Clang，并在运行时编译程序。这需要额外的 CPU 和内存，并且可能会暴露仅在编译程序时出现的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d788df36291da2cbc5c9924690c3ac72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bec91b5a2e55df7433bbdaca83af276/" rel="bookmark">
			C语言函数程序实例(超全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.编写函数fun，功能是：计算n门课程的平均值，计算结果作为函数值返回。 例如，若有5门课程的成绩是：92，76，69，58，88，则函数的值为76.599998。
2. 用函数将一个N阶方阵进行转置，输入输出在主函数中实现。(使用for循环实现)
3.编写函数fun(str,i,n),从字符串str中删除第i个字符开始的连续n个字符。注:str[0]代表字符串的第一个字符)。(使用while循环实现
4.用辗转相除法求两个整数的最大公约数。(使用while循环实现)
5.编写函数fun（n）,函数的功能是求n!。主函数的功能是计算: x!+y!+z! 的值。（同类型题：2!+4!+6!+8!+10! 或者 3!+5!+7!+9!+11!）
6. 用函数将两个字符串连接起来，不允许使用strcat函数。(使用for循环实现)
7.编写函数fun求一个不多于5位的正整数的位数，该数在主函数中输入，并在主函数中输出结果。
8.从键盘为一维整型数组输入10个整数，调用fun函数找出其中最小的数,并在main函数中输出。请编写fun函数。
9.求一批数中小于平均值的数的个数。(使用for循环实现)（同类型题：求一批正整数中最大的偶数或奇数。或者 求一组数中最小的数或者最大的数）
10.学生的记录由学号和成绩组成。N名学生的数据已放入主函数中的结构体数组s中，请编写函数fun：把高于等于平均分的学生数据放在b所指的数组中，高于等于平均分的学生人数通过形参n传回，平均分通过函数值返回。
11.函数fun，其功能是将一个数字字符串转换成与其面值相同的长整型整数。 可调用len求字符串长度。
12. 函数fun，将M行N列的二维数组中字符数据按列的顺序依次放到一个字符串中
13. 函数sort：冒泡法，对数组中的10个数据，从小到大排序，在主函数中输出
14.将字符串中的小写字母转换为对应的大写字母，其它字符不变。
15.编写函数fun生成一个主对角线元素为1，其他元素都为0的3*3的二维数组
16.编写函数求1~100(闭区间)中奇数的平方和。结果为166650
17. 求一批数中最大值和最小值的差。（和、乘积）
18.给定n个数据, 求最小值出现的位置(如果最小值出现多次,求出第一次出现的位置即可)
19. 编写函数fun求1的K次方到N的K次方的累加和
20.编写函数fun，函数的功能是：求给定正整数m(包括m)以内的素数之和。 例如：当m=20时，函数值为77。
21. 编写函数fun，函数的功能是：求一个给定字符串中的字母的个数。(使用for循环实现)
22.编写函数fun，函数的功能是：计算并输出给定整数n的所有因子之和（不包括1与自身）。规定n的值不大于1000。例如：n的值为855时，应输出704。
23. 用函数求fibonacci数列前28项的和。 已知数列的第一项值为1，第二项值也为1，从第三项开始，每一项均为其前面相邻两项的和。运行结果：832039
24. 编写函数fun，函数的功能是：求一分数序列2/1，3/2，5/3，8/5，13/8，21/13…的前n项之和。例如：求前20项之和的值为32.660259
1.编写函数fun，功能是：计算n门课程的平均值，计算结果作为函数值返回。 例如，若有5门课程的成绩是：92，76，69，58，88，则函数的值为76.599998。 #include "stdio.h" float fun(int a[],int n) { int i,sum=0; float ave; for(i=0;i&lt;n;i++) sum=sum+a[i]; ave=sum/n; return ave; } int main() { int a[]={92,76,69,58,88}; printf("y=%f\n",fun(a,5)); } 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bec91b5a2e55df7433bbdaca83af276/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05e52b858efde251d70bbbc11aeebb17/" rel="bookmark">
			win11文件操作卡顿解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：win11资源管理器操作文件时卡顿，光标转圈，鼠标切换文件或全选文件时卡顿非常明显，打开任务管理器-性能，可见windows资源管理器CPU占用高。
解决方案：
（1）WIN+R，输入regedit，打开注册表
（2）打开：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Shell Extensions
（3）如存在Blocked节点，则打开，否则新建项：Blocked
（4）创建字符串，数值名称：{e2bf9676-5f8f-435c-97eb-11607a5bedf7}，数值为空，如图：
（5）重启计算机，打开文件夹，效果变成win10风格，如图，测试卡顿问题解决
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/256/">«</a>
	<span class="pagination__item pagination__item--current">257/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/258/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>