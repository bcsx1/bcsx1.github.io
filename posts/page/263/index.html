<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56dbb4ec3799c17598774fd4354dc588/" rel="bookmark">
			算术移位 VS 逻辑移位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义 逻辑左移（LLS，Logical Left Shift）：低位补零。 逻辑右移（LRS，Logical Right Shift）：高位补零。 算术左移（ALS，Arithmetic Left Shift）：符号位不变，低位补零。 算术右移（ARS，Arithmetic Right Shift）：高位补符号位。 注意：以上4种定义，所有位（包括符号位）要同步移动。 结论 1. 逻辑左移与算术左移完全相同。 2. 正数：逻辑右移与算术右移完全相同。 3. 负数：逻辑右移与算术右移不同。 以上结论从严格从定义上得到。接下来解释一下多数人的疑惑。
疑惑 1. 负数的逻辑左移，明显符号位被移走了，1变成0了呀，负数不就变成正数了吗？为何能和算术左移一样呢？ 首先呢，从定义上看，逻辑左移和算术左移就是一样的，这个问题准确来讲是问为什么这么定义？
其实这是一个常见的误区。我们要注意，计算机是按补码存储的。
假设计算机的位长是4位，1111b（b表示二进制）这个数是几？这个数的实际大小应该是保持符号位不变，其他位取反再加1，那么这个数是-1。
计算机位长4 bit能表示的数值范围为-8 ~ 7,即1000b ~ 0111b，我们只看负数部分：
原值左移1位十进制二级制二级制十进制说明-111111110-2扩大2倍-211101100-4扩大2倍-311011010-6扩大2倍-411001000-8扩大2倍-5101101106溢出，undifined-6101001004溢出，undifined-7100100102溢出，undifined-8100000000溢出，undifined 我们看到，从-5开始，左移1位，全部会溢出。从数值上来看，-5左移1位，应该扩大2倍至-10，但是-10显然超出了4 bit字长计算机的表示范围，也就是溢出，溢出的结果当然是不确定的，不可信。即使你保持符号位不变，4 bit也无法表示出-10。
思考一下，使得我们疑惑的，无非是：次高位如果为0（也就是上表的-5 ~ -8 这些数）左移1位之后会出现符号反转，，非常奇妙的是，这些数左移1位之后恰好全部溢出！
这是巧合吗？
假设计算机位长n bit，那么可表示的负数范围为 -2n-1~ -1 。
如图，将[-2n-1, -1]分成连续的两段：
└─────────────┘ └───────────┘
-2n-1 -(2n-2+1) -2n-2 -1
10 00...0b 10 11...1b 11 00...0b 11 11...1b
第一段 [-2n-1, -(2n-2+1)] 对应次高位为0的情况：
此时左移1位（即乘以2），符号位反转，但是数值上恰好都溢出了。第二段 [-2n-2, -1] 对应次高位为1的情况：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56dbb4ec3799c17598774fd4354dc588/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0827ddf77b7dfbf17b178d05d0a0eb98/" rel="bookmark">
			Python3 使用PyInstaller打包成exe时报错：IndexError:tuple index out of range
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		File "C:\Users\xx\AppData\Local\Programs\Python\Python310\lib\site-packages\PyInstaller\lib\modulegraph\modulegraph.py", line 2645, in _scan_code self._scan_bytecode( File "C:\Users\xx\AppData\Local\Programs\Python\Python310\lib\site-packages\PyInstaller\lib\modulegraph\modulegraph.py", line 2749, in _scan_bytecode for inst in util.iterate_instructions(module_code_object): File "C:\Users\xx\AppData\Local\Programs\Python\Python310\lib\site-packages\PyInstaller\lib\modulegraph\util.py", line 147, in iterate_instructions yield from iterate_instructions(constant) File "C:\Users\xx\AppData\Local\Programs\Python\Python310\lib\site-packages\PyInstaller\lib\modulegraph\util.py", line 139, in iterate_instructions yield from get_instructions(code_object) File "C:\Users\xx\AppData\Local\Programs\Python\Python310\lib\dis.py", line 338, in _get_instructions_bytes argval, argrepr = _get_const_info(arg, constants) File "C:\Users\xx\AppData\Local\Programs\Python\Python310\lib\dis.py", line 292, in _get_const_info argval = const_list[const_index] IndexError: tuple index out of range 解决方案： 1. 找到C:\Users\xx\AppData\Local\Programs\Python\Python310\lib\dis.py文件
2. 打开该文件，修改_unpack_opargs方法，在else分支新增extended_arg = 0
3. 重新执行打包命令，执行成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8efbd39fdac297753e7c0afc6396ff/" rel="bookmark">
			Java Selenium防止被网站检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Java Selenium防止被网站检测（谷歌浏览器） 通过命令打开一个浏览器窗口 进入谷歌浏览器安装目录执行命令 chrome.exe --remote-debugging-port=9222
注意：执行此命令前关闭浏览器所有窗口！！否则将不会生效
编码实现 System.setProperty("webdriver.chrome.driver", "your chrome driver path"); ChromeOptions option = new ChromeOptions(); option.setExperimentalOption("debuggerAddress", "127.0.0.1:9222");//此为固定代码（如果您的端口号不变的情况下） webDriver = new ChromeDriver(option); //隐式等待时间 webDriver.manage().timeouts().implicitlyWait(20,TimeUnit.MILLISECONDS); webDriver.get("web page url"); 优劣说明 优势劣势基本可以躲开绝大多数网站的检测不能使用无头模式（因为必须存在那个已经打开的窗口）http代理将不会生效 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b86f3831398f90ac5eaa639d4e8933d/" rel="bookmark">
			linux内核零拷贝技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 设计思想
零拷贝技术主要用于磁盘数据通过网络进行交互，常见用法卸载磁盘文件从网络发送出去。常规的卸载文件方法流程如下所示。
从上图可以看出软件流程一共复制了4次数据，内核态到用户态切换4次。
读操作（复制两次，上下文切换两次）：
1.用户进程通过 read() 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）
2.CPU利用DMA控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）
3。CPU将读缓冲区（read buffer）中的数据拷贝到用户空间（user space）的用户缓冲区（user buffer）
4.上下文从内核态（kernel space）切换回用户态（user space），read 调用执行返回。
写操作（复制两次，上下文切换两次）：
1.用户进程通过 write() 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）
2.CPU 将用户缓冲区（user buffer）中的数据拷贝到内核空间（kernel space）的网络缓冲区（socket buffer）
3.CPU 利用 DMA 控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。（虽然网络驱动会分层解析网络数据帧，但网络数据是通过sk_buff指针缓存在各个层级进行数据，所以这里网络协议层不存数据拷贝）
4.上下文从内核态（kernel space）切换回用户态（user space），write 系统调用执行返
从上面可以看到用户态和内核态之间数据拷贝流程走了两次，熟悉linux内核调度结构的知道内核态和应用态数据拷贝是比较费时，同时拷贝数据是个冗余过程，仅仅从应用态过了一圈。所以引入了零拷贝技术。
在数据传输的过程中，避免数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间进行拷贝。有的时候，应用程序在数据进行传输的过程中不需要对数据进行访问，那么，将数据从 Linux 的页缓存拷贝到用户进程的缓冲区中就可以完全避免，传输的数据在页缓存中就可以得到处理。在某些特殊的情况下，这种零拷贝技术可以获得较好的性能。Linux 中提供类似的系统调用主要有 mmap()，sendfile() 以及 splice()。
mmap():
和传统的区别就是read操作变成了mmap，之后用户空间会和内核态共享同一块内核缓冲区，读入的数据都在这个内核缓冲区里面。写入的话还是和原来一样。这个函数在linux设计中用的比较多，结合/dev/mem使用可以直接在应用态访问硬件物理地址，或者将文件映射到内存等。
sendfile():
sendfile对于mmap来说更加优化了一步，数据从缓冲复制到到socket直接都是在内核空间一次性完成的，用户空间只是发起了sendfile的调用，减少了复制和上下文切换的开销。这个文件只能针对真正的文件从网络卸载，对于自定义文件系统是不支持的，对于高速存储用的比较少。
splice():
splice又在上面两位前辈的基础上变更更加强大，之前sendfile只能是内核缓冲区向socket复制数据，而splice直接让讷河缓冲区和socket之间建立了一个管道可以直接相互交换数据。
linux零拷贝技术本次采用的mmap+write方式实施，数据走向流程图如下所示。
将内核读缓存通过mmap函数映射到应用态，实现内核态和应用态共享该空间。通过mmap函数后会减少一次数据拷贝，上下文切换不变，但是通过异步设计思想可以规避掉上下文切换耗时。
2 代码设计
在内核态分配20个连续的DMA缓存空间，分别标号为1~20，读磁盘和通过网络发送数据实现异步方式，只要有空余的缓存空间，读线程一直读数据到20个缓存空间中，网络发送线程一直发送数据。读数据和发送数据通过循环队列实现，可以使用互斥锁实现循环队列，也可以使用无锁高效互斥队列。
2.1 mmap函数
zero_copy_vir_addr=mmap(NULL,zero_copy_block_size*zero_copy_block_num,PROT_READ|PROT_WRITE,MAP_SHARED,dev_fd,zero_copy_phy_addr);
if (zero_copy_vir_addr == NULL){
DBG_PRINTF(“%s mmap fail!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b86f3831398f90ac5eaa639d4e8933d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6798b25e72b842bedac6730d324936fe/" rel="bookmark">
			Python获取指定时间内的所有日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里介绍两种获取指定时间内的所有日期的方法，附样例参考。
一种是使用pandas库的date_range方式，使用pandas库的date_range方法生成日期间隔里的所有日期, start, end, periods和freq必须指定三个。
一种是自己定义的方法，获取指定日期内的所有日期，可指定周期, 至少返回两条日期。仅供参考，如果有不完美的地方，欢迎指出。
方法一：
import pandas as pd def get_date_range1(start, end, periods=2, freq='7D', format='%Y-%m-%d %H:%M:%S'): """ 使用pandas库的date_range方法生成日期间隔里的所有日期, start, end, periods和freq必须指定三个 :param start: 起始日期 :param end: 结束日期 :param periods: 周期 :param freq: 时间间隔 :param format: 格式化输出 :return: 日期list """ periods = None if start and end else periods date_list = pd.date_range(start=start, end=end, periods=periods, freq=freq) if len(date_list) &lt; 2: date_list = date_list.union(date_list.shift(1)[-1:]) return [item.strftime(format) for item in date_list] print(get_date_range1("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6798b25e72b842bedac6730d324936fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/736f9d2d70407f886a3a55cd61bf520b/" rel="bookmark">
			超级好用的css属性clip-path；轻松画出各种图形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;style&gt; .box{ position: relative; margin: 0 auto; width: 200px; height: 40px; background: lightblue; clip-path: polygon(0 0,100% 0,70% 50%,100% 100%,0 100%,0 0); } .box::before{ content: 'a'; position: absolute; left: 0; bottom: 0; } &lt;/style&gt; &lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div&gt;从左上角（0% 0%）开始，右下角（100% 100%）结束，画出的图形&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea0b3ee42392f0579f7332562f063820/" rel="bookmark">
			osgb的顶点，纹理，索引，UV读取与存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		virtual void apply(osg::Geode&amp; node) { for (int i = 0; i &lt; node.getNumDrawables(); i++) { osg::Geometry* geometry = dynamic_cast&lt;osg::Geometry*&gt;(node.getDrawable(i)); if (geometry) { //apply(*g); //*********************************************** //解析顶点 osg::Array* vertexArray = geometry-&gt;getVertexArray(); if (vertexArray == NULL) return; //顶点数组 osg::Vec3Array* verts = dynamic_cast&lt;osg::Vec3Array*&gt;(vertexArray); long lVertNum = verts-&gt;size(); std::vector&lt;osg::Vec3 &gt;::iterator iter_ver = verts-&gt;begin(); //遍历顶点值 for (; iter_ver != verts-&gt;end(); iter_ver++) { double x = iter_ver-&gt;x(); double y = iter_ver-&gt;y(); double z = iter_ver-&gt;z(); } //纹理 osg::Texture2D* tex2D = dynamic_cast&lt;osg::Texture2D*&gt;(geometry-&gt;getStateSet()-&gt;getTextureAttribute(0, osg::StateAttribute::TEXTURE)); osg::Image* image = tex2D-&gt;getImage(); osgDB::writeImageFile(*image, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea0b3ee42392f0579f7332562f063820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a3214b59205d416c45861610d144de9/" rel="bookmark">
			（二十三）Flink Table API &amp; SQL 编程指南 Table API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 &amp; 示例 Table API 支持 Scala, Java 和 Python 语言。Scala 语言的 Table API 利用了 Scala 表达式，Java 语言的 Table API 支持 DSL 表达式和解析并转换为等价表达式的字符串，Python 语言的 Table API 仅支持解析并转换为等价表达式的字符串。
下面的例子展示了 Scala、Java 和 Python 语言的 Table API 的不同之处。表程序是在批环境下执行的。程序扫描了 Orders 表，通过字段 a 进行分组，并计算了每组结果的行数。
Java 的 Table API 通过引入 org.apache.flink.table.api.java.* 来使用。下面的例子展示了如何创建一个 Java 的 Table API 程序，以及表达式是如何指定为字符串的。 使用DSL表达式时也需要引入静态的 org.apache.flink.table.api.Expressions.*。
import org.apache.flink.table.api.*; import static org.apache.flink.table.api.Expressions.*; EnvironmentSettings settings = EnvironmentSettings .newInstance() .inStreamingMode() .build(); TableEnvironment tEnv = TableEnvironment.create(settings); // 在表环境中注册 Orders 表 // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a3214b59205d416c45861610d144de9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/150bad8276406157f3ad528ec911ed06/" rel="bookmark">
			华为ensp配置aaa认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步，搭建如下拓扑图。
第二步，点击连接
sys 进入系统视图
user-int console 0 进入console 0 口也就是登录接口。
authentication-mode aaa 设置身份验证为aaa
aaa 直接进入aaa视图界面
local-user king password cipher 123 创建一个为king用户，（密文）密码为123
local-user king privilege level 3 设置运行级别为3（最大权限）
quit 退回到上一级。
username king 账户
password 123 密码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cdcca768f62dc0fd4dd2c2d8064587d/" rel="bookmark">
			Linux网络设备驱动分析，以W5300以太网驱动为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文是笔者在分析Linux网络驱动时记录的笔记，在这里分享给大家。因为笔者目前也属于学习阶段，因此可能会存在分析不清楚甚至分析错误的地方，欢迎大家评判指正！！
版本说明 Linux内核版本：4.1.15
驱动源码路径：drivers/net/ethernet/wiznet
设备私有数据 在分析驱动之前，需要先了解一下W5300自定义的私有数据w5300_priv都有哪些内容
struct w5300_priv { void __iomem *base; //内存基地址 spinlock_t reg_lock; //自旋锁 bool indirect; //是间接读写还是直接读写 u16 (*read) (struct w5300_priv *priv, u16 addr); //读函数 void (*write)(struct w5300_priv *priv, u16 addr, u16 data); //写函数 int irq; //中断号 int link_irq; //连接检测中断，当有新连接或者连接断开触发此中断 int link_gpio; //连接检测IO struct napi_struct napi; //napi_struct，此驱动使用NAPI struct net_device *ndev; //网络设备结构体指针 bool promisc; //混杂接收模式标志 u32 msg_enable; }; 驱动入口和出口 static SIMPLE_DEV_PM_OPS(w5300_pm_ops, w5300_suspend, w5300_resume); static struct platform_driver w5300_driver = { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cdcca768f62dc0fd4dd2c2d8064587d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61f2f95fd7da14fdca6067c8deca1ff3/" rel="bookmark">
			npm常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装包 npm install &lt;package&gt; 安装包，默认会安装最新的版本 npm install &lt;package&gt;@&lt;version&gt; 安装指定版本的包 npm install &lt;package&gt; --save-dev npm install &lt;package&gt; -D 安装包并将安装包信息将加入到devDependencies（开发阶段的依赖），所以开发阶段一般使用它 npm install &lt;package&gt; --save npm install &lt;package&gt; -S 安装包并将安装包信息将加入到dependencies（生产阶段的依赖） npm install &lt;package&gt; --global npm install &lt;package&gt; -g 全局安装包 卸载包 npm uninstall &lt;package&gt; --save-dev npm uninstall &lt;package&gt; -D 卸载开发版本的包 npm uninstall &lt;package&gt; --save npm uninstall &lt;package&gt; -S 卸载生产版本的包 npm uninstall &lt;package&gt; 卸载包 npm uninstall &lt;package&gt; --global npm uninstall &lt;package&gt; -g 全局卸载包 更新包 npm update 更新包，将包更新到最新版本 npm update &lt;package&gt; 更新指定包 npm update -g 更新全局包 npm update -g &lt;package&gt; 更新指定的全局包 npm outdated [-g] 列出所有已经过时的包，可以及时进行包的更新 查看安装的包 npm ls 查看安装的模块及依赖 npm ls -g 查看全局安装的模块及依赖 初始化项目 npm init [-f|--force|-y|--yes] 查看某条命令的详细帮助 npm help &lt;term&gt; [&lt;terms.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61f2f95fd7da14fdca6067c8deca1ff3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/262ca5164fa91bfabfd1f3800cee2206/" rel="bookmark">
			关于MyBatis的Example类详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Example类的定义？
mybatis-generator会为每个字段产生Criterion，为底层的mapper.xml创建动态sql。如果表的字段比较多,产生的example类会十分庞大。理论上通过example类可以构造你想到的任何筛选条件。在mybatis-generator中加以配置，配置数据表的生成操作就可以自动生成example了。 mybatis 的mapper接⼝提供了增、删、改、查的⽅法。避免过多使⽤xml来直接写sql。
实体类 User： private Integer id; private String name; private String age; private Integer sex； Example类的使用： Example examle = new Example(User.class); example.setOrderByClause("字段名 asc,字段名 desc"); //去除重复，boolean 型，true 为选择不重复的记录。 example.setDistinct(false); Criteria criteria = new Example().createCriteria(); is null;is not null; equal to(value);not equal to(value); GreaterThan(value);GreaterThanOrEqualTo(value); LessThan(value); LessThanOrEqualTo(value); in(item,item,item,...);not in(item,item,item,...); like("%"+value+"%");not like("%"+value+"%"); Between(value1,value2);not between(value1,value2); Mybatis的实例函数：
返回值类型方法功能说明int countByExample(UserExample example) throws SQLException按条件计数int deleteByPrimaryKey(Integer id) throws SQLException按主键删除int deleteByExample(Example example) throws SQLException按条件删除String / Integer insert (User user) throws SQLException 插⼊数据(返回值为ID) User selectByPrimaryKey(Integer id) thorws SQLException按主键查询 List&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/262ca5164fa91bfabfd1f3800cee2206/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/883cbebb8a47094761a47ef4b3a5e1a0/" rel="bookmark">
			如何通过Charles&#43;BurpSuite的配合在PC端抓到手机包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		渗透测试工作记录 文章目录 渗透测试工作记录前言一、Charles是什么？二、实现步骤（以Mac端抓包IOS微信小程序为例）1.在Charles下设置代理的端口2.分别在PC端和手机端安装证书3.关闭macOS代理，打开外部代理4.配置外部代理5.打开burp6.让Charles能解析https的包 总结 前言 在我日常的渗透测试工作中，用的最多的软件就是Burp Suite，我觉得它功能多样，界面清晰简洁，即使是之前完全没接触过这类软件的人也可以很快上手，所以实际上在刚入行的时候我根本就没再去学去用什么其他的软件了。但随着测试的系统越来越多，我发现有时会遇到在Burp Suite中抓不到包的问题！我现在也不知道这种情况产生的原因，只知道在burp里抓不到包就无法进行常规的测试操作，令我这个菜鸟感到非常着急（唉~
目前遇到过两种抓不到包的情况：一是微信小程序，二是测试APP的时候在进入APP和登录时都可以正常抓到包，但偏偏进了需要测试的功能点之后就抓不到包了。
听大佬说，要用“全局代理”，要用“花瓶”……虽然不是很懂但是去安装了Charles并学了一下怎么使用，然后顺利在burp中抓到了包，在这里记录一下以备未来如果忘记了可以翻一翻。
本文仅简单记录了在一次渗透测试工作中，通过借助Charles来解决burp中抓不到包的问题的配置步骤，不涉及Charles的具体功能介绍和如何安装等内容。
一、Charles是什么？ Charles 是在PC端常用的网络包截取工具，Charles 通过将自己设置成系统的网络访问代理服务器，使所有的网络访问都要经过它，从而实现了对网络包的截取和分析。
有关Charles比较全面的介绍和使用方法可以参考别人的这篇文章：https://www.jianshu.com/p/dd6a24f0c73d
PS：看了Charles的使用方法之后，我感觉Charles好像和burp的功能差不多啊，但是界面和操作方法似乎不如burp来的简洁，所以才没有burp那么出名吗？
二、实现步骤（以Mac端抓包IOS微信小程序为例） 1.在Charles下设置代理的端口 点击Charles窗口内上部工具栏图标的最后一个（Settings），点击弹出菜单中的Proxy Settings，填入代理端口 8888（或者自定义，但不能和系统已占用端口冲突），并且勾上“Support HTTP/2”和 “Enable transparent HTTP proxying”，点击右下角OK即可。
2.分别在PC端和手机端安装证书 先给PC端安装证书，点击位于屏幕顶端的菜单栏的Help，找到SSL Proxying，选择Install Charles Root Certificate按照提示就可以下载安装上。接下来是要把证书设置成信任（这很关键！方法在下面）。
安装PC端证书之后，在Mac的“钥匙串访问”（安装证书时“钥匙串访问”应该会自己弹出来）的左侧点击“系统”，从显示已安装证书的列表里找到Charles的证书，在证书位置点击鼠标右键，在出现的菜单中点击“显示简介”，展开窗口中的“信任”一栏，设置为“始终信任”。
再给手机端安装证书，步骤如下：
1.还是点击位于屏幕顶端的菜单栏中的Help并找到SSL Proxying，这一次选择有on a Mobile Device的这一项。
2.点击后会弹出窗口提示设置的方法，按照提示在手机端将代理设置为电脑的ip:8888，这里要先确保手机和电脑连接同一个无线网络。然后在手机的浏览器打开http://chls.pro/ssl，按提示下载证书即可。
3.下载证书之后同样很关键的步骤就是要设置证书为信任。在手机的设置-&gt;通用-&gt;关于本机-&gt;(滑到最下面找到）证书信任设置-&gt;找到并打开Charles Proxy CA的开关。
3.关闭macOS代理，打开外部代理 点击位于屏幕最上方菜单栏右侧的小花瓶logo，在下拉菜单中去掉macOS Proxy的勾选，再勾选上External Proxy Servers，如下图1。如果这里勾选了macOS Proxy，就是打开了本机的本地全局代理，相当于手动进行了操作：网络偏好设置-&gt;高级-&gt;代理-&gt;勾选上本地的http和https代理，如下图2。因为这里我是想在PC端抓手机端的包，所以没必要打开电脑的本地代理，但后面是要将Charles作为手机端的代理，再由Charles将包转发给burp，所以对于Charles来说，burp就成了一个“External Proxy Server”。（个人理解不一定对
PS：上图的本机http、https代理实际上在这里是不需要勾选的哈！
4.配置外部代理 点击屏幕顶端的Charles菜单栏中的Proxy，从下拉菜单中找到External Proxy Settings，勾选http和https代理，这里http和https的代理服务器地址都是127.0.0.1:8080.
5.打开burp 已经设置了外部代理了，就必须打开burp（当然了主要是要打开burp中对127.0.0.1:8080的监听），否则就会出现“连不上网了”的现象。在burp的菜单栏中的Proxy选项下的Options中打开127.0.0.1:8080的代理监听（默认应该是已经打开的），在Intercept中关闭请求拦截。
6.让Charles能解析https的包 完成上面的配置步骤后，从手机上打开微信小程序，登录并进入功能点，应该已经可以在Charles窗口左侧的列表中找到想抓的包。在想抓的https包的url处右击选择Enable SSL Proxying。这一步非常重要，因为我曾经不知道这一步骤然后burp中依然抓不到包……
以上都完成后，再访问在手机端微信小程序中想要测试的功能点，此时burp中应该就可以抓到包了。
总结 以上就是今天要记录的内容。这里一定要注意的事情有：
1.PC端和手机端都需要安装burp证书和Charles证书，并且打开信任。
2.点击位于屏幕顶部右侧的Charles小花瓶logo，取消macOS Proxy的勾选，勾选上External Proxy Servers。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/883cbebb8a47094761a47ef4b3a5e1a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/768d2ad8924106b17eec86b7f482bdab/" rel="bookmark">
			BridgeWebView使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 当我们采用H5与Native原生结合开发，使用H5去开发一些功能的时候，肯定会涉及到Android与Js互相调用的问题，通常有两种实现方式，
第一种使用原生的addJavascriptInterface()来解决
第二种使用第三方框架WebViewJavascriptBridge 这也是我今天要分享的部分
为什么要使用WebViewJavascriptBridge 对于安卓开发有一段时间的人来说，知道安卓4.4以前谷歌的webview存在安全漏洞，网站可以通过js注入就可以随便拿到客户端的重要信息，甚至轻而易举的调用本地代码进行流氓行为，谷歌后来发现有此漏洞后，增加了防御措施，如果要是js调用本地代码，开发者必须在代码中申明JavascriptInterface，
列如在4.0之前我们要使得webView加载js只需如下代码：
mWebView.addJavascriptInterface(new JsToJava(), "myjsfunction"); 4.4之后调用需要在调用方法加入加入@JavascriptInterface注解，如果代码无此申明，那么也就无法使得js生效，也就是说这样就可以避免恶意网页利用js对安卓客户端的窃取和攻击。
但是即使这样，我们很多时候需要在js记载本地代码的时候，要做一些判断和限制，或者有可能也会做些过滤和对用户友好提示，因此JavascriptInterface也就无法满足我们的需求了，特此有大神就写出了WebViewJavascriptBridge框架。
开始使用 第一步.Android Studio 导包
repositories { // ... maven { url "https://jitpack.io" } } dependencies { compile 'com.github.lzyzsd:jsbridge:1.0.4' } 第二步.在布局文件中添加
&lt;com.github.lzyzsd.jsbridge.BridgeWebView android:id="@+id/wv_web_view" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; 第三步.代码中添加交互方法
H5调android方法
//android端代码 mWebView.registerHandler("test", new BridgeHandler() { @Override public void handler(String data, CallBackFunction function) { function.onCallBack("指定Handler收到Web发来的数据，回传数据给你"); } //H5端代码
function test() { //调用本地java方法 //第一个参数是 调用java的函数名字 第二个参数是要传递的数据 第三个参数js在被回调后具体执行方法，responseData为java层回传数据 var data='发送消息给java代码指定接收'; window.WebViewJavascriptBridge.callHandler( 'test' ,data , function(responseData) { bridgeLog('来自Java的回传数据： ' + responseData); } ); } 或者
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/768d2ad8924106b17eec86b7f482bdab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33186bd55f45520dab7276621f845e77/" rel="bookmark">
			page.route获取当前页面路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个是官方文档给出的方法 当时我就去项目内去使用了 ，但是当我写下代码之后 页面就报错了
//错误代码示例 let pageInfo = page.route let pageinfo = this.page.route let pageinfo = page.route() 三行代码 我全试了一遍，对于我这种比较小白的人来说 ，官方不给出使用示例，我都不知怎么用啊。
最后通过打印 this 找到了实例的方法属性
最终的代码应该书写为
//正确获取书写方式 let pageInfo = this.$mp.page.route 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff22bcaa8a74a654ba9d4dfce963aff8/" rel="bookmark">
			数据分析：大数据时代的必备技能之Power BI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 商业智能分析概述与流程一、BI概述与流程前言什么是 BI ？什么是可视化？ BI可视化步骤 二、Microsoft Power BI介绍与安装1. 介绍2. Power BI特点3. Power BI 应用模式 及组件4. Power BI组件5.Power BI安装 产品销售数据分析与可视化一、产品销售数据分析1. 新建项目及数据源准备2. 数据建模--关系图(1)、关系介绍和关系视图(2)、关系模型布局(3)、创建、编辑、删除关系 3. 练习创建星型模式数据模型 二、产品销售数据分析1. 数据预处理-DAX2. DAX书写规则(1)、日期格式转化(2)、在销售表中得到产品单价数据(3)、销售表金额汇总(4)、得到每个门店销售额(5)、为门店设定销售目标(6)、计算门店销售完成率 三、产品销售可视化1. 仪表图2. 多行卡3. KPI图4. 切片器5. 地图6.视图整体布局 四、常见数据可视化视觉对象1. 数据可视化原则2. 柱形图3. 簇状柱形图4. 条形图5. 堆积条形图7. 折线图8. 面积图9. 组合图10. 功能区图表11. 饼图12. 环形图13. 散点图 案例分析一、职业教育经营分析看板二、电子商务公司年终复盘三、餐饮数据分析与可视化四、产品与客户销售数据分析 商业智能分析概述与流程 一、BI概述与流程 前言 什么是 BI ？什么是可视化？ 商业智能（ Business Intelligence ，简称：BI ），指用现代数据仓库技术、线上分析处理技术、数据挖掘和数据展现技术进行数据分析以实现商业价值(运用一定的技术，进行数据分析，创造商业价值)。
可视化（Visualization），是指利用计算机图形学和图像处理技术，将数据转换成图形或图像在屏幕上显示出来，从而清晰、有效的传达与沟通信息(通过图表传达信息）。
某地旅游可视化大屏
电商可视化大屏
新媒体可视化大屏
BI可视化步骤 1.明确需求2.确定指标体系3.可视化布局4.具体实现并配色 二、Microsoft Power BI介绍与安装 1. 介绍 Microsoft Power BI 是微软2015年推出的自助式BI工具，在中国分为国际版和国内版两个版本。对于Power BI的作用，微软官方给出的解释如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff22bcaa8a74a654ba9d4dfce963aff8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c4f2343ecb9b83d85f18a0fe4c3703b/" rel="bookmark">
			数据分析Power BI案例：产品与客户销售数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、产品与客户销售数据分析1. 新建项目及数据源准备 二、数据预处理1. 产品表预处理2. 员工表预处理3. 销售表预处理4. 计算实际业绩（1）方案1（2）方案2 5. 计算总业绩 三、产品与客户销售数据可视化目标完成1. 显示员工平均业绩达成率2. 显示销售门市计数3. 按月统计销售金额4.显示销售总金额数据5.不同客户销售额占比6.员工业绩达成情况分析7.构建日期切片器8.分析不同季度产品销售情况9.不同门市销售数据分析10.不同产品销售分析11.地图显示位置 四、数据交互效果五、其他数据可视化视觉对象1.获取练习数据2.漏斗图-转化率分析3.帕累托图分析1-旅游公司人群分组情况分析4.帕累托图分析2-客户满意度调查分析5.问答 一、产品与客户销售数据分析 1. 新建项目及数据源准备 本节课我们以产品与销售数据表.xlsx文件作为数据源，实现一个简单的Power BI项目
打开Power BI Desktop，从登录界面或文件选项选择“获取数据”，选择从“Excel”导入，点击连接，找到产品与销售数据表.xlsx文件并打开。选中两个sheet表，然后点击加载数据。ctrl+s保存为财务数据分析.pbix文件。
二、数据预处理 进入Powerbi Query 编辑器
1. 产品表预处理 2. 员工表预处理 1、将第一行用作标题 2、拆分列 3、对列进行重命名 4、新增一列为业绩达成率，加百分比，小数点后保留两位 3. 销售表预处理 1、销售表中新增一列为金额。统计每行销售数据的金额 2、新增一列为月份 4. 计算实际业绩 方案1：在excel里面计算：当前文件复制一份为产品与销售数据表 - 副本 计算单价，计算金额，数据透视表统计每个员工总业绩 方案2：在powerbi里面计算 （1）方案1 （2）方案2 5. 计算总业绩 1、新建的列会存储在表中，会占用内存，如果再数据庞大的表中添加列，会影响模型运算速度。 2、新建的度量值只是一个标签，以公式形式存储，不使用时不操作数据，基本不占内存，使用更加灵活。 3、在实际工作中，对于某一个数据对象的属性类信息，一般使用列来完成；通过运算得到值的结果，一般使用度量值来完成；能用度量值来解决的问题，就不用新建列。 三、产品与客户销售数据可视化 目标完成 1. 显示员工平均业绩达成率 2. 显示销售门市计数 3. 按月统计销售金额 4.显示销售总金额数据 5.不同客户销售额占比 6.员工业绩达成情况分析 7.构建日期切片器 8.分析不同季度产品销售情况 9.不同门市销售数据分析 10.不同产品销售分析 11.地图显示位置 四、数据交互效果 以客户维度，地区维度，员工维度，时间维度，达到数据整体的联动效果 五、其他数据可视化视觉对象 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c4f2343ecb9b83d85f18a0fe4c3703b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc4a3fe1b34f1b0fece8909794ca692b/" rel="bookmark">
			人工智能——CIFAR10 图像识别问题的卷积神经网络实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import urllib.request import os import tarfile url = "http://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz" filepath = "D:/AI/data/CIFAR-10/cifar-10-python.tar.gz" if not os.path.isfile(filepath): result = urllib.request.urlretrieve(url, filepath) print("Download: ", result) else: print("Data file already exists!") if not os.path.exists("D:/AI/data/CIFAR-10/cifar-10-batches-py"): tfile = tarfile.open("D:/AI/data/CIFAR-10/cifar-10-python.tar.gz", "r:gz") result = tfile.extractall("D:/AI/data/CIFAR-10/") print("Extracted to D:/AI/data/CIFAR-10/cifar-10-batches-py/") else: print("Directory already exists!") Data file already exists!
Directory already exists!
import numpy as np import pickle as p def load_CIFAR_batch(filename): with open(filename, "rb") as f: data_dict = p.load(f, encoding = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc4a3fe1b34f1b0fece8909794ca692b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/003ea9f8959248871b5acf21a76279b2/" rel="bookmark">
			Linux-零拷贝技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“零拷贝”，这名字一听就很厉害。
在看宋宝华老师的一篇吃瓜文章种，看到了这个逻辑，于是去搜索记录整理，其实东西都是东一搜西一搜搞到的，其中比较好的两篇文章：
一文彻底揭秘linux操作系统之「零拷贝」！ - 知乎
linux内核零拷贝技术_HeroKern的博客-CSDN博客_linux 零拷贝
这篇文章里面引用了很多两位的内容，大家可以去看下原著，下面内容是自己的笔记记录。
简介：
零拷贝：
[1] DMA传输可以不经过CPU copy从一个硬件传递到另一个硬件中
为啥不直接在两个硬件中传递呢？
答：从后面的例子来看，这的传递并不能满足涉及，有的时候需要对数据的操作，比如socket传输中在kernel buffer中会增加一个buffer的size和位置信息，再copy到socket上。
由此引出问题：这个中间的操作是必须的吗？假如经过kernel不可以吗？
答：自己思考，像是硬盘和socket，并不是挂在一个总线上，两个设备之间的信息传序，必须得经过kernel作为中间人来转换传输。后面再思考下吧。
[2] 零拷贝是：当用户空间发起调用，将一个数据从硬件1（硬盘）中读取然后再发送到硬件2（网口缓存）中，这个过程可以简化为：硬件1直接通过DMA传递到内核空间中，再经过DMA传递到硬件2上，这样就不用发生CPU copy了。
1、零拷贝是什么？ "零拷贝"中的"拷贝"是指操作系统在I/O操作中,将数据从一个内存区域复制到另外一个内存区域，而"零"并不是指0次复制, 更多的是指在用户态和内核态之间的复制是0次。
零拷贝是指的在用户与内核空间之间的复制的次数是0，那么如果不用零拷贝的话，复制的次数是几呢？如下面的例子：
例子：
从上图可以看出软件流程一共复制了4次数据，内核态到用户态切换4次。
读操作（复制两次，上下文切换两次）：
1.用户进程通过 read() 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）
2.CPU利用DMA控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）
3。CPU将读缓冲区（read buffer）中的数据拷贝到用户空间（user space）的用户缓冲区（user buffer）
4.上下文从内核态（kernel space）切换回用户态（user space），read 调用执行返回。
写操作（复制两次，上下文切换两次）：
1.用户进程通过 write() 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）
2.CPU 将用户缓冲区（user buffer）中的数据拷贝到内核空间（kernel space）的网络缓冲区（socket buffer）
3.CPU 利用 DMA 控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。（虽然网络驱动会分层解析网络数据帧，但网络数据是通过sk_buff指针缓存在各个层级进行数据，所以这里网络协议层不存数据拷贝）
4.上下文从内核态（kernel space）切换回用户态（user space），write 系统调用执行返
从上面可以看到用户态和内核态之间数据拷贝流程走了两次，熟悉linux内核调度结构的知道内核态和应用态数据拷贝是比较费时，同时拷贝数据是个冗余过程，仅仅从应用态过了一圈。所以引入了零拷贝技术。
这个例子和下面的例子是重复的，但是放在这里可以更好的描述一下多次拷贝的情况。同时里面的描述也可以做为一个基础参考，可以先看仔细看看这个例子。
2、零拷贝给我们带来的好处 • 减少甚至完全避免不必要的 CPU 拷贝，从而让 CPU 解脱出来去执行其他的任务；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/003ea9f8959248871b5acf21a76279b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6ba0d541f483d9017aeec8ea513be1e/" rel="bookmark">
			vue中的：__ob__: Observer无法取出数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述：
vue中某个数组可以打印出数据，却无法取出；
原因：
_ ob _: Observer是 Vue 对数据监控添加的属性，不可枚举和遍历
解决办法：
将数组转为普通数组，再将数组里边的对象转为普通对象。代码如下
console.log(data) this.list = [] const newarr = Object.assign([], data).map(item =&gt; { return Object.assign({}, item) }) newarr.forEach((item) =&gt; { if (item.coItemCode !== '' &amp;&amp; item.coItemCode !== null) { getCoItemList({ coItemName: '', coItemCode: item.coItemCode, coItemSpec: '' }, this.pageOfItem).then((response) =&gt; { this.list.push(response.data.data[0]) }) } }) 打印结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c3dd68471385d7d12ce3c0d726853bb/" rel="bookmark">
			adb和frida的一点简单使用记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、手机端安装frida-server二、使用frida测试手机app总结 前言 仅记录一下今天新学的一点adb和frida的使用。
因为上个月已经在pc端安装过adb和frida，而且我其实忘记是怎么安装的了……所以如果本文被想学安装的人看到了就实在不好意思啦，可以找找其他人的博客。
不过，当时安装的时候，我是M1的MacBook Pro，安装macOS-arm64版本反而不成功，安装macOS-x86_64却安装成功了……
一、手机端安装frida-server 前提是电脑上已经有了adb，frida-server已经下载到了电脑上，用数据线连接了电脑和手机。
附frida下载地址：https://github.com/frida/frida/releases
一开始还不太会用，记得之前看过别人的博客里使用adb push命令时手机端目录有用/sdcard的，就用了/sdcard：
adb push frida-server-15.1.17-android-arm64 /sdcard 等待完成：
然后就是去手机的目录下找到frida并运行了：
（我用的手机是adb root的手机，所以先输入一条adb root命令再adb shell）
adb root adb shell cd /sdcard ./frida-server-15.1.17-android-arm64 结果提示permission denied，上网一查得知要chmod一下，结果还是不行，一样提示permission denied。
然后知道是一开始放的目录不行！不能就这样随便地放/sdcard下面，要放在/data下面，而且后来再去看别人教程一般是/data/local/tmp，我当时就偷懒直接把文件转移到/data下了：
mv ./frida-server-15.1.17-android-arm64 /data/ cd /data chmod 777 frida-server-15.1.17-android-arm64 ./frida-server-15.1.17-android-arm64 (运行服务器之前还是要先chmod一下）
完成
二、使用frida测试手机app 1.输入frida-ps -U
查看一下是否正常回显内容
2.输入objection -g com.iss.xxx explore测试注入攻击（这里我之前已经通过pip3安装了objection，xxx是为了保护隐私，根据自己测试的app情况而定）回显如下：
3.输入android hooking list classes进行hook
结果就不贴了
总结 以上就是今天要记录的所有内容了。还不明白今天都学了什么，只是记录一下能用的命令。继续加油！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d846217db79e31e69e6eb7928760959/" rel="bookmark">
			VUE手写横向轮播图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提：自己封装的轮播图，暂时没测出bug，有优化方案欢迎留言~
效果如下图，一行三个，点击上一张/下一张 向前或向后移动一格,窗口缩放会适当变形，不影响切换
&lt;template&gt; &lt;div class="swiper-template"&gt; &lt;div class="my-swiper-page"&gt; &lt;div class="page-left"&gt; &lt;span&gt;{{ activeIndex + 1 }}&lt;/span &gt;/{{ swiperList.length }} &lt;/div&gt; &lt;/div&gt; &lt;div class="my-swiper-container" v-show="swiperList.length"&gt; &lt;div class="my-swiper-wapper"&gt; &lt;div class="arrow imgLeft" @click="clickLeft"&gt; &lt;span class="el-icon-arrow-left"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="arrow imgRight" @click="clickRight"&gt; &lt;span class="el-icon-arrow-right"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div ref="swiperDom" class="my-swiper-content"&gt; &lt;ul ref="swiperDomUI" :style="ulStyle"&gt; &lt;li v-for="(item, index) in swiperList" :key="item.id" class="" :style="{ width: liWidth + 'px' }" ref="liDom" @click="changeIndex(item, index)" &gt; &lt;div class="introduce-li-box" :class="index === activeIndex ? 'active' : ''"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d846217db79e31e69e6eb7928760959/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2206cfd3e0ab135df731093bf9ce203f/" rel="bookmark">
			从零开始安装搭建win10与ubuntu20.04双系统开发环境——集安装、配置、软件、美化、常见问题等于一体的——超详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 **前言 **关于系统安装配置与软件安装一、Win10安装ubuntu20.04双系统1.按照自己的需求分区2.配置软件镜像源软件包管理工具介绍更换APT源——使用国内镜像 3.解决win10与unbuntu20.04系统时间相差8小时的问题如何解决呢？But Why？ 4.修改双系统启动项为win10默认启动 二、chrome浏览器与代理配置安装chrome配置代理1.ubuntu系统代理（全局代理）2.chrome中配置代理 三、配置开发环境1.Java与MavenJava JDKMaven 2.Anaconda安装与配置3.Node.js与npm下载安装编辑用户环境变量测试是否生效 4.Git 四、常用软件安装1.百度网盘2.~~网抑云~~ 网易云音乐**需要注意的是：** 3.文本编辑器Vim4.deepin-wine与QQ、微信、QQ音乐等软件首先介绍一下wine和Deepin-wine：现在让我们通过deepin-wine安装QQ等应用 5.安装Typora并使用Picgo配置gitee图床6.输入法安装（1）安装搜狗输入法添加ubuntukylin源安装搜狗输入法设置默认输入法题外话其一：如果使用安装包dpkg安装时缺少依赖题外话其二：由于安装搜狗拼音导致启动ubuntu登录用户之后黑屏 （2）安装anthy日语输入法添加PPA源，安装anthy 7.WPS与字体安装安装WPS安装字体新建字体存放目录拷贝字体到window-font下修改权限，并更新字体缓存 8.VS code9.关于JetBrains全家桶 关于系统界面美化一、关于themes和icons主题的组合使用自定义修改主题模板的样式 二、关于扩展组件 **前言 ** Ubuntu是一个基于Debian发行版和Gnome桌面环境，以桌面应用为主的Linux操作系统。相较于RHEL、CentOS、Fedora等发行版，Ubuntu似乎更适合已经熟悉Windows系统的用户入门Linux，日常使用也更为方便。
Ubuntu 20.04 LTS在今年（2020年）4月23日发布。LTS(Long Term Support)是指长期演进版，Ubuntu会对这一版本的支持时间更长。
正好最近饱受win10频繁卡顿的困扰，于是时隔一年多我又装回了ubuntu系统。所以在这里记录一下ubuntu20.04安装与环境搭建的过程。很久没写过如此长篇的文章了，文中所有内容都是根据我的需求进行安装和配置，大家按自己的需要查看就行。
关于系统安装配置与软件安装 一、Win10安装ubuntu20.04双系统 关于这一部分，包括U盘启动盘制作，硬盘分区，双系统安装等内容，百度上已经有很多文章，只需要搜索“win10安装ubuntu20.04双系统”,"win10 unbuntu双系统“等关键词即可。
这里提供几篇可以参考的文章：
【Linux基础】Windows10安装Ubuntu20.04双系统
win10安装ubuntu20.04双系统
windows10安装ubuntu双系统教程（绝对史上最详细）
这里有两点可以简单提一下：
1.按照自己的需求分区 因为是双系统，win10对我来说还是比较常用，所以我只能将60G分配给Ubuntu，我的分区如下所示（这里文件系统我都选择使用ext4，也可根据需要选择ext3、xfs等）：
大小类型空间类型20Gext4/primary（主分区）8Gswap交换空间logical（逻辑分区）512Mext4/bootlogical（逻辑分区）剩余空间（这里接近30G）ext4/homelogical（逻辑分区） 其中：
/ :根目录，是linux的系统分区，ubuntu安装在这个分区下，类似于windows的C盘。一般至少预留20G以上/boot：引导分区，用于存放开机所需的文件——内核、开机菜单及其配置文件等。网上很多教程说只需要100M-200M就足够，但根据我使用的经验来看，至少需要分配到300M以上，否则甚至没有足够的空间给内核进行升级（即使清理干净了旧的内核文件）。这里我选择给它分配512M。swap交换空间：类似于windows的虚拟内存，一般可以分配为物理内存的两倍。限于可用的硬盘空间，这里我之分配了8个G/home：用户的家目录，是用于存放个人文件的地方，是一般用户使用的主要目录。这个分区越大越好，因此可以将所有剩余空间全部分配给它。 一般来说只需要手动分配这四个空间即可，但也可以根据需要添加更多分区（例如自行分配/root等），具体操作自行百度。
2.配置软件镜像源 软件包管理工具介绍 说到软件的安装就不得不介绍一下linux的软件包管理工具（使用Ubuntu系统请务必了解一下apt）：
APT：是Debian Linux发行版中的APT(Advanced Packaging Tool)软件包管理工具。所有基于Debian的发行都使用这个包管理系统。不过APT工具与现在常用的apt 命令不是同一个东西，apt命令是一种与APT交互的工具。
在基于 Debian 的 Linux 发行版中，有各种工具可以与 APT 进行交互，以方便用户安装、删除和管理的软件包。apt-get 便是其中一款广受欢迎的命令行工具，以前使用过ubuntu的用户应该对apt-get很熟悉。apt-get、apt-cache 和 apt-config 这三条命令当中包含了最常用的 Linux 包管理命令 。但这也使得命令太过分散，不便于使用。
apt 命令的引入就是为了解决命令过于分散的问题，它为用户提供了更加结构化的包管理方式。可以说：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2206cfd3e0ab135df731093bf9ce203f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21baab627466c7089d0ffe48070309b8/" rel="bookmark">
			【立体匹配论文阅读】【二】CREStereo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Practical Stereo Matching via Cascaded Recurrent Network with Adaptive Correlation 基于自适应相关级联递归网络的实用立体匹配 说明：本博客可以理解为对论文的翻译和总结整理，并且会在其中添加一些在其他博客搜到的理解，PPT可以在文末下载。PPT是本人创作，希望可以帮到大家。
本文是旷视研究院（Megvii Research）、腾讯和电子科技大学在CVPR2022发布的一篇文章，其算法效果在Middlebury和ETH3D上都是排名第一的（截止到本博客发布时）。
算法平台搭建与测试请查看：通过Anaconda搭建CREStereo虚拟测试环境（Win10系统）
摘要 这段话机翻的，大概了解一下干啥的就行，想深入了解请继续往后看：
随着卷积神经网络的出现，立体匹配算法近年来取得了巨大的进展。然而，由于实际的复杂因素，如薄的结构、非理想的校正、相机模块的不一致性和各种各样的硬场景，从智能手机等消费者级设备拍摄的真实世界的图像对中准确提取差异仍然是一个巨大的挑战。在本文中,我们提出一套创新的设计来解决实际的立体匹配的问题:1)为了更好地恢复好深度细节,我们设计一个层次网络反复细化更新而且方式差异,以及叠级联结构推理;2)提出了自适应的群体关联层来减轻错误矫正的影响;3)我们引入一个新的合成数据集，特别注意困难的情况，以更好地推广到真实场景。我们的结果不仅在Middlebury和ETH3D基准排名第一，以一个显著的优势超过现有的最先进的方法，但也显示了高质量的真实照片的细节，这清楚地证明了我们的贡献的效力。
第一大障碍：（当前消费级产品的高分辨率图像只会加重这一问题，例如，在计算bokeh中，精细细节周围的视差误差会导致渲染结果下降，这对人类的感知是不利的）
第二大障碍：（例如，目前大多数智能手机捕捉的是广角和长焦镜头的立体对，它们具有明显的焦距和失真参数等特征，会不可避免地导致不理想的矫正，而且不一致的摄像头模块产生的图像对可能在照明、白平衡、图像质量等方面存在差异）
实际的立体匹配：Pang等人提出了一种自适应的方法，将CNN泛化到目标域，没有Ground Truth。Luo等人提出了一种小波合成网络，为智能手机上的散景应用产生更好的结果。Song等人为网络引入了一种域适应管道，以缩小合成域和真实域之间的差距。
合成数据集提供了高精度和密集的Ground Truth，He等人使用Blender建立了一个用于立体匹配的数据生成管道，纹理来自普通数据集的真实图像。Autoflow引入了一种简单的方法来渲染随机多边形与运动的光流训练。这些数据集仍然具有有限的物体形状变化和有限的视差/光流值分布，削弱了从合成世界到真实世界的泛化能力。
LoFTR提出了一种新的局部图像特征匹配方法。首先在粗粒度上建立图像特征的检测、描述和匹配，然后在精粒度别上细化亚像素级别的密集匹配，而不是依次执行图像特征检测、描述和匹配。与使用cost volume来搜索对应关系的密集方法相比，该文借鉴Transformer使用了自注意层和互注意层来获得两幅图像的特征描述符。这种方法提供的全局接受域使得能够在纹理较少的区域产生密集匹配。
低分辨率和高层次特征图由于具有较大的接受域和足够的语义信息，因此对于非纹理或重复纹理区域的匹配更稳健。但在这种特征图中，精细结构的细节可能会丢失。
资料下载 Li, Jiankun et al. “Practical Stereo Matching via Cascaded Recurrent Network with Adaptive Correlation.” ArXiv abs/2203.11483 (2022): n. pag. CVPR2022.PPT下载：lijyhh/Study-notes/Machine vision/02_CREStereo/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de8fa14d16f1bbaf40301983f2022bb2/" rel="bookmark">
			使用 uni-app 打包 H5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 找到项目中 manifest.json --- H5 配置---运行时的基础路径， 将路径修改为 相对路径（./ ）
2. 修改完后，点击工具栏 --- 发行 --- 网站pc web或手机 h5
3. 弹出弹窗，修改网站标题与网站域名（网站域名取对应项目的域名，一般为https/http开头）填完后直接点击发行。
4. 点击发行后如图
5. 发行成功后，找到 unpackage --- dist --- build --- h5 文件夹， 在外部资源中打开，将 h5 文件夹打包成 zip 格式，然后给到运维，运维会帮忙发布到服务器，发布成功后，运维会给你一个属于 h5 项目的域名 https://xxxx.xxx.com/app/ 拿取H5域名去拼接页面，就能在浏览器中打开对应的页面了。 （ https://xxxx.xxx.com/app/#/pages/index/index ）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a04a17cf5ced1b14e5f9cd18f0bcd42e/" rel="bookmark">
			更新禅道步骤及更新过程中出现的问题SQLSTATE[23000]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		禅道从11.6.3版本至15.0.1，在升级过程中报错，显示：
SQLSTATE[23000]: Integrity constraint violation: 1062 Duplicate entry 'system-common--CRExecution' for key 'unique'
The sql is:
UPDATE `zt_config` SET `key` = 'CRExecution' WHERE `module` = 'common' AND `key` = 'CRProject'
解决方法：
假设原xampp文件夹备份两份（防止再次出错），现将原来的xampp文件夹直接删除，然后重新使用其中一份备份文件夹，并改名为xampp文件，再次进行升级操作，成功升级
问题原因：
之前执行失败原因，怀疑是xampp文件中有文件正在执行，处于打开状态，与数据库更新命令冲突导致
最后升级成功，如下图：
新版禅道页面：
升级步骤：
一、备份禅道
我第一次安装禅道时使用的是一键安装方式，所以直接备份安装后的xampp文件夹就行（如何备份？直接将xampp文件夹复制粘贴一份存起来）
二、下载新版的禅道源代码
这里禅道15.0.1版本的源代码下载地址为：https://dl.cnezsoft.com/zentao/15.0.1/ZenTaoPMS.15.0.1.zip
三、新版本替换老版本文件
将ZenTaoPMS.15.0.1.zip解压，解压后文件夹zentaopms中所有文件复制到原来的安装文件c:/xampp/zentao文件夹下，覆盖原来xampp/zentao目录下面的东西（操作方法：把zentaopms/下面的所有文件覆盖到 xampp/zentao/ 下面）。
四、进行升级操作
在禅道部署的服务器上，通过浏览器访问http://localhost/zentao/upgrade.php，按照页面提示进行升级就可以了。如果是88端口的话，路径是http://localhost:88/zentao/upgrade.php
操作成功即可。
如有其他问题，欢迎留言~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8353090d715de7517e1bc3387ead585d/" rel="bookmark">
			linux安装配置Syslog客户端以及服务端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装syslog yum install -y rsyslog.x86_64 二、配置linux的日志服务器，（服务端 192.168.126.154，接收）： 服务端主要做的是配置监听端口，决定采用TCP还是UDP方式。本例采用UDP 修改配置文件中SYSLOGD_OPTIONS=“-c 5” 添加“ -r选项”即可，目的可以让服务器能够接受客户端传来的数据
-r表示允许接收外来的消息，-x表示不解析DNS,
#-m 0表示时间戳标记间隔,如果指定只接受某个或多个ip过来的日志，例"-s 192.168.1.1:192.168.1.2"
vi /etc/sysconfig/rsyslog [root@SyslogVM etc]# vi /etc/sysconfig/rsyslog # Options for rsyslogd # Syslogd options are deprecated since rsyslog v3. # If you want to use them, switch to compatibility mode 2 by "-c 2" # See rsyslogd(8) for more details SYSLOGD_OPTIONS="-r -c 5" 修改/etc/rsyslog.conf文件，指定传输方式、端口、日志存放位置
[root@SyslogVM etc]# vim /etc/rsyslog.conf 使用UDP接收方式: $ModLoad imudp $UDPServerRun 514 日志存放位置：客户端传来的日志记录在remote.log中 *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8353090d715de7517e1bc3387ead585d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd5b0252c8d93e34845cc3f6cd19a9c3/" rel="bookmark">
			substr函数用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		substr(string, start&lt;,length&gt;):从string的start位置开始提取字符串 length:要提取字符串的长度，若length为以下任意条件之一时，返回start位置到串尾的所有字符:
length不指定 length为空 length为负数
length大于start到串尾的长度
例如:
data test; str='chsh234960b3'; strl=subatr(str,5); str2=substr(str,5,'');
str3=aubstr(str,5,-3);
str4=aubstr(str,5, 30);
drop atr;
run;
proc print noobs; run;
注意两点：
substr中的start为负数时返回空值;
当length为负数时，默认从start位罝取所有字符。
subatr实现从右侧取数几种方法：从字符串chah234960b3右侧截取5个字符
的几种方法
1.substr(str,length(str)-n+1,n)
data _null_;
str='chah234960b3';
str1=substr(str,length(str)-5+1,5);
put str1=;
run;
2.使用reverse函数
data _null_;
str='chah234960b3';
str1=reverse(substr(reverse(str),1,5));
put str1=;
run;
substr除了有字段截取的功能外，还可以用来替换字段
'='在左边: 截取字段
data _null_;
x='123456';
str=substr(x,1,3);
put str=;
run;
在log中输出结果为: str=123;
'='在右边: 替换字段
data _null_;
x='123456';
substr(x,1,3)='789';
put x=;
run;
在log中输出结果为: str=789456;
通常情况下，substr往往结合find一起使用.
例1: 截取每行数据中的math和english
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd5b0252c8d93e34845cc3f6cd19a9c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43992ca74d3dc2cfa139f639c201046e/" rel="bookmark">
			CSS高度塌陷问题-六种解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题背景 子元素浮动后，无法撑起父元素高度，导致父元素高度丢失，其下元素会自动上移，导致页面布局混乱
解决方案 一、BFC 块级格式化环境（Block Formatting Context） BFC是页面元素的一个隐藏属性，默认是关闭的，开启BFC该元素会变成一个独立的布局区域。区域内的元素不会影响区域外的元素.
开启BFC后的特点： 1、开启BFC的元素不会被浮动元素覆盖
2、开启BFC的元素子元素和父元素外边距不会重叠
3、开启BFC的元素可以包含浮动的子元素
开启BFC方式： 1、设置元素的浮动
2、将元素设置为行内块元素：display:inline-block
3、设置overflow为非visible的值：overflow:hidden
二、clear： 清除浮动元素对当前元素所产生的影响
left：清除左侧浮动元素对当前元素的影响
right：清除右侧浮动元素对当前元素的影响
both：清除两侧中最大影响的那侧
1、在结尾处添加空div标签clear:both。
结尾处的空div会撑起父元素的高度，使其不会塌陷，但会改变页面结构
2、给父元素设置伪元素选择器，并设置清除浮动的样式。
box::after{display:block;clear:both;content:"";}
三、父级div定义height 直接给父元素一个高度，使其不会因子元素的浮动塌陷
不推荐，因为设置固定高度，父元素的高度不会适应子元素的高度而变化
四、总结 总的来说，解决高度塌陷问题，有以下几种方法：
1、设置元素的浮动
2、将元素设置为行内块元素：display:inline-block
3、设置overflow为非visible的值：overflow:hidden
4、在结尾处添加空div标签clear:both。
5、给父元素设置伪元素选择器，并设置清除浮动的样式：box::after{display:block;clear:both;content:"";}
6、父级div定义height
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/755639af4bebc82a882fa325e542cbe4/" rel="bookmark">
			课程设计——小型成绩管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要求：
1、程序功能
编程实现一个基础的成绩管理系统。
2、设计目的
通过本程序综合掌握结构体类型、指针、链表、函数、文件等知识的综合使用。
3、功能要求（可扩充功能）
（1）实现简单的菜单设计，如下所示：
1 添加学生信息
2 显示学生信息
3 查找学生信息
4 插入学生信息
5 删除学生信息
6 成绩计算
7 按总分降序输出
0 退出
（2）每个学生的信息至少包括姓名、学号、3门课程的成绩、班级等信息。
（3）“添加学生信息”：输入新的学生信息以后，系统将把相关信息存储到文件中。以班级为单位存放到不同的文件中。至少有3个班，每个班级至少10个学生。
（4）“显示学生信息”：系统将从文件中读取数据，按要求显示所有的学生信息。为使界面美观，可考虑用二维表格的形式输出。
（5）“查找学生信息”：可进一步设计，如按姓名查找或按学号查找，或者查找某门课程的最高/最低成绩、或者在所有学生中查找平均分最高/最低的学生信息等。
（6）“插入学生信息”：根据学号顺序进行插入。
（7）“删除学生信息”：可进一步设计，根据姓名删除还是根据学号删除。删除前显示该条记录，并提交用户确认。
（8）“成绩计算”:可扩充，如计算每个学生的总分、平均分；计算每个班级每门课程的平均分。
（9）“按总分降序输出”：可扩展，按总分降序或升序。
学生根据需求可以扩展。
可供参考。如果也问题或好的意见记得提出来哟。让学习编程更加群有趣。
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; FILE* fp1, * fp2, * fp3; typedef struct node { int id; char name[20]; int score[3]; int s_class; double average; double sum; union { int s_id; char s_name[20]; }resault; }STU; STU stu[300],a; int menu() { int op; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/755639af4bebc82a882fa325e542cbe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52d1e41fb9865081f832a4125c9b8ac6/" rel="bookmark">
			【shiro550反序列化漏洞（CVE-2016-4437）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、漏洞产生的原因
shiro1.2.4版本及一下，rememberMe功能使用的加密密钥是硬编码在源码中
二、漏洞的原理
shiro框架有一个rememberMe功能，会在登录成功后返回一个rememberMe字段，作为认证凭据
在请求的Cookie中添加rememberMe字段，会再服务器对该字段进行base64解码，aes解密，再反序列化，如果密钥硬编码，则rememberMe字段的值可被而已构造，造成反序列化漏洞
三、复现步骤
vulhub上启动环境
构造poc
1、使用java反序列化漏洞利用工具ysoserial生成poc，再写代码进行加密、编码，生成最终的poc
2、利用工具直接生成poc（后补充）
将生成的poc作为请求cookie的值发送请求，查看是否生效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1db693571b5dbe6589ca18cdf4ef418e/" rel="bookmark">
			vue中使用天地图测距、测面、标点【一】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天地的基本引入及创建地图，这里我就不详细讲解了，可以查看天地图的API就可以创建基本的地图页面。
首先，在地图上
选点测距：
var T = window.T; let stationTool = new T.PolylineTool(this.TMap, { showLabel: true, color: "#de590e", }); // 选点测距 stationTool.open(); 选点测面：
// 测面积 let planimeter = new T.PolygonTool(this.TMap, { showLabel: true, color: "#de590e", weight: 4, opacity: 0.6, fillColor: "#fff", fillOpacity: 0.3, }); planimeter.open(); 选点测量：这里的选点主要是用户可以通过输入经纬度及小数点来测量两点之间的距离
var T = window.T; const { frontjdNum, frontjdFenNum, frontjdMiaoNum, frontwdNum, frontwdFenNum, frontwdMiaoNum, endjdNum, endjdFenNum, endjdMiaoNum, endwdNum, endwdFenNum, endwdMiaoNum, } = this.form; // lng 经度 lat 纬度 let frontlng = (parseFloat(frontjdMiaoNum) / 60 + parseFloat(frontjdFenNum)) / 60 + parseFloat(frontjdNum); let frontlat = (parseFloat(frontwdMiaoNum) / 60 + parseFloat(frontwdFenNum)) / 60 + parseFloat(frontwdNum); let endlng = (parseFloat(endjdMiaoNum) / 60 + parseFloat(endjdFenNum)) / 60 + parseFloat(endjdNum); let endlat = (parseFloat(endwdMiaoNum) / 60 + parseFloat(endwdFenNum)) / 60 + parseFloat(endwdNum); // 点位数据 const site = [ { longitude: frontlng, latitude: frontlat }, { longitude: endlng, latitude: endlat }, ]; // 计算两点之间的距离 const add = getDistance(frontlng, frontlat, endlng, endlat); let points = []; site.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1db693571b5dbe6589ca18cdf4ef418e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/886963425b368a4dd87f12763e8d78c0/" rel="bookmark">
			vue父组件修改子组件的属性值（报错“TypeError: Cannot set properties of undefined (setting ‘status‘)“，解决方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 父组件：子组件：报错：原因：解决办法： 代码：
父组件： &lt;bg-check-box ref="examState" :checkList="formSearch.examList" @change="stateChange" v-if="is=true"&gt;&lt;/bg-check-box&gt; // change(){ this.$refs.examState.status=[0]//报错 } 子组件： &lt;template&gt; &lt;div class="bgCheckBox"&gt; &lt;el-checkbox-group v-model="status" size="mini" @change="checkChange"&gt; &lt;el-checkbox :label="item.value" border size="mini" v-for="item in checkList" :key="item.value"&gt;{{item.label}}&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { status:[], }; }, } 报错： 原因： 子组件没有在页面初始化时加载,而是在点击某个特定的按钮后才开始显示加载,所以回报undefined
解决办法： 修改change方法
change(){ this.$nextTick(()=&gt;{ this.$refs.examState.status=[0] }) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a189e06b7e562d45abc00792baee54c8/" rel="bookmark">
			EMMC接口协议详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第4章 系统特性
第5章 e•MMC 设备与系统
5.1 e•MMC系统概述
5.2 存储寻址
5.3 e•MMC设备概述
5.3.1 总线协议
5.3.2 总线速度模式
5.3.3/4/5 HS200总线速度模式/系统框图/可调采样
5.3.6/7 HS400总线速度模式/系统框图
Base Ver5.1_20220612
因为是按照JEDEC协议编录，前三章为缩略用语等，后续补充
第4章 系统特性 e•MMC设备是一种托管(managed)存储，它定义了一种对存储阵列进行间接存储访问的机制。这种间接访问通常由单独的控制器启用。间接存储访问的优点是，存储设备可以在不涉及主机软件的情况下执行多个后台存储管理任务。这使得主机系统上的闪存管理层更简单。
e•MMC 设备支持以下功能 ： 系统 电压（ VCC 和 VCCQ ）范围（表 1 ） 11线总线(时钟、Data Strobe、1位命令、8位数据总线）和硬件复位。
• 0-200MHz 的 时钟频率 • 三 种不同的数据总线宽度模式： 1 位（默认）、 4 位和 8 位 数据保护机制： • 密码 • 永久的 • 通电 • 临时 不同类型的错误保护读写模式： • 单块 (Single Block) • 多块 (Multiple Block) 数据删除命令： • 擦除 (Erase) • 修剪 (Trim) • 清 除 (Sanitize) 突然断电时的数据保护方法 使用特定于应用程序的命令定制解决方案的能力 省电睡眠模式 增强主机和设备通信技术以提高性能 • 断电通知 • 高优先级中断（ HPI ） • 后台操作 • 分区 • 增强区域 • 实时时钟 • 分区属性 • 上下文管理 • 系统数据标记 • 压缩命令 • 动态设备容量 • 可选的易失性缓存 • 缓存增强屏障 • 包装箱温度 • 命令队列 • 增强 Strobe 在使用定义的引导模式时自动传输数据的引导区域。 对受重播保护的存储块的签名访问。 两种类型的高容量设备: 小型 512B 扇区设备 和 大型 4KB 扇区设备 。 第5章 e•MMC 设备与系统 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a189e06b7e562d45abc00792baee54c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3bbf375d59b148fbdbad2bd9f4645f8/" rel="bookmark">
			VSCode自动对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Shift + Alt + F
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e868eca312b82e15ff703b06486383/" rel="bookmark">
			代码分析工具使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、valgrind二、gprof三、gperftools总结 Ubuntu18.04系统+ROS节点
前言 记录下C++代码性能分析工具的简单使用方式，包括valgrind、gprof、gperftools。
一、valgrind 内存泄露分析：
通过launch文件启动 &lt;node pkg="this_pkg" type="this_pkg_node" name="this_pkg_node_name" output="screen" **launch-prefix**="valgrind --log-file=valReport --leak-check=full --show-reachable=yes --leak-resolution=low"/&gt; 生成的检测报告是主目录下的“.ros/valReport ”
内存占用分析： launch-prefix="valgrind --tool=massif --time-unit=B --massif-out-file=massif_report.out " 然后通过ms_print分析采样文件
ms_print ./massif_report.out massif-visualizer 可视化分析采样文件
massif-visualizer ./lio_node_massif_report.out 二、gprof 分析内存。
增加编译选项
在CMakeLists.txt中增加 add_compile_options(-pg) set(catkin_LIBRARIES ${catkin_LIBRARIES} -pg) 然后正常运行launch文件启动程序，ctrl+c终止程序。
查看结果gmon.out
文件保存在在.ros文件夹下 cd .ros gprof /home/robot/catkin/devel/lib/this_pkg/this_pkg_node gmon.out 将gmon.out保存到txt文件，以文本的形式显示调用分析： gprof /home/robot/catkin/devel/lib/this_pkg/this_pkg_node gmon.out -b &gt; node_mem.txt -b：可选参数。
txt文件可视化：
需要安装工具gprof2dot： sudo pip install gprof2dot 可视化命令：
gprof2dot -n 7 -s ./node_mem.txt | dot -Tpng -o output_dg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70e868eca312b82e15ff703b06486383/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a73d522d9db0db1157891488563d96b/" rel="bookmark">
			野火指南者移植hal&#43;rtthread&#43;lvgl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个新手，想移植hal+rtthread+lvgl，移植了好多天，碰见了各种问题，最后在rtthread官方找到灵感，参照官方例程移植成功。
通过rtthread env工具新建模板 rtthread官方网站BSP制作教程 (rt-thread.org)
“3.4.1 修改链接脚本”修改链接脚本：
这个可以不知道怎么改的，可以用keil生成一个该芯片工程，按下图填写
“3.4.2修改构建脚本”中芯片型号以及芯片启动文件选择：x6.s小容量产品16K &lt;FLASH&lt;32K，xb.s中容量产品64K &lt;FLASH&lt;128K， xe.s大容量产品256K &lt;FLASH&lt;512K，xg.s小容量产品768K &lt;FLASH&lt;1024K。
开始移植 参考视频RT-Thread社区与LVGL社区梦幻联动：教你如何基于RT-Thread运行LVGL官方软件包！_哔哩哔哩_bilibili
官方已经给stm32l475-atk-pandora适配了LVGL，用env工具拉取stm32l475-atk-pandora模板的最新版，参照这个模板进行移植。
把stm32l475-atk-pandora模板里面的packages复制到上面生成的野火指南者模板，
把D:\STM32\RT\rt-thread4.1\bsp\stm32\stm32l475-atk-pandora\applications目录下LVGL文件夹复制过去。
把这四个文件用lvgl官方包内的文件代替，并改成相同名字。
新增三个组。
LVGL组把SRC内的文件添加进去，LVGL-DEMO组添加demo文件夹里的内容，LVGL-PORT组添加LVGL文件夹里的内容。
添加头文件。
编译一下，报错
注释掉#include &lt;drv_lcd.h&gt;
继续报错，野火采用320*240电阻屏，把LCD_W改成240，LCD_H改成320.
把野火指南者hal库配套例程里的这四个文件复制到D:\STM32\rt-thread4.1\bsp\stm32\stm32f103\applications\port。
把里面文件添加到工程。
添加头文件
根据报错情况把所有#include "./led/bsp_led.h" 这种形式 改成#include "bsp_led.h" 。
在rt-thread4.1\bsp\stm32\libraries\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src文件夹里，把stm32f0xx_hal_conf_template.h改成stm32f0xx_hal_conf.h，删除其余带template的文件，把剩下内容添加到Libraries组。
在"bsp_ili9341_lcd.c"添加如下像素填充函数。
void ILI9341_DrawPixel(uint16_t usX, uint16_t usY,uint16_t color) { if ((usX &lt; LCD_X_LENGTH) &amp;&amp; (usY &lt; LCD_Y_LENGTH)) { ILI9341_SetCursor (usX,usY); ILI9341_FillColor (1,color); } } 在lv_port_disp.h中添加如下代码：
#define MY_DISP_HOR_RES 240 #define MY_DISP_VER_RES 320 lv_port_disp.c文件中做如下更改：
/*Set the resolution of the display*/ disp_drv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a73d522d9db0db1157891488563d96b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7732dad5c159af0ad7e9c26df40a7cef/" rel="bookmark">
			将字符串格式的字典转换为字典格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 例如：将字符串格式的字典转换为字典格式，我的字符串如下：
问题描述 例如：将字符串转换为字典,按照网上的ast.literal_eval和json.loads，eval的处理方法都失败了
json.loads方法报错：
print(type(response)) page = json.loads(response) ast.literal_eval方法报错（eval方法同，未尝试）：
print(type(response)) page = ast.literal_eval(response) 原因分析： 例如：网上搜了好多的原因，都无法解决，有一个方法写的是通过正则将字符串里面的不符合JSON格式的引号替换掉，但是我原始数据是没有太多问题的，另外正则也不太会，就暂时放弃了
解决方案： 使用 pip install pyyaml import yaml
即用yaml来转化,成功解决，对字典得一些操作都可以使用了
page = yaml.load(respnse) pag 解决方法来源：https://www.it1352.com/1505393.html改问题下面的回答，感谢那位大佬。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26659f598be82301923566dfa2d1f20d/" rel="bookmark">
			nonebot2小插件-查看自己在世上的存活时间（较精确）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果如图 :
以下为源码
from nonebot import on_keyword, on_command from nonebot.typing import T_State from nonebot.adapters.onebot.v11 import Message, Bot, Event, MessageSegment import datetime # 输入关键字'ch'触发 Live = on_keyword({'ch'}) @Live.got('live', prompt='请回复你的出生日期\n如:2003 9 27\n可回复\'取消\'停止') async def get_live_time(bot: Bot, state: T_State, event: Event): global monthList a = state['live'] if str(a) == "取消": await Live.finish("已取消") if len(str(a).split(' ')) &lt; 3 or not (str(a).split(" ")[0] + str(a).split(" ")[1] + str(a).split(" ")[2]).isdigit(): await Live.reject("你是不是在逗我呀！") else: birth_time = str(a) t = datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26659f598be82301923566dfa2d1f20d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ae3398bc9a9b99846cc38c04b812bc2/" rel="bookmark">
			Requirement already satisfied解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到的问题： 当使用电脑中安装的Python 3.7的IDLE去运行某一个python文件时，会出现ModuleNotFoundError: No module named 'numpy'的报错，需要安装numpy库。
而当使用win+R快捷键打开cmd，输入pip install numpy命令时，却得到Requirement already satisfied: numpy in d:programminganaconda3libsite-packages (1.16.5)的提示，告诉我们已经有numpy存在于d:programminganaconda3libsite-packages (1.16.5)路径中，但是我们在IDLE中运行python文件时还是缺少numpy库。
分析原因，是因为已经存在的numpy库是存在于d:programminganaconda3libsite-packages (1.16.5)路径中，而我们的IDLE安装在d:programmingPython37文件夹下，目前d:programmingPython37Libsite-packages路径中是不存在numpy库的，所以运行python文件会报错。所以我们需要将numpy库安装在IDLE对应的路径下，才可以正常运行该python文件。
解决办法： 在cmd中使用pip install --target=目标路径 工具包名字格式的命令去安装所需要的库。例如，我使用pip install --target=d:/programming/Python37/Lib/site-packages numpy这个命令去安装numpy库，就可以成功安装。
重新在IDLE中运行之前的python文件，就可以正常运行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a02dc90e0b1dc8b596a5d88e098a46/" rel="bookmark">
			从pitch角谈欧拉角
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、浅谈欧拉角1 前因2 欧拉角 二、万向锁总结 前言 看代码的时候，发现出现了两种不同的求pitch的函数的计算方式，于是开始了追溯。
一、浅谈欧拉角 1 前因 首先，这套代码由接入了第三方库。本身主要使用四元数表示旋转，而第三方库使用欧拉角进行计算（Z-X-Y外旋），这就涉及到了旋转表示方式的转换；而且不巧的是用了欧拉角这种虽然贴近人的认知但是理解上容易混淆、计算上容易出错的表示方式。
正如我特意标出来的“Z-X-Y外旋”，我的疑问就出在这儿。代码对第三方库的接入其实比较简单，按照“Z-X-Y外旋”的方式定义好四元数和欧拉角的转换关系就可以了，类似于借助旋转矩阵R=RyRxRz关于角度的展开式，利用反三角函数求欧拉角角度。问题是本体代码其实用的X-Y-Z外旋，但是直接使用了Z-X-Y外旋获取当前pitch，明显是不一致的两套转换，这有点危险。
2 欧拉角 为什么欧拉角会产生这种风险呢？
答案：绕轴方式和旋转顺序的多样性，且得到的姿态结果是不同的。
欧拉角的绕轴方式有两种：外旋–绕固定轴旋转（如自定义的世界坐标系）和内旋–绕动轴旋转（自身的本体轴）。前者坐标轴固定不变，后者随着旋转坐标轴不断变换位置。控制变量法，我们先固定旋转顺序为X-Y-Z。那么：
外旋求得的旋转矩阵：R=RzRyRx
内旋求得的旋转矩阵：R=RxRyRz
得到的R不同。
旋转顺序有：3 * 2 * 2，排列组合一下，旋转轴1有三个选择，旋转轴2有两个选择，旋转轴3有两个选择，如下：
X-Y-Z, Y-Z-X, Z-X-Y, X-Z-Y, Y-X-Z, Z-Y-X,
X-Y-X, Y-Z-Y, Z-X-Z, X-Z-X, Y-X-Y, Z-Y-Z
同理，固定旋转方式为外旋，只考虑旋转顺序的影响。仍旧借助旋转矩阵的表达式，相同角度但不同旋转顺序得到的R是不同的，相同R也对应不同旋转顺序的不同角度值。
所以混用旋转方式是需要慎重考虑的。但是细究代码，由于求pitch那部分有个前提是只做了绕y轴的旋转，所以对结果没大影响。
二、万向锁 既然提到了欧拉角，那么万向锁有必要谈一谈。但是和上边一直使用的外旋不同，万向锁现象针对内旋，即绕物体本体轴发生的现象，而且这个现象关联了两个坐标系，我们就称为世界坐标系和本体坐标系吧。
我们先达成一个共识：欧拉角是物体旋转的一种表达方式，它描述了物体姿态A和姿态B的旋转关系，这个旋转是可以通过一个旋转矩阵或四元数直接转换完成的。只是欧拉角本身的定义决定了这个过程可以描述为绕不同的轴多次旋转完成。
假设：1.姿态A的状态下，物体本体坐标系和世界坐标系重合。2.使用Z-Y-X旋转方式。3.欧拉角使用内旋方式。4.x轴对应roll，y轴对应pitch，z轴对应yaw。
于是从A-&gt;B有：R = RzRyRx。
针对中间的旋转轴y轴，即pitch角，姿态A下如果绕它旋转90度会发生什么呢？我们发现新的本体x轴，写为x’，转到了z轴上，绕轴旋转前后的对应关系为：
x’——z
y’——y
z’——(-x)
由于姿态A时本体坐标系和世界坐标系重合，上述的x-y-z也是世界坐标系。
我们规定了欧拉角旋转方式为Z-Y-X，绕z旋转yaw后，只要绕y’的pitch为90度，就会出现当前的本体x轴x’’-z的对应关系。Z-Y之后是X，可以绕x轴旋转吗？当然可以。那为什么会有自由度丢失问题呢，这不是三个轴都可以绕行旋转吗？
我们前边提到了，万向锁涉及到两个坐标系，世界坐标系和本体坐标系。在上述内旋的方式下，物体确实可以绕自己的任意轴旋转。但是再观察一下，这种情况下Z-Y之后的X轴在怎么转呢？它和世界坐标系下绕z轴描述的旋转是一样的！从世界坐标系下看，物体在经过Z-Y-X旋转后，实际上只在Z和Y两个自由度上有改变，新的x’’也是描述的z，整个过程都不会有原本的x上的变化（roll）。也就是说，完整的旋转表达本来在roll、pitch和yaw都可以被描述，然而这种状况下该旋转丢失了roll的描述，这就是万向锁死锁或丢失自由度的现象。
再者，数学描述也很清晰，可以从R = RzRyRx得到
发现，最后只有两个轴了是不是？！
总结 欧拉角对旋转的表达方式很直观，便于理解，但是其本身的多样性需要重视。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4659840c934c492ee0c7620d4e442b71/" rel="bookmark">
			Docker与ROS可视化（RViz）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、Docker中构建ROS环境二、Docker内ROS与主机ROS通信三、Docker内开启RViz1.OpenGL2.nvidia-docker3.libglvnd 四、其他总结 前言 本文主要解决三个问题：1.Docker中构建ROS环境；2.Docker内ROS与外部ROS通信；3.Docker内的可视化，例如开启RViz。
本文操作基于Ubuntu18.04环境，Docker20.10.7版本，构建Docker的Ubuntu16.04环境。
一、Docker中构建ROS环境 Docker构建镜像的方式有两种，一种从终端pull已有的镜像，即其他人上传过的镜像；另一种则是通过Dockerfile构建镜像，这是本文选择的方式。
如果你有一定的Docker学习基础，那么对Dockerfile一定不陌生。Dockerfile是一个具备简单语法的、用户可自由配置的Docker镜像构建脚本。它的好处是用户可以根据自己的需求进行定制，类似于在一个全新的系统下进行环境配置。当目录下存在Dockerfile时，在该目录下开启终端执行如下命令，Docker会依据Dockerfile写入的内容进行镜像定制。
docker build -t [image_name] .
使用Dockerfile构建ROS环境，有两种选择：
通过FROM指令选取一个集成了ROS的镜像，例如osrf/ros:kinetic-desktop-full，然后在文本中更换软件源、安装其他所需库等操作，完整版见[github]。 FROM osrf/ros:kinetic-desktop-full RUN apt-get update &amp;&amp; apt-get install -y sudo &amp;&amp; rm -rf /var/lib/apt/lists/* # 编辑sources.list，使用国内软件源 # 根据自己需求安装一些linux工具，如ping、tftp、htop、vim RUN cp /etc/apt/sources.list /etc/apt/sources.list.bak &amp;&amp; \ sed -i 's/archive.ubuntu.com/mirrors.aliyun.com/g' /etc/apt/sources.list &amp;&amp; \ sed -i 's/security.ubuntu.com/mirrors.aliyun.com/g' /etc/apt/sources.list &amp;&amp; \ apt-get update &amp;&amp; \ apt-get upgrade -y &amp;&amp; \ apt-get install -y iputils-ping tftp lsb-core htop &amp;&amp; \ apt-get install mlocate &amp;&amp; \ apt-get install -y vim &amp;&amp; \ apt-get -y update --fix-missing &amp;&amp; \ apt-get clean RUN apt-get update -y &amp;&amp; \ apt-get install -y dbus &amp;&amp; \ rm -rf /var/lib/apt/lists/* CMD ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4659840c934c492ee0c7620d4e442b71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7b14d49a33d0f4999e4ec523bb3d37b/" rel="bookmark">
			idea无法搜索下载插件问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 IDEA无法搜索插件我的解决办法 IDEA无法搜索插件 最近重装了系统，需要配置好多环境，但当我在idea中搜索插件的时候，发现idea Plugins居然搜索不到插件，百度了下，都是些是设置idea勾选的设置，不过试了之后并没有什么卵用；
我的解决办法 我的这个问题研究了好长时间，最后居然发现是我这边宽带运营商的问题，运营商国内网速很ok，但却屏蔽了idea下载插件的网址，最后手机开热点解决；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feb189af0302cd3ab5a3ef429ace26a8/" rel="bookmark">
			【Linux】在一台机器上同时安装多个版本的CUDA（切换CUDA版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、前言二、安装CUDA三、安装cuDNN四、切换CUDA版本五、总结六、参考 一、前言 正如题目所言，最近笔者要跑一个TensorFlow搭建的模型，等我按照要求将对应版本的TensorFlow和Keras安装好之后，发现训练模型巨慢，GPU显存只用了一点点而且利用率一直是零，而且提示找不到一些库，提示如下。 2022-06-10 13:06:14.299058: I tensorflow/stream_executor/platform/default/dso_loader.cc:53] Could not dlopen library 'libcudart.so.10.0'; dlerror: libcudart.so.10.0: cannot open shared object file: No such file or directory; LD_LIBRARY_PATH: /usr/local/cuda-10.0/lib64:/usr/local/cuda-10.0/extras/CUPTI/lib64 2022-06-10 13:06:14.299110: I tensorflow/stream_executor/platform/default/dso_loader.cc:53] Could not dlopen library 'libcublas.so.10.0'; dlerror: libcublas.so.10.0: cannot open shared object file: No such file or directory; LD_LIBRARY_PATH: /usr/local/cuda-10.0/lib64:/usr/local/cuda-10.0/extras/CUPTI/lib64 2022-06-10 13:06:14.299155: I tensorflow/stream_executor/platform/default/dso_loader.cc:53] Could not dlopen library 'libcufft.so.10.0'; dlerror: libcufft.so.10.0: cannot open shared object file: No such file or directory; LD_LIBRARY_PATH: /usr/local/cuda-10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/feb189af0302cd3ab5a3ef429ace26a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40e8eb255a019dd4e7ae7bbd616e8bca/" rel="bookmark">
			【Linux】CUDA Toolkit和cuDNN版本对应关系（更新至2022年6月，附官网永久更新链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、前言二、对应关系三、如何使用四、总结五、参考 一、前言 NVIDIA® CUDA® Toolkit 为创建高性能 GPU 加速应用程序提供了一个开发环境。借助 CUDA 工具包，您可以在 GPU 加速的嵌入式系统、桌面工作站、企业数据中心、基于云的平台和 HPC 超级计算机上开发、优化和部署您的应用程序。该工具包包括 GPU 加速库、调试和优化工具、C/C++ 编译器以及用于部署应用程序的运行时库。
全球的深度学习研究人员和框架开发人员都依赖cuDNN来实现高性能GPU加速。它使他们可以专注于训练神经网络和开发软件应用程序，而不必花时间在底层GPU性能调整上。
本篇博客记录了了CUDA Toolkit 和cuDNN的版本对应关系，并给出了下载官网的地址，一些初学者可能需要这份版本对应关系表，下载之前可能需要注册一个账号。
二、对应关系 cuDNN官网下载地址：https://developer.nvidia.com/rdp/cudnn-archive
CUDA 工具包下载地址：https://developer.nvidia.com/cuda-toolkit-archive
官网可查对应关系：
cuDNNCUDAcuDNN v8.4.0 (April 1st, 2022)CUDA 11.xcuDNN v8.4.0 (April 1st, 2022)CUDA 10.2cuDNN v8.3.3 (March 18th, 2022)CUDA 11.5cuDNN v8.3.3 (March 18th, 2022)CUDA 10.2cuDNN v8.3.2 (January 10th, 2022)CUDA 11.5cuDNN v8.3.2 (January 10th, 2022)CUDA 10.2cuDNN v8.3.1 (November 22nd, 2021)CUDA 11.5cuDNN v8.3.1 (November 22nd, 2021)CUDA 10.2cuDNN v8.3.0 (November 3rd, 2021)CUDA 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40e8eb255a019dd4e7ae7bbd616e8bca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ae78f50b3eb149823ea3ae67fe845e5/" rel="bookmark">
			MetaMask钱包添加bsc链
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 网络名称： BSC主网 // 新的资源中心网址：https://bsc-dataseed1.binance.org/ // ChainID: 56 // 符号： BNB // Block Explorer URL: https://bscscan.com/ // 然后按 “保存”，到这里就添加网络成功了 一些tip：
空投不要随便领取，尤其是需要授权钱包的空投，很可能是骗子；可以在浏览器插件上查看钱包有哪些授权，定期清理； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a84a0f1e3e248a79a668aa18c9664b2/" rel="bookmark">
			Linux基础命令解析（查看、CV、压缩、重定向）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标：
1、熟悉查看命令
2、熟悉针对文件的一些操作（去重、排序、创建、剪切、删除、复制）
3、熟悉压缩命令
4、熟悉重定向
一、熟悉查看命令
cat（适合短小文件）：
More（适合长文件）：
head（看文件前边）：
tail（看文件后边）：
tr：
wc：
stat：
linux中三种时间：
1、atime：
2、mtime：
3、ctime：
grep：
cut：
二、熟悉针对文件的一些操作（去重、排序、创建、剪切、删除、复制）
cut（参数 文件名称）：
diff：
uniq：
sort：
touch：
mkdir：
Cd：
copy：
rm删除：
Rm -rf：强制删除目录（root权限下别乱用，高危操作）：
file：
三、熟悉压缩命令
tar：
4、熟悉重定向
重定向分为：
学习目标： 1、熟悉查看命令 2、熟悉针对文件的一些操作（去重、排序、创建、剪切、删除、复制） 3、熟悉压缩命令 4、熟悉重定向 一、熟悉查看命令 cat（适合短小文件）： 查看文件内容，一次全部显示，很难看全
More（适合长文件）： 可以看进度，像看小说一样。
head（看文件前边）： 看文件前多少行，-n 后加行号
tail（看文件后边）： 看文件后多少行，-n 后加行号，-f实时刷新
-f实时刷新
“|”命令衔接符，吧输出屏幕的内容，交给“|”后的命令进行二次处理。
tr： 通过这个命令做转换，叫通配符，将所有小写字母转为大写字母。
cat anaconda-ks.cfg | tr [a-z] [A-Z]
并不是所有命令都支持管道符“|”，大部分是支持的。
wc： -w统计字数（单词数），-l统计行数，-c统计字节数
stat： 看文件时间
linux中三种时间： 1、atime： 访问时间，最后一次访问文件时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a84a0f1e3e248a79a668aa18c9664b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aa0265fc145410f0d6ccd202ccf5613/" rel="bookmark">
			1030. 完美数列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1030. 完美数列 给定⼀个正整数数列，和正整数p，设这个数列中的最⼤值是M，最⼩值是m，如果M &lt;= m * p，则称 这个数列是完美数列。
现在给定参数p和⼀些正整数，请你从中选择尽可能多的数构成⼀个完美数列。
输⼊格式：
输⼊第⼀⾏给出两个正整数N和p，其中N（&lt;= 105）是输⼊的正整数的个数，p（&lt;= 109）是给定的参 数。第⼆⾏给出N个正整数，每个数不超过109。
输出格式：
在⼀⾏中输出最多可以选择多少个数可以⽤它们组成⼀个完美数列。
输⼊样例：
10 8 2 3 20 4 5 1 6 7 8 9
输出样例：
8
分析： 先对数列从小到大排序
#include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int n; long long p; cin&gt;&gt;n&gt;&gt;p; vector&lt;int&gt; v(n); for(int i=0;i&lt;n;i++) cin&gt;&gt;v[i]; sort(v.begin(),v.end()); int result=0,temp=0; for(int i=0;i&lt;n;i++){ //因为result保存的是目前的最大值，比result小的就不用再判断了 for(int j=i+result;j&lt;n;j++){ if(v[j]&lt;=v[i]*p){ temp=j-i+1; if(temp&gt;result) result=temp; }else{ break; //跳出内层循环后，i++, } } } cout&lt;&lt;result; return 0; } 版本二： #include&lt;bits/stdc++.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aa0265fc145410f0d6ccd202ccf5613/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3704f540795dafa1f165a6b4b0f510c3/" rel="bookmark">
			c&#43;&#43; - 大整数加法（重载运算符）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用vector&lt;int&gt;数组存储大整数，并重载运算符
#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; vector&lt;int&gt; a,b; // 存储大整数，高位存储在高位 //重载+、-、*、/，同时满足大整数与大整数、与整数的加法 vector&lt;int&gt; operator +(vector&lt;int&gt; a, vector&lt;int&gt; b){ //大整数 + 大整数 vector&lt;int&gt; ans; //记录输出结果 int carry = 0; //表示进位，初值为0 for(int i = 0; i &lt; a.size() &amp;&amp; i &lt; b.size(); ++i){ carry += a[i] + b[i]; //当前位相加，并加上进位 ans.push_back(carry % 10); //输入个位 carry /= 10; //舍弃个位 } //当a或b还未加完时，则继续相加，以下循环只会触发一个 for(int i = ans.size(); i &lt; a.size(); ++i){ carry += a[i]; ans.push_back(carry % 10); carry /= 10; } for(int i = ans.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3704f540795dafa1f165a6b4b0f510c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/195ffcfefc85da420fc34a50f90a132a/" rel="bookmark">
			Overleaf编译出现的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Latex Error: Command \proof already defined. 解决办法是插入以下代码：
\let\proof\relax \let\endproof\relax \usepackage{amsthm} **不清楚什么原因，可能是和哪个package顺序写错了？
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/262/">«</a>
	<span class="pagination__item pagination__item--current">263/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/264/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>