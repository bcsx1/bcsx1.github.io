<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14e44ce06167d728ca2f74fad9ff456f/" rel="bookmark">
			五种常见编程语言的数据类型相互转换,你确定不来看看!!!!!!!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五种常见编程语言的数据类型相互转换,你确定不来看看!!! 目录 五种常见编程语言的数据类型相互转换,你确定不来看看!!!!!!! 整型与浮点型整型转浮点型c,c++版java版Pythonjs 浮点型转整型c,c++javajs 整型与字符串整型转字符串cc++javapythonjs 字符串转整型cc++javapythonjs 列表与字符串列表转字符串cc++javapythonjs 字符串转列表cc++javapythonjs 结束 整型与浮点型 整型转浮点型 c,c++版 int x=12; float y=(float)x; printf("整型强制转换浮点型:x=%f\n",float(x);//常见的强制转换 (float)x 但是直接答应会有错误 printf("y=%f\n",y); x=x/2.0; //直接用于运算 printf("运算后的x=%d\n",x); printf("res=%f\n",x/2.0); //整型与浮点数进行整除得到的是浮点数 java版 int x=10; float y=(float)x; System.out.println("整型强制转换浮点型x="+(float)x); System.out.println("y="+y); Python x=12 y=float(x) print(f'整型强制转换浮点型x={float(x)}') print(f'y={y}') js js中整型无法直接转浮点型,只能字符串转浮点型parseFloat,在后面会说明
浮点型转整型 c,c++ float x=12.5; int y=(int)x; printf("浮点型转整型%d\n",(int)x);//浮点型转整型是向下取整即12.5向下取整就是12 printf("y=%d\n",y); java float x=10.5f; int y=(int)x; System.out.println("浮点型型强制转换整型x="+(int)x); System.out.println("y="+y); Python
x=12.5 y=int(x) print(f'浮点型强制转换整型x={int(x)}') print(f'y={y}') js 无
整型与字符串 整型转字符串 c #include&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int number1 = 123456; int number2 = -123456; char string[16] = {0}; itoa(number1,string,10); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14e44ce06167d728ca2f74fad9ff456f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86d444a34a46dddc5b5334adfc365a94/" rel="bookmark">
			经纬恒润智能驾驶开发、测试评估平台——智能驾驶全量数据感知及分析系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一期给大家介绍了平台的总体方案，本期从“单车智能”开发及测试的角度，为各位看官带来智能驾驶全量数据感知及分析系统。
智能驾驶全量感知数据实时可视化系统，可实时展示车端各类传感器数据，可实现感知系统自动对标，并可感知端获取各类极限场景。包括以下几部分组成：
智能驾驶数据采集分析及可视化系统
提供一套智能驾驶传感器全量数据采集及分析软硬件系统，传感器数据同步，可实时在可视化界面展示各传感器数据。
• 全量数据采集
• 定制化传感器接入
• 远程事件监控/数据传输
• 数据同步
• 数据可视化
• 定制化场景提取
• ADAS功能/测试信号分析
真值系统
真值系统，通过量化真值系统和本车系统的感知结果差异可以评价标注过程，软件和模型训练过程。
• 传感器功能验证
• 车辆感知系统对标分析
• ADAS功能执行分析
• ADAS功能漏报率、误报率
• 感知系统分析
• 图像自标注真值系统
传感器对标评估系统
• 传感器自评价报告
♦ 重复性再现性分析
• 传感器对标评价报告
♦ 多目标漏报率、误报率
♦ 分类误差量化分析
♦ 跟踪误差量化分析
• 极限场景评价报告
核心优势
• 全量数据同步采集：支持全量智能驾驶传感器及定制化传感器数据同步采集，包括车辆总线数据、摄像头、激光雷达、毫米波雷达和GPS数据等
• 实时数据可视化：传感器视频数据可叠加，提供各传感器的可视化显示，提供各传感器可视化分析
• 真值系统：高精度感知软硬件系统，车辆感知系统与真值系统对标分析，提供对标分析报告
• 传感器对标评估系统：可对传感器输出自评价及对标评价报告，评价分析传感器的多目标漏报率误报率，提供误差的量化分析
• 场景对标分析：提供对标系统的场景对标分析报告，包含感知系统融合后对标分析报告和单传感器对标分析报告
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4640decb86153f60d93be46c99dea46/" rel="bookmark">
			JAVA：java.math.BigDecimal cannot be cast to java.lang.Long
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从数据库查询返回的数值类型，在转换为string时提示
java.math.BigDecimal cannot be cast to java.lang.String的报错
此处应使用String.valueOf方法来转换。
修改完后正常。
以下说明.toString()和String.valueOf(Object)的使用区别。
.toString()
java.lang.Object类里已有public方法.toString()，对任何java对象都可以调用此方法。但必须保证object不是null值，否则将抛出NullPointerException异常。
String.valueOf(Object)
当转换null时得使用String.valueOf((Object) null），而不是String.valueOf(null）避免了转换Null时空指针报错。
而且类似上述例子中BigDecimal类型想要转换成string，也应使用String.valueOf方法。
所以尽量推荐使用String.valueOf(Object)代替.toString()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e326917588dd351eb2fbee13196159d9/" rel="bookmark">
			python/使用SQLite-使用MySQL-使用SQLAlchemy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 使用SQLite使用MySQL安装MySQL安装MySQL驱动 使用SQLAlchemy 使用SQLite SQLite是一种嵌入式数据库，它的数据库就是一个文件。由于SQLite本身是C写的，而且体积很小，所以，经常被集成到各种应用程序中，甚至在iOS和Android的App中都可以集成。
Python就内置了SQLite3，要使用SQLite3可以直接导入。
要搞清楚的几个概念：
表是数据库中存放关系数据的集合，一个数据库里面通常都包含多个表，比如学生的表，班级的表，学校的表，等等。表和表之间通过外键关联。
使用：
要操作关系数据库，首先需要连接到数据库，一个数据库连接称为Connection；
连接到数据库后，需要打开游标，称之为Cursor，通过Cursor执行SQL语句，然后，获得执行结果。
Python定义了一套操作数据库的API接口，任何数据库要连接到Python，只需要提供符合Python标准的数据库驱动即可。
由于SQLite的驱动内置在Python标准库中，所以我们可以直接来操作SQLite数据库。
我们实践一下：
import sqlite3 conn = sqlite3.connect('test.db') cursor = conn.cursor() cursor.execute('create table user (id varchar(20) primary key, name varchar(20), telephone varchar(20))') cursor.execute('insert into user (id,name,telephone) values (\'1\',\'Michael\',\'13456\')') cursor.execute('insert into user (id,name,telephone) values (\'2\',\'jiebao\',\'987654\')') cursor.rowcount cursor.close() conn.commit() conn.close() 再试试查询记录：
import sqlite3 conn = sqlite3.connect('test.db') cursor = conn.cursor() s = cursor.execute('select * from user where id = ?',('1',)) values1 =s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e326917588dd351eb2fbee13196159d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/867bb6ebb8e16312058c9c1f26b38e34/" rel="bookmark">
			uni-app中底部导航的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uni-app修炼之路（六） tabBar 参考官方文档：https://uniapp.dcloud.io/collocation/pages?id=tabbar
tabBar tabBar 用来配置导航栏的表现，以及导航切换时显示的对应页。
属性说明：
属性类型必填默认值描述平台差异说明colorHexColor是tab 上的文字默认颜色selectedColorHexColor是tab 上的文字选中时的颜色backgroundColorHexColor是tab 的背景色borderStyleString否blacktabbar 上边框的颜色，可选值 black/whiteApp 2.3.4+ 支持其他颜色值blurEffectString否noneiOS 高斯模糊效果，可选值 dark/extralight/light/none（参考:使用说明）App 2.4.0+ 支持listArray是tab 的列表，详见 list 属性说明，最少2个、最多5个 tabpositionString否bottom 可选值 bottom、top top 值仅微信小程序支持fontSizeString否10px文字默认大小App 2.3.4+iconWidthString否24px图标默认宽度（高度等比例缩放）App 2.3.4+spacingString否3px图标和文字的间距App 2.3.4+heightString否50pxtabBar 默认高度App 2.3.4+midButtonObject否中间按钮 仅在 list 项为偶数时有效App 2.3.4+ 其中 list 接收一个数组，数组中的每个项都是一个对象，其属性值如下：
属性类型必填说明pagePathString是页面路径，必须在 pages 中先定义textString是tab 上按钮文字，在 App 和 H5 平台为非必填。例如中间可放一个没有文字的+号图标iconPathString否图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效，不支持网络图片，不支持字体图标selectedIconPathString否选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效 midButton 属性说明
属性类型必填默认值描述widthString否80px中间按钮的宽度，tabBar 其它项为减去此宽度后平分，默认值为与其它项平分宽度heightString否50px中间按钮的高度，可以大于 tabBar 高度，达到中间凸起的效果textString否中间按钮的文字iconPathString否中间按钮的图片路径iconWidthString否24px图片宽度（高度等比例缩放）backgroundImageString否中间按钮的背景图片路径 midButton没有pagePath，需监听点击事件，自行处理点击后的行为逻辑。监听点击事件为调用API：uni.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/867bb6ebb8e16312058c9c1f26b38e34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d04e932fd65f105b99e315de264b70cf/" rel="bookmark">
			ant中的table和pagination表格分页结合使用  手写分页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表格部分
&lt;a-table :row-selection="rowSelection" :columns="columns" :data-source="data" class="components-table-demo-nested" @change="onChangeTable" :scroll="{ x:1600 ,y:500}" :pagination="pagination" :locale="locale" &gt; &lt;/a-table&gt; 2.分页
&lt;div class="paginationBox"&gt; &lt;span style="float:left;margin-top:5px;font-size:14px; font-family:PingFangSC-Regular,PingFang SC; font-weight:400; color:rgba(144,151,167,1)" &gt;共{{total}}项&lt;/span&gt; &lt;a-pagination show-less-items class="pagination" show-quick-jumper show-size-changer v-model="pagination.current" :page-size.sync="pagination.pageSize" :total="total" @change="onChangePagination" @showSizeChange="onShowSizeChange" /&gt; &lt;/div&gt; 3.data中的数据
total: 100, pagination: { // 分页 simple: false, current: 1, total: 0, pageSize: 10 }, 4.某个方法
// 任务文件搜索 handleSearchInput(value) { this.searchObj.pageNum = 1; this.pagination.current = 1; if (value.trim()) { this.searchObj.taskNameOrFileName = value.trim(); } else { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d04e932fd65f105b99e315de264b70cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55767a3f37d19f789df8246bc21872f2/" rel="bookmark">
			【TCP/IP】划分子网--构造超网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信搜索：编程笔记本微信搜索：编程笔记本微信搜索：编程笔记本 点击上方蓝字关注我，我们一起学编程
欢迎小伙伴们分享、转载、私信、赞赏
小伙伴儿们看完以后可不可以帮我点亮一下在看呀~
划分子网和构造超网 文章目录 划分子网和构造超网1. 划分子网1.1 从两级 IP 地址到三级 IP 地址1.2 子网掩码 2. 使用子网时分组的转发3. 无分类编址 CIDR （构造超网）3.1 网络前缀3.2 最长前缀匹配3.3 使用二叉线索查找路由表 前面我们讨论了 IP 层怎样根据路由表的内容进行分组转发，而没有涉及到 路由表一开始是如何建立的以及路由表中的内容应如何更新。在进一步讨论路由选择之前，我们需要先来介绍 划分子网和 构造超网这两个非常重要的概念。 1. 划分子网 1.1 从两级 IP 地址到三级 IP 地址 在今天看来，早期的 IP 地址设计确实不够合理。
IP 地址空间利用率有时很低
每一个 A 类地址网络可连接的主机数超过 1000 万，而每一个 B 类地址网络可连接的主机数也超过 6 万。有的单位申请到了一个 B 类地址网络，但所连接的主机数并不多，可是又不愿意申请一个足够使用的 C 类地址，理由是考虑到今后可能的发展。IP 地址的浪费，还会使 IP 地址空间的资源过早地被用完。
给每一个物理网络分配一个网络号会使路由表变得太大因为使网络性能变坏
每一个路由器都应当能够从路由表查出应该怎样到达其他网络的下一跳路由器。因此，互联网中的网络数越多，路由器的路由表的项目数也就越多。这样，即使我们拥有足够多的 IP 地址资源可以给每一个物理网络分配一个网络号，也会导致路由器的路由表中的项目数过多。这不仅增加了路由器的成本（需要更多的存储空间），而且使得查找路由时耗费更多的时间，同时也使路由器之间定期交换的路由信息急剧增加，因而使路由器和整个互联网的性能都下降了。
两级 IP 地址不够灵活
有时情况紧急，一个单位需要在一个新的地方马上开通一个新的网络。但是在申请到一个新的 IP 地址之前，新增加的网络是不可能连接到互联网上工作的。我们希望有一种方法，使一个单位能够随时灵活地增加本单位的网络，而不必事先到互联网管理机构去申请新的网络号。原来的两级 IP 地址无法做到这一点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55767a3f37d19f789df8246bc21872f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfb21b41a01659969ff6f03fabcfac83/" rel="bookmark">
			Linux系统CUDA10.2&#43;CUDNN安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里主要针对驱动已经安装好了的环境，如何安装合适的显卡驱动这里不多赘述，本文演示的系统为Ubuntu18.04，但理论上其他Linux发行版操作类似。
驱动适配 通过命令行输入nvidia-smi查看自己的显卡驱动版本以及支持的最大CUDA版本，下图第一行就显示了这些信息，可以看到，最大支持CCUDA10.2，更高版本的CUDA需要升级驱动程序。
安装包下载 CUDA的安装可以访问官网开发者工具中找到，链接给出，此时显示的结果如下，这是最新的CUDA11，点击右侧的红框选择历史版本。
找到CUDA10.2，按照需求进行选择，然后安装指示使用wget或者浏览器下载runfile文件。
CUDNN的下载也类似，链接也给出，这个下载需要注册开发者账号（简单几步注册登录即可），然后如下图选择合适的CUDA版本对应的CUDNN并选择CUDNN Library for Linux。这里注意，推荐的是CUDNN8.0.2，事实上，还有一个7.6.5更合适一些，点开Archived菜单查找，后者更稳定。
安装 CUDA安装 下面的步骤先看完再做。
首先，通过下面的命令关闭图形界面管理器，如果你的图形管理器使用的是gdm3那么将命令中的lightdm换成gdm3即可。
sudo service lightdm stop 此时，桌面环境会关闭，通过快捷键Ctrl+Alt+F1进入命令行界面，输入用户名和密码登录，然后找到之前下载的cuda文件（切换到该文件所在目录下），执行下面的命令。
sudo sh cuda_*.run 此时会进入安装，下面的过程不便截图，描述一下：首先，会询问显示管理器仍有开启，是否继续安装，这里选择continue；然后，会列出一个列表要求选择想要安装的内容，这里将第一个驱动安装的部分回车一下将那个x取消，只安装cuda tool kit即可；之后，方向键选择下面的Install进行安装，最后安装成功后会有一个提示。
这时候cuda是安装好了，但是环境变量找不到cuda程序，自己手动修改环境变量文件，通过vim或者gedit修改，对应命令分别为vim ~/.bashrc和gedit ~/.bashrc，将下面的内容添加到文件最后，再通过source ~/.bashrc更新环境变量。
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib64 export PATH=$PATH:/usr/local/cuda/bin export CUDA_HOME=$CUDA_HOME:/usr/local/cuda 此时，输入nvcc -V检查安装是否成功，如下图则表示安装成功。
CUDNN安装 切换到cudnn文件所在目录，通过tar -xzvf cudnn-10.2-linux-x64-v7.6.5.32.tgz命令解压文件，会得到一个cuda文件夹，逐一执行下面的命令进行cudnn的安装。
sudo cp cuda/include/cudnn.h /usr/local/cuda/include/ sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64/ sudo chmod a+r /usr/local/cuda/include/cudnn.h sudo chmod a+r /usr/local/cuda/lib64/libcudnn* 完成后，通过下面的命令查看安装情况，如果结果如下图逐行显示版本号，则安装成功。
cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2 至此，在Ubuntu18.04上CUDA和CUDNN安装完成。
训练测试 按照官方教程，在虚拟环境中安装Pytorch1.5并进行GPU训练测试，结果如下，成功使用CUDA训练。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a80479eff47ae1221554d6e87de797fb/" rel="bookmark">
			idea 在resin4.0部署项目，出现server ‘default‘ 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在resin4.0上面部署了应用，出现下面的错误 com.caucho.config.ConfigException: -server 'default' is an unknown server in the configuration file.
at com.caucho.server.resin.Resin.initTopology(Resin.java:1101)
at com.caucho.server.resin.Resin.initServletSystem(Resin.java:1307)
at com.caucho.server.resin.Resin.configure(Resin.java:1026)
at com.caucho.server.resin.Resin.initMain(Resin.java:1008)
at com.caucho.server.resin.Resin.main(Resin.java:1469)
-server 'default' is an unknown server in the configuration file.
解决的办法是：
在resin的启动参数里加上-server app-0就能启动名字前缀是app的服务。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b396553bcb115441a568689f7595f11e/" rel="bookmark">
			Sqlserver2012安装最新教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装前所需东西 必装：
.netFramework3.5
msodbcsql.msi(非必须，最好安装上) 如果你需要本地php环境来操作sqlserver数据库，那pdo_sqlsrv 扩展和sqlsrv扩展也是必装的。
二、所需东西下载地址和教程（根据自己实际场景来安装） .netFramework3.5 离线安装.netFramework3.5教程：
NetFx3.cab文件从网上下载一个
1、将下载好后的安装包NetFx3.cab直接、直接、直接（说三遍）放到C盘下的Windows目录下。
2、cmd到C:\Windows目录下运行该条命令：
dism.exe /online /add-package /packagepath:C:\WINDOWS\netfx3.cab 3、等待安装即可。
msodbcsql.msi
下载地址：提取码（e31n）
这个下载好后直接安装即可。 pdo_sqlsrv 扩展和sqlsrv扩展
下载地址：提取码（86uq） 下载好，随便解压到一个文件夹，生成的都是dll文件。根据电脑版本和php版本复制到你的php目录，并在配置文件中开启扩展。这个流程不在详细说明了，安装所有php扩展都是此流程。
三、正式安装 解压下载好后的压缩包，运行setup.exe： 安装之前使用系统配置检查器检测一波可能会导致失败的因素： 有失败就解决掉他，没有则继续安装： 选择全新SQL server独立安装或向现有安装添加功能： 选择指定可用版本即可： 这一步的报错不用管，继续安装即可： 选择SQL Server功能安装： 全选所有功能： 特别提醒，下面这个共享功能目录默认是C盘，但是可以更换自定义盘符及位置，并且这两个目录不能一样，不然无法继续下一步
默认实例，直接下一步： 添加当前用户： 继续添加当前用户： 默认即可： 继续添加当前用户： 随意定义一个控制器名即可，之前选择了安装D盘，那这个工作目录和结果目录不用动，继续默认： 直接下一步： 这个配置文件路径可改可不改（可能不改更稳定点）： 这一步的安装时间较长： 最后，安装成功。
四、总结 前段时间在淄博医院装sqlserver，失败了一次，原因就是.netFramework没有安装上，导致最后安装成功但失败。
祝：sqlserver安装成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/100593aa6f051157e3a01fa90d0cc3a9/" rel="bookmark">
			蓝桥杯嵌入式1、按键、流水灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、添加lLibrary的相关依赖
1、打开液晶参考历程
2、重新定义液晶初始化函数
void lcdall_init(void); void lcdall_init(void) { STM3210B_LCD_Init(); LCD_Clear(Blue); LCD_SetBackColor(Blue); LCD_SetTextColor(White); LCD_Clear(Blue); LCD_DisplayStringLine(Line4 ," Hello,world. "); Delay_Ms(1000); } 3、初始化 LED和按键（蓝桥杯嵌入式开发板LED灯位PC8-15，使用LED灯时应同时控制锁存PD2；按键为PA0、8和PB1、2）
（1）打开：第十一届蓝桥杯大赛个人赛（电子类）模拟题\嵌入式设计与开发\STM32固件库v3.5\STM32F10x_StdPeriph_Lib_V3.5.0\Project\STM32F10x_StdPeriph_Examples\GPIO\IOToggle复制以下主函数的初始化代码，进行更改，进行LED和按键初始化，注意按键模式不是GPIO_Mode_Out_PP而是
int main(void) { /*!&lt; At this stage the microcontroller clock setting is already configured, this is done through SystemInit() function which is called from startup file (startup_stm32f10x_xx.s) before to branch to application main. To reconfigure the default setting of SystemInit() function, refer to system_stm32f10x.c file */ /* GPIOD Periph clock enable */ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); /* Configure PD0 and PD2 in output pushpull mode */ GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/100593aa6f051157e3a01fa90d0cc3a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0343bf7a73dd685e0357a7106ab3620f/" rel="bookmark">
			TDengine 2.0正式上线，集群功能开源，不用再为高可靠、数据规模大而发愁了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019年7月，涛思数据团队将精心研发的TDengine 1.6版本开源，开源后，产品获得了开发者社区的积极反馈。从超过百万用户的体验反馈中，我们团队发现了一些技术问题。而彻底解决这些问题，需要我们对一些功能进行重新的设计和研发。历经八个月的披星戴月，
TDengine 2.0 终于来了！下面一起来看看，TDengine 2.0具体都有哪些升级改进。
秉持开源初心，率先将集群版开源 我们在与开源社区用户的沟通中发现，对于时序大数据的处理，仅仅使用开源的单机版，对很多场景来说是远远不够的。而越来越多的开源时序数据库将集群版纳入企业版，宣布不会开源，甚至开源后又闭源，用户不得不满世界寻找第三方集群方案和替代方案。
开源技术是为了开辟技术的“疆土”，它理应被用于更多场景，而不是受限于版本。
因此，即使大多数厂商不开源集群版的情况下，作为一高效的物联网大数据平台，我们愿意秉持开源的初心，率先将集群版进行开源，支持水平扩展，以保证任何规模的数据量都可以处理，同时保证系统的高可用性和高可靠性，让开发者们无需绞尽脑汁到处寻找集群的替代方案。
解决几大技术问题 涛思数据是一家有技术洁癖的Startup，做极致的产品是我们整个团队的追求，2.0版解决了如下几大问题：
彻底解决1.6版本里数据乱序插入，效率下降问题；采用分布式技术来存储、查询静态标签数据，以进一步提高多表之间的聚合速度；采用行式与列式相结合的Hybrid引擎存储时序数据，大幅减少系统资源。 解决这些问题之后，TDengine 2.0成为一个名副其实的，不囿于场景，更具普适性的高效物联网大数据平台。
测试覆盖率和稳定性都有了质的飞跃 在2.0的研发过程中通过使用持续集成（ Continous Integration）工具和方法，对 TDengine 进行即时全面的测试，保证了功能、稳定性以及性能指标达到预期要求。470个测试例（包括 Python 测试程序 3万行）和测试方法文档也一并开源，大家可以随时进行验证测试，也欢迎各位研发同学编写更多测试例并贡献出来。
当然，还有很多特性和功能上的改进，我们在这里不再详述，纸上得来终觉浅，还是希望大家能够将TDengine 2.0快速用起来，在使用过程中体验这些改进。快去涛思数据官网下载安装包、或者直接去GitHub下载源码吧，欢迎大家在GitHub上互动，共同完善TDengine！你们的每一个Star和Fork都是我们潜心研发的动力！
小 Tips：TDengine 2.0 文档已经同步上线，点击这里，即可访问，欢迎广大开发者阅读指正！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d396ecda83cb9bc697e8f97b2a1e6292/" rel="bookmark">
			ffmpeg推流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流程详解
av_register_all()
该方法初始化所有的封装和解封装。在使用FFmpeg的时候首先要调用这个方法。
static void register_all(void) { avcodec_register_all(); /* (de)muxers */ REGISTER_MUXER (A64, a64); REGISTER_DEMUXER (AA, aa); REGISTER_DEMUXER (AAC, aac); //... } 这里面就是进行各种注册，而REGISTER_MUXER 、REGISTER_DEMUXER 是前面定义的宏。我们看到是静态方法，说明该方法只能在所在的文件中使用，这也防止被注册多次。
avformat_network_init()
网络相关初始化。如果我们使用了网络拉流和推流等等，要先初始化。
avformat_open_input()
声明是
int avformat_open_input(AVFormatContext **ps, const char *url, AVInputFormat *fmt, AVDictionary **options); 定义在libavformat\utils.c中。主要功能
输入输出结构体AVIOContext的初始化；
输入数据的协议URLProtocol，通过函数指针的方式，与FFMPEG关联，剩下的就是调用该URLProtocol的函数进行open,read等操作了
avformat_find_stream_info
int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options);
可以读取视音频数据并且获得一些相关的信息。定义在libavformat\utils.c下
avformat_alloc_output_context2
int avformat_alloc_output_context2(AVFormatContext **ctx, AVOutputFormat *oformat,
const char *format_name, const char *filename);
定义在libavformat\mux.c中
ctx：函数调用成功之后创建的AVFormatContext结构体。
oformat：指定AVFormatContext中的AVOutputFormat，用于确定输出格式。如果指定为NULL，可以设定后两个参数（format_name或者filename）由FFmpeg猜测输出格式。
PS：使用该参数需要自己手动获取AVOutputFormat，相对于使用后两个参数来说要麻烦一些。
format_name：指定输出格式的名称。根据格式名称，FFmpeg会推测输出格式。输出格式可以是“flv”，“mkv”等等。
filename：指定输出文件的名称。根据文件名称，FFmpeg会推测输出格式。文件名称可以是“xx.flv”，“yy.mkv”等等。
函数执行成功的话，其返回值大于等于0。
内部流程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d396ecda83cb9bc697e8f97b2a1e6292/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9025d7993436ce2122c20030375952fc/" rel="bookmark">
			十进制转八进制 c语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理：
首先在栈底放入哨兵，接着用算法求出余数，把余数依次放入栈中， 然后取栈顶元素，并且出栈栈顶元素。
//十进制转八进制 #include"stdio.h" #include"stdlib.h" #define maxsize 100 typedef struct { int data[maxsize]; int top; }link; void initializa(link *s)//初始化函数 { s-&gt;top=0; } int empty(link *s)//判栈空函数 { if(s-&gt;top==0) return 1; else return 0; } int enter(link *s,int x)//进栈函数 { if(empty(s)==maxsize-1) { printf("此栈已满\n"); return 0; } else { s-&gt;top++; (s-&gt;data)[s-&gt;top]=x; } return 1; } int out(link *s,int *x)//出栈函数 { if(empty(s)==1) { printf("此栈为空\n"); return 0; } else { *x=(s-&gt;data)[s-&gt;top]; s-&gt;top--; } return 1; } int gettop(link *s,int *x) { if(empty(s)==1) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9025d7993436ce2122c20030375952fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0003d0f29d4250617aa44dfa115f44d8/" rel="bookmark">
			Shell 编程核心技术《三》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎关注【无量测试之道】公众号，回复【领取资源】,
Python编程学习资源干货、
Python+Appium框架APP的UI自动化、
Python+Selenium框架Web的UI自动化、
Python+Unittest框架API自动化、
资源和代码 免费送啦~
文章下方有公众号二维码，可直接微信扫一扫关注即可。
今天将分享如何来具体编写一个 Shell 脚本，并掌握编写 Shell 脚本的必备知识。
想要编写一个 Shell 脚本，需要的必备知识：
1、 首先需要掌握的是注释，注释以 # 开头，用于增加脚本可读性；
2、 其次是参数，我们需要给脚本传入参数并解析它；
3、 最后是函数封装，以及掌握脚本是如何执行和调试的。
注释
1、首先我们来看下注释：
使用vim创建一个文件，当然你也可以使用 vs code 等其他编辑器，vs code 可以支持语法高亮，也是非常不错的，输入 vim /tmp/test_001.sh 指令创建了 test_001.sh 文件。
2、接下来开始编写脚本：
按i键进入编辑模式，并输入注释 # this is a test script! 用来告诉大家这个脚本是干什么的，当然注释不是必需的，只是为了增加可读性，同时Shell也不会执行注释语句。
参数
当脚本开始执行，就需要我们掌握系统默认的参数解析规则。当传递一个参数给脚本时，它是怎样被解析的呢？
1、$0 表示被执行的程序，也就是当前脚本；
2、$1、$2 分别表示传递的第 1 个和第 2 个参数，Shell 默认只支持 9 个参数，如果你需要支持更多的参数可以使用 shift；
3、$@、$* 表示所有的参数，但不包含 $0；
4、${#*}、${#@} 表示参数的个数；
5、${*:1:3}、${*:$#} 表示不同参数的值。
解释说明：
001、$@与$*的区别如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0003d0f29d4250617aa44dfa115f44d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3f868cbaf4a3621d6dbcf1a1367a544/" rel="bookmark">
			SpringBoot之Canal 同步数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot之Canal同步数据库 介绍 通过实时同步数据库表的方式实现，例如我们要统计每天注册与登录人数，我们只需把会员表同步到统计库中，实现本地统计就可以了，这样效率更高，耦合度更低，Canal就是一个很好的数据库同步工具。 canal是阿里巴巴旗下的一款开源项目，纯Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费，目前主要支持了MySQL。
本地数据库和服务器上数据库保持一致，本地添加内容，服务器上面数据库也会自动添加内容 1.Canal环境搭建 1）检查binlog功能是否有开启
show variables like 'log_bin'; 2）如果显示状态为OFF表示该功能未开启，开启binlog功能
1，修改 mysql 的配置文件 my.cnf vi /etc/my.cnf 追加内容： log-bin=mysql-bin #binlog文件名 binlog_format=ROW #选择row模式 server_id=1 #mysql实例id,不能和canal的slaveId重复 2，重启 mysql： service mysql restart 3,再次检测是否开启 show variables like 'log_bin'; 2.安装Canal 下载地址
1）下载之后，放到目录中，解压文件
cd /usr/local/canal tar zxvf canal.deployer-1.1.4.tar.gz 2）修改配置文件
vi conf/example/instance.properties #需要改成自己的数据库信息 canal.instance.master.address=119.3.109.93:3306 #需要改成自己的数据库用户名与密码 canal.instance.dbUsername=root canal.instance.dbPassword=123456 #需要改成同步的数据库表规则，例如只是同步一下表，第一条是全部，第二条是选择其中一个表，看自己需要 #canal.instance.filter.regex=.*\\..* canal.instance.filter.regex=guli_ucenter.ucenter_member 3.启动Canal ./startup.sh 4.创建Canal模块，并引入依赖，版本在我主模块那里，这个只是引入，Canal的版本是1.1.0 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3f868cbaf4a3621d6dbcf1a1367a544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aafd83cd9399fb2b810f5eaac37355a/" rel="bookmark">
			如何修改Android Studio编译的应用名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下，如需要修改编译的项目的名称，只需要在项目的build文件中在Android{}的这个大括号下加上如下内容：
applicationVariants.all { variant -&gt; variant.outputs.all { output -&gt; if (variant.buildType.name == "release") { outputFileName = "*****" + "-release.apk" println("release versionName ========== " + variant.mergedFlavor.versionName) } else { outputFileName = "*****" + "-debug.apk" } } } 注意：
1："*****"为你自定义的项目名，编译结果的名称为*****-release.apk
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af90d781f9de1b0500cdf3fc94983bf1/" rel="bookmark">
			K8S常见的概念及命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K8S作为一个容器编排系统，功能非常强大，其概念很多，相应的，也会有很多命令。得益于K8S接口良好的一致性，我们无需特别记忆繁杂的指令，了解概念之后，只需知道一个公式即可掌握绝大多数命令，那就是：
kubuctl + 动作 + 资源类型 + 资源名 + 选项
下面我们分别来看一下什么是“资源”，什么是“动词”。
一、 常见的资源 Pod Pod 是K8S中最基本的单元，在整个应用的生命周期中，Pod可能随时被创建、删除。一个Pod提供一个独立的网络空间，容器的实体运行在Pod 中，一般一个Pod包含一个容器（多个也不是不可以）；而Pod运行于Node 中，一个Node可以有多个Pod。对于运行的容器来说，Pod就像一台宿主机，容器是感受不到区别的。Pod、Node与容器的关系如图所示：
ReplicaSet/ReplicationController 从字面意思就能看出，ReplicaSet或ReplicationController是负责管理（Pod）副本的，这很适用于微服务中的应用场景。假如原本有一个Pod，现在想水平扩展为三个，则只需对ReplicaSet说，我需要3个Pod副本，剩下的，ReplicaSet会自己完成。同样的，假如原本应该有三个Pod，由于不可预料的原因，挂掉了一个，那么此时ReplicaSet 会知道少了一个Pod，然后自动创建一个新Pod。如图所示：
ReplicationController可以视作跟ReplicaSet基本一样，在将来可能跟会被废弃。
NameSpace 这个概念很好理解，就是用于区分不同资源的命名空间，与Linux的namespace的概念类似。
Service 我们可以把Service理解为类似于nginx的负载均衡，即Service向外提供一个可访问的地址，后面负载了多个服务：
正如前文所说，每个Pod有独立的IP，当外部的客户端发起请求时，通过Service暴露的地址，从而得以把请求负载到每一个Pod。
Deployment 这时一个更高层级的概念，Deployment不管理Pod，而是通过管理ReplicaSet来控制Pod的行为：
在笔者看来，Deployment最主要的作用是用来解决应用版本的升级及回退问题。在不用Deployment的情况下，如果需要将Pod1和Pod2的应用从V1版本升级到V2，为保持服务的不中断，我们可能需要手动新建一个ReplicaSet，然后将Service的负载逐一从V1版本滚动升级为V2；同时在这个过程中，机器上存在双倍数量的Pod，资源消耗量也大增；如果要回退版本呢？可能更麻烦。但我们采用更高级的Deployment，只需要跟Deployment说，版本升级到V2，剩下的工作即会自动完成，无需我们手动干预更底层给的ReplicaSet和Pod。
二、 动作 get ：获取某一类资源的整体状态。套用前文的公式，如 kubectl get pod，即返回目前所有的pod： $ kubectl get pod NAME READY STATUS RESTARTS AGE kubia-75974f96b5-m2ksh 1/1 Running 0 7h12m kubia-75974f96b5-n6fqt 1/1 Running 0 7h16m kubia-75974f96b5-tpkc2 1/1 Running 0 7h16m decribe：获取某一个具体资源的详细信息，如我想查看名为"kubia-75974f96b5-m2ksh"的pod的详情，同样的，参照公式，则可用命令kubectl describe pod kubia-75974f96b5-m2ksh： $ kubectl describe pod kubia-75974f96b5-m2ksh Name: kubia-75974f96b5-m2ksh Namespace: default Priority: 0 Node: minikube/192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af90d781f9de1b0500cdf3fc94983bf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a41ffab224c9e2f25382cf5787af69e/" rel="bookmark">
			springboot项目打包成jar包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于SpringBoot内置了tomcat，所以将SpringBoot项目直接打成jar包就可以直接运行。
方式一:
File→Project Structure → Project Settings→Artifacts→JAR→From modules with dependencies
如下图,module选择需要打包的项目名;Main Class 选择项目的主程序类(启动类);输出目录确保是空的,如果里面有一个MANIFEST.MF文件,要先删除掉
将设置都搞定好后,就开始打包,如果初次打包按照以下流程
点击Build Artifacts后会出现下图的弹窗
如果是初次打包点击build,如果不是请点击Rebuild
最后找到输出目录即可
所有的输出文件都在out目录下,运行 java -jar xxxx.jar即可运行项目
部署:将该文件夹复制到对应的服务器上
&lt;1&gt;首次部署当前程序需要在对应的文件夹中执行以下命令
a.启动程序 nohup java -jar demo01.jar &amp;
b.退出 ctrl + c
c.查看日志 tail -500f nohup.out
&lt;2&gt;非首次部署当前程序需要在对应的文件夹中执行以下命令
a.捕获上一个版本程序的进程 ps - ef|grep demo01.jar
b.杀死对应的进程 kill 进程号
c.启动程序 nohup java -jar demo01.jar &amp;
d.退出 ctrl + c
e.查看日志 tail -500f nohup.out
方式二:
在pom.xml文件中定义启动类的名称 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a41ffab224c9e2f25382cf5787af69e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2568b984e055fcb866f5c29673110657/" rel="bookmark">
			ROS python2和python3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ROS里面一起用python3和python2还是有点困难
ROS官方其实是有相关教程的：http://wiki.ros.org/UsingPython3 从里面教程就可以看出，过程和步骤很繁琐复杂，主要的问题就是各种python包的依赖等等。
网上搜到有一些解决方法：
sudo apt-get install python3-catkin-pkg-models
sudo apt-get install python3-catkin-pkg
这种方法我虽然搜到了但是我并没有在自己本机上实验，因为执行的时候提示我会把Python2版本的全部给删除，这个方法可能是直接安装的编译或好的python3的版本
剩下的就只有一种方法，从源代码进行编译：要么直接把整个ROS系统用python3进行编译，要么就把某个包进行编译
这里找到一个编译Cv_bridge的 https://medium.com/@beta_b0t/how-to-setup-ros-with-python-3-44a69ca36674
如果不是整个系统重新编译也用不了ros的pub，sub等核心 功能，当然如果有一些包能够单独使用的话可以考虑一下
目前的我们的解决方案是使用一些网络通信、进程间通信或者共享内存
2020.08.02 目前最新版的ROS是全面支持python3的，http://wiki.ros.org/Distributions，不过需要装在Ubuntu20系统上才可以
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cad20fa03a308c06ecba4ceea5f5a7c5/" rel="bookmark">
			C&#43;&#43;算法篇    递归调用（函数调用自身）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要理解运用递归要学习理解下面几个问题： 什么是递归？ 递归的精髓(思想)是什么？ 递归和循环的区别是什么？ 什么时候该用递归？ 使用递归需要注意哪些问题？ 递归思想解决的几个经典的问题？ 1、递归概念： 德罗斯特效应就是说，你拿着一面镜子，然后再站在一面镜子前面，让两面镜子相对。你看到镜子里面的情景，是相同的，无限循环的。
在数学与计算机科学中，递归是指在函数的定义中调用函数自身的方法。实际上递归其包含了两个意思：递 和 归，这正是递归思想的精华所在。
大师 L. Peter Deutsch 说过：人理解迭代，神理解递归。毋庸置疑地，递归确实是一个奇妙的思维方式。对一些简单的递归问题，我们总是惊叹于递归描述问题的能力和编写代码的简洁，但要想真正领悟递归的精髓、灵活地运用递归思想来解决问题却并不是一件容易的事情。在正式介绍递归之前，我们首先引用知乎用户李继刚对递归和循环的生动解释：
递归：你打开面前这扇门，看到屋里面还有一扇门。你走过去，发现手中的钥匙还可以打开它，你推开门，发现里面还有一扇门，你继续打开它。若干次之后，你打开面前的门后，发现只有一间屋子，没有门了。然后，你开始原路返回，每走回一间屋子，你数一次，走到入口的时候，你可以回答出你到底用这你把钥匙打开了几扇门。
循环：你打开面前这扇门，看到屋里面还有一扇门。你走过去，发现手中的钥匙还可以打开它，你推开门，发现里面还有一扇门（若前面两扇门都一样，那么这扇门和前两扇门也一样；如果第二扇门比第一扇门小，那么这扇门也比第二扇门小，你继续打开这扇门，一直这样继续下去直到打开所有的门。但是，入口处的人始终等不到你回去告诉他答案。　2、递归思想的精髓 正如上面所描述的场景，递归就是有去（递去）有回（归来），如下图所示。“有去”是指：递归问题必须可以分解为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决，就像上面例子中的钥匙可以打开后面所有门上的锁一样；“有回”是指 : 这些问题的演化过程是一个从大到小，由近及远的过程，并且会有一个明确的终点(临界点)，一旦到达了这个临界点，就不用再往更小、更远的地方走下去。最后，从这个临界点开始，原路返回到原点，原问题解决。
更直接地说，递归的基本思想就是把规模大的问题转化为规模小的相似的子问题来解决。特别地，在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况，这也正是递归的定义所在。格外重要的是，这个解决问题的函数必须有明确的结束条件，否则就会导致无限递归的情况。
例题分析：求n! #include&lt;bits/stdc++.h&gt; using namespace std; int f(int n) { int m; if (n==1) m=1; else m=f(n-1)*n; return m; } int main() { int x,y; cin&gt;&gt;x; y=f(x); cout&lt;&lt;y; } 看程序写结果:
#include&lt;bits/stdc++.h&gt; using namespace std; int f(int n) { int m; if (n==1) m=10; //递归终止条件 else //先测试，后递归调用。 m=f(n-1)+2; //递归调用语句，该语句的参数应该逐渐逼近终止条件 return m; } int main() { int x=10,y; y=f(x); cout&lt;&lt;y; } 输出： #include&lt;bits/stdc++.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cad20fa03a308c06ecba4ceea5f5a7c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/716c38c78695f2e22f60ec6f178e3f5b/" rel="bookmark">
			Ubuntu20.04安装arm-xilinx-linux版本的GCC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		就是一个新手小白，安装这个GCC花了我自己两天时间，就憋着，不想去问老师。 心得：查经验，跟着动手，能对的话，万事大吉。不对的话，嗯。。。你要做出贡献了，实践过程中中多注意报错的log。
step1 有一个安装包
arm-xilinx-linux版本的GCC：链接：https://pan.baidu.com/s/1uLlAJI525GMxAEMFlhsc6g
提取码：1234
解压后，把这个安装包放到Ubuntu的某个文件夹下，然后执行下面两条指令：
cd CodeSourcery/Sourcery_CodeBench_Lite_for_Xilinx_GNU_Linux/bin //找到编译器路径 pwd //获取路径 把这个路径记下来.
step2 配置环境变量
回到~目录，执行语句：
sudo vim ~/.bash.rc 然后在最下面添加你刚得到的路径，以下是我个人的：
export PATH=$PATH:usr/local/arm/CodeSourcery/Sourcery_CodeBench_Lite_for_X ilinx_GNU_Linux/bin 保存，退出，
step3 激活环境变量
执行指令：
source ./bashrc//激活环境变量的设置 可以执行指令：
arm-xilinx-linux-gnueabi-gcc -v 如果出现了GCC的版本号，就完成了。如果没有，就请继续。。。
我在网上看了很多文章，说是少了32位库兼容包会导致“NO such file or directory”, 他们的处理方法是 执行：sudo apt-get install lib32ncurses5 lib32z1，我试了试，报错了。 报错的意思是， 现在的Ubuntu20版本不用lib32ncurses5 了， 于是，我就将指令改成了：
sudo apt-get install lib32z1 然后，再次执行arm-xilinx-linux-gnueabi-gcc -v，就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1403aad59c7d425280932f9d5d8ed60c/" rel="bookmark">
			c&#43;&#43; 并发 -- “你一下我一下模式“  == 生产者消费者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++ 并发 – “你一下我一下模式” == 生产者消费者模式 利用了 start_send 控制了等待顺序，m_cond 会先执行等待
注意send_run中一定是先m_cond.notify_all() 后 wait，因为如果都是先wait就会造成第二次循环的时候死锁，m_cond 在wait 的同时 m_cond_t 也在wait，在相互等
#include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;condition_variable&gt; #include &lt;thread&gt; std::condition_variable m_cond; std::condition_variable m_cond_t; std::mutex mutex_; std::mutex mutex_t; bool start_state = false; bool start_send = false; bool is_varaible() { return start_state; } void start_run() { std::unique_lock&lt;std::mutex&gt; lck(mutex_); printf("m_cond wait\r\n"); if (start_state) { m_cond.wait(lck); } start_send = false; m_cond_t.notify_all(); printf("m_cond wait end\r\n"); lck.unlock(); } void thread_func() { while(true) { start_run(); } } void send_run() { std::unique_lock&lt;std::mutex&gt; lck(mutex_); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1403aad59c7d425280932f9d5d8ed60c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e64eebab125010920e2f3a8157294303/" rel="bookmark">
			R语言基础——reshape2包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R语言基础学习--reshape2包 简介1. rehsape2包2. 长宽数据格式 函数学习1. melt函数2. cast函数2.1 dcast()函数2.2 acast()函数 3. 其他函数3.1 `add_margins()`函数3.2 `recast ()`函数3.3 `melt_check()`函数3.4 `colsplit()`函数 参考文件 简介 1. rehsape2包 reshape2包是由Hadley Wickham开发的一个R包，从其命名不难看出，reshape2包可以对数据重塑，就像炼铁一样，先融化数据，再重新整合数据，它的主要功能函数为cast()和 melt()，实现了长数据格式与宽数据格式之间的相互转换。
比如说，如果你要做回归等等的多变量分析，用到glm等等，那必然要用宽格式数据；再比如说，如果你要到ggplot里面画图，按照Hadley大神的可视化语法思想，多半是要用长格式的数据的。
2. 长宽数据格式 宽数据格式：每个变量单独成一列。
长数据格式：变量ID没有单独成列，而是整合在同一列。
概念难以理解? 这里以airquality数据集为例：
函数学习 reshape2包的学习主要以官方推荐的空气质量数据集(airquality)为例。
首先载入数据集并查看数据项目
data("airquality") head(airquality) knitr::kable(head(airquality),align = "c") OzoneSolar.RWindTempMonthDay411907.46751361188.072521214912.674531831311.56254NANA14.3565528NA14.96656 为了便于后续的处理，我们将列名转换为小写
colnames(airquality) # [1] "Ozone" "Solar.R" "Wind" "Temp" "Month" "Day" names(airquality) &lt;- tolower(names(airquality)) names(airquality) # [1] "ozone" "solar.r" "wind" "temp" "month" "day" 1. melt函数 官方介绍
从官方文档可以看出，melt()函数可以将一个对象“融化”为一个数据框。
对于不同的数据结构，melt()函数有不同的用法，如：
(1) 数据框(data frame)：melt.data.frame()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e64eebab125010920e2f3a8157294303/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8ef1e3c3c2ec418e6e5a6bf36e2fcff/" rel="bookmark">
			二叉树的路径总和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
说明: 叶子节点是指没有子节点的节点。
示例:
给定如下二叉树，以及目标和 sum = 22，
5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。
代码：
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool hasPathSum(TreeNode* root, int sum) { if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8ef1e3c3c2ec418e6e5a6bf36e2fcff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18ada8faf1304c1fc94efa30f9b9697c/" rel="bookmark">
			【横向移动】内网渗透之内网信息收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
目的:
后渗透攻防参考链接：
一、内网信息收集
1.内网基础信息：
2.内网核心业务信息：
3.其他信息
二、内网实战（命令、工具及脚本）
1.用户列表、当前权限等
win：
linux：
​
2.内网网络拓扑等信息
3.进程列表
win:
linux:
4.端口信息
win:
linux:
5.补丁信息
win:
linux：
6.本地用户习惯及历史记录
7.凭证收集
8.系统哈希或明文密码获取
（1）mimikatz获取明文（一般会报毒）
（2）注册表导出，本地分析（较安全准确）
（3）Get-PassHashes脚本
（4）wce读取明文，哈希注入
（5）procdump（微软出品）+本地用mimikatz得明文，较安全
9.星号查看
三、内网权限拓展（常见应用漏洞）：
前言： 首先要能拿下一台可连接内的机器权限(webshell)，然后才能开始域渗透收集系统一般信息，包括操作系统、IP、是否存在杀毒软件、打过的补丁，用户信息，服务及任务信息，组网信息，计划任务信息，事件查看器信息和文件夹和文件位置信息。
当渗透测试人员进入内网后，面对的是一片“黑暗森林”，所以渗透测试人员首先会对当前所处的网络环境进行判断，通常的判断分为三种:
我是谁？——对机器角色的判断。这是哪？——对目前机器所处网络环境的拓扑结构进行分析和判断。我在哪？——对目前机器所处位置区域的判断。 目的: 内网信息收集是为了深入的了解内网情况，为了横向移动，权限维持，长期渗透做准备，收集的内容包括有：本机系统信息，本地网络信息，域内用户，域组信息等。收集并分析了这些信息，对于我们在内网进行渗透有一定的帮助作用。
后渗透攻防参考链接： https://www.secpulse.com/archives/51527.html
https://www.freebuf.com/column/194119.html
https://www.cnblogs.com/oneWhite/p/11173170.html
本机内网信息搜集
【内网渗透】——内网信息收集之鹏哥教你骚操作
https://3gstudent.github.io/
一、内网信息收集 1.内网基础信息： （1）内网网段信息：网段信息有助于我们对渗透的内网进行拓扑、分区。以拿下边界服务器为例，得到一定的控制权之后，一定要查看网卡信息，这样就收集到内部网络地址段的信息，进一步渗透，找到更多的内部网络地址。
（2）内网大小：有助于我们了解整个公司的网络分布与组成，帮助我们寻找内网核心业务。
2.内网核心业务信息： 内网OA办公系统（大公司）、邮件服务器（大公司才有）、网络监控系统（一般都有）、财务应用系统、核心产品源码（对于IT公司，会架设自己的svn或者git服务器）
3.其他信息 系统管理员密码。
其他用户session，3389和ipc$连接记录，各用户回收站信息。
浏览器密码和浏览器cookie获取。
windows无线密码获取（利用netsh），数据库密码获取。
host文件获取和dns缓存信息收集等，可以查看DNS服务器的IP，如果是域，一般情况DNS服务器和域控是同一台！先定位出DNS服务器，再进行后面渗透。
杀软、补丁、进程、网络代理信息wpad信息（Web Proxy Auto-Discovery Protocol，是客户端通过DHCP或DNS协议探测代理服务器配置脚本url的一种方式），软件列表信息。
计划任务、帐号密码策略与锁定策略、共享文件夹、web服务器配置文件。
VPN历史密码等、TeamView密码等、启动项、iislog等。
常用的后渗透信息收集工具、PowerShell+各种内网渗透工具的使用。
二、内网实战（命令、工具及脚本） 1.用户列表、当前权限等 win： 导出域内所有用户信息详细信息。字段可以不加选择默认字段 csvde -r "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18ada8faf1304c1fc94efa30f9b9697c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ada45a29d159a76a4ad1f06170bd6c2/" rel="bookmark">
			执行truffle unbox react报错，出现Error: connect ECONNREFUSED 0.0.0.0:443问题的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提：我是用的是MAC系统，不知道使用windows系统是否也可以 react-box 项目构建 localhost:ReactDapp liyuechun$ truffle unbox react-box Starting unbox... ================= ✔ Preparing to download box ✖ Downloading Unbox failed! RequestError: Error: connect ECONNREFUSED 0.0.0.0:443 at new RequestError (/usr/local/lib/node_modules/truffle/build/webpack:/node_modules/request-promise-core/lib/errors.js:14:1) at Request.plumbing.callback (/usr/local/lib/node_modules/truffle/build/webpack:/node_modules/request-promise-core/lib/plumbing.js:87:1) at Request.RP$callback [as _callback] (/usr/local/lib/node_modules/truffle/build/webpack:/node_modules/request-promise-core/lib/plumbing.js:46:1) at self.callback (/usr/local/lib/node_modules/truffle/build/webpack:/node_modules/request/request.js:185:1) at Request.emit (events.js:189:13) at Request.onRequestError (/usr/local/lib/node_modules/truffle/build/webpack:/node_modules/request/request.js:881:1) at ClientRequest.emit (events.js:189:13) at TLSSocket.socketErrorListener (_http_client.js:392:9) at TLSSocket.emit (events.js:189:13) at emitErrorNT (internal/streams/destroy.js:82:8) at emitErrorAndCloseNT (internal/streams/destroy.js:50:3) at process._tickCallback (internal/process/next_tick.js:63:19) Truffle v5.1.29 (core: 5.1.29) Node v10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ada45a29d159a76a4ad1f06170bd6c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7941bc3b91d0c135c39235bfa94ef290/" rel="bookmark">
			PostgreSQL - 一文看懂explain
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		explain是SQL优化的前提。但explain的结果，无论是官方手册，还是别人写的博客，看完后点头如捣蒜，但往往看到自己SQL的执行计划时，并不很确定要优化的点在哪里。很大一部分原因是不知道各计划节点的具体含义，更确切地说，是不明白SQL执行的原理。比如，我们并不能很好地回答以下问题
index scan、index only scan、bitmap index scan 有啥区别？为什么明明有建立索引，但PG就是不用呢？执行计划中有子查询就一定不好吗？hash join、merge join、nestloop join有啥区别？。。。。。。 本文的目的，是让大家看懂SQL执行计划。毕竟，看懂了，才谈得上优化。
只有在了解数据库针对SQL做了哪些优化，才能制定出合理策略，利用优化器本身的特性达到最终优化整个SQL的最终目的，因此我们首先会介绍SQL优化器的原理；而本文的目的是让大家看懂explain，因此会介绍执行计划中最核心的部分——扫描节点和连接节点，大部分的优化思路都来自于此；文章的最后介绍explain命令得到的结果每一部分的具体含义，并介绍方便查看复杂计划的可视化工具。
查询优化器原理 在介绍执行计划前，先了解一下执行计划生成的原理。一条SQL从输入到执行完毕，大致会经历如下三个步骤
语法分析：词法分析、语法分析、语义分析查询优化：基于规则的优化、基于代价的优化查询执行、数据存取 explain的输出，是查询优化的最终结果。而查询优化又被分为两个步骤
基于规则的优化：即逻辑优化，通过对关系代数表达式进行逻辑上的等价变换，以获得性能更好的计划，比如谓词下推（将上层的过滤条件下推到下层）。
基于代价的优化：即物理优化，逻辑优化后，实际的查询路径还是有很多种，PG建立了代价计算模型，计算所有可能路径的代价，选出最优路径。
比如select * from users where id = 1，在扫描方式上，有顺序扫描、索引扫描等。在不同的数据量情况下，按顺序扫描和索引扫描的代价可能是不一样的，因此它的执行计划可能会随数据量的变化而变化。
逻辑优化（基于规则的优化） 基于逻辑的等价变换，可对原始的SQL语句进行优化。逻辑优化的基本原则——将复杂逻辑变为简单逻辑。具体做的工作，大致是提升子查询、表达式预处理、having子句条件下推、group by冗余字段消除、谓词（过滤条件）下推、外连接消除等。
子查询提升 子查询可分为如下两类
相关子查询：子查询中引用外层表的列属性，导致外层表的每一条记录，子查询都需要重新执行一次
非相关子查询：子查询是独立的，与外层表没有直接的关联，子查询单独执行一次，外层表可以重复利用其结果
通常来说，相关子查询会被提升，非相关子查询由于其本来就只执行一次，因此没有太大必要提升。
-- 相关子查询举例 explain select *, (select label_id from content_to_label where content_id = content.id) as label_id from content; HotSpotIntrinsicCandidate Seq Scan on content (cost=0.00..3694.61 rows=1151 width=743) SubPlan 1 -&gt; Seq Scan on content_to_label (cost=0.00..3.10 rows=3 width=4) Filter: (content_id = content.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7941bc3b91d0c135c39235bfa94ef290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a13b548fc4ab5ca999ddbcab75b48909/" rel="bookmark">
			效果展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d404e285c17a2cd40719df4df25ee34f/" rel="bookmark">
			前端jq/vue echarts中国地图的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、jquery项目实现echarts中国地图 1、引入相关资源文件 jquery、echarts 等
&lt;script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcdn.net/ajax/libs/echarts/4.8.0/echarts.min.js"&gt;&lt;/script&gt; 2、下载中国地图json数据中国地图json数据下载地址
3、展示代码
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;中国地图&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="main" style="width: 100%;height:800px;"&gt;&lt;/div&gt; &lt;/body&gt; &lt;script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcdn.net/ajax/libs/echarts/4.8.0/echarts.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; //获取地图数据 $.get('china.json', function (chinaJson) { //注册地图 echarts.registerMap('china', chinaJson); // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); var geoCoordMap = { '上海': [121.4648,31.2891], '东莞': [113.8953,22.901], '东营': [118.7073,37.5513], '中山': [113.4229,22.478], '临汾': [111.4783,36.1615], '临沂': [118.3118,35.2936], '丹东': [124.541,40.4242], '丽水': [119.5642,28.1854], '乌鲁木齐': [87.9236,43.5883], '佛山': [112.8955,23.1097], '保定': [115.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d404e285c17a2cd40719df4df25ee34f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f74e77f1f746724f71f3b686e817582b/" rel="bookmark">
			Android Xml解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近看到一个面试题，是这样的：
面试官：怎么动态判断服务器返回的数据是 Xml 还是 Json？（答案见下）
由此有了这一篇文章。
1. 什么是XML XML (Extensible markup language): XML是一种标记语言，用于存储与传输数据。是常用的数据传输方式，区分大小写，文件扩展名为.xml。XML定义了一组用于以人类可读和机器可读的格式编码文档的规则。XML的设计目标集中在Internet的简单性，通用性和可用性上。它是一种文本数据格式，并通过Unicode对不同的人类语言提供了强大的支持，被W3C所推荐。
例如：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;Users&gt; &lt;user&gt; &lt;name&gt;James&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;/user&gt; &lt;user&gt; &lt;name&gt;Mike&lt;/name&gt; &lt;age&gt;19&lt;/age&gt; &lt;/user&gt; &lt;user&gt; &lt;name&gt;John&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;/user&gt; &lt;user&gt; &lt;name&gt;Peter&lt;/name&gt; &lt;age&gt;21&lt;/age&gt; &lt;/user&gt; &lt;/Users&gt; 1.1 XML 与 JSON 的区别 JSON (JavaScript Object Notation): 是一种轻量级的数据交换格式，它完全独立于语言。它基于JavaScript编程语言，易于理解和生成。文件扩展名为.json。
例如：
{ "Users":[ { "name":"James", "age":18 }, { "name":"Mike", "age":19 }, { "name":"John", "age":20 }, { "name":"Peter", "age":21 } ] } XML 与 JSON 的区别：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f74e77f1f746724f71f3b686e817582b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e6ca8201571381e0473a95551f6afd1/" rel="bookmark">
			利用elementui的el-table实现跨页保存单击勾选状态和全选状态（在前端分页）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路: 从接口获取全部数据，前端完成分页数据展示，利用el-table自身的方法实现跨页保存单击勾选状态，自己实现el-table跨页保存全选状态方法。
第一步，前端分页，从接口获取全部数据 所以不要给后端传递pageSize和currentPage参数
第二步，用slice分割当前页码要显示的数据 代码：
:data="tableData.slice((currentPage-1)*pagesize, currentPage*pagesize)" 备注:tableData为表格绑定的数据源，currentPage为当前页码,pagesize为每页的数据条数
第三步，添加row-key和reserve-selection 利用el-table自身能够跨页保存勾选状态(非全选)。
(做完这一步，表格即可实现跨页保存单击勾选状态。)
代码：
:row-key="(row)=&gt;{ return row.groupId}" &lt;el-table-column :reserve-selection="true" type="selection" /&gt; 备注：row.groupId为表格每行数据的唯一标识(ID)，请根据实际id替换。
第四步（为el-table全选添加跨页状态保存） 添加一个变量，保存勾选的数据
代码：
selectedLeftTableIds: [],//保存表格勾选的数据 为表格el-table添加全选监听事件和单击勾选监听事件
代码：
@select-all="selectSingleTableAll" @selection-change="tableSelection" 具体代码实现(你需要写在methods: { }里)：
// 表格多选 tableSelection: function (item) { this.selectedLeftTableIds = item //获取当前表格全部的勾选数据 // console.log('实际勾选数据this.selectedLeftTableIds：', this.selectedLeftTableIds) }, //表格全选 selectSingleTableAll: function (selection) { //获取当前页码所显示的数据 let a = this.tableData.slice((this.currentPage - 1) * this.pagesize, this.currentPage * this.pagesize) //获取当前页勾选的数据 let b = selection // 判断是取消全选还是全选 let isLeftTableAllSelectStatus = b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e6ca8201571381e0473a95551f6afd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dcb738afbd293f7ccf2fe93aa4c0dcc/" rel="bookmark">
			vue中当数字*100后的计算失误问题:0.3*100得到的结果是229.99999999999997
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言： 在做消费类型系统的时候，遇到个问题，是计算机乘法问题得到结果有问题， 比如 : 0.3*100得到的结果是229.99999999999997 原因： 二进制和十进制转换中的限位问题，浮点运算带上点微小的误差是正常现象。
但是对于消费来说，这个问题是很严重的，我们要求的计算不能出现问题，
解决办法： 将以下的方法引入页面methods中，参数是你的数据，（注意：必须Sting类型），然后获取返回的值，就是处理好的数据
还有一点，我在@blur的事件中调用这个方法是会报错，很奇怪，但是其他地方调用没有任何问题
/** * 计算精度问题 * 解决 2.3*100 计算机得到的不是230的问题 * */ yuantofen(val) { var s = val.split(".") var yuan = parseInt(s[0]) * 100; var fen = 0; if (s.length &gt; 1) { let fenVal = (parseInt(s[1].substr(0, 1))) * 10; fen += fenVal; if (s[1].length &gt; 1) { fen += parseInt(s[1].substr(1, 1)); } } var fee = yuan + fen; return fee; }, 到这里就结束了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dc5c0c5bd4eff024e793c83c1a82765/" rel="bookmark">
			ERROR tool.ExportTool: Encountered IOException running export job （hive传到mysql报错）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你在启动mysql的时候mysql -u root -p
后面没有输入密码
所以你在传的时候也不需要输入密码
sqoop export --connect jdbc:mysql://localhost:3306/dbb --table small_user --username root -P --fields-terminated-by ‘,’ --export-dir /user/hive/warehouse/small_user
注：由于sqoop语法问题P一定要大写
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c11a5eb55a49ce0359343ad7f6c280dd/" rel="bookmark">
			vue 的v-pre指令和pre标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue 的v-pre指令和pre标签 1. vue的pre指令不加v-pre代码不加v-pre效果图加v-pre代码加v-pre效果图 2. vue的pre标签不加pre标签代码不加pre标签效果图加pre标签代码加pre标签效果图 1. vue的pre指令 v-pre指令说明：跳过这个元素和它的子元素的编译过程。可以用来显示原始标签。跳过大量没有指令的节点会加快编译。
不加v-pre代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;title&gt;Vue&lt;/title&gt; &lt;script type="text/javascript" src="C:/Users/XXXX/Desktop/Javascript/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;!--没有加v-pre指令--&gt; &lt;div&gt;{{ message}}&lt;p&gt;{{ message }}&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vueObj = new Vue({ el: '#app', data: { message: 'Hello Vue.js!' } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 不加v-pre效果图 不加v-pre指令时，显示了VUE实例的data中定义的message变量的值
加v-pre代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;title&gt;Vue&lt;/title&gt; &lt;script type="text/javascript" src="C:/Users/qingminglong/Desktop/Javascript/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;!--加v-pre指令--&gt; &lt;div v-pre&gt;{{ message}}&lt;p&gt;{{ message }}&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vueObj = new Vue({ el: '#app', data: { message: 'Hello Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c11a5eb55a49ce0359343ad7f6c280dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9de3ed314ae52f8415e4eed1bf16e2cc/" rel="bookmark">
			unity-代码控制录屏UnityRecorder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System; using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEditor.Recorder; using UnityEditor.Recorder.Input; using UnityEngine; public enum RecorderControllerState { Video, Animation, ImageSequence } /// &lt;summary&gt; /// 录制 /// &lt;/summary&gt; public class NewBehaviourScript : MonoBehaviour { RecorderController m_RecorderController; private RecorderControllerState controllerState = RecorderControllerState.Video; [Header("下面两个单纯观看数据，不用管")] public RecorderControllerSettings controllerSettings; public MovieRecorderSettings videoRecorder; private string animationOutputFolder; private string mediaOutputFolder; private void Start() { controllerSettings = ScriptableObject.CreateInstance&lt;RecorderControllerSettings&gt;(); m_RecorderController = new RecorderController(controllerSettings); animationOutputFolder = Application.dataPath + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9de3ed314ae52f8415e4eed1bf16e2cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d6a898849d17053d11ce38457f53af5/" rel="bookmark">
			从控制理论的根轨迹法和稳定性分析谈到舵机PD控制代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一次谈到基于MPU6050的基于一阶互补滤波算法实现后，本来想接着就自适应一阶互补滤波和卡尔曼滤波再写一篇的，但是卡尔曼滤波算法我自己写出来并进行姿态解算后发现效果不很好，才疏学浅，等我调好了再写吧，昨天花了半下午做了一个基于MPU6050的舵机云台自稳定系统，采用PD控制，下面就从控制理论原理到代码实现来谈一谈。
1.P项对系统性能影响的分析
假设现在我们有如下一个系统：
这个系统采用简单的比例控制，当kp=1时，我们来分析一下他的稳定性，从奈奎斯特曲线的角度来分析：
num=[1]; kp=1; den=[1 1 -2]; sys=tf(num,den); nyquist(sys); 由P-Z=N这个奈奎斯特判据来看，P作为开环传递函数在右半平面的极点数等于1，N作为奈奎斯特曲线逆时针绕（-1,0j）这个点的圈数等于0，所以Z等于1，意味着闭环传递函数在右半平面的极点数为1，系统不稳定。我们可以通过时域响应来验证一下：
我们扩大kp值，将kp变为10：
num=[10]; kp=10; den=[1 1 -2]; sys=tf(num,den); nyquist(sys); 由P-Z=N可以，P=1，N=1，所以Z=0，闭环系统稳定。老规矩验证一波：
可以看出，时域响应确实是稳定的，但是存在稳态误差。
现在我们可以得到一个结论：单纯的比例控制，增大或者减小比例系数kp可以改变系统的稳定性。
我们再次增大kp值，这次我们将kp增大到50：
与上面kp等于10的时域响应比较可得，其稳态误差减小了但是瞬态响应振荡加剧了。所以我们又可以得到一个结论：在系统稳定前提下，增大比例系数kp可以减小稳态误差，但是会导致系统振荡加剧。
下面从数学角度分析一下：
首先求出系统的闭环传递函数：
总所周知，在拉普拉斯变换中有一个终值定理，假设输入为一个阶跃响应，由终值定理可得：
当t趋近于无穷时，s趋近于0，所以此时输出为：
由于输入为r(t)=1，所以y(t)-r(t)为：
当kp增大时，稳态误差减小，这是有数学依据的。
那么为什么会导致系统的振荡加剧呢，这次我们感性一点分析。我们知道了系统的闭环传递函数为:
输入为阶跃值1，那么系统的时域表达式可写作:
λ1和λ2为闭环传递函数的两个极点，如果λ1和λ2实部都小于0那么系统稳定，如果有虚部存在，那么就会产生振荡。由韦达定理可以求得两个极点为：
当kp&gt;9/4时根号下的部分为负数，会出现虚数，在e的指数部分出现虚数i，怎么这么熟悉，咦咦咦，记得有位大神叫欧拉，提出了一个强的一批的欧拉公式，把指数和三角函数联系在了一起，下面来看看这个伟大的公式：
那么一切都好理解了，如果特征值存在虚部项，那么y(t)里就会存在由特征值实部决定的eλt衰减项以及由特征值虚部决定的三角函数振荡项，实部大小决定收敛速度，虚部（虚部也是实数啊）大小决定振荡剧烈程度。当kp&gt;9/4时，kp越大，实部永远等于-0.5，衰减速度不变，虚部绝对值越大，三角函数部分系数越大，振荡越剧烈，所以从数学上证明了kp越大，振荡越剧烈。在这个系统里，我们可以总结一下，kp=2和kp=9/4是两个分界点。
当kp&lt;2,系统不稳定（前面提到过）；
当2&lt;kp&lt;9/4,系统稳定且不振荡，当kp=2.2时；
当kp&gt;2时，系统稳定且存在振荡，kp越大振荡越剧烈但稳态误差较小。
以上便是对单纯的比例控制对系统影响的分析，大家还可以从开环bode图的角度去分析系统的稳定性，其实在奈奎斯特曲线中也能看出相位裕度和幅值裕度从而进行稳定性分析，这里我就贴一个kp=10时这个系统的开环bode图：
num=[10]; kp=2.2; den=[1 1 -2]; sys=tf(num,den); bode(sys); 开环伯德图分析系统性能不外乎幅值裕度和相位裕度，当幅频特性曲线与横坐标相交时对应的频率为截止频率，当相频特性特性曲线通过-（2k+1）π时对应的频率为穿越频率，在截止频率点处求相位裕度，在穿越频率点处求幅值裕度，公式就不细说了，说下结论，相位裕度越大，幅值裕度越大，系统越稳定，截止频率越大，系统响应也越快，幅值裕度越大，系统对输入信号跟随性越好，感性上来认识就是越像输入曲线，各位同志们可以下来自己在MATLAB里按照这个规律实验一下。有机会的话下次详细讲讲bode下的系统稳定性分析。
D项对系统性能的影响分析：
老规矩，先看仿真结果，再做数学分析。既然没有做任何计算，上来就随便搞一个数字，让比例系数kp=50，这样静态误差小一点，然后让微分项系数kd=20。仿真一波：
图中黄线为加入微分控制的时域响应，蓝色线为纯比例控制，我们发现加入微分量后超调量减小了，振荡也消失了，但是系统的响应速度降低了，这只是一个感性的认识，在工程中使用纯PD控制也很少，毕竟这玩意对噪声太敏感，你要是拿这个控制器去控制电机或者舵机，如果把传感器和主控制器放在电机或舵机附件，那你就会体验到什么叫蹦蹦床的快乐了。所以工程中一般都使用一个叫做超前补偿器的玩意，然后整个控制方法也就被称为不完全微分PD控制（其实不完全微分PID控制用的比较多），好了，先说到这里，总结一下我们现在遇到的问题，
1.怎么从数学角度来证明微分项加入后对系统性能的影响；
2.为什么要使用超前补偿器，他对系统会带来什么影响，为什么超前补偿器噪声不敏感。
下面我们从根轨迹的角度来分析问题1，根轨迹法是经典控制理论中分析系统性能，设计系统模态的一个令人赏心悦目的方法，这里不介绍根轨迹法如何绘制，因为我们有matlab，记得有位大佬说过，matlab为低能的用户提供方便的程序集成，确实，没有matlab，我这种低能的大学生还真就不能进行大量的科研计算，仿真建模，只能在实操中碰壁，没法用仿真指导实操，我总不能遇到什么问题就自己用C编一个函数吧，没那能耐，泰勒展开，快速傅里叶，根轨迹，bode图，那个不得写半天，matlab一个函数的事，咱们不是搞数学的，整那么多事干嘛。扯远了，下面来看看纯比例控制下的根轨迹图：
num=[1]; %kp=50; %kd=20; den=[1 1 -2]; sys=tf(num,den); %bode(sys); rlocus(sys);%求根轨迹 axis([-2.5 2 -6 6]); 我们可以看出，当增益为2时，为临界点，随着增益kp的增大，系统都为负根，系统稳定，但是随着kp的增大，根进入两条与x轴垂直的线内，大家可以看到，根在这两条直线上时，实部为-0.5，是不是和我们之前算的特征值的实部一样，这时候再增大kp，对不起，实部不会变了，虚部绝对值一直增大而已，然后这会造成什么现象，振荡加剧啊，那作为未来的工程师，现在的大学生，是不是要想办法改善一下这种情况，我不就是想让根的实部往左移吗，让根的虚部绝对值越小吗，贪心点的话，我想让根都落在负实轴上，离原点越远越好。既然我们有这样的想法，那我们可以假设让根落在哪个位置，然后用根轨迹上的根与零点连线与实轴正方向夹角-根与极点连线与实轴正方向的夹角=-180°的定理来确定零点应该放在哪个位置，如果我们是加一个微分项，那么就会增加一个零点，只要零点安放位置合适，按照上述原理，就会导致根轨迹的左移，达到我们想要的结果，不信我们验证一波：
加入微分项后系统变为如下（上面部分为pd控制，下面部分为p控制）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d6a898849d17053d11ce38457f53af5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495de6ff1ca6a0e7cf9c651b9f1cadbf/" rel="bookmark">
			Mybatis和JDBC区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天面试中问了这个问题，当时答的不好，现在整理一下。
JDBC是Java提供的一个操作数据库的API；
MyBatis是一个支持普通SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索封装。MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。
MyBatis是对JDBC的封装。相对于JDBC，MyBatis有以下优点：
1. 优化获取和释放
我们一般在访问数据库时都是通过数据库连接池来操作数据库，数据库连接池有好几种，比如C3P0、DBCP，也可能采用容器本身的JNDI数据库连接池。我们可以通过DataSource进行隔离解耦，我们统一从DataSource里面获取数据库连接，DataSource具体由DBCP实现还是由容器的JNDI实现都可以，所以我们将DataSource的具体实现通过让用户配置来应对变化。
C3P0 xml配置：
&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"&gt; &lt;property name="driverClass" value=" oracle.jdbc.driver.OracleDriver "/&gt; &lt;property name="jdbcUrl" value=" jdbc:oracle:thin:@localhost:1521:ora9i "/&gt; &lt;property name="user" value="admin"/&gt; &lt;property name="password" value="1234"/&gt; &lt;/bean&gt; DBCP xml配置：
&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3309/sampledb" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="1234" /&gt; &lt;/bean&gt; DURID xml配置：
&lt;bean name="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;property name="driverClassName"&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;property name="url"&gt; &lt;value&gt;${jdbc_url_gx}&lt;/value&gt; &lt;/property&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/495de6ff1ca6a0e7cf9c651b9f1cadbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97855850185ae096b9f76927670457e9/" rel="bookmark">
			附PPT|阿里巴巴实时数仓最新架构图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1
优酷大数据olap选型 分享嘉宾：五羖,阿里文娱技术专家
分享大纲：
大数据给传统数据技术带来的挑战 市面上各类大数据 OLAP 技术方案一览
优酷不同业务场景的 OLAP 选型 2
网易数据湖ICEBERG实战 范欣欣-网易大数据技术专家
分享大纲：
数据仓库平台建设的痛点
数据湖iceberg核心原理
数据湖iceberg社区现状
网易数据湖iceberg实战之路
3
flink-1.11 hive集成与批流一体 李锐-阿里巴巴技术专家、Apache Hive PMC
分享大纲：
Flink 1.11 中的新特性
Hive 批流一体数仓
4
菜鸟进口实时数仓2.0 张庭-菜鸟-数据&amp;规划部-数据工程师，花名：佳二，毕业于浙江工业大学，计算机科学与技术专业，这个老师分享的太干货了，完全看不出来是一个应届生分享的，所以我就多贴点他的ppt，建议搞实时数仓的都仔细看一遍
分享大纲：
相关背景介绍
进口实时数仓演进过程
挑战与实践
总结与展忘
5
网易实时数仓实践与展望 马进-网易数据科学中心,13年加入网易,先后负责分布式数据库ddb,网易数据运河ndc,rds,流计算等项目,目前专注于实时数仓项目建设。
分享大纲：
架构与残片实践
数据中台融合
计算存储流批一体
数仓实时性分级
6
阿里巴巴搜索推荐实时数仓演进之路 士恒-2014年加入阿里巴巴搜索事业部，主要从事搜索推场业务基础数据研发。
分享大纲：
业务背景
电信应用场景
flink+hologres实时数仓演进
hologres最佳实践
总结 公众号回复“0731”，即可获取ppt下载链接，目前已经上传到百度网盘。
关注小晨说数据，获取更多大厂技术干货分享
回复“spark”，“flink”，“中台”，“机器学习”，“用户画像”获取海量学习资料～～～
你也「在看」吗？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a2e4211c8a6c0e07838bfb4fca69f93/" rel="bookmark">
			Oracle从小白到精通第一天（单行函数，以及date，char，number之间的转换）（尚硅谷学习Oracle笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle学习笔记 1.基本关键字2.select基本用法以及其中一些基本知识3.过滤排序数据使用的是where 条件4.单行函数 1.基本关键字 desc 表名 意思是描述一个表结构order by desc或者asc 降序或者升序排序 一般在select语句的结尾 2.select基本用法以及其中一些基本知识 select * from employees where 条件算数运算符 + - * / 数字和日期可以使用，但是日期只能使用 + -
其中日期应该这样写
select last_name,hire_date from employees where to_char(hire_date,'yyyy-mm-dd')='1994-06-07';select 8*4 from dual; 这样来计算一个数空值包含的数学表达式都为空值列的别名有三种表示方法，第一种 直接空格 后面跟别名，第二种 用as ，第三种用 “ ”来表示。连接符 || 可以把不同的列连接成一列 select first_name||last_name from employees;删除重复行使用 distinct关键字 select distinct department_id from employees; 3.过滤排序数据使用的是where 条件 其中有=， ＞，＜ ，&gt;=,&lt;=,&lt;&gt;huozhe!=;这么几种where语句要紧跟着from语句字符和日期要在单引号中，并且对大小写比较敏感其他的比较运算符有
1.between … and … 在两个范围之间，包含两个边界值
2.in (…，…，…) 等于列表值中的一个
3.like 模糊查询 %是匹配所有 _匹配一个 其中有个转义字符 \ escape ’ \ ’
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a2e4211c8a6c0e07838bfb4fca69f93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee4916faf061e2fe7811b3eef0ccce53/" rel="bookmark">
			虚拟机VMware 14安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装前先关闭杀毒软件和360卫士，注意安装路径不能有中文，安装包路径也不要有中文。
[安装环境]：Win7/Win8/Win10
1.鼠标右击“vmware14”压缩包，选择解压。
2.打开解压之后的文件夹，鼠标右击“VMware-workstation-full-14.0.0.24051”,选择以管理员的身份运行。
3.点击下一步。
4.勾选“我接受许可”，点击下一步。
5.点击“更改”选择软件安装的位置，我这里把安装路径设置到D盘，用户可根据自己的实际情况选择安装的位置（建议不要安装到C盘）。点击下一步。
6.取消勾选检查产品更新和客户体验改进计划，点击下一步。
7.点击下一步。
8.点击安装。
9.安装中会弹出以下对话框，点击取消。
10.点击完成。
11.点击否。
12.双击桌面VM快捷方式，打开虚拟机。
13.输入许可证密钥：AA510-2DF1Q-H882Q-XFPQE-Q30A0，点击继续。
14.点击完成。
15.虚拟机安装完毕，打开界面如下。
注：用户可根据自己的需求在虚拟机里安装（xp、win7、xin8或xin10）系统，虚拟机里安装windows系统方法大致相同，请参考以下安装教程。
附：虚拟机安装windous系统通用步骤：
1.双击桌面VM快捷方式，打开虚拟机。
2. 点击：创建新的虚拟机
3.选择自定义，点击下一步。
4.硬件兼容性，选择最新版本，点击下一步。
5.点击浏览，打开需要安装的系统，我这里打开win7的系统文件（用户可在本文开头提供的win7、win8、win10下载地址下载相应的系统文件），点击下一步。
6.什么都不填，点击下一步。
7.点击是。
8.点击浏览设置虚拟机存放的位置，我这里选择存放到H盘（建议用户选择到除C盘以外的其它盘），点击下一步。
9.继续点击下一步。
10.根据电脑配置，选择处理器数量，我这里保持默认，点击下一步。
11.设置虚拟机的内存大小，建议最少选择512M。我这里选择1024M，点击下一步。
12.点击下一步。
13.点击下一步。
14.下一步。
15.选择创建新的磁盘，点击下一步。
16.选择磁盘容量大小（xp系统建议设置10G以上。Win7及以上系统设置30G以上）点击下一步。
17.点击下一步。
18.点击完成。
19.系统安装中，大约需要30分钟。
20.虚拟机正在安装系统。
21.安装完成，在虚拟机中打开的win7系统界面如下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97fab5a68d08e213debeac8a1fa78793/" rel="bookmark">
			数据交互协议——JSON
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：konishi5202
链接：https://www.jianshu.com/p/4fcb49b55ff6
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
JSON概述 1.1 JSON介绍 JSON：JavaScript对象表示法（JavaScript Object Notation）。是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。JSON采用完全独立于语言的文本格式，但是也使用了类似C语音家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使JSON成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成（一般用于提升网络传输速率）。
JSON解析器和JSON库支持许多不同的编程语言。JSON文本格式在语法上与创建JavaScript对象的代码相同。由于这种相似性，无需解释器，JavaScript程序能够使用内建的eval()函数，用JSON数据来生成原生的JavaScript对象。
JSON是存储和交换文本信息的语法，类似XML。但JSON比XML更小、更快、更易解析；且JSON具有自我描述性、语法简单，易于理解。
1.2 JSON语法 JSON语法是JavaScript对象表示法语法的子集： 数据在键值对中；数据由逗号分隔；花括号保存对象，也称一个JSON对象；方括号保存数组，每个数组成员由逗号隔开，并且每个数组成员可以是JSON对象、数组、键值对 JSON的三种语法： 键/值对key:value，用半角冒号分割。比如"name":“Faye”。文档对象JSON对象写在花括号中，可以包含多个键/值对。比如{“name”:“Faye”, “address”:“北京”}。数组JSON数组在方括号中书写：数组成员可以是对象、值，也可以是数组(只要有意义)。比如{“love”: [“乒乓球”,“高尔夫”,“斯诺克”,“羽毛球”,“LOL”,“撩妹”]}。 JSON的值可以是：数字（整数或浮点数）、字符串（在双引号中）、逻辑值（true or false）、数组（在方括号中）、对象（在花括号中）、NULL。
二、 cJSON介绍 C语言实现json格式的传输，可以在工程文件中配置json库。
cJSON是一个c语言头文件，cJOSN采用链表存储。
cJSON库在使用的时候需要两部，将cJSON.h文件添加到项目中；如果在命令行中进行连接还需要加上-lm表示链接math库。
2.1 源码获取 三、cJSON数据结构和接口 3.1数据结构定义 双向链表
/* cJSON Types: */ #define cJSON_Invalid (0) #define cJSON_False (1 &lt;&lt; 0) #define cJSON_True (1 &lt;&lt; 1) #define cJSON_NULL (1 &lt;&lt; 2) #define cJSON_Number (1 &lt;&lt; 3) #define cJSON_String (1 &lt;&lt; 4) #define cJSON_Array (1 &lt;&lt; 5) #define cJSON_Object (1 &lt;&lt; 6) #define cJSON_Raw (1 &lt;&lt; 7) /* raw json */ #define cJSON_IsReference 256 #define cJSON_StringIsConst 512 /* The cJSON structure: */ typedef struct cJSON { /* next/prev allow you to walk array/object chains.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97fab5a68d08e213debeac8a1fa78793/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/050e6c050c69207ef2b8fbb8fb7826c9/" rel="bookmark">
			代码实现 | 方程组的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		求解方程组的实现 对于方程组，我们分为一元二次方程、一元二次方程、二元一次方程组和线性方程组来分析。下面为大致的划分思路：
一元一次方程 这是最简单的方程，例如a*x=b，利用C语言写出程序：（一元一次非常简单，Java也就不重复了）
C语言： #include&lt;stdio.h&gt; int main() { float a,b,x; scanf("%f%f",&amp;a,&amp;b); x= b/a; printf("%f",x); } 一元二次方程 一元二次方程的求解有多种方法，例如开方法、配方法、因式分解、求根公式等等，我们采用求根公式来进行求解：
求根公式如下：
所以，对于一元二次方程的求解，根据公式求即可。
C语言： #include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() { double a,b,c,disc,x1,x2; char key; while(1) { printf("一元二次方程为ax*x+bx+c=0,请输入a,b,c的值：\n"); scanf("%lf%lf%lf",&amp;a,&amp;b,&amp;c); disc=b*b-4*a*c; if(disc == 0) { x1=-b/(2*a); x2=x1; printf("方程的两个实根为x1=x2=%lf\n",x1); } else if(disc &lt; 0 ) printf("方程没有实数根。\n"); else { x1 = (-b + sqrt(disc))/(2*a); x2 = (-b - sqrt(disc))/(2*a); printf("方程两个实根为x1=%lf,x2=%lf\n",x1,x2); } printf("是否继续？是的话输入y，否输入n\n"); scanf("%s",&amp;key); if(key == 'y') continue; else if(key == 'n') break; else { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/050e6c050c69207ef2b8fbb8fb7826c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0caf286da9cb27d232e6ea5a45d21f79/" rel="bookmark">
			Java8新特性JDK8之收集器 partitioningBy分组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java新特性玩转JDK8之收集器 partitioningBy分组 parttioningBy 分组 按照参数条件将数据分为两组。结果为Map&lt;boolean, List&gt; 类型，一组为符合条件，另一组为不符合条件。 示例 找出集合中长度大于四 和 长度小于等于四的元素。 public class Main { public static void main(String[] args) { List&lt;String&gt; list = Arrays.asList("java", "springboot", "HTML5","nodejs","CSS3"); Map&lt;Boolean, List&lt;String&gt;&gt; result = list.stream().collect(Collectors.partitioningBy(obj -&gt; obj.length() &gt; 4)); // 长度大于四：[springboot, HTML5, nodejs] System.out.println("长度大于四："+result.get(true)); // 长度小于等于四：[java, CSS3] System.out.println("长度小于等于四："+result.get(false)); } } 原文地址：https://www.yuque.com/haomingzi-kowv5/pmcs3t/whdrke
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e4fe5eaba1e0edbaa1879ab4188ba87/" rel="bookmark">
			Tree Recovery poj2255(前序中序遍历建立二叉树)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接：Tree Recovery poj2255
题意：
给出一个前序遍历序列和中序遍历序列，输出后序遍历序列
跟之前的给后序和中序遍历序列一样
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;cmath&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;sstream&gt; using namespace std; typedef long long ll; const int inf = 0x3f3f3f3f; const int maxn = 30; int l[maxn],r[maxn]; string fo_order,in_order; void build(int l1,int r1,int l2,int r2) { if(l1 &gt; r1){ return ; } char root = fo_order[l2]; int k = l1; while(in_order[k] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e4fe5eaba1e0edbaa1879ab4188ba87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9782071b00711d8e388da42685fee2ce/" rel="bookmark">
			Vue子组件的显示与隐藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Vue子组件的显示与隐藏 第一步 使用v-show 1.1 父组件1.2 子组件2 第二步 父子组件传参 2.1 父组件2.2 子组件 Vue子组件的显示与隐藏 在使用Vue开发前端页面的过程中，经常都会遇到需要在父组件中控制子组件的显示/隐藏，比如弹出窗口。最简单的方法就是：通过父子组件间的数据双向绑定来实现。这种方法虽然简单，但只是针对于父与子组件这种关系来实现的。如果是子组件与子组件之间，可以考虑使用Vuex来完成。
另外我自己也是一个前端小白，为了更方便大家理解，我将代码拆分成了两个步骤：
第一步是实现父对子的显示/隐藏的控制（v-show）第二步是实现子组件对自己的隐藏（父子组件参数传递） 完整的代码在2.1与2.2中。
第一步 使用v-show 这一步首先实现在父组件通过v-show对子组件的显示/隐藏进行控制。
父组件中有显示/隐藏按钮，点击后显示/隐藏子组件，效果如下：
1.1 父组件 &lt;template&gt; &lt;div class="contain"&gt; &lt;p&gt;这里是父组件页面&lt;/p&gt; &lt;button @click="showDialog(true)"&gt;显示&lt;/button&gt; &lt;button @click="showDialog(false)"&gt;隐藏&lt;/button&gt; &lt;!-- 这里使用v-show --&gt; &lt;subDialog v-show="dialog_visible"&gt;&lt;/subDialog&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 引入子组件 import subDialog from "@/components/Dialog/subDialog"; export default { components: { subDialog }, data() { return { // 控制子组件显示与隐藏的标识，类型为Boolean dialog_visible: false } }, methods: { showDialog(visible) { this.dialog_visible = visible; } } } &lt;/script&gt; &lt;style lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9782071b00711d8e388da42685fee2ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f24bb58b63b057a789890bc8d7050d13/" rel="bookmark">
			Mysql高级之Mysql各个组件介绍（总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Mysql各个组件 连接器查询缓存可使用的参数 分析器优化器执行器 连接器 1.连接器用来管理连接和进行权限验证 2.一个用户成功建立连接后，即使用管理员的账号对这个用户的权限进行了修改，也不会影响已经存在连接的权限，新连接才可以用新权限 3.建立连接的过程通常比较复杂，所以尽量使用长连接 4.Mysql执行过程临时使用的内存是管理在连接对象里面的 查询缓存 1.之前执行的结果可能会以key-value对的形式直接缓存在内存中，key是查询的语句，value是查询的结果 2.查询缓存的失效非常频繁，只要有一个对表的更新，这个表上所有的查询缓存都会被清空 可使用的参数 query_cache_type = DEMAND //对于默认的SQL语句都不使用查询缓存 select SQL_CACHE * from T from T where ID = 10	//显式的指定SQL语句使用查询缓存 ------------Mysql8之后就没有查询缓存 我认为没有也行，可以加缓存中间件------------------------ 分析器 1.先做词法分析，识别出里面的字符串分别是什么，代表什么 2.语法分析，判断你输入的词是否满足Mysql语法 优化器 1.优化器是在表里面有多个索引的时候，决定使用哪一个索引，或者在一个语句有多表关联的时候，决定各个表的连接顺序 2.分析器是告诉你应该做什么，优化器是告诉你应该怎么做 执行器 1.用来操作文件系统，执行语句 2.开始执行的时候，会判断你有没有执行的权限，如果没有，就会返回没有权限的错误 3.执行的时候，先取出满足条件的第一行（无索引时取表的第一行），然后循环的取满足条件的下一行 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0af15f4a2a74be8392ea87f2a7b3e8c/" rel="bookmark">
			wangeditor支持图片和视频上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在搞 王编辑器 ，但是却不支持视频上传。只能自己去修改源代码。将上传图片变为可支持的上传视频。
如果觉得麻烦 可以安装我的版本。如果已经安装过 请先卸载之前的版本
npm uninstall wangediror@你自己的版本 --save
再执行
npm i guoeditor 以下为修改的全部源代码。即可粘贴复制。
(function (global, factory) { typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' &amp;&amp; define.amd ? define(factory) : (global.wangEditor = factory()); }(this, (function () { 'use strict'; /* poly-fill */ var polyfill = function () { // Object.assign if (typeof Object.assign != 'function') { Object.assign = function (target, varArgs) { // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0af15f4a2a74be8392ea87f2a7b3e8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/021fdc423004dc54b388aea2fc4c7a3f/" rel="bookmark">
			maven配置时报错NB: JAVA_HOME should point to a JDK not a JRE**解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
今天配置maven时，环境变量什么的都配置好了，在cmd输入mvn -v时提示如下图 百度了各种方法，结果总结了以下几点：
第一：
检查JAVA_HOME，path中有没有出现多余的“；”号，有的话直接删除。我仔细检查了一遍，然鹅并没有。
第二：
在JAVA_HOME应该设为C:\Program Files\Java\jdk1.8.0_112\，path中，改为%JAVA_HOME%\bin。之前配置变量的时候，好像末尾都不用加/，但是还是去试了一下，结果，成功。（安装JDK的时候最好是装在除c盘之外的盘）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0e2257bf26218367789e4f6d9532f3b/" rel="bookmark">
			HBase学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1章 HBase 简介 HBase定义：HBase 是一种分布式、可扩展、支持海量数据存储的NoSQL 数据库。
HBase 数据模型 逻辑上是一张表，底层物理存储是kv
HBase 逻辑结构：row_key（逻辑上一行的key），列族（column family），列（column qualifier），region（将高表进行横向切分），cell（每个rowkey中每个列族下的列和其值为一个cell） row_key唯一，是每行数据的key；可以有多个列族（目录）；每个列族内有多个列，列也是数据信息；每个row_key的数据可以拥有不同的列，所以说列也是数据；row_key很多时会将数据划分成不同的region存储（目录），每个region内有所有的列族，每个列族目录下有切分的数据HBase 物理存储结构：逻辑上一个row_key有多个cell，存储时row_key和每一个cell为一行数据，存储为storeFile，存储时会有：row_key，column family，column qualifier，timestamp，type，value timestamp：每个值的版本根据timestamp确定，type为其类型，对于删除操作有delete、deleteCoumn、deleteFamily，value为cell的值数据模型： NameSpace：类似于数据库，每个命名空间下有多个表，HBase有两个自带的：hbase和defaultRegion：类似于表的概念，定义表时只需要声明列族，列（字段）可以动态的改变Row：表中每一行数据都有一个row_key和多个列组成，数据安装row_key的字典顺序存储，查询时只能按照rowkey查询Column：每个列由列族和列限定符进行限定TimeStamp：用于标识不同的版本Cell：rowkey，column family，column qualifier，timestamp唯一确定的单元，cell中数据没有类型，全部以字节码存储 基本架构 region server：region的管理者，每个节点是一个region server。实现类HRegionServer，主要作用是对数据（get，put，delete）和region（splitRegion、compactRegion）的操作master：所有region server的管理者，实现类HMaster，主要作用是对表的操作（create，delete，alter元数据），对region server的操作（分配regions到每个region server，监控region server的状态，负载均衡和故障转移）zookeeper：做master的高可用，region server的监控，元数据的入口，集群配置的维护hdfs：提供底层存储 第2章 HBase快速入门 HBase安装部署 zk正常部署：bin/zkServer.sh start，单节点启动，使用脚本zk.sh start集群启动hadoop正常部署：sbin/start-dfs.sh，sbin/start-yarn.shhbase：解压，修改hbase-env.sh，hbase-site.xml，regionservers软连接hadoop配置文件到 HBase，core-site.xml，hdfs-site.xml分发，启动：start-hbase.sh，关闭：stop-hbase.sh HBase Shell操作 基本操作
进入客户端：bin/hbase shell查看帮助命令：help查看所有表：list 表的操作
创建表：create插入数据：put扫描表：scan查看表结构：describe更新指定字段的数据：get查看指定行或指定列族:列的数据：get统计表数据行数：count删除数据：delete（删除某一列，）、deleteall（删除rowkey的所有数据）、truncate（清空表数据，配置也没了！）删除表：diable、drop变更表信息：alter 第3章 HBase 进阶 架构原理 storeFile：实际存储的物理文件，表目录 -- region目录 -- 多个列族目录 -- 多个storeFile，有序的HFile格式文件MemStore：写缓存，数据线存储在MemStore中，排序后到达刷写时机写到HFileWAL：数据先写都Write-Ahead-Logfile中，再写到MemStore中，系统出现故障时可以通过这个日志文件重建（源码中先写到内存在写到WAL，但是trycatchfinally保证了WAL和内存中数据一致，如果没有写入WAL成功，会回滚） 写流程 client先访问zk，获取hbase:meta表位与哪个region server访问对应的region server，获取hbase:meta表，根据请求的namespace:table/rowkey查询出在哪个region server，并缓存table的region信息到客户端的meta cache方便下次访问与目标region server通信将数据写入wal将数据写入对应的memstore，数据在memstore按rowkey排序向客户端发送ack等待memstore刷写时机，将数据刷写到HFile MemStore Flush 某个memstore的大小到达128M，其所在region的所有memstore都会刷写；当达到了128*4会阻止往memstore写当region server中所有memstore总大小到达heap_size*0.4*0.95，region server会按照memstore的大小排序，依次刷写；当达到了heap_size*0.4会阻止网memstore写到达自动刷写时间，也会触发memstore flush，默认1个小时 读流程 client先访问zk，获取hbase:meta表位与哪个region server访问对应的region server，获取hbase:meta表，根据请求的namespace:table/rowkey查询出在哪个region server，并缓存table的region信息到客户端的meta cache方便下次访问与目标region server通信分别在block cache，memstore，和storeFile查询目标数据，并进行合并将查询到的数据块缓存到block cache将合并后的结果返回给客户端 StoreFile Compaction Minor Compaction，将临近的小文件合并成大文件，不会清理过期和删除的数据Major Compaction，将所有的HFile合并成一个大文件，并清理过期和删除的数据 Region Split 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0e2257bf26218367789e4f6d9532f3b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/422/">«</a>
	<span class="pagination__item pagination__item--current">423/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/424/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>