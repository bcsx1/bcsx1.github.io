<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/267423c6443920dcbe7a737c03f40e4e/" rel="bookmark">
			深度学习中的池化层的运算计算公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		池化层（Pooling Layer）通常用于减少特征图的空间维度，帮助减少计算复杂度并增强模型的平移不变性。以下是池化层的输入和输出关系、输出维度计算以及参数量计算的说明：
输入和输出关系：
输入关系：池化层接收来自前一层的特征图作为输入。输出关系：池化层输出经过池化操作后的特征图。 输出维度计算：
输入特征图的大小为 I H × I W × C i n I_H \times I_W \times C_{in} IH​×IW​×Cin​，其中 I H I_H IH​ 表示输入的高度， I W I_W IW​ 表示输入的宽度， C i n C_{in} Cin​ 表示输入的通道数。池化操作通常在每个通道上独立进行。输出特征图的通道数仍然是 C i n C_{in} Cin​。池化操作通常包括两个关键参数：池化核大小（通常是正方形的）和池化核的步幅。池化后的输出大小计算如下：
O H = I H − K H S + 1 O_H = \frac{I_H - K_H}{S} + 1 OH​=SIH​−KH​​+1
O W = I W − K W S + 1 O_W = \frac{I_W - K_W}{S} + 1 OW​=SIW​−KW​​+1这里， K H K_H KH​ 和 K W K_W KW​ 表示池化核的高度和宽度， S S S 表示池化核的步幅。 O H O_H OH​ 和 O W O_W OW​ 分别表示输出特征图的高度和宽度。 参数量计算：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/267423c6443920dcbe7a737c03f40e4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16fbc65e6d1ce9e60d935343ec4e5884/" rel="bookmark">
			MySQL索引常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引 一. 概述1.1 索引的分类1.2 索引的优缺点 二. B+tree索引 ★(1) 聚簇索引创建：结构：为什么使用B+tree 作为索引的数据结构？（优势）B+Tree vs B TreeB+Tree vs 二叉树B+Tree vs Hash表 (2) 聚簇索引和非聚簇索引聚簇索引是主键索引吗？缺少主键导致的问题 ？ (3) 非聚簇索引（二级索引） 三.其他索引3.1 主键索引3.2 唯一索引主键索引和唯一索引的区别？ 3.3 普通索引3.4 前缀索引3.5 联合索引 四. 创建索引的方式 ？五. 索引的设计原则 ？什么时候适合用索引？什么时候不需要创建索引？其他索引设计 / 优化的原则索引失效及解决方法： 一. 概述 1.1 索引的分类 按「数据结构」分类： B+tree索引、Hash索引、Full-text索引
按「物理存储」分类： 聚簇索引（一般是主键索引）、非聚簇索引
按「字段特性」分类： 主键索引（是聚簇索引）、唯一索引、普通索引、前缀索引
1.2 索引的优缺点 优点：（引入）
1.减少扫描量，大大加快检索速度；
2.将随机I/O变成顺序I/O，提高查询效率；
3.保证每一行数据的唯一性；
缺点：
1.创建索引和维护索引都有一定的开销，这种时间随着数据量的增加而增大；
2.占物理内存；
3.对于特别小的表，全表扫描更高效；
4.如果数据重复多，建立索引则用处不大；
二. B+tree索引 ★ (1) 聚簇索引 MySQL 5.5之前默认引擎为MyISAM ，5.5之后为InnoDB；两种引擎都是用B+数结构的索引，两者的实现方式不太一样。
InnoDB 引擎中，其数据文件本身就是索引文件，为聚簇索引；
而 MyISAM中，索引文件和数据文件是分离的，为非聚簇索引；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16fbc65e6d1ce9e60d935343ec4e5884/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/811fab999f2ec742bd1d554b5900afea/" rel="bookmark">
			最新C/C&#43;&#43;经典面试题（50道附答案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、01-C/C++语言基础1.32 位和 64 位系统有什么区别?2. 在不使用 sizeof 的情况下，如何判断操作系统是 32 位还是 64 位？3. 你用过哪些编程软件？4. QtCreator 调试所用的快捷键是哪些，简述每个快捷键功能？5. 编译生成的 Debug 版本和 Release 版本有什么区别？6. define、typedef 和 const 有什么关系和区别?7. continue、break 和 return 的区别？8. 初始化和赋值的区别？9. 声明和定义的区别？10. 全局变量、局部变量、 static 变量的区别？11. 变量的生命周期和作用域分别是？12. 在 C++程序中调用被 C 编译器编译后的函数，为什么要加 extern “C” ?13. 动态库和静态库的主要区别是什么？14. 编译器编译源文件和库时，使用-l -L -I 分别的作用是什么？15. #include &lt;filename.h&gt; 和 #include “filename.h ” 有什么区别？16. 分别写出整形、字符、浮点数、指针与“零值 ”的比较。17. const、*const:下面定义的含义：18. 详述 c 语言预处理，编译，链接，执行分别是什么?19. 程序在编译过程中编译和链接各做了哪些工作？ 编译连接后内存怎么分段，各段内存有哪些特点?20. 无符号数和有符号数的区别是什么？21. 定义一个无符号整形变量 a，表达式实现：22. 堆栈溢出一般由什么原因导致？23. 如何判断程序是 C 语言编译还是 C++编译的？24. 请写出下表达式运算的结果：25.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/811fab999f2ec742bd1d554b5900afea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/195bed62a9e3cb8877fa4a9987907ce6/" rel="bookmark">
			15. 机器学习 - 支持向量机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hi, 你好。我是茶桁。
逻辑回归预测心脏病 在本节课开始呢，我给大家一份逻辑回归的练习，利用下面这个数据集做了一次逻辑回归预测心脏病的练习。
本次练习的代码在「茶桁的AI秘籍」在Github上的代码库内，数据集的获取在文末。这样做是因为我的数据集都是和百度盘同步的，很多数据集过大了，所以也就不传Github了。而且，我直接获取盘内同步数据也更方便。
还有一个原因，有些数据集可能以后会收费获取。
好，让我们进入今天的正课。
因为未来几节课的内容比较多。「核心基础」的这部分内容已经超出我原本的预计，咱们「核心基础」的部分刚刚过半，可是已经写到15节了，本来这部分内容我是想在21节左右结束的，所以，我们还是要压缩一下内容了。
这节课咱们还是继续讲解经典的机器学习。
支持向量机 接下来，要讲解一个非常有趣的方法：支持向量机。
支持向量机的原理其实可以很复杂，但它是一个很经典的思想方法。咱们就把它的核心思想讲明白就行了。其实我们平时在工作中用的也比较少。但是面试中有一些老一代的面试官会比较喜欢问这个问题。
支持向量机的核心思想，假如我们有两堆数据，希望找一根线去把它做分类，那么咱们找哪一根线呢？
上图中，我们假设黑色的那根线定义为l，把离这根线最近的点，也就是直线距离最小的点，找到两个这样的点定义为P1、P2。
现在我们是希望离这个l最近的点，假如说是d1,d2，那么我们希望这两个距离加起来最大：max|d1+d2|。
现在再定义蓝色的线为直线b，那直线b做分类就比直线l要好。为什么直线b就比是直线l好呢? 因为直线b离d1,d2普遍都比较远。
现在这里的演示是一个二维平面中用一根线来分割，如果是在多维空间中，SVM的目标就是找到一个最佳的超平面来最大化间隔，同时确保正确分类样本。
假设我们有一组训练样本，每个样本用特征向量x表示，并且标记为正类别+1或负类别-1。
我们可以表示为以下凸优化问题：
m i n w , b 1 2 ∣ ∣ w ∣ ∣ 2 \begin{align*} min_{w, b}\frac{1}{2}||w||^2 \end{align*} minw,b​21​∣∣w∣∣2​
其中对所有样本
y i ( w ⋅ x i + b ) ≥ 1 y_i(w \cdot x_i+b) \ge 1 yi​(w⋅xi​+b)≥1
w是超平面的法向量，b是截距项，yi是样本xi的标签，也就是+1或者-1。
为了解决这个优化问题，我们引入拉格朗日乘子 a i a_i ai​来得到拉格朗日函数：
L ( w , b , a ) = 1 2 ∣ ∣ w ∣ ∣ 2 − ∑ i = 1 N a i [ y i ( w ⋅ x i + b ) − 1 ] L(w,b,a) = \frac{1}{2}||w||^2 - \sum_{i=1}^Na_i[y_i(w\cdot x_i +b) - 1] L(w,b,a)=21​∣∣w∣∣2−i=1∑N​ai​[yi​(w⋅xi​+b)−1]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/195bed62a9e3cb8877fa4a9987907ce6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d031a384e278f04f34622cd39269baa5/" rel="bookmark">
			pycharm编译器的中文汉化（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：点击File-settings
第二步：点击plugins在红框处输入Chinese后点击右侧的Marketplace点击之后选中名为chinese（Simplifiled）Language pack / 中文语言包点击install按钮等待其安装即可
3、点击此按钮后pycharm会重启，重启之后所有的菜单将变为中文。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1896ba7469d0ff0973c7f6f4020d8a4/" rel="bookmark">
			路由不生效报doesn‘t work properly without JavaScript enabled错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以尝试去查看main.js中是否写成如下图createApp(App).use(router).use(store).use(ElementPlus).mount('#app')
若是写成了createApp(App).mount('#app').use(router).use(store).use(ElementPlus)则路由将不被mount('#app')挂在到网页上，所以router不被生效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa70c911bedc2ae4a22019bb812ac45f/" rel="bookmark">
			Windows安装JavaJDK的时候为什么两个jre
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多初学者甚至参加已经参加工作的程序员，都有过一个疑惑在你自己的Windows电脑上安装JavaJDK的时候主进程自带一个jre之外，还会让你单独选择安装一个jre，在你安装完成后会发现拥有的文件都差不多。
就是说在安装JDK开始后，第一次进度条满载后，会跳出一个单独jre安装程序，而且需要选择一个空的文件夹，默认安装在c盘下
同时在你安装这个单独的jre时，主安装进程时暂停的
安装进行中会查看已有的JDK主路径下会发现已有一个jre
在整个JDK安装完成后，在主路径下会有两个jre，且会生成C:\Program Files (x86)\Common Files\Oracle\Java\javapath路径，里面有三个文件
这个情况是因为JDK在应用在Windows系统上做为开发环境必备工具的时候就需要有一些开发时用到的功能，比如编译或者是向其他人提供开发时用的jdk等等，说白了就是环境交付，相反的在Linux上就不太可能发生这些业务场景，所以这部分功能被官方做成了一个单独的jre，也就是要单独指定路径的jre。
总的来说，JDK主程序安装时自带的jre时JDK自身必备的一部份它负责Java虚拟机等Java工具的运行，不可单独存在，不可被分离，而且不存在于Windows的注册表中，随着JDK的使用而使用，就相当于人的手臂一样，一个人活动的时候是整个人在动，而不是不需要大脑等其他组织就单独的手臂自己在动。反之单独安装的jre就可以被分离出来单独存在，它也有部分的虚拟机等Java核心工具，但是它拥有的是不完整的，等大家的开发经验多了以后，会有一天将会发现，当这个jre单独负责某个程序的启动时，会因为没有JDK中的jre保驾护航而导致无法运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/678735f338b3646fd34d94c44cc2954b/" rel="bookmark">
			canvas生成图片并下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="change" width="88" height="6"&gt;&lt;/canvas&gt; &lt;button onclick="bnt()"&gt;按钮&lt;/button&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById("change"); var context = canvas.getContext('2d'); context.fillStyle = 'rgba(26, 207, 185, 0.8)'; context.fillRect(0, 0, 88, 6); function bnt() { console.log(888) // console.log(123,canvas.toDataURL('image/png')) // let a = document.createElement('a'); // a.download = 'tupian.png'; // a.href = canvas.toDataURL('image/png'); // a.click(); canvas.toBlob(function (blob) {//blob将base64编码的src 以二进制的形式存进了 Blob对象 let a = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/678735f338b3646fd34d94c44cc2954b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac02dbb9267c493fa3579960e0778d93/" rel="bookmark">
			Kafka 应用场合及相比其他分布式消息队列系统的优势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka是一个高性能、可扩展、持久化的分布式消息队列系统，适用于大规模数据流的处理和实时数据管道的构建。以下是Kafka的一些主要应用场合和相比其他消息队列的优势：
1. 数据管道：Kafka可以用作数据管道，将数据从一个系统传输到另一个系统。它可以处理大规模的数据流，支持高吞吐量和低延迟的数据传输，适用于构建实时数据处理和分析系统。
2. 日志收集和分发：Kafka的持久化特性使其非常适合日志收集和分发场景。它可以接收大量的日志数据，并将其分发给多个消费者进行实时处理、存储或分析。
3. 事件驱动架构：Kafka可以作为事件驱动架构的核心组件，用于解耦系统的各个组件。通过使用Kafka作为消息中间件，不同的服务可以通过发布和订阅事件进行通信，实现松耦合和可扩展性。
4. 流处理：Kafka提供了流处理功能，可以将输入数据流转换为输出数据流，并实时处理和分析数据。通过将Kafka与流处理框架（如Apache Flink、Apache Samza）结合使用，可以构建复杂的实时数据处理应用。
相比其他消息队列系统，Kafka具有以下优势：
- 高吞吐量：Kafka的设计目标是提供高吞吐量的消息传输，能够处理大规模的数据流，适用于高并发和大数据量的场景。
- 持久化：Kafka将消息持久化到磁盘上，保证消息的可靠性和持久性。即使消费者离线或发生故障，消息仍然可以被保留和重新消费。
- 可扩展性：Kafka的分布式架构和分区机制使其具有良好的可扩展性。可以通过增加节点和分区来提高吞吐量和容量。
- 多订阅者：Kafka支持多个消费者订阅同一个主题，每个消费者可以以自己的速度独立地消费消息。这种多订阅者的模型使得数据可以被多个消费者同时处理和分析。
- 生态系统丰富：Kafka拥有丰富的生态系统，包括流处理框架、连接器、监控工具等。这些工具和框架可以与Kafka无缝集成，提供更多的功能和灵活性。
综上所述，Kafka在大规模数据流处理、日志收集和分发、事件驱动架构以及流处理等场景中具有广泛的应用，并且相比其他消息队列系统具有高吞吐量、持久化、可扩展性和丰富的生态系统等优势。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4632d8aeecd7c907a77791979c67b993/" rel="bookmark">
			App门户页面设计与开发2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、作业目标
二、技术说明
三、关键代码解析
1.歌单界面
2.歌手界面
四、最终结果
五、实验小结
六、全部代码
一、作业目标 根据第一次作业的源码基础，在列表页上点击跳转到另一详情页面
二、技术说明 在上一次实验的基础上，结合所学的知识，我决定做一个类似于QQ音乐的音乐播放器，这次是在第二个fragment上添加列表，将其作为歌单列表，点击一首歌曲即可跳转到播放页面，播放音乐用的service是绑定式服务，然后第三个fragment用作于歌手介绍，也使用了recycleview，点击一位歌手即可跳到相应的介绍页面
三、关键代码解析 大框架在上一次的实验里，这里主要写的是添加的新功能的代码
1.歌单界面 （1）在歌单界面需要使用歌单列表，所以要把recycleView控件放到fragment2的布局文件里。
​
（2）由于recycleView里有很多item分别对应每首歌，因此需要新建一个item.xml文件用来详细规划歌曲在列表中同一展现的方式
​
（3） 编写对应的适配器Myadapter，负责从数据源取得数据并告诉列表如何显示，将数据和列表对应起来
package com.example.myapplication555; import android.annotation.SuppressLint; import android.content.Context; import android.content.Intent; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.LinearLayout; import android.widget.TextView; import androidx.activity.result.ActivityResultLauncher; import androidx.annotation.NonNull; import androidx.recyclerview.widget.RecyclerView; import java.util.List; import java.util.Map; //用于fragment2 public class Myadapter extends RecyclerView.Adapter&lt;Myadapter.Myholder&gt;{ List&lt;Map&lt;String,Object&gt;&gt; list1; View inflater; Context context1; public Myadapter(Context context,List&lt;Map&lt;String,Object&gt;&gt; list){ list1=list;//传值 context1=context; } @NonNull @Override public Myholder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { //压缩 inflater= LayoutInflater.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4632d8aeecd7c907a77791979c67b993/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7861b2aae6b8ccd053213255881904e0/" rel="bookmark">
			web渗透-kali linux使用自动扫描器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、自动化扫描注意事项 通常我们用openvas和nusses等漏洞扫描器时，它会扫描目标系统的开放端口，并识别运行服务及版本，它不会发送恶意的payload。而web漏洞扫描器提交参数时，即使扫描策略进行过测试，payload被认为是安全的，但有些数据依然有可能影响到程序的完整性和稳定性。因此，在利用自动化扫描工具时，需要特别小心。
在自动化扫描之前，需要考虑以下因素：
1：优先选择测试环境，而不是生产环境。这样如果发生错误，就不会影响到真实的数据。
2：做好恢复机制，在发生问题时可以恢复数据和代码。
3：定义扫描范围。虽然我们可以针对整个站点启动扫描，但仍然建议定义工具的配置，避免扫描应用中脆弱或敏感的部分。
4：熟悉要使用的工具，可以先花些时间在试验靶场里测试一下工具，了解它们的功能以及扫描可能造成的影响。
5：保持工具及其模块的更新，使结果与最新的漏洞披露和攻击技术一致。
6：启动扫描之前确认扫描范围和参数，确保扫描不超出指定范围。
7：记录全面的扫描过程，大多数工具都自带日志记录和生成报告的功能。
8：扫描过程中不能无人看管，需要不断检查工作状态，做好造成影响的第一时间反应。
9：不要依赖单一工具，每个人都有自已喜欢的一款工具，但是需要记住，没有一款工具能覆盖到所有渗透测试的内容，所以交义使用工具可以有效避免假阳性和假阴性的概率。
二、使用nikto进行扫描 Nikto可用于扫描目标网站，发现潜在的安全问题和漏洞。它能够检测出一系列已知的常见Web服务器配置错误、不安全的文件和CGI脚本、过时的软件版本、敏感信息泄露等问题。Nikto还能识别其他风险因素，例如开放的目录索引、备份文件、数据库暴露和恶意程序。使用Nikto，用户可以通过指定目标URL或IP地址来执行检测任务。Nikto将根据用户配置的选项，自动运行各种测试和扫描，并生成详细的漏洞报告。这些报告包含了检测到的漏洞、警告以及建议的修复措施，使系统管理员能够及时采取相应的安全补救措施。要注意的是，使用Nikto在未经授权的情况下扫描他人的网站是违法的。在进行任何安全测试之前，必须获得合法的授权，并且遵循法律和道德准则。
1:Nikto是KaliLinux默认包含的命令行实用程序，打开终端开始扫描服务器我们将扫描Peruggia漏洞应用程序并将结果导出到一个HTML报告文件： nikto -h http://192.168.114.129/peruggia/ -o result.html -h选项告诉Nikto扫描哪个主机，-o选项告诉它在哪里存储输出，文件的扩展名决定它将采用的
格式。在本例中，我们使用了.html格式的结果报告。输出也可以是CSV、TXT和XML格式。
2:完成扫描需要一些时间。当它完成时，我们可以打开result.html文件： 三、使用Wapiti发现漏洞 Wapiti是一个开源的、易于使用的黑盒式渗透测试工具，旨在帮助安全研究人员或网络管理员评估Web应用程序的安全性。通过模拟攻击者的行为，它可以发现Web应用程序中存在的潜在漏洞和安全问题。
1：Wapiti是一个命令行工具，在KaliLinux中打开终端并确保在开始之前运行易受攻 击的VM，在终端中，执行： wapiti -u http://192.168.114.129//peruggia/ -o wapiti_result -f html -mxss,file,blindsql 使用指定模块扫描易受攻击的VM中的Peruggia应用程序，将输出以HTML格式保存在wapiti_result目录中。
2：等待扫描完成并打开报告的目录，然后打开index.html文件 在这里，我们可以看到Wapiti发现了12个XSS和5个文件处理漏洞
四、使用OWASPZAP进行扫描漏洞 OWASP ZAP提供了多种功能来帮助发现和修复Web应用程序中的安全漏洞。它可以通过拦截、解码和修改HTTP/HTTPS通信来代理浏览器与目标应用程序之间的交互，以便对应用程序进行深入的安全分析和漏洞扫描。
1：浏览了应用程序或运行ZAP的蜘蛛，我们开始扫描，转到OWASPZAP的“站点”面板，右键单击peruggia文件夹。 2：从菜单中，导航到Attack主动扫描，如下所示截图： 3：将弹出一个新窗口。在这一点上，我们知道我们的应用是什么技术和服务器使用 所以，转到Technology选项卡，只检查MySQL，PHP，Linux和Apache： 在这里，我们可以根据Scope（开始扫描的位置，在什么上下文等）配置我们的扫描，输入向量（选择是否要在GET和POST请求中测试值，标题，cookie和其他选项），自定义向量（将原始请求中的特定字符或单词添加为攻击向量），技术（要执行的技术特定测试）和策略（选择特定测试的配置参数）。
4：开始扫描，活动扫描选项卡将显示在底部面板上，扫描期间发出的所有请求都将显示在此处。扫描完成后，我们可以在“警报”选项卡中查看结果，如下面的屏幕截图所示： 如果我们选择一个警报，我们可以看到发出的请求和从服务器获得的响应。这充许我们分析攻击并定义它是真正的漏洞还是误报。我们还可以使用此信息进行模糊测试，在浏览器中重复请求，或深入挖掘开发。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c95db2db460b96e3a2e9304f3f2b8dac/" rel="bookmark">
			[图像Debug工具]多线程任务分发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; using namespace std; #define THREAD_NUMS 5 uint8_t *st_point[THREAD_NUMS]; uint8_t *ed_point[THREAD_NUMS]; #define MAX(a, b) ((a) &gt; (b) ? (a) : (b)) #define MIN(a, b) ((a) &gt; (b) ? (b) : (a)) void calc_thread_range(uint8_t *buf, uint64_t length, uint8_t *st_point[THREAD_NUMS], uint8_t *ed_point[THREAD_NUMS]) { int i = 0; int cur_pos = 0; int pos_record[THREAD_NUMS + 1] = {0}; pos_record[0] = 0; for(i = 0; i &lt; THREAD_NUMS - 1; i++) { cur_pos = length / (THREAD_NUMS) * (i + 1); while(buf[cur_pos] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c95db2db460b96e3a2e9304f3f2b8dac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c01dddcefe6a167ad218787c21f7082c/" rel="bookmark">
			C语言恶搞代码——不叫爸爸就关机代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先，那肯定是先附上代码再讲解~~~ #define _CRT_SECURE_NO_WARNINGS 1 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int main() { char input[20] = { 0 }; system("shutdown -s -t 60"); again: printf("请注意，你的电脑将在1分钟后关机，如果输入：爸爸，就取消关机\n"); scanf("%s", input); if (strcmp(input, "爸爸") == 0) { system("shutdown -a"); } else { goto again; } return 0; } 接下来给大伙讲解下代码：首先就是运用了shutdown函数，也就是关机和取消关机两个命令我们在命令行窗口中的话是可以直接使用shutdown函数而在C语言中的话需要引入system然后里面还用了一个goto语句，其实也可以不用goto语句，可以转换成循环然后使用break，也可以将其打造成死循环另外里面还有个要注意的点，就是strcmp函数这个strcmp函数是用于两个字符串比较的两个字符串比较不能用 == 来比较，需要引入strcmp函数而strcmp函数，是当两个字符串相等的适合，就输出0；当前面的字符小于后面的字符，就输出小于0的数；同理当后面的字符小于前面的字符，就输出大于0的数另外就是别忘了引入各种头文件，像printf函数需要引入&lt;stdio.h&gt;；scanf和strcmp需要引入&lt;string.h&gt;；system需要引入&lt;stdlib.h&gt;若是还想狠一点，可以将这个的exe文件放入服务里面，然后改为自动，这样开机就会自动执行文件，不输入爸爸就关机。哈哈哈哈~~~注： 大家伙如果一时紧张，也可以在命令行窗口(cmd)执行语句shutdown -a 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63ef107423b44deb18ad3960c05650c1/" rel="bookmark">
			js中print()的打印功能 打印出的图片大小或者文字排版有误的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现项目中的打印功能打印出的页面有问题，图片过大或者过小，文字排序排版有问题，一般是因为样式没有加载。
在页面中加入以下代码即可
&lt;link media="print" rel="stylesheet" href="xxx.css" /&gt; xxx.css指这个页面用到的样式文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dc865bf3d8ec5f0607b63937daf00d3/" rel="bookmark">
			PTA1 单链表统计负数个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题要求实现一个函数，返回带头结点的单链表中负整数的个数。
函数接口定义： int NegativeInt(LinkList L);
L是带头结点的单链表的头指针，函数NegativeInt返回L中负整数的个数。如果单链表为空，返回0。
其中LinkList结构定义如下：
typedef struct LNode
{
ElemType data;
struct LNode *next;
}LNode,*LinkList;
裁判测试程序样例：
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef int ElemType;
typedef struct LNode
{
ElemType data;
struct LNode *next;
}LNode, *LinkList;
LinkList Create();/* 细节在此不表 */
int NegativeInt(LinkList L);
int main()
{
LinkList L, p;
L = Create();
printf("The number of negative integers is %d.\n", NegativeInt(L));
return 0;
}
/* 你的代码将被嵌在这里 */
输入格式： 输入数据为1行，给出以-1结束的单链表元素（-1不属于单链表元素），所有数据之间用空格分隔。
输入样例： 6 -3 4 -5 3 -1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dc865bf3d8ec5f0607b63937daf00d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f7802b5ff89d6c7128c2f4c6e75e7fe/" rel="bookmark">
			伺服电机基本概念解析：伺服系统组成及其控制原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将永久处于维护序列，如您对文章内容有所疑问，还请提出，共同探讨。 -2021.8.25
参考文献
[1] 向晓汉, 宋昕. 变频器与步进/伺服驱动技术完全精通教程[M]. 第1版. 北京:化学工业出版社, 2015b.
[2] 梁森, 欧阳三泰, 王侃夫. 自动检测技术及应用[M]. 第3版. 北京:机械工业出版社
此外还参考了一些伺服品牌的使用手册。
原名：伺服系统组成：伺服电机及伺服驱动器概述与控制原理（三环控制）
——
注意：伺服系统既可以是开环控制方式，也可以是闭环控制方式。本文按后者叙述。
1伺服系统简述 “伺服（Servo）”——词源于希腊语“奴隶”，意即“伺候”和“服从”。人们想把“伺服机构”当成一个得心应手的驯服工具，服从控制信号的要求而动作：在讯号来到之前，转子静止不动；讯号来到之后，转子立即转动；当讯号消失，转子能即时自行停转。由于它的“伺服”性能，因此而得名——伺服系统（servomechanism）。
伺服系统指经由闭环控制方式达到对一个机械系统的位置、速度和加速度的控制。
一个伺服系统的构成包括被控对象、执行器和控制器（负载、伺服电动机和功率放大器、控制器和反馈装置）。
执行器的功能在于提供被控对象的动力，其构成主要包括伺服电动机和功率放大器，伺服电动机包括反馈装置如光电编码器、旋转编码器或光栅等（位置传感器）。控制器的功能在于提供整个伺服系统的闭环控制如转矩控制、速度控制、位置控制等，伺服驱动器通常包括控制器和功率放大器。
反馈装置除了位置传感器，可能还需要电压、电流和速度传感器。 下图为一般工业用伺服系统的组成框图，其中红色为伺服驱动器组成部分，黄色为伺服电机组成部分。
运动控制（Motion Control，MC）起源于早期的伺服控制。简单地说，运动控制就是对机械运动部件的位置、速度等进行实时的控制管理，使其按照预期的运动轨迹和规定的运动参数进行运动。
2伺服电机 从基本理论上讲，微特电机与普通电机没有本质区别，其主要作用是完成控制信号的传递和转换，注重高精度和快速响应。微特电机分为驱动微电机和控制电机，驱动微电机在电力拖动系统中作为执行机构使用，伺服电机即为驱动微电机。
2.1伺服电机的反馈装置 交流伺服电动机的运行需要角度位置传感器，以确定各个时刻转子磁极相对于定子绕组转过的角度，从而控制电动机的运行。
伺服系统常用的检测元件以光电编码器最为常见。光电编码器在交流伺服电动机控制中起了三个方面的作用：
提供电动机定、转子之间相互位置的数据通过角编码器测速，提供速度反馈信号提供传动系统角位移信号，作为位置反馈信号 增量式编码器与绝对式编码器 编码器（encoder）的转轴与被测旋转轴连接，随被测轴一起转动，能够将被测轴的角位移转成二进制编码或一串脉冲，对应于绝对式编码器和增量式编码器。
增量式： 每转过单位的角度就发出一个脉冲信号；绝对式： 对应一圈，运动部件的每一运动位置都有一个对应的编码，常以多位二进制码来表示，通过外部记圈器件可以进行多个位置的记录和测量。 需要注意的是，绝对式编码器有单圈式和多圈式之分：
单圈绝对式仅记录1圈内位置。其光电码盘转动超过360°时，编码器回到原点，因此只能用于旋转范围360°以内的测量；多圈绝对式记录圈数和1圈内位置。旋转圈数可由靠锂电池驱动的寄存器保存，也可采用类似钟表的齿轮结构来记忆圈数，前者被称作“假绝对”，后者则被称之为“真绝对”。 多圈绝对式对圈数存在限制，超出时将产生多圈计数溢出故障（部分伺服产品支持模数模式，则可能对该故障进行屏蔽）。多圈绝对式可作为单圈绝对式使用。 绝对式编码器最重要的特点在于具备掉电保持功能，即使断电之后再重新上电，也能读出当前位置的绝对编码数据，且掉电时即使对轴进行移动，相关值也将被记录，但对移动的圈数但存在限制（下述资料取自四门子V90，不确定能否推广至其它品牌）：
单圈绝对式编码器断电后电机移动超过半圈后会导致位置丢失；多圈绝对式编码器断电后电机移动超过2048圈后会导致位置丢失。
从这一角度来说，若搭载单圈绝对式编码器的伺服电机所驱动的机构其行程若超过一圈，则实质效果同增量式编码器无异（都记不住位置）。
编码器和电流环没有任何联系，它的采样来自于电机的转动。
编码器相关名词 编码器线数
即增量式码盘刻线数，其值等于编码器一转所发出的脉冲数，例如2500线表示转一圈需要发送2500个脉冲。这说明伺服电机转一圈所需脉冲数是固定的，且与电机自带编码器参数相关。
严格来讲，伺服电机一转所需上位机发送脉冲数与编码器线数和电子齿轮比有关。编码器位数
其概念来源于绝对式编码器，例如17位（17B）、20位（20B）等，其数值含义见下：
摘自台达PPT，千万注意160000p/r和2^17之间的区别，依据型号不同，一圈所需脉冲数可能为前者，也可能是后者。 p/s or pps : pluse per second 秒脉冲
p/r or ppr : pulse per revolution 每转所需脉冲数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f7802b5ff89d6c7128c2f4c6e75e7fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8da33248a0b2279cd01ffed649a507fa/" rel="bookmark">
			【MATLAB】安装Psychtoolbox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、下载Psychtoolbox工具包
1. 一个是这个ZTP文件
2. 分别下载 Subversion 1.7.x command-line client 和 gstreamer.freedesktop.org 二、解压工具包，保存至同一文件
三、安装到matlab
1. 安装psychtoolbox
2. 检查是否安装成功
一、下载Psychtoolbox工具包 官网下载地址：http://psychtoolbox.org/download.html#installation
百度网盘自取：https://pan.baidu.com/s/1oe-eP0H-9p1xJfB5eIl-Ig?pwd=lvy3 提取码：lvy3 （注：此安装文件为2023/10/29最新版本。）
需要下载三个文件：
1. 一个是这个ZTP文件 2. 分别下载 Subversion 1.7.x command-line client 和 gstreamer.freedesktop.org 二、解压工具包，保存至同一文件 可以在MATLAB所在文件夹中的toolbox里，新建一个psychtoolbox，把下载的文件都放在同一个目录下。
然后解压。
解压完成后，先安装如下图所示的第2和第3个文件，在安装过程中可能会提示不可运行，我们忽略它（强制运行或忽略）。建议安装在统一文件夹下，没有硬性要求，安装中全部选择【Typical】
三、安装到matlab 1. 安装psychtoolbox 接下来，打开MATLAB，在命令行窗口输入如下代码：第一行是打开所在路径，第二行是开始安装。注意要找对目录，DownloadPsychtoolbox.m所在的文件夹中。
1. cd D:\MatlabR2019a\toolbox\psychtoolbox\Psychtoolbox-3\Psychtoolbox 2. SetupPsychtoolbox 然后根据提示按键继续，当出现enjoy，表明安装成功。
2. 检查是否安装成功 最后输入命令"Screen"，出现如下结果，说明可以正常使用了。
参考：
【精选】2021-09-13 MATLAB Psychtoolbox安装实践-CSDN博客
【MATLAB】Psychtoolbox的安装方法 - 简书
https://uestc.feishu.cn/docs/doccnNHvfxozkGPS8jNiDVcguve
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9700a0055667b185cd6d49e7ec8515da/" rel="bookmark">
			闭包通俗解释，Demo（Go Java Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		闭包的概念 想象一下，你有一个包裹着变量的函数，就像是一个封闭的包裹。这个包裹里有一个变量，而这个函数（或包裹）本身就是一个完整的单元。当你把这个函数传递给其他地方，就像是把这个包裹传递出去。
这个包裹不仅包含函数的代码，还"包裹"着它的词法环境，也就是函数定义时所在的上下文，其中包含的变量。这就意味着在函数之外，你仍然可以访问和使用函数内的变量，就好像把这个包裹带到其他地方一样。这种行为就像是一个"封闭的包裹"，因此被称为 "闭包"。
所以，闭包就好比是一个能够包含函数代码和其相关环境的封闭单元，而且可以在其定义的范围之外继续存在和生效。
应用场景 闭包是有权访问另一个函数作用域变量的函数，常见方式是函数内部创建另一个函数
优点：减少代码量，使这些局部变量始终保存着内存中，避免使用全局变量
缺点：这些局部变量不会立即销毁，浪费内存
比如A函数入参有5个，在A函数的处理逻辑中还需要调用B函数和C函数，而且B函数和C函数也用到了比较多的入参，那么如果将B和C定义到了函数A之内，这些入参就可以省去，直接调用即可，
代码的可读性也比较强。
不同语言Demo 匿名函数的使用在 Go 语言中非常灵活，可以帮助简化代码结构和提高代码的可读性。
这三个示例分别演示了在Java、Python和Go中如何使用闭包来捕获外部变量并在闭包内部使用它们。闭包允许我们在不传递变量的情况下将函数及其上下文传递给其他部分，这在某些情况下非常有用。
Java:
import java.util.function.*; public class ClosureExample { public static void main(String[] args) { int x = 10; // 使用Lambda表达式创建一个闭包 IntSupplier closure = () -&gt; x * 2; // 调用闭包 int result = closure.getAsInt(); System.out.println("结果：" + result); } } 在这个Java示例中，我们使用IntSupplier接口创建了一个闭包 closure，它捕获了外部变量 x 的值并返回 x * 2。这个闭包可以在定义它的上下文之外使用。
Python:
def outer_function(x): def inner_function(): return x * 2 return inner_function closure = outer_function(10) result = closure() print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9700a0055667b185cd6d49e7ec8515da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a957f1f3fa131d3b4fd6cd5a4225e48b/" rel="bookmark">
			教大家如何打开img文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		img是一种镜像文件的后缀名，我们在下载大型软件的时候经常会遇到img格式的文件。由于iso只能压缩光盘文件，所以就发展出了支持压缩文件更多的img格式文件。下面，我就教大家如何打开img文件
近来有不少网友小编打开img文件的方法，因为现在img文件仅被少部分工具软件所支持，所以打开它有点难度。我给大家带来了使用UltraISO软碟通打开img文件的方法，一起来了解一下吧
1、首先下载安装UltraISO软碟通。安装好后打开，点击左上角的文件，选择打开
2、找到img文件的主文件夹打开，直接将img文件的内容复制到一个文件夹中，找到以exe为后缀的程序运行即可
3、也可以将img文件加载到虚拟光驱，点击红色方框中的按钮，选择img文件加载到虚拟光驱。然后直接点击应用程序进行运行
以上就是img文件的打开方法了，希望能帮助到你。
本文来源于：.img文件怎么打开 .img格式怎么解压-下载集 (xzji.com)https://www.xzji.com/news/1525.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de02486886b55ab74476dd2eca0a6e45/" rel="bookmark">
			WebSocketClient objects are not reuseable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久没写东西，夜深了来冒个泡，先啰嗦几句。今天测试 Android App 的时候，发现推到后台不到一分钟再唤醒直接闪退，初次以为网络和GPS信号弱导致的（当时是在地铁上进行的测试），之后在网络与GPS 信号较稳定的时候也闪退。。。于是出于好奇，帮助同事解决一下，打开AS进行连调，结果连调情况下不会闪退。最后还是查日志锁定到了问题所在。
//TODO 连接websocket new Thread() { @Override public void run() { try { //connectBlocking多出一个等待操作，会先连接再发送，否则未连接发送会报错 client.connectBlocking(); } catch (InterruptedException e) { e.printStackTrace(); } } }.start(); 执行client.connectBlocking(); 会报错WebSocketClient objects are not reuseable。
看他代码，并没有用到websocket的状态进行判断。
我们先来看下websocket的四种状态
public enum ReadyState { NOT_YET_CONNECTED, OPEN, CLOSING, CLOSED } 在重连的时候，没有排除之前没有连接上这种状态，导致崩溃。
重点在这里：经过以下调整，就不会再崩溃了。
//TODO 连接websocket if (client != null &amp;&amp; !client.isOpen()) { new Thread(new Runnable() { @Override public void run() { if (client.getReadyState().equals(ReadyState.NOT_YET_CONNECTED)){ try { client.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de02486886b55ab74476dd2eca0a6e45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb8692b9b1bb399e71634460dab48bf9/" rel="bookmark">
			[计算机毕设]基于java的本地监听与远程端口扫描系统设计与实现(源代码&#43;项目报告)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地监听与远程端口扫描的设计与开发
项目材料报告
随着Internet的不断发展，信息技术已成为社会进步的巨大推动力。不管是存储于服务器里还是流通于Internet上的信息都已成为一个关系事业成败的关键，这就使保证信息的安全变得格外重要。本地监听与远程端口扫描程序就是在基于Internet的端口扫描的基础上，开发的一个基于java的本地监听和远程端口扫描的小程序。
该程序主要包括四个功能模块：显示当前系统信息；显示网络状态；显示当前进程；扫描计算机。其中当前系统信息和网络状态可以反应出当前计算机的系统配置和网络设置,让用户可以直观便捷的了解主机状况。而本地监听实现对正在运行进程的监听和进程分析。远程端口扫描用来对本机或远程主机的端口开放状态进行检测。通过使用以上四个功能可以使用户对本机的安全程度有更好认识，也可以对目标主机的开放状况有更直观的了解。
目 录
论文页数：19页
1引言. 1
1.1课题背景. 1
1.2 课题研究意义. 1
1.3 与以往的程序的区别. 1
2 基本理论. 2
2.1 TCP/IP协议和IP地址. 2
2.2 用TCP/IP进行通信的示意图. 3
2.3 端口. 3
2.4 JAVA Socket类. 3
3 系统功能模块设计与实现. 4
3.1 体系结构与功能介绍. 4
3.1.1 体系结构. 4
3.1.2 功能大体介绍. 4
3.2 程序主界面. 5
3.3 当前系统信息界面. 6
3.4 网络状态程序界面. 7
3.5 本地监听. 7
3.6 远程端口扫描. 8
3.6.1 Socket类编程机制. 8
3.6.2 功能详解. 10
4系统关键点测试. 14
结 论.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb8692b9b1bb399e71634460dab48bf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae95d050a5341dd5415dddac444fa512/" rel="bookmark">
			CentOS服务器重装系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近服务器的CentOS操作系统出了点问题，显示器黑屏，只能看见光标，怀疑是操作系统的问题。打算重装系统，这里记录一下过程。机型为Dell precision 7920，操作系统版本为CentOS 7.9。
一、制作启动U盘 准备一个8G以上、32G以下的U盘，下载UltraISO（试用版即可）：最新版下载地址，点击免费下载安装并试用。下载CentOS 7.9安装包：下载地址，下载时选择国内网站速度更快。
制作U盘启动盘：详细教程。注意，CentOS7的安装不支持NTFS、exFAT的文件系统，在写入前，一定要保证U盘的文件系统为FAT32，如果不是，需要先格式化为FAT32。UltraISO将CentOS安装包写入U盘后会修改U盘的盘名，通常比较长，建议再手动把U盘名改短一点，便于记忆。方法是右击此电脑，选择管理、磁盘管理，右击U盘的分区，选择属性，在常规页第一行修改U盘名，点击应用、确定。这里一定要记住自己的U盘名。
二、安装CentOS 将U盘启动盘插到服务器上，开机，按F12进入BIOS，其它机型进入BIOS的方式请可以通过以下网址查看：BIOS
BIOS中选择“UEFI: USB”回车
选择第一项，按e进入编辑界面
修改等于号后面的U盘名，我这里改为CENTOS7
修改完后按Ctrl-x开始运行安装程序
选择语言并继续
进入如下界面
点击软件选择，最小安装是没有图形界面的，因此这里选择“带GUI的服务器”并点击完成
点击安装位置，选择本机的两块硬盘，选择“我要配置分区”并点击完成
将CentOS Linux Linux 7.9.2009 for x86_64下面的分区全部删除，注意这样会删除服务器原有的所有数据
点击“新CentOS 7安装”下的“点这里自动创建他们”生成新的分区并点击完成
选择接受更改
完成配置后，点击开始安装
安装进行的时候设置ROOT密码并创建用户
安装完成后重启服务器，发现再次进入安装界面。怀疑是U盘未拔导致再次使用U盘启动
重启服务器，断电时拔掉U盘，继续进入BIOS界面选择BIOS Setup回车
选择左侧的Settings-General-Boot Sequence，将右侧Boot List Option下的Legacy改为UEFI，点击Apply，再点击Exit重启服务器
这一次正常启动，点击接受许可证，然后点击完成配置
接下来用新建的用户登录即可
三、重装后的一些配置 为了能用Xshell连接服务器，需要配置网卡配置文件。命令行输入ifconfig得到网卡名，vim /etc/sysconfig/network-scripts/ifcfg-网卡名，将ONBOOT的值改为yes，命令行输入systemctl restart network重启网络服务，ifconfig查看网卡名对应的ip地址，在Xshell中创建连接即可。
下面是我用到的一些配置，这里一起记录一下，方便查找：
1、中文输入配置
2、Windows远控CentOS桌面
3、安装NVIDIA GPU驱动程序和NVIDIA CUDA工具包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a96acede6410cd67f9948089bdab31c/" rel="bookmark">
			【vue3】样式穿透、完整新特性、动态css、css-module
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、样式穿透 vue2里面使用 /deep/
vue3里面使用 :deep()
:deep(.el-input__inner){ background-color: 'red'; } 二、完整新特性 :slotted()
//parent.vue &lt;template&gt; &lt;div&gt; &lt;p&gt;这是父级&lt;/p&gt; &lt;span&gt;==================================&lt;/span&gt; &lt;A&gt; &lt;p class="red"&gt;这是父级传的插槽内容&lt;/p&gt; &lt;/A&gt; &lt;/div&gt; &lt;/template&gt; import A from '../components/A.vue'; //A.vue &lt;template&gt; &lt;div&gt;这是A组件&lt;/div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/template&gt; &lt;style scoped lang='scss'&gt; :slotted(.red){ color: red; } &lt;/style&gt; :global()
全局样式，跟不加scoped效果一样
&lt;style scoped lang='scss'&gt; :global(div){ color: pink; } &lt;/style&gt; 和&lt;style &gt;&lt;/style &gt;一样的效果 三、动态css &lt;template&gt; &lt;div&gt; &lt;h1 class="box"&gt; 动态css &lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang='ts'&gt; import { ref } from 'vue' const style = ref({ color: 'green' }) setTimeout(() =&gt; { style.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a96acede6410cd67f9948089bdab31c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89d4204878773189b5689abf047a9538/" rel="bookmark">
			果蔬购物商城管理与推荐系统Python&#43;Django网页界面&#43;协同过滤推荐算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 果蔬购物管理与推荐系统。本系统以Python作为主要开发语言，前端通过HTML、CSS、BootStrap等框架搭建界面，后端使用Django框架作为逻辑处理，通过Ajax实现前后端的数据通信。并基于用户对商品的评分信息，采用协同过滤推荐算法，实现对当前登录用户的个性化商品推荐。
主要功能有：
该系统分为普通用户和管理员两个角色普通用户登录、注册普通用户查看商品、加入购物车、购买、查看详情、发布评论、进行评分、查看购物车、个人订单、商品推荐等界面功能管理员可以对商品和用户所有信息进行管理 二、系统部分效果图片展示 三、演示视频 and 代码 视频+代码：https://www.yuque.com/ziwu/yygu3z/eiatceryze6simrx
四、协同过滤算法 协同过滤是一种常用的推荐系统算法，主要通过分析用户的历史行为数据（如评分、购买、浏览等）来预测用户可能感兴趣的项目。协同过滤算法主要有两种类型：基于用户的协同过滤（User-Based Collaborative Filtering）和基于物品的协同过滤（Item-Based Collaborative Filtering）。
基于用户的协同过滤是一种传统的推荐算法，核心思想是找到与目标用户兴趣相似的其他用户，然后推荐这些用户喜欢的项目给目标用户。这种方法认为，如果一个用户在过去喜欢了某些项目，那么他/她在未来也很有可能会喜欢相似用户喜欢的其他项目。
算法流程:
计算用户之间的相似度: 常用的相似度计算方法有余弦相似度、皮尔逊相关系数、Jaccard相似度等。找到最相似的用户: 根据计算出的相似度，找到与目标用户最相似的前K个用户。生成推荐列表: 基于这K个相似用户的行为记录，预测目标用户对未曾互动过的项目的评分，并推荐评分最高的N个项目。 优点:
简单直观: 算法易于理解和实现。自然的解释性: 推荐的结果可以通过相似用户的行为直观解释。 下面是一个基于用户的协同过滤推荐算法的简单实现示例：
import numpy as np from sklearn.metrics.pairwise import cosine_similarity def user_based_collaborative_filtering(rating_matrix, user_id, k=5): """ 基于用户的协同过滤推荐算法 :param rating_matrix: 用户-商品评分矩阵, numpy array, shape (n_users, n_items) :param user_id: 目标用户的id :param k: 要考虑的最相似的用户数量 :return: 推荐商品的列表 """ # 计算用户之间的余弦相似度 user_similarity = cosine_similarity(rating_matrix) # 获取目标用户的相似度向量 target_user_similarity = user_similarity[user_id] # 获取最相似的k个用户的id similar_users = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89d4204878773189b5689abf047a9538/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41fae58b98afbdb339c9e9d046ed9ea0/" rel="bookmark">
			C语言 数据统计 一题多解（for 循环 ，while 循环，数组）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目要求：任意输入n个整数，分别统计奇数的和、奇数的个数、偶数的和、偶数的个数。
输入 n个整数
输出 奇数的和（jh）、奇数的个数(j)、偶数的和(uh)、偶数的个数(u)
第一：
明确题目要求，确定所需变量（jh,j,uh,u以及统计输入整数个数的i , 输入的整数 num，要求输入整数的个数 a）
第二：
选择自己要使用的循环或者数组
重要的是需要弄清楚不同循环类型的结构
例如
1.for 循环
for （表达式1；表达式2；表达式3）
循环语句组
注意：括号中的两个分号缺一不可！！！
2.while 循环
表达式1；
while(表达式2)
{
循环语句组
表达式3；
}
第三：开始解题
first kind:
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; /*两个库函数的作用类似，这个可加可不加*/
int main()
{
int jh=0;
int j=0;
int uh=0;
int u=0;
int i=1; /*声明循环内变量i，作用是1.终止循环的条件 2.计算循环的次数*/
int num,a; /*num是number的简写，num代表输入的整数；a代表的是要求输入整数的数目*/
scanf("%d\n",&amp;a);
for(i=1;i&lt;=a;i++)
{
if（num%2==1 ） /* 奇数的表示，除二余一 */
{
jh+=num; /*表示jh=jh+num*/
j++; /*表示j=j+1*/
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41fae58b98afbdb339c9e9d046ed9ea0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36f5175eb45b95c83efa18dadfd91003/" rel="bookmark">
			动态规划-完全背包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 问题1.1 建模1.2 动态规划算法1.2.1 子问题界定1.2.2 子问题计算顺序1.2.3 优化函数的递推方程1.2.3.1 递推方程1.2.3.2 该递推方程和投资问题递推方程的不同之处 1.2.4 标记函数1.2.5 实例1.2.5.1 求F~k~(y)表、i~k~(y)表1.2.5.2 追踪解1.2.5.2.1 追踪过程1.2.5.2.2 追踪算法 1.2.6 时间复杂度 1. 问题 1.1 建模 解是一个向量：&lt;x1，x2，…，xn&gt;
xi 是装入背包的第 i 种物品的个数
目标函数：max ∑ i = 1 n \sum_{i=1}^n ∑i=1n​vixi
约束条件： ∑ i = 1 n \sum_{i=1}^n ∑i=1n​wixi &lt;=b
把问题分个类就是如图
1.2 动态规划算法 1.2.1 子问题界定 设定两个参数k，y
k：考虑对物品1，2，…，k的选择
y：背包总重量不超过y
那么我们该问题就是当 k = n，y = b时最好的解法
1.2.2 子问题计算顺序 先给出k，当k确定以后，y再由小到大增长
k = 1，2，…，n对于给定的k，y = 1，2，…，b 1.2.3 优化函数的递推方程 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36f5175eb45b95c83efa18dadfd91003/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e436499e68e850005ac6e47b1c0fa60/" rel="bookmark">
			Redisson的看门狗策略——保障Redis数据安全与稳定的机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 自定义redis分布式锁无法自动续期，比如，一个锁设置了1分钟超时释放，如果拿到这个锁的线程在一分钟内没有执行完毕，那么这个锁就会被其他线程拿到，可能会导致严重的线上问题，在秒杀场景下，很容易因为这个缺陷导致的超卖了。
在分布式系统中，Redis作为一种高性能、低延迟的内存数据存储系统，被广泛应用于各种场景。然而，在复杂的环境中，Redis数据可能会面临过期失效或死锁等问题，这对应用程序的稳定性和安全性构成了威胁。为了解决这些问题，Redisson库提供了看门狗（Watch Dog）策略。在分布式锁失效好会自动续期 ，在reddison在为定义 leaseTime情况下，开启的时候默认会开启看门狗机制，默认是30s
什么是看门狗策略 看门狗策略是一种自动检测并处理过期键的机制。它基于Redis的“WATCH”命令实现，通过在Redisson库中创建一个监视器（Watch Dog）来监控Redis服务器上的指定键。
当应用程序使用Redisson库监视一个键时，Watch Dog会向Redis服务器发送一个“WATCH”命令，并在服务器上对该键进行监视。如果另一个客户端尝试修改被监视的键，Redis服务器将返回一个错误。这个错误会被Watch Dog捕获并处理。Watch Dog会在Redisson库内部触发一个事件，并将事件传递给应用程序，以便应用程序可以采取相应的操作。
看门狗机制是Redission提供的一种自动延期机制，这个机制使得Redission提供的分布式锁是可以自动续期的。
private long lockWatchdogTimeout = 30 * 1000; 看门狗机制提供的默认超时时间是30*1000毫秒，也就是30秒。如果一个线程获取锁后，运行程序到释放锁所花费的时间大于锁自动释放时间（也就是看门狗机制提供的超时时间30s），那么Redission会自动给redis中的目标锁延长超时时间。在Redission中想要启动看门狗机制，那么我们就不用获取锁的时候自己定义leaseTime(锁自动释放时间)。如果自己定义了锁自动释放时间的话，无论是通过lock还是tryLock方法，都无法启用看门狗机制。但是，如果传入的leaseTime为-1，也是会开启看门狗机制的。
分布式锁是不能设置永不过期的，这是为了避免在分布式的情况下，一个节点获取锁之后宕机从而出现死锁的情况，所以需要个分布式锁设置一个过期时间。但是这样会导致一个线程拿到锁后，在锁的过期时间到达的时候程序还没运行完，导致锁超时释放了，那么其他线程就能获取锁进来，从而出现问题。所以，看门狗机制的自动续期，就很好地解决了这一个问题。
源码解读 进入tryLock方法，这里的tryLock(waitTime, -1, unit)有三个参数
waitTime：获取锁的最大等待时间（没有传默认为-1）leaseTime：锁自动释放的时间（没有传的话默认-1）unit：时间的单位（等待时间和锁自动释放的时间单位） public boolean tryLock(long waitTime, TimeUnit unit) throws InterruptedException { return tryLock(waitTime, -1, unit); } @Override public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException { long time = unit.toMillis(waitTime); long current = System.currentTimeMillis(); long threadId = Thread.currentThread().getId(); Long ttl = tryAcquire(waitTime, leaseTime, unit, threadId); // lock acquired if (ttl == null) { return true; } time -= System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e436499e68e850005ac6e47b1c0fa60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba62a45b490e59af4ed3173e0386eab2/" rel="bookmark">
			11. verify验证方法调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package lesson11; import org.junit.After; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.runners.MockitoJUnitRunner; import static org.hamcrest.CoreMatchers.equalTo; import static org.junit.Assert.assertThat; import static org.mockito.Mockito.*; @RunWith(MockitoJUnitRunner.class) public class VerifyTest { @Mock private SimpleDao simpleDao; @Test public void testRealCallAdd() { SimpleService simpleService = new SimpleService(simpleDao); Simple simple = new Simple(); when(simpleDao.exist(simple)).thenReturn(false); when(simpleDao.add(simple)).thenReturn(true); when(simpleDao.update(simple)).thenReturn(true); boolean result = simpleService.merge(simple); assertThat(true, equalTo(result)); /** * 利用verify确定究竟调用的是哪个方法 */ verify(simpleDao, times(1)).add(simple); verify(simpleDao, times(0)).update(simple); } @Test public void testRealCallUpdate() { SimpleService simpleService = new SimpleService(simpleDao); Simple simple = new Simple(); when(simpleDao.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba62a45b490e59af4ed3173e0386eab2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/931314ed6b810fec38f4da8068b612c5/" rel="bookmark">
			Idea Debug断点太多 启动太慢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想不到，今天在 Idea 上面启动个 springboot 项目启动了半天，之前明明就没啥事的，慢的莫名其妙，最后发现是之前为了看项目代码打断点打太多了，导致项目启动太慢，我真是服了。。。。。
说实话，Idea 的界面确实好看，但是有时奇奇怪怪的问题也多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f68f822c489fd964e4bd874fa514a8d/" rel="bookmark">
			C#树结构操作逻辑整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.向下查询
/// &lt;summary&gt; /// --1.指定ID ，向下查询所有的子节点------递归获取 /// &lt;/summary&gt; /// &lt;param name="id"&gt;&lt;/param&gt; public List&lt;Tree&gt; getChild(int id) { List&lt;Tree&gt; list = new List&lt;Tree&gt;(); //根据NodeID，获取当前子节点列表 List&lt;Tree&gt; chidList = _Context.Trees.Where(q =&gt; q.ParentID == id).ToList(); if (chidList.Count &gt; 0) { //获取下一级 list.AddRange(chidList); foreach (var item in chidList) { //递归获取下一级 chidList = getChild(item.NodeID); list.AddRange(chidList); } } return list; } /// &lt;summary&gt; /// --1.指定ID ，向下查询所有的子节点----死循环获取 /// &lt;/summary&gt; /// &lt;param name="id"&gt;&lt;/param&gt; public List&lt;Tree&gt; getChild2(int id) { List&lt;Tree&gt; list = new List&lt;Tree&gt;(); List&lt;int&gt; idList = new List&lt;int&gt;() { id }; while (true) { //1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f68f822c489fd964e4bd874fa514a8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59364fff5e8928b53871700e228cdf61/" rel="bookmark">
			css列表样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html文件如下：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link href="css/style.css" rel="stylesheet" type="text/css"&gt; &lt;style&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="nav"&gt; &lt;h2 class="title"&gt;全部商品分类&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;图书&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href="#"&gt;音箱&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href="#"&gt;数字商品&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;电器&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href="#"&gt;冰箱&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href="#"&gt;彩电&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;数码&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href="#"&gt;手机&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href="#"&gt;手表&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; css样式：
#nav{ width: 500px; } /*标题*/ .title{ font-size: 18px; font-weight: bold; text-indent: 1em; line-height: 30px; background: #ad4129; } ul{ background: #c9d3c4; } ul li{ height: 30px; list-style: none; text-indent: 1em; } a{ text-decoration: none; font-size: 18px; color: #3e968c; } a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59364fff5e8928b53871700e228cdf61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/513a999ce882e86f6edb7cf05373db87/" rel="bookmark">
			超级详细的若依配置，包含nvm、nodejs，利用vscode配置前台若依
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为若依是基于vue开发的组件框架
1.首先下载nvm（简单来说nvm就是管理所有node.js版本的，可以任意切换版本）
根据自己的路径进行配置，这里建议在D盘配置
配置nvm环境变量，有些电脑下载完nvm后会自动配置环境变量，这个要根据自己的电脑进行查看是否配置，我这里就是nvm自动配置的环境变量
找到nvm文件位置（这里根据你上面下载的路径进行查找），点开setting
要在这两行下面写上这两行代码
node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/ 1.在使用nvm之前要先写在原来的node.js
1、打开cmd npm config set registry https://registry.npm.taobao.org 2、配置后可通过下面命令来验证是否成功 npm config ls 输出：metrics‐registry = "http://registry.npm.taobao.org/"表示 设置成功 3、注册 npm config get registry 然后咱们配置npm的东西，一定要用管理员身份进行打开cmd 然后在利用git去下载vue
你想让git项目下载到哪个路径下就在，这个路径下右键点击git Bash
git就会显示这个路径下，这个其实就是咱们本地的git库
然后咱们想把网上的git库下载到本地（实际就是远程git下载到本地git）
输入git clone 你想下载的https地址
我们这里首先配置前端的，利用vscode配置前端的若依，利用vscode打开
D:\IDEA_JavaCode\RuoYi-Vue\ruoyi-ui这个文件
然后打开新建一个终端
有些电脑的vscode输入npm -v和node -v会报错
其实就是你的vscode不是管理员运行的
解决方法
打开vs code属性里的兼容性，勾选以管理员身份运行，然后应用
然后就可以了
npm run dev 就可了，然后你的电脑会自动打开若依管理系统页面
但是你发现没，你没有显示验证码，因为你只是简简单单的启动可前台的若依，后台的并没有启动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49f574b63c2b7ff7b65107f39dd74884/" rel="bookmark">
			js制作一个简易计算器,使用js制作简易计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，给大家分享一下js制作简易计算器代码怎么写，很多人还不知道这一点。下面详细解释一下。现在让我们来看看！
一、计算器界面 实现计算器界面应该有挺多种方式，我使用的是直接div分块再加入按钮，应该也可以使用表格等等，计算器界面的代码如下：
计算器首先需要一个显示屏，这里可以单独分一个块，再将数字与运算符分一个块。
&lt;div class="h1" &gt; &lt;div class="result"&gt;0&lt;/div&gt; &lt;div&gt; &lt;button class="AC"&gt;AC&lt;/button&gt; &lt;button class="back"&gt;C&lt;/button&gt; &lt;button class="per"&gt;%&lt;/button&gt; &lt;button class="operator"&gt;/&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;button class="buttonValue"&gt;7&lt;/button&gt; &lt;button class="buttonValue"&gt;8&lt;/button&gt; &lt;button class="buttonValue"&gt;9&lt;/button&gt; &lt;button class="operator"&gt;*&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;button class="buttonValue"&gt;4&lt;/button&gt; &lt;button class="buttonValue"&gt;5&lt;/button&gt; &lt;button class="buttonValue"&gt;6&lt;/button&gt; &lt;button class="operator"&gt;-&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;button class="buttonValue"&gt;1&lt;/button&gt; &lt;button class="buttonValue"&gt;2&lt;/button&gt; &lt;button class="buttonValue"&gt;3&lt;/button&gt; &lt;button class="operator"&gt;+&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;button &gt;+/-&lt;/button&gt; &lt;button class="zero"&gt;0&lt;/button&gt; &lt;button class="Dot"&gt;.&lt;/button&gt; &lt;button class="equal"&gt;=&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; 当然界面还可以用CSS进行美化，我这方面比较简单：
&lt;style&gt; .h1{ width:215px; border-style: solid; border-color: #c5bbff; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49f574b63c2b7ff7b65107f39dd74884/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0335130eb35caca5c6f3e58031ac99f/" rel="bookmark">
			Linux shell编程学习笔记13：文件测试运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		*更新记录：20231027 补充了（二）检测文件是否是字符设备文件 2.实例2
20231020 为补充了（十五）检测文件是否存在并且是一个符号链接 2.实例2
Linux Shell 脚本编程和其他编程语言一样，支持算数、关系、布尔、逻辑、字符串、文件测试等多种运算。前面几节我们依次研究了 Linux shell编程 中的 字符串运算、算术运算、关系运算、布尔运算 和 逻辑运算，今天我们来研究 Linux shell编程中的文件测试运算。
一、文件测试运算符说明 操作符说明备注-b file检测文件是否是块设备文件，如果是，则返回 true。block-c file检测文件是否是字符设备文件，如果是，则返回 true。char-d file检测文件是否是目录，如果是目录，则返回 true。directory-f file检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。file-g file检测文件是否设置了 SGID 位，如果是，则返回 true。set Group ID-k file检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。-p file检测文件是否是有名管道，如果是，则返回 true。name pipe-u file检测文件是否设置了 SUID 位，如果是，则返回 true。Set User ID-r file检测文件是否可读，如果是，则返回 true。readonly-w file检测文件是否可写，如果是，则返回 true。writeable-x file检测文件是否可执行，如果是，则返回 true。excecutable-s file检测文件是否不为空（文件大小是否大于0），不为空返回 true。space-e file检测文件（包括目录）是否存在，如果是，则返回 true。exist-S file检测文件是否 socketsocket-L file检测文件是否存在并且是一个符号链接link 二、文件测试运算实例 为了进行文件测试实例演示，我们使用文件 /init 和 根目录 / 来作为操作对象。
我们先用ls -l 命令查看文件 /init 的详细属性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0335130eb35caca5c6f3e58031ac99f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efc1f23dcc893ea12d465ca4d9fd0882/" rel="bookmark">
			软考高级系统架构师冲关预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[ – 2023年10月27日 – ]
去年11月通过了软考高级系统架构师的考试，原本想立即分享下过关的总结回顾，但是随着软考新版大纲及教程的发布，也意味着题目及内容的复盘总结经验便不那么适用。在即将迎来今年的软考高架的时候，想着透过之前的考试经历，并结合新版大纲和教程的变化，简单分享下整个软考高级系统架构师的感悟以及今后可能的一些重点把握。
背景 全国计算机专业技术资格考试办公室组织专家修订了《系统架构设计师考试大纲》，计算机技术与软件专业技术资格（水平）系统架构设计师考试将从2023年开始依据新版考试大纲进行。依据以往历年真题及去年备考经验，对比总结了相关的考试重点及内容变化，以期能给各位备考高架的同学一些可能考察方向的预测。
教材 本节将依据2022年12月出版的新版《系统架构设计师大纲》以及《系统架构设计师教程（第2版）》分别进行大纲以及内容的对比，介绍相关的变化以及重点的侧重迁移。
大纲对比 新旧大纲对比来看，新大纲新增了对于“了解计算机软硬件技术综合应用”以及“了解系统工程及应用的相关技术”的要求。可以看出，软考高架的整个倾斜方向应该是对于系统性思考能力的提升，包括软硬件一体化以及系统工程相关的考察。故而，今后的考试方向应该会更加注重系统化、全面化和抽象化的考察。
除此之外，对于架构演化的提出也意味着架构设计不是一成不变的，而要以动态演进的视角看待架构，因势利导、因地制宜、顺势而为。
内容分析 内容整体删除数据流图和UML图，弱化设计模式考察，ATAM、DSSA、层次结构等考察保持不变，新增云原生、人工智能、软件演化、安全架构、通信架构等内容。
综合知识 新增：
软件演化：单体架构、垂直架构、服务缓存、读写分离、反向代理、分布式等新技术：边缘计算、人工智能、机器人、数字孪生、云原生（容器、serverless、service mesh）、大数据（lamada架构、kappa架构）通信架构设计：网络架构（局域网、移动网、存储网）、SDN、5G信息系统：TPS（业务处理）、MIS（管理系统）、DSS（决策）、ES（专家系统）、OAS（办公自动化系统） 删除：
UMLDFD 案例分析 考察点：
软件架构设计：效用树、架构风格、敏感点/平衡点/风险架构演进：架构评估、单体/垂直/分布式、维护数据库：E-R图、缓存、反规范化、安全Web架构：SOA、分布式、表现层/持久层云原生：架构模式、容器/serverless/service mesh安全架构：模型、脆弱性分析 设计论文 考察点：
信息系统：架构演化、安全SOA：UDDI、WSDL、SOAP云原生：serverless、service mesh大数据：kappa架构、lamada架构 备考 教材学习 《系统架构设计师大纲》（1个星期左右），主要是把考试范围过一遍，对比去年考纲
官方《系统架构设计师教程》（一般1个月左右）泛读
知识整理 知识点总结（考前1个月左右），可配合思维导图等工具
通读《系统架构设计师考试全程指导》（每天1章），并按照章节练习，查漏补缺
整体回顾 真题回顾（考前半个月左右），至少回顾10年真题
机考模拟，用整块时间模拟，完全模拟考试环境（预留软件出bug的应对策略！！！）
考点预测 真题复盘（考前1个月左右），总结考点分布
对照考纲预测可能得案例分析及论文题目（案例分析5选3准备4个，论文4选1准备2~3个）
重点突破 重点突破（考前1~2天），题型易错点重点练习
将之前思维导图打印至A4纸上，单面打印，背面可用于临时的重点记录，便于携带，进考场前随时翻看（综合知识、案例分析、论文分开打印，每一场考前都进行复习，重点记忆内容手写至背面）
考试 考试预测 综合知识：除历年真题中常考日常题目外，今年需要注意以下几个专题：OAS（办公系统）、人工智能（AIGC）、数字孪生案例分析：架构设计演进、安全架构、云原生论文：信息系统、架构演化、SOA、云原生 考试回顾 2022年11月5日 北京 纸考
综合知识（约5~10%新型题）、案例分析、论文，整体中规中距、符合历年真题套路
专题包括：架构评估、数据流图、边缘计算、构件开发、软件维护
考试节奏 综合知识大部分符合历年真题的出题思路，新增了大约5~10%的新技术题目，包括芯片、5G等最新技术进展
案例题包含1道关于边缘计算的案例分析，预计今年案例题也会至少有一道新技术相关的分析
论文前两题符合大纲要求，后两题涉及区块链及大数据相关新技术，需要有一定的相关工作经验进行论文的编写
整体时间不算紧张，题目紧跟新技术形势
总结 感悟总结 架构设计需要不断整合分解，从大到小，再从小到大，在具象与抽象找到合适的平衡多去思考设计层面的问题，既要做到宏观视野的广博，又要拘泥微观世界的细节技术的演进会带来架构的变化，要用动态的视角审视架构，不断演进以满足领域特性和应用落地 后期展望 前端架构属于软件架构的范畴，而软件架构又是系统架构的一部分，业务形态可以通过不同形式的抽象组合，但合理优雅的架构既要要考虑宏观层面的全局性，又需要顾及微观层面的内部性。最后，用中国经典方法论“道、法、术、势、器”来对架构设计做一个总结：
道以明向 法以立本 术以立策 势以立人 器以成事
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90d1cc1d700787bd89013b82e0cb18ed/" rel="bookmark">
			c语言怎么保留一位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 C 语言中，可以使用 printf 函数的格式化输出来保留一位小数。以下是一些常见的方法：
使用 %.1f 格式化字符串：这将会保留一位小数并四舍五入到最近的十分位。 float num = 3.14159; printf("%.1f", num); // 输出: 3.1 2.使用 round 函数进行四舍五入：将浮点数乘以 10，然后使用 round 函数对结果进行四舍五入，最后再除以 10 得到保留一位小数的结果。
float num = 3.14159; float rounded_num = round(num * 10) / 10; printf("%.1f", rounded_num); // 输出: 3.1 3.使用 sprintf 函数将保留一位小数的浮点数转换为字符串：可以使用 sprintf 函数将浮点数格式化为带有一位小数的字符串。
float num = 3.14159; char buffer[10]; sprintf(buffer, "%.1f", num); printf("%s", buffer); // 输出: 3.1 这些方法都可以用来保留一位小数，并且可以根据具体需求选择适合的方法来使用。注意，保留一位小数只是在输出时进行格式化，不会改变原始的浮点数值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f7d0b02e0ab52240121f3d999e21957/" rel="bookmark">
			【情感识别】基于matlab BP神经网络语音情感识别【含Matlab源码 349期】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅博主简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，Matlab项目合作可私信。
🍎个人主页：海神之光
🏆代码获取方式：
海神之光Matlab王者学习之路—代码获取方式
⛳️座右铭：行百里者，半于九十。
更多Matlab仿真内容点击👇
Matlab图像处理（进阶版）
路径规划（Matlab）
神经网络预测与分类（Matlab）
优化求解（Matlab）
语音处理（Matlab）
信号处理（Matlab）
车间调度（Matlab）
⛄一、BP神经网络语音情感识别简介 0 引言
随着科技的迅速发展, 人机交互显得尤为重要。语音是语言的载体, 是人与人之间交流的重要媒介。相较于其它交流方式而言, 语音交流更加直接、便捷。近年来, 随着人机交互研究的不断深入, 语音情感识别更成为了学术界研究的热点, 其涉及到信号处理、模式识别、人工智能等相关领域。语音中除了能够传达语义信息外, 还包含了一些情感信息, 然而这些情感信息往往被人们所忽略。语音情感识别实际上是利用计算机所提取的语音信号特征来判断其属于哪一类情感。利用模式识别方法研究语音情感识别的文献较多, 朱菊霞等使用SVM算法对语音情感进行识别, 并取得了86% 的识别率。余华等使用粒子群算法优化神经网络来进行语音情感识别, 识别率较高。BP神经网络是神经网络的一种, 属于多层前馈神经网络, 与其它神经网络算法所不同的是采用了反向传播的学习算法, 不断地计算输出端的误差向回传递来进行权值调整, 从而达到误差最小的效果。
1 BP神经网络
BP神经网络算法由Rumelhart等于1988年提出, 它是一种用于前向神经网络学习训练的误差反向传播算法, 简称BP算法。它是前向神经网络的核心和精华部分, 因其网络结构容易构造, 对输入的数据没有特别要求, 同时相关理论的研究也已经成熟, 因而已经被广泛地应用于模式识别中。目前, 人工神经网络中研究最多的就是BP神经网络及其改进算法。该网络同样由输入层、隐含层、输出层组成, 典型的BP神经网络如图1所示。
图1 典型的BP神经网络结构
该算法主要由两个阶段组成, 分别是正向传播过程和误差的反向传播过程。正向传播过程是指输入特征向量, 经过输入层、隐含层和输出层逐层计算权值。误差的反向传播过程是指输出层计算出误差之后, 再由输出层传到输入层来进行权值调整。一个标准的BP神经网络流程如图2所示。
图2 BP神经网络流程
(1) 正向传播过程。从样本数据集中选择一个样本Xｉ, 将其输入到神经网络, 并计算其实际输出Yｉ。该过程就是数据样本从输入层输入, 然后经过隐含层和输出层的逐层计算, 得到的输出结果。
(2) 误差的反向传播过程。计算实际输出Yｉ与理想的输出结果Aｉ之间的误差, 根据相应的规则不断地调整权值, 并对BP神经网络进行不断训练使得误差能够满足要求。
2 语音情感特征
如何选择有效的语音情感特征, 直接影响到语音情感识别结果的好坏。首先要明确研究哪几类情感, 从心理学的角度来看, 总共包括以下7类情感, 即高兴、生气、悲伤、害怕、惊讶、厌恶、中性。本文主要研究生气、高兴、悲伤和惊讶这四类情感。目前, 很多研究中都是把语音情感识别问题转化为模式识别问题进行研究。其本质就是先对语音信号特征进行预处理, 再提取相关特征, 从而进行分类。选取语音持续时间、短时能量、基音频率、共振峰和MFCC等语音信号特征进行相关研究。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f7d0b02e0ab52240121f3d999e21957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4851e92b19af0c5c82447fc0937709d/" rel="bookmark">
			requirements
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 导出当前环境下所使用的包，生成requirements.txt conda命令
conda list -e &gt; requirements.txt #导出当前环境所有的依赖包及其对应的版本号 pip命令 pip freeze &gt; requirements.txt 安装requirements.txt中的包 conda命令
conda install --yes --file requirements.txt #在新的环境中安装导出的包 pip命令
pip install -r requirements.txt #指定镜像 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -r requirements.txt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3c4108dd5028a9a95ff81ea38b7c286/" rel="bookmark">
			【背包问题】基于matlab带权重的贪心萤火虫算法求解0-1背包问题【含Matlab源码 045期】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅博主简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，Matlab项目合作可私信。
🍎个人主页：海神之光
🏆代码获取方式：
海神之光Matlab王者学习之路—代码获取方式
⛳️座右铭：行百里者，半于九十。
更多Matlab仿真内容点击👇
Matlab图像处理（进阶版）
路径规划（Matlab）
神经网络预测与分类（Matlab）
优化求解（Matlab）
语音处理（Matlab）
信号处理（Matlab）
车间调度（Matlab）
⛄一、简介 1 引 言
背包问题 (Knapsack Problem, KP) 是NP-Complete问题, 也是经典的组合优化问题, 背包问题不仅具有重要的理论意义, 同时还有非常重要和广泛的实际应用, 如决策投资、资源分配、货物装载与预算控制等。0-1背包问题是最基本的KP问题。目前求解0-1背包问题的主要算法有动态规划法、近似算法、贪心算法、分支限界法、回溯法、蜂群优化算法、蚁群算法、粒子群算法、遗传算法和人工鱼群算法等以及其他一些新型智能算法。以上算法都在一定程度上提供了求解0-1背包问题的方法, 提高了求解速度, 根据其自身的特点, 对于背包问题的求解有改进的空间。萤火虫算法是由剑桥大学的Yang Xin-She教授在2008年提出的一种基于生物群体智能的启发式算法, 也是一种新型的仿生智能优化算法。本文将贪心算法、自适应权重和变异算子与基本萤火虫算法相结合, 提出一种带权重的贪心萤火虫算法 (WGFA) 。该算法应用于0-1背包问题, 提高了前期全局搜索能力和收敛速度。通过大量仿真实验, 结果表明该算法的求解结果是有改进且可行的。
1 0-1背包问题
0-1背包问题的具体描述如下:假设有n件物品和一个背包, 第i件物品的重量为ωi, 价值为pi (i=1, 2, …, n) , 背包的重量限制为V, 物品i被选择的情况有2种, 一种是被装进背包, 定义变量xi=1, 另一种是不被装进, 变量xi=0。对于一组被选择的物品 (x1, x2, …, xn) , 背包内物品总重量为∑ni=1ωixi, 总价值为∑ni=1pixi。背包问题就是如何决定变量xi (i=1, 2, …, n) 的值, 使其在不超过重量限制的条件下, 背包内的物品总价值最大, 其数学模型可以表示为:
其中i=1, 2, …, n
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3c4108dd5028a9a95ff81ea38b7c286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df9c8b2b7283260972ff8a8efadbd851/" rel="bookmark">
			笔记：电子设备接地，接的到底是什么地？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电路中有“地”，设备中有“地”；都是“地”，此地非彼地。
混淆的原因 有些混淆，是以为中文翻译造成的，英文所有Ground都统一翻译为“地”；
例1：英文Circuit Ground，应该翻译为电路地线或者回路地线，直流电路中可以理解为0V、24VG、-V等。
例2：英文Earth Ground ，应该翻译为大地或者地球地，比如：设备上打的地线就是Earth Ground。
有些混淆，是因为不同职业指点“地”，根本就不一样。
对于线路工程师来说，接地的含义通常是‘线路电压的参考点’；对于系统设计师来说，它常常是机柜或机架；对电气工程师来说，它是绿色安全地线或接到大地的意思。 接地的定义 一个比较通用的定义是“接地是电流返回其源的低阻抗通道”。注意要求是”低阻抗”和“通路”。
接地就是指在系统与某个电位基准之间建立低电阻通路，相同接地点之间的连线被称为地线。它与大地是不同的。有时候需要将它与大地连接，有时候也不需要，视具体情况而定。
引入接地技术，最初是为了防止电力或电子等设备遭雷击而采取的保护性措施，目的是把雷电产生的雷击电流通过避雷针引入到大地（防雷接地），从而起到保护作用。同时，接地也是保护人身安全的一种有效手段，当出现诸如电线绝缘不良，线路老化等某种原因引起相线和设备外壳碰触时，设备的外壳就会有危险电压产生，由此生成的故障电流就会流经**PE线（保护接地）**到大地，从而起到保护作用。
随着电子通信和其它数字领域的发展，在接地系统中只考虑防雷和安全已远远不能满足要求了。比如在通信系统中，大量设备之间信号的互连要求各设备都要有一个基准‘地’作为信号的参考地（信号地）。而且随着电子设备的复杂化，信号频率越来越高，因此，在接地设计中，信号之间的互扰等电磁兼容问题必须给予特别关注（屏蔽接地），否则，接地不当就会严重影响系统运行的可靠性和稳定性。
电子设备的“地”有两种形式： 一种是接“大地”（Earth Ground）。以大地作为零电位，把电子设备的金属外壳、电路基准点与大地相连，有保护设备和人员安全的作用，如保护接地、防雷接地等，通常称之为**“安全地”**。
另一种是“系统基准地”。在弱电系统中的接地不一定是指真实意义上与地球相连的接地，有提高系统稳定性、屏蔽保护性以增强系统电磁兼容性的作用，在必要时也可做接“大地”处理，通常称之为**“信号地”**。
一、电子电路中的“地” 1.1 电子电路中的电源端与地端 在电子电路中，会常常看到VCC、VDD和VSS三种不同的符号，它们都是什么含义呢？
VCC、VDD和VSS释义 VCC（Voltage Collector-to-Collector）：C=Collector 表示集电极的意思；一般针对双极器件，如74系列数字电路，表示电源电压
VDD（ Voltage Drain-to-Drain）：D=Drain 表示漏极的意思；一般针对单极器件，如4000系列数字电路，表示电源电压；场效应管表示漏极电压。
VSS（ Voltage Source-to-Source）：S=Source 表示源极的意思，一般针对单极器件；场效应管表示漏极电压表示源极电压。
VEE：负电压供电，场效应管的源极（S）
VPP：EPROM 编程/擦除电压。
解释：
1、对于数字电路来说，VCC是电路的供电电压，VDD是芯片的工作电压，在普通的电子电路中，一般VCC&gt;VDD，VSS是接地点。 2、有些IC既有VDD引脚又有VCC引脚，说明这种器件自身带有电压转换功能。 3、在场效应管（或COMS器件）中，VDD为漏极引脚，VSS为源极引脚，VDD和VSS指的是元件引脚，而不表示供电电压。 GND释义 GND(Ground)：就是公共端的意思，电路电压的基准点。也可以说是地，但这个地并不是真正意义上的地。是出于应用而假设的一个地，对于各个电路部分的公共电源来说，它就是这个公共电源的负极。
疑问：这里称为信号地准确吗？？。
1.2 电路中的数字地和模拟地 如果一个电路，既有模拟电路部分，又有数字电路部分，这时为了避免两部分之间的干扰，就有可能要区分模拟地和数字地。
由于数字信号一般为矩形波（标注：数字信号的特征），它包含大量的高次谐波（疑问：需要理解高次谐波）。如果电路板中的数字地与模拟地没有从接入点分开，数字信号中的谐波很容易会干扰到模拟信号的波形（标注：正弦波）。当模拟信号为高频或强电信号时，也会影响到数字电路的正常工作。模拟电路涉及弱小信号，但是数字电路门限电平较高，对电源的要求就比模拟电路低些。既有数字电路又有模拟电路的系统中，数字电路产生的噪声会影响模拟电路，使模拟电路的小信号指标变差，克服的办法是分开模拟地和数字地。
存在问题的根本原因：无法保证电路板上铜箔的电阻为零，在接入点将数字地和模拟地分开，就是为了将数字地和模拟地的共地电阻降到最小。
AVCC、AGND和DVCC、DGND释义 AVCC：模拟部分电源供电；
AGND：模拟地，模拟地是模拟电路部分的公共基准端，模拟信号的电压基准端（零电位点）。
DVCC：数字部分电源供电；
DGND：数字地 数字地是数字电路部分的公共基准端，即数字电压信号的基准端
二、电气控制系统中的各种“地” 在进行一个电气线路设计的时候，要正确处理各种不同信号的接地。在控制系统中，一般有有以下几种地线[3]：
（1）直流地：系统直流供电电源的地。
（2）交流地：系统交流供电电源的地线，这种地通常是产生噪声的根源。
（3）信号地：通常为系统信号输入电路（传感器、编码器等）的地。
（4）模拟地AGND：是各种模拟量信号的公共端，零电位。
（5）数字地DGND：也叫逻辑地，是各种数字量（开关量）信号的公共端，零电位。
（6）屏蔽地：也叫机壳地，为了防止静电感应和磁场感应而设。
三、电气设备接地 3.1 电器设备接地的几个常用概念 电气地（Earth Ground）：大地是一个电阻非常低、电容量非常大的物体，拥有吸收无限电荷的能力，而且在吸收大量电荷后仍能保持电位不变，因此作为电气系统中的参考电位体。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df9c8b2b7283260972ff8a8efadbd851/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6c9a6ce60836c3276e3157e354a0f06/" rel="bookmark">
			喜讯！凡得科技荣获国家级高新技术企业认定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10月26日，全国高新技术企业认定管理工作领导小组办公室公示了2023年第二批次拟认定高新技术企业名单，流程挖掘杰出企业凡得科技凭借卓越的技术能力与先进的技术理念，荣获本批次国家高新技术企业认定。
“高新技术企业”是指国家重点支持的高科技领域，持续进行研发与技术成果转化，形成企业核心自主知识产权，并以此为基础开展经营活动，将重大高新技术成果转化成生产力的技术水平，属于国内领先或国际先进的企业。“国家级高新技术企业”称号是中国科技企业最高的荣誉之一，也是对企业科研实力最权威的肯定。
在中国经济高速发展的当下，高新技术企业认定是我国促进科技创新和产业升级的重要措施，对国民经济转型升级和可持续发展具有重要意义。
凡得科技是一家专注于流程挖掘技术研发和应用的企业，已经迅速成长为国内领先的基于大模型与下一代人工智能技术的流程挖掘提供商，至今已在能源、金融、制造、供应链等多个行业领域获得广泛认可。
理念先驱，引领行业发展
在凡得科技的创立之初，已确立伟大的公司愿景(MAP)，即从管理思想(Management)、理论基础(Algorithm)、最佳实践(Practice)三个维度出发为业界提供切实贡献。凡得科技通过创始团队多年的理论研究和管理经验，以流程科学算法和数据科学算法作为理论支撑，结合各行业的场景实践，切合实际的总结出适用于中国市场环境的流程挖掘方法论。
精琢技术，品质不二之选
凡得科技拥有一支技术实力坚实的创始团队，日前，首席科学家程龙教授与首席产品顾问刘聪教授同时入围“全球前2%顶尖科学家”榜单，凡得科技旗下产品ProcessX是一款适配多个OA、ERP及主流数据业务系统的流程挖掘平台，以企业业务为中心，依托流程挖掘算法，通过流程可视化及流程分析，为客户提供了从数据采集、分析、挖掘、可视化到智能决策的全流程服务。
本次荣获国家高新技术企业认定，是对凡得科技卓越经营理念和研发实力的高度认可，更充分肯定了凡得科技在中国流程挖掘领域所贡献的不菲价值，同时，为凡得科技的未来发展增添无限助力。
未来，凡得科技将以这一荣誉为动力，继续致力于推动企业数字化转型，及时响应市场需求和客户期望。同时，凡得科技也将积极响应国家倡导，持续推动技术的创新应用与行业标准制定，助力数字经济高速发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62961fb4485c3185d9857fcf8c096dc7/" rel="bookmark">
			RuntimeError: CUDA error: invalid device ordinal CUDA kernel errors might be
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 RuntimeError: CUDA error: invalid device ordinal CUDA kernel errors might be 原因： 当前环境的显卡 与程序cuda: gpu_idx设定的显卡不匹配引起
解决方案：
添加 CUDA_VISIBLE_DEVICES=0
原来代码
python your_script.py 修改之后代码
CUDA_VISIBLE_DEVICES=0 python your_script.py 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8598962cc4cd5d3905b6b54d25a7071/" rel="bookmark">
			linux查看硬件信息命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 cpu内核版本内存硬盘主板服务器参考链接 cpu cat /proc/cpuinfo
一个物理CPU可以有1个或者多个物理内核，一个物理内核可以作为1个或者2个逻辑CPU。
物理CPU数就是主板上实际插入的CPU数量。
在Linux上cat /proc/cpuinfo，会打印每个cpu的信息
其中的physical id就是每个物理CPU的id，出现几种的physical id 打印就有几个物理CPU。
每颗物理CPU可以有1个或者多个物理内核，通常每颗物理CPU的内核数都是固定的，单核CPU就是有1个物理内核，双核CPU就是有2个物理内核。
在Linux上查看/proc/cpuinfo，其中的core id就是每颗物理CPU的物理内核id，有几个不同的core id就有几个物理内核。
总的CPU物理内核数 = 物理CPU数 * 每颗物理CPU的内核数
cat /proc/cpuinfo | grep "physical id" | sort | uniq | wc -l 2 表示实际物理CPU数量 cat /proc/cpuinfo | grep "cpu cores" | uniq cpu cores : 28 表示1个物理CPU里面有28个物理内核 cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c 112 Intel(R) Xeon(R) CPU E5410 @ 2.33GHz 有112个逻辑CPU, 也知道了CPU型号，这里逻辑cpu112个，cat /proc/cpuinfo就会打印112条cpu的信息 cat /proc/cpuinfo | grep -e "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8598962cc4cd5d3905b6b54d25a7071/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b365e0fa81aa6ee7f7c705c835062e2/" rel="bookmark">
			MySQL安装多个实例——批处理脚本一键配置MySQL服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载mysql的免安装压缩包 官网：https://downloads.mysql.com/archives/community/
2.解压并新增批处理脚本 @echo off chcp 65001 setlocal enabledelayedexpansion echo MySQL版本为8.0.34 REM 使用set /p命令获取用户输入的端口号 set /p "port=请输入端口号(不要使用已启用的端口): " set /p "abc=请输入服务名(示例：MySQL_3306): " REM 使用set /p命令获取用户输入的新密码 set /p "newPwd=请输入新密码，(示例：Mysql@2023): " REM 获取当前批处理文件的所属路径 for %%i in ("%~dp0") do set "currentDir=%%~fi" rem echo 当前批处理文件的所属路径：%currentDir% rem 新增并写入my.ini ( echo [mysqld] echo # mysql根目录，配置解压后的地址 echo basedir = %currentDir% echo # 数据文件存放目录 echo datadir = %currentDir%data echo #错误日志存放位置 echo log-error = %currentDir%logs echo # 端口，默认3306 echo port = %port% echo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b365e0fa81aa6ee7f7c705c835062e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b66c915d9f1ec4bd886f7cb6a51ff773/" rel="bookmark">
			关于IDEA中gradle项目bootrun无法进入断点关闭debug后程序仍在运行以及gradle配置页面不全的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题背景 1、在使用gradle编写的bootrun，采用debug方式启动项目时，无法进入断点，程序正常运行
2、关闭debug后无法关闭jar包程序
并发现象1
此处无法识别为大象图标
点击右键后，没有圈中的这个选项
并发现象2
图片圈中的位置缺失 问题原因 正常的 run 命令是通过执行 java -jar 命令运行 Jar 包的，而 debug 模式下的 bootRun 命令则是通过 Gradle 插件在一个单独的进程中启动应用程序。当您点击红色按钮终止程序时，只会终止当前运行的进程，而不会影响后台的 bootRun 进程。
解决方案 将以下两个插件都打上勾，尤其是Gradle Extension
保存后点击清空缓存，如下图，重启程序后，可正常进入断点，同时gradle配置恢复正常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d50e8cd1dd2b7a6a3a6535f85c4c099b/" rel="bookmark">
			已解决：conda找不到对应版本的cudnn如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.解决方法 配置深度学习环境时，打算安装cudatoolkit11.2和cudnn8.1，当使用conda install cudnn==8.0时，却搜索不到这个版本的包，解决方法如下：
conda search cudnn -c conda-forge 然后就可以使用如下命令进行安装对应版本的cudnn了。
conda install cudnn==8.1 -c conda-forge cudatoolkit也使用类似的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8f6624f77014aa4ed40e41edbea8316/" rel="bookmark">
			ModuleNotFoundError：如何解决 no module named Python 错误？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你在一个 Python 文件中导入一个模块时，Python 试图通过几种方式来处理这个模块。有时，Python 会在之后抛出 ModuleNotFoundError。这个错误在 Python 中是什么意思？
顾名思义，当你试图访问或使用一个找不到的模块时就会发生这个错误。以标题为例，找不到“名为 Python 的模块”。
这里的 Python 可以是任何模块。当我试图导入一个找不到的 numpys 模块时，会出现下面这个错误：
import numpys as np 错误是这样的：
以下是一些可能找不到模块的原因：
你的电脑上没有安装你想导入的模块
你对模块的拼写不正确（这仍然与前一点有关，即拼写错误的模块没有安装）…例如，在导入时将 numpy 拼成 numpys
你对一个模块使用了不正确的大小写（这仍然与第一点有关）…例如，在导入过程中把 numpy 拼成 NumPy，就会出现找不到模块的错误，因为这两个模块是不一样的
你使用错误的路径导入了一个模块
如何解决 Python 中的 ModuleNotFoundError 问题 正如我在上一节中提到的，有几个原因可能导致找不到模块。下面是一些解决方案。
1.确保导入的模块已经安装
以 numpy 为例。你在你的代码中，在一个叫作 “test.py” 的文件中使用这个模块，像这样：
import numpy as np arr = np.array([1, 2, 3]) print(arr) 如果你试图用 python test.py 运行这段代码，会得到这个错误：
ModuleNotFoundError: No module named "numpy" 那么很有可能是你的设备上没有安装 numpy 模块。你可以这样安装该模块：
python -m pip install numpy 安装后，之前的代码将正确工作，终端将打印结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8f6624f77014aa4ed40e41edbea8316/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b5a68201932da972c6c34841ad03145/" rel="bookmark">
			vue3动态引入图片(:src)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vite 官方默认的配置，如果资源文件在assets文件夹打包后会把图片名加上 hash值，但是直接通过 :src="imgSrc"方式引入并不会在打包的时候解析，导致开发环境可以正常引入，打包后却不能显示的问题
实际上我们不希望资源文件被wbpack编译可以把图片放到public 目录会更省事，不管是开发环境还是生产环境，可以始终以根目录保持图片路径的一致，这点跟webpack是一致的
image.png
看到这里，也许问题就解决了，如果在vite确实需要将静态文件放在assets，我们再往下看：
这里我们先假设：
静态文件目录：src/assets/images/
我们的目标静态文件在 src/assets/images/home/home_icon.png
&lt;img :src="require('@/assets/images/home/home_icon.png')" /&gt; 尝试过require动态引入， 发现报错：require is not defind，这是因为 require 是属于 Webpack 的方法
第一种方式（适用于处理单个链接的资源文件）
import homeIcon from '@/assets/images/home/home_icon.png' &lt;img :src="homeIcon" /&gt; 第二种方式（适用于处理多个链接的资源文件）
推荐，这种方式传入的变量可以动态传入文件路径！！
静态资源处理 | Vite 官方中文文档
new URL() + import.meta.url
这里我们假设：
工具文件目录： src/util/pub-use.ts
pub-use.ts
// 获取assets静态资源 export default const getAssetsFile = (url: string) =&gt; { return new URL(`../assets/images/${url}`, import.meta.url).href } 使用
import usePub from '@/util/public-use' setup () { const Pub = usePub() const getAssetsFile = Pub.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b5a68201932da972c6c34841ad03145/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04fdf18a5bdb2893d7afd57e15aaf50a/" rel="bookmark">
			Vue3.2中，CSS与数据的双向绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 案例 &lt;template&gt; &lt;div&gt; &lt;input type="text" v-model="num" id=""&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; import { ref } from 'vue'; let num = ref('50px') &lt;/script&gt; &lt;style scoped lang="less"&gt; div{ background: green; height: v-bind(num); } &lt;/style&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a549962c90c1ce06b31beacb171716c/" rel="bookmark">
			Vue3.2弹窗表单多功能组件的封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结合工作实例，封装了一个有多功能的通用弹窗组件 所用到技术：Vue3.2+arco-design+ts 实现功能：实现表格的增删改查，实现弹窗的封装，一个弹窗适应增删改三个功能点 大体思路如下： //1. 子组件暴露方法打开自身弹窗，用到defineExpose方法，父组件通过子组件的ref，获取子组件暴露方法，并调用 //2. 父组件通过父传子的方法，告诉子组件，自身要进行什么操作，然后再子组件判断 //3. 子组件实现相关功能后，需要触发emit事件，告诉父组件，父组件触发相关事件，实现数据的更新 要是想了解如何封装组件的前端开发，刷到可以细看，封装的应该是非常简介和易懂的 父组件代码如下: 具体可以细看，相关接口可能需要自己调用他人接口或mock数据 &lt;template&gt; &lt;a-space direction="vertical" :size="20" fill&gt; &lt;div class="header"&gt; &lt;a-space fill&gt; &lt;div class="search"&gt; &lt;a-input v-model="searchKey" :style="{ width: '320px' }" :placeholder="$t('settings.search')" class="search" allow-clear @clear="searchIdenInfo" @keyup.enter="searchIdenInfo" &gt; &lt;template #prefix&gt; &lt;a-button type="text" shape="circle" @click="searchIdenInfo"&gt; &lt;template #icon&gt; &lt;SvgIcon name="search" /&gt; &lt;/template&gt; &lt;/a-button&gt; &lt;/template&gt; &lt;/a-input&gt; &lt;/div&gt; &lt;div class="btns"&gt; &lt;a-button type="primary" :disabled="selectedKeys.length === 0" @click="delChooseInfo" &gt; {{ $t('basicData.mailList.identityInfo.del') }} &lt;/a-button&gt; &lt;a-button type="primary" @click="addIdenInfo"&gt; {{ $t('basicData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a549962c90c1ce06b31beacb171716c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/69/">«</a>
	<span class="pagination__item pagination__item--current">70/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/71/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>