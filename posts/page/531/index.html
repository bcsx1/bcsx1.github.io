<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0526a78e82bbaeaadefc94c45924dd65/" rel="bookmark">
			Drools7在Intellij IDEA下的引入静态方法错误提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 在Intellij IDEA 2016下，默认安装了Drools的插件，但使用Drools7（其他版本应该也有问题）时发现，在DRL文件中引入的静态方法IDEA会提示“Cannot resolve”，而代码可以正常执行。
示例 定义了DroolsStringUtils类，类中有一个isEmpty的静态方法，在drl文件中的代码如下：
package com.rules import static com.utils.DroolsStringUtils.isEmpty; import com.model.Product; rule CheckIsEmpty when eval(isEmpty("")); then System.out.println(111); end 此时，IDEA会有如下提示： 查找了各种解决方案，暂时无法解决。但正常运行时不影响程序的执行。 可能的原因是目前Intellij idea2016.3 只支持drools版本到6.2.0的原因吧。感兴趣或有答案的朋友可以研究回复一下。
后语 你的支持是我努力的最大动力！此系列课程正在持续更新中，相关讨论QQ（593177274）已经建立，欢迎大家加入讨论。如有疑问可以留言也可以发送本人邮箱secbro2@gmail.com。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7ae1204818ff3e064b67856bd3191c2/" rel="bookmark">
			【初级算法剖析】超大文件获取顺序相关数据问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一类问题，典型问题一般如下：
1、给出超大文件，比如100T，每一行是一个访问ip/查询关键字等，计算频率最高的前100个。
2、给出超大文件，比如100T，第一行是一个值，计算第N个。
特点：
1、数据非常大，无法用内存加载。
2、数据无序。
3、结果顺序相关。
初步思路：一直在思考怎么用流式的一次遍历就直接出结果，无果。算法拼的就是经验，没搞过就很麻烦。
有效思路：hash划分，缩小量级，小量级下做有序处理，然后定位到具体的分片之后，重复这个过程，直到量级很小时，排序。
例如找出100T IP数据第1000个数，思路如下：
1、先计算一下内存使用。如果是1G，做hash计数，约1G/4字节=2^28方。
2、遍历一次文件，ip转换为整数，取前28位，在hash表计数，将将数据存入独立的文件。如果是字符串，可以正常取前28位（近4字符）。
3、统计之后，hash桶排序，如果足够离散，也可以直接遍历28bit位数，从命中开始找。确定第1000个在哪个桶。
比如按从小开始，桶计数分别是300，400，500，300，则第1000个在500桶中。
4、针对选定的桶，如果文件过大，重复上述过程，重复过程中注意忽略已经使用的前28位。对ip来说，只能取后4位了。
5、如果文件不大了，则直接排序，计算精确的位置，比如上面的数据，前3个桶相加是700，第1000是500桶的第300个。
对于前N问题，hash分片之后，每个桶分别独立计算前N个，然后再合并，排序，选择最终的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2431d578158a1e4477613bb57a9e4954/" rel="bookmark">
			Shell脚本中反引号`和$()的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		`和 ()都是命令替换符。由反引号括起来的也是⼀条命令,Shell先执⾏该命令,然后将输出结果⽴刻代换到当前命令⾏中。命令代换也可以⽤ ()表⽰: DATE= (date) (())⽤于算术计算, (())中的Shell变量取值将转换成整数,例如: VAR=45 echo (( VAR+3)) (())中只能⽤+-*/和()运算符,并且只能做整数运算
那么`和$()在命令替换时有什么区别呢
`和$()在用到\时，有了差别，下面举个例子来说明这个问题
echo `echo \\w ` echo $(echo \\w ) 为什么有这样不同的结果呢？ 在举个例子 当直接执行echo \$HOSTNAME语句时，结果为$HOSTNAME 当直接执行echo $HOSTNAME语句时，结果为localhost.localdomain 现在编写这样两句程序
echo `echo \$HOSTNAME` echo $(echo \$HOSTNAME) 结果分别为localhost.localdomain和 HOSTNAME，这说明在用反引号时，并没有将反斜杠(\)做反义字符对待，所以$没有将 的特殊意义转换，将被解释为echo localhost.localdomain，结果为localhost.localdomain。 在用 ()时，将反斜杠(\)做反义字符对待，所以$将 的特殊意义转换，所以将被解释为echo \$HOSTNAME，结果为$HOSTNAME。
这说明在反引号(`)中一个反斜杠()并没有转义的作用。
现在多增加几个反斜杠看看结果
echo `echo \\$HOSTNAME` echo $(echo \\$HOSTNAME) 这次结果有了变化，分别为 $HOSTNAME \localhost.localdomain 这就说明echoecho $HOSTNAME被解释成了echo \$HOSTNAME，而echo $(echo \\$HOSTNAME)被解释成了echo \localhost.localdomain。 为什么这次又会是这个结果呢？ 其实还是和\有关，在`中一个\不做转义字符处理，但是两个就要做转义字符处理。在$()中一个做转义字符处理，所以有两个\时，就被处理成了一个\。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/750c161188f0ae69dc5d43400a29d9d9/" rel="bookmark">
			没事刷刷题之三     产生冠军 HDOJ 2094
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		X - 产生冠军 一群人，打乒乓球比赛，两两捉对撕杀，每两个人之间最多打一场比赛。
球赛的规则如下：
如果A打败了B，B又打败了C，而A与C之间没有进行过比赛，那么就认定，A一定能打败C。
如果A打败了B，B又打败了C，而且，C又打败了A，那么A、B、C三者都不可能成为冠军。
Input 输入含有一些选手群，每群选手都以一个整数n(n&lt;1000)开头，后跟n对选手的比赛结果，比赛结果以一对选手名字（中间隔一空格）表示，前者战胜后者。如果n为0，则表示输入结束。
Output 对于每个选手群，若你判断出产生了冠军，则在一行中输出“Yes”，否则在一行中输出“No”。
Sample Input 3 Alice Bob Smith John Alice Smith 5 a c c d d e b e a d 0 Sample Output Yes
No
这个题目要给定两人之间的厮杀情况，要我们从中选出一个冠军，当然多个冠军不存在，既然只有一个冠军，而什么样的人才能是冠军呢？
⑴他不能出现在失败的一方，如果他失败了，肯定就不是冠军嘛。
⑵那么不出现在失败的一方是从没被击败过的，但不一定是冠军，因为别人也可能没被击败过，哎呀，既然这样就没法比了啊，有多个没被击败的，所以自然产生不了冠军。
综合上面情况，要产生冠军，必定是败方所没有出现的人，而且只能是一个。
所以我们 可以用set把人数统计出来，再减去败方的人数，如果只要一个，就是冠军，否则NO 代码如下：
#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;set&gt; #include&lt;string&gt; #include&lt;iostream&gt; using namespace std; int main(){ int n; while(~scanf("%d",&amp;n)&amp;&amp;n){ set&lt;string&gt; a,b; for(int i=0;i&lt;n;i++){ string a1,b1; cin&gt;&gt;a1&gt;&gt;b1; a.insert(a1); a.insert(b1); b.insert(b1); } int len=a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/750c161188f0ae69dc5d43400a29d9d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99938282f04071859941e18f16efcf42/" rel="bookmark">
			select
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select用于探测多个句柄状态的变化
#include &lt;sys/select.h&gt; #include &lt;sys/time.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); fd_set 类型可以简单的理解为按 bit 位标记句柄的队列。 nfds句柄的最大数+1， readfds关心读事件文件描述符集， writefds关心写事件文件描述符集， exceptfds关系异常事件文件描述符集， timeout阻塞时间，它可以使select处于三种状态： 第一，若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止； 第二，若将时间值设为0秒0毫秒，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值； 第三，timeout的值大于0，这就是等待的超时时间，即select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回，返回值同上述。 select返回值：负值，select错误。 0值，时间超时，没有事件就绪 正值，某些文件可读，可写，异常
void FD_CLR(int fd, fd_set *set);//将set中第fd位置为0 int FD_ISSET(int fd, fd_set *set);//检测fd位是否被标记 void FD_SET(int fd, fd_set *set);//在set中将第fd位置为1 void FD_ZERO(fd_set *set);//将set全部置零 在某一事件就绪时，用FD_SET将该位标记。 select在输入输出时都必须检测事件是否就绪。如果输⼊的readfds 标记了 16 号句柄，则 select() 将检测 16 号句柄是否可读。在 select()返回后，可以通过检查 readfds 有否标记 16 号句柄，来判断该“可读”事件是否发⽣。
server.c
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99938282f04071859941e18f16efcf42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9adf974d9500ae2d897490e4e0e729f8/" rel="bookmark">
			js获取form表单所有数据的简单方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址点击打开链接
在HTML中用js获取通过GET、POST方法（就是在网址后加?a=b&amp;c=d之类）传过来的表单值。
针对大家常用的获取表单方式，很多时候都是在重复的写一些代码，今天给大家贴出来的代码可以作为公用方法直接调用。可以提高大家的开发效率。
&lt;script type="text/javascript"&gt; //获取指定form中的所有的&lt;input&gt;对象 function getElements(formId) { var form = document.getElementById(formId); var elements = new Array(); var tagElements = form.getElementsByTagName('input'); for (var j = 0; j &lt; tagElements.length; j++){ elements.push(tagElements[j]); } return elements; } //获取单个input中的【name,value】数组 function inputSelector(element) { if (element.checked) return [element.name, element.value]; } function input(element) { switch (element.type.toLowerCase()) { case 'submit': case 'hidden': case 'password': case 'text': return [element.name, element.value]; case 'checkbox': case 'radio': return inputSelector(element); } return false; } //组合URL function serializeElement(element) { var method = element.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9adf974d9500ae2d897490e4e0e729f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ed894d7617ed51a54062e3d5ddb3cdb/" rel="bookmark">
			安卓中白天模式和夜间模式的切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 安卓是自带模式的，我们在styles.xml便可以设置标题栏显示的颜色（白天和夜间模式当然也就可以通过切换主题来实现） 设置切换之间的动画 在res下面新建anim文件夹然后在里面创建切换动画 in.xml
&lt;!-- interpolator 这个是动画变化的频率 快 慢 等--&gt; &lt;alpha android:duration="0" android:fromAlpha="0.0" android:interpolator="@android:anim/accelerate_interpolator" android:toAlpha="1.0"&gt; &lt;/alpha&gt; out.xml
&lt;alpha android:duration="0" android:fromAlpha="1.0" android:interpolator="@android:anim/decelerate_interpolator" android:toAlpha="0.0"&gt; &lt;/alpha&gt; 在styles里面设置要切换的主题
&lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;!--黑夜主题--&gt; &lt;style name="AppTheme.Black" parent="Theme.AppCompat"&gt; &lt;/style&gt; 在Preferences.class 定义一个传值的类
ublic class Preferences { private static final String shared_name="guide"; private static SharedPreferences sp; public static String getString(Context context, String key, String defaultValues) { sp = context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ed894d7617ed51a54062e3d5ddb3cdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ac16a23aa0db1beb3cc7a76f4738c5/" rel="bookmark">
			DIV CSS鼠标经过悬停在图片上时图片上方显示文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		纯div+css实现第一张图片没有文字内容，鼠标悬停时出现第二张图那样效果
使用div css实现鼠标悬停图片上方时显示文字内容原理：
首先我们设置一个盒子对象，并且将图片使用style标签内设置为CSS背景图片，同时设置该对象html a超链接display:none隐藏，该超链接锚文本内放好文字内容，最后设置鼠标悬停经过整个对象时候显示超链接内容。
需要注意是，我们使用了css position绝对定位超链接a标签位于该盒子对象下方，并且为了美化效果给html a标签宽度与对象宽度相同，设置一定高度，设置css背景为半透明背景颜色。
同时为了兼容IE6我们使用了IE6支持hover插件。控制阅读了解ie6 hover支持。本效果兼容各大浏览器包括IE6。
完整HTML源代码如下：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;鼠标悬停图片上显示文字 在线演示 www.divcss5.com&lt;/title&gt; &lt;style&gt; img{border:0}/* css 注释说明：设置图片边框为0 */ body{behavior:url("csshover.htc");text-align:center;}/* css注释说明：兼容ie6 支持标签使用hover */ .divcss5{ position:relative;width:554px; height:346px;margin:0 auto} .divcss5 a,.divcss5 span{display:none; text-decoration:none} .divcss5:hover{cursor:pointer} .divcss5:hover a.now{cursor:pointer; position:absolute; top:0; width:100%; height:100%;
z-index:100; left:0; display:block;} .divcss5:hover span{ display:block;position:absolute; bottom:0; left:0;color:#FFF;width:554px; z-index:10;height:36px; line-height:36px; background:#000;filter:alpha(opacity=60);-moz-opacity:0.5;opacity: 0.5;} /* 设置显示文字定位位置，背景半透明 */ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="divcss5" style="background:url(imgexp.png)"&gt; &lt;span&gt;文字内容&lt;/span&gt; &lt;a href="#" class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4ac16a23aa0db1beb3cc7a76f4738c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15e626c85bf5eb7d7f55a7e3ae97d53f/" rel="bookmark">
			jquery 获取和修改img src路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 获取： 复制代码代码如下: $("#imgId")[0].src; 修改： 复制代码代码如下: $("#imgId").attr('src',path); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8564a805bec169294113b927111a234d/" rel="bookmark">
			@SpringBootApplication原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.@SpringBootApplication是一个组合注解，我们来看一下它的源码：
// // Source code recreated from a .class file by IntelliJ IDEA // (powered by Fernflower decompiler) // package org.springframework.boot.autoconfigure; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Inherited; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import org.springframework.boot.SpringBootConfiguration; import org.springframework.boot.context.TypeExcludeFilter; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.FilterType; import org.springframework.context.annotation.ComponentScan.Filter; import org.springframework.core.annotation.AliasFor; @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication { @AliasFor( annotation = EnableAutoConfiguration.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8564a805bec169294113b927111a234d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fda97e72773d85e34315384abe10db2/" rel="bookmark">
			udp用户数据报协议的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 udp的简介 UDP—用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。 2 实现udp所使用的函数 socket 函数：创建一个通信点，返回一个文件描述符
#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int socket(int domain, int type, int protocol); 在第一个参数应该是AF_INET ,第二个参数中SOCK_DGRAM ，创建一个udp套接字.
bind函数：为套接口分配一个本地IP和协议端口，对于网际协议，协议地址是32位IPv4地址或128位IPv6地址与16位的TCP或UDP端口号的组合；如指定端口为0，调用bind时内核将选择一个临时端口，如果指定一个通配IP地址，则要等到建立连接后内核才选择一个本地IP地址。 bind()的作⽤是将参数sockfd和server绑定在⼀起,使sockfd这个⽤于⽹络通讯的⽂件描述符监听server所描述的地址和端口号。
#include &lt;sys/socket.h&gt; int bind(int sockfd, const struct sockaddr * server, socklen_t addrlen); recvfrom函数：用来接收数据，从sockfd处接收，将数据存放在buf内，接受len个数据。
#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); sendto函数：UDP使用sendto()函数发送数据，发送到sockfd处，发送buf里的内容，发送len个。
#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; ssize_t sendto(int sockfd, const void *buf, size_t len,\ int flags, const struct sockaddr *dest_addr, socklen_t addrlen); 3 udp_server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fda97e72773d85e34315384abe10db2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b6a9e73be09b250dc6112193e9bc709/" rel="bookmark">
			C#使用拉依达准则（3σ准则）剔除异常数据（.Net剔除一组数据中的奇异值）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题的提出：
电池生产中，遇到一批电池的测量结果数据：
电压值电池个数
电压值电池个数
电压值电池个数
电压值电池个数0.0561 4.091 4.14617 4.174134340.3211 4.0941 4.14717 4.175139730.7671 4.0992 4.14819 4.176133390.9721 4.1121 4.14923 4.177122753.0981 4.1193 4.1526 4.178103093.1871 4.121 4.15140 4.17983763.3191 4.1211 4.15250 4.1863243.5261 4.1223 4.15375 4.18146673.531 4.1253 4.15484 4.18233403.5321 4.1262 4.155100 4.18323583.541 4.1271 4.156118 4.18417193.5411 4.1282 4.157153 4.18511993.5441 4.1293 4.158173 4.1868393.5452 4.132 4.159248 4.1876223.8321 4.1322 4.16335 4.1884173.9281 4.1332 4.161419 4.1893043.931 4.1344 4.162540 4.191703.9511 4.1351 4.163731 4.1911243.9631 4.1365 4.164962 4.192773.9721 4.1374 4.1651359 4.193433.9732 4.1386 4.1661846 4.194444.0451 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b6a9e73be09b250dc6112193e9bc709/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42edb524d2efc39b99071edc5d297ba1/" rel="bookmark">
			vue&#43;vueRouter 实例demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		main.js
import Vue from 'vue' import App from './App.vue' import router from './router/router' /** * 加载插件 * @VueRouter：路由 */ /** * 定义常量信息 * @DOMAINNAME：客户端地址 * @SERVERNAME：服务端地址 * @API_SERVER：服务端接口 */ let DOMAINNAME = '' let SERVERNAME = '' let API_SERVER = '' /** * 全局方法 */ //获取当前页面路由信息 router.afterEach(function (transition) { console.log("当前路由参数") console.log(transition) }) /** * 创建实例 */ new Vue({ router, render: h =&gt; h(App) }).$mount('#app') 路由文件router/router.js /** * 路由文件 * 引入[Vue, VueRouter]模块 */ import Vue from 'vue' import VueRouter from 'vue-router' /** * 加载模块 */ Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42edb524d2efc39b99071edc5d297ba1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a7eab7d814fd7b2d6cb12e11992ccfc/" rel="bookmark">
			Android客户端之“微服私访”App的系统学习（一）  本地服务端环境的搭建和部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 每晚睡觉前都会去看看微信公众号中来自各位大神的干货分享，偶然看到鸿洋大神推荐的一篇有关课工厂的一个公开课 高效Android工程师6周培养计划，根据学习内容，整理成笔记。本系列文章意在详细介绍一个Android APP的后台的搭建到前端的详细开发流程。话不多说，下面就来介绍一下今天的内容：
简介： 微服私访是一款集巡店、培训、拜访于一体的店铺管理软件。软件支持多平台、多店铺的管理。包含了公司及同行业的一些资讯动态。拥有添加或者查看店铺的的最新动态，对拜访的过的店铺和进行培训的店铺进行详情记录存储的功能。软件功能完备、实用简单，是小型企业、店铺理想的管理软件。
项目整体介绍： UI界面效果： 数据结构： 公共接口规范： 1.接口调用方式 接口都基于 HTTP 协议，单向认证，可兼容多种编程语言。只要能够按照接口的规范 GET、POST 发送参数就可以取得相应接口返回的数据。接口字符编码使用 utf-8
2.图片查看方式 接口返回的图片路径不是全路径，查看图片时候，需在返回的图片路径前加上服务地址，例如头像图片路 径返回为:img/user/test.png，那么在访问的全路径为 http://localhost:8080/img/user/test.png
3.接口报文定义 3.1公共代码返回表 3.2部分接口方法返回表 接口定义： 这里以登录接口为例： APP登录接口 提交类型：POST 接口码：login
1.请求报文说明： 2.请求报文示例： http://localhost:8080/visitshop/login
3.响应报文说明： 4.响应报文示例： 服务端搭建： 部署Tomcat: 部署Tomcat之前，确保已经安装好java开发环境，这里就不再赘述了。 首先在Tomcat官网下载安装程序 http://tomcat.apache.org/download-80.cgi，并配置好环境变量。 这里说明一下，安装Tomcat分为（安装版和解压版），安装版的为 .exe程序，解压版的为压缩包形式，安装板的启动方式为启动Tomcat.exe，解压版的启动方式是点击bin目录下的startup.bat。 启动后访问：http://localhost:8080 如果能够访问到主页说明服务器运行成功,成功界面如下： 创建数据库并初始化数据： 安装mysql数据库 首先登陆mysql官网，下载安装包，mysql的安装和Tomcat一样都分为安装版和解压版，下载链接https://dev.mysql.com/downloads/mysql/ 根据自己的电脑操作系统选择合适的版本。 安装版：http://jingyan.baidu.com/article/4b07be3c67853c48b380f311.html 解压版：http://www.jianshu.com/p/261bde75b321 安装完成后启动mysql服务：这里以解压版的安装方式下，进行启动，如下界面表示启动成功： 安装mysql 客户端 这里可以选择安装（Navicat for MySQL）或者SQLyog,进行数据库的连接和查看操作。 Navicat :http://rj.baidu.com/soft/detail/24312.html?ald SQLyog:http://www.cr173.com/soft/126913.html 安装好之后，开始建立数据库连接： 这里介绍SQLyog客户端的使用：启动程序，新建连接，设置好参数，如下图表示连接成功： 执行shopvisit.sql脚本 ：将shopvisit.sql文件中的所有指令，拷贝到SQLyog中Query的编辑框中，并执行 Excute All Querys按钮，初始化数据库表结构。
部署服务程序 将后台部署包\visitshop.rar 文件解压到当前目录，然后把解压出来的文件夹 visitshop 拷贝到 tomcat 目录 \webapps 下。然后重新启动运行服务。 服务启动成功后，访问地址：http://localhost:8080/visitshop/如果 出现以下界面则说明服务部署成功： 注释1： 在解压版安装条件下，启动mysql服务的时候，会出现如下异常： 解决办法： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a7eab7d814fd7b2d6cb12e11992ccfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cec4b8bc5ba90e349cb55522e68fbc0/" rel="bookmark">
			OpenCV图像边缘检测（Canny算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、图像边缘检测简介 图像的边缘是指图像局部区域亮度变化显著的部分，该区域的灰度剖面一般可以看作是一个阶跃，既从一个灰度值在很小的缓冲区域内急剧变化到另一个灰度相差较大的灰度值。图像的边缘部分集中了图像的大部分信息，图像边缘的确定与提取对于整个图像场景的识别与理解是非常重要的，同时也是图像分割所依赖的重要特征，边缘检测主要是图像的灰度变化的度量、检测和定位，自从1959提出图像边缘检测以来，经过五十多年的发展，已有许多中不同的图像边缘检测方法。常见的方法有canny算子、Laplace算子，sobel算子和Scharr算子等。 关于图像边缘检测一般有以下步骤，如下图所示： 下面将对边缘检测算法进行分别介绍。
二、Canny算子 2.1、Canny算子简介 JohnCanny于1986年提出Canny算子，它与Marr（LoG）边缘检测方法类似，也属于是先平滑后求导数的方法。它是一个多级边缘检测算法。Canny 的目标是找到一个最优的边缘检测算法，最优边缘检测的含义是： （1）好的检测- 算法能够尽可能多地标识出图像中的实际边缘； （2）好的定位- 标识出的边缘要尽可能与实际图像中的实际边缘尽可能接近； （3）最小响应- 图像中的边缘只能标识一次，并且可能存在的图像噪声不应标识为边缘。 为了满足这些要求 Canny 算法使用了变分法，这是一种寻找满足特定功能的函数的方法。最优检测使用四个指数函数项的和表示，但是它非常近似于高斯函数的一阶导数。 2.2、Canny 边缘检测的步骤 （1）去噪声 用高斯滤波器对输入图像做平滑处理 (大小为 5x5 的高斯核)，即利用高斯平滑模板与原始数据作卷积，得到的图像与原始图像相比有些轻微的模糊（blurred）。这样，单独的一个像素噪声在经过高斯平滑的图像上变得几乎没有影响。 （2）计算梯度幅值和方向( x 和 y 方向上的卷积核) 图像中的边缘可能会指向不同的方向，所以 Canny 算法使用 4 个 mask 检测水平、垂直以及对角线方向的边缘。原始图像与每个 mask 所作的卷积都存储起来。对于每个点我们都标识在这个点上的最大值以及生成的边缘的方向。这样我们就从原始图像生成了图像中每个点亮度梯度图以及亮度梯度的方向。 角度方向近似为四个可能值，即 0, 45, 90, 135。 （3）对图像的梯度强度进行非极大抑制 这一步排除非边缘像素， 仅仅保留了一些细线条(候选边缘)。 （4）利用双阈值检测和连接边缘 较高的亮度梯度比较有可能是边缘，但是没有一个确切的值来限定多大的亮度梯度是边缘多大，所以 Canny 使用了滞后阈值。滞后阈值需要两个阈值——高阈值与低阈值。假设图像中的重要边缘都是连续的曲线，这样我们就可以跟踪给定曲线中模糊的部分，并且避免将没有组成曲线的噪声像素当成边缘。所以我们从一个较大的阈值开始，这将标识出我们比较确信的真实边缘，使用前面导出的方向信息，我们从这些真正的边缘开始在图像中跟踪整个的边缘。在跟踪的时候，我们使用一个较小的阈值，这样就可以跟踪曲线的模糊部分直到我们回到起点。 若候选边缘点大于上阈值，则被保留；小于下阈值，则被舍弃；处于二者之间，须视其所连接的像素点。 2.3、OpenCV中Canny( )函数解析 Canny( )函数在opencv中的方法如下： void Canny(InputArray image, OutputArray edges, double threshold1, double threshold2, int apertureSize = 3, bool L2gradient = false) 下面 对每个参数进行解析： 第一个参数，InputArray类型的image，输入图像，即源图像，填Mat类的对象即可，且需为单通道8位图像。 第二个参数，OutputArray类型的edges，输出的边缘图，需要和源图片有一样的尺寸和类型。 第三个参数，double类型的threshold1，第一个滞后性阈值，即上阈值。 第四个参数，double类型的threshold2，第二个滞后性阈值，即下阈值。 第五个参数，int类型的apertureSize，表示应用Sobel算子的孔径大小，其有默认值3。 第六个参数，bool类型的L2gradient，一个计算图像梯度幅值的标识，有默认值false。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cec4b8bc5ba90e349cb55522e68fbc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0fc5b49b3e9fac78f4ccf6c240eb026/" rel="bookmark">
			解决Error: ENOENT: no such file or directory, scandir 安装node-sass报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webpack打包时出现 Error: ENOENT: no such file or directory, scandir 解决方案是执行以下方法： npm rebuild node-sass 可是有时就是网络问题导致上面命令安装失败,查下失败提示,有可能是
Cannot download "https://github.com/sass/node-sass/releases/download/v4.5.3/win32-x64-48_binding.node":
然后下面就是nodejs给你的暗示
========暗示=========
Hint: If github.com is not accessible in your location
try setting a proxy via HTTP_PROXY, e.g.
export HTTP_PROXY=http://example.com:1234
or configure npm proxy via
npm config set proxy http://example.com:8080
&gt; node-sass@4.5.3 postinstall K:\mypro\nodePro\node_modules\_node-sass@4.5.3@node-sass
========暗示=========
意思是就说下载这个链接失败,你可以直接在浏览器打开这个链接(应该也打不开,或者特别慢),到这里我只能说你要翻墙了,上面也暗示你翻墙了.
翻墙后再试试几次npm rebuild node-sass,
还是不行也要想办法把win32-x64-48_binding.node 文件下载下来(在公司或者家里换不同的网络试试),
win32-x64-48_binding.node 到手后,打开项目下面的路径 node_modules\_node-sass_node-sass@4.5.3@node-sass\vendor (上面暗示的最后一句就有,版本号可能不一样)
然后在vendor文件夹下面创建win32-x64-48(要对应版本)文件夹,win32-x64-48文件夹下面放binding.node(文件名去掉前面的win32-x64-48_)
然后再一次命令: npm rebuild node-sass
应该安装成功
可能出错问题:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0fc5b49b3e9fac78f4ccf6c240eb026/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/547004c940b4a1316f5bde90b0c1a06c/" rel="bookmark">
			nginx代理websocket的一个问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一开始是在/etc/nginx/conf.d/下这样添加配置的， 结果后端服务在返回101后就断开连接， 并没有完成握手：
map $http_upgrade $connection_upgrade { default upgrade; '' close; } upstream wsbackend { server 10.220.11.122:8888; } server { listen 12345; location / { proxy_pass http://wsbackend; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; } } 客户端ws加了重试机制， 结果一直在重连， nginx accesslog是这样的：
192.168.1.100 - - [07/Jul/2017:15:59:02 +0800] "GET /filecheck HTTP/1.1" 101 0 "-" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/59.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/547004c940b4a1316f5bde90b0c1a06c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a9f45760d006fcd9faddbf99d834c8c/" rel="bookmark">
			聊一聊PV和并发、以及计算web服务器的数量的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.csdn.net/index_ling/article/details/61198203
最近和几个朋友，聊到并发和服务器的压力问题。很多朋友，不知道该怎么去计算并发？部署多少台服务器才合适？　所以，今天就来聊一聊PV和并发，还有计算web服务器的数量 的等方法。这些都是自己的想法加上一些网上的总结，如有不对，欢迎拍砖。　几个概念
网站流量是指网站的访问量，用来描述访问网站的用户数量以及用户所浏览的网页数量等指标，常用的统计指标包括网站的独立用户数量、总用户数量（含重复访问者）、网页浏览数量、每个用户的页面浏览数量、用户在网站的平均停留时间等。
网站访问量的常用衡量标准：独立访客(UV) 和 综合浏览量（PV）,一般以日为单位来衡量和计算。
独立访客(UV)：指一定时间范围内相同访客多次访问网站，只计算为1个独立访客。
综合浏览量（PV）：指一定时间范围内页面浏览量或点击量，用户每次刷新即被计算一次。
PV计算带宽
计算带宽大小需要关注两个指标：峰值流量和页面的平均大小。
举个例子:
假设网站的平均日PV：10w 的访问量，页面平均大小0.4 M 。
网站带宽 = 10w / （24 *60 * 60）* 0.4M * 8 =3.7 Mbps
具体的计算公式是：网站带宽= PV / 统计时间（换算到S）*平均页面大小（单位KB）* 8
在实际的网站运行过程中，我们的网站必须要在峰值流量时保持正常的访问，假设，峰值流量是平均流量的5倍，按照这个计算，实际需要的带宽大约在 3.7 Mbps * 5=18.5 Mbps 。
PS：
1. 字节的单位是Byte，而带宽的单位是bit，1Byte=8bit,所以转换为带宽的时候，要乘以 8。
2. 在实际运行中，由于缓存、CDN、白天夜里访问量不同等原因，这个是绝对情况下的算法。
PV与并发
具体的计算公式是：并发连接数 = PV / 统计时间 * 页面衍生连接次数 * http响应时间 * 因数 / web服务器数量；
解释：
页面衍生连接次数: 一个页面请求，会有好几次http连接，如外部的css, js,图片等,这个根据实际情况而定。
http响应时间: 平均一个http请求的响应时间，可以使用1秒或更少。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a9f45760d006fcd9faddbf99d834c8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4230e9974c067e00980e45d581f0ac7/" rel="bookmark">
			altera小实验——ROM读取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在研究固定系数乘法器的查超标法，需要用到ROM存储器，因此探究了下初步使用。
器件：altera Cyclone III
1.建立工程与主文件
2.建立ROM的初始化文件
由于ROM不可写入，因此其数据的存储需要一个初始化文件，里面预写入ROM中的存储数据。
在File-&gt;New...里选择Hex文件或MIF文件都可以，用MIF文件更加容易借助其他工具如MATLAB等进行修改与生成，因此选择MIF文件。
双击生成文件，并对文件数据进行修改。随便改了改里面的存储数值，地址与数值一致了。保存文件为rom.mif。
打开.mif文件可见其组织方式。
3.建立ROM IP核
本页设置数据位宽与数据深度，ROM类型（一般auto即可），输入地址的时钟与输出数据的时钟。
该页选择是否在数据输出端加入一个reg来减小延时，如果加入的话，数据会晚一个周期抵达。
该页添加rom.mif初始文件，注意地址一定要写全，否则会出现如下报错：
Error (127001): Can't find Memory Initialization File or Hexadecimal (Intel-Format) File ......
之后生成.v文件即可
4.实例化并编译
添加rom.v文件并实例化编译，用signaltap抓取信号观察结果。
可以观察到输出数据与输入地址之间差了两个周期，这是因为输入地址时打了一拍，输出数据时打了一拍。
若取消掉数据输出后面的reg，则输出数据波形如下：
转载于:https://www.cnblogs.com/mingmingruyue99/p/7202004.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44f057f311bf3235396c8353d26575f0/" rel="bookmark">
			Android 沉浸式状态栏与隐藏导航栏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前言 一般我们在Android的APP开发中，APP的界面如下： 可以看到，有状态栏、ActionBar(ToolBar)、导航栏等,一般来说，APP实现沉浸式有三种需求：沉浸式状态栏，隐藏导航栏，APP全屏 沉浸式状态栏是指状态栏与ActionBar颜色相匹配， 隐藏导航栏不用多说，就是将导航栏隐藏，去掉下面的黑条。 APP全屏是指将状态栏与导航栏都隐藏，例如很多游戏界面，都是APP全屏。 所以，在做这一步时，关键要问清楚产品狗的需求，免得白费功夫。 下面，分别来介绍这三种方式的实现。
2 沉浸式状态栏 沉浸式状态栏效果一般如下： 顺便在网上找的图 关于沉浸式状态栏网上的方案很多，比如android 5.0 以上的MD设计，或者修改activiyty的window的setStatusBarColor()方法，设置颜色。需要说明一点的时，沉浸式状态栏只对API19以上有效。 这里我依然采用的是设置Activity的Window设置setStatusBarColor()的方法。代码如下：
/** * 设置状态栏的颜色 */ @TargetApi(Build.VERSION_CODES.KITKAT) public static void statusBarTintColor(Activity activity, int color) { // 代表 5.0 及以上 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { activity.getWindow().setStatusBarColor(color); return; } // versionCode &gt; 4.4 and versionCode &lt; 5.0 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) { //透明状态栏 activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); ViewGroup androidContainer = (ViewGroup) activity.findViewById(android.R.id.content); // 留出高度 setFitsSystemWindows true代表会调整布局，会把状态栏的高度留出来 View contentView = androidContainer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44f057f311bf3235396c8353d26575f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51a5edd8679f78756b1a60163b7d5bee/" rel="bookmark">
			echarts中series中的数据如何如何循环显示数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		echarts中的数据格式如下
var option = {
title : {
text: '月份对比',
subtext: ''
},
tooltip : {
trigger: 'axis'
},
legend: {
data:['3月','4月','5月','6月']
},
toolbox: {
show : false,
feature : {
dataView : {show: true, readOnly: false},
magicType : {show: true, type: ['line', 'bar']},
restore : {show: true},
saveAsImage : {show: true}
}
},
calculable : true,
xAxis : [
{
type : 'category',
data : ['襄城区','樊城区','襄州区','高新区','东津新区','襄阳市直','枣阳市','宜城市','老河口市','南漳县','保康县','谷城县']
}
],
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51a5edd8679f78756b1a60163b7d5bee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4851afba5d6e4eee28e7763361f79476/" rel="bookmark">
			对 Canal (增量数据订阅与消费)的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述
canal是阿里巴巴旗下的一款开源项目，纯Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费，目前主要支持了MySQL(也支持mariaDB)。
起源：早期，阿里巴巴B2B公司因为存在杭州和美国双机房部署，存在跨机房同步的业务需求。不过早期的数据库同步业务，主要是基于trigger的方式获取增量变更，不过从2010年开始，阿里系公司开始逐步的尝试基于数据库的日志解析，获取增量变更进行同步，由此衍生出了增量订阅&amp;消费的业务，从此开启了一段新纪元。
基于日志增量订阅&amp;消费支持的业务：
数据库镜像 数据库实时备份 多级索引 (卖家和买家各自分库索引) search build 业务cache刷新 价格变化等重要业务消息 工作原理
mysql主备复制实现：
从上层来看，复制分成三步：
master将改变记录到二进制日志(binary log)中(这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看)； slave将master的binary log events拷贝到它的中继日志(relay log)； slave重做中继日志中的事件，将改变反映它自己的数据。 canal的工作原理
原理相对比较简单：
canal模拟mysql slave的交互协议，伪装自己为mysql slave，向mysql master发送dump协议 mysql master收到dump请求，开始推送binary log给slave(也就是canal) canal解析binary log对象(原始为byte流) 架构设计
个人理解，数据增量订阅与消费应当有如下几个点：
1、增量订阅和消费模块应当包括binlog日志抓取，binlog日志解析，事件分发过滤(EventSink)，存储(EventStore)等主要模块。
2、如果需要确保HA可以采用Zookeeper保存各个子模块的状态，让整个增量订阅和消费模块实现无状态化，当然作为consumer(客户端)的状态也可以保存在zk之中。
3、整体上通过一个Manager System进行集中管理，分配资源。
可以参考下图：
canal架构设计
说明：
server代表一个canal运行实例，对应于一个jvm instance对应于一个数据队列 (1个server对应1..n个instance) instance模块：
eventParser (数据源接入，模拟slave协议和master进行交互，协议解析) eventSink (Parser和Store链接器，进行数据过滤，加工，分发的工作) eventStore (数据存储) metaManager (增量订阅&amp;消费信息管理器) EventParser
整个parser过程大致可分为几部：
Connection获取上一次解析成功的位置(如果第一次启动，则获取初始制定的位置或者是当前数据库的binlog位点) Connection建立连接，发生BINLOG_DUMP命令 Mysql开始推送Binary Log 接收到的Binary Log通过Binlog parser进行协议解析，补充一些特定信息 传递给EventSink模块进行数据存储，是一个阻塞操作，直到存储成功 存储成功后，定时记录Binary Log位置 EventSink设计
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4851afba5d6e4eee28e7763361f79476/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1417d365d4bebf8a55ed42302dcee181/" rel="bookmark">
			c&#43;&#43;十进制转二进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以使用栈来做。 #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; int main(){ int n,ans; cin&gt;&gt;n; stack&lt;int&gt; stk; while(n!=0){ ans=n%2; n=n/2; stk.push(ans); } while(!stk.empty()){ cout&lt;&lt;stk.top(); stk.pop(); } return 0; }
推广到任意进制#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;cmath&gt;using namespace std;void convert(int num,int m){char c[16]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};stack&lt;char&gt; s;int n=abs(num);while(n){s.push(c[n%m]);n/=m;}if(num&gt;=0){while(!s.empty()){cout&lt;&lt;s.top();s.pop();}}else{cout&lt;&lt;"-";while(!s.empty()){cout&lt;&lt;s.top();s.pop();}}}int main(){int n,m;cin&gt;&gt;n&gt;&gt;m;convert(n,m);return 0;}方法2：#include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; char numToChar(int n) { if(n&lt;=9&amp;&amp;n&gt;=0) return n+'0'; if(n&gt;9&amp;&amp;n&lt;16) return 'A'+(n-10); return ' '; } int main() { int num, k; cin&gt;&gt;num&gt;&gt;k; string ret="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1417d365d4bebf8a55ed42302dcee181/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64d457fd8958e15e42a9c462da803835/" rel="bookmark">
			ANTLR4的IntelliJ插件安装及示例Hello.g4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Download: https://plugins.jetbrains.com/plugin/7358-antlr-v4-grammar-plugin 或者从这里http://www.antlr.org/tools.html进入下载。
前提 安装好 - jdk - IntelliJ
配置好ANTLR的java运行时环境(库)。具体见这里
插件安装 Hello.g4示例 在IntelliJ中新建java项目（即一个Module），并创建grammar文件Hello.g4 。代码如下：
//Define a grammar called Hello grammar Hello; r : 'hello' ID; // match keyword hello followed by an identifier ID : [a-z]+; // match lower-case identifiers WS : [ \t\r\n]+ -&gt; skip; // skip spaces, tabs, newlines IntelliJ 中的Project相当于eclipse中的workspace； 而IntelliJ中的Module相当于eclipse中的project。 因此，我们创建项目时只需在当前Project中创建一个新的Module项目（File -&gt; New -&gt; Module）。
编辑好该.g4文件后即可测试该grammar规则。在rule “r”处选中“r”并右击鼠标后，点击“Test Rule r”，如下图。然后在左下方便可以输入“hello name”,在右下方框中便会显示对应的Parse tree。 Hello.g4的ANTLR代码生成配置 注意：IntelliJ中的ANTLR插件指定了antlr的运行时库的版本为最新版本（此处即为ANTLR4 4.7版本）
右击项目中刚刚创建的Hello.g4文件，点击“Configure ANTLR…”，然后便会弹出如下图所示窗口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64d457fd8958e15e42a9c462da803835/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b39ac3473418b3d0b993c60ca864e964/" rel="bookmark">
			codeforces 822 C Hacker, pack your bags!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：http://codeforces.com/contest/822/problem/C 大致题意： 给出n个区间和cost，以及一个数x，从n个区间取出两个不重合的区间使得他们的区间大小恰好为x， 并使得两个cost和最小 解法： 对于每个区间，一个区间起点之前的区间都与这个区间不重合，用一个数组动态记录这个区间之前的所有区间大小对应的cost最小值，那么就可以求出这个区间和之前区间和为x的最小值。 代码：
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; const int N = 2e5+7; const long long INF = 2e9+7; vector&lt;int&gt; li[N],ri[N]; int l[N],r[N]; long long c[N]; int n,x; long long dp[N]; int main(){ cin &gt;&gt; n &gt;&gt; x; for(int i = 0 ; i &lt; n ; i++){ cin &gt;&gt; l[i] &gt;&gt; r[i] &gt;&gt; c[i]; li[l[i]].push_back(i); ri[r[i]].push_back(i); } fill(dp,dp+N,INF); long long ans = INF; for(int i = 1 ; i &lt; N ; i++){ for(auto j : li[i]){ int d = r[j] - l[j] + 1; int m = x - d; if(m&lt;1) continue; ans = min(ans,dp[m]+c[j]); } for(auto j : ri[i]){ int d = r[j] - l[j] + 1; dp[d] = min(dp[d],c[j]); } } if(ans == INF) cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b39ac3473418b3d0b993c60ca864e964/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d29aff640812476c512c326a516514e2/" rel="bookmark">
			【厉害了】台达PLC可以实现无线下载程序！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		台达PLC程序远程无线下载
前两天需要修改下一个台达PLC的程序，但是PLC已经在现场了而且是放在高台上的，调试起程序来不太方便。平时这个PLC和控制室电脑之间用的是无线通讯方式，通过一对儿无线通讯终端来完成数据传输。
我突然想到，也许可以用这对无线通讯终端来完成对台达PLC的程序无线下载。之前一直用三菱的PLC这么做过，我想台达的PLC也能这么实现。如果可以无线下载，那改程序就简单多了。
说干就干，我先自己试验了下台达PLC程序的远程无线下载的可实施性。折腾了2小时就成功了。很不吝啬的来分享下，调试和搭建过程。
设备搭建：
在电脑上打开台达PLC（DVP16ES200R）编程软件 Delta WPLSoft，用USB转RS232数据线连接一台无线通讯终端，这个终端可以自动识别RS232端口。
如图所示▼
另一边的台达PLC先连接上RS232编程电缆，然后再接一根RS232交叉线，以确保程序可以顺利的传输给这边无线通讯终端的RS232端口。
如图所示▼
搭建完成的示意图
如图所示▼
调试方式：
我编写了一个简单的程序，用一秒的脉冲M1013来触发输出继电器Y0（蓝框所示）。全部电器通电后，运行程序对远端的PLC进行下载。观察Y0是否以一秒的频率在闪烁。或者看连接PLC的无线通讯终端的红灯是否闪烁。
成功写入程序显示如下▼
后记：
之所以觉得台达PLC能实现程序的远程无线下载，主要是我原来在三菱PLC上实践过。众所周知台达PLC与三菱PLC非常类似，软件上肯定不会差太多。而且我用的无线通讯终端是三菱PLC专用的，这又进一步坚定了我的想法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fcfc44da30bb65db00b5d6c54fa053e/" rel="bookmark">
			codeforces 822 B Crossword solving
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：http://codeforces.com/contest/822/problem/B 大致题意： 给出两个字符串，问第一个字符串变成第二个字符串的子串最少需要做多少次replace，并输出replace的位置。 解法： 直接暴力求解，中间记录replace的次数和位置，保留最小值和对于的位置 代码：
#include &lt;iostream&gt; using namespace std; const int N = 1005; int main(){ int n,m; cin &gt;&gt; n &gt;&gt; m; char s[N],s2[N]; cin &gt;&gt; s &gt;&gt; s2; int res = n; int ans[N],temp[N]; for(int i = 0 ; i &lt; n ; i++){ ans[i] = 1; } for(int i = 0 ; i &lt; m-n+1 ; i++){ int sum = 0; for(int j = 0 ; j &lt; n ; j++){ if(s[j]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fcfc44da30bb65db00b5d6c54fa053e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/650ba53ebd762abc2e8de7029607b565/" rel="bookmark">
			codeforces 822 A I&#39;m bored with life
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：http://codeforces.com/contest/822/problem/A 大致题意： 给两个数求他们阶层的最大公约数。 解法： 显然答案是两个数最小值的阶层，因为其中一个数小于等于12，所以直接求最小值的阶层不会溢出。 代码：
#include &lt;iostream&gt; using namespace std; int main(){ int n,m; cin &gt;&gt; n &gt;&gt; m; int r = n &lt; m ? n : m; long long res = 1; for(int i = 1; i &lt;= r ; i++){ res*=i; } cout &lt;&lt;res &lt;&lt; endl; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b333aaa7d749af5eb4b8a377e4ea96a/" rel="bookmark">
			LDO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己总结的一些LDO应用经验，供大家参考。很多观点可能不是很精确，欢迎工程师排砖交流！ 一、选型 1、确定电路需要的电压类型是正电压还是负电压。正电压的器件较多，负电压的器件可以考虑LM2991（较多大公司使用）； 2、确定电路的输出电压、负载电流和输入电压（注意输入电压和负载电流都需要降额80％考虑） 3、确定电路的最大、最小输入－输出电压差；电路的最大、最小输入－输出电压差应该满足器件要求； 4、单板PCB、结构尺寸和生产线对封装形式的要求； 5、确定电路的电性能指标要求（如静态电流、精度、纹波、效率等）；器件的指标应该满足电路指标的要求，并且考虑温度对各种性能指标的影响； 6、确定器件的输出电容以及ESR值，如果器件对输出电容以及ESR有特殊要求，考虑公司现有器件是否满足要求； 7、其他要求（如电路是否需要使能控制端、价格因素等）。 二、外围元件 1、输入电容 输入电容的主要作用是对调整器的输入进行滤波，另外输入电容也可以抵消输入线较长时引入的寄生电感效应，防止电路产生自激振荡；所以调整器输入端一般采用两个电容并联的设计。较大的电容提供滤波作用，一般取10uF左右；较小电容提供消除振荡作用，取值一般为1uF，实际应用中一般选用0.1uF，位置尽量靠近调整器的输入管角。如果输入端采用工频变压器和二极管整流电路，为了提高滤波性能，输入端的滤波电容值应该取的更大一些。 输入电容除了考虑容值外，纹波电流额定值也必须考虑，输入电容的纹波电流应小于器件手册给出的额定值，电路的纹波电流可以用下面的公式简单计算： Iripple＝PI×Vp×f×C 其中： Iripple：输入电容的纹波电流 Vp：纹波电压的峰－峰值 C：输入电容值 f：为纹波电压的频率，一般取100KHz 再考虑以上因素的时候还应该注意温度对电容特性的影响，如钽电容其电容值以及纹波电流额定值都随着温度的升高而降低。 另外电容都需80％的降额，钽电容需要50－60％的降额。 2、输出电容 电压调整器的许多性能都受输出电容的影响。其中电容值以及ESR对电路频率响应的影响是最主要的。由于隧道深度的存在，输出电容以及ESR选择不当，非常容易引起电路的自激振荡。因此电容的选择建议参考器件手册的隧道深度图。 在选择电容的时候还需要考虑温度对容值以及ESR的影响，应该保证在整个温度范围内电路都是稳定的。（主要是铝电容的ESR受温度影响比较大，所以建议在温度悲较大的应用场合下最好不要选择铝电容作为输出电容） 在使用可调LDO调整器时，有时候我们为达到较好的输出纹波抑制性能，调整器需要对地增加滤波电容，但是必须注意的是：电路的输出增加了这个电容，又会增加一个闭环极点（f＝1/2×pi×（R1//R2）×CC为补偿电容），电路的输出电容必须相应的增加，才能保证电路的稳定。 另外一个容易忽视的问题：LDO带有多个负载的时候，每个负载电路的输入电容都是调整器的输出电容。 三、布局 LDO设计中，布局容易被忽视，其实布局是非常重要的。 1、元器件放置 为了保证调整电路有足够好的瞬态响应特性，LDO调整器的带宽都较高，这使得LDO容易发生振荡，除外围元件对LDO产生影响外，实际电路的寄生参数也会对电路的频率响应特性产生影响：PCB走线产生的寄生电感。所以电路设计的时候，旁路电容应该尽量靠近器件引脚，即引线长度尽量短，调整器输入端到旁路电容的走线距离应该小于1英寸。 2、地回路 调整器的性能也受到地回路的影响，主要是输入滤波电容的回路引线位置不当。如果输入电容回路引线和调整器负载回路存在物理上的连接，由于纹波电容的纹波电流峰值非常大（平均电流的5－15倍），输入端的纹波电压（50Hz或者120Hz）降耦合到负载电压上。 3、反馈电压检测 另外一个影响：负载引线的电阻引起的检测误差，这个问题一般发生在输出电流较大的电路中，使得负载电压比实际设计的电压低。 4、安装 半导体器件失效率随温度升高而增加，而功率较大的调整器件通过散热器保证器件正常工作时候的结温不超过其额定值。安装的是否需要注意的地方： PCB设计的器件封装一定要和器件封装相吻合； 引脚弯曲角度要正确，否则器件将会受到较大的机械应力，可能导致封装，管教以及键合丝问题； 绝缘材料（或者散热器）表面粗糙，导致热阻增大，可能导致器件结温过高而损坏。 四、保护 1、采用双电源供电的电路保护 在许多情况下，调整器的负载并不直接连接到地，而是采用两个极性相反的调整器。常见与运算放大器，在这种情况下调整器的输出必须连接嵌位二极管。 2、反偏保护 有时候可能出现调整器输入电压比输出电压的跌落速度快的可能：如输入端迅速短路：调整器的输出电压大于7V时，这种情况可以使调整器元件的发射极－基极之间的P-N结击穿损坏。我们一般在调整器的输入－输出端反相并联一个二极管进行保护。 另外在三端可调整的电路中，如果输出端使用较大的电容或者输出电压可能超过25V时。（大电容是指Co&gt;25uF,Cadj&gt;10uF）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecc09bbc95cf3d0759c14abaef5caac1/" rel="bookmark">
			android中自定义画布Canvas的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、要求：
1.画布绘制控件的方法，控件应该是一个可以自定义的；
2.画布是可以缩放，且提供一个缩放的方法供外使用；
3.控件之间连线的方法；
4.画布缩放之后手势滑动的识别实现；
二、在github里面种找到了一个类似度挺高的开源项目：
github中的第三方的开源项目地址：
在第三方的FabricView的项目中已经实现了：
1.控件的可以绘制；
2.可以连线；
3.未实现的是缩放的实现？
4.手势滑动的识别？
5.缩放之后的滑动识别？
三、需求改造：
把开源项目经过修剪和添加来实现自己项目中的画布功能
1.在画板上连线已经实现：
public boolean onTouchDrawMode(MotionEvent event) { // get location of touch float eventX = event.getX(); float eventY = event.getY(); // based on the users action, start drawing switch (event.getAction()) { case MotionEvent.ACTION_DOWN: // create new path and paint currentPath = new CPath(); currentPaint = new Paint(); currentPaint.setAntiAlias(true); currentPaint.setColor(mColor); currentPaint.setStyle(mStyle); currentPaint.setStrokeJoin(Paint.Join.ROUND); currentPaint.setStrokeWidth(mSize); currentPath.moveTo(eventX, eventY); currentPath.setPaint(currentPaint); // capture touched locations lastTouchX = eventX; lastTouchY = eventY; Log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecc09bbc95cf3d0759c14abaef5caac1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee39552bfdb38429756f5fe2750fe677/" rel="bookmark">
			Verilog组合逻辑和时序逻辑的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VerilogHDL语言分为面向综合和面向仿真两大类语句，且可综合语句远少于仿真语句，读者可能会有可综合设计相对简单的感觉。然而事实刚好与此相反，这是因为：首先，可综合设计是用来构建硬件平台的，因此对设计的指标要求很高，包括资源、频率和功耗，这都需要通过代码来体现；其次，在实际开发中要利用基本VerilogHDL语句完成种类繁多的硬件开发，给设计人员带来了很大的挑战。所有的仿真语句只是为了可综合设计的验证而存在。为了让读者深入地理解可综合设计、灵活运用已学内容，本章将可综合设计中的基本知识点和难点提取出来，融入VerilogHDL语法以及开发工具等诸多方面，以深入浅出的方式向读者说明设计中的难点本质。 8.1 组合逻辑和时序逻辑 数字电路根据逻辑功能的不同特点，可以分成两大类，一类叫组合逻辑电路（简称组合电路），另一类叫做时序逻辑电路（简称时序电路）。掌握组合逻辑和时序逻辑的区分手段与实现方法是数字系统设计的基本要求。 8.1.1 组合逻辑设计 1．组合逻辑概念 组合逻辑是VerilogHDL设计中的一个重要组成部分。从电路本质上讲，组合逻辑电路的特点是输出信号只是当前时刻输入信号的函数，与其他时刻的输入状态无关。无存储电路，也没有反馈电路，其典型结构如图8-1所示。从电路行为上看，其特征就是输出信号的变化仅仅与输入信号的电平有关，不涉及对信号跳变沿的处理。 尽管组合电路在功能上千差万别，可是其分析方法却有很多相似之处。给定逻辑电路后，得到其输入与输出的直接表达式，将输入组合全部带入表达式中计算得到输出结果，并以真值表的形式表达出来，最后根据真值表说明电路功能。 组合逻辑电路的设计就是在给定逻辑功能的前提下，通过某种设计渠道，得到满足功能要求且最简单的逻辑电路。基于HDL 语言和EDA工具的组合逻辑电路的设计流程如图8-2 所示。 其中逻辑抽象和HDL编程是重点环节。在很多情况下，逻辑问题都是通过文字描述的，逻辑抽象就是对设计对象的输入与输出信号间的因果关系，用逻辑函数的方法表示出来。HDL语言编程就是直接通过语句来实现抽象结果。 2．组合逻辑的Verilog HDL 描述 根据组合逻辑的电路行为，可以得到两种常用的RTL 级描述方式。第一种是always模块的触发事件为电平敏感信号列表；第二种就是用assign 关键字描述的数据流赋值语句。 （1）always 模块的敏感表为电平敏感信号的电路 这种方式的组合电路应用非常广泛，几乎可以完成对所有组合逻辑电路的建模。always模块的敏感列表为所有判断条件信号和输入信号，但一定要注意敏感列表的完整性。在always模块中可以使用if、case 和for 等各种RTL关键字结构。由于赋值语句有阻塞赋值和非阻塞赋值两类，建议读者使用阻塞赋值语句“=”，详细原因将在8.3.1 节进行说明。 always 模块中的信号必须定义为reg 型，不过最终的实现结果中并没有寄存器。这是由于在组合逻辑电路描述中，将信号定义为reg型，只是为了满足语法要求。下面给出一个组合逻辑实例。 【例8-1】通过Verilog HDL 语言实现一个2 输入比较器，输入分别为d1、d2，输出分别为f1（d1&gt;d2时为高电平）、f2（d1 = d2 时为高电平）、f3（d1 可以看出，组合逻辑就对应着电平触发事件电路。上述程序在ISE中综合后的RTL级结构图如图8-3所示，可以看出，虽然将输出信号f1、f2以及f3声明为寄存器变量，并且在always模块中进行赋值操作，但在组合逻辑设计中，并没有综合成D触发器。 上述程序在ISESimulator中的仿真结果如图8-4所示，只要敏感信号电平发生变化，always语句块中所有语句都会被重新执行一次。 （2）assign语句描述的电路 利用条件符“?”可以描述一些相对简单的组合逻辑电路，信号只能被定义为wire型。当组合逻辑比较复杂时，需要很多条assign语句或者多重嵌套“?”，使得代码可读性极差，因此此时推荐第一种组合逻辑建模方式。下面给出一个由assign关键字描述的组合逻辑实例。 【例8-2】通过assign语句实现例8-1的比较器。 在ISE中查看其综合后的RTL级结构示意图，可以发现和图8-3一样，其仿真结果也和例8-1的一致。 3．组合逻辑电路的注意事项 （1）敏感信号列表 在组合逻辑设计中，读者必须重点对待敏感信号列表。敏感信号列表出现在always块中，其典型行为级的含义为：只要敏感信号列表内的信号发生电平变化，则always模块中的语句就执行一次，因此设计人员必须将所有的输入信号和条件判断信号都列在信号列表中。有时， 不完整的信号列表会造成不同的仿真和综合结果，因此需要保证敏感信号的完备性。在实际的PLD 器件开发中，EDA工具都会默认将所有的输入信号和条件判断语句作为触发信号，增减敏感信号列表中的信号不会对最终的执行结果产生影响，因此读者如果期望在设计中通过修改敏感信号来得到不同的逻辑，那就大错特错了。当敏感信号不完备时，会使得仿真结果不一样，这是因为仿真器在工作时不会自动补充敏感信号表。如果缺少信号，则无法触发和该信号相关的仿真进程，也就得不到正确的仿真结果。 因此，为了确保仿真和最终实现结果一致，必须要保证组合逻辑电路always敏感信号列表的完备性。如果设计人员在设计中，认为列举信号麻烦，则采用下面的语句。 此时，综合工具和仿真工具会自动将所有的敏感信号自动加入敏感信号列表。ISE 也支持这一用法。 （2）不要在组合逻辑中引入环路 在组合逻辑中引入环路会导致电路产生振荡、毛刺以及冲突等问题，从而降低设计的稳定性和可靠性，因此要彻底避免环路。 图8-5给出一个简单的环路设计，把一个寄存器输出通过组合逻辑后，再次通过两级组合逻辑处理反馈给该组合逻辑的引脚时，就会产生组合环路，要避免该组合环路，可以采用图8-6所示的逻辑设计示意图，不仅功能结构一致，还取消了组合逻辑环路。 之所以称逻辑环路是一种高风险设计，其原因如下： 首先，环回逻辑的延时完全依靠组合逻辑门延迟和布线延迟。一旦这些传播时延有所变化，则环路的整体逻辑将彻底失效。 其次，环路的时序分析是个死循环过程。目前的EDA开发工具为了计算环路的时序逻辑都会主动割断时序路径，引入许多不确定的因素。 目前的综合工具都会给出逻辑环路的警告（CombinationalLoops），因此设计人员必须对软件工具的此类报告特别在意。如果一定要实现环路，则需要通过时序逻辑的寄存器来完成。 8.1.2 时序逻辑设计 1．时序逻辑电路的基本知识 时序逻辑是Verilog HDL设计中另一类重要应用。从电路特征上看来，其特点为任意时刻的输出不仅取决于该时刻的输入，而且还和电路原来的状态有关。电路里面有存储元件（各类触发器，在FPGA芯片结构中只有D 触发器）用于记忆信息，如图8-7所示。从电路行为上讲，不管输入如何变化，仅当时钟的沿（上升沿或下降沿）到达时，才有可能使输出发生变化。 从图8-7 可以看出，时序逻辑电路由组合逻辑电路和存储电路这两部分组成，其中存储电路由各类触发器（JK 触发器、D 触发器以及T触发器等类型）构成，并将组合逻辑的部分输出反馈到输入逻辑的输入端口。 时序电路可通过表达式（电路输出端的输出逻辑表达式、存储电路触发器输出端的驱动或激励表达式，以及表示触发器状态的状态方程）、状态转移表、状态转移图、时序图以及HDL行为描述语言等来描述。若将输入变量和各级触发器状态的全部组合列出，分别代入各级触发器的状态方程和电路的输出方程，则可以计算出各级触发器的次态值和当前输出值，把相应的计算结果列成真值表就可得到状态转移表。对于读者最关心的HDL行为描述代码，可在时序图的基础上快速得到。 分析一个时序电路，就是要找出给定时序电路的逻辑功能。具体地说，就是要求找出电路的状态和输出状态（一般指进位输出、借位输出等）在输入变量和时钟信号作用下的变化规律。为了直观地说明上述方法，下面给出一个简单的时序逻辑电路，通过分析得到其常用的描述形式。 【例8-3】完成图8-8 所示的简单时序逻辑电路的分析。 （1）首先，列出输出方程、驱动方程，即 由于电路采用T 型触发器，因此其特征方程为： 将驱动方程代入特征方程，可以得到式（8-4）所示的状态方程。 （2）计算并列出状态转移表 图示电路有一个输入X和1级触发器，因此输入与触发器初态的取值组合只有4组，即00、01、10和11。把这些取值带入式（8-4）和式（8-1），可计算出触发器的次态和电路的输出值，其相应的状态转移表如表8-1所列。 （3）画出状态转移图和时序图 状态转移图直观、形象地显示出了时序逻辑电路的特点和逻辑功能，本例的状态转移图如图8-9所示。其中，圆圈内的数字表示电路的状态，箭头表示状态转换的方向，箭头旁注明了状态转换的输入条件和输出结果，输入条件位为斜线上方，而输出结果位于斜线下方。 时序图就是通过数字信号波形直观表示时序逻辑电路的特点和逻辑功能，可根据状态方程、状态转移表等多方面得到，用于判断设计结果的正确性。图8-10（a）、（b）分别给出了触发器初始状态为0和1的时序图。 从图8-10中可以看出以下两点：首先，时序电路的输出信号不仅取决于电路当时的输入，还取决于电路原来的状态，体现了“记忆”特性。其次，在同步时序逻辑电路中，触发器由时钟信号CP来触发，控制其翻转时刻，而对触发器翻转到何种状态并无影响。 2．时序逻辑的Verilog HDL描述 时序电路的行为决定了其只能通过always块语句实现，通过关键词“posedge”和“negedge”来捕获时钟信号的上升沿和下降沿。在always语句块中可以使用任何可综合的标志符。下面首先以D触发器为例，给出基本单元触发器的VerilogHDL实例，读者可自行完成其余常用触发器（RS触发器、JK触发器以及T触发器等）的Verilog HDL实现。 【例8-4】通过Verilog HDL实现D触发器。 同步D触发器的功能为：输入D只能在时序信号clk的沿变化时才能被写入到存储器中，替换以前的值，常用于数据延迟以及数据存储模块中。由于D触发器只有一个输入端，在许多情况下，可使触发器之间的连接变得非常简单，因此使用十分广泛。 上述程序在ISE中综合后的RTL级结构图如图8-11所示。 上述程序的仿真结果如图8-12所示。从中可以看出，在时钟上升沿，D触发器都将输入数据接收并寄存。 在给出时序逻辑设计最基本的电路后，下面给出图8-8所示电路的Verilog HDL实现，和例8-3的描述方法进行比较。 【例8-5】通过Verilog HDL语言实现例8-3所示电路。 程序在ISE综合后的RTL级结构图如图8-13所示，可以看出，其和图8-8是一致的，达到了设计的目的。 上述程序的仿真结果如图8-14所示，验证了程序的正确性。 在利用Verilog HDL描述时序电路时有以下几个问题需要注意。 （1）在描述时序电路的always块中的reg型信号都会被综合成寄存器，这是和组合逻辑电路所不同的。 （2）时序逻辑中推荐使用非阻塞赋值“&lt;=”，原因将在8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee39552bfdb38429756f5fe2750fe677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6ed86bda506c3cea5ca7620e1ef6706/" rel="bookmark">
			C&#43;&#43;判断一个序列是否为堆（最大堆、最小堆）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考： https://blog.csdn.net/guoweimelon/article/details/50904346 1、如何判断一个序列是不是堆？ 把这个序列看成是数组型的二叉树， 如果根节点是i，左子数是2*i，右子数是2*i+1。 2、 堆分为最大堆和最小堆。 （1）最大堆 当父节点的键值总是大于或等于任何一个子节点的键值时为最大堆。画成堆形式如下： （2）最小堆 当父节点的键值总是小于或等于任何一个子节点的键值时为最小堆，画成堆形式如下： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbfadae15f0eff9f5af514eff38fb0c6/" rel="bookmark">
			如何使用reshape/reshape2使劲揉你的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想必各位之前对 Hadley Wickham 大神都有所耳闻了。名声遐迩的ggplot2就是Hadley大神一手开发的，当然大神还很多产，除了ggplot2，还写了plyr、dplyr以及本文要说的reshape/reshape2包。作为Rstudio的首席科学家，让我们在学习reshape包之前膜拜一下Hadley大神：
reshape/reshape2包提供了一套数据重构和整合的工具。功能看起来类似excel中的数据透视表，但其间数据形式的千变万化仅靠两个核心函数melt和cast即可实现。在开发出reshape包5年之后，大神对原来的代码进行了重构重新发布了reshape2包，二者在本质上并无差异，相较于reshape包，reshape2的特性在于：
用dcast和acast函数代替了原先的cast函数
可以用变量名来设定边际参数
删除了cast函数的一些功能，dplyr包可以在这些函数上表现更好
对melt函数族增加了缺失值处理参数
reshape2计算效能更加快速
reshape包
用R语言实战一书中的一个简单的例子来看reshape的两个核心函数melt和cast的功能。melt表示对原始数据进行融合，将其重构为这样一种数据格式：每个测量变量独占一行，且行中要带有唯一识别这个测量所需的变量标识符。
cast函数读取melt过后的数据，并使用公式将其重塑为任何你想要的数据。其调用方式为：
newdata&lt;-cast(mdata,formula,FUN)
其中mdata为已融合过的数据，formula为重塑公式，FUN为数据整合函数。formula接受的公式格式如下：
rowvar1+rowvar2+...~colvar1+colvar2+...
rowvar1+rowvar2+...为选取的行标识变量，colvar1+colvar2+...为选取的列测量变量。
且看例子：
library(reshape)
#原始数据
mydata&lt;-data.frame(id=c(1,1,2,2),time=c(1,2,1,2),
X1=c(5,3,6,2),X2=c(6,5,1,4))
#melt进行数据融合
md&lt;-melt(mydata,id=(c("id","time")))
md
id time variable value
1 1 1 X1 5
2 1 2 X1 3
3 2 1 X1 6
4 2 2 X1 2
5 1 1 X2 6
6 1 2 X2 5
7 2 1 X2 1
8 2 2 X2 4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbfadae15f0eff9f5af514eff38fb0c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69a36b2937b8ce25e283dd8a44c9f931/" rel="bookmark">
			Java开发实例大全提高篇——JFreeChart图表篇（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发十年，就只剩下这套架构体系了！ &gt;&gt;&gt; 第2篇 JFreeChart图表篇
第7章 JFreeChart基本操作
7.1 JFreeChart基础操作
实例144 基本饼图
public JFreeChart getJFreeChart() {
PieDataset dataset = getPieDataset();
JFreeChart chart = ChartFactory.createPieChart("Pie title",
dataset, false, false, false);
return chart;
}
/**
* 创建一个饼图表的数据集
*
* @return
*/
private PieDataset getPieDataset() {
DefaultPieDataset dataset = new DefaultPieDataset();
dataset.setValue("A", 200);
dataset.setValue("B", 400);
dataset.setValue("C", 500);
return dataset;
}
public static void main(String[] args) {
ChartDemo1 chartDemo1 = new ChartDemo1();
ChartFrame chartFrame = new ChartFrame("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69a36b2937b8ce25e283dd8a44c9f931/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e7d645ba5c525d270bb9dbe682cdbc/" rel="bookmark">
			如何对网站关键词进行合理布局？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网站关键词优化是做网站seo优化的至关重要的步骤，如果你网站的关键词布局、关键词运营、关键词设置、关键词挑选没有做好，那样会导致你后期优化效果乏力，不能得到理想的优化成效。所以网站关键词优化不单单只是简单的挑选设置关键词那么简单，还要知道怎么样去布局关键词，每个页面分配几个关键词才是合理的。今天小编给大家分析下网站关键词该怎么样合理分配到每个栏目页面。 做网站seo优化都知道，网站首页要比其他页面的权重高，所以导致很多人在做关键词布局的时候，经常把一大堆核心的关键词堆积在首页当中，这样的做法不单不能起到很好的效果，反而影响了网站整体排名效果。要合理的分布和设置，这样你整个网站不单单靠的是首页，只要运用分配好，每个网站页面都能为你带来可观的流量。还有在这里需要给大家说下，做网站优化推广不要一开始就进行盲目的站外推广，在你网站内部优化还没有做好的情况下，切记不要任意妄为。当你做好网站优化的细节后，可以先利用易推宝为网站进行站外推广排名工作。易推宝详情： http://www.iisp.com/yituibao/?s=hyc 网站的网站的关键词布局核心是什么？该怎么样去布局要优化的关键词呢？接下来从三个方向给大家分析： 1. 网站首页关键词如何布局才合理？ 现在很多企业网站处在这样的现象：把绝大部分的关键词全都堆积在的网站的首页标题中，这样的做法非常的不好。首先如果你网站首页的关键词过多，不单会让你的网站标题变得很长，还会让网站在搜索结果中显示出来的标题变得不全，更重要的如果网站首页标题过长还会因关键词过多导致关键词权重分散，不能让关键词得到更好的排名。那么，关于首页关键词的布局怎么样才是合理的呢？ 建议是一般情况把3-5个主关键词放在首页优化，主关键词一般竞争会大一些，用首页去竞争，优化做起来比较容易，在做关键词布局之前，一定要分析关键词，做好关键词库，为后期做准备。 2. 网站栏目页关键词如何布局才合理？ 栏目的关键词布局要根据你一开始拟定的关键词库，挑选一些次重点关键词分配到栏目页面，每个网站栏目页面也是与首页一样最好是布局3-5个为宜，不要过多。虽然栏目页权重没有首页高，但是只要你做好了也可以排到别人首页网站前面的。当然栏目也关键词还需要你的 网站模板结构合理，这样才能更好的布局。 3. 网站内容页关键词如何布局才合理？ 内容页面的关键词一般可以利用长尾词进行布局，你有多少的长尾词就可以用多少内页去做优化，而且长尾词所带来的效果非常可观，长尾词能够带来的流量和转化率是你意想不到的。 关于文章内容页关键词你要注意： （1) 正文第一句话必须出现核心关键词 （2) 正文中间出现一次关键词 （3) 文章结尾处出现关键词 （4) 图表标题出现关键词 （5) 锚文本连接内加入关键词 这些位置加入核心关键词之后，剩下的就是要有意识地加入次级关键词和长尾关键词。一篇文章最多优化3个关键词。因此，核心关键词及其同义变形词部署好之后，次级关键词适当出现2 - 3次即可，切忌喧宾夺主。长尾关键词一般出现一次即可，因为搜索次数不多，也很少有人刻意去下功夫优化长尾。文章内容和段落不宜过长。太长最好分成几篇来描述，把大段内容分成几个小段内容。 网站的seo优化不是一件简单的事，它是一项长期的工程。网站的优化不是单纯网站关键词优化，还包含了许许多多的方面，只有做好每一个方面才能真正的把网站优化好，才能有好的排名。还有想要做好网站优化前提你要拥有一个利用优化的网站，对于这一点很多人都很忧虑，什么样的网站才符合优化的条件呢？当然， 你可以选择寻找专业的公司合作为你 定制网站 。亦或者可以利用 建站宝盒响应式建站系统来建设一个利用优化的响应式网站。关于更多的网站关键词优化详情可以留意原文： http://www.iisp.com/ztview/F_hyc174.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3a3f1ed2a7405dc1099e356e2f5820a/" rel="bookmark">
			配置的shiro登录页面报错及解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 23 WARN [org.apache.shiro.mgt.DefaultSecurityManager] - Delegate RememberMeManager instance of type [org.apache.shiro.web.mgt.CookieRememberMeManager] threw an exception during getRememberedPrincipals(). org.apache.shiro.crypto.CryptoException: Unable to execute 'doFinal' with cipher instance [javax.crypto.Cipher@7081c100]. at org.apache.shiro.crypto.JcaCipherService.crypt(JcaCipherService.java:462) at org.apache.shiro.crypto.JcaCipherService.crypt(JcaCipherService.java:445) at org.apache.shiro.crypto.JcaCipherService.decrypt(JcaCipherService.java:390) at org.apache.shiro.crypto.JcaCipherService.decrypt(JcaCipherService.java:382) at org.apache.shiro.mgt.AbstractRememberMeManager.decrypt(AbstractRememberMeManager.java:482) at org.apache.shiro.mgt.AbstractRememberMeManager.convertBytesToPrincipals(AbstractRememberMeManager.java:419) at org.apache.shiro.mgt.AbstractRememberMeManager.getRememberedPrincipals(AbstractRememberMeManager.java:386) at org.apache.shiro.mgt.DefaultSecurityManager.getRememberedIdentity(DefaultSecurityManager.java:604) at org.apache.shiro.mgt.DefaultSecurityManager.resolvePrincipals(DefaultSecurityManager.java:492) at org.apache.shiro.mgt.DefaultSecurityManager.createSubject(DefaultSecurityManager.java:342) at org.apache.shiro.subject.Subject$Builder.buildSubject(Subject.java:846) 解决： 本地cookie问题，清除一下就可以了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fffc0c644ae58f5b50eca8573719725/" rel="bookmark">
			Linux Kernel gpio export功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 在正常情况下，假设我们在控制usb使能相关gpio脚的时候，代码中通常我们会做如下调用：
#define USB_EN_GPIO 11 gpio_request(USB_EN_GPIO, "usb_en"); gpio_direction_output(USB_EN_GPIO, 1); gpio_export(USB_EN_GPIO, false); 上述执行完毕之后就可以给 GPIO_11 这个口上电，并且会生成 sysfs相关的控制节点。这里是/sys/class/gpio/gpio11/的目录，该目录下的内容为：
-rw-r--r-- 0 0 4096 1970-01-01 01:38 active_low -rw-r--r-- 0 0 4096 1970-01-01 01:38 direction drwxr-xr-x 0 0 1970-01-01 00:00 power lrwxrwxrwx 0 0 1970-01-01 01:38 subsystem -&gt; ../../../../class/gpio -rw-r--r-- 0 0 4096 1970-01-01 00:00 uevent -rw-r--r-- 0 0 4096 1970-01-01 01:38 value 调用 gpio_export() 就可以生成该GPIO相关的sysfs控制节点。
二、gpio_export() 1、函数定义： // include/asm-generic/gpio.h /* * A sysfs interface can be exported by individual drivers if they want, * but more typically is configured entirely from userspace.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fffc0c644ae58f5b50eca8573719725/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08d42479135c9c91864bc32ebc753c00/" rel="bookmark">
			Keil调试程序如何查看变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一个问题：调试时候想实时查看某一变量变化？
view 菜单下的 watch windows，全局变量才能查看点击打开链接
比如要查看u8 adcx的值变化，如下：
全速运行后，如下：
无法查看！什么问题？
该变量非全局变量！
解决办法： 必须是当前断点处所在的函数里面有这个参数才行,或者是全局变量.点击打开链接
将变量adcx改为全局变量：
调试状态下，鼠标选中变量后点右键，弹出的菜单有增加到变量窗口一栏，添加到watch #1 watch #2都可以。点击打开链接
第二个问题：Watch1窗口中变量adcx值不能实时显示？
解决方法：
8楼：调试状态下，勾上View-&gt;Periodic Window Update 点击打开链接
第三个问题：调试时候如何查看局部变量？
watch框内的变量只有在当前变量作用域的才可以添加，例如全局变量。局部变量即使添加后，在下次调试时也会从watch窗口移除，改到locals窗口内显示。locals窗口是查看当前函数处内部变量值得窗口。点击打开链接
我的理解：Call Stack + Local窗口变量自动的添加，取决于程序设置断点停止的位置有哪些局部变量和显示停止时刻的值。断点作用域改变，窗口中的变量名也随之改变。程序运行状态无法显示。
上面图片源自于：KEIL help文档
keil在调试时watch 窗口里面的各个选项框有什么不同？点击打开链接 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f8fc1fd6505146471704f9df6fb1a5/" rel="bookmark">
			基于SpringBoot &#43; Mybatis &#43; webpack&#43;VueJs &#43; ElementUI编写的管理系统（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面：第一篇主要写Vue，第二篇主要写SpringBoot（可能没第二篇了。。）
一、基本思维 整个系统所采用的是前后端分离的理念，vue负责页面展示，SpringBoot负责业务逻辑处理，这样在编写的过程中很容易发现问题的所在以及给后期维护减少了许多麻烦。
二、部分截图
三、源代码地址 这里我给出我在码云备份的代码。（希望你们能看清楚我写的是什么。） Vue部分（主要在src中）：https://git.oschina.net/littleeight/vue_danger SpringBoot部分：https://git.oschina.net/littleeight/springboot_danger
四、Vue的入门 一、vue安装。vue的安装其实官网写的很清楚了。这里注意的是安装过程中这个选项要选择no。 二、Vue的架构 Index.html==&gt;&gt;main.js==&gt;&gt;app.vue==&gt;&gt;hello.vue，这个是vue的流动过程，我们在编写自己的vue时，只需要在app.vue中写好跳转便可。
四、具体实现
1、主界面 位置在src-danger-main.vue，从主要代码( 不要了css部分)跟图片结合来讲。
&lt;template&gt; &lt;div class="main"&gt; &lt;!--头部--&gt; &lt;el-row :gutter="0"&gt; &lt;!--头部左边--&gt; &lt;el-col :span="4"&gt; &lt;div class="main-top main-top-left"&gt; &lt;h1&gt;危险辨识系统&lt;/h1&gt; &lt;/div&gt; &lt;!--头部右边--&gt; &lt;/el-col&gt; &lt;el-col :span="20"&gt; &lt;div class="main-top main-top-right"&gt; &lt;h2&gt;{{ username }},欢迎您!!!&lt;/h2&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;!--中部--&gt; &lt;el-row&gt; &lt;!--中部左边--&gt; &lt;el-col :span="4"&gt; &lt;div class="main-middle-left"&gt; &lt;el-menu default-active="2" class="main-middle-left-menu" theme="dark" router&gt; &lt;el-menu-item index="/DeptInfo"&gt;单位信息&lt;/el-menu-item&gt; &lt;el-menu-item index="/FileQuire"&gt;法规文件查询&lt;/el-menu-item&gt; &lt;el-menu-item index="/CriticalQuire"&gt;临界值查询&lt;/el-menu-item&gt; &lt;el-menu-item index="/DangerQuire"&gt;危险源辨识&lt;/el-menu-item&gt; &lt;el-menu-item index="/RecordQuire"&gt;查询记录&lt;/el-menu-item&gt; &lt;/el-menu&gt; &lt;el-menu default-active="2" class="el-menu-vertical-demo" theme="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4f8fc1fd6505146471704f9df6fb1a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c08ac3a04028c82c9aeec54ed565a44/" rel="bookmark">
			C语言语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入两个数，分别赋值该a,b，%d表示两个数都是十进制数（当然都是整数）。相对应的还有%b（二进制），%h（十六进制），以及%O八进制 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58ac1426102a2e97262f593be3637d3f/" rel="bookmark">
			区块链 基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特点：公开、透明，解决交易中信任问题，通过技术推动社会交易成本的降低。 采用新的清算方式, 使用流水账记录。 1. 区块链的六层结构 数据层 数据区块， 链式结构， 时间戳， 非对称加密， 哈希函数， Merkle树。网络层 P2P网络， 传播机制， 验证机制共识层 PoW, PoS, DPoS激励层 发行机制， 分配机制合约层 脚本代码， 算法机制， 智能合约应用层 可编程货币， 可编程金融， 可编程社会 从1 —-》6 由底而上 各层之间相互配合， 实现一个去中心化的信用机制。 2. 区块链技术概念 通俗说： 分布式记账; 形成 公开,透明,不可篡改、不可伪造的数据库.区块链技术的本质是一种互联网协议。只有当所有网络节点(或大部分节点)进行区块确认后， 该笔交易才算真正结束。 区块链技术在没有中央控制点的分布式对等网络下，使用分布式集体运作的方法，构建了一个P2P的自组织网络。通过复杂的校验机制，区块链数据库能够保持完整性、连续性和一致性，即使部分参与人作假也无法改变区块链的完整性，更无法篡改区块链中的数据。
核心技术1：区块+链 = 时间戳.
核心技术2：分布式结构——开源的、去中心化的协议. 5.1 分布式记账、分布式传播、分布式存储这三大技术: 实现该系统的”不可被控”.核心技术3：非对称加密算法 核心技术4：脚本. 增加区块链技术的可拓展性, 会使系统有机会去处理一些无法预见到的交易模式，保证了这一技术在未来的应用中不会过时，增加了技术的实用性。 总结: 1 区块链是一种分布式的不可篡改的数据库;2 该数据库由按时间顺序的区块组成;3 区块由一段时间内的网络交易信息组成;4 该数据库的特点是: 分布式, 所有者共同维护; 3. 共识机制 POW : 工作量证明 (第一种) 比特币的共识机制(POW): 工作量证明机制. (以太坊前三个阶段也采用该机制);工作证明: 设立一个奖励，要想得到就得付出代价，付出代价的方式是解题（比特币是SHA-256，以太坊是SHA-3），谁先解出来，奖励就归谁，一旦计算出来后，要告诉大家，大家会帮你验证，大家都承认后你就可以拿到这个奖励，然后基于这道题目继续算下一个题目，如此反复;因为每一个区块链都是基于前一个区块链产生的，如果有攻击者要修改之前的记录，从那之后每一个区块链都要重新付出劳动，POW机制通过控制区块的平均生成时间，降低攻击者试图赶上随后区块的概率;大家帮忙验证其实是一个集体投票的结果，大多数人决定了最长那条链，因为那条链中包含最多的工作量证明，并且投票是基于计算力（CPU），有计算力才有投票权;POW机制解决了拜占庭将军问题 : 即在 互相不信任 的情况下，只要 好人的数量大于坏人，就保证系统的正确运转（符合大多数的意愿），让系统具备一定的 容错性，这也就是大家所说的：区块链具备去信任的能力; POS : Proof of Stake，权益证明 (第二种) 权益证明 : 主要思想是节点记账权的获得难度 与 节点持有的权益成反比， 相对于PoW，一定程度 减少 了数学运算带来的资源消耗，性能也得到了相应的提升，但 依然是基于哈希运算竞争获取记账权的方式; POW 和 POS　共识机制的不同之处在于： 1 POW 在于对各节点计算出来的结果进行共识;2 POS 在于对选择哪个节点进行记账进行共识;3 所以不同之处在于: 一个是进行记账结果的共识, 一个是进行选择谁进行记账的共识;(以上属于自己的理解) 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58ac1426102a2e97262f593be3637d3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c0c790321acc2962d263fa01c0d805d/" rel="bookmark">
			js获取freemarker变量的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后台数据
@RequestMapping(value="/suit_item", method = RequestMethod.GET) public String getSuitItem(HttpServletRequest request, ModelMap map) { //TO DO map.put("testCaseDtoList", testCaseDtoList); return "/suit/suit_item"; } 需要获取一个list里面的id
前台js可以这么写
&lt;script type="text/javascript"&gt; $(document).ready(function() { var checkedArray =[]; //初始化将测试集包含的用例存在数组里面 &lt;#if testCaseDtoList??&gt; &lt;#list testCaseDtoList as item&gt; checkedArray.push("${item.id}"); &lt;/#list&gt; &lt;/#if&gt; }); &lt;/script&gt; 页面初始化之后就可以使用checkedArray
完美！
转载于:https://www.cnblogs.com/chn58/p/7084819.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/059272c32673b52bf9f4aedaa5c800e2/" rel="bookmark">
			用回溯法解决八皇后问题(Java实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。
—-以上内容引自百度百科。
本程序的功能是打印八皇后的所有摆放方式，用回溯法解决，使用的语言是Java，主要函数在代码中都有注释。 主要思想是：从第0行开始摆放皇后，第0行摆放完毕后，就摆放第1行，以此类推…当第7行摆放完毕，即棋盘上已经有了8个皇后，就打印出所有皇后的路径。接下来，就从第8个皇后开始，逐一将摆放好的皇后撤回。每撤回一个，就试探该行的其它位置（因为我们要打印所有正确的摆法）。 程序如下：
从运行结果可以看出：八皇后共有92种摆法。 public class EightQueen{ private static final int SIZE = 8; //皇后的个数，此处设为8，表示8个皇后 private static int count = 0; //记录摆放的方式数 public static void main(String[] args) { LinkedList&lt;Location&gt; list = new LinkedList&lt;Location&gt;(); eightQueen(list, 0, 0); //从棋盘的第0行第0列开始 System.out.println("八皇后共有 " + count + "种摆放方式"); } /** * 定义位置的数列结构，用于表示皇后的摆放位置 */ static class Location { int x ; //对应棋盘的列 int y ; //对应棋盘的行 Location(int x, int y){ this.x = x; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/059272c32673b52bf9f4aedaa5c800e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/facfe09864a2fd583de1885fe6f914e9/" rel="bookmark">
			qq提供的聊天接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做网页时候，我们有时候需要做在线咨询功能，我们可以通过qq提供的接口来通过点击一个链接来直接弹出聊天对话框
&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;a href="tencent://message/?uin=123456789&amp;Site=&amp;Menu=yes"&gt;点这个链接会打开一个和QQ是123456789的用户聊天的窗口&lt;/a&gt; &lt;/html&gt; 好简单，记录下来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60a1d35ae9436f2369536eba703db2d1/" rel="bookmark">
			图像几何变换（geometric transformation）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. imwarp B = imwarp(A,tform) demo
I = imread('cameraman.tif'); tform = affine2d([1 0 0; .5 1 0; 0 0 1]); % x ⇒ x+0.5*y % y ⇒ y J = imwarp(I,tform); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66372cdc2227fc589c1b3d0b591ec569/" rel="bookmark">
			codeforces 821 B Okabe and Banana Trees
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：http://codeforces.com/contest/821/problem/B 大致题意： 给两个正整数m,b,画出一条直线y = -x/m + b，求直线下的一个矩形使得获取的香蕉数最多，每个点(x,y)的香蕉数目为 x+y。 解法： 可推得公式，矩形右上角为(x,y)的香蕉总数为 (x+1) * x / 2 * (y+1) + (y+1) * y /2 * (x+1) 然后，依次遍历直线上的格点，求出矩形右上角为格点坐标的香蕉总数，取最大值。 代码：
#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int main(){ long long m,b; cin &gt;&gt; m &gt;&gt; b; long long ans = -1; for(long long i = 0 ; i &lt;= b; i++){ long long j = m * (b-i); ans = max(ans, (1+i) * i / 2 * (j+1) + (1+j) * j /2 * (i+1)); } cout &lt;&lt; ans &lt;&lt; endl; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2867f72aea0fd197b9a4396b1d2d24e/" rel="bookmark">
			Android中字母大小写切换的快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.选中要切换到字母 eclipse
ctrl+shift+x 转为大写 ctrl+shift+y 转为小写
2. Androidstudio字母大小写切换用一下方法或直接使用快捷键（大小写转换 Cmd + Shift + U Ctrl + Shift + U）
（1）.打开as
（2）.需要在切换的字符中，选中该这些的小写的字母
（3）.选中完成了字母之后，然后就进行点击Android studio的菜单中的”Edit“的选项菜单。
（4）、点击完了edit的选项菜单之后，就会弹出了一个下拉菜单中进行选择“Toggle case”的选项菜单。
（5）、在Android studio的toggle case的选择完成之后，可以在输入代码中小写的字母切换成了大写的字母。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6c5e81151348fb8685ccc64090085c8/" rel="bookmark">
			ES6之块级作用域与函数声明--读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数能不能在块级作用域之中声明？ ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 // 情况一 if (true) { function f() {} } // 情况二 try { function f() {} } catch(e) { // ... } 上面两种函数声明，据 ES5 的规定都是非法的。 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。 再来看一下ES6： ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 下面看一段代码： function f() { console.log('I am outside!'); } (function () { if (false) { // 重复声明一次函数f function f() { console.log('I am inside!'); } } f(); }()); ES6 理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？ 原因是若改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6规定，浏览器的实现可以不遵守上面的规定，允许有自己的行为方式。 允许在块级作用域内声明函数。函数声明类似于var，即会提升到全局作用域或函数作用域的头部。同时，函数声明还会提升到所在的块级作用域的头部。 注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。 // 浏览器的 ES6 环境 function f() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6c5e81151348fb8685ccc64090085c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2928204041233165c6176d1fc2ebabde/" rel="bookmark">
			异地多活个人笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://mp.weixin.qq.com/s/UbW9q7Mzt4QMRrQrEmAxNw
异地容灾：传统来说，异地是冷备份，存在冷备份数据可靠性、实时性、切换启动耗时等问题
异地项目最大的挑战是延时
最简单、最好的办法，就是让操作全部在同一机房内完成，这就是单元化
需要在异地部署的是流量会爆发式增长的，流量很大的那部分，异地部署，我们要在成本之间找到一个平衡点
异地多活最大的风险在于，它的数据会同时在多个地方写，冷备则不存在数据会写错的问题
目前实现整个单元化项目最大的几个难点是：
第一个是路由的一致性。
第二个是挑战是数据的延时问题。
第三个是数据的正确性很难保证。
第四个是数据的一致性。
第五个怎样确保对业务的影响最小，也是一个挑战。
真正所有做到高可用的网站，最重要的一点是故障恢复时间的控制。
如果一地出现故障，不管是什么原因，最容易的解决方案，就是把这一地的流量全部切走。这样可以把故障控制在一分钟以内，整个可用性是非常高的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f8baa4d78c5c5aab8cd0202d861ddd8/" rel="bookmark">
			mysqldump备份原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里通过开启general log追踪mysqldump的备份过程，可以动态调整general log的参数设置。 一、不加--single-transaction备份 mysqldump --default-character-set=utf8mb4 -uroot --triggers -R -E -A --master-data=2 |gzip &gt;dbbackup.sql.gz 1、连接数据库 2、调整sql_mode、time_zone 3、刷新tables(关闭所有打开的表并清空缓存数据) 4、FLUSH TABLES WITH READ LOCK(执行全局读锁) 5、记录相关变量、参数、binlog位置等 6、备份数据文件、表空间等 7、备份业务表结构、表数据、触发器 8、备份系统表结构、表数据、触发器 9、备份函数、存储过程 10、备份结束退出，全局锁自动释放 2017-06-24T00:48:48.622170Z 56 Connect root@localhost on using Socket 2017-06-24T00:48:48.622372Z 56 Query /*!40100 SET @@SQL_MODE='' */ 2017-06-24T00:48:48.622500Z 56 Query /*!40103 SET TIME_ZONE='+00:00' */ 2017-06-24T00:48:48.622654Z 56 Query FLUSH /*!40101 LOCAL */ TABLES 2017-06-24T00:48:48.623539Z 56 Query FLUSH TABLES WITH READ LOCK 2017-06-24T00:48:48.623669Z 56 Query SELECT COUNT(*) FROM INFORMATION_SCHEMA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f8baa4d78c5c5aab8cd0202d861ddd8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/530/">«</a>
	<span class="pagination__item pagination__item--current">531/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/532/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>