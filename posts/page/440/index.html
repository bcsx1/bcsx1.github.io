<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/477144388317d4ab88b9af3bf5ef525d/" rel="bookmark">
			宏定义中的#
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
问题描述 **
工作中遇见下列代码
#define printFLV(_int)	printf("%s()--L:%d " #_int"=%d\n",__FUNCTION__, __LINE__, _int); 解释
1、首先这是一个宏定义，而宏定义中的“#”表示是“字符串化”的意思，即是把跟在后面的参数转换成一个字符串；
2、根据上面的解释，printFLV(data)，即：
printf("%s()–L:%d " “data”"=%d\n",FUNCTION, LINE, data);
3、通过使用宏定义及宏定义中“#”，可以使printf的应用更加灵活。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad00987bff2248a3ad80c134ace6b231/" rel="bookmark">
			爬取电影信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前爬取过基于html跳转的豆瓣TOP250网页，还有基于ajax跳转的美团评论网页，这次将介绍如何爬取基于html和ajax两种跳转方式且含有反爬虫程序和异常值的电影信息网页
电影信息网页链接：
http://movie.mtime.com/boxoffice/#CN/2019
爬取电影信息 1.分析网页(1)爬取目标(2)分析2018年的电影信息(3)分析点击2018年时10个页面的json文件(4)请求并筛取信息 2.提取信息(1)提取电影名及电影排名(2)提取首日票房数字(3)提取导演名字及模糊匹配(4)提取演员名字(5)字符串拼接(6)提取内容在同一字符串输出 3.代码异常处理及汇总(1)替换提取内容中的信息(2)代码汇总及保存 4.爬取2020年的电影信息(1)爬取2020年第一页电影信息(2)爬取2020年10页的电影信息(3)跳过错误继续爬取(4)记录代码运行时间 1.分析网页 (1)爬取目标 (2)分析2018年的电影信息 可以看出网页左边，电影年度可以分为2018,2019,2020年三个部分，我们先针对2018年时的网页进行分析并爬取
分析点击2018年时，第一页的网页链接：
切换到2018年时第二页的网页为：
分析结果：
据以上结果可看出，当点击选择到2018年的电影信息，并进行切换时，链接都为
http://movie.mtime.com/boxoffice/#CN/2018
切换网页时链接没有发生改变，说明在2018年的电影信息这个部分,网页是基于ajax跳转的，可利用抓包技术对网页进行爬取 (3)分析点击2018年时10个页面的json文件 寻找json文件方法：
找到页面json文件后复制链接的方法：
2018年时第一个页面的json文件链接为：
http://movie.mtime.com/boxoffice/?year=2018&amp;area=china&amp;type=MovieRankingYear&amp;category=all&amp;page=0&amp;display=list&amp;timestamp=1586871242566&amp;version=07bb781100018dd58eafc3b35d42686804c6df8d&amp;dataType=json 2018年时第二个页面的json文件链接为：
http://movie.mtime.com/boxoffice/?year=2018&amp;area=china&amp;type=MovieRankingYear&amp;category=all&amp;page=1&amp;display=list&amp;timestamp=1586871698868&amp;version=07bb781100018dd58eafc3b35d42686804c6df8d&amp;dataType=json 2018年时第十个页面的json文件链接为：
http://movie.mtime.com/boxoffice/?year=2018&amp;area=china&amp;type=MovieRankingYear&amp;category=all&amp;page=9&amp;display=list&amp;timestamp=1586871775520&amp;version=07bb781100018dd58eafc3b35d42686804c6df8d&amp;dataType=json 对以上三个链接进行分析可得出，有以下两个个地方不一样：
第一个不同的地方：
因为我们找的是第一页，第二页和第十页的链接，所以此处的0,1,9表示的是第一页，第二页和第十页
第二个不同的地方：
此处的timestamp是时间戳
(4)请求并筛取信息 导入接下来要用的库 # 导入需要的库 import csv,requests,time from lxml import etree 设置浏览器代理，构造字典，向服务器请求json文件 # 导入需要的库 import csv,requests,time from lxml import etree # 设置浏览器代理，构造字典 headers={ 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.92 Safari/537.36' } #此处的url暂时放入的是page=0时，2018年的电影信息第一页 url="http://movie.mtime.com/boxoffice/?year=2018&amp;area=china&amp;type=MovieRankingYear&amp;category=all&amp;page=0&amp;display=list&amp;timestamp=1587124108705&amp;version=07bb781100018dd58eafc3b35d42686804c6df8d&amp;dataType=json" requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad00987bff2248a3ad80c134ace6b231/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ffa7fd006110115bf8cfd814bd84c78/" rel="bookmark">
			慕测平台的使用—— 在eclipse上安装mooctest插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在慕测平台上下载工具
http://www.mooctest.net/download
2.下载完成后解压：
3.安装插件
第一步：将plugins文件夹中的jar包复制到eclipse文件夹下的 plugins文件夹下
第二步：将下载的插件中的features文件夹复制到eclipse的根目录下
注意：是复制整个文件夹
注意：是复制到根目录下
3.重启eclipse
发现菜单栏多了一个选项
到此为止，安装成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e1f765d73734185600def4fe5904665/" rel="bookmark">
			C&#43;&#43;实现计算组合数（详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： 计算两个非负整数n和m，返回组合数。例如当n &lt; 25,m = 12 时，答案为5200300。 计算组合数的公式： 先从排列数说起，排列数指从n个不同的元素中取出m(m &lt;= n)个元素的所有不同排列的个数。 由这个定义可以得到排列数公式为： = n * (n - 1) .....(n - m + 1) = 组合数和排列数的区别在于组合数与元素的顺序无关，排列数与元素的顺序有关。 有公式： 程序： 按照组合数的公式有：
#include&lt;cstdio&gt; using namespace std; long long factorial(int n) { long long m = 1; for (int i = 1; i &lt;= n; i++){ m *= i; }//for return m; } long long C(int n, int m) { return factorial(n) / (factorial(m)*factorial(n - m)); } int main() { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e1f765d73734185600def4fe5904665/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3e1b4efaebde6f199d9620cd563a9db/" rel="bookmark">
			两个线程交替执行交叉打印两个字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比如
String a = "1234"; String b = "abcd"; 通过两个线程实现打印结果：12ab34cd
public class Test { private ReentrantLock lock = new ReentrantLock(); private Condition conditionA = lock.newCondition(); private Condition conditionB = lock.newCondition(); private boolean flag = true; public static void main(String[] args) { String a = "1234"; String b = "abcd"; Test test = new Test(); Thread t1 = new Thread(() -&gt; { test.outA(a); }); Thread t2 = new Thread(() -&gt; { test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3e1b4efaebde6f199d9620cd563a9db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14ddee5dc9beb6f4393f059ebf78b4f6/" rel="bookmark">
			给定一个链表，两两交换其中相邻的节点，并返回交换后的链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目原文
题目：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。示例:给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.
可以用递归或者非递归的方式来做这个题
非递归方式
思路：声明三个节点，前两个节点进行交换，最后一的声明的节点用来表示位置。while循环结束的条件是cur之后（包括cur）必须有两个及以上的非空节点。
public static ListNode swapPairs(ListNode head) { if(head==null || head.next==null){ //链表没有结点或者只有一个结点，直接返回不进行交换。 return head; } ListNode pre=head; ListNode preNext=head.next; ListNode cur=preNext.next; //以上三个节点的声明。前两个节点进行交换，后一个节点用来声明下一次进行交换的第一个元素。 pre.next=cur; preNext.next=pre; head=preNext;//新的头部; while(cur!=null&amp;&amp;cur.next!=null){//当cur和cur.next同时存在时才能交换，也就是要有2个以上 preNext=cur.next;//交换时第二个结点元素 cur=preNext.next;//下一次交换的第一个元素 pre.next.next=cur;//这个用处比较奇妙，这个是为了保证链表的完整性。 preNext.next=pre.next;//第二个元素后面链接第一个元素 pre.next=preNext;//上一次的交换后的第二个元素链接本次第二个元素 pre=preNext.next;//交换后的第二个元素 } return head; } 循环体里最终要的就是表示三个声明节点的位置，其中pre.next.next=cur，是为了保证链表的完整性。因为preNext.next=pre.next。
递归方式
思路：
刚开始链表由1-&gt;2-&gt;3-&gt;4构成。
下面的递归则是 swapPairs(1)函数开始：1-&gt;swapPairs(3) 3-&gt;swapPairs(5) //这个5指的是4的下一个节点，也就是null。
swapPairs(5)返回null，所以3-&gt;null，然后继续swapPairs（3）的后半部分，4-&gt;3-&gt;null.，并且返回4。
由于swapPairs(3)返回4，所以1-&gt;4-3-null，然后继续swapPairs（1）的后半部分，2-&gt;1-&gt;4-&gt;3-&gt;null。递归完成。
public ListNode swapPairs(ListNode head) { if(head==null||head.next==null){ return head; } ListNode first = head; ListNode last = head.next; //以上保存现场 first.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14ddee5dc9beb6f4393f059ebf78b4f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be0d5e3e9254c5908a34684612038fcc/" rel="bookmark">
			Error updating database. Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityCon Duplicate entry
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020-04-17 01:00:00.762 ERROR 2556 --- [ scheduling-1] o.s.s.s.TaskUtils$LoggingErrorHandler : Unexpected error occurred in scheduled task
org.springframework.dao.DuplicateKeyException: ### Error updating database. Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException: Duplicate entry '8504-1' for key 'uk_enterprie_id'
### The error may involve defaultParameterMap
### The error occurred while setting parameters
### SQL: insert into wecaht_push_monitor_template_info(enterprie_id, enterprie_name, monitor_title, monitor_item, monitor_level_id, alter_date, publish_date, info_url) values(?, ?, ?, ?, ?, ?, ?, ?)
### Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException: Duplicate entry '8504-1' for key 'uk_enterprie_id'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be0d5e3e9254c5908a34684612038fcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1aee9c40dd606ce5c749e233758d636/" rel="bookmark">
			Unicode与中文互转（反斜杠u(\u)开头的16进制Unicode编码转换成中文汉字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Unicode与中文互转 （反斜杠u(\u)开头的16进制Unicode编码转换成中文汉字 工具地址： http://www.msxindl.com/tools/unicode16.asp 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4df88970c886deb7c67c999eef53ac1/" rel="bookmark">
			ISO15765_2 网络层服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 参考OSI的CAN模型 1.1 CAN分层模型 CAN网络通信采用分层设计架构(参考OSI基本模型)，其分层如下：
编号
层架构
层架构
ISO
1
Application Layer
应用层
ISO-14229-3
2
Session Layer
会话层
ISO-14229-2
3
Network layer
网络层
ISO-15765-2
4
Data Link layer
数据链路层
ISO-11898-1
5
Physical layer
物理层
生产厂商定义
1.2 CAN 软件架构 CAN软件架构(Vector协议栈)如下：
注：如上图，只有诊断报文才会通过CANTp模块处理。
15765-2网络层服务介绍CAN TP模块的理论基础，用于诊断报文在网络层的传输，当接受数据大于8个字节时，网络层会把接收到的多帧数据组包成单个数据传输给应用层；当发送数据大于8个字节时，网络层会把数据分割成连续多帧报文传输到总线上。
标准CAN报文一次只能传输8个字节的数据，而部分诊断服务响应的数据长度超过8个字节，这时候发送节点网络层会把数据分割成若干连续的帧报文发送出去，接收节点接收到若干帧报文后，把数据重新组装在一起。
2 网络层协议 网络层服务协议指定不同ECU网络层之间的数据传输协议，网络层协议允许传输/接收数据长度最高达4095个字节的数据，并反馈传输/接收的结果给相对应的层。
报文数据长度不超过7个字节时，报文通过单帧发送/接收;当报文数据长度大于7个字节时，网络层会对数据进行组包(接收节点)及解包(发送节点)，并通过首帧，流控帧，续帧配合完成数据的发送。
2.1 帧格式 2.1.1 单帧传输数据 Sigle Frame（SF） 单帧用于传输长度小于等于7个字节的数据。
如请求诊断会话服务的请求默认会话子服务：
注： ID为0x713的报文为请求服务报文，由Client发出，Server接收；
ID为0x613的报文为响应服务报文，由Server发出，Client接受；
如何看诊断报文内容(通过协议控制信息(N_PCI)来区分)？
下表给出了诊断报文单帧的结构，Byte1 的前四bits的值为0(代表单帧)，后四个比特的值用于表明传输数据的字节数；
上面第一帧报文： 02 10 01
byte1中的0表明当前是单帧，2 代表当前帧数据长度为2；10 01 代表当前传输的数据(2个字节)；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4df88970c886deb7c67c999eef53ac1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e143239058887dcffeecc1f98b99fb47/" rel="bookmark">
			Unity3d烘焙常见&#34;黑斑&#34;解决方法(适用5.x、2017、2018、2019版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多Unity3d初学者在烘焙场景时，由于没有经验，模型上常常出现一些怪异的"黑斑"、“撕裂”、”硬边”、“漏光”现象（如下图所示），反复调试，问题依然得不到解决，搞得精疲力尽，甚至产生了放弃的念头，本文将针对Unity3d烘焙时常见的几种“黑斑”现象进行逐一分析和图解，希望对遇到这样问题的朋友有所帮助。
1. 图一，图二所示的黑斑，是因为模型没有光照贴图坐标，烘焙后光照图错乱造成的，清零烘焙数据，按照下图所示的步骤，勾选"generate lightmap UVs(创建光照贴图坐标)“选项，重新烘焙即可消除。
2. 图三所示的墙角的黑斑，实为漏光所致，很多人按照Unity3d的要求，采用最优化精简的单面建模构建的室内场景，因为墙背面是镂空的，灯光从室外照进来，烘焙后出现了"漏光”，可按下面两图所示步骤操作，并将Cast Shadows的选项改为“Shadows Only”，然后重新烘焙即可消除。
3. 图四、图五所示的黑斑，有人称之为“烘焙硬边”，是由于这些模型的UV在光照图中所占的比例太小，按照下图所示的步骤操作，并将“Scale In Lightmap”参数适当调大，然后重新烘焙即可消除
如果还有个别模型有硬边，按下图所示，将面光源移至窗户框以内，重新烘焙即可。
以上为笔者的个人经验，仅供大家参考，如有谬误，请指正！若您制作商业项目，可去网上找些Unity3d烘焙相关的教程，也可参看本人编制的Unity3d布光与光影烘焙及后处理实战视频教程。希望以上的解答对有此类问题的朋友有所帮助，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8892e221aa7c4d5f880c9ee0de25ec8/" rel="bookmark">
			微信小程序：局部变量和全局变量的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		局部变量，即只可以在单个页面使用的变量，不同页面间不能引用和修改其他页面的变量。而全局变量则可以实现不同页面之间共享变量。
1、局部变量 局部变量仅限在单个页面使用，如index页面，在index页面的index.js、index.wxml、index.wass、index.json定义的变量，仅限在这个index页面的文件中使用，无法共享到其它页面的文件中使用。
（1） 局部变量的定义：
局部变量在页面的index.js文件中的Page({data:{定义变量}})，如：
page({ data:{ str:'HelloWord', //定义字符串 num:1,//定义数字 bool：false //定义布尔类型 }, )} （2）局部变量的引用：
在页面的index.js文件中引用，需要加上前类项，如
this.data.str, this.data.num, this.data.bool 在页面的index.wxml文件中引用时，可直接使用，如：
&lt;text&gt;{{str}}&lt;/text&gt; &lt;text&gt;{{num}}&lt;/text&gt; &lt;text&gt;{{bool}}&lt;/text&gt; 注意：变量需要用两个大括号（{{ }}）括起来
（3）局部变量的修改：
局部变量的修改有两种：
方法一、
this.data.str = 'Welcome to Helloworld', this.data.num = 2, this.data.bool = true 方法二、
this.setdata({ str: 'Welcome to Helloworld', num:2, bool:true }) 以上两种方法均可对局部变量进行修改，可以根据个人喜爱，但建议：当需要修改的变量数量少时用方法一，数量多时用方法二。
2、全局变量 全局变量，是在全局的文件中定义，不仅在全局页面的文件中使用，还可共享给其它页面使用。一个微信小程序，一般包含多个页面，页面之间会跳转，这时需要在不同页面之间共享数据，这时就需要用到全局变量。
一个微信小程序会存在这三个文件：app.js、app.wass、app.json。而这三个文件就是全局文件。
（1）全局变量的定义：
在app.js文件中的App({globalData:{定义全局变量}})定义，如：
App({ globalData:{ str:'Helloworld', num:1, bool:false }, }) (2)全局变量的引用：
在app.js文件中的引用，如：
this.globalData.str, this.globalData.num, this.globalData.bool 在非app.js文件中的引用，需要先声明全局变量，再使用，如：
var app = getApp() //声明全局变量 app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8892e221aa7c4d5f880c9ee0de25ec8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d59b3f18b6f2fa4cf4c46414627d736b/" rel="bookmark">
			ParameterizedType及其方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在项目的BaseDao这个类中经常要用到ParameterizedType这个接口。
先贴一段代码：
public class BaseDao&lt;T&gt; { // Dbutils中的查询类 private QueryRunner queryRunner = new QueryRunner(); // 用来接收子类的泛型的类型 private Class&lt;T&gt; type; { // 子类对象被建立时，会调用父类的构造代码块 // 这里的this指向了子类对象 // 获取子类的Class对象 Class clazz = this.getClass(); // 获取带泛型的父类的ParameterizedType对象 ParameterizedType superclass = (ParameterizedType) clazz.getGenericSuperclass(); // 获取泛型参数数组 Type[] actualTypeArguments = superclass.getActualTypeArguments(); // 该数组的第一个值就是T(也就是子类的Class类型) type = (Class&lt;T&gt;) actualTypeArguments[0]; } 首先让我们来了解一下Type这个接口。
Type是Java中所有类型的通用超级接口。 这些类型包括基本类型，参数化类型，数组类型，类型变量。
这里的类型其实是某个类的对应的Class名。
如：Integer.class, Double.class, Person.class
public class Main { public static void main(String[] args) { Field[] fields = Person.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d59b3f18b6f2fa4cf4c46414627d736b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f77500a87d1f887c4e19c6b0f1d138eb/" rel="bookmark">
			解释SAR/INSAR/DINSAR的概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解释SAR/INSAR/DINSAR的概念及工作原理。
◆合成孔径雷达技术是干涉雷达和差分干涉雷达技术的基础，而干涉雷达和差分干涉雷达技术则是合成孔径雷达技术的应用延伸和扩展。
◆干涉雷达测量技术（INSAR)是以同一地区的两张SAR图像为基本处理数据，通过求取两幅SAR图像的相位差，获取干涉图像，然后经相位解缠，从干涉条纹中获取地形高程数据的空间对地观测新技术。
◆差分干涉雷达测量技术（D-INSAR）是指利用同一地区的两幅干涉图像，其中一幅是通过形变事件前的两幅SAR获取的干涉图像，另一幅是通过形变事件前后两幅SAR图像获取的干涉图像，然后通过两幅干涉图差分处理（除去地球曲面、地形起伏影响）来获取地表微量形变的测量技术。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b13483ceacc63218797b547990b89f1b/" rel="bookmark">
			SQLyog报错1064
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQLyog视图界面建表报错1064 double类型之后不能加长度
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22c3512efd9b4b612383bcb5f899c6a5/" rel="bookmark">
			十次方项目开发系列【10】：接口加密&amp;Eureka微服务和网关服务开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标
了解接口加密业务需求
掌握常用加密算法和密钥格式
实现十次方的接口加密微服务
文章目录 一 业务场景介绍二 加密方式2.1 摘要算法2.2 对称加密2.3 非对称加密2.4 数字签名（非对称加密） 三 OpenSSL生成RSA密钥对3.1 RSA算法的密钥格式3.2 OpenSSL生成RSA密钥对的命令3.2.1 生成RSA私钥，文本存储格式，长度20483.2.2 根据私钥生成对应的公钥3.2.3 私钥转化成pkcs8格式 四 搭建接口加密微服务4.1 修改tensquare_parent4.2 创建Eureka微服务4.3 修改文章微服务4.4 创建tensquare_encrypt网关服务接口加密微服务搭建完成 结束 一 业务场景介绍 数据安全性 - 抓包工具 fiddler
其他：wireshark charles
系统明文传输的数据会被不明身份的人用抓包工具抓取，从而威胁系统和数据的安全性 二 加密方式 2.1 摘要算法 消息摘要是把任意长度的输入揉和而产生长度固定的信息。
消息摘要算法的主要特征是加密过程不需要密钥，并且经过加密的数据无法被解密，只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文。消息摘要算法不存在密钥的管理与分发问题，适合于分布式网络上使用。
消息摘要的主要特点有：
无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。消息摘要看起来是“随机的”。这些数据看上去是胡乱的杂凑在一起的。只要输入的消息不同，对其进行摘要后产生的摘要消息也必不相同；但相同的输入必会产生相同的输出。只能进行正向的消息摘要，而无法从摘要中恢复出任何消息，甚至根本就找不到任何与原信息相关的信息。虽然“碰撞”是肯定存在的，但好的摘要算法很难能从中找到“碰撞”。即无法找到两条不同消息，但是它们的摘要相同。 常见的摘要算法：CRC、MD5、SHA等
2.2 对称加密 加密和解密使用相同密钥的加密算法。
对称加密的特点：
速度快，通常在消息发送方需要加密大量数据时使用。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。 典型应用场景：离线的大量数据加密（用于存储的）
常用的加密算法：DES、AES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK等。
加密的安全性不仅取决于加密算法本身，密钥管理的安全性更是重要。如何把密钥安全地传递到解密者手上就成了必须要解决的问题。
2.3 非对称加密 非对称加密算法是一种密钥的保密方法，加密和解密使用两个不同的密钥，公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。非对称加密算法的特点： 算法强度复杂加密解密速度没有对称密钥算法的速度快 经典应用场景：数字签名（私钥加密，公钥验证）
常用的算法：RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）。
2.4 数字签名（非对称加密） 数字签名（又称公钥数字签名）是一种类似写在纸上的普通的物理签名，是使用了公钥加密领域的技术实现，用于鉴别数字信息的方法。数字签名通常使用私钥生成签名，使用公钥验证签名。签名及验证过程： 发送方用一个哈希函数（例如MD5）从报文文本中生成报文摘要,然后用自己的私钥对这个摘要进行加密将加密后的摘要作为报文的数字签名和报文一起发送给接收方接收方用与发送方一样的哈希函数从接收到的原始报文中计算出报文摘要，接收方再用发送方的公用密钥来对报文附加的数字签名进行解密如果这两个摘要相同、接收方就能确认该数字签名是发送方的。 数字签名验证的两个作用： 确定消息确实是由发送方签名并发出来的确定消息的完整性 用于解决非对称加密后传输过程中被篡改密文
三 OpenSSL生成RSA密钥对 3.1 RSA算法的密钥格式 密钥长度在JDK 中默认长度是1024，且必须是64 的倍数。密钥的常用文件格式有pem（文本存储）或者der（二进制存储）。RSA使用pkcs协议定义密钥的存储结构等内容，私钥以PKCS#8格式编码 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22c3512efd9b4b612383bcb5f899c6a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cc1ea3f2065ade9efa7e2fc62047c18/" rel="bookmark">
			网站首页布局模板1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最常见的网站首页布局 准备代码原理 准备 说明：
参考腾讯云服务首页 （利用html页面定位到指定位置）
需要实现的效果 div内容用图片替代，背景图片准备dummyimage（一个很好的生成指定图片尺寸颜色的网站）
代码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;/head&gt; &lt;style&gt; *{ margin: 0; } html,body{ width: 100%; height: 100%; } .div1{ width:100%; height: 100%; background: url(00e6ff.png); background-size: cover; text-align: center; } .div2{ width:100%; height: 100%; background: url(5500ff.png); background-size: cover; } .div3{ width:100%; height: 100%; background: url(fff700.png); background-size: cover; } &lt;/style&gt; &lt;body&gt; &lt;section class="div1"&gt;&lt;button onclick="goTo3();"&gt;跳转到第三张&lt;/button&gt;&lt;/section&gt; &lt;section class="div2"&gt;&lt;/section&gt; &lt;section id="three" class="div3"&gt;&lt;/section&gt; &lt;section class="div2"&gt;&lt;/section&gt; &lt;/body&gt; &lt;script src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cc1ea3f2065ade9efa7e2fc62047c18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae704839eeb561adbb5b744c6f089cd6/" rel="bookmark">
			(NoPermissions (FileSystemError): Error: EACCES: permission denied, open &#39;&#39; 在Docker中的读写权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因Docker 的容器的对文件的权限不足 做法 在与container映射的目录中（即-v 选项的值）将写入权限给予公共组。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a98e166baa4948204ef073320b7c5bf/" rel="bookmark">
			MySQL查看编码命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MySQL查看编码修改编码 show variables like 'character%' set character_set_client=utf8mb4; set character_set_connection=utf8mb4; set character_set_results=utf8mb4; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be5d89d6017f28a4dec169272adb0e6c/" rel="bookmark">
			迭代器&amp;生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.解析式 1.1 列表解析式 ​ 列表解析式使用中括号[]，内部是for循环，if条件可以省略，它返回一个新的列表。
​ 列表解析式是一种语法糖，编译器会优化，不会因为简写而影响效率，反而因优化提高了效率；减少程序员工作量，减少出错；简化了代码，但可读性强；不仅减少了字节码，而且减少了栈帧。
​ 语法：[返回值 for 元素 in 可迭代对象 if 条件]
&gt;&gt;&gt; [x for x in range(5)] [0, 1, 2, 3, 4] &gt;&gt;&gt; def f(n): ... return n**2 ... &gt;&gt;&gt; [f(x) for x in range(5)] [0, 1, 4, 9, 16] 1.2 集合解析式 ​ 集合解析式使用花括号{}，内部是for循环，if条件可以省略，它返回一个新的集合。
​ 语法：{返回值 for 元素 in 可迭代对象 if 条件}
&gt;&gt;&gt; {(x,y) for x,y in enumerate(range(1,5))} {(0, 1), (3, 4), (2, 3), (1, 2)} 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be5d89d6017f28a4dec169272adb0e6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/debb268f43efab8d9392a3b3d91c500b/" rel="bookmark">
			Python3装饰器详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		装饰器 ​ 装饰器本质上是一个函数，该函数用来处理其他函数，它可以让其他函数在不需要修改代码的前提下增加额外的功能。装饰器的返回值也是一个函数对象，它经常用于有切面需求的场景，比如：插入日志、性能测试、事物处理、缓存、权限校验等应用场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量于函数功能本身无关的雷同代码继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。
​ 一个装饰器可以用来装饰多个函数，一个函数也可以被多个装饰器装饰 。
​ @符号是装饰器的语法糖，在定义函数的时候使用，避免再一次赋值操作。
无参装饰器 ​ 它是一个函数，被装饰函数作为它的形参，返回值也是一个函数，使用@functionname方式调用。装饰器是高阶函数，装饰器是对传入函数的功能的装饰（增强），不侵入任何代码。
def logger(fn): def wrapper(*args, **kwargs): print("args={}, kwargs={}".format(args,kwargs)) ret = fn(*args, **kwargs) print("{}".format(fn.__name__)) return ret return wrapper @logger # add = logger(add),返回内层函数的引用 def add(x, y): return x + y print(add(4,5)) 带参装饰器 ​ 带参装饰器是在装饰器外层又加了一层函数
def logger(*paras): def _logger(fn): def wrapper(*args, **kwargs): print("args={}, kwargs={}".format(args,kwargs)) ret = fn(*args, **kwargs) print("paras={}".format(paras)) print("{}".format(fn.__name__)) return ret return wrapper return _logger @logger(10,20,30) # add = logger(add),返回内层函数的引用 def add(x, y): return x + y print(add(4,5)) functools模块 ​ 被装饰后的函数其实已经是另外一个函数了（函数名等函数属性会发生改变）。为了不影响，Python的functools包中提供了一个叫wraps的decorator来消除这样的副作用。写一个decorator的时候，最好在实现之前加上functools的wraps或者update_wrapper，它能保留原有函数的一些内置属性，，例如：__name__、 __module__ 、__doc__ 和__dict__等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/debb268f43efab8d9392a3b3d91c500b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d97b15723c3161e2ecbd89d25e659eb/" rel="bookmark">
			怎么用python自带的idle来打开py文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么用python自带的idle来打开py文件 顺着appdata&gt;local&gt;programs&gt;python&gt;lib&gt;idlelib&gt;idle.bat
把这个文件添加到打开方式中即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4996848804c4c4bdefc0f49d34857b6c/" rel="bookmark">
			数据结构——（1）线性表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、什么是线性表
二、线性表有哪些种类
三、线性表的实现
1.用数组实现的线性表
2.用链表(双向链表)实现的线性表
一、什么是线性表 线性表：由同种数据类型的数据元素组成的有序序列。 说人话：将有一堆同样类型的数据按顺序放在一起的数据结构。
举例子：现在我有英语书（序号0）、语文书（序号1）和数学书（序号2）；现在我想把他们按语文书、数学书、英语书的顺序放成一叠，那么用序号表示就是1、2、0。在程序中可以用一个数组来表示：book[3]={1,2,0}.这里，这个数组book就是一个线性表。
线性表的作用：线性表一般用于存储有顺序关系的数据序列。最典型的例子为队列（先进先出）、栈（先进后出）。线性表支持操作： 一般而言，线性表至少支持以下三种操作：
插入元素：在线性表的指定位置插入一个元素（insert、push_back、push_front等函数）删除元素：在线性表的指定位置删除一个元素（delete、pop_back、pop_front等函数）访问元素：访问线性表中指定位置的一个元素(下表操作符[]等) 二、线性表有哪些种类 数组(array)：数组是有序的元素序列，其特点是相邻的两个元素在物理内存上也是相邻的，整个数组是一段连续的内存空间。数组使用很方便，但由于其内存空间是连续的，因此使用数组之前要预设其大小；插入和删除操作要移动大量元素，操作的平均时间复杂度较链表高。链表(lined list)：链表不同于数组，链表是一种链式的数据结构（如图所示，图为双向链表）。链表由若干个节点相连而成，每个节点内部分为数据域和链接域，数据域即该节点保存的具体数据，链接域是指向其他节点的指针。 队列(queue)：队列是一种特殊的线性表。数组和链表都应支持随机访问，而队列不支持。队列必须遵守“先进先出”的原则。举个例子：我往队列里按顺序存了3（第一个元素）、2、4、5、1，那么从队列中取出数据时，取出的顺序也只能为3、2、4、5、1,在这个例子中，不能跳过3而取出其他元素。
栈(stack)：栈跟队列一样，也是一种特殊的线性表。不同的是，队列遵守的是“先进先出”的原则，栈遵守的是“后进先出”的原则。如图所示：
三、线性表的实现 上面提到线性表有数组、链表、队列以及栈四种。事实上无论是队列还是栈都可以用数组或链表来实现，因此下面介绍怎么用数组或链表来实现线性表。
1.用数组实现的线性表 现在先列出这里实现的主要操作类型：
find：找到第一个与x相同的第一个元素位置并返回insert：在指定位置插入目标元素,时间复杂度O(n)deleteElement：删除指定位置的元素,时间复杂度O(n)operator[]：返回第K个元素的非const引用 find:在数组中一个一个对比，判断当前数组元素是否目标元素，找到了就返回这个引索，找不到就返回-1.
int find(T x){ for(rangeType i = 0; i &lt; length_; i++){ if(x == array_[i])return i; } return -1; } insert：前面说过，用数组实现的线性表的插入和删除操作是比较麻烦的，主要原因是要把目标位置之后的元素都往前挪一个位置或往后挪一个位置（插入操作示意如下）。
核心代码：
for(rangeType j = length_; j &gt; i; j++){ array_[j] = array_[j-1]; } array_[i] = element; deleteElement:跟insert差不多，不过insert是向后挪的，deleteElement是向前挪的。核心代码：
length_--; for (rangeType j = i; j &lt; length_; j++) { array_[j] = array_[j+1]; } operator[]：由于数组本身就支持下表操作，这里加个条件判断（引索是否有效）就完事了。核心代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4996848804c4c4bdefc0f49d34857b6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a4bfc00fd069695d4eedf2cb6380481/" rel="bookmark">
			怎么判断笔记本显卡性能？笔记本显卡和台式机显卡性能差距大吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 众所周知，显卡是高端电脑上最重要的部件之一，很多小伙伴在选购电脑的时候往往会关注显卡的性能，不过大家在选择显卡时，又不知道它的性能如何，而且有不少用户想要知道笔记本显卡和台式主机显卡之间的性能差距。下面配置网分享一下怎么判断笔记本显卡性能，和笔记本和台式机同型号显卡性能差距对比，希望可以给大家一些参考。
先来看怎么判断笔记本显卡性能？ 笔记本的显卡根据生产厂商的不同，大概可以分为两类，一类是英伟达公司生产的显卡，另一类是AMD公司生产的显卡，也就是我们经常说的N卡和A卡。区分这两类显卡的时候，一般N卡的首字母多数是G和F开头，而A卡多数是以H和R开头（英特尔的集成显卡多数也是以H开头），对于N卡一直独占鳌头，价格也是相对较高。
对于笔记本的显卡，一般集成在主板上，我们很难通过肉眼看到他的具体型号，那么我们可以通过directx工具查看电脑的显卡信息，比如我这台电脑的信息就是使用的是英特尔的HD Graphics 520显卡，内存是1284MB
在这个电脑自带的软件中，我们是看不到电脑的独立显卡信息，接下来我们使用第三方软件鲁大师查看我们电脑的显卡信息。
通过鲁大师我们可以直观的看到，我们的这台笔记本使用的是Nvidia GeForce 940M 4G的独立显卡，可以看到驱动的版本和驱动的发行时间等信息。
此外，以前的笔记本的电脑的显卡一般会在型号的后面有一个M，例如上面的940M、GTX 850M或者HD 8790M等都是笔记本的显卡型号。只要我们知道显卡型号了，就可以判断显卡的性能高低！即通过名称去判断显卡的性能高低：
N卡而言，第一位是第几代产品，和性能基本无关，第二位数字越大性能越强，第三位数字是5或0，例如635就比630好，当然635比640差，现在的十系显卡要看前两位数字了。但是带五和前后显卡差距不大的
A卡同理的，第一位是产品代数，第二位越大性能越好，第二位相同看第三位的，第四位都是0无所谓，同型号台式显卡比笔记本显卡还很多，例如GT630比GT630M好很多。
然后不同代数之间，一般GT630M性能和GT540M差不多，A卡也这样。
笔记本显卡和台式机显卡性能差距大吗 我们就以现在笔记本主流GTX1660Ti移动版显卡，来与台式机GTX1660Ti桌面版进行比较，第一我们来看看两者参数，初步了解一下两者之间的性能差距。
一、GTX1660Ti移动版和GTX1660Ti桌面版参数对比，如下图所示：
小结：
从GTX10系列（Pascal架构）开始，取消了显卡M型号后缀，不再区分移动版和桌面，因为它们拥有相同的“芯脏”，移动版显卡在流处理器、纹理单元、光栅单元并没有进行缩水了，所以移动版和桌面版差距并不是那么明显了。我们将GTX1660Ti移动版和桌面版两者参数进行对比之后发现，差距并不是很大，只是在核心频率略有缩水，TDP功耗降低能够理解，笔记本将TDP功耗降低的目的就是让笔记本散热模块能够“压得住”显卡。
不过笔记本的GTX1660Ti 6G移动版和台式机的GTX1660Ti 6G桌面版依然会性能差异，只是没有GTX10系列之前那么明显，我们通过3DMARK和游戏实测来帮大家感受一下两者之间的性能差距。
二、3DMARK显卡性能测试
3DMARK显卡性能测试
测试小结：
通过3DMark对两者性能进行了测试，台式机GTX1660Ti桌面版相比笔记本GTX1660Ti移动版，在Fire Strike Ultra模式中领先了10%，在Fire Strike Extreme模式下领先了9.2%，在Fire Strike模式下领先了13%。
三、游戏平均帧数测试
测试小结：
在1080P最高画质游戏实测下，台式机GTX1660Ti桌面版相比笔记本GTX1660Ti移动版提升还算是蛮明显的，根本都有十几帧到二十帧的性能差异。
结语：
总的来说，现在台式机和笔记本同型号的显卡核心相同，频率也相差无几，但是从跑分上来看，依然存在10%左右的性能差距，这不必然只体现在理论跑分上，更多的时候会体现在实际的游戏之中。现在的笔记本在空间和散热受限的情况下，移动版显卡做到这样的性能已经是相当不错了。
文章来源：http://www.peizhi.net/bjbjq/114.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8436ad4d195d3d75c289639c4852a18a/" rel="bookmark">
			开发中间带有&#43;号和悬浮按钮的底部选项卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、新建一个uniapp项目，选择模板
2、 创建好之后，用微信开发者工具打开，默认点击【发布】，悬浮框出现，但在实际项目当中，不用每次点击【发布】tab都显示悬浮框，针对上述问题，做如下优化：
第一次切换到【发布】tab时，默认不显示悬浮框，页面只显示图标，且背景为白色；再次点击【发布】时，悬浮框出现，背景变灰色；点击灰色区域，悬浮框消失来回点击【发布】，悬浮框显示与隐藏，同时页面背景色跟着变化 效果图如下：
3、修改原模板的tabbar-3.vue页面，其余保持不变
&lt;template&gt; &lt;view class="content" :class="{'active':active}" @click="onCancleActive"&gt; &lt;!-- 1 图 --&gt; &lt;image class="logo active" src="../../../static/logo.png" mode="aspectFit"&gt;&lt;/image&gt; &lt;!-- 2 悬浮按钮 --&gt; &lt;view class="tabbar-box-wrap" v-show="active"&gt; &lt;view class="tabbar-box"&gt; &lt;!-- 2.1 发图文 --&gt; &lt;view class="tabbar-box-item" @click.stop="goToPage('/pages/tabbar-3-detial/tabbar-3-release/tabbar-3-release')"&gt; &lt;image class="box-image" src="../../../static/img/release.png" mode="aspectFit"&gt;&lt;/image&gt; &lt;text class="explain"&gt;发图文&lt;/text&gt; &lt;/view&gt; &lt;!-- 2.2 发视频 --&gt; &lt;view class="tabbar-box-item" @click.stop="goToPage('/pages/tabbar-3-detial/tabbar-3-video/tabbar-3-video')"&gt; &lt;image class="box-image" src="../../../static/img/video.png" mode="aspectFit"&gt;&lt;/image&gt; &lt;text class="explain"&gt;发视频&lt;/text&gt; &lt;/view&gt; &lt;!-- 2.3 提问 --&gt; &lt;view class="tabbar-box-item" @click.stop="goToPage('/pages/tabbar-3-detial/tabbar-3-qa/tabbar-3-qa')"&gt; &lt;image class="box-image" src="../../../static/img/qa.png" mode="aspectFit"&gt;&lt;/image&gt; &lt;text class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8436ad4d195d3d75c289639c4852a18a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73d2f92678a3fa77a748ebb74a7f7549/" rel="bookmark">
			基于RK3308平台的TAS5805调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬件结构 RK3308ADUIO说明 硬件框图，分为内置code和外挂code，硬件连接方式如下图：
软件结构 基于硬件框架，软件上使用ASOC架构，软件代码有两套，在创machine的时候，二者有区别，内置code使用multicode创建，外置code使用simple_card创建；
内置code架构说明： code dai driver:
sound/soc/codecs/rk3308_codec.c sound/soc/rockchip/rockchip_vad.c cpu dai driver:
sound/soc/rockchip/rockchip_i2s_tdm.c machine:
sound/soc/rockchip/rockchip_multicodecs.c 外置code架构说明（以TI的571x系列为例）： code driver:
sound/soc/codecs/tas571x.c cpu driver:
sound/soc/rockchip/rockchip_i2s_tdm.c machine:
sound/soc/generic/simple-card.c 调试记要 TAS5805的初始化： 初始化5805需要I2S的BCLK,RLCLK稳定输出，且没有数据输出，才可以初始化5805的音效寄存器，不然后续5805的音效寄存器会复位
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9775e12c6417c5babe3e6ff851bd0d7d/" rel="bookmark">
			标题PHP use、namespace和自动加载的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 PHP一个文件要想执行另一个文件的代码，一定要先引入 （require_once）使用use的话，一定要有被use的那个空间，也就是说所有被引入的文件里面一定要有那个namespace通过use的空间，可以使用自动加载函数加载文件 // ./index.php &lt;?php spl_autoload_register(function($class_name) { $file = str_replace("\\", "/", dirname(__FILE__) . "/" . $class_name . ".php"); if(file_exists($file)) { require_once($file);# } } }); use helper\PrintClass; $obj = new PrintClass(); $obj-&gt;doPrint(); // ./helper/PrintClass.php &lt;?php namespace helper; class PrintClass { public function doPrint() { echo "开始打印"; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad1a022980e41f0e3f99e4050c12cfc8/" rel="bookmark">
			Iceberg 在基于 Flink 的流式数据入库场景中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文以流式数据入库的场景为基础，介绍引入 Iceberg 作为落地格式和嵌入 Flink sink 的收益，并分析了当前可实现的框架及要点。
应用场景
流式数据入库，是大数据和数据湖的典型应用场景。上游的流式数据，如日志，或增量修改，通过数据总线，经过必要的处理后，汇聚并存储于数据湖，供下游的应用（如报表或者商业智能分析）使用。
上述的应用场景通常有如下的痛点，需要整个流程不断的优化：
支持流式数据写入，并保证端到端的不重不丢（即 exactly-once）；
尽量减少中间环节，能支持更实时（甚至是 T+0）的读取或导出，给下游提供更实时更准确的基础数据；
支持 ACID，避免脏读等错误发生；
支持修改已落地的数据，虽然大数据和数据湖长于处理静态的或者缓慢变化的数据，即读多写少的场景，但方便的修改功能可以提升用户体验，避免用户因为极少的修改，手动更换整个数据文件，甚至是重新导出；
支持修改表结构，如增加或者变更列；而且变更不要引起数据的重新组织。
引入 Iceberg 作为 Flink sink
为了解决上述痛点，我们引入了 Iceberg 作为数据落地的格式。Iceberg 支持 ACID 事务、修改和删除、独立于计算引擎、支持表结构和分区方式动态变更等特性，很好的满足我们的需求。
同时，为了支持流式数据的写入，我们引入 Flink 作为流式处理框架，并将 Iceberg 作为 Flink sink。 下文主要介绍 Flink Iceberg sink 的实现框架和要点。但在这之前，需要先介绍一些实现中用到的 Flink 基本概念。
Flink 基本概念
从 Flink 的角度如何理解"流"和"批"
Flink 使用 DataFrame API 来统一的处理流和批数据。
Stream, Transformation 和 Operator
一个 Flink 程序由 stream 和 transformation 组成：
Stream: Transformation 之间的中间结果数据；
Transformation：对（一个或多个）输入 stream 进行操作，输出（一个或多个）结果 stream。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad1a022980e41f0e3f99e4050c12cfc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7e94712675ec2aa9f431d33114be486/" rel="bookmark">
			StringBuffer、StringBuilder 判断是否为空
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法如下：
if(stringBuilder.length()&gt;0 &amp;&amp; !"null".equals(stringBuilder.toString()) &amp;&amp;!"".equals(stringBuilder.toString())) { //stringBuilder不为空，StringBuffer同理 ｝ 注意：“StringBuffer和StringBuilder”在使用append()方法时，如果append(null)，则它们的“底层源代码”会自动把null转换成字符串的"null"，
//例子 StringBuilder sb = new StringBuilder(); sb.append(null); System.out.println(sb.length()); //长度为4 System.out.println(sb.toString()); //字符串为null 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c9f2e422fc79ad9ee5aa89d889e84b9/" rel="bookmark">
			CSS实现左右两边不同时滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css布局，左边滚动时，右边不随着滚动，右边滚动时，左边不随着滚动 例子截图：
代码：
&lt;body&gt; &lt;div class="parent"&gt; &lt;div class="leftChild"&gt;&lt;/div&gt; &lt;div class="rightChild"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; body {width： 100%， height： 100%} .parent {overflow: hidden; position:fixed; top:0; bottom:0; left:0; right:0} .leftChild {float:left; overflow:auto; width:40%;height: 100%} .leftChild {float:left; overflow:auto; width:60%; height: 100%} 后续还有更好的解决方案，会继续更新
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df73c07e52b446460031e1afb612236/" rel="bookmark">
			十次方项目开发系列【7】：SpringDataMongoDB通过查询方法名进行查询定义方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springDataMongoDB通过查询方法名进行查询定义方式 一 项目目录结构二 实现通过查询方法名进行查询2.1 通过文章Id查询评论2.1.1 在CommentController中添加方法2.1.2 在持久层CommentRepository添加方法2.1.3 在CommentService添加方法2.1.4 数据库展示以及功能效果 2.2 扩展2.2.1 根据发布时间和点赞数查询2.2.2 根据用户ID查询，并且根据发布时间倒序排序Desc 结束 一 项目目录结构 搭建工程：十次方项目开发系列【1】：项目介绍和工程搭建 二 实现通过查询方法名进行查询 2.1 通过文章Id查询评论 2.1.1 在CommentController中添加方法 // GET /comment/article/{articleId} 根据文章ID查询文章 @RequestMapping(value = "/article/{articleId}",method = RequestMethod.GET) public Result findByArticleId(@PathVariable String articleId){ List&lt;Comment&gt; list = commentService.findByArticleId(articleId); //返回多个值用list return new Result(true,StatusCode.OK,"根据文章id查询评论成功",list); } 2.1.2 在持久层CommentRepository添加方法 此处findby** 是通过查询方法名进行查询定义方式重点
//根据文章id查询评论 List&lt;Comment&gt; findByArticleid(String articleId); 2.1.3 在CommentService添加方法 public List&lt;Comment&gt; findByArticleId(String articleId) { //调用持久层根据文章Id查询即可 List&lt;Comment&gt; list = commentRepository.findByArticleid(articleId);//返回多个数据用list return list; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6df73c07e52b446460031e1afb612236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dd30088c0b499993124887ebe5b598f/" rel="bookmark">
			长按列表Item将内容复制到黏贴板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 adapter.setOnItemLongClickListener(new OnItemLongClickListener() { @Override public boolean onItemLongClick(@NonNull BaseQuickAdapter adapter, @NonNull View view, int position) { //获取剪贴板管理器 ClipboardManager mClipboardManager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE); //创建能够存入剪贴板的ClipData对象 ClipData mClipData = ClipData.newPlainText("ad", data.get(position).toString()); //将ClipData数据复制到剪贴板： mClipboardManager.setPrimaryClip(mClipData); Toast.makeText(MainActivity.this, "数据已经复制到黏贴板", Toast.LENGTH_SHORT).show(); return true; } }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c22c2f6b5ab8253b1ff7db458338c220/" rel="bookmark">
			Servlet的两种配置方式：web.xml和@WebServlet注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Servlet配置：WEB_INF/web.xml和@WebServlet注解 1. 文件配置：WEB_INF/web.xml2. 注解配置：@WebServlet3. 两者同时使用注意事项 Servlet2.5 规范之前，Java Web应用的绝大部分组件都通过 web.xml 文件来配置管理。 Servlet3.0 规范可通过 Annotation 来配置管理Web组件，极大简化了原有的配置信息。 在Servlet3.0 以后，我们可以不需要在 web.xml 里面配置 servlet，只需要加上 @WebServlet 注解就可以修改该 Servlet 的属性了。
1. 文件配置：WEB_INF/web.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;!--servlet与servlet-mapping标签需同时使用--&gt; &lt;!--创建servlet标签--&gt; &lt;servlet&gt; &lt;!--给指定的servlet类起一个名字--&gt; &lt;servlet-name&gt;demo01&lt;/servlet-name&gt; &lt;!--servlet类的全限定路径--&gt; &lt;servlet-class&gt;com.demo.servlet.DemoServlet&lt;/servlet-class&gt; &lt;!--servlet初始化加载优先级(0~10)--&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--创建servlet映射标签--&gt; &lt;servlet-mapping&gt; &lt;!--映射到哪个servlet，与上面一致--&gt; &lt;servlet-name&gt;demo01&lt;/servlet-name&gt; &lt;!--客户端访问路径 localhost:8080/项目名称/demo--&gt; &lt;url-pattern&gt;/demo&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--全局初始化参数:整个web应用--&gt; &lt;context-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;root&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;1234&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--默认显示页面，如有404则会继续查找下一个welcome-file标签--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;demo.html&lt;/welcome-file&gt; &lt;welcome-file&gt;demo.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;demo.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!--当页面未找到报404时显示 location 标签指定的页面--&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c22c2f6b5ab8253b1ff7db458338c220/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faaf223e1caf09f1c0ac2fad2e2d54f2/" rel="bookmark">
			VMware虚拟机安装manjaro-kde-19.0.2（内含调教：换源、美化、输入法、微信、TIM）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拎包入住：VMware虚拟机安装manjaro-kde-19.0.2（内含调教：换源、输入法、微信、TIM） 一、下载VMware15.5并二、官方下载manjaro-kde-19.0.2（同样适用于其他KDE系统版本）三、打开虚拟机安装manjaro四、换源（加快下载速度）五、配置中文输入法六、安装各类软件七、美化 本次环境： Windows 10
VMware15.5
manjaro-kde-19.0.2（同样适用于其他KDE系统版本）
一、下载VMware15.5并 为节省篇幅自行百度
二、官方下载manjaro-kde-19.0.2（同样适用于其他KDE系统版本） https://manjaro.org/download/#kde-plasma
【Get KDE Plasma 19.0.2 】为下载按钮
如果下载系统文件速度太慢了，可以在清华大学镜像站内里找镜像
Index of/osdn/storage/g/m/ma/manjaro/目录下可寻
三、打开虚拟机安装manjaro ①打开VMware再选择：文件——新建虚拟机——典型（推荐）——下一步
②选择：稍后安装操作系统——下一步
③选择：Linux——版本：其他Linux 5.x或更高版本内核64位——下一步
（注：此处版本若有更好选择请指教）
④自拟虚拟机名称，并更改位置为非C盘即可 ——完成后下一步
⑤根据需求设置最大磁盘大小（设置50G以上），选择将虚拟磁盘存储为单个文件——完成后下一步。
⑥再点击完成虚拟机创建完毕。
⑦配置manjaro：
1.点击虚拟机设置——内存2G以上——处理器内核数量2；
2.其中CD/DVD——使用ISO映像文件——浏览选择你下载的majaro镜像文件
⑧确定即虚拟机设置完成
接下来manjaro安装：
⑨开启此虚拟机——选择Boot：manjaro——Enter回车
⑩左上角将语言改为【Chinese（China）】——启动安装程序
⑪欢迎界面：默认简体中文——点击下一步
⑫位置界面：默认上海——点击下一步
⑬键盘界面：默认——点击下一步
⑭分区界面：手动分区——点击下一步
⑮点击：新建分区表———OK
⑯点击创建
⑰创建"/boot “引导分区大小1G ，挂载点“/boot”。(分区大小根据总磁盘大小可自行调整)
⑱创建根目录”/“分区大小20G，挂载点“/”。(分区大小根据总磁盘大小可自行调整)
⑲创建用户分区”/home"大小22G，挂载点“/home”。(分区大小根据总磁盘大小可自行调整)
⑳创建扩展分区大小8G，用于创建交换分区。
㉑自定义即可
㉒Office Suite页面：根据喜好自选办公软件即可——点击下一步
㉓摘要页面：点击安装——现在安装
㉔等待数分钟后重启，安装完成。
四、换源（加快下载速度） ①打开终端，输入下列命令：
#更新镜像排名，选择速度最快的即可 sudo pacman-mirrors -i -c China -m rank #更新数据源和系统 sudo pacman -Syyu ②也可更换中科大源
#安装编辑器gedit sudo pacman -S gedit sudo gedit /etc/pacman.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faaf223e1caf09f1c0ac2fad2e2d54f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/442630483593f890779ad2e13d44a37e/" rel="bookmark">
			AD altium designer 16导入step 3D模型的时候报 Cannot load 3D model from file !
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上搜这个错误都是老版本打开新版本画的图，后者3D模型丢失的原因。
我这个是在AD16版本的PCB元件库上添加自己画的3D 模型，弹框报 Cannot load 3D model from file !，各种折腾不行，后来想是不是路径中有中文的原因，直接把画的3D模型导出到全英文不带空格的路径文件夹下面，再导入，就没问题了。
外国写的软件我估计50%的故障都是由于中文路径导致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5813e4d2deefeccb07b63f1254eee70/" rel="bookmark">
			Android 下载网络pdf到本地 并加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 加载pdf文件目前只支持 本地pdf加载的方式 无法像IOS原生web展示pdf，所以要
1.先下载到本地，2.再去加载本地pdf文件
加载方式有多种，本次列取了pdf-viewer的方式，其他方式还有微信X5内核 ，android_pdf ,SuperWeb，Moliza开源的Pdf.js等 各有利弊 下载网络pdf文件到本地 String outFilePath = DOWN_LOAD_PATH + System.currentTimeMillis() + ".pdf"; HttpOkhUtils.getInstance().download(“网络图片地址”, new Callback() { @Override public void onFailure(Call call, IOException e) { WaitDialog.dismiss(); } @Override public void onResponse(Call call, Response response) throws IOException { WaitDialog.dismiss(); //下载功能 InputStream inputStream = response.body().byteStream(); FileOutputStream outputStream = new FileOutputStream(new File(outFilePath)); byte[] by = new byte[2048]; int len = 0; while ((len = inputStream.read(by)) != -1) { outputStream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5813e4d2deefeccb07b63f1254eee70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6b6b6bf9716a674c547b9c0b6ed0248/" rel="bookmark">
			Hive_HIVE优化指南_场景七_数据倾斜问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：
1. hive.map.aggr、hive.groupby.skewindata执行过程
https://blog.csdn.net/chybin500/article/details/80988089
2.hive倾斜的最终解决方案（非常经典），结合了Spark倾斜优化的一些思想
hive数据倾斜优化 https://blog.csdn.net/jin6872115/article/details/79878391
3.还算不错，无 大表 JOIN 大表 的优化
Hive学习之路 （十九）Hive的数据倾斜
https://www.cnblogs.com/qingyunzong/p/8847597.html
==================================
Hive 优化，大纲地址 ： https://blog.csdn.net/u010003835/article/details/105334641
测试数据 场景七.数据倾斜问题 GROUP BY 场景下的数据倾斜 JOIN 场景下的数据倾斜 1) 由于空值导致的数据倾斜问题 2) 由于数据类型不一致，导致的转换问题，导致的数据倾斜 3) 业务数据本身分布不均，导致的数据倾斜 3) 下面4个小场景
i.大表与小表JOIN (Map JOIN)
ii.大表与大表JOIN, 一张表数据分布均匀，另一张表数据特定的KEY(有限几个) 分布不均
iii.大表与大表JOIN, 一张表数据分布均匀，另一张表大量的KEY 分布不均
iiii.大表与大表JOIN, 桶表，进行表拆分
================================================================
下面我们进入正题
测试数据 use data_warehouse_test; CREATE TABLE IF NOT EXISTS datacube_salary_org ( company_name STRING COMMENT '公司名称' ,dep_name STRING COMMENT '部门名称' ,user_id BIGINT COMMENT '用户id' ,user_name STRING COMMENT '用户姓名' ,salary DECIMAL(10,2) COMMENT '薪水' ,create_time DATE COMMENT '创建时间' ,update_time DATE COMMENT '修改时间' ) PARTITIONED BY( pt STRING COMMENT '数据分区' ) ROW FORMAT DELIMITED FIELDS TERMINATED BY ',' STORED AS TEXTFILE ; CREATE TABLE IF NOT EXISTS datacube_salary_basic_aggr( company_name STRING COMMENT '公司名称' ,dep_name STRING COMMENT '部门名称' ,user_id BIGINT COMMENT '用户id' ,salary DECIMAL(10,2) COMMENT '薪水' ) STORED AS ORC ; CREATE TABLE IF NOT EXISTS datacube_salary_dep_aggr( company_name STRING COMMENT '公司名称' ,dep_name STRING COMMENT '部门名称' ,total_salary DECIMAL(10,2) COMMENT '薪水' ) STORED AS ORC ; CREATE TABLE IF NOT EXISTS datacube_salary_company_aggr( company_name STRING COMMENT '公司名称' ,total_salary DECIMAL(10,2) COMMENT '薪水' ) STORED AS ORC ; CREATE TABLE IF NOT EXISTS datacube_salary_total_aggr( total_salary DECIMAL(10,2) COMMENT '薪水' ) STORED AS ORC ; 用到的表的数据：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6b6b6bf9716a674c547b9c0b6ed0248/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73a96403d18251f158f61ee23c8f318d/" rel="bookmark">
			Spring AOP配置 之 @Aspect
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Aspect 一、AOP概念(百度)二、AOP基本术语三、Advice类型四、Sping @Aspect开发步骤五、执行顺序六、试例代码 一、AOP概念(百度) AOP(Aspect Oriented Programming)：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。
AOP是Spring框架面向切面的编程思想，AOP采用一种称为“横切”的技术，将涉及多业务流程的通用功能抽取并单独封装，形成独立的切面，在合适的时机将这些切面横向切入到业务流程指定的位置中。
二、AOP基本术语 Aspect(切面)：切面泛指交叉业务逻辑。类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice，如事务处理、日志记录就可以理解为切面。切面实际就是对主业务逻辑的一种增强。Joint Point(连接点)：程序执行的某个特定位置,如类开始初始化前，类初始化后，类某个方法调用前,调用后,方法抛出异常之后。一个类或一段代码拥有一些具有边界性质的特定点，这些代码中的特定点就成为连接点。（指切面可以织入的位置。） Spring仅支持方法的连接点，即只能在方法调用之前，调用之后，方法抛出异常，以及方法调用前后这些连接点织入增强；PointCut(切点)：指切面具体织入的位置。是一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。Advice(增强)：Advice是切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。通知定义了Advice代码切入到目标代码的时间点，是目标方法执行之前执行，还是之后执行等。Advice类型不同，切入时间不同。Target(目标对象)：织入 Advice 的目标对象.。Weaving(织入)：把切面应用到目标对象来创建新的代理对象的过程。 三、Advice类型 @Before：标识一个前置增强方法。@After：final增强，不管是抛出异常或者正常退出都会执行。@AfterReturning：后置增强，方法正常退出时执行。@AfterThrowing：异常抛出增强，方法执行抛出异常后执行。@Around：环绕增强，能控制切点执行前，执行后，，用这个注解后，程序抛异常，会影响@AfterThrowing这个注解。 四、Sping @Aspect开发步骤 添加依赖 &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjrt --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt; 配置自动扫描包 &lt;context:component-scan base-package="com.test.spring.aop"&gt; &lt;/context:component-scan&gt; 编写切面
3.1 定义一个类，该类添加了@Component、@Aspect注解
3.2 定义切点(切点定义方式可参考《Spring AOP配置 之 @PointCut注解》)
3.3 配置增强，给方法添加@Before、@After、@AfterReturning、@AfterThrowing、@Around等增强配置。书写增强方法的具体业务逻辑，通过JoinPoint对象参数，可以获取到方法的签名和方法的参数等信息。 五、执行顺序 @Around环绕通知@Before通知执行@Before通知执行结束@Around环绕通知执行结束@After后置通知执行了@AfterReturning第一个后置返回通知后执行 六、试例代码 import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import org.aspectj.lang.JoinPoint; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73a96403d18251f158f61ee23c8f318d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48c09eeae2aa230e113c08c19da01a53/" rel="bookmark">
			使用root用户配置的hadoop集群启动报错：ERROR: Attempting to operate on hdfs namenode as root
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天在虚拟机上自己搭建了一个集群，然后因为工作就一直也没管。今天启动的时候，发现报错了。还以为是自己在搭建的时候有问题呢。然后第二次搭建完成之后，启动还是报错。就上网查。
大致报错信息如下：
[root@master hadoop]# start-dfs.sh Starting namenodes on [master] ERROR: Attempting to operate on hdfs namenode as root ERROR: but there is no HDFS_NAMENODE_USER defined. Aborting operation. Starting datanodes ERROR: Attempting to operate on hdfs datanode as root ERROR: but there is no HDFS_DATANODE_USER defined. Aborting operation. Starting secondary namenodes [master] ERROR: Attempting to operate on hdfs secondarynamenode as root ERROR: but there is no HDFS_SECONDARYNAMENODE_USER defined. Aborting operation. [root@master hadoop]# start-yarn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48c09eeae2aa230e113c08c19da01a53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc27ffaf7da10c11c1c037f28827039/" rel="bookmark">
			如何查找论文的源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍两个用于查询论文源代码的网站并介绍一些常用的获取code的办法
1、https://paperswithcode.com/
操作如下图所示，左上角输入名字，便会出来结果，然后点击code部分即可
2、https://www.profillic.com/paper/arxiv:1701.04099
这个网站也是类似的操作
3、如果是经典文章，那code往往网上一搜一大片，如果是比较新的文章，可以采用如下三种方法：
（1）在google搜索该论文的名称或者第一作者的姓名，找到该作者的个人学术主页。在他的主页上看看他是否公开了论文的代码。
（2） 在google搜索该论文中算法的名字+code或者是某种语言，如python等。这是因为阅读这篇论文的科研人员不少，有的人读完会写代码并公布出来。
（3）邮件联系第一作者。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a8811d443f6030c0446a7ab8dbb6a8d/" rel="bookmark">
			导致Http的status状态为canceled的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近接手新项目，发现项目中的axios没有封装，就动手封装了一下，封装过程详见我的另一篇文章-&gt;vue中封装axios请求.；封装后开始测试，遇到的问题是status一直是canceled，调试了好长时间，发现是这里的问题：
//这里以postjson请求的参数为例 const options = { url: getFullUrl(requestConfig.url), //获取完整的路径 method: "post", //提交方式 data: requestConfig.params, //提交数据（因为这里传的就是json数据，所以没有转换） headers: requestConfig.headers || { "Content-Type": "application/json; charset=utf-8" //设置请求头 }, //问题所在地，错误的以为单位是s，所以设置为10，实际上是10ms，请求根本发不通 timeout: requestConfig.timeout || 10 //修改为即可 timeout: requestConfig.timeout || 15000 }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8295b717fd63e311ac05c8fd4464aaee/" rel="bookmark">
			再次尝试适配Android透明状态栏、导航栏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		终于翻译完了 由于我并不是很懂英语 并且里面的部分名词不知道如何翻译 就采用了机翻或者直接删掉、改为我理解中的意思 所以本文章内容可能和原文有出入
如有侵权请联系！
如果您观看了我 Becoming a Master Window Fitter 的演讲，你就会知道处理窗口插入视图（以下统一使用机翻：插图）可能很复杂。 最近，我一直在改善一些应用程序中的系统栏处理功能，使它们可以隐藏状态栏和导航栏。 我想出了一些方法，可以更轻松地处理插图。
在导航栏后面绘图 对于本文的其余部分，我们将使用 BottomNavigationView 演示一个简单的示例，该示例位于屏幕底部。 它非常简单地实现为：
&lt;BottomNavigationView android:layout_height="wrap_content" android:layout_width="match_parent" /&gt; 默认情况下，您活动的内容将布置在系统提供的UI（导航栏等）中，因此我们的视图与导航栏齐平。 我们的设计师已决定，他们希望该应用开始在导航栏后面绘制。 为此，我们将使用适当的标记调用 setSystemUiVisibility()：
rootView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION 注：以上代码使用的是Kotlin 想看Java版的可以看看我之前转载的文章：关于Android 10的手势导航条适配问题
最后，我们将更新主题，以使我们拥有一个带有深色图标的半透明导航栏：
&lt;style name="AppTheme" parent="Theme.MaterialComponents.Light"&gt; &lt;!-- Set the navigation bar to 50% translucent white --&gt; &lt;item name="android:navigationBarColor"&gt;#80FFFFFF&lt;/item&gt; &lt;!-- Since the nav bar is white, we will use dark icons --&gt; &lt;item name="android:windowLightNavigationBar"&gt;true&lt;/item&gt; &lt;/style&gt; 视图显示在导航栏的后面 如您所见，这只是我们要做的开始。 由于活动现在位于导航栏的后面，因此我们的 BottomNavigationView 也是如此。 这意味着用户实际上无法单击任何导航项。 要解决此问题，我们需要处理系统提供的所有 WindowInsets ，并使用这些值将适当的填充应用于视图。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8295b717fd63e311ac05c8fd4464aaee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7291068902a7967b8f9d765af1e0b5c3/" rel="bookmark">
			手把手教你 Tableau 绘制范围线图（二十三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手把手教你 Tableau 绘制范围线图 范围-线图将整体数据的部分统计特征（均值、最大值、最小值等）展示在图形中，既可以说明群体特征，还可以展示个体信息，更可以比较个体与整体的相对关系。
绘制人工服务接听量范围线图 数据展示 操作步骤 1、拖拽度量「人工服务接听量」和维度「日期」到行、列功能区；
2、修改列功能功能区「日期」为 “天”；
3、拖拽维度「工号」到筛选器，并显示筛选器，选择一个工号「20010925」；
4、创建计算字段「接听量平均值」（FIXED 函数参考下图）；
5、创建计算字段「接听量最大值」（FIXED 函数参考下图）；
6、创建计算字段「接听量最小值」（FIXED 函数参考下图）；
7、拖拽接听量平均值、接听量最大值和接听量最小值到标记中的详细信息，否则后面添加参考线（参考区间）时无法选择这些参数；
8、添加平均值参考线：线 – 每单元格 – 选择接听量平均值 – 标签无；
8、添加最大、最小值参考区间：区间 – 每单元格 – 开始（最大值、标签无）-- 结束（最小值、标签无）-- 选择虚线。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32079257252203353d1302667817e7a0/" rel="bookmark">
			爬取基于ajax跳转的网页内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬取美团的用户评价 1.分析网页(1)对比切换网页时的URL(2)ajax与抓包技术介绍 2.利用抓包技术抓取网页(1)审查代码(2)打开jupyter notebook(3)将评论的json文件解析出来(4)复制内容链接(5)请求网页 3.提取json文件中的信息(1)理解html中层级关系(2)开始提取信息(3) 提取所有用户的评论(4) 再提取所有用户的用户id和头像链接 4.将提取到的信息保存为csv文件5.将所有页面的内容提取并保存(1)分析ajax页面链接(2)提取所有内容并保存 1.分析网页 (1)对比切换网页时的URL 第一页如下图：
切换到第2页时如下图：
对两页的链接进行对比：
第1页链接为：
https://www.meituan.com/meishi/2469129/
第2页链接为：
https://www.meituan.com/meishi/2469129/
对比后发现两个链接一样，故该网站是基于ajax跳转的， 要使用抓包的方式来爬取数据
(2)ajax与抓包技术介绍 每一个网页都有一个html框架，网页上的内容将在这个框架中呈现，而基于ajax跳转的网页（即切换网页时，链接无变化的网页），就是将ajax加载出来的内容放到html框架中去。而抓包技术就是在ajax将加载出来的内容放到html框架的这个过程中，利用python语言将数据拦截并获取下来
2.利用抓包技术抓取网页 (1)审查代码 找到包含有评论的那个文件，如下图：
在选中的文件中，发现文件中的文字和网页上显示的文字相对应，即这个文件就是我们要找的文件包
(2)打开jupyter notebook 新建一个文件夹，并在其中打开Jupyter notebook
将张一步找到的那个链接在新标签页打开，便可看到该网页上的所有内容，如下图：
打开后，如下图所示：
通过红圈中的内容和网页的对比，可以确定就是我们所要的评论内容 (3)将评论的json文件解析出来 将json文件的内容复制到一个json在线解析之中解析出具有规范化格式的文件
json在线解析网址：
https://www.sojson.com/simple_json.html
要复制的内容为：
利用json在线解析解析出来的内容为：
(4)复制内容链接 方法一：
得到链接为：
https://www.meituan.com/meishi/api/poi/getMerchantComment?uuid=c1b7c81aeaf04a259833.1586665372.1.0.0&amp;platform=1&amp;partner=126&amp;originUrl=https%3A%2F%2Fwww.meituan.com%2Fmeishi%2F2469129%2F&amp;riskLevel=1&amp;optimusCode=10&amp;id=2469129&amp;userId=&amp;offset=0&amp;pageSize=10&amp;sortType=1 Headers下方的Reponse URL即是我们要复制的链接
方法二：
右击，选择copy、再点击copy link address也可得到我们要的链接
链接为：https://www.meituan.com/meishi/api/poi/getMerchantComment?uuid=c1b7c81aeaf04a259833.1586665372.1.0.0&amp;platform=1&amp;partner=126&amp;originUrl=https%3A%2F%2Fwww.meituan.com%2Fmeishi%2F2469129%2F&amp;riskLevel=1&amp;optimusCode=10&amp;id=2469129&amp;userId=&amp;offset=0&amp;pageSize=10&amp;sortType=1 (5)请求网页 步骤和基于html跳转的网页一样，只是此处的链接是那个文件包的链接，也就是上一步所复制的链接，代码及运行结果如下： #导入requests 库 import requests #复制链接 ajax_url="https://www.meituan.com/meishi/api/poi/getMerchantComment?uuid=c1b7c81aeaf04a259833.1586665372.1.0.0&amp;platform=1&amp;partner=126&amp;originUrl=https%3A%2F%2Fwww.meituan.com%2Fmeishi%2F2469129%2F&amp;riskLevel=1&amp;optimusCode=10&amp;id=2469129&amp;userId=&amp;offset=0&amp;pageSize=10&amp;sortType=1" #构造字典 headers_meituan={ "User-Agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32079257252203353d1302667817e7a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c02c8d7048942e234afdcbe9c638f3ff/" rel="bookmark">
			Golang cookie使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cookie设置和获取使用方法
func HttpCookies() { http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) { cName := http.Cookie{ Name: "name",	//	cookie的名称 Value: "golang",	//	cookie名称对应的值 Path: "/",	// Domain: "",	//	cookie的作用域 Expires: time.Time{},	//	cookie的过期时间 RawExpires: "", MaxAge: 0,	//	设置过期时间，对应浏览器cookie的MaxAge属性 Secure: false,	//	设置Secure属性(说明：Cookie的Secure属性，意味着保持Cookie通信只限于加密传输，指示浏览器仅仅在通过安全/加密连接才能使用该Cookie。如果一个Web服务器从一个非安全连接里设置了一个带有secure属性的Cookie，当Cookie被发送到客户端时，它仍然能通过中间人攻击来拦截) HttpOnly: true,	//	设置httpOnly属性（说明：Cookie的HttpOnly属性，指示浏览器不要在除HTTP（和 HTTPS)请求之外暴露Cookie。一个有HttpOnly属性的Cookie，不能通过非HTTP方式来访问，例如通过调用JavaScript(例如，引用 document.cookie），因此，不可能通过跨域脚本（一种非常普通的攻击技术）来偷走这种Cookie。尤其是Facebook 和 Google 正在广泛地使用HttpOnly属性。） SameSite: 0, Raw: "", Unparsed: nil, } cId := http.Cookie{ Name: "id", Value: "21", Path: "/", Domain: "", Expires: time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c02c8d7048942e234afdcbe9c638f3ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb799eaf19edad6580ad97c823651255/" rel="bookmark">
			leetcode--64最小路径和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。
示例:
输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/minimum-path-sum
方法：
动态规划。有两点必须要搞清楚，初值和状态转移方程。
我创建一个长度为n的数组memo，初值设置为第一行累加值，也就是memo[0] =grid[0][0]。memo[1] = memo[0] + grid[0][1],以此类推，我这样做的目的是记录到i列最小的值。因为每次1只能向下或者向右，所以我只考虑当前参考位置的左和上最小的值。考虑边界问题，单独处理。
状态转移方程很简单：
memo[j] = min(memo[j-1],memo[j]) + grid[i][j]; class Solution { public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(); if(m == 0) return 0; int n = grid[0].size(); vector&lt;int&gt; memo(n,-1); memo[0] = grid[0][0]; for(int i = 1; i &lt; n; i++) memo[i] = memo[i-1] + grid[0][i]; for(int i = 1; i &lt; m; i++){ memo[0] = memo[0] + grid[i][0]; for(int j = 1; j &lt; n; j++){ memo[j] = min(memo[j-1],memo[j]) + grid[i][j]; } } return memo[n-1]; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90c8223626930c342c71bcfcc987ceef/" rel="bookmark">
			iOS基础界面编程———常用UIView控件的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UIView的子类
UIWindow：UILabel：类比于Android中的TextView的显示功能；UIPickerView：UIProgressView：UIActivityIndication：UIImageView：UITableBar：UIToolbar：UINavigationBar：UITableViewCell：UIActionSheet：UIAlerView：UIScrollView：UISearchBar：UIWebView：UIControl： 1.UILabel类的功能是提供显示及编辑，其属性(跟Android中的属性设置对比学习，原理一样)如下： @property(nullable, nonatomic,copy) NSString *text; // default is nil @property(null_resettable, nonatomic,strong) UIFont *font; // default is nil (system font 17 plain) @property(null_resettable, nonatomic,strong) UIColor *textColor; // default is nil (text draws black) @property(nullable, nonatomic,strong) UIColor *shadowColor; // default is nil (no shadow) @property(nonatomic) CGSize shadowOffset; // default is CGSizeMake(0, -1) -- a top shadow @property(nonatomic) NSTextAlignment textAlignment; // default is NSTextAlignmentNatural (before iOS 9, the default was NSTextAlignmentLeft) @property(nonatomic) NSLineBreakMode lineBreakMode; // default is NSLineBreakByTruncatingTail.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90c8223626930c342c71bcfcc987ceef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f7d8522140de20876ef8f1d35954304/" rel="bookmark">
			C语言自学通俗讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C/C++知识自我总结 什么是程序？
通俗点讲就是运用编程语言使电脑完成一系列操作的指令的集合。
什么是C语言？
C语言是一种高级编程语言之一，同为高级编程语言还有C++、VB、Java、Python……除了高级编程语言之外还有较为底层的机器语言。
什么是机器语言？
可以理解为计算机看的懂的语言，它也是真正给计算机下达指令的编程语言，它与高级编程语言的的区别是我们看不懂(๑• . •๑)。但是不要心理不平衡，因为计算机也看不懂我们的高级编程语言。但是高级编程语言和机器语言也是有必然联系的。高级编程语言是通过编译器转换成机器语言。然后真正给计算机下达指令。
那么有些人想问了，为什么不让我们直接用机器语言去进行编程呢？这是因为机器语言相对人来说是十分枯燥且冗长的，你可以理解为一大串的二进制数。而高级编程语言就是将这一串串人看不懂的二进制数，与我们可以看得懂的指令绑定起来。
编译是啥？
从上文我们可以知道，要想使高级编程语言真正作用于计算机，必须通过编译器转化成机器语言。那么我们就可以知道，编译器是一个可以将人看得懂的代码转换成计算机看得懂的指令的程序。
总结 从以上内容可以得知编译器是高级编程语言与机器语言的桥梁。有编译器对高级编程语言进行编译，转换成机器语言。我们所写的代码才能真正的使计算机进行工作。
本文仅为个人观点，是自身对编程学习所得出的理解。若有不正确之处，请各位大佬及时指点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c38b7cf36268f618b83bfcd90cce44b4/" rel="bookmark">
			直线和直线，直线和圆，直线和矩形的交点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直线和圆的交点公式
y=kx+b
(x+c)² + (y+d)² = r²
的形式
转换成
ax+by+c=0
以（x, y）为圆心，r 为半径的形式
c++
// ax+by+c=0 // （x, y）为圆心，r 为半径 double x1_ = -(sqrt(pow(r, 2) * (1 + pow(a / b, 2)) - pow(x, 2) * pow(a / b, 2) - (2 * x * y + 2 * c * x / b) * a / b - pow(y, 2) - 2 * c * y / b - pow(c / b, 2)) + (y + c / b) * (a / b) - x) / (1 + pow(a / b, 2)); double y1_ = -(-a / b * (sqrt(pow(a / b, 2) * pow(r, 2) + pow(r, 2) - pow(x, 2) * pow(a / b, 2) - x * x * y * a / b - x * x * a * c / pow(b, 2) - pow(y, 2) - 2 * c * y / b - pow(c / b, 2)) - x) - y * pow(a / b, 2) + c / b) / (1 + pow(a / b, 2)); double x2_ = (sqrt(pow(r, 2) * (1 + pow(a / b, 2)) - pow(x, 2) * pow(a / b, 2) - (2 * x * y + 2 * c * x / b) * a / b - pow(y, 2) - 2 * c * y / b - pow(c / b, 2)) - (y + c / b) * (a / b) + x) / (1 + pow(a / b, 2)); double y2_ = -(-a / b * (-sqrt(pow(a / b, 2) * pow(r, 2) + pow(r, 2) - pow(x, 2) * pow(a / b, 2) - x * x * y * a / b - x * x * a * c / pow(b, 2) - pow(y, 2) - 2 * c * y / b - pow(c / b, 2)) - x) - y * pow(a / b, 2) + c / b) / (1 + pow(a / b, 2)); 有需要根据第一个图片里的样子转换就可以了，或者用贴出的代码（有点乱）自己更改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c38b7cf36268f618b83bfcd90cce44b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ee92faa8ab7ec295b3c7b2d6e2b631f/" rel="bookmark">
			Dart之Stream异步事件流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在此先插播一句观察者模式
观察者模式常见案例：
RxJava、LiveData、Dart中通过Stream异步事件流构建Widget的Bloc
观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。
观察者模式是一种对象行为型模式，
其主要优点如下：
降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。目标与观察者之间建立了一套触发机制。 它的主要缺点如下。
目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。 Stream 就是流的意思，表示发出的一系列的异步数据。可以简单地认为 Stream 是一个异步数据源。它是 Dart 中处理异步事件流的统一 API
集合与Stream
Dart 中，集合（Iterable或Collection）表示一系列的对象。而 Stream （也就是“流”）也表示一系列的对象，但区别在于 Stream 是异步的事件流。比如文件、套接字这种 IO 数据的非阻塞输入流（input data），或者用户界面上用户触发的动作（UI事件）。
集合可以理解为“拉”模式，比如你有一个 List ，你可以主动地通过迭代获得其中的每个元素，想要就能拿出来。而 Stream 可以理解为“推”模式，这些异步产生的事件或数据会推送给你（并不是你想要就能立刻拿到）。这种模式下，你要做的是用一个 listener （即callback）做好数据接收的准备，数据可用时就通知你。
Stream 与 Future
Stream 和 Future 是 Dart 异步处理的核心 API。Future 表示稍后获得的一个数据，所有异步的操作的返回值都用 Future 来表示。但是 Future 只能表示一次异步获得的数据。而 Stream 表示多次异步获得的数据。比如界面上的按钮可能会被用户点击多次，所以按钮上的点击事件（onClick）就是一个 Stream 。简单地说，Future将返回一个值，而Stream将返回多次值。
另外一点， Stream 是流式处理，比如 IO 处理的时候，一般情况是每次只会读取一部分数据（具体取决于实现）。和一次性读取整个文件的内容相比，Stream 的好处是处理过程中内存占用较小。而 File 的readAsStringSync（异步读，返回 Future）或 readAsString（同步读，返回 String）等方法都是一次性读取整个文件的内容进来，虽然获得完整内容处理起来比较方便，但是如果文件很大的话就会导致内存占用过大的问题。
获取Stream的方式：
Stream 有3个工厂构造函数：fromFuture、fromIterable 和 periodic，分别可以通过一个 Future、Iterable或定时触发动作作为 Stream 的事件源构造 Stream
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ee92faa8ab7ec295b3c7b2d6e2b631f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aabf61bf49ef134caba77a448b2ab26/" rel="bookmark">
			爬取豆瓣TOP250
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一课《爬取豆瓣TOP250》 1.准备工作2.开始爬取网页（1）分析网页（2）用for循环表示这个分析结果（3）用page函数表示这10页的url链接 3.正式爬取网页（1）请求网页源代码，即html（2）到top250上对代码进行审查（3）请求网址以及请求方法（4）开始请求网页（5）伪装浏览器（6）代码表示 4信息的筛选（1） 安装lxml库（2）过滤（3）从网页上（豆瓣TOP250）提取信息（4）复制整个网页的xpath路径（5）获取每个电影的名字（6）接着获取电影链接（7）接着获取电影星级数（8）接着获取电影评分（9）接着获取电影评价人数 5.python综合输出的方法（1）可以输出分隔符美化输出结果（2）print横向同时输出多个值 6.爬取得到的内容的保存问题（1）常见保存格式（2）爬取电影排名（3）用正则表达式re匹配星级数中的数字（4）用专门提取数字的re正则来提取数字（5）提取所有的星级数并将其规范化（6）将爬取的到的内容保存为csv格式 7.所有代码综合 1.准备工作 （1）安装python,并安装jupyter库，便于使用jupyter notebook编辑页面
（2）安装python，可能需要配置环境变量，win10配置环境变量时，直接加一条新的路径
(3)安装好jupyter后，进入时先用命令进入jupyter库所在目录，再直接输入jupyter notebook,便可直接进入jupyter的网络编辑页面
例如：
cd #进入jupyter库所在c盘
cd 目录 #进入jupyter库所在目录
再输入jupyter notebook
结果如下：
出现此界面后便会自动跳转到jupyter的网络编辑页面，如下：
2.开始爬取网页 （1）分析网页 分析URL链接：
第一页：https://movie.douban.com/top250 或 https://movie.douban.com/top250?start=0&amp;filter=
第二页：https://movie.douban.com/top250?start=25&amp;filter=
第三页：https://movie.douban.com/top250?start=50&amp;filter=
第四页：https://movie.douban.com/top250?start=75&amp;filter=
分析结果：从此可以看出，一至四页的URL链接是有规律 的，star=的后面，每个链接之间相差数字25
此时直接看第十页：
第十页URL为：
https://movie.douban.com /top250?start=225&amp;filter= 再看第一页的链接为：
https://movie.douban.com/top250?start=0&amp;filter= 仍然符合以上分析结果
（2）用for循环表示这个分析结果 结果如下：
（3）用page函数表示这10页的url链接 将函数改为：
for page in range(0, 226, 25): url=‘https://movie.douban.com/top250?start=%s&amp;filter=’%page 将start=0改为start=%s,后面跟的%page表示将page函数中的数 值范围赋予给s,即可一次性构造出十个网页的链接
运行结果如下：
此时可随便点击一个链接进去，如点击start=75的链接进去，便进到top250 的第四页，而根据前面的分析，这个链接确实是第四页
3.正式爬取网页 （1）请求网页源代码，即html 实现这个目的，需要在python中安装request库，命令为pip install requests
以请求第一页为例：
test_url='https://movie.douban.com/top250?start=0&amp;filter=' 此处的单引号也可以写成双引号，目的都是为了把括号内的内容变为字符串
（2）到top250上对代码进行审查 右击进入检查元素,点击网络(network),再点击所有（All）
对该网页进行刷新，下方会出现网页的组成元素，例如图片等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aabf61bf49ef134caba77a448b2ab26/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/439/">«</a>
	<span class="pagination__item pagination__item--current">440/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/441/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>