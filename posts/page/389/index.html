<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15c2e2858205ec44d9ba7173d3247757/" rel="bookmark">
			Unity C# Texture图像传输到C&#43;&#43; dll的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位我最近又找到了更好的办法~
因为用原来的办法虽然可以正确传输，但由于unity中需要将texture转成byte数组，gc会占用很多时间，因此研究了一下换了一种新的办法：
Unity C# Texture发送到C++ dll的方法 升级版
此方法需要调用dx11，本人也是新手，希望大佬们发现我写的有什么不对的地方能帮我指出！
原文：
最近在写dll，用opencv处理图像，但是图像信息要从unity那边传过来，我们本来使用的方法是用byte数组传递：
void transferImage(byte* pImg, int width, int height) { image = cv::Mat(height, width, CV_8UC3, pImg).clone(); flip(p_FaceParam-&gt;input_frame, p_FaceParam-&gt;input_frame, 0); } 但是后来发现unity那边获取Texture转成byte还需要一定的时间，所以最近发现了一个更好的办法
这个方法转载自链接:
在Unity3D和OpenCV之间传递图片（Texture2D/WebCamTexture转Mat）.
C#：
using System; using System.Runtime.InteropServices; Texture2D TextureToTexture2D(Texture texture) { Texture2D texture2D = new Texture2D(texture.width, texture.height, TextureFormat.RGBA32, false); RenderTexture currentRT = RenderTexture.active; RenderTexture renderTexture = RenderTexture.GetTemporary(texture.width, texture.height, 32); Graphics.Blit(texture, renderTexture); RenderTexture.active = renderTexture; texture2D.ReadPixels(new Rect(0, 0, renderTexture.width, renderTexture.height), 0, 0); texture2D.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15c2e2858205ec44d9ba7173d3247757/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3d1aa4ec46c92a4ab59a6a567ca2e93/" rel="bookmark">
			Generative Adversarial U-Net for Domain-free Medical Image Augmentation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文下载：
http://xxx.itp.ac.cn/pdf/2101.04793.pdf
Generative Adversarial U-Net for Domain-free Medical Image Augmentation 用于无域医学图像增强的生成对抗U-Net
摘要 标注的医学图像的缺乏是医学图像计算领域的巨大挑战之一。没有足够的训练样本，深度学习模型有很大的可能性遇到过拟合的问题。常用的图像处理方法有图像旋转、裁剪、调整图片大小（resizing）等。这些通用的方法引入了更多的训练样本，可以帮助减轻过拟合问题。但是他们没有真正引入有更多信息的新图片，也可能会导致数据泄漏，因为测试集可能包含类似的样本出现在训练集中。为了解决这个挑战，我们提出用生成对抗网络生成多样的图片。在本文中，我们设计了一个新颖的生成方法，名字叫作生成对抗U-Net（generative adversarial U-Net），同时利用的生成对抗网络和U-Net。与现有方法不同，我们新设计的模型是无域的（domain-free），可泛化到各种医学图像。在8个数据集上进行了更多的实验，包括CT扫描影像、病理学影像、X射线影像等。视觉效果和定量结果都征明了提出的方法在生成大量高质量的医学图像有效性和良好的泛化能力。
Index : 生成对抗网络、U-Net、数据增强，医疗影像分析
Introduction 最常用是数据增强方法：
The most commonly used data augmentation strategy is dataset manipulation including various simple modfications of the data, such as translation, rotation,flip,crop, and scale [5],[6].
但是，像素级的修改不能引入新的图像，只能引入原始图像的变体，因此仍然可能出现过拟合问题。而合成数据增强方法则被认为是更合理的替代方法，因为它可以根据原始图像生成复杂类型的数据。
GAN在分割上的应用：
1.Xue et al. [19] used two GANs to learn the relationship between brain MRI images and a brain tumor segmentation map.
2.GAN+NAS 胸部器官分割；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3d1aa4ec46c92a4ab59a6a567ca2e93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da504623a867a70b426c5da913c739a6/" rel="bookmark">
			【stm32】史上最详细的8种IO口模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8种IO口模式 4种输入模式4种输出模式 （带上拉或者下拉）浮空输入推挽输出上拉输入复用式推挽输出下拉输入开漏输出模拟输入复用式开漏输出 1、浮空输入 浮空输入模式下，I/O端口的电平信号直接进入输入数据寄存器。MCU直接读取I/O口电平，I/O的电平状态是不确定的，完全由外部输入决定；如果在该引脚悬空（在无信号输入）的情况下，读取该端口的电平是不确定的。 一般多用于外部按键输入
2、上拉输入 IO内部接上拉电阻，此时如果IO口外部没有信号输入或者引脚悬空，IO口默认为高电平 如果I/O口输入低电平，那么引脚就为低电平，MCU读取到的就是低电平
3、下拉输入 IO内部接下拉电阻，此时如果IO口外部没有信号输入或者引脚悬空，IO口默认为低电平 如果I/O口输入高电平，那么引脚就为高电平，MCU读取到的就是高电平
4、模拟输入 5、开漏输出 输出端相当于三极管的集电极，要得到高电平状态需要上拉电阻才行，适合于做电流型的驱动，其吸收电流的能力相对强（一般20mA以内）
IO输出0接GND，IO输出1，悬空，需要外接上拉电阻，才能实现输出高电平。当输出为1时，IO口的状态由上拉电阻拉高电平
6、推挽输出 在推挽输出模式时，N-MOS管和P-MOS管都工作，如果我们控制输出为0，低电平，则P-MOS管关闭，N-MOS管导通，使输出低电平，I/O端口的电平就是低电平，若控制输出为1 高电平，则P-MOS管导通N-MOS管关闭，使输出高电平，I/O端口的电平就是高电平， 外部上拉和下拉的作用是控制在没有输出时IO口电平
此时施密特触发器是打开的，即输入可用，通过输入数据寄存器GPIOx_IDR可读取I/O的实际状态。I/O口的电平一定是输出的电平
推
挽输出输出0-接GND， IO输出1 -接VCC，读输入是未知的
推挽输出和开漏输出的区别 推挽输出开漏输出可以输出强高低电平，连接数字器件可以输出强低电平，高电平得靠外部电阻拉高。输出端相当于三极管的集电极. 需要外接上拉电阻，才能实现输出高电平 合于做电流型的驱动，其吸收电流的能力相对强(一般20ma以内)；在使用任何一种开漏模式时，都需要接上拉电阻，否则只能输出低电平推挽输出电路： 其中IN端输出高电平时下面的PNP三极管截止，而上面NPN三极管导通，输出电平VS+；当IN端输出低电平时则恰恰相反，PNP三极管导通，输出和地相连，为低电平开漏输出电路：IN端输出低电平时，三极管导通，使输出接地，IN端输出高电平时，三极管截止，所以引脚既不输出高电平，也不输出低电平，为高阻态。为正常使用时必须接上拉电阻 在STM32的应用中，除了必须用开漏模式的场合，我们都习惯使用推挽输出模式。
7、开漏复用输出 输出的高低电平的来源于其它外设，施密特触发器打开，输入可用，通过输入数据寄存器可获取I/O实际状态 除了输出信号的来源改变 其他与开漏输出功能相同
可以理解为GPIO口被用作第二功能时的配置情况（即并非作为通用IO口使用）
8、推挽复用输出 可以理解为GPIO口被用作第二功能时的配置情况（即并非作为通用IO口使用）
F4系列与F1系列区别: 本质上的区别是F4系列采用了Cortex-M4内核 ，而F1系列采用Cortex-M3内核
F1系列(M3)IO口基本结构：
F4系列(M4)IO口基本结构：
F4系列设计的更加高级与人性化，他将外部上下拉电阻转移到了输出/输入驱动器外部，使得输出模式下也可以实现内部上拉与下拉，方便了用户的使用，增加了灵活性。
引脚模式的配置方式如下： 1、作为普通GPIO输入：根据需要配置该引脚为浮空输入、带弱上拉输入或带弱下拉输入，同时不要使能该引脚对应的所有复用功能模块。
2、作为普通GPIO输出：根据需要配置该引脚为推挽输出或开漏输出，同时不要使能该引脚对应的所有复用功能模块。
3、作为普通模拟输入：配置该引脚为模拟输入模式，同时不要使能该引脚对应的所有复用功能模块。
4、作为内置外设的输入：根据需要配置该引脚为浮空输入、带弱上拉输入或带弱下拉输入，同时使能该引脚对应的某个复用功能模块。
5、作为内置外设的输出：根据需要配置该引脚为复用推挽输出或复用开漏输出，同时使能该引脚对应的所有复用功能模块。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9768b8c961f0f9f2dbfb265626b7aa0/" rel="bookmark">
			微服务论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://martinfowler.com/articles/microservices.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/714db7c07529f13875019d7a399172f3/" rel="bookmark">
			PermissionError: [WinError 5] 拒绝访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Pycharm运行时，报错：PermissionError: [WinError 5] 拒绝访问
但是使用终端（Terminal）运行就没有问题
尝试方案：三步解决python PermissionError: [WinError 5]拒绝访问的情况 ，然而并没有解决问题
最终确认是Pycharm的工作路径问题
修改 Working directory 的路径，如果没有则加上
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80c08f8df27b4038d60ee4c7033fce61/" rel="bookmark">
			寻找数组中第k大元素（C&#43;&#43; 版 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		寻找数组第k大元素和上篇选择排序算法相似，只是分割之后舍弃另一半数据。
#include &lt;cassert&gt; #include &lt;iostream&gt; using namespace std; // // 交换 数组中两个元素 // void swap(int *data, int a, int b) { int tmp = *(data + a); *(data + a) = *(data + b); *(data + b) = tmp; } // // 对数组区间进行分割，返回支点位置 // int partition(int *data, int begin, int end) { // 选择区间的第一个点作为 支点，暂存在变量pivot中 int pivot = *(data + begin); // 接下来，扫描区间 从支点之后第一个元素到最后一个元素 int i = begin + 1; int j = end; while (true) { // 从左向右扫描，如果元素值小于支点就向后移动 while (i &lt;= j &amp;&amp; *(data+i) &lt; pivot) i++;	// 注意：i &lt;= j 而不是 i &lt; j， 否则扫描区间不完整 // 从右向左扫描，如果元素值大于支点就向后移动 while (i &lt;= j &amp;&amp; *(data+j) &gt;= pivot) j--;	// 注意：i &lt;= j 而不是 i &lt; j， 否则扫描区间不完整 if (i &gt; j) { // 此时，扫描应该结束，i, j 位置是 j + 1 == i， j 在 i 前 break; } else {	// 把 从左向右 找到的 大于支点的元素 和 // 从右向左 找到的 小于支点的元素 交换 swap(data, i, j); } } // 扫描结束后, // j 指向了 &lt; pivot 区间最后一个元素 （区间元素个数是0时， 也成立）， // i 指向了 &gt;= pivot 区间第一个元素 （区间元素个数是0时， 也成立）， // 因支点是取的是区间的第一个元素（位于 &lt; pivot 区间一侧， 若支点取最后元素， 应取i作为分割点）， // 所以应该 把j 位置的值与pivot交换，j 也就是pivot点 swap(data, begin, j); return j; } // // 找第 nth 小元素 （nth 从 0 开始） // int _find_nth_min(int *data, int begin, int end, int nth) { int p = partition(data, begin, end); if (p == nth) { return data[p]; } else if (p &lt; nth) { return _find_nth_min(data, p + 1, end, nth); } else { // p &gt;= nth return _find_nth_min(data, begin, p - 1, nth); } } // // 找第 nth 小元素 wrapper 函数（nth 从 0 开始） // int find_nth_min(int *data, int len, int nth) { assert(0 &lt;= nth &amp;&amp; nth &lt;= len - 1);	// 确认范围正确 return _find_nth_min(data, 0, len - 1, nth); } // // 找第 nth 大元素 （nth 从 0 开始） // int find_nth_max(int *data, int len, int nth) { return find_nth_min(data, len, len - 1 - nth); } void print_array(int *data, int len) { for (int i = 0; i &lt; len - 1; i++) { cout &lt;&lt; data[i] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80c08f8df27b4038d60ee4c7033fce61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be56f9d0ee1e32806b63962b44fc87b2/" rel="bookmark">
			C&#43;&#43;实现跨平台串口通信代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++实现跨平台串口通信代码 串口通信在设备通信使用的还比较多，自己在几个项目都使用过，已经很稳定(哈哈，自吹一下)。
头文件serialport.h
//定义串口波特率 #define SBR_0	0 #define SBR_50	50 #define SBR_75	75 #define SBR_110	110 #define SBR_134	134 #define SBR_150	150 #define SBR_200	200 #define SBR_300	300 #define SBR_600	600 #define SBR_1200	1200 #define SBR_1800	1800 #define SBR_2400	2400 #define SBR_4800	4800 #define SBR_9600	9600 #define SBR_19200	19200 #define SBR_38400	38400 #define SBR_OTHER 0010000 #define SBR_57600 57600 #define SBR_115200 115200 #define SBR_230400 230400 #define SBR_460800 460800 #define SBR_500000 500000 #define SBR_576000 576000 #define SBR_921600 921600 #define SBR_1000000 1000000 #define SBR_1152000 1152000 #define SBR_1500000 1500000 #define SBR_2000000 2000000 #define SBR_2500000 2500000 #define SBR_3000000 3000000 #define SBR_3500000 3500000 #define SBR_4000000 4000000 #define SEV_RXCHAR 0x0001 // Any Character received #define SEV_RXFLAG 0x0002 // Received certain character #define SEV_TXEMPTY 0x0004 // Transmitt Queue Empty #define SEV_CTS 0x0008 // CTS changed state #define SEV_DSR 0x0010 // DSR changed state #define SEV_RLSD 0x0020 // RLSD changed state #define SEV_BREAK 0x0040 // BREAK received #define SEV_ERR 0x0080 // Line status error occurred #define SEV_RING 0x0100 // Ring signal detected #define SEV_PERR 0x0200 // Printer error occured #define SEV_RX80FULL 0x0400 // Receive buffer is 80 percent full #define SEV_EVENT1 0x0800 // Provider specific event 1 #define SEV_EVENT2 0x1000 // Provider specific event 2 typedef struct SerialPortParam_Stru { char m_PortName[16]; //端口名 SInt32 m_BaudRate; //波特率 SInt32 m_DataBit; //数据位的个数,默认值为8个数据位 char m_Parity; //奇偶校验 SInt32 m_StopBit; //停止位 UInt64 m_CommEvents; //通信时间 SerialPortParam_Stru() { memset(m_PortName, 0, sizeof(m_PortName)); m_BaudRate = 9600; m_DataBit = 8; m_Parity = 'N'; m_StopBit = 1; m_CommEvents = SEV_RXCHAR; } SerialPortParam_Stru(const SerialPortParam_Stru &amp;other) { memcpy(m_PortName, other.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be56f9d0ee1e32806b63962b44fc87b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e6c5dc20ca1deb99e499e870b47cd78/" rel="bookmark">
			Modbus协议CRC校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Modbus协议CRC校验 最近在开发Modbus协议网关，使用到了CRC校验，做了一点记录，希望对有需要的人有点帮助。
// CRC16高位码表 static const UInt8 CRC16HiTable[] = { 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40 }; // CRC16低位码表 static const UInt8 CRC16LoTable[] = { 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40 }; /** * CRC16_ModbusBlockByTable - 采用查表方式计算CRC16码 * @param Buf 校验串 * @param Length 检验字符长度 * @return 返回校验码 * * **/ UInt16 CRC16_ModbusBlockByTable(UInt8 *Buf, SInt32 Length) { UInt32 index = 0; UInt8 CRCHi = 0xFF; UInt8 CRCLo = 0xFF; UInt8 *pBufIn = Buf; while (Length--) { index = CRCHi ^ (*pBufIn); CRCHi = CRCLo ^ CRC16HiTable[index]; CRCLo = CRC16LoTable[index]; pBufIn++; } return (UInt16)((((UInt16)CRCHi) &lt;&lt; 8) | ((UInt16)CRCLo)); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28817450f47b1634d703ee0b1ce88be2/" rel="bookmark">
			MyBatis实现新增返回自增主键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加记录后获取主键ID，这是一个很常见的需求，特别是在一次前端调用中需要插入多个表的场景。
除了添加单条记录时获取主键值，有时候可能需要获取批量添加记录时各记录的主键值，MyBatis从3.3.1版本开始支持批量添加记录并返回各记录主键字段值。
mybatis提供了不少操作sql语句的标签，其中包括了新增的标签，其返回与主键相关属性也是该标签提供的，与返回主键相关的属性如下：
属性描述keyProperty(仅对insert和update有用)此属性的作用是将插入或更新操作时的返回值赋值给PO类的某个属性，通常会设置为主键对应的属性。 如果需要设置联主键，可以在多个值之间用逗号隔开keyColumn(仅对insert和update有用)此属性用于设置第几列是主键，当主键列不是表中的第一列时需要设置。在需要主键联合时，值可以用逗号隔开useGeneratedKeys(仅对insert叶和update有用)此属性会使MyBatis使用JDBC的getGeneratedKeys()方法来获取由数据库内部生产的主键，如MySQL相SQLServer等自动递增的字段，其默认值为false 一、新增之后返回自增的主键
方式一：
&lt;insert id="addUser" parameterType="com.zm.pojo.User" useGeneratedKeys="true" keyProperty="id"&gt; insert into user (name,pwd) values (#{name },#{pwd}); &lt;/insert&gt; 测试：
方式二：
&lt;insert id="insertCacheId" parameterType="com.zm.pojo.User"&gt; insert into user(name,pwd) values(#{name },#{pwd}) &lt;!-- 指定结果类型resultType，keyProperty是属性，自动返回到属性id中，order是次序，after是指获取id是在于插入后 --&gt; &lt;selectKey resultType="int" keyProperty="id" order="AFTER"&gt; select @@identity &lt;/selectKey&gt; &lt;/insert&gt; 方式三：实际上方式二的另一种写法
&lt;insert id="insertCacheIdNoReturn" parameterType="com.zm.pojo.User"&gt; insert into user(name,pwd) values(#{name },#{pwd}) &lt;!-- 指定结果类型resultType，keyProperty是属性，自动返回到属性id中，order是次序，after是指获取id是在于插入后 --&gt; &lt;selectKey resultType="int" keyProperty="id" order="AFTER"&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; &lt;/insert&gt; 测试方法基本一样，就是执行接口的方法不一样
注解方式：
@Insert("insert into user(name,pwd) values(#{name},#{pwd});") @Options(useGeneratedKeys = true, keyProperty = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28817450f47b1634d703ee0b1ce88be2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f66d4bc2bae2aae3c192267aa6979100/" rel="bookmark">
			Keras中dense层原理及用法解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.全连接层Fully Connection作用二.API解释2.1 示例1：dense层为输入层2.2 示例2：dense层为中间层2.3 示例3：dense层为输出层 三.实现过程四.数学解释 一.全连接层Fully Connection作用 全连接的核心操作就是矩阵向量乘积
y = W ∗ x y =W*x y=W∗x
本质就是由一个特征空间线性变换到另一个特征空间。因此，dense层的目的是将前面提取的特征，在dense经过非线性变化，提取这些特征之间的关联，最后映射到输出空间上。
如下3x3x5的数据，转换成1x4096的形式。中间实现转换这个过程是一个卷积操作, 卷积操作就是利用了矩阵向量乘积的原理实现
我们用一个3x3x5的filter 去卷积激活函数的输出，得到的结果就是一个fully connected layer 的一个神经元的输出，这个输出就是一个值
FC层在keras中叫做Dense层，正在pytorch中交Linear层
二.API解释 keras.layers.Dense(units, activation=None, use_bias=True, kernel_initializer='glorot_uniform', bias_initializer='zeros', kernel_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, bias_constraint=None) 参数解释如下（黑体为常用参数）：
units ：代表该层的输出维度或神经元个数, units解释为神经元个数为了方便计算参数量，解释为输出维度为了方便计算维度
activation=None：激活函数.但是默认 liner (详见API的activation)
use_bias=True：布尔值，该层是否使用偏置向量b
kernel_initializer：初始化w权重 (详见API的initializers)
bias_initializer：初始化b权重 (详见API的initializers)
kernel_regularizer：施加在权重w上的正则项 (详见API的regularizer)
bias_regularizer：施加在偏置向量b上的正则项 (详见API的regularizer)
activity_regularizer：施加在输出上的正则项 (详见API的regularizer)
kernel_constraint：施加在权重w上的约束项 (详见API的constraints)
bias_constraint：施加在偏置b上的约束项 (详见API的constraints)
2.1 示例1：dense层为输入层 # 作为 Sequential 模型的第一层，需要指定输入维度。可以为 input_shape=(16,) 或者 input_dim=16，这两者是等价的。 model = Sequential() model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f66d4bc2bae2aae3c192267aa6979100/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5badf01c88b6094894c06ca2b08363da/" rel="bookmark">
			表单全选取消全选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例分析： ①全选和取消全选做法：让下面所有复选框的checked属性（选中状态）跟随全选按钮即可
②下面复选框需要全部选中，上面全选才能选中做法：给下面所有复选框绑定点击事件，每次点击，都要循环查看下面所有的复选框是否有没选中的，如果有一个没选中，上面全选就不选中
③可以设置变量，来控制全选是否选中
④
//获取元素 var j_cbAll = document.getElementById('j_cbAll') //全选按钮 var j_tbs = document.getElementById('j_tbs').getElementsByTagName('input') //下面所有的复选框 //注册事件 //全选和取消全选 j_cbAll.onclick = function(){ // this.checked 它可以得到当前复选框的选中状态如果是true 就是选中，如果是false 就是未选中 for(var i = 0; i &lt; j_tbs.length;i++){ j_tbs[i].checked = this.checked } } //下面复选框全部选中，才会触发上面的全选 //遍历给下面每个复选框绑定点击事件 for(var i = 0; i &lt; j_tbs.length; i++){ j_tbs[i].onclick = function(){ //flag控制全选按钮是否选中 var flag = true //每次点击下面的复选框都要循环检查这4个小按钮是否全被选中 for(var i = 0; i &lt; j_tbs.length; i++){ if(!j_tbs[i].checked){ flag = false; break;	//退出for循环 这样可以提高执行效率 因为只要有一个没有选中，剩下的就无需循环 } } j_cbAll.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5badf01c88b6094894c06ca2b08363da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8c3fa607f5e602a4b10f768776dddba/" rel="bookmark">
			Java反射机制案例-通过修改配置文件可以创建任意对象，并使用其方法。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		反射：框架设计的灵魂 什么是反射？
将类的各个组成部分（成员变量，构造函数，方法）封装为其他对象 Java代码在计算机中经历的三个阶段
案例 配置文件 className=day01.reflect.Car methodName=carMethod 代码 import java.io.IOException; import java.io.InputStream; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Properties; public class PersonOrCar { public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException { //创建配置对象 Properties properties = new Properties(); //创建类加载器 ClassLoader classLoader = PersonOrCar.class.getClassLoader(); //通过类加载器，读取配置文件并转化为字节流 InputStream resourceAsStream = classLoader.getResourceAsStream("config.properties"); //载入配置文件 properties.load(resourceAsStream); //读取配置文件中的类名和方法名 String className = properties.getProperty("className"); String methodName = properties.getProperty("methodName"); //加载该类进入到内存中运行 Class aClass = Class.forName(className); //创建该类的一个对象 Object newObj = aClass.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8c3fa607f5e602a4b10f768776dddba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d0e32c8fc4aea63bd063bbf899310c8/" rel="bookmark">
			Freescale MC9S12G128  PLL,OSC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MC9S12G128 PLL,OSC PLL OSC简述：S12CPMU Block Diagram:S12CPMU Synthesizer Register(CPMUSYNR)PLL设置示例： PLL OSC简述： S12CPMU Block Diagram: S12CPMU Synthesizer Register(CPMUSYNR) PLL相关主要寄存器：
CPMUPROT:时钟配置寄存器保护
Clock Configuration Registers Protection Bit — This bit protects the clock configuration registers from
accidental overwrite (see list of affected registers above):
Writing 0x26 to the CPMUPROT register clears the PROT bit, other write accesses set the PROT bit.
0 Protection of clock configuration registers is disabled.
1 Protection of clock configuration registers is enabled.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d0e32c8fc4aea63bd063bbf899310c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2ae5206fa1a8e17dcb044682c5d5308/" rel="bookmark">
			hutool文档_Hutool:github拥有11.9k Star的“糊涂”项目不糊涂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天逛Github社区，又发现了一个好项目，迫不及待的推荐给大家，虽然和嵌入式关系不大，但是对于广大的JAVA开发者来说，绝对是神器。
简单介绍一下Hutool Hutool是一个小而全的Java工具类库，通过静态方法封装，降低相关API的学习成本，提高工作效率，使Java拥有函数式语言般的优雅，让Java语言也可以“甜甜的”。
开源项目Hutool
为什么推荐Hutool 工欲善其事必先利其器，Hutool能快速的提高开发效率，这就是我推荐的原因。
Hutool的目标是使用一个工具方法代替一段复杂代码，从而最大限度的避免“复制粘贴”代码的问题，彻底改变我们写代码的方式。
以计算MD5为例：
【以前】打开搜索引擎 -&gt; 搜“Java MD5加密” -&gt; 打开某篇博客-&gt; 复制粘贴 -&gt; 改改好用
【现在】引入Hutool -&gt; SecureUtil.md5()
Hutool的存在就是为了减少代码搜索成本，避免网络上参差不齐的代码出现导致的bug。
直接调用API，是不是简单快捷方便？
Hutool涵盖的组件有哪些？ 一个Java基础工具类，对文件、流、加密解密、转码、正则、线程、XML等JDK方法进行封装，组成各种Util工具类，同时提供以下组件：
Hutool组件包
如上图所示，Hutool组件包含了大部分常用功能，可以根据需求对每个模块单独引入，也可以通过引入hutool-all方式引入所有模块。
以后写代码再也无需去copy和paste了，一个API轻松搞定。
如何安装？ Maven项目：
在项目的pom.xml的dependencies中加入以下内容:
cn.hutool hutool-all 5.3.2 Gradle
compile 'cn.hutool:hutool-all:5.3.2' 非Maven项目
下载hutool-all-X.X.X.jar即可。
编译安装
下载整个项目源码(v5-master或v5-dev分支都可)然后进入Hutool项目目录执行：
./hutool.sh install 然后就可以使用Maven引入了。
如果想要HutoolAPI文档+中文参考文档+项目链接
请关注我，再私信，发送关键字“Hutool”，后台将自动发送。
欢迎关注，后期继续不定期分享干货~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4424d26c9f6062345a5b11edbef68a96/" rel="bookmark">
			使用VSCode打造APM飞控的编译&#43;烧录&#43;调试一体的终极开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
本文链接：https://blog.csdn.net/loveuav/article/details/89969810
前言 APM（Ardupilot）和PX4是当今世界上最为流行和活跃的两大开源飞控软件项目，它们均在Linux下基于gcc编译工具链开发，对于那些习惯与在Windows下使用Keil MDK开发单片机的童鞋，无疑带来了一定的门槛，除了编译环境搭建较为麻烦之外，还有一个最主要的原因便是难以实现类似Keil上的在线硬件调试（Debug）功能。
而本文的主要目的在于引导读者，在Ubuntu系统下为APM飞控搭建一个类似Keil的编译、烧录和调试一体的开发环境，降低开源飞控的入门和开发门槛。
前期准备 硬件 飞控板：本教程中必须是基于STM32单片机并支持APM固件的飞控板，如pixhawk，pixhawk2等等，而作者本人则使用的是之前自己制作的一款基于STM32F405的飞控板，因此中间还有一段移植APM固件到第三方飞控板的教程，如果手上已经有官方飞控的童鞋可以直接跳过。J-Link OB调试器：烧录和调试必备工具，淘宝上十几元一个，没有的话先准备一个吧。 系统环境 ubuntu 18.04
软件 这里先列出后续会使用到的软件工具版本：
VSCode : 1.33.1OpenOCD : 0.10.0Cortex-Debug : 0.2.3gcc-arm-none-eabi : 6.3.1python : 2.7.15ArduCopter : 3.7.0-dev (fd19b257) 为什么使用VSCode VSCode是微软在2015年发布的一个现代化跨平台开源编辑器，原生支持Git，并拥有着最强大的插件社区，被称之为史上最好用的编辑器。在越来越多各种强大的插件支持下，你可以将VSCode演变成支持绝大多数语言的IDE，当然包括了我们做嵌入式开发常用的C/C++。
随着时代的发展，Keil之类的IDE，虽然上手简单，但是其编辑器功能已经远远落后与时代，还有着收费、不开源、不支持跨平台等各种问题。而VSCode正好弥补了这些缺点，并有着无比强大的编辑器功能与丰富插件支持。结合插件，我们可以将VSCode打造成一个有史以来最强大的飞控开发IDE，有着比拟Keil的硬件Debug功能，还有秒杀Keil几条大街的编辑器，那么我们还有什么理由不投入VSCode的怀抱呢？
邂逅VSCode 1.安装 在ubuntu上安装VSCode的方法有很多种，可自行百度。比较简单的一种方式是访问官网，直接下载deb包到本地，双击安装。
2.插件 丰富的插件是VSCode的灵魂，也是短短两三年内造就了VSCode霸主地位的主要原因之一，不安装插件的VSCode比咸鱼好不了多少。。。
安装插件的方法是点击左侧的”Extensions“图标，或使用快捷键ctrl+shit+x打开插件搜索栏，输入名称查找插件，并点击install，如下图：
必装插件 C/C++ ：提供C/C++语言的智能推导，函数跳转，调试等功能GitLens ：Git辅助插件Chinese (Simplified) Language Pack ：中文界面语言包Cortex-Debug ：Cortex系列单片机调试工具 推荐安装 Git History ：可视化的形式查看Git提交历史Bracket Pair Colorizer ：为代码中的括号添加颜色识别，强烈推荐，可提高代码阅读效率C++ Intellisense ：可作为C/C++插件的一个补充ARM ：提供ARM汇编语言的高亮识别One Dark Pro ：比较受欢迎的主题vscode-icons ：提供各种好看的文件及文件夹图标Settings Sync ：同步VSCode配置 3.设置界面为中文 喜欢原生英文界面的可跳过这一步。。。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4424d26c9f6062345a5b11edbef68a96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8819554d7106be9ce1d3cbe8ed02996/" rel="bookmark">
			怎么把4399小游戏的代码_25行代码带你爬取4399小游戏数据，看下童年的游戏是否还在...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
本文的文字及图片来源于网络,仅供学习、交流使用,不具有任何商业用途,如有问题请及时联系我们以作处理。
还记得童年的网页小游戏吗？今天带大家爬取4399小游戏网站的数据，游戏名字+链接地址
目标网站
http://www.4399.com/ 基本环境配置
python 3.6
pycharm
requests
parsel
csv
爬虫代码
导入需要用到的工具
1import requests
2import parsel
3import csv
请求网页
1 url = 'http://www.4399.com/flash_fl/5_{}.htm'.format(page)
2 headers = {
3 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36'
4 }
5 response = requests.get(url=url, headers=headers)
6 response.encoding = response.apparent_encoding
解析网页，爬取数据
1 for li in lis:
2 dit ={}
3 data_url = li.css('a::attr(href)').get()
4 new_url = 'http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8819554d7106be9ce1d3cbe8ed02996/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91c0e2834b4b90272a2321bf7d092fee/" rel="bookmark">
			html网页制作期末大作业成品_大工20秋《Web前端网页制作》大作业及要求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击这里获取答案
网络教育学院
《Web前端网页制作》课 程 设 计题 目： 学习中心： 层 次： 专 业： 年 级： 年 春/秋 季 学 号： 学 生： 辅导教师： 完成日期： 年 月 日
大工20秋《Web前端网页制作》课程设计
注意：从以下5个题目中任选其一作答。
题目一：学习资源共享平台
总 则：利用先关的平台和数据库设计一个资源共享平台。（具体工具平台及语言可以自己根据自己的习惯选用）
要 求：（1）建立一个完整的平台文件夹，所有平台内容都要包含在建立的这个文件夹内，平台各类元素文件在总文件夹中以子文件夹形式分类清楚。（如图片都放在子文件夹image里，html页都放在pages子文件夹内，数据库文件放在DB文件夹内）
（2）平台系统用户分为：学生用户、教师用户和管理员用户。不同的用户拥有不同的权限，各自完成各自的管理功能，不同的用户看到不同的系统功能。
（3）用SQL Server/MySql创建后台数据库，并完善数据库结构和功能。
（4）学生用户的主要功能模块：学生的登录与注册、学生留言、资料上传、下载。
（5）教师的主要功能模块：教师的注册和登录、教师留言、资料上传、下载。
（6）管理员的主要功能模块：管理员管理学生教师的信息、管理员审核资料。
（7）附带一份课程设计功能说明书，也放在总文件夹中。功能书包含：介绍各模块功能、数据库设计说明、各模块核心程序、总结及体会。
（8）将所制作的相关文件压缩成一个文件，文件名为 [姓名 奥鹏卡号 学习中心]（如戴卫东101410013979浙江台州奥鹏学习中心[1]VIP ）
作业提交：
大作业上交时文件名写法为：[姓名 奥鹏卡号 学习中心]（如：戴卫东101410013979浙江台州奥鹏学习中心[1]VIP）
以附件形式上交离线作业（附件的大小限制在10M以内），选择已完成的作业（注意命名），点提交即可。如下图所示。
注意事项：
独立完成作业，不准抄袭其他人或者请人代做，如有雷同作业，成绩以零分计！
题目二：制作一个VIP登记网站
总 则：利用Dreamweaver CS3结合ASP制作一个VIP登记网站，建立几个基本的数据库表。
要 求：（1）建立一个完整的站点，所有网站内容都要包含在建立的这个站点文件夹内，网站各类元素文件在站点总文件夹中以子文件夹形式分类清楚。（如图片都放在子文件夹image里，html页都放在pages子文件夹内）
（2）制作一个简单的符合VIP登记网站的首页，包括必要的连接：VIP注册、VIP登录、新闻公告等。首页体现出清晰的框架结构。
（3）建立简单的数据关联。
（4）制作VIP的注册和登录页面，充分运用表单技术。
（5）建立VIP个人管理页面，包含基本的管理元素。
（6）附带一份网站设计及功能说明书，也放在站点总文件夹中。
（7）将所制作的网页及相关文件压缩成一个文件，文件名为 [姓名 奥鹏卡号 学习中心]（如戴卫东101410013979浙江台州奥鹏学习中心[1]VIP ）
作业提交：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91c0e2834b4b90272a2321bf7d092fee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/508ac18edd6b122b6444f22678a1317d/" rel="bookmark">
			联想笔记本电脑忘记账户密码与PIN码怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
联想笔记本电脑忘记账户密码与PIN码怎么办
步骤一：制作u盘启动盘
步骤二：登录微软官网，找到恢复密钥
步骤三：使用U盘清除密码
经验教训
联想笔记本电脑忘记账户密码与PIN码怎么办 我的联想小新笔记本，装的Windows10正版系统，设置的本地账户。昨天，由于指纹识别太多次没有成功，导致进入系统的时候需要输入PIN码，我忘了PIN码，也忘记了本地账户的密码。一通百度和朋友的助攻下，成功清除了登录密码。
步骤一：制作u盘启动盘 地址：http://pe.uqidong.asia/，下载UEFI版，使用教程在页面中都有说明
步骤二：登录微软官网，找到恢复密钥 步骤三：使用U盘清除密码 这里面分为几个小步骤，我写详细点，有用的上的朋友可以作为指引
开机时按Fn+f12，使用U盘启动盘，进入WinPE环境；桌面上有清除账户密码的工具，打开之后，清除按钮是灰色的，因为磁盘被加密了，这就是正版系统的优点，也是不方便的地方；打开磁盘管理，解锁C盘，选择使用恢复密钥，输入C盘的恢复密钥；这个时候就可以使用清除账户密码的工具清除掉密码了。 经验教训 在控制面版-&gt;用户账户-&gt;用户账户-&gt;创建密码重置盘，备份一份密码；设置完账户密码和PIN码之后，要重启验证下；多创建一个账户 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd26fc20ff8ae484deabcd51ed9326e0/" rel="bookmark">
			栈----出栈序列合法判断(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 给定一个从1开始的连续整数列1、2、3、4…n。
将上述数列按顺序入栈，中途栈顶元素可以出栈。
再给定一个出栈序列，判断此序列是否合法。
例如，将n设为4。即得到数列1、2、3、4。
再给定出栈序列1、3、4、2。
可以看出，此出栈序列合法。
过程如下，先将数列1、2、3、4中的元素1入栈，再将其出栈。
然后将元素2、3入栈，将元素3出栈。
最后将元素4入栈，再把栈内的仅余元素4、2出栈。
整个过程中，元素按照1、3、4、2的顺序出栈。证明其合法。
Input
输入包括多组测试用例。
对于每组测试用例，第一行包含一个整数n&lt;100，代表从1开始的连续整数列长度。
第二行包含一个长度为n的数列，代表出栈序列。出栈序列的各元素在区间[1,n]内且不重复。
Output
若出栈序列合法，则输出Yes。
否则，输出No。
Sample Input 4
1 3 4 2
Sample Output
Yes
Hint
“Yes”,"No"注意大小写
判断原则：出栈序列中，元素i之后所有比i小的元素之间必须是降序排列的 #include&lt;iostream&gt;//出栈序列中，元素i之后所有比i小的元素之间必须是降序排列的 using namespace std; int main() { int n; while(cin&gt;&gt;n) { int a[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; int flag1=0; int flag2=0;//如果序列不合法为1 for(int i=0;i&lt;n;i++) { flag1=0; int temp,j; for(j=i+1;j&lt;n;j++) { if(a[j]&lt;a[i]) { flag1=1; temp=a[j]; break; } } if(flag1==1) { for(int k=j+1;k&lt;n;k++) { if(a[k]&lt;a[i]&amp;&amp;a[k]&gt;temp) { flag2=1; break; } else if(a[k]&lt;a[i]&amp;&amp;a[k]&lt;temp) { temp=a[k]; } } }	if(flag2==1) break; } if(flag2==0) cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd26fc20ff8ae484deabcd51ed9326e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47a7321acd82550b44873b1211529531/" rel="bookmark">
			mysql函数分别系统函数和自定义函数_【存储过程】MySQL存储过程/存储过程与自定义函数的区别...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		---------------------------存储过程--------------------
语法:
创建存储过程:
CREATE[definer = {user|current_user}] PROCEDURE sp_name ([ proc_parameter [,proc_parameter ...]]) [ characteristics..] routime_body
其中:
proc_parameter : [IN|OUT|INOUT] parameter_name type
其中IN表示输入参数，OUT表示输出参数，INOUT表示既可以输入也可以输出；param_name表示参数名称；type表示参数的类型
存储过程体中可以使用自定义函数(UDF)中使用的复合结构/流程控制/SQL语句/自定义变量等等内容,
调用存储过程:
CALLsp_name ([ proc_parameter [,proc_parameter ...]])
CALL sp_name
说明:当无参时,可以省略"()",当有参数时,不可省略"()"
存储过程修改:
ALTER语句修改存储过程只能修改存储过程的注释等无关紧要的东西,不能修改存储过程体,所以要修改存储过程,方法就是删除重建!
删除存储过程:
DROP PROCEDURE [IF EXISTS] sp_name
示例:
创建无参存储过程:
delimiter //
CREATE PROCEDURE showTime()
BEGIN
SELECT now();
END//
delimiter ;
CALL showTime;
作用:显示当前时间,没什么实际意义
创建含参存储过程:
只有一个IN参数
delimiter //
CREATE PROCEDURE seleById(IN uid SMALLINT UNSIGNED)
BEGIN
SELECT * FROM son WHERE id = uid;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47a7321acd82550b44873b1211529531/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4666276ae6565133ffa19fdbb2eb4f6/" rel="bookmark">
			脚本实现Oracle19c_pdb单实例自动安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目地址：Oracle19c_pdb_autoinstall
脚本使用说明具体请查看github上的README.md，使用上有什么问题，请反馈问题到我邮箱，谢谢！！
说明：脚本已经配置oracle服务自启动，并配置为系统服务，启动与停止时使用root用户操作
停止 # service oracle stop 启动 # service oracle start oracle19c（12.2.0.3）版本在linux系统环境的使用说明：
The following Linux x86-64 kernels are supported:
1、Oracle Linux 7.4 with the Unbreakable Enterprise Kernel 4: 4.1.12-112.16.7.el7uek.x86_64 or later
2、Oracle Linux 7.4 with the Unbreakable Enterprise Kernel 5: 4.14.35-1818.1.6.el7uek.x86_64 or later
3、Oracle Linux 7.4 with the Red Hat Compatible kernel: 3.10.0-693.5.2.0.1.el7.x86_64 or later
4、Red Hat Enterprise Linux 7.4: 3.10.0-693.5.2.0.1.el7.x86_64 or later
5、SUSE Linux Enterprise Server 12 SP3: 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4666276ae6565133ffa19fdbb2eb4f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5277b1abe4d9d44642680e3f26190f4f/" rel="bookmark">
			mysql key_len_浅谈mysql explain中key_len的计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql的explain命令可以分析sql的性能，其中有一项是key_len(索引的长度)的统计。本文将分析mysql explain中key_len的计算方法。
1、创建测试表及数据
CREATE TABLE `member` (
`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
`name` varchar(20) DEFAULT NULL,
`age` tinyint(3) unsigned DEFAULT NULL,
PRIMARY KEY (`id`),
KEY `name` (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
INSERT INTO `member` (`id`, `name`, `age`) VALUES (NULL, 'fdipzone', '18'), (NULL, 'jim', '19'), (NULL, 'tom', '19');
2、查看explain
name的字段类型是varchar(20)，字符编码是utf8，一个字符占用3个字节，那么key_len应该是 20*3=60。
mysql&gt; explain select * from `member` where name='fdipzone';
+----+-------------+--------+------+---------------+------+---------+-------+------+-----------------------+
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5277b1abe4d9d44642680e3f26190f4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c79327aa9be8053f18985100dc23e689/" rel="bookmark">
			mysql binlog过期策略_清理多台MySQL数据库的过期binlog日志的shell脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节主要内容：
清理mysql中过期的binlog日志。
问题描述：美好梦中，传来阵阵报警声，磁盘空间满。
查看：
复制代码 代码示例:
[root@jbxue cacti]$ ssh xxxx "df -h"
/dev/mapper/Sys-mysqldata
300G 270G 30G 90% /mysqldata
15G 166M 14G 2% /mysqldata/binlog
原因：
近段时间业务量增长比较快，可能是产生了过多的binlog导致的。
继续分析：
复制代码 代码示例:
[root@jbxue cacti]$ ssh xxxx " sudo -u mysql ls /mysqldata/data/" |grep mysql-bin
mysql-bin.001350
.......
mysql-bin.002352
mysql-bin.log.index
binlog日志文件1000多个，看来要写个脚本清理下了。
本文的主角出场，一个清理多台MySQL数据库的过期binlog日志的shell脚本，分享给大家。
clear_binlog.sh脚本：
复制代码 代码示例:
#!/bin/bash
#
#site: www.jquerycn.cn
for i in `cat server03list`; do #循环遍历db列表
# 1 获取数据库的master binlog名称,并在控制台打印出当前执行的db名称
echo $i;
binlog=`ssh $i " /opt/mysql/product/5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c79327aa9be8053f18985100dc23e689/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cb86e912acfaee8d62364772a058833/" rel="bookmark">
			队列的链式存储结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链队列 队列的存储结构一、队列的初始化操作二、队列的相关函数判断队列是否为空获得队列的长度 三、获得获得队列头元素四、队列的插入五、队列的删除六、清空队列七、销毁队列总结测试代码及运行实例 队列的存储结构 队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表，即“先进先出”
typedef struct QNode { int data; struct QNode *next; }QNode,*QueuePtr; typedef struct { QueuePtr front,rear; }LinkQue,*LinkQueue; 结点由存放数据元素的数据域和存放放后继结点地址的指针域组成
链队列由指向头结点的front和指向队尾的rear组成
同线性表，元素具有相同的类型，相邻元素具有前驱和后继关系。
对于链栈来说，当队列为空时，front和rear都指向头结点 一、队列的初始化操作 目的：初始化队列
实现：类比链表创建头结点，让front和rear都指向头结点，初始化一个空队列
void InitQueue(LinkQueue &amp;Q) { Q=(LinkQueue)malloc(sizeof(LinkQue)); QueuePtr s=(QueuePtr)malloc(sizeof(QNode)); Q-&gt;front=s; Q-&gt;rear=s; } 二、队列的相关函数 判断队列是否为空 若队列为空返回true，否则返回false
bool QueueEmpty(LinkQueue Q) { return Q-&gt;rear==Q-&gt;front; } 获得队列的长度 创建结点指针s遍历链队列，返回队列长度
int QueueLength(LinkQueue Q) { int len=0; QueuePtr s=Q-&gt;front; while (s-&gt;next) { s=s-&gt;next; len++; } return len; } 三、获得获得队列头元素 功能：输出获得队列头元素
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cb86e912acfaee8d62364772a058833/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36e8a3c6fcabc135f30c4c76297489e5/" rel="bookmark">
			Spark中字符串和json、map格式相互转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spark中字符串和json格式相互转化 字符串转为map import org.json4s.DefaultFormats import org.json4s.jackson.JsonMethods.parse val ad = """{"name":"zsd","age":11}""" implicit val formats: DefaultFormats.type = org.json4s.DefaultFormats val adMap: Map[String, Any] = parse(ad).extract[Map[String, Any]] map或者case class 转化为字符串 import org.json4s.jackson.Serialization import org.json4s.{Formats, NoTypeHints} case class Person(name:String,age:Int) val p = Person("zs",20) implicit val formats: AnyRef with Formats = Serialization.formats(NoTypeHints) val jsonString = Serialization.write(p) val m = Map( "name" -&gt; "zd", "age" -&gt; 13 ) implicit val formats: AnyRef with Formats = Serialization.formats(NoTypeHints) val jsonString = Serialization.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36e8a3c6fcabc135f30c4c76297489e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22843484c18fe248bf31306244f79f47/" rel="bookmark">
			剑指 Offer 48. 最长不含重复字符的子字符串 C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 普通哈希表 遍历字符串s，作为起点，二次遍历字符串，当有重复字符出现时，记录下此时的字符串长度tmp；
清除哈希表，并退出循环，取tmp，和res中较大的赋给res；
进入到下一轮循环，起点后移一个字符，重复上面步骤。
class Solution { public: int lengthOfLongestSubstring(string s) { unordered_set&lt;char&gt; hash; int res = 0; for(int i = 0; i &lt; s.size(); i++){ int tmp = 0; for(int j = i; j &lt; s.size(); j++){ if(hash.find(s[j])==hash.end()){ hash.insert(s[j]); tmp++; }else{ hash.clear(); break; } } res = max(res, tmp); } return res; } }; 时间复杂度 O(N^2) 空间复杂度 O(1)
2 双指针 + 哈希 第一种做法时间消耗太大，有没有什么办法能够一次遍历即可，因为两次遍历其实遍历了很多重复的元素，所以我们可以使用左右指针分别指向子串的首尾，如果加入新元素不重复，那么右指针就一直右移，如果加入新元素重复了呢？那么右指针就先歇歇，左指针右移，然后移除前面的元素。
举个例子：
p w w k e w
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22843484c18fe248bf31306244f79f47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5deedf17160ecfc0ceed03a106b3203a/" rel="bookmark">
			freescale MC9S12G128单片机概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MC9S12G-Family Features:开发环境：CodeWarrior IDE:开发板：DBM下载器： Features: This section describes the key features of the MC9S12G-Family.
S12 16Bit Central Processor Unit (CPU)
外部主时钟（Main External Oscillator）4MHz~16MHz 晶振(crystal)
内置1MHz RC振荡器IRC(Internal RC Oscillator )
内置锁相环IPLL（Internal Phase-Locked Loop）
开发环境： CodeWarrior IDE: CodeWarrior IDE version 5.9.0开发板+DBM下载 器 开发板： 飞翔科技MC9S12G128MLL开发板实物图
DBM下载器： 飞翔科技DBM下载实物图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8b0f92b66c0a9ac474c21fa2edbc073/" rel="bookmark">
			XShell 还是 FinalShell？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		水帖
FinalShell 是我先于 XShell 上手的，怎么说呢，遇到需要代理，打隧道的时候，你还得下XShell，XShell 支持的功能不是一点半点，毕竟一个团队了。
反观FinalShell，Java 大内存，高CPU占用，不定时卡死，个人维护。。。
总之，我的推荐还是 XShell 和 XFtp，因为我这种强迫症用完一次就关，需要多次，频繁的打开，继续 FinalShell 的话那体验太不好了。而且 XShell 对个人免费（虽然对其他产品有打压的意思，但确实你得考虑效率啊）
XShell Yes 😃 官网下载即可，如慢，利用迅雷
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/596e719d6bb3246079d8d6493a11a34c/" rel="bookmark">
			mysql查询所有触发器_如何查询数据库中的所有触发器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select name from sysobjects where xtype='TR' --所有触发器
select name from sysobjects where xtype='P' --所有存储过程
select name from sysobjects where xtype='V' --所有视图
select name from sysobjects where xtype='U' --所有表
以上为SqlServer用法
Select object_name From user_objects Where object_type='TRIGGER'; --所有触发器
Select object_name From user_objects Where object_type='PROCEDURE'; --所有存储过程
Select object_name From user_objects Where object_type='VIEW'; --所有视图
Select object_name From user_objects Where object_type='TABLE'; --所有表
以上为Oracle用法
show triggers;
查看所有触发器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b59f8c81030a9fed400e0114e43c6ec5/" rel="bookmark">
			stdstring、LPCWCH、LPSTR之间转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		std::string、LPCWCH、LPSTR之间转换 最近在写一个程序，用到了windows 原始API，遇到了字符之间的转换问题，在网上发现，都不是很全面。所以整理一下源码，记录一下，希望帮到有需要的人。
/******************************************************************************* * Function : LPCWCH2LPSTR * Description: LPCWCH转换LPSTR * Calls : 见函数实现 * Called By : * Input : * Output : * Return : * Others : ********************************************************************************/ LPSTR LPCWCH2LPSTR(const LPCWCH strCS) { const UINT wLen = lstrlen(strCS) + 1; UINT aLen = WideCharToMultiByte(CP_ACP, 0, strCS, wLen, NULL, 0, NULL, NULL); LPSTR lpa = new char[aLen+1]; memset(lpa, 0, aLen+1); WideCharToMultiByte(CP_ACP, 0, strCS, wLen, lpa, aLen, NULL, NULL); return lpa; } /******************************************************************************* * Function : LPCWCH2STDString * Description: LPCWCH转换LPSTR * Calls : 见函数实现 * Called By : * Input : * Output : * Return : * Others : ********************************************************************************/ std::string LPCWCH2STDString(const LPCWCH strcs) { LPSTR ltmp = LPCWCH2LPSTR(strcs); std::string stdStr(ltmp); delete[] ltmp; return stdStr; } /******************************************************************************* * Function : STDString2LPWSTR * Description: std::string转换LPWSTR * Calls : 见函数实现 * Called By : * Input : * Output : * Return : * Others : ********************************************************************************/ LPWSTR STDString2LPCWCH(const std::string strcs) { UINT len = MultiByteToWideChar(CP_ACP, 0, strcs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b59f8c81030a9fed400e0114e43c6ec5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01fc34b79bf23c756e571c37cd2ff643/" rel="bookmark">
			vmware14.1.8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网下载地址如下：
https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.8-14921873.exe
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c064f52e0f3482973f3f739da06e740f/" rel="bookmark">
			mysql语句计算表平均值_如何计算mysql数据表某一列的平均值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建一个test数据库，在数据库里建立一张data表，内外有三个字段，id、username、age。
2
在data数据内外插入5条数据，用于下面计较数据表age列的平均值。
3
新建一个php文件，定名为test.php，在文件内利用header()方式设置文件执行编码为utf8。
4
在test.php文件内，利用new mysqli经由过程数据库账号、暗码、名称毗连数据库，并利用set_charset设置获取数据的编码为utf8，再利用if语句判定当毗连数据库不当作功时，输犯错误信息。
5
在test.php文件内，编写查询数据库的sql语句，在sql语句中，利用avg()方式求age列的平均值。
6
在test.php文件内，利用query()方式执行sql语句查询数据库，将获得的数据资本利用fetch_all()方式转换为二维数据，并经由过程echo把平均值输出在页面上。
7
在浏览器执行test.php文件，查看输出的成果。可见，当作功实现了输出age列的平均值，平均值为20。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/172ebd12e7408b4756c8a7b7ff2a54d1/" rel="bookmark">
			怎么看mysql的编码方式_如何查看mysql编码方式？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看mysql编码方式的方法：
1、需要以root用户身份登陆才可以查看数据库编码方式
以root用户身份登陆的命令为：&gt;mysql -u root –p,之后两次输入root用户的密码
2、查看数据库的编码方式命令为:&gt;show variables like 'character%';
+--------------------------+----------------------------+
| Variable_name | Value |
+--------------------------+----------------------------+
| character_set_client | latin1 |
| character_set_connection | latin1 |
| character_set_database | latin1 |
| character_set_filesystem | binary |
| character_set_results | latin1 |
| character_set_server | latin1 |
| character_set_system | utf8 |
| character_sets_dir | /usr/share/mysql/charsets/ |
+--------------------------+----------------------------+
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/552781b1a7f4a01b26a8c847de574032/" rel="bookmark">
			mysql 索引修改_mysql添加、修改、删除、查询索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、添加索引
1、添加普通索引/联合索引
第一种：
格式：
ALTER TABLE 表名 ADD INDEX 索引名称(索引字段);
ALTER TABLE user ADD INDEX name_index(name);
第二种：
格式：
CREATE INDEX 索引名称 ON 表名(索引字段);
CREATE INDEXname_index ONuser(name);
注：添加普通索引使用 index ，索引字段可以为多个用逗号分隔即为联合索引
2、添加唯一索引
第一种：
格式：
ALTER TABLE 表名 ADD UNIQUE 索引名称(索引字段);
ALTER TABLEuser ADD UNIQUE login_name_index(login_name,user_type);
第二种：
格式：
CREATE UNIQUE INDEX 索引名称 ON 表名(索引字段);
CREATE UNIQUE INDEX login_name_index ON user(login_name,user_type);
注：唯一索引使用 UNIQUE ，索引字段可以有多个用逗号分隔，多个时即为联合唯一索引
二、删除索引
格式：
DROP INDEX 索引名称 ON 表名;
DROP INDEX login_name_index ON user;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/552781b1a7f4a01b26a8c847de574032/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aa880e06894bf0eb43f1eaf355ad985/" rel="bookmark">
			mysql游标 循环_MySQL游标与嵌套循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游标嵌套遍历
user表：
CREATE DEFINER=`root`@`localhost` PROCEDURE `test`()
BEGIN
DECLARE user1 VARCHAR(100);
DECLARE user2 VARCHAR(100);
DECLARE done INT DEFAULT 0;
DECLARE cursor_user1 CURSOR FOR(SELECT `name` FROM `user`); -- 定于游标1
DECLARE cursor_user2 CURSOR FOR(SELECT `name` FROM `user`); -- 定义游标2
DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1; -- 结束标识
OPEN cursor_user1; -- 开启游标1
loop_1: LOOP -- 外层循环
-- -------------------------------------------------------------------------------------
# 尝试从游标1指向的数据集合获取数据，如果集合已经遍历完毕，done的值被设置为1。
FETCH cursor_user1 INTO user1;
IF done = 1 THEN LEAVE loop_1; END IF; -- 外层循环结束条件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2aa880e06894bf0eb43f1eaf355ad985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbf1276bca87eb6933ca579f748eb9be/" rel="bookmark">
			mysql if then end_Mysql的查询--case when then end 与 if
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1
IF(expr1,expr2,expr3)
如
mysql&gt; SELECT IF(1&gt;2,2,3); -&gt; 3
mysql&gt; SELECT IF(1&lt;2,'yes','no'); -&gt; 'yes'
mysql&gt; SELECT IF(STRCMP('test','test1'),'no','yes'); -&gt; 'no'
表 A
字段 a，b，c，d
if(条件，value1,value2)
注意：value可以是值，可以是字段，也可以是式子 如：c/d,c+d 等。
SELECT if(a&gt;b,c,d) as cs FROM A
解释：如果用if进行对字段值的判断，当条件为 true时，取值value1,为flase时，取值value2。
2
case when then else end 语句用于查询满足多种条件的情况，类似java中的if...else，还有的就是用于进行行转列的查询，这个是放在select 子句后面的，是充当的是字段的作用。
具体用法就是：分为两种，一种是简单的函数形式，另一种就是表达式的形式。
其含义解释：
简单的函数形式
case 字段 when 值 then 结果 else 其他情况 end；
表达式的形式
case when 字段=值(这里写表达式，例如 score=80) then 结果 else 其他情况 end；
如：
简单的函数形式
select case score when 'a' then '优秀' else '良好' end from student;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbf1276bca87eb6933ca579f748eb9be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2da4c129017c32fd16ad728dac925eea/" rel="bookmark">
			用pandas将数据写入mysql_如何用Pandas库实现MySQL数据库的读写？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次分享将介绍如何在Python中使用Pandas库实现MySQL数据库的读写。首先我们需要了解点ORM方面的知识。
ORM技术
对象关系映射技术，即ORM(Object-Relational Mapping)技术，指的是把关系数据库的表结构映射到对象上，通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。在Python中，最有名的ORM框架是SQLAlchemy。Java中典型的ORM中间件有: Hibernate, ibatis, speedframework。
SQLAlchemy
SQLAlchemy是Python编程语言下的一款开源软件。提供了SQL工具包及对象关系映射(ORM)工具，使用MIT许可证发行。可以使用pip命令安装SQLAlchemy模块：
'数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名'
Pandas读写MySQL数据库
我们需要以下三个库来实现Pandas读写MySQL数据库：
pandas
sqlalchemy
pymysql
其中，pandas模块提供了read_sql_query()函数实现了对数据库的查询，to_sql()函数实现了对数据库的写入，并不需要实现新建MySQL数据表。sqlalchemy模块实现了与不同数据库的连接，而pymysql模块则使得Python能够操作MySQL数据库。我们将使用MySQL数据库中的mydb数据库以及employee表，内容如下：
mydb数据库以及employee表
下面将介绍一个简单的例子来展示如何在pandas中实现对MySQL数据库的读写：
在MySQL中查看mydf表格：
这说明我们确实将pandas中新建的DataFrame写入到了MySQL中!
将CSV文件写入到MySQL中
以上的例子实现了使用Pandas库实现MySQL数据库的读写，我们将再介绍一个实例：将CSV文件写入到MySQL中，示例的mpg.CSV文件前10行如下：
mpg.CSV文件前10行
示例的Python代码如下：
在MySQL中查看mpg表格：
仅仅5句Python代码就实现了将CSV文件写入到MySQL中，这无疑是简单、方便、迅速、高效的!
总结
本文主要介绍了ORM技术以及SQLAlchemy模块，并且展示了两个Python程序的实例，介绍了如何使用Pandas库实现MySQL数据库的读写。程序本身并不难，关键在于多多练习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7090ead3b72d0dfd1d2d505e6a5f7333/" rel="bookmark">
			FcaNet解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 注意力机制，特别是通道注意力机制在计算机视觉中取得了巨大的成功，很多工作着重于设计更加高效的通道注意力结构，却忽略了一个重要的问题，那就是为了得到每个通道全局表示所使用的全局平均池化（Global Average Pooling，GAP）真的合适吗？FcaNet这篇文章，作者从频域角度重新思考GAP，为了弥补了现有通道注意力方法中特征信息不足的缺点，将GAP推广到一种更为一般的2维的离散余弦变换（DCT）形式，通过引入更多的频率分量来充分的利用信息。设计的高效Fca模块甚至在现有的通道注意力方法基础上，只需要修改一行代码即可实现。
论文标题
FcaNet: Frequency Channel Attention Networks
论文地址
http://arxiv.org/abs/2012.11879
论文源码
https://github.com/cfzd/FcaNet
介绍 注意力机制在计算机视觉中受到了广泛的关注，它让网络更加关注于部分重要的信息，按照作用维度的不同，我们将注意力分为空间注意力、通道注意力和自注意力，其中，由于简单高效，下图所示的通道注意力直接对不同的通道加权，成为一种主流的注意力范式。
SENet和ECANet致力于设计不同的通道加权函数，如全连接或者一维卷积，然后这些函数的输入都是每个通道一个标量，这个标量默认都是来自于GAP，这是因为GAP相当的简洁高效，但是GAP也有不可忽略的问题，那就是GAP没办法捕获丰富的输入表示，这就导致了经过GAP得到的特征缺乏多样性，这主要是因为GAP对一个通道所有空间元素取其均值，而这个均值其实不足以表达不同通道的信息。
作者对全局平均池化即GAP进行了理论上的分析，最终得出如下结论：首先，不同的通道有极大概率出现相同的均值，然而它们的语义信息是不同的，换句话说，GAP抑制的通道之间的多样性；其次，从频域角度来看，作者证明了GAP其实是离散余弦变换（DCT）的最低频分量，这其实忽略了很多其他有用的分量；最后，CBAM的成功也佐证了只使用GAP得到的信息是不足够的。
在这些结论的基础上，作者设计了一种新的高效多谱通道注意力框架。该框架在GAP是DCT的一种特殊形式的基础上，在频域上推广了GAP通道注意力机制，提出使用有限制的多个频率分量代替只有最低频的GAP。通过集成更多频率分量，不同的信息被提取从而形成一个多谱描述。此外，为了更好进行分量选择，作者设计了一种二阶段特征选择准则，在该准则的帮助下，提出的多谱通道注意力框架达到了SOTA效果。
方法论 通道注意力 通道注意力的权重学习如下式所示，它表示输入经过GAP处理后由全连接层学习并经过Sigmoid激活得到加权的mask。
a t t = sigmoid ⁡ ( f c ( gap ⁡ ( X ) ) ) a t t=\operatorname{sigmoid}(f c(\operatorname{gap}(X))) att=sigmoid(fc(gap(X)))
然后，mask与原始输入经过下式逐通道相乘得到注意力操作后的输出。
X ~ : , i , : , : = a t t i X : , i , : , : , s.t. i ∈ { 0 , 1 , ⋯ , C − 1 } \tilde{X}_{:, i,:,:}=a t t_{i} X_{:, i,:, :}, \text { s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7090ead3b72d0dfd1d2d505e6a5f7333/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29087b86becc3357fdc7bcb02e6a312c/" rel="bookmark">
			剑指 Offer 44. 数字序列中某一位的数字  C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 找规律 我们通过观察，可以发现以下规律：
对于第 n 位对应的数字，我们令这个数字对应的数为 target，然后分三步进行。
首先找到这个数字对应的数是几位数，用 digits 表示；然后确定这个对应的数的数值 target；最后确定返回值是 target 中的哪个数字。 举个栗子：
比如输入的 n 是 365：
经过第一步计算我们可以得到第 365 个数字表示的数是三位数，n=365-9-90\times2=176n=365−9−90×2=176，digtis = 3。这时 n=176n=176 表示目标数字是三位数中的第 176176 个数字。我们设目标数字所在的数为 number，计算得到 number=100+176/3=158number=100+176/3=158，idx 是目标数字在 number 中的索引，如果 idx = 0，表示目标数字是 number 中的最后一个数字。根据步骤2，我们可以计算得到 idx = n % digits = 176 % 3 = 2，说明目标数字应该是 number = 158 中的第二个数字，即输出为 5 class Solution { public: int findNthDigit(int n) { // 计算该数字由几位数字组成，由1位：digits = 1；2位：digits = 2... long base = 9,digits = 1; while (n - base * digits &gt; 0){ n -= base * digits; base *= 10; digits ++; } // 计算真实代表的数字是多少 int idx = n % digits; // 注意由于上面的计算，n现在表示digits位数的第n个数字 if (idx == 0)idx = digits; long number = 1; for (int i = 1;i &lt; digits;i++) number *= 10; number += (idx == digits)?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29087b86becc3357fdc7bcb02e6a312c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d1c97708e7135fe5bc66f2808eaf7e4/" rel="bookmark">
			Java 注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信搜索【NO编程】，关注这个与众不同的公众号。
个人网站：www.newobject.cc
版权声明：本文为原创文章，转载请注明出处。
什么是注解 注解(Annotations)是 Java5 开始提供的功能特性，注解的定义和接口有些相似，最直观感觉就是比接口时多一个 @ 符号。
public @interface MyAnnotation { String value(); } 通过 “@ + 注解名” 来使用注解。
@MyAnnotation(value = "hahaha") public class AnnotationUse { // ... } 那么注解有什么用呢? 注解是用来为类、接口、方法和字段等提供元数据信息，这些信息可以被编译器，开发工具和其他程序等识别，能够在编译和运行时访问元数据信息，然后程序根据这些信息来做一些事情。
例如，编译器根据注解来提示错误和警告信息，文档工具可以通过读取注解生成文档，程序运行时读取元数据(配置信息)来执行某些操作等。
换个方式说，注解就是贴在类上的标签。
打个比方，比如我们去超市买面包，如果把自己看做是运行的程序或编译器，把面包看做 Java 类，面包上的标签就相当于注解，标签上有生产日期，保质期，通过这些标签直接从面包上获得了一些信息，通过读取这些信息我们可以做一些选择或行为，买或者不买，或买几个。注解可以这样理解，就是标签。
商品上有多个标签，不同用途。Java 注解也一样，也可以标注多个注解。
定义注解 通过 @interface 来定义注解，注解里包含方法声明，方法可称为注解元素或属性。
public @interface MyAnnotation { int id(); String value(); // ... } 标记注解 标记注解就是没有任何元素的注解类型，称之为标记注解。
public @interface MyAnnotation { } 单元素注解 具有一个方法元素的注解类型称为单元素注解，单元素注解中唯一元素的名称应该为 value（也可以不为 value, 但 value 在使用时有特殊的约定支持）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d1c97708e7135fe5bc66f2808eaf7e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8016f22d8b5ce2cb0c7cfb43823bd862/" rel="bookmark">
			Nacos 控制台导入配置介绍与踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Nacos 控制台手册 https://nacos.io/zh-cn/docs/console-guide.html
2. 控制台导入配置与踩坑 2.1 配置文件批量导入 一次导入/导出操作只能在一个 namespace 下进行
上次文件只接受压缩包，遇到相同配置文件时，可以选择: 终止导入,跳过，覆盖
压缩包内需要用 group 做为的文件夹名，该文件夹内则存放配置文件
示例: DEFAULT_GROUP
注意: 在 Mac 上进行同样的操作，会发现提示: “导入失败! 未读取到合法数据，请检查导入的数据文件。”
2.2 导入失败时的解决方案: 方案一: 打开mac下的zip文件，发现里面有一个 .DS_store的文件，这个文件nacos读取的时候，会出现异常，所以需要清除 .DS_store 文件，具体步骤
1. 创建 分组 默认为 DEFAULT_GROUP 2. 删除 .DS_STORE（mac平台需要，其他平台可以忽略） 3. 压缩成zip文件 方案二： 使用打包命令
如果不想将.DS_Store或者__MacOSX…或者.svn等等打包进来，可以打开Terminal，输入下面的命令：
&gt; zip -r foo.zip foo -x "*.DS_Store" foo.zip表示生成的文件名，foo表示目标文件或文件夹的路径，-r表示将所有子目录的内容也打包进来，-x后面跟需要被排除的文件名。
方案三： 使用第三方 zip 软件 - 如: macitbetter
https://macitbetter.com/
* 在偏好设置中选中【预置】，然后在【保存】中勾选【从压缩文件中移除特殊Mac文件】即可。 如果依然报错，那么建议检查配置文件的内容是否为空,为空的配置文件将导入失败。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31221ccb0faa418a96f5f3306b883833/" rel="bookmark">
			MSP430第五章：统一时钟系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.介绍 通用时钟系统（UCS）可以让用户在性能与功耗中寻找最佳平衡点，允许用户在外部只有晶振的条件下纯软件配置，其包含5个时钟源：
XT1CLK：低频/高频振荡器，可以使用32768HZ手表晶振、标准晶振、谐振器、4-32MHZ外部时钟源VLOCLK：内部低功耗低频时钟，典型值10KHZ。REFOCLK：内部32768HZ手表晶振，可用作FLL的参考时钟。DCOCLK：内部数控振荡器（DCO），可被FLL稳定。XT2CLK：可选高频振荡器，可用作标准振荡器，共振器、4-32MHZ外部时钟源，也可用作FLL的参考时钟。 3个可用时钟信号：
ACLK：辅助时钟，ACLK可被软件选用源于XT1CLK, REFOCLK, VLOCLK, DCOCLK,DCOCLKDIV 和XT2CLK（如果可用）。可被FLL的1、2、4、8、16、32分频时钟，也可用软件配置为外围模块时钟源。MCLK：主时钟，MCLK可被软件选用源于XT1CLK, REFOCLK, VLOCLK, DCOCLK,DCOCLKDIV 和XT2CLK（如果可用）。可用软件配置为CPU和系统时钟源。SMCLK：子系统主时钟，SMCLK可被软件选用源于XT1CLK, REFOCLK, VLOCLK, DCOCLK,DCOCLKDIV 和XT2CLK（如果可用）。可用软件配置为外围模块时钟源。 2.USC操作 上电复位后，UCS模块默认配置如下：
XT1处于LF模式，XT1供应XT1CLK，XT1CLK供应ALKDCOCLKDIV供应MCLKDCOCLKDIV供应SMCLK锁频环（FLL）开启，FLL选择XT1CLK为参考源XIN和XOUT与通用I/O引脚复用，XT1不可用XT2IN和XT2OUT引脚为通用IO，XT2不可用 2.1 内部低功耗低频率振荡器VLO
VLO不需要晶体提供10KHZ时钟，为超低功耗应用提供时钟来源。当VLO用于ACLK, MCLK, SMCLK（SELA = 1 SELM = 1 SELS = 1）时钟源时启用。
2.2 内部低频参考振荡器REFO
REFO可用作没有振荡器的低成本应用。典型值32.768KHZ，用于稳定DCO频率。REFO结合FLL提供可变范围的系统时钟。不启用不消耗能量。
2.3 XT1振荡器
XT1振荡器支持低频模式（XTS=0）下32768HZ的超低功耗手表频率，手表晶振连接XIN和XOUT，没有其他外部连接。 软件选择XCAP位配置为内部在低频模式下提供负载电容，电容值可选2pF、6pF、9pF、12pF（典型值）。也可以根据晶振要求添加额外的外部电容。
在某些设备中，XT1在高频模式（XTS=1）也支持高速振荡器。高速晶体或谐振器连接XIN和XOUT，并需要在两个终端上外部电容。
2.4 XT2振荡器
XT2与XT1在高频模式参数完全相同
2.5 数控振荡器DCO
DCO能够被DCORSEL, DCO, 和 MOD位配置，也可被FLL稳定频率。通过配置SELREF位，FLL能够接收不同的参考源XT1CLK, REFOCLK, 和 XT2CLK (如果可用) 。n的值被FLLREFDIV位配置（n=1、2、4、8、12、16，默认值是1）
FLLD位配置预分频的值D为1、2、4、8、16和32，默认D=2，MCLK和SMCLK源于DCOCLKDIV。
除法器（N+1）和预分频值D决定DCOCLK和DCOCLKDIV频率。FLLN位配置除法器（N+1）的值，最小N=2，如果无意写入FLLN=0，逻辑上将导致FLLN=1。所以设置FLLN=0和FLLN=1结果相同。
默认FLL开启，设置SCG0和SCG1将其关闭。当FLL关闭时，DCO继续以UCSCTL0和UCSCTL1的配置运行。如果需要可以改变DCO频率，否则其将被FLL稳定。
PUC后DCORSEL = {2}、DCO = {0}，MCLK和SMCLK源于DCOCLKDIV。因为CPU执行代码使用MCLK，而MCLK来自于快速启动的DCO，所以PUC到执行第一行代码所需时间不超过5微秒。
DCOCLK频率通过以下方式设定：
DCORSEL中的3位选择8个DCO频率的其中一个DCO中的5位将上述频率再次分成32个频率，步进约8%MOD中的5位在DCO和下一个更高的频率DCO+1之间切换，当DCO = {31}，MOD位无效，因为DCO已经是范围内最高频率了 2.6 锁频环FLL
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31221ccb0faa418a96f5f3306b883833/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab3e11cf70b1c6002a442b0867c435b6/" rel="bookmark">
			树莓派Pi-hole实操安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树莓派Pi-hole实操安装教程 目录 树莓派Pi-hole实操安装教程前言速览材料 安装方法1（适合在港澳台以及国外的读者）方法2 （适合中国大陆的读者）1. 手动编译FTL2. 下载basic-install.sh的脚本文件3. 在脚本文件中，修改`FTLinstall()` 验证引用 前言 Pi-hole 是一款开源且免费的 DNS 沉洞服务器（DNS sinkhole），能够在不安装任何客户端侧软件的前提下为设备提供网络内容屏蔽服务，非常轻量易用。搭配上家中吃灰已久的树莓派，我们就能够轻松打造属于自己的广告屏蔽助手。1
但我们该如何真正的配置它呢？在实操中会出现很多的问题，下面将为大家带来自己的一点操作流程以及体会。
速览 本文主要参考教程为此网站，并在此网站的基础上为大家排个雷。大家可以边看它边操作，出现的问题可以来对照解决。
材料 树莓派3B x 1笔记本 x 1家用路由器 x 1 安装 首先我们需要将树莓派接入路由器，有线或无线均可，然后远程登录到树莓派上：
（现在默认大家已经来到了ssh或者远程连接的位置。 如果在这方面有所疑惑可以查询树莓派的SSH连接和 Windows远程桌面连接树莓派。
方法1（适合在港澳台以及国外的读者） Pi-hole 提供了一键安装脚本：
curl -sSL https://install.pi-hole.net | bash 当然我们也可以试试，因为这网络啊实在是太太太难成功了……
方法2 （适合中国大陆的读者） 首先提升通过修改hosts或者别的什么途径来提高你连接境外服务器的速度。（请读者自行查阅）做完了第一步后，你会发现……这样下载的网络永远会被FTL给卡断，所以我们查阅Github的官方文档，得到了以下的解决方案： 1. 手动编译FTL Debian / Ubuntu / Raspbian，下载依赖 sudo apt install build-essential libgmp-dev m4 cmake libidn11-dev libreadline-dev 从源文件编译 libnettle wget https://ftp.gnu.org/gnu/nettle/nettle-3.6.tar.gz tar -xzf nettle-3.6.tar.gz cd nettle-3.6 ./configure --libdir=/usr/local/lib make -j $(nproc) sudo make install Clone FTL git clone https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab3e11cf70b1c6002a442b0867c435b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae8fe7bda282c6b312f486249cfe9595/" rel="bookmark">
			Zookeeper基于Java访问-节点事件监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Watcher监听机制是Zookeeper中非常重要的特性，我们基于zookeeper上创建的节点，可以对这些节点绑定监听事件，比如可以监听节点数据变更、节点删除、子节点状态变更等事件，通过这个事件机制，可以基于zookeeper实现分布式锁、集群管理等功能
watcher机制有一个特性：当数据发生改变的时候，那么zookeeper会产生一个watch事件并发送到客户端，但是客户端只会收到一次这样的通知，如果以后这个数据再发生变化，那么之前设置watch的客户端不会再次收到消息。因为他是一次性的；如果要实现永久监听，可以通过循环注册来实现
curator对节点事件监听提供了很完善的api，接下来简单演示一下curator事件监听的基本使用
&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; Curator提供了三种Watcher来监听节点的变化
. PathChildCache：监视一个路径下孩子结点的创建、删除、更新。
. NodeCache：监视当前结点的创建、更新、删除，并将结点的数据缓存在本地。 . TreeCache：PathChildCache和NodeCache的“合体”，监视路径下的创建、更新、删除事件，并缓存路径下所有孩子结点的数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb5987d29ccf73a72b0420ce8c4db5cf/" rel="bookmark">
			公众号获取token失败_关于微信公众号开发的Token验证失败该如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微信公众号开发时需要在公众平台填写服务器配置，其中有一个填写token项，本人在学习过程中出现了验证失败的结果，经上网查阅发现有许多人都出现过这样的问题，现在就此我总结了一些关于填写token时需要注意的事项并简单的介绍一下什么是token，它是用来做什么的：
token其实起到了一个密钥的作用，主要是针对微信服务器和微信后台进行验证的一个密钥用来防止第三方恶意插件的。视频中首先会在微信公众号开发平台上输入你的token值然后进行提交，这一操作主要目的是将你设置的token(服务器token)值发送到微信后台服务器中进行储存，而代码中写的那个String token其实就是你这个公众号将来留在后台的一个token(后台token)，当你在运行时token(服务器token)会和token(后台token)进行比对的，所以俩个token在填写时一定要一致。
下面是填写时需要注意的几个细节：
1.编写的token值绝对要保证独一无二，因为每一个开发的微信平台都会向服务器提交一个token值，这个值会被保存在后台的数据库服务器中，所以你的token一定要保证不能和其他人的token冲突，否则肯定会验证失败。
2.在公众平台填写token时一定要保证前后没有误输入空格。
3.再一个强调的是代码中的token一定要和公众平台上填写的一致。
我认为只要把以上几个问题注意一下在服务器配置中的此项填写时就不会出现错误了，希望寥寥数语可以帮助一些同样遇到此类问题的朋友。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/649872ee831c3c6e594c2aa78c914a04/" rel="bookmark">
			springboot异步和切面_spring中的切面和异步执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先理解异步和多线程的概念，怎么实现接口的异步调用呢？多线程，这是很多人第一眼想到的关键词，没错，多线程就是一种实现异步调用的方式！
2、下面介绍怎么实现异步调用方式
3、首先如果你的项目是springboot项目那么只需要在想要调用的方法上加上异步注解@Async就可以了(前提启动类上要加上启用异步注解的注解@EnableAsync如果不开启那么@Async是无效的)还有一点需要注意：那就是在同一个类里面调用加@Async注解的方法是无效的，举个栗子：在类Test里面有a和b两个发放，b方法加了开启异步注解，这样如果a方法调用b方法异步并没有执行，那么为什么呢？
难道是代码写错了？想起spring对@Transactional注解时也有类似问题，spring扫描时具有@Transactional注解方法的类时，是生成一个代理类，由代理类去开启关闭事务，而在同一个类中，方法调用是在类体内执行的，spring无法截获这个方法调用。
针对这个切面问题要重点聊聊了：
1、首先要知道spring的aop切面的原理是什么？
答：Spring是采用动态代理(AOP)实现对bean的管理和切片，它为我们的每个class生成一个代理对象。只有在代理对象之间进行调用时，可以触发切面逻辑，也就是切面才可以切进去，才能执行切面里编写的代码。
而在同一个class中，方法B调用方法A，调用的是原对象的方法，而不通过代理对象。所以Spring无法切到这次调用。
2、所以想必你大致也明白了为什么在同一个类里面一个方法调用另外一个带有@Async的方法不起作用了，不仅仅是这个，同一个类里面一个方法调用另外一个开启事物(@Transactional)的的方法，事物也是不起作用的。
3、自定义的注解在同一个类里面方法调用也是不起作用的，总的来说同一个类里面总的来说只要是同一个类里面的方法间调用，那么切面都是无效的，aop都无法切入进入，
4、解决办法用AopContext.currentProxy()获取一个代理类，然后用代理类再去调用就好了
代码示例:
@Service
public class CmpActivityServiceImpl implements CmpActivityService {
@Autowired
private ActivityRepository activityRepository;
@Async
@TargetDataSource(DataSourceEnum.CMP_DB)
@Override
public void dynamicDb(Activity activity){
/**
* 获取本对象的代理对象，再进行调用这个类里面的其他方法，那么被调用的那个方法上面如果有切面
* 那么切面就可以生效了，本代码示例就是在开启事物之前先动态切换数据源，
* 这样下面的addCpmActivity上的@Transactional开启事物方法就可以生效了，
* 动态切换数据源要注意一个问题，就是在开启事物之前要先切换成需要的数据源，不要在开启事物
* 之后在切换数据源不然会切换失败，因为一个事物的开启是建立在与一个数据源建立连接的基础上开启的
* 所以如果先开启事物然后再切换数据源会报错，切换会失败
*/
((CmpActivityServiceImpl)AopContext.currentProxy()).addCpmActivity(activity);
}
/**
* 要注意 @Transactional是否是生效的
* @param activity
*/
@Transactional
@Override
public void addCpmActivity(Activity activity) {
}
}
注意：在类中使用AopContext.currentProxy()时会报如下错误：
Cannot find current proxy: Set 'exposeProxy' property on Advised to 'true' to
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/649872ee831c3c6e594c2aa78c914a04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7efe519e151626eb9a8cd9a90ff247c0/" rel="bookmark">
			unc 目录不受支持_DOS批处理不支持将UNC 路径作为当前目录的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话少说，直接上代码，打开网上邻居→整个网络→Microsofi Windows Network→在工作组找到本机对应的电脑，双击测试以下批处理代码：
显示当前目录.bat
cd /d %~dp0
echo %cd%
pushd %~dp0
echo %cd%
popd
pause
可以看到，在开始使用cd命令跳转到UNC目录时，会出现"CMD 不支持将 UNC 路径作为当前目录。"的提示，即cd命令只能在本地目录跳转，却不能跳转到UNC目录。
那如何是好？看第二个命令：pushd，使用"pushd %~dp0"可以将UNC路径映射成本地的Z盘，执行该命令后，下一个提示符就不是原来的C:\&gt;，而是Z:\&gt;，即已经映射成功的UNC路径。
这时，就可以像操作本地目录一样操作UNC目录了(实际上在“我的电脑”中会出现一个Z盘的映射，相当于本地硬盘)。如图中所示，cd、dir等命令均可以使用。
最后，在执行完操作后，别忘了使用popd将映射断开。断开后，提示符又变成了原来的C:\Windows&gt;。
另外一个更好的解决办法：直接在批处理所在的目录前面加上变量%~dp0即可。无论是调用批处理名字，还是拷贝，都可以。
但是要注意，一般地文件共享是只读共享，UNC目录不可写，因此echo &gt;file1.txt这样的语句，fiel1.txt前面不要加%~dp0，默认用C:\windows目录即可。
@echo off
%~dp0bootice\BOOTICEx86 /DEVICE=0 /mbr /install /type=GRUB4DOS /v045 /boot_file=grldr /quiet
echo n|copy /-y %~dp0grub\grldr.* %systemdrive%\
echo n|copy /-y %~dp0grub\menu.lst %systemdrive%\
attrib +h %systemdrive%\grldr.*
attrib +h %systemdrive%\menu.lst
ECHO ┌─────────────────────────────────┐
ECHO │已经把grub4dos写入硬盘MBR! 按任意键退出。 │
ECHO └─────────────────────────────────┘
pause &gt;nul
解决UNC路径不受支持问题 补充
今天在我的win7系统中在一个共享文件路径中执行bat脚本遇到了如下的错误提示：
内容就是：
用作为当前目录的以上路径启动了 CMD.EXE。 UNC 路径不受支持。默认值设为 Windows 目录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7efe519e151626eb9a8cd9a90ff247c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3125c938f547bf4f9fd69196d107cf87/" rel="bookmark">
			crc可以检出奇数个错误_CRC：（循环冗余校验）         循环冗余校验是数据通信领域中最常用的一种差错校验码，主要用来检测或校验数据传输或者保存后可能出现的错误。其特征是信息...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CRC：(循环冗余校验)
循环冗余校验是数据通信领域中最常用的一种差错校验码，主要用来检测或校验数据传输或者保存后可能出现的错误。其特征是信息字段和校验字段的长度可以任意选定。
工作原理：
CRC检错方法的工作原理可以从发送端与接收端两个方面进行描述。
1)发送端将发送数据比特序列当作一个多项式f(x),用双方预先约定的生成多项式G(x)去除，求得一个余数多项式R(x)。将余数多项式加到数据多项式之后，一起发送到接收端。
2)接收端用同样的生成多项式G(x)去除接收到的数据多项式f'(x),得到计算余数R'(x)。如果计算余数多项式R'(x)与接收余数多项式R(x)相同，表示传输无差错；否则，表示传输有差错，通知发送端重传数据，直至正确为止。
eg:
1)发送数据比特序列为：f(x)=110011
2)生成多项式比特序列为：G(x)=11001 (N=5，k=4)
3)将发送数据比特序列乘以2的4次方，即产生的乘积为：1100110000
4)将乘积用生成多项式比特序列去除，按模2算法求得余数为：1001
5)将余数比特序列加到乘积中得：
1 1 0 0 1 1 + 1 0 0 1 = 1 1 0 0 1 1 1 0 0 1
6)如果在数据传输过程中没有发送错误，接收端收到的带有CRC校验码的数据比特序列一定能被相同的生成多项式整除：
CRC的检错能力：
1)能够检查出全部离散的1位错。
2)能够检查出全部离散的2位错。
3)能够检查出全部奇数错。
4)能够检查出全部长度小于或等于k位的突发错。
5)能以[1-(1/2)^(k-1)]的概率检查出长度为k+1位的突发错。
感谢阅读，希望能帮助到大家，谢谢大家对本站的支持！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bbb3fa6935a8899a796a283537606d4/" rel="bookmark">
			前端web worker的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript是单线程的编程语言，当遇到需要处理大量数据的逻辑计算时需要等待代码按照顺序运行，这会导致用户需要等待这段代码执行完后才能对页面进行操作（UI 交互）严重的可能会前端页面卡死的情况发生。
但有一种方式可以避免这种困境，它就是web worker。
web worker 的作用，就是为 JavaScript 创造多线程环境，worker存在于一个不同的线程中，它和主线程互不干扰,这样就可以把处理大量数据的逻辑计算放在worker里，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。
Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。
一、使用web worker 需要注意以下几个点。 （1）同源限制
分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源，如果js文件是在cdn服务上托管的可以把js文件转成字符串。
（2）web worker上下文
worker中的上下文和主线程js的上下文对象是不同的，window不是它的顶层对象，所以window相关的一些方法如alert等时不能使用的，还有dom也是不能访问的。不过基本的方法。例如console.log、navigator、location、setTimeout等可以访问。
（3）通信联系
正如前面提到的，web worker诞生的目的在于解决耗时操作对ui交互的影响，worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。
（4）文件限制
worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。
(5) worker使用node_modules中的依赖
worker如果需要使用node_modules中的依赖,可以使用worker-loader或workerize-loader来处理。
二、worker的基本使用 主线程js
// 引入worker脚本文件 const worker = new Worker('worker.js'); // 监听message事件 worker.addEventListener('message', (event) =&gt; { console.log(event.data); }); const data = { title: '有大量数据需要处理', num: 60, } /* * worker.postMessage()方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。 /* // 发送消息 //转成JSON字符串 worker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bbb3fa6935a8899a796a283537606d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965fd47dfe991d41895a667cee7f9831/" rel="bookmark">
			chunk rtmp 帧_LibRTMP库优化之调整输出块大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 为什么要调整输出块大小
首先在RTMP_Connect0函数中LibRTMP是关闭了Nagle算法这个TCP选项的，为了实时性这样做是好的，但是要注意到LibRTMP的结构体RTMP的成员是有m_outChunkSize，并且在RTMP_Init函数中被初始化了默认值128，然后整个LibRTMP代码没有改变m_outChunkSize的接口函数，内部也没有改变m_outChunkSize的实现逻辑，也没有发送改变块大小的消息给流媒体服务器的代码逻辑，关闭Nagle加如此小的块大小会导致很多小包，而以太网的MTU是1500，这样如果用在播放客户端由于主要是接收媒体流到也没有什么，但是如果用在发布媒体流的推流客户端网络效率就太低了，并且IP小包太多还会引起流媒体的服务器软中断升高，导致内核占用的CPU过高。m_outChunkSize在发送给流媒体服务器消息会用于分块，所以从这个方面来说LibRTMP还是部分支持改变块大小的，这部分逻辑实现不需要任何改变。
2. 调整输出块大小的函数
static int
ChangeChunkSize(RTMP *r,int outChunkSize)
{
RTMPPacket packet;
char pbuf[RTMP_MAX_HEADER_SIZE + 4];
packet.m_nBytesRead = 0;
packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
packet.m_packetType = RTMP_PACKET_TYPE_CHUNK_SIZE;
packet.m_nChannel = 0x04;
packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
packet.m_nTimeStamp = 0;
packet.m_nInfoField2 = 0;
packet.m_hasAbsTimestamp = 0;
packet.m_nBodySize = 4;
r-&gt;m_outChunkSize = outChunkSize;
r-&gt;m_outChunkSize = htonl(r-&gt;m_outChunkSize);
memcpy(packet.m_body, &amp;r-&gt;m_outChunkSize, 4);
r-&gt;m_outChunkSize = ntohl(r-&gt;m_outChunkSize);
return RTMP_SendPacket(r, &amp;packet, TRUE);
}
注1：RTMP协议的消息类型01(RTMP_PACKET_TYPE_CHUNK_SIZE宏的值)就是用于改变输出块大小的消息类型，结合MTU
注2：outChunkSize大小可以选择1500-20(IP头)-20(TCP头)=1460，考虑到IP头、TCP头有扩展选项，加之PPPoE，为保证起见可选为1360，也可以设为大于MTU的其它值，不过这样的话就会出现IP分片了，也不是好习惯。
注3：每当调用本函数后就顺便修改了RTMP的成员变量m_outChunkSize，以保持与服务器收到的一致。
3. 调用调整输出块大小的函数的时机
随时可以调整，只不过在调用ChangeChunkSize函数后，要注意到这个函数内部已经改变了RTMP的成员变量m_outChunkSize，这样在调用这个函数之后的所有发给流媒体服务器的消息要以这个块大小来分块，由于TCP的有序性，服务器在收到该改变块大小的消息后也会以此块大小来解析后序的所有消息，由于播放客户端主要是拉流，播放端需要传给服务器的数据不多，可以不修改，基于此可以在收到connect的响应后的处理逻辑中调用ChangeChunkSize函数，具体如下(HandleInvoke函数中部分代码)：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/965fd47dfe991d41895a667cee7f9831/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/388/">«</a>
	<span class="pagination__item pagination__item--current">389/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/390/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>