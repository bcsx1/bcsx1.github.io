<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d87630618f4be58adbcd91b62bdec22/" rel="bookmark">
			vue父组件监听子组件生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 还是记一下吧，总是忘！
通过在子组件生命周期里公开一个事件，通过父组件监听： // 在子组件中 mounted(){ this.$emit('mounted','mounted 触发了') }, // 父组件监听 &lt;child-component @mounted="handleDoSomething"&gt;&lt;/child-component&gt; vue2中的@hook事件监听 &lt;child-component @hook:mounted="handleDoSomething"&gt;&lt;/child-component&gt; vue3中类似上面的@hook@vue:mounted="jhMounted" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cfcef2648cde01e071090dcde64b555/" rel="bookmark">
			linux--expect用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们通过Shell可以实现简单的控制流功能，如：循环、判断等。但是对于需要交互的场合则必须通过人工来干预，这时候就用到了expect。
举例： 1、复制本地文件到服务器中，此时会要求先确认再输入密码（先输入“yes”再输入密码），如下图
2、设置jdk版本时sudo update-alternatives --config java，需要输入序号选择JDK版本，如下图
使用步骤： 1、安装expect
sudo apt-get install expect
2、创建一个.sh后缀的文件
3、编辑文件，文件开头申明，标识脚本使用的Shell解释器类型为expect：
#! /usr/bin/expect
4、接收文件执行时命令行传参，并定义变量：
set jdk_command [lindex $argv 0]
set jdk_version [lindex $argv 1]
5、使用spawn执行命令：
spawn sudo update-alternatives --config $jdk_command
6、交互开始，检查交互提示行：
expect "type selection number:"
7、交互行输入
send "$jdk_version\r"
8、结束本次交互
expect eof
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeb35a029da3e8e8cd3acb0e6b650c6e/" rel="bookmark">
			自定义View控件流程是怎样的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方自定义控件流程 根据Android Developers官网的介绍，自定义控件需要以下步骤。（根据业务需要，某些步骤可省略） 1、创建View2、处理View的布局3、绘制View4、与用户进行交互5、优化已定义的View 上面五项就是Android官方给出的自定义控件步骤。 每个步骤里面又包括了很多细小的知识点。可以记住这五个点，并且了解每个点里包含的小知识点。再加上一些自定义控件的练习。将这些知识熟练于心，相信开发者都能够定义出优秀的自定义控件。接下来对上面列出的5个要点进行细化阐述。 创建View 继承View 自定义的View是继承于View，当然如要自定义的View拥有某些Android已经提供的控件功能，可直接继承于已经提供的控件。 重写构造方法 Xxx(Context context)Xxx(Context context, AttributeSet attrs)Xxx(Context context, AttributeSet attrs, int defStyleAttr) 定义自定义属性 自定义属性通常写在res/values/attrs.xml文件中。声明自定义属性，都属于styleable，一般styleable的name和自定义控件的类名一样。 获取自定义属性 当在xml中创建一个view时，所有在xml中声明的属性都会被传入到view的构造方法中的AttributeSet类型的参数当中。通过调用Context的obtainStyledAttributes()方法返回一个TypedArray对象。然后直接用TypedArray对象获取自定义属性的值。TypedArray对象是共享的资源，因此在获取完值之后必须要调用recycle()方法来回收。 测量View(Measure) 测量
一个View在展示时是有宽和高，测量View就是为了能够让自定义的控件能够根据各种不同的情况以合适的宽高去展示。测量就必须要提到onMeasure方法。onMeasure方法是一个view确定宽高的地方。 重写onMeasure的固定伪代码写法：```
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
int measureWidth = measure(widthMeasureSpec, true);
int measureHeight = measure(heightMeasureSpec, false);
setMeasuredDimension(measureWidth, measureHeight);
}
* 计算出height和width之后在onMeasure中要调用setMeasuredDimension()方法。否则会出现运行时异常。 计算一些自定义控件需要的值 onSizeChange()
onSizeChange() 方法在view第一次被指定了大小值、或者view的大小发生改变时会被调用。 绘制View(Draw) 自定义控件被创建并且测量代码写好后，接下来就调用onDraw()来绘制View onDraw方法包含一个Canvas叫做画布的参数，onDraw()简单来说就两点：Canvas决定要去画什么；Paint决定怎么画Canvas提供了画线方法，Paint就来决定线的颜色。Canvas提供了画矩形，Paint又可以决定让矩形是空心还是实心。 在onDraw方法中开始绘制之前 画笔Paint对象信息要初始化完毕。因为View的重新绘制是比较频繁的，可能多次调用onDraw，所以初始化的代码不应该放在onDraw方法里。 Paint画笔 在绘图过程中起到了极其重要的作用，画笔主要保存颜色，样式等绘制信息，指定如何绘制文本和图形，画笔对象有很多设置方法，大体上可以分为两类，一类与图形绘制相关，一类与文本绘制相关。 Canvas画布 当调整好画笔之后，需要绘制到画布上，这就得用Canvas类。Canvas画布可以绘制任何东西。还需要设置一些关于画布的属性，比如，画布的颜色、尺寸等。 常见绘制操作有哪些 drawRect，drawRoundRect，绘制矩形drawOval，drawCircle，drawArc：绘制椭圆，圆，以及圆弧drawText：绘制文本drawBitmap：绘制图片 Rect和RectF介绍和区别 Rect的参数为int类型，而RectF的参数类型为float类型，从这一点上来看，RectF的精度更高一些，但是他们都是通过四个坐标参数来确定一个矩形的区域。 与用户进行交互 某些情况自定义控件不仅只是展示漂亮的样式，还需要支持用户点击，拖动操作。自定义控件就需要做用户交互这一步。在Android系统中最常见的事件就是触摸事件，会调用View的onTouchEvent(android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeb35a029da3e8e8cd3acb0e6b650c6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47f7662e878daf10046a6a89aa5beaa0/" rel="bookmark">
			IDEA缩放代码快捷键设置/IDEA代码字体大小调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在IDEA需要进行代码的缩放，为了方便进行了快捷键设置：`ctrl` + `向上/向下滚动滚轮` 进行字体的缩放：
首先进入文件，找到设置：
然后找到按键映射(keymap) ，搜索increase和decrease(也可以直接搜索font直接就都出来了)，这里以增加字体大小举例：
右键点击增加字体大小(Increase Font Size) -&gt; 添加鼠标快捷方式
输入自己的快捷键后单击"确定"，最后点击"应用"-&gt;"确定"即可。
缩放一样就略过了~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c596a1e1e4cae7ad651124af462e28e1/" rel="bookmark">
			Pinia的使用、Pinia的持久化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Pinia： Pinia 是 Vue 的存储库，它允许跨组件/页面共享状态。pinia是Vuex的升级版 目录
什么是Pinia： Pinia 是 Vue 的存储库，它允许跨组件/页面共享状态。pinia是Vuex的升级版
一.Pinia的使用 1.在项目中安装Pinia 2.引入使用
3.Pinia模块创建
4.在页面中使用 5.pinia修改state数据的方法：
1.修改 store对象的数据：
2.$patch传递一个对象来修改
3. $patch传递一个函数来修改：
4. actions里修改：
二. Pinia持久化
一.Pinia的使用 1.在项目中安装Pinia # 使用 yarn yarn add pinia # 使用 npm npm install pinia 2.引入使用 vue3引入写法：
# main.js或main.ts import { createApp } from 'vue' import App from './App.vue' import { createPinia } from 'pinia'; const app = createApp(App); const pinia = createPinia(); app.use(pinia); app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c596a1e1e4cae7ad651124af462e28e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e5868d3c06d9a8567e70fe4f76dfdb9/" rel="bookmark">
			Redis系列--数据过期清除策略&amp;缓存淘汰策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、过期策略 一、前言 Redis 所有的数据结构都可以设置过期时间，时间一到，就会自动删除。可以想象里面有一个专门删除过期数据的线程，数据已过期就立马删除。这个时候可以思考一下，会不会因为同一时间太多的 key 过期，以至于线程忙不过来。同时因为 Redis 是单线程的，删除的时间也会占用线程的处理时间，如果删除的太过于繁忙，会不会导致线上读写指令出现卡顿。
二、立即删除 它会在设置键的过期时间的同时，创建一个定时器， 当键到了过期时间，定时器会立即对键进行删除。 这个策略能够保证过期键的尽快删除，快速释放内存空间。
1、优点： 立即删除能保证内存中数据的最大新鲜度，因为它保证过期键值会在过期后马上被删除，其所占用的内存也会随之释放。对内存来说是非常友好的。
2、缺点： 立即删除对cpu是最不友好的。因为删除操作会占用cpu的时间，如果刚好碰上了cpu很忙的时候，比如正在做交集或排序等计算的时候，就会给cpu造成额外的压力。
3、总结：立即删除对cpu不友好，但是对内存友好，实际性质就是用处理器性能换区内存空间。 三、惰性删除 数据到达过期时间，不做处理。等下次访问该数据时，如果未过期，返回数据 ；发现已过期，删除，返回不存在。
开启惰性删除：lazyfree-lazy-eviction=yes
1、优点 ： 对于cpu来说是非常友好的，减少了cpu资源的占有。
2、缺点： 如果一个键已经过期，而这个键又仍然保留在redis中，那么只要这个过期键不被删除，它所占用的内存就不会释放。因此对于内存是很不友好的。
在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除(除非用户手动执行FLUSHDB)，我们甚至可以将这种情况看作是一种内存泄漏–无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说,肯定不是一个好消息
四、定期删除 定期删除策略是前两种策略的折中：
定期删除策略每隔一段时间执行一次删除过期键操作并通过限制删除操作执行时长和频率来减少删除操作对CPU时间的影响。
1、过期key的集合 redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定时遍历这个 字典来删除到期的 key。除了定时遍历之外，它还会使用惰性策略来删除过期的 key。定期删除是集中处理，惰性删除是零散处理。
2、定时扫描策略 Redis 默认会每秒进行十次过期扫描，过期扫描不会遍历过期字典中所有的 key，而是 采用了一种简单的贪心策略。
1、从过期字典中随机 20 个 key；
2、删除这 20 个 key 中已经过期的 key；
3、如果过期的 key 比率超过 1/4，那就重复步骤 1；
于此同时为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。
而这就会出现一种需要特别注意的情况：
设想一个大型的 Redis 实例中所有的 key 在同一时间过期了。Redis 会持续扫描过期字典 (循环多次)，直到过期字典中过期的 key 变得稀 疏，才会停止 (循环次数明显下降)。这就会导致线上读写请求出现明显的卡顿现象。导致这 种卡顿的另外一种原因是内存管理器需要频繁回收内存页，这也会产生一定的 CPU 消耗。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e5868d3c06d9a8567e70fe4f76dfdb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86b471191b56ccc306509e7a8ae4aff7/" rel="bookmark">
			JavaFx教程_编程入门自学教程_菜鸟教程-免费教程分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 教程简介 JavaFX 是一个 Java 库，用于开发桌面应用程序以及富 Internet 应用程序 (RIA)。在 JavaFX 中构建的应用程序可以在多个平台上运行，包括 Web、移动和桌面。
JavaFX 旨在取代 Java 应用程序中的 swing 作为 GUI 框架。但是，它提供了比摆动更多的功能。与 Swing 一样，JavaFX 也提供自己的组件并且不依赖于操作系统。它是轻量级和硬件加速的。它支持各种操作系统，包括 Windows、Linux 和 Mac OS。
JavaFX入门教程 - 从基本到高级概念的简单步骤了解JavaFX，其中包括概述，环境，架构，应用程序，2D形状，文本，效果，转换，动画，颜色，图像，3D形状，事件处理， UI控件，图表，布局窗格，CSS。
教程目录 JavaFX教程JavaFX - 概述JavaFX - 环境JavaFX - 架构JavaFX - 应用程序JavaFX - 2D形状JavaFX - TextJavaFX - EffectsJavaFX - TransformationsJavaFX - 动画JavaFX - 颜色JavaFX - 图像JavaFX - 3D形状JavaFX - 事件处理JavaFX - UI控件JavaFX - 图表JavaFX - 布局窗格（容器）JavaFX - CSSJavaFX - 有用的资源 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/533eebbdc14bf8ee030ea11d329fae95/" rel="bookmark">
			【项目复盘vue2&#43;ts】el-table某些列多行文本超过多少行显示...并且鼠标移入能显示文本全部
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图
效果：el-table中某几列文本过长，又不想用el-tooltip显示全部。涉及区域列文本超过两行显示...，涉及部门列文本超过三行显示...，鼠标移入时用html原生标签的title属性可以显示该单元格全部文本内容
实现思路： 1.判断溢出需要显示...的列，用v-if + slot-scope做处理
2.鼠标移入显示全部文本需要用到html的title属性
3.computed动态绑定css
&lt;el-table-column v-for="item in tableProps" :key="item.prop" :prop="item.prop" :label="item.label" align="center"&gt; &lt;template slot-scope="scope"&gt; &lt;div v-if="item.label === '涉及区域' || item.label === '涉及部门'" :title="scope.row[item.prop] ? scope.row[item.prop] : ''" :class="isEllipsis(item)"&gt; {{ scope.row[item.prop] }} &lt;/div&gt; &lt;div v-else&gt; {{ scope.row[item.prop] }} &lt;/div&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;script lang="ts"&gt; import Vue from 'vue' import { Component, Ref } from 'vue-property-decorator' // 引入装饰器 // 在Vue2的ts里面在方法前面写get就是计算属性 get isEllipsis() { return function (item:any) { let className:string[] = [] if(item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/533eebbdc14bf8ee030ea11d329fae95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f9de337d049746aa9f265c7eb9d6501/" rel="bookmark">
			JAVA 接收JSON数据，并进行转换处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常业务中经常需要与外部系统交互处理数据，在此文章中记录一下我在项目中处理json数据流程。
第一种以实体类处理
以文档中的数据结构构建实体类，使字段与需要接收转换的JSON字段变量名尽量保持一致，如果不一致，则会获取不到变量的数值，也可以使用 @JsonProperty(value = “json变量名”)标注在字段上，通过注解来进行转换。
controller方法接收json数据
(@RequestBody XXX xxx)
将实体类转换成json字符串
将json字符串转换成对象或集合（需要根据自己接收到的参数选择转换的类型），然后获取字段调用对象的get方法即可。 String jsonString =接收到的json字符串
XXX xxx= JSONArray.parseObject(jsonString, XXX.class);//转换成对象
List&lt;XXX &gt; xxxs = JSONObject.parseArray(jsonString, XXX .class)//转换成集合
ChangeMeterRecord changeMeterRecord = JSONObject.parseObject(json, ChangeMeterRecord.class);
SwitchingTable switchingTable = JSONObject.parseObject(json2, SwitchingTable.class); 我是操作的集合
Map data = new HashMap(); data.put("newManufacturer",changeMeterRecord.getNewManufacturer()); data.put("newTableName",changeMeterRecord.getNewTableName()); data.put("newModel",changeMeterRecord.getNewModel()); data.put("newMeterNum",changeMeterRecord.getNewMeterNum()); data.put("newDirection",changeMeterRecord.getNewDirection()); data.put("newMeterOrigin",changeMeterRecord.getNewMeterOrigin()); data.put("newMeterFlow",changeMeterRecord.getNewMeterFlow()); data.put("newDigits",changeMeterRecord.getNewDigits()); data.put("newCardSubnumber",changeMeterRecord.getNewCardSubnumber()); data.put("changeReason",changeMeterRecord.getChangeReason()); data.put("originalReading",changeMeterRecord.getOriginalReading()); data.put("newReading",changeMeterRecord.getNewReading()); data.put("repairGasCost",changeMeterRecord.getRepairGasCost()); data.put("newSeal",changeMeterRecord.getNewSeal()); data.put("remark",changeMeterRecord.getRemark()); data.put("changedate", formatter.format(date)); 第二种以JSONObject处理 接收数据
@RequestMapping(value = "/insertOutside",method=RequestMethod.POST)
public void insertOutside(@RequestBody JSONObject jsonObject)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f9de337d049746aa9f265c7eb9d6501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c7daa613708674d08810954bc7f35c8/" rel="bookmark">
			flask 使用paddlenlp taskflow 报错 RuntimeError No root path can be found for the provided module mp_main
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flask 使用paddlenlp taskflow 报错 RuntimeError :No root path can be found for the provided module “mp_main” 使用多进程来搭建taskflow抽取信息的时候报错。
翻译以下，所提供的"mp_main"模块中找不到根路径，这可能是因为该模块来自于一个没有提供文件名信息的引用，或者是一个命名空间包。在这种情况下，需要明确提供根路径。
看到这个报错，开始有点儿方，刚开始以为是
if __name__ == '__main__': 写错了，但检查了之后发现没有问题。跟新代码前，开多进程是没有问题的，加了一个taskflow的信息提取就出问题了，猜测是taskflow这个命名和flask里面的冲突了（但flask 官网搜了下并没有taskflow这个函数），也没有安装 taskflow这个包。
from paddlenlp import Taskflow form paddlenlp import Taskflow as pdtf 改了依然报错。注释掉包含taskflow的进程，引用文件中包含对Taskflow的引用也会报错。
网上相关的信息基本没有，有一个plotly社区，关于dash with multiprocessing的问题，链接
报了同样的错误，然后大致看了下帖子。
提问者认为，是因为win中没有forking的问题，并找到了引起该问题所引用的两个scypi包，而除这两个包之外的其他scypi包则没问题。
有大佬回复说，这可能是win缺乏forking，在多进程的时候，创建新的进程需要重新引用父模块，但不使用main。（我对这方面也懂的很少，没咋明白这到底怎么回事）
我代码里面是直接创建多进程，并没有用进程池。
然后在paddlenlp github 的issues里面找到这个：链接
该问题是关于使用Taskflow 多进程卡死的，跟我这个好像也没啥关系，毕竟，我这个服务都启不起来。
paddle方回复，可以使用spawn的形式尝试，我没试这个。
另一个网友回复，把引用写在进程内部就可以解决。我试了下，这个确实可以。
但还有个问题，这个网友说，使用cpu的时候，使用多进程是没有问题的，只有使用gpu才有问题。而我用的就是cpu，依然有这个问题。
可能和cpu，gpu没太大关系，只是和多进程有关。参考链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9489f22c74777b63dee47d297a8605aa/" rel="bookmark">
			Ubuntu安装apex
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#安装apex混合精度工具 git clone https://github.com/NVIDIA/apex cd apex python setup.py install 出现报错：
torch.__version__ = 1.8.1+cu101
Traceback (most recent call last):
File "setup.py", line 136, in &lt;module&gt;
_, bare_metal_version = get_cuda_bare_metal_version(CUDA_HOME)
File "setup.py", line 23, in get_cuda_bare_metal_version
raw_output = subprocess.check_output([cuda_dir + "/bin/nvcc", "-V"], universal_newlines=True)
TypeError: unsupported operand type(s) for +: 'NoneType' and 'str'
可能是nvcc还没有安装
conda install -c nvidia cuda-nvcc 再执行安装步骤：
python setup.py install 即可成功安装
.....
Finished processing dependencies for apex==0.1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/290b814e3bf46d8f131fda1d71f47815/" rel="bookmark">
			Python桌面应用开发之PyQt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言：桌面应用开发三大框架介绍一、PyQT介绍二、安装三、使用教程(1)基础窗口(2)分区布局窗口(类似于html中div的使用)(3)栅格布局窗口(类似于html中的table)(4)表单布局窗口(类似于html中的form)(5)事件函数与事件过滤器(6)信号和槽四、实战示例(1)状态栏（追踪鼠标移动轨迹）(2)菜单栏(3)工具栏(4)对话框(5)相册(6)计算器(7)秒表(8)嵌入浏览器或其他windows应用5.图形化界面Qt Designer(1)安装(2)基础控件(3)使用教程 引言：桌面应用开发三大框架介绍 Tkinter：优势是免安装、相对简单，缺点是功能少，无界面设计工具。
PyQT：使用率高，功能最为强大，代码可维护性和易读性高。
WxPython：介于Tkinter和PyQT之间，相当于压缩版QT。
总结：三种框架各有优劣，有时间可以全部学习，并不复杂。如果只选一种，这里推荐使用最主流、最保值、上限最高的PyQT。
一、PyQT介绍 Qt：Qt是一个跨平台的C++图形用户界面应用程序开发框架，目前已成为最强大，最受欢迎的跨平台GUI库之一。Qt不仅可以开发GUI程序，也可开发非GUI程序，比如控制台工具和服务程序。
PyQt：PyQt是Qt的Python封装，提供Qt类和函数的API。
PyQt6的官网：https://www.riverbankcomputing.co.uk/news
可以参考的中文手册：https://www.syrr.cn/news/415861.html?action=onClick
PyQt常用模块：
QtWidgets模块：包含应用程序类、窗口类、控件类和组件类
QtGui模块：包含和gui相关的功能，例如用于事件处理、图像处理、字体和颜色类等
QtCore模块：包含核心的非gui功能，例如线程、定时器、日期时间类、文件类等
二、安装 安装：pip install PyQt6
检查安装版本(进入python命令行)：
from PyQt6.QtCore import QT_VERSION_STR, PYQT_VERSION_STR QT_VERSION_STR, PYQT_VERSION_STR 三、使用教程 (1)基础窗口 import sys from PyQt6.QtWidgets import QApplication, QWidget, QLabel from PyQt6.QtGui import QIcon, QFont from PyQt6.QtCore import Qt #从QWidget类派生的桌面应用程序窗口类 class MyWindow(QWidget): #QtWidgets模块：包含应用程序类、窗口类、控件类和组件类 #构造函数 def __init__(self): super().__init__() # 调用基类的构造函数 self.setWindowTitle('Hello World') # 设置标题 #self.setWindowIcon(QIcon('res/qt.png')) # 可以设置图标 lab = QLabel('Hello World', self) # 实例化标签 lab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/290b814e3bf46d8f131fda1d71f47815/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f75018f73a3ec85f63ce5fc81dd23e5a/" rel="bookmark">
			Linux服务器部署工程（柳州职业技术学院）电信院22级工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux服务器部署工程 组长：蒋文毅 组员：蒋文毅、覃黎国、赖佳俊、潘苗康、龙博文、韦晴
指导老师：黄光明
目录 目录
Linux服务器部署工程项目... 0
目录... 1
1学习项目：... 2
1.1 项目背景... 2
1.2项目要求... 2
1.3项目分工... 3
2工程的实施步骤... 4
2.1Linux系统上硬盘挂载与用户管理操作。... 4
2.2 Linux系统上的用户宿主目录设置。... 5
2.3部署DHCP服务器，IP地址分配。... 5
2.4FTP服务器的部署及学生FTP服务。... 6
2.5 部署WEB服务器，网页服务。... 7
2.6定时备份学生作业文件。... 8
3项目成果和效果... 9
3.1Linux系统上硬盘挂载与用户管理操作。... 9
3.2Linux系统上的用户宿主目录设置。... 11
3.3部署DHCP服务器，IP地址分配。... 12
3.4FTP服务器的部署及学生FTP服务。... 16
3.5部署WEB服务器，网页服务。... 21
3.6定时备份学生作业文件。... 24
4学习心得：... 25
4.1蒋文毅... 25
4.2覃黎国... 27
4.3赖佳俊... 29
4.4潘苗康... 30
4.5韦晴... 32
4.6龙博文... 34
5总结... 36
5.1总结... 36
5.2展望... 36
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f75018f73a3ec85f63ce5fc81dd23e5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bad93b5ffd4f8641c2ea46581f97a22a/" rel="bookmark">
			Android Hidl开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、环境准备
首先准备一份Android源码。
#源码中编译生成hidl-gen
make hidl-gen
下面是hidl-gen的语法：
usage: hidl-gen [-p &lt;root path&gt;] -o &lt;output path&gt; -L &lt;language&gt; [-O &lt;owner&gt;] (-r &lt;interface root&gt;)+ [-R] [-v] [-d &lt;depfile&gt;] FQNAME...
Process FQNAME, PACKAGE(.SUBPACKAGE)*@[0-9]+.[0-9]+(::TYPE)?, to create output.
-h: Prints this menu.
-L &lt;language&gt;: The following options are available:
check : Parses the interface to see if valid but doesn't write any files.
c++ : (internal) (deprecated) Generates C++ interface files for talking to HIDL interfaces.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bad93b5ffd4f8641c2ea46581f97a22a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/489527c5c65c4f3078cc2c980c75b7d1/" rel="bookmark">
			autoprefixer: end value has mixed support, consider using flex-en
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode 控制台报错，浏览器控制台没有报错
解决：
// justify-content:end; justify-content: flex-end; 全局去查找 justify-content:end;
换成 justify-content: flex-end;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1da8060107fc325482a7a3848d17c931/" rel="bookmark">
			iview ui vue2.0 radio 点击选中状态后取消选中状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;RadioGroup v-model="formData.deficiencyType"&gt; &lt;Radio label="1" :disabled="modalType=='C'?true:false" @click.native="cancelSelection(1)"&gt;1&lt;/Radio&gt; &lt;Radio label="2" :disabled="modalType=='C'?true:false" @click.native="cancelSelection(2)"&gt;2&lt;/Radio&gt; &lt;/RadioGroup&gt; method: cancelSelection(selectedLabel) { if(this.modalType === 'U'){ if (this.formData.deficiencyType == selectedLabel) { this.formData.deficiencyType = ''; console.log(" this.formData.deficiencyType1: " + this.formData.deficiencyType); }else{ this.formData.deficiencyType=selectedLabel } } console.log(" this.formData.deficiencyType: " + this.formData.deficiencyType); }, 点击红框中的区域可以取消选中状态
但是点击数字这块区域就不行，
上面方法中 把this.formData.deficiencyType 重置为'',但最后输出打印还是1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f0fba4a454867a4f3c0609d78e7377b/" rel="bookmark">
			python生成矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.生成都是1的对角矩阵
a = np.eye(27,k=0) print(a) 2.生成全1矩阵
# 创建全是1的矩阵（此时矩阵元素类型为float64类型） a = np.ones(shape=(4,5)) print(a) # 创建全是0的ndarray b = np.zeros(shape=(3,4)) print(b) #一种公用的方法：（此时矩阵元素为整型） c = np.full(shape=(4,5),fill_value=8) print(c) 3.元素非0矩阵，实现对角位置为0
for i in range(0, n): for j in range(0, n): if i == j: dis[i,j] = 0 print(dis) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e9b605476dcfca9642a15c7f6b98443/" rel="bookmark">
			Ubuntu 22.04上安装NFS服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用如下命令安装NFS服务端软件：
# 在主机上运行以下命令 orangepi@orangepi5:~$ sudo apt install nfs-server 2、在配置NFS时需要使用用户uid和组gid，可以使用id命令查看
# 在主机上运行id命令 orangepi@orangepi5:~$ id uid=1000(orangepi) gid=1000(orangepi) groups=1000(orangepi),5(tty),6(disk),20(dialout),27(sudo),29(audio),44(video),46(plugdev),60(games),100(users),101(systemd-journal),106(input),111(netdev),122(bluetooth),999(docker) 可以发现主机用户的uid和gid均为1000，在下面配置文件中会使用到。
3、配置NFS
安装NFS服务后，会新增一个/etc/exports文件(即/etc/目录下名为exports的文件)，NFS服务根据它的配置来运行。
用vim打开/etc/exports文件命令如下：
orangepi@orangepi5:~$ sudo vim /etc/exports 在/etc/exports文件末尾添加如下语句并且保存：
# 以下内容添加到/etc/exports文件末尾，IP地址和uid，guid需要根据自己的环境仅限修改 /home/orangepi/nfs 192.168.50.0/24(rw,sync,all_squash,anonuid=1000,anongid=1000,no_subtree_check) 以上内容注释：
/home/orangepi/nfs：需要共享的主机目录，注意使用空格与后面的配置隔开。192.168.50.0/24：配置哪个网段或主机可以访问，其中/24是掩码，此处表示24个1，即掩码是255.255.255.0。结合前面192.168.50.0表示此处配置IP为192.168.50.*的主机均可以访问该目录，即192.168.50.*网段局域网上的所有主机。rw：表示客户机的权限，rw表示可读写。具体的授权还受到文件系统的rwx及用户身份影响。sync：资料同步写入到内存与磁盘中。anonuid=1000：将客户机上的用户映射成指定的本地用户ID的用户，此处1000是主机oprangepi用户的uid，此处请根据具体的主机用户uid进行配置。anongid=100：将客户机上的用户映射成属于指定的本地用户组ID，此处1000是主机orangepi用户组gid。此处请根据具体的主机用户组gid进行配置。no_subtree_check：不检查子目录权限，默认配置。 本配置中的anonuid和anongid把客户机的用户映射成本地uid/gid为1000的用户，即主机orangepi，那么当在客户机上使用与主机不同的用户访问NFS共享目录时，都会有orangepi的权限。
4、创建共享目录
为了确保共享的配置有效，还需要创建共享的目录，本例中为/home/orangepi/workdir。
# 在主机上运行以下命令 orangepi@orangepi5:~$ mkdir /home/orangepi/nfs 5、更新exports配置
修改完/etc/exports文件并且保存后，可使用exportfs命令更新配置：
# 在主机上运行以下命令 orangepi@orangepi5:~$ sudo exportfs -arv [sudo] password for orangepi: exporting 192.168.50.0/24:/home/orangepi/nfs 该命令的参数说明：
-a：全部mount或umount文件/etc/exports中的内容-r：重新mount文件/etc/exports中的共享内容。-u：umount目录。-v：在exportfs的时候，将详细的信息输出到屏幕上。 6、查看NFS共享情况
使用showmount -e可查看当前NFS服务器的加载情况。
orangepi@orangepi5:~$ showmount -e Export list for orangepi5: /home/orangepi/nfs 192.168.50.0/24 7、安装NFS客户端
主机开启NFS服务后，在同一局域网内的另一台主机上安装NFS客户端，执行以下命令安装NFS客户端命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e9b605476dcfca9642a15c7f6b98443/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4b923e497e03f1150d07a6e1312910b/" rel="bookmark">
			使用conda虚拟环境，Jupyter Notebook 链接不上 kernel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1，检查 ipykernel 和 ipython 是否一致
输入pip list 或者conda list检查一下相应库的版本是不一致
不一致的话，可以更新这两个库的版本：pip install --upgrade 库名
2，看控制台的报错，如果是报404，内核找不到，这个可能是目前内核名称已经和现在不一致，需要进行内核注册。
python -m ipykernel install --user --name=ame --display-name "ame-new" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a841565792dff20a55c45a5f00ed58dc/" rel="bookmark">
			基于Java&#43;SpringBoot&#43;vue学生学习平台详细设计实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝20W+,csdn特邀作者、博客专家、CSDN新星计划导师、java领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和毕业设计项目实战✌
🍅文末获取联系🍅
精彩专栏推荐👇🏻👇🏻👇🏻👇🏻
java项目精品实战案例《100套》https://blog.csdn.net/weixin_39709134/category_11128297.html?spm=1001.2014.3001.54822022Java项目设计参考题目值得收藏https://blog.csdn.net/weixin_39709134/article/details/126371520?spm=1001.2014.3001.5501
目录
一、前言介绍：
二、系统设计：
2.1 BS模式结构：
2.2 系统整体架构图：
2.3 系统功能结构图：
三、数据设计：
四、功能截图： 4.1 前端首页功能模块：
4.1.1 用户前端首页：
4.1.2 课程信息：
4.1.3 课程详情模块​
4.1.4 作业信息：
4.1.5 资料信息： 4.1.6 校园论坛： 4.1.7 论坛列表：
4.1.8 试卷和考试：​
4.1.9 考试详情： 4.1.10 校园公告：​
4.1.11 个人中心
4.2 学生后台模块：
4.3 教师后台模块：
4.4 管理员后台模块：
4.4.1 登录：
4.4.2 修改密码：
4.4.3 学生管理：
4.4.4 教师管理：
4.4.5 课程管理：
4.4.6 作业管理：
4.4.7 资料管理：
4.4.8 签到管理：
4.4.9 成绩统计：
4.4.10 学生作业管理：
4.4.11 试题管理：
4.4.12 校园论坛：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a841565792dff20a55c45a5f00ed58dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fd0da2fe5f7549c0808f6225a72419c/" rel="bookmark">
			阿里P7的消息中心架构设计笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近我们在重构消息中心，关于设计上的部分记录一下笔记，希望能够帮助到正在做类似设计的。另外我创建了一个高级研发的笔记分享群，免费加入，有兴趣的可以在文章底部扫描二维码加入
需求 我们的消息中心主要服务于如下场景：
1、业务使用消息通知对应人员；这也是我们目前主要的使用场景
2、给租户发送通知；如新功能上线，试用，开通功能场景
3、运营类的场景
以上只是列举了在企业中常见的3个场景，其实还有很多，消息中心存在着以下几个特征：
调用量大
消息中心的上游系统很多是监控系统、或者是营销系统等，这些系统的特点就是瞬间的调用量大，比如当云厂商发生故障时，基本上所有的监控系统都在告警，往外push消息。又或者营销系统在某个时间点大量发送营销消息。这个问题的答案就是引入MQ来削峰。
低延迟
业务方通常希望自己的消息越快越好，最好实时送达，但是我们的资源是有限的，所以我们应该给消息分级别和分泳道，因为重要的消息一般量小，需要低延时。而不重要的消息量大，往往可以接收一定时间的延时。按消息级别分泳道，不要让不重要的消息阻塞重要消息的发送。
不丢消息、不重复发送消息
消息要保证不丢失，不重复发送。我们要记录消息的状态，保证消息的幂等，还要支持发送失败的消息自动或手动重试。
历史消息查询和备份
我们可以分库分表，或者定期归档到hdfs。
消息统计分析
对消息的统计和分析主要用来治理我们的上游调用方，比如：有些业务大量的使用重要级别发送不重要消息，或者大量消息占用成本等等。
整体设计 我们先来看下整体的设计
消息配置准备流程
消息推送流程
消息任务生命周期
消息中心关键业务对象
用户免打扰
某些用户可能不想接收消息，某些场景下用户可以主动设置，租户管理员也可以手动设置某些用户免打扰，不需要接收消息，或者限制接收消息的频次
技术方案 推模型
一般来说消息都是读多写少
拉模型
官方消息其实很少，可以采用客户端拉取模型
当然如果数据量太大可以放弃掉mysql，改用hbase存储
为什么是Hbase？
HBase 和 MySQL 的核心差异在于底层的数据结构，HBase 使用 LSM(Log-Structure Merge)树，Innodb 使用 B+树。
LSM 树，即日志结构合并树(Log-Structured Merge-Tree)。其实它并不属于一个具体的数据结构，它更多是一种数据结构的设计思想。
核心思路其实非常简单，就是假定内存足够大，因此不需要每次有数据更新就必须将数据写入到磁盘中，而可以先将最新的数据驻留在内存中，等到积累到最多之后，再使用归并排序的方式将内存内的数据合并追加到磁盘队尾 (因为所有待排序的树都是有序的，可以通过合并排序的方式快速合并到一起)。
LSM 具有批量特性，存储延迟。当写读比例很大的时候（写比读多），LSM 树相比于 B 树有更好的性能。因为随着 insert 操作，为了维护 B 树结构，节点分裂。读磁盘的随机读写概率会变大，性能会逐渐减弱。多次单页随机写，变成一次多页随机写,复用了磁盘寻道时间，极大提升效率。
缓解压力 1、异步写入消息
2、先写缓存
优先分发 利用消息优先级队列，将不同优先级的消息发送到不同的队列当中
SPI机制的运用 消息限流规则场景，用户可以利用SPI机制自定义限流规则
设计模式的运用 1、渠道工厂
利用工厂模式创建渠道对象
2、模板方法+策略模式-发送消息流程
消息发送的流程大体上是一致的，比如 选择渠道-》执行消息推送-》消息日志记录-〉状态更新
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fd0da2fe5f7549c0808f6225a72419c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/635c9abae7b2c6b4a78a2be7ed1897c6/" rel="bookmark">
			2023最新jdk1.8下载java环境安装教程附百度云盘下载(保姆级)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度云盘下载地址:
链接：https://pan.baidu.com/s/1jPxWR_TOXLmKflSktCQ7cw?pwd=nb66 提取码：nb66
官网下载地址:
Java Downloads | Oracle
打开官网之后第一步点window,第二步点击64位下载
点64位下载后,会弹出此界面,把我同意勾上,然后点下载,下载需要登陆,如果没有需要注册一个账号
这个我就不演示了
由于注册麻烦,特分享一个账号给需要的人:
账号：oracle_test@fexbox.org
密码：Java001@@@
注意如果失效了就麻烦自己注册一个账号哦
下载完成之后
第一步:安装jdk 如图是下载好之后的样子,我们首先把它点开
有些电脑会弹出此窗口,我们点运行即可,如果出现对此设备是否许可一定要选择是
之后会出现这个界面,我们直接点下一步
下一步之后会出现此界面,如果需要修改安装路径我们点击更改,如果不需要就直接下一步,建议直接下一步,毕竟占内存空间不大,默认比较好找到
然后会出现一系列的安装,我们只需要等待即可
安装好之后会弹出一个jre安装,我们也选择下一个,如果上面步骤改了路径,这个也要改一下哦
出现此界面就代表jdk安装成功啦
第二步:配置环境变量 首先我们打开电脑设置,如图找到高级系统设置
也可以右键此电脑图标&gt;选择属性也可以打开
打开高级系统设置之后,如图选择环境变量打开
打开环境变量之后,我们点击系统变量下的新建如图:
新建如图:
变量名:JAVA_HOME
变量值:C:\Program Files\Java\jdk-1.8
注意如果不是默认的路径,变量值需改成自己安装的路径哦
填好之后我们点击确定
然后双击path 如图
打开之后我们点新建
然后将此 %JAVA_HOME%\bin 复制粘贴到输入框,并且上移将其置于顶部
点击确定,我们的环境就配置好了.
测试环境是否成功
快捷键win+r打开命令窗口,输入cmd回车
然后输入 java -version
如果提示版本信息就代表成功啦.没有也不要灰心哦再看一次教程说不定哪里漏下了.
好了到处结束谢谢大家支持!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69cafe81b61d60823f960ac7edf7d454/" rel="bookmark">
			【前端工程化】深入浅出vite（一）--vite的优点及原理、性能优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vite 需要 Node.js 版本 14.18+，16+。然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本。
背景 webpack支持多种模块化，将不同模块的依赖关系构建成依赖图来进行统一处理，当构建的项目越来越大时，需要处理的JS代码也越来越多，通常需要很长时间才可以启动开发服务器，即使使用模块热替换(HMR)，修改文件也需要几秒钟才能在浏览器中反映出来，影响了开发效率和幸福感。
Vite可以解决上述问题，它支持ESM规范，所以并不需要遍历依赖图，而是按需加载各种文件。
初体验 mkidr vite-demo cd vite-demo npm init -y npm i lodash &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Vite demo&lt;/title&gt; &lt;link rel="stylesheet" href="./index.css"&gt; &lt;/head&gt; &lt;script src="./index.js" type="module"&gt;&lt;/script&gt; &lt;body&gt; &lt;h1&gt;Hello Vite&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; // index.js import { name } from './test' console.log(name) // test.js import _ from 'lodash' export const name = 'Armouy'; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69cafe81b61d60823f960ac7edf7d454/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaf88f17755b69bb4cac04120750e0ec/" rel="bookmark">
			利用JAVA代码将本地文件传入HDFS中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、环境配置
1.1 配置hadoop和java的环境变量
1.2 修改本地host文件
二、编写JAVA代码
2.1 导入hadoop_lib包
2.2 读取本地文件
2.3 使用copyBytes方法将本地文件传入hdfs
三、在hdfs中查看是否上传成功
总结
一、环境配置 1.1 配置hadoop和java的环境变量 1.下载hadoop和jdk 2.在系统变量里配置HADOOP_HOME和JAVA_HOME，并配置PATH。
3.在cmd中输入以下代码查看是否配置成功
hadoop version java -version 1.2 修改本地host文件 Windows本地是不知道我们在虚拟机中的ip和hostname的，我们需要手动修改windows系统本地文件，这样在写代码的时候windows能识别出我们虚拟机的host。
在 C:\Windows\System32\drivers\etc 中修改hosts文件，将虚拟机的hostname和ip写在文件底部
二、编写JAVA代码 2.1 导入hadoop_lib包 首先要下载hadoop_lib包，然后在IDEA里面导入这个包。 2.2 读取本地文件 本次要上传的文件如下
要一次性上传完这些文件，需要循环读取文件名字，代码如下
2.3 使用copyBytes方法将本地文件传入hdfs IOUtils.copyBytes（）方法:
IOUtils.copyBytes(in, out, 4096, false)
--in:是FSDataInputStream类的对象，是有关读取文件的类，也就是所谓“输入流”
--out:是FSDataOutputStream类的对象，是有关文件写入的类，也就是“输出流”
--4096表示用来拷贝的buffer大小（buffer是缓冲区）--缓冲区大小
--// true - 是否关闭数据流，如果是false，就在finally里关掉
先创建hdfs存储路径作为输出流，然后把本地文件存储路径作为输入流，利用copyBytes方法将本地文件上传到hdfs输出流的路径就大功告成了！！ 代码如下↓
三、在hdfs中查看是否上传成功 输入以下代码查看hdfs里是否存在我们上传的文件
hdfs dfs -ls -R /can_data hdfs中存在文件，上传成功！
总结 本次利用java代码将本地文件上传到hdfs中，是hadoop中基础的操作之一。熟练并灵活地使用java，可以让大数据学生们很好地提升自己的能力，对大数据的理解也会更深刻。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d905bcad7fd93881e114212416585947/" rel="bookmark">
			【Alist】关于阿里云Open 的OAuth 验证 API 无法连接的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关于 failed get objs: failed to list objs: Post "https://api.nn.ci/alist/ali_open的问题解决
由于原api https://api.nn.ci被sni阻断，导致国内无法连接的情况，故提供两个新的api供使用： https://api-cf.nn.ci (套了一层cloudflare)
https://api.xhofe.top (辽宁多线， 由亚洲云赞助)
需要将aliyundrive_open后台配置中的Oauth令牌链接更换为 https://api-cf.nn.ci/alist/ali_open/token
https://api.xhofe.top/alist/ali_open/token
查看详情：https://github.com/alist-org/alist/discussions/4572 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/679c7819e16d4ab04ad5915342ed6c15/" rel="bookmark">
			如何修复损坏的word
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Word是许多人在日常工作中经常使用的软件，但有时它可能会出现意外的崩溃或文档损坏，这对于你正在编辑的文件和工作的进展都会产生重大影响。但是，你不需要过于担心，因为还是有一些方法可以通过修复Word文档中的损坏来解决这个问题。那么如何修复损坏的word呢?在这里，小编将分享一些简单而有效的方法，以帮助您修复损坏的Word文件。
1. 使用自动修复功能
Word提供了自动修复功能，可以快速修复Word文档中的损坏。当你打开一个Word文档时，如果Word检测到文档已损坏，会弹出一个窗口提示你进行修复。你可以按照指示操作，在几个步骤中轻松修复文档。
2.复制和粘贴文本
如果Word文档无法修复，并且你有必要从文档中提取内容，可以尝试复制和粘贴文本。打开损坏的文件，选中文本，并复制到新建的Word文档中。此方法适用于仅损坏文档中一部分内容的情况。如果整个文档已损坏，可以尝试使用其他方法。
3. 使用第三方工具修复Word
如果上述两种方法都失败了，可以尝试使用第三方工具来修复您的Word文档。这里一款小编之前用过的简单的文档修复软件：失易得文档修复，可以及时的帮助我们修复损坏的文件。
通常失易得文档修复能够快速的对损毁的文档进行修复处理，能够解决因为断电、误删、未保存、病毒、卡顿等原因造成的文件损毁。我们可以打开软件，把文件拖到软件内或者点击“添加文档”进行添加。
修复的文件，点击“开始修复”。修复完成后你会看到“预览”按钮，点击“预览”查看。
如何修复损坏的word?我们可以使用其他的方法修复它。无论你选择哪种方法，重要的是要及时处理损坏文档，以确保你不会丢失任何重要的数据或进度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/589caebe08376292d0b1dfc1ade24266/" rel="bookmark">
			通俗易懂的梯度下降法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是梯度下降法？ 梯度下降法在机器学习中常常用来优化损失函数，是一个非常重要的工具。用更加通俗的方式来解释：梯度下降法的作用就是寻找一个 「极小值点」，从而让函数的值尽可能地小。如下图所示，为函数y=xsinx的图像，存在多个局部极小值点，这么多极值点，怎么用梯度下降法找到呢？
梯度其实就是函数的变化率，用数学表达式其实可以表示为函数的倒数或者偏导数，梯度既有大小也有方向，寻找函数的 局部极小值可以理解为就是寻找梯度（函数导数）为0 且左边导数小于0 且右边导数大于0*的点位（自己认为比较接地气的理解），而梯度下降法就是为了找到局部极小值点，就是朝着梯度下降的方向搜索（即使当前变量的值 - 当前梯度方向）。
此时可能会有人疑惑，为什么不直接令其导数等于0，再根据其左右两边的导数正负判断极小值点？？？。是的，大家说的都非常有道理，简单的函数可以直接这么干，但是对于一些非常复杂的函数，其导数也相当复杂，求解当然也是一件非常复杂的事情，故而有了梯度下降法来求解极小值。
2、梯度下降法的定义 其中第（3）步中的梯度即为函数求导
3、梯度下降法求解实例 举一个简单的例子，利用梯度下降法求函数 y= x^2的极小值：
备注：计算步长一般情况下不能太大，否则容易出现左右跳动的情况，导致收敛变慢，如下如所示
4、多元函数的梯度下降 如果变量为多个，那么就需要分别对每个变量求偏导数，然后合并在一起，得到一个多元向量，如下面例子所示，最后按照 梯度下降法的定义 去计算
如下图中，使用红色箭头表示当前所在的位置，随后使用 「黑色」 箭头代表其中一个轴上的坐标朝向哪个方向变化可以使得函数值 「y」 减小，并使用 「黄色」 箭头代表另外一个轴上的坐标朝向哪个方向变化可以使得函数值 「y」 减小。根据平行色变形法则有了 「黑色」 向量和 「黄色」 向量，就可以知道这两个向量最终达到的效果就是 「蓝色」 向量所达到的效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8224f16aa3a82001accbb1a335a9ac6f/" rel="bookmark">
			Flutter生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.生命周期的基本概念 什么是生命周期？ 说白了就是回调函数
让你知道我封装好的这个Widget它处于什么样的状态了
生命周期有啥作用？ 初始化数据 创建变量、常量
发送网络请求
监听小部件的事件
管理内存
销毁数据、销毁监听者
销毁Timer等等
2.Widget的生命周期 StatelessWidget 1、构造方法
2、build方法
StatefulWidget Widget构造方法
Widget的createState
State构造方法
State的initState
didChangeDependencies方法（改变依赖关系）
依赖（共享数据）的InheritedWidget发生变化之后，didChangeDependencies才会调用。 State的Build
1.当调用setState方法。会重新调用Build进行渲染。
2.setState方法内部主要是利用_element（本质是就是context对象） 调用 markNeedsBuild
当Widget销毁的时候调用State的dispose
例子验证：
class MyHomePage extends StatelessWidget { final String? title; MyHomePage({Key? key, this.title}) : super(key: key) { print('构造方法调用了！'); } @override Widget build(BuildContext context) { print('Build方法调用了！'); return Center( child: Text(title ?? ''), ); } } 并用ASCode 来编译运行：
可以看到先运行 1。MyHomePage（） 2.Widget build(BuildContext context)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8224f16aa3a82001accbb1a335a9ac6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e66f7a029f1e76e265dcc42b8afc949a/" rel="bookmark">
			原生js实现鼠标长按事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;div onmousedown="down()" onmouseup="up()" onclick="cli()"&gt;长按事件&lt;/div&gt; &lt;progress value="0" max="100"&gt;&lt;/progress&gt; &lt;script&gt; let progress = document.getElementsByTagName('progress')[0]; let time = ""; let lock = true; function down() { time = setInterval(() =&gt; { lock = false; progress.value += 5 }, 1000) } function up() { clearInterval(time); setTimeout(() =&gt; { lock = true; }) } function cli() { if (lock) { alert(progress.value); } } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aef82d5102a4ec8b04d87322d231c0a1/" rel="bookmark">
			蓝牙资讯|未来几年物联网迅猛发展，蓝牙发挥重要作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDC预测，2023年全球物联网(IoT)支出将达到8057亿美元，比2022年增长10.6%。物联网生态系统的投资预计将在2026年超过1万亿美元，在2023-2027年的预测期内，复合年增长率(CAGR)为10.4%。
到2023年，物联网服务将成为最大的支出领域，并在预测结束时占全球物联网支出的近40%。硬件支出是第二大技术类别，以模块/传感器采购为主。软件将成为增长最快的技术类别，五年复合年增长率为11.0%，重点是应用和分析软件的采购。
在整个预测期间，西欧、美国和中国将占所有物联网支出的一半以上。尽管西欧和美国目前的支出水平相似，但在2023-2027年的预测期内，西欧将以11.0%的复合年增长率扩大其领先地位，而美国的复合年增长率为8.0%。预计到预测结束时，中国的物联网支出将超过美国，其复合年增长率为13.2%。
随着物联网设备在消费电子产品中的广泛采用，通过物联网通信协议实现的标准化和互操作性至关重要。 这些改善了用户体验，并使设备之间的数据共享和通信顺畅。 物联网的使用最近在全世界范围内显着增加。 2019 年全球约有 86 亿台物联网设备。随着物联网设备在全球范围内的加速采用，预计到 2022 年物联网设备总数将达到 121.4 亿台。到 2030 年，预计地球上将有约 231.4 亿台物联网设备。 此外，随着越来越多的物联网设备在全球范围内使用，预计在整个评估期间对物联网通信协议的需求将会增加。
低功耗蓝牙在智能家庭中起到了重要的作用，可以减少布线。而且，低功耗蓝牙可以收集房间内的数据，并实时监控功能，实现无线智能家居、安防等物联网应用的连接。
低功耗蓝牙在我们平时生活中很是常见，应用范围也比较广，人们生活中的家居用品，如智能控制灯光技术，这种技术不仅是传统意义上的对灯光开关的控制，更随科学技术的发展，人们对灯光的控制要求不仅在开关上面，还包含灯光色彩、种类的变化控制等。如北京奥运会上的灯光表演。
因此，在现时生活中，低功耗蓝牙智能灯光控制技术的应用在很大程度上满足了人们的需要，也可以满足人们的需求 智能家居技术在人们生活中的应用范围很广，依据应用的地方不同，相关企业智能家居把他们分为以下几个方面。
1、对客厅的控制应用
在客厅中的应用与卧室的控制类似，都能实现对房间内的照明场景及娱乐设施的控制，如通过灯光实现对音响设备的控制等。通过音乐设备实现对窗帘、空调等设备的控制。还可以通过通信设备的使用，实现对家里面电器的控制。
2、对楼道的控制应用
智能家居控制系统不仅是实现灯光的控制，还能根据自然光的亮度，实现对灯光的开关调节。具体可以突出，当自然光的光线较亮时，会将楼道内的灯光亮度调暗。当自然光强度较暗或者没有自然光时，会实现对灯的亮度自动调节。此外，还能帮助人们进行定时提醒，做到定时开灯、定时关灯等。
3、室内方面的应用
具体对房间内的照明控制系统，对此来实现对不同场景的切换与控制;还可以对窗帘、空调等电器设备的智能控制。除此之外，还以可以通过移动设备，对整个房间内的电器及灯具的控制。智能家居控制系统在人们的生活中应用非常广，不仅增强了人们生活的安全性，更提供了人们生活的方便与快捷，使人们在生活过程中具有愉悦的心情，因此受到人们广泛的青睐。
ST17H66蓝牙BLE5.2芯片是伦茨科技最新推出的16脚蓝牙BLE芯片， 具有256KB Flash +（96KB ROM）+64KB SRAM，蓝牙协议栈固化，不再占用Flash空间。64KB的SRAM，分区使用，可以在待机时保存更多用户数据，可以设置大容量缓冲区，支持更加复杂的功能。符合SIG规范的自组网应用。包括多节点的控制，以及2主4从的同时工作。
ST17H66有10 x GPIO，-103dBm @BLE 125Kbps。单端天线输出，可以无匹配电路。支持天线矩阵切换，支持外挂LNA信号放大。
最大的优势是功耗降低。上一代产品蓝牙接收峰值电流&gt;13mA; MCU的功耗0.5mA/MHz；低功耗模式下平均电流&gt;40uA。新产品的蓝牙接收峰值电流8.6mA，MCU的功耗&lt;90uA/MHz。低功耗模式下平均电流可降低到20uA30uA。BLE5的广播数据包更加灵活，最多可包含200Byte数据，BLE4只有32Byte。传输速率更快，BLE5可以达到2030KB/s；BLE4一般在45KB/s。
应用场景：
对功耗控制要求比较严格的应用，比如高档的防丢器，电子标签等。
对数据传输有一定要求的客户，比如用于云台自拍的透传模块，希望蓝牙OTA更加可靠的客户。
方便灵活的电子标签应用。如商品标签，资产防盗，生物追踪。
伦茨科技拥有自主研发无线射频和低功耗蓝牙BLE5.2芯片并具有全球知识产权，针对AIoT物联网领域和个人消费者，提供蓝牙主控全集成芯片的「软硬件共性」解决方案及核心器件，配套全方位APP软件平台定制开发。所设计的蓝牙芯片方案应用于智能穿戴设备、蓝牙室内导航、智能家居、医疗健康、运动建身、数据传输、远程控制、个人外设及AIoT物联网等场景。（tingting是伦茨科技旗下品牌，主要是提供Apple Find My服务应用于各大物联网产品中）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba69f674d4ce0749c14c04a3f4829294/" rel="bookmark">
			2023年全国职业院校技能大赛-赛题第06套-GZ033 大数据应用开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
任务A：大数据平台搭建（容器环境）（15分）
子任务一：Hadoop 完全分布式安装配置
子任务二：Spark on Yarn安装配置
子任务三：Hudi安装配置
任务B：离线数据处理（25分）
子任务一：数据抽取
子任务二：数据清洗
子任务三：指标计算
任务C：数据挖掘（10分）
子任务一：特征工程
子任务二：推荐系统
任务D：数据采集与实时计算（20分）
子任务一：实时数据采集
子任务二：使用Flink处理Kafka中的数据
任务E：数据可视化（15分）
子任务一：用柱状图展示消费额最高的省份
子任务二：用饼状图展示各地区消费能力
子任务三：用折线图展示每年上架商品数量的变化
子任务四：用条形图展示消费额最高的地区
子任务五：用散点图展示省份平均消费额
任务F：综合分析（10分）
子任务一：Spark中的HashShuffle的有哪些不足？
子任务二：请简述Flink的Slot和parallelism有什么区别。
子任务三：分析下一年度的建仓目的地。
2023年全国职业院校技能大赛
赛题第06套
赛项名称： 大数据应用开发 英文名称： Big Data Application Development 赛项组别： 高等职业教育组 赛项编号： GZ033 背景描述
大数据时代背景下，电商经营模式发生很大改变。在传统运营模式中，缺乏数据积累，人们在做出一些决策行为过程中，更多是凭借个人经验和直觉，发展路径比较自我封闭。而大数据时代，为人们提供一种全新的思路，通过大量的数据分析得出的结果将更加现实和准确。商家可以对客户的消费行为信息数据进行收集和整理，比如消费者购买产品的花费、选择产品的渠道、偏好产品的类型、产品回购周期、购买产品的目的、消费者家庭背景、工作和生活环境、个人消费观和价值观等。通过数据追踪，知道顾客从哪儿来，是看了某网站投放的广告还是通过朋友推荐链接，是新访客还是老用户，喜欢浏览什么产品，购物车有无商品，是否清空，还有每一笔交易记录，精准锁定一定年龄、收入、对产品有兴趣的顾客，对顾客进行分组、标签化，通过不同标签组合运用，获得不同目标群体，以此开展精准推送。
因数据驱动的零售新时代已经到来，没有大数据，我们无法为消费者提供这些体验，为完成电商的大数据分析工作，你所在的小组将应用大数据技术，以Scala作为整个项目的基础开发语言，基于大数据平台综合利用Hudi、Spark、Flink、Vue.js等技术，对数据进行处理、分析及可视化呈现，你们作为该小组的技术人员，请按照下面任务完成本次工作。
任务A：大数据平台搭建（容器环境）（15分） 环境说明：
服务端登录地址详见各任务服务端说明。
补充说明：宿主机及各容器节点可通过Asbru工具或SSH客户端进行SSH访问。
子任务一：Hadoop 完全分布式安装配置 本任务需要使用root用户完成相关配置，安装Hadoop需要配置前置环境。命令中要求使用绝对路径，具体要求如下:
从宿主机/opt目录下将文件hadoop-3.1.3.tar.gz、jdk-8u212-linux-x64.tar.gz复制到容器Master中的/opt/software路径中（若路径不存在，则需新建），将Master节点JDK安装包解压到/opt/module路径中(若路径不存在，则需新建)，将JDK解压命令复制并粘贴至客户端桌面【Release\任务A提交结果.docx】中对应的任务序号下；
修改容器中/etc/profile文件，设置JDK环境变量并使其生效，配置完毕后在Master节点分别执行“java -version”和“javac”命令，将命令行执行结果分别截图并粘贴至客户端桌面【Release\任务A提交结果.docx】中对应的任务序号下；
请完成host相关配置，将三个节点分别命名为master、slave1、slave2，并做免密登录，用scp命令并使用绝对路径从Master复制JDK解压后的安装文件到slave1、slave2节点（若路径不存在，则需新建），并配置slave1、slave2相关环境变量，将全部scp复制JDK的命令复制并粘贴至客户端桌面【Release\任务A提交结果.docx】中对应的任务序号下；
在Master将Hadoop解压到/opt/module(若路径不存在，则需新建)目录下，并将解压包分发至slave1、slave2中，其中master、slave1、slave2节点均作为datanode，配置好相关环境，初始化Hadoop环境namenode，将初始化命令及初始化结果截图（截取初始化结果日志最后20行即可）粘贴至客户端桌面【Release\任务A提交结果.docx】中对应的任务序号下；
启动Hadoop集群（包括hdfs和yarn），使用jps命令查看Master节点与slave1节点的Java进程，将jps命令与结果截图粘贴至客户端桌面【Release\任务A提交结果.docx】中对应的任务序号下。
子任务二：Spark on Yarn安装配置 本任务需要使用root用户完成相关配置，已安装Hadoop及需要配置前置环境，具体要求如下：
从宿主机/opt目录下将文件spark-3.1.1-bin-hadoop3.2.tgz复制到容器Master中的/opt/software（若路径不存在，则需新建）中，将Spark包解压到/opt/module路径中(若路径不存在，则需新建)，将完整解压命令复制粘贴至客户端桌面【Release\任务A提交结果.docx】中对应的任务序号下；修改容器中/etc/profile文件，设置Spark环境变量并使环境变量生效，在/opt目录下运行命令spark-submit --version，将命令与结果截图粘贴至客户端桌面【Release\任务A提交结果.docx】中对应的任务序号下；完成on yarn相关配置，使用spark on yarn 的模式提交$SPARK_HOME/examples/jars/spark-examples_2.12-3.1.1.jar 运行的主类为org.apache.spark.examples.SparkPi，将运行结果截图粘贴至客户端桌面【Release\任务A提交结果.docx】中对应的任务序号下（截取Pi结果的前后各5行）。 （运行命令为：spark-submit --master yarn --class org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba69f674d4ce0749c14c04a3f4829294/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cd8da578d8b1e775d8fdaf6c02eaac5/" rel="bookmark">
			大语言模型微调和PEFT高效微调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录标题 1 解释说明1.1 预训练阶段1.2 微调阶段 2 几种微调算法2.1 在线微调2.2 高效微调2.2.1 RLHF2.2.2 LoRA2.2.3 Prefix Tuning2.2.4 Prompt Tuning2.2.5 P-Tuning v2 1 解释说明 预训练语言模型的成功，证明了我们可以从海量的无标注文本中学到潜在的语义信息，而无需为每一项下游NLP任务单独标注大量训练数据。此外，预训练语言模型的成功也开创了NLP研究的新范式，即首先使用大量无监督语料进行语言模型预训练（Pre-training），再使用少量标注语料进行微调（Fine-tuning）来完成具体NLP任务。 1.1 预训练阶段 大模型首先在大量的无标签数据上进行训练，预训练的最终目的是让模型学习到语言的统计规律和一般知识。在这个过程中模型能够学习到词语的语义、句子的语法结构、以及文本的一般知识和上下文信息。需要注意的是，预训练本质上是一个无监督学习过程。 1.2 微调阶段 预训练好的模型然后在特定任务的数据上进行进一步的训练。这个过程通常涉及对模型的权重进行微小的调整，以使其更好地适应特定的任务。不同于模型预训练过程可以代入无标签样本，深度学习模型微调过程需要代入有标签的样本来进行训练，微调的本质是一个有监督学习过程。 2 几种微调算法 伴随着大模型技术的蓬勃发展，微调技术一跃成为大模型工程师必须要掌握的核心技术，越来越多的微调技术也在不断涌现。大模型微调重要性不言而喻，那么到底有哪些微调方法呢？ 2.1 在线微调 借助OpenAl提供的在线微调工具进行微调；在线微调API地址按照格式要求，准备并上传数据集；排队、支付费用并等待微调模型训练完成；赋予微调模型API单独编号，调用API即可使用。 2.2 高效微调 高效微调，State-of-the-art Parameter-Efficient Fine-Tuning (SOTA PEFT)，特指部分参数的微调方法，这种方法算力功耗比更高，也是目前最为常见的微调方法；除此之外，Fine-Tuning也可以代指全部微调方法，同时OpenAl中模型微调API的名称也是Fine-Tuning，需要注意的是，OpenAI提供的在线微调方法也是一种高效微调方法，并不是全量微调。主流高效微调方法包括LoRA、Prefix Tuning、P-Tuning、Prompt Tuning、AdaLoRA等；目前这些方法的实现均已集成至Hugging Face项目的库中，我们可以通过安装和调用Hugging Face的PEFT(高效微调)库,来快速使用这些方法;高效微调仓库 2.2.1 RLHF RLHF: Reinforcement Learning from Human Feedback，即基于人工反馈机制的强化学习。最早与2022年4月，由OpenAl研究团队系统总结并提出，并在GPT模型的对话类任务微调中大放异彩，被称为ChatGPT“背后的功臣”；最早由OpenAl研究团队提出，并用于训练OpenAl的InstructGPT模型，根据OpenAl相关论文说明，基于RLHF训练的InstructGPT模型，在仅拥有1.3B参数量的情况下，输出效果已经和GPT-3 175B模型媲美。这充分说明了RLHF方法的实践效果；RLHF也是目前为止常用的、最为复杂的基于强化学习的大语言模型微调方法，目前最好的端到端RLHF实现是DeepSpeedChat库，由微软开源并维护。 步骤1：监督微调（SFT）——使用精选的人类回答来微调预训练的语言模型以应对各种查询；步骤2：奖励模型微调——使用一个包含人类对同一查询的多个答案打分的数据集来训练一个独立的（通常比SFT小的）奖励模型（RW）；步骤3：RLHF训练——利用 Proximal Policy Optimization（PPO）算法，根据RW模型的奖励反馈进一步微调SFT模型。 2.2.2 LoRA LoRA: LOW-RANK ADAPTATION OF LARGE LANGUAGE MODELS (2021)，基于低阶自适应的大语言模型微调方法；原理简述：基于大模型的内在低秩特性，增加旁路矩阵来模拟全参数微调。简而言之，是通过修改模型结构进行微调，是一种四两拨千斤的微调方法，是目前最通用、同时也是效果最好的微调方法之一；LoRA最早是由微软研究院发布的一项微调技术，LoRA除了可以用于微调大语言模型(LLM)外，目前还有一个非常火爆的应用场景：围绕diffusion models(扩散模型)进行微调，并在图片生成任务中表现惊艳。 2.2.3 Prefix Tuning Prefix-Tuning: Optimizing Continuous Prompts for Generation (2021)，基于提示词前缀优化的微调方法，来源于斯坦福大学的一种高效微调方法；原理简述：在原始模型基础上，增加一个可被训练的Embedding层，用于给提示词增加前缀，从而让模型更好的理解提示词意图，并在训练过程中不断优化这些参数；Prefix Tuning既能够在模型结构上增加一些新的灵活性，又能够在模型使用上提供一种自动的、能够改进模型表现的提示机制。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cd8da578d8b1e775d8fdaf6c02eaac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20490079676e77bca81f2c49fb95a400/" rel="bookmark">
			c语言扫雷游戏代码学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c语言扫雷游戏代码学习 目录 **c语言扫雷游戏代码学习**1.基本思路将程序拆分为三个部分: 2.各个功能实现首先定义宏,以便后面参数的修改.写出主函数,确定程序的大体框架.接下来按照步骤完善game()函数.菜单功能棋盘初始化棋盘的打印布置地雷扫雷部分显示附近的地雷数目检查非雷格子数目彩色打印函数呃,未完成头文件,函数,变量的声明头文件引用 3.完整代码game.htest.cgame.c早期游戏通关图片 结束语参考 运行环境,visual studio 2022社区版 1.基本思路 经典的扫雷界面
这里用c语言模拟实现的扫雷界面
扫雷游戏由一个有X,Y轴的平面格子构成,所以需要用到二位数组.
1.利用两个二位数组分别来布置雷(玩家不可见)char mine[ROWS][COLS],展示扫雷的界面(玩家可见)char show[ROWS][COLS].
2.雷的布置:利用随机数生成布置雷,需要用到时间戳,rand()函数.
3.爆炸式边界展开:当扫雷点四周没有雷的时候,扫雷边界会向四周继续展开, 直到边界出现雷. 利用函数的递归实现该功能.
4.不同颜色显示:利用彩色打印实现不同雷数量的显示,以及疑似有雷位置的标记.
5.标记功能,创建一个一维数组存储标记点的坐标.
将程序拆分为三个部分: test.c(主程序,游戏的大体框架)
game.c(自定义函数,游戏的各个具体功能实现)
game.h(头文件,宏,函数声明)
2.各个功能实现 首先定义宏,以便后面参数的修改. 定义的棋盘比展示的棋盘多了两行两列,用于解决查询棋盘边缘格子四周的地雷数量,这样边缘格子也存在上下左右的8个相邻格子.扩宽的格子不设置地雷.
这里可以修改棋盘大小,地雷数量,可以调整难度.
//宏定义 //棋盘数量 #define ROW 9 #define COL 9 #define ROWS ROW+2 #define COLS COL+2 //地雷数量 #define easy_count 10 写出主函数,确定程序的大体框架. 主函数放在test,c
int main() { //输入值 int input = 0; //雷布置 char mine[ROWS][COLS] = { 0 }; //扫雷展示界面 char show[ROWS][COLS] = { 0 }; //随机种子 srand((unsigned int) time(NULL)); do { //菜单 menu(); //选择 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20490079676e77bca81f2c49fb95a400/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2d4e9cf900197b1ac3d80263613c0b4/" rel="bookmark">
			windows 系统批量去掉文件名前缀 bat 脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Windows 系统上，你可以使用批处理脚本（.bat 文件）来批量去掉文件名的前缀。以下是一个简单的示例脚本，你可以根据自己的需求进行修改：
@echo off setlocal enabledelayedexpansion REM 设置要重命名的文件夹路径 set "folderPath=C:\Path\To\Your\Folder" REM 设置要去除的前缀 set "prefix=OldPrefix_" REM 遍历文件夹中的所有文件 for %%F in ("%folderPath%\%prefix%*") do ( REM 获取文件的扩展名 set "extension=%%~xF" REM 获取文件名（去掉前缀） set "newName=%%~nF" set "newName=!newName:%prefix%=!" REM 组合新的文件名 set "newName=!newName!!extension!" REM 输出重命名前后的文件名（可选） echo Renaming "%%~nxF" to "!newName!" REM 执行重命名操作 ren "%%F" "!newName!" ) echo Batch renaming completed. pause 将上述脚本保存为扩展名为 .bat 的文件，并将 "C:\Path\To\Your\Folder" 替换为你想要批量移除文件名前缀的文件夹路径，以及将 "OldPrefix_" 替换为你希望去掉的前缀。
注意：需要将脚本文件在 另存为 页面将编码格式改为ANSI，因为如果是txt文本默认编码是UTF-8 ！！！会报错或者执行失败。
运行脚本后，它将遍历指定文件夹中以指定前缀开头的所有文件，并去除前缀，然后将文件重命名为新的文件名。
请注意，在运行脚本之前应备份重要文件，以防止意外的操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c79d15c9788c539b2105105c4978bed9/" rel="bookmark">
			为什么Float比较不要用==
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么Float比较不要用== Float类型比较不要用`==`引出问题Float比较不能用==原因精度问题NaN问题无穷大问题 为什么可以用equals Float类型比较不要用== 引出问题 在一个风和日丽的大雨天，一个辛勤劳作的码农正在刨着前辈留下的一座大山，debug了一个下午决定记录下这个不起眼小bug。
大致代码是这样的 ：
//一大堆东西 //一大堆东西 //一大堆东西 if (point.getX()==linePoint.getX() &amp;&amp; point.getY()==linePoint.getY()) { //一大堆东西 //一大堆东西 } //一大堆东西 //一大堆东西 反正事就是这么个事，并且IDEA也提示了要用.equals()，不要用==。
但是比较还要靠这个bug摸一下午🐟，于是有了这篇文章。。。
Float比较不能用== 下面有两个Float类型的变量a、b，并且值都为1.0f，不看答案的前提下大家不妨先来猜猜结果是多少？
Float a = 1.0f; Float b = 1.0f; System.out.println(a == b); System.out.println(a.equals(b)); 揭晓答案：
当我们使用==来对两个Float类型进行比较是打印的结果是false；而使用.equals()比较时打印的结果才是我们期望的true。
开个小差：
其实即使我们不运行程序，IDEA也会自动提醒我们注意！
当我们把鼠标放到黄色块（我的是波浪线是因为我的主题的缘故）时，IDE就会提示我们Replace '==' with 'equals()'，鼠标单击即可自动转换。
上方翻译：使用’==‘比较数字对象，而不是’equals()’
原因 在Java中，Float类型是一个32位的浮点数，由符号位、指数位和尾数位组成。由于浮点数的存储和运算方式与整数不同，因此在使用==时可能会存在以下爱几种问题：
精度问题 在计算机系统理论中，浮点数采用 IEEE 754 标准表示，编码方式是符号+阶码+尾数
比如 float 类型占用 32 位，单精度浮点表示法：
符号位（sign）占用 1 位，用来表示正负数，0 表示正数，1 表示负数指数位（exponent）占用 8 位，用来表示指数，实际要加上偏移量小数位（fraction）占用 23 位，用来表示小数，不足位数补 0 从这里可以看出，指数位决定了大小范围，小数位决定了计算精度。当十进制数值转换为二进制科学表达式后，得到的尾数位数是有可能很长甚至是无限长。所以当使用浮点格式来存储数字的时候，实际存储的尾数是被截取或执行舍入后的近似值。这就解释了浮点数计算不准确的问题，因为近似值和原值是有差异的，导致使用==比较时返回false。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c79d15c9788c539b2105105c4978bed9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f180d744ab52413d38097c3c07243e28/" rel="bookmark">
			SpringBoot基于java的校园论坛的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌在职Java研发工程师、专注于程序设计、源码分享、技术交流、专注于Java技术领域和毕业设计✌
项目名称 SpringBoot基于java的校园论坛的设计与实现
视频演示 SpringBoot基于java的校园论坛的设计与实现_哔哩哔哩_bilibili
系统介绍 基于Java的校园论坛的设计与实现
摘 要：校园论坛能够为广大师生提供在线交流的服务，满足校园内广大师生的各种学习需求和生活需求。广大师生可以用它来进行学术交流、分享生活、失物认领、组织活动等。论坛系统能够鼓励学生积极参与各类学术研讨、项目合作，从而提高学生的学术能力和团队协作精神。我们通过对已有校园论坛的功能和特点进行分析和总结提出了一个面向未来校园的全新设计方案，提升了校园论坛的易用性、安全性、可扩展性和社交属性。
在系统架构方面，本论坛采用了B/S结构，后端以Java为主要开发语言，结合SpringBoot、MyBatis等成熟框架进行开发。我们的前端采用了Vue.js框架和Element UI组件库，实现了高度响应化的布局，并且让用户能够得到更好的体验。为确保安全性，本系统采用了权限控制、验证码、敏感词过滤等多重安全措施。同时，为了适应不断增长的用户需求，本论坛提供了丰富的社交功能，如点赞、评论、私信等，实现了师生间的实时互动。
本文提出的基于Java的校园论坛设计方案，不仅具备良好的性能和稳定性，还能有效地满足学生和教师的需求，为校园生活带来便利。
关键词：校园论坛；社交功能；实时互动；文章；交流
基于Java的校园论坛的设计与实现
摘 要：校园论坛能够为广大师生提供在线交流的服务，满足校园内广大师生的各种学习需求和生活需求。广大师生可以用它来进行学术交流、分享生活、失物认领、组织活动等。论坛系统能够鼓励学生积极参与各类学术研讨、项目合作，从而提高学生的学术能力和团队协作精神。我们通过对已有校园论坛的功能和特点进行分析和总结提出了一个面向未来校园的全新设计方案，提升了校园论坛的易用性、安全性、可扩展性和社交属性。
在系统架构方面，本论坛采用了B/S结构，后端以Java为主要开发语言，结合SpringBoot、MyBatis等成熟框架进行开发。我们的前端采用了Vue.js框架和Element UI组件库，实现了高度响应化的布局，并且让用户能够得到更好的体验。为确保安全性，本系统采用了权限控制、验证码、敏感词过滤等多重安全措施。同时，为了适应不断增长的用户需求，本论坛提供了丰富的社交功能，如点赞、评论、私信等，实现了师生间的实时互动。
本文提出的基于Java的校园论坛设计方案，不仅具备良好的性能和稳定性，还能有效地满足学生和教师的需求，为校园生活带来便利。
关键词：校园论坛；社交功能；实时互动；文章；交流
4.1 软件功能模块设计 本基于Java的校园论坛系统主要是分为前台和后台两个功能模块，并且也是通过角色进行区分的，分别为管理员角色和用户角色，管理员主要是负责对系统后台的所有数据进行统一维护，用户是对系统前台进行功能操作的。系统功能模块如下所示：
用户的主要功能模块包括了：登录、注册、首页、分类、文章阅读、我的收藏、文件资源、阅读排行、发布文章、评论管理等功能模块。
在校园论坛系统中，管理员起着至关重要的作用，他们负责监控和管理整个系统的运行情况。他们需要登录以确认身份才能获得系统访问权限，然后通过查看后台首页了解关键数据和论坛运行状况。管理员可以已注册的用户进行全面的管理，包括对其进行增删改查操作，并对其账号进行冻结和解冻处理。管理员会根据用户的积分和等级分配与之相匹配的权限，如发表文章、发表评论等。管理员能够调整各功能模块的访问权限，确保不同用户能够按照各自不同的需求进行操作。管理员可以发布、编辑和删除系统公告，以便及时通知用户重要信息；他可以创建和维护论坛板块分类，方便用户找到自己需要的内容，并在该内容下评论来进行交流。管理员可以通过文章管理模块对用户发表的文章和评论进行审核、修改和删除等操作，以确保广大师生看到的是高质量的内容。管理员可以对论坛系统中的所有内容进行管理，对其这些内容执行查看、删除和备份等管理操作。这些功能模块共同构成了一个完整的管理员后台管理系统，对实现对校园论坛的高效管理和监控有非常重要的作用。
校园论坛总体功能模块图如图4-1所示：
环境需要 1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS； 5.数据库：MySql 5.7版本；
6.是否Maven项目：否；
技术栈 1. 后端：Spring+SpringMVC+Mybatis
2. 前端：JSP+CSS+JavaScript+jQuery
使用说明 1. 使用Navicat或者其它工具，在mysql中创建对应名称的数据库，并导入项目的sql文件；
2. 使用IDEA/Eclipse/MyEclipse导入项目，Eclipse/MyEclipse导入时，若为maven项目请选择maven;
若为maven项目，导入成功后请执行maven clean;maven install命令，然后运行；
3. 将项目中springmvc-servlet.xml配置文件中的数据库配置改为自己的配置;
4. 运行项目，在浏览器中输入http://localhost:8080/ 登录
运行截 用户管理控制层: package com.houserss.controller; import javax.servlet.http.HttpSession; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f180d744ab52413d38097c3c07243e28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9485b462e71db651717e65a0e13e1a2d/" rel="bookmark">
			Unity 双指缩放镜头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		private Camera mainCamera; public float zoomSpeed = 0.1f; // 缩放速度 public float minZoom = 5f; // 最小缩放值 public float maxZoom = 120f; // 最大缩放值 private Vector2?[] oldTouchPositions = { null, null }; private Vector2 oldTouchVector; private float oldTouchDistance; private void ZoomCamera(float deltaMagnitudeDiff) { if(mainCamera == null) { mainCamera = Camera.main; } // 计算新的缩放值 float newZoom = mainCamera.orthographicSize - deltaMagnitudeDiff; // 将缩放值限制在最小值和最大值之间 newZoom = Mathf.Clamp(newZoom, minZoom, maxZoom); // 更新相机的缩放值 mainCamera.orthographicSize = newZoom; // 可以在这里写你自己的缩放事件 } private void Update() { //当两次触摸 if (Input.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9485b462e71db651717e65a0e13e1a2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/415f29906c5d33c46b71f5f7c0d12091/" rel="bookmark">
			odoo连接器-odoo数据拉取，Java xml-rpc实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 odoo数据拉取，创建，更新
参考 官方external api文档
External API — Odoo 14.0 文档 术语 ORM odoo数据以对象模型呈现，支持one2many，many2one，many2many等对象关联关系
Model 可以看作数据表，数据类型
XML-RPC odoo使用xml-rpc通信
设计模型 Client负责连接协议，即xml rpm协议
Connector 封装获取数据逻辑
QueryRequest 查找请求，封装查找条件参数
表达式模型 odoo的查询表达式是逆波兰表达式，连接器支持两种构建表达式方式
表达式分析器(未实现) 用户出入 (traceId=='b') and ((database=='d') or ((days&gt;=12) or (eventType=='g')))
通用格式的表达式，分析器转换成逆波兰式
流式api构建器 流式builder构建逆波兰式
两方式比较：
分析器，通用的表达式符合开发人员的思维，但分析器递归分析消耗一定性能，可增加缓存支持，但要考虑参数化表达式
流式api性能高，需要开发人员先转为逆波兰式
接口设计 setupTestDataBase 获取demo库的属性，包括host，user，password，database(数据库名称)，用于demo库拉取，demo库是动态，先通过此方法，odoo分配哪个demo库
authenticate 认证，认证的参数，host，user，password，database，连接器构造方法传入
listFieldsOfModel 获取模型的字段，包括名称，类型，说明
count 返回传入请求条件查到的记录总数
search 查找
createRecored/updateRecord/deleteRecord 增删改记录
开发指南 以下代码来源于单元测试
1. 构建连接器 odooConnector = new Connector(host, dbParams, false);
host = "http://xxx.odoo.com" xxx申请时填写
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/415f29906c5d33c46b71f5f7c0d12091/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cede161846b47a2b003eba9aa006b5f/" rel="bookmark">
			java Predicate接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Predicate是Java中的一个函数式接口,它代表一个判断逻辑,接收一个输入参数,返回一个布尔值。
接口定义
@FunctionalInterface public interface Predicate&lt;T&gt; { boolean test(T t); } 它接收泛型T的输入,返回true或false。
Predicate接口通常用来:
1. 过滤集合中的元素。像List#removeIf()、Stream#filter()等方法接收Predicate来过滤元素。
2. 判断对象是否满足某条件,作为if语句的判断条件。
3. 验证对象的一些属性或状态是否正确。
4. 自定义复杂的判断逻辑作为方法的参数。Predicate的使用者无需了解判断逻辑的具体实现细节。
示例代码:
// Remove persons older than 18 list.removeIf(person -&gt; person.age &gt; 18); // Check if "Hello" starts with "H" if (startsWith("H")) { ... } Predicate&lt;String&gt; startsWithH = s -&gt; s.startsWith("H"); // Check if person has empty name Predicate&lt;Person&gt; nameNotEmpty = person -&gt; !person.name.isEmpty(); // Use Predicate to filter candidates selectCandidates(candidates, candidate -&gt; candidate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cede161846b47a2b003eba9aa006b5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4687328731a3d0ff8ece7e47359623c8/" rel="bookmark">
			MacBook解压安装MongoDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MacBook下mongoDB安装 官方下载地址: https://www.mongodb.com/try/download/community
官方安装地址: https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x-tarball/
官方下载免费的社区版本: Community Server mongodb-osx-ssl-x86_64-3.6.5.tgz
#解压 tar -zxvf mongodb-osx-ssl-x86_64-3.6.5.tgz #修改目录名 mv mongodb-osx-x86_64-3.6.5 mongodb-3.6.5 #添加到环境变量里 vim ~/.zshrc 最后加入 export MONGODB_HOME=/Users/liang/software/mongodb-3.6.5 export PATH=$MONGODB_HOME/bin:$PATH #使配置生效 source ~/.zshrc #查看版本 mongod -version 报错: 提示不能打开 #系统偏好设置--&gt;安全性与隐私--&gt;通用 允许从以下位置下载的App: 已阻止使用"mongod",因为来自身份不明的开发者 点击 仍然允许 #再次执行 mongod -version #打印如下: db version v3.6.5 git version: a20ecd3e3a174162052ff99913bc2ca9a839d618 OpenSSL version: OpenSSL 1.1.0h 27 Mar 2018 allocator: system modules: none build environment: distarch: x86_64 target_arch: x86_64 #进入mongodb安装目录，创建data和log目录 mkdir data mkdir log #启动服务 mongod --dbpath /Users/liang/software/mongodb-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4687328731a3d0ff8ece7e47359623c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dad683c75e16e4f30e98a42463dc31ef/" rel="bookmark">
			Python - 定时任务框架【APScheduler】基本使用详解(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 前言 一个网页会有很多数据是不需要经常变动的，比如说首页，变动频率低而访问量大，我们可以把它静态化，这样就不需要每次有请求都要查询数据库再返回，可以减少服务器压力
我们可以使用Django的模板渲染功能完成页面渲染
二. APSchedule简介 APScheduler的全称是Advanced Python Scheduler。它是一个轻量级的 Python 定时任务调度框架。
APScheduler 支持三种调度任务：
固定时间间隔固定时间点（日期）Linux 下的 Crontab命令。同时，它还支持异步执行、后台执行调度任务。 三. 使用 1.安装APScheduler pip install APScheduler 2. 使用APScheduler 步骤 APScheduler 使用起来还算是比较简单。运行一个调度任务只需要以下三部曲：
新建一个 schedulers (调度器)添加一个调度任务(job stores)运行调度任务 简单示例
在项目模块或者根目录的__init__.py文件中添加以下代码
from apscheduler.scheduler import Scheduler sched = Scheduler() @sched.interval_schedule(seconds=2,misfire_grace_time=3600) def excute_task(): fun() #执行任务函数 sched.start() #启动定时任务脚本 启动项目即可自动执行
python manage.py runserver 8000 3. 基础组件介绍 APScheduler 有四种组件，分别是：调度器(scheduler)，作业存储(job store)，触发器(trigger)，执行器(executor)。
schedulers（调度器）
它是任务调度器，属于控制器角色。它配置作业存储器和执行器可以在调度器中完成，例如添加、修改和移除作业。
triggers（触发器）
描述调度任务被触发的条件。不过触发器完全是无状态的。
job stores（作业存储器）
任务持久化仓库，默认保存任务在内存中，也可将任务保存都各种数据库中，任务中的数据序列化后保存到持久化数据库，从数据库加载后又反序列化。
executors（执行器）
负责处理作业的运行，它们通常通过在作业中提交指定的可调用对象到一个线程或者进城池来进行。当作业完成时，执行器将会通知调度器
schedulers（调度器） 提供 7种调度器，能够满足我们各种场景的需要。例如：后台执行某个操作，异步执行操作等。经常使用的为BackgroundScheduler
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dad683c75e16e4f30e98a42463dc31ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0afc432b3e4113e3cb1b69339e208849/" rel="bookmark">
			行业报告 | 智能教育发展蓝皮书（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创 | 文 BFT机器人
核心观点 Core point 在教育数字化转型的背景下，积极探索智能技术助力教学减负增效的实践路径，对于深化教育教学改革，促进学生全面发展、健康成长具有重要现实意义。
03 智能技术助力教学设计 教学设计以解决实际的教学问题为宗旨，是连接教学理论与实践的桥梁.为开展教与学活动提供前置准备。
本章在阐述教学设计的内涵、特征与挑战以及智能技术助力教学设计应用场景的基础上，以教学目标设计、教学资源设计、教学活动设计等教学场景为例，深入分析智能技术在助力教学设计减负增效中的作用。
3.1智能技术助力教学设计应用场景
教学设计主要指运用系统的方法，对学习者分析、教学目标、教学内容、教学方法、教学策略和教学评价等环节进行规划的过程”。教学设计是一个复杂的系统工程，包含教学价值与目标定位、教学主要变量与教学关系处理、教学程序与活动方式的预设，以及教学资源与环境、教学评价的规划等核心内容，具有目的性、计划性、预先性和创造性等特征。
随着基础教育教学改革的不断深入和智能技术的快速发展，如何通过教学设计优化教学流程进而提高教学效果和质量，是当前面临的挑战。例如: 重视发挥教学目标的导向作用，但目标设计的精准性和弹性化有待提升，教学资源是教学设计的内容，但资源获取便捷性和适用性需要提升:注量教学活动设计,但设计的便捷化和精细化需要加强。
随着智能技术与教育教学的深度融合，教学过程发生了深刻变化。借助大数据、云计算、知识图谱等智能技术创新教学设计，为推进教育教学变革、促进学生全面发展和教师自我成长提供了更多可能，有助于教学设计减负增效。智能技术助力教学设计的应用场景，包括教学目标设计、教学资源设计、教学活动设计等，具体如图 3-1 所示。
3.2精准化教学目标设计
教学目标设计是教学设计的首要任务，也是有效教学的根本保障”。
教学目标设计的本质是在学习者特征与教学预期之间建立一种准确的映射关系，教师需要在综合考虑学生学习现状和学习偏好的基础上，通过学习需求分析、学习目标生成等步骤来实现教学目标的精细化、差异化、适切化设计。目前教学目标设计主要是依据教师主观经验、教材内容来确定，大多是“一刀切”式的教学目标或低层次的教学目标，难以满足学生个体的差异需求。
教育大数据、学习分析等智能技术的发展为实现精准教学目标设计提供了新的方向和有效方法，其作用主要体现在提高教学目标设计的精准性和教学目标设计的差异性两方面。
智能技术支持的教学目标设计通过赋能学习需要分析、教学目标预设等典型场景，助力教师基于学生多方面学情精准识别学习需求，并能够面向班级、小组以及个体预设弹性化、差异化的教学目标，具体应用场景如下：
（1）精准化学情诊断分析
智能技术能够支持更精准高效地开展知识盲点分析、知识状态分析、学科能力分析和情感态度太细，帮助教师精准把握学生在知识基础、认知结构、认知能力和学习动机等多方面的起点水平和需要，为明确教学名表提供依据。
如在知识状态分析中，基于知识图谱技术，可以将学生多次在某知识模块内的测试表现与知识结构建立关联，并通过建模分析将学生对于不同知识的掌握情况分为不同级别，这样教师能够明晰学生在某一知识模块中的知识点掌握状态及知识点之间的相互关系，进一步基于学生知识掌握实然与应然状态间的差距来精准设定教学目标。
（2）弹性化教学目标预设
班级学情画像、学习者画像等智能技术能够更精准高效地识别不同学生群体的共性特征和差异化需求，支持教师综合考虑班级教学目标和个体学习目标设定更加弹性化的教学目标。
如在基于学习者画像设定差异化目标方面，智能技术支持对学生各项学习行为和结果数据的全面采集与智能分析,通过对学生特征和行为标签集的提炼来建构多方位、多层次学习者画像。基于学习者画像，教师一方面可以通过学习者画像的分类标签来识别不同学生群体以设计分层化学习目标，还能够瞄准每一位学生的不同表现和差异需求来生成个性化学习目标，实现教学目标差异化和个性化预设。
3.3精准化教学目标设计
教学资源设计是教学设计的重要组成部分，是教师对资源进行选择与开发使之形成适用于教学目标和教学实施要求的优质教学资源的过程，主要包括收集文字、图片、视频、课件等素材，以及对素材进行筛选、整理、处理、加工等操作。
教学资源设计是教学设计的重要组成部分，是教师对资源进行选择与开发使之形成适用于教学目标和教学实施要求的优质教学资源的过程，主要包括收集文字、图片、视频、课件等素材，以及对素材进行筛选、整理、处理、加工等操作。目前教学资源设计实践中，还不同程度地存在资源获取效率低、个性化开发难度大以及资源组织无序、筛选应用不便等诸多问题，使得教师无法便捷高效地设计准备适用的教学资源。
大数据、云计算等智能技术可以帮助教师进行有效的教学资源收集、加工和组织设计，减轻教师备课负担，提高备课效率。具体主要体现在三个方面:①提升资源获取的便捷性;②提高资源组织的有序性;③减轻资源开发制作负担。
教学资源设计通常包括收集、加工、整理等过程，智能技术支持下的教学资源设计主要体现在便捷化教学资源获取、体系化教学资源整理和智能化教学资源制作等典型应用场景中，具体如下。
（1）便捷化教学资源获取
在智能技术支持下，资源设计过程可以实现一站式汇聚、便捷化共享、多终端下载、智能化同步以及个性化推荐，由此减轻教师资源获取负担，提高教师资源获取效率。
如在教学资源智能搜索与推荐方面，通过智能搜索等技术能够对搜索关键词进行分词处理，并建立数据源索引，帮助教师实现精准搜索。通过智能推荐等技术，能够根据教师个人资源偏好进行资源智能推荐，或根据班级和学生个人的学科知识点掌握情况，精准匹配适合的教学资源，从而帮助教师缩小资源搜索范围，提高资源获取效率。
（2）体系化教学资源整理
在智能技术的支持下，教师通过教学资源标签自动化生成工具和可视化资源目录导航等，可以查看清晰明了的资源逻辑关系，选取适用的教学资源，提高资源准备效率。
如在资源可视化导航方面，通过知识地图等技术，可以将各分类之间或者知识点之间的关系进行可视化的展示，形成具有结构层次的可视化教学资源目录，并按照类别、知识点等逻辑关系呈现对应的教学资源。教师可以根据授课需要，利用可视化的教学资源目录查看、选用合适的教学资源，提高教学资源选取应用的便捷性。
（3）智能化教学资源制作
在智能技术的支持下，教师可以利用智能化内容制作工具对资源进行便捷化智能化加工处理，提高资源制作效率。
如在教学课件便捷制作方面，教师可以利用课件制作模板、模板化 Flash 工具、整合文字转语音工具以及动画人物设计工具等，实现多样化课件素材的便捷制作与设计，可以通过课件插件工具、资源链接工具，即时便捷地添加形式丰富的教学活动内容(如分类、连线、选词填空、画廊、语言学科评测练习等)、在线或本地资源库的教学资源等，提高课件制作的效率。
报告来源：科大讯飞
报告编辑：BFT机器人
更多精彩内容请关注公众号：BFT机器人
本文为原创文章，版权归BFT机器人所有，如需转载请与我们联系。若您对该文章内容有任何疑问，请与我们联系，将及时回应。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd1e2c6dd0afd18d4cdf3c924142214/" rel="bookmark">
			ChatGPT是否可以生成代码或编程语言？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是的，ChatGPT可以用于生成代码或编程语言的片段。作为一个强大的语言模型，它在许多领域展示了很强的生成能力，包括自然语言处理、文本摘要、翻译等。然而，需要明确的是，生成的代码质量和可用性取决于模型的训练数据和任务设置。
首先，ChatGPT的训练数据包含了大量的开源代码、技术文档、博客文章等与编程相关的内容。这些数据使得模型可以学习到编程语言的语法、规则和常见的代码模式。它可以理解变量、函数、条件语句、循环等基本编程概念，并在生成代码时遵循这些概念。
其次，GPT-3.5架构的设计使得模型能够捕捉长期依赖关系和上下文信息，这对于生成代码非常重要。编程语言通常具有严格的语法和结构要求，而GPT-3.5模型的自注意力机制和前馈神经网络可以帮助模型记住先前的上下文并生成与之一致的代码。这使得模型能够生成连贯、合法的代码片段。
当然，生成代码是一个具有挑战性的任务，涉及到多种因素和复杂性：
1. 语言和框架的多样性：编程世界中有多种编程语言和框架可供选择，每种语言都有其独特的语法和规则。对于一个通用的语言模型如ChatGPT来说，它可以尝试生成多种编程语言的代码，但在特定语言或框架上的生成可能会更受限制。
2. 语法和语义的准确性：生成的代码需要符合编程语言的语法规则，以确保代码的正确性。此外，代码的语义也需要符合预期的逻辑和功能。尽管ChatGPT具有一定的语法和语义理解能力，但它仍然有可能生成不合法的代码或具有错误逻辑的代码。
3. 上下文的理解和利用：生成有效的代码需要考虑到上下文信息，如变量、函数、类等之前的定义和使用。ChatGPT在某种程度上可以记住先前的上下文并应用于生成代码，但在复杂的编程任务中，模型可能会遇到挑战并产生不准确或错误的结果。
4. 缺少实际执行和测试：生成的代码可能在语法上是正确的，但在实际执行中可能存在问题。编程过程通常涉及到调试和测试，以确保代码的正确性和
性能。然而，ChatGPT并不具备实际执行代码的能力，它只能根据训练数据中的模式和规则生成代码。因此，生成的代码可能需要经过人工的检查、测试和调整，以确保其可用性和正确性。
尽管存在这些挑战和限制，但ChatGPT在一些简单的编程任务上可以提供有用的代码片段和解决方案。例如，它可以生成基本的变量赋值、条件语句、循环结构等。对于一些常见的编程问题，如字符串处理、列表操作、简单算法等，模型可以生成相对合理的代码示例。
另一方面，对于更复杂的编程任务和领域特定的问题，ChatGPT的生成结果可能不够准确或满足要求。在这些情况下，通常需要对生成的代码进行修改、扩展或优化，以适应具体的需求和约束。
为了提高生成代码的质量和可用性，有一些方法可以尝试：
1. 数据预处理和训练数据的准备：通过选择高质量的编程相关数据，并进行预处理和清洗，可以提高模型对编程语言和模式的理解。精心策划的训练数据可以包含多个编程语言和领域的示例，以增加模型的多样性和覆盖范围。
2. 针对特定任务的Fine-tuning：将模型进行进一步的Fine-tuning，以适应特定的编程任务或领域。通过在相关的任务上进行Fine-tuning，模型可以更好地理解特定问题的上下文和约束，生成更适合的代码片段。
3. 控制生成的策略和约束：通过引入一些约束和提示，可以控制生成的代码的特定属性。例如，可以引入特定的函数、库或语言特性的提示，以确保生成的代码满足特定需求或遵循特定规范。
4. 结合人工的审查和修改：生成的代码应该经过人工的审查、测试和修改。专业的开发人员可以检查并修正生成的代码，确保其质量和可用性。这样的人机合作可以提高生成代码的质量，并弥补模型在编程理解和实际执行方面的不足。
需要强调的是，尽管ChatGPT可以生成一些代码片段，但在真正的编程任务中，仍然需要结合人类的专业知识和判断来编写高质量的代码。人类程序员的经验和洞察力是无法替代的，他们可以深入理解问题的本质和需求，并设计出更加优雅、高效的解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/698fea190462dec63c31de9f38dae42e/" rel="bookmark">
			STM32 HAL库开发——基础篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、基础知识
1.1 Cortex--M系列介绍
1.2 什么是stm32
1.3 数据手册查看
1.4 最小系统和 IO 分配 1.4.1 电源电路
1.4.2 复位电路
1.4.3 BOOT 启动电路
1.4.4 晶振电路
1.4.5 下载调试电路
1.4.6 串口一键下载电路 1.4.7 IO 分配 1.4.8 总结 1.5 开发工具
1.6 下载
二、 代码、工程相关
2.1 文本美化
2.2 代码编辑技巧
2.3 查找&amp;替换技巧
三、c语言基础复习 3.1 stdint.h 3.2 位操作
3.3 宏定义
3.4 条件编译 3.5 exturn 声明
3.6 类型别名（typedef） 3.7 结构体
3.8 指针
3.9 代码规范
四、STM32基础知识
4.1 Cortex M内核 &amp; 芯片 4.2 F1 框架
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/698fea190462dec63c31de9f38dae42e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d305484d936dfda5e342c043d7ad8fb6/" rel="bookmark">
			uboot使用，uboot常见指令。MobaXterm的安装和使用，通过串口连接虚拟机和开发板。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文以是三星tiny4412芯片为例，操作系统为Linux。
一、uboot 1.uboot相关的基础概念 开发板启动的时候必须启动操作系统，要想启动操作系统，必须要有运行的环境，必须要有外挂的内存，在开发板上电，初始化完DRAM之后具备了内存，操作系统还存在于外部存储SD/eMMC，要想运行操作系统 ，就必须将操作系统加载到内存里，能将操作系统搬运到DRAM里的就是引导程序，这就需要用到uboot。
uboot是一个开源的免费的项目，uboot在github上的源码 。
2.uboot的重要文件夹 uboot源码包解压后的目录\uboot_tiny4412-sdk1506
arch(架构)：
\uboot_tiny4412-sdk1506\uboot_tiny4412-sdk1506\arch\arm\cpu\armv7\exynos，三星公司放的初始化外设的代码。
\uboot_tiny4412-sdk1506\uboot_tiny4412-sdk1506\arch\arm\cpu\armv7/Start.s，uboot启动第一个程序。
board（板级资源）：
\uboot_tiny4412-sdk1506\uboot_tiny4412-sdk1506\board\samsung\tiny4412，友善之臂田间初始化的代码。
boards.cfg：
uboot所支持的开发板的名字，这个配置文件里有很多种开发板的名字，要想适配某个开发板，make 开发板的名字_config，比如想要适配tiny4412，在根目录执行make tiny4412_config。
doc：
帮助文档 纯英文的。
sd_fuse：
友善之臂提供的一些工具，BL1偶校验的文件。
3.uboot的配置和编译 在刚刚下载好的uboot根目录下执行：make tiny4412_config，执行完这个命令之后 uboot就会适配tiny4412开发板。
编译的步骤
1.将uboot的压缩包拷贝到虚拟机里。
2.解压压缩包。
tar xvf uboot_tiny4412-sdk1506.tar.bz2 3.进入解压缩后的目录
4.配置uboot
make tiny4412_config 5.编译uboot
make 表示使用单核单线程编译，速度比较慢。
make -jn n表示线程的个数加1 ，n为1,2,3....，根据分给操作系统的资源来定。
编译完成之后 会生成一个文件u-boot.bin，这个文件就是我们后续要使用得uboot得文件。
4.uboot的烧写和使用 最终编译出来得u-boot.bin(271k)，但bl2最大只能存放14k得内容，IRAM也不够uboot得启动，BL2还得必须将DRAM驱动起来。所以uboot可以被分成两部分，前14k是一部分放到BL2得位置用于初始化DRAM 将剩余的uboot搬运到DRAM里并运行，uboot启动完成之后 开始搬运操作系统。
1.进入sd_fuse目录
先执行 make clean，再执行 make 生成mkbl2。
2.将生成的mkbl2拷贝到上一级目录
cp ./mkbl2 ../ 3.进入到上级目录，执行
cd ../ ./mkbl2 u-boot.bin bl2.bin 14336 4.将sd卡插入到电脑上并且让虚拟机识别,执行烧录BL2命令
sudo dd iflag=dsync oflag=dsync if=.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d305484d936dfda5e342c043d7ad8fb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/046271e07ec40fc0afd4025a17160a4b/" rel="bookmark">
			大数据技术原理笔记-考点版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课本参考林子雨老师的大数据技术原理与应用 第三版
第一章 大数据概述 1.大数据定义及4V特点 Page 8-10，4个特点都要深入理解 （1）数据量大：“数据爆炸”成为大数据时代的鲜明特征
（2）处理速度快：数据生成到消耗的时间窗口小，用于决策的时间少；数据处理和分析的速度通常要达到秒级响应。
（3）数据类型繁多：大数据数据类型丰富，总体分为结构化和非结构化数据两类
（4）价值密度低：价值密度低，商业价值高
2.大数据对思维方式的重要影响 Page 12 （1）全样而非抽样
​ 过去：数据存储和处理能力限制，采用抽样
​ 现在：分布式文件系统和分布式计算模型提供了强大的数据存储和处理能力，采用全样
（2）效率而非精确
​ 过去：由于采用抽样分析，为限制误差放大，需要追求分析方法的精确性
​ 现在：采用全样分析，不存在误差放大问题；大数据要求实时分析结果，需要追求效率
（3）相关而非因果
​ 过去：重视因果关系
​ 现在：更注重相关性
3.大数据四大计算模式解决的问题，以及代表产品 Page 17 4.什么是流数据？流计算框架与平台分类 Page 17 （1）定义：流数据是指在时间分布和数量上无限的一系列动态数据集合体，数据的价值随着时间的流逝而降低，因此必须采用实时计算的方式给出秒级响应。
（2）作用：流计算可以实时处理来自不同数据源的、连续到达的流数据，经过实时分析处理，给出有价值的分析结果。
（2）分类
​ 1）商业级流计算平台
​ 2）开源流计算框架
​ 3）公司为支持自身业务开发的流计算框架
5.云计算、物联网定义 Page 19, Page 23 （1）云计算：云计算通过网络提供可伸缩的、廉价的分布式计算能力，用户只需接入网络就可以获得所需的各种IT资源
（2）物联网：物联网是物物相连的互联网，是互联网的延伸，它利用局部网络或互联网等通信技术把传感器、控制器、人员和物等通过新的方式联在一起，形成人与物、物与物相联，实现信息化和远程管理控制
6.大数据、云计算、物联网三者关系与区别 Page 27 （1）关系
（2）区别
​ 1）大数据侧重于对海量数据的存储、处理和分析，从海量数据中发现价值
​ 2）云计算旨在整合和优化IT资源，通过网络方式廉价提供给用户
​ 3）物联网的发展目标是实现“物物相连”，应用创新是物联网发展的核心
第二章 Hadoop 1.Hadoop生态系统两大核心组件？Page 29 分布式文件系统HDFS（Hadoop Distributed File System）和MapReduce计算模型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/046271e07ec40fc0afd4025a17160a4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd470563f42355a65c0b08c23bd6aec0/" rel="bookmark">
			Verilog/C&#43;&#43;实现排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Verilog/C++实现排序算法 1、冒泡排序算法 冒泡排序是一种简单的交换类排序。
冒泡排序算法的原理如下：
1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。2、对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。3、针对所有的元素重复以上的步骤，除了最后一个。4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。
1.1、C++实现代码如下： //交换 a 和 b 的位置 void swap(int *a, int *b) { int temp; temp = *a; *a = *b; *b = temp; } //冒泡排序实现函数，从输出结果，可以看到冒泡的具体实现流程 void BubSort_test(int *a, int N) { for (int i = 0; i &lt; N; i++) { //对待排序序列进行冒泡排序 for (int j = 0; j + 1 &lt; N - i; j++) { //相邻元素进行比较，当顺序不正确时，交换位置 if (a[j] &gt; a[j + 1]) { swap(&amp;a[j], &amp;a[j + 1]); } } /*///-------输出本轮冒泡排序之后的序列---------- printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd470563f42355a65c0b08c23bd6aec0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f45dbf70bd8f78d2662bdc0556fb1fb8/" rel="bookmark">
			getopt() / getopt_long()命令行参数解析函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
命令行参数
getopt()函数
getopt函数的参数
全局变量：
实例使用：
运行结果
getopt_long()函数
getopt_long函数的参数
实例使用
参考文章
命令行参数 getopt() / getopt_long() 均用来对命令行参数进行解析。getopt()处理参数，getopt_long()用来处理长参数。
图1 命令行参数
命令行参数由Command name，Option，Option argument 以及Operands组成。
Command name：程序的名称。
Option：选项，它是用来用来决定程序的行为。
​​​Option argument：选项参数，是选项Option所需要的信息。
Operands：操作对象,可以为NULL。
举例：
./a.out -a abc //Command name：a.out
//Option: a
//Option argument: abc
//Operands: null
./a.out -a abc def
//Command name：a.out
//Option: a
//Option argument: abc
//Operands: def
getopt()函数 #include &lt;unistd.h&gt; int getopt(int argc, char * const argv[], const char *optstring); extern char *optarg; extern int optind, opterr, optopt; getopt函数的参数 参数argc和argv：通常是从main的参数直接传递而来，argc是命令行参数的数量，argv是一个常量字符串数组的地址。 argc为命令行参数个数，包含了Command name，Option，Option argument 以及Operands。argv[0]为程序名；argv[1]到argv[argc -1]为该程序命令行参数；argv[argc]为空。 参数optstring：一个包含正确选项字符的字符串。 单个字符，表示该选项Option不需要参数。"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f45dbf70bd8f78d2662bdc0556fb1fb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed8c2d0044f006416bc1ead4c8c09036/" rel="bookmark">
			QString中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QString中文乱码问题 乱码问题通常会在有中文的时候出现，有两种写法可以避免乱码：
QString str1 = QString::fromLocal8Bit("你好"); QString str2 = QStringLiteral("你好"); 通常情况下，需要中文的QString串的时候会使用这两种写法，且比较推荐QStringLiteral宏的方式进行创建
fromLocal8Bit使用 在Qt中，fromLocal8Bit()是QString类的一个成员函数，用于将本地编码（Local 8-bit）的字符串转换为QString对象。它的使用方法如下：
QByteArray localData = "你好"; // 本地编码的字符串 QString str = QString::fromLocal8Bit(localData); // 将本地编码的字符串转换为QString对象 在上述示例中，我们首先将本地编码的字符串存储在QByteArray对象中，然后使用fromLocal8Bit()函数将其转换为QString对象。
该函数的目的是解决在不同平台和不同编译环境中使用本地编码时可能出现的字符集问题。它会自动根据当前环境的本地编码进行字符集转换，以正确地表示字符串。
需要注意的是，fromLocal8Bit()函数只能用于处理本地编码的字符串，而不适用于其他编码格式。如果您的字符串使用的是其他编码，例如UTF-8或GBK，可以使用其他适当的函数进行转换，如fromUtf8()或fromUtf16()。
QByteArray utf8Data = "你好"; // UTF-8编码的字符串 QString str = QString::fromUtf8(utf8Data); // 将UTF-8编码的字符串转换为QString对象 QByteArray gbkData = "你好"; // GBK编码的字符串 QString str = QString::fromLocal8Bit(gbkData); // 将GBK编码的字符串转换为QString对象 从不同编码转换为QString时，确保使用适当的函数来处理相应的编码格式，以保证正确的字符集转换。
QStringLiterial使用 QStringLiteral是Qt提供的一个宏，用于创建编译时优化的QString对象，以提高性能和减少内存使用。下面是QStringLiteral的使用方法：
创建QString对象： QString str1 = QStringLiteral("Hello"); // 直接使用QStringLiteral创建字符串 QString str2 = QStringLiteral("World"); 字符串拼接： QString str = str1 + QStringLiteral("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed8c2d0044f006416bc1ead4c8c09036/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc55c63b279f407b38d9ab322b3bd648/" rel="bookmark">
			手机屏幕的DPI和PPI有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么有的手机厂商在屏幕参数一栏标注PPI，而有的手机却标注DPI？这其中又有什么猫腻呢，不同的标注方法会对手机产生那些影响？
PPI和DPI的区别是什么，分别都是如何计算的？对你的视觉体验会产生多大的影响呢？
① DPI即dot per inch
DPI所代表的含义是：
DPI表示分辨率，指每英寸长度上的点数。DPI又可细分为水平分辨率和垂直分辨率，例如一张1英寸x1英寸的图片，如果它的水平分辨率是100dpi，垂直分辨率是50dpi，那么就是说，它水平方向每英寸分成100小段，垂直方向每英寸分成50小段，就像米尺上的一格格那样。这种图片总共有100x50=5000个格子，这张图片总共有5000像素。由于它的水平分辨率和垂直分辨率不相等，所以每个像素是一个微小的长方形。
通常是与照片和打印挂钩。
② ppi（像素密度）
每英寸屏幕所拥有的像素数。然而这个每英寸并不是每平方英寸的简称，也是对角线的长度。所以，我们可以这么理解屏幕像素密度，即在一个对角线长度为1英寸的正方形内所拥有的像素数。
图片ppi值越高，画面的细节就越丰富，因为单位面积的像素数量更多。
一般来说，手机屏幕距离眼睛10-12英寸时，分辨率达到一定水平，屏幕PPI只要达到300PPI，人眼视网膜就无法分辨出像素点了，这样的屏幕被称为“视网膜屏幕”。
计算方法
是长宽各自平方之和开方，除以对角线长度即屏幕尺寸(单位英寸)。原理可以自己画个矩形勾股定理算一算。
例如4.7英寸的iPhone7，屏幕分辨率是1334x750，那么它的像素密度即PPI的计算方法如下：
下面是官方数据与笔者实际计算一致
区别在于
PPI是该手机最高质量的画质参数，虽说你可以通过Root等手段修改像素密度。图片的ppi无法反映这张图片能在冲印店得到的冲印质量。
DPI是手机图片输出的一个衡量标准，一般用于图片打印时调节参数。针对特定的图片而言，图片的像素是固定的，所以，打印分辨率和打印尺寸便呈现反比的关系。
DPI是开发时候用的，相当于是安卓强行规定，跟我们平时所谓的ppi(像素密度)不一样，这里所说的dpi，一般都被用于字体等大小的修改。这就是为什么厂家标注参数是PPI，而在跑分软件上会显示DPI。
有很多人将二者混为一谈，错把PPI的计算方法当成DPI的计算方法，这显然是不对的，一般消费者根本不能分清两者的概念，网上关于手机DPI的解释又很少，所以有些商家会故意选用数字大的参数标出，当然也不排除某些网站在参数标注时出现概念混淆的情况。
大多数手机厂商都会使用PPI作为参数，因为PPI有简单的公式计算，方便可靠。
例如笔者这台5.7英寸1080x1920的手机，PPI计算值为386，DPI计算值为480，假若手机厂商在参数中没有使用PPI而是使用DPI(屏幕密度)，那么容易误导不知情消费者认为这款手机的显示水平很高。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/121/">«</a>
	<span class="pagination__item pagination__item--current">122/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/123/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>