<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45fbbe17a3083bc9c97edf5fd1560061/" rel="bookmark">
			curl命令进行接口测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候会遇到一些需求：后端先写功能接口，前端后面再做，这样在灰度发版的时候怎么验证生产接口功能？
1、接口自动化
2、postman直接调用生产接口
3、curl命令测试接口
今天重点是方法3
一、curl命令的介绍：
Windows环境上有很多接口测试的工具，如soapui、postman等，但这些工具在linux平台上使用起来相对不那么便捷。
建立在linux平台的接口可通过curl工具实现。
工作中呢，我们通常都是通过xshell链接linux服务器的，那么对于接口的测试，可以直接再xshell上实现，链接对应的服务器，直接输入curl命令即可。
1.1 curl 常用的参数
-X/--request [GET|POST|PUT|DELETE|…] 使用指定的http method发出 http request
-H/--header 设定request里的header
-i/--include 显示response的header
-d/--data 设定 http parameters
-v/--verbose 輸出比较多的信息
-u/--user 使用者账号
-b/--cookie cookie 文件路径 使用cookie
1.2 curl命令也可以通过postman自动来生成
二、如何测试接口
1、测试get请求
$ curl http://www.linuxidc.com/login.cgi?user=test001&amp;password=123456
2、测试post请求
$ curl -d "user=nickwolfe&amp;password=12345" http://www.linuxidc.com/login.cgi
3、以json数据为例
方式一：发送磁盘上面的JSON文件（推荐） curl -X POST -H 'content-type: application/json' -d @/apps/myjsonfile.txt http://192.168.129.xx/AntiRushServer/api/ActivityAntiRush
方式二：在命令行直接发送JSON结构数据 curl -H 'content-type: application/json' -X POST -d '{"accountType":"4","channel":"1","channelId":"YW_MMY","uid":"13154897541","phoneNumber":"13154897541","loginSource":"3","loginType":"1","userIp":"192.168.2.3","postTime":"14633fffffffffff81286","userAgent":"Windows NT","imei":"352600051025733","macAddress":"40:92:d4:cb:46:43","serialNumber":"123"}' http://192.168.129.xx/AntiRushServer/api/ActivityAntiRush
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45fbbe17a3083bc9c97edf5fd1560061/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21005c2211906ecbfb57ce5914517fba/" rel="bookmark">
			hive加减月份，获取上个月日期（前几个月）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1，如果拿到的日期格式不是标准格式(yyyy-MM-dd HH:mm:ss)，先转成时间戳。
select unix_timestamp('202105', 'yyyyMM') from ****; --返回结果：1619798400 2，再将时间戳转成标准时间格式。
select from_unixtime(unix_timestamp('202105', 'yyyyMM'), 'yyyy-MM-dd HH:mm:ss') from ***; --返回结果：2021-05-01 00:00:00 3，调用add_months函数，负数代表往历史方向减月份， 正数代表往未来方向加月份。
select add_months(from_unixtime(unix_timestamp('202105', 'yyyyMM'), 'yyyy-MM-dd HH:mm:ss'), -1) from ***;
--返回结果：2021-04-01
4，再将日期转成时间戳格式
select unix_timestamp(add_months(from_unixtime(unix_timestamp('202105', 'yyyyMM'), 'yyyy-MM-dd HH:mm:ss'), -1), 'yyyy-MM-dd') from ***; --返回结果：1617206400 5，设置日期模板，转换成最终想要的日期格式
select from_unixtime(unix_timestamp(add_months(from_unixtime(unix_timestamp('202105', 'yyyyMM'), 'yyyy-MM-dd HH:mm:ss'), -1), 'yyyy-MM-dd'), 'yyyyMM') from ***; --返回结果：202104 6.当前 时间上个月
select add_months(CURRENT_DATE,-2) from **; --返回结果：2021-03-10 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8414327a1ef074eb170c0246b429ce30/" rel="bookmark">
			微信小程序仿支付宝账单列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		支付宝是咋做的 咱也不知道 先把效果实现了再说 效果图如下: js代码 后端根据最后的时间 向后查询size条数据
getData() { const params = { page: 1, size: 10, type: this.data.navActive + 1 } const list = this.data.dateList; if (list.length &lt;= 0) { const month = moment().format('YYYY-MM'); this.setData({ dateList: [{ month, count: 0, list: [] }] }) this.getMonthCount(month, 0); params.beginAt = moment().format('YYYY-MM-DD HH:mm:ss'); } else { // 有效月份 const validMonths = this.data.dateList.filter(item =&gt; item.list.length &gt; 0); // 有效月份的最后一条数据索引 const lastIndex = validMonths[validMonths.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8414327a1ef074eb170c0246b429ce30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71f87359f1fbe28c1b79be7059e54bbc/" rel="bookmark">
			Android开发之——开发中的错误及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 概述 开发工具升级，依赖库，运行环境(jdk)等都会造成项目运行出现错误掌握开发中常见错误现象和问题及解决办法，能节省时间本文将不定期更新 二 错误类 2.1 Cannot inline bytecode built with JVM target 1.8 现象 Cannot inline bytecode built with JVM target 1.8 into bytecode that is being built with JVM target 解决方案 android { ... compileOptions { sourceCompatibility = 1.8 targetCompatibility = 1.8 } kotlinOptions { jvmTarget = "1.8" } } 2.2 Unable to find EOCD signature 现象1 Execution failed for task ':app:packagexxxxRelease'. &gt; A failure occurred while executing com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71f87359f1fbe28c1b79be7059e54bbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b7a3a2a4215fcf65c8af4187374287/" rel="bookmark">
			C#创建并使用DLL文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.创建DLL文件 1.新建C#类库项目 2.编写代码 using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace MyLibrary { public class Class1 { public string getMsg() { return "Message"; } } } 3.生成DLL文件 右键MyLibrary项目，点击生成，生成dll文件。或者选中MyLibrary按F6键生成dll文件。生成的dll文件路径为：…\MyLibrary\bin\Debug\MyLibrary.dll
二.使用DLL文件 1.新建C#窗体应用程序 2.添加DLL引用 右键MyApplication-添加-新建文件夹。新建lib文件夹，存放刚才已经生成的dll文件。
将生成好的dll文件复制到lib文件夹下。
右键MyApplication-添加引用-浏览-lib-MyLibrary.dll，然后点击确定。
接着就可以看见MyLibrary引用已经添加进来了。
3.编写代码使用库文件 右键Form1-查看代码
添加代码
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using MyLibrary; namespace MyApplication { public partial class Form1 : Form { public Form1() { InitializeComponent(); Class1 class1 = new Class1(); Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25b7a3a2a4215fcf65c8af4187374287/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f40f2bcb1ccac0e0a46790c7ee5db93/" rel="bookmark">
			React中使用img
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方式1.先根据路径引入，然后当作变量使用
import logo from '../assets/logo.png' //... &lt;img src={logo} alt='logo'/&gt; 方式2.使用require
&lt;img src={require('../assets/logo.png')} alt='logo'/&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/997ceaa2cb665b8972d0e779cf383cb2/" rel="bookmark">
			android定位源码 demo,LocationDemo(Android定位)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码:
public class LocationUi extends BaseUi implements View.OnClickListener, LocationListener {
private Button mBtnStartLocation;
private Button mBtnStopLocation;
private TextView mTvLocation;
private LocationManager mLocationManager;
@Override
protected void initView() {
setContentView(R.layout.ui_location);
mBtnStartLocation = (Button) findViewById(R.id.location_btnStartLocation);
mBtnStopLocation = (Button) findViewById(R.id.location_btnStopLocation);
mTvLocation = (TextView) findViewById(R.id.location_tvLocation);
}
@Override
protected void initData() {
}
@Override
protected void initListener() {
mBtnStartLocation.setOnClickListener(this);
mBtnStopLocation.setOnClickListener(this);
}
@Override
public void onClick(View v) {
switch (v.getId()) {
case R.id.location_btnStartLocation:
openGPSSettings();
break;
case R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/997ceaa2cb665b8972d0e779cf383cb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d8f2d7fedaaefa35e5eeb2d6b075090/" rel="bookmark">
			移动端iphone抓包调试神器—Stream安装和使用（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前已经给大家分享了很多抓包工具的文章了，如果觉得有用，记得分享！！！
Fiddler抓取APP请求（环境搭建）之mama再也不用担心抓不到包了
Fiddler抓包神器带你遨游网络，叱咤风云，为所欲为
【Fiddler篇】FreeHttp无限篡改http报文数据调试和mock服务
【Fiddler篇】抓包工具之Filters（过滤器）进行会话过滤
【Fiddler篇】Stave插件之环境映射
Fiddler Everywhere全平台抓包调试工具安装和使用（一）
【Jmeter篇】你有Fiddler Charles，我有Jmeter录制Web和App
stream是一款免费轻量级移动端ios抓包调试工具，配置方便无需设置代理，集成了HTTP抓包、构建请求、Hosts 设置、常用工具、数据导出等功能。
1、苹果手机appstore搜stream并下载
2、进入抓包工具，允许配置VPN，下载CA证书
3、设置-通用-描述文件，找到下载好的证书，安装成功
4、设置-通用-关于手机-证书信任设置，开启信任
5、点开始抓包，进入要抓包的app美团外卖，抓好包后 停止抓包
6、进入抓包历史，查看抓包信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51487e5eab4c880b027d359a2a89e7c3/" rel="bookmark">
			熬夜怒肝，图解算法！BFS和DFS的直观解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 我们首次接触 BFS 和 DFS 时，应该是在数据结构课上讲的 “图的遍历”。还有就是刷题的时候，遍历二叉树我们会经常用到BFS和DFS。它们的实现都很简单，这里我就不哆嗦去贴代码了。
想看代码的可以看《剑指Offer（三十八）：二叉树的深度》这个题目就可以利用BFS和DFS进行求解。那么，这两者“遍历” 的序列到底有何差别？
本篇文章就单纯来讲讲它们的区别和各自的应用，不会涉及任何代码。我们以“图的遍历”为例，进行说明。
二、区别 广度优先搜索算法（Breadth-First-Search，缩写为 BFS），是一种利用队列实现的搜索算法。简单来说，其搜索过程和 “湖面丢进一块石头激起层层涟漪” 类似。
深度优先搜索算法（Depth-First-Search，缩写为 DFS），是一种利用递归实现的搜索算法。简单来说，其搜索过程和 “不撞南墙不回头” 类似。
BFS 的重点在于队列，而 DFS 的重点在于递归。这是它们的本质区别。
举个典型例子，如下图，灰色代表墙壁，绿色代表起点，红色代表终点，规定每次只能走一步，且只能往下或右走。求一条绿色到红色的最短路径。
对于上面的问题，BFS 和 DFS 都可以求出结果，它们的区别就是在复杂度上存在差异。我可以先告诉你，该题 BFS 是较佳算法。
BFS示意图：
如上图所示，从起点出发，对于每次出队列的点，都要遍历其四周的点。所以说 BFS 的搜索过程和 “湖面丢进一块石头激起层层涟漪” 很相似，此即 “广度优先搜索算法” 中“广度”的由来。
DFS示意图：
三、总结 现在，你不妨对照着图，再去看看你打印出的遍历序列，是不是一目了然呢？
最后再说下它们的应用方向。
BFS 常用于找单一的最短路线，它的特点是 "搜到就是最优解"，而 DFS 用于找所有解的问题，它的空间效率高，而且找到的不一定是最优解，必须记录并完成整个搜索，故一般情况下，深搜需要非常高效的剪枝（剪枝的概念请百度）。
PS：BFS 和 DFS 是很重要的算法，读者如果想要更深入地了解它们，建议去 OJ 或 Leetcode 上找一些相关赛题训练下，一定会给你一个别样的天地。
如上图所示，从起点出发，先把一个方向的点都遍历完才会改变方向...... 所以说，DFS 的搜索过程和 “不撞南墙不回头” 很相似，此即 “深度优先搜索算法” 中“深度”的由来。
最后再送大家一本，帮助我拿到 BAT 等一线大厂 offer 的数据结构刷题笔记，是一位 Google 大神写的，对于算法薄弱或者需要提高的同学都十分受用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51487e5eab4c880b027d359a2a89e7c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6e34c7d80a331b85748dd000b545c4b/" rel="bookmark">
			android的事件传递机制,android 事件传递机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于事件都来自于触摸屏幕上的各个组件，简单的组件，例如TextView,Button等继承自View,复杂的组件如LinearLayout,ListView等继承自ViewGroup，而且ViewGroup也是继承了View的。
View中与触摸相关的方法如下：
boolean dispatchTouchEvent(MotionEvent event)
boolean onTouchEvent(MotionEvent event)
ViewGroup中与触摸相关的方法如下：
boolean dispatchTouchEvent(MotionEvent event)
boolean onTnterceptTouchEvent(MotionEvent event)
boolean onTouchEvent(MotionEvent event) (该方法在ViewGroup中没有重写，是继承了View的)
在Activity中也有相关的方法如下：
boolean dispatchTouchEvent(MotionEvent event)
boolean onTouchEvent(MotionEvent event)
事件传递的流程简介如下：
三者都是类似的，先执行 dispatchTouchEvent ,(若有onInterceptTouchEvent则执行onInterceptTouchEvent,返回false，则传递给孩子，返回true,则自己执行 (onTouch) onTouchEvent (onClick)) 为什么是上面的顺序，分别去看View,ViewGroup,Activity中的源码就晓得啦
在程序中是先执行Activity中的这些方法，再执行最外层的ViewGroup中的这些方法，最后执行View中 的这些方法
为什么是这个顺序，我也不知道，还要再继续查查
总结:
1. dispatchTouchEvent 是为了执行onTouch，onTouch返回false,才会继续执行onTouchEvent, onTouchEvent 是为了执行onClick
2. 以上的方法，若返回true,则表示自己处理，不向下传递，返回false，则表示继续向下传递去处理，自己不做处理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe0b92f87094a802eb84e12c79a216a/" rel="bookmark">
			android8.0 no system,Android8.0及其以上版本获取序列号时报：Access denied finding property &#34;ro.serialno&#34;...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法：
先说解决办法：android 8.0 及其以上的用这种方法获取序列号：Build.getSerial();
原因：
我需要手机的序列号一开始我是通过下面这个方法获取的序列号
/**
* 序列号
*
* @return
*/
public static StringgetSerialNumber() {
String serial =null;
try {
Class c = Class.forName("android.os.SystemProperties");
Method get = c.getMethod("get", String.class);
serial = (String) get.invoke(c, "ro.serialno");
}catch (Exception e) {
e.printStackTrace();
}
return serial;
}
用这种方式其它手机都行，但是我用华为mate10pro就出先了Access denied finding property "ro.serialno"，还说我没有权限，但是读手机的权限我是给了的。
里面大概说了android O为了更好的管理用户的隐私做了一些调整，比如说刚才的那个问题。并且说在Android的未来版本中，针对Android O的应用会将Build.SERIAL视为“未知，只能通过Build.getSerial();这个方法获取了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b046df06608b7c548003ac21032a7171/" rel="bookmark">
			Java API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Java API一、Object 类1.1 equals 方法1.2 hashCode 方法 二、String类2.1 字符串特性2.2 常见方法API2.3 StringBuilder2.4 StringBuffer 三、包装类2.1 包装类2.2 自动装箱与拆箱 四、Math 类五、random类4.1 random类的使用4.2 小练习 六、UUID类七、时间日期6.1 Date6.2 Calendar6.3 小练习6.4 时间转换6.5 LocalDate6.6 LocalTime6.7 LocalDateTime6.8 时间格式转换 八、System九、正则表达式9.1 Java中的正则表达式基本语法 十、Class 类 Java API API（Application Programming Interface，应用程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。 目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节。
一、Object 类 Object类是Java语言中所有类的根，所有的类都直接或间接的继承了Object类；数组也继承了Object类；Object类中定义了equals方法public boolean equals Object，用来比较两个对象的虚地址，如果虚地址相同则返回true，否则返回false； 1.1 equals 方法 Object类中定义了equals方法public boolean equals( Object obj )，用来比较两个对象的虚地址，如果虚地址相同则返回true，否则返回false；Object类中的equals方法的作用，与==相同，都是比较两个对象的虚地址； 很多类覆盖了equals方法，用来比较两个对象的属性值，如果属性值相同，则认为两个对象相等；例如，String类就覆盖了equlas方法，用来比较两个字符串的字符序列值
package com.singerw.objdet; public class TestStudent { public static void main(String[] args) { Student s1 = new Student(1, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b046df06608b7c548003ac21032a7171/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2e7670c1d3d09c9845608a8ff8a76e7/" rel="bookmark">
			第81节 二维数组的存储及地址表示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、二维数组的存储
1.例如：float a[3][5] 在内存中申请一段连续的内存，按行连续存储数据：
a[0][0],a[0][1],a[0][2],a[0][3],a[0][4],a[1][0],a[1][1],a[1][2],a[1][3],a[1][4],a[2][0],a[2][1],a[2][2],a[2][3],a[2][4]
2.输出二维数组元素的两种方法：
#include &lt;stdio.h&gt; int main() { int a[3][4] = { {1,2,3,4},{11,12,13,14},{21,22,23,24} }; //输出a[2][1]地址： printf("%p\n", &amp;a[2][1]); //直接取元素的地址 printf("%p\n", &amp;a[0][0] + 2 * 4 + 1); //通过首元素地址偏移得到； printf("%p\n", a + 2 * 4 + 1); //错误，二维数组名运算，按行进行加减 } 运行结果： 0095FDC4 0095FDC4 0095FE30 二、深入理解二维数组
1、二维数组看作是元素是一维数组的一维数组
2、例：int a[3][4]；
 可以将 a 看作是一维数组，它有3个元素：a[0],a[1]和a[2]
 每个元素a[i]又是一个包含4个元素的一维数组
 a[i]是一维数组的名字，其值是第i行的起始地址
三、体会下面程序
#include &lt;stdio.h&gt; int main() { int a[3][4] = { {1,2,3,4}, {11,12,13,14}, {21,22,23,24}, }; //这个二维数组可看作是包含三个“数组”元素的一维数组{a[0],a[1],a[2]} //以下四种输出都是元素a[2][3]的地址 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2e7670c1d3d09c9845608a8ff8a76e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cae8069ab25756016337bca86c187e40/" rel="bookmark">
			JS 数组、JS函数 、JS 封装函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.数组为什么要用数组？数组的概念:声明数组的方式：数组的长度： 里面元素的个数。数组的下标（索引）如何获取数组中的元素数组的遍历例： 2.数组方法push()pop()shift()unshift()例： 3.函数什么是函数？使用函数的步骤：函数的分类：函数的优点：调用函数的格式：retrun:【注意】 根据参数与返回值的不同，可将函数分为4种：【注意】 形参：实参：传参：实参与形参个数的关系：例： 3.封装函数封装函数的步骤：例： 5.arguments问题：参数不固定怎么办？ 案例练习 1.数组 为什么要用数组？ 当我们需要一组数据，或者一次性定义很多类似的变量时，我们可以使用数组，提高开发效率。 数组的概念: 一组数据的集合。其中每一个数据叫做元素。在数组中可以放任意类型的元素。 声明数组的方式： 字面量（直接赋值，将值写在[]里面，每一个元素之间用逗号分隔。）通过new 关键字创建数组。 new Array(数组中存放的数据); 例：var arr = new Array(3); 错误理解：声明一个数组，数组中有一个元素，元素的值为3。正确理解：声明一个数组，该数组的长度为3.里面可以放3个元素，此时没有放任何的元素。 【注意】如果数组中只有一个元素，而且这个元素是一个number，使用第二种方式会出现问题。
此时这个number就不是一个数据了， 而是数组的长度。 数组的长度： 里面元素的个数。 数组的长度表示可以放多少个元素。数组名.length 数组的下标（索引） 数组中的数据都是按照次序排列好的，每个值都有编号。这个编号叫做索引或者下标。从0开始，下标的最大值：length-1. 如何获取数组中的元素 获取数组中的元素，需要通过下标。数组变量名[下标] 数组的遍历 将数组的数据一个一个取出来，进行操作。 例： var arr = [88, 90, 59, "80"]; for (var i = 0; i &lt; arr.length; i++) { // console.log(arr[i]); //88 90 59 80 //88 90 59是数字类型 80是字符串类型 } console.log(arr[0]); //88 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cae8069ab25756016337bca86c187e40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ab2cae741b112645837f20471dd1d91/" rel="bookmark">
			android触摸滑动监听,Android 滑动监听的实例详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 滑动监听的实例详解
摘要: ScollBy,ScollTo是对内容的移动,view.ScollyBy是对view的内容的移动
view,ScollTo是对内容的移动(移动到指定位置),view.ScollyBy是对view的内容的移动(移动距离)
在次activity中,当手指点击TextView ,此时是ViewGroup 响应还是TextView响应呢？
代码实践:
在activity中重写onTouchEvent():
public boolean onTouchEvent(MotionEvent event) {
switch (event.getAction()){
case MotionEvent.ACTION_DOWN:
float rawY = event.getRawY();
float y = event.getY();
Log.i(TAG, "rawY: "+rawY+",____"+y);
break;
}
return super.onTouchEvent(event);
}
在textView中添加滑动监听:
imageView.setOnTouchListener(new View.OnTouchListener() {
@Override
public boolean onTouch(View v, MotionEvent event) {
switch (event.getAction()){
case MotionEvent.ACTION_DOWN:
float rawY = event.getRawY();
float y = event.getY();
Log.i(TAG, "imageView_rawY: "+rawY+",____"+y);
break;
}
return false;
}
});
在两个的返回值都是false时:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ab2cae741b112645837f20471dd1d91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fec4dc1cce11a22479c82e470ddf09cb/" rel="bookmark">
			360 android插件化开发,详解Android插件化开发-资源访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态加载技术(也叫插件化技术)，当项目越来越庞大的时候，我们通过插件化开发不仅可以减轻应用的内存和CPU占用，还可以实现热插拔，即在不发布新版本的情况下更新某些模块。
通常我们把安卓资源文件制作成插件的形式，无外乎有一下几种：
zip、jar、dex、APK(未安装APK、安装APK)
对于用户来讲未安装的APK才是用户所需要的，不安装、不重启，无声无息的加载资源文件，这正是我们开发者追求的结果。
但是，开发中宿主程序调起未安装的插件apk，一个很大的问题就是资源如何访问，这些资源文件的ID都映射在gen文件夹下的R.java中，而插件中凡是以R开头的资源都不能访问。究其原因是因为宿主程序中并没有插件的资源，所以通过R来加载插件的资源是行不通的，程序会抛出异常：无法找到某某id所对应的资源。
那么开发中该怎么办呢，今天我们来一起探讨一下插件化开发中资源文件访问的解决方案。
想必大家在开发中都写过类似代码，例如，在主程序访问字符串文件
this.getResources().getString(R.string.app_name);
这里的this，其实就是Context，上下文对象。通常我们的的APK安装路径为：
/data/apk/packagename~1/base.apk
APK启动，Context通过类加载器加载完毕后，会去APK中加载资源文件。想必大家都知道，Activity的工作主要是通过ContextImpl来完成的， Activity中有一个叫mBase的成员变量，它的类型就是ContextImpl。注意到Context中有如下两个抽象方法，看起来是和资源有关的，实际上Context就是通过它们来获取资源的。这两个抽象方法的真正实现在ContextImpl中，也就是说，只要实现这两个方法，就可以解决资源问题了。
/** Return an AssetManager instance for your application's package. */
public abstract AssetManager getAssets();
/** Return a Resources instance for your application's package. */
public abstract Resources getResources();
我们若是想使用这两个方法，需要实例化Context对象，通常我们可以根据APK中的包名完成Context对象的创建：
Context pluginContext = this.createPackageContext("com.castiel.demo",flags);
但是这样做有个前提，必须要求初始化时加载的是自己APK，如果我们加载的是未安装的插件APK，这么做肯定就不可取了。为啥呢，看源码：
Resources resources = packageInfo.getResources(mainThread);
if (resources != null) {
if (activityToken != null
|| displayId != Display.DEFAULT_DISPLAY
|| overrideConfiguration != null
|| (compatInfo !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fec4dc1cce11a22479c82e470ddf09cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a4a62fd82a149a340032bd4faa6d561/" rel="bookmark">
			android:scrollbars代码控制,android:scrollbars属性和弹出键盘的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android:scrollbars属性：自由控件已经超过了布局的大小就会滚动。要看到滚动效果,那你Linear里面的内容长度要超出整屏的高度就能实现滑动
要实现ScrollView滚动条的隐藏，有两种方法:
1、是在XML的ScrollView布局中加入属性android:scrollbars="none"
2、在代码中获取ScrollView后进行scroll.setVerticalScrollBarEnabled(false);
问题描述：
ScrollView隐藏滚动条后，如果之前设置了 键盘弹出 自动把滚动布局向上(滚动)会失效，而是把整个布局顶上去！
这样一来，我们就不能设置android:scrollbars="none"了，那么我们如果就是想不显示滚动条，该怎么做呢？
设置滚动条为透明色即可：
android:scrollbarThumbVertical="@android:color/transparent"
android:scrollbars="vertical"
至此，文章结束，希望此文能帮助到你，如果对此文有不同见解，欢迎直接评论！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0366a835ce35b9e1f4d994cecd98c8b5/" rel="bookmark">
			FCN论文翻译（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FCN论文翻译（一） 目录
用于语义分割的完全卷积网络
1、介绍
2、相关工作
前言：这篇文章是对FCN原文进行翻译，这篇翻译是第一和第二节，剩下的接下来会持续更新。论文原文：https://arxiv.org/pdf/1605.06211.pdf 用于语义分割的完全卷积网络 Jonathan Long∗ Evan Shelhamer∗ Trevor Darrell UC Berkeley
{jonlong,shelhamer,trevor}@cs.berkeley.edu
摘要：卷积网络是一种强大的视觉模型，它能产生特征层次结构。我们发现，卷积网络本身，经过端到端、像素到像素的训练，在语义分割方面超过了目前的水平。我们的关键洞察是建立“完全卷积”网络，该网络接收任意大小的输入，并通过有效的推理和学习产生相应大小的输出。我们定义并详细描述了完全卷积网络的空间，解释了它们在空间密集型预测任务中的应用，以及与先前模型的联系。我们将当代分类网络（AlexNet[19]、VGG网[31]和GoogLeNet[32]）改编为完全卷积网络，并通过微调[4]将它们的学习表示转移到分割任务中。然后，我们定义了一种新的架构，它将来自深层、粗糙层的语义信息与来自浅层、精细层的外观信息相结合，以产生精确而详细的分割。我们的全卷积网络实现了PASCAL VOC（2012年平均IU为62.2%）的20%相对改进，NYUDv2和SIFT流的分割达到了最新的水平，而对于典型图像，推理需要不到五分之一秒。
1、介绍 卷积网络正在推动识别技术的进步。卷积神经网络不仅改进了整体图像分类[19，31，32]，而且在结构化输出的局部任务上也取得了进展。其中包括边界盒目标检测[29,12,17]、部分和关键点预测[39,24]以及局部对应[24,9]方面的进展。
从粗推断到精推断过程中的下一步自然是在每个像素处进行预测。先前的方法已经使用卷积神经网络进行语义分割[27，2，8，28，16，14，11]，其中每个像素都用其封闭对象或区域的类别进行标记，但这项工作解决了一些缺点。
图1.完全卷积网络可以有效地学习对每像素任务（如语义分割）进行密集预测。
我们证明了一个完全卷积网络（FCN），经过训练的端到端，像素到像素的语义分割在没有进一步机器学习的情况下超过了最先进的水平。据我们所知，这是第一个端到端训练FCNs的工作（1）用于像素预测（2）来自有监督的预训练。现有网络的完全卷积版本预测任意大小输入的密集输出。学习和推理都是通过密集的前向计算和反向传播来实现的。在网络中，上采样层通过池化层在网络中实现像素级的预测和学习。
这种方法是有效的，无论是渐进的和绝对的，并排除了需要做其他工作的复杂性。分块训练很常见[27,2,8,28,11]，但缺乏完全卷积训练的效率。我们的方法没有使用预处理和后处理的复杂度，包括超像素[8，16]、建议[16，14]，或随机场或局部分类器的事后细化[8，16]。我们的模型通过将分类网重新解释为完全卷积的，并从学习的表示中进行微调，从而将最近在分类方面取得的成功[19，31，32]转化为密集预测。相比之下，以前的工作在没有监督的预训练的情况下应用了小型卷积神经网络[8，28，27]。
语义分割面临着语义和位置之间的内在张力：全局信息决定什么，而局部信息决定哪里。深层特征层次在局部到全局金字塔中联合编码位置和语义。在第4.2节中，我们定义了一个新颖的“跳过”架构，将深度的、粗糙的语义信息和浅层的、精细的外观信息结合起来(见图3)。
在下一节中，我们将回顾有关深度分类网络、模糊神经网络和使用卷积神经网络进行语义分割的最新方法。以下部分解释FCN设计和密集预测权衡，介绍我们的网络内上采样和多层组合架构，并描述我们的实验框架。最后，我们展示了PASCAL VOC 2011-2、NYUDv2和SIFT Flow的最新研究结果。
2、相关工作 我们的方法借鉴了深度网络在图像分类[19,31,32]和迁移学习[4,38]方面的最新成功。迁移首先在各种视觉识别任务上演示[4,38]，然后在检测上演示，在混合提议分类器模型中的实例和语义分割上演示[12,16,14]。我们现在重新构建和微调分类网络，以指导语义分割的密集预测。我们绘制了FCN的空间图，并在此框架中定位了以前的模型，包括历史模型和近期模型。
完全卷积网络 据我们所知，将卷积网络扩展到任意大小的输入的想法最早出现在Matan等人的[25]中，他们将经典的LeNet[21]扩展为识别数字字符串。 由于他们的网络仅限于一维输入字符串，Matan等人使用Viterbi解码获得他们的输出。Wolf和Platt[37]将卷积网络输出扩展为四角检测分数的二维地图。宁等。 [27]定义了一个卷积网络，用完全卷积推理对线虫组织进行粗分类。 在当今的多层网络中，也已经开发了完全卷积计算。Sermanet等人[29]对滑动窗口进行检测，Pinheiro和Collobert [28]对语义进行分割，Eigen等人[5]对图像进行还原，可以进行完全卷积推理。完全卷积训练很少见，但Tompson等[35]有效地用于学习端到端零件检测器和空间模型以进行姿势估计，尽管它们没有阐述或分析这种方法。 或者，He等人[17]丢弃了分类网络的非卷积部分，制成了特征提取器。他们将提案和空间金字塔池相结合，以产生用于分类的局部，固定长度的特征。尽管这种混合模型快速有效，但无法端对端学习
卷积网络的密集预测 最近的一些工作已经将卷积应用于密集的预测问题，包括Ning等人[27]，Farabet等人[8]，Pinheiro和Collobert [28]的语义分割。Ciresan等人[2]的电子显微镜边界预测，以及Ganin和Lempitsky的混合神经网络/最近邻模型[11]预测自然图像。以及Eigen等人[5，6]进行的图像恢复和深度估计。 这些方法的共同要素包括 :
限制能力和接受领域的小模型； 逐批训练[27、2、8、28、11]； 通过超像素投影，随机场正则化，滤波或局部分类进行后处理[8、2、11]； 由OverFeat [29]引入的用于密集输出[28，11]的输入移位和输出隔行； 多尺度金字塔处理[8、28、11]； 饱和tanh非线性[8，5，28]和集合[2，11]， 而我们的方法没有这种机制。 但是，我们确实从FCN的角度研究了分批训练3.4和“移位和缝合”密集输出3.2。 我们还讨论了网络内上采样3.3，其中Eigen等人[6]的全连接预测是一个特例。 与这些现有方法不同，我们使用图像分类作为监督的预训练来适应和扩展深度分类体系结构，并进行全面卷积微调，以从整个图像输入和整个图像基础事实中简单有效地学习。
Hariharan等人[16]和Gupta等人[14]同样将深层分类网适应于语义分割，但是在混合提议分类器模型中却是如此。 这些方法通过对边界框和/或区域建议进行采样以进行检测，语义分割和实例分割来微调R-CNN系统[12]。 两种方法都不是端到端学习的。
他们分别在PASCAL VOC分割和NYUDv2分割上获得了最新的结果，因此我们在第5节中直接将我们独立的端到端FCN与它们的语义分割结果进行比较。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/764468755b1fca79bf3e91942a13b130/" rel="bookmark">
			android7.1.1版本更新,ColorOS安卓7.1.1升级包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ColorOS升级7.1.1正式版来袭，ColorOS完美兼容安卓7.1.1系统，可以适合oppo绝大部分手机，让你的手机系统更上一层楼，体验到最新的系统带给你更好的操作。
升级方法：
★请先将您的手机升级至最新的正式版本(R9s _11_A.18_170112版本)。如果您的手机不是最新正式版，请在“设置--系统更新”中检测升级。
★安装R9s全网通公测版升级.APK，安装完成后，桌面点击进入“ColorOS升级”，检测并加入升级计划。
★成功加入升级计划，即可在“设置--系统更新”中即可检测到R9s全网通公测版更新。该升级APK仅限R9s全网通、R9sk全网通机型下载使用！
★下载并更新到R9s全网通公测版：
更新推荐：
★ 新增 Android版本从Android 6.0升级为Android 7.1
★ 新增 全新应用分屏，设置-其他设置中开启分屏开关，在支持分屏的应用界面长按多任务键进入分屏
★ 新增 相册云同步,手机存储的照片和视频自动同步到云端
更新日志：
【桌面】
1.新增 桌面搜索接入黄页，支持搜索团购、电影等黄页内容
2.优化 全局主题规范升级，不再兼容3.0旧全局主题
【相册】
1.新增 相册搜索功能，可以根据时间、地理位置信息和人物名称来搜索照片
2.优化 相册图片排序，“照片”标签页和图集内，图片按照拍摄时间顺序排列，最新的图片排在最后
3.优化 相册精选12款全新滤镜，图片美化效果大幅提升
【信息】
1.新增 挂机短信,接收到诈骗电话挂机后，用户会收到防骗提醒信息，谨防诈骗
2.优化 信息卡片式显示，在设置中打开开关，即可将火车票、机票等短信以卡片化显示，便于阅读
3.优化 智能信息下一步更加场景化，短信快捷操作更智能，智能分析短信内容实现直接查快递、缴话费等功能
4.优化 信息服务本地化，短信公众号服务在信息对话中即可打开
【控制中心】
1.新增 控制中心增加OShare和夜间护眼快捷操作开关
【手机管家】
1.优化 儿童空间密码调整为锁屏密码
2.优化 儿童空间主页交互，设置操作更直观
【文件管理】
1.新增 OShare功能，文件传输快人一步
2.新增 文件管理搜索出来的文件支持编辑选择操作
【便签】
1.优化 便签新风格，内容呈现更加丰富合理，版式更加简洁大方
2.优化 便签编辑支持滑动多选操作
【通知栏】
1.优化 横幅提醒通知调整为卡片式显示
2.优化 通知栏时间显示布局
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ac8c8577e5ff2484608be8fbb240165/" rel="bookmark">
			Python 的一万种用法：制作 Web 可视化页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源 | 法纳斯特
头图 | 下载于ICphoto
一谈到Web页面，可能大家首先想到就是HTML、CSS或JavaScript。
本次小F给大家介绍一下如何用Python制作一个数据可视化网页，使用到的是Streamlit库，轻松将一个Excel数据文件转换为一个Web页面，提供给所有人在线查看。
每当你对Excel文件进行更改保存，Web页面还能够实时进行更新，确实挺不错的。
Streamlit的文档和教程地址如下：
https://docs.streamlit.io/en/stable/
https://streamlit.io/gallery
相关的API使用可以去文档中查看，都有详细的解释。
项目一共有三个文件，程序、图片、Excel表格数据。
数据情况如下，某公司年底问卷调查(虚构数据)，各相关部门对生产部门在工作协作上的打分情况。
有效数据总计约676条，匿名问卷，包含问卷填写人所属部门，年龄，评分。
最后对各部门参与人数进行汇总计数(右侧数据)。
首先来安装一下相关的Python库，使用百度源。
# 安装streamlit pip install streamlit -i https://mirror.baidu.com/pypi/simple/ # 安装Plotly Express pip install plotly_express==0.4.0 -i https://mirror.baidu.com/pypi/simple/ # 安装xlrd pip install xlrd==1.2.0 -i https://mirror.baidu.com/pypi/simple/ 因为我们的数据文件是xlsx格式，最新版的xlrd，只支持xls文件。
所以需要指定xlrd版本为1.2.0，这样pandas才能成功读取数据。
命令行终端启动网页。
# 命令行终端打开文件所在路径 cd Excel_Webapp # 运行网页 streamlit run app.py 成功以后会有提示，并且浏览器会自动弹出网页。
如果没有自动弹出，可以直接访问上图中的地址。
得到结果如下，一个数据可视化网页出来了。
目前只能在本地访问查看，如果你想放在网上，可以通过服务器部署，需要自行去研究～
下面我们来看看具体的代码吧。
import pandas as pd import streamlit as st import plotly.express as px from PIL import Image # 设置网页名称 st.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ac8c8577e5ff2484608be8fbb240165/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a645f6cd1f10cb646284d4a4181a4edb/" rel="bookmark">
			OpenGL核心技术之帧缓冲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenGL核心技术之帧缓冲
笔者介绍：姜雪伟，I。
https://blog.csdn.net/jxw167/article/details/54985183/
CSDN视频网址：http://edu.csdn.net/lecturer/144
本篇博文主要是给读者解密关于游戏后处理渲染效果的原理，后处理渲染效果在Unity，UE4虚幻引擎等商业引擎 使用的非常多，
比如Bloom，Blur，SSAO，PSSM，HDR等等都属于后处理渲染效果，它们的实现其实就是应用帧缓冲技术实现的，本篇博文主要是
围绕帧缓冲给读者介绍其实现原理以及应用案例。
在前面给读者介绍了几种不同的屏幕缓冲：用于写入颜色值的颜色缓冲，用于写入深度信息的深度缓冲，以及允许我们基于一些条件丢弃指定片段的模板缓冲。本篇博客主要是给读者介绍帧缓冲，什么是帧缓冲？其实就是把前面介绍的这几种缓冲结合起来叫做帧缓冲(Framebuffer)，它被储存于内存中。OpenGL给了我们自己定义帧缓冲的自由，我们可以选择性的定义自己的颜色缓冲、深度和模板缓冲。本篇博客主要是给读者介绍帧缓冲，我们前面介绍的渲染操作都是在默认的帧缓冲之上进行的，当你创建了你的窗口的时候默认帧缓冲就被创建和配置好了，通过创建我们自己的帧缓冲我们能够获得一种额外的渲染方式。通过帧缓冲可以将你的场景渲染到一个不同的帧缓冲中，可以使我们能够在场景中创建镜子这样的效果，或者做出一些炫酷的特效。首先我们会讨论它们是如何工作的，然后我们将利用帧缓冲来实现一些炫酷的效果。
我们在引擎渲染中经常会使用一些后处理效果，这些后处理效果就是在帧缓冲中进行的。下面我们就告诉读者帧缓冲是如何工作的？
我们可以使用一个叫做glGenFramebuffers的函数来创建一个帧缓冲对象（简称FBO）：
GLuint fbo;
glGenFramebuffers(1, &amp;fbo);
首先我们要创建一个帧缓冲对象，把它绑定到当前帧缓冲，做一些操作，然后解绑帧缓冲。我们使用glBindFramebuffer来绑定帧缓冲：
glBindFramebuffer(GL_FRAMEBUFFER, fbo);
绑定到GL_FRAMEBUFFER目标后，接下来所有的读、写帧缓冲的操作都会影响到当前绑定的帧缓冲。也可以把帧缓冲分开绑定到读或写目标上，分别使用GL_READ_FRAMEBUFFER或GL_DRAW_FRAMEBUFFER来做这件事。如果绑定到了GL_READ_FRAMEBUFFER，就能执行所有读取操作，
像glReadPixels这样的函数使用了，绑定到GL_DRAW_FRAMEBUFFER上，就允许进行渲染、清空和其他的写入操作。在此给读者总结一下构建一个完整的帧
缓冲满足的条件：
建构一个完整的帧缓冲必须满足以下条件：
我们必须往里面加入至少一个附件（颜色、深度、模板缓冲）。
其中至少有一个是颜色附件。
所有的附件都应该是已经完全做好的（已经存储在内存之中）。
每个缓冲都应该有同样数目的样本。
上面的条件提到了样本，如果你不知道什么是样本也不用担心，我们会在后面的博文中讲到。
我们需要为帧缓冲创建一些附件(Attachment)，还需要把这些附件附加到帧缓冲上。当我们做完所有上面提到的条件的时候我们就可以用 glCheckFramebufferStatus 带上 GL_FRAMEBUFFER 这个参数来检查是否真的成功做到了。然后检查当前绑定的帧缓冲，返回了这些规范中的哪个值。如果返回的是 GL_FRAMEBUFFER_COMPLETE就对了：
if(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE)
// Execute victory dance
后续所有渲染操作将渲染到当前绑定的帧缓冲的附加缓冲中，由于我们的帧缓冲不是默认的帧缓冲，渲染命令对窗口的视频输出不会产生任何影响。出于这个原因，它被称为离屏渲染（off-screen rendering），就是渲染到一个另外的缓冲中。为了让所有的渲染操作对主窗口产生影响我们必须通过绑定为0来使默认帧缓冲被激活：
glBindFramebuffer(GL_FRAMEBUFFER, 0);
当我们做完所有帧缓冲操作，不要忘记删除帧缓冲对象：
glDeleteFramebuffers(1, &amp;fbo);
现在在执行完成检测前，我们需要把一个或更多的附件附加到帧缓冲上。一个附件就是一个内存地址，这个内存地址里面包含一个为帧缓冲准备的缓冲，它可以是个图像。当创建一个附件的时候我们有两种方式可以采用：纹理或渲染缓冲（renderbuffer）对象。
接下来介绍纹理，当把一个纹理附加到帧缓冲上的时候，所有渲染命令会写入到纹理上，就像它是一个普通的颜色/深度或者模板缓冲一样。使用纹理的好处是，所有渲染操作的结果都会被储存为一个纹理图像，这样我们就可以简单的在着色器中使用了。
创建一个帧缓冲的纹理和创建普通纹理差不多：
GLuint texture;
glGenTextures(1, &amp;texture);
glBindTexture(GL_TEXTURE_2D, texture);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a645f6cd1f10cb646284d4a4181a4edb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf0c409f225554682e2216c3c113733b/" rel="bookmark">
			HFM student Hyperion Financial Management
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HFM student Hyperion Financial Management
https://docs.oracle.com/cd/E57185_01/index.htm
《Oracle®Hyperion财务管理用户指南》
标题和版权信息
文档可访问性
文档反馈
点击展开 1关于财务管理 财务管理功能 Oracle Hyperion Financial Management提供以下功能：
企业财务信息的统一视图在可扩展的基于Web的应用程序中整合了来自全球资源的关键绩效和运营指标。“快速虚拟关闭”功能可缩短关闭周期的天数和周数，包括使用基于Web的流程管理，基于Web的公司间对账，日记帐调整以及一致的数据和业务度量。强大的多维分析有助于在公司，成本中心，产品，品牌，客户和渠道级别上识别和报告关键的财务和业务趋势，新的盈利能力和现金流量来源。灵活的“假设”方案管理功能可动态合并并报告实际结果，财务预算，预测和计划，并随着假设和事实的变化而产生新的报表。预先格式化的大容量报告可通过同一应用程序为内部管理以及外部监管和政府机构提供及时，准确的财务信息。预打包的功能可以快速，经济高效地进行开箱即用地部署，其中包括世界一流的分配，多币种转换以及与遗留应用程序，ERP和CRM系统的可靠数据集成等功能。使用行业标准工具，可定制和可扩展的应用程序可以快速，经济高效地解决您的问题。专为Web设计，因此用户可以使用标准的Web浏览器从任何位置轻松安全地访问全球财务信息。关系数据存储可确保用户24x7x365可获得关键任务数据。 此外，财务管理还提供：
预建的入门套件应用程序可满足特定要求，例如可持续发展报告，IFRS，日本法定报告与Oracle Essbase集成以进行扩展的报告和分析与其他Oracle Hyperion Enterprise Performance Management应用程序集成 绩效管理架构师 Oracle Hyperion EPM Architect是Oracle Hyperion Financial Management安装和配置的组件。您可以使用它来创建和使用应用程序和尺寸，以及同步数据。
有关在Performance Management Architect中执行的任务的帮助，请参见《Oracle Hyperion Enterprise Performance Management Architect管理指南》。
EPM工作区 Oracle Hyperion企业绩效管理工作区中提供了Oracle Hyperion Financial Management。有关在EPM Workspace中执行的任务的信息，例如“导航”，“收藏夹”，“管理”或“工具”菜单中的首选项或功能，请参见《Oracle Hyperion Enterprise Performance Management工作区用户指南》和联机帮助。
财务管理维度 维度描述组织的数据，通常包含相关成员的组。维的示例包括“科目”，“实体”和“期间”。Oracle Hyperion Financial Management提供了八个系统定义的维度，使您能够填充可应用于帐户的无限数量的自定义维度。
构成维度的元素称为成员。例如，GrossMargin和TotalRevenues是“帐户”维的成员。
维成员按层次结构排列。上级成员称为父级成员，紧接在父级成员下方的成员称为其子级。父母以下的所有成员都称为后代。层次结构的最底层层次结构成员称为基础级别成员。
并非所有数据维都允许您定义层次结构。例如，“年份”维不支持层次结构。
数据输入维的基本级别成员，而不是父成员。父级成员的值是从父级成员的子级聚合的。在某些情况下，将计算基本级别成员的数据。
以下各节描述了系统定义的尺寸。有关设置维度属性的信息，请参阅甲骨文海波龙企业绩效管理架构师管理员指南，如果你正在使用海波龙解决方案公司EPM架构师，或者甲骨文Hyperion财务管理管理员指南，如果你正在使用财务管理经典应用程序管理。
场景维度
“方案”维表示一组数据，例如“实际”，“预算”或“预测”。例如，实际业务情景可以包含来自总账的数据，这些数据反映了过去和当前的业务运营。预算业务情景可以包含反映目标业务运营的数据。预测方案通常包含与未来期间的预测相对应的数据。法律场景可以包含根据法律GAAP格式和规则计算的数据。
您可以为应用程序定义任意数量的方案，并为方案维度成员定义属性，例如默认频率，默认视图和零数据设置。
年份维度
Year维度代表数据的会计年度或日历年度。一个应用程序可以包含一年以上的数据。在创建应用程序时，您可以指定年份范围，并从“年份”维度中选择一个年份来处理数据。
期间维度
期间维表示时间段，例如季度和月份。通过在层次结构中显示时间段，它可以包含时间段和频率。例如，如果“实际”方案每月维护一次数据，则一年中该方案通常可使用12个数据周期。财务管理支持期间维度的年，月和周。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf0c409f225554682e2216c3c113733b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/173e48920360aa3794781fd50b0fb8d4/" rel="bookmark">
			Android全面屏导航栏高度,Android10全面屏开启底部手势横条，弹窗留白问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public static boolean isShowNavBar(Context context) {
if (null == context) {
return false;
}
/**
* 获取应用区域高度
*/
Rect outRect1 = new Rect();
try {
((Activity) context).getWindow().getDecorView().getWindowVisibleDisplayFrame(outRect1);
} catch (ClassCastException e) {
e.printStackTrace();
return false;
}
int activityHeight = outRect1.height();
Log.e("zrj", "状态栏高度:"+ getStatusBarHeight() );
Log.e("zrj", "应用区域高度:"+ activityHeight );
Log.e("zrj", "导航栏高度:"+ getNavBarHeight() );
Log.e("zrj", "屏幕物理高度:"+ getRealHeight(context) );
/**
* 屏幕物理高度 - 状态栏高度 导航栏高度 = 导航栏存在时的应用实际高度
*/
int remainHeight = getRealHeight(context) - getStatusBarHeight() - getNavBarHeight();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/173e48920360aa3794781fd50b0fb8d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/065ba9063395e3f191597ca440887528/" rel="bookmark">
			zynq linux opencv效率,2 - 基于ZYNQ7000的交叉编译工具链Qt&#43;OpenCV&#43;ffmpeg等库支持总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以通过输入echo $PATH命令检查环境变量是否设置正确，如下图：
可以，编译C文件进行测试，
使用gedit在任意目录下编辑hello.c文件如图所示，保存后进入终端。
以root身份进入到当前目录下，输入arm-xilinx-linux-gnueabi-gcc -o hello hello.c命令(该命令root身份有效)
生成hello可执行文件，输入file hello命令，hello文件信息如下，显示arm可执行文件。
此时证明arm-xilinx交叉编译工具安装正确无误，进入下一步。
在此之前建议，添加环境变量用于简单表示交叉编译库存放路径，每次启动终端都需要输入此命令
export ZYNQ_CV_BUILD=/opt/opencv/opencv-lib
使用echo $ZYNQ_CV_BUILD命令检验是否添加环境变量，再开始对依赖库的编译。
2.依赖库的交叉编译
对于依赖库的编译，都需要进行配置，当发生配置错误时可使用./configure --help命令查看帮助，以及阅读相应log文件查看编译出错原因。切记需要按照顺序编译，并且一定注意版本一致。
(1)zlib-1.2.7
由于zlib中没有--host选项，所以需要预先声明cc变量
unzip zlib127.zip
cd zlib-1.2.7
export CC=arm-xilinx-linux-gnueabi-gcc
./configure --prefix=$ZYNQ_CV_BUILD --shared
make
make install
然后，可进入$ZYNQ_CV_BUILD/lib目录下检查是否已编译ARM环境的zlib库
cd $ZYNQ_CV_BUILD/lib
ls
file libz.so.1.2.7
如下图所示，则表明成功编译arm所需库文件，以下依赖库均可采用此种检查方式，故略去。
(2)jpeg-8d
tar -xzvf jpegsrc.v8d.tar.gz
cd jpeg-8d
./configure --prefix=$ZYNQ_CV_BUILD --host=arm-xilinx-linux-gnueabi --enable-shared
make
make install
(3)libpng-1.5.14
libpng编译时需要zlib库的内容，所以需要LDFLAGS以及CFLAGS变量声明。
tar -xzvf libpng-1.5.14.tar.gz
cd libpng-1.5.14
./configure --prefix=$ZYNQ_CV_BUILD --host=arm-xilinx-linux-gnueabi
--with-pkgconfigdir=$ZYNQ_CV_BUILD/lib/pkgconfig LDFLAGS=-L$ZYNQ_CV_BUILD/lib
CFLAGS=-I$ZYNQ_CV_INSTALL/include
make
make install
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/065ba9063395e3f191597ca440887528/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bee28a90747ef91858e4500e9ec299ea/" rel="bookmark">
			android app 首页布局,Android App界面的ListView布局实战演练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、继承listActivity、使用arrayAdapter使用ListView和arrayAdapter布局，是ListView布局中最为简单的一种，首先我们会建立一个组件用来显示数据，例如main.xml
android:layout_width="fill_parent"
android:layout_height="fill_parent"
android:padding="10dp"
android:textSize="16sp"
&gt;
Activity代码如下
package cn.com.android.grid;
import android.app.ListActivity;
import android.os.Bundle;
import android.widget.ArrayAdapter;
public class listViewTest extends ListActivity {
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
String data[] = getData();
ArrayAdapter arrayAdapter = new ArrayAdapter(this, R.layout.main, data);
this.setListAdapter(arrayAdapter);// ArrayAdapter 继承自baseAdapter，baseAdapter又继承自ListAdapter
}
/**
* @author chenzheng_java
* @description 获取一个数组列表
*/
private String[] getData(){
String[] data = new String[100];
for (int i = 0; i &lt; 100; i++) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bee28a90747ef91858e4500e9ec299ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8ac70116eae6463acb5c7f3e48c2c7e/" rel="bookmark">
			android 扫描二维码支付,Android 扫码盒子全局接收付款码（全局事件&amp;上层接收&amp;多重下发）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现MainActivity，然后接收到的内容，通过接口回调，依次下发到各个业务
String barcode = ""; // 收到的码结果
String check = "0000"; //特殊码前缀 如：核销码
@Override
public boolean dispatchKeyEvent(KeyEvent event) {
if(event.getAction()==KeyEvent.ACTION_DOWN){
Log.e("dispatchKeyEvent","dispatchKeyEvent: "+event.toString());
char pressedKey = (char) event.getUnicodeChar();
barcode += pressedKey;
Log.e("dispatchKeyEvent","barcode: "+barcode);
}
if (event.getAction()==KeyEvent.ACTION_DOWN &amp;&amp; event.getKeyCode() == KeyEvent.KEYCODE_ENTER) {
Log.e("dispatchKeyEvent","barcode最后: "+barcode);
// Toast.makeText(MainActivity.this,barcode,Toast.LENGTH_LONG).show();
if(scanKeyManager!=null){
String str = barcode.trim().replace("\n","");
Log.e("付款码：", str + "");//check78787
if (str.length() == 18) {//1346 0952 2362 9255 02
if (scanKeyManager != null &amp;&amp; !str.startsWith(check)){
scanKeyManager.analysisKeyEvent(str);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8ac70116eae6463acb5c7f3e48c2c7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f4a42212fc219385bade6964bacaef0/" rel="bookmark">
			如何查看手机的android版本信息,怎么查看手机型号、配置、版本【图文教程】...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么查看手机型号、配置、版本【图文教程】
很多人在购买手机之后突然想起要查看一下手机型号、配置等，那么怎么看手机型号配置呢?下面教大家怎么看手机型号配置的两种方法，都来看看吧。
步骤1、首先来说说第一种方法，这一种方法在大家都手机上都可以通用。就是在设置里面，在“关于手机”中进行查看。那么要在手机桌面中先找到“设定”，并且点击打开“设定”。
步骤2、点击打开“设定”以后，“设定”项目里边有很多的设置项。在这些设定项中需要找到“关于手机”这个项目，看到这里没有，那就需要往下翻，找到“关于手机”。
步骤3、在“设定”项目中往下翻动，在这一页面的最下方就可以看到“关于手机”，然后就点击打开“关于手机”这个项目。
步骤4、在“关于手机”这个项目中，能看到手机关于配置的各个说明。有手机型号，还有手机的安卓版本，以及手机的内核等等。这些只是手机配置的一部分，还可以更具体的了解手机的配置。
步骤5、下面就来说说第二种，第二种需要借助软件来完成。需要手机安装360手机卫士，安装了360手机卫士以后，在桌面上点击打开360手机卫士。
步骤6、点击打开360手机卫士以后，进入到“常用功能”的界面，再需要找到“安全防护”。找到“安全防护”以后，点击打开，然后可以在里面找到“系统检测”的功能。
步骤7、进入到“安全防护”以后，在“安全防护”中，最下方有一项“系统检测”。这个“系统检测”就是360对手机的系统配置以及使用情况的检测，然后点击打开“系统检测”。
步骤8、点击打开“系统检测”以后，这里面对手机的系统介绍比较完善，所有的关于手机配置方面的信息基本都可以看的到。
以上就是怎么看手机型号的解决办法，希望对大家有帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d0c24ad706a03016a5bef968f6ce57c/" rel="bookmark">
			android源码模块编译错误,Android 源码编译错误记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		构建环境 mac os 10.14.5
在构建过程中报如下错误：
Could not find a supported mac sdk: ["10.10" "10.11" "10.12" "10.13"]
遇到这个问题不需要安装xcode，更不需要安装Mac os sdk 10.14，只需要安装
Command_Line_Tools_macOS_10.13_for_Xcode_9.3即可，这个是可以在mac os 10.14上安装的最简化版本的命令行工具。
如果安装了xcode，安装了Mac os sdk 10.14，则会报ld: symbol(s) not found for architecture i386的错误，因为在Mac os sdk 10.14开始已经不再支持i386.
在下载android源码之前一定要划分一个大小写敏感的分区，否则会在编译过程中出现各种问题。
也会报如下错误:
Checking build tools versions...
build/core/main.mk:159: ************************************************************
build/core/main.mk:160: You are building on a case-insensitive filesystem.
build/core/main.mk:161: Please move your source tree to a case-sensitive filesystem.
build/core/main.mk:162: ************************************************************
build/core/main.mk:163: *** Case-insensitive filesystems not supported.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d0c24ad706a03016a5bef968f6ce57c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beca03adff4b26a992b52a7d9cde509a/" rel="bookmark">
			android 触摸事件传递机制,Android Touch事件传递机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们点击屏幕时，会有下列事件发生：
Activity调用dispathTouchEvent()方法，把事件传递给Window；
Window再将事件交给DecorView(DecorView是View的根布局)；
DecorView再传递给ViewGroup；
Activity ——&gt; Window ——&gt; DecorView ——&gt; ViewGroup——&gt; View
事件分发的主要有三个关键方法
dispatchTouchEvent() 分发
onInterceptTouchEvent() 拦截 ，只有ViewGroup独有此方法
onTouchEvent() 处理触摸事件
Activity首先调用dispathTouchEvent()进行分发，接着调用super向下传递
ViewGroup首先调用dispathTouchEvent()进行分发，接着会调用onInterceptTouchEvent()(拦截事件)。若拦截事件返回为true，表示拦截，事件不会向下层的ViewGroup或者View传递；false，表示不拦截，继续分发事件。默认是false，需要提醒一下，View是没有onInterceptTouchEvent()方法的
事件在ViewGroup和ViewGroup、ViewGroup和View之间进行传递，最终到达View；
View调用dispathTouchEvent()方法，然后在OnTouchEvent()进行处理事件；OnTouchEvent() 返回true，表示消耗此事件，不再向下传递；返回false，表示不消耗事件，交回上层处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/098b056d68ee209b2263c72aed1f6f14/" rel="bookmark">
			android 置顶窗口位置,RecyclerView选中项居中(横向、竖向)，指定位置置顶（竖向）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要实现对LinearLayoutManager的重写
中间显示类
import android.content.Context;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.LinearSmoothScroller;
import android.support.v7.widget.RecyclerView;
import android.util.DisplayMetrics;
public class CenterLayoutManager extends LinearLayoutManager {
static int lastPositon = 0;
static int targetPosion = 0;
public CenterLayoutManager(Context context, int orientation, boolean reverseLayout) {
super(context, orientation, reverseLayout);
}
@Override
public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, int position) {
CenterSmoothScroller smoothScroller = new CenterSmoothScroller(recyclerView.getContext());
smoothScroller.setTargetPosition(position);
startSmoothScroll(smoothScroller);
}
public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, int lastpositon, int position) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/098b056d68ee209b2263c72aed1f6f14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cf840045b026133374fafed15c3b983/" rel="bookmark">
			腾讯面试题：找出重复数（部分思考）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ 有 2.5 亿个数，其中只有一个数出现两次，其他的数都出现一次。在内存紧张的情况下，怎么找出这个重复数？
一、与【重复】有关的题目 1、LeetCode136.只出现一次的数字（异或法） 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
class Solution { public int singleNumber(int[] nums) { int res = 0;//任何数与0进行异或操作都等于本身 for (int num : nums) { res^=num; } return res; } } 2、剑指offer03.数组中重复的数字 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
class Solution { // public int findRepeatNumber(int[] nums) { // HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); // for(int num:nums){ // if(set.contains(num)){ // return num; // } // set.add(num); // } // return -1; // } //如果没有重复数字，那么正常排序后，数字i应该在下标为i的位置，所以思路是重头扫描数组，遇到下标为i的数字如果不是i的话，（假设为m),那么我们就拿与下标m的数字交换。在交换过程中，如果有重复的数字发生，那么终止返回ture public int findRepeatNumber(int[] nums) { int temp; for(int i=0;i&lt;nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cf840045b026133374fafed15c3b983/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/365ba92138781e1004b1f2ad25dae943/" rel="bookmark">
			如何修改 / 校正Linux系统时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言 很多时候我们操作完Linux系统后会直接挂起机器，不是关闭机器，但是这样就会带来一个问题，系统时间会脱离网络实际时间，导致系统时间与时间不一致，下面就是关于修改 / 校正Linux系统时间的操作步骤
操作 使用date命令查看当前系统时间。如下所示：
[root@hadoop102 ~]# date 2021年 05月 23日 星期日 11:16:42 CST 但是目前实际时间是：
2021年5月25日 20:55:07 星期二
使用命令rm -f /etc/localtime删除本地时间文件。如下所示：
[root@hadoop102 ~]# rm -f /etc/localtime 使用命令cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime复制时区文件到localtime。如下所示：
[root@hadoop102 ~]# cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 使用命令“yum install -y ntpdate”安装“ntpdate”。如下所示：
[root@hadoop102 ~]# yum install -y ntpdate 使用命令“ntpdate -u ntp.api.bz”将本地时间与网络时间同步，如下所示：
[root@hadoop102 ~]# ntpdate -u ntp.api.bz 25 May 21:02:50 ntpdate[6867]: step time server 114.118.7.161 offset 207360.947555 sec 使用命令date查看当前系统时间是否更新。如下所示：
[root@hadoop102 ~]# date 2021年 05月 25日 星期二 21:04:07 CST 使用命令“hwclock -w”保存配置，以便重启后时间再次不对。如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/365ba92138781e1004b1f2ad25dae943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555580f331e24c64c9e7d8060cc07e12/" rel="bookmark">
			2021-05-24  XAMPP安装配置部署过程完整记录（win10）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备工作 1、下载XAMPP 下载XAMPP安装包：https://sourceforge.net/projects/xampp/files/XAMPP%20Windows/
我用的是windows版本的，两种下载方式：路径1 和 路径2（直接安装.exe，推荐)
2、安装XAMPP 装在D盘了，D盘下的app是我装各种电脑软件的地方
一路点 next，ok就好。
安装完成，运行就是下面的样子了：
二、配置阶段 1、配置Apache Apache端口号默认80端口（也是http端口），这里，可以使用默认的80端口，也可以修改为8081端口。
（1）使用默认的80端口：在部署阶段（下边有描述）完成后，可以直接用localhost访问xampp主页和php，或者可以直接用自己设置的域名访问，即，不需要加端口号
（2）修改为8081端口：有些电脑会与默认的80端口产生冲突，有可能会导致浏览器不能正常使用，所以修改端口号可以避免这些问题。麻烦的是，需要加端口号访问。即，http://localhost:8081，使用自己设置的域名访问也必须加：8081。
为了避免发生冲突，还是选择修改端口~~~，修改如下：
修改 httpd.conf 文件 修改 httpd-ssl.conf 文件 这里443其实就是https端口，为了避免发生冲突，修改为4433
修改之后记得保存！！！
2、配置MySQL 修改php语言配置文件 my.ini MySQL默认的端口是3306，避免发生端口占用，这里也修改了，修改为3316
把my.ini中的字符集改为utf8，原文档中已有，但需要取消注释，防止出现乱码。
修改之后记得保存！！！
3、配置Service和port设置 在跟着其他博主的教程配置的时候，有博主说：“ 配置这个Service和port，这样可以使你点击Admin登进去，不用又在网址栏上输入端口号。” 这后半句“不用又在网址栏上输入端口号。”表述是有问题的，并不是不用输入端口号，而是不用在浏览器地址栏输“http://localhost:8081/dashboard/”去访问。
如果用直接用localhost不输入端口号直接访问是会出错的，因为浏览器默认端口号是80，修改了端口号，就必须加端口号。
点击Save保存的时候，可能会遇到拒绝访问的问题，如下图：
这是因为权限不够。按提示的路径找到xampp-control.ini文件，右键→属性，找到安全，更改权限，如下图：
修改完权限后，再点击Save就不会报错了。
三、测试阶段 1、测试Apache 点击Admin，进行测试
出现下面这个网页，说明Apache配置成功。
2、测试MySQL 可以点MySQL那儿的Admin，或者上图网页最右上角的phpMyAdmin测试MySQL。可能会出现报错，如下：
修改 config.inc.php 文件 加入这句：$cfg['Servers'][$i]['port'] = '前面修改过的MySQL端口号';
修改之后记得保存！！！
记得每次修改这些文件后，最好重启Apache (start)
刷新一下，就可以打开如下的界面了：
修改 MySQL默认密码 有博主说：“（此处可不必修改密码，因为有些人修改密码后，后面的操作会出现一些问题，所以最好不要修改了哦）”，可以不修改，但是很不安全，还是修改吧。按照默认的安装结果，MySQL没有密码，需要设置密码，可以在xampp中启动apache和mysql后，为mysql设置密码。
点击“账户”，点击“修改权限”
可能会出现下面这个问题：
尝试了很多方法，修改这句SQL语句，或者将MySQL密码改成空密码，各种解决方案，都不行，就算行也会报其他sql语句的错。
最简单粗暴的做法就是直接卸载了重装，重新过一遍，当作再熟悉一遍流程~~，成功了哈哈哈
然后再做任何操作，会报这个错
打开xampp，修改config.inc.php中的数据库密码（[‘password’] = ‘刚才修改的那个密码’）
再重新进这个phpMyadmin，就不会报错了。
四、部署 方式一：直接复制 将项目文件夹复制到…\xampp\htdocs目录下，比如…\xampp\htdocs\phpweb，然后在浏览器中输入localhost:8081/phpweb可以直接访问访问D盘phpweb的内容了（这里必须加上端口号，之前没有修改端口号的话，就直接输入localhost/phpweb访问）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/555580f331e24c64c9e7d8060cc07e12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fbaf20eab6a014d851d39f5b4a921f9/" rel="bookmark">
			android自定义dialog布局文件,Android自定义Dialog及其布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际项目开发中默认的Dialog无法满足需求，需要自定义Dialog及其布局，并响应布局中控件的事件。
上效果图：
自定义Dialog，LogoutDialog:
要将自定义布局传入构造函数中，才能在Activity中通过 dialog.findviewbyid 获取到控件，否则返回null。
public class LogoutDialog extends Dialog{
Context context;
public LogoutDialog(Context context) {
super(context);
this.context=context;
this.setContentView(R.layout.logout_dialog);
}
public LogoutDialog(Context context, int theme){
super(context, theme);
this.context = context;
this.setContentView(R.layout.logout_dialog);
}
[email protected]
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
//this.setContentView(R.layout.logout_dialog);
}
}
自定义布局文件，logout_dialog.xml：
android:layout_width="250dp"
android:layout_height="wrap_content"
android:orientation="vertical"
android:background="@android:color/transparent"
&gt;
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:background="@drawable/dialog_top_bg"
android:orientation="vertical"
android:paddingTop="10dp"
&gt;
android:layout_width="50dp"
android:layout_height="50dp"
android:src="@drawable/pop_icon1"
android:layout_gravity="center_horizontal"
android:layout_marginBottom="10dp"
/&gt;
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:text="是否确认注销账号"
android:layout_gravity="center_horizontal"
android:layout_marginBottom="20dp"
android:textColor="#FF3C25"
android:layout_marginLeft="20dp"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fbaf20eab6a014d851d39f5b4a921f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3377b7ea12a59d1c540a8eaa600783aa/" rel="bookmark">
			android 自定义文字位置吗,Android自定义控件实现带文字提示的SeekBar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android自定义控件实现带文字提示的SeekBar
发布时间：2020-09-08 19:19:58
来源：脚本之家
阅读：73
作者：容华谢后
1.写在前面
SeekBar控件在开发中还是比较常见的，比如音视频进度、音量调节等，但是原生控件有时还不能满足我们的需求，今天就来学习一下如何自定义SeekBar控件，本文主要实现了一个带文字指示器效果的SeekBar控件
看下最终效果：
IndicatorSeekBar
2.实现
IndicatorSeekBar
public class IndicatorSeekBar extends AppCompatSeekBar {
// 画笔
private Paint mPaint;
// 进度文字位置信息
private Rect mProgressTextRect = new Rect();
// 滑块按钮宽度
private int mThumbWidth = dp2px(50);
// 进度指示器宽度
private int mIndicatorWidth = dp2px(50);
// 进度监听
private OnIndicatorSeekBarChangeListener mIndicatorSeekBarChangeListener;
public IndicatorSeekBar(Context context) {
this(context, null);
}
public IndicatorSeekBar(Context context, AttributeSet attrs) {
this(context, attrs, R.attr.seekBarStyle);
}
public IndicatorSeekBar(Context context, AttributeSet attrs, int defStyleAttr) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3377b7ea12a59d1c540a8eaa600783aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc5fae7f4804615c14fae38244c41b00/" rel="bookmark">
			Qt5 openssl版本不兼容问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 项目启动QWebsocketServer时卡住打印日志如下 qt.network.ssl: QSslSocket: cannot resolve CRYPTO_num_locks
qt.network.ssl: QSslSocket: cannot resolve CRYPTO_set_id_callback
qt.network.ssl: QSslSocket: cannot resolve CRYPTO_set_locking_callback
qt.network.ssl: QSslSocket: cannot resolve ERR_free_strings
qt.network.ssl: QSslSocket: cannot resolve sk_new_null
qt.network.ssl: QSslSocket: cannot resolve sk_push
qt.network.ssl: QSslSocket: cannot resolve sk_free
qt.network.ssl: QSslSocket: cannot resolve sk_num
qt.network.ssl: QSslSocket: cannot resolve sk_pop_free
qt.network.ssl: QSslSocket: cannot resolve sk_value
qt.network.ssl: QSslSocket: cannot resolve SSL_library_init
qt.network.ssl: QSslSocket: cannot resolve SSL_load_error_strings
qt.network.ssl: QSslSocket: cannot resolve SSL_get_ex_new_index
qt.network.ssl: QSslSocket: cannot resolve SSLv2_client_method
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc5fae7f4804615c14fae38244c41b00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72bb024a652578f1b73b81763c29fc5b/" rel="bookmark">
			android 植入谷歌广告,将谷歌广告添加到Android应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我想将谷歌广告添加到我的应用程序(这是我的第一次).我也添加了jar文件.
这是xml.
xmlns:ads="http://schemas.android.com/apk/lib/com.google.ads"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:orientation="vertical" &gt;
android:layout_width="fill_parent"
android:layout_height="wrap_content"
android:background="@color/headerbgcolor"
android:weightSum="1" &gt;
android:id="@+id/back"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:layout_weight="0.2"
android:text="@string/back"
android:onClick="finishActivity"/&gt;
android:id="@+id/headertitle"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:layout_gravity="center_vertical"
android:layout_weight="0.6"
android:gravity="center"
android:text="@string/header_title" /&gt;
android:id="@+id/home"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:layout_weight="0.2"
android:text="@string/home" /&gt;
android:id="@android:id/list"
android:layout_width="wrap_content"
android:layout_height="320dp"
android:scrollbarAlwaysDrawVerticalTrack="true" &gt;
android:layout_width="fill_parent"
android:layout_height="wrap_content" &gt;
android:id="@+id/adView"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:layout_alignParentBottom="true"
ads:adSize="BANNER"
ads:adUnitId="a14f26e5d930307"
ads:loadAdOnCreate="true"
ads:testDevices="AVD_for_4in_WVGA_Nexus_S,5554" /&gt;
但是当我尝试在课堂上定义adview时,我无法在课堂上定义adview.
这是我的课程,我试着去定义.
public class Cities extends Activity {
Button btnback = null;
Button btnhome = null;
TextView headertitle = null;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72bb024a652578f1b73b81763c29fc5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6943fca25487396b78baad6f4ea4103/" rel="bookmark">
			PML决策树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		决策树(Decision Tree)：决策树使用之前的决策来计算是否愿意去看喜剧演员的几率。
age表示年龄，Experience表示演员的经验，Rank表示演员的排名，Nationality表示演员所在的国家，Go表示是否应该去看
AgeExperienceRankNationalityGo36109UKNO42124USANO2346NNO5244USANO43218USAYES44145UKNO6637NYES35149UKYES52137NYES3559NYES2435USANO1837UKYES4599UKYES import pandas from sklearn import tree import pydotplus from sklearn.tree import DecisionTreeClassifier import matplotlib.pyplot as plt import matplotlib.image as pltimg #加载数据 df = pandas.read_csv("shows.csv") #将字符串值更改为数值 d = {'UK': 0, 'USA': 1, 'N': 2} df['Nationality'] = df['Nationality'].map(d) d = {'YES': 1, 'NO': 0} df['Go'] = df['Go'].map(d) #X是功能列，y是目标列 features = ['Age', 'Experience', 'Rank', 'Nationality'] X = df[features] y = df['Go'] #创建决策树，将其另存为图像，然后显示该图像： dtree = DecisionTreeClassifier() dtree = dtree.fit(X, y) data = tree.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6943fca25487396b78baad6f4ea4103/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da005ea9fc6cfed389d4e6c2c4c40e7c/" rel="bookmark">
			FileZilla Server与FileZilla Client
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FileZilla Server 简介 FileZilla Server是一款开源、免费的FTP客户端服务器端的项目，主要优势是高安全性和高性能，安全性是来自于其开放源代码的，高性能来自于其代码的开发平台是C/C++，自身基础就好于其他VB/Dephi平台开发的应用程序，占用资源非常少，是一款超强的开源免费FTP 服务器软件。
下载安装 FileZilla Server的下载地址为：https://www.filezilla.cn/download/server。
选择FileZilla Server 0.9.60.2中文安装版进行下载。
双击FileZilla_Server-cn-0_9_60_2.exe进行安装：
点击我接受：
勾选全部，点击下一步：
选择安装路径，点击下一步：
选择FilaZilla Server的启动方式：默认就是作为服务自动启动，无需修改。点击Next：
单击安装，接着就是安装过程，安装完毕后：
点击关闭，打开FileZilla Server的主界面：
首次打开主界面，会弹出输入服务器进行管理对话框，按照提示输入相关信息，点击连接即可。
设置账号密码 在菜单栏单击编辑(E)，然后选择用户(U)，打开用户设置界面。按照以下进行设置。
设置账户：
设置密码：
为账户设置共享目录以及权限(全选，方便测试)：
FileZilla Client 简介 FileZilla客户端是一个快速可靠的、跨平台的FTP、FTPS和SFTP客户端。具有图形用户界面(GUI)和很多有用的特性。
下载与安装 FileZilla Client的下载地址为：https://www.filezilla.cn/download/client。
选择FileZilla64位绿色版下载(免安装)。
连接FtpServer 运行filezilla.exe，界面如下:
按照下面图示进行连接：(注意，端口号为21，不是14147)
连接成功后，界面如下：
界面左边是本地信息，界面右边是远程站点信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da552ef09bb3ce14087af7d7e188f642/" rel="bookmark">
			android广播intent原理,Android中BroadcastReceiver详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BroadcastReceiver是什么？
Android app可以发送广播也可以接收系统或者其它app发送的广播，是发送/订阅的设计模式。这些广播被发送当重要的事件发生的时候。例如，安卓系统发送广播当各种各样系统事件发生的时候，比如手机启动了或者手机开始充电了。应用也可以发送自定义广播，例如通知其它应用一些他们可能感兴趣的东西，比如一些新的内容被下载了。
系统广播会在系统事件发生的时候被发送出来，比如当手机进入或者退出开发者选项的时候，所有订阅了系统广播的人都可以收到这个广播。
广播它自身是被包裹在了一个Intent里面，它是有一个唯一的标识的(例如android.intent.action.AIRPLANE_MODE)。这个Intent对象同时包含了一些其它的信息，在它的字段里面，飞行模式这个intent里面就包含了一个boolean的字段来表示飞行模式是开启还是关闭的。
BroadcastReceiver能用来做什么?
接收系统发送出的重要的广播(网络变化，开机，充电)
app之间相互通信，相互拉活的手段
app内部组建间通信的手段
BroadcastReceiver分为哪几类？
从不同的纬度区分，可能分为不同的类别。
系统广播/非系统广播
全局广播/本地广播
无序广播/有序广播/粘性广播
BroadcastReceiver怎么使用？
1. 注册广播
1.1 静态注册广播
复制代码
1.2 动态注册广播
val br: BroadcastReceiver = MyBroadcastReceiver()
val filter = IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION).apply {
addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED)
}
registerReceiver(br, filter)
复制代码
2. 发送广播
Intent().also { intent -&gt;
intent.setAction("com.example.broadcast.MY_NOTIFICATION")
intent.putExtra("data", "Notice me senpai!")
sendBroadcast(intent)
}
复制代码sendBroadcast(Intent("com.example.NOTIFY"), Manifest.permission.SEND_SMS)
复制代码
复制代码
3. 接收广播
private const val TAG = "MyBroadcastReceiver"
class MyBroadcastReceiver : BroadcastReceiver() {
override fun onReceive(context: Context, intent: Intent) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da552ef09bb3ce14087af7d7e188f642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b2c7f0f9e2ca422d0ee80feedf47ab1/" rel="bookmark">
			android 动态生成直线,Android：Textview中的直线/水平线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我正在使用在EditText中每行文本之间绘制线条的技术,然后我将通过将setKeyListener(null)设置为自定义EditText对象使EditText不可编辑,这样,EditText就像一个TextView ?
一个自定义的EditText,用于在显示的每行文本之间绘制线条：
public class LinedEditText extends EditText {
private Rect mRect;
private Paint mPaint;
// we need this constructor for LayoutInflater
public LinedEditText(Context context, AttributeSet attrs) {
super(context, attrs);
mRect = new Rect();
mPaint = new Paint();
mPaint.setStyle(Paint.Style.STROKE);
mPaint.setColor(0x800000FF);
}
@Override
protected void onDraw(Canvas canvas) {
int count = getLineCount();
Rect r = mRect;
Paint paint = mPaint;
for (int i = 0; i &lt; count; i++) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b2c7f0f9e2ca422d0ee80feedf47ab1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08f2bb16df64ce7ce70afad1bd87e251/" rel="bookmark">
			android播放mp3旋转动画,Android 实现旋转木马的音乐效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、百度在线音乐旋转木马效果
就上面那个，当音乐在播放的时候，那个光碟轮子在转，就想旋转木马一般。感觉好好玩啊。
碰巧想起前阵子做音乐播放器，哎，那这个也可以做在手机的音乐播放器上，这样就代替了进度条了。
一想到，就兴奋，于是，首先画圆形，然后放置背景图片，然后使用动画旋转。当音乐播放时，同时
开始播放圆形图片的动画，当音乐暂停时，暂停旋转；当音乐停止播放时，就停止动画，图片回到原点。
二、效果
三、实现代码
(1)MainActivity
public class MainActivity extends Activity {
MediaPlayer m1;
ImageView infoOperatingIV;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
infoOperatingIV = (ImageView) findViewById(R.id.infoOperating);
Button play = (Button) findViewById(R.id.play);
Button stop = (Button) findViewById(R.id.stop);
play.setOnClickListener(new OnClickListener() {
@Override
public void onClick(View v) {
playMusic();
}
});
stop.setOnClickListener(new OnClickListener() {
@Override
public void onClick(View v) {
stopMusic();
}
});
}
private void playMusic() {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08f2bb16df64ce7ce70afad1bd87e251/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e3e12198972998cdc9dd3a8f4dfaa6/" rel="bookmark">
			openvino c&#43;&#43;推理华盛顿大学BackgroundMattingV2模型人像抠图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用openvino c++推理华盛顿大学BackgroundMattingV2模型人像抠图。
基本性能：仅使用CPU可以实现720P实时推理
开源项目：https://github.com/kingpeter2015/libovmatting
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b948ae0e71e2721f7e2a5da50a6807a7/" rel="bookmark">
			linux 取最后一列,awk取最后一列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
想查到某个目录下所有以sd_sensor_xxxx.log等文件中，最后一个序号文件的序号。
也就是，要把xxxx取出来。
解决办法：
1. 首先要取到所有sd_sensor_xxxx.log文件中的最后一行文件，该文件代表了最大的序号；
ls -l sd_*.log | sed -n '$p'当前目录有如下文件：
[root@Real6410 sdcard]# lshello sd_sensor_0000.log sd_sensor_0002.log test.txt
使用命令之后：
[root@Real6410 sdcard]# ls -l sd*.log | sed -n '$p' -rwxrwxrwx 1 root root 0 Dec 6 01:29 sd_sensor_0002.log
2. 使用awk取到上述显示内容的最后一列，不需要具体数sd_sensor_0002.log排在第几列。命令：
[root@Real6410 sdcard]# ls -l sd*.log | sed -n '$p'| awk '{print $NF}'sd_sensor_0002.log
3. 再次使用awk加切分符号将0002分离出来。命令：
ls -l sd*.log | sed -n '$p'| awk '{print $NF}' | awk -F '.' '{print $1}' | awk -F '_' '{print $NF}'使用命令结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b948ae0e71e2721f7e2a5da50a6807a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a17a80393f0d2f310707247434af8e1/" rel="bookmark">
			Elasticsearch聚合分析(一)——Metric聚合分析  2021/5/25
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Elasticsearch聚合分析 什么是聚合分析 简介： 聚合分析，英文为Aggregation，是es除搜索功能外提供的针对es数据做统计分析的功能
ES提供多种分析方式： Bucket、Metric、Pipeline 等Bucket，分桶类型，类似SQL语法中的group by语法。Metric，指标分析类型，如计算最大值，最小值，平均值等等。Pipeline，管道分析类型，基于上一级的聚合分析结果进行再分析。Matrix，矩阵分析类型。 Metric聚合分析 Metric分析分类 1.单值分析：只输出一个分析结果。 min（最小值）max（最大值）avg（平均值）sum（总和）cardinality（计算数目的，类似sql中的distinct count） 2.多值分析，输出多个分析结果 stats（多样统计分析，可以一次性得到最小值，最大值，平均值，中值等等）、extended stats、percentile（百分位数的统计）、percentile rank、top hits（排在前面的结果列表） 单值：最小值 GET /linGuanlink/_search { "size": 0,	// 不需要返回文档列表 "aggs": { "min_age": {	// 自定义聚合名称 "min": {	// 聚合类型 "field": "age" } } } } 单值：最大值 GET /linGuanlink/_search { "size": 0, "aggs": { "max_age": { "max": { "field": "age" } } } } 单值：平均值 GET /linGuanlink/_search { "size": 0, "aggs": { "avg_age": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a17a80393f0d2f310707247434af8e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a5e2797e127dabe80c31f9bbbd25961/" rel="bookmark">
			PML之多元回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、多元回归(Multiple Regression)
多元回归就像线性回归一样，但是具有多个独立值，这意味着我们试图基于两个或多个变量来预测一个值。
列子：car表示汽车类型，model表示模式，volume配置发动机的容量，weight汽车的重量，co2释放二氧化碳的量
CarModelVolumeWeightCO2ToyotaAygo100079099MitsubishiSpace Star1200116095SkodaCitigo100092995Fiat50090086590MiniCooper15001140105VWUp!1000929105SkodaFabia1400110990MercedesA-Class1500136592FordFiesta1500111298AudiA11600115099HyundaiI20110098099SuzukiSwift1300990101FordFiesta1000111299HondaCivic1600125294HundaiI301600132697OpelAstra1600133097BMW11600136599Mazda322001280104SkodaRapid16001119104FordFocus20001328105FordMondeo1600158494OpelInsignia2000142899MercedesC-Class2100136599SkodaOctavia1600141599VolvoS602000141599MercedesCLA15001465102AudiA420001490104AudiA620001725114VolvoV7016001523109BMW520001705114MercedesE-Class21001605115VolvoXC7020001746117FordB-Max16001235104BMW216001390108OpelZafira16001405109MercedesSLK25001395120 import pandas from sklearn import linear_model df = pandas.read_csv("cars.csv") #x有俩个维度，重量和发动机容量 X = df[['Weight', 'Volume']] #y表示释放二氧化碳的量 y = df['CO2'] #调用线性模型 regr = linear_model.LinearRegression() #进行线性拟合 regr.fit(X, y) #预测2300kg的汽车重量，1300cm的发动机容量，行驶1公里可以释放的二氧化碳 predictedCO2 = regr.predict([[2300, 1300]]) #打印预测结果 print(predictedCO2) #打印参数 print(regr.coef_) [107.2087328]#释放的二氧化碳 [0.00755095 0.00780526]#表示重量增加1公斤，释放二氧化碳是0.00755095，容量增加1升，释放的二氧化碳是0.00780526 重量：0.00755095体积：0.00780526
这些值告诉我们，如果重量增加1kg，则CO2排放量增加0.00755095g。
如果发动机尺寸（容积）增加1 cm3，则CO2排放量将增加0.00780526 g。
2、标准化处理
标准化方法使用以下公式：
z = (x - u) / s
其中z是新值，x是原始值，u是平均值，而s是标准值偏差。
列子：
import pandas from sklearn import linear_model from sklearn.preprocessing import StandardScaler scale = StandardScaler() df = pandas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a5e2797e127dabe80c31f9bbbd25961/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c923b0f07c76a17f6b8e114b71cfcf9a/" rel="bookmark">
			PostgreSQL安装与简单操作 - linux Ubuntu 服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装PostgreSQL并设置用户和密码 1.1 打开终端或服务器 sudo apt-get install postgresql-9.5
上面是安装9.5版本，如果是安装最新版本，则不需要写版本号。
安装成功后，自动添加一个名为postgres的系统用户，密码随机。并自动生成一个名为postgres的数据库，用户名为postgres，密码随机。
1.2 打开客户端工具（psql）修改postgres数据库用户的密码 sudo -u postgres psql 使用postgres用户登录数据库
登录成功后，命令就会在postgres=#下运行
#以下内容内容都是在 postgres=# 下输入 ALTER USER postgres WITH PASSWORD '123456'; # 密码设置为123455，有分号才会执行命令 \q #退出客户端 1.3 修改ubuntu操作系统的postgres用户的密码 su root 切换到root用户
以上切换到root用户后会要求输入密码，如果输入后提示验证失败，不用管，直接进行下一步。
sudo passwd -d postgres #清空用户postgres的密码 sudo -u postgres passwd #设置密码 接下来按要求输入两次密码，要与上面的密码相同 2.数据库操作 2.1 创建数据库——恢复数据库/数据表 以下内容都是在user@user:~$下输入
切换到普通用户用一下三种方法
ctrl + d# su my root ‘username’ 退回到usernameexit sudo -u postgres createdb -O postgres test # O是大写的字母 #使用postgres连接数据库，创建属于用户postgres的数据库test pg_restore --host localhost --port 5432 --username "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c923b0f07c76a17f6b8e114b71cfcf9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33ab96e42eddc47c9eeb1e7c8b929fa4/" rel="bookmark">
			PML之多项式拟合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多项式回归(Polynomial Regression)
如果数据点不适合线性回归，我们就要考虑使用多项式回归
import matplotlib.pyplot as plt x = [1,2,3,5,6,7,8,9,10,12,13,14,15,16,18,19,21,22] y = [100,90,80,60,60,55,60,65,70,70,75,76,78,79,90,99,99,100] plt.scatter(x, y) plt.show() 绘制多项式拟合线：
import numpy import matplotlib.pyplot as plt from sklearn.metrics import r2_score#查看拟合度 x = [1,2,3,5,6,7,8,9,10,12,13,14,15,16,18,19,21,22] y = [100,90,80,60,60,55,60,65,70,70,75,76,78,79,90,99,99,100] #NumPy有一种方法可以让我们建立多项式模型： mymodel = numpy.poly1d(numpy.polyfit(x, y, 3)) #从位置1开始，到位置22结束 myline = numpy.linspace(1, 22, 100) print(r2_score(y, mymodel(x)))#查看拟合度 #原始散点 plt.scatter(x, y) #画出多项式回归线： plt.plot(myline, mymodel(myline)) plt.show() 查看拟合度：
F:\开发工具\pythonProject\tools\venv\Scripts\python.exe F:/开发工具/pythonProject/tools/bys/ml03.py 0.9432150416451025 Process finished with exit code 0 0.94表示很好。
查看x和y之间的关系：使用r平方
r平方值的范围是0到1，其中0表示不相关，而1表示100％相关。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f23388aa8c421a53ae5f04d9d3653379/" rel="bookmark">
			PML之线性回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性回归：
import matplotlib.pyplot as plt x = [5,7,8,7,2,17,2,9,4,11,12,9,6] y = [99,86,87,88,111,86,103,87,94,78,77,85,86] plt.scatter(x, y) plt.show() import matplotlib.pyplot as plt from scipy import stats x = [5,7,8,7,2,17,2,9,4,11,12,9,6] y = [99,86,87,88,111,86,103,87,94,78,77,85,86] #slope表示斜率，intercept表示偏置，r相关系数，p使用Wald检验和检验统计量的t分布，对假设检验的两侧p值进行零假设，该假设的零假设是斜率为零。 #std_err在残余正态性假设下，估计坡度（梯度）的标准误差。 slope, intercept, r, p, std_err = stats.linregress(x, y) def myfunc(x): return slope * x + intercept #产生一个新的y值，就是回归线的y值 mymodel = list(map(myfunc, x)) plt.scatter(x, y) plt.plot(x, mymodel) plt.show() 用法：
输入已知的x的数值，就可以获取y值的预测值。查看这些数据是否适合用新型回归，看看r的值，r越小表示回归预测越差。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af7a976d228e7b165542eaa759c95a1c/" rel="bookmark">
			PML之百分位数、数据分布、正态数据分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是百分位数？
示例：假设我们有一个街道上所有人口的年龄数组。
ages = [5,31,43,48,50,41,7,11,15,39,80,82,32,2,8,6,25,36,27,61,31]
什么是75.百分位数？答案是43，这意味着75％的人是43岁或以下。
90％的人口年龄是多少岁？ import numpy ages = [5,31,43,48,50,41,7,11,15,39,80,82,32,2,8,6,25,36,27,61,31] x = numpy.percentile(ages, 90) print(x) 结果：
61.0 意味着90%以下的年龄是61岁以下。
2、数据分布(Data Distribution)
创建一个包含250个介于0和5之间的随机浮点数的数组：
#数据分布 x = np.random.uniform(0.0, 5.0, 250) plt.hist(x, 5) plt.show() 直方图解释
我们使用上例中的数组绘制5条柱状图。
第一栏代表数组中介于0和1之间的值。
第二栏代表1到2之间的数值。
这给了我们这个结果：
52个值介于0和1之间48个值介于1和2之间49个值介于2和3之间51个值在3和4之间50个值介于4到5之间 3、正太数据分布
在概率论中，在数学家卡尔·弗里德里希·高斯（Carl Friedrich Gauss）提出了这种数据分布的公式之后，这种数据分布被称为正态数据分布或高斯数据分布。
#正太分布（平均值为5.0，标准差为1.0） x = np.random.normal(5.0, 1.0, 100000) plt.hist(x, 100) plt.show() 注意：由于正态分布图具有钟形的特征形状，因此也称为钟形曲线。
直方图解释
我们使用numpy.random.normal()方法中的数组，该数组具有100000个值，以绘制100个条形的直方图。
我们指定平均值为5.0，标准差为1.0。
这意味着该值应集中在5.0左右，并且很少远离平均值小于1.0。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/360/">«</a>
	<span class="pagination__item pagination__item--current">361/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/362/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>