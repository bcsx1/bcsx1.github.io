<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4cd40650f90cda5491be42a03ac3ea7/" rel="bookmark">
			网络分析仪 smith圆图调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ecf20dda8e047ade5f2f334205ab3b8/" rel="bookmark">
			编译型or解释型？Python运行机制浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python语言通常被看作是解释型语言，不同于像C语言那样的编译型。但实际上，如果说Python是编译型语言，也未尝不可。我们来一起看一下1！
1.举个栗子 首先看一个简单的例子：
#!/usr/bin/python3 # file name ：demo1.py a=1 b=2 print("a+b = ",a+b) c=NotDefinedValue print(c) 这里第四行有个赋值的错误，但python在运行前不会进行类型检查，所以该程序仍可正常运行，直至遇到错误，运行结果与预想的一致：
a+b = 3 Traceback (most recent call last): File "/demo.py", line 4, in &lt;module&gt; c=NotDefinedValue NameError: name 'NotDefinedValue' is not defined Process finished with exit code 1 现在稍微改动一下，使最后一行有个语法错误（少个括号）：
#!/usr/bin/python3 # file name ：demo2.py a=1 b=2 print("a+b = ",a+b) c=NotDefinedValue print(c 按照对python语言的理解，程序应该会逐行执行，直至遇到第一个赋值语句的错误，然后抛出异常。执行结果应该和上面的例子一样。是不是这样呢，我们试着执行，结果如下：
File "/demo.py", line 6 SyntaxError: unexpected EOF while parsing 可见没有像预想的一样，而是直接抛出语法错误。
那么问题来了，前三行代码没错误，为什么不能正常执行呢？python作为解释性语言，应该是“一边执行一边转换”的，后面的“错误”按理说不会影响前面正确的代码的啊？2 那可能有同学要说了，python在运行之前会检查语法！但“检查语法”是个怎样的过程呢？要知道答案，需要了解python底层的运作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ecf20dda8e047ade5f2f334205ab3b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfe08a56917cbb9c296d34adabd1f227/" rel="bookmark">
			schema.xml文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyCatschema.xml 详解
1.读写分离文件主要为： schema.xml
主要配置字段为：
&lt;?xml version="1.0"?&gt; &lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt; &lt;mycat:schema xmlns:mycat="http://io.mycat/"&gt; &lt;schema name="TESTDB" checkSQLschema="false" sqlMaxLimit="100" dataNode="dn1"&gt; &lt;table name="travelrecord" dataNode="dn1,dn2,dn3" rule="auto-sharding-long" /&gt; &lt;table name="company" primaryKey="ID" type="global" dataNode="dn1,dn2,dn3" /&gt; &lt;table name="goods" primaryKey="ID" type="global" dataNode="dn1,dn2" /&gt; &lt;table name="hotnews" primaryKey="ID" autoIncrement="true" dataNode="dn1,dn2,dn3" rule="mod-long" /&gt; &lt;table name="customer" primaryKey="ID" dataNode="dn1,dn2" rule="sharding-by-intfile"&gt; &lt;childTable name="orders" primaryKey="ID" joinKey="customer_id" parentKey="id"&gt; &lt;childTable name="order_items" joinKey="order_id" parentKey="id" /&gt; &lt;/childTable&gt; &lt;childTable name="customer_addr" primaryKey="ID" joinKey="customer_id" parentKey="id" /&gt; &lt;/table&gt; &lt;/schema&gt; &lt;dataNode name="dn1" dataHost="localhost1" database="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfe08a56917cbb9c296d34adabd1f227/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9387ca17c73264f688b46f2554ff77e/" rel="bookmark">
			红黑树的插入和删除自平衡基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 参考文档 30张图带你彻底理解红黑树 过程 插入自平衡的7种情况记录 红黑树为空树。把插入节点作为根节点，并把节点设置为黑色。
插入节点的Key已存在。更新当前结点的值为插入节点的值。
插入节点的父节点为黑节点。直接插入。
插入节点的父亲节点是红节点的时候，一共有4种情况。a,叔叔节点存在且为红色。b,叔叔节点存在是黑色或者不存在。
如果是a情况（插入的时候有两种插入的情况，但是都一样处理），不用旋转，只需要变更父亲节点和祖父节点的颜色，并且把祖父节点设置成插入的节点，继续判断。
如果是b情况，就需要旋转，为什么需要旋转，是因为出现某些子树的节点多了，因此需要旋转。
是祖父节点的左子树。 记住标准的一个，插入节点是父亲节点的左子树。对父亲节点和祖父节点进行变色，并右旋祖父节点。
是祖父节点的右子树。 插入节点是父亲节点的右子树，需要先左旋父亲节点，变成“标准模式”。然后，对父亲节点和祖父节点进行变色，并右旋祖父节点。
删除自平衡的9种情况记录 有哪些情形？
a) 若删除节点无子节点，直接删除。
b) 若删除节点只有一个子节点，用子节点替换删除节点。
c) 若删除节点有两个子节点，有后续节点（大于删除节点的最小节点）替换删除节点。
对于上述情形c有9种情况：理解前提条件（删除操作删除的节点可以看作删除替代节点，而替代节点最后总是在树末。）
如果替换节点是红色的，则不影响树的平衡，因此在树的末端找到替代节点，把替代节点的颜色设置为删除节点的颜色即可。
如果替换节点是黑色的，则一定会影响树的平衡。
是父亲节点的左子节点 兄弟节点是红节点 （变形到下面的三种情况中的某一种） 兄弟节点是黑节点 a,右子节点是红节点，左子节点任意颜色（标准模式） b,右子节点是黑节点，左子节点为红节点（目标是变成标准模式b---&gt;a） c,子节点都为黑节点（变成b或者a，如果变成b的话，还需要在变形到a标准模式即可） 是父亲节点的右子节点 兄弟节点是红节点（变形到下面三种情况中的某一种） 兄弟节点是黑节点 a,左子结点是红结点，右子结点任意颜色(标准模式) b,左子结点是黑结点，右子结点为红结点（目标是变成标准模式b---&gt;a） c,子结点都为黑结点（变成b或者a，如果变成b的话，还需要在变形到a标准模式即可） 小结 插入规律：核心就是，旋转的时机是什么？旋转方向分析过程：如果右旋转，则左子树节点多了。如果左旋转，则右子树节点多了。无论左旋还是右旋，都是旋转点，往下拉扯，儿子节点往上拉扯。记住标准模式，有时候需要旋转父亲节点，转化成标准模式
什么是标准模式？
这是自定义的。
a) 祖父的左子树，父亲依然是左节点，插入的节点依然是左节点插入。
b) 祖父的右子树，父亲依然是右节点，插入的节点依然是右节点插入。
什么时候旋转？
a) 必须把当前节点插入情况，先转化为标准模式，这个时候，不变色，只是旋转父亲节点即可。旋转可以理解为拉扯，左旋就是把旋转点往一边拉扯。
b) 红黑树某个分支的层高或者叫深度比另一个分支高2了，这个时候需要旋转。先变父亲节点色，再变祖父节点色，把祖父节点当成旋转点，然后往节点少的一个分支拉扯即可。
操作：变色 + 拉扯（旋转）
不用记忆具体的操作细节。而是想，出现某种情况的时候，是变色还是拉扯（旋转）。
删除结论。删除操作可以看成删除替代节点。先找到删除节点的替代节点。然后，分析替代节点是什么颜色即可。如果替代节点是红色的，不影响红黑树平衡，但是颜色会被设置成删除节点的颜色。
后续通过结合HashMap源码对红黑树的实践过程，反过来理解红黑树理论知识，会发现，理论知识是一样的，但是实现的细节或者说是小技巧是不一样的，理解起来反而更加清晰。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58ff1e3e6cd58682338f4dd981df3240/" rel="bookmark">
			PCL可视化vtkRenderingOpenGL问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、问题描述二、问题解决方法 一、问题描述 我使用的pcl版本是pcl1.8.0，而在使用PCL可视化中的PCLVisualizer类时，出现了下面的问题：
因为对于PCL我也是个小白，所以感觉这错的莫名其妙啊。所以我就去网上搜索了一下，网上说是添加下面的这几行代码就可以了。
#include &lt;vtkAutoInit.h&gt; VTK_MODULE_INIT(vtkRenderingOpenGL); VTK_MODULE_INIT(vtkInteractionStyle); VTK_MODULE_INIT(vtkRenderingFreeType); 然后我就添加了这几行代码，可是又出现了下面的问题：
严重性	代码	说明	项目	文件	行	禁止显示状态错误	LNK2019	无法解析的外部符号 "void __cdecl vtkRenderingOpenGL_AutoInit_Destruct(void)" (?vtkRenderingOpenGL_AutoInit_Destruct@@YAXXZ)，该符号在函数 "public: __cdecl vtkRenderingOpenGL_ModuleInit::~vtkRenderingOpenGL_ModuleInit(void)" (??1vtkRenderingOpenGL_ModuleInit@@QEAA@XZ) 中被引用	cloud_viewer 没有办法只能再去搜索去了，就看到有的博主说可以将下面这行代码修改就可以了。
VTK_MODULE_INIT(vtkRenderingOpenGL); 修改为：
VTK_MODULE_INIT(vtkRenderingOpenGL2); 于是，我就试了一下，倒是真的能运行了，但是又出现了了新的问题。
当我使用鼠标进行点云的缩放时，程序就会突然的崩溃，说是PCL中的一个vtkRenderingOpenGL2-8.0.dll文件在执行时出现了异常，内存访问冲突。
在问题一个接一个的出现之后，终于走到了最后一个问题的面前，不容易啊。
二、问题解决方法 又到网上搜索了一圈之后，我大概能够确定了问题就出在vtkRenderingOpenGL2-8.0.dll这个文件中了，那就没啥好的办法了只能重新编译VTK8.0了。具体的步骤可以看：QT配置PCL过程记录(一)和QT配置PCL过程记录(二)。
不过在重新编译的过程中我们要注意的是下面的这个选项：
这个选项会决定你之后生成的文件时vtkRenderingOpenGL-8.0.dll还是vtkRenderingOpenGL2-8.0.dll，不过这倒也无所谓对后面也没有太大的影响。
通过cmke生成项目之后，按部就班的先生成Debug版本的lib文件，现在就要注意一下，你生成路径中bin文件夹下的dll文件了。
如果你再生成Release版的lib文件，则你的bin文件夹下就会生成相应的Release版的dll文件，它会覆盖你之前的Debug版的dll文件，所以我建议可以先复制Debug版的dll文件做个备份。
注意：一定要根据你的版本来选择Debug版的dll文件或是Release版的dll文件，否则运行还是会失败的。我就是踩了这个坑所以耽误了我很多的时间，难受啊，所以一定要注意这一点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b775b6ca5bfab70d7f9dfdc4475045f/" rel="bookmark">
			腾讯云服务器标准型SA2详细情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云标准型SA2实例是新一代实例，特点是使用了 AMD CPU，按照文档中的描述，这款实例提供了稳定平衡的计算、内存和服务器资源，是应用程序的绝佳选择。之前SA2实例一直没有对外开放，最近看到开放使用了，就分享出相关信息。
腾讯云标准型SA2配置参数 CPU处理器：AMD EPYC ROME新一代处理器，主频2.6GHz，睿频3.3GHz。
内存：最新一代八通道 DDR4，内存计算性能稳定。
网络：超高网络收发包能力达750万pps，最大网络带宽25Gbps。
比同样的标准型SA1的数据好看很多。
腾讯云标准型SA2 用在哪里 各种类型和规模的企业级应用
搜索等计算集群
视频编解码、视频渲染等对单核性能敏感的应用
更多信息看云服务器&gt; 实例规格
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0782a62afd036eab5464cb5fafd1536c/" rel="bookmark">
			电脑版微信多开的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一台电脑登录多个微信也是很多人的常态，今天分享三种电脑版微信多开的方法。
一、简单暴力回车法 这个方法不需要借助任何工具，直接在电脑版微信本身即可无限多开~此方法并非100%成功率，有时候需要大家多尝试几次。缺点就是登陆多个账号需要一一的扫码登录。
1，鼠标左键单击桌面微信图标。
2，按住键盘回车（不要松开）
3，再单击鼠标左键，想要多开几个微信就单击几次。
二、高端方便代码法 此方法的原理和上一个方法原理相同，利用了一串代码，让多开更加方便，成功率100%。
1，桌面新建一个TXT文本，将以下代码复制进去。其中红色框内内容是需要修改内容，改为你的微信安装路径即可。需要多开几个微信，你就复制几行 start +路径代码。下图为双开。
TASKKILL /F/IM WECHAT.EXE start " " "D:\Program Files (x86)\WeChat\WeChat.exe" start " " "D:\Program Files (x86)\WeChat\WeChat.exe" 2，另存为.bat格式。双击bat文件即可多开微信。
3，如遇bat文件闪退，请百度：批处理文件闪退解决办法。
三，uwp应用+网页版 如果你的电脑是win10系统，除了使用网页版微信，还可以安装一个uwp应用的微信。
1，打开微软store商店，在里面搜索微信并下载。
这样我们电脑中就可以安装两个微信，且互不冲突。每次登陆微信不需要扫码。非常适合需要登陆两个微信的小伙伴。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2debf4974a25a53d708af4c0fa62fb/" rel="bookmark">
			CVPR2020 | Context Prior：在语义分割中引入上下文先验，Cityscapes上81.3％mIoU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“AI算法修炼营”，选择加星标或“置顶”
标题以下，全是干货
论文链接：https://arxiv.org/pdf/2004.01547.pdf
代码链接：https://git.io/ContextPrior
最近的工作广泛探索了上下文相关性在语义分割任务中的重要性，通过充分捕获上下文信息以获得更准确的分割结果。但是，大多数方法很少区分不同类别之间的上下文相关性，这可能会影响语义分割模型的性能。例如，之前的经典工作non-local网络关注的是特征图像素点之间的关系，而忽略了不同类别之间的上下文依赖关系，因为并不是所有的类间依赖关系都对语义分割模型有用，有些甚至会造成混乱。non-local机制细节可以参考文章：视觉注意力机制 | non-local和自注意力机制的区别和联系）
在这项工作中，作者直接监督特征聚合以清楚地区分类内和类间上下文。具体来说，在亲和度损失下设计了一个即插即用的通用模块：context prior layer（上下文先验层）。给定一个输入图像和相应的ground truth，根据亲和度损失构建了一个Ideal Affinity Map以监督类内和类间信息的产生，使得学习的上下文先验提取属于同一类别的像素，而反向先验则关注于不同类别的像素，规范了类内和上下文信息的分离。
提出的context prior layer可以有选择地捕获类内和类间上下文相关性，从而实现可靠的特征表示。为了验证有效性，设计了有效的上下文先验网络（CPNet）。大量的定量和定性评估表明，所提出的模型与最新的语义分割方法相比具有良好的性能，实现SOTA。更具体地说，在ADE20K上达到46.3％mIoU，在PASCAL-Context上达到53.9％mIoU，在Cityscapes上达到81.3％mIoU。
主要贡献：
1）构造了一个上下文先验，并监督嵌入上下文先验层中的亲和力损失，以明确捕获类内和类间上下文依赖关系；
2）为语义分割设计了一个有效的上下文先验网络（CP-Net），其中包含骨干网络backbone和上下文先验层context prior layer；
3）所提出的方法在ADE20K，Pascal-Context和Cityscapes上实现SOTA。
文章的核心思想在于：根据标签，事先知道哪些像素属于同一个类，那么就可以利用这个先验知识去监督标签预测，使得预测结果尽量让同类像素的预测结果相同。
一、背景
受卷积层结构的限制，全卷积网络FCN提供的上下文信息不足，有待改进。近年来各种方法被提出来用于探索上下文依赖性，以获得更准确的分割结果。
目前，聚合上下文信息主要有两种方法:
（1）基于金字塔的聚合方法
有几种方法如PSPNet采用基于金字塔的模块或全局池化来有规律的聚合区域或全局上下文信息。然而，它们捕获了同类的上下文关系，却忽略了不同类别的上下文，如图1(b)所示。当场景中存在混淆类别时，这些方法可能会导致上下文可靠性降低。
（2）基于注意力的聚合方法
最近基于注意力的方法，如通道注意力、空间注意力、point-wise attention，有选择地聚合不同类别之间的上下文信息。然而，由于缺乏明确的区分，注意力机制的关系描述不太清楚。因此，它可能会选择不需要的上下文依赖关系，如图1(e)所示。
总体而言，这两种方式都在没有明确区分类内和类间上下文的情况下聚合了上下文信息，从而导致了不同上下文关系的混合，造成混乱。
图1：语义分割中很难分割的情形示例。在第一行中，红色方框中的sand的中心部分被误分类为大海，因为阴影部分的外观与大海相似。使用基于金字塔的聚合方法，混淆的空间信息的聚合可能导致不良的预测，如（b）所示。在第二行中，绿色框中的桌子的外观与床的底部相似。基于注意力的方法在没有先验知识的情况下无法有效地区分混淆的空间信息，从而导致预测结果不正确，如（e）所示。在作者提出的CPNet中，以清晰的区分方式聚合了上下文相关性。值得注意的是，上下文先验将类内和类间关系建模为上下文先验知识，以捕获类内和类间上下文相关性。
作者注意到，确定的上下文依赖关系有助于卷积神经网络理解场景。相同类别的相关性（类内部上下文）和不同类别之间的差异（类间上下文）使特征表示更鲁棒，并减少了可能类别的搜索空间。因此，将ground truth建模类内和类间的先验知识，从而去监督网络上下文信息的学习，以获得更准确的预测，这对于场景分割非常重要。
二、具体方法
文中，将上下文先验公式化为二进制分类器，以区分哪些像素属于当前像素的同一类别，而相反的先验可以集中于不同类别的像素。
具体来说，首先使用全卷积网络来生成特征图和相应的先验图。对于特征图中的每个像素，先验地图可以有选择地突出显示属于同一类别的其他像素，以聚合类内上下文，而相反的先验可以聚合类间上下文。将先验地图嵌入到网络中，设计了包含亲和力损失Affinity Loss的Context Prior层，该层直接监督先验的学习。同时，Context Prior还需要空间信息来推理这些关系。为此，设计了一个聚合模块，该模块采用完全可分离的卷积（在空间和深度维度上分开）来有效地聚合空间信息。
2.1、亲和力损失（Affinity Loss）和上下文先验层（Context Prior Layer）
语义分割网络很难从孤立的像素中建模上下文信息。为了让网络建模类别之间的关系，引入了亲和度损失。对于图像中的每个像素，此损失让网络考虑相同类别的像素（上下文内）和不同类别之间的像素（上下文间）。然而，要想用亲和力损失对网络的学习进行监督，就要得到预测图和真值。那么Affinity Loss的真值是怎么产生的呢？
文章首先就从真值标签出发，经过one-hot编码之后，生成每一个类的像素二值标签（如上图）（实际上可以理解成根据标签对每一类做二值分割），于是得到C个HW大小的二值标签MAP。
但是每一个单独的二值标签只代表了某一类像素之间的关联，所以作者进一步将C个HW大小的二值标签MAP扩展成 C个长度等于像素数量N的向量，于是得到N*C的一个矩阵(如下图)。
由于这个矩阵是个二值矩阵，所以作者将它与它的转置相乘，于是得到一个像素与像素之间相互关联（关联主要是指是不是同一类）关系的关联矩阵（图中的Affinity Map）。其实，可以看出Ideal Affinity Map中的第j行（1 &lt;= j &lt;= N）代表着H×W个像素中的第j个像素，与所有像素的关系。举例：如果第j个像素与第i个像素属于相同类别，那么Ideal Affinity Map中第j行第i列的值为1，否者为0。于是，Ideal Affinity Map中蕴含了相当丰富的类内信息，而1-Ideal Affinity Map则为丰富的类间信息。所以通过Affinity Loss使得Context Prior Map能够学习到这些信息。
对于Affinity Loss的就提表示，总的来说：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba2debf4974a25a53d708af4c0fa62fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bccd98b489552c7947ca8152241a4a1/" rel="bookmark">
			pggan学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（边学边更新）
1 、pggan的基本介绍 如果直接生成大分辨率的图片，建立从latent code 到 1024x1024 pixels样本的映射网络G，肯定是很难工作的，因为，在生成的过程中， 判别器D很容易就可以识别出G生成的“假图像”，G难以训练 。因此，提出PGGAN（progressive gan）来进行逐层训练。
训练开始于有着一个4*4像素的低空间分辨率的生成器和判别器。随着训练的改善，逐渐的向生成器和判别器网络中添加层，因此增加生成图片的空间分辨率。所有现存的层通过进程保持可训练性。这里N×N是指卷积层在N×N的空间分辨率上进行操作。这个方法使得在高分辨率上稳定合成并且加快了训练速度。右图展示了六张通过使用在1024 × 1024空间分辨率上渐进增长的方法生成的样例图片。 （如fig1）
当把生成器和判别器的分辨率加倍时，会平滑的增强新的层。这个样例解释了如何从16 × 16像素的图片转换到32 × 32像素的图片。（如fig2）
2x是指用最近邻卷积上采样将图片的长宽翻倍，而0.5x表示用平均池化的方法将图像长宽缩小一倍
关于toRGB &amp;&amp;from RGB : 因为此时生成网络最后的输出通道数不一定为3，所以需要toRGB将其转换为RGB三通道，具体操作时用1x1的卷积核进行卷积操作，fromRGB恰好相反
关于权重α：我们把在更高分辨率上操作的层视为一个残缺块, α表示新加入层的权重，当α=0时，相当于未加入这一层，当α=1时，就变成了一般的网络结构。α在训练过程中逐渐由小增大直至到1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ea98a65d394ba99339c05872cfffa3/" rel="bookmark">
			Flink Checkpoint机制分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创作品，转载请标明：http://blog.csdn.net/xiejingfa/article/details/105439802
可靠性是分布式系统实现必须考虑的因素之一。Flink基于Chandy-Lamport分布式快照算法实现了一套可靠的Checkpoint机制，可以保证集群中某些节点出现故障时，能够将整个作业恢复到故障之前某个状态。同时，Checkpoint机制也是Flink实现Exactly-Once语义的基础。
本文将介绍Flink的Checkpoint机制的原理，并从源码层面了解Checkpoint机制是如何实现的（基于Flink 1.10）。
1. 为什么需要Checkpoint Flink是有状态的流计算处理引擎，每个算子Operator可能都需要记录自己的运行数据，并在接收到新流入的元素后不断更新自己的状态数据。当分布式系统引入状态计算后，为了保证计算结果的正确性（特别是对于流处理系统，不可能每次系统故障后都从头开始计算），就必然要求系统具有容错性。对于Flink来说，Flink作业运行在多个节点上，当出现节点宕机、网络故障等问题，需要一个机制保证节点保存在本地的状态不丢失。流处理中Exactly-Once语义的实现也要求作业从失败恢复后的状态要和失败前的状态一致。
那么怎么保证分布式环境下各节点状态的容错呢？通常这是通过定期对作业状态和数据流进行快照实现的，常见的检查点算法有比如Sync-and-Stop（SNS）算法、Chandy-Lamport（CL）算法。
Flink的Checkpoint机制是基于Chandy-Lamport算法的思想改进而来，引入了Checkpoint Barrier的概念，可以在不停止整个流处理系统的前提下，让每个节点独立建立检查点保存自身快照，并最终达到整个作业全局快照的状态。有了全局快照，当我们遇到故障或者重启的时候就可以直接从快照中恢复，这就是Flink容错的核心。
2. Checkpoint执行流程 Barrier是Flink分布式快照的核心概念之一，称之为屏障或者数据栅栏（可以理解为快照的分界线）。Barrier是一种特殊的内部消息，在进行Checkpoint的时候Flink会在数据流源头处周期性地注入Barrier，这些Barrier会作为数据流的一部分，一起流向下游节点并且不影响正常的数据流。Barrier的作用是将无界数据流从时间上切分成多个窗口，每个窗口对应一系列连续的快照中的一个，每个Barrier都带有一个快照ID，一个Barrier生成之后，在这之前的数据都进入此快照，在这之后的数据则进入下一个快照。
如上图，Barrier-n跟随着数据流一起流动，当算子从输入流接收到Barrier-n后，就会停止接收数据并对当前自身的状态做一次快照，快照完成后再将Barrier-n以广播的形式传给下游节点。一旦作业的Sink算子接收到Barrier n后，会向JobMnager发送一个消息，确认Barrier-n对应的快照完成。当作业中的所有Sink算子都确认后，意味一次全局快照也就完成。
当一个算子有多个上游节点时，会接收到多个Barrier，这时候需要进行Barrier Align对齐操作。
如上图，一个算子有两个输入流，当算子从一个上游数据流接收到一个Barrier-n后，它不会立即向下游广播，而是先暂停对该数据流的处理，将到达的数据先缓存在Input Buffer中（因为这些数据属于下一次快照而不是当前快照，缓存数据可以不阻塞该数据流），直到从另外一个数据流中接收到Barrier-n，才会进行快照处理并将Barrier-n向下游发送。从这个流程可以看出，如果开启Barrier对齐后，算子由于需要等待所有输入节点的Barrier到来出现暂停，对整体的性能也会有一定的影响。
综上，Flink Checkpoint机制的核心思想实质上是通过Barrier来标记触发快照的时间点和对应需要进行快照的数据集，将数据流处理和快照操作解耦开来，从而最大程度降低快照对系统性能的影响。
Flink的一致性和Checkpoint机制有紧密的关系：
当不开启Checkpoint时，节点发生故障时可能会导致数据丢失，这就是At-Most-Once当开启Checkpoint但不进行Barrier对齐时，对于有多个输入流的节点如果发生故障，会导致有一部分数据可能会被处理多次，这就是At-Least-Once当开启Checkpoint并进行Barrier对齐时，可以保证每条数据在故障恢复时只会被重放一次，这就是Exactly-Once 3. Checkpoint相关配置 StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); env.enableCheckpointing(1000); env.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE); env.getCheckpointConfig().setMinPauseBetweenCheckpoints(500); env.getCheckpointConfig().setCheckpointTimeout(60000); env.getCheckpointConfig().setMaxConcurrentCheckpoints(1); env.getCheckpointConfig().enableExternalizedCheckpoints(ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION); 默认情况下，Checkpoint机制是关闭的，需要通过enableCheckpointing(interval)来开启，并指定每interval毫秒进行一次Checkpoint。Checkpoint模式支持Exactly-Once和At-Least-Once，可以通过setCheckpointingMode来设置。如果两次Checkpoint的时间很短，会导致整个系统大部分资源都用于执行Checkpoint，影响正常作业的执行。可以通过setMinPauseBetweenCheckpoints来设置两次Checkpoint之间的最小间隔。setCheckpointTimeout可以给Checkpoint设置一个超时时间，当一次Checkpoint超过一定时间没有完成，直接终止掉。默认情况下，当一个Checkpoint还在执行时，不会触发另一个Checkpoint，通过setMaxConcurrentCheckpoints可以设置最大并发Checkpoint数量。enableExternalizedCheckpoints可以设置当用户取消了作业后，是否保留远程存储上的Checkpoint数据，一般设置为RETAIN_ON_CANCELLATION。 4. Checkpoint过程源码分析 4.1 Client端生成Checkpoint配置 Client端在向JobManger提交作业前会根据用户代码生成StreamGraph，再转化为JobGraph，在构建JobGraph时会调用configureCheckpointing生成JobCheckpointingSettings配置并保存在JobGraph中。这里要注意到triggerVertices这个集合，它表示Flink通过这些节点触发Checkpoint。在构建JobGraph时只会将Source节点加入到triggerVertices，决定Flink之后发起Checkpoint时只针对Source节点注入Barrier。
private void configureCheckpointing() { CheckpointConfig cfg = streamGraph.getCheckpointConfig(); ...（省略部分代码，只展示核心流程，下同） // --- configure the participating vertices --- // collect the vertices that receive "trigger checkpoint" messages. // currently, these are all the sources List&lt;JobVertexID&gt; triggerVertices = new ArrayList&lt;&gt;(); // collect the vertices that need to acknowledge the checkpoint // currently, these are all vertices List&lt;JobVertexID&gt; ackVertices = new ArrayList&lt;&gt;(jobVertices.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67ea98a65d394ba99339c05872cfffa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49f8aabb24860a36ec783e4fbf91c40c/" rel="bookmark">
			elementUI el-input 只能输入正整数验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字母e在js中属于数字，但是正则匹配 \d 是拦不住字母e 的
正确写法为：
onKeypress="return (/[\d]/.test(String.fromCharCode(event.keyCode || event.which))) || event.which === 8" &lt;el-input type="number" placeholder="请输入" min="1" onKeypress="return (/[\d]/.test(String.fromCharCode(event.keyCode || event.which))) || event.which === 8" v-model.number="count"&gt;&lt;/el-input&gt; 其他写法： // 只允许输入数字
&lt;el-input type="number" placeholder="请输入" min="1" oninput ="value=value.replace(/[^\d]/g,'')" v-model.number="count"&gt;&lt;/el-input&gt; 同理，只允许输入数字和小数
oninput ="value=value.replace(/[^0-9.]/g,'')" 允许输入小数点后几位：
// 保留一位小数 oninput="if(isNaN(value)) { value = parseFloat(value) } if(value.indexOf('.')&gt;0){value=value.slice(0,value.indexOf('.')+2)}" // 若需要保留N位小数，则把2 改为 1 + n即可 设置范围，最大值，最小值，监听input 及 change事件
&lt;el-input min="0" max="100" type="number" @input="numberChange($event, 100)" @change="numberChange($event, 100)" onKeypress="return (/[\d]/.test(String.fromCharCode(event.keyCode || event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49f8aabb24860a36ec783e4fbf91c40c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18f363fd29189d07a51af2863bca9d7e/" rel="bookmark">
			vue中实现回到顶部功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!-- 回顶部按钮为一张50*50的图片 --&gt; &lt;!-- btnFlag 控制图片显示隐藏 --&gt; &lt;!-- backTop 回顶部的方法 --&gt; &lt;img v-if="btnFlag" class="go-top" src="图片url" @click="backTop"&gt; vue实例：
// vue的两个生命钩子，这里不多解释。 // window对象，所有浏览器都支持window对象。它表示浏览器窗口，监听滚动事件 mounted () { window.addEventListener('scroll', this.scrollToTop) }, destroyed () { window.removeEventListener('scroll', this.scrollToTop) }, methods: { // 点击图片回到顶部方法，加计时器是为了过渡顺滑 backTop () { const that = this let timer = setInterval(() =&gt; { let ispeed = Math.floor(-that.scrollTop / 5) document.documentElement.scrollTop = document.body.scrollTop = that.scrollTop + ispeed if (that.scrollTop === 0) { clearInterval(timer) } }, 16) }, // 为了计算距离顶部的高度，当高度大于60显示回顶部图标，小于60则隐藏 scrollToTop () { const that = this let scrollTop = window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18f363fd29189d07a51af2863bca9d7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8828039e7f49ce9b975f5b50893b3b7d/" rel="bookmark">
			const char *转 const wchar *函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 const char *转 const wchar *函数 const wchar_t* CharToWchar(const char* ch) { const size_t len = strlen(ch) + 1; wchar_t* wch = new wchar_t[len]; mbstowcs(wch, ch, len); return wch; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b71317d7ff9431906a0288a63fac4fac/" rel="bookmark">
			贴图、纹理、材质、着色器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		纹理：是纹路，是直接表现物体的表面的样子，在程序数据表现位图，像素矩阵的形式。
贴图：贴图是3d程序映射规则，是把纹理数据映射到3d程序模型上的规则。
材质：是渲染程序中的各种可视属性的集合，简单的说是光和3d纹理的综合表现，提供程序的渲染数据和光照算法，是程序数据集。就比如
石头纹理和光照算法，通过算法组成石头材质，实现让程序能够渲染出更加真实的屏幕图片。
纹理是图片的资源数据，是基本的资源数据，纹理通过映射规则（贴图规则，转化资源坐标数据等），成了3贴图，再加上光照效果，是的
物品具有某些质感就成了材质。
着色器：是用来实现图像渲染的，用来替代固定渲染管线的可编辑程序。
GLSL：openGl着色器语言
其他详细知识：https://www.zhihu.com/question/25745472
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d010eadbfc460db7efa31385d745356/" rel="bookmark">
			关于Android 10的手势导航条适配问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导航条不适配就太丑了 今天换了几个搜索引擎搜了一下 都没有找到合适的内容 还是去拥抱官方吧
官方文档 手势导航全屏应用内容设置透明系统栏设置界面可见度标记手动占用边衬区 处理存在冲突的应用手势与“返回”手势冲突与“主屏幕”/“快速切换”手势存在冲突游戏和其他非视图型应用 其他资源博文视频 手势导航 从 Android 10 (API 级别 29) 开始，Android 系统支持完全基于手势的导航。为确保应用与此功能兼容，应用开发者应完成以下两项任务：
将应用内容扩展到屏幕边缘。处理存在冲突的应用手势。 全屏应用内容 为了充分利用浮动导航栏提供的额外屏幕空间，您需要对应用做一些更改。
设置透明系统栏 您可以通过在主题背景中设置以下值来完成这一操作：
&lt;!-- values-29/themes.xml: --&gt; &lt;style name="AppTheme" parent="..."&gt; &lt;item name="android:navigationBarColor"&gt;@android:color/transparent&lt;/item&gt; &lt;!-- Optional, but recommended for full edge-to-edge rendering --&gt; &lt;item name="android:statusBarColor"&gt;@android:color/transparent&lt;/item&gt; &lt;/style&gt; 或者，您也可以通过使用 Window.setNavigationBarColor() 和 Window.setStatusBarColor() 来动态完成这一设置。
当设备设置为使用手势导航，并且应用导航栏采用透明背景时，系统会根据其后面内容的颜色自动更新句柄颜色。不过，当用户处于 2 个按钮或 3 个按钮的导航模式时，这些按钮不会更改颜色。系统会改用半透明背景，让这些按钮保持可见状态。不过，仅当应用适配 API 级别 29 或更高版本时，系统才能执行此操作。
设置界面可见度标记 为了能够将视图应用到全屏，您的应用必须告知系统其可以处理此类视图。为此，您可以使用 View.setSystemUiVisibility() 来设置以下标记：
SYSTEM_UI_FLAG_LAYOUT_STABLESYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION Kotlin:
view.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION or View.SYSTEM_UI_FLAG_LAYOUT_STABLE) Java:
view.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_STABLE); 这些标记一起告知系统应以全屏模式展示应用，如同不存在导航栏和状态栏一样。对于其他全屏事件，您还可以设置 SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN，以便将状态栏移到后侧。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d010eadbfc460db7efa31385d745356/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ceaad2eac5e9d9ca9d49a6428015a0/" rel="bookmark">
			如何在腾讯云快速注册域名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		建立网站需要域名和服务器，拥有域名是第一步，需要完成注册域名的过程，才能让用户访问网站。
本文讲解如何快速进行域名注册。
查询并注册域名。在域名页面查询想要注册的域名或者后缀是否已经被他人注册。
注册的多就点击批量注册。
若返回的查询结果显示【已被注册】，说明该域名已被他人注册，请更换域名或者后缀。找到合适的就赶紧注册，尽量选择com域名，会比较好一些。
填写域名信息
确认域名的时长，填写域名信息
域名信息中，时长默认显示：1年、2年、3年、5年和10年。
有三种方式填写域名所有者信息。
如果之前买过域名，选择使用之前填写的域名信息。
需要使用新的域名信息，选择【使用新的域名信息】，填写新域名信息，保存】
提交
核对域名信息、时长
最后国内域名商处都要实名认证。
更多参阅域名注册快速入门
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5776878184e8d497638705580e9dee1/" rel="bookmark">
			算法基础-十大排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法基础-十大排序算法 排序就是将一组对象按照某种逻辑顺序重新排列的过程。
一、冒泡排序 从数组头开始，比较相邻的元素。如果第一个比第二个大，就交换。
/**冒泡排序（升序）*/ public static int[] sort(int[] array) { if (array.length == 0) { return array; } //循环数组长度的次数 for (int i = 0; i &lt; array.length; i++) { /*从第0个元素开始，依次和后面的元素进行比较 j &lt; array.length - 1 - i表示第[array.length - 1 - i] 个元素已经冒泡到了合适的位置，无需进行比较，可以减少比较次数*/ for (int j = 0; j &lt; array.length - 1 - i; j++) { //如果第j个元素 大于 第j+1个元素，则交换位置 if (array[j] &gt; array[j + 1]) { int temp = array[j + 1]; array[j + 1] = array[j]; array[j] = temp; } } } return array; } 二、简单选择排序 从待排序的元素中选出最小(大)元素与第1个元素交换，执行n-1趟后就完成了排序。这种方法叫做选择排序，因为不断地选择剩余元素中最小(大)元素。是冒泡排序的一种优化，减少了交换次数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5776878184e8d497638705580e9dee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8193ae022fc42bb28b6aca3c2a6f2065/" rel="bookmark">
			ubuntu16中安装MySQL5.7.29
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、解压tar
tar -xvf mysql-server_5.7.29-1ubuntu16.04_amd64.deb-bundle.tar -C mysql
二、安装第一个包（安装顺序不可更改）
dpkg -i mysql-common_5.7.29-1ubuntu16.04_amd64.deb 三、安装第二个包
1.首先安装libaio1_0.3.109-4_amd64.deb
dpkg -i libaio1_0.3.109-4_amd64.deb 2.安装mysql-community-client_5.7.29-1ubuntu16.04_amd64.deb
dpkg -i mysql-community-client_5.7.29-1ubuntu16.04_amd64.deb
四、安装第三个包
dpkg -i mysql-community-client_5.7.29-1ubuntu16.04_amd64.deb
五、安装第四个包
1.首先安装libmecab2_0.996-1.3_amd64.deb
dpkg -i libmecab2_0.996-1.3_amd64.deb
2.安装
dpkg -i mysql-community-server_5.7.29-1ubuntu16.04_amd64.deb
六、修改配置文件
vi /etc/mysql/mysql.conf.d/mysqld.cnf
注释掉127.0.0.1
七、修改root权限
update use set host='%' where user='root';
flush privileges;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c22726e999be601dda2c420762121614/" rel="bookmark">
			解决AD原理图中无法输入中文的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不知道碰到哪了，只能输入字母和数字，不能输入中文了，难受。。。
1.
2.
3.
然后一直确定就OK，最后重启一哈
哈哈，恢复默认值了，真香。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97486e15909b51bb08827e08c8cc3f35/" rel="bookmark">
			C&#43;&#43;：std::greater()、std::less()、自定义比较函数的规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、结论1.排序和建堆的效果2.解释结论 二、解析1.比较规则：strict weak ordering2.less和greater其实是什么3.bool返回值和比较操作符（1）规则（2）并不是想当然的位置交换（3）&lt;和&lt;=代价证明 三、自定义1.数组2.优先级队列 Reference 一、结论 1.排序和建堆的效果 排序：
less&lt;T&gt;变成升序（从左到右遍历下标时，数组元素是从小到大）
greater&lt;T&gt;变成降序（从左到右遍历下标时，数组元素是从大到小）建堆：
less&lt;T&gt;变成大顶堆（从上层到下层，堆元素是从大到小，同层之间随便）
greater&lt;T&gt;变成小顶堆（从上层到下层，堆元素是从小到大，同层之间随便） 可以看到排序和建队时，less和greater并不是直接对应汉语意思，不能统一。其实是真正的意思是两个要比较的元素，第一个元素是否比第二个元素更小less还是更大greater。
2.解释结论 排序
上面的例子应该就看懂了吧。less就是让前一个比后一个更小；greater就是让前一个比后一个更大。谁会是a，谁会是b，是按照排序算法的。
建堆
顶堆插入一个新元素时，就是插入到最后一个叶子。
然后这时候整理堆内元素让堆重新满足大小顶堆。关键让新插入的结点和它的父结点进行比较，comp(新插入，它的父结点)。
大顶堆就是让父比子大，即符合less让新插入的比父结点更小；
小顶堆就是父比子小，即符合greater让新插入的比父结点更大。
二、解析 1.比较规则：strict weak ordering std::greater()、std::less()、自定义比较函数，这些都其实是用作比较的，要遵从c++制定的比较规则。
需要满足三种特性要求，否则使用中会报错：
反自反性：falsetrue的互斥性：true则false（但不要求false则怎么样）传递性：true＋true则true 2.less和greater其实是什么 比如less
template &lt;class T&gt; struct less { bool operator() (const T&amp; x, const T&amp; y) const {return x&lt;y;} typedef T first_argument_type; typedef T second_argument_type; typedef bool result_type; }; 可以看到关键就是bool operator()和return x&lt;y;
bool operator()：要的就是这个返回值bool，决定比较是否要交换。这个结果用在排序和建堆中就表示是否要交换。return x&lt;y;：可以看到其实就是使用&lt;之类的操作符重载，这就是怎么排序的规则。
PS：但这产生了限制，基本的元素int之类的，自然可以直接比较；但复杂类型如自定义一个类，里面有多个数据，我们就还得定义重载操作符比较，要不然编译器不知道该比较什么。 3.bool返回值和比较操作符 （1）规则 bool comp(a, b)意思是：返回的值指示作为第一个参数传递的元素是否被视为在其定义的特定严格弱排序中位于第二个参数之前。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97486e15909b51bb08827e08c8cc3f35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ade6122f2907c819b889875cf11e55d/" rel="bookmark">
			如何利用Python制作新型冠状病毒省份(直辖市)实时疫情图？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何利用Python制作新型冠状病毒省份(直辖市)实时疫情图？
一.数据采集
先找到数据，对数据进行数据采集
数据来源：新浪疫情实时监测
URL: https://news.sina.cn/zt_d/yiqing0121
数据采集：
1.访问https://news.sina.cn/zt_d/yiqing0121
2.打开Chrome开发者工具，点开network，刷新页面，点击各个请求，找到获取取json的请求。
例如：附图
https://interface.sina.cn/news/wap/fymap2020_data.d.json?1581410367084&amp;&amp;callback=sinajp_15814103671094932140955446096
返回的数据类型：
Headers:
Genneral
Request URL: https://interface.sina.cn/news/wap/fymap2020_data.d.json?1581410367084&amp;&amp;callback=sinajp_15814103671094932140955446096
Request Method: GET
Status Code: 200 Remote Address: 39.156.6.163:443
Referrer Policy: unsafe-url
Response Headers
content-type: text/html
返回的数据显示：
City中，cureNum是治愈数，deathNum是死亡人数。value是确诊数
数据处理：
用到以下几个模块
1.requests模块 （用于网页访问）
2.re模块 （用于正则表达式，处理数据时需要）
3.json模块，读取数据
4.图表地图模块：pyecharts
数据包：echarts-china-provinces-pypkg
数据包：echarts-china-cities-pypkg
(用pip安装requests,pyecharts以及两个数据包)，例如：pip install pyecharts
三.数据处理代码：
说明：响应返回数据包含在一个js变量中，需要用正则处理下，然后用python自带的json.loads方法转为dict。
import requests
import re
import json
from pyecharts.charts import Map,Geo
from pyecharts import options as opts
import time
result =requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ade6122f2907c819b889875cf11e55d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/688115729cfb2aa56d213a97687c1a66/" rel="bookmark">
			PHP对二维数组里面的多字段进行排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		##PHP对二维数组里面的多字段进行排序
&lt;?php $data = [ ["sort" =&gt; "99", 'site_sort' =&gt; "9"], ["sort" =&gt; "99", 'site_sort' =&gt; "20"], ["sort" =&gt; "9", 'site_sort' =&gt; "80"], ["sort" =&gt; "99", 'site_sort' =&gt; "80"], ["sort" =&gt; "99", 'site_sort' =&gt; "86"], ["sort" =&gt; "99", 'site_sort' =&gt; "130"], ]; // $dataLen = count($data); // for ($i=0; $i &lt; $dataLen; $i++) { // for ($j=$i + 1; $j &lt; $dataLen; $j++) { // if ($data[$i]["sort"] &gt; $data[$j]["sort"]) { // $tmp = $data[$i]; // $data[$i] = $data[$j]; // $data[$j] = $tmp; // }else if (($data[$i]["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/688115729cfb2aa56d213a97687c1a66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9099fda8f2997e5e1aaebfa156f9249a/" rel="bookmark">
			ArcMap打开特别慢的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 本机Desktop客户端连接本机的浮动许可管理器(单机版应该也是一样的)，但无论是打开ArcGIS Administrator查看可用性还是打开ArcMap都一直在检查许可状态的界面，等好久都是这个界面，导致体验很差。
原因： 经查找发现是杀毒软件导致的，如果您的机子也遇到了打开ArcMap巨慢而且必须开启杀毒软件的话，那么请看下面解决方法。
解决方法： 将下列目录及其子目录添加到杀毒软件的白名单中，也就是不让杀毒软件扫描下面文件夹：
C:\Program Files (x86)\ArcGIS
C:\Program Files (x86)\Common Files\ArcGIS
C:\Program Files (x86)\ESRI
C:\Program Files (x86)\ArcGIS\Desktop10.8
C:\ProgramData\FLEXnet
C:\Python27
亲测有效，如果安装目录不是默认位置的话，对应修改一下即可，官方链接。
此外，还有一种浮动许可连接可能导致ArcMap打开慢的原因：
问题描述： 本机Desktop客户端连接的许可服务器，并且已经将许可借出到本地了，但是打开ArcMap的速度和之前没有借出时差不多，而且该机器如果在许可服务器的局域网外使用，打开ArcMap则会更慢
原因： 虽然已经将许可借出到本地了，但是客户端ArcGIS Administrator里的license manager那里依然填写的是许可服务器的地址，如下图：
所以这时ArcMap会优先去该地址下找许可，找不到才会使用该机器已经借出的许可。
解决方法： 将ArcGIS Administrator的license manager那里设置为空：
然后应用，再次打开ArcMap就会快很多了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd0f648f2d014a3afd5fa80880e38558/" rel="bookmark">
			解决AD中PCB芯片引脚之间间距太小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计——&gt;规则：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/332bcc6026a0eec2e40f60a9c32bb5ed/" rel="bookmark">
			【VBA(一)：For循环】【Excel中宏的使用&#43;手工书写VBA代码&#43;使用For循环&#43;小结及练习】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Excel中宏的使用录制宏优缺点 录制相对引用的宏案例 手工书写VBA代码新建模块 使用For循环案例 小结及练习定义宏VBA（ALT+F11）相关概念 定位制作工资条设置按钮宏设置工资条案例 Excel中宏的使用 ALT+F8
录制宏 原数据（有六张表）
先创建一个宏，取名为宏1
创建好宏，开始录制宏，在一月份的表进行操作，每一次对单元格的操作都会被录制，所以要谨慎。
在一月表中进行删除CDE列，将金额列放在日期列后面，筛选数量大于200的数据。
效果图（一月）
操作完成后，点击停止录制。
切换到二月表，点击宏，执行宏1。
效果图（二月）
优缺点 优点：可以进行重复的操作
缺点：表结构不同，效果不同
录制相对引用的宏 使用相对引用即可
参考所选单元格的偏移进行改变
案例 原数据
目标：从A1下两个单元格改颜色
选中A1-录制宏-点击相对引用-选中A3改变填充色-停止录制-选中A1-宏-执行宏
效果图（执行了三次宏）
手工书写VBA代码 Visual Basic可以查看代码
查看上一个改颜色的代码
新建模块 模块相当于一个宏，此处新建了一个改颜色的模块，效果跟上一个宏一样。
更改宏名可以直接在代码中更改，信息会自动同步到Excel中。
选中工程管理器里面的模块-右键-插入-模块
使用For循环 案例 将改颜色操作进行10次
效果图（在B1进行操作）
小结及练习 定义 宏 一组动作的集合
VBA（ALT+F11） 做宏的工具，VBA是代码
相关概念 Sub ABC() … End Sub
Dim i
For i = 1 to 10 … Next
定位 永远定位第一行
录制宏-选中第一行-停止录制
代码
可以把代码放在For之前，就不用去选中第一行再执行循环
制作工资条 原数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/332bcc6026a0eec2e40f60a9c32bb5ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8b1f3c548c4555fad62bf9234cc1630/" rel="bookmark">
			【海思篇】【Hi3516DV300】六、音频输入篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的：使海思板的麦克风和扬声器工作起来；让更多的爱好者了解海思、加入海思。
目录
1 准备工作
1）音频能力
2）检测板子
3）sample下audio编译
2 麦克风调试
1）配置acap音频参数
2）启动ai（关闭重采样及不使用VQE）
3）配置Audio Codec
4）取音频流
3 总结
1 准备工作 1）音频能力 集成 Audio codec，支持 16bit 语音输入和输出支持单声道 mic 差分输入，降低底噪支持单端双声道输入支持 I 2 S 接口，支持对接外部 Audio codec 2）检测板子 我的板子就是MIC同时接了AC_INL和AC_INR，最后录音数据都是0数据。最后AC_INR接地就ok了。
3）sample下audio编译 声音调试是基于样例sample下audio（依赖common文件夹）
Hi3516CV500_SDK_V2.0.1.1/smp/a7_linux/mpp/sample
make ARCH=arm CROSS_COMPILE=arm-himix200-linux-
2 麦克风调试 1）配置acap音频参数 AIO_ATTR_S stAioAttr; stAioAttr.enSamplerate = AUDIO_SAMPLE_RATE_48000; stAioAttr.enBitwidth = AUDIO_BIT_WIDTH_16; stAioAttr.enWorkmode = AIO_MODE_I2S_MASTER; stAioAttr.enSoundmode = AUDIO_SOUND_MODE_MONO; stAioAttr.u32EXFlag = 0; stAioAttr.u32FrmNum = 30; stAioAttr.u32PtNumPerFrm = AACLC_SAMPLES_PER_FRAME; stAioAttr.u32ChnCnt = 1; stAioAttr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8b1f3c548c4555fad62bf9234cc1630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2886f48240e108ca6047c975d217fb0/" rel="bookmark">
			野火《LwIP 应用开发实战指南》小白学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 近日开始阅读野火《LwIP 应用开发实战指南》，遇到不懂的地方写下笔记，与同好分享。本人水平有限，如有不对，请留言指正。 第一个问题： 对动态内存池的枚举宏定义的理解 野火的解释如图： 我用例程来理解上述野火的解释：（编译环境ubuntu18.04） #include &lt;stdio.h&gt; enum spectrum { red, //0 orange, //1 yellow, //2 green, //3 blue, //4 violet //5 }; typedef enum{ //为演示方便，去掉了size参数 #define LWIP_MEMPOOL(name,num,desc) MEMP_##name, LWIP_MEMPOOL(RAW_PCB,MEMP_NUM_RAW_PCB,"RAW_PCB")//0 LWIP_MEMPOOL(UDP_PCB,MEMP_NUM_UDP_PCB,"UDP_PCB")//1 LWIP_MEMPOOL(TCP_PCB,MEMP_NUM_TCP_PCB,"TCP_PCB")//2 //LWIP_MEMPOOL(MY_PCB,MEMP_NUM_MY_PCB,"MY_PCB") MEMP_MAX	}memp_t; void main() { printf("color.blue=%d\n",blue); printf("MEMP_MAX=%d\n",MEMP_MAX); } 运行结果： memp_tm枚举体中的MEMP_MAX值的大小根据LWIP_MEMPOOL语句多少自动增加，如果你把LWIP_MEMPOOL(MY_PCB,MEMP_NUM_MY_PCB,"MY_PCB")前的注释取消，那么MEMP_MAX=4 为演示方便，去掉了size参数。 #define LWIP_MEMPOOL(name,num,desc)中只有name参数在本例的枚举中有用，仅为演示使用，其它参数在LWIP中还是有用的。 本文涉及的知识点有：c枚举类型 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/895d06dc88c43bbc47e5ad1b8311bef4/" rel="bookmark">
			（五）python内置函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		强制转换 (7个)
dict()set()list()int()str()bool()tuple() 输入输出（2个）
input（）print（） 数学相关（）
abs() 绝对值float（）浮点型min() 最小值max() 最大值sum() 加和divmod() 两数相除，得商和余数round() 保留几位小数（默认有四舍五入） #max min lst = [1,2,3,4,5,67] a1 = max(lst) a2 = min(lst) print(a1,a2) # sum print(sum(lst)) # divmod res = divmod(101 , 10) print(res) #商，余数 res3 = pow(2,3) #幂次运算 print(res3) res2 = round(1.1234,3) #保留小数 print(res2) 进制转换
bin() 将十进制转换成二进制oct() 将十进制转换成八进制int() 将其他类型转换成十进制hex() 将十进制转换成十六进制 num = 16 print(bin(num)) #0b10000 print(oct(num)) #0o20 print(hex(num))	#0x10 v1 = '0b10000' print(int(v1 ,base=2)) #16 v2 = '0o20' print(int(v2 ,base=8))	#16 v3 = '0x10' print(int(v3 ,base=16))	#16 其他
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/895d06dc88c43bbc47e5ad1b8311bef4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b30ef2a52735c8394e7c6b07a6ba9281/" rel="bookmark">
			钉钉小程序测试环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		钉钉开发者平台:https://open-dev.dingtalk.com/#/corpeapp 提供了4种不同形式得小程序开发：企业内部开发、第三方企业应用、第三方个人应用、移动接入应用。其中移动接入应用这种方式我感觉用不到，所有就没看它了。另外三种 企业内部开发 跟三方个人应用差别不大，第三方企业应用需要收费，钉钉赚钱得一种方式吧。
因为我后面做的东西又可能需要上架，所以就先选择了企业内部开发 方式做为探路者了。
快速开发官方入口：https://ding-doc.dingtalk.com/doc#/bgb96b/gt5d6a 照着官方得快速入门很快就可以搭建一个本地得demo
我在搭建过程中前端很顺利，后端遭遇到了几个坑。一是Maven版本得问题，在执行mvn clean 等命令得时候会报错，发现是我原先pc上按照得maven版本太低了，然后从官网下载了一个最新得maven版本后就可以正常编译了。maven下载官网：https://maven.apache.org/download.cgi
官方下载得demo是个快餐 没有前端跟服务的得数据curd，这里我集成了oracle数据库，相关配置
pom.xml
&lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc14&lt;/artifactId&gt; &lt;version&gt;10.2.0.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; application.properties
#服务启动端口号。钉钉云ECS目前只开放80和22端口 server.port=8089 spring.datasource.driver-class-name= oracle.jdbc.driver.OracleDriver spring.datasource.url= jdbc:oracle:thin:@114.67.108.250:1521:ORCL spring.datasource.username= bosyundev spring.datasource.password= bosyun2019 # 下面为连接池的补充设置，应用到上面所有数据源中 # 初始化大小，最小，最大 spring.datasource.initialSize= 1 spring.datasource.minIdle= 3 spring.datasource.maxActive= 216 # 配置获取连接等待超时的时间 spring.datasource.maxWait= 30000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 spring.datasource.timeBetweenEvictionRunsMillis= 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 spring.datasource.minEvictableIdleTimeMillis= 30000 spring.datasource.validationQuery= select 1 from dual spring.datasource.testWhileIdle= true spring.datasource.testOnBorrow= false spring.datasource.testOnReturn= false 完了启动得时候报错了，error:Consider revisiting the conditions above or defining a bean of type 'javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b30ef2a52735c8394e7c6b07a6ba9281/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/659fc32c3a6842be202af27a0416f98e/" rel="bookmark">
			为什么要用神经网络？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要用神经网络？ 1. 对于同一个分类任务，我们可以用机器学习的算法来做，为什么要用神经网络呢？
一个分类任务，我们用机器学习算法来做时，需要把数据“喂”到算法里去训练，最后保存模型，再来预测分类的准确性。但是这就有个问题，即我们需要实现确定好特征，每一个特征即为一个维度，特征数目过少，我们可能无法精确的分类出来，即我们所说的欠拟合，如果特征数目过多，可能会导致我们在分类过程中过于注重某个特征导致分类错误，即过拟合。
这就会造成我们在特征工程上花费大量的时间和精力，才能使模型训练得到一个好的效果。然而神经网络不需要做大量的特征工程，比如提前设计好特征的内容或者说特征的数量等，我们可以直接把数据“喂”进去，让它自己训练，自我“修正”，即可得到一个较好的效果。
https://blog.csdn.net/qq826364410/article/details/78509783
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38fb8ce32e261835215935aac709e5e5/" rel="bookmark">
			Java从入门到精通第八章（包装类）学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		包装类
java.lang包中的Integer类、Long类和Short类可以将基本类型int、long和short类封装成一个类。由于这些类包含的方法基本相同，所以以Integer类为例来介绍。
Integer类有两种构造方法，可通过构造方法来获取Integer对象
可通过Integer.MAX_VALUE来获取int类型可取的最大值
可通过Integer.MIN_VALUE来获取int类型可取的最小值
可通过Integer.SIZE来获取以二进制补码形式表示int值的位数
可通过Integer.TYPE来获取int的类型
Boolean：
两种构造方法，可通过构造方法来获取Boolean对象
用字符串形式的参数的构造函数获取Boolean对象时，只要不是“true”，默认为false。
可通过Boolean.TRUE来获取Boolean对象的对应基值true
可通过Boolean.FALSE来获取Boolean对象的对应基值false
可通过Boolean.TYPE来获取Boolean对象的基本类型boolean
Byte：
可通过两种构造方法获取Byte对象（不常用）
推荐使用valueOf（String str）方法获取Byte对象
Byte by = 15；也可以，编译器会自动装箱，将by化为Byte对象
可通过Byte.MAX_VALUE来获取bytet类型可取的最大值
可通过Byte.MIN_VALUE来获取byte类型可取的最小值
可通过Byte.SIZE来获取以二进制补码形式表示byte值的位数
可通过Byte.TYPE来获取byte的类型
Character：
可通过两种构造方法获取
Character.CONNECTOR_PUNCTUATION：返回byte型值，表示Unicode规范中的常规类别**“PC”**；
Character.UNASSIGNED：返回byte型值，表示Unicode规范中的常规类别“Cn”；
Character.TITLECASE_LETTER：返回byte型值，表示Unicode规范中的常规类别“Lt”；
Double：
Double类和Float类的方法基本相同，以Double为例
两种构造方法获取Double对象
Double.MAX_EXPONENT:返回int值，表示有限double变量可能具有的最大指数
Double.MIN_EXPONENT:返回int值，表示有限double变量可能具有的最小指数
Double.NEGATIVE_INFINNTY:返回double值，表示保存double类型的负无穷大值的常量
Double.POSITIVE_INFINNTY:返回double值，表示保存double类型的正无穷大值的常量
Number：
抽象类Number是BigDecimal、BigInteger、Byte、Double、Float、Integer、Long和Short类的父类，Number的子类必须提供将表示二点数值转换为byte、double、float、int、long和short的方法，例如，doubleValue（）方法返回双精度值。
在Number类的所有子类中都包含以上这几种方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd81efc760a8c916997efc35d5f2bada/" rel="bookmark">
			智能驾驶数据后处理分析—INTEWORK-VDA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着智能驾驶技术在新车上逐步普及，车辆研发阶段需要做大量的实车测试工作，当前的测试方式主要是路采实车数据后，按标准和法规进行测试场景提取和测试数据分析。调查显示绝大部分智能驾驶研发厂商以传统的手动分析或借助非专业工具进行半自动处理数据为主，测试分析工作效率很低。
由于路试并非按照预定工况进行顺序驾驶，各种场景往往是在采集过程中无规律地出现，因此给数据筛选和分析工作带来了许多困难。数据分析的步骤一般是通过回放数据进行特定场景的提取，之后再进行数据评价，而往往数据提取和分析所耗的时间与实车采集时间相当，甚至更多。
为解决上述问题，经纬恒润基于并行和科学计算平台自主开发了数据分析的利器INTEWORK-VDA工具，通过此工具可以实现实车录制数据中测试场景的快速筛选和科学评价。VDA包含如下主要功能模块：
使用VDA工具可大幅提高采集数据的分析效率，快速自动生成分析结果和报告。如下为基于传统方式和使用VDA软件进行ACC跟停和起步数据分析的耗时对比（实车3小时采集的数据，其中报文文件1G、视频文件4.5G）：
VDA典型功能
• 场景快速筛选
基于VDA可实现场景的快速筛选和可视化分析，如下为输入LDW压线报警筛选的条件，软件可将符合条件的数据以数据段的形式列出，用户可查看符合LDW报警场景的数据，支持总线信号和视频数据的同步回放。
• 关键评价指标自动提取
支持上百项智能驾驶场地法规测试和开放道路测试关键指标自动提取、数据统计和测试报告自动生成。
• 数据可视化
VDA的曲线分析模块提供了多种曲线查看功能，可进行信号的标注、放大、缩小并可显示常规的统计结果如：标准差和平均值等。
• 测试用例编辑
VDA支持典型测试场景的测试用例和测试结果评价准则的录入，并且用例可做为积累直接在后续测试中复用。
• 用例执行及报告生成
编辑好的用例可结合实车采集的数据进行执行和分析，软件按照筛选条件和评价准则自动生成分析结果，并且可支持生成pdf、html、excel格式测试报告的自动生成和导出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05875f513cc93995f24062622555329d/" rel="bookmark">
			汇编语言标志位：SF、CF、PF、AF、DF、ZF、TF、IF、OF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汇编语言标志位：SF、CF、PF、AF、DF、ZF、TF、IF、OF CF:进位标志位。在无符号运算时，记录了运算结果的最高有效位向更高位的进位值或从更高位借位，产生进位或借位时CF=1，否则CF=0；## 标题
PF:奇偶标志位。相关指令执行后结果所有bit中1的个数为偶数，那么PF=1，1的个数为奇数则PF=0；
AF:辅助进位标志位。运算过程中看最后四位，不论长度为多少。最后四位向前有进位或者借位，AF=1,否则AF=0;
ZF:零标志位。相关指令执行后结果为0那么ZF=1,结果不为0则ZF=0；
SF:符号标志位。相关指令执行后结果为负那么SF=1，结果非负数则SF=0；
TF:调试标志位。当TF=1时，处理器每次只执行一条指令，即单步执行;
IF:中断允许标志位。它用来控制8086是否允许接收外部中断请求。若IF=1，8086能响应外部中断，反之则屏蔽外部中断;
DF:方向标志位。在串处理指令中，每次操作后，如果DF=0，si、di递增，如果DF=1，si、di递减；注意此处DF的值是由程序员进行设定的 cld命令是将DF设置为0，std命令是将DF设置为1；
OF:溢出标志位。记录了有符号运算的结果是否发生了溢出，如果发生溢出OF=1,如果没有OF=0；
————————————————
版权声明：本文为CSDN博主「yeanhoo」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_41890599/article/details/99866410
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c8e17757de8cfd08c41f68105510578/" rel="bookmark">
			CIC滤波器和SINC滤波器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、CIC提出于1981年，那正是《读者》杂志创刊的日子。它可以方便地实现抽取和内插；通过调节积分器和comb的个数可以调节其频率响应。其一般频响如图1：
图1
类似于一个SINC函数，因此也被称为SINC滤波器。针对图1中通带不平的问题，可以设计额外的补偿滤波器。值得一提的是，sinc函数和矩形函数在频域和时域是互相对应的，也就是说，时域的sinc函数:sin(x)/x，在频率对应于brick wall filter；反之亦然。
2、在具体的实现上，CIC(SINC）的实现形式一般如图2：
图2 其中comb的实现形式如图3，是一个带延迟的差分器：
图3 假如R=1（不抽取降速），这个形式的时域推导出的z传递函数为[(1-z^-M)/(1-z^-1)]^N，其中N是积分器&amp;comb的个数。神奇的是，这个IIR的形式最终被简化成了一个FIR如图4，图中R代表抽取率。因此CIC是FIR滤波器，在matlab中用freqz函数对图4的频响进行分析，即可得到图1所示的结果。
图4 显然图4的表达形式可用另一种形式来实现：N个累加器串联，每个累加器为Σ{0~(M-1)}。但是这样硬件效率不如图2.
3、在TI/ADI的过采样ADC产品中，对于图4，如果N=1即称为SINC1，N=3即为SINC3，N=5即为SINC5；而且，常常是多个滤波器搭配使用（如SINC5+SINC1)，这样实现更好的滤波效果，还可以通过精心的频点设计来定点滤除工频干扰。
4、图1中通带衰减很快，为了解决这个问题，可以设计额外的滤波器来补偿，效果如图5.详细内容，请参考文献2. 图5 参考文献：
1、https://en.wikipedia.org/wiki/Cascaded_integrator%E2%80%93comb_filter
2、https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/an/an455.pdf
3、http://home.mit.bme.hu/~kollar/papers/cic.pdf
4、https://ieeexplore.ieee.org/document/4401816 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9731d3fef6717ae5781709699bbf3e8f/" rel="bookmark">
			《王道操作系统》学习笔记总目录&#43;思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章是对《2021王道操作系统》所有知识点的笔记总结归档，虽说是2021年的，但是这些都是最核心的底层基础知识，过多少年都不会有很大的变化，核心都差不多。
我的武功秘籍：note.bithachi.cn，希望可以一起交流学习。
学习视频：王道操作系统
其它学习时总结的目录笔记，有思维导图和案例。见下图
看到很多小伙伴需要课件，这里直接附上网盘链接：
链接：https://pan.baidu.com/s/17ClnaWO2wkzBX_eX7sB66g
提取码：8q81
复制这段内容后打开百度网盘手机App，操作更方便哦
第 1 章 计算机系统概述 1.1 操作系统的基本概念 1.1.1 操作系统的概念、功能和目标（系统资源的管理者、提供接口、作为扩充机器、虚拟机）
1.1.2 操作系统的特征（并发、共享、虚拟、异步）
1.2 操作系统的发展和分类 1.2.1 操作系统的发展和分类（手工、单道/多道批处理、分时、实时、网络、分布式、嵌入式、个人计算机）
1.3 操作系统的运行机制和体系结构 1.3.1 操作系统的运行机制和体系结构（大内核、小内核）
1.3.2 中断和异常（内中断和外中断、中断处理过程）
1.3.3 系统调用（执行过程、访管指令、库函数与系统调用）
1.0.0 第一章操作系统概述错题整理
第 2 章 进程管理 2.1 进程与线程 2.1.1 进程的定义、特征、组成、组织
2.1.2 进程的状态（运行、就绪、阻塞、创建、终止）及转换（就绪-&gt;运行、运行-&gt;就绪、运行-&gt;阻塞、阻塞-&gt;就绪）
2.1.3 原语实现对进程的控制
2.1.4 进程之间的通信（共享通信、消息传递、管道通信）
2.1.5 线程概念与多线程模型
2.2 处理机的调度 2.2.1 处理机调度的概念及层次
2.2.2 进程调度的时机（主动放弃与被动放弃）、切换与过程（广义与狭义）、方式（非剥夺与剥夺）
2.2.3 度算法的评价指标（cpu利用率、系统吞吐量、周转时间、等待时间、响应时间）
2.2.4 作业/进程调度算法（FCFS先来先服务、SJF短作业优先、HRRN高响应比优先）
2.2.5 作业/进程调度算法（时间片轮转调度算法、优先级调度算法、多级反馈队列调度算法）
2.3 进程的同步与互斥 2.3.1 进程的同步与互斥
2.3.2 实现临界区进程互斥的软件实现方法
2.3.3 实现临界区进程互斥的硬件实现方法
2.3.4 信号量机制（整型信号量、记录型信号量P、V）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9731d3fef6717ae5781709699bbf3e8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c068b10668ab8f23e574223ca4d31df7/" rel="bookmark">
			【蓝桥杯嵌入式】【STM32】4_TIM之定时器及其中断、PWM初探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、定时器中断2、定时器输出PWM3、定时器复用功能重印象表 下载工程文件：
https://gitee.com/Joseph_Cooper/blue-bridge-embedded
1、定时器中断 定时器的分类：
定时器的三种计数模式：
向上计数模式：计数器从0计数到自动加载值（TIMx_ARR），然后重新从0开始计数并且产生一个计数器溢出事件。
向下计数模式：计数器从自动装入的值（TIMx_ARR）开始向下计数到0，然后从自动装入的值重新开始，并产生一个计数器向下溢出事件。
中央对齐模式（向上/向下计数）：计数器从0开始计数到自动装入的值-1，产生一个计数器溢出事件，然后向下计数到1并且产生一个计数器溢出事件；然后再从0开始重新计数。
通用定时器框图：
定时器和总线对应关系：
实验：在LCD屏幕上每秒滚动显示字符。
配置步骤：
（1）、TIM3 时钟使能。
（2）、初始化定时器参数,设置自动重装值，分频系数，计数方式等
（3）、设置 TIM3_DIER 允许更新中断。
（4）、TIM3 中断优先级设置。
（5）、允许 TIM3 工作，也就是使能 TIM3。
（6）、编写中断服务函数。
TIM.c:
#include "Headfile.h" u8 TimCount = 0; //Tout = (ARR+1)(PSC+1)/Tclk 时间计算公式 void Timer3InteruptInit(u16 arr, u16 psc){ TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; NVIC_InitTypeDef NVIC_InitStructure; //（1）、TIM3 时钟使能。 RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);//使能TIM3时钟 //（2）、初始化定时器参数,设置自动重装值，分频系数，计数方式等 TIM_TimeBaseInitStructure.TIM_Period = arr;//自动重装值 TIM_TimeBaseInitStructure.TIM_Prescaler = psc;//分频系数 TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;//计数方式 TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;//设置时钟分割 TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure); //（3）、设置 TIM3_DIER 允许更新中断。 TIM_ITConfig(TIM3,TIM_IT_Update,ENABLE); //（4）、TIM3 中断优先级设置。 NVIC_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c068b10668ab8f23e574223ca4d31df7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e6b2f925608a73ced637db033144dfd/" rel="bookmark">
			OpenChannelSSD之六_从OpenChannelSSD到ZNS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenChannelSSD之六_从OpenChannelSSD到ZNS 背景Chunk 和 PU关于Zoned Namespaces (ZNS) 背景 关于在GitHub上的Open Channel SSD 的开源项目好久没人更新过，在qemu搭建的平台上改进过，经常会出现bug, 对内核版本，qemu版本，系统版本要求相当高了。
虽然有很多论文已经发表出来了，但是讲真的觉得很多都是理论假设，并不能真的得到相应的实验结果，因此在学相关方面内容一定要看顶会论文，毕竟阿里的内部技术并不是公开的。
如今企业级要实现云存储效率需要单个SSD满足许多不同的工作负载，而工作负载现在可以说是无处不在。在应用共享SSD的时候，负载之间干扰造成延时忽高忽低，最坏时延迟巨幅升高。 保证为每一个硬盘用户提供稳定的服务质量，才能体现出云环境的服务质量。
传统SSD把内部的FTL交给主机处理是Open-Channel SSD的主要功能，让用户自制属于自己的SSD。
Chunk 和 PU Open-Channel SSD提出了chunk和PU的概念。
Chunks特点：
在LBA范围内顺序写入;需要重置才能重写;借鉴HDD的SMR规范（ZAC / ZBC）;针对SSD物理限制进行了优化:使写入与介质对齐
Parallel Units特点：
Host可以对单独的工作负载进行direct I/O;单个或者多个die实现条带化;并行单元继承了底层介质的吞吐量和延迟特性;与NVMe中的I / O确定性相似的概念; 不难看出，Open-Channel SSD实现了I/O分离，可预测性延迟的特点，FTL功能移至Host端负责数据管理以及I/O调度。
但是实际情况，Open-Channel Specification 仅仅定义了Open-Channel涉及的最为通用的部分。不同厂商的SSD产品特性不同，它们或者难以统一，对定制化应用和工作负载的需求，依旧欠缺灵活性
关于Zoned Namespaces (ZNS) 采用Open-Channel SSD架构有阿里，微软等，将这个架构成为NVMe标准规范一部分的概念，提供灵活的定制化需求是一个热点研究。西部存储将功能驱动到解决关键OCSSD用例的NVMe中，提出了ZNS的概念。
• 它是NVMe工作组中的技术提案
相对于正常的NVMe Namespace, Zoned Namespace将一个Namespace的逻辑地址
空间切分成一个个的zone。Zone的基本操作有Read, Append Write，Zone
Management 以及Get Log Page。 • 将zone接口标准化是为了：
减少设备端的WAF;减少OP;减少SSD的DRAM，这是SSD中代价最高的部分;改善延迟和吞吐量;适用软件生态系统； 怎么来理解?
ZNS与SMR的ZBC / ZAC相似
• 存储空间被分成多个zone
• 每一段zone内都是顺序写入的
• 它是针对SSD优化的接口
-与介质特征保持一致（Zone的大小和Nand的块大小一致，Zone的容量与介质大小一致）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e6b2f925608a73ced637db033144dfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19546633f0a2725d24cdcb1fb0c6c9e7/" rel="bookmark">
			监督学习、无监督学习、强化学习的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习 目前机器学习主流分为三大类：监督学习，无监督学习和强化学习
举个例子，我们经常考试，试卷上的题目我们未必都做过，但是在复试的时候会刷很多题，通过这些题目我们学会了阶梯方法，在考试时面对陌生的题目也能做出来。
同样机器学习也是一个举一反三的过程，我们可以利用一些训练数据，使机器能够利用它们分析未知数据。
通过计算的手段利用经验来改善系统自身的性能，其实它研究的问题就是学习算法，就是说我们把经验数据给它，然后它基于这些经验产生模型，下次遇到新情况时，模型就会给我们判断。
监督学习： 监督学习分为两大问题：“回归”和“分类”。
在回归问题中，我们会预测一个连续值，比如说预测明天多少度，预测房价多少钱等等，而分类问题就是预测明天是什么天气，多云、下雨还是晴天，它与分类问题的区别就在于分类问题的结果是一个类别，预测结果不是对就是错，而回归问题是对真实值的一种逼近预测，你的预测值与真实值差距越小则越好，不会存在对错的概念，比如预测房价为999元，真实价格为1000元，我们认为这是一个比较好的回归分析。
监督学习其实就是根据已有的数据集，知道输入和输出结果之间的关系，根据这种关系训练得到一个最优的模型。监督学习中训练数据是有标签的。
监督学习的目的是通过学习许多有标签的样本，然后对新的数据做出预测。
无监督学习： 无监督学习中，我们基本不知道结果会是什么样，但可以通过聚类的方式从数据中提取一个特殊的结构。在无监督学习中给定的数据集是和监督学习中给定的数据集不一样。无监督学习的训练数据没有相关的标签。
无监督学习算法的目标是以某种方式组织数据，然后找出数据中存在的内在结构。这包括将数据进行聚类，或者找到更简单的方式处理复杂数据，使复杂数据看起来更简单。
强化学习： 强化学习是一种学习模型，它不会直接给你解决方案，需要通过试错的方式去寻找。AlphaGo用的就是强化学习。
强化学习不需要标签，你选择的行动越好，得到的反馈越多。所以你能通过执行这些行动看是输是赢来学习下围棋，不需要有人告诉你什么是好的行动什么是坏的行动。
参考：https://blog.csdn.net/sqc3375177/article/details/78679603
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2867d6782b7bf0a4e2ca4bbb04a6e89/" rel="bookmark">
			C&#43;&#43;学习第六篇——最短路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最短路是图论最重要的算法之一，也是算法难点。经过这篇的学习，你会发现你离成功就差一个最短路的距离。=.=
最短路是指，某个点到某个点之间的距离最短。
算法1：Dijkstra算法 迪杰斯特拉算法是很典型的单源最短路算法，而且时间复杂度较其他算法更低，唯一的缺点是无法判断含负权边的图的最短路。而且其仅能作为单源最短路，也就是一个起点、一个终点求最短。在开始前推荐大家先去看我的另一篇博客最小生成树其中的prim算法和这个很类似。
同样由于技术有限，仅靠文字和代码讲解。-_-
int pic[1005][1005];//存图 在输入之前，初始化图，将各点之间的距离设置为最大值，表示无法到达。
这里的图是单向的。
void init() { for(int i=0;i&lt;1005;i++) { for(int j=0;j&lt;1005;j++) { pic[i][j]=(1&lt;&lt;21);//最大值可以自己设定，只要能表示不可达即可 } } } dijkstra模板函数如下
特别强调c++和java不同，新开的数组会沿用之前相同名字的内存地址，所以赋值false很关键。之前我的模板错误在此
另外注意起点下标0-n-1或者1-n需要更改
void dijkstra() { int weight[1005];//起始到其他端点的值 bool visit[1005]; for(int i=0;i&lt;n;i++) { weight[i]=pic[0][i];//将图中0到各个端点的值赋给weight数组 visit[i]=false; } weight[0]=0; visit[0]=true; //此时起点为0 while(true)//0点作为起始点，从下一个点开始 { int j=0,k=-1,min=(1&lt;&lt;21); //weight内的值为0时表示，已经访问过 //遍历weight数组，寻找一个最小值，并且该点没有被访问过 while(j&lt;n) { if(min&gt;weight[j]&amp;&amp;!visit[j]) { min=weight[j]; k=j;//用k存下这个节点 } j++; } //已知的min是我当前起始节点到k节点的距离，已知连接边中最短的 if(k==-1) break; visit[k]=true;//访问过该节点 //自此形成从起始到K的边,将其连接 for(int m=0;m&lt;n;m++) { if(weight[m]&gt;pic[k][m]+weight[k]&amp;&amp;!visit[m]) { weight[m]=pic[k][m]+weight[k]; //将单点间距离与新更新值距离比较求最小 } } } } 和prim唯一一点不同的是，其他点存的距离为一段距离，未连接之前是最大值，连接过后就是某一段加某一段,weight数组里面存的是起始点到各点之间的距离。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2867d6782b7bf0a4e2ca4bbb04a6e89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fec272c278aec781edbfd2031ccb6ce/" rel="bookmark">
			android 导入unity3d的类库：No implementation found for void com.unity3d.player.UnityPlayer.nativeRestart.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体原因不太清楚，怀疑是jni平台的问题。
我使用的unity3d版本是：2018.2.8f1。
出现问题的场景：
在unity3d中按正常流程导出android类库，在windows7电脑上的模拟器(android10)上运行没有问题。但是到了我的mac上的模拟器就出问题了，打开就报这个错误，而且，装到手机上也是这个错误。
解决问题的方式：
打包的时候选择scripting backend 中的IL2CPP,并勾选下放的 target architectures 中的 ARM64 平台。然后导出库。中间会让选择要使用的ndk(如果电脑配置了ndk的环境变量可能不需要选择了)。我这个版本的unity使用的r13k版本的ndk。具体配置如下图：
使用这种方式导出，编译速度会变慢很多。但是导出的类库使用的时候就不会报上面的错误了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3eeead2f7eecd270b6b6dd2a9fc3bdf/" rel="bookmark">
			HTML基础标签及案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML HTML概述 HTML：Hyper Text Markup Language（超文本标记语言）；是一门用户创建网页文档的标记语言，网页本身是一种文本文件，在文本文件中添加标记符。HTML是用来创建网页的标记语言，HTML标记的内容是用浏览器来解析的；所见即所得！
HTML特点 1、简易性：超文本标记语言的版本升级采用的超集方式，更加方便灵活；
2、可扩展性：超文本标记语言采取的子类元素的方式，为系统扩展带来保证；
3、平台无关性：只要有浏览器就行；
4、通用性：HTML是网络的通用语言，一种简单、通用的标记语言；
HTML基本结构 &lt;!-- 文档声明：文档的类型 --&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;!--网页的头部 --&gt; &lt;head&gt; &lt;!--字符集编码 --&gt; &lt;meta charset="utf-8" /&gt; &lt;!-- 页面的标题 --&gt; &lt;title&gt;卡卡之家&lt;/title&gt; &lt;/head&gt; &lt;!-- 网页的主题，显示的部分--&gt; &lt;body&gt; 展示的内容 &lt;/body&gt; &lt;/html&gt; HTML标签通常是成对出现的，有开始标签，有结束标签，称为对标签。没有结束标签的为空标签；
HTML标签都长都有属性，格式：属性名 = “属性值” 属性名 = “属性值”。多个属性用空格间隔；
HTML标签不区分大小写，建议小写；
HTML文件后缀名为html或htm；
HTML基本标签 结构标签 &lt;html&gt;&lt;/html&gt;:根标签 &lt;head&gt; ：头标签 &lt;title&gt;&lt;/title&gt;页面的标题 &lt;/head&gt; &lt;body&gt;：主体标签：显示网页内容 &lt;/body&gt; 属性：
color:文本的颜色
bgColor:背景色
background：背景图片
颜色的表示方式：
颜色名称 red blue green yellow orange
RGB模式 #000000 #ffffff #325687
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3eeead2f7eecd270b6b6dd2a9fc3bdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a070bf3c65591c15099a63982ad448fc/" rel="bookmark">
			用python判断一个数是否是完美数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚刚接触python不久，代码测试过可以运行，可能会有不严谨的地方
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c2660314db09451047636b20d7e2a9c/" rel="bookmark">
			咸鱼程序员之-算法第一篇-字符串暴力匹配算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hello ,本咸鱼这节给大家分享一下字符串匹配算法之-暴力匹配算法。
虽说这种算法不是特别好，但总归能解决问题。ok 。直接上代码：
这里小编有觉得有几个注意点。
1.边界问题： 因为你的数组是从0开始遍历，所以i一定不能等于数组的长度，否则就会越界。
2.返回的下标 这个下标是i-j 不要把j 理解成数组的长度奥
ok 我们来测试一下：
okay ，结果正确。这个算法一般不推荐面试的时候去说或者写，面试官会觉得你不懂算法。下节小编将分享经典的kmp算法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42bfe315b40f090070251135a7cea40b/" rel="bookmark">
			leetcode刷题汇总（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 就要找工作了，从此漫漫刷题路，受Grandyang启发，记录自己的做题之旅。刷题开始的有点晚，希望从现在坚持下去。
开始时间：20200312
题号分类题名备注1371前缀和状态压缩每个元音包含的字符串长度001680双指针回文串2001417递归与回溯太平洋大西洋水流问题001401数组、按位与二进制手表001345双指针交换元音字母344双指针字符串倒序343动态规划整数拆分001337动态规划 买卖股票的最佳时期含冷冻001322动态规划 零钱兑换001300动态规划、二分查找 最长上升子序列001287二分法、快慢指针寻找重复数001283数组移动0279图论、动态规划完全平方数216递归与回溯组合总和三215快排寻找第k大的数213动态规划打家劫舍2001210bfs课程表2001207bfs课程表001200递归与回溯岛屿数量001167双指针两数之和2131递归与回溯分割回文串001130递归与回溯被包围的区域001125双指针回文串122动态规划买卖股票最佳时期2121动态规划买卖股票最佳时期120动态规划三角形最小路径和105二叉树、递归从前序遍历和中序遍历构造二叉树00198动态规划打家劫舍00193递归与回溯复原IP地址00191动态规划解码方法00190递归子集二88数组合并两个有序数组80数组删除重复项79递归与回溯、二维平面单词搜索00178递归子集77递归与回溯组合75数组、快排颜色分类70动态规划爬楼梯64动态规划最小路径和63动态规划不同路径262动态规划不同路径52递归、回溯N皇后二51递归、回溯N皇后47递归、回溯、查找表全排列200146递归与回溯全排列00140递归与回溯组合总和二39递归与回溯组合总和27数组移除val元素26数组去重17递归与回溯电话号码的字母组合5动态规划最长回文子串 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/033fff1d3485c748b8e42303673e05e1/" rel="bookmark">
			什么是git，为什么要用git（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git是一个开源的分布式版本控制系统。重点是版本控制系统（version control system ）。
git的官方文档地址：https://git-scm.com/book/zh/v2/
一、什么是版本控制？ 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。
那什么又是版本？
在生活中，我们应该听过某某的书又出新版本了。苹果11又出来了，又该换手机了。新书、新手机对于之前的那本书来说就是新版本，以前的就是老版本。
在git上通俗点说就是：对文件进行修改、保存并提交，则形成一个版本。它是一个主观行为，你修改或者开发阶段性的完成了，并提交了，即形成一个版本。每提交一次就形成一个版本。
git就是对一系列的版本进行控制，并且是分布式的。
那什么又是分布式？
分布式的对立面是集中式。集中式就是所有的文件都存放在一台机器上，这台机器坏了，那就全部没有了。
分布式就是所有的文件不仅仅放在一处。在git中，你的电脑上的git仓库就是一个功能完整的系统，可以进行各种操作，也可以同步至github服务器上。
大概理解这么多，暂时就够用了。
二、如何安装git 官网下载地址：https://git-scm.com/downloads
官网提供了Mac OS X 、Windows、Linux/Unix 世界三大操作系统的软件版本，选择相应的安装即可。
三、为什么要学习git命令 对于习惯windows的用户，可能会不喜欢敲命令。但学习git命令不是目的啊，学习命令是为了熟悉和理解git的操作流程，
理解git的操作原理，是如何版本控制的。只要最终理解了，用开发工具的git操作，或者图形化工具，或者命令都不在话下了。
所以必须从git命令着手开始学习，最终达到可以在团队内与团队成员协作开发的目的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43887e885e12bf96388a71373c7ff5e6/" rel="bookmark">
			《数据中台：让数据用起来》读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言思维导图数据中台总体架构图 本文转载自 http://www.softeng.cn/?p=255 引言 最近三周主要读了两本书，一本是《大数据架构详解：从数据获取到深度学习》，目前只读了三分之一，而另一本就是本文所写的《数据中台：让数据用起来》，已经完全读完了，该书在2020年1月出版，其中系统的介绍了数据中台的调研、设计、实施、运营的方法论，虽然没有涉及到具体的技术实现细节，但是对于甲方、项目经理、需求分析师、数据管理员、数据运营人员等应该是够了，这本书可以让读者了解建设数据中台的全过程，以及建设数据中台所需要的基础知识，同时，该书也明确了各个角色、岗位人员在建设数据中台过程中的职责和工作内容。
读完这本书收获主要有以下几个方面：
对数据中台有了一个系统的了解，数据中台概念是近几年兴起的一种针对企业和政府机构的大数据应用，在之前的工作中，虽然也接触了一些中台相关的概念，但是一直没有机会去系统的了解，通过这本书，对数据中台有了一个较为全面的了解；从整体架构和设计层面积累了一些数据中台的知识，之前的工作中接触到的大多数都是业务系统，强调的主要是业务流程和业务逻辑，对于大数据相关知识了解较少，通过这本书，积累了一些大数据方面的基础知识；为今后的工作提供了一种新的思考方式，其实这本书中介绍的很多方法，不仅仅适用于数据中台建设，对于较为大型或专业的信息化系统，在系统设计和架构时，也可以参考该书中提到的一些方法。 从我的理解说说构建数据中台的几个要点：
数据中台建设是一个持续性工作，只有开始，没有结束，是一个循序渐进的过程，不能像对待一个普通的信息化项目那样去看待数据中台；数据中台需要企业全员积累、掌握数据意识，否则很可能成为早夭的或者昙花一现的项目；数据中台除了需要强大的技术支持外，还需要甲方战略层面、组织架构层面、日常管理层面多方面的支持，否则很难落地并良好运营；数据中台建设需要按行业、领域、核心关注点等要素因地制宜的进行设计和实施，在技术层面，有产品化的东西，但是在应用层面，每个企业需要按照各自的实际情况建设；数据中台的建设及运营会打破企业传统管理模式，极有可能伤害既得利益者，但当数据中台能够良好的运行后，又会给企业整体带来更大的利益；数据中台的建设应该是以企业的经营、管理需要为目的，而不是以完成上级的命令为目的；数据中台与统一数仓不同，其更强调数据资产化和资产服务化的能力；数据中台并非一种新的技术，我的理解，其是一种新的信息化架构，利用传统信息技术、大数据、人工智能、网络安全等技术手段，结合企业更加复杂的数据需求，而产生的一种新的信息化架构，更像是软件工程的产物。 思维导图 下图是本人读完本书后，根据目录结构及本人在阅读过程中认为是重点的内容整理出来的一张思维导图。
思维导图源文件下载地址：
链接：https://pan.baidu.com/s/1QWzA2ENxyYc9OovVXVO4ow
提取码：dgsz
数据中台总体架构图 下图是书中所介绍的一种较为常见的数据中台总体架构图，除了下图，在该书的附录中，还分别介绍了地产行业、证券行业、零售行业、制造行业、传媒行业、检务行业等6个行业的数据中台解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44e11041888fa57b76c093b2d3579f08/" rel="bookmark">
			OpenGL ES 3. 纹理采样 详述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，接下来将为大家介绍OpenGL ES 3. 纹理采样。
1、纹理采样概念
纹理采样就是根据片元的纹理坐标到纹理图中􏰯取对应位置颜色的过程。但由于被渲染图元中的片元数量与其对应纹理区域中像素的数量并不一定相同，也 就是说图元中的片元与纹理图中的像素并不总是一一对应的。
例如，将较小的纹理图映射到较大的图元或将较大的纹理图映射到较小的图元时这种情况就 会产生。因此，通过纹理坐标在纹理图中并不一定能得到与之完全对应的像素，这时就需要采用一些策略使得纹理采样可以顺序进行下去。通常采用的策略有最近点采样、线性采样两种，下面将一一进行详细介绍。 2、最近点采样 GL_NEAREST
最近点采样是最简单的一种采样算法，其速度在各种采样算法中也是最快的。
其实际效果如下图所示：
从前面原理的介绍中可以看出，最近点采样很简单，计算量也小。但最近点采样也有一个明显的缺点，那就是若把较小的纹理图映射到较大的图元上时容易产生很明显的锯齿。
GL_NEAREST的设置方式：
GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, //设置 MIN 时为最􏰰点采􏰞样 GLES30.GL_TEXTURE_MIN_FILTER,GLES30.GL_NEAREST); GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, //设置 MAG 时为最􏰰点采􏰞样 GLES30.GL_TEXTURE_MAG_FILTER,GLES30.GL_NEAREST); 3、线性采样 GL_LINEAR
线性采样算法的原理如图所示。
线性采样时的结果颜色并不一定仅来自于纹理图中的一个像素，其在采样时会考虑到片元 对应的纹理坐标点附近的几个像素。
其实际效果如下图所示：
由于采样时对采样范围内的多个像素进行了加权平均，因此，在将较小的纹理图映射到较大的图元上时，不再会有锯齿的现象，而是平滑。
GL_LINEAR的设置方式：
GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, //设置 MIN 时为线性采􏰞样 GLES30.GL_TEXTURE_MIN_FILTER,GLES30. GL_LINEAR); GLES30.glTexParameterf(GLES30.GL_TEXTURE_2D, //设置 MAG 时为线性采􏰞样 GLES30.GL_TEXTURE_MAG_FILTER,GLES30. GL_LINEAR); 最后，欢迎大家一起交流学习：微信：liaosy666 ； QQ：2209115372 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce0645b986a9332eab20ccaf16324465/" rel="bookmark">
			咸鱼engineer之-java设计模式第一篇-单例模式4种写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 单例模式通常有四种写法： 饿汉写法 懒汉写法
内部类写法
枚举写法
那么这些写法具体有什么区别呢，给大家分享下我自己的理解
1.饿汉模式： ok ，为什么恶汉模式这样写呢，其实他是通过jvm类加载机制来保证在类加载的时候只加载一次这个实例 的 ，不需要程序员去保证是否单例。这里 的构造方法必须是私有的，但是这种单例模式也有可能通过反射去调用构造方法，所以如果要保证绝对的单例，还需要加上一个判断。类似这样
其实java.lang下面的runtime就是饿汉模式写法：
2.懒汉模式： 懒汉模式有几点需要注意：1.需要构造方法私有 2.需要双重校验 3.加锁 4.防止cpu或者JIT指令重排序
懒汉一开始其实只需要这样写 保证需要的时候加载就ok
但是当多线程并行执行的时候就存在问题如下：
当两个线程同时走到这个place 的时候就会产生多例。ok 这样写确实能保证单例了，但是如果将synchronized加载方法上又会产生低效率的代码 ，我们只需要在need 产生对象的时候去new 对象，所以改造后如下：
那么此时是不是绝对单例呢，并不是，当两个线程同时并行执行，就会产生两个线程都获取锁成功，两个线程都获取到了锁资源，都从阻塞状态转为待运行状态，如下
所以还需要加上一层校验，如下：
最后还需要注意一点：cpu或者JIT导致的指令重排序,简单演示一下指令重排：比如：
当我们做一个new 对象的时候jvm 指令会做那些事情呢。我们用javap反汇编看下具体的过程 如下：
我们可以看到反汇编后的指令。第一步 是new 也就是分配空间 第二步是复制操作数栈 第三步是初始化 第四步是赋值
那么在多核cpu下并行执行两个线程就会出现指令重排的情况 比如：分配空间-&gt;初始化-&gt;赋值 指令重排后可能变成
分配空间-&gt;赋值-&gt;初始化。此时
当A线程来的时候，B线程可能还没进行初始化就拿到这个线程，就会有问题，所以我们需要加上关键字volatile来保证防止指令重排，如下
ok 这就算是一个完整的懒汉了。但其实这还有反射攻击问题。
3.静态内部类 这个就比较简单了
个人理解是通过jvm 类加载机制来保证的单例，和饿汉很像。如果要保证完全单例，还需要和上面的饿汉一样加上防止反射攻击的判断
4.枚举类 枚举类是比较标准的写法，虽然枚举的语法有点反人类，但还是好用的
枚举类其实即能防止反射攻击，也能防止因为序列化和反序列化导致的产生多例问题
这里的序列化和反序列化指的是下面这个场景：
比如我把通过getInstance取出来的对象序列化的磁盘上，在从从磁盘上取出来的时候你就会发现并不是一个对象，那么这个时候也就不是单例了，怎么防止这个问题呢，打开serializable这个类我们可以看到
他已经帮我们想好办法了，
如果不是采取枚举写法，你需要在你的类重写serializable 的一个方法readResolve()就可以保证被序列化后的类对象是一个了。
但是如果你采用枚举写法就不会用这个问题，因为枚举已经帮你实现了。
总结一下：如果你想偷懒用饿汉就可以了，但是需要加上防止反射的判断以及重写序列化的方法才能完全保证安全。如果想要完全高级且安全建议枚举写法。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6606a37fc4be7f7c82365c7cbf9db61/" rel="bookmark">
			Python类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python类 一、概述 Python 类包括数据和行为，对象与对象通过消息机制来相互通信。
二、定义类 class className(basicClass): classbody 三、类的成员 （一）类的成员：
1、数据成员（attribute):表示对象特征，以变量形式呈现。
2、成员方法（method):表示对象方法，以函数形式呈现。
（二）数据成员的分类（按归属）
1、属于对象的数据成员：
定义：一般在__init__方法定义，以 self.name 形式呈现。
访问：只能通过对象名访问 。
属性：每个对象的数据成员是相互独立，互不影响。
2、属于类的数据成员：
定义：一般不在任何成员方法定义。
访问：类外部通过类名或对象名访问，（类内部通过“类名.成员名")
属性：该类所有对象共享
（三）类的数据成员的分类：（按是否能被类外部访问）
1、私有成员：
（1）特征：不能被类的外部直接访问。
（2）定义形式：以__name（以两个下划线，但不 以两下划线表示）
（3）特殊：python私有成员没有严格的访问保护机制，类外部分仍然可能以“对象名._类名__私有成员名”来访问类内部私有成员
（4）特殊的私有成员：name（前后都两个划线），是系统定义的特殊成员。
2、公有成员：
（1）特性：类外部能够直接访问
（2）定义形式：一般形式（name)
class ca: num = 0 #属性类的公有数据成员 __cnum = 0 #属性类的私有数据成员 def __init__(self, v1 = 0, v2 = 0): self.v1 = v1 #属于对象的公有数据成员 self.__v2 = v2 #属于对象的私有数据成员 ca.num += 1 #类内部访问 属性类的公有数据成员 类名.成员名 ca.__cnum +=2 #类内部访问 属性类的私有数据成员 类名.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6606a37fc4be7f7c82365c7cbf9db61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/024b4409e11aacf20c19ce4f7d5c91aa/" rel="bookmark">
			真彩色图像RGB，YIQ图像，HSV图像，YCbCr图像的相互转换(Matlab实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		image=imread('Lena.jpg'); subplot(2,4,1); imshow(image) title('原始图像') %RGB转YIQ YIQ=rgb2ntsc(image); subplot(2,4,2); imshow(YIQ) title('RGB转YIQ') %YIQ转RGB rgb=ntsc2rgb(YIQ); subplot(2,4,3); imshow(rgb) title('YIQ转RGB') %RGB转hsv HSV=rgb2hsv(image); subplot(2,4,4) imshow(HSV) title('RGB转hsv') %hsv转RGB rgb1=hsv2rgb(HSV); subplot(2,4,5) imshow(rgb1) title('hsv转RGB') %RGB转YCBCR yc=rgb2ycbcr(image); subplot(2,4,6) imshow(yc) title('RGB转YCBCR') %YCBCR转RGB rgb2=ycbcr2rgb(yc); subplot(2,4,7) imshow(rgb2) title('YCBCR转RGB') 主要函数有：
rgb2gray 将RGB图像转换成灰度图像
ind2gray 将索引色图像转换成灰度图像
rgb2ind 将RGB图像转换成索引色图像
ind2rgb 将索引色图像转换成RGB图像
im2bw 将图像转换成黑白图像
实现效果：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/440/">«</a>
	<span class="pagination__item pagination__item--current">441/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/442/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>