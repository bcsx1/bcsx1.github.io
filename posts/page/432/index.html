<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45bff2f21cc2c768a5e8736bfeed3fe2/" rel="bookmark">
			机器学习——支持向量机SVM之多分类问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
方法1：改造目标函数与限制条件
方法2：一类对其他类（类数为N，需要建立N个SVM模型）
情形1：多个SVM模型结果交集得出确切归类
情形2：多个SVM模型结果交集没有得出确切归类
方法3：一类对一类（类数为N，需要建立SVM模型为N*(N-1)/2个）
方法1：改造目标函数与限制条件 这个方法不太实用
方法2：一类对其他类（类数为N，需要建立N个SVM模型） 即将其他类合并为一类，另一个类独立出来，常用来处理三类问题，测试样本的分类通过交集来完成
情形1：多个SVM模型结果交集得出确切归类 情形2：多个SVM模型结果交集没有得出确切归类 方法3：一类对一类（类数为N，需要建立SVM模型为N*(N-1)/2个） 这种方法就是将多类中的每一类与剩下的类逐一进行建立SVM模型，对测试样本进行归类，最后将测试样本归类到占比大的那一类,类似于投票的性质，票数多的类就将样本归类到这一类
这是最常用的方法，最有效的方法，但SVM模型多，计算时间长
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9f5700b8a04212ae6f561341b237bb2/" rel="bookmark">
			一篇文章区分监督学习、无监督学习和强化学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过之前的一些积累，终于有勇气开始进军机器学习了！说实话，机器学习 这个概念是我入行的最纯粹的原因，包括大学选专业、学习 Python 语言…这些有时间仔细梳理下经历再写，总之这个系列的文章就是我自学 机器学习 的笔记，各位看看就好，希望能为一些想入门但无从下手的小伙伴，提供一些帮助。另外我会采用通俗易懂的方式描述一些概念上的东西，我本人小白一枚，如果在这系列的文章中有什么错误，欢迎各路大神指正！在此谢过。
机器学习 所谓机器学习，就是让机器(特指计算机)具有像人类一样学习能力的技术，从海量数据(大数据)中寻找有价值的信息。所以我认为，机器学习的本质是数据挖掘技术。
比如 淘宝通过你的购买记录向你推荐可能感兴趣的商品；头条通过你的浏览记录向你推荐可能感兴趣的文章或视频……
机器学习的种类 根据数据训练方式的不同，机器学习分为 监督学习、无监督学习和强化学习 3 种学习类型，本文的目的就是用最朴素的语言描述三者之间的区别，以明确概念。
监督学习 监督学习是一个 举一反三 的过程，先由已标注正确的 训练集 进行训练，训练完成之后的“经验”称为模型，然后将未知的数据传入模型，机器即可通过“经验”推测出正确结果。
这么讲有些抽象，举个例子：
1.老师：1 个苹果 + 1 个苹果 = 2 个苹果 2.学生：1 个苹果 + 1 个苹果 = 2 个苹果 3.老师：1 个香蕉 + 1 个香蕉 = 2 个香蕉 4.学生：1 个香蕉 + 1 个香蕉 = 2 个香蕉 5.老师：1 个西瓜 + 1 个西瓜 = ？ 6.学生：1 个西瓜 + 1 个西瓜 = 2 个西瓜 上边的例子中，学生通过总结第 1 步和第 3 步中，老师所传授的“苹果和香蕉”的经验，总结出了 “1 + 1 = 2”，所以，在第 5 步，老师没有给定答案的情况下，学生根据总结出的 “1 + 1 = 2”的经验，给出了 “1 个西瓜 + 1 个西瓜 = 2 个西瓜”推测。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9f5700b8a04212ae6f561341b237bb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af89f4f543ab348afe3963116f52839d/" rel="bookmark">
			Java基础知识学习:语句块_方法_递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录,更新ing,学习Java的点滴记录 目录放在这里太长了,附目录链接大家可以自由选择查看--------Java学习目录
语句块 语句块（有时叫做复合语句），是用花括号扩起的任意数量的简单 Java 语句。块确定
了局部变量的作用域。块中的程序代码，作为一个整体，是要被一起执行的。块可以被嵌套在另一个块中，但是不能在两个嵌套的块内声明同名的变量。语句块可以使用外部的变量，而外部不能使用语句块中定义的变量，因为语句块中定义的变量作用域只限于语句块。示例
方法 许多程序设计语言(像C和C++)用函数这个术语来描述命名子程序;而在Java里却常用方法这个术语表示"做某些事情的方法".Java的方法决定了一个对象能够接收什么样的消息.方法的基本组成部分包括:名称,参数,返回值和方法体方法声明基本形式:
返回类型描述的是在调用方法之后从方法返回的值.参数列表给出了要传给方法的信息的类型和名称.方法名和参数列表(合起来被称为"方法签名")唯一地标识出某个方法.Java中的方法只能作为类的一部分来创建,除静态方法外,方法只能通过对象才能被调用,且这个对象必须执行这个方法的调用.如果视图在某个对象上调用并不属于它的方法,那么在编译时就会得到错误信息.方法调用形式:
对象名.方法名(实参列表)方法详细说明
形式参数:在方法声明时用于接收外界传入的数据----(int a,int b)
实参调用方法时实际传给方法的数据-----(1,2)
返回值:方法在执行完毕后返还给调用它的环境的数据-----main方法中打印函数接收到的数据是3
返回值类型:实现约定的返回值的数据类型,如无返回值,必须指定为void------testMethod方法的返回值类型为int调用方法的注意点
(1) 实参的数目,数据类型和次数必须和所调用的方法声明的形式参数列表匹配
(2)return语句终止方法的运行并返回数据
(3) Java中进行方法调用传递参数时,遵循值传递的原则(传递的都是数据的副本)
当方法参数为基本数据类型时，是将外部变量值拷贝到局部变量中而进行逻辑处理的，故方法是不能修改原基本变量的
对于引用类型的方法参数，会将外部变量的引用地址，复制一份到方法的局部变量中，两个对象指向同一个地址。所以如果通过操作副本引用的值，修改了引用地址的对象，此时方法以外的引用此地址对象也会被修改。 方法的重载 在日常生活中,相同的词可以表达多种不同的含义—他们被"重载"了.特别是含义之间差别很小时,这种方式十分有用.可以说"清晰衬衫,清洗车,清洗狗".但如果硬要这样说就显得很愚蠢:“以洗衬衫的方式洗衬衫,以洗车的方式洗车”.这是因为听众根本不需要对所执行的动作做出明确的区分.大多数人类语言都具有很强的"冗余性".提前讲一点关于类的知识:在Java(和C++)里,构造器时强制重载方法名的一个原因.既然构造器的名字已经由类名所确定,就只能有一个构造器名.那么想用多种方式创建一个对象该怎么办呢?为了让方法名相同而形式参数不同的构造器同时存在,必须用到方法重载.方法的重载是指一个类中可以定义多个方法名相同，但参数不同的方法。 调用时，会根据不同的参数自动匹配对应的方法。构成方法重载的条件:
形参类型、形参个数、形参顺序不同雷区
只有返回值不同不构成方法的重载
只有形参的名称不同，不构成方法的重载示例 package com.test; public class Main { public static void main(String[] args) { System.out.println(add(3, 5));// 8 System.out.println(add(3, 5, 10));// 18 System.out.println(add(3.0, 5));// 8.0 System.out.println(add(3, 5.0));// 8.0 // 我们已经见过的方法的重载 System.out.println(); //0个参数 System.out.println(1); //参数是1个int System.out.println(3.0); //参数是1个double } /** * 求和的方法 */ public static int add(int n1, int n2) { int sum = n1 + n2; return sum; } // 方法名相同，参数个数不同，构成重载 public static int add(int n1, int n2, int n3) { int sum = n1 + n2 + n3; return sum; } // 方法名相同，参数类型不同，构成重载 public static double add(double n1, int n2) { double sum = n1 + n2; return sum; } // 方法名相同，参数顺序不同，构成重载 public static double add(int n1, double n2) { double sum = n1 + n2; return sum; } //编译错误：只有返回值不同，不构成方法的重载 // public static double add(int n1, int n2) { // double sum = n1 + n2; // return sum; // } //编译错误：只有参数名称不同，不构成方法的重载 // public static int add(int n2, int n1) { // double sum = n1 + n2; // return sum; // } } 涉及基本类型的重载(可能复杂一点,可跳过)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af89f4f543ab348afe3963116f52839d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3670421bd18137e4fca77ab18ef22247/" rel="bookmark">
			yarn 的安装和换源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yarn 的安装和换源 一：介绍 1.1 Yarn 的简介： ​ Yarn是facebook发布的一款取代npm的包管理工具；
1.2 Yarn的特点： ​ 1)速度超快—-Yarn缓存了每个下载过的包，所以再次使用时无需重复下载。同时利用并行下载以最大化资源利用率，因此安装快。
​ 2)超级安全—-在执行代码之前，Yarn会通过算法检验每个安装包的完整性。
​ 3)超级可靠—–使用详细、简洁的锁文件格式和明确的安装算法，Yarn能够保证在不同系统上无差异工作。
二：安装 进入官网：https://classic.yarnpkg.com/zh-Hans/docs/install#windows-stable
下载安装程序
之后点击运行，之后一直点击Next就可以了
在cmd中输入
yarn --version
看到如下界面即是成功了。
三：换源 yarn config get registry // 查看yarn当前镜像源
yarn config set registry https://registry.npm.taobao.org/ // 设置yarn镜像源为淘宝镜像
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c0a11d344264fb26ca533967219ca79/" rel="bookmark">
			什么是WSGI？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WSGI的全称是Web Server GateWay Interface，Web服务器网关接口，是Python定义的一个服务器与web应用通信的接口。嗯，看了定义还是不懂这到底是什么，没关系，我们接着往下看。
1.web开发遇到的问题 假设我们现在想用Python开发一个 “Hello World” 级别的HTTP Web应用。在不借助任何其他已有的组件情况下，如何开始呢？首先，不管应用有多简单，也要实现一个服务器。服务器要一直监听TCP的80端口，当发现有内容传入时，把内容解析为HTTP数据包。怎么解析呢？从TCP接收到的内容实际是由各种分隔符和字符组成的HTTP报文，必须遵循HTTP协议的规范，才能正确解析，所以还要先研究RFC文档，可能光看文档就得几个月（头秃）；最后按照HTTP协议的规范把想返回的内容加上HTTP头，传给TCP，这才是一个完整的服务器处理周期。这仅仅是服务器的部分，接下来才能关注Web应用。
好在我们不必自己从头写Web服务器，已经有别人写好了，我们只需关注Web 的应用层，然后把这个应用交给服务器就行。那么问题又来了，服务器和Web应用如何通信呢？写服务器的是一帮人，写应用层的是另一群人，需要制定统一的接口，这样两边才能正常通信。在这种情况下，诞生了WSGI。WSGI的位置大致如下图所示：
现在，我们要是想实现一个Web应用，只需关注应用层面，遵循WSGI接口即可，而无需关注底层的服务器。
2.一个最简单的WSGI应用 实现一个遵循WSGI的应用很简单：
def application(environ,start_response): start_response(status,response_headers) return [response_body] 如上所示，满足的条件有：
该应用必须是一个可调用对象，无论是函数、方法还是一个实现了__call__ 方法的对象；应用必须接收两个参数，一般用environ和start_response，这两个参数都是由服务器传递进来；前一个是字典，包含了HTTP请求的一些字段（CGI字段）；后一个是回调函数，由此应用调用，给Web服务器返回HTTP状态码和其他头部，状态码应为string，而头部应为由二元tuple组成的 list；最后该应用需要返回一个HTTP body，是一个bytes组成的可迭代对象（如list)。 按照这样的接口规范，我们现在来写一个返回 “Hello World” 的Web应用：
def application(environ,start_response): if environ["REQUEST_METHOD"] == "GET": # 判断请求方法是否是GET start_response('200 OK',[('Content-Type', 'text/html')]) # 回调 return [b'Hello World'] # 返回一个可迭代对象 代码很简短，先判断请求方法，再回调，最后返回内容。函数的两个参数，environ和start_response将会由服务器传递进来。
现在我们只需要一个符合WSGI标准的服务器，把这个函数交给服务器运行即可。Python内置了一个简易的服务器，我们可以通过wsgiref来使用：
from wsgiref.simple_server import make_server httpd=make_server('127.0.0.1',port=9005,app=application) if __name__ == "__main__": https.serve_forever() 我们把application这个函数对象传给了服务器，启动后就可以在本地9005端口监听客户端请求了。用curl命令测试一下：
$ curl http://localhost:9005 Hello World 到这里我们已经对WSGI有了足够的了解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/465bcd0e3210b4c32d82590fc9256d0d/" rel="bookmark">
			MakeFile 编译时如何控制命令是否打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		makefile 默认情况下是输出命令的，可以通过命令前加@屏蔽命令的显示
下面定义是否为DEBUG 模式的控制
ifeq ($(DEBUG),true)
hide:=
else
hide:=@
endif
编写makefile
all:
${hide}echo "aaaa"
${hide}echo "bbbb"
执行make 显示：
echo "aaaa"
aaaa
echo "bbbb"
bbbb
执行 export hide=@ ;make 则显示
aaaa
bbbb
如果仅仅想调试makefile 而不想执行命令可以使用make 的“-n”或“--just-print” 参数
如执行 make -n 显示
echo "aaaa"
echo "bbbb"
如果想全面禁止命令的输出也可以使用make 的“-s”或“--slient” 参数
如执行make -s 显示
aaaa
bbbb
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34bbd21c58362ed55bcf08fb59a954ea/" rel="bookmark">
			ets Jan8 2013，rst cause :2,boot mode :(1,7)_ESP8266学习笔记（6）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用uart串口烧录完程序，打开串口助手，复位后，可能会看到且只看到这样一个语句：
ets Jan8 2013，rst cause :2,boot mode :(1,7)
其实只是因为你忘记关掉烧录模式了
何以见得呢？
在于boot mode：(1,7)中的1（7没什么意义），其意义可查看下表：
（GPIO15,GPIO0,GPIO2）BOOT模式Mode（0,0,0）Remamping0(0,0,1)UART Boot1(0,1,0)Jump Boot2（0,1,1）Flash Boot3（1,0,0）SDIO Low Speed V2I04（1,0,1）SDIO High Speed V1I05（1,1,0）SDIO Low Speed V1I06（1,1,1）SDIO High Speed V2I07 其中GPIO15,GPIO0,GPIO2是esp8266下载时用到的三个GPIO口，（0,0,0）即使对应GPIO15,GPIO0,GPIO2的电平为低，低，低。
如果是用uart串口下载的话，则下载时使用模式 UART Boot,下载完成后，使用Flash Boot！
但如果看到的是：
ets Jan8 2013，rst cause :2,boot mode :(3,6)
此时模式是正确的，但是执行发生了错误，这个看rst cause:2中的2，它表示的意义如下：
1，电源复位
2，外部复位
4，硬件看门狗复位
如有疑问或纰漏，欢迎留言！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fff4cbc1e4d96e705c23733cc1b2f0c/" rel="bookmark">
			SpringBoot项目使用Maven自动扩展属性   |   MSCode微服务平台框架代码源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot项目使用Maven自动扩展属性。
MSCode微服务平台框架 mscodecloud.com 代码示例
app.encoding=@project.build.sourceEncoding@ app.java.version=@java.version@ &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;configuration&gt; &lt;delimiters&gt; &lt;delimiter&gt;@&lt;/delimiter&gt; &lt;/delimiters&gt; &lt;useDefaultDelimiters&gt;false&lt;/useDefaultDelimiters&gt; &lt;/configuration&gt; &lt;/plugin&gt; Gradle代码示例：
processResources { expand(project.properties) } app.name=${name} app.description=${description} MSCode微服务平台框架 mscodecloud.com 是基于Spring Cloud、Spring Boot、Activiti7工作流和阿里巴巴组件，提供所有源码和详尽文档的企业级快速开发平台。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1abb2f8582d032fa961ce687640857d2/" rel="bookmark">
			SpringBoot自定义启动前的Environment或ApplicationContext   |   MSCode微服务平台框架代码源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot自定义启动前的Environment或ApplicationContext。
MSCode微服务平台框架 mscodecloud.com 代码示例
每个实现注册在META-INF/spring.factories：
org.springframework.boot.env.EnvironmentPostProcessor=com.example.YourEnvironmentPostProcessor 实现代码：
public class EnvironmentPostProcessorExample implements EnvironmentPostProcessor { private final YamlPropertySourceLoader loader = new YamlPropertySourceLoader(); @Override public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) { Resource path = new ClassPathResource("com/example/myapp/config.yml"); PropertySource&lt;?&gt; propertySource = loadYaml(path); environment.getPropertySources().addLast(propertySource); } private PropertySource&lt;?&gt; loadYaml(Resource path) { if (!path.exists()) { throw new IllegalArgumentException("Resource " + path + " does not exist"); } try { return this.loader.load("custom-resource", path).get(0); } catch (IOException ex) { throw new IllegalStateException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1abb2f8582d032fa961ce687640857d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2266df0f6690fb9e49519b455c9c0d7/" rel="bookmark">
			百度开源全新版本词法分析工具LAC 2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎关注 “百度NLP” 官方公众号，及时获取更多自然语言处理技术干货！
百度NLP权威发布，可能是最好用的中文词法分析工具****——LAC 2.0闪亮登场！与LAC 1.0相比，LAC 2.0在性能与效果上有明显提升，且支持多种开发语言，一键安装调用，更加快速便捷。
LAC项目地址：
https://github.com/baidu/lac
LAC是什么 LAC全称Lexical Analysis of Chinese，是百度NLP（自然语言处理部）研发的一款词法分析工具，可实现中文分词、词性标注、专名识别等功能。
LAC在分词、词性、专名识别的整体准确率超过90%，以专名识别为例，其效果要比同类词法分析工具提升10%以上。
例如：我知道你不知道，百度开源词法LAC帮你更懂中文！
LAC 2.0可以从语义合理性角度精确完成分词、词性标注和专名的一体化识别。
LAC 2.0有哪些优势 自开源以来，LAC得到了不少关注与好评。为了进一步提升厂内外开发者的使用体验，我们对LAC进行了新一轮全面升级，带来5大优势：
1、效果好：通过大规模语料自动标注和联合模型训练，整体效果业内领先
通过前沿的深度学习模型BiGRU-CRF，LAC 2.0可以联合学习分词、词性标注和实体识别这三个具有强关联性的任务，模型的整体效果F1值超过了0.91，词性标注F1值超过了0.94，专名识别F1值超过了0.85，效果对比业内其他开源工具达到了领先的水平。
同时，对于词法分析而言，OOV(新词，out of vocabulary)是当前模型效果提升最大的障碍，最有效的解决方法是增加数据量，但是人工标注数据需要巨大的人力成本。我们基于强大的NLP技术积累，通过自动标注生成大规模数据集，让模型可以学习到强大的泛化特征，并通过一定量的人工标注数据对模型进行修正。相较于仅用人工标注数据集进行模型训练，通过该方法训练得到的模型整体效果提升超过3%。
2、效率高：优化模型参数与性能，重构C++调用代码，简化编译流程，性能提升约2倍
与旧版本相比，LAC 2.0的效率得到较大的提升。通过精简模型参数，结合飞桨预测库的性能优化，LAC 2.0词法分析的CPU单线程性能优于其他主流工具（详细数据参考表4词性标注与实体识别性能评估）。
3、可定制：
LAC 2.0可以实现简单可控的干预机制，能够精准匹配用户词典对模型进行干预，词典支持长片段形式，使得干预更为精准。
模型示意图
4、调用便捷：增加Python的pip一键安装，增加Java和Android的支持与调用
LAC 1.0仅支持C++和Python，调用相对复杂有一定门槛。LAC 2.0则同时提供了Java、android、C++和Python语言，重构相关代码，相比LAC1.0版本使用更便捷。同时，LAC 2.0支持一键安装，开发者可以实现快速调用和集成。
5、支持移动端：定制超轻量级模型，体积仅为2M
LAC 2.0在对Android应用的支持上，定制了一版超轻量级的模型，该模型的体积仅为2M，在主流千元手机上测试单线程性能达到了200 QPS，能够满足大多数移动应用的需求，效果大幅超过了同等体积量级的模型。
LAC 2.0对比其他开源工具 分词效果
我们选择市面上流行的3款分词工具进行模型比较。并在pku、msr、ctb、weibo等多个开源数据集对模型效果进行评测，从结果上看，LAC在不同数据集的分词效果均明显优于相关工具，平均分词错误至少降低38.5%，如下所示：
该表格列出的数据是通过各个工具提供的训练接口在不同开源数据集上进行微调训练得出。采用数据集微调训练后再评估，是因为目前分词结果并没有统一的标准，比如人名“张三”，MSR数据集切分时会将其作为一个完整的单词，而工具A数据集标准则认为姓和名需要进行切分，故而会切分为“张 三”。不同标准导致结果差异大，故而通过微调训练使得模型在一个分词标准下进行比较。
LAC默认模型的分词标准偏向于实体粒度，会比其他开源工具的分词粒度更大一些，有需要的同学，可通过增量训练接口和定制接口快速实现模型微调和粒度迁移。
专名识别效果
标注任务中，我们以词法任务中难度最大的专名识别任务对LAC的效果进行评估，在开源的新闻实体识别数据集（MSRA）与简历实体识别数据集（Resume）上比较了LAC 2.0与其他工具的效果差异：
表1 MSRA 专名效果评估
表2 Resume 专名效果评估
表1、表2中LAC的人名识别效果显示会稍低于工具B，实则是因为LAC认为"张先生"、"李老师"才是一个完整的人名实体，而其他工具和MSRA数据集则将其中"张"字、"李"字标注为人名实体。故而LAC的人名识别效果实际上会显著高于表中的数值，并优于工具B。
综上可知，LAC的专名识别的整体效果要显著优于其他工具。
性能比较
我们也对LAC与其他工具的性能进行比较，测试环境为：Python语言，Linux系统，CPU E5-2650 v3。
其分词的性能如表3所示，词性标注与实体识别性能如表4所示，LAC还可实现批处理的形式，性能会更快一些。
从结果上看，在分词速率上，LAC性能优于工具A和工具B。而在词性标注和实体识别上，LAC的性能是最高的。
表3 分词性能评估
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2266df0f6690fb9e49519b455c9c0d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aa7880f6e565c8381817d580256a8c6/" rel="bookmark">
			Unity双指控制缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity双指控制缩放 缩放原理代码属性与方法 缩放原理 我所使用的缩放逻辑原理与其他人的可能不太一样，但也不是什么非常复杂的算法，可以说就是摄像机的拉近拉远，通过这种方式实现图像上的放大缩小。
代码 protected readonly Transform m_zoom = null; private float max = 3.7f; private float min = 0; protected static float current = 0; private float last = -1; public void Update() { if (Input.touchCount == 2) { float dis = Vector2.Distance(Input.touches[0].position, Input.touches[1].position);//两指之间的距离 if (-1 == last) last = dis; float result = dis - last;//与上一帧比较变化 if (result + current &lt; min)//区间限制：最小 result = min - current; else if (result + current &gt; max)//区间限制：最大 result = max - current; result *= 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aa7880f6e565c8381817d580256a8c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d98a67330e90c771e2145d3136305c/" rel="bookmark">
			no converter found for return value of type: class net.sf.net.json.JSONObject解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息如下图：
原因分析： 这个问题是spring注解@responseBody会自动将返回类型转为接送格式，没有该类型（net.sf.net.json.JSONObject）的类型转换器（下图第七个缺少MappingJacksonHttpMessageConverter ）引起的。如下图：
而引起 MappingJacksonHttpMessageConverter 类型缺少的原因是 项目本来是spring3版本，jackson版本是jackson-core-asl和 jackson-mapper-asl 都是1.9.13 当spring升级到4版本时，jackson版本未升级，导致找不到该类型转换器。
解决办法：把jackson升级到2版本后(去掉jackson1版本，因为2版本包名换了) 该错误就解决了。jackson依赖如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1777f56a6f642e4d5f7480f59d8b702/" rel="bookmark">
			beq的实验笔记-《Node.js中CommonJs的机制》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node.js中模块以文件为粒度。
require 引入文件，路径可以使用小驼峰,'.'或者'..'结合，引入的文件如果是文件夹，会优先找到改文件夹下的package.json，如果配置合法会找到main指向的文件，否则加载index.js,index.json,index.node,其种.node是c++扩展。
module.exports/exports是文件暴露出去的对象，实则每个模块都是互不干涉的闭包。
使用 require 引入的文件是（形式引用）有缓存的，即第一次加载包后后续加载会读取缓存中的包数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f82e5269bc97d73ce0ba946108956b3/" rel="bookmark">
			MySQL客户端Navicat的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL客户端Navicat的使用
1.MySQL中添加PatchNavicat.exe
Windows系统中MySQL的安装教程：
Windows系统中MySQL的安装教程_mry6的博客-CSDN博客
(1)下载Navicat软件,双击鼠标左键安装,之后的操作只需点击Next就可以安装成功.
(2)把PatchNavicat.exe放到安装目录下面
(3)安装结束后双击PatchNavicat.exe,显示成功,就可以进入navicat不用注册的页面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95ee9783fa1c0d8aeb1ae9231a0df26b/" rel="bookmark">
			去除Recycleview自带删除item效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 去除Recycleview自带删除item效果
(自己的RecyclerView).setItemAnimator(null); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab3e47e0a5111461a59dfe2a3a9b5a27/" rel="bookmark">
			一维卷积（1D-CNN）、二维卷积（2D-CNN）、三维卷积（3D-CNN）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一维卷积神经网络（1D-CNN） 一维卷积常用在序列模型、自然语言处理领域；
假设输入数据维度为8，filter维度为5；
不加padding时，输出维度为4，如果filter的数量为16，那么输出数据的shape就是；
二维卷积神经网络（2D-CNN） 二维卷积常用在计算机视觉、图像处理领域（在视频的处理中，是对每一帧图像分别利用CNN来进行识别，没有考虑时间维度的信息）；
假设原始图像 shape 为（其中3为3个通道），使用32个大小为（其中3为深度，与通道数相同）的卷积核对其进行卷积，得到特征图的shape为；
三维卷积神经网络（3D-CNN） 在神经网络的输入中增加时间这个维度（连续帧），神经网络就可以同时提取时间和空间特征，进行行为识别、视频处理；
比如：对3幅连续帧用三维卷积核进行卷积，可以理解为用3个不同的二维卷积核（二维卷积神经网络中使用的卷积核）卷积3张图，并将卷积结果相加（通过这种处理，网络就提取了时间之间的某种相关性）；
三维卷积神经网络的训练和卷积神经网络的训练方式相同；参考：深度网络的训练过程与方法
在文献《3D Convolutional Neural Networks for Human Action Recognition》中三维卷积与二维卷积的对比图如下：
上图的三维卷积是对连续的三帧图像进行卷积操作（堆叠多个连续帧组成一个立方体，在立方体中利用三维卷积核进行卷积，这样得到的每个特征map都与上一层中3个邻近的连续帧相连）；
三维卷积神经网络架构如下图：
input：7张大小为的连续帧；
hardwired，H1：通过设定的hardwired kernels获得5种特征（灰度、x方向梯度、y方向梯度、x方向光流、y方向光流），前三个特征可以对每帧分别操作获得，光流则需要利用2帧信息获得，所以H1层特征map数量为7+7+7+6+6=33；
convolution C2：3D卷积核的大小为（3为时间维度），即每次操作3帧图像，采用了2种不同的3D卷积核，增加了maps数量；
sub-sampling S3：按照图中降采样后maps数量保持不变，maps大小减半；
后面操作分析类似。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/640af4072a93e7d33c278f0c3f7aa2f1/" rel="bookmark">
			指针变量被const修饰的两种情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const int * p = &amp;a; //const修饰的指针指向的目标
// int const *p = &amp;a; // 和上一句等价
*p = 200; // error
int * const q = &amp;a; // const修饰的是指针变量，不能改变q指向的目标，
q = &amp;b; // error
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d70532514cde22a74e6137de5351131a/" rel="bookmark">
			springBoot中对于model层、dao层、service层、controller层的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springBoot作为一个轻量级的java开发框架，在许多的方面提出了相应的解决方案。
一般来说基于springBoot的项目基本分为以下几个层次（在项目文件夹中体现为一个层次对应一个package）
Dao层（mapper层）service层（业务层）model层（entity层）controller层（控制层） 各层的作用 Dao 层 即数据持久层，对数据做持久化操作。也被称为mapper层。dao层的作用为访问数据库，向数据库发送sql语句，完成数据的增删改查任务。
Service 层 业务层，service层的作用为完成功能设计。存放业务逻辑处理，不直接对数据库进行操作，有接口和接口实现类，提供controller层调用的方法。调用dao层接口，接收dao层返回的数据，完成项目的基本功能设计。（也就是说对于项目中的功能的需求就是在这里完成的）
Model 层 即数据库实体层，也被称为entity层，pojo层，存放的是实体类，属性值与数据库中的属性值保持一致。 实现set和get方法。
一般数据库一张表对应一个实体类，类属性同表字段一一对应
Controller层 控制器层，controller层的功能为请求和响应控制。controller层负责前后端交互，接受前端请求，调用service层，接收service层返回的数据，最后返回具体的页面和数据到客户端。
因此对于一个Web项目，从发起请求到给与响应的流程是这样的：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30cc7d6269d18a1d08fb8ae1262ca9f4/" rel="bookmark">
			原码、反码、补码（中日两国概念体系之间的对比分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.国内概念体系介绍，相关内容出处：https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html
2.日本概念体系介绍，相关内容出处：https://mathwords.net/ninohosuu
简单概括：
1.国内：原码即原码，首位作符号位，0为正，1为负数。正数的原码，反码，补码均相同，不再赘述。
关于负数，反码则将符号位保留，其他位取反即可，补码则为反码+1。
补码再次取反+1，可以得到原码。（符号位始终不变）
2.日本只存在【1的补数】【2的补数】两个概念。
【1的补数】涉及的比特列不讨论正负，即默认正数，
对一组正常的序列全部取反，得到这个数之于1的补数，简称【1的补数】。
同补码过程相同，【1的补数】+1，即得到【2的补数】。
表面上看上去没什么区别，实际上日方的思考方式更倾向于为机器着想，【2的补数】本质便是补码，拥有所有补码的特征和细节，拥有符号位，能够表现正负，被机器识别。（或者说所有负数均依赖于【2的补数】来表示，正常的序列没有这样的功能。）
从根本上来讲是有没有符号位的区别，但不同阶段并没有沿用同一套制度，简而言之就是一会有一会没。
对于机器来说，负数的减法操作转化成了加法操作，对于人来说，可以不用想那么多有的没的。
这里只是稍微介绍下二者的细微差别，实际上都同根同源。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2f340d76e5fd0907e96376f27bc4270/" rel="bookmark">
			vue出现的错误：uncaught typeerror cannot read property contains of null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue如果出现错误：uncaught typeerror cannot read property contains of null，
检查一下body标签的规范。不要乱套
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8293caae5fb40dddf547ecdd89fba9b2/" rel="bookmark">
			误删环境变量Path解决方式汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：不要重启电脑，电脑系统：Windows10
一、问题重述 起因是我在添加环境变量时报错：
于是使用了 rapidee 工具来添加环境变量[3]。
但是打开后并没有找到Path（截图时我已解决该问题）：
但是习惯性的按了保存，然后直接退出了，之后发现环境变量中的path不见了。
二、问题解决 因为rapidee相当于是直接修改注册表了，所以方法2对我没用。
本来找了同学问了对方的Path路径准备先加上去改一下应付应付，但是突然发现之前因为在配置东西，所以打开了cmd没关，而cmd可直接输出环境变量路径查看。
以后记得善用备份功能，在rapidee中直接备份即可：
1. cmd 如果在误删path之前打开了cmd且没关，则该cmd中依然存在之前的环境。在cmd中输入：
echo $Path$ 可输出环境变量，复制后重新添加即可：
2. 注册表恢复[1] 在没有重启电脑的情况下，注册表中可能包含有之前的环境变量。
win+R，打开 regedit ：
进入 “计算机\HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment” 路径：
如果在 OS 下面有 Path，则可以直接复制，重新添加环境变量：
3. 还原点还原[2] 如果电脑之前保存过还原点，可以使用该方法。但是要衡量一下是添加环境变量麻烦还是重新执行电脑这段时间执行过的操作麻烦。
右键电脑，“属性” --&gt; "高级系统设置" --&gt; “系统保护” --&gt; “系统还原”：
4. 重新添加环境变量 如果以上方法均不成功，则只能重新添加Path。Windows10的初始Path值如下：
C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\; 如果平时有写博客或者截图的习惯，可以找一下是否截取过电脑上环境变量的截图。
其余环境变量只能等到碰到出错的时候再一步步查找位置，重新添加了。
参考文档 [1] 环境变量path误删了如何恢复？
[2] path环境变量 还原
[3] Windows修改环境变量的工具—Rapid Environment Editor
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6273b7e1575f86f15feba8992909af2e/" rel="bookmark">
			Android的基本组件（四大组件）——Android初探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android应用通常由一个或者多个基本组件组成。Android应用常用的组件包括Activity、Service、BroadcastReceiver、ContentProvider等组件。下面将对他们进行进行较为简单的介绍。
1、Activity与View 之所以将Activity与View一起介绍，是因为我们初学时有时可能会将二者混淆。Activity是Android应用中负责与用户交互的组件，View组件是所有UI空间、容器控件的基类，View组件就是Android应用中实实在在看到得到部分。Activity只能通过setContentView（View）来显示指定组件，View组件需要放到容器组建中或者使用Activity将它显示出来。
如需要通过某个Activity把指定View显示出来，调用Activity中的setContentView() 方法即可，同时setContentView() 方法也可以接受一个布局管理资源的ID作为参数进行显示，例如下面的setContentView(R.layout.activity_main)。
public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } } 实际上Activity就是Window的容器，Activity包含一个getWindow()方法，该方法返回该activity包含的窗口。如果Android应用不调用Activity中的setContentView() 来设置该窗口的显示内容，则该程序将会显示一个空窗口。
Activity为Android提供了可视化用户界面，如果该Android应用需要多个用户界面，则Android应用将可能会包含多个Activity，多个Activity组成Activity栈，当前活动的Activity位于栈顶。
Activity包含一个setTheme(int resid) 方法来设置其窗口风格（即主题）。例如我们希望窗口不显示ActionBar、以对话框形式显示窗口，都可以通过该方法实现。
2、Service Service与Activity的地位是并列的，也是一个单独的组件，Service的区别在与它通常位于后台运行，一般不需要与用户交互，因此它没有图形界面。
与Activity组件需要继承Activity基类相似，Service组件需要继承Service的基类。一个Service运行起来后，它将拥有独立的声明周期，service组件通常用于为其他组件提供后台服务或者监控其他组件的运行状态。
3、BroadcastReceiver BroadcastReceiver代表广播接收器，从代码实现角度看，它非常类似于事件编程中的监听器。与普通事件监听器不同点在于，普通事件监听器监听的事件是源于程序中的对象，而BroadcastReceiver监听的事件源是Android应用中的其他组件，相当于一个全局的事件监听器。
使用BroadcastReceiver较为简单，只需要实现自己的BroadcastReceiver子类，并重写onReceive(Context context, Intent intent)方法即可。通常由两种方式对BroadcastReceiver进行注册：
在Java代码或者Kotlin中通过Context.registReceiver() 方法注册BroadcastReceiver在AndroidManifest.xml中使用&lt;receiver ... /&gt;方法注册 当其他组件通过sendBroadcast()、sendStickyBroadcast()或sendOrderedBroadcast()方法发送广播时，如果该BroadcastReceiver接收到“订阅”的intent，则onReceive(Context context, Intent intent)就会被触发。
4、ContentProvider ContentProvider是Android系统中为多个应用程序之间（跨应用）的数据交换提供的一个标准。
当用户实现自己的ContentProvider时，需要实现如下抽象方法：即“增删改查”
insert(Uri , ContentValues): 向ContentProvider插入数据delete(Uri , ContentValues): 删除ContentProvider中指定的数据update(Uri , ContentValues , String , String[]): 更新ContentProvider中指定的数据query(Uri , String[] , String , String[] , String): 从ContentProvider查询数据 通常与ContentProvider结合使用的是ContentResolver，一个应用程序使用ContentProvider暴露自己的数据，而另一个应用程序则通过ContentResolver来访问数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6273b7e1575f86f15feba8992909af2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00318eb5e2c1558e40e4fba4421a5a5c/" rel="bookmark">
			中文版Latex常用语法大全教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中文版Latex常用语法大全教程 Latex语法格式中文版的“hello world”注释换行、分段、分页文字的粗体、斜体、颜色、大小下划线、双下划线、波浪线、删除线、斜删除线Latex文档层次结构Latex层次Latex封面Latex目录Latex摘要Latex关键字Latex引用Latex脚注Latex数学公式Latex数学图形Latex插入图片Latex插入表格Latex插入代码Latex文字加边框Latex段落文字加边框latex分栏Latex段落Latex空白字符Latex页面配置Latex页眉页脚Latex手写参考文献Latex使用BibTeX生成参考文献列表 小结参考资料 Latex是一个基于Tex的文章，期刊，书籍的排版系统，可让使用者在极短的时间内写出很高排版质量的文档。
对于没有接触过Latex的同学来说，这种以代码形式进行文档书写的方式，会让人一头雾水，摸不到南北。
下面我以本人的视角来梳理《中文版Latex常用语法大全教程》，请大家一定要先浏览本文目录，目录一般呈现的都是文章大纲，对理解文章很有帮助。
不建议大家一开始就从头看到尾，而是在写作的过程中用到了那个知识点就去看那一点，这样更有助于学习。若是零基础的同学，我会再出一版《Latex快速入门》，请持续关注哦。
不过在开始本文前，需要各位同学配好自己的环境，我的环境配置，请参考我的另一篇文章《ubuntu20.04下vim+vimtex编写latex的利器》，本文的所有演示用例，都是基于该环境实现的。
数学用的平面几何图形绘制，请参考我的另外文章
《Latex-TiKZ绘制数学平面几何图教程》《Latex-pgfplots绘制3维曲线图》 Latex语法格式 在开始本文之前，请先熟悉下，Latex的行文结构，这也是最基本的，作为一个程序员来说，每开始一个新的编程语言学习时，都要先了解该程序语言的结构，那样才能快速编程。
\documentclass[options]{class} \begin{document} % 录入正文内容 \end{document} 参数
options 定制文档类的属性，不同的选项之间须用逗号隔开。clsss 指定文档类型，如：book、report、article、letter等。 注意： 本文所有的教程都是基于 中文环境 的Latex文档编写。
Latex的中文环境配置请参考我的另一篇文章《ubuntu20.04下vim+vimtex编写latex的利器》。
中文版的“hello world” 让我们来创建第一个文档，中文版的“hello world”，使用 vim 编写 test.tex 文档，录入如下代码
%! Tex program = xelatex \documentclass{article} \usepackage[UTF8]{ctex} \begin{document} hello 中国 \end{document} 编好后，在vim的命令行模式下，按 “\ll” 进行编译并预览，每次更改代码并重新保存后，都会实时更新预览界面。如下图：
是不是很简单啊，让我们期待在本文的帮助下，畅游Latex文档编写的世界吧。
注释 Latex也如 C语言等编程语言一样，也有单行和多行注释
单行，以%开头的行，是单行注释多行，（不要忘记添加多行注释用的包， \usepackage{verbatim} ） \begin{comment}多行注释内容\end{comment} 示例
%! Tex program = xelatex \documentclass{article} \usepackage[UTF8]{ctex} \usepackage{verbatim} \begin{document} %单行注释 hello 中国 \begin{comment} 这是一个注释行 这又是一行注释 hehe \end{comment} \end{document} 换行、分段、分页 换行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00318eb5e2c1558e40e4fba4421a5a5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f074bd9c429b6c061b2608a455c3aef/" rel="bookmark">
			全连接层详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：本系列博客在于汇总CSDN的精华帖，类似自用笔记，不做学习交流，方便以后的复习回顾，博文中的引用都注明出处，并点赞收藏原博主
1、什么是全连接层： 全连接层（fully connected layers，FC）在整个卷积神经网络中起到“分类器”的作用。如果说卷积层、池化层和激活函数等操作是将原始数据映射到隐层特征空间的话，全连接层则起到将学到的“分布式特征表示”（下面会讲到这个分布式特征）映射到样本标记空间的作用。在实际使用中，全连接层可由卷积操作实现：
对前层是全连接的全连接层可以转化为卷积核为1x1的卷积；而前层是卷积层的全连接层可以转化为卷积核为hw的全局卷积，hw分别为前层卷积结果的高和宽。
全连接的核心操作就是矩阵向量乘积 y = Wx
转载于：https://blog.csdn.net/qq_39521554/article/details/81385159
2、怎么理解全连接层： 假设你是一只小蚂蚁，你的任务是找小面包。你的视野还比较窄，只能看到很小一片区域。当你找到一片小面包之后，你不知道你找到的是不是全部的小面包，所以你们全部的蚂蚁开了个会，把所有的小面包都拿出来分享了。全连接层就是这个蚂蚁大会~
3、进一步理解⭐⭐⭐ 以下内容转载于：https://blog.csdn.net/m0_37407756/article/details/80904580
例如经过卷积，relu后得到3x3x5的输出。
那它是怎么样把3x3x5的输出，转换成1x4096的形式？
很简单,可以理解为在中间做了一个卷积。
从上图我们可以看出，我们用一个3x3x5的filter 去卷积激活函数的输出，得到的结果就是一个fully connected layer 的一个神经元的输出，这个输出就是一个值。因为我们有4096个神经元。我们实际就是用一个3x3x5x4096的卷积层去卷积激活函数的输出。
举个简单的例子：
从上图我们可以看出，猫在不同的位置，输出的feature值相同，但是位置不同。
对于电脑来说，特征值相同，但是特征值位置不同，那分类结果也可能不一样。
这时全连接层filter的作用就相当于
喵在哪我不管，我只要喵，于是我让filter去把这个喵找到，
实际就是把feature map 整合成一个值，这个值大，有喵，这个值小，那就可能没喵
和这个喵在哪关系不大了，鲁棒性有大大增强。
因为空间结构特性被忽略了，所以全连接层不适合用于在方位上找Pattern的任务，比如segmentation。
全连接层中一层的一个神经元就可以看成一个多项式（类似加权平均），我们用许多神经元去拟合数据分布
但是！！！只用一层fully connected layer 有时候没法解决非线性问题，
而如果有两层或以上fully connected layer就可以很好地解决非线性问题了
4、全连接层的作用： 通过特征提取，实现分类
我们现在的任务是去区别一图片是不是猫
假设这个神经网络模型已经训练完了，全连接层已经知道
当我们得到以上特征，我就可以判断这个东东是猫了。
因为全连接层的作用主要就是实现分类（Classification）
红色的神经元表示这个特征被找到了（激活了）
同一层的其他神经元，要么猫的特征不明显，要么没找到
当我们把这些找到的特征组合在一起，发现最符合要求的是猫
ok，我认为这是猫了
这细节特征又是怎么来的？
就是从前面的卷积层，下采样层来的
5、全连接层的注意层面： 全连接层参数特多（可占整个网络参数80%左右）
那么全连接层对模型影响参数就是三个：
1，全接解层的总层数（长度）
2，单个全连接层的神经元数（宽度）
3，激活函数
首先我们要明白激活函数的作用是：增加模型的非线性表达能力
6、torch代码小结 以下设置了三个全连接层，大家留意每一层的filter
import torch.nn as nn import torch.nn.functional as F class Net(nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f074bd9c429b6c061b2608a455c3aef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/078b7994198d25c8e9cd7a8fbf469e7d/" rel="bookmark">
			【笔记】uni-app小程序退出当前小程序/app
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 退出当前小程序：
&lt;navigator open-type="exit" target="miniProgram"&gt;退出程序&lt;/navigator&gt; 小程序由app拉起，点击按钮退回app
&lt;button open-type="launchApp" app-parameter="wechat" binderror="launchAppError"&gt;退出程序&lt;/button&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c414a87539d7ada51fcb6fb28110bd7/" rel="bookmark">
			Proxmox VE容器安装Pi-Hole方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 *本文原创，是作者亲身实践写成，非网上复制粘贴版本。
先说下为什么要容器安装，因为容器提供轻量级的虚拟化，占用系统资源少，速度快。
一. Pi-Hole简介 相信大家已经对Pi-Hole都有耳闻了，这里再简单介绍下。Pi-Hole是一个开源免费的DNS服务器构建软件，它的特殊之处就是对于广告地址的DNS进行解析屏蔽，所以客户端电脑/手机/平板等不用安装任何软件，只要把本机的DNS解析服务指向Pi-Hole服务器地址即可，适用于任何操作系统。可简略的认为是广告屏蔽DNS服务器。
二. 安装过程 下载LXC容器模板Debian10，方法不再赘述。
根据LXC容器模板创建CT，CT启动后为了方便远程管理安装软件等，我们需要启用root远程SSH登陆服务器功能。
Debian系统一般默认不允许root进行ssh登录，或者默认都没有安装ssh服务。
a. 安装ssh-service
apt install ssh
b. 修改配置文件
vi /etc/ssh/sshd_config
c. 光标移到文档末尾按下o键添加一行，输入如下字符，然后按下Esc键，按下：（冒号）输入wq命令保存并退出
PermitRootLogin yes
d. 重启服务
systemctl restart ssh安装curl命令支持
apt-get install curl
如果运行此命令失败，用apt update命令更新下程序数据库。安装Pi-Hole
curl -sSL https://install.pi-hole.net | bash如果出现如下提示，表明GitHub的raw.githubusercontent.com域名解析被污染了。
可通过修改hosts解决此问题。
查询真实IP，在https://www.ipaddress.com/查询raw.githubusercontent.com的真实IP。
修改hosts
vi /etc/hosts
添加如下内容：
199.232.68.133 raw.githubusercontent.com重新执行Pi-Hole安装命令
curl -sSL https://install.pi-hole.net | bash
出现如下画面就表示可以正常安装。途中跳出的图形界面选取默认值即可，如果需要光标跳转记得使用“Tab”键。
安装完成后出现如下画面：
上面的Web Interface password非常难记，所以我们要修改密码，用如下命令
pihole -a -p用浏览器登录如上图片提示的服务器web管理页面（http://192.168.137.2/admin），login刚才修改过的密码，点开Tools→Update Gravity菜单更新过滤列表，最后可以看到如下更新成功的提示。
至此Pi-Hole安装全部结束。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dce4f5ca7d1c90a5a103deeebd11b518/" rel="bookmark">
			spring cloud Zuul聚合Swagger2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zuul整合Swagger2 结构图：
先贴代码 1、聚合工程的父工程pom依赖 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.alsb&lt;/groupId&gt; &lt;artifactId&gt;zuul-swagger2&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;gateway&lt;/module&gt; &lt;module&gt;registry&lt;/module&gt; &lt;module&gt;user&lt;/module&gt; &lt;module&gt;region&lt;/module&gt; &lt;/modules&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-cloud.version&gt;Greenwich.RELEASE&lt;/spring-cloud.version&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mapper.starter.version&gt;2.1.5&lt;/mapper.starter.version&gt; &lt;springfox-swagger2.version&gt;2.9.2&lt;/springfox-swagger2.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- springCloud --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${mapper.starter.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;${springfox-swagger2.version}&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;io.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dce4f5ca7d1c90a5a103deeebd11b518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ee2cd1a09e2e49bfca402a9dc817f49/" rel="bookmark">
			rk3288buildroot添加移远4G模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rk3288buildroot 系统搞的人比较少，最初调试一脸蒙蔽，不知如何下手，搞了几天，百度谷歌无数，最终搞定。其实也没那么麻烦，只要方法得当，写此博文只做记录吧！
整个调试分为两部分，一部分是kernel部分添加，主要是打开一些配置宏。另一部分是系统层配置，我使用的是pppd，当然还有其他方式，我没有尝试了。
1，修改kenel配置：
修改 drivers/usb/serial/usb_wwan.c 文件，如下红色部分
static struct urb *usb_wwan_setup_urb(struct usb_serial_port *port,
int endpoint,
int dir, void *ctx, char *buf, int len,
void (*callback) (struct urb *))
{
if(dir == USB_DIR_OUT) {
struct usb_device_descriptor *desc = &amp;serial-&gt;dev-&gt;descriptor;
If((desc-&gt;idVendor == cpu_to_le16(0x2c7c) &amp;&amp; desc-&gt;idProduct
== cpu_to_le16(0x0125)))
{
urb-&gt;transfer_flags |= URB_ZERO_PACKET;
}
}
return urb;
}
Setp5: Add VID add PID
drivers/usb/serial/option.c 添加红色部分
static const struct usb_device_id option_ids[] = {
{ USB_DEVICE(0x1286, 0x4e3d) },
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ee2cd1a09e2e49bfca402a9dc817f49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59e8f7f085e6b1ad7e99a04c98d2e8b1/" rel="bookmark">
			计算机行业实习生第一天上班应该做些什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大学的期间的实习现在已经是越来越普及了，尤其是在严重的就压压力下，加上由于各种因素的影响互联网行业本来就不怎么景气，所以很多的用人单位在招人的时候实习经历了就成了硬性的条件了。但是很多初来乍到的同学可能对于实习充满恐惧，也不知道第一天上班应该干些什么，今天我以我的实际经历写一写吧！
好了，废话不多说，我们来聊正事吧！
1.找到公司的地点，联系招聘管理 一般的公司不论是实习生还是正式员工，流程一般都是上午办理入职手续，下午去对应的部门上班。第一天实习的员工一般要自己先找到公司，然后在前台询问工作人员，看招聘你的管理的办公位置在哪，找到对应的负责人说明情况之后，她会确认你的身份（一般办理入职手续之后在她那边会显示你的信息）。
2.带你认识你的上司 核实身份结束，负责人会带你去见对应的开发小组的组长（这里是组长，不是部门的部长或者管理人员，因为人家压根可能没空搭理你），见过小组长（一般是具有三到五年开发经验的老手）之后，相互认识之后组长会安排你上班的位子，并且简单的告诉你关于部门的，关于公司的一些管理规章制度（这里你最好是静静的听着，不要老是问这问那，自己有问题的私下再问别人），介绍完之后他会给你找一个手把手带你的师父，一般是在公司待了一两年的开发人员，让他帮助你搭建环境，给你分配任务。
3.开始完成手头的任务 在公司认清自己的上司和对应的带你的师父之后，一般带你的师父会给你一些配置开发环境锁需要的资源和一些项目的文件夹。你需要在电脑上配置相应的环境，尝试把师父所给的项目在本地跑一跑。一般刚去的实习生不会立马安排你做东西，都是先看看项目代码，熟悉开发环境。趁着这个时候就好多学习，多看。
想给大家强调一点的就是，在这个装环境，看代码的过程中一定要多问，多想，有些不会的东西自己在网上搜不到答案，就不要一直卡在那里不动，一定要学会主动问，一方面是别人来的就会的比你多，帮助你的话比你在网上苦苦需求答案要快的多，另一方面你要体现出你好学的态度，基础不重要，重要的是来了肯学肯干的态度。
一般开发部门的实习生的第一天就是这样的，我只是针对于我个人的经历和大家谈一谈，具体的公司的流程可能有所不同，大家也就随便看看，消遣消遣。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7cddf2bb9fd7b13404fc4f8950db32c/" rel="bookmark">
			MySQL常见注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 避免使用 select * 你需要什么信息,就查询什么信息,查询的多了,查询的速度肯定就会慢
2. 当你只需要查询出一条数据的时候,要使用 limit 1 比如你要查询数据中是否有男生,只要查询一条含有男生的记录就行了,后面不需要再查了,使用Limit 1 可以在找到一条数据后停止搜索
3. 建立高性能的索引 索引不是随便加的也不是索引越多越好,更不是所有索引对查询都有效
4. 建数据库表时,给字段设置固定合适的大小. 字段不能设置的太大,设置太大就造成浪费,会使查询速度变慢
5. 要尽量使用not null 6. EXPLAIN 你的 SELECT 查询 使用EXPLAIN,可以帮助你更了解MySQL是如何处理你的sql语句的, 你可以查看到sql的执行计划,这样你就能更好的去了解你的sql语句的不足,然后优化语句.
7. 在Join表的时候,被用来Join的字段，应该是相同的类型的,且字段应该是被建过索引的,这样，MySQL内部会启动为你优化Join的SQL语句的机制。 8. 如果你有一个字段，比如“性别”，“国家”，“民族”, “省份”，“状态”或“部门”，这些字段的取值是有限而且固定的，那么，应该使用 ENUM 而不是 VARCHAR。 因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。
9. 垂直分割 将常用和有关系的字段放在相同的表中，把一张表的数据分成几张表 这样可以降低表的复杂度和字段的数目，从而达到优化的目的
10. 优化where查询
①. 避免在where子句中对字段进行表达式操作
比如： select 列 from 表 where age*2=36; 建议改成 select 列 from 表 where age=36/2;
②. 应尽量避免在 where 子句中使用 !=或&lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。
③. 应尽量避免在 where 子句中对字段进行 null 值 判断
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7cddf2bb9fd7b13404fc4f8950db32c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b31d94089f2ec393f4ad71a6533d9141/" rel="bookmark">
			数学建模——人口增长模型的matlab实现以及对2010年人口预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 运行软件：MATLAB R2012a实验数据指数增长模型指数增长模型：方法一对2010年的人口预测 指数增长模型：方法二对2010年人口预测 改进的指数增长模型对2010人口预测 逻辑斯蒂(logistic)模型逻辑斯蒂(logistic)模型：方法一对2010预测 逻辑斯蒂(logistic)模型：方法二对2010预测 运行软件：MATLAB R2012a 实验数据 年份17901800181018201830184018501860人口/百万3.95.37.29.612.917.123.231.4增长率/10年0.29490.31130.29860.29690.29070.30120.30820.2452 年份18701880189019001910192019301940人口/百万38.650.262.976.092.0105.7122.8131.7增长率/10年0.24350.24200.20510.19140.16140.14570.10590.1059 年份1950196019701980199020002010人口/百万150.7179.3203.2226.5248.7281.4308.7增长率/10年0.15790.14640.11610.10040.11040.1349 指数增长模型 满足人口增长的微分方程和初始条件为：
利用函数dsolve()可得：
指数增长模型：方法一 根据已知数据对模型的参数进行估计又称为数据拟合。
对下面的这个公式同时取对数
可得
t：代表年份1970取0，依次类推
x：人口数量，实验数据已知
根据求出的公式可以求出y；然后利用polyfit()函数求出r，a的值；当a求出来时，根据上面求出的公式，可以求出x0；将r，x0带入公式
可求出指数增长模型方法一的x值
代码如下：
使用的是matlb函数
function [ x1 ] = method_1( x ) %方法一：直接用人口数据和线性最小二乘法 % 利用函数polyfit（），dsolve()求解，r年增长率,返回x1模型的估计值 y=log(x); t=0:1:21; p=polyfit(t,y,1); r=p(1); a=p(2); x0=exp(a); s=dsolve('Dx=r*x','x(0)=x0','t'); x1=eval(s); x1=x1'; end 运行代码：
x=[3.9	5.3	7.2	9.6	12.9	17.1	23.2	31.4	38.6	50.2	62.9	76	92	105.7	122.8	131.7	150.7	179.3	203.2	226.5	248.7	281.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b31d94089f2ec393f4ad71a6533d9141/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6212d0b4d5ae62f4b20d2b991302e865/" rel="bookmark">
			VS Code使用虚拟环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开vs code，File--&gt;Perference--&gt;Setting，搜索Python.Venv Path，将其设置为你的虚拟环境所在的目录。例如：D:\software\Anconnda3\envs\TG36
2、View--&gt;Command Palette,进入命令面板，输入 Python: Select Interpreter，可以看到有虚拟环境目录下的python.exe，选择你需要使用的环境的目录，这样就能在VS Code中按虚拟环境的配置进行调试了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92f7357250a6a2937d97d4f1eb577bec/" rel="bookmark">
			Hausdorff 距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hausdorff 距离是描述两组点集之间相似程度的一种量度；
假设有两组集合：，；
则这两个点集之间的单向 Hausdorff 距离：
其中，||a-b|| 表示 a 与 b 之间的欧氏距离，h(A,B) 也叫前向 Hausdorff 距离，h(B,A) 也叫后向 Hausdorff 距离;
h(A,B) 的理解：先在集合 B 中取距离集合 A 最近的点 ，然后计算集合 A 中的每个点 与 之间的距离，并将距离进行排序，然后取距离最大的值作为 h(A,B) 的值。（若 h(A,B)=d，表示 A 中所有点到 B 集合的距离不超过 d）
双向 Hausdorff 距离：
双向 Hausdorff 距离取单向 Hausdorff 距离中的最大值，度量了两个点集间的不相似程度（双向 Hausdorff 距离越小，匹配程度越高）；
但是，在图像存在噪声污染或遮挡等情况时，上述的 Hausdorff 距离很容易造成误匹配，如下图：
B 集合中距离 A 集合最近的点 bj，A集合中距离 bj 最远的点是 a2，但是由于存在噪声，Hausdorff 距离并没有取 a2 与 bj 之间的距离，而是噪声与 bj 之间的距离，导致错误。
为了解决这一问题，Huttenlocher 提出了部分 Hausdorff 距离；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92f7357250a6a2937d97d4f1eb577bec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69bc7e04b39be95bd71eb7e0f32d47af/" rel="bookmark">
			ExcelVBA 之Static 变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		静态变量（static）
除了范围之外，变量还有存活期，变量的存活期决定了该变量能保存它的值有多久。一旦该工程打开，模块级别和工程级别的变量就会保留它们的值。然而，如果程序的逻辑需要，VB能够重新初始化这些变量。使用Dim语句声明的当地变量当过程结束时就会丢失值，当地变量的存活期是随着过程的运行的，并且它们在程序每次运行的时候可以被重新初始化。VB允许你通过改变声明方式延长当地变量的存活期。
用Static关键字声明的变量是特殊的当地变量，静态变量在过程级别声明。和那些用关键字Dim声明的当地变量相反，静态变量在程序已经不在它们的过程里时仍然不会丢失它们的内容。例如，当一个带有静态变量的VBA过程调用另外一个过程时，在VB执行完被调用的过程语句后返回主调过程时，静态变量仍然保留它原来的值。过程CostOfPurchase示范静态变量allPurchase的使用：
Sub CostOfPurchase() 'declare variables Static allPurchase Dim newPurchase As String Dim purchCost As Single newPurchase = InputBox("Enter the cost of a purchase:") purchCost = CSng(newPurchase) allPurchase = allPurchase + purchCost 'display results MsgBox "The cost of a new purchase is: " &amp; newPurchase MsgBox "The running cost is: " &amp; allPurchase End Sub 上面的过程以一个名为allPurchase的静态变量和两个当地变量newPurchase和purchCost的声明开始。该过程中使用的InputBox函数显示一个对话框并且等着用户输入数值，一旦用户输入数值并且点击确定后，VB就会将该数值赋给变量newPurchase。因为InputBox函数的结果总是字符串，变量newOurchase被声明为字符串数据类型了。然而，你不能在数学计算中使用字符串，这就需要在下一指令中使用一个类型转换函数（CSng）来将字符串值转换为单精度浮点类型的数字。函数CSng只需要一个自变量——你要转换的数值。函数CSng转换的数字结果保存在变量purchCost上。
技巧：类型转换函数
在CSng上的任意地方按下F1，可以查看更多关于函数CSng的信息（也可以查看其它类型转换函数信息）下一行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2edb2e85c1381a89f4831582e26af39e/" rel="bookmark">
			bcel Unable to process Jar entry
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动Tomcat 8/9报错：org.apache.tomcat.util.bcel.classfile.ClassFormatException: It is not a Java .class file
Jun 03, 2020 3:53:33 PM org.apache.catalina.startup.ContextConfig processAnnotationsJar SEVERE: Unable to process Jar entry [FmsBlendingServiceImpl.class] from Jar [file:/D:/works/sts_space2/.metadata/.plugins/org.eclipse.wst.server.core/tmp1/wtpwebapps/b2b-file/WEB-INF/lib/isp-acp-1.1.0-RELEASE.jar] for annotations org.apache.tomcat.util.bcel.classfile.ClassFormatException: It is not a Java .class file 网上搜了一圈，没有有效的办法，然后去对应的jar文件里面查看那个FmsBlendingServiceImpl类。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cea37b9aaa49f2ed31379969726b47e2/" rel="bookmark">
			Verilog中$finish和$stop的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.$finish的用法 当程序中出现$finish,当仿真到该语句时，会提示要不要退出仿真。如果选是，则仿真结束，退出仿真窗口。
2.stop的用法 2.1 遇到stop暂停 在仿真程序中，我们看到存在一个$stop语句；
此时我们开始仿真，正产仿真时间是1000ns：
但是仿真到$stop语句时，突然出现了暂停；
并且波形仿真时间也到250ns暂停了：
2.2 继续仿真 1）. 此时不要急躁，点击继续仿真icon；
2）. 吃屎tcl窗口出现了继续仿真命令 run -continue：
3）. 然后剩余的750ns得以继续仿真，整个仿真时间也就是1000ns：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd7c339b4378f0170380fbcf1a6bfe41/" rel="bookmark">
			date_histogram的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.标准写法在kibana中
2.date_histogram支持了日期的表达式
3.时间返回结果格式化
4.time_zone时区的用法
5，offset 使用偏移值，改变时间区间
6.Missing Value缺省字段
7.其他
8.代码实现
https://blog.csdn.net/opera95/article/details/78614244
date_histogram （和 histogram 一样）默认只会返回文档数目非零的 buckets。
1.标准写法在kibana中 GET /cars/transactions/_search { "size" : 0, "aggs": { "sales": { "date_histogram": { "field": "sold", "interval": "month", "format": "yyyy-MM-dd", "min_doc_count" : 0, //这个参数强制返回空 buckets。 "extended_bounds" : { //这个参数强制返回整年 "min" : "2014-01-01", "max" : "2014-12-31" } } } } } 2.date_histogram支持了日期的表达式 的用法与histogram差不多，只不过区间上支持了日期的表达式。
interval字段支持多种关键字：`year`, `quarter`, `month`, `week`, `day`, `hour`, `minute`, `second`
{ "aggs":{ "articles_over_time":{ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd7c339b4378f0170380fbcf1a6bfe41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dbc80b88ffae2993893e15b6a3e2c91/" rel="bookmark">
			Qt5 获取多屏幕分辨率以及屏幕缩放比例DPI适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在开发qt相关,将需要的东西记录下来,可以给后来的开发人员做参考,同时也是给自己做一个备忘,有什么问题大家可以多多交流.
1、获取多个显示器屏幕分辨率
#include &lt;QScreen&gt; #include &lt;QGuiApplication&gt; #include &lt;QList&gt; // 获取多显示器,通过list存储当前主机所有显示器 QList&lt;QScreen *&gt; list_screen = QGuiApplication::screens(); // 通过循环可以遍历每个显示器 for (int i = 0; i &lt; list_screen.size(); i++) { QRect rect = list_screen.at(i)-&gt;geometry(); int desktop_width = rect.width(); int desktop_height = rect.height(); // 打印屏幕分辨率 qDebug() &lt;&lt; desktop_width &lt;&lt;desktop_height; } 2、获取主屏幕的缩放比例
// 除以96之后即可转换成dpi的数值,以2k屏幕为例,Windows默认dpi是125%,这里的值就是:1.25 double dpi = QGuiApplication::primaryScreen()-&gt;logicalDotsPerInch() / 96; 3、获取窗口所在屏幕的缩放比例
double dpi = this-&gt;screen()-&gt;logicalDotsPerInch() / 96; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4798a2d566fb62a5f25b25dc677b9ef5/" rel="bookmark">
			OpenCv中图像PSNR和SSIM的计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCv中图像PSNR和SSIM的计算，最近写论文要用到，mark一下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3db48ddb4911111f9b178cf25bd98310/" rel="bookmark">
			VNC 修改默认端口号5900&#43;为15900&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vnc的默认端口是5901，这个说法是不对的。vnc并不是只有一个端口。
以前另一个文章介绍了nvcserver的配置用户的过程，里面提到了桌面号，这个桌面号就可以端口有密切关系
先看看这个配置
VNCSERVERS="1:oracle 2:root"
VNCSERVERARGS[1]="-geometry 800x600 -nolisten tcp -nohttpd"
......
这里是摘自/etc/sysconfig/vncservers里的一段。 这里就配置了2个桌面，一个桌面号是1， 一个是2.
vncserver在调用的时候，会根据你的配置来启用server端的监听端口， 从5900开始，加上你的桌面号，比如这里的哦oracle就是5901，root就是5902
所以通过这里的桌面号也是可以达到我们的目的的,根据你的目标端口来设定用户的周面好，虽然可以解决，但是总是感觉有些没有拉干净的感觉，这不是 这次的研究内容，还是找个痛快的方式吧。
这次的研究主要就是颠覆这样的默认规则，直接的深入进去，我要直接修改5900+为15900+
在网上没有找到比较好的方法和文档，自己动手吧
从vncserver这个启动命令开始吧，
[root@redflag1 ~]# which vncserver
/usr/bin/vncserver
[root@redflag1 ~]# file /usr/bin/vncserver
/usr/bin/vncserver: a perl script text executable
[root@redflag1 ~]# grep "59" /usr/bin/vncserver -n
18:# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
118:$vncPort = 5900 + $displayNumber;
238:# n is taken if something is listening on the VNC server port (5900+n) or the
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3db48ddb4911111f9b178cf25bd98310/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/366b2387f819ac8c563614bf5fa8984e/" rel="bookmark">
			【vue&#43;element-ui】获取el-table-column中一条记录的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用插槽：
&lt;el-table-column label="状态"&gt; &lt;!-- 作用域插槽 --&gt; &lt;template v-slot:="scope"&gt;{{scope}}&lt;/template&gt; &lt;/el-table-column&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3963441eab9eae30a80d577df1a29ee2/" rel="bookmark">
			集成学习分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础集成技术
最大投票（Max Voting）法
平均（Averaging）法
加权平均（Weighted Average）法
高级集成技术
堆叠（Stacking）
混合（Blending）
Bagging
提升（Boosting）
基于Bagging和Boosting的算法
Bagging meta-estimator
随机森林
AdaBoost
GBM
XGB
Light GBM
CatBoost
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf9bbf5a5de856e7b7a9d15627e0c57a/" rel="bookmark">
			从零开始学习音视频编程技术（35） Linux搭建Qt5.13和ffmpeg4.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下Qt5.13引用ffmpeg4.2
Qt历史版本下载：http://download.qt.io/archive/qt/
运行Qt需要安装的库：
sudo apt-get install gcc g++ make
sudo apt-get install libgl1-mesa-dev
编译ffmpeg命令如下：
1.安装yasm:
wget http://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz
tar xvzf yasm-1.3.0.tar.gz
cd yasm-1.3.0
./configure
make &amp;&amp; make install
2.安装nasm(2.13以上版本)
wget https://www.nasm.us/pub/nasm/releasebuilds/2.14.02/nasm-2.14.02.tar.bz2
tar xvf nasm-2.14.02.tar.bz2
cd nasm-2.14.02
./configure
make &amp;&amp; make install
3.安装其他依赖
apt install cmake -y
4.编译x264(只编译静态库)
x264下载地址：
http://ftp.videolan.org/pub/videolan/x264/snapshots/
tar xvf x264-snapshot-20191024-2245-stable.tar.bz2
cd x264-snapshot-20191024-2245-stable
./configure --enable-static --prefix=../x264 --enable-pic make -j16
make install
5.编译x265(只编译静态库)
x265下载地址:
http://ftp.videolan.org/pub/videolan/x265/
tar xvf x265_3.2.tar.gz
cd x265_3.2/build/linux/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf9bbf5a5de856e7b7a9d15627e0c57a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baf831845c63717681dafa591a484530/" rel="bookmark">
			VMware虚拟机网络适配器NAT模式 Ubuntu18.0.4无法上网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 折腾了半天，最后发现是
VMware NAT Service 服务未打开
打开命令窗口：services.msc 找到 VMware NAT Service 服务，启动就行了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05c90b22870a080bcc20ff8f62e83b6b/" rel="bookmark">
			SVN出现Unable to connect to a repository at URL错误时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开TortoiseSVN点击右侧的Setting
2、点击Setting后打开一个页面点击页面左侧的Saved Data
3、点击右侧的Clear，清除历史以及我们保存过的URL
4、清理完URL，我们就可以进行重新输入SVN的URL
5、输入账户和密码即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52de59461a4b9ed76ea497a63afd15bb/" rel="bookmark">
			PBR材质：基本原理和简单制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要：介绍PBR材质的基本原理以及制作一个简单的PBR材质
参考资料：BASIC THEORY OF PHYSICALLY-BASED RENDERING
如有问题，多多指正。
侵删。
1.PBR是什么，光线的基本原理。 PBR即Physically-based rendering，基于物理的渲染。基于物理的渲染，即通过计算光线与物体表面的交互状态而实现模拟真实世界画面的一种渲染方式。通常用于影视特效，写实风格的游戏，工业领域。现实中的环境，肯定不止一种光源，而是有很多光源一起发生作用，光线互相交织在一起的。
光的组成包括：光源，颜色，亮度，衰减，强度，形状，以及无数的“线”。当光或者说光线打到物体上，可以发生两种反应，一种是折射，一种是反射。折射的光线会被吸收，或者被离散，而反射的光线则会继续进行反射作用。根据光的折射原理，光不是在物体的表面进行折射的，而是在第二表面，也就是进入物体第二表面之后，发生的折射效应，此时光线会被离散或吸收，吸收使得光的强度变小，而离散使得光的方向发生改变，强度则不会发生改变。而光在各种物体的表面，折射和反射的情况也是非常不同的，比如在粗糙的物体，物体的反射就会增多，光线经过多次漫反射，其光滑度就很低，比如毛衣，墙砖。
2.相关的几种基本概念和PBR材质的构成（以unity标准材质为例） DIFFUSION &amp; REFLECTION（扩散和反射） 反射：当光线打到物体表面时，一部分光线会被反射，在法线的相对侧根据某个角度进行反弹，就好像一个篮球打在墙上，会被反弹回去，这个概念比较好理解，从法线的一侧，然后碰到表面，在法线另一侧进行反弹。而在光滑的表面，通过反射，就容易得到一种镜像的效果，也就是像镜子一样，比如拖的很干净的地面，因为光滑，反射就容易出现“镜像”的效果。
扩散：当然，光打在物体上，不止会发生反射，还有发生别的反应。比如有一些光线进入了物体内部，被物体吸收或者是转换成了热量。而发生反射的，则通过多次反射进入你的眼睛或者是摄像头，然后被你看到，这就是我们常说的“漫反射”。我们把这种光称之为diffuse light（散射光）。对于不同波长的光，散射光（diffuse light）的吸收和散射通常会大不相同，所以对于一个对象，我们要给它颜色，或者说，每个物体，其实都是有颜色的。而散射光部分光线的反射并不是有规律的反射，而是随机或者说非常混乱的反射，这部分光在进行计算的时候，会给一个反射率，作为计算这个“部分”的多少或者说反射的多少。
TRANSLUCENCY（透明度） 透明度;这个比较好理解，但是因为某些物体的属性，比如蜡烛甚至是人的皮肤，光线的散射会更复杂。如果一个物体表面足够薄，光线可以穿过该物体，这个物体就是“半透明的”，光线会到达里面那一层，要处理这种效果，不能简单使用颜色，而是需要特殊的阴影系统。而另外一种，“全透明”物体，也就是如玻璃，光线可以穿到另一边，在这个物体里面几乎不会发生散射。
Metallic（金属） 金属：顾名思义，就是表现金属属性的一个参数。
Albedo（RGB）（反照率） Albedo英文原意是反照率，其实就是基础颜色或者贴图，在上文中我讲到，一个物体最基本的是会有颜色的，透明的物体物体，也是有颜色的，所以这个Albedo也就是基本的颜色（或贴图）。
Smoothness（光滑度） 表现物体的光滑度的一个参数，通常会与金属Metallic一起使用。
Normal Map(法线贴图) 法线贴图就是在原物体的凹凸表面的每个点上均作法线，通过RGB颜色通道来标记法线的方向，你可以把它理解成与原凹凸表面平行的另一个不同的表面，但实际上它又只是一个光滑的平面。对于视觉效果而言，它的效率比原有的凹凸表面更高，若在特定位置上应用光源，可以让细节程度较低的表面生成高细节程度的精确光照方向和反射效果。
简而言之，就是使用该帖图，可以使画面更有立体感，同时丰富更多的细节。
Height Map（高度贴图or视差贴图） 高度贴图是使用法线投影进行渲染时存储源对象相对高度的灰度贴图。
可以将高度贴图作为目标对象上置换贴图。这是向低分辨率对象的边缘添加细节的方式，因为边缘本身不受发现凹凸贴图的影响。高度贴图在某些时候可以纠正法线贴图制作凹凸感时的错误，使物体表面的细节更加真实。
Occlusion（遮挡剔除） 参考unity的官方文字：
The occlusion map is used to provide information about which areas of the model should receive high or low indirect lighting. Indirect lighting comes from ambient lighting and reflections, so steep concave parts of your model like a crack or a fold would not realistically receive much indirect light.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52de59461a4b9ed76ea497a63afd15bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7cc3abfd2b0ea1e135668e0b1751216/" rel="bookmark">
			用自家的网络搭建属于自己的服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每次在网上问：如何用自己家的的宽带搭建一个外网可访问的站点呢？就总是会收到一些诸如“别折腾自己的电脑啦，现在有个东西叫做云服务器”的回答，“生命不息，折腾不止”作为我的座右铭所以以上并不是我想要的答案。废话不多讲，上干货
由于本人是python程序员，所以以下部分代码为python实现
众所周知由于IPV4已用完，所以目前我们办理的宽带分配到的IP地址多数为各大运营商的内网IP。
第一步： 获取公网IP
我们要做的就是拨打运营商客服电话，告诉客服人员自己家里有小孩需要安装摄像头所以需要公网IP。业务受理后，恭喜你，你获得了一个动态的外网IP。下面代码可以查看自家的公网IP
import requests import re res = requests.get('https://www.ip.cn/').text regular = '((25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)\.){3}(25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)' my_ip = re.search(regular, res).group() print(my_ip) 第二步： 网站部署
无论使用Nginx还是Tomcat等部署网站都可以，但是监听端口需要设置为80和443以外的其他端口（家庭网络中这两个端口是不开放的）
此步骤不明白的可以百度教程
第三步： DMZ到内网IP
如果是电信光猫需要用管理员的用户名和密码，大家可以试一下
超级用户名：telecomadmin
超级密码：nE7jA%5m（注意大小写）
进入超管界面后找到DMZ功能，将服务器的内网IP填好后这台服务器就暴露到Internet了，外网可以通过第一步查到的IP+端口号访问自己的网站了。
第四步： 购买自己的域名
可以去阿里云购买一个自己的域名，然后解析A记录为www或其他值，ip对应到第一步的IP地址，这样就可以通过域名+端口号访问自己的网站了。由于每次断电IP地址会变化，如果想一劳永逸可以查看阿里api，当公网IP变化后可以调用api修改解析记录。
时间关系，以上大多数只写出了思路，有问题欢迎留言，后续有时间会附上实现方法和图片，有疑问欢迎留言
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e202891bdbd55ce7d77787f41ca0590d/" rel="bookmark">
			kettle与Hadoop整合------操作详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先下载hadoop集群得两个文件：core-site.xml hdfs-site.xml
两个文件地址：/export/servers/hadoop/etc/hadoop
下载命令：
sz core-site.xml
sz hdfs-site.xml
关于下载Linux下载文件到window中操作详解课参考：
https://blog.csdn.net/data_curd/article/details/106431302
下载完毕得Hadoop文件上传到kettle中得：
data-integration\plugins\pentaho-big-data-plugin\hadoop-configurations\cdh514
这个文件夹里面
文件上传完毕后，在data-integration\plugins\pentaho-big-data-plugin文件夹里面有
plugin.properties文件，打开编辑这个文件
在active.hadoop.configuration= 后面添加 cdh514
如下图所示：
以上操作完毕后，建议关闭kettle软件，重启一次
接下来直接上图：
业务需求：
输入：Hadoop
输出：Excel
**
在kettle中创建转换的快捷键：ctrl + n
在kettle中创建作业的快捷键：ctrl + alt + n**
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15c014be2e16de2c9962806f6215aac0/" rel="bookmark">
			arxiv无法访问打不开论文换中科院镜像源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		arxiv打不开，打开太慢。中科院的http://cn.arxiv.org/ 镜像地址也访问不了。。
使用中科院arxiv的这个镜像地址：http://xxx.itp.ac.cn
把要访问 arxiv 链接中的域名从 https://arxiv.org 换成 http://xxx.itp.ac.cn ,
比如:
https://arxiv.org/pdf/2003.10152.pdf -&gt;http://xxx.itp.ac.cn/pdf/2003.10152.pdf
一秒钟就打开了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdb1c2d6b4fae0a196d48dc3b5ef91ca/" rel="bookmark">
			vue父组件通过$refs调用子组件方法时报undefined的问题?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天用vue写项目，用$refs调用子组件方法遇到这样的问题，如下图： 大概就是这样子的问题，在网上查了很多资料，终于解决了，解决办法就是这样：
出现这个问题的原因主要是在vue还没进行加载完方法的时候就开始进行执行组件方法就会报这个错误，解决的办法很简单，只要在让方法在vue加载完组件之后再进行执行就好了！ 希望对你有帮助 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/431/">«</a>
	<span class="pagination__item pagination__item--current">432/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/433/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>