<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c23ddb39af6ca26f513fec026f2ac6b5/" rel="bookmark">
			SGM代码及其测试代码和结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SGM代码 github上边已经有很多开源的SGM代码了，下面就给出几个已经试过好用的代码，以免忘记下载的代码来自哪个连接。
gishi523 /semi-global-matching ：基于CSCT的SGM，用左右一致性检测、唯一性检测、中值滤波进行后处理，并且用SSE4.1 and OpenMP进行优化，大概 10 fps / s。dhernandez0 /sgm ：《Embedded real-time stereo estimation via Semi-Global Matching on the GPU, D. Hernandez-Juarez》这篇文章的实现，用GPU进行加速，是源码不是库，很有参考价值。在Kitti上边跑是64 fps /s。reisub /SemiGlobal-Matching ：基于BT的SGM，没有任何的后处理，速度较慢，跑一帧需要17s。ethan-li-coding /SemiGlobalMatching ：李博的代码，基于CT的SGM，用左右一致性检测，唯一性检测，亚像素插值，在CPU上实现，在vs2019上release跑大概 1 fps / s。fixstars /libSGM ：基于GPU的SGM，代码写成库了，写的非常乱，没什么参考价值，但速度确实挺快，在KITTI跑 50fps/s。 测试代码 #include &lt;iostream&gt; #include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; using namespace std; using namespace cv; int main(int argc, char** argv) { cv::Mat GT; cv::Mat output_disparity; Mat occl,occ_and_discont,occ_and_textl; GT = cv::imread("/home/dcm/图片/2003/teddy/disp2.png", CV_LOAD_IMAGE_GRAYSCALE); output_disparity = cv::imread("/home/dcm/semi-global-matching-master/build/output_disparity.png", CV_LOAD_IMAGE_GRAYSCALE); occl = imread("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c23ddb39af6ca26f513fec026f2ac6b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cca50922af49777ed8de7b3d416941b/" rel="bookmark">
			运算方法与运算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定点数加法 定点数补码加法的计算准则是：
[ x ] 补 + [ y ] 补 = [ x + y ] 补 m o d 2 n + 1 [x]_补+[y]_补=[x+y]_补mod2^{n+1} [x]补​+[y]补​=[x+y]补​mod2n+1,n为字长。
定点数减法计算准则：
[ x − y ] 补 = [ x ] 补 + [ − y ] 补 [x-y]_补=[x]_补+[-y]_补 [x−y]补​=[x]补​+[−y]补​
[ − y ] 补 [-y]_补 [−y]补​可直接根据定义计算，也可以根据y的补码保留最右边的一个1和之后的数，1左边的数全部取反。
数据溢出检测：
运算结果超出了数据的表示范围时就表示溢出了。
溢出只发生在同符号数相加时。
检测溢出：
1、检测结果和操作数的符号位，当运算结果和操作数的符号位不同时就表示溢出了。
2、对最高数据位进位和符号位进位进行检测。
以C0表示符号位进位，C1表示最高数据位进位，C0与C1异或结果为1时就发生了溢出。
3、用变形补码：即用两位符号位，初始时两位符号位相同，当两位符号位的异或结果为1时就发生了溢出。
还有软件检测测溢出。
无符号整数检测溢出：无符号数加法可以用ALU的进位位检测，无符号数减法根据ALU进位取反检测。
定点数加减法运算器设计 加法运算器的基本单元为一位全加器FA
串行加法器是利用一位全加器串联，低位的进位作为相邻加法器的一个输入。如下图：
串行减法器的设计和加法器一样，根据公式改变一个输入即可，由于[-y]的补码就是各位与1异或再加1，各位与1异或就相当于取反。如下图：
C0§为1时为减法运算器，为0时是加法运算器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cca50922af49777ed8de7b3d416941b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9a62f6f15eda618853616f67966efc0/" rel="bookmark">
			UE4实时渲染——几何结构渲染二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一节：UE4实时渲染——几何结构渲染一
上一节我们探讨了绘制调用drawcall的概述，以及对性能的影响。
绘制调用drawcall的可视化 现在让我们看一下绘制调用drawcall在场景中可视化展现出来。
使用RenderDoc插件，开启使用后，貌似要重启一下UE4才可以使用，这样做好，这里会多出一个小按钮。
点击按钮后，会将当前场景捕捉到RenderDoc中，通常要5-10秒的等待时间，然后出现这样的画面，这是一个可以免费下载的程序：
中间是编辑器输出的帧画面，你可以输出多个帧画面，然后双击帧画面，就会出现许多关于该帧画面的标签页，
如果点击“渲染管线状态（Pipeline States）”，我们可以看到各个着色器经历的步骤。
左侧的区域，列出了所有的渲染内容，展开场景，就得到了按顺序排列的渲染过程：
当我们点击预通道prepass，这是首先完成的环节：
我们目前处于基础通道BasePass：
基础通道属于主要环节，负责渲染几何体，
打开这个基础通道环节，里面包含了3个步骤，其中采用了2种静态遮挡，还使用了动态遮挡，
而且第二组静态遮挡里相比而言，包含了最多的模型，这些模型就是我们在这一帧中能看到的所有内容，虽然看起来是按照名称排序，实际上是按照材质排序的（因为多数使用相同材质的模型名称会类似），这个列表中，每一个都是一次绘制调用drawcall，一步一步的你会看到逐对象渲染，所以这个过程将会很慢，
你可以点击这个时钟按钮，来看绘制调用的耗时，
这个耗时是根据渲染当时的硬件情况，以及调度使用情况，来计算的，所以就算是同一帧，相同的对象，渲染耗时也是可能有偏差的。但我们还是可以有个大致的了解，比如中间的雕像损耗性能最大。
其他步骤这里暂时不深究。
--------------------------------------分割------------------------------------------
两种工作流方式及其优缺点 需要注意的是：
1、蓝图中的每个静态网格体，仍然需要一次绘制调用，组件也是逐个进行遮挡和渲染的。
2、如果想减少绘制调用drawcall，最好使用少量的大模型，而非大量的小模型。但大模型使用也要适量，大模型使用太多，也会导致一些问题，比如a、遮挡会变得复杂；b、光照贴图lightmapping会变得复杂；c、碰撞检测也会变得复杂；d、对于内存来说负担也更重
你有两种工作流方式：
1、模块化方式创建场景（类似搭乐高）
2、一整块网格体
两种方式区别对比：
1、对于“一整块网格体”这种方式而言，对之前提到过的四种剔除方式之一的“遮挡剔除”很不友好，但凡有一个像素点出现在画面里，这整块网格体都将渲染出来，即使它出现在背后。
2、“一整块网格体”这种方式，对于光照贴图lightingmapping更加糟糕，光照贴图会在后面讲述。
3、还有对碰撞检测而言：
对于模块化方式而言，碰撞检测就是，比如说，当你在房间中丢出一个小球，当这个球碰到房间内的立柱（单个模块），它必须从立柱那里查询碰撞信息，来确定它击中的位置，以及下一步该怎么做，它会从立柱那里得到一个面数非常低的碰撞模型，这个碰撞模型就是它使用的碰撞盒。但是对于“一整块网格体”方式而言，相同的球击中网格体内的立柱，小球会得到整个网格体的碰撞数据，仅仅因为它击中了立柱，虽然这种影响很复杂但不会特别厉害，但仍然会产生影响。
4、内存的话，一个立柱模型可能只有410KB的内存，但“一整块网格体”占用了7.5MB的内存。 所以综上所述，我们可以看到，不论是用大模型，还是小模型，都均有利弊。
解决方案：
为了解决“单独模块”的弊端、“大型整块网格体”的弊端，选择折中的办法，就是模块化网格体，这样可以：
1、节省工作量、时间和内存
2、容易放置、光照、遮挡、碰撞检测、LOD都会有所改善
3、但是绘制调用drawcall的次数会更高
所谓模块化网格体，其实就是，模块不要单独放置，也不要合的过于庞大，可以几个单独的模块合成一个中型大小的模块，这样就是模块化网格体了，同时也中和了两个极端的优缺点。
--------------------------------------分割------------------------------------------
模块化网格体（独立模块的轻量合成） 需要注意的是：小心合并它们，一旦合并后，我们就没办法简单的撤销合并。
我们应该遵循以下合并规则：
（最好用相同材质的独立模块，这样可以使绘制调用drawcall一次性绘制）
1、越常用的网格体，并且面数越低越好。
我们可以从“窗口”菜单选择“统计”
这里显示SM_TrimWall_U使用了164次，每次有268个多边形
我们可以选择常用且面数低的网格体，面数较低的网格体合在一起之后面数也不会变得过高，这就很合理。
2、合并同一区域内的网格体。
如果在不同的区域内的网格体合并，这对遮挡没有好处，对碰撞来说也很糟糕，网格体应处于同一区域或房间内。
3、只合并拥有相同材质的网格体，否则性能不会提升太多。
每一种材质都会有绘制调用drawcall，所以如果合并不同材质的，仍然会有相同的绘制调用次数。
4、没有碰撞，或者只有简单碰撞的网格体，更适合合并。
5、非常小，或者只接受动态光照的网格体。
如果网格体太小，我们就不用担心光照贴图。
6、远距离几何体更适合合并。
实际上我们合并与否，都是为了性能、帧率能更好，所以当帧率达到了我们心里的目标帧率比如30FPS，我们就没有必要再去想着如何合并网格体了。
在一些低端硬件上，比如vr、ar、移动端设备上，可能最终我们需要合并所有网格体，所有内容。
--------------------------------------分割------------------------------------------
实例化静态网格体渲染 默认情况下，UE4中的网格体会实例化并保存在内存中，但它们不会在渲染时实例化。内存中实例化、实例化渲染的区别如下。
内存中实例化：
模型只在内存中实例化，并不会在渲染时实例化。
导入模型（如422kb），只在内存中存在1次，如果我把它放到场景中2次，意味着它渲染了2次，但是在内存中仍然只占用422kb。
实例化渲染：
内存中、渲染时都实例化。
比如，将相同的立柱添加到实例化静态网格体组件中，按组进行渲染，它们实例化后仿佛就是一个单一模型，但有4个对象那么大，这样我们就可以一次性渲染一组网格体了。
但实际上我们并不会默认对所有对象，做实例化渲染，因为在做实例化渲染之前，渲染器会依次询问，这两个网格体是否是同一个，依次询问对比会带来大量的损耗，所以有时其性能并不如直接渲染来的更高效。
所以我们只把相同对象放到实例化静态网格体组件中，相当于给它一个简短的列表，告诉它只比较这个列表中的对象即可，因为他们有可能是一样的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9a62f6f15eda618853616f67966efc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/181b4a049848600d4bd47b8897c99b7c/" rel="bookmark">
			H5选择本地文件夹下图片上传到服务器，并在网页中显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基本变种 html5缺点：还要选择 基本 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Definition&lt;/title&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;article&gt; &lt;h2&gt;file&lt;/h2&gt; &lt;input type="file" id="files" onchange="draw()" webkitdirectory accept="image/*"&gt; &lt;/article&gt; &lt;section&gt; &lt;canvas id="myCanvas" width=2000 height=5000&gt;&lt;/canvas&gt; &lt;/section&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; var imgPosY = 0; function draw() { // 获取选择到的文件 var files = document.getElementById("files").files; for (var file of files) { // console.log(file.webkitRelativePath); // 显示图片的相对路径 // 读取文件内容 var reader = new FileReader(); reader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/181b4a049848600d4bd47b8897c99b7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d1e8f4ec460c5a8750e11d526d79562/" rel="bookmark">
			C语言的主要用途以及未来发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		截止到 2021 年，C语言已经发布了将近 50 年，是不折不扣的“大叔”或者“大爷”，但是，C语言在编程界依然非常流行；2019 年，C语言由于速度快、平台独立的特性，在世界编程语言排行榜中夺得第二名。
图1：2019年世界编程语言排行榜
C语言是为直接控制硬件而开发的，可以用来编写操作系统内核、驱动程序等。
C语言也是很多其它编程语言的基石，它们有的使用C语言开发编译器和标准库，有的基于C语言模块进行扩展，因此，C语言也被称为其它语言的“母语”。
现在都 2021 年了，您可能会想，C语言在现实生活中还有什么用途呢？这就是本文要重点讨论的内容。
本文我们先讨论C语言的特性，然后讨论C语言在目前以及未来的实际用途。通过阅读本文，您将对C语言有一个整体的认知。
什么是C语言？ 1972 年，丹尼斯·里奇（Dennis Ritchie）在著名的贝尔实验室中开发了C语言。
图2：C语言之父——丹尼斯·里奇
从特性方面讲，C语言是一种中级语言，它结合了低级语言速度快的特点，以及高级语言开发方便的特点；从应用方面讲，C语言也是一种高级语言，它可以用来编写电脑软件，或者开发嵌入式系统。
当需要开发一种新的编程语言时，C语言是最好的选择，因为C语言执行效率非常高，仅次于汇编语言。例如，目前常用的 Python、PHP、C++、Objective-C 都是在C语言的基础上进行开发的。
C语言的主要特点：
执行速度快可以直接访问内存模块化，易于扩展占用内存少静态类型中级语言可移植性通用语言 C语言的用途 C语言是一种非常简单的编程语言，全世界的程序员都在使用它。最初，C语言被用于系统性开发工作，准确地说，就是编写操作系统（例如 Windows、Linux 等）和底层组件（比如驱动、网络协议等），因为C语言的优势就是执行效率高，C语言生成的程序几乎和汇编语言生成的程序一样快速。
C语言的用途可以概括如下：
1) 系统编程
C语言可移植性好，性能高，能够直接访问硬件地址，而且到达某个地址的时间非常短，这使得C语言天生适合开发操作系统或者嵌入式应用程序。在最初的时候，C语言主要就是被应用在这两个领域。
2) 开发其它编程语言
有些编程语言的编译器或者解释器就使用C语言开发，还有一些编程语言的库或者模块支持C语言，这使得C语言成为了很多其它编程语言的基础。
3) 电气工程
C语言在电气工程领域也有很多用途，它可以使用信号处理算法来管理微处理器、微控制器等集成电路。
4) 编译器中间件
由于C语言具有可移植性，适应性强，有时也被用作不同编程语言的中间语言，这样不同编程语言之间就可以共享组件/模块。把C语言作为中间件的编译器有 Gambit、BitC、Glasgow Haskell Compiler、Vala 和 Squeak 等。
5) 应用程序
C语言被广泛应用于实现最终的用户应用程序，或者作为某些应用程序的关键模块。例如，机械设计领域的各种 CAM 和 CAD 都在使用C语言编写某些关键模块，这些模块对执行效率有着较高要求。
举例说明C语言的应用 在日常生活中，很多系统软件和桌面应用程序都采用C语言进行开发，下面给出了一些示例。
1) 操作系统
UNIX 是第一个使用高级语言设计的操作系统，它使用的编程语言就是C语言。后来，Microsoft Windows 和不同的 Android 组件也使用C语言编写。
2) GUI（图形用户界面）
Adobe Photoshop 是目前最受欢迎的图像编辑器之一，它的很多组件就使用C语言开发。此外，Illustrator 和 Adob​​e Premiere 也使用了C语言。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d1e8f4ec460c5a8750e11d526d79562/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21f9c9ce97fa2f11056b6ba164decacd/" rel="bookmark">
			script的函数知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基础script的两种函数script与body的位置 基础 碰到出错的语句，抛出错误后就立马停下，之后的都不执行了。一个&lt;script&gt;&lt;/script&gt;块和另一个&lt;script&gt;&lt;/script&gt;块，其内变量互通。 &lt;script&gt; var str = '第一块中的变量在第二块中出现了'; function f1() { console.log('第一块中定义的函数，在第二块中成功执行了'); } f2(); console.log('f2应该不出现') &lt;/script&gt; &lt;script&gt; function f2() { console.log('第二块中定义的函数，不应该在第一块中执行成功'); } f1(); console.log(str); &lt;/script&gt; script的两种函数 js代码会先进入预编译阶段，然后再进入执行阶段：
预编译阶段：声明变量；处理声明式函数。执行阶段：赋值变量；处理赋值式函数；处理调用函数语句。同一阶段中按语句先后顺序执行。 PS：这个东西只关乎“调用函数语句”和“声明式函数”“赋值式函数”的先后关系，不关乎函数内部实现问题。
例子1
f1();	// 调用函数语句 function f1() { // 声明式函数 console.log('f1'); } // f1(); //这就不用说都肯定行 所以，造成了可以f1()可以写在function f1(){}前的情况。
例子2
f2();	// 调用函数语句 var f2 = function(){ // 赋值式函数 console.log('f2'); } f2()和function f2(){}都在执行阶段中，按照顺序处理，所以就会出现未定义的问题。
例子3：重复定义的覆盖现象
f1();	function f1() { console.log('f1.A'); } function f1() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21f9c9ce97fa2f11056b6ba164decacd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/058078b1a60611cf9942b1b38a192da8/" rel="bookmark">
			你的计算机由组织管理,Windows10提示“某些设置由你的组织来管理”如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不少windows10正式版用户都反馈，自己在系统进行一些设置时，遇到了错误提示“某些设置由你的组织来管理”，最终导致部分设置选项无法使用，如下图所示。这该怎么办呢？下面，小编就给大家分享Windows10提示“某些设置由你的组织来管理”的具体解决方法。
有时甚至会影响到锁屏壁纸设置功能：
解决方法：
出现这一问题，是因为在设置—隐私—反馈和诊断中，诊断和使用情况数据一项选择了“基本”，如下图所示，只需要将其更改为“增强”或“完整”即可。
也就是说，想要使用所有的设置功能，就需要反馈更多的数据。
另外，如果加入了Insider预览计划，那么该选项默认同样是选择“完整”，但不允许用户修改，如下图所示：
当然，作为Insider会员，似乎理应反馈更多的数据，保证测试的意义。你认为微软的这项设置是否合理呢？
Windows10提示“某些设置由你的组织来管理”的具体解决方法就介绍到这里了。使用win10过程中，遇到同样问题的用户，不妨按照小编的方法操作看看！大家可以关注系统城更多教程http://www.xitongcheng.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25c0d04b7f64fe6f4bb5fb4a80b8d580/" rel="bookmark">
			Maxscript连接Access数据库的相关操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maxscript在连接Access数据库中，主要有用到的是AOD Connection和AOD Recordset对象。
Mydate = createOLEObject "ADODB.Connection" Mydate.Open "driver={Microsoft Access Driver (*.mdb, *.accdb)}; DBQ=F:\\tt\\EmbedRecord.mdb;PWD=*******" 调用Conncetion中的Open方法来进行数据库的连接。其中DBQ是路径，PWD是数据库密码。
rs = createOLEObject "ADODB.Recordset" //创建Recordset对象 rs.Open "SELECT * from 表名" Mydate 1 3 //第二位数字 1表示读取数据；3表示新增、改动或删除数据 连接好数据库之后，就可以使用Recordset的方法对access进行操作。
rs.MoveFirst --指向第一条记录 rs.MoveNext --指向下一条记录 rs.EOF --是否最后一条记录 rs.Delete --删除当前指向的记录 rs.close --关闭 //添加记录 rs.GetRows() rs.AddNew #("列1","列2"……) #(值1,值2,……) --添加语句 //遍历数据库 fields=rs.Fields --Recordset的一个默认集合 count = fields.count --列的数目 while rs.EOF == false do ( for i = 1 to count do ( local item = fields.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25c0d04b7f64fe6f4bb5fb4a80b8d580/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db4565e5fe4cca77708632c35c1a8895/" rel="bookmark">
			(转)Visual Studio Code单行和多行注释方法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/qq_40027987/article/details/88115493
使用Django的三行代码为例：
一、单行注释：（注释第一行代码）
1、光标放在首字母之前，shift+#，取消同理。
2、光标放在第一行任意位置（句中句末都可以），ctrl+/，取消同理。
3、光标选中想要注释的某行代码，alt+shift+A，取消同理。
4、光标选中想要注释的某行代码，(1）ctrl+k（2）ctrl+c，取消是（1）ctrl+k（2）ctrl+u。
二、多行注释：（注释多行代码）
1、光标选中想要注释的所有代码，ctrl+/，取消同理。
2、光标选中想要注释的所有代码，alt+shift+a，取消同理。
3、光标选中想要注释的所有代码，(1）ctrl+k（2）ctrl+c，取消是（1）ctrl+k（2）ctrl+u。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/846eee902683e7d5fd6248d853510445/" rel="bookmark">
			vscode创建jar包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.bilibili.com/video/av89944931/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81b7e900b20a6e91806c0878a5606f7f/" rel="bookmark">
			关于HarmonyOS是否支持X86的看法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于HarmonyOS是否支持X86的看法 最近，鸿蒙os在互联网世界里可谓是掀起了大风大浪，而我相信有许多人跟我一样希望早日适配X86，于是我就跑到Openharmony的开源文档仓库发表了一个Issues，但是官方的回答却让人心寒：
但是，当我打开HUAWEI DevEco Studio准备创建项目时，发现了一个不起眼的小图标：
这下让我更疑惑了，不是不支持吗？难道官方在说谎？难道，这次HDD就要发布PC版吗？想到这里，我就立刻报名了HDD（别问我为什么不直接看直播）。
祖传结尾:
本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。
Copyright ©2021 Redish101
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0df1a5099ae049bf038741c9d3b78659/" rel="bookmark">
			Android集成微信登录-无法收到微信登录回调结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误日志 2021-07-09 16:37:27.011 25614-25614/【包名】 D/MicroMsg.PaySdk.WXFactory: createWXAPI, appId = 【wxappid】 checkSignature = false
2021-07-09 16:37:27.011 25614-25614/【包名】 D/MicroMsg.PaySdk.WXFactory: createWXAPI, appId = 【wxappid】 checkSignature = false, launchMode = 2
2021-07-09 16:37:27.011 25614-25614/【包名】 D/MicroMsg.SDK.WXApiImplV10: &lt;init&gt;, appId = 【wxappid】 checkSignature = false, launchMode = 2
2021-07-09 16:37:27.011 25614-25614/【包名】 D/MicroMsg.SDK.WXMsgImplComm: ignore wechat app signature validation
2021-07-09 16:37:27.011 25614-25614/【包名】 D/MicroMsg.SDK.WXApiImplV10: registerApp, appId = 【wxappid】
2021-07-09 16:37:27.011 25614-25614/【包名】 D/MicroMsg.SDK.WXApiImplV10: registerApp, appId = 【wxappid】
2021-07-09 16:37:27.011 25614-25614/【包名】 D/MicroMsg.SDK.WXApiImplV10: register app 【包名】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0df1a5099ae049bf038741c9d3b78659/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e1ee087ada0e36d7744db0af26b0e68/" rel="bookmark">
			Go语言创建和获取Cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Cookie 简介 Cookie就是客户端存储技术.以键值对的形式存在在B/S架构中,服务器端产生Cookie响应给客户端,浏览器接收后把Cookie存在在特定的文件夹中,以后每次请求浏览器会把Cookie内容放入到请求中 二.Go语言对Cookie的支持 在net/http包下提供了Cookie结构体 Name设置Cookie的名称Value 表示Cookie的值Path 有效范围Domain 可访问Cookie 的域Expires 过期时间MaxAge 最大存活时间,单位秒HttpOnly 是否可以通过脚本访问 type Cookie struct { Name string Value string Path string // optional Domain string // optional Expires time.Time // optional RawExpires string // for reading cookies only // MaxAge=0 means no 'Max-Age' attribute specified. // MaxAge&lt;0 means delete cookie now, equivalently 'Max-Age: 0' // MaxAge&gt;0 means Max-Age attribute present and given in seconds MaxAge int Secure bool HttpOnly bool Raw string Unparsed []string // Raw text of unparsed attribute-value pairs } 三.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e1ee087ada0e36d7744db0af26b0e68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46ee49dead507c13f12cfa6777a85127/" rel="bookmark">
			快收藏！！整理了100个Python小技巧！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小F～
目前Python可以说是非常流行，在目前的编程语言中，Python的抽象程度是最高的，是最接近自然语言的，很容易上手。
你可以用它来完成很多任务，比如数据科学、机器学习、Web开发、脚本编写、自动化等。
下面，小F就给大家分享100个Python小技巧，帮助大家更好的了解和学习Python。
▍1、for循环中的else条件
这是一个for-else方法，循环遍历列表时使用else语句。
下面举个例子，比如我们想检查一个列表中是否包含奇数。
那么可以通过for循环，遍历查找。
numbers = [2, 4, 6, 8, 1] for number in numbers: if number % 2 == 1: print(number) break else: print("No odd numbers") 如果找到了奇数，就会打印该数值，并且执行break语句，跳过else语句。
没有的话，就不会执行break语句，而是执行else语句。
▍2、从列表中获取元素，定义多个变量
my_list = [1, 2, 3, 4, 5] one, two, three, four, five = my_list ▍3、使用heapq模块，获取列表中n个最大或最小的元素
import heapq scores = [51, 33, 64, 87, 91, 75, 15, 49, 33, 82] print(heapq.nlargest(3, scores)) # [91, 87, 82] print(heapq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46ee49dead507c13f12cfa6777a85127/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ccfcd3b73d80dc67e5ed924c5e8be87/" rel="bookmark">
			springboot集成mongdb 操作数据及文件存储下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装 如果去官网下载mongdb的话比较麻烦，http://www.mongodb.org。建议去http://dl.mongodb.org/dl/win32/x86_64这个地址下载，方便快捷
安装好之后，去安装目录启动，我安装到了C盘C:\Program Files\MongoDB\Server\4.0\bin。cd进入该目录，然后命令启动：mongod --dbpath E:\mongdb\data 如图：
访问：http://localhost:27017/
说明启动成功
二、代码集成 1、pom.xml
版本需要对应，我这里是springboot2.0.4.RELEASE对应mongdb4.0
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.zhouzy.springboot&lt;/groupId&gt; &lt;artifactId&gt;zhouzy-mongdb&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;zhouzy-springboot&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ccfcd3b73d80dc67e5ed924c5e8be87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a60b4b565e4b3720761ae29c8143ce89/" rel="bookmark">
			map文件查看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		map文件里面内容大致分为五大类（按照map文件分类的顺序）：
1.Section Cross References：模块、段(入口)交叉引用；
2.Removing Unused input sections from the image：移除未使用的模块；
3.Image Symbol Table：映射符号表；
4.Memory Map of the image：内存（映射）分布；
5.Image component sizes：存储组成大小。
Ⅰ、Section Cross References：模块、段(入口)交叉引用
Section Cross References：模块、段(入口)交叉引用，指的是各个源文件生成的模块、段（定义的入口）之间相互引用的关系。
Ⅱ、Removing Unused input sections from the image：移除未使用的模块
我们工程代码中，没有被调用的模块。
1142 unused section(s) (total 90021 bytes) removed from the image.
Ⅲ、Image Symbol Table：映射符号表
Image Symbol Table：映射符号表，也就是各个段所存储对应地址的表（这一项比较重要）。
Symbols分为两大类
1.Local Symbols局部
2.Global Symbols全局
内容要点
1.Symbol Name：符号名称
2.Value：存储对应的地址；
大家会发现有0x0800xxxx、0x2000xxxx这样的地址。
0x0800xxxx指存储在FLASH里面的代码、变量等。
0x2000xxxx指存储在内存RAM中的变量Data等。
3.Ov Type：符号对应的类型
符号类型大概有几种：Number、Section、Thumb Code、Data等；
细心的朋友会发现：全局、静态变量等位于0x2000xxxx的内存RAM中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a60b4b565e4b3720761ae29c8143ce89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c6eae710e2154de70e9663552aa7e6/" rel="bookmark">
			【论文精读】深度学习脑部医学图像双任务：联合配准和肿瘤分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Deep Learning-Based Concurrent Brain Registration and Tumor Segmentation Estienne, T. et al. “Deep Learning-Based Concurrent Brain Registration and Tumor Segmentation.” Frontiers in Computational Neuroscience 14 (2020): n. pag.
Abstract Image registration and segmentation are the two most studied problems in medical image analysis. Deep learning algorithms have recently gained a lot of attention due to their success and state-of-the-art results in variety of problems and communities. In this paper, we propose a novel, efficient, and multi-task algorithm that addresses the problems of image registration and brain tumor segmentation jointly.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1c6eae710e2154de70e9663552aa7e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a8df0b7fa74d4c38aedbe1a402f87ac/" rel="bookmark">
			计算机软件系统 初中,初中信息技术计算机系统的组成(硬件)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《初中信息技术计算机系统的组成(硬件)》由会员分享，可在线阅读，更多相关《初中信息技术计算机系统的组成(硬件)(22页珍藏版)》请在人人文库网上搜索。
1、一、复习第一节,1、信息处理的过程包括哪 5 个过程？,采集存储加工存储输出,2、在信息处理中，计算机是 、 的工具,最基本,最重要,二、计算机系统的组成,一个完整的计算机系统包括 硬件 和 软件 两部分。,现今流行的计算机外观,不管是哪种外形的计算机，组成计算机硬件的基本部件都包括五大部件：,存储器,运算器,控制器,输入设备,输出设备,存储指令和数据,执行所有的运算,指挥、控制整台计算机的工作,将信息送入计算机,将结果输出,1)、存储器可分为 主存储器(内存)、 辅助存储器(外存),主存 (内存),存取速度快，但容量较小,辅存 (外存),容量大，成本低，但存取速度较慢,主机中内存条RAM,内。
2、存和外存的区别,内存和外存本质的区别是能否被中央处理器(CPU)直接访问。CPU不能直接执行外存中的程序，处理外存中的数据。 两者的主要区别是： 从原理上讲位置不同，主机内还是主机外； 构成材料不同，半导体还是磁介质(光介质)； 存储容量不同，内存小，外存大； 价格不同：价格/每存储单元内存高，外存低； 存取速度不同：内存高，外存低。,内存又分为两种,只读存储器 (ROM),随机存储器 (RAM),ROM 存放最基本的输入输出控制程序； 其中的信息只能读出不能写入； 断电后信息不会丢失。,RAM 是一种读写存储器， 其内容可以随时根据需要读出或写入； 断电后信息丢失。,常用的外存有：,U盘,软。
3、盘,移动硬盘,硬盘,光 盘,2、存储器的容量,计算机存储容量以 字节 为单位， 1个字节称为1byte，简写 1B,1KB= 1024B 1MB=1024KB 1GB=1024MB,1个字节(1B)可存放1个英文字母， 2个字节(1B)可存放1个汉字,请问，1张1.44MB的软盘可存放多少个汉字？,存储容量练习,15个字节(1B)可存放 英文字母， 20个汉字需要 字节(B)来存放。,15个,40个,1MB= B 2GB= KB,2*1024*1024,1024*1024,2KB存放( )个汉字 3MB存放( )个英文字母,3*1024*1024,1024,存 储 器,主存储器 (内存),辅助。
4、存储器 (外存),只读存储器(ROM),随机存储器(RAM),硬盘,软盘,光盘,U盘、移动硬盘等,2、运算器,3、控制器,运算器、控制器集成一块 芯片上中央处理器(CPU),4、输入设备,5、输出设备,微机常用的输入输出设备,计 算 机 软 件,系统软件,应用软件,操作系统,Windows,Linux,最基本、最重要的系统软件。,程序设计语言,VB、C、PASCAL、JAVA等,软件 = 程序 + 数据+文档,操作系统的主要功能: p10,试列举几种应用软件,应用软件：,为解决特定问题而设计的各种程序、文档资料。,Word 、 wps 文字处理软件,Excel电子表格软件,Powerpoint幻灯片制作软件,Flash 3d max动画制作软件,游戏、网络聊天软件等等。,计算机系统,硬件系统,软件系统,主机,外部设备,内存,CPU,运算器,寄存器,随机存储器(RAM),只读存储器(ROM),外存储器,输入/输出设备(I/O设备),系统软件(操作系统、 语言处理程序等),应用软件(字处理、计算机辅助设计等),控制器,存储器,计算机系统应包括硬件系统和软件系统两大部分:,输入设备和输出设备,列出两种常用的输入设备( )( ) 列出两张常见的输出设备( )( ),鼠标,键盘,显示器,打印机,扫描仪是一种 ( )设备 绘图仪是一种 ( )设备,输入,输出,作 业： P24 3-7题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09a33325a29ac756ffe2062c5d981976/" rel="bookmark">
			hbase-phoenix的视图，二级索引--重要
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Phoenix的视图 ​ 说明: 发现在Phoenix的只有在Phoenix自定义的表以及Phoenix的系统表, 如果我们在hbase上自定义的表, 在Phoenix中无法找到的, 那么也就意味着无法通过Phoenix对hbase自建的表进行相关的操作
​ 如何解决这种问题呢? 采用Phoenix提供的视图
视图主要的目的: 对hbase自建表进行映射关系匹配, 这个过程类似于 hive表和hdfs上数据进行映射 映射成功后, 我们就可以通过Phoenix对hbase中自建表进行相关的查询操作 如何构建视图呢? 格式: create view 名称空间."hbase映射表名" ( key 类型 primary key, 列族1.列名1 类型, 列族1.列名2 类型, 列族2.列名1 类型, .... ) 注意事项: 1) 视图的名称必须与对应要映射hbase表名保持一致的 2) 视图的中主键的名称可以任意定义, 但是必须加上主键约束, 同时必须放置表的第一个 3) 视图中列族名称 以及对应的列名 必须和要映射的hbase表名中列族列名一致 如何删除视图呢 drop view 视图名称; 案例:
目前在hbase中有一张 WATER_BILL 表, 请在Phoenix中构建一个视图与之映射, 并完成以下的查询需求:
​ 根据查表的日期, 查询6月份总计有多少条查表记录
1) 创建视图 create view "WATER_BILL" ( id varchar primary key, c1.address varchar, c1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09a33325a29ac756ffe2062c5d981976/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e4e02accb87e470b8b0e90366861e28/" rel="bookmark">
			ASCII码对应表，ASCII码值的大小顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚开始基础计算机编程的时候，学习的是二进制、十进制、十六进制。
十进制是生活习惯中最常用的计数方法，也是我们计数的思维逻辑。
后来接触了计算机基础，我们知道计算机都是用二进制表示的，但是这种表示方法让人理解很困难。
因此人们编制了统一的信息交换代码，也就是ASCII码表，它的全称是“美国信息交换标准代码”
详细的ASCII 码表见下：
如上表：每一个ASCII 都有3部分组成. ASCII值、16进制、控制字符。
其中ASCII值就是控制字符对应的十进制数值，16进制和ASCII值是对应的，控制字符就是可以表示的字符。
例如，如下图所示：
ASCII值65：就是大写因为字母‘A’的ASCII的值，这里的65是10进制
16进制41H：转换成10进制是65，和ASCII值是对应的。
控制字符A：就是需要表示的大写字母‘A’
那ASCII码表有那些应用呢？
最常见的就是我们的电脑上的键盘，但输入方式切换成英文的时候，我们通过键盘输入的数字0-9，小写a-z、大写字母A-Z、还有一些符号@、！、&amp;、*等都是ASCII格式。
其中键盘的0-9对应的ASCII值就是0x31-0x32(16进制)，A-Z对应的ASCII值是(0x41-0x5A)，a-z对应的ASCII值是(0x61-0x7A);
我第一次真正接触ASCII，是写LCD1602驱动的时候，其实ASCII在单片机程序编程中也是非常常用的，尤其是屏幕的显示，以及串口通讯、4G通讯等
例如1602液晶屏的显示，如果要显示 ’A’，需要给液晶屏输入“0x41”
在这里也给大家顺便讲一下单片机程序中的ASCII字符怎么表示。如下面代码定义了字符0-9:
unsigned char code ASCII0_9[10]=”0123456789”; //C51单片机
我们将需要表示的数值放置在一个自定义的数组中，然后把字符用“”括起来。
如上，如果我们调用ASCII0-9[0]对应的10进制数就是48，16进制是0x30，表示字符0。
同时我们定义的数组，还需要用code来修饰，code表示将定义的数组变成常量（51单片机用code, STM32单片机用const ）。
我们在C语言程序编程中，有一种变量的定义“char”，我们也叫字符型类型，也是和ASCII有关，char 占用一个字节，取值范围是-128 ~127。
ASCII表是基于英语来编写的，其中包含了英文的大小写字母，以及数字0-9，各种符号。
之前的ASCII表是0-127，共128个字符。
但是随着科技的不断的进步，先前定义的ASCII 不能满足大家的需求. 后来ASCII 的表有扩展到了256个字符。
扩充ASCII码表如下图所示：
我们看一下ASCII 扩展表上面的字符，大多数我们都很陌生，其实我们在单片机程序编程中用的也是非常少，大家只要了解就行了。
关于ASCII码表，今天就先给大家介绍到这里了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c65b7b658ed8ae531e8cd719ac732f0a/" rel="bookmark">
			面试速记之Java并发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 并行并发线程实现的方法设置线程名获取线程名获取当前工作线程引用线程休眠守护线程加入线程（插队）join()join(long millis) 礼让线程yield() 线程优先级线程是否活跃当前线程的线程组中活跃线程数目线程状态同步同步代码块同步方法非静态方法静态方法 死锁线程通信notify()notifyAll() sleep与wait方法的区别CAS问题CAS底层 JMM三大特性可见性原子性顺序性指令重排序 volatile单例模式（要会写）饿汉懒汉懒汉在多线程场景下会出问题解决：为什么要加volatile？ 如何解决volatile不保证原子性？ AtomicInteger相关方法锁锁细化锁粗化锁升级公平锁非公平锁可重入锁（递归锁）自旋锁独占锁共享锁规则 阻塞队列synchronized底层 LockCallable接口并发工具类线程池ThreadPoolExecutor 进程线程协程死锁条件互斥请求与保持非剥夺循环等待 避免破坏请求与保持破坏非剥夺破坏循环等待 ThreadLocal底层线程池用threadlocal会内存泄漏 并行 多核cpu，多个任务同时跑
并发 多任务申请资源，只能处理一个任务
时间间隔短导致看起来像同时执行，实则是多任务交替执行
线程实现的方法 1.继承thread类，重写run方法
2.实现runnable接口，重写run方法
3.实现Callable接口
设置线程名 1.构造
2.setter
获取线程名 getter
获取当前工作线程引用 currentThread()
线程休眠 sleep(long millis)
不释放锁
到时间 或 notify()/notifyAll() 唤醒
守护线程 要在跑之前设好
setDaemon(boolean on)
qq聊天界面是守护
qq程序是非守护
当qq程序无了，没啥可守护了，qq聊天界面也会无
加入线程（插队） join() 当前线程暂停，等插队线程执行完了再继续
join(long millis) 当前线程等若干时间，时间到了继续跑
礼让线程 yield() 暂停当前线程，让其他线程跑
线程优先级 setPriority(int newPriority)
MAX_PRIORITY 最高是10
MIN_PRIORITY 最低是1
NORM_PRIORITY 默认是5
设最高不保证一定先执行，而是尽可能先执行
这些属性要在跑前设
线程是否活跃 isAlive()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c65b7b658ed8ae531e8cd719ac732f0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c5d04117da94aebce09061257453ad1/" rel="bookmark">
			C语言实现简单的登录操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写代码实现，模拟用户登录情景，并且只能登录三次。
要实现这种操作，我们需要设置一个字符串arr1用来存放密码，同时还要手动输入一个字符串password来记录我们输入的字符串，并将password与arr1字符串比较判断是否相同。同时for循环三次即可，如果输入正确则跳出循环。
值得注意的是： 在比较password与arr1是否相等时，不能够用==比较，比如下面的程序：
#include &lt;stdio.h&gt; int main() { char password[10] = ""; char arr1[] = "123456"; int i = 0; int j = 0; for (i = 0; i &lt; 3; ++i) { printf("请输入密码:"); scanf("%s", password); if (password==arr1)//使用等号比较字符串 错误 { break; } else { printf("密码错误，请重新输入\n"); } } if (i == 3) printf("输入次数用完\n"); else printf("登陆成功\n"); } 使用==比较字符串相等是不行的，因为字符串password的本质是一个字符数组，password只是数组名，而在数组那一章我们知道数组名代表的是数组首元素地址（sizeof和直接&amp;除外），所以password==arr1比较的实际上是这两个字符数组首元素的地址，很明显这俩地址是不相同的，因此不能用 == 比较字符串是否相等。
在C语言&lt;string.h&gt;头文件中有个strcmp的库函数：
因此我们可以使用这个库函数来比较他俩是否相等，如果相等则返回0，否则则返回非0.
修改后的代码：
#include &lt;stdio.h&gt; #include&lt;string.h&gt; int main() { char password[10] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c5d04117da94aebce09061257453ad1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dff87448a356c652f2431d8b8e18188/" rel="bookmark">
			win8计算机管理员权限删除文件,win8系统使用管理员权限无法删除部分文件的修复方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win8系统使用管理员权限无法删除部分文件的修复方法?
我们在操作win8系统电脑的时候,常常会遇到win8系统使用管理员权限无法删除部分文件的问题。那么出现win8系统使用管理员权限无法删除部分文件的问题该怎么解决呢？很多对电脑不太熟悉的小伙伴不知道win8系统使用管理员权限无法删除部分文件到底该如何解决？其实只需要 1、右击无法删除的文件夹，选择属性，弹出属性对话框，切换到安全选项卡，点击“高级按钮”2、看到wim的高级设置界面，所有者是Trustedinstaller，这是一个syetem级别的权限，管理员权限也无法删除，点击更改按钮就可以了。下面小编就给小伙伴们分享一下win8系统使用管理员权限无法删除部分文件具体的解决方法：
原因分析：
1、微软从Vista系统开始，Administrator就不再是最高权限了，虽然默认的都是管理员权限，但是有些东西还是删除不了。
2、Administrator已经不再是最高权限了，这里引入system这个概念：系统内置的system权限是windows系统中高于Administrator的权限，系统底层最高的权限是属于Trustedinstaller用户组权限，非人为可以设置的权限。
3、这是因为微软充分考虑了windows的安全和运行，把部分权限给了system用户组来管，最大程度上避免了xp系统时代用户管理员权限的滥用。
解决方法：
1、右击无法删除的文件夹，选择属性，弹出属性对话框，切换到安全选项卡，点击“高级按钮”；
2、看到wim的高级设置界面，所有者是Trustedinstaller，这是一个syetem级别的权限，管理员权限也无法删除，点击更改按钮；
3、弹出选择用户和组对话框，输入对象为Everyone，，英文意思是每个人，单击检查名称看看是否可以使用，点击确定。
按照上述方法设置权限之后，再次操作就可以成功删除文件了，日后操作win8系统遇到相同问题就可以轻松解决了
以上，便是win8系统使用管理员权限无法删除部分文件的修复方法了，如若修复完成后还无法解决这个问题，建议大家重新安装。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad0422e0c6739f098073480d2feeff4a/" rel="bookmark">
			error: vue-cli路Failed to download repo vuejs-templates/webpack: read ECONNRESET
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用vue-cli 搭建vue项目时初始化报错：Failed to download repo vuejs-templates/webpack: read ECONNRESET step1: 排查 vue -V ,node -v,webpack -v行你们有骨气都成功安装了，再试一次【循环三次 vue init webpack xxx】，不给面子是吧，行算你狠。。。
step2: 瞅着你像个报错连接异常，应该是网络的问题，尝试了直接使用github/webpack路径：下载【https://github.com/vuejs-templates/webpack/releases】，如果可以直接下载压缩文件，解压就可以了，but … 连github 都不给脸好吧，想必你也会遇见这丑恶的的嘴脸。。。
step3: 那就直接手机开热点，连接再执行vue init webpack &lt;项目名&gt;,如上图,干的漂亮，听话快试试吧，别折腾了,等着开工呢。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3b124a2477eb5c95b69c6227bdd95ed/" rel="bookmark">
			RabbitMQ学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文基于尚硅谷发布于 B 站的《尚硅谷2021最新版 RabbitMQ 教程丨快速掌握 MQ 消息中间件》教学视频整理而得
视频地址: https://www.bilibili.com/video/BV1cb4y1o7zz?p=1
尚硅谷官网: http://www.atguigu.com/
什么是 MQ MQ(message queue，消息队列)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游【逻辑解耦+物理解耦】的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务
简单来说，A 向 B 发送消息，则 A 可以称之为【上游】，B 则理所当然称之为【下游】
为什么使用 MQ 流量消峰 现在有一商品订单服务器，可以接受的并发峰值为 10000 / s，某一时刻，商品促销，并发峰值达到 20000 / s，此时，我们有两种选择
在达到 10000 / s 的峰值时，限制用户下单，用户体验相当不好
放任不管，则用户访问超过峰值，商品订单服务器宕机
以上两种选择不论是对用户还是对企业自身，都没有找到一个比较好的平衡点，现在，MQ 的作用就能体现出来，如图
使用 MQ 作为中间通道，将用户的访问存储在消息队列中作为缓冲，分批次发送给订单服务器进行处理，其【先进先出】的理念，保证了用户访问的先后，最终达到，既不必限制用户访问，也不会造成订单服务器宕机的效果
但此种方式也有一定缺点，因为是分批次处理的，造成用户的等待时间相比正常情况下，较长，但是有舍必有得，通过 MQ 的方式来处理大量并发，也算是找到了用户和服务的良好平衡点，毕竟：等待下单总比没法下单要好得多
应用解耦 依然以电商系统为例，此时，有商品订单服务完成订单创建，需要调用【库存系统(削减库存)】【物流系统(生成物流信息)】【支付系统(生成支付信息)】，若此时，某一子系统出现故障，如库存系统出现故障，需要进行紧急修复，在没有使用 MQ 的情况下，系统之间耦合，直接进行相互调用，因为库存系统的故障，导致整个下单操作异常，影响用户下单
但若是使用到了 MQ，服务之间相互调用时，只需要将请求传递给 MQ，通过 MQ 来向其他服务发送相关请求消息，期间若有服务出现异常，可以将相互的请求消息缓存在 MQ 中，待对应的服务恢复后再进行相关消息的处理，这样，服务之间就进行了解耦，如下图
异步处理 有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api (回调)，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callbackapi 。同样 B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3b124a2477eb5c95b69c6227bdd95ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7352da95f6a013d8eba4269c5e1f4d81/" rel="bookmark">
			面试速记之Java SE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 集合ListArrayListVectorLinkedListCopyOnWriteArrayListConcurrentLinkedQueue SetHashSet补充：说说 == 与 equals TreeSetCopyOnWriteArraySet MapHashMapjdk版本对比1.8-1.8+ 时间复杂度存储过程散列表解决hash冲突1.开放地址法2.拉链法 HashTableTreeMapConcurrentHashMap1.71.8 QueuePriorityQueue Iterator迭代器 String注解JDK1.基本Annotation补充函数式接口(Functional Interface) 2.元Annotation@Retention@Target@Documented@Inherited 类型Ⅰ.标记 AnnotationⅡ.元数据 Annotaion 自定义AnnotationQ：如何将注解上信息注入到方法中？作用 泛型相关概念泛型类继承/实现泛型类/接口 泛型方法设置通配符上下限泛型擦除 NIO组成Ⅰ.buffer核心方法核心变量1.Capacity（容量）2.Limit（上界）3.Position（位置）4.Mark（标记） 模式切换缓冲区类型直接缓冲区非直接缓冲区 Ⅱ.ChannelⅢ.Selector 对比 参考资料 集合 List 有序
可重复
有索引
ArrayList 数组
线程不安全
初始容量：10
扩容：1.5倍
结尾会预留空间
修改和查询快
Vector 线程安全，synchronized
扩容：2倍
性能不高
LinkedList 双向循环链表（1.7-）
双向链表（1.7+）
增删快
实现了Deque接口，可当作队列使用
CopyOnWriteArrayList 线程安全的ArrayList
ConcurrentLinkedQueue 线程安全的LinkedList
Set 无序
不可重复
无索引
HashSet 底层是HashMap
添加时，首先判断hashCode，不存在则添加；存在则调equals，false则添加，true则不添加
补充：说说 == 与 equals Object：两者均比较地址
String：==比较地址，重写了equals，比较内容
TreeSet 默认升序
底层是TreeMap
存自定义对象切记实现Comparator接口，并重写compare方法规定排序方式
CopyOnWriteArraySet 线程安全的HashSet
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7352da95f6a013d8eba4269c5e1f4d81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ba464be7d6814341b0db1608f20abc/" rel="bookmark">
			2021超全大数据面试宝典，吐血总结十万字，大数据面试收藏这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文最新版已发布至公众号【五分钟学大数据】
获取此套面试题最新pdf版，请搜索公众号【五分钟学大数据】，对话框发送 面试宝典
扫码获取最新PDF版：
版本
时间
描述
V1.0
2020-02-18
创建
V1.2
2020-06-17
新增 spark 、flink相关面试题
V1.3
2021-03-18
新增 java、JVM、mysql、JUC等
持续更新中… 本文档更新只发于公众号：五分钟学大数据
本套面试题堪称史上最全，既有面试技巧，面试流程，还有技术总结，面试真题，包含算法，Java，Mysql，大数据框架，大数据项目等（持续更新中… 最新版请扫描下方二维码关注公众号：五分钟学大数据，回复【面试宝典】获取）。
第一版是按照大数据技术进行划分(另一版，可在公众号【五分钟学大数据】后台发送 面试 获取)，第二版是综合版 (此版)。
扫码关注公众号，获取最新PDF版：（对话框发送 面试宝典）
目 录
第1章 找工作流程. 1
1.1 学习技能. 1
1.2 编写简历. 1
1.3 投简历. 1
1.4 约面试时间. 1
1.5 面试. 1
1.6 等回复. 1
1.7 拿offer 2
1.8 入职. 2
1.9 准备必备资料，签合同. 2
第2章 面试说明. 2
2.1 笔试. 2
2.2 面试. 3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49ba464be7d6814341b0db1608f20abc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54133ff11bbb74aeb5e5666deb0d723d/" rel="bookmark">
			Ubuntu16.04使用华为4G路由器（随行wifi）USB直连
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@[TOC] Ubuntu16.04使用华为4G路由器（随行wifi）USB直连
Ubuntu16.04使用华为4G路由器（随行wifi）USB直连 我用的工控机开发，没有WIFI网卡，所以要上网只能用网线直连。但我有一个华为随行wifi（Huawei E5573s-856），就不想再拉网线或买一个4G转有线的路由器了。
1.安装usb-modeswitch的软件 qu@qu:~$ sudo apt-get install usb-modeswitch 一般显示已经安装，剩下的就是配置了
2.查看是否读到设备 qu@qu:~$ lsusb 3.修改配置文件 sudo gedit /etc/usb_modeswitch.conf 在文件后面追加
DefaultVendor= 0x12d1 DefaultProduct= 0x1f01 后面为lsusb读到的华为设备的ID号
4.进入/etc/usb_modeswitch.d/目录，创建文件12d1:1f01 cd /etc/usb_modeswitch.d/ sudo vi 12d1:1f01 文件中编辑,编辑完保存后退出
#Huawei E5573s-856 DefaultVendor=0x12d1 DefaultProduct=0x1f01 TargetVendor=0x12d1 TargetProduct=0x14db MessageEndPoint = "0x01" MessageContent="55534243123456780000000000000a11062000000000000100000000000000" 5.激活配置 sudo usb_modeswitch -W -c /etc/usb_modeswitch.d/12d1:1f01 可以上网了。
整体思路就是把USB模拟成Ethernet。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45434ef96155e38ad69a040dca365aa1/" rel="bookmark">
			DoTween详细使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文连接
DoTween 默认配置加上链式调用API风格，配上lambda匿名函数调用，非常简单清晰好用。DoTween实现了通用的缓动算法，能够配置出各种想要的动画效果。另外，队列延迟回调函数，也能完成各种异步延迟执行功能。
DoTween 为各种Unity的对象做了函数绑定，方便调用。比如Transform， Color， Text， Material等都可以直接调用DoTween的动画API。我们先从通用的动画函数来了解。
public static Tweener To(DOGetter&lt;T&gt; getter, DOSetter&lt;T&gt; setter, T endValue, float duration) // 创建一个 Tweener 从当前坐标0.5秒移动到坐标Vector3(100, 100, 100)位置 Tween tween = DOTween.To ( () =&gt; transform.position, (x) =&gt; transform.position = x, new Vector3(100, 100, 00), 0.5f ); 参数T可以是各种数值类型，比如int，float，long ，vector等。getter, setter就是两个代理函数，可以使用匿名函数传入。getter 用来获取当前需要设置的值，setter用来设置当前数值，参数x是有DoTween计算过后的数值。endValue就是最终的数值，duration是使用的时间。和标准的Tween动画是一样的。
getter, setter可以是多条语句的函数，就需要用{}括起来。理解起来就是，DoTween利用传入的两个函数，来获取初始值和每帧设置值，这样就能驱使数值的变化反映到属性上。这里返回tween对象，是为了链式调用，DoTween几乎所有的函数调用都会返回tween对象，能够继续调用其他函数。
DOTween.To ( () =&gt; audio.volume, (v) =&gt; audio.volume = v, 1.0f, 10 ) .OnComplete ( () =&gt; { // 回调执行 } ) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45434ef96155e38ad69a040dca365aa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/365642e318c32410978c0be80c790072/" rel="bookmark">
			iOS之NSKeyedArchiver进行数据归档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		普通数组的归档和解档
普通数组的归档流程：
获得文件归档的路径使用NSKeyedArchiver类的 NSKeyedArchiver+ (BOOL)archiveRootObject:(id)rootObject toFile:(NSString *)path方法将数据归档 //普通数组归档 - (IBAction)onClickBtn1:(id)sender { //沙盒ducument目录 NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0]; //完整的文件路径 NSString *path = [docPath stringByAppendingPathComponent:@"numbers.plist"]; NSArray *numbers = @[@"one",@"two"]; //将数据归档到path文件路径里面 BOOL success = [NSKeyedArchiver archiveRootObject:numbers toFile:path]; if (success) { NSLog(@"文件归档成功"); } } 注：+ (BOOL)archiveRootObject:(id)rootObject toFile:(NSString *)path方法有个BOOL类型的返回值。说明归档操作是有可能失败的。一般来说，归档失败最多的情况有两种：文件路径不存在以及无写入权限。后面会单独讲。
普通数组解档流程：
获得文件归档的路径使用NSKeyedUnarchiver类的+ (nullable id)unarchiveObjectWithFile:(NSString *)path;方法进行解档，读取内容。 //普通数组解档 - (IBAction)onClickBtn2:(id)sender { //沙盒ducument目录 NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0]; //完整的文件路径 NSString *path = [docPath stringByAppendingPathComponent:@"numbers.plist"]; //将path文件路径的数据解档出来 NSArray *numbers = [NSKeyedUnarchiver unarchiveObjectWithFile:path]; NSLog(@"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/365642e318c32410978c0be80c790072/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e902054ad93d23822277621e35394f85/" rel="bookmark">
			如何使用原生的Feign
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Feign Feign 是由 Netflix 团队开发的一款基于 Java 实现的 HTTP client，借鉴了 Retrofit、 JAXRS-2.0、WebSocket 等类库。通过 Feign，我们可以像调用方法一样非常简单地访问 HTTP API。这篇博客将介绍如何使用原生的 Feign，注意，是原生的，不是经过 Spring 层层封装的 Feign。
补充一下，在 maven 仓库中搜索 feign，我们会看到两种 Feign： OpenFeign Feign 和 Netflix Feign。它们有什么区别呢？简单地说，OpenFeign Feign 的前身就是 Netflix Feign，因为 Netflix Feign 从 2016 年开始就不维护了，所以建议还是使用 OpenFeign Feign。
为什么使用Feign 为什么要使用HTTP client 首先，因为 Feign 本身是一款 HTTP client，所以，这里先回答：为什么使用 HTTP client？
假设不用 HTTP client，我们访问 HTTP API 的过程大致如下。是不是相当复杂呢？直接操作 socket 已经非常麻烦了，我们还必须在熟知 HTTP 协议的前提下自行完成报文的组装和解析，代码的复杂程度可想而知。
那么，这个过程是不是可以更简单一些呢？
我们可以发现，在上面的图中，红框的部分是相对通用的，是不是可以把这些逻辑封装起来？基于这样的思考，于是就有了 HTTP client（根据类库的不同，封装的层次会有差异）。
所以，为什么要使用 HTTP client 呢？简单地说，就是为了让我们更方便地访问 HTTP API。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e902054ad93d23822277621e35394f85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cc0efc571050fa1ed4cea8b9c58f8b2/" rel="bookmark">
			普通类，抽象类，接口之间比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 普通类与抽象类有哪些区别？ 1，普通类中不能包含抽象方法，抽象类可以包含抽象方法。 2，抽象类不能直接实例化，普通类可以实例化（实例化：Cat a=new Cat（））； ## 抽象类可以使用final修饰吗？ 不能，抽象类就是用来让其他类继承的，fianl类是最终类，不能被继承。 接口和抽象类有什么区别？ 1，实现：抽象类的子类使用extends来继承；接口则必须使用implements来实现接口。 2，构造函数：抽象类可以有构造函数，接口不能有。 3，实现数量：类可以实现多个接口，但只能继承一个抽象类。 4，访问修饰符：接口中的方法默认使用public修饰，抽象类中可以用任意修饰符修饰方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b4fe6fa9cf916dff3fcb797c1fa734a/" rel="bookmark">
			serializable和parcelable的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Serializable (Java自带）:
Serializable是序列化的意思，表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地。
Parcelable (android专用）:
除了Serializable之外，使用Parcelable也可以实现相同的效果，
不过不同于将对象进行序列化，Parcelable方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是lntent所支持的数据类型，这样也就实现传递对象的功能了。
选择序列化方法的原理· 内存中使用Parcelable
持久化使用Serializable
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67372e47c0ec81dec2fe73c1d5c3a67d/" rel="bookmark">
			常见的计算机网络安全威胁的表现形式,网络安全威胁的的表现形式有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络安全威胁包括似的网络信息被窃听、重传、篡改、拒绝服务攻击，并导致网络行为否认、电子欺骗、非授权访问、传播病毒等问题。
1、窃听：攻击者通过监视网络数据获得敏感信息,从而导致信息泄密。主要表现为网络上的信息被窃听,这种仅窃听而不破坏网络中传输信息的网络侵犯者被称为消极侵犯者。恶意攻击者往往以此为基础,再利用其它工具进行更具破坏性的攻击；
2、重传：攻击者事先获得部分或全部信息,以后将此信息发送给接收者；
3、篡改：攻击者对合法用户之间的通讯信息进行修改、删除、插入,再将伪造的信息发送给接收者,这就是纯粹的信息破坏,这样的网络侵犯者被称为积极侵犯者。积极侵犯者截取网上的信息包,并对之进行更改使之失效,或者故意添加一些有利于自己的信息,起到信息误导的作用；
4、拒绝服务攻击：攻击者通过某种方法使系统响应减慢甚至瘫痪,阻止合法用户获得服务；
5、行为否认：通讯实体否认已经发生的行为；
6 、电子欺骗 通过假冒合法用户的身份来进行网络攻击,从而达到掩盖攻击者真实身份,嫁祸他人的目的；
7、非授权访问：没有预先经过同意,就使用网络或计算机资源被看作非授权访问。它主要有以下几种形式:假冒、身份攻击、非法用户进入网络系统进行违法操作、合法用户以未授权方式进行操作等；
8、传播病毒、通过网络传播计算机病毒,其破坏性非常高,而且用户很难防范。如众所周知的CIH病毒、爱虫病毒、红色代码、尼姆达病毒、求职信、欢乐时光病毒等都具有极大的破坏性,严重的可使整个网络陷入瘫痪。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca508f4f4a7ded7c81599a7f46bc2c1/" rel="bookmark">
			北大软微计算机技术硕士复试,2016北大软微考研复试细节和名单.doc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档介绍：
北大软微考研复试细节和名单根据北京大学研究生院的工作安排,并结合我院的具体情况,现将年硕士研究生复试、录取阶段的工作安排说明如下:一、复试时间、地点:复试时间:月、日;复试地点:软件与微电子学院(大兴校区)(地址:北京市大兴工业开发区金苑路号)。乘车路线:北京站:地铁二号线宣武门站换乘地铁四号线高米店南站下车,C口出站,在金星西路打车或者乘兴路到福苑东区站下车,北行米路东。北京西站:地铁九号线国家图书馆站换乘地铁四号线高米店南站下车,C口出站,在金星西路打车或者乘兴路到福苑东区站下车,北行米路东。北京南站:地铁四号线高米店南站下车,C口出站,在金星西路打车或者乘兴路到福苑东区站下车,北行米路东。复试分为两部分:英语听力考试、面试。英语听力时间为月日、日:—:(:停止入场),面试时间为月日、日:,各位考生的具体复试时间、地点安排请见复试通知书。请考生务必于月、日到北京大学本部理科一号楼室领取复试通知书,复试费可以在领取通知书时上交。二、录取原则:按照各招生专业方向及考试类别分组,差额复试。复试以综合面试为主,对综合能力较强且具备今后专业学****能力的考生才考虑予以录取。综合面试重点考核考生基础知识的掌握、编程语言的掌握、工程实践(或项目管理)能力、语言表达能力、英语能力、逻辑思维以及综合能力。报考计算机动画创作、交互媒体、数字影视制作、数字娱乐技术、艺术设计方向的考生,复试之前需提交一份以上本人专业作品。作品的形式、内容不限,能充分体现个人专业水平即可。不能提供作品者,取消其综合面试的资格。对同等学力考生,除正常参加复试外,需加试两门专业课;总成绩=初试权重*初试门总成绩/+复试成绩(换算成百分制)*复试权重+外语听力成绩(换算成分制)。初试权重为%,复试权重为%。复试成绩采用百分制记分,分为及格。复试成绩不合格的考生不予录取。三、复试学生名单:国家考生编号姓名王辰余星星常瀛修康晓非谈家桐白云鹤卜宏哲曹硕曹威常堃陈大晟陈冠林程志强陈立陈敏龙陈楠陈鹏陈平平陈庆平陈则吾迟蕊沂迟鑫崔璇戴晶晶邓娟邓雅妮董纪杜知昊冯辰翔高雷雷高丕基高天放高雅高正坤郭莉莉郭梦溪郭禹呈郭子扬韩勤韩泽洋何寒松何苏何中艺华传洲黄梦龙胡彬胡盖蕾胡伟佳胡勇硕冷睿梁爽黎浩然李金哲李林松林栋柳豹刘卜源刘代夏刘芳作刘鸿刘建岐刘玫燚刘沫含刘书元
内容来自淘豆网www.taodocs.com转载请标明出处.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67e5f8c8941df24b303b5c022d4d0caf/" rel="bookmark">
			2020北大复试计算机技术名单,2020北大软微学院集成电路工程考研录取名单，复试分数线，考试科目，参考书目...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学院于2002年3月成立至今，已初步形成了一个学院(北京大学软件与微电子学院)、两个学科(软件工程学科、集成电路设计与工程学科)、四个基地(国家软件人才国际培训(北京)基地、国家集成电路人才培养基地、软件工程国家工程研究中心北京工程化基地、北大软件与微电子学院无锡产学研合作教育基地)的综合性软件与微电子人才培养实体。目前，学院以培养软件工程、集成电路工程、项目管理、电子与通信工程4个领域的工程硕士为主体。学院以脱产、在职的培养方式，发展至今，形成了每年可为国家培养1000名左右的工程硕士研究生的规模。
二、考试科目
集成电路工程研究方向：
01. 集成电路设计与工程
02. 智能系统集成技术
03. 半导体能源技术及应用
考试科目：
① 101 思想政治理论
② 201 英语一
③ 301 数学一
④ 833 集成电路基础
计划招生50人，其中推免12人。
三、参考书目
833 集成电路基础
《电子技术基础》(数字部分) 康华光 高等教育出版社
301数学一
高数教材：《高等数学》——同济版;
线代教材：《线性代数》——同济版、清华版;
概率教材：《概率论与数理统计》——浙江大学盛骤版
考研数学复习全书推荐的有：
《数学复习全书》——李永乐;
《线性代数辅导讲义》——李永乐;
《高数18讲》——张宇
考研数学真题、习题类推荐的依次有：
《数学历年真题解析》——李永乐;
《数学基础过关660题》——李永乐;
《全真模拟经典400题》——李永乐;
四、复试分数线
集成电路工程：总分/政治/外语/数学一/专业课
2019年：300/55/55/90/90
2018年：300/50/50/90/90
2017年：300/50/45/80/80
2016年：290/50/45/80/80
五、复试
1.按照各招生专业方向及考试类别分组，差额复试。
2.复试以综合面试为主，对综合能力较强且具备今后专业学习能力的考生予以择优录取。综合面试重点考核考生基础知识的掌握、编程语言的掌握、工程实践(或项目管理)能力、语言表达能力、英语能力、逻辑思维以及综合能力。
3.对同等学力考生，除正常参加复试外，需加试两门专业课。
4.总成绩＝初试权重*初试4门总成绩/5＋复试成绩*复试权重。初试权重为70%，复试权重为30%。
5.复试成绩采用百分制记分，60分为及格。复试成绩不合格的考生不予录取。
六、录取名单
七、复习经验
专业课建议大家考数电逻辑，因为每年的考生90%选择的是这门课，相应的资料多很多，电子线路(模电+数电)，普物，半导体相应的考生比较少，资料也少-些。我建议学弟学妹们应该把书本先大致看一遍,这样对于课本有个大概了解，然后再来认认真真的跟老师学，认真做课后习题完成老师布置的要求，这样哪怕变化再大,120+的分数是很容易达到的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6760f0f5b893b453f657dab86f98a6ae/" rel="bookmark">
			method ＜init＞()V not found解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息： java.lang.NoSuchMethodError: org.apache.flink.streaming.connectors.elasticsearch7.ElasticsearchSink: method &lt;init&gt;()V not found 产生原因： method ()V not found这种原因就是没找到正确的无参构造方法：
引用的类里面没有无参构造方法引用的类出现冲突，有两个或以上的方法被捕获，但是系统无法判断用哪个 我的问题： 出于某种原因，我需要继承flink-connector-es的ElasticsearchSink这个类，但是这个类的构造方法是private，只提供了一个builder，不允许继承，于是我就把源码扒出来，把private改成了public，并且加了一个无参构造方法，然后顺利的继承了这个类，但是没有注意的是，我项目的路径名和ElasticsearchSink源码包路径名完全一样，导致打jar包的时候，源码ElasticsearchSink类和我自己改造的ElasticsearchSink类打到同一个目录下了，然后代码在运行的时候就报了上述错误。
总结： 但凡是属于java.lang.NoSuchMethodError这中错误的通常就是两种情况，一是没有找到这个依赖，需要重新引入，二是找到了多个依赖，可能是多版本的情况，也可能是打包打到同一个包去了。排查办法就是先排查依赖，可以用maven的show dependencie，或者idea的Dependency Analyzer插件，排查是否缺少依赖或着是否有依赖冲突，然后确定一个版本就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a794cfbcb4c4a94949b28e6e3493b8e4/" rel="bookmark">
			Vue-cli脚手架的创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、DOS环境下 DOS常用基本命令：这会使用这些就能创建项目了
cd 打开文件夹，如（E:\cd proj）dir查看文件夹内容，如（E:\ dir proj）md创建新文件夹，如（E:\ md proj）cd..返回上一级文件夹，如（E:\ cd ..）cls清屏 二、vue-cli安装
在DOS环境下输入以下命令：
vue-cli2的安装：cnpm install -gd vue-clivue-cli3的安装：普通安装：npm install -g @vue/cli、淘宝镜像安装：cnpm install -g @vue/cli（选择一个安装即可） 三、vue-cli的项目创建
有一些默认的选项，按个人项目需求进行选择。
vue-cli2：vue init webpack projvue-cli3：vue create proj 四、vue-cli项目启动
vue-cli2：npm run devvue-cli3：npm run serve 直到出现一个一个网址：http://localhost:8080/即为启动成功
如果项目运行失败重新安装一下环境依赖一般都会得到解决
失败时运行一遍：cnpm install 或 cnmp install -g （在文件夹中安装依赖环境）
然后在启动项目即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12cac568b5e3de2872b15c5f925aacea/" rel="bookmark">
			nodejs&#43;rabbitmq实现任务延迟执行与重试控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以发送邮件任务为例，第一次发送邮件失败后，延时30s后继续发送此邮件，如果如此重试3次后仍然失败，则停止发送。
send_email: 发送邮件任务队列(死信队列)send_email_retry: 发送邮件任务重试队列send_email_fail: 发送邮件任务失败队列 生产者 创建send_email队列，并给队列绑定交换机exchange和路由routingkey await ch.assertQueue(queue_send_email, { durable: true }) await ch.assertExchange(dlx_routing_exchange) await ch.bindQueue(queue_send_email,dlx_routing_exchange, dlx_routing_key) 创建queue_retry队列，指定死信交换机deadLetterExchange和死信路由deadLetterRoutingKey以及队列消息过期时间messageTtl
可以发现我们指定的queue_retry队列的死信交换机和死信路由和queue_email队列声明的交换机和路由一致。这样只要queue_retry队列中的消息过期后，就会自动从queue_retry队列转移到queue_email队列,而queue_email的消费者又可以消费了，这样就实现了延迟消费。而被死信交换机和死信路由绑定的队列(queue_email)就叫做 死信队列。 await ch.assertQueue(queue_retry, { durable: true, deadLetterExchange: dlx_routing_exchange, deadLetterRoutingKey: dlx_routing_key, messageTtl: 30 * 1000 }) 创建queue_fail队列
失败队列主要就是存储重试3次后仍然失败的发邮件任务，供人工查看。 await ch.assertQueue(queue_fail, { durable: true }) 生产者创建发送邮件任务到queue_email队列
注意: 在headers中指定了一个count参数，用来标识重试的次数 await ch.sendToQueue(queue, Buffer.from('发送邮件'), { deliveryMode: true, headers: { count } }) 消费者 await ch.consume(queue, (msg) =&gt; { //获取重试的次数 let retryCount = msg.properties.headers.count const result = sendEmail(); if (result) { //发送成功 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12cac568b5e3de2872b15c5f925aacea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2473fe5d24e7c8d9cc0a34d305c9dac3/" rel="bookmark">
			vs布局之解决vs界面左、右边窗口关闭如何显示问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景模拟场景恢复窗口其他常见情况我的情况 感言 背景 如标题所示，这个问题老实说困扰了不少人。。。。当然也困扰了我好大一会，大学那会学c#的时候使用的是vs2017，但是对于vs2017许久不用，然后现在因为要设计报表又使用到了vs2008.
探究加百度了好一会但是，莫得结果。。。。自己捣鼓了一番才解决。
模拟场景 当我们大家vs的时候，默认的窗口布局是这样的，此处以vs2008为例，如下：
然后我们可以将左边的工具箱，右边的解决方案属性都关闭，就变成下面这样的了：
恢复窗口 如何恢复勒？
有两种方式，第一种是一个一个恢复，如下：
这样是能够恢复成原样的。并且在视图中有许多选项，都可以在我们不小心关闭之后恢复出来。
第二种是直接一键恢复，如下：
这样也会恢复，恢复如下：
其他 常见情况 这里自己要设计报表，然后有一个报表数据，默认报表数据的布局是这样的，如下：
当我不小心将这个报表数据关闭之后，我们仍然需要在视图中去寻找，如下：
当然也可以直接使用快捷键，crtl+alt+d；之后就会恢复成原来那样。
我的情况 但是，实际上我还遇到了另一种情况，就是当我们设置了报表数据的显示方式的时候，我这里设置自动隐藏，如下：
自动隐藏之后，显示如下：
之后嫌弃自动隐藏太慢了，又将其设置为可停靠。。。。。
然后我就很手贱的将这个报表拉动了。。。。。拉动成下面这个样子，并且我自己也不知道怎么拉出来的。。。。。如下：
之后我就将这个报表数据给关闭了。。。。。。因为我想着反正可在视图上显示出来恢复原样，所以就关了。。。。
关了之后，当我关了之后第一次点视图的时候，没了报表数据。。。。。。如下：
之后无论点击多少次都没有报表数据这个了。。。。。
然后就百度了好久。。。。都没有结果。
再之后，我也点击了n次恢复默认窗口布局，然而报表数据依旧显示不出来。。。。。。。。
抱着不死心的态度，我又点视图，这个时候又显示出了报表数据了。。。。。。。很玄乎。。。。有鬼。。。。
后来我研究了一会，发现当我关闭报表数据的时候，需要点击一下vs报表界面：
当我们点击之后，在上面的栏目中出现报表的时候，就代表报表数据在视图中存在了，如下：
、
还有就是可以先重置窗口布局，这样也会在栏目上显示出报表，然后点击视图，就也可以显示出这个报表数据了。
以为到这就完了？
并没有！！！！！
在我一开始不知道操作的时候，采用的是点击了报表界面的方法；当我点击报表界面之后，再在视图中显示出报表数据的时候，这个报表数据并不会显示为默认的在左边显示，而是显示为之前拉出来的样子。。。。 对于我这强迫症而言，再加上拉出来不好操作，显示也不清楚。
还是要解决才行。
然后我就瞎操作一番，才发现需要选中报表数据的上方，并且长按鼠标左键，就会显示如下：
然后将其往左滑，并且按照如下操作：
害，到这终于解决了！！！
还是选择先重置窗口布局好些，就没那么麻烦。。。。。
感言 这个问题虽小，但是还是要花费一番功夫才能捋清的！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc752df5847a3779e5c02b0f7a5b63c4/" rel="bookmark">
			北大计算机考研复试线,北京大学计算机考研分数线及报录比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		北京大学计算机考研分数线高吗?北京大学计算机历年报录比有多高?
最近三年分数线：
专业名称
2017年
单科
=100
单科
&gt;100
总分
信息学院
计算机科学与技术
50
90
350
专业名称
2018年
单科
=100
单科
&gt;100
总分
信息学院
计算机科学与技术
50
90
310
软微学院
软件工程
50
90
310
计算机技术(专业学位)
政治：50
英语：45
80
340/300
软件工程(专业学位)
80
300
数据科学(计算机科学与技术)/数据科学(软件工程)
50
90
300
专业名称
2019年
单科
=100
单科
&gt;100
总分
信息学院
计算机科学与技术
50
90
360
软微学院
软件工程
50
90
/
计算机技术(专业学位)
50
90
360/340
软件工程(专业学位)
50
90
340
数据科学(计算机科学与技术)/数据科学(软件工程)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc752df5847a3779e5c02b0f7a5b63c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f68300ee66c14212931587101dda2c60/" rel="bookmark">
			活体检测：keras
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日萌社 人工智能AI：Keras PyTorch MXNet TensorFlow PaddlePaddle 深度学习实战（不定时更新）
1. 什么是活体检测？ --&gt; 判断捕捉到的人脸是真实人脸，还是伪造的人脸攻击（如：彩色纸张打印人脸图，电子设备屏幕中的人脸数字图像 以及 面具 等） 2. 为什么需要活体检测？ --&gt; 在金融支付，门禁等应用场景，活体检测一般是嵌套在人脸检测与人脸识别or验证中的模块，用来验证是否用户真实本人 3. 活体检测对应的计算机视觉问题： --&gt; 就是分类问题，可看成二分类（真 or 假）；也可看成多分类（真人，纸张攻击，屏幕攻击，面具攻击） 据《人民日报》报道，嘉兴上外秀洲外国语学校402班科学小队向都市快报《好奇实验室》报料：他们在一次课外科学实验中发现，只要用一张打印照片就能代替真人刷脸，骗过小区里的快递智能柜，最终取出父母们的货件。随后，小朋友们还发来了几段视频佐证。
据《人民日报》报道，嘉兴上外秀洲外国语学校402班科学小队向都市快报《好奇实验室》报料：他们在一次课外科学实验中发现，只要用一张打印照片就能代替真人刷脸，骗过小区里的快递智能柜，最终取出父母们的货件。随后，小朋友们还发来了几段视频佐证。
生物识别技术在验证过程中出现的漏洞可能会让不法分子破解各种人脸识别应用，包括苹果的 Face ID。 在拉斯维加斯举办的 2019 世界黑帽（Black Hat）安全大会上，腾讯公司的研究人员演示了攻破苹果 Face ID 的法宝：一款特制眼镜。这幅眼镜镜片上贴有黑色胶带，黑色胶带中心还贴有白色胶带。
在演示中，研究人员只需要将这款眼镜戴在受害者的脸上即可解锁 Face ID，访问手机。但是，鉴于不法分子需要在不唤醒受害者的情况下把眼镜戴在他/她的脸上，所以这种攻击本身存在难度。 在攻破苹果 Face ID 的过程中，研究人员利用了生物识别技术背后的「活体检测」功能。活体检测是筛选人们「真假」特征的生物识别认证过程中的一部分，其原理是检测背景噪声、响应失真或聚焦模糊。苹果公司在 iPhone 和 iPad Pro 的 Face ID 人脸识别系统中使用的就是这种活体检测功能。
腾讯安全研究人员马卓（Zhuo Ma）认为，虽然以前的攻击主要聚焦于制作假数据来欺骗生物识别技术，但这种类型的音频或视频攻击由各种部分组成，包括窃取受害者设备的指纹信息、生成假音频或视频以及硬件层面的侵入破解等。 而在此次攻击实验中，研究人员决定聚焦于活体检测（允许用户扫一眼即可解锁手机），从而希望在受害者意识不清醒的时候通过面部来欺骗 Face ID。 但是，马卓还表示：「这种操作非常具有挑战性，我们不能吵醒正在熟睡的受害者，同时 3D 系统的伪造也存在诸多困难... 所以我们需要找到一种成本低但成功率高的解决方案。」
利用活体检测破解 FaceID 研究人员专门研究了活体检测如何扫描用户眼睛。他们发现，活体检测对人眼的抽象化处理是在黑色区域（人眼）上嵌上白点（虹膜），即以黑区+白点的形式来模拟眼睛和虹膜。此外，如果用户戴上眼镜，活体检测扫描眼睛的方式也会出现变化。 研究人员发现了苹果 Face ID 的漏洞，即用户戴着眼镜时也能解锁手机。当 Face ID 识别到用户戴着眼镜时，就会自动跳过对眼部区域 3D 信息的提取。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f68300ee66c14212931587101dda2c60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c265712a77d1b9a5eb67240e833c2e2/" rel="bookmark">
			TimeQuest Timing Analyzer简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
时序约束错误
一：TimingQuest Timing Analyzer
二：TimeQuest_Timing Analyzer Wizard
软件版本：Quartus ii 13.0sp1
时序约束错误 如下图出现时序约束错误
一：TimingQuest Timing Analyzer 1：tools-&gt;TimingQuest Timing Analyzer打开时序约束文件
2：创建时序分析网表
点击Netlist-&gt;Create Timing Netlist来创建一个新的网表约束网表，由于输入的门级网表是综合后适配的因此选择post-fit。
speed grade 是跟器件有关。设置成功点击ok
3：创建时钟
Constraints-&gt;Create Clock,在对话框中填写系统时钟信息。
Clock name可以自己命名，之后将其与实际的时钟端口对应就可以
period与实际周期一致，我使用（周期20ns，频率为50MHz）
waveform edges ：选择上升沿，下降沿
Targets为对应的时钟管脚，这里对应了CLOCK_50.
然后点击run。
注意出现错误
Targets 输入命令get_ports 中间应该应该添加空格 {clk}；clk为实际对应的管脚。
如上图并不会出现上述错误。
4：设置非理想时钟。
我们所使用的时钟都是非理想的，一般要给时钟留余量
latency是寄存器时钟信号与时钟源信号之间的相位差，uncertainty是寄存器与寄存器之间的时钟相位差，在此时uncertainty进行设置
uncertainty-&gt;SetClock Uncertainty,设置时钟源的setup uncertainty为1ns
5:Constraints-&gt;Derive PLL Clocks
直接生成pll时序约束
6：查看tasks页面中的diagnostic-Report Clocks中可以查看时钟约束情况
7：写出SDC文件
Constraints-&gt;Write SDC Files,保存文件
8：查看SDC文件
在work文件夹下可以查看.sdc文件，其中为对应的tcl时序约束脚本。
9：添加约束文件
Assignments-&gt;Settings-&gt;TimeQuest Timing Analyzer ,点击添加.sdc文件
二：TimeQuest_Timing Analyzer Wizard 另外一种使用快捷向导 Assignments-&gt;TimeQuest_Timing Analyzer Wizard
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c265712a77d1b9a5eb67240e833c2e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44636c332b728d716e502793b4b6d673/" rel="bookmark">
			C/C&#43;&#43; 取整函数ceil(),floor()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用floor函数。floor(x)返回的是小于或等于x的最大整数。
如： floor(10.5) == 10 floor(-10.5) == -11
使用ceil函数。ceil(x)返回的是大于x的最小整数。
如： ceil(10.5) == 11 ceil(-10.5) ==-10
floor()是向负无穷大舍入，floor(-10.5) == -11；
ceil()是向正无穷大舍入，ceil(-10.5) == -10
fix
朝零方向取整，如fix(-1.3)=-1; fix(1.3)=1;
floor
朝负无穷方向取整，如floor(-1.3)=-2; floor(1.3)=1;
ceil
朝正无穷方向取整，如ceil(-1.3)=-1; ceil(1.3)=2;
round
四舍五入到最近的整数，如round(-1.3)=-1;round(-1.52)=-2;round(1.3)=1;round(1.52)=2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18eb6ca3399969e40d6dca02dd3996f9/" rel="bookmark">
			ARM仿真器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RAM V11串口配置
1、Jlink的驱动版本最好是V5.12以上，或者是V5.12。
2、打开安装Jlink的文件目录SEGGER，在目录中找到J-Link Commander程序。
3、首先在命令窗口中执行si 0
4、再执行命令vcom enable。
5、最后重新上电J-Link，可以看到J-Link的串口端口如下。
============================================================================
======================================================================
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9cc4b076f6e8c16b9bfc36552d275d2/" rel="bookmark">
			C&#43;&#43;产生随机数的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用cstdlib库 C++11之前，C和C++都用相同的方法来产生随机数（伪随机数），即rand()函数，用法如下：
1）使用srand()撒一个种子 功能：初始化随机数发生器
用法：void srand(unsigned int seed)
2）使用rand()产生随机数 功能：随机数发生器
用法：int rand(void)
3）控制随机数范围 要取得 [a,b) 的随机整数，使用 (rand() % (b-a))+ a;
要取得 [a,b] 的随机整数，使用 (rand() % (b-a+1))+ a;
要取得 (a,b] 的随机整数，使用 (rand() % (b-a))+ a + 1;
** 参考：C++ rand 与 srand 的用法
4）示例代码 #include &lt;iostream&gt; #include &lt;ctime&gt; #include &lt;cstdlib&gt; int getRand(int min, int max); int main() { srand(time(0)); for (int i=0; i&lt;10; i++) { int r = getRand(2,20); std::cout &lt;&lt; r &lt;&lt; std::endl; } return 0; } // 左闭右闭区间 int getRand(int min, int max) { return ( rand() % (max - min + 1) ) + min ; } 使用random库：c++11 random library C++11之前，无论是C，还是C++都使用相同方式的来生成随机数，而在C++11中提供了随机数库，包括随机数引擎类、随机数分布类，简介如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9cc4b076f6e8c16b9bfc36552d275d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d430ad594508a87122e8f63e2dd3ce4/" rel="bookmark">
			红黑二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		红黑二叉树简单了解 由于还没有深挖：就先简单的说明一下它的几个特点。
红黑树：
顾名思义，是我们平时最常用的平衡二叉查找树，平衡属性：任意节点左右的子树高度相差不大于一。
平衡属性：任意节点左右子树高度相差不大于一。
性质：1，根结点是黑色。叶节点是不存储数据的黑色空节点。
2，任何相邻的两个节点都不能同时为红色，并且红色节点的子节点一定是黑色的 。
3，任意节点到其可到达的叶节点间 包含相同数量的黑色空节点。
**##**n个节点的红黑二叉树，高度不超过
2（log（N+1））。
**##**完全二叉树的 高度是log（N）
**##**AVL严格的二叉树，查找效率不超过log（N）：不善于有频繁的删除，查找，插入等操作的结构，而红黑 二叉树不存在这样的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a099c4fbe61b5a1b20bd53e45e8d14cd/" rel="bookmark">
			XSS远程代码执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DOM型 脏数据的输入 1、document.referer
以上代码输出了document.referer属性，而第一次访问该页面的时候并没有该属性，所以我们构造一个含有脚本代码的url来产生referer，当单击连接时，便能执行XSS代码
2、location 使用location.href能管理页面法人URL
脏数据输出 输出在这里指定是能使字符串在页面中输出的方法或函数，比如innerHTML、document.write等	1、测试和发掘DOM型XSS输出对对象的流程 跟踪输出函数的变量，比如首先找到document.write等会造成危害的地方，然后回溯变量与函数的调用过程，查看用户能否控制输入
存储型 输入代码后不立即执行而是存储到数据库中， 再次访问存储代码的那个数据库条目就会执行输入的代码 读取document.cookie时会得到当前文档的所有cookie 存储型XSS可以通过使用beef来使用可以使得操作时获取更多的方便与更多的内容
反射型 反射型XSS攻击类似于DOM型
Document 对象属性 body 提供对 元素的直接访问。对于定义了框架集的文档，该属性引用最外层的 。
cookie 设置或返回与当前文档有关的所有 cookie。
domain 返回当前文档的域名。
lastModified 返回文档被最后修改的日期和时间。
referrer 返回载入当前文档的文档的 URL。
title 返回当前文档的标题。
URL 返回当前文档的 URL。
Document 对象方法 方法 描述
close() 关闭用 document.open() 方法打开的输出流，并显示选定的数据。
getElementById() 返回对拥有指定 id 的第一个对象的引用。
getElementsByName() 返回带有指定名称的对象集合。
getElementsByTagName() 返回带有指定标签名的对象集合。
open() 打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出。
write() 向文档写 HTML 表达式 或 JavaScript 代码。
writeln() 等同于 write() 方法，不同的是在每个表达式之后写一个换行符。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a099c4fbe61b5a1b20bd53e45e8d14cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08814ee2e4a489721c77dc5ee847b133/" rel="bookmark">
			linux的epel源配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		epel源的配置是基于网络的。首先你的服务器需要能连接外网，其次它能够DNS解析。
连接外网测试：ping 8.8.8.8
DNS解析测试：ping www.baidu.com
都要保证能通，表示电脑的网络连接没有问题，下面就来配置外面的yum文件
关于系统自带的repo文件在配置本地yum的是时候就已经说过了，不懂的可以看我的上一篇文章。
vim /etc/yum.repos.d/epel.repo
注意：--为注释
[epel] --配置epel源
name=epel --指定名称
baseurl=https://mirrors.aliyun.com/centos/7/os/x86_64/ --配置源的获取位置我这里指向了阿里源，也可以知道别的源，网上有很多。这里所指向的位置就是repodata的上级目录
gpgcheck=0 --0表示不做密钥检查，1表示做密钥检查
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf4d1d0f2d06b8d2e08c7251a86763b/" rel="bookmark">
			应用进程退出原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Android 11 引入了 ActivityManager.getHistoricalProcessExitReasons() 方法，用于报告近期任何进程终止的原因。应用可以使用此方法收集崩溃诊断信息，例如进程终止是由于 ANR、内存问题还是其他原因所致。
一、getHistoricalProcessExitReasons应用进程退出原因 经过一份测试后，然后对照官方文档，仔细阅读后，发现getHistoricalProcessExitReasons这个方法是获取历史进程退出原因的方法。
注意：系统将此历史信息存储在环形缓冲区中，只会返回最近的记录。
packageName: String, 包名 pid: Int, （A process ID that used to belong to this package but died later; a value of 0 means to ignore this parameter and return all matching records. Value is 0 or greater） maxNum: Int 异常的数量 ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
List exitInfoList = activityManager.getHistoricalProcessExitReasons(getPackageName(),
0, 5);
注意：某些设备无法报告内存不足终止事件。在这些设备上，getHistoricalProcessExitReasons() 方法会返回 REASON_SIGNALED 而不是 REASON_LOW_MEMORY，并且 getStatus() 的返回值为 SIGKILL。 如需检查设备是否可以报告内存不足终止事件，请调用 ActivityManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faf4d1d0f2d06b8d2e08c7251a86763b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/350/">«</a>
	<span class="pagination__item pagination__item--current">351/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/352/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>