<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dc52c7b45544bc4130efc03f22b756e/" rel="bookmark">
			C语言-字符型数据与ASCII码表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、字符型常量 字符型常量指单个字符，是用一对单引号及其所括起来的字符表示。例如：‘A’、‘a’、‘0’、’$‘等都是字符型常量。
C语言的字符使用的就是ASCII字符集，总共有128个，每个相应的ASCII码都表示一个字符：
（1）每一个字符都有唯一的次序值，即ASCII码。
（2）数字’0’，‘1’，‘2’，…，‘9’、大写字母’A’，‘B’，‘C’，…，‘Z’、小写字母’a’，‘b’，‘c’，…，'z’的ASCII都是升序连续排列的。
注： 数字和数字字符不一样的，带单引号的是字符，例如:1是整型数字，而’1’是字符，其ASCII码是49，即按整型输出的话就是49，按字符型数据输出就是1。
ASCII码表：
符号（解释）十进制十六进制符号（解释）十进制十六进制NULL（空操作）00x00@640x40SOH（标题开始）10x01A650x41STX（正文开始）20x02B660x42ETX（正文结束）30x03C670x43EOT（传输结束）40x04D680x44ENQ（请求）50x05E690x45ACK（收到通知）60x06F700x46BEL（响铃）70x07G710x47BS（退格）80x08H720x48HT（水平制表符）90x09I730x49LF（换行）100x0AJ740x4AVT（垂直制表符）110x0BK750x4BFF（换页）120x0CL760x4CCR（回车）130x0DM770x4DSO（不用切换）140x0EN780x4ESI（启用切换）150x0FO790x4FDLE（数据链路转义）160x10P800x50DC1（设备控制1）170x11Q810x51DC2（设备控制2）180x12R820x52DC3（设备控制3）190x13S830x53DC4（设备控制4）200x14T840x54NAK（拒绝接收）210x15U850x55SYN（同步空闲）220x16V860x56ETB（结束传输块）230x17W870x57CAN（取消）240x18X880x58EM（媒介结束）250x19Y890x59SUB（代替）260x1AZ900x5AESC（换码（溢出））270x1B[910x5BFS（文件分隔符）280x1C\920x5CGS（分组符）290x1D]930x5DRS（记录分隔符）300x1E^940x5EUS（单元分隔符）310x1F_950x5F(space)（空格）320x20`960x60!330x21a970x61"340x22b980x62#350x23c990x63$360x24d1000x64%370x25e1010x65&amp;380x26f1020x66’390x27g1030x67(400x28h1040x68)410x29i1050x69*420x2Aj1060x6A+430x2Bk1070x6B,440x2Cl1080x6C-450x2Dm1090x6D.460x2En1100x6E/470x2Fo1110x6F0480x30p1120x701490x31q1130x712500x32r1140x723510x33s1150x734520x32t1160x745530x35u1170x756540x36v1180x767550x37w1190x778560x38x1200x789570x39y1210x79:580x3Az1220x7A;590x3B{1230x7B&lt;600x3C|1240x7C=610x3D}1250x7D&gt;620x3E~1260x7E?630x3FDEL（删除）1270x7F 2、字符型变量 用char定义的变量为字符型变量。例如：char op; 定义了一个字符型变量op，其数据类型为char型，即字符型数据。可以对其进行赋值，例如op='*'就是将字符型常量’*‘赋值给变量op。
字符型变量在计算机中是按照ASCII码的值来存储的，可以和整形数据进行运算，其运算规格类似，例如：op = '*'+1;，那么op按字符型数据输出就是’+’，按整型数据输出就是43。
3、字符型数据的输入输出 (1)scanf()和printf()函数输入输出字符 scanf()和printf()函数进行字符型数据的输入输出和整型浮点型的处理方式完全一样，只是格式控制字符串中相应的格式控制说明为%c。
(2)字符输入函数getchar() getchar()函数可以从键盘输入一个字符。其一般用法为：
char ch; ch = getchar(); 这句话就是从键盘输入一个字符，并将其赋给变量ch。
(3)字符输出函数putchar() putchar()函数是输出一个字符。其一般用法为：
putchar(输出参数); 输出参数是字符型变量或者字符型常量。
注： 使用getchar()函数和putchar()函数同样需要先包含头文件#include &lt;stdio.h&gt;
函数getchar()和putchar()分别只能输入和输出一个字符，若要处理多个字符的输出和输出，那么一般需要采用循环的方式多次调用该函数。例如下面的代码为输入8个字符，然后将这8个字符再输出，每两个字符中间添加一个’-’。
#include &lt;stdio.h&gt; int main(void) { char ch int first = 1, k;	/*first的值表示将要处理的是否为输入的第一个字符*/ printf("Enter 8 characters:"); for (k=1; k&lt;=8; k++) { ch = getchar();	/*变量ch接收从键盘输入的一个字符*/ if (first == 1) { putchar(ch);	/*输出存放在变量ch中的字符*/ first = 0;	/*处理完第1个字符，清楚标志位*/ } else {	/*处理第2个及以后的字符*/ putchar('-'); /*输出字符常量'-'*/ putchar(ch); /*输出存放在变量ch中的字符*/ } } } 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dc52c7b45544bc4130efc03f22b756e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0328cabd46e01fb5b4393afe393c85f3/" rel="bookmark">
			【Java SE】数组的定义与使用；数组的使用；如何理解引用，形参，实参；二分查找；冒泡排序；数组逆置；数组的拷贝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组的定义与使用 文章目录 数组的定义与使用1. 数组基本用法1.1 什么是数组1.2 创建数组1.3 数组的使用1.获取长度2.访问元素3.修改元素4.输出数组 2. 数组作为方法的参数2.1 基本用法2.2 如何理解引用，形参，实参(重点)2.3 认识null2.4 初识JVM内存区域划分 3. 数组作为方法的返回值4. 数组练习4.1 实现一个自己版本的数组转字符串4.2 输出一个数组中的最大值4.3 给定一个整型数组，求出数组中元素的平均值4.4 无序数组找某个元素的下标4.5 有序数组找某个元素的下标（二分查找）4.6 判断一个整型数组是否是升序的4.7 数组排序（冒泡排序）4.8 数组排序 用Arrays.sort排序4.9 用Arrays.fill 填充数组4.10 数组逆置4.11 整型数组数字排列，偶数在前，奇数在后4.12 数组的拷贝 5. 二维数组 1. 数组基本用法 1.1 什么是数组 数组的本质就是让我们能“批量”创建相同类型的变量
例如：
如果要创建两个变量： int a; int b;
如果要创建多个变量，就需要使用数组
注意事项：在Java中，数组中包含的变量必须的相同类型
1.2 创建数组 基本语法：
数据类型[ ] 数组名称 = {初始化数据}
数据类型[ ] 数组名称 = new 数据类型 [ 数组大小 ]
数据类型[ ] 数组名称 = new 数据类型[ ] {初始化数据}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0328cabd46e01fb5b4393afe393c85f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd9617afc98d07cf42eff1172ffd481a/" rel="bookmark">
			xml.etree.ElementTree.ParseError: not well-formed (invalid token): line 1, column 0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 今天在将目标检测的数据集从xml文件转成txt文件的时候，突然报错
，报错代码如下
xml.etree.ElementTree.ParseError: not well-formed (invalid token): line 1, column 0 } 原因分析： 在网上查了一些方法，发现解决的方法很少，大部分都是说第一行不匹配，但是我的xml都是自己用labeling标注的，总感觉没有问题，最后将转换后的路径打印出来才恍然大悟，原因是以前的文件夹里有非xml文件，完全是自己粗心导致，请大家以此为鉴
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f14b7d75aba6221a6a4abff9dd14761a/" rel="bookmark">
			面向对象 和 面向过程 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、面向对象与面向过程的区别 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。
其实就是两句话，面向对象就是高度实物抽象化、面向过程就是自顶向下的编程！
二、面向对象的特点 对象：现实中任何事物都可以称之为对象，有自己的独特的特点。 属性是用来描述具体某个对象的特征。例如小明身高180，体重70千克，身高和体重就是属性。 面向对象的思想就是把一切事物都看成对象，而对象一般都是由属性和方法组成。 属性属于对象静态的一面，用来形容对象的一些特性。 方法属于对象动态的一面，例如，小明会跑，会说话。跑，说话这些行为就是对象的方法！ 类：具有同种属性的对象称为类，。比如，“人”就是一类，其中的人名比如小明，小红等都是对象。类相当于一个模板，他定义了它所包含的全体对象的公共特征和功能，对象是类的实例化。所以我们一般在做程序的时候一般都不用类名的，比如我们在叫小明的时候，不会喊“人，你干嘛呢！”而是说的是“小明，你在干嘛呢！” 面向对象有三大特性：封装性，继承性和多态性
总结 面向过程：
优点是性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。而Linux\Unix等一般采用面向过程开发，性能是最重要的因素。缺点是没有面向对象易维护，易复用，易扩展。可维护性差，不易修改。
面向对象：
优点是易维护，易复用，易扩展。由于面向对象由封装，继承，多态性的特性，可以设计出耦合度低的系统，使系统更加灵活，更加易于维护。 缺点是性能比面向过程低。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cb8a178f7d55d1b22c4e6e899d1afb9/" rel="bookmark">
			简述微信小程序原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、本质
首先，小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象。
所以就没有相关的DOM API和BOM API，这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。
同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。
总之，js是单线程的，小程序是双线程，逻辑层和视图层（渲染层）是分开的，同时运行的。
二、通信
又因为小程序是双线程的，任何逻辑层和视图层的数据传递都是线程之间的通信，所以具有一定的延时，所以页面的更新就成了异步操作。
异步会使得各部分的运行时序变得复杂一些，比如在渲染首屏的时候，逻辑层与渲染层会同时开始初始化工作，但是渲染层需要有逻辑层的数据才能把界面渲染出来。
如果渲染层初始化工作较快完成，就要等逻辑层的指令才能进行下一步工作。
所以小程序的生命周期就起了作用，如下
三、运行机制
小程序启动运行两种情况：
1.冷启动（重新开始）：用户首次打开或者小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即为冷启动。
2.热启动：用户已经打开过小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需要将后台态的小程序切换到前台，这个过程就是热启动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be86146a79b26803ffcea521edf73d3c/" rel="bookmark">
			Unity插件XCharts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XCharts 1.下载网址2.获取和导入 XCharts3.添加一个简单图表4.添加多个Serie5.添加其他组件6.给折线图区域填充颜色7.个性化定制每个数据项的配置8.用代码添加折线图9.用代码改图表参数 是一款基于Unity3D的UGUI系统的插件，可以绘制折线图、曲线图、饼状图、雷达图、散点图、热力图等等，功能强大。 1.下载网址 网址1：https://github.com/XCharts-Team/XCharts
网址2：XCharts的Github下载网址
2.获取和导入 XCharts 2.1 直接放入XCharts源码到项目
下载好XCharts源码后，直接将XCharts目录拷贝到Unity项目工程的Assets目录下。
2.2 通过Assets/Import Package导入XCharts
下载好XCharts的.unitypackage文件后，打开Unity，菜单栏 Assets–&gt;Import Package–&gt;选中.unitypackage导入即可开始使用XCharts。
2.3 通过Package Manager导入XCharts
对于Unity 2018.3以上版本，可通过 Package Manager来导入XCharts，打开Package Manager后，通过 Add package form git URL…，输入XCharts的github URL: https://github.com/XCharts-Team/XCharts.git#master
稍等片刻后即可使用XCharts。
也可以直接将package加入到manifest.json文件：打开Packages目录下的manifest.json文件，在dependencies下加入：
"com.monitor1394.xcharts": "https://github.com/XCharts-Team/XCharts.git#master", 如需更新XCharts，删除manifest.json文件（部分Unity版本可能是packages-lock.json文件）的lock下的com.monitor1394.xcharts相关内容即会重新下载编译。
3.添加一个简单图表 在Hierarchy试图下右键或菜单栏GameObject下拉：XCharts-&gt;LineChart
即可快速创建一个简单的折线图出来
4.添加多个Serie 如何在上图的基础上添加两条折线呢，只需Add Serie按钮，选择对应的Serie类型即可：
5.添加其他组件 默认图表没有Legend，需要Legend组件可通过Add Component按钮添加
6.给折线图区域填充颜色 如果需要给折线图区域填充颜色，可单独给Serie添加Component
7.个性化定制每个数据项的配置 如果需要个性化定制每个数据项的配置，可以单独给每个SerieData添加Component。比如我们给第一个折线图的第二个数据单独显示Label
8.用代码添加折线图 给gameObject挂上LineChart脚本：
var chart = gameObject.GetComponent&lt;LineChart&gt;(); if (chart == null) { chart = gameObject.AddComponent&lt;LineChart&gt;(); chart.Init(); } 调整大小：
chart.SetSize(580, 300);//代码动态设置尺寸，或直接操作chart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be86146a79b26803ffcea521edf73d3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89acb23c61698df57bab64c626be1400/" rel="bookmark">
			Unity窗口操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity窗口操作 unity调用win32操作窗口1.基本操作（1）全屏（2）最小化（3）除任务栏全屏（4）改变标题栏文字（5）设置无边框，窗口位置及分辨率 2.没有标题栏和上边框时，点动场景拖动窗口3.自由调整窗口大小4.调整窗口大小强制固定比例 unity调用win32操作窗口 1.基本操作 （1）全屏 （2）最小化 （3）除任务栏全屏 （4）改变标题栏文字 （5）设置无边框，窗口位置及分辨率 using System; using System.Collections; using System.Collections.Generic; using System.Runtime.InteropServices; using UnityEngine; /// &lt;summary&gt; /// 窗口工具系统类(窗口状态) /// &lt;/summary&gt; public class WindowManager : MonoBehaviour { #region 系统字段 &amp; 系统方法 //设置当前窗口的显示状态 [DllImport("user32.dll")] public static extern bool ShowWindow(System.IntPtr hwnd, int nCmdShow); //获取当前激活窗口 [DllImport("user32.dll", EntryPoint = "GetForegroundWindow")] public static extern System.IntPtr GetForegroundWindow(); //获取指定unity.exe窗口 [DllImport("user32.dll", EntryPoint = "FindWindow")] public static extern IntPtr FindWindow(string lpClassName, string lpWindowName); //public static IntPtr ParenthWnd = FindWindow(null, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89acb23c61698df57bab64c626be1400/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfdc37818414dee7ca3e5c7b17e43dbc/" rel="bookmark">
			10 Java 常见的加密方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用对称加密算法 基于“对称密钥”的加密算法主要有DES、3DES（TripleDES）、AES、RC2、RC4、RC5和Blowfish等。本文只介绍最常用的对称加密算法DES、3DES（TripleDES）和AES。
Java中的MD5实现 package amigo.endecrypt; import java.security.MessageDigest; /** * 采用MD5加密 * @author Xingxing,Xie * @datetime 2014-5-31 */ public class MD5Util { /*** * MD5加密 生成32位md5码 * @param 待加密字符串 * @return 返回32位md5码 */ public static String md5Encode(String inStr) throws Exception { MessageDigest md5 = null; try { md5 = MessageDigest.getInstance("MD5"); } catch (Exception e) { System.out.println(e.toString()); e.printStackTrace(); return ""; } byte[] byteArray = inStr.getBytes("UTF-8"); byte[] md5Bytes = md5.digest(byteArray); StringBuffer hexValue = new StringBuffer(); for (int i = 0; i &lt; md5Bytes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfdc37818414dee7ca3e5c7b17e43dbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada489ef43d9ee66f5b5c2a91b14a3ca/" rel="bookmark">
			前端解决跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跨域问题 1.什么是跨域
做了快二年前端，无论是在开发or面试中总会遇到这个跨域问题，今天就简单写一下。
跨域是由浏览器同源策略引起的，是指页面请求的接口地址，必须与页面url地址处于同域上（即域名，端口，协议相同）。这是为了防止某域名下的接口被其他域名下的网页非法调用，是浏览器对JavaScript施加的安全限制。
浏览器跨域限制的目的，就是为了不让你在前端解决这个问题，但是一些憨憨就喜欢问这些问题或者让前端解决
2.如何解决跨域
前端解决：
1.JSONP：利用script标签可跨域的特点，在跨域脚本中可以直接回调当前脚本的函数。
2.CORS：服务器设置HTTP响应头中Access-Control-Allow-Origin值，解除跨域限制
但是！！不管是标准的CORS或黑科技JSONP，都不是纯前端能解决的，都需要服务器端配合。
JSONP需要服务器端返回的JS文件内有回掉方法。
CORS需要服务器端配置CORS信息。
所以遇到让前端解决跨域的公司，大家懂的吧。
后端解决：
nginx反向代理，代表的是服务端，对于浏览器来说，请求的url一直是nginx的IP（这是我咨询了一个有五年开发经验的后端大佬给我的答案）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f088fedacdc8c8c21476c4b108c491aa/" rel="bookmark">
			CSS3.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS3 Cascading Style Sheet 层叠级联样式表
CSS：表现（美化网页）
发展史 CSS1.0
CSS2.0 DIV+CSS，html与css结构分离的思想
CSS2.1 浮动，定位
CSS3.0 圆角，阴影，动画
快速入门 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- 语法： 选择器{ 声明1; 声明2; ...... } --&gt; &lt;style&gt; h1{ color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 外部引用：&lt;link rel="stylesheet" href="CSS/style.css"&gt; CSS优势：
内容和表现分离网页结构表现统一，可以实现复用样式十分丰富建议使用独立的css文件利用SEO，容易被搜索引擎收录 CSS导入方式 1. 行内样式
&lt;!--行内样式：在标签元素中，添加style属性，如有多个用分号隔开--&gt; &lt;h1 style="color: cornflowerblue;font-family: 'Microsoft YaHei UI Light'" &gt;标题&lt;/h1&gt; 2. 内部样式
&lt;!--在head标签中--&gt; &lt;style&gt; h1{ color: red; } &lt;/style&gt; 3. 外部样式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f088fedacdc8c8c21476c4b108c491aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c690df41f1a2477cf4196862ab8cdaa/" rel="bookmark">
			影像组学初学者指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		影像组学是放射学领域的一个相对较新的词，意思是从医学图像中提取大量的定量特征。人工智能（AI）大体上被定义为一组先进的计算算法，可以对所提供的数据模式进行学习，以便对未知的数据集进行预测。由于与传统的统计方法相比，人工智能具有更好的处理海量数据的能力，因此可以将影像组学方法与人工智能结合起来。总之，这些领域的主要目的是提取和分析尽可能多和有意义的深层定量特征数据，以用于决策支持。如今，影像组学和人工智能都因其在各种放射学任务中取得的显著成功而备受关注，由于担心被人工智能机器取代，大多数放射科医生对此感到焦虑。考虑到计算能力和大数据集可用性的不断发展进步，未来临床实践中人与机器的结合似乎是不可避免的。因此，不管他们的感受如何，放射科医生都应该熟悉这些概念。我们在本文中的目标有三个方面：第一，让放射科医生熟悉影像组学和人工智能；第二，鼓励放射科医生参与这些不断发展的领域；第三，为未来方法的设计和评估提供一套良好实践建议。本文发表在Diagnostic and Interventional Radiology杂志。
影像组学是放射学领域的一个新词，源于“放射”（意为医学图像）和“组学”（意为基因组学和蛋白质组学）的结合，有助于我们理解各种医学状况的各种领域，如基因组学和蛋白质组学。影像组学只是从医学图像中提取大量特征。典型的影像组学特征分析包括尺寸、形状和纹理特征的评估，这些特征具有关于像素或体素分布有用的空间信息。这些影像组学特征进一步用于创建统计模型，旨在为各种器官和系统的个性化诊断和管理提供支持，如大脑（2,3）、垂体（4,5）、肺（6）、心脏（7）、肝（8）、肾（9-12）、肾上腺（13,14）和前列腺（15）。
人工智能（AI）是一组基于先进计算算法的系统，可以从大量数据中准确地进行推理学习（16）。就像人类一样，学习是机器智能行为的基本要求。因此，AI是包含不同学习算法的一般概念，即机器学习（ML）和最近非常流行的深度学习算法（图1）。尽管人工智能的概念可以追溯到20世纪50年代，但由于计算能力的进步（19-21），自2000年以来，人工智能的发展势头迅猛。如今，人工智能技术为智能数据分析提供了许多不可或缺的工具，用于解决一些医疗问题，特别是诊断问题（17、18、21-24）。
图1，人工智能（AI）相关概念的维恩图。人工智能是通过机器，特别是计算机系统模拟人类的智能过程，如学习、推理和自我修正。人工智能是一个广泛的概念，涵盖了许多机器学习技术，如k近邻、支持向量机、决策树和神经网络。神经网络包括各种算法，从非常简单到复杂的结构，如多层感知器和深度学习或卷积神经网络。
影像组学和人工智能之间的关系是相互的。由于其不断增长的高维特性，影像组学领域需要更强大的分析工具，人工智能凭借其强大的功能，似乎是实现这一目标的潜在候选者。另一方面，在医学图像分析中，人工智能应用不可避免地需要影像组学，因为用于训练和构建人工智能模型的指标是通过影像组学方法提供的，特别是特征提取和特征选择技术。
在这篇文章中，我们从一个相当实用的角度回顾了影像组学和人工智能。我们的目标有三个方面：第一，让放射科医生熟悉放射学和人工智能；第二，鼓励他们参与这些不断发展的领域；第三，为良好实践提供一套建议和技巧。
关键问题和解答
为什么我们需要用到影像组学?
在传统的放射学实践中，除了尺寸和体积等少数测量外，成像数据集通常通过视觉或定性的方式进行评估。这种方法不仅涉及观察者内和观察者之间的差异，而且在医学图像中留下大量未使用的深层隐藏数据。通过常见的临床情况中两名肿瘤患者的大小、形状、边界和异质性等具有不同的定性特征，可以解释医生对影像组学的需求。在这种情况下，患者的生存率可能会有所不同，即使肿瘤具有相似的组织病理学特征。如果在任何干预或治疗之前能够预测患者的预后，那么对患者的管理方法就会有所不同。这实际上被称为精准医学。在精准医学中，需要识别属于不同亚型的患者以获得更好的结果。可以认为，影像组学是实现这些目标的一种客观方法。无论使用常规或先进的成像技术，影像组学的主要目的是提取尽可能多和有意义的隐藏目标数据，以用于临床决策支持。
为什么我们要将人工智能引入到影像组学中？
与传统的统计方法相比，人工智能在影像组学中使用的主要原因是它具有更好的处理大量数据的能力。人工智能算法主要用于分类问题。这些算法基本上学习通过分析模式提供的数据，然后对未知的数据集进行预测，以评估这些模式是否正确。人工智能算法不仅能够分析预定义或人工提取的影像学特征，还能够直接分析图像，以便自动提取特征（17、27–30）。这种非常流行和先进的人工智能子集称为深度学习（28）。深度学习算法本身也能够执行分割任务，无需任何人工干预（31）。
作为一名放射科医生，有可能参与到影像组学流程中吗？
是的，这是完全可能的。集体工作极为重要，因为影像组学的工作流程涵盖了广泛的连续步骤，包括预处理、分割、特征提取和数据处理（1）。根据使用的软件，每个步骤可能需要大量的时间和工作量。作者认为，在医学影像学的任何一个分支领域中，至少有三种方法可以参与影像组学。
首先，最简单的方法是寻找付费软件。这些类型的软件很容易使用，因为提供商简化了几乎所有的影像组学流程。其中一些还可以为进一步分析提供一些统计工具。
第二，更难的方法是使用自由软件程序，通过图形用户界面（GUI）提取影像组学特征。最常用的手工特征提取软件程序是MaZda（32）、LIFEx（33）、PyRadiomics（34）和IBEX（35）。尽管作者鼓励放射科医生开始参与其中，但是对于这些软件程序，他们还强烈建议谨慎行事，因为这些程序中的流程没有很好地建立，并且有许多参数需要调整，例如建立离散化水平、标准化方法、重新采样以及从最终特征表中清除非放射性数据等。此外，还有一些软件程序，可以直接从神经网络层内的图像（如Nvidia的Digits软件）中使用GUI进行深度特征提取(https://developer. http://nvidia.com/digits）和 (https://deepcognition. ai/）。
第三，最难的方法是使用允许特征提取的编码软件，如果用户具有编码技能或至少熟悉编码，可以使用MATLAB和Python平台，它们有大量用于人工提取和深度特征提取的库。
作为一名放射科医生，有可能参与人工智能吗？
是的，这也是完全可能的。作者认为，作为一名放射科医生，至少有三种方式可以在没有正式数据或计算机科学基础的情况下参与人工智能。
首先，最简单的方法是找到或成为关于医学成像的数据科学合作的一部分。数据或计算机科学家需要有意义的临床观点来提供影像组学中人工智能未满足的需求。
其次，更难但不是最难的方法是获得一些传统的统计基础，并学习如何在不会编码的情况下使用数据挖掘软件程序来执行人工智能任务。有许多用于此目的的自由软件程序，如Waikato知识分析环境（WEKA）软件（36）、Orange数据挖掘软件（37）、RapidMiner(https://rapidminer. com/），Rattle in R statistics（38）和Deep learning studio(https://deepcognition. ai/）。所有这些软件程序都有一个GUI，可以轻松实现各种AI任务，包括非常简单到非常复杂的ML算法。此外，其中一些软件程序还可以选择与其他通用环境（例如Python和R）集成，以获得更高级的功能。作为放射科医生，作者建议首先从WEKA或Orange软件类程序，考虑到其界面的简单性和易用性。另一方面，应该记住，并不是每个软件都能够完成每项任务。例如，根据我们的个人经验，WEKA足以执行许多ML任务，但它的可视化能力有限且较差，除非它与其他环境集成。
第三，最困难的方法当然是从学习如何编码开始。虽然从零开始学习代码通常看起来很困难，也很令人畏惧，但有一些非常简单的语言可以开始，比如Python语言，它是一种面向对象的语言，语法直观易懂，与人类语言非常相似。学习Python语言为使用许多可用的AI库（如Google的TensorFlow）提供了各种机会，即使对于具有低级编程技能的用户也是如此。有大量的资源可以低成本学习编写实现AI代码，如书籍、网站和在线课程（如Coursera、Udemy、edX）。
考虑到人工智能的发展，放射科医生的未来会怎样？
正如在最近的世界范围的年度放射学会议（如北美放射学学会（RSNA）和欧洲放射学大会（ECR））上所看到的，整体主题明显转向了影像组学和人工智能，这比任何其他医学领域都要明显得多。影像组学和人工智能都因其在各种放射学任务中取得的显著成功而备受关注，由于担心被智能机器取代，大多数放射科医生对此感到焦虑。考虑到计算能力和大数据集可用性的不断发展进步，未来临床实践中人与机器的结合似乎是不可避免的。因此，不管他们的感觉如何，放射科医生都应该熟悉这些概念。作者认为，具有人工智能的影像组学组学在一定程度上可以帮助放射科医生完成或促进某些任务，减轻放射科医生的繁重工作量，这实际上将使放射科医生比以往任何时候都更加高效，因为他们有机会在实践中只处理更复杂的放射学问题。
影像组学工作流
为了给读者提供一个更广阔的视角，在对每个步骤进行详细回顾之前，图2中简单地给出了简单的影像组学流程示意图。
图2.传统和基于深度学习的影像组学示意图。
图像采集
影像组学可应用于各种成像技术，包括计算机断层扫描、磁共振成像（MRI）、正电子发射断层扫描、X射线和超声检查。目前使用的采集技术种类繁多。此外，不同的供应商提供不同的图像重建方法，根据需要在每个机构设置。这不仅是多机构规模的问题，也是同一机构的问题。尽管在视觉分析中通常被低估或忽略，但不同采集和图像处理技术的使用可能会对影像组学产生重大影响，因为这是一个像素或体素水平的过程，可能会影响图像噪声，进而影响纹理，可能反映不同的潜在病理学。这些差异还可能导致独立数据集中的影像学分析结果不一致，这是影像组学的主要问题之一。从现实的角度来看，我们应该承认，不可能将所有的图像采集协议统一起来。另一方面，我们的主要目标应该是找到最佳的技术方法，以创建最稳定和准确的影像组学模型，甚至适用于通过不同协议获得的图像。要做到这一点，必须考虑到每种成像方式各自的特点。
图像预处理
影像组学依赖于某些图像参数。在任何成像模态中需要处理的最重要的是像素或体素的大小（41）、灰度级的数量（41）和灰度值的范围（42）。此外，MRI应消除信号强度不均匀性（43,44）。有许多方法可以处理这些依赖关系。对于灰度值的标准化，±3sigma标准化是最广泛使用的方法（45）。像素重采样可以使用各种插值方法来完成，例如线性插值和三次样条插值（46）。不同的软件程序提供不同的离散化方法，例如，固定箱大小和固定箱数量。N3和N4偏置场校正算法是广泛采用的避免信号强度不均匀性的技术（44）。尽管这些预处理步骤中的一些已包含在放射科软件程序中，但应该知道，许多用户友好的开源工具可用于高级放射成像数据预处理，如ImageJ、MIPAV（医学图像处理、分析和可视化）和3DSlicer。
分割
分割被认为是影像组学中最关键的步骤，因为影像组学特征主要是从分割的区域或体积中提取的。由于某些肿瘤的边缘非常不清楚，因此分割过程具有挑战性。手工分割被认为是黄金标准，前提是它是由有经验的专家执行的，这非常耗时。另一方面，手动分割受读取器内和读取器间变化的影响，导致放射特征再现性问题。为了避免差异性，下面介绍几种自动和半自动的方法：主动轮廓（snake）方法（49）、水平集方法（50）、基于区域的方法（51）、基于图形的方法（52）和基于深度学习的方法（53）。尽管自动分割技术是客观的，但它们很容易出错，尤其是当图像存在伪影和噪声以及感兴趣的病变非常不均匀时。
特征提取
考虑到影像组学特征的定义，大多数特征不属于放射科医生词典的一部分。在这种情况下，应该记住，影像组学是一种无假设的方法。这意味着没有关于特征临床相关性的先验假设，这些特征由专家创建的图像分析算法自动计算。该方法的目的是使用这些不可知或非语义特征发现以前肉眼不可见的图像特征，并基于最具辨别力的特征进行分类，这也称为影像组学特征的发展。只要这些模型在独立的数据集上得到验证，影像组学就可能是一种有效的方法。总之，整个过程意味着，除了一些直方图或一阶特征外，如果试图在临床环境中定义每个影像组学特征，可能会导致失败。
有两类影像组学特征：第一个是预定义的或人工提取的特征，由图像处理专家创建。这些也被称为传统特征。表1列出了一些传统的影像组学特征（即预定义或人工提取的特征）。第二种是深度特征，它现在已经很流行了，因为一些深度学习算法在其提取层中为给定任务自行设计和选择特征，而不需要任何人为干预（28）。最近的一些研究也表明了深度特征相对于传统特征的优越性（54,55）。
表1，传统的影像组学特征示例
可以根据不同的图像类型提取影像组学特征，这有助于影像组学特征的高维性。常见的图像类型如图3所示。
图3，a-c：用于影像组学特征提取的不同图像类型：（a）原始图像；（b） 滤波图像；（c） 小波变换图像。
影像组学数据处理
数据预处理
在进一步分析使用AI算法获得的放射数据之前，需要对数据进行预处理。可能的数据预处理步骤如下：特征缩放、离散化、连续化、随机化、过采样、欠采样等。
考虑到它们对基于人工智能的分类性能的主要影响，作者建议在每项科学工作中至少需要考虑特征缩放和随机化。
影像组学特征值是在不同的尺度上产生的，这严重干扰了人工智能算法内部参数的稳定性，例如人工神经网络的权重和偏差。特征缩放意味着将数值更改为通用尺度，避免数值范围内的显著扭曲。特征缩放涉及两大类：规范化和标准化。处理方法的选择取决于人工智能算法对数据分布的假设，这些假设将用于进一步的分析。
另一方面，数据集的随机化是创建模型的另一个重要因素，因为ML算法的性能受初始值或种子因素的影响。如果在创建模型之前未预处理，数据集中的某些偏差可能会强烈影响结果。
类平衡是反映ML分类器实际性能的一个重要因素。在严重失衡的情况下，结果可能具有误导性。为了解决这个问题，可以使用过采样和欠采样技术。用于平衡类的常用和公认技术之一是合成少数过采样技术（SMOTE）（56），它从少数类创建新的和类似的实例，这些实例不是实际实例的精确复制。
降维
放射学方法通常会导致高维性，这意味着它们会产生大量需要处理的特征。通常的做法是将高维度降低到较低的水平，以优化分类器性能，这基本上被称为降维（57）。可以使用不同的方法进行降维，例如特征再现性分析（58）、共线性分析（9）、基于算法的特征选择（57、59）和聚类分析。
应进行特征再现性分析，以评估对变量敏感的特征，特别是需要人工干预的分割任务（10）。此外，如果可能，应扩展该分析，以评估不同采集协议的影响（60-62）。再现性分析的目标是通过排除再现性相对较差的特征来降低维度。这种分析最常用的统计工具之一是类内相关系数（ICC）（63）。
分析中需要考虑不同类型的ICC（63）。共线分析是另一种可行的降维方法，因为大量特征具有相似的信息，其程度称为共线强度（64）。皮尔逊相关系数可用于确定冗余特征，即共线特征。二元特征具有高共线性，与其他特征共线性最高的特征应排除在分析之外。值得注意的是，也有一些基于共线状态和与类的最大相关性选择特征的算法，例如，基于相关性的特征选择算法（59）。这些算法非常有用，因为它通过同时进行两种技术，即共线分析和特征选择，减少了降维的工作量。
最广泛使用的降维技术是基于算法的特征选择（57）。有各种具有不同功能的算法，如最小绝对收缩和选择算子（65）、基于相关性的特征选择算法（59）、ReliefF（66）和基尼指数（67）。研究人员应该对这些算法进行实验，以获得最佳结果。
降维中最令人困惑的问题是应该实现的功能的最终数量。虽然没有关于这方面的指导方针，但最好将特征的总数至少减少到标记数据总数的十分之一。然而，作者也认为，尽管应该尽可能减少特征的数量，但只要它们独立的外部数据在计算机上得到验证，具有令人满意的性能，就不应该成为主要问题。
基于AI的统计分析
AI训练之前的需求
在进行人工智能活动之前，有一些必须注意的事项：（i）一致的数据；（ii）数据的妥善整理；（iii）专家驱动的数据处理；以及（iv）有效的临床问题或AI需要回答的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c690df41f1a2477cf4196862ab8cdaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60e7ceaecbb06bf98ba2fa57de13cd3c/" rel="bookmark">
			k8s多节点master部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s多节点master部署 多节点master2节点部署从master01节点上拷贝证书文件、配置文件和服务管理文件到master02修改配置文件kube-apiserver中的IP在master02节点上启动各服务并设置开机自启查看node节点状态 负载均衡部署+keepalived高可用（192.168.80.14/15）配置nginx的官方在线yum源，配置本地nginx的yum源修改nginx配置文件，配置四层反向代理负载均衡检查配置文件语法并启动nginx服务部署keepalived服务修改keepalived配置文件（额外编写健康检查脚本）启动keepalived服务（一定要先启动了nginx服务，再启动keepalived服务） 修改node节点上的kubeconfig配置文件在master01节点上操作 多节点master2节点部署 从master01节点上拷贝证书文件、配置文件和服务管理文件到master02 scp -r /opt/etcd/ root@192.168.80.16:/opt/ scp -r /opt/kubernetes/ root@192.168.80.16:/opt scp /usr/lib/systemd/system/{kube-apiserver,kube-controller-manager,kube-scheduler}.service root@192.168.80.16:/usr/lib/systemd/system/ 修改配置文件kube-apiserver中的IP vim /opt/kubernetes/cfg/kube-apiserver KUBE_APISERVER_OPTS="--logtostderr=true \ --v=4 \ --etcd-servers=https://192.168.80.11:2379,https://192.168.80.12:2379,https://192.168.80.13:2379 \ --bind-address=192.168.80.16 \	#修改master02的ip --secure-port=6443 \ --advertise-address=192.168.80.16 \	#修改master02的ip 在master02节点上启动各服务并设置开机自启 systemctl enable --now kube-apiserver.service systemctl enable --now kube-controller-manager.service systemctl enable --now kube-scheduler.service 查看node节点状态 ln -s /opt/kubernetes/bin/* /usr/local/bin/ kubectl get nodes kubectl get nodes -o wide	#-o=wide：输出额外信息；对于Pod，将输出Pod所在的Node名 //此时在master02节点查到的node节点状态仅是从etcd查询到的信息，而此时node节点实际上并未与master02节点建立通信连接，因此需要使用一个VIP把node节点与master节点都关联起来 负载均衡部署+keepalived高可用（192.168.80.14/15） 配置nginx的官方在线yum源，配置本地nginx的yum源 cat &gt; /etc/yum.repos.d/nginx.repo &lt;&lt; 'EOF' [nginx] name=nginx repo baseurl=http://nginx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60e7ceaecbb06bf98ba2fa57de13cd3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee66a0e9b9353c0435af75496caad134/" rel="bookmark">
			JWT令牌刷新机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JWT令牌刷新机制 问题来源 JWT令牌保存在客户端，会存在过期时间，那么如果令牌一直没有变化，那么过期时间也不会发生变化。假设一个JWT令牌的过期时间是5天，但是用户在这5天内一直在使用本系统，那么理论上当到了第五天的时候就应该是自动对这个令牌进行续期操作，而不是让用户重新登录。
解决办法 双令牌机制 设置长短日期的两个令牌，两个令牌都传给客户端，客户端每次携带两个令牌请求当两个令牌都没有过期的时候，服务端正常验证逻辑如果短令牌过期，长令牌没有过期，那么服务端重新生成两个新的令牌返回给客户端，客户端下次就带着新的令牌请求，完成了令牌的自动刷新。 缓存令牌机制 服务端不仅将令牌返回给客户端，同时将令牌缓存到Redis中，缓存时间是客户端令牌的过期时间的一倍如果客户端令牌过期了，但是Redis中的没有过期，那么就生成一个新的令牌返回给客户端，完成自动的令牌续期如果两者都过期了，那么就让用户重新登录。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c83c79251c391114803ce5bd0dbdc67/" rel="bookmark">
			关于vue3 history相关问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我实际操作了一下,我觉得有必要纠正一下,在实际开发种,实际上,可能我的上一章节匹配,会出现一些小问题
他会告诉你,你匹配的方式不对,不能用这种方式!于是你就去找,正则匹配方式,然后利用重定向
这次系统又会告诉你,栈溢出问题,我们先看栈溢出啥意思
在代码中的某个地方，您正在调用一个函数，该函数又调用另一个函数，依此类推，直到达到调用堆栈限制。这几乎总是因为具有未满足的基本情况的递归函数
这是官方说的一句话,不过其实好像自己懂了,又好像没懂,假设说我们用的是重定向,你这个时候,确实跟上面的说的一样,其实我们没必要用重定向,我们看匹配方案!
代码如下:
import { createRouter, createWebHistory } from 'vue-router'
const routes = [{ path: '/', component: () =&gt; import('../views/user.vue') },
{ path: '/:catchAll(.*)', component: () =&gt; import('../views/error.vue') }]
const router = createRouter({
history: createWebHistory(process.env.BASE_URL),
routes
})
export default router
当然这是动态路由加载方法,也叫做路由懒加载,其实根据你自己叫法了!
这样你随便输入一个组件,就可以到你创建的错误组件里面了,当然404组件你别忘记了创建了,这种错误,别大意了!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53026b611522f060251ee7675eee4ac1/" rel="bookmark">
			SpringBoot 单元测试，@Value注解执行不生效问题解决，测试类依赖注入实例失败问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题背景：想要把配置文件中的配置在测试的时候加载到测试类中，但是执行下来，发现@Value在测试方法执行时，不生效。参数总是加载为null 。
springboot 版本：2.6.4
二、原因排查
（一）查找@Value 生效前提如下：
1、不能作用于 static final 修饰的属性；
2、不能作用于非注册类，即用@Component 及其衍生注解的类；
3、类的使用只能通过依赖注入的方式，不能用new的方式；
以上三点，只有第三点我不满足，于是我在测试类中添加了被测试类的依赖注入@Autowired，测试发现注入的实例hiveDeal一直为null。
（二）解决测试类依赖注入实例失败问题
查找资料可知：Spring 中，实例由容器管理，测试类中，容器因为没有对应的上下文，没有办法进行注入类的实例化操作，因此需要提供一个上下文环境给我测试类，即添加如下两个注解到测试类。
@RunWith(SpringRunner.class) //意指让程序运行于Spring测试环境 @SpringBootTest(classes = HiveDeal.class) //给测试类提供上下文环境 注解说明
@RunWith 类级别注解，提供了一种更改测试运行程序的默认机制。可以根据指定的类运行程序，指定的类必须是Runner类的子类。
@SpringBootTest 通过这个注解，可以使JUnit单元测试执行在SpringBoot 环境中，提供上下文环境。
最终程序如下：
//测试类节选 import org.junit.jupiter.api.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest(classes = HiveDeal.class) class HiveDealTest { @Autowired private HiveDeal hiveDeal; @Test public void executeDDLTest(){ //hiveDeal = new HiveDeal(); hiveDeal.execute("create table autotest_tb(name string) partitioned by(ds string)"); } } //被测试类节选 import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53026b611522f060251ee7675eee4ac1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad58c740b5030207f7b36ee6517d9e91/" rel="bookmark">
			光电耦合器MOC3041
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		光电耦合器MOC3041 MOC3041
MOC3041是早期仙童半导体公司出品的一款光电耦合器，其内部包括一只砷化镓红外发光二极管和单片硅探测器，构成双向可控硅过零触发驱动程序，用于逻辑控制电路系统，如固态继电器，工业控制，电机，电磁铁和消费类
MOC3041内部含有过零检测电路，当输入引脚1输入15mA的电流，输出端6引脚、4引脚之间的电压稍过零时，内部双向晶闸管导通，触发外部晶闸管导通，当MOC3041输入引脚输入电流为0时，内部双向晶闸管关断，从而外部晶闸管也关断.
过零点之后电压上升，当电压升到15V时可控硅触发，触发后330欧的电阻被短路而没有电流，电流只从阳极阴极间流过。所以330欧的电阻不会承受220V的电压。计算电阻功率时就不必按220V电压计算。图中330欧的电阻是一个下拉电阻，它不会承受220V的电压，所以在计算这个330欧电阻功率时也不用按220V计算。
其他相关器件 4N40 是常用的单向晶闸管输出型光电耦合器，也称固态继电器。当输入端有15～30mA 电流时，输出端的晶闸管导通，输出端的额定电压为400V，额定电流为300mA。输入输出端隔离电压为1500V～7500V。
双向可控硅97A6，97A6是1A/600V双向可控硅，在调光电路、灯光控制、温度控制等电路中广泛应用。该可控硅耐压高达600V，可以直接应用于220V控制电路，最大工作电流为1A，可以控制100W以下电阻性的负载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2af6bbd37b6f51ec3592548726b5cc4/" rel="bookmark">
			【万人千题计划】第七题 2148. 元素计数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2148. 元素计数 https://leetcode-cn.com/problems/count-elements-with-strictly-smaller-and-greater-elements/
题目描述 给你一个整数数组 nums ，统计并返回在 nums 中同时至少具有一个严格较小元素和一个严格较大元素的元素数目。
示例1 输入：nums = [11,7,2,15]
输出：2
解释：元素 7 ：严格较小元素是元素 2 ，严格较大元素是元素 11 。
元素 11 ：严格较小元素是元素 7 ，严格较大元素是元素 15 。
总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。
示例2 输入：nums = [-3,3,3,90]
输出：2
解释：元素 3 ：严格较小元素是元素 -3 ，严格较大元素是元素 90 。
由于有两个元素的值为 3 ，总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。
提示 1 &lt;= nums.length &lt;= 100
-1e5 &lt;= nums[i] &lt;= 1e5
这道题的数据量是1e5，所以我偷了个小懒，直接用了桶排序哈哈哈。把最大值和最小值中间的数全加起来就哦了。
下面是AC代码：
int countElements(int* nums, int numsSize) { int a[200015]={0},sum=0,x=0,y=0; for(int i=0;i&lt;numsSize;i++) { int b=*(nums+i); a[b+100000]++; } for(int i=0;i&lt;200005;i++) { if(a[i]&gt;0) { x=i; break; } } for(int i=200005;i&gt;=0;i--) { if(a[i]&gt;0) { y=i; break; } } for(int i=x+1;i&lt;y;i++) { sum+=a[i]; } return sum; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a4e3eb4f6cc3567f7a359d45cdd66f6/" rel="bookmark">
			SQL查询数据之多表（关联）查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据表：
关联查询主要分为：（inner join）交叉关联、（left join）左关联、（right join）右关联
（inner join）交叉关联：
定义：（inner join）交叉关联只返回两个表联结相等的字段的行语法：select * from 表1 inner join 表2
on 表1.字段号=表2.字段号
比如我要查学生表和成绩表的交叉关联，那首先要找到它们联结相等的字段
它们唯一相同的字段就是学号这个字段
那么按照上面的语法写就是：
注意看，输出表是只有5个学生的的信息的，但是我们的学生表是一共拥有10个学生的，它的定义是只返回两个表联结相等的字段的行， 成绩表里只有5个学生的学号，相对等学生表联结的只能是5个学生的信息
（left join）左关联：
定义：（left join）左关联返回包括左表的所有记录和右表中联结字段相等的记录语法：select * from 表1 left join 表2
on 表1.字段号=表2.字段号
那要查学生表和成绩表的左关联先参照语法打一遍，效果如下：
左关联就是以左表为主体，右表有数据就显示，没有数据就显示null
（right join）右关联：
定义：（right join）右关联返回包括右表的所有记录和左表中联结字段相等的记录语法：select * from 表1 right join 表2
on 表1.字段号=表2.字段号
右关联就刚好和左关联相反
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b1ad2f9419c6106ce2710098f4afe46/" rel="bookmark">
			【Redis监听过期key不及时问题，适用于高并发及其海量数据的场景】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前沿 redis监听过期key的教程网上都有文章，但大多数都是针对于一般的处理，如果遇上高并发及其海量数据的数据的情况下会有一些问题。
本文会分析一般的监听过期key的处理在海量数据情况下出现的问题？怎么去解决，本文的思路和步骤都很清晰哦~
抛出问题：redis监听过期key不及时 举个例子：
现在时间09:00, 有个key设置一分钟后过期，也就是我在09:01的时候redis会告知我这个key过期了。
但是如果redis存储了海量数据，可能会导致这个的不及时通知，意思就是可能09:02才通知你
出现这种情况通知不及时很可能影响到业务操作，所以我们需要解决这个问题
分析问题：为什么会出现通知不及时的情况？
我们首先得了解redis底层是如何知道key过期的，它有三种方案：
redis默认采用的是定期删除+惰性删除
定期删除的过程：
每隔一段时间，Redis 会分别去各个库随机拿 20 个非永久 Key，判断它们是否过期，过期则删除，如果这一次拿的 key 中有超过 1/4 的数据过期，则再执行一遍过程 1，直到过期数据不超过当次拿出来的 20 条记录的 1/4。
（可以通过配置 redis.conf 中的 hz 修改 Redis 执行定期删除的频率，默认 hz=10，即每 100ms 执行一次，1/4 与每次拿的数量 20 暂时未找到配置项）；
如果当前数据库没有非永久 key，则跳过当前数据库；
如果 key 已过期，但没有被定期删除，由于惰性删除策略，在下次请求获取该数据时会将该数据删除；
平时我们都是把所有key都存在一个库里，它去随机获取的时候不一定能拿到过期key，所以就可能造成key过期没有及时通知
解决方案：
1.将缓存数据与监听数据分离，即把不同功能类型的数据分库存放（Redis 默认有 16 个库，库的数量可在 redis.conf 配置修改），例如把缓存数据存在 database0，把监听数据存在 database1；
让进行监听的库中 key 尽量少，如果不同业务的监听超时时间差异较大，则考虑将不同业务的超时监听数据存放到不同的数据库； 存放不同的库之后意味着执行命令需要动态切换库，公众号回复 redis多库组件 就能获得动态切库组件了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca46293afc12d75b414af0ea31de64a/" rel="bookmark">
			深度学习优化算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习各类优化器 借用古代炼丹的一些名词，我们可以把训练模型中的数据比做炼丹药材，模型比做炼丹炉，火候比做优化器。那么我们知道，同样的药材同样的炼丹炉，但是火候不一样的话，炼出来的丹药千差万别，同样的对于深度学习中训练模型而言，有时候模型性能不好，也许不是数据或者模型本身的原因，而是优化器的原因。由此可见优化器对于深度学习来说是多么重要了，那么今天小编就带大家了解一些常见的优化器。
优化算法设计原理 深度学习中的优化算法采用的原理是梯度下降法，即最小化目标函数 J ( θ ) J(\theta) J(θ)，最优化的求解过程，首先求解目标函数的梯度 ∇ J ( θ ) \nabla J(\theta) ∇J(θ)，然后将参数 θ \theta θ 向负梯度方向更新， θ t = θ t − 1 − η ∇ J ( θ ) \theta_{t}=\theta_{t-1}-\eta\nabla J(\theta) θt​=θt−1​−η∇J(θ)， η \eta η 为学习率，表明梯度更新的步伐的大小，最优化的过程依赖的算法称为优化器，可以看出深度学习优化器的两个核心是梯度与学习率，前者决定参数更新的方向，后者决定参数的更新程度。
我们定义 θ \theta θ 为待优化的参数， J ( θ ) J(\theta) J(θ) 为目标函数，初始学习率为 η \eta η。再进行一次梯度下降过程中优化算法的执行框架如下：
1、计算目标函数关于当前参数的梯度：
g t = ∇ J ( θ t ) g_t = \nabla J(\theta_t) gt​=∇J(θt​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ca46293afc12d75b414af0ea31de64a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43952b34a0d174925e94ebcd02cc5662/" rel="bookmark">
			android app 运行时提示 应用专为旧版 Android 打造
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 将 targetSdkVersion 升级至23后，弹窗消失，但需要对APP进行全面的重新测试。
android:targetSdkVersion="23" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e59cff4649e2628786bcbe15b31c5cde/" rel="bookmark">
			卷积层参数计算与设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卷积层维度计算与设置 卷积结构 CNN结构：
Input(输入层)----&gt; Conv(卷积)----&gt;Relu(激活)----&gt;Pool(池化)----&gt;FC(全连接)
输入层参数介绍：
batch_size：相当于一次训练的样本数weight/height：图片宽和高channels：图片通道数，1是黑白，3是RGB 卷积层参数介绍：
filter = 卷积核(1x1,3x3,5x5)feature map = 卷积之后得到的输出结果weight/height：卷积核大小in_channel: 等于输入图片的通道数（这个是可以根据自己的需要来设置的）out_channel: 等于输出通道数padding：填充值，在输入特征图的每一边添加一定数目的行列，使得输出的特征图的长、宽 = 输入的特征图的长、宽stride：步长，卷积核经过输入特征图的采样间隔 卷积计算公式：
N 输出大小 = (W输入大小 − Filter + 2Padding )/Stride+1
反卷积计算公式：
N 输出大小 = (W输入大小 − 1 )*Stride+Filter - 2 *Padding
注意：卷积向下取整，池化向上取整。
池化层参数介绍：
Filter : 卷积核大小stride：步长，卷积核经过输入特征图的采样间隔 池化计算公式：
输出大小 = (输入大小 − Filter)/Stride+1
作用：
maxpooling有局部不变性而且可以提取显著特征的同时降低模型的参数，从而降低模型的过拟合。
因为只是提取了显著特征，而舍弃了不显著的信息，是的模型的参数减少了，从而一定程度上可以缓解过拟合的产生。
如何选择卷积核大小、个数、层数？ 1. 卷积核大小： 理论上来说，卷积核的大小可以是任意的，但绝大部分的CNN中使用的卷积核都是奇数大小的正方形，如1x1,3x3,5x5,7x7,11x11等，也有长方形的卷积核，如Inceptionv3中3x3的变成1x3和3x1。
为什么CNN中的卷积核一般都是正方形，没有长方形？
大小选择一般为3x3的较多，越小越好，降低参数数量，降低复杂度。多个小卷积核比一个大卷积核好，原因有两点：
1.减少了参数量
2.3个3x3卷积核=1个7x7卷积核=1个5x5卷积核
以Mnist为例，图片28x28，使用5x5的卷积核，stride=1对其卷积，Result=（28-5)/1+1=24
用两个3x3卷积核：
(28-3）/ 1+1=26
(26-3）/ 1+1=24
2. 卷积核的个数 等于输出特征图的通道数，卷积核的数量越多，意味着提取的特征种类越多，通常会取2^n个，按照16的倍数倍增
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e59cff4649e2628786bcbe15b31c5cde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc69d1ad166c25df5f2fbc04630d2c5/" rel="bookmark">
			《网络安全应急响应技术实战指南》知识点总结（第6章 webshell网络安全应急响应）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、webshell概述 webshell通常指以JSP、ASP、PHP等网页脚本文件形式存在的一种服务器可执行文件，一般带有文件操作、执行命令功能，是一种网页后门。攻击者在入侵一个网站后，通常会将webshell后门文件与网站服务web目录下正常的网页文件混在一起，使用浏览器或专用客户端进行连接，从而得到一个服务器操作环境，以达到控制网站服务器的目的。
二、webshell分类 1、JSP型webshell脚本
全称Java Server Pages，是一种动态web资源的开发技术。JSP是在传统的网页HTML文件中插入Java程序段和JSP标记，从而形成JSP文件。
2、ASP型webshell脚本
全称Active Server Pages，是服务器开发专用脚本。可以与数据库和其他程序进行交互，是在IIS中运行的一种程序。
3、PHP型webshell脚本
全称Hypertext Preprocessor，是一种通用开源脚本语言，主要适用于web开发领域。可支持常见的数据库及操作系统，可快速地执行动态网页。
三、webshell用途 1、站长工具
webshell的一般用途是通过浏览器来对网站所在的服务器进行运维管理。随着webshell的发展，其作用演变成在线编辑文件、上传和下载文件、数据库操作、执行命令等。
2、持续远程控制
当攻击者利用漏洞或其他方法完成webshell植入时，为了防止其他攻击者再次利用，其会修补该网站的漏洞，以达到网站被其单独、持续控制。
3、权限提升
webshell的执行权限与web服务器运行的权限息息相关，若当前web服务器是root权限，则webshell也将获得root权限。在一般情况下，webshell为普通用户权限，此时攻击者为了进一步提升控制能力，会通过设置任务计划、内核漏洞等方法来获取root权限。
4、极强的隐蔽性
部分恶意网页脚本可以嵌套在正常网页中运行，且不容易被查杀。一旦webshell上传成功，其功能也将被视为所在服务的一部分，流量传输也将通过服务本身进行，因此拥有极强的隐蔽性。
四、webshell检测方法 1、基于流量
基于流量的webshell检测方便部署，可以通过流量镜像直接分析原始信息。
2、基于文件
通过检测文件是否加密（混淆处理），创建webshell样本hash库，可对比分析可疑文件。
3、基于日志
对常见的多种日志进行分析，可帮助我们有效识别webshell的上传行为等。
五、webshell防御方法 网页中一旦被植入webshell，攻击者就能利用它获取服务器系统权限、控制“肉鸡”发起DDos攻击、网站篡改、网页挂马、内部扫描等一系列攻击行为。因此，针对webshell的防御至关重要。
1、配置必要的防火墙，并开启防火墙策略，防止暴露不必要的服务为攻击者提供利用条件。
2、对服务器进行安全加固，如，关闭远程桌面功能、定期更换密码、使用https加密协议等。
3、加强权限管理，对敏感目录进行权限设置，限制上传目录的脚本执行权限等。
4、安装webshell检测工具，发现可疑的webshell程序就立即隔离查杀。
5、排查程序存在的漏洞，并及时修补漏洞。
6、时常备份数据库等重要文件。
7、需要保持日常维护，并注意服务器中是否有来历不明的可执行脚本文件。
8、采用白名单机制上传文件，不在白名单的一律禁止上传，上传目录权限遵循最小权限原则。
六、常规处置方法 网站中被植入webshell文件，通常代表着网站中存在可利用的高危漏洞，攻击者利用这些漏洞，将webshell写入网站，从而获得网站的控制权。一旦在网站中发现webshell文件，可采取以下步骤进行临时处置。
1、入侵时间确定
通过在网站目录中发现的webshell文件的创建时间，判断攻击者实施攻击的时间范围，以便后续一句此时间进行溯源分析、追踪攻击者的活动路径。
2、web日志分析
对访问网站的web日志进行分析，重点关注已知的入侵时间前后的日志记录，从而寻找攻击者的攻击路径，以及所利用的漏洞。
3、漏洞分析
通过日志中发现的日志问题，针对攻击者活动路径，可排查网站中存在的漏洞，并进行分析。
4、漏洞复现
对已发现的漏洞进行漏洞复现，从而还原攻击者的活动路径。
5、漏洞修复
清除已发现的webshell文件，并修复漏洞。
七、常用工具 扫描工具
1、D盾（web查杀工具）
2、河马webshell查杀
抓包工具
1、wireshark（可捕获流量并进行分析）
八、技术操作指南 在做应急响应时，首先要判断系统是否存在植入webshell的可能，对事件发生的时间进行排查，对攻击路径进行溯源分析。如果网站被植入暗链或出现单击链接跳转到其他网站的情况，应首先排查网站首页相关js，查看是否被植入了恶意跳转的js。若网站首页被篡改或有其他被攻击的现象，则应根据网站程序信息，如程序目录、文件上传目录等，使用工具（如D盾）和搜索关键词（如eval、assert）方式定位到webshell文件并清除，然后再根据日志溯源。
1、初步预判 1）了解webshell事件表现（被植入webshell可能出现的异常现象）
（1）网页被篡改，或在网站中发现非管理员设置的内容
（2）出现攻击者恶意篡改网页或网页被植入暗链的现象
（3）发现安全设备报警
2）判断webshell事件发生时间
根据异常现象发生时间，结合网站目录中webshell文件的创建时间，可大致定位事件发生的时间段。
3）判断系统架构
收集系统信息，如服务器（Windows、Linux等）、内容管理系统（即CMS）、中间件、框架、脚本语言等，为快速溯源分析提供前期准备工作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcc69d1ad166c25df5f2fbc04630d2c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c65db9914be6b2d587b219f9e6cd08ef/" rel="bookmark">
			mybatis 中update 返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		- mybatis中执行，update函数，那么这个函数的返回值是matched（匹配的）行数还是changed（受影响的）行数呢？
默认情况下是matched记录数，并不是changed记录数
如何让其返回值为受影响（changed）的记录数呢？
只需在mysql数据连接url参数加useAffectedRows=true即可
jdbc.url=jdbc:mysql://localhost:3306/ssm?useAffectedRows=true *以下是作者原文，测试思路很好，很值得学习，感谢原创作者！
如果定义一个如下的update函数，那么这个函数的返回值到底是啥意思呢？是受影响的行数吗？
验证之前我们先看看数据库中的数据记录。总共两条数据记录！
数据库链接配置为：
jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/ssm jdbc.username=root jdbc.password=123456 下面看看我们的单元测试类。
我们根据 ID 获取记录，然把用户名由 root 改为 root001。如果说返回值是影响的行数的话，那么应该返回 1.跟我们的预期结果 1 是相符的。单元测试会通过。
单元测试通过，我们看看数据库中的记录有没有变化。
看起来貌似没有任何问题。单元测试通过，数据库的确是只有一条记录更改了。这说明 mybatis 的 update 操作返回值的确是受影响的行数。
真的是这样吗
我们知道当数据库中的记录被修改之后，我们在次执行相同的 update 语句将不会影响到数据记录行数。
按照这个逻辑来讲的话，在此执行此单元测试，返回值应该为 0，跟我们的预期值 1 不同，单元测试应该不通过。再次运行单元测试：
我去，单元测试居然神奇般的通过了。。。请注意看，我们在命令行执行 update 语句那张图，返回的 matched 数量为 1。所以默认情况下，mybatis 的 update 操作的返回值是 matched 的记录数，并不是受影响的记录数。
那么有没有办法让 mybatis 的 update 操作的返回值是受影响的行数呢。因为我们业务逻辑中有时会根据这个返回值做业务判断。答案当然是有的。
修改数据库链接配置为：增加了 useAffectedRows 字段信息。
jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/ssm?useAffectedRows=true jdbc.username=root jdbc.password=123456 再次运行单元测试：
从报错信息可以清晰的看出，返回值是 0，跟我们的预期值 1 不同。
作者：豆豆先生的小屋
链接：https://www.jianshu.com/p/80270b93082a
来源：简书
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c65db9914be6b2d587b219f9e6cd08ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a616359ee5dbc8844f591a538e8dcf4/" rel="bookmark">
			HTTPS原理 如何实现安全通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
HTTP存在的问题
HTTPS原理
数字证书
CA可不可以用公钥加密服务器的公钥？
参考：
HTTPS理论基础及其在Android中的最佳实践_孙群的博客-CSDN博客_android httpshttps://blog.csdn.net/iispring/article/details/51615631
HTTPS是什么？加密原理和证书。SSL/TLS握手过程_哔哩哔哩_bilibili
HTTPS有什么用？比起HTTP来说有什么区别？如何实现？ - 知乎
HTTP存在的问题 HTTP 由于是明文传输，所以安全上存在以下三个风险：
窃听风险，比如通信链路上可以获取通信内容，用户号容易没。篡改风险，比如强制入垃圾广告，视觉污染，用户眼容易瞎。冒充风险，比如冒充淘宝网站，用户钱容易没。 HTTPS做的改进：
信息加密：交互信息无法被窃取。校验机制：无法篡改通信内容，篡改了就不能正常显示。身份证书：证明淘宝是真的。 HTTPS原理 我们知道，HTTP请求都是明文传输的，所谓的明文指的是没有经过加密的信息，如果HTTP请求被黑客拦截，并且里面含有银行卡密码等敏感数据的话，会非常危险。为了解决这个问题，Netscape 公司制定了HTTPS协议，HTTPS可以将数据加密传输，也就是传输的是密文，即便黑客在传输过程中拦截到数据也无法破译，这就保证了网络通信的安全。
HTTPS协议 = HTTP协议 + SSL/TLS协议，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输，由此可以看出HTTPS是由HTTP和SSL/TLS一起合作完成的，现在大都支持TLS。
SSL的全称是Secure Sockets Layer，即安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。SSL协议在1994年被Netscape发明，后来各个浏览器均支持SSL，其最新的版本是3.0
TLS的全称是Transport Layer Security，即安全传输层协议，最新版本的TLS（Transport Layer Security，传输层安全协议）是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。在TLS与SSL3.0之间存在着显著的差别，主要是它们所支持的加密算法不同，所以TLS与SSL3.0不能互操作。虽然TLS与SSL3.0在加密算法上不同，但是在我们理解HTTPS的过程中，我们可以把SSL和TLS看做是同一个协议。
HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输。
总的来说，对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。
一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。
1.客户端向服务器发起HTTPS请求，连接到服务器的443端口
2.服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
3.服务器将自己的公钥发送给客户端。
4.客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。
5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。
6.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
7.然后服务器将加密后的密文发送给客户端。
8.客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。
数字证书 通过观察HTTPS的传输过程，我们知道，当服务器接收到客户端发来的请求时，会向客户端发送服务器自己的公钥，但是黑客有可能中途篡改公钥，将其改成黑客自己的，所以有个问题，客户端怎么信赖这个公钥是自己想要访问的服务器的公钥而不是黑客的呢？ 这时候就需要用到数字证书。
要想让客户端信赖公钥，公钥也要找一个担保人，这个担保人的就是证书认证中心（Certificate Authority），简称CA。 也就是说CA是专门对公钥进行认证，进行担保的，也就是专门给公钥做担保的担保公司。 全球知名的CA也就100多个，这些CA都是全球都认可的，比如VeriSign、GlobalSign等，国内知名的CA有WoSign。
那CA怎么对公钥做担保认证呢？CA本身也有一对公钥和私钥，CA会用CA自己的私钥对要进行认证的公钥进行非对称加密，此处待认证的公钥就相当于是明文，加密完之后，得到的密文再加上证书的过期时间、颁发给、颁发者等信息，就组成了数字证书。
不论什么平台，设备的操作系统中都会内置100多个全球公认的CA，说具体点就是设备中存储了这些知名CA的公钥。当客户端接收到服务器的数字证书的时候，会进行如下验证：
首先客户端会用设备中内置的CA的公钥尝试解密数字证书，如果所有内置的CA的公钥都无法解密该数字证书，说明该数字证书不是由一个全球知名的CA签发的，这样客户端就无法信任该服务器的数字证书。
如果有一个CA的公钥能够成功解密该数字证书，说明该数字证书就是由该CA的私钥签发的，因为被私钥加密的密文只能被与其成对的公钥解密。
除此之外，还需要检查客户端当前访问的服务器的域名是与数字证书中提供的“颁发给”这一项吻合，还要检查数字证书是否过期等。
CA可不可以用公钥加密服务器的公钥？ （我的理解）
不行，如果CA用CA公钥加密 待认证的服务器公钥，那么其他人也有一样的CA公钥，任何人都可以对服务器公钥进行CA认证。
这样一些危险的网站也就有了自己的CA证书，而且这个证书客户端收到后，在用设备中内置的私钥解锁时都能正确解锁，这样客户端就误以为这是一个经过CA认证的机构。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e40aaf87e854203cdb679c9fb5ed22d/" rel="bookmark">
			【c&#43;&#43;复习笔记】——多态详细解析，多态的原理，多态的笔试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人主页:努力学习的少年🤟 版权: 本文由【努力学习的少年】原创、在CSDN首发、需要转载请联系博主💬 如果文章对你有帮助、欢迎关注、点赞、收藏(一键三连)和订阅专栏哦 目录
一. 多态的含义
二. 多态的作用
三. 静态的多态
四. 虚函数和动态的多态
1.动态多态的定义和实现
2. 定义虚函数
3. 虚函数重写的特殊例子
4. 纯虚函数与抽象类
五. 动态多态的原理
1.写一个程序打印虚表中的虚函数的地址。
六. 多继承的虚函数表
七. 笔试题
1. 为什么多态函数的参数是基类的指针或者引用 ，参数是基类对象不行？
2.对象中的虚表指针是在什么阶段的初始化呢？虚表又是在什么阶段生成的呢？
3.虚表是存在进程地址空间中的哪个区域的？(栈，堆等）
4. sizeof(Base1)和sizeof(Base2)是多少？
5.函数重载，重写，隐藏（重定义）的对比
6. inline函数可以是虚函数吗？
7. 静态成员没有this可以是虚函数吗？
8. 构造函数可以是虚函数吗？
一. 多态的含义 多态的含义提供同一个接口可以用多种方法进行调用的机制，从而可以通过相同的接口访问不同的函数。具体的说，就是同一个函数名称，作用在不同的对象上将产生不同的行为。
举个现实生活中的例子: 比如 买票这个行为 ，当 普通人 买票时，是全价买票； 学生 买票时，是半价买票； 军人 买票时是优 先买票。也就是不同的人去买票有不同的待遇。 联编是计算机程序自身彼此关联的过程，即把一个标识符名和一个存储地址联系在一起的过程。按照联编进行的阶段的不同分为两种不同的联编的方法： 静态联编 和 动态联编 ，这两种联编过程分别对应着多态的两种实现方式: 静态的多态 和 动态的多态 。 静态多态: 在程序编译期间确定了程序的行为，也称为，比如：函数重载。动态多态（动态绑定）：即运行时的多态，在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法。 二. 多态的作用 事实上，多态也是人类思维方式的一种直接模拟，比如，一个对象中有很多求两个数最大值的行为，虽然可以针对不同的数据类型，写很多不同的名称的函数来实现，但它们功能几乎完全相同，这时候就可以采用多态的特征，用统一的标识来完成这些功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e40aaf87e854203cdb679c9fb5ed22d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ea0f8e86273a9657d58911ad63fc5a1/" rel="bookmark">
			嵌入式学习--vi的基本命令二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嵌入式学习--vi的基本命令二 vi查找命令vi替换命令vi复制和剪切命令 vi查找命令 /string 查找字符串string
n继续向下查找
N向上查找
按回车后，光标的位置直接跳转到字符char的前面
vi替换命令 ：范围 s /旧string/新string //用新的替换旧的(没有范围默认当前行)
：s/str1/str2/g g表示把str1全部替换成str2(否则默认只换一个) ：.,$表示当前行到最后一行的替换 :1,$表示第一行到最后一行的替换（全文替换） :%表示全文替换 :n,n1s表示从第n行到n1行进行替换 替换11到28行的小a变成大A
按下回车键后
需要在后面加上g 否则默认只替换一个
vi复制和剪切命令 y0将光标至行首的字符拷入剪切板
y$将光标至行尾的字符拷入剪切板
:范围 y 表示块复制 然后点p粘贴
注意： 此时拷贝的内容不是第26行全部的内容
而是从光标的位置到这一行的行首位置的全部
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34b4c71fd27a0d507690c0413e4c4f1/" rel="bookmark">
			网络安全教程（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1-网络安全概述 1-1基础概念 1-1-1计算机网络安全的定义 国际标准化组织ISO将计算机网络安全定义为：“为数据处理系统建立和采取的技术与管理的安全保护，保护网络系统的硬件，软件及其系统中的数据不因偶然的或者恶意的原因而遭受到破坏、更改、泄露，系统连接可靠、正常的运行，网络服务不中断。”
1-1-2网络安全的5项特征 网络安全的5项特征：
保密性：信息不泄露给非授权用户、实体或过程，或供其利用的特性。完整性：数据未经授权不能进行改变的特性。即信息在存储或传输过程中保持不被修改、不被破坏和丢失的特性。可用性：可被授权实体访问并按需求使用的特性，即当需要时能否存取所需的信息。例如网络环境下拒绝服务、破坏网络和有关系统的正常运行等都属于对可用性的攻击。可控性：对信息的传播及内容具有控制能力。可审查性：出现安全问题时能够提供依据与手段。 1-1-3网络安全威胁 所谓网络安全威胁，是指对网络和信息的机密性，完整性、可用性在合法使用时可能造成的危害。
人为角度：
信息泄露、完整性破坏、拒绝服务攻击、滥用网络。 表现形式：
窃听、重传、篡改、拒绝服务攻击、行为否认、电子欺骗、非授权访问、传播病毒。
1-2网络攻击 1-2-1潜在的网络攻击者 国家黑客计算机恐怖分子有组织犯罪其他犯罪成员国际新闻机构商业竞争不满的雇员（实施内部威胁）不小心或未受到良好训练的雇员 1-2-2网络攻击分类 被动攻击：监视网络上的信息传输，包括监视明文，解密加密不善的通信数据，口令嗅探等。主动攻击：企图避开或打破安全防护，引入恶意代码以及转化数据或破坏系统的完整性。 （1）修改数据（2）替换（3）会话劫持（4）伪装成授权用户或服务器（5）获取系统应用和操作系统的缺陷（6）攫取主机或网络的信任（7）获得数据执行（8）恶意代码插入并刺探（9）拒绝服务：网络中散布垃圾包，垃圾邮件等 3.邻近攻击：未授权者在物理上接近网络系统或设备，目的是修改、收集和拒绝访问信息。
（1）修改数据或收集信息（2）物理破坏 4.内部人员攻击
（1）修改数据或安全机制
（2）建立未授权网络连接
（3）秘密通道
(4)物理损坏或破坏
5.分发攻击：软件和硬件开发后和安装前这段时间，当它从一个地方转移到另个一地方时，攻击者恶意修改软硬件。
1-3网络安全的特点 1-3-1网络安全的特点 攻击与防守不对称性：攻击可以攻其一点，防守必须全面防御。网络安全动态性：新的漏洞会不断出现。旧的漏洞会被消灭。攻击与防御的经济性问题：安全投入大于保护价值会得不偿失，攻击投入大于目标价值也会得不偿失。人是网络安全问题的核心：安全问题的根源在于人性的弱点。 1-3-2如何实现网络安全 安全政策：
安全政策是一个组织为了实现其业务目标而制定的一组规定，用来规范用户的行为，知道信息资源的保护和管理。安全政策应表现为一份或一系列正式的文档。安全政策规定了用户什么是该做的、什么是不该做的。 1-4网络安全技术 1-4-1网络安全基本要素 双向身份认证访问控制授权加密算法完整性检测不可否认性：双方都能证明信息已被发送和接收了，并且能确认身份，数字签名的特性，可以提供不可否认性可靠性保护：防止数据遭到捕获。数据隔离：防止数据泄露，不允许机密数据流入非机密网络。 2-数据加密与认证 2-1密码学基础 2-1-1加密的起源 4000年以前，古埃及的尼罗河畔，一位擅长书写者在贵族的墓碑上书写铭文时有意用变形的象形文字而不是普通的象形文字来撰写铭文，这是史上记载最早的密码形式。公元前5世纪，隐写术最早将现代密码概念运用于实际的人是凯撒大帝，后被称为凯撒密码，凯撒密码是将字母按字母表的顺序排列，并且最后一个字母与首字母相连。加密方法是将明文中的每个字母用其后的第三个字母代替，就成了密文。一般明文用小写，密文用大写。 例：
明文m e e t a t t o n i g h t
凯撒密码 P H H W D W W R Q L J K W 4.几种简单密码方案
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b34b4c71fd27a0d507690c0413e4c4f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d060662f272e2ba965dae6add7501a2/" rel="bookmark">
			Jetpack Compose for Desktop 打包生成Windows的Msi安装包和exe可执行程序 exited with 311 code
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建Compose for Desktop项目, 用IDEA默认生成的代码进行打包. 打包环境: IDEA 2021.3.3
kotlin 1.5.31
JDK jdk-15.0.2_x64(此版本打包失败, 改用jdk-16.0.2_x64成功)
Gradle 7.1.1
org.jetbrains.compose 1.0.0
Windos 10 专业版 21H2
build.gradle.kts
import org.jetbrains.compose.compose import org.jetbrains.compose.desktop.application.dsl.TargetFormat import org.jetbrains.kotlin.gradle.tasks.KotlinCompile plugins { kotlin("jvm") version "1.5.31" id("org.jetbrains.compose") version "1.0.0" } group = "me.zhou" version = "1.0" repositories { google() mavenCentral() maven("https://maven.pkg.jetbrains.space/public/p/compose/dev") } dependencies { implementation(compose.desktop.currentOs) } tasks.withType&lt;KotlinCompile&gt; { kotlinOptions.jvmTarget = "11" } compose.desktop { application { mainClass = "MainKt" nativeDistributions { targetFormats(TargetFormat.Dmg, TargetFormat.Msi, TargetFormat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d060662f272e2ba965dae6add7501a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd022b02040ca9a722f7b91eaa5dca45/" rel="bookmark">
			嵌入式学习-----vi编辑器的使用一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vi编辑器三种模式的使用 1.命令行模式2.编辑模式3.底行模式 1.命令行模式 1.1 什么叫命令行模式呢？
用户进入编辑器默认处于的模式，且在此时，是不能进行代码的输入
例：
vi com.c 创建一个com.c文件
按回车键进入编辑页面，此时是属于命令行模式的
1.2 命令行常见操作
我会一一为大家演示一下命令
yy：复制代码
nyy：从光标位置复制n行代码
p：粘贴在光标下一行
P：粘贴在光标上一行
dd：从光标位置剪切代码
ndd：从光标位置剪切n行代码
u：撤销
ctrl+r：反向撤销（即恢复刚刚撤销的内容）
x：从光标位置进行删除
我现在要复制头文件#include&lt;stdio.h&gt;
把光标移到第7行，然后按两下yy；
光标还是在第7行，按小写的p即可完成粘贴
如果要撤销按u
yy：复制代码
粘贴p，粘在光标的下一行
撤销按u
这时候我们要把第8行的内容撤销掉
一是按u撤销
而是按dd撤销这一行
注意：依然是从光标位置开始
如果我们要复制第7,8行的代码
光标移到第7行输入2yy
粘贴在第9行的上面，光标移到第9行的开头
输入P
复制n行代码nyy
粘贴到光标的上面P
剪贴n行ndd
现在我们从第8行开始剪切3行，光标先移动到第8行，然后输出3dd,
第8,9,10行的内容就会消失。
如果我们要删除头文件#include&lt;stdio.h&gt;
x单个字符进行删除(从光标位置开始)
2.编辑模式 2.1什么叫编辑模式呢？
能够在文件下，进行代码的输入，删除等一系列操作。
2.2怎么从命令行模式进入编辑模式呢？
在命令行输入a/i/o，区别在于光标的位置不一样。
A：将光标移到行尾
I：直接将光标进入行首
a:从光标的下一个位置输入
i:从光标位置输入
O：是在上面加空行
o：是在下面加空行
不用按a或者i,换行后直接进入插入模式
2,3怎么从编辑模式退出进入命令行模式呢？
按下键盘上Esc键，即进入命令行模式
按下A后，底行显示插入
退出编辑模式，按键盘上的Esc即进入到命令行模式
I：直接将光标进入行首
此时光标在;的位置上
按下I会去哪里呢？
a:从光标的下一个位置输入
退出编辑模式按Esc
i:从光标位置输入
退出编辑模式按Esc
O：是在上面加空行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd022b02040ca9a722f7b91eaa5dca45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9e7bcb6489d8113aad0ec8cc17e3253/" rel="bookmark">
			elasticsearch两年学习资料整理分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不管做任何事，都要先确定，我们是真的想要去做它。然后为之付出时间，直到有一天，做到极致！
而我想要在搜索领域做到极致！
一手资料永远都是官网 这里给一个官网文档的传送门：Configuring Elasticsearch | Elasticsearch Guide [8.1] | Elastic
一手资料，最好的还是源码 我们应该学会从源码中寻找答案。下边的文章，知识教我们如何开始读源码。没有直接去分析源码。
如何读源码学习_水的精神的博客-CSDN博客
网上的一些优质博客 当然，Elasticsearch的官方文档上也有一些我们找不到的东西，比如集群的优化等等。这时我们就需要去参考其他人的经验了。下面我给出了一些Elasticsearch的相关学习内容，可以对应地看一看。
Scroll详解
elasticsearch更改mapping(不停服务重建索引)
ElasticSearch: Index 和 Type 的区别
ElasticSearch:为中文分词器增加对英文的支持（让中文分词器可以处理中英文混合文档）
elasticsearch中minimum_should_match的一些理解
Elasticsearch Date类型使用技巧
ElasticSearch优化系列一：集群节点规划
elasticsearch 性能调优
elasticsearch三个重要的优化
分布式搜索引擎Elasticsearch性能优化与配置
刨根问底 | Elasticsearch 5.X集群多节点角色配置深入详解
[Elasticsearch] 多字段搜索 (二) - 最佳字段查询及其调优
如何提高ElasticSearch 索引速度
elasticsearch 写流程
elasticsearch之x-pack破解
新浪32亿条实时日志的Elasticsearch优化
elasticsearch写入优化记录,从3000到8000/s
elasticsearch在debian，ubuntu上得安装
es社区-知识星球 “Elasticsearch中文技术社区”群的钉钉群号： 21737292公众号：铭毅天下。上百位通过es认证的都在这里。es底层lucene的学习直通车（网上学习lucene最好的地方，最全的地方）：GitHub - LuXugang/Lucene-7.5.0: Lucene 7.5.0 8.4.0 8.6.0 8.7.0 8.8.0 8.9.0 一些优质的书籍 《elasticsearch源码解析与优化实战》这本书是我看过市面上全部的es相关的书以后最推荐的一本。 这本书不太会教你怎么入门es，怎么去使用API，但是会告诉你一次写入的流程，一次查询的流程，集群是如何选举的，es是如何启动的，等原理性的知识。
对应的阿里云盘链接：阿里云盘分享
《elasticsearch技术解析与实战》这边书可以学都api。如果你因为还可以的话，还是看最新版es的官方文档来学习api吧！ 对应的阿里云盘链接：阿里云盘分享
《从lucene到elasticsearch》es是基于lucene的。想要真的到底层，还是去学一下lucene。 对应的阿里云盘链接：阿里云盘分享
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9e7bcb6489d8113aad0ec8cc17e3253/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0038669ef92082edeb10e5aa8d052cb5/" rel="bookmark">
			电脑无法复制粘贴怎么办的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、鼠标点击桌面左下角开始菜单，找到运行并打开，或者使用Win+R的快捷键组合来打开运行；
2、在输入框里面输入“CHKDSK”，然后点击确定；
3、点击确定后会直接弹出修复窗口，自动运行，这里需要等待一段时间，根据个人电脑速度而定，几分钟不等，完成后会自动关闭窗口，你就可以测试一下复制粘贴功能了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30d5bd65440e58968c775422d5316ec8/" rel="bookmark">
			http中传输“&#43;”号转义问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转自https://blog.csdn.net/rushichunqiu/article/details/81087999
今天被加号经过http传输转变为空格的问题折腾好久，网上找了好多，最后找到这篇很不错，问题算是解决了，再次记录下来！
今天遇到base64加密向后端传值的问题，本来经过加密已经传过去了，但是没有返回成功的结果。于是，与后端同事配合，找找问题所在。发现是加密后的字符串中有一个“+”符号，在传之前console.log了一下，是显示这个符号的，但是传输过去在去识别，就换成空格了。在网上找到的大神们的做法，看到一个简洁有效的，在此记录一下：
首先，在string原型上创建一个替换字符串的方法：
String.prototype.replaceAll = function(s1,s2){
return this.replace(new RegExp(s1,"gm"),s2);
};
再次，在代码中，就可以使用该方法进行字符串的替换了，也不仅仅是“+”这个符号，一通百通：
var a = "dggdger4+g5ty34"
var b = a.replaceAll("\\+", "%2B");
console.log(b); // 输出为dggdger4%2Bg5ty34
将“+”符号转换为url可以识别ASCII 字符（十六进制格式）：“%2B”。这样在传输就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20dc7314142a5fea02e7469fb67c7b1e/" rel="bookmark">
			动态规划——背包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态规划——背包问题（运输货物问题） 先学习 01背包问题
背包问题可大致分为【完全背包问题】和【多重背包问题】
分析问题：
原问题：在满足重量约束的条件下，将这 m 件物品选择性的放入容量位W的背包中所能获得的最大利润。
子问题：在满足重量约束的条件下，将 前 i（i&lt;=m）件物品选择性的放入容量为 j（j&lt;=W）的背包中所能获得的最大利润。
定义状态： f（i，j）为前 i 件物品选择性放入 容量为 j （j&lt;= W）中获得最大利润。那么 f（m，W）就是我们的原问题。
存在两个参数，所以创建一个二维DP数组。
vi表示第 i 件物品的价值，wi 表示第 i 件物品的重量
这里假设物品重量为正整数（非正整数，可以试着转化单位化为整数或其他方法，还在学习中）
寻找状态转移方程
边界条件（初始条件）
第一行： f（1，i）表示把第1件物品放入容量为 j 的背包所能获取的最大值，显然 j &gt;= w1，即只要背包的容量&gt;=第1件物品的重量（装的下）时，f（1，j）=v1，否则f（1，j）=0；第一列： f（i，1）表示把前 i 件物品放入容量为 1的背包所能获取的最大值，这里物品重量都是正整数，因此我们先找前i件物品中重量为1的物品，然后再找其中v价值最大的物品，f（i，1）=vi，如果前i件物品不存在重量为1 的物品时，f（1，j）=0； 构建方程：
当 i &gt; 1 和 j &gt; 1 的情况： 考虑以下：由一个容量大小为j的背包，已经规划好了 前面 i-1 件物品的装载方案，现在你只需要考虑装不装第 i 件物品。 所以接下来，考虑两种情况：
（1）第 i 件物品重量wi &gt; 背包容量 j ：我们只能放弃。那就是还是和前面的装载方案一样，不变，即 f（i，j）=f（i-1，j）与前 i-1 件物品选择放入背包一样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20dc7314142a5fea02e7469fb67c7b1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aabc0394aa936d0c9abe09b0cab9337a/" rel="bookmark">
			Android 应用瘦身
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		瘦身目的 开发过程中，随着功能不断的迭代，包体积也会逐渐变大，如果此时将包投入市场，将会引来客户的投诉和抱怨。体积大一方面是浪费用户数据流量，另一方面是增加了安装的等待时间，用户可能因为嫌弃安装包太大扬长而去，对企业利润有着直接的冲击，所以应用瘦身环节尤为重要。下面以企业项目做实例分享一下瘦身经验。
基本思路 其实很简单，主要分两大步骤：了解安装包的组成部分，对安装包的资源目录瘦身
1.安装包的组成部分
在代码结构双击打包好的apk会出现以下信息，可以直观的看到安装包结构：
通过上图，我们可以知道哪些模块最影响包的体积，根据对体积的影响程度做好排序，优化方向需围绕以下几个目录。
assetslibres.dex.arsc 2.对安装包的资源目录瘦身
assets。该目录下存放资源文件，例如音频文件、json、web等。但下图可以看到该目录下存放的全是字体
针对字体，给出两种建议：
a.先检查下所需字体Android是否提供
b.可以通过提取所需文字的ttf文件，大幅减小ttf体积，可以从几MB压缩到几KB不等
例如应用有语音播报功能，我们会将音频文件放置assets。这时优先考虑MP3、AAC等有损格式而非PCM、WAV无损格式。因为有损和无损语音质量差别甚微、但文件体积却天差地别
如非必要，考虑是否可通过网络存储、文件存储等其他方式保存资源，视具体情况而定，原则上尽量不参与打包
lib。lib下存放各种架构的so文件，现在大部分机器的cpu架构是armv7，所以我们打包时只需加入以下代码过滤掉其他的abi（最终根据实际情况）。具体路径：app目录下的build.gradle
附上代码：
ndk { abiFilters "armeabi-v7a" } 效果：优化前
效果：优化后
res。这里都是一些资源文件，如下图所示，包含mipmap、drawble、layout等资源文件。优化方向主要有两个：
1.删除无用资源。有两种方式：这里可以用lint检测并物理删除目录下的无用资源，也可以在gradle设置shrinkResources为true，shrinkResources不会物理上删除无用资源，它是在打包时不将无用资源打进apk
使用第二种方式“shrinkResources“时需关注两点：
a.shrinkResources的使用一定要配合minifyEnabled，只有minifyEnabled为true时shrinkResources才会生效。具体原因就是我们的资源都是代码中使用的，我们需要知道哪些资源被代码使用，所以先得检测代码，即代码压缩/代码混淆
b.shrinkResources默认发现代码中调用资源R.mipmap.a，则其他未使用资源R.mipmap.a*也会被打包进apk（*代表任意字符或字符串）,所以如果您想自定义要保留的资源，则在路径res/raw/keep.xml定义规则
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;resources xmlns:tools="http://schemas.android.com/tools" tools:discard="@color/selector_tint_color" tools:keep="@layout/activity_test1,@layout/activity_test2" tools:shrinkMode="strict"/&gt; &lt;!--discard：做严格检查--&gt; &lt;!--keep :不做严格检查--&gt; &lt;!--shrinkMode="strict" :该模式只保留在代码或者资源文件中明确引用的资源--&gt; &lt;!--shrinkMode="safe" :该模式会保留所有明确引用的资源以及可能被 Resources.getIdentifier() 动态引用的资源--&gt; 注意：当使用lint删除资源文件时，对于代码中使用了getIdentifier(String name, String defType, String defPackage)设置图片，这就需要格外小心了。我们一般的做法就是用lint检测无用资源然后删除，但getIdentifier()函数并不直接引用资源文件，而是输入资源名称，从而引起“资源文件不存在“的报错
2.图片优化。使用svg、webp、.9png格式的图片
下表是我测试的一组对照数据，根据自己的经验总结：
PNG2.3M（大图）124K（小图）SVG（矢量）1.44M257K有细微失真WebP91.5K16.3K没有失真a.背景图选用webp比较划算
b.小图标选用svg比较划算
c.对于图标相同只是颜色不同的无需再做图，我们只需要设置着色器android:tint属性就好了，可以省下好些图标空间
提一句：我们写layout布局时，1.可以将公共部分提取出来，2.改用约束布局尽量少一些layout层级。虽然对包体积不是很大，但多多少少会影响一些性能
.dex。该目录是.java文件在Davlik编译的字节码文件，相当于JVM的字节码.class，如下所示，是一些java文件。优化方向有以下几点：
1.将app目录下build.gradle文件中minifyEnabled设置为true，即代码压缩/代码混淆。这里需要注意的是对于从外部引入的一些三方库，不能够被混淆，需要在proguard-rules定义混淆规则
2.移除废弃功能的代码。反正有Git，删了代码随时可以找回
3.提取重复代码
4.减少不必要的依赖。有时为了某个需求添加依赖，而后删除该需求后需记得删除该依赖
5.删除重叠框架。例如网络请求框架有okhttp、volley等，协同开发时往往会引入多种网络框架，这时只需保留一种框架
6.插件化。例如某些不常用的功能，既想拥有小体积，又想保留该功能，这时只需保留接口，通过网络从服务器下载相应功能的插件apk，在主应用中动态加载。关于插件化，我在后面的文章中会做简单介绍
.arsc。它是res的一套关系映射规则，通过以下这张图很清楚知道平时我们代码中使用的R.xxx.xxx其实就是通过这个关系映射找到的
像以上的string资源，默认它会编译出所有语言，如无必要，我们只需编译所需语言即可。此处以中文为例，只需在app目录下build.gradle中加入：resConfigs ‘zh’
代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aabc0394aa936d0c9abe09b0cab9337a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0f9bc87f90fab5c6e83fcb377f0e6c3/" rel="bookmark">
			六、docker--镜像制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.创建文件夹/mydocker以及如下文件
2.编辑Dockerfile
3.编辑requirements.txt文件
4.编辑app.py文件
5.生成镜像文件
6.查看镜像
7.启动容器
8.访问网站
本文环境：
CentOS Stream 8
Docker 20.10.13
本文创建一个用python连接redis数据，输出到网页功能的镜像。
1.创建文件夹/mydocker以及如下文件 2.编辑Dockerfile FROM python:2.7-slim WORKDIR /app ADD . /app VOLUME ["/data_flask"] #安装requirements.txt库制作镜像时运行 RUN pip install --trusted-host pypi.python.org -r requirements.txt EXPOSE 80 ENV NAME World ENV AUTHOR Seesunman #容器启动时运行 CMD ["python","app.py"] 3.编辑requirements.txt文件 Flask Redis 4.编辑app.py文件 from flask import Flask from redis import Redis, RedisError import os import socket redis = Redis(host = "redis", db = 0, socket_connect_timeout = 2, socket_timeout=2) app = Flask(__name__) @app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0f9bc87f90fab5c6e83fcb377f0e6c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e81e340ba9a92c2f6c0da1c813df3fa3/" rel="bookmark">
			[C语言]TCP服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试环境：树莓派x64
#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;stdio.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/shm.h&gt; #define PORT 7654 //端口 #define QUEUE_SIZE 10 //最大客户端连接数 //传进来的sockfd，就是互相建立好连接之后的socket文件描述符 //通过这个sockfd，可以完成 [服务端]&lt;---&gt;[客户端] 互相收发数据 void str_echo(int sockfd ) { char buffer[1024]; pid_t pid = getpid(); while(1) { memset(buffer,0,sizeof(buffer)); int len = recv(sockfd, buffer, sizeof(buffer),0); if (len &gt; 0) { printf("客户端ID: %d 内容: %s\n", pid,buffer); if(strcmp(buffer,"exit\n")==0) {//对比内容以执行对应命令 printf("子进程: %d 退出.\n",pid); break; } char jg[1024]; char *wbq = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e81e340ba9a92c2f6c0da1c813df3fa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec19d8c1098881911bc088b4082ba927/" rel="bookmark">
			简单登录注册页面（HTML5、CSS、JS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用HTML5和简单的CSS样式写一个登录注册页面，JS和CSS都在HTML5中
登录代码如下
&lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;style&gt; body { background: url('images/background.jpg') no-repeat; background-size: 100% auto; } #login_box { width: 20%; height: 400px; background-color: #00000085; margin: auto; margin-top: 10%; text-align: center; border-radius: 10px; padding: 50px 50px; } #login_box input, #login_box button { outline: none; } #login_box h2 { color: #ffffff90; margin-top: 5%; } #login_box #form #input_box { margin-top: 5%; } #login_box #form #input_box input { border: 0; width: 60%; font-size: 15px; color: #ffffff; background: #ffffff00; border-bottom: 2px solid #ffffff; padding: 5px 10px; margin-top: 10px; } #login_box button { margin-top: 50px; width: 50%; height: 30px; border-radius: 10px; border: 0; color: #fff; font-size: 15px; background-image: linear-gradient(120deg, #f093fb 0%, #f5576c 100%); cursor: pointer; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec19d8c1098881911bc088b4082ba927/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53043767ae649a56a4e6c8cc8c58e58d/" rel="bookmark">
			rtthread ulog 日志组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ulog 简介
日志的定义：日志是将软件运行的状态、过程等信息，输出到不同的介质中（例如：文件、控制台、显示屏等），并进行显示和保存。为软件调试、维护过程中的问题追溯、性能分析、系统监控、故障预警等功能，提供参考依据。可以说，日志的使用，几乎占用的软件生命周期的至少 80% 的时间。
日志的重要性：对于操作系统而言，由于其软件的复杂度非常大，单步调试在一些场景下并不适合，所以日志组件在操作系统上几乎都是标配。完善的日志系统也能让操作系统的调试事半功倍。
ulog 的起源: RT-Thread 一直缺少小巧、实用的日志组件，而 ulog 的诞生补全了这块的短板。它将作为 RT-Thread 的基础组件被开源出来，让我们的开发者也能用上简洁易用的日志系统，提高开发效率。
ulog 是一个非常简洁、易用的 C/C++ 日志组件，第一个字母 u 代表 μ，即微型的意思。它能做到最低ROM&lt;1K, RAM&lt;0.2K的资源占用。ulog 不仅有小巧体积，同样也有非常全面的功能，其设计理念参考的是另外一款 C/C++ 开源日志库：EasyLogger（简称 elog），并在功能和性能等方面做了非常多的改进。主要特性如下：
日志输出的后端多样化，可支持例如：串口、网络，文件、闪存等后端形式。
日志输出被设计为线程安全的方式，并支持异步输出模式。
日志系统高可靠，在中断 ISR 、Hardfault 等复杂环境下依旧可用。
日志支持运行期 / 编译期设置输出级别。
日志内容支持按关键词及标签方式进行全局过滤。
API 和日志格式可兼容 linux syslog。
支持以 hex 格式 dump 调试数据到日志中。
兼容 rtdbg （RTT 早期的日志头文件）及 EasyLogger 的日志输出 API。
ulog 架构
下图为 ulog 日志组件架构图：
前端：该层作为离应用最近的一层，给用户提供了 syslog 及 LOG_X 两类 API 接口，方便用户在不同的场景中使用。
核心：中间核心层的主要工作是将上层传递过来的日志，按照不同的配置要求进行格式化与过滤然后生成日志帧，最终通过不同的输出模块，输出到最底层的后端设备上。
后端：接收到核心层发来的日志帧后，将日志输出到已经注册的日志后端设备上，例如：文件、控制台、日志服务器等等。
配置选项
ENV 工具中使用 menuconfig 配置 ulog 的路径如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53043767ae649a56a4e6c8cc8c58e58d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7c75f978e56160abb0d96c32c5ccbf1/" rel="bookmark">
			C&#43;&#43;多线程：condition_variable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方定义 在多线程编程中，有一种十分常见的行为：线程同步。线程同步是指线程间需要按照预定的先后次序顺序进行的行为。C++11对这种行为也提供了有力的支持，这就是条件变量(condition_variable和condition_variable_any)。条件变量位于头文件condition_variable下。
condition_variable/condition_variable_any类是一个synchronization primitive，可用于阻止一个线程或同时阻止多个线程，直到另一个线程修改共享变量（condition），并通知condition_variable，才会继续执行。
当调用它的wait函数时，它使用一个mutex来锁定线程。使得该线程保持阻塞状态，直到被另一个线程调用同一个condition_variable对象上的notify函数才被唤醒。condition_variable类型的对象必须使用unique_lock&lt;mutex&gt;等待，而 std::condition_variable_any可以跟任何其他可锁定对象绑定使用, 也可以使用自定义类型。
原理 其实，条件变量跟 c++11 没特别大关系，它是操作系统实现的（Linux下使用 pthread库中的 pthread_cond_*() 函数提供了与条件变量相关的功能）。现在的关键在于理解为啥要有它，而且需注意一点，条件变量自身并不包含条件。因为它通常和 if (或者while) 一起用，所以叫条件变量。
并发有两大需求，一是互斥，二是等待(同步)。互斥是因为线程间存在共享数据，等待则是因为线程间存在依赖。互斥的话，通过互斥锁能搞定，常见的有依赖操作系统的 mutex。条件变量，是为了解决等待需求。考虑实现生产者消费者队列，生产者和消费者各是一个线程。一个明显的依赖是，消费者线程依赖生产者线程 push 元素进队列。没有条件变量，你会怎么实现消费者呢？让消费者线程一直轮询队列（需要加 mutex)。如果是队列里有值，就去消费；如果为空，要么是继续查，要么sleep一下，让系统过一会再唤醒你，你再次查。可以想到，无论哪种策略，都不通用，要么费cpu，要么线程过分sleep，影响该线程的性能。
有条件变量后，你就可以用事件模式了。上面的消费者线程，发现队列为空，就告诉操作系统，我要wait，一会肯定有其他线程发信号来唤醒我的。这个其他线程，实际上就是生产者线程。生产者线程push队列之后，则调用signal，告诉操作系统，之前有个线程在wait，你现在可以唤醒它了。上述两种等待方式，前者是轮询(poll)，后者是事件(event)。一般来说，事件方式比较通用，性能不会太差(但存在切换上下文的开销)。轮询方式的性能，就非常依赖并发pattern，也特别消耗cpu。
条件变量要和锁一起使用，锁提供了互斥这一机制，而条件变量在其基础上提供了同步的机制（同步是比互斥更严格的关系，互斥只要求线程间访问某一资源时不存在同时处理或者交替处理的可能，而对线程本身的调度顺序没有限制，也就是说谁先访问都行但你们一个个来，这就是互斥。同步就是在互斥的基础上，虽然线程之间的调度我们没办法控制，但我们可以原子的让某些线程在唤醒时检查某个条件，如果条件不满足就释放锁然后进入阻塞，通过这种方式达到控制不同线程按照某一种你设定的顺序访问资源）。一般条件变量，锁和用户提供的判定条件这三个因素一起组合使用，上文中的某个条件就是指用户提供的判定条件，而线程在检查这个条件，如果不满足就释放锁然后进入阻塞这个过程的原子性由条件变量提供，这也是条件变量的意义。
condition_variable 今天的目的，我们不介绍系统的条件变量，今天介绍C++11的condition_variable。先来简单介绍一下它的主要成员函数。
wait // 当前线程的执行会被阻塞，直到收到 notify 为止。 void wait (unique_lock&lt;mutex&gt;&amp; lck); // 当前线程仅在pred=false时阻塞；如果pred=true时，不阻塞。 template &lt;class Predicate&gt; void wait (unique_lock&lt;mutex&gt;&amp; lck, Predicate pred); wait会阻塞当前线程直至条件变量被通知，或虚假唤醒发生。
调用wait时，该函数会自动调用 lck.unlock() 释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。然后阻塞当前执行线程，另外，一旦当前线程获得通知(notified，通常是另外某个线程调用 notify_* 唤醒了当前线程)，wait()函数再次调用 lck.lock()重新上锁然后wait返回退出，可以理解lck的状态变换和 wait 函数被调用(退出)是同时进行的。
std::condition_variable提供了两种 wait() 函数。第二种情况多了条件参数 Predicate，只有当 pred 条件为false 时调用 wait() 才会阻塞当前线程，并且在收到其他线程的通知后只有当 pred 为 true 时才会被解除阻塞。因此第二种情况类似以下代码：
while (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7c75f978e56160abb0d96c32c5ccbf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfeb8913d021f6a89566c53da31cbb23/" rel="bookmark">
			AD22如何添加元器件库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开libPkg项目 2、编译
3、查看添加好的库
4、查看添加好的库
===
当然，如果你手上有IntLib文件（已经编译好的库）
可以直接点击install，进行安装。
===
比如从这个地方去下载：
1、Other Installers | User Manual | Documentation
所有制造商的库都在这里。
双击即可安装 2、IntLib
3、进行安装
===
讲的非常好👇
AD20如何加载元件库 - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9f23d534c055dd7d78f43fd169f040d/" rel="bookmark">
			Visual Studio Code中左侧颜色标识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码里的左侧颜色标识:
红色，未加入版本控制; (刚clone到本地)
绿色，已经加入版本控制暂未提交; (新增部分)
蓝色，加入版本控制，已提交，有改动； (修改部分)
白色，加入版本控制，已提交，无改动；
灰色：版本控制已忽略文件。
git文件标识:
A: 增加的文件.
C: 文件的一个新拷贝.
D: 删除的一个文件.
M: 文件的内容或者mode被修改了.
R: 文件名被修改了。
T: 文件的类型被修改了。
U: 文件没有被合并(你需要完成合并才能进行提交)
X: 未知状态
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2165bd1950f68e34c3320b6a1eb6e68e/" rel="bookmark">
			android--emo的来源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言第一次安装bug出现了idea配置android开发环境碰运气，重新下载导入项目，测试成功感悟 前言 记录一下我安装android studio的心路历程，为什么就我遇到这么多问题。。。。。
第一次安装 这学期新开的移动应用开发需要用到android studio，于是波哥发了一个压缩包，里面有相关的安装资料，相信很多人都害怕装软件，至于原因嘛，有人的电脑不适配某些软件，有人怕配置环境变量，有人怕杂七杂八的捆绑配置，但是自我感觉装软件虽然有时候有很多bug，但是最后不管是idea，mysql,vscode,vmware等等，还是配置maven，配置mybatis，配置spring等等，都还是功了的，但是这次我遇到了意想不到的问题。本以为按照步骤一下子就可以安装好，但是下载完后该出现的欢迎界面却没有出现，报了一个错–could not find main class,过了一个月都还记得，因为当时我查了无数资料，网上说是jdk没配好，但是我百分之百确定jdk没问题，后来问安卓大佬说是可能是最新版的软件没适配到所有电脑，于是我下载了一个很老的版本–2.3。。。
bug出现了 本以为2.3的版本就是老了点，基本的功能都还是能够实现的，但是今天我open一个项目的时候，会出现大片大片的爆红，凭着经验主义，我觉得肯定是包没有成功导入，但是我猜错了，我手动将包丢进去，可红还是那么红。。。。然后我查资料说是gradle版本和android studio不适配，于是我尝试降级gradle，但是还是没有效果。
idea配置android开发环境 大不了不用安卓嘛，AS也是基于idea来开发的，于是我打算用idea来配置AS，可是导入项目之后又发现，又是那个错误，我真的心态崩了。。。。
碰运气，重新下载 想着老版本不行，idea配置不了，害，又不能没有软件，于是想着碰碰运气重新下载最新的版本，心里想着只要初步安装完后欢迎界面出现我就成功了，于是我战战兢兢的一步一步来，生怕出错，直到看到那个心里想的界面出现后，我泪流满面，后来按照步骤走，就成功完成了安装。。。
导入项目，测试成功 装好了只是第一步，又回到了导入项目，导入进去还是那个错误。。。于是想着应该不是
gradle的问题了，后来按照大众认可的方法在gradle.properties中添加一句android.overridePathCheck=true，大概花了几分钟下载资源，刷新，运行，成功
感悟 emmmm,遇到问题还是不要轻易放弃吧，自己多去查资料，我大概算了一下，每次装软件，配置环境，我都花了很长时间，一个问题看的文章就有几十甚至上百篇，可能老天看我这么坚持，不忍心让我失望吧哈哈哈。总之，希望程序员媛和程序猿们出了问题就努力解决，在学习的道路上越走越顺利，共勉！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86257a59ddf3fe263744e2d59f18fddc/" rel="bookmark">
			Python内置类型性能分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python内置类型性能分析 timeit模块list的操作测试insert与append比较list内置操作的时间复杂度dict内置操作的时间复杂度 timeit模块 timeit模块可以用来测试一小段Python代码的执行速度。
class timeit.Timer(stmt=‘pass’, setup=‘pass’, timer=)
Timer是测量小段代码执行速度的类。stmt参数是要测试的代码语句（statment）；setup参数是运行代码时需要的设置；timer参数是一个定时器函数，与平台有关。 timeit.Timer.timeit(number=1000000)
Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次。方法返回执行代码的耗时，一个float类型的秒数。 list的操作测试 def t1(): l = [] for i in range(1000): l = l + [i] def t2(): l = [] for i in range(1000): l.append(i) def t3(): l = [i for i in range(1000)] def t4(): l = list(range(1000)) from timeit import Timer timer1 = Timer("t1()", "from __main__ import t1") print("concat ",timer1.timeit(number=1000), "seconds") timer2 = Timer("t2()", "from __main__ import t2"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86257a59ddf3fe263744e2d59f18fddc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b52e05aa74f61323bf7113c0c3f0e87/" rel="bookmark">
			C&#43;&#43;设计模式 - 解析器模式（Interpreter）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		领域规则模式 在特定领域中,某些变化虽然频繁,但可以抽象为某种规则。这时候,结合特定领域,将问题抽象为语法规则,从而给出在该领域下的一般性解决方案。 典型模式 Interpreter Interpreter 动机( Motivation ) 在软件构建过程中,如果某一特定领域的问题比较复杂 ,类似的结构不断重复出现,如果使用普通的编程方式来实现将面临非常频繁的变化。在这种情况下,将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子,从而达到解决问题的目的。 模式定义 给定一个语言,定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。
结构 要点总结 Interpreter模式的应用场合是Interpreter模式应用中的难点,只_有满足“业务规则频繁变化,且类似的结构不断重复出现，并且容易抽象为语法规则的问题”才适合使用Interpreter模式。使用Interpreter模式来表示文法规则,从而可以使用面向对象技巧来方便地"扩展”文法。Interpreter模式比较适合简单的文法表示,对于复杂的文法表示，Interperter模式会产生比较大的类层次结构, 需要求助于语法分析生成器这样的标准工具。 cpp #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;string&gt; #include&lt;stack&gt; class Expression { public: virtual int interpreter(std::map&lt;char, int&gt;) = 0; virtual ~Expression() {} }; class VarExpression :public Expression { public: VarExpression(const char&amp; k) :key(k) {} int interpreter(std::map&lt;char, int&gt;var) override { return var[key]; } private: char key; }; class SymbolExpression :public Expression { public: SymbolExpression(Expression* l, Expression* r) :left(l), right(r) {} protected: Expression* left; Expression* right; }; class AddExpression : public SymbolExpression { public: AddExpression(Expression* left, Expression* right) :SymbolExpression(left, right) {} int interpreter(std::map&lt;char, int&gt; var) override { return left-&gt;interpreter(var) + right-&gt;interpreter(var); } }; class SubExpression :public SymbolExpression { public: SubExpression(Expression* left, Expression* right) :SymbolExpression(left, right) {} int interpreter(std::map&lt;char, int&gt; var) override { return left-&gt;interpreter(var) - right-&gt;interpreter(var); } }; class MulExpression :public SymbolExpression { public: MulExpression(Expression* left, Expression* right) :SymbolExpression(left, right) {} int interpreter(std::map&lt;char, int&gt; var) override { return left-&gt;interpreter(var) * right-&gt;interpreter(var); } }; class DivExpression :public SymbolExpression { public: DivExpression(Expression* left, Expression* right) :SymbolExpression(left, right) {} int interpreter(std::map&lt;char, int&gt; var) override { return left-&gt;interpreter(var) / right-&gt;interpreter(var); } }; Expression* analyse(std::string expStr) { std::stack&lt;Expression*&gt; expStack; Expression* left = nullptr; Expression* right = nullptr; for (int i = 0; i &lt; expStr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b52e05aa74f61323bf7113c0c3f0e87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea5d7224e773a9561fd710eaf8e331af/" rel="bookmark">
			Python 爬虫笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 爬虫笔记 HTTP协议requests模块get() 和post()函数headers 数据解析正则表达式bs4解析-HTML语法Xpath 批量爬取百度图片selenium 毕设与图像分类相关，所以需要大量的图片数据，所以先学学爬虫爬图片。
本文作为自学笔记，仅供参考
声明：本文所有爬取的内容，都是合法的公开内容，不涉及侵权，且不做商用，仅用于个人学习使用。
学习课程：B站路飞学城IT
爬虫：
简单来说就是利用程序获取互联网上的资源。
robots.txt协议 ：规定网站中哪些数据不可以爬取， 只是协议，但并不能防止恶意爬取
爬虫的一般步骤：
拿到页面源代码解析该源代码，拿到数据 在学习爬虫之前，要先了解一下HTTP协议。
HTTP协议 HTTP协议是万维网的通信基础。简单来说就是计算机访问网页所需遵守的规则。
接下来是计算机网络的基础知识。
HTTP有两种报文，请求报文和响应报文。
请求报文:
客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。
响应报文:
HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文
请求头中最常见的一些重要内容:
User-Agent:请求载体的身份标识(用什么发送的请求)Referer:防盗链(这次请求是从哪个页面来的? 反爬会用到)cookie:本地字符串数据信息(用户登录信息, 反爬的token) 响应头中一些重要的内容:
cookie各种神奇的莫名其妙的字符串(一般都是token) 请求方式:
GET:显式提交
POST:隐式提交
接下来我们就要使用get 和 post方式去爬取一些网页。如果你没有学习过计算机网络，那么只需要先记住有这两种请求方式即可。
requests模块 get() 和post()函数 主要使用requests.get() 函数 和 requests.post()函数来请求获取网页上的内容
使用get还是post根据要爬取的页面的请求方式选择
例如：北京新发地的菜价页面就是post
百度的就是get
requests.get()
传入的第一个参数是url，统一资源定位标识，简单来说即要爬取的网页地址。
# 最简单的get请求方式 url = "http://www.baidu.com" requests.get(url) 增加url参数 参数名为:params , 字典形式
例如：
params参数中的内容将直接加在url后面。
requests.post()
post加url参数, 参数名为 data 字典形式
有些网页的中的内容并不会直接出现在源代码页面中， 而是动态加载， 此时我们就需要抓包，然后查看其请求参数，并使用该参数请求页面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea5d7224e773a9561fd710eaf8e331af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3667d4b16cdf8172631194086ba25f19/" rel="bookmark">
			上海税务局网站 环境检测 可信任站点未设置问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题一：上海税务局网站环境检测显示可信任站点未设置 问题二：上海税务局网站的环境检测IE浏览器显示正常，goolge浏览器却显示可信任站点未设置 在网上找了很久才找到这么一个有用的方法，以下为自己实测归纳总结，希望对你有用。
问题一解决方法： 1，先不要管环境检测，直接登录
2，不能登录再参考下列方法，添加可信任站点
//下列方法非原创，能解决大家问题就好
原地址：参考文档
上 海 市 电 子 税 务 局 已 于 2019 年 1 月 1 日 启 用 的 新 域 名
(https://etax.shanghai.chinatax.gov.cn)，需要您添加新的可信站点，具体操作说明如下：
1，若在首页“环境检测”中发现“可信站点情况”为“未设置”，则表示您需要添加可信站点。
2，通过浏览器工具栏打开“Internet 选项”配置窗口，选择“安全”页签。
3，在“安全”页签下，选择“受信任的站点”区域，准备配置具体受信任的站点；“受信任的站点”区域的安全级别可以选择默认级别——中。
4，打开“站点”，录入需要添加的受信任的站点，上海市电子税务局新域名：
https://etax.shanghai.chinatax.gov.cn
5，添加完信任站点后，选择“自定义级别”，补充设置安全选项。
6， 在“自定义级别”选项窗口内，可以先重置自定义设置为“中(默认值)”，点击“重置(E)…”按钮完成重置。然后在此窗口内，找到“对未标记为可安全执行脚本的ActiveX 控件初始化并执行脚本”，并选择“启用”。
7，启用并确定完成相关设置后，刷新环境检测页面，便可以通过环境检测，开始体验电子税务局各项办税服务了。
经过上面设置后使用IE浏览器登录上海税务局，查看环境检测时候正常了
问题二解决方法： 1，使用上述方法解决掉IE浏览器的上海税务局网站环境检测问题后，想使用goolge浏览器或360浏览器及其他浏览器登录税务局网站，却依旧显示可信任站点未设置，只有IE是正常的。
这种情况不要管环境检测直接进行登录就可以了（打热线电话问的，亲测可行！！）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97dae3103745fbee30afa4ee2dc5341b/" rel="bookmark">
			实验三、vi编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的 学习使用 vi编辑器建立、编辑、显示及加工处理文本文件。
二、实验内容 1.进入和退出vi
2.利用文本插入方式建立一个文件。
3.在新建的文本文件上移动光标位置。
4.对该文件执行删除、复原、修改、替换等操作。
三、主要实验步骤 1.进入vi。
在shell提示符后输入命令vi，进入vi编辑器，并处于vi命令方式，此时从键盘上输入的任何字符都被作为编辑命令来解释。
2.建立一个文件,如 file.c。进入插入方式,输入一个C语言程序的各行内容,故意制造几处错误。最后,将该文件存盘。回到shell状态下。
首先回到shell状态下，然后输入vi file.c
然后输入i,进入插入命令模式,输入C语言程序的各行内容
制造了几处错误之后,按Ecs键回到命令方式之后输入 :wq回到shell状态下
3.运行gcc file.c -o myfile,编译该文件，会发现错误提示。理解其含义。
4.重新进入Vi,对该文件进行修改。然后存盘,退出vi。重新编译该文件。如果编译通过了,那么可以用./myfile运行该程序。
从新进入vi编辑器
输入c,进入文本修改模式,修改文本之后,按Esc退出之后同样输入:wq保存退出
运行通过之后,用./myfile运行程序
5.运行man date &gt; file10，然后运行 vi file10。使用x、dd 等命令删除某些文本行。
使用u命令复原此前的情况。
使用c、r、s等命令修改文本内容。
使用检索命令进行给定模式的检索。
x命令:删除光标所在的字符。若前面给出一个数值n，则由光标所在的字符开始、向右删除n个字符
dd命令：删除光标所在的整行
删除某些文本行之后：
u命令：复原命令，取消刚才的插入或删除命令，恢复到原来的情况
c命令：修改文本对象，用新输入的文本代替老的文本
r命令：取代命令，用随后输入的单个字符取代光标所在的字符
s命令：用随后输入的正文替换光标所在的字符
这三个命令都差不多，随意出入一个命令即可完成对文本的修改
向前字符串检索：/模式+Enter键
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d93031f3085672887235487f1ac1e53/" rel="bookmark">
			java中的HashMap如何输出key值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HashMap&lt;Integer, Integer&gt; tempMap = new HashMap&lt;&gt;(); ​​​​​​​tempMap.keySet().iterator().next(); 1、keySet()—将HashMap转为key的集合
2、iterator()为迭代器
3、next()—迭代的获取集合中的下一个元素
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3120c17b57a5d2db777be4a6751c5ed7/" rel="bookmark">
			docker k8s 部署 rocketmq
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker 和 k8s 部署 rocketmq 1. docker部署
docker run -d -v /u01/data/namesrv/logs:/home/rocketmq/logs --name rmqnamesrv -p 9876:9876 apacherocketmq/rocketmq:4.5.0-alpine sh mqnamesrv docker run -d -v /u01/data/broker/logs:/home/rocketmq/logs -v /u01/data/broker/store:/home/rocketmq/store --name rmqbroker --link rmqnamesrv:namesrv -e "NAMESRV_ADDR=namesrv:9876" -p 10909:10909 -p 10911:10911 -p 10912:10912 apacherocketmq/rocketmq:rocketmq:4.5.0-alpine sh mqbroker docker run -d --name rocketmq-dashboard -e "JAVA_OPTS=-Drocketmq.namesrv.addr=10.0.1.56:9876" -p 6765:8080 -t apacherocketmq/rocketmq-dashboard:latest 2. k8s部署
1. 通过storgeclass创建两个备用pvc
apiVersion: v1 kind: PersistentVolumeClaim metadata: annotations: volume.beta.kubernetes.io/storage-provisioner: fuseim.pri/ifs name: rocketmqpv spec: accessModes: - ReadWriteMany resources: requests: storage: 1Gi storageClassName: managed-nfs-storage --- apiVersion: v1 kind: PersistentVolumeClaim metadata: annotations: volume.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3120c17b57a5d2db777be4a6751c5ed7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/287/">«</a>
	<span class="pagination__item pagination__item--current">288/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/289/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>