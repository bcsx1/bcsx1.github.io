<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a77390a78f2b762255cdb98f3bd33e85/" rel="bookmark">
			ES6 —— 填充数组fill( )、数组的遍历 for…of、获取数组索引arr.keys()、获取数组的内容和索引arr.entries()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、把数组进行填充 fill( )实例方法 ES6 —— 数组常用方法（entries、for...of、fill、find、Array.of、Array.from）_es6 entries find-CSDN博客
fill() 也是一个实例方法。
它的作用是把数组进行填充。它接收三个参数
第一个参数是填充的变量
第二个是开始填充的位置
第三个是填充到的位置(不填则默认是数组的长度)。
let arr=[0,1,2,3,4,5,6,7,8,9]; arr.fill('a',2,5); console.log(arr); // [0,1,'a','a','a',5,6,7,8,9] 上边的代码是把数组从第二位到第五位用 a 进行填充。
2、数组的遍历 for…of 循环 ES6 —— 数组常用方法（entries、for...of、fill、find、Array.of、Array.from）_es6 entries find-CSDN博客
这种形式比 ES5 的 for 循环要简单而且高效。
先来看一个最简单的for…of循环：
let arr = ["a", "b", "c"]; for (let item of arr) { console.log(item); // a b c } ① 获取数组索引 那我们可以使用下面的代码输出数组索引 arr.keys()
let arr = ["a", "b", "c"]; for (let item of arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a77390a78f2b762255cdb98f3bd33e85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64f2a0b8b948571f413d9ca50b082ce1/" rel="bookmark">
			VS 将 localhost访问改为ip访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 使用vs进行本地调试时需要多人访问界面,使用ip访问报错
问题描述 vs通过ip访问报错
虚拟机或其它电脑不能正常打开
原因分析： 原因是vs访问规则默认是iis,固定默认启动地址是localhost
解决方案： 1.vs项目启动之后会出现这个
右击显示
刚开始是只有localhost这一个,我们需要添加一个本地ip的
2.点击这个地址会出现配置
选择配置，系统自动打开配置文件，找到当前节点
加上需要绑定的地址
保存，重新运行
注意：VS以管理员身份运行
调试运行后，查看IIS，正常启动
虚拟机和局域网中可以访问
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c9cbcfa59ae39f604a1858562cd5ff7/" rel="bookmark">
			ES6 ——JSON数组格式转换成数组Array.from 、文本或者变量转换成数组Array.of、找到符合条件的数组元素find
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、JSON 数组格式转换成数组 Array.from(xxx) ES6 —— 数组常用方法（entries、for...of、fill、find、Array.of、Array.from）_es6 entries find-CSDN博客
JSON 的数组格式就是为了前端快速的把 JSON 转换成数组的一种格式，我们先来看一下JSON的数组格式怎么写。
let json = { '0': 'a', '1': 'b', '2': 'c', length:3 } 这就是一个标准的JSON数组格式，跟普通的 JSON 对比是在最后多了一个 length 属性。
只要是这种特殊的 json 格式都可以轻松使用 ES6 的语法转变成数组。在 ES6 中绝大部分的 Array操作都存在于 Array 对象里。我们就用 Array.from(xxx) 来进行转换。
我们把上边的JSON代码转换成数组，并打印在控制台。
let json = { '0': 'a', '1': 'b', '2': 'c', length:3 } let arr=Array.from(json); console.log(arr) // ['a','b','c'] 实际开发中这种方法还是比较常用的，毕竟节省了我们代码行数，也让我们的程序更清晰。
2、文本或者变量转换成数组 Array.of(xxx) ES6 —— 数组常用方法（entries、for...of、fill、find、Array.of、Array.from）_es6 entries find-CSDN博客
它负责把一堆文本或者变量转换成数组。
在开发中我们经常拿到了一个类似数组的字符串，需要使用 eval 来进行转换。如果你一个老手程序员都知道 eval 的效率是很低的，它会拖慢我们的程序。这时候我们就可以使用 Array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c9cbcfa59ae39f604a1858562cd5ff7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44437afb391fd0fee866c83a5ac4ac8c/" rel="bookmark">
			ES6——数组、对象和字符串的解构赋值--02
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构
一、数组的解构赋值 ① 简单的数组解构 以前，为变量赋值，我们只能直接指定值。比如下面的代码：
let a=0; let b=1; let c=2; 而现在我们可以用数组解构的方式来进行赋值。
let [a, b, c] = [1, 2, 3]; 上面的代码表示，可以从数组中提取值，按照位置的对象关系对变量赋值。
② 数组模式和赋值模式统一 可以简单的理解为等号左边和等号右边的形式要统一，如果不统一解构将失败。
let [a,[b,c],d]=[1,[2,3],4]; 如果等号两边形式不一样，很可能获得 undefined 或者直接报错。
③ 解构的默认值 解构赋值是允许你使用默认值的，先看一个最简单的默认的例子。
let [foo = true] =[]; console.log(foo); // 控制台打印出true 上边的例子数组中只有一个值，可能你会多少有些疑惑，我们就来个多个值的数组，并给他一些默认值。
let [a, b="二"] = ['一'] console.log(a + b); // 一二 现在我们对默认值有所了解，需要注意的是 undefined 和 null 的区别。
undefined 相当于什么都没有，b是默认值。 let [a, b = "二"] = ["一", undefined]; console.log(a + b); // 一二 null 相当于有值，但值为 null。所以 b 并没有取默认值，而是解构成了 null
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44437afb391fd0fee866c83a5ac4ac8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5f499a4b6eb106320607a0b3a3b0444/" rel="bookmark">
			JMeter学习笔记003-JMeter之CSV参数化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谈CSV参数化之前，我们先聊一聊【用户定义的变量】功能，这个功能，可以使我们将一些信息配置成参数，在不同的组件中获取。
添加【用户定义的变量】的方式：【线程组】 -&gt; 添加 -&gt; 配置元件 -&gt; 【用户定义的变量】
如图所示，我新增了filePath与user两个变量，那么在当前线程组中，所有的组件都可以通过 f i l e P a t h 、 {filePath}、 filePath、{user}的方式获取到。
在JMeter组件中，获取变量的方式，是${变量名}。（BeanShell中除外）
虽然JMeter提供了【用户定义的变量】功能，但是实际场景中，它并不能满足我们的需求。
比如，同一个接口，我需要针对不同的场景做功能验证。
A场景：用户传输userName：zhangsan，password：123456，返回success。
B场景：用户传输userName：zhangsan，password：654321，返回error。
此时，如果我们使用【用户定义的变量】功能，数据配置比较麻烦不说，我们还需要创建多个HTTP请求来处理。
这种重复性工作，在系统开发中，我们是要思考如何避免的。（程序的本质，就是解放劳动力）
【用户定义的变量】一般用来配置全局统一信息，如CSV文件地址等。
我们可以通过【CSV数据文件设置】+【循环控制器】来解决。
循环控制器 【线程组】-&gt; 添加 -&gt; 逻辑控制器 -&gt; 【循环控制器】
如图所示，循环控制器分为名称、注释、循环次数三部分。
其中，主要的是循环次数。可以选择永远，也可以固定次数（如图所示，固定3次），也支持参数化配置（这个后续有机会再写，通过迭代器的方式）。
CSV数据文件设置 在循环控制器中新增【CSV数据文件设置】。
【循环控制器】 -&gt; 添加 -&gt; 配置元件 -&gt; 【CSV数据文件设置】
如图所示，文件名是本地csv文件路径，文件编码选择对应的编码集（一般默认UTF-8）。
变量名称，对应的是CSV的列。
笔者案例CSV如下，分三列，测试列、序号列、信息列。
测试,序号,信息 测试1,123,哈哈哈 测试2,456,嘿嘿嘿 测试3,789,额嘟嘟嘟嘟嘟嘟 变量名称，自己定义，在后续流程中通过 变量引入，如： {变量}引入，如： 变量引入，如：{num}。笔者将csv的三列内容，分别定义为test、num、message。
忽略首行：如果首行是列头，则选择true。
分隔符：CSV一般使用英文逗号分割，默认即可，如果是用其他符号分割，输入具体分隔符。
是否允许带引号：CSV中的文本如果有引号，则选择true。
遇到文件结束符再次循环：默认False，csv文件结束符，笔者没搞明白。
遇到文件结束符停止线程：同上。
线程共享模式：所有线程、当前线程组、当前线程，这个指的是CSV的作用域。
验证 配置好【循环控制器】和【CSV数据文件设置】之后，就可以验证了。
编写一个HTTP接口。
@PostMapping("/test/jmeter3") public String test3(@RequestBody String str) throws Exception{ String res = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5f499a4b6eb106320607a0b3a3b0444/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6498ceb8d20d6ec15e05acb209b15d0/" rel="bookmark">
			高压直流输电工程技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高压直流输电工程技术是一种电力输电技术，它使用直流电流来传输电能，通常用于长距离、大容量的电能传输。这种技术在一些特定情况下比传统的交流输电技术更有优势，因为它可以减少输电损耗、提高输电能力和稳定性。以下是一些关于高压直流输电工程技术的重要信息：
直流电流 vs. 交流电流： 高压直流输电工程技术使用直流电流，与传统的交流输电不同。直流输电通常适用于长距离输电，因为它在输电线路上的损耗较小。
输电容量： 高压直流输电系统通常具有更高的输电容量，因此可以传输大量的电能，适用于远距离、大容量的电力输送。
转换站： 高压直流输电系统需要转换站，将交流电转换为直流电，以及将直流电转换回交流电。这些转换站通常位于输电线路的起点和终点。
电压等级： 高压直流输电系统通常工作在极高的电压等级，以减少输电损耗。这些电压等级可以达到数百千伏（千伏）。
输电线路： 输电线路通常是特制的，以适应高压直流输电。这些线路通常采用高绝缘材料，以减少漏电和绝缘故障的风险。
输电距离： 高压直流输电系统适用于长距离输电，如跨越山脉、水域或国家边界等情况。
环保优势： 高压直流输电系统通常具有较低的电能损耗，这有助于减少温室气体排放，因此在环保方面有一些优势。
稳定性： 直流电流在传输过程中具有较高的稳定性，这使得高压直流输电系统更适合对电能质量要求较高的应用。
成本和复杂性： 建设和维护高压直流输电系统通常比交流输电系统更昂贵和复杂。
高压直流输电技术在一些特定情况下非常有用，但其应用通常取决于具体的输电需求和地理条件。这种技术已经在世界各地得到广泛应用，特别是在长距离输电、能源交换和可再生能源集成方面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ebbc01542821a774ab55aa8fd75e379/" rel="bookmark">
			栈和队列的实现及相关面试题（超详细！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		栈和队列 栈概念与结构栈的功能栈的实现头文件Stack.h栈的结构体 Stack 源文件Stack.c初始化 void StackInit(Stack* ps)压栈 void StackPush(Stack* ps, STDataType data)出栈 void StackPop(Stack* ps)返回栈顶的值 STDataType StackTop(Stack* ps)返回栈中元素的个数 int StackSize(Stack* ps)判断栈是否为空 bool StackEmpty(Stack* ps)销毁栈 void StackDestroy(Stack* ps) 队列概念与结构队列的功能队列的实现头文件 Queue.h队列的结构体 Queue 队列源文件 Queue.c初始化队列 void QueueInit(Queue* q)队尾入队列 void QueuePush(Queue* q, QDataType data)队头出队列 void QueuePop(Queue* q)获取队列头部元素 QDataType QueueFront(Queue* q)获取队列队尾元素 QDataType QueueBack(Queue* q)获取队列中有效元素个数 int QueueSize(Queue* q)判断队列是否为空 bool QueueEmpty(Queue* q)销毁队列 void QueueDestroy(Queue* q) 栈和队列的结合笔试题力扣20. 有效的括号解题思路具体步骤 答案力扣20.有效的括号 栈 概念与结构 栈是一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。
栈的功能 1.进栈（压栈）：栈的插入操作，入数据在栈顶，如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ebbc01542821a774ab55aa8fd75e379/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdab0678a8cb96c99828e0cadcf8f5fe/" rel="bookmark">
			什么是BT种子！磁力链接又是如何工作的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一.什么是BT？1.BT简介：1.1.BT是目前最热门的下载方式之一1.2.BT服务器是通过一种传销的方式来实现文件共享的 2.小知识：2.1.你知道吗BT下载和常规下载到底有哪些不同2.2.BT下载的灵魂：种子2.3.当下载结束后，如果未关闭BT客户端程序 3.BT下载速度为何不快：3.1.不是公网用户3.2.上传速度被限制3.3.种子数太少3.4.防火墙的阻隔 4.BT下载对硬盘寿命的影响5.最后 一.什么是BT？ 1.BT简介： 1.1.BT是目前最热门的下载方式之一 它的全称为“BitTorrent”简称“BT”，中文全称“比特流”，但很多朋友将它戏称为“变态下载”，这又是什么原因呢？
就HTTP、FTP、PUB等下载方式而言，一般都是首先将文件放到服务器上，然后再由服务器传送到每位用户的机器上，它的工作原理如图1所示。
因此如果同一时刻下载的用户数量太多，势必影响到所有用户的下载速度，如果某些用户使用了多线程下载，那对带宽的影响就更严重了，因此几乎所有的下载服务器都有用户数量和最高下载速度等方面的限制．很明显，由于上述的原因，即使你使用的是宽带网，通常也很难达到运营商许诺的最高下载速度，这里面固然有网络的原因，但与服务器的限制也不无关系。正因如此，BT下载方式出现之后，很快就成为了下载迷们的最爱。
1.2.BT服务器是通过一种传销的方式来实现文件共享的 它的工作原理。举个例子来说吧，例如BT服务器将一个文件分成了N个部分，有甲、乙、丙、丁四位用户同时下载，那么BT并不会完全从服务器下载这个文件的所有部分，而是根据实际情况有选择地从其他用户的机器中下载已下载完成的部分。例如甲已经下载了第1部分，乙已经下载了第2部分，那么丙就会从甲的机器中下载第1部分，从乙的机器中下载第2部分，当然甲、乙、丁三位用户也在同时从丙的机器中下载相应的部分，这就大大减轻了BT服务器的负荷，也同时加快了丙的下载速度，也就是说每台参加下载的计算机既从其他用户的计算机上下载文件，同时自身也向其他用户提供下载，因此参与下载的用户数量越多，下载速度也越高。
2.小知识： 2.1.你知道吗BT下载和常规下载到底有哪些不同 和常规下载文件不一样的是，当你进行BT下载时，你开始链接的地址都是.torrent结尾的文件。其实只要下载此文件，在本机运行此文件一样可以进行BT下载工作。而网上的BT下载链接都是由广大用户自己发布提供的，这样使得下载资料非常广，不受常规管理人员的限制。
2.2.BT下载的灵魂：种子 无论何种BT客户端程序，默认设置都未对下载速度和上传速度进行限制，这是因为BT软件会给上传速度较快的用户优先提供服务，也就是说上传速度越快，下载速度也越快，因此如果你使用的是宽带的话，下载时就不要去限制上传速度了。
2.3.当下载结束后，如果未关闭BT客户端程序 （例如一边运行BT提供上传服务，一边浏览网页、编辑文档等），这时你将成为一个传递圣火的使者，即“种子”（seed）。换句话说，如果一个文件被分成10个部分，但拥有第9部分的人只有一个，即只有一个种子，如果这位用户由于某种原因断线或关机，那么其他用户就只能下载到90%了，在进行BT下载时是令人最为苦恼的。 3.BT下载速度为何不快： 有时候，BT下载速度并不快，这其中有多种原因。例如：
3.1.不是公网用户 由于内网用户无法提供主动连接，下载速度肯定会比公网用户慢一些，这是很正常的。 3.2.上传速度被限制 由于所有的BT客户端程序都对上传速度快的用户提供优先服务，因此如果你对上传速度进行了限制，实际上也就是变相限制了自己的下载速度。
3.3.种子数太少 如果种子数太少，当然也会影响到其他用户的下载速度，没办法，这还是需要每一个BT用户都发扬“雷锋”精神，自己下载结束后千万不要立即关闭BT，否则种子数就越来越少了。 3.4.防火墙的阻隔 防火墙软件也会对BT的下载速度造成一定影响，当然为了保证系统的安全，这一点点影响还是可以忽略不计的。 4.BT下载对硬盘寿命的影响 BT根本不伤硬盘 !!!
5.最后 喜欢就点个关注吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69fabaac66af75ee396c21885edadcf3/" rel="bookmark">
			error:0308010C:digital envelope routines::unsupported（解决Node.js版本与所使用的OpenSSL版本冲突问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误 可以看到是node.js版本冲突了，原因可能是node.js版本过高或者过低
方法一 1.先在package.json配置文件里面写入这两句代码 "dev":"vue-cli-service serve", "dev_t": "set NODE_OPTIONS=\"--openssl-legacy-provider\" &amp; npm run dev\n" 2.再在终端输入set NODE_OPTIONS=–openssl-legacy-provider set NODE_OPTIONS=--openssl-legacy-provider 3.输入 npm run dev_t 启动 npm run dev_t 可以看到启动成功了
方法二 把node.js版本降级或者升到最新，具体看OpenSSL的版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9603fa03d6704840d1b68c0dbc97d059/" rel="bookmark">
			JavaWeb：实现购物商城（课程设计完整版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 做一个javaweb可以对前后端基础知识进行巩固。
就比如 前端可以用 html+css+js+jQuery；
后端Http协议，Servlet基础，JSP技术，Mysql等
在文章结尾附项目源代码和素材
一、功能概述 购物商城分为 管理员 和 普通用户 页面用户可以自行注册登录用户可以 加入商品到购物车中，可以查看商品的详情管理员可以对 商品进行增删改查，就比如发布商品，下架商品，修改商品，搜索商品。 二、代码分析 action层：管理业务调度和管理跳转的，即处理逻辑问题bean层：封装数据，设置数据的属性和行为biz层：接受数据库的处理结果并且返回给前端dao层：对数据库进行增删改查util层： 是一个多功能，基于工具的包。比如字符串处理，JDBC连接等 三、项目展示 因为艺术细胞太少，所以前端页面设计的比较难看，大家可以自行修改也可以在评论区提出意见，或联系我修改。
1.登录和注册 2.普通用户页面 3.商品详情页 4.购物车 5.管理员页面 6. 发布商品页面 7. 修改商品页面 8.商品数据库 四、部分代码展示 1.登录和注册 //1.判读用户请求的类型为login String method = req.getParameter("type"); switch (method) { case "login": // 从 login.html中 拿 账号，密码等数据 String name = req.getParameter("name"); String pwd = req.getParameter("pwd"); // 调用UserBiz的getUser方法，根据 网页中 输入的账号密码，获取相应对象 User user = userBiz.getUser(name,pwd); //判断 获取到的对象是否为 null; if (user == null) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9603fa03d6704840d1b68c0dbc97d059/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/841ca19174338547e51241cf3eeaf51e/" rel="bookmark">
			windows nginx 常见操作命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在根目录下，cmd进入dos窗口
1、查看nginx的版本号
nginx -v 2、启动nginx
start nginx 或者运行 nginx.exe 3、快速停止或关闭Nginx
nginx -s stop 4、正常停止或关闭nginx
nginx -s quit 5、配置文件修改后重加载命令：
nginx -s reload 6、查看nginx进程
tasklist /fi "imagename eq nginx.exe" 7、查看所有nginx进程
tasklist /fi "imagename eq nginx.exe" 8、彻底停止nginx服务
taskkill /f /t /im nginx.exe 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c6b553009b3bee7ac015e553a9aeb54/" rel="bookmark">
			c语言密码登录(含密码加密)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c语言密码登录 一、 内置函数1、_getch();2、strcmp();3、exit();二、密码登录程序三、总结 一、 内置函数 1、_getch(); _getch()在头文件conio.h中。主要作用是从控制台读取一个字符，但不显示在屏幕上。本文主要用于加密部分。注意,部分低版本编译器用的是getch()。 例： #include &lt;stdio.h&gt; #include &lt;conio.h&gt; void main() { char a,b; a = _getch(); putchar('\n'); b = a; printf("%c", b); } 2、strcmp(); strcmp()在头文件string.h中。主要用于字符串的比较(区分大小写)，strcmp() 会根据 ASCII 编码依次比较 str1 和 str2 的每一个字符，直到出现不到的字符，或者到达字符串末尾（遇见\0）。 返回值：
如果返回值 &lt; 0，则表示 str1 小于 str2。
如果返回值 &gt; 0，则表示 str2 小于 str1。
如果返回值 = 0，则表示 str1 等于 str2。
(以第一次比较不同为主)
3、exit(); exit()在头文件stdlib.h中。是C语言中的一个终止函数，通常是用在子程序中用来终结程序用的，使用后程序自动结束，跳回操作系统。通常exit(0)为正常退出，括号里为非零为异常退出。 二、密码登录程序 #include &lt;stdio.h&gt; #include &lt;conio.h&gt; #include &lt;stdlib.h&gt; void main() { char* code1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c6b553009b3bee7ac015e553a9aeb54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e77faea8446b4181a645fd3990b4b16a/" rel="bookmark">
			分享一个可交互的小场景（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。
先看效果：
可互动的小场景
再看代码： JS部分
&lt;script&gt; var rotateDiv = document.getElementById('rot'); var rotateIcons = document.getElementById('rot-icons'); var clickRotateDiv = document.getElementById('click-rot'); var angle = 0; clickRotateDiv.onclick = function() { angle += 60; rotateDiv.style.transform = 'rotate(' + angle + 'deg)'; rotateIcons.style.transform = 'rotate(' + angle + 'deg)'; }; var step = 2; var color1 = 'rgba(0,0,0,0.5)'; var color2 = 'rgba(0,0,0,0.1)'; var gradient = ' conic-gradient('; for (var i = 0; i &lt; 360; i += step) { var color = i % (2 * step) === 0 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e77faea8446b4181a645fd3990b4b16a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a398cb577260a8ee9afcf677fc8f465/" rel="bookmark">
			pdm使用经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 去掉图表中的网格底线 Tools -&gt; Dispaly Preferences -&gt; General Settings -&gt;
General标签 -&gt; Diagram -&gt;
取消勾选Show page delimiter，
点击OK，
二．创建模型及变更模型 操作：file–&gt;new Model…
快捷键：ctrl+n
常用的以下两种：
1.概念模型(conceptual Data Model)
选择categories--&gt;information--&gt;conceptual Data--&gt;ok创建概念模型 2.物理模型(Physical DataModel)
选择categories--&gt;information--&gt;Physical Data--&gt;ok创建物理模型 二．将概念模型转换成物理模型
操作：Tools–&gt;GeneratePhysical Data Model
快捷键：ctrl+shift+p
三，显示Comment描述字段 如果要显示Comment描述字段的话，我们需要双击表格，然后进入Columns选项页，点击Customize Columns and Filter按钮，然后勾选Comment即可，如图：
当我们勾选完Comment并保存后，在Table Properties窗口Columns选项卡页中看到Comment了，如图：
但是，保存后回到设计视图，仍没有看到Comment注释信息，这样非常不便我们设计
此时，我们在工具栏找到模型-&gt;Extensions按钮，如图：
在打开的 List of Extensions 对话框中新建一个，然后点击属性按钮，如图：
在Profile右键，点击Add Metaclasses，如图：
选中Column，然后点击OK，如图：
然后选中Column，右键选择 New -&gt; Extended Attribute，如图：
Name一个名字（例如 AttributeComment ），dataType选择String，选中 Computer、Read only
注意：名字不能用 Comment，因为这是内置名字，用了会提示你重名，如图：
切换到Get Method Script tab 将 %Get% = “” 改为 %Get% = Rtf2Ascii (obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a398cb577260a8ee9afcf677fc8f465/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ee5a0c32d84b03a0a3a7eeaa94f47e4/" rel="bookmark">
			spring cloud alibaba系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring cloud alibaba (0)基础环境搭建
spring cloud alibaba (1)-引入nacos进行服务管理
spring cloud alibaba (2)-nacos配置中心
spring cloud alibaba (3)-feign发送请求与负载均衡
spring cloud alibaba (4)-sentinel实现容错
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d5d619ab9906d757ceb68b41eacc0de/" rel="bookmark">
			链接跳转新技术：抖音私信名片，开启流量增长新篇章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在今天这个数字化快速发展的时代，抖音作为一款广受欢迎的社交媒体平台，已成为品牌和个人推广的重要渠道。借助抖音私信黑科技，您现在可以创造独特的私信名片链接，这不仅增加了与目标受众互动的新途径，而且还提供了一种全新的推广方式。
这项创新技术使您能够生成个性化的名片链接，您可以自定义标题、描述、品牌标志，甚至是链接的落地页。这意味着您的每一次互动都将更具个性化和专业性，帮助您在激烈的市场竞争中脱颖而出。
更为重要的是，这项技术拥有强大的后台控制系统，可以精准地统计访问来源。无论是通过抖音群分享，还是直接发送给好友，这项技术都能为您提供详细的数据分析，帮助您更好地理解受众并优化推广策略。
此外，该技术支持推广网址和微信二维码引流，这为您提供了更多的引流渠道，无论是提高粉丝关注度还是转化率，都将更为有效。您可以将这些链接分享到抖音群或私信给好友，利用抖音的庞大用户基础，实现高效的粉丝引流和关注度提升。
安全性和效率是我们设计这款产品时的首要考虑因素。我们保证了引流过程的私密性和高效性，确保您在构建私域流量时的安全性和有效性。
总而言之，抖音私信黑科技不仅提供了一种新颖的互动方式，还为品牌和个人带来了更高效的市场推广手段。它是您在数字营销领域迈向成功的理想伙伴。试用入口:douyin618.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9abdf068ca5c8f9e50bb5efbf93453bd/" rel="bookmark">
			C&#43;&#43;学习——系列六：模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++学习——系列六 模板 模板 字面意思，做一个函数或类的模板，根据实际调用情况来实例化函数或类。
template &lt;class 类型参数1, class 类型参数2...&gt; 返回值类型 函数名(形参表) { 函数体; } template &lt;class 类型参数1, class 类型参数2...&gt; class 类名 { ... }; template &lt;class T, int size&gt;	//也可出现非类型参数 class A { T array[size]; }; A&lt;double, 5&gt; a; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //循环执行函数 template &lt;class T, class Pred&gt; void MyForeach (T * s, T * e, Pred f)	//可以传入函数指针 { for(; s != e; ++s) { f(* s); } } void Print(string s) { cout &lt;&lt; s &lt;&lt; endl; } //模板类 template &lt;class T&gt; class myclass { public: T * p; int size; myclass(T * m, int n) { p = new T[n]; size = n; for(int i = 0; i &lt; size; ++i) p[i] = m[i]; } ~myclass( ) { delete [] p; } }; int main() { string array[3] = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9abdf068ca5c8f9e50bb5efbf93453bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a756e9761a5f28780974adc90aa74b7/" rel="bookmark">
			linux下usleep函数对CPU占用率的影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux下usleep函数对CPU占用率的影响 2023-11-16
文章目录 linux下usleep函数对CPU占用率的影响1. 测试代码2. CPU占用率不使用usleep延时#define SLEEP_US 1 (1微秒)#define SLEEP_US 10 (10微秒)#define SLEEP_US 100 (100微秒)#define SLEEP_US 1000 (1000微秒=1毫秒)#define SLEEP_US 10000 (10000微秒=10毫秒)#define SLEEP_US 100000 (100000微秒=100毫秒) 环境
系统: ubuntu 22.04 内核版本: Linux 5.15.0-58-generic cpu: Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHz cpu核数: 1 架构: x86_64 1. 测试代码 main.cpp
#include &lt;unistd.h&gt; // usleep #define SLEEP_US 1 int main() { while (1) { usleep(SLEEP_US); } return 0; } $ g++ main.cpp -o main $ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a756e9761a5f28780974adc90aa74b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3498e82812242333016e4b041e630e6b/" rel="bookmark">
			环境配置tensorflow-gpu(1.15和2.0)|torch-1.2.0&#43;python3.7&#43;CUDA10&#43;cudnn7.6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.Anaconda安装
2.新建python环境
3.包安装
查看已安装的包：
安装常用的包：
4.框架安装：
Cuda安装：
Tensorflow-gpu-1.15 安装：
Tensorflow-gpu-2.0 安装：
Pytorch安装：
1.Anaconda安装 下载安装
下载网址：Free Download | Anaconda 下载完双击安装包，默认选项一直安装就行了
系统用户名应该为英文，避免很多麻烦
建议安装在c盘，直接在c盘新建个文件夹，命名为anaconda3(我装在E盘)
Finish后安装完毕
可能有的情况（我装新版遇到的）
菜单栏没有快捷键：
查看anaconda文件夹里面有没有menu文件夹，有没有anaconda-navigator.json文件，没有自己建，有就在命令行使用以下命令：
python .\Lib\_nsis.py mkmenus
详细见：
Tips--解决安装完Anaconda没有快捷方式的问题_conda安装完快捷方式执行程序位置-CSDN博客
2.新建python环境 方式一：命令行安装：
在电脑开始菜单，打开anaconda prompt，
使用以下命令都能创建python环境：
conda create --name py37 python=3.7
conda create -p C:\Anaconda3\envs\py37 python=3.7
创建完后，用下面命令激活：
conda activate py37
方式二：图形界面安装：
在电脑开始菜单，打开anaconda，在environments中，create一个环境，填写环境名、选择版本，创建即可。
3.包安装 查看已安装的包： conda list：
conda 是 Anaconda 发行版中的包管理器，用于管理 Python 环境中的软件包。
conda list 会列出当前激活环境中通过 conda 安装的所有软件包及其版本。
通过 conda install 安装的软件包会出现在 conda list 的输出中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3498e82812242333016e4b041e630e6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf78bcf05316ae509b727a7cd370cfe6/" rel="bookmark">
			Ubuntu下调用opencv库点阵汉字的字模读取与显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、解决的问题
二、汉字点阵字库原理 1、 汉字编码
1.1、区位码：
1.2、机内码：
1.3、国际码：
1.4、汉字机内码、国标码和区位码三者关系：
2、点阵字库结构：
2.1、点阵字库存储：
2.2、16*16 点阵字库：
2.3、14*14 与 与 12*12 点阵字库： 3、汉字点阵的获取： 3.1、利用区位码获取汉字：
3.2、利用汉字机内码获取汉字：
三、在Ubuntu下用C/C++调用opencv显示图片及文字
1、实验准备：
2、编写代码：
3、编译运行 ：
4、运行效果：​
四、总结
五、参考资料
一、解决的问题 学习理解汉字的机内码、区位码编码规则和字形数据存储格式。在Ubuntu下用C/C++(或python) 调用opencv库编程显示一张图片，并打开一个名为"logo.txt"的文本文件（其中只有一行文本文件，包括你自己的名字和学号），按照名字和学号去读取汉字24*24点阵字形字库（压缩包中的文件HZKf2424.hz）中对应字符的字形数据，将名字和学号叠加显示在此图片右下位置。
二、汉字点阵字库原理 1、 汉字编码 1.1、区位码： 在国标 GD2312—80 中规定，所有的国标汉字及符号分配在一个 94 行、94 列的方阵中，方阵的每一行称为一个“区”，编号为 01 区到 94 区，每一列称为一个“位”，编号为01 位到 94 位，方阵中的每一个汉字和符号所在的区号和位号组合在一起形成的四个阿拉伯数字就是它们的“区位码”。 区位码的前两位是它的区号，后两位是它的位号。 用区位码就可以唯一地确定一个汉字或符号，反过来说，任何一个汉字或符号也都对应着一个唯一的区位码。汉字“母”字的区位码是3624，表明它在方阵的 36 区 24 位，问号“?”的区位码为0331，则它在 03 区 3l 位。 名称内容中文名汉字区位码类别办法作用为每个汉字编一个唯一的代码优势便计算机辨认、接收和处理 1.2、机内码： 汉字的机内码是指在计算机中表示一个汉字的编码。机内码与区位码稍有区别。如上所述，汉字区位码的区码和位码的取值均在 1~94 之间，如直接用区位码作为机内码，就会与基本 ASCII 码混淆。为了避免机内码与基本 ASCII 码的冲突，需要避开基本 ASCII 码中的控制(00H~1FH)，还需与基本 ASCII 码中的字符相区别。为了实现这两点，可以先在区码和位码分别加上 20H，在此基础上再加 80H(此处“H”表示前两位数字为十六进制数)。经过这些处理，用机内码表示一个汉字需要占两个字节，分别 称为高位字节和低位字节，这两位字节的机内码按如下规则表示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf78bcf05316ae509b727a7cd370cfe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b659cea0f4a50929280278fb5e9dabd3/" rel="bookmark">
			Could not find com.android.tools.build:gradle:xxx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景： 提示：这里简述项目相关背景：
项目在构建的时候，可能会遇到旧项目里面的配置不能正常使用
问题描述 提示：这里描述项目中遇到的问题：
Could not find com.android.tools.build:gradle:4.1.2. 意思是：无法找到gradle:4.1.2的版本
原因分析： 提示：这里填写问题的分析：
出现这种情况，有可能是因为网络的问题，毕竟gradle官网是在国外，网速差的话可能就下载不下来 解决方案： 提示：这里填写该问题的具体解决方案：
1.1.打开build.gradle (Project)
2.添加国内的阿里云
buildscript { repositories { google() jcenter() maven { url "http://maven.aliyun.com/nexus/content/groups/public/" } } dependencies { classpath 'com.android.tools.build:gradle:4.1.2' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } allprojects { repositories { google() jcenter() maven { url "http://maven.aliyun.com/nexus/content/groups/public/" } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a62e489b5a66d4469272e40fd47b2d5/" rel="bookmark">
			Unity3D ugui获取ui控件屏幕坐标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 local worldPos = uiGo.Transform.position local uiCamera = GetUICamera() local screenPos = uiCamera:WorldToScreenPoint(worldPos) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cdbba3f282f1d8b008fe2e2b1369a98/" rel="bookmark">
			Python实现秒杀某宝商品抢购（附超详细代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双11过去了，前两天我干了一件惊天动地的大事，估计这件大事是很多小伙伴都想干的。我居然用python抢购淘宝商品，没想到吧，最勇敢的还是我。关于抢购的思路以及代码，我将会在这篇文章中详细的介绍，感兴趣的可以往下看哟！！！
目录 1.项目环境 2.某宝抢购流程分析 3.程序实现思路 4.代码实践与梳理 标题项目环境 •操作系统：Windows 10 Python学习交流Q群：903971231#### •开发环境：python3.7 •IDE：Pycharm •自动化模块：Selenium •安装命令：pip install selenium •浏览器版本：Google Chrome 99.0.4844.51 •浏览器驱动版本：ChromeDriver 99.0.4844.51 注意: 浏览器驱动版本与浏览器版本要一致！
我给大家准备了2022最新的Python免费学习资料、代码、教程等等，直接加群领取。
抢购流程分析 1.登录网站
2.购物车选中抢购商品
3.结算购买
4.提交订单
关键：快速完成前面流程，当订单进入提交页面时，付款时间不影响抢购。
程序实现思路 购物流程都是固定没有变化的，因此可以把购物流程步骤用代码编辑好交给selenium去自动执行。
项目结构：驱动直接复制放入项目根路径
1、导入对应类库实现对浏览器的操作
from selenium import webdriverimport datetime import time #自动打开浏览器并且最大化窗口driver = webdriver.Chrome()driver.maximize_window() 执行上述代码，浏览器会自动打开并显示如下,证明我们已经开始通过代码操控浏览器了。
2、用代码实现购物流程 2.1 访问某宝： driver.get('https://www.taobao.com') 2.2登录某宝： if driver.find_element_by_partial_link_text('亲，请登录'): driver.find_element_by_partial_link_text('亲，请登录').click() 2.3 进入购物车 #跳转到购物车页面driver.get('https://cart.taobao.com/cart.htm') 2.4 选中所有商品 #寻找全选选项并勾选if driver.find_element_by_id("J_SelectAll1"): driver.find_element_by_id("J_SelectAll1").click() 2.5 对比时间,提交结算(重点) def buy(buy_time): #buy_time 购买时间 while True: now = datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cdbba3f282f1d8b008fe2e2b1369a98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd26c1269e19c56d0de33f10f0eed120/" rel="bookmark">
			开发中-唯一标识符最佳做法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文提供了根据用例为应用选择合适标识符的指导。
如需大致了解 Android 权限，请参阅权限概览。有关使用 Android 权限的具体最佳做法，请参阅应用权限最佳做法。
使用 Android 标识符的最佳做法 在使用 Android 标识符时，请遵循以下最佳做法：
避免使用硬件标识符。在大多数用例中，您可以避免使用硬件标识符，例如 SSAID (Android ID)，而不会限制所需的功能。
Android 10（API 级别 29）对不可重置的标识符（包括 IMEI 和序列号）添加了限制。您的应用必须是设备或个人资料所有者应用，具有特殊运营商权限或具有 READ_PRIVILEGED_PHONE_STATE 特许权限，才能访问这些标识符。
只针对用户剖析或广告用例使用广告 ID。在使用广告 ID 时，请始终遵循用户关于广告跟踪的选择。此外，请确保标识符无法关联到个人身份信息 (PII)，并避免桥接广告 ID 重置。
尽一切可能针对防欺诈支付和电话以外的所有其他用例使用实例 ID 或私密存储的 GUID。对于绝大多数非广告用例，使用实例 ID 或 GUID 应已足够。
使用适合您的用例的 API 以尽量降低隐私权风险。使用 DRM API 保护重要内容，并使用 SafetyNet API 防止滥用行为。SafetyNet API 是能够确定设备真伪而不会招致隐私权风险的最简单方法。
本指南剩下的部分将以开发 Android 应用为背景详细介绍这些规则。
使用广告 ID 广告 ID 是一种可由用户重置的标识符，适用于广告用例。但是，在使用此 ID 时，请注意以下要点：
在重置广告 ID 时始终尊重用户的意愿。在未经用户同意的情况下，请勿使用其他标识符或指纹将后续广告 ID 关联起来，对用户重置进行桥接。Google Play 开发者内容政策声明如下：
“…重置后，在未获得用户明确许可的情况下，新的广告标识符不得与先前的广告标识符或由先前的广告标识符所衍生的数据相关联。”
始终尊重关联的个性化广告标记。广告 ID 是可配置的，用户可以限制与 ID 关联的跟踪数量。请务必使用 AdvertisingIdClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd26c1269e19c56d0de33f10f0eed120/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04fd633fccbe0a18dfb2e13a3fc66e56/" rel="bookmark">
			通俗易懂的牛顿下山法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
俗话说：好记性不如烂笔头，通过写文章的方式既可以加深自己的理解，又可以与大家分享，双赢，何乐而不为？ 古人陆游又曾说：纸上得来终觉浅，用来形容大学中的知识再合适不过了，方到用时，才有更深刻的理解，才对数学家们的智慧才更加敬佩！ **
回归正题 1、方法概述及演变过程 牛顿迭代法 是一种线性化方法，其基本是想是将非线性方程 f ( x ) = 0 f(x)=0 f(x)=0逐步归结为某种线性方程来求，也是求解 单变量非线性方程 最实用的方法之一，该方法在单根附近二阶收敛。和梯度下降法均属于最优化方法（后面会分析两者的优缺点），但应用时要选用较好的初值 x 0 x_{0} x0​ 近似才能保证迭代收敛，否则可能会发散（后面会举例说明）。
下山法，顾名思义，就是确保迭代过程中单调递减，即
∣ f ( x k + 1 ) ∣ &lt; ∣ f ( x k ) ∣ 式 ( 1.1 ) |f(x_{k+1})|&lt;|f(x_{k})| \qquad 式(1.1) ∣f(xk+1​)∣&lt;∣f(xk​)∣式(1.1)
将牛顿迭代法与下山法结合起来，得到 牛顿下山法，确保了迭代过程中，稳定收敛。
2、牛顿迭代法 牛顿公式的推导：
设已知方程 f ( x ) = 0 f(x)=0 f(x)=0 有近似根 x k x_{k} xk​,且 f ′ ( x k ) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04fd633fccbe0a18dfb2e13a3fc66e56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c93a722f103acb9f16a29c0754845d43/" rel="bookmark">
			就近值 reduce用法 时间戳与时间点对比循环查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后台接口返回的13为时间戳
需要与数据data的time做对比，查找出最近的值
data的数据结构如下：
将：改为空格，变成数字之间的对比
//查找最近的时间 getNearestTime(timestamp, data) { let date = new Date(timestamp) let h = date.getHours() let m = (date.getMinutes() &lt; 10 ? '0' + date.getMinutes() : date.getMinutes()) let hm = parseInt(h + '' + m) let nearestTime = '' let distance = 1000000 for (let i in data) { let time = parseInt(data[i].time.replace(':', '')) let dis = Math.abs(hm - time) if (dis &lt; distance) { distance = dis nearestTime = data[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c93a722f103acb9f16a29c0754845d43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f6ff82829c39ba06fb849676942161e/" rel="bookmark">
			C&#43;&#43; Qt 创建多线程，控制6组ABB输出到UI界面上，使用moveToThread方式，配合mutex,condition_variable实现，含优化代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
小项目需求：
分析：
实现：
输出A的槽：
输出B的槽：
优化逻辑：
最终跑起来效果如下：
完整代码也贴出来吧，这样大家好参考一下：
本篇内容主要涉及到的相关技术有：多线程，多线程创建的方式 moveToThread，互斥锁 mutex,条件变量 condition_variable，唯一锁 unique_lock 等。
小项目需求： 在Qt程序中有2条线程，可分别输出A、B字符，每条线程只能启动一次，想办法控制输出顺序为：ABBABBABBABBABBABB共六组，输出到Ui界面上，用标签来显示即可
分析： 创建线程倒是不难，使用Qt来创建的话，可以考虑使用moveToThread的方式来实现，这个项目主要考察的是如何控制2条线程的输出顺序，观察字符的规律可以发现，每3个字符就是一个组合，3个一组，这样的话，就能拿到3这个特殊的数字，共6组数，有6个A，12个B，所以一开始可以很直白的创建2个槽函数，来分别输出A或者B就可以初步效果了，加上互斥锁和条件变量的配合，使用一个字符计数器来全局统计一下，将计数器对3取余，判断余数就可以轻松实现效果，当能除尽时，余数为0，可以输出A，当余数为1或者2时，输出B，最后可以将要输出的内容通过信号的方式发给主界面即可，只需要在主界面里面再增加一个槽函数来处理这个信号即可。
实现： 两个先简单输出的槽，就可以轻松实现出来了：
全局使用3个变量，方便操作：
int g_cnt=0; mutex g_mtx; condition_variable g_conv; 输出A的槽： void MyThread::outA() { for(int i=0;i&lt;6;++i){ unique_lock&lt;mutex&gt; ul(g_mtx); g_conv.wait(ul,[=]{return g_cnt % 3 == 0;}); qDebug()&lt;&lt;"A"; g_cnt++; g_conv.notify_all(); } } 输出B的槽： void MyThread::outB() { for(int i=0;i&lt;6*2;++i){ unique_lock&lt;mutex&gt; ul(g_mtx); g_conv.wait(ul,[=]{return g_cnt % 3 != 0;}); qDebug()&lt;&lt;"B"; g_cnt++; g_conv.notify_all(); } } 写完这2个核心的线程槽函数之后，发现代码居然如此雷同，重复率太高了，那是不是可以考虑优化一下代码？
答案是肯定的，必须优化，要不然此代码婶婶可忍，叔叔不可忍呀；
优化逻辑： 可以考虑把需要优化的地方给提炼出来，使用一个变量来取代，那这样就可以优化2个地方：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f6ff82829c39ba06fb849676942161e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/545d13ae9f90ba3d771a1d805baf6402/" rel="bookmark">
			2.正多边形的组合图形（Goc ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		50.十字徽型（魔法学院第7课） 解题思路： （1）先确定起笔位置，一般选择竖线下端。
（2）模拟绘制，先画内环。
（3）内环每一条边的起点就是外环正多边形的起点，再模拟画外环。
对应（2）的代码
int main(){ p.c(10);//注意颜色放在外面 for(int i=0;i&lt;10;i++) { //画内环 p.fd(50).rt(360.0/10); } return 0; } 对应（3）的代码
int main(){ p.c(10);//注意颜色放在外面 for(int i=0;i&lt;10;i++) { //画三角形 for(int j=0;j&lt;3;j++) p.fd(50).rt(120); //画内环 p.fd(50).rt(360.0/10); } return 0; } 112.第2题：花朵(比赛模拟题) 时限：5s 空间：256m 通过次数：18220
题目描述 看到你绘制的漂亮领奖台，小C觉得应该再摆放些花朵更满意。小C设计了几种不同颜色、边长和边数的“多边形花朵”（见输入输出样例），但不确定哪种好看些。 为了研究什么颜色、边长和边数的花更好看，下C需要编制一个通用的程序：键盘输入颜色、边长和边数，就可以画出相应的花朵。
输入格式 一行3个空格分隔开的正整数：分别表示颜色、边长和边数。
输出格式 相应的花朵图形。
输入/输出例子1 输入：
2 50 4
输出：
输入/输出例子2 输入：
3 35 7
输出：
输入/输出例子3 输入：
6 30 12
输出：
解题思路： （1）确定内环的起笔位置，一般选择竖线下端；
（2）模拟绘制，先画内环。
（3）内环每一条边的起点就是外环正多边形的起点，再模拟画外环。
错误示范：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/545d13ae9f90ba3d771a1d805baf6402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1f7214ec13d75c1c6af69e278a99481/" rel="bookmark">
			Python函数传递参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		严格来讲，python中并不存在值传递和引用传递的说法，准确地说，Python 的参数传递是赋值传递 （pass by assignment），或者叫作对象的引用传递（pass by object reference），使用这两个说法只是为了更好地联系已经学过的内容，方便进行类比分析。
在 Python 中：
1、变量的赋值，只是表示让变量指向了某个对象，并不表示拷贝对象给变量；而一个对象，可以被多个变量所指向。
2、可变对象（列表，字典，集合等等）的改变，会影响所有指向该对象的变量。
3、对于不可变对象（字符串、整型、元组等等），所有指向该对象的变量的值总是一样的，也不会改变。但是通过某些操作（+= 等等）更新不可变对象的值时，会返回一个新的对象。
def fun(lst, num, string): lst += ['yes'] num += 1 string += 'abc' lst = list('hello') num = 100 string = 'def' print('befor:') print(lst, num, string) fun(lst, num, string) print('after:') print(lst, num, string) 输出：
befor: ['h', 'e', 'l', 'l', 'o'] 100 def after: ['h', 'e', 'l', 'l', 'o', 'yes'] 100 def 从中可以看到，对列表的修改是作用在原对象上的，而对数字，字符串的修改不是直接作用在原对象上的。
再看例子：
def my_func4(l2): l2 = l2 + [666] l1 = [1, 2, 3] print('befor:') print(l1) print('after:') my_func4(l1) print(l1) 输出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1f7214ec13d75c1c6af69e278a99481/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/442843d29ac113164e2bb6366f7a7ab7/" rel="bookmark">
			vue2常用自定义指令封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// throttleDirective.js // 一些常用的自定义指令 import Vue from 'vue' // 节流函数 Vue.directive('throttle', { inserted: function(el, binding) { let timeoutId let lastExecutedTime = 0 const { value, arg, modifiers } = binding const delay = modifiers.immediate ? +arg || 200 : +arg || 0 const execute = function() { clearTimeout(timeoutId) value(); lastExecutedTime = Date.now() } el.addEventListener('click', function() { const currentTime = Date.now() if (currentTime - lastExecutedTime &gt;= delay) { execute() } else { clearTimeout(timeoutId) timeoutId = setTimeout(execute, delay) } }) } }) // 外部点击 Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/442843d29ac113164e2bb6366f7a7ab7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8732027de24989cb3beae6e4a67273cb/" rel="bookmark">
			关于 uniapp 的 WebSocket 封装（心跳检测、断线重连）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 基于 uniapp 提供的 WebSocket Api 来进行封装，让你的 WebSocket 功能更加强大！
实现思路 心跳检测
客户端定时向服务端发送"ping"，如果服务端在一定的时间内，没有返回给客户端"pong"，那么就判断为离线。
断线重连
客户端监测到服务端断线后，就重新初始化 WebSocket 类，然后再进行检测，反复操作，直到连接成功为止。
代码实现 websocket.js
function pickJsonObj(value) { try { return JSON.parse(value) } catch (e) { return null; } } class WebSocketClient { constructor(url) { this.url = url; this.socket = null; this.isReconnecting = false; this.reconnectInterval = 3000; // 重连间隔，单位毫秒 this.heartBeatInterval = 5000; // 心跳间隔，单位毫秒 this.pingTimeoutDuration = 1000; // 超过这个时间，后端没有返回pong，则判定后端断线了。 this.heartBeatTimer = null; this.destroy = false; // 是否销毁 } connect() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8732027de24989cb3beae6e4a67273cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8734090edcad23abb769e54b433bfdf0/" rel="bookmark">
			小程序内嵌的H5缓存机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我们项目一直做的是小程序内嵌H5聊天室的项目
最近遇到了个奇怪的bug，当在聊天页面聊天的时候，点击了H5项目的链接，跳转出去了，回来之后，别人发的消息H5页面就看不到了。
按照在浏览器开发的逻辑，点击外部链接，再回来，其实相当于刷新页面。然而在刷新页面的时候，前端会去走接口请求全部的聊天记录，这样你在走期间的所有消息也会被展示。
想是这么想的，浏览器上运行也没有问题，但是真机测试的时候发现了问题。
在ios机型上，跳转外部链接，再回来不会重新请求历史记录接口，但是之前渲染的聊天气泡都在，这就导致，在离开的这个期间，对方发的所有消息，H5页面都是不会再继续展示的，展示的还是之前的消息。这是因为ios与安卓的浏览器缓存机制的问题导致的。
解决这个问题的关键是，有些接口当页面重新回来的时候要重新加载一遍，我们可以把这一部分接口放进window的onpageshow事件里面去。当页面重新展示的时候，我去加载一遍我的接口。
可以进行机型检测，当只有苹果机型，并且能确定页面是从缓存读取出来的时候，我再去重新刷新页面。
window.onpageshow = function(event) { // persisted判断页面是不是从缓存里面读取出来的 if (event.persisted) { if (isweixin()) { // 判断是不是微信ios环境 if (window.__wxjs_is_wkwebview) { // 刷新页面 window.location.reload() } } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23de271bf60a32d975b08d8f10103c33/" rel="bookmark">
			ensp简单校园网综合实验（HCIA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验概述 本实验旨在模拟一个真实的校园网环境，包括宿舍楼和教学楼两个区域，并使用一系列网络技术来实现内网设备的互通、网络安全和互联网访问。我们将使用VLAN、RSTP、VRRP、OSPF多区域、浮动路由、NAT、ACL、DHCP等技术来进行配置。
二、实验拓扑 实验拓扑图显示了两个建筑物（宿舍楼和教学楼），通过一个接入交换机与汇聚层相连。两个汇聚交换机（Agg01和Agg02）被配置为网关，每栋楼的主机都属于不同的VLAN（VLAN10和VLAN20）。本实验将展示如何使用RSTP和VRRP技术实现主备负载均衡，并在汇聚层配置DHCP以提供动态地址分配和可扩展性。核心和出口路由器之间的连接将通过OSPF协议实现，该协议能够自动发现网络路由并划分不同的区域。为了提高网络的可靠性和稳定性，出口路由器将采用NAT技术来转换内部和外部网络地址，同时配置主备浮动静态路由以连接两个外部运营商。最后，为了确保两栋楼可以访问互联网，我们将配置外网连接一台服务器，并通过相应的配置实现互联网访问。
2.1 VLAN信息表 设备名称
端口
链路类型
VLAN 参数
HZ-HZCampus-Agg01-S5731
GE0/0/1
Trunk
PVID:1
Allow-pass：10 20
Eth-trunk1（GE0/0/2,0/0/3,0/0/23）
Trunk
PVID:1
Allow-pass：10 20
GE0/0/24
Access
PVID：101
HZ-HZCampus-Agg02-S5731
GE0/0/1
Trunk
PVID:1
Allow-pass：10 20
Eth-trunk1（GE0/0/2,0/0/3,0/0/23）
Trunk
PVID:1
Allow-pass：10 20
GE0/0/24
Access
PVID:102
HZ-HZCampus-Acc01-S5731
GE0/0/1
Trunk
PVID:1
Allow-pass：10 20
GE0/0/2
Trunk
PVID:1
Allow-pass：10 20
GE0/0/23
Access
PVID:20
GE0/0/24
Access
PVID:10
HZ-HZEDU-Acc01-AR6140
GE0/0/1
Access
PVID:1
GE0/0/2
Access
PVID:1
GE0/0/3
Access
PVID:1
2.2 IP地址规划表 设备名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23de271bf60a32d975b08d8f10103c33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03af44d18ee24cf1c1eafbb01ef93972/" rel="bookmark">
			yum安装node,npm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 node官网
添加下载源
curl -sL https://rpm.nodesource.com/setup_14.x | sudo bash -
yum -y install nodejs npm 查看版本
npm -v node -v 卸载
yum -y remove nodejs npm 修改镜像源
4.1. 修改淘宝镜像源
set registry https://registry.npm.taobao.org npm config get registr 4.2. 修改华为云镜像源
npm config set registry https://mirrors.huaweicloud.com/repository/npm/ npm config get registry 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c370bc6f7d65f7e424ef56244a05ac4b/" rel="bookmark">
			高版本模拟器安装burp证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载burp证书，安装openssl
http://burp 自己找官网安装openssl Win32/Win64 OpenSSL Installer for Windows - Shining Light Productions (slproweb.com) 二、查看模拟器端口并连接
adb devices
adb remount
openssl x509 -inform der -in cacert.der -out burp.pem
openssl x509 -subject_hash_old -in burp.pem
新建文件夹
三、 改下生成的burp.cer,并传到模拟器里
burp.pem改名为9a5ba575.0
adb push 9a5ba575.0 /system/etc/security/cacerts/
最后成功抓包，无证书警告：
参考链接：
https://blog.csdn.net/weixin_50995890/article/details/134176933
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c638cb6109128c167f14bbd3c3f10278/" rel="bookmark">
			微信小程序获取用户手机号码教程（前端&#43;后端）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 文章目录 系列文章目录前言一、前端实现获取用户手机号码1.前端获取用户登录凭证 code2.后端解析用户登录凭证获取手机号码 二、注意事项总结 前言 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站，这篇文章男女通用，看懂了就去分享给你的码吧。
在开发微信小程序时，获取用户手机号码是常见的需求之一。本教程将为你详细介绍如何在前端和后端实现获取用户手机号码的功能，以及如何保护用户隐私和安全。
一、前端实现获取用户手机号码 在微信小程序中，可以通过调用 wx.login() 获取用户的登录凭证 code，然后将 code 发送给后端服务器，由后端通过微信提供的接口获取用户的手机号码。具体步骤如下：
1.前端获取用户登录凭证 code 在前端页面的逻辑层中，调用 wx.login() 方法获取用户的登录凭证 code，并将其发送给后端服务器。
// 前端页面的逻辑层 wx.login({ success: (res) =&gt; { if (res.code) { // 获取到用户登录凭证 code const code = res.code; // 将 code 发送给后端服务器 wx.request({ url: 'https://your-backend-server.com/getPhoneNumber', data: { code: code }, method: 'POST', success: (res) =&gt; { console.log(res.data); }, fail: (err) =&gt; { console.error('请求后端接口失败', err); }, }); } else { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c638cb6109128c167f14bbd3c3f10278/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c91d648b991608a723f7f8fae3e5616/" rel="bookmark">
			链表的增删改查(python实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链表的增删改查 使用python实现链表的增删改查
增
add(val)：在头结点处增加，左插入append(val)：在尾结点处增加，右插入 删
remove_single(target)：删除值为target的第一个节点remove_all(target)：删除值为target的所有节点 查
search(target)：返回值为target的第一个节点索引get(index)：返回索引位置为index的第一个节点的值 # -*-coding:utf-8-*- # 链表的增删改查 class Node: def __init__(self, val: int) -&gt; None: self.val = val self.next: Node | None = None class LinkedList: def __init__(self) -&gt; None: self._head = None def is_empty(self): """判断是否为空""" return self._head is None def get(self, index: int) -&gt; int | None: """获取index位置的值""" if self.is_empty(): print('linked list is empty') return if index &lt; 0 or index &gt; self.size - 1: raise IndexError('index out of range!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c91d648b991608a723f7f8fae3e5616/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cda097a83d4b8a98cf0177f0a2504d9/" rel="bookmark">
			计算机视觉基础（9）——相机标定与对极几何
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本节我们将学习相机标定和对极几何两部分的内容。
在相机标定部分，我们将学习直接线性变换（Direct Linear Transform, DL）,张正友标定法（Zhang’s Method）和 Perspective-n-Point (PnP) 这三种方法。
在对极几何部分，我们将了解极平面、基线、极点和极线等概念，以及相机相对位姿估计和对极约束。
一、相机标定 1.1 相机内外参 内参：描述相机本身的属性，同一相机，内参固定
外参：描述相机的姿态、位置，随时间变化
让我们来回顾一下相机的成像过程
1.2 相机标定概述 通过实验的方法计算和估计相机内外参数的过程称为相机标定(Camera Calibration)
相机标定的应用有：
• 矫正透镜畸变（内参标定） • 建立相机成像几何模型，实现三维重构
相机标定的意义：
• 相机标定是非常关键的环节，标定结果的精度直接影响相机工作产生结果的准确性 • 做好相机标定是做好后续工作的前提 下面讲解三种相机标定的常见方法：
• 直接线性变换 (Direct Linear Transform, DLT)——同时估计内外参 • 张正友标定法 (Zhang’s Method)——估计内参 • Perspective-n-Point (PnP)——估计外参
1.3 直接线性变换（DLT） 1.3.1 基本设定 • 已知：部分参考点在图像坐标系和世界坐标系下的坐标 • 求解：相机的内参矩阵𝑲、外参𝑹与𝒕 1.3.2 世界坐标系到图像坐标系的映射 1.3.3 关于矩阵M自由度的解释 1.3.4 DLT算法的基本思路和流程 1.3.5 小结 • DLT方法通过计算未标定数据 (Uncalibrated Camera)的映射参数矩阵𝑀，来计算相机内外参 • 需要已知至少6个观测点的世界坐标和图像坐标 • 当已知观测点近似落在同一平面时，DLT求解不稳定
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cda097a83d4b8a98cf0177f0a2504d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2a7e1baa04683c9ef1644cf66888be4/" rel="bookmark">
			CSDN新手指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN新手指南 一、什么是CSDN？
文章目录 CSDN新手指南一、什么是CSDN？二、使用步骤1.首先我们打开CSDN官方网站2.如何发布自己的文章3.使用[Markdown编译器](MD编辑器)4.为什么使用Markdown编译器5.编写文章6.发布 总结 一、什么是CSDN？ CSDN（全称为中国软件开发网）是一个致力于服务中国软件开发者的社区平台。它提供了大量的软件开发技术文章、教程、案例、工具等资源，涵盖了 Java、Python、C++ 等众多编程语言，以及前端开发、后端开发、数据科学、人工智能等多个领域。此外，CSDN还提供了职业培训、IT 资讯、数据分析等方面的服务，是国内开发者非常重要的学习和交流平台之一。
二、使用步骤 1.首先我们打开CSDN官方网站 效果如下
这是CSDN官网的首页 点击登录即可
2.如何发布自己的文章 方法1
方法2
两个方法均可使用
3.使用Markdown编译器 Markdown编译器可以帮助我们可以快速编辑自己的文章。
4.为什么使用Markdown编译器 CSDN选择使用Markdown编译器有多个原因。首先，Markdown作为一种轻量级的标记语言，具有简洁、易读、易写的特点。它的语法简单，能够让作者直接输入标记，无需鼠标操作就能完成排版，从而提高写作效率。此外，Markdown文件可以被各种文本编辑器打开和编辑，即使编辑器不能识别Markdown的语法格式，也能将.md的文件当作.txt格式来显示，这为作者提供了极大的便利性。在CSDN上，用户可以选择使用Markdown作为默认的编辑器，从而实现更高效的写作体验。
5.编写文章 选择Markdown编译器进行制作文章
选择喜欢的模板进行编辑：
作者可以根据自己的需求对文章进行编写
6.发布 作者可以根据自己的需求对文章发布的时候进行一些修改再进行发布
总结 CSDN是一个资源丰富、交流互动的平台，适合IT技术人员学习和交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31bf8855416f79252d5293f615632a8f/" rel="bookmark">
			AIGC｜实践探索Langflow集成AzureOpenAI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、背景
二、AzureOpenAI介绍
三、langflow集成支持AzureOpenAI
langflow集成AzureOpenAI联通改造流程：
四、效果演示
一、背景 langflow是一个LangChain UI，它提供了一种交互界面来使用LangChain，通过简单的拖拽即可搭建自己的实验、大数据模型flow。
由于目前langflow的流程中不支持AzureOpenAI，因此本文将介绍如何在langflow中引入AzureopenAI。
二、AzureOpenAI介绍 Azure OpenAI是一种云服务，帮助企业和开发人员快速构建、训练和部署AI应用程序。该服务运行在Microsoft Azure上，因此用户无需购买专门的硬件或软件。它利用OpenAI强大的语言模型（如GPT-3、Codex、Embeddings等），通过REST API进行调用，并能够轻松调整以适应特定任务。
最重要的是，Azure OpenAI允许用户申请API_KEY，以便在国内直接使用大模型进行训练。相比之下，使用openAI可能需要魔法环境，而Azure OpenAI更加稳定。
三、langflow集成支持AzureOpenAI 首先在配置文件中增加AzureOpenAI的配置，让其可以在前端页面组件中展示出来，如下图所示：
重新启动后可以页面的LLms中看到AzureOpenAI组件，接下来分析页面节点组件初始化过程，页面节点组件初始化接口如下所示：
langflow集成AzureOpenAI联通改造流程： 1：分析langflow引入langchain的python库实现openAI的连接
openAI实现方式与AzureOpenAI的区别
# openAI初始化大模型llm importos os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY fromlangchain.llms importOpenAI fromlangchain importPromptTemplate, LLMChain template = """Question: {question} Answer: Let's think step by step.""" prompt = PromptTemplate(template=template, input_variables=["question"]) llm = OpenAI() langflow初始化openAI只需要OPENAI_API_KEY即可，AzureOpenAI需要参数OPENAI_API_TYPE 现有的组件配置不支持此参数，会导致AzureOpenAI初始化失败，因此langflow暂未开放集成AzureopenAI。
langflow改造instantiate_based_on_type 通用初始化llm组件的地方需要根据AzureOpenAI特殊处理，添加AzureOpenAI的instantiate方法即可。
# 核心初始化AzureOpenAI方法 def instantiate_azureOpenAI(class_object, params): return class_object(deployment_name=params.get('model_name'), model_name=params.get('model_name') ,openai_api_key=params.get('openai_api_key'),openai_api_base=params.get('openai_api_base') ,openai_api_type="azure",openai_api_version=params.get('openai_api_version')) 四、效果演示 启动langflow前后端服务，访问前端服务界面 导入Basic Chat 模板flow 替换open的llms 如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31bf8855416f79252d5293f615632a8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a9f95b08bfa16f6ee3dc128e0f6eced/" rel="bookmark">
			css 灰质彩色的边框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 border: 4px solid transparent; background-color:#fff; background-clip: padding-box,border-box; background-origin:padding-box, border-box; background-image: linear-gradient(90deg,#F5F6FA,#F5F6FA 42%,#F5F6FA),linear-gradient(151deg,#33e9bf,#c7e58a,#b1e8cc); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0f0451e019369ddd734d8aed8ab1a63/" rel="bookmark">
			解决opencv中使用cv2.imshow不显示图片问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在使用opencv中的cv2.imshow显示图片的时候总会出现如下错误：cv2.error: OpenCV(4.8.1) D:\a\opencv-python\opencv-python\opencv\modules\highgui\src\window.cpp:1272: error: (-2:Unspecified error) The function is not implemented. Rebuild the library with Windows, GTK+ 2.x or Cocoa support. If you are on Ubuntu or Debian, install libgtk2.0-dev and pkg-config, then re-run cmake or configure script in function 'cvShowImage'
1：查找了很多资料发现是在安装opencv的时候安装顺序出现了问题，于是执行下面代码，重新安装imshow就能成功显示图片了
pip uninstall opencv-python pip uninstall opencv-contrib-python pip install opencv-contrib-python pip install opencv-python 二：模块冲突，卸载opencv-contrib-python，查看以下几种包之间依赖
大概率解决问题。
opencv-python: 只包含opencv库的主要模块. 一般不推荐安装. opencv-contrib-python: 包含主要模块和contrib模块, 功能基本完整, 推荐安装. opencv-python-headless: 和opencv-python一样, 但是没有GUI功能, 无外设系统可用. opencv-contrib-python-headless: 和opencv-contrib-python一样但是没有GUI功能. 无外设系统可用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47f213fc45ec1f137ca53ec40c8757b4/" rel="bookmark">
			操作系统(五)文件系统和I/O系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言文件系统文件系统和文件文件描述符目录、文件别名和文件系统分层文件系统目录实现文件别名名字解析（路径遍历）文件系统挂载文件系统种类 虚拟文件系统文件缓存和打开文件打开文件 文件分配空闲空间管理和冗余磁盘阵列RAID空闲空间管理冗余磁盘阵列RAID(Redundant Array of Indexpensive Disks) I/O系统同步与异步I/OI/O结构I/O控制方式I/O数据传输磁盘调度1. 先进先出FIFO算法2. 最短服务时间优先（SSTF）3. 扫描算法（SCAN）(电梯算法)4. 循环扫描算法（C-SCAN）5. LOOK与C-LOOK算法6. N步扫描（N-step-SCAN）算法7. 双队列扫描算法（FSCAN）算法 磁盘缓存 小结 前言 本文主要涉及操作系统的简介、硬件结构、内存管理、进程管理、文件系统、设备管理等内容，可以作为学习操作系统的辅助文本记录。撰写本文的目的主要是针对操作系统整体做一个相对完整的梳理，以便后续回顾之用。
本文是第五篇，讲述操作系统的文件系统和I/O系统。
第一篇：操作系统(一)基础知识及操作系统启动
第二篇：操作系统(二)内存管理的基础知识
第三篇：操作系统(三)进程和线程的基础知识
第四篇：操作系统(四)进程和线程的调度算法、同步互斥、通信、死锁等
文件系统 文件系统和文件 文件系统：操作系统中管理持久性数据的子系统，提供数据存储和访问功能
组织、检索、读写访问数据大多数计算机系统都有文件系统Google也是一个文件系统 文件：具有符号名，由字节序列构成的数据项集合
文件系统的功能：
分配文件磁盘空间
管理文件块（位置和顺序）
管理空闲空间（位置）
分配算法（策略）
管理文件集合
定位：文件及其内容
命名：通过名字找到文件
文件系统结构：文件组织方式
数据可靠和安全
安全：多层次保护数据安全
可靠：持久保存文件；避免系统泵快、媒体错误、攻击等
文件属性：
名称、类型、位置、大小……
文件头：文件系统元数据中的文件信息
文件属性
文件存储位置和顺序
文件描述符 文件描述符：操作系统在打开文件表中维护的打开文件状态和信息 文件指针：最近一次读写位置；每个进程分别维护自己的 打开文件指针文件打开计数：当前文件打开的次数；最后一个打开该文件的进程关闭文件时，就可以将其从文件表中去除了。文件在磁盘上位置：缓存数据访问信息访问权限：每个进程的文件访问模式信息 文件的用户视图 持久的数据结构 系统访问接口 字节序列的集合（UNIX）系统不关心存储磁盘上的数据结构 操作系统的文件视图 数据块的集合数据块是逻辑存储单元，而扇区是物理存储单元 进程读文件 获取字节所在的数据块返回数据块内对应部分 进程写文件 获取数据块修改数据块中对应部分写回数据块 文件系统中的基本操作单位是数据块访问模式： 顺序访问：按字节依次读取随机访问：从中间读写索引访问：依据数据特征索引 文件内部结构 无结构：字节序列简单记录结构：分列、固定长度、可变长度等复杂结构：可执行文件、PDF等 文件共享和访问控制 多用户系统的文件共享是很必要的访问控制：每个用户能够获得哪些文件的哪些访问权限 访问模式：读、写、执行等 目录、文件别名和文件系统 分层文件系统 文件是以目录的方式组织起来
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47f213fc45ec1f137ca53ec40c8757b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/149369bbea10fae530d660faad5fc774/" rel="bookmark">
			[C&#43;&#43;学习笔记]:二叉树进阶:搜索二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 搜索二叉树基础概念二叉搜索树的性能分析 具体实现底层成员主要功能1.二叉搜索树的查找2.二叉搜索树的插入3.二叉搜索树的删除4.中序遍历5.通过递归实现查找,插入,删除6.构造,析构,赋值重载 Key模型和 Key_Value模型底层成员具体实现 OJ题目练习 注:这里是初学者的笔记,可能会出错,如果有错,希望你能提醒我. 搜索二叉树 基础概念 学习原因:
map和set特性需要先铺垫二叉搜索树，而二叉搜索树也是一种树形结构
性质:
若它的左子树不为空，则左子树上所有节点的值都小于根节点的值若它的右子树不为空，则右子树上所有节点的值都大于根节点的值它的左右子树也分别为二叉搜索树 功能:
可以搜索自带排序功能去重,重复值插入失败 搜索二叉树的结构由插入顺序决定
二叉搜索树的性能分析 插入和删除操作都必须先查找，查找效率代表了二叉搜索树中各个操作的性能。 对有n个结点的二叉搜索树，若每个元素查找的概率相等，则二叉搜索树平均查找长度是结点在二叉搜索树的深度的函数，即结点越深，则比较次数越多。 但对于同一个关键码集合，如果各关键码插入的次序不同，可能得到不同结构的二叉搜索树： 最优情况下，二叉搜索树为完全二叉树(或者接近完全二叉树)，其平均比较次数为：log_2(N) 最差情况下，二叉搜索树退化为单支树(或者类似单支)，其平均比较次数为：N 具体实现 像放全部实现代码:
#pragma once #include &lt;iostream&gt; using namespace std; //二叉搜索树	数据结构 namespace Key { template&lt;class K&gt; struct BSTreeNode { BSTreeNode&lt;K&gt;* _left; BSTreeNode&lt;K&gt;* _right; K _key; BSTreeNode(const K&amp; key) :_left(nullptr) , _right(nullptr) , _key(key) {} }; template&lt;class K&gt; class BSTree { typedef BSTreeNode&lt;K&gt; Node; public: // 默认构造, 显示写了构造(拷贝构造),编译器就不生成默认构造,可以用default强制生成 BSTree() = default; BSTree(const BSTree&lt;K&gt;&amp; b) { CopyTree(_root, b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/149369bbea10fae530d660faad5fc774/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d143c716b4256d69f3349585991d0484/" rel="bookmark">
			【速成】蓝桥杯嵌入式省一教程：（十一）UART串口通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与I2C、SPI一样，UART是一种通信协议，设备之间依靠Rx(Receive)与Tx(Transmit)两条线进行数据传输。一个单片机通常内置有多个UART，而这些UART通常都与单片机上的USB接口连接在一起，因此只需要将单片机通过数据线与电脑相连，即可实现单片机与电脑的UART串口通信。
下面我们就来看看如何实现串口通信功能。首先配置好Cube中有关UART的设置：
首先选择USART1/2/3/UART4中的任意一个（USART与UART的区别是USART可以进行同步通信，UART只能进行异步通信），将Mode设置为Asynchronous（异步），将Baud Rate（波特率）设置为9600。同步是指通信设备之间使用同一个时钟信号传输数据，而异步是指使用约定的波特率（即数据传输速率）进行数据传输与接收。 打开中断：
在这里中断是用于接收。我们只能控制发送的时间，却不能控制接收的时间，因为不知道对方什么时候会发送数据，因此我们使用接收中断，当接收到数据时进入中断函数进行处理。
首先我们来看看如何用单片机向电脑发送信息，这需要用到HAL库的UART发送函数：
/** * @brief Send an amount of data in blocking mode. * @note When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), * the sent data is handled as a set of u16. In this case, Size must indicate the number * of u16 provided through pData. * @note When FIFO mode is enabled, writing a data in the TDR register adds one * data to the TXFIFO.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d143c716b4256d69f3349585991d0484/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0452b806c5e03a35bdbdd6a2e9c2378/" rel="bookmark">
			【Phoenix】请求的生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文的目的是讨论Phoenix请求的生命周期。我们实战添加两个新的页面，并讨论整个过程是如何串起来的。
让我们从添加第一个新页面开始。
添加一个新页面 web应用通常通过将HTTP方法和路径映射到应用的某个函数来处理请求。Phoenix通过路由器来实现这个匹配。例如将”/articles”映射到显示文章的函数。因此，添加一个页面首先要添加一个新的路由。
新建路由 控制器和动作通过路由器关联它要处理的HTTP方法和路径。在Phoenix中，控制器对应者Elixir的模块，动作是控制器下定义的方法。
动作本质上就是一个处理请求的函数，在Go语言中，称为处理器函数，Phoenix使用了”action”一词来表述它，翻译为动作确实略显生硬，阅读时可以理解为每个请求对应的动作。但对于其本质一定要拿捏准确。
对于新的应用，Phoenix为我们生成了一个路由器文件 lib/hello_web/router.ex ，它也是本章的主角。
在前面例子中欢迎页的路由如下：
get "/", PageController, :home 让我们看看这个路由干了什么。访问 http://localhost:4000 向跟目录发起一个HTTP GET请求。这个请求会被 lib/hello_web/controllers/page_controller.ex 文件定义的 HelloWeb.PageController 中的 home/2 函数处理。
我们会新建一个页面，当访问 http://localhost:4000/hello 时，输出”Hello World, from Phoenix!”。
我们要做的第一件事是添加一个页面路由。打开 lib/hello_web/router.ex ，对于一个全新的应用，内容如下：
defmodule HelloWeb.Router do use HelloWeb, :router pipeline :browser do plug :accepts, ["html"] plug :fetch_session plug :fetch_live_flash plug :put_root_layout, html: {HelloWeb.Layouts, :root} plug :protect_from_forgery plug :put_secure_browser_headers end pipeline :api do plug :accepts, ["json"] end scope "/", HelloWeb do pipe_through :browser get "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0452b806c5e03a35bdbdd6a2e9c2378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf1e5821a438d14f002fd20acda6a349/" rel="bookmark">
			【RDMA】librdmacm库和连接建立过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述： rdma_cm是用于建立RDMA传输上的通信的管理器。
说明： RDMA CM是一个用于建立可靠连接和不可靠数据报数据传输的通信管理器。它为建立连接提供了一个RDMA传输中立的接口。该API基于套接字，但为队列对（QP）的语义进行了调整：通信必须通过特定的RDMA设备进行，并且数据传输是基于消息的。
RDMA CM仅提供RDMA API的通信管理（连接建立/拆除）部分。它与libibverbs库定义的verbs API配合使用。libibverbs库提供了发送和接收数据所需的接口。
客户端操作： 此部分提供了通信的主动端（或客户端）的基本操作概述。一般的连接流程如下：
1. rdma_create_event_channel：创建接收事件的通道。
2. rdma_create_id：分配一个rdma_cm_id，类似于socket。
3. rdma_resolve_addr：获取本地RDMA设备以到达远程地址。
4. rdma_get_cm_event：等待RDMA_CM_EVENT_ADDR_RESOLVED事件。
5. rdma_ack_cm_event：确认事件。
6. rdma_create_qp：为通信分配一个QP。
7. rdma_resolve_route：确定到达远程地址的路由。
8. rdma_get_cm_event：等待RDMA_CM_EVENT_ROUTE_RESOLVED事件。
9. rdma_ack_cm_event：确认事件。
10. rdma_connect：连接到远程服务器。
11. rdma_get_cm_event：等待RDMA_CM_EVENT_ESTABLISHED事件。
12. rdma_ack_cm_event：确认事件。
13. 在连接上执行数据传输。
14. rdma_disconnect：撤销连接。
15. rdma_get_cm_event：等待RDMA_CM_EVENT_DISCONNECTED事件。
16. rdma_ack_cm_event：确认事件。
17. rdma_destroy_qp：销毁QP。
18. rdma_destroy_id：释放rdma_cm_id。
19. rdma_destroy_event_channel：释放事件通道。
用于在节点之间建立不可靠数据报（UD）通信的过程几乎相同。但是，QPs之间不会形成实际的连接，因此不需要断开连接。
虽然此示例显示客户端发起断开连接，但连接的任一方都可以发起断开连接。
服务器操作： 此部分提供了通信的被动端（或服务器端）的基本操作概述。一般的连接流程如下：
1. rdma_create_event_channel：创建接收事件的通道。
2. rdma_create_id：分配一个rdma_cm_id，类似于socket。
3. rdma_bind_addr：将本地端口号设置为监听的端口号。
4. rdma_listen：开始监听连接请求。
5. rdma_get_cm_event：等待带有新的rdma_cm_id的RDMA_CM_EVENT_CONNECT_REQUEST事件。
6. rdma_create_qp：在新的rdma_cm_id上为通信分配一个QP。
7. rdma_accept：接受连接请求。
8. rdma_ack_cm_event：确认事件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf1e5821a438d14f002fd20acda6a349/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fed702286053e44cb4fd6af97f01ddd/" rel="bookmark">
			Spring boot导入jackson相关maven依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：1.x版本使用的是codehaus的库，2.0之后改成fasterxml，建议使用2.0以后的版本。
版本一： &lt;!-- jackson 1.x 相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-core-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; 版本二： &lt;!-- jackson 2.x 相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; 引入过程遇到问题： Failed to instantiate [com.fasterxml.jackson.datatype.jsr310.JavaTimeModule]: Constructor threw exception; nested exception is java.lang.NoClassDefFoundError: com/fasterxml/jackson/datatype/jsr310/ser/ZoneIdSerializer 排查一看，是因为在pom文件中导入了谷歌的jackson-datatype-guava依赖，导致了版本冲突，将版本修改一致即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/230db0271b73370226b2a65f102604d3/" rel="bookmark">
			vagrant&#43;virtualbox的踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vagrant + virtualbox 文章目录 vagrant + virtualbox一、导入虚拟机ova文件失败二、修改虚拟机的保存位置三、无法使用xshell等软件用密码进行连接四、vagrant up失败 一、导入虚拟机ova文件失败 背景：手动删除了虚拟机文件导致无法重新导入相同名称虚拟机的ova文件
错误代码：E_INVALIDARG (0x80070057)
解决方式：打开virtualbox管理器，选中管理-&gt;虚拟介质管理，删掉其中存在感叹号的虚拟硬盘，重新启动virtualbox后重新导入虚拟机即可。若不行可尝试使用管理员模式打开。其次就是确保虚拟机的默认保存位置下不存在该虚拟机名称且有数据的文件夹，存在相同名称的需要确保是个空文件亦或者是存在一个毫无关联的文件。
二、修改虚拟机的保存位置 打开virtualbox管理器，选中管理-&gt;全局设定-&gt;常规-&gt;默认虚拟电脑位置，修改了即可，使用vagrant up新增的虚拟机也会在virtualbox的默认路径下
三、无法使用xshell等软件用密码进行连接 背景：使用xshell连接会直接跳到需要使用密钥才能连接
解决方式：先通过virtualbox进到虚拟机中，修改/etc/ssh/sshd_config这个文件，需要使用管理员模式。理论上注释掉PasswordAuthentication no这一行就行，不行的话再把PasswordAuthentication yes的注释去掉
sudo vi /etc/ssh/sshd_config #找到PasswordAuthentication no这一行，注释掉。并去掉PasswordAuthentication yes的注释 #输入 i 进入编辑模式，修改后输入esc退出输入模式，并输入 :wq 回车保存，最后重启sshd服务 service sshd restart 四、vagrant up失败 可能1：查看当前存在的同名镜像，删除掉相关的镜像后再重新vagrant up
#查看当前的虚拟机的状态，可以查询出相关的id，然后根据id删除 vagrant global-status #删除掉不需要的虚拟机 vagrant destroy id 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/756063e520a5981c8d1fe1ef5dd0e19e/" rel="bookmark">
			使用virtualBox&#43;vagrant快速安装一个虚拟机以及遇到问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用virtualBox+vagrant快速安装一个虚拟机 一、安装virtualBox二、安装vagrant三、使用vagrant安装虚拟机1.初始化虚拟机2.安装虚拟机2.1 下载虚拟机2.2 下载虚拟机的方式二（推荐）3.连接虚拟机3.1 通过cmd连接虚拟机连接过程中遇到的一个问题3.2 通过xshell直接连接虚拟机3.3 若不能上网，配置网卡 4.配置yum源 一、安装virtualBox virtualBox是虚拟机管理工具，使用vagrant安装的虚拟机通过virtualBox进行统一管理。
安装可以直接到官网下载安装即可，安装之后不需要其他操作，安装好虚拟机之后会自动识别到虚拟机。
注：使用vagrant安装虚拟机之前需要先安装virtualBox，否则安装虚拟机的时候会报错
二、安装vagrant 安装直接到官网下载windows版本64位的版本即可，安装之后需要重启系统。
验证是否成功：打开cmd，输入vagrant即可验证是否成功，如下图则代表安装成功。
三、使用vagrant安装虚拟机 1.初始化虚拟机 以centos/7为虚拟机的系统版本，进到安装的目录下面输入命令进行初始化，会生成一个Vagrantfile文件，这个文件也可以手动编写。
vagrant init centos/7 2.安装虚拟机 2.1 下载虚拟机 在生成Vagrantfile的目录下面输入：
vagrant up 2.2 下载虚拟机的方式二（推荐） 使用方法1下载比较慢且可能会出现错误，推荐去官网或其他网站下载对应版本的box，并添加即可。
//如果不明确文件夹路径，最好写完整目录 vagrant box add centos/7 CentOS-7-x86_64-Vagrant-2004_01.VirtualBox.box //查看是否添加成功--查询添加的所有box vagrant box list //最后再安装就会直接找到本地的box vagrant up 3.连接虚拟机 //在cmd直接输入 vagrant ssh //账号和密码 vagrant 3.1 通过cmd连接虚拟机连接过程中遇到的一个问题 vagrant@127.0.0.1: Permission denied (publickey,gssapi-keyex,gssapi-with-mic). ①找到虚拟机安装目录中的virtualbox中的private_key
右键-属性-安全-高级 查看当前的所有者是否有权限
假设没有则添加，添加的用户需要跟上面查看的当前用户一致
最后禁用继承，因为我这边已经搞好了，所以变成了启用
搞完之后vagrant reload重启虚拟机再重新连接试试，若不行则继续第②步
②可以点击参考
在virtualBox管理器中启动虚拟机（显示界面的方式）
输入用户名密码，都是vagrant即可登录成功，接着输入su赋予管理员权限
然后输入vi /etc/ssh/sshd_config 输入i进入输入模式，找到PasswordAuthentication no这一行 注释掉
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/756063e520a5981c8d1fe1ef5dd0e19e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/59/">«</a>
	<span class="pagination__item pagination__item--current">60/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/61/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>