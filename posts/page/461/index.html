<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81158d410bcb74f27c9af028355faa11/" rel="bookmark">
			mysql-5.7.27 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		net start mysql 发生系统错误2 系统找不到指定的文件 转自：https://www.jianshu.com/p/6d8ed7c36e6f
以管理员身份运行，在命令行输入cd+mySQL的bin目录的安装路径
C:\Windows\system32&gt;cd C:\Program Files\MySQL\MySQL Server5.6\bin
C:\Program Files\MySQL\MySQL Server5.6\bin&gt;mysqld --remove
Service successfully removed.
C:\Program Files\MySQL\MySQL Server5.6\bin&gt;mysqld --install
Service successfully installed.
C:\Program Files\MySQL\MySQL Server5.6\bin&gt;net start mysql
MySQL 服务正在启动 .
MySQL 服务已经启动成功。
======================
网上有很多安装过程，但是没有可能是由于环境或者版本的问题，安装过程中遇到了一些问题，最终成功安装，记录一下自己的安装过程，看看大家有没有踩到同一个坑的
首先是我的环境：windows10、64位 mysql版本5.7.27
1》下载mysql5.7.27解压包
https://dev.mysql.com/downloads/mysql/,选择Windows x86,64-bit ZIP Archive 5.7.27
(更改一下，这个网址默认是下载mysql8.0版本的，这里提供另外的地址，直接下载mysql5.7.27
https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.27-winx64.zip)
2》解压到自己的安装文件夹下，我这里是 D:\appinstall\mysql-5.7.27
3》配置环境变量：Path系统环境变量下加入 D:\appinstall\mysql-5.7.27\bin
4》mysql在5.7以上版本解压后没有配置文件my.ini和data文件夹
先自己创建my.ini文件，内容如下：
[mysqld]
port = 3306
basedir = D:\appinstall\mysql-5.7.27\bin
datadir = D:\appinstall\mysql-5.7.27\data
max_connections=200
character-set-server=utf8
default-storage-engine=INNODB
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
explicit_defaults_for_timestamp=true
[mysql]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81158d410bcb74f27c9af028355faa11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff93d15002a9c46a6a4332b46535da91/" rel="bookmark">
			记一次虚函数使用的查错过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起因 一个基础库中对资源回收的行为出现异常，经过排查，发现是基础库实现时对虚函数的调用出现问题造成的，记录下来吧。
纯虚函数的版本 #include &lt;iostream&gt; using namespace std; class B { public: ~B() { close(); } void close() { doClose(); } virtual void doClose() = 0; }; class D : public B { virtual void doClose() { cout &lt;&lt;"D::doClose()" &lt;&lt;endl; } }; int main(int argc, char *argv[]) { B * p = new D(); p-&gt;close(); delete p; return 0; } # g++ main.cpp &amp;&amp; ./a.out D::doClose() pure virtual method called terminate called without an active exception Aborted 这里很好理解，D先于B析构，之后的doClose就没有对应的函数可用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff93d15002a9c46a6a4332b46535da91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67776d35c643cbfae24aab7c9a2d722a/" rel="bookmark">
			金山云笔试题：AKM函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 题目描述 /** 阿克曼(Ackmann)函数 【题目描述】 阿克曼(Ackmann)函数A(m，n)中，m，n定义域是非负整数(m&lt;=3,n&lt;=10)，函数值定义为： akm(m,n) = n+1; (m=0时) akm(m,n) = akm(m-1,1); (m&gt;0,n=0时) akm(m,n) = akm(m-1,akm(m, n-1)); （m,n&gt;0时) 【输入】输入m和n。 【输出】函数值。 【输入样例】2 3 【输出样例】9 */ 写出递归与非递归算法，并输出调用过程。
2. 代码实现递归和非递归 import java.util.Stack; public class Main2 { public static void main( String[] args ) { System.out.println(AkmRecur(2, 3)); System.out.println(AkmNonRecur(2, 3)); } //递归 public static int AkmRecur(int m, int n) { if (m == 0) return n + 1; else if (n == 0) return AkmRecur(m - 1, 1); else return AkmRecur(m - 1, AkmRecur(m, n - 1)); } //非递归 public static int AkmNonRecur(int m, int n) { Stack&lt;Integer&gt; sx = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; sy = new Stack&lt;Integer&gt;(); int x = 0; int y = 0; sx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67776d35c643cbfae24aab7c9a2d722a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/253451dc7f997b816d69df857346c4ed/" rel="bookmark">
			字节跳动笔试题：1. 小于N的质数数量；2. 逆时针二维数组；3. 判断a&#43;b&gt;c
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 小于N的质数数量 import java.util.Scanner; /** * 计算小于N的质数数量 * @author Turing * */ public class Main4 { public static void main( String[] args ) { Scanner sc = new Scanner(System.in); int [] arr = new int[100]; int num = 0; while(sc.hasNextLine()){ String str = sc.nextLine().trim(); if(str.equals("")){ break; }else{ arr[num++] = Integer.valueOf(str); } } for (int i = 0; i &lt; num; i++) { System.out.println(primesNum(arr[i])); } } public static int primesNum(int n){ boolean[] num = new boolean[n]; int number = 0; for (int i = 2; i &lt; n; i++) { if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/253451dc7f997b816d69df857346c4ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b96e3f14577d6b6080e06268683e7fe/" rel="bookmark">
			C/C&#43;&#43; Socket编程（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下的socket演示程序 server.cpp 是服务器端代码，client.cpp 是客户端代码，要实现的功能是：客户端从服务器读取一个字符串并打印出来。
服务器端代码 server.cpp：
#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; int main() { int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); //创建套接字 struct sockaddr_in serv_addr; memset(&amp;serv_addr, 0, sizeof(serv_addr)); //每个字节都用0填充 serv_addr.sin_family = AF_INET; //使用IPv4地址 serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1"); //服务端IP地址 serv_addr.sin_port = htons(1234); //端口 bind(serv_sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)); //将套接字和IP、端口绑定 listen(serv_sock, 20); //进入监听状态，等待用户发起请求 //接收客户端请求 struct sockaddr_in clnt_addr; socklen_t clnt_addr_size = sizeof(clnt_addr); int clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size); char str[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b96e3f14577d6b6080e06268683e7fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be704e5872237fcdc77150b39b03d43c/" rel="bookmark">
			Warning: Hash history cannot PUSH the same path; a new entry will not be added to the history stack
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象 在用`mobx-react-router`的`this.props.history.push("/")`的时候，浏览器会提示 Warning: Hash history cannot PUSH the same path; a new entry will not be added to the history stack 解决 原因：这个是 reactr-router 的一个提示，当前路由下的 history 不能 push 相同的路径到 stack里。只有开发环境存在，生产环境不存在，目前还没看到官方有去掉的意思。看不惯的话可以采取一些方法关掉这个提示。
&lt;Link to={{ pathname: "/" }} replace&gt;detail&lt;/Link&gt; 或者 this.props.history.replace("/"); 参考 https://www.npmjs.com/package/mobx-react-router
转载于:https://www.cnblogs.com/shengulong/p/11609931.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/544c7cb31d7288a7a477839347110b8f/" rel="bookmark">
			node不要使用最新版本，使用LTS版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误现象 const { Math, Object, Reflect } = primordials; 原因 使用了最新的node版本
解决 使用稳定版本，参考官网说明,目前10.x的版本是稳定版本(LTS)
yarn的使用 避免和npm混用
安装 推荐：npm install -g yarn不推荐：brew install yarn会覆盖node版本，安装最新的node版本(不是LTS版本),安装的node版本不够稳定 homebrew安装指定版本的node brew search node然后选择一个node版本
参考 https://yarnpkg.com/zh-Hans/docs/install#mac-stable
https://blog.csdn.net/yw00yw/article/details/81354533
转载于:https://www.cnblogs.com/shengulong/p/11609914.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2ca1bd95e1aa4739ba3a6f1eaa10ed7/" rel="bookmark">
			Kattis amazingadventures Amazing Adventures（费用流路径）题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意： 在一个\(100*100\)的方格中，要求从\(b\)走到\(g\)，途中经过\(c\)但不经过\(u\)，并且不能走已经做过的路。如果可以，就求出路径。
思路： 拆点建费用流，看能不能从\(c\)走两条路走到\(b，g\)。然后输出路径。
代码： #include&lt;set&gt; #include&lt;map&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;bitset&gt; #include&lt;string&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include &lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; const int maxn = 20000 + 5; const int M = 50 + 5; const ull seed = 131; const int INF = 0x3f3f3f3f; const ll MOD = 1000000007; struct Edge{ int to, next, cap, cost; }edge[10000 * 4 * 10 + 100]; int head[maxn], tot; int pre[maxn], dis[maxn]; bool vis[maxn]; int N; void init(){ N = maxn; tot = 0; memset(head, -1, sizeof(head)); } void addEdge(int u, int v, int cap, int cost){ //双向边 edge[tot].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2ca1bd95e1aa4739ba3a6f1eaa10ed7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28879e03d22e5430d4aef50c21acd76c/" rel="bookmark">
			石川es6课程---11、json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		石川es6课程---11、json 一、总结 一句话总结： ` 感觉更方便了一点，增加了一些简写 ` key-value 一样时可以简写：console.log({ a,b}}) ` 里面函数可以简写：console.log({ show(){ console.log('a') }}) 1、JSON 格式要求？ - JSON 是 JS对象 的严格子集 - 只能用双引号 - 所有的key都必须用双引号包起来 二、json JSON 格式
JavaScript Object Notation 的缩写，是一种用于数据交换的文本格式JSON 是 JS对象 的严格子集JSON 的标准写法只能用双引号所有的key都必须用双引号包起来 JSON 对象
JSON 对象是 JavaScript 的原生对象，用来处理 JSON 格式数据，有两个静态方法JSON.parse(string) ：接受一个 JSON 字符串并将其转换成一个 JavaScript 对象。JSON.stringify(obj) ：接受一个 JavaScript 对象并将其转换为一个 JSON 字符串。 var json = {a: 12, b: 5} var str = 'hi,' + JSON.stringify(json) var url = 'http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28879e03d22e5430d4aef50c21acd76c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e29afb32753002eb026406a5341b5a35/" rel="bookmark">
			springboot 部署运行一端时间后，上传临时文件失效的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 springboot程序运行一段时间后，上传文件会报错：临时文件目录失效 添加以下Bean,设置临时目录。 @Configuration public class MultipartConfig { /** * 文件上传临时路径 */ @Bean MultipartConfigElement multipartConfigElement() { MultipartConfigFactory factory = new MultipartConfigFactory(); String location = System.getProperty("user.home") + "/tmp/uploadcache"; log.info("upload cache path={}", location); File tmpFile = new File(location); if (!tmpFile.exists()) { tmpFile.mkdirs(); } factory.setLocation(location); return factory.createMultipartConfig(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e60706da46c0965f6c09bf60ffe838a/" rel="bookmark">
			service redis does not support chkconfig的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题解决办法如下：
必须把下面两行注释放在/etc/init.d/redis文件靠前的注释中：
# chkconfig: 2345 90 10
# description: Redis is a persistent key-value database
上面的注释的意思是，redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10。
附录： linux 运行级别 运行级别就是操作系统当前正在运行的功能级别。这个级别从0到6 ，具有不同的功能。这些级别在/etc/inittab文件里指定。这个文件是init程序寻找的主要文件，最先运行的服务是那些放在/etc/rc.d 目录下的文件。
不同的运行级定义如下：(可以参考Linux里面的/etc/inittab)
# 缺省的运行级，RHS用到的级别如下：
0：关机
1：单用户模式
2：无网络支持的多用户模式
3：有网络支持的多用户模式
4：保留，未使用
5：有网络支持有X-Window支持的多用户模式
6：重新引导系统，即重启
对各个运行级的详细解释：
0 为停机，机器关闭。
1 为单用户模式，就像Win9x下的安全模式类似。
2 为多用户模式，但是没有NFS支持。 3 为完整的多用户模式，是标准的运行级。
4 一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本 电脑的电池用尽时，可以切换到这个模式来做一些设置。
5 就是X11，进到X Window系统了。
6 为重启，运行init 6机器就会重启。
chkconfig用法 chkconfig命令可以用来检查、设置系统的各种服务
使用语法：
chkconfig [--add][--del][--list][系统服务] 或 chkconfig [--level &lt;等级代号&gt;][系统服务][on/off/reset]
参数用法：
–add 增加所指定的系统服务，让chkconfig指令得以管理它，并同时在系统启动的叙述文件内增加相关数据。
–del 删除所指定的系统服务，不再由chkconfig指令管理，并同时在系统启动的叙述文件内删除相关数据。
–level&lt;等级代号&gt; 指定读系统服务要在哪一个执行等级中开启或关毕。
使用范例：
chkconfig --list 列出所有的系统服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e60706da46c0965f6c09bf60ffe838a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bdb6092cd35c4f7c169acf67b481fc1/" rel="bookmark">
			BPMN2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.activiti.org/userguide/#bpmn20
转载于:https://www.cnblogs.com/mengjianzhou/p/11607336.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a18a8693debca9fc3e6983de804c85b0/" rel="bookmark">
			CodeMeter 软件加密技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://baike.baidu.com/item/CodeMeter/482271?fr=aladdin 转载于:https://www.cnblogs.com/butterflybay/p/11607264.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1de4874b8a0b8bcbacb35f575b04f572/" rel="bookmark">
			十六进制颜色码及其表示-(6 digit color code)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们知道对于RGB颜色系统，颜色是由三个256位的十进制数值表示的: (R:0-255,G:0-255,B:0-255) 那么一个三元组可以确定一种颜色。
然而，在很多配置文件中颜色并不是直接用十进制数字来表示的。观察到两位十六进制可以表示0-255之间的数字，那么一个六位颜色码(6 digit color code)就可以用六位的16进制数值来表示了。
下面罗列一些十六进制颜色码以供说明。
16位进制代码颜色效果 #FFFFFF #FFFFCC #FFFF99 #FFFF66 #FFFF33 #FFFF00 #FFCCFF #FFCCCC #FFCC99 #FFCC66 #FFCC33 #FFCC00 #FF99FF #FF99CC #FF9999 #FF9966 #FF9933 #FF9900 #FF66FF #FF66CC #FF6699 #FF6666 #FF6633 #FF6600 #FF33FF #FF33CC #FF3399 #FF3366 #FF3333 #FF3300 #FF00FF #FF00CC #FF0099 #FF0066 #FF0033 #FF0000 Hex CodeColor#66FFFF #66FFCC #66FF99 #66FF66 #66FF33 #66FF00 #66CCFF #66CCCC #66CC99 #66CC66 #66CC33 #66CC00 #6699FF #6699CC #669999 #669966 #669933 #669900 #6666FF #6666CC #666699 #666666 #666633 #666600 #6633FF #6633CC #663399 #663366 #663333 #663300 #6600FF #6600CC #660099 #660066 #660033 #660000 16位进制代码颜色效果 #CCFFFF #CCFFCC #CCFF99 #CCFF66 #CCFF33 #CCFF00 #CCCCFF #CCCCCC #CCCC99 #CCCC66 #CCCC33 #CCCC00 #CC99FF #CC99CC #CC9999 #CC9966 #CC9933 #CC9900 #CC66FF #CC66CC #CC6699 #CC6666 #CC6633 #CC6600 #CC33FF #CC33CC #CC3399 #CC3366 #CC3333 #CC3300 #CC00FF #CC00CC #CC0099 #CC0066 #CC0033 #CC0000 Hex CodeColor#33FFFF #33FFCC #33FF99 #33FF66 #33FF33 #33FF00 #33CCFF #33CCCC #33CC99 #33CC66 #33CC33 #33CC00 #3399FF #3399CC #339999 #339966 #339933 #339900 #3366FF #3366CC #336699 #336666 #336633 #336600 #3333FF #3333CC #333399 #333366 #333333 #333300 #3300FF #3300CC #330099 #330066 #330033 #330000 16位进制代码颜色效果 #99FFFF #99FFCC #99FF99 #99FF66 #99FF33 #99FF00 #99CCFF #99CCCC #99CC99 #99CC66 #99CC33 #99CC00 #9999FF #9999CC #999999 #999966 #999933 #999900 #9966FF #9966CC #996699 #996666 #996633 #996600 #9933FF #9933CC #993399 #993366 #993333 #993300 #9900FF #9900CC #990099 #990066 #990033 #990000 Hex CodeColor#00FFFF #00FFCC #00FF99 #00FF66 #00FF33 #00FF00 #00CCFF #00CCCC #00CC99 #00CC66 #00CC33 #00CC00 #0099FF #0099CC #009999 #009966 #009933 #009900 #0066FF #0066CC #006699 #006666 #006633 #006600 #0033FF #0033CC #003399 #003366 #003333 #003300 #0000FF #0000CC #000099 #000066 #000033 #000000 转载于:https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1de4874b8a0b8bcbacb35f575b04f572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1de92b2fdfe366ca44322d2b789da440/" rel="bookmark">
			Session,Token相关区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 为什么要有session的出现？
答：是由于网络中http协议造成的，因为http本身是无状态协议，这样，无法确定你的本次请求和上次请求是不是你发送的。如果要进行类似论坛登陆相关的操作，就实现不了了。
2. session生成方式？
答：浏览器第一次访问服务器，服务器会创建一个session，然后同时为该session生成一个唯一的会话的key,也就是sessionid，然后，将sessionid及对应的session分别作为key和value保存到缓存中，也可以持久化到数据库中，然后服务器再把sessionid，以cookie的形式发送给客户端。这样浏览器下次再访问时，会直接带着cookie中的sessionid。然后服务器根据sessionid找到对应的session进行匹配；
还有一种是浏览器禁用了cookie或不支持cookie，这种可以通过URL重写的方式发到服务器；
简单来讲，用户访问的时候说他自己是张三，他骗你怎么办？ 那就在服务器端保存张三的信息，给他一个id，让他下次用id访问。
3. 为什么会有token的出现？
答：首先，session的存储是需要空间的，其次，session的传递一般都是通过cookie来传递的，或者url重写的方式；而token在服务器是可以不需要存储用户的信息的，而token的传递方式也不限于cookie传递，当然，token也是可以保存起来的；
4. token的生成方式？
答：浏览器第一次访问服务器，根据传过来的唯一标识userId，服务端会通过一些算法，如常用的HMAC-SHA256算法，然后加一个密钥，生成一个token，然后通过BASE64编码一下之后将这个token发送给客户端；客户端将token保存起来，下次请求时，带着token，服务器收到请求后，然后会用相同的算法和密钥去验证token，如果通过，执行业务操作，不通过，返回不通过信息；
5. token和session的区别？
token和session其实都是为了身份验证，session一般翻译为会话，而token更多的时候是翻译为令牌；
session服务器会保存一份，可能保存到缓存，文件，数据库；同样，session和token都是有过期时间一说，都需要去管理过期时间；
其实token与session的问题是一种时间与空间的博弈问题，session是空间换时间，而token是时间换空间。两者的选择要看具体情况而定。
虽然确实都是“客户端记录，每次访问携带”，但 token 很容易设计为自包含的，也就是说，后端不需要记录什么东西，每次一个无状态请求，每次解密验证，每次当场得出合法 /非法的结论。这一切判断依据，除了固化在 CS 两端的一些逻辑之外，整个信息是自包含的。这才是真正的无状态。 而 sessionid ，一般都是一段随机字符串，需要到后端去检索 id 的有效性。万一服务器重启导致内存里的 session 没了呢？万一 redis 服务器挂了呢？ 方案 A ：我发给你一张身份证，但只是一张写着身份证号码的纸片。你每次来办事，我去后台查一下你的 id 是不是有效。 方案 B ：我发给你一张加密的身份证，以后你只要出示这张卡片，我就知道你一定是自己人。 就这么个差别。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e01cc3beca83b2283f9fdf80346d1ed6/" rel="bookmark">
			深入理解计算机系统 第三章 程序的机器级表示 Part2 第二遍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一遍对应笔记链接 https://www.cnblogs.com/stone94/p/9943779.html
本章汇编代码中常出现的几个指令及其含义
1、push
操作数的个数：1
将操作数（一般是寄存器）的值压入栈中，由于栈向下生长，所以这时栈顶指针会减小一点
2、move
操作数的个数：2
第一个操作数是源操作数，第二个操作数是目的操作数，该指令将源操作数的值赋给目的操作数
3、call
操作数的个数：1
调用某个方法，栈的变化没有完全弄明白
4、pop
操作数的个数：1
将栈顶元素赋给操作数，同时从栈顶弹出该元素，栈顶指针增加一定的值
5、ret
当前方法结束，返回
这里说到的两种抽象看不大懂
“计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节，对于机器级编程来说，其中两种抽象尤为重要，第一种是由指令集体系结构或指令集架构（ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数 ISA ，包括 x86-64，将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始，处理器的硬件远比描述的惊喜复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与 ISA 指定的顺序执行的行为完全一致。第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组”
转载于:https://www.cnblogs.com/stone94/p/11605824.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a06523c03acd881e2eb98d4ca63f9ff6/" rel="bookmark">
			linux如何找回已经删除的文件？lsof
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 lsof(list open files)是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的
在终端下输入lsof即可显示系统打开的文件，因为 lsof 需要访问核心内存和各种文件，所以必须以 root 用户的身份运行它才能够充分地发挥其功能。
输出信息含义 lsof输出各列信息的意义如下：
COMMAND：进程的名称 PID：进程标识符
USER：进程所有者
FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等 TYPE：文件类型，如DIR、REG等
DEVICE：指定磁盘的名称
SIZE：文件的大小
NODE：索引节点（文件在磁盘上的标识）
NAME：打开文件的确切名称
FD 列中的文件描述符cwd 值表示应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改,txt 类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序。
其次数值表示应用程序的文件描述符，这是打开该文件时返回的一个整数。如上的最后一行文件/dev/initctl，其文件描述符为 10。u 表示该文件被打开并处于读取/写入模式，而不是只读 ® 或只写 (w) 模式。同时还有大写 的W 表示该应用程序具有对整个文件的写锁。该文件描述符用于确保每次只能打开一个应用程序实例。初始打开每个应用程序时，都具有三个文件描述符，从 0 到 2，分别表示标准输入、输出和错误流。所以大多数应用程序所打开的文件的 FD 都是从 3 开始。
与 FD 列相比，Type 列则比较直观。文件和目录分别称为 REG 和 DIR。而CHR 和 BLK，分别表示字符和块设备；或者 UNIX、FIFO 和 IPv4，分别表示 UNIX 域套接字、先进先出 (FIFO) 队列和网际协议 (IP) 套接字。
常用参数 lsof 列车所有打开的文件
lsof /filepath/file 查看谁正在使用某个文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a06523c03acd881e2eb98d4ca63f9ff6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1d3faccbd0dbd88c67038678bdc8882/" rel="bookmark">
			SpringBoot  JPA  自动生成代码 (一) 生成实体类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前做SSM项目时，一直使用的是Mybatis的Generator自动生成代码工具，也是蛮好使的。现在换了SpringBoot，自动生成代码使用的是人人开源项目修改来的，可以直接生成简单的CRUD代码和HTML页面。
一次偶然的机会，帮群里一个老弟看代码时，发现他们自动生成代码是用的JPA，之前听说过这个，但是没有用过，所以也是一脸懵逼的。于是查了查怎么用，之后发现也是很神奇的，也是可以直接生成实体类，然后Dao层和Service直接继承就可以完成简单的CRUD了，自己刚接触，这里记录一下简单的使用过程。
今天是第一次使用JPA生成代码，在查了半天之后，发现自动生成的脚本的样式是千奇百怪的，那个老弟还非要按照别人的代码格式生成，但是人家又不给他生成代码的脚本，让他自己百度找，对于小白的我就很懵逼了。
这里使用的是IDEA，其自带的生成实体类的脚本Generate POJOs.groovy有点过于简单了，那么下面先看看自带的这个脚本怎么用。
首先是打开DataSource
这时会在右边弹出如下图的窗口，由于我这里已经添加过数据库了，第一次打开会提示使用Alt + Insert 进行添加数据库，我这里使用的是MySQL。
输入需要连接的数据库的信息，然后点击左下角的下载工具，然后点击Test Connection，如果提示Success 证明连接成功了，这时点击Apply，ok即可。
下面还是使用的之前添加的jpa-demo这个数据库，可以看到这里只有一张User表，我们就拿这个来生成。
右键我们需要生成实体类的表格，这里可以多选，可以看到如下图。如果使用默认的脚本，可以直接点击最后的Generate POJOs.groovy，这里我们简单的扩展一下，自定义我们自己的脚本。
可以看到，IDEA跳转到这个页面了，这个文件的内容就是系统自动带的生成实体类的脚本。
第一次用的时候没有仔细看，直接按照网上的博客直接生成了，感觉蛮神奇的，后来发现生成的跟那个项目里面别人写的不一样，这才反应过来，看一下这个脚本文件的内容，发现这个脚本也是有固定的套路的。
这里贴上一个简单的生成实体类的脚本，可以随意自己定制：
import com.intellij.database.model.DasTable import com.intellij.database.model.ObjectKind import com.intellij.database.util.Case import com.intellij.database.util.DasUtil import java.text.SimpleDateFormat /* * Available context bindings: * SELECTION Iterable&lt;DasObject&gt; * PROJECT project * FILES files helper */ packageName = "" typeMapping = [ (~/(?i)tinyint|smallint|mediumint/) : "Integer", (~/(?i)int/) : "Long", (~/(?i)bool|bit/) : "Boolean", (~/(?i)float|double|decimal|real/) : "BigDecimal", (~/(?i)datetime|timestamp|date|time/) : "Date", (~/(?i)blob|binary|bfile|clob|raw|image/): "InputStream", (~/(?i)/) : "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1d3faccbd0dbd88c67038678bdc8882/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1ecfc23765563cfbfbc63340316c36/" rel="bookmark">
			安装包错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.jianshu.com/p/942c562065c8
//备份/var/lib/dpkg/status文件 sudo cp /var/lib/dpkg/status status.bkp //编辑该文件 sudo vim /var/lib/dpkg/status //定位到出错的软件包，将该软件包的记录删除，保存，就完成了。 转载于:https://www.cnblogs.com/misstaste/p/11601370.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab341cd14a123ef60061ef40075f4347/" rel="bookmark">
			解决Manifest merger failed with multiple errors方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题原因 升级到android studio 3.5之后Android Support库和AndroidX库存在不兼容的问题
2. 解决方法 2.1 方案一：取消对androidx库的依赖 第一步：找到对androidx依赖的库：在project目录中执行以下命令，其中app为对应的module名称。
gradlew :app:dependencies 第二步：降低依赖库的版本，使用一个不依赖androidx的版本
2.2 方案二：迁移到androidx库 第一步：在AndroidManifest.xml的Application标签中增加如下代码:
android:appComponentFactory="" tools:replace="android:appComponentFactory" 第二步：使用Refactor-&gt;Migrate to AndroidX进行工程迁移
3. 总结 方案一经过测试可用，方案二还有更进一步的步骤要完善，不过网络资源更多，不进行赘述。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4897fc12c0b42494cc37f0eb3ee89035/" rel="bookmark">
			Redis常用命令-list-set-zset
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis常用命令
Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)等
https://gitee.com/nmwork/RedisUtil
1. Redis数据类型 1.1. List类型 1.1.1. 简介 Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)
è类似JAVA中的LinkedList
1.1.2. 命令 赋值语法： LPUSH key value1 [value2] //将一个或多个值插入到列表头部(从左侧添加)
RPUSH key value1 [value2] //在列表中添加一个或多个值(从右侧添加)
LPUSHX key value //将一个值插入到已存在的列表头部。如果列表不在，操作无效
RPUSHX key value //一个值插入已存在的列表尾部(最右边)。如果列表不在，操作无效。
取值语法： LLEN key //获取列表长度
LINDEX key index //通过索引获取列表中的元素
LRANGE key start stop //获取列表指定范围内的元素
描述： 返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。
start: 页大小*(页数-1) stop : (页大小*页数)-1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4897fc12c0b42494cc37f0eb3ee89035/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0877ecb6850790931c32d814d497f7f0/" rel="bookmark">
			Redis常用命令-string-hash
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis
1. Redis命令描述 Redis 命令用于在 redis 服务上执行操作。
要在 redis 服务上执行命令需要一个 redis 客户端。
Redis 客户端在我们之前下载的的 redis 的安装包中。
Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)等
1.1. Redis键key Redis 键命令用于管理 redis 的键
DEL key
该命令用于在 key 存在时删除 key。 DUMP key
序列化给定 key ，并返回被序列化的值。
EXISTS key 检查给定 key 是否存在。 EXPIRE key seconds
为给定 key 设置过期时间（以秒计）。 PEXPIRE key milliseconds 设置 key 的过期时间以毫秒计。
TTL key 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live) PTTL key 以毫秒为单位返回 key 的剩余的过期时间。
PERSIST key 移除 key 的过期时间，key 将持久保持。 KEYS pattern 查找所有符合给定模式( pattern)的 key 。 keys 通配符 获取所有与pattern匹配的key,返回所有与该匹配 通配符： * 代表所有 ？ 表示代表一个字符 RENAME key newkey 修改Key的名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0877ecb6850790931c32d814d497f7f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88482f7e0d63dd8accf06ac58f2efdfb/" rel="bookmark">
			爬虫 5 ： 列表中的字典数据写入到csv表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 def write(self,lst): header_file = ['singer_name','singer_picture','singer_detail'] with open('singer789.csv','a+',newline='',encoding='utf-8') as s : s_csv = csv.DictWriter(s,header_file) s_csv.writeheader() s_csv.writerows(lst) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22e52c447995520b9586a123da8b5dfe/" rel="bookmark">
			Bat备份MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows环境下定时备份MySQL数据经常用到，实测过的脚本如下，希望能为你节约一些时间^_^
set backup_dir="D:\backup" set "ymd=%date:~,4%%date:~5,2%%date:~8,2%" "C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqldump.exe" -Q db_name -uroot -pedu@2018 &gt; %backup_dir%\db_name_%ymd%.sql forfiles /p %backup_dir% /s /m *.* /c "cmd /c Del @path" /d -30
实现备份数据库db_name到某一目录下（以当日日期命名），然后删除30天以前的备份
转载于:https://www.cnblogs.com/roostinghawk/p/11598192.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64cea34e8d1b17609db0751dac553f7b/" rel="bookmark">
			连接池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结:1.连接池:java对外提供了连接的接口,连接池的存在就省去了每次创建和释放连接。
2.连接池的连接条件:1.将commons-pool-1.5.6.jar的jar包引进java项目下的lib文件夹
3.用连接池对象代替dao'层的Connection对象;
4.在tools工具包里创建MyDBUtils工具文件和JDNCUtils一样
QueryRunner qr=new QueryRunner(MyDBUtils.getDatasource());用MyDBUtils.getDatasource()代替了Connection
String sql="select * from user where name=?";
Object[] obj={"小红"};
int row=qr.update(sql,obj);
使用连接池也不需要释放
5.什么是事务:一件事情由n个单元组成,要么这n个丹玉一起成功要么这n个单元一起失败,这n个单元一起组成的事情就叫事务
6.一条sql语句就是一个事务,默认开启事务并提交事务
7.Mysql的事务:1.开启事务:start transaction()运行的sql会先存在内存中,所以没有改变数据库,所以说,rollback回滚以后能回复,因为没有改变数据库,需要commit提交才会把sql 语句执行后的结果写进数据库里
commit:是提交事务,将事务开启到事务提交这一块的sql会真正的提交到数据库,并对数据库进行修改
事务回滚:rollback:从事务开启到事务回滚,这一块所有的sql都没有效果,
事务开启后,只是把sql语句的运行和运行结果存储在内存中并没有作用在数据库上所以可以回滚后恢复原来的样子
8.JDBC事务操作:1.executeypdate()和executequery都是事务自动提交了，每一次执行都会提交
9.开启事务:conn.setAutoComnmit(false)(默认的是true是自动提交,需要改成false才会自动提交)
10.事务提交:conn.commit; 事务回滚:conn.rollback;
11.控制事务的Connection必须是同一个Connection因为需要包装控制的是同一个事务 12.事务的特性和隔离级别:原子性:指事务是一个不可分离的整体要么都执行要么都不执行
13.一致性:一个事务中,事务的前后数据的完整性必须保持一致
14.隔离性:指多个事务,指多个用户一起访问时
15.持久性:是指一但事务提交那么对数据库的影响是永久的,即使数据库发生了故障。
16.账号的转入转出:1.jsp文件:&lt;body&gt; &lt;form action="/Servlet" method="post"&gt;
转出账户:&lt;input type="text" name="out"&gt;
转入账户:&lt;input type="text" name="in"&gt;
转出金额:&lt;input type="text" name="money"&gt;
提交:&lt;input type="submit" value="确认"&gt; &lt;/form&gt; &lt;/body&gt;
Dao层:转出:public void outmoney(Connection conn,String out,double money){
QueryRunner qr=new QueryRunner();
String sql="update conn set money=money-? where uname=?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64cea34e8d1b17609db0751dac553f7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21beabca51c568f32b6503489799d83a/" rel="bookmark">
			以前表有数据的A表B表,更改模型关系,建立关联关系,这个时候执行Migrations时报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情况:我想在已经生成的表UnitProcess,Allocations建立 1--N的关系.
执行Migration的时候,就报主键冲突.
解决办法:
因为UnitProcess表和Allocations有脏数据, Allocations里的ProcessId不在UnitProcess表里,所以执行时报错.
找出脏数据,删掉.重新执行.
或者
数据没用的话,删除两张表的数据,重新执行.就OK了.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37363bd75bec77ae388e6cb0ea82d572/" rel="bookmark">
			Upgrade Windows Server 2016 to Windows Server 2019
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pre-Upgrade Upgrade path: Windows Server 2016 can be upgraded to Windows 2019 in a single upgrade process.
Support: In-place Upgrade is supported for Windows Server 2016 on physicaL hardware, and in Virtual Machines. Public and private cloud companies also support In-place Upgrade on Windows Server 2016 Virtual Machines to upgrade to Windows Server 2019 – check with your cloud provider.
Alternative: Migrate (re-deploy) applications and data on a clean install of Windows Server 2019.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37363bd75bec77ae388e6cb0ea82d572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ca73574b08bbe4ad09c988c52be40a6/" rel="bookmark">
			SpringBoot的四种定时任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定时任务实现的几种方式：
Timer：这是java自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。
使用这种方式可以让你的程序按照某一个频度执行，但不能在指定时间运行。一般用的较少。
ScheduledExecutorService：也jdk自带的一个类；是基于线程池设计的定时任务类
每个调度任务都会分配到线程池中的一个线程去执行,也就是说,任务是并发执行,互不影响。
Spring Task：Spring3.0以后自带的task，可以将它看成一个轻量级的Quartz，而且使用起来比Quartz简单许多。
Quartz：这是一个功能比较强大的的调度器，可以让你的程序在指定时间执行，也可以按照某一个频度执行，配置起来稍显复杂。
使用Timer 这个目前在项目中用的较少，直接贴demo代码。具体的介绍可以查看api
public class TestTimer {
public static void main(String[] args) {
TimerTask timerTask = new TimerTask() {
@Override
public void run() {
System.out.println("task run:"+ new Date());
}
};
Timer timer = new Timer();
//安排指定的任务在指定的时间开始进行重复的固定延迟执行。这里是每3秒执行一次
timer.schedule(timerTask,10,3000);
}
}
使用ScheduledExecutorService 该方法跟Timer类似，直接看demo：
public class TestScheduledExecutorService {
public static void main(String[] args) {
ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
// 参数：1、任务体 2、首次执行的延时时间
// 3、任务执行间隔 4、间隔时间单位
service.scheduleAtFixedRate(()-&gt;System.out.println("task ScheduledExecutorService "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ca73574b08bbe4ad09c988c52be40a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c9e4b78a0ade0495615dfb17fe8ca0e/" rel="bookmark">
			Redis基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 简介 Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key - value 数据库
Redis 与 其他 key - value 缓存产品有以下三个特点：
Redis 支持数据持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
Redis 不仅仅支持简单的 key - value 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储
Redis 支持数据的备份，即 master - slave 模式的数据备份
Redis 优势 性能极高 – Redis 读的速度是 110000 次 /s, 写的速度是 81000 次 /s 。
丰富的数据类型 - Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
原子性 - Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。
其他特性 - Redis 还支持 publish/subscribe 通知，key 过期等特性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c9e4b78a0ade0495615dfb17fe8ca0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05f2d7ec8229cc51e33a4dbedcfbcc25/" rel="bookmark">
			使用Python判断一个正整数数是否为素数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
使用Python判断一个正整数数是否为素数 **
判定一个数是否为素数的基本思路：
1、了解素数的定义，一个正整数n若为素数，则它的约数只能是1和n本身，
2、根据定义，我们需要将这个数除以从2到n-1之间的全部正整数，如果全部都不能整除，则这个数便是素数。若是其中有一个数能被整除，则这个数是个合数，而不是素数。 因此，用求余算法%不失为一种有效的方法。
3、根据上述原理，我们可以用while循环来实现
代码设计如下：
#输入需要验证的整数n，注意，一定要将变量转换为int，否则运算过程中无法判别n是int还是字符串，会报错。 n = int(input("请输入要判断的整数：")) #变量的初始值应该从2开始，因为所有的整数都能被1整除，从1开始意义不大。 i = 2 #注意，为什么i的取值范围是（2，n/2+）而不是（2，n-1）呢？其实取（2，n-1）也是可以行的，只是运算量比较大而已，浪费资源。因为当i&gt;n/2时，n是不可能整除i的，所以i的最大取值范围到n/2即可，这样能大大减少运算量。 while i &lt;= int(n/2)+1: if n%i == 0: #注意，这里应该使用break语句跳出循环，表示一旦在（2，n/2+1）之间的某数能够被n整除，那么这个数必定是合数，再循环没有意义，直接跳出 break #如果i仍然不能被n整除，那么就自增1，继续执行求余循环，直到i取到最大值为止 i += 1 #如果在（2，n/2）之间的所有数字都不能被n整除，那么就可以认定这个数是素数。 else: print("%d是素数" % n) 补充说明： 1）本文的注释比较长，主要是方便新手阅读，如果感到不方便，可以删除中文注释
2）这个语句没有考虑n&lt;=1情况，略微有些不严谨，但是不影响对于大于1的正整数是否为素数的判断。如果有必要的话，大家可以尝试添加一个对n&lt;=1的判断，保证逻辑的严密性
3）以下是代码执行的举例：
请输入要判断的整数：151
151是素数
#输入151，会报出这个数是素数的结果
请输入要判断的整数：155
#输入155，不会显示结果，因为155不是素数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff914afca89461c45ec8635e06b4d6ee/" rel="bookmark">
			Windows下载及安装chromedriver.exe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows下载及安装chromedriver.exe
1.首先下载chromedriver
下载地址：http://chromedriver.storage.googleapis.com/index.html
下载之前查看自己PC的chrome游览器的版本
查看chrome游览器版本的方法：
(1) 打开的Chrome浏览器主界面的地址栏输入网址: chrome://version/
(2) 点击打开谷歌浏览器以后，点击右上角的“主菜单”按钮;
在打开的下拉菜单中依次点击“帮助/关于Google Chrome”菜单项;
这时就会打开关于chrome的页面，在这里就可以看到google chrome浏览器的版本号了.
2.通过自己的版本下载相应的chromedriver.exe
对比步骤：
(1)打开下载链接： http://chromedriver.storage.googleapis.com/index.html
(2) 依次点击文件夹，打开文件夹里边的notes.txt文件；
3.将下载下来的文件减压,把chromedriver.exe放在chrome安装目录下。我的安装目录是(C:\Users\0923\AppData\Local\Google\Chrome\Application\)
4.配置环境变量.
步骤:右键点击我的电脑-----&gt;属性---&gt;高级系统设置----&gt;环境变量------&gt;在path路径下添加上文中浏览器文件所在的根目录。我的是：C:\Users\0923\AppData\Local\Google\Chrome\Application\（即上面截图的目录）到此就OK了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff5bfc16ec2734049d22198f2a7dfba7/" rel="bookmark">
			前端 web知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Web 知识 Web缓存的理解 参考博客 强制缓存和协商缓存区别三种情况（没有缓存；缓存内容失效，缓存标识存在；缓存标识和缓存内容都存在）Expires（http/1.0）-&gt;Cache Control(http/1.1)(两者的工作原理，及为什么废除)Cache Control主要取值协商缓存的字段：Last-Modified / If-Modified-Since和Etag / If-None-Match,其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高 Web存储的理解 cookie和session，localstorage和sessionStorage，IndexedDB存储位置：session存储在服务端；其他均存储在客户端；存储大小：cookie存储为4kb，较小；localstorage为5MB，其余均不限量，大量数据使用IndexedDB；存储方式：cookie为文本，内容包括名称，值，域，路径，过期时间；其他均为键值对；生存周期：cookie存在生命周期，或可以手动清除；sessionStorage在关闭页面自动清除；其余的均需手动清除安全性：session安全性较高（因为是存储在服务端的） HTTP的理解 基于TCP/IP协议族传输数据，位于应用层；四个版本，最新为http2.0无连接，每次连接只处理一次请求无状态，即每次请求完全相互独立，没有状态记录http状态码：1xx，2xx，3xx，4xx，5xx；http请求方法：Get，Post，Head，Delete，Connect，Options,Put HTTPS的理解 https = http + 加密 + 认证 + 完整性保护 内容加密：通信的加密和内容的加密；内容的加密和解密同时使用一个密钥称为共享密钥加密，为对称加密；密钥的加密采用公开密钥加密的方式，为非对称加密；https加密过程采用对称加密和非对称加密相结合的方式；对公开密钥的确认采用数字证书认证的方式；验证身份：使用证书，同时对客户端和服务端进行身份验证保护数据完整性，防止篡改 OSI七层模型及每层对应的协议 应用层（应用层，表示层，会话层）：HTTP，FTP，TELNET，DHCP传输层：TCP（面向连接，可靠），UDP网络层：IP，ICMP，ARP，RARP，数据链路层：CDMA和CDMA/CD物理层： HTTP版本 http/0.9, http/1.0, http/1.1, http/2.0 区别 http/0.9：仅支持请求方式GET；仅能请求访问HTML格式的资源http/1.0:增加了请求方式post和head；可以支持多种数据类型；开始支持cache；每次TCP连接只能发送一个请求，当服务器响应后关闭连接，下一次请求关闭连接，即不支持keepalive。为了解决这一问题，有些浏览器使用了非标准的Connection字段：keep-alive。http/1.1：引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection：keep-alive，若一段时间没有请求，就主动关闭，或者在发送最后一个请求的时候，Connection：close；加入管道机制，可以同时发送多个请求，增加了并发性；新增put，options，delete，connect，trace请求方法；http/2.0：增加了双工模式，客户端不仅可以同时发送多条数据，服务器可以同时处理多个请求，解决了队头堵塞的问题；增加了服务器的推送功能；创建公共的信息字段表，以索引号来表示信息字段；采用二进制格式而非文本格式； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40fc9882ac0afd96aff6d097f7f982ec/" rel="bookmark">
			向excel表格的sheet页面添加数据，覆盖原数据，不改变原excel其他的sheet页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用openyxl库向excel表格的sheet页面添加数据，覆盖原数据，不改变原excel其他的sheet页面 import pandas as pd from openpyxl import load_workbook def write_excel(date1, date2): book = load_workbook(r'C:\Users\86159\Desktop\test.xlsx') writer = pd.ExcelWriter(r'C:\Users\86159\Desktop\test.xlsx', engine='openpyxl') writer.book = book idx = book.sheetnames.index("集中作业处人员信息") book.remove(book.worksheets[idx]) #删除原数据 book.create_sheet("集中作业处人员信息", idx) idy = book.sheetnames.index("托管部门人员信息") book.remove(book.worksheets[idy]) #删除原数据 book.create_sheet("托管部门人员信息", idy) writer.sheets = dict((ws.title, ws) for ws in book.worksheets) #保存其他用不到的sheet页面 date1.to_excel(writer, "集中作业处人员信息", index=False) #保存数据 date2.to_excel(writer, "托管部门人员信息", index=False) writer.save() writer.close() #创建dateframe数据 a = np.random.randint(1, 6, (5, 3)) date1 = pd.DataFrame(a, columns=['A', 'B', 'C']) a = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40fc9882ac0afd96aff6d097f7f982ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5da30fdf7c9af2904a808883f9f72ecb/" rel="bookmark">
			后台php处理 微信小程序 授权登录 获取手机号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信获取手机 必须 先授权登录 ，也就是在前端使用 wx.login(),详情请看微信官方文档 一、后台拿到 code 也就是登录后返回的 一个参数 ，然后进行 auth.code2Session 解密 , 换取 openid 和 session_key 代码入下
$appid = '你的appid';//小程序唯一标识 (在微信小程序管理后台获取) $appsecret = '你的';//小程序的 app secret (在微信小程序管理后台获取) $grant_type = "authorization_code"; //授权（必填） $js_code = '前端获取的code' $curl = curl_init(); //使用curl_setopt() 设置要获得url地址 $url = 'https://api.weixin.qq.com/sns/jscode2session?appid=' . $appid . '&amp;secret=' . $appsecret . '&amp;js_code=' . $js_code . '&amp;grant_type=' . $grant_type; curl_setopt($curl, CURLOPT_URL, $url); //设置是否输出header curl_setopt($curl, CURLOPT_HEADER, false); //设置是否输出结果 curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); //设置是否检查服务器端的证书 curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false); //使用curl_exec()将curl返回的结果转换成正常数据并保存到一个变量中 $data = curl_exec($curl); //关闭会话 curl_close($curl); return json_decode($data,true); 二、获取到的 openid 就是小程序 授权登录的唯一标示符 然后我们就需要 前端 再登录后 点击 &lt;button open-type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5da30fdf7c9af2904a808883f9f72ecb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fbec3d0146f9945c6ad6a42ae05a647/" rel="bookmark">
			nginx 负载策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、轮询(weight=1)
默认选项，当weight不指定时，各服务器weight相同，
每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。
upstream bakend { server 192.168.1.10; server 192.168.1.11; } 2、weight
指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。
如果后端服务器down掉，能自动剔除。
比如以下配置，则1.11服务器的访问量为1.10服务器的两倍。
upstream bakend { server 192.168.1.10 weight=1; server 192.168.1.11 weight=2; } 3、ip_hash
每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session不能跨服务器的问题。
如果后端服务器down掉，要手工down掉。
upstream resinserver{ ip_hash; server 192.168.1.10:8080; server 192.168.1.11:8080; } 4、fair（第三方插件）
按后端服务器的响应时间来分配请求，响应时间短的优先分配。
upstream resinserver{ server 192.168.1.10:8080; server 192.168.1.11:8080; fair; } 5、url_hash（第三方插件）
按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存服务器时比较有效。
在upstream中加入hash语句，hash_method是使用的hash算法。
upstream resinserver{ server 192.168.1.10:8080; server 192.168.1.11:8080; hash $request_uri; hash_method crc32; } 设备的状态有:
1、down 表示单前的server暂时不参与负载
2、weight 权重,默认为1。 weight越大，负载的权重就越大。
3、max_fails 允许请求失败的次数默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fbec3d0146f9945c6ad6a42ae05a647/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40d67bd62dd756d34ecfb936b5aaa83e/" rel="bookmark">
			elasticsearch 聚合脚本（Aggregation script）错误：No such property: xxx for class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		es版本是2.1.2（比较老的版本了）
索引有8个分片
做聚合查询使用脚本对两个聚合字段做除法处理
{ "size": 0, "query": { "bool": { "must": [ { "term": { "lvl": 7 } }, { "terms": { "dt": [ "2019-09-01", "2019-09-02", "2019-09-03", "2019-09-04", "2019-09-05" ] } }, { "terms": { "buId": [ "1726" ] } } ] } }, "aggregations": { "dt": { "terms": { "field": "dt" }, "aggregations": { "deptId1": { "terms": { "field": "deptId1", "size": 0 }, "aggregations": { "storageRatio": { "avg": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40d67bd62dd756d34ecfb936b5aaa83e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/688697da4014263603e1be5e2f3261b9/" rel="bookmark">
			[College] C&#43;&#43;字符串读入与进制转化-关于《实践教程》P10[程序]的一些总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引子 在《实践教程》P10的程序代码如下：
#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;cstdlib&gt; #include&lt;algorithm&gt; using namespace std; int main() { char a[20]; int i; cout&lt;&lt;"请输入以下包含空格的字符串：It's a book."&lt;&lt;endl; cin&gt;&gt;a[0]&gt;&gt;a[1]&gt;&gt;a[2]&gt;&gt;a[3]&gt;&gt;a[4]&gt;&gt;a[5]&gt;&gt;a[6]&gt;&gt;a[7]&gt;&gt;a[8]&gt;&gt;a[9]; a[10]='\0'; cout&lt;&lt;"保存的是："&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"请重新输入一遍"&lt;&lt;endl; cin.get(a[0]); cin.get(a[1]); cin.get(a[2]); cin.get(a[3]); cin.get(a[4]); cin.get(a[5]); cin.get(a[6]); cin.get(a[7]); cin.get(a[8]); cin.get(a[9]); cin.get(a[10]); cin.get(a[11]); cin.get(a[12]); cin.get(a[13]); a[14]='\0'; cout&lt;&lt;"保存的是："&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"注意：a[0]存放上次输入的回车符，a[14]存放本次输入结束的回车符，各自产生一个换行。"&lt;&lt;endl; cout&lt;&lt;"请输入一个八进制整数：0750"&lt;&lt;endl; cin&gt;&gt;i; cout&lt;&lt;"输出的数用十进制表示是："&lt;&lt;endl; cout&lt;&lt;dec&lt;&lt;i&lt;&lt;endl; cout&lt;&lt;"请输入十六进制整数：0xff"&lt;&lt;endl; cin&gt;&gt;i; cout&lt;&lt;"输入的数用十进制表示是："&lt;&lt;endl; cout&lt;&lt;dec&lt;&lt;i&lt;&lt;endl; cout&lt;&lt;"使用get.line()吸收0后面的字符："&lt;&lt;endl; cin.getline(a,18); cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"改用显式指定类型，输入八进制数750："&lt;&lt;endl; cin&gt;&gt;oct&gt;&gt;i; cout&lt;&lt;"输入的数用十进制表示是："&lt;&lt;endl; cout&lt;&lt;i&lt;&lt;endl; cout&lt;&lt;"输入的数用八进制表示是："&lt;&lt;endl; cout&lt;&lt;oct&lt;&lt;i&lt;&lt;endl;//指明用八进制输出以后一直有效 cout&lt;&lt;"请输入十六进制整数：ff"&lt;&lt;endl; cin&gt;&gt;hex&gt;&gt;i; cout&lt;&lt;"输入的数用十进制表示是："&lt;&lt;endl; cout&lt;&lt;dec&lt;&lt;i&lt;&lt;endl;//必须显式地改为十进制 cout&lt;&lt;"输入的数用十六进制表示是："&lt;&lt;endl; cout&lt;&lt;hex&lt;&lt;i&lt;&lt;endl; cout&lt;&lt;"请输入字符串：This is a cat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/688697da4014263603e1be5e2f3261b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4942ace54eb3eb4d48697e56f3baa531/" rel="bookmark">
			关于 token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户在浏览器做一系列操作，后台服务怎么判断这些操作是来自同一个用户？
1. seesion
用户登录后，后台生成 sessionid 返回给浏览器，浏览器的每次请求带上 sessionid，后台关联 sessionid 和用户信息。在分布式系统中，需要使用 redis 或 memcached 等中间件。
2. token
用户登录后，后台根据用户信息，指定算法，私钥生成 token，然后返回 token 给浏览器，浏览器的每次请求带上 token，后台收到 token 后，重新计算生成签名验证 token，token 中带有用户信息。
相关技术：JSON Web Token
header.payload.signature
转载于:https://www.cnblogs.com/allenwas3/p/11589841.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13d70267f5b2fbd3d7a2e11c94800853/" rel="bookmark">
			SQL中case when的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		建表 插入数据 CREATE TABLE course ( id INT ( 20 ), sid INT ( 20 ), course VARCHAR ( 255 ), score INT ( 20 ) ); INSERT INTO `course` VALUES (1, 1, '语文', 43); INSERT INTO `course` VALUES (2, 1, '数学', 55); INSERT INTO `course` VALUES (3, 2, '语文', 77); INSERT INTO `course` VALUES (4, 2, '数学', 88); INSERT INTO `course` VALUES (5, 3, '语文', 98); INSERT INTO `course` VALUES (6, 3, '数学', 65); 一、case when then else end的用法 (1)基本用法 case when 条件1 then 条件成立的内容 when 条件2 then 条件成立执行的内容 else 其他条件 end (2)在update更新中使用 UPDATE TABLE SET 字段 1 = CASE WHEN 条件 1 THEN 值 1 WHEN 条件 2 THEN 值 2 ELSE 值 3 END WHERE (3)在select查询中使用 select 字段1, 字段2, case 字段3 when 值1 then 新值 when 值2 then 新值 end as 重新命名字段3的名字 from table (4)在where条件中使用 select 字段1,字段2,字段3 from table where case when 条件1 then where后的条件 when 条件2 then where后的条件 else where后想加的条件 end -- 举例说明：语文成绩找到及格的，数学成绩找出来不及格的,相当于找到偏科偏语文的学生的学生 select * from course where case when course = '语文' then score&gt;60 when course = '数学' then course&lt;60 end (5)在GROUP BY分组中使用 select 字段1,字段2,字段3 from table where 条件 group by case when 条件1 then 字段x when 条件2 then 字段y end 说明：满足条件1以字段x分组，满足条件2以字段y分组。 (6)在Order By排序中使用 select 字段1,字段2,字段3 from table where 条件 order by case when 条件1 then 字段x when 条件2 then 字段y end 说明：满足条件1以字段x排序，满足条件2以字段y排序。 -- 所有数学课程成绩 大于 语文课程成绩的学生的学号 -- 第1步、使用case when来进行行列转换 select sid 学号, case WHEN course='语文' then score else 0 end as 语文分数, case WHEN course='数学' then score else 0 end as 数学分数 from course -- 第2步 根据学号进行合并，将同一个学生的数学和语文成绩放在一行显示 -- "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13d70267f5b2fbd3d7a2e11c94800853/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89c0960ec00af4ff0f1a41e1f227df1a/" rel="bookmark">
			遞歸回溯解決8皇后問題
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天學習了經典的8皇后問題,强化了對遞歸調用的理解,之前自己寫遞歸老是把出口條件理解錯,導致邏輯錯誤,時常抛棧溢出的錯誤.
其實簡單來説遞歸調用,在調用之前,一定要想明白,遞歸出口在哪裏,在調用遞歸的時候,怎麽能讓遞歸的代碼不斷向出口方向靠近,
最終能找到遞歸的出口.這個問題想明白了,遞歸調用也就成功了一半了.
之前在調用遞歸時還發現,遞歸説到底是通過棧進行計算,如果在遞歸裏調用了堆裏的東西,一定不能是new出來的對象.
而且遞歸調用時要盡量把調用遞歸用到的資源放到外面,減少遞歸調用的資源.
舉個簡單例子來説,寫一個輸出重複語句的遞歸方法,代碼本身沒問題,但是如果調用方法次數過多,仍然會抛出棧溢出的錯誤.
用代碼測試過,一個簡單的輸出語句,在我電腦上,用String直接調用遞歸方法,一旦超過6200次就可能抛異常,
用StringBuilder調用遞歸方法,一旦超過12000次也可能抛異常
今天老師講的遞歸實現8皇后的方法確實很經典.占用資源也不多,但老師說,實際上這樣的算法大概得調用14000多次遞歸方法
由此可見,其實遞歸方法代碼占用的資源和代碼本身的複雜程度關係並不大,關鍵還是看代碼怎麽設計的,
怎麽能夠在調用時還能保證不占用過多的計算機資源.
以上就是我本人對於遞歸的一些粗淺的理解.
下面放上我重寫過的遞歸解決8皇后問題的代碼.
1 package com.recursion; 2 3 /* 4 * 遞歸回溯解決8皇后問題 5 * 需求,根據象棋的規則,在棋盤上放置8個皇后,每個皇后的下一步棋不能吃子 6 * 棋盤上放置到第8個皇后時,8個皇后的位置作爲一個正解,算出總共有多少正解 7 * 8 * 遞歸回溯的思路 9 * 將第一個皇后放在第一行第一列,放第二個皇后,看下一步棋是否能吃子, 10 * 不能吃子則放第三個皇后,放置下一個子時,位置可能回溯,發生變化 11 * 放到第8個皇后時開始回溯求解 12 * 得到一個正確解就會退回一個棧,會把棧裏所有的可能性都嘗試一遍, 13 * 退回上一個棧,再次求解,一直回溯到第一個皇后 14 * 15 */ 16 public class EightQueen { 17 //1,共有8個皇后 18 int max = 8; 19 //1,定義存放解法的數組 20 int[] array = new int[max]; 21 //5,定義解法的變量 22 static int count = 0; 23 public static void main(String[] args) { 24 // TODO Auto-generated method stub 25 //1,用一維數組表示棋盤,索引表示行坐標,數值表示列坐標 26 //定義一個將皇后放的位置輸出的方法 27 //4,調用遞歸方法測試 28 EightQueen queen8 = new EightQueen(); 29 queen8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89c0960ec00af4ff0f1a41e1f227df1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e6b4634e463f6c5518004189fecb1c9/" rel="bookmark">
			7-8 猜数字 (20 分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 7-8 猜数字 (20 分) 一群人坐在一起，每人猜一个 100 以内的数，谁的数字最接近大家平均数的一半就赢。本题就要求你找出其中的赢家。
输入格式：
输入在第一行给出一个正整数N（≤10
​4
​​ ）。随后 N 行，每行给出一个玩家的名字（由不超过8个英文字母组成的字符串）和其猜的正整数（≤ 100）。
输出格式：
在一行中顺序输出：大家平均数的一半（只输出整数部分）、赢家的名字，其间以空格分隔。题目保证赢家是唯一的。
输入样例：
7
Bob 35
Amy 28
James 98
Alice 11
Jack 45
Smith 33
Chris 62
输出样例：
22 Amy
#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; struct E{ char name[11]; int num; }a[10001]; int main(){ int n,sum=0; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++){ scanf("%s%d",a[i].name,&amp;a[i].num); sum+=a[i].num; } int avg=(sum/n)/2,minm=11111,tag; for(int i=0;i&lt;n;i++){ if(abs(avg-a[i].num)&lt;minm){ minm=abs(avg-a[i].num); tag=i; } } printf("%d %s\n",avg,a[tag].name); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8cee269df827a5c9af1e55f5815bd34/" rel="bookmark">
			timeout超时时长优化和hystrix dashboard可视化分布式系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在生产环境中部署一个短路器，一开始需要将一些关键配置设置的大一些，比如timeout超时时长，线程池大小，或信号量容量
然后逐渐优化这些配置，直到在一个生产系统中运作良好
（1）一开始先不要设置timeout超时时长，默认就是1000ms，也就是1s
（2）一开始也不要设置线程池大小，默认就是10
（3）直接部署hystrix到生产环境，如果运行的很良好，那么就让它这样运行好了
（4）让hystrix应用，24小时运行在生产环境中
（5）依赖标准的监控和报警机制来捕获到系统的异常运行情况
（6）在24小时之后，看一下调用延迟的占比，以及流量，来计算出让短路器生效的最小的配置数字
（7）直接对hystrix配置进行热修改，然后继续在hystrix dashboard上监控
（8）看看修改配置后的系统表现有没有改善
根据系统表现优化和调整线程池大小，队列大小，信号量容量，以及timeout超时时间的经验
一开始如果默认的线程池大小是10
理想情况下，每秒的高峰访问次数 * 99%的访问延时 + buffer = 30 * 0.2 + 4 = 10线程，10个线程每秒处理30次访问应该足够了，每个线程处理3次访问
此时，我们合理的timeout设置应该为300ms，也就是99.5%的访问延时，计算方法是，因为判断每次访问延时最多在250ms（TP99如果是200ms的话），再加一次重试时间50ms，就是300ms，感觉也应该足够了
因为如果timeout设置的太多了，比如400ms，比如如果实际上，在高峰期，还有网络情况较差的时候，可能每次调用要耗费350ms，也就是达到了最长的访问时长
那么每个线程处理2个请求，就会执行700ms，然后处理第三个请求的时候，就超过1秒钟了，此时会导致线程池全部被占满，都在处理请求
这个时候下一秒的30个请求再进来了，那么就会导致线程池已满，拒绝请求的情况，就会调用fallback降级机制
因此对于短路器来说，timeout超时一般应该设置成TP99.5，比如设置成300ms，那么可以确保说，10个线程，每个线程处理3个访问，每个访问最多就允许执行300ms，过时就timeout了
这样才能保证说每个线程都在1s内执行完，才不会导致线程池被占满，然后后续的请求过来大量的reject
对于线程池大小来说，一般应该控制在10个左右，20个以内，最少5个，不要太多，也不要太少
刚开始的时候，每个依赖服务都是给1个线程，3个线程，但是我们允许说，如果你的某个线程池突然需要大量的线程，最多可以到100个线程
如果你使用了100个线程，高峰期过去了，自动将空闲的线程给释放掉
（1）coreSize
设置线程池的大小，默认是10
HystrixThreadPoolProperties.Setter()
.withCoreSize(int value)
（2）maximumSize
设置线程池的最大大小，只有在设置allowMaximumSizeToDivergeFromCoreSize的时候才能生效
默认是10
HystrixThreadPoolProperties.Setter()
.withMaximumSize(int value)
（5）keepAliveTimeMinutes
设置保持存活的时间，单位是分钟，默认是1
如果设置allowMaximumSizeToDivergeFromCoreSize为true，那么coreSize就不等于maxSize，此时线程池大小是可以动态调整的，可以获取新的线程，也可以释放一些线程
如果coreSize &lt; maxSize，那么这个参数就设置了一个线程多长时间空闲之后，就会被释放掉
HystrixThreadPoolProperties.Setter()
.withKeepAliveTimeMinutes(int value)
（6）allowMaximumSizeToDivergeFromCoreSize
允许线程池大小自动动态调整，设置为true之后，maxSize就生效了，此时如果一开始是coreSize个线程，随着并发量上来，那么就会自动获取新的线程，但是如果线程在keepAliveTimeMinutes内空闲，就会被自动释放掉
默认是fales
HystrixThreadPoolProperties.Setter()
.withAllowMaximumSizeToDivergeFromCoreSize(boolean value)
1、为什么需要监控与报警？
HystrixCommand执行的时候，会生成一些执行耗时等方面的统计信息。这些信息对于系统的运维来说，是很有帮助的，因为我们通过这些统计信息可以看到整个系统是怎么运行的。hystrix对每个command key都会提供一份metric，而且是秒级统计粒度的。
这些统计信息，无论是单独看，还是聚合起来看，都是很有用的。如果将一个请求中的多个command的统计信息拿出来单独查看，包括耗时的统计，对debug系统是很有帮助的。聚合起来的metric对于系统层面的行为来说，是很有帮助的，很适合做报警或者报表。hystrix dashboard就很适合。
2、hystrix的事件类型
对于hystrix command来说，只会返回一个值，execute只有一个event type，fallback也只有一个event type，那么返回一个SUCCESS就代表着命令执行的结束
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8cee269df827a5c9af1e55f5815bd34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09aed1435f86b89e41abacd2c90ec400/" rel="bookmark">
			初识微服务框架ServiceComb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/zengdongwen/article/details/93486257
后续跟进学习。
转载于:https://www.cnblogs.com/chaojizhengui/p/11586398.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31c7a8c7ba15583c71db1c2a2eb5bfbc/" rel="bookmark">
			Everything中http和ETP&amp;FTP服务器的用法和感受
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. HTTP服务器属于阉割版 a.点开everything后，直接勾选启用http服务器，然后点击确定，这时候http服务器就可以使用了
b. 此时我们可以在本机打开IE浏览器，然后输入：http:localhost：8080回车；
或者输入：http://PCID：8080回车，其中PCID是电脑的名字
http存在一个致命缺陷，那就是只能在本机上服务器查询，其他机台不能使用。手机也不能使用，这个和网络没有关系，我也是迷茫中。这样看，http服务器还不如ftp服务器
2.FTP服务器的使用费了一番功夫 1.ftp服务器和http服务器的创建类似，只需要启用然后确定即可。但是有时候会报错，这是一种因为端口已经被占用，我们可以将21，更改为2121，然后再次确定即可。
2.上面描述的是服务器的创建，那么客户端进行访问呢，那就打开everything，在窗口中直接输入客户端服务器IP，还有对应端口，然后确定就可以连接到服务器
3.ftp服务器连接成功后，我们就可以进行搜索了。出现的结果也是有条理的：
会显示搜索结果来自于ftp，并且显示C D E F G表示的硬盘盘位。
还是要补充说明，如果通过everything创建的ftp服务器的主机上，已经通过win系统创建了ftp服务器，那么这两个服务器都是ftp服务器，只是端口不同，那么客户端everything即使输入正确的IP和端口，也连接不到该ftp服务器。这个非常遗憾，也可能是我的水平问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5105e3aa86e0e83abeb403a28e681132/" rel="bookmark">
			mark a good day for 大数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一种新的大数据就要诞生，这种新的大数据将会引发数据存储的变革，将会改变社会信息发布方式
The new public information issuing method will lead the infomation teachnologies.
转载于:https://www.cnblogs.com/action-L/p/11584436.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/537ffb05ac997c409ac111e6276ad02c/" rel="bookmark">
			如何使用windows的bat命令获取到小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://zhidao.baidu.com/question/180631496511289124.html?qbl=relate_question_1&amp;word=bat%20%C1%BD%CE%BB%CA%FD%CF%E0%B3%FD%20%D0%A1%CA%FD%B5%E3%20set
应该说bat只能简单计算且计算式只能是整数，结果中小数部分直接被舍弃
但可以想办法先将需要的小数位扩大为整数，通过字符串的处理后得到需要的带小数的值,比如计算 11/3 保留两位小数 （4舍5入）
@echo off
set/a a=11,b=3,x=a/b
echo 直接计算会取整：%a%÷%b%=%x%
set/a a2=a*1000
set/a x=a2/b+5
set x=%x:~,-3%.%x:~-3,2%
echo 精确(4舍5入)到两位小数: %a%÷%b%=%x%
pause
=====保留一位小数
set x=%x:~,-2%.%x:~-2,1%
REM Select two decimal digits for all operations SET /A VAR=250+310 ECHO RESULT: %VAR:~0,-2%.%VAR:~-2%
rem Set "ONE" variable with two decimal places: SET ONE=100 rem To multiply two FP numbers, divide the result by ONE: SET /A MUL=A*B/ONE rem To divide two FP numbers, multiply the first by ONE: SET /A DIV=A*ONE/B https://stackoverflow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/537ffb05ac997c409ac111e6276ad02c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a6df02dafdf60424b1777ed610292b2/" rel="bookmark">
			Android 9.0 以太网上网设置静态ip，解决拔插后才能更改ip地址的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前面看过Android7.0与8.0的以太网后，对9.0的以太网解决起来更得心应手了。在添加以太网后，可以顺利设置静态ip.但是当我设置静态后，出现需要将网线拔插一次更新网络后才能刷新ip地址的bug。当时以为只要像7.0和8.0那样新增就没有问题了，没想到这次9.0又改变了代码结构。下面我将详细介绍9.0的网络步骤。
以下是设计到的文件极其目录：
packages\apps\Settings\src\com\android\settings\ethernet\EthernetConfigDialog.java-----------设置静态ip,自己新增
frameworks\base\core\java\android\net\EthernetManager.java frameworks\opt\net\ethernet\java\com\android\server\ethernet\EthernetServiceImpl.java
frameworks\opt\net\ethernet\java\com\android\server\ethernet\EthernetTracker.java ————区别其他版本，Google新增的类
frameworks\opt\net\ethernet\java\com\android\server\ethernet\EthernetNetworkFactory.java
为了能够在不看其他版本或者不了解之前Android版本以太网流程情况下尽快熟知，我这里还是需要啰嗦的讲一下以太网的流程。
以下仅设置静态ip流程。
1：主动调用设置静态ip方法
try { StaticIpConfiguration staticIpConfiguration = new StaticIpConfiguration(); InetAddress mIpAddr = NetworkUtils.numericToInetAddress(mIpaddr.getText().toString());//ip地址 String[] strs = mMask.getText().toString().split("\\.");//子网掩码参数 int count = 0; for(String str : strs){ if(str.equals("255")){ count++; } } int prefixLength = count*8; LinkAddress mIpAddress = new LinkAddress(mIpAddr,prefixLength); InetAddress mGateway = NetworkUtils.numericToInetAddress(mGw.getText().toString());//网关地址 ArrayList&lt;InetAddress&gt; mDnsServers = new ArrayList&lt;InetAddress&gt;(); mDnsServers.add(NetworkUtils.numericToInetAddress(mDns1.getText().toString()));//dns1 //与dns2的值 mDnsServers.add(NetworkUtils.numericToInetAddress(mDns2.getText().toString())); staticIpConfiguration.ipAddress = mIpAddress; staticIpConfiguration.gateway = mGateway; staticIpConfiguration.dnsServers.addAll(mDnsServers); config = new IpConfiguration(IpAssignment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a6df02dafdf60424b1777ed610292b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23445f194370fe5aed29855c8ffa8e2b/" rel="bookmark">
			將中綴運算式轉換為逆波蘭運算式並計算結果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看了一下我的播客, 自從加入培訓班後就沒怎麼更新了, 主要還是覺得代碼水準有所提升, 之前寫的一些非常基礎的代碼已經變的沒有太大價值了.
繼續寫這一類代碼, 用處也不大, 以後可能會上一些品質比較高的代碼. 最起碼對我而言還是有一定難度的.
這裡上一段逆波蘭運算式的代碼.
需求是這樣的: 將String math = "12.8 + (2 - 3.55)*4+10/5.0"這個中綴表達式的字符串轉換為逆波蘭表達式(後綴表達式), 並計算出結果.
轉換后的逆波蘭表達式應該是這樣的: 12.8, 2, 3.55, -, 4, *, +, 10, 5.0, /, +
這個代碼涉及到了集合, 和棧的一些基本操作. 這裏就不詳細記錄了. 主要還是記錄一下大體的思路
思路如下: 1, 定義運算符的優先級, 並將優先級計算方法寫出來.
2, 掃描中綴表達式,順序進行判斷, 在判斷的過程中用棧存儲計算結果, 用一個集合存儲後綴表達式.
3, 計算的邏輯是這樣的: 從左往右掃描, 如果第一個拿到的不是括號或者數字, 抛異常, 掃描第一個數字, 并且掃描後面的並判斷,
如果還是數字, 或者小數點, 拿到后做拼接, 直到掃描到運算符停止, 將拼接的結果入棧; 掃描到第一個符號, 直接入棧,再往下,
遇到左括號也直接入棧, 繼續掃描, 重複上一個邏輯, 直到遇到右括號, 遇到右括號后, 將前面兩個數彈出, 再從符號棧彈出左括號和一個運算符,
計算后得到一個數, 再次入棧.(這裏要將左右括號丟掉). 如果上一個邏輯中有多個數和多個運算符, 計算運算符的優先級, 根據優先級做彈棧和計算,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23445f194370fe5aed29855c8ffa8e2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a6f7751729c729008ce9eb290252bf6/" rel="bookmark">
			java之冒泡排序8个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.实现思路二.冒泡排序三.代码实现 一.实现思路 我们在实现这8个数排序主要思路是：先用一个数组存取8个数字，然后使用冒泡排序从小到大进行排序。
二.冒泡排序 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
三.代码实现 我们定义变量i表示数组，变量j表示数组的下一位。
也就是说：a[i]和a[j]分别代表了数组的上一位和下一位，利用双重循环的特点【先内层执行完毕，再执行外层循环】进行数组的比较。
public class max{ public static void main(String []args){ //定义一个一维数组,并初始化值 int a[]={78,23,56,34,12,45,67,89}; int i,j,temp; /*进行冒泡排序*/ for(i=0;i&lt;a.length;i++){ for(j=0;j&lt;a.length;j++) { if(a[i]&lt;a[j]) { temp=a[i]; a[i]=a[j]; a[j]=temp; } } } /*输出这个数组*/ for(i=0;i&lt;a.length;i++) System.out.print(""+a[i]); } } import java.util.Scanner; public class BubbleSort { public static void main(String[] args) { // TODO 自动生成的方法存根 int l = 0; Scanner scanner=new Scanner(System.in);//系统的标准输入 int []numbers=new int[8]; System.out.println("please enter eight numbers:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a6f7751729c729008ce9eb290252bf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c552701fcb0195d15fa16725238320f/" rel="bookmark">
			Vue去掉警告 You are running Vue in development mode......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决Vue控制台提示
警告内容：
您正在以开发模式运行Vue。
在部署生产时，请确保打开生产模式。
解决方案：添加 Vue.config.productionTip = false
&lt;script type="text/javascript" src="./js/vue.js"&gt;&lt;/script&gt; &lt;script&gt;Vue.config.productionTip = false&lt;/script&gt; 参考Vue官方教程：https://cn.vuejs.org/v2/guide/
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/460/">«</a>
	<span class="pagination__item pagination__item--current">461/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/462/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>