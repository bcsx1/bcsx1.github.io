<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f805fcf94b1da1d950f73cbbd432e9af/" rel="bookmark">
			电子科大2020图论考题回忆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电子科大2020图论考题回忆 在8.26号考的，凭着回忆梳理一下，表述不会和考题一模一样，但是和题目的大体意思一样。
题型就是填空，选择和大题。
一.填空题 一个3正则图的补图有16条边，则这个图的顶点数是：__
ps:
首 先 是 握 手 定 理 ： 3 n = 2 m 首先是握手定理：3n=2m 首先是握手定理：3n=2m
然 后 是 补 图 和 此 图 边 数 合 是 完 全 图 的 边 数 ： m + 16 = n ∗ ( n − 1 ) 2 然后是补图和此图边数合是完全图的边数：m+16=\frac{n*(n-1)}{2} 然后是补图和此图边数合是完全图的边数：m+16=2n∗(n−1)​
一个图是极大平面图，给了顶点数n，问有几个面：__
ps:
极 大 平 面 图 有 φ = 2 ∗ n − 4 极大平面图有\varphi=2*n-4 极大平面图有φ=2∗n−4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f805fcf94b1da1d950f73cbbd432e9af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bd429ad4621c516b11a8b28fccacd18/" rel="bookmark">
			目的NAT转换，源进源出功能，外网访问内部服务器（双出口属于不同安全域）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍双出口环境下公网用户通过NAT策略访问内部服务器（双出口属于不同安全区域）的配置举例 网络拓扑如下
企业一共申请了1.1.1.1和1.1.10.10公网ISP1的公网IP；2.2.2.2和2.2.20.10公网ISP2的公网IP地址；
1.1.1.1和2.2.2.2分别配置到防火墙的两个出口接口上；1.1.10.10和2.2.20.10 分别作为服务器的公网IP为外网用户提供访问服务。内部服务器的IP地址为：10.2.0.8
配置思路
配置接口IP地址和安全区域，完成网络基本参数配置。
配置安全策略，允许外部网络用户访问内部服务器。
配置NAT策略。
在GigabitEthernet 1/0/1和GigabitEthernet 1/0/7上配置源进源出功能和默认网关。
1、配置接口IP地址和安全区域
1-1、配置接口IP地址
[FW-GigabitEthernet 1/0/1] ip address 1.1.1.1 24 [FW-GigabitEthernet 1/0/2] ip address 10.2.0.1 24 [FW-GigabitEthernet 1/0/7] ip address 2.2.2.2 24 1-2、把接口加入对应的安全区域
将接口GigabitEthernet 1/0/2加入DMZ区域。
[FW] firewall zone dmz [FW-zone-dmz] add interface GigabitEthernet 1/0/2 将接口GigabitEthernet 1/0/1加入Untrust1区域。
[FW] firewall zone name untrust1 [FW-zone-untrust1] set priority 10 [FW-zone-untrust1] add interface GigabitEthernet 1/0/1 将接口GigabitEthernet 1/0/7加入Untrust2区域。
[FW] firewall zone name untrust2 [FW-zone-untrust2] set priority 20 [FW-zone-untrust2] add interface GigabitEthernet 1/0/7 2、配置安全策略，允许外网用户访问内部服务器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bd429ad4621c516b11a8b28fccacd18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2468d860a670955d89d849baf92e689f/" rel="bookmark">
			华为防火墙-USG6000系列-补丁的安装和删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意事项：全部板卡注册成功以后才能打补丁操作；（管理员加载补丁时，不允许其他用户登录设备进行操作，否则可能会导致补丁加载失败)
准备工作：从官网下载补丁，搭建好tfp或tftp服务器；
1、确定原来机器上是否安装有补丁。
&lt;huawei&gt;display patch-information
注意：如果原来机器没有补丁，可以直接加载补丁。如果有补丁，需要卸载补丁：
&lt;huawei&gt;patch delete all
2、加载补丁（补丁不能重复加载、补丁版本必须和产品基础版本一致）
&lt;huawei&gt; patch load xxx_V000R000SPH001.pat all
3、激活补丁
&lt;huawei&gt;patch active all
4、运行补丁
&lt;huawei&gt;patch run all
注意：如果是双机热备，同样需要再备份防火墙上 执行一遍。
查看安装的补丁：display patch-information
第二部分：补丁回退
1、删除补丁
&lt;huawei&gt;patch delete all
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e035d43c21eec417ee71787bb007bc0e/" rel="bookmark">
			WGS 1984 投影划分带
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“WGS 1984”坐标系的墨卡托投影分度带（UTM ZONE）选择方法如下：
（1） 北半球地区，选择最后字母为“N”的带； （2） 可根据公式计算，带数=（经度整数位/6）的整数部分+31 如：江西省南昌新建县某调查单元经度范围115°35′20″—115°36′00″， 带数=115/6+31=50，选50N，即WGS 1984 UTM ZONE 50N。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/184ca2dccfa61c880eb2f2b84729603c/" rel="bookmark">
			ECC理解和python代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全称：椭圆曲线加密（Elliptic Curve Cryptography），ECC加密算法是一种公钥加密技术，以椭圆曲线理论为基础。利用有限域上椭圆曲线的点构成的Abel群离散对数难解性，实现加密、解密和数字签名。将椭圆曲线中的加法运算与离散对数中的模乘运算相对应，就可以建立基于椭圆曲线的对应密码体制。Python代码： # -*- coding:utf-8 *- # author: DYBOY # reference codes: https://blog.dyboy.cn/websecurity/121.html # description: ECC椭圆曲线加密算法实现 """ 考虑K=kG ，其中K、G为椭圆曲线Ep(a,b)上的点，n为G的阶（nG=O∞ ），k为小于n的整数。 则给定k和G，根据加法法则，计算K很容易但反过来，给定K和G，求k就非常困难。 因为实际使用中的ECC原则上把p取得相当大，n也相当大，要把n个解点逐一算出来列成上表是不可能的。 这就是椭圆曲线加密算法的数学依据 点G称为基点（base point） k（k&lt;n）为私有密钥（privte key） K为公开密钥（public key) """ def get_inverse(mu, p): """ 获取y的负元 """ for i in range(1, p): if (i*mu)%p == 1: return i return -1 def get_gcd(zi, mu): """ 获取最大公约数 """ if mu: return get_gcd(mu, zi%mu) else: return zi def get_np(x1, y1, x2, y2, a, p): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/184ca2dccfa61c880eb2f2b84729603c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b97bdd119c5d8973a95e0b5da839139a/" rel="bookmark">
			使用SQL求12个月内，连续最大月份数问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL解决连续最大月数问题 问题概述：
某一张表，这里简称test表，其中的数据是按月保存数据的。现在需要计算该数据表中，近12个月的业务数据，并且求某个字段等于0的连续最大月数。
连续最大月数：
一笔业务数据，12个月内的数据如下：
1、2月为03、4、5月为27、8月为09月为610、11、12月为0 则以上该笔业务数据的最大连续月数等于：3，即：10、11、12三个月。
测试数据表 create table test( serialno varchar(32), pmt_amt decimal(38,6), data_dt varchar(15) ) 测试数据 insert into test values('6222822009129',0,'2020-07-31'); insert into test values('6222822009129',1,'2020-06-30'); insert into test values('6222822009129',0,'2020-05-31'); insert into test values('6222822009129',0,'2020-04-30'); insert into test values('6222822009129',0,'2020-03-31'); insert into test values('6222822009129',2,'2020-02-29'); insert into test values('6222822009129',3,'2020-01-31'); insert into test values('6222822009129',0,'2019-12-31'); insert into test values('6222822009129',7,'2019-11-30'); insert into test values('6222822009129',0,'2019-10-31'); insert into test values('6222822009129',0,'2019-09-30'); insert into test values('6222822009129',3,'2019-08-31'); insert into test values('6222822009128',0,'2020-07-31'); insert into test values('6222822009128',1,'2020-06-30'); insert into test values('6222822009128',0,'2020-05-31'); insert into test values('6222822009128',4,'2020-04-30'); insert into test values('6222822009128',0,'2020-03-31'); insert into test values('6222822009128',2,'2020-02-29'); insert into test values('6222822009128',0,'2020-01-31'); insert into test values('6222822009128',0,'2019-12-31'); insert into test values('6222822009128',7,'2019-11-30'); insert into test values('6222822009128',0,'2019-10-31'); insert into test values('6222822009128',0,'2019-09-30'); insert into test values('6222822009128',3,'2019-08-31'); 解决思路 使用row_number()给数据指定序号使用over()函数，按照serialno业务号分组，data_dt升序排序使用trunc()和months_between()函数计算近12个月内的数据使用month()函数计算月份 SELECT SERIALNO, PMT_AMT, DATA_DT, EXTRACT(MONTH FROM TO_DATE(DATA_DT, 'yyyy-mm-dd')) AS MTHS, -- 月份 ROW_NUMBER() OVER(PARTITION BY SERIALNO ORDER BY DATA_DT ASC) AS RANK -- 序号 FROM TEST WHERE TRUNC(MONTHS_BETWEEN(TO_DATE('2020-06-30', 'yyyy-mm-dd'), TO_DATE(DATA_DT, 'yyyy-mm-dd'))) &lt;= 12 计算月份和序号之差（如果是连续月份，则月份和序号之差应该是相同的）过滤掉不满足条件的数据 SELECT T.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b97bdd119c5d8973a95e0b5da839139a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c191799c4ed89354d74a45480427c0e/" rel="bookmark">
			【2020牛客面经整理】美团一面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：牛客395930587号
链接：https://www.nowcoder.com/discuss/490309?channel=1009&amp;source_id=discuss_terminal_discuss_history
来源：牛客网
口述怎么样判断一个链表是否成环。 答：快慢指针检测，快指针每次走两格，慢指针每次走一格，判断二者是否会相遇。
讲一下平衡树的特征。 答：空树或任意节点的子树的高度差都小于等于1.
mysql数据库的索引是用什么结构来实现的？它为什么要用这种结构？它利用了硬盘的哪些特点？ 答：B+树；
要知道为什么用B+树，首先得知道B+树的特点；
1、B+节点关键字搜索采用闭合区间；
2、B+非叶子节点不保存数据相关信息，只保存关键字和子节点的引用；
3、B+关键字对应的数据保存在叶子节点中；
4、B+叶子节点是顺序排列的，并且相邻节点具有顺序引用的关系
B+树在MySQL中的优势：
1、B+树：多路绝对平衡查找树，拥有B-树的优势；
2、B+树扫库表能力更强；
3、B+树的磁盘读写能力更强；
4、B+树的排序能力更强；
5、B+树的查询效率更加稳定
原因：索引本身也很大，不可能全部存储在内存中，因此索引常常以文件的形式存储在磁盘上，这时索引的查找过程就要产生磁盘IO消耗，评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘IO操作次数的渐进复杂度。
使用B+树的原因和磁盘存取原理有很大的关系，由于存储介质和机械运动耗费，磁盘的存取速度往往是主存的几百分之一，为了提高效率，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这是根据著名的局限性原理：当一个数据被用到时，其附近的数据通常会马上被用到。
预读可以提高IO效率，预读的长度一般为页的整数倍。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常称为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存，然后异常返回；
数据库系统巧妙的利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次IO就可以完全载入；
每次新建节点时，直接申请一个页的空间，这样就保证了一个节点物理上也存储在一个页内，加上之前计算机存储分配都是按页对齐的，就实现了一个node只需要一次IO
一次检索最多需要h-1次IO，复杂度O（h）=O（logmN）而红黑树这种结构h要高很多，逻辑上很近的节点物理上可能很远效率太差
给定N个数字，快速找到最大的K个，怎么实现？那么时间复杂度是多少？ 答：堆排，调整成大根堆形式，取堆顶，
O（nlog2n）
归并和快排的相似之处和不同之处？它们的稳定性呢？ 答：相似之处：都运用分治策略实现；
快排：分解；解决；合并
归并：分解；解决；合并
时间复杂度都是O（nlogn）
不同之处：快排是一种不稳定的排序算法；
归并是一种稳定的排序算法（即相等的元素顺序不会改变）但归并排序的空间消耗更大；
有一个文件，然后文件中有几十亿个数字，怎么去重呢？ 递归在实际中会出现什么问题？这里我只说了可能会爆栈，面试官很友善的提示我说那从时间的角度呢？ 超时、栈溢出
讲一下常见的设计模式。 答：代理模式、简单工厂模式、工厂方法模式、
1、单例模式、适配器模式、策略模式；
代理模式为其他对象提供一种代理以控制这个对象的方法，代理类在运行时创建的代理称之为动态代理；（Spring AOP横向切面技术）；
2、简单工厂模式：又称为静态工厂方法模式，在简单工厂模式中，可以根据参数的不同返回不同类的实例，简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同父类；包含以下角色：工厂角色（负责实现创建所有具体产品类的实例，直接被外界调用）、抽象产品角色、具体产品角色；优点：只需要传入一个正确的参数既可以得到结果无须知道细节；缺点：违背了开闭原则，增加一个产品需要修改工厂的逻辑；
3、工厂方法模式：通过定义工厂父类负责定义创建对象的公共方法，而子类负责生产具体对象，将类的实例化（具体产品的创建）延迟到工厂类的子类中完成；角色（抽象产品、具体产品、抽象工厂、具体工厂）；不违背开闭原则但是每新增一个产品还需要增加与之对应的具体工厂，增加系统的复杂性；
4、单例模式：特点：单例模式只能有一个实例；必须自己创建自己的唯一实例；必须给其他对象提供这一唯一实例；饿汉、懒汉、全局锁式、静态代码块式、双重校验锁式、静态内部类式、枚举方式；
5、适配器模式：将一个接口转化为客户所需要的另一个接口，使接口不兼容的一些类可以一起工作；类适配器（使用继承方式）、对象适配器（组合模式）；角色（目标角色、源角色、适配器角色）；优点：复用性、扩展性；缺点：系统较凌乱
hashmap是线程安全的吗？那用什么代替呢，还有一些常见的hashmap的问题 答：不是；hashmap不是线程安全的原因：HashMap在put的时候，插入的元素超过了容量（由负载因子决定）的范围就会触发扩容操作，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的；
用ConcurrentHashMap代替；
HashTable通过使用synchronized关键字修饰方法来实现线程同步，因此Hashtable的同步会锁住整个数组，在高并发的情况下，效率非常差；
ConcurrentHashMap作为高吞吐量的线程安全HashMap实现，采用了锁分离的技术允许多个修改操作并发进行。将Hash表默认分为16个桶（每一个桶看做一个Hahtable），对应的put，remove等操作只需要锁住当前线程需要用到的桶，不需要锁住整个数据。只有个别方法（size（），containsValue（））可能需要锁住整个表而不是某个桶，在实现的时候需要按照顺序锁定所有的桶，操作完毕后又按顺序释放所有桶，按顺序可以防止死锁的发生。在读操作的时候，由于ConcurrentHashMap底层的HashEntry将元素设为final修饰（key，hash，next），几乎是不可变量，所以删除操作时需要把删除节点前面的所有节点都复制一遍，然后把复制后的Hash链的最后一个节点指向待删除节点的后继节点，比较耗时，value用volatile（不能保证原子性）修饰使这个值被修改后对所有线程都可见。
在Java语言中，多线程安全的容器主要分为两种：Synchronized和Concurrent，虽然它们都是线程安全的，但是它们在性能方面差距比较大。
Synchronized容器（同步容器）主要通过synchronized关键字来实现线程安全，在使用的时候会对所有的数据加锁。需要注意的是，由于同步容器将所有对容器状态的访问都串行化了，这样虽然保证了线程的安全性，但是这种方法的代价就是严重降低了并发性，当多个线程竞争容器时，吞吐量会严重降低。于是引入了Concurrent容器（并发容器），Concurrent容器采用了更加智能的方案，该方案不是对整个数据加锁，而是采取了更加细粒度的锁机制，因此，在大并发量的情况下，拥有更高的效率。
synchronized锁的对象是什么？ 答：1、对于同步方法，锁当前对象；
2、对于静态同步方法，锁当前类的class对象
3、对于同步代码块，锁住的是synchronized括号中的对象
synchronized和lock的区别 答：1、存在层面：Synchronized是java中的一个关键字，存在于JVM层面，Lock是java中的一个接口；
2、锁的释放条件：（1）获取锁的线程执行完同步代码后，自动释放；（2）线程发生异常时，JVM会自动释放锁；Lock必须在finally关键字中释放锁，不然容易造成线程死锁；
3、锁的获取：在Syncronized中，假设线程A获得锁，B线程等待。如果A发生阻塞，那么B会一直等待。在Lock中会分情况而定，Lock中有尝试获取锁的方法，如果尝试获得锁，则不用一直等待；
4、锁的状态：Synchronized无法判断锁的状态，Lock则可以判断；
5、锁的类型：synchronized是可重入锁，不可中断，非公平锁；Lock锁则是可重入锁，可中断，可公平锁；
6、锁的性能：synchronized使用与少量同步的情况下，性能开销比较大。Lock锁使用于大量同步阶段：
（1）Lock锁可以提高多个线程进行读的效率（使用readWriteLock）
（2）在竞争不是很激烈的情况下，synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，synchronized的性能会下降几十倍，ReetrantLock的性能可以维持常态；
（3）ReetrantLock提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步等；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c191799c4ed89354d74a45480427c0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69ec0184f8b3b94542f70170fd8835aa/" rel="bookmark">
			搭建数据库项目的步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、创建package.json文件 npm init -y 2、下载需要使用的插件 npm i express mysql express-session await-to-js 3、创建一个数据库配置文件db_config.js 4、创建数据库连接文件 dbConnect.js 5、创建一个文件夹db,并将db_config.js和dbConnect.js放到该文件夹下 6、书写连接数据库代码,并将相关的类抛出。 7、新建一个model文件夹，新建一个userModel.js文件，并书写业务层逻辑代码， 8、新建一个子路由文件夹router，新建一个子路由文件userRouter.js 9、新建一个主路由文件app.js 10、新建一个public文件夹用来存放静态资源 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0b8dc69d249f9dc99fdf923ae21d8fa/" rel="bookmark">
			创建数据库的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、下载Mysql插件 npm i mysql 2、引入Mysql插件 const mysql=require("mysql"); 3、创建数据库连接 mysql.createConnection(this.config); 注：创建数据库连接的时候要配置相关参数，如，数据库地址，登录用户名，登录密码，端口号，数据库的名字
#4、建立数据库连接
引用.connect(); connect()方法可以以回调函数作为参数，但是回调函数的参数是err,当连接数据库出错的时候，会有值，不出错就是null. 引用.connect((err)=&gt;{ }); 5、执行sql语句，使用 引用.query() 6、关闭数据库 con.end(),此方法可以传递回调函数作为形参 con.destroy()，不能传递参数 关闭数据库的方法--end()可以是回调当形参，注：回调中只有一个参数err,错误参数，如果数据关闭的时候产生错误，则其会有值，否则就是null. con.end((err)=&gt;{ }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a3863a5c23e2f87c8aba15b7b84f1c2/" rel="bookmark">
			windows cmd删除指定文件夹下指定时间文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cmd 命令
forfiles /p "E:\Service\RAService\CustomerPhoto\pic" /s /m *.jpg /d -365 /c "cmd /c del @path /q /f" 文件加地址： E:\Service\RAService\CustomerPhoto\pic
文件类型 ： .jpg
多少天以前： -365
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a2b651132d3f0766bb1d43e10b8c77b/" rel="bookmark">
			Phoenix构建HBase二级索引案例实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、为什么要使用二级索引？
二、全局索引和本地索引
三、可变索引和不可变索引
四、配置HBase支持Phoenix二级索引
五、实战
5.1 在phoenix中创建表
5.2 导入测试数据
5.3 Global Indexing的二级索引测试
5.4 Local Indexing的二级索引测试
5.5 如何确保query查询使用Index
5.6 索引重建
5.7 删除索引
六、索引性能调优
一、为什么要使用二级索引？ 对于HBase而言，如果想精确地定位到某行记录，唯一的办法是通过rowkey来查询。如果不通过rowkey来查找数据，就必须逐行地比较每一列的值，即全表扫瞄。
对于较大的表，全表扫描的代价是不可接受的。但是，很多情况下，需要从多个角度查询数据。
例如，在定位某个人的时候，可以通过姓名、身份证号、学籍号等不同的角度来查询
要想把这么多角度的数据都放到rowkey中几乎不可能（业务的灵活性不允许，对rowkey长度的要求也不允许）。
所以需要secondary index（二级索引）来完成这件事。secondary index的原理很简单，但是如果自己维护的话则会麻烦一些。
现在，Phoenix已经提供了对HBase secondary index的支持。
二、全局索引和本地索引 2.1 Global Indexing
Global indexing，全局索引，适用于==读多写少==的业务场景。
使用Global indexing在写数据的时候开销很大，因为所有对数据表的更新操作（DELETE, UPSERT VALUES and UPSERT SELECT），都会引起索引表的更新，而索引表是分布在不同的数据节点上的，跨节点的数据传输带来了较大的性能消耗。
在读数据的时候Phoenix会选择索引表来降低查询消耗的时间。
在默认情况下如果想查询的字段不是索引字段的话索引表不会被使用，也就是说不会带来查询速度的提升。
2.2 Local Indexing
Local indexing，本地索引，适用于==写操作频繁==以及空间受限制的场景。
与Global indexing一样，Phoenix会自动判定在进行查询的时候是否使用索引。
使用Local indexing时，索引数据和数据表的数据存放在相同的服务器中，这样避免了在写操作的时候往不同服务器的索引表中写索引带来的额外开销。
使用Local indexing的时候即使查询的字段不是索引字段索引表也会被使用，这会带来查询速度的提升，这点跟Global indexing不同。对于Local Indexing，一个数据表的所有索引数据都存储在一个单一的独立的可共享的表中。
三、可变索引和不可变索引 3.1 immutable index
immutable index，不可变索引，适用于数据==只增加不更新并且按照时间先后顺序存储==（time-series data）的场景，如保存日志数据或者事件数据等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a2b651132d3f0766bb1d43e10b8c77b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cafb3603b14a1d1b269f1b170693cee/" rel="bookmark">
			策略设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现实生活中我们到商场买东西的时候，卖场往往根据不同的客户制定不同的报价策略，比如针对新客户不打折扣，针对老客户打9折，针对VIP客户打8折...
现在我们要做一个报价管理的模块，简要点就是要针对不同的客户，提供不同的折扣报价。
如果是有你来做，你会怎么做？
我们很有可能写出下面的代码：
public class QuoteManager { public BigDecimal quote(BigDecimal originalPrice,String customType){ if ("新客户".equals(customType)) { System.out.println("抱歉！新客户没有折扣！"); return originalPrice; }else if ("老客户".equals(customType)) { System.out.println("恭喜你！老客户打9折！"); originalPrice = originalPrice.multiply(new BigDecimal(0.9)).setScale(2,BigDecimal.ROUND_HALF_UP); return originalPrice; }else if("VIP客户".equals(customType)){ System.out.println("恭喜你！VIP客户打8折！"); originalPrice = originalPrice.multiply(new BigDecimal(0.8)).setScale(2,BigDecimal.ROUND_HALF_UP); return originalPrice; } //其他人员都是原价 return originalPrice; } } 经过测试，上面的代码工作的很好，可是上面的代码是有问题的。上面存在的问题：把不同客户的报价的算法都放在了同一个方法里面，使得该方法很是庞大(现在是只是一个演示，所以看起来还不是很臃肿)。
下面看一下上面的改进，我们把不同客户的报价的算法都单独作为一个方法
public class QuoteManagerImprove { public BigDecimal quote(BigDecimal originalPrice, String customType){ if ("新客户".equals(customType)) { return this.quoteNewCustomer(originalPrice); }else if ("老客户".equals(customType)) { return this.quoteOldCustomer(originalPrice); }else if("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cafb3603b14a1d1b269f1b170693cee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4320a5c26e060019f606174f36137d6c/" rel="bookmark">
			java中的BigDecimal和Integer，Long
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 BigDecimalInteger类型ID用long还是Long？ java基础学的不是太好，补补课把
Java中数据类型分两种：
1.基本类型：long,int,byte,float,double
2.对象类型：Long,Integer,Byte,Float,Double其它一切java提供的，或者你自己创建的类。
其中Long叫 long的包装类。Integer、Byte和Float也类似，一般包装类的名字首写是数值名的大写开头。
BigDecimal 定义
BigDecimal a=new BigDecimal(String; val) BigDecimal a=new BigDecimal(double val); 应用场景
一般使用BigDecimal来解决商业运算上丢失精度的问题
Integer类型 应用场景
容器里推荐用Integer。 对于PO实体类，如果db里int型字段允许null，则属性应定义为Integer。
当然，如果系统限定db里int字段不允许null值，则也可考虑将属性定义为int。
int是java提供的8种原始类型之一，java为每个原始类型提供了封装类，Integer是int的封装类。int默认值是0，而Integer默认值是null；
定义
Integer a=new Integer(int value); Integer a=new Integer(String value); 转换
i.定义中就可以将int型和String型的转换为Integer型
ii. String类型转换为Integer型
Integer.valueOf("");
Integer.getInteger("");
iii.String、Integer类型转换为int型
Integer.parseInt("");
Integer a;
a.intValue();
iv.上面定义的Integer a转换为float, double, long
a.floatValue();
a.doubleValue();
a.longValue();
v.Integer a转换为String(其它的类型转换为String都可通用以下方法)
toString();
String.valueOf(a);
ID用long还是Long？ 到底是选择Long
还是long这个还得看具体环境，如果你认为这个属性不能为null,那么就用long，因为它默认初值为0，如果这个字段可以为null，那么就应该选择Long。
参考
Java常用类型(Integer,BigDecimal)定义、转换及比较
Java中的BigDecimal类和int和Integer总结
java 常用的几种数据类型转换
菜鸟学Java——你知道long和Long有什么区别吗？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61e236098e9f30a748e7f18da3ed58ed/" rel="bookmark">
			Pgrep命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【语法】
pgrep(选项)(参数)
【选项】
-o：仅显示找到的最小（起始）进程号；
-n：仅显示找到的最大（结束）进程号；
-l：显示进程名称；
-P：指定父进程号；
-g：指定进程组；
-t：指定开启进程的终端；
-u：指定进程的有效用户ID。
【参数】
进程名称：指定要查找的进程名称，同时也支持类似grep指令中的匹配模式。
pstree:查看进程树
安装pstree命令:yum -y install psmisc pstree -aup :以树形结构显示进程信息 -a :显示完整信心
-u :列出对应 用户名
-p :列出对应PID号
进程的启动方式:
*手工启动:
前台启动:用户输入命令,直接执行程序
后台启动:在命令行尾加入"&amp;"符号
jobs:查看后台运行的程序
jobs -L :查看当前终端中后台运行的进程任务
Ctrl + z :后台挂起
Ctrl + c :结束正在执行的命令
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/497f7715368575ec1ffeed0be9c50100/" rel="bookmark">
			新建HttpServletRequest对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 新建HttpServletRequest 1、导入的包： import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; 2、获取HttpServletRequest对象： HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); HttpSession session = request.getSession(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd1e78485640f18285df8538c76bc00b/" rel="bookmark">
			Yarn在运行时报错error handling URI: /cluster org.eclipse.jetty.io.RuntimeIOException: org.eclipse.jetty.io
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Yarn运行的application的日志中发现有规律的错误日志
影响：并没有影响服务，application正常处理数据。
日志现状：
1-- 两个时间点。每个时间点往后间隔1分钟会有相同错误日志。
2-- 不是每次间隔都会有(即使1分钟的整数倍，有时候2分钟，有时候4分钟)。
日志内容：
2020-07-01 10:05:43,497 ERROR webapp.Dispatcher (Dispatcher.java:service(171)) - error handling URI: /cluster org.eclipse.jetty.io.RuntimeIOException: org.eclipse.jetty.io.EofException at org.eclipse.jetty.server.ResponseWriter.isOpen(ResponseWriter.java:133) at org.eclipse.jetty.server.ResponseWriter.println(ResponseWriter.java:314) at org.apache.hadoop.yarn.webapp.hamlet2.HamletImpl$EImp._p(HamletImpl.java:110) at org.apache.hadoop.yarn.webapp.hamlet2.Hamlet$SCRIPT.__(Hamlet.java:457) at org.apache.hadoop.yarn.server.resourcemanager.webapp.RMAppsBlock.renderData(RMAppsBlock.java:194) at org.apache.hadoop.yarn.server.webapp.AppsBlock.render(AppsBlock.java:145) at org.apache.hadoop.yarn.webapp.view.HtmlBlock.render(HtmlBlock.java:69) at org.apache.hadoop.yarn.webapp.view.HtmlBlock.renderPartial(HtmlBlock.java:79) at org.apache.hadoop.yarn.webapp.View.render(View.java:243) at org.apache.hadoop.yarn.webapp.view.HtmlBlock$Block.subView(HtmlBlock.java:43) at org.apache.hadoop.yarn.webapp.hamlet2.Hamlet.__(Hamlet.java:30354) at org.apache.hadoop.yarn.server.resourcemanager.webapp.AppsBlockWithMetrics.render(AppsBlockWithMetrics.java:29) at org.apache.hadoop.yarn.webapp.view.HtmlBlock.render(HtmlBlock.java:69) at org.apache.hadoop.yarn.webapp.view.HtmlBlock.renderPartial(HtmlBlock.java:79) at org.apache.hadoop.yarn.webapp.View.render(View.java:243) at org.apache.hadoop.yarn.webapp.view.HtmlPage$Page.subView(HtmlPage.java:49) at org.apache.hadoop.yarn.webapp.hamlet2.HamletImpl$EImp._v(HamletImpl.java:117) at org.apache.hadoop.yarn.webapp.hamlet2.Hamlet$TD.__(Hamlet.java:848) at org.apache.hadoop.yarn.webapp.view.TwoColumnLayout.render(TwoColumnLayout.java:71) at org.apache.hadoop.yarn.webapp.view.HtmlPage.render(HtmlPage.java:82) at org.apache.hadoop.yarn.webapp.Dispatcher.render(Dispatcher.java:206) at org.apache.hadoop.yarn.webapp.Dispatcher.service(Dispatcher.java:165) at javax.servlet.http.HttpServlet.service(HttpServlet.java:790) at com.google.inject.servlet.ServletDefinition.doServiceImpl(ServletDefinition.java:287) at com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd1e78485640f18285df8538c76bc00b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1189009c6ee5dd1b83878fd942370723/" rel="bookmark">
			python学习笔记3——字典-当索引行不通时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要将一系列值组合成数据结构并通过编号来访问各个值时，列表很有用。当通过名称来访问其各个值的时候，此时的数据结构称为映射（mapping）。字典是Python中唯一的内置映射类型，其中的值不按顺序排列，而是存储在键下。键可能是数、字符串或元组。
1. 字典的用途 下面是Python字典的一些用途： ❑ 表示棋盘的状态，其中每个键都是由坐标组成的元组；
❑ 存储文件修改时间，其中的键为文件名；
❑ 数字电话/地址簿。
2. 创建和使用字典 &gt;&gt;&gt; phonebook={'Alice':'1111', 'beth':'2222', 'Cecil':'3528'} 字典由键及其相应的值组成，这种键-值对称为项（item）。在上面的示例中，键为名字，而值为电话号码。每个键与其值之间都用冒号（:）分隔，项之间用逗号分隔，而整个字典放在花括号内。
2.1 函数dict 使用函数dict[插图]从其他映射（如其他字典）或键-值对序列创建字典。
&gt;&gt;&gt; item = [('name', 'Gumby'), ('age', 42)] &gt;&gt;&gt; d = dict(item) &gt;&gt;&gt; d {'name': 'Gumby', 'age': 42} 还可使用关键字实参来调用这个函数
&gt;&gt;&gt; d = dict(name ='gumb;y', age = 42) &gt;&gt;&gt; d {'name': 'gumb;y', 'age': 42} 2.2 字典的基本操作 字典的基本行为在很多方面都类似于序列。
❑ len(d)返回字典d包含的项（键-值对）数。
❑ d[k]返回与键k相关联的值。
❑ d[k] = v将值v关联到键k。
❑ del d[k]删除键为k的项。
❑ k in d检查字典d是否包含键为k的项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1189009c6ee5dd1b83878fd942370723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a66e42f59acae2adc676a37d93aab6c/" rel="bookmark">
			Leetcode 链表加法模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。
给定两个这种链表，请生成代表两个整数相加值的结果链表。
例如：链表 1 为 9-&gt;3-&gt;7，链表 2 为 6-&gt;3，最后生成新的结果链表为 1-&gt;0-&gt;0-&gt;0。
示例1
输入 复制
[9,3,7],[6,3] 输出 复制
{1,0,0,0} 思路：
由于链表末尾才表示数的最低位，因此传统遍历方式不行，采取递归的思路，核心实现：
等长链表的相加，返回最终进位，操作在原先链表（不增加额外空间）多余链表与单个数字的相加 易错点：
先将长链表断开，完成等长链表相加
完成剩余链表进位
最终勾连完整链表
等长链表的相加以及单链表与数字相加，返回最终进位
//等长链表相加，相加到head1 返回相加后进位大小 int add1(ListNode* head1,ListNode* head2) { if(head1==NULL &amp;&amp; head2==NULL) return 0; int sum=(head1-&gt;val+head2-&gt;val+add1(head1-&gt;next,head2-&gt;next)); head1-&gt;val=sum%10;//当前位 统一累加到List1中 return sum/10;//进位 } //在一条原先的链表基础上，添加一个数字 int add2(ListNode* head1,int value) { if(head1==NULL) return value; int sum=head1-&gt;val+add2(head1-&gt;next,value); head1-&gt;val=sum%10; return sum/10;//进位 } 核心算法，先求解链表长度，在调用，注意最终进位需要额外创建一个节点：
ListNode* addInList(ListNode* head1, ListNode* head2) { int l1=0; ListNode* p=head1; while(p) { l1++; p=p-&gt;next; } int l2=0; p=head2; while(p) { l2++; p=p-&gt;next; } //获得两者的大小长度 if(l1==l2) { int add=add1(head1,head2); if(add&gt;0) //还有进位 { ListNode* pre=new ListNode(add); pre-&gt;next=head1; return pre; } else { return head1;//返回累加后的head1 } } else if(l1&lt;l2) { p=head2; for(int i=0;i&lt;l2-l1-1;i++) p=p-&gt;next; ListNode* new_head2=p-&gt;next; int add=add1(new_head2,head1);//后面等长部分先累加 p-&gt;next=NULL;//断开 add=add2(head2,add);//剩余的串与add累加 p-&gt;next=new_head2; if(add&gt;0) //还有进位 { ListNode* pre=new ListNode(add); pre-&gt;next=head2; return pre; } else { return head2;//返回累加后的head1 } } else{ p=head1; for(int i=0;i&lt;l1-l2-1;i++) // p=p-&gt;next; ListNode* new_head1=p-&gt;next; int add=add1(new_head1,head2);//后面等长部分先累加 p-&gt;next=NULL;//断开 add=add2(head1,add);//剩余的串与add累加 p-&gt;next=new_head1;//重新狗链 if(add&gt;0) //还有进位 { ListNode* pre=new ListNode(add); pre-&gt;next=head1; return pre; } else { return head1;//返回累加后的head1 } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21b618738ff01f03c3e807644dc77f60/" rel="bookmark">
			opencv for java 遮挡检测（适用于图片像素较小）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新手
因为此代码用到了驾驶室内的摄像头分析，所以图片像素较小，运行速率影响较小。
若图片像素很大，这方案运行速率影响很大，不建议使用。
//首先是第一层检测，用灰度与边缘检测，分四个方向进行了检测 public boolean detect_Shelter(String image_path) { im = imread(image_path); Mat dst; Mat img_lefttop; Mat img_righttop; Mat img_leftbottom; Mat img_rightbottom; dst = new Mat(); Mat test = new Mat(); cvtColor(im, dst,COLOR_RGB2GRAY); Canny(dst, test, 0, 255, 3); //这里的范围与阈值10都可根据自己的情况进行调整，下面四个方向的测试相同 Range rangerows = new Range(9,dst.rows()/5*3); Range rangecols = new Range(9,dst.cols()/5*3); img_lefttop=new Mat(test,rangerows,rangecols); //System.out.println("img_lefttop"+img_lefttop); if(Core.countNonZero(img_lefttop)&lt;10) { //因为第一层检测会导致大量的夜晚环境误报遮挡，所以需要第二层像素点检测。 if(detect_Shelter_RGB(im)) { return true; } } rangerows = new Range(9,dst.rows()/5*3); rangecols = new Range(dst.cols()/5*2-1,dst.cols()); img_righttop = new Mat(test, rangerows, rangecols); //System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21b618738ff01f03c3e807644dc77f60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/961dddec5bcef7f4bb18c808c4f16ec6/" rel="bookmark">
			去除Evaluation Warning : The document was created with Spire.PDF for Java.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去除Evaluation Warning : The document was created with Spire.PDF for Java. 最近项目中有一个需求需要把PDF文件添加页码，最终在网上找到了用Spire去添加的方法，但是比较尴尬的是会在页面的第一页加上Evaluation Warning : The document was created with Spire.PDF for Java.一段文字。最终通过网上找例子找到了解决办法，因为这段文字只出现在第一页，所以这里的处理方式是在文档创建时先添加一个空白页，最后再把空白页去掉，代码如下： 最近项目中有一个需求需要把PDF文件添加页码，最终在网上找到了用Spire去添加的方法，但是比较尴尬的是会在页面的第一页加上Evaluation Warning : The document was created with Spire.PDF for Java.一段文字。最终通过网上找例子找到了解决办法，因为这段文字只出现在第一页，所以这里的处理方式是在文档创建时先添加一个空白页，最后再把空白页去掉，代码如下： import java.awt.*; import java.awt.geom.Dimension2D; import java.awt.geom.Rectangle2D; import com.spire.pdf.PdfDocument; import com.spire.pdf.automaticfields.PdfCompositeField; import com.spire.pdf.automaticfields.PdfPageCountField; import com.spire.pdf.automaticfields.PdfPageNumberField; import com.spire.pdf.graphics.PdfBrushes; import com.spire.pdf.graphics.PdfStringFormat; import com.spire.pdf.graphics.PdfTextAlignment; import com.spire.pdf.graphics.PdfTrueTypeFont; import com.spire.pdf.graphics.PdfVerticalAlignment; /** * * @author changsp * 2020年6月4日 */ public class AddPdfPageNumbers { public static void main(String[] args) { //加载PDF文档 PdfDocument pdf = new PdfDocument(); pdf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/961dddec5bcef7f4bb18c808c4f16ec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dff596616d1c2c4bce1da2ab7d60400/" rel="bookmark">
			代码时间复杂度计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间复杂度公示：
下面分析一段代码：
2、3、4行每一行都需要1个单位的执行时间，5、6行循环了N边，需要2N个单位时间，7、8行执行了n^2遍，所以一共需要执行时间：（2N ^2 + 2N + 3 ）*单位时间。
我们用T(n) 表示，O表示T(n)与f(n)成正比（单位时间），所以表达式可以写成：T(n) = O(2N ^2 + 2N + 3 ) ,这就是大O时间复杂度表示法，由于N无穷大，所以只需要表示最大量级即可，即：T(n) = O(N ^2 )
时间复杂度分析： 1、只关注循环执行次数最多的一段代码；
2、加法法则：总复杂度等于量级最大的那段代码的复杂度；
例如：时间复杂度：T(n) = O(N+N ^2 ) = O（N ^2 ）
3、乘法法则：嵌套代码的复杂度等于嵌套内外代码的复杂度乘积；
例如：
以下算法时间复杂度为：T(n) = O(N X N)=O(N ^2 )
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/098fc16c30b91f1b37199949bc633af9/" rel="bookmark">
			GEO数据挖掘（学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GEO数据挖掘 1. GEO数据库简介2. 数据下载3. 数据质量检查4. ID转换5. 数据探索5.1 PCA分析5.2 hclust聚类5.3 limma包进行差异分析5.3.1 热图5.3.2 火山图 5.4 GO and KEGG 生信菜鸟一枚，记录下学习生信技能树GEO数据挖掘相关视频的学习笔记。
1. GEO数据库简介 NCBI Gene Expression Omnibus（GEO）是一个存储各种高通量实验数据的公共数据库。这些数据包括基于单通道和双通道微阵列的实验，检测mRNA，基因组DNA和蛋白质丰度，以及非阵列技术，如基因表达系列分析（SAGE），质谱蛋白质组学数据和高通量测序数据。网址如下：https://www.ncbi.nlm.nih.gov/geo/
2. 数据下载 gset是一个列表，里面拥有表达矩阵、分组信息、临床资料等等内容，
########################################### # GEO accession : GSE42872 # Platforms : GPL6244 # BioProject : PRJNA183688 ########################################## #####数据下载##### if(!require(GEOquery)) BiocManager::install("GEOquery") # 安装包 package.version("GEOquery") # 查看版本 help(package = "GEOquery") # 查看GEOquery中的函数 library(GEOquery) # 加载包 library(tidyverse) search() # 查看已加载R包 gset &lt;- getGEO('GSE42872',destdir = ".", AnnotGPL = F,getGPL = F)#下载GSE数据 save(gset,file = 'GSE42872.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/098fc16c30b91f1b37199949bc633af9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ffd013bb82b166cf129813594ec1ab6/" rel="bookmark">
			from bert import modeling,报错“module ‘bert‘ has no attribute ‘modeling‘”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：
tensorflow版本：2.21
查询方法：
import tensorflow as tf tf.__version__ bert安装方式：pip install bert
问题+解决方法
问题1.tensorflow的版本不匹配；
解决：将tensorflow的版本降低为1.15.0：
install tensorflow==1.15.0 -ihttp://pypi.douban.com/simple --trusted-host pypi.douban.com 解释：更新tensorflow版本时，采用了豆瓣的国内镜像，速度较快。
2.bert库的非tensorflow版本。
卸载bert库:pip uninstall bert
安装tensorflow的bert库：pip install bert-tensorflow.
总结
首先，检查是否是bert版本的问题，本人首先降低tensorflow的版本，从2.2.1-1.15.0-1.12.0,问题始终没有解决。
最后，将tensorflow的版本固定到1.15后，调整了bert的版本，问题解决。
参考博客
https://www.cnblogs.com/z-cm/p/13021569.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/466df358bac60b6113cd1095e5ad9290/" rel="bookmark">
			No such property: variantConfiguration for class: com.android.build.gradle.internal.variant.Applicat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集成bugly热修复的时候，在app module的“build.gradle”文件中添加：
// 依赖插件脚本
apply from: 'tinker-support.gradle' sync之后会报错 No such property: variantConfiguration for class: com.android.build.gradle.internal.variant.ApplicationVariantData
原因：是由于我的AS 项目根目录下用的gradle版本是
dependencies { classpath "com.android.tools.build:gradle:4.0.1" // tinkersupport插件, 其中lastest.release指拉取最新版本，也可以指定明确版本号，例如1.0.4 classpath "com.tencent.bugly:tinker-support:latest.release" } 改成：
dependencies { classpath 'com.android.tools.build:gradle:3.4.2' // tinkersupport插件, 其中lastest.release指拉取最新版本，也可以指定明确版本号，例如1.0.4 classpath "com.tencent.bugly:tinker-support:latest.release" } gradle-wrapper.properties 文件中：
distributionUrl=https\://services.gradle.org/distributions/gradle-6.1.1-all.zip 改为：
distributionUrl=https\://services.gradle.org/distributions/gradle-5.5-all.zip 然后再sync即可，这个应该是腾讯bugly sdk的bug了，一直还没修复。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecdb6211d179772b3e334e792e4e4128/" rel="bookmark">
			预测误差的自助法估计(Bootstrap estimate of prediction error)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bootstrap estimate of prediction error 1 一般方法2 改进方法1 - the more refined bootstrap approach3 改进方法2 - 0.632 bootstrap estimate4 结果参考书目 1 一般方法 定义一个测量误差的函数Q（表示的是响应变量 y y y和预测值 y ^ \hat{y} y^​之间的差异），对回归模型来说，一般选择平方损失函数，分类问题一般选择示性函数 Q = I ( y ≠ y ^ ) Q = I(y \neq \hat{y}) Q=I(y​=y^​)，在此，我们选择测量误差为负对数似然函数。
如果直接用原始数据进行估计，然后计算原始数据的负对数似然，这种误差称为“apparent error”。这种误差一般比较小，无法忽略掉过拟合的问题。所以对于预测误差的bootstrap estimate一般采用以下方法：
产生B个bootstrap samples，在每个样本上估计model,然后将模型应用到原始数据（original sample）,共产生B个预测误差，最终求平均值（prediction error）。 或者采用0.632 bootstrap estimator。
产生B个bootstrap samples 作为训练集，在原始数据中，训练集没有出现的样本作为测试集，在训练集上训练模型，并应用到测试集计算预测误差，共产生B个预测误差，求平均值。 2 改进方法1 - the more refined bootstrap approach 首先定义一个概念：“optimism”
o p t i m i s m = p r e d i c t i o n e r r o r − a p p a r e n t e r r o r optimism= prediction error - apparent error optimism=predictionerror−apparenterror
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecdb6211d179772b3e334e792e4e4128/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbfecacb19c019c4c98cf8351c9d3ffb/" rel="bookmark">
			mac 文件显示隐藏状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上面bai的方法都太low了
shift+command + . 切换文件的显示du和隐藏zhi
sudo chflags nohidden 文件 将文dao件设置成显示状态
sudo chflags hidden 文件 将文件设置成隐藏状态
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e63677dc490dba4586eb42414a86964f/" rel="bookmark">
			Android R0 Tethering source code
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/frameworks/base/core/java/android/net/ConnectivityManager.java 2481 public void startTethering(int type, boolean showProvisioningUi, 2482 final OnStartTetheringCallback callback) { 2483 startTethering(type, showProvisioningUi, callback, null); 2484 } 2486 /** 2487 * Runs tether provisioning for the given type if needed and then starts tethering if 2488 * the check succeeds. If no carrier provisioning is required for tethering, tethering is 2489 * enabled immediately. If provisioning fails, tethering will not be enabled. It also 2490 * schedules tether provisioning re-checks if appropriate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e63677dc490dba4586eb42414a86964f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8833f4fd2e8978f9bb1fc58e2b3e30e/" rel="bookmark">
			贝叶斯详细分析，详细例子解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 写在前面：
贝叶斯定理算是统计学中特别重要的了，像极大似然估计等一些重要的方法都是基于贝叶斯发展出来的，所以学好贝叶斯基本上可以认识到大半部分的统计知识，而且对数据分析的小伙伴面试有帮助额
一、定义事件A、B 先验概率 P(A)
后验概率P(A|B)
条件似然概率P(B|A)
B 的先验概率P(B)，一般称为标淮化常量
贝叶斯公式 P(AB)=P(A|B)*P(B) =P(B|A)*P(A)
通过上面的贝叶斯公式，我们可以发现，已知先验概率、后验概率、条件似然概率、标准化常量四个值中的三个，就可求另一个未知的值。基本上我们都是已知先验概率、后验概率和标准化常量，然后去求条件似然概率。
二、应用场景 这里举两个贝叶斯公式应用的例子，a题比较简单，b题是a题的升级版，涉及到一个先验概率的刷新，需要仔细去体会~，我会分步骤去介绍，求解过程。
a题. 一机器在良好状态生产合格产品几率是90%，在故障状态生产合格产品几率是30%，机器良好的概率是75%，若一日第一件产品是合格品，那么此日机器良好的概率是多少。
第一步： 定义事件，A : 机器良好；B : 第一件产品是合格品。确定问题是求解P(A|B)=?
第二步：P(A)=0.75
P(B|A)=0.9
P(B)=0.9*0.75+0.3*0.25=0.75
第三步：P(A|B)=P(B|A)*P(A)/P(B)=0.9
b题.一机器在良好状态生产合格产品几率是90%，在故障状态生产合格产品几率是30%，机器良好的概率是75%，若一日第一件和第二件产品都是合格品，那么此日机器良好的概率是多少。
分析发现b题中是两件产品是合格品，那么这里计算就要麻烦上一些了
第一步： 定义事件，A : 机器良好；B : 第一件产品是合格品；C:第二件产品也是合格品。确定问题是求解P(A|C)=?，（这里的描述可能有些问题，但请注意我说的是 C:第二件产品也是合格品，这里面就包含了第一件产品是合格品的信息）
第二步：P(A)=0.75
P(B|A)=0.9
P(B)=0.9*0.75+0.3*0.25=0.75
第三步：P(A|B)=P(B|A)*P(A)/P(B)=0.9
由于第一件产品是合格品，所以此时我们已经知道了机器完好的概率是0.9，而不在是0.75了，所以此时先验概率P(A)=P(A|B)=0.9
第四步：刷新先验概率 P(A)=0.9
P(C|A)=0.9
P(C)=P(C|A)*P(A)+P(C|~A)*P(~A)=0.9*0.9+0.3*0.1=0.84 注： ~A=1 - A
第五步：P(A|C)=P(C|A)*P(A)/P(C)=0.9*0.9/0.84=0.9643
三、更进一步的公式 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afcbdfecb2a600ec908d0d9175df5244/" rel="bookmark">
			PTP4L命令手册（谷歌翻译）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ptp4l-PTP边界/普通时钟 概要 ptp4l [-AEP246HSLmqsv] [-f config] [-p phc-device] [-l打印级别] [-i接口] ... 描述 ptp4l是根据Linux的IEEE标准1588的精确时间协议（PTP）的实现。它实现了边界时钟（BC）和普通时钟（OC）。 选项 -A自动选择延迟机制。从E2E开始，并在收到对等延迟请求时切换到P2P。 -E选择延迟请求-响应（E2E）机制。这是默认机制。单个PTP通信路径上的所有时钟必须使用相同的机制。当对等延迟请求被发出时，将打印警告。 使用端到端机制在端口上接收。 -P选择对等延迟（P2P）机制。当使用P2P机制在端口上收到延迟请求时，将打印警告。 -2选择IEEE 802.3网络传输。 -4选择UDP IPv4网络传输。这是默认传输方式。 -6选择UDP IPv6网络传输。 -H选择硬件时间戳。必须将-i选项指定的所有端口和配置文件中的所有端口连接到同一PTP硬件时钟（PHC）。这是默认时间戳。 -S选择软件时间戳。 -L选择旧硬件时间戳。 -f配置 从指定文件中读取配置。缺省情况下，不读取配置文件。 -i接口 指定一个PTP端口，它可以多次使用。此选项或配置文件中必须至少指定一个端口。 -p phc设备 使用硬件时间戳记，可以强制使用哪个PHC设备（例如/ dev / ptp0）。 -s启用slaveOnly模式。 -l打印级别 设置应该打印或发送到系统记录器的消息的最大系统日志级别。默认值为6（LOG_INFO）。 -m将消息打印到标准输出。 -q不要将消息发送到系统记录器。 -v打印软件版本并退出 -h显示帮助消息。 配置文件 配置文件分为几部分。每个部分均以包含其名称的一行开头，并带有括号。每个设置都放在单独的行上，其中包含 选项和由空格字符分隔的值。空行和以＃开头的行将被忽略。 全局部分（表示为[global]）设置程序选项，时钟选项和默认端口选项。其他部分是端口特定的部分，它们将覆盖默认端口选项。该部分的名称是 已配置端口的名称（例如[eth0]）。 -i选项无需指定配置文件中指定的端口。空端口部分可用于替换命令行选项。 端口选项 延迟不对称 传输路径和接收路径的时间差（以纳秒为单位）。当主机到从机的传播时间较长时，该值应为正；从机到主机的时间较长时，该值应为负。的 默认值为0纳秒。 logAnnounceInterval 公告消息之间的平均时间间隔。较短的时间间隔使ptp41对主从层次结构中的更改反应更快。在整个域中，间隔应相同。被指定为 两秒的幂。默认值为1（2秒）。 logSyncInterval 同步消息之间的平均时间间隔。较短的时间间隔可以提高本地时钟的准确性。指定为两秒的幂。默认值为0（1秒）。 logMinDelayReqInterval Delay_Req消息之间的最小允许平均时间间隔。较短的时间间隔使ptp41对路径延迟的变化反应更快。指定为两秒的幂。默认值为0（1 第二）。 logMinPdelayReqInterval Pdelay_Req消息之间的最小允许平均时间间隔。指定为两秒的幂。默认值为0（1秒）。 announceReceiptTimeout 在最后一条“公告”消息过期之前，错过的“公告”消息的数量。预设值为3。 syncReceiptTimeout 在触发“最佳主时钟”选择之前，可能丢失的同步/跟随消息的数量。此选项用于根据802.1AS-2011标准在gPTP模式下运行。将此选项设置为 零将禁用同步消息超时。默认值为0或禁用。 具体运输 运输特定领域。必须在0到255之间。默认值为0。 path_trace_enabled 启用用于跟踪通告消息路由的机制。默认值为0（禁用）。 follow_up_info 如果启用，则在Follow_Up消息中包括802.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afcbdfecb2a600ec908d0d9175df5244/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28484b0ed76b36e96d3b618316ee5019/" rel="bookmark">
			Springboot集成activiti6.0踩坑实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、springboot2.0集成activiti6.0 1.1引入jar包 &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring-boot-starter-basic&lt;/artifactId&gt; &lt;version&gt;6.0.0&lt;/version&gt; &lt;/dependency&gt; 1.2配置myibatis，生成28张表 spring: datasource: name: ecityposition type: com.alibaba.druid.pool.DruidDataSource filters: stat url: jdbc:mysql://localhost:3306/activiti?useUnicode=true&amp;nullCatalogMeansCurrent=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.jdbc.Driver username: root password: root activiti: database-schema-update: true #检测历史表是否存在 db-history-used: true #记录历史等级 可配置的历史级别有none, activity, audit, full history-level: full #校验流程文件，默认校验resources下的processes文件夹里的流程文件 check-process-definitions: false 二、设计bpmn 2.1创建bpmn 在resource目录下创建process文件夹，然后新建bpmn文件
2.2设计流程图 这里设计了一个最简单的请假流程
由于idea对编辑不太友好，我这里选择Camunda Modeler
2.3bpmn乱码问题 百度了很多，基本不解决问题。
但是这个方法解决了我的问题：
help–&gt;edit custom vm… 添加-Dfile.encoding=UTF-8
三、启动流程并进行简单测试 如果数据库出现28张表，就表明已经集成成功。
3.1部署流程 @Test public void prepare() { ProcessEngine processEngine= ProcessEngines.getDefaultProcessEngine(); RepositoryService repositoryService = processEngine.getRepositoryService(); Deployment deployment = repositoryService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28484b0ed76b36e96d3b618316ee5019/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c998a96f5342893c7d9f06f3c6d92ee/" rel="bookmark">
			数据挖掘标准流程CRISP-DM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先说一下KDD模型的概念 知识发现（KDD：Knowledge Discovery in Database）是从数据集中识别出有效的、新颖的、潜在有用的，以及最终可理解的模式的非平凡过程。知识发现将信息变为知识，从数据矿山中找到蕴藏的知识金块，将为知识创新和知识经济的发展作出贡献。
这里不得不提一下数据挖掘的概念，数据挖掘（英语：Data mining），又译为资料探勘、数据采矿。它是KDD中的一个步骤。数据挖掘一般是指从大量的数据中通过算法搜索隐藏于其中信息的过程。数据挖掘通常与计算机科学有关，并通过统计、在线分析处理、情报检索、机器学习、专家系统（依靠过去的经验法则）和模式识别等诸多方法来实现上述目标。
数据挖掘利用了来自如下一些领域的思想：(1) 来自统计学的抽样、估计和假设检验，(2)人工智能、模式识别和机器学习的搜索算法、建模技术和学习理论。数据挖掘也迅速地接纳了来自其他领域的思想，这些领域包括最优化、进化计算、信息论、信号处理、可视化和信息检索。一些其他领域也起到重要的支撑作用。特别地，需要数据库系统提供有效的存储、索引和查询处理支持。源于高性能（并行）计算的技术在处理海量数据集方面常常是重要的。分布式技术也能帮助处理海量数据，并且当数据不能集中到一起处理时更是至关重要。
2、跨行业数据挖掘标准流程 CRISP-DM (cross-industry standard process for data mining), 即为"跨行业数据挖掘标准流程"，CRISP-DM 模型是KDD模型的一种，最近几年在各种KDD过程模型中占据领先位置，它是由戴姆勒-克莱斯勒、SPSS和NCR的分析人员共同开发的。CRISP提供了一种开放的、可自由使用的数据挖掘标准过程，使数据挖掘适合于商业或研究单位的问题求解策略。
如图流程图
CRISP-DM为一个KDD工程或者说是一个数据挖掘项目提供了一个完整的过程描述。它把这个过程定义为六个标准阶段，分别是商业理解、数据理解、数据准备、建立模型、模型评估和模型发布，以下分别加以简介：
(一)商业理解阶段 商业理解也可以说是业务/研究理解的并确定分析目标的一个阶段。
首先明确目标：明确要达到的业务目标，并将其转化为数据挖掘主题。
其次转换数据挖掘定义：要从商业角度对业务部门的需求进行理解，并把业务需求的理解转化为数据挖掘的定义，拟定达成业务目标的初步方案。具体包括商业背景分析、商业成功标准的确定、形势评估、获得企业资源清单、获得企业的要求和设想、评估成本和收益、评估风险和意外、初步理解行业术语。
最后确定目标与策略：确定数据挖掘的目标和制定数据挖掘计划。
确定商业目标：明确商业背景、商业目标、可衡量的成功标准评估环境：明确企业资源、需求、约束，风险，沟通，成本代价分析确定数据挖掘目标：明确目标以及可衡量的成功标准制定项目计划 (二)数据理解阶段 首先收集数据：找出可能的影响主题的因素，确定这些影响因素的数据载体、数据体现形式和数据存储位置。
其次熟悉数据，具体包括以下工作内容:检测数据质量，对数据进行初步理解，简单描述数据，探测数据意义，
最后提前数据：分析数据中潜藏的信息和知识提出拟用数据加以验证的假设。
收集原始数据：撰写数据收集报告（充分理解数据来源，注意数据集有效时间）描述数据：数据描述报告探索数据：数据探索报告检验数据质量：数据质量报告 (三)数据准备阶段 数据准备是将前面找到的数据进行变换、组合，建立数据挖掘工具软件要求格式和内容的宽表。数据准备阶段要从原始数据中形成作为建模分析对象的最终数据集。数据准备阶段的具体工作主要包括数据制表、记录处理、变量选择、数据转换、数据格式化和数据清理等，各项工作并不需要预先规定好执行顺序，而且数据准备工作还有可能多次执行。
数据准备：数据集和数据集描述选择数据：包含/排除数据的准则清洗数据：数据清洗报告，一定要记录数据清洗方法构造数据：派生属性，数据转化、离散、产生新纪录化等等整合数据：合并数据，匹配数据格式化数据：去量纲等 (四)建立模型阶段 建立模型是应用软件工具，选择合适的建模方法，处理准备好的数据表，找出数据中隐藏的规律。在建立模型阶段，将选择和使用各种建模方法，并将模型参数进行优化。对同样的业务问题和数据准备，可能有多种数据挖掘技术方法可供选用，此时可优选提升度高、置信度高、简单而易于总结业务政策和建议的数据挖掘技术方法。在建模过程中，还可能会发现一些潜在的数据问题，要求回到数据准备阶段。建立模型阶段的具体工作包括:选择合适的建模技术、进行检验设计、建造模型。
选择建模技术：建模算法，模型建立生成测试设计：撰写测试设计文档生成模型：使用的参数、模型以及模型描述模型评价: 评估模型并完善参数 (五)模型评估阶段 模型评估是要从业务角度和统计角度进行模型结论的评估。要求检查建模的整个过程，以确保模型没有重大错误，并检查是否遗漏重要的业务问题。当模型评估阶段结束时，应对数据挖掘结果的发布计划达成一致。
结果评价：依据商业成功标准评价模型结果、审核模型过程在检验：审核模型建立过程后续阶段检验：最终决定 (六)模型发布阶段 模型发布又称为模型部署，建立模型本身并不是数据挖掘的目标，虽然模型使数据背后隐藏的信息和知识显现出来，但数据挖掘的根本目标是将信息和知识以某种方式组织和呈现出来，并用来改善运营和提高效率。当然，在实际的数据挖掘工作中，根据不同的企业业务需求，模型发布的具体工作可能简单到提交数据挖掘报告，也可能复杂到将模型集成到企业的核心运营系统中去。
树立执行计划：部署计划树立调控/维持计划：计划书编写最终报告书：得到最终报告或陈述项目再检验：经验文档 总结 Crisp-DM标准流程：
商业理解（行业）-&gt;数据理解（关系）-&gt;数据准备（质量）-&gt;建立模型（算法）-&gt;模型评估（标准）-&gt;发布模型
合理的翻译一个挖掘主题：业务问题-&gt;数据问题-&gt;数据模型-&gt;解决方案 (沟通能力+表达能力+理解能力+建模能力)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c32118f20760d2296c4ccbe6541140e/" rel="bookmark">
			SpringBoot项目如何访问jsp页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、pom.xml中引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、application.properties 中 指定视图 spring.mvc.view.prefix=/WEB-INF/jsp/ spring.mvc.view.suffix=.jsp 3、创建src/main/webapp 目录并在该目录创建jsp 添加的路径位置 和jsp内容： 4、创建访问jsp页面的Controller @Controller public class ExcelController { /* * 进入jsp页面 */ @RequestMapping("/index") public String html(){ return "index"; } } 5完成！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad88248ea34fca5d54fbe5dab66190ca/" rel="bookmark">
			【css外边距塌陷】外边距合并问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.父子元素之间的外边距margin合并问题(外边距塌陷)
&lt;!-- 结构 --&gt; &lt;div class="box"&gt; &lt;div class="b1"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 样式 --&gt; .box { width: 800px; height: 500px; background-color: orange; } .b1 { margin-top: 20px; width: 200px; height: 200px; background-color: purple; } 解决方法：
父元素添加代码段：
/*border: 1px solid transparent; !*方法1*!*/ /*float: left; !*方法2*!*/ /*position: absolute; !*方法3*!*/ /*padding: 1px; !*方法4*!*/ /*display: inline-block; !*方法5*!*/ /*overflow: hidden; !*方法6*!*/ /*overflow: auto; !*方法7*!*/ 2.兄弟元素之间的外边距合并问题
&lt;!--结构--&gt; &lt;div class="box1"&gt; &lt;div class="b2"&gt;&lt;/div&gt; &lt;div class="b3"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!--样式--&gt; .b2, .b3 { width: 100px; height: 100px; border: 1px solid #ccc; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad88248ea34fca5d54fbe5dab66190ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a92ccda011455efd4ab8f2b31a57dfc0/" rel="bookmark">
			echarts市级区域地图数据展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、原理 引用对应市区json数据（比如我就是引用的河南省驻马店市的数据），通过百度地图坐标拾取器获取地区的经纬度，将数据填在对应位置（我下面有注释），再配置下样式颜色之类的渲染上就可以了
二、看图片可能感受不大，下面是我echarts社区的主页，里面有这个例子，大家可以去看看效果 我的echarts个人主页
三、效果图 四、直接上代码，解释在注释里 &lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript" src = "jquery-3.4.1.js的路径"&gt;&lt;/script&gt; &lt;script type="text/javascript" src = "echarts.js的路径"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="map" style="width: 1200px;height:900px;"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var dom = document.getElementById("map"); //得到echarts的实例对象 var myChart = echarts.init(dom); //根据百度地图坐标拾取器来的经纬度 var geoCoordMap = { '遂平县': [114.015819, 33.150944], '上蔡县': [114.276256, 33.267906], '西平县': [114.022143, 33.394355], "驿城区": [114.006045, 32.978599], '确山县': [114.033641, 32.810768], "泌阳县": [113.335694, 32.731107], "汝南县": [114.375141, 33.016389], "正阳县": [114.398138, 32.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a92ccda011455efd4ab8f2b31a57dfc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24dff2f44561f4cdac8f97cc178eff5e/" rel="bookmark">
			上亿数据如何秒查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实战：上亿数据如何秒查
最近在忙着优化集团公司的一个报表。优化完成后，报表查询速度有从半小时以上(甚至查不出)到秒查的质变。从修改SQL查询语句逻辑到决定创建存储过程实现，花了我3天多的时间，在此总结一下，希望对朋友们有帮助。
数据背景
首先项目是西门子中国在我司实施部署的MES项目，由于项目是在产线上运作(3 years+)，数据累积很大。在项目的数据库中，大概上亿条数据的表有5个以上，千万级数据的表10个以上，百万级数据的表，很多…
(历史问题，当初实施无人监管，无人监控数据库这块的性能问题。ps:我刚入职不久…)
不多说，直接贴西门子中国的开发人员在我司开发的SSRS报表中的SQL语句：
select distinct b.MaterialID as matl_def_id, c.Descript, case when right(b.MESOrderID, 12) &lt; ‘001000000000’ then right(b.MESOrderID, 9)
else right(b.MESOrderID, 12) end as pom_order_id, a.LotName, a.SourceLotName as ComLot,
e.DefID as ComMaterials, e.Descript as ComMatDes, d.VendorID, d.DateCode,d.SNNote, b.OnPlantID,a.SNCUST
from
(
select m.lotname, m.sourcelotname, m.opetypeid, m.OperationDate,n.SNCUST from View1 m
left join co_sn_link_customer as n on n.SNMes=m.LotName
where
( m.LotName in (select val from fn_String_To_Table(@sn,’,’,1)) or (@sn) = ‘’) and
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24dff2f44561f4cdac8f97cc178eff5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/972689ebce1cf8661da249aa25fa1435/" rel="bookmark">
			redis——key命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 命令意义del keyword删除记录exists jihe判断是否存在这个key,存在1 不存在返回0explre jihe 5设置过期时间5秒EXPLREAT Jihe Unix 时间戳设置记录的过期时间move keyword 1把记录迁移到其他逻辑库rename keyword tmp把keyword改为tmpselect 1切换逻辑库（16个库）persist keyword移除过期时间type 800判断数据类型 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e03ddb62e8c867f4d62bf8c2b86ba96b/" rel="bookmark">
			arxiv打不开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cornel University提供支持的原访问地址：https://arxiv.org
国内中科院镜像的地址：cn.arxiv.org
注意前面没有http:// 否则打不开。
在原网站找到文章后，可以把http://替换为cn.
如：cn.arxiv.org/pdf/1710.06081v2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b606cdc8b877fe3b4103e429a1d8e67b/" rel="bookmark">
			Springboot下的WebRequest获取Requestbody参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：因为RequestBody是以流的形式读取，流读取一次以后就没有了，所以HttpServletRequest 的 getInputStream() 和 getReader() 都只能读取一次。如果想要通过WebRequst再次获取RequestBody中的参数，首先需将RequestBody保存，然后通过自定义HttpServletRequestWrapper类，重写当中getReader()和getInputStream()方法；然后再通过Filter中将ServletRequest替换为自定的HttpServletRequestWrapper
一、自定义HttpServletRequestWrapper类 1. CustomizeHttpServletRequestWrapper.java
package com.zsx.http; import lombok.extern.slf4j.Slf4j; import javax.servlet.ReadListener; import javax.servlet.ServletInputStream; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletRequestWrapper; import java.io.*; @Slf4j public class CustomizeHttpServletRequestWrapper extends HttpServletRequestWrapper { private byte[] buffer = {}; /** * Constructs a request object wrapping the given request. * * @param request The request to wrap * @throws IllegalArgumentException if the request is null */ public CustomizeHttpServletRequestWrapper(HttpServletRequest request) { super(request); log.info("=========CustomizeHttpServletRequestWrapper.CustomizeHttpServletRequestWrapper()========="); try { InputStream is = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b606cdc8b877fe3b4103e429a1d8e67b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5738a4a772b347361df0ae7f5129ff9/" rel="bookmark">
			LSTM模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LSTM模型 一：简介：
LSTM模型,是循环神经网络的一种变体,可以很有效的解决简单循环神经网络的梯度爆炸或消失问题。
二：优缺点：
优点：改善了RNN中存在的长期依赖问题；LSTM的表现通常比时间递归神经网络及隐马尔科夫模型（HMM）更好；作为非线性模型，LSTM可作为复杂的非线性单元用于构造更大型深度神经网络。
缺点：一个缺点是RNN的梯度问题在LSTM及其变种里面得到了一定程度的解决，但还是不够。它可以处理100个量级的序列，而对于1000个量级，或者更长的序列则依然会显得很棘手；另一个缺点是每一个LSTM的cell里面都意味着有4个全连接层(MLP)，如果LSTM的时间跨度很大，并且网络又很深，这个计算量会很大，很耗时。
三：代码实现
from keras.datasets import mnist #加载数据 (x_train, y_train), (x_test, y_test) = mnist.load_data() print('x_train.shape:',x_train.shape) print('x_test.shape:',x_test.shape) 输出： ('x_train.shape:', (60000, 28, 28)) ('x_test.shape:', (10000, 28, 28)) #时间序列数量 n_step = 28 #每次输入的维度 n_input = 28 #分类类别数 n_classes = 10 #将数据转为28*28的数据（n_samples,height,width） x_train = x_train.reshape(-1, n_step, n_input) x_test = x_test.reshape(-1, n_step, n_input) x_train = x_train.astype('float32') x_test = x_test.astype('float32') #标准化数据，因为像素值在0-255之间，所以除以255后数值在0-1之间 x_train /= 255 x_test /= 255 #y_train，y_test 进行 one-hot-encoding，label为0-9的数字，所以一共10类 y_train = keras.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5738a4a772b347361df0ae7f5129ff9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21ec93c8c69d9523a3ebf4db9b182ef0/" rel="bookmark">
			mmcv安装卸载：ModuleNotFoundError: No module named 或者 WARNING: Skipping mmcv as it is not installed.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 运行mmdetection时：
报错提示：
Traceback (most recent call last): File "tools/test.py", line 12, in &lt;module&gt; from mmdet.apis import multi_gpu_test, single_gpu_test File "d:\a文件盘\a项目\cv\mmdetection-master\mmdet\__init__.py", line 25, in &lt;module&gt; f'MMCV=={mmcv.__version__} is used but incompatible. ' \ AssertionError: MMCV==1.1.0 is used but incompatible. Please install mmcv&gt;=1.0.5, &lt;=1.0.5. mmcv 版本需要为1.0.5，而自己默认安装的是1.1.0版本的。
先卸载mmcv
pip uninstall mmcv pip uninstall mmcv-full 再安装mmcv版本为1.0.5：
pip install mmcv==1.0.5 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9adb813ef222f1820c238a0a80974a71/" rel="bookmark">
			SE模块详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下图表示一个SE 模块。主要包含Squeeze和Excitation两部分。W，H表示特征图宽，高。C表示通道数，输入特征图大小为W×H×C。
1、压缩（Squeeze）
第一步是压缩（Squeeze）操作，如下图所示
这个操作就是一个全局平均池化（global average pooling）。经过压缩操作后特征图被压缩为1×1×C向量。
2、激励（Excitation）
接下来就是激励（Excitation）操作，如下图所示
由两个全连接层组成，其中SERatio是一个缩放参数，这个参数的目的是为了减少通道个数从而降低计算量。
第一个全连接层有C*SERatio个神经元，输入为1×1×C，输出1×1×C×SERadio。
第二个全连接层有C个神经元，输入为1×1×C×SERadio，输出为1×1×C。
3、scale操作
最后是scale操作，在得到1×1×C向量之后，就可以对原来的特征图进行scale操作了。很简单，就是通道权重相乘，原有特征向量为W×H×C，将SE模块计算出来的各通道权重值分别和原特征图对应通道的二维矩阵相乘，得出的结果输出。
这里我们可以得出SE模块的属性：
参数量 = 2×C×C×SERatio
计算量 = 2×C×C×SERatio
总体来讲SE模块会增加网络的总参数量，总计算量，因为使用的是全连接层计算量相比卷积层并不大，但是参数量会有明显上升，所以MobileNetV3-Large中的总参数量比MobileNetV2多了2M。
4、MobileNet中的SE模块
SE模块的使用是很灵活的，可以在已有网络上添加而不打乱网络原有的主体结构。
ResNet中添加SE模块形成SE-ResNet网络，SE模块是在bottleneck结构之后加入的，如下图左边所示。
MobileNetV3版本中SE模块加在了bottleneck结构的内部，在深度卷积后增加SE块，scale操作后再做逐点卷积，如上图右边所示。MobileNetV3版本的SERadio系数为0.25。使用SE模块后的MobileNetV3的参数量相比MobileNetV2多了约2M，达到5.4M，但是MobileNetV3的精度得到了很大的提升，在图像分类和目标检测中准确率都有明显提升。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94c9dbb1758849bddbe24b6202ee719b/" rel="bookmark">
			Android 性能优化(三)----ANR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 . 什么是ANR？ ANR(Application Not responding)， 应用程序无响应；主线程如果在规定时内没有处理完相应工作，就会出现ANR。# 系列文章目录
二 . ANR 产生的原因？ 只有UI线程阻塞才会发生ANR，发生ANR的根本原因有以下三种：
KeyDispatchTimeOut ：
View的按键事件或者触摸事件在特定的时间（5秒）内无法得到响应；BroadcaseTimeOut：
BroadcastReceiver的onReceiver()函数运行在主线程中，在特定的时间（10秒）内无法完成处理。ServiceTimeOut：
Service的各个生命周期函数在特定时间（20秒）内无法完成处理，这种比较少见。 从出现ANR的原因可以看出发生ANR之前的特定时间（5s, 10s, 20s）之内主线程很繁忙，在做耗时操作，Android中常见的耗时操作有哪些呢？
耗时操作： IO文件读写操作，会导致iowait负载较大;SQL语句， 当数据库内容太复杂太大时，会出现读写很慢的问题;Bitmap 位图的一些运算，比如毛玻璃等特效；等待系统GC垃圾回收，当App出现严重的内存泄漏时很容易出现这种ANR； 三 . 如果分析ANR ？ 在开始分析ANR之前我们应该学习一些必要的如下前提知识：
1. 如何获取ANR log 信息？ 在发生ANR的时候，系统会收集ANR相关的log：
会收集ANR相关的关键信息，ANR前后CPU使用情况，还会收集trace信息，trace记录了ANR时各个线程的执行情况
手动获取trace.txt: chmod 777 /data/anr adb pull data/anr/traces.txt ~/traces.txt 获取DropBox中的log traces.txt只保留最后一次发生ANR时的信息, android 2.2开始增加了DropBox功能, 保留历史上发生的所有ANR的log.
“/data/system/dropbox”是DB指定的文件存放位置.
日志保存的最长时间， 默认是3天.
#####2. 如何判断是否此段代码在主线程？
//方法一：使用 Looper 类判断 Looper.myLooper() != Looper.getMainLooper() //方法二：通过查看 Thread 类的当前线程 Thread.currentThread() == Looper.getMainLooper().getThread() #####3. 线程的状态：
ThreadState (defined at “dalvik/vm/thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94c9dbb1758849bddbe24b6202ee719b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff57db5ba32f1a51edab8d3a4ad4e9ac/" rel="bookmark">
			现代计算机图形学入门作业一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客仅用于个人记录学习历程，可能不适合他人阅读。
十分感谢闫大佬的视频，让我能从0开始学习图形学
所有图片都来自现代计算机图形学入门-闫令琪 第一次作业是填充模型变换和投影变换矩阵，按照课程视频的来就很简单。
要注意作业框架中的相机已经规定了相机看的方向是-z，上方向是y。
正交投影 正交投影是最好理解的，把整个场景移动到0，0，0的位置，随后压缩成一个222的立方体，再进行光栅化就得到了需要的画面，作业中不需要把物体移动到0，0，0位置，因为作业的框架是把相机永远置于0，0，0，物品随之移动保证相对位置。
投影矩阵 因为人眼看到的范围类似左边的图，但是要在屏幕上投影我们需要右边的矩形。因此要做一个挤压操作。
先规定
近平面上的所有点不变远平面所有点的z值不变远平面上的中心点不变 设相机位置到近平面距离为n到远平面距离为f
通过各种推到最后得到投影变化的矩阵
n, 0, 0, 0 0, n, 0, 0 0, 0, n+f, -n*f 0, 0, 1, 0 然后和正交投影一样压缩成标准立方体
r:右面x坐标
l:左面x坐标
t:顶部y坐标
b:底部y坐标
投影矩阵的代码
(8.22更新，发现原来的代码里忘记把宽高比写进去，eye_pov的角度忘记除以2.导致出来的图偏小)
Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar) { Eigen::Matrix4f projection = Eigen::Matrix4f::Identity(); // TODO: Implement this function // Create the projection matrix for the given parameters. // Then return it. float tb = tan(radian(eye_fov/2))*fabs(zNear)*2; float rl = tb*aspect_ratio; float nf = zFar - zNear; Eigen::Matrix4f persp; persp &lt;&lt; zNear, 0, 0, 0, 0, zNear, 0, 0, 0, 0, zNear+zFar, -zNear*zFar, 0, 0, 1, 0; Eigen::Matrix4f translate; translate &lt;&lt; 2/rl, 0, 0, 0, 0, -2/tb, 0, 0, 0, 0, 2/nf, 0, 0, 0, 0, 1; projection = translate*persp*projection; return projection; } 模型变换矩阵很简单就是一个绕z轴旋转的矩阵
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff57db5ba32f1a51edab8d3a4ad4e9ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23798bd04bd56bab815368c96d039221/" rel="bookmark">
			RNA-seq数据分析(HISAT2&#43;featureCounts&#43;StringTie)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RNA-seq数据分析 简介1 生物基础1.1 中心法则1.2 RNA-seq Protocol1.3 RNA-seq总的路线图 2 数据分析2.1 前期准备2.1.1 创建目录&amp;安装conda2.1.2 常用文件格式简介 2.2 软件安装2.2.1 conda安装软件2.2.2 预编译版本软件安装2.2.3 源码安装 2.3 数据下载 下载完成之后一定要检查数据完整性，不然分析白做使用awk命令提取md5值，生成md5文件，运行以下命令检查文件完整性2.5 质控（QC）2.6 去接头2.7 hisat2比对2.8 定量和转录本组装 参考 简介 基因表达是功能基因组学研究的一个重要领域。基因表达与基因信息从基因组DNA到功能蛋白产物的流动有关。RNA-seq已成为一种标准的基因表达检测方法，尤其用于检测转录本相对丰度和多样性。已有研究表明，其可靠性可以与其他成熟的方法如定量聚合酶链式反应(qPCR)相媲美。
声明： 文中如有不足请留言讨论！
1 生物基础 吐槽： 系统性总结真的好困难，刚开始阅读文献也很吃力。但是行动是知识特有的果实，慢慢积累吧。
1.1 中心法则 中心法则对于学习生物的人来说再熟悉不过了，基因信息的流动，蛋白的产生等一系列生物学事件都基于中心法则，是基因表达分析的一条主线。遗传信息从双链基因组DNA模板到翻译后修饰蛋白的流动是每个阶段至关重要的分子特征。RNA-seq通常针对成熟的mRNA分子。
图中对于中心法则做了系统的总结，感兴趣可以click here。
1.2 RNA-seq Protocol 典型的RNA-seq流程包括从感兴趣的样本中分离RNA、建库、高通量测序产生数以百万计的reads(长度一般为30-300bp)、比对到参考基因组或转录组，差异表达分析、发现转录本亚型和其它的下游分析。下图很好的概括了RNA-seq数据产生的过程。
RNA-seq的应用：
检测所有基因在特定条件下的表达水平(发育阶段、不同组织、正常与疾病、药物治疗)。 发现新基因，可变剪切，基因突变和基因融合等。
1.3 RNA-seq总的路线图 这张图引自A survey of best practices for RNA-seq data analysis。包括了三个板块，分别是预分析，核心分析和高级分析。很好的概括了实验设计和拿到测序reads后的数据分析，并介绍了不同的分析路线和每一步的数据分析方法，可以说是一个很好的大纲。
更多的细节可以通过阅读文章中的引用进一步了解。
2 数据分析 注意：
这里省略了进入相关文件目录的步骤，大家分析时要注意。本次数据是小鼠早期胚胎测序得到的双末端数据，单末端相关参数可以使用–help查看帮助文档。但分析总体流程相同。
我使用的是HISAT2+featureCounts+StringTie流程。 2.1 前期准备 2.1.1 创建目录&amp;安装conda 创建目录
# 首先使用cd命令需要进入自己的目录 cd ~/ # 创建文件夹，用于存储参考基因组 mkdir -p /mnt/data/hwb/database/mouse_genome_esml_84/grcm38_tran/ # 建立软件安装目录 mkdir biosoft # 此外还需要建立项目分析的目录以及备份文件，方便查找 conda安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23798bd04bd56bab815368c96d039221/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39520f1a1aa47a6b52b574c3124bf119/" rel="bookmark">
			numpy 移动平均与卷积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、滑动平均二、一维最佳实践三、二维图像平滑平均 一、滑动平均 滑动平均滤波法（又称递推平均滤波法），时把连续取N个采样值看成一个队列 ，队列的长度固定为N ，每次采样到一个新数据放入队尾,并扔掉原来队首的一次数据.(先进先出原则) 把队列中的N个数据进行算术平均运算,就可获得新的滤波结果。N值的选取：流量，N=12；压力：N=4；液面，N=4~12；温度，N=1~4
优点： 对周期性干扰有良好的抑制作用，平滑度高 适用于高频振荡的系统
缺点： 灵敏度低 对偶然出现的脉冲性干扰的抑制作用较差 不易消除由于脉冲干扰所引起的采样值偏差 不适用于脉冲干扰比较严重的场合 比较浪费RAM
numpy.convolve(a, v, mode=‘full’) 详解
参数： a:(N,)输入的一维数组 v:(M,)输入的第二个一维数组 mode:{‘full’, ‘valid’, ‘same’}参数可选 ‘full’　默认值，返回每一个卷积值，长度是N+M-1,在卷积的边缘处，信号不重叠，存在边际效应。 ‘same’　返回的数组长度为max(M, N),边际效应依旧存在。 ‘valid’ 返回的数组长度为max(M,N)-min(M,N)+1,此时返回的是完全重叠的点。边缘的点无效。 改方法和一维卷积参数类似，a就是被卷积数据，v是卷积核大小。
关于运行平均值与一维卷积：
在Python的SciPy函数或NumPy函数或模块中，用于在给定特定窗口的情况下计算一维数组的运行平均值。
python实现方法。优点：无依赖。缺点：慢
mylist = [1, 2, 3, 4, 5, 6, 7] N = 3 cumsum, moving_aves = [0], [] for i, x in enumerate(mylist, 1): cumsum.append(cumsum[i-1] + x) if i&gt;=N: moving_ave = (cumsum[i] - cumsum[i-N])/N #can do stuff with moving_ave here moving_aves.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39520f1a1aa47a6b52b574c3124bf119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e66d5934333a589a5fb11eb94078abae/" rel="bookmark">
			Array.prototype.splice.apply合并数组用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Array.prototype.splice.apply合并数组用法详解 数组对象的splice方法合并数组Array.prototype.splice.apply合并数组 数组对象的splice方法合并数组 var arr1 = ['a', 'b', 'c']; arr1.splice(2, 0, '1'); arr1.splice(2, 0, '2') arr1.splice(2, 0, '3') console.log(arr1); 运行结果：
Array.prototype.splice.apply合并数组 var arr1 = ['a', 'b', 'c']; var arr2 = ['1', '2', '3']; //合并数组arr1和arr2 arr2.unshift(2, 0); //在arr2前面插入两个元素2和0；arr2 = [2, 0, '1', '2', '3']; //2和0的含义是从arr1的索引为2的元素前面删掉0个元素后，再往索引为2的元素前插入arr2的元素 Array.prototype.splice.apply(arr1, arr2); console.log(arr1); //[ 'a', 'b', '1', '2', '3', 'c' ] 运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/355357c6d414d340fd8bd9ae7d287c4e/" rel="bookmark">
			通用异步收发器UART
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		*****UART基本结构
⑴、输出缓冲寄存器，它接收CPU从数据总线上送来的并行数据，并加以保存。
⑵ 、输出移位寄存器，它接收从输出缓冲器送来的并行数据，以发送时钟的速率把数据逐位移出，即将并行数据转换为串行数据输出。
⑶ 、输入移位寄存器，它以接收时钟的速率把出现在串行数据输入线上的数据逐位移入，当数据装满后，并行送往输入缓冲寄存器，即将串行数据转换成并行数据。
⑷ 、输入缓冲寄存器，它从输入移位寄存器中接收并行数据，然后由CPU取走。
⑸、控制寄存器，它接收CPU送来的控制字，由控制字的内容，决定通信时的传输方式以及数据格式等。例如采用异步方式还是同步方式，数据字符的位数，有无奇偶校验，是奇校验还是偶校验，停止位的位数等参数。
⑹、状态寄存器。状态寄存器中存放着接口的各种状态信息，例如输出缓冲区是否空，输入字符是否准备好等。在通信过程中，当符合某种状态时，接口中的状态检测逻辑将状态寄存器的相应位置“1”，以便让CPU查询。
在PIC系列单片机中
*****使能UART
UART模块通过UARTEN位和UTXEN位置1来使能。一旦使能，UxTX和UxRX引脚就分别配置为输出和输入，改写了相应的I/O端口引脚的TRIS和PORT寄存器位设置。UxTX引脚在没有传输发生时，处于逻辑1。
注意：在UARTEN置1前，不应该将UTXEN位置1，否则将无法使能UART发送。
*****UART 发送器
发送器的核心是发送移位寄存器 （UxTSR）。移位寄存器从发送 FIFO 缓冲器 UxTXREG 获取数据。 UxTXREG 寄存器中的数据由软件写入。在前一次装入数据的停止位发送前，不会向 UxTSR 寄存器装入新数据。一旦停止位发送完毕， UxTXREG 寄存器中的新数据 （如果有）就会被装入 UxTSR。
注： UxTSR 寄存器并未映射到数据存储器中，因此用户不能直接访问它。
通过将 UTXEN 使能位 （UxSTA&lt;10&gt;）置 1 来使能发送。实际的发送要到 UxTXREG 寄存器装
入了数据并且波特率发生器 （UxBRG）产生了移位时钟 （图 21-3）后才发生。还可以先装入
UxTXREG 寄存器，然后将 UTXEN 使能位置 1 来启动发送。通常，第一次开始发送的时候，由
于 UxTSR 寄存器为空，这样传输数据到 UxTXREG 寄存器会导致该数据立即传输到 UxTSR。发
送过程中清零 UTXEN 位将使发送中止并复位发送器。因此， UxTX 引脚将回复到一个高阻抗状
态。
为了选择 9 位发送，PDSEL&lt;1:0&gt; 位（UxMODE&lt;2:1&gt;）应设置为 11 并且第 9 位应该写入 UTX8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/355357c6d414d340fd8bd9ae7d287c4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edfede9d0259e4b49ba7e0e7fcac2fdd/" rel="bookmark">
			C# .Net  获取实体对象属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现方法：
private static readonly ConcurrentDictionary&lt;RuntimeTypeHandle, PropertyInfo[]&gt; _dynamicObjectProperties = new ConcurrentDictionary&lt;RuntimeTypeHandle, PropertyInfo[]&gt;(); /// &lt;summary&gt; /// 获取对象属性 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; /// &lt;returns&gt;&lt;/returns&gt; private static PropertyInfo[] GetObjectProperties&lt;T&gt;() { var type = typeof(T); var key = type.TypeHandle; PropertyInfo[] queryPts = null; _dynamicObjectProperties.TryGetValue(key, out queryPts); if (queryPts == null) { queryPts = type.GetProperties(); _dynamicObjectProperties.TryAdd(key, queryPts); } return queryPts; } 使用例子：
public object Transform() { var obj = new KeyValue() { Key = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edfede9d0259e4b49ba7e0e7fcac2fdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f219a2eff8d6cf825845d8e9428a281a/" rel="bookmark">
			Could not find a package configuration file provided by “qt_build“ with any of the following nam...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述
CMake Warning at
/opt/ros/indigo/share/catkin/cmake/catkinConfig.cmake:76
(find_package): Could not find a package configuration file provided
by “qt_build” with any of the following names:
qt_buildConfig.cmake qt_build-config.cmake Add the installation prefix of “qt_build” to CMAKE_PREFIX_PATH or
set “qt_build_DIR” to a directory containing one of the above files.
If “qt_build” provides a separate development package or SDK, be
sure it has been installed. Call Stack (most recent call first):
robot_rqt/CMakeLists.txt:14 (find_package)
– Could not find the required component ‘qt_build’.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f219a2eff8d6cf825845d8e9428a281a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eb6139ed75bb1e33bff0e0a7eb09ece/" rel="bookmark">
			winserver物理内存使用不到一半就频繁爆内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		winserver该不该设置虚拟内存？使用的物理内存和内存使用的区别？提交、专用、工作集的区别？已提交又是什么东西？
如何配好winserver内存 前言■ 概述 过程■ 发现问题■ 模拟再现1. 结果呈现2. 触发操作、尝试解读3. 提出假设、重复实验4. 得出结论 ■ 探索原因“使用的物理内存”和”内存使用“的区别① 初探② 二探③ 再探④ 终探⑤ 结论 提交、专用、工作集的区别提交大小① 两个配置例子② 结论 ■ 配置优化一个比方深入理解反向比喻分页文件该配多少？ 推荐RAMMap最后 前言 线上一直存在一个问题，内存无法最大利用化，经常出现服务崩溃问题。
■ 概述 winserver上有16g的物理内存，使用不到8g，就会莫名其妙出现各种服务闪退问题。查看资源管理器，发现虽然物理内存使用比不高，但是内存使用却接近100%。深入了解后才知道提交内存才是进程真正占用的内存。设置虚拟内存以充分利用物理内存，便可解决此问题。
过程 ■ 发现问题 待解决清单里有个问题：内存使用大于7g就会有问题（物理内存有16g），tomcat内存会不断增加。
—— （方向错了，tomcat背锅了）
由于无从下手，渐渐地，这个问题被遗忘掉了。
而win又有一个特点，开机久了，系统会占用物理内存越来越多，所以每次服务奔溃了重启奔溃了重启（基本奔溃的是一个视频流服务，所以它背锅，认为这个服务存在问题），也多次提出过这个问题，和之前一样，问题定向错误，无从下手，渐渐地习惯了这种奔溃。慢慢地，物理内存占用到了12g。
—— （开机久后，频繁奔溃的临界点由8g提高到了13g，问题定向由应用问题转向了内存问题，错误认为内存确实不够用了，服务确实达到了该服务器所能支持的临界点）
这个问题被重新翻了出来。
■ 模拟再现 既然无法避免频繁崩溃，在空闲时间点，我选择主动地去触发它，让奔溃的场景复现，然后解析奔溃原因。
1. 结果呈现 如图所示，红线是崩溃的临界线。曲线在攀升到巅峰后，突然呈断崖式下降，“使用的物理内存”下降了12%左右，“内存使用”下降25%左右。
2. 触发操作、尝试解读 本来两个曲线有所富余，我尝试的启动两个tomcat，曲线逐渐上升，直到上图所示，“使用的物理内存”缓缓增加，“内存使用”攀升到天花板后开始垂死挣扎，直到某一个点，“内存使用”直接触顶，然后就是两个tomcat同时闪退，接着资源监控器中也可看到两条曲线同时急速下降。
3. 提出假设、重复实验 这个结果可把我乐坏了，如果不存在任何触顶的话，这个问题可能真的就不了了之了，但是“内存使用”的曲线触顶了，我可以大胆提出假设，这条“内存使用”的曲线呈服务器真正所使用的内存情况。我尝试着在各台不同的Windows电脑上重复实验，结果不出所料，只要“内存使用”达到了百分比，程序就会奔溃。当然更多的电脑上情况是”使用的物理内存“占比很高，”内存使用“占比较低，难以撑满。
4. 得出结论 程序频繁崩溃的直接原因是”内存使用“达到了百分比。
■ 探索原因 找到了直接原因，然后就是寻找它背后的根本原因。
“使用的物理内存”和”内存使用“的区别 ① 初探 这两个图究竟有什么联系？果断进行面向百度解决方案，结果很失败，这个搜索词条根本找不到相关的资料。然后就是寻求同学、好友的帮助，仍然得不出结果，算是大家的一个知识盲区，同学的回答中最接近事实的猜测就是第二块曲线图可能是虚拟内存。然后大胆猜测内存使用是物理内存+虚拟内存，然后我查看了服务器上设置的虚拟内存分页文件设置大小——关闭，为0，烦恼来了，既然没设置虚拟内存，那么第二块曲线图所呈现应该和物理内存一样才对，同学又给出了猜测，还有一部分物理内存被操作系统占用了而又不显示，而内存使用中显示了出来，然后我假定了结论有一部分物理内存作为置换使用，所以不可用，供系统使用而又不显示在物理内存里 。。。
② 二探 这个结论给的很勉强，无法服众，不过好歹有点再深究的蛛丝马迹，好过无头苍蝇，不知道怎么走好太多了。知道了和虚拟内存可能有关系，我就尝试调整虚拟内存，结果问题莫名其妙地解。解决。。解决了。。。调大虚拟内存后，第二块曲线图的曲线立马降了下来，崩溃的情况自然就不会出现了。
类似这样的情况，原本无虚拟内存，给系统配上了8g虚拟内存后，第二块曲线图的占比立马降了下来。
③ 再探 解决问题后算是松一口气，但是接下来的日子里总觉得心中搁着一块什么东西，毕竟，知其然而不知其所以然只能算解决一小半问题，虽然这个问题解决了，但你不知道什么原因，未来还会出现什么问题完全是未知的，你解决问题获得了什么知识，也是是空白的。因此，我并未放下对这个现象的探索。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eb6139ed75bb1e33bff0e0a7eb09ece/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/418/">«</a>
	<span class="pagination__item pagination__item--current">419/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/420/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>