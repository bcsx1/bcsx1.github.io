<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13e27573716b61210c751ec4e577c3e2/" rel="bookmark">
			计算图片相似度的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.余弦相似度计算2.哈希算法计算图片的相似度3.直方图计算图片的相似度4.SSIM（结构相似度度量）计算图片的相似度5.基于互信息（Mutual Information）计算图片的相似度 1.余弦相似度计算 把图片表示成一个向量，通过计算向量之间的余弦距离来表征两张图片的相似度。
from PIL import Image from numpy import average, dot, linalg # 对图片进行统一化处理 def get_thum(image, size=(64, 64), greyscale=False): # 利用image对图像大小重新设置, Image.ANTIALIAS为高质量的 image = image.resize(size, Image.ANTIALIAS) if greyscale: # 将图片转换为L模式，其为灰度图，其每个像素用8个bit表示 image = image.convert('L') return image # 计算图片的余弦距离 def image_similarity_vectors_via_numpy(image1, image2): image1 = get_thum(image1) image2 = get_thum(image2) images = [image1, image2] vectors = [] norms = [] for image in images: vector = [] for pixel_tuple in image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13e27573716b61210c751ec4e577c3e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/393ab511845ed125811753b702d8a548/" rel="bookmark">
			五大点，搞懂单线程的Redis到底快在哪里
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言一.开发语言二.纯内存访问三.数据结构简单四.单线程五.非阻塞多路I/O复用机制 前言 Redis是一种基于键值对(Key-Value)的NoSQL数据库，Redis的Value可以由String，hash，list，set，zset，Bitmaps，HyperLogLog等多种数据结构和算法组成。Redis还提供了键过期，发布订阅，事务，Lua脚本，哨兵，Cluster等功能。Redis执行命令的速度非常快，根据官方给的性能可以达到10w+qps。那么本文主要介绍到底Redis快在哪里，主要有以下几点：
一.开发语言 现在我们都用高级语言来编程，比如Java、python等。也许你会觉得C语言很古老，但是它真的很有用，毕竟unix系统就是用C实现的，所以C语言是非常贴近操作系统的语言。Redis就是用C语言开发的，所以执行会比较快。
另外多说一句，大学生们好好学C，会让你更好的理解计算机操作系统。别觉得学了高级语言就可以不用关注底层，欠的债总归要还的。此处推荐一本比较难啃的书《深入理解计算系统》。
二.纯内存访问 Redis将所有数据放在内存中，非数据同步正常工作中，是不需要从磁盘读取数据的，0次IO。内存响应时间大约为100纳秒，这是Redis速度快的重要基础。先看看CPU的速度：
拿我的电脑来说，主频是3.1G，也就是说每秒可以执行3.1*10^9个指令。所以说CPU看世界是非常非常慢的，内存比它慢百倍，磁盘比他慢百万倍，你说快不快？
借了一张《深入理解计算机系统》的图，展示了一个典型的存储器层次结构，在L0层，CPU可以在一个时钟周期访问到，基于SRAM的高速缓存春续期，可以在几个CPU时钟周期访问到，然后是基于DRAM的主存，可以在几十到几百个时钟周期访问到他们。
三.数据结构简单 ​ 数据结构简单，对数据操作也简单，Redis 不使用表，不会强制用户对各个关系进行关联，不会有复杂的关系限制，其存储结构就是键值对，类似于 HashMap，HashMap 最大的优点就是存取的时间复杂度为 O(1)。
四.单线程 第一，单线程简化算法的实现，并发的数据结构实现不但困难且测试也麻烦。第二，单线程避免了线程切换以及加锁释放锁带来的消耗，对于服务端开发来说，锁和线程切换通常是性能杀手。当然了，单线程也会有它的缺点，也是Redis的噩梦：阻塞。如果执行一个命令过长，那么会造成其他命令的阻塞，对于Redis是十分致命的，所以Redis是面向快速执行场景的数据库。
除了Redis之外，Node.js也是单线程，Nginx也是单线程，但他们都是服务器高性能的典范。
五.非阻塞多路I/O复用机制 在这之前先要说一下传统的阻塞I/O是如何工作的：当使用read或者write对某一文件描述符（File Descriptor FD）进行读写的时候，如果数据没有收到，那么该线程会被挂起，直到收到数据。阻塞模型虽然易于理解，但是在需要处理多个客户端任务的时候，不会使用阻塞模型。
I/O多路复用实际上是指多个连接的**管理可以在同一进程。**多路是指网络连接，复用只是同一个线程。在网络服务中，I/O多路复用起的作用是一次性把多个连接的事件通知业务代码处理，处理的方式由业务代码来决定。在I/O多路复用模型中，最重要的函数调用就是I/O 多路复用函数，该方法能同时监控多个文件描述符（fd）的读写情况，当其中的某些fd可读/写时，该方法就会返回可读/写的fd个数。
Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll的read、write、close等都转换成事件，不在网络I/O上浪费过多的时间。实现对多个FD读写的监控，提高性能。
举个形象的例子吧。比如一个tcp服务器处理20个客户端socket。
- A方案：顺序处理，如果第一个socket因为网卡读数据处理慢了，一阻塞后面都玩蛋去。
- B方案：每个socket请求都创建一个分身子进程来处理，不说每个进程消耗大量系统资源，光是进程切换就够操作系统累的了。
- C方案 （I/O复用模型，epoll） ：将用户socket对应的fd注册进epoll（实际上服务器和操作系统之间传递的不是socket的fd而是fd_set的数据结构），然后epoll只告诉哪些需要读/写的socket，只需要处理那些活跃的、有变化的socket fd的就好了。 这样，整个过程只在调用epoll的时候才会阻塞，收发客户消息是不会阻塞的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/114c37b8887f6abfc3cde2292fcdc93e/" rel="bookmark">
			【大厂面试系列】吊打面试官之mysql高频面试题（最新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据库基础知识
为什么要使用数据库什么是SQL？什么是MySQL?数据库三大范式是什么mysql有关权限的表都有哪几个MySQL的binlog有有几种录入格式？分别有什么区别？ 数据类型
mysql有哪些数据类型 引擎
MySQL存储引擎MyISAM与InnoDB区别MyISAM索引与InnoDB索引的区别？InnoDB引擎的4大特性存储引擎选择 索引
什么是索引？索引有哪些优缺点？索引使用场景（重点）索引有哪几种类型？索引的数据结构（b树，hash）索引的基本原理索引算法有哪些？索引设计的原则？创建索引的原则（重中之重）创建索引的三种方式，删除索引创建索引时需要注意什么？使用索引查询一定能提高查询的性能吗？为什么百万级别或以上的数据如何删除前缀索引什么是最左前缀原则？什么是最左匹配原则B树和B+树的区别使用B树的好处使用B+树的好处Hash索引和B+树所有有什么区别或者说优劣呢?数据库为什么使用B+树而不是B树B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，什么是聚簇索引？何时使用聚簇索引与非聚簇索引非聚簇索引一定会回表查询吗？联合索引是什么？为什么需要注意联合索引中的顺序？ 事务
什么是数据库事务？事物的四大特性(ACID)介绍一下?什么是脏读？幻读？不可重复读？什么是事务的隔离级别？MySQL的默认隔离级别是什么？ 锁
对MySQL的锁了解吗隔离级别与锁的关系按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了MySQL中InnoDB引擎的行锁是怎么实现的？InnoDB存储引擎的锁的算法有三种什么是死锁？怎么解决？数据库的乐观锁和悲观锁是什么？怎么实现的？ 视图
为什么要使用视图？什么是视图？视图有哪些特点？视图的使用场景有哪些？视图的优点视图的缺点什么是游标？ 存储过程与函数
什么是存储过程？有哪些优缺点？ 触发器
什么是触发器？触发器的使用场景有哪些？MySQL中都有哪些触发器？ 常用SQL语句
SQL语句主要分为哪几类超键、候选键、主键、外键分别是什么？SQL 约束有哪几种？六种关联查询什么是子查询子查询的三种情况mysql中 in 和 exists 区别varchar与char的区别varchar(50)中50的涵义int(20)中20的涵义mysql为什么这么设计mysql中int(10)和char(10)以及varchar(10)的区别FLOAT和DOUBLE的区别是什么？drop、delete与truncate的区别UNION与UNION ALL的区别？ SQL优化
如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？SQL的生命周期？大表数据查询，怎么优化超大分页怎么处理？mysql 分页慢查询日志关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？为什么要尽量设定一个主键？主键使用自增ID还是UUID？字段为什么要求定义为not null？如果要存储用户的密码散列，应该使用什么字段进行存储？优化查询过程中的数据访问优化长难的查询语句优化特定类型的查询语句优化关联查询优化子查询优化LIMIT分页优化UNION查询优化WHERE子句 数据库优化
为什么要优化数据库结构优化MySQL数据库cpu飙升到500%的话他怎么处理？大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？ 垂直分表 适用场景缺点水平分表： 适用场景水平切分的缺点MySQL的复制原理以及流程读写分离有哪些解决方案？备份计划，mysqldump以及xtranbackup的实现原理数据表损坏的修复方式有哪些？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3bcf889a74f40bb80ebc9b55c45c1f8/" rel="bookmark">
			开发中遇到的bug-Invalid shorthand property initializer（已解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对象中的：
是不是写成 = 了？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2cb947003884ecabc486fd1aef90927/" rel="bookmark">
			Unity 2019导入ARCore Unity SDK解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题背景 最近学习ARCore，即自定义创建一款Android端的AR应用。于是便学习ARCore官方网站的开发教程，先导入并运行arcore-unity-sdk-1.16.0.unitypackage，但是在Unity 2019导入arcore-unity-sdk-1.16.0.unitypackage后总是提示编译错误。
二、错误原因分析 参考ARCore官方网站的开发教程时，浏览器根据博主我所在的国家默认选择了ARCore的中文开发教程，这似乎不是什么大问题。但是，如果我们仔细对比ARCore的英文和中文开发教程，我们会发现中文开发教程存在着严重的滞后性！
由上述的ARCore中英文开发教程的对比图，我们可以得知：中文教程已经很久没有更新了，而只有英文教程提到了以下针对在Unity 2019导入ARCore Unity Sdk时需要的额外安装包：
Unity 2019 only: Select Window &gt; Package Manager and install the following packages:
Multiplayer HLAPI (required by the CloudAnchors sample)
XR Legacy Input Helpers (required by Instant Preview, which uses the TrackedPoseDriver)
三、解决方案 我们需要按照ARCore最新的英文版开发教程来完成我们ARCore Unity Sdk的导入操作，以下是最新的英文版教程。
1.创建一个新项目并导入SDK
打开Unity并创建一个新的3D项目。
仅适用于Unity 2019:选择Window &gt;Package Manager并安装以下包:
Multiplayer HLAPI(CloudAnchors sample需要该安装包)
XR Legacy Input Helpers (使用TrackedPoseDriver的Instant Preview需要该安装包)
导入ARCore Unity Sdk：
选择 Assets &gt; Import Package &gt; Custom Package。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2cb947003884ecabc486fd1aef90927/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6bc8b38d6d2370d0455e971721cb8cc/" rel="bookmark">
			VCC、VDD、VSS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VCC：C=circuit 表示电路的意思, 即接入电路的电压；
VDD：D=device 表示器件的意思, 即器件内部的工作电压；
对于数字电路来说，VCC是电路的供电电压,VDD是芯片的工作电压（通常Vcc&gt;Vdd），VSS是接地点；有些IC既有VDD引脚又有VCC引脚，说明这种器件自身带有电压转换功能。
VEE：发射极电源电压, Emitter Voltage, 一般用于 ECL 电路的负电源电压.
VSS：S=series 表示公共连接的意思，通常是指电路公共接地端电压。
VPP：不同芯片对Vpp的定义稍有不同,比如电压峰峰值,单片机中Vpp多数定义为编程电压
在场效应管（或COMS器件）中，VDD为漏极，VSS为源极，VDD和VSS指的是元件引脚，而不表示供电电压。一般来说VCC=模拟电源,VDD=数字电源,VSS=数字地,VEE=负电源
在IC测试资料里是这样规定的。。。
我们大多数芯片的电源pin确实都起名VDD因为主要都是CMOS工艺的，测试的时候VDD和VCC也都是混着用的，没有过分去区别差异。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdea4276904ce5cf57dbe255884a8dcd/" rel="bookmark">
			使用最好的python ide
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Throughout this article, I will discuss a step-by-step guide for using some of the top Python Integrated Development Environments/Code Editors:I. Google Colaboratory | II. Jupyter Notebook | III. Spyder. With a noteworthy guide for the feature of uploading Python code files to your Github account.
在整篇文章中，我将讨论使用一些顶级Python集成开发环境/代码编辑器的分步指南： I. Google Colaboratory 二。 Jupyter笔记本| 三， Spyder 。 关于将Python代码文件上传到您的Github帐户的功能的值得注意的指南。
I. Google合作实验室 (I. Google Colaboratory) Colaboratory, or “Colab” for short, is a product from Google Research.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdea4276904ce5cf57dbe255884a8dcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ea123da1db7c809aa7f51f6dbb35fd0/" rel="bookmark">
			归并排序的实现与求逆序对数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		归并排序 归并排序是个一种非常有趣的算法，原理就像比武大会，比武大会需要
选出一个最厉害的武术高手，但是参与者很多很多，总不能让他们在一起
打群架吧！因此就有了擂台赛这种形式出现。
无论参赛者有多少，主办方都可以让他们两两比赛，获胜者再分成两两一组，
继续比试，一直到决出冠军
举个例子 有A、B、C、D、E、F、G、H一共8人参考参加比武大会。 第一轮，两两一组，有4名选手胜出（四分之一决赛）
第二轮，两两一组，有两名选手胜出（半决赛）
第三轮，仅剩的两人一组，冠军胜出（总决赛）
擂台赛流程：先进行两两分组竞赛，然后胜出者两两分组继续竞赛，归并排序的流程
也是类似的，但存在一些不同之处。
归并排序，分而治之，分：二分；治：合并 二分 假设集合一共有n个元素，算法将会对集合进行逐层的折半分组。
第一层分成两个大组，每组n/2个元素；
第二层分成4个小组，每组n/4个元素；
…
一直到每组只有一个元素为止
Code:
void erfen(int l,int r) //二分 { int mid=(r - l)/2 + l; if(l&lt;r) { erfen(l,mid); erfen(mid+1,r); } _merge(l,mid,r); } 合并 归并排序和擂台赛有一个很大的不同，就是擂台赛只需要决定谁最大，而并不关心谁第二、第三；
而归并排序则需要确定每一个元素的排列位置。
因此我们需要不断把有序的小组不断合并成更大的有序的组
实现：3个操作 实现：3个操作
创建一个额外大集合用于存储归并结果，长度是两个小集合之和。
从左到右逐一比较两个小集合中的元素，把较小的元素优先放入大集合。
从另一个还有剩余元素的集合中，把剩余元素按顺序复制到大集合尾部
Code void _merge(int l,int mid,int r)//归并 { int p1=l,p2=mid+1; for(int i=l;i&lt;=r;i++) { //两段各个数比较大小存入 if(((p1&lt;=mid)&amp;&amp;(p2&gt;r))||(a[p1]&lt;a[p2])) { b[i]=a[p1]; p1++; } else { b[i]=a[p2]; p2++; } } for(int i=l;i&lt;=r;i++) a[i]=b[i]; } 通过归并排序求逆序数 逆序数：在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。 例1： 3 4 1 2 逆序数为4 例2： 5 1 2逆序数为2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ea123da1db7c809aa7f51f6dbb35fd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35240d7e392ee155a85f4fa03bbc71ac/" rel="bookmark">
			std::map 自定义key类型，重写operator＜() 没有严格弱序引起的“invalid comparator”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题现象特征 问题分析严格弱序三要求测试demo 问题 现象 生产环境中偶发崩溃，调试时弹出以下弹窗：
定位问题为 map自定义key类型重写operator&lt;() 没有严格弱序引起。
特征 编译正常，运行时偶发（取决于key值），容易让人以为是指针问题。 问题分析 严格弱序三要求 参考自： C++ 严格弱序
两个关键字不能同时“严格弱序”于对方如果a“严格弱序”于b，且b“严格弱序”于c，则a必须“严格弱序”于c如果存在两个关键字，任何一个都不“严格弱序”于另一个，则这两个关键字是相等的。 测试demo 根据业务代码bug输出demo如下：
#include &lt;map&gt; struct StKey { int account; int type; StKey(int account_, int type_): account(account_), type(type_) { } bool operator&lt;(const StKey &amp; right) const { #if 1 // 严格弱序 if (account != right.account) { return account &lt; right.account; } if (type != right.type ) { return type &lt; right.type ; } return false; #else // 非严格弱序，产生的原来实现 return account &lt; right.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35240d7e392ee155a85f4fa03bbc71ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b12ace3bcfe6de6243f3a7a0a74d1f07/" rel="bookmark">
			ECharts 实现重叠柱状图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 使用详解
（1）series.z
说明：
折线图组件的所有图形的 z 值。控制图形的前后顺序。
z 值小的图形会被 z 值大的图形覆盖。z 相比 zlevel 优先级更低，而且不会创建新的 Canvas。
（2）series.barGap
说明：
不同系列的柱间距离，为百分比（如 '30%'，表示柱子宽度的 30%）。
如果想要两个系列的柱子重叠，可以设置 barGap 为 '-100%'。这在用柱子做背景的时候有用。
在同一坐标系上，此属性会被多个 'bar' 系列共享。此属性应设置于此坐标系中最后一个 'bar' 系列上才会生效，并且是对此坐标系中所有 'bar' 系列生效。
2 原始效果图 3 实现代码（重叠柱状图） &lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 var option = { tooltip: { trigger:"axis", formatter:"{a1}&lt;br/&gt;{b1}：{c1}%" }, legend: { data:['增长率'] }, xAxis: { data: ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b12ace3bcfe6de6243f3a7a0a74d1f07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcb53524a5e73f20acbb0dd470061c5d/" rel="bookmark">
			python 利用jieba读取txt文本进行分词后存入新txt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python 利用jieba读取txt文本进行分词后存入新txt import jieba txt = open("news.txt",encoding='UTF-8').read() words = jieba.lcut(txt) result = open('results.txt','w',encoding='UTF-8') result.write(' '.join(words)) counts = {} for word in words: if len(word) == 1: continue else: counts[word] = counts.get(word,0) + 1 items = list(counts.items()) items.sort(key=lambda x:x[1], reverse=True) for i in range(30): word, count = items[i] print (u"{0:&lt;10}{1:&gt;5}".format(word, count)) result.write((str(items[i]))) result.close() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd5a859ac3752f84b0f38796ce5eab3c/" rel="bookmark">
			将一个数组每三个一组生成一个新数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 var data = [ {name:'Liming',age:'1'}, {name:'Liming',age:'2'}, {name:'Liming',age:'3'}, {name:'Liming',age:'4'}, {name:'Liming',age:'5'}, {name:'Liming',age:'6'}, {name:'Liming',age:'7'}, {name:'Liming',age:'8'}, {name:'Liming',age:'9'}, {name:'Liming',age:'10'}, ] var result = []; for(var i=0;i&lt;data.length;i+=3){ result.push(data.slice(i,i+3)); } console.log("分组数据",result); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a9a759e4b0d570f6ceab60ed9f0b95/" rel="bookmark">
			idea操作git时 合并分支&#43;解决冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结一、IDEA使用Git合并到Master分支&amp;冲突解决步骤 1、合并基本步骤 首先切换到master分支在要合并的分支上右键 Merge into current合并成功后，再选择Push 2、合并过程出现冲突的解决 accept yours:代表以自己的为准accept theris:代表以更新下来的文件为准merge:代表手动合并 一般解决冲突我们都是选择merge。
1、选中文件，点击右侧的Merge。
2、出现一个窗口，分为三个部分。
最左侧，是本地当前分支代码中间，解决冲突后的最终结果文件最后侧，是本地将要被合并的分支代码 通过比较文件内容，合并需要的代码到中间的位置，最后点击Apply就完成了。
3、具体操作：
将需要的内容点击："&gt;&gt;"既可以合并内容到result中，不需要的内容点击“x”即可，合并完成后点击apply即可。
（值得注意的是，最将所有的“x &gt;&gt;”符号都要处理完，不需要的点击“x”,需要的点击“&gt;&gt;”）
最后，不论是什么场景下产生的冲突解决方法是一样的。
合并完成后，点击右下角“Apply”
解决冲突后，需要先pull远程分支到本地仓库，然后再把本地仓库的代码推送push到远程分支。
总结二、idea操作git时合并分支及解决冲突 操作演示 场景：两个分支，一个master主分支，一个是1.0版本（这里我叫次分支），先将次分支上的数据合并到主分支上，没有冲突的数据会自动合并，有冲突的会提示你解决冲突。
01.先切换到主分支上，然后如图点击“merge into Current”（有些版本里是显示“merge”）
02.如果代码没有冲突，就会直接合并成功了，此时主分支上就会含有次分支上的数据，再pull+push进行推送即可（当然在上图中也可以考虑直接在远程上操作，我就不测试了）
解决冲突 03.如果合并时出现冲突就会弹出下面提示框要求你解决冲突，
accept yours:冲突文件使用主分支数据accept theirs:冲突文件使用次分支数据merge：手动选择冲突数据
注：如未处理完就关闭了上面窗口，可以在“最上方VCS——Git——Resolve Conflicts”重新打开
特殊情况：合并过一次后如果再将主分支回滚版本，此时虽然主分支上没有了次分支上的数据了，但再去合并次分支时，原来次分支之前已经合并过的内容不会在合并上去，会提示“Already up-to-date”。 参考：
https://my.oschina.net/xiaomiaonevergiveup/blog/4275856
https://blog.csdn.net/weixin_44647371/article/details/88184693?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduend~default-1-88184693.nonecase&amp;utm_term=idea%E4%B8%ADgit%E4%B8%A4%E4%B8%AA%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81&amp;spm=1000.2123.3001.4430
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee23e3e92bd775e4166ac3c80a033234/" rel="bookmark">
			加减运算&amp;溢出判断（计算机组成原理16）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加减运算&amp;溢出判断 视频链接地址： https://www.bilibili.com/video/BV1BE411D7ii?from=search&amp;seid=6420326887479343502 计算机组成原理 系列文章目录 加减运算&amp;溢出判断前言1 原码的加减运算2 补码的加减运算2.1 补码加减2.2 溢出判断2.3 符号扩展 3 小结 前言 在本篇中，你将掌握
原码、补码的加减法运算加法运算的三种溢出判断符号扩展的实现 1 原码的加减运算 注意看上图，14+（-14）的原码加法是错误的
原码的加法运算：
正+正 = 绝对值做加法，结果为正
负+负 = 绝对值做加法，结果为负
正+负 = 绝对值大的减绝对值小的，符号位同绝对值大的数
原码的减法运算，“减数”符号取反，转变为加法
可以看出，原码的加法逻辑太难了，所以计算机中通常用补码来实现加减运算
2 补码的加减运算 2.1 补码加减 [ A − B ] 补 = [ A ] 补 + [ − B ] 补 [A-B]_{补} = [A]_{补} + [-B]_{补} [A−B]补​=[A]补​+[−B]补​
对于补码来说，无论加法还是减法，最后都会转变成加法，由加法器实现运算，符号位也参与运算。
且对于8位机器字长的补码运算会出现溢出，（-128至127）
2.2 溢出判断 在补码加法运算中，会出现溢出这种问题，可以将溢出理解为“循环补码”
比如三位机器数的加法，3+3 = 011 + 011 = 110 = -2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee23e3e92bd775e4166ac3c80a033234/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c18fb3483287d60c067d592b48c4fe3e/" rel="bookmark">
			2020-10-11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找到多少个梅森素数就能找到多少个完全数（向前辈致敬） 所谓梅森数，是指形如2 p ^p p-1的一类数，如果指数p和梅森数都是素数，后者称为梅森素数。在梅森素数的基础上，形如2 p − 1 ^{p -1} p−1(2 p ^p p-1)的一类数就是完全数。
目前为止，已经找到51个梅森素数，p最小为2，最大为82589933，根据p值，可以统计这些梅森素数和完全数。考虑到后面的梅森素数是上千万位数，计算工作量很大，运算速度要有保障，采用Java编程，导入java.math.BigInteger进行精度计算。
package good; import java.math.BigInteger; import java.io.File; import java.io.IOException; import java.io.Writer; import java.io.FileWriter; public class Perfect { public static void main(String[] args) { // TODO Auto-generated method stub File file= new File("data.txt"); if (!file.exists()) { try { file.createNewFile(); //如果文件不存在则创建文件 } catch (IOException e) { e.printStackTrace(); } } int p[]= {2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281, 3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243, 110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377, 6972593, 13466917, 20996011,24036583, 25964951, 30402457, 32582657, 37156667, 42643801, 43112609, 57885161, 74207281, 77232917,82589933}; BigInteger one=new BigInteger("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c18fb3483287d60c067d592b48c4fe3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/716594e3fcb0f73094dab32e98a999f5/" rel="bookmark">
			十一国庆过后，秋招Java岗，陆续收到字节/招银等offer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的秋招可以算是开始的早结束的早，前前后后一共面了10个吧，最后拿到的有招行信用卡中心、农行西安、字节、快手、shopee、招银网络。
以下仅针对我的面试内容及体验，不具有普遍性。在文末分享了我为金九银十准备的备战资源库，包含了源码笔记类，大厂面试真题，跳槽解析，简历解析，项目实战源码+笔记+工具，有需要的
#戳这里即可获取
1、招银网络 六月底的时候开始了第一个笔试，招银网络。据说以前会卡学历，现在不卡了。招银网络的面试流程分为笔试+电话面（笔试成绩好会直接跳过)+2轮技术面+1轮hr面+资料审核，可谓是又臭又长，体验极差。从六月底持续到8月中旬提交资料，上述流程每走一步都需要一周时间，等到8月中旬提交材料的时候我的秋招已经结束了。。。。
面试内容：框架多，数据库多，Java基础少，面试会写题，应该算是easy里简单的那些题。
框架问了spring boot、spring data jpa，我的项目里用到了这些。
2、字节跳动 6月30日投简历，字节当时真的是随便投的，看到客户端招零基础，就很随意的投了客户端（因为我天天刷抖音，也有一些客户端基础，本科的时候做过APP)
前前后后面了三次（成都抖音、教育、data），虽然挂了两次，但是平心而论，面试体验还是非常好的，只要面试一开始，流程就走的很快。
面试内容：
抖音和教育部门几乎没有问任何客户端的知识，全程怼计算机网络+操作系统+Java基础，写题都是easy难度。
data的部门是做小程序基础平台的，要求应该是稍微高一点，还问了很多关于客户端的基础知识，写题是medium难度。
教育部门自认为全程都很不错，挂掉的原因不明。
总结：很想去字节的话，挂了就赶紧联系其他部门的hr捞，有hr主动捞的话也可以讨价还价，问问能不能直接从三面开始
3、招商银行信用卡中心 这个单位比较卡学历，一般是双985起步。我自己是双西电，应该算是最低入场券了，很多双985甚至华五的被刷简历。
我是当时7月底的时候报名参加了提前批的Geeker技术竞赛，据说三千多人最后发了十来个offer，报录比300：1也是相当恐怖了。
初试8月3日牛客网做三道题，然后大概有六七十人进了复赛吧
复赛8月10日早上10点开始公布赛题，两条赛道，一条偏算法一条偏工程，我选的工程。
截止当日凌晨24点提交项目文件+PPT+接口文档，第二天早上开始答辩，提交越晚答辩开始越早，我是差不多24点才提交的，所以第二天又起了个大早视频答辩，最后成绩应该是第9名。
大概是做一个红包雨的项目，官方说可以参考开源的资料，我当时一着急忘了，全程纯手写，后来才知道别人参考了开源的项目。
8月13日收到性格测试通知，8月14日早上参加终面，终面完之后8月20日官网状态变成offer发放中，8月26日收到带薪offer，9月份卡中心预约好了体检，体检中心会打电话过来和你商量一个体检时间。
体验：可能是先入为主，一直觉得这个单位很棒、高大上，所以全程都觉得体验很好，面试官、比赛导师、hr都态度很好，包括提前帮你预约好体检。
这个单位应该是我最心仪的了，福利待遇好，wlb，里面的人基本都是高学历很优秀，心心念念了好久，最后因为一些个人原因选择了西安农行，直到昨天hr还打电话过来问怎么没有回复签约邮件，真的特别惋惜，不过人生没有十全十美的选择。
4、shopee 7月底到8月初面试，两轮技术+一轮hr，8月14收到意向书
一面的面试官是c++的，问我会不会，我直接说不会，他就全程问算法题，我口述思路，大概问了有十几道题，只记得有一些是偏实际应用场景的题，海量数据下排序查找什么的，问完之后可能觉得算法这块没什么问题了，写题就让我写了two sum
二面和牛客网其他面经差不多，系统设计，高并发系统、秒杀系统，然后就聊聊天
清楚的记得那天早上卡中心终面结束后突然收到了shopee意向书
5、快手 快手似乎是随机分部门的，我面的部门只有两面技术面
一面8月11日，写了两道medium题，然后问了三个Java的问题就结束了差不多45分钟
二面本来是8月14日，面试官有事推到了8月17日，写了一条sql 一道智力题 一道easy题，只记得用二分法，问数据库多一些。
之后就没有消息了，以为自己挂了，结果9月7日收到hr电话说过了，两面面评都挺好的。
9月15日再次收到另一个hr的电话，说部门内部对我的简历评估之后，觉得我更适合算法岗，让我考虑一下是否转算法岗，我觉得自己还是想做开发，就说还是想做开发
体验：面试完就没有消息了是比较难受的，好在我当时已经有了其他满意的offer，就没有很在意，如果手上没有其他offer，会很煎熬。
6、农行西安研发 农行来的比较晚，整个9月就面了农行，流程走的很急。。。
8月29笔试，9月13一面，9月21二面，9月25体检，9月28签约
面试内容：西安人3v1，基本是按照简历面的，我之前有小程序、客户端、后端的项目，所以这些都问到了，第一个面试官问了后端的redis之类以及非常简单的Java基础，第二个面试官似乎是前端的，问了前端的基础和客户端的基础，第三个面试官问了数据库的高可用、非对称加密。
体验：一面体验非常好，三个面试官都态度特别好。但是流程感觉很糟糕，每次都是提前一天晚上突然通知，比如体检的前一天晚上8点通知第二天早上体检，并且要求提前两天不吃肉不喝酒啥的，体检350自费。。。
其他投递的公司：
1、阿里
当时面阿里的时候我已经收到了shopee和招行卡中心，对招行卡中心特别满意并且我也没有大厂情节，第一次二面挂了之后被捞起来，我就拒了没有继续面
2、百度
百度我投的是Java，是一个用Go和C++的部门面的，二面的面试官不懂java，一直问我机器学习，二面挂
3、猿辅导
感觉猿辅导的一面面试官和我学的不是一个java，总是质疑我回答的问题，后来问了一下舍友都说回答的没什么问题，写题的时候我用O(n)的复杂度，面试官让我尝试O(n^2)的复杂度，一面挂
4、华为西研所
西研所CBG云服务部主管面挂，用淘宝对比我做的项目，说我的项目不行。。。。。。。
秋招学习历程 **人菜就要多学习！**曾经也无数次担心基础不好和专硕时间短没时间准备而找不到工作，既然选择了改行，就只能咬牙坚持了，特别喜欢一句话：“努力交给自己，剩下的交给时间”。下面分享下我的金九银十备战资源库，有需要的直接转发本文后，
———————————————— 戳这里即可获取 闲言少叙，直接上干货：
一，2020年一线互联网大厂面试题及详析
二，源码笔记（图文结合）
四，“真”——互联网项目实战 随着5G时代的到来，人们生活节奏加快，大多数人习惯通过手机利用碎片时间来获取资讯。因此，人们对于移动资讯类应用的需求越来越高。仿头条项目正是在这样的背景下诞生，该项目致力于获取最新最热新闻资讯，通过大数据平台分析用户好，为用户精确推送资讯新闻。
1.采用使用 WEEX 跨终端开发语言与 VUE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/716594e3fcb0f73094dab32e98a999f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79342d25af8ac83c126e8108c41e1061/" rel="bookmark">
			微信公众号自动化上传图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.python+selenium，用默认浏览器打开，进入上传图片界面，点击按钮无反应。
F12进入，在network寻寻觅觅，也找不到那个上传图片的神秘url（爬虫靠它啊）。
2.python+appium,用appium-desktop进入微信公众号后，再想进一步点击进入，无法加载，即便加载，也无法定位。用上uiautomatorviewer也浪费表情。
3.用按键精灵吧，我实在想不出其它解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/526440f0e8d55ad2917908d2a3724344/" rel="bookmark">
			kotlin协程的理解与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 为什么在kotlin要使用协程呢，这好比去了重庆不吃火锅一样的道理。协程的概念并不陌生，在python也有提及。任何事务的作用大多是对于所依赖的环境相应而生的，协程对于kotlin这门语言也不例外。协程的优点，总的来说有如下几点：轻量级，占用更少的系统资源； 更高的执行效率； 挂起函数较于实现Runnable或Callable接口更加方便可控； kotlin.coroutine 核心库的支持，让编写异步代码更加简单。当然在一些不适应它的用法下以上优势也会成为劣势。
1.协程定义 协程定义:kotlin官方基于JVM的线程实现的一个并发任务处理框架，封装的线程api
使用方便，不使用回调实现线程切换,使用同步方式写出异步代码所有的耗时任务保证一定放在后台执行挂起函数执行完毕之后，协程会把它切换到原先的线程的线程。 2.协程的基本用法 常规函数中一般都有：call and return,协程在此之外添加了suspend和resume.
suspend 用于暂停执行的当前协程,并保存所有的局部变量resume 用于已暂停的协程中暂停出恢复 supend(挂起函数)是什么，有什么意义
suspend，对协程的挂起并没有实际作用，其实只是一个提醒，函数创建者对函数的调用者的提醒，提醒调用者我是需要耗时操作，需要用挂起的方式,在协程中使用.
需要注意的是挂起函数只能在挂起函数或者协程作用域中使用，为什么挂起函数需要在协程作用域中使用？因为普通函数没有suspend和resume这两个特性，所以必须要在协程的作用中使用。意义： 语法层面：作为一个标记和提醒。通过报错来提醒调用者和编译器，这是一个耗时函数，需要放在后台执行。
编译器层面：辅助 Kotlin 编译器来把代码转换成 JVM 的字节码。
怎么自定义suspend函数？什么时候定义？需要耗时操作的时候,需要定义,例如io耗时操作(请求网络)；获取数据库数据；一些等待一会需要的操作；列表排除，json解析等;怎么写suspend函数，给函数前加上suspend 关键字，把内容用withContext包起来 suspend fun testSuspendfun(){ withContext(Dispatchers.IO){ } } 协程如何确保主线程安全
Dispatchers.Main 调用程序在Android的主线程中Dispatchers.IO 适合主线程之外的执行磁盘或者网络io操作，例如文件的读取与写入，任何的网络请求Dispatcher.Default 适合主线程之外的，cpu的操作，例如json数据的解析，以及列表的排序， 协程的挂起本质：本质就是切线程，完成之后只不过可以自动切回来
协程挂起就是切个线程，在挂起函数执行完毕之后，协程会自动的重新切回它原先的线程，也就是稍后会被切回来的线程切换。切回来就是resume，恢复功能是协程，所以suspend函数需要在另一个suspend函数或者协程中调用。「非阻塞式挂起」阻塞的方式写出了非阻塞的方式。
3.协程的创建以及取消 //创建一个协程 Val scope = CoroutineScope(Dispatchers.Main+Job()) 通过Job获取协程的生命周期 scope.launch{ } 其他耗时请求，例如从数据库中获取数据 scope.async { } 在KTX库为某些生命周期提供自己的CoroutineScope，例如ViewModel中viewModelScope，Lifecycle有lifecycleScope
协程的启动，launch 启动新协程而不将结果返回给调用方
//创建之后，不管后续 launch(){ } async 启动一个新协程，并通过deferred的await方法暂停函数
//返回deferred 对象 val deferred async{ } deferred.await() 协程的结构化并发，取消协程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/526440f0e8d55ad2917908d2a3724344/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ddedc39d73f65bf7e6948e309a17a60/" rel="bookmark">
			ECharts 设置全圆形仪表盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 使用详解 （1）series.startAngle
说明：仪表盘起始角度。圆形正右手侧为 0 度，正上方为 90 度，正左手侧为 180 度。
（2）series.endAngle
说明：仪表盘结束角度。
2 原始效果图 3 实现代码（全圆形仪表盘） &lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 var option = { tooltip: { formatter: '{a} &lt;br/&gt;{b} : {c}%' }, series: [ { name: '业务指标', type: 'gauge', detail: {formatter: '{value}%'}, data: [{value: 45, name: '完成率'}], startAngle:0, endAngle:359.999, } ] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt; &lt;/body&gt; 4 最终效果图（全圆形仪表盘） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2169858b27a3b500794e75f39277d476/" rel="bookmark">
			Python崛起：“人生苦短，我用Python”并非一句戏言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习使你快乐
这些年，编程语言的发展进程很快，在商业公司、开源社区两股力量的共同推动下，涌现出诸如Go、Swift这类后起之秀，其中最为耀眼的是Python。
在这里还是要推荐下我自己建的Python开发学习群：725479218，群里都是学Python开发的，如果你正在学习Python ，小编欢迎你加入,大家都是软件开发党，不定期分享干货（只有Python软件开发相关的），包括我自己整理的一份2018最新的Python进阶资料和高级开发教程，欢迎进阶中和进想深入Python的小伙伴
知名开发者网站Stackoverflow撰文指出，从2012至2017年编程语言Python成为开发者使用增长最快的主流编程语言，其中2017年增长率达到了27%，一举超过包括**Java、C#、PHP、C++**在内的所有同类。另据高盛集团发布的一份《2017调查报告》针对全球数千名高校实习生的调查中，当问到你认为“哪个语言在未来会更重要”时，被调查的80、90后优秀年轻开发者中72%选了Python。
语言的使用者是一直被誉为业界上游“源头活水”的开发者，其重要程度从各大科技巨头公司每年例行召开的开发者大会上可见一斑。对于开发者群体而言最重要的事物有两个，一是平台，二就是编程语言。编程语言Python为什么能够获得全球众多开发者的青睐？它的崛起给开发者世界带来了什么变化？
● 成功的一半源于好的开始 在主流编程语言当中，Python并不是一个“新人”，它的历史超过25年，但真正风靡之时却是最近几年，所以“后起之秀”的称呼实至名归。Python的起源是1989年，其发明者荷兰人程序员吉多•范罗苏姆受ABC语言的启发计划开发一个新的脚本解释器，由此迈出了Python项目的起点。
Python能够真正风靡的原因之一是有一个好的起点。它的起步很稳，避开了版权纠纷，且搭上了开源运动的顺风车。在那个年代，商业版权一直是热门事件，业界史上第一个软件领域重大官司AT&amp;T和伯克利BSD的Unix版权案打得天昏地暗，该案的结局直接促成了BSD的开源分支、Linux的诞生以及震惊世界的自由软件运动。
Python最初的版权归属是CWI（阿姆斯特丹的国家数学与计算机科研学会），这与吉多早年在该机构工作有关，后来吉多受雇于CNRI（维吉尼亚州的国家创新研究公司），Python权属转移至此。那时自由软件运动已经开始，在CNRI期间发布的1.6至2.1多个版本的Python许可证是一种与GPL并不兼容且类似于BSD的开源许可，CNRI因受到自由软件基金会的压力释放了Python的原许可证，吉多由此掌握了主导权并起草了新的许可证。他改变了原许可证与GPL的不兼容，此举获得了自由软件基金会颁发的自由软件进步奖。再后来吉多和他的团队成立了Python软件基金会，将版权与许可证置于其下。
创始人吉多•范罗苏姆的心思缜密与灵活处事为Python最初的发展营造了良好的环境，包括几次权属的转移、起草新的许可证、机智地与自由软件阵营斡旋，最后安全融入开源的大潮。这一切为Python此后十多年里逐渐成长为主流编程语言赢得了契机。
● “人生苦短，我用Python”并非一句戏言
Python崛起的原因之二与其本身特点有关，或者说，其长期维护演进形成的独特风格迎合了大多数开发者的口味。在开发者社群流行着一句玩笑“人生苦短，我用Python”（原话为” Life is short, you need Python”），这句看似戏言的话实际上恰恰反映了Python的语言特性与其在开发者心里的价值分量。
除了包涵大多数主流编程语言的优点（面向对象、语法丰富）之外，Python的直观特点是简明优雅、易于开发，用尽量少的代码完成更多工作。尽管Python是一种解释型语言，与传统的编译型语言相比降低了机器执行效率，但是处理器的处理速率与环境速率（比如网络环境）的差异在大多数场景中完全抵消了上述代价；牺牲部分运行效率带来的好处则是提升了开发效率，在跨平台的时候无需移植和重新编译。 所以Python的显著优点在于速成，对于时间短、变化快的需求而言尤为胜任。
Python最强大的地方体现在它的两个外号上，一个叫“内置电池”，另一个是“胶水语言”。前者的意思是，Python官方本身提供了非常完善的标准代码库，包括针对网络编程、输入输出、文件系统、图形处理、数据库、文本处理等等。代码库相当于已经编写完成打包供开发者使用的代码集合，程序员只需通过加载、调用等操作手段即可实现对库中函数、功能的利用，从而省去了自己编写大量代码的过程，让编程工作看起来更像是在“搭积木”。除了内置库，开源社区和独立开发者长期为Python贡献了丰富大量的第三方库，其数量远超其他主流编程语言，可见Python的语言生态已然相当壮大。
“胶水语言”是Python的另一个亮点。Python本身被设计成具有可扩展性，它提供了丰富的API和工具，以便开发者能够轻松使用包括C、C++等主流编程语言编写的模块来扩充程序。就像使用胶水一样把用其他编程语言编写的模块粘合过来，让整个程序同时兼备其他语言的优点，起到了黏合剂的作用。正是这种多面手的角色让Python近几年在开发者世界中名声鹊起，因为互联网与移动互联时代的需求量急速倍增，大量开发者亟需一种极速、敏捷的工具来助其处理与日俱增的工作，Python发展至今的形态正好满足了他们的愿望。
● Python的影响 从两个著名编程语言排行网站TIOBE和PYPL的最新数据来看，Java与Python的排名分别位于第1和第5、第1和第2。关于两个网站的排行机制我们不得而知，但从开发者社群的相关评论中可以认为PYPL更能反映编程语言在开发者群体中的流行程度。不论如何，Python的崛起已是毋庸置疑的事实，而它上面的前辈则是常年占据榜单第1，互联网与移动时代的娇子Java。从Stackoverflow和多个开源社区公开的数据来看，Python的用户数量增长很快，在今后两年超过Java成为全球最流行编程语言的可能性非常之高。
值得一提的是，那些颇有影响力的主流编程语言，其背后一般都站着科技巨头公司，比如Java之于甲骨文、C#之于微软、Objective-C之于苹果。Java之所以常年第一是因为其同时还几乎是安卓平台的御用语言，以及受益于Sun时代影响力的眷顾。Python虽曾一度为谷歌使用，但Go语言问世后随着时间推移或将遇冷。也就是说，Python成了没有巨头站队的主流编程语言，那么它的影响力是如何维系的？为什么还能够保持高速成长并形成赶超Java之势？
我们认为这与Python多年来实现较好案例与范用性有关。可以添加我企鹅。柯西学习725479218。。使用Python开发的知名案例中，包括豆瓣、果壳、知乎、Dropbox、EVE（星战前夜）每一个都是重量级产品，这说明Python语言本身的发展已日臻完善，有着极高的稳定与可靠性保证。第二是Python的应用范围，除了日常工具和脚本之外，还适用于Web程序、GUI开发、操作系统中间件、服务端运维等等，这些年Python的一些第三方库在机器学习、神经网络方面活跃非凡，这也为语言本身的推广和流行加分不少。
最后需要指出的是，Python编程思想包含强烈的黑箱思维，这意味着开发者将愈加重视模块化和流水线式的编程工作，事实上这也是未来主流编程语言的发展趋向。随着计算机语言的演化和开发工具集成功能日趋强大，未来的编程工作将大幅简化。从某种角度看，Python更像是已经“迈入未来”的编程语言，其对开发者群体结构变化，以及新进开发者数量的激增，这些影响都将是深远的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f1262d165cedfe630b9e16fc7b74266/" rel="bookmark">
			移位运算（计算机组成原理15）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移位运算 视频链接地址： https://www.bilibili.com/video/BV1BE411D7ii?from=search&amp;seid=6420326887479343502 计算机组成原理 系列文章目录 移位运算前言1 移位运算1.1 算数移位1.1.1 原码的算数移位1.1.2 反码的算数移位1.1.3 补码的算数移位1.1.4 算数移位小结 1.2 逻辑移位1.3 循环移位 2 小结 前言 在本篇中，你将掌握
三种移位运算的方法：算数移位+逻辑移位+循环移位 对于定点数其表示有两种：无符号数和有符号数，其中有符号数又有原码、反码、补码、移码四种，本篇将学习四种码的运算。
在计算机中，使用移位便可实现 乘除法 = 移位 + 加法
1 移位运算 1.1 算数移位 算数移位，理解好位权和负数特殊的移位补位就可以掌握
1.1.1 原码的算数移位 对于原码的算数移位：
符号位不变，数值位右移，如上图。高位补0，低位舍弃，若舍弃的位=0，则相当于 ÷ 2；若舍弃的位=1，则会丢失精度，如 2 − 1 2^{-1} 2−1
符号位不变，数值位左移，同理。低位补0，高位舍弃，若舍弃的位=0，则相当于 × 2；若舍弃的位=1，则会出现严重误差（舍弃了最高位的1）
1.1.2 反码的算数移位 反码的算数移位，如上图，注意：
正数的反码 = 原码，移位同原码
负数的反码 = 原码数值位取反，负数反码移位运算规则为
右移：高位补1，低位舍弃
左移：低位补1，高位舍弃
1.1.3 补码的算数移位 正数的补码 = 原码，移位同原码
负数的补码 = 原码数值位取反+1，负数补码移位运算规则为
右移：同反码，高位补1，低位舍弃
左移：同原码，低位补0，高位舍弃
1.1.4 算数移位小结 正数的原码 = 补码 = 反码，补位都用0补负数的反码 = 原码数值位取反，补码 = 原码数值位取反+1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f1262d165cedfe630b9e16fc7b74266/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb4e2b12739a567c184cc1e480a95ae8/" rel="bookmark">
			消息队列调试工具MqTool v1.0免费版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MqTool(消息队列调试工具)Rab bitMQ、ActiveMQ消息队列调试工具用于调试MSMQ、Ra bbitMQ、ActiveMQ三种消息队列,其中MSMQ支持Active、Binary、XML格式,Ra bbitMQ支持逐条接发、批量接发、RPC回调模式、新建队列、建立持久化队列、连接测试等功能。
使用方法：
使用MqTool工具数据投放流程介绍
1.创建send目录文件：把环保给税务的xml文件放入Send目录
2.找到mqsend.properties文件
3.修改mqsend.properties文件，filepath=填写真实存放工具的目录
ip=填写前置机的地址
4.修改完mqsend.properties文件后，直接双击执行send.bat文件或者如下图CMD窗口执行
http://kk04.cn/f-6791.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/006d57f9d738f57329464def2cee7f20/" rel="bookmark">
			k8s---Kubectl 命令管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是kubectl：kubectl基本命令：创建 ：kubectl run命令删除：kubectl detele命令 项目周期：一．创建资源二．发布资源三．更新资源版本信息四．回滚资源版本信息五．删除资源信息六．查看具体资源的详细信息 什么是kubectl： ●kubectl是管理k8s集群的命令行工具，通过生成的json格式传递给apiserver进行创建，查看，管理的操作
●帮助操作：
[root@master02 ~]# kubectl --help kubectl controls the Kubernetes cluster manager. Find more information at: https://kubernetes.io/docs/reference/kubectl/overview/ Basic Commands (Beginner): ##初级指令 create Create a resource from a file or from stdin. ##创建资源 expose ##使用 replication controller, service, deployment 或者 pod 并暴露它作为一个 新的Kubernetes Service ##创建资源做端口映射，将服务暴露出去，方便别人访问 run ##在集群中运行一个指定的镜像 set ##为 objects 设置一个指定的特征（做版本设置的时候会用到） Basic Commands (Intermediate): ##中级指令 explain ##查看资源的文档，查看某个资源的文档信息 get ##显示一个或更多 resources资源 edit ##直接编辑运行过程中的资源 delete Delete resources by filenames, stdin, resources and names, or by resources and label selector ##删除资源 Deploy Commands: ##业务部署的指令 rollout Manage the rollout of a resource ##回滚，回滚到上一级 scale 为 Deployment, ReplicaSet, Replication Controller 或者 Job 设置一个新的副本数量 autoscale 自动调整一个 Deployment, ReplicaSet, 或者 ReplicationController 的副本数量 ##自动弹性伸缩 Cluster Management Commands: ##集群管理指令 certificate ##修改 certificate 资源.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/006d57f9d738f57329464def2cee7f20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc78bb1d5064f58021284407b92a464/" rel="bookmark">
			android 沙盒_我们分别测试了2020年排名前五的最佳android电视盒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android 沙盒
So once you have decided you want an android TV box. Now, all you have to do is pick from a plethora of available devices. When you start searching you would find out that there are a hundred different Android TV boxes available. All with different specifications and features. How to know which is right for you? In this post, learn about the ultimate five android TV boxes on the market.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcc78bb1d5064f58021284407b92a464/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d7f15fda27de5954afbdb027840cace/" rel="bookmark">
			oracle调用的sql文件必须以sql结尾
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我创建了一个sql文件，没有以sql为后缀，在调用的时候，会默认加sql后缀，然后报错说找不到文件，在sqlplus后面跟的@也是一样的，也会报同样的错误
SQL&gt; ! cat /tmp/get_inst_num_sql set head off; set pagesize 0; set feedback off; set sqlblanklines off; set newpage none; select max(inst_id) from gv$instance; exit; SQL&gt; @/tmp/get_inst_num_sql; SP2-0310: unable to open file "/tmp/get_inst_num_sql.sql" [oracle@slcm05adm04 bin]$ ./sqlplus "sys/cdb1@cdb1 as sysdba" @/tmp/get_inst_num_sql SQL*Plus: Release 21.0.0.0.0 - Development on Sat Oct 10 08:15:27 2020 Version 21.1.0.0.0 Copyright (c) 1982, 2020, Oracle. All rights reserved. Connected to: Oracle Database 21c Enterprise Edition Release 21.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d7f15fda27de5954afbdb027840cace/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eca4487a43ab7892914bb66e4b50ab15/" rel="bookmark">
			xpath解析html文件报错：lxml.etree.XPathEvalError: Invalid expression
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.反斜杠的问题：
错误示范：title = sel.xpath(’//div/h2/a text()’)
正确：title = sel.xpath(’//div/h2/a/text()’)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5450c64dab1bd057ae326f7f0652e50f/" rel="bookmark">
			MySQL系列复习（4）DDL常见操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、库的管理
1.1、创建库
1.2、删除库
1.3、建库通用的写法
1.4、示例
2、表管理
2.1、创建表
2.1.1、格式
2.1.2、注意
2.1.2、约束说明
2.2、删除表
2.3、修改表名
2.4、表设置备注
2.5、复制表
2.6、复制表结构+数据
3、表中列的管理
3.1、添加列
3.2、修改列
3.3、删除列
环境：mysql5.7.30，cmd命令中进⾏演⽰。
DDL：Data Define Language数据定义语⾔，主要⽤来对数据库、表进⾏⼀些管理操作。如：建库、删库、建表、修改表、删除表、对列的增删改等等。
⽂中涉及到的语法⽤[]包含的内容属于可选项，下⾯做详细说明。
1、库的管理 1.1、创建库 create database [if not exists] 库名 [default character set=utf8mb4];
1.2、删除库 drop database [if exists] 库名;
1.3、建库通用的写法 drop database if exists 旧库名;
create database 新库名;
1.4、示例 mysql&gt; drop database if exists test01; Query OK, 6 rows affected (0.17 sec) mysql&gt; show databases like 'test01'; Empty set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5450c64dab1bd057ae326f7f0652e50f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9293aa881cc4bfae931d0d16b8f15e60/" rel="bookmark">
			ECS_FML——小议中心极限定理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中心极限定理(CLT)是统计学中的一个基本定理，它是一个非常简单的概念。当你进一步阅读时就会发现，这也是一个很重要的概念。在阅读任何其他正态分布之前，必须了解一个先决条件概念，请阅读我关于正态分布的文章ECS_FML——小议高斯分布，它是中心极限定理的完美前传。
中心极限定理的准定义是：
中心极限定理（CLT）指出，如果样本量足够大，则变量均值的采样分布将近似于正态分布，而与该变量在总体中的分布无关。
解码晦涩的定义
让我们直接进入一些例子！
示例# 1
选取一个均匀分布[0,1]，它被称为均匀分布，因为在0和1之间选择值的概率相等，因此它的概率密度函数(PDF)是水平的直线。现在，让我们假设我们从这个分布中随机抽取20个样本(绿点)并计算这些样本的均值，我们得到一个值，在这个例子中是0.5，用虚线表示。让我们把这个平均值画在直方图上。由于这个柱状图到目前为止只有一个平均值，它并没有告诉我们任何其他信息（左图）。继续从相同的分布中提取更多的随机样本，计算各自的平均值并将这些平均值绘制在直方图上，我们开始得到一个有趣的结果。
随着我们从均匀分布中抽取越来越多的随机样本，并在直方图上绘制样本均值，我们得到一个正态分布结果如下(见右曲线)。
推论：
我们从均匀的数据分布开始，但是从中抽取的样本均值是正态分布。
例# 2
在第二个例子中，让我们按照与第一个例子相同的步骤，唯一的不同是我们这次要从指数分布中提取样本。
我们将再次随机抽取20个样本，计算样本的均值，并将其绘制在直方图上。计算100这样的样本的均值并将其画在直方图上，这样的分布对我们来说并不陌生。样本均值是正态分布！
推论：我们从指数数据分布开始，但从中抽取样本的均值得到正态分布。
我们从指数数据分布开始，但是从中抽取的样本均值得到正态分布。
因此，它在这一点上变得非常直观，中心极限定理意味着什么？
中心极限定理意味着即使数据分布不是正态的，从中抽取的样本均值的分布也是正态的。
知道样本均值总是正态分布的实际含义是什么？
在分析领域，我们每天都会遇到各种各样的数据，而源数据的分布并不总是被我们所知道的，但是，因为我们了解中心极限定理，所以我们甚至不需要关心源数据的分布，因为我们总是可以得到正态分布。
为了使中心极限定理能够起作用，我们必须能够计算出样本的平均值。有一个分布称为柯西分布，没有样本均值，从而中心极限定理论并不适用于它，但除了柯西分布，我没有遇到除中心极限定理以外的任何其他分布。)
下面是了解均值正态分布的实际含义：
我们可以用均值的正态分布来分配置信区间。我们可以进行T检验（即两个样本均值之间是否存在差异）我们可以进行方差分析（即3个或更多样本的均值之间是否存在差异）这篇文章涵盖了我们在处理数据和样本时应该知道的中心极限定理的整个理论。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/695476c7335c9c7388bb122e354ae5ef/" rel="bookmark">
			如何将两个.hex文件合成一个
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在写程序的时候，有时候有两个可执行文件的时候，都想使用里面的功能，但是源文件融合起来又感觉麻烦，这时候就要想到把两个.hex文件合成一个，也是可以使用的。
提示：在合并前，一下先备份，不然搞砸了，就没得后悔药啦。。。
1、首先打开一个.hex文件
文件的开始
文件的结束
2、再打开另一个.hex文件，把文件的开头和结尾去掉，复制中间的部分，再粘贴到打开第一个.hex文件结尾处的前面，保存成为新的.hex文件，在用工具下载进单片机即可。
文件的开头
文件的结尾
3、大功完成，开始测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e5eec683190cea1fb838c641c91c07f/" rel="bookmark">
			【大厂面试系列】吊打面试官之redis面试题（最新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 简单介绍一下 Redis 呗! 简单来说 Redis 就是一个使用 C 语言开发的数据库，不过与传统数据库不同的是 Redis 的数据是存在内存中的 ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。
另外，Redis 除了做缓存之外，Redis 也经常用来做分布式锁，甚至是消息队列。
Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。
2. 分布式缓存常见的技术选型方案有哪些？ 分布式缓存的话，使用的比较多的主要是 Memcached 和 Redis。不过，现在基本没有看过还有项目使用 Memcached 来做缓存，都是直接用 Redis。
Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。
分布式缓存主要解决的是单机缓存的容量受服务器限制并且无法保存通用的信息。因为，本地缓存只在当前服务里有效，比如如果你部署了两个相同的服务，他们两者之间的缓存数据是无法共同的。
3. 说一下 Redis 和 Memcached 的区别和共同点 现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！
共同点 ：
都是基于内存的数据库，一般都用来当做缓存使用。都有过期策略。两者的性能都非常高。 区别 ：
Redis 支持更丰富的数据类型（支持更复杂的应用场景）。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。Redis 有灾难恢复机制。 因为可以把缓存中的数据持久化到磁盘上。Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e5eec683190cea1fb838c641c91c07f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e0f232da7f72e446ff1cf1bcb69432b/" rel="bookmark">
			Pytorch-均方差损失函数和交叉熵损失函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		均方差损失函数mse_loss()与交叉熵损失函数cross_entropy() 1.均方差损失函数mse_loss() 均方差损失函数是预测数据和原始数据对应点误差的平方和的均值。
\[MSE=\frac{1}{N}( y^`−y)^2 \] N为样本个数，y'为预测数值，y为正确数值。
代码实例：
import torch import torch.nn.functional as F if __name__ == '__main__': data=torch.tensor([1.0,3.0]) loss=F.mse_loss(torch.tensor([1.0,1.0]),data) print(loss) # [(1-1)^2+(3-1)^2]/2 = 2 data1=torch.tensor([2.0,3.0]) loss=F.mse_loss(torch.tensor([1.0,1.0]),data1) print(loss) # [(2-1)^2+(3-1)^2]/2 = 2.5 输出结果
tensor(2.) tensor(2.5000) 2.交叉熵损失函数cross_entropy()：相比mse_loss()梯度更大了，优化更快了 先引入熵的概念，熵是衡量分布是否稳定的一个概念，衡量一个分布的信息熵的计算公式如下：log默认以2为底
\[Entropy(p)=-\sum_{i=1}^{n} p(i)log p(i) \] 衡量一个分布的信息熵的实例化代码如下：
import torch if __name__ == '__main__': # 交叉熵一般用于分类问题，如果下面四个数据代表四个类别的比例， # 四个类别的比例都相同，这里的熵很高，就不容易判断。 data=torch.tensor([0.25,0.25,0.25,0.25]) # 输出熵 print('data的熵为',-(data*torch.log2(data)).sum()) # 熵越高，越不容易确定 # 第四个类别的比例为0.97，这里的熵也很低，就比较容易确定。 data1=torch.tensor([0.01,0.01,0.01,0.97]) # 输出熵 print('data1的熵为',-(data1*torch.log2(data1)).sum()) # 熵越低，越容易确定 输出结果
data的熵为 tensor(2.) data1的熵为 tensor(0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e0f232da7f72e446ff1cf1bcb69432b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b74409330582d4a350346bcfc63aa107/" rel="bookmark">
			脏读幻读不可重复读的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
例如：
张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。
与此同时，
事务B正在读取张三的工资，读取到张三的工资为8000。
随后，
事务A发生异常，而回滚了事务。张三的工资又回滚为5000。
最后，
事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。
2、不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
例如：
在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。
与此同时，
事务B把张三的工资改为8000，并提交了事务。
随后，
在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。
3、幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。
例如：
目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。
此时，
事务B插入一条工资也为5000的记录。
这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcef10ddf0186d983e1f757a2a8fbc48/" rel="bookmark">
			freemarker 循环map里面的对象形式List
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.第一种：list里面嵌套一个map集合
java部分： // 重组数据并封装到list集合中 List&lt;LinkedHashMap&lt;String, String&gt;&gt; listInfo = new ArrayList&lt;&gt;(); LinkedHashMap&lt;String, String&gt; linkedMap = new LinkedHashMap&lt;&gt;(); linkedMap.put("元素", String.valueOf(100)); list.add(linkedMap); 取值部分： &lt;#list listInfo as linkedHashMap&gt; &lt;#list linkedHashMap?keys as itemKey&gt; ${linkedHashMap[itemKey]} &lt;/#list&gt;	&lt;/#list&gt; 第二种：list里面嵌套map集合，在map集合里面再次嵌套list集合 java部分： // 重组详细数据并封装到list集合中 List&lt;LinkedHashMap&lt;String, List&lt;LinkedHashMap&lt;String, String&gt;&gt;&gt;&gt; listMap = new ArrayList&lt;&gt;(); //定义重组详细数据list里面的map LinkedHashMap&lt;String, List&lt;LinkedHashMap&lt;String, String&gt;&gt;&gt; LinkedHashMap = new LinkedHashMap&lt;&gt;();//创建Map //定义重组详细数据list里面的map里面的list集合 List&lt;LinkedHashMap&lt;String, String&gt;&gt; linkedHashMap = = new ArrayList&lt;&gt;(); //定义重组详细数据list里面的map里面的list集合里面的map LinkedHashMap&lt;String, String&gt; linkedMap = new LinkedHashMap&lt;&gt;(); linkedMap.put("元素",String.valueOf(101)"); list.add(linkedMap); LinkedHashMap.put("上级元素", list); listMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcef10ddf0186d983e1f757a2a8fbc48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4370db36788e78d53a8cf3ab0b5ac5c/" rel="bookmark">
			spring事务的7种传播行为和5种隔离级别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 事务传播行为 事务传播行为(为了解决业务层方法之间互相调用的事务问题): 当事务方法被另一个事务方法调用时,必须指定事务应该如何传播。例如:方法可能继续在现有事务中运行,也可能开启一个新事务,并在自己的事务中运行。在TransactionDefinition定义中包括了如下几个表示传播行为的常量:
支持当前事务的情况: TransactionDefinition.PROPAGATION_REQUIRED: 如果当前存在事务,则加入该事务;如果当前没有事务,则创建一个新的事务。TransactionDefinition.PROPAGATION_SUPPORTS: 如果当前存在事务,则加入该事务;如果当前没有事务,则以非事务的方式继续运行。TransactionDefinition.PROPAGATION_MANDATORY: 如果当前存在事务,则加入该事务;如果当前没有事务,则抛出异常。(mandatory:强制性) 不支持当前事务的情况: TransactionDefinition.PROPAGATION_REQUIRES_NEW: 创建一个新的事务,如果当前存在事务,则把当前事务挂起。TransactionDefinition.PROPAGATION_NOT_SUPPORTED: 以非事务方式运行,如果当前存在事务,则把当前事务挂起。TransactionDefinition.PROPAGATION_NEVER: 以非事务方式运行,如果当前存在事务,则抛出异常。 其他情况: TransactionDefinition.PROPAGATION_NESTED: 如果当前存在事务,则创建一个事务作为当前事务的嵌套事务来运行;如果当前没有事务,则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。 隔离级别 TransactionDefinition 接口中定义了五个表示隔离级别的常量:
TransactionDefinition.ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别,Mysql 默认采用的REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别。TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别,允许读取尚未提交的数据变更,可能会导致脏读、幻读或不可重复读。TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据,可以阻止脏读,但是幻读或不可重复读仍有可能发生。TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同一字段的多次读取结果都是一致的,除非数据是被本身事务自己所修改,可以阻止脏读和不可重复读,但幻读仍有可能发生。TransactionDefinition.ISOLATION_SERIALIZABLE: 最高的隔离级别,完全服从ACID的隔离级别。所有的事务依次逐个执行,这样事务之间就完全不可能产生干扰,也就是说,该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc9afd2b806c68110c264af71f8078d/" rel="bookmark">
			【LaTeX】LaTeX打取整符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 中括号 [ x ] \left[ x \right] [x] \left[ x \right] 向下取整（取整）符号 ⌊ x ⌋ \lfloor x \rfloor ⌊x⌋ \lfloor x \rfloor 向上取整（取顶）符号 ⌈ x ⌉ \lceil x \rceil ⌈x⌉ \lceil x \rceil 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b839d2bec264362bff36b29ca90ef77/" rel="bookmark">
			命令行下安装并运行 Pycharm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 系统版本：
uname -a Linux violet 4.15.0-45-generic #48~16.04.1-Ubuntu SMP Tue Jan 29 18:03:48 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux 安装：
其实官网给了具体的教程了，传送门：https://www.jetbrains.com/pycharm/download/#section=linux
教程里面直接就写了需要用 snap 这个工具来安装 pycharm，那就先下载个 snap 好了，具体安装如下：
sudo apt install snapd snapd-xdg-open snap refresh sudo snap refresh // 这里我选择了安装社区版本的 pycharm sudo snap install pycharm-community --classic // 安装结果 violet@violet:$ sudo snap install pycharm-community --classic pycharm-community 2020.2.3 from jetbrains✓ installed 安装完成之后，怎么在命令行里面启动呢？
先找到 pycharm 的安装路径，我的路径如下，在对应的 bin 目录下直接 ./pycharm.sh 就能直接启动了
/snap/pycharm-community/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c03c1110e8b861c1e238ebe30b2c8b7/" rel="bookmark">
			平衡二叉查找树的插入删除查找操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、删除的节点可能是叶子节点，也有可能不是，不是的话就对要删除节点的子节点前序遍历找到后继节点
2、查询操作
二叉查找树的查询复杂度，和二分查找一样，插入和查找的时间复杂度均为 O(logn) ，但是在最坏的情况下仍然会有 O(n) 的时间复杂度（线性链表结构）。
由于普通二叉查找树会容易失去平衡，极端情况下二叉查找树会退化成线性的链表，导致插入查找复杂度变为O(N),所以引入了平衡二叉树（对左右子树的高度差进行限制）
3、
左旋
右旋
平衡二叉树插入操作以后不平衡问题：
不管是左旋还是右旋，旋转的目的都是将节点多的一支出让节点给另一个节点少的一支。
参考：https://blog.csdn.net/qq_25940921/article/details/82183093
左图在没插入前”19“节点前，该树还是平衡二叉树，但是在插入”19“后，导致了”15“的左右子树失去了”平衡“，所以此时可以将”15“节点进行左旋，让”15“自身把节点出让给”17“作为”17“的左树，使得”17“节点左右子树平衡，而”15“节点没有子树，左右也平衡了。（右边多左旋把右边的旋转到左边）如下图，
参考：https://blog.csdn.net/qq_25940921/article/details/82183093
这篇博客详细讲了左右旋的使用
总结一下就是：
左左，左右，右左，右右。
例如：在原来平衡二叉树基础上左子树节点下右子树下插入：左右
左左 右旋
左右 左旋 + 右旋
右左 右旋 + 左旋
右右 左旋
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24212969b16a4c238a39024ba12be4a9/" rel="bookmark">
			python实现百度语音合成(超详细！！)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SDK：软件开发工具包。一般都是一些软件工程师为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件时的开发工具的集合。
API：应用程序接口。是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。目的是提供应用程序与开发人员基于某软件或硬件得意访问一组例程的能力，而有无需访问原码，或理解内部工作机制的细节。
网站：https://ai.baidu.com
1.打开https://ai.baidu.com
点击‘开放能力’ 再点击‘在线合成’
2.点击‘技术文档’
3.左侧点击‘在线合成python—SDK’
主要理解一下下面的参考代码！
4.点击控制台
5.点击语音技术
6.登陆后点击创建应用
7.创建完成后查看创建的内容
8.安装 pip install baidu-aip
安装成功
完整代码如下：
# -*- coding: utf-8 -*- # import os from aip import AipSpeech # os.chdir(r'C:\Users\justb\Desktop\爬虫2') """ 你的 APPID AK SK """ APP_ID = '2279934' #自己的app——id API_KEY = 'Vs6emvyAHLfxQUPy9dRIe' #自己的API_KEY SECRET_KEY = 'NfVGMXBTKap5yvRQxMgphsqhXl0T' #SECRET_KEY client = AipSpeech(APP_ID, API_KEY, SECRET_KEY) s = '我是王然然，我的书，你看到了吗？' result = client.synthesis(s, 'zh', 1, { #zh代表中文 'vol': 5, }) #返回的是一个音频流，需要保存成mp3文件 # 识别正确返回语音二进制 错误则返回dict 参照下面错误码 if not isinstance(result, dict): with open('audio2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24212969b16a4c238a39024ba12be4a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd99f99b1633286e786d9fd7376c4e34/" rel="bookmark">
			CCS报错    creating output section XXXXXXXXX without SECTIONS specification 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是CMD的问题，标题中XXXXXXXXX可能为某段程序。在CMD文件中未定义程序存放的位置。
比如说，报了 creating output section csmpasswds without SECTIONS specification 的警告。
只需要打开CMD文件
在SECTIONS文件中加入 csmpasswds : &gt; RAML2, PAGE = 1即可；
SECTIONS { /* Setup for "boot to SARAM" mode: The codestart section (found in DSP28_CodeStartBranch.asm) re-directs execution to the start of user code. */ codestart : &gt; BEGIN, PAGE = 0 ramfuncs : &gt; RAMM0 PAGE = 0 .text : &gt; RAML0L1, PAGE = 0 .cinit : &gt; RAMM0, PAGE = 0 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd99f99b1633286e786d9fd7376c4e34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8b560aabb06801151736c92667f8468/" rel="bookmark">
			节约功耗去掉hbtp_daemon
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dbdb2622d5f1642ae80e5cd0ca29039/" rel="bookmark">
			ECS_FML——小议高斯分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来ECS一个礼拜了，FML上来就讲多元高斯分布，起初我是裂开的，因为好久没接触数学了，其次高斯分布听都没听说过（后来一查才知道，切，不就正态分布么qaq），但经过潇哥等大佬的帮助，以及查阅了一些资料后，慢慢开始复（预）习gay率论、线代等课程。 每个试图进入强大的数据科学世界的人都会遇到正态分布。在这篇文章中，我将以一种非常清晰的方式解释它到底是什么，我们如何解释它，以及为什么它作为一个每个数据科学家都必须意识到的概念具有巨大的重要性。
什么是正态分布？ 正态分布也被称为高斯分布或钟形曲线（因为它看起来像一个钟），这是统计学中最重要的概率分布，就像我们在大自然中经常看到的那样，它有点神奇。例如，身高、体重、血压、测量误差、智商得分等都服从正态分布。
还有一个跟它相关的，并且非常重要的概念，叫中心极限定理，这将在以后的文章中讨论。
现在，参考上面的图像，并了解一个正常变量的值是如何分布的。这是一个对称分布，其中大多数观测值聚集在具有最高发生概率的中心峰（均值/平均值）附近，并且当我们在两个方向上都偏离中心峰时，我们看到曲线尾部出现值的可能性越来越小。此图描绘了一个群体的智商水平，可以理解，智商水平非常低或智商水平很高的人很少见，并且大多数人都处于平均智商得分范围内。
我们周围的很多很多变量都可以用这个正态分布来描述。想想所有同事到达办公室所需要的时间，只有少数人会住在5分钟或2个多小时的距离内(尾部)。大多数人将在20分钟-70分钟的距离(即峰值附近的区域)。当你研究越来越多的正态分布的变量时，你会发现它无处不在。
正态分布的参数 正态分布总是以平均值为中心，而曲线的宽度则由标准差(SD)决定。
这是两个正态分布，x轴上的高度单位是英寸，y轴上是特定高度对应的人数。
婴儿的平均身高为20英寸（50cm），标准差为0.6英寸（1.5cm）。成年人的平均分布为70英寸（175cm），标准差为4英寸（10cm）了解正态分布标准差的意义在于，它遵循一个经验法则，即大约95%的测量值落在均值附近的+/- 2倍个标准差之间。
推论：
95%的人口落在平均值+/- 2*SD之间95%的婴儿身高在20 +/- 1.2英寸之间95%的成年人身高测量值在70 +/- 8英寸之间 正态分布的第一个参数是均值 均值或平均值是正态分布的集中趋势，它决定了曲线峰值的位置。平均值的变化导致曲线沿x轴水平移动。
正态分布的第二个参数是标准差SD 标准差是正态分布变异性的量度，它决定了曲线的宽度。SD值的变化导致曲线变得更窄或更宽，并对曲线的高度产生反比例的影响。
更紧的曲线(较小的宽度)-&gt;更高的高度更宽的曲线(更高的宽度)-&gt;更短的高度 现在，你已经了解了正态分布曲线的所有基础知识。让我们继续学习与之相关的其他重要信息。
所有正态分布的共同特征 它们都是对称的。平均值=中位数。根据经验法则，我们可以确定正态分布曲线离均值标准差范围内的数据百分比。 通过一个示例，这一点将变得更加清楚。
让我们来看一个披萨外卖的例子。假设一家披萨餐厅的平均配送时间为30分钟，标准偏差为5分钟。根据经验法则，我们可以确定68%的交付时间在25-35分钟(30 +/- 5)之间，95%在20-40分钟(30 +/- 2*5)之间，99.7%在15-45分钟(30 +/-3*5)之间。
当我们知道如何将统计应用于现实生活中的问题时，看到事情变得多么直观了吗？
在这篇文章的最后一部分，我们将学习正态分布的一个特例
标准正态分布：正态分布的特例 如前所述，正态分布根据参数值(平均值和标准差)有许多不同的形状。标准正态分布是正态分布的一个特例，均值为0，标准差为1。这个分布也称为Z分布。
标准正态分布上的值称为标准分数或Z分数。标准分数表示某一特定观测值高于或低于平均值的SD数。
例如，标准得分为1.5表示观察到的结果比平均值高1.5个标准差。另一方面，负分数表示低于平均值的值。平均值的Z分数为0。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8001b8cacd3787b4320281998c7b90ba/" rel="bookmark">
			深度学习领域专业词汇_深度学习时代的人文领域专业知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习领域专业词汇
It’s a bit of an understatement to say that Deep Learning has recently become a hot topic. Within a decade alone, the field has made significant strides on problems once thought to be impossible, including facial recognition, generating text that mimics human writing, making art, and playing games involving strategy and intuition.
我T的有点轻描淡写地说，深学，最近成为热门话题。 仅在十年内，该领域就在人们认为不可能的问题上取得了长足的进步，包括面部识别，生成模仿人类文字的文字，制作艺术品以及玩涉及策略和直觉的游戏。
Given the buzz surrounding the (seemingly unreasonable) effectiveness of these algorithms, it’s easy to get lost in the extremes of speculation and skepticism towards Deep Learning.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8001b8cacd3787b4320281998c7b90ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/406a2c54414eecb80ba5e6e36cfd6619/" rel="bookmark">
			聊天产生器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Is Artificial Intelligence(AI) making us lazy or efficient?
人工智能(AI)使我们变得懒惰还是高效？
I think it’s making us efficient. Due to COVID-19, people are more often found interacting with their peers via social media and text messages. For instance, my push notifications are up by 37%, and positively enough I have reconnected with my school friends, old friends per se. However, this arose a problem of constantly sticking to my phone and suffering from Nomophobia and Phantom vibration syndrome.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/406a2c54414eecb80ba5e6e36cfd6619/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c57005702babe1629664475661666d/" rel="bookmark">
			针对iframe底部留白问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来聊一下。之前做的专题因为有过改底部公司名称的问题，一下让小伙伴刷了好几百个专题的底部，后来决定将以后的所有专题底部都搞为公共的，所以启用了好久不用的iframe，一切正常的之后，隐约发现了一个小bug，就是底部出现了一条横线，那么针对这一个问题有了一个简单的解决办法。
先上一段代码
&lt;iframe src="http://www.yc-wr.com" style="width: 100%;border: none;height: 218px;vertical-align:bottom;"&gt; &lt;/iframe&gt; 其实很常规吧，其实最重要的一点就是一个样式，那就是加了一个这个样式vertical-align:bottom;
完美解决。。。。吼吼
希望可以帮助那些同样遇到这个问题的小伙伴们。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8353656c878e53efdea4e77a1df5f7f/" rel="bookmark">
			ArcGIS中，一个点集里的点两两连线，比如有4个点，就连3&#43;2&#43;1=6条线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载于https://www.cnblogs.com/orchidLan/p/8903588.html。
一、目标
一个点集里的点两两连线，比如有4个点，则连3+2+1=6条线；有38个点，则连37+36+35+···+3+2+1=703条线，其原始坐标数据及最终样式类似于以下这种：　→↓
二、总体思路
使用arcgis中的XY To Line工具，如下图所
其中，Start X Field、Start Y Field、End X Field、End Y Field分别为起点和终点的坐标值，Line Type为要构建的大地测量线的类型，包括GEODESIC（默认）、GREAT_CIRCLE、RHUMB_LINE、NORMAL_SECTION这四种构造方法，ID为输入表中的字段，此字段和坐标值包含在输出中，可用于将输出要素与输入表中的记录相连接。Spatial_Reference为空间参考。
可以看到，要准备的数据是包含起点和终点坐标值、ID的一张表。
三、表数据准备
（一）坐标值数据准备
首先，是要将Start X、Start Y合并，为了便于区分，将StationName也合并到一个单元格。即在XYOld列中，即D2单元格输入“=A2&amp;","&amp;B2&amp;","&amp;C2”，并下拉至列尾；
其次，将D列复制到E列（XYOldCopy）；
（二）坐标值排列组合
对D列和E列进行排列组合。右键左下方sheet1名称（本例为PointstoTest）→查看代码→在弹出的对话框中粘贴如下代码：
Sub 两列组合() 'EXCEL880.COM产品,2017-7-12 Dim n1, n2, arr, brr, i, j, k n1 = [D65536].End(xlUp).Row n2 = [E65536].End(xlUp).Row arr = Range("D2:D" &amp; n1) brr = Range("E2:E" &amp; n2) ReDim crr(1 To n1 * n2, 0) Dim dic Set dic = CreateObject("scripting.dictionary") For i = 1 To UBound(arr) For j = i + 1 To UBound(brr) Key = arr(i, 1) &amp; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8353656c878e53efdea4e77a1df5f7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10812385f5e1e37268c583089506ca77/" rel="bookmark">
			MRT(MODIS Reprojection Tool)安装、影像批量拼接、重投影和格式转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文首发于https://www.cnblogs.com/orchidLan/p/7210448.html。
一、安装MRT(MODIS Reprojection Tool)
安装准备：检查是否安装java.exe。Java版本至少为Java 2 Runtime Environment version 1.5或者是Java 2 SDK version 1.5或者更高的版本。在Windows平台中可以通过开始/搜索并输入java.exe来检查自己的电脑是否安装有java，也可以不检查直接重新安装一份。
解压安装包MRT_download_&lt;platform&gt;.zip。包含四个文件：mrt_install.bat，MRT_&lt;platform&gt;.zip，reg_set.exe， 以及unzip.exe。
双击mrt_install.bat，并按提示完成安装。
注：下载地址为https://lpdaac.usgs.gov/tools/modis_reprojection_tool，要先注册账号才能下载，注册的时候最好用国外邮箱，如雅虎什么的，反正QQ，163邮箱收不到验证链接。
二、使用MRT(MODIS Reprojection Tool）
(一）GUI界面操作 安装完成后，打开MRT的安装路径文件夹，打开bin文件夹，双击ModisTool.bat或者ModisTool.jar即可进 入MRT的GUI界面。
输入MODIS数据，选择输出NDVI和EVI，指定输出路径输出文件格式为GEOTIFF，采样方式为最近邻，投影类型为Albers Equal Erea，输出像元大小为250m，然后直接点击run就可以了。其中，投影参数设置见下图（STDPR1第一条标准纬线25，STDPR2第二条标准纬线为47，CentMer中央经线为105，datum基准面WGS84）：
（二）批处理拼接之一年以内的数据
备注：该操作数据及BAT文件须放在一个文件夹下（文件夹起名请用英文，MRT对中文路径数据会打不开）。
操作步骤:
1.新建一个DATA文件夹，将HDF数据拷到DATA文件夹下;
2.在DATA文件夹下再新建个Result文件夹（存放拼接后数据）;
3.将以下代码内容粘到一个TXT文件中，更改TXT文件扩展名为BAT即可，假设你命名该BAT文件名为MOSAIC.BAT；
4：点击MOSAIC.BAT，即可进行拼接操作。
注意：第一行代码里，把MRTDATADIR替换为你自己的MRTDATADIR名称，MRTDATADIR名称可以在安装目录里，找到ModisTool.bat，然后右键选择编辑中查看；
此外以下代码未考虑中间天数间断的情况，比如对MODIS时间分辨率为16天的数据，在一个应连续的等差数列中间有数据缺失，存在相差32天的情况，可能会报错，请注意。
set MRTDATADIR=f:\MOD_HDE_SOURCE set /a DAY=2000049 rem ***开始日期*** set /a DEADLINE=2000353 rem ***结束日期*** :start if %DAY% leq %DEADLINE% (goto ORDER) else exit :ORDER rem **将当天的图幅数据文件名放在一个TXT文件中** dir *%DAY%.*.hdf/a/b/s &gt; MOSAICINPUT.TXT rem **拼接HDF12种数据中的第一种** d:/software_install/MRT/bin/mrtmosaic.exe -i MOSAICINPUT.TXT -s "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10812385f5e1e37268c583089506ca77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc047d37fb9c4a47669094d66b8c1594/" rel="bookmark">
			ENVI中批量转TIFF，Arcgis批量地理校正
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载于https://www.cnblogs.com/orchidLan/p/8886750.html。
一、数据介绍
本次使用的数据为时空连续臭氧产品，从武汉大学“地学感知数据质量改善与融合应用研究室”网站（网址：http://sendimage.whu.edu.cn/send-resource-download/）下载，它是“利用发展的遥感信息重建理论与方法，基于Aura卫星上OMI传感器的臭氧总量三级产品OMTO3e，通过对该产品的缺失信息进行重建与修复，生成了全球（2004-2014）最高分辨率的时空连续臭氧制图产品。”——来自官网介绍。产品经解压后如下所示： 将上面的数据从ENVI里导出为TIFF，并在Arcgis中打开后如下所示，与左下方标准坐标数据（绿色坐标）在地理空间上不匹配，无法进行下一步处理：
由于数据量比较大，一个一个地georeferencing比较麻烦，因此需要采用批量处理的方法。
二、总体处理思路
首先是要在ENVI中，将图1所示的原始文件批量转换为TIFF，再在arcgis中批量地理校正。
三、ENVI中批量转TIFF
新建TXT文件，并重命名为“ENVIRaster_Study.pro”，用记事本或者notepad++或其他软件打开后，输入以下代码，其中第17行的输出文件路径根据实际情况调整。
PRO ENVIRaster_Study e = ENVI() ; Launch the application inputfilefolder=dialog_pickfile(/directory,title='Choose the input directory!');选择输入文件夹 inputfilefolderfiles=file_search(inputfilefolder,'*filled',count=num);读取文件夹下的文件 for j=0,num-1 do begin inputfile=inputfilefolderfiles[j] raster1 = e.OpenRaster(inputfile) ; 读入文件 inputfilesplit = strsplit(inputfile,'\',/extract) ;这里inputfile类似于"F:\Zhanglan\Postgraduate\Zhoumen\Tongji\OMIO3\2004m1001-TFFSRC_filled"这样的字符串 ;将字符串以"\"符号打断,以便取最后一个"\"后的字符串"2004m1001-TFFSRC_filled"经变换后做输出文件名 outputfilename=inputfilesplit[N_ELEMENTS(inputfilesplit)-1];取打断后最后一个"\"后的字符串做输出文件名 filepath_output = 'F:\Zhanglan\Postgraduate\Zhoumen\Tongji\O3Project\FN'+outputfilename+'.tif' ; 输出文件路径 raster1.Export, filepath_output, 'TIFF'; 输出为tiff格式 Print,'finished' ;打印finished，提示完成 endfor end 保存文件后，双击打开（前提是安装了IDL），这时IDL会自动打开pro文件，点击“运行”，这时等待几秒到十几秒，IDL会自动打开ENVI 并弹出“choose the input directory！”对话框，选择要处理的数据所在的文件夹，即可。运行结果如下图所示：
四、ArcGIS中批量进行地理校正
经第三步转换后的TIFF文件，在ArcGIS中打开后，如第二张图所示，丢失了地理坐标信息，无法与正确的地理坐标匹配，所以，还需要进行地理校正。
传统的方法是使用georeferencing手动校正，这无法满足大量数据均需要校正的要求，所以，使用Python脚本做批量处理。
大致方法是在ArcMap中新建toolbox，右键新建的toolbox/add/script，添加写好的脚本。然后，再右键新建的toolbox/new/model，新建一个model，并把添加的脚本拖进model里，点击Model/Run Entire Model即可。具体自行百度。
脚本如下，其中source_pnt为待校正图像的四至点，target_pnt为要校正到的四至点（目标四至点or正确的四至点）：
try: import arcpy arcpy.env.workspace = r"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc047d37fb9c4a47669094d66b8c1594/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4edc151bcc6bb94b178d13a8bb5e05cf/" rel="bookmark">
			解决iframe引入视频黑屏但有声音的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决iframe引入视频黑屏但有声音的问题
&lt;script&gt; window.onload = function () { document.getElementsByTagName('body')[0].style.zoom=0.999; } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fe0677a432adf7de9432ee3aa58d342/" rel="bookmark">
			el-input输入框设置不能输入空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果要使文本框不可添加空格
就在中的v-model后面+.trim
这个maxlength是限制输入框内最多输入多少字数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e272788b20c2302df4b7925546fa0c1/" rel="bookmark">
			maven安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载maven到/usr/local wget https://archive.apache.org/dist/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz 2.解压 tar -zxvf apache-maven-3.5.4-bin.tar.gz 3.编辑配置文件，添加环境变量 vi /etc/profile 添加如下信息
#set Maven environment export M2_HOME=/usr/local/apache-maven-3.5.4 export PATH=${M2_HOME}/bin:$PATH 如下图所示
4.重启配置文件 source /etc/profile 5.查看是否成功 mvn -v 6.配置maven 修改apache-maven-3.5.4/conf/settings.xml a.修改maven阿里源
在 &lt;mirrors&gt;标签下添加：
&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 如下图所示：
b.修改本地仓库地址
创建/usr/local/maven-repo 文件夹
在 &lt;settings&gt;标签下添加：
&lt;localRepository&gt;/usr/local/maven-repo&lt;/localRepository&gt; 如下图所示：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/411/">«</a>
	<span class="pagination__item pagination__item--current">412/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/413/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>