<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3c40204108f3a2d7c283beaf4a8ea94/" rel="bookmark">
			正确修改Oracle数据库的默认账号密码的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建表空间和用户时，需要的时候竟然忘记了密码，试了好多次都没连接上，进而用户也被锁定，下面就教您处理Oracle默认用户的密码问题的方法，希望对和我一样情况的朋友们有所帮助。
1.安装时选择的自动安装，忘了用户名和密码导致现在试了几个Oracle默认用户名密码後（表格中附带默认用户名及密码），都提示无效的用户名、密码， Username Password Description See Also CTXSYS CTXSYS The Oracle Text account Oracle Text Reference DBSNMP DBSNMP The account used by the Management Agent component of Oracle Enterprise Manager to monitor and manage the database Oracle Enterprise Manager Grid Control Installation and Basic Configuration LBACSYS LBACSYS The Oracle Label Security administrator account Oracle Label Security Administrator's Guide MDDATA MDDATA The schema used by Oracle Spatial for storing Geocoder and router data Oracle Spatial User's Guide and Reference MDSYS MDSYS The Oracle Spatial and Oracle interMedia Locator administrator account Oracle Spatial User's Guide and Reference DMSYS DMSYS The Oracle Data Mining account.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3c40204108f3a2d7c283beaf4a8ea94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ea45a0271af25155773d43680dc3a40/" rel="bookmark">
			C&#43;&#43; 调用c#DLL函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己实践了一下，其实不是很难，怕自己忘记掉，再加上有几个需要注意的问题，这里记录下来。
1. c# 创建dll library
using System;using System.Collections.Generic;using System.Text;namespace AddDll{public class Add{public int iadd(int a, int b){int c = a + b;return c;}}} 2. c++实现调用程序
这里创建一个Win32的控制台应用程序
Configure：右键点击解决方案资源管理器中的UseDll，选择“属性”，将公共语言运行库支持设置为“公共语言运行库支持(/clr)” 即Common Language Runtime Support (/clr)
PS：如果你是建立一个MFC程序的话，必须把Use of MFC设置成：Use MFC in a Shared DLL 共享dll，不然会引起冲突
（error D8016: '/clr' and '/MTd' command-line options are incompatible 错误）
#include "stdio.h"#using "..\debug\AddDll.dll"using namespace AddDll;int main(){int result;Add ^add = gcnew Add(); //生成托管类型//gcnew creates an instance of a managed type (reference or value type) on the garbage //collected heap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ea45a0271af25155773d43680dc3a40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4511885bec34af58406dae2efe777fc/" rel="bookmark">
			LaTeX技巧189：LaTeX括号总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 \begin{longtable}{l} [1] 你好啊。 \\ [2] 吃了没？ \\ \end{longtable}
功能语法显示不好看 (\frac{1}{2} )好一点\left( \frac{1}{2} \right) 您可以使用\left和\right来显示不同的括号：
功能语法显示圆括号，小括号\left( \frac{a}{b}\right)方括号，中括号\left[ \frac{a}{b}\right]花括号，大括号\left\{ \frac{a}{b}\right\}角括号\left \langle \frac{a}{b} \right\rangle单竖线，绝对值\left| \frac{a}{b}\right|双竖线，范\left \| \frac{a}{b} \right\|取整函数
（Floor function）\left \lfloor \frac{a}{b} \right\rfloor取顶函数
（Ceiling function)\left \lceil \frac{c}{d} \right\rceil斜线与反斜线\left / \frac{a}{b} \right\backslash上下箭头\left \uparrow \frac{a}{b} \right\downarrow\left \Uparrow \frac{a}{b} \right\Downarrow\left \updownarrow \frac{a}{b} \right\Updownarrow混合括号\left [ 0,1 \right )
\left \langle \psi \right |
单左括号\left \{ \frac{a}{b} \right .单右括号\left . \frac{a}{b} \right \} 备注：
可以使用\big, \Big, \bigg,\Bigg控制括号的大小，比如代码\Bigg (\bigg [ \Big \{\big \langle \left | \| \frac{a}{b} \| \right |\big \rangle \Big \}\bigg ] \Bigg )显示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5c76a1b7bc0aab9aa395812c3cea16a/" rel="bookmark">
			管程机制浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 管程的概念
1. 管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。
2. 进程只能互斥得使用管程，即当一个进程使用管程时，另一个进程必须等待。当一个进程使用完管程后，它必须释放管程并唤醒等待管程的某一个进程。
3. 在管程入口处的等待队列称为入口等待队列，由于进程会执行唤醒操作，因此可能有多个等待使用管程的队列，这样的队列称为紧急队列，它的优先级高于等待队列。
二、 管程的特征
1. 模块化。
管程是一个基本的软件模块，可以被单独编译。
2. 抽象数据类型。
管程中封装了数据及对于数据的操作，这点有点像面向对象编程语言中的类。
3. 信息隐藏。
管程外的进程或其他软件模块只能通过管程对外的接口来访问管程提供的操作，管程内部的实现细节对外界是透明的。
4. 使用的互斥性。
任何一个时刻，管程只能由一个进程使用。进入管程时的互斥由编译器负责完成。
三、 enter过程、leave过程、条件型变量c、wait(c) 、signal(c)
1. enter过程
一个进程进入管程前要提出申请，一般由管程提供一个外部过程--enter过程。如Monitor.enter()表示进程调用管程Monitor外部过程enter进入管程。
2. leave过程
当一个进程离开管程时，如果紧急队列不空，那么它就必须负责唤醒紧急队列中的一个进程，此时也由管程提供一个外部过程—leave过程，如Monitor.leave()表示进程调用管程Monitor外部过程leave离开管程。
3. 条件型变量c
条件型变量c实际上是一个指针，它指向一个等待该条件的PCB队列。如notfull表示缓冲区不满，如果缓冲区已满，那么将要在缓冲区写入数据的进程就要等待notfull，即wait(notfull)。相应的，如果一个进程在缓冲区读数据，当它读完一个数据后，要执行signal(notempty)，表示已经释放了一个缓冲区单元。
4. wait(c)
wait(c)表示为进入管程的进程分配某种类型的资源，如果此时这种资源可用，那么进程使用，否则进程被阻塞，进入紧急队列。
5. signal(c)
signal(c)表示进入管程的进程使用的某种资源要释放，此时进程会唤醒由于等待这种资源而进入紧急队列中的第一个进程。
四、 应用实例
案例一：生产者消费者问题。生产者进程将产品放入某一缓冲区，消费者进程到此缓冲区中取产品。这个过程必须保证：1. 当缓冲区有剩余空间时，生产者才能在其中放入产品；2. 当缓冲区有数据时，消费者才能在其中取出产品。
解决方案：使用管程机制来实现生产者和消费者之间的同步互斥问题
1. 假设有一基本管程monitor，提供了enter、leave、signal、wait等操作；
2. 条件变量notfull表示缓冲区不满，条件变量notempty表示缓冲区不空；
3. 缓冲区buff[0...n-1]用来存放产品，最大可放n件产品；
4. 定义整型变量count表示缓冲区当前的产品数，指针in指向缓冲区当前第一个空的位置，指针out指向缓冲区当前第一个不空的位置；
5. 定义过程add(ItemType item)
add(ItemTypeitem) //生产者进程在缓冲区放入产品
{
if(count==n) wait(notfull);
//如果此时缓冲区已满，那么进程必须等待notfull，这意味着进程已经被阻塞到紧急队列里
buff[in]=item; //否则在第一个空的位置放入产品
in=(in+1)%n; //指针循环加1
count++; signal(notempty); //此时缓冲区已经多了一个产品，也就是说生产者进程去唤醒因取不到产品被阻塞的消费者进程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5c76a1b7bc0aab9aa395812c3cea16a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/345591843f6117d66e7c3724d2a3431a/" rel="bookmark">
			宏定义中的#、##和#@符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、# 字符串化操作符
其作用是：将宏定义中的传入参数名转换成用一对双引号括起来的参数名字符串。
其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。
如：
#define TEST_MACRO1(para) printf("Welcome to the C world, %s!\n", #para)
当使用该宏定义时：
TEST_MACRO1(ligt);
在编译时将会展开成:printf("Welcome to the C world, %s!\n", "ligt");
注意（对空格的处理）：
（1）忽略传入参数名前面和后面的空格，如：
TEST_MACRO1( ligt );也会被展开成:printf("Welcome to the C world, %s!\n", "ligt");
（2）当传入参数名间存在空格时，编译器将会自动连接各个子字符串，并以一个空格连接各个子字符串，
忽略其中多余的空格，如：
TEST_MACRO1( know pig xia );被展开成:printf("Welcome to the C world, %s!\n", "know pig xia");
2、## 符号连接操作符
宏定义中，参数名即为形参，如:#define sum(a, b) ((a) + (b))
其中a和b均为某一参数的代表符号，即形式参数。而##的作用则是将宏定义中的多个形参组成一个实际参数名。
如：
char *username1 = "ligt";
#define TEST_MACRO2(para) printf("Welcome to the C world, %s!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/345591843f6117d66e7c3724d2a3431a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eec9726d31e26e7ca114850af8a0021e/" rel="bookmark">
			由system.currentTimeMillis() 获得当前的时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。
currentTimeMillis方法
public static long currentTimeMillis()
该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。
可以直接把这个方法强制转换成date类型。
代码如下：
long currentTime = System.currentTimeMillis();
SimpleDateFormat formatter = new SimpleDateFormat("yyyy年-MM月dd日-HH时mm分ss秒");
Date date = new Date(currentTime);
System.out.println(formatter.format(date));
运行结果如下：
当前时间:2011年-08月10日-14时11分46秒
另：
可获得当前的系统和用户属性：
String osName = System.getProperty(“os.name”);
String user = System.getProperty(“user.name”);
System.out.println(“当前操作系统是：” + osName);
System.out.println(“当前用户是：” + user);
System.getProperty 这个方法可以得到很多系统的属性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a90da987cb6a62e0953013a7e804810/" rel="bookmark">
			C、C&#43;&#43;、Java语言中异常处理机制浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C、C++、Java语言中异常处理机制浅析
一、 异常处理 (ExceptionalHandling)概述
1. 异常处理
异常处理又称异常错误处理，它提供了处理程序运行时出现任何意外或异常情况的方法。异常处理通常是防止未知错误的发生所采取的处理措施，对于某一类型的错误，异常处理应该提供相应的处理方法。例如，在设计程序时，如果可能会碰到除0错误或者数组访问越界错误，程序员应该在程序中设计相应的异常处理代码以便发生异常情况时，程序做出相应的处理。
2. 异常处理的两类模型
（1）终止模型
在这种模型中，异常是致命的，它一旦发生，将导致程序终止。这种模型被C++和Java语言所支持。
（2）恢复模型
当发生异常时，由异常处理方法进行处理，处理完毕后程序返回继续执行。
二、 C语言异常处理
1. 常用方法
（1）使用abort()和exit()两个函数，他们声明在&lt;stdlib.h&gt;中；
（2）使用assert宏调用，它位于&lt;assert.h&gt;中。assert(expression)当expression为0时，就好引发abort()；
（3）使用全局变量errno，它由C语言库函数提供，位于&lt;errno.h&gt;中；
（4）使用goto语用局部跳转到异常处理代码处；
（5）使用setjmp和longjmp实现全局跳转，它们声明&lt;setjmp.h&gt;中，一般由setjmp保存jmp_buf上下文结构体，然后由longjmp跳回到此时。
2. 实例演示
实例一 ：使用exit()终止程序运行
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
voidDivideError(void)
{
printf("divide 0 error!\n");
}
doubledivide(double x,double y)
{
if(y==0) exit(EXIT_FAILURE);//此时EXIT_FAILURE=1
//也可以使用atexit()函数来注册异常处理函数,但此时异常处理函//数必须形如voidfun(void);
else return x/y;
}
intmain()
{
double x,y,res;
printf("x=");
scanf("%lf",&amp;x);
printf("y=");
scanf("%lf",&amp;y);
atexit(DivideError);
res=divide(x,y);
printf("result=%lf\n",res);
return 0;
}
实例二：使用assert(expression)
#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;
intmain()
{
int a,b,res;
res=scanf("%d,%d",&amp;a,&amp;b);
//scnaf函数返回从stdin流中成功读入的数据个数
assert(res==2); //如果res!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a90da987cb6a62e0953013a7e804810/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d6658bc343eac99db6472202c3afef/" rel="bookmark">
			如何更改linux文件的拥有者及用户组(chown和chgrp)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文整理自： http://blog.163.com/yanenshun@126/blog/static/128388169201203011157308/
http://ydlmlh.iteye.com/blog/1435157
一、基本知识
在Linux中，创建一个文件时，该文件的拥有者都是创建该文件的用户。该文件用户可以修改该文件的拥有者及用户组，当然root用户可以修改任何文件的拥有者及用户组。在Linux中，对于文件的权限（rwx），分为三部分，一部分是该文件的拥有者所拥有的权限，一部分是该文件所在用户组的用户所拥有的权限，另一部分是其他用户所拥有的权限。对于文件的权限请参考《Linux的chmod命令》
文件（含文件夹，下同）的权限，在shell中可以通过chmod命令来完成，关于此请参考《Linux的chmod命令》。在 shell 中，可以使用chown命令来改变文件所有者及用户组，chgrp命令来改变文件所在用户组。在 Linux的C程序中，可以使用chown函数来改变文件所有者，及所在用户组。
另外，在shell中，要修改文件当前的用户必须具有管理员root的权限。可以通过su命令切换到root用户，也可以通过sudo获得root的权限。
二、使用chown命令更改文件拥有者
在 shell 中，可以使用chown命令来改变文件所有者。chown命令是change owner（改变拥有者）的缩写。需要要注意的是，用户必须是已经存在系统中的，也就是只能改变为在 /etc/passwd这个文件中有记录的用户名称才可以。
chown命令的用途很多，还可以顺便直接修改用户组的名称。此外，如果要连目录下的所有子目录或文件同时更改文件拥有者的话，直接加上 -R的参数即可。
基本语法：
chown [-R] 账号名称 文件或目录
chown [-R] 账号名称:用户组名称 文件或目录
参数：
-R : 进行递归( recursive )的持续更改，即连同子目录下的所有文件、目录
都更新成为这个用户组。常常用在更改某一目录的情况。
示例1：
[root@localhost home]# touch testfile //由 root 用户创建文件 [root@localhost home]# ls testfile –l -rw--w--w- 1 root root 0 Jun 7 19:35 testfile //文件的拥有者及拥有者级均为 root [root@localhost home]# chown yangzongde testfile //修改文件拥有者为 yangzongde [root@localhost home]# ls testfile -l -rw--w--w- 1 yangzongde root 0 Jun 7 19:35 testfile //查看文件拥有者为 yangzongde，但组仍为 root 示例2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96d6658bc343eac99db6472202c3afef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f8c3a376b012fc70353980e0e0b1a9/" rel="bookmark">
			一起来学Ajax(一)之初识Ajax
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天正在学ASP.NET Ajax，学的有点迷糊，所以决定先学Ajax，再向ASP.NET Ajax过渡，本文将带大家初识Ajax，从宏观上看Ajax，再从细节部分学习，文章脉络如下。
Ajax定义Ajax组成XMLHttpRequest
常见Ajax使用Ajax客户端生命周期实现原理一个简单的实例 Ajax定义
Ajax是Asynchronous JavaScript and XML(异步JavaScript和XML)的缩写，它不是一种新的编程语言，而是一种使用现有标准的新方法。看全称好像只有JavaScript和XML，其实Ajax并不是只包含JavaScript和XML，Ajax是由JavaScript、XML、CSS、DOM和XMLHttpRequest等组成的。
Ajax组成
除了Json和XMLHttpRequest，其它的以前都学习过，所以简略介绍一下。
1、HTML/XHTML：用于描述Ajax页面的初始样式，即首次加载显示的页面。
2、DOM：Document Object Model(文件对象模型)，用来表示XML数据结构。
3、CSS：Cascading Style Sheet(层叠样式表)达式，用来表示HTML文件中元素出现的样式。
4、XML和JSON：XML是标准的数据样式，无论是服务器端还是客户端都可以很好地对其进行解释，
JSON：JavaScript Object Notation，因为JSON的格式和JavaScript中定义对象的语法一致， 对于同样的数据，JSON要比XML更简短，减少了网络流量。
5、服务器端处理浏览器请求：开发者可以选择他所熟悉的方式进行服务器端设计实现。
6、XMLHttpRequest对象：它允许开发者在javaScript中以异步的方式向服务器发出HTTP请求并得到响应。
7、JavaScript：通过JavaScript可以将上述元素联系在一起，例如通过JavaScript查看修改DOM、CSS等。
XMLHttpRequest对象
XMLHttpRequest对象是AJAX和Web 2.0应用程序的技术基础，AJAX利用XMLHttpRequest来实现发送和接收HTTP请求与响应信息。一个经由XMLHttpRequest对象发送的HTTP请求不需要页面中拥有或回寄一个＜form＞元素。AJAX中的"A"代表了"异步"，这意味着XMLHttpRequest对象的send()方法可以立即返回，从而让Web页面上的其它HTML/JavaScript继续其浏览器端处理而由服务器处理HTTP请求并发送响应。缺省情况下请求是异步进行的，你也可以选择发送同步请求，这将会暂停其它Web页面的处理，直到该页面接收到服务器的响应为止，在使用XMLHttpRequest对象发送请求和处理响应之前，必须先用JavaScript创建一个XMLHttpRequest对象。
XMLHttpRequest属性 属 性
描 述
onreadystatechange
每个状态改变时都会触发这个事件处理器，通常会调用一个JavaScript函数
readyState
请求的状态。有5个可取值：0 = 未初始化，1 = 正在加载，2 = 已加载，3 = 交互中，4 = 完成
responseText
服务器的响应，表示为一个串
responseXML
服务器的响应，表示为XML。这个对象可以解析为一个DOM对象
status
服务器的HTTP状态码（200对应OK，404对应Not Found（未找到），等等）
statusText
HTTP状态码的相应文本（OK或Not Found（未找到）等等）
XMLHttpRequest方法 方 法
描 述
abort()
停止当前请求
getAllResponseHeaders()
把HTTP请求的所有响应首部作为键/值对返回
getResponseHeader("header")
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10f8c3a376b012fc70353980e0e0b1a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff10e13f63fc08d2489989a798498c81/" rel="bookmark">
			我的伞呢？？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨夜天空电闪雷鸣，大雨倾盆。我不曾见过这么大的雨，也不曾见过路面积了那么深的水。在新疆我们有天然的下水道，稍微下点小雨，沙漠会很快的把水给吸收了，即使下大点的雨，那也会干的很快，往往是雨刚一停，地面还是湿的，抛开地表上的一层湿土，很快就能见到下面一层还是干的沙子。再者说新疆，尤其是我们垦区，那是真的很少很少下雨。
提前了看了天气预报，知道昨天会下雨，还专门换了拖鞋，晚上看到下着那么大的雨，有种兴奋感，一路趟着水回的宿舍，还觉得挺好玩的。但老天一打雷，我又很害怕。一路紧跟姐妹们，最终反正是安全的回到了宿舍。
说完了少见多怪，再说说我的伞。在家很少下雨，于是我也没有带伞和买伞的习惯。但这里还是老下雨，于是在大四走的时候，我也在他们那里陶了两把伞，有些破，但还好能遮雨，也没怎么花钱。我的伞是天堂伞，浅粉色，有些破。我观察了一下，在走廊里有好几把都是我那样的伞，我自己也分不清哪一把伞是自己的，昨晚走的时候，我找了好一会儿也不知道哪把伞是自己的，海燕说先随便拿一把走吧，我也就随便拿了一把伞走了。到现在我也不确定那是自己的伞呢？还是不是自己的伞呢？总之先把它放在走廊里，如果没有别人拿，那可能就是我的了，如果有人拿了，说明那伞就不是我的，我再买一把得了，然后做个标记，自己认得就好了，以后避免发生这种事儿。
但一句话说回来，就像老师说的，我们是一家人，都是兄弟姐妹。其实这些都是小事儿，就算找不到自己的伞了，把伞拿错了，也没什么。比起老师的大舍，我们这算的了什么啊？
回头看过去的这个暴风雨之夜，我们的米老师都做了些什么？看着雨下大了，我们知道往家跑，但是米老师看着雨下大了，却要往学校跑。一是担心，我们帮孩子们是否安全，二是担心机房的设备是否安全。由于有两个同学生病了，老师冒雨送她俩去门诊，回宿舍，第二天一大早又去接她俩，自己却一晚没有回家，没有合眼。看着博客里的他留下的痕迹，是深夜两点多。深夜两点多，是我睡的正熟的时候。哪里知道老师因为这样的暴风雨，老师却一夜都没有合眼。
我们每年这样的寒暑假的学习都是他在他掏钱，都是他在付出，几百号人也就只有这样一位老师。有人问他值得吗？他说“管这些干嘛，做着高兴就行，我做过了我无悔！”自己的儿子好不容易回来了，可是因为这样的暑假，因为这样的夜晚，连陪伴他的时间都没有，却一心担心着我们这帮孩子的安慰？我也在问：“米老师，这样值得吗”？对于米老师，和对于我自己的父母，我有同样的疑问：“爸妈，你们养育我二十来年你们值得吗？”这二十来年里，我花费的是你们的血汗钱，是你们的青春岁月，留下的却是岁月的痕迹。想当年，你们自己才十多岁，就满世界的跑着去挣钱，养活自己，而如今，你们的孩子都二十好几了，都还养不活自己，对于这点，我内心始终充满了疑问，充满了愧疚。米老师：“我们不是您的亲孩子，您却日日夜夜都在为我们付出着，您这到底又是为什么？”您说：“我希望将来的某一天，我们提高班的人扎根在世界的软件业中，希望将来中国能有自己的操作系统，希望将来我们中国人不再每天掏钱养着美国人”。“如果您这样做失败了怎么办？”您说：“没什么，即使最终失败了，我们也可以告诉后人，不要再像我们这样做了，经过实践证明，这条道路是错误的！”
十三个春夏秋冬，您都在廊坊师范的条条道路上和您的学生们行走着！真的就像作品展时主持人形容的：一支粉笔行云流水，三尺讲台绘声绘色。
父母给予了我们生命，您却给予了我们再生。丁成云师姐大学一毕业每月工资就拿到九千五，柳波师哥才工作两年现在每月工资一万二，李学宇师姐，刘兵师哥，继争光师哥。。。。您毕业的所有六期、五期学员最低工资也是在七千五以上。我想：这样的奇迹只有您能创造出来！我终于明白了一点，为什么清华大学的计算机教育杂志为什么要花那么大的精力和那么多的笔墨来记录您，为什么那么多的报刊杂志、网络媒体都来争先报道您，为什么那么多名校的专家教授都来听您的课，为什么CSDN首页上会有那多的您的学生在占领。
这绝不是偶然，这是能十三载的辛勤耕耘。
真的，我们很幸运，能遇上您这样的老师！您常说：“提高班的品质教育占50%，素质教育20%，能力占20%，知识和技术占10%。”您常跟我们说的话，和常做的事儿，外人却不敢相信。然而我们却在真真切切的经历着。《我的伞呢》，你信吗？这样一篇博客在常人看来是一篇普通的博客，在米老师看来却是他进行素质教育的课题。
寒假，暑假是所有同学休息的日子，却是我们提高班同学学习的黄金时间。宁可花十万元钱学习，也不可花十万元钱找份工作，或者是找个老公、找个老婆成家，这样的十万元钱换来的只能是：一辈儿穷，辈辈儿穷！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fb218d59d3afc4a8a84dfa2a084cced/" rel="bookmark">
			深入浅出JavaScript(2)—ECMAScript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：
深入浅出JavaScript(1)—ECMAScript
深入浅出JavaScript(2)—ECMAScript
这篇博客,我们继续分析ECMAScript基础,主要涉及语句,函数和运算符.这将有助于我们深入理解javascript原理
一、语句
语句很简单，只要有语言就出的程序员都不会陌生，它和我们java等语言中的语句非常类似，其实就是衍生于我们的传统编程语言。
无非涉及三种结构：顺序，选择，循环。基本上任何问题，我们都可以利用这三种结构经过拆分组合来解决掉。
二、运算符
运算符与我们传统的编程语言也非常相似，废话不多说，看图
详细展开
其中几个需要明确的：
左移运算：它把数字中的所有数位向左移动指定的数量。例如，数字2等于二进制的10，左移5位，变为64，即100000
var intTest=2;
var intResult=intTest&lt;&lt;5
最后intResult==64；
对于AND运算
OR运算
三、函数
在Js里，函数其实是一个功能完整的对象，都可以看做是function类的一个实例。
详细展开
其中有一点很有意思，即利用arguments对象模拟函数重载的方法：
用arguments对象判断传递给函数的参数个数，模拟重载。
例如：
function doAdd(){
If(arguments.length==1){
alert(arguments[0]+10);
}else if(arguments.length==2){
alert(arguments[0]+arguments[1]);
}
}
doAdd(10); //输出20
doAdd(30,20); //输出50
function类
闭包：
闭包：
当内部函数在定义它的作用域的外部被引用时,就创建了该内部函数的闭包,如果内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些变量在内存不会被释放,因为闭包需要它们.
简单看这两句话可能不好理解，我在网上找了两篇文章，感觉写得不错，如果让我整理也不见得比他们整理得好，推荐给大家。
http://www.jb51.net/article/24101.htm
http://www.cnblogs.com/rubylouvre/archive/2009/07/24/1530074.html
总结：
今天主要写了关于javascript核心ECMAScript的基础知识，包括语句，运算符和函数。其中，语句和运算符和java非常相似，对于有语言基础的人来说非常简单。而函数，javascript中的函数为对象，可以看做是function类的实例，注意同名函数不会报错，后者覆盖前者，其中还提到模拟函数重载的方法和一些注意点。
ECMAScript的基础知识大概就这些，了解这些有助于我们深入理解javascript原理。
下次将会写javascript对象的相关东西，谢谢关注。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf9734f6009917dc15872a1ea0e793c/" rel="bookmark">
			代码戏我千百遍，我待代码如初恋--数组和指针真的不一样啊。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我发现了一个秘密：数组和指针真的不一样啊。
今天，我写了这么个坑爹的代码：
array.c
Array.h
Pointer.c
编译运行，运行到main红色框框里那句就出错了：
同样是打印p[0]，在函数print_p();里没出错，到main里就出错了，好怪异啊。
翻书吧，在《C专家编程》的第84页对数组和指针的访问进行了解释，我在这里当一下搬运工：
图 A 数组的下标引用 图B 对指针的引用
图C 对指针进行下标引用
我现在遇到的状况是:在pointer.c里写了句声明“extern char *p;”，然后再以p[0]的方式来引用array.c里数组p[MAX_NUM+1]= "abcdefg";其实质是图A和图B访问方式的组合。首先，进行图B所示的间接引用。然后，如图A所示用下标作为偏移量进行直接访问。更为正式的说法是，编译器将会:
1. 取得符号表中p的地址，提取存储于此处的指针。
2. 把下标所表示的偏移量与指针的值相加，产生一个地址。
3. 访问上面这个地址，取得字符。
一步一步来，先看一下函数 print_p() 里是怎么对数组 p[] 进行访问的；将 Array.c 更改如下： 编译，执行结果如下：
访问过程：
a. 经过数组定义后，符号p代表了数组p[MAX_NUM+1]的首地址0x0804970,数组“abcdefg”存储于以0x0804970开始的8个字节的内存空间。
b. 访问p[3]时，就是先取得p的值0x0804970,然后+3得到0x0804973,再取地址0x0804973里的内容‘d’也就是0x64.
但为什么在函数main引用p[0]时会出错呢。在main函数添加一句打印p的值的语句看一下。
这次连&amp;p的值也打印了。
执行结果如下：
由于重新编译，数组p的首地址被重新分配成0x08049768了，但这没影响。看到了没，在main里&amp;p = 0x08049768刚好是数组p的首地址，这时的p却等于0x64636261;
哈哈，好玩的事情来了，我在这个坎纠结了好久。
原来是这样的：
在array.c里的char p[MAX_NUM+1] = "abcdefg"告知编译器p是一个字符序列，经过编译后数组p[MAX_NUM+1]首地址是0x08049768，在array.c里引用p时，p代表的就是数组的首地址，也就是p=0x08049768；而在pointer.c里extern char *p却告知编译器p是一个指向字符的指针，此时p代表的是地址0x08049768里存储的值0x64636261(p是个指针，占用四个byte的空间，而从0x08049768开始的四个byte里存的是‘a’’b’’c’’d’,即0x64636261)，即p = 0x64636261。就像定义 char a = 0x01一样，0x01存于某个地址空间内，引用a时，就去这个地址空间取得里面存储的值0x01,即a = 0x01。
extern char *p把p声明为指针后，不管p原先是定义为指针还是数组，取p[i]的值都会按照往上面好几行已经说过的三个步骤走，即：
1. 取得符号表中p的地址0x08049768,提取存储于此处的指针0x64636261；
2. 把下标i与指针的值相加，产生一个地址，即0x64636261+i；
3. 访问上面的这个地址，取得字符。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebf9734f6009917dc15872a1ea0e793c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8c7a438524cc7f5a91591cf566ed381/" rel="bookmark">
			android4.0 输入法框架分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		InputMethodManager.java
InputMethodManager.java中定义一个变量： IInputMethodSession mCurMethod;
从表面上看，似乎是远程使用的。
我们在后面有这样一个变量mClient ：这个是传到InputMethodManagerService中回调使用的：
主要在startInputInner或者onWindowFocus中调用InputMethodManagerService方法时传进去。
final IInputMethodClient.Stub mClient = new IInputMethodClient.Stub() {
public void onBindMethod(InputBindResult res) {
//这里发送一个消息：MSG_BIND
mH.sendMessage(mH.obtainMessage(MSG_BIND, res));
}
}
class H extends Handler {
public void handleMessage(Message msg) {
switch (msg.what) {
case MSG_BIND: {
//很明显：从InputMethodManagerService中传递过来的
final InputBindResult res = (InputBindResult)msg.obj;
mCurMethod = res.method;
}
break;
……
}
}
}
从上面可以知道，mClient在InputMehtodManager中代表一个启动的Input的客户端，它在正常启动后传到InputMethodManagerService中使用。那么，InputMethodManager中的mCurMethod如何初始化的？
InputMethodManagerService.java
public boolean handleMessage(Message msg) {
……
//和谁bind的？
case MSG_BIND_METHOD:
args = (HandlerCaller.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8c7a438524cc7f5a91591cf566ed381/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70a01fbf5063017f7777aebd0e8a8aa4/" rel="bookmark">
			void在C/C&#43;&#43;中的两种不同含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在wrlinux3.0环境下编译项目代码，报出大量的'&lt;anonymous&gt;' has incomplete type，invalid use of 'VOS_VOID'的错误，经分析大致原因如下：
void作为一个C/C++关键字，有两层含义。第一层含义就是大家熟知的，作为一种“不是类型”的类型。它还有另一层含义，就是写在函数的参数表里面，表示这个函数不接受任何参数。后一种含义其实是从C语言中继承而来，因为C语言里面，如果函数的参数表为空的话，表示这个函数可以接受任意参数。比如：
void func()
{
printf("Hello, world!\n");
}
int main()
{
func("Hello, world!"); //用gcc编译通过，运行正确；而用g++编译通不过
return 0;
}
在这种情况下，为了限定这个函数不会接受任何参数，必须在参数表里面写一个void，也就是写成void func(void)。C++的检查比C语言更严格，如果函数的参数表为空，则表示这个函数不会接受任何参数，换句话说，void func()和void func(void)，效果都一样。此时，void的第二层含义就逐渐被淡化。
接下来把刚才的代码做一个简单的变化：
typedef void VOS_VOID;
VOS_VOID func(VOS_VOID);
由于使用了typedef，所以void被理解为第一层含义：作为一种“不是类型”的类型。简单点说，VOS_VOID是一种类型。但实际上函数的参数不可能是VOS_VOID类型（因为你不可能把一个VOS_VOID类型的值作为参数传到函数里面），所以编译出错。
在当前项目的代码中，其实存在大量上述这种情况，把typedef void VOS_VOID改成#define VOS_VOID void是一种比较简单的解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a534a6e352f3385252e4bd593d1cd14/" rel="bookmark">
			Android 上百实例源码分析以及开源分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先 介绍几本书籍(下载包中)吧。
01_Android系统概述
02_Android系统的开发综述
03_Android的Linux内核与驱动程序
04_Android的底层库和程序
05_Android的JAVA虚拟机和JAVA环境
06_Android的GUI系统
07_Android的Audio系统
08_Android的Video 输入输出系统
09_Android的多媒体系统
10_Android的电话部分
11_Android的连接部分
12_Android的传感器系统
13_Android应用开发揭秘(含代码)
14_Android 电话与短信应用
15_Android斗地主[牌桌实现源码]
16_Android核心分析
17_Android开发权威指南
18_Android开发指南中文版-应用程序框架
19_Android驱动开发入门及手机案例开发分析教程
20_Android手机开发应用案例分析之手机版开心网功能实现
21_Android硬件驱动开发关键技术和HAL移植要领
22_Android中文翻译组——Android中文API合集（4）
23_Android Google.Android开发入门与实战
24_Android 精通Android游戏开发
25_Android 3G应用开发之Android
26_Android 15个Android很有用的代码片段
27_Android Android 图像处理篇
28_Android Android_CTS测试研究
29_Android Android_GoogleMaps基础开发教程
30_Android Android_GPS架构分析
31_Android android_JNI编程_一些技巧
32_Android android_jni操作指南
33_Android Android_NDK开发实例
34_Android Android_RIL层剖析(官方翻译)
35_Android Android2.2+API+中文文档系列
36_Android Android的Message机制(简单小结)
37_Android Android的主题和风格介绍
38_Android Android开发环境搭建
39_Android Android内存泄露调试
40_Android Android日历完整实现
41_Android Android摄像头的应用
42_Android Android实现GPS定位
43_Android Android通过JNI调用驱动程序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a534a6e352f3385252e4bd593d1cd14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cd133a91a7b82441d440e7c8b2ad810/" rel="bookmark">
			iPhone实战：操作SQLite
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; SQLite是一款轻量级的数据库，是遵守ACID的关联式数据库管理系统，它的设计目标是嵌入式的，而且目前已经在很多嵌入式产品中使用了它，它占用资源非常的低，在嵌入式设备中，可能只需要几百K的内存就够了。它能够支持Windows/Linux/Unix等等主流的操作系统，同时能够跟很多程序语言相结合，比如 Tcl、C#、PHP、Java等，还有ODBC接口，当然还有我们使用的Obj-C。用这种方法保存的数据既可以在客户端存储大量数据，同时能够利用SQL语句灵活地查询、插入、更新或者删除数据。
本人在开发过程中发现关于iOS中SQLite的编程文章实在太少了，大多数都是涉及都一些简单的操作。因此，下面写到的操作我会在简单的SQLite操作基础上（其中包括打开/关闭数据库、构造表、插入、更新或者删除数据操作），再增加两项数据库操作中比较常用的功能实践，分别实现带参数SQL语句的执行以及数据库的事物启动、提交和回滚。废话不多说，直接进入主题吧。
在iOS中使用SQLite我们需要加入libsqlite3.dylib的库，并在引入SQLite的头文件。如下：
#import &lt;sqlite3.h&gt; 导入库和头文件之后，接下来的操作就是打开一个数据库。这时候需要调用sqlite3_open这个函数来对打开一个数据库文件。此函数声明如下：
int sqlite3_open( const char *filename, /* Database filename (UTF-8) */ sqlite3 **ppDb /* OUT: SQLite db handle */ ); 其中第一个参数就是数据库所存放的路径，如果路径下没有数据库文件则系统会在此路径下创建一个数据库。至于第二个参数则是数据库的句柄引用，但此函数调用成功后此句柄将会保存打开数据库的句柄,此句柄在往后的数据库操作中需要用到。因此，可如下方式调用：
NSString *dbPath=[NSString stringWithFormat:@”%@/Documents/demo.db”,NSHomeDirectory()]; sqlite3 *dbHandle; if (sqlite3_open([path UTF8String], &amp;dbHandle)==SQLITE_OK) { NSLog(@“打开数据库成功!”); } 既然有打开数据库，那么就肯定有关闭数据库的操作了，我们要养成良好的习惯，当需要使用数据库的时候就执行sqlite3_open来打开数据库，等使用完数据库后就调用sqlite3_close函数来对数据库进行关闭。关于sqlite3_close函数声明如下：
int sqlite3_close(sqlite3 *); 关闭时传入数据库句柄即可对数据库进行关闭。调用方式如下：
if(sqlite3_close(dbHandle)==SQLITE_OK) NSLog(@“关闭数据库成功!”); 接下来需要讲述的是如何对数据库进行操作，常用的有两种方式可以操作数据库中的数据和调整结构。
第一种就是sqlite3_exec函数，这种方法一般使用在不返回数据集的情况，也就是说少用于查询类的操作，同时笔者也尚发现使用此函数如何配合参数使用。如果使用他来创建表结构、更新、插入或者删除操作是一种直观快捷的方法。先来看看此方法的声明：
int sqlite3_exec( sqlite3*, /* An open database */ const char *sql, /* SQL to be evaluated */ int (*callback)(void*,int,char**,char**), /* Callback function */ void *, /* 1st argument to callback */ char **errmsg /* Error msg written here */ ); 第一个参数就是我们打开数据库的句柄了，第二个参数就是SQL语句，第三个参数为回调方法的函数指针，一旦指定此参数后，当执行语句为查询语句时则在枚举记录集时回对调此方法。第四个参数则为回调的第一个参数引用。关于第三第四个参数还有待研究（如果哪位大虾知道如何使用，不妨告诉小弟，一定感激不尽）。至于第五个参数就是如果方法执行后存在异常，那么这个参数保存的就是错误的描述信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cd133a91a7b82441d440e7c8b2ad810/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c95c9f96f01644982406b124411a299b/" rel="bookmark">
			There is no item category assigned to account xxxxxxx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做GOODS ISSUE的时候遇到这么一个问题，报出一个错误There is no item category assigned to account xxxxxxx，暂时也不知道原因，后来到
Financial Accounting Global Settings(New)--&gt;General Ledger Accounting(New)--&gt;Business Transactions--&gt;Document splitting--&gt;Activate Document Splitting
到里面deactivation company 就行
备注： 知其然，不知其所以然，还望读者能个原因，为什么这么做可以解决问题？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4b03abff0e37da035d6fc0f9a4b1235/" rel="bookmark">
			GPIO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写控制程序 GPIO的配置文件在/sys/class/gpio目录下，控制程序可以分为四个步骤：
配置GPIO：在/sys/class/gpio目录下可以看到文件export，调用该文件以实现配置。该文件对所有GPIO编号，从0开始。GPIOn_x的编号为32*n+x，例如此处用的GPIO1_6的编号为32*1+6=38。在终端输入：# echo "38" &gt; /sys/class/gpio/export，在此回到目录/sys/class/gpio下，可以看到产生了一个新的目录./gpio38，里面包含了该IO口的输入输出设置等配置文件。注意：export文件只有root写权限，执行上述命令或者以后用C编写的可执行文件要以ROOT身份执行。 设置GPIO的方向（输入输出）:在终端输入：# echo "out" &gt; /sys/class/gpio/gpio38/direction，即设置该GPIO为输出。 设置GPIO的输出电平：在终端输入：#echo "1" &gt; /sys/class/gpio/gpio38/value，即设置GPIO输出高电平，输入echo "0" &gt; /sys/class/gpio/gpio38/value设置GPIO输出低电平。 关闭GPIO：在终端输入：#echo "38" &gt; /sys/class/gpio/unexport，即删除GPIO配置文件，可以看到目录gpio38已经被删除。
下面是C语言编写的GPIO控制例程，实现LED的每隔一秒闪烁一次。
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
int main(void)
{
FILE *p=NULL;
int i=0;
p = fopen("/sys/class/gpio/export","w");
fprintf(p,"%d",38);
fclose(p);
p = fopen("/sys/class/gpio/gpio38/direction","w");
fprintf(p,"out");
fclose(p);
for(i=0;i&lt;100;i++)
{
p = fopen("/sys/class/gpio/gpio38/value","w");
fprintf(p,"%d",1);
sleep(1);
fclose(p);
p = fopen("/sys/class/gpio/gpio38/value","w");
fprintf(p,"%d",0);
sleep(1);
fclose(p);
}
p = fopen("/sys/class/gpio/unexport","w");
fprintf(p,"%d",38);
fclose(p);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4b03abff0e37da035d6fc0f9a4b1235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b20aa397308ba4fa23bb7c49594a3d46/" rel="bookmark">
			周鸿祎：微创新要极端一点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，真正流行的产品，都不是在核心技术上能人所不能，技术已经同质化，最后比拼的都是产品和体验。而对于用户来说，体验是细节，是微观的东西。即使不是IT企业，不是 互联网企业，也应该想一想，在产品、流程中还有哪些可以改善，还有哪些可以做到极致。 我非常反对成功学，很多事情经过成功学加工之后，就变得像传奇小说，只是听起来很热闹。创业是由很多很残酷的教训组成的。在这个行业里，我算是最大的失败者。正因为有失败，所以才有总结，不断去改善。
放弃大战略，关注点滴感受
在公司内部，我比较反对做评论家，创业者首先不要去做评论家。评论家站在高端，谈产业问题，谈格局，其实没意义。很多话越抽象越对，但只是正确的废话。别说小企业，即便是一个大企业，当面临挑战或转型的时候，也要放弃概念上的论证，放弃平台上的规划，放弃所谓大战略。
诺基亚面临苹果挑战的时候，做了很宏大的规划，他们甚至花了60多亿美元买了一家地图公司——很宏伟的格局。今天，他们和微软合作，也有很宏伟的格局。但他们从来没有从用户、产品的角度去想一想：用户用手机的时候，有什么困难？我一直用诺基亚的产品，用诺基亚手机下载软件对人是一个极大的挑战，但是诺基亚公司高管和技术人员都认为这不是问题，问题是“我们没有正确的方向和战略”。
反观苹果。很多买苹果产品的人，都会觉得它某一点很酷，用得很方便。拿一个iPad和一台电脑，给3岁的小孩和60岁的老人，哪款产品能在3分钟之内就能学会使用？只有iPad.乔布斯永远在关注图标是否精美，手机用起来是否顺畅。
但苹果是因为宏观战略上规划得好，才成为“街机”的吗？我认为，苹果公司没有战略，如果有也只有用户战略和产品战略：不断发现用户的需求，不断满足用户的需求，把它做到极致。不是说完全不能谈战略，但企业战略不能在“云端”，所有的战略一定要具象到怎么解决用户体验问题，这是非常重要的产品观。
为什么讲微创新？因为消费者对产品的感觉都来自微小的接触点。消费者是不理性的，选择一个产品还是抛弃一个产品，不是因为对你产品本质的了解，更不是因为好的技术，而是在使用中点点滴滴的感受。
今天，互联网让信息更加对称，让消费者拥有更多的知情权和选择权，消费者的话语权越来越强，用户体验会越来越变成一个产品成功的关键。用户体验，过去单纯理解为产品的交互、外观和包装，这是一种误区。体验能够改变人们对技术的认知。反过来看，再好的东西，如果太抽象，用户没有感知，就不是好的用户体验。
举例来说，一位做手机的厂商跟我大讲特讲他的屏幕如何如何好，都是各种技术术语和指标。我说，讲这些没用，用户没感觉，你不如在手机里内置几张精美的壁纸，在壁纸映衬下，用户就感觉出谁的屏幕好了。
什么东西能形成体验？狗咬人不是体验，人咬狗才是体验。你去一个饭店，你点餐、吃饭、结帐走人，这不叫体验。好的用户体验，不光要让用户感知到，还一定要超出用户预期。拉斯维加斯一个酒店，客人结完账后会送给客人两瓶水，让客人在沙漠里开车的时候有水喝。按照传统思维，结账完毕即交易完毕，送水则完全超出客人预期，而且代表一种关怀。结果这家酒店的回头率特别高。
最糟糕的用户体验我觉得是电视机的遥控器，绝对是最悲催的设计。大部分键用不到，经常用的键又特别容易用坏。最常用的键是开关、频道和音量，下面几排按钮都没记得按过。电视有很多功能是消费者一辈子都用不上的，是技术人员为了完成电视机的卖点，硬设计到遥控器上。卖点的观念已经过时了，你不能再通过卖点去忽悠用户。用户不是买完东西跟你的关系就结束了，恰恰是用户买了你的产品之后，体验之旅才真正开始。
给大家推荐一本关于用户体验的书：《一切行业都是娱乐业》。为什么所有行业都是娱乐业？娱乐业不靠别的，就是拼用户体验。我们去看《阿凡达》、《泰坦尼克号》，花了钱却什么也没买到，还耽误了两个小时，但是你觉得很开心，这就是用户体验。如果你的行业让用户买到的不是产品，而是产品带来的感觉，你就成功了。
突破用户最不爽的东西
微创新不是很多人谣传的那样，只是抄袭，那是对这个思想的绝对歪曲。微创新是要从消费者角度看问题，找出用户今天最不爽的东西。而从用户角度看，你认为是微观的东西，一点也不微观。拿360来说，一个用户也许使用我十个功能的体验都很好，而且360终身免费还给他解决很多问题，但哪天360犯了一个错误，有一个东西打不开了，甚至可能都不是我们的问题，他一样会指责，360又怎么怎么样了。
360的发展，也是从微观入手。当年360进入杀毒市场，其他企业都做了10年以上。他们每年会宣扬很多卖点，但是360看到了一个机会——他们杀不了流氓软件。我经常在想，幸亏我是门外汉，门外汉没有思维定式。他们认为安全就应该这么做，他们也赚了钱。但是那种做法我不会，那我能不能从用户的角度去解决问题？这时我们就有了创新。
而做微创新和做产品，一定要把一点做到极致，这叫伤其十指，不如断其一指。不要怕产品有缺点，这世界上没有产品没有缺点。360刚出来的时候界面很丑，技术很一般，但我们就一个优点，能解决流氓软件的问题，而且最多、最全，就这一点打动了用户。所以在做微创新的时候，要扪心自问，我敢不敢在一点上做到极致。
从企业经营来说，什么叫大智慧？就是有舍有得，你敢于舍得，你敢于放弃，你才能获得。如果说，这点也不能舍，那点也不能舍，最后你的决策一定是平庸的。
单点突破还有一个前提——单点一定要做到极端。你敢不敢做到极端，这点很重要。心存包袱和顾虑只是稍微做一点改良，这其实是最可怕的，因为你提醒了对手。
千万不要“精神分裂”，在一个服务上分出档次。某公司做免费邮箱，流量一直排名中国前几位，有一天决定邮箱要收费，就让免费用户的服务更差，这其实是想办法赶走用户，自己还在树上就把树给锯了。
怎么把体验做到极致？第一，能不能让原来很贵的东西变得很便宜，甚至变成免费。美国连电脑免费都有人探索过，包括上网免费。一个产品本身免费，靠后来的服务赚钱。第二，能不能把复杂的东西做得很简单，这是技术人员最容易忽视的，其实真正高超的技术都是用户感觉不到的。还有一点，就是大道至简，你觉得够简单了，其实还能更简单，比如从博客到微博。
不怕犯错误，脸皮厚一点
对很多创业公司来说，微创新是一种值得身体力行的方法，从微观入手，从小处着眼去做。但大家不要觉得这是老军医传授的一招就灵的功夫，微创新要做两手准备。
第一个准备，失败是常态。做微创新，不要怕尝试，不要怕犯错。失败给你增加经验和教训，能够让你承受力更好。大家不妨用小步快跑、不断尝试的方式，花两周或一个月做一个微创新，不行也就浪费了两周或者一个月时间。不可以动辄做几年的规划，互联网业一年等于传统行业的七年。
脸皮要厚一点，我们不是伟大的企业家，也不是企业教父。绝大多数人都害怕失败，勇士和懦夫都会恐惧，只是懦夫控制不了自己的情绪，而勇士能够控制自己的情绪，在有恐惧、有压力的时候，还能冷静地做判断。2006年，我做反流氓软件的时候，差点被骂出抑郁症。因为他不能说你做反流氓软件不对，他只能说你是一个坏人。
第二个准备，要在企业形成一种文化，让那些在一线作战的客服、测试、开发和产品人员能够创新，而不是老板在创新。一个企业，不需要每个人都了解企业的战略，而应该让他们结合产品、流程上的细微之处，从用户角度出发提供创新的点子。
我们所有浏览器的产品改进，都不是在屋里想出来的，都是从用户抱怨中来。一次，一个用户打电话来，说你们的浏览器怎么都不支持网银？我们发现，其实是因为用户没有装网银插件。而用户要使用不同银行的网银，需要安装七八个软件和驱动。用户安装过程中，要下载、安装、重启，一堆问题，而如果安装网银插件失败了，他也不知道，就会归咎于浏览器太烂。我们就做了一件事，我们跟银行签好协议，帮用户自动下载安装最新的网银插件。你不能去教育你的用户去装网银插件，这就是微创新的机会。
而过去传统的做法是，我们老板想要创新，让我们自上而下制定一个宏观的战略，再分解到各个部门。这种创新，就算你是乔布斯，也可能会出问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c41dc42376bf21167a7c709624baba7f/" rel="bookmark">
			Context的子类实现：ContextImpl的初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Context：
Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc
1、它描述的是一个应用程序环境的信息，即上下文。
2、该类是一个抽象(abstract class)类，Android提供了该抽象类的具体实现类(后面我们会讲到是ContextIml类)。
3、通过它我们可以获取应用程序的资源和类，也包括一些应用级别操作，例如：启动一个Activity，发送广播，接受Intent
信息 等。。
对于我们用到的Activity、Service、Application等都是Context，Context是一个抽象类，它的真正实现是ContextImpl.java中，而Activity、Service、Application用到的Context都是ContextImpl的实例。
二、Context实例创建：
1、创建Activity时：
在启动Activity时：
private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
Activity activity = null;
if (activity !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c41dc42376bf21167a7c709624baba7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73914fa5caeae4bcf89f66ad2e3647a6/" rel="bookmark">
			四人过桥、三盏灯 三个开关 的答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目都还是比较老了，再来温习下吧：
1. 有两个房间，其中一间房里有三盏灯，另一间房里有控制这三盏灯的开关。这两间房是相对独立、相对封闭的，没有空 上的直接联系；三盏灯与三个开关也没有顺序上的必然联系。现在只允许你分别进入这两个房间一次，然后判断三盏灯分别是由哪个开关控制的 2. 四人组合的2x合唱团赶往演唱会场，途中必需经过一座桥，天色很暗，而他们只有一只手电筒。一次时最多 有两人一起过桥，而过桥的时候必须持有手电筒，所以就得有人把手电筒带来带去，来回于桥的两端。手电筒是不能用丢的方式来传递的。四个人的步行速度各不同，若两人同行则以较慢者的速度为准。A需花1分钟过桥，B需花2分钟过桥，C需花5分钟过桥，D需花10分钟过桥，他们如何在17 钟内过桥？
3. 有7克、2克砝码各一个，天平一架，如何只用这些物品三次将140克的盐分成50克、90克各一份？
答案：1、分析：单纯从逻辑控制上来考虑，两个开关最多识别两盏灯。因此，必须采取其他的办法。本题的答案就是：热，电灯发热。进入有开关的房间，将第一个开关打开，约5分钟，然后关闭；再将第二个开关打开。然后进入有灯的房间，热的且关着的开关属于第一个开关；亮着的属于第二开关；不亮且凉的是第三个开关。
2、分析：逆推法。四个人，得走五趟才能全部过完桥；而D的一趟10分钟肯定是必须的。也就是说，其他3个人在剩下的四趟只能用7分钟；这就是说，C是不可能在剩下的四趟里的，否则还剩下三趟就只有2分钟时间了，而实际上即使只让A走三趟也至少要3分钟。综合，C和D必须一起走，而且C还不能再往回走。因此，答案就是A和B先过，2分钟；A回来，1分钟；C和D过，10分钟；B回来，2分钟；A和B一起过，2分钟。共17分钟。
3、分析：第一次把140克对半分出两个70克，第二次称用2+7，从其中一堆得到9克，第三次用这个9克和2克砝码从同一堆再称出11克，把这个9+11=20克放到对面的70克那堆里面去。
转载于:https://blog.51cto.com/zorro/901144
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28c0739509f9ee6e7b5ec319e51e5483/" rel="bookmark">
			《操作系统概念-第七版》概念复习笔记第8章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 内存是现代计算机运行的中心内存由很大的一组字或字节组成，每个字或字节都有自己的地址CPU根据程序计数器的值从内存中提取指令，这些指令可能会引起进一步对特定内存地址的读取和写入内存单元只能看到地址流，而并不知道这些地址是怎么产生的或它们是什么地址（指令或数据）CPU能直接访问的存储器只有内存和处理器内的寄存器机器指令可以用内存地址作为参数，但是不能用磁盘地址； 因此，执行指令以及指令使用的数据必须在这些直接可访问的存储设备上，如果数据不在内存中，那么在CPU使用之前必须把数据移到内存中要确保操作系统不被用户进程所访问，以及用户进程不被其他用户进程访问；
首先要确保每个用户进程都有自己的独立的内存空间，并确保进程只访问其合法地址
【基地址寄存器】：含有最小的合法物理内存地址
【界限地址寄存器】：决定范围的大小
只有操作系统可以通过特权指令来加载基地址寄存器和界限地址寄存器，并做出修改，不允许用户修改操作系统在内核模式下执行可以无限制地访问操作系统和用户的内存通常，程序以二进制可执行文件的形式存储在磁盘上； 为了执行，程序被调入内存空间【输入队列】：在磁盘上等待调入内存以便执行的进程队列【地址绑定】：源程序中的地址通常是用符号来表示的（如：count），编译器通常将这些符号地址绑定在可重定位的地址（如：从本模块开始的第14字节），链接程序或加载程序再将这些可重定位的地址绑定成绝对地址； 每次绑定都是从一个地址空间到另一个地址空间的映射将指令和数据绑定到内存地址上有几种情况：
1、编译时：在编译时就知道进程将在内存中的驻留地址，那么就可以生成绝对代码； 如果将来开始地址发生了改变，那么必须重新编译代码（MS-DOS的.COM格式程序就是这种情况）
2、加载时：在编译时不知道具体在内存中的地址，这时，编译器必须生成可重定位代码； 如果开始地址发生变化，只需要重新加载用户代码以引入新的地址值
3、执行时：如果进程在执行时可以从一个内存段移到另一个内存段，就属于这种情况； 这种情况需要特定的硬件，绝大多数计算机操作系统采用这种办法CPU所生成的地址通常称为【逻辑地址】，而内存单元所看到的地址（即加载到内存地址寄存器中的地址）通常称为【物理地址】在编译事和加载时的地址绑定方法生成相同的逻辑地址和物理地址，但是在执行时绑定的是两者不一样的，通常称逻辑地址为【虚拟地址】由程序所生成的所有逻辑地址的集合称为【逻辑地址空间】，相应的有【物理地址空间】运行时从虚拟地址到物理地址的映射是有被称为【内存管理单元MMU】的硬件设备来完成的
一种实现映射的方案：使用【重定位寄存器】，其实是前面所讲的基地址寄存器；用户进程所生成的地址在送交内存之前，都将加上重定位寄存器的值； 例如：逻辑地址为346，重定位寄存器的值是10000，则将映射到地址10346
用户程序绝不会看到真正的物理地址【动态加载】：对于一个进程的子程序只有在被调用时才被加载，所有子程序都以可重定位的形式保存在磁盘上； 主程序装入内存并运行，当一个子程序需要调用到另一个子程序时，调用子程序首先检查另一个子程序是否已被加载，如果没有，【可重定位的链接程序】将用来加载所需要的子程序，并更新程序的地址表以反映这一变化，接着，控制传递给新加载的子程序动态加载不需要操作系统提供特别的支持【存根】是一小段代码，用来指出如何定位适当的内存驻留库程序，或者是如果该程序不在内存时应该如何装入库； 不管如何，存根会用子程序地址来替换自己，并开始执行子程序【动态链接】：概念与动态加载相似，只是这里不是将加载延迟到运行时，而是将链接延迟到运行时； 这一特点通常用于系统库，如语言子程序库；若没有这一点，则每个程序都必须要有一份语言库的副本，这浪费了磁盘空间和内存空间； 动态链接也可以使用于库的更新； 动态链接需要操作系统的帮助；【交换】：进程被换出（滚出）内存或换入（滚入）内存通常一个交换出的进程需要回到它原来所占有的空间交换需要【备份存储】，是快速磁盘，这必须足够大，以便容纳所有用户的内存镜像副本具有动态内存需求的进程需要通过系统调用（请求内存和释放内存）来通知操作系统其内存需求变化情况**************以下讨论是基于操作系统放在低内存**************************【连续内存分配】：每一个进程位于一个连续的内存区域MMU动态地将逻辑地址加上重定位寄存器的值后映射成物理地址，再将之送往内存单元【多分区方法】：将内存分为多个固定大小的分区； 每个分区只能容纳一个进程； 因此多道程序的程度会受分区数所限制在【可变分区】方案里，操作系统有一个表，用于记录哪些内存可用和哪些内存已被占用
在一开始，所有的内存都可用于用户进程，因此可以作为一大块可用内存，称为【孔】； 当有新进程需要内存的时候，就为该进程查找足够大的孔， 如果找到，可以在孔内为该进程分配所需的内存，未分配的内存下次可以使用内存不断的分配给进程，直到下一个进程的内存需求不能满足为止，这时没有足够大的可用孔来装入进程； 操作系统可以等到有足够的空间或者是往下扫描输入队列以确定是否有其他内存需求较小的进程可以被满足当进程释放空间时，将所占有的孔与相邻的孔合并成大孔从一组可用孔中选择一个孔的方法：（首次适应较佳）
1、首次适应：分配第一个足够大的孔，就可停止
2、最佳适应：分配最小的足够大的孔，必须查找整个表；可以产生最小的剩余孔
3、最差适应：分配最大的孔，必须查找整个表；可以产生最大的剩余孔【碎片】：内存之中的小空间，但已经不足以分配给进程使用了；
首次适应和最佳适应方法都会有【外部碎片】
【50%规则】：假定有N个可分配块，那么可能有0.5N个块是外部碎片，即1/3的内存不能使用通常将内存以固定大小的块为单元来分配，但若按这种方案，进程所分配的内存可能比所要的要大，这两个数字之差称为【内部碎片】【紧缩】：解决外部碎片的问题；移动内存内容，以使所有空闲空间合并成一整块；（紧缩仅在重定位是动态并在运行时可采用）【分页】：允许进程的物理地址空间可以是非连续的；（传统上，分页是由硬件支持的）分页避免了将不同大小的内存块匹配到交换空间上的麻烦；实现分页的基本方法涉及将物理内存分为固定大小的块，称为【帧】；而将逻辑内存也分为同样大小的块，称为【页】；
当需要执行进程时，其页从备份存储中调入到可用的内存帧中； 备份存储也分为固定大小的块由CPU生成的地址分为两部分：页号（P）和页偏移（d），页号作为页表（【页表】包含每页所在物理内存的基地址）的索引，基地址与页偏移组合成了物理地址，就可送交物理单元了分页不会产生外部碎片，但是仍然有内部碎片；分页的一个重要特点是用户视角的内存和实际的物理内存的分离【帧表】：每一个条目对应着一个帧，以表示该帧是空闲还是已占用，如果占用，是被哪个占用绝大多数的操作系统都为每个进程分配一个页表，页表的指针与其他寄存器的值（如指令计数器）一起存入进程控制块中，当调度程序需要启动一个进程时，它必须首先装入用户寄存器，并根据所保存的用户页表来定义正确的硬件页表值【页表基寄存器PTBR】：指向存在内存中的页表【转换表缓冲区TLB】：是关联的快速内存； 由键（标签）和值组成； 当关联内存根据给定定值查找时，它会同时与所有键进行比较
TLB只包含页表中的一小部分条目，当CPU产生逻辑地址后，其页号提交给TLB，如果找到了页号就找到了帧号，并可用来访问内存； 如果页码不在TLB中（TLB失效），那么就需要访问页表，寻找到后将之放入TLB中，如有必要，置换出一个有的TLB在每个条目中还保存地址空间标识符（ASID），可用来唯一标识进程，并为进程提供地址空间保护【页表长度寄存器PTLR】：表示页表的大小； 可用于检查每个逻辑地址以验证其是否位于进程的有效范围分页的优点之一在于可以【共享公共代码】【可重入代码】、【纯代码】：可以共享，不能自我修改的代码，它从不会在执行期间改变
【向前映射页表】：地址转换由外向内（在两级或多级页表结构中，从外部页表到内部页表）【哈希页表】：处理超过32位地址空间的常用方法是使用哈希页表，并以虚拟页码作为哈希值；
哈希页表的每一条目都包括一个链表的元素，每个元素包括：（1）虚拟页码；（2）所映射的帧号；（3）指向链表中下一个元素的指针；
算法工作：虚拟地址中的虚拟页号转换到哈希表中，用虚拟页号与链表中的每一个元素的第一个域相比，如果匹配（不匹配就比下一个），那么相应的帧号（第二个域）就用来形成物理地址【群集页表】：类似于哈希页表，但是每一个条目不只包括一页信息，包括多页； 因此一个页表条目可以存储多个物理页帧的映射，对于稀疏地址空间特别有用；【反向页表】：对于每个真正的内存页或帧才有一个条目； 每个条目包含保存在真正内存位置的页的虚拟地址以及拥有该页的进程的信息； 整个系统只有一个；
【分段】：逻辑地址空间是由一组段组成的； 每个段都有名称和长度，地址指定了段名称和段内偏移；因此，用户可以通过段名称和偏移两个量来指定地址【段表】：段表的每个条目都有段基地址和段界限（段的长度）段表的使用：一个逻辑地址由：（1）段号（段名称）和（2）段内偏移；
如果偏移合法，那么就与段基地址相加而得到所需字节在物理内存的地址； 如果不合法，会陷入操作系统
在pentium系统中，CPU产生逻辑地址，它被赋给分段单元； 分段单元为每个逻辑地址生成线性地址，然后线性地址交给分页单元，它接下来生成内存中的物理地址；（分段单元和分页单元相当于内存管理单元MMU）进程的逻辑空间被分成两部分：第一部分最多由8K个段组成，这部分为私有，存于【本地描述符表LDT】； 第二部分最多由8K个段组成，这部分为所有进程所共享，存于【全局描述符表GDT】；
LDT, GDT的每个条目为8B，包括一个段的详细信息，如基位置和段界限等；
逻辑地址是由一对（选择器，偏移）组成的，
其中选择器是16位的数：s 表示段号（13位）， g 表示是在GDT还是LDT（1位），p是保护信息
偏移是一个32位的数，用来表示字节（或字）在段内的位置 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80fc05c64d6b71d0e62ead8d037d6fe8/" rel="bookmark">
			如何通过CMPP短信网关下发WAP PUSH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		折腾了几天wap push，终于有个结论。通过CMPP短信网关下发已测试出技术实现没问题， 而用同样的方式给联通的SGIP短信网关发送，返回一个socket被关闭的信号，估计是做了屏蔽。 致电联通技术负责人，果然福建地区把wap push都封住了，不但是短信网关，连PPG都不行。看 来联通也明白自己的平台管理不善，容易让不法分子钻空子，干脆把门都堵上了。 个人认为，wap push不是正常业务有效的宣传途径，目前手机厂商很多将wap psuh收件箱 设置在互联网功能菜单中的下下层，用户听到提示音看到提示图标但找不到地方。我经常帮困惑 的亲友清理这些垃圾。再者目前SP已经臭名昭著(这要归功于这个行业里的流氓)，普通用户对这 些服务退避三舍，公司目前的信息资源无法满足某些有特殊爱好的用户群（这点目前值得我庆幸）。 通过正当途径没法做，其它的，就不在我的工作范围。 不过既然做了，就写写吧。 通过移动的短信网关下发wap push，相对于下发普通短信， 有两个地方不同。 一、CMPP_SUBMIT消息包的部分参数值改变。具体是： Msg_Fmt = 4(表示消息内容是二进制)， TP_pid = 0； TP_udhi = 1； 二、字段Msg_Content的内容是二进制数字，有特定的组合方式。格式解析起来，就是所谓的 “压缩后的XML“,即WBXML,一共有7个部分，把每个部分的二进制码按顺序组合起来填入 Msg_Content字段，当做普通短信下发即可。我做了个简单的测试，代码大概如下： char szWapPushHeader1[12] = {0x0B, 0x05, 0x04, 0x0B, 0x84, 0x23, 0xF0, 0x00, 0x03, 0x03, 0x01, 0x01}; char szWapPushHeader2[9] = {0x29, 0x06, 0x06, 0x03, 0xAE, 0x81, 0xEA, 0x8D, 0xCA}; char szWapPushIndicator[8] = {0x02, 0x05, 0x6A, 0x00, 0x45, 0xC6,0x0C, 0x03}; char szWapPushDisplayTextHeader[3] = {0x00, 0x01, 0x03}; char szEndOfWapPush[3] = {0x00, 0x01, 0x01}; //以上数字串是什么意思，估计有几个说明可以参考下， 又是前人经验： //0B WAP PUSH头部的总长度 //05040B8423F0表示接下来是一个WAP PUSH //00 表示是Concatenated Short Messages //03 长度 //03 reference number //01 表示分成1个短信发送 //01 当前包的序号 //我大概知道是某种语法，不明白的话也不太影响功能的样子。好象只需要知道分几条短信和 //序号发就可以了。以上每个部分，也有其他可以通过测试的不同的串值，我目前只测了这种 //常见的值，至少它在我的几款测试机器上是能正常的。 //以下两个字串就是需要自己填写的了： //szWapPushUrl：wap push的目的链接，费尽心机不就是想把这个发出去嘛。要求是"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80fc05c64d6b71d0e62ead8d037d6fe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cb45ea41348d19a285382bbd43e5e46/" rel="bookmark">
			[转]MyBatis之传入参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MyBatis的select、insert、update、delete这些元素中都提到了parameterType这个属性。MyBatis现在可以使用的parameterType有基本数据类型和JAVA复杂数据类型
基本数据类型：包含int,String,Date等。基本数据类型作为传参，只能传入一个。通过#{参数名} 即可获取传入的值复杂数据类型：包含JAVA实体类、Map。通过#{属性名}或#{map的KeyName}即可获取传入的值 基本数据类型参数示例： 根据班级ID查询教师列表
xml文件
[html] view plain copy &lt;select id="selectTeacher" parameterType="int" resultType="com.myapp.domain.Teacher"&gt; select * from Teacher where c_id=#{id} &lt;/select&gt; java代码
[java] view plain copy List&lt;Teacher&gt; tList = teacherMapper.selectTeacher(2); for (Teacher entityTemp : tList) { System.out.println(entityTemp.toString()); } JAVA实体类型参数示例： [html] view plain copy &lt;select id="selectTeacher" parameterType="com.myapp.domain.Teacher" resultType="com.myapp.domain.Teacher"&gt; select * from Teacher where c_id=#{id} &lt;/select&gt; [java] view plain copy java代码 Teacher queryTeacher=new Teacher(); queryTeacher.setId(2); List&lt;Teacher&gt; tList = teacherMapper.selectTeacher(queryTeacher); for (Teacher entityTemp : tList) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cb45ea41348d19a285382bbd43e5e46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/296358e0abb2dcd4ed2d181fadfc471d/" rel="bookmark">
			Hibernate SQL查询时有重名字段出现的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hibernate 执行数据库操作语句时会自动为字段取别名。
问题：
SELECT a.name,ec.name resourcesName FROM eam_alert a,eam_resource ec WHERE a.resource_id=ec.id
使用jdbc直接查询，结果正确。
使用hibernate的getSession().createQuery(sql)查询，不报错，但结果不正确，结果中的两列的值都试a.name的值。
解决方案：
下面的方法就可以避免字段名重复的问题:
List cats = sess.createSQLQuery( " select {cat.*} from cats cat " ).addEntity( " cat " , Cat. class ).list();
这个查询指定了:
SQL查询语句，它带一个占位符，可以让Hibernate使用字段的别名.
查询返回的实体，和它的SQL表的别名.
addEntity()方法将SQL表的别名和实体类联系起来，并且确定查询结果集的形态。
addJoin()方法可以被用于载入其他的实体和集合的关联.
List cats = sess.createSQLQuery(
" select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten.mother = cat.id " )
.addEntity( " cat " , Cat. class )
.addJoin( " kitten "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/296358e0abb2dcd4ed2d181fadfc471d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8b6c9043aecfa8d58a2016ee0ef5ffd/" rel="bookmark">
			C - enum和typedef enum的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在了解enum和typedef enum的区别之前先应该明白typedef的用法和意义。
C语言里typedef的解释是用来声明新的类型名来代替已有的类姓名，例如：
typedef int CHANGE;
指定了用CHANGE代表int类型，CHANGE代表int，那么：
int a,b;和CHANGE a,b；是等价的、一样的。
方便了个人习惯，熟悉的人用CHANGE来定义int。
typedef为C语言的关键字，作用是为一种数据类型定义一个新名字。这里的数据类型包括内部数据类型（int,char等）和自定义的数据类型（struct等）。
而enum是枚举类型，有了typedef的理解容易看出，typedef enum定义了枚举类型，类型变量取值在enum{}范围内取，在使用中二者无差别。
enum AlertTableSections
{
kUIAction_Simple_Section = 0,
kUIAction_OKCancel_Section,
kUIAction_Custom_Section,
kUIAlert_Simple_Section,
kUIAlert_OKCancel_Section,
kUIAlert_Custom_Section,
}; typedef enum {
UIButtonTypeCustom = 0, // no button type
UIButtonTypeRoundedRect, // rounded rect, flat white button, like in address card
UIButtonTypeDetailDisclosure,
UIButtonTypeInfoLight,
UIButtonTypeInfoDark,
UIButtonTypeContactAdd,
} UIButtonType;
看上面两个例子更好理解，下面的是UIButton的API，UIButtonType指定的按钮的类型，上面的直接调用enum里的元素就可以了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46b6160bcaf26ec99810acefcdc9059a/" rel="bookmark">
			韩语发音表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		韩国语共有40个字母，其中有21个元音和19个辅音。 单 元 音 ㅏ：嘴自然张开，舌头接触下齿龈，但不要贴上，嘴唇不要紧张，也不要成圆形。发音与汉语拼音的“a”相似，但比“a”稍靠后。 ㅑ：先发“ㅣ”，然后迅速滑到“ㅏ”。 ㅓ：口形比“ㅏ”小一些，舌后部稍微抬起，嘴唇不要紧张，也不要成圆形。 ㅕ：先发“ㅣ”，然后迅速滑到“ㅓ”。 ㅗ：嘴稍微张开，舌后部抬起，双唇向前拢成圆形。与汉语拼音的“o”相似，但比“o”口形要小且圆。 ㅛ：先发“ㅣ”，然后迅速滑到“ㅗ”。 ㅜ：口形比“ㅗ”小一些，双唇向前拢成圆形。与汉语拼音的韵母“u”相似。 ㅠ：先发“ㅣ”，然后迅速滑到“ㅜ”。 ㅡ：嘴稍微张开，舌身稍向后缩，舌前部放平，舌后部略向软腭抬起，嘴唇向两边拉开。与汉语拼音中“zi,ci,si,ri"的韵母的发音。练习时可先法”zi"，然后，舌尖稍微往后缩，这时就可发出“ㅡ”。找到感觉后可直接发音“ㅡ”。 ㅣ：与汉语拼音的“yi”相似。 双 元 音 ㅐ：嘴张的比“ㅏ”要小一些，嘴唇向两边拉紧一点，舌尖顶住下齿，舌面抬起靠近硬腭，这时舌面左右两边夹在上下齿之间，舌面与硬腭形成扁的椭圆形。 ㅒ：先发一个“ㅣ”，然后迅速滑到“ㅐ”，即可发出此音。 ㅔ：口形比“ㅐ”要小一些，嘴唇两边放松，舌尖顶住下齿，这时舌面硬腭之间比“ㅐ”圆。与汉语拼音中“ye,jie”的韵母e发音。 ㅖ：先发一个“ㅣ”，然后迅速滑到“ㅔ”，即可发出此音。 ㅘ：先发一个“ㅗ”，然后迅速滑到“ㅏ”，即可发出此音。 ㅚ：嘴张的与“ㅗ”相同，但舌位及舌形与“ㅔ”相同。练习时，先发一个“ㅔ”，然后变一下口形再发一个“ㅚ”，就这样可以交替练习。 ㅙ：先发一个“ㅚ”，然后迅速滑到“ㅐ”，即可发出此音。 ㅝ：先发一个“ㅜ”，然后迅速滑到“ㅓ”，即可发出此音。 ㅞ：先发一个“ㅜ”，然后迅速滑到“ㅔ”，即可发出此音。与汉语拼音的“yue"相似。 ㅟ：口形与“ㅜ”相同，但舌位及舌形与“ㅣ”相同。练习时，先发一个“ㅜ”，然后变一下口形再发一个“ㅟ”，就这样可以交替练习。 ㅢ：先发一个“ㅡ”，然后迅速滑到“ㅣ”，即可发出此音。 基 本 辅 音 ㄱ：发音时，将舌面后部抬起，使舌根接触软腭，堵住气流，然后放开，使气流冲出而发声。它与汉语拼音的“g”相似，但力度要小一点。 ㄴ：发音时，先用舌尖抵住上齿龈，堵住气流，然后使气流从鼻腔中留出来，同时舌尖离开上齿龈，震动声带而发音。它与汉语拼音的“n”相似。 ㄷ：发音时，先用舌尖抵住上齿龈，堵住气流，然后舌尖离开上齿龈，使气流冲出，爆发、破裂成声。它与汉语拼音的“d”相似。 ㄹ：发音时，先使舌尖和上齿龈接近，然后使气流通过口腔，这是舌尖轻轻振弹一下而发声。 与汉语拼音的“r”相比，舌尖靠前的，而且舌尖也不可卷起来。 ㅁ：发音时，首先紧闭嘴唇，堵住气流，然后使气流从鼻腔中流出的同时，双唇破裂成声。它与汉语拼音的“m”相似。 ㅂ：发音时，双唇紧闭并稍向前伸，堵住气流，然后用气流把双唇冲开，爆发成声。它与汉语拼音的“b"相似，但力度稍轻一点。 ㅅ：发音时，舌尖抵住下齿，舌面前部接近硬腭，使气流从舌面前部和硬腭之间的空隙处挤出来，磨擦成声。它与汉语拼音的“s”相似。 ㅇ：做为字的首音时不发音，只是起到装饰作用。 ㅈ：发音时，舌尖抵住下齿，舌面前部向上接触上齿龈和硬腭堵住气流，使气流冲破阻碍的同时，磨擦出声。它与汉语拼音的“z”相似。 ㅊ：发音时，方法与辅音“ㅈ”基本相同，只是发音时要用爆破性的气流推出。它与汉语拼音的“c"相似。 ㅋ：发音时，方法与辅音“ㄱ”基本相同，只是发音时要用爆破性的气流推出。它与汉语拼音的“k"相似。 ㅌ：发音时，方法与辅音“ㄷ”基本相同，只是发音时要用爆破性的气流推出。它与汉语拼音的“t"相似。 ㅍ：发音时，方法与辅音“ㅂ”基本相同，只是发音时要用爆破性的气流推出。它与汉语拼音的“p"相似。 ㅎ：发音时，使气流从声门挤出，这时声带磨擦就发出此音。它与汉语拼音的“h”相似。 紧 辅 音 ㄲ：发音时，与辅音“ㄱ”时基本相同，只是力度上要大一点。 ㄸ：发音时，与辅音“ㄷ”时基本相同，只是力度上要大一点。 ㅃ：发音时，与辅音“ㅂ”时基本相同，只是力度上要大一点。 ㅆ：发音时，与辅音“ㅅ”时基本相同，只是力度上要大一点。 ㅉ：发音时，与辅音“ㅈ”时基本相同，只是力度上要大一点。 韩语字母介绍 韩语是拼音语言，由基本母音（元音）、基本子音（辅音）、双母音（元音）、双子音（辅音）和收音所构成。子音（辅音）无法单独发音，必须藉住母音母音（元音）辅助，才能发出该子音（辅音）的式确的发音方式。而母音（元音）可以单独发音，但是不能独成字，所以如果单发母音（元音）的音时，必须藉助子音（辅音）中的“이응”来形成一个完整的字。现在我们就来认识一下这些韩文的字母吧。 子音 ㅇ ㅈ ㅊ ㅋ ㅌ ㅍ ㅎ
名字 이응 지읒 치읓 키읔 티읕 피읖 히읗
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46b6160bcaf26ec99810acefcdc9059a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edfac3927a2f636358c96cbb57f83526/" rel="bookmark">
			oracle中update...select
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比如有两张表
USER_CHINESE
ID ZHONGWEN
1 张三 2 李四 3 王五 USER_ENGLISH ID PINYIN 1 zhangsan 2 lisi 4 liuliu 现在我想让USER_CHINESE表中的汉字变成拼音。 sql语句是： update USER_CHINESE t1 set t1.zhongwen = (select t2.pinyin from USER_ENGLISH t2 where t2.id = t1.id); 这时候，你可能觉得应该update两条。 可是结果是：3条被更新。 看结果： USER_CHINESE ID ZHONGWEN 1 zhangsan 2 lisi 3 真的是更新了三条。 由于id=3的没有匹配上，所以id=3的记录的ZHONGWEN字段改成null了。 所以，这点一定要注意。 记住：如果update或delete没有where条件，则一定是全表更新的。 如果你不想更新id=3的记录。sql语句可以这样写： update USER_CHINESE t1 set t1.zhongwen = (select t2.pinyin from USER_ENGLISH t2 where t2.id = t1.id) where t1.id !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edfac3927a2f636358c96cbb57f83526/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d811a21b236688e79c3291db206c611/" rel="bookmark">
			C3p0使用时出现的异常及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当并发量大的时候，C3P0连接池会出现如下异常信息：
Caused by: java.sql.SQLException: An attempt by a client to checkout a Connection has timed out. at com.mchange.v2.sql.SqlUtils.toSQLException(SqlUtils.java:106) at com.mchange.v2.sql.SqlUtils.toSQLException(SqlUtils.java:65) at com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool.checkoutPooledConnection(C3P0PooledConnectionPool.java:527) at com.mchange.v2.c3p0.impl.AbstractPoolBackedDataSource.getConnection(AbstractPoolBackedDataSource.java:128) at org.springframework.jdbc.datasource.DataSourceUtils.doGetConnection(DataSourceUtils.java:113) at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:79) ... 5 more Caused by: com.mchange.v2.resourcepool.TimeoutException: A client timed out while waiting to acquire a resource from -- timeout at awaitAvailable() at com.mchange.v2.resourcepool.BasicResourcePool.awaitAvailable(BasicResourcePool.java:1317) at com.mchange.v2.resourcepool.BasicResourcePool.prelimCheckoutResource(BasicResourcePool.java:557) at com.mchange.v2.resourcepool.BasicResourcePool.checkoutResource(BasicResourcePool.java:477) at com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool.checkoutPooledConnection(C3P0PooledConnectionPool.java:525) ... 8 more 对于这部分的异常分析如下： 网上很多说是C3P0的bug问题。c3p0在同时关闭statement和connection的时候，或者关闭他们之间的时间很短的时候，有时候connection并没有被关闭，因为有些preparedstatement还在被cached住。这样就会有很多connection并没有真正的被关闭，连接池的连接都给耗尽了，就会产生上面的异常。解决的方案就是把缓存关闭也就是把c3p0.max_statements 设置成0，这样就不会有缓存的preparedstatement，而设置的c3p0.idle_test_period又小于c3p0.timeout，这样的设置应该没有什么问题了。
回头有时间的话，再拜读下源码研究下,目前先这么解决即可.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/350d13bd23322fd9c74a1d8fd82b28e0/" rel="bookmark">
			Page Faults/sec &amp; Pages/sec
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pages Input/sec 是为了解决硬错误页，从硬盘上读取的页数，而Page Reads/sec 是为了解决硬错误，从硬盘读取的次数。如果 Page Reads/Sec 比率持续保持为 5，表示可能内存不足。 Page Faults/sec 是指处理器中“页面错误”的数量。当一个进程引用不在主存储器“工作集” 中的虚拟内存页时，就会发生页面错误。如果该页面在 Standby 列表上，因而已在主存储器中，或者如果另一个与其共享该页面的进程正在使用该页，那么发生“页面错误”时，不会从磁盘读取该页面。
Pages Input/sec 是指内存引用时页面不在内存，为解决这种情况而从磁盘读取的页面数量。此计数器包含页面流量，它代表为应用程序访问文件数据分配的系统缓存。如果您担心过 量的内存压力（即，系统颠簸）以及可能造成的过量调页，那么这是个需要查看的重要计数器。
Pages Output/sec 是指因主存储器中的页面已修改而写入磁盘的页面数量。
Pages/sec 是指引用不在内存中的页面时，为解决这一问题，从磁盘读取或写入到磁盘的页面数量。它是 Pages Input/sec 与 Pages Output/sec 之和。此计数器包含页面流量，它代表为应用程序访问文件数据分配的系统缓存。该值还包括取自或保存到非高速缓存的映射内存文件的那些页面。如果您担心过量 的内存压力（即，系统颠簸），以及可能造成的过量调页，那么，这是个需要查看的主要计数器。在 WTS 测试中 观察到的结果表明，内存瓶颈对系统性能的影响比 CPU 瓶颈的影响严重得多。出现 CPU 瓶颈时，仍会处理所有的客户请求，但处理速度变慢。受 CPU 限制的机器上的所有客户均可以继续操作，只是在处理过程中，会有持续几秒的定期暂停。 在受内存限制的 WTS 中，测试已表明，只要可用的物理系统 RAM 已达到某个水平，系统就会开始从转换文件读取页面和写入页面。在物理系统 RAM 的数量达到临界水平后，WTS 就会充斥大量转换文件的调页信息。由于影响很大，所以应密切观察内存的使用情况。
最重要的两个性能计数器是 Available Bytes 和 Page Inputs/sec。如果观察到 Page Outputs/Sec 和 Page Inputs/Sec 有上升的趋势，则系统中可能存在内存瓶颈。当处理器向内存指定的位置请求一页（可能是数据或代码）出现错误时，这就构成一个Page Fault。如果该页在内存的其他位 置，该错误被称为软错误（用Transition Fault/sec 计数器衡量）；如果该页必须从硬盘上重新读取时，被称为硬错误。许多处理器可以在有大量软错误的情况下继续操作。但是，硬错误可以导致明显的拖延。 Page Faults/sec 是处理器每秒钟处理的错误页（包括软错误和硬错误）。
notes: 貌似看来，Page Faults/sec - Pages Input/sec = Soft Page Faults/sec ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/350d13bd23322fd9c74a1d8fd82b28e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6ce7714e1cfc35cdd03f323e0a83377/" rel="bookmark">
			Eclipse中已安装的插件如何卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在Eclipse中安装了一个插件，导致Eclipse使用的时候有些问题，就找了资料，原来Eclipse中的插件也是可以卸载的。
方法是点击菜单“Help”，“Install New Software...”，在弹出的对话框中选择右下角的“already installed”
然后就显示已经安装的插件：
选择要卸载的插件，然后点“Uninstall...”把它卸载掉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8adf61622b686d06777e44371ec59af/" rel="bookmark">
			Intent中createChooser方法的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当我们使用如下代码的时候可能会遇到这种情况 Intent it = new Intent(Intent.ACTION_VIEW); startActivity(it); 应为android程序中有很多Activity使用的ACTION_VIEW作为action。所以会打开如下画面。 当我们使用如下代码的时候就会开启不同标题的同一个画面。
Intent it = new Intent(Intent.ACTION_VIEW); Intent chooserIntent = Intent.createChooser(it, "自定义标题-曹箭波"); startActivity(chooserIntent); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae8b94fe4c2ce98b80f1b2ddce234863/" rel="bookmark">
			java.lang.ClassNotFoundException: net.sf.json.JSONArray错误。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用Eclipse，做JSONDemo不断报：java.lang.ClassNotFoundException: net.sf.json.JSONArray错误，找了很久，终于找到了。 原因是由于试用Eclipse的Build Path导入JSON需要用的Jar，发现这样不行。 解决办法：手动将需要的Jar拷贝到lib目录下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce864c7de6836dbc5da061820ca07f62/" rel="bookmark">
			在JS中使用Freemaker变量值，利用函数js_string
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在js中要获取freemaker中变量的值需要使用freemaker内置函数js_string
1. String内置的JavaScript转换： js_string 用途：用于JavaScript转义，转换',",换行等特殊字符 模板:
&lt;script&gt; alert("${errorMessage?js_string}"); //必须写，否则报错
&lt;/script&gt;
输出:
&lt;script&gt; alert("Readonly\'s pet name is \"Cross Bone\""); &lt;/script&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc67e843d49e9a0b9da28fad60df930e/" rel="bookmark">
			CString Char *互相转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Visual C++.NET2005中，默认的字符集形式是Unicode，但在VC6.0等工程中，默认的字符集形式是多字节字符集（MBCS：Multi-Byte Character Set），这样导致在VC6.0中非常简单实用的各类字符操作和函数在VS2005环境下运行时会报各种各样的错误，这里总结了在Visual C++.NET2005环境中Unicode字符集下CString和char *之间相互转换的几种方法，其实也就是Unicode字符集与MBCS字符集转换。
1、Unicode下CString转换为char *
方法一：使用API：WideCharToMultiByte进行转换
CString str = _T("D:\\校内项目");
//注意：以下n和len的值大小不同,n是按字符计算的，len是按字节计算的
int n = str.GetLength(); // n = 14, len = 18
//获取宽字节字符的大小，大小是按字节计算的
int len = WideCharToMultiByte(CP_ACP,0,str,str.GetLength(),NULL,0,NULL,NULL);
//为多字节字符数组申请空间，数组大小为按字节计算的宽字节字节大小
char * pFileName = new char[len+1]; //以字节为单位
//宽字节编码转换成多字节编码
WideCharToMultiByte(CP_ACP,0,str,str.GetLength(),pFileName,len,NULL,NULL);
pFileName[len+1] = '\0'; //多字节字符以'\0'结束
方法二：使用函数：T2A、W2A
CString str = _T("D:\\校内项目");
//声明标识符
USES_CONVERSION;
//调用函数，T2A和W2A均支持ATL和MFC中的字符转换
char * pFileName = T2A(str); //char * pFileName = W2A(str); //也可实现转换
注意：有时候可能还需要添加引用#include &lt;afxpriv.h&gt;
2、Unicode下char *转换为CString
方法一：使用API：MultiByteToWideChar进行转换
char * pFileName = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc67e843d49e9a0b9da28fad60df930e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ceb107a955749e0c041fd125ca6ba86/" rel="bookmark">
			C#使用Des加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DES(Data Encryption Standard)算法为密码体制中的对称密码体制，又被成为美国数据加密标准，是1972年美国IBM公司研制的对称密码体制加密算法.
哎理论的东西就不多说了,很容易让人头痛,我们只要有个概念:有对称加密和非对称加密这两种类型.
对称加密:只有一个密钥,加密数据和解密数据时都用它.打个比方,跟我们平时开门的门锁一样,关门开门都用的一个锁匙.密钥就相当于是钥匙.在代码中其实就相当于是传给函数的一个参数.
非对称加密:有两个密钥,一个公钥,一个私钥.相当于我们锁门用一个钥匙,开门的时候要用另外一个钥匙.
对于对称加密我们可能较容易理解,反正只要一个密钥,写代码时就是弄一个变量,然后加密的函数用这个变量做参数,解密函数也用它做参数.
非对称加密就稍微难理解点,它不一般不是用在同一个程序中.而用于不同的程序间传数据.假如有这样一个场景,你在某网站上输入一个密码,然后要传到服务器去验证.那密码在传输过程中不安全,假如被人截取了可咋整啊,这时你就会想到把密码加密.这样人家截取到了也看不懂.这时不能用对称加密,因为就一个密钥,只你客户端程序知道它并用它加密,但服务器那边不知道,你想到传送密码过去时把密钥也传过去,这样就同样不安全,也怕被截取.于是非对称加密闪亮登场了.
首先服务器那端通过某个算法生成一对密钥匙,一个公钥A,一个私钥B.这样A加密后的东西用B可以解密,B加密的东西用A可以解密.所谓公钥自然是公开的,大家都知道.这样所有人都可以用公钥去加密,而私钥只要服务器知道,别人不会知道,所以你就安全了.那有人会问能不能通过公钥A算出B,理论上自然是能的,不然也不存在破解密码那一说了.只是难度可能比较大.这主要是一些数学算法不太容易逆推,这就涉及些数学的理论了啊.
算法的具体实现我们不管了,.net的一些系统函数给我们完成了那些工作,我们只要去调用就行.
using System.Text;
using System.IO;
using System.Security.Cryptography; //调用那些函数需要先引用这两个命名空间
string myKey = "weiwenhp"; //这就是传说中的密钥了,你可以随便取一个.Des的密钥是64位的二进制,那换成字符串的话只能是8个字符.
//加密的函数
string JiaMi(string sourceString,string key)
{
byte []keyBytes = Encoding.UTF8.GetBytes(key);
byte []keyIV = keyBytes;
byte []inputByteArray = Encoding.UTF8.GetBytes(sourceString);
DESCryptoServiceProvider desProvider = new DESCryptoServiceProvider();
MemoryStream memStream = new MemoryStream();
CryptoStream crypStream = new CryptoStream(memStream, desProvider.CreateEncryptor(keyBytes,keyIV), CryptoStreamMode.Write);
crypStream.Write(inputByteArray,0, inputByteArray.Length);
crypStream.FlushFinalBlock();
returnConvert.ToBase64String(memStream.ToArray());
}
//解密的函数
string JieMi(string encryptString,string key)
{
byte []keyBytes = Encoding.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ceb107a955749e0c041fd125ca6ba86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/318186e3483ad68060e60243003b91b1/" rel="bookmark">
			CSDN专家分和博客系统积分获得规则！（转官方）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客积分规则 博客积分是CSDN对用户努力的认可和奖励，也是衡量博客水平的重要标准。博客等级也将由博客积分唯一决定。积分规则具体如下：
1、每发布一篇原创或者翻译文章：可获得10分；2、每发布一篇转载文章：可获得2分；3、博主的文章每被评论一次：可获得1分；4、每发表一次评论：可获得1分（自己给自己评论、博主回复评论不获得积分）；5、博文阅读次数每超过100次：可获得1分，阅读加分最高加到100分，即文章点击上万次截止；6、文章被投票：顶1票加1分，踩1票减1分；7、文章被管理员或博主本人删除，相应减去博主基于该篇博文所获得的分数；8、评论被管理员或博主删除，相应减去发评论者和博主基于该评论各自获得的分数（博主应减积分不会动态实时去掉，是每周固定时间清理一次）；9、另外会开设相应的抄袭举报功能，一旦举报证实某篇原创文章抄袭，将扣除博主该篇文章相应的得分。 博客等级 图标等级所需积分V10V2100V3500V41000V52000V65000V710000V830000V950000V10100000V11200000V12300000V13500000V14800000V151000000 最新的请到点击这里看官方链接：https://blog.csdn.net/home/help.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/202ca7a5d8e3ae1a560f178a8daeaee1/" rel="bookmark">
			日工资，月工资，加班费，个人所得税，年终奖计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作日固定数据： 按照法律规定，每月工作时间为20.83天，月计薪天数为21.75天，全年制度工作时间为250天，全年节假日及公休日为115天。 计算方法： 每月工作时间 20.83=（365-104-11）÷12；月计薪天数 21.75=（365-104）÷12）；全年制度工作时间 250=365-104-11；全年节假日及公休日 115=104+11 。 日工资计算方法： 日工资＝月工资收入÷21.75（用于有缺勤，工作未满一个月等情况下的工资计算）。 小时工资计算方法： 小时工资=月工资收入÷（21.75×8）。 节假日、公休日加班费计算： 节假日加班三薪（月工资收入÷21.75×300%）。 公休日加班双薪（月工资收入÷21.75×200%） 春节长假七天总加班费=月工资收入÷21.75×300%×3+月工资收÷21.75×200%×4 。（上述案例案例以春节长假七天加班为例，前三天是法定节假日（即除夕、春节、初二）拿三薪，每天加班费为（月工资÷21.75×300%），后四天是双休日调休（即初三至初六）拿双薪，每天加班费为（月工资÷21.75×200%）。） 最低工资标准（各地不同）： 最低工资不包括以下各项：(一)加班加点工资；(二)中班、夜班、高温、低温、井下、有毒有害等特殊工作环境、条件下的津贴；(三)国家法律、法规和政策规定的劳动者保险、福利待遇；(四)企业或雇主通过贴补伙食、住房等支付给劳动者的非货币性收入。从以上规定可以看出，企业包吃包住属于劳动者的非货币性收入，不能纳入最低工资标准计算范围。此外，实物及有价证券，如单位发给员工的劳保物品、餐票、电影票等，也不能作为计算最低工资标准的组成部分。《关于贯彻执行〈中华人民共和国劳动法〉若干问题的意见》中规定：“劳动者与用人单位形成或建立劳动关系后，试用、熟练、见习期间，在法定工作时间内提供了正常劳动，其所在的用人单位应当支付其不低于最低工资标准的工资。” 人力资源和社会保障部新闻发言人尹成基4月25日透露，目前月最低工资标准最高的是深圳1500元，小时最低工资标准最高的是北京14元。 据中新网报道，截止4月26日，月最低工资标准最高的是深圳1500元，第二是上海1450元，天津和浙江同为1310元并列第三；黑龙江、重庆、江西、海南四省市列倒数后四位，均低于900元。而小时最低工资标准最高的是北京14元，第二、三名是深圳和天津，后三位分别是吉林、黑龙江和海南排在，均低于8元。值得注意的是，由于2011年海南并未调整月最低工资标准，其目前月最低工资830元和小时最低工资7.2元的标准都是倒数第一位。 下列各项个人所得，应纳个人所得税： 一、工资、薪金所得； 二、个体工商户的生产、经营所得； 三、对企事业单位的承包经营、承租经营所得； 四、劳务报酬所得； 五、稿酬所得； 六、特许权使用费所得； 七、利息、股息、红利所得； 八、财产租赁所得； 九、财产转让所得； 十、偶然所得； 十一、经国务院财政部门确定征税的其他所得。 个人所得税的税率（应缴纳的个税＝[(应发工资－四金或三金)－3500]×税率－速算扣除数）： 速算扣除数： 一、工资、薪金所得，适用超额累进税率，税率为3%-45%。 二、个体工商户的生产、经营所得和对企事业单位的承包经营、承租经营所得，适用5%-35%的超额累进税率（税率表附后）。 三、稿酬所得，适用比例税率，税率为20%，并按应纳税额减征30%。 四、劳务报酬所得，适用比例税率，税率为20%。对劳务报酬所得一次收入畸高的，可以实行加成征收，具体办法由国务院规定。 五、特许权使用费所得，利息、股息、红利所得，财产租赁所得，财产转让所得，偶然所得和其他所得，适用比例税率，税率为20%。 新税法主要从4个方面进行了修订： 一、是工薪所得扣除标准提高到3500元。 二、是调整工薪所得税率结构，由9级调整为7级，取消了15%和40%两档税率，将最低的一档税率由5%降为3%。 三、是调整个体工商户生产经营所得和承包承租经营所得税率级距。生产经营所得税率表第一级级距由年应纳税所得额5000元调整为15000元，其他各档的级距也相应作了调整。 四、是个税纳税期限由7天改为15天，比现行政策延长了8天，进一步方便了扣缴义务人和纳税人纳税申报。 年终奖缴税计方算法： 年终奖的含义：年终奖的正式名称叫全年一次性奖金，是单位给予雇员一年来的工作业绩奖励，也是可给可不给的一个项目。 年终奖的由来：奖金对于员工来说是一种物质奖励。如果员工的绩效优良，工作成绩突出，为企业的发展做出了贡献，就应该给予奖励，一来是对员工努力的承认；二来激励员工继续努力工作，实现更佳的工作表现。但记者在对一些企业的调查当中发现，企业在发放年终奖的时候考虑的并不简单，有的目的很明确，就是为了奖励员工们在一年当中所付出的劳动，但也有一些企业发放年终奖的时候是不得已而为之。 年终奖令人欢喜令人忧：辛苦一年了，年底的时候，大家都盼望着能拿到丰厚的年终奖。但是，拿到年终奖之后，不要把个人所得税给忘了。很多人对于年终奖所得税计算方法都是比较迷糊，在这里，简单为大家介绍一下年终奖所得税计算方法，并提供一个年终奖个人所得税计算器.xls，可以方便大家更快捷的算出自己应该交的年终奖所得税。 年终奖所得税计算三种具体方法： 年终奖高于（或等于）费用扣除额的计算按照年终奖缴税规定，个人取得全年一次性奖金且获取奖金当月个人的工资、薪金所得高于（或等于）税法规定的费用扣除额2000元时，计算公式为：应纳税额=个人当月取得全年一次性奖金×适用税率-速算扣除数，个人当月工资、薪金所得与全年一次性奖金应分别计算缴纳个人所得税。 例：李某2008年年终奖为12000元，当月工资、薪金收入为2400元，则应纳税额为1195元。 1、12000÷12=1000（元），适用税率为10%，速算扣除数为25。 2、年终奖应纳税额为12000×10%-25= 1175（元）。 3、当月工资、薪金所得应纳税额为（2400-2000）×5%=20（元）。 4、当月合计应纳税额为1175+20=1195（元）。 二、取得年终奖当月个人工资、薪金所得低于费用扣除额的计算： 如果在发放年终一次性奖金的当月，个人工资、薪金所得低于税法规定的费用扣除额，应将年终奖减除"个人当月工资、薪金所得与费用扣除额的差额"后的余额，再确定年终奖的适用税率和速算扣除数。这时的计算公式为： 应纳税额=（个人当月取得年终奖-个人当月工资、薪金所得与费用扣除额的差额）×适用税率-速算扣除数。 例：刘某当月工资、薪金所得低于2000元（只有1400元），2008年1月13日，该单位再向刘某发放年终奖3000元，因此，应将年终一次性奖金减除当月工资与费用扣除额2000元之间的差额后，计算缴纳个人所得税。据此，刘某在获得这笔年终奖时，应缴纳个人所得税120元。计算过程为： 1、应纳税所得额为3000-（2000-1400）=2400（元）。 2、2400÷12=200元，适用税率为5%，速算扣除数为0。 3、应纳税额为2400×5%=120（元）。 三、是年终奖除以12低于2000也要纳税： 特别需要强调的是，全年一次性奖金除以12后的余额，低于法定费用扣除额2000元也应该纳税。因为纳税人的费用扣除额在工资中已扣除，用全年奖金除以12，主要是为确定适用税率和速算扣除数，不能作为判断是否纳税的依据。 例：高某全年一次性奖金为18000元，用全年奖金除以12后为1500元，虽然这低于法定费用扣除额2000元，但也应按相应税率缴纳税款1775元。 1、18000÷12=1500元，适用税率为10%，速算扣除数为25。 2、应纳税额为18000×10%-25=1775（元）。 2009年8月31日，国家税务总局公布了“关于明确个人所得税若干政策执行问题的通知”。今后，单位在实行“双薪制”（单位为雇员多发放一个月工资）后，“双薪”应全额计算缴纳个人所得税的方法停止执行。 通知指出，近期部分地区反映个人所得税若干政策执行口径不够明确，为公平税负，根据相关规定，《国家税务总局关于个人所得税若干政策问题的批复》第一条，有关“双薪制”的计税方法停止执行。 原办法规定，国家机关、事业单位、企业和其他单位在实行“双薪制”后，个人因此而取得的“双薪”，应单独作为一个月的工资、薪金所得计征个人所得税。对上述“双薪”所得原则上不再扣除费用（起征点2000元），应全额作为应纳税所得额按适用税率计算纳税（即第12个月工资和第13个月工资相加后再扣除起征点费用）。 四、单位发不含税年终奖个人所得税的计算 根据《国家税务总局关于纳税人取得不含税全年一次性奖金收入计征个人所得税问题的批复》（国税函〔2005〕715号）规定，对于年终奖个人所得税由单位负担的，如果个人当月工资薪金所得高于（或等于）规定费用扣除额的，其个人所得税的计算公式如下： （一）按照不含税的全年一次性奖金收入除以12的商数，查找相应适用税率A和速算扣除数A； （二）含税的全年一次性奖金收入=（不含税的全年一次性奖金收入一速算扣除数A）÷（1一适用税率A）； （三）按含税的全年一次性奖金收入除以12的商数，重新查找适用税率B和速算扣除数B； （四）应纳税额=含税的全年一次性奖金收入×适用税率B一速算扣除数B.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/202ca7a5d8e3ae1a560f178a8daeaee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b69ac8030181dbe7c4509fd2f5b9a488/" rel="bookmark">
			Android动态切换主题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件换肤从功能上可以划分三种： 1) 软件内置多个皮肤，不可由用户增加或修改；
最低的自由度，软件实现相对于后两种最容易。
2) 官方提供皮肤供下载，用户可以使用下载的皮肤；
用户可选择下载自己喜欢的皮肤，有些玩家会破解皮肤的定制方法，自己做皮肤使用，或者传到网上给大家用。
参考：http://blog.csdn.net/zhyooo123/article/details/6697186
3) 官方提供皮肤制作工具或方法，用户可自制皮肤。
关于主题和样式：
就像style一样，主题依然在&lt;style&gt;元素里边申明，也是以同样的方式引用。 不同的是你通过在Android Manifest中定义的&lt;application&gt;和&lt;activity&gt;元素将主题添加到整个程序或者某个 Activity，但是主题是不能应用在某一个单独的View里。 @符号和？符号来应用资源。@符号表明了我们应用的资源是前边定义过的(或者在前一个项目中或者在Android 框架中)。问号？表明了我们引用的资源的值在当前的主题当中定义过 关于设置主题的注意事项： 不少同学会发泄setTheme()竟然会无效。那么注意 使用setTheme()只能在Oncreate()之前使用。在setContentView()，还是不行那么就在super.onCreate(savedInstanceState);之前 如果要使用动态切换主题，那么就必须调用actvity.finish()。然后再重新加载setTheme() 一些参考资料： http://www.eoeandroid.com/forum.php?mod=viewthread&amp;tid=160087 http://www.eoeandroid.com/forum.php?mod=viewthread&amp;tid=103123 android自带主题和样式 接下来来看范例： 设有一个main.xml布局文件。 新建一个xml用于放置多个主题。如： &lt;--蓝色主题--&gt; &lt;style name="Theme.Blue"&gt; &lt;item name=" pageBackground"&gt;@style/page_background_bl&lt;/item&gt; &lt;item name="pagePaddingLayout"&gt;@style/page_padding_layout_bl&lt;/item&gt; &lt;/style&gt; &lt;--白色主题--&gt; &lt;style name="Theme.White"&gt; &lt;item name=" pageBackground"&gt;@style/page_background_wh&lt;/item&gt; &lt;item name="pagePaddingLayout"&gt;@style/page_padding_layout_wh&lt;/item&gt; &lt;/style&gt; 注意到这里每个主题中的item名字是相同的，且在布局文件main.xml中 &lt;LinearLayout android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="wrap_content" style="? pageBackground"&gt; main.xml中引用白色主题还是蓝色主题的pageBackground，交由代码处理。动态切换主题。 代码实现动态切换： 创建一个util类，设置一个全局变量保存主题信息。 那么就必须调用actvity.finish()。然后再重新加载setTheme() 下面贴出主要的代码： package irdc.ex03_21; import android.app.Activity; import android.os.Bundle; import android.view.View; import android.view.View.OnClickListener; import android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b69ac8030181dbe7c4509fd2f5b9a488/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/596b4045c542ade62983dca3eafdb49d/" rel="bookmark">
			MC9S12G128 串口通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/***************************************************************** ** 程序名：MC9S12G128 串口 ** 参 数：BusCLK_nM 总线时钟 ** 功 能：使用G128串口通信 ** 注 意：程序中使用的是G128的第一路串口，即（S0，S1） ** 作 者： ** 版 本：v1.0 ** 时 间：2012.5.9 ******************************************************************/ #include &lt;hidef.h&gt; #include "derivative.h" #include &lt;ctype.h&gt; #include &lt;string.h&gt; #include &lt;stdarg.h&gt; #define BusCLK_nM 16000000 #pragma CODE_SEG DEFAULT #define CR_as_CRLF TRUE // if true , you can use "\n" to act as CR/LF, // if false, you have to use "\n\r",but can get a higher speed static int do_padding; static int left_flag; static int len; static int num1; static int num2; static char pad_character; unsigned char uart_getkey(void) { while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/596b4045c542ade62983dca3eafdb49d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bda5feaf65a94e7780a04284505296f1/" rel="bookmark">
			ORA-01931: cannot grant UNLIMITED TABLESPACE to a role on 10g
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL&gt; grant unlimited tablespace to dba_role; grant unlimited tablespace to dba_role * ERROR at line 1: ORA-01931: cannot grant UNLIMITED TABLESPACE to a role The Error ORA-01931: cannot grant UNLIMITED TABLESPACE to a role is an Expected behaviour. This has been identified as BUG 12873187 . Until 11.1.0.7, granting UNLIMITED TABLESPACE privilege to a role raised ORA-1931 error. On 11.2, granting UNLIMITED TABLESPACE privilege to a role succeeds, but CREATE TABLE statement still raises ORA-1950.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bda5feaf65a94e7780a04284505296f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44e38f1297ba35be7505e0b72e4f56b7/" rel="bookmark">
			数据结构之排序算法--C#实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文出处：http://www.cnblogs.com/hfutwyy/archive/2012/04/25/2470173.html
本文中介绍的排序方法主要有以下几种：冒泡排序、选择排序、插入排序、希尔排序、归并排序、堆排序、快速排序。
排序算法之一：冒泡排序（Bubble Sort）
冒泡排序算法是可用的最慢的排序算法之一，但是是最容易理解和实现的一种排序算法。这种排序的得名是由于数值"像气泡“一样升至队列的顶端或者底端而得名，
通过多次遍历整个列，并且比较相邻的数据，如果左边的数值大于右边的数值就进行交换（升序）。
实现代码如下：
//Bubble Sort Code public static void BubbleSort(int[] arr) { for(int i=0;i&lt;arr.Length;i++) { for(int j = 0;j&lt;arr.Length-i-1;j++) { if(arr[j]&gt;arr[j+1]) { int temp = arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } } 排序算法之二：选择排序（Selection Sort)
以数组为例（当然其他的集合类型也是一样），这种排序是从数组的起始处开始，把第一个元素与数组中其他元素进行比较。然后将最小的元素放在第0个位置，接着再从第一个位置开始再次进行排序操作。直到数组的最后一个元素为止。
//Selection Sort Code public static void SelectSort(int[] arr) { int min; for (int i = 0; i &lt; arr.Length-1; i++) { min = i; for (int j = i + 1; j &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44e38f1297ba35be7505e0b72e4f56b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/896d582fe770cc94a511e694a1fcf67c/" rel="bookmark">
			批处理基础：if判断输入参数是否空
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @echo off set one=%1 set two=%2 if "%one%"=="" ( echo 空) else ( echo %1) if "%two%"=="" (echo null) else echo %2 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/369eeed00abda6c9948a925a6dedd5fd/" rel="bookmark">
			Existing &amp;quot;SAMPLE&amp;quot; database found...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是我解决这个问题看到的一个帖子，不错！我就是照着来的（给新手看的）：
I am trying to open up sample database but i cannot go through and it pop up with these message : Existing "SAMPLE" database found... The "-force" option was not specified... Attempt to create the database "SAMPLE" failed. SQL1005N The database alias "SAMPLE" already exists in either the localdatabase directory or system database directory.
Is there anyone who can help me on it Thank you STEP 1: Check first on system db directory &gt;db2 list db directory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/369eeed00abda6c9948a925a6dedd5fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58a8a11434f49d42ac1c4d128e2e2cba/" rel="bookmark">
			人不能被欲望左右
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人不能被物欲左右
很多想得到的，都得到了。但灵魂依旧空洞。
人不能被情欲左右
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55bba2023a2a5fa8966bbca06d6803f3/" rel="bookmark">
			C&#43;&#43;直接初始化和复制初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 （1）复制初始化的基本原理
我们知道，对象在内存中的直接表象是在内存中占有一个一定大小的空间。分配空间是建立对象的第一步。但是刚刚分配的空间就像一个没有开垦的荒田，或者是前面对象占有之后留下来的残余，从理论上讲，由于不管是什么大家都是0101，所以就算没有初始化也是有值的，只是这个值你是不能正确使用的。所以建立对象的关键在于如何对该对象所占有的空间进行正确的初始化。
初始化虽然与赋值的结果很像，但是其所面临的状态和发生的时间是不同的。从他们的功能来讲，初始化与给某个变量赋值的唯一特点就是他是第一次初始化。当然当你认识到这点的时候，他们的区别也就是无所谓了。关键在于，初始化，是一个必须的赋值过程，因为如果你不做这方面的动作，你的对像是一个没有用的（或者不能正常使用的）
直接初始化，就是使用构造函数，定义在申请了对象空间之后如何对各个子空间进行初始赋值，称他们为直接初始化是很贴切的，应为他就是最为普通的初始化，是构建一个完整对象的一个过程——先将空间申请好，然后给各个子空间（数据属性）进行相应的赋值。
复制初始化，特点特别之处在于“复制”二字，核心意义就是，我通过对一个已有对象的完全复制，来构建对象。它的过程可以理解成这样——先申请空间，然后将被复制的对象（空间一样大）的所有内容全部复制过去，就形成了这个对象。所以，要明确，两种初始化的方式，都是一构造函数的形式存在的。区别在于他们的参数方面，复制初始化，表达的就是对一个已有同类型的对象进行复制，那么这种构造函数就应该使用某个对象来进行复制，同时因为，C++参数的传递默认都是值传递，要声明使用引用的方式（要不然就又复制了一次了）；并且是const类型的。
也就是说任何复制初始化的表面特征就是使用“=”号来表达，左边是对该对象的空间的申明，右边是另外一个同类型的对象，注意，一定是同类型的对象（即使不是，也会使用类型转换构造函数来进行构造（前面说过）！形如：
classname objectname=objectname2; //复制初始化。 classname objectname(,,,,,); //直接初始化，有参数。 classname objectname; //直接初始化，没有参数。 classname *objectpointorname=new classname(,,); 这里的操作有两个过程，先使用对象构造函数通过直接初始化构造出一个对象，然后将指针放回，不管有没有参数。
classname objectname=other_objectname3; 这里表达的是，这个othe_objectname3，不是classname这个类型。这个个就要知道，右边的会通过调用直接初始化构造函数，构造出对应的对象，然后调用复制初始化构造函数。
所以： 构造函数应该分为:1)直接初始化构造函数
2）复制初始化构造函数
还是要说，复制初始化构造函数看起来像赋值，但是，其实只是像而已，它其实是借用了这种表象，来触发调用了那个使用同类型对象引用作为参数的复制构造函数。
string null_book="9-999-9999-9"; //先调用了隐式转换的直接初始化构造函数，然后调用了复制初始化构造函数。 string dots(10, '.');//直接调用直接初始化构造函数。 string empty_copy=string(); //先调用显示直接初始化构造函数，然后调用复制初始化构造函数。 string empty_direct; //直接调用没有参数的（默认）构造函数 ifstream file1("filename"); //直接初始化 ifstream file2="filename"; //虽然语法没有错，但是，由于文件对象不能复制，所以不能使用复制初始化，这种做法在文件领域中通常是错误的。 Sales_item item=string("9-999-99999-9"); //这个语法对与错，关键是看Saltes_item有没有隐式（没有使用explicity标志）转换以string类型为参数的构造函数。 （2）构造函数（用于直接或复制初始化 ）的使用模式。 事实上，我们说这些东西特殊，关键是他们时候的时候特殊，两种构造函数（对应两种初始化方式）都有显示和隐式的构造方法。 对于直接初始化，我们知道显示的方法，就是使用类名加上参数（其实就是在调用构造函数），隐式的方法，就是在一个需要该类对象的地方出现了其他的数据类型，于是系统会自动调用对应函数（这个应该在编译的时候应该调用了）因为这个时候可以检测出错误来。 对于复制初始化，最显示的调用手段就是使用“=”符号（这个时候应该成为复制初始化符号）。那么还有许多地方是隐式的调用。如参数传递时，函数返回时，初始化容器时！ 1）对于参数传递：我们知道除非是引用参数，否则就是一个使用上层对象复制初始化函数参数的过程。 2）对于函数返回值：我们知道除非是引用返回，否则在return的那个语句就是使用函数内的对象，复制初始化一个上层对象（通常是临时的，然后马上有被用于） 3）在某些容器初始化的过程中如： vect&lt;string&gt; svec(5); 这里的过程就是，先使用string默认构造出一个实例对象，然后使用这个对象，复制初始化其它的元素。这个过程是容器的实现细节，其实从外面看，可以理解为直接初始化。 4）数组初始化，有时候使用这样的语法： Sales_item primer_eds[]={ string("1231231"), string("3123123") } 可知这个过程，就是一个先调用直接初始化生成string，然后继续隐式调用直接初始化生成Sales_item。最后使用复制初始化，给那个数组的各个元素初始化。 从上面两个关于容器（包括数组）的初始化过程可以看出，他们与普通的类（也是包含许多的元素对象）的不同了 ！ （3）组装复制构造函数。 对，我们现在学习了，默认构造函数（没有参数的，可能是系统定义，可能是用户定义，系统只有在没有任何构造函数的情况下定义默认构造函数），而系统定义的默认构造函数就叫做组装默认构造函数，还有一种特殊的构造函数——类型转换构造函数（其实并不特殊）；现在学习了组装复制构造函数（只要用户没有主动构造一个复制构造函数（使用类型引用做参数），系统就会自行组装）；就算只定义了复制构造函数，系统也不会自动组装默认构造函数，所以，如果你定义了复制构造函数，那么一定要定义普通构造函数（最好有默认构造函数）。要不然，就没有构造函数了。 想到这里，我们发现不管什么什么类型的构造函数，功能都是实例并初始化对象，可能复制构造函数与普通构造函数的过程有些不同（其实就是使用的方法和领域不同），但是他们仍然是平等的。所以只有一个默认构造函数，并且只有当没有任何自定一构造函数的时候，系统才会有组装构造函数；而复制构造函数，是一定有的（不管在什么情况）。 其实复制构造函数的本质依然是构造函数，它的功能就是使用那个已知的对象中的元素，“逐个”的赋值给那个需要初始化的对象。所以，你可以把组装复制构造函数，想象成一个带有所有对象元素（顺序也一至）的初始化列表的构造函数。 与普通构造函数一样，涉及到对某个元素的初始化时，对于内建类型，直接使用copy的方法，对于类类型，使用定义复制构建函数。如果没有定义复制构建函数，就使用组装的，毕竟复制构建函数的参数是一定的，所以基本不存在无法复制的元素的可能。 但是直接构造函数就有可能出现，子元素没有默认构造函数的情况，而不能进行构造，并且直接构造的时内建类型也有可能不初始化（依编译器而定）。 另外一个要注意的是，虽然我们没有办法进行复制初始化数组（这就是为什么数组没有办法作为参数传递，或则作为返回值返回，或者定义的时候用一个数组来复制初始化另外一个数组），但是当数组在某个其他类型的里面的是后，这个时候如果发生了复制初始化，作为元素的数组会也被复制初始化，但是，是通过逐个复制元素的方法。 （4）自定义复制构造函数 class Foo{ public: Foo(); //默认构造函数 Foo(const Foo&amp;); //复制构造函数 } 其中，const可以不写（但通常建议这么做），由于复制的作用要用到传递参数、返回值，这些都是隐式的调用，所以一定不能将其声明为explicit。所以可以知道explicit的作用就是承认在可能的情况下，系统默认在需要使用该函数的情况下，能不能自动使用。 从前面我们说可以将组装复制构造函数用相应的带有完全初始化列表的构造函数来代替，我们可以发现，复制构造函数要实现的功能基本稳定，所以通常组装复制构造函数基本可以满足要求。 所以我们经常不怎么自己定义复制构造函数，但是有些时候程序实现要求我们必须自定义构造函数，这个时候我们就表明了，构建复制构造函数的困难之处，不在于语法 ，它与普通的构造函数是一样的；关键是在，构建这个东西的用途，当用途明确后，其他就简单了。 有些时候，例如 1）对象成员是一个指向某个资源的指针（用户本意不想只是复制指针，那表明没有复制指针指向的对象）， 2）或者该类型规定每新建一个对象需要做一些动作，那么这个时候就需要自定义复制构造函数 （注意哦！与普通构造函数一样，构造函数理论上的功能包括空间分配、元素初始化，以及相关处理，那个复制初始化符号“=”左右应该看成一个整体。） 3）或者该类型的每个对象都富有一个唯一ID成员的机制 （5）如何阻止类的复制初始化功能 1）我们知道，我们使用explicity可以声明，该复制构造函数不能被隐式使用，于是在参数、返回值的那些地方都不能用，但是如何让普通的复制初始化也不用呢？ 那就是声明为private。我们说过。构造函数的特殊还在于，它是直接被外层使用的，不需要套一个什么类的帽子（因为它就是类名），所以如果申明为private那么就不能使用了，这就是为什么大部分的构造函数都被申明为public了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a9d0940b4cababaf9fa27adc565cd79/" rel="bookmark">
			一个医院院长电视机坏了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一个医院院长电视机坏了，拿到一个大修理店去修。
修理店接待人员:“OK，开机费50元”
医院院长: “为什么还没修理就要先交费”？
修理店接待人员: “我们修理店的制度就是这样，你们医院的挂号费，不是没看病之前就要交吗”？
医院院长无话可说，只好交了50元。
修理店接待人员问：“你好，请问你的电视机出了什么问题？”
医院院长:“就是没有反应了，声音图像都没了。” 修理店接待人员:“看来你的电视是内部出了问题，那你要看内科，再请问你要看工程师还是高级工程师，修理费是工程师加收20元，高级工程师要加收30元。” 医院院长:“不就是修电视机吗？修好就可以了，我管他什么工程师还是高级工程师”？
修理店接待人员:“不一样的，高级工程师水平高，什么疑难问题的电视都能修理好，修好的返修率也明显低于工程师，但是修理费相对高一点，所以这个由顾客您自己选择”。
医院院长:“我的电视应该不算疑难杂症，就一般工程师就好了”。
修理店接待人员: “那好，请你先交20元修理费”。
医院院长: “为什么还没修理就要先交费”？
修理店接待人员: “我们修理店的制度就是这样，你们医院不是没看病之前就要交吗”？
医院院长无话可说，只好又交了20元，将电视机捧进修理店，来到了工程师的工作。工程师问了一下电视机的情况，先开了三个付费单请医院院长交费：
一、万用表测量费20元;
二、示波器测量费50元; 三、扫频仪费80元。
医院院长惊问：“为什么要顾客出这个测试费，这不是方便你们修理工程师的吗？”
工程师：“没错，我们的工程师以前也是靠“望、闻、问、切、听”，凭经验修理，可是现在科学发达了，什么仪器都有了，修理时做了测试会比较准确，也能测试出目前暂时还没有显现的故障出来。而且，我们买这些仪器仪表要花费大量资金，所以我们要收一些合理的费用。你的还好，没有用到更多仪器，上次一个客户送一个电器，我们用了网络分析仪测试天线抗阻，测试费就是150元，人家也是测了。我们会尽量替顾客着想，尽量少一些测试，为顾客省钱。当然你也可以坚持不测试，但我们修理时，可能会判断错误将好的零件换掉，给顾客造成不必要的费用。也可能修不好你的电器，最后耽误你的时间。”
医院院长只好先交了150元测试费。 工程师经过半个小时测试，用打印机打出一张线路图，发现是一个三极管烧了，他花几分钟，换了个二元钱的三极管就修好了电视机。
工程师把打印好的线路图塞到院长手中后开了一张缴费单，叫医院院长去交8元打印费。院长不解的问：“打印费也要我出啊？”“是的，这是店里的规定，打印费由顾客出，那张图不是给你了吗？”“可我看不懂啊，要这张图干啥？”“你们医院给病人做B超，打印的绘图病人也看不懂啊，不照样是病人出钱吗”？
医院院长无语，只好去交钱。 最后，工程师对院长说，我们店实行电脑管理，请你去提货柜台提货。
提货柜台打了一个修理清单给医院院长交费，缴费单上写着：
“据物价局规定，我店实行分项收费，做到使顾客明明白白消费。你本次修理收费如下： 35W白光牌烙铁使用费（拆焊各1次）：10元; 一次性烙铁头清洁棉： 2元;
吸枪使用费1次：5元; φ0.8环保锡线10g :5元; 2N1234三极管1个 ：2元; 剪三极管管脚斜口钳使用费：5元; 焊接后清洗焊盘洗板水费：5元;
拆焊三极管、清洗焊盘等人工费： 20元; 合计：54元”。
医院院长看了差点晕倒。医院院长的修电视共花了282元钱，只换了一个价值二元的配件 注：请大家转发所有的群：极积反映医院收费情况 ，希望中国医疗有关订制改革，真正帮到百姓! 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9002821f4bce101551b79d5f283d7d7e/" rel="bookmark">
			02_UVaOJ_ AOAPC I_Beginning Algorithm Contests (Rujia Liu)_Volume0_Getting Started
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刘汝佳白书推介（第01~04章相关UVaOJ题目练习）
Root :: AOAPC I: Beginning Algorithm Contests (Rujia Liu) :: Volume 0. Getting Started
内容包括：题目列表，相关题目的.cpp（题目，分析，代码）
题目难度参考于：http://www.cnblogs.com/devymex/archive/2010/08/26/1808716.html
[难度：3] 10055 - Hashmat the Brave Warrior
[难度：3] 10071 - Back to High School Physics
[难度：5] 10300 - Ecological Premium
[难度：39] 458 - The Decoder
[难度：42] 494 - Kindergarten Counting Game
[难度：34] 414 - Machined Surfaces
[难度：42] 490 - Rotating Sentences
[难度：37] 445 - Marvelous Mazes
[难度：41] 488 - Triangle Wave
[难度：42] 489 - Hangman Judge
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9002821f4bce101551b79d5f283d7d7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91d929028db0567552669a3ebef8ebaa/" rel="bookmark">
			字符数组和字符指针的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 字符数组和字符指针变量之间是有重要区别的，下面分别介绍这些区别。 字符数组是由若干个数组元素组成的，每个元素占用一个存储单元，保存一个字符。而字符串指针变量本身是一个变量，用来保存字符串常量的首地址。如果字符串指针变量没初始化而使用，将产生不可预料的后果。 例如： char s[50]; char *ps; scanf("%s",s); scanf("%s",ps); 以上程序中，第1行定义了一个字符数组，编译器将会分配50个连续的存储单元。而第2行定义字符串指针变量，编译器只分配4个字节用来存放字符串常量的首地址，由于指针变量的值还未初始化，所以ps变量中的值还是未知的。第3行程序接收用户输入，并保存到数组s中，这是正确的。而第4行程序却带来问题，因为ps的值为未知的，而该语句将用户输入的内容保存到一个未知的内存区域，可能会使系统崩溃。因此，必须先对字符串指针变量进行初始化，使其指向一个确定的内存区域，然后才能使用。例如，可用以下方式初始化： char s[80]; char *ps=s; scanf("%s",ps); 前面曾反复提到，数组名是数组的首地址，是一个指针常量，确定存储位置后就不能改变。而字符串指针变量是一个变量，该变量保存的字符串常量首地址是可以改变的，即字符串指针变量可以指向不同的字符串常量，如图所示。当字符串指针变量ps指向第一个字符串常量时，变量ps就表示第一个字符串，当指向第二个字符串常量时，变量ps就表示第二个字符串。 例如： char s[]="The Beijing 2008 Olympic Games"; 是正确可行的，但以下语句却不能被编译： char s[80]; s="The Beijing 2008 Olympic Games"; 字符串常量只能在初始化数组时一次性保存到数组的各元素中。数组定义后，要改变字符数组的值，就只能逐个修改数组元素的值，例如，可以按以下方式对数组各元素分别赋值： char s[80]; s[0]='T'; s[1]='h'; 而对于字符串指针变量，可使用以下方式修改指针变量所指向的字符串常量： char *s; s="The Beijing 2008 Olympic Games"; s=" One Word, One Dream!"; 在程序执行过程中，可随时改变字符串指针变量的值，实质是将另一个字符串常量的首地址填入字符串指针变量中，使其指向新的字符串常量。
从以上几点可以看出字符串指针变量与字符数组在使用时的区别，同时也可看出使用指针变量更加方便。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52472f4295bc46aafc2d9e0ea8586734/" rel="bookmark">
			const形参的函数重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转自：http://www.cppblog.com/Marcky/archive/2009/07/12/89796.html
《C++ primer》中提到“仅当形参是引用或指针的时候，形参是否为const才对重载有影响。”
int add(int a, int b); int add(const int a, const int b);我想通过定义这两个函数来实现实参是否为const的重载，可事与愿违，这里的第二个函数并没有对第一个进行overloading，而是redefinition。因为，在此的两个函数的形参并不会直接关联到实参，在调用这两个函数的时候， 形参都只是实参的一个副本，不管add函数内部对形参做什么处理，都不会影响到实参，也就是说——第二个函数形参中的const没有任何的用处，只是多此一举罢了。所以在此的第二个定义只是对第一个的重定义罢了。 int add(int &amp;a, int &amp;b); int add(const int &amp;a, const int &amp;b);这次定义的两个函数与上面不同的地方就是形参使用了引用。这个时候编译器就完全可以根据实参是否为const确定调用哪一个函数了。调用如下： //非const变量x, y int x = 1; int y = 2; add(x, y); //call add(int &amp;a, int &amp;b) //const变量x, y const int x = 1; const int y = 2; add(x, y); //call add(const int &amp;a, const int &amp;b)上述第一种情况：实参为非const对象的时候，其实两个函数都可以被调用，都与之匹配，因为非const对象不但可以初始化非const引用，也可以初始化const引用。但由于非const对象初始化const引用的时候涉及到类型转换，所以此时带非const引用形参的函数为最佳匹配。 上述第二种情况：实参为const对象的时候，就不能将此对象传递给带非const引用的形参的函数了，因为const对象只能用来初始化const引用。 int add(int *a, int *b); int add(const int *a, const int *b); //非const对象 int x = 1; int y = 2; //cosnt对象 const int r = 1; const int s = 2; add(&amp;x, &amp;y); //call add(int *a, int *b); add(&amp;r, &amp;s); //call add(cosnt int *a, cosnt int *b);利用带const指针形参进行重载也是合法的，其中的原理和const引用形参完全一样。 应该注意这里是基于指针本身是否为const来实现的重载，而不是指针所指向的对象是否为const。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/568/">«</a>
	<span class="pagination__item pagination__item--current">569/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/570/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>