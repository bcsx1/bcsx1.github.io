<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f496e7620eb0dd35b1c8d99930360de/" rel="bookmark">
			setContentView流程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PhoneWindow的创建 通过在ActivityThreed中performLaunchActivity方法拿到activity
然后再Activity中attach方法new PhoneWindow
然后回到ActivityThreed中performLaunchActivity方法中 mInstrumentation.callActivityOnCreate()执行oncreate
继承 Activity 的流程 PhoneWindow.setContentView — 主要目的 创建 DecorView 拿到 Content
创建DecorView
第一个分支
第二个分支
protected ViewGroup generateLayout(DecorView decor) { ... else { //举个例子 用R.layout.screen_simple layoutResource = R.layout.screen_simple; } mDecor.startChanging(); mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); //id/context赋值到mContentParent ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); } 看下图id/context就是mContentParent就是activity_main
然后回到setContentView()将R.layout.activity_main进行渲染到mContentParent
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3953da43194d8370cf00a25c89b30e22/" rel="bookmark">
			持久化缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Improve build performance with Persistent Caching （通过使用持久性缓存来提高构建性能） Cache基本配置 在 Webpack 4 中，cache 只是单个属性的配置，所对应的赋值为 true 或 false，用来代表是否启用缓存，或者赋值为对象来表示在构建中使用的缓存对象。而在 Webpack 5 中，cache 配置除了原本的 true 和 false 外，还增加了许多子配置项，例如：
cache.type：缓存类型。值为 'memory'或‘filesystem’，分别代表基于内存的临时缓存，以及基于文件系统的持久化缓存。在选择 filesystem 的情况下，下面介绍的其他属性生效。cache.cacheDirectory：缓存目录。默认目录为 node_modules/.cache/webpack。cache.name：缓存名称。同时也是 cacheDirectory 中的子目录命名，默认值为 Webpack 的 ${config.name}-${config.mode}。cache.cacheLocation：缓存真正的存放地址。默认使用的是上述两个属性的组合：path.resolve(cache.cacheDirectory, cache.name)。该属性在赋值情况下将忽略上面的 cacheDirectory 和 name 属性。
单个模块的缓存失效
Webpack 5 会跟踪每个模块的依赖项：fileDependencies、contextDependencies、missingDependencies。当模块本身或其依赖项发生变更时，Webpack 能找到所有受影响的模块，并重新进行构建处理。
这里需要注意的是，对于 node_modules 中的第三方依赖包中的模块，出于性能考虑，Webpack 不会跟踪具体模块文件的内容和修改时间，而是依据依赖包里package.json 的 name 和 version 字段来判断模块是否发生变更。因此，单纯修改 node_modules 中的模块内容，在构建时不会触发缓存的失效。
全局的缓存失效
当模块代码没有发生变化，但是构建处理过程本身发生变化时（例如升级了 Webpack 版本、修改了配置文件、改变了环境变量等），也可能对构建后的产物代码产生影响。因此在这种情况下不能复用之前缓存的数据，而需要让全局缓存失效，重新构建并生成新的缓存。在 Webpack 5 中共提供了 3 种不同维度的全局缓存失效配置。
1、buildDependencies
第一种配置是cache.buildDependencies，用于指定可能对构建过程产生影响的依赖项。
它的默认选项是{defaultWebpack: ["webpack/lib"]}。这一选项的含义是，当 node_modules 中的 Webpack 或 Webpack 的依赖项（例如 watchpack 等）发生变化时，当前的构建缓存即失效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3953da43194d8370cf00a25c89b30e22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82c1725b33b5393abaa0526d2e110986/" rel="bookmark">
			操作系统小命令 （创建、删除用户）&#43; 第一次linux下写C代码 &#43; “- su: cd /desktop: 没有那个目录或文件”错误提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天出于好奇，搞了搞操作系统的操作，知道了一些零散的操作系统的小知识点，简单记录一下（杂记），还有一个让我烦恼但是又很无奈的小插曲......
一：小记
GNOME：我理解是进入虚拟机后的那个桌面
打开虚拟机终端：Ctrl+Alt+T
小命令：
1、cd Desktop：（进入桌面）
2、cd(空格).. :（返回上一目录）
3、dir/ls：查看当前目录下内容
4、ps：显示当前shell或终端窗口中，当前用户的进程信息
5、ps -e：显示系统中每一个进程的信息
6、ps -f：产生一个完全列表，给出每个进程的所有可用信息
7、ps -u userid：显示特定用户的所有进程
8、kill(空格)PID：终止一个标识符为PID的进程（软杀死：可以正确地关闭文件，温和地终止进程。）
9、kill(空格)-9 PID：强制终止一个进程（强制杀死）
（对于shell之外的进程，把kill –9 PID作为最后的选项，因为它是一种生硬的方法，不允许正确的进程终止。）
10、
创建一个新用户（要转到root权限下才能创建新用户，转用户不懂的可以看表格下方的方法噢）：
step1：useradd(空格)用户名：用户名我用 Try useradd Try
使用该命令不会为新创建用户在/home下自动创建于用户名同名的用户名目录，不会自动选择shell版本，不会主动让你设置密码，简言之，就是不能成功登录。（因为我的一个用户这么创建了，反复输入密码后重新跳回登陆界面）
推荐使用：sudo adduser try（或者：adduser try） //用户名与上面不同，因为我下面有两
个分别的例子
这个会在 /home下自动创建于用户名同名的用户名目录和系统shell版本，会在创建时提示输入密码。
step2：用 passwd(空格)用户名 为新用户设置密码：
passwd Try
step3：使用cd(空格)/home/ 转换用户的 su 命令看能不能转到新用户Try，可以的话则创建成功。
cd /home/
su Try 所示如下（糊掉的只是用户名啦 &gt;_&lt; ）：
su Try 后用 whoami 查看当前用户：
（但是！！！！这个是不能登录的，也就是用useradd Try创建的用户！！！） ----------------------------上方su后没有进行用户状态的改变，命令外方只有一个$-------------------------
-----------------------下方su后改变并进入了新用户状态，前边有带颜色的用户名-------------------------- （建议：用sudo adduser Try（或者：adduser Try），成功后应该为如下所示：！！！）
这个是后来创建的用户，用户名和上面有点不一样，没关系哒
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82c1725b33b5393abaa0526d2e110986/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/537f44627412f1a4b8d333fb16e479d7/" rel="bookmark">
			Vue中的计算属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、计算属性computed 表达式的计算逻辑可能会比较复杂，使用计算属性可以使模板内容更加简洁
注意：下边的例子为computed的普通用法，默认执行get函数
计算属性中的函数必须有return
&lt;div id="app"&gt; &lt;h1&gt;{{getValue}}&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:"#app", data:{ value:"在天愿做比翼鸟" }, computed:{ getValue(){ return this.value; } } }); &lt;/script&gt; 2、computed vs methods 我们可以使用 methods 来替代 computed，效果上两个都是一样的，但是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用 methods ，在重新渲染的时候，函数总会重新调用执行。
3、computed高级 getter：获取数据【当使用到了计算属性，就会自动执行get函数】
setter：设置数据【当更改了计算属性，就会自动执行set函数】
&lt;div id="app"&gt; &lt;button @click="getName = '王安'"&gt;更改computed数据&lt;/button&gt; &lt;h1&gt;{{getName}}&lt;/h1&gt; &lt;h1&gt;{{getName}}&lt;/h1&gt; &lt;h2&gt;{{num}}&lt;/h2&gt; &lt;button @click="myClick"&gt;点击&lt;/button&gt; &lt;button @click="myClick"&gt;点击&lt;/button&gt; &lt;h1&gt;{{count}}&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:"#app", data:{ name:"王先生", num:0, count:0 }, methods:{ myClick(){ this.count = this.count+=1; } }, computed:{ getName:{ get:function () { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/537f44627412f1a4b8d333fb16e479d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/397a961333057347882066b43db22bb6/" rel="bookmark">
			DataX（MySQL同步数据到Doris）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 编译DataX doriswriter pluginDataX mysqlreader 写入数据到Doris性能测试Bug 记录 1. 编译 doriswriter doriswriter 插件
https://github.com/apache/incubator-doris/tree/master/extension/DataX
步骤（按需修改源代码） 从github上拉取源码（或者直接在上面地址下载包） git clone https://github.com/apache/incubator-doris.git 不过执行 init 即可
2. 运行 init-env.sh
主要做了下面几件事，减少了繁杂的操作。
（1）将 DataX 代码库 clone 到本地。
（2）将 doriswriter/ 目录软链到 DataX/doriswriter 目录。
（3）在 DataX/pom.xml 文件中添加 doriswriter 模块。
（4）将 DataX/core/pom.xml 文件中的 httpclient 版本从 4.5 改为 4.5.13（因为有bug）
编译 doriswriter （1）命令
mvn clean install -pl plugin-rdbms-util,doriswriter -DskipTests （2）编译完地址
../target/datax/datax/ 把编译完的包放到plugin下即可 ../datax/plugin/ 具体可看Doris官网 http://doris.incubator.apache.org/zh-CN/extending-doris/datax.html
2. MySQL同步数据到Doris 创建Doris表 CREATE TABLE `mars_micro_user_events` ( `id` bigint, `user_id` bigint DEFAULT NULL , `group_type` int DEFAULT NULL, `group_id` int DEFAULT NULL, `event_type` varchar(45) DEFAULT NULL, `event_name` varchar(45) DEFAULT NULL, `event_count` int DEFAULT NULL, `event_time` bigint DEFAULT NULL, `created_time` bigint DEFAULT NULL, `updated_time` bigint DEFAULT NULL ) ENGINE=OLAP DUPLICATE KEY(id) COMMENT "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/397a961333057347882066b43db22bb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b8a79dd7eca7d7a72b273a4150b03f6/" rel="bookmark">
			Doris 分区与分桶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分区与分桶概述 分区与分桶秉承着"大而化小，分而治之"的目标，目的都是为了便于查询，提高查询的效率。
分区的定义: 对数据进行水平切分，水平切分之后数据是完全物理隔离的，每个分区即为一个物理文件夹。
比如一个网站每天的埋点行为日志数据量比较大，在查询时进行全表扫描耗费的资源非常多。那在这个情况大数据体量下，可以按照每天日期对数据表进行分区，不同日期的数据存放在不同的分区下，在查询时只要指定分区字段的值就可以直接从该分区查找。
分桶的定义: 对数据进行垂直切分，各个分桶相互独立，每个分桶即为一个文件。
比如我们按照name列分为4个桶，就是对name列值的hash值对4取摸，按照取模结果对数据分桶。如取模结果为0的数据记录存放到一个文件，取模为1的数据存放到一个文件，取模为2的数据存放到一个文件、取模为3的数据存放到一个文件。
从上面可见，分区注重粗粒度，而分桶注重细粒度。同时需要注意的是这存在一定的担忧：分区容易造成数据倾斜。
今天主要讲讲，Doris分区与分桶。
Doris支持两级分区存储, 第一层为 range 分区，也可支持list方式, 第二层为 hash分桶。
Drois分区 注意点 （1）分区列必须为key列。
（2）分区列可以指定一列或多列。
（3）不论分区列是什么类型，在写分区值时，都需要加双引号。
（4）add partition添加分区，可以为该分区单独指定桶的数量。
Range 分区 通过 values less than (xxx) 仅指定上界，系统会将前一个分区的上界作为该分区的下界，生成一个左闭右开的区间。
同 Range Partition，当导入数据值在分区范围外，则不会被导入。
PARTITION BY RANGE (`dt`) ( PARTITION p_20220501 VALUES LESS THAN ("2022-05-01"), PARTITION p_20220502 VALUES LESS THAN ("2022-05-02"), PARTITION p_20220503 VALUES LESS THAN ("2022-05-03"), PARTITION p_20220504 VALUES LESS THAN ("2022-05-04") ) List 分区 通过 VALUES IN (xxx) 来指定每个分区包含的枚举值，分区值为枚举值。只有当数据为目标分区枚举值其中之一时，才可以命中分区。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b8a79dd7eca7d7a72b273a4150b03f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e348bc1a9786471323f62b44720c2dcc/" rel="bookmark">
			NERF&#43;&#43;: ANALYZING AND IMPROVING NEURAL RADIANCE FIELDS分析和改进神经辐射场
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
NERF++: ANALYZING AND IMPROVING NEURAL RADIANCE FIELDS分析和改进神经辐射场
ABSTRACT
1 INTRODUCTION
2 PRELIMINARIES
3 SHAPE-RADIANCE AMBIGUITY形状-辐射模糊度
4 INVERTED SPHERE PARAMETRIZATION反向球体参数化
NERF++: ANALYZING AND IMPROVING NEURAL RADIANCE FIELDS分析和改进神经辐射场 ABSTRACT 神经辐射场(NeRF)为各种捕捉设置实现了令人印象深刻的视图合成结果，包括有界场景的360°捕捉360◦ capture of bounded scenes以及有界和无界场景的前向捕捉forward-facing capture of bounded and unbounded scenes。NeRF将表示视图不变不透明度view-invariant opacity和视图相关颜色体积的view-dependent color volumes多层感知器(MLPs)拟合到一组训练图像，并基于体积绘制技术对新视图进行采样。在这份技术报告中，我们首先讨论了辐射场及其潜在的模糊性potential ambiguities，即形状辐射率的模糊性shape-radiance ambiguity，并分析了NeRF在避免这种模糊性方面的成功之处。第二，我们提出了一个参数化问题，它涉及到将NeRF应用于大规模、无边界3D场景中的360°物体特征。我们的方法在这种具有挑战性的场景中提高了视图合成的保真度。代码可在https://github.com/Kai-46/nerfplusplus.获得
1 INTRODUCTION 回忆一下你的上一个假期，在那里你拍了几张你最喜欢的地方的照片。现在在家里，你希望再次在这个特别的地方走动，如果只是虚拟的。这要求您在一个可能无限的场景中从不同的、自由放置的视点渲染同一个场景。这种新颖的视图合成任务是计算机视觉和图形学中的一个长期存在的问题(Chen &amp; Williams，1993；Debevec等人，1996年；莱沃伊和汉拉汉，1996年；Gortler等人，1996年；Shum &amp; Kang，2000年)。
最近，基于学习的方法已经导致了照片级的新颖视图合成的重大进展。特别是神经辐射场(NeRF)的方法已经引起了极大的关注(Mildenhall等人，2020)。NeRF是一个隐式的基于MLP的模型，它将5D向量(3D坐标加上2D观察方向)映射到不透明度和颜色值，通过将模型拟合到一组训练视图来计算。然后，所得到的5D函数可以用于利用传统的体绘制技术生成新的视图。
在本技术报告中，我们首先对NeRF中的潜在故障模式进行了分析，并分析了NeRF在实践中避免这些故障模式的原因。第二，我们提出了一种新的空间参数化方案novel spatial parameterization scheme，我们称之为反向球面参数化inverted sphere parameterization，它允许NeRF处理一类新的无界场景捕获captures of unbounded scenes。
图1：形状辐射模糊度（左）和无边界场景的参数化（右）。形状歧义Shape-radiance ambiguity：我们的理论分析表明，在缺乏显式或隐式正则化，一组训练图像可以独立于恢复几何(例如，不正确的场景几何Sˆ而不是正确的几何S∗)通过利用视图相关的辐射来模拟正确的几何的效果。无界场景的参数化Parameterization of unbounded scenes：使用标准参数化方案，要么只建模部分场景（红色轮廓），导致背景元素中的重要伪影，或（2）整个场景被建模（橙色轮廓），这导致由于有限的采样分辨率的细节的总体损失。
特别地，我们发现在理论上，在没有任何正则化的情况下，从一组训练图像优化5D函数会遇到不能推广到新的测试视图的临界退化解critical degenerate solutions。这种现象被封装在形状-辐射模糊度中shape-radiance ambiguity(图1，左)，其中通过适当选择每个表面点的出射2D辐射outgoing 2D radiance，可以为任意不正确的几何形状完美地拟合一组训练图像。我们的经验表明，NeRF中使用的特定MLP结构在避免这种歧义方面发挥了重要作用，产生了令人印象深刻的综合新观点synthesize novel views的能力。我们的分析为NeRF令人印象深刻的成功提供了一个新的视角。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e348bc1a9786471323f62b44720c2dcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93841548eb807648d8fe003fd977efb9/" rel="bookmark">
			IntelliJ IDEA插件的Jrebel激活踩坑【内网离线使用】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【前言】
Jrebel默认是需要外网在每一次使用时实时激活的，但是我们好多情况都是内网使用，所以我查了很多资料找到了一个解决方案！
Jrebel 破解方法：https://www.jb51.net/article/199354.htm
Jrebel 脱机工作
不管是在线激活还是自己搭建服务器激活，在重启IDEA，再使用JRebel部署应用的时候，都会访问激活用的服务器校验证书，假设公网网络不能访问，或者许可证服务器没启动，都会导致JRebel不可用。
所以推荐启用Work offline脱机模式，脱机模式可以在激活后，180天内不用再激活，到期后，再把许可证服务器启动，激活一次就可以继续脱机模式。
work offline ： 可离线180天，期间Jrebel不再连服务器激活，后面过期后，再激活，再离线，重复如此即可！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6a408065491717ac44ef2098c08ea5e/" rel="bookmark">
			SkeyeExPlayer(Windows)开发之跨语言调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面我们来讲解一下关于SkeyeExPlayer接口的调用，主要分为C++和C#两种语言，C++也可以基于VC和QT进行开发，C++以VC MFC框架为例进行讲解，C#以Winform框架为例进行讲解。
VC开发SkeyeExPlayer
首先建一个基于MFC Dialog的工程，取名叫SkeyeExPlayer，关于界面逻辑的处理过程就不做过多赘述了，大家有兴趣的可以去看SkeyeExPlayer项目代码；下面我们讲解一下SkeyeExPlayer的调用流程：
(1) 打开一个流或文件进行播放
通过SkeyeExPlayer_Open打开一个流或者本地文件，打开以后即播放，不需要调用SkeyeExPlayer_Play方法，调用完成后，注意，比如拉网络流的时候，由于Open函数是非阻塞而立即返回的，所以，播放过程可能尚未初始化完成，从而获取流的信息可能获取不到，正确的做法是在线程或者计时器里面轮询获取；Open完成后，我们可以对一些参数进行设置，比如设置OSD和图片叠加，显示模式，音量大小等：
// player open file m_player = SkeyeExPlayer_Open(str, m_stcVideoWnd-&gt;GetSafeHwnd()); if (m_player) { m_bPlayPause = FALSE; SetTimer(TIMER_ID_PROGRESS, 1000, NULL); m_bOpening = TRUE; //字幕和图片叠加 // // SkeyeExPlayer_SetLogo 设置台标/LOGO // player	- 指向 SkeyeExPlayer_Open 返回的 player 对象 // bIsUse	- 是否使用水印 1=启用 0=不启用 // ePos	- 台标位置：1==leftttop 2==righttop 3==leftbottom 4==rightbottom // eStyle	- 水印的风格，见WATERMARK_ENTRY_TYPE声明 // x	- 水印左上角位置x坐标 // y	- 水印左上角位置y坐标 // width	- 宽 // height	- 高 // logopath	- 水印图片路径 SkeyeExPlayer_SetLogo (m_player, 1, 2, 3, 0, 0, 0, 0, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6a408065491717ac44ef2098c08ea5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22026e07c8c4e481c272f82fdd7e8159/" rel="bookmark">
			react项目require导入图片不显示，网页查找元素显示[object module]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法：在你导入图片的后面加上.default
具体解释可查看https://zhuanlan.zhihu.com/p/262272714
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29f818c08f7c322c7fb4f88e5fe43445/" rel="bookmark">
			Swagger—API接口文档使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Swagger介绍 Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务 (https://swagger.io/)。 它的主要作用是：
使得前后端分离开发更加方便，有利于团队协作 接口的文档在线自动生成，降低后端开发人员编写接口文档的负担 功能测试：Spring已经将Swagger纳入自身的标准，建立了Spring-swagger项目，现在叫Springfox。通过在项目中引入 Springfox ，即可非常简单快捷的使用Swagger。 2 SpringBoot集成Swagger 1. 在项目中添加依赖。
&lt;!‐‐ Swagger依赖 ‐‐&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;/dependency&gt; 2. 在工程的config包中添加一个Swagger配置类
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Contact; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; @Configuration @ConditionalOnProperty(prefix = "swagger",value = {"enable"},havingValue = "true") @EnableSwagger2 public class SwaggerConfiguration { @Bean public Docket buildDocket() { return new Docket(DocumentationType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29f818c08f7c322c7fb4f88e5fe43445/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23736790f4965c9ee74f705b6e477594/" rel="bookmark">
			RocketMQ 阿里云部署 公网IP 配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天将RocketMQ部署到阿里云上的时候
发现一直抱如下错误
[2022-05-16 13:11:33.207] ERROR collectTopicThread_6 - Failed to collect topic: TopicTest data org.apache.rocketmq.remoting.exception.RemotingConnectException: connect to 172.21.67.142:10911 failed at org.apache.rocketmq.remoting.netty.NettyRemotingClient.invokeSync(NettyRemotingClient.java:407) at org.apache.rocketmq.client.impl.MQClientAPIImpl.queryTopicConsumeByWho(MQClientAPIImpl.java:1702) 其中的172.21.67.142:10911是我们阿里云的私网IP，自然是连不到的，所以需要配置一下broker 的公网IP
配置方法如下
1、前往RocketMQ的目录，找到conf下的broker.conf
2、在最后面添加
brokerIP1 = 阿里云公网IP namesrvAddr = 阿里云公网IP:9876 3、阿里云开放接口 10909、10911、9876
4、启动namesrv
nohhup sh mqnamesrv &amp; 5、启动broker并且设置conf
nohup sh mqbroker -c ../conf/broker.conf &amp; 这样配置就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b48fc454edf9f9f954448ef0540e73f1/" rel="bookmark">
			判断JS数据类型的五种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript 中常见的几种数据类型： 目录
JavaScript 中常见的几种数据类型：
一、分类
二、判断
1、typeof
null既然属于基本数据类型，为什么用typeof返回的是object呢？
js小数运算出现的问题(精度丢失)
解决方法一
解决方法二
解决方法三
2、instanceof
3、constructor
细节问题：
4、Object.prototype.toString 5、===
三、相关问题
1、undefined 与 null的区别
2、什么时候给变量赋值为null呢？
3、严格区分变量类型和数据类型？
一、分类 基本类型：string，number，boolean，symbol（ES6新增）基本类型中也有两个特殊的类型，即：undefined，null
引用类型：Object，Function，Array，RegExp，Date,...
二、判断 1、typeof typeof 返回一个表示数据类型的字符串，返回结果包括：number、boolean、string、object、undefined、function等6种数据类型
typeof '123' string // 有效 typeof 1 number // 有效 typeof true boolean // 有效 typeof Symbol('1') symbol // 有效 typeof undefined undefined // 有效 typeof {a:1,b:2} object // 有效 function c(){console.log('123')} typeof c function // 有效 typeof null object // 无效 typeof [] ; //object 无效 typeof new Date(); //object 无效 typeof new RegExp(); //object 无效 总结：typeof 可以对JS基础数据类型做出准确的判断，而对于引用类型返回的基本上都是object, 其实返回object也没有错，因为所有对象的原型链最终都指向了Object,Object是所有对象的`祖宗`。 但当我们需要知道某个对象的具体类型时，typeof 就显得有些力不从心了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b48fc454edf9f9f954448ef0540e73f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf9a545c6dd0be570b0e3120a542ad9e/" rel="bookmark">
			unity之A*寻路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、程序演示 二、 思路解析 我们先来了解一下A*寻路的思路：
1.每个块需要一个数据类(PointTest.cs)，这个类中要存的数据方法有：
1.每个移动方块都有三个值FGH,其中G (代表起点到当前点的距离)、H（当前点到终点的距离）F＝G＋H。
2.并且每个移动方块都会存储自己上一个块（Parent）
2.首先 创建一个开放列表（OpenList：存放已经找到并计算好FGH值的周围块）和一个关闭列表（closeList：不可移动的块，如起点、障碍物和已经走过的块）
3.将起点放入开放列表（openList）中，只要开放列表（openList）中存在可移动的点就执行While循环while（openList.Count&gt;0）。其中while循环中要执行的方法如下：
3.1 我们先在开放列表（openList）中找到最小F值的块为当前块。
3.2将找到的最小F值的块放入到关闭列表（closeList）中。
3.3 找寻当前块周围的八个可移动块放入周围块列表（surroundPointsList）中
3.4 剔除周围块列表（surroundPointsList）中存在的 如：起点，障碍物，走过的块等不可移动的块，这样周围块列表（surroundPointsList）中就只剩下可以走的块了
3.5然后我们遍历这些可移动的周围块，每个周围块执行两个判断：
（1）当这个周围块不存在开放列表中时，计算这个块的FGH值，并且将父节点赋值成当前节点
（2）当这个周围块存在开放列表中时，我们计算新的G值（计算方式：当前点的G值+当前点到这个周围块的节点所消耗的G值）是否小于周围块的原G值，如果小于就要更新这个周围块的GF值（为什么不更新H值呢？因为H值是块到终点的距离是不会变的。所以不用修改），并且修改这个周围块的父节点为当前节点。
3.6 最后判断一下开放列表（openList）中是否存在终点这个块，如果存在就跳出While循环
4.就这样我们根据终点块的父节点，一级一级的往后倒推就找到了我们想要的最短路径。
三、案例演示： 看案例图之前先了解一下每个颜色块的作用吧
（1）浅蓝色代表在开放列表中的块（存放已经找到并计算好FGH值的周围块）
右上角为F，左下角为G，右下角为H
（2）橙色代表找到的最小F值块
（3）箭头的指向表示块的上一级父节点
（4） 蓝色表示关闭列表（closeList）中的点（其中绿色起点和红色终点也都在关闭列表中，为了区别就没有标成蓝色）
好的接下来我们就开始根据上面的思路对照来看图了解：
1.开放列表中只有一个起点，将起点放入到关闭列表中并获取起点周围的8个周围块（上下左右，左上 左下 右上 右下），由于一开始这8个周围块都不在关闭列表）中，所以计算他们的FGH值并对父节点赋值，然后放入到开放列表中。如下图
2.再次执行循环，先找到开放列表中的最小F值块（当前橙色块），找寻当前块周围的8个点，剔除不可移动的周围块，遍历剩下的可移动周围块点进行判断，根据上图我们可以找到橙色块，根据橙色当前块来找周围可移动的块共有四个，并且这四个块都在开放列表中了（都有自己的FGH值和父节点了），所以我们要进行一个计算，从当前块（橙色）到这个周围块所花费的G值加橙色块的原G值是否小于周围块原来G值，小于就代表从当前块（橙色）这条路比你上一次走的路要近，就要重新计算这个周围块的FG值，并且修改这个周围块的父节点。这里呢这四个周围块原路径都比走当前块（橙色）近，所以不做修改，执行下一次循环
3.上一步橙色点不是已经走过了嘛，所以这里我就把走过的橙色块改成蓝色代表已经走过的块不能再走了，这一步还是和上一次一样从开放列表中找到最小F值点，这时候你会发现有两个最小值F为4.576492的块这时候怎么选呢？其实我们一开搜寻周围块的时候是有顺序的（上下左右，左上 左下 右上 右下），我们按照这个顺序将块存入到列表，所以当遇到多个最小F值的块相谁最先在列表中就选择那个块为当前块，所以这里程序选的是以起点为中心的右上角的块为当前块（橙色块）。然后就是遍历周围块（注意这里我设置了周围有墙不可以贴墙斜着走方法），没有在开放列表中的就计算FGH值，设置父节点，放到开放列表中即可，在开放列表中时，计算新路径G值与原路径G值谁大谁小，小就修改FG值，并替换父节点，否则就啥也不用动。
4.好的接下来继续找最小点，对周围点进行逻辑判断
5.继续
6.继续
7.继续
8.继续
9.继续
10. 下一步 11.下一步
12.下一步
13.下一步
14.下一步
15.下一步
16.下一步
17.下一步
18.最后一步，可以看到周围块包含了结束点，这证明我们已经找到了最优路线
19.最后找到的路线 程序运行效果：
四、代码实现 1.地图块脚本
using System.Collections; using System.Collections.Generic; using UnityEngine.UI; using UnityEngine; /// &lt;summary&gt; /// 地图块 /// &lt;/summary&gt; public class PointTest : MonoBehaviour { public Text ftxt; public Text gtxt; public Text htxt; //当A*计算出最近路径点时，用于记录上一节点 public PointTest Parent { get; set; } public float F { get; set; }//总消耗 F=G+H public float G { get; set; }//表示从起点移动到网格上指定方格的移动耗费 (可沿斜方向移动) public float H { get; set; }//当前点到终点的消耗 //位置下标（具体位置要根据图片宽度进行计算） public Vector2 PosIndex { get; set; } //是否是障碍物 public bool IsWall { get; set; } RectTransform m_rect;//记录自身Rect组件 public void InitData(Vector2 origin, Vector2 space, Vector2 posIndex) { Parent = null; //创建地图 上一路径默认为空 PosIndex = posIndex; //位置下标 //当前rect为空 赋值 if (m_rect == null) { m_rect = GetComponent&lt;RectTransform&gt;(); ftxt = m_rect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf9a545c6dd0be570b0e3120a542ad9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82cf73528fedd698df72f6f918abbd74/" rel="bookmark">
			brpc组件bvar源码解析（二）AgentGroup和AgentCombiner
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇：brpc组件bvar源码解析（一）简介、使用和类的关系
1.AgentGroup AgentGroup中通过tls数据实际保存了bvar在每个线程中的统计值。
AgentGroup类的定义：
模板参数Agent实际传入的是AgentCombiner::Agent这个结构体；对于Agent相同的bvar，例如两个bvar::Adder&lt; int &gt;，在AgentGroup中实际的存储空间是同一块buffer，通过AgentId定位（类似一个数组的不同下标）。
成员变量都是static的，因为对于一种Agent，这些成员在全局只需要一份定义：
其中ThreadBlock是AgentGroup的嵌套类：
_s_agent_kinds：标记下一个可用的AgentId是多少；每次分配了新的AgentId后+1
_s_free_ids：bvar在析构时会归还AgentId，归还的AgentId都会放在_s_free_ids中由于重复使用
_s_tls_blocks：是ThreadBlock*的动态一维数组；而ThreadBlock内部是Agent的静态一维数组_agent，数组_agent长度约为4096/sizeof(Agent)（记为L）。_s_tls_blocks一次申请L个agent的buffer，并且因为是动态数组，可以动态扩展
_s_mutex：是保护_s_agent_kinds和_s_free_ids的锁；
函数create_new_agent： 这是新建一个agent时调用的，目的是获取一个AgentId（实际是int）。一个agent在所有tls的buffer数组中的位置是相同的。这个AgentId就标识了这个位置。它是AgentCombiner的构造函数调用的。AgentCombiner有了这个id，就能把一个bvar在各个tls中的数据定位到，进而“累加”起来。
函数destroy_agent 同理bvar析构时将调用此函数，用于回收AgentId、并暂存到_s_free_ids中。略。
函数get_tls_agent： 目的是根据AgentId从当前线程的tls数据中获取Agent存储位置的指针。具体是根据AgentId计算出在_s_tls_blocks的下标block_id（因为_s_tls_blocks每个元素指向的ThreadBlock的大小是固定的，即ELEMENTS_PER_BLOCK），然后再计算出在第A个ThreadBlock中的下标B，即得到Agent地址。其实把整个_s_tls_blocks的存储看成一维数组就很好理解了。
这里有个前提条件就是_s_tls_blocks不是空指针，_s_tls_blocks是一个tls数据，如果它为空，get_tls_agent将会返回NULL，此时调用地方将会调用get_or_create_tls_agent函数。
函数get_or_create_tls_agent 每个线程第一次调用时都会为_s_tls_blocks new出新的空间，并resize足够大；同样根据AgentId计算出block_id，为第block_id个block申请空间；再计算出在block_id个block的下标B，返回B的地址；
2.AgentCombiner AgentCombiner类的定义：
三个模板参数：
ResultTp：已经处理好的结果的类型
ElementTp：待处理的元素的类型。
BinaryOp：在聚合所有tls数据时的op操作，例如Adder的op是AddTo（相加），Maxer的op是MaxTo（取最大值），Miner的op是MinTo（取最小值）
ResultTp和ElementTp可能是同一个类型（例如都是int），也可能不同（例如是Stat，是uint64_t，op是AddToStat、负责将uint64_t值加到Stat变量中）。
嵌套类Agent： Agent中最重要的就是保存了ElementTp类型的值，即一个bvar的元素类型的值。ElementContainer的封装主要是为了线程安全的操作ElementTp值，对于整型和浮点型，其实就是atomic，其他类型就是读写操作加了Lock。
一个bvar在每个线程tls中实际存储的就是Agent类型。Agent其次保存了AgentCombiner（上面的self_type是AgentCombiner的别名）指针，因为上面介绍AgentGroup时我们知道底层存储是多个Agent一维数组，所以每个Agent需要知道它所属于哪个AgentCombiner。
同时，由于Agent继承自LinkNode，它就有了父类中的指向前一个节点的指针previous_和指向后一个节点的指针next_，成为了双向链表的节点类型。下面介绍_agents时会讲到作用。
成员变量： _id：此bvar的AgentId，用于在AgentGroup中查询当前线程tls数据中的Agent地址。
_op：BinaryOp类的对象，上面讲过这个op的作用了。
_global_result：ResultTp类型，保存汇总结果
_result_identity:ResultTp类型的初始值，用于快速reset ResultTp类型变量
element_identity: ElementTp类型的初始值，用于快速reset ElementTp类型变量
agents:存放所有Agent的双向链表。怎么存放的：每个Agent有前向指针previous_和后向指针next，所以把所有的Agent的previous_和next_赋值、串联起来就构成了一个双向链表，我们只要保存这个链表的头，就能依次遍历获得全部的Agent。注意这里并没有改变底层存储Agent的地址，他们实际还是存在AgentGroup中的（多个）一维数组中，只不过通过Agent的previous、next_串联了起来。
_agents的实现方式是一个很好的借鉴的地方。一方面为了减少内存碎片、提高cpu cache命中率和便于回收再利用，底层存储用多个一维数组连续存储，另一方面其中的一些数据因为某些原因需要组成隐式的“一组”，那么就可以使用双向链表的方式组织在一起。
构造函数 构造函数中申请一个AgentId。
析构函数 析构函数中调用了clear_all_agents，并且让AgentGroup回收了AgentId。clear_all_agents的代码：
clear_all_agents加锁做如下事情：遍历_agents中的每个节点（实际是Agent类型），调用Agent的reset函数（element重置为默认值，combiner重置为NULL），并将该node从双向链表_agents中删除。执行结束后_agents包含0个agent。
函数get_or_create_tls_agent 一个bvar需要写数据时一定会调用这个函数。它是通过_id快速找到当前线程tls数据中的Agent的地址。AgentGroup::get_tls_agent和AgentGroup::get_or_create_tls_agent之前已经介绍过了，不再赘述。这个过程完全没有锁的，因为操作的都是tls数据。这个是即使再频繁的写bvar数据、性能也非常好的核心所在，因为写时是完全没有数据竞争的。当然了，读的时候会有锁。
306~311行是什么作用？后文会讲解，这里先留意一下。
函数combine_agents 需要读一个bvar数据时一定会调用这个函数。它的目的是AgentCombiner类的核心作用，即把bvar在所有线程tls中存储的Agent的值“累加”起来。
此函数是线程安全的，即可以在任何线程被同时调用。
当前bvar所有tls的Agent可以通过双向链表_agents查询到。初始化ret为_global_result的值，遍历_agents中的每个节点，将该节点的Agent的实际值临时保存在tls_value，然后通过_op将tls_value“累加”到ret。最后返回ret。
函数reset_all_agents 此函数是线程安全的，即可以在任何线程被同时调用。
_agents中的每个节点的值进行“累加”，并和_global_result“累加”，保存到tmp最后返回；并且每个节点的值重置为_element_identity（ElementTp类型默认值）；
函数commit_and_erase commit_and_erase只会被Agent的析构函数调用。获得准备析构的agent的值并“累加”到_global_result，然后从_agent中删除这个agent。
agent什么时候析构进而调用这个commit_and_erase函数？我理解是AgentGroup中的_s_tls_blocks空间不足需要resize的时候可能会因为realloc导致agent复制到新的对象、原对象析构，但因为双向链表_agent中的previous_和next_都是指向agent地址，所以一旦agent地址发生改变，那么_agent就指向了错误的地址，所以需要析构的agent调用commit_and_erase以保证程序正确。所以这里考虑的很细，不这么做的话程序就可能会coredump了。
同时也知道了_global_result的作用，就是把需要迁移的agent的值都保持到_global_result中。
但是就有一个问题，_s_tls_blocks realloc虽然把当前的agent从_agent删除了，但是它原来的值会拷贝到新的对象（我们暂时称为new agent）啊，也就是说new agent的值并不是从初始化值开始的，一旦再次写入，老的值和已经“累加”到_global_result的值——岂不是算了两次。解决方法就是get_or_create_tls_agent函数306~311行，再看下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82cf73528fedd698df72f6f918abbd74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f77b859d6c565b1aa9ada1d09047c6bb/" rel="bookmark">
			Games104笔记---LE1--现代游戏引擎导论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前记：
基础理论：
现代游戏引擎
当代一些专业的引擎(中间件)
什么是游戏引擎：
游戏里面复杂的系统
开发者平台
书籍推荐
课程内容：
游戏引擎的基础内容
MVVM：
渲染系统
动画系统
物理系统
GamePlay系统
特效系统
工具链
网络通信
Motion_Matching, PCG
Dop, Job System
Lumen, Nanite
作业框架：
本课程的作业体系
共创人员
学习资料：
笔记导航： LE7--渲染系统4：渲染管线，后处理：https://blog.csdn.net/m0_56399931/article/details/124790469
LE6--渲染系统3：游戏中的地形/天空/云渲染：LE6--渲染系统3：yo地形/天空/云渲染_This is MX的博客-CSDN博客
LE5--渲染系统2：光照、材质、Shadow：Games104笔记---LE5--渲染系统2：光照、材质、Shadow_This is MX的博客-CSDN博客
LE4--渲染系统1：渲染基础：Games104笔记---LE4--渲染系统1：渲染基础_This is MX的博客-CSDN博客_渲染系统
LE3--基础架构2：数据组织与管理：Games104笔记---LE3--基础架构2：数据组织与管理_This is MX的博客-CSDN博客
LE2--基础架构1：引擎架构分层整体Pipeline：Games104笔记---LE2--基础架构1：引擎架构分层整体Pipeline_This is MX的博客-CSDN博客
LE1--现代游戏引擎导论：Games104笔记---LE1--现代游戏引擎导论_This is MX的博客-CSDN博客
前记： 这个系列算是新开的坑吧，和网友们一同追完Games104这么课，做完作业，每次上完课三天内发出笔记
我写的作业会发到Github的仓库上：https://github.com/1393650770/Games104-Homework
基础理论： 现代游戏引擎 当代一些专业的引擎(中间件) （物理、动画、渲染、等其他中间件）
什么是游戏引擎： •矩阵的技术基础•创造的生产力工具•复杂性的艺术
游戏里面复杂的系统 游戏里面的模拟，复杂的系统
开发者平台 现代的游戏引擎需要有可扩展的API接口，允许程序员在不改变核心的情况下定义各种玩法。并且可以为数百名不同学科的开发人员顺利地一起工作。
书籍推荐 书籍推荐
课程内容： 游戏引擎的基础内容 游戏引擎的基础内容
看游戏引擎的时候可以从update（tick）函数入手
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f77b859d6c565b1aa9ada1d09047c6bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c750c36b940b13d09b19084ba0acc24/" rel="bookmark">
			Games104笔记---LE2--基础架构1：引擎架构分层整体Pipeline
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
游戏引擎分层：
游戏引擎自身【五层架构】：
为什么要分层呢？
工具层：
核心功能：
功能层：
功能层的功能：
这里笔记作者举例Unity的循环：
资源层：
资源转换成资产：
这里笔记作者举例Unity的资产导入：
Unity导入资源工作流
核心层：
核心功能：
这里笔记作者举例UE核心层的循环：
平台层：
核心功能：
Mini Engine -Pilot
学习资料：
笔记导航： LE7--渲染系统4：渲染管线，后处理：https://blog.csdn.net/m0_56399931/article/details/124790469
LE6--渲染系统3：游戏中的地形/天空/云渲染：LE6--渲染系统3：yo地形/天空/云渲染_This is MX的博客-CSDN博客
LE5--渲染系统2：光照、材质、Shadow：Games104笔记---LE5--渲染系统2：光照、材质、Shadow_This is MX的博客-CSDN博客
LE4--渲染系统1：渲染基础：Games104笔记---LE4--渲染系统1：渲染基础_This is MX的博客-CSDN博客_渲染系统
LE3--基础架构2：数据组织与管理：Games104笔记---LE3--基础架构2：数据组织与管理_This is MX的博客-CSDN博客
LE2--基础架构1：引擎架构分层整体Pipeline：Games104笔记---LE2--基础架构1：引擎架构分层整体Pipeline_This is MX的博客-CSDN博客
LE1--现代游戏引擎导论：Games104笔记---LE1--现代游戏引擎导论_This is MX的博客-CSDN博客
游戏引擎分层： 游戏引擎自身【五层架构】： 工具层--功能层--资源层--核心层--平台层
还有第三方库
为什么要分层呢？ 这个其实很好想，主要还是解耦，降低复杂性，让下层独立于上层，便于管理。并且层次之间的调用一般只允许上层调用下层的接口，不允许下层调用上层的接口
工具层： 核心功能： 是更好地让开发者开发游戏，提高生成效率。比如地形编辑器，UI编辑器，Shader编辑器。
这一层还有一个重要的功能就是DCC，让其他软件的资产无损导入我们的引擎，需要做资产导出器，资产导入器
功能层： 功能层的功能： 核心功能是让世界动起来，入手点是tick点（ue：tick ，unity：update）
现代游戏引擎还需要考虑多线程，但是会有依赖关系，所以这种引擎架构其实并不好做，但是肯定是未来趋势
这里笔记作者举例Unity的循环： 资源层： 核心功能是管理资产的生命周期。
资源转换成资产： 通过定义一个元资源文件格式(例如。ast)来统一文件访问。通
过导入预处理来更快地访问资产。
构建一个复合资产文件来引用所有资源。
guid是一个额外的引用保护。
这里笔记作者举例Unity的资产导入： Unity导入资源工作流 1.Unity 为资源分配唯一 ID。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c750c36b940b13d09b19084ba0acc24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43163042075e64e9e6c14c4f6edd5fc4/" rel="bookmark">
			Games104笔记---LE3--基础架构2：数据组织与管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
怎样构建游戏世界：
抽象现实中的物体：
组件化：
组件的更新：
事件系统：
场景管理：
感谢大佬
问题：
一个模块Tick事件太长？
Tick的时候渲染线程和逻辑线程怎么同步？
空间已经划分了，动态物体怎么处理？
组件模式有什么缺点？
事件机制怎么进行调试？
物理和动画互相影响要怎么处理？
学习资料：
笔记导航： LE7--渲染系统4：渲染管线，后处理：https://blog.csdn.net/m0_56399931/article/details/124790469
LE6--渲染系统3：游戏中的地形/天空/云渲染：LE6--渲染系统3：yo地形/天空/云渲染_This is MX的博客-CSDN博客
LE5--渲染系统2：光照、材质、Shadow：Games104笔记---LE5--渲染系统2：光照、材质、Shadow_This is MX的博客-CSDN博客
LE4--渲染系统1：渲染基础：Games104笔记---LE4--渲染系统1：渲染基础_This is MX的博客-CSDN博客_渲染系统
LE3--基础架构2：数据组织与管理：Games104笔记---LE3--基础架构2：数据组织与管理_This is MX的博客-CSDN博客
LE2--基础架构1：引擎架构分层整体Pipeline：Games104笔记---LE2--基础架构1：引擎架构分层整体Pipeline_This is MX的博客-CSDN博客
LE1--现代游戏引擎导论：Games104笔记---LE1--现代游戏引擎导论_This is MX的博客-CSDN博客
怎样构建游戏世界： 抽象现实中的物体： 抽象出属性和行为
继承出新的物体
组件化： 组件化这个事情，编程届有一句话“组件优于继承”。Unity和Ue也都是有组件的
组件优于继承，这是为什么呢？一方面其实是很多继承来的功能对于特定对象来说其实可能是不需要的，如果我们把它加载进来其实也是会消耗性能的，另一方面组件化有着更高的复用性，但是这也就意味着更高的颗粒度。
Unity和UE中的组件化：
组件的更新： 事件系统： 为什么需要事件系统呢，因为如果做游戏逻辑的时候直接硬编码每个物体查询一次，消耗太高，并且耦合太高了，所以产生了事件。
一个好的游戏引擎需要有一个可拓展的事件系统，允许程序员自己注册自己类型的事件，并进行通知。
事件的实现可以参考这个：ouzel/EventDispatcher.cpp at master · elnormous/ouzel · GitHub
场景管理： 我们必须把复杂度降低到下o^2以下，我们可以对其进行空间划分，使用八叉树、BVH、BSP等结构进行管理。这个管理可以看一下光追的BVH生成，后续我也会写一下。
感谢大佬 问题： 一个模块Tick事件太长？ 解决方法：优化引擎的处理，比如说一帧处理全部的炸弹碎片，那可以把炸弹碎片多帧里面处理
Tick的时候渲染线程和逻辑线程怎么同步？ 一般会有多个线程来做渲染的数据准备，逻辑线程一般会比渲染线程早一些。
空间已经划分了，动态物体怎么处理？ 一般是不同场景采用不同的空间划分方法，一般实现的时候要实现多种空间划分方法，让引擎择优选择。
组件模式有什么缺点？ 在切换组件的时候成本很高；组件之间也要有通信接口机制，并且有可能是要不断的query，这个高频调用里消耗也是很大的。
事件机制怎么进行调试？ 其实最有效的还说打log，引擎开发者也可以开发出可视化的事件通知debug模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43163042075e64e9e6c14c4f6edd5fc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b8bc2e40446ad8412f4b1615cfe581e/" rel="bookmark">
			Games104笔记---LE6--渲染系统3：游戏中的地形/天空/云渲染
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
地形几何
高度图：
自适应网格细分
几个原则：
网格细分的方法：
实时变形的地形：
体素化：
Marching Cubes算法：
地形着色：
存储内容：
地形纹理采样:
正确的过渡算法：
凹凸/视差/置换贴图：
Virtual Texture:
地形渲染问题：
浮点数精度问题：
解决方法：
地形植被：
天空渲染：
简单的天空模型：
更加合适的模型：
光传输方程：
体积渲染方程：
散射的类型：
实时大气渲染实现：
RayMarching实现：
预计算：
如何快速计算大气散射：
云的渲染：
老的方法：
新的方法：
体积云：
体积云的实现：
Pilot v0.0.2:
笔记导航： LE7--渲染系统4：渲染管线，后处理：https://blog.csdn.net/m0_56399931/article/details/124790469
LE6--渲染系统3：游戏中的地形/天空/云渲染：LE6--渲染系统3：yo地形/天空/云渲染_This is MX的博客-CSDN博客
LE5--渲染系统2：光照、材质、Shadow：Games104笔记---LE5--渲染系统2：光照、材质、Shadow_This is MX的博客-CSDN博客
LE4--渲染系统1：渲染基础：Games104笔记---LE4--渲染系统1：渲染基础_This is MX的博客-CSDN博客_渲染系统
LE3--基础架构2：数据组织与管理：Games104笔记---LE3--基础架构2：数据组织与管理_This is MX的博客-CSDN博客
LE2--基础架构1：引擎架构分层整体Pipeline：Games104笔记---LE2--基础架构1：引擎架构分层整体Pipeline_This is MX的博客-CSDN博客
LE1--现代游戏引擎导论：Games104笔记---LE1--现代游戏引擎导论_This is MX的博客-CSDN博客
地形几何 高度图： 每个网格/顶点应用高度、材质等信息，我们每个顶点可以根据高度改变位移。
但是这种方法是不适用于开放世界的。很难直接画出几百万公里的场景
自适应网格细分 当fov越来越窄的时候，网格越来越细
那为什么是fov呢，如果写过摄像机系统的话，其实有一个方法实现缩放，就是变更fov，如果fov越小离物体就越近，所以这种时候网格就需要越精细。
几个原则： · 距离摄像机和视场
· 与地面真实值相比的误差(预计算)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b8bc2e40446ad8412f4b1615cfe581e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54989d6a11751984b97433cc7bf9addb/" rel="bookmark">
			python习题#讲解14日志讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.借助日志模板文件，初始化日志配置，
要求：2天生成一个新日志文件，保留日志文件个数3。测试日志使用，
打印日志信息内容： “这是晚自习作业题的日志信息”，
保存到 log_homework.log 文件中。
打印 5条以上日志。
截图打印结果。
import logging import logging.handlers#导入日志参数 from config import D#导入路径 #when='D'：D是days天缩写#2是指2个 when#3是指⽇志⽂件的个数 def init_log_config(filename, when='D', interval=2, backup_count=3): """ 功能：初始化日志配置函数 :param filename: 日志文件名 :param when: 设定日志切分的间隔时间单位 :param interval: 间隔时间单位的个数，指等待多少个 when 后继续进行日志记录 :param backup_count: 保留日志文件的个数 :return: """ # 1. 创建日志器对象 logger = logging.getLogger() # 2. 设置日志打印级别 logger.setLevel(logging.DEBUG) # logger.setLevel(logging.INFO) # logger.setLevel(logging.WARNING) # logger.setLevel(logging.ERROR) # logger.setLevel(logging.CRITICAL ) # logging.DEBUG 调试级别 # logging.INFO 信息级别 # logging.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54989d6a11751984b97433cc7bf9addb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bec6d84bd3c2b7c4fe2c9149f1481b52/" rel="bookmark">
			Unity中如何使用Rider调试C#和lua代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作中经常需要调试lua代码，之前使用VS调试C#代码，使用Intellij Idea来调试lua代码，这样其实比较麻烦，所以查了一下，可以直接使用Rider来统一的调试C#和lua代码
Rider安装： Rider下载：Rider官网下载，根据需要选择对应的版本，建议使用Rider2020.1.0，参考链接
使用Rider调试C#代码： 打开Unity，在preference中设置为Rider，当双击C#文件时则会自动使用Rider打开：
​
在Rider菜单栏中选择“Attach to Unity Editor”：
​
注意：
1.一般选择“Attach to Unity Editor”，不要选择“Attach to Unity Editor &amp; Play”。后者在点击调试图标后会自动启动Unity —— 有些情况为了方便调试并不需要自动启动Unity。两者区别仅仅在于是否调试时自动启动Unity，可以根据具体情况而定
2.在断点C#代码时需要先启动Rider中的调试，然后运行Unity。
使用Rider断点C#代码很简单，因为在安装Rider后可以将Unity和Rider关联起来，代码调试很简单
使用Rider调试Lua代码： 1.安装EmmyLua插件用于lua调试： 在Rider菜单栏“File -&gt; Settings”：
​
2.配置LuaDebugger： 点击“Edit Configuration”: ​
点击左上角“+”添加LuaDebugger：
​
设置LuaDebugger的Name以及Connection方式：
​
3.LuaDebugger有两种Conection方式 方式一：Rider充当服务器 —— Tcp (Debugger connect IDE) Rider先启动调试模式，等待Unity启动后连接
1.根据LuaDebugger中的设置，需要将“dbg.tcpConnect”粘贴入lua代码中：
​
2.找到C#调用Lua代码最初始的文件，如“GameMain.lua”等，在代码顶部添加：
​
或者也可以将以上拷贝的“dbg.tcpConnect”等代码放进独立的lua脚本"EmmyLuaDebgger.lua"中，然后在“GameMain.lua”中“Require EmmyLuaDebugger”也可以：
如新建“EmmyLuaDebugger.lua”脚本：
-- TCP (Debugger connect IDE) package.cpath = package.cpath .. ';C:/Users/Frank/AppData/Roaming/JetBrains/Rider2021.3/plugins/EmmyLua/debugger/emmy/windows/x64/?.dll' local dbg = require('emmy_core') dbg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bec6d84bd3c2b7c4fe2c9149f1481b52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28c9066ed928460ad0d47dd3d4c0f074/" rel="bookmark">
			vue--vuex介绍与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue介绍 Vuex 是什么？ Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式，单一状态树,通俗理解就是一个应用的数据集合，可以想象为一个“前端数据库”（数据仓库），让其在各个页面上实现数据的共享包括状态，并且可操作。详情官方解释。
Vuex的组成 Vuex分成五个部分：
State：单一状态树Getters：状态获取Mutations：触发同步事件Actions：提交mutation，可以包含异步操作Module：将vuex进行分模块 前四个特征就是核心。
正如官网vuex图示，Vuex的数据总是“单向流动”
用户访问页面并触发actionaction提交mutation事件mutation事件更改state状态state状态改变后更新页面(vue comptents) Vuex 规定，属于应用层级的状态只能通过 Mutation 中的方法来修改，而派发 Mutation 中的事件只能通过 action。
用法 从左到右，从组件出发，组件中调用 action，在 action 这一层级我们可以和后台数据交互，比如获取初始化的数据源，或者中间数据的过滤等。然后在 action 中去派发 Mutation。Mutation 去触发状态的改变，状态的改变，将触发视图的更新。
注意事项 数据流都是单向的组件能够调用 actionaction 用来派发 Mutation只有 mutation 可以改变状态store 是响应式的，无论 state 什么时候更新，组件都将同步更新 方式 方式一：可以将state，getter，mutation，action写到一个store.js文件中可以参考
方式二：在src目录下我们创一个vuex文件夹，分别创建index.js,mutations.js,state.js,getters.js,actions.js可以参考
这里以方式二进行实例
为什么使用Vuex 在未使用Vuex之前，使用组件传值
组件传值 1.父子组件
父组件--&gt;子组件，通过子组件的自定义属性：props
子组件--&gt;父组件，通过自定义事件：this.$emit('事件名',参数1,参数2,...);
2.非父子组件或父子组件
通过数据总数Bus，this.$root.$emit('事件名',参数1,参数2,...)
3.非父子组件或父子组件
更好的方式是在vue中使用vuex
方法1:
用组件之间通讯。这样写很麻烦，并且写着写着，估计自己都不知道这是啥了，很容易写晕。
方法2:
我们定义全局变量。模块a的数据赋值给全局变量x。然后模块b获取x。这样我们就很容易获取到数据
使用 第一步：npm i vuex --save/-S第二步： 创建store.js import vuex from 'vuex' import vue from 'vue'第三步：Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28c9066ed928460ad0d47dd3d4c0f074/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74baba74d4381f2c10e25d2ef6a5e09b/" rel="bookmark">
			ElementUI中Table-column的formatter属性的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、官方文档对formatter属性的介绍 二、formatter属性的作用 主要用来对页面中的数据进行二次渲染。
三、使用方法 &lt;el-table :data="tableData" border :row-class-name="tableRowClassName" height="250"&gt; &lt;el-table-column prop="id" label="编号" width="200" :resizable="false" align="center"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop="age" label="年龄" sortable :sort-method="sortMtd"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop="email" label="邮箱"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop="dept.name" label="部门" :formatter="showDept"&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;script&gt; export default { name: "Table", data(){ return { tableData: [ {id:1101,name:'小张',age:22,email: '287934111@qq.com',dept: {id:11,name: '研发部'}}, {id:1102,name:'小王',age:25,email: '287934222@qq.com',dept:{}}, ] } }, methods: { showDept(row, column, cellValue, index){ console.log(row); console.log(column); console.log(cellValue); console.log(index); if (cellValue){ return cellValue; } return "暂无部门"; } }, } &lt;/script&gt; 注意：在showDept方法中必须设置返回值，否则无效！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/595b90a402829f1fd38a474a18b7ad6e/" rel="bookmark">
			UFS 手机相关调试接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 前言
我们拿到一款手机，怎么去知道手机UFS相关的信息呢，接下来我们一起来看下吧！
二 . UFS相关信息
预置环境：最好有root权限的手机版本，可以连接adb
1. 查看UFS分区
sgdisk --print /dev/block/sdx(块设备节点，对应UFS的一个Lun)
:/# sgdisk --print /dev/block/sda Disk /dev/block/sda: 124655616 sectors, 475.5GIB Sector size(logical/physical): 4096/4096 bytes Disk identifier(GUID): 562F2C51-9999-0000-7777-1111-2345678901234 Partition table holds up to 64 entries Main partition table begins at sector 2 and ends at sector 3 First usable sector is 6, last usable sector is 124655610 Partition will be alihned on 2-sector boundaries Total free space space is 0 sectors(0 bytes) Number Start(sector) End(sector) Size Code Name 1 6 7 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/595b90a402829f1fd38a474a18b7ad6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6362232d710c1f8641bf1f34b7cefdb7/" rel="bookmark">
			ElementUi中table组件使用row-class-name无效的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题再现 table组件使用row-class-name属性无效!
&lt;template&gt; &lt;div&gt; &lt;h3&gt;Table表格组件的使用&lt;/h3&gt; &lt;el-table :data="tableData" stripe border :row-class-name="tableRowClassName"&gt; &lt;el-table-column prop="id" label="编号" width="200"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop="age" label="年龄"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop="email" label="邮箱"&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: "Table", data(){ return { tableData: [ {id:1101,name:'小张',age:22,email: '287934111@qq.com'}, {id:1102,name:'小王',age:25,email: '287934222@qq.com'} ] } }, methods: { tableRowClassName({row, rowIndex}) { /*console.log('row的值：'+ row); console.log('rowIndex的值：' + rowIndex);*/ if (rowIndex === 0) { return 'warning-row'; } else if (rowIndex === 1) { return 'success-row'; } return ''; } }, } &lt;/script&gt; &lt;style scoped&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6362232d710c1f8641bf1f34b7cefdb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6879441ff876b4ae6c9c55871accbdf/" rel="bookmark">
			写mfc的几个error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.error C2664: “CFileDialog::CFileDialog(BOOL,LPCTSTR,LPCTSTR,DWORD,LPCTSTR,CWnd *,DWORD,BOOL)”: 不能将参数 2 从“const char [4]”转换为“LPCTSTR”
1&gt; 与指向的类型无关；转换要求 reinterpret_cast、C 样式转换或函数样式转换
解决：项目----属性----常规----字符集----使用多字节字符集
2.error C4996: ‘strcpy’: This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
1&gt; c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h(110) : 参见“strcpy”的声明
1&gt; BB_PLOT.cpp
解决：项目----属性----c/c+±—预处理器----添加_CRT_SECURE_NO_WARNINGS
3.private:
static DWORD CALLBACK ThreadProc(LPVOID param);
调用时m_hThread = CreateThread(NULL,0,ThreadProc,this,0,NULL);
静态成员函数的地址可用普通函数指针储存，而普通成员函数地址需要用类成员函数指针来储存，因为普通成员函数要执行时我们必须要确定他是属于哪个类对象才能执行，而类的static函数是不属于这个类的，他是在编译器编译时期就已经确定的，普通成员函数是在有了类对象之后才能执行。
CALLBACK
#define CALLBACK __stdcall
不写时是__cdecl
区别：https://blog.csdn.net/W_Y2010/article/details/95480357
4.ReverseFind（‘\‘）函数
此函数表示从右开始寻找第一个“\”的，并返回从左开始数的索引地址。
与之相对的是Find（‘’）函数，表示从左开始寻找第一个’\'，并返回从左开始数的索引地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6879441ff876b4ae6c9c55871accbdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b7f6e26c6da8b54753b85500978b21c/" rel="bookmark">
			GO 错误处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误处理 defer+recover机制处理错误自定义错误 defer+recover机制处理错误 (1)我们来写一个错误
package main import "fmt" func main() { test() fmt.Println("上面的除法操作执行成功...") fmt.Println("正常执行下面的逻辑...") } func test() { num1 := 10 num2 := 0 result := num1 / num2 //第13行 fmt.Println(result) } 我们来运行一下,结果如图：
意思是（死机:运行时错误:整数被零除）
发现：程序中出现错误/恐慌以后，程序被中断，无法继续执行。
(2)错误处理/捕获机制
GO中追求代码优雅，引入机制：defer+recover机制处理错误 。
内置函数recover:
func recover() interface{}
内建函数recover允许程序管理恐慌过程中的GO程。在defer的函数中，执行recover调用会取回传至panic调用的错误值，恢复正常执行，停止恐慌过程。若recover在defer的函数之外被调用，它将不会停止恐慌过程序列。在此情况下，或当该Go程不在恐慌过程中时，或提供给panic的实参为nil时，recover就会返回nil。
package main import "fmt" func main() { test() fmt.Println("上面的除法操作执行成功...") fmt.Println("正常执行下面的逻辑...") } func test() { //利用defer+recover来捕获错误：defer后加上匿名函数的调用 defer func() { //调用recover内置函数，可以捕获错误： err := recover() //如果没有捕获错误，返回值为零值：nil if err != nil { fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b7f6e26c6da8b54753b85500978b21c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd5cc173e1a90cadef04711899ed477e/" rel="bookmark">
			汉诺塔问题的求解与分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、递归算法介绍 这篇文章讲的是一个古老而又经典的汉诺塔问题，他是递归算法的一个很好的应用实例。有关递归函数的介绍，在使用递归函数求解字符串的逆置问题文章中介绍过。递归思想是来解决可计算问题的，他的根本特征在于逐步的计算和分解这一计算，通过将某一大问题不断的分解成逻辑上相同的小问题，然后对小问题的求解进而获得最终的答案。使用递归算法的程序在形式上往往都比较简洁明了，这也正是他的价值所在。（更好地阅读体验，请访问程序员在旅途）
计算机使用栈内存结构来从物理上实现递归算法，每一次的递归调用，系统都要将本次调用的返回地址、局部变量、形式参数等值压入到栈中，调用结束之后，再从栈顶取出保存的信息返回给相应的变量并退出栈，再继续执行递归的上一层函数。由于计算机系统给每一个程序分配的栈空间有限，因此，在使用递归求解问题的时候，一定要注意递归的深度，如果递归的次数太多，很可能会出现栈溢出的情况，导致问题求解失败。
二、汉诺塔问题 2.1 问题由来 相传在古印度圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘。游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上.
2.2 问题分析 汉诺塔问题是一种多分支的递归解法，相对于单分支的递归解法（如：阶乘的递归解法）来说，不太容易理解，但是只要把握住递归的思想核心就能够理解这个程序的逻辑。汉诺塔解法总结起来有三步骤：
1） 把 N-1个盘子 移到中转柱
2）把第N个盘子移动到 目标柱
3）把中转柱上面的N-1个盘子借助目前空闲的柱子 移动到 目标柱。
注意，上面的中转柱，起始柱，是会变化的。每一层递归的逻辑都是，借助"目标柱子"，将n-1个 盘子移动到 “中转柱”，然后再将最后一个盘子移动到"目标柱子"，再将中转柱上的盘子按照同样的规律移动到"目标柱子"。
无论有多少盘子，在移动的过程中，都是遵循上面的三个步骤。在移动第N个盘子的时候，我们总得要想办法把前面N-1个盘子移到中转柱，然后才能将第N个盘子移到目标柱。在移动第N-1个盘子的时候，也是得要把前面N-2个盘子移到中转柱，然后才能把第N-1个盘子移到目标柱。所以，你可以看到，移动N、N-1、N-2···号盘子到目标柱的思路是一样的，因此，我们可以用递归的思想解决这个问题。
2.3 程序实现 #include&lt;stdio.h&gt; void hnt(int n, char a, char b, char c){ if(n == 1){ // 递归出界条件 printf("%c -- &gt; %c \n", a,c); }else{ /* 每一层递归的逻辑都是，借助"目标柱子"，将n-1个 盘子移动到 "中转柱"，然后再将最后一个盘子移动到"目标柱子". 注意，这里的中转柱是会变化的。 */ hnt(n-1,a,c,b); // ① 借助 c 柱子将a柱子上的n-1个盘子 移动到 b 柱子上 printf("%c -- &gt; %c \n", a,c); // ② 将 a柱子上的第n个盘子 移动到 c柱子上 hnt(n-1, b,a,c); // ③ 将在b柱子上的n-1个盘子，借助 a 柱子（此时a空闲） 移动到 c 柱子上 } } int main(){ int n; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd5cc173e1a90cadef04711899ed477e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/629ff4e03a4f9603cb71998040e144b7/" rel="bookmark">
			【比赛向】东京证卷交易所预测-赛题理解（Kaggle_2022_Structured Data）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【比赛向】东京证卷交易所预测-赛题理解（Kaggle_2022_Structured Data） 比赛地址：https://www.kaggle.com/competitions/jpx-tokyo-stock-exchange-prediction
东京证卷交易所预测 系列文章目录 【比赛向】东京证卷交易所预测-赛题理解（Kaggle_2022_Structured Data）1 赛题背景2 赛题数据2.1 Stock_list.csv2.2 train_files2.3 supplemental_files2.4 jpx_tokyo_market_prediction2.5 example_test_files2.6 data_specifications 3 baseline 1 赛题背景 金融市场的成功需要一个人去识别可靠的投资。当一只股票被低估时买入是有意义的；如果估值过高，又该卖出。虽然这些财务决策以往都是由专业人士手工做出，但科技为散户投资者带来了新机会。具体而言，数据科学家可能会对探索量化交易感兴趣，在这种交易中，决策是基于训练过的模型进行预测得到。目前有很多定量交易工具用于分析金融市场和制定投资策略。创建和执行这样的策略需要历史和实时数据，这对于散户来说很难获得。
该比赛将从日本真实股票市场中提供财务数据，让散户投资者能够最大限度分析市场。日本证券交易所集团（JPX）是一家控股公司，运营者世界上最大的证券交易所之一——东京证券交易所（TSE）。
本次比赛将在模型训练结束后，将模型和真实的未来回报进行比较。具体而言，每个参赛者将对约2,000只股票进行预期回报率从高到低排序，并根据前200支股票和后200支股票的回报率差进行评估。参赛者可以访问来自日本市场的财务数据，例如股票信息和历史股票价格。
简述：对确定日期和股票代码进行Rank预测，Rank表示2000只股票中每只股票的第二天收盘价和第二天收盘价的变化率的排名。
2 赛题数据 五大文件夹：
data_specification: 给出数据表的各列具体意义（仅给出各列的具体含义）example_test_files: 测试集的数据文件夹，用于预测提交，与train_files格式一致，只是缺少’Target’jpx_tokyo_market_prediction: 启动测试提交的API，需5分钟内提交所有行并少于0.5GB内存（我们不必考虑文件内容，与比赛数据无关）supplemental_files: 包含补充训练数据的动态窗口train_files: 训练集，主要文件夹包含了各类股票信息stock_list.csv: SecuritiesCode(即股票id)和公司名称之间的映射，以及有关公司所在行业的一般信息 2.1 Stock_list.csv 给出了4417只股票和对应公司的信息
具体而言，各列的意义为：
股票id、有效日期、公司名称、部门/产品、TSE市场重组后的类别、TOPIX-17分类标准下的股票行业种类代码、TOPIX-17的股票股票行业种类、TOPIX-17的种类代码、TOPIX-17的名称、TOPIX系列代码、TOPIX系列代码名称、计算市值的交易日期、交易日期下的收盘价、已发行的证券数、2021年12月3日的市值、需要预测的股票标记
个人觉得有意义的是：
EffectiveDate、Section/Products、NewMarketSegment、33SectorCode、17SectorCode、NewIndexSeriesSizeCode
2.2 train_files stock_prices.csv: 股票基本信息表
主要包含了各只股票的基本信息，如
Open：开盘价（当天首次交易价格）、Close：收盘价（最后一次成交价）、Volume：一天内股票交易量、AdjustmentFactor：理论价格/成交量、ExpectedDividend：除权日（ex-right date）的预期股息价值，该值是在除息日期前2个营业日记录的，共99.19%缺失，不考虑使用、
以及Target = [Close(t+2)-Close(t+1)] / Close(t+1)
而我们最终预测的Rank就是Target的逆排序，Target越大Rank排名越靠前
secondary_stock_prices.csv: 股票基本信息表，格式同stock_prices
stock_prices是核心数据集，包含了2000种最常交易的股票。但许多流动性较低的股票也在东京市场上交易，他们虽然没有评分，但可以帮住评估整个市场
options.csv: 基于大盘的期权状况数据。期权隐含了对股票市场未来价格的预测，即使期权没有打分，但可能很有价值
暂时不清楚这个options.csv该怎么结合到stock_prices里，没有理解清楚期权和股票的区别和关系。
financials.csv
financial.csv是针对4071只股票的季度收益报告的结果，其中可以通过DateCode列与stock_prices的RowId相对应使用。
trades.csv
trades.csv是上一个商业星期的总交易量。共1712条数据，缺失严重，约44.68%的行不能使用。
可以通过Date列与stock_price相关联。
2.3 supplemental_files 与train_files文件内容格式完全一致，将会在5月初、6月初的竞赛主阶段，以及提交文件锁定前大约一周，用新数据更新。
在最终模型训练过程中，需要将这里面的数据与train_files合并作为我们最终的训练集使用。
2.4 jpx_tokyo_market_prediction 测试提交API文件，与赛题内容无关
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/629ff4e03a4f9603cb71998040e144b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca2f2436be861317b13f76ef0861b5d9/" rel="bookmark">
			[游戏代码]求生之路插件:人物获得武器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;sourcemod&gt; #include &lt;sdktools&gt; #pragma semicolon 1 public Plugin:myinfo = { name = "[紫冰] 武器给予", author = "紫冰", description = "输入指令获得武器", version = "1.0", url = "https://blog.csdn.net/ZBzibing/article/details/124114073" }; public OnPluginStart() { RegConsoleCmd("sm_qiang",qiang, "指令!qiang"); } public Action:scout(client, Args) { //GivePlayerItem(client, "weapon_autoshotgun");	//在玩家位置产生一个自动霰弹枪 new wq = CreateEntityByName("weapon_autoshotgun"); //获得自动霰弹枪 DispatchSpawn(wq); EquipPlayerWeapon(client, wq); PrintToChatAll("武器已经获得"); return Plugin_Handled; } 武器代码:
weapon_autoshotgun
weapon_first_aid_kit
weapon_hunting_rifle
weapon_molotov
weapon_pain_pills
weapon_pipe_bomb
weapon_pistol
weapon_pumpshotgun
weapon_rifle
weapon_smg
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c31a48a74f8b53f79acc969d638db2b/" rel="bookmark">
			OKHttp五大拦截器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RetryAndFollowUpInterceptor重试重定向拦截器 重试拦截器在交出(交给下一个拦截器)之前，负责判断用户是否取消了请求；在获得了结果之后 会根据响应码判断是否需要重定向，如果满足条件那么就会重启执行所有拦截器。
重试 重定向(最大次数为20) 响应码说明重定向条件407代理需要授权，如付费代理，需要验证身份通过proxyAuthenticator获 得到了Request。 例: 添加 Proxy-Authorization 请求头401服务器需要授权，如某些接口需要登陆才能使用 (不安全，基本上没用了)通过authenticator获得到了Request。例: 添加 Authorization 请求头3XX重定向响应OkHttpClient配置允许重定向408请求超时。1、用户允许自动重试(默认允许) 2、本次请求的结果不是 响应408的重试结果 3、服务器未响应Retry-After(稍后重试),或者响应Retry-After: 0。503服务不可用1、本次请求的结果不是 响应503的重试结果 2.服务器明确响应 Retry-After: 0，立即重试421从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围自动再次使用另一个连接对象发起请求 BridgeInterceptor桥接拦截器 桥接拦截器在交出之前，负责将HTTP协议必备的请求头加入其中(如：Host)并添加一些默认的行为(如：GZIP压缩)；在获得了结果后，调用保存cookie接口并解析GZIP数据。
补全请求头 请求头说明Content-Type请求体类型，如：application/x-www-form-urlencodedContent-Length/Transfer-Encoding请求体解析方式Host请求的主机站点Connection: Keep-Alive默认保持长连接Accept-Encoding: gzip接收响应体使用gzip压缩CookieCookie身份识别User-Agent用户信息，如：操作系统、浏览器等 得到响应： 1、读取Set-Cookie响应头并调用接口告知用户，在下次请求则会读取对应的数据设置进入请求头，默认CookieJar无实现；
2、响应头Content-Encoding为gzip，使用GzipSource包装解析。
CacheInterceptor缓存拦截器 缓存拦截器顾名思义，交出之前读取并判断是否使用缓存；获得结果后判断是否缓存。
缓存规则 Http的缓存我们可以按照行为将他们分为：强缓存和协商缓存
命中强缓存时，浏览器并不会将请求发送给服务器。强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间；若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify/If-Modify- Since或Etag/If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，客户端从缓存中加载资源。 缓存策略 拦截器通过CacheStrategy判断使用缓存或发起网络请求。此对象中的networkRequest与cacheResponse分别代表需要发起请求或者直接使用缓存
networkRequestcacheResponse说明NullNot Null直接使用缓存Not NullNull向服务器发起请求NullNull要求使用缓存，但是没有缓存。直接gg，okhttp直接返回504Not NullNot Null发起请求，若得到响应为304(无修改)，则更新缓存响应并返回 即：networkRequest存在则优先发起网络请求，否则使用cacheResponse缓存，若都不存在则请求失败！
缓存检测 ConnectInterceptor连接拦截器 连接拦截器在交出之前，负责找到或者新建 一个连接，并获得对应的socket流；在获得结果后 不进行额外的处理。
链接流程 连接池清理 代理链接 CallServerInterceptor请求服务器拦截器 请求服务器拦截器进行真正的与服务器的通信，向服务器发送数据，解析读取的响应数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47c8c8636cd5482c204bd077037dc8bc/" rel="bookmark">
			Go后端服务器（访问html中的静态资源）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如代码所示，前端html页面中可能会存在这样子的引用，当用go写的代码作为服务器时，该怎么让浏览器中的html中的引用正常加载呢
&lt;script src="../src/resource/js/jquery.js"&gt;&lt;/script&gt; &lt;script src="../src/resource/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;script src="../src/resource/js/smoothscroll.js"&gt;&lt;/script&gt; &lt;script src="../src/resource/js/jquery.magnific-popup.min.js"&gt;&lt;/script&gt; &lt;script src="../src/resource/js/magnific-popup-options.js"&gt;&lt;/script&gt; &lt;script src="../src/resource/js/wow.min.js"&gt;&lt;/script&gt; &lt;script src="../src/resource/js/custom.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; 文件树如下所示
Go作为后端应用程序，应该如何给html提供所需要的文件呢？
http.Handle("/src/resource/", http.FileServer(http.Dir("./"))) 答：Go中有很方便的文件服务器，我们只需要给他配置一下，然后监听即可。
我们挨着来看这行代码，如果直接在浏览器中输入我监听的这个目录，那么就会进入如下页面。
该目录就是对应着http.Dir("./")这个目录，./就代表着从当前目录下开始，也就是goexercise这个目录下开始。
那么既然我们自己都可以从浏览器上下载资源了，那么html的Get请求岂不是也可以正常请求资源
我们可以从html中的get请求来分析一下，他具体请求的是哪个位置的文件，打开自己的html页面，F12，看网络
发现有一堆get请求，我们随便点开一个，发现访问的是./src/resource/js/bootstrap.min.js该路径的文件，跟html中的路径是一致的，我们之前已经配置好了文件系统了，所以正常来说可以访问。
我们手动查看一下是否可以正常访问该目录，如果都可以，那么应该就没有问题了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1661f7f0e4b72e903dd51027b8d63121/" rel="bookmark">
			Python之文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件操作 1. 文件的基本操作 打开文件读写等操作关闭文件 2.1.1 打开 在python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件，语法如下：
open(name, mode) name：是要打开的目标文件名的字符串(可以包含文件所在的具体路径)。
mode：设置打开文件的模式(访问模式)：只读、写入、追加等。
2.1.1.1 打开文件模式 Untitled
2.1.1.2 快速体验 f = open('test.txt', 'w') 注意：此时的f是open函数的文件对象。
2.1.2 文件对象方法 2.1.2.1 写 语法 对象对象.write('内容') 体验 # 1. 打开文件 f = open('test.txt', 'w') # 2.文件写入 f.write('hello world') # 3. 关闭文件 f.close() 注意：
w和a模式：如果文件不存在则创建该文件；如果文件存在，w模式先清空再写入，a模式直接末尾追加。r模式：如果文件不存在则报错。 2.1.2.2 读 read() 文件对象.read(num) num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据。
readlines() readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素。
f = open('test.txt') content = f.readlines() # ['hello world\n', 'abcdefg\n', 'aaa\n', 'bbb\n', 'ccc'] print(content) # 关闭文件 f.close() readline() readline()一次读取一行内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1661f7f0e4b72e903dd51027b8d63121/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0b1e2a07b47f4ab9cb4f42e6424320e/" rel="bookmark">
			Python之函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数 1. 函数 目的：函数在开发过程中，可以更高效的实现代码重用
1.1 函数定义 语法：
def 函数名(参数）： """函数说明文档""" #查看说明文档， help(函数名） 代码...... 函数的参数：函数调用的时候可以传入真实数据，增大函数的使用的灵活性
形参：函数定义时书写的参数(非真实数据)实参：函数调用时书写的参数(真实数据)传递和定义参数的顺序及个数必须一致。函数调用，通过“键=值”形式加以指定。可以让函数更加清晰、容易使用，同时也清除了参数的顺序需求。缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值不定长参数也叫可变参数。用于**不确定调用的时候会传递多少个参数(不传参也可以)的场景。**此时，可用包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便。 包裹位置传递
def name(*args): print(args) name('Dave') name('Dave', 19) """ ('Dave',) ('Dave', 19) """ 传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组(tuple)，args是元组类型，这就是包裹位置传递。 包裹关键字传递
def keys(**kwargs): print(kwargs) keys(name = 'Dave', nation = 'China', age = 18) # {'name': 'Dave', 'nation': 'China', 'age': 18} 函数的返回值
作用：函数调用后，返回需要的计算结果写法 return 表达式 return a, b写法，返回多个数据的时候，默认是元组类型。return后面可以连接列表、元组或字典，以返回多个值。 函数的说明文档
作用：保存函数解释说明的信息写法 def 函数名(): """ 函数说明文档 """ 函数嵌套调用：一个函数内部嵌套调用另外一个函数
2. 变量的作用域 变量作用域指的是变量生效的范围，主要分为两类：
局部变量：是定义在函数体内部的变量，即只在函数体内部生效。在函数体内部，临时保存数据，即当函数调用完成后，则销毁局部变量。全局变量：指的是在函数体内、外都能生效的变量。 如何在函数体内部修改全局变量？ global 关键字声明该是全局变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0b1e2a07b47f4ab9cb4f42e6424320e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92cdd17c6a0bddc929c82957d3c093d1/" rel="bookmark">
			【C&#43;&#43;】[C&#43;&#43; 自由存储区与动态内存分配] C&#43;&#43; 如何判断什么时候使用堆，什么时候用栈，什么时候用new
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 CSDN的文章像寄生虫，不管怎么搜都是重复的、低质量的、互相抄的、只有标题的、还有一堆点进去是跳转链接的、还全他娘标的“原创的”、“原创”的文章内容告诉你如下图，图都他娘的没有，抄都抄不全，最关键的是传播错误知识，让包括我在内的众多用户消化了很多错误知识，多走了很多歪路。因此，希望这篇文章能对CSDN的质量有一丝丝的提升，也包括了些自己的看法和经验，权当抛砖引玉。
C++的内存管理（五区） 理解什么时候用堆或栈，我们先回顾下基础知识，在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。
栈 在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
注：静态局部变量位于全局静态区（腾讯一面）
堆 由malloc分配的内存块，动态分配资源，由我们的应用程序去控制，一个malloc就要对应一个free，如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
这地方面试会考你内存泄漏的概念。引申出来C++11的智能指针或操作系统对内存碎片的处理都是常考内容。（大厂常考智能指针的底层原理）
自由存储区 C++的概念，new所申请的内存则是在自由存储区上，使用delete来释放。
你甚至能在CSDN搜到完全相反的定义（谣言：自由存储区是malloc出来的）。自由存储区在c++规范里说的很模糊，，具体的处理是靠编译器来的，大部分情况下能当成堆。这话可不是我瞎说的，我找到了一篇关于c++标准的文章
http://www.gotw.ca/gotw/009.htm
里面明确提到
翻译过来即
自由存储是两个动态内存区域之一（另一个说的是堆），由 new/delete
分配/释放。对象生命周期可以小于分配存储的时间；也就是说，空闲存储对象可以在不立即初始化的情况下分配内存，并且可以在不立即释放内存的情况下销毁。
这里我们还能看到其和堆的区别：
堆是另一个动态内存区域，
由 malloc/free 及其
变体分配/释放（也就是说封装了malloc的操作符等）。请注意，虽然默认的全局
new 和 delete 可能
由特定编译器根据 malloc 和 free 实现，但
堆与空闲存储不同，
在一个区域中分配的内存不能在另一个区域中安全地
释放。从堆分配的内存可以
通过 placement-new 构造和显式销毁
如果这样使用，关于自由存储区生命周期的注释在这里同样适用。
也就是说，全靠编译器，基本上，大部分C++编译器默认使用堆来实现自由存储，这样的编译器编译出来的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。（腾讯面试会问你如何改变分配对象的分配区，知识点就是这块）
全局/静态存储区 全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。
常量存储区 这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。
除此之外你还能看到分成其他区的，类似“代码区”、“BSS段”这类词，都不是C++层面的，别记。
堆与栈的使用 接下来的叙述，我们将自由存储区视为堆，或称这俩为动态内存分配。
为什么要使用动态内存分配 缺点：速度较慢并且可能导致内存泄漏或内存碎片。
优点：动态分配限制较少。
使用动态分配的两个主要原因：
编译时不确定需要多少内存。 例如，在将文本文件读入字符串时，通常不知道文件的大小，因此在运行程序之前无法决定分配多少内存。
即编译器无法确定char file[文件大小]，这句代码应该分配多少内存，因为文件大小在编译时无法给出确定的值。
然而，这里c++有个重要的特性，可以方便地使用动态内存分配， int n = 10; string text[n];这种写法没用到new，但却是在堆上分配内存，并会在离开当前块时，通过析构函数自动析构，使得代码看起来是在栈上创建的，实际上是在堆上创建的，我们下一节会详细提到。
希望离开当前块后保留分配的内存。 例如，
int func(int num) { int ans = num; return ans; } 在这种情况下，即使栈（string ans;）可以保存整个文件内容，您也无法从函数返回并保留分配的内存块，因为此时ans已经被操作系统回收了。（注，虽然你可以使用该函数的返回值，但实际上是进行了一次拷贝构造函数，即原来栈的对象已经被操作系统自动回收）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92cdd17c6a0bddc929c82957d3c093d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b605665ed4c63301d017dd65ecb48e52/" rel="bookmark">
			【vscode】vscode终端框无法输入或无法运行的某种原因 launch.json、c_cpp_properties.json、tasks.json、setting.json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直在用codeRunner运行程序，直到遇到了一个bug，需要用到断点功能，于是试了下F5。
发现终端框输入不了，并且运行代码有的代码没有输出，奇怪的bug，后找了许多解决方案，有的能在外部终端cmd正常运行，有的报错，有的“此时不应有 &amp;”的各种奇形怪状的问题。偶然发现笔记本的就很正常，对比了一下环境。
最后发现是台式机重装了系统后装的MinGW是32位的，笔记本是64的，在重装了个64的mingw并添加了path重启电脑后，整个程序正常了，消耗了一下午时间得来的经验。
另附上我的各Json配置文件数据，给大家作参考，也给自己留个备份。
使用如下json理论上可以在coderunner和调试运行的时候都用vsc的内置终端，并可以输入输出。各参数有的加了注释，按自己需求来改吧。
launch.json
//launch.json { "version": "0.2.0", "configurations": [ { "name": "(gdb) Launch", "type": "cppdbg", "request": "launch", "program": "${fileDirname}/${fileBasenameNoExtension}.exe", "args": [], "stopAtEntry": false, "cwd": "${workspaceFolder}", "environment": [], "externalConsole": false, "internalConsoleOptions": "neverOpen", "MIMode": "gdb", "miDebuggerPath": "gdb.exe", "setupCommands": [ { "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": false } ], "preLaunchTask": "Compile" } ] } c_cpp_properties.json
{ //c_cpp_properties.json "configurations": [ { "name": "Win32", "includePath": [ "${workspaceFolder}/**" // "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b605665ed4c63301d017dd65ecb48e52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff7527f8c43ceeb97ebbc18d6e344274/" rel="bookmark">
			【项目】[Qt] QT 发布程序；生成exe 、添加依赖dll 库、（可选）打包成单exe （含qt IDE和vs版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若需要添加自定义图标 软件发布后会使用默认应用程序图标（即软件出错时经常看到的那个图标）
若需要美观自定义图标，参考此文档
https://blog.csdn.net/gongfpp/article/details/120641056
qt IDE版 编译为release版本 Debug版本方便调试，而release版本则是为发布面向用户的软件的版本，release版本省略了大量的debug操作，编译器自动识别并在编译时自动优化程序，提高软件运行效率，因此我们需要用release版本编译
使用qt添加依赖库 我们找到编译后的exe所在目录
这里面包括了程序的.h .cpp和编译生成的.o等中间文件，我们运行时只需要exe文件
而此时双击exe文件，会发现缺少依赖dll等出错信息，这是因为我们使用qt creator的运行时，qt自动调用了所需的各种dll文件等，而我们自己手动打开exe，则没有qt的帮助。
为防止其他文件的干扰，我们新建一个文件夹，复制该exe文件进去，开始打包依赖库。
按下windows徽标键 ，搜索你所用的编译器的版本 （我这里用的是minGw 64bit）打开
窗口中输入cd D:\code\Qt\build-Homeworktor-Desktop_Qt_5_12_3_MinGW_64_bit-Release\release\Homeworktor
（路径换成你自己刚才新建的exe目录，若目录不处于C盘则需要先切换到相应盘符）
此时如上图 输入windeployqt Homeworktor.exe (exe换成你自己的文件名)
打包完如下图
该目录则包括了所需的所有文件和依赖项 此时已经可以双击使用exe
注：若仍出现如找不到libgcc_s_dw2-1.dll, 尝试重新安装该程序以解决问题.等错误，可能是构建套件与编译时的编译器版本不符合，需要选择相同版本的编译器重新执行windeployqt，即下图两者相同
Visual Studio版 编译并生成exe vs里点击
则会生成exe
用tool程序添加依赖库 首先启动下图程序
接下来需要两个目录
1.对应32|64位的windeployqt.exe程序目录，一般在类似下图的qt安装目录。
2.欲编译的程序release版目录。一般在vs项目目录中的release目录中，找到exe文件
如果没有，则先在vs中编译运行一次。
然后我们同样新建一个文件夹，把exe丢进去，这时我们可以看到，exe运行不了（因为没有依赖文件）。
我们使用tool工具，cd进入新建的文件夹（这里文件夹名为exe），使用
…\目录\windeployqt.exe -release 目标exe名
如下图所示
注意注意 ：这地方–release 不是单横线 图中打错了 但能运行 不知道有没有问题
完成后目录中会添加进项目所需的各种文件，此时即可运行
(选做)打包成一个exe文件 这时文件夹内有一堆文件，如果我们的项目并不大，仅是一个小工具，则一个大文件夹丢给用户使用则显得不方便，我们可以打包成一个exe文件。
首先下载 Enigma Virtual Box
https://enigmaprotector.com/en/downloads.html
安装后打开
此时在3处选择Add Folder Recursive 选择主exe所在的有一堆dll的目录（大部分情况下即1处的目录） 然后OK
点OK，则如上图，此时可以Files Options 中压缩文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff7527f8c43ceeb97ebbc18d6e344274/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62062a2485a26b3e891e2d2579230bb0/" rel="bookmark">
			普通原因与特殊原因的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在SPC中，对过程的偏差区分了信号与噪音，信号是特殊原因造成的偏差，噪音是普通原因造成的偏差。这两类原因有啥区别呢？我归纳整理如下：
普通原因特殊原因定义 普通原因指的是指持续作用于过程的多种变差源。过程中的普通原因会随着时间的推移产生稳定且可重复的分布。我们称之为:“处于统计控制状态”、“受统计控制”，或有时简称“受控”。普通原因表现为一个稳定系统的偶然原因。只有变差的普通原因存在且不改变时，过程的输出才是可以预测的。特殊原因(通常也叫查明原因)指的是造成不是始终作用于过程的变差的原因，即当它们出现时将造成(整个)过程的分布改变。除非所有的特殊原因都被查出来并且采取了措施，否则它们将继续用不可预测的方式来影响过程的输出。如果系统内存在变差的特殊原因，随着时间的推移，过程的输出将不稳定。影响范围持续地影响过程，是具有稳定的，是会影响过程输出的所有单值偶然发生的，有时存在，有时不存在，不会影响过程输出的所有单值影响因子的数量是有很多单独的因素产生是由一个或几个单独的因素产生影响因子的力量单个因素对过程结果产生的影响会很小任何一个都会对过程结果产生巨大的变差作用时间 长期 短期或间断 可预测性 可预测 不可预测，有偶然性 点的表现 点是随机的 超出控制限或非随机的 有害/有利 有害 有害，需查出原因，消除 有益，需查出原因，保持 消除成本 成本高，时间长 成本低，时间短 消除的责任 管理者 过程直接操作者 采取的措施 系统措施：需要修改过程的定义、入口准则、属性取值范围。局部措施：需要符合过程的定义、入口准则、属性取值范围。措施的影响范围约80%的问题约20%的问题对Cpk的作用初始过程能力Cpk=1.67，若要想Cpk=2.0去努力，这时候就是在消除普通原因初始过程能力Cpk=1.67，努力让Cpk也达到1.67的过程就是在消除特殊原因示例人员能力差异，需求复杂度不同，估算水平的差异投入未达标，人员缺乏培训，临时停电，人员离职 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7a031acbe63042aa4cd5c08e9c066b8/" rel="bookmark">
			pytorch_lesson10 二分类交叉熵损失函数及调用&#43;多分类交叉熵损失函数及调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：仅仅是学习记录笔记，搬运了学习课程的ppt内容，本意不是抄袭！望大家不要误解！纯属学习记录笔记！！！！！！
文章目录 一、机器学习中的优化思想二、回归：误差平方和SSE三、二分类交叉熵损失函数1 极大似然估计求解二分类交叉熵损失2 用tensor实现二分类交叉熵损失3 用PyTorch中的类实现二分类交叉熵损失 四、多分类交叉熵损失函数1 由二分类推广到多分类2 用PyTorch实现多分类交叉熵损失调用logsoftmax和NLLLoss实现直接调用CrossEntropyLoss（） 一、机器学习中的优化思想 模型训练的目标：求解一组最适合的权重向量，令神经网络的输出结果与真实值尽量接近。
关键概念：损失函数是可以衡量真实值与预测结果的差异，评价模型学习过程中产生的损失的函数。
如果损失函数的值很小，则说明模型预测与真实值很接近，模型在数据集上表现优异，权重优秀；如果顺势函数的值很大，则说明模型预测值与真实值差异很大，模型在数据集上表现很差，权重糟糕。
二、回归：误差平方和SSE from torch.nn import MSELoss import torch torch.random.manual_seed(420) yhat = torch.randn(size=(50, 1), dtype=torch.float32) y = torch.randn(size=(50, 1), dtype=torch.float32) criterion = MSELoss() #实例化 loss = criterion(yhat, y) #由于没有设定随机种子，所以每次运行的数字都不同 print(loss) #tensor(2.4869) 对于MESloss来说，有一个重要的参数是reduction，reduction默认是mean，求得是平均损失，reduction设置为sum时，求的是全部样本的损失值之和。
criterion_1 = MSELoss(reduction='sum') loss_1 = criterion_1(yhat, y) print(loss_1) #tensor(124.3458) criterion_2 = MSELoss(reduction='mean') loss_2 = criterion_2(yhat, y) print(loss_2) #tensor(2.4869) 三、二分类交叉熵损失函数 1 极大似然估计求解二分类交叉熵损失 我们将极大似然概率公式表示为：
第i个样本预测为1的概率为p1，被预测为0的概率为p0，yi代表第i个样本的真实标签，这个标签为1的时候，p1就保留下来了，如果真实标签为0的话，p0就保留下来了。然后我们使得这个预测概率达到最大即可。
2 用tensor实现二分类交叉熵损失 N = 3 * pow(10, 3) torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7a031acbe63042aa4cd5c08e9c066b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5143970ebb6d75b7e2ff10703c912571/" rel="bookmark">
			数据结构 - 哈希表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本介绍 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
数组 + 链表
实例 有一个公司，当有新的员工来报道时,要求将该员工的信息加入(id、性别、年龄、住址……)，当输入该员工的id时，要求查找到该员工的所有信息。
要求：不使用数据库，尽量节省内存，速度越快越好 =&gt; 哈希表(散列表)。
员工实体类Employee
/** * @ClassName Employee * @author: shouanzh * @Description 雇员实体类 * @date 2022/5/13 21:00 */ class Employee { private int id; private String name; private Employee next; // 下个节点 public Employee(int id, String name) { this.id = id; this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5143970ebb6d75b7e2ff10703c912571/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1839c7ade264a84b8ae1cfca560c67c3/" rel="bookmark">
			轨迹优化——三维空间下通过BVIP生成最小jerk轨迹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面的 这篇文章主要是记录下深蓝学院开的《移动机器人运动规划》这门课程中第五章-最优轨迹生成的作业即三维空间下通过BVIP生成最小jerk轨迹相关的内容及做作业时的过程。
其课程链接在下面，感兴趣的可以去报名学习：
移动机器人运动规划-深蓝学院 任务描述 如下图所示，给定三维空间下起始点和终点的位置、速度和加速度，以及（M-1）个中间位点的位置，那么这段轨迹就被分成了 M 段。其中每小段轨迹移动的时间 也是给定的。
要求我们用最优条件来计算三维最小jerk轨迹的系数，因为这些系数能描述一条轨迹，这个后面也会讲。
至于最优条件怎么来的，这里就不说明了，后面会讲最优条件是什么。
边界值问题（Boundary value problem，BVP) 在讲BVIP时我们先来讲轨迹生成中的BVP问题，这一部分建议先看下面链接的相关内容：
Robotics: Aerial Robotics（空中机器人）笔记（六）:无人机运动规划
简单来说，就是我们已知机器人初始的状态（比如说初始的位置，速度，加速度等），以及最后的状态，也就是我们只考虑起始和最终的状态，不考虑中间的状态。
如下图所示，这是一个无人机接球的例子，只考虑无人机起始的状态和接球的状态来生成轨迹：
最优条件理论告诉我们：如果我们的输入是轨迹的 s 阶导数（如果是位置的话 s=1 ，加速度的话 s=2， jerk的话 s=3，依此类推），那么其描述轨迹的多项式的阶数就是 2s -1。我们现在要生成是jerk轨迹，那么多项式的阶数就是 2 * 3 - 1 = 5。
我们来看一维空间的情况，起点和终点的状态已知，求jerk轨迹：
那么我们的jerk轨迹就可以这么描述：
通过将 t=0, t=T代入到上面的多项式，以及多项式的一阶求导，二阶求导可得：
如果边界条件是这样的则是：
这时如果这段轨迹运行的时间 T 已知，那么就可以求出这条轨迹的参数 了 。那么轨迹也就知道了。
那么如果我们要设计一条经过指定位点的轨迹，我们就需要指定每个位点的状态，包括位置，速度，加速度等等。 但有时候我们只是要让机器人经过某个位点，而不需要规定其在位点的速度，加速度等状态，那么这就是BIVP（Boundary-intermediate value problem）。
BIVP（Boundary-intermediate value problem） 最优条件理论告诉我们，如果我们的输入是轨迹的 s 阶导数，那么其 2s-d-1 阶导数也都是连续可导的。也就是说，如果我们的输入是 jerk（ s = 3 ），首先位置，速度，加速度肯定是连续的，这没有异议。但是包括 jerk 在内，snap（ s = 4 ）在位点上也是连续可导的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1839c7ade264a84b8ae1cfca560c67c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f155dd9b83863e0cec67ae84d52bc656/" rel="bookmark">
			【c&#43;&#43;/c】C语言“小小计算器”扩展功能【期末大作业】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 实验1、“小小计算器”扩展功能实现（1）代码整合：结果实验2、“小小计算器”扩展功能实现（2）代码结果解决问题：中文乱码 上一篇：小小计算器基本功能 实验1、“小小计算器”扩展功能实现（1） 扩充小小计算器功能：
&lt;1&gt; “22 学生成绩排序”
定义学生结构体数组，长度为10，依次输入这十个学生的学号、姓名、成绩，利用冒泡排序，对这10个学生排序，从小到大输出这10个学生的信息，然后输出10个学生的总成绩和平时成绩
代码整合： #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; using namespace std; int main() { const int n=10; struct student //定义结构体变量 { string name; int num; double score; }; struct student student1[n]; struct student student2; int i,j; for(i=0;i&lt;n;i++) { cout&lt;&lt;"请输入第"&lt;&lt;i+1&lt;&lt;"个学生的信息："; cin&gt;&gt;student1[i].num &gt;&gt;student1[i].name &gt;&gt;student1[i].score; } double sum=0; double average; //各学生的平均成绩 for(i=0;i&lt;n;i++) { sum=sum+student1[i].score; average=sum/3; } // 冒泡排序 for(int j=0;j&lt;n;j++){ for(i=0;i&lt;n-j-1;i++){ if(student1[i].score&gt;student1[i+1].score){ student2 = student1[i]; student1[i] = student1[i+1]; student1[i+1] = student2; } } } //打印出各学生的信息 cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f155dd9b83863e0cec67ae84d52bc656/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b76b9a2602f09a34e364001303154c0/" rel="bookmark">
			C语言简单编程：计算球的体积和面积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天用 C语言做一个计算球的体积和表面积的程序。
首先我们要知道球的体积和表面积计算公
对于公式中用到的圆周率PI我们使用”宏替换"来实现。我们定义为大写字母PI并使之被替换的值为3.14.代码如下：
#include&lt;stdio.h&gt; #define PI 3.14 //宏定义 int main() { int r; //定义r为整型 float v,f; //定义v,f为当精度浮点型 r=2; //给半径赋值 v=4.0*PI*r*r*r/3.0; //计算球的体积 f=4.0*PI*r*r; //计算球的表面积 printf("体积为：%f，表面积为：%f\n",v,f); //输出体积、表面积 return 0; } 接下来我们可以改变半径的值，或者改变PI被替换的值，在运算看看，比手算快多了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa597c8140b6fdf8c35ee27a1004538/" rel="bookmark">
			智能车方向环pd控制理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能车方向环pd控制理解 方向环d的作用方向环p的作用d项与p项的相互影响对于舵机pd参数的意义如何整定参数舵机的pd控制研究方案1： P = P b a s i c + E R ∗ E R ∗ K P=P_{basic}+ER*ER*K P=Pbasic​+ER∗ER∗K：方案2： P = P b a s i c + A B S ( E R ) ∗ K P=P_{basic}+ABS(ER)*K P=Pbasic​+ABS(ER)∗K：方案3： P = E R ∗ E R ∗ K P=ER*ER*K P=ER∗ER∗K：方案优化建议： 位置式pd公式： p ∗ E R + d ∗ ( E R − E R L ) p*ER+d*(ER-ERL) p∗ER+d∗(ER−ERL) p为比例项 d为微分项 ER为当前车辆与赛道中线的偏差 ERL为当前车辆与赛道中线的上次偏差 方向环d的作用 在智能车转向控制中，车辆的转弯主要取决于d项控制，当车辆由直道入弯时，ER-ERL会变化很大，而ER的变化其实很小，此时主要起作用的是d项，所以入弯主要靠d项，也就是给人一种d项有预测作用的感觉
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fa597c8140b6fdf8c35ee27a1004538/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e45e33e2f7db3828d2f16da03e9e7c2/" rel="bookmark">
			(三)路径规划算法---OBVP例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路径规划算法中的OBVP例子 文章目录 路径规划算法中的OBVP例子1.已知量1.1 目标函数1.2 变量1.3 状态方程1.4 初始值 2.固定边界条件2.1 构建系统的Hamiltonian矩阵 H H H和协变量 λ \lambda λ2.2 通过Hamiltonian矩阵对协变量进行求导2.3 最小化输入变量2.4 通过积分求得最优轨迹 s ∗ s^* s∗2.5 最终状态确定最优轨迹的参数2.6 最优状态下目标函数 3.自由边界条件4 .小结 通过 上章的OBVP的原理讲解，大家想必对该算法的流程有了大致了解，现在通过路径规划课程里面的例子，加深对OBVP的了解。 1.已知量 1.1 目标函数 J = ∫ 0 T g ( s , u ) d t = ∫ 0 T ( 1 + u T R u ) d t = ∫ 0 T ( 1 + a x 2 + a y 2 + a z 2 ) d t J=\int_0^T {g(s,u)dt = \int_0^T {(1 + {u^T}Ru)dt = \int_0^T {(1 + a_x^2 + a_y^2 + a_z^2)} } } dt J=∫0T​g(s,u)dt=∫0T​(1+uTRu)dt=∫0T​(1+ax2​+ay2​+az2​)dt
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e45e33e2f7db3828d2f16da03e9e7c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0206920f87589c03639c1be1e1458d7/" rel="bookmark">
			三种等待方式：强制等待、显式等待、隐式等待
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用selenium的时候，会遇到一种定位不到的情况，因为web页面有一个加载的过程 当页面元素未出现时，去定位肯定是定位不到的，所以我们需要用到了‘等待’，该如何使用等待呢，让我们一起来探讨一下吧！
time.sleep()强制等待 time模块，是python专门用来处理时间的内建库。
我们可以使用它时需要导入 import time
time.sleep(2) 意思是强制休眠2秒种的时间
这样等待的弊端是，我们已经定位到元素的时候，还会继续等待，导致我们工作效率很低 所以WebDriver提供了两种类型的等待：隐式等待和显式等待
implicitly_wait()隐式等待 该方法来实现隐式等待，默认参数的单位为秒，如里面的参数设置等待时长为10秒。
当脚本执行到某个元素定位时，如果元素可以定位，则继续执行；
如果元素定位不到，则它将以轮询的方式不断地判断元素是否被定位到。
假设在第6秒定位到了元素则继续执行，若直到超出设置时长（10秒）还没有定位到元素，则抛出异常。
该等待设置完是对整个全局起作用，所以只需设置一次即可，不需要导入任何模块，直接使用
WebDriverWait()：显式等待 是针对于某个特定的元素设置的等待时间，在设置时间内，默认每隔0.5时间检测一次特定的元素是否存在，
如果在设置的时间内找到了元素，则直接执行。如果超过设置最长等待时间检测不到则抛出异常。
默认检测频率为0.5s，默认抛出异常为：NoSuchElementException。
该方法需要导入By 、WebDriverWait 、expected_conditions
下面的代码是对三种等待的具体例子：
from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC import time driver=webdriver.Chrome() driver.implicitly_wait(5) #隐式等待 driver.get('http://www.baidu.com') time.sleep(3) #强制等待 driver.find_element_by_id('kw').send_keys('特朗普') #每隔0.5秒检查一次（默认就是0.5秒。也可以修改），最多等待10秒，直到找到ID="su"元素就执行，否则抛出异常 element=WebDriverWait(driver,10,0.5).until(EC.visibility_of_element_located((By.ID,'su'))) #显式等待 element.click() time.sleep(2) driver.quit() 补充一点
presence_of_element_located 检查元素是否存在，但是并不一定可见。
visibility_of_element_located 检查元素存在，并且可见于页面，也就是能定位到它
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4c4571104e5bda54e6c80e66a30640a/" rel="bookmark">
			【Unity Shader】UI特效在RawImage上使用运行良好,但是在Image上则不是预期效果的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		疑惑 在最开始用shader做UI特效的时候,或多或少会遇到这样的问题,就是用RawImage能得到预期效果,而用Image很有可能就得不到预期效果,关键原因还是UV的差异引起的.
简单说下RawImage和Image的差异:
他们是从MaskableGraphic派生出来的两个不同的分支,他俩并没有继承关系.
游戏中应该跟多的会使用到Image,因为他是用的图集思想,可以达到自动合批的效果,性能是优于RawImage的,而能达到自动合批,那么他得有相同的材质球,比如两个Image分别显示同一个图集中的不同Sprite,那么他们的材质球中的贴图则就是整张图集(在FrameDebugger中可查看),而达到显示不同的Sprite则是通过Image网格中顶点的UV值来指定的,而RawImage则不是图集思想,就是单张纹理直接显示,他的网格顶点中的UV值就是正常的[0~1].
通常情况下做UI特效,内部算法要么直接对颜色值进行处理,要么就是用UV值做变化因子进行一些操作.而用UV值参与计算的shader就很有可能在Image上使用效果达不到预期的问题,因为内部的算法基本上都是视为UV的区间是0~1,那么处理的结果就可以想象是对整张图集进行处理,而当前这个Image就仅仅是取其中一小块,当然效果就很难达到预期.
PS:如果内部想用模型坐标来计算,那么更不靠谱,因为对合批的网格去取他的模型坐标本身就是离大谱的事儿.
解决办法 Image的网格里的UV值不是不在[0,1]区间吗.那么可以在使用uv值做变换之前,将他重新映射的到预期的[0,1]区间,那么后续的计算就能达到我们的预期效果.而在映射之前就得拿到当前Image上显示的Sprite在图集中uv值范围.
CPU端获取Sprite在图集中uv值范围代码:
Vector4 GetSpriteUVRange(Image image){ Sprite sp = image.sprite; Vector2[] uv = sp.uv; //四个分量值的含义 x:uMin y:uMax z:vMin w:vMax Vector4 uvRange = new Vector4(1,0,1,0); for (int i = 0; i &lt; uv.Length; i++) { Vector2 tempUV = uv[i]; uvRange.x = Mathf.Min(uvRange.x, tempUV.x); uvRange.y = Mathf.Max(uvRange.y, tempUV.x); uvRange.z = Mathf.Min(uvRange.z, tempUV.y); uvRange.w = Mathf.Max(uvRange.w, tempUV.y); } return uvRange; } 将上面获取到的uv范围传入到Shader中,uv映射伪代码如下:
//这里的lerp其实不需要, 第三个参数计算的结果就是在[0,1]区间 //只是为了传达更常用的映射关系,比如像映射到1~3,那么吧前面的0,1 改为 1,3即可.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4c4571104e5bda54e6c80e66a30640a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c2a9d5db5d727c79224c018ea63a67a/" rel="bookmark">
			怎样防止雪崩效应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是雪崩一、怎么防止雪崩二、spring-cloud-alibaba整合sentinel1.加依赖2.加注解3.加配置4.下载jar5.使用 什么是雪崩 随着时间的进行，假设A服务down了，而B还在不断的请求，每次请求都创建一个线程，B线程数越来越大，最终达到服务器最大限度，进而B服务down了，而B的上游服务也在不断请求B服务，进而上游服务陆续都Down了。
这种因下游服务导致一系列上游服务Down的现象称为雪崩效应。
一、怎么防止雪崩 超时的思想： 减小请求的超时时间，超时就释放线程。限流的思想： 限定流量大小，超 过这个值就进流量了。舱壁模式思想：请求接口时用自己的线程池，A线程池满了，不会影响B线程池。比如一条船，一个舱进水了，不会影响别的舱，船也 不会沉。断路器思想： 监控API错误率达到阈值就断闸，过段时间进入半开模式，根据半开模式结果来选择进入断闸还是合闸。 二、spring-cloud-alibaba整合sentinel 1.加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 2.加注解 不用加
3.加配置 加暴露sentinel配置 management: endpoints: web: exposure: include: '*' 启动应用确认集成sentinel是否成功，访问：http://localhost:8081/actuator/sentinel给微服务指定sentinel spring: datasource: url: jdbc:mysql://localhost:3306/content_center?serverTimezone=UTC hikari: username: gxf password: 1111.aaa # mysql-connector 版本 # &gt;= 6.x: com.mysql.cj.jdbc.Driver # &lt;= 5.x: com.mysql.jdbc.Driver driver-class-name: com.mysql.cj.jdbc.Driver application: name: content-center cloud: nacos: discovery: server-addr: localhost:8848 cluster-name: BJ-UserCenter metadata: target-version: v1 version: v1 sentinel: transport: dashboard: localhost:8080 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c2a9d5db5d727c79224c018ea63a67a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69bee4578d800153679a8b22a7f9b9ab/" rel="bookmark">
			查看linux服务器性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看物理cpu核心数 cat /proc/cpuinfo |grep "physical id"|sort|uniq|wc -l 查看每个物理cpu中的core个数 # output为12，说明当前服务器的每个物理CPU封装的物理核数为12个 cat /proc/cpuinfo |grep "cpu cores"|wc -l 逻辑cpu的个数 # output为12，说明该服务器有12个逻辑CPU # 物理cpu个数*核数=逻辑cpu个数（不支持超线程技术的情况下） cat /proc/cpuinfo |grep "processor"|wc -l #cpu运行模式32/64
root@XXXXXXX:~# getconf LONG_BIT 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac6c610f04f454f10aded4bf96d95da3/" rel="bookmark">
			利用python 在音频中加入指定SNR的噪声
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在声音分类中常常需要 在声音中加入指定SNR的噪声， 本文提供增加指定SNR的加性高斯白噪声（Additive White Gaussian Noise (AWGN)）的代码。
代码如下：
def awgn(audio, snr): #在audio y中 添加噪声 噪声强度SNR为int audio_power = audio ** 2 audio_average_power = np.mean(audio_power) audio_average_db = 10 * np.log10(audio_average_power) noise_average_db = audio_average_db - snr noise_average_power = 10 ** (noise_average_db / 10) mean_noise = 0 noise = np.random.normal(mean_noise, np.sqrt(noise_average_power), len(audio)) return audio + noise audio为clean audio, snr为指定的整数大小。 如 clean audio: waveform 与 spectrogram为
SNR指定10时候： waveform 与spectrogram为
敢于spectrogram 计算可以参考：理解梅尔频谱（mel spectrogram）
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/270/">«</a>
	<span class="pagination__item pagination__item--current">271/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/272/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>