<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87df6572bfdc7d4f67239b150e19ac43/" rel="bookmark">
			关于SQL统计数值范围内人数的问题（工资范围，年龄范围）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博客解决的问题是SQL统计范围人数的问题。
比如统计0-3000，3000-4000，4000-5000.....等工资段的人数
或者统计0-60，60-70，70-80，80-90，90-100每个分数段的人数
类似这种问题的SQL解决方法
我们先通过一个例子来了解以下：
首先我们建一张表，名user如下
idusernamemoney1张三1002李四3003王五9004老六4005七妹80006小八10007老九1200 我们来统计money在区间 0-500，500-1000，1000-1500每个段的人数：
查询语句格式是这样的
select count(case when money BETWEEN 0 AND 500 THEN 1 END) as '0-500', count(case when money BETWEEN 501 AND 1000 THEN 2 END) as '500-1000', count(case when money BETWEEN 1001 AND 1500 THEN 3 END) as '1000-1500' FROM user 解析一下：
每一个count都是求一个分段，as是给分段一个别名
拿一个语句刨析一下里边的意思 count(case when money BETWEEN 0 AND 500 THEN 1 END)as '0-500'
case when 条件 Then 成立的话怎样 END
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87df6572bfdc7d4f67239b150e19ac43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d10164fe31314ad88267fea6844d4fbc/" rel="bookmark">
			mx-framework前端框架使用经验积累(SG-UAP)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用SG-UAPV2.8及mx-framework前台框架开发项目的过程中，积累了一些前端框架的使用技巧，基本上涵盖了大部分常用点。如有需要可以打开“阅读更多”后，直接全文搜索你想知道的问题。若未查询到可以留言告诉我，我也会尽力解答。
**
1.布局控件 **
创建一个布局控件主要包括以下步骤： 导入js类 创建实例 将实例添加到容器中
导入所需的js类。
创建实例。
将实例添加到容器中。
**
## 1.1上下分割窗口布局
**
//1.导入类代码
$import("mx.containers.HSplit"); //2. 创建实例
me.hsplit = new mx.containers.HSplit({ rows: “300, auto“ ,//窗口的两部分大小 borderThick:”0px”//设置边框粗细 }); //3.将实例添加到容器中
me.addControl(me.hsplit); **
1.2左右分割窗口布局
**
//1.导入类代码
$import("mx.containers.VSplit"); //2. 创建实例
me.vsplit = new mx.containers.VSplit({ cols: “300, auto“ //窗口的两部分大小 }); //3.将实例添加到容器中
me.addControl(me.vsplit); 1.3手风琴式菜单
//1.导入类代码
$import("mx.containers.Accordion"); //2. 创建菜单实例
me.accordion = new mx.containers.Accordion( { "height":"60%", "width":"20%", panels:[ { title: "综合评价", name: "zhpj" }, { title: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d10164fe31314ad88267fea6844d4fbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd5ad4a5a90ac9ae7c91c6fa34f2790a/" rel="bookmark">
			[详细]Oracle新建数据库实例、创建用户和表空间及添加“本地Net服务名”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
1.创建数据库实例： **
1.打开“Database Configuration Assistant”，选择“创建数据库”
2.输入数据库实例名“sguap”或其他自定义
3．输入同一口令，一定要记住：
4.选择“使用Unicode（AL32UTF8）”
以上为创建数据库实例的详细步骤，没有添加特殊说明的地方，都按默认处理（更高级的配置请教高手，此处仅是入门级介绍）。
**
2.配置表空间和用户 **
方式一：用SQL语句创建表空间和用户
1.使用PL/SQL工具登录刚刚创建的数据库；Username:sys;Password:自己先前设定的；Database:localhost:1521/数据库实例名；Connect as：SYSDBA。
2. 新建—SQL Window
2.输入以下SQL语句，创建表空间，其中“&amp;table_space_name”更改为自定义表空间名称，例如：TBS_SGUAP;“&amp;table_data_name”更改为自定义数据文件名；最后点击运行。
CREATE TABLESPACE table_space_name LOGGING DATAFILE '&amp;table_data_name ' SIZE 200M AUTOEXTEND ON NEXT 100M MAXSIZE UNLIMITED EXTENT MANAGEMENT LOCAL SEGMENT SPACE MANAGEMENT AUTO ; 实例：
CREATE TABLESPACE TBS_SGUAP LOGGING DATAFILE 'DATA_SGUAP_1' SIZE 200M AUTOEXTEND ON NEXT 100M MAXSIZE UNLIMITED EXTENT MANAGEMENT LOCAL SEGMENT SPACE MANAGEMENT AUTO ; 3.使用以下SQL 语句创建用户，其中“&amp;username”更改为自定义用户名，例：uap_user；“&amp;password”更改为自定义密码，例如：uap_user；“table_space_name”为刚刚创建的表空间名称；
create user &amp;username identified by &amp;password default tablespace table_space_name ; 实例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd5ad4a5a90ac9ae7c91c6fa34f2790a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69bac662a50c51e7e670041e1273affa/" rel="bookmark">
			MyBatis教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自 https://b：log.csdn.net/zpcandzhj/article/details/80878563 文章目录 1.从JDBC谈起1.1.使用IDEA创建maven工程1.2.引入mysql依赖包1.3.准备数据1.4.JDBC基础代码回顾1.5.JDBC缺点分析 2.MyBatis介绍3.Mybaits整体架构4.快速入门（quick start）4.1.引入依赖（pom.xml）4.2.全局配置文件（mybatis-config.xml）4.3.配置Map.xml（MyMapper.xml）4.4.修改全局配置文件（mybatis-config.xml）4.5.构建sqlSessionFactory（MybatisTest.java）4.6.打开sqlSession会话，并执行sql（MybatisTest.java）4.7.目录结构 5.分析5.1.引入日志依赖包（pom.xml）5.2.添加log4j.properties5.3.MyBatis使用步骤总结 6.完整的CRUD操作6.1.创建UserDao接口6.2.创建UserDaoImpl6.3.编写UserDao对应的UserDaoMapper.xml6.4.添加UserDao的测试用例6.5.编写UserDao的测试用例6.6.目录结构6.7.解决数据库字段名和实体类属性名不一致的问题 7. 动态代理Mapper实现类7.1.思考上述CRUD中的问题7.2.使用动态代理改造CRUD7.3.完整的例子7.4.动态代理总结 8.mybatis-config.xml详解8.1.properties属性读取外部资源8.2.settings设置8.3.typeAliases8.4.typeHandlers（类型处理器）8.5.plugins（插件）拦截器8.6.environments(环境)8.7.mappers 9.Mapper XML文件详解9.1.CRUD标签9.1.1.select9.1.2.insert9.1.3.update9.1.4.delete 9.2.#{}和${}9.3.面试题（#、$区别）9.4.resultMap9.5.sql片段 10.动态sql10.1.if10.2.choose when otherwise10.3.where 和set10.4.foreach 11.缓存11.1.一级缓存11.2.二级缓存 12.高级查询12.1.表关系说明12.2.一对一查询12.3.一对多查询12.4.多对多查询12.5.resultMap的继承12.6.高级查询的整理 13.延迟加载14.如果sql语句中出现’&lt;’的解决方案1、使用xml中的字符实体2、使用```&lt;![CDATA[ &lt; ]]&gt;``` 15.Spring 集成Mybatis15.1引入spring和Mybatis相关依赖15.2配置spring配置文件15.3 测试 16.SpringBoot 集成Mybatis17.Mybatis Generator的使用18.MyBatis整合分页插件 pageHelper 1.从JDBC谈起 1.1.使用IDEA创建maven工程 1.2.引入mysql依赖包 &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; 12345 1.3.准备数据 创建数据库：
CREATE DATABASE ssmdemo;
创建表：
DROP TABLE IF EXISTS tb_user;
CREATE TABLE tb_user (
id char(32) NOT NULL,
user_name varchar(32) DEFAULT NULL,
password varchar(32) DEFAULT NULL,
name varchar(32) DEFAULT NULL,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69bac662a50c51e7e670041e1273affa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47bec42803339d4611a266ac8e1c9042/" rel="bookmark">
			Kubernetes之ServiceAccount&#43;Secret（超详细汇总）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第0章、前言 API Server作为Kubernetes网关，是访问和管理资源对象的唯一入口，其各种集群组件访问资源都需要经过网关才能进行正常访问和管理。每一次的访问请求都需要进行合法性的检验，其中包括身份验证、操作权限验证以及操作规范验证等，需要通过一系列验证通过之后才能访问或者存储数据到etcd当中。如下图：
每一个用户对API资源进行操作都需要通经过以下三个步骤：
第一步：对客户端访问进行认证操作，确认是否具有访问k8s权限 token(共享秘钥) SSL(双向SSL认证) ....通过任何一个认证即表示认证通过，进入下一步 第二步：授权检查，确认是否对资源具有相关的权限 ABAC(基于属性的访问控制) RBAC(基于角色的访问控制) NODE(基于节点的访问控制) WEB HOOK(自定义HTTP回调方法的访问控制) 第三步：准入控制(对操作资源相关联的其他资源是否有权限操作) Kubernetes只对以下的API请求属性进行检查:
user - username,uid group - user group "extra"- 额外信息 API - API资源的对象 Request path - 请求资源的路径(k8s使用resultful风格接口的API) http://Node_IPaddr:6443/apis/apps/v1/namespaces/namespaces_name/resource_name/ HTTP 请求动作 - HTTP verbs get，post，put，和delete用于非资源请求 HTTP 请求动作映射到 API资源操作- get，list，create，update，patch，watch，proxy，redirect，delete，和deletecollection用于请求resource Resource -被访问（仅用于resource 请求）的resource 的ID或名字- *对于使用resource 的请求get，update，patch，和delete，必须提供resource 名称。 Subresource - 正在访问的subresource （仅用于请求resource ） Namespace - 正在访问对象的命名空间（仅针对命名空间的请求资源） API group - 正在访问的API组（仅用于请求资源）。空字符串指定核心API组。 Secret解决了密码、token、密钥等敏感数据的配置问题，而不需要把这些敏感数据暴露到镜像或者Pod Spec中。Secret可以以Volume或者环境变量的方式使用。
第一章、Secret Secret类型 Secret有三种类型： Opaque：base64编码格式的Secret，用来存储密码、密钥等；但数据也通过base64 –decode解码得到原始数据，所以加密性很弱。 kubernetes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47bec42803339d4611a266ac8e1c9042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0857c0de1138f0d71c6f1b19933ca245/" rel="bookmark">
			modelsim更改默认编辑器以及恢复默认编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		modelsim自带的编辑器不是很友好，但是可以生成testbench模板，而且调试时也能自动跳转到某一行的错误。有时设置外部编辑器后无法恢复自带编辑器，具体解决方案如下：
1、新装modelsim采用内部编辑器
删除注册表项：
Computer\HKEY_CURRENT_USER\Software\Model Technology Incorporated\ModelSim 并新装好modelsim之后，此时.v文件的默认打开方式保持和windows的设置一样，如果windows里你已经设置过.v文件的默认打开方式，此时需要删掉注册表项：HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.v，即可恢复默认编辑器。
2、设置外部编辑器
如何设置外部编辑器呢？首先要在modelsim自带的terminal里输入：
proc external_editor {filename linenumber} { exec "D:/Program Files/Notepad++.exe" $linenumber $filename &amp; # edit as required } 接着输入：
set PrefSource(altEditor) external_editor 这样即完成了配置外部编辑器 并采用外部编辑器打开source文件，此时在1中提到的modelsim的注册表项中也生成了PrefSource项。
3、恢复内置编辑器
terminal中输入unset PrefSource(altEditor)即可恢复windows默认的编辑器。如果此时在modelsim双击v文件仍然采用外部编辑器打开，参考1中删除windows的默认配置即可。
4、总结
个人认为，默认文件最好采用内部编辑器打开方便bug定位和tb生成，可以同时采用外部编辑器打开，这样需要重复点击reload，但是省去了很多事情。部分参考链接：https://electronics.stackexchange.com/questions/17359/how-to-configure-my-favorite-editor-in-modelsim
2019.3.13
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7985be519416fb25339b1356b1c4083/" rel="bookmark">
			统计学中I和II类错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：原文转
转自：原文转
假设检验是基于抽样样本来进行结果推断的，而抽样样本只是总体的一小部分，从总体中抽取不同的样本，可能会得出不同的结果，因此我们通常希望抽样样本是一个能够很好地反映总体特征的具有代表性的样本。但由于抽样误差的存在，在进行假设检验根据P值做出推断时具有一定的概率性，因此所得的结论就不一定完全正确，这就是我们常见的假设检验的陷阱：I类错误和II类错误。
I类错误，也称为假阳性错误，就是说实际上总体并无差异，原假设H0是成立的，但是通过假设检验P≤α，在设定α的检验水准下，拒绝了H0，认为有差异，出现了假阳性的现象。前面提到的检验水准α，就是预先设定允许犯I类错误概率的最大值，此时犯I类错误的概率即为α。
II类错误，也称为假阴性错误，就是说实际上原假设H0不成立，但是通过假设检验P＞α，在设定α的检验水准下，不拒绝H0，得出了阴性的结论，此时犯II类错误的概率为β。
1、第一类错误又称Ⅰ型错误、拒真错误，是指拒绝了实际上成立的、正确的假设，为“弃真”的错误，其概率通常用α表示。假设检验是反证法的思想，依据样本统计量作出的统计推断，其推断结论并非绝对正确，结论有时也可能有错误，错误分为两类。
2、第二类错误，Ⅱ型错误，接受了实际上不成立的H0 ，也就是错误地判为无差别，这类取伪的错误称为第二类错误，其概率用β表示。简单说就是：你的假设是错误，但你接受该假设。
“第一类错误”和“第二类错误”之间的关系：
1、当样本例数固定时，α愈小，β愈大；反之，α愈大，β愈小。因而可通过选定α控制β大小。要同时减小α和β，唯有增加样本例数。统计上将1-β称为检验效能或把握度(power of a test)，即两个总体确有差别存在，而以α为检验水准，假设检验能发现它们有差别的能力。实际工作中应权衡两类错误中哪一个重要以选择检验水准的大小。
2、做假设检验的时候会犯两种错误：第一，原假设是正确的，而你判断它为错误的；第二，原假设是错误的，而你判断它为正确的。我们分别称这两种错误为第一类错误(Type I error)和第二类错误(Type II error)。
第一类错误：原假设是正确的，却拒绝了原假设。
第二类错误：原假设是错误的，却没有拒绝原假设。
我们常把假设检验比作法庭判案，我们想知道被告是好人还是坏人。原假设是“被告是好人”，备择假设是“被告是坏人”。法庭判案会犯两种错误：如果被告真是好人，而你判他有罪，这是第一类错误(错杀好人)；如果被告真是坏人，而你判他无罪，这是第二类错误(放走坏人)。
记忆方法：我们可以把第一类错误记为“以真为假”，把第二类错误记为“以假为真”。当然我们也可以将第一类错误记为“错杀好人”，把第二类错误记为“放走坏人”。
在其他条件不变的情况下，如果要求犯第一类错误概率越小，那么犯第二类错误的概率就会越大。这个结论比较容易理解，当我们要求“错杀好人”的概率降低时，那么往往就会“放走坏人”。
同样的，在其他条件不变的情况下，如果要求犯第二类错误概率越小，那么犯第一类错误的概率就会越大。当我们要求“放走坏人”的概率降低时，那么往往就会“错杀好人”。同样的，在其他条件不变的情况下，如果要求犯第二类错误概率越小，那么犯第一类错误的概率就会越大。当我们要求“放走坏人”的概率降低时，那么往往就会“错杀好人”。
总结而言：I类错误和II类错误只是一个统计学上的概念，在进行假设检验时无法确定其发生的实际概率。由于两类错误主要受样本量的影响，因此可以通过增大样本量的方法，使得我们的抽样样本尽可能的接近总体，具有更好的代表性，以达到降低两类错误发生概率的目的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/249a804654e1aaad5842606f22a6f85b/" rel="bookmark">
			Android——六大基本布局总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本理论：
Android六大基本布局分别是：
线性布局LinearLayout
表格布局TableLayout
相对布局RelativeLayout
层布局FrameLayout
绝对布局AbsoluteLayout
网格布局GridLayout。
其中，表格布局是线性布局的子类。网格布局是android 4.0后新增的布局。
在手机程序设计中，绝对布局基本上不用，用得相对较多的是线性布局和相对布局。
（一）线性布局LinearLayout
线性布局在开发中使用最多，具有垂直方向与水平方向的布局方式，通过设置属性“android:orientation”控制方向，属性值垂直（vertical）和水平(horizontal)，默认水平方向。
android:gravity：内部控件对齐方式，常用属性值有center、center_vertical、center_horizontal、top、bottom、left、right等。
这个属性在布局组件RelativeLayout、TableLayout中也有使用，FrameLayout、AbsoluteLayout则没有这个属性。
center：居中显示，这里并不是表示显示在LinearLayout的中心，当LinearLayout线性方向为垂直方向时，center表示水平居中，但是并不能垂直居中，此时等同于center_horizontal的作用；同样当线性方向为水平方向时，center表示垂直居中，等同于center_vertical。
top、bottom、left、right顾名思义为内部控件居顶、低、左、右布局。
这里要与android:layout_gravity区分开，layout_gravity是用来设置自身相对于父元素的布局。
android:layout_weight：权重，用来分配当前控件在剩余空间的大小。
使用权重一般要把分配该权重方向的长度设置为零，比如在水平方向分配权重，就把width设置为零。
先来看一下效果：
下面来看看代码：
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/LinearLayout1" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="${relativePackage}.${activityClass}" &gt; &lt;EditText android:id="@+id/edit" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;!-- 第一线性布局 LinearLayout一定要设置方向 android:orientation 值:horizontal 元素水平摆放 | vertical 元素垂直摆放 android:gravity="right"设置对齐方式 --&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal" android:gravity="center" &gt; &lt;Button android:id="@+id/button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="确定"/&gt; &lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="取消" /&gt; &lt;/LinearLayout&gt; &lt;!-- 第二线性布局 --&gt; &lt;LinearLayout android:layout_width="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/249a804654e1aaad5842606f22a6f85b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2155ab446302e4c2517e4285b9020ce0/" rel="bookmark">
			七款酷炫的 Mac 屏保
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ankur Biswas 原作，授权 LeanCloud 翻译。
分享我最喜欢的一些 MacBook 屏保，让电脑看起来美美哒～
Padbury Clock Word Clock Simple Clock Grid Clock Fliqlo Fractal Clock Word Clock 如果喜欢这些屏保，可以和小伙伴分享！留言告诉我，哪个屏保是你的最爱？
LeanCloud，领先的 BaaS 提供商，为移动开发提供强有力的后端支持。更多内容点击 www.leancloud.cn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6888cc95a54ffa464264a30d0e9eb300/" rel="bookmark">
			R 语言 plyr包和reshape2包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4801c65176650269a3e69bb6a2025ba7/" rel="bookmark">
			Java语言程序设计与数据结构(梁勇版) 基础版 课后习题 第三章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.1
import java.util.Scanner; /** * 解一元二次方程 */ public class T3_1 { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print("Enter a,b,c:"); double a = scanner.nextDouble(); double b = scanner.nextDouble(); double c = scanner.nextDouble(); double d=b*b-4*a*c; if(d&gt;0){ double r1=(-b+Math.pow(d,0.5))/(2*a); double r2=(-b-Math.pow(d,0.5))/(2*a); System.out.println("The equation has two roots "+r1+" and "+r2); }else if(d==0){ double r=(-b)/(2*a); System.out.println("The equation has one root "+r); }else{ System.out.println("The equation has no real roots"); } } } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4801c65176650269a3e69bb6a2025ba7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa3d14144a883cf5eb892aa3227ae830/" rel="bookmark">
			正向代理和反向代理的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然正向代理服务器和反向代理服务器所处的位置都是客户端和真实服务器之间，所做的事情也都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端，但是二者之间还是有一定的差异的。
1、正向代理其实是客户端的代理，帮助客户端访问其无法访问的服务器资源。反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等。
2、正向代理一般是客户端架设的，比如在自己的机器上安装一个代理软件。而反向代理一般是服务器架设的，比如在自己的机器集群中部署一个反向代理服务器。
3、正向代理中，服务器不知道真正的客户端到底是谁，以为访问自己的就是真实的客户端。而在反向代理中，客户端不知道真正的服务器是谁，以为自己访问的就是真实的客户端。
4、正向代理和反向代理的作用和目的不同。正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。
转载于:https://www.cnblogs.com/eriwang/p/10518924.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f13929a569660c6b3a1cece323971fd/" rel="bookmark">
			先来先服务（FCFS）和短作业优先（SJF）调度算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来先服务调度算法 FCFS是最简单的调度算法，该算法即可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，系统将按照作业到达的先后次序来进行调度，或者说它是优先考虑在系统中等待时间长的作业，而不管该作业所需执行时间的长短，从后备作业队列中选择几个最优先进入该队列的作业，将它们调入内存，为他们分配资源和进程。然后把他放入就绪队列。
FCFS算法在单处理机系统中已经很少作为主调度算法，但经常把他与其他调度算法相结合使用，形成一个更为有效的算法。
短作业优先调度算法 由于在实际情况中，短作业（进程）占有很大的比例，但为了能使他们能比长作业优先执行，而产生了短作业优先调度算法。
1.短作业优先算法 SJF算法是以作业长短来计算优先级，作业越短，其优先级越高。作业的长短是以作业所要求的运行时间来衡量的。
2.短作业优先算法的缺点 SJF调度算法较之FCFS算法有了明显改进，但仍然存在许多缺点：
（1）必须预知作业的运行时间。
（2）对长作业非常不利，长作业的周转时间会明显的增长，有可能出饥饿现象。
（3）在采用SJF算法时，人机无法实现交互。
（4）该调度算法完全未考虑作业的紧迫程度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/056c1e80c4ec1a14324a30a0dbcc7d1a/" rel="bookmark">
			vs2017 .natvis 失效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.natvis文件用于调试时候自定义显示自定义类型的可视化提示。
一般这类文件存在
C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Common7\Packages\Debugger\Visualizers路径下。
.natvis文件的规则在此不介绍，详见官网：在调试器中创建本机对象的自定义视图
在natvis失效的时候，检查以下选项是否被勾选，如果是，则解除勾选
如果没勾选还是无法显示正确的自定义试图，则考虑是否natvis文件出错。
在此处选择详细，在debug的时候检查需要可视化的自定义类型，直接对日志搜索你的自定义类名如：“QString”。如果出现error，检查error项对应的问题。然后根据error更改对应的natvis文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98d984873267a7ff35ba7a7ca424dc8b/" rel="bookmark">
			make编译打印详细日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的是make V=1 具体如下： 命令描述make V=0quiet build (default)make V=1verbose buildmake V=2give reason for rebuild of target 举个例子 gaoliwendeMacBook-Pro:webrtc-audio-processing-0.3.1 gaoliwen$ make V=1 Making all in webrtc Making all in . /bin/sh ../libtool --tag=CXX --mode=compile g++ -DPACKAGE_NAME=\"webrtc-audio-processing\" -DPACKAGE_TARNAME=\"webrtc-audio-processing\" -DPACKAGE_VERSION=\"0.3.1\" -DPACKAGE_STRING=\"webrtc-audio-processing\ 0.3.1\" -DPACKAGE_BUGREPORT=\"\" -DPACKAGE_URL=\"\" -DPACKAGE=\"webrtc-audio-processing\" -DVERSION=\"0.3.1\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1 -DLT_OBJDIR=\".libs/\" -DHAVE_DECL___ARM_ARCH_ISA_ARM=0 -DHAVE_DECL___ARM_ARCH_7A__=0 -DHAVE_DECL___AARCH64__=0 -DHAVE_DECL___I386__=0 -DHAVE_DECL___X86_64__=1 -I. -std=c++11 -DWEBRTC_AUDIO_PROCESSING_ONLY_BUILD -DWEBRTC_POSIX -DWEBRTC_MAC -DWEBRTC_THREAD_RR -DWEBRTC_CLOCK_TYPE_REALTIME -DNDEBUG -I.. -g -O2 -MT libwebrtc_la-common_types.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98d984873267a7ff35ba7a7ca424dc8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d4a8129b6d625f5754db6983d0df2ed/" rel="bookmark">
			数据预测建模概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，输入变量可以是数值型或分类型，输出变量也可以是数值型或分类型。如果输出为分类型，则称为分类预测模型；反之，则为回归预测模型。 2，一般拿到的数据为一个矩阵，一行对应一个观测，一列对应一个变量。一般自变量（解释变量）会有多个（x1, x2, …, xp），因变量（被解释变量）只有一个（y）。在预测过程中可以看成是发生在p+1为空间中的事件。 3，建模过程其实就在找p个x与一个y之间的关系，并将这种关系用一个模型表示出来（线性或非线性）。模型确定后，对于给定的新的p个x值，就可以预测出 y ^ \hat{y} y^​。 4，对于分类预测模型，实际上是找到p维的超平面，使得位于超平面同侧的点更接近；而对于回归预测模型，也要找到一个p维的超平面，使得预测得到的值位于这个超平面上。 5，对分类预测模型的评价 ROC曲线是很好的评价方式，参考ROC曲线。
TPR(真阳性率) = TP/(TP+FN)，也叫查全率、敏感性；
FPR(假阳性率) = FP/(FP+TN) = 1 - TN/(FP+TN)，其中TN/(FP+TN)叫做真阴性率，又叫特异性；
查准率 = TP/(TP+FP)；
由于查准率（Precision）和查全率（Recall）无法同时大，可以基于查准率和查全率的调和平均数定义F1值，F1越大预测结果越准确。
1/F1 = 1/2 * (1/Precision + 1/Recall)，即 F 1 = 2 ∗ P ∗ R / ( P + R ) F1 = 2*P*R/(P+R) F1=2∗P∗R/(P+R)；
准确性(Accuracy) = (TP+TN)/(TP+TN+FP+FN)
6，对回归预测模型的评价 可以计算均方误差去评价回归模型：
其实在进行回归建模时，就是要找到一系列参数使得均方平方和最小。
7，统计建模、机器学习与深度学习 7.1 统计建模数据量一般小，机器学习和深度学习大；
7.2 统计建模对模型的关注度更大，先假定数据的概率分布，再选择模型，接着对参数进行估计，然后对数据进行解释；而机器学习更关注从数据到数据的预测准确性，选定好算法后，不断优化参数，使模型达到理想结果；深度学习更像是一个黑匣子，喂给它数据，它能自己学习出最佳的参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9efe2f652fa135b0cb8feebe77b0972/" rel="bookmark">
			spring cloud config因jar包版本原因导致失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring boot、spring cloud 框架搭建，遇到的坑，以下全文是异常日志：
:: Spring Boot :: (v2.0.7.RELEASE)
03-11 17:04:41.724[INFO ][ main][c.s.c.ConfigStartup ][ 658]: The following profiles are active: native
03-11 17:04:41.755[INFO ][ main][ConfigServletWebServerApplicationContext][ 588]: Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@2654635: startup date [Mon Mar 11 17:04:41 CST 2019]; parent: org.springframework.context.annotation.AnnotationConfigApplicationContext@11bd0f3b
03-11 17:04:43.234[ERROR][ main][o.s.b.SpringApplication ][ 837]: Application run failed
java.lang.IllegalStateException: Error processing condition on org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.authenticationEventPublisher
at org.springframework.boot.autoconfigure.condition.SpringBootCondition.matches(SpringBootCondition.java:64)
at org.springframework.context.annotation.ConditionEvaluator.shouldSkip(ConditionEvaluator.java:108)
at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForBeanMethod(ConfigurationClassBeanDefinitionReader.java:181)
at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForConfigurationClass(ConfigurationClassBeanDefinitionReader.java:142)
at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitions(ConfigurationClassBeanDefinitionReader.java:118)
at org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:328)
at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:233)
at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:271)
at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9efe2f652fa135b0cb8feebe77b0972/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dac2631cb1d84b14bc8b8882035b4451/" rel="bookmark">
			图像处理小白之图像处理一般步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：是否为彩色图片（假设：是）
第二步：转为灰度图像
第三步：通过灰度阀值寻找区域
第四步：通过特征点提取，提取固定区域
第五步：对提取的区域做处理，例如填充区域，膨胀，开操作等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a514c9ea37758c7a57d1a63c9d69497e/" rel="bookmark">
			深度相机原理揭秘之飞行时间法（TOF）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，未经博主允许不得转载。违者必究。	https://blog.csdn.net/electech6/article/details/78349107	&lt;/div&gt; &lt;link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"&gt; &lt;div class="htmledit_views" id="content_views"&gt; 本文已经首发在个人微信公共号：计算机视觉life（微信号CV_life），欢迎关注！
深度相机按照深度测量原理不同，一般分为：飞行时间法、结构光法、双目立体视觉法。本文就来说一说飞行时间法。
飞行时间是从Time of Flight直译过来的，简称TOF。其基本原理是通过连续发射光脉冲（一般为不可见光）到被观测物体上，然后接收从物体反射回去的光脉冲，通过探测光脉冲的飞行（往返）时间来计算被测物体离相机的距离。
TOF法根据调制方法的不同，一般可以分为两种：脉冲调制（Pulsed Modulation）和连续波调制（Continuous Wave Modulation）。
飞行时间法深度测量基本原理示意图
脉冲调制
脉冲调制方案的原理比较简单，如下图所示。它直接根据脉冲发射和接收的时间差来测算距离。
光脉冲法工作原理示意图
脉冲调制方案的照射光源一般采用方波脉冲调制，这是因为它用数字电路来实现相对容易。接收端的每个像素都是由一个感光单元（如光电二极管）组成，它可以将入射光转换为电流，感光单元连接着多个高频转换开关（下图的G0，G1）可以把电流导入不同的可以储存电荷(下图S0，S1)的电容里。
相机上的控制单元打开光源然后再关闭，发出一个光脉冲。在同一时刻，控制单元打开和关闭接收端的电子快门。接收端接收到的电荷S0被存储在感光元件中。
然后，控制单元第二次打开并关闭光源。这次快门打开时间较晚，即在光源被关闭的时间点打开。新接收到的电荷S1也被存储起来。具体过程如下图所示。
因为单个光脉冲的持续时间非常短，此过程会重复几千次，直到达到曝光时间。然后感光传感器中的值会被读出，实际距离可以根据这些值来计算。
记光的速度为c，tp为光脉冲的持续时间， S0表示较早的快门收集的电荷， S1表示延迟的快门收集的电荷，那么距离d可以由如下公式计算：
最小的可测量距离是：在较早的快门期间S0中收集了所有的电荷，而在延迟的快门期间S1没有收集到电荷，即S1 = 0。代入公式会得出最小可测量距离d=0。
最大的可测量的距离是：在S1中收集了所有电荷，而在S0中根本没有收集到电荷。然后，该公式得出d= 0.5 x c × tp。因此最大可测量距离是通过光脉冲宽度来确定的。例如，tp = 50 ns，代入上式，得到最大测量距离d = 7.5m。
优点：
测量方法简单，响应较快
由于发射端能量较高，所以一定程度上降低了背景光的干扰
缺点：
发射端需要产生高频高强度脉冲，对物理器件性能要求很高
对时间测量精度要求较高
环境散射光对测量结果有一定影响
连续波调制
实际应用中，通常采用的是正弦波调制。由于接收端和发射端正弦波的相位偏移和物体距离摄像头的距离成正比(见后面推导)，因此可以利用相位偏移来测量距离。
连续波调制原理示意图
连续波调制的测量原理相对脉冲调制来说复杂一些，我们以最常用的连续正弦波调制来推导一下测量的原理。
连续正弦波调制测量方法示意图
连续正弦波调制测量方法，具体的推导过程如下。序号1-9对应下图的公式1-9。
假设发射的正弦信号s(t)振幅是a，调制频率是f
经过时延 △t后接收到的信号为接收r(t)，衰减后的振幅为A，强度偏移（由环境光引起）为B
四个采样时间间隔相等，均为T/4
根据上述采样时间可以列出四个方程组
从而可以计算出发射和接收的正弦信号的相位偏移△φ
据此可以根据（6）中公式计算物体和深度相机的距离d
接收信号的衰减后的振幅A的计算结果
接收信号强度偏移B的计算结果，反映了环境光
A, B的值间接的反应了深度的测量精度，深度测量方差可以用公式9近似表示。
连续正弦波调制公式推导
优点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a514c9ea37758c7a57d1a63c9d69497e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6763791854ea444cac9997ec8730b72d/" rel="bookmark">
			Oracle修改表或者字段的注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://www.cnblogs.com/fx-blog/p/7132833.html
语句：
comment on table 表名 is '表的注释信息'; comment on column 表名.字段名 is '字段的注释信息';
注意表名的大小写
例如：
1、创建表：
CREATE TABLE Student(
id varchar2(32) primary key,
name varchar2(8) not null,
age number
);
2、添加表注释：
Comment on table Student is '个人信息';
修改表注释：
Comment on table Student is '学生个人信息';
3、添加字段注释：
comment on column Student.id is 'id';
comment on column Student.name is '姓名';
comment on column Student.age is '年龄';
修改字段注释：
comment on column Student.id is '学生id';
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6763791854ea444cac9997ec8730b72d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/006b02618b5c39420277ee7bca3bf301/" rel="bookmark">
			go语言实现--二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。
二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有 2^{i-1} 个结点；深度为k的二叉树至多有2^k-1个结点；对任何一棵二叉树T，如果其终端结点数为n_0，度为2的结点数为n_2，则n_0=n_2+1（百度百科）。
二叉树有多种：
(1)完全二叉树——叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作完全二叉树。
(2)满二叉树——叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作满二叉树，他是一种特殊的完全二叉树。
(3)平衡二叉树——具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。
一般二叉树性质：
性质1：二叉树第i层上的结点数目最多为 2^{i-1} (i≥1)。
性质2：深度为k的二叉树至多有2^{k}-1个结点(k≥1)。
性质3：包含n个结点的二叉树的高度至少为log2 (n+1)。
性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1。
完全二叉树性质:
具有n个节点的完全二叉树的高度k为[log2n]+1对于具有n个节点的完全二叉树,如果按照从上(根节点)到下(叶节点)和从左到右的顺序对二叉树中的所有节点从0开始到n-1进行编号,则对于任意的下标为k的节点，有：
• 如果k=0,则它是根节点，它没有父节点；如果k&gt;0,则它的父节点的下标为[(i-1)/2];
• 如果2k+1 &lt;= n-1,则下标为k的节点的左子结点的下标为2k+1;否则,下标为k的节点没有左子结点.
• 如果2k+2 &lt;= n-1,则下标为k的节点的右子节点的下标为2k+2;否则,下标为k的节点没有右子节点 满二叉树性质:
在满二叉树中，叶节点的个数比分支节点的个数多1
二叉树遍历
1、前序遍历（与树的前序遍历一样）
基本思想：先访问当前结点，再前序遍历左子树，最后再前序遍历右子树即根—左—右。
图中前序遍历结果是：1，2，4，5，7，8，3，6
2、中序遍历
基本思想：先中序遍历左子树，然后再访问当前结点，最后再中序遍历右子树即左—根—右。
图中中序遍历结果是：4，2，7，8，5，1，3，6
3、后序遍历
基本思想：先后序遍历左子树，然后再后序遍历右子树，最后再访问当前结点即左—右—根。
图中后序遍历结果是：4，8，7，5，2，6，3，1
4、层次遍历（与树的层次遍历一样）
基本思想：从第一层开始，依此遍历每层，直到结束。
图中层次遍历结果是：1，2，3，4，5，6，7，8
例子：
对上图的二叉树遍历做一个go语言的实现，代码如下：
package main import ( "fmt" ) type Node struct { Value int Left, Right *Node } func (node *Node) Print() { fmt.Print(node.Value, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/006b02618b5c39420277ee7bca3bf301/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc058c19ccc02ec09944b645b87d8c82/" rel="bookmark">
			如何用github和typora打造自己的云笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 缘起 从2016年冬季开始，我就有了看书会记些笔记的习惯，在比对了各个软件之后，选定了有道云笔记。主要看中了：1.免费；2.跨多个平台（手机、mac、windows）；3.可以用markdown写。
这几年用下来，确实也还不错。但总有一些让我不满意的地方，一是有时候卡顿严重，几乎无法书写；二是笔记的版本管理，我在mac上使用时，查看笔记的版本，虽然软件提供了比对近30天版本的功能，但是我发现各版本的区别就是0和1的区别（下图显示3-5号和3-3号两版本没任何改动，但其实我本身是有改动的）；三是我怕某天笔记倒闭了我这几年的笔记就得一个一个慢慢下载下来了，十分被动；最后一点就是有道云笔记支持不了本地图片添加到markdown里面；
所以渐渐地，我也有了把笔记上传github的想法。可是彼时github私有仓库是收费的，而我又不想私密的笔记公开，所以就作罢。但是现在不一样了，github私有仓库免费了，所以我也开始着手自己的转移工作。
所需工具 git，官网传送门：点我 开源的分布式版本控制系统 Typora，官网传送门：点我 Typora是一个本地的markdown编辑工具，支持Windows/Mac/Linux三大系统 步骤 1. 建立自己的github私有仓库 进入github官网，在个人仓库页面，新建私人仓库。
2. 克隆到本地 然后进入项目页面，克隆仓库到本地。
3. 设置Typora 主要就是开启Typora的文件树视图。
然后打开你的仓库。
之后所有的新建文件、目录操作都可以在文件树视图里面进行，不小心关闭了软件，只需要打开最近打开的文件，目录树自动就加载出来了。
总结 优点 本地图片放到同级目录下，就可以使用相对路径引入，在本地看笔记很方便。所有笔记都在本地，同步到github，具有版本控制。本地编辑，十分流畅。 缺点 同步github比较麻烦，需要自己提交至github。（可以自己写个crontab命令进行定时检测仓库变动，然后上传github）笔记的分享功能没有了。（这个我个人的解决方式是发布到ubuntu pastebin进行分享，本来是想推荐gist的，结果被墙了=。=) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4708a2479c765cef2afd8094e08a269/" rel="bookmark">
			HttpPost 上传文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * Project Name:testHttpClient * File Name:ClientMultipartFormPost.java * Package Name:com.test.httpclient * Date:2016年12月28日下午4:01:59 * Copyright (c) 2016, 77493077@qq.com All Rights Reserved. * */ package com.test.httpclient; import java.io.File; import java.io.IOException; import java.nio.charset.Charset; import org.apache.http.Consts; import org.apache.http.HttpEntity; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpPost; import org.apache.http.entity.ContentType; import org.apache.http.entity.mime.HttpMultipartMode; import org.apache.http.entity.mime.MultipartEntityBuilder; import org.apache.http.entity.mime.content.FileBody; import org.apache.http.entity.mime.content.StringBody; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.util.EntityUtils; /** * ClassName:ClientMultipartFormPost &lt;br/&gt; * Function: TODO ADD FUNCTION. &lt;br/&gt; * Reason:	TODO ADD REASON. &lt;br/&gt; * Date: 2016年12月28日 下午4:01:59 &lt;br/&gt; * @author ZengZhuo(lenovo) * @version * @since JDK 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4708a2479c765cef2afd8094e08a269/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60900089b476469fbc33f8d02f4bdb5a/" rel="bookmark">
			NTFS、FAT、ExFAT的优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FAT32文件系统
FAT32文件系统优点：突破了FAT对每一个分区的容量只有2GB的限制，可以支持大到2TB（2048G）的分区。在不超过8GB的分区容量下，每个簇的容量都固定为4KB，与FAT16相比，可以大大减少磁盘的浪费，提高磁盘利用率。
FAT32文件系统缺点：用 FAT32格式分区的磁盘，由于文件分配表的扩大，运行速度比采用FAT16格式分区的磁盘要慢，且DOS系统和某些早期的应用软件不支持这种分区格式。 另外还有一个致命的缺点让FAT32逐渐被淘汰，这就是FAT32的单个文件最大只能支持4GB。现在已经进入高清时代，720P和1080P高清视频文 件都很容易超过4GB，因此FAT32已经走向没落。
NTFS文件系统
NTFS文件系统优点：NTFS分区具有极高的安全性和稳定性，在使用中不易产生文件碎片。它能对用户的操作 进行记录，通过对用户权限进行非常严格的限制，使每个用户只能按照系统赋予的权限进行操作，充分保护了系统与数据的安全。另外对大部分用户而言，NTFS 最直观的优点是，单个文件的大小突破了FAT32的4GB的限制。
NTFS文件系统缺点：NTFS虽然有诸多优点，但这些都是针对传统机械硬盘而设计的，对于新兴的Flash 闪存材料不一定适用。NTFS分区是采用“日志式”的文件系统，因为要记录磁盘的详细读写操作，对U盘这种闪存储介质会造成较大的负担，比如同样存取一个 文件或目录，在NTFS系统上的读写次数就会比FAT32来得多，理论上NTFS格式的U盘比较容易损坏，而且400MB以下的分区也比FAT16更浪费 空间。
ExFAT文件系统
exFAT文件系统优点：分区大小和单文件大小最大可达16EB（16×1024×1024TB）；簇大小非 常灵活，最小0.5KB，最高达32MB；采用了剩余空间分配表，空间利用率更高；同一目录下最大文件数可达65536个；支持访问控制；支持 TFAT(WINCE早期文件系统)。可以看出，ExFAT就是闪存专用的文件系统，只有U盘和存储卡才能格式化成exFAT，传统硬盘是无法格式化成 exFAT格式的，因为exFAT的特性其实并不比NTFS强，但却比NTFS及FAT32更适合闪存使用。
exFAT文件系统缺点：exFAT作为一种全新的文件系统，在电脑上的兼容性却不太好，目前主流的XP和Vista默认都不支持ExFAT，XP需升级至SP3补丁、Vista需升级至SP1补丁才能支持它。当然微软也提供了exFAT的单独更新文件，Win7默认支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddd120eecc1c74ad395786492ecc5e14/" rel="bookmark">
			给你三个线程，如何让它们交替打印1、2、3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题提出 前几天写了一篇 Java多线程：写一下两个线程交替打印 0~100 的奇偶数 介绍了如果用 wait/notify 控制两个线程交替执行，最后留了一个扩展问题：有三个线程，要求让它们交替输出 1、2、3，打印内容如下：
线程1：1 线程2：2 线程3：3 线程1：1 线程2：2 线程3：3 …… 该如何实现？
分析 沿用两个线程的交替打印的思路，重点是当第一个线程获取到锁的时候第二个线程在wait状态等待被唤醒，此时第一个线程完成任务时，主动唤醒第二个线程，自己进入等待状态，不与之竞争。这样就能起到“我做完轮到你，你做完轮到我”的状态。
而三个线程的情况下是无法简单通过一个锁来完成的，因为当多个线程在等待时，我们无法通过 notify 来唤醒指定的线程。如何解决呢？
解决 我们可以使用三个锁 lock1、lock2 和 lock3，分别对应要执行的三个线程 t1、t2 和 t3。
当前线程t1执行时，先锁定下一个线程t2对应的锁 lock2，然后再获取自己线程对应的锁 lock1，当两个锁都拿到时才打印，并唤醒在等待 lock1 的线程t3，退出 lock1 的同步代码块，释放 lock1，此时 t3 拿到 lock1，等待获取 lock3（lock3 在启动时就被 t2 占了）。之后释放 lock2 让 t2 进入执行状态自己进入等待 lock2 被唤醒，此时线程进行等待状态，以免进入下一次循环与 t2 竞争 lock2。
t2 也是相同的逻辑，唤醒等待 lock2 的 t1，此时 t1 才从上次循环中退出再次获取 lock2，然后释放 lock3, 让 t3 进入执行状态。
最终的目的就是要实现三个线程相互等待前面两个线程执行完，形成一个循环。
private int count = 0; private final Object lock1 = new Object(); private final Object lock2 = new Object(); private final Object lock3 = new Object(); public static void main(String[] args) throws InterruptedException { new MultiTurningThread().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddd120eecc1c74ad395786492ecc5e14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b972cf285edadf17fbdb1dbee0cd94/" rel="bookmark">
			海量数据处理：1G大小的一个文件中找出出现频率最高的100个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.题目描述 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M，要求返回频数最高的100个词
2.思考过程 （1）参见我的其他大数据面试题博文。此处1G文件远远大于1M内存，分治法，先hash映射把大文件分成很多个小文件，具体操作如下：读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件(记为f0,f1,...,f4999)中，这样每个文件大概是200k左右（每个相同的词一定被映射到了同一文件中）
（2）对于每个文件fi，都用hash_map做词和出现频率的统计，取出频率大的前100个词（怎么取？topK问题，建立一个100个节点的最小堆），把这100个词和出现频率再单独存入一个文件
（3）根据上述处理，我们又得到了5000个文件，归并文件取出top100（Top K 问题，比较最大的前100个频数）
堆排序找Top K 借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。即借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。所以，我们最终的时间复杂度是：O（N） + N' * O（logK），（N为1000万，N’为300万）。
总结： 要解决该问题首先要进行分类，把重复出现的IP都放到一个文件里面，一共分成100份，这可以通过把IP对100取模得到，具体方法如把IP中的点转化为整型long型变量，这样取模为0,1,2...99的IP都分到一个文件了，但是要考虑一个问题，如果某个文件的IP取余之后还是特别多无法放入内存中，可以再对这一类IP做一次取模，直到每个小文件足够载入内存为止。这个分类很关键，如果是随便分成100份，相同的IP被分在了不同的文件中，接下来再对每个文件统计次数并做归并，这个思路就没有意义了，起不到“大而化小，各个击破，缩小规模，逐个解决”的效果了。
接下来把每个小文件载入内存，建立哈希表将每个IP作为关键字映射为出现次数，这个哈希表建好之后也得先写入硬盘，因为内存就那么多，一共要统计100个文件。
在统计完100个文件之后，我再建立一个小顶堆，大小为100，把建立好并存在硬盘哈希表载入内存，逐个对出现次数排序，挑出出现次数最多的100个，由于次数直接和IP是对应的，找出最多的次数也就找出了相应的IP。
所以海量数据面前要多采用分治算法，化整为零 各个击破！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75fe8f01d3018e5af2d7cec671750a12/" rel="bookmark">
			【深度学习】CNN原理和全卷积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CNN原理、介绍一下CNN？ 【深度学习系列】卷积神经网络CNN原理详解(一)——基本原理
卷积神经网络CNN总结
CNN总结
为什么要将全连接替换成全卷积？替换成全卷积的好处是什么？ 网络一大堆啰里啰嗦的。。。
首先明确一点，全连接是一种特殊的卷积层，只要将卷积核尺寸同输入w*h保持相同，channel个数同全连接的neural个数。
第一点好处：加速前向传播速度，因为卷积核在每个特征图上的计算是并行的；第二点好处：在图像问题中，全卷积可以不限制输入图像的大小，适用范围更大，但是全连接要保证输入图像保持一致的大小。 第三点好处：因为卷积具有尺度不变性，全连接没有。 1*1卷积层可以看成全连接层，其中空间维度高和宽上的每个元素相当于样本，通道相当于特征。
全连接层的作用：可以将卷积得到的局部特征连接起来，综合考虑整个图像。
全连接层的坏处：会破坏图像的空间结构，因此人们便开始用卷积层来“代替”全连接层，通常采用1×1的卷积核，这种不包含全连接的CNN成为全卷积神经网络FCN。
全连接层的输入尺寸是固定的，卷积层的输入尺寸是任意的。
为什么将全连接层替换为卷积层？
为什么用1*1卷积层代替全连接层？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4991cbbfd541bfe96358e67233b262c0/" rel="bookmark">
			海量数据处理：两个大文件中的相同记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.题目描述
给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url?
2.思考过程
（1）首先我们最常想到的方法是读取文件a，建立哈希表（为什么要建立hash表？因为方便后面的查找），然后再读取文件b，遍历文件b中每个url，对于每个遍历，我们都执行查找hash表的操作，若hash表中搜索到了，则说明两文件共有，存入一个集合。
（2）但上述方法有一个明显问题，加载一个文件的数据需要50亿*64bytes = 320G远远大于4G内存，何况我们还需要分配哈希表数据结构所使用的空间，所以不可能一次性把文件中所有数据构建一个整体的hash表。
（3）针对上述问题，我们分治算法的思想。
step1：遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件(记为a0,a1,...,a999，每个小文件约300M)，为什么是1000？主要根据内存大小和要分治的文件大小来计算，我们就大致可以把320G大小分为1000份，每份大约300M（当然，到底能不能分布尽量均匀，得看hash函数的设计）
step2：遍历文件b，采取和a相同的方式将url分别存储到1000个小文件(记为b0,b1,...,b999)（为什么要这样做? 文件a的hash映射和文件b的hash映射函数要保持一致，这样的话相同的url就会保存在对应的小文件中，比如，如果a中有一个url记录data1被hash到了a99文件中，那么如果b中也有相同url，则一定被hash到了b99中）
所以现在问题转换成了：找出1000对小文件中每一对相同的url（不对应的小文件不可能有相同的url）
step3：因为每个hash大约300M，所以我们再可以采用（1）中的想法
所以海量数据面前要多采用分治算法，化整为零 各个击破！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/728d2c432c61a041ff6b31c5e0794c7e/" rel="bookmark">
			Hutool好用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hutool是一个Java工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，让Java语言也可以“甜甜的”。Hutool最初是我项目中“util”包的一个整理，后来慢慢积累并加入更多非业务相关功能，并广泛学习其它开源项目精髓，经过自己整理修改，最终形成丰富的开源工具集。
Hutool是Hu + tool的自造词，谐音“糊涂”，寓意追求“万事都作糊涂观，无所谓失，无所谓得”的境界。
https://www.hutool.cn/docs/#/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4481d3ca9c1a12af36bdca0034892cb5/" rel="bookmark">
			国内最火的10款Java开源项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国内的开源环境已经相当好，但是国内开发注重是应用，创新有但不多，从榜单可以看出，专门搞技术的还是少数，结合项目实践的站大多数，分享给你们，架构的时候可以参考这些解决方案，
zheng征项目(stars 5.6k)
基于Spring+SpringMVC+Mybatis分布式敏捷开发系统架构，提供整套公共微服务服务模块：集中权限管理（单点登录）、内容管理、支付中心、用户管理（支持第三方登录）、微信平台、存储系统、配置中心、日志分析、任务和通知等，支持服务治理、监控和追踪，努力为中小型企业打造全方位J2EE企业级开发解决方案。
地址：https://gitee.com/shuzheng/zheng
JFinal(stars 4.8k)
JFinal 是基于 Java 语言的极速 WEB + ORM 框架，其核心设计目标是开发迅速、代码量少、学习简单、功能强大、轻量级、易扩展、Restful。在拥有Java语言所有优势的同时再拥有ruby、python、php等动态语言的开发效率！为您节约更多时间，去陪恋人、家人和朋友 :)
地址：http://www.jfinal.com/
SpringBoot-Learning(stars 4.6k)
Spring Boot教程与Spring Cloud教程
地址：https://gitee.com/didispace/SpringBoot-Learning
iBase4J(stars 4.1k)
AVA分布式快速开发平台：SpringBoot，SpringMVC，Mybatis，mybatis-plus，motan/dubbo分布式，Redis缓存，Shiro权限管理，Spring-Session单点登录，Quartz分布式集群调度，Restful服务，QQ/微信登录，App token登录，微信/支付宝支付；日期转换、数据类型转换、序列化、汉字转拼音、身份证号码验证、数字转人民币、发送短信、发送邮件、加密解密、图片处理、excel导入导出、FTP/SFTP/fastDFS上传下载、二维码、XML读写、高精度计算、系统配置工具类等等。
地址：https://gitee.com/iBase4J/iBase4J
JeeSite(stars 3.1k)
JeeSite 是一个企业信息化开发基础平台，Java EE（J2EE）快速开发框架，使用经典技术组合（Spring、Spring MVC、Apache Shiro、MyBatis、Bootstrap UI），包括核心模块如：组织机构、角色用户、权限授权、数据权限、内容管理、工作流等。
地址：https://gitee.com/thinkgem/jeesite
jeewx(stars 2.6k)
Jeewx是一款开源、免费的微信管家系统（多触点管理平台）。采用JAVA语言，支持微信公众号、微信企业号、支付宝服务窗、QQ公众号、微博账号等多触点管理。Jeewx实现了微信、支付窗、微信企业号、微博等触点的基础管理功能，便于用户二次开发。2014年荣获CSDN开发商大会第一名
地址：https://gitee.com/jeecg/jeewx
MCMS建站系统（stars 2.5k）
完整开源！Java快速开发平台！基于Spring、SpringMVC、Mybatis架构，MStore提供更多好用的插件与模板（文章、商城、微信、论坛、会员、评论、支付、积分、工作流、任务调度等，同时提供上百套免费模板任意选择），价值源自分享！铭飞系统不仅一套简单好用的开源系统、更是一整套优质的开源生态内容体系。铭飞的使命就是降低开发成本提高开发效率，提供全方位的企业级开发解决方案，每月28定期更新版本
地址：https://gitee.com/mingSoft/MCMS
t-io(stars 2.3k)
t-io是基于jdk aio实现的易学易用、稳定耐操、性能强悍、将多线程运用到极致、内置功能丰富、核心代码只有3000多行(2017年05月13号统计)的即时通讯框架(广义上的即时通讯，并非指im)，字母 t 寓意talent。
地址：https://gitee.com/tywo45/t-io
CMS(stars 2.1k)
一款使用Java语言开发的CMS，使用了Spring MVC,Spring,MyBatis等流行框架，提供首页大图管理、目录管理、文章管理和管理员管理等功能。是学习和二次开发的首选
地址：https://gitee.com/shishuo/CMS
hutool(stars 2k)
一个Java基础工具类，对文件、流、加密解密、转码、正则、线程、XML等JDK方法进行封装，组成各种Util工具类，同时提供以下组件： 1. 布隆过滤 2. 缓存 3. 数据库ORM（基于ActiveRecord思想）4. HTTP客户端 5. IO 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4481d3ca9c1a12af36bdca0034892cb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a33a645a7c942eecb7459b293e5b2dc2/" rel="bookmark">
			springboot ajax 跨域请求导致sessionId 不一致 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先处理跨域问题
springboot 有处理跨域的注解@CrossOrigin
这样已经可以处理跨域请求，但session并不共享
注解修改如下：
@CrossOrigin(allowCredentials="true",allowedHeaders="*") 同时前端js ajax部分加入： xhrFields:{
withCredentials:true
},
function ajaxtest(){ var url = "http://10.11.64.198:8888/t"; $.ajax({ url: url, type: 'POST', async:true, xhrFields:{ withCredentials:true }, success: function(respon){ }, error: function(){ alert('服务器发生错误！'); } }); } 完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efb1a9ff71fcbcb4b444b44a4d9e0e0e/" rel="bookmark">
			c语言基础--ASCII码表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ASCII控制字符 二进制十进制十六进制缩写可以显示的表示法名称/意义0000 0000000NUL␀空字符（Null）0000 0001101SOH␁标题开始0000 0010202STX␂本文开始0000 0011303ETX␃本文结束0000 0100404EOT␄传输结束0000 0101505ENQ␅请求0000 0110606ACK␆确认回应0000 0111707BEL␇响铃0000 1000808BS␈退格0000 1001909HT␉水平定位符号0000 1010100ALF␊换行键0000 1011110BVT␋垂直定位符号0000 1100120CFF␌换页键0000 1101130DCR␍归位键0000 1110140ESO␎取消变换（Shift out）0000 1111150FSI␏启用变换（Shift in）0001 00001610DLE␐跳出数据通讯0001 00011711DC1␑设备控制一（XON 启用软件速度控制）0001 00101812DC2␒设备控制二0001 00111913DC3␓设备控制三（XOFF 停用软件速度控制）0001 01002014DC4␔设备控制四0001 01012115NAK␕确认失败回应0001 01102216SYN␖同步用暂停0001 01112317ETB␗区块传输结束0001 10002418CAN␘取消0001 10012519EM␙连接介质中断0001 1010261ASUB␚替换0001 1011271BESC␛跳出0001 1100281CFS␜文件分割符0001 1101291DGS␝组群分隔符0001 1110301ERS␞记录分隔符0001 1111311FUS␟单元分隔符0111 11111277FDEL␡删除 ASCII可显示字符 二进制十进制十六进制图形0010 00003220（空格）(␠)0010 00013321!0010 00103422"0010 00113523#0010 01003624$0010 01013725 %0010 01103826&amp;0010 01113927'0010 10004028(0010 10014129)0010 1010422A*0010 1011432B+0010 1100442C,0010 1101452D-0010 1110462E.0010 1111472F/0011 0000483000011 0001493110011 0010503220011 0011513330011 0100523440011 0101533550011 0110543660011 0111553770011 1000563880011 1001573990011 1010583A:0011 1011593B;0011 1100603C&lt;0011 1101613D=0011 1110623E&gt;0011 1111633F?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efb1a9ff71fcbcb4b444b44a4d9e0e0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2b7a1df85c620f558816057c7277115/" rel="bookmark">
			Mybatis简介和优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是Mybatis？
Mybatis是一个半自动的ORM持久层框架，内部封装了JDBC。作为开发者只需要关注sql语句本身。Mybatis是通过xml或注解的方式将需要执行的各种statement配置起来。通过Java对象和statement中的sql动态参数映射生成最终执行的sql语句，最终由Mabtais框架执行sql并将结果映射为Java对象并返回。MyBatis 支持定制化 SQL、存储过程以及高级映射。MyBatis 是可以双向映射的，可以将数据集映射为Java对象，也可以将Java对象映射为数据库中的记录。
二、Mybait的优点：
（1）简单易学，容易上手（相比于Hibernate） 基于SQL编程；（2）JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；（3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持，而JDBC提供了可扩展性，所以只要这个数据库有针对Java的jar包就可以就可以与MyBatis兼容），开发人员不需要考虑数据库的差异性。（4）提供了很多第三方插件（分页插件 / 逆向工程）；（5）能够与Spring很好的集成；（6）MyBatis相当灵活，不会对应用程序或者数据库的现有设计强加任何影响，SQL写在XML里，从程序代码中彻底分离，解除sql与程序代码的耦合，便于统一管理和优化，并可重用。（7）提供XML标签，支持编写动态SQL语句。（8）提供映射标签，支持对象与数据库的ORM字段关系映射。（9）提供对象关系映射标签，支持对象关系组建维护。 三、MyBatis框架的缺点：
（1）SQL语句的编写工作量较大，尤其是字段多、关联表多时，更是如此，对开发人员编写SQL语句的功底有一定要求。（2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39b3c04e8b693aded126d641d338a227/" rel="bookmark">
			结构体的长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在32位里：
typedef struct {
unsigned char haha; \\4
unsigned int huhu; \\4
unsigned short wuha; \\4
}One_DEF;
typedef struct
{
unsigned char wowo; \\4
One_DEF wuwu; \\12
unsigned short wawi; \\4
unsigned int hah; \\4
}Two_DEF;
其中一个结构体在另一个结构体中，其会默认为一个单位，即Two_DEF的sizeof无法将其扩张开来看：
typedef struct
{
unsigned char wowo; \\4
unsigned char haha; \\4
unsigned int huhu; \\4
unsigned short wuha; \\4
unsigned short wawi; \\4
unsigned int hah; \\4
}
无法通过展开如上所示进行计算长度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37c907b4217bb8ddc44fd70035bb5197/" rel="bookmark">
			discuz bug:Deprecated: __autoload() is deprecated, use spl_autoload_register()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Deprecated: __autoload() is deprecated, use spl_autoload_register()
解决：可能原因PHP版本过高，亲测discuz3.4版本使用php7.2.10会出现此bug，更换到php7.1以下就可以
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/706d3c14dc5ee0bfea427a0853beb81f/" rel="bookmark">
			word文档受损打不开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天下午朋友拜托我把百度文库的文章拷贝下来转换成word，我用冰点文库下载，于是有了它的 pdf 版和 txt版。
虽然txt版可以直接转换成word文档打开，但是不是我的想要 的效果，缺失了不少信息。
于是我在线将 pdf 转换成 word文档，预览是自己要的效果，于是下载打开。结果出现以下问题：
我按照它的提示一一进行尝试，都解决不了问题。经过百度搜索，发现解决方式都是word提供的解决方式里面有的，帮助不了我。下载软件来解决这个问题，我个人觉得没那个必要，而且可不可靠还两说。
(ಡωಡ)hiahiahia 然后然后，突然想到直接将受损打不开的word文档后缀改为 “.txt” ，再将该文本用word打开，这时候将文本另存为，再打开word 文档就没问题了。
开心~~~ 希望这个做法可以帮到大家呀~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f415a03390243a1207afdd20ccb186a/" rel="bookmark">
			python&#43;opencv多进程实现识别魔方颜色，通过kociemba算法得出算法字符串并画图（附毕设完整视频）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整毕设成果视频如下：
本科毕业设计转魔方（声音略大）
python+opencv本科毕业设计转魔方（声音略大） 上一篇博客已经给大家讲了鼠标hsv获取魔方颜色阈值方法，具体见 python+opencv 识别魔方照片块颜色并可鼠标获取目标区域hsv值 本次给大家讲讲识别的整套流程（其实是从github上扒下来的），看了一个寒假改了改，改成自己能用的，单进程运算六个面按照他的方法识别其实挺慢的，于是便做了一些改进用了多进程（进程池）的方法，创建六个进程，每个进程分别处理一个面，这样就快多了，原来需要三十秒左右，现在好的时候能到一两秒内，分享出来给大家共享。 先呈现一下效果图： `d 可以看出，快的时候将近一秒，具体要看cpu了。（注：第一次刚一开始运行的时候会很慢，如果时间很长都没有出结果把它关掉，重新在运行一遍就好啦！） 关于多进程进程池的问题，前段时间冥思苦想，一开始用多线程思路，使用threading模块，具体网上都有参考例子，可以搜一下，例如：https://www.cnblogs.com/tyomcat/p/5486827.html，但是用多线程后出现一个致命问题，并不是想自己想的那样更快，反而慢了，原因应该是网上说的 GIL全局锁，在解释器解释执行 Python 代码时，先要得到这把锁，意味着，任何时候只可能有一个线程在执行代码，其它线程要想获得 CPU 执行代码指令，就必须先获得这把锁，如果锁被其它线程占用了，那么该线程就只能等待，直到占有该锁的线程释放锁才有执行代码指令的可能。 因此，这也就是为什么两个线程一起执行反而更加慢的原因，因为同一时刻，只有一个线程在运行，其它线程只能等待，即使是多核CPU，也没办法让多个线程「并行」地同时执行代码，只能是交替执行，因为多线程涉及到上下文切换、锁机制处理（获取锁，释放锁等），所以，多线程执行不快反慢。 在python里，如果想更多的利用多核cpu内存，还是更多利用多进程处理比较好。 https://blog.csdn.net/topleeyap/article/details/78981848这篇博客里有具体的实现多进程的几种方式，我用的是进程池的方式（Pool）： ps=Pool(6) #cpu=ps.apply(colorMatch,args=(i,)) # 同步执行 up_cpu=ps.apply_async(colorMatch,args=('up',)) # 异步执行 right_cpu=ps.apply_async(colorMatch,args=('right',)) front_cpu=ps.apply_async(colorMatch,args=('front',)) down_cpu=ps.apply_async(colorMatch,args=('down',)) left_cpu=ps.apply_async(colorMatch,args=('left',)) back_cpu=ps.apply_async(colorMatch,args=('back',)) # 关闭进程池，停止接受其它进程 ps.close() # 阻塞进程 ps.join() 我创建了六个进程：up_cpu、right_cpu、front_cpu、down_cpu、left_cpu、back_cpu
将拍摄的六个面照片依次传入颜色识别函数colorMatch(side)：
def colorMatch(side): cube_rgb = cv2.imread( side + '.jpg') 这套颜色识别方法，是对六种颜色分别计算出掩膜，将其加和后对整个面进行识别，
mask = red_erosion + green_erosion + yellow_erosion + blue_erosion + orange_erosion + white_erosion mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel_50)#开运算分割色块 mask = cv2.erode(mask, kernel_50, iterations = 1) res = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f415a03390243a1207afdd20ccb186a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62b905e881fdd42286c9025d22603298/" rel="bookmark">
			java中的 FileWriter类 和 FileReader类的一些基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FileWriter学习
FileWriter 文件输出流是用于将数据写入 File 或 FileDescriptor 的输出流。文件是否可用或能否可以被创建取决于基础平台。特别是某些平台一次只允许一个FileOutputStream（或其他文件写入对象）打开文件进行写入。在这种情况下，如果所涉及的文件已经打开，则此类中的构造方法将失败。
FileOutputStream 用于写入诸如图像数据之类的原始字节的流。要写入字符流，请考虑使用 FileWriter。
共有五个构造方法
FileWriter(File file) 根据给定的 File 对象构造一个 FileWriter 对象。
FileWriter(File file, boolean append) 根据给定的 File 对象构造一个 FileWriter 对象。
FileWriter(String fileName) 根据给定的文件名构造一个 FileWriter 对象。
FileWriter(String fileName, boolean append) 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象。
FileWriter(FileDescriptor fd) 构造与某个文件描述符相关联的 FileWriter 对象。
其中方法可以分为三组，入参带File的为一组，入参带String 的为一组，这两组方法基本相似。
带File 的构造方法是直接传入文件来构造FileWriter对象，而带String 的构造方法，则必须先通过new File(String path) 来构造File 文件，再来构造FileWriter对象。
再看 File file 入参的两个方法
FileWriter(File file) 和 FileWriter(File file, boolean append) 的区别在于后面多了一个boolean append 参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62b905e881fdd42286c9025d22603298/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c84f184b16c03a9bc863d0a798b332ab/" rel="bookmark">
			预测数值型数据：回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文传送机
用线性回归找到最佳拟合直线
局部加权线性回归
通过缩减系数来“理解”数据
岭回归
lasso
前向逐步回归
用线性回归找到最佳拟合直线 线性回归
优点：结果易于理解，计算上不复杂
缺点：对非线性的数据拟合不好
适用数据类型：数值型和标称型数据
回归方程为：，其中为回归系数
回归的一般方法
收集数据：采用任意方法收集数据准备数据：回归需要数值型数据，标称型数据将被转换为二值型数据分析数据：绘制出数据的可视化二维图将有助于对数据做出理解和分析，在采用压缩减法求得新回归系数之后，可以将新拟合线在图上作为对比训练算法：找到回归系数测试算法：使用或者预测值和数据的拟合度来分析模型的效果使用算法：使用回归，可以在给定输入的时候预测出一个数值，这是对分类方法的提升，因为这样可以预测连续型数值而不仅仅是离散的类别标签。 现在的问题是，给定和对应的，怎样才能找到呢？一个常用的方法就是找出使误差最小的 。这里的误差是指预测值和真实值之间的差值，使用丐武训哈的简单累加将使得正差值和负差值相互抵消，所以我们采用平方误差。
平方误差为：
写成矩阵运算的形式为：
为求的极小值，可对进行求导，的极值点一定出现在的位置：
可得
这里的便是回归系数的最优估计向量。
代码：
import numpy as np import matplotlib.pyplot as plt def load_dataset(filename): feature_number = len(open(filename).readline().split('\t'))-1 data_mat = [] label_mat = [] file = open(filename) for line in file.readlines(): line_array = [] curr_line = line.strip().split('\t') for i in range(feature_number): line_array.append(float(curr_line[i])) data_mat.append(line_array) label_mat.append(curr_line[-1]) return data_mat, label_mat def linear_regress(x_array, y_array): x_mat = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c84f184b16c03a9bc863d0a798b332ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0296fda2416625fbe4fca49827527d36/" rel="bookmark">
			springboot日期返回前端显示的yyyy-MM-dd &#39;T&#39; HH:mm:ss问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自
https://blog.csdn.net/z_k_h/article/details/82253530
https://blog.csdn.net/qice675563721/article/details/78947864
框架默认restful返回json，后台时间显示正确, 但在前端打印出来的时间是’T’格式的
在配置文件中添加：
springboot2.0以上
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss spring.jackson.time-zone=GMT+8 #spring.jackson.serialization.WRITE_DATES_AS_TIMESTAMPS=true(也可以直接返回时间戳) 可以正常解决date返回前端的显示问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec6ccaad34cce5215a2f1394a0114c56/" rel="bookmark">
			jQuery里面的普通绑定事件和on委托事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以click事件为例：
$().click()和$().on('click',function(){}) 普通绑定事件：$(’.btn1’).click(function(){}绑定
on绑定事件：$(document).on(‘click’,’.btn2’,function(){}绑定
那么这两种方式有什么区别呢？
$(选择器).click(fn)
当选中的选择器被点击时触发回调函数fn。只针对与页面已存在的选择器。
$(选择器).on('click',function(){}) （Jq1.7+）
on()事件相当于是$(document).click(function(){if(点击的是btn){}})，给document添加了一个click事件，当点击的是btn，事件冒泡原理，从里到外，就相当于点击了document，那么就会执行后面的操作，本质上只给document添加了一个事件，而click()事件是给所有btn添加了click事件。
另外on()事件可以添加多个事件同时支持动态绑定元素，即页面上元素有添加或变化后仍可绑定,前提是‘选择器’须是目标绑定元素的父元素。
on()委托事件的优点：原来的事件绑定，要绑定好多事件，现在只需要绑定一个事件，大大提高了效率和页面性能，解决的动态添加元素导致不能触发的bug。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f2e5baae6175c52aa4c6eaaae1996a5/" rel="bookmark">
			Python读书笔记-每日一练-20190307|鸡兔同笼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述:《孙子算经》中记载的有趣问题，今有雉兔同笼，上有三十五头，下有九十四足，问雉兔各几何？
解题思路
1.穷举法:假设有x只鸡，y只兔。因为每只鸡一头两足，每只兔一头四足，由题中数据可以得到x+y=35,x*2+y*4=94,遍历即可得到鸡兔只数。程序编写如下:
#!/usr/bin/env python3 #Filename:chichen_rabbit.py class CR(object): def __init__(self): pass @staticmethod def exhaustion(head ,foot): chicken = 0 rabbit = 0 for i in range(0, head + 1): for j in range(0, head - i +1): if(i*2 + j*4 ==foot): chicken = i rabbit = j break return (chicken,rabbit) if __name__ == "__main__": head,foot = 35,94 ret = CR.exhaustion(head, foot) print("chicken=%d,rabbit=%d"%(ret[0],ret[1])) 穷举法在有限的数据组合中是直接有效的，不过效率肯定有所不足。
2.假设法:假设让鸡与兔子同时抬起两只脚，则此时鸡是屁股坐在地上，只有每只兔子剩余的两条腿接触地面，剩余多少条腿呢？94-35*2=24，显然兔子数为24/2=12只，鸡为35-12=23只，程序编写为:
@staticmethod def assume(head,foot): rabbit = (foot - head*2)/2 chicken = head - rabbit return (chicken,rabbit) 当然程序中公式也可以变形:rabbit = foot/2 - head，至于这个公式如何假设就看自己理解了~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7a97bdc707dbfc09f413c13cd433aba/" rel="bookmark">
			Chrome浏览器安装CoAP调试客户端Copper插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 由于火狐浏览器56版本之后不再支持Copper插件，本文将介绍如何在Chrome浏览器中安装Copper插件。两个浏览器中使用CoAP插件Copper的方法非常相似。
获取Copper4Cr插件 把Copper4Cr工具克隆到本地
git clone https://github.com/mkovatsc/Copper4Cr.git windows环境运行install.bat
安装Copper插件 打开Chrome浏览器，在浏览器地址栏输入“chrome://extensions/”。
打开Chrome浏览器开发者模式。
点击“加载已解压的扩展程序”，选择代码仓库中app文件夹。再点击“加载已解压的扩展程序”，选择extension文件夹。
正确安装之后，Chrome浏览器中可以看到以下相似界面
复制Copper(Cu4Cr) Application 0.1.0中ID编号，见上图。
找到Copper4Cr代码仓库中的ClientPortChrome.js文件，该文件位于Copper4Cr代码仓库extension/endpoint目录下。把上一步复制的ID编号覆盖ClientPortChrome.js中的appId。
插件安装完成。
简单测试 操作说明 点击Chrome右上角的Cu标记，进入Copper插件后输入CoAP资源地址，例如“coap://wsncoap.org/test”
点击操作按钮GET可获得以下类似界面
区别说明 在Chrome浏览器中使用Copper插件，不能在浏览器地址栏修改CoAP资源地址。
特别说明 个人在一台阿里云ECS上部署了一个CoAP测试服务，由于本人时间和精力有限，该CoAP服务可能定期崩溃（自己的运维水平不够，请大家多原谅）。如果读者发现该CoAP测试服务崩溃，请通过邮件或电话告知，非常感谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a152ac6223c34464f497b1b2742df36/" rel="bookmark">
			kafka监控获取指定topic的消息总量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import kafka.api.PartitionOffsetRequestInfo; import kafka.common.TopicAndPartition; import kafka.javaapi.OffsetResponse; import kafka.javaapi.PartitionMetadata; import kafka.javaapi.TopicMetadata; import kafka.javaapi.TopicMetadataRequest; import kafka.javaapi.consumer.SimpleConsumer; import java.util.*; import java.util.Map.Entry; public class KafkaOffsetTools { public final static String KAFKA_TOPIC_NAME_ADAPTER = "sample"; public final static String KAFKA_TOPIC_NAME_EXCEPTION = "exception"; public final static String KAFKA_TOPIC_NAME_AUDIT = "audit"; private static final String rawTopicTotal = "rawTopicTotalRecordCounter"; private static final String avroTopicTotal = "avroTopicTotalRecordCounter"; private static final String exceptionTopicTotal = "exceptionTopicTotalRecordCounter"; public KafkaOffsetTools() { } public static long getLastOffset(SimpleConsumer consumer, String topic, int partition, long whichTime, String clientName) { TopicAndPartition topicAndPartition = new TopicAndPartition(topic, partition); Map, PartitionOffsetRequestInfo&gt; requestInfo = new HashMap, PartitionOffsetRequestInfo&gt;(); requestInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a152ac6223c34464f497b1b2742df36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a2293c317e440436bcb4a4ff286ad27/" rel="bookmark">
			使用flowdroid得到apk的调用关系图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用flowdroid得到apk的调用关系图
问题描述 直接调用constructCallgraph()得到的调用关系图并不完整，以QKSMS代码为例。
TransactionService.java的部分源码如下所示
用flowdroid生成的调用关系图，其中onReceive()调用的函数输出如下：
从运行结果中可以看出得到的调用函数并不完整，getNetworkInfo()、isConnected()、getState()等均为出现。
解决 将soot-infoflow/src/soot/jimple/infoflow/InfoflowConfiguration.java中的第132行CallgraphAlgorithm的值更新为CallgraphAlgorithm.CHA，运行结果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73728d995051b554804649100e8d64a4/" rel="bookmark">
			vue  浮点型乘除法精确计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在js里直接使用乘法*得到的结果是不精确的，错误的。例如：0.0056*100=0.559999 很明显这个结果是错误的。那么如何计算加减乘除呢？在vue 里.乘法计算，使用的话也很简单 &lt;p&gt; 【月息】{{NumberMul(0.0058,100)}}% &lt;/p&gt; Vue.prototype.NumberMul = function(arg1, arg2) { var m = 0; var s1 = arg1.toString(); var s2 = arg2.toString(); try { m += s1.split(".")[1].length; } catch (e) {} try { m += s2.split(".")[1].length; } catch (e) {} return Number(s1.replace(".", "")) * Number(s2.replace(".", "")) / Math.pow(10, m); } 浮点型加法： Vue.prototype.NumberAdd = function(arg1, arg2) { var r1, r2, m, n; try { r1 = arg1.toString().split(".")[1].length } catch (e) { r1 = 0 } try { r2 = arg2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73728d995051b554804649100e8d64a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/111e43f7f7a52697faab978a3c8cf153/" rel="bookmark">
			Windows 用bat脚本创建计划任务执行php
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步 准备好两个文件，一个bat,一个php
test.php
&lt;?php file_get_contents("http://www.ceshi.com/ceshi"); ?&gt; ceshi.bat（用php.exe打开test.php文件）
F:\php\php\php-5.4.45\php.exe -q F:\php\WWW\web\test.php 第二步 创建计划任务
打开‘控制面板’——》‘管理工具’——》‘任务计划程序’
填写常规、触发器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04e55dc307140c04b26f016461b748f7/" rel="bookmark">
			python正则表达式匹配字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注微信公众号(瓠悠笑软件部落)，一起学习，一起摸鱼
相关资料:
re module
regular-expressions
使用步骤 import re 导入正则表达式模块用 re.compile() 函数创建一个 Regex 对象.(记着使用原始字符串, 字符串前面带r)将你要用于搜索的字符串传入 Regex 对象的 search() 方法中。这个方法将会返回一个 Match object.调用 Match object　的 group() 方法，将返回实际匹配到的文本 eg:匹配美国的号码
#! /usr/bin/python3 import re phoneNumRegex = re.compile(r'\d{3}-\d{3}-\d{4}') mo = phoneNumRegex.search('My number is 415-555-4242.') print('Phone number found: ' + mo.group()) 在线正则表达式
Grouping with Parentheses 假设您要将区号与电话号码的其余部分分开。添加括号将在正则表达式中创建组：
(\d{3})-(\d{3}-\d{4}). 然后你可以使用group() 匹配对象方法从一组的文字获取匹配的文本。正则表达式字符串中的第一组括号将是第1组。第二组括号将是第二组。通过将 整数 1 或者 2 作为参数传入 group() 方法中，你可以获取匹配到的文本的不同部分。如果传0, 或者不传，将会返回匹配的完整文本。
phoneNumberRegex = re.compile(r'(\d{3})-(\d{3}-\d{4})') mo = phoneNumberRegex.search('My number is 415-555-4242.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04e55dc307140c04b26f016461b748f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc993606ccd218dee9ffcf0307e2896e/" rel="bookmark">
			TensorFlow Process finished with exit code -1073740791 (0xC0000409)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Check failed: PyBfloat16_Type.tp_base != nullptr 查了很多博客，最后发现是因为numpy的问题，并不一定都是内存问题，可能是安装方式问题，再者是安装了多个版本的numpy或者没有更新
安装方式： 1、注意win10安装tensorflow需要创建 TensorFlow 依赖环境：
conda create -n tensorflow python=3.6 2、然后在Anaconda Prompt中激活tensorflow环境：
activate tensorflow 3、最后在这个环境下安装tensorflow（cpu）
conda install tensorflow 如果直接进入第3步，就会报此类似错误的。 需要重新创建环境，再在此环境下安装tensorflow。
pycharm中需切换到TensorFlow 依赖环境的python：
ok —— apply —— ok
如果需要其他工具包，在anaconda promote切换到此环境下安装
numpy： 1.如果是因为没有更新，直接更新 python -m pip install --upgrade numpy
2.安装了两个版本
先卸载 pip uninstall numpy
再更新 python -m pip install --upgrade numpy
记录自己的学习过程，方便日后查阅，如有不对的地方还请指教！如果你喜欢欢迎点赞、评论\(^o^)/~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0412e98aba0615dadf8780b6f6bdc6f/" rel="bookmark">
			框架：Spring事务的隔离级别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 首先,说说什么事务（Transaction）
事务，就是一组操作数据库的动作集合。事务是现代数据库理论中的核心概念之一。
如果一组处理步骤或者全部发生或者一步也不执行，我们称该组处理步骤为一个事务。
当所有的步骤像一个操作一样被完整地执行，我们称该事务被提交。
由于其中的一部分或多步执行失败，导致没有步骤被提交，则事务必须回滚到最初的系统状态。
2. spring七个事务传播属性：
1.PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。
2.PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。
3.PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。
4.PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。
5.PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
6.PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。
7.PROPAGATION_NESTED – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。
备注：常用的两个事务传播属性是1和4，即PROPAGATION_REQUIRED，PROPAGATION_REQUIRES_NEW
3. 五个隔离级别：
ISOLATION_DEFAULT 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.
另外四个与JDBC的隔离级别相对应；
ISOLATION_READ_UNCOMMITTED 这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。 这种隔离级别会产生脏读，不可重复读和幻像读。
ISOLATION_READ_COMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。 这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。
ISOLATION_REPEATABLE_READ 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。 它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。
ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。 除了防止脏读，不可重复读外，还避免了幻像读。
关键词： 1)幻读：事务1读取记录时事务2增加了记录并提交，事务1再次读取时可以看到事务2新增的记录； 2)不可重复读取：事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录； 3)脏读：事务1更新了记录，但没有提交，事务2读取了更新后的行，然后事务T1回滚，现在T2读取无效。
脏读：指一个事务读取了一个未提交事务的数据
不可重复读：在一个事务内读取表中的某一行数据,多次读取结果不同.一个事务读取到了另一个事务提交后的数据.
虚读(幻读)：在一个事务内读取了别的事务插入的数据，导致前后读取不一致(insert)
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/486/">«</a>
	<span class="pagination__item pagination__item--current">487/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/488/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>