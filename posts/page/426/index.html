<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/525b7735fb8d871739d3b2400582b355/" rel="bookmark">
			小白之路——tableau篇（数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
目录
I.简介
II.属性
A.工作区
B.快捷键
III.基本图形
1.条形图
2.直方图
3.数据前处理
4.折线图
5.饼图
6.环形图
7.基本表&amp;凸显表
8.树形图
9.气泡图
10.词云
11.标靶图
12.甘特图
13.瀑布图
14.数据集合并
15.符号地图
16.填充地图&amp;背景地图&amp;混合地图
17.多边形地图
18.自定义编码
19.仪表板
20.故事
21.功能介绍
A数据分层结构
​​B.数据分组
C.数据集
22.计算字段
23.函数
24.寻址&amp;分区
25.数据聚合
IV.进阶图形
1.范围-线图
2.倾斜图
3.网络图
4.弧线图
5.雷达图
6.凹凸图bump chart
7.旋风图/人口金字塔图
8.漏斗图
9.箱线图
V.资源
I.简介 1.Tableau一款可以将数据运算与美观图标完美嫁接在一起的软件。可以帮助任何人快速分析、可视化并分享信息。
定义——桌面系统简单的商业智能工具软件；提供完整的分析能力
【特点】
易用、快速、灵活和精美能够处理海量数据数据引擎的速度极快比传统的数据库查询快10-100倍 【更改标记类型：】
https://help.tableau.com/current/pro/desktop/zh-cn/viewparts_marks_marktypes.htm#GanttBarMark
本文用到的是【Tableau desktop】：
Tableau Desktop 是一款设计和创建美观的视图与仪表板、实现快捷数据分析功能的桌面端分析工具。包含Tableau Desktop Personal(个人版)和Tableau Desktop Professional(专业版)两个版本，支持Windows和Mac操作系统。
II.属性 A.工作区 1.工作区说明：
2.文件类型：
可以使用多种不同的Tableau文件类型，如工作簿、打包工作簿、数据提取、数据源和书签等， 来保存和共享工作成果和数据源
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/525b7735fb8d871739d3b2400582b355/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca35ed6fddf7e2243aa57ec7064ee223/" rel="bookmark">
			Ctrl&#43;Z 撤销  撤多了 砍手之前先修复!!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ctrl+Z撤销 那么有没有手贱的时候或者脑残的时候 撤多了 ┭┮﹏┭┮, 想砍死自己的心都有了
砍死之前先修复!! 说不定就又救回自己的一条小命
那么 试下 ctrl+shift+z
不行的话就用 Ctrl+Y
windows下的返回撤销操作为Ctrl+Y 反正 小翔我用的就是这个 贼啦好使 O(∩_∩)O哈哈~
开开心心敲代码
是谁的锅
懵懵逼逼出BUG
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/066f643497f4ca1a21ea1b16ce36e120/" rel="bookmark">
			Mac下安装swaggo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装工具
go get -u github.com/swaggo/swag/cmd/swag 安装完成后检查一下
swag -v swag version v1.6.7 如果提示zsh: command not found: swag，先看一下gopath的目录
go env 找到目录大概这样GOPATH="/Users/xx/go"，ls一下，看到有swag这个命令，试一下
/Users/xx/go/bin/swag -v swag version v1.6.7 那就是没有加到环境变量，我的终端是zsh，编辑一下配置
vim ~/.zshrc 添加
export PATH="/Users/xx/go/bin:$PATH" 关掉终端再打开试一试swag就ok了
https://github.com/swaggo/swag
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9489e729ca3d7fe08c11719ab60ff9a0/" rel="bookmark">
			【Python】 第4章-5 求e的近似值 (15分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 自然常数 e 可以用级数 1+1/1!+1/2!+⋯+1/n!+⋯ 来近似计算。本题要求对给定的非负整数 n，求该级数的前 n+1 项和。
输入格式: 输入第一行中给出非负整数 n（≤1000）。
输出格式: 在一行中输出部分和的值，保留小数点后八位。
输入样例: 10 输出样例: 2.71828180 【Python参考代码】 ①定义阶乘函数 #By yangbo 2020.07.14 def fun(n):#定义阶乘函数 s=1 for i in range(1,n+1): s*=i return s N,E=int(input()),1 for i in range(1,N+1): E+=1/fun(i) print("%.8f"%E) ②由于测试点3耗时长达188ms,于是有了改进版： #By yangbo 2020.07.14 N,E,S=int(input()),1,1 for i in range(1,N+1): S*=i E+=1/S print("%.8f"%E) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12372d59b70c36741940c83f8d88da25/" rel="bookmark">
			微信小程序watch  属性监听器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 设置监听器 接收需要监听的对象, 一个watch对象 */ setWatcher(data, watch) { Object.keys(watch).forEach(v =&gt; { // 遍历需要监听的属性 this.observe(data, v, watch[v]); // 监听data内的v属性，传入watch内对应函数以调用 }) }, /** * 监听属性 并执行监听函数 */ observe(obj, key, watchFun) { var val = obj[key]; // 给该属性设默认值 Object.defineProperty(obj, key, { configurable: true, enumerable: true, set: function(value) { val = value; watchFun(value,val); // 赋值(set)时，调用对应函数 }, get: function() { return val; } }) }, 使用 在onload中调用app.setWatcher(app.globalData, this.watch())
watch() { return { onceMsg: (newVal) =&gt; { if(newVal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12372d59b70c36741940c83f8d88da25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c21d470e9c578139fcad8e92179ffc1/" rel="bookmark">
			HTML 5—布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单布局 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; * { margin: 0; padding: 0; } .header { /*设置一个宽度*/ width: 1000px; /*设置一个高度*/ height: 150px; /*设置一个背景颜色*/ background-color: yellowgreen; /*设置居中*/ margin: 0 auto; } /*设置一个content*/ .content { /*设置一个宽度*/ width: 1000px; /*设置一个高度*/ height: 400px; /*设置一个背景颜色*/ background-color: orange; /*居中*/ margin: 10px auto; } /*设置content中小div的样式*/ .left { width: 200px; height: 100%; background-color: skyblue; /*向左浮动*/ float: left; } .center { width: 580px; height: 100%; background-color: yellow; /*向左浮动*/ float: left; /*设置水平外边距*/ margin: 0 10px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c21d470e9c578139fcad8e92179ffc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7510770be88dacd43f72440f1d170012/" rel="bookmark">
			尚硅谷JVM从入门到精通宋红康版|第十四章、垃圾回收概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		垃圾回收概述 概念 这次我们主要关注的是黄色部分，内存的分配与回收
什么是垃圾 在提到什么是垃圾之前，我们先看下面一张图
从上图我们可以很明确的知道，Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C语言没有垃圾收集技术，需要我们手动的收集。
垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。
关于垃圾收集有三个经典问题：
哪些内存需要回收？什么时候回收？如何回收？ 垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。
什么是垃圾？ 垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。
如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。
磁盘碎片整理 机械硬盘需要进行磁盘整理，同时还有坏道
大厂面试题 蚂蚁金服 你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和G1？JVM GC算法有哪些，目前的JDK版本采用什么回收算法？G1回收器讲下回收过程GC是什么？为什么要有GC？GC的两种判定方法？CMS收集器与G1收集器的特点 百度 说一下GC算法，分代回收说下垃圾收集策略和算法 天猫 JVM GC原理，JVM怎么回收内存CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？ 滴滴 Java的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃圾回收器的
京东 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。垃圾回收算法的实现原理 阿里 讲一讲垃圾回收算法。什么情况下触发垃圾回收？如何选择合适的垃圾收集算法？JVM有哪三种垃圾回收器？ 字节跳动 常见的垃圾回收器算法有哪些，各有什么优劣？System.gc（）和Runtime.gc（）会做什么事情？Java GC机制？GC Roots有哪些？Java对象的回收方式，回收算法。CMS和G1了解么，CMS解决什么问题，说一下回收的过程。CMS回收停顿了几次，为什么要停顿两次? 为什么需要GC 对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。
除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。
随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。
早期垃圾回收 在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：
MibBridge *pBridge= new cmBaseGroupBridge（）； //如果注册失败，使用Delete释放该对象所占内存区域 if（pBridge-&gt;Register（kDestroy）！=NO ERROR） delete pBridge； 这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。
有了垃圾回收机制后，上述代码极有可能变成这样
MibBridge *pBridge=new cmBaseGroupBridge(); pBridge-&gt;Register(kDestroy); 现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了线代开发语言必备的标准。
Java垃圾回收机制 优点 自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险
没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。
自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发
oracle官网关于垃圾回收的介绍
https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html
担忧 对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。
此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见outofMemoryError时，快速地根据错误异常日志定位问题和解决问题。
当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7510770be88dacd43f72440f1d170012/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/814f7a75099caf69ec5bc3815b3ff8d4/" rel="bookmark">
			JVM解释i&#43;&#43;和&#43;&#43;i底层区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个程序解释i++和++i 前言代码实现字节码指令解释以上运行结果第一类问题总结 第二类问题第三类问题第四类问题 前言 如果只用普通的知识解释i++和++i的话 i++ 先将i赋值再++ ==i 先++再赋值 但是这简单的回答并不能入吸引面试官的眼球,如果用java字节码指令分析则效果完全不同 代码实现 /** * @author wxy * @create 2020 下午 10:25 */ public class OperandStackTest { /** 程序员面试过程中， 常见的i++和++i 的区别 */ public static void add(){ //第1类问题： int i1 = 10; i1++; System.out.println(i1);//11 int i2 = 10; ++i2; System.out.println(i2);//11 //第2类问题： int i3 = 10; int i4 = i3++; System.out.println(i3);//11 System.out.println(i4);//10 int i5 = 10; int i6 = ++i5; System.out.println(i5);//11 System.out.println(i6);//11 //第3类问题： int i7 = 10; i7 = i7++; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/814f7a75099caf69ec5bc3815b3ff8d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97a4bef408ad7fbb7564d163ddf5de89/" rel="bookmark">
			libpng-warning:-iCCP:-cHRM-chunk-does-not-match-sRGB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现以下错误：
libpng warning: iCCP: cHRM chunk does not match sRGB
解决：
若电脑使用的是QQ输入法，请替换成别的输入法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c76d92a8776462943278e8e4c887532/" rel="bookmark">
			SpringCloud Alibaba - 链路追踪（浅谈链路追踪 / 阿里组件 并没有链路追踪，应该选取哪一种使用好）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringCloud Alibaba - 链路追踪（浅谈链路追踪 / 阿里组件 并没有链路追踪，应该选取哪一种使用好） 回溯链路追踪（介绍）基本实现原理 常用组件 回溯 前面的章节讲解了微服务的互相调用，以及注册发现，熔断，网关等等，但是这些操作还不足以支撑项目的开发，我们还需要对程序的各方面分析等等，那么这章节讲解 链路追踪 ，不过和网关一样，Alibaba并没有开源相对应的组件，所以我们需要自己进行选择。
链路追踪（介绍） 在大型系统的微服务化构建中，一个系统被拆分成了许多模块。这些模块负责不同的功能，组合成系统，最终可以提供丰富的功能。在这种架构中，一次请求往往需要涉及到多个服务。互联网应用构建在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、可能使用不同的编程语言来实现、有可能布在了几千台服务器，横跨多个不同的数据中心，也就意味着这种架构形式也会存在一些问题：
如何快速发现问题？如何判断故障影响范围？如何梳理服务依赖以及依赖的合理性？如何分析链路性能问题以及实时容量规划？ 就是这样一个调用链，一个用户请求了应用A，应用A需要请求应用B和应用C，而应用C需要请求应用D和应用E。
分布式链路追踪（Distributed Tracing），就是将一次分布式请求还原成调用链路，进行日志记录，性能监控并将一次分布式请求的调用情况集中展示。比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。
基本实现原理 如果想知道一个接口在哪个环节出现了问题，就必须清楚该接口调用了哪些服务，以及调用的顺序，如果把这些服务串起来，看起来就像链条一样，我们称其为调用链。
想要实现调用链，就要为每次调用做个标识，然后将服务按标识大小排列，可以更清晰地看出调用顺序，我们暂且将该标识命名为spanid。
实际场景中，我们需要知道某次请求调用的情况，所以只有spanid还不够，得为每次请求做个唯一标识，这样才能根据标识查出本次请求调用的所有服务，而这个标识我们命名为traceid。
现在根据spanid可以轻易地知道被调用服务的先后顺序，但无法体现调用的层级关系，正如下图所示，多个服务可能是逐级调用的链条，也可能是同时被同一个服务调用。
所以应该每次都记录下是谁调用的，我们用parentid作为这个标识的名字。
到现在，已经知道调用顺序和层级关系了，但是接口出现问题后，还是不能找到出问题的环节，如果某个服务有问题，那个被调用执行的服务一定耗时很长，要想计算出耗时，上述的三个标识还不够，还需要加上时间戳，时间戳可以更精细一点，精确到微秒级。
只记录发起调用时的时间戳还算不出耗时，要记录下服务返回时的时间戳，有始有终才能算出时间差，既然返回的也记了，就把上述的三个标识都记一下吧，不然区分不出是谁的时间戳。
虽然能计算出从服务调用到服务返回的总耗时，但是这个时间包含了服务的执行时间和网络延迟，有时候我们需要区分出这两类时间以方便做针对性优化。那如何计算网络延迟呢？我们可以把调用和返回的过程分为以下四个事件。
Client Sent简称cs，客户端发起调用请求到服务端。Server Received简称sr，指服务端接收到了客户端的调用请求。Server Sent简称ss，指服务端完成了处理，准备将信息返给客户端。Client Received简称cr，指客户端接收到了服务端的返回信息。 假如在这四个事件发生时记录下时间戳，就可以轻松计算出耗时，比如sr减去cs就是调用时的网络延迟，ss减去sr就是服务执行时间，cr减去ss就是服务响应的延迟，cr减cs就是整个服务调用执行的时间。
其实span块内除了记录这几个参数之外，还可以记录一些其他信息，比如发起调用服务名称、被调服务名称、返回结果、IP、调用服务的名称等，最后，我们再把相同spanid的信息合成一个大的span块，就完成了一个完整的调用链。
PS(实现原理编写，参考 一文读懂链路追踪)。
常用组件 cat 由大众点评开源，基于Java开发的实时应用监控平台，包括实时应用监控，业务监控 。 集成方案是通过代码埋点的方式来实现监控，比如： 拦截器，过滤器等。 对代码的侵入性很大，集成成本较高。风险较大。zipkin 由Twitter公司开源，开放源代码分布式的跟踪系统，用于收集服务的定时数据，以解决微服务架构中的延迟问题，包括：数据的收集、存储、查找和展现。该产品结合spring-cloud-sleuth使用较为简单， 集成很方便， 但是功能较简单。pinpoint Pinpoint是韩国人开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI功能强大，接入端无代码侵入。SkyWalking 是本土开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI功能较强，接入端无代码侵入。目前已加入Apache孵化器。Sleuth SpringCloud 提供的分布式系统中链路追踪解决方案。 SpringCloud alibaba技术栈中并没有提供自己的链路追踪技术的，我们可以采用Sleuth +Zinkin来做链路追踪解决方案。这也是目前企业中较为流行的方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25ac31304eea3feac3ab682b47c7aa95/" rel="bookmark">
			KNN算法原理与python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 KNN算法原理KNN算法介绍KNN算法模型距离度量k值的选择分类的决策规则 KNN算法python实现手写数字识别sklearn代码实现 参考文献 KNN算法原理 KNN算法介绍 KNN（K-Nearest Neighbor）算法，顾名思义，其原理也就是“近朱者赤，近墨者黑”。KNN算法是一种有监督的分类算法，输入同样为样本特征值向量以及对应的类标签，输出则为具有分类功能的模型，能够根据输入的特征值预测分类结果。核心原理就是，与待分类点最近的K个邻居中，属于哪个类别的多，待分类点就属于那个类别。
KNN分类算法的思路很简洁，实现也很简洁，具体分三步：
1）找K个最近邻。KNN分类算法的核心就是找最近的K个点，选定度量距离的方法之后，以待分类样本点为中心，分别测量它到其他点的距离，找出其中的距离最近的“TOP K”，这就是K个最近邻。
2）统计最近邻的类别占比。确定了最近邻之后，统计出每种类别在最近邻中的占比。
3）选取占比最多的类别作为待分类样本的类别。
KNN算法模型 KNN算法模型主要有三要素构成：距离度量，k值的选择和分类的决策规则。
距离度量 两个样本点之间的距离代表了这两个样本之间的相似度。距离越大，差异性越大；距离越小，相似度越大。
闵可夫斯基距离的数学表达式如下：
闵可夫斯基距离是一组距离的定义，不妨把闵可夫斯基距离看作一个代数形式的母版，通过给P设置不同的值，就能用闵可夫斯基距离得到不同的距离表达式。
当P=1时，称为曼哈顿距离，表达式如下：
当P=2时，为欧几里得距离，最常用于度量两点之间的直线距离。表达式如下：
距离的度量方法没有好坏，选择什么方法主要是根据当前情况而定。
k值的选择 k值的选择会对KNN算法的结果产生重大的影响。
如果选择较小的K值
“学 习”的近似误差（approximation error)会减小，但 “学习”的估计误差（estimation error) 会增大，
噪声敏感
K值的减小就意味着整体模型变得复杂，容易发生过 拟合.
如果选择较大的K值
减少学习的估计误差，但缺点是学习的近似误差会增大.
K值的增大 就意味着整体的模型变得简单.
在应用中，k值一般取一个比较小的数值，通常采用交叉验证法来选取最优的k值。
分类的决策规则 根据多数表决原则，决定待分类样本点的类别。
KNN算法python实现 手写数字识别 1）数据加载：我们可以直接从 sklearn 中加载自带的手写数字数据集；
2）准备阶段：通过可视化的方式来查看图像的呈现。通过数据规范化可以让数据都在同一个数量级的维度。将全部的图像数据作为特征值矩阵；
3）分类阶段：通过训练可以得到分类器，然后用测试集进行准确率的计算。
knn分类器的常用构造参数有：
1）.n_neighbors 代表邻居的数量。
2）.weights： 代表所有邻居的权重，其中 uniform 代表所有邻居权重相同， distance 代表权重是距离的倒数。还可以自定义。
3）.algorithm: 计算邻居的方法，auto代表 根据数据的情况自动选择，kd_tree 是kd树，适用于维数不超过20的情况。ball_tree是球树，可以用于维度更大的情况。brute 是暴力搜索。
4）.leaf_size:是kd树或者球树的叶子数量，默认是20.
sklearn代码实现 from sklearn.model_selection import train_test_split from sklearn import preprocessing from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25ac31304eea3feac3ab682b47c7aa95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4473d4d1d7f13e5ea9cb6ed326e921e4/" rel="bookmark">
			Excle 取前几位数、中间几位数、后几位数的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、left函数用法：left(取值的数值,取值位数)
二、right函数用法：right(取值的数值,取值位数)
三、mid函数用法：mid(取值的数值,取开始位置序号,取值位数)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fe55046898d57c46ac20e742a8162bd/" rel="bookmark">
			Java基本查找算法 -- 哈希表的查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、哈希表的查找 前面讨论的线性表和树表的查找中，表中的相对位置是随机的，也就是是说，记录在表中的位置跟记录的关键字之间不存在确定关系。因此，在这些表中查找记录时需要进行一系列的关键字比较。这一类查找方法是建立在“比较”的基础上的。
在记录的存储位置和它的关键字之间建立一个确定的对应关系f,使每个关键字和表中一个唯一的存储位置相对应,称这个对应关系f为哈希(散列)函数,根据这个思想建立的表称为哈希表。
在哈希表中,若出现key1≠key2,而f(key1)=f(key2),则这种现象称为地址冲突key1和key2对哈希函数f来说是同义词。根据设定的哈希函数f=H(key)和处理冲突的方法，将一组关键字映射到一个有限的连续的地址集上，并以关键字在地址集中的“象作为记录中的存储位置，这一映射过程为构造哈希表(散列表)。
好的哈希函数应该使一组关键字的哈希地址均匀分布在整个哈希表中，从而减少冲突，常用的构造哈希函数的方法有：
(1)直接地址法。取关键字或关键字的某个线性函数值为哈希地址,即H(key)=key或H(key)=a*ket+b,其中,a和b为常数(2)数字分析法。假设关键字是r进制数(如十进制数),并且哈希表中可能出现的关键字都是事先知道的，则可选取关键字的若干数位组成哈希地址。选取的原则是使得到的哈希地址尽量避免冲突，即所选数位上的数字尽可能是随机的。(3)平方取中法。取关键字平方后的中间几位为哈希地址。这是一种较常用的方法。通常在选定哈希函数时不一定能知道关键字的全部情况，仅取其中的几位为地址不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此得到的哈希地址随机性更大。(4)除留余数法。取关键字被某个不大于哈希表长m的数p除后所得的余数为哈希地址。即:H(key)= key mod p(p&lt;=m)。这是一种最简单、最常用的方法,它不仅可以键字直接取模，也可在折叠、平方取中等运算上取模。 采用均匀的哈希函数可以减少地址冲突，但是不能避免冲突，因此，必须有良好的法来处理冲突，通常，处理地址冲突的方法有以下两种:
(1)开放地址法。在开放地址法中，以发生冲突的哈希地址为自变量，通过某周哈希冲突函数得到一个新的空闲的哈希地址。这种得到新地址的方法有很多种，主要有线性探查法和平方探查法。线性探查法是从发生冲突的地址开始，依次探查该地址的下一地址，直到找到一个空闲单元为止。而平方探查法则是在发生冲突的地址上加减某个因子的平方作为新的地址。(2)拉链法。拉链法是把所有的同义词用单链表链接起来的方法。在这种方哈希表中每个单元中存放的不再是记录本身，而是相应同义词单链表的头指针。 例1：有如下数字构成的序列：A = { 7，4，1，14，100，30，5，9，20，134 } 请构造一张哈希表。
对数字序列:A = { 7,4,1,14，100，30，5，9，20，134 }中的10个元素,就可以采用除留余数法来构造哈希表,哈希函数为H(key)=key%p(p&lt;=m),其中p用13,m用15,而对与哈希冲突的解决，可以采用开放地址中的线性探查法，具体构造哈希表的过程如下：
首先在哈希表可用空间里取用15个连续空间来存放对应元素,对于A中第一个元素用哈希函数求其对应的空间位置为:7%13=7，所以把第一个元素7放入位置为7的空间里。
对于A中第二个元素4,用哈希函数求其对应的空间位置为:4%13=4,所以把第个元素4放入位置为4的空间里。
对于A中第三个元素1，用哈希函数求其对应的空间位置为：1%13=1，所以把第三个元素1放入位置为1的空间里。
对于A中第四个元素14,用哈徐函数求其对应的空间地址为：14%13=1，但由于位置1的空间里有元素了，就采用开发地址中的线性探查法解决地址冲突，依此往后探索地址，得到位置2的空间可用，所以把第4个元素14放入位置2的空间里。
按如此寻址规律循环下去，把剩下的元素全部放入哈希表中，得到哈希表如下：
为了便于查验构造哈希表结果的正确性，构造哈希表的代码里面添加了显示哈希表内容的函数和构造哈希表驱动程序，具体代码如下：
public class HashTable { public int[] key; public int nullKey = -1; public int count = 0; public HashTable() { this.key = new int[50]; } public void insertHT(HashTable ha, int key, int p, int m) { int i, adr; adr = key % p; if (ha.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fe55046898d57c46ac20e742a8162bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab5789c25d5bcd48989832531b9daa52/" rel="bookmark">
			微信小程序已支持分享到朋友圈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序大概本周二也就是7月7日的时候悄悄上线了分享到朋友圈功能，目前还是beta版本。
目前小程序分享到朋友圈有以下2个限制：
a.仅支持Android平台，ios平台暂不支持
b.微信基础库限制2.11.3及以上
开发者设置分享小程序到朋友圈，有2种方式：
wx.showShareMenu()，支持快速分享到朋友圈使用默认小程序标题，分享图为小程序logo，不可自定义参数。（uni-app已支持） wx.showShareMenu({ menus: ['shareAppMessage', 'shareTimeline'] //shareAppMessage必须得有 }) onShareTimeline()，支持自定义分享到朋友圈的小程序标题、分享图，自定义query参数。（uni-app截止发文暂不支持） //注意必须得设置允许“发送给朋友”onShareAppMessage，是设置onShareTimeline的前提，否则不支持分享到朋友圈 onShareAppMessage: () =&gt; { }, onShareTimeline: () =&gt; { return { title: "测试小程序朋友圈分享", query: "id=110101&amp;name=heyzqt", imageUrl: "https://example.cn/test.png" } }, 单页模式 用户在朋友圈打开分享的小程序页面，虽然是小程序里的一个页面，但是不会真正打开小程序，可以理解成只用来预览的一个单页。
这个单页模式下顶部会固定有导航栏，底部固定有操作栏，且不可自定义，所以要考虑适配的问题。
默认预览的是当前小程序的内容，但因为单页模式下一些组件或接口有限制，比如页面无登录状态、wx.login均不可用，不能跳转其他页面、不能横屏、不会渲染tabBar、本地存储和小程序普通模式不共用。
所以在一些交互操作的时候，可能会弹出toast提示请前往小程序使用完整服务，所以微信官方建议分享朋友圈最好在纯内容场景分享的情况下使用。
最近微信官方也有很多对小程序利好的行动，比如H5跳转小程序开始公测了，企业红包封面故事跳转小程序，都挺有意思的，大家可以关注关注。
更多细节可以看微信开发者文档分享小程序到朋友圈
如果对你有帮助的话，点赞、评论、赞赏都是对我的鼓励，也是支持我写下去的动力，谢谢！
本文原创发布于微信公众号「程序员张晴天」，欢迎关注第一时间获取最新分享，一起进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b282b90240672e9fed82e2710d0637bb/" rel="bookmark">
			DPDK网卡设备加载流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、bus总线网卡设备扫描 函数在目录dpdk/lib/librte_eal/common/eal_common_bus.c
初始化流程在EAL环境初始化调用 ret_bus_scan函数完成的。内部会调用所有bus-&gt;scan接口的目的是扫描所有bus下注册的设备。
下面有bus设备注册、网卡驱动注册、以PCI设备的注册来详细说明注册流程。
1.1 bus设备注册 dpdk/lib/librte_eal/include/rte_bus.h
是由宏RTE_REGISTER_BUS，在程序启动时完成的注册，目前查询宏使用的地方如下。
/** * Helper for Bus registration. * The constructor has higher priority than PMD constructors. */ #define RTE_REGISTER_BUS(nm, bus) \ RTE_INIT_PRIO(businitfn_ ##nm, BUS) \ {\ (bus).name = RTE_STR(nm);\ rte_bus_register(&amp;bus); \ } RTE_REGISTER_BUS(FSL_DPAA_BUS_NAME, rte_dpaa_bus.bus);/*drivers/bus/dpaa/dpaa_bus.c*/ RTE_REGISTER_BUS(FSLMC_BUS_NAME, rte_fslmc_bus.bus)/*drivers/bus/fslmc/fslmc_bus.c*/ RTE_REGISTER_BUS(IFPGA_BUS_NAME, rte_ifpga_bus);/*drivers/bus/ifpga/ifpga_bus.c*/ RTE_REGISTER_BUS(pci, rte_pci_bus.bus);/*drivers/bus/pci/pci_common.c*/ RTE_REGISTER_BUS(vdev, rte_vdev_bus)；/*drivers/bus/vdev/vdev.c*/ RTE_REGISTER_BUS(vmbus, rte_vmbus_bus.bus);/*drivers/bus/vmbus/vmbus_common.c*/ 1.2 网卡全局rte_pci_bus的注册 我们重点学习网卡设备的注册，网卡设备全部注册到全局变量rte_bus_list链表上，遍历全局变量rte_bus_list，调用对应的回调函数scan，我看查下一下注册代码及通过链表找到pci的bus。
struct rte_pci_bus rte_pci_bus = { .bus = { .scan = rte_pci_scan, .probe = pci_probe, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b282b90240672e9fed82e2710d0637bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c57dfe92a975e2ea849200c9a5bc604d/" rel="bookmark">
			Vulkan Specification(Vulkan规范)：第十四章 14.6 内置变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		14.6. 内置变量 带有BuiltIn 修饰符修饰的变量是内置变量，可以在着色器内被访问。
每个 BuiltIn 修饰的含义有如下几种： 此节的剩余部分，内置变量的名称与术语带有内置修饰符的变量等同。 内置变量中整数类型的可以被声明为有符号或者无符号整数。
ClipDistance
Decorating a variable with the ClipDistance built-in decoration will make that variable contain the mechanism for controlling user clipping. ClipDistance is an array such that the ith element of the array specifies the clip distance for plane i. A clip distance of 0 means the vertex is on the plane, a positive distance means the vertex is inside the clip half-space, and a negative distance means the point is outside the clip half-space.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c57dfe92a975e2ea849200c9a5bc604d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dfd8383d337cd62f686d137db6acf1d/" rel="bookmark">
			Redis中string数据结构的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis有string、hash、list、set、zset几种数据结构，这些数据结构仅仅是面向使用者的上层结构，其底层的具体实现有多种。string的内部编码有三种：raw，embstr，int，其如图所示：
我们可以通过type命令查看数据结构类型，object encoding命令查看内部编码：
127.0.0.1:6379&gt; type hello string 127.0.0.1:6379&gt; object encoding hello "raw" 这里我们结合redis源码，来看一下这几种底层的数据结构是如何实现的。
redisObject Redis的设计颇有“万物皆对象”的意思，无论是string，还是hash等其他的数据类型，皆为redisObject,其结构体源码如下：
typedef struct redisObject { // 类型 unsigned type:4; // 编码 unsigned encoding:4; // 对象最后一次被访问的时间 unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */ // 引用计数 int refcount; // 指向实际值的指针 void *ptr; } robj; 当我们使用object encoding命令时，访问的就是该结构体内的encoding字段；ptr字段就是指向实际数据的指针。
sds(Simple Dynamic String) sds对象是字符串的底层实现，raw和embstr类型均基于此实现：
struct sdshdr { // buf 中已占用空间的长度 int len; // buf 中剩余可用空间的长度，初始化为0 int free; // 数据空间 char buf[]; }; len字段用于保存字符串长度，所以用strlen求字符串长度时，直接读取此值，时间复杂度为 O(1)；free字段指剩余可用的空间，新建字符串时该值为0；buf则为储存字符串的数组。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dfd8383d337cd62f686d137db6acf1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/781e9243a481c4f0b3862343bad404a7/" rel="bookmark">
			Vulkan Specification(Vulkan规范)：第十四章 14.4 片元着色器输入附件接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当管线将要执行到片元阶段，片元着色器subpass输入与当前subpass的输入附件之间 形成了一个接口。 片元着色器subpass输入变量与输入附件之间通过 InputAttachmentIndex修饰 匹配一致， 输入附件由VkSubpassDescription数据类型的数组name:pInputAttachments指定， 该数据结构描述了片元着色器执行时所在的subpass。
带有UniformConstant描述类型，且带有被OpEntryPoint 静态使用的一个OpEntryPoint的 片元着色器subpass 输入变量形成了 片元输入附件接口。 这些变量必须被声明为 OpTypeImage 类型，一个Dim维的SubpassData操作数， 一个Sampled 操作数为2。
InputAttachmentIndex修饰符指定的 一个subpass 输入变量 i 从 VkSubpassDescription 的pInputAttachments[i]成员指向的输入附件读取数据。 若此 subpass 输入变量被声明为N元素的数组，它消耗N个连续的输入附件，从指定的索引开始。 同一个InputAttachmentIndex 的输入变量不能多于1个，不管是通过显式还是隐式数组声明。 The number of 可用的输入附件索引个数是通过 VkPhysicalDeviceLimits 数据结构的maxPerStageDescriptorInputAttachments 成员指定的。
带有 InputAttachmentIndex的变量必须只能在片元阶段被使用。 subpass 输入的基础的数据类型(floating-point, integer, unsigned integer) 必须与对应的输入附件的基础格式要匹配， 否则subpass从这些变量中取出的值将是未定义的。
参考 输入附件 获取更多细节。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caf5dc5d74c73a02812f70ff495003a2/" rel="bookmark">
			Java 泛型数组（ T[] arr = new T[N]）创建报错之谜！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天小编在创建一个泛型数组的时候报了错。
代码如下:
class Stack&lt;T&gt; { private T[] list; private int n; private Stack(int capacity) { list = new T[capacity]; } } 报错信息如下:
Error:(15, 17) java: 创建泛型数组 从上面的错误信息可以推断出来Java不支持直接创建 T[] arr = new T[N]形式的泛型数组。
问题出在哪里？这个明明在逻辑上可以行得通的。
原因 原因在于 Java中的泛型擦除
1、Java泛型是使用擦除来实现的，这意味着在使用泛型的时候任何具体的类型信息都被擦除，唯一知道的就是在使用一个对象。
2、任何在运行时需要确切知道类型信息的操作都将无法工作。
这就不难理解了 new T[N] 对 T[] arr进行赋值时，意味着T[] arr要知道 new T[N]的数据类型。但是在运行时被擦除，，所以报错。
解决方案 方案一
一般的解决方案：在想要创建泛型数组的地方使用ArrayListprivate List&lt;T&gt; list = new ArrayList&lt;&gt;(); 方案二
成功创建泛型数组的唯一方式就是创建一个被擦除类型的新数组，然后对其转型。private T[] list; private int size; public ArrayLinkedStack(int capacity) { list = (T[]) new Object[capacity]; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5ef62e894f571b9e3b3c6aeb847f46b/" rel="bookmark">
			sklearn快速入门教程：（五）集成学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sklearn快速入门教程–（五）集成学习 一、集成学习简述 集成学习是目前各类竞赛和工程中应用最广泛的模型提升方法。比如在kaggle中就有关于集成学习的介绍（Kaggle模型融合原文）。这里所谓的模型融合实际上主要就是集成学习方法。
常见的集成学习有以下几种：
BoostingBaggingStacking 其中boosting和bagging应用最多。比如目前流行的xgboost就是(gradient)boosting的一种，而random forest则是bagging的一种。
二、集成学习的两种主要思路 各种集成学习的思路不尽相同，尤其对于初学者通常一看到集成学习的理论都会很头疼。那么要快速学会集成学习的使用，就先要对其关键的思路有所了解。
顾名思义，集成学习是将多个模型放在一起，通过某种方式将其组合起来，从而得到一个统一的预测模型。自然地，在集成之前就要有基本的模型用于集成。目前所用的集成学习模式主要分为两种：
采用同一基模型，在样本的不同子集上进行训练，从而得到对应的多个不同的具体模型。这类学习方法的代表就是boosting, bagging。采用多种基模型，在同一样本上进行训练，将多个模型组合起来得到具体模型。voting和stacking都是采用这类方式。 明白这一点之后其实就很容易分析sklearn中的对应方法了，对单一模型对应的方法，它的语法通常是这样：
ensemble_method(estimator,**args) 这里estimator是指sklearn中的基模型，比如Tree，LinearRegression等都属于这一类型，而**args则表示其它参数。结合上一教程中的内容不难想到，这个estimator实际上就是一种通用模式，也就是说它只要属于这一类型，其它的方面就可以完全自由设定。比如我想用一个SVC来进行集成，同时又想指定它的核函数，那么就可以直接将SVC(kernel='rbf')传入函数。这种灵活的操作方式会给我们各类改进和提升提供便利。
而对于多个模型通常是这样：
ensemble_method(estimators,**args) 注意这里是estimators，也就是多个模型。那么很自然地想到多个模型肯定是以集合的形式输入。事实上在sklearn中，这里是用列表表示多个模型，而每个模型则由其名称和实体类型来表示。比如：
estimators = [ ('lr', RidgeCV()), ('svr', LinearSVR(random_state=42)) ] 可想而知，如果有更多的模型，则直接在列表中继续加入即可。
三、单一模型集成 - - 以Adaboost为例 这里我们以iris数据集作为样本，将100个Logistic Regression模型用Adaboost集成起来。
from sklearn.model_selection import cross_val_score from sklearn.datasets import load_iris from sklearn.ensemble import AdaBoostClassifier from sklearn.linear_model import LogisticRegression X, y = load_iris(return_X_y=True) clf = AdaBoostClassifier(LogisticRegression(), n_estimators=100) clf.fit(X,y) clf.predict(X)	运行结果：
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2]) 可以看到，在sklearn中实现这样的集成学习是非常简单的，只需要一句代码即可。训练和预测和直接使用机器学习模型是完全一样的语法。这一点也是sklearn中一个亮点，它尽最大可能减小了程序员去背工具模式的工作，从而可以将更多精力集中在问题本身。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5ef62e894f571b9e3b3c6aeb847f46b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8c25182116d0728ad659e0e2a9bca77/" rel="bookmark">
			c&#43;&#43;算法全套流水账——排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序 大家好，cht又来唠叨算法了 今天我们说说 排序！ 咳咳，我们先说说最简单的三种排序: 快速排序 归并排序 冒泡排序 cht在这里提示大家,模板不能死记硬背哦 1、冒泡排序 作为如此老套的算法，大家应该并不陌生 冒泡排序的思路是什么呢？就是把数列中所有不成顺序的数交换。 （其实就是暴力算法） 时间复杂度 O(n²) 没有听懂的同学们再来看看图吧。 注意！这里的排序是倒向的（a &gt; b &gt; c）。 接下来给大家看看动态图 现在大家应该都明白什么是冒泡排序了吧。 接下来我们来看看c++代码（我的代码和动态图不同） #include&lt;iostream&gt; #include&lt;algorithm&gt;//swap函数 using namespace std; const int N = 100010;//...+10!!! int n;//需要排列的数的个数 int q[N];//排序数组 int main() { scanf("%d",&amp;n);//提速，最好用scanf for(int i = 0; i &lt; n; i ++) scanf("%d",&amp;q[i]); //模板区（自己搞的，有错误请多多指正） for(int i = 0; i &lt; n; i ++) for(int j = 0; j &lt; n &amp;&amp; j !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8c25182116d0728ad659e0e2a9bca77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef6b7b9689524cd4728dcd8e320ea441/" rel="bookmark">
			通过snmp获取设备和系统信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、打开snmp服务 以server2008为靶机测试。 从开始-&gt;管理工具-&gt;打开服务管理器 在服务器管理器中选择功能 选择添加功能 在SNMP处打勾 按下一步进行安装（此处已经安装完成） 打开服务器管理器中的配置-&gt;服务选项 在服务中找到SNMP Service 并点击右键 属性 在属性中打开：安全 ，并添加社区public 下方选择 接受来自任何而主机的SNMP数据包 之后如下图所示确认即可 注：该靶机地址为192.168.0.108
二、SNMP扫描工具onesixone的使用 命令：onesixtyone 192.168.0.108 public public：团体社区名称 若不知道团体社区名称 可使用字典代替 可使用命令dpkg -L onesixtyone 查看onesixtyone自带字典 也可自己添加字典 命令：onesixtyone -c /usr/share/doc/onesixtyone/dict.txt 192.168.0.108 -o 123.log -w 100 -c ：指定字典路径 -o ：导出日志 -w 100 ： 发送包之间等待100毫秒 若扫描出现乱码可用命令 apt-get install onesixtyone 进行更新软件
三、snmpwalk命令的使用 snmpwalk 192.168.0.108 -c public -v 2c -v: 指定SNMP协议版本 有1|2c|3 一般使用2c -c: 密钥 指定连接设备SNMP读密码 （该命令获取到所有的系统信息 内容较多，可添加参数进行针对查询） 1.获取ip信息
snmpwalk 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef6b7b9689524cd4728dcd8e320ea441/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0205e1f33167f23700d320c64fe57f40/" rel="bookmark">
			如何将一个字典写入文本文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python3的写法中，将一个字典写入文件的两种方法：
1.导入json包，使用json.dumps读取文本变为字典
import json #创建一个字典 dict ={"name":'图图',"age":'3'} with open('file.txt', 'w') as file: file.write(json.dumps(dict)) 2.遍历整个字典，分别输出key,value值
fr = open(r"文件路径","a+",encoding="utf-8") dict ={"name":图图,"age":3} #遍历整个字典，输出key,value值 for k,v in dict.items(): fr.write("输入key值"+str(key)) fr.write("输入value值"+str(value)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b694acfdad5cfefa9191f5fb566e60d/" rel="bookmark">
			生物信息学工具——vcftools手册（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生物信息学工具之vcftools（1） vcftools安装 作者本人是用winscp连接了学校的平台，使用linux语言，对vcftools工具进行安装和使用。得到的结果基本都选用python进行处理或可视化。凡是软件都要从安装讲起。这次也不例外。
作者讲述的安装方法是基于linux语言的。
1.get一个安装包 可以从网上搜索一下vcftools很容易就能get到它的安装包。
这里放一个作者找到的网页链接：https://sourceforge.net/projects/vcftools/files/
也可以通过作者的网盘获取作者使用的vcftools版本：#######这里有个坑，等着作者来填########
2.解压&amp;安装 如果你的安装包是以压缩包形式下载的，就用下面的语句进行解压。
tar -xvf vcftools.0.x.xx.tar.gz 代码中vcftools.0.x.xx.tar.gz，替换成你下载的压缩包的具体名字。
VCFtools中的某些脚本要求VCF文件由bgzip压缩，并由tabix建立索引。
这两个工具都是tabix包的一部分，可以从这里下载：https://sourceforge.net/projects/samtools/files/tabix/
运行VCFtools Perl脚本，必须将PERL5LIB环境变量设置为包含Vcf.pm模块。操作语句如下：
对路径描述是到vcftools文件夹中src文件夹下的perl文件夹
export PERL5LIB=/path/to/your/vcftools-directory/src/perl/ 现在编译程序。更改当前目录到指定的目标目录。
cd vcftools/	./configure	make make install 默认情况下，编译后的程序现在位于vcftools/bin/目录中。
可能会出现一些常见的编译器错误，例如无法定位Vcf.pm或者无法找到zlib。
如果出现这种情况，请访问zlib页面以获得安装说明，或者编辑上面解释的PERL5LIB变量。
或者，如果已经使用git克隆了最新的存储库版本，请使用以下命令集安装vcftools:
cd vcftools/ ./autogen.sh	./configure	make	make install 为了能够在命令行中使用工具，我们需要把这些工具都加入到系统环境变量中。
语句如下：
vcftools加入路径时，对路径描述的一定要一直到bin文件夹下。
export PATH=$PATH:/data/software/vcftools/vcftools-build/bin/ 作者的情况是，每次推出命令行，都要重新输入上面的语句，将bin文件夹加入到环境变量中。
文章参考vcftools使用手册，同时加入作者部分作者经验。如有版权问题，请联系作者，作者将及时删除。
vcftools手册链接：http://vcftools.github.io/man_latest.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/850154d3daf3c9bde489de7ba55d488b/" rel="bookmark">
			HC-SR04超声波模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.硬件原理图 2.传感器参数表 电气参数HC-SR04 超声波模块工作电压DC 5 V工作电流15mA工作频率40kHz最远射程4m最近射程2cm测量角度15 度输入触发信号10uS 的 TTL 脉冲输出回响信号输出 TTL 电平信号，与射程成比例规格尺寸452015mm 3.引脚功能表 HC-SR04实物图
HC-SR04功能引脚表
引脚说明VCC接5VGND地线TRIG触发控制信号输入ECHO回响信号输出 4.工作原理 （1）给超声波模块接入电源和地
（2）给脉冲触发引脚（trig）输入一个长为20us的高电平方波
（3）输入方波后，模块会自动发射8个40KHz的声波，与此同时回波引脚echo端的电平会由0变为1;（此时应该启动定时器计时）
（4）当超声波返回被模块接收到时，回波引脚端的电平会由1变为0;（此时应该停止定时器计数），定时器记下的这个时间即为超声波由发射到返回的总时长
（5）根据声音在空气中的速度为344米/秒，即可计算出所测的距离。
超声波时序图
以上时序图表明你只需要提供一个 10uS 以上脉冲触发信号，该模块内部将发出 8个 40kHz 周期电平并检测回波。一旦检测到有回波信号则输出回响信号。回响信号的脉冲宽度与所测的距离成正比。由此通过发射信号到收到的回响信号时间间隔可以计算得到距离。建议测量周期为 60ms 以上，以防止发射信号对回响信号的影响。公式： uS/58=厘米 uS/148=英寸； 距离= 高电平时间*声速（340M/S）/2 5.流程图 硬件运行流程图
时间的输入捕获流程图
6.注意事项 （1）公式中为什么要除以58？ 我们作一下单位换算，34,300除以1,000,000厘米/微秒。 即为：0.0343厘米/微秒
再换一个角度，1/（0.0343 厘米/微秒） 即：29.15 微秒/厘米。1厘米就29.15微秒。
但是发送后到接收到回波，声音走过的是2倍的距离。所以实际距离就是1厘米，对应58.3微秒。
（2）高电平的测量 我们使用通用定时器的输入捕获来测量高电平时间，所以使用的过程中要注意结果是否溢出 （3）消抖 由于超声波测量一次的时间很短，测量一次很有可能出错，所以我们可以多测几次求平均值来进行消抖。 （4）使用的注意事项 此模块不宜带电连接，若要带电连接，则先让模块的 GND 端先连接，否则会影响模块的正常工作。 测距时，被测物体的面积不少于 0.5 平方米且平面尽量要求平整，否则影响测量的结果 7.基于stm32-mini的代码模块 Ultrasonic.h模块 #ifndef __ULTRASONIC_H #define __ULTRASONIC_H #include "sys.h" #define trig PBout(2) //超声波输出 #define echo PBin(3) //超声波输入 void TIM3_Int_Init(u16 arr,u16 psc); //计数器使能 void Ultrasonic_Init(void); //超声波初始化 void open_Ultrasonic(void); //打开超声波 void close_Ultrasonic(void); //关闭超声波 int accept_Ultrasonic(void); //计算距离 int get_val(void); //消抖 #endif Ultrasonic.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/850154d3daf3c9bde489de7ba55d488b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3816463cacca5f0f9e243fdcf1924ce/" rel="bookmark">
			DPDK 内存管理---malloc_heap和malloc_elem
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博文是基于dpdk20.5代码阅读所写，如理解有错误或不当之处，烦请指正，不甚感激。也可以私信我一起探讨。
两种数据结构体介绍 Malloc 库内部使用了两种数据结构类型（可以参考dpdk官方文档3.4.4章节介绍）：
struct malloc_heap：用于在每个 CPU Socket 上跟踪和管理可用内存空间。
struct malloc_elem：Malloc 库内部用于追踪分配和释放空间的基本要素。
基本内存分布结构说明 malloc_elem介绍 elem是heap管理内存的基本单元，内存的添加和删除都是基于elem结构来操作的，内存块有三种状态，具体如下：
enum elem_state { ELEM_FREE = 0, /*表示当前elem块是空闲的*/ ELEM_BUSY, /*表示当前elem块已经被使用的*/ ELEM_PAD /*表示当前elem块已经使用并且是pad形势*/ }; 一个elem被分为三个段，elem header（管理头）、data（存放数据部分）、Trailer cookie（debug打开时有效，主要用户检测内存是否存在越界） 三部分。具体分布如下：
当申请elem1块剩余空间小于elem最小内存时，会创建一个ELEM_PAD 类型的elem2块。ELEM_PAD 数据块内存状态如下，主要原因是rte_malloc 是返回data区域的首地址，通过数据首地址-malloc elem结构大小可以找到elem2块的地址，根据elem2的类型是ELEM_PAD，使用elem2地址-elem2-&gt;pad可以直接找到elem1的首地址，管理起来很方便,但是会造成内存的浪费，在频繁申请小内存时，空间浪费比较多。
malloc_elm结构还有两个比较关注的数据prev和next
这两个指针用于指向紧跟这当前 memseg 的头元素。当释放一个内存块时，该指针用于引用上一个内存块，检查上一个块是否也是空闲。如果空闲，则将两个空闲块合并成一个大块。双向链表的关系必须是前后内存连续的并且参数中msl和orig_elem，这样才能进行合并。
static int next_elem_is_adjacent(struct malloc_elem *elem) { return elem-&gt;next == RTE_PTR_ADD(elem, elem-&gt;size) &amp;&amp; elem-&gt;next-&gt;msl == elem-&gt;msl &amp;&amp; (!internal_config.match_allocations || elem-&gt;orig_elem == elem-&gt;next-&gt;orig_elem); } malloc_heap介绍 在EAL初始化时，所有预先分配的内存段都被设置成malloc heap的一部分，这种设置包括在每个几乎连续的内存段的开头放置一个带有free的elem内存块。然后将free 的elem内存块添加到malloc heap的free_head 链表中。
这种设置也会在运行时候发生如果支持的话（leacy mem是不支持的），在这种情况下，还会将新分配的页面添加到堆中，如果有空闲段，则与相邻的空闲段合并。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3816463cacca5f0f9e243fdcf1924ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afdd4b4ea887d24407b4d5a671e0afd1/" rel="bookmark">
			TCP怎么保证传输的安全性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/sunlong88/p/12845035.html
一、TCP保证可靠性的两个协议：
1. 停止等待协议
每发送完一个分组，就停止发送，等待对方确认，收到确认后再发送下一个分组。
2. 连续ARQ协议
利用滑动窗口，位于滑动窗口内的所有分组都可以连续的发送出去，而不需要逐个等待对方的确认。A每收到一个确认，就把发送窗口向前滑动一个分组的位置。B采用累积确认的方式，对按序到达的最后一个分组发送确认（就是最后这个分组的编号），就表示这个分组之前的所有分组都收到了。
（1）优点：信道利用率高，容易实现，即使确认丢失，也不必重传。
（2） 缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。
二、TCP心跳机制：
心跳机制是定时发送一个自定义的结构体(心跳包)，让对方知道自己还活着，以确保连接的有效性的机制。
心跳检测步骤：
1.客户端每隔一个时间间隔发生一个探测包给服务器
2.客户端发包时启动一个超时定时器
3.服务器端接收到检测包，应该回应一个包
4.如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器
5.如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了
心跳包的发送，通常有两种技术：
1、应用层自己实现的心跳包
2、TCP的KeepAlive保活机制
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/479df13edf2da36a850ce185c64ad6bd/" rel="bookmark">
			IjkPlayer【1】 Demo Android的最简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、目的 Ijkplayer最为一个经典的视屏播放开源框架，虽然是开源框架对于刚入门的人来说看到源码以及脚本的各种操作肯定是无从下手，这里先把Ijkplayer简化为一个最简单的项目只是简单的播放，当实现了播放后可再根据自己的需要的功能去查api，这个项目向当前ijkplayer的"hello world"。只需要按照以下步骤就可以实现播放。
当完成ijkpler的"hello world"后肯定你会想知道更多的功能函数，下一篇介绍使用的功能函数 IjkPlayer【2】 API 查询
二、创建项目以及基础配置 1）创建项目后在model的build.gradle的dependencies{}中添加添加以下依赖。 ijkplayer 可以直接依赖源码也可以依赖官方打包好的库，这里作为最简单的实现直接使用官方打包好的库，
如果开发涉及到Java层逻辑可以将源码中的ijkplayer-java文件夹作为Model库添加到项目中，然后把"tv.danmaku.ijk.media:ijkplayer-java:0.8.8" 替换为ijkplayer-java Model。如果开发涉及到Native部分就需要根据官网提示的步骤操作编译源码。
dependencies { //========ijkplaer Java部分依赖 implementation 'tv.danmaku.ijk.media:ijkplayer-java:0.8.8' //google ExoPlayer播放的扩展，一般无需添加 //implementation 'tv.danmaku.ijk.media:ijkplayer-exo:0.8.8' //========ijkplaer Native部分依赖(根据运行CPU的平台选择) //使用真机测试 添加以下依赖 implementation 'tv.danmaku.ijk.media:ijkplayer-armv7a:0.8.8' //使用电脑模拟器 添加以下依赖 implementation 'tv.danmaku.ijk.media:ijkplayer-x86:0.8.8' implementation ile 'tv.danmaku.ijk.media:ijkplayer-x86_64:0.8.8' //其他CPU平台 //implementation 'tv.danmaku.ijk.media:ijkplayer-armv5:0.8.8' //implementation 'tv.danmaku.ijk.media:ijkplayer-arm64:0.8.8' } 2）在AndroidManifest.xml添加网络权限 &lt;uses-permission android:name="android.permission.INTERNET"&gt;&lt;/uses-permission&gt; 3)在layout中添加SurfaceView作为显示控件 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;SurfaceView android:id="@+id/surfaceView" android:layout_width="match_parent" android:layout_height="match_parent"&gt;&lt;/SurfaceView&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 4）添加主业务逻辑代码 public class MainActivity extends AppCompatActivity { private SurfaceView showView; private IjkMediaPlayer ijkMediaPlayer; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/479df13edf2da36a850ce185c64ad6bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f95051bfa9e506d39bfb0328360e5f3a/" rel="bookmark">
			html &#43; css &#43; js使用HBuilder开发工具做2048益智游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2048–&gt;html + css + js使用HBuilder开发工具做2048益智游戏 今天使用html + css + js给同学们做了一个简易版的2048益智游戏，希望大家按照步骤勤加练习，在编码的坑里早日踏上康庄大道，祝前程似锦！
效果图：
附源码github链接:
https://github.com/LittleGreyKing-FriedBlackYoFeed-xoox/2048.git
开发思路：
一、使用HBuilder工具创建空白html项目
创建项目时路径尽量不要有中文路径
二、创建js和css文件备用
项目目录：
三、书写html标签
引入css和js文件：
书写html标签：
html标签的代码，直接放在body标签中即可:
index.html
&lt;header&gt; &lt;h1&gt;2048&lt;/h1&gt; &lt;/header&gt; &lt;div id="gamePanel"&gt; &lt;p&gt;&lt;a class="button" id="newGame"&gt;New Game&lt;/a&gt; Score: &lt;span id="score"&gt;0&lt;/span&gt;&lt;span class="writer"&gt;小灰灰版&lt;/span&gt;&lt;/p&gt; &lt;div id="gridPanel"&gt; &lt;div class="grid"&gt; &lt;/div&gt; &lt;div class="grid"&gt; &lt;/div&gt; &lt;div class="grid"&gt; &lt;/div&gt; &lt;div class="grid"&gt; &lt;/div&gt; &lt;div class="grid"&gt; &lt;/div&gt; &lt;div class="grid"&gt; &lt;/div&gt; &lt;div class="grid"&gt; &lt;/div&gt; &lt;div class="grid"&gt; &lt;/div&gt; &lt;div class="grid"&gt; &lt;/div&gt; &lt;div class="grid"&gt; &lt;/div&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f95051bfa9e506d39bfb0328360e5f3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb70944ce936384e91da4236f3b5196a/" rel="bookmark">
			异步加载设置元素的scrollTop不生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方案：scrollTop需要在异步加载完成后再调用，因为是异步的，在去后台获取数据的时候，如果scrollTop就触发了，那么就出现不生效的情况
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d45b556fc3640d7c8d6f58a075441e21/" rel="bookmark">
			P5704 【深基2.例6】字母转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原题链接
题目描述
输入一个小写字母，输出其对应的大写字母。例如输入 q[回车] 时，会输出 Q。
输入格式
无
输出格式
无
输入样例
q
输出样例
Q
源码
package com; import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner s=new Scanner (System.in); String a=s.next(); System.out.printf("%c",a.charAt(0)-32); } } 以上代码仅供参考
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2490f4b249394d55ef8309bfa93f1dcf/" rel="bookmark">
			Java 面试题基础 -总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 面试题基础(一) 如想了解更多更全面的Java必备内容可以阅读：所有JAVA必备知识点面试题文章目录：
JAVA必备知识点面试题 1、面向对象的特征有哪些方面？
答：面向对象的特征主要有以下几个方面：
抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽 象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的 细节是什么。 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类 被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让 变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要 手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中 关于桥梁模式的部分）。
第 212 页 共 485 页 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问 只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自 治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写 一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西， 只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别， 明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是 封装得足够好的，因为几个按键就搞定了所有的事情）。 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。 简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分 为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的 服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B 系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须 刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电， 甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道 供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载 （overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override） 实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的 东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已 有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样 的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 2、访问修饰符public,private,protected,以及不写（默认）时的区别？
修饰符当前类同 包子 类其他包public√√√√protected√√√×default√√××private√××× 类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公 开（public），对于不是同一个包中的其他类相当于私有（private）。受保护 （protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私 有。Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的 修饰符可以是以上四种。
3、String 是最基本的数据类型吗？
答：不是。Java 中的基本数据类型只有 8 个：byte、short、 char、int、long、float、double、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。
4、float f=3.4;是否正确？
答:不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于 下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换 float f =(float)3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2490f4b249394d55ef8309bfa93f1dcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0010883cf03f5b67c80e94ee2975ff11/" rel="bookmark">
			【Python】 第3章-3 输出字母在字符串中位置索引 (20分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入一个字符串，再输入两个字符，求这两个字符在字符串中的索引。
输入格式: 第一行输入字符串
第二行输入两个字符，用空格分开。
输出格式: 反向输出字符和索引，即最后一个最先输出。每行一个。
输入样例: 在这里给出一组输入。例如：
mississippi s p 输出样例: 在这里给出相应的输出。例如：
9 p 8 p 6 s 5 s 3 s 2 s 【Python参考代码】 ①版本一，稍微冗杂了点 #By yangbo 2020.07.10 n=input() a,b=input().split() for i in range(len(n)):#这里没有range 的是正的：0 1 2 3 4 。。。。 if n[len(n)-1-i] == b: #在遍历时才逆序遍历 print((len(n)-1-i),b)#打印字符b,所以才有两个if。若是打印n[i](此时n[i]==b),这样程序更好 elif n[len(n)-1-i] == a: print((len(n)-1-i),a) ②进阶版，索引直接逆序、输出合二为一 #By yangbo 2020.07.10 n=input() a,b=input().split() for i in range(len(n)-1,0,-1): #反向输出字符和索引 if n[i] == b or n[i] == a: print(i,n[i]) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9c62814d4481f5893284ddf7ac199f4/" rel="bookmark">
			关于MATLAB图形设置的参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、绘图函数中的参数（以plot为例1.'Color'2.'LineStyle'3. 'LineWidth'5.'MarkerIndices'6.'MarkerEdgeColor'7.'MarkerFaceColor'8.'MarkerSize'9.关于plot的输出 二、查看与修改图像属性的函数1.get2.set(1)gcf(2)gca 一、绘图函数中的参数（以plot为例 1.‘Color’ 设置线的颜色
用法：
plot(x,y,'Color',[x x x]) % or plot(x,y,'Color','x') 颜色选项(‘x’)等效RGB格式([x x x])‘r’[1 0 0]‘g’[0 1 0]‘b’[0 0 1]‘y’[1 1 0]‘m’[1 0 1]‘c’[0 1 1]‘w’[1 1 1]‘k’[0 0 0] 使用TOC语法后生成一个完美的目录。
2.‘LineStyle’ 设置线的样式
用法：
plot(x,y,'LineStyle','x') 选项(‘x’)描述‘-’实线‘–’虚线‘:’点描线‘-.’点划线‘none’无线 运算结果是 1024.
3. ‘LineWidth’ 设置线宽
用法:
plot(x,y,'LineWidth',0.75) arker’
设置点的样式
用法：
plot(x,y,'Marker','x') 选项(‘x’)描述‘o’圆形‘+’加号‘*’星号‘.’点‘x’叉‘s’正方形‘d’菱形‘^’上三角形‘p’五角星 5.‘MarkerIndices’ 显示标记的索引点，常与’Marker’连用
用法:
x = 0:.1:10; y = sin(x); plot(x,y,'Marker','o','MarkerIndices',[1 5 10]) %第1 5 10个数据点将用圆形标注出来 6.‘MarkerEdgeColor’ 设置数据点的边缘颜色
用法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9c62814d4481f5893284ddf7ac199f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2b2468a966cc635c95fbe79bfd88ea5/" rel="bookmark">
			托管 非托管_如何在托管Kubernetes上还原Neo4J备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		托管 非托管
在下面的视频中，我将解释如何将Neo4J实例的备份还原到在托管Kubernetes环境中运行的新实例。 备份内容将从先前写入备份的持久卷中获取。 在上一篇文章中，您可以首先了解如何进行备份。 自己尝试 同样，您将在以下GitHub存储库中找到Kubernetes资源。 cd /tmp/ git clone https: //github.com/sdaschner/neo4j-tools cd neo4j-tools/ 我们需要确保拥有可用的backupdir-和datadir- persistent卷。 您可以查看以前的帖子以及有关我们如何到达那里的视频。 数据目录仅包含一个空数据库，我们将从备份中还原该数据库。 以下pod将绑定两个卷，还原备份并将结果写入数据目录，此后可在我们的Neo4J实例中再次使用： kubectl apply -f backup/neo4j-restore-backup.yaml NAME READY STATUS RESTARTS AGE neo4j-restore-backup 0 / 1 Completed 0 13s 如果现在再次启动Neo4J实例（例如， 单核实例），我们将看到数据库内容已还原。 翻译自: https://www.javacodegeeks.com/2020/06/how-to-restore-a-neo4j-backup-on-managed-kubernetes.html
托管 非托管
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a5903b8e79311b5b31756e1bde74d46/" rel="bookmark">
			restful和rest_HATEOAS的RESTful服务：JVM上的REST API和超媒体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		restful和rest
1.简介 到目前为止，我们已经花了很多时间谈论了相当数量的关于角色的的超媒体和HATEOAS在REST风格的 Web服务和API，扫视不同规格和可用性方面。 听起来好像支持超媒体和HATEOAS并不难，只需选择您的收藏夹就可以了！ 您可能会猜到，现实是“好，取决于情况”，在本教程的这一部分中，我们将理解“为什么”。 困难的学习方法是从头开始设计和实现它们。 这正是我们将要忙的事情，主要在Java中将RESTful Web API和客户端引入JVM平台。 我们将为其设计RESTful Web API的应用程序是我们之前涉及的案例研究的扩展版本。 从业务角度来看，我们将实施一个可以让客户租车的租车平台。 我们的目标是根据REST架构风格的原则和约束来构建该平台。 目录 1.简介 2.从CRUD到工作流程 3.在服务器上 3.1。 JAX-RS 3.2。 Quarkus，Micronaut，Helidon…… 3.3。 Crnk 3.4。 Spring帽子 3.5。 九头蛇 4.在客户端上 4.1。 JAX-RS 4.2。 Crnk 4.3。 Spring帽子 5。结论 6.接下来 7.下载源代码 2.从CRUD到工作流程 超媒体作为驱动力的存在极大地改变了设计过程。 不幸的事实是，目前大多数基于HTTP的Web服务和API基本上都是CRUD代理，用于其后面的数据存储。 仅仅公开数据模型并不能帮助客户理解他们可以做什么，他们注定要在许多地方复制服务器的业务逻辑（至少是业务逻辑的大部分）。 这不是经过深思熟虑的REST应用程序应该做的。 REST API应该花费几乎所有的描述性精力来定义用于表示资源和驱动应用程序状态的媒体类型，或者为现有标准媒体类型定义扩展关系名称和/或启用超文本的标记。 花费所有精力描述应该在媒体类型的处理规则范围内（并且在大多数情况下已由现有媒体类型定义）完全定义对感兴趣的URI使用哪种方法。 https://roy.gbiv.com/untangled/2008/rest-apis-must-be-超文本驱动 代替CRUD ，我们应该将RESTful Web API视为工作流。 通过就适当的媒体类型达成共识，服务器和客户端可以就如何解释它们达成共识。 链接，关系和操作（支付能力）的存在会引导客户采取可能的后续步骤。 换句话说，服务定义并共享供客户遵循的工作流。 3.在服务器上 在深入研究库和框架之前，最好先了解我们正在尝试作为应用程序一部分构建的RESTful Web API的工作流程。 下图是这样做的尝试。 租车API工作流程 诚然，工作流远非详尽无遗，但足以说明现实世界中RESTful Web API的复杂性，挑战和好处。 最后但并非最不重要的一点是，我们尚未决定要使用哪种超媒体规范 。 HAL的简单性，轻量级结构和广泛采用（以及HAL-FORMS ）使其成为大多数情况下的不错选择，这就是我们将用于RESTful Web API的方式。 制定战略决策后，就该讨论技术细节了。 首先，我们正在寻找对我们有帮助的库或框架。 JAX-RS Jakarta RESTful Web服务规范（更好地称为JAX-RS 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a5903b8e79311b5b31756e1bde74d46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f8688041d44bb7f573da5de05836fea/" rel="bookmark">
			cadence allegro 怎么进行drc检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		菜单栏setup —&gt;enable on-line drc 可以开启在线drc检查，鼠标放在右下角drc的颜色框上可以看到on line drc是否是开启状态。
DRC检测的步骤：“tools”–“update DRC”
所有的DRC检测项设置在“setup”–“constraints”–“modes”，负责DRC的开启和关闭。
如果有DRC错误，就在PCB会出现红色的警告的，比如“PP”，这个是package和package之间的间距小于规则设置。可以在网上搜索所有的DRC错误，就能判断哪块有问题了。
如果板子很大，不容易看到DRC错误，修改drc显示大小，“setup”–“design parameter”–“display”，改大“DRC marker size”的值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b070b354d4e984f1ab954b279117c6c/" rel="bookmark">
			HTML标签及案例超详细笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML标签及案例超详细笔记 引言：
本文主要分享了有关HTML的内容包括：HTML的特点、基本结构，HTML的基本标签（结构标签、排版标签、标题标签、滚动标签、文本格式化标签、容器标签、列表标签、超链接标签、图片标签以及表格标签、表单标签、框架标签）最后分享一个表格嵌套的案例；
文章目录 HTML标签及案例超详细笔记1. HTML概述1.1 HTML特点1.2 HTML基本结构 2. HTML基本标签2.1 结构标签2.2 排版标签2.3 标题标签2.4 滚动标签2.5 原样输出标签2.6 文本格式化标签2.7 容器标签2.8 列表标签2.8.1 无序列表2.8.2 有序列表2.8.3 定义列表 2.9 超链接标签2.9.1 连接到的url2.9.2 作为锚点 2.10 图片标签2.11 表格标签2.11.1 普通表格2.11.2 表格的表头2.11.3 表格的列合并2.11.4 表格的行合并2.11.5 表格的拆分 2.12 表单标签2.12.1 标签属性2.12.2 表单的两种提交方式2.12.3 标签案例 2.13 利用表单标签完成登录2.14 框架标签2.14.1 Framset2.14.2 左边菜单页2.14.3 头部文件2.14.4 中间页面2.14.5 底部页面 3. 基本标签的综合案例 1. HTML概述 HTML：Hyper Text Markup Language（超文本标记语言）；是一门用户创建网页文档的标记语言，网页本身是一种文本文件，在文本文件中添加标记符。HTML是用来创建网页的标记语言，HTML标记的内容是用浏览器来解析的；
1.1 HTML特点 1、简易性：超文本标记语言的版本升级采用的超集方式，更加方便灵活；
2、可扩展性：超文本标记语言采取的子类元素的方式，为系统扩展带来保证；
3、平台无关性：只要有浏览器就行；
4、通用性：HTML是网络的通用语言，一种简单、通用的标记语言；
1.2 HTML基本结构 &lt;!-- 文档声明：文档的类型 --&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;!--网页的头部 --&gt; &lt;head&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b070b354d4e984f1ab954b279117c6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c8ca9564c469a3044de6f13c2f518c5/" rel="bookmark">
			操作系统课后考前勾课后习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 第一题 1、有一台计算机，具有IMB 内存，操作系统占用200KB ，每个用户进程各占200KB 。如果用户进程等待I/O 的时间为80 % ，若增加1MB 内存，则CPU 的利用率提高多少？
答:
CPU利用率＝1-（80%)^4 = 0.59
若再增加1MB 内存，系统中可同时运行9 个用户进程，此时：
cPu 利用率＝1-（80%)^9 = 0.87
故增加IMB 内存使CPU 的利用率提高了47 % :
87 ％/59 ％=147 %
147 ％-100 % = 47 %
第二题 2 一个计算机系统，有一台输入机和一台打印机，现有两道程序投入运行，且程序A 先开始做，程序B 后开始运行。程序A 的运行轨迹为：计算50ms 、打印100ms 、再计算50ms 、打印100ms ，结束。程序B 的运行轨迹为：计算50ms 、输入80ms 、再计算100ms ，结束。试说明（1 ）两道程序运行时，CPU有无空闲等待？若有，在哪段时间内等待？为什么会等待？( 2 ）程序A 、B 有无等待CPU 的情况？若有，指出发生等待的时刻。
答：画出两道程序并发执行图如下：
（1）两道程序运行期间，CPU存在空闲等待，时间为100 至150ms 之间（见图中有色部分）
（2）程序A 无等待现象，但程序B 有等待。程序B 有等待时间段为180rns 至200ms 间（见图中有色部分）
第四题 4在单CPU 和两台 I/O( I1 , 12 ）设备的多道程序设计环境下，同时投入三个作业运行。它们的执行轨迹如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c8ca9564c469a3044de6f13c2f518c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49d0336db5491b11dcbc1db83d7c8a20/" rel="bookmark">
			Elsevier 图形规范 Artwork
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总览 文件格式
EPS preferred 位图 （首选）
PDF 应用越来越广泛
TIFF bitmap pixels images选用。照片艺术图
注意：eps无法导出时，可以导出到pdf，或者以打印机方式到pdf，检查未进行降采样。
字体
Arial Helvetica Times
用希腊字母表示符号字体
命名
FIG1.eps
图片大小 长宽 elsevier图片大小官网
知乎必看
绝大多数 SCI 期刊对于插图排版的规格有三种版式：单栏图、1.5 栏图、双栏图。在写图片latex需要注明是几栏图。所有图高度最好不超过24cm，但是官网没有具体要求。宽度要求如下
单栏图 8~9cm
双栏图 11.4~14cm
双栏图 17.1~19cm
分辨率 分辨率科普
官网分辨率的要求：
Image resolution, number of pixels and print size are related mathematically: Pixels = Resolution (DPI) × Print size (in inches); 300 DPI for halftone images; 500 DPI for combination art; 1000 DPI for line art.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49d0336db5491b11dcbc1db83d7c8a20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc85767caaca3bf53b5be05de0ce9bbf/" rel="bookmark">
			Android 一个条形动画加载效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果 完整代码，复制即用，请拉到底部
可以对颜色、线条数、动画幅度、宽度等进行设置，上图只是一个基本的效果~
思路 先确定了想实现的效果是这样的：
整体分为中、高、低三种线，计算出三种线条的位置进行同步绘制确定变化效果是每条线逐减，低到设定的最低值开始逐增，增到最高值再减 实现 定义属性 //属性 private int lineSpace; //两条线之间的宽度 private float changeStep; //动画幅度 private int lineCount; //堆数，每堆5根线条 private int lineWidth; //线宽度 private int changeSpeed; //变化速度 次/秒 private int color; //颜色 private int width; //通过动态计算得到 private int maxHeight; //最高高度 private int minHeight; //最低高度 private float radius; //线条弧度 设想是能自主控制线宽、线高、圆角、颜色、数量（每5个一堆）、动画幅度，用上面的参数基本能实现了
我定义了attr文件，用来在xml里面直接设置：
&lt;declare-styleable name="LineLoadingView"&gt; &lt;attr name="lineWidth" format="dimension" /&gt; &lt;attr name="changeStep" format="float" /&gt; &lt;attr name="lineSpace" format="dimension" /&gt; &lt;attr name="lineCount" format="integer" /&gt; &lt;attr name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc85767caaca3bf53b5be05de0ce9bbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6ee0152f7335a88db1097cda74f47ef/" rel="bookmark">
			@Scheduled定时任务不生效？？？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两年没有写博客了，有点生疏，现在看之前写的博客真是惭愧，什么鬼……（都不要看了）
前几天碰到一个问题，关于定时任务的，在这分享给大家！
@Scheduled
定时任务可以有很多写法，我觉得最简单的就是用注解的方式，如果你的项目用的是spring boot框架，就可以三步完成：
一，添加@EnableScheduling注解到入口类声明上面
/**
* 启动
*
*/
@SpringBootApplication
@EnableScheduling
public class Application {
public static void main(String args[]) {
SpringApplication.run(Application.class, args);
}
}
二，创建类，添加@Component注解
@Component
public class Task {
}
三，创建方法，添加@Scheduled注解
@Scheduled(cron = "${task.cron.tradeData}")
public void getTradeData() {
}
(这里cron是从配置文件取值，如下)
task:
cron:
tradeData: 0 1 0 * * ?
看似简单，却隐藏着很多坑，一不小心就掉进去了，比如：
（1）此方法不能有参数
（2）此方法不能有返回值
（3）此类中不能包含其他带任何注解的方法（发现新大陆）
违反任何一条，定时都不会生效!
小心别入坑哦！！！！
————————————————
版权声明：本文为CSDN博主「王丽君csdn」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/wlj323/article/details/80448291
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22eafc3e1aef9a1e6f6b7f5c9689d7b0/" rel="bookmark">
			解决Windows update medic service服务禁用不了拒绝访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多小伙伴发现禁用Windows update服务后没几天又自动开启，无法禁用自动更新就是因为Windows update medic service服务导致，但是在禁用Windows update medic service服务的时候又出现拒绝访问，如下
解决方法：
方法一：CMD命令
1、首先使用 Win + R 组合快捷键，打开运行对话框，然后输入命令 cmd，点击下方的“确定”打开服务，如下图所示。
复制这条命令
REG add “HKLM\SYSTEM\CurrentControlSet\Services\WaaSMedicSvc” /v “Start” /t REG_DWORD /d “4” /f
2、右键点击粘贴，然后回车
方法二：修改注册列表
1、首先使用 Win + R 组合快捷键，打开运行对话框，然后输入命令 regedit，点击下方的“确定”打开服务，如下图所示。
2、在注册表设置中，找到并定位到“HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WaaSMedicSvc”，右侧找到“Start”键，右键点击“修改”，将数值改为“4”
3、继续在右侧找到“FailureActions”键，右键点击“修改”，修改该键的二进制数据，分别将“0010”和“0018”行的左起第5个数值选中，由原来的“01”改为“00”
改完之后，再回到“服务”窗口中找到Windows Update Medic Service服务，点击鼠标右键，在“属性-常规”和“属性-恢复”中，可以看到该服务已被禁止，且三次失败后的动作皆为“无操作”
另外下面这篇文章是通过服务、注册表、组策略、计划任务中，全方位设置强制关闭Win10自动更新，请转到Win10自动更新有效强制永久关闭.
————————————————
版权声明：本文为CSDN博主「凡尘-追梦者」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_44545251/article/details/101018974
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9253fd0d494c58a55eb39997df53111f/" rel="bookmark">
			这才是真正的Android获取assets文件路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网上找的时候，发现一大堆都不靠谱，只有这个才是靠谱的https://blog.csdn.net/mp624183768/article/details/85162944。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9ef4e743b12d24e48fce4ee47a1f6dc/" rel="bookmark">
			合同审查要点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		审查合同，一般是按如下三步进行：
第一步、形式审查
合同分三大部分：开头(合同名称、编号、双方当事人和鉴于条款)，正文(第一条至最后一条)，签署部分(即双方签字盖章和签署时间)。
形式审查就是看一看一份合同是否具备这三部分，这三部分是否完整，是否有前后矛盾的地方。常见的错误有：当事人名称不一致、不完全、错误或矛盾，合同名称与实质内容不符、时间签署前后不一样，地址、法定代表人错误等。
第二步、实质审查
1、合同标的：订立合同的目的
2、合同标的的数量与质量
3、双方权利义务
4、收费数额与方式
5、商品或服务交付的数额与方式
6、违约责任
7、解除条件
8、争议解决条款
9、合同生效时间
10、合同签订日期和地点
11、签字和盖章
合同审查的着重点：合同的效力，合同的中止、终止、解除，违约责任和争议解决条款。
1、合同的效力：主体是否有资格（审查合作各方是否具有合作的主体资格条件），是否合法，是否有无效条款，无效条款定义：造成对方人身伤害的和因故意和重大过失造成对方财产损失的免责条款。
2、合同的履行和中止：审查质量标准、价款或报酬、履行地点、履行期限、履行方式、履行费用等条款，履行顺序。
第三步、沟通、参照
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/917cdc5d014559eba599683079d4f0f3/" rel="bookmark">
			Quixel bridge桥接设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插件管理 一、Quixel bridge桥接到UE4设置 安装插件 选择插件版本：（与你使用的UE4版本一致）选择安装目录：（该插件需要安装到UE4的插件目录里：C:\Program Files\Epic Games\UE_4.26\Engine\Plugins）资源导入目录：（这里的路径是UE4里你的项目文件目录）
在网上下载的资源包，可以拷贝到Quixel bridge的Megascans Library里，如路径：C:\Users\user\Documents\Megascans Library\Downloaded 二、Quixel bridge桥接到Blender设置 插件安装方法一：自动安装 插件下完就自动安装了，老版本适用。在安装插件之前，请确保已关闭Blender。（或者装完插件后重启Blender） 插件安装方法二：手动安装 现在的版本需要手动安装插件，安装前先关闭Blender。
1、下载桥接插件：
2、下载完插件后，把插件复制到Blender相关文件夹内：
我的Libray库目录：C:\Users\user\Documents\Megascans Library\support\plugins\blender\3.3\MSPlugin
把插件复制到Blender相关文件夹内，路径是：C:\Users\user\AppData\Roaming\Blender Foundation\Blender\2.91\scripts\Startup\MSPlugin
3、打开Blender，并开启插件：
将资产导出到Blender 1、3D资产（直接导出去就行）2、看不到导入的2D资产？？ 其实，导入的2D资产就是一个材质球，在Blender里的材质页面或 着色器页面选择并使用导入的材质球就行。 如何跟踪/查看Blender插件引发的错误/错误？ 三、bridge桥接到Unity 1、下载插件并设置Unity资产导入路径（看下图）
下载插件（插件下载到了Bridge的资产库里）设置资产导入的Unity项目路径（最好在自己的项目资产文件夹（Assets）里新建个名为Megascans的文件夹，并把导入路径指定为该文件夹。）
2、在Unity导入插件包
在 Unity 中，转到资产 &gt; 导入包 &gt; 自定义包&gt; 导航到 /Megascans Library/Support/Plugins/Unity/Version/ 并打开名为 Megascans_Importer.unitypackage 的文件&gt; 点击导入。
3、导入插件包后，会打开插件界面。
4、导入资产
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a040c2b4056264a908cbcd43c4decd7d/" rel="bookmark">
			【转】基于知识图谱的推荐系统(KGRS)综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下文章来源于AI自然语言处理与知识图谱 ，作者Elesdspline
作者信息 Elesdspline
目前从事NLP与知识图谱相关工作。
导语 本文是2020年针对知识图谱作为辅助信息用于推荐系统的一篇综述。知识图谱对于推荐系统不仅能够进行更精确的个性化推荐，而且对推荐也是具有可解释性的，有迹可循。
本文汇总了近些年来知识图谱辅助推荐系统的一些研究工作，并按不同的方法进行划分类别(下图是我根据论文画出的大纲方法类别图)；除此之外，汇总了不同场景下的知识图谱数据集，涵盖7个场景；最后阐述了未来的一些可研究方向及趋势。
基于知识图谱的推荐方法
一、背景知识 推荐系统已经广泛应用在实际生活中的很多场景，特别是个性化推荐系统已经有越来越多的研究工作和落地实践，但是仍然面临着一些问题，例如数据稀疏、冷启动等问题。
近年来，利用知识图谱作为辅助信息生成推荐已经引起了人们相当大的兴趣，这种方法不仅可以缓解上述问题，更准确的进行个性化推荐，而且可以对推荐的结果也是可解释的，是有迹可循的。
下面我们将分别来看一下这两方面。
1.1 推荐系统 推荐系统在实际生活中已经有很多的应用场景，比如我们所熟知的电影、音乐、POI、新闻、教育、书籍，购物等。
推荐系统的目的旨在为 user (用户) 推荐一个（或一系列）未观测的 item (物品，电影，新闻等)。基本步骤如下：
学习 user 和 item 的向量表示 根据 1 中的 user 和 item 向量表示，计算表示 user 对 item 的偏好得分，得分函数可以采用內积、DNN等。
基于 2 中计算的得分，进行排序推荐。
推荐系统主要包含以下三种方法：
Collaborative Filtering (CF): 基于协同过滤的推荐系统，协同过滤算法是从相似度度量出发，考虑 user 或者 item 之间的相似度进行相关推荐，它比较常用的两种方法是基于内存（memory-based）和基于模型（model-based）的两种方法。
Content-based Filtering (CB)：基于内容的推荐系统，与基于协同过滤从全局 user 和 item 的交互数据中学习他们的向量表示相比，基于内容的推荐方法从 item 的内容中学习 user 和 item 的表示。它认为 user 可能对与他们过去交互过的 item 中相似的 item 感兴趣。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a040c2b4056264a908cbcd43c4decd7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebecac2d2f3e146207f056e5e39455cd/" rel="bookmark">
			python第三方库和官方网址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python第三方库下载网址 https://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy
2. Python官方网址
https://pypi.org/project/pylint/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cd184a65c2ea9e7832f2f114cee422b/" rel="bookmark">
			IO流案例以及特殊操作流/对象对象序列化流/Properties集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 IO流案例复制单级文件夹复制多级文件夹 IO特殊操作流标准输入流字节打印流字符打印流 对象序列化流serialVersionUID&amp;transient Properties集合Properties作为Map集合的使用Properties作为Map集合的特有方法Properties和IO流相结合的方法 CET4P228 IO流案例 复制单级文件夹 单级文件夹也就是一个文件夹里面有多个文件
步骤
创建数据源目录File对象获取数据源目录File对象的名称创建目的地目录File对象，路径自定义，文件名就用源目录对象的文件名判断第3步创建的File是否存在，如果不存在，就创建获取数据源目录下所有文件的File数组遍历File数组，得到每一个File对象，该File对象，其实就是数据源文件获取数据源文件File对象的名称创建目的地文件File对象，路径由(目的地目录+第7步获取的名称)组成复制文件
由于不清楚数据源目录下的文件都是什么类型的，所以采用字节流复制文件采用参数为File的构造方法 import java.io.*; public class example_2 { public static void main(String[] args) throws IOException { File srcFile = new File("D:\\JavaSE\\src\\day_19");	//1. 创建数据源目录File对象 String fileSourceName = srcFile.getName();	//2. 获取数据源目录File对象的名称 File destFolder = new File("D:\\", fileSourceName); //3. 创建目的地目录File对象 if (!destFolder.exists()) {//4. 判断第3步创建的File是否存在，如果不存在，就创建 destFolder.mkdir(); //创建目录 } File[] listFiles = srcFile.listFiles();	//5. 获取数据源目录下所有文件的File数组 for (File f : //6. 遍历File数组，得到每一个File对象，该File对象，其实就是数据源文件 listFiles) { String srcFiles = f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cd184a65c2ea9e7832f2f114cee422b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80eb4113a3081e21a5a9dd733eb3ce7f/" rel="bookmark">
			Android Studio安装 Flutter  插件后找不到设备（no devices）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		No connected devices found; please connect a device, or see flutter.dev/setup for getting started instructions.
Flutter 找不到设备，首先我安装了第三方模拟器，接下来是连接模拟器的教程
1.在 Flutter的Sdk目录下运行
flutter config --android-sdk 你的flutter sdk的地址 这个是我的（当出现“You may need to restart any open editors for them to read new settings.” 时重启 Android Studio）
重启Android Studio后 在 Local 敲命令
adb connect 127.0.0.1:你模拟器的端口
连接后就自动检测到了模拟器
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/425/">«</a>
	<span class="pagination__item pagination__item--current">426/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/427/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>