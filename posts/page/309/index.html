<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ad0d1a06c5705e92684bde5a9630c0b/" rel="bookmark">
			docker镜像中更换jdk，解决验证码不能正确显示的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、复制jdk到容器中
1、使用tomcat镜像启动一个容器
docker run -itd --name tomcat -p 9998:8080 xxx/tomcat:7.0.57-jre8 2、复制jdk文件到容器中
docker cp /usr/local/jdk1.8.0_121 tomcat:/usr/local/ 3、将其制作成为一个镜像
docker commit tomcat xxx/tomcat:7.0.57-jdk8 以上几步的目的是，其他人使用镜像时，不用每次复制服务器的jdk
4、制作Dockerfile
(1) 新建一个Dockerfile文件，注意，该文件只能叫这个名字；
cd /home/app touch Dockerfile （2）在Dockerfile中写入一下内容
FROM xxx/tomcat:7.0.57-jdk8 WORKDIR /usr/local ENV JAVA_HOME=/usr/local/jdk1.8.0_121 ENV CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV PATH=$JAVA_HOME/bin:$PATH CMD ["catalina.sh","run"] 注意：FROM的是之前制作的镜像，启动命令是因为FROM的镜像是tomcat，所以启动命令为该命令；
（3）将其制作成新镜像;
docker build -t xxx/tomcat7:jdk8 . (4) 上传镜像
docker push xxx/tomcat7:jdk8 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e500182cbf2eeebb522b6e3343d23b5/" rel="bookmark">
			vue history模式，刷新页面404？结合nginx配置路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 环境：vue2 、nginx
vue history模式，刷新页面404？
出现的场景： spa应用，在history模式下，路由的变更是前端的浏览器 history.pushState、replaceState进行监听切换的，nginx只会配置入口路径进行访问的时候，能正常切换路由，但是进到其他的路由进行刷新的时候，出现了404。
原因： 这是因为我们刷新了当前页面（访问页面相当与发起一个get请求），服务器接收到了，就去查找页面，而服务器只配置了一个首页路由，自然是找不到的。我们不可能每个页面都去服务器配置一下路由。
解决方式： 我们可以在nginx中配置当找不到对应页面的时候，转回首页，这就变向地交给客户端去找路由了，这样本来就存在的路由在刷新的时候就不会再出现404；只需要在nginx 的.conf文件添加以下配置： location / { try_files $uri $uri/ /index.html; } 上述配置说明：try_files 去尝试到网站目录读取用户访问的文件，如果第一个变量存在，就直接返回；
不存在继续读取第二个变量，如果存在，直接返回；不存在直接跳转index.html
前端配置404页面：当路由找不到的时候，重定向到我们指定的页面，如下，找不到对应的路由时，重定向为“/”,这个路径是我希望用户跳转到不存在的路由的时候，自动重定向过来的页面。 [ { path: '*', redirect: '/' }, { path: '/', name: 'nft', component: ()=&gt; import(/* webpackChunkName: 'nft' */ '@/views/nft/index.vue') } ] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba81c55d1a4d3abd3ade44a6e1dac80c/" rel="bookmark">
			数据结构 - 链式队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.链式队列
链式队列 ： 用链表形式实现的队列。链表结点为队列数据存储区，链表结点包括两部分数据存储
区和指针存储区。
数据存储区 ：存放真实有效数据的区域。
指针存储区 ：存放下一个链表结点的地址。
2.创建链式队列
为链式队列申请内存，即为队首指针和队尾指针申请内存。
为链式队列头结点申请内存，头结点不存放有效数据，方便队列的操作。
将队首指针和队尾指针指向头结点，即队首指针和队尾指针相等。
链式队列头结点指针域为空，即为NULL；头结点数据域可不管，亦可为零，作为链式队列有效的
节点数，亦可作为创建队列成功标识等等，由开发者根据实际情况而定。
3.链式队列数据入队 .为链式队列入队数据结点申请内存。
将新结点设置为最后个结点，新结点的指针域为空，数据域为入队数据。
更新队尾指针，将队尾指针指向新插入的结点。
4.链式队列数据出队 .只有在链式队列非空时出队数据才有效。
若只有一个有效结点时，需将队尾指针指向头结点，头结点指针域为空。
头结点指针指向下下个有效结点。
结点数据出队。
释放出队结点数据内存。
5.代码示例
linkqueue.h
#ifndef __LINKQUEUE_H__ #define __LINKQUEUE_H__ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdbool.h&gt; typedef int datatype; #define MAXSIZE 10 //定义链式队列的结点类型 typedef struct linkqueuende{ datatype data; struct linkqueuende *next; }linkpqueue_node,*linkpqueue_node; //将front和read指针封装 typedef struct linkqueue{ linkpqueue_pnode front,read; }link_queue,*link_pqueue; extern void init_linkqueue(link_queue *Q); extern bool is_full_linkqueue(link_pqueue q); extern bool in_linkqueue(datatype data,link_pqueue q); extern bool out_linkqueue(link_pqueue q,datatype *D); extern bool is_empty_linkqueue(link_pqueue q); extern void show_linkqueue(link_pqueue q); #endif linkqueue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba81c55d1a4d3abd3ade44a6e1dac80c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e7ea3e062da5ad64e0e5ef6559f025b/" rel="bookmark">
			Uncaught (in promise) NavigationDuplicated: Avoided redundant navigation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现这个的原因：重复跳转路由，场景：当下路由是/home，反复点击跳转到/home。
解决方式： 跳转前进行判断是否同一个路由，不同则跳转，相同则不跳转。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85ed23f4056260daa43eef5b523d37f9/" rel="bookmark">
			vue.3.0&#43;vite&#43;ts的uni-app项目Typescript引起的报错处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Typescript引起的报错处理 1、Non-relative paths are not allowed when ‘baseUrl’ is not set. Did you forget a leading ‘./’? 在tsconfig.json文件中加：
{ "baseUrl": ".", } 2、Cannot find module ‘@/utils/login’ or its corresponding type declarations.ts(2307) 在tsconfig.json文件中加：
{ "@/utils/*": ["src/utils/*"], } 3、Property ‘context’ does not exist on type ‘NodeRequire’. 安装 npm i @types/webpack-env -D 在tsconfig.json文件中加：
{ "types": ["webpack-env"], } 最终tsconfig.json配置 { "compilerOptions": { "target": "esnext", "useDefineForClassFields": true, "module": "esnext", "moduleResolution": "node", "strict": true, "jsx": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85ed23f4056260daa43eef5b523d37f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7665da9a641c5a783753238e44efc9dc/" rel="bookmark">
			java synchronized你得知道的几件事？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文要点 本文主要讲的是synchronized 锁膨胀的原理，会从源代码上面向大家展开锁膨胀的逻辑和从源代码上面来推敲设计者为什么要这样做。
synchronized 分析 因为网上已经有比较多的文章讲整个synchronized的分析，所以这篇文章主要专注回答几个点。
在看下面例子前，我们先看下整个markword 在64位系统里面是如何表达的。
synchronized的偏向锁性能是否优于轻量级锁 在源码分析前首先看如下代码：
*/ public class OneSingleThread { public static void main(String[] args) { OneSingleThread oneSingleThread = new OneSingleThread(); long before = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000; i++) { synchronized (oneSingleThread) { } } long after = System.currentTimeMillis(); System.out.println(after - before); } } 第一次运行的时候：我们关闭偏向锁
-XX:-UseBiasedLocking -XX:BiasedLockingStartupDelay=0
第二次运行的时候vm 参数
-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0
从实验对比我们能发现在单线程情况下，偏向锁的性能还是有提高的，大概非偏向锁，100w次运行，性能能优化26毫秒。但是这里有一个伪命题，就是我们为什么要在循环里面用锁，当这个锁进入释放，能够达到100w次（同一个线程），是不是我们程序本身应该优化。
synchronized的偏向锁什么情况会做膨胀为轻量级锁 package com.test; import org.openjdk.jol.info.ClassLayout; /** * @Author: 彭雨佳 * @Date: 2021/12/5 11:53 上午 */ public class TwoThreadDemo { public static TwoThreadDemo lock = new TwoThreadDemo(); public static void main(String[] args) { Thread a = new Thread() { @Override public void run() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7665da9a641c5a783753238e44efc9dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2c73ba56f75d7a40778fca6f18a9c60/" rel="bookmark">
			云服务器安装Nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.下载nginx2.配置1.安装PCRE2.安装zlib-devel3.配置nginx1.解压2.指定配置文件位置3.安装openssl（可跳过）4.执行make5.创建文件夹logs：6.启动nginx 3.运行一个vue项目1.上传dist文件夹 1.下载nginx 点此选择nginx下载版本
选择版本：nginx-1.20.2.tar.gz （这个版本好像是当前最新的稳定版本）
通过XFTP上传到云服务器
2.配置 1.安装PCRE [root@iZbp136w25mhx42m5ve5wxZ dev]# yum install -y pcre-devel 2.安装zlib-devel [root@iZbp136w25mhx42m5ve5wxZ dev]# yum install -y zlib-devel 3.配置nginx 1.解压 [root@iZbp136w25mhx42m5ve5wxZ dev]# tar -zxvf nginx-1.20.2.tar.gz 进入解压后的文件夹：
2.指定配置文件位置 执行 --prefix = 后面指定的是你nginx配置文件的位置（以后只需要改此路径下conf文件中的nginx.config配置文件即可,网上很多都是指定的/usr/local/nginx这个文件夹，我比较嫌麻烦，打算放在一起，后面需要创建一个logs文件夹，否则会报错nginx: [alert] could not open error log file: open() /usr/dev/logs）
[root@iZbp136w25mhx42m5ve5wxZ nginx-1.20.2]# ./configure --prefix=/usr/dev/nginx-1.20.2 3.安装openssl（可跳过） [root@iZbp136w25mhx42m5ve5wxZ nginx-1.20.2]# yum install -y openssl openssl-devel 4.执行make [root@iZbp136w25mhx42m5ve5wxZ nginx-1.20.2]# make &amp;&amp; make install 5.创建文件夹logs： [root@iZbp136w25mhx42m5ve5wxZ nginx-1.20.2]# mkdir logs 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2c73ba56f75d7a40778fca6f18a9c60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/212f2e2fcc6b8c2ed7e87c3162d548ad/" rel="bookmark">
			Mysql从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显示数据库语句
show databases
显示创建数据库的语句
show create database 库名
修改数据库: alter DATABASE 库名 charset = 字符集(utf8或者utf8mb4)
删除数据库
drop databse 库名
使用数据库
use 库名
备份数据库
cmd命令下执行:
备份数据库表中的数据
mysqldump -u 用户名 -p 数据库名 &gt; 文件名.sql
恢复数据库
mysql –u root -p database_name &lt; 文件名.sql; 还原某个数据库,要求该数据库已经创建成功
创建表
create table 表名(
字段名 字段类型
字段名 字段类型
)charset = 字符集(utf8或者utf8mb4)
数据库数据类型
数值类型
BIT(M) 位类型。M指定位数，默认值1，范围1-64
INT[UNSIGNED] 带符号是负的2的31次方到2的31次方-1 ,无符号2的32方-1 TINYINT[UNSIGNED] 带符号的范围是-128到127。无符号0到255。默认是有符号
FLOAT[(M,D)][UNSIGNED] M指定豆示长度,d指定小数位数,占用空间4个字节
DOUBLE[(M,D)] [UNSIGNED] 表示比float精度更大的小数,占用空间8个字节
DECIMAL(M,D) [UNSIGNED] 定点数M指定长度,D表示小数点的位数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/212f2e2fcc6b8c2ed7e87c3162d548ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86c311c97e636f255afc9d984852e53d/" rel="bookmark">
			http 常见状态码 以及对应的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1xx -提供信息。
100 Continue。当客户端提交一个包含主体的请求时.将发送这个响应。该响应表示已收到请求消息头.客户端应继续发送主体。请求完成后，再由服务器返回另一个响应。
 2xx—请求被成功提交。
200 Ok。本状态码表示已成功提交请求，且响应主体中包含请求结果。
201 Created. PUT请求的响应返回这个状态码，表示请求已成功提交。
 3xx—客户端被重定向到其他资源。
301 Moved Permanently。本状态码将浏览器永久重定向到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。
302 Found。本状态码将浏览器暂时重定向到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL.
304 Not Modified。本状态码指示浏览器使用缓存中保存的所请求资源的副本。服务器使用If-Modified-Since与If-None-Match消息头确定客户端是否拥有最新版本的资源。
 4xx -请求包含某种错误。
400 Bad Request。本状态码表示客户端提交了一个无效的HTTP请求。当以某种无效的方式修改请求时(例如在URL中插人一个空格符)，可能会遇到这个状态码。
401 Unauthorized.服务器在许可请求前要求HTTP进行身份验证。WWW-Authenticate消息头详细说明所支持的身份验证类型。
403 Forbidden。本状态码指出，不管是否通过身份验证，禁止任何人访问被请求的资源。
404 Not Found。本状态码表示所请求的资源并不存在。
405 Method Not Allowed。本状态码表示指定的URL不支持请求中使用的方法。例如，如果试图在不支持PUT方法的地方使用该方法，就会收到本状态码。
414 Request-URI Too Large 。如果在本地代码中探查缓冲器滋出瀚洞并就此提交超长数据串.则本状态码表示请求主体过长，服务器无法处理。
 5xx—服务器执行请求时遇到错误。
500
Internal Server Error。本状态码表示服务器在执行请求时遇到错误。当提交无法预料的输人、在应用程序处理过程中造成无法处理的错误时，通常会收到本状态码。应该仔细检查服务器响应的所有内容，了解与错误性质有关的详情。
503 Service Unavailable。通常，本状态码表示尽管Web服务器运转正常.并且能够响应请求，但服务器访问的应用程序还是无法作出响应。应该进行核实，是否因为执行了某种行为而造成这个结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fac327aab649426046f4c0ef65a3e948/" rel="bookmark">
			数据结构——图基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇参考了王道及b站懒猫老师，王卓老师的课程，进行归纳总结，本文使用的语言是c语言，部分代码没有实现或使用伪代码方式，文章内容共包含了以下几个部分：
那么接下来就从图的基本概念进行学习：
图的基本概念 图G由顶点集V和边集E组成，记为G=(V,E)，其中VG)表示图G中顶点的有限非空集;E(G)表示图G中顶点之间的关系(边）集合。若V={v1,v2,v3,…… }，则用|V表示图G中顶点的个数。
E={(u, v)| u∈v,v∈V}，用|E表示图G中边的条数。
线性表和树可以为空，但图不能为空，其顶点集不能为空，但边可以为空
有向图
若E是有向边(也称弧）的有限集合时，则图G为有向图。弧是顶点的有序对，记为&lt;v,w&gt;,其中v w是顶点，v称为弧尾,w称为弧头，&lt;v, w&gt;称为从v到w的弧，也称v邻接到w。
如下图：边集合为E={&lt;A,B&gt;,&lt;E,A&gt;,&lt;C,A&gt;,&lt;B,C&gt;,&lt;C,D&gt;,&lt;D,E&gt;,&lt;C,E&gt;}
无向图
若E是无向边（简称边）的有限集合时，则图G为无向图。边是顶点的无序对，记为(vy, w)或(w, v)。可以说w和v互为邻接点。边(v, w)依附于w和v，或称边(v, w)和v, w相关联。
如下图：边集合为E={(A,B),(E,A),(C,A),(B,C),(C,D),(D,E),(C,E)}
筒单图、多重图
一个图G如果满足:①不存在重复边;②不存在顶点到自身的边，那么称图G为简单图。图6.1中G,和 G均为简单图。若图中某两个顶点之间的边数大于1条，又允许顶点通过一条边和自身关联，则称图G为多重图。多重图和简单图的定义是相对的。数据结构中仅讨论简单图。
完全图（也称简单完全图)
对于无向图，E的取值范围为О到n(n -1)/2，有n(n -1)/2条边的无向图称为完全图，在完全图中任意两个顶点之间都存在边。对于有向图，E的取值范围为0到n(n -1)，有n(n -1)条弧的有向图称为有向完全图，在有向完全图中任意两个顶点之间都存在方向相反的两条弧
子图
设有两个图G=(V, E)和G' =(v,E')，若V是V的子集，且E是E的子集，则称G是G的子图。若有满足V(G')=V(G)的子图G，则称其为G的生成子图。
注意:并非V和E的任何子集都能构成G的子图，因为这样的子集可能不是图，即E的子集中的某些边关联的顶点可能不在这个V的子集中。
连通、连通图和连通分量
在无向图中，若从顶点v到顶点w有路径存在，则称v和w是连通的。,若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图。无向图中的极大连通子图称为连通分量。
强连通图、强连通分量
在有向图中，如果有-一对顶点v和w，从v到w和从w到v之间都有路径，则称这两个顶点是强连通的。若图中任何一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连通子图称为有向图的强连通分量,
生成树、生成森林
连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为n，则它的生成树含有n-1条边。包含图中全部顶点的极小连通子图，只有生成树满足这个极小条件，对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。在非连通图中，连通分量的生成树构成了非连通图的生成森林。
注意:区分极大连通子图和极小连通子图。极大连通子图是无向图的连通分量，极大即要求该连通子图包含其所有的边;极小连通子图是既要保持图连通又要使得边数最少的子图。
边的权和网
在一-个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。这种边上带
有权值的图称为带权图，也称网。
稠密图、稀疏图
边数很少的图称为稀疏图，反之称为稠密图。稀疏和稠密本身是模糊的概念，稀疏图和稠密图常常是相对而言的。
路径、路径长度和回路
顶点v,到顶点v之间的一条路径是指顶点序列当然关联的边也可理解为路径的构成要素。路径上边的数目称为路径长度。第一个顶点和最后一个顶点相同的路径称为回路或环。若一个图有n个顶点，并且有大于n-1条边，则此图一定有环。
简单路径、简单回路
在路径序列中，顶点不重复出现的路径称为简单路径。.除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。
图的存储结构与基本操作 邻接矩阵法 所谓邻接矩阵存储，是指用一个一-维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的邻接关系)，存储顶点之间邻接关系的二维数组称为邻接矩阵。
如下图所示的表格，将顶点作为横纵坐标，交叉处为权值，此图为无向网即没有方向且有权值，当两个顶点之间无边时用无穷大来表示。如图可以发现规律，各数值按照对角线对称
这里的图和下面创建的是一样的，可以将代码和图一起进行剖析
邻接矩阵结构体成员 #define MAXINT 32767 //最大值即无穷大 #define VERTEX_MAX 100 //最大顶点数 typedef struct Gragh { char Vertex[VERTEX_MAX]; //顶点数组 int Edge[VERTEX_MAX][VERTEX_MAX];//边表 int vernum,arcnum; //顶点个数，边数 }Gragh; 邻接矩阵创建 ① 输入边和顶点数量即 vexnum和arcnum
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fac327aab649426046f4c0ef65a3e948/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c0eece8e3b450ea763a5f1ec4f9d0e/" rel="bookmark">
			推荐系统（十九）推荐系统中的专业名词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 tgi 全称为target group index，即用户画像中的标签，比如用户是否有车，是否有房。
参考 用户画像TGI 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bde78f30fccbb318274f7cf65b076b74/" rel="bookmark">
			N皇后问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 描述
国际象棋的棋盘是由8×8共64个方格构成，棋子放在方格里面。如果两个皇后棋子在同一行、同一列，或者在某个正方形的对角线上，那么这两个皇后就会互相攻击。请在棋盘上摆放8个皇后，使得它们都不会互相攻击。这是经典的8皇后问题。
现在要解决N皇后问题：将N个皇后摆放在一个N行N列的国际象棋棋盘上，要求任何两个皇后不能互相攻击。输入皇后数N(1&lt;=N&lt;=9),输出所有的摆法。无解输出"NO ANSWER"。行列号都从0开始算。
输入
一个整数N，表示要把N个皇后摆放在一个N行N列的国际象棋棋盘上
输出
所有的摆放放案。每个方案一行，依次是第0行皇后位置、第1行皇后位置......第N-1行皇后位置。
多种方案输出顺序如下：优先输出第0行皇后列号小的方案。如果两个方案第0行皇后列号一致，那么优先输出第1行皇后列号小的方案......以此类推
样例输入
4 样例输出
1 3 0 2 2 0 3 1 #include&lt;iostream&gt; #include&lt;math.h&gt; using namespace std; int ansi[100],number; void is_change(int n) { if(n==number) { for(int i=0;i&lt;number;i++) { cout&lt;&lt;ansi[i]+1&lt;&lt;" "; } cout&lt;&lt;endl; return ; } for(int i=0;i&lt;number;i++)//每一列判断是否有行与他对应， { int j;//对于 for(j=0;j&lt;n;j++) { if(ansi[j]==i||fabs(ansi[j]-i)==fabs(n-j)) /*皇后与皇后之间不能同一行同一列,并且不能够斜向触碰， 对于这种要排除可能，通过break， 进行排除，如果出去之后j!=n,则说明不相等*/ break; } if(j==n) { ansi[n]=i; is_change(n+1); } } } int main() { cin&gt;&gt;number; is_change(0); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab718b9e1cd18e224c05551d0bdee168/" rel="bookmark">
			www.no1paper.cn在代码中插入此网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ![
多多成稿作品网首页 ](https://img-blog.csdnimg.cn/f2245f3d6d014295b8153225b700506e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSa5aSa5oiQ56i_5L2c5ZOB572R,size_20,color_FFFFFF,t_70,g_se,x_16)多多成稿作品库www.no1paper.cn
特色是新原创作品较多还可以投稿赚收益，收集了百万篇毕业论文范文作品、文案，原创文集分享，定期发布各种期刊杂志的论文征稿及论文投稿信息 收集专业学术资料是撰写毕业论文的重要组成部分，对毕业论文的优秀与否起重要作用。
种期刊杂志的论文征稿及论文投稿信
A B C 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20913242896a7c34b8a99febf2e6e085/" rel="bookmark">
			SSM异步请求分页&#43;模糊查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dao层
dao层 // 根据用户名查询单个用户 User getUsername(String name) throws Exception; // 分页列表+模糊查询+排序 List&lt;User&gt; getUserlist(@Param("pageNo") int pageNo,@Param("pageSize") int pageSize,@Param("name") String name,@Param("isSort") String isSort) throws Exception; xml文件
&lt;select id="getCount" resultType="int"&gt; SELECT COUNT(1) FROM t_userinfo &lt;if test="name != null and name != ''"&gt; WHERE name LIKE CONCAT("%",#{name},"%") &lt;/if&gt; &lt;/select&gt; &lt;select id="getUserlist" resultType="User"&gt; SELECT * FROM t_userinfo &lt;where&gt; &lt;if test="name != null and name != ''"&gt; name LIKE CONCAT("%",#{name},"%") &lt;/if&gt; &lt;/where&gt; ORDER BY userid ${isSort} LIMIT #{pageNo},#{pageSize} &lt;/select&gt; page工具类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20913242896a7c34b8a99febf2e6e085/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/728158772c9441d9a7b93f11b03bbc0e/" rel="bookmark">
			基于ESP32与phyphox的DIS实验制作（2）－用phyphox自带的实验界面来进行物理实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实phyphox自带的一些实验界面也可以进行很多的实验研究，上一篇提到的一同参加自制教具比赛的那位老师（感谢那位老师的分享），就是用phyphox自带的实验界面来设计很多很有创意的实验！
1、使用phyphox自带实验界面进行电梯加速度测量
为此我也特地在家里的电梯里用phyphox做了一个小实验——测量电梯下降时加速度的变化。以下是实验的视频：
（这里好像不方便放视频，具体视频请关注微信公众号：宁中物理创新实验室）
以下是测得的数据：
突然想到一个问题，大家根据上面的图像算算我家住在几楼？
2、实验数据的导出
在phyphox里只提供了最简单的数据处理，貌似只有线性拟合。如果要进行更复杂的数据处理，我们可以将数据导出到excel里进行处理。
点击界面右上角的三个点按钮：
然后选择导出数据：
选择第一个Excel：
然后选择微信或者qq发送给自己的电脑或者别人。
打开后就可以看到所有的数据了，然后你就可以对数据进行处理了。
3、通过电脑屏幕实时显示phyphox的界面
使用phyphox来进行实验有一个很大的缺点，那就是手机传感器和屏幕都在一起，如果你想利用它来进行一个圆周运动加速度的研究，那么手机屏幕也会跟着做圆周运动，我们就没法看清屏幕上的数据了。所以phyphox设计了一个远程访问功能，让电脑浏览器上也能实时的显示手机屏幕上的数据，这样就可以方便的在教室里进行演示实验了。
选择启用远程访问,可以看到在界面下方会显示具体的ip地址，注意你的电脑和手机必须在同一个局域网内。 然后在电脑的浏览器里输入刚才的网址，就可以同步显示手机上的界面了。
phyphox自带的实验也非常的丰富，主要有加速度传感器、霍尔传感器（磁力计）、陀螺仪、声音传感器，有些手机上还有光传感器等等，结合这些传感器和自制的一些实验器材，可以开发很多的实验，我见过有将手机贴在轮胎上、将手机挂在弹簧下、将手机从空中自由落体…不过这些实验有一个非常大的缺点，那就是你的手机很危险！
这一篇就到这里结束了，回顾一下这一篇的内容：
（1）用phyphox测量了电梯运行时的加速度
（2）将测得的数据通过qq分享到了电脑上
（3）通过电脑端的浏览器远程实时显示并控制phyphox
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d9152b967870ced947432efcc4a106a/" rel="bookmark">
			从键盘输入某班学生的学号和某门课的成绩（每班人数最多不超过40人），当输入为负值时，表示输入结束，试编程从键盘任意输入一个学号，查找该学号学生的成绩。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**提示信息："Input student’s ID and score:" **输入格式： "%ld%d" **提示信息： "Input the searching ID:" **输入格式要求："%ld" **输出格式要求："Total students are %d\n" "score = %d\n" "Not found!\n" 程序的两次运行示例如下： ① Input student’s ID and score:1910122 84 Input student’s ID and score:1910123 83 Input student’s ID and score:1910124 88 Input student’s ID and score:1910125 87 Input student’s ID and score:1910126 61 Input student’s ID and score:-1 -1 Total students are 5 Input the searching ID:1910123 score = 83 ② Input student’s ID and score:1910122 84 Input student’s ID and score:1910123 83 Input student’s ID and score:1910124 88 Input student’s ID and score:1910125 87 Input student’s ID and score:1910126 61 Input student’s ID and score:-1 -1 Total students are 5 Input the searching ID:1910128 Not found!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d9152b967870ced947432efcc4a106a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39761502b1d789b0e764c610782a3745/" rel="bookmark">
			Vue 组件化编程、VueComponent实例对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 模块与组件、模块化与组件化非单文件组件单文件组件 模块与组件、模块化与组件化 模块：
理解: 向外提供特定功能的 js 程序，一般就是一个 js 文件为什么: js 文件很多很复杂作用: 复用 js，简化 js的编写，提高 js 运行效率 组件：
理解: 用来实现局部(特定)功能效果的代码集合(html/css/js/image……)为什么: 一个界面的功能很复杂作用: 复用编码，简化项目编码，提高运行效率 模块化：
当应用中的 js 都以模块来编写的，那这个应用就是一个模块化的应用 组件化：
当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用 非单文件组件 模板编写没有提示没有构建过程，无法将 ES6 转换成 ES5不支持组件的 CSS真正开发中几乎不用 Vue中使用组件的三大步骤：
1、定义组件(创建组件)
使用 Vue.extend(options) 创建，其中 options 和 new Vue(options) 时传入的那个options几乎一样，但也有区别
el不要写 ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。data必须写成函数———— 避免组件被复用时，数据存在引用关系。备注：使用template可以配置组件结构。 2、注册组件
局部注册：靠new Vue的时候传入components选项全局注册：靠Vue.component(‘组件名’,组件) 3、使用组件(写组件标签)
&lt;xxx&gt;&lt;/xxx&gt; 或者 &lt;xxx/&gt; &lt;body&gt; &lt;div id="root"&gt; &lt;hello&gt;&lt;/hello&gt; &lt;hr&gt; &lt;h1&gt;{{msg}}&lt;/h1&gt; &lt;hr&gt; &lt;!-- 第三步：编写组件标签 --&gt; &lt;school&gt;&lt;/school&gt; &lt;hr&gt; &lt;!-- 第三步：编写组件标签 --&gt; &lt;student&gt;&lt;/student&gt; &lt;/div&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39761502b1d789b0e764c610782a3745/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42a87b22a805c070852548f9671c8d19/" rel="bookmark">
			uniapp打包安卓APP生成自有证书的教程，简单实用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都知道uniapp是一个可以实现多端开发的一个工具。但我之前使用uniapp这个工具，光用来画页面了，打包什么的从来都没怎么参与过。于是，趁着最近不忙，准备学习如何将uniapp打包成安卓APP。接下来就是我学习uniapp打包APP的心得与笔记。
1.安装JRE环境 可从Oracle官方下载jre安装包：Java Downloads | Oracle
也可以去找其他资源进行下载。
也可以选择这个资源进行下载：jdk-8u311-windows-x64.zip-其它文档类资源-CSDN下载
下载完后，就进行安装，安装很简单直接下一步下一步就行了。
注意：记住你的java安装的位置。
我这里就以它的默认位置进行安装的。
2.配置java环境变量 这里以我的jre安装地址：C:\Program Files\Java\jre1.8.0_311 为例。
window10进入环境变量，找到用户变量的Path，新建将你的jre本地安装地址添加进去。然后点两次确认退出就好了。
3.生成自有证书 首先我们可以进入一个文件列表较少的文件夹，因为这样生成的证书文件比较好找一点。
生成证书的命令行为：
keytool -genkey -alias wang -keyalg RSA -keysize 2048 -validity 36500 -keystore wang.keystore 注意：
wang是证书别名，可修改为自己想设置的字符，建议使用英文字母和数字wang.keystore是证书文件名称，可修改为自己想设置的文件名称，也可以指定完整文件路径36500是证书的有效期，表示100年有效期，单位天，建议时间设置长一点，避免证书过期 按回车后，会出现以下页面，注意：wang只是我用来做测试所使用的，正式使用需要按实际情况进行填写。
上述操作完成后，生成的证书就会以如下的形式存在我的本地目录中了。
4.使用自有证书进行打包 自有证书需要与你生成自有证书相同的信息进行填写。
最后进行短时间的等待即可。 ok，自有证书打包就这么完成了！这是多么的简单，以前还觉得生成证书打包什么的可能很难，结果就这么几步。果然还是俗话说得好万事开头难！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cef3167cb55ace20cede9a15208d5663/" rel="bookmark">
			消息发送功能搭配策略和建造者设计模式（绝对经典）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
消息发送可以简单划分为：短信、邮箱、消息推送、app消息发送等几种模式，但是随着业务的扩大很有可能引入其他的消息发送方式，如果基于if-else或者switch-case的方式，代码会显得耦合度很高，迭代开发要修改的地方很多，所有抽象出接口，使用策略模式会很好的解耦。
设计思想
1、消息发送独立成一个单独的服务
2、把消息类型抽象出一个服务提供者provider接口，抽象方法是发送消息
3、每个不同的消息实现provider接口
4、定义消息发送的服务接口
5、服务接口的实现组装各个消息模板，调用消息提供的接口去发送
6、定义两个实体类 消息配置类（比如发送短信是appId，assessKey ，发送邮件的邮箱和密码信息等）模板配置类 比如短信模板，邮件模板等
核心实现 消息服务接口实现类要实现ApplicationContextAware接口，以便到ApplicationContext容器拿到不同消息的provider的实现。
代码实现 由于粘贴代码会导致篇幅过长，上传到了码云上 地址：https://gitee.com/devil_1/message.git
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0634f0f83fec95daf6760755f2db0722/" rel="bookmark">
			爆破专栏丨SpringBoot2.x系列教程之整合Redis实现持久化缓存效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在上一章节中，壹哥 带大家利用默认的ConcurrentHashMap，实现了一种默认的内存级别的缓存效果。但是这种缓存方案，并没有把数据实现持久化缓存，也就是说一旦内存被释放，缓存的数据也就不存在了。所以在本章节中，我会带大家结合之前学过的Redis，带各位把数据持久化缓存到Redis中。
本案例我会直接在上一节的案例基础上进行改造。
一. Spring Boot整合Redis实现缓存
1. 创建Web项目
我们按照之前的经验，创建一个SpringBoot的Web程序，具体过程略。
2. 添加依赖包
我们在上一章节的基础上，添加2个新的依赖包，redis和json的。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.39&lt;/version&gt; &lt;/dependency&gt; 3. 修改application.yml配置文件 主要是添加关于redis的配置信息，以及设置缓存类型。
cache: default-exp: 1000 #单位秒,缓存的过期时间 server: port: 8080 spring: application: name: cache-demo datasource: driver-class-name: com.mysql.cj.jdbc.Driver username: root password: syc url: jdbc:mysql://localhost:3306/spring-security?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8&amp;useSSL=false&amp;serverTimezone=UTC redis: host: localhost port: 6379 database: 0 #password: cache: type: redis #由redis进行缓存,一共有10种缓存方案 jpa: database: mysql show-sql: true #开发阶段,打印要执行的sql语句.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0634f0f83fec95daf6760755f2db0722/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b69f0c36f735b86a89ecefed07dfc501/" rel="bookmark">
			Vue-Uni-App小程序实现身份证识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue-Uni-App小程序实现身份证识别~ 需求：实现一个身份证的识别功能！看下方图片！
思路：（把用户上传的身份证图片转成base64请求接口发送给后端，后端返回对应的信息渲染到页面上就行了！）
识别出来后 第一步：在components新建 image-uploader.vue 代码如下： &lt;template&gt; &lt;view class="uploader-container row wrap"&gt; &lt;view class="upload-image-box" v-for="(item, index) in fileList" :key="index" :style="{ width: previewWidth, height: previewHeight }" &gt; &lt;image mode="widthFix" class="img-preview" :src="item.url" :style="{ width: previewWidth, height: previewHeight }" /&gt; &lt;view v-if="deletable" class="close-icon row-center" @click="deleteImage($event, index)" &gt; &lt;icon type="cancel" size="30" color="white" /&gt; &lt;/view&gt; &lt;/view&gt; &lt;view ref="input" class="uplader-upload row-center" :style="{ width: previewWidth, height: previewHeight }" @click="handleImage" v-show="(fileList.length == 0 || mutiple) &amp;&amp; fileList.length &lt; maxUpload"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b69f0c36f735b86a89ecefed07dfc501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1495f2d42ab928a676a6454164b370bd/" rel="bookmark">
			前端通过url链接下载文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端通过url链接下载文件
网上找到几个相关的方法,如下
// 方法一: const form = document.createElement('form'); form.setAttribute('action', 'http://text.com/file.txt'); form.setAttribute('method', 'get'); form.setAttribute('target', '_blank'); form.setAttribute('style', 'display:none'); document.body.appendChild(form); form.submit(); document.body.removeChild(form); // 方法二: window.open('http://text.com/file.txt') 但是这两种方式都是新开一个标签页并显示出来，用户体验不是很好。
我们可以使用html中a标签的一种方法，如下：
// 方法三:
&lt;a href="http://text.com/file.txt" download="fileName.txt"&gt;下载&lt;/a&gt; 这是使用html5中加入a标签的新属性download,属性值为下载时保存的文件名。加上download属性后，点击a标签就不是跳转链接了，而是下载资源。
注意：以上方法只有在文件url链接的域名与当前域名相同时才适用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda930fd4581be66a2dc5aee5e819bb9/" rel="bookmark">
			大数据学习之MapReduce
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MapReduce概述 MapReduce是一种分布式并行编程框架，借助一个集群通过多台机器同时并行处理大规模数据集
MapReduce的策略
MapReduce采用分而治之的策略。把庞大的数据集，切分成非常多的独立的小分片，然后为每个分片单独地启动一个map任务，最终通过多个map任务，并行地在多个机器上处理MapReduce的理念 计算向数据靠拢而不是数据向计算靠拢要完成一次数据分析时，选择一个计算节点，把运行数据分析的程序放到计算节点上运行然后把它所涉及的数据，全部从各个不同的节点上面拉过来，传输到计算发生的地方
MapReduce将复杂的集群计算过程，高度的抽象成Map函数和Reduce函数 函数输入输出说明Map&lt;k1,v2&gt; 如：&lt;行号,”a b c”&gt;List(&lt;k2,v2&gt;) 如：&lt;“a”,1&gt;
&lt;“b”,1&gt;
&lt;“c”,1&gt;1.将小数据集进一步解析成一批&lt;key,value&gt;对，输入Map函数中进行处理 2.每一个输入的&lt;k1,v1&gt;会输出一批&lt;k2,v2&gt;。其中&lt;k2,v2&gt;是计算的中间结果Reduce&lt;k2,List(v2)&gt;
如：&lt;“a”,&lt;1,1,1&gt;&gt;&lt;k3,v~3&gt; &lt;“a”,3&gt;输入的中间结果&lt;k2,List(v2)&gt;中的List(v2)表示是一批属于同一个k2的value MapReduce 体系结构 Client 客户端
用户编写的MapReduce程序通过Client提交到JobTracker端
用户可通过Client提供的一些接口查看作业运行状态JobTracker 作业追踪器
负责资源的监控和作业的调度
监控底层的其它TaskTracker以及当前运行的Job的健康状况，一旦发现失败，就将相应的任务转移到其他节点
跟踪任务的执行进度、资源使用量等信息，并将这些信息告诉任务调度器（TaskScheduler），而调度器会在资源出现空闲时，选择合适的任务去使用这些资源TaskTracker 任务调度器
接收JobTracker发送过来的命令并执行相应的操作（如启动新任务、杀死任务等）
TaskTracker会周期性地通过“心跳”将本节点上资源的使用情况和任务的运行进度汇报给JobTracker
TaskTracker如何衡量自己资源使用情况？
使用“slot”等量划分本节点上的资源量（CPU、内存等）。一个Task获取到一个slot后才有机会运行，而Hadoop调度器的作用就是将各个TaskTracker上的空闲slot分配给Task使用。slot分为Map slot和Reduce slot两种，分别供MapTask和Reduce Task使用，两种slot不通用。Task 任务
Task分为Map Task和Reduce Task两种，均由TaskTracker启动
MapReduce的工作流程 不同的Map任务之间不会进行通信不同的Reduce任务之间也不会发生任何信息交换用户不能显式地从一台机器向另一台机器发送消息所有的数据交换都是通过MapReduce框架自身去实现的 MapReduce执行的各个阶段 首先从分布式系统HDFS上通过InputFormat模块加载读取文件，InputFormat负责对输入进行验证，并且把大的数据进行逻辑上的切分Split，Split是一个逻辑概念，它只包含一些元数据信息，比如数据起始位置、数据长度、数据所在节点等。它的划分方法完全由用户自己决定。
Hadoop为每个split创建一个Map任务，split的多少决定了Map任务的数目。大多数情况下，理想的分片大小是一个HDFS块，防治一个分片横跨多个block上，而block不在同一台机器上
Reduce任务的数量
最优的Reduce任务个数取决于集群中可用的reduce任务槽(slot)的数目
通常设置比reduce任务槽数目稍微小一些的Reduce任务个数（这样可以预留一些系统资源处理可能发生的错误）
再由记录阅读器RR根据分片的位置和长度信息，从HDFS中把相关分片读取出来，输出为&lt;key，value&gt;形式Map函数只接收&lt;key，value&gt;形式的输入，Map函数中是用户定义的处理逻辑，完成相关的数据处理，生产中间结果一堆的&lt;key，value&gt;中间结果经过Shuffle（分区、排序、合并、归并）过程，才能把相关的键值对分发给相对应的Reduce任务来处理
Map端的Shuffle过程 每个Map任务分配一个缓存
MapReduce默认100MB缓存
设置溢写比例0.8
分区默认采用哈希函数
排序是默认的操作
排序后可以合并（Combine）
合并不能改变最终结果
在Map任务全部结束之前进行归并
归并得到一个大的文件，放在本地磁盘
文件归并时，如果溢写文件数量大于预定值（默认是3）则可以再次启动Combiner，少于3不需要
JobTracker会一直监测Map任务的执行，并通知Reduce任务来领取数据
合并（Combine）和归并（Merge）的区别：两个键值对&lt;“a”,1&gt;和&lt;“a”,1&gt;，如果合并，会得到&lt;“a”,2&gt;，如果归并，会得到&lt;“a”,&lt;1,1&gt;&gt;
Reduce端的Shuffle过程 Reduce任务通过RPC向JobTracker询问Map任务是否已经完成，若完成，则领取数据
Reduce领取数据先放入缓存，来自不同Map机器，先归并，再合并，写入磁盘
多个溢写文件归并成一个或多个大文件，文件中的键值对是排序的
当数据很少时，不需要溢写到磁盘，直接在缓存中归并，然后输出给Reduce
Reduce任务接收到&lt;key，value-list&gt;之后，处理用户撰写的Reduce函数中的处理逻辑，完成对数据的分析，最终结果的输出格式为&lt;key，value&gt;最终结果经过OutputFormat模块，对输出格式进行检查，以及输出相关目录是否存在最后写入到分布式文件系统HDFS中 MapReduce应用程序的执行过程 程序部署执行Map任务读数据，到缓存本地（磁盘）写数据远程读数据写输出HDFS文件 MapReduce实例分析：WordCount 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cda930fd4581be66a2dc5aee5e819bb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/195d97dc0247d79633c3aeba9f65ca66/" rel="bookmark">
			flex:1什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结论
flex：1即为flex-grow：1，经常用作自适应布局，将父容器的display：flex，侧边栏大小固定后，将内容区flex：1，内容区则会自动放大占满剩余空间。
原理
flex属性 是 flex-grow、flex-shrink、flex-basis三个属性的缩写。
推荐使用此简写属性，而不是单独写这三个属性。
flex-grow：定义项目的的放大比例；
默认为0，即 即使存在剩余空间，也不会放大； 所有项目的flex-grow为1：等分剩余空间（自动放大占位）； flex-grow为n的项目，占据的空间（放大的比例）是flex-grow为1的n倍。 不设置flex-grow时:
&lt;div style="display:flex;border:1px solid #000;"&gt; &lt;div style="height:100px;background-color:gray;"&gt;1&lt;/div&gt; &lt;div style="height:100px;background-color:red;"&gt;2&lt;/div&gt; &lt;div style="height:100px;background-color:gray;"&gt;3&lt;/div&gt; &lt;/div&gt; 所有项目的flex-grow为1时:
&lt;div style="display:flex;border:1px solid #000;"&gt; &lt;div style="height:100px;background-color:gray;flex-grow:1;"&gt;1&lt;/div&gt; &lt;div style="height:100px;background-color:red;flex-grow:1;"&gt;2&lt;/div&gt; &lt;div style="height:100px;background-color:gray;flex-grow:1;"&gt;3&lt;/div&gt; &lt;/div&gt; flex-shrink：定义项目的缩小比例；
默认为1，即 如果空间不足，该项目将缩小； 所有项目的flex-shrink为1：当空间不足时，缩小的比例相同； flex-shrink为0：空间不足时，该项目不会缩小； flex-shrink为n的项目，空间不足时缩小的比例是flex-shrink为1的n倍。 不设置flex-shrink时：
&lt;div style="display:flex;border:1px solid #000;"&gt; &lt;div style="height:100px;background-color:gray;width:200px;"&gt;1&lt;/div&gt; &lt;div style="height:100px;background-color:red;width:200px;"&gt;2&lt;/div&gt; &lt;div style="height:100px;background-color:gray;width:200px;"&gt;3&lt;/div&gt; &lt;/div&gt; 第二个item的 flex-shrink为0时：
&lt;div style="display:flex;border:1px solid #000;"&gt; &lt;div style="height:100px;background-color:gray;width:200px;"&gt;1&lt;/div&gt; &lt;div style="height:100px;background-color:red;width:200px;flex-shrink:0;"&gt;2&lt;/div&gt; &lt;div style="height:100px;background-color:gray;width:200px;"&gt;3&lt;/div&gt; &lt;/div&gt; 第一个item的 flex-shrink为1(默认值)，第二个item的 flex-shrink为0，第三个item的 flex-shrink为2时：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/195d97dc0247d79633c3aeba9f65ca66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeb80d7bdf22ff447203bebf5ca64f0d/" rel="bookmark">
			vue&#43;echarts中使图表能循环显示tooltip-使用封装tooltip的方法轮询显示图表数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个 mixin 工具(需要注意的是调用 ecahrts api 方法的变量叫 chart) 需要使用这个 chart 变量来调用提示方法, 下面代码里面有这个变量, 如果不熟悉mixin 就先自己看看, 也不要因为不会用 mixin 就感觉 mixin 不好, 人云亦云, 存在就有存在的意义
支持多系列(series) seriesLength 如果不传默认为0
/* * @Description: 图标自动展示的工具 * @Author: * @LastEditors: chengchongzhen * @Date: 2021-12-22 15:23:51 * @LastEditTime: 2021-12-27 14:27:07 */ export default { data() { return { dataIndex: 0, seriesLength: 0, seriesIndex: 0, dataLength: 0, hideTimer: null } }, beforeDestroy() { if (this.hideTimer) { clearInterval(this.hideTimer) this.hideTimer = null } }, methods: { /** * @description: 自动展示提示 * @param {*} dataLength 数据长度 * @param {*} time 循环时长 * @return {*} */ showTip(dataLength = 6, time = 1500, seriesLength = 0) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeb80d7bdf22ff447203bebf5ca64f0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f55fd9f3a7439f359c5f8862ccb1d337/" rel="bookmark">
			iOS 批量上传图片的 3 种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AFNetworking 在去年年底升级到了 3.0。这个版本更新想必有很多好处，然而让我吃惊的是，它并没有 batch request 接口。之前的 1.x 版本、2.x 版本都实现了这个很常见的需求，不知道作者为何选择在 3.x 中去掉它。
在 AFNetworking 2 中，我们只需一行代码就能解决批量上传的问题：
[AFURLConnectionOperation batchOfRequestOperations:operations progressBlock:^(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations) { NSLog(@"%lu 上传完成，共 %lu", (long)numberOfFinishedOperations, (long)totalNumberOfOperations); } completionBlock:^(NSArray *operations) { NSLog(@"上传完毕"); }]; 但 AFNetworking 3 用的是NSURLSession，而不是用NSOperation来包装NSURLConnection，所以把整个AFURLConnectionOperation类都干掉了。上面的方法不能再用，并且也没有给出替代品。因此，我们只能自己动手了。
实现这个功能，有几个要点：
异步上传。批量请求里的每个请求都应该在不同线程，可以同时上传。在所有请求都完成之后，再通知回调。尽管异步请求的返回先后顺序没有一定，很可能后发出的请求先返回；但是最后回调的时候，请求返回的结果必须要按请求发出的顺序排列。比如，一个很常见的处理是，上传图片的接口返回该图片的 url；那么回调结果里的 url 顺序显然需要跟上传的图片顺序一一对应上。最好传完每张图片也能有一个回调，方便我们告诉用户上传的进度。 同时满足以上要点，主要有3种思路：GCD、NSOperation 以及 promise。这个需求也是示例多线程用法的一个很好的例子，所以我写了这篇比较详细的文章供大家参考。
下面的代码以图片上传为例。测试数据配置了 3 张图片，其中第 2 张图片尺寸最小，往往先上传完毕，用来测试请求发出顺序与返回顺序不一致的情况。 方法一：GCD dispatch group 我们知道，GCD dispatch 是多线程处理最简单的方法。全部请求完成后再通知回调的需求，很适合利用 dispatch group 来完成。至于保证返回结果的顺序，我们只好自己来做了。
首先需要一个方法，对于每张图片生成一个上传请求。
- (NSURLSessionUploadTask*)uploadTaskWithImage:(UIImage*)image completion:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionBlock { // 构造 NSURLRequest NSError* error = NULL; NSMutableURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f55fd9f3a7439f359c5f8862ccb1d337/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fbecd37a9042a289b1c481c94417e18/" rel="bookmark">
			java mysql 数据库备份和还原操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫VX 领Java资料，前端，测试，python等等资料都有
package com.itenp.gen.action; import java.io.BufferedReader; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.InputStream; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.text.SimpleDateFormat; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map; import javax.annotation.Resource; import org.apache.log4j.Logger; import org.springframework.context.annotation.Scope; import org.springframework.stereotype.Controller; import com.itenp.gen.common.Constants; import com.itenp.gen.common.ParameterUtil; import com.itenp.gen.service.i.BackUpServiceI; import com.itenp.gen.system.PropertiesCache; import com.itenp.gen.vo.BackUpVO; import com.itenp.gen.vo.UserVO; /** 说明:数据备份还原 * 作者:fhadmin * from www.fhadmin.cn */ @SuppressWarnings("serial") @Scope("prototype") @Controller("backupAction") public class BackUpAction extends BaseAction { private static Logger log = Logger.getLogger(BackUpAction.class); private String databaseDirectory = PropertiesCache.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fbecd37a9042a289b1c481c94417e18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b756438582907ac71fdf0c25e494b795/" rel="bookmark">
			JDK环境配置&amp;IDEA新建一个JAVA项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、JDK环境配置 1.下载安装包
下载地址&lt;www.oracle.com&gt;
2.下载好安装包后，双击进入安装向导
3.点击“下一步”（可修改默认安装路径）
4.安装完成后点击“关闭”
5.坏境配置
（1）打开“此电脑”——&gt;右键——&gt;“属性”
（2）进入“高级系统设置”
（3）点击“环境变量”
（4）“系统变量”——&gt;“新建”
扫VX 领Java资料，前端，测试，python等等资料都有
（新建：变量名“JAVA_HOME”；变量值是jdk的安装路径）
（5）在新建一个
（注：变量值前面的两个符号是英文的 .;）
(6)
(7)然后点击“新建”，变量值为%JAVA_HOME%\bin，点击“上移”，把它移到第一行，最后点击“确定”
这样坏境就配置完成了。
6.检验是否配置成功
（1）按“Win + R”——&gt;输入“cmd”——&gt;“确定”
（2）输入java -version获取安装的jdk版本信息
（3）检测java.exe命令
（4)检测javac.exe命令
二、IDEA新建一个JAVA项目 1.“File”—&gt;"New"—&gt;"Projeck"
2.
3.可以不用勾选，直接选择"next"
4.
5.“This Window”
6.右键“Scr”——&gt;"new"——&gt;
给项目包命名
7.和第六步差不多
命名
8.写好代码后点击“run”就可以运行了，或者在代码空白处右键——&gt;“run”
扫VX 领Java资料，前端，测试，python等等资料都有
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3afc8d7aa2eab6ec8eb07b7f1e4659f/" rel="bookmark">
			Java 创建 PDF 文件包的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概述
PDF文件包可方便在仅打开一个窗口的情况下阅读多个文档，通过将多个PDF文档或其他非PDF文档封装在一起，打开文件包后可以随意切换查看文件包中的文档，在需要编辑更改的情况，也可以打开文本包中的文档进行编辑。下面，通过Java程序来演示如何来创建PDF文件包。这里分以下两种情况来添加，方法类似。
（1）创建文件包，添加文件夹（父/子文件夹），并添加文档到文件包
（2）创建文件包，添加多个文档到文件包 2. 本次运行环境
代码编译环境：IntelliJ IDEAJDK版本：1.8.0PDF jar包工具：Free Spire.PDF for Java（免费版）测试使用的文档包括：Word文档（.docx2013）、Excel文档（.xlsx2013）、PPT文档（.pptx2013）、PDF文档、txt文档、png图片等 【Jar包导入参考步骤】
①. 手动导入：Project Structure（Shift+Ctrl+Alt+S）打开的界面中选择【Modules】—【Dependencies】，点击“+”，【JARs or directories…】,选择本地路径中的jar包，添加后，勾选，点击“OK”。
②. Maven导入：在pom.xml文件中配置maven仓库路径并指定free spire.pdf.jar 的依赖，然后导入。具体配置内容如下：
扫VX 领Java资料，前端，测试，python等等资料都有
&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;com.e-iceblue&lt;/id&gt; &lt;url&gt;http://repo.e-iceblue.cn/repository/maven-public/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;e-iceblue&lt;/groupId&gt; &lt;artifactId&gt;spire.pdf.free&lt;/artifactId&gt; &lt;version&gt;4.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3. 示例
Java示例代码1-创建文件包时，创建父级/子文件夹，并添加文档到文件夹
Java示例代码2-创建文件包，添加多个文档到文件包
import com.spire.pdf.*; //java www.fhadmin.cn public class Portfolio2 { public static void main(String[] args) { String[] files = new String[] { "sample.pdf", "sample.docx", "sample.xlsx","sample.pptx","sample.txt","sample.png" }; //创建PdfDocument实例 PdfDocument pdf = new PdfDocument(); for (int i = 0; i &lt; files.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3afc8d7aa2eab6ec8eb07b7f1e4659f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96c5fd685dde0d69e334339937000911/" rel="bookmark">
			JVM，我就不信学不会你了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM 对 Java 有多重要，对程序员面试有多重要，这些不用多说。
如果你还没意识到学 JVM 的必要性，或者不知道怎么学 JVM，那么看完这篇文章，你就能知道答案了。
曾经的我很不屑于学 JVM，但是后来发现不学不行。这就像和媳妇吵架之后我不想道歉一样，不道歉那是不可能的，道歉是早晚的事儿，逃不掉。
后来我明白了：
认怂越晚，结局越惨。
但是我学的时候才知道：JVM，你太过分了，太难学了！
我的学习过程可以说非常坎坷，不过经历坎坷之后，我倒是发现学 JVM 的门道很多。
以我的经验加上和同行们的交流，我认为学 JVM 最好的方法是：
在程序员不同的水平段，做精准的学习。
所谓的精准学习，就是学习对自己工作有巨大帮助的知识点。以工作内容带动学习，等到积累多了，再一举攻克所有 JVM 知识点，最终熟练掌握 JVM 底层原理。
下面我来说说初级、高级、资深程序员，如何循序渐进、分步学习。
扫VX 领Java资料，前端，测试，python等等资料都有
初级程序员怎么学 对刚入行的新手程序员，工作一般是修复简单 bug、开发简单功能。如何编码少出 bug，是这个阶段的核心问题。
对于这个核心问题，JVM 原理必须深入掌握两个知识点。
1. 类的初始化
类的初始化，要了解的非常深入才可以。否则，一不留神就会往项目里引入一些有关初始化的 bug。
比如看看下面这段代码：
public class ParentClass { private int parentX; public ParentClass() { setX(100); } public void setX(int x) { parentX = x; } } public class ChildClass extends ParentClass{ private int childX = 1; public ChildClass() {} @Override public void setX(int x) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96c5fd685dde0d69e334339937000911/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4633a76554f6bdd59db6aed01983fa8/" rel="bookmark">
			基于 STM32F103 在 FATFS 模式下对 SD 卡的数据读取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、SD卡简介1.1 什么是SD卡1.2 SD卡的特点1.3 SD卡的寄存器1.4 SPI 模式如何访问SD卡1.5 SD卡初始化 二、使用STM32CubeMX创建工程三、使用kei烧入程序观察结果3.1 硬件接线3.2 效果演示 四、总结参考文章 一、SD卡简介 1.1 什么是SD卡 1.2 SD卡的特点 1.3 SD卡的寄存器 CSD寄存器包括卡的容量，数据块的大小，非常重要的寄存器
1.4 SPI 模式如何访问SD卡 SD卡命令介绍
CMD0用来复位SD卡。
CMD8用来区分2.0卡还是1.0卡。
CMD9读取卡的特定的数据寄存器SCR。
CMD10读取卡的标志寄存器CID。
CMD16设置块大小，对于SDHC无效，SDHC固定是512字节。
CMD17读取一个块的数据。
CMD18读取多个块的数据。
CMD24是写入一个块的数据。
CMD25是写入多个块的数据。
每个指令都有一个响应。
SD卡和单片机的通信过程
1.5 SD卡初始化 初始化步骤：
二、使用STM32CubeMX创建工程 最后保存即可
创建工程后并修改部分源码，最后的工程链接在下面
链接：https://pan.baidu.com/s/1L5E4BG8cqvpvtDxOdUUXoQ
提取码：e63q
三、使用kei烧入程序观察结果 3.1 硬件接线 STM32F103C8T6SD卡PA4CSPA5SCKPA6MISOPA7MOSI 注意事项：
1、stm32核心板使用5V为SD卡供电
2、尽量减少连线，或者使用短线连接
3、实验前先检查下SD卡是否为FATS格式，如果不是，要重新格式化SD卡
3.2 效果演示 打开串口助手即可观察到一些结果
然后将SD卡插入电脑，即可观察到在U盘中创建了一个HELLO.TXT文件
四、总结 本次实验练习了如何通过stm32对SD卡进行初始化，因为这次实验没有前人来铺路了，所以雷只有自己来踩，实验的过程还是比较坎坷的，最后还是在老师和其他同学的帮助下做出来的。以前都没想过供电的电源会影响实验的结果。通过这次实验学到了一些关于SD卡和SD卡协议的知识，但是也只是一些基本的东西，以后遇到需要应用SD卡的情况的话，需要更深入地学习的话应该会更加得心应手。
参考文章 SD卡简介
STM32用cube配置FATFS模式下SPI读写SD卡
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bfaa2d2d78201a097b96bc5c2533e82/" rel="bookmark">
			大数据学习之NoSQL数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NoSQL的概述 NoSQL的特点 灵活的扩展性灵活的数据模型与云计算密切相关 传统关系数据库性能缺陷 无法满足海量数据的管理需求无法满足高并发的需求无法满足高可扩展性和高可用性的需求 MySQL集群方式的缺陷 复杂性，整个集群部署管理配置都非常复杂延迟性，当主库压力较大时，就会带来较大的延迟扩容问题，整个集群压力过大时，需要增加新机器对整个数据集进行重新分区，非常复杂 NoSQL数据库与关系数据库的比较 数据库原理方面，关系数据库具有完备的关系代数理论作为基础；NoSQL数据库缺乏理论基础数据规模方面，关系数据库很难实现横向扩展，纵向扩展非常有限；NoSQL数据库具有非常好的水平可扩展性数据库模式方面，关系数据库要定义严格的数据库模式，而且要严格遵守事先定义的数据库模式；NoSQL数据库的数据模型非常灵活查询效率方面，关系数据库在适当数据量下的查询效率高，数据量增大后查询效率下降；NoSQL为构建面向复杂查询的索引，查询性能差，虽然NoSQL可以使用MapReduce来加速查询，但是，在复杂查询方面的性能仍然不如关系数据库。事务一致性方面，关系数据库遵循ACID事务模型可以保证事务强一致性；NoSQL数据库放松了对事务ACID四性的要求，而是遵守BASE模型，只能保证最终一致性。数据完整性方面，关系数据库可以很容易实现数据完整性，比如通过主键或者非空约束来实现实体完整性，通过主键、外键来实现参照完整性，通过约束或者触发器来实现用户自定义完整性；NoSQL数据库却无法实现完整性约束可扩展性方面，关系型数据库扩展性较差；NoSQL可扩展性好可用性方面，关系数据库在任何时候都以保证数据一致性为优先目标，其次才是优化系统性能，随着数据规模的增大，关系数据库为了保证严格的一致性，只能提供相对较弱的可用性；NoSQL数据库都能提供较高的可用性，能在短时间内迅速返回所需的结果标准化方面，关系数据库遵循SQL标准，标准化比较完善；NoSQL数据库未形成通用的行业标准技术支持方面，关系数据库大多是商业数据库，可获得非常强大的技术和后续服务支持；NoSQL数据库很多属于开源产品，处于发展阶段可维护性方面，关系数据库需要管理员维护；NoSQL数据库没有成熟的基础，维护较为复杂 NoSQL的四大类型 1. 键值数据库，比如redis 数据模型：键是一个字符串对象，值可以是任意类型的数据
应用范围：涉及频繁的读写，拥有简单数据类型的应用，如会话、配置文件、参数、购物车等，存储配置和用户数据信息的移动应用
优点：扩展性好，灵活性好，大量写操作时性能高
缺点：无法存储结构化信息，条件查询效率较低
不适用情形：不是通过键而是通过值来查（键值数据库没有通过值查询的途径）、需要存储数据之间的关系（在键值数据库中，不能通过两个或两个以上的键来关联数据）、需要事务的支持（在一些键值数据库中，产生故障时，不可以回滚 ）
2. 列族数据库，HBase根据列族进行垂直划分，根据行键进行水平划分 数据模型：列族
应用范围：分布式数据存储与管理，数据在地理上分布于多个数据中心的应用程序，可以容忍副本中存在短期不一致情况的应用程序，拥有动态字段的应用程序，拥有潜在大量数据的应用程序，大到几百TB的数据
优点：查找速度快，可扩展性强，容易进行分布式扩展，复杂性低
缺点：功能较少，大都不支持强事务一致性
不适用情形：需要ACID事务支持的情形，Cassandra等产品就不适用
3. 文档数据库，本质上可以看成一个键值数据库，它的值是文档而不是非标量，比如mongoDB 特性：能够将自己的数据的内容和类型进行自我描述
常用数据结构：JSON数据格式
应用范围： 存储、索引并管理面向文档的数据或者类似的半结构化数据，比如，用于后台具有大量读写操作的网站、使用JSON数据结构的应用、使用嵌套结构等非规范化数据的应用程序
优点：性能好（高并发），灵活性高，复杂性低，数据结构灵活提供嵌入式文档功能，将经常查询的数据存储在同一个文档中既可以根据键来构建索引，也可以根据内容构建索引
缺点：缺乏统一的查询语法
不适用情形：在不同的文档上添加事务。文档数据库并不支持文档间的事务，如果对这方面有需求则不应该选用这个解决方案
4. 图数据库，以图结构方式存储相关信息，比如Neo4j 数据模型：图结构
应用范围：专门用于处理具有高度相互关联关系的数据，比较适合于社交网络、模式识别、依赖分析、推荐系统以及路径寻找等问题
优点：灵活性高，支持复杂的图形算法，可用于构建复杂的关系图谱
缺点：复杂性高，只能支持一定的数据规模
NoSQL数据库的三大理论基石 1. CAP C（Consistency）一致性，指任何一个读操作总能读到之前完成的写操作的结果，在分布式环境中，多点的数据是一
致的，或者说，所有节点在同一时间具有相同的数据A（Availability）可用性，指快速获取数据，可以在确定的时间内返回操作结果，保证每个请求不管成功或者失败都有响应P（Partition tolerance）分区容忍性，是指当出现网络分区的情况时（即系统中的一部分节点无法和其他节点进行通信），分离的系统也能够正常运行，也就是说，系统中任意信息的丢失或失败不会影响系统的继续运作
一个分布式系统不可能同时满足一致性、可用性和分区容忍性这三个需求，最多只能同时满足其中两个 2. BASE 一个数据库事务具有ACID四性：
A（Atomicity）：原子性，是指事务必须是原子工作单元，对于其数据修改，要么全都执行，要么全都不执行C（Consistency）：一致性，是指事务在完成时，必须使所有的数据都保持一致状态I（Isolation）：隔离性，是指由并发事务所做的修改必须与任何其它并发事务所做的修改隔离D（Durability）：持久性，是指事务完成之后，它对于系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持 3. 最终一致性 文档数据库MongoDB MongoDB由C++语言编写，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能，MongoDB旨在为web应用提供可扩展的高性能数据存储解决方案。
MongoDB特点
操作简单，面向文档存储可以设置任何属性的索引，实现快速排序具有很好的水平可扩展性支持丰富的查询表达式，可查询文档中内嵌的对象及数据可替换已完成文档中某个指定的数据字段MongoDB中的MapReduce主要是用来对数据进行批量处理和聚合操作安装简单
在一个关系型数据库中，一篇博客的相关内容会存放在多张数据表中（如下图）。在查询时，需要‘join’操作
在文档数据库MongoDB中，能用一个文档来表示一篇博客，评论与投票作为文档数组，放在正文主文档中。这样数据更易于管理，消除了传统关系型数据库中影响性能和水平扩展性的“JOIN”操作。 数据库 一个MongoDB中可以建立多个数据库。MongoDB的默认数据库为"db"，该数据库存储在data目录中MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文
件中。 文档
文档是一个键值(key-value)对(即BSON)。
MongoDB的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别集合
集合就是MongoDB文档组，类似于关系数据库中的表格，关系数据库中的一行记录对应一个MongoDB文档
集合存在于数据库中，没有固定的结构，可对集合插入不同格式和类型的数据
MongoDB数据类型较多，有字符型、整型、布尔型等
MongoDB安装 Window平台安装MongoDB
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bfaa2d2d78201a097b96bc5c2533e82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6acc6da073ffa130adf669c49670755/" rel="bookmark">
			微信小程序调用域名服务器的服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序得益于它的简单便捷，在日常生活中应用的很普遍。做过开发的同学都知道，微信的前端比较简单易懂，并且微信自带云开发，提供云存储，可以满足一些商家或者自媒体的需求。如果企业类的用户使用小程序，数据是存在企业自己的服务器上，小程序也提供了访问域名服务器服务的方法。
因为小程序的统一入口都在微信开发上，所以对域名的管控比较严格。域名会指向一台或几台服务器，域名实名制其实就是用来确定谁对被访问的服务负责。之前我们提出想用小程序来实现员工自助，但是供应商推脱说小程序访问企业域名有限制，他们遇到过怎么连也连不上的问题。我特意做了一下测试，试试我们的域名能不能被正常访问。
1、在本地服务器创建api服务，在内网中使用小程序访问，前提是勾选不校验域名，服务返回正常，测试通过。
2、请网络同事将本地的IP映射到域名和端口，开通网络访问，做好证书配置。类似http://10.0.xxx.xx:8080映射到https://hrapi.xxxxxx.com.cn:8084/，此时在小程序中直接调用域名服务（设置校验域名）会提示地址不在合法域名列表中。
3、在小程序开发设置中设置域名服务器
4、此时再调用此服务，可以正常得到返回消息。
结论：通过小程序可以正常访问我们的域名服务地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/973f0513925411d7e50c62d62b0655cc/" rel="bookmark">
			使用Python操作MongoDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信公众号：运维开发故事，作者：double冬
通常在项目中，一般都需要一种编程语言来操作数据库，使用Python来操作数据库有着天然的优势，因为Python的字典和MongoDB的文档几乎是一样的格式，本文讲介绍如何使用Python进行MongoDB操作
1 连接数据库 1.1 安装PyMongo 使用Python操作MongoDB需要使用一个第三方库——PyMongo。安装这个库与安装Python其他的第三方库一样，使用pip安装即可：
python3 -m pip install pymongo 也可以指定安装的版本:
python3 -m pip3 install pymongo==3.5.1 更新 pymongo 命令：
python3 -m pip3 install --upgrade pymongo 安装完成以后，打开Python交互环境，导入PyMongo。如果不报错（如图所示），则表示安装成功
image.png
1.2 连接数据库 要使用PyMongo操作MongoDB，首先需要初始化数据库连接。
（1）如果 MongoDB 就运行在本地电脑上，而且也没有修改端口或者添加用户名和密码，则初始化MongoClient的实例不需要带参数，直接写为以下格式： import pymongo conn = pymongo.MongoClient() （2）如果MongoDB运行在其他服务器上，则需要使用“URI（UniformResource Identifier，统一资源标志符）”来指定链接地址 import pymongo conn = pymongo.MongoClient('mongodb://test:12345@45.10.110.77:27019') MongoDB的URI格式如下：mongodb://用户名：密码@服务器IP或域名：端口例如：
（3）如果没有设置权限验证，则不需要用户名和密码，可写为 import pymongo conn = pymongo.MongoClient('mongodb://45.10.110.77:27019') 1.3 连接库与集合 PyMongo连接库与集合有两种方式
方式1 连接数据库与集合的方法1
from pymongo import MongoClient conn = MongoClient() databae = conn.数据库名 collection = database.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/973f0513925411d7e50c62d62b0655cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95ad4c0f34350acc0bee7e6d7dabb8f6/" rel="bookmark">
			JavaScript弱类型的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 异常需要等到运行时才能发现 const obj = {}
// obj.foo()
setTimeout(() =&gt; {
obj.foo()
}, 1000000)
=========================================
2. 函数功能可能发生改变 function sum (a, b) {
return a + b
}
console.log(sum(100, 100))
console.log(sum(100, ‘100’))
=========================================
3. 对象索引器的错误用法 const obj = {}
obj[true] = 100 // 属性名会自动转换为字符串
console.log(obj[‘true’])
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d9c39c2db9c1cd8050c919b6e068966/" rel="bookmark">
			TypeError: Cannot read properties of undefined (reading ‘matched‘)vue项目创建之后写路由报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue项目创建之后写路由报错
原代码：
修改之后代码
在 import 路由文件后，命名为Router，就会出现报错，
原因：
router 才是Vue实例化的配置字段名称，不识别其他的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/066503d8e5d09d9b48db457db94e77f4/" rel="bookmark">
			gradient_accumulation_steps --梯度累加理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：
https://blog.csdn.net/Princeicon/article/details/108058822
https://blog.csdn.net/weixin_43643246/article/details/107785089
假设情景：
batch_size = 10 #每批次大小
total_num = 1000 #数据总量
按照 训练一个批次数据，更新一次梯度；
训练步数 train_steps = 1000 / 10 = 100
梯度更新步数 = 1000 / 10 = 100
当显存不足以支持每次 10 的训练量！
需要减小 batch_size
通过设置gradient_accumulation_steps = 2
batch_size = 10 / 2 =5
即训练2个批次数据，更新一次梯度，每个批次数据量为5（减小了显存压力，但未改变梯度更新数据量–10个数据一更新）
结果：训练步数 tran_steps = 1000 / 5 = 200 增加了一倍
梯度更新步数 1000 / 10 = 100 未改变
总结：梯度累加就是，每获取1个batch的数据，计算一次梯度，梯度不清空，不断累加，累加到gradient_accumulation_steps次数后，根据累加梯度更新参数，清空梯度，进行下一次循环。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca9e25d689fdb8ae0516531d5716763f/" rel="bookmark">
			使用OpenCV进行多边形绘制和填充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 OpenCV中在图像上进行多边形绘制和填充的函数分别为polylines和fillPoly，在图像分割任务中午中，可用于将预测结果绘制到目标图像。
简单的实现：
import cv2 import numpy as np img = np.zeros([600, 600, 3]) points = np.array([[200, 200], [200, 300], [270, 370], [340, 300], [340, 200], [270, 130]], np.int32) img = cv2.polylines(img, [points], isClosed=True, color=[0, 0, 255], thickness=5) img = cv2.fillPoly(img, [points], color=[0, 255, 0]) cv2.imwrite(out_path, img) 结果：
在多边形线段的的绘制中一般需要定义5个参数，分别为原始图像img，多边形节点points，是否闭合，线段颜色和线段宽度。多边形填充只需要定义三个参数，原始图像，节点points，填充颜色。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/000f8356674ba7f71b01172fd26c1278/" rel="bookmark">
			商业智能BI不仅仅是报表工具，它的真正价值是：决策支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个独立系统，商业智能BI解决两个问题。一是信息的发布，它可以在正确的时间向正确的人提供正确的信息。几十年来，我们看到的商业智能项目，至少有90%的项目成果变成了提供信息的报告。这种情况下，改变的只是信息的呈现方式。过去，基于纸张，它变成电子文档；现在，通过网络和技术变化，但它仍然是一个报表！如果BI只拥有报表功能，那么它不应该被称为商业智能，而是业务报表。商业智能BI之所以被称为商业智能BI，是因为它还有另一个重要的意义–决策支持。
商业智能BI可以将企业不同的业务系统（如ERP、CRM、OA等）的数据，提取出有用数据并进行整合清洗，再进行数据分析及处理，高效快速地为企业提供报表展现与分析，进而提供决策支持。
众所周知，报表是可以标准化的。比如一些大企业定义了40种银行对账单，但最终根据各部门所需作用来定义报表外在形式，它可能会变成40万种报表，这就是提供标准报表。
但是，有没有制定决策的标准呢？有标准的决定吗？答案当然是没有。当决策层得到不同信息时，基于决策情景与目标，他们会以不同的方式思考，进而做出不同的决定。也就是说，支持个性化决策。当然，这里的个性化决策并不代表允许偏离业务目标，随心所欲做决策，即错误决策。这这种情况下，根据已经发生的历史数据摸清“过去发生了什么”及“未来会发生什么”，就变得更加有意义，因为这是个性化决策的科学依据。
一个满足使用的BI工具在决策支持里主要要解决的问题是什么呢？一个是即兴查询和分析。在发现问题甚至防患问题时，都能够即时地查询和分析。举个股市的例子来说，A股份狂涨，这时炒股的你想要去分析“它为什么涨”？标准的KIP只能告诉你”现状是什么”，标准的报表也只能告诉你”过去是什么”，但是它们都不能解决A股为什么涨及它后续走势的预测。关于原因的分析，涉及关联因素，以及关联因素的其他载体比较…这么复杂的一个分析，不可能事先做好所有的Cube以及标准的KPI。一个合格的的BI工具能够借助其内置模型，快速对相关因素进行大量的科学计算，并通过报表图形的可视化展示进而支持决策。
在这里就给大家介绍一款合格的BI工具，由广州思迈特软件推出的Smartbi覆盖数据分析的全流程，包括数据连接与准备、数据分析与挖掘、数据共享与应用，除了满足你日常的报表制作需求，用来做决策支持也是非常好用的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/083e8072766ddecd0ee84318f825626c/" rel="bookmark">
			RT-Thread 断言：assertion failed at function:rt_object_init 等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		assertion failed at function:rt_object_init，
|| assertion failed at function:rt_mq_send …等错误
[W/UART] Warning: There is no enough buffer for saving data, please increase the RT_SERIAL_RB_BUFSZ option.
原因：1.使用的对象未创建或初始化，如：事件，消息队列。。。
2.在创建或初始化对象前，使用了对象相关函数 如：rt_mq_send,rt_event_send
(对象还未初始化，在别的线程调用了)
3.初始化函数使用错误，使用init静态初始化，应该提前分配好控制块空间，
如：struct rt_messagequeue mq; 而不是rt_messagequeue_t，rt_messagequeue_t只是一个指 针，没有实际空间，用于接收动态创建(create)对象时，返回的对象句柄。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7db1c2f7ee825a12f064aee6d265514/" rel="bookmark">
			vsomip sub/notify 调试问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 统一台机器调试vsomeip-3.1.20.3 中examples 的 订阅/通知， 通知的应用报此错，
$VSOMEIP_CONFIGURATION=vsomeip-service.json VSOMEIP_APPLICATION_NAME=service-sample ./notify-sample
2021-11-23 10:34:34.334661 [warning] Reliability type for event [1234.5678.777] was not configured Using : RT_UNRELIABLE
2021-11-23 10:34:34.335109 [warning] Reliability type for event [1234.5678.778] was not configured Using : RT_UNRELIABLE
2021-11-23 10:34:34.335208 [warning] Reliability type for event [1234.5678.779] was not configured Using : RT_UNRELIABLE
2021-11-23 10:34:34.335830 [info] Parsed vsomeip configuration in 0ms
2021-11-23 10:34:34.335928 [info] Using configuration file: "vsomeip-service.json".
2021-11-23 10:34:34.336016 [info] Configuration module loaded.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7db1c2f7ee825a12f064aee6d265514/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5718c26e4673948ad8f8cb26d4286810/" rel="bookmark">
			解决VUE前端首页加载缓慢，app.js文件过大的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章以Jeecg前端为例，其他框架略过步骤1即可
经过分析及资料查询，解决此问题有三个路径可走： 目录
1.删除不需要的依赖
2.进行jscss压缩(1.打包时压缩 2.nginx压缩)
2.1打包时压缩
2.2nginx压缩(官网推荐)
3.使用cdn加速
1.删除不需要的依赖 分析发现的在线表单占用较大，考虑到实际场景中基本不使用，删除相关依赖。需要修改3个文件
util.js
main.js
package.json
然后删除node_modules, yarn重新install，再build，效果立竿见影！
2.进行jscss压缩(1.打包时压缩 2.nginx压缩) 2.1打包时压缩 打包的时候通过webpack配置生成对应的 .gz 文件，浏览器请求xx.js/css等文件时，服务器返回对应的xxx.js.gz文件；浏览器请求xx.js文件时，服务器对xx.js文件进行gzip压缩后传输给浏览器。
webpack打包生成gz文件
安装插件（compression-webpack-plugin）：
npm install compression-webpack-plugin --save-dev vue.config.js文件进行webpack配置（没有此文件可以在项目根路径创建一个文件）：
const CompressionPlugin = require('compression-webpack-plugin'); module.exports = { plugins: [ new CompressionPlugin({ algorithm: 'gzip', // 使用gzip压缩 test: /\.js$|\.html$|\.css$/, // 匹配文件名 filename: '[path].gz[query]', // 压缩后的文件名(保持原文件名，后缀加.gz) minRatio: 1, // 压缩率小于1才会压缩 threshold: 10240, // 对超过10k的数据压缩 deleteOriginalAssets: false, // 是否删除未压缩的源文件，谨慎设置，如果希望提供非gzip的资源，可不设置或者设置为false（比如删除打包后的gz后还可以加载到原始资源文件） }), ], }, }; 这里对js、html、css文件进行了压缩处理，并没有进行图片压缩，因为图片压缩并不能实际减少文件大小，反而会导致打包后生成很多同大小的gz文件，得不偿失。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5718c26e4673948ad8f8cb26d4286810/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a85d7a219809f03c3477edaaf4e34813/" rel="bookmark">
			c&#43;&#43;中vector在push_back时调用移动构造函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++构造函数的调用 c++11中构造函数包括：
默认构造函数拷贝构造函数移动构造函数拷贝赋值函数移动赋值函数 那么请思考下面的一个案例中其调用的顺序是怎样的：
class A { public: A() { printf("A()--默认构造\n"); } ~A() { printf("~A()--析构函数\n"); } A(const A &amp;a) { printf("A(const A&amp; a)--复制构造\n"); } A(A &amp;&amp;a) { printf("A(A&amp;&amp; a)--移动构造\n"); } A &amp;operator=(const A &amp;a) { printf("operator=(const A&amp; a)--赋值构造\n"); return *this; } A &amp;operator=(A &amp;&amp;a) { printf("operator=(A&amp;&amp; a)--移动赋值构造\n"); return *this; } }; int main() { std::vector&lt;A&gt; vec; vec.reserve(2); for (int i = 0; i &lt; 4; ++i) { cout&lt;&lt;i&lt;&lt;endl; vec.push_back(A()); } cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a85d7a219809f03c3477edaaf4e34813/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f21cec240fe0eb3a74fcd68e9a6e34df/" rel="bookmark">
			【微机汇编语言学习笔记（四）】十进制数的ASCII转换为BCD码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目的：从键盘输入五位十进制数的ASCII码，存放与3500H起始的内存单元中，将其转换为BCD码，再分别存入350AH起始的地址单元内。若输入不是十进制的ASCII，则对应存放结果的单元内容为“FF”。
设计思路：先对输入的ASCII码大小进行判断，判断其是否是在30H~39H范围内。若不在，则让其输出0FFH；若在该范围内，则将该数进行减30H的操作，所得差值即为该ASCII码对应的BCD码。
程序
SSTACK SEGMENT STACK DW 64 dup(?) SSTACK ENDS CODE SEGMENT ASSUME CS:CODE START:MOV CX,0005H ;转换位数 MOV DI,3500H ;ASCII码的起始地址 A1: MOV BL,0FFH ;将错误标志存入BL MOV AL,[DI] ;将ASCII码送入AL ;判断该ASCII是否大于3AH CMP AL,3AH ;比较AL中ASCII码与3AH的大小 JNB A2 ;若AL中ASCII码大于或等于3AH则转A2 ;判断该ASCII是否小于30H SUB AL,30H ;将AL中值减去30H，将所得结果存入AL中 JB A2 ;小于30H则转A2 MOV BL,AL ;将已经转换后的BCD码送到BL A2: MOV AL,BL MOV [DI+0AH],AL;将最终转换结果送入结果保存区 INC DI LOOP A1 ;判断是否转换完 MOV AX,4C00H INT 21H ;结束程序 CODE ENDS END START 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2288d019be59d7da5dc26795ddd6092/" rel="bookmark">
			复习笔记JAVA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数组的工具类Arrays冒泡排序如果这个类提供了其他的构造函数，默认的无参构造会被覆盖掉，所以需要手动提供无参构造静态资源是类资源，随着类的加载而加载，只加载一次，并且优先于对象进行加载，直到类消失，它才会消失接口其实是对外暴露的一套规则，是一套开发规范，以后要面向接口进行编程，是先天设计的结果抽象类与接口的区别**常见异常：**String转StringBuilder：StringBuilder的：Integer i1 = Integer.valueOf();数据只要在-128~127有一个高效的效果java集合关系图线程五态模型线程实现方式两种常见的锁构造方法对于不想进行序列化的变量，使用transient关键字修饰。string常用方法集合的跨苏失败机制fail-fast数组与list转换sql执行顺序什么是ServletLinux查看日志**杀死进程命令:****查询任意服务****@LoadBalanced**小节面试分析 数组的工具类Arrays 1)toString(数组名) : 打印数组中所有的元素
2)sort(数组名) ：对数组中的元素进行排序
3)copyOf(原来数组的名字，新数组的长度)
如果新长度=旧长度–普通复制
如果新长度&gt;旧长度–扩容
如果新长度&lt;旧长度–缩容
注意：本方法并不会改变原来数组，而是创建指定长度的新数组
冒泡排序 1）如果有n个数，最多比较n-1轮
2）每一轮中如何比较？
从头开始，把所有数过一遍【相邻比较，位置不对就互换】
3）之前轮中比较出来的最大值，不需要参与下一轮的比较
4）写法：外层循环控制的是比较的轮数，内层循环控制的是比较的次数
拓展：可以了解一些其他的排序算法，比如二分排序，快速排序，归并排序，全排序
如果这个类提供了其他的构造函数，默认的无参构造会被覆盖掉，所以需要手动提供无参构造 静态资源是类资源，随着类的加载而加载，只加载一次，并且优先于对象进行加载，直到类消失，它才会消失 接口其实是对外暴露的一套规则，是一套开发规范，以后要面向接口进行编程，是先天设计的结果 抽象类与接口的区别 抽象类是一个特殊的类，使用class定义，特殊在这个类中可以定义没有方法体的方法(抽象方法)
接口可以理解成一个特殊的抽象类，特殊在接口中所有的方法都是抽象方法，但注意接口不是类，用interface定义
抽象类中有构造方法，为了给子类创建对象时调用
接口中没有构造方法的，子类调用的是父类的构造方法
接口可以多继承，但抽象类只能单继承
抽象类可以定义普通的成员变量，但接口只能定义静态常量
接口与抽象类均不可以实例化/创建对象
抽象是后天重构的结果，接口是先天设计的结果
常见异常： 空指针异常
IO异常
sql异常
数据库连接异常
数组越界异常
字符串越界异常
找不到类异常
算数异常
String转StringBuilder： String s = “abc”; StringBuilder sb = new StringBuilder(s);
StringBuilder的： StringBuilder转String：
StringBuilder sb = new StringBuilder();
sb.append(“abc”);
String s = sb.toString();
总结一句话，拼接多用StringBuilder,用完转回String用String丰富的方法
Integer i1 = Integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2288d019be59d7da5dc26795ddd6092/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0112be762da105532dd22a04026cba72/" rel="bookmark">
			qt错误2-error: forward declaration of ‘class xxx‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这也是qt开发中，经常遇到的错误：
字意就是：提前声明了变量，这个错误是在头文件当中提示的，其含义就是：这个类未定义
与上面qt错误1的本质是一样的：
可以声明一个类而不定义它
class Student;//declaration of the Student class
这个声明,有时候被称为前向声明(forward declaration),在程序中引入了类类型的Student.在声明之后,定义之前,类Student是一个不完全类型(incompete type),即已知Student是一个类型,但不知道包含哪些成员.
不完全类型只能以有限方式使用,不能定义该类型的对象,不完全类型只能用于定义指向该类型的指针及引用,或者用于声明(而不是定义)使用该类型作为形参类型或返回类型的函数.
也就是说我们使用前置声明是因为不想引入该类的头文件，但是前置声明是有限制的，也就是，只能用来定义前置声明类的指针或者引用。这里我继承了该类，而继承是需要了解类的内部结构的，所以造成了这个错我。
在QT当中引入界面类时：
在未定义界面类时，就会出现这个问题，其也是用的指针，但会报错，有些奇怪？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2acc049e6216c3c9e0f547bbddec2c6b/" rel="bookmark">
			公司面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是注解，如何使用，
注解：注解是JDK 1.5之后引入的一个特性，与类、接口、枚举是在同一个层次。
它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来
对这些元素进行说明，注释。
可以看作是对 一个 类／方法 的一个扩展的模版，
每个 类／方法 按照注解类中的规则，来为 类／方法 注解不同的参数，
在用到的地方可以得到不同的 类／方法 中注解的各种参数与值。
注解是一种元数据形式。即注解是属于java的一种数据类型，和类、接口、数组、枚举类似。
注解用来修饰，类、方法、变量、参数、包。
注解不会对所修饰的代码产生直接的影响。
使用：在每个方法上面进行调用。
2、注解的执行过程是什么样的
这个我理解的是看具体知识点的注解，主要是Spring的
3、orm框架解决了什么问题，如果让你实现，思路是啥
ORM解决的主要问题是对象关系的映射。域模型和关系模型分别是建立在概念模型的基础上的。
域模型是面向对象的，而关系模型是面向关系的。一般情况下，一个持久化类和一个表对应，类
的每个实例对应表中的一条记录，类的每个属性对应表的每个字段。 ORM：将数据映射到对象。操作对象来操作数据库。类(model)映射到表，属性映射到字段
自己实现思路：
定义父类，实现mysql连接、封装CURD、事务
所有的Model都继承父类，定义表名
4、怎么理解面向接口编程
什么是接口？
-- 在表面上是由几个没有主体代码的方法定义组成的集合体，有唯一的名称，可以被类或其他接口所实现（或者也可以说继承）， 由关键词 interface 修饰。
什么是面向接口编程？
-- 在系统分析或架构设计中，每个层级的程序并不是直接提供程序服务，而是定义一组接口，通过实现接口来提供功能。面向接口编程实际是面向对象编程的一部分。
5.接口的定义和实现分开（分开有什么好处呢？）
首先，项目一般是由团队共同开发来完成的，在其中，接口的定义一般是由架构师来设定，然后又编程人员来实现完成，架构师根据架构、设计规则来设定接口，把握项目的整体视图和编写规范，编程人员实现具体业务逻辑，分工明确，程序清晰。
其次，从实现上看，接口的定义时间很短，但接口的实现周期相对较长，若一个编程人员需要调用其他人员编写的某个方法时，可以采用多态的方式获取接口对象，来调用方法，这样保证团队共同完成开发。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c82e56e7e31a39caa1668de45c716447/" rel="bookmark">
			Element&#43;Vue&#43;SVG给下拉框选项添加图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单记录一下
代码 SvgIcon.vue 组件用来简单封装svg
&lt;template&gt; &lt;svg v-else :class="svgClass" aria-hidden="true" v-on="$listeners"&gt; &lt;use :xlink:href="iconName" /&gt; &lt;/svg&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'SvgIcon', props: { iconClass: { type: String, required: true }, className: { type: String, default: '' } }, computed: { iconName() { return `#icon-${this.iconClass}` }, svgClass() { if (this.className) { return 'svg-icon ' + this.className } else { return 'svg-icon' } } } } &lt;/script&gt; &lt;style scoped&gt; .svg-icon { width: 20px; height: 20px; vertical-align: middle; fill: currentColor; overflow: hidden; } &lt;/style&gt; 全局注册svg
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c82e56e7e31a39caa1668de45c716447/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fccc27562aa18b40dacdd6dca450dd13/" rel="bookmark">
			消费互联网 VS 产业互联网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		何为消费互联网?何为产业互联网？所谓消费互联网，就是以个人为服务对象，从电商、社交、搜索等领域的消费为主线，渗透到百姓生活的各个领域，极大地影响人们的生活和消费习惯。而产业互联网是以生产者为用户，以生产和交易活动为目标的互联网应用，体现在互联网对各产业的生产、交易、融资、流通等各个环节的改造。除了概念上的不同，它们还有哪些区别呢?
一、思维方式的不同
产业互联网和消费互联网有完全不同的实践路径与思维方式，消费互联网讲爆款、流量、体验、唯快不破、链接节点较短、交易高频次低价值；而产业互联网讲的是供应链的协同集成与优化、十分看重价值实现、需要一定的产业隐形知识的积累、讲究地推、较长的价值链条的整合、低频高值、决策难度大。
二、面对的群体不同
消费互联网面对的是消费者个人，人人都是消费者，每个人都可说几句。但产业互联网更专业，必须是“产业+互联网”，而不是“互联网+场景应用”，它是以产业为基础，从产业出发，而不是从互联网出发；产业是基础、产业的互联网是技术手段、价值的实现是根本，如果只是搏眼球、讲尖叫、最终不实现价值交付，一切都是白搭。
三、发展方向不同
消费互联网的特征是赢家通吃一家独大，而产业互联网的特征是细分领域比较垂直。从硬件环境来说，消费互联网的普及是由个人电脑、智能终端、网络连接成本的下降所推动的，产业互联网的突破是由更低成本的传感器、数据存储和更快的数据分析能力所推动的。
四、推动因素不同
从推动因素来说，消费互联网得以迅速发展是因为个人生活体验借助互联网得到了极大大提升，购物、阅读、娱乐、出行等方面因为互联网的出现变得更加方便、快捷。而产业互联网将会因为更高的生产、资源配置、交易效率而得到快速推进。
消费互联网的商业模式则是以“眼球经济”为主，即通过高质量的内容和有效信息的提供来获得流量，从而通过流量变现的形式吸引投资商，最终形成完整的产业链条。在消费互联网时代，互联网以消费者为服务中心，以提供个性娱乐为主要方式，虽能在短时间内迅速吸引眼球，但由于其服务范围的局限性，以及未触动消费者本质生活，也易导致其迅速淹没于互联网发展的大浪中。然而，产业互联网其魅力之一在于其相对于消费互联网来说壁垒较高，不存在赢者通吃的局面，在特定领域里面深度经营可以修建较高的城墙，这就为那些拥有优势产业资源和行业地位、有企业用户资源、具备互联网思维与互联网服务能力的企业带来了机会。
产业互联网的机会的原因远不止于此，在产业互联网时代，实体企业将会主导电商，产业互联网平台是由产业特性决定的，任何企业都要采购原材料，采购服务。因此，如果实体企业有能力做产业互联网平台，就有机会主导电子商务的应用。
蜘点集团始终围绕定位于科技型平台企业的发展为目标，负责各自在全国范围内的各种直营和撮合业务及其合伙人办事处的发展管理，直营业务重点代理经营各种合作企业产品，通过线上平台进行销售，全国金融机构风控服务业务、中小微企业融资担保业务、企事业单位的阳光招投标直营业务，共享仓、物流等方面的直营业务和撮合业务。通过六大行业平台和两大服务平台，让更多的企业全面实现数字化管理，利用新技术、新理念、新模式为其降本增效和赋能。
由此可见，基于大数据、供应链、在线采购的产业互联网新模式将促使实体企业升级，加速融入互联网，从中获得自己所需的利益，以保持行业竞争力。产业互联网的黄金时期正在到来，这将成为下一个风口。今后，不会再有互联网企业，所有企业都将成为互联网企业。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ff09cbacd5aeacc5e2a5a8b7cc1dcd5/" rel="bookmark">
			【Mysql实战45讲】14 count(*)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果有个页面经常要显示交易系统的操作记录总数，如何计数？ 如果用redis来保存这个表的总行数，可能存在一些问题，比如在数据表中插入一行数据后，准备将redis中的计数+1时，redis异常重启了，那刚刚这个+1的操作就丢失了，这个场景下是有解的，就是redis异常重启后，到数据库里单独执行一次 count(*) 来获取真实的行数，并写回到redis即可，由于异常重启不是经常出现的状况，所以这一次全表扫描的成本是可以接受的。但还有个问题是，redis所计数的值是不精确的，比如在执行新增记录逻辑时，先写数据库，再改redis计数，读的时候先读redis，再读数据表中的记录，此时可能出现：插入一行数据后，还没来得及给redis中的计数+1，就读了redis中的计数和数据表中的记录。所以可以将这个计数放到数据库中用单独的一张计数表进行记录。InnoDB支持崩溃后数据的恢复，不会让数据丢失，并且由于InnoDB支持事务，所以可以避免redis中的不精确问题：比如先插入数据，再更新计数，如果在这中间进行了读的操作，由于前面的更新事务还没提交，更新的操作对读操作是不可见的，所以读到的数据还是未插入前的数据。 count(1) 和 count(*) count(1) 会遍历整张表，但不取值，按行进行累加count(*) 也不取值， InnoDB 专门对其进行了优化查找效率方面，两者差不多，尽量使用 count(*) 重点：先插入数据，再更新计数表中的值。因为更新计数表时会涉及行锁的竞争，所以先插入再更新能最大程度的减少事务之间的锁等待，提升系统的并发度 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/308/">«</a>
	<span class="pagination__item pagination__item--current">309/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/310/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>