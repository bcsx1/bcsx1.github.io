<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/173478850b016b256966050cda662e13/" rel="bookmark">
			浏览器兼容video视频播放的多种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 在 HTML 中播放视频并不容易！因为直到现在，仍然不存在一项旨在网页上显示视频的标准。今天，大多数视频是通过插件（比如 Flash）来显示的。然而，并非所有浏览器都拥有同样的插件。 比如windows平台的IE浏览器利用Activex控件来播放flash而其它的浏览器则使用Netscape插件技术来播放flash。而在HTML5 中规定了一种通过 video 元素来包含视频的标准方法，但&lt;video&gt; 元素只支持三种视频格式：MP4、WebM、Ogg。
开发中我们希望视频文件在所有浏览器中（Internet Explorer, Chrome, Firefox, Safari, Opera）和所有硬件上（PC, Mac , iPad, iPhone）都能够播放。有时候甚至需要保证在不同的浏览器上视频播放界面效果保持一致。
在html内联视频中常用的多媒体视频文件格式是flash和mp4文件。flash视频内容可以使用&lt;embed&gt;或&lt;object&gt;标签，mp4视频内容可以使用&lt;embed&gt; 、&lt;object&gt; 、&lt;video&gt;。但目前，&lt;video&gt; 元素只支持三种视频格式：MP4、WebM、Ogg。&lt;object&gt;标签是用于windows平台的IE浏览器的，而&lt;embed&gt; 是用于windows和Macintosh平台下的Netscape Navigator浏览器以及Macintosh平台下的IE浏览器。
下面依次介绍&lt;embed&gt; 、&lt;object&gt; 、&lt;video&gt;各个标签的使用及视频播放的局限性，
1、&lt;embed&gt; 标签 概述：&lt;embed&gt; 标签是HTML5中新增的标签，定义一个容器，可以在页面中嵌入任何类型的文档。用户的机器上必须已经安装了能够正确显示文档内容的程序，一般常用于在网页中插入多媒体格式可以是 Midi、Wav、AIFF、AU、MP3等，IE、Firefox等最新浏览器都能支持。url为音频或视频文件及其路径，可以是相对路径和绝对路径。
使用如下：
&lt;embed src="test.mp4" type="video/mp4" width="400px" height="300px"&gt; 注意事项：
HTML4 无法识别 &lt;embed&gt; 标签。如果浏览器不支持 Flash(如未安装)，那么视频将无法播放。iPad 和 iPhone 苹果设备不支持Flash 视频。（ipad的浏览器属于HTML5技术构架，可以不依赖Flash播放视频。） 补充：安卓系统从Android 2.1版本就开始部分支持flash，可下载安装flash插件播放视频。Adobe Flash Player 10.1.92.8已经支持所有android 2.2智能手机。目前主流的安卓智能机系统都在版本2.3以上，android4.0已大行其道。因此无须对安卓设备采用单独的视频处理方案，安卓系统和windows系统采用同样的方案，使用flash播放器即可实现。
2、 &lt;object&gt; 标签 概述：定义一个嵌入的对象。请使用此元素向您的 XHTML 页面添加多媒体。此元素允许您规定插入 HTML 文档中的对象的数据和参数，以及可用来显示和操作数据的代码。
&lt;object&gt; 标签用于包含对象，比如图像、音频、视频、Java applets、ActiveX、PDF 以及 Flash。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/173478850b016b256966050cda662e13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adabc88f46cfa07b7bece0da2c486002/" rel="bookmark">
			Jrebel 热部署 离线激活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 . 打开jrebel 激活面板 . 选择Connect to online licensing service 输入url：http://www.zpjeck.top:8081/518dc87d-b942-4369-a635-323cfc81d0e1
http://39.108.164.99:8081/518dc87d-b942-4369-a635-323cfc81d0e1 ----&gt;&gt;&gt;&gt;修改为
https://www.zpjeck.top/jrebel/518dc87d-b942-4369-a635-323cfc81d0e1
邮箱：随便填写。
2.本服务器是自己搭建的，不作为商用，后期会持续更新。如果有问题，欢迎下方评论。
3.----------------------------------------------------2020年4月15日更新
抱歉，由于服务器即将到期，现更改为 域名访问方式，url：
https://www.zpjeck.top/jrebel/518dc87d-b942-4369-a635-323cfc81d0e1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0f9e020559576215a4d23adabaaf81d/" rel="bookmark">
			设计模式：抽象工厂模式，结合类图秒懂！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过前篇文章《设计模式：工厂模式，解除耦合的利器》的介绍，我们对工厂模式有了深入的了解，今天继续介绍一种特殊的工厂模式，也就是抽象工厂模式。
定义 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式，是工厂方法模式的升级版，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。
抽象工厂模式包含了几个角色：
AbstractFactory：用于声明生成抽象产品的方法
ConcreteFactory：实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；
AbstractProduct：为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；
Product：定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。
这是它的通用类图：
其中 AbstractProductA 和 AbstractProductB 就是两个产品族的抽象类 (或者接口)，而 Product1 和 Product2 就是产品族下的具体产品类，AbstractCreator 就是工厂的抽象。
我们可以用操作系统来举例，现在市面上用的最多的两种PC端操作系统是windows和Linux，两个系统都有共同类型的组件，如文件夹，按钮，文本等。套用下抽象工厂的通用类图，我们不难发现，两个系统就相当于产品组抽象类AbstractProductA 和 AbstractProductB，而按钮、文本这些组件就是具体的产品类。
然后再来分析一下，如果有一个应用要在两个系统上运行，应该怎么设计？是编写两套程序运行于不同的系统上？这样实在是太浪费资源了，我们可以通过抽象工厂模式屏蔽掉操作系统对应用的影响。软件功能、逻辑、UI 都一个非常类似，唯一的不同是调用不同的工厂方法，由不同的产品类去处理与操作系统交互的信息，而这就是抽象工厂的优势。
代码编写 抽象工厂的通用类图我们已经了解了，下面就是具体代码的实现：
产品族的抽象类，AbstractProductA 和 AbstractProductB，
public abstract class AbstractProductA { //每个产品共有的方法 public void shareMethod() { } // 每个产品相同方法，不同实现 public abstract void doSomething(); } public abstract class AbstractProductB { //每个产品共有的方法 public void shareMethod() { } // 每个产品相同方法，不同实现 public abstract void doSomething(); } 两个产品族的具体实现类代码，
public class ProductA1 extends AbstractProductA { public void doSomething() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0f9e020559576215a4d23adabaaf81d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cef3894c750a08bad863f95de63b1c74/" rel="bookmark">
			IDEA新建xml文件显示为普通的text文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 版权声明： https://blog.csdn.net/qq_40585396/article/details/85250182 &lt;/div&gt; &lt;link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-cd6c485e8b.css"&gt; &lt;link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-cd6c485e8b.css"&gt; &lt;div class="htmledit_views" id="content_views"&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;Intellij IDEA新建xml文件时，文件内容不能高亮显示，文件logo是text文本图案&lt;/strong&gt;&lt;/li&gt; &lt;li&gt;&lt;strong&gt;但是可以创建以其他名字命名的xml文件&lt;/strong&gt;&lt;/li&gt; &lt;li&gt;&lt;strong&gt;以下有2种原因&lt;/strong&gt;&lt;/li&gt; 在下方列表中选中点击减号，删除text文本中的*.xml，如果没有无需删除 ​​​​​​​
在XML中添加*.xml，如果有无需添加 asd
如果还是无法解决，那么就看下面这张图，看看是否里面多了一个自己刚刚创建的Mapper删除之后就可以重新创建 以之前的名字命名的xml文件了。 如果解决了以上问题，点个赞，谢谢！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/284c3d552d1c292fc26f82ceaf73de1d/" rel="bookmark">
			ENVI实验教程（3）遥感图像预处理—几何校正
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验三、遥感图像预处理—几何校正 一、实验目的
熟悉几何校正的主要过程和关键步骤熟练ENVI常用几何校正工具掌握ENVI地面控制点GCPs的选取和不同模式的几何校正流程。
二、实验基本要求认真阅读和掌握本实验的程序。上机操作几何校正模块的运行和应用。保存与记录实验结果，并进行分析总结。
三、实验时间和地点地点：时间：
四、实验条件硬件：PC电脑（Windows10操作系统）软件：ENVI 5.3参考资料：《ENVI遥感图像处理方法》第4章使用数据：…\第4章 遥感图像预处理\ 3-几何校正
五、实验内容Image to image 几何校正
六、注意事项
1、控制点选择时注意GCPs数目确定。
2、几何校正的精度控制。
七、实验步骤
1.开始&gt;程序&gt;ENVI5.1&gt;Tools&gt;ENVI Classic，主菜单&gt;File&gt;Open Image File，将SPOT（bldr_sp.img）和TM图像（bldr_tm.img）文件打开，并分别在Display中显示两个影像
2主菜单&gt;Map&gt;Registration&gt;Select GCPs:Image to Image，打开几何校正模块。
3选择显示SPOT文件的Display为基准影像（Base Image），显示TM文件的Display为待校正影像（Warp Image），点击OK进入采集地面控制点。
当选择一定数量的控制点之后（至少3个），可以利用自动找点功能。
点击Ground Control Points Selection上的Show List按钮，可以看到选择的所有控制列表
选择校正参数输出
检验校正结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18881cbff2d09e533b540f9f78e48dac/" rel="bookmark">
			C语言 指针简介（&amp;和*运算符）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		取地址符（&amp;） 和 取值符（*） （1）&amp; 运算符 ：用于取一个对象的地址 例如：int *p; p = &amp;c; 将c的地址赋值给指针变量p，我们称p为 “指向” c的指针。
取地址运算符只能用于内存中的对象，即变量与树组元素，它不能作用于表达式、常量或register类型的变量。
（2）* 运算符：作用于指针时表示访问指针所指向的对象
例如：int x; x = *p; 将p指向的地址所对应的对象赋值给x，所以 x 就等于c的值 （3）&amp; 与 * 使用示例： int x = 1, y = 2, z[10];
int *ip; //ip is a pointer to int
指针简介 指针：一种保存变量地址的变量。
声明形式： 数据类型 *指针名;
例如：int *p; //声明了一个int型的指针变量p
注意：指针只能指向某种特定类型的对象，也就是说，每个指针都必须指向某种特定的数据类型。（一个例外情况跟是指向void类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身）
由于指针也是变量，所以在程序中可以直接使用，而不必通过间接引用的方法使用。
例如 如果iq是另一个指向整型的指针，那么语句 iq = ip 将把ip中的值拷贝到iq中，这样，指针iq也将指向ip指向的对象
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e6dd987cd7544ddef924572239fcc31/" rel="bookmark">
			Ant Design 控制Tabs标签页 哪页高亮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目上遇到一个关于Ant Design Tabs标签页问题。
项目背景：用户个人中心包括基本信息、我的钱包、我的订单、消息与通知四个模块(如下左图)；需求为该用户提交完订单，跳转到我的订单模块(如下右图)，但是项目中个人中心是一个组件，基本信息、我的钱包、我的订单、消息与通知是四个小组件，所以只能调到个人中心组件，且默认跳到基本信息。这是不符合需求的。
为了解决该问题，我先在提交页面跳转时加如下代码，携带id（我的订单）；
that.props.history.push({ pathname: '/app/header/Personal', state: { id: 3 } }); 在个人中心页面判断，
第一种尝试：然后给defaultActiveKey属性赋值，但是等跳转过去又是在第一项，不知为何，赋值就是不管用。
第二种尝试：然后给activeKey属性赋值，跳转过去确实是第三项，但是切换别的项失败。
第三种尝试：继续第二种尝试，查看文档，发现有onChange事件，每次更改，给activeKey赋值，问题解决。还有一个onTabClick事件，也可以运用。
代码如下：
class Personal extends React.Component { constructor(props) { super(props) this.state = { tabPosition: 'left', activeKey: '', } }; componentDidMount() { if (this.props.history.location.state === undefined) { this.setState({ activeKey: '1' }); }else{ let state = this.props.history.location.state; this.setState({ activeKey: state.id+'' }); } } callback = (key) =&gt; { this.setState({ activeKey: key }); } render() { const {activeKey} = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e6dd987cd7544ddef924572239fcc31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555bea98058b83d7fd05077ae2412085/" rel="bookmark">
			postman并发调用接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.新增测试项目
2.配置好接口内容
配置完后要点击保存按钮
3.并发
并发结果返回
POSTman并发请求完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b3d3d86f2cdcd17c373ab99b96d9f01/" rel="bookmark">
			Java web 中的Session
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在web容器中设置
例如：tomcat里面的web.xml
&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; 默认30分钟，自己修改数字即可
2、在工程的web.xml中设置
例如：java web 项目中，在WebContent-&gt;WEB-INF-&gt;web.xml下
&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; 3、在Servlet中设置（Java代码）
HttpSession session = request.getSession(); session.setMaxInactiveInterval（30*60）;//以秒为单位 以上三种优先顺序：1 &lt; 2 &lt;3
Session的过期时间如何计算？
在生成session的时候，会设置一个session过期时间。session的过期时间并不是从生成session对象开始计算，超过过期时间，session就失效了。
而是每当一个浏览器请求，session生存时间就会刷新，最后一次浏览器请求，超过过期时间，没有浏览器请求到达，session就会过期。
备注：
request.getSession()和request.getSession(true)意思相同：获取session,如果session不存在，就新建一个
reqeust.getSession(false)获取session,如果session不存在，则返回null
如果 项目中无法确定会话一定存在，最好用request.session(false);
例如：当向Session中存取登录信息时，一般建议：HttpSession session =request.getSession();
当从Session中获取登录信息时，一般建议：HttpSession session =request.getSession(false);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e95cfefb7bdda6d044659af33758f86a/" rel="bookmark">
			Kimball维度建模（维度表技术）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 维度表： 1.每个维度表都包含单一的主键列，作为与事实表的外键 2.维度表有自己的维度代理键，即用来标识唯一性，无意义。+1 3.下钻 商业分析的基本方法： 上卷（roll-up）：上卷是沿着维的层次向上聚集汇总数据。 例如，对产品销售数据，沿着时间维上卷，可以求出所有产品在所有地区每月 （或季度或年或全部）的销售额。 下探（drill-down）：下探是上卷的逆操作，它是沿着维的层次向下，查看更详细的数据。 4.多层次维度： 多层次指例如日期，有年月日的层次，也可以有天到周的层次。同一维度可能有不同层次 5.空值属性 推荐采用标识性标识空值，例如unknown。因为不同数据库对空值处理不同。 6.日历日期维度： 用YYYYMMdd更容易划分。 7.一致性维度集成： 集成了来自不同商业的数据。 即不同的维度表具有相同列名和内容时，称维度表具有一致性，关联起来可将不同维度表 集成到一个报表中。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a72858e90169be3a9835a614ffeb680/" rel="bookmark">
			Linux的基本指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、ls指令
含义：ls （list）
注意：ls列出的结果颜色说明，其中蓝色的名称表示文件夹，黑色的表示文件，绿色的其权限为拥有所有权限。
用法1：#ls
含义：列出当前工作目录下的所有文件/文件夹的名称
用法2：#ls 路径
含义：列出指定路径下的所有文件/文件夹的名称
用法3：#ls 选项 路径
含义：在列出指定路径下的文件/文件夹的名称，并以指定的格式进行显示。
常见的语法：
#ls -l 路径
#ls -la 路径
选项解释：
-l：表示list，表示以详细列表的形式进行展示
-a：表示显示所有的文件/文件夹（包含了隐藏文件/文件夹）
用法4：#ls -lh 路径
含义：列出指定路径下的所有文件/文件夹的名称，以列表的形式并且在显示文档大小的时候以可读性较高的形式显示
2、pwd指令
用法：#pwd （print working directory，打印当前工作目录）
3、cd指令
命令：#cd （change directory，改变目录）
作用：用于切换当前的工作目录的
语法：#cd 路径
在Linux中有一个特殊的符号“~”，表示当前用户的家目录。
4、mkdir指令
指令：mkdir （make directory，创建目录）
语法1：#mkdir 路径 【路径，可以是文件夹名称也可以是包含名称的一个完整路径】
语法2：#mkdir -p 路径
含义：当一次性创建多层不存在的目录的时候，添加-p参数，否则会报错
语法3：#mkdir 路径1 路径2 路径3 …. 【表示一次性创建多个目录】
5、touch指令
指令：touch 作用：创建文件
语法：#touch 文件路径 【路径可以是直接的文件名也可以是路径】
6、cp指令
指令：cp （copy，复制）
作用：复制文件/文件夹到指定的位置
语法：#cp 被复制的文档路径 文档被复制到的路径
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a72858e90169be3a9835a614ffeb680/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2a5cde21dd085c3a3599e5abe687818/" rel="bookmark">
			初入it公司程序员应该做什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多同学不清楚入职一家it公司应该做什么，程序员的工作流程是什么，下面给大家介绍一下大概的流程。
正所谓面试造飞机，工作拧螺丝，面试过程中，会问面试者很多技术点，包括javase基础，框架，消息队列，分布式等等问题，当然如果面试成功之后，接下来就是我们在工作中具体做哪些事情。下面仅以2-3年工作经验来浅谈一下。
1、入职第一天，搭建开发环境
首先，大部分公司都会有自己的jar包管理工具，普遍的是maven和gradle，首先我们需要配置公司私服地址和自己本地地址，在maven安装包中的setting.xml配置文件中，如下图
或者直接拷贝同事的setting.xml配置文件。
gradle，可以配置远程仓库和本地仓库，我的是macos，所以都没有进行配置，大家可以自行搜索配置，也可以在项目中进行配置。
2、使用git，拉取项目，熟悉项目
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6aed113c72730ce92405bd29413cb23/" rel="bookmark">
			应用程序状态监测系统实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在嵌入式系统运行过程中，应用程序运行状态(如变量值、方法调用、程序控制流等)，是我们开发人员经常需要关注的，在调试过程中我们经常通过添加打印并运行程序去了解程序的运行状态，这样效率很低且在有些很难复现的问题调试中更难实施，因此，一种动态查看应用程序运行状态的系统，大多数情况能很快定位到问题出错位置，提高调试效率。
本文通过实现动态查看模块调试信息和动态设置打印等级的控制命令，用户进入shell输入相应命令，可在程序中打印出各个模块运行信息，在设备出现相关问题时，通过查看各模块状态信息或使用自定义的其他功能，能快速定位到目前问题出错位置，从而提高问题解决效率。
系统实现说明 本系统包含两个模块，包括DSP模块动态监视和DSP打印等级控制两部分。DSP模块动态监视功能：用于在设备程序运行时，用户可在shell输入指定命令，DSP系统根据命令执行相应功能，由子模块内部自定义功能，本框架只负责获取并识别用户输入命令并判断子模块是否支持，支持则将命令下发到子模块，由各子模块进行处理；DSP打印等级控制：可动态设置打印等级，防止DSP打印过多影响其他同事调试。
C/S架构实现 1 socket基本原理 简单介绍下socket原理，这个网上一大把，随便搜一个讲的都比我好。
shell命令识别模块通过socket TCP网络编程实现。简单介绍下socket通信原理：
1、在服务端建立一个ServerSocket,绑定相应的端口，并且在指定的端口进行侦听，等待客户端的连接；
2、客户端创建连接Socket并且向服务端发送请求；
3、服务器收到请求，并且接受客户端的请求信息。一旦接收到客户端的连接请求后，会创建一个链接socket，用来与客户端的socket进行通信。通过相应的输入/输出流（write/read）进行数据的交换，数据的发送接收（recv/send）以及数据的响应等等；
4、当客户端和服务端通信完毕后，需要分别关闭socket，结束通信。
具体接口流程如下图所示。
2 Cleint/Server功能实现 由于本模块客户端和服务端都只会在单个主机上运行，因此为提高效率，本模块使用本地套接字AF_UNIX，程序会在设备固定路径下创建socket套接字文件，用于进程间通信。
客户端代码单独实现，主要实现功能如下：
1、 获取用户输入命令；
2、 识别判断用户输入命令服务端程序是否支持；
3、 支持则将用户输入命令发送到服务端，否则与服务端断开连接；
4、 如服务端处理出错会发送来出错信息，接收并打印出错信息。
服务端代码集成在嵌入式应用程序代码中，在应用程序初始化时会创建服务端线程，等待客户端连接，主要实现功能：
1、 向客户端提供程序模块所支持的功能列表；
2、 接收客户端发来的待处理命令；
3、 解析待处理命令，检测命令所属子模块，将命令发送到相应子模块，后续由子模块进行处理；
4、 如处理出错则向客户端发送出错信息。
客户端/服务器功能实现及交互流程如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8fd8c04e4fbf5db16243e81eed21fc2/" rel="bookmark">
			Ant Design时间选择框汉化问题总结------国际化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ant Design用起来确实很好用，若是做管理后台真的是很适合。
最近遇到了时间框汉化的问题，代码如下图：
&lt;RangePicker disabledDate = {this.disabledDate} disabledTime = {this.disabledRangeTime} onChange = {this.onChange} showTime = {{hideDisabledOptions: true}} format = "YYYY-MM-DD HH:00:00" /&gt; 结果如下图： 随之就要把时间选择器汉化，先是从antd官网找到一种方式，如下：
import moment from 'moment'; import 'moment/locale/zh-cn'; moment.locale('zh-cn'); &lt;RangePicker disabledDate = {this.disabledDate} disabledTime = {this.disabledRangeTime} onChange = {this.onChange} showTime = {{hideDisabledOptions: true}} format = "YYYY-MM-DD HH:00:00" /&gt; 结果如下图：(日历部分变为中文，但是placeholder、select time和ok还是英文)
随后寻找很多办法，看官方文档https://ant.design/components/locale-provider-cn/找出了方法....‘国际化’
import zh_CN from 'antd/lib/locale-provider/zh_CN'; import moment from 'moment'; import 'moment/locale/zh-cn'; import { LocaleProvider } from 'antd'; &lt;LocaleProvider locale={zh_CN}&gt; &lt;RangePicker disabledDate = {this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8fd8c04e4fbf5db16243e81eed21fc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/550dac942da8d44e44cbc6c644e34d8f/" rel="bookmark">
			电脑如何通过数据线连接手机网络？（USB共享网络）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：用数据线连接手机和电脑的USB插孔，这时候电脑网络连接的状态是这样。。。
第二步：打开手机设置，找到移动网络共享。。。打开USB连接
第三步：电脑上网络图标。。鼠标右击。。。打开网络和共享中心。。。
鼠标左键点击更改适配器设置。。。。
第四步：来到网络连接界面。。。第二个以太网图标上。。。鼠标右键点击禁用，就变成了启用。。。启用之后就完成了USB网络连接。。。。。。
最后电脑上网络连接图标没有红色错号。。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21e6aadbd3f783e20d86d362db2e0255/" rel="bookmark">
			Ubuntu系统中防火墙的使用和开放端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu系统中防火墙的使用和开放端口
目录
1、Ubuntu查看防火墙的状态... 2
2、Ubuntu开启防火墙... 2
3、Ubuntu添加开放SSH端口... 3
4、Ubuntu防火墙常用命令... 5
4.1、查看ufw防火墙的状态... 5
4.2、启用ufw防火墙... 6
4.3、重启ufw防火墙... 6
4.4、关闭ufw防火墙... 6
4.5、设置外来访问默认权限... 6
4.6、端口的开放与关闭... 7
4.6.1、开放普通端口... 7
4.6.2、关闭普通端口... 8
4.6.3、开放规定协议的端口... 8
4.6.4、关闭指定协议端口... 9
4.6.5、开放限定ip地址端口... 10
注意：不管是在Linux服务器还是在Ubuntu服务器中，当防火墙开启以后，会开放一些常用的端口，这时常常直接到自己Windows上telnet已经开放的端口，通常会忽略开放的这些端口在服务器中是否有程序进行监听，如果没有程序进行监听，telnet开放的这些端口时往往是不通的。
1、Ubuntu查看防火墙的状态 在Ubuntu系统进行安装的时候默认安装了ufw防火墙
查看防火墙的状态
命令：
sudo ufw status
系统提示： “Status: inactive”状态：不活跃
上面提示表示没有开启防火墙，并不是没有安装防火墙
如果没有安装可以使用命令安装
命令：
sudo sudo apt-get install ufw
2、Ubuntu开启防火墙
开启防火墙，
命令：
sudo ufw enable //开启防火墙
注意：Command may disrupt existing ssh connections. Proceed with operation (y|n)?
表示：命令可能会中断现有的ssh连接。继续操作(y|n)?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21e6aadbd3f783e20d86d362db2e0255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48990906f72df82800b9331e1b8af575/" rel="bookmark">
			【约束布局】ConstraintLayout 之 Chains 链式约束 ( Chains 简介 | 代码 及 布局分析 | 链头设置 | 间距设置 | 风格设置 | 权重设置 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 链 简介( 1 ) Chains ( 链 ) 简介 2. 创建 链 及 分析 生成的代码( 1 ) 创建水平链( 2 ) 链创建后的代码及样式( 3 ) 链创建后 生成的 代码( 4 ) 生成的 链 代码分析 3. 链头 及 链的间距( 1 ) 链头设置( 2 ) 链 间距 4. 链 的 三种风格( 1 ) 链 风格设置( 2 ) 链 的 三种风格( 3 ) CHAIN_SPREAD 样式 代码示例 及 效果( 4 ) CHAIN_SPREAD_INSIDE 样式 代码示例 及 效果( 5 ) CHAIN_PACKED 样式 代码示例 及 效果 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48990906f72df82800b9331e1b8af575/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a71d83a07c88ca130952955e403173ca/" rel="bookmark">
			浅析Kotlin协程 ——协程是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kotlin协程的使用https://blog.csdn.net/qq_17798399/article/details/95245996
协程是什么？ 首先kotlin协程是kotlin的扩展库(kotlinx.coroutines)。
线程在Android开发中一般用来做一些复杂耗时的操作，避免耗时操作阻塞主线程而出现ANR的情况，例如IO操作就需要在新的线程中去完成。但是呢，如果一个页面中使用的线程太多，线程间的切换是很消耗内存资源的，我们都知道线程是由系统去控制调度的，所以线程使用起来比较难于控制。这个时候kotlin的协程就体现出它的优势了，kotlin协程是运行在线程之上的，它的切换由程序自己来控制，无论是 CPU 的消耗还是内存的消耗都大大降低。
协程和线程区别与关系: 线程和协程的目的本质上存在差异:
线程的目的是提高CPU资源使用率, 使多个任务得以并行的运行, 所以线程是为了服务于机器的.协程的目的是为了让多个任务之间更好的协作, 主要体现在代码逻辑上, 所以协程是为了服务于人的, 写代码的人. (也有可能结果会能提升资源的利用率, 但并不是原始目的) 在调度上, 协程跟线程也不同:
线程的调度是系统完成的, 一般是抢占式的, 根据优先级来分配, 是空分复用.协程的调度是开发者根据程序逻辑指定好的, 在不同的时期把资源合理的分配给不同的任务, 是时分复用的. 作用上的不同:
协程确保了代码逻辑是顺序的, 不管同步操作要是异步操作, 前一个完成, 后一个才会开始.线程可以被调度到CPU上执行, 这样代码才能真正运行起来. 协程与线程的关系:
协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程. 可总结如下:
线程是协程的资源.协程通过Interceptor来间接使用线程这个资源. Kotlin中文站
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e44588b188035c443dbe02747fb83dcd/" rel="bookmark">
			Nginx指令add_header和proxy_set_header的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如何理解反向代理？
Nginx是反向代理服务器，我们可以从下面的图来理解为什么是反向代理。以Nginx为中心，数据的流向是从Server到Nginx再到Client，注意我说的是数据（响应数据），而不是请求。我们都知道水流一定是从上游流到下游，所以给Server一个别称上游服务器，当然这个别称并不是我定义的。
proxy_set_header和add_header的区别
区别：proxy_set_header是Nginx设置请求头信息给上游服务器，add_header是Nginx设置响应头信息给浏览器。
proxy_set_header
假如Nginx请求上游服务器时，添加额外的请求头，就需要使用proxy_set_header。在Java中使用HttpServletRequest#getHeader(String name)来获取请求头的值，name是请求头的名称。
例如：proxy_set_header X-Request-URI $scheme://$host/$uri;
String requestUrl = request.getHeader("X-Request-URI"); if (requestUrl == null) { // 从Servlet服务器获取客户端请求地址 requestUrl = request.getRequestURL().toString(); } add_header
Nginx响应数据时，要告诉浏览器一些头信息，就要使用add_header。例如跨域访问（详细参见Nginx跨域访问配置）
add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Headers' 'X-Requested-With'; add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS' # 由于跨域请求，浏览器会先发送一个OPTIONS的预检请求，我们可以缓存第一次的预检请求的失效时间 if ($request_method = 'OPTIONS') { add_header 'Access-Control-Max-Age' 2592000; add_header 'Content-Type' 'text/plain; charset=utf-8'; add_header 'Content-Length' 0; return 204; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55210139acf7ed33ef9866dd4f57450b/" rel="bookmark">
			个人编码规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：在此我记录了一些在工作中总结的个人编码规范，算是对阿里出版的编码规范的个人补充。
【强制】在controller层API中，禁止使用Map类型作为入参类型，建议使用实体类型或简单类型； 使用Map类型容易造成以下问题：
前端人员无法准确获知应该传递哪些有效参数;service层很难获知传递了哪些参数；参数名没有强限制，容易造成参数命名混乱和错误；若涉及到多种不同类型参数，则泛型必须为Object，导致无法对参数类型进行强制要求，如果不对每个参数都进行繁复的类型检查，容易出现意想不到的异常；无法使用注解校验。 【建议】在将实体类JSON化时，值为null的字段不要映射成""(即空字符串)。 虽然前端人员可能会建议将null映射成为""，但此行为在后端可能会出现问题。实体类中除String类型之外的字段，无法将""映射成null，会导致JSON字符串解析失败。在进行redis缓存的解析反解析过程可通过设置解决这一问题，但从前端传递的JSON字符串则无法解决。
【强制】与时间戳相关的数据必须使用Long或long类型，无论单位是秒或毫秒。 由于Integer类型长度限制，所有的毫秒时间戳都将溢出，而秒时间戳在2038年也将溢出，为了减少溢出的可能，必须全部使用长整型。
【建议】时间戳单位统一使用毫秒。 无论前后端人员，在时间戳的单位选择上，全部使用毫秒作为单位。
【建议】时间相关参数类型建议使用Date，而非LocalDateTime。 虽然在java8中推出了LocalDateTime类型，但很多库与框架并未很好地支持LocalDateTime类型，故不建议使用改类型。
【建议】数据库表中伪删除字段不要以is开头，且类型设为TINYINT，长度为1。 使用is作为开头不符合java bean规范，容易引起误解，个人建议使用deleted；使用TINYINT，且长度设为1，在逆向工程中会被解析为布尔类型，比起无意义的01更好理解。 【建议】每一个项目都应该有一份详细的协同文档。（暂定） 建议文档使用MARKDOWN语法，并使用git进行版本管理。
文档至少应具有以下内容：
立项说明书：说明立项原因、用途等，由管理人员给出；数据库设计方案：所有的表结构都和说明都要详细列出，对于枚举值需要做详细说明。所有关于表结构的添加、删除、修改操作都必须记录，并给出修改原因、操作人员、核准人员等信息；接口列表：详细罗列项目中需要使用到的接口，包括接口设计目的、业务流程、涉及的表和字段等，接口文档不必在此列出。新增、删除、修改接口的操作都必须对此文档做出修改，并给出修改原因、操作人员、核准人员等信息。 【强制】没用的代码、表、字段必须删除。 旧代码会让系统看起来臃肿不堪，造成极差的阅读体验。
不要觉得将来可能会重新启用，因为基本上不会再用，即使再用，大概率不会是相同的逻辑，即使逻辑相同，你敢直接启用么？与其在旧代码上战战兢兢地修改，不如重写。
如果只是暂时性的修改，必须加上TASK标记，以便快速更正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cceff3d5f822f32bbe427054e7e4c6a/" rel="bookmark">
			UVALive 3938 &#34;Ray, Pass me the dishes!&#34; 动态最大连续和（线段树）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意：给出一个长度为n的序列, 再给出m个询问, 每个询问是在序列 [a,b][a,b] 之间的最大连续和. 要你计算出这个这个区间内最大连续和的区间 [x,y](a≤x≤y≤b)[x,y](a≤x≤y≤b)。 分析：详见《训练指南》P201-202。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=500000+10; typedef long long ll; typedef pair&lt;int,int&gt; par; ll a[maxn]; int n,q,temp,l,r; ll sum[maxn];//前缀和,要求一段区间的值就是sum[r]-sum[l-1] struct node { int l,r,prer,sufl;//左右节点，最大前缀和终点，最大后缀和起点 par sub;//结果 }nodes[maxn&lt;&lt;2]; ll cal(par x) { return sum[x.second]-sum[x.first-1];//求区间和 } //比较两个区间和大小 par cmp(par x,par y) { ll a=cal(x); ll b=cal(y); if(a!=b) return a&gt;b?x:y; return x&lt;y?x:y; } //合并 node com(node x,node y) { node res; res.l=x.l; res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cceff3d5f822f32bbe427054e7e4c6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60407844ae97fd1c9753a68460499839/" rel="bookmark">
			【Android】EventBus事件接收不到的几种情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于EventBus事件接收不到，遇到过以下几种情况。
1、没有调用EventBus的注册方法(register)
2、接收方法中的参数与发送的不一致，导致EventBus判断没有对应的注册者
3、发送的是粘性事件，并且是同一类型的粘性事件(这个是我最近遇到的)
对于第三点的原因，经过阅读源码发现：
粘性事件会加入一个叫stickyEvents的Map集合中，该集合使用event.getClass作为key，event作为value，因此当出现同一类的粘性事件时，会将之前的粘性事件给替换掉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b128f579ae5292c2a53f22c6544a097/" rel="bookmark">
			2.EP4CE10F17的ADC设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前记：师夷长技以自强
P285
1.基本概念 ADC:Analog to Digital Conver，是将模拟信号转变为数字信号的电子元件。分为间接ADC和直接ADC两种，实验中使用的ADC128S022是逐次逼近型属于直接ADC。
ADC128S022:主要特性是8通道12位转换速度为50Ksps~200Ksps，输出的数据兼容SPI,QSPI,等接口的二进制数据。
2.ADC128S022电气特性 2.1封装和结构 实验中的ADC芯片共16管脚，采用双排直插式封装，
了解它内部的结构有助于更好地掌握芯片的使用方式，基本上分为三大块：多路选择子模块、逐次逼近转换子模块和逻辑控制模块
可以看出，与FPGA有关的只有SCLK、\CS、DIN、DOUT。
2.2时序 首先一次采样有16个SCLK时钟，前3个时钟ADC处于采用模式，后13个为保持模式。其中DIN的输入发生在SCLK的上升沿，DOUT的输出发生在SCLK的下降沿，上图中的DOUT应该往右移半拍。
DIN的8个控制寄存器只用了其中的3位：
Bit7Bit6Bit5Bit4Bit3Bit2Bit1Bit0DONTCDONTCADD2ADD1ADD0DONTCDONTCDONTC 其中的ADD2,ADD1,ADD0组成的3位二进制数代表了IN的通道号。
由于SCLK的工作频率是0.8~3.2MHz，系统频率为50MHz，这里定义ADC的工作频率为1.92MHz，为了完成线性序列机的设计，需要一个两倍的时钟SCLK2X=3.84MHz，大概经过系统时钟13分频得到。下面先列出信号随时间的操作表：
计数值对应信号操作0\CS = 0;1SCLK = 0;2SCLK = 1;3 SCLK = 0;
4SCLK = 1;5SCLK = 0;DIN = ADD2;6SCLK = 1;7SCLK =0,DIN = ADD1;8 SCLK = 1;
9SCLK = 0;DIN = ADD0;10SCLK = 1;r_data[11] = DOUT;11SCLK = 0;12SCLK = 1;r_data[10] = DOUT;13SCLK = 0;14SCLK = 1;r_data[9] = DOUT;15SCLK = 0;16SCLK = 1;r_data[8] = DOUT;17SCLK = 0;18SCLK = 1;r_data[7] = DOUT;19SCLK = 0;20SCLK = 1;r_data[6] = DOUT;21SCLK = 0;22SCLK = 1;r_data[5] = DOUT;23SCLK = 0;24SCLK = 1;r_data[4] = DOUT;25SCLK = 0;26SCLK = 1;r_data[3] = DOUT;27SCLK = 0;28SCLK = 1;r_data[2] = DOUT;29SCLK = 0;30SCLK = 1;r_data[1] = DOUT;31SCLK = 0;32SCLK = 1;r_data[0] = DOUT;33CS_N = 1; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b128f579ae5292c2a53f22c6544a097/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17b8c1706d3281dacf97e88a6f26889c/" rel="bookmark">
			海思Hi3516EV300调试笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		调试Hi3516EV300过程中遇到的一些需要注意的点：
PIPE 可以设置成多种工作模式，情况如下。
第 0 个 PIPE 可以有 4 种模式：
− VI 在线 VPSS 离线
− VI 在线 VPSS 在线
− VI 离线 VPSS 离线
− VI 离线 VPSS 在线
其他 PIPE 可以有 2 种模式：
− 当第 0 个 PIPE 为 VI 离线 VPSS 在线时，绑定的其他 PIPE 只能设置 VI 离线
VPSS 在线。
− 当第 0 个 PIPE 设置成其它模式时，绑定的其他 PIPE 只能为 VI 离线 VPSS 离
线。
HI_MPI_SYS_SetVIVPSSMode
必须在 HI_MPI_SYS_Init 后，所有的 VI PIPE 和所有的 VPSS 组创建前设置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17b8c1706d3281dacf97e88a6f26889c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d971ba706caa216cca433112afc90e8c/" rel="bookmark">
			对光照、阴影和反光具有鲁棒性的变化检测算法及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对光照、阴影和反光具有鲁棒性的变化检测算法及实现 http://www.cqvip.com/Main/Detail.aspx?id=8293930
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca56c29ebc2f7ec8f92ff588df767129/" rel="bookmark">
			Dart语言入门(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近好长时间没有写博客，也不知道要写点什么，一直也静不下心来学习，想看会学习视频，手机又放不下，看一会就去玩手机了。最近好不容易下定决心学习一波，虽然有时候还是会玩手机，但是比以前好太多了。
以后我的博客会侧重于Flutter的讲解，有时间也会穿插着Android的一些知识。现在就让我们开始Flutter的踩坑之路吧。
前言 Dart诞生于2011年10月10日，是一种“结构化的Web编程”语言，Dart编程语言在所有现在浏览器和环境中提供高性能。Dart用于Web、服务器、移动应用和物联网等领域的开发。
Dart语言的特性 ①.Dart是AOT(Ahead Of Time)编译的，编译成快速、可预测的本地代码，使Flutter几乎都可以使用Dart编写。
②.Dart也可以JIT(Just In Time)编译，开发周期异常快，工作流颠覆常规。
③.Dart可以更轻松地创建以60fps运行的流畅动画和转场。
④.Dart使Flutter不需要单独的声明式布局语言(如JSX或XML)，或单独的可视化界面构建器，因为Dart的声明式编程布局易于阅读和可视化
Dart重要概念 ①.所有的东西都是对象，无论是变量、数字、函数等都是对象。所有的对象都是类的实例。
②.程序中指定数据类型使得程序合理地分配内存空间，并帮助编译器进行语法检查。但是，指定类型不是必须的。Dart语言是弱数据类型。
③.Dart代码在运行前解析。指定数据类型和编译时的常量，可以提高运行速度。
④.Dart程序有统一的程序入口:main();
⑤.Dart没有public、protected和private的概念。私有特性通过变量或函数加上下划线来表示。
⑥.Dart的工具可以检查出警告信息(warning)和错误信息(error)。
⑦.Dart支持anync/await异步处理。
Dart语言常用库 包名 描述
dart:async 异步编程支持，提供Future和Stream类
dart:collection 对dart:core提供更多的集合支持
dart:convert 不同类型(JSON,UTF-8)间的字符编码、解码支持
dart:core Dart语言内建的类型、对象以及dart语言核心的功能
dart:html 网页开发用到的库
dart:io 文件读写I/O相关操作的库
dart:math 数字常量及函数，提供随机数算法
dart:svg 事件和动画的矢量图像支持
以下三个库的使用频率最高
①.dart:core:核心库，包括strings、numbers、collections、errors、dates、URIs等
②.dart：html:网页开发里DOM相关的一些库
③.dart:io:I/O命令行使用的I/O库
④.dart:core库是Dart语言初始已经包含的库，其他的任何库在使用前都需要加上import语句。
使用官方提供的pub工具可以安装丰富的第三方库。第三方库的地址为：pub.dartlang.org
环境准备 安装Dart SDK 官方共有三种SDK版本选择，分别是Flutter、Web、Server这三种，我们这里只是Dart编程语言的学习，只需要下载Server版的SDK就行。
网址是：https://dart.dev/tools/sdk/archive
分为Windows，Macos和Linux，根据自己的电脑系统下载所需的sdk
配置环境变量 我是在Windows上安装的，通过点击下一步即可安装，安装完成后，需将dart-sdk下的的bin目录添加到系统Path环境变量中。
测试是不是安装成功了，打开cmd，输入dart，出现红框里面的就是成功了
配置idea编辑器 我没有用官方推荐的VSCode编辑器，而是选择了idea编辑器，大家可以根据自己的需求选择编辑器。
在idea中使用Dart语言，要先安装Dart插件
依照如下步骤安装 Dart 的插件
1.依次选择 File -&gt; Setting 打开 IDEA 设定的界面
2.选择 “Plugins” 选项，在输入输入“Dart”并点击搜索按钮
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca56c29ebc2f7ec8f92ff588df767129/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a617c0398a57868702cfe816e5f0ea5c/" rel="bookmark">
			hive处理json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		{转载}https://www.iteblog.com/archives/2362.html
问题我们都知道，Hive 内部提供了大量的内置函数用于处理各种类型的需求，参见官方文档：Hive Operators and User-Defined Functions (UDFs)。我们从这些内置的 UDF 可以看到两个用于解析 Json 的函数：get_json_object 和 json_tuple。用过这两个函数的同学肯定知道，其职能解析最普通的 Json 字符串，如下：hive (default)&gt; SELECT get_json_object(’{“website”:“www.iteblog.com”,“name”:“过往记忆”}’, ‘$.website’);OKwww.iteblog.com hive (default)&gt; SELECT json_tuple(’{“website”:“www.iteblog.com”,“name”:“过往记忆”}’, ‘website’, ‘name’);OKwww.iteblog.com 过往记忆Time taken: 0.074 seconds, Fetched: 1 row(s)json_tuple 相对于 get_json_object 的优势就是一次可以解析多个 Json 字段。但是如果我们有个 Json 数组，这两个函数都无法处理，get_json_object 处理 Json 数组的功能很有限，如下：
hive (default)&gt;&gt; &gt; SELECT get_json_object('[{"website":"www.iteblog.com","name":"过往记忆"}, {"website":"carbondata.iteblog.com","name":"carbondata 中文文档"}]', '$.[0].website');OKwww.iteblog.comTime taken: 0.069 seconds, Fetched: 1 row(s) 如果我们想将整个 Json 数组里面的 website 字段都解析出来，如果这么写将非常麻烦，因为我们无法确定数组的长度，而且即使确定了，这么写可维护性也很差，所以我们需要想别的办法。
如果想及时了解Spark、Hadoop或者Hbase相关的文章，欢迎关注微信公共帐号：iteblog_hadoop使用 Hive 自带的函数解析 Json 数组在介绍如何处理之前，我们先来了解下 Hive 内置的 explode 函数，官方的解释是：explode() takes in an array (or a map) as an input and outputs the elements of the array (map) as separate rows.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a617c0398a57868702cfe816e5f0ea5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f649577efe56fe285d85f3923b1a755/" rel="bookmark">
			react native报错 React Native version mismatch解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		react Native 开发过程中 遇到的问题
在启动项目时 遇到过React Native version mismatch错误
这里报错的意思是react native 与 javascript 版本不一致
这里可能出现报错的原因有两个，一个就如报错所言两种版本不一致，另一个是因为在启动新项目之前有个旧项目在还在启动中。
两种版本不一致时 我们需要收到把package.json文件里的react-native文件版本改为与javascript版本一致。（不要忘记 npm install 重新安装依赖包）；
当还有一个旧项目在启动时，我们只需要关闭运行旧项目的终端就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c393dd85da51847dd1bad10152d242dd/" rel="bookmark">
			xshell 只能打开四个标签的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xshell个人版做了限制,只能打开四个标签,打开超过四个标签就会新开一个窗口,工作效率会降低,目前想到三个解决办法
1. 装个人版再装plus 版.(优点,打开超过四个标签不会开新窗口,缺点,破解有可能会失效)
https://blog.csdn.net/yueludanfeng/article/details/88546424
2. 使用国产finallShell代替xshell (优点:免费,个人觉得比shell好用,缺点:需要迁移服务器账号密码等)
http://www.hostbuf.com/
3. 使用xshell5 xshell5不会限制标签数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ee04162b08af4196c51747c4ee28e11/" rel="bookmark">
			ubuntu boot修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方案：使用U盘启动盘，进入系统安装boot-repair 问题描述：最近在工作的ubuntu系统中尝试安装了deepin桌面，在进行桌面主题设置后重启，ubuntu无法启动，开机启动失败后进入biso界面 环境描述：双显卡的笔记本（在进行U盘引导时需要禁用n卡，不禁用会导致各种卡死）
步骤： 第一步：还是进入ubuntu图形界面 在插上U盘后重启，通过键盘进入U盘引导界面 先使用键盘上下选择，以避免超时，以ubuntu18为例，移动到第一个tryxxx（因为你已经安装了ubuntu系统，不到万不得已不选择重装），按下e进入grob界面，找到quiet splash或linux开头行 该行直接在末尾空格+nomodeset，按下F10启动系统。（在期间也许会再次发生卡死，不要灰心，重启电脑，按原步骤检查输入是否正确）
第二步：安装boot-repair 进入系统后打开终端完成以下命令：（需要联网） 安装boot-repair的源，并更新 sudo add-apt-repository ppa:yannubuntu/boot-repair &amp;&amp; sudo apt-get update 安装并开启boot-repair sudo apt-get install -y boot-repair &amp;&amp; boot-repair
第三步：进行恢复 在安装成功后弹出的窗口选择Recommended repair， 恢复成功后，就会弹出我们的盘的各种信息以及引导的信息。 如果有些人不小心点击了Create a BootInfo summary的话，那你的开机启动界面将会出来一大堆你以前没见过的东西。 本攻略无视这些，总感觉后面会用到。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2576866def47dba8d9ed87c6ee0c080/" rel="bookmark">
			Dart语言详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 变量1.1 变量-变量的声明1.2 变量-默认值1.3 变量-final和const 2 内置类型2.1 内置类型-num, int, double2.2 Strings 字符串2.3 内置类型-bool2.4 内置类型-List2.5 内置类型-Map2.6 内置类型-Set2.7 内置类型-Runes2.8 内置类型-Symbol 3 函数3.1 函数-定义3.2 函数-可选参数3.3 函数-匿名函数3.4 函数-闭包3.5 函数-函数别名 4 操作符5 流程控制语句6 异常6.1 异常-Exception类型6.2 异常-Error类型6.3 异常-抛出6.4 异常-捕获 7 类7.1 类-构造函数7.2 类-命名构造函数7.3 类-重定向构造函数7.4 类-初始化列表7.5 类-调用超类构造函数7.6 类-常量构造函数7.7 类-工厂构造函数7.8 类-Setter和Getter7.9 类-抽象类7.10 类-可调用类 8 Mixin9 泛型9.1 泛型-泛型函数9.2 泛型-构造函数泛型9.3 泛型-泛型限制9.4 泛型-与java区别 10 库10.1 库-使用核心库10.2 库-载入第三方库10.3 库-载入文件10.4 库-指定库前缀10.5 库-选择性载入10.6 库-延迟载入10.7 库-自定义库 11 异步11.1 异步-async和await11.2 异步-then,catchError,whenComplete11.3 异步-Event-Looper11.4 异步-Event Queue和Microtask Queue11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2576866def47dba8d9ed87c6ee0c080/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b495720e75a8f2490ed82bebc0f4afb/" rel="bookmark">
			qss样式表之QComboBox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来个简单的示例
QComboBox { font-family: "Microsoft YaHei"; font-size: 14px; color: #000000; font-style: italic; font-weight: bold; } 效果图如下
其中：
font-family 为设置字体类型，标准形式需要加双引号，不加也可能会生效，具体看系统是否支持，中英文都支持，但要保证字体编码支持，一般程序编码为"utf-8"时没问题。
font-size 为设置字体大小，单位一般使用 px 像素
font-style 为设置字体斜体，italic 为斜体， normal 为不斜体
font-weight 为设置字体加粗，bold 为加粗， normal 为不加粗
color 为设置字体颜色，可以使用十六进制数表示颜色，也可以使用某些特殊的字体颜色：red, green, blue 等，或者使用 rgb(r,g,b) 和 rgba(r,g,b,a) 来设置，其中 r、g、b、a 值为0~255，如果想不显示颜色可以设置值为透明 transparent
注意：字体颜色用的是 color 属性，没有 font-color 这个属性的
对于字体样式，可以把 family size style weight 统一设置在 font 属性中：
font: bold italic 18px "Microsoft YaHei"; 这里出现的顺序要求是 style 和 weight 必须出现在开头，size 和 family 在后面，而且 size 必须在 family 之前，否则样式将不生效，font 中不能设置颜色，可以单独设置 style weight 和 size，不能单独设置 family
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b495720e75a8f2490ed82bebc0f4afb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c12580af0da1f19725103e7fc3d96e69/" rel="bookmark">
			Ubuntu下为安装的软件创建启动图标并添加到开始菜单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu下为安装的软件创建启动图标并添加到开始菜单 linux操作系统，如果用apt-get命令安装软件，往往会自带启动图标，但是很多时候自己安装的软件没有自动生成这样的图标，要自己手动创建图标快捷方式
开始菜单软件图标位置 这些在开始菜单里看见的图标位置：/usr/share/applications
具体打开目录看一眼：
也就是说，我们创建好.desktop文件后，扔到这里就好，之后在开始菜单就找得到了
创建.desktop文件 以下以qgroundcontrol软件为例
下载的目录里面，直接在命令行里打
source qgroundcontrol-start.sh 执行启动脚本，软件就打开了
但是这样每次都很不爽，所以在桌面新建一个qgroundcontrol.desktop文件，在命令行里面输入以下命令：
gedit qgroundControl 打开文件进行编辑，复制这些命令：
[Desktop Entry] Version=3.5.3 Type=Application Terminal=false Exec=//home/strange/Downloads/3.5.3/qgroundcontrol/qgroundcontrol-start.sh Name=QGroundControl Icon=/home/strange/Downloads/3.5.3/qgroundcontrol/qgroundcontrol.png 然后修改文件属性为可执行，右键properties
至于再添加什么其他的软件，只需要明确启动脚本所在位置，也就是
Exec=//home/strange/Downloads/3.5.3/qgroundcontrol/qgroundcontrol-start.sh 和图标所在位置，也就是
Icon=/home/strange/Downloads/3.5.3/qgroundcontrol/qgroundcontrol.png
就可以正常打开了
如果不想看见开一个终端窗口，就设置：
Terminal=false 创建开始菜单图标 用命令行sudo，把创建好的.desktop文件复制到/usr/share/applications就好，具体可以用sudo cp命令操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/189d18641c0c7f275e471db6559ebb93/" rel="bookmark">
			Arduino&#43;ESP8266，AT指令配置连接Onenet物联网平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 该项目为业余时间做的作品，利用Arduino串口发送AT指令配置ESP8266，使ESP8266连接到Onenet物联网平台从而获取云端数据，项目优点是配置简单，程序做好处理了，只需更改WIFI名称、WIFI密码、、Onenet设备号、APIKEY、数据流名称。
Onenet平台具有应用编辑功能，很方便的可以创建出一个上位机的界面，Onenet提供的APP还可以显示网页端编辑好的界面，所以可以很快速的开发出一个物联网系统的上位机程序。在本作品中我创建了一个按钮用于控制LED灯
效果如下图
演示视频：https://v.youku.com/v_show/id_XNDI2ODAzMzQ3Mg==.html?spm=a2h3j.8428770.3416059.1
Onenet配置 在另一篇博客做详细的介绍编写中
硬件部分 器材数量截图Arduino UNO1 ESP8266（ESP-01S）1 LED（5V）1 接线部分 ESP8266Arduino3V33.3VGNDGNDRXTx--1TXRx--2 程序 1、配置串口及初始化ESP8266 初始化ESP8266
void ConnectSetup() //初始化ESP8266，连接WiFi { Serial.begin(115200); Serial.println("AT+CWMODE=1"); //配置为Station模式，连接热点 delay(500); Serial.println("AT+RST"); //复位ESP8266模块 delay(1000); Serial.println("AT+CWJAP=\""+WiFiName+"\",\""+WiFIPasswd+"\"");//配置为Station模式，连接热点 delay(2500); } 初始化串口及IO口，在这里控制LED灯的引脚为7号引脚，也可以更改为其他的
void setup() { Serial.begin(115200); pinMode(7, OUTPUT); ConnectSetup(); } 2、获取Onenet平台取数据 采用Http协议，GET Onenet的数据
void GetOnenet() { String str = "GET http://api.heclouds.com/devices/"+DeviceID+"/datastreams/"+DataStreamName+" HTTP/1.1"+"\napi-key: "+APIKey+"\nHost:api.heclouds.com\nConnection:close\n\n"; Serial.println("AT+CIPSTART=\"TCP\",\""+ServerIP+"\","+ServerPost); //连接服务器 delay(100); Serial.println("AT+CIPSEND="+(String)str.length()); //设置发送数据长度 delay(200); Serial.println(str);//Get Onenet的数据 } 3、主程序 定时向串口发送数据包，连接Onenet平台获取数据
void loop() { GetOnenet(); if (Serial.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/189d18641c0c7f275e471db6559ebb93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a9ad9882e230d800383a04da5b1b877/" rel="bookmark">
			python 处理pdf文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用pdfminer转pdf文件
from pdfminer.pdfinterp import PDFTextExtractionNotAllowed from pdfminer.pdfparser import PDFParser from pdfminer.pdfparser import PDFPage from pdfminer.pdfparser import PDFDocument from pdfminer.pdfinterp import PDFContentParser,PDFPageInterpreter from pdfminer.pdfinterp import PDFResourceManager from pdfminer.pdfdevice import PDFTextDevice from pdfminer.layout import LTTextBoxHorizontal,LAParams from pdfminer.converter import PDFPageAggregator path="./code/docs-pdf/c-api.pdf" with open(path,mode="rb")as fp: mypdf=PDFParser(fp) print(mypdf) doc=PDFDocument() mypdf.set_document(doc) doc.set_parser(mypdf) doc.initialize() if not doc.is_extractable: raise PDFTextExtractionNotAllowed else: #创建pdf资源管理器 来管理共享资源 rscrmgr=PDFResourceManager() #创建一个pdf文档分离器 laparams=LAParams() device=PDFPageAggregator(rscrmgr,laparams=laparams) interpreter=PDFPageInterpreter(rscrmgr,device) #处理每一个page的内容 for page in doc.get_pages(): interpreter.process_page(page) layout=device.get_result() for x in layout: if (isinstance(x,LTTextBoxHorizontal)): with open("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a9ad9882e230d800383a04da5b1b877/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac62dd04a7ed886bdb622e916abd7b56/" rel="bookmark">
			UFS存储介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下一代存储技术介绍-UFS UFS Universal Flash Storage，即就是UFS。此内存扩展标准是UFSHCI标准JESD223的扩展。UFSHCI标准定义了UFS驱动程序和UFS主机控制器之间的接口。除寄存器接口外，它还定义了系统内存中的数据结构，用于交换数据，控制和状态信息。此外，UFSHCI标准定义了这些层内的协议层结构和抽象实体。
通用内存可以将设备内部工作内存移动到系统内存中，从而降低整体系统成本并提高设备性能。
UFS最新一代UFS3.0 UFS 3.0专为需要高性能和低功耗的移动应用和计算系统而开发，是首款引入MIPI M-PHY HS-Gear4的标准，每通道数据速率高达11.6 Gbps，性能比先前版本规范(UFS2.0)高2倍。
UFS 3.0包括两个专门针对汽车市场推出的功能：能够在扩展温度范围内工作和刷新操作。
UFS是一种高性能接口，设计用于需要最小化功耗的应用，包括智能手机和平板电脑等移动系统以及汽车应用。
其高速串行接口和优化协议可显着提高吞吐量和系统性能。
速率提升的根本原因：
为了实现最高性能和最节能的数据传输，UFS利用MIPI®Alliance的业界领先规范来形成其互连层。此协作继续使用UFS 3.0版，该版本引用了MIPI M-PHY®v4.1物理层规范和最近发布的MIPI UniProSM v1.8传输层规范。
JEDEC标准官网：https://www.jedec.org/news/pressreleases/jedec-publishes-universal-flash-storage-ufs-ufshci-version-30-and-ufs-card
JEDEC：JEDEC即 固态技术协会是微电子产业的领导标准机构。在过去50余年的时间里，JEDEC所制定的标准为全行业所接受和采纳。作为一个全球性组织，JEDEC的会员构成是跨国性的。JEDEC 不隶属于任何一个国家或政府实体。但是华为被制裁时间明显指出，这是一家美国的附属组织。
UFS替代谁 请注意UFS存储是用来为下一代存储而发展的相关技术，其性能比较是和eMMC来比较的，并不是和NAND Flash比较，因为eMMC是NAND的进化版本，其性能来讲eMMC是秒杀Nand Flahs的；而eMMC的协议已经多年未更新了，且eMMC的数据时序标准似乎到达瓶颈，所以很难再有新的发展了，而且并行8总线的eMMC因为需要并行-串行转换，所以速率很难提升上去。而串行方式的UFS变成新的趋势了，其简单连接以及高速率，现在看来会在未来一段时间称为新的存储趋势。
数据传输形式： eMMC为半双工结构，同一时间下只能读取或者写入，但是UFS是全双工结构，既可以读取又可以写入。UFS使用的是差分传输结构，而eMMC使用的是单线传输形式需要考虑噪声容限等指标，且信号电平要高于UFS，因此速率受限不如UFS。 具体的速率比较如下，eMMC与UFS：
eMMC与UFS相比，其总线数量太多，但最终处理都是要变为串行机器码的，所以如果eMMC协议没有革新，则被UFS取代只是时间问题。况且因为温度导致的时序飘移等情况，在eMMC5.1版本下，为了优化在HS400模式下这个问题，专门增加了strobe这个引脚来自适应时序对其，如果eMMC再升高传输模式，则就需要做出新的改变。故从14年之后目前没有新的eMMC标准出来了。
请注意，以下的速率是当前一些产品平均可以实际达到的速率，并不是标准规范的速率：
具体的速率比较如下，eMMC、UFS与SATA：
UFS、eMMC、SATA性能比较，图中比较的是最高的理论速率，所以实际的物理连接速率可能低于此值，具体看配置（以下的SATA 为 X2的总线形式，当然总线越多速率越高）。
请注意如下是标准规定可以达到的最高速率：
eMMC与UFS总线传输形式 总线传输形式不一样，虽然都是同步传输方式，即就是都需要时钟信号作为参考；
eMMC使用8条数据总线做复用（地址和数据，发送和接收），外加命令线以及新增的STROBE线；需要的IO口很多，比较复杂；UFS需要两组差分线，一条是时钟线就可以了，并且是双向数据发送接收，全双工；IO口配置也比较简单，就像USB3.0一样。 如下所示：
更详细的连接描述：
UFS传输协议： UFS卡架构基于最先进的行业验证协议：移动行业处理器接口（MIPI）的M-PHY和UniPro，物理层和链路层采用JEDEC联盟标准，命令层采用SCSI命令。
UFS使用UniPro作为数据链路层。 UniPro仅支持点对点链接，因为它们需要设备所需的最高数据速率。
UFS主机UniPro IP的主要组件是AXI接口，UFS主机控制器接口，UFS传输协议层（UTP），传输层，网络层，数据链路层，PHY适配器层和M-PHY。
如下图所示：
从实际的物理信号传输比较 UFS相比于eMMC的优势：
1）抗EMI和串扰
如果从差分导体外部引入EMI或串扰，则将其同等地添加到反相和非反相信号。
因此，接收器电路极大地降低了干扰或串扰的幅度。
2）降低EMI和串扰
差分对中的两个信号产生（理想情况下）幅度相等但极性相反的电磁场。
这适用于UFS卡，并确保两个导体的发射在很大程度上相互抵消。
3）更好的信噪比
UFS卡中的差分信号可以使用较低的电压，并且由于提高了抗噪声性能，仍然保持足够的信噪比（SNR），而SD卡中的单端信号需要稳定的高电压以确保足够的SNR。
4）接收器电路的复杂性降低
将差分信号集成到UFS卡中，确定逻辑状态更简单，
就像比较反相和非反相信号的电压一样。
然而，在SD卡的单端系统中，接收器电路更复杂，应考虑参考电压的值以及变化和容差。
5）专业物理/链接和命令层的优点
UFS应用电路：
下图显示了UFS卡的推荐原理图，其中包含所有信号连接和无源元件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac62dd04a7ed886bdb622e916abd7b56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e73cbeb5d7c1cfa9e7e62240a9264654/" rel="bookmark">
			ros笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 路径搜索 &lt;rospkg， ref: rospkg&gt;
终端使用
rospkg find package name : return the absolute path to a package rospack list | grep 'package_name' python 使用
import rospkg rospack = rospkg.RosPack() dir = rospack.get_path("package name") 2从bag中解析数据
过滤数据：
rosbag filter
或
rosbag play + rosbag record（可以同时record多个bag）
终端直接输出
rosbag info xxx.bag rosbag play xxx.bag rostopic echo '/xx_topic' python 使用
import collections import rosbag def read_pose_from_ros_bag(ros_bag_file, topics=None): ''' Reads different kinds of topics from a ros bag file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e73cbeb5d7c1cfa9e7e62240a9264654/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b56854147650edac2bda4069cf85c86/" rel="bookmark">
			ConcurrentHashMap如何实现高效的线程安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前的专栏主要介绍了Java集合框架的典型，并且也分析了比较流行的Map实现方法HashMap，让大家进一步的了解了使用方法和底层原理，并且稍微讲述了线程方面的问题，这篇文章将主要围绕线程，亦或是并发的角度去介绍。
但是我们之前所介绍大多数都不是线程安全的，但也有像HashTable这样安全，但是性能很差，成本很高的，所以java内部也提供了并发包，为高度并发需求提供了更加全面的工具支持。
那么，我们如何保证线程是安全的，Concurrent包下的ConcurrentHashMap又是如何实现高效的线程安全的
简介 Java提供了不同层面的线程安全支持。在传统集合框架内部，我们可以调用Collections工具类提供的包装方法，来获取一个同步的包装容器，但是它们都是利用非常粗粒度的同步方式，在高并发情况下，性能比较低下。
另外，更加普遍的选择是用并发包提供的线程安全容器类，它提供了：
并发容器：ConcurrentHashMap，CopyOnWriteArrayList线程安全队列(Queue/Deque)：ArrayBlockingQueue、SynchronousQueue各种有序容器的线程安全版本等。 保证线程安全，首先最简单的就是使用synchronize，到更加精细化的，比如基于分离锁实现的ConcurrentHashMap等并发实现等。具体看开发的场景需求，总体来说，并发包内提供的容器通用场景，远胜于早期的简单同步实现。
分离锁：在某些情况下，可以将锁分解技术进一步扩展为对一组独立对象上的锁进行分解，这种情况称为锁分段。例如ConcurrencyHashMap是有一个包含16个锁的数组实现，每个锁保护所有散列桶的1/16，其中第N个散列桶由第（N mod 16）个锁来保护。假设所有关键字都时间均与分布，那么相当于把锁的请求减少到原来的1/16，可以支持多达16个的并发写入。
锁分段的劣势在于：与采用单个锁来实现独占访问相比，要获取多个锁来实现独占访问将更加困难并且开销更高，比如计算size、重hash。
说到线程安全和并发，可以说是java面试中的必考点，但是对于ConcurrentHashMap等等的并发容器也在不断的演进，所以也不能一概而论。
从面试角度来讲：
要深入思考并且回答这个问题及其扩展方面，至少需要：
理解基本的线程安全工具。理解传统集合框架并发编程中Map存在的问题，了解简单同步方式的不足梳理并发包内，尤其是ConcurrentHashMap自身的演进，目前的很多分析资料还是基于其早期版本。掌握ConcurrentHashMap自身的演进，目前的很多分析资料还是基于其早期版本。 扩展 为什么需要ConcurrentHashMap？
我们之前说过HashTable是可以保证线程安全的，但是性能较低，或者可以说是比较耿直，在底层，像get put remove 的操作，在底层都是加上了各种synchronize。简单来说，这就导致了所有并发操作都需要竞争同一把锁，一个线程在进行同步操作，其他在排队，这就大大降低了效率。
前面已经提到了HashMap不是线程安全的，并发情况会让CPU占用100%，那么能不能利用Collections提供的同步包装来解决问题呢?
可以看以下的代码：
我们发现这个同步包装器只是利用输入Map构造了另一个同步版本，所有操作虽然不再声明成为synchronized方法，但是还是利用了this作为互斥的mutex，没有真正的改进。
所以，HashTable确实可以保证线程安全，但无法保证高并发环境的有效利用。
ConCurrentHashMap分析 首先先强调，ConcurrentHashMap的设计一直都在演化，所以，在这里将比较分析结构，实现机制等方面，进行不同版本的讲述。
在最早的ConcurrentHashMap，其实现是基于：
分离锁，也就是将内部进行分段(Segment)，里面则是HashEntry的数组，和HashMap类似，哈希相同的条目也是以链表的形式存放。HashEntry内部使用volatile的value字段来保证可见性，也利用了不可变对象的机制来改进利用Unsafe提供的底层能力，比如volatile access。去直接完成部分操作，以优化性能，毕竟Unsafe中的很多操作都是JVM intrinsic优化过的 可以明显的看出它避免了HashTable整体同步的问题，提高了性能。
在构造的时候，Segment的数量由concurrentcyLevel决定，默认是16，也可以在相应构造函数直接指定。
然后可以看一下ConcurrentHashMap下的get源码：
而对于put操作，为了避免二次哈希导致哈希碰撞，所以用Unsafe，直接获取Node，然后进行线程安全的put操作：
public V put(K key, V value) { return putVal(key, value, false); } /** Implementation for put and putIfAbsent */ final V putVal(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b56854147650edac2bda4069cf85c86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feea5a9f30c0242189134710cd8b646d/" rel="bookmark">
			【SQL】SQL Case When用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 case when sql中计算条件列表，并返回多个可能的结果表达式之一。
CASE 表达式有两种格式：1、CASE 简单表达式，它通过将表达式与一组简单的表达式进行比较来确定结果。2、CASE 搜索表达式，它通过计算一组布尔表达式来确定结果。这两种格式都支持可选的 ELSE 参数。
可以在 SELECT、UPDATE、DELETE 和 SET 等语句以及 select_list、IN、WHERE、ORDER BY 和 HAVING 等子句中使用 CASE。这里使用MySQL数据库进行操作。
语法格式 1、简单表达式
select *,case sex when '1' then '男' when '2' then '女' else '其他' end as sexdesc from score; 2、搜索表达式
select *,case when sex='1' then '男' when sex='2' then '女' end as sexdesc from score; 2019-07-06-143912.png 相关用法 1、case when和group by一起使用
//统计各分段内的学生数 select count(*) as nums,case when score&lt;90 then '小于90分' else '不小于90分' end as status from score group by y case when score&lt;90 then '小于90分' else '不小于90分' end; 2019-07-06-160504.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/feea5a9f30c0242189134710cd8b646d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e29a39a36dac450eb889f48c7c01ee52/" rel="bookmark">
			java设计模式之原型模式、浅克隆和深克隆区别、克隆破坏单例模式、原型模式源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、原型模式之简单介绍：
》定义：指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象，
》特点：不需要知道任何创建的细节，不调用构造函数。
》类型：创建型。
》适用场景：
1、类初始化消耗较多资源。
2、new产生的一个对象需要非常复杂的过程（数据准备、访问权限等）；
3、构造函数比较复杂；
4、循环体中产生大量对象时；
》优点：
原型模式比直接new创建对象性能要高
简化创建过程；
》缺点：
必须配备克隆方法
对克隆复杂对象或对克隆出的对象进行复杂改造时，容易引入风险；
深拷贝、浅拷贝使用要得当。
原型扩展：
》深克隆：
对于引用类型，如果需要他们指向不同的对象，就需要深克隆，也就是需要重写或者说
覆盖object的cloneable()方法。
》浅克隆：
浅克隆的引用类型，克隆出的新引用和原来的引用指向的对象是同一个。
二、代码实践
创建如下实例，我们要给很多人发送邮件，模板内容一致，来模拟创建大量对象。同时，通过不断改进代码的状态，来演示原型模板使用的特点。
假设一般常见的方式，代码如下：
package com.zxl.design.pattern.creation.prototype; /** * Created by Administrator on 2019/7/6. */ public class Mail { private String name; private String emailAddress; private String content; public Mail(){ System.out.println("constructor as default"); } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmailAddress() { return emailAddress; } public void setEmailAddress(String emailAddress) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e29a39a36dac450eb889f48c7c01ee52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d49706e11bc8f0221566ac15a97e3792/" rel="bookmark">
			ssh介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 SSH是Secure Shell Protocol的简写，SSH先对联机数据包通过加密技术进行加密处理，加密后在进行数据传输。确保了传递的数据安全。
SSH是安全的加密协议，用于远程连接linux服务器。SSH默认端口是22，安全协议版本SSHv2，除了2之外还有SSHv1（有漏洞）。SSH服务端主要包含两个服务功能SSH远程连接和SFTP服务。Linux SSH客户端包含ssh远程连接命令，以及远程拷贝scp命令等。 非对称加密 ssh之所以安全，在于其基于公私钥的非对称加密方式。
先将Client生成公钥添加到remotehost中的~/.ssh/authorized文件中。建立远程链接，将client的公钥发送给remotehost，remotehost在~/.ssh/authorized文件中寻找你的公钥进行匹配，当匹配成功后，remotehost生成一个用公钥加密的随机数并将这个随机数发送给Client。Client接收到公钥加密的随机数后，利用自己的相匹配的私钥进行解密。（如果你在生成密钥时给密钥加了密码，你需要在选择密钥解密时输入密码）解密成功后将解密后的随机数返回给remotehost，这时remotehost进行判断是否与自己生成的随机数相同，如果相同链接建立成功。 参考 https://wk.baidu.com/view/12824942a32d7375a517801d?pcf=2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dff0ffb724ecaf19717778a900d36839/" rel="bookmark">
			module-info.class问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.module-info.class是个什么？干什么？
2.看名字module-info，即 模块信息，自然想到是管理模块信息的。jdk9特性里的，在解压软件中直接干掉呗，试试没报错ok就行
3.pom文件导入 asm等配置后启动报错
&lt;dependency&gt;
&lt;groupId&gt;asm&lt;/groupId&gt;
&lt;artifactId&gt;asm&lt;/artifactId&gt;
&lt;version&gt;3.3.1&lt;/version&gt;
&lt;/dependency&gt;
严重: Unable to process Jar entry [module-info.class] from Jar [jar:file:/D:/soft/repository/org/ow2/asm/asm/7.1/asm-7.1.jar!/] for annotations
org.apache.tomcat.util.bcel.classfile.ClassFormatException: Invalid byte tag in constant pool: 19
2.log4j中也有，也干掉，这个层次jar位置再往下找META-INF/versions/9/module-info.class，编译器都告诉你位置了，别傻傻的和前面那个一样
Unable to process Jar entry [META-INF/versions/9/module-info.class] from Jar [jar:file:/D:/soft/repository/org/apache/logging/log4j/log4j-api/2.12.0/log4j-api-2.12.0.jar!/] for annotations
找到对应maven仓库的位置 /D:/soft/repository/org/apache/logging/log4j/log4j-api/2.12.0/log4j-api-2.12.0.jar!/下的
META-INF/versions/9/module-info.class 解压工具删除掉（关掉IDE工具，删完再运行）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f28d0dedd941f16bf04ef6a9f2c64ae/" rel="bookmark">
			form表单如何不直接提交？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在from表单上添加属性onsubmit
2.在中间写上checkform()方法
&lt;script type="text/javascript"&gt; function checkform(form){ if(readcount == 0){ return false; } return true; }; &lt;/script&gt; 该方法return false时表单不会提交，如果引入jquery,不能写在$(document).ready()里面，这个里面写的js,都是先要获取jquery元素的(就像方法里面不能写方法，ready()已经是一个方法了，checkform()又是一个方法。所以checkform()方法直接写在script标签内即可)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/653031b711ae34c8d1784adb93086f5a/" rel="bookmark">
			循环输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; void CirPrint( int *number,int n,int m) { if(number==NULL) return; int start=0; int cout=0; while(cout&lt;n*m) { for(int i=start;i&lt;n-start&amp;&amp;cout&lt;n*m;i++) { printf("%3d",number[start*n+i]); cout++; } for(int i=start+1;i&lt;m-start&amp;&amp;cout&lt;n*m;i++) { printf("%3d",number[i*n+(n-1-start)]); cout++; } for(int i=n-2-start;i&gt;=start&amp;&amp;cout&lt;n*m;i--) { printf("%3d",number[(m-1-start)*n+i]); cout++; } for(int i=m-2-start;i&gt;start&amp;&amp;cout&lt;n*m;i--) { printf("%3d",number[i*n+start]); cout++; } start++; } } int main() { int *number; int n,m; scanf("%d %d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;m;j++) scanf("%d",&amp;(number[i*m+j])); } CirPrint(number,n,m); //cout &lt;&lt; "Hello world!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/653031b711ae34c8d1784adb93086f5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b2c306fa919326197fa28dce73f1ca3/" rel="bookmark">
			5、用filter求素数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5、用filter求素数 计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单：
首先，列出从2开始的所有自然数，构造一个序列：
2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：
3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：
5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
取新序列的第一个数5，然后用5把序列的5的倍数筛掉：
7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b2c306fa919326197fa28dce73f1ca3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9070053520cac708345b4318e78158c3/" rel="bookmark">
			19、【翻译】模块inspect — Inspect live objects
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		19、【翻译】模块inspect — Inspect live objects 翻译自Python官方文档 ： 29.12. inspect — Inspect live objects inspect—检查活动对象 inspect模块提供了几个有用的功能来帮助获取有关活动对象的信息，例如模块，类，方法，函数，回溯，框架对象和代码对象。 例如，它可以帮助您检查类的内容，检索方法的源代码，提取并格式化函数的参数列表，或者获取显示详细回溯所需的所有信息。
这个模块提供了四种主要的服务：类型检查，获取源代码，检查类和函数以及检查解释器堆栈。
3、使用Signature对象来内省可调用对象 3.3版本的新功能。
Signature对象表示可调用对象的调用签名及其返回注释。 要获得Signature对象，请使用signature（）函数。
inspect.signature(callable, *, follow_wrapped=True) 为给定的可调用对象返回一个Signature对象：
&gt;&gt;&gt; from inspect import signature &gt;&gt;&gt; def foo(a, *, b:int, **kwargs): ... pass &gt;&gt;&gt; sig = signature(foo) &gt;&gt;&gt; str(sig) '(a, *, b:int, **kwargs)' &gt;&gt;&gt; str(sig.parameters['b']) 'b:int' &gt;&gt;&gt; sig.parameters['b'].annotation &lt;class 'int'&gt; 接受各种各样的python callables，从普通函数和类到functools.partial（）对象。
如果不提供签名，则引发ValueError;如果不支持该类型的对象，则引发TypeError。
3.5版新增：follow_wrapped参数。 传递False以获得可调用对象的签名（callable.__wrapped__ 不会用于打开装饰的可调用对象）。
注意：在Python的某些实现中，某些可调用对象可能不是内省的。 例如，在CPython中，C中定义的一些内置函数不提供关于它们参数的元数据。
class inspect.Signature(parameters=None, *, return_annotation=Signature.empty) Signature对象代表一个函数的调用签名及其返回注释。对于函数接受的每个参数，它在其参数集合中存储了一个参数对象。
可选的parameters参数是一系列Parameter对象的序列，这些参数要经过检验，以此来保证没有重名的参数，并且参数的顺序是正确的（例如：首先是positional-only，然后是positional-or-keyword），以及没有默认值的参数在前，有默认值的在后。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9070053520cac708345b4318e78158c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9e1cbc09725b197add65b7676d717c9/" rel="bookmark">
			Spring注解@Component、@Repository、@Service、@Controller区别 .
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring 2.5 中除了提供 @Component 注释外，还定义了几个拥有特殊语义的注释，它们分别是：@Repository、@Service 和 @Controller。
在目前的 Spring 版本中，这 3 个注释和 @Component 是等效的，但是从注释类的命名上，很容易看出这 3 个注释分别和持久层、业务层和控制层（Web 层）相对应。
虽然目前这3 个注释和 @Component 相比没有什么新意，但 Spring 将在以后的版本中为它们添加特殊的功能。
所以，如果 Web 应用程序采用了经典的三层分层结构的话，最好在持久层、业务层和控制层分别采用上述注解对分层中的类进行注释。
@Service用于标注业务层组件
@Controller用于标注控制层组件（如struts中的action）
@Repository用于标注数据访问组件，即DAO组件
@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。
[java] view plain copy print ? @Service public class VentorServiceImpl implements iVentorService { } @Repository public class VentorDaoImpl implements iVentorDao { } @Service public class VentorServiceImpl implements iVentorService { } @Repository public class VentorDaoImpl implements iVentorDao { } 在一个稍大的项目中，如果组件采用xml的bean定义来配置，显然会增加配置文件的体积，查找以及维护起来也不太方便。 Spring2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9e1cbc09725b197add65b7676d717c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a01faa97b683ff1a0a9b8d859b22152f/" rel="bookmark">
			about wParam and lParam
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两个是Win16系统遗留下来的产物了
在Win16API中WndProc有两个参数
一个是WORD类型的16位整型变量
另一个是LONG类型的32位整型变量,
因此根据匈牙利命名法，16位的变量就被命名为wParam, 而32位的变量就被命名为lParam。
到了Win32API中，原来的16位变量也被扩展为32位，
因此wParam和lParam的大小完全相同。
在Win32API的早期，为了保证和Win16API的代码可移植性
MS定义了WPARAM和LPARAM两个宏
当时保留了w前缀的原因一方面是由于WPARAM宏也已W开头，
还有也因为要提醒程序员注意到可移植性，当然到了现在
Win16早已退出历史舞台，这个前缀也就约定俗成的沿用下来了。
转载于:https://www.cnblogs.com/jonnyyu/archive/2005/08/23/220525.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/186fb90be90d24eaedfd519474304fa8/" rel="bookmark">
			【转载】你的“音量控制”窗口是不是很大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://dotnet.blogger.cn/qiuji/archive/2004/04/19/905.aspx 转载于:https://www.cnblogs.com/jonnyyu/archive/2004/04/21/6750.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88dcfdf5188024fe6bca7de11ecbf37d/" rel="bookmark">
			How to handle IHTMLDocument2.onmouseover event in .NET
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有些ActiveX控件的事件机制是使用IDispatch接口的default method实现的，在.NET中如何使用这样的事件回调呢？
1)?定义一个类，定义事件处理的方法并加上属性标识它是该类的IDispatch接口缺省方法，下面是一个例子：
Public Class Interop
Public Sub onMouseOver()
MessageBox.Show("MouseOver")
End Sub
End Class
2) 但是如果你直接写
IHTMLDocument2 doc = axWebBrowser1.Document
doc.onmouseover = New Interop
那在运行时会得到一个NOT_IMPLEMENTED的异常，因为默认情况下.NET 的Interop Marshaller会将marshal成VT_UNKNOWN类型的Variant，而我们这里需要marshal成VT_DISPATCH的Variant。我们可以使用.NET提供的DisptachWrapper来解决这个问题。
doc.onmouseover = New DispatchWrapper(New Interop)
当你不再需要处理这个事件时，你可以使用下面的方法把该event handler断开。
doc.onmouseover = New DispatchWrapper(Nothing)
转载于:https://www.cnblogs.com/jonnyyu/archive/2004/02/02/711.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/470/">«</a>
	<span class="pagination__item pagination__item--current">471/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/472/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>