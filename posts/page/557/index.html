<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4b03ec0b346e5b463e63070173e6b9c/" rel="bookmark">
			Pip install: ImportError: cannot import name IncompleteRead
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在Ubuntu 14.04 64bit上安装python开发环境的过程中遇到如下错误:
Pip install: ImportError: cannot import name IncompleteRead
表现的现象是, 无论我怎么使用pip install XXX, 我都会得到上面类似的错误, (在ubuntu中使用命令直接安装的pip出错了, 不管是卸载后重装, 都无法修复这个问题.)
经过网上搜索, 发现这是python pip的一个bug：
https://bugs.launchpad.net/ubuntu/+source/python-pip/+bug/1306991
网上通常的解决方法是
从pip官网直接重装，重装前先卸载ubuntu的pip包
sudo apt-get remove python-pip
sudo apt-get autoremove
wget https://raw.github.com/pypa/pip/master/contrib/get-pip.py --no-check-certificate
sudo python get-pip.py
下面是我找到的经过验证过很管用的方法:
easy_install -U pip
下面是pip安装成功后的验证:
参考文献
[1].http://suanfazu.com/t/pip-install-importerror-cannot-import-name-incompleteread/17
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ef125c2c2b60e5d761ced4aa92d8957/" rel="bookmark">
			C语言数组知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组：就是只能存放一种数据类型，比如int类型的数组、float类型的数组，里面存放的数据称为“元素”
数组的定义：
首先声明数组的类型，然后声明数组元素的个数（也就是需要多少存储空间）
格式： 元素类型 数组名[元素个数];
比如： int[3];
数组元素有顺序之分，每个元素都有一个唯一的下标（索引），而且都是从0开始
数组元素的访问: a[i]
数组元素的初始化：
 int a[3] = {10, 9, 6};
 int a[3] = {10,9};
 int a[] = {11, 7, 6};
 int a[4] = {[1]=11,[0] = 7};
#include&lt;stdio.h&gt; int main() { //数组的定义格式： 类型 变量名[元素个数]; //int ages[5]; //数组的赋值方式： /* ages[0] = 12; ages[1] = 19; ages[2] = 14; ages[3] = 26; ages[4] = 18; */ //int ages[5] = {[2] = 14,[3] = 26}; //int ages[5] = {12,19}; int ages[5] = {12,19,14,26,18}; //错误写法： //int ages[]; //错误写法 //int ages[5]; 只能在定义数组的时候进行初始化 //ages = {12,19,14,26,18}; //错误写法,如果想在定义数组的同时进行初始化，数组元素个数必须是常量或者不写 //int ages[count] = {12,19,14,26,18}; /*数组的遍历，按顺序查看数组的每一个元素*/ //1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ef125c2c2b60e5d761ced4aa92d8957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec13c69497cc1b5df71cd2575108f2d1/" rel="bookmark">
			发布网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 https://developer.apple.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20efb4cb6ea6c892fb5f37128e4bd560/" rel="bookmark">
			C/C&#43;&#43;快速读写磁盘数据的方法-块读取/异步/优化分析算法/内存文件映射的原理和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速读写磁盘数据的方法：
1.块读取：一下子将数据读取到内存的（无论是文本还是二进制)，而不是一行行的读取。
2.异步的IO，创建多线程，或者使用重叠IO,IO复用，异步的事件回调通知机制（可以用事件对象，信号驱动来实现)。
3.优化分析文件的算法和尽量延后分析，分析算法里面频繁的申请字符串内存和释放字符串内存，尽量用指针解析出来，分析文件的内容可以延期到使用的时候才分析。
如果不注意，不小心 ，读取文件的主要性能消耗将会在这里，所以需要特别高的重视。
4.使用内存文件映射, window是CreateFileMapping，MapViewOfFile，UnmapViewOfFile，CloseHandle；linux是用mmap,munmap,msync,free。
内存文件映射的使用：
(1)大数据量文件的读取，有效的提高磁盘和内存间数据通信的性能；
(2）进程间快速的共享内存，实现进程间高效的通信。
内存映射文件性能高于普通IO的原因：
内存文件映射和普通的文件IO都是要通过文件系统和硬盘驱动拷贝数据到内存中，内存文件映射数据越大越快主要是：
（1）实际拷贝数据前，需要建立映射信息，内存文件映射已经提前准备好了映射关系，内核调度好了进程内的内存块，交付给内核进行了预先处理，内存文件映射会消耗掉一些时间。
（2）实际拷贝时候，内存文件映射将磁盘数据直接拷贝到用户进程内存空间只进行了一次拷贝，而普通的IO是先将文件拷贝到内核缓存空间，然后才拷贝到用户进程内存空间，进行了两次拷贝。
下面是一个使用普通的fread函数和内存映射文件函数，读取不同大小的磁盘文件的性能分析表：
文件大小(KB)
I/O函数读取时间(ms)
内存映射读取时间(ms)
5.56 0
47
56
31
47
508
94
47
4597.76
811
47
47820.8
7348
78
209920
31403
218
510976
72977
436
综合：当读写磁盘文件的数据较小(少于1MB)时候，使用内存文件映射和普通IO是差异很小的，所以建议使用普通IO就可以了；当很多文件的大小在几十MB, 几百MB, 或者1GB以上的文件数据需要进行较频繁的访问，或者一开始需要全部加载这些大文件的时候，那么就需要考虑使用内存文件映射了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1cff4bb718b2a47a3711f7b6afd6b5f/" rel="bookmark">
			Apache Commons Math3学习笔记（1）- 快速傅立叶变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		傅立叶变换：org.apache.commons.math3.transform.FastFourierTransformer类。
用法示例代码：
double inputData = new double[arrayLength]; // ... 给inputData赋值 FastFourierTransformer fft = new FastFourierTransformer(DftNormalization.STANDARD); Complex[] result = fft.transform(inputData, TransformType.FORWARD); 使用还是非常简单的。首先要创建待计算数据的数组，可以是double类型，亦可是org.apache.commons.math3.complex.Complex类型，然后创建org.apache.commons.math3.transform.FastFourierTransformer对象实例，最后调用其transform方法即可得到存放于复数数组中的傅立叶变换结果。 完整的示例代码如下：
import org.apache.commons.math3.transform.DftNormalization; import org.apache.commons.math3.transform.FastFourierTransformer; import org.apache.commons.math3.transform.TransformType; interface TestCase { public Object run(List&lt;Object&gt; params) throws Exception; public List&lt;Object&gt; getParams(); } class CalcFFT implements TestCase { public CalcFFT() { System.out.print("本算例用于计算快速傅立叶变换。正在初始化 计算数据(" + arrayLength + "点)... ..."); inputData = new double[arrayLength]; for (int index = 0; index &lt; inputData.length; index++) { inputData[index] = (Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1cff4bb718b2a47a3711f7b6afd6b5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dee859cc087fc5389a80c38de9ebdcc/" rel="bookmark">
			遗传算法简单实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遗传算法的手工模拟计算示例
为更好地理解遗传算法的运算过程，下面用手工计算来简单地模拟遗传算法的各
个主要执行步骤。
例：求下述二元函数的最大值：
(1) 个体编码
遗传算法的运算对象是表示个体的符号串，所以必须把变量 x1, x2 编码为一种
符号串。本题中，用无符号二进制整数来表示。
因 x1, x2 为 0 ~ 7之间的整数，所以分别用3位无符号二进制整数来表示，将它
们连接在一起所组成的6位无符号二进制数就形成了个体的基因型，表示一个可
行解。
例如，基因型 X＝101110 所对应的表现型是：x＝[ 5，6 ]。
个体的表现型x和基因型X之间可通过编码和解码程序相互转换。
(2) 初始群体的产生
遗传算法是对群体进行的进化操作，需要给其淮备一些表示起始搜索点的初始
群体数据。
本例中，群体规模的大小取为4，即群体由4个个体组成，每个个体可通过随机
方法产生。
如：011101，101011，011100，111001
(3) 适应度汁算
遗传算法中以个体适应度的大小来评定各个个体的优劣程度，从而决定其遗传
机会的大小。
本例中，目标函数总取非负值，并且是以求函数最大值为优化目标，故可直接
利用目标函数值作为个体的适应度。
(4) 选择运算
选择运算(或称为复制运算)把当前群体中适应度较高的个体按某种规则或模型遗传到下一代群体中。一般要求适应度较高的个体将有更多的机会遗传到下一代
群体中。 本例中，我们采用与适应度成正比的概率来确定各个个体复制到下一代群体中
的数量。其具体操作过程是：
• 先计算出群体中所有个体的适应度的总和 fi ( i=1.2,…,M );
• 其次计算出每个个体的相对适应度的大小 fi / fi ，它即为每个个体被遗传
到下一代群体中的概率，
• 每个概率值组成一个区域，全部概率值之和为1；
• 最后再产生一个0到1之间的随机数，依据该随机数出现在上述哪一个概率区
域内来确定各个个体被选中的次数。
(5) 交叉运算
交叉运算是遗传算法中产生新个体的主要操作过程，它以某一概率相互交换某
两个个体之间的部分染色体。
本例采用单点交叉的方法，其具体操作过程是：
• 先对群体进行随机配对；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dee859cc087fc5389a80c38de9ebdcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7017f14ec170c66c827a641bd5dc0ca/" rel="bookmark">
			OnDisable与OnDisable的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OnDisable：当物体被销毁时 OnDisable将被调用，并且可用于任意清理代码。脚本被卸载时，OnDisable将被调用，OnEnable在脚本被载入后调用。注意： OnDisable不能用于协同程序。
OnDestory：当MonoBehaviour将被销毁时，这个函数被调用。OnDestroy只会在预先已经被激活的游戏物体上被调用。注意：OnDestroy也不能用于协同程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f98c2881c97cca1e140f0a3612fbf58/" rel="bookmark">
			PostgreSQL explain返回行的评估
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		explain返回行是通过对应表的列的统计信息来评估的，在系统表pg_stats中。
建表，插入测试数据：
postgres=# create table tb15(id integer,name character varying); CREATE TABLE postgres=# insert into tb15 select generate_series(1,10000),'john'; INSERT 0 10000 postgres=# analyze tb15; ANALYZE 例1. where条件完全落在柱状图的边界值。 postgres=# explain(analyze,verbose,buffers)select * from tb15 where id&lt;1000; QUERY PLAN ------------------------------------------------------------------------------------------------------------ Seq Scan on public.tb15 (cost=0.00..180.00 rows=1000 width=9) (actual time=0.009..0.821 rows=999 loops=1) Output: id, name Filter: (tb15.id &lt; 1000) Rows Removed by Filter: 9001 Buffers: shared hit=55 Total runtime: 0.901 ms (6 rows) postgres=# \x Expanded display is on postgres=# select * from pg_stats where tablename ='tb15' and attname='id'; -[ RECORD 1 ]----------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- schemaname | public tablename | tb15 attname | id inherited | f null_frac | 0 avg_width | 4 &lt;strong&gt;n_distinct | -1&lt;/strong&gt; most_common_vals | most_common_freqs | &lt;strong&gt;histogram_bounds | {1,100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,3100,3200,3300,3400,3500,3600,3700,3800,3900,4000,4100,4200,4300,4400,4500,4600,4700,4800,4900,5000,5100,5200,5300,5400,5500,5600,5700,5800,5900,6000,6100,6200,6300,6400,6500,6600,6700,6800,6900,7000,7100,7200,7300,7400,7500,7600,7700,7800,7900,8000,8100,8200,8300,8400,8500,8600,8700,8800,8900,9000,9100,9200,9300,9400,9500,9600,9700,9800,9900,10000}&lt;/strong&gt; correlation | 1 most_common_elems | most_common_elem_freqs | elem_count_histogram | 当where条件不是等于的时候，且n_distinct为-1的时候（表示该字段的值都是唯一的），可以参考pg_stats表中的histogram_bounds字段的统计值，也就是表字段的柱状图。 histogram_bounds 的值受参数 default_statistics_target 控制。default_statistics_target默认值为100，default_statistics_target参数值越大，那么PG搜集的列上的统计信息就越精确，当然在表做 Analyze 操作时花费的时间也稍长些。 postgres=# show default_statistics_target ; default_statistics_target --------------------------- 100 (1 row)这里提一下也可以修改字段的统计的default_statistics_target值 postgres=# \h alter table Command: ALTER TABLE Description: change the definition of a table Syntax: ALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ] action [, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f98c2881c97cca1e140f0a3612fbf58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43c8f222aaccd9d3089f3fcdc8f038d4/" rel="bookmark">
			continue、break、return这三个关键字的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、return 语句的作用 (1) return 从当前的方法中退出,返回到该调用的方法的语句处,继续执行。 (2) return 返回一个值给调用该方法的语句，返回值的数据类型必须与方法的声明中的返回值的类型一致。 (3) return后面也可以不带参数，不带参数就是返回空，其实主要目的就是用于想中断函数执行，返回调用函数处。 2. continue 语句的作用 （1）break在循环体内，强行结束循环的执行，也就是结束整个循环过程，不在判断执行循环的条件是否成立，直接转向循环语句下面的语句。 （2）当break出现在循环体中的switch语句体内时，其作用只是跳出该switch语句体。 3.continue 语句的作用 终止本次循环的执行，即跳过当前这次循环中continue语句后尚未执行的语句，接着进行下一次循环条件的判断。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/962e9b84f184f95b9b62e8c9785c8969/" rel="bookmark">
			火车运煤算法--全面解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你是山西的一个煤老板，你在矿区开采了有3000吨煤需要运送到市场上去卖，从你的矿区到市场有1000公里，你手里有一列烧煤的火车，这个火车最多只能装1000吨煤，且其能耗比较大――每一公里需要耗一吨煤。请问，作为一个懂编程的煤老板的你，你会怎么运送才能运最多的煤到集市？
这道题一开始看上去好像是无解的，因为你的火车每一公里就要消耗一吨煤，而到目的地有1000公里，而火车最多只能装1000吨媒。如果你的火车可以全部装下，到目的地也会被全部烧光，一丁点也不剩。所以，很多人的第一反应都是觉得这个不太可能。
思考答题是：
装1000吨煤，走250公里，扔下500吨煤，回矿山。装1000吨煤，走到250公里处，拿起250吨煤继续向前到500公里处，扔下500吨煤，回矿山。此时火车上还有250吨，再加上在250公里处还有250吨煤，所以，火车是可以回矿山的。装上最后1000吨煤，走到500公里处，装上那里的500吨煤，然后一直走到目的。 大家可能还有更好的方案，请集思广益！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/865838069cefa477e38cb09e325c716a/" rel="bookmark">
			&#34;remote:error:refusing to update checked out branch:refs/heads/master&#34;的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用Git Push代码到数据仓库时，提示如下错误:
[remote rejected] master -&gt; master (branch is currently checked out)
错误原型：
remote: error: refusing to update checked out branch: refs/heads/master remote: error: By default, updating the current branch in a non-bare repository remote: error: is denied, because it will make the index and work tree inconsistent remote: error: with what you pushed, and will require 'git reset --hard' to match remote: error: the work tree to HEAD. remote: error: remote: error: You can set 'receive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/865838069cefa477e38cb09e325c716a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ac25b8480f26cc259c4fc5f18e7555a/" rel="bookmark">
			史上最全的Chrome使用技巧集锦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Chrome的隐身模式 2 3 先来说说隐身模式的启用方法吧 4 5 1.键盘快捷：Ctrl + Shift + N。 6 7 2.在Windows7下的任务栏处，右击“Chrome”图标，会出一个下拉菜单，点击“新建隐身窗口”。 8 9 3.你还可以在一个正在浏览的页面中，通过“右键点击链接”出现下拉菜单，选择“在隐身窗口中打开链接”，直接进入隐身窗口（如下图）。 10 11 简单一点的说，Chrome的隐身模式的好处就是保持你的隐私。具体表现在在此窗口中查看的网页不会显示在浏览器历史记录或搜索历史记录中，关闭隐身窗口后也不会在计算机上留下 Cookie 之类的其他痕迹，但会保留所有下载的文件或创建的书签，一般什么情境下你会使用Chrome的隐身模式呢 12 13 1、在注册网上银行等业务方面的网站时 14 15 2、你用朋友的电脑上网，而又不想在“历史记录”中被他发现你上了哪些网站 16 17 Chrome最强大的地方莫过于有各种各样的插件了，那如何在隐身模式下启用或禁用插件呢？点击右上角“扳手“–》”更多工具“–》”扩展程序”，在这个页面中，你可以选择哪些插件可以用于Chrome的隐身模式 18 19 事实上隐身模式并非是万能的，Chrome给出的建议是在以下一些情况下谨防失效： 20 21 收集或共享有关您的信息的网站 22 跟踪您访问的网页的互联网服务提供商或雇主 23 以提供免费表情符号的名义跟踪您击键情况的恶意软件 24 通过秘密代理进行监视的行为 25 站在身后的人 26 27 Chrome下各种组合键 28 热键组合 实现的功能 29 F1 Google浏览器帮助中心 30 F12 打开Chrome控制台 31 Ctrl+J 进入“下载内容”页面 32 Ctrl+H 查看“历史记录”页面 33 Ctrl+D 将此页加入书签 34 Ctrl+F 打开/关闭 搜索框（搜索页面内的文字） 35 Ctrl+P 打开打印窗口 36 Ctrl+T 新建标签页 37 Ctrl+W 关闭标签页 38 Ctrl++ 放大页面 39 Ctrl+- 缩小页面 40 Ctrl+0 默认页面字体大小 41 Ctrl+Shift+T 重新打开最近关闭的一个标签 42 Ctrl+N 新建一个窗口 43 Ctrl+Shift+N 新建一个隐身模式窗口 44 Ctrl+Tab 从左到右，标签循环浏览 45 Ctrl+Shift+Tab 从右到左，标签循环浏览 46 Ctrl+1-8 分别指向第1、2、3…8标签 47 Ctrl+9 跳转到最后一个标签 48 Ctrl+Shift+Del 打开“清除浏览数据”窗口 49 Ctrl+Shift+B 显示/隐藏书签栏 50 Shift+Esc 开打Chrome任务管理器 51 Alt+Home 在当前标签打开首页 52 Alt+D/Ctrl+L 迅速突出地址栏 53 Ctrl+Enter 在地址栏自动添加www或.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ac25b8480f26cc259c4fc5f18e7555a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b9c00f36c8097067c8895b02fb4face/" rel="bookmark">
			Android Drawable 转化成 Bitmap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /*Java代码 将Drawable转化为Bitmap */ Bitmap drawableToBitmap(Drawable drawable) { int width = drawable.getIntrinsicWidth(); int height = drawable.getIntrinsicHeight(); Bitmap bitmap = Bitmap.createBitmap(width, height,drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888: Bitmap.Config.RGB_565); Canvas canvas = new Canvas(bitmap); //canvas.drawColor(0xff33B5E5); drawable.setBounds(0,0,width,height); drawable.draw(canvas); return bitmap; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02641115f179afb3d446a7c61a14aca3/" rel="bookmark">
			Devcpp（Dev-C&#43;&#43;）代码编辑的快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里记录一些个人使用Devcpp时，摸索出来的代码编辑快捷键，感觉非常有用。如果是熟悉eclipse软件使用的开发者，对它在标号上的光标跳转，文本的选取，翻页等等快捷键的使用一定不会陌生，相比之下，很多eclipse里面使用的快捷键，同样适用于Devcpp。
说明一下，这里测试快捷键用的Devcpp的版本号为5.6.3，同时还穿插它与eclipse，Visual Studio 2013（以下简写为VS2013）的对比。废话不多说，进入主题。
1、Ctrl + 方向键左或右
光标在标记和数字之间跳转，跳转之后的光标位于标记或数字的开头处，这里的跳转会忽略掉标记或数字之间的各种符号，仅仅是在你打出的abc字母组成的标记或数字之间来回跳转。（eclipse和VS2013则不会跳过这些符号，并且它们处理字符上的跳转时并不是逐个字符地进行，而是能识别多个符号的组合符号，将其当成一个整体跳过，例如，&lt;&lt;，+=，==）
2、Ctrl + 方向键上或下
光标保持在当前位置不动，进行上下翻页，翻页是按一行一行进行。（同eclipse和VS2013）
3、Ctrl + Home键
跳转到当前文本的开头处。（同eclipse和VS2013）
4、Ctrl + End键
跳转到当前文本的末尾处。（同eclipse和VS2013）
5、Ctrl + d
删除光标当前所在位置上，一整行的文本。（同eclipse，但VS2013不支持）
6、Ctrl + e
复制光标当前所在位置上一整行的内容，并粘贴在刚才复制行所在的下一行上，不会覆盖原先下一行的文本，而是将复制的内容插入光标所在行和下一行之间。（eclipse则是激活并定位当前打开的某一个文件，而VS2013是用于某种组合键，功能不明）
7、Ctrl + PageUp
光标跳到当前代码编辑视窗的顶行首个文本字符之后，注意不是整个文本的首行。（同VS2013，而eclipse是在几个打开的代码文件之间进行切换）
8、Ctrl + PageDown
同上，只是在当前视窗末行的相同位置处。（同上）
9、Ctrl + m
换行，效果等同按下一次回车键（vim中也支持，eclipse中则是隐藏左右两边的工具栏，使代码文本的视窗最大，VS2013则是用于某个功能不明的组合键）。
10、Ctrl + / 用 // 注释掉光标当前所在行，再次按下则会取消注释。如果已经选中一个区域的文本，那么会给这块区域的每一行都加上 // 注释，再次按下会取消注释。（同eclipse，但VS2013不支持）
***还有一种注释的组合键Ctrl + .（英文句点），但不能通过再次按下撤销注释，Devcpp的说明中有一个Ctrl + ,（英文逗号）用于取消注释，但实际使用后没有效果。
11、Ctrl + Space（空格键）【代码的智能提示，非常有用】
Devcpp同样可以弹出智能提示，估计很多用户都没有发现，上下键移动选取候选项，使用回车键选出所需的选项，注意用Tab键对选项没有选中效果。需要注意的是，使用这一功能，需要时不时地保存当前编辑的代码文本，只有将代码文本保存到硬盘之后（Ctrl + s），软件才会进行一次代码的文法分析，然后再按下此组合键触发需要的提示，如果有时候发现软件的智能提示没有效果，那么可尝试先保存代码，再试一次。另外，这个代码提示的功能是比较有限的，提示的内容里并不包含关键字，但自定义的函数、变量，类对象的方法、属性，结构体中包含的元素，都是可提炼出来的。（eclipse和VS2013可以用Tab键来选定选项，这两个软件的智能提示一般不需要手动按键激发，也可以设置它们的触发键 ）
12、shift + 方向键左或右
从当前光标所在位置处开始，逐个字符地选取文本，字符包括字母和符号。（同eclipse和VS2013）
13、shift + 方向键上或下
从当前光标所在位置处开始，整行整行地选取文本。如果光标不在当前所在行的行首或行尾，则不会自动选中这一整行，只选取由光标划分开的那一部分。（同eclipse和VS2013）
14、Ctrl + shift + 方向键左或右
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02641115f179afb3d446a7c61a14aca3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf06cac42957aeef2f1cbb17cbc8d51c/" rel="bookmark">
			关于Modelsim仿真速度的优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果在不需要波形，只需要快速知道结果的情况下，可以用优化选项。这适用于做大量case的仿真阶段。因为这一阶段多数case都是通过的，只需要快速确认即可，然后把没通过的case拿出来做全波形的仿真调试。
根据“Quick Reference Guide for Increasing Performance”，经典的办法是
3-step method
1) Compile
2) Optimize
3) Simulate
脚本如下
vlib work
vlog *.v
vopt -o testbench_opt testbench
vsim testbench_opt
不过这个方法我在5.6的版本上尝试有如下限制（不知道modelsim推高级的版本有没有解决）
1. 如果设计全是源代码，整体编译整体优化后仿真可以有非常满意的加速效果；
2. 如果设计中包含了FPGA的仿真库文件，具体工艺库的库文件或者其它提前编译好的库文件，则在优化后
的loading操作时modelsim会提示链接错误，这显然是个很沮丧的消息，因为有些工程在设计的时候并没有把
memory等工艺相关的对象用纯RTL来表示，而是用了FPGA工具生成的v文件（很遗憾，我现在的项目正是如此，头大啊）
转载于:https://www.cnblogs.com/hfyfpga/p/4284402.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a203f4d5aa3ad8fab5f3f4b8debfe3/" rel="bookmark">
			c&#43;&#43; string总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标准C++中提供的string类得功能也是非常强大的，一般都能满足我们开发项目时使用。现将具体用法的一部分罗列如下，只起一个抛砖引玉的作用吧，好了，废话少说，直接进入正题吧！
要想使用标准C++中string类，必须要包含
#include &lt;string&gt;// 注意是&lt;string&gt;，不是&lt;string.h&gt;，带.h的是C语言中的头文件
using std::string;
using std::wstring;
或
using namespace std;
string类的大部分函数：
begin 得到指向字符串开头的Iterator
end 得到指向字符串结尾的Iterator
rbegin 得到指向反向字符串开头的Iterator
rend 得到指向反向字符串结尾的Iterator
size 得到字符串的大小
length 和size函数功能相同
max_size 字符串可能的最大大小
capacity 在不重新分配内存的情况下，字符串可能的大小
empty 判断是否为空
operator[] 取第几个元素，相当于数组
c_str 取得C风格的const char* 字符串
data 取得字符串内容地址
operator= 赋值操作符
reserve 预留空间
swap 交换函数
insert 插入字符
append 追加字符
push_back 追加字符
operator+= += 操作符
erase 删除字符串
clear 清空字符容器中所有内容
resize 重新分配空间
assign 和赋值操作符一样
replace 替代
copy 字符串到空间
find 查找
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01a203f4d5aa3ad8fab5f3f4b8debfe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9795236b4f7f89043d09aaa2a7d0dac7/" rel="bookmark">
			代码风格、命名规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的代码风格：
1、 大括号单独一行，内容只有一行的可以写在一行
2、 小括号前后不加空格
3、 逗号之后空一格
4、 for中的每个分号后空一格
5、 不在if、for、while语句中的=、+、-、复合赋值+=前后各空一格
在语句中的看情形：单次出现可空，多次出现一般不空
6、 复合比较&gt;=、==看情况：单次出现可空，多次出现一般不空
7、 *、/、%、比较操作&lt;、&gt;、!、位运算&amp;、|不空格
8、 &lt;&lt;、&gt;&gt;、&amp;&amp;、||前后空一格
9、 if、else后面只有一行且比较短时写在if或else的同一行
比较长时加{}并另起几行
10、注释//前后空一格，多行时可适当对齐
一段注释/**/,按*号对其: /*
* 注释内容
*/
11、do while、try catch:
do
{
.....;
}while();
try
{
}
catch(...)
{
}
12、相似代码将符号对齐：
a = test();
ab = test();
abcc = test();
13、将未提取至一个函数的小功能模块适当用作用域包围：
{
模块内容
...
}
14、一个整体的功能模块适当包含在命名空间内
我的命名规范：
A. class类：大写C开头,第一个类名大写: classCTest
B. struct结构体：大写字母开头，后缀_t: struct Test_t
C. class类数据成员：前缀m_：int m_test; struct成员无特殊规则: int test;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9795236b4f7f89043d09aaa2a7d0dac7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e150e020a82036da509585b920714208/" rel="bookmark">
			Java 日期总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 日期处理有两种类: Date类和GregorianCalendar(继承于Calendar)
Date 由于Sun 已经清楚地将相应的构造函数和方法标记为“不赞成”（deprecated），所以倾向于使用GregorianCalendar。
一 获取GregorianCalendar对象方法:
1. Calendar.getInstance() 2. new GregorianCalendar() 二 获取当前时间 SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");//设置日期格式 System.out.println(df.format(new Date()));// new Date()为获取当前系统时间
三 字符串转Date类 String dateString="year-month-day"; SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd"); Date date=sdf.parse(dateString); 四 Date类转字符串 String str; Date date; …… str=(new SimpleDateFormat("yyyy-MM-dd" )).format(date); 五 时间加减 Calendar calendar=Calendar.getInstance(); calendar.setTime(date); //用已有Date类初始化calendar中的Date类 calendar.getTime(date); //获取calendar中的Date类 calendar.set(Calendar.DAY_OF_MONTH,calendar.get(Calendar.DAY_OF_MONTH)+1); //set方法用来设置Date类中的年、月、日等属性， 如 DAY_OF_MONTH设置月中的天数，Calendar.MONTH设置月， //注意月份的起始值为０而不是１。 //另外要注意的一点是，Calendar 为了性能原因对 set() 方法采取延缓计算的方法， //但是在 Calendar 的方法中，get() 和 add() 会让 Calendar 立刻刷新。 calendar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e150e020a82036da509585b920714208/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8daba021005695bb4af68b2a423d3c14/" rel="bookmark">
			执行计划查看方法（Explain plan）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是执行计划
所谓执行计划，顾名思义，就是对一个查询任务，做出一份怎样去完成任务的详细方案。举个生活中的例子，我从珠海要去英国，我可以
选择先去香港然后转机，也可以先去北京转机，或者去广州也可以。但是到底怎样去英国划算，也就是我的费用最少，这是一件值得考究
的事情。同样对于查询而言，我们提交的SQL仅仅是描述出了我们的目的地是英国，但至于怎么去，通常我们的SQL中是没有给出提示信息
的，是由数据库来决定的。
生成执行计划的方法
1.设置autotrace
序号
命令
解释
1
SET AUTOTRACE OFF
此为默认值，即关闭Autotrace 2
SET AUTOTRACE ON EXPLAIN
只显示执行计划
3
SET AUTOTRACE ON STATISTICS
只显示执行的统计信息
4
SET AUTOTRACE ON
包含2,3两项内容
5
SET AUTOTRACE TRACEONLY
与ON相似，但不显示语句的执行结果
例：
SQL&gt; select * from emp; 执行计划
----------------------------------------------------------
Plan hash value: 3956160932
--------------------------------------------------------------------------
| Id | Operation | Name | Rows | Bytes | Cost (%CPU)| Time |
--------------------------------------------------------------------------
| 0 | SELECT STATEMENT | | 14 | 532 | 3 (0)| 00:00:01 |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8daba021005695bb4af68b2a423d3c14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9778840a0100cb30c982876741b0b5a2/" rel="bookmark">
			SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DB2
timestamp:
to_timestamp('2013-9-16 17:03:00.29999', 'yyyy-mm-dd hh24:mi:ss:ff')
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95db13d5bca5443ce1a7859738151d22/" rel="bookmark">
			LaTeX排版常用字体和格式设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2010-05-05 15:11:23 分类： LINUX
\usepackage{mathbbold} \usepackage{CJK,CJKnumb} \usepackage{indentfirst} %首行缩进宏包 \usepackage{latexsym,bm} % 处理数学公式中和黑斜体的宏包 \usepackage{amsmath,amssymb} % AMSLaTeX宏包 用来排出更加漂亮的公式 \usepackage{graphicx} \usepackage{cases} \usepackage{pifont} \usepackage{txfonts} %%%%%%%%%%% CJK下设置中文字体 %%%%%%%%%%%%% \newcommand{\song}{\CJKfamily{song}} % 宋体 (Windows自带simsun.ttf) \newcommand{\fs}{\CJKfamily{fs}} % 仿宋体 (Windows自带simfs.ttf) \newcommand{\kai}{\CJKfamily{kai}} % 楷体 (Windows自带simkai.ttf) \newcommand{\hei}{\CJKfamily{hei}} % 黑体 (Windows自带simhei.ttf) \newcommand{\li}{\CJKfamily{li}} % 隶书 (Windows自带simli.ttf) %%%%%%%%%%% 设置字体大小 %%%%%%%%%%%%% \newcommand{\chuhao}{\fontsize{42pt}{\baselineskip}\selectfont} \newcommand{\xiaochuhao}{\fontsize{36pt}{\baselineskip}\selectfont} \newcommand{\yihao}{\fontsize{28pt}{\baselineskip}\selectfont} \newcommand{\erhao}{\fontsize{21pt}{\baselineskip}\selectfont} \newcommand{\xiaoerhao}{\fontsize{18pt}{\baselineskip}\selectfont} \newcommand{\sanhao}{\fontsize{15.75pt}{\baselineskip}\selectfont} \newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont} \newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont} \newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont} \newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont} \newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont} \newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont} %%%%%%%% 设置版心 %%%%%%%%%%%%% \setlength{\textwidth}{14cm} \setlength{\textheight}{20cm} \setlength{\hoffset}{0cm} \setlength{\voffset}{0cm} \setlength{\parindent}{2em} % 首行两个汉字的缩进量 \setlength{\parskip}{3pt plus1pt minus1pt} % 段落之间的竖直距离 \renewcommand{\baselinestretch}{1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95db13d5bca5443ce1a7859738151d22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c395ca67fb4e7cf871219eccf9e0cd3/" rel="bookmark">
			bug修复日记------玩家第一次登陆的信息没有存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结构介绍：
最近在写游戏中社交相关的逻辑处理。整体思路架构如下：
当玩家登录游戏，去数据库中查找有没有玩家的信息，如果有，那么就取出来，放在内存中，如果没有，就新建一个玩家信息。
当玩家登出游戏的时候，把玩家的信息从内存中写入数据库中
现场日记：
今天在做单元测试的时候，发现一个bug，当玩家第一次登录游戏，然后登出之后，玩家的信息竟然没有存到数据库里。
当玩家第二次登录的时候，再登出游戏，竟然存到数据库里了。
分析过程：
在知晓这个bug之后，仔细打印从玩家登录到登出过程中运行的每一个函数。经过一翻查找，发现玩家在登出游戏的时候，玩家的信息
往数据库里存储的时候报错，并且错误被劫持。
紧接着，开始打印错误日志，发现当玩家的信息往数据库里面写入的时候，有一个信息从内存中读取失败。
然后分析这个信息，发现了之前思维的一个漏洞：
之前的想法是当玩家第一次登录的时候，先校验用户名和密码，如果不存在用户，那么就会新建一个。这时候，应该接着新建一个初始
的玩家信息，但是之前没有执行这一步。所以导致玩家的信息一直都没有，自然就写不入数据库里。
最终解决方案：
在玩家第一次登入的时候，初始化玩家信息，并存入数据库中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e05330a81b583e865398a2c56a8b6746/" rel="bookmark">
			epoll详解（转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ 什么是epoll epoll是什么？按照man手册的说法：是为处理大批量句柄而作了改进的poll。当然，这不是2.6内核才有的，它是在2.5.44内核中被引进的(epoll(4) is a new API introduced in Linux kernel 2.5.44)，它几乎具备了之前所说的一切优点，被公认为Linux2.6下性能最好的多路I/O就绪通知方法。 epoll的相关系统调用 epoll只有epoll_create,epoll_ctl,epoll_wait 3个系统调用。 1. int epoll_create(int size); 创建一个epoll的句柄。自从linux2.6.8之后，size参数是被忽略的。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。 2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); epoll的事件注册函数，它不同于select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。 第一个参数是epoll_create()的返回值。 第二个参数表示动作，用三个宏来表示： EPOLL_CTL_ADD：注册新的fd到epfd中； EPOLL_CTL_MOD：修改已经注册的fd的监听事件； EPOLL_CTL_DEL：从epfd中删除一个fd； 第三个参数是需要监听的fd。 第四个参数是告诉内核需要监听什么事，struct epoll_event结构如下： [cpp] view plain copy print ? //保存触发事件的某个文件描述符相关的数据（与具体使用方式有关） typedef union epoll_data { void *ptr; int fd; __uint32_t u32; __uint64_t u64; } epoll_data_t; //感兴趣的事件和被触发的事件 struct epoll_event { __uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; events可以是以下几个宏的集合： EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）； EPOLLOUT：表示对应的文件描述符可以写； EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）； EPOLLERR：表示对应的文件描述符发生错误； EPOLLHUP：表示对应的文件描述符被挂断； EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。 EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e05330a81b583e865398a2c56a8b6746/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cd0d06a01dff1fd3fb7af334062196c/" rel="bookmark">
			Java中的逃逸分析和TLAB以及Java对象分配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在学习使用Java的过程中，一般认为new出来的对象都是被分配在堆上，但是这个结论不是那么的绝对，通过对Java对象分配的过程分析，可以知道有两个地方会导致Java中new出来的对象并一定分别在所认为的堆上。这两个点分别是Java中的逃逸分析和TLAB（Thread Local Allocation Buffer）。本文首先对这两者进行介绍，而后对Java对象分配过程进行介绍。
1. 逃逸分析 1.1 逃逸分析的定义 逃逸分析，是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。 在计算机语言编译器优化原理中，逃逸分析是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他过程或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。
Java在Java SE 6u23以及以后的版本中支持并默认开启了逃逸分析的选项。Java的 HotSpot JIT编译器，能够在方法重载或者动态加载代码的时候对代码进行逃逸分析，同时Java对象在堆上分配和内置线程的特点使得逃逸分析成Java的重要功能。
1.2 逃逸分析的方法 Java Hotspot编译器使用的是
Choi J D, Gupta M, Serrano M, et al. Escape analysis for Java[J]. Acm Sigplan Notices, 1999, 34(10): 1-19. Jong-Deok Choi, Manish Gupta, Mauricio Seffano,Vugranam C. Sreedhar, Sam Midkiff等在论文《Escape Analysis for Java》中描述的算法进行逃逸分析的。该算法引入了连通图，用连通图来构建对象和对象引用之间的可达性关系，并在次基础上，提出一种组合数据流分析法。由于算法是上下文相关和流敏感的，并且模拟了对象任意层次的嵌套关系，所以分析精度较高，只是运行时间和内存消耗相对较大。
绝大多数逃逸分析的实现都基于一个所谓“封闭世界(closed world)”的前提：所有可能被执行的，方法在做逃逸分析前都已经得知，并且，程序的实际运行不会改变它们之间的调用关系 。但当真实的 Java 程序运行时，这样的假设并不成立。Java 程序拥有的许多特性，例如动态类加载、调用本地函数以及反射程序调用等等，都将打破所谓“封闭世界”的约定。
不管是在“封闭世界”还是在“开放世界”，逃逸分析，作为一种算法而非编程语言的存在，吸引了国内外大量的学者对其进行研究。在这里本文就不进行学术上了论述了，有需要的可以参见谷歌学术搜索：http://www.gfsoso.com/scholar?q=Escape%20Analysis。
1.3 逃逸分析后的处理 经过逃逸分析之后，可以得到三种对象的逃逸状态。 GlobalEscape（全局逃逸）， 即一个对象的引用逃出了方法或者线程。例如，一个对象的引用是复制给了一个类变量，或者存储在在一个已经逃逸的对象当中，或者这个对象的引用作为方法的返回值返回给了调用方法。ArgEscape（参数级逃逸），即在方法调用过程当中传递对象的应用给一个方法。这种状态可以通过分析被调方法的二进制代码确定。
NoEscape（没有逃逸），一个可以进行标量替换的对象。可以不将这种对象分配在传统的堆上。
编译器可以使用逃逸分析的结果，对程序进行一下优化。 堆分配对象变成栈分配对象。一个方法当中的对象，对象的引用没有发生逃逸，那么这个方法可能会被分配在栈内存上而非常见的堆内存上。
消除同步。线程同步的代价是相当高的，同步的后果是降低并发性和性能。逃逸分析可以判断出某个对象是否始终只被一个线程访问，如果只被一个线程访问，那么对该对象的同步操作就可以转化成没有同步保护的操作，这样就能大大提高并发程度和性能。矢量替代。逃逸分析方法如果发现对象的内存存储结构不需要连续进行的话，就可以将对象的部分甚至全部都保存在CPU寄存器内，这样能大大提高访问速度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cd0d06a01dff1fd3fb7af334062196c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf71926a0a91577c021408866c7c69ac/" rel="bookmark">
			关于INT_PTR的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用CStringArray 定义数组获并取数组大小，语句如下：
CStringArray sArr;
sArr.Add("姓名");
sArr.Add("姓名");
int nCount = sArr.GetCount();
使用VS2003编译时，得到如下警告信息：
warning C4244: “=” : 从“INT_PTR”转换到“int”，可能丢失数据
我得解决办法是：
将int nCount = sArr.GetCount();修改为int nCount = (int)sArr.GetCount();
查看帮助文档，INT_PTR是在basetsd.h中定义的数据类型，代码如下：
#if defined(_WIN64) typedef __int64 INT_PTR, *PINT_PTR; typedef unsigned __int64 UINT_PTR, *PUINT_PTR; typedef __int64 LONG_PTR, *PLONG_PTR; typedef unsigned __int64 ULONG_PTR, *PULONG_PTR; #define __int3264 __int64 #else typedef _W64 int INT_PTR, *PINT_PTR; typedef _W64 unsigned int UINT_PTR, *PUINT_PTR; typedef _W64 long LONG_PTR, *PLONG_PTR; typedef _W64 unsigned long ULONG_PTR, *PULONG_PTR; #define __int3264 __int32 #endif 个人理解为INT_PTR是特殊定义的类型在_W64(即__w64)中: int --&gt; INT_PTR是为了解决32位与64位编译器的兼容性而设置的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61e25571d100f220a5e25487a587a284/" rel="bookmark">
			Broadcast Intent实现的四个步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Broadcast Intent 机制的实现包含四个步骤：
一，注册
注册相应的Broadcast Intent 和重写onReceive方法
重写onReceive方法：
public class Receiver extends BroadcastReceiver{ @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub //添加onReceive代码处理 } }XML注册： 在application添加
&lt;receiver android:name="Receiver"&gt; &lt;intent-filter &gt; &lt;!-- 添加相应的行为、类别或者类型 --&gt; &lt;action android:name=""/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt;java注册： IntentFilter filter = new IntentFilter(); filter.addAction(My_NEW_LIFEFORM); //添加行为、类别或者类型 Receiver myReceiver =new Receiver(); registerReceiver(myReceiver, filter); 二，广播
有三种发送广播的方式，是由Context类提供的：
Context.sendBroadcast: 广播Intent到BroadcastReceiver,满足条件的Broadcast Receiver都会执行onReceiver方法。这种方式不严格保证执行顺序。Context.sendOrderedBroadcast: 广播Intent到BroadcastReceiver,满足条件的Broadcast Receiver都会执行onReceiver方法。这种方式保证执行顺序，根据BroadcastReceiver注册时IntentFilter设置的优先级的顺序来执行onReceiver方法，高优先级的BroadcastReceiver执行先于低优先级的BroadcastReceiver。Context.sendStickyBroadcast： 广播Intent到BroadcastReceiver,满足条件的Broadcast Receiver都会执行onReceiver方法。这种方式一直保存sendStickyBroadcast发送的Intent， 这样以后使用registerReceiver注册招收器时，新注册的接收器的Intent对象为该Intent对象。 三、接收 BroadcastReceiver收到广播Intent，对Intent进行判断，满足即执行onReceiver方法。
四、销毁
每次执行 onReceiver 方法完，BroadcastReceiver实例就会被销毁。因为执行onReceiver方法时，Android系统会启动一个程序计时器，如果在一定时间内onReceiver方法没有完成，会被认为该无响应，所以onReceiver方法需要包含快速执行的逻辑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b21c6e4250bfc89c1c79799feff1105/" rel="bookmark">
			RSA算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www4.zzu.edu.cn/rgb6/ShowMht.aspx?Type=1&amp;ID=76
RSA算法需要以下相关的数学概念：
素数：素数是一个比1大，其因子只有1和它本身，没有其它数可以整除它的数。素数是无限的。例如，2，3，5，7……等。
两个数互为素数：指的是它们除了1之外没有共同的因子。也可以说这两个数的最大公因子是1。例如，4和9，13和27等。
模运算：如A模N运算，它给出了A的余数，余数是从0到N-1的某个整数，这种运算称为模运算。
RSA加密算法的过程如下：
（1）取两个随机大素数p和q（保密）
（2）计算公开的模数r=pq(公开)
（3）计算秘密的欧拉函数 (r) =（p-1）(q-1)（保密），两个素数p和q不再需要，应该丢弃，不要让任何人知道。
（4）随机选取整数e，满足gcd(e,  (r))=1(公开e，加密密钥)
（5）计算d，满足de≡1(mod  (r))(保密d，解密密钥，陷门信息)
（6）将明文x（其值的范围在0到r-1之间）按模为r自乘e次幂以完成加密操作，从而产生密文y（其值也在0到r-1范围内）
y=xe (mod r)
（7）将密文y按模为r自乘d次幂，完成解密操作
x=yd (mod r)
下面用一个简单的例子来说明RSA公开密钥密码算法的工作原理。
取两个素数p=11，q=13，p和q的乘积为n=p&amp;#215;q=143，算出秘密的欧拉函数Phi(n)=(p-1)&amp;#215;(q-1)=120，再选取一个与Phi(n)=120互质的数，例如e=7，作为公开密钥，e的选择不要求是素数，但不同的e的抗攻击性能力不一样，为安全起见要求选择为素数。对于这个e值，可以算出另一个值d=103，d是私有密钥，满足e&amp;#215;d=1 mod (n)，其实7&amp;#215;103=721除以120确实余1。欧几里德算法可以迅速地找出给定的两个整数a和b的最大公因数gcd（a，b），并可判断a与b是否互素，因此该算法可用来寻找解密密钥。
(n,e) 这组数公开，(n,d)这组数保密。
设想需要发送信息x=85。利用(n,e)=(143,7)计算出加密值：
y= xe (mod r)=857 mod 143=123
收到密文y=123后，利用 (n,d)=(143,103)计算明文：
x=yd (mod r) =123103mod 143=85
加密信息x（二进制表示）时，首先把x分成等长数据块 x1 ,x2,..., xi ，块长s，其中 2s ≤ n，s尽可能的大。对应的密文是：
yi = xie ( mod r )
解密时作如下计算：
xi = yid ( mod r )
RSA算法中的难点有以下几点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b21c6e4250bfc89c1c79799feff1105/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bf47b313afc30172ce843702f73aaec/" rel="bookmark">
			shell的find命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：关于find命令
由于find具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一下。即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只你具有相应的权限。
在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(这里是指30G字节以上的文件系统)。
一、find 命令格式 1、find命令的一般形式为； find pathname -options [-print -exec -ok ...] 2、find命令的参数； pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。 -print： find命令将匹配的文件输出到标准输出。 -exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' { } \;，注意{ }和\；之间的空格。 -ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 3、find命令选项 -name 按照文件名查找文件。 -perm 按照文件权限来查找文件。 -prune 使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。 -user 按照文件属主来查找文件。 -group 按照文件所属的组来查找文件。 -mtime -n +n 按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。 -nogroup 查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。 -nouser 查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。 -newer file1 ! file2 查找更改时间比文件file1新但比文件file2旧的文件。 -type 查找某一类型的文件，诸如： b - 块设备文件。 d - 目录。 c - 字符设备文件。 p - 管道文件。 l - 符号链接文件。 f - 普通文件。 -size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。 -depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。 -fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。 -mount：在查找文件时不跨越文件系统mount点。 -follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。 -cpio：对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。 另外,下面三个的区别:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bf47b313afc30172ce843702f73aaec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6500634695cab7a6c1ce2332488bbe03/" rel="bookmark">
			使用LabVIEW如何生成应用程序（exe）和安装程序（installer）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题: 在Windows平台下使用LabVIEW如何生成一个独立可执行程序和安装程序？
解答: 为什么要生成exe和installer
使用LabVIEW编写程序的最后往往需要将程序拿到目标电脑上去运行，如何将程序从开发电脑上移植到目标电脑上呢？这里有两种方法：
1. 在目标电脑上安装LabVIEW以及相关驱动和工具包，然后将vi或者整个项目拷贝到目标电脑上。然而安装LabVIEW和各种工具包会比较耗费时间，且vi可以被任意修改，容易引起误操作，如果只是运行程序，则不推荐这种方法。
2. 将LabVIEW编写的程序在开发电脑上编译生成独立可执行程序（exe），然后将可执行程序移植到目标电脑上，这里的移植分为两种方式：
A．将生成的exe拷贝到目标电脑上，然后在目标电脑上单独安装LabVIEW运行引擎（Run-Time Engine）和需要的驱动以及工具包等，此方法中安装驱动和工具包也需要花费较多时间，不推荐
B．将生成的exe和一些用到的组件打包生成installer，即安装程序，然后在目标电脑上运行安装程序即可，这样安装完成后，之前生成的exe、LabVIEW运行引擎以及其他用到的工具包会自动安装到目标电脑上，这种方法移植程序比较简单，是最常用的方法。
关于LabVIEW运行引擎
任何电脑，只要你想在上面运行LabVIEW生成的独立可执行程序（exe），你都需要在目标电脑上安装LabVIEW运行引擎。LabVIEW运行引擎包含了：
1. 运行LabVIEW生成的可执行程序所需要的库和文件
2. 使用浏览器远程访问前面板所需的浏览器插件
3. 应用程序中生成LabVIEW报表所需要的一些组件
4. 一些3D图表的支持等
运行引擎本身就是支持多语言的，不需要安装特定语言版本的运行引擎。另外需要确保目标电脑上安装的运行引擎版本与开发应用程序时使用的LabVIEW版本一致。如果你想在一台电脑上运行多个版本的LabVIEW生成的可执行程序，那你的电脑必须安装与这些LabVIEW版本一一对应的多个版本的运行引擎。不同版本的LabVIEW运行引擎可以在NI官方网站上免费下载到。
关于硬件驱动
如果您的程序使用了NI硬件的驱动，那么在目标电脑上就需要安装对应版本的驱动程序。以DAQmx为例，比方说您在实现一个数据采集任务时用到了某个版本的DAQmx驱动，将来在目标电脑上就需要安装对应版本的DAQmx驱动。
综上所述，目标电脑上安装LabVIEW运行引擎是必须的，而硬件驱动的安装则取决于您的程序是否有使用该硬件驱动。
准备工作
生成独立可执行程序和安装程序需要用到应用程序生成器，LabVIEW专业开发版包含有应用程序生成器，基础版和完全开发版则需要单独购买。
在生成独立可执行应用程序之前需要做一些检查工作，LabVIEW帮助文档中列出了一个检查列表：http://zone.ni.com/reference/en-XX/help/371361J-01/lvconcepts/build_checklist/
生成应用程序简易步骤
1. 新建一个LabVIEW项目，或者打开一个已经建好的项目，项目中包含了您的vi，确保vi运行正常。一些通过文件路径来使用文件的代码在编译成exe之后可能会出现文件找不到的错误，对于此类错误，可以参考KB：5SD4CE7K,3HKEK93U, 2T6GI6BH, 18RDJ60O新建的项目如图：
2. 在项目浏览器的程序生成规范处右键单击新建》应用程序（exe）
3. 设置目标文件名和目标目录。目标文件名是您将来生成的exe文件名，该文件位于目标目录中，默认的目标目录会在项目所在目录的上一级目录中新建一个builds文件夹，生成的exe文件保存到这个目录中。如图
4. 选择源文件，选中顶层vi单击“添加项”箭头将顶层vi添加到启动vi栏中，其他用到的子vi和文件可以添加到始终包括栏中，如图
5. 可以使用LabVIEW默认图标作为应用程序图标，也可以选择自己设计一个图标：使用图标编辑器编辑并保存自己设计的图标，去掉“使用默认LabVIEW图标文件”前的勾选，在弹出的对话框中选择添加刚才保存的图标文件，注意“图标图像”的类型要与编辑该图标时选择的类型一致，如图
6. 选择预览》生成预览，然后可以看到将来会生成哪些文件，其中就包括我们的独立可执行应用程序，现在还看不到我们自定义的图标，不用着急，最后生成以后就可以看到了，如图
7. 最后选择“生成”，LabVIEW就会弹出生成状态窗口，当生成结束后会提示生成的应用程序所在路径，您可以单击浏览打开应用程序所在目录，然后就可以看到带自定义图标的应用程序了，如果单击完成，则会关闭生成状态窗口，如图
至此，我们已经完成了生成独立可执行应用程序的操作，如果目标电脑上已经安装了LabVIEW运行引擎和其他需要的组件，那么就可以将生成的exe文件拷贝到目标电脑上直接运行了。以下篇幅介绍在生成exe的基础上如何生成installer，即生成安装文件的操作。
生成installer简易步骤
1. 在同一个项目中右键单击程序生成规范，选择新建》安装程序，如图
2. 在“产品信息”中设置您的产品名称和安装程序生成目录，产品名称会影响安装程序所在的路径名，并且对应着在windows添加删除程序列表中应用程序的名字，如图
3. 选择“目标”，修改目标名称，该名称决定了将来安装程序运行结束后，可执行文件会释放到哪个文件夹中，如图
4. 选择“源文件”，在项目文件视图中单击选择之前创建的应用程序生成规范，然后单击添加箭头，将应用程序添加到目标文件夹中，右边目标视图可以看到添加结果，如图
5. 选择“快捷方式”，修改右边的快捷方式名称和子目录名称。快捷方式名称对应着将来在开始菜单中看到的快捷方式图标的名称，子目录对应着快捷方式在开始菜单中所处的文件夹名称，如图
6. 选择“附加安装程序”，勾选相应的LabVIEW运行引擎和必要的驱动程序以及工具包等，之后这些驱动以及工具包会一起包含在生成的installer中。LabVIEW在这里会自动帮您勾选一些必要的NI安装程序，但是有可能并没有包含所有需要安装的程序，您的程序中使用到了哪些驱动以及工具包，在这里配置的时候就需要勾选哪些工具包。对于一些特定的工具包，如NI OPCServers、DSC运行引擎等不支持直接打包部署（KB:5SS56RMQ 56P8BSJT），因此在这里会无法勾选或者勾选无效，这些工具包需要在目标电脑上再单独安装，如果您不能确定该工具包是否支持打包部署，请联系NI技术支持。
7. 单击“生成”按钮开始生成安装程序，同样会弹出一个生成状态窗口，生成过程完成后，单击浏览可以打开安装文件所在路径，您会看到一个setup.exe文件，这个文件就是最终的安装文件。单击“完成”按钮关闭状态窗口。如图
现在，您可以将打包生成好的安装程序拷贝到目标电脑上运行了，需要注意的是，拷贝的时候要将整个文件夹拷贝到目标电脑上然后再运行setup.exe，安装过程与普通windows应用程序没有区别，安装结束后您就可以在目标电脑上运行您自己的应用程序了。
扩展
生成应用程序和安装程序其实有很多地方需要设置，这里只给出了一些最基本的设置，其他设置您可以参考LabVIEW帮助文档中的有关描述，这里给出两个链接：
http://zone.ni.com/reference/en-XX/help/371361J-01/lvhowto/building_a_stand_alone_app/
Using the LabVIEW Run-Time Engine
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6500634695cab7a6c1ce2332488bbe03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e1c6ada266af478fb20fbbc1d0f11b6/" rel="bookmark">
			如何在Caffe中配置每一个层的结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近刚在电脑上装好Caffe，由于神经网络中有不同的层结构，不同类型的层又有不同的参数，所有就根据Caffe官网的说明文档做了一个简单的总结。
1. Vision Layers 1.1 卷积层(Convolution) 类型：CONVOLUTION
例子
layers { name: "conv1" type: CONVOLUTION bottom: "data" top: "conv1" blobs_lr: 1 # learning rate multiplier for the filters blobs_lr: 2 # learning rate multiplier for the biases weight_decay: 1 # weight decay multiplier for the filters weight_decay: 0 # weight decay multiplier for the biases convolution_param { num_output: 96 # learn 96 filters kernel_size: 11 # each filter is 11x11 stride: 4 # step 4 pixels between each filter application weight_filler { type: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e1c6ada266af478fb20fbbc1d0f11b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a73009b3f309497ab7dd974fae7a1c52/" rel="bookmark">
			new出来的service对象和你在spring中注入的service对象不是同一个对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 new出来的service对象和你在spring中注入的service对象不是同一个对象，在spring中service对象到你是赋了值的，但是你new出来的service对象中的dao是没有赋值的。
当然会出问题，你要么就全部注入，不要new ，在实际开发中也不会这样做 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5e89f144b3798801f3c8f7374518e4d/" rel="bookmark">
			Python搜索路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://www.jbxue.com/article/15324.html
在python编程中，模块的导入需要一个叫做"路径搜索"的过程。
即在文件系统"预定义区域"中查找 mymodule.py文件(如果你导入 mymodule 的话)。
这些预定义区域只不过是你的 Python 搜索路径的集合。
默认搜索路径是在编译或是安装时指定的。它可以在一个或两个地方修改。
一个是启动 Python 的 shell 或命令行的 PYTHONPATH 环境变量。 该变量的内容是一组用冒号分割的目录路径。
如果想让解释器使用这个变量, 那么请确保在启动解释器或执行 Python 脚本前设置或修改了该变量。
解释器启动之后, 也可以访问这个搜索路径, 它会被保存在 sys 模块的 sys.path 变量里。
不过它已经不是冒号分割的字符串, 而是包含每个独立路径的列表。
一个 Unix 机器搜索路径的样例。
注意：搜索路径在不同系统下一般是不同的。
复制代码代码示例: &gt;&gt;&gt; sys.path ['', '/usr/local/lib/python2.x/', '/usr/local/lib/python2.x/plat-sunos5', '/usr/local/lib/python2.x/lib-tk', '/usr/local/lib/python2.x/lib-dynload', '/usr/local/lib/Python2.x/site-packages',] 这只是个列表，所以可以随时随地对它进行修改。
如果知道需要导入的模块是什么，而它的路径不在搜索路径里，那么只需要调用列表的 append() 方法即可，就像这样:
sys.path.append('/home/wesc/py/lib')
修改完成后, 即可加载自己的模块了。
转载于:https://www.cnblogs.com/sevenguin/p/4234994.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f10b3e10283fa7effd6ab8054990176/" rel="bookmark">
			Java was started but returned exit code = 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 具体不知道什么原因，电脑有点卡，在我debug的时候， 突然Eclipse不见了，然后发现一个错误信息的框框， 无奈关了重启任然不起效，值得去找解决的办法，经过多次的尝试， 在StackOverflow上找到一个可行的符合我情况的办法： 我的eclipse.ini修改后的配置文件的内容如下： -startup plugins/org.eclipse.equinox.launcher_1.1.0.v20100507.jar --launcher.library plugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.1.1.R36x_v20100810 -product org.eclipse.epp.package.jee.product --launcher.defaultAction openFile --launcher.XXMaxPermSize 256M -showsplash org.eclipse.platform --launcher.XXMaxPermSize 256m -vm C:/xxx/jdk/bin/javaw.exe C:/xxx/jdk/jre/bin/server/jvm.dll --launcher.defaultAction openFile -vmargs -Xms256m -Xmx1024m ---------- 我添加了这一句： C:/xxx/jdk/jre/bin/server/jvm.dll 原文链接地址： http://stackoverflow.com/questions/18609160/eclipse-returns-error-message-java-was-started-but-returned-exit-code-1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/577ca58fbe1117a0597a520d48426d0e/" rel="bookmark">
			Android翻页效果原理实现之曲线的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尊重原创转载请注明：From AigeStudio（http://blog.csdn.net/aigestudio）Power by Aige 侵权必究！
炮兵镇楼
上一节我们通过引入折线实现了页面的折叠翻转效果，有了前面两节的基础呢其实曲线的实现可以变得非常简单，为什么这么说呢？因为曲线无非就是在折线的基础上对Path加入了曲线的实现，进而只是影响了我们的Region区域，而其他的什么事件啊、滑动计算啊之类的几乎都是不变的对吧，说白了就是对现有的折线View进行update改造，虽然是改造，但是我们该如何下手呢？首先我们来看看现实中翻页的效果应该是怎样的呢？如果大家身边有书或本子甚至一张纸也行，尝试以不同的方式去翻动它，你会发现除了我们前面两节曾提到过的一些限制外，还有一些special的现象：
一、翻起来的区域从侧面来看是一个有弧度的区域，如图所示侧面图：
而我们将按照第一节中的约定忽略这部分弧度的表现，因为从正俯视的角度我们压根看不到弧度的效果，So~我们强制让其与页面平行：
二、根据拖拽点距离页面高度的不同，我们可以得到不同的卷曲度：
而其在我们正俯视点的表现则是曲线的弧度不同：
同样的，我们按照第一节的约定，为了简化问题，我们将拖拽点距离页面的高度视为一个定值使在我们正俯视点表现的曲线起点从距离控件交点1/4处开始：
三、如上一节末所说，在弯曲的区域图像也会有相似的扭曲效果
OK，大致的一个分析就是这样，我们根据分析结果可以得出下面的一个分析图：
由上图配合我们上面的分析我们可知：DB = 1/4OB，FA = 1/4OA，而点F和点D分别为两条曲线（如无特殊声明，我们所说的曲线均为贝赛尔曲线，下同）的起点（当然你也可以说是终点无所谓），这时，我们以点A、B为曲线的控制点并以其为端点分别沿着x轴和y轴方向作线段AG、BC，另AG = AF、BC = BD，并令点G、C分别为曲线的终点，这样，我们的这两条二阶贝塞尔曲线就非常非常的特殊，例如上图中的曲线DC，它是由起始点D、C和控制点B构成，而BD = BC，也就是说三角形BDC是的等腰三角形，进一步地说就是曲线DC的两条控制杆力臂相等，进一步地我们可以推断出曲线DC的顶点J必定在直线DC的中垂线上，更进一步地我们可以根据《自定义控件其实很简单5/12》所说的二阶贝塞尔曲线公式得出当且仅当t = 0.5时曲线的端点刚好会在顶点J上，由此我们可以非常非常简单地得到曲线的顶点坐标。好了，YY归YY我们还是要回归到具体的操作中来，首先，我们要计算出点G、F、D、C的坐标值，这四点坐标也相当easy，就拿F点坐标来说，我们过点F分别作OM、AM的垂线：
因为FA = 1/4OA，那么我们可以得到F点的x坐标Fx = a + 3/4MA，y坐标Fy = b + 3/4OM，而G点的x坐标Gx = a + MA - 1/4x；其他两点D、C就不多扯了，那么在代码中如何体现呢？首先，为了便于观察效果，我们先注释掉图片的绘制：
/* * 如果坐标点在原点（即还没发生触碰时）则绘制第一页 */ if (mPointX == 0 &amp;&amp; mPointY == 0) { // canvas.drawBitmap(mBitmaps.get(mBitmaps.size() - 1), 0, 0, null); return; } // 省略大量代码 //drawBitmaps(canvas);并绘制线条： canvas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/577ca58fbe1117a0597a520d48426d0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62df420e64c14d2823cb01234040d844/" rel="bookmark">
			linux下apk签名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 LOCAL_PATH:= $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := 模块名 LOCAL_MODULE_TAGS := optional LOCAL_SRC_FILES := $(LOCAL_MODULE).apk LOCAL_MODULE_CLASS := APPS LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX) LOCAL_CERTIFICATE := platform include $(BUILD_PREBUILT) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada5b9d521044d5e860a7305d68a3ddc/" rel="bookmark">
			【c&#43;&#43;11】override(重写)与final(最终)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include "stdafx.h" #include &lt;iostream&gt; // 标示符含义： // override，表示此虚函数必定“重写”了基类中的对应虚函数。 // final，(1)作用在虚函数：表示此虚函数已处在“最终”状态，后代类必定不能重写这个虚函数。 // (2)作用在类：表示此类必定不能被继承 // 编译器将帮你检查是否“必定” class B1 final {}; // 此类不能被继承 // class D1: public B1 {}; // error! class B { public: // virtual void func() override // error! 指定了重写但实际并没重写,没有基类 // { // std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl; // } virtual void f() const { std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl; } virtual void fun() { std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl; } }; class D : public B { public: virtual void f(int)	// ok!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ada5b9d521044d5e860a7305d68a3ddc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c21b5539100629293c6b261bf6825c3/" rel="bookmark">
			我的开源视音频项目汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文汇总一下自己视音频编解码学习方面的开源项目。这些开源项目大体上可以分成专业领域程序，FFmpeg示例程序，FFmpeg移植程序，多媒体项目示例程序，视音频编解码原理学习工程几个类别。这些类别的详细含义如下所列。 专业领域程序：一些有专业性质的程序。FFmpeg示例程序：FFmpeg的类库的各种示例程序。FFmpeg移植程序：FFmpeg项目中移植到Windows的VC平台下的程序。多媒体项目示例程序：除了FFmpeg之外其他多媒体项目的示例程序。视音频编解码学习工程：用于学习视音频编解码原理的示例程序。 下面按照类别分别记录每个项目。每个程序的介绍分成“简介”，“文章”，“项目主页”三个部分： “简介”使用几句简短的话介绍开源项目。“文章”则是我自己写的有关该项目的文章。“项目主页”则是该项目的主页地址。 此前一直以SourceForge作为各个项目的主页地址。后来受到不少人的建议，将代码在Github上也保存了一份；国内的开源中国的代码托管做的也不错，因此也在开源中国上保存了一份代码。此外，在SourceForge上做了一个简单的Wiki，在Github上做了一个简单的Blog，方便对这两个网站上的项目进行查找和访问。上述三个网站上的项目列表可以通过下列地址访问。 我的SourceForge主页：https://sourceforge.net/u/leixiaohua1020/wiki/我的Github主页：http://leixiaohua1020.github.com/我的开源中国主页：http://git.oschina.net/leixiaohua1020 1. 专业领域程序 专业领域程序指的是主要应用于科学实验方面的程序。这类程序并不是视音频技术开发必须的，主要用于研究工作。
1.1 VideoEye 简介
VideoEye是一个开源的实时视频分析的软件。本软件可以播放和分析视频数据。它支持多种视频流输入方式：HTTP，RTMP，RTSP以及文件等等。该软件可以实时分析视频流并能以图形化的方式呈现其分析结果。
文章
《开源实时视频码流分析软件：VideoEye》
项目主页
SourceForge：https://sourceforge.net/projects/videoeye/
Github：https://github.com/leixiaohua1020/VideoEye
开源中国：http://git.oschina.net/leixiaohua1020/VideoEye
1.2 TIandSI 简介
本工具用于计算视频的时间信息（TI，也称为时间复杂度），以及空间信息（SI，也称为空间复杂度），以上两个指标取自于ITU-R BT.1788标准。
文章
《视频特性TI（时间信息）和SI（空间信息）的计算工具：TIandSI》
《视频特性TI（时间信息）和SI（空间信息）的计算工具：TIandSI-压缩码流版》
项目主页
SourceForge：https://sourceforge.net/projects/tiandsi/
Github：https://github.com/leixiaohua1020/TIandSI
开源中国：http://git.oschina.net/leixiaohua1020/TIandSI
2. FFmpeg示例程序 FFmpeg示例程序是我做的最多的一类程序。这些示例程序展示了利用FFmpeg的类库进行视音频程序开发的方法，比较适合新手学习FFmpeg。目前这些示例程序已经覆盖了从流媒体接收，解封装，解码，像素转换，编码，封装，流媒体发送所有这些流程。
FFmpeg示例程序在视频处理的流程中的位置如下图所示。 单击查看更清晰的图片
图中显示了一个完整的视频处理流程。按照蓝色箭头指向的顺序，从外部协议接收下来的数据依次经过解协议，解封装，解码，像素转换，编码，封装，发送这几个步骤。这些步骤按照处理数据类型的不同，可以分成几个层次： 协议层（Protocol Layer）：该层处理的数据为符合特定流媒体协议规范的数据，例如http，rtmp，file等。封装层（Format Layer）：该层处理的数据为符合特定封装格式规范的数据，例如mkv，mp4，flv，mpegts，avi等。编码层（Codec Layer）：该层处理的数据为符合特定编码标准规范的数据，例如h264，h265，mpeg2，mpeg4等。像素层（Pixel Layer）：该层处理的数据为符合特定像素格式规范的数据，例如yuv420p，yuv422p，yuv444p，rgb24等。 下面我们上述几个层次对FFmpeg示例程序进行归类。
协议层处理包含以下项目：
simplest ffmpeg device：使用FFmpeg读取设备中的媒体数据。simplest ffmpeg mem handler：使用FFmpeg读取内存中的数据。simplest ffmpeg streamer：使用FFmpeg发送流媒体数据。 封装层处理包含以下项目：
simplest ffmpeg format：使用FFmpeg分离音视频（demux），封装音视频（mux），转换封装格式（remux）。 编码层处理包含以下项目：
simplest ffmpeg player：使用FFmpeg解码播放视频数据。simplest ffmpeg audio player：使用FFmpeg解码播放音频数据。simplest ffmpeg video encoder：使用FFmpeg编码视频数据。simplest ffmpeg audio encoder：使用FFmpeg编码音频数据。simplest ffmpeg picture encoder：使用FFmpeg编码图片。 像素层处理包含以下项目：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c21b5539100629293c6b261bf6825c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b470fbe3b1832e639edf2b011f6b61e/" rel="bookmark">
			资源网址合集的合集，上千个链接！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.分享一百多套开发视频教程的下载地址
http://www.cnblogs.com/dennisit/p/3184225.html
2.下载频道2013下半年超人气精华资源汇总---全都是免积分下载。
http://bbs.csdn.net/topics/390674613
3. 25个可遇不可求的jQuery插件
http://www.csdn.net/article/2014-03-14/2818765-best-free-jquery-plugins
4.andorid实例源码地址分享（一）
http://blog.csdn.net/tkwdmylove/article/details/23607273
4.各种视频教程，有空下来看看
http://blog.csdn.net/joy32812/article/details/6770087
6.来源csdn，上面的资源都可以下载。 http://www.yuyueqianli.com/read.php?tid=693
7.最强开发资源平台大合集
http://1249164263.iteye.com/blog/2172273
转载于:https://www.cnblogs.com/yjhkhnuje/p/4208851.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14a526a1968f96a81081d85039539766/" rel="bookmark">
			js模块化例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在看一本书，里面提到js的模块化，觉得很有必要，所以记录下来
Game.js
/*** This is the main class that handles the game life cycle. It initializes* other components like Board and BoardModel, listens to the DOM events and* translates clicks to coordinates.* @param canvas the canvas object to use for drawing*/function Game(canvas) {this._boardRect = null;this._canvas = canvas;this._ctx = canvas.getContext("2d");this._boardModel = new BoardModel();//实例化类this._boardRenderer = new boardRenderer(this._ctx, this._boardModel);this.handleResize();}_h = Game.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14a526a1968f96a81081d85039539766/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13e5dd55a4d7a0cc654f8ea7e6584f0a/" rel="bookmark">
			php curl getinfo的时间分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在php中可以使用curl调用远程接口，在调用完成以后， 能够获取相关的内容和信息，但有时候， 我们需要统计这个调用过程的时间， 尤其是在使用curl做并发测试的时候，这个统计就尤为重要，针对其中关于时间的几个统计项，在curl中给出的中文解释非常模糊， 且网上针对这方面的资源并不好找，我在这里做个说明。
图示 图解 1： 在curl中的几个比较重要的时间范围都已标记出来，如有错误，希望能够指正。
namelookup_time: 解析时间， 从开始直到解析完远程请求的时间；
connect_time: 建立连接时间,从开始直到与远程请求服务器建立连接的时间；
pretransfer_time: 从开始直到第一个远程请求接收到第一个字节的时间；
starttranster_time: 从开始直到第一个字节返回给curl的时间；
total_time： 从开始直到结束的所有时间。
2： 从上面就能很容易得到不同阶段的时间， 比如实际的远程服务器的处理数据的时间可以用starttransfer_time - pretransfer_time计算得到， 即图示中的第4个小段的时间， 若想得到本地与服务器传输数据所消耗的时间，则把时间段2与时间段5做加法即可， 而时间段2和5均很容易得到。
其他的两个时间：
1： redirect_time: 假如远程请求中又包含了重定向， 那么从开始直到重定向完成之后的那个远程请求的starttransfer_time就是这个时间(如有错误，请指正);
2:　file_time: 远程获取文档的时间，如果无法获取，则返回值为“-1”；
PS:这两种时间均未做过实践，如果有知道的，欢迎讨论
参考：
curl_easy_getinfo
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da1c40e5c3f75171d6dc5dc3e80d9bfb/" rel="bookmark">
			c&#43;&#43;中 const修饰指针的理解与记忆法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 经常混淆c++中的const修饰指针的作用，今天看到一个blog说的很好”以*为界，左物右指“，因此转载过来当笔记。
当使用带有指针的const时，有两种选择：1、或者const修饰指针正指向的对象，2、const修饰存储在指针本身的地址。 1 指向const的指针 使用指针定义的技巧，正如任何复杂的定义一样，是在标识符的开始处读它并从里到外读。如果我们要使正指向的元素不发生改变，得写： const int * x; 从标识符开始：“x 是一个指针，指向一个const int。” 把const从一边移到另一边，结果一样。 int const * x; 2 cosnt指针 是指针本身成为一个const指针，必须把const标明的部分放在*的右边，如： int d = 1; int * const x = &amp;d; 指针本身是const指针，编译器要求给它一个初始化值，这个值在指针寿命期间不变。然而要改变它所指向的值是可以的，可以写*x = 2。 这些可以总结成这样一句话: 以*为分界点, 当const在*的左边时,实际物体值不变 当const在*的右边时,指针不变, 即, 左物右指 这样来记比较方便！！ [转载自： http://laokaddk.blog.51cto.com/368606/216630/] ----------------------------------------------------------------------------------------------- 个人补充： const char * pc;中的pc变量可以指向非const的char 变量；但pc却不可以赋值给char *的变量（道理很显然）。 我之所以提到该话，是因为我们经常会有一个参数进过几层函数传递，这样的话，要注意指针的const的统一。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88252f2f27c4a3190d965dd2eb025529/" rel="bookmark">
			最简单的基于FFmpeg的编码器-纯净版（不包含libavformat）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		=====================================================
最简单的基于FFmpeg的视频编码器文章列表：
最简单的基于FFMPEG的视频编码器（YUV编码为H.264）
最简单的基于FFmpeg的视频编码器-更新版（YUV编码为HEVC(H.265)）
最简单的基于FFmpeg的编码器-纯净版（不包含libavformat）
=====================================================
本文记录一个更加“纯净”的基于FFmpeg的视频编码器。此前记录过一个基于FFmpeg的视频编码器：
《最简单的基于FFmpeg的视频编码器-更新版（YUV编码为HEVC(H.265)）》
这个视频编码器调用了FFmpeg中的libavformat和libavcodec两个库完成了视频编码工作。但是这不是一个“纯净”的编码器。上述两个库中libavformat完成封装格式处理，而libavcodec完成编码工作。一个“纯净”的编码器，理论上说只需要使用libavcodec就足够了，并不需要使用libavformat。本文记录的编码器就是这样的一个“纯净”的编码器，它仅仅通过调用libavcodec将YUV数据编码为H.264/HEVC等格式的压缩视频码流。
流程图 仅使用libavcodec（不使用libavformat）编码视频的流程如下图所示。
流程图中关键函数的作用如下所列：
avcodec_register_all()：注册所有的编解码器。 avcodec_find_encoder()：查找编码器。 avcodec_alloc_context3()：为AVCodecContext分配内存。 avcodec_open2()：打开编码器。 avcodec_encode_video2()：编码一帧数据。 两个存储数据的结构体如下所列： AVFrame：存储一帧未编码的像素数据。 AVPacket：存储一帧压缩编码数据。 对比 简单记录一下这个只使用libavcodec的“纯净版”视频编码器和使用libavcodec+libavformat的视频编码器的不同。
PS：使用libavcodec+libavformat的编码器参考文章 《最简单的基于FFmpeg的视频编码器-更新版（YUV编码为HEVC(H.265)）》
（1） 下列与libavformat相关的函数在“纯净版”视频编码器中都不存在。 av_register_all()：注册所有的编解码器，复用/解复用器等等组件。其中调用了avcodec_register_all()注册所有编解码器相关的组件。 avformat_alloc_context()：创建AVFormatContext结构体。 avformat_alloc_output_context2()：初始化一个输出流。 avio_open()：打开输出文件。 avformat_new_stream()：创建AVStream结构体。avformat_new_stream()中会调用avcodec_alloc_context3()创建AVCodecContext结构体。 avformat_write_header()：写文件头。 av_write_frame()：写编码后的文件帧。 av_write_trailer()：写文件尾。 （2） 新增了如下几个函数 avcodec_register_all()：只注册编解码器有关的组件。 avcodec_alloc_context3()：创建AVCodecContext结构体。
可以看出，相比于“完整”的编码器，这个纯净的编码器函数调用更加简单，功能相对少一些，相对来说更加的“轻量”。
源代码 /** * 最简单的基于FFmpeg的视频编码器（纯净版） * Simplest FFmpeg Video Encoder Pure * * 雷霄骅 Lei Xiaohua * leixiaohua1020@126.com * 中国传媒大学/数字电视技术 * Communication University of China / Digital TV Technology * http://blog.csdn.net/leixiaohua1020 * * 本程序实现了YUV像素数据编码为视频码流（H264，MPEG2，VP8等等）。 * 它仅仅使用了libavcodec（而没有使用libavformat）。 * 是最简单的FFmpeg视频编码方面的教程。 * 通过学习本例子可以了解FFmpeg的编码流程。 * This software encode YUV420P data to video bitstream * (Such as H.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88252f2f27c4a3190d965dd2eb025529/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cb658ae4c85d16b24fa664968de8fca/" rel="bookmark">
			bmp转jpg（使用libjpeg）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接： ﻿﻿ http://www.cnblogs.com/tiandsp/archive/2012/12/03/2799561.html
jpg压缩原理可以参考这篇文章http://hi.baidu.com/tiandsp/item/f5a2dcde6ef1405bd73aae41，我很早以前转的一篇文章。
没有使用libjpeg的压缩代码可以看看这篇文章http://hi.baidu.com/tiandsp/item/9b5843c58a3b4474cfd4f841，也是我很早以前转的。
这次使用libjpeg库压缩和上一篇的解压正好对应起来，有好多函数名称我都是对称的起的，所以结合起来看效果更好。
和上一篇一样，只能处理24位和8位的图像。
代码如下：
#include &lt;iostream&gt; #include &lt;stdio.h&gt; extern "C"{ #include "jpeglib.h" }; #pragma comment(lib,"jpeg.lib") using namespace std; #pragma pack(2) //两字节对齐，否则bmp_fileheader会占16Byte struct bmp_fileheader { unsigned short bfType; //若不对齐，这个会占4Byte unsigned long bfSize; unsigned short bfReverved1; unsigned short bfReverved2; unsigned long bfOffBits; }; struct bmp_infoheader { unsigned long biSize; unsigned long biWidth; unsigned long biHeight; unsigned short biPlanes; unsigned short biBitCount; unsigned long biCompression; unsigned long biSizeImage; unsigned long biXPelsPerMeter; unsigned long biYpelsPerMeter; unsigned long biClrUsed; unsigned long biClrImportant; }; FILE *input_file; FILE *output_file; struct bmp_fileheader bfh; struct bmp_infoheader bih; unsigned char *src_buffer; unsigned char *dst_buffer; void read_bmp_header() { fread(&amp;bfh,sizeof(struct bmp_fileheader),1,input_file); fread(&amp;bih,sizeof(struct bmp_infoheader),1,input_file); } void read_bmp_data() { fseek(input_file,bfh.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cb658ae4c85d16b24fa664968de8fca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efaf5c526ed34d7e7059b0d1aac47a56/" rel="bookmark">
			delphi中VirtualStringTree树使用方法之终结篇！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; delphi中VirtualStringTree树使用方法之终结篇
delphi中VirtualStringTree树使用方法之终结篇！
2011-07-01 14:06
VirtualStringTree 的用法详解：
作者：张志宝go淘宝
例子：创建了一个树名为VirtualStringTree1，第一列显示数据库字段ID的值，标题为编号；第二列显示字段Name的值，标题为名字。
一、【TVirtualStringTree常用属性】
BorderStyle :设置边框选项 bsSingle设置单边框
为TVirtualStringTree添加列及列标题： Header--Columns : 设置列 点击“…”，在弹出界面点击add new按钮，就增加一列，在其text中输入列名,在width输入列宽度；
Header--options-hovisible: 设置列可显示！！ Header-Style :设置树的主题类型
ScrollBaroptions--AlwaysVisible 滚动条是否总是可见
ScrollBarOptions-ScrollBars-ssVertical 设置为只有竖向滚动条
为TVirtualStringTree添加勾选框、选择框、复选框：
TreeOptions----MiscOpitions---toCheckSupport 设置为True即可
CheckImageKind 为勾选框设置图标
Header-Maincolumn 设置勾选框在第几列前面，默认为0也就是在第一列前面
并设置ongettext()事件和onInitailNode()事件，见下面事件部分。
--------------------------------------------------------------------------------------------------------------------------------------------
二、 【TVirtualStringTree常用方法 】 VirtualStringTree1.NodeDataSize := sizeOf(TMyNodeData); //设置占存储空间大小
树节点选中：VirtualStringTree1.Selected[p_node]True; //设置节点p_node处于选中状态
树节点勾选框选中:p_node.CheckState:=cscheckedNormal;//设置节点p_node处于勾选状态
onchecked()事件：设置节点勾选时触发的事件，其中第二个参数就是勾选的节点
取消选中的节点：VirtualStringTree1.ClearSelection;
树节点删除: VirtualStringTree1.DeleteSelectedNodes; //删除选中的节点
树节点内容清空：VirtualStringTree1.clear;
得到树的第一个节点:VirtualStringTree1.GetFirst;
得到树的第一个选中节点：VirtualStringTree1.GetFirstSelected;
得到节点的下一个节点:VirtualStringTree1.Getnext(p_node);
得到下一个选中的节点:VirtualStringTree1.GetNextSelected(p_node);
得到父节点:p_node.Parent
得到子节点个数:p_node.ChildCount
得到第一个子节点：p_node.FirstChild
得到最后一个子节点：p_node.FirstChild
得到上一个兄弟节点：p_node.PrevSibling
得到下一个兄弟节点：p_node.NextSibling
---------------------------------------------------------------------------------------------------------------------------
三、【TVirtualStringTree显示数据库字段内容】：
//定义一个指针
type
Tjdtransline =record
id: integer; //编号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efaf5c526ed34d7e7059b0d1aac47a56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2198f420887f20b2de538d50e356c0b/" rel="bookmark">
			Python 对象的引用计数和拷贝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 对象的引用计数和拷贝 Python是一种面向对象的语言，包括变量、函数、类、模块等等一切皆对象。
在python中，每个对象有以下三个属性：
1、id，每个对象都有一个唯一的身份标识自己，可通过内建函数id(obj)查看。
2、type，对象的类型决定了该对象可以保存什么类型的值，可用内建函数type(obj)查看；
3、value，即对象的值。
下面是一个例子：
&gt;&gt;&gt; str = "hello world" &gt;&gt;&gt; type(str) &lt;type 'str'&gt; &gt;&gt;&gt; id(str) 139840619053776 &gt;&gt;&gt; str2="hello world" &gt;&gt;&gt; id(str2) 139840619053888 &gt;&gt;&gt; str == str2 True &gt;&gt;&gt; str is str2 False &gt;&gt;&gt; 注意：id()函数返回一个数字，不同的对象的id值不一样，即使他们值一样。
同时也可以看出，关系运算符 "==" 比较的是两个对象的值是否相等，而 is 比较的是两个变量是否为同一个对象（或者说指向同一块内存）。
还有一个内建函数cmp，也可用于比较两个对象的值，它返回的是一个int值，例如：
&gt;&gt;&gt; cmp("abc", "bcd") -1 &gt;&gt;&gt; cmp(7,7) 0 &gt;&gt;&gt; cmp(7,9) -1 &gt;&gt;&gt; cmp(19,9) 1 再来看下面这个有趣的现象：
&gt;&gt;&gt; a = [4] &gt;&gt;&gt; b = [4] &gt;&gt;&gt; a is b False &gt;&gt;&gt; a = 1 &gt;&gt;&gt; b = 1 &gt;&gt;&gt; a is b True 可见，对两个变量赋予相同的值，它们有可能是同一个对象（对不可变对象而言，可以节省内存），也可能是两个不同的对象，这可能取决于对象的类型（type）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2198f420887f20b2de538d50e356c0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b05d4e19d461bdc3ad8880b415f458f5/" rel="bookmark">
			最简单的基于librtmp的示例：发布H.264（H.264通过RTMP发布）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		=====================================================
最简单的基于libRTMP的示例系列文章列表：
最简单的基于librtmp的示例：接收（RTMP保存为FLV）
最简单的基于librtmp的示例：发布（FLV通过RTMP发布）
最简单的基于librtmp的示例：发布H.264（H.264通过RTMP发布）
=====================================================
本文记录一个基于libRTMP的发布H.264码流的程序。该程序可以将H.264数据发布到RTMP流媒体服务器。目前这个例子还不是很稳定，下一步还有待修改。
本程序使用回调函数作为输入，通过自定义的回调函数，可以发送本地的文件或者内存中的数据。
函数调用结构图 本程序的函数调用结构图如下所示。
整个程序包含3个接口函数： RTMP264_Connect()：建立RTMP连接。 RTMP264_Send()：发送数据。 RTMP264_Close()：关闭RTMP连接。 按照顺序调用上述3个接口函数就可以完成H.264码流的发送。 结构图中关键函数的作用如下所列。 RTMP264_Connect()中包含以下函数： InitSockets()：初始化Socket RTMP_Alloc()：为结构体“RTMP”分配内存。 RTMP_Init()：初始化结构体“RTMP”中的成员变量。 RTMP_SetupURL()：设置输入的RTMP连接的URL。 RTMP_EnableWrite()：发布流的时候必须要使用。如果不使用则代表接收流。 RTMP_Connect()：建立RTMP连接，创建一个RTMP协议规范中的NetConnection。 RTMP_ConnectStream()：创建一个RTMP协议规范中的NetStream。 RTMP264_Send()中包含以下函数： ReadFirstNaluFromBuf()：从内存中读取出第一个NAL单元。 ReadOneNaluFromBuf()：从内存中读取出一个NAL单元。 h264_decode_sps()：解码SPS，获取视频的宽，高，帧率信息。 SendH264Packet()：发送一个NAL单元。 SendH264Packet()中包含以下函数： SendVideoSpsPps()：如果是关键帧，则在发送该帧之前先发送SPS和PPS。 SendPacket()：组装一个RTMPPacket，调用RTMP_SendPacket()发送出去。 RTMP_SendPacket()：发送一个RTMP数据RTMPPacket。 RTMP264_Close()中包含以下函数： RTMP_Close()：关闭RTMP连接。 RTMP_Free()：释放结构体“RTMP”。 CleanupSockets()：关闭Socket。 源代码 程序提供的3个接口函数的使用方法如下。可以看出接口比较简单。
/** * Simplest Librtmp Send 264 * * 雷霄骅，张晖 * leixiaohua1020@126.com * zhanghuicuc@gmail.com * 中国传媒大学/数字电视技术 * Communication University of China / Digital TV Technology * http://blog.csdn.net/leixiaohua1020 * * 本程序用于将内存中的H.264数据推送至RTMP流媒体服务器。 * This program can send local h264 stream to net server as rtmp live stream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b05d4e19d461bdc3ad8880b415f458f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98ee17124ed2c2e7cde9c48ad4f57f4c/" rel="bookmark">
			Android 实现多个输入框的对话框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		布局： &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="vertical" &gt; &lt;TextView android:id="@+id/textView1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="姓名" /&gt; &lt;EditText android:id="@+id/editTextName" android:layout_width="match_parent" android:layout_height="wrap_content" &gt; &lt;requestFocus /&gt; &lt;/EditText&gt; &lt;TextView android:id="@+id/textView2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="电话号码" /&gt; &lt;EditText android:id="@+id/editTextNum" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;/LinearLayout&gt; &lt;pre name="code" class="java"&gt;代码： protected void showAddDialog() { LayoutInflater factory = LayoutInflater.from(this); final View textEntryView = factory.inflate(R.layout.dialog, null); final EditText editTextName = (EditText) textEntryView.findViewById(R.id.editTextName); final EditText editTextNumEditText = (EditText)textEntryView.findViewById(R.id.editTextNum); AlertDialog.Builder ad1 = new AlertDialog.Builder(FriendActivity.this); ad1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98ee17124ed2c2e7cde9c48ad4f57f4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb07fed6a4d0663b0324be1fe243023a/" rel="bookmark">
			最简单的基于librtmp的示例：发布（FLV通过RTMP发布）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		=====================================================
最简单的基于libRTMP的示例系列文章列表：
最简单的基于librtmp的示例：接收（RTMP保存为FLV）
最简单的基于librtmp的示例：发布（FLV通过RTMP发布）
最简单的基于librtmp的示例：发布H.264（H.264通过RTMP发布）
=====================================================
本文记录一个基于libRTMP的发布流媒体的程序：Simplest libRTMP Send FLV。该程序可以将本地FLV文件发布到RTMP流媒体服务器。是最简单的基于libRTMP的流媒体发布示例。
流程图 使用librtmp发布RTMP流的可以使用两种API：RTMP_SendPacket()和RTMP_Write()。使用RTMP_SendPacket()发布流的时候的函数执行流程图如下图所示。使用RTMP_Write()发布流的时候的函数执行流程图相差不大。 流程图中关键函数的作用如下所列：
InitSockets()：初始化Socket RTMP_Alloc()：为结构体“RTMP”分配内存。 RTMP_Init()：初始化结构体“RTMP”中的成员变量。 RTMP_SetupURL()：设置输入的RTMP连接的URL。 RTMP_EnableWrite()：发布流的时候必须要使用。如果不使用则代表接收流。 RTMP_Connect()：建立RTMP连接，创建一个RTMP协议规范中的NetConnection。 RTMP_ConnectStream()：创建一个RTMP协议规范中的NetStream。 Delay：发布流过程中的延时，保证按正常播放速度发送数据。 RTMP_SendPacket()：发送一个RTMP数据RTMPPacket。 RTMP_Close()：关闭RTMP连接。 RTMP_Free()：释放结构体“RTMP”。 CleanupSockets()：关闭Socket。 源代码源代码中包含了使用两种API函数RTMP_SendPacket()和RTMP_Write()发布流媒体的源代码，如下所示。 /** * Simplest Librtmp Send FLV * * 雷霄骅，张晖 * leixiaohua1020@126.com * zhanghuicuc@gmail.com * 中国传媒大学/数字电视技术 * Communication University of China / Digital TV Technology * http://blog.csdn.net/leixiaohua1020 * * 本程序用于将FLV格式的视音频文件使用RTMP推送至RTMP流媒体服务器。 * This program can send local flv file to net server as a rtmp live stream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb07fed6a4d0663b0324be1fe243023a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc9785a27652d2b15b75447763a77586/" rel="bookmark">
			交叉编译libupnp，make时提示libtool: eval: line 944: syntax error near unexpected token `|&#39;的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编译libupnp时，make后，提示错误 "../libtool: eval: line 944: syntax error near unexpected token `|'"
解决方法：
1、export NM= arm-xxx-nm
2、./configure CC=arm-xx-gcc --prefix=libupnp_install --host=arm-linux
3、make
4、make install
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8117e9dd73e19337606aa3831d10005c/" rel="bookmark">
			最简单的基于librtmp的示例：接收（RTMP保存为FLV）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		=====================================================
最简单的基于libRTMP的示例系列文章列表：
最简单的基于librtmp的示例：接收（RTMP保存为FLV）
最简单的基于librtmp的示例：发布（FLV通过RTMP发布）
最简单的基于librtmp的示例：发布H.264（H.264通过RTMP发布）
=====================================================
本文记录一个基于libRTMP的接收流媒体的程序：Simplest libRTMP Receive。该程序可以将RTMP流保存成本地FLV文件。实际上本文记录的程序就是一个“精简”过的RTMPDump。RTMPDump功能比较多，因而其代码比较复杂导致很多初学者不知从何下手。而本文记录的这个程序只保留了RTMPDump中最核心的函数，更加方便新手入门学习libRTMP。
流程图使用librtmp接收RTMP流的函数执行流程图如下图所示。 流程图中关键函数的作用如下所列： InitSockets()：初始化Socket RTMP_Alloc()：为结构体“RTMP”分配内存。 RTMP_Init()：初始化结构体“RTMP”中的成员变量。 RTMP_SetupURL()：设置输入的RTMP连接的URL。 RTMP_Connect()：建立RTMP连接，创建一个RTMP协议规范中的NetConnection。 RTMP_ConnectStream()：创建一个RTMP协议规范中的NetStream。 RTMP_Read()：从服务器读取数据。 RTMP_Close()：关闭RTMP连接。 RTMP_Free()：释放结构体“RTMP”。 CleanupSockets()：关闭Socket。 其中NetStream和NetConnection是RTMP协议规范中的两个逻辑结构。NetStream建立在NetConnection之上。一个NetConnection可以包含多个NetStream。它们之间的关系如下图所示。 源代码 /** * Simplest Librtmp Receive * * 雷霄骅，张晖 * leixiaohua1020@126.com * zhanghuicuc@gmail.com * 中国传媒大学/数字电视技术 * Communication University of China / Digital TV Technology * http://blog.csdn.net/leixiaohua1020 * * 本程序用于接收RTMP流媒体并在本地保存成FLV格式的文件。 * This program can receive rtmp live stream and save it as local flv file. */ #include &lt;stdio.h&gt; #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8117e9dd73e19337606aa3831d10005c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/556/">«</a>
	<span class="pagination__item pagination__item--current">557/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/558/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>