<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cc5adc81b6d3c1c5f9d9db5a4723202/" rel="bookmark">
			AI换脸项目faceswap研究报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缘起
deepfakes是利用AI技术换脸的开源项目，目前基于deepfakes的开源项目很多，而faceswap认可度很高，到目前为止有28.5千Star，可以说是换脸这类项目最火的了。小弟在当下有换脸需求，选取了这个项目进行研究尝试，将自己的经验和体会记录下来，希望对你有所帮助！
感谢公司、领导、一切关心支持我的人！
效果
先上一些效果，增加一些趣味性！
官方换脸效果1
官方效果2，小扎在国会舌战群儒的场景
第一次尝试换脸，演讲者左右换姿势，似乎是为不冷落两边的观众
另外一个换脸后的效果
尝试了很多此换脸，不在此一一列举。
+++++++++++++++++++++++
准备
需要一块好的nvidia显卡，最低是1080或以上，众所周知，机器学习是费时的，一块好的显卡可以帮助你节省大量的时间，我用的机器配置了4块TITAN xp显卡，这个项目训练时大部分小弟用到其中两张显卡，在训练villain模型时，用到了其中三张，villain很吃显存，基本上一天可以训练出一个比较清晰的模型。
如果只有CPU，我建议还是放弃尝试，据说训练时间是以周为单位的，训练出一个结果，可能需要数周，那就需要极大的耐性。训练中你机器CPU100%的被烧数周，不能干其他事情。而训练一个模型可能并不让人满意，每次调整参数，又的继续等待数周。大概你周游完欧洲各国后，回家一看结果还没出来！
如果在linux上运行程序，需要一些ffmpeg知识、一些shell脚本经验
该项目在windows上可以直接运行图形，我只有ssh命令行连接的ubuntu服务器，所以自己写了写脚本来处理，很羡慕GUI版本
后来突然领悟可以在我的mac笔记本上运行图形界面，用来查看配置选项。
图形界面是这样：
能运行图形界面操作起来更方便，但是如果像我一样在服务器上通过ssh登陆，也无妨。
在本地调整好参数，同步到服务器上就行啦。
安装好CUDA 10.0 和 anaconda，这个到处都是教程，在此不累叙。
安装faceswap
下载项目https://github.com/deepfakes/faceswap
需要注意的是这个项目经常更新，有时可能不稳定，所以我clone了一份在自己的github里https://github.com/hnjiakai/faceswap ，幸运的是我用clone的这个版本，训练和转换等整个过程都很顺利，没有出现论坛里讨论的各种奇奇怪怪的问题。
1、利用conda创建好运行faceswap的虚拟环境
conda create -n face tensorflow=1.14 python=3.6
2、切换到虚拟环境
conda activate face 3、安装依赖环境
pip -r requirements.txt
conda install opencv 这些其实已经完整99%的安装，剩下1%用到时提示缺少可以用conda install xxx安装。详细的安装过程可以参照https://github.com/deepfakes/faceswap/blob/master/INSTALL.md
人脸资源准备
A人脸，以后简称A脸，从需要变脸的视频中得到，我用ffmpeg将视频A转换成图片到A-src文件夹，然后利用faceswap抽取人脸到A-desc文件夹为后续训练做准备。
B人脸，以后简称B脸，从另外一个视频中得到，同样用ffmpeg抽取帧B-src文件夹，然后利用faceswap抽取人脸到B-desc文件夹。
抽取的配置图：
抽取人脸的配置截图中，红框部分做调整就可以，其他默认就OK
1++++抽取帧的ffmpeg命令
ffmpeg -i a_movie.mp4 -qscale:v 2 -f image2 -r 1 zhubo-src/img_%d.jpg
更多ffmpeg用法请看https://blog.csdn.net/jiakai82/article/details/103288726
2++++利用faceswap抽取人脸图片
A脸提取
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cc5adc81b6d3c1c5f9d9db5a4723202/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/539c842ff08cfb496b5a9fdd974f9bf3/" rel="bookmark">
			通过SNMP查询交换机的MAC表以及核心交换机的ARP表，实现查询对应关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过SNMP查询交换机的MAC表以及核心交换机的ARP表，实现查询对应关系 通过SNMP查询交换机的MAC表以及核心交换机的ARP表，实现查询对应关系，这样就可以实现后面我们要的功能了，无论是查询IP的MAC，接在什么交换机的什么口，还是去匹配机房里异常的进入设备，后面可以加上集成MSSQL数据库，在表里加上每个MAC的所有历史记录，比如什么时候接入交换机，什么时候换到另外的交换机的哪个口。
下载并引用
SnmpSharpNet.dll
https://download.csdn.net/download/chscomfaner/12094545
先打开交换机的SNMP，打开方法：
#snmp-server community public ro #配置本路由器的只读字串为public #snmp-server community public rw #配置本路由器的读写字串为public App.config
&lt;?xml version="1.0" encoding="utf-8" ?&gt; &lt;configuration&gt; &lt;appSettings&gt; &lt;add key="community" value="public"/&gt; &lt;add key="sw" value="192.168.10.200"/&gt; &lt;add key="router" value="192.168.10.1"/&gt; &lt;/appSettings&gt; &lt;/configuration&gt; Programs.cs
using System; using System.Collections.Generic; using System.Configuration; using System.Linq; using System.Text; using System.Threading; namespace SNMP_SW { class Program { static object locker=new object(); static List&lt;SW&gt; allSW=new List&lt;SW&gt;(); static List&lt;Router&gt; allRouter = new List&lt;Router&gt;(); static void Main(string[] args) { //扫描交换机 string[] sws = ConfigurationManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/539c842ff08cfb496b5a9fdd974f9bf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a14a1d521acba4dab1c94f165267105f/" rel="bookmark">
			泛微E9 流程 独立选择框对应数据库表 查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select * from workflow_SelectItem where fieldid=8815 order by selectvalue
流程 独立选择框对应数据库表：workflow_SelectItem
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/045a88df0acd44416e3f15b2be8c2958/" rel="bookmark">
			C#执行系统命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来自森大科技官方博客
http://www.cnsendblog.com/index.php/?p=266
GPS平台、网站建设、软件开发、系统运维，找森大网络科技！
http://cnsendnet.taobao.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ba1a05bf453a1babd575099d47a813d/" rel="bookmark">
			支付宝 app应用 授权  php &#43; APICloud
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		app应用授权 怎么处理 支付宝官方文档 https://docs.open.alipay.com/218/105325
APICloud 文档 https://docs.apicloud.com/Client-API/Open-SDK/aliPayTradePlus#a5
根据文档整理了 php 的代码 仅供参考 获取 授权数据信息 极简版授权请求参数和返回
apiname=com.alipay.account.auth&amp;app_id=2016051801417322&amp;app_name=mc&amp;auth_type=AUTHACCOUNT&amp;biz_type=openservice&amp;method=alipay.open.auth.sdk.code.get&amp;pid=2088221932028920&amp;product_id=APP_FAST_LOGIN&amp;scope=auth_user&amp;sign_type=RSA&amp;target_id=61ef37122e104d148c855d14e9bf90e2&amp;sign=m6K7Dz4CxPAgLn2uwIjGSmgRcOBYtHcqaYqLc85/C6PCqoIu6tUHDmx5/hb0xy+dMCdQoFcQWKRGzBl040g/6avD/PhOUSUi9Cmtd2HxSzEEjk7LuFn9QrpAmcM7/tub+K/G/2rQp9ce8FY2RCbJ/sFDA09M5B+2gqzy9Qkc5fE=
/** *获取授权数据 */ public function get_auth_data(){ $appid = '1111'; // 商户账号appid $sign_type = 'RSA2'; $targetId = mt_rand(000000,999999);//此处随机获取 $data = [ 'apiname'=&gt;'com.alipay.account.auth', 'method'=&gt;'alipay.open.auth.sdk.code.get', 'app_id'=&gt;$appid,//支付宝分配给开发者的应用ID 'app_name'=&gt;'mc', 'biz_type'=&gt;'openservice', 'pid'=&gt;'11111',//签约的支付宝账号对应的支付宝唯一用户号，以2088开头的16位纯数字组成 登录你的支付宝 用户信息中 可以找到 'product_id'=&gt;'APP_FAST_LOGIN', //标识授权类型，取值范围：AUTHACCOUNT代表授权；LOGIN代表登录 'scope'=&gt;'kuaijie', 'target_id'=&gt;$targetId, //商户标识该次用户授权请求的ID，该值在商户端应保持唯一 'auth_type'=&gt;'AUTHACCOUNT',//授权类型 AUTHACCOUNT:授权 LOGIN:登录 'sign_type'=&gt;$sign_type,//签名算法类型 ]; //读取配置信息 $aop = new \AopClient; $aop-&gt;gatewayUrl = "https://openapi.alipay.com/gateway.do"; $aop-&gt;appId = '1111111';//支付宝分配给开发者的应用ID $aop-&gt;rsaPrivateKey = '1111111';//支付宝私钥 $aop-&gt;format = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ba1a05bf453a1babd575099d47a813d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd92e5b053e8cf2a657e5ca1bb9511bb/" rel="bookmark">
			java 线程池详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要使用线程池？
为了减少资源的开销，提高系统性能先创建好线程，如果需要使用从池中取，提高利用率控制线程数量，防止程序崩溃 Java 中创建线程池的两种方式？
使用ThreadPoolExecutor类使用Executors类 其实这两种方式在本质上是一种方式，都是通过ThreadPoolExecutor类的方式
一、ThreadPoolExecutor的方式 1、使用方法 查看JDK的源码，ThreadPoolExecutor类提供了以下构造方法
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) { this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); } public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) { this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler); } public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) { this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd92e5b053e8cf2a657e5ca1bb9511bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a6c345b5327e512b4d13cccb44030d8/" rel="bookmark">
			拉格朗日方程的三种推导方法之基于欧拉-拉格朗日方程推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拉格朗日方程是分析力学中的重要方程，其地位相当于牛顿第二定律之于牛顿力学。
欧拉-拉格朗日方程可以表述为：
设有函数 y ( x ) \mathbf{y}(x) y(x)和 f ( y , y ˙ , x ) f(\mathbf{y},\mathbf{\dot{y}},x) f(y,y˙​,x)：
y ( x ) = ( y 1 ( x ) , y 2 ( x ) , … , y N ( x ) ) (1) \mathbf{y}(x)=\left( {{y}_{1}}(x),{{y}_{2}}(x),\ldots ,{{y}_{N}}(x) \right)\tag{1} y(x)=(y1​(x),y2​(x),…,yN​(x))(1)
y ˙ ( x ) = ( y ˙ 1 ( x ) , y ˙ 2 ( x ) , … , y ˙ N ( x ) ) (2) \mathbf{\dot{y}}(x)=\left( {{{\dot{y}}}_{1}}(x),{{{\dot{y}}}_{2}}(x),\ldots ,{{{\dot{y}}}_{N}}(x) \right)\tag{2} y˙​(x)=(y˙​1​(x),y˙​2​(x),…,y˙​N​(x))(2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a6c345b5327e512b4d13cccb44030d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c7a02554cad13817b16d62a73021075/" rel="bookmark">
			拉格朗日方程的三种推导方法之基于汉密顿原理推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拉格朗日方程是分析力学中的重要方程，其地位相当于牛顿第二定律之于牛顿力学。
哈密顿原理可数学表述为：
δ ∫ t 1 t 2 L d t = 0 (1) \delta \int_{{{t}_{1}}}^{{{t}_{2}}}{Ldt=0}\tag{1} δ∫t1​t2​​Ldt=0(1)
在等时变分情况下，有：
δ q ∙ = d d t ( δ q ) (2) \delta \overset{\bullet }{\mathop{q}}\,=\frac{d}{dt}(\delta q)\tag{2} δq∙​=dtd​(δq)(2)
δ ∫ t 1 t 2 L d t = ∫ t 1 t 2 ( δ L ) d t = 0 (3) \delta \int_{{{t}_{1}}}^{{{t}_{2}}}{Ldt=\int_{{{t}_{1}}}^{{{t}_{2}}}{(\delta L)dt}}=0\tag{3} δ∫t1​t2​​Ldt=∫t1​t2​​(δL)dt=0(3)
由拉格朗日量定义得，在等时变分情况下有
δ L = ∂ L ∂ q ∙ δ q ∙ + ∂ L ∂ q δ q (4) \delta L=\frac{\partial L}{\partial \overset{\bullet }{\mathop{q}}\,}\delta \overset{\bullet }{\mathop{q}}\,+\frac{\partial L}{\partial q}\delta q\tag{4} δL=∂q∙​∂L​δq∙​+∂q∂L​δq(4)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c7a02554cad13817b16d62a73021075/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ade49c74305b91f9fb3e163f77c9984/" rel="bookmark">
			Swagger2 非全局、无需重复输入的Head参数（Token）配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优化方案如下：
通过Swagger2的securitySchemes配置全局参数：如下列代码所示，securitySchemes的ApiKey中增加一个名为“Authorization”，type为“header”的参数。 private List&lt;ApiKey&gt; securitySchemes() { return newArrayList( new ApiKey("Authorization", "Authorization", "header")); } 在Swagger2的securityContexts中通过正则表达式，设置需要使用参数的接口（或者说，是去除掉不需要使用参数的接口），如下列代码所示，通过PathSelectors.regex("^(?!auth).*$")，所有包含"auth"的接口不需要使用securitySchemes。即不需要使用上文中设置的名为“Authorization”，type为“header”的参数。 private List&lt;SecurityContext&gt; securityContexts() { return newArrayList( SecurityContext.builder() .securityReferences(defaultAuth()) .forPaths(PathSelectors.regex("^(?!auth).*$")) .build() ); } 设置完成后进入SwaggerUI，右上角出现“Authorization”按钮，点击即可输入我们配置的参数。
对于不需要输入参数的接口（上文所述的包含auth的接口），在未输入Authorization参数就可以访问。
其他接口则将返回401错误。点击右上角“Authorization”按钮，输入配置的参数后即可访问。参数输入后全局有效，无需每个接口单独输入。
image.png
至此，完成Swagger2 非全局、无需重复输入的Head参数配置。
Swagger2的相关完整代码如下（工程基于Springboot）：
@Configuration @EnableSwagger2 public class Swagger { @Bean public Docket api() { return new Docket(DocumentationType.SWAGGER_2). useDefaultResponseMessages(false) .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.regex("^(?!auth).*$")) .build() .securitySchemes(securitySchemes()) .securityContexts(securityContexts()) ; } private List&lt;ApiKey&gt; securitySchemes() { return newArrayList( new ApiKey("Authorization", "Authorization", "header")); } private List&lt;SecurityContext&gt; securityContexts() { return newArrayList( SecurityContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ade49c74305b91f9fb3e163f77c9984/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc794e770423415ee65b23d3203d4a1d/" rel="bookmark">
			C#使用iText7以及FreeImage导出JPXDecode格式的图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装iText7包
2、安装FreeImage.Net包
3、注意需要下载FreeImage.dll到bin目录下，有X86和X64两个版本，注意选一个符合的，如果没有这个dll文件，运行时会报“不能正确加载FreeImage.dll"
4、代码如下:
/// &lt;summary&gt; /// PDF版本 /// &lt;/summary&gt; private static readonly PdfVersion pdfVersion = PdfVersion.PDF_1_5; /// &lt;summary&gt; /// 转换文件 /// &lt;/summary&gt; /// &lt;param name="src"&gt;&lt;/param&gt; /// &lt;param name="dest"&gt;&lt;/param&gt; public void ConvertFile(string src, string dest) { PdfDocument pdfDoc = new PdfDocument(new PdfReader(src), new PdfWriter(dest, new WriterProperties().AddUAXmpMetadata().SetPdfVersion(pdfVersion)).SetSmartMode(true) ); try { int numberOfPdfObjects = pdfDoc.GetNumberOfPdfObjects(); for (int i = 1; i &lt;= numberOfPdfObjects; i++) { PdfObject pdfObject = pdfDoc.GetPdfObject(i); if (pdfObject == null || !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc794e770423415ee65b23d3203d4a1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/049c3ef36a27098d881078e63cc62975/" rel="bookmark">
			块级作用域中声明函数的一些小问题分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看一段简单代码，原题记不大清了，重新写了一个，大致如下
function fun() { console.log(a); console.log(b); if (true) { function b() { console.log("ycx") }; var a = 10; } console.log(a); console.log(b); } fun(); 初看此题，一般都会先考虑利用预编译的知识点去分析此题。
在代码执行前会先进行两步操作
第一步代码检测会检测一些明显的语法错误，并不涉及一些逻辑方面的
第二步才是预编译的过程
预编译 在函数执行前的一瞬间，生成AO对象 函数的形参作为AO对象的属性名，实参作为AO对象的属性值 分析var声明，变量名作为AO对象的属性名，属性值为undefined，遇到和参数同名的情况，不做任何改变 分析函数声明，函数名作为AO的属性名，属性值为函数体，遇到相同属性名，直接覆盖 若直接按照上面预编译的步骤进行分析，可得fun.AO
fun.AO = { a: undefined, b: function() { console.log("ycx") }, } 然后得到答案
// undefined // function() { console.log("ycx") } // 10 // function() { console.log("ycx") } 咋一看合情合理，但是放到浏览器里面跑一遍
运行结果与预先估计的不太对 问题就出在if条件里面的函数声明，似乎并没有被提前
实际上在这里的函数声明并没有完全提前，只是提前了声明部分，并没有分配实际的内存空间
在ES5的标准中，块级作用域中是不允许声明函数的
但是浏览器在解析的过程中，为了兼容旧的代码，并没有遵守这一规定，因此上面代码在执行的时候至少是没有报错的
在执行的时候，函数声明会转换为函数表达式
if语句中会转换成类似于以下代码
if (true) { var b = function() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/049c3ef36a27098d881078e63cc62975/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acd3652f88f2130142ce092d4c0bd227/" rel="bookmark">
			Android Studio 下载设备虚拟机镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里以下载手机虚拟机镜像为示例 需要用到的软件 Android SDK Tools
不知道如何安装Android SDK Tools 的请参考 安装Android SDK Tools
SDK Manager.exe打不开的请参考这里 SDK Manager 打不开解决方法
1.选择镜像 选择所需要的镜像版本，点击install package
2.同意协议，点击install 3.等待下载 4.完成安装 如图所示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8dbbace5da3af19be8bae86aab199fa/" rel="bookmark">
			Android Studio 创建手机虚拟机教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小白 Android Studio创建手机虚拟机 版本 AndroidStudio 3.5.3
在APP开发中不一定每时每刻都有真机，所以可以通过AndroidStudio 创建一个手机虚拟机
1.创建新的手机虚拟机 ①.点击No devices 旁边的小三角，选择Open AVD Manager
②.点击 Create Virtual Device
③.选择一个适合的机型，在这里我选择了6.3英寸，1440x2960分辨率的机型。然后点击Next
④选择版本，如果这里选择了Next是灰色的请参考 小白AndroidStudio安装虚拟设备镜像
⑤配置
⑥完成配置，打开手机虚拟机。
⑦效果图
⑧以后就可以在这里直接打开了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90112837b26dbb2a6acffc75d687bc24/" rel="bookmark">
			C&#43;&#43;经典算法题-打印水仙花数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 题目 题目：打印出所有的“水仙花数”，所谓“水仙花数”是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个“水仙花数”，因为153=1的三次方＋5的三次方＋3的三次方。
2. 分析 程序分析：利用for循环控制100-999个数，每个数分解出个位，十位，百位。
3. 代码示例 main() { int i, j, k, n; printf("'water flower'number is:"); for (n = 100; n &lt; 1000; n++) { i = n / 100;/*分解出百位*/ j = n / 10 % 10;/*分解出十位*/ k = n % 10;/*分解出个位*/ if (i * 100 + j * 10 + k == i * i * i + j * j * j + k * k * k) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90112837b26dbb2a6acffc75d687bc24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/575e9ff4b2f19dcb16e93437b53e7398/" rel="bookmark">
			NPM自定义全局安装路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 NPM自定义全局安装路径 步骤一： 在nodejs的安装目录下【笔者的安装目录为F:\ComonTools\NodeJS】创建npm的缓存目录node_cache，在当前目录下使用shift+鼠标右键，选择打开命令行，输入命令：npm config set cache "D:\nodejs\node_cache",配置npm的缓存文件保存目录成功。
步骤二： 在nodejs的安装目录下找到npmrc文件【笔者的目录在F:\ComonTools\NodeJS\node_modules\npm\npmrc】，该文件记录的是npm全局安装应用的时候的默认存储路径，修改该路径为"F:\ComonTools\NodeJS"即可。
拓展内容
如果觉得以上方法过于麻烦，不想进行修改，可以将npm全局安装应用的默认存储路径添加到系统环境变量里面也可以哦。
# 配置全局安装路径 npm config set prefix "F:/ComonTools/NodeJS/node_global" # 配置全局缓存路径 npm config set cache "F:/ComonTools/NodeJS/node_cache" # 修改npm默认镜像源为淘宝镜像源 npm config set registry https://registry.npm.taobao.org 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f86d8b5f393cf4e8b8c5468da407c2/" rel="bookmark">
			实验1：第一个Android程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验1：第一个Android程序 一、实验目的： 了解Android应用程序开发环境的搭建方法;使用eclipse+ADT插件和Android Studio开发应用程序的一般步骤 二、实验内容： 安装JDK并配置好环境变量；安装eclipse和ADT插件安装Android Studio在eclipse和Android Studio中创建Android应用程序并在模拟器上运行成功。 三、实验步骤： 1.搭建Android开发环境
（1）首先需要安装JDK并配置环境变量；
2）下载并安装Eclipse；
(2.1)第一步：下载eclipse,并安装
(2.2)安装完成之后配置环境变量：
（3）安装ADT插件；
（4）下载并安装Android SDK，将SDK位置在ADT里配置好；
（5）下载并安装Android Studio，指定好SDK的位置；
1、首先下载Android studio安装包
2、下载好该安装包之后，点击进行安装，依次出现以下界面
2.创建Android应用程序
（1）使用Eclipse建立第一个Android程序（以“com.androidcourse._学号”为包名）并在模拟器上成功运行；
1.依次选择File-&gt;New Android Application:
2.依次点击Next:
3.选择Empty Activity:
4.运行结果：
（2）使用Android Studio建立第一个Android程序（以“com.androidcourse._学号”为包名）在模拟器上成功运行；
（3）比较Eclipse和Android Studio两款软件的异同。
1. AndoridStudio构建程序界面更方便，打印信息更详细，编辑历史更详细，智能识别更强大，资源文件可以在代码中预览，开发界面中为我们提供了超过10种的视图。
2. Eclipse创建项目更简单，项目体积比较小，配置文件无需更新，多项目管理很方便。
3. 总的来说AndroidStudio比Eclipse更要强大，同时通过AndoridStudio来进行Android项目开发是一种不可颠覆的趋势和潮流，毕竟Eclipse可以做的东西很多，不够专注！而AndroidStudio只面向手机开发， 术业有专攻，在开发Android项目方面的优势肯定是很明显的。但AndroidStudio也有缺点，特别是在使用gradle文件方面，用户体验亟需提高，需要更多地考虑一下不能正常使用国外网站的地区如何正常地使用该工具来构建程序。
四、实验总结 答：通过此次实验熟悉了android studio和eclipse的基本安装过程，并学会了配置相应的环境变量。通过分别在eclipse和android studio中创建工程，对比分析了两者的相同点和不同点，相比于eclipse来说，我更倾向于选择使用相对专业的android studio，虽然其比较占用内存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/171edba63c4891c8a2302c45d56f372c/" rel="bookmark">
			Apach代理SESSION丢失处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Apach代理SESSION丢失处理 因在项目中使用了apache对项目进行代理，前后端请求时，session总是丢失，最后发现是在代理时因为路径的转发原因，使得每次请求都会重新创建session。 解决办法就是在配置中添加ProxyPassReverseCookieDomain和ProxyPassReverseCookiePath ProxyPass /test http://127.0.0.1:8080/ ProxyPassReverse /test http://127.0.0.1:8080/ ProxyPassReverseCookieDomain 内部路径（127.0.0.1） 公共路径（www.baidu.com/） ProxyPassReverseCookiePath 内部域（/） 公共域（/test ） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f741783b8dc1b95c2d23a8ffb76a1802/" rel="bookmark">
			ELK使用及elastalert告警设置配置实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.系统部署 **1):部署过程略...** #readme ```bash 1.问题：ERROR: bootstrap checks failed max file descriptors [4096] for elasticsearch process likely too low, increase to at least [65536] max number of threads [1024] for user [lishang] likely too low, increase to at least [2048] 解决：切换到root用户，编辑limits.conf 添加类似如下内容 vi /etc/色curity/闪电mits.conf 添加如下内容: * soft nofile 65536 * hard nofile 131072 * soft nproc 2048 * hard nproc 4096 2.问题：max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144] 解决：切换到root用户修改配置sysctl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f741783b8dc1b95c2d23a8ffb76a1802/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfa1887972207e7fddb81891b9fa1321/" rel="bookmark">
			U3D Rigidbody_2_属性篇_02_angularVelocity
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Properties angularVelocity: 刚体的角速度矢量（以弧度/秒为单位） 在大多数情况下，不应该直接修改它，因为这可能导致行为失真
[1]创建4个爆炸点，按下 R 键触发爆炸效果，将处于4个爆炸点中间的胶囊体弹起。在它们身上挂载好爆炸脚本。
using UnityEngine; public class ExplosionPoint : MonoBehaviour { private float radius; private float powerValue; private Collider[] colliders; private Vector3 explosionPoint; private void Start() { radius = 5.0f; powerValue = 1000.0f; explosionPoint = transform.position; colliders = Physics.OverlapSphere(explosionPoint, radius); } private void Update() { if (Input.GetKeyDown(KeyCode.R)) { TriggerExplosion(); } } private void TriggerExplosion() { foreach (Collider col in colliders) { Rigidbody rb = col.GetComponent&lt;Rigidbody&gt;(); if (rb !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfa1887972207e7fddb81891b9fa1321/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5cdee3a2929066e0dc9380216191541/" rel="bookmark">
			golang定时器实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		golang定时器，需求是能够在指定时间后停止。或某种条件出发停止。
https://golang.google.cn/pkg/time/#example_Tick
好，下面上货。
package main import ( "context" "fmt" "sync" "time" ) func main() { fmt.Println(123) go goClock() go goClock2() stopTheWorld() } func stopTheWorld() { var wg sync.WaitGroup wg.Add(1) wg.Wait() } func goClock() { ticker := time.NewTicker(time.Second) defer ticker.Stop() done := make(chan bool) go func() { time.Sleep(10 * time.Second) done &lt;- true }() for { select { case &lt;-done: fmt.Println("Done!") return case t := &lt;-ticker.C: fmt.Println("clock Current time: ", t) } } } func goClock2() { ticker := time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5cdee3a2929066e0dc9380216191541/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/638de7ace00b23cbb25ac3571b3c3878/" rel="bookmark">
			Android 使用RtmpDump推流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍在android平台上使用RtmpDump来完成推音视频流的示例。音频流使用faac编码器，视频流使用x264编码器编码器。
具体可参考Github仓库
文章目录 1 总结构图2 音频采集2.1 java层 音频采集初始化配置2.2 java层 开始采集音频数据 3 音频编码3.1 将音频数据从java层传递到native层3.4 native层 编码音频数据 4 视频采集4.1 视频采集初始化配置4.2 开始采集视频数据 5 视频编码5.1 将视频频数据从java层传递到native层5.2 native层 编码视频数据5.3 编码sps和pps数据5.4 编码帧数据 6 推流 1 总结构图 java层的VideoChannel和AudioChnnel负责音视频数据的采集。C层的VideoChannle和AudioChannel负责音视频数据的编码。
流程主要分三大步骤
native层的初始化。通过java层的LivePusher类调用native_lib.c的jni函数，在函数中会创建C层的用于编码的VideoChannel和AudioChannel。并会实现编码后的回调函数。
音视频采集的初始化。首先是java层的VideoChannel和AudioChannel的初始化。当有数据采集出来会通过LivePusher传递到native_lib类中。然后通过C层的VideoChannel和AudioChannel编码音视频的数据。当VideoChannel和AudioChannel编码数据完成后会通过回调函数，将RtmpPacket添加到native_lib.c文件的队列中。
开始采集: 当一切准备工作都完成后，开始发起java层的音视频采集。此时采集后的数据会按照之前初始化的步骤来完成音视频的编码及添加到待推流的队列过程。然后native_lib.c中会开启一个线程，不断轮询队列中的packet数据，并将packet推到服务器。
2 音频采集 2.1 java层 音频采集初始化配置 public AudioChannel(LivePusher livePusher) { //1 初始化LivePusher, 用于将采集到的数据通过LivePusher中的native函数传递到c层 mLivePusher = livePusher; //2 创建线程池对象，用于在线程中读取音频数据 executor = Executors.newSingleThreadExecutor(); //3 配置通道数 比如是单声道或者立体声 int channelConfig; if (channels == 2) { channelConfig = AudioFormat.CHANNEL_IN_STEREO; } else { channelConfig = AudioFormat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/638de7ace00b23cbb25ac3571b3c3878/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b0281a1a54b3dcab8ba5c7bcfb8049b/" rel="bookmark">
			详解CSP-J/S
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​什么是CSP CSP（Certified Software Professional）是CCF的计算机软件能力认证。
什么是CSP-J/S 从2019年，CCF发布暂停举办NOIP的消息，并随即推出了CSP非专业级别认证。非专业级别较之专业级别更为简单，分两个级别进行，分别为CSP-J（对应NOIP普及组，Junior）和CSP-S（对应NOIP提高组，Senior），均涉及算法和编程。任何人都可以报名参加，没有年龄限制。
CSP-J和CSP-S均分别举办两轮，认证方式均为现场认证，非网络认证。参加CSP-J/S第二轮，必须先参加第一轮，达到一定的分数者方可参加第二轮。
CCF 强调，CSP 非专业级别认证旨在推动计算机科学的普及，让更多的青少年和非专业人士接触和学习计算机科学，并对他们未来选择以计算机为其职业有所帮助。CSP 认证不纳入行政轨道，不建议将 CSP 成绩作为职业晋升和升学的唯一依据，不建议以功利的心态参加 CSP 认证。
首次CSP-J/S报名情况 首次CSP-J/S第一轮认证于2019年10月19日举行，共有来自全国31个省市（含港澳）共计106,344人报名参加。其中，S组为48812人、J组为57532人。有10个省市的参加人数在3000人以上，分别是：山东、四川、浙江、安徽、广东、江苏、福建、上海、北京、湖南。
首次CSP-J/S第二轮认证于2019年11月16日-17日在各认证省市同时举行，共有来自全国30个省市（含澳门）共计29165人报名参加。其中，S组为13870人、J组为15295人。
多少分可以通过CSP-J/S第一轮 从2019年首次CSP-J/S第一轮来看，各省分数线完全不同，只能说根据各省的具体情况而定。
按照CCF规定，至少要保证各省报名人数的20%。也就是说假设A省初赛报名了100人，哪么至少要保证20人参与第二轮。
但是实际执行的时候，每个省的政策又不相同。比如浙江省，按照报名人数20%进行总分排序，前20%考生进入第二轮。比如江苏省，是各地区有不同的分数线。
相对而言，信奥弱省在初赛会占优势。比如江西省，2019年基本就是参加了第一轮考试的考生全部进入第二轮。
CSP-J/S与NOI之间的关系 CCF表示：CSP-J/S认证成绩优异者，可参加NOI省级选抜，省级选拔成绩优异者可参加NOI。和NOIP一样，要求CSP-S一等奖。
CSP-J/S认证时间 基本和原有NOIP比赛时间相同。
CSP-J/S第一轮在10月份第三个星期六进行，时间为2小时，内容为笔试或机试（从2020年开始全部为机试），满分100分。
CSP-J/S第二轮在11月份第三个星期六和星期日进行，复赛的题型和考试形式全部为上机编程题。CSP-J复赛规定为：时间为3小时，共4道题，每题100分，共计400分。CSP-S复赛规定为：包括一试和二试，分两天进行。每次测试时间为3小时，有3道题，每题100分。选手的总分为两次测试的分数的总和，最高600分。
CSP-J/S是否受到教育部认可 暂时不得而知，至少目前没有在教育部的白名单上。但是2019年12月，清华大学冬令营和北京大学冬令营如期举行，说明了大学的态度。
更多资讯 进一步CSP-J/S相关信息请参考这个链接http://www.noi.cn/newsview.html?id=947&amp;hash=11BA0D&amp;type=1。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db866cda886b37e56b68cbd86d91547f/" rel="bookmark">
			HTML基础教程(尽情期待)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我相信看视频的还有很多老司机，取其精华，查漏补缺，下方评论留言。
HTML结构和头
HTML标题
HTML段落
HTML格式
HTML注释
HTML链接
HTML图像
HTML按钮
HTML列表
HTML表格
HTML视频
HTML音频
HTML块级元素和内联元素
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88fb6dcdf1a20e85e5df481396c7d570/" rel="bookmark">
			搜索-Query理解(全)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Query 模块： 纠错分词紧密度同义词词权重实体词识别意图识别 长尾 query 的多样性对于搜索系统来说是一个很大的挑战，原因有：
❶ 存在输入错误。例如上图中的错误 query "塞尔维雅" ( 塞尔维亚 )，对于这种错误我们希望系统能够自动的纠错；
❷ 存在表达冗余。例如输入 "孙子兵法智慧的现代意义"，在这个语境下，"智慧" 是一个无关紧要的词。如果强制去匹配 "智慧" 的话，反而匹配不出真正想要的结果；
❸ 存在语义鸿沟。比如 "高跟鞋消音"，其中 "消音" 这个词的表达较少见，使得同时包含 "高跟鞋" 和 "消音" 文档较少。而类似的表达如 "高跟鞋声音大如何消除"、"高跟鞋消声" 等可能较多。用户输入的 query 和用户生产内容之间存在了语义鸿沟。其他类型的难点还有表达不完整，意图不明等等。
我们先通过图右边这个query："iPhone 手机价格多少" 来介绍如何解决上述问题：
❶ 对于输入错误，比如说用户输入的 query 是 iPhone，但是这个词输错了，会通过纠错模块将其纠正为正确的 query；
❷ 对于表达冗余，通过计算每一个词的重要程度也就是 term weight，来确定参与倒排索引求交操作的词。先对 query 进行分词，切成 iPhone、手机、价格、多少，之后判断各词对于表达意图更重要，重要的词会在检索时参与倒排索引的求交操作，不那么重要的词不严格要求一定在文档中出现；
❸ 解决语义鸿沟的问题。需要对原始 query 做同义词扩展，比如 "iPhone" 和 "苹果" 是同义词，"价格" 和 "售价" 是同义词。
所以在传统的搜索领域中的查询模块，往往包含这些子任务：纠错、分词、紧密度、同义词、词权重，以及其他的如实体词识别、意图识别等等。这些查询理解会生成一个结构化的数据，检索模块就可以通过结构化的查询串去召回相关的文档。
三路召回： queryrewrite-queryvector 如图所示，实际召回中有三个队列，基于倒排索引的队列占两个，分别是原始 Query 队列和改写 Query 队列。改写队列是用翻译模型去生成一个表达更适合检索的 query，然后再去做 query 理解和索引召回。而第三个队列是基于 embedding 的索引。首先把所有 doc、原始 query 都转为向量，再通过空间最近邻的 KNN-Search，找到与 query 最相似的文档。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88fb6dcdf1a20e85e5df481396c7d570/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/567c500151444824cf178005ed8e5ae9/" rel="bookmark">
			ENVI学习总结（三）——图像几何校正
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3. 图像几何校正 3.1 内容介绍 几何校正是利用地面控制点和几何校正数学模型来矫正非系统因素产生的误差，由于校正过程中会将坐标系统赋予图像数据，所以此过程包括了地理编码。
3.1.1 控制点选择方式 ENVI提供以下选择方式：
（1） 从栅格图像上选择
如果拥有需要校正图像区域的经过校正的影像、地形图等栅格数据，可以从中选择控制点，对应的控制点选择模式为Image to Image。
（2） 从矢量数据中选择
如果拥有需要校正图像区域的经过校正的矢量数据，可以从中选择控制点，对应的模式为Image to Map。
（3） 从文本文件中导入
事先已经通过GPS测量、摄影测量或者其他途径获得了控制点坐标数据，保存为以[Map (x,y), Image (x,y)]格式提供的文本文件可以直接导入作为控制点，对应的控制点选择模式为Image to Image 和Image to Map。
（4） 键盘输入
如果只有控制点目标坐标信息或者只能从地图上获取坐标文件（如地形图等），只好通过键盘敲入坐标数据并在影像上找到对应点。
3.1.2 几何校正模型 ENVI提供三个几何校正模型：仿射变换（RST）、多项式和局部三角网（DelaunayTriangulation）。
3.1.3 控制点的预测与误差计算 控制点的预测是通过控制点回归计算求出多项式系数，然后通过多项式计算预测下一个控制点位置，RMS值也是用同样的方法。默认多项式次数为1，因此在选择第四个点时控制点预测功能可以使用，随着控制点数量的增强，预测精度随之增加。最少控制点数量与多项式次数的关系为（n+1）²。
3.2 详细操作步骤 3.2.1 扫描地形图的几何校正 第一步：打开并显示图像文件
开始&gt;程序&gt;ENVI5.1&gt;Tools&gt;ENVI Classic，选择主菜单&gt;File&gt;Open Image File，将taian-drg.tif文件打开，并显示在Display中。
第二步：启动几何校正模块
（1） 主菜单&gt;Map&gt;Registration&gt;Select GCPs:Image to map，打开几何校正模块。
（2） 在Image to Map Registration面板中，选择Beijing_1954_GK_Zone_20，X/Y Pixel Size分别输入4，单击OK，打开Ground Control Points Selection面板如图3.1.1。
图3.1.1 选择坐标系及输出网格大小
（3）在 Displsy 视图中，定位到左上角第一个公里网交互处，从图上读取 X：20501000，Y：4003000，填入在 Image to Map Registration 面板中的 E 和 N，单击 Add Point 按钮，增加第一个控制点如图3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/567c500151444824cf178005ed8e5ae9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e74b264dc076b286a57f172e70307d68/" rel="bookmark">
			The POM for * is invalid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打包一个老应用，结果maven compile的时候报错：
The POM for * is invalid 然后到本地的maven repository看了下那个包下的pom文件，真的是个坏文件，pom本来是xml格式的，但那个文件下的内容却是html。原来是公司的nexus私服上这个文件有问题，把私服上的这个文件fix掉应该就可以解决了。
要快的话就是先从maven central上下一个好的pom文件，去覆盖掉本地的那个pom，然后重新maven compile就OK了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fc6da1e13ff509acd7da790f720a651/" rel="bookmark">
			阿里巴巴向全社会开放黑科技：“泡在水里”的服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介： 为了让数据中心更绿色，阿里工程曾将服务器“泡在水里”进行散热，节能超70%，今天这项黑科技的神秘面纱被揭开。
为了让数据中心更绿色，阿里工程曾将服务器“泡在水里”进行散热，节能超70%，今天这项黑科技的神秘面纱被揭开。
2020年1月6日，阿里巴巴宣布将“浸没式液冷数据中心技术规范”向全社会开放。这项规范旨在用一套标准流程为下一代绿色基地型数据中心的建设提供设计依据，通过液冷技术的普及，降低全社会的能耗水平。初步估算，如果全国的数据中心都采用液冷技术，一年可节省上千亿度电。
2009年到2019年，是云计算引领行业巨变的十年，也是IT格局巨变的十年。云已经超越传统IT，成为IT创新中心、科技产业重心和企业数字化核心。以阿里巴巴为代表的互联网公司凭借洞察的优势和扎实的技术正在引领IT基础设施的自主研发和技术创新，除了液冷技术外，阿里巴巴基础设施事业部还自主研发了400G光模块、存储部件、智能供电技术等创新产品，追求算力的极致提升。
2016年，阿里巴巴就推出了全球首台浸没式液冷服务器，将服务器被浸泡在特殊的绝缘冷却液里，运算产生热量可被直接吸收进入外循环冷却，全程用于散热的能耗几乎为零。这种形式的热传导效率比传统的风冷要高百倍，节能效果超过70%。
相对于传统IT，液冷数据中心的背后是巨大创新和革命性变化，硬件与系统的变更需要大量人力和物力投入，当前这个领域几乎空白，没有标准可以借鉴。此次阿里巴巴开源的整套规范，涵盖了数据中心的设计、施工、部署、运维等各个环节，通过一体化设计合理规划，降低部署成本，提升稳定性，带领数据中心走上高效、清洁、集约的绿色发展道路。
与传统OEM设备商不同，阿里巴巴在技术创新体系中融入了各个领域的思考。以自研网络交换机为例，阿里自研了大规模、可扩展、简约化的互联网数据中心网络架构，通过网络秒级管理、管控系统建设，和多年的运维管理建模经验，最终呈现出性能优异的网络交换机和网络操作系统。
“传统IT缺的不是创新，而是工匠级创新，”阿里巴巴基础设施事业部总经理高山渊表示，十年多来，阿里人把技术当成工艺品打磨，阿里巴巴有条件、有资源、有责任成为IT创新的担当，向社会分享技术红利。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61dc04e9952ad3ea6e31e647e8a625eb/" rel="bookmark">
			STM32串口配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		串口一
void usart1_Init(u32 bound) { //GPIO端口设置 GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOC, ENABLE);//使能USART1,GPIOA,C时钟 //USART1_TX GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.9 //USART1_RX GPIOA.10初始化 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.10 //Usart1 NVIC 配置 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 0-3; NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//抢占优先级3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道使能 NVIC_Init(&amp;NVIC_InitStructure); //根据指定的参数初始化VIC寄存器 //USART 初始化设置 USART_InitStructure.USART_BaudRate = bound;//串口波特率 USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式 USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位 USART_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61dc04e9952ad3ea6e31e647e8a625eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d6ff354ef1ac89ec4ef2e397f26d073/" rel="bookmark">
			旋转变压器及旋变解码芯片RDC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博文主要介绍旋转变压器的类型与结构及其工作原理；介绍旋变-数字转换（RDC）芯片以及对旋转变压器输出信号的解码工作原理；介绍ADI公司生产的AD2S1200旋变-数字转换芯片，该部分包括介绍该芯片的主要特性，管脚配置及其功能，以及AD2S1200的数据输出过程和励磁输出。
1 旋转变压器介绍 旋转变压器（Resolver）是一种电磁式传感器，它主要用于角度位置和角速度的测量。旋转变压器由安装时固定不动的定子和安装在轴上的转子组成。旋转变压器的工作原理相似于普通变压器，它的定子和转子可以看成变压器的原边和副边。定子绕组接受外部的励磁电压，而转子绕组则通过电磁耦合产生感生电动势。转子绕组的感生电动势经过解调等处理后可得到转子的转角，从而得到目标结构的轴角位置和角速度等数据。
当外界给予正余弦旋转变压器旋转变压器的定子绕组以一定频率的励磁电压时，转动的转子上的绕组便会输出幅值与转子轴角成正、余弦函数关系的调幅信号。旋转变压器有绕线式和磁阻式之分，也有单极对和多极对之分。通常采用多极对旋转变压器能够提高数据采集的精度。
图 1 旋转变压器实物 图1为赢双公司生产的52XU9733型磁阻式旋转变压器。其主要参数如表1所示：
表- 1 YS 52XU9733主要参数 型号YS 52XU9733极对数3对极励磁电压7V(AC)励磁频率10kHz变压比0.286±10%精度≤±45’ 2 旋转变压器的工作原理 通常在旋转变压器的的转子中有一组原边绕组，定子中则有两组副边绕组。而在可变磁阻旋变中，转子里没有绕组，取而代之的是原边绕组也在定子上，见图1。不过，凸极性设计的转子能在副边绕组产生与角度位置成正、余弦变化的感生电动势。
图 2 旋变结构示意图 无论是经典旋变还是可变磁阻式旋变，当外界给予如图2-3中R2-R4所示的励磁信号时，转动的旋转变压器将输出如S2-S4、S1-S3所示的正余弦调幅波。
图 3 旋转变压器的励磁输入和正余弦输出 设旋转变压器转子 R1—R2 励磁绕组两端施加的励磁电压为:
U R 1 − R 2 = E P sin ⁡ ( w t ) ( 1 ) {{U}_{R1-R2}}={{E}_{P}}\sin (wt)\tag{ 1 } UR1−R2​=EP​sin(wt)( 1 )
则旋转变压器定子上的 S1—S2和S3—S4绕组输出电压分别为:
U S 3 − S 1 = E 0 sin ⁡ ( w t ) sin ⁡ θ ( 2 ) {{U}_{S3-S1}}={{E}_{0}}\sin (wt)\sin \theta \tag{ 2 } US3−S1​=E0​sin(wt)sinθ( 2 )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d6ff354ef1ac89ec4ef2e397f26d073/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd0163defeab277cbad101a17b1a3902/" rel="bookmark">
			Unity发布安卓9.0及以上版本不能访问http请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决办法一：
在AndroidManifest.xml的application中添加如下一条属性即可：android:usesCleartextTraffic="true"
解决方法二：
在res/xml目录下新建xml文件，文件名为network_security_config.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted="true"&gt; &lt;trust-anchors&gt; &lt;certificates src="system" /&gt; &lt;/trust-anchors&gt; &lt;/base-config&gt; &lt;/network-security-config&gt; 之后在Manifest.xml文件中使用配置
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;manifest ... &gt; &lt;application android:networkSecurityConfig="@xml/network_security_config"&gt; &lt;/application&gt; &lt;/manifest&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a309bc071a4faec95f5f229ac432d44d/" rel="bookmark">
			常用的传输媒体有哪些，各有什么特点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的传输媒体有以下几种
1.双绞线 双绞线分屏蔽双绞线和无屏蔽双绞线。由两根相互绝缘的导线组成。可以传输模拟信号，也可以传输数字信号，有效带宽达250kHz，通常距离一般为几道十几公里。导线越粗其通信距离越远。在数字传输时，若传输速率为每秒几兆比特，则传输距离可达几公里。一般用作电话线传输声音信号。虽然双绞线容易受到外部高频电磁波的干扰，误码率高，但因为其价格便宜，且安装方便，既适于点到点连接，又可用于多点连接，故仍被广泛应用。
2.同轴电缆 同轴电缆分基带同轴电缆和宽带同轴电缆，其结构是在一个包有绝缘的实心导线外，再套上一层外面也有一层绝缘的空心圆形导线。由于其高带宽（高达300~400Hz）、低误码率、性能价格比高，所以用作LAN中。同轴电缆的最大传输距离随电缆型号和传输信号的不同而不同，由于易受低频干扰，在使用时多将信号调制在高频载波上。
3.光导纤维 光导纤维以光纤维载体，利用光的全反向原理传播光信号。其优点是直径小、质量轻：传播频带款、通信容量大：抗雷电和电磁干扰性能好，五串音干扰、保密性好、误码率低。但光电接口的价格较昂贵。光纤被广泛用于电信系统铺设主干线。
4.无线电微波通信 无线电微波通信分为地面微波接力通信和卫星通信。其主要优点是频率高、频带范围宽、通信信道的容量大；信号所受工业干扰较小、传播质量高、通信比较稳定；不受地理环境的影响，建设投资少、见效快。缺点是地面微波接力通信在空间是直线传播，传输距离受到限制，一般只有50km，隐蔽性和保密性较差；卫星通信虽然通信距离远且通信费用与通信距离无关，但传播时延较大，技术较复杂，价格较贵。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e079361d0e481a0386461233fb4d04c/" rel="bookmark">
			JVM 内存结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM 内存结构 虚拟内存：将一些磁盘空间当做内存使用； 一、 JVM 内存划分 jdk 中 1.7 和 1.8 中间有区别
JVM 在运行 Java 程序的过程中会将其所管理的内存划分为若干个不同的数据区域，JVM 管理的内存包括以下几个运行时数据区域：（下面为 JVM 运行时内存数据区域）
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-x25y9Unx-1578190223249)(Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.resource/166786b5cf6d7f95)]
区域是否线程共享是否会内存溢出程序计数器否不会虚拟机栈否会本地方法栈否会堆是会方法区是会 虚拟机栈：每个虚拟机栈都是归属于一个线程的，是线程私有的空间，当一个线程创建的时候，与之对应的虚拟机栈就产生了，线程消亡则对应的虚拟机栈就消失；生命周期同线程相同；其描述的是 Java 方法执行的内存模型，每个方法执行的同时都会创建一个栈帧。
虚拟机栈中数据称为：栈帧：每一个方法执行的时候都会创建一个与该方法有关并且独有的栈帧（JVM 是基于栈执行的），里面存储操作数栈中数据，局部变量表（就是该线程可以自己访问到的局部变量信息（包括八种基本数据类型（其中 64 位的 long、double 占用两个局部变量空间（Slot））和对象引用（reference 类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个- 代表对象的句柄或者其他与此对象相关的位置）））、方法的返回地址（出口，即执行一条字节码指令的地址）、动态连接等，即主要存储与方法执行相关的内容；每个方法从调用到执行完毕，对应一个栈帧在虚拟机栈中的入栈和出栈。
通常所说的栈，一般是指虚拟机栈中的局部变量表部分。局部变量表所需的内存在编译期间完成分配。 栈的大小可以固定也可以动态扩展，当扩展到无法申请足够的内存，则OutOfMemoryError。 当栈调用深度大于JVM所允许的范围，会抛出StackOverflowError的错误，不过这个深度范围不是一个恒定的值
局部变量表所需的内存空间实在编译期间完成分配，运行期不会改变；
异常：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；当虚拟机在动态扩展时候无法申请到足够的内存，将抛出 OutOfMemoryError 异常；
程序计数器（Program Counter Register）：是当前线程所执行的字节码的行号指示器，描述字节码解释权工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，线程在执行字节码时候，执行完当前字节码之后，指定下一行字节码的位置在哪（因为执行可以顺序也可以跳转）；
是线程所私有的内存空间（或者说是数据结构），针对多线程，本质上是通过线程轮流切换并分配处理器执行时间的方式实现，即在任意一个确定时刻，一个处理器都只会执行一条线程中的指令，因此切换执行下一个线程需要记住上一个线程挂起到什么位置（便于恢复到正确的执行位置），因此每个线程都有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储；如果线程执行的是一个 Java 方法，则计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是 Native 方法，则计数器值为空（Undefined）； 本地方法栈（Native Method Stack）：方法上加上 Native 关键字，表示该方法是有 C/C++ 实现，不是 Java 实现的，即主要用于执行本地方法；同样会抛出 StackOverflowError 和 OutOfMemoryError 异常。
虚拟机栈和本地方法栈区别：前者是为虚拟机执行 Java 方法（即字节码）服务，后者是为虚拟机使用到的 Native 方法服务。虚拟机规范中对该部分没有强制规范， Hotspot 虚拟机直接将本地方法栈和虚拟机栈合二为一。 堆（Heap）：在虚拟机启动时候创建，对所有线程共享，存放绝大部分的对象实例（部分会使用栈上分配，标量替换 技术存放在其他位置），Java 中不能直接使用对象，只能通过引用方式获取该对象然后使用它，引用作为一个变量是在栈中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e079361d0e481a0386461233fb4d04c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ea3863d0f5f0fd3f261ff8938753a93/" rel="bookmark">
			FPGA资源利用率报告中的LUT和LUTRAM有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过Report Utilization查看资源利用率报告时，会生成如下图所示的一个表格。在这个表格中Resource对应的列会有LUT和LUTRAM，那么两者到底有什么区别呢？是包含关系吗？不过，可以断定的是LUTRAM是指将LUT用做分布式RAM/ROM，换句话说是指SLICEM中的LUT被用做了存储单元，那么这里的存储单元是否包含移位寄存器（SRL）呢？
为了验证我们看如下一个设计。这个设计包含三个模块：5-bit计数器（会消耗1个LUT），32x1（深度为32，宽度为1）的分布式RAM（会消耗1个SLICEM中的LUT），深度为32的移位寄存器（会消耗1个SLICEM中的LUT）。
对每个模块采用OOC综合方式，可以验证上述对每个模块LUT利用率推断的正确性，如下图所示。
打开布线后的DCP，执行report_utilization命令，结果如下图所示。可以看到该设计共消耗了3个LUT，2个LUTRAM。
事实上，从Available对应列可以看到LUT对应的数据为41000，而该数据指的是FPGA中所有LUT的个数。
结论：
-资源利用率中的LUT是指设计中消耗的所有LUT，包括用做逻辑函数发生器的LUT（SLICEL中的LUT），也包括用做存储单元的LUT（SLICEM中的LUT）
-资源利用率报告中的LUTRAM是指设计中消耗的SLICEM中的LUT（用做分布式RAM/ROM或移位寄存器）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d50fb480816e8a3eecb12ff0d1ac790d/" rel="bookmark">
			C&#43;&#43;链表的应用实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题一：编写一个算法判断链表中的数据项是否按从小到大排序,该链表的第一个节点由first指向。
题二：对于给定的整数n，编写一个算法把新节点插入到链表中第n个节点之后的位置，该链表的第一个节点由first指向。
题三：编写一个算法来颠倒一个链表，该链表的第一个节点由first指向。不要复制列表元素，而是重置链接和指针，是的first指向原来的最后一个节点，且节点之间的所有链接都反向。
#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #define COUNT 5 //初始5个结点的链表 struct node { int num; node *next; }; node *creat(); //创建新链表（5个结点） void print(node *); //遍历链表 node *add(node *); //添加\插入一个结点 int isSort(node *); //判断其数据项是否按从小到大排列 node *reverse(node *); //反转链表 void main() { node *first; first = creat(); print(first); first = add(first); print(first); first = reverse(first); print(first); if (0 == isSort(first)) printf("不是按从小到大排序\n"); else printf("是按从小到大排序\n"); } node *creat() { node *p1, *p2, *first; first = NULL; p1 = p2 = (node *)malloc(sizeof(node)); p1-&gt;num = 1; //头结点 first = p1; for (int i = 1; i &lt;= COUNT; i++) { p1 = (node *)malloc(sizeof(node)); p1-&gt;num = (100 * rand()) / (RAND_MAX * 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d50fb480816e8a3eecb12ff0d1ac790d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d82903ca8af7b9392d3cff0e87975b9/" rel="bookmark">
			java 重写equals方法的种种“坑”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重写java object类的equals方法 覆盖equals方法请遵守约定什么情况下要覆盖equals方法容易违反的对称性不易察觉的传递性 覆盖equals请遵守通用约定 似乎覆盖equals方法看起来似乎是一件平常甚至极其简单的事情， 但是有许多覆盖方式会导致错误，并且会表现出超出预期的行为， 而有可能数小时也无法找到错误的位置。（比如说把参数改成了非Object类型） 1. 类的每一个实例在本质上都是唯一的
（ 从内存的角度来讲是这样的），对于代表活动而不是值(value)的类来说更是如此， 例如Thread。 Object提供equals的实现对于这些类来说是正确的行为 2. 类没有必要提供“逻辑相等”的测试功能
3.超类已经覆盖了equals方法，超类的行为对于子类来说同样也是合适的
4.类是私有的或者是包级私有的，可以确定它的equals方法永远不会被外界调用
如果非常想规避风险，可以覆盖equals方法， 来确保来自Object或者超类的方法永远不会被意外调用。 那么什么时候应该覆盖equals方法 如果类具有自己特有的“逻辑相等”概念（不同于对象等同的概念） 而且超类没有覆盖equals方法。这通常属于"值类"(value class)的情形 例如 一个圆 Circle类，内有一个私有的成员变量radius半径 可以认为，radius相等代表了两个实例在逻辑上相等（或许可以再加上坐标） 再看String类，程序员在利用equals方法比较值对象的引用时， 更希望知道它们逻辑上是否相等，而不希望知道它们到底是不是同一个对象 为满足要求，不仅必须覆盖equals方法， 而且这样做也使得这个类的实例 可以被用作映射表 (map) 的键 (key) ，或者集合set的元素， 使其表现出符合预期的行为 注意：有一种“值类”不需要覆盖equals方法
即实例受控，甚至于单例模式，
确保每个实例的“值”至多只存在一个对象，甚至仅能存在一个实例
（好像太严格了，不过只能存在一个对象有什么可比的呢，就像客户端只能有一个连接服务器的socket类实例一样）
覆盖equals时请遵守通用约定 自反性，对称性以及传递性是最基础的约定 x.equals(x) = x.equals(x) (好像很傻)
x.equals(y) = y.equals(x）(这也是最容易出现问题的地方）
x.equals(y) = y.equals(z) 那么x.equals(z) == true
一致性： 对于任何非null引用值x和y,只要equals方法的比较操作在对象中引用的信息没有被修该，多次调用x.equals(y)返回的结果一致
对于任何非null的引用值x,x.equals(null)必须返回false 下面是一个不区分大小写字符串类的定义（注意 是反例！！违反了对称性）
public class CaseInsensitiveString { private final String s;//存有不可变字符串s public CaseInsensitiveString(String s) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d82903ca8af7b9392d3cff0e87975b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/008b458c77da58e2c6be1cae8385078e/" rel="bookmark">
			什么是西安80坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概述
西安80坐标系，即1980年国家大地坐标系，采用地球椭球基本参数为1975年国际大地测量与地球物理联合会第十六届大会推荐的数据。该坐标系的大地原点设在我国中部的陕西省西安市西北方向60公里处的泾阳县永乐镇，又简称西安大地原点。基准面采用青岛大港验潮站1952－1979年确定的黄海平均海水面（即1985国家高程基准）。
2. 椭球参数
西安80椭球参数采用IUG 1975年大会推荐的参数，因而可得西安80椭球两个最常用的几何参数为：
长半轴a=6378140±5（m）
短半轴b=6356755.2882m
扁 率α=1/298.2570
第一偏心率平方 =0.00669438499959 第二偏心率平方=0.00673950181947
参考椭球
3. 坐标系特点
(1)椭球参数与克拉索夫斯基椭球相比精度高。
(2)椭球有4个参数，是一套完整的数值，既确定了几何形状，又表明了地球的基本物理特征，从而将大地测量学与大地重力学的基本参数统一起来。
(3)椭球参数与国际天文学会(IAU)决定从1984年启用的新天文常数系统中的地球椭球参数相一致。
(4)与1954年北京坐标系相比，轴系与参考基本面明确。
(5)通过椭球定位，参考椭球与我国似大地水准符合较好，高程异常的等值线零线有两条穿过我国东部和西部，一般地区高程异常在+20m ~ -20m之间。
(6)该坐标系是综合利用我国30年来天文、重力、三角测量资料建成的我国自己的大地坐标系。
地球椭球体
4. 分带方式
西安80坐标采用投影坐标系，可以使用3度分带或者6度分带。很多大城市在西安80的基础上进一步演算，制定了各自的城市坐标系，如杭州城市坐标系就是基于西安80的。西安80的坐标值，Y应该为6位（无带号）或者8位（有带号），X应该为7位。
分带表（部分）
5. 适用范围
因为西安80是我国制定的国家大地坐标系，因此超出我国范围的坐标值是没有意义的。 目前仍旧在使用中的我国大地坐标系有：北京54、西安80、国家2000，其中北京54和西安80逐步会替换为国家2000。
1980年野外控制点测量
6. 大地原点选址考量
西安80坐标系的坐标原点在陕西省泾阳县永乐镇。为什么这里成了"天选之地"呢？
（1）地处我国领土的中部，几乎是我国的几何中心。
（2）地质构造稳定，八百里秦川关中腹地，地下都是淤积的黄土，地质灾害威胁较小。
（3）地下物质稳定，周围没有矿藏资源，历史上也从未出现过大水灾，因此，人为挖掘和自然灾害威胁较小，大地原点设在这里基本上是安全稳定的。
我国大地坐标原点
7. 同其他坐标系之间的转换
在实际运用的过程中，往往会涉及到西安80坐标系同别的坐标系之间的转换，这一点，可以使用水经注万能地图下载器，在导出的时候可以选择西安80等各种坐标系，如下图所示。
坐标转换
8. 结语
以上就是西安80坐标系的详细说明，主要包括了椭球参数、坐标系特点、分带方式、适用范围、大地原点选址考量和同其他坐标系之间的转换等功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da499d8d05fb0bd9b99c5fd53987268c/" rel="bookmark">
			【笔记】YOLOv3&#43;darknet实现目标识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、安装OPENCV3.41、安装配置相关工具及依赖库2、从官网下载源码3、安装过程（1）将zip文件解压到当前目录（2）进入解压后的文件夹（3）创建一个编译需要的临时文件夹build，并进入（4）cmake一下（5）进行make编译，需要很久，静静等待（6）进行make install安装 二、编译darknet1、首先要安装Darknet，拷贝他们的github：2、修改Makefile3、修改.weights文件保存时机4、然后进入` darknet/`文件夹进行编译：5、下载在ImageNet预训练过的网络参数weight，选择YOLOv3-tiny版本的：6、测试`darknet`，用`data/`文件夹里的测试图进行测试： 三、创建自定义数据集1、获取训练集样本2、利用LabelImg标记训练样本，获得每张图片对应的.txt文件(1）添加自己的类(2)打开工具，标记生成对应文件 3、汇总.txt文件 四、训练YOLOv3-tiny模型1、获取训练所必须的文件（1）`yolov3-tiny.conv.15`（2）`yolov3-tiny-bot.cfg`（3）`bot.data`（4）`bot.names` 2、开始训练3、输出日记解释 五、结果测试后记1、断点继续训练2、Nan3、训练日志可视化4、YOLOV3无法加载图片"cannot load image" 参考资料 本文中的YOLOv3是在Linux下进行测试的，如不需要OPENCV，可以不安装，Makefile中的对应选项也不用更改
一、安装OPENCV3.4 目前darknet c框架只支持opencv2.x和3.x。如果想要运行在opencv4.x上，需要首先修改Makefile来显性指定opencv版本为4.x，具体办法请自行百度，这里我们直接用OPENCV3.4.7
1、安装配置相关工具及依赖库 sudo apt-get install build-essential #必须的，gcc编译环境 sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev #必须的,包括cmake等工具 sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev #可选的，看个人需要，总共5M左右 如出现无法定位软件包：libjasper-dev，在代码中把这个删掉再执行
2、从官网下载源码 官网地址：https://opencv.org/releases.html
3、安装过程 这是官方的安装教程，但是执行的时候有些地方需要更改
（1）将zip文件解压到当前目录 unzip opencv-3.4.7.zip -d . （2）进入解压后的文件夹 cd opencv-3.4.7 （3）创建一个编译需要的临时文件夹build，并进入 mkdir build cd build/ （4）cmake一下 cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da499d8d05fb0bd9b99c5fd53987268c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b4c9e9487c593a6f5632c5b0a6fa369/" rel="bookmark">
			C# byte数组与16进制字符串相互转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网络通信中常利用字节数组（byte[]） 收发数据，是因为计算机中只能识别0/1编码，一个字节Byte 占8 位 bit（0/1编码），非常方便的表达二进制bit流 的传输序列。而网络抓包或收发数据包检测分析时常利用16进制格式显示，因为二进制书写较长，难以记忆，而每4个二进制位对应1个16进制位，两位16进制的数刚好表达一个字节（8位）,比较直观。
二进制和16进制之间具有对应关系见下表：
例如：180 对应的二进制为：10110100 ，由上表得到 1011 = B, 0100=4 ,所有180的16进制表示为：B4
例如下图：字符串ASCII编码后对应的16进制表示：
在C#中有一个数据基本类型byte表示范围0到255，经常需要进行字符串转16进制、及16进制与byte或byte[]的转化。
1：单个byte转16进制字符串 byte _byte = 97; string result= Convert.ToString(_byte, 16);// result="61" 不足2位补零：例如换行符：\n 对应ASCII表的10进制为10.
byte _byte = 10; string result= Convert.ToString(_byte, 16); // a result = _byte.ToString("X2"); //0A 或小写 .ToString("x2") 变成0a 2：byte[]转16进制字符串 有了上面的情形1，byte数组转16进制字符串，只需要循环逐个转换，然后拼接所有字符串返回结果即可，代码如下： /// &lt;summary&gt; /// 字节数组转16进制字符串：空格分隔 /// &lt;/summary&gt; /// &lt;param name="byteDatas"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string ToHexStrFromByte(this byte[] byteDatas) { StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; byteDatas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b4c9e9487c593a6f5632c5b0a6fa369/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f6ebf3692c098250205d96cabfe03c3/" rel="bookmark">
			python使用nibabel和sitk读取保存nii.gz文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 nii.gz格式是医学图像常用的压缩格式，python中可用nibabel和sitk来读取保存。
使用nibabel 由于使用nibabel图像会旋转90度，所以读取保存的时候还得保存映射信息，3维图像格式为（z, x, y）
读取nii.gz文件
img = nib.load('xxxxx.nii.gz') img_affine = img.affine img = img.get_data() 保存nii.gz文件
nib.Nifti1Image(img,img_affine).to_filename('xxxxx.nii.gz') 使用sitk 使用sitk读取nii时，读取出来的还是图片格式，可以使用他自带的函数进行处理，不过速度比较慢，建议使用GetArrayFromImage转换成numpy格式再处理，3维图像格式为（x, y, z）
读取nii.gz文件
img = sitk.ReadImage('xxxxx.nii.gz') img = sitk.GetArrayFromImage(img) 保存nii.gz文件
out = sitk.GetImageFromArray(img) sitk.WriteImage(out,'xxxxx.nii.gz') 在numpy数组和nibabel或sitk中相互转换时，要注意数据的格式，一般保存为int或uint类型。比如输入nii为16位有符号整型时，我们可能需要转换成0~255灰度图，可用如下代码：
img = sitk.ReadImage('xxxxx.nii.gz') img = sitk.Cast(sitk.RescaleIntensity(img),sitk.sitkUInt8) img = sitk.GetArrayFromImage(img) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f888f4f905f9cdf393c04eccfc88431/" rel="bookmark">
			Argument list too long” 错误与解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		crontab -e 编辑完后保存退出后，报错 no space left on device
根据上面的报错了解到是磁盘空间满了，那么首先是检查磁盘空间。
df -h 查看到是 /var 磁盘分区空间已经达到 100%，至此定位了问题所在。是 /var 磁盘空间饱满导致，因为 crontab 会在保存时将文件信息写到 / var 目录下面，然而这个磁盘没有空间了，所以报错。
接着通过命令 du –sh * 命令检查 / var 目录下面的所有文件或者目录的大小，发现 /var/spool/clientmqueue 目录占用了 /var 整个分区大小的 90%，那么 /var/spool/clientmqueue 目录下的文件都是怎么产生的，能否删除，基本上都是邮件信息，可以删除。
rm * /bin/rm :argument list too long
当在 linux 系统中试图传递太多参数给一个命令时，就会出现 “argument list too long” 错误，这是 linux 系统一直以来都有的限制，查看这个限制可以通过命令 “getconf ARG_MAX” 来实现，
getconf ARG_MAX more /etc/issue 查看版本 解决方法：
1、
rm [a-n]* -rf rm [o-z]* -rf 2、使用 find 命令来删除
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f888f4f905f9cdf393c04eccfc88431/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65177ad4ba987e91ba2de44254cd8e1f/" rel="bookmark">
			ECharts入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@{ Layout = null; } &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src="~/echarts.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 var option = { title: { text: 'ECharts 入门示例' }, tooltip: {}, legend: { data: ['销量'] }, xAxis: { data: ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] }; // 使用刚指定的配置项和数据显示图表。 myChart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65177ad4ba987e91ba2de44254cd8e1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c5f6d1ec9eadfffba6229626b29675/" rel="bookmark">
			【Python】—日志模块logging使用详解1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、日志级别2、logging流程3、几个重要的类3.1 Logger类1) 最常用的配置方法2) 创建`Logger`对象`logging.getLogger([name])` 3.2 `Handler`类3.3 `Filter`类3.4 `Formatter`类 4. 使用示例4.1 直接调用`logging`接口4.2 使用`basicConfig()`函数4.3 一步步配置`Logger`4.4 通过`dictConfig`配置4.4.1 `dictConfig()`4.4.2 配置规则4.4.3 配置示例 开发部署项目时，不可能将所有的信息都输出到控制台中，因此我们将这些信息记录到日志文件中，不仅方便查看程序运行的情况，也可以在项目出现故障时根据该运行时产生的日志快速定位问题。 Python中提供了日志模块logging，可以方便的记录日志信息。
本文主要分析了logging模块的相关知识及具体使用。
当前介绍该日志模块的文章有很多，之所以还要进行记录，一方面是因为没有看到系统的介绍，二是通过梳理此部分内容，做到不止会用，还明白内部函数调用。
1、日志级别 Python标准库logging用做记录日志，默认分为五种日志级别：
DEBUG(10)：详细信息，调试问题时所需INFO(20)：证明事情可按预期工作WARNING(30)：有意外，将来可能发生问题，但依然可用ERROR(40)：严重问题，程序不能执行一些功能CRITICAL(50)：严重错误 我们自定义日志级别时注意不要和默认的日志级别数值型相同（这是什么意思呢），logging执行时输出大于等于设置的值日级别的日志信息，如设置级别为INFO，则INFO, WARNING, ERROR, CRITICAL级别的日志都会输出。
5种等级分别对应5种日志打印方法：debug, info, warning, error, critical。
默认的是WARNING，即当等级大于等于WARNING才被跟踪。
2、logging流程 官方的logging模块工作流程图如下：
logging流程图 从上图中可以看到这几种python类型，Logger, LogRecord, Filter, Handler, Formatter。
类型说明
Logger：日志，暴露函数给应用程序，基于日志记录器和过滤器级别决定哪些日志有效。LogRecord：日志记录器，将日志传到相应的处理器处理。Handler：处理器，将（日志记录器产生的）日志记录发送至合适的目的地。Filter：过滤器，提供了更好的粒度控制，它可以决定输出哪些日志记录。Formatter：格式化器，指明了最终输出中日志记录的布局。 基本流程:
判断Logger对象对于设置的级别是否可用，如果可用，则往下执行，否则，流程结束。创建LogRecord对象，如果注册到Logger对象中的Filter对象过滤后返回False， 则不记录日志，流程结束，否则，向下执行。LogRecord对象将Handler对象传入当前的Logger对象，（图中子流程）如果Handler对象的日志级别大于设置的日记级别，再判断注册到Handler对象中的Filter对象过滤后是否返回True而放行输出日志信息，否则不放行，流程结束。如果传入的Handler大于Logger中设置的级别，也即Handler有效，则往下执行，否则，流程结束。判断这个Logger对象是否还有父Logger对象，如果没有（代表当前Logger对象是最顶层的Logger对象root Logger），流程结束。否则将Logger对象设置为它的父Logger对象，重复上面3,4两步，输出父类Logger对象中的日志输出，直到是root Logger对象。 3、几个重要的类 前面讲logging流程的时候，提到几个概念：Logger，Handler，Filter，Formatter。
3.1 Logger类 Logger对象有3个任务要做：
向应用程序代码暴露info, debug等方法，使应用程序可以在运行时记录日志消息基于日志级别（默认的过滤设施）或Filter对象来决定要对哪些日志进行后续处理将日志消息传送给所有感兴趣的日志handlers 一个系统只有一个根Logger对象，并且该对象不能被直接实例化。
通过调用logging.getLogger(name)函数创建Logger类对象。
Logger对象最常用的方法有两类：（1）配置方法，（2）消息发送方法
Logger对象可以设置多个Handler对象和Filter对象，Handler对象可以设置Formatter对象。
Formatter对象用来设置消息的具体输出格式。
1) 最常用的配置方法 方法描述Logger.setLevel设置日志器将会处理的日志消息的最低严重级别Logger.addHandler()为该Logger对象添加一个handler对象Logger.removeHandler为该Logger对象移除一个handler对象Logger.addFilter()和Logger.removeFilter()为该Logger对象添加 和 移除一个filter对象 logger对象配置完成后，可使用下面的方法来创建日志记录：
Logger.debug(), Logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1c5f6d1ec9eadfffba6229626b29675/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/697ac523bbc79571505350e8ecde7f68/" rel="bookmark">
			python--列表、字符串、字典、元组之间的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 列表、字符串、字典、元组之间的转换1. 列表与字符串的相互转换列表转字符串字符串转列表 2. 列表与字典的相互转换列表转字典两个列表转字典嵌套列表转字典 字典转列表 3. 字典与字符串的相互转换字符串转字典字典转字符串 4. 元组与字符串的相互转换元组转字符串字符串转元组 5. 元组与列表的相互转换元组转列表列表转元组 6. 元组与字典的相互转换元组转字典字典转元组 列表、字符串、字典、元组之间的转换 1. 列表与字符串的相互转换 列表转字符串 将列表中的元素用特定的符号连接成一个字符串：
In [1]: list1 = ['a','b','c'] In [2]: str1 = ''.join(list1) In [3]: str1 Out[3]: 'abc' 例子中用空字符连接，也就是元素之间直接连接。也可以用别的字符，如“-”，如下所示：
In [4]: str1 = '-'.join(list1) In [5]: str1 Out[5]: 'a-b-c' 不过，上述例子仅适用与列表中的元素都是字符串，如果列表中还包含数值等其他类型元素，可以增加一步将列表中的每个元素都转字符串，如下：
In [8]: list1 = ['a',7,'b',8,'c'] In [9]: list2 = [str(it) for it in list1] In [10]: list2 Out[10]: ['a', '7', 'b', '8', 'c'] 或者还有列表中包含列表元素：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/697ac523bbc79571505350e8ecde7f68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/277999f95b656f9f821e4e66d9809895/" rel="bookmark">
			Android Studio各个版本的下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.android-studio.org/index.php/download/hisversion/ （官方）
https://www.androiddevtools.cn/（非官方）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1176e2116d869fb77e2cc13ab31716f3/" rel="bookmark">
			记一次python mem排错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker run 一个容器（多个测试样例）。结果显示 有个测试样例被 killed 。
docker stats 查看 ，发现内存接近90G；而我实际运行时 只有 1G的内存。所以被killed。
[root@a34h05007.cloud.h05.amtest87 /root] #docker stats --no-stream|head -n 1;while [[ true ]];do echo time sleep 1 &gt;/dev/null 2&gt;&amp;1;docker stats --no-stream|grep aedfae9724a8;done CONTAINER CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS aedfae9724a8 119.02% 85.88 GiB / 94.28 GiB 91.08% 0 B / 0 B 12.29 kB / 33.52 MB 4 aedfae9724a8 126.96% 86.16 GiB / 94.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1176e2116d869fb77e2cc13ab31716f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbca1d6b836b28fbee23aef470184445/" rel="bookmark">
			FFmpeg从入门到牛掰（四）：音频编码(encode )讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明出处：https://blog.csdn.net/impingo
项目地址：https://github.com/im-pingo/pingos
音频编码讲解 流程描述函数接口和流程音频编码代码示例QQ交流群：697773082 流程描述 上篇文章【FFmpeg从入门到牛掰（三）：音频解码(decode)讲解】介绍了音频解码的过程，所谓解码就是将AAC、mp3这类音频压缩算法处理过的数据还原成pcm数据的过程，那么音频编码就是用AAC、mp3这类音频压缩算法处理pcm数据的过程。
在ffmpeg中，AVPacket用来保存一个编码后的数据，AVFrame结构用来保存pcm数据和yuv数据。
函数接口和流程 获得你所需的编解码器，可以使用以下两个函数，前者是通过AVCodecID（如AV_CODEC_ID_OPUS）获取ffmpeg支持的编解码器，后者是通过编解码器的名称（如：“libopus”）返回ffmpeg支持的编解码器。 AVCodec codec = avcodec_find_decoder(AV_CODEC_ID_OPUS); //等价于 AVCodec codec = avcodec_find_encoder_by_name("libopus"); 根据获得的AVCodec指针，创建编码器上下文指针，后续的编码操作都是围绕着这个指针进行操作。 AVCodecContext *c = avcodec_alloc_context3(codec); 设置编码器参数 c-&gt;bit_rate = 48000; c-&gt;sample_fmt = AV_SAMPLE_FMT_S16; if (!check_sample_fmt(codec, c-&gt;sample_fmt)) { fprintf(stderr, "Encoder does not support sample format %s", av_get_sample_fmt_name(c-&gt;sample_fmt)); exit(1); } c-&gt;sample_rate = select_sample_rate(codec); c-&gt;channel_layout = select_channel_layout(codec); c-&gt;channels = av_get_channel_layout_nb_channels(c-&gt;channel_layout); 打开编码器 /* * int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options) * */ AVDictionary* opts = NULL; av_dict_set(&amp;opts, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbca1d6b836b28fbee23aef470184445/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/547d424240d9f440def3bf4d84a0617c/" rel="bookmark">
			turtle复习，试着用turtle画一个有颜色填充的三角形！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 加深学习turtel:画一个有颜色填充的三角形吧！ import turtle turtle.hideturtle() turtle.speed(5) turtle.penup() turtle.pendown() turtle.write("A") turtle.begin_fill() turtle.forward(200) turtle.dot(5) turtle.penup() turtle.goto(205,0) turtle.pendown() turtle.write("B") turtle.penup() turtle.goto(200,0) turtle.pendown() turtle.left(90) turtle.forward(200) turtle.dot(5) turtle.penup() turtle.goto(202,202) turtle.pendown() turtle.write("C") turtle.penup() turtle.goto(200,200) turtle.pendown() turtle.left(135) turtle.forward(282) turtle.dot(5) turtle.end_fill() turtle.penup() turtle.goto(50,-50) turtle.pendown() turtle.write("比较标准的一个三角形") turtle.done() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec74d7abb8f9f58ebd70128086c7a649/" rel="bookmark">
			关于TypeError: Cannot read property &#39;validate&#39; of undefined     at VueComponent.submitForm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue集成element-UI报错 解决办法: ref里面关键字和$refs要一致（也就是这里的loginForm）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be58b713be17bd2a48d45a942a62eac5/" rel="bookmark">
			无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用 sudo apt-get install 安装软件时， 出现错误 “无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系”。
错误的主要原因是，系统中已经安装了被依赖的包的高版本。
例如在安装 gcc-4.8-multilib 时，依赖 libc6-dev-x32 ，但是系统中已经安装了***libc6-dev-x32*** ，并且版本高于所要求的版本，导致安装失败。
解决方法一 安装指定版本的被依赖包
sudo apt-get install libc6-dev-x32 &gt;= 2.11 解决方法二 使用aptitude进行安装，aptitude 会对依赖关系进行智能处理
sudo apt-get install aptitude sudo aptitude install &lt;package name&gt; 安装 aptitude使用 aptitude 安装包 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/132e69921f66b0657b75ad1d6f96304d/" rel="bookmark">
			python中的@运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在看fastai的代码时，看到这么一段：
n=100 x = torch.ones(n,2) x[:,0].uniform_(-1.,1) x[:5] a = tensor(3.,2) y = x@a + torch.rand(n) 这里面有个@符号不知道是啥意思？
于是百度搜了一下，都是说@xxx是注解或者装饰器，明显不是这段代码的场景嘛！
于是又Google了一下，原来这个@是Python 3.5之后加入的矩阵乘法运算符，终于明白了！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/450/">«</a>
	<span class="pagination__item pagination__item--current">451/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/452/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>