<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fd5dcfa30574e5bd503c6e496b8b1c6/" rel="bookmark">
			ACL | 自然语言处理（NLP）之多轮对话建模优化（Utterance ReWriter）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：AINLPer微信公众号
编辑: ShuYini
校稿: ShuYini
时间: 2019-8-4
引言 最近2019年新鲜的ACL论文出来了，发现了一篇关于多轮对话模型的文章还不错，其题目为：Improving Multi-turn Dialogue Modelling with Utterance ReWriter。文章单位：微信人工智能模式识别中心（腾讯）。文章的背景为：当前我们在日常多轮交流的时候，经常会出现前后相互参照和信息遗漏的问题，这对于人来说能够正确的理解出说话人的意图，但是对于机器来说，这是比较困难的。为此该篇文章提出了：为提高多轮会话模型水平，将重写人类的话语作为其一个预处理过程。每句话都要重写一遍，以恢复所有相关和省略的信息。然后根据重写的话语执行下一步处理步骤。为了更好地训练语音重写器，文章收集了一个带有人工注释的新数据集，并利用指针网络引入了一种基于转换的语音重写体系结构。
PS：欢迎关注AINLPer微信公众号，论文解读会每日更新，等你来看。
本文概述 当前对话系统中，对于单轮对话的模型建模来说已经相对比较成熟一点，但是对于多轮对话来说仍然具有比较大的挑战。其最大的挑战就是在多轮对话中存在共指关系和信息缺失。如下图所示：
为了解决多轮对话中的共指关系和信息缺失的问题，本文的思路是训练一个言语重写器将多轮对话转换成单轮对话，其目的就和上图所示，将Utterance3改成Utterrance3`。由于把信息补全了，所以此时的多轮就相当于单轮对话了，将其输入到对话系统中，就可以按照单轮对话来处理了。为了训练言语重写器，文章创建了包含2万个多轮对话数据集，并且每句话都是成对的存在的；提出了一种高效的基于转换的话语改写器，其性能优于其它几个比较强的基线版本；最后将话语改写器应用到现实生活中的在线聊天机器人中，得到比较显著的改进效果。
数据集介绍 为了获得句子改写器模型的并行训练数据，我们从几个流行的中国社交媒体平台上抓取了200k个候选的多轮会话数据，供标注者使用。敏感信息会预先过滤，以便以后处理。在开始标注之前，我们随机抽取了2000个会话数据，并分析了多轮对话中出现共引用和省略的频率。
表2列出了统计数据。可以看出，只有不到30%的话语既没有共参也没有省略，相当多的话语既没有共参也没有省略。这进一步证实了在多轮对话中处理这些情况的重要性。
模型介绍 问题定义 定义每个训练样本为： ( H , U n → R ) (H,U_n \to{R} ) (H,Un​→R) ，其中 H = { U 1 , U 2 , . . . , U n − 1 } H=\left\{U_1,U_2,...,U_{n-1}\right\} H={U1​,U2​,...,Un−1​}表示前n-1轮的会话历史， U n U_n Un​表示第n轮的会话前，R表示消除共指关系和信息缺失后输出的言语。训练Utterance ReWriter目标根据会话历史数据自动推断出重写的 U n U_n Un​。该过程首先将 ( H , U n ) (H,U_n) (H,Un​)编码为向量s序列，然后利用指针网络对R进行解码。整个模型架构图如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fd5dcfa30574e5bd503c6e496b8b1c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e68d545034cec71299332ae7e632846/" rel="bookmark">
			c&#43;&#43;类的构造函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class Class_dele
{
public:
//委托构造函数体有代码的话会先运行函数中代码，然后才会返回到委托者
Class_dele(string str, int num, char ch):
classstr(str), classnum(num), classch(ch)
{
cout &lt;&lt;"not "&lt;&lt; classstr &lt;&lt; " " &lt;&lt; classnum &lt;&lt; " " &lt;&lt; classch &lt;&lt; endl;
}
//构造函数的默认值
Class_dele() :Class_dele("str1",1,'a') {}
Class_dele(string sstr) :Class_dele(sstr, 2, 'b')
{
cout &lt;&lt;"weituo "&lt;&lt; classstr &lt;&lt; " " &lt;&lt; classnum &lt;&lt; " " &lt;&lt; classch &lt;&lt; endl;
}
Class_dele(int num) : Class_dele()
{
cout &lt;&lt; num &lt;&lt;" "&lt;&lt; classstr &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e68d545034cec71299332ae7e632846/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78e9f02a1d058f5aaa415ecb855e3e65/" rel="bookmark">
			BGP详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BGP协议详解 BGP是一种边界网关协议。但是也属于动态路由协议。
一.BGP的特征（一种外部路由协议，用来在AS之间传递路由信息，是一种增强版的距离矢量协议）
1.可靠的路由更新机制
传输协议：TCP，短口号：179（可跨越设备更新RIB）
无需周期性更新
路由更新：只发生增量路由，原因：路由表太过庞大
周期性发送Keepalive报文检测TCP连通性（与OSPF的不同点，发送的不再是hello报文）
2.丰富的METRIC度量方法
3.从设计上避免了环路的发生
4.为路由附带属性信息
5.支持CIDR
6.丰富的路由过滤的路由策略
二.BGP的报文类型
Type 1——Open（打开）消息
携带自身的能力，信息，RID，等去尽力BGP邻居
Type 2——Update（更新）消息
更新和撤销NLRI----网络层可达消息（网络前缀）—包括丰富的路由属性
Type 3——Keepalive（保持激活）消息
保持TCP活跃的。（第一个Keepalive要买回来确认邻居关系是否建立成功）
Type 4——Notification（通告）消息
差错报文，对错误的配置进行响应，具有差错检测功能，当检测到错误时，会向对等体发送notification消息，并关闭BGP连接；
Type 5——Refresh（刷新）消息
BGP刷新路由的能力
两种邻居关系:
IBGP：internal bgp（AS号码相同）
EBGP：external bgp（AS号码不同）
三.BGP通告路由的方式（建立在TCP基础上的邻居关系）
1.Network
BGP通告的为路由（本身的直连，通告从其他协议得到的路由：IGP）
2.引入路由（重分布）：import-route
3.Aggregate（汇聚）产生路由
以上为产生BGP路由
IBGP通常用loopback作为更新源建立邻居关系（原因：更加稳定）
TCP的五元组（源IP，原目的端口，协议）
BGP的跟信源即是源IP（PEER xx（）目的IP，connectint 100）
ebgp通常采用直连来建立邻居，也可以用环回口备份
1.在R1R2建立直连的ebgp
bgp 200 peer 123.1.1.1 as 100 bgp 100 peer 123.1.1.1 as 200 2.R1R3在环回口建立ebgp邻居（EBGP）
bgp 100 peer 33.1.1.1 as number 200 peer 33.1.1.1 ebgp-max-hop 255 peer 33.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78e9f02a1d058f5aaa415ecb855e3e65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b40b8b30982e78ba10b945fb3164f6c0/" rel="bookmark">
			ES6 JSON
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		json：
1、JSON对象：
JSON.stringify
JSON.parse
2、JSON简写：
（1）属性和属性值（key、value）的名字是一样的时候可以只保留其中一个（如{a:a, b:b}=&gt;{a, b}）；
（2）方法 当函数中有:function时，可以把:function删掉。
3、json标准写法：
（1）名字和字符串值只能用双引号；
（2）所有的名字都必须用双引号包起来。
&lt;script&gt; // json对象 /* let json = { a: 1, b: 5 } // JSON.stringify输出json格式的数据（字符串变为JSON数据） // let str = JSON.stringify(json)	// encodeURIComponent把json数据加密为URI let str = 'https://www.baidu.com/push/user?data=' + encodeURIComponent(JSON.stringify(json)) alert(str) */ // json数据变为对象（字符串） /* let str = '{"a":1,"b":2,"c":"hr226"}' let json = JSON.parse(str) console.log(json) */ // json简写 /* let a = 1; let b = 2; // let json={a:a,b:b,c:3} let json = {a,b,c: 3} console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b40b8b30982e78ba10b945fb3164f6c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae74371486088af846c49816b26d005b/" rel="bookmark">
			python内置函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python内置函数 abs() abs() 函数返回数字的绝对值。
abs( x )
x -- 数值表达式，可以是整数，浮点数，复数。
​
函数返回 x（数字）的绝对值，如果参数是一个复数，则返回它的大小。 all() all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。
all(iterable)
iterable -- 元组或列表。
​
如果iterable的所有元素不为0、''、False或者iterable为空，all(iterable)返回True，否则返回False；
​
注意：空元组、空列表返回值为True，这里要特别注意。 any() any() 函数用于判断给定的可迭代参数 iterable 是否全部为 False，则返回 False，如果有一个为 True，则返回 True。
any(iterable)
iterable -- 元组或列表。
​
如果都为空、0、false，则返回false，如果不都为空、0、false，则返回true。 ascii() ascii() 函数类似 repr() 函数, 返回一个表示对象的字符串, 但是对于字符串中的非 ASCII 字符则返回通过 repr() 函数使用 \x, \u 或 \U 编码的字符。 生成字符串类似 Python2 版本中 repr() 函数的返回值。
ascii(object)
object -- 对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae74371486088af846c49816b26d005b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea30bcf4148b4b173b3259aa97634c1d/" rel="bookmark">
			C语言运算符优先级（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 学习c语言时，经常使用的到运算符的优先级，网上的总结参差不齐，今天找到一个相对比较完整的运算符优先级的总结，现在分享给大家：
原文转载自embed_huang
说明：
同一优先级的运算符，运算次序由结合方向所决定。 简单记就是：！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e208d54492b2fddb137ccd7351ae2192/" rel="bookmark">
			Python3函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、函数
1. 函数的命名规则
2. 函数的定义与使用
2.1 定义函数
2.2 调用函数
2.3 形参与实参
2.4 可更改与不可更改对象
2.5 函数返回值
3. 函数的参数
3.1 必需参数
3.2 关键字参数
3.3 默认参数
3.4 可变参数
4. 变量的作用域
5. lambda匿名函数
6. 递归函数
7. 高阶函数
8.内置函数
8.1 filter()函数
8.2 map()函数
8.3 reduce()函数
一、函数 函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段所有的函数都有返回值。如果你没有告诉它们该返回什么，将返回None。def语句中，位于函数名后面的变量通常称为形参，而调用函数时提供的值称为实参。字符串以及数和元组是不可变的，意味着不能修改它们（即只能替换为新值）。函数的作用：减少重复代码；方便修改，更易扩展；保持代码一致性。 1. 函数的命名规则 函数名必须以下划线或字母开头，可以包含任意字母、数字和下划线的组合。不能使用任何标点符号。函数名区分大小写。函数名不能是保留字。 2. 函数的定义与使用 2.1 定义函数 Python定义函数使用def关键字，后面必须跟函数名和带括号的形式参数列表和冒号。然后，在缩进块中编写函数体，函数的返回值用return语句返回。
函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量。
格式：def 函数名(参数列表):
函数体
2.2 调用函数 调用函数通过函数名和带括号的实参列表
2.3 形参与实参 形参：形式参数，不是实际存在，是虚拟变量，在定义函数和函数体时使用形参，目的时在函数调用时接收实参（实参个数，类型与实参一一对应）
实参：实际参数，调用函数时传给函数的参数，可以是常量、变量、表达式、函数，传给形参
2.4 可更改与不可更改对象 在Python中，字符串、数字和元组是不可更改的对象，而列表和元组是可更改的对象
2.5 函数返回值 可用return 表达式语句用于把函数作为结果值返回。所有的函数都有返回值。
如果没有return语句，默认会返回一个None。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e208d54492b2fddb137ccd7351ae2192/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/394a6225e4daecd7bb2c6f59c7e58834/" rel="bookmark">
			matlab读取文本文件----textscan
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		textscan 从文本文件或字符串读取格式化数据
全页折叠
语法 C = textscan(fileID,formatSpec)
C = textscan(fileID,formatSpec,N)
C = textscan(chr,formatSpec)
C = textscan(chr,formatSpec,N)
C = textscan(___,Name,Value)
[C,position] = textscan(___)
说明 C = textscan(fileID,formatSpec) 将已打开的文本文件中的数据读取到元胞数组 C。该文本文件由文件标识符 fileID 指示。使用 fopen 可打开文件并获取 fileID 值。完成文件读取后，请调用 fclose(fileID) 来关闭文件。
textscan 尝试将文件中的数据与 formatSpec 中的转换设定符匹配。textscan 函数在整个文件中按 formatSpec 重复扫描数据，直至 formatSpec 找不到匹配的数据时才停止。
C = textscan(fileID,formatSpec,N) 按 formatSpec 读取文件数据 N 次，其中 N 是一个正整数。要在 N 个周期后从文件读取其他数据，请使用原 fileID 再次调用 textscan 进行扫描。如果通过调用具有相同文件标识符 (fileID) 的 textscan 恢复文件的文本扫描，则 textscan 将在上次终止读取的点处自动恢复读取。
C = textscan(chr,formatSpec) 将字符向量 chr 中的文本读取到元胞数组 C 中。从字符向量读取文本时，对 textscan 的每一次重复调用都会从开头位置重新开始扫描。要从上次位置重新开始扫描，需要指定 position 输出参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/394a6225e4daecd7bb2c6f59c7e58834/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a12f374507f380006a8435e04a9df2e4/" rel="bookmark">
			Selenium1、Selenium2、Selenium3的区别，终于讲清楚了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 selenium 1的原理
selenium 1 包括以下两部分：selenium server、 Client Libraries组成
1. selenium server
selenium server负责控制浏览器的行为。主要有launcher，Http Proxy，selenium core。selenium core使用Selenium Server嵌入到浏览器页面中。实质上，selenium core是由JS函数组成，这样我们可以实现用程序对浏览器进行操作。
2. client Libraries
编写测试用例时控制selenium server的库
3. selenium RC与TestCase之间的关系
4. testCase 工作过程
(1).测试案例（Testcase）通过Client Lib的接口向Selenium Server发送Http请求，要求和Selenium Server建立连接。
为什么要通过发送Http请求控制Selenium Server而不采用其他方式呢？从上文可以看出，Selenium Server是一个独立的中间服务器（确切地说是代理服务器），它可以架设在其他机器上！所以测试案例通过发送HTTP请求去控制Selenium Server是很正常的。
(2).Selenium Server的Launcher启动浏览器，把Selenium Core加载入浏览器页面当中，并把浏览器的代理设置为Selenium Server的Http Proxy。
(3).测试案例通过Client Lib的接口向Selenium Server发送Http请求，Selenium Server对请求进行解析，然后通过Http Proxy发送JS命令通知Selenium Core执行操作浏览器的动作。
(4).Selenium Core接收到指令后，执行操作。
(5).浏览器收到新的页面请求信息（因为在(4)中，Selenium Core的操作可能引发新的页面请求），于是发送Http请求，请求新的Web页面。
由于Selenium Server在启动浏览器时做了手脚，所以Selenium Server会接收到所有由它启动的浏览器发送的请求。
(6).Selenium Server接收到浏览器的发送的Http请求后，自己重组Http请求，获取对应的Web页面。
(7).Selenium Server的Http Proxy把接收的Web页面返回给浏览器。
二、 selenium 2-selenium webDriver原理
1. 直接利用浏览器原生的API，封装成更加面向对象的selenium WebDriver API，直接操作浏览器页面里的元素，甚至操作浏览器本身。如：截屏、窗口大小、启动、关闭、安装插件、配置证书等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a12f374507f380006a8435e04a9df2e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/469d9865b85d07fb088123cbd519b035/" rel="bookmark">
			我的世界光影使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		光影使用方法 写这个主要是为了记录下最近捯饬我的世界服务端和客户端时遇到的一些东西，全当随笔了。
首先要确认已经安装了高清补丁，这次使用的客户端版本是1.12.2
1.下载光影压缩包，一般都是zip格式
2.将压缩包放进游戏目录的.minecraft/shaderpacks下
3.进入游戏进行设置，选项-&gt;视频设置-&gt;光影
选择刚才添加的光影即可，一般会卡几秒，设定完成以后就可以使用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3855b99773929a94cbc9d80a2d1b0691/" rel="bookmark">
			qt 自定义控件样式01-QComboBox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、效果
颜色没有定的非常亮丽，可以自行设置，只是将日常设置QComboBox样式用到的一些属性列出来，后续系列也是一样
二、qss样式
QComboBox { border: 1px solid gray;//设置边界线样式 border-radius: 3px;//设置控件四周圆角 padding: 1px 18px 1px 3px;//设置下拉框未打开时显示的内容与边界的距离 min-width: 60px;//最小宽度 } QComboBox:editable { background: white;//QComboBox可编辑状态下的背景颜色，需设置其属性可编辑后才能显示，默认是不可编辑的 } QComboBox:!editable, QComboBox::drop-down:editable //QComboBox不可编辑、下拉子控件可编辑的时候 { background: qlineargradient//背景线性渐变 ( x1: 0, y1: 0, x2: 0, y2: 1,//初始位置，和结束位置 stop: 0 #E1E1E1, stop: 0.4 #DDDDDD,//stop第一个值为位置，第二个值为颜色RGB值 stop: 0.5 #D8D8D8, stop: 1.0 #D3D3D3 ); } /* QComboBox gets the "on" state when the popup is open */ QComboBox:!editable:on, QComboBox::drop-down:editable:on //设置了控件和子控件在下拉框下拉后的样式 { background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #D3D3D3, stop: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3855b99773929a94cbc9d80a2d1b0691/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b15bec812c17c2a21e2265efe6cc1a90/" rel="bookmark">
			HTML 列表去掉前边点和序号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- ol 有序列表 o oder 有序的 l list 列表 --&gt; &lt;!-- ol list-style: none 即可去掉序号 --&gt; &lt;ol style="list-style: none;"&gt; &lt;li&gt;女装&lt;/li&gt; &lt;li&gt;家电&lt;/li&gt; &lt;li&gt;学习&lt;/li&gt; &lt;/ol&gt; &lt;!-- ul un order list 无序列表 --&gt; &lt;ul&gt; &lt;li&gt;女装&lt;/li&gt; &lt;li&gt;家电&lt;/li&gt; &lt;li&gt;学习&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 显示效果:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47f8be9cfad6316ff115d4df6e66789c/" rel="bookmark">
			容器 迭代器源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		容器 迭代器源码解析 标签（空格分隔）： 容器 Iterable Iterator
demo List&lt;String&gt; list = new ArrayList&lt;&gt;(); Iterator&lt;String&gt; iterable = list.iterator(); while (iterable.hasNext()) { String data = iterable.next(); } code public interface Iterable&lt;T&gt; { //迭代器 Iterator&lt;T&gt; iterator(); //遍历元素， default void forEach(Consumer&lt;? super T&gt; action) { //空检查 Objects.requireNonNull(action); //这里要注意一下：foreach增强for循环出自于java5，且遍历的数据源只能是Iterable或者Array数组 for (T t : this) { //遍历回调 action.accept(t); } } //不知道是干啥的，先放放 default Spliterator&lt;T&gt; spliterator() { return Spliterators.spliteratorUnknownSize(iterator(), 0); } } public interface Iterator&lt;E&gt; { //判断是否还有下一个元素 boolean hasNext(); //获取下一个元素 E next(); //移除当前元素 default void remove() { throw new UnsupportedOperationException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47f8be9cfad6316ff115d4df6e66789c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43e51b7ab7252a09ccb110f9b98f8c3d/" rel="bookmark">
			C语言 getchar()原理及易错点解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.getchar()系列1.getchar()工作原理及作用2.使用getchar()清理回车\n3.使用getchar()清理缓存4.混合scanf()与getchar() 一.getchar()系列 1.getchar()工作原理及作用 工作原理：getchar()是stdio.h中的库函数，它的作用是从stdin流中读入一个字符，也就是说，如果stdin有数据的话不用输入它就可以直接读取了，第一次getchar()时，确实需要人工的输入，但是如果你输了多个字符，以后的getchar()再执行时就会直接从缓冲区中读取了。
实际上是 输入设备-&gt;内存缓冲区-&gt;getchar()
你按的键是放进缓冲区了,然后供程序getchar()
你有没有试过按住很多键然后等一会儿会滴滴滴滴响,就是缓冲区满了,你后头按的键没有存进缓冲区.
键盘输入的字符都存到缓冲区内,一旦键入回车,getchar就进入缓冲区读取字符,一次只返回第一个字符作为getchar函数的值,如果有循环或足够多的getchar语句,就会依次读出缓冲区内的所有字符直到’\n’.要理解这一点,之所以你输入的一系列字符被依次读出来,是因为循环的作用使得反复利用getchar在缓冲区里读取字符,而不是getchar可以读取多个字符,事实上getchar每次只能读取一个字符.如果需要取消’\n’的影响,可以用getchar();来清除,这里getchar();只是取得了’\n’但是并没有赋给任何字符变量,所以不会有影响,相当于清除了这个字符.
作用1:从缓冲区读走一个字符，相当于清除缓冲区。
作用2:前面的scanf()在读取输入时会在缓冲区中留下一个字符’\n’（输入完按回车键所致），所以如果不在此加一个getchar()把这个回车符取走的话，接下来的scanf()就不会等待从键盘键入字符，而是会直接取走这个“无用的”回车符，从而导致读取有误。
2.使用getchar()清理回车\n 这个问题转载自n_s_X14,但是作者在文章最后留了一个问题，现在在这里给大家解释一下原因。
文章的源码为：
#include &lt;stdio.h&gt; int main(void){ char m[40]; char n; printf("please input first str:\n"); //提示用户输入第一个字符串 scanf("%s",m); //获取用户第一个输入字符串 printf("you input str is :%s\n",m); //输出用户的输入的第一个字符串 printf("input second char :\n"); //提示用户输入第二个字符 scanf("%c",&amp;n); //获取用户的第二个字符 printf("now you input second char is :%c\n",n);//输出用户输入的第二个字符 return 0; } Output:
please input first str: abc you input str is :abc input second char : now you input second char is : Program ended with exit code: 0 问题：我们第一次输入abc后成功打印出来了you input str is :abc，但是执行到printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43e51b7ab7252a09ccb110f9b98f8c3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e92a603efc3d5bcbf2df3cce39782136/" rel="bookmark">
			浅析如何利用Squish实行 GUI自动化测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.引言
图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的系统操作用户界面。是软件与用户进行交互的主要方式，与早期计算机使用的命令行界面相比，图形界面对于用户来说在视觉上更易于接受、操作上更加便捷直观，它极大的方便了非专业用户的使用，使我们从命令行的操作方式解放出来，取而代之的是可以通过窗口、菜单、按键等方式来方便地进行操作。GUI软件测试是指对拥有GUI软件进行的软件测试。GUI的广泛应用为我们的程序操作提供了极大的方便，但是同时也使得GUI软件更复杂、更难以测试。
2.GUI测试难点
(1) GUI测试还没有完备的标准
对于普通的单元测试，我们只需要给目标函数一个输入并检测输出就可以了。例如：对于 Server 端逻辑的测试，我们只需要模拟客户端发起一个 HTTP 的请求就可以了，但是对于GUI的测试尚没有给出完整的定义。
(2) 复杂的GUI程序几乎无法生成完整的测试用例
用户对GUI软件的操作是任意的，而这些操作事件的发生没有固定的顺序，因此GUI软件的输入域变得非常的庞大或者无穷，导致可能无法生成完整的测试用例，这也会使得测试的期望输出也变得很复杂。
(3) 自动化GUI测试困难重重
GUI软件的输入和输出是交替进行的，而且测试输入受到GUI结构和状态的限制、输入域的不确定和事件的庞大，这些特点都会使得自动化GUI测试困难重重，自动测试时需要时刻监视GUI的结构和状态，而且输入域上的很多事件序列是无效的，这会使我们的测试过程无法正确执行或者不会得到软件的积极响应，从而很容易导致测试失败。
3.GUI测试技术
(1) 录制/回放技术
是通过测试人员在对GUI软件进行操作，然后通过专门的脚本语言进行录制，录制的过程中可以对关键点或者关心的事件和数据插入相应的验证点，录制完成后，进行回放操作，在回放的过程中，验证操作事件或者数据是否和期望的一致，从而完成测试。是目前流行的GUI测试方法。
(2) 基于有限状态自动机
有限状态自动机（Finite State Machine，简称FSM）是一种能够描述交互式系统的数学模型。GUI软件作为一种交互式系统，也可以使用FSM进行建模。但这是一个难度和工作量都很大工作。
(3) 基于UML
UML（Unified Modeling Language，统一建模语言）是用来对软件系统进行可视化建模的一种语言。利用UML用例图和活动图来生成GUI测试用例的方法。这类方法使用的前提是具有完善的UML软件设计文档或UML软件规约，具有较大的局限性。
(4) 利用人工智能方法
利用人工智能方法生成测试用例的研究主要是将智能规划方法（Planning）和遗传算法（GeneticAlgorithm）引入GUI测试用例生成。但使用这种方法时需要人工确定每个事件的初始状态和其引起的状态变化，工作量非常大，难以用于大规模GUI软件测试。使用遗传算法对熟练测试人员生成的样本测试用例集进行学习，然后根据学习的结果来生成新的测试用例。这种方法依然需要较高的人工成本，同时其效果受样本集的影响很大。
4.GUI自动化回归测试工具Squish
在创建现代复杂的GUI应用程序的时候，GUI测试是程序开发和QA的一个重要组成部分。随着应用的开发周期越来越短，短时间内通过人工去进行手动的审查GUI缺陷几乎是不可行的。Squish自动化GUI测试工具，以记录的方式快速的生成测试用例，通过测试用例的回放，发现软件产品缺陷通知相关人员及早的修复，从而节省时间、降低成本、提高效率。
Squish支持多种平台，Squish使测试人员应用GUI技术实现应用程序自动化成为可能，测试工程师可以通过Squish自由记录和编写测试使用熟悉的脚本语言来完成测试，拥有其他GUI测试工具无可替代的优点。此外，Squish提供非常紧密的集成与特定GUI技术支持。这给测试人员提供了他们正在测试(数据项，控制，和小部件，等等)的内部原理应用，也导致生产了
非常健壮和稳定的GUI测试。Squish是一个非常开放和灵活的系统，支持简单的集成与常见的测试管理系统和环境。
Squish的功能与优点：
● 智能测试记录和回放，选择非专有的脚本测试语言，以及强大的脚本编辑功能；
●插入验证点，可以验证应用关键点的功能；
●易于使用，基于Eclipse的集成开发环境；
● 测试日志记录和批处理执行，生成灵活的报告格式，自动截取验证失败的图形；
● 高级GUI控件支持和自定义控件；
● 支持交叉工具包；
● 脚本支持访问应用程序内部；
● GUI对象映射；
● 分布式和多个应用测试；
● 测试数据和数据驱动测试；
● 灵活性和可扩展性；
5.Squish自动化GUI测试过程
(1) 测试应用
Squish测试工具主要测试软件的GUI是否能够完成期望的功能。例如测试如下应用，AddressBook是一款经典的桌面应用程序，功能十分简单，但是包含了桌面级应用程序的最基本的特性（文件的打开、关闭、保存以及应用的关闭、最小化和最大化等）。
(2) 测试目标
AddressBook应用可以通过手动的添加或者删除应用数据，应用程序会保存应用数据，我们要测试在用户添加或者删除应用数据的时候，GUI应用程序是否会像我们所期望的那样，准确无误的添加或者删除数据，在最终的应用数据库中保存添加或者删除记录。
(3) 录制测试脚本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e92a603efc3d5bcbf2df3cce39782136/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5ae8a14254949e8b3daaf9daa542501/" rel="bookmark">
			抓包工具fiddler安装过程中遇到的各种坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fiddler 安装以及如何抓取HTTPS请求 众所周知 Fiddler 是一个非常实用的 抓包工具 而且 有很多的 扩展功能可以去官网下载
我们在开发中，难免需要抓包工具来查看接口数据 或者 测试接口的安全性, 如未签名而进行值的修改.
下面将介绍它的安装以及配置 证书 来抓取HTTPS加密信息
1.官网下载 https://www.telerik.com/fiddler （虽然安装没什么好说的,但还是写一下,走完整的流程）
点击 Free download 开始免费下载 之后会进入下载页面，此时会问你准备如何使用 Fiddler？ （安装了不同扩展功能的版本）选择好对应的版本进行下载
如果顺利则直接成功的下载好安装包
当然其实直接在百度搜索 并下载 也很省事
双击安装包.exe 可执行文件
选择好安装路径，install 并 运行 此时我们不做任何配置的情况下 已经可以抓取 HTTP 请求 （明文不解释，当然也需要请求走系统代理 火狐游览器需要设置“手工配置代理”）
但是我们如果项目中使用了HTTPS 请求，由于HTTPS请求的安全性，所有数据都是加密的，那么我们怎么抓取其中的信息呢？
首先我们要配置一下 Fiddler 的证书
为什么要配置这个玩意呢？ 有人会问， 那么我们先来简单看一下原理
1. Fiddler 拦截到我们自己客户端的HTTPS请求。
2.把拦截到的请求转发给请求服务器。
3.请求服务器响应，并生成证书文件发送给我们客户端，Fiddler 拦截，获取到请求服务器响应的证书文件，并把我们配置的伪造证书发送给我们自己的客户端。
4.客户端接受到伪造证书，再次请求数据。数据已经根据伪造证书加密。
5.Fiddler 拦截获取其中所有请求信息，再根据3,步骤中拦截到的正真证书文件 进行信息加密，发送给请求服务器。
总体来说, Fiddler 起到了中间转发的角色。
Fiddler 证书的配置：
1.Tools -&gt; Options -&gt; HTTPS
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5ae8a14254949e8b3daaf9daa542501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b864d287ffe7bedf63df3fd7e5d16e9c/" rel="bookmark">
			多个SSH密钥,访问不同的git服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该方法可以在同一设备中使用不同的密钥进行访问不同的git服务器,或者同一个密钥访问不同的git服务器(这需要密钥支持,一般都是不同的密钥,哈哈哈)还可以使用不同路径下的ssh密钥,只要设置好密钥所在地址就行.
方法步骤及要求 tip:该方法仅适用于已经有SSH密钥的情况,如果没有请找服务器管理员申请,自己是管理员的话自行网上查找生成方法, 这里就不过多介绍了(其实是我不会~)
1.把私钥,重命名拷贝到~/.ssh 文件夹下,主要是看管理员要求什么格式
cp xxx ~/.ssh/xxx_xxx 2.将文件权限提升到600
chmod 600 xxx_xxx 3.在~/.ssh目录下创建一个config文件,文件进行如下内容填写
Host theone //这个theone可以替换成任意标实名,要好记,使用git clone 的时候要用上 HostName xxx.xxx.xxx.xxx //git 服务器地址 Port 22 //端口号 User name //创建私钥时的账号 PreferredAuthentications publickey IdentifyFile ~/.ssh/xxx_xxx //私钥路径 Host thetwo //这个thetwo可以替换成任意标实名,不要重复了要好记,使用git clone 的时候要用上 HostName xxx.xxx.xxx.xxx //git 服务器地址 Port 22 //端口号 User name //创建私钥时的账号 PreferredAuthentications publickey IdentifyFile ~/.ssh/xxx_xxx //私钥路径 要更多的话就依次按照这个顺序添加,最后保存退出就可以了
使用方法 使用的时候用Host代替HostName,例如
ssh yaxon@theone git 服务器地址都填一样的话,就实现多个不同密钥访问同一个git服务器啦
密钥一样的话,就实现同一个密钥访问多个不同git服务器啦(当然,还是要服务器支持~)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47a2130db42e59823a0a0cc419e68000/" rel="bookmark">
			常见的居中方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.常用居中方法 居中在布局中很常见，我们假设DOM文档结构如下，子元素要在父元素中居中：
&lt;div class="parent"&gt;
&lt;div class="child"&gt;&lt;/div&gt;
&lt;/div&gt;
水平居中
子元素为行内元素还是块状元素，宽度一定还是宽度未定，采取的布局方案不同。下面进行分析：
行内元素：对父元素设置text-align:center;
定宽块状元素: 设置左右margin值为auto;
不定宽块状元素: 设置子元素为display:inline,然后在父元素上设置text-align:center; 通用方案: flex布局，对父元素设置display:flex;justify-content:center;
垂直居中
垂直居中对于子元素是单行内联文本、多行内联文本以及块状元素采用的方案是不同的。
父元素一定，子元素为单行内联文本：设置父元素的height等于行高line-height
父元素一定，子元素为多行内联文本：设置父元素的display:table-cell或inline-block，再设置vertical-align:middle;
块状元素:设置子元素position:fixed（absolute），然后设置margin:auto;
通用方案: flex布局，给父元素设置{display:flex; align-items:center;}。
经我验证无论是行内元素还是块级元素，父元素不需要设置高度，使用padding设置一个值，就可以垂直居中
另外，使用position和transform（ IE8 及更早版本不支持 transform 属性）
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;
&lt;style&gt;
.center {
height: 200px;
position: relative;
border: 3px solid green;
}
.center p {
margin: 0;
position: absolute;
top: 50%;
left: 50%;
border: 1px solid red;
-ms-transform: translate(-50%, -50%);
transform: translate(-50%, -50%);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47a2130db42e59823a0a0cc419e68000/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29fea977158338422235a7b5617bca92/" rel="bookmark">
			腾讯视频弹幕爬取----------之亲爱的，热爱的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为很喜欢杨紫演的亲爱的热爱的，想看看上头姐妹都是怎么花式夸杨紫的，所以，爬取腾讯视频的弹幕分析看看！
1.爬取单集弹幕 首先打开腾讯视频F12查询网站代码，从下面的图片中可以看出，有一个JSdanmu的请求在这个请求里面，包含我们准备要爬取的弹幕评论内容。
打开这个JS请求：
左图中comments就是弹幕评论，右图为该弹幕请求的URL。
url = 'https://mfm.video.qq.com/danmu?otype=json&amp;callback=jQuery19106282297637704668_1564552111377&amp;target_id=4000696434%26vid%3Dt00313mumzy&amp;session_key=1149997%2C63204%2C1564552136&amp;timestamp=15&amp;_=1564552111441' 这个网址很长，其中很多去掉对网址访问结果没有影响，所以经过简化得到如下的：
url = 'https://mfm.video.qq.com/danmu?otype=json&amp;target_id=4000696434%26vid%3Dt00313mumzy&amp;timestamp=15' 通过对比第一张图中出现的第二个danmu请求的URl可以看出url只有时间戳timetamp变化了，每次变化为30秒：
url2 = 'https://mfm.video.qq.com/danmu?otype=json&amp;target_id=4000696434%26vid%3Dt00313mumzy&amp;timestamp=45' 以此类推可以得到一集电视弹幕URL变化的规律，从而获取一集的全部弹幕。
上图是一条弹幕请求中包含的信息。我们需要的信息是 opername 用户名 、 commentid 评论id、content 内容 、 timepoint 评论时间、 uservip_degree 会员等集、upcount 评论点赞量。这几个要素。
import requests import json import time import pandas as pd #一个JS请求的内容 def parse_base_info(url,headers,df): html = requests.get(url,headers=headers) html.text[:500] bs = json.loads(html.text,strict = False) for i in bs['comments']: content = i['content'] upcount = i['upcount'] name = i['opername'] user_degree = i['uservip_degree'] timepoint = i['timepoint'] comment_id = i['commentid'] cache = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29fea977158338422235a7b5617bca92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c02152c496da554a034ecfc3d2705e7b/" rel="bookmark">
			最新十大排序算法详细讲解，以及各种应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 十大排序算法汇总比较和非比较的区别一些基本的术语排序算法复杂度及稳定性一、冒泡排序算法简介动图演示代码实现应用场景算法分析 二、快速排序算法简介动图演示代码实现算法分析 三、简单插入排序算法简介动图演示代码实现应用场景算法分析 四、希尔排序算法简介图片演示代码实现算法的优点算法分析 五、简单选择排序算法简介动图演示代码实现应用场景算法分析 六、堆排序算法简介图片演示代码实现应用场景算法分析 七、二路归并排序算法简介图片演示代码实现应用场景算法分析 八、计数排序算法简介动图演示代码实现应用场景算法分析 九、桶排序算法简介图片演示代码实现算法分析 十、基数排序算法简介动图演示代码实现算法分析一些基本情况 ** 十大排序算法汇总 **
比较和非比较的区别 常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。
在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。
比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。
计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr之前有多少个元素，则唯一确定了arr在排序后数组中的位置。
非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。
非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。
一些基本的术语 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
不稳定：如果a原本在b的前面，而a=b，排序之后a可能出现在b的后面；
内排序：所有的排序操作都在内存中完成；
外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
时间复杂度：一个算法执行所消耗的时间；
空间复杂度：运行完一个程序所需内存的大小。
排序算法复杂度及稳定性 一、冒泡排序 算法简介 1.从左向右依次对比相邻元素，将较大值交换到右边；
2.每一轮循环可将最大值交换到最左边
3.重复1.2两个步骤，直至完成整个数组。
动图演示 代码实现 /** * 冒泡算法的实现 * @param array * @return */ public static int[] bubbleSort(int[] array) { if(array.length==0) { return array; } for (int i = 0; i &lt; array.length; i++) { for (int j = 0; j &lt; array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c02152c496da554a034ecfc3d2705e7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8672351226223e44d816714cca86101/" rel="bookmark">
			一个很有水平的题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Test.main() 函数执行后的输出是（）
public class test { public static void main(String [] args){ System.out.println(new B().getValue()); } static class A{ protected int value; public A(int v) { setValue(v); } public void setValue(int value){ this.value = value; } public int getValue(){ try{ value++; return value; } catch(Exception e){ System.out.println(e.toString()); } finally { this.setValue(value); System.out.println(value); } return value; } } static class B extends A{ public B() { super(5); setValue(getValue() - 3); } public void setValue(int value){ super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8672351226223e44d816714cca86101/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03453e0ec5abbea7edd0adfa43803fc7/" rel="bookmark">
			是否带眼镜检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一个版本：
数据样本，带眼镜的图片2000
不带眼镜的2000张
开始训练模型
# -*- coding: utf-8 -*- """ Created on Wed Jul 10 15:39:22 2019 @author: 01 """ import cv2 import glob import os import tensorflow as tf import numpy as np import time tf.reset_default_graph() #数据集地址 path='C:/Users/01/Desktop/face/data/images/img_small/' #模型保存地址 model_path='F:/1/model.ckpt' #将所有的图片resize成100*100 w=100 h=100 c=3 #读取图片 def read_img(path): cate=[path+x for x in os.listdir(path) if os.path.isdir(path+x)] imgs=[] labels=[] for idx,folder in enumerate(cate): for im in glob.glob(folder+'/*.jpg'): print('reading the images:%s'%(im)) img=cv2.imread(im) img=cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03453e0ec5abbea7edd0adfa43803fc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0a5fc27344e441f19f185c7ad3d0917/" rel="bookmark">
			Flink DataSet API - Transformations
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DataSet API - Transformations 数据转换MapFlatMapMapPartitionFilterSortPartitionReduceAggregate作用于分组上作用于整个DataSet上 minBy/maxBy作用于分组上作用于整个DataSet上 GroupReduceDistinctJoin笛卡儿积Union数据分区广播变量文件缓存容错 数据转换 数据转是换将一个或多个DataSet 转换成为一个新的DataSet 。程序可以将多个DataSet 转换组合成复杂的DataSet。
Map 对整个DataSet做一对一映射，即每个元素对应产生一个新元素。
data.map(new MapFunction&lt;String, Integer&gt;() { public Integer map(String value) { return Integer.parseInt(value); } }); FlatMap 获取一个元素并生成对应的零个、一个或多个元素。
data.flatMap(new FlatMapFunction&lt;String, String&gt;() { public void flatMap(String value, Collector&lt;String&gt; out) { for (String s : value.split(" ")) { out.collect(s); } } }); MapPartition Map和FlatMap转换的对象是DataSet中的每个元素，而MapPartition转换的对象是DataSet的每个分区。
data.mapPartition(new MapPartitionFunction&lt;String, Long&gt;() { public void mapPartition(Iterable&lt;String&gt; values, Collector&lt;Long&gt; out) { long c = 0; for (String s : values) { c++; } out.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0a5fc27344e441f19f185c7ad3d0917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08f985b1679dc2a2e8ea9baee74c6768/" rel="bookmark">
			设有一数列，包含10个数，已按升序排好。现要求编一程序，它能够把从指定位置开始的n个数按逆序重新排列并输出新的完整数列。进行逆序处理时要求使用函数。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;
void nsort(int a[],int n)
{
int t;
for (int i = n,j=0,m=0; m&lt;(10-n)/2;m++,j++,i++)
{
t = a[i];
a[i] = a[10 - j - 1];
a[10 - j - 1] = t;
}
for (int i = 0; i &lt; 10; i++)
{
printf("%d,", a[i]);
}
}
void main()
{
int a[10],n;
for (int i = 0; i &lt; 10; i++)
{
scanf("%d", &amp;a[i]);
}
scanf("%d", &amp;n);
nsort(a,n);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08f985b1679dc2a2e8ea9baee74c6768/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60d23697a7456ab797e7b6c7e52cabcd/" rel="bookmark">
			排序算法值快速排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速排序算法： 对于一个待排序列，确认出一个基准值key，将将序列分为小于基准值和大于等于基准值的两个序列，然后再将这两个序列再进行之前的操作分成新的两列，不断往下循环操作使数组分到的数组越来越小，如果分到的新序列里的元素为1或者为0，那么这个序列就是有序的了。
key值可以定为待排序列的第一个元素或者最后一个元素，对待排序列的分组操作有三种实现思想。
1.按基准值互划分左右区间： huver法挖坑法前后指针法 1. 1hover法（前后指针法） 定义两个指针，begin指向待排序列的第一个元素，end指向待排序列的倒数第二个元素，将最后一个元素定位基准值key。
begin向后移动，当begin所指向的元素小于key时向后移动一个元素，当begin指向的元素大于等于key时begin停止后移，开始移动end，当end指向的元素大于等于key时，end向前移动一位，当end指向元素小于key时停止移动。交换begin和end指向元素，然后继续向后移动begin，大于key停止，向前移动end，小于key停止，begin和end交换所指向元素的值。重复指向这个操作，直至end和begin指向同一个元素。这是将这个元素和基准值进行交换。此时的序列就分为了小于begin指向的基准值的左边序列，和大于等于基准值的右边序列。
int hover(int array[], int left, int right){ int begin = left; int end = right - 1; int key = array[right]; while (begin &lt; end){ while (begin&lt;end&amp;&amp;array[begin] &lt; key) begin++; while (begin&lt;end&amp;&amp;array[end] &gt;= key) end--; Swap(array + begin, array + end); } Swap(array + begin, array + right); return begin; } 1.2挖坑法 “挖坑法”听名字就是要从待排序列中取出一个元素，让序列中“空”出一个元素出来。第一步确定基准值key，将待排序列的最后一个元素定为基准值，将这个基准值“挖”出来，定义两个指针分别指向待排序列的第一个元素和倒二个元素分别为begin和end，begin所指向的元素小于key，begin向后移动，当begin指向元素大于key时，将这个元素“挖”出来将之前“挖”出的空填起来，然后移动end指针，当end指向的元素大于等于key时，向前移动一位，否则将end指向的元素“挖”起来，去“填”前面的坑，然后又开始向后移动begin，大于key就“挖”起来填后面的坑，向前移动end指针重复上面的操作，依次移动两个指针，直至两个指针指向同一个位置，而且这个位置是个“坑”，用key“填”这个“坑”，此时待排序列就被分为左边小于key的左序列，和右边大于等于key的右序列。
int potholing(int array[], int left, int right){ int key = array[right]; int begin = left; int end = right; while(begin &lt; end){ while (begin &lt; end&amp;&amp;array[begin] &lt; key) begin++; array[end] = array[begin]; while (begin &lt; end&amp;&amp;array[end] &gt;= key) end--; array[begin] = array[end]; } array[begin] = key; return begin; } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60d23697a7456ab797e7b6c7e52cabcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1172370b5a08b2722af38af4cc69940d/" rel="bookmark">
			国王游戏（算法竞赛进阶指南 P40，贪心 &#43; 大数乘除）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.题目链接： 国王游戏 二.题目大意： 国王和大臣排队，国王始终排在最前面.
每个人的左右手里各有一个数 a，b.
每 i 位大臣获得钱数为 现在对大臣重新排队，求最小化最大大臣金额.
三.分析： 按照大臣的 a * b 排序，得到的最大大臣金额是最小的.
证明：
这里选用临项交换的方法.
设第 i 位大臣的 a 为 a[i], b 为 b[i]
第 i + 1 位大臣的 a 为 a[i + 1], b 为 b[i + 1]
则，交换前两位大臣的金额分别为 和 交换后的金额分别为 和 提出公因项 得： 和 和 现在来比较交换前后最大的金额
即： 与 两遍同乘以 转化为： 与 若 又因为 所以 反之若 又因为 所以 综上所得：当 时，交换后更优，反之交换前更优.
因此，将大臣按照 排序后，此时即可取得最小的金额.
证毕.
之后遍历一遍，取最大值即可.
ps：这里要手写大数乘除法（顺便留个模板）.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1172370b5a08b2722af38af4cc69940d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c58db15b62b79dbc86bc9057d9891b7/" rel="bookmark">
			SpringBoot 生成带水印pdf | 中文字体问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 生成pdf 中文字体问题 一般生成pdf引用中文字体有以下几种方式：
方法一：使用Windows系统字体(TrueType)
方法二：使用iTextAsian.jar中的字体
方法三：使用资源字体(ClassPath)
理论上使用方式三是最好的，但是实际使用过程中，itext读取字体的方式是接受的目录，不是实际的文件。所以当使用SpringBoot部署方式以jar包方式运行，在获取字体的时候获取不到，因为在服务器上读取的字体路径为jar包中的路径：
file:/root/startup/za-minos-ms.jar!/BOOT-INF/classes!/
如上图，这种路径是无法正确读取文件的，所以合理的解决方案是通过流读取，然后在服务器上创建新的文件。也就是最终使用的是方法一字体引用方式。
读取和创建新文件的代码：
/** * Created by zhangshukang on 2019/7/25. */ @Slf4j @Component public class FontUtil { public static String[] fontNames = {"ping_fang_bold.ttf", "ping_fang_light.ttf", "ping_fang_regular.ttf", "SIMLI.TTF"}; public static String fontPath = "biz/pdf/fonts/"; public static String newFontPath = "resources"; private static String sourceTemplatePath; static { //静态方法调用一次　sourceTemplatePath = createFtlFileByFtlArray(); } public static String createFtlFileByFtlArray() { String path = ""; for (int i = 0; i &lt; fontNames.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c58db15b62b79dbc86bc9057d9891b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2742ff71e2fdbbc0d5c0dcd72871ff7d/" rel="bookmark">
			Python 大数字字符串求和（包含多位小数，长整数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决思路：
找到两个数字字符串的小数点的位置，没有的补上 “.0”。以小数点的位置给两个数字字符串补上0，让二者同等长度。从右向左循环相加，组合成结果字符串，遇到小数点直接添加小数点。将最后的进位与结果组合，正常最终结果 # num1, num2 两个字符串 def long_sum(num1,num2): #1 参数准备 carry = 0 # 默认进位为0 res = "" # 最后结果 #2 计算长度,与小数点位置 size1 = len(num1) log1 = num1.find('.') if log1 == -1: # 没有小数点，就对该数字字符串转化为小数字符串 size1 += 2 num1 += ".0" log1 = size1- 2 size2 = len(num2) log2 = num2.find('.') if log2 == -1: size2 += 2 num2 += ".0" log2 = size2- 2 # print(num1,num2,) # 补齐小数点 1234.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2742ff71e2fdbbc0d5c0dcd72871ff7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/277fae1a3874cbfe2c58e69a179f9eae/" rel="bookmark">
			python人脸切割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入图像
输出：
# created at 2018-01-22 # updated at 2018-09-29 # Author: coneypo # Blog: http://www.cnblogs.com/AdaminXie # GitHub: https://github.com/coneypo/Dlib_face_cut import dlib # 人脸识别的库dlib import numpy as np # 数据处理的库numpy import cv2 # 图像处理的库OpenCv import os # 读取图像的路径 path_read = "./data/images/faces_for_test/1/0/" # 用来存储生成的单张人脸的路径 path_save = "./data/images/img_small/" # Delete old images def clear_images(): imgs = os.listdir(path_save) for img in imgs: os.remove(path_save + img) print("clean finish", '\n') clear_images() # Dlib 预测器 detector = dlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/277fae1a3874cbfe2c58e69a179f9eae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b669eaad5e1f92c776b8623e0e3728c/" rel="bookmark">
			The JAVA_HOME environment variable is not defined correctly  should point to a JDK not a JRE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动Tomcat的时候出现以下错误
The JAVA_HOME environment variable is not defined correctly This environment variable is needed to run this program NB: JAVA_HOME should point to a JDK not a JRE 这个错误总之来说就是Tomcat没有找到JAVA_HOME这个变量。
没有找到JAVA_HOME无非两个问题。
1、 是我们java的环境变量没有配置正确。 这个问题我们直接可以在命令行中使用java 和javac就可以发现
2. 如果我们的环境变量设置的没有问题，可能就是我们的Tomcat，没有找到JAVA_HOME。
我们使用的startup.bat命令实际调用的是setclasspath.bat这个文件。我们将JAVA_HOME配置在这个文件中，就可以让tomcat找到了。
我们在这个文件的开头位置设置JAVA_HOME和JRE_HOME即可
set JAVA_HOME=E:\java\jdk\jdk1.8
set JRE_HOME=E:\java\jdk\jre1.8
@echo off rem Licensed to the Apache Software Foundation (ASF) under one or more rem contributor license agreements. See the NOTICE file distributed with rem this work for additional information regarding copyright ownership.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b669eaad5e1f92c776b8623e0e3728c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/597cac68b3e8a3d7cb4c47c357c67521/" rel="bookmark">
			Cantata 8.0有哪些新变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cantata 8.0 于2018年5月发布，这一重大版本的升级在以往技术的基础上增添了关键性新功能，并且对用户界面进行了全面改进，这个文档简要介绍了8.0中的主要变化。
Cantata 于2018年5月发布，本次版本升级所包含的重要新功能有：自动测试维护、多个嵌入式目标环境下的测试重用以及更灵活的代码插装。8.0也继续在用户界面上进行优化，在保留熟练用户的专家模式界面基础上增加了简单直观的新用户模式。
软件开发生命周期尽早开展测试可以提高代码质量，减少代码返工的风险，即使计划非常好的项目依然需要在初始测试后对代码进行修改，单元测试和集成测试非常依赖于代码的结构，修改代码会带来很大的风险，修正其中的问题也很费时间，Cantata代码变更分析这一新功能自动识别代码的改变对测试的影响，并帮助自动维护测试。针对代码的修改可以提供解决这些问题的指南和建议，并自动触发自动测试。
彻底的代码变更和测试依赖性分析可以发现：
● 哪些代码发生变化并影响现有的测试脚本
● 哪些测试脚本被代码修改影响
● 代码修改对之前的测试所实现的代码覆盖率产生什么影响
代码变更的结果在全新的代码变更管理器中显示，已经测试过的代码依然保留并与现在的代码进行对比。
源代码中所发生的修改并对测试脚本发生影响的情况包括：
● 源文件增加/删除/改名
● 头文件增加/删除/改名
● 函数&amp;方法
■ 增加/删除
■ 修改（范围，返回类型，名称或参数）
■ 函数体增加/删除
■ 函数体变更-影响代码覆盖率
● 变量
■ 增加/删除
■ 增加/删除
针对代码的变更需要自动同步测试用例，提供指导性的选择：
● 关于每一个源文件的代码修改对现有测试脚本的影响的详细信息
● 对更新测试提供建议，并对于接受这个建议的影响也提供详细指南
● 测试脚本自动重构以实现建议的测试更新
8.0中新的目标环境切换功能使得同样的测试在多个目标环境中重用更加轻松，特别是当代码在多个目标环境中重用时，这个功能具有很大帮助。
每一个目标环境都会产生独立的makefiles，在其间进行切换很容易，就像在工具条下拉框中选择一个目标部署配置一样简单：
测试重用可以加快在多个嵌入式目标环境配置中的测试进度，避免在多个项目中复制，降低了测试维护的工作量，消除了维护多个项目和配置的风险。
Cantata 测试结果文件记录了每一个目标配置中执行的测试，所以对每一个环境都提供单独的测试认证相关的证据。
除了内置的目标部署配置环境之外，每当新的配置包开发完成，都可以从QA Systems公司下载。
Cantata 8.0引入了一个新的测试浏览器，更加容易查看代码、测试用例、测试结果和报告。这是一个测试的中心视图，更加清晰和容易进行导览，只显示和Cantata测试相关的信息。
测试浏览器提供了一个场景相关的控制集中器，对Cantata的功能和视图进行管理，对项目浏览的控制功能进行了结合和提升，这些诊断信息以前在覆盖率结果和测试结果浏览器中显示。
测试浏览器的新特性包括：
● 以上下文菜单直接创建和管理Cantata测试
● 过滤器聚焦相关源文件、测试状态和结果
● 对每一个树节点工具提示附加信息和相关的结果
新的测试属性视图提供了测试环境控制的单一入口，可以对测试浏览器中选中的每一个测试项设置其属性，这个视图改进了之前测试脚本管理器中的控制功能。
测试属性可以让用户管理如下内容：
● 项目和测试脚本级别选项
● 全局数据设置
● 测试用例函数名和注释描述
● 控制测试构建的设置（make file，头文件路径，代码覆盖率和静态内存）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/597cac68b3e8a3d7cb4c47c357c67521/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f7b33892b6545a3ee3b5e7f148efc6/" rel="bookmark">
			Flink DataStream API - Connector（连接器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Connector 连接器HDFS连接器Kafka1.创建连接器2.创建反序列化器3.设置消息起始位置偏移4.设置检查点周期5.设置位置偏移提交方式 异步I/O 连接器 Source和Sink节点连接外部数据源的组件称为连接器（Connector），其中内置连接器的实现代码集成在Flink源码中，但是这些代码并没有被编译进Flink二进制程序包中。内置连接器如下，其中括号里描述的是支持Source还是Sink。
Apache Kafka (source/sink)Apache Cassandra (sink)Amazon Kinesis Streams (source/sink)Elasticsearch (sink)Hadoop FileSystem (sink)RabbitMQ (source/sink)Apache NiFi (source/sink)Twitter Streaming API (source) Flink的容错机制在出现故障时恢复程序并继续执行它们。这些故障包括机器硬件故障、网络故障、暂态程序故障等。
Flink可以精确地保证，只有连接器支持exactly-once语义时，一致性保障情况如下图所示：
HDFS连接器 HDFS连接器是以库的形式提供的，需在MAVEN工程中引入以下依赖：MAVEN仓库地址
&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-filesystem_2.11&lt;/artifactId&gt; &lt;version&gt;1.8.1&lt;/version&gt; &lt;/dependency&gt; 唯一需要设置的参数是存储文件的基本路径。并可以通过指定自定义bucketer、写入器和批大小来进一步配置接收器。
默认情况下，当元素到达时，BucketingSink将根据当前系统时间进行分割，并使用datetime模式（“yyyy-MM-dd–HH”）来命名桶。此模式使用当前系统时间和JVM的默认时区传递给DateTimeFormatter，以形成桶路径。用户还可以为桶指定一个时区来格式化桶路径。每当遇到新的日期，就会创建一个新的桶。例如，如果您有一个包含分钟作为最细粒度的模式，那么您将每分钟获得一个新桶。每个桶本身都是一个包含多个部件文件的目录（sink的每个并行实例将创建自己的部件文件），当部件文件变得太大时，sink还将在其他文件旁边创建一个新的部件文件。当桶变为非活动时，打开的部分文件将被刷新并关闭。当一个桶最近没有被写入时，它被认为是不活动的。默认情况下，sink每分钟检查不活动的桶，并关闭超过一分钟没有写入的桶。可以在BucketingSink上使用setInactiveBucketCheckInterval()和setInactiveBucketThreshold()配置此行为。
还可以通过在BucketingSink上使用setBucketer()指定自定义桶。如果需要，桶可以使用元素或元组的属性来确定桶目录。
默认使用StringWriter写入。这将对传入的元素调用toString()，并将它们写入用换行符分隔的部分文件中。要指定自定义写入器，请在BucketingSink上使用setWriter()。如果您想编写Hadoop sequencefile文件，您可以使用提供的SequenceFileWriter，它也可以配置为使用压缩。
有两个配置选项指定何时关闭一个桶内文件，何时启动一个新的桶内文件:
-通过设置指定大小(默认的部分文件大小为384 MB)通过设置一个固定的时间间隔(默认的随时间间隔是Long.MAX_VALUE) 当满足这两个条件之一时，将启动一个新的桶内文件。
DataStream&lt;Tuple2&lt;IntWritable,Text&gt;&gt; input = ...; // 定义存储桶的基本路径 BucketingSink&lt;Tuple2&lt;IntWritable,Text&gt;&gt; sink = new BucketingSink&lt;Tuple2&lt;IntWritable,Text&gt;&gt;("/base/path"); sink.setBucketer(new DateTimeBucketer&lt;&gt;("yyyy-MM-dd--HHmm", ZoneId.of("America/Los_Angeles"))); sink.setWriter(new SequenceFileWriter&lt;IntWritable, Text&gt;()); sink.setBatchSize(1024 * 1024 * 400); // this is 400 MB, sink.setBatchRolloverInterval(20 * 60 * 1000); // this is 20 mins input.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91f7b33892b6545a3ee3b5e7f148efc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e50c01e87111d0ccdb3bc57e258fd840/" rel="bookmark">
			js 字符串编码与解码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编码有三种
1、escape(对应解码unescape)
定义：escape() 对字符串进行编码。
注意：
该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： * @ - _ + . / 。其他所有的字符都会被转义序列替换。
2、encodeURI(对应解码decodeURI) 定义：encodeURI() 函数可把字符串作为 URI 进行编码。
注意：
该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ' ( ) 。
该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&amp;=+$,#
3、encodeURIComponent（对应解码decodeURIComponent）
定义：encodeURIComponent() 函数可把字符串作为 URI 组件进行编码
注意：
该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ' ( ) 。
其他字符（比如 ：;/?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e50c01e87111d0ccdb3bc57e258fd840/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7f0295436d667d67e1324ff4c47bcde/" rel="bookmark">
			两种构造最小生成树的算法（普里姆算法，克鲁斯卡尔算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一）普里姆算法
普里姆算法求最小生成树：从生成树中只有一个顶点开始，到定点全部进入生成数为止；
2.克鲁斯卡尔算法。
思想：将所有边按其权值从小到大排一遍，从小到大依次选取边，加入最小生成树中，若加入此边后不会产生回路，则将此边加入，否则则舍去，遍历一遍所有的边。可通过并查集判断是否构成回路。
例题：HDU1863 畅通工程
题意：
省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。经过调查评估，得到的统计表中列出了有可能建设公路的若干条道路的成本。现请你编写程序，计算出全省畅通需要的最低成本。
Input
测试输入包含若干测试用例。每个测试用例的第1行给出评估的道路条数 N、村庄数目M ( &lt; 100 )；随后的 N 行对应村庄间道路的成本，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间道路的成本（也是正整数）。为简单起见，村庄从1到M编号。当N为0时，全部输入结束，相应的结果不要输出。 Output
对每个测试用例，在1行里输出全省畅通需要的最低成本。若统计数据不足以保证畅通，则输出“?”。
Sample Input
3 3 1 2 1 1 3 2 2 3 4 1 3 2 3 2 0 100 Sample Output
3 ? 显然是个最小生成数的题。
附上克鲁斯卡尔算法的代码：
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;set&gt; #include&lt;stack&gt; #include&lt;queue&gt; #include&lt;vector&gt; #define ll long long using namespace std; int n,m; int a[105]; struct node{ int p,q; int z; }g[10010]; bool cmp(node p,node q) { return p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7f0295436d667d67e1324ff4c47bcde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88283e4609f10c5f5b9fe6e52edea702/" rel="bookmark">
			PHP实现中文字符串截取无乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关于mb_strcut函数截取字符串
&lt;?php echo mb_strcut("PHP中文网", 0, 7); 截取“PHP中文网”前7个字节，结果如下： ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190730122742849.png) 从图中可以看到，我们要截取7个字节，但是只显示截取了“PHP中”这6个字节。由于一个汉字等于三个字节，那么这里第7个字节就不会显示了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3146b5e32f4ce0b941ed2eb5ca4e1018/" rel="bookmark">
			Python调用科大讯飞C语言接口(语音听写linux sdk)实现语音识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		科大接口调用文档：
https://www.xfyun.cn/doc/asr/voicedictation/Linux-SDK.html#_2、sdk集成指南
from ctypes import * import time import threading # 调用动态链接库 dll = cdll.LoadLibrary("../Linux_iat1226_xxxxxxx/libs/x64/libmsc.so") # 登录参数，apppid一定要和你的下载SDK对应 login_params = b"appid = xxxxxx, work_dir = ." FRAME_LEN = 640 # Byte MSP_SUCCESS = 0 # 返回结果状态 MSP_AUDIO_SAMPLE_FIRST = c_int(1) MSP_AUDIO_SAMPLE_CONTINUE = c_int(2) MSP_AUDIO_SAMPLE_LAST = c_int(4) MSP_REC_STATUS_COMPLETE = c_int(5) # 你的语音文件路径 filename = "./f1.wav" class Msp: def __init__( self ): self.recogStatus = c_int(8) self.counter = 0 self.laststr = '' self.sessionID = None self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3146b5e32f4ce0b941ed2eb5ca4e1018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c8b590238e557bf00617e169c0e1a4d/" rel="bookmark">
			MYSQL 数据库基础（三 流程函数的学习，多行函数相当于统计计算等等、group by的使用、goup by衍生出的having、排序关键字order by、升序ASC、降序DESC、模糊查询等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流程函数 类似与java中的判断情况 的学习
实际应用：
-- 满足条件执行 第一个逗号后面的 否则执行第二个逗号 SELECT ename,sal,IF(sal&lt;2500,'低于2500','高于2500') as'工资状态' from emp -- ifnull 如果不为空 就是括号里第一个值，如果为空就是第二个值 select ename,sal,comm,sal+IFNULL(comm,0)as'到手工资=工资加津贴comm' from emp select ename,sal, case when sal&lt;2500 then '工资低于2500' else '工资高于2500' end as '工资水平' from emp -- 多分枝判断语句 select ename ,sal, case when sal&lt;2000 then '工资小于2000' when sal&lt;2500 then '工资小于2500但是大于2000' ELSE '工资大于2500' end as '工资水平' from emp SELECT ename,max(sal)-- 最大工资人名： from emp -- 最小工资人的全部信息 select *,min(sal) from emp -- count 是用于记录查询数据的，可以查看表中有多少记录 -----行 select count(*) from emp -- 平均数 SELECT avg(sal)as'平均工资' from emp 多行函数通常可以与group by关键字一起使用，group by的作用就是分组 我们也可以称之为 一类一类，比如说查某个部门工资，这样一类一类的 举例说明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c8b590238e557bf00617e169c0e1a4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dba051cd95ac7bf32a56d856f059f1e/" rel="bookmark">
			c&#43;&#43;实现情绪识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇使用python实现情绪识别的基础上，使用c++实现情绪识别。
这里的人脸检测模块不是使用dlib模块（使用dlib模块也可以，测试以后发现速度比较慢），这里使用另外一个开源的模块。
facedetect-dll.h,可以去我的资源里下载。里面的眉毛斜率检测模块，因为c++没有np.polyfit，所以需要自己实现（参考最小二乘）。
#include &lt;fstream&gt; #include &lt;string&gt; #include &lt;iostream&gt; //#include &lt;dlib/image_processing/frontal_face_detector.h&gt; //#include &lt;dlib/image_processing/render_face_detections.h&gt; //#include &lt;dlib/image_processing.h&gt; //#include &lt;dlib/gui_widgets.h&gt; //#include &lt;dlib/image_io.h&gt; #include &lt;opencv2/core/core.hpp&gt; //#include &lt;dlib/timer.h&gt; #include &lt;opencv2/dnn.hpp&gt; #include &lt;opencv2/imgproc.hpp&gt; #include &lt;opencv2/highgui.hpp&gt; #include "highgui.h" #include "lib\facedetect-dll.h" #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include "lib\facedetect-dll.h" using namespace cv; using namespace std; using namespace dnn; float LineFitLeastSquares(float *data_x, float *data_y, int data_n); // ---------------------------------------------------------------------------------------- // #define DETECT_BUFFER_SIZE 0x20000 int main() { const char* path = "E:/fangtu1/1/FTA001190217537664_一寸照.jpg"; unsigned char * pBuffer = (unsigned char *)malloc(DETECT_BUFFER_SIZE); //auto src = cv::imread("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dba051cd95ac7bf32a56d856f059f1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77a5460254e2c6cc855125788ae4a6d4/" rel="bookmark">
			C&#43;&#43;中自增运算符（&#43;&#43;）与自减（--）运算符的重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中自增运算符（++）与自减（--）运算符的重载 运算符重载自增运算符（++）与自减（--）运算符的重载结果分析 运算符重载 运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。
运算符重载需要以下函数
/*类名*/ operator /*要重载的运算符*/()；//函数声明 /*类名*/ /*类名*/::operator /*要重载的运算符*/() //函数主体 { //具体操作 } 自增运算符（++）与自减（–）运算符的重载 下面以一道题为例，来理解自增运算符（++）与自减（–）运算符的重载。
题目：编写程序定义Point类，在类中定义整型的私有成员变量_x_y，定义成员函数Point&amp; operator++()；Point operator++(int)；以实现对Point类重载“++”(自增)运算符，定义成员函数Point＆ operator－－()；Point operator－－(int)；以实现对Point类重载“－－”(自减)运算符，实现对坐标值的改变。
特别注意：由于编译器必须能够识别出前缀自增与后缀自增，人为规定用 operator++() 和 operator–() 重载前置运算符，用 operator++(int) 和 operator–(int) 重载后置运算符，在这里的 int 并没有什么实际的意义，仅仅是为了区分重载的是前置的形式还是后置的形式。
根据上述运算符重载的函数，代码如下
#include&lt;iostream&gt; using namespace std; class Point { private: int _x; int _y; public: Point(int x = 0, int y = 0) { _x = x; _y = y; } Point operator ++();//前置型 Point operator ++(int);//后置型 Point operator --();//前置型 Point operator --(int);//后置型 void Display(); Point pp() { _x++; _y++; return *this; } Point mm() { _x--; _y--; return *this; } ~Point(){} }; Point Point::operator ++() //前置型自增 { return pp(); } Point Point::operator ++(int)//后置型自增 { Point p = *this; pp(); return p; } Point Point::operator --()//前置型自减 { return mm(); } Point Point::operator --(int)//后置型自减 { Point p = *this; mm(); return p; } void Point::Display() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77a5460254e2c6cc855125788ae4a6d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e474408beaab2ca79e286219fcf3cbe3/" rel="bookmark">
			Flink-DataStream 窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink-DataStream 窗口 窗口 window窗口的生命周期Keyed vs Non-Keyed Windows窗口分配器（Window Assigners）滚动窗口（Tumbling Windows）滑动窗口（Sliding Windows）会话窗口（Session Windows）全局窗口（Global Windows） 窗口函数（Window Functions）ReduceFunctionAggregateFunctionFoldFunctionProcessWindowFunctionProcessWindowFunction with Incremental Aggregation在ProcessWindowFunction中使用每窗口状态 触发器（Triggers）Fire and Purge默认触发器（ Default Triggers of WindowAssigners）Built-in and Custom Triggers 清除器（Evictors）迟到生存期（Allowed Lateness） 窗口 window 窗口是另一类的算子，是DataStream的逻辑边界，在第一个元素到达后创建，在生命周期结束后被销毁。
窗口分为两大类：
Keyed Window：通过在keyedStream上定义window()获得。可并行计算。Non-Keyed Window：通过在DataStream上定义windowAll()获得。 Keyed Windows stream .keyBy(...) &lt;- keyed versus non-keyed windows .window(...) &lt;- required: "assigner" [.trigger(...)] &lt;- optional: "trigger" (else default trigger) [.evictor(...)] &lt;- optional: "evictor" (else no evictor) [.allowedLateness(...)] &lt;- optional: "lateness" (else zero) [.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e474408beaab2ca79e286219fcf3cbe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb8d72044eed6ef75d0b37057b7deb1a/" rel="bookmark">
			Java基础教程：多线程基础（5）——倒计时器(CountDownLatch)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java基础教程：多线程基础（5）——倒计时器(CountDownLatch) 引入倒计时器 在多线程协作完成业务功能时，有时候需要等待其他多个线程完成任务之后，主线程才能继续往下执行业务功能，在这种的业务场景下，通常可以使用Thread类的join方法，让主线程等待被join的线程执行完之后，主线程才能继续往下执行。当然，使用线程间消息通信机制也可以完成。其实，java并发工具类中为我们提供了类似“倒计时”这样的工具类，可以十分方便的完成所说的这种业务场景。
为了能够理解CountDownLatch，举一个很通俗的例子，运动员进行跑步比赛时，假设有6个运动员参与比赛，裁判员在终点会为这6个运动员分别计时，可以想象没当一个运动员到达终点的时候，对于裁判员来说就少了一个计时任务。直到所有运动员都到达终点了，裁判员的任务也才完成。这6个运动员可以类比成6个线程，当线程调用CountDownLatch.countDown方法时就会对计数器的值减一，直到计数器的值为0的时候，裁判员（调用await方法的线程）才能继续往下执行。
引入倒计时器后，实际是定义了线程A的前置线程数量，每当前置线程完成一个任务，计数器减一，直到所有前置线程都执行完任务后，线程A才继续执行。
常用方法 CountDownLatch构造方法接受一个整数值N，之后调用CountDownLatch的countDown方法会对N减一，直到N减到0的时候，当前调用await方法的线程继续执行。
其他方法如下：
await() throws InterruptedException：调用该方法的线程等到构造方法传入的N减到0的时候，才能继续往下执行；await(long timeout, TimeUnit unit)：与上面的await方法功能一致，只不过这里有了时间限制，调用该方法的线程等到指定的timeout时间后，不管N是否减至为0，都会继续往下执行；countDown()：使CountDownLatch初始值N减1；long getCount()：获取当前CountDownLatch维护的值； 实例：按序打印 题解链接
参考资料 参考文章：https://juejin.im/post/5aeec3ebf265da0ba76fa327题目链接：题目链接 转载于:https://www.cnblogs.com/MrSaver/p/11262184.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca484da974c36b0f4c534e02b9991638/" rel="bookmark">
			阿里管理九板斧 -借人成事、借事修人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然员工身处职场，但阿里希望这还是一个情场，甚至道场。
好的组织不仅会让员工获得职业发展，还能得到真正的「人」的成长。如同每个个性鲜明的人，一家企业也拥有强烈的个性特质，阿里的个性特质就是人的“味道”：
“人才固然是宝贵的，但每个人内心的那团火更宝贵，它将能照亮不可预见的未来。”如果用两句话来概括阿里的人才发展，那就是“人事合一”和“虚事实做”
人事合一
所谓人事合一，就是借事修人，借人成事。
员工在阿里工作5年会有个成人仪式——只有在阿里待满5年才能真正成为“阿里人”，经历足够多的挫折、委屈、变化，才能充分感知阿里味，并由内而外地散发出阿里味。
我们对所有团队领导者的要求也是既要做成事，也要带出一支队伍。阿里人才发展和组织发展的核心原则是——紧贴业务场景，基于业务实际需要发展人，发展组织。
虚事实做
所谓虚事实做，由于领导力、文化、员工成长的内在体验是虚的，必须通过实实在在的事情，将人的内在体验落地，在业务中沉淀宝贵的体验与感受。举例来说：在阿里每完成一项工作，大家会再多花5分钟谈谈个人的感受与体验，来加深对业务的理解以及彼此间的情感。
一、阿里巴巴的九板斧体系但凡一家优秀的公司，都必须要形成对自身的独特看法和视角。借着阿里形成领导力的“九板斧”体系，大家可以对阿里“人事合一”有个体感。
九板斧体系主要分为三层：
“腿部”包括拿结果、Hire&amp;Fire、建团队；“腰部”包括定策略、做导演、搭班子；“头部”包括定战略、断事用人、造土壤；
每一层级的领导者只需练好三门“绝技”或关键点即可。
△阿里领导力“九板斧”体系
从纵向来看，九板斧背后也有着清晰的脉络，第一是做事情，第二是培养人，第三需要打通人和事之间的“任督二脉”。
做事情
从定战略、定策略，到拿结果，是阿里“做事情”的线。
首先，高层领导者需要定战略、指明方向，看清楚未来3～5年的产业格局与竞争态势，以及客户价值是什么；其次，中层需要定策略，将大的、虚幻的战略转化为当年的策略；最后，基层拿结果，将这些策略转化成具体项目和目标，细化到10人的小团队能够负责并产出结果。
培养人
造土壤、搭班子、建团队，是阿里“培养人”的线。
首先，建团队，每位基层领导者应懂得带人、凝聚人心，引领大家走向共同的目标；其次，搭班子，这需要联合很多“工种”来做一件事情，如一个行业领导者需要把运营、产品、技术甚至外界等几股力量组合在一起，才能产生效果；最后，造土壤，阿里把组织比喻为一片土壤、一个有机的生命体，只要土壤好，植物就容易播种，让团队文化呈现健康的、正能量的状态。
打通任督二脉
每个人都有任督二脉，我们要考察管理者在人与事方面的“要害点”是否通畅。
Hire&amp;Fire：对于基层管理者来说，除了拿结果、建团队之外，招聘与解聘是也是关键。在阿里，如果一个领导者没有开除过一个员工，他就不是真正成熟的管理者。其实，解聘代表着你的取舍标准，只有这样，一个团队才真正具备拿结果的能力，团队的文化与味道也才能建立起来。
做导演：管理者应像世界级的导演，首先要“挑选好剧本”，即挑选一个好的业务；然后，“找演员”，将团队建立起来；最后，还需要好的舞美与灯光等配套设施，才能将团队捏合起来。一出“戏”导出来后，不光要叫座，还应对社会产生影响，这正是“做导演”背后的逻辑。
断事用人：越往上，我们会发现能否用对人、能否做艰难而不完美的决定最为关键，这非常考验管理者的智慧，也最能体现他/她到底相信什么。
以上这三条线可以总结为一句话：
“一张图、一场仗、一颗心”
作为领导者，首先要明确团队的战略大图是否清楚，能否让每一个细分部门找到自己的位置。同时，在互联网不确定的情况下，“一颗心”很重要，即一群有情有义的人共同打“一场仗”，做一件有意义、有价值的事情。
二、阿里巴巴对事对人的本质理解在阿里，HR团队的使命就是“聚”一群有情有义的人，一起做有价值的事。如何聚人？如何成事，我们有自己的理解。
事：战略循环圈
在2007年以前，阿里的战略基本是以年为单位，到了2008年之后，这个战略循环被严重地打乱。我们发现不同业务模块的节奏逐渐变得完全不同，有的从一年变成了半年，有的变成一个季度，有的甚至变成一个月。
面对这种不确定性，建立一个试错机制至关重要，于是我们针对“事”建立了类似PDCA的战略循环。
首先，“生成战略”；随后，将战略分解到各业务模块“集体行动”；然后，进行“客户反馈”；最后，基于“共同看见”进行战略调整。
阿里对战略的定义是：战略＝客户价值×客户感受。其核心包括三个问题：
客户是谁？客户的痛点是什么？如何解决？
在商业环境中，满足客户需求最为关键。
△阿里PDC战略循环
其中，“共同看见”极具阿里特色。
我们的业务可以称为“双边市场”，既要服务消费者，又要服务好卖家，因此要强调整体利益的最大化。这个过程并非为每位客户做到价值最大化那么简单，而要基于整个生态环境进行判断，甚至让消费者和卖家参与进来共同选择与判断，比如：阿里尝试的“卖家自治”策略。大家“共同看见”得越深，做出的策略也越有生命力。在帮助业务成功的同时，还应让组织得以发展。在不同的业务阶段，阿里基于战略循环沉淀出了几个典型的帮助组织发展的工具，在“共同看见—生成战略—集体行动—客户反馈—共同看见”等各个环节，分别沉淀了“共创、KPI、三板斧、复盘”等工具。阿里对业务领导者的要求比较苛刻，要求其做到“雌雄同体”，如果说PDC战略循环是“雄”的一面，那么共创、KPI、三板斧、复盘等环节就属于“雌”的一面。
人：关注组织的“心”“脑”“体”
一个人最快乐的状态，莫过于心里向往的、头脑里思考的、手里做的事情是一样的。组织如人，“心”对应着组织的文化，“脑”对应着组织的能力，“体”相当于组织的体系机制。
“体”是组织的骨骼，包括绩效考核机制、利益分配机制以及相应的配套体系、机制、流程等；“脑”即能力，相当于组织的肌肉，只有肌肉够发达，骨骼才能强壮；当然，阿里最看重的是“心”，即我们到底为什么要在一起？事情背后的意义和价值是什么？阿里追求的是伙伴间的情义，希望共同做一件对这个社会有价值的事情；
将“心”“脑”“体”组合，就形成了“组织能量”，杨国安教授有一个“经营业绩 = 战略 ×组织能力”，但阿里认为“成功＝战略 组织能量”。能力都可以被训练，但能量是每个人与生俱来的，取决于你如何激发；“心”最重要，员工内心的那团火都藏在心内，关键在于你是否能找到那根导火索。 发挥阿里OD的价值
在组织发展的过程中，我总会问自己与团队一个问题：“我们不是做业务的，怎么在业务中为战略落地提供价值？”
经过这几年的摸索，阿里OD（组织发展）团队在助力战略到执行的过程中，找到了三个核心切入点：第一，强化“从未来看现在”的能量；第二，切换“从客户看我们”的视角；第三，激发个体内在状态，去创造性地面对理想与现实之间的张力。“从未来看现在”
做业务的员工很容易沉浸在每日的运营细节中，精心思考如何达到业务目标。这本来无可厚非，但阿里很多业务属于开拓性质，前无古人，如果只沉浸在运营的思路中，就很容易局限自己。
正如一句阿里话所问：“你做决策是基于利益计算，还是基于相信？”业务的投入产出可以通过计算来明晰，但这样的事情往往是在复制过去，而凡是创造未来的事情通常无法用现成逻辑计算。
所谓的“相信”，就是我们这个业务的初心是什么？这个社会会因为我们而有什么不同？然后再看应该坚持什么？打破什么？
因此，OD团队很关键的一个作用是定期组织活动，让大家回看业务出发时的初心，让整个团队共同找到由心而发的能量，脚踏实地、更好地创造未来。“从客户看我们”
阿里谈战略的三个经典问题：“WHO、WHAT、HOW”，我们会惯性地在“WHAT”和“HOW”的层面工作，但业务部门却很少有时间聚在一起讨论“WHO”，即你的客户是谁？谁是你的主要客户？谁不是你的客户？
我们有个很深的体感，当部门存在协同问题时，其实本质上往往是大家对客户选择的不同，只有让他们认识到这点不同，并对“客户是谁”达成共识时，合力自然而然产生。
另一种很典型的场景是，我们总是不自觉地拿解决方案来套客户的需求。如何真正倾听并理解客户的需求，是阿里的四大组织能力之一，因而OD团队会通过组织产品如三板斧，以及一些特定的流程、互动方式，帮助业务领导者从惯性中走出来，“把脚真正穿到客户的鞋里去”。△从战略到执行
我们越来越从一个确定的世界走向一个不确定的世界，在不确定性极大的业务里，领导者的位置逐渐从中心退到边缘，需要的领导风格也因此有很大不同。阿里许多领导者都有过山车的体验——业务总是忽明忽暗，时而觉得已经清楚，时而又迷失了方向。
但是，我们知道创新总是发生在未知领域，需要深入未知的水底才有机会创新。而作为人性的一部分，没有人愿意失控，因为未知里有不安、迷茫甚至恐惧。
在这样的情况下，OD团队要做的是，在具体业务探索中，让领导者打破内心的自我惯性，让团队产生“背靠背”的信任，勇于面对真实。
阿里有这样一句话：“真实比正确更重要”——“正确”是基于过去和昨天的判断，“真实”是你作为个体去真正。
https://www.toutiao.com/a6718140565805859332/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18d312c4196df21aff2301c007f1d732/" rel="bookmark">
			几何代数与球面几何
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		n n n维球面 S n = { x ∈ R n + 1 ∣ x 2 = 1 } \mathcal S^n=\{x\in\mathbb R^{n+1}|x^2=1\} Sn={x∈Rn+1∣x2=1}的齐次空间模型是 N p 0 n = { x ∈ N n ∣ x ⋅ 0 = − 1 } \mathbb N_{p_0}^n=\{x\in\mathbb N^n|x\cdotp_0=-1\} Np0​n​={x∈Nn∣x⋅0​=−1}，其中 p 0 p_0 p0​为 R n + 1 , 1 \mathbb R^{n+1,1} Rn+1,1里面特征为负数的单位向量。 R n + 1 \mathbb R^{n+1} Rn+1是 p 0 p_0 p0​的对偶空间， R n + 1 = p ~ 0 \mathbb R^{n+1}=\widetilde p_0 Rn+1=p ​0​，是一个 n + 1 n+1 n+1维Euclidean空间，单位球是 S n \mathcal S^n Sn。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18d312c4196df21aff2301c007f1d732/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbb9a23180b76d94ff3bfcc9a369d63a/" rel="bookmark">
			如何使用Matlab绘制图形并标记图例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当我们在写cscd、EI或者SCI论文时，常常需要放置一些图片，通常情况下需要对图片进行一些处理，对图像横纵坐标、曲线进行标记。本文阐述如何使用Matlab来实现这些功能。
1、如何使用Matlab绘制相关曲线图
在Matlab中，常采用plot函数来绘制二维图像。其函数格式如下：
plot(x,y) 如果x,y都属于向量，则它们必须具有相同的长度，plot函数将以x为横轴，绘制出y。如果x,y都属于矩阵，则它们必须具备相同的尺寸，此时plot函数将x的第1列和y的第1列对应取出来，绘制一条曲线，然后将x的第2列与y的第2列对应起来，绘制另外一条曲线，以此类推直到完成第n条曲线的绘制。
plot(x,y,LineSpec,‘PropertyName’,Property Value,…)格式，其中LineSpec表示指定曲线颜色、线型等特征的字符串，PropertyName表示绘制曲线的线宽、标记点边框线条颜色，标记点大小等等，关于LinSpec以及PropertyName的相关属性见下表：
例子：
x = -5:0.5:5; y = 5.*exp(-abs(x)) .*sin(x); plot(x,y,'--Hr','LineWidth',1.5,'MarkerEdgeColor','b',... 'MarkerFaceColor','m','MarkerSize',10) 2、如何给图像进行图例标注
当我们在绘制图像时，往往需要对图像的横纵坐标以及该图的标题进行相应的标注，例如
这幅图中横纵坐标“The i-th singular value”、“Magnitude (log)”等可以采用MATLAB中的xlabel以及yxlabel等形式绘制出来，如下：
xlabel(‘The i-th singular value’), ylabel(‘Magnitude (log)’).
xlabel(‘string’,‘PropertyName’,PropertyValue,…)格式可以设置横纵坐标的其他相关属性，比如字体颜色、大小、加粗等。
在MATLAB中常用的图形修饰函数名称及其说明见下表所示：
3、图例和颜色条（legend函数）
在所绘制图形中常常需要标注图形中不同颜色、线条的数据组的实际意义，此时可以通过legend函数来实现。legend函数格式为：
legend(‘string1’,‘string2’,…)
代码示例如下：
x = 0:0.02*pi:2*pi; y1=sin(x); y2=cos(x); y3=sin(3*x).*cos(x); plot(x,[y1;y2;y3]) legend('sin(x)','cos(x)','sin(3x)cos(x)') 可以通过下述代码对横坐标轴进行自定义：
set(gca, 'xticklabel', [1 3 5 7 9]); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26b3ad09ca9aa24e87072ce8e3b574eb/" rel="bookmark">
			easy-x库graphics.h图形库安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		easy-x库graphics.h图形库安装 graphics.h就是C++下easy-x库的一个图形库，还蛮好玩的，你想用vc6.0还是VS都是需要自己安装这个库的，接下来就来看着怎么安装吧！ 一.先去下个easy-x
进官网转转https://easyx.cn/
emmm这里有两个下载诶，那怎么选呢？
我建议点右边那个“下载EasyX”，方便简洁，直接下载
左边这个下载点进去是这样的
哇好多版本啊，选择恐惧症看着就不想选，还是刚刚那个吧
点击下载
最好更改保存路径到桌面，方便找到，也方便不用的时候删除，哈哈哈
下完后有两种情况
1.你下到桌面的是一个压缩包
那就解压，然后打开解压后的文件夹
运行这个setup
2.下载的就是一个软件，类似这样
那就直接运行好了
无论哪一种情况，运行后点下一步
然后在这里找到自己编程软件对应的版本点击安装就好了，就可以直接进入对应软件调用这个库了，是不是特别简单啊，哈哈哈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d145635eeccbabffabe81845ad89aee1/" rel="bookmark">
			机器学习笔记 | Supervised Learning and Unsupervised Learning（监督学习和无监督学习）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		趁着开学前，计划入门机器学习，选择了coursera吴恩达老师的机器学习课程。
（如果打开视频看不了解决方法访问：https://www.cnblogs.com/marsggbo/p/7625575.html）
1、初识机器学习 机器学习的应用已经渗透了很多方面，如google搜索引擎苹果的图片识别，垃圾邮件过滤器，淘宝的推荐等等。
两种提出的机器学习的定义：
Arthur Samuel将其定义为：“在特定编程的情况下，给予计算机学习能力的领域”。这是一个较旧的，非正式的定义。
Tom Mitchell提供了一个更现代的定义：“一个程序被认为能从经验E中学习，解决任务T，达到性能度量值P，当且仅当，有了经验E后，经过P评判，程序在处理T时的性能有所提升。“
例如：玩跳棋。
E =下棋者的经验
T =下棋的任务。
P =该程序将赢得比赛的概率。
在一般情况下，任何机器学习问题可以被分配到两大类别之一：
监督学习（Supervised Learning）和无监督学习（Unsupervised Learning）。
2、监督学习（Supervised Learning） 在监督学习中，我们给出了一个数据集，并已经知道了我们的正确的输出应该是什么样子，并且认为输入和输出之间存在关系。
监督学习问题被分为为“回归（regression）”和“分类（classification）”问题。在回归问题，我们试图在连续输出中预测的结果，这意味着我们正在尝试输入变量映射到一些连续函数。在分类问题，我们不是试图预测离散输出结果。换句话说，我们正试图输入变量映射到不同的类别。
列子1：基于房地产市场规模数据，试图预测它们的价格，价格是一个连续值输出，所以这是一个回归问题。
列子2：给定一个带有肿瘤的患者，试图预测肿瘤是良性还是恶性，是一个离散值的输出，这是一个分类问题。
3、无监督学习（Unsupervised Learning） 无监督学习使我们能够在几乎不知道或者根本不知道结果应该是什么样子的情况下解决问题。我们能够从不需要知道变量影响的数据中得到结构。我们可以根据数据中变量之间的关系对数据进行聚类，得到这种结构。
在无监督学习中，没有基于预测结果的反馈。 聚类（Clustering）：收集100万个不同的基因，并找到一种方法自动将这些基因分组，这些基因在某种程度上与不同的变量(如寿命、位置、角色等)相似或相关。
非聚类（Non-clustering）：“鸡尾酒会算法”，让你在混乱的环境中找到结构。(例如，在鸡尾酒会上从一堆声音中辨别出个人的声音和音乐)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75eab657e39f4a5992fcda1f1060782e/" rel="bookmark">
			sublime text3支持类函数跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开sublime text3，点击首选项下面的浏览插件，进入到packages目录：
打开User目录，看有没有Default (Windows).sublime-mousemap这个文件，如果没有，则新建一个该文件:
并输入如下内容即可：
[
{
“button”: “button2”,
“count”: 1,
“modifiers”: [“ctrl”],
“command”: “jump_back”
},
{
“button”: “button1”,
“count”: 1,
“modifiers”: [“ctrl”],
“press_command”: “drag_select”,
“command”: “goto_definition”
}
]
保存，ctrl键+鼠标左键即可实现类跳转。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b4bbc05495805cf7ff3b0dcd14a6b67/" rel="bookmark">
			排序算法之选择排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择排序：每一趟在n-i+1个有数据中选取最大（小）的数据，作为有序数组的第i个元素。
直接选择排序：
在元素集合array[i]~array[j]中选择关键码最小的元素若他不是这组元素中的第一个元素，就将它与这组元素中的第一个元素交换在剩余的array[i+1]~array[n-1]集合中，重复以上步骤，直到结合只剩下一个元素，排序完成 代码实现：
void SelectSort(int array[], int size){ int min;//记录最小元素的下标 for (int i = 0; i &lt; size - 1; i++){ min = i; for (int j = i + 1; j &lt; size; j++){ if (array[j] &lt; array[min]){ min = j; } } if (i != min){ int k = array[i]; array[i] = array[min]; array[min] = k; } } Print(array, size); } 总结:
时间复杂度：O(N^2)稳定性：不稳定 堆排序：
堆排序是利用堆积树这种数据机构所设计的一种排序算法，它是通过堆来进行选择数据，需要注意的是排升序建大堆，排降序建小堆。
堆的逻辑结构就是一个完全二叉树，存储结构是一个一维数组，数组中的每一个元素满足
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b4bbc05495805cf7ff3b0dcd14a6b67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/964a0777639229359474c48cf016708f/" rel="bookmark">
			C语言基本数据类型int, short int, long int, long long int, unsigned int, signed int等解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 普通int类型 int类型是有符号整型，即int类型的值必须是整数，可以是正整数，负整数，零。
int类型取值范围因计算机系统而异。早起的16位IBM PC兼容机使用16位来存储一个int值，其取值范围是-32769 ～32768。目前个人计算机一般是32位，因此用32位存储一个int值。现在随着个人计算机产业的发展，个人计算机逐步迈向64位处理器发展，自然可以储存更大的整数。ISO C规定int的取值范围最小为-32769 ～32768。
1.1打印int值 我们知道可以使用printf()函数打印int类型的值，%d指明了在一行中打印整数的位置。
%d称为转换说明。
例1⃣️：
# include &lt;stdio.h&gt; int main(void) { int i = 10; int j = 3; printf("%d %d\n", i, j); return 0; } Output：
10 3 第一个输出控制符%d 对应的是第一个输出参数i，第二个输出控制符%d对应的是第二个输出参数j
例2⃣️：
# include &lt;stdio.h&gt; int main(void) { int i = 10; printf("%d\n", i); return 0; } 这句话的意思是将变量 i 以十进制输出。
那么现在有一个问题：i 本身就是十进制，为什么还要将 i 以十进制输出呢？
因为程序中虽然写的是 i=10，但是在内存中并不是将 10 这个十进制数存放进去，而是将 10 的二进制代码存放进去了。计算机只能执行二进制 0、1 代码，而 0、1 代码本身并没有什么实际的含义，它可以表示任何类型的数据。所以输出的时候要强调是以哪种进制形式输出。所以就必须要有“输出控制符”，以告诉操作系统应该怎样解读二进制数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/964a0777639229359474c48cf016708f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecfb1b825182c7fe5f8f800bf3280ce2/" rel="bookmark">
			[windows]原生c&#43;&#43; Tcp socket通信简单详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		又是幻想进鹅厂的一天 ┭┮﹏┭┮
这个是当时Qt的 tcpServer :https://blog.csdn.net/weixin_42837024/article/details/88847220 写Qt写的想了一下,原生的 c++ tcp是怎么写的？我还不会,网上查了查资料 自己写了个小demo玩一玩
发现tcp socket 通信都是那回事
下面先介绍一下 TCP 的基础知识（ 还挺重要的 毕竟大厂挺注重基础的） TCP ：Tcp 协议传输控制协议(Transmission Control Protocol) 1.面向连接的 :先连接,在通信,比如电话? 2.可靠的:基于面向连接机制,3次握手协议 等,要比UDP 可靠 3.基于字节流的:这就意味着数据是以字节流的形式传递给接收者的， 没有固有的”报文”或”报文边界”的概念。从这方面来说，读取TCP数据 就像从串行端口读取数据一样–无法预先得知在一次指定的读调用中会 返回多少字节（也就是说能知道总共要读多少，但是不知道具体某一次读多少）。 UDP创建UDP socket——DGRAM：基于数据报通信方式，每一次发送的数据 都是一个独立的整体，包含目标主机的ip地址、端口号及发送数据的内容 3次握手和4次握手 3次握手 通俗讲: 假设一个为A 一个为B
(第一次): A问B 你听得到吗?(说明A能发出声音 代表可以send)
(第二次): B说我听到了,你能听到吗?(说明B能听到声音 代表可以read)
(第三次): A说我也听到了，那咱们开始吧(说明A也能听到read,B也能发声音send)
如果是2次握手的话 不能确保可靠性,4次的话就冗余了,所以就是3次握手
4次挥手 (第一次):A说 我说完了,你还有话说吗(因为不确定B还有没有话说)
(第二次):B说 等等我还有一句话 (i love you）
(第三次):A听完了 说现在还有想说的吗 B说 没有了,想说的都说了,挂了吧
(第四次):A说 好 挂了吧 A挂 B挂
tcp 编程一般的步骤: server(服务端) 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecfb1b825182c7fe5f8f800bf3280ce2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/467/">«</a>
	<span class="pagination__item pagination__item--current">468/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/469/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>