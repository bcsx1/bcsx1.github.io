<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f297cea33374a782f4e205b6d0d84b6/" rel="bookmark">
			Spring Websocket 跨域访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 官方文档springwebsocket 4.1.5版本前默认支持跨域访问，之后的版本默认不支持跨域，需要设置：
.setAllowedOrigins("*") &lt;websocket:handlers allowed-orgins="*"&gt; ... &lt;/websocket:handlers&gt; 具体实现代码：
方式一：
@Configuration @EnableWebMvc @EnableWebSocket public class WebSocketConfig extends WebMvcConfigurerAdapter implements WebSocketConfigurer{ @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) { registry.addHandler(systemWebSocketHandler(),"/webSocketServer"); registry.addHandler(systemWebSocketHandler(),"/webSocketServer/sockjs").setAllowedOrigins("*").withSockJS(); } @Bean public WebSocketHandler systemWebSocketHandler(){ return new SystemWebSocketHandler(); } 方式二：
&lt;websocket:handlers allowed-origins="*"&gt; &lt;websocket:mapping path="/webSocketHandler" handler="webSocketHandler"/&gt; &lt;!--&lt;websocket:handshake-interceptors&gt; &lt;bean class="com.tyron.web.interceptor.WebSocketSessionHandshakeInterceptor"/&gt; &lt;/websocket:handshake-interceptors&gt;--&gt; &lt;/websocket:handlers&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a20ae19fa68c246a60990fb9bd2e405/" rel="bookmark">
			c语言中字符指针与字符数组的区别：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		char 是用来存储单个字符的；
例如：
char ch=’a’; char[]是用来存储多个字符的；
例如：
char ch[5]={‘h’, ‘e’, ‘l’, ‘l’, ‘o’}; //数组本质上就是同时定义了多个变量，并对变量进行初始化
当char[]最后一个字符为‘\0’的时候，这是一个字符串
例如：
char ch[6]={‘h’, ‘e’, ‘l’, ‘l’, ‘o’, ‘\0’}; 字符串也可以写成：
char ch[6]=”hello”;// char ch[]=”hello”;//一般为了方便，不写数组元素个数//引号引起来的是字符串，默认结尾处有'\0' char ch1[]=”world”;//存储在栈内存，内容可以被修改 char *ch2=”hello world”;//存储在常量区，内容不能被修改等价于const char *ch =”hello world”; 注意：ch2是一个局部指针变量，存储在栈中，而“helloworld”则是存储在常量区的。但是，ch，ch1以及其中的数组，hello,world均是存储在栈中的。
//char * 字符指针与int*相比在形式上多了这种赋值方式：
1)
int* i=&amp;j;//赋值的是一个地址； char ch[]=”hello world”;//ch保存了字符串首字符的地址 char* p=ch;// 字符指针指向了字符串的首字符h *p =’T’//这样是对的，因为字符指针p指向的是一个字符变量 //这是char* 与int*的相同的地方；
2）
char* ch=”hello world”; //char*还可以直接赋值一个字符串常量！！！这个与int*的不同之处。
//实质上”helloworld”返回的也是地址，而不是字符串常量本身。 对字符串数组进行初始化的方法有两种：
1） 定义的时候直接初始化：
char ch[]=”hello”; 2)使用字符数组的拷贝函数
char* strcpy(char *dst, const char *src); char ch[6]; char *p=”hello”; strcpy(ch,p); 注意：dst是已经申请的内存单元，足够大的可修改的内存区域，需能盛下src内的字符个数，并且不能是指向常量的字符串常量，所以可以是字符数组char ch[6];也可以是new的内存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a20ae19fa68c246a60990fb9bd2e405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76bb76089824c19d12ccc6877708b7cd/" rel="bookmark">
			python-解决pip安装速度慢的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于Python开发用户来讲，PIP安装软件包是家常便饭。但国外的源下载速度实在太慢，浪费时间。而且经常出现下载后安装出错问题。所以把PIP安装源替换成国内镜像，可以大幅提升下载速度，还可以提高安装成功率。
国内源： 新版ubuntu要求使用https源，要注意。
清华：https://pypi.tuna.tsinghua.edu.cn/simple
阿里云：http://mirrors.aliyun.com/pypi/simple/
中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/
华中理工大学：http://pypi.hustunique.com/
山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/
临时使用： 可以在使用pip的时候加参数-i https://pypi.tuna.tsinghua.edu.cn/simple例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider，这样就会从清华这边的镜像去安装pyspider库。 永久修改，一劳永逸： Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)
内容如下：
[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host=mirrors.aliyun.com windows下，直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini。内容同上。
原网页：http://www.cnblogs.com/microman/p/6107879.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/354b0f03b1cee71672d62768bf646459/" rel="bookmark">
			logback配置每天生成一个日志文件,保存30天的日志文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;configuration&gt; &lt;!-- 文件输出格式 --&gt; &lt;property name="PATTERN" value="%-12(%d{yyyy-MM-dd HH:mm:ss.SSS}) |-%-5level [%thread] %c [%L] -| %msg%n" /&gt; &lt;!-- test文件路径 --&gt; &lt;property name="TEST_FILE_PATH" value="D:\\comp\\日志管理" /&gt; &lt;!-- pro文件路径 --&gt; &lt;property name="PROD_FILE_PATH" value="/var/log/tomcat/systemName" /&gt; &lt;property name="LOG_NAME" value="systemName" /&gt; &lt;!-- 开发环境 --&gt; &lt;springProfile name="dev"&gt; &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;${PATTERN}&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 输出到文件 --&gt; &lt;logger name="org.springframework.jdbc.core.JdbcTemplate" level="debug"/&gt; &lt;logger name="com.guige" level="debug" /&gt; &lt;root level="info"&gt; &lt;appender-ref ref="CONSOLE" /&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;!-- 测试环境 --&gt; &lt;springProfile name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/354b0f03b1cee71672d62768bf646459/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2784be472b8d8a0a5229a83790ba5814/" rel="bookmark">
			Excel VBA高级编程 - 根据关键字自动搜索，自动生成下拉菜单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注微信公众号：万能的Excel，回复关键词【下拉菜单】获取Excel源文件
功能说明： 因为工作需要，每一次都要从SAP查找物料信息，手动生成物料清单（Boom表），繁琐且容易出错。
使用VBA实现了如下功能：
1、根据关键字，自动检索符合条件的产品信息
2、自动生成下拉菜单
3、选定物料名称，其他产品信息将自动对应输入
1
附件代码：
Private Sub Worksheet_Change(ByVal Target As Range) Dim whereStr$, sql$, conn, mr%, j%, k%, l%, n% Dim i As Long, w1 As String j = Target.Row On Error Resume Next k = Application.WorksheetFunction.Match(Sheet6.Cells(Target.Row, 3), Sheet2.Range("D1:D103"), 0) l = Application.WorksheetFunction.Match(Sheet6.Cells(Target.Row, 2), Sheet2.Range("C1:C103"), 0) n = Application.WorksheetFunction.Match(Sheet6.Cells(Target.Row, 1), Sheet2.Range("b1:b103"), 0) If k &gt; 0 And l = 0 Then Cells(Target.Row, 2) = Application.WorksheetFunction.Index(Sheet2.Range("C:C"), k) ElseIf k &gt; 0 And l &gt; 0 And n = 0 Then Cells(Target.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2784be472b8d8a0a5229a83790ba5814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a73641c7a75009e0a34ebaea29f6859/" rel="bookmark">
			使用canvas将照片和海报边框图片合成海报的移动端例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求： 类似一些美图软件中的给照片加相框的操作 1. 用户选择照片，照片可以移动、可以放大缩小 2. 选择海报模版 3. 生成海报 最后生成的海报效果图类似下图 使用的技术栈是：vue+html2canvas+exif-js 具体思路和代码：
html部分，思路和逻辑在代码下面写着 &lt;template&gt; &lt;section&gt; &lt;div id='posterwrap' v-show='!sharing' ref="wrap"&gt; &lt;div ref='posterwrap-inner' class="posterwrap-inner"&gt; &lt;p v-show='!temp.imgsrc' @click='chooseimg'&gt;&lt;/p&gt; &lt;!-- 照片预览区 --&gt; &lt;div class="preview-img-wrap"&gt; &lt;img @touchstart.prevent.stop='touchStart($event, 0)' @touchmove.prevent.stop='touchMove($event, 0, -1)' @touchend.prevent.stop='touchEnd($event, 0)' :style='{width: 99 * myphoto.scale + "%", height: 99 * myphoto.scale + "%", left: myphoto.x + "px", top: myphoto.y + "px"}' :src="myphoto.imgsrc" id='preview' alt="" ref="img" &gt; &lt;/div&gt; &lt;!-- 选择的海报模版 --&gt; &lt;img @touchstart.prevent.stop='touchStart($event, 0)' @touchmove.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a73641c7a75009e0a34ebaea29f6859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/603e60af1b21d0cac9691745047dcb49/" rel="bookmark">
			OkHttp源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文配套视频： okhttp内核分析配套视频一okhttp内核分析配套视频二okhttp内核分析配套视频三 源码分析相关面试题 Volley源码分析注解框架实现原理 基本使用 从使用方法出发，首先是怎么使用，其次是我们使用的功能在内部是如何实现的.建议大家下载 OkHttp 源码之后，跟着本文，过一遍源码。
官方博客栗子：http://square.github.io/okhttp/#examples
OkHttpClient client = new OkHttpClient(); String run(String url) throws IOException { Request request = new Request.Builder() .url(url) .build(); Response response = client.newCall(request).execute(); return response.body().string(); } 12345678910 Request、Response、Call 基本概念 上面的代码中涉及到几个常用的类：Request、Response和Call。下面分别介绍：
Request 每一个HTTP请求包含一个URL、一个方法（GET或POST或其他）、一些HTTP头。请求还可能包含一个特定内容类型的数据类的主体部分。
Response 响应是对请求的回复，包含状态码、HTTP头和主体部分。
Call OkHttp使用Call抽象出一个满足请求的模型，尽管中间可能会有多个请求或响应。执行Call有两种方式，同步或异步
第一步：创建 OkHttpClient对象,进行源码分析： OkHttpClient client = new OkHttpClient();` 1 通过okhttp源码分析,直接创建的 OkHttpClient对象并且默认构造builder对象进行初始化
public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory { public OkHttpClient() { this(new Builder()); } OkHttpClient(Builder builder) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/603e60af1b21d0cac9691745047dcb49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41645f15158b0a2202e590cb4205d5a3/" rel="bookmark">
			ConstraintLayout 中 Barrier的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Barrier 是用多个 View 作为限制源来决定自身位置的一种辅助线.
&lt;android.support.constraint.Barrier android:id="@+id/barrier1" android:layout_width="wrap_content" android:layout_height="wrap_content" app:barrierDirection="right" app:constraint_referenced_ids="button2,button1" /&gt; 其中 constraint_referenced_ids 指定限定源id,多个id用逗号隔开
barrierDirection 指定限制的方向 , 有 left, right, top, bottom, start, end, 6种
上面代表的是 barrier1 以 button2 和 button1 两者最右侧为基准线来作为自己的定位
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50bc8eeacbcb68f0e2421f849f1a5193/" rel="bookmark">
			bat实现每天定时执行命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 比如希望电脑在每天03:00自动关机：at 03:00 /every:M,T,W,Th,F,S,Su "shutdown -s" M就是Monday，T就是Tuesday，后面类推，意思就是每周的每一天都运行。登录后运行我不知道怎么使用at命令来实现，不过可以“附件”-“系统工具”-“任务计划程序”来实现。 操作步骤如下：1.进入任务计划程序后点击右边的“创建任务”2.常规项中填入计划的名字3.触发器中点击“新建”，开始任务选择“登录时”，下面还能设置登录延时时间等4.操作项中点击“新建”，比如我要一登录就关机，则可在“程序或脚本”中输入“shutdown”，参数中输入“-s”，最后点“确定”即可。操作完成后就可以在任务计划程序库中看到这个计划了，可以自由修改，非常方便。（包括上面的at命令也会在这里体现，而且这里修改更加直观和方便） https://www.5420.com.cn/topnews/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/911c4a0e5b2c52f3ff21e890656a1a03/" rel="bookmark">
			AdMob Android谷歌广告接入（精简版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里先附上谷歌AdMob API官方说明文档的地址，如果有不明白或者想详细了解的可以点击进入 查看学习：https://developers.google.com/admob/android/rewarded-video
顺便附上广告请求错误码对应原因查看的网址： https://developers.google.com/android/reference/com/google/android/gms/ads/AdRequest
话不多说，在项目里面需要用到的加载谷歌广告的地方比较多，重复代码多次写没有必要，所以封装了一个工具类，直接调用方法就行，你在使用时可以更加细节封装优化一下~
LoadGoogleAd.kt代码：
import android.app.Activity import android.util.Log import android.widget.Toast import com.google.android.gms.ads.AdListener import com.google.android.gms.ads.AdRequest import com.google.android.gms.ads.InterstitialAd import com.google.android.gms.ads.MobileAds import com.google.android.gms.ads.reward.RewardItem import com.google.android.gms.ads.reward.RewardedVideoAd import com.google.android.gms.ads.reward.RewardedVideoAdListener import com.wj.R /** * @time 2018/6/11 * @author JunJieW * @since 1376881525@qq.com * @description 谷歌广告加载封装工具类 */ class LoadGoogleAd { private val TAG = "LoadGoogleAd" private var activity: Activity? = null internal var mInterstitialAd: InterstitialAd? = null lateinit var mRewardedVideoAd: RewardedVideoAd constructor(activity: Activity, adType: String) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/911c4a0e5b2c52f3ff21e890656a1a03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63a7d812a6e7b0372f9d58c52f73c511/" rel="bookmark">
			Hive_ Hive 建表语句详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：
https://blog.csdn.net/qq_36743482/article/details/78383964
最近博主在编写一个每天定时创建Hive 分区的脚本，其中需要创建Hive表，
开始的时候我以为创建Hive 表的语句顺序是比较宽松的，经过测试发现不然，
Hive 创建表需要比较固定的书写顺序
虽然暂时不知道这个顺序，可以查阅什么样的文档找到，如果知道的朋友，可以在底下踊跃留言，有红包派送
下面对Hive 建表的格式规范进行讲解
注：hive其他语法在hive官网有说明，建议初学者，去官网学习一手的资料， 官网：https://cwiki.apache.org/confluence/display/Hive/Home#Home-UserDocumentation
Create Table 官网说明 Hive建表方式共有三种：
直接建表法查询建表法like建表法 首先看官网介绍 ‘[]’ 表示可选，’|’ 表示二选一
CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name -- (Note: TEMPORARY available in Hive 0.14.0 and later) [(col_name data_type [COMMENT col_comment], ... [constraint_specification])] [COMMENT table_comment] [PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)] [CLUSTERED BY (col_name, col_name, ...) [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS] [SKEWED BY (col_name, col_name, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63a7d812a6e7b0372f9d58c52f73c511/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da1c9c057422c5e64c816e7b17154b2c/" rel="bookmark">
			在vue项目中如何引用mui来实现监听安卓手机的物理返回键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先下载mui.js，直接在vue项目中的index.html页面中引入进来 2.在index.html中加入下面的代码 &lt;script&gt; mui.init({ swipeBack: false, //关闭右滑关闭功能（默认就是false） keyEventBind: { backbutton: true //开启back按键监听（默认就是true） } }); var quitTime = null; mui.plusReady(function(){ mui.back = function(){ //首次按键，提示‘再按一次退出应用’ if (!quitTime) { //记录第一次按下回退键的时间 quitTime = new Date().getTime(); //回退到上一页面 window.history.go(-1); setTimeout(function() { //1s中后清除 quitTime = null; }, 1000); }else{ if((new Date().getTime() - quitTime) &lt; 1000){ quitTime = null; plus.runtime.quit(); } } }; }); &lt;/script&gt;
3.ctrl+S保存，结束
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9abcdb1f881f08f9c62ad3806a737bc/" rel="bookmark">
			安卓开发的SQLite操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、存储方式简介 之前已经讲解过APP对接服务器的demo，众所周知，一个APP，必不可少地会涉及到服务器以及数据库的操作。连接服务器，可以让我们合理地利用服务器以及客户端进行任务分配，如果所有功能都在客户端或者服务端完成，必然会造成一头大一头小的情况。合理地安排任务，能够大大地提高APP的稳定性以及可操作性。而对于一个多用户使用的APP，用户使用过程更是会产生许多的数据，其中一些有用的数据需要我们保存下来，因为下次使用用户可能还需要继续使用。
在安卓开发之中，提供给我们使用的存储方法有较多。
如果这些数据只是在当前activity生命周期之中有用到的（一次性数据），我们可以直接通过定义变量的形式来临时储存（activity结束或者系统内存紧张时，这些变量随时都有可能被回收）。这种方法优缺点比较明显，存储快速，定义简单，但是数据没有持久性。将数据存储在手机文件里。将数据存储在手机文件里，可以解决上面临时变量的缺点，利用JAVA流将数据存储在手机文件之中，对于一些数据类型较为简单的存储十分实用。但是以文件的形式来存储数据，缺点也很明显，首先，手机文件存储数据，能实现的存储数据类型十分有限，对于一些具有复杂联系的数据难以储存，就算存放进去了，后期的维护也是十分艰难。第三个存储方法就是利用JAVA提供的一个SharedPreferences类来存储数据。其实这一种方法跟手机文件存储有点相似，但是该方法下存储的数据是以键值对的形式进行存储的，之后在读取时可以通过键来读取对应键的内容，这样的存储方式对于一些常见的键值数据的存储十分方便。虽然SharedPreferences方法比之手机文件存储方式多了一个键值对的功能，但是仍然无法很好地处理一些复杂数据类型。数据库。数据库相信大部分人都有听说过，数据库分为多种类型，而最常见的就是关系型数据库了。关系型数据库通过数据之间的关系来建表，并且通过表的形式来管理数据，实现数据的增删查改。虽然数据库能够很好地维护一些复杂数据类型，但是对于一些简单的数据存储，就没有必要使用数据库来管理了，这样反而显得冗余。 2、SQLite简介 本次程序使用的数据库是SQLite数据库，实现的是一个APP连接到数据库的增查改操作。先看一下APP实现的功能：
SQLite是一款轻量级的关系型数据库，它运算速度快，占用资源少，通常只需要几百k的内存就够了，支持标准的sql语法和数据库的ACID事务。在Android中为了能够更加方便的管理数据库，专门提供了一个SQLiteOpenHelper帮助类，借助这个类就可以非常简单的对数据库进行创建和升级。
SQLiteOpenHelper是一个抽象类，如果我们要使用的话，就需要创建一个自己的类去继承它。SQLiteOpenHelper中有2个抽象方法，分别是onCreate和onUpgrade方法，我们必须在自己的帮助类里面重写这两个方法，然后分别在这两个方法中实现创建，升级数据库的逻辑。
SQLiteOpenHelper中还有2个非常重要的实例方法，getReadableDatabase()和getWritableDatabase()方法。这两个方法都可以创建或打开一个现有的数据库（如果数据库已经存在则直接打开，否则创建一个新的数据库），并返回一个可对数据库进行读写操作的对象。不同的是当数据库不可写入的时候（如磁盘空间已满）getReadableDatabase()方法返回的对象将以只读的方式去打开数据库，而getWritableDatabase()方法方法将出现异常。
SQLiteOpenHelper中有2个构造方法可供重写，一般使用参数少点的那个构造方法即可。这个构造方法中接收4个参数，第一个参数是Context，必须要有Context才能对数据库进行操作。第二参数是数据库名，创建数据库时使用的就是这里使用的名称。第三个参数允许我们在查询数据的时候返回一个自定义的Cursor，一般都是传如null。第四个参数表示当前数据库的版本号，可用于对数据库进行升级操作。构建出SQLiteOpenHelper的实例后，在调用它的getReadableDatabase()或getWritableDatabase()方法就能够创建数据库了，数据库文件会存放在/data/data/&lt;package name&gt;/databases/目录下。此时，重写的onCreate方法也会得到执行，所以通常在这里去处理一些创建表的逻辑。
3、SQLite数据库的创建 SQLite数据库的创建主要是通过继承SQLiteOpenHelper并重写其onCreate(用来创建数据库)，onUpgrade(用来更新数据库)，onDowngrade(用来数据库的版本向下兼容，若是不重写该方法，那么就必须保证数据库的版本version每次操作都是大于或者等于上一次的操作的版本)。具体看一下代码：
public class MySQLite extends SQLiteOpenHelper{ //从ShareData中取得想要新建的表名 ShareData sData=new ShareData(); //建表语句 private Context context; public MySQLite(Context context,String name, SQLiteDatabase.CursorFactory factory,int version) { super(context,name,factory,version); this.context=context; } /* * 建表，该表有四列，分别为主键id、username、password以及验证码verification * @see android.database.sqlite.SQLiteOpenHelper#onCreate(android.database.sqlite.SQLiteDatabase) */ @Override public void onCreate(SQLiteDatabase db) { if(!sData.get().isEmpty()) { String CREATE_BOOK="create table "+sData.get()+"("+"id integer primary key autoincrement," +"username text,"+"password text,"+"verification integer)"; db.execSQL(CREATE_BOOK); Log.i("建表界面","表名是"+sData.get()); Toast.makeText(context, "建表成功", Toast.LENGTH_SHORT).show(); } else Toast.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9abcdb1f881f08f9c62ad3806a737bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6be5feb6aa5352c6418d2e4b540dcbed/" rel="bookmark">
			千万级消息设计--初级篇（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 本文都是参加工作的实际情况,希望对大家有所帮助。—— 蚂蚁爬树不怕高，有心学习不怕老。
需求 1.用户个人消息，平台消息（平台给所有人发送消息）。
2.用户未读消息展示，消息列表展示
初期mysql数据库表设计： 1.用户信息表users_message
CREATE TABLE `users_message` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(200) DEFAULT NULL, `content` varchar(4000) DEFAULT NULL, `uid` int(11) DEFAULT NULL, `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `msg_type` tinyint(4) DEFAULT '1' COMMENT '用户消息为1, 系统消息为 0', `is_read` tinyint(4) DEFAULT '0' COMMENT '是否已读0未读1已读', `ope_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '操作更新时间【不由程序控制，由mysql系统控制】', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC; 2.平台信息表sys_message
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6be5feb6aa5352c6418d2e4b540dcbed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7bbdcaa998a6ac1a86b9c6e6c2c22dc/" rel="bookmark">
			AUC上升CTR一定上升么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记得几年前，百度从谷歌挖来了一个非常牛逼的工程师，这位工程师带来了很多机器学习的概念，实在是让自己这种土包子开了眼界，在一次会议上，这位工程师在解释auc和线上ctr的关系时，说 ”我做了这么多年机器学习，还从来没见过算法A在auc上胜过算法B，但是线上表现A比B差。” 必须备注一点，自己当时连auc都没搞清楚的小喽啰，也许记忆会有偏差，所以原话也许有偏差。
事实上，在点击率预估这项工程的开展初期，这句话非常正确，因为有对它的坚定信念，帮助我们fix了类似于线上线下环境不一致等无数工程bug。因此，看到这篇文章的同学们，如果你发现auc上升，点击率却不上升，请优先排查bug。在确定没有bug的情况下，再看下文吧。
在bug逐渐收敛之后，这段时间是令人欣慰的，无数次的找新的特征，加入模型，auc上升，线上ctr提升。可是逐渐的，我们出现了越来越多的AUC上升，但是CTR并不一定提升，甚至是有下降的情况，总结分析有下面几种情况：
环境特征的引入
这里的环境特征是指的网民特征，如query，cookie，流量等与广告无关的信息。如果环境特征引入起的作用只是把不会被点击的环境和可能被点击的环境区分开，例如加入了cookie特征，从而把样本拆的更细，而这个特征的加入的表现对评估数据集auc的提升只是表现在命中某些cookie，点击率为0，那么线上多半不会有太显著的变化，因为针对这些cookie，不管出什么广告，点击率都为0，对这部分情况预测的更好并不能对点击产生影响。
这种原因一般都有几个伴随的现象，相对比较好识别：
(1) instance变多，被拆的更细
(2) top auc上升
(3) ctr的分布左移
点击率和relevance的偏差
在Google的一篇paper：User browsing models: relevance versus examination中有很详尽的分析。
我们在说点击率的时候，实际上：点击率=true relevance * position_bias，在online应用的时候，我们都是将position设为相同，即通过true relevance对广告做的排序，而我们线下评估auc，都是对点击率做的评估。这里解释一下为什么online不用点击率做排序，理想情况下我们按照点击率最大化，应该是对所有候选的M个广告分别计算在排名为1,2,3，n的时候的点击率，然后用greedy的算法去计算怎样从中间选择n个广告使得总的点击率（第一名广告点击率+第二名广告点击率+。。）最高，但是这个计算量太大了，承受不起，所以干脆直接用排除掉位置影响的true relevance去排序。这样做并不会有太大问题，因为直观上，position_bias应该只与位置相关，而与广告相关。
好的，解释完了，回过来说我们线上用true relevance排序，但是线下评测用的点击率，这意味着算法A比算法B的排序性能好，只是说明true_relevance * position_bias比算法B好，不能说明A的true_relevance的排序性能比B好，除了上线检验，没有别的方法去验证。
在Google的这篇paper里面还提到position_bias越简单，可能越贴近真实情况（即前面说的position_bias只与位置相关，与环境，历史点击行为，广告本身都没有关系）是最好的。因此，如果我们对position_bias过度建模，比如LR模型里面加入了更多的位置相关的组合特征，会出现auc上升的情况，但是线上ctr反而会下降。事实上，我们曾经尝试去除了与位置相关的组合特征，线下auc有下降，但是线上ctr有了比较大的improve。
评估集合和线上集合的数据偏差（survival-bias 名词来源于张雷的ppt）
简言之，就是我们的评估集合是基于线上历史上曾经展现过的样本做的评估，线上未展现过的样本的表现是不清楚的，这其中可能会存在分布的偏差。
例如A1,A2,A3,B1,B2,B3是六个样本，真实的点击率高低排序应该是A1&gt;A2&gt;A3&gt;B1&gt;B2&gt;B3，历史上只有A1,A2,A3展现过
算法1的排序：A1&gt;A3&gt;A2&gt;B1&gt;B2&gt;B3
算法2的排序：B1&gt;B3&gt;B2&gt;A1&gt;A2&gt;A3
如果基于历史上展现过的样本做评估，算法2(A1&gt;A2&gt;A3)优于算法1(A1&gt;A3&gt;A2)，但是如果线上有较多的B1，B2，B3展现，那么算法2很可能表现还不如算法1
理论很简单，但是实践中，这个原因很难有指标去验证，除非原来的算法和现在的算法有非常大的差异，比如LR换成GBBT，一般历史样本和线上样本的分布本不会有太大的差异，这样你也就很难用线上新展现样本的比例或者A/B test在这部分新展现样本上去做什么比较。这是我最不喜欢的一个因素，因为所有最后查不出原因的auc上升，ctr没变化的case都很无奈的归咎于这个因素。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7d3880ef6c2459f43f9e972717c99f7/" rel="bookmark">
			C#类、对象、方法和属性详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#类、对象、方法和属性详解 C#类、对象、方法和属性详解
一、相关概念：
1、对象:现实世界中的实体（世间万物皆对象）
2、类:具有相似属性和方法的对象的集合
3、面向对象程序设计的特点:封装 继承 多态
4、对象的三要素：属性（对象是什么）、方法（对象能做什么）、事件（对象如何响应）
☆相互关系：类是对象的抽象，对象是类的实例，类是一种抽象的分类，对象则是具体事物。
比如如果车是一个类，某个人的一辆奔驰车就是一个对象，车的颜色质量就是它的属性，启动、停止这些动作则可以定义为车的方法。
二、类的定义与语法
1、定义类：
[修饰符] class 类名 {
类成员
}
2、类的访问修饰符:public internal
a) public:可访问域是所在的程序和任何引用的程序 访问不受限制
语法:
public class 类名
{
类成员
}
b) internal:可访问域定义范围内 (默认访问修饰符)
语法：
(internal) class 类名
{
类成员
}
3、类成员：数据成员和字段
a) 数据成员:字段和常量
字段:变量
声明:类型 字段名
例：
public class Persion
{
public string name;
}
b) 方法成员 （方法是类的行为，告诉我们类能够做什么，）
实例方法：
修饰符 返回值类型 方法名(参数列表)
{
方法体
}
修饰符：如：public、private、protected、internal
返回值类型：若方法无返回值，则使用 void
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7d3880ef6c2459f43f9e972717c99f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dae5a74a83ecafde80d78e169a1fb3c/" rel="bookmark">
			Cannot read property &#39;$el&#39; of undefined  at VueComponent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在.vue文件的template标签里面引用子组件，如下所示
&lt;scroll class="middle-r" ref="lyriclist" :data="currentLyric &amp;&amp; currentLyric.lines"&gt;&lt;/scroll&gt; 然后再&lt;script&gt;中的methods属性中的一个方法去获取到该对象：由于&lt;scroll&gt;是一个子组件，通过this.$refs.lyricList是不能操作子组件里面的DOM的，因此需要引用$el来获取DOM对象
this.$refs.lyricList.$el.style[transform] = `translate3d(${offsetWidth}px,0,0)`
然后再浏览器报错：报错文件player.vue，发生错误的行数是423行，错误大概意思是说$el属性未定义，而这个书写语句是在middleTouchMove()函数里面的。
分析：根据错误类型是说这个对象未定义，那大致猜测是this.$refs.lyricList没有获取到组件元素，可以结合template中的html中元素的ref属性的定义。结果发现在html中的ref='lyriclist'与js中的引用不一样即this.$refs.lyricList
player.vue?55e8:423 Uncaught TypeError: Cannot read property '$el' of undefined at VueComponent.middleTouchMove 解决方法：将template中的ref属性的值改成ref='lyricList'就ok了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ba99fecfba92969f8971c44460a9747/" rel="bookmark">
			jvm运行机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JVM启动流程 1.java虚拟机启动的命令是通过java +xxx(类名，这个类中要有main方法)或者javaw启动的。
2.执行命令后，系统第一步做的就是装载配置，会在当前路径中寻找jvm的config配置文件。
3.找到jvm的config配置文件之后会去定位jvm.dll这个文件。这个文件就是java虚拟机的主要实现。
4.当找到匹配当前版本的jvm.dll文件后，就会使用这个dll去初始化jvm虚拟机。获得相关的接口。之后找到main方法开始运行。
上面这个过程的描述虽然比较简单，但是jvm的启动流程基本都已经涵盖在里面了。
jvm的基本结构 类加载器子系统就是通常我们所说的ClassLoader类加载器，首先我们会通过ClassLoader加载到jvm的内存中去，本地方法区主要就是native的方法调用，这个我们不前不做关心， pc寄存器 1.每个线程拥有一个pc寄存器。 jvm会为每一个线程分配一个pc寄存器，这个pc寄存器总是会指向下一个指令的地址。这样程序在执行过程中pc寄存器总是会知道下一步会做什么。在执行本地方法的时候，pc寄存器的值总是未定义的。 方法区 方法区是用来保存类的原信息。用来描述类的信息，包括类型常量池，字段方法信息，方法字节码。在JDK6的时候字符串常量是放在方法区中，但是JDK7的时候就已经移到了堆中。所以从这方面来说方法区，堆中到底保存的是什么信息和jdk的版本有很大的关系。从一般意义上来说我们的方法区就是保存一些类的原信息。方法区通常和永久区（perm）关联在一起，保存一些相对稳定的数据， java堆 1.java堆应该是和程序开发中最为密切的一个内存区间，我们在程序开发中通过new出来的对象基本上都是保存在java堆中。 2.堆是全局共享的，所有线程都共享java堆，也就是你创建了一个对象之后，所有的线程都是能够访问的。 3.从GC的角度看，java堆的结构和GC的算法是有关系的。 java栈 1.java栈和堆相比是线程私有的，栈是由一系列帧组成的，所以java栈也叫作帧栈。帧中保存的内容是一个方法的局部变量，操作数栈，常量池指针。每一次方法调用都会创建一个新的帧，并压栈。 我们来看一段C++代码 在上面代码中method()这个方法中，我们new了一个对象，那这个new的对象就是在堆上分配的，但是在堆上分配有一个问题就是每次我们new一个对象之后都要手动把这个对象去删除，释放内存。如果我们多次在堆上分配了对象空间，但是却忘记了删除对象，就会出现内存泄露，就是我们分配空间却没有删除。内存泄露在实际开发中是非常难以解决的问题，因为内存泄露有可能发生在任何地方。 我们可以采用右面的方法，声明一个对象，我们像上面右面的方法中声明一个对象，那么他并没有实际的划分内存空间，而只是在java栈上产生了一个引用。而这个引用在我们使用后会自动释放，不会产生内存泄露的问题。 java栈上分配好处 栈上分配的一般都是比较小的对象，在没有逃逸(逃逸是指这个对象创建出来之后不仅仅只在当前线程中要使用，其他的线程也要调用的情况)的情况下，直接分配到栈上。GC可以自动回收，减轻GC的压力。大对象或者逃逸对象无法分配到栈上。 我们从上面的代码和主时中可以交互，一个程序要想执行是需要几个内存区域交互配合执行的。 从上面这个图中我们可以发现，每个线程读取和存储的都是线程的工作内存。而线程的工作内存再到主存中的存储是肯定会有一些时差的。也就是改变了一个变量的值之后，另一个调用这个变量的对象是不能马上知道的。如果说要让其他线程立即可见这个改动，就要使用volatile关键字修饰。一旦使用这个关键字之后，所有调用这个变量的线程就直接去主存当中拿取数据。 下面这个图就是线程和本地内存和主存之间的关系。 线程总是在自己的本地内存中拿取变量，而本地内存中存储的只是共享变量的一个副本，真正的共享变量是存储在主存中的。所以这个之间存在了一定的时延和误差。 可见性 可见性是指一个线程修改了变量之后，其他线程能够立即知道。 保证可见性的方法就是上图提到的三种方法。 有序性和指令重排 有序性：在一个线程当中，所有的指令，所有的操作都是有序的。但是在线程外观察，在多线程的情况下去观察前面一个线程的行为，我们会发现这个行为有可能就是无序的(这种无序有两种原因，一种就是指令重排，另一种就是主存同步的延时，也就是说在线程A中更改了一个变量的值，同步主存也成功了，但是在线程B中我们可能还没来得及去同步主存中的值，这个时候对于线程B来说线程A的操作可能就是无序的)。 指令重排的基本原则： 1.程序顺序原则，一个线程内保证语义的串行性。 2.volatile规则：volatile关键字变量的写是先发生于读的。 3.锁规则：解锁必然发生于随后的一个加锁之前。 4.传递性：A先于B，B先于C，那么A必然先于C。 5.线程的start方法先于它的每一个动作。 6.线程的所有操作先于线程的终结(Thread.join())。 7.线程的中断（interrupt()）先于线程被中断的代码。 8.对象的构造函数执行结束于funlize()方法。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebec9c9b0163eac346d2e74f4ce74a3b/" rel="bookmark">
			React-Native开发二 Android 已有项目集成React-Native
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前言 之前写过一篇RN的环境搭建教程和新建一个新的RN项目的文章 https://blog.csdn.net/qiyei2009/article/details/78820207 但是其实在实际开发中，在已有的android项目中集成RN情况更普遍，这篇文章就是一个怎么在已有Android项目中引入RN的例子
2 集成步骤 首先搭建好Android开发环境，并有一个新建的或者已经存在的Android项目 在未创建ReactNative项目大概是这个样子 接着创建ReactNative Module用于存放我们RN相关的内容，极大程度的与原生开发解耦
1 在应用中添加js代码 在项目根目录输入以下命令
npm init 在这中间要求输入包名，其他的默认即可 这一步完成之后，在项目的根目录下就会生成package.json这个文件 接下来还需要把启动脚本放进去：
"start": "node node_modules/react-native/local-cli/cli.js start" 注意下启动脚本的路径，如果集成的项目目录结构不一样的话会报找不到启动脚本之类的错误，到时根据具体目录结构修改就好了。
2 安装React 和React Native 根目录输入以下命令
npm install --save react react-native 大约一两分钟的样子（如果卡到这里了，看看安装时是不是忘了配置镜像），完成之后你的根目录下会多了一个node_modules的文件夹，里面存放了下载好的React 和React Native。
要是控制台输出了版本不一致的警告信息，例如：
npm WARN react-native@0.45.1 requires a peer of react@16.3.1 but none was installed. 则继续执行 npm i -S react@16.3.1 (这里版本跟警告信息一致)。 3 下载.flowconfig文件(非必须)
curl -o .flowconfig https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig 第三步curl命令，其实质是下载.flowconfig配置文件，这个文件用于约束js代码的写法。非必需，可 4 新建index.android.js 项目根目录下创建index.android.js文件，目录内容如下：
'use strict'; import React from 'react'; import { AppRegistry, StyleSheet, Text, View } from 'react-native'; class EssayJokeReactNativeDemo extends React.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebec9c9b0163eac346d2e74f4ce74a3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54cf41df06834f4868b0bbd104344605/" rel="bookmark">
			点餐系统的简单开发（一）[数据库模型设计和数据库的创建]（学习）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建项目，首先要进行需求分析，根据分析，然后进行开发的第一步，首先是数据库模型的设计，以及数据库的创建，整理和分析好每个表之间的关联。
直接写出这个项目的数据库创建语句以及表之间关联的语句，项目很简单，因此没有设计到很复杂的逻辑关系，表之间的关联也很简单。
-- 创建数据库
CREATE DATABASE hotel CHARACTER SET utf8;
USE hotel;
-- 1. 餐桌表
CREATE TABLE dinnerTable(
idINT PRIMARY KEY AUTO_INCREMENT, -- 餐桌主键
tableName VARCHAR(20), -- 餐桌名
tableStatus INT DEFAULT 0, -- 餐桌状态：0，空闲； 1，预定
orderDate DATETIME
);
-- 2. 菜类别表
CREATE TABLE foodType(
id INT PRIMARY KEY AUTO_INCREMENT, -- 类别主键
typeName VARCHAR(20) --类别名称
);
-- 3. 菜品种表
CREATE TABLE food(
idINT PRIMARY KEY AUTO_INCREMENT, -- 主键
foodName VARCHAR(20), -- 菜名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54cf41df06834f4868b0bbd104344605/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc42e3ed23e71904ffe2f207d462a187/" rel="bookmark">
			“万方论文”爬取、数据清洗、以及利用word2vec训练model
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chapter1 关于“万方论文”的论文爬取与数据清洗 tips1：爬取数据 【背景】此爬虫是爬取万方自己设定的主题相关文献的
“title”、“abstract”、“link”、”author“、”date“、”keywords“、”link“等信息
【准备内容】爬虫原链接为 https://github.com/EachenKuang/wanfangSpider 项目上修改版。
修改内容如下：将所爬取内容进行了处理。同时将原本应该存入txt文件中结果存在了一个wanfang.sqlite数据库中。可以直接下载SQLiteStudio打开此数据库并且导出sql文件转存入mysql等数据库，使用更加方便。
因此我也上传了github仓库，链接：https://github.com/snowlixue/wanFangSpider-dataPretreatment
【操作提示】
start_urls = [ 'http://s.wanfangdata.com.cn/Paper.aspx?q=的&amp;f=top&amp;p=1']修改其中“的”为你所要爬取的主题。 在pipelines.py文件中修改所要存储的属性信息。
tips2：转存入mysql 【导入mySQL】爬取完成之后，用SQLiteStudio导出sql/csv文件，之后转存入mysql数据库。我用的Navicat客户端。这里要注意的是需要在Navicat中建好含有这些字段的表，然后表后右击导入sql/csv文件。之后加入自增的id字段。（否则数据清洗一定会出错）
tips3：数据清洗 【删除null值和空格】1.数据导入后title会有很多空格，需要删除。2.由于abstract、title、keywrods很重要，这里采取直接删除其中任一为null的行。3.对id列删除重建，使其可以重新从1自增排序。
import mysql.connector #连接数据库 conn = mysql.connector.connect(user='root', password='root', database='test') cursor = conn.cursor() sql_select = "select * from cnkiinfotest" try: cursor.execute(sql_select) result = cursor.fetchall() for row in result: id = row[0] print(id) # 清除title、abstract、keywords任意为null的项 if row[1] == None or row[5] == None or row[6] == None: cursor.execute("delete from cnkiinfotest where id = %d"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc42e3ed23e71904ffe2f207d462a187/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86da03917c88a9aae12437de163212d8/" rel="bookmark">
			Invalid prop: type check failed for prop &#34;radius&#34;. Expected Number, got String.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在vue编写的项目中，在浏览器的console报错： Invalid prop: type check failed for prop "radius". Expected Number, got String. 如下图所示：
在子组件progress-circle.vue的template中的定义如下： &lt;svg :width="radius" :height="radius" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg&gt; 在子组件progress-circle.vue的script中的props实现那个定义如下：radius和percent都是从父组件传递过来的数据
props: { radius: { type: Number, default: 100 }, percent: { type: Number, default: 0 } } 父组件player.vue中引用progress-circle子组件
&lt;progress-circle radius="32" :percent="percent"&gt; 然后就包上面的错误了。
分析：由于radius是从父组件传递给子组件的数据，在父组件中定义的时候是直接定义一个变量而不是绑定一个变量，那么当传递给子组件 的时候这个变量的值是一个字符串。但是在子组件中radius的类型是number，因此该变量应该还是要绑定传给子组件的。
解决的方法：只需要在父组件player.vue中做改变，在父组件中的定义如下
&lt;progress-circle :radius="radius" :percent="percent"&gt; 在player.vue的data中定义一个变量radius,如下所示
data() { return { //防止快速点击造成的bug songReady: false, currentTime: 0, radius: 32 } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e982e13f12710faf35aab9b4b92c1d3b/" rel="bookmark">
			千万级消息设计-思考（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 第一次写，也不知道写成什么样，喜欢的给个赞，不喜欢的给我留言。—— 蚂蚁爬树不怕高，有心学习不怕老。 场景 消息对于用户和平台来说，就是平台和用户之间的桥梁。特别是将消息看的很重的平台。查询消息记录返回，响应时间问题？ 现在都流行消息个数展示,未读消息个数问题？某某平台改变，小公司都要忙活了，忙坏了产品，累死了开发...上面的两个看似简单的问题，在特定的场合，会给平台带来严重的结果，下面谈谈两种特殊的场合。 场合 1.用户到百万时，数据量到千万级后；2.已经满足第一个条件后，平台再来几个推广活动。用户同时上线，参加活动会给用户发消息的时候（平台对用户进行推送消息，进行促销时，参加活动，活动奖励等使用消息通知的。 引发的问题 数据量过大时，查询速度变慢，导致数据库吃不消； 并发量高的时候，又想要给用户实时的展示。数据库更吃不消。当数据库都假死状态了。平台的客户端都出现了网络错误,谈何做活动等 怎么办？ 引 1.后续还会对上面的问题进行剖析和解决
2.如果大家有好的建议请给我留言。写在这里是为了方便大家带来思考，带着思考一起学习进步...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30ab0d39b821aa4f3d3c6a17e53439f5/" rel="bookmark">
			特性(Feature)与功能(Function)的差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载自：http://www.englishvincent.com/?p=171
在嵌入式产品开发中，经常会听到feature 特性和function 功能两者的需要。对此不是很清楚，下面来简单小结一下：
Feature，特性，在词典中的解释是：A feature of something is an interestingor important part or characteristic of it。feature本意是指特点，指事务有鲜明特征方面的属性，对应到产品或解决方案所具有的特征。
Function，功能，在词典中的解释是：The function of something or someone is theuseful thing that they do or are intended to do。Function强调产品的目的和用途。
在很多产品，特别是消费数字产品，它的特点也正好是其所包含的多种功能。而传统产品中很容易区分feature和function。比如：自行车，它的功能很少有人再描述，而特点不外乎可折叠foldable, 耐用serviceable, 铝合金轮毂alloywheels之类。
那么，为什么在介绍产品时很少看到用function呢？这是因为日常产品的基本功能无人不知，只是特点有所不同。比如买手机，我当然知道是用来打电话的，我想知道的只是与众不同的features，这时一般的问题是"what’s the difference?"。但假设你在介绍一个全新开发的又没人认识的东西时，我想function是必须要先予说明的，这时的问题是"what’s this?"。
而对于新产品研发，针对细分客户研发有针对性的产品特性，以差异化的满足客户需求，才可在在市场中占有一席之地。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/719cda150c315f786ef745d700d3c7f7/" rel="bookmark">
			html常用文本标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.&lt;Strong&gt; &lt;/Strong&gt;表强调 表示强调标签里面的内容，以加粗的格式显现。
2.&lt;em&gt;&lt;/em&gt;表示语气强调以倾斜的方式显现
例如：敲掉澳大利亚草原上有食肉动物出没，非常危险
&lt;strong&gt;
非洲大草原上有肉食动物出没。非常危险
&lt;/strong&gt;&lt;br&gt;
今天天气&lt;em&gt;真好&lt;/em&gt;啊 3 . &lt;i&gt;表倾斜 没有任何语义
4.&lt; b&gt;加粗 没有任何语义
5.&lt;small&gt; &lt;/small&gt;小字显示。例如免责声明呀 。一些不想被客户看到的信息，就故意写小点
6.&lt;cite&gt;表示引用
7.&lt;sub&gt; 让字体变小 显示在下方
H&lt;sup&gt;2&lt;/sup&gt;o
8.&lt;sup&gt;让字体变小显示在上方。
9.&lt;ins&gt;表示插入的字符。表示方式 带下划线。
10.&lt;del&gt; 在字符上带一条删除线。 一般用于价格 的打折 把原价划掉 下面出来一个新价格
11.&lt;code&gt;表示此段是程序代码
12&lt;pre&gt; 预格式化。就是你敲在源码里是什么格式。在页面上就显示什么格式。一般跟code配合使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33ebdf4e4ea17495f0b9212050581ebe/" rel="bookmark">
			Redis 的 5 个常见应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Redis 是一个强大的内存型存储，具有丰富的数据结构，使其可以应用于很多方面，包括作为数据库、缓存、消息队列等等。
如果你的印象中Redis只是一个 key-value 存储，那就错过了Redis很多强大的功能，下面就是实际应用场景中5个最普遍的案例。
1. 全页面缓存 如果你使用的是服务器端内容渲染，你又不想为每个请求重新渲染每个页面，就可以使用 Redis 把常被请求的内容缓存起来，能够大大的降低页面请求的延迟，已经有很多框架用Redis来缓存页面，这就是页面静态化的一种方式。
2. 排行榜 Redis 基于内存，可以非常快速高效的处理增加和减少的操作，相比于使用 SQL 请求的处理方式，性能的提升是非常巨大的。
Redis 的有序集合可以轻松实现“从一个大型列表中取得排名最高的N个元素”，毫秒级，而且非常简单。
3. Session 存储 这可能是应用最广的点了，相比较于类似 memcache 的 session 存储，Redis 具有缓存数据持久化的能力，当缓存因出现问题而重启后，之前的缓存数据还在那儿，这个就比较实用，避免了因为session突然消失带来的用户体验问题。
4. 队列 例如 email 的发送队列、等待被其他应用消费的数据队列，Redis 可以轻松而自然的创建出一个高效的队列。
5. 发布/订阅 pub/sub 是 Redis 内置的一个非常强大的特性，例如可以创建一个实时的聊天系统、社交网络中的通知触发器等等。
在此我向大家推荐一个架构学习交流群。交流学习群号：478030634 里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化、分布式架构等这些成为架构师必备的知识体系。还能领取免费的学习资源，目前受益良多
小结 这5个小用例只是Redis的很表层的功能，希望能为你带来一点灵感。
注：关注作者微信公众号，了解更多分布式架构、微服务、netty、等知识点。公众号：《Java烂猪皮》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dea6e0e9147e39785fe1fc757d63d8b/" rel="bookmark">
			python-时间戳转换相差8小时问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题描述】 在将时间戳timestamp转化为固定时间格式的时候，会相差8小时
例子：
create_time_temp = get_col_name(my_dict,'create_time') #自写的取变量数值的函数，得到的是个时间戳 dateArray = dt.datetime.utcfromtimestamp(create_time_temp/1000) create_time = dateArray.strftime("%Y-%m-%d %H:%M:%S") 返回的create_time是想要的格式的，但是发现会少8小时
【原因分析】 可能是因为默认时区的问题，导致并不是北京时间。（我猜的。。。）
【解决办法】 在utc上直接加上8小时。
create_time_temp = get_col_name(my_dict,'create_time') #自写的取变量数值的函数，得到的是个时间戳 dateArray = dt.datetime.utcfromtimestamp(create_time_temp/1000+28800)#在这里修改的！ create_time = dateArray.strftime("%Y-%m-%d %H:%M:%S") 问题解决！
（仅供个人学习，不负责任~~哈哈哈~~~~）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ca72a34d5ac07d82ab3e808f169c85/" rel="bookmark">
			Mingw gcc生成windows dll、封装opencv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：在我本机电脑生成一个目录存放工程文件E:\Project\test。用notepad++写3个文件
Test.h
#ifndef __TEST__ #define __TEST__ #ifdef __cplusplus extern "C" { #endif __declspec(dllexport) void __stdcall Test(); #ifdef __cplusplus } #endif #endif Test.cpp
#include "Test.h" #include &lt;opencv.hpp&gt; __declspec(dllexport) void __stdcall Test() { IplImage* ipl = cvLoadImage("E:\\123.jpg"); if(ipl){ cvSaveImage("e:\\123.bmp", ipl); cvReleaseImage(&amp;ipl); } } makefile
opencv_Include1=./Opencv/include opencv_Include2=./Opencv/include/opencv opencv_Include3=./Opencv/include/opencv2 opencv_Lib=./Opencv/lib -lopencv_core2410 -lopencv_highgui2410 -lopencv_imgproc2410 Test.dll:Test.o g++ Test.o -L $(opencv_Lib) -shared -o Test.dll Test.o:Test.h Test.cpp g++ -c -w Test.cpp -o Test.o -I $(opencv_Include1) -I $(opencv_Include2) -I $(opencv_Include3) clean: rm edit Test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71ca72a34d5ac07d82ab3e808f169c85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8178c1b8dd8bbf9546c2bfd65173c67/" rel="bookmark">
			Vue.js is detected on this page. Open DevTools and look for the Vue panel.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要解决 这个问题，则是因为没有开启debug mode，所以要对vue开启debug mode
在main.js中书写下面形式：
import Vue from 'vue' Vue.config.devtools = true则可以在浏览器调试vue代码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8babe77ef9b4d78883a53462efa7080/" rel="bookmark">
			android4.4 遇到 libhwui.so libGLES_mali.so 的native crash
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I/DEBUG (26895): signal 11 (SIGSEGV), code 2 (SEGV_ACCERR), fault addr 8581b210
I/DEBUG (26895): r0 811cfc10 r1 400db200 r2 8581b210 r3 00000001
I/DEBUG (26895): r4 811cfc10 r5 bedca37c r6 0093df4c r7 785c58e0
I/DEBUG (26895): r8 bedca3d8 r9 6d5bca4c sl 4161d700 fp bedca3ec
I/DEBUG (26895): ip 00000001 sp bedca378 lr 40cfc089 pc 8581b210 cpsr 600f0010
I/DEBUG (26895): d0 0000000000000010 d1 0000000000000004
I/DEBUG (26895): d2 000000000000000c d3 0000000000000004
I/DEBUG (26895): d4 0000000000000008 d5 3f80000000000000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8babe77ef9b4d78883a53462efa7080/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fae89ab4370fff2485c990ea1a7fa64/" rel="bookmark">
			学习笔记☞ 正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、动机 1、处理文本成为计算机常见工作之一 2、对文本内容的搜索提取是一项比较复杂困难的工作 3、为了快速方便处理上述问题，正则表达式技术诞生，逐渐发展为一个被众多语言使用的独立技术 2、定义： 正则表达式即高级文本匹配模式，提供了搜索，替代等功能。 本质是由一系列特殊符号和字符组成的字串，这个字串即是正则表达式。 这个表达式描述了字符和字符的重复行为，可以匹配一类特征的字符串。 3、目标 1、熟练使用正则表达式符号 2、正确组合和理解一般的正则表达式 3、能够使用Python操作正则表达式 4、正则表达式特点 1、方便进行检索和修改 2、支持语言众多 3、灵活多样 4、使用场景： 1、MongoDB正则类型 2、django等框架作为URL匹配 3、爬虫 5、正则表达式的使用 1、Python re模块 作用： 处理正则表达式 6、re模块函数： 1、re.fandall(pattern,string) 功能： 使用正则表达式匹配字符串 参数： pattern : 正则表达式 string ： 需要匹配的目标字符串 返回值： 一个列表，匹配到的所有内容 7、元字符： 即正则表达式中有特殊定义的符号 1、普通字符 元字符： abc 匹配规则 匹配相应的普通字符，就代表abc字面值 示例 s='abdlabcladgfajdhg' re.findall('abc',s) ['abc'] 2、或 元字符： ab|cd 匹配规则 匹配|两边任意一个正则表达式符合的情况 示例 s='abdlabcladgfajdhg' re.findall('ab|cd',s) ['ab', 'ab'] 注： | 两侧不要有没用的空格 3、匹配一个单一字符 元字符： . 匹配规则 匹配处理换行外的任意字符 示例： re.findall('f.o','foo is mot fao') ['foo', 'fao'] 4、匹配开始位置 元字符： ^ 匹配规则： 匹配一个字符串的开始位置 示例： 一、 re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fae89ab4370fff2485c990ea1a7fa64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93ea720096ce648e70f5299ba8272ea0/" rel="bookmark">
			vue打包webapp项目出现图标在手机端显示错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在vue通过手脚架创建的项目打包后，里面用到的ElementUI图标和iView图标都显示成了一个×的样式，这个明显影响了美观。
本人的项目通过修改webpack.base.conf.js文件配置，解决了
文件下面的10000改成80000。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e6a5bee9112aef3221d498b5e26f5e6/" rel="bookmark">
			最长公共子上升序列（信息学奥赛一本通-T1306）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题目描述】 给定两个整数序列，写一个程序求它们的最长上升公共子序列。
当以下条件满足的时候，我们将长度N的序列S1,S2,...,SN 称为长度为M的序列A1,A2,...,AM的上升子序列：
存在1≤i1&lt;i2&lt;...&lt;iN≤M，使得对所有1≤j≤N，均有Sj=Aij，且对于所有的1≤j&lt;N，均有Sj&lt;Sj+1。
【输入】 每个序列用两行表示，第一行是长度M(1≤M≤500)，第二行是该序列的M个整数Ai(−231≤Ai&lt;231)
【输出】 在第一行，输出两个序列的最长上升公共子序列的长度L。在第二行，输出该子序列。如果有不止一个符合条件的子序列，则输出任何一个即可。
【输入样例】 5
1 4 2 5 -12
4
-12 1 2 4
【输出样例】 2
1 4
【源程序】 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;string&gt; #include&lt;cstdlib&gt; #include&lt;queue&gt; #include&lt;vector&gt; #define INF 0x3f3f3f3f #define PI acos(-1.0) #define N 501 #define MOD 100001 #define E 1e-12 using namespace std; struct Node{ int len; int ans[N]; }order[N],now; int a[N],b[N]; int main() { int n,m; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) cin&gt;&gt;a[i]; cin&gt;&gt;m; for(int i=1;i&lt;=m;++i) cin&gt;&gt;b[i]; for(int i=1;i&lt;=m;++i) { now.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e6a5bee9112aef3221d498b5e26f5e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0930c9889fdc92ae9b96e4b380e65557/" rel="bookmark">
			基于Android平台的个人时间管理系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.前言 另外一个毕设作品，功能不算完善，主体框架使用了《高效Android工程师6周养成计划》里面的项目内容，其中最核心功能就是仿照“我要当学霸”这个软件的形式实现的监督不让用户玩手机的功能，该功能很大程度参考了一个前辈的实现过程，表示感谢。
1.效果 2.相关技术 2.1 《高效Android工程师6周养成计划》微服私访项目 本来是去年暑假的免费直播课程，当时很忙没时间看，现在已经收费了，好在看到一位小伙伴有录播，最后学习了一下。确实值得推荐，里面实现的完整的企业Android应用的开发流程，确实是android开发进阶不得不学的好项目，对后续自己独立开发应用都有着很大的参考价值。下面给出相关链接
高效Android工程师6周养成计划 视频下载(好像不免费，录屏不易也是应该的)
Android客户端之“微服私访”App的系统学习（一个同学的笔记，值得参考）
2.2 仿照“我要当学霸”这个软件的形式实现的监督不让用户玩手机的功能 这个功能是最复杂的，这里参考了前辈的实现方式，后台监控然后关闭其他app的功能其实并不简单，因为这个功能利用不善就变成了流氓软件。下面给出相关链接
【Android】做一款类似我要当学霸里的学习监督的APP
这里是上述项目源码（前辈谦虚，加了微信才要到源码，感谢）
3.项目源码 这里直接给出项目源码，功能并不完善，仅供参考。
4.推荐简单易用第三方库 主要是,涉及到下载SDK，使用JNI的第三方库很麻烦，找到这几个进一步简化配置操作的方法，留个笔记
几行代码轻松实现百度定位和在地图显示指定坐标·（配置方便）
一分钟学会使用IJKPlayer（配置方便）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87f7d90e09b7fac7d78c51e0886d6200/" rel="bookmark">
			机器学习之集成学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、集成学习
集成学习（Ensemble learning）是使用一系列学习器进行学习，并使用某种规则把各个学习结果进行整合，从而获得比单个学习器显著优越的泛化性能。它不是一种单独的机器学习算法，而更像是一种优化策略。
集成学习的一般结构是，先产生一组个体学习器，再用某种结合策略将它们结合起来。
集成学习优势在于：
1）个体学习器之间存在一定的差异性，这会导致分类边界不同，也就是说可能存在错误。那么将多个个体学习器合并后，就可以得到更加合理的边界，减少整体的错误率，实现更好的效果；
2）对于数据集过大或过小的情况，可以分别进行划分和有放回的操作，产生不同的数据子集，然后使用数据子集训练不同的学习器，最终再合并成为一个强学习器；
3）如果数据的划分边界过于复杂，使用线性模型很难描述情况，那么可以训练多个模型，然后再进行模型的融合；
4）对于多个异构的特征集的时候，很难直接融合，那么可以考虑使用每个数据集构建一个分类模型，然后将多个模型融合。
个体学习器分类
同质：所有个体学习器都是一个种类的——基学习器
异质：所有个体学习器不全是一个种类的——组件学习器
基学习器有时也被称为弱学习器，指的是准确率略微好于随机猜测的学习器。
集成算法的两个主要问题：如何选择若干个体学习器，以及选择何种策略将这些个体学习器集成为一个强学习器。
集成算法的成功在于保证个体学习器的多样性（好而不同），且集成不稳定的算法也能够得到一个比较明显的性能提升。
常见的集成学习有：
用于减少方差的Bagging
用于减少偏差的Boosting
用于提升预测结果的Stacking
二、Bagging
Bagging自举汇聚法（Bootstrap Aggregating），思想是：为了使基学习器尽可能的具有较大的差异（好而不同），对训练样本进行采样以产生若干个不同的子集，对每一个子集训练一个基学习器，然后结合策略进行集成的方法。为了不让每个基学习器效果太差，这些子集不能完全不同，因此使用子集之间相互有交叠的采样方法，即bootstrap方法。
基本流程：给定包含m个样本的数据集，随机取出一个样本放入采样集中，再把它放回到原始数据集中，重复m次，得到含m个样本的采样集，可知原始数据集中有63.2%的样本出现在采样集中，有36.8%的样本不会出现在采样集中，这些不在采样集中的样本可以作为验证集对泛化性能进行包外估计（out-of-bag estimate）。进行同样的操作进行T次得到T个每个含m个样本的采样集，基于每个采样集训练一个基学习器，再将基学习器进行组合，一般使用多数投票或求均值的方式来统计最终的分类结果。
Bagging方法的基学习器可以是基本的算法模型，如：Linear、Ridge、Lasso、Logistic、Softmax、ID3、C4.5、CART、SVM、kNN等。
Bagging计算复杂度与基学习器复杂度同阶，效率高；Bagging可以不经修改地用于多分类和回归问题。
Bagging主要关注降低方差，因此在不剪枝决策树、神经网络等易受样本扰动的学习器上效果更加明显。
Bagging方法的训练过程
Bagging方法的预测过程
三、Boosting
Boosting是一族可将弱学习器提升为强学习器的算法，先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器分错的样本获得较大的权重，然后基于调整后的样本分布来训练下一个基学习器；如此反复进行，直至基学习器数量达到指定值，最终将这些学习器进行加权结合，正确率越高的基学习器的获得的权重越大。Boosting可以用于分类和回归问题。
提升技术的意义：如果一个问题存在弱预测模型（偏差较大），那么可以通过依据损失函数的梯度方式进行提升（Gradient Boosting），从而得到一个强预测模型（偏差减小）。
对样本分布进行调整主要有两种方法：
（1）重新赋权法（re-weighting）：在每一轮学习中，根据样本分布为每个训练样本重新赋予一个权重值。
（2）重采样法（re-sampling）：对于无法接受带权样本的基学习算法，在每一轮学习中，根据样本分布对训练集重新进行采样，再用重采样得到的样本集对基学习器进行训练。
Boosting算法在训练的每一轮都要检查当前生成的基学习器是否满足基本条件（例如在AdaBoost算法中橙线部分），一旦不满足该条件，则废弃当前基学习器，使用重采样法可以在重新采样后继续训练过程。
常见的Boosting模型有：AdaBoost、GBDT、XGBoost
Bagging和Boosting的区别
（1）样本选择：Bagging算法是有放回的随机采样；Boosting算法是每一轮训练集不变，只是训练集中的每个样例的权重发生变化，权重值根据上一轮的分类结果进行调整。
（2）样例权重：Bagging使用随机抽样，样例的权重相等；Boosting根据错误率不断的调整样例的权重值，错误率越大则权重越大。
（3）基学习器权重：Bagging所有基学习器的权重相等；Boosting对于误差小的基学习器赋予更大的权重。
（4）并行计算：Bagging可以并行生成各个基学习器；Boosting理论上只能顺序/串行生成，因为后一个模型需要前一个模型的结果。
（5）Bagging中每个基学习器都是强学习器，主要关注的问题是降低方差；Boosting中每个基学习器都是弱学习器，主要关注的问题是降低偏差。
四、学习法Stacking
当训练数据很多时，一种更为强大的结合策略是使用学习法，即通过训练一个模型用于组合其他模型的技术。Stacking是学习法的典型代表，方法是首先从原始数据集中训练出初级学习器（异质），将初级学习器的预测结果作为训练次级学习器的输入，再次训练得到最终结果，一般使用单层的Logistic回归作为组合模型。
在训练阶段，次级训练集是初级学习器产生的，若直接用初级学习器的训练集来产生次级训练集，则过拟合风险会比较大；因此通过交叉验证或留一法的方式，用训练初级学习器未使用的样本来产生次级学习器的训练样本。
算法流程：
（1）使用留出法划分原始数据集，一部分为训练集，一部分为测试集。
（2）对于训练集，进行k-fold交叉验证，上图中k=5，从而将训练集划分为5份，其中四份作为新的训练集，剩下一份作为新的测试集。
（3）选择k个合适的初级学习器，基于新的训练集训练模型，使用新的测试集产生预测值。
（4）将所有预测值合并称为一个新的数据集，作为次级学习器的训练数据（即New Feature数据集）。
（5）利用k次产生的模型，和老的测试集特征，产生一系列预测值，对这些预测值求平均，并将这些平均数据作为下一轮的测试集。
（6）下一轮的目标值Y保持不变，还为原始数据集的Y值。
五、结合策略
学习器结合可能会从三个方面带来好处：
（1）统计的原因
由于学习任务的假设空间往往很大，可能有多个假设在训练集上达到同等的性能，此时若是有单个学习器会导致泛化性能不佳，结合多个学习器会减小这一风险。
（2）计算的原因
单个学习算法往往会陷入局部最优解，多个学习器结合可降低陷入糟糕局部最优解的风险。
（3）表示的原因
某些任务的真实假设可能不在当前学习算法所考虑的假设空间中，此时若使用单个学习器拟合效果一定不佳，而通过结合多个学习器，由于相应的假设空间有所扩大，则有可能学得更好的近似。
1、平均法
用于hi为连续型数据。
（1）简单平均值法：
（2）加权平均值：，
2、投票法
用于hi为离散型数据，类别集合为{c1,c2,...cN}，hi在样本x上的预测输出表示为一个N维向量，hij(x)是hi在类别标记cj上的输出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87f7d90e09b7fac7d78c51e0886d6200/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ef4d31d2323b3a6c9d87af34508fa13/" rel="bookmark">
			时间片轮转法：平均周转时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间片轮转法（RR）
算法描述：用于分时系统中的进程调度。每次调度时，总是选择就绪队列的队首进程，让其在CPU上运行一个系统预先设置好的时间片。一个时间片内没有完成运行的进程，返回到绪队列末尾重新排队，等待下一次调度。
【例】进程A、B、C、D需要运行的时间分别为20ms、10 ms、15 ms、5 ms，均在0时刻到达。到达的先后次序为A、B、C、D。如果时间片分别为1 ms和5ms，计算各个进程的带权周转时间和平均带权周转时间。
分析 在掌握了时间片轮转法概念的基础上，我们可以用一个执行时间图来形象地表示作进程的执行情况，帮助我们理解此题。具体如下：
根据执行时间图就可以计算各个进程的带权周转时间和平均带权周转时间了。这里要注意的是，要记住带权周转时间和平均带权周转时间的算术公式：
带权周转时间W，即：
W = T/R
其中T为周转时间，R为实际运行时间。
平均带权周转时间为：
解：采用时间片轮转法进行调度，算法的性能指标如下：
到达时间
进
程
名
到达时间
运行时间
开始时间
完成时间
周转时间
带权
周转时间
时间片=1
A
0
20
0
50
50
2.5
B
0
10
1
34
34
3.4
C
0
15
2
45
45
3.0
D
0
5
3
20
20
4.0
平均周转时间=37.25 平均带权周转时间=3.225
时间片=5
A
0
20
0
50
50
2.5
B
0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ef4d31d2323b3a6c9d87af34508fa13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60de4f235c11891ea58d28809295c818/" rel="bookmark">
			【UE4源代码分析】-005 Editor的起点-Main函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、UE4-Editor的运行 1.1 UE4编辑器的位置 UE4.sln 编译完之后，在输出目录下会生成UE4Editor.exe,(图1所示)。 图1 UE4Editor.exe 双击 UE4Editor.exe 即可启动经过我们自己编译的UE4编辑器。 1.2 UE4编辑器启动过程 双击启动 UE4Editor.exe 之后，编辑器开始运行，首先会弹出程序启动画面，在该界面上显示编辑器启动过程以及进度。 图2 UE4Editor启动界面Splash Screen 启动界面上标明了当前启动的UE4引擎的版本-4.19.2，以及当前加载的进度。 图3 UE4Editor启动界面Splash Screen带加载进度 在完成了加载之后，程序进度已有工程选择界面，在该界面上，用户可以选择系统中已经存在的UE4项目进行编辑， 注意 ：这里列出的项目包括计算机上历史版本的UE4引擎所创建的项目。 图4 UE4Editor选择项目 用户可以通过单击 新建项目 选项卡，进入新建项目界面。 图5 UE4Editor新建项目 用户通过新建项目选项卡输入项目名称和存储位置之后，UE4会创建项目。可供创建的项目主要由两种类型——蓝图项目和C++项目。蓝图项目开发过程中，主要使用UE蓝图脚本进行开发，而C++项目主要使用C++语言在VS编辑器中进行开发。 这里，我选择创建C++空白项目。UE4编辑器完成项目文件的创建之后，自动使用VS2015打开了我刚才创建的C++空白项目(项目名称 p1 )。 项目文件目录结构如图所示。 图6 UE4Editor新建空白C++项目文件组织 从图6中可以看出，与UE4引擎源代码工程相比，p1项目多了一个Game项目，该项目为p1游戏的项目代码所在的位置。 至此，我们已经完成了用UE4编辑器创建UE4游戏的项目，可以在其中自由的编写项目代码，进行游戏开发了。 那么， UE4编辑器到底是怎么运行起来的呢？ 2、函数调用起点 UE4引擎是使用C++语言开发的，伟大的《C语言》、《C++》、《Windows程序设计》告诉我们，win32程序通常是从main函数或者WinMain函数开始执行的。( 排除全局变量构造等情况，只按常规套路出牌。 ) 那么UE4Editor.exe是不是也是从这里开始执行的呢？ 在Engine\Source\Runtime\Launch\Private\Windows\LaunchWindows.cpp中有WinMain函数。 int32 WINAPI WinMain( _In_ HINSTANCE hInInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ char*, _In_ int32 nCmdShow ) { // Setup common Windows settings SetupWindowsEnvironment(); int32 ErrorLevel	= 0; hInstance	= hInInstance; const TCHAR* CmdLine = ::GetCommandLineW(); #if !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60de4f235c11891ea58d28809295c818/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7b0ac96ea7c6828b0cffe93c85498ea/" rel="bookmark">
			linux忘记用户名和密码，如何重置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 步骤 1.开机在出现GRUB菜单时按上下键取消倒计时(我是一直按e键)，并定位到要进入的操作系统选择项，按e键进入编辑模式 2.定位到以kernel开头的一行，按e 3.进入到可编辑的一行文字状态下，加上空格和数字1，按回车后回到刚才的菜单界面 4.按下b键，重启系统 5.进入不用输入用户名密码的单用户模式 6.重置密码，输入命令passwd 用户名，开始键入新的密码，这以root用户为例: passwd root 7.输入reboot重启进入centos系统，输入用户名，然后输入你刚才新创建的密码，可以进入系统 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cedaddf3f4b9219404392babbb33715b/" rel="bookmark">
			vue项目 设置scrollTop不起作用 总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在开发中，遇到这样一个情景。一个页面中有三个模块，每个模块对应一个标题，每个模块内容都很长，所以需要点击当前模块对应的标题滚动到模块所在位置。
我想的方案是获取到每个模块距离文档顶部的距离，然后将值赋给对应要滚动的元素。 步骤如下:
首先给每个模块一个id，例如： &lt;div class="module module1" id="anchor-0"&gt; &lt;div class="module module1" id="anchor-1"&gt; &lt;div class="module module1" id="anchor-2"&gt; 复制代码 点击每个标题的时候获取到当前模块的id &lt;a v-for="(navItem,index) in navData" :key="index" class="navItem" :class="{active:index == i }" @click="goAnchor('#anchor-'+index)"&gt;{{navItem.name}}&lt;/a&gt; methods: { // tab点击滚动 goAnchor(val) { let anchor = this.$el.querySelector(val); }, 复制代码 *最后就可以获取每个模块距离文档顶部的距离了，然后赋值给对应要滚动的元素就可以了
methods: { // tab滚动 goAnchor(val) { let anchor = this.$el.querySelector(val); this.$nextTick(() =&gt; { document.querySelector(".el-main").scrollTop = anchor.offsetTop; }); }, 复制代码 切记：在这里一定要加上this.$nextTick()方法，否则document.querySelector(".el-main").scrollTop的值永远为0，不会赋值成功的！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d99ec2323702bd5f25c9baef11192b65/" rel="bookmark">
			从HTTPS协议的网址跳转到HTTP协议的网址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		右键点击Chrome的快捷方式，在其“属性”的“快捷方式”选项卡中，将“ --allow-running-insecure-content”加到“目标”文本框的最后面即可(注意前面有个空格)。重新打开Chrome，就不会再看到“不安全内容”的提示了，同时HTTPS协议下的网站也可访问HTTP协议的接口了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b10bbc3059472915ffcf3abd88246c71/" rel="bookmark">
			Selenium自动化测试入门（基于Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该系列文章系个人读书笔记及总结性内容，任何组织和个人不得转载进行商业活动！
本人小白 最近在尝试学习Python 开篇记录 只为交流 相互学习O(∩_∩)O~~
Selenium，化学元素硒的英文示意，对于软件测试来书，则是一个主要用于Web应用程序自动化测试的工具集合；
之前有这个计划来学习和使用自动化测试到项目中去，以满足公司需求，所以闲时就买了本书，内容较简洁，实践学习中；
前言： 旨在学习使用Python语言调用Selenium WebDriver接口进行自动化测试；
作为一名小白，我们先来看看所需的入门知识和信息；
1.Selenium WebDriver：业界通用的测试框架，不仅是web测试的标准，同时在移动测试领域也是底层的核心驱动框架；
2.Python作为动态语言，其优点多多，前一阶段用了一段时间简单熟悉了下Python语法，感兴趣的同学可移步查看；
Selenium包括一系列的工具组件： 1.Selenium IDE：是嵌入到FireFox浏览器的插件，用于在Firefox上录制和回放Selenium脚本；
虽然只能在Firefox下使用，但它能将录制好的脚本转换成各种Selenium WebDriver支持的程序语言，进而扩展到更广泛的浏览器类型；
2.Selenium WebDriver：可支持多种语言，用于操作浏览器的一套API；支持各类型浏览器，跨操作系统；
WebDriver为诸多语言提供完备的，用于实现web自动化测试的第三方库；
3.Selenium Standalone Server：包括Selenium Grid、远程控制、分布式部署等，均可实现Selenium脚本的高效执行与拓展；
利用Grid使得自动化测试可以并行运行，甚至在跨平台、异构的环境中运行，包括主流的移动端环境，如Android、iOS；
学习准备：Python语言及语法，Web前段知识（这个了解的很少/(ㄒoㄒ)/~~），至于一些前期准备和环境配置，我们稍后来实践；
一、基于Python的Selenium WebDriver入门 Selenium可以自动操纵浏览器来做很多，如模拟与浏览器的交互，而且支持到多数主流浏览器；
我们首先需要选择一门语言来编写自动化脚本，而这门语言需要有Selenium client library支持；我们选择Python；
1.1 安装Python和Selenium包 安装Python：安装不同平台的Python可以在http://python.org/download/ 安装Selenium：使用pip工具https://pip.pypa.io/en/latest/ 按照文档，需要先执行脚本get-pip.py 下载执行即可；
之后执行终端命令：pip3 install -U selenium 来安装Selenium WebDriver client library；-U参数会将已经安装的旧版更新至新版；可查阅官方文档；
1.2 PyCharm设置 PyCharm有两个版本：社区版和专业版，社区版是免费的，可以下载使用；
在使用PyCharm时，需要配置Python的解释器，我们选择支持selenium的Python版本解释器；
1.3 Selenium WebDriver基于Python的实例脚本 我们尝试创建一个引用Selenium WebDriver Client library的Python脚本，使用Selenium WebDriver提供的类和方法模拟用户与浏览器的交互；
我们尝试使用百度搜索来实践这个脚本：搜索“铜钱贯”，并打印搜索记录的内容：
Python脚本编辑如下：（searchproducts.py）
# -*- coding:utf-8 -*- from selenium import webdriver # create a new Firefox session driver = webdriver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b10bbc3059472915ffcf3abd88246c71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d182d20072c70b5119d511cd8a30c740/" rel="bookmark">
			Eclipse安装插件的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Eclipse插件的安装方法大体可以分为三种：直接复制、使用link文件，以及使用eclipse自带的图形界面的插件安装方法。
一、使用link文件（建议使用） eclipse的安装目录：E:\InstallationSoftware\eclipse 插件所在文件夹（假设是python插件，一般包含：features与plugins文件夹）：E:\InstallationSoftware\eclipse-plugs\PyDev
在eclipse的安装目录下新建links 文件夹，在links目录中建立一个以 link为扩展名的文本文件如PyDev.link，在PyDev.link 中加入插件所在文件夹路径，即：
path=E:\\InstallationSoftware\\eclipse-plugs\\PyDev 注意路径：link文件中path=插件目录的path路径分隔要用\或是/
然后打开命令行，到当前eclipse的目录下，输入：eclipse -clean，重新启动eclipse，这样eclipse就会加上新的插件了。
可以在eclipse：help &gt;&gt; About Eclipse &gt;&gt; Installation Detail 中看到（不同版本的eclipse可能不同），如图： 二、直接复制法 把插件所在文件夹（假设是python插件）中features与plugins文件夹中的内容分别复制到eclipse安装目录中的features与plugins文件夹中，然后按照前面的方法重启eclipse就好了。
三、使用eclipse自带的图形界面的插件安装方法 help &gt;&gt; Install New Software &gt;&gt; Add &gt;&gt; 输入Name与Locaton 步骤一： 步骤二： 步骤三： 然后一直next下去就好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e20d05386ddce43319e72bf76dd32586/" rel="bookmark">
			VS C&#43;&#43;程序打包成可安装文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建setup and deployment 工程 在既有项目解决方案内添加 setup and deployment工程如下图 添加项目需要的文件 1. 在Application Folder添加 Project Output 选择exe工程（主输出，包含所需dll等） 此时需要使用的dll会被自动打包进来，另外程序所需的 db文件数据库文件需要收到添加进来 Add-&gt;File 选择 db文件 如果工程不止一个，也需要把其它工程生成的dll一同 导入进来Add-&gt;File 2. 在Application Folder 添加-&gt;文件 选择 “c:”windows”system32”msiexec.exe”文件，用于卸载 工程 3. 在Users Desktop 添加-&gt;文件 选择一个适合在桌面显示的ico 4. 在Users Programs Menu 添加-&gt;文件 选择一个适合在菜单显示的图标.ico 或者3,4可以在 Application Folder下建iconFolder 存放ico，供3,4引用 完整显示如下 创建快捷方式 1、开始菜单快捷方式：在“PrimaryOutputfromxxx(Active)”上右击创建来自 主输出 的快捷方式“，并命名，并在其的属性栏中为其“Icon”选择刚才导入的图标。并将其拖动到“用户的”程序”菜单”文件下 2、桌面快捷方式：步骤同1。将其拖动到“用户桌面”下 3、卸载快捷方式：在msiexec.exe上右击“创建msiexec.exe 的快捷方式”，并命名为例“卸载dispenser”。将此快捷方式的Argumments属性设置为”/x {程序ID}”，ID值即为打包程序的ProductCode属性,如“/x {1AE1E45C-C68B-4033-BE53-218FDEEF52D0}”(不包括双引号)。获取ProductCode如下 将其拖动到“用户的”程序”菜单”文件下,当然也可放在桌面，可为其修改属性Icon 4、打包.net framework 选择SetuptestWindows项目的属性，在对话框中选择“系统必备”，然后在弹出的对话框中选择“从与我的应用程序相同的位置下载系统必备组件”，确定，有些如果编译不过去就选择第一个从网站上下载。 更改默认安装位置 Application Folder -&gt;属性 -&gt;DefaultLocation
参考2015打包安装程序 https://www.cnblogs.com/dongh/p/6868638.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75283871d7796fec1768d4a7ca79b444/" rel="bookmark">
			VS2015 创建及使用DLL，以及静态lib
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建DLL方法一 使用IDE创建Dll工程 1.1 在既有解决方案中创建Dll工程使用 File-&gt;添加 dll项目 1.2 需要新建解决方案时 使用File-&gt;新建 dll项目 是否需要导出符号，是否需要预编译头 可以自行决定 使用导出符合可以 导出一个完整的Dll实例 如下 其中DllProject.h DllProject.cpp 是示例的头文件及其实现 Dllmain.cpp 是dll的main函数入口 【DllMain函数】 Windows在加载DLL时，需要一个入口函数，就像控制台程序需要main函数一样。有的时候，DLL并没有提供DllMain函数，应用程序也能成功引用DLL，这是因为Windows在找不到DllMain的时候，系统会从其它运行库中引入一个不做任何操作的默认DllMain函数版本，并不意味着DLL可以抛弃DllMain函数。 根据编写规范，Windows必须查找并执行DLL里的DllMain函数作为加载DLL的依据，它使得DLL得以保留在内存里。这个函数并不属于导出函数，而是DLL的内部函数，这就说明不能在客户端直接调用DllMain函数，DllMain函数是自动被调用的。 DllMain函数在DLL被加载和卸载时被调用，在单个线程启动和终止时，DllMain函数也被调用。参数ul_reason_for_call指明了调用DllMain的原因，有以下四种情况： DLL_PROCESS_ATTACH:当一个DLL被首次载入进程地址空间时，系统会调用该DLL的DllMain函数，传递的ul_reason_for_call参数值为DLL_PROCESS_ATTACH。这种情况只有首次映射DLL时才发生； DLL_THREAD_ATTACH:该通知告诉所有的DLL执行线程的初始化。当进程创建一个新的线程时，系统会查看进程地址空间中所有的DLL文件映射，之后用DLL_THREAD_ATTACH来调用DLL中的DllMain函数。要注意的是，系统不会为进程的主线程使用值DLL_THREAD_ATTACH来调用DLL中的DllMain函数； DLL_PROCESS_DETACH:当DLL从进程的地址空间解除映射时，参数ul_reason_for_call参数值为DLL_PROCESS_DETACH。当DLL处理DLL_PROCESS_DETACH时，DLL应该处理与进程相关的清理操作。如果进程的终结是因为系统中有某个线程调用了TerminateProcess来终结的，那么系统就不会用DLL_PROCESS_DETACH来调用DLL中的DllMain函数来执行进程的清理工作。这样就会造成数据丢失； DLL_THREAD_DETACH:该通知告诉所有的DLL执行线程的清理工作。注意的是如果线程的终结是使用TerminateThread来完成的，那么系统将不会使用值DLL_THREAD_DETACH来执行线程的清理工作，这也就是说可能会造成数据丢失，所以不要使用TerminateThread来终结线程。以上所有讲解在工程DLLMainDemo（工程下载）都有体现。
stdafx.h stdafx.cpp是预编译头文件及实现文件 targetver.h可以设置所支持的windows 平台版本 `DllProject.h文件解析如下` // 下列 ifdef 块是创建使从 DLL 导出更简单的 // 宏的标准方法。此 DLL 中的所有文件都是用命令行上定义的 DLLPROJECT_EXPORTS // 符号编译的。在使用此 DLL 的 // 任何其他项目上不应定义此符号。这样，源文件中包含此文件的任何其他项目都会将 // DLLPROJECT_API 函数视为是从 DLL 导入的，而此 DLL 则将用此宏定义的 // 符号视为是被导出的。 #ifdef DLLPROJECT_EXPORTS //定义在 工程-&gt;属性-&gt;c/c++ 预处理器定义 为工程宏定义 #define DLLPROJECT_API __declspec(dllexport) //在dll项目中 为dllexport #else #define DLLPROJECT_API __declspec(dllimport) //在使用该dll的项目中为 dllimport #endif // 此类是从 DllProject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75283871d7796fec1768d4a7ca79b444/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daabb85055524511a1c8c6c0e5381e57/" rel="bookmark">
			spring boot 因mybatis版本引发的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用spring boot整合项目的时候，遇到了一个异常，如下：
2018-06-03 20:44:17.660 WARN 301924 --- [ main] o.s.b.f.s.DefaultListableBeanFactory : Bean creation exception on non-lazy FactoryBean type check: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'roleDao' defined in file [B:\workspace_spring\resume\baseservice\target\classes\com\ma\base\dao\RoleDao.class]: Unsatisfied dependency expressed through bean property 'sqlSessionFactory'; nested exception is Error creating bean with name 'sqlSessionFactory' defined in class path resource [org/mybatis/spring/boot/autoconfigure/MybatisAutoConfiguration.class]: org.springframework.beans.BeanInstantiationException: Factory method 'sqlSessionFactory' threw exception; nested exception is java.lang.NoSuchMethodError: org.mybatis.spring.SqlSessionFactoryBean.setVfs(Ljava/lang/Class;)V 根据异常信息，MybatisAutoConfiguration类中出现了方法调用异常，打开源码查看
@Bean @ConditionalOnMissingBean public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception { SqlSessionFactoryBean factory = new SqlSessionFactoryBean(); factory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daabb85055524511a1c8c6c0e5381e57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac7b09edbabc4a19868296397bba5518/" rel="bookmark">
			【离散数学二】集合的包含
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集合的包含 Time Limit: 1000 ms Memory Limit: 65536 KiB Submit Statistic Discuss Problem Description 已知含n个元素的集合的子集A和B，用位串表示法判断是否有A⊆B。
Input 多组测试数据，每组测试数据第1行输入正整数n(1 &lt;= n &lt;= 100)，表示集合元素个数，第2行输入位串表示法形式的集合A，第3行输入位串表示法形式的集合B。
Output 对于每组测试数据，若A⊆B则输出yes，反之则输出no。
Sample Input 10 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 10 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 1 1 1 1 Sample Output yes no Hint #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac7b09edbabc4a19868296397bba5518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0698d777128c92d2ded614bcad2c8371/" rel="bookmark">
			Star sky CodeForces - 835C （二维前缀和）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Star sky CodeForces - 835C The Cartesian coordinate system is set in the sky. There you can see n stars, the i-th has coordinates (xi, yi), a maximum brightness c, equal for all stars, and an initial brightness si (0 ≤ si ≤ c).
Over time the stars twinkle. At moment 0 the i-th star has brightness si. Let at moment t some star has brightness x. Then at moment (t + 1) this star will have brightness x + 1, if x + 1 ≤ c, and 0, otherwise.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0698d777128c92d2ded614bcad2c8371/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86265e114115dc3c76e4f2f992e3003/" rel="bookmark">
			ubuntu 系统磁盘清理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、引言 ubuntu系统使用一段时间之后，因长期未进行垃圾清理，会出现磁盘空间不够等情况，这会被迫就需要进行磁盘清理了。
二、清理方法 1)查看电脑磁盘空间的使用情况，使用baobab命令，看到的结果如下图，则可先挑一些进行清理 baobab 2)清理缓存及软件卸载遗留 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3bd1ae3008881fd10ac6372f33714b6/" rel="bookmark">
			MinFilter算法的快速实现c&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MinFilter算法的快速实现，提供一篇论文供有需要的朋友学习：http://files.cnblogs.com/Imageshop/O%281%29%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9C%80%E5%B0%8F%E5%80%BC%E7%AE%97%E6%B3%95.pdf
图像大小：width=500，height=376 块大小31 运行快了好多，仅仅用了7个毫秒。
数组实现（论文提到的）： void getMin(unsigned char* data,unsigned char* output,int size,int r) { int minIndex=0; int block=(r&lt;&lt;1)+1; int min=*data; for(int i=1;i&lt;block;i++) { if(min&gt;=*(data+i)) { min=*(data+i); minIndex=i; } } output[r]=data[minIndex]; for (int j=r+1;j&lt;size-r;j++) { if (minIndex&gt;=j-r) { int temp=(r&lt;&lt;1)+j-r; if(data[minIndex]&gt;=data[temp]) minIndex=temp; } else { minIndex=j-r; int min=data[j-r]; for (int i=j-r+1;i&lt;block+j-r;i++) { if(min&gt;=data[i]) { min=data[i]; minIndex=i; } } } output[j]=data[minIndex]; } } 对于矩阵的实现： void minFilter2(unsigned char* minData,unsigned char* outputData,int width,int height,int r) { int block=(r&lt;&lt;1)+1; unsigned char* tempData=(unsigned char*)calloc(height,sizeof(unsigned char)); unsigned char* tempData2=(unsigned char*)calloc(height,sizeof(unsigned char)); int minIndex=0; int min=0; //求行的最小值 for (int i=0;i&lt;height;i++) { unsigned char* data_ptr=minData+i*width; unsigned char* output_ptr=outputData+i*width; getMin(data_ptr,output_ptr,width,r); //在边缘复制minData值 for (int j=0;j&lt;r;j++) { output_ptr[j]=data_ptr[j]; output_ptr[width-j-1]=data_ptr[width-j-1]; } } //求列最小值 //for (int j=0;j&lt;width;j++) //{ // for (int i=0;i&lt;height;i++) // { // *(tempData+i)=*(outputData+i*width+j); // } // getMin(tempData,tempData2,height,r); // for (int i=r;i&lt;height-r;i++) // { // *(outputData+i*width+j)=*(tempData2+i); // } //} //free(tempData2); //求列最小值 for (int j=0;j&lt;width;j++) { min=outputData[j]; minIndex=0; for (int i=1;i&lt;block;i++) { unsigned char* output_ptr=outputData+i*width; if(min&gt;=output_ptr[j]) { min=output_ptr[j]; minIndex=i; } } *(tempData+r)=min; for (int i=r+1;i&lt;height-r;i++) { if(minIndex&gt;=i-r) { unsigned char* output_ptr2=outputData+(i+r)*width; if(min&gt;=output_ptr2[j]) { min=output_ptr2[j]; minIndex=i+r; } } else { unsigned char* output_ptr1=outputData+(i-r)*width; minIndex=i-r; min=output_ptr1[j]; for (int k=i-r+1;k&lt;block+i-r;k++) { unsigned char* output_ptr3=outputData+k*width; if(min&gt;=output_ptr3[j]) { min=output_ptr3[j]; minIndex=k; } } } *(tempData+i)=min; } for (int i=r;i&lt;height-r;i++) { *(outputData+i*width+j)=*(tempData+i); } } free(tempData); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b32447217d343d764676d5551040fad/" rel="bookmark">
			离散正弦变换(DST)实现（cpu和cuda）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matlab中有dst函数用来计算离散正弦变换，但是类似于DFT，它的变换矩阵并不是一个完全的正交矩阵，需要外加一个定标因子才能变换正交矩阵，有关Matlab中的dst正变换和dst逆变换函数对应的公式分别如下： 从以上两个公式可以看出它类似于我们常见的DFT，DFT反变换中有个1/N定标因子，正变换中没有（此处是反变换中有个2/(N+1)）。 CPU版本：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;memory.h&gt; #include "fftw3.h" //fft动态库 void dst(double* a,int n,int m,double* b) //dst { int yW = 2*(n+1); fftw_complex *iin = (fftw_complex*)fftw_malloc(sizeof(fftw_complex)*yW); fftw_complex *out = (fftw_complex*)fftw_malloc(sizeof(fftw_complex)*yW); fftw_plan p; //对每一行做FFT变换 for (int j=0;j&lt;m;j++) { iin[0][0] = 0; iin[0][1] = 0; iin[n+1][0] = 0; iin[n+1][1] = 0; for (int i=0;i&lt;n;i++) { iin[i+1][0] = a[j*n+i]; iin[n+2+i][0] = -a[j*n+(n-1-i)]; iin[i][1] = 0; } p = fftw_plan_dft_1d(yW,iin,out,FFTW_FORWARD, FFTW_ESTIMATE); fftw_execute(p); for (int i=0;i&lt;n;i++) { b[j*n+i] = -out[i+1][1]/2; } } fftw_destroy_plan(p); fftw_free(iin); fftw_free(out); } //使用实数做傅立叶，更省内存 void dst2(double* a,int n,int m,double* b) { int yW = 2*(n+1); double *iin = (double*)fftw_malloc(sizeof(double)*yW); fftw_complex *out = (fftw_complex*)fftw_malloc(sizeof(fftw_complex)*(n+2)); fftw_plan p; //对每一行做FFT变换 for (int j=0;j&lt;m;j++) { iin[0] = 0; iin[n+1] = 0; for (int i=0;i&lt;n;i++) { iin[i+1] = a[j*n+i]; //iin[n+2+i] = -a[j*n+(n-1-i)]; iin[yW-1-i] = -a[j*n+i]; } p = fftw_plan_dft_r2c_1d(yW,iin,out,FFTW_ESTIMATE); fftw_execute(p); for (int i=0;i&lt;n;i++) { b[j*n+i] = -out[i+1][1]/2; } } fftw_destroy_plan(p); fftw_free(iin); fftw_free(out); } void idst(double* a,int n,int m,double* b) { int yW = 2*(n+1); fftw_complex *iin = (fftw_complex*)fftw_malloc(sizeof(fftw_complex)*yW); fftw_complex *out = (fftw_complex*)fftw_malloc(sizeof(fftw_complex)*yW); fftw_plan p; //对每一行做FFT变换 for (int j=0;j&lt;m;j++) { iin[0][0] = 0; iin[0][1] = 0; iin[n+1][0] = 0; iin[n+1][1] = 0; for (int i=0;i&lt;n;i++) { iin[i+1][0] = a[j*n+i]; iin[n+2+i][0] = -a[j*n+(n-1-i)]; iin[i][1] = 0; } p = fftw_plan_dft_1d(yW,iin,out,FFTW_FORWARD, FFTW_ESTIMATE); fftw_execute(p); for (int i=0;i&lt;n;i++) { b[j*n+i] = -out[i+1][1]/(n+1); } } fftw_destroy_plan(p); fftw_free(iin); fftw_free(out); } void dstXY(double* a,int w,int h,double* b) { //对行每行做dst int ww = 2*(w+1); fftw_complex *hiin = (fftw_complex*)fftw_malloc(sizeof(fftw_complex)*ww); fftw_complex *hout = (fftw_complex*)fftw_malloc(sizeof(fftw_complex)*ww); fftw_plan p; for (int j=0;j&lt;h;j++) { hiin[0][0] = 0; hiin[0][1] = 0; hiin[w+1][0] = 0; hiin[w+1][1] = 0; for (int i=0;i&lt;w;i++) { hiin[i+1][0] = a[j*w+i]; hiin[w+2+i][0] = -a[j*w+(w-1-i)]; hiin[i+1][1] = 0; hiin[w+2+i][1] = 0; } p = fftw_plan_dft_1d(ww,hiin,hout,FFTW_FORWARD, FFTW_ESTIMATE); fftw_execute(p); for (int i=0;i&lt;w;i++) { b[j*w+i] = -hout[i+1][1]/2; } } fftw_free(hiin); fftw_free(hout); //对结果每列做dst int hh = 2*(h+1); fftw_complex *liin = (fftw_complex*)fftw_malloc(sizeof(fftw_complex)*hh); fftw_complex *lout = (fftw_complex*)fftw_malloc(sizeof(fftw_complex)*hh); for (int i=0;i&lt;w;i++) { liin[0][0] = 0; liin[0][1] = 0; liin[h+1][0] = 0; liin[h+1][1] = 0; for (int j=0;j&lt;h;j++) { liin[j+1][0] = b[j*w+i]; liin[h+2+j][0] = -b[(h-1-j)*w+i]; liin[j+1][1] = 0; } p = fftw_plan_dft_1d(hh,liin,lout,FFTW_FORWARD, FFTW_ESTIMATE); fftw_execute(p); for (int j=0;j&lt;h;j++) { b[j*w+i] = -lout[j+1][1]/2; } } fftw_free(liin); fftw_free(lout); fftw_destroy_plan(p); } void dstXY2(double* a,int w,int h,double* b) { //对行每行做dst int ww = 2*(w+1); double *hiin = (double*)fftw_malloc(sizeof(double)*ww); fftw_complex *hout = (fftw_complex*)fftw_malloc(sizeof(fftw_complex)*(w+2)); fftw_plan p; for (int j=0;j&lt;h;j++) { hiin[0] = 0; hiin[w+1] = 0; for (int i=0;i&lt;w;i++) { hiin[i+1] = a[j*w+i]; hiin[w+2+i] = -a[j*w+(w-1-i)]; } p = fftw_plan_dft_r2c_1d(ww,hiin,hout,FFTW_ESTIMATE); fftw_execute(p); for (int i=0;i&lt;w;i++) { b[j*w+i] = -hout[i+1][1]/2; } } fftw_free(hiin); fftw_free(hout); //对结果每列做dst int hh = 2*(h+1); double *liin = (double*)fftw_malloc(sizeof(double)*hh); fftw_complex *lout = (fftw_complex*)fftw_malloc(sizeof(fftw_complex)*(h+2)); for (int i=0;i&lt;w;i++) { liin[0] = 0; liin[h+1] = 0; for (int j=0;j&lt;h;j++) { liin[j+1] = b[j*w+i]; liin[h+2+j] = -b[(h-1-j)*w+i]; } p = fftw_plan_dft_r2c_1d(hh,liin,lout,FFTW_ESTIMATE); fftw_execute(p); for (int j=0;j&lt;h;j++) { b[j*w+i] = -lout[j+1][1]/2; } } fftw_free(liin); fftw_free(lout); fftw_destroy_plan(p); } void idstXY(double* a,int w,int h,double* b) { //对行每行做idst int ww = 2*(w+1); fftw_complex *hiin = (fftw_complex*)fftw_malloc(sizeof(fftw_complex)*ww); fftw_complex *hout = (fftw_complex*)fftw_malloc(sizeof(fftw_complex)*ww); fftw_plan p; for (int j=0;j&lt;h;j++) { hiin[0][0] = 0; hiin[0][1] = 0; hiin[w+1][0] = 0; hiin[w+1][1] = 0; for (int i=0;i&lt;w;i++) { hiin[i+1][0] = a[j*w+i]; hiin[w+2+i][0] = -a[j*w+(w-1-i)]; hiin[i+1][1] = 0; hiin[w+2+i][1] = 0; } p = fftw_plan_dft_1d(ww,hiin,hout,FFTW_FORWARD, FFTW_ESTIMATE); fftw_execute(p); for (int i=0;i&lt;w;i++) { b[j*w+i] = -hout[i+1][1]/(w+1); } } fftw_free(hiin); fftw_free(hout); //对结果每列做idst int hh = 2*(h+1); fftw_complex *liin = (fftw_complex*)fftw_malloc(sizeof(fftw_complex)*hh); fftw_complex *lout = (fftw_complex*)fftw_malloc(sizeof(fftw_complex)*hh); for (int i=0;i&lt;w;i++) { liin[0][0] = 0; liin[0][1] = 0; liin[h+1][0] = 0; liin[h+1][1] = 0; for (int j=0;j&lt;h;j++) { liin[j+1][0] = b[j*w+i]; liin[h+2+j][0] = -b[(h-1-j)*w+i]; liin[j+1][1] = 0; } p = fftw_plan_dft_1d(hh,liin,lout,FFTW_FORWARD, FFTW_ESTIMATE); fftw_execute(p); for (int j=0;j&lt;h;j++) { b[j*w+i] = -lout[j+1][1]/(h+1); } } fftw_free(liin); fftw_free(lout); fftw_destroy_plan(p); } void dstY(double* a,int w,int h,double* b) { fftw_plan p; int hh = 2*(h+1); fftw_complex *liin = (fftw_complex*)fftw_malloc(sizeof(fftw_complex)*hh); fftw_complex *lout = (fftw_complex*)fftw_malloc(sizeof(fftw_complex)*hh); for (int i=0;i&lt;w;i++) { liin[0][0] = 0; liin[0][1] = 0; liin[h+1][0] = 0; liin[h+1][1] = 0; for (int j=0;j&lt;h;j++) { liin[j+1][0] = a[j*w+i]; liin[h+2+j][0] = -a[(h-1-j)*w+i]; liin[j+1][1] = 0; liin[h+2+j][1] = 0; } p = fftw_plan_dft_1d(hh,liin,lout,FFTW_FORWARD, FFTW_ESTIMATE); fftw_execute(p); for (int j=0;j&lt;h;j++) { b[j*w+i] = -lout[j+1][1]/2; } } fftw_free(liin); fftw_free(lout); fftw_destroy_plan(p); } int main() { int w = 5; int h = 4; double* b = (double*)malloc(h*w*sizeof(double)); //A=[1,2,3,7;4,5,6,1;7,8,9,2;1,2,3,4;3,4,5,9]; double a[20] = {1,4,7,1,3, 2,5,8,2,4, 3,6,9,3,5, 7,1,2,4,9}; //dst(a,w,h,b); //相当于matlab的 ：DSTA = dst(A); //dstXY(a,w,h,b); //相当于matlab的 ：DSTA = dst(A); DSTAA = dst(DSTA')'; //dstY(a,w,h,b); //相当于matlab的 ：DSTAA = dst(DSTA')'; //idst(a,w,h,b); //相当于matlab的 ：DSTB = dst(A')'; //idstXY(a,w,h,b); // === 相当于matlab的 ：IDSTA = idst(A); IDSTAA = idst(IDSTA')'; //dstXY2(a,w,h,b); dst2(a,w,h,b); for (int j=0;j&lt;h;j++) { for (int i=0;i&lt;w;i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b32447217d343d764676d5551040fad/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/509/">«</a>
	<span class="pagination__item pagination__item--current">510/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/511/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>