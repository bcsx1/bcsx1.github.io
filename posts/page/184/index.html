<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6af04acc698dc3e12cafb4a875d5923b/" rel="bookmark">
			UOS桌面版配置远程访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UOS桌面版配置远程访问 一、SSH &amp; SFTP二、VNC三、x11vnc.service 一、SSH &amp; SFTP # 安装SSH sudo apt update sudo apt install ssh # 开启SFTP vi /etc/ssh/sshd_config # Subsystem sftp /usr/libexec/openssh/sftp-server 下面添加 Subsystem sftp internal-sftp # 重启 systemctl restart sshd.service 二、VNC # 安装VNC sudo apt install -y x11vnc x11vnc # 设置VNC密码 sudo x11vnc -storepasswd /etc/x11vnc.pass # 启动服务 （如无则创建） sudo vim /usr/lib/systemd/system/x11vnc.service # 填入本文 《三、x11vnc.service》的内容 # 赋权 sudo chmod 755 /lib/systemd/system/x11vnc.service sudo chown root:root /lib/systemd/system/x11vnc.service sudo systemctl daemon-reload sudo systemctl enable x11vnc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6af04acc698dc3e12cafb4a875d5923b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e89dab301f53ff70164c9b86b68023b/" rel="bookmark">
			C&#43;&#43;中求水仙花数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，我们所要做的第一步为先理解什么是水仙花数；所谓水仙花数，是指一个三位正整数，其各位数字的立方和等于该整数本身。
如：1*1*1+5*5*5+3*3*3=153。
问题： 编程求出所有的水仙花数。
这里可以用两种循环语句（do while语句/for循环语句）可以进行计算；但大体的思维逻辑是先表达出个位，十位，百位数。然后让他满足1*1*1+5*5*5+3*3*3=153这个条件。
下面先用do while循环语句进行写作（这里需要注意的是调用了一个数学的函数库，即数据库中的pow幂函数）：
代码如下 #include &lt;iostream&gt; using namespace std; #include &lt;math.h&gt; //调用数学运算函数库 int main() { int num = 100; //num%10 个位数；num/10%10 十位数；num/100 百位数； do { if (pow(num%10,3) + pow(num / 10 % 10,3) + pow(num / 100,3) == num) //pow（主体，幂的次方） //对应个位数的三次方+十位数的三次方+百位数的三次方 { cout &lt;&lt; num &lt;&lt; endl; //输出水仙花数 } num++; //进行num=num+1 } while (num &lt; 1000); //判断语句，判断是三位数 } 输出结果如下图
当用for循环语句写的时候，逻辑与do while的是一个逻辑的；
代码如下：
#include &lt;iostream&gt; using namespace std; #include &lt;math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e89dab301f53ff70164c9b86b68023b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30dbfffccc33c86f2b6360f312cb11e2/" rel="bookmark">
			K8S node亲和与反亲和：nodeSelector应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		节点标签的作用： k8s作为一个集群，每个pod都是随机调度到节点运行的，而不同的服务对资源的需求不同，比如mysql，elasticesarch等服务的pod对磁盘I/O要求比较高，这样的服务我们可以把它们手动调度到有ssd磁盘的服务器上运维更为合理，而不是调度到hdd磁盘节点上；
微服务对网络的要求比较高，可以把这些服务调度到网络带宽比较高的服务器运行
而K8S默认的随机调度方式显然不适用，因此基于此情况，我们可以通过人工干预，把node添加不同的标签，基于这些标签区分调度
1、查看node节点默认的标签： k8s集群创建好后，每个节点会有一个默认的标签，其中有个labels项目有个参数hostname是每个主机的标签名称，它的角色是node节点
2、node标签使用背景： 可根据业务情况，把不同项目的业务pod分配到指定的一批服务器上运行，只要在那一批服务器打上指定的标签，并且在业务资源的yaml文件中指定这个标签即可
3、打标签（基于key=value格式） 把节点打上标签，该节点只用于project(项目)是myserver的，以后有myserver项目的pod调度的话有限调度到这个节点运行 root@master1:~# kubectl label node 172.31.7.111 project="myserver" 再查看node标签发生变化了，多了刚刚打上的标签名，pod的标签是给service筛选用的，而node的标签是给pod进行筛选用的
4、验证： 创建资源设置node标签，查验是否只会调度到对应的node节点
1、编写yaml文件 root@master1:/tmp# cat nodeSelector.yaml kind: Deployment #apiVersion: extensions/v1beta1 apiVersion: apps/v1 metadata: labels: app: myserver-tomcat-app2-deployment-label name: myserver-tomcat-app2-deployment namespace: myserver spec: replicas: 1 selector: matchLabels: app: myserver-tomcat-app2-selector template: metadata: labels: app: myserver-tomcat-app2-selector spec: containers: - name: myserver-tomcat-app2-container image: tomcat:7.0.94-alpine imagePullPolicy: IfNotPresent #imagePullPolicy: Always ports: - containerPort: 8080 protocol: TCP name: http env: - name: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30dbfffccc33c86f2b6360f312cb11e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0382f26341d714d62142bac0b9567710/" rel="bookmark">
			Android 开发之Gradle基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio工程的项目结构 Android Studio作为专业的安卓开发工具，它在构建安卓项目的时候具有很大的优势，首先了解安卓的项目结构对开发非常重要，直接上图：
其实，一个完整的Android Studio工程我们可以分为5个部分，图中选出的是日常经常开发关注的部分，他们分别是：
app模块：他是Android项目的核心模块，项目的核心功能与主要业务在该模块下开发，build文件夹存放编译生成的文件，build.gradle是该模块的构建脚本图中第2部分：整个项目的构建脚本（build.gradle）、项目的基础配置信息（settings.gradle）、执行脚本与一些配置文件，重点关注build.gradle图中第3部分：Gradle的版本以及缓存路径的配置信息图中第4部分：项目的子Module，结构与app类似 Gradle简介 Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，也增加了基于Kotlin语言的kotlin-based DSL，抛弃了基于XML的各种繁琐配置。
Gradle可以使用groovy或者Kotlin语言进行脚本开发，目前主要使用Groovy语言，Groovy语法此处不过多叙述，关注闭包以及他的动态特性即可。
安装教程以及其它内容可自行科学上网~~
Gradle的task ——任务 task是gardle中最小的任务单元，任务之间可以进行复杂的操作（如动态创建任务，多任务间依赖调用等等)。gradle的执行其实就是由各种任务组合执行，来对项目进行构建的。
使用gradlew help命令，任何gradle项目都有一个该task，可以执行此命令观察taks执行的流程是否如预期。
可以使用工具查看，还可以通过 gradlew tasks 命令查看可运行任务。
使用gradlew tasks --all 命令查看所有任务。
使用gradlew A B 命令表示执行任务A和B，支持驼峰简写。
我们创建一个简单的Andoid项目在app下的build.gradle中来试着写一个简单的任务
我们可以点击绿色三角执行该任务，也可以使用命令行执行，命令行执行如下：任选其一，即可在控制台看到输出的结果
D:\TestCode\GeadleLearning&gt;gradlew pH D:\TestCode\GeadleLearning&gt;gradlew printHello 关于task的其它特性
task A { doLast { println "doLast A ..." } } task C { doLast { println "doLast C ..." } } task B { doLast { println "doLast B ..." } } // hello 任务依赖于A、B、C三个任务，按照Gradle任务列表中的顺序进行执行 task hello(dependsOn: [A, C, B]) { //任务执行的时候首先执行该闭包 doFirst { println "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0382f26341d714d62142bac0b9567710/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6eab8b6279ea1934055ff17543d790d/" rel="bookmark">
			Android MPAndroidChart  --折线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要使用的三方为：MPAndroidChart 1.使用方法：引入依赖或者导入module repositories {
maven { url "https://jitpack.io" }
}
implementation 'com.github.PhilJay:MPAndroidChart:v3.1.0'
2.在布局中定义 &lt;com.github.mikephil.charting.charts.LineChart
android:id="@+id/lineChart"
android:layout_width="match_parent"
android:layout_height="400dp"
/&gt;
3.折线图主要由六部分组成 标题(Description)
标记(marker)
图例(Legend)
X轴(XAxis)
Y轴(YAxis)
数据源(LineData)
4.最基础的使用方式 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); setContentView(R.layout.activity_linechart); lineChart = findViewById(R.id.lineChart); // 背景颜色 lineChart.setBackgroundColor(Color.WHITE); // 禁用描述文本 lineChart.getDescription().setEnabled(true); // 启用触摸手势 lineChart.setTouchEnabled(true); // 设置监听器 lineChart.setOnChartValueSelectedListener(this); lineChart.setDrawGridBackground(false); // 启用拖动 lineChart.setDragEnabled(true); // 启用缩放 lineChart.setScaleEnabled(true); // lineChart.setScaleXEnabled(true); // lineChart.setScaleYEnabled(true); // 沿两个轴缩放 lineChart.setPinchZoom(true); // 动画 lineChart.animateXY(2000,2000); setData(); setMarker(); } //加载数据 public void setData(){ float datas[] = {14f,15f,16f,17f,16f,16f}; //在MPAndroidChart一般都是通过List&lt;Entry&gt;对象来装数据的 List&lt;Entry&gt; entries = new ArrayList&lt;Entry&gt;(); //循环取出数据 for(int i = 0; i &lt; datas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6eab8b6279ea1934055ff17543d790d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb3deb44bc55e154bb75227e580b7355/" rel="bookmark">
			【设计模式】八、面向对象设计原则之合成复用原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章|源码 https://github.com/tyronczt/design-mode-learn
定义-是什么 合成复用原则（Composite/Aggregate Reuse Principle，CARP）是指尽量使用对象组合/聚合而不是继承关系达到软件复用的目的。
它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则 与 里氏替换原则 相辅相成的，两者都是开闭原则的具体实现规范。
聚合 has-A：整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享组合 contains-A ：体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束继承 is-A ：一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能 思考-为什么 合成/聚合复用 优点 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能
它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用；对象间的耦合度低。可以在类的成员位置声明抽象；复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象； 缺点 通过这种方式复用建造的系统会有较多的对象需要管理； 继承复用 优点 新的实现较为容易，因为基类的大部分功能可以通过继承关系自动进入派生类；修改或扩展继承而来的实现较为容易。 缺点 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用；子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护；它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化； 应用-怎么用 案例：汽车分类管理程序 仓库代码地址：https://github.com/tyronczt/design-mode-learn/tree/main/design-mode-learn-5-01
汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。
public class CarMaker { public static void main(String[] args) { RedGasolineCar c1 = new RedGasolineCar(); c1.move(); } } class GasolineCar { public void move() { System.out.println("gasoline move"); } } class ElectricCar { public void move() { System.out.println("electric move"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb3deb44bc55e154bb75227e580b7355/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52ef706d51d831c4564432a87609ae82/" rel="bookmark">
			探究pyqt的QThread是否摆脱了GIL实现真正的多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提出疑问 产生这个疑问是因为，使用QThread创建的线程在Python的主线程里看不到子线程调用堆栈，而且用viztracer也看不到。
1.QThread的viztracer图表
2. 使用threading.Thread的viztracer图表
设计实验 import threading import time from PyQt5 import QtCore class Task(QtCore.QThread): def __init__(self, idx): super(__class__, self).__init__() self.idx = idx def run(self): for i in range(20000): print(f"{self.idx}:{i}") def fun(idx): for i in range(20000): print(f"{idx}:{i}") if __name__ == "__main__": # threading.Thread t1 = threading.Thread(target=fun, args=(1,), daemon=True) t1.start() t2 = threading.Thread(target=fun, args=(2,), daemon=True) t2.start() t3 = threading.Thread(target=fun, args=(3,), daemon=True) t3.start() t4 = threading.Thread(target=fun, args=(4,), daemon=True) t4.start() t5 = threading.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52ef706d51d831c4564432a87609ae82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62fe1acd409a8f5e37d43d1c9f56281d/" rel="bookmark">
			在C&#43;&#43;中将引用转换为指针表示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C++中将引用转换为指针表示 有没有办法在c ++中"转换"对指针的引用？在下面的例子,func2已经定义了原型和我不能改变它,但func是我的API,我想为pass两个参数,或一(组和第二组,以NULL)或既不(均设置为NULL):
void func2(some1 *p1, some2 *p2);
func(some1&amp; obj, some2&amp; obj2)
{
func2(…);
}
Che*_*hen 31
func2(&amp;obj, &amp;obj2);
使用正常变量等参考参数.
Jon*_*ood 10
只需获取对象的地址即可.
some1 *p = &amp;obj;
或者在你的情况下:
func2(&amp;obj, &amp;obj2);
Jar*_*d42 6
在正常情况下，您可以简单地使用&amp;：
void func(some1&amp; obj, some2&amp; obj2)
{
func2(&amp;obj, &amp;obj2);
}
但operator&amp;可能会重载，因此std::addressof（自 C++11 起）应用于这些情况：
void func(some1&amp; obj, some2&amp; obj2)
{
func2(std::addressof(obj), std::addressof(obj2));
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c3139f62d0ac278e85be9341770846b/" rel="bookmark">
			uniapp：下载文件，并保存到手机文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一
uni.downloadFile({ url: url,//文件的下载路径 success(res) { //保存到本地 uni.saveFile({ tempFilePath: res.tempFilePath,//文件的临时路径 success: function(res) { const savedFilePath = res.savedFilePath; // 打开文件 uni.openDocument({ filePath: savedFilePath, success: function(res) { uni.hideLoading() }, fail: function(res) {}, complete: function(res) { setTimeout(uni.hideLoading(), 4000) }, }); }, fail: function(err) {	} }); }, fail(res) {} }) ##注意：虽然能保存到本地，但是保存的位置非常奇怪 例如：（安卓端）"内部存储\Android\data\io.dcloud.HBuilder\apps\HBuilder\doc\uniapp_save" 位置不方便用户查找，并且文件名在保存到本地的过程中，还被篡改了 所以建议采用方法二 方法二
uni.showLoading({ title: '正在下载' }); // 本地路径开头使用file://，跟上手机文件本地目录storage/emulated/0， // 这时用户文件管理器能看到的了，之后创建 连信 作为文件夹， // 后缀是用于文件命名和格式修改，大家可以使用变量。 var url = this.downFileSrc; let dtask = plus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c3139f62d0ac278e85be9341770846b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/961006b53abf23f2208ebe1fe263201d/" rel="bookmark">
			Vue使用el-select下拉框实现可输入可选择，失去焦点时不清空绑定参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div&gt; &lt;!-- 例子1、嵌套循环的方式 --&gt; &lt;div v-for="item in list" :key="item.id"&gt; &lt;el-select clearable filterable allow-create v-model="name" @input="Update" default-first-option @blur.capture.native="Nameblur(item.id, $event)" &gt; &lt;el-option :value="item.id" :label="item.label" v-for="item in options" :key="item.id" &gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/div&gt; &lt;!-- 例子2、也可单独设置filterable属性必须加 --&gt; &lt;el-select filterable allow-create ref="nameSel" v-model="name" value-key="name" @blur="nameBlur" default-first-option &gt; &lt;el-option v-for="item in list" :key="item" :label="item" :value="item" /&gt; &lt;/el-select&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { name: "", list: [ { id: 0, title: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/961006b53abf23f2208ebe1fe263201d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/147f3fbf4d17f1f642684acab4eb2e6f/" rel="bookmark">
			微软打字时，间距突然变大？解决方法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打字时不知道按到什么字距变大，网上的shift+空格不管用？看这个看这个😊
是像这样吧:
原因：不小心切换了输入法半全角
方法：
①找到右下角工具栏输入法这里，中英文这儿
②鼠标放在上面，点右键进行全半角切换，
③右键,看到了嘛
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afc8dc8554fabe23a1ee06f36d1bca2b/" rel="bookmark">
			二路归并排序及时间复杂度分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言 二路归并排序是一种效率极高的递归排序，将数组A化为有序数组时间复杂度为O(nlogn)。
思想 二路归并排序分为拆分数组以及合并两个操作。
切分（自上而下）时间复杂度2*T(n/2) 每次从数组A中间切分，将数组分为[low，mid]以及[mid+1，high]两段，直至不可再分(low不小于high)即最终分成最下层一个一个的数组。当然在代码中不会让他真的变成一个一个数组！用下标圈定范围即可。
合并（自下而上）时间复杂度T(n) 将两段各自有序的数组合并成一个有序数组，并逐步向上合并，最终得到一个有序数组。
下面举例分析如何进行合并操作，需要三个指针，我设为i，j，k
比较下面两个数组指针（i，j）所指位置的数值将较小的放入上面的有序数组里，例如第一次比较17&lt;28，故将17放入上面有序数组中的第一个位置。此时i++，k++即i，k向后移动一位直至下面两个数组其中之一遍历完成，该例子为【17，24】遍历完成，而【28，40】并未遍历完成最终将未遍历完的数组剩下部分复制到上面的那个有序数组里
辅助数组B的作用 在合并操作中，先将此次需要合并的A数组全部放入B中，即i，j所指向的数组B，没错，他俩实际上在代码中就是一个数组只不过人为的在中间分开了，分为[low，mid]，[mid+1，high]两段而已。
再经历上述合并步骤，将这两段数组合并到A数组的原位置中[low，high]中。
即i，j指向的是B数组的元素，而k指向的是A数组的元素
代码 #include&lt;iostream&gt; using namespace std; #define n 16 //辅助数组---&gt;空间复杂度O(n) int* B = (int*)malloc((n + 1) * sizeof(int)); //合并 void merge(int A[], int low, int mid, int high) { //将A复制到B for (int k = low; k &lt;= high; k++) { B[k] = A[k]; } int i, j, k; //循环结束条件需要满足左右数组其中之一遍历结束 for (i = low, j = mid + 1, k = i; i &lt;= mid &amp;&amp; j &lt;= high; k++) { if (B[i] &lt;= B[j]) A[k] = B[i++]; else A[k] = B[j++]; } //若左数组未遍历结束 while (i &lt;= mid)A[k++] = B[i++]; //若右半数组未遍历结束 while (j &lt;= high)A[k++] = B[j++]; } //二路归并排序 void mergeSort(int A[], int low, int high) { if (low &lt; high) { int mid = (low + high) / 2; //左半数组---&gt;T(n/2) mergeSort(A, low, mid); //右半数组---&gt;T(n/2) mergeSort(A, mid + 1, high); //合并---&gt;T(n) merge(A, low,mid, high); } } int main() { int A[16] = {24,17,40,28,13,14,22,32,40,21,48,4,47,8,37,18}; mergeSort(A, 0, 15); for(int i =0;i&lt;n;i++) cout &lt;&lt; A[i]&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afc8dc8554fabe23a1ee06f36d1bca2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b7befec4e87f6928f476970bc050ef1/" rel="bookmark">
			Python保存图像的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录读取和保存图像的几种方式
1、读取图片 1.1、使用cv2读取图片，注意：opencv打开路径中不能有中文！！！
img = cv2.imread(img_path+'/'+name) 1.2、使用rasterio读取遥感影像
img = rasterio.open(img_path+'/images/'+name).read() 1.3、使用Image读取图像
image = Image.open(os.path.join(img_path, name)) 2、保存图片 2.1、使用cv2保存图片
cv2.imwrite(os.path.join(save_dir,name.replace('tif','png')),img) 2.2、使用numpy保存
img = rasterio.open(img_path+'/images/'+name).read() img.save(save_path+'/'+filename +'.tif') 2.3、使用plt保存
image = Image.open(os.path.join(img_path, name)) plt.imshow(image) plt.show() plt.savefig('001.png') 参考：
https://blog.csdn.net/xzm961226xzm/article/details/120951317
https://blog.csdn.net/weixin_50727642/article/details/119743762
https://www.cnblogs.com/cgmcoding/p/14244735.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf45b1a63b9af6086e88189e39c6ac55/" rel="bookmark">
			C&#43;&#43;：拷贝构造函数之指针悬挂（深拷贝与浅拷贝）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指针悬挂问题 指针悬挂问题就是深拷贝与浅拷贝的问题。浅拷贝时，同一类的不同对象的指针成员共享一份内存空间这容易导致指针悬挂问题，此时应该使用深拷贝（显式编写拷贝构造函数来避免浅拷贝）。
合成构造函数只能做最简单的参数值映射（浅拷贝）
用以下代码作例子分析指针悬挂（浅拷贝）问题：
#include &lt;iostream&gt; #include &lt;string.h&gt; using namespace std; class Student { private: char* name; int* id; int age; public: Student(char* Name, int* Id , int Age){ name = new char[strlen(Name) + 1]; strcpy(name, Name); id = new int[5]; for(int i = 0; i &lt; 5; ++i) id[i] = Id[i]; age = Age; }; ~Student(){ delete name; delete id; } char* get_name(){return name;} int* get_id(){return id;} int get_age(){return age;} }; int main(){ // stu1初始化 char* name_X = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf45b1a63b9af6086e88189e39c6ac55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/283ca109233b52a008eead28d3f047c0/" rel="bookmark">
			谈谈SpringBoot（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Spring Boot缓存 1.1 JSR-107 Spring从3.1开始定义了org.springframework.cache.Cache
和org.springframework.cache.CacheManager接口来统一不同的缓存技术；
并支持使用JCache（JSR-107）注解简化我们开发。
Cache接口为缓存的组件规范定义，包含缓存的各种操作集合；Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache， ConcurrentMapCache等；每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取；使用Spring缓存抽象时我们需要关注以下两点：
1、确定方法需要被缓存以及他们的缓存策略
2、从缓存中读取之前缓存存储的数据 1.2 Springboot缓存抽象的缓存注解 Cache缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等CacheManager缓存管理器，管理各种缓存（Cache）组件@Cacheable主要针对方法配置，能够根据方法的请求参数对其结果进行缓存@CacheEvict清空缓存@CachePut保证方法被调用，又希望结果被缓存@EnableCaching开启基于注解的缓存keyGenerator缓存数据时key生成策略serialize缓存数据时value序列化策略 @Cacheable/@CachePut/@CacheEvict 主要的参数
value缓存的名称，在spring 配置文件中定义，必须指定至少一个例如：@Cacheable(value=”mycache”) 或者@Cacheable(value={”cache1”,”cache2”}key缓存的key，可以为空，如果指定要按照SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合例如：@Cacheable(value=”testcache”,key=”#userName”)condition缓存的条件，可以为空，使用SpEL 编写，返回true 或者false，只有为true 才进行缓存/清除缓存例如：@Cacheable(value=”testcache”,condition=”#userName.length()&gt;2”)allEntries
(@CacheEvict )是否清空所有缓存内容，缺省为false，如果指定为true，则方法调用后将立即清空所有缓存例如：@CachEvict(value=”testcache”,allEntries=true)beforeInvocation
(@CacheEvict)是否在方法执行前就清空，缺省为false，如果指定为true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存例如：
@CachEvict(value=”testcache”，beforeInvocation=true) 1.3 Springboot缓存注解的使用 1.3.1 创建工程 参照：谈谈SpringBoot（一）9. SpringBoot与数据访问
/resources/application.properties
#开启驼峰命名 #mybatis.configuration.map-underscore-to-camel-case=true #将日志级别设置为debug logging.level.com.zmj.springboot.mapper=debug #打开自动配置报告 debug=true pom.xml依赖 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.12.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.zmj&lt;/groupId&gt; &lt;artifactId&gt;springboot-cache&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-cache&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/283ca109233b52a008eead28d3f047c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad18b09e7291129c73084d4c9eaebb2b/" rel="bookmark">
			网线直连NUC调试并使用VSCode实现X11转发（Jetson，树莓派适用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 场景描述 此种场景下，NUC与PC机通过一根网线进行连接，网线负责PC与NUC进行通信（SSH连接）。同时可以将NUC的图形界面转发到PC（远程桌面或X11窗口转发均可）。方便战队成员在没有显示器的场景下对NUC进行调试。配置示例如下图所示：
其中NUC作为被控端，可以为其他任何设备，如NVidia Jetson，树莓派等。
本方法仅适用于被控设备可以正常开机，网卡正常驱动情况。
2. 硬件准备 示例操作系统：
PC机： Windows 10 21H2 LTSC
NUC： Ubuntu 18.04 LTS
实验室使用的NUC
用网线将笔记本的网口和NUC的网口连接起来，如果笔记本没有网口的话需要购买一个USB有线网卡。
USB有线网卡
连接好之后，将NUC连上电源，笔记本连上WiFi。
3. 网络准备 打开控制面板如图，我们需要使用的是名为“WLAN”和“以太网n”的设备。（“以太网n”为我的USB有线网卡，若使用笔记本自带网口则使用“以太网”设备即可。）
右键WLAN，选择属性，选择共享，勾选“允许其他网络用户通过此计算机的Internet连接来连接”，家庭网络连接的选项选择你用来连接NUC的网络设备，在我的电脑上为“以太网3”。
点击确定退出，右键“以太网n”，选择属性，双击“Internet协议版本4（TCP/IPv4）”
进行如图配置。
确定退出。
打开cmd命令行，输入arp -a得到如图反馈
其中，接口192.168.137.1下的设备即为PC给NUC分配的IP地址。第一次分配的IP可能为192.168.137.189，接下来依然以图中的IP 192.168.137.11举例。
测试一下网络是否互通，执行ping 192.168.137.11，出现如图即为网络通信成功。
如果你得cmd中有ssh工具的话，可以直接在这里测试一下ssh是否可用。执行 ssh 用户名@ip，如 ssh hll@192.168.137.11
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Mn58oEgW-1675913339734)(null)]
出现如图即为成功。
4. VSCode配置Remote-SSH VSCode下载地址Visual Studio Code - Code Editing. Redefined
要装的插件如图
安装之后，侧边栏出现如图图标
点击图标，点击加号，新建远程连接。
在nuc上ping外网卡住的时候可以通过将windows上wlan的网络共享关闭再打开解决。
输入 ssh 用户名@ip，如 ssh hll@192.168.137.11，回车保存
继续回车
侧边栏出现如图设备，点击文件夹图标进行连接
选择Linux回车，点击侧边栏文件图标
点击打开文件夹
点击确定
选择Linux回车
出现如图，Remote-SSH配置完毕
5. NUC配置静态IP 网线的插拔会导致PC每次分配给NUC的IP发生变化，这里我们需要给NUC分配静态IP。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad18b09e7291129c73084d4c9eaebb2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b61e55dda76432451cf48dada6f1c66b/" rel="bookmark">
			【设计模式】七、面向对象设计原则之接口隔离原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章|源码 https://github.com/tyronczt/design-mode-learn
定义-是什么 接口隔离原则(Interface Segregation Principle, ISP)的含义：
Clients should not be forced to depend upon interfaces that they don’t use.
客户端不应该依赖它不用的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。 =&gt; 低耦合 如果客户依赖了不需要的接口，就要面临不需要的接口变动带来的风险提倡客户不应被迫使用对其无用的方法或功能 The dependency of one class to another one should depend on the smallest possible interface.
类间的依赖关系应建立在最小的接口上。 =&gt; 高内聚 把没有关系的接口合并在一起，会形成一个臃肿的大接口，这是对职责分配和接口的污染最小接口：满足项目需求的相似功能把庞大臃肿的接口拆分成更小和更具体的接口 接口隔离：多个专门的接口 &gt; 单一的总接口
思考-为什么 接口隔离原则符合我们常说的高内聚、低耦合的设计思想，可以使类具有很好的可读性、可扩展性和可维护性。我们在设计接口的时候，要多花时间去思考，要考虑业务模型，包括对以后有可能发生变更的地方还要做一些预判。所以，对于抽象、对于业务模型的理解是非常重要的。
接口隔离原则和单一职责原则 从功能上来看，接口隔离原则和单一职责原则都是为了提高类的内聚, 降低类之间的耦合, 体现了封装的思想。但二者还是有区别的。
（1）从原则约束来看: 接口隔离原则更关注的是接口依赖程度的隔离；而单一职责原则更加注重的是接口职责的划分。
（2）从接口的细化程度来看: 单一职责原则对接口的划分更加精细，而接口隔离原则注重的是相同功能的接口的隔离。接口隔离里面的最小接口有时可以是多个单一职责的公共接口。
（3）单一职责原则更加偏向对业务的约束；接口隔离原则更加偏向设计架构的约束。这个应该好理解，职责是根据业务功能来划分的，所以单一原则更加偏向业务；而接口隔离更多是为了“高内聚”，偏向架构的设计。
接口隔离原则的优点 接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。
将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。如果接口的粒度大小定义合理，能够保证系统的稳定性；然而，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。使用多个专门的接口能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。 接口隔离原则的实现方法 在具体应用接口隔离原则时，应该根据以下几个规则来衡量。
接口要尽量小 不能出现Fat Interface；但是要有限度，首先不能违反单一职责原则（不能一个接口对应半个职责）。接口要高内聚 在接口中尽量少公布public方法。 接口是对外的承诺，承诺越少对系统的开发越有利。定制服务 只提供访问者需要的方法。例如，为管理员提供IComplexSearcher接口，为公网提供ISimpleSearcher接口。接口的设计是有限度的 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同, 需要深入了解业务逻辑。 接口隔离原则的建议 一个接口只服务于一个子模块或业务逻辑；通过业务逻辑压缩接口中的public方法；已被污染了的接口，尽量去修改；若变更的风险较大，则采用适配器模式转化处理；拒绝盲从； 应用-怎么用 案例：动物行为 // 动物行为 public interface IAnimalAction { void eat(); // 吃 void fly(); // 飞 void swim(); // 游泳 } // 狗 public class Dog implements IAnimalAction { @Override public void eat() { } @Override public void fly() { // 狗不会飞 } @Override public void swim() { } } 对于狗来说，其他两种行为都ok，但是不会飞。假如再增加一种鸟类动物大雁，大雁不会游泳。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b61e55dda76432451cf48dada6f1c66b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99f963b2135803895257762fbba29327/" rel="bookmark">
			JSON Schema定义 &#43;Networknt validator格式校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 JSON Schema是基于JSON的格式的规范，用于定义JSON数据的结构。
官网：https://ajv.js.org/json-schema.html
在线验证：https://www.jsonschemavalidator.net/
在json-schema官网上可以看到，java版本的validator库推荐了以下几种方案：
Snow 2019-09, draft-07, -06 Uses Maven for the project and Gson under the hood. (GNU Affero General Public License v3.0)
everit-org/json-schema draft-07, -06, -04 (Apache License 2.0)
Justify draft-07, -06, -04 (Apache License 2.0)
networknt/json-schema-validator draft-07, -06, -04 Support OpenAPI 3.0 with Jackson parser (Apache License 2.0)
常用的json-schema-validator库有：everit-org/json-schema和networknt/json-schema-validator ，在everit-org/json-schema的github介绍中可知，如果项目代码中使用jackson进行的json解析，推荐使用后者进行校验；如果使用的是org.json API 进行json解析，推荐使用前者校验。
everit：GitHub - everit-org/json-schema: JSON Schema validator for java, based on the org.json API
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99f963b2135803895257762fbba29327/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aced1fe3ef52fe41071b492846c365d/" rel="bookmark">
			关于git上传多个项目报错问题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是因为git文件的冲突，在创建文件夹的子目录下删除一个就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a38d49b857280e243bad7ba69ee80bbd/" rel="bookmark">
			SHELL 变量和引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SHELL 变量和引用 一、变量的定义及命名二、变量的类型1.根据数据类型分类2. 根据作用域分类 三、变量的定义1. 变量名=变量值2. 位置参数和预定义变量 四、变量的运算1. 运算符2. 运算操作符与运算命令3. 表达式 五、练习练习1练习2练习3 一、变量的定义及命名 变量就是程序设计语言中的一个可以变化的量，当然，可以变化的是变量的值。几乎所有的程序设计语言中都有定义变量，并且其涵义也大同小异。从本质上讲，变量就是在程序中保存用户数据的一块内存空间（即是临时的），而变量名就是这块内存空间的地址。也可以作为一个表达式或一个命令。在程序的执行过程中，保存数据的内存空间的内容可能会不断地发生变化，但是，代表内存地址的变量名却保持不变。（即变量是值可能会一直变，但变量名却保持不变）命名：在Shell中，变量名可以由字母、数字或者下划线组成，并且只能以字母或者下划线开头。 二、变量的类型 1.根据数据类型分类 Shell是一种动态类型语言和弱类型语言
echo $test_var # 输出变量值echo “$test_var” # 如果要作为一个整体，尽量用双引号echo ‘$test_var’ # 输出 $test_varecho $(pwd) # 获取该命令的执行结果 2. 根据作用域分类 环境变量 使用declare -x 或 export 导出才可以叫环境变量
也叫全局变量
所有环境变量的名字都采用大写，且要导出
分为自定义环境变量
一般是指用export内置命令导出的变量，用于定义shell的运行环境，保证shell命令的正确执行。环境变量可以在命令行中设置和创建，但用户退出命令行时这些变量值就会丢失，即该环境变量只在当前 shell和子shell中有效。如果希望永久保存环境变量，可以在配置文件中设置。如果在命令行定义一个变量 data ，和 export data2导出 ，在脚本里输出它们，再利用bash执行脚本，那么只有data2可以被导出值。如果想永久保存环境变量
1） 用户的环境变量配置
在~/.bash_profile 或 ~/.bashrc 里定义
2） 全局环境变量的配置
在 /etc/bashrc、/etc/profile 文件或者 /etc/profile.d 目录中定义定义环境变量的三种方式：
设置过后需要重新用户连接，才会去访问该配置文件，才会生效。或者用 sourc 或 . 执行重新执行脚本，不会产生子进程。 和bash内置的环境变量
shell内置的环境变量是所有的shell程序都可以使用的变量。包括有 PATH、HOME、COLUMNS、HISTFILE、HISTSIZE等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a38d49b857280e243bad7ba69ee80bbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2154a25d7a1be996dd6cb9c7cd178a2d/" rel="bookmark">
			数据可视化（Echarts、antv）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A、Echarts a、安装：npm i echarts@4.9.0
b、在main.js中配置：
import * as echarts from 'echarts'
Vue.prototype.echarts = echarts
c、在vue组件的虚拟DOM中定义echarts的挂载点
d、对echarts的各个配置项进行配置（以柱状图bar为例）
title：图表的标题
tooltip：鼠标悬浮在图表上时显示的提示信息
xAxis：x轴的文本
yAxis：y轴的文本
series：是一个数组，包含多个对象，一个对象就是图表中一组柱子
type：表示的图表的类型（bar表示柱状态图、line表示折线图、pie表示饼图......）
data：是一个数组，有多少个单元就显示多少个柱子
B、vue-echarts模块的使用
a、安装：npm i vue-echarts
b、导入：
import 'echarts' import VueECharts from "vue-echarts"; import "echarts/lib/chart/bar"; c、在vue组件中注册vue-echarts
import Echarts from 'vue-echarts' export default { name: 'App', components: { 'v-chart':VueECharts } } d、在vue组件的data函数中定义vue-echarts配置项
data(){ return { bar: { color: ["#ffdd38", "#0fc7ab"], // 柱状图颜色设置 title: { text: "Vue-ECharts 入门示例", left: 'center' //标题居中 }, tooltip: {}, animation: false, //不显示动画效果 legend: { //图例设置 //show: false, //是否显示图例 icon: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2154a25d7a1be996dd6cb9c7cd178a2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/820b5192db736ea88e8ab767ecda69ef/" rel="bookmark">
			【设计模式】六、面向对象设计原则之依赖倒置原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章|源码 https://github.com/tyronczt/design-mode-learn
定义-是什么 依赖倒置原则（Dependency inversion principle，简称 DIP），其含义：
高层模块不应该依赖低层模块，两者都应该依赖其抽象抽象不应该依赖细节, 细节应该依赖于抽象要针对接口编程，不要针对实现编程 传统的自顶向下设计 传统设计方式采用自顶向下的原则，逐级依赖，中层模块和高层模块的耦合度很高，如果需要修改其中的一个模块，则可能会导致其它很多模块也需要修改，牵一发动全身，不易于维护。 不使用依赖反转的系统构架，控制流和依赖关系流的依赖箭头是一个方向的，由高层指向底层，也就是高层依赖底层。
依赖倒置原则 举个通俗一点的例子：
唐朝的皇帝要了解一下今年的科举情况，他肯定不会直接去找礼部尚书问情况，而是让当班的公公去传唤；礼部尚书也会通过管家或者身边人去找侍郎或郎中了解科举情况。
例子中的公公、管家就是接口/抽象层的角色，按照传统思维应该是皇帝自顶向下直接问各个侍郎或郎中去问科举情况，依赖倒置，侍郎、郎中去尚书那儿汇报情况再去皇帝那儿汇报。
思考-为什么 核心思想：面向接口编程
优点 减少类之间的耦合性提高系统稳定性提高代码可读性和维护性可降低修改程序所造成的风险 应用-怎么用 如果说实现开闭原则的关键事抽象化，是面向对象设计的目标的话，依赖倒置原则就是这个面向对象设计的主要机制。
依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则:
每个类尽量提供接口或抽象类，或者两者都具备。变量的声明类型尽量是接口或者是抽象类。任何类都不应该从具体类派生。使用继承时尽量遵循里氏替换原则。 案例：用户抽奖 需求：有部分投注用户，设计随机、权重方式进行抽奖
代码仓库：https://github.com/tyronczt/design-mode-learn/tree/main/design-mode-learn-4-01
public class BetUser { // 用户姓名 private String userName; // 用户权重 private int userWeight; public BetUser() { } public BetUser(String userName, int userWeight) { this.userName = userName; this.userWeight = userWeight; } public String getUserName() { return userName; } public void setUserName(String userName) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/820b5192db736ea88e8ab767ecda69ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/593adc2e3733d378b6df883a09b41ca2/" rel="bookmark">
			CPU过高问题定位（Thread Dump）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实战:CPU过高问题定位 方式1：top + jstack step1：找到问题进程，拿到 PID 在物理机上执行
# 查看 CPU 占用率最高的进程，拿到进程ID 36032 $ top 物理机部署解决方案 直接继续 step 2
docker部署解决方案：根据 PID 找到 container https://stackoverflow.com/questions/24406743/coreos-get-docker-container-name-by-pid
# docker ps -q | xargs docker inspect --format '{{.State.Pid}}, {{.ID}}' | grep "^${PID}," $ docker ps -q | xargs docker inspect --format '{{.State.Pid}}, {{.ID}}' | grep "^36032," 后面的步骤进入容器操作！（docker exec -it xxx /bin/bash）需要在容器中再次 top 一下，然后继续 step2。
kubernetes部署解决方案 登录出问题的物理机，方法同 docker。
step2：根据 PID 找到问题线程 PPID # 查看进程 CPU 占用率最高的线程，拿到线程ID 36044 # Alpine 貌似命令还不一样，是这个 top -H $ top -Hp 36032 # 将PPID 转换为16进制 $ printf %x 36044 8ccc step3： thread dump 并分析 # 进程进行 thread dump（-F是可选的用来强制dump，JDK8有，JDK11无） # 如果是 docker 需要根据 PID 找到 container，看下面 $ jstack -F 36032 &gt; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/593adc2e3733d378b6df883a09b41ca2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c3e064f7cac2c3069ddc8baf1428928/" rel="bookmark">
			vue中的methods，computed，watch区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		computed是计算属性；watch是监听，监听data中的数据变化；methods是方法(函数) 2、computed支持缓存，当其依赖的属性的值发生变化时，计算属性会重新计算，反之，则使用缓存中的属性值；watch不支持缓存，当对应属性发生变化的时候，响应执行；methods 在重新渲染的时候，函数总会重新调用执行。所以说虽然methods和computed的到效果是一样的，但是因为computed 提供缓存，所以当要处理海量数据时，要使用computed来提高性能。 3、computed不支持异步，有异步操作时无法监听数据变化；watch支持异步操作。 4、computed第一次加载时就监听；watch默认第一次加载时不监听。 computed中的函数必须调用return；watch不是。 computed:{ getMessage(){ //调用return return this.Message.split('').reverse().join('') } } &lt;template&gt; &lt;el-card class="box-card"&gt;&lt;el-input v-model="name" style="width: 30%;"&gt;&lt;/el-input&gt;&lt;/el-card&gt; &lt;/template&gt; data() { return { name: '123' }; }, watch: { name(newVal, oldVal) {//参数一为新修改的值，参数二为修改后的值 console.log('newVal', newVal); console.log('oldVal', oldVal); },y //当设置immediate属性为true时，无论值是否发生改变，时刻都会监听； //当设置immediate属性为false时，常规用法，只有值发生改变才会监听。 immediate: true } 6、computed是响应式的，methods并非响应式。 7、调用方式不一样，computed定义的成员像属性一样访问，视图层{{msg}}:this.属性名，methods定义的成员必须以函数形式调用:方法名()，视图层{{msg()}}。 7、使用场景： computed：一个属性受到多个属性影响，如：购物车商品价格结算。
watch：一个数据影响多条数据，如：搜索数据。数据变化响应，执行异步操作，或高性能消耗的操作，watch为最佳选择。
所以：
computed和methods他们能同时实现一个功能时 ，选择前者，因为compute有缓存；
computed和watch他们能同时实现一个功能时,选择前者，因为更加简洁；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9083e1dd6167f3acaf0a6ba56515852/" rel="bookmark">
			Qt&#43;OpenCV显示图片（Mat转QImage然后显示在QLabel上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、概述 此篇主要是记录一下如何将OpenCV集成得到Qt Creator中，并将OpenCV的Mat对象转换为QImage并使用qt的api显示图片
a.使用Qt Creator开发工具集成OpenCV,在.pro文件中配置环境即可，如下图所示
b.将Mat对象转为QImage对象并使用Qt显示出来的步骤如下：
1.将使用OpenCV imread函数加载一张图片
2.将Mat转为QImage
3.将QImage转为QPixmap
4.将QPixmap放到QLabel上并显示出来
2、示例 /** * 调用openCV显示一张图片，让图片的尺寸和窗口尺寸保持一致 * @brief MainWindow::MainWindow * @param parent */ MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-&gt;setupUi(this); Mat src = imread("C:\\Users\\wei.yang\\Downloads\\girl.jpg"); //imshow("girl",src); QImage dst = QImage(src.data,src.cols,src.rows,src.step,QImage::Format_BGR888); this-&gt;setFixedSize(QSize(dst.width(),dst.height()));//设置窗口为固定尺寸 QLabel *label = new QLabel();//创建一个label label-&gt;setParent(this);//将其父类指向当前窗口，在关闭窗口的时候此label会跟着销毁 label-&gt;setFixedSize(QSize(dst.width(),dst.height()));//设置label为固定尺寸 label-&gt;setScaledContents(true);// //label-&gt;resize() label-&gt;setPixmap(QPixmap::fromImage(dst));//在label显示图片 } 3、显示效果 本文福利，莬费领取Qt开发学习资料包、技术视频，内容包括（C++语言基础，Qt编程入门，QT信号与槽机制，QT界面开发-图像绘制，QT网络，QT数据库编程，QT项目实战，QSS，OpenCV，Quick模块，面试题等等）↓↓↓↓↓↓见下面↓↓文章底部点击莬费领取↓↓
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d97d7d7c2484045e8a5b32527619f670/" rel="bookmark">
			Tomcat简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Tomcat简介
二、下载安装Tomcat 三、利用Tomcat部署静态页面 一、Tomcat简介 Tomcat是一个HTTP服务器，可以按照HTTP的格式来解析请求来调用用户指定的相关代码然后按照HTTP的格式来构造返回数据。
二、下载安装Tomcat 进入Tomcat官网选择与自己电脑的JDK合适的下载版本，JDK1.8一般选用Tomcat8。
然后选择core中的zip点击下载。
对得到的压缩文件进行解压就可以得到如下文件夹：
双击打开文件夹中的bin目录下的startup.bat文件就会启动
可能会出现乱码，因为tomcat使用的是utf-8字符集，但是windows使用的是GBK字符集。
还有可能会出现闪退的情况，可以打开cmd命令行窗口将start.bat拖到命令行窗口进行测试，查看环境变量是否没有配置：
还有就是可能出现8080端口号被占用的情况，可以先找到占用8080端口号的进程，然后在任务管理器中关闭对应的进程。
当tomcat安装成功之后可以利用127.0.0.1:8080在浏览器中进行访问会有如下界面：
三、利用Tomcat部署静态页面 将html文件放到Tomcat安装目录下的webapps\ROOT下，然后就可以使用127.0.0.1:8080/xx.html来访问这个html文件了.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51d602d80a8874f539009ca1da9dfbd6/" rel="bookmark">
			实现优雅的数据返回 - springboot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要统一返回值 定义统一的数据返回格式有利于提高开发效率、降低沟通成本，降低调用方的开发成本。目前比较流行的是基于JSON格式的数据交互。无论是HTTP接口还是RPC接口，保持返回值格式统一很重要。
一般情况下，统一返回数据格式没有固定的规范，只要能描述清楚返回的数据状态以及要返回的具体数据即可，但是一般会包含状态码、消息提示语、具体数据这3部分内容。
{ "code": 20000, "message": "成功", "data": { "items": [ { "id": "1", "name": "weiz", "intro": "备注" } ] } } 定义的返回值包含4要素：响应结果、响应码、消息、返回数据。
统一数据返回 数据格式 定义的返回值包含如下内容：
Integer code：成功时返回0，失败时返回具体错误码。String message：成功时返回null，失败时返回具体错误消息。T data：成功时返回具体值，失败时为null。 data字段为泛型字段，根据实际的业务返回前端需要的数据类型。 { "code": 20000, "message": "成功", "data": { "items": [ { "id": "1", "name": "weiz", "intro": "备注" } ] } } 状态码 返回的数据中有一个非常重要的字段：状态码。状态码字段能够让服务端、客户端清楚知道操作的结果、业务是否处理成功，如果失败，失败的原因等信息。
状态码含义说明200OK请求成功201CREATED创建成功204DELETED删除成功400BAD REQUEST请求的地址不存在或者包含不支持的参数401UNAUTHORIZED未授权（验证不通过）403FORBIDDEN被禁止访问404NOT FOUND请求的资源不存在406Not acceptable错误 – 无法接受422Unprocesable entity[POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误500INTERNAL SERVER ERROR内部错误 其他的业务相关状态码需要根据实际业务定义。
定义数据处理类 视图对象（响应数据结构）：
package com.qsdbl.malldemo.entity.vo; import io.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51d602d80a8874f539009ca1da9dfbd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c0696df1b45d8e2fb831971133efcbd/" rel="bookmark">
			LeetCode 45. 跳跃游戏 II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。
每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:
0 &lt;= j &lt;= nums[i]
i + j &lt; n
返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。
示例 1:
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
示例 2:
输入: nums = [2,3,0,1,4]
输出: 2
提示:
1 &lt;= nums.length &lt;= 104
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c0696df1b45d8e2fb831971133efcbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e620da0f47bfd2f4e91e4a719ff90694/" rel="bookmark">
			C/C&#43;&#43;数字字符串与数字之间的相互转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、数字字符串转化为数字
1.1、C语言方法
1.2、C++方法
2、数字转化为数字字符串
2.1、C语言方法
2.2、C++方法
1、数字字符串转化为数字 1.1、C语言方法 (1) sscanf
sscanf读取格式化的字符串中的数据
sscanf的原型：
#include &lt;stdio.h&gt;
int sscanf(const char *str, const char *format, ...);
参数列表：
str:待读取的字符串;
format:字符串格式描述;
其后是一序列数目不定的指针参数，存储读取后的数据.
返回值：
函数将返回成功赋值的字段个数
示例：
1.将数字字符串转化为整数
#include&lt;stdio.h&gt; int main() { int year, month, day; int count = sscanf_s("20220208", "%04d%02d%02d", &amp;year, &amp;month, &amp;day); printf("count=%d, year=%d, month=%d, day=%d\n", count, year, month, day); //输出：count=3, year=2022, month=02, day=08 return 0; } 2.浮点数转换
#include&lt;stdio.h&gt; int main() { double a,b; int count = sscanf_s("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e620da0f47bfd2f4e91e4a719ff90694/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/133341a0961d249b9479ee0bc9c3fb96/" rel="bookmark">
			window10系统基于theano安装Keras
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows10系统基于theano’0.8.0’安装Keras’1.0.7’ 一、电脑系统：
windows10 anaconda 二、python需要安装以下模块：
1、Keras version: '1.0.7' 2、Theano version: '0.8.0' 三、安装步骤
1、创建conda虚拟环境
在anaconda prompt中输入
# theano是创建的虚拟环境名，python=指定了python版本 conda create -n theano python=2.7 若是已有python2.7的虚拟环境，则忽略第一步，直接从第二步开始后续步骤。
2、激活环境
conda activate keras 如果已有python2.7的虚拟环境，则将keras替换为你自己的虚拟环境名。
3、安装theano
pip install theano==0.8.0 4、安装keras
pip install keras==1.0.7 注意：
此时keras使用的是tensorflow后端，我们需要修改文件来使用theano后端。方法如下：
1、打开桌面“此电脑”，找到路径：C:\Users\（个人用户名）\.keras，如下图所示：
打开keras.json文件，可以看到内容如下：
{ "image_dim_ordering": "th", "epsilon": 1e-07, "floatx": "float32", "backend": "tensorflow" } 2、将"backend": “tensorflow"改为"backend”: “theano”，修改后的keras.json文件内容如下：
{ "image_dim_ordering": "th", "epsilon": 1e-07, "floatx": "float32", "backend": "theano" } 3、保存并关闭文件。
四、测试安装是否成功
1、进入python，输入import theano，回车
2、上述指令无问题后，继续输入import keras，回车
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/133341a0961d249b9479ee0bc9c3fb96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ae56b3dfe361679f1b4276b46db8fe/" rel="bookmark">
			Cause: java.sql.SQLException: No operations allowed after statement closed.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cause: java.sql.SQLException: No operations allowed after statement closed. 需求背景：多个大表关联打成一个大宽表，数据量是千万级。
一开始直接写Flink SQL非常慢并且严重反压，运行一段时间会报binlog过期的问题。
2022-11-06 16:50:34 java.lang.RuntimeException: One or more fetchers have encountered exception at org.apache.flink.connector.base.source.reader.fetcher.SplitFetcherManager.checkErrors(SplitFetcherManager.java:225) at org.apache.flink.connector.base.source.reader.SourceReaderBase.getNextFetch(SourceReaderBase.java:185) at org.apache.flink.connector.base.source.reader.SourceReaderBase.pollNext(SourceReaderBase.java:143) at org.apache.flink.streaming.api.operators.SourceOperator.emitNext(SourceOperator.java:385) at org.apache.flink.streaming.runtime.io.StreamTaskSourceInput.emitNext(StreamTaskSourceInput.java:68) at org.apache.flink.streaming.runtime.io.StreamOneInputProcessor.processInput(StreamOneInputProcessor.java:65) at org.apache.flink.streaming.runtime.tasks.StreamTask.processInput(StreamTask.java:526) at org.apache.flink.streaming.runtime.tasks.mailbox.MailboxProcessor.runMailboxLoop(MailboxProcessor.java:203) at org.apache.flink.streaming.runtime.tasks.StreamTask.runMailboxLoop(StreamTask.java:811) at org.apache.flink.streaming.runtime.tasks.StreamTask.invoke(StreamTask.java:760) at org.apache.flink.runtime.taskmanager.Task.runWithSystemExitMonitoring(Task.java:954) at org.apache.flink.runtime.taskmanager.Task.restoreAndInvoke(Task.java:933) at org.apache.flink.runtime.taskmanager.Task.doRun(Task.java:746) at org.apache.flink.runtime.taskmanager.Task.run(Task.java:568) at java.lang.Thread.run(Thread.java:834) Caused by: java.lang.RuntimeException: SplitFetcher thread 0 received unexpected exception while polling the records at org.apache.flink.connector.base.source.reader.fetcher.SplitFetcher.runOnce(SplitFetcher.java:150) at org.apache.flink.connector.base.source.reader.fetcher.SplitFetcher.run(SplitFetcher.java:105) at java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96ae56b3dfe361679f1b4276b46db8fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d97c911d9a2fb50cc3bf34574dfacafe/" rel="bookmark">
			动态SQL做增删改查操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是动态SQL sql的内容是变化的, 可以根据条件获取到不同的sql语句.
主要是where部分发生变化。
动态sql的实现, 使用的是mybatis提供的标签 2.动态SQL常用标签 元素作用描述if条件判断单条件判断choose(when、otherwise)条件选择多条件分支判断where.set辅助(条件)处理SQL语句拼接问题foreach循环(批量插入 修改)循环遍历 3.具体使用 mapper.xml文件
&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="ShopInfoMapper"&gt; &lt;sql id="tableName" &gt; `shop_info` &lt;/sql&gt; &lt;sql id="columns"&gt; `shop_info_name`, `shop_info_price`, `shop_info_remark`, `modify_time` &lt;/sql&gt; &lt;sql id="params"&gt; #{shop_info_name}, #{shop_info_price}, #{shop_info_remark}, #{modify_time} &lt;/sql&gt; &lt;sql id="primaryKey"&gt; `shop_info_id` &lt;/sql&gt; &lt;sql id="id"&gt; ${zyu.id} &lt;/sql&gt; &lt;!-- 动态查询语句 --&gt; &lt;select id="query" resultType="map" parameterType="map"&gt; select &lt;include refid="primaryKey"&gt;&lt;/include&gt;,&lt;include refid="columns"&gt;&lt;/include&gt; from &lt;include refid="tableName"&gt;&lt;/include&gt; &lt;trim prefix="where" prefixOverrides="and |or" &gt; &lt;if test="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d97c911d9a2fb50cc3bf34574dfacafe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bf0323d05f682f5feeceae0887972c2/" rel="bookmark">
			C# XML文档遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建一个xml文件，放在你的C#工程的bin\Debug\netcoreapp3.1目录下
xml的内容为：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!--注释：编码格式--&gt; &lt;skills&gt; &lt;skill&gt; &lt;id&gt;1&lt;/id&gt; &lt;name lang="cn"&gt;半月斩&lt;/name&gt; &lt;damage&gt;500&lt;/damage&gt; &lt;!--注释：破环力--&gt; &lt;/skill&gt; &lt;skill&gt; &lt;id&gt;2&lt;/id&gt; &lt;name lang="cn"&gt;闪现&lt;/name&gt; &lt;damage&gt;10&lt;/damage&gt; &lt;/skill&gt; &lt;skill&gt; &lt;id&gt;2&lt;/id&gt; &lt;name lang="cn"&gt;疾跑&lt;/name&gt; &lt;damage&gt;20&lt;/damage&gt; &lt;/skill&gt; &lt;/skills&gt; C# winform 控制台文件：
using System; using System.Xml; namespace xml { class Program { static void Main(string[] args) { Console.WriteLine("Hello World!"); XmlDocument xmlDoc = new XmlDocument(); xmlDoc.Load("skills.xml"); //放在debug 下 //XmlNode root = xmlDoc.FirstChild; //不能这么写 不然只会得到它的头一句 编码那句 XmlNode root = xmlDoc.ChildNodes[1]; //得到它的根节点 XmlNodeList skillList = root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bf0323d05f682f5feeceae0887972c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb935e8991a328a99d65ca0edb29f5ce/" rel="bookmark">
			【Vue】pinia 数据持久化插件 pinia-plugin-persistedstate 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么需要持久化？ 刷新浏览器后，重新加载页面时会重新初始化 vue、 pinia，而 pinia 中状态的值仅在内存中存在，而刷新导致浏览器存储中的数据就没了。
在实际开发中，浏览器刷新时，有些数据希望是保存下来的。如用户登录后，用户信息会存储在全局状态中，如果不持久化状态，那么每次刷新用户都需要重新登录了。
要解决这个问题非常简单，在状态改变时将其同步到浏览器的存储中，如 cookie、localStorage、sessionStorage 。每次初始化状态时从存储中去获取初始值即可。
说起来思路很简单，可真正实现起来就各种问题了，所以咱们就使用 pinia 的插件 pinia-plugin-persistedstate 来实现。
pinia-plugin-persistedstate 插件官方文档
安装依赖 npm install pinia-plugin-persistedstate yarn add pinia-plugin-persistedstate pnpm add pinia-plugin-persistedstate 引入该插件，在创建 pinia 实例时传入该插件 import { createPinia } from 'pinia' import piniaPluginPersistedstate from 'pinia-plugin-persistedstate' const pinia = createPinia() pinia.use(piniaPluginPersistedstate) export default pinia 在需要持久化状态的模块(modules)中设置 persist ... const useUserStore = defineStore('user', () =&gt; { ... }, { key: 'user', // Key 用于引用 storage 中的数据 storage: sessionStorage // 将数据持久化到的 storage 中 // 更多配置请参考官方文档 }) 参考链接 Pinia 数据持久化储存(pinia-plugin-persistedstate)Vue3 Vite3 状态管理 pinia 基本使用、持久化、在路由守卫中的使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b005ca9512283ade7de14818f0592f63/" rel="bookmark">
			JMeter压测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 设置线程组 线程：可以理解为用户，一个线程代表一个用户。
线程组：可以理解为一个包含了多个待测试接口的集合。
线程数：代表用户数量。
循环次数：每个线程执行次数，代表每个用户请求接口的次数。
持续时间：当到达测试时间后，线程组中的任务还没有结束，JMeter则停止测试
2. 添加HTTP请求 这里填写需要测试的接口地址，下图中演示验证码接口，红框中使用了JMeter中的库函数生成随机数。
3. 添加查看结果树 查看结果树：这个主要用来分析各请求结果信息。
4. 添加聚合报告 聚合报告：这个用来分析压测结果分析。
5. 查看测试结果 Label：每个 JMeter 的 element(例如 HTTP Request)都有一个 Name 属性，这里显示的就是 Name 属性的值。
样本：表示这次测试中一共发出了多少个请求。
可以看到本次测试样本只有2930个，因为在前面对线程组的持续时间进行了设置，导致很多样本没有发出任务就结束了。
平均值：平均响应时间——默认情况下是单个 Request 的平均响应时间，当使用了 Transaction Controller 时，也可以以Transaction 为单位显示平均响应时间。
中位数：就是所有用户的响应时间取中间值。
90% 百分位：90％ 用户的响应时间（单位毫秒）。
最小值：最小响应时间。
最大值：最大响应时间。
异常%：本次测试中出现错误的请求的数量/请求的总数。
吞吐量：吞吐量——默认情况下表示每秒完成的请求数(Request per Second)，当使用了 Transaction Controller 时，也可以表示类似 LoadRunner 的 TransactionperSecond 数。
接收KB/Sec：每秒从服务器端接收到的数据量，相当于LoadRunner中的Throughput/Sec。发送同理。
6. json格式数据请求 这里使用登录接口作为示例。
请求数据
加入信息头管理器，用来设置请求的数据类型。
重新配置线程组。
程序运行完成以后，就可以查看相应的测试结果这里以2000个线程组瞬时并发为例得到如下报告：
上图表参数含义如下：
1、样本数目是总共发送到服务器的请求数。
2、最新样本是代表时间的数字,是服务器响应最后一个请求的时间。
3、吞吐量是服务器每分钟处理的请求数，应越来越高或趋于稳定。
4、平均值是总运行时间除以发送到服务器的请求数。
5、中间值是代表时间的数字，有一半的服务器响应时间低于该值，而另一半高于该值。
6、偏离量：数据分布的偏差，每次响应时间的变化偏差，应该是趋于稳定或者越来越小比较好
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b005ca9512283ade7de14818f0592f63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78b0703d8fb8e508685cd08c892ee3b8/" rel="bookmark">
			org.apache.poi.util.POILogger, but class was expected异常的原因及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 各位小伙伴在项目开发过程中可能会需要对excel表格文件进行导入导出;那么完成这项功能其实有两钟方法:1、使用Apache POI框架对excel进行操作;2、使用EasyExcel;二者都可以解析Excel文件。但是poi存在的一个非常严重的问题就是非常耗内存，虽然poi有一套SAX模式的API可以一定程度解决内存溢出的问题，但内存消耗依旧很大。如果各位小伙伴感兴趣的话我会在后面将两种方法的实现都整理出来分享给大家，现在先说使用poi 遇到的一个异常: java.lang.IncompatibleClassChangeError:Found interface org.apache.poi.util.POILogger, but class was expected。
出现这个异常的原因其实很简单，大部分小伙伴在进行项目开发的时候都是在现有的框架中填写代码，所以说在pom文件导入依赖的时候可能会没有注意pom文件原先已经存在了poi，如下
&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; 可以看见这个 poi 依赖的版本号是 4.1.2，而我们出现这个异常的原因就是因为我们缺少 poi-ooxml 或导入的 poi-ooxml 版本号不一致，所以我们只需要将 poi-ooxml 依赖加入或将版本号修改为一致即可解决该问题，如下：
&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d89fc9ce7bec2f2d7d52698b7a837569/" rel="bookmark">
			sublime侧边栏字体、样式、边距修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 插件打开 安装插件：PackageResourceViewer安装成功后ctrl+shift+p，输入PackageResourceViewer，打开如下图：
输入Theme-Default输入Default.sublime-theme 手动打开 preferences -&gt; browse packages 或者打开sublime Text根目录进入packages压缩工具打开Theme - Default.sublime-package修改Default.sublime-theme 修改前注意备份
修改内容 "font_face": "system", "font_size_sm": 13, // 侧边字体大小 "font_size": 14, "font_size_lg": 14, "font_size_title": 24, { "class": "sidebar_tree", "platforms": ["windows"], // 边距大小，[左右边距, 上下边距] 修改最后一个即可 "row_padding": [16, 2, 4, 4], } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5259550188ef371ceae7eb44f9c190bf/" rel="bookmark">
			[Redis]Spring 整合Redis5.0集群【jedisCluster】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.第一步：引入响应的jar包。 &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.7.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; 2.第二步：Spring配置文件spring-redis.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd"&gt; &lt;context:property-placeholder location="classpath:redis.properties" /&gt; &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;property name="maxIdle" value="${redis.maxIdle}" /&gt; &lt;property name="maxTotal" value="${redis.maxActive}" /&gt; &lt;property name="maxWaitMillis" value="${redis.maxWait}" /&gt; &lt;property name="testOnBorrow" value="${redis.testOnBorrow}" /&gt; &lt;/bean&gt; &lt;bean id="hostport1" class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="172.16.1.84" /&gt; &lt;constructor-arg name="port" value="7001" /&gt; &lt;/bean&gt; &lt;bean id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5259550188ef371ceae7eb44f9c190bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae1f4f48c0e6e825ca40fc3240760e04/" rel="bookmark">
			使用winSCP完成在Windows 和 Linux 系统之间传输文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、为什么要使用 WinSCP
在日常 SoC 开发中，我们经常需要在 Windows 和 Linux 系统之间传输文件，
例如在 Windows 系统上的 DS-5 集成开发环境中编写好的 Linux 应用程序需要传
递到 Linux 嵌入式开发板中（例如 SoC FPGA 开发板），或者需要将 Linux 系统
中的文件拷贝到 Windows 上进一步操作处理，就涉及到两者之间的文件传输。
实现上述场景中文件传输的一种比较便捷的方式，是使用 SCP 方式。 在 Windows
系统中，可以通过安装 WinSCP 软件来实现上述功能。
2、安装 WinSCP
该软件可以在 https://winscp.net/eng/download.php 网址下载得到，光盘资料
中提供了下载好的离线安装包 WinSCP-5.13.3-Setup.exe，直接双击即可运行安装。
安装过程没有什么需要注意的， 一律默认即可。
使用时， 如果远程主机没有固定的 IP 和端口映射， 则需要 Windows 主机和
远程主机处于同一网段，例如连接在同一个路由器上，或者通过网线直连，并设
置 IP 在同一网段， 否则无法实现连接
3、建立远程主机连接
安装完成后运行。 首次使用会自动弹出登录界面，在主机名处输入希望连接
主机的 IP 地址，端口号默认 22， 用户名和密码输入远程系统的用户名和密码即
可， 使用WinCP，不仅可以连接开发板，还可以连接windows系统中安装的Ubuntu
虚拟机， 如图 5.6– 1 所示， 为使用 WinCP 连接笔者电脑上虚拟机方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae1f4f48c0e6e825ca40fc3240760e04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd5e40f627cbc5dfcc23a33c2b1e6043/" rel="bookmark">
			latex \textbf加粗没反应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方案：
对于中文无法加粗，检查是否引用了中文环境包 \usepackage{ctex}
对于英文、数字无法加粗，引用字体编码设置包 \usepackage[T1]{fontenc}
转自：https://blog.csdn.net/dongqing0315/article/details/125385922
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a10b0766ae26ef6bc064de65d56f6723/" rel="bookmark">
			UG二次开发 创建圆柱和简单孔UF_MODL_create_simple_hole
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本实例主要实现了通过ufun创建圆柱和简单孔，主要使用了一下几个ufun函数：
theUFSession.Modl.CreateCyl1 创建圆柱
theUFSession.Modl.AskFeatFaces 获取面列表
theUFSession.Modl.CreateSimpleHole 创建简单孔
最终实现效果图如下：
一、主程序 先看实现简单孔的主程序如下：
using System; using NXOpen; using NXOpen.UF; using NxLibrary; public class Program { private static Session theSession; private static UFSession theUFSession; public static Program theProgram; private static UI theUI = null; public static int Main(string[] args) { theUI = UI.GetUI(); int retValue = 0; try { #region 简单孔 double[] origin = new double[3] { 0.0, 0.0, 0.0 }; double[] direction = new double[3] { 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a10b0766ae26ef6bc064de65d56f6723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ce1cffd9f3ec51be614465bedb7b230/" rel="bookmark">
			计算机网络中网络吞吐量计算公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是什么？网络吞吐量的计算公式是：吞吐量 = 每秒传输的数据量 / 网络带宽。其中，网络带宽是指网络中每秒可以传输的数据量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2576aa11a16d54347adeac44b05a183/" rel="bookmark">
			MySQL无法启动 不断反复重启 没有提示的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不出问题一路next，出了问题才发现无从下手。居然没有记录错误的日志。
多方查找与尝试，找到解决方案。
直接在MySQL安装目录下，运行：mysqld --console
这样可以看到启动信息与错误提示。
我的提示
2023-02-07T15:09:08.567200Z 1 [ERROR] [MY-012271] [InnoDB] InnoDB: The innodb_system data file 'ibdata1' must be writable
2023-02-07T15:09:08.568178Z 1 [ERROR] [MY-012278] [InnoDB] InnoDB: The innodb_system data file 'ibdata1' must be writable
2023-02-07T15:09:08.568701Z 1 [ERROR] [MY-010334] [Server] Failed to initialize DD Storage Engine
2023-02-07T15:09:08.569753Z 0 [ERROR] [MY-010020] [Server] Data Dictionary initialization failed.
2023-02-07T15:09:08.569827Z 0 [ERROR] [MY-010119] [Server] Aborting
2023-02-07T15:09:08.572348Z 0 [System] [MY-010910] [Server] C:\phpstudy_pro\Extensions\MySQL8.0.12\bin\mysqld.exe: Shutdown complete (mysqld 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2576aa11a16d54347adeac44b05a183/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a11e7d524869e98699da1d802c317658/" rel="bookmark">
			Java开发学习(四十四)----MyBatisPlus查询语句之查询条件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查询条件 前面我们只使用了lt()和gt(),除了这两个方法外，MybatisPlus还封装了很多条件对应的方法。
MybatisPlus的查询条件有很多:
范围匹配（&gt; 、 = 、between）
模糊匹配（like）
空判定（null）
包含性匹配（in）
分组（group）
排序（order）
……
1.1 等值查询
需求:根据用户名和密码查询用户信息
@SpringBootTest class Mybatisplus02DqlApplicationTests { ​ @Autowired private UserDao userDao; @Test void testGetAll(){ LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;(); lqw.eq(User::getName, "Jerry").eq(User::getPassword, "jerry"); User loginUser = userDao.selectOne(lqw); System.out.println(loginUser); } } eq()： 相当于 =,对应的sql语句为
SELECT id,name,password,age,tel FROM user WHERE (name = ? AND password = ?) selectList：查询结果为多个或者单个
selectOne:查询结果为单个
1.2 范围查询
需求:对年龄进行范围查询，使用lt()、le()、gt()、ge()、between()进行范围查询
@SpringBootTest class Mybatisplus02DqlApplicationTests { ​ @Autowired private UserDao userDao; @Test void testGetAll(){ LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;(); lqw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a11e7d524869e98699da1d802c317658/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4dd6d1c60f878058db16b980270064b/" rel="bookmark">
			EventBus初识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 使用方式注册定义消息类型接收通知的回调解绑发送 2 示例3 控制接收方法运行的线程POSTINGMAINBACKGROUNDASYNC 1 使用方式 注册 EventBus.getDefault().register(this); 定义消息类型 public class EventA { String message; public EventA(String message) { this.message = message; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } } 接收通知的回调 @Subscribe public void onEventReceive(EventA eventA) { } 解绑 EventBus.getDefault().unregister(this); 发送 EventBus.getDefault().post(new EventA("message")); 2 示例 在MainActivity中启动SecondActivity。在MainActivity中重写带有@Subscribe注释的方法，用于接收事件的回调。在SecondActivity中发送事件。 接收方
public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4dd6d1c60f878058db16b980270064b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc831170467d912a9277d251b156c524/" rel="bookmark">
			windows jenkins获取管理员权限或本地用户权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 如果是还没装jenkins如果jenkins已经在跑了jenkins启动报错，错误代码为：1069的解决办法 有个前端项目要使用taro，编译的时候报找不到，明明在jenkins的服务器上面已经装了，猜测可能是用户不对，结合之前git也有一些用户的问题，使用命令或者某些插件的时候经常出现权限错误的情况，在此分享一下解决办法。 如果是还没装jenkins 可以使用本地或域用户将Jenkins作为独立的Windows服务安装和运行。如果Test不通过，请看下文：jenkins启动报错，错误代码为：1069的解决办法
如果jenkins已经在跑了 按Ctrl+windows键，输入services.msc
在服务中右键选中并点击jenkins服务，查看属性对话框
切换登录标签，选中此账户登录，里边填写administrator或者有权限的账户，密码就是登录密码，此时重启jenkins服务即可。
jenkins启动报错，错误代码为：1069的解决办法 如果重启jenkins报错，错误代码为：1069，可能是用户名密码不对，注意：是密码，不是pin。如果忘记了当前用户的密码，可以按照以下步骤覆盖之前密码：
账户→登录选项→其他设置【为了提高安全性……】把开关关闭
账户→登录选项→其他设置【为了提高安全性……】把开关关闭就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14aec011011ec67b1fa7ed199965fbe8/" rel="bookmark">
			Linux kernel | 块IO子系统请求处理过程、multi-queue框架、请求合并处理blk_plug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 通用块层提供给上层的接口函数是submit_bio。上层在构造好bio请求之后，调用该接口提交给Linux通用块层处理。
上层向块io子系统提交请求
我们首先从submit_bio函数入手：
//common/block/blk-core.c:10 blk_qc_t submit_bio(struct bio *bio) { if (blkcg_punt_bio_submit(bio)) return BLK_QC_T_NONE; /* * If it's a regular read/write or a barrier with data attached, * go through the normal accounting stuff before submission. */ if (bio_has_data(bio)) { unsigned int count; if (unlikely(bio_op(bio) == REQ_OP_WRITE_SAME)) count = queue_logical_block_size( bio-&gt;bi_bdev-&gt;bd_disk-&gt;queue) &gt;&gt; 9; else count = bio_sectors(bio); if (op_is_write(bio_op(bio))) { count_vm_events(PGPGOUT, count); } else { task_io_account_read(bio-&gt;bi_iter.bi_size); count_vm_events(PGPGIN, count); } } /* * If we're reading data that is part of the userspace workingset, count * submission time as memory stall.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14aec011011ec67b1fa7ed199965fbe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d33f5721f2abc65c0160d2d067205056/" rel="bookmark">
			线程复习（针对面试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题一：请说明一下进程和线程的区别？ 一个进程运行要给他分配系统资源，维护他的代码段和数据段，堆栈等。而线程跟他共享这些，节俭的多任务操作方式。
典型的UNIX/Linux进程可以看成只有一个控制线程：一个进程在同一时刻只做一件事情。有了多个控制线程后，在程序设计时可以把进程设计成在同一时刻做不止一件事，每个线程各自处理独立的任务。　进程是程序执行时的一个实例，是担当分配系统资源（CPU时间、内存等）的基本单位。在面向线程设计的系统中，进程本身不是基本运行单位，而是线程的容器。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。
线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。线程包含了表示进程内执行环境必须的信息，其中包括进程中表示线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno常量以及线程私有数据。进程的所有信息对该进程的所有线程都是共享的，包括可执行的程序文本、程序的全局内存和堆内存、栈以及文件描述符。在Unix和类Unix操作系统中线程也被称为轻量级进程（lightweight processes），但轻量级进程更多指的是内核线程（kernel thread），而把用户线程（user thread）称为线程。
"进程——资源分配的最小单位，线程——程序执行的最小单位"
进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
问题二：使用线程的理由 从上面我们知道了进程与线程的区别，其实这些区别也就是我们使用线程的理由。总的来说就是：进程有独立的地址空间，线程没有单独的地址空间（同一进程内的线程共享进程的地址空间）。
使用多线程的理由之一是和进程相比，它是一种非常"节俭"的多任务操作方式。我们知道，在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种"昂贵"的多任务工作方式。而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。据统计，总的说来，一个进程的开销大约是一个线程开销的30倍左右，当然，在具体的系统上，这个数据可能会有较大的区别。
使用多线程的理由之二是线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。当然，数据的共享也带来其他一些问题，有的变量不能同时被两个线程所修改，有的子程序中声明为static的数据更有可能给多线程程序带来灾难性的打击，这些正是编写多线程程序时最需要注意的地方。
除了以上所说的优点外，不和进程比较，多线程程序作为一种多任务、并发的工作方式，当然有以下的优点：
提高应用程序响应。这对图形界面的程序尤其有意义，当一个操作耗时很长时，整个系统都会等待这个操作，此时程序不会响应键盘、鼠标、菜单的操作，而使用多线程技术，将耗时长的操作（time consuming）置于一个新的线程，可以避免这种尴尬的情况。使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。 Linxu线程生产者 cond Linux 初始化 宏 静态初始化：
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; // static init
pthread_cond_t cond = PTHREAD_COND_INITIALIZER; // static init
动态初始化：
pthread_mutex_t mutex; //dynamic init
pthread_cond_t cond; //dynamic init
主函数中必须：
pthread_mutex_init(&amp;mutex, NULL); //dynamic init
pthread_cond_init(&amp;cond, NULL); //dynamic init
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f6a5912a53e293e40859fb008362eba/" rel="bookmark">
			minio 结合ng 报错The request signature we calculated does not match the signature you provided.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求描述：小程序中需要访问图片，但是又不能直接访问minio的ip地址加端口的方式。只有通过ng来转发。小程序里面必须通过域名的方式才能访问接口或者图片。
正常通过ip加端口是能访问minio的图片。通过ng后就报错意思就是验证不通过访问图片。大概的原因应该是ng转发后的header有什么问题。
我是去掉了ng配置中的proxy_set_header Host 这个设置。加了proxy_redirect off;
全局配置如下：
#user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { #https访问minio的端口号 listen 8079 default_server ssl; server_name www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f6a5912a53e293e40859fb008362eba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e80a6450e5a78ffa04790a8a34da3ca/" rel="bookmark">
			redis失效策略和删除策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用Redis时，我们一般会为Redis的缓存空间设置一个大小，不会让数据无限制地放入Redis缓存中。可以使用下面命令来设定缓存的大小，比如设置为4GB：
CONFIG SET maxmemory 4gb
既然 Redis 设置了缓存的容量大小，那缓存被写满就是不可避免的。当缓存被写满时，我们需要考虑下面两个问题：决定淘汰哪些数据，如何处理那些被淘汰的数据。
一、Redis的数据过期清除策略：
如果我们设置了Redis的key-value的过期时间，当缓存中的数据过期之后，Redis就需要将这些数据进行清除，释放占用的内存空间。Redis中主要使用 定期删除 + 惰性删除 两种数据过期清除策略。
1、过期策略：定期删除+惰性删除：
（1）定期删除：redis默认每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果有过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载。
为什么不用定时删除策略呢？
定时删除，用一个定时器来负责监视key，过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key，因此没有采用这一策略。
（2）惰性删除：定期删除可能导致很多过期的key 到了时间并没有被删除掉。这时就要使用到惰性删除。在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间并且过期了，是的话就删除。
2、定期删除+惰性删除存在的问题：
如果某个key过期后，定期删除没删除成功，然后也没再次去请求key，也就是说惰性删除也没生效。这时，如果大量过期的key堆积在内存中，redis的内存会越来越高，导致redis的内存块耗尽。那么就应该采用内存淘汰机制。
二、Redis的缓存淘汰策略：
Redis共提供了8中缓存淘汰策略，其中 volatile-lfu 和 allkeys-lfu 是Redis 4.0版本新增的。
1、noeviction：不进行淘汰数据。一旦缓存被写满，再有写请求进来，Redis就不再提供服务，而是直接返回错误。Redis 用作缓存时，实际的数据集通常都是大于缓存容量的，总会有新的数据要写入缓存，这个策略本身不淘汰数据，也就不会腾出新的缓存空间，我们不把它用在 Redis 缓存中。
2、volatile-ttl：在设置了过期时间的键值对中，移除即将过期的键值对。
3、volatile-random：在设置了过期时间的键值对中，随机移除某个键值对。
4、volatile-lru：在设置了过期时间的键值对中，移除最近最少使用的键值对。
5、volatile-lfu：在设置了过期时间的键值对中，移除最近最不频繁使用的键值对
6、allkeys-random：在所有键值对中，随机移除某个key。
7、allkeys-lru：在所有的键值对中，移除最近最少使用的键值对。
8、allkeys-lfu：在所有的键值对中，移除最近最不频繁使用的键值对
通常情况下推荐优先使用 allkeys-lru 策略。这样可以充分利用 LRU 这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。
如果你的业务数据中有明显的冷热数据区分，建议使用 allkeys-lru 策略。
如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用 allkeys-random 策略，随机选择淘汰的数据就行。
如果没有设置过期时间的键值对，那么 volatile-lru，volatile-lfu，volatile-random 和 volatile-ttl 策略的行为, 和 noeviction 基本上一致。
三、Redis中的LRU和LFU算法：
1、LRU算法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e80a6450e5a78ffa04790a8a34da3ca/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/183/">«</a>
	<span class="pagination__item pagination__item--current">184/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/185/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>