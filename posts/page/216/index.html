<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a69599393a152e1cc043352a4b450f6b/" rel="bookmark">
			高速电路中的几种结构理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【菊花链】：单点连出去很多，交汇点在总线上
【fly-by】：特殊的菊花链结构，总线上引出非常短的分支到ddr上
【T型】 : 两个DDR对称放置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f4e1368d539889ccb9220578b4d762d/" rel="bookmark">
			解决docker出现A dependency job for docker.service failed. See ‘journalctl -xe‘ for details.问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 1、问题分析2、解决办法2.1、删除运行时信息2.2、卸载container.io2.3、重启虚拟机2.4、重新安装docker（说明：不会影响现有数据） 1、问题分析 我发现docker没有启动起来，然后通过docker images查看docker镜像，但是命令迟迟没有执行，所以我使用systemctl restart docker重启docker，但是出现了下面的问题
按照提示，我输入journalctl -xe命令查看原因，错误描述如下图
可以看出来是Container导入的问题
2、解决办法 2.1、删除运行时信息 rm -rf /var/lib/containerd 来自于：https://github.com/containerd/containerd/issues/5175
2.2、卸载container.io yum remove containerd.io 2.3、重启虚拟机 reboot 2.4、重新安装docker（说明：不会影响现有数据） # 卸载资源 sudo yum remove docker* #配置docker yum 源 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #安装docker 19.03.9（大家根据自己docker版本进行安装） yum install -y docker-ce-3:19.03.9-3.el7.x86_64 docker-ce-cli-3:19.03.9-3.el7.x86_64 containerd.io # 首先启动docker，然后让docker随虚拟机一起启动 systemctl start docker systemctl enable docker 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e6a2fa8d2dc8f8db790922450147c34/" rel="bookmark">
			大无语事件，gulimall.com域名国外申请了！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做谷粒商城项目，学到社交登录这块，微博要认证比较麻烦，就看弹幕说用github，代码都整完了，结果gulimall.com会被自动重定向到这个网页(还是2022年申请的，真不是有人故意搞怪嘛)，我本地域名和他冲突了。其实只要不去外网就没事，可是我github不开vpn，就没法上，真是服了！
去看看gitee了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4bef23fc6f832a59199aa03805feb4a/" rel="bookmark">
			解析强缓存与协商缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 在工作中，前端代码打包之后的静态需要部署到服务器上，这时就需要对一些静态资源做一些运维配置，其中缓存是必不可少的。
缓存的优点：
减少了不必要的数据传输减轻了对服务器的压力，提升系统的性能加快了用户加载网页的速度提升了用户体验 缓存的缺点：
无法保证缓存数据与数据库中的数据保持同步可能会出现缓存失效 一、强缓存 强缓存其实就是强制缓存的意思。当浏览器去请求某个文件的时候，服务端就在respone header里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制，具体表现为：
respone header 的cache-control，常见的设置是max-age public private no-cache no-store等
强制缓存主要取决于两个字段 Expires 和 Cache-Control 中的 max-age 字段， 在
在的情况下， 其流程如下图所示
由图可知，当强制缓存中的两个字段同时存在的时候，Cache-Control中的max-age优先级要高，只有当Cache-Control失效时才会校验Expires字段。
强缓存总结 cache-control: max-age=xxxx，public
max-age：表示缓存的时间（有效期）
public：表示客户端和代理服务器都可以缓存该资源；但是，当用户重新刷新页面时，就会重新 发送请求，获取资源cache-control: max-age=xxxx，private
private：表示只让客户端可以缓存该资源；代理服务器不缓存cache-control: max-age=xxxx，immutable
immutable：表示即使用户重新刷新页面，也不会重新发送请求，还是直接读取缓存cache-control: no-cache
no-cache：表示不走强制缓存，但可以走协商缓存cache-control: no-store
no-store：表示不走缓存 二、协商缓存 当强制缓存时间过期后，这是客户端就会去请求服务器，在请求服务器的过程中可以设置协商缓存。
协商缓存主要由 ETag 和 Last-Modified 两个字段来实现
ETag 是一个用于映射 web 资源的映射 token，具有唯一性
Last-Modified 则通常是文件最后更新的日期时间戳
协商缓存的工作流程如下图所示：
浏览器首次向服务器请求数据时， 服务器正常返回数据，同时在响应头中放入 ETag 和 Last-Modified 两个新字段浏览器第二次向服务器请求数据时， 浏览器会自动地在请求头附上 If-None-Match 和 If-Modified-Since 两个字段（分别对应的是 ETag 和 Last-Modified 的值，主要校验两者是否相等）， 然后由服务器端进行校验， 校验通过的话（表明数据有效）， 服务器会直接返回 状态码 304 ，且不携带响应体的报文段， 这相当于告诉浏览器：当前缓存有效， 可以直接使用！ 校验失败则会和首次请求一样， 返回状态码为200且携带数据响应体的报文段， 同时这个响应头会带上新的ETag 和Last-Modified， 为下一次协商缓存做好铺垫 总结 强制缓存发生在浏览器端， 协商缓存发生在服务器端强制缓存在浏览器强制刷新的情况下不会生效， 而协商缓存则不受影响。强制缓存返回的报文状态码为 200， 协商缓存返回的报文状态码为 304 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac8271ab3e04ce1952b58d29660712a/" rel="bookmark">
			使用 Sortable.js 在 uni App 上实现拖拽排序功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sortable.js,它可以用来实现这个拖拽的功能。
Sortable.js —是一个JavaScript库，用于在现代浏览器和触摸设备上对拖放列表进行重新排序，无需jQuery。 特点有：
轻量级但功能强大
移动列表项时有动画
支持触屏设备和大多数浏览器（IE9及以下除外）
支持单个列表容器内部拖拽排序，也支持两个列表容器互相拖拽排序
支持拖放操作和可选择的文本
非常友善的滚动效果
基于原生HTML5中的拖放API
支持多种框架（Angular、Vue、React等）
支持所有的CSS框架，如：Bootstrap
简单的API，方便调用
CDN
不依赖于jQuery
步骤 安装sortable.js
npm install sortablejs --save-dev 获取节点
这里获取的节点是需要拖拽列表的父节点
// 使用DOM id 获取DOM let el = document.getElementById('list') 或者
// 使用类名 let el = document.querySelector('.list') 通过Sortable()构建函数，接收容器元素和配置项
let el = document.querySelector('.list') ​ sortable = Sortable.create(this.dragData, { sort: true, //是否可进行拖拽排序 animation: 500, // 允许被拖拽的类名 draggable: '.data', ​ // 元素被选中 onChoose: (/**Event*/evt) =&gt; { console.log("元素被选中,事件对象",evt) // element index within parent }, // 开始拖拽的时候 onStart: (/**Event*/evt) =&gt; { evt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ac8271ab3e04ce1952b58d29660712a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae2bad1e3dd51984a132fce4ce2f30b1/" rel="bookmark">
			vultarget-a红日靶场全面解析（完整版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 vultargeta靶场是星期五实验室公众号发布的自行设计靶场,其中涵盖了WEB渗透、主机漏洞、域漏洞、工控漏洞等等。
此靶场使用
网络结构 其靶场网络结构为
kali : 桥接模式win7: 双网卡—桥接模式,卡2仅主机模式win2019: VMnet19仅主机模式win2016: 双网卡— VMnet18仅主机模式 ,VMnet19仅主机模式 win7主机通过NAT与kali机出于同一网段,且通过VMnet18接入内网与win2016VM18网卡进行通信,win2016通过网卡2VM19与DC机进行通信
信息搜集 扫描同一网段下主机ip地址
arp-scan -l 128为本机地址,131为win7主机ip
nmap -sS -sV 192.168.111.131 nmap扫描目标主机.注意:windows防火墙开启状态默认不允许ping检测,而linux默认是支持的,所以使用nmap探测时应使用TCP的SYN进行探测
根据结果可以看出目标主机开启80端口和445端口,访问网站
通过访问目标主机网站,可以发现该靶场使用到了通达OA系统,百度百科上这么写这:
通达OA概述与先进技术，该系统采用领先的B/S(浏览器/服务器)操作方式，使得网络办公不受地域限。　Office Anywhere采用基于WEB的企业计算，主HTTP服务器采用了世界上最先进的Apache服务器，性能稳定可靠。数据存取集中控制，避免了数据泄漏的可能。提供数据备份工具，保护系统数据安全。多级的权限控制，完善的密码验证与登录验证机制更加强了系统安全性。
WIN7漏洞利用 通达OA利用工具+中国蚁剑 上面端口扫描时发现目标机器开启445端口,首先想到利用永恒之蓝漏洞,稍后利用,先使用通达OA工具尝试攻击
点击通达OA工具可以进行下载
为了方便我将该工具源码打包成jar方便kali执行
java -jar TDOA_RCE-master.jar 首先打开通达OA工具后目标地址为靶场对外主机win7的外网ip,获取Cookie按钮后下方栏中会显示通达OA任意用户登录测试得到的Cookie一键利用,工具会自动在http://192.168.1.109/FRSJFIL.php生成木马并提供密码
******* 当前通达OA版本为: 11.3 正在尝试利用任意用户登录漏洞获取Cookie... poc1利用成功 已自动填充 ******* 正在尝试利用本地文件包含漏洞... 利用成功 SHELL如下: http://192.168.111.131/VPMHKQF.php 密码:x 中国蚁剑直接连接
成功连接
进入命令端
whoami 永恒之蓝漏洞利用 在信息搜集环节,我们是发现被攻击主机开启443端口,所以我会想到利用永恒之蓝漏洞进行一次渗透
kali机打开msfconsoleuse exploit/windows/smb/ms17_010_eternalblueset rhosts 192.168.111.131run
成功得到通道!并且为system权限
自动迁移进程,稳固连接 run post/windows/manage/migrate 输入shell 进入控制台
chcp 65001 修改控制台编码,默认进入shell有些字符会乱码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae2bad1e3dd51984a132fce4ce2f30b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae695a91faf7bdb0645c9f7c01627f4f/" rel="bookmark">
			在vue项目中为啥不能用index作为key？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		啊？不是吧，在vue中，不能使用index作为key呢？使用index作为key又好理解又方便，为什么不能使用呢？看文章就知道啦~.
一、key的作用是什么？ key的作用众所周知，看一个demo就知道：
&lt;script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"&gt;&lt;/script&gt; &lt;body&gt; &lt;ul id="app"&gt; &lt;li v-for="(item,index) in list" :key="index"&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; new Vue({ el: '#app', data() { return { list: [1, 2, 3] } } }) &lt;/script&gt; &lt;/body&gt; 复制代码 image-20220924222650595.png 在vue中key可以没有，没有也可以运行并且不会报错，但是建议加上key。
另外，我们必须知道，vue中key运用的地方------配合v-for使用。key是vue中虚拟dom标记的唯一标识，通过这个key，diff算法能更加准确和快捷。不使用key的情况下，因为vue的就地更新会选择复用节点，之前的状态被保存，可能会产生一系列的bug。另外，key的唯一性可以被map数据结构充分利用，时间复杂度仅为o（1）。
简单来说，key是唯一标识，为了让diff算法更准确的找到需要被对比的两个节点。
二、什么是虚拟DOM？ 虚拟DOM结构就是一个对象而已，其中描述了每一层容器的特征。在beroreCreated执行的时候，DOM树并没有生成。
虚拟DOM光说肯定是不可理解的，那我们就用代码说话：
&lt;script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"&gt;&lt;/script&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;ul&gt; &lt;item v-for="(num,index) in list" :key="index":num="num":class=`item${num}`&gt;&lt;/item&gt; &lt;/ul&gt; &lt;button @click="change"&gt;change&lt;/button&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: '#app', data() { return { list: [1, 2, 3] } }, methods: { change() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae695a91faf7bdb0645c9f7c01627f4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e69c8aeeec5488c8b46221bb7fbc55cc/" rel="bookmark">
			9.知识图谱和知识挖掘的了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.知识图谱能做什么？ 知识图谱想做的，就是在不同数据（来自现实世界）之间建立联系，从而带给我们更有意义的搜索结果。比如：用 Google 搜索自然语言处理，右侧会显示研究领域和相关概念。点击这些知识点，又可以深入了解；再比如，搜索一个人名时，右侧会给出此人的生平、背景、居住位置、作品等信息。
2. 知识图谱的通用表示方法 本质上，知识图谱是一种揭示实体之间关系的语义网络 ，可以对现实世界的事物及其相互关系进行形式化地描述 。现在的知识图谱己被用来泛指各种大规模的知识库 。
三元组是知识图谱的一种通用表示方式，即G=(E，R，S)。其中，E是实体集合，R是知识库中的关系集合，S真包含于E✖R✖E代表知识库中的三元组集合。
三元组的基本形式主要包括实体 A、关系、实体 B 和概念、属性、属性值等，实体是知识图谱中的最基本元素，不同的实体间存在不同的关系。概念主要指集合、类别、对象类型、事物的种类，例如人物、地理等；属性主要指对象可能具有的属性、特征、特性、特点以及参数，例如国籍、生日等；属性值主要指对象指定属性的值，例如中国、1988—09—08等。每个实体（概念的外延）可用一个全局唯一确定的 ID 来标识，每个属性—属性值对可用来刻画实体的内在特性，而关系可用来连接两个实体，刻画它们之间的关联。
3.知识图谱的逻辑结构 知识图谱在逻辑上可分为模式层与数据层两个层次，数据层主要是由一系列的事实组成，而知识将以事实为单位进行存储。如果用（实体 A，关系，实体 B）、（实体、属性，属性值）这样的三元组来表达事实，可选择图数据库作为存储介质，例如开源的 Neo4j、Twitter 的 FlockDB、Sones 的 GraphDB 等。模式层构建在数据层之上，主要是通过本体库来规范数据层的一系列事实表达。本体是结构化知识库的概念模板，通过本体库而形成的知识库不仅层次结构较强，并且冗余程度较小。
4.知识图谱的关键技术 【其实，知识图谱的知识指的是数据(一般指文本数据)，而不是指传统的知识含义】
大规模知识库的构建与应用需要多种智能信息处理技术的支持。主要是NLP技术。
关键的一些技术和步骤：
知识抽取：知识抽取技术，可以从一些公开的半结构化、非结构化的数据中提取出实体、关系、属性等知识要素。知识抽取主要包含实体抽取、关系抽取、属性抽取等，涉及到的 NLP 技术有命名实体识别、句法依存、实体关系识别等。
知识表示：基于三元组的知识表示形式受到了人们广泛的认可，但是其在计算效率、数据稀疏性等方面却面临着诸多问题。近年来，以深度学习为代表的表示学习技术取得了重要的进展，可以将实体的语义信息表示为稠密低维实值向量，进而在低维空间中高效计算实体、关系及其之间的复杂语义关联。知识表示学习主要包含的 NLP 技术有语义相似度计算、复杂关系模型，知识代表模型如距离模型、双线性模型、神经张量模型、矩阵分解模型、翻译模型等。
知识融合：由于知识图谱中的知识来源广泛，存在知识质量良莠不齐、来自不同数据源的知识重复、知识间的关联不够明确等问题，所以必须要进行知识的融合。知识融合是高层次的知识组织，使来自不同知识源的知识在同一框架规范下进行异构数据整合、消歧、加工、推理验证、更新等步骤，达到数据、信息、方法、经验以及人的思想的融合，形成高质量的知识库。在知识融合过程中，实体对齐、知识加工是两个重要的过程。
知识推理：知识推理则是在已有的知识库基础上进一步挖掘隐含的知识，从而丰富、扩展知识库。在推理的过程中，往往需要关联规则的支持。由于实体、实体属性以及关系的多样性，人们很难穷举所有的推理规则，一些较为复杂的推理规则往往是手动总结的。对于推理规则的挖掘，主要还是依赖于实体以及关系间的丰富情况。知识推理的对象可以是实体、实体的属性、实体间的关系、本体库中概念的层次结构等。知识推理方法主要可分为基于逻辑的推理与基于图的推理两种类别。
5.大规模开发知识库 【可以认为这是一个模型，或者一堆建立了关联关系的数据，可以直接拿来使用】
中文知识图谱资源：
OpenKG.CN：中文开放知识图谱联盟旨在通过建设开放的社区来促进中文知识图谱数据的开放与互联，促进中文知识图谱工具的标准化和技术普及。Zhishi.me ：Zhishi.me 是中文常识知识图谱。主要通过从开放的百科数据中抽取结构化数据，已融合了百度百科，互动百科以及维基百科中的中文数据。CN-DBPeidia：CN-DBpedia 是由复旦大学知识工场实验室研发并维护的大规模通用领域结构化百科。cnSchema.org: cnSchema.org 是一个基于社区维护的开放的知识图谱 Schema 标准。cnSchema 的词汇集包括了上千种概念分类、数据类型、属性和关系等常用概念定义，以支持知识图谱数据的通用性、复用性和流动性。 6.Neo4j初识： 知识图谱是一种基于图的数据结构，由节点和边组成。其中节点即实体，由一个全局唯一的 ID 标示，关系（也称属性）用于连接两个节点。通俗地讲，知识图谱就是把所有不同种类的信息连接在一起而得到一个关系网络，提供了从“关系”的角度去分析问题的能力。
6.1 Neo4j的优势 数据存储：不像传统数据库整条记录来存储数据，Neo4j 以图的结构存储，可以存储图的节点、属性和边。属性、节点都是分开存储的，属性与节点的关系构成边，这将大大有助于提高数据库的性能。数据读写：在 Neo4j 中，存储节点时使用了 Index-free Adjacency 技术，即每个节点都有指向其邻居节点的指针，可以让我们在时间复杂度为 O(1) 的情况下找到邻居节点。另外，按照官方的说法，在 Neo4j 中边是最重要的，是 First-class Entities，所以单独存储，更有利于在图遍历时提高速度，也可以很方便地以任何方向进行遍历。 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e69c8aeeec5488c8b46221bb7fbc55cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf1e33bdf044803a349ad07e9a99bb5/" rel="bookmark">
			使用PyG进行图神经网络的节点分类、链路预测和异常检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图神经网络(Graph Neural Networks)是一种针对图结构数据(如社交图、网络安全网络或分子表示)设计的机器学习算法。它在过去几年里发展迅速，被用于许多不同的应用程序。在这篇文章中我们将回顾GNN的基础知识，然后使用Pytorch Geometric解决一些常见的主要问题，并讨论一些算法和代码的细节。
常见的图神经网络应用 GNN可以用来解决各种与图相关的机器学习问题:
节点的分类：预测节点的类别或标签。例如，在网络安全中检测网络中的欺诈实体可能是一个节点分类问题。
链接预测：预测节点之间是否存在潜在的链接(边)。例如，社交网络服务根据网络数据建议可能的朋友联系。
图分类：将图形本身划分为不同的类别。比如通过观察一个化合物的图结构来确定它是有毒的还是无毒的。
社区检测：将节点划分为集群。比如在社交图中寻找不同的社区。
异常检测：以无监督的方式在图中查找离群节点。如果没有标签，可以使用这种方法。
在这篇文章中，我们将回顾节点分类、链接预测和异常检测的相关知识和用Pytorch Geometric代码实现这三个算法。
图卷积 图神经网络在过去的几年里发展迅速，并且有许多的变体。在这些GNN变体中图卷积网络可能是最流行和最基本的算法。在本节中我们将对其进行回顾和介绍。
图卷积是一种基于图结构提取/汇总节点信息的有效方法。它是卷积神经网络卷积运算的一个变体，卷积神经网络通常用于解决图像问题。
在图像中，像素在网格中按结构排序，卷积操作中的过滤器或卷积核(权重矩阵)以预先确定的步幅在图像上滑动。像素的邻域由过滤器大小决定(下图中过滤器大小为3 x 3，蓝色过滤器中的8个灰色像素为邻域)，过滤器中的加权像素值被聚合为单个值。卷积运算的输出比输入图像的尺寸小，但对输入图像有更高层次的视图，这对预测图像问题很有用，比如图像分类。
在图中，节点以非结构化的方式排序，节点之间的邻域大小不同。图卷积取给定节点(下图中的红色节点)及其邻居(蓝圈内的灰色节点)的节点特征的平均值，计算更新后的节点表示值。通过这种卷积操作，节点表示捕获局部的图信息。
下图显示了更多关于图卷积操作的细节。邻居节点(蓝色)的节点特征和目标节点(红色)的节点特征被平均。然后与权重向量(W)相乘，其输出更新目标节点的节点特征(更新后的节点值也称为节点嵌入)。
对于那些相关的节点，节点特征使用度矩阵的逆进行归一化，然后再聚合而不是简单的平均（原始论文公式8中提出）
这个卷积操作中需要注意的一点是，图卷积的数量决定了节点特征被聚合到每个节点的步数。在下图中，第一个卷积将蓝色节点的特征聚合到橙色节点中，第二个卷积将绿色节点的特征合并到橙色节点中。
可以看到卷积的数量决定了聚合的节点特征有多远
在接下来的几节中，我们实现GCN。但是在深入研究它们之前，先熟悉一下将要使用的数据集。
Cora - 基准数据集 Cora数据集是一个论文引用网络数据，包含2708篇科学论文。图中的每个节点代表一篇论文，如果一篇论文引用另一篇论文，则有节点间有一条边相连。
我们使用PyG (Pytorch Geometric)来实现GCN, GCN是GNN的流行库之一。Cora数据集也可以使用PyG模块加载:
from torch_geometric.datasets import Planetoid dataset = Planetoid(root='/tmp/Cora', name='Cora') graph = dataset[0] Cora数据集来源于Pytorch Geometric的“Automating the Construction of Internet Portals with Machine Learning”论文。
节点特征和边缘信息如下所示。节点特征是 1433 个词向量，表示每个出版物中的词不存在 (0) 或存在 (1)。边在邻接列表中表示。
每个节点都是七个类别中的一个，这将就是分类的目标标签
利用NetworkX库可以实现图数据的可视化。节点颜色代表不同的类。
import random from torch_geometric.utils import to_networkx import networkx as nx def convert_to_networkx(graph, n_sample=None): g = to_networkx(graph, node_attrs=["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bf1e33bdf044803a349ad07e9a99bb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2aa497bbb232f19837f2657f0a9e436/" rel="bookmark">
			tensorflow2.0 mnist手写数字识别 并验证几张图片以查看效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的： tensorflow2.0+mnist已经算是ML界的“HELLO WORLD”了吧。网络上这方面的内容也比较多，可是有很多教程都是讲到训练完成就结束，如果只从数据上看准确率，对我们的主观感受不深。这里讲一下如何拿一张图片验证一下，以便直观感受。
环境：miniconda下tensorflow2.0 1、以下为训练： import tensorflow as tf import pandas as pd import matplotlib.pyplot as plt %matplotlib inline import image import numpy as np data = tf.keras.datasets.mnist (x_train,y_train),(x_test,y_test) = data.load_data() x_train,x_test = x_train/255.0,x_test/255.0 #print(x_train.shape) #plt.imshow(y_train[0]) #print(x_train[0]) #y_test[0] model = tf.keras.models.Sequential() model.add(tf.keras.layers.Flatten(input_shape=(28,28))) model.add(tf.keras.layers.Dense(128, activation="relu")) model.add(tf.keras.layers.Dropout(0.2)) model.add(tf.keras.layers.Dense(10)) loss_fn = loss_fn = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True) model.compile( optimizer="adam", loss=loss_fn, metrics=['accuracy'] ) model.fit(x_train,y_train,epochs=5) 2、以下为验证： 1、需要注意的是model.predict()输入参数应该是一个2维1列的矩阵。
2、这样做的好处是可以一次输入多个待验证数据，一并取得答案。
3、
而图片为28*28的矩阵，取其中一个：
img1_ = x_test[INDEX]
将矩阵展开成1维数组：
img1_ = img1_.flatten()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2aa497bbb232f19837f2657f0a9e436/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7995500ca85f3057631916f94d052aa/" rel="bookmark">
			嵌入式作业使用STM32的SPI实现OLED屏显
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.什么是SPI接口
二.使用OLED显示屏显示数据
三.自行修改程序实现显示学号和姓名
1.姓名学号的点阵 2. 实现显示代码
3.输入点阵代码
4.主函数设置
5.烧录
6.结果
四.自行修改程序实现显示温度和湿度
1.主函数修改
2.新建bsp_i2c.c
3.烧录 4.结果
五.自行修改程序实现长字符显示
烧录
​编辑
结果
六.总结
七.参考资料
前言
软件版本: STM32CubeMX:6.61
KEIl:5.61
mcusip
取字模软件
硬件: STM32F103C8T6 ASAIR温湿度传感器 OLED显示屏
一.什么是SPI接口 SPI 是英语Serial Peripheral interface的缩写，顾名思义就是串行外围设备接口。是Motorola首先在其MC68HCXX系列处理器上定义的。
SPI，是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便，主要应用在 EEPROM，FLASH，实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间。
SPI接口框图：
SPI内部结构简明图：
SPI接口一般使用4条线通信：
MISO 主设备数据输入，从设备数据输出。
MOSI 主设备数据输出，从设备数据输入。
SCLK时钟信号，由主设备产生。
CS从设备片选信号，由主设备控制。
SPI工作原理总结：
1、硬件上为4根线。
2、主机和从机都有一个串行移位寄存器，主机通过向它的SPI串行寄存器写入一个字节来发起一次传输。
3、串行移位寄存器通过MOSI信号线将字节传送给从机，从机也将自己的串行移位寄存器中的内容通过MISO信号线返回给主机。这样，两个移位寄存器中的内容就被交换。
4、外设的写操作和读操作是同步完成的。如果只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。
二.使用OLED显示屏显示数据 实验工具与材料
软件：keil
硬件：PC机，STM32开发板（本过程采用的是野火stm32mini开发板），0.96寸OLED显示屏，下载器（本过程采用ST_Link）0.96寸OLED显示屏相关介绍
参考下面链接：0.96inch SPI OLED Module - LCD wiki运行厂家给出的Demo程序
①下载程序
程序下载链接：http://www.lcdwiki.com/res/Program/OLED/0.96inch/SPI_SSD1306_MSP096X_V1.0/0.96inch_SPI_OLED_Module_SSD1306_MSP096X_V1.0.zip ②打开资料包，选择与自己平台相同的实例，打开Demo的工程，使用keil编译
③将程序烧录到开发板
④连接显示屏和开发板 三.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7995500ca85f3057631916f94d052aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eacb2f99d7b5ebdb3844123e30e02dd0/" rel="bookmark">
			c语言函数的调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数 一、函数的调用机制（一）、调用机制：程序员调用方法，方法给程序员返回结果（二）、函数调用规则举例：判断函数调用是否正确。 二、函数的递归调用（一）、递归调用：一个函数在函数体内又调用了本身。（二）、函数递归需要遵守的重要原则递归练习题1.斐波那契数2.求函数值3.猴子吃桃问题 三、函数注意事项和细节讨论习题请编写一个函数swap(int *nl, int*n2)可以交换nl 和 n2的值。 一、函数的调用机制 （一）、调用机制：程序员调用方法，方法给程序员返回结果 举例：
（1）传入一个数+1 test函数
//第一题 #include&lt;stdio.h&gt; int test(int n1){ int sum = n1 + 1; printf("sum = %d",sum); return 0; } void main(){ int n2=6; test(n2); } （2）计算2个数并返回 getSum函数
//第二题 #include&lt;stdio.h&gt; int getSum(int n1,int n2){ return n1+n2; } void main(){ int res=getSum(1,9);//传入1 和 9 printf("\nres = %d",res);// res = 10 } （二）、函数调用规则 1.当调用(执行)一个函数时，就会开辟一个独立的空间(栈)。
2.每个栈空间是相互独立。
3.当函数执行完毕后，会返回到调用函数位置，继续执行。
4如果函数有返回值，则将返回值赋给接收的变量。
5.当一个函数返回后，该函数对应的栈空间也就销毁。
举例：判断函数调用是否正确。 案例1
char* getSum(int num1,int num2){ int res = num1 + num2; retuen res; } 错误原因是类型不匹配(char* 到 int)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eacb2f99d7b5ebdb3844123e30e02dd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63cb2a6c453ecaf82ff088687e5b5e29/" rel="bookmark">
			安装并配置 cz-customizable 插件遇到报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 npm 下载 cz-customizable
npm i cz-customizable@6.3.0 --save-dev
报错信息如下：
npm ERR! code ERESOLVE npm ERR! ERESOLVE could not resolve npm ERR! npm ERR! While resolving: @vue/eslint-config-standard@6.1.0 npm ERR! Found: eslint-plugin-vue@8.7.1 npm ERR! node_modules/eslint-plugin-vue npm ERR! dev eslint-plugin-vue@"^8.0.3" from the root project npm ERR! npm ERR! node_modules/@vue/eslint-config-standard npm ERR! dev @vue/eslint-config-standard@"^6.1.0" from the root project npm ERR! npm ERR! Conflicting peer dependency: eslint-plugin-vue@7.20.0 npm ERR! node_modules/eslint-plugin-vue npm ERR! peer eslint-plugin-vue@"^7.0.0" from @vue/eslint-config-standard@6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63cb2a6c453ecaf82ff088687e5b5e29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/431af0bfa2df4e3a24e9d577b720e43c/" rel="bookmark">
			四、模块化编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模块化编程 视频链接(51单片机)[https://www.bilibili.com/video/BV1Mb411e7re/?spm_id_from=333.337.search-card.all.click]
P13-P14
传统编程和模块化编程：
传统方式编程：所有的函数均放在main.c里，若使用的模块比较多，则一个文件内会有很多的代码，不利于代码的组织和管理，而且很影响编程者的思路
模块化编程：把各个模块的代码放在不同的.c文件里，在.h文件里提供外部可调用函数的声明，其它.c文件想使用其中的代码时，只需要#include "XXX.h"文件即可。使用模块化编程可极大的提高代码的可阅读性、可维护性、可移植性等
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-l0mqTb85-1667297617952)(upload%5Cimage-20221101002205299.png)]
C语言的预编译 C语言的预编译以#开头，作用是在真正的编译开始之前，对代码做一些处理（预编译）
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ClD5SawH-1667297617953)(upload%5Cimage-20221101002409085.png)]
此外还有#ifdef,#if,#else,#elif,undef等
#ifdef AAA ADADAD #endif 如果定义了AAA，ADADAD才参与编译 如果没有定义，则ADADAD不参与编译 ------ define AAA #ifdef AAA ADADAD #endif 模块化编程需要注意的事项 .c文件：函数、变量的定义
.h文件：可被外部调用的函数、变量的声明
任何自定义的变量、函数在调用前必须有定义或声明（同一个.c）
使用到的自定义函数的.c文件必须添加到工程参与编译
使用到的.h文件必须要放在编译器可寻找到的地方（工程文件夹根目录、安装目录、自定义）
在单片机中模块化编程非常重要，在模块化编程时，一般需要定义两个.h和.c文件。只有这样在main.c函数当中新定义的函数模块才可以进行调用。以Delay延时函数为例：
Delay.h文件定义 #ifndef _DELAY_H_ //在定义函数时一般使用大写，并且函数名要与.h用下划线隔开 //含义：如果没有定义_DELAY_H_,就预编译下面的内容 #define _DELAY_H_ //参与预编译之后，就定义_DELAY_H_ //只会编译一次，防止重复定义导致出错 //通俗理解就是这块代码让定义只运行一次 //中间放置要定义的函数 #endif //以下是实例中Delay.h文件的内容 /* #ifndef __DELAY_H__ // #define __DELAY_H__ void Delay(unsigned int xms//函数声明 #endif */ Delay.c文件定义 //首先要定义一个函数.c文件 在定义之后要将函数代入函数.c文件当中 //例如delay() void delay() { //写入内容 } //以下是实例中Delay.c文件的内容 /* void Delay()	//@12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/431af0bfa2df4e3a24e9d577b720e43c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/029ff05b46b2117c065a54bd1f88d800/" rel="bookmark">
			Python作业七记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义一个学生student类，有下面的实例属性：
姓名：name
年龄：age
成绩 score包含语文，数学，英语三门课的成绩，每课成绩的类型为整数
该类的实例方法：
获取学生的姓名：get_name()，返回类型:str
获取学生的年龄：get_age()，返回类型:int
返回3门科目中最高的分数：get_course()，返回类型:int
编写student类的测试程序。
输入格式: 第1行输入姓名字符串
第2行输入年龄
第3行输入逗号分割的三个成绩
输出格式: 分3行输出，第1行输出姓名，第2行输出年龄，第3行输出最高分
class Student(): def __init__(self,name,age,*score): self.name = name self.age = age self.score = score def get_name(self): print(self.name) def get_age(self): print(self.age) def get_course(self): print(max(max(self.score))) if __name__ == '__main__': name = input() age = int(input()) score = list(map(int,input().split(","))) student = Student(name,age,score) student.get_name() student.get_age() student.get_course() 定义一个字典类：dictclass，实例属性为一个字典，包含的实例方法如下：
1）删除某个key
del_dict(key)
2）判断某个键是否在字典里，如果在返回键对应的值，不存在则返回"not found"
get_dict(key)
3）返回键组成的列表：返回类型;(list)
get_key()
4）合并字典，并且返回合并后字典的values组成的列表。返回类型:(list)
update_dict({要合并的字典})
{'姓名': '张三', '性别': '男'}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/029ff05b46b2117c065a54bd1f88d800/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a35b462fc07f2c996be69d473854965b/" rel="bookmark">
			【正点原子STM32连载】 第六十章 USB鼠标键盘(Host)实验 摘自【正点原子】MiniPro STM32H750 开发指南_V1.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）实验平台：正点原子MiniPro H750开发板
2）平台购买地址：https://detail.tmall.com/item.htm?id=677017430560
3）全套实验源码+手册+视频下载地址：http://www.openedv.com/thread-336836-1-1.html
4）对正点原子STM32感兴趣的同学可以加群讨论：879133275
第六十章 USB鼠标键盘(Host)实验 本章我们介绍如何使用STM32H750的USB HOST来驱动USB鼠标/键盘。
本章分为如下几个小节：
60.1 USB鼠标键盘简介
60.2 硬件设计
60.3 程序设计
60.4 下载验证
60.1 USB鼠标键盘简介 传统的鼠标和键盘是采用PS/2接口和电脑通信的，但是现在PS/2接口在电脑上逐渐消失，所以现在越来越多的鼠标键盘采用的是USB接口，而不是PS/2接口的了。
USB鼠标键盘属于USB HID设备。USB HID即：Human Interface Device（人机交互设备）的缩写，键盘、鼠标与游戏杆等都属于此类设备。不过HID设备并不一定要有人机接口，只要符合HID类别规范的设备都是HID设备。关于USB HID的知识，我们这里就不详细介绍了，请大家自行百度学习。
本章，我们同上一章一样，我们直接移植官方的USB HID例程，官方例程路径：光盘8，STM32参考资料 1，STM32CubeH7固件包 STM32Cube_FW_H7_V1.6.0Projects
STM32H743I-EVALApplicationsUSB_HostHID_Standalone，该例程支持USB鼠标和键盘等USB HID设备，本章我们将移植这个例程到我们的开发板上。
60.2 硬件设计 例程功能
本实验代码，开机的时候先显示一些提示信息，然后初始化USB HOST，并不断轮询。当检测到USB鼠标/键盘的插入后，显示设备类型，并显示设备输入数据：
如果是USB鼠标：将显示鼠标移动的坐标（X，Y坐标），滚轮滚动数值（Z坐标）以及按键（左中右）。
如果是USB键盘：将显示键盘输入的数字/字母等内容（不是所有按键都支持，部分按键没有做解码支持，比如F1~F12）。硬件资源
1）RGB灯
RED ：LED0 - PB4
GREEN ：LED1 - PE6
2）串口1(PA9/PA10连接在板载USB转串口芯片CH340上面)
3）正点原子2.8/3.5/4.3/7/10寸TFTLCD模块(仅限MCU屏，16位8080并口驱动)
4）USB_HOST接口(D-/D+连接在PA11/PA12上)
60.3 程序设计
60.3.1 程序流程图
图60.3.1.1 USB鼠标键盘实验(Host)程序流程图
60.3.2 程序解析
这里我们只讲解核心代码，详细的源码请大家参考光盘本实验对应源码。
本实验，我们在上一个实验的基础上修改，对照官方HID例子，然后，我们在工程里面添加USB HID相关代码，如图60.3.2.1所示：
图60.3.2.1 USB鼠标键盘工程分组
可以看到，USB部分代码，同上一章的在结构上是一模一样的，只是.c文件有些变化。我们重点介绍下USB_HOST里面的usbh_hid_mouse.c这个文件，该文件拷贝自ST官方例程，但是ST官方例程对鼠标的支持不好（兼容性差，不支持滚轮等），我们重写了该文件，下面介绍该文件。
USB驱动代码
usbh_hid_mouse.h，首先介绍usbh_hid_mouse.h里面定义的一个结构体，具体如下： /* 鼠标信息结构体*/ typedef struct _HID_MOUSE_Info { uint8_t x; /* x轴增量（强制转换成signed char后使用）*/ uint8_t y; /* y轴增量（强制转换成signed char后使用）*/ uint8_t z; /* z轴增量（强制转换成signed char后使用）*/ uint8_t button; /* 将buttons修改为button,存储按键状态 */ } HID_MOUSE_Info_TypeDef; HID_MOUSE_Info_TypeDef结构体中，成员x和y表示鼠标的横向/纵向移动的增量值，成员z表示鼠标的滚轮的滚动增量值，在使用的时候，需要强制转换成unsigned char类型后使用（有±）。button的bit0、bit1、bit2分别表示鼠标的：左键、右键和滚轮键的按下状态。我们通过这个结构体，就可以获得当前鼠标的输入状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a35b462fc07f2c996be69d473854965b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f482d833341d356d373f1d0e8fdf6fec/" rel="bookmark">
			深度学习 pytorch手写数字识别 MNIST数据集 解析&#43;详细注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 模型构建2 训练 train.py3 测试 eval.py4 工程文件、数据集、源码下载 文件结构 ①存放训练之后导出的模型； ②存放数据集； 1 模型构建 神经网络由对数据进行操作的层/模块(layers/modules)组成。torch.nn提供构建网络的所有blocks,
在PyTorch中的每个modules都继承了nn.Module,可以构建各种复杂的网络结构。
通过nn.Module定义神经网络，使用init初始化,对数据的所有操作都在forward()中实现
import torch import torch.nn as nn # 1 创建网络模型 model.py # 卷积神经网络（两个卷积层） class ConvNet(nn.Module): # nn,neural network def __init__(self, num_classes=10): #0~9种类别 super(ConvNet, self).__init__() self.layer1 = nn.Sequential( nn.Conv2d(1, 16, kernel_size=5, stride=1, padding=2), #输出尺寸：(n+2p-f)/s +1 = (28+4-5)/1 + 1 = 28,输入28输出还是28 ,1*28*28 nn.BatchNorm2d(16), # 输出通道16,16*28*28 nn.ReLU(), nn.MaxPool2d(kernel_size=2, stride=2)) #最大池化，做下采样，f=2,s=2相当于图像减半 #图片变模糊，保留原图片的特征，让训练参数减少。 #16*14*14 self.layer2 = nn.Sequential( nn.Conv2d(16, 32, kernel_size=5, stride=1, padding=2), #输入16通道，输出32通道 nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f482d833341d356d373f1d0e8fdf6fec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c01a58a7c8d9430174fe7542af852c55/" rel="bookmark">
			ssh: Could not resolve hostname d: Name or service not known
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ssh: Could not resolve hostname d: Name or service not known
Windows下载Linux服务器文件，除了使用XShell中Xftp或者winscp等其他图形化界面软件外，还可使用类似Openssh for Windows.但是使用过的同学一定出现过“ssh: Could not resolve hostname d: Name or service not known”的报错。其实网上有很多解决方案，但是小编我看过后发现基本都无法彻底解决。今天就给大家分享一下我处理的过程。
一、首先安装Openssh for Windows；
1-1 如果本机是Windows系统，想从Linux系统下载文件到本机，那么执行 scp linux_user@linux_ip:/linux文件位置 windows本机位置
1-2 如果本机是windows系统，想将本机文件上传至Linux服务器，那么执行 scp windows文件位置 linux_user@linux_ip:/linux文件位置
二、根据实际情况执行完毕后，输入相应linux用户密码。
三、重点就是linux中路径使用“/”,而windows是用“\”。那么1-1中的“windows本机位置”应该怎么书写？其实小编试过很多种方法，比如
：/d:/ 😕/d:/ :\d\等，但是最终的报错要么是找不到路径，要么是提示这是一个目录，要么就是ssh: Could not resolve hostname d: Name or service not known的报错。经过小编两天的研究，最终百度了很多文章，都说是hosts的问题。但是这个款操作系统的SCP指令，小编认为和hosts无关.
最终经过小编不懈研究，终于找出解决方案
解决方案：
Openssh安装路径为 D:\Program Files\OpenSSH，打开后可以看到“home”文件夹。可以在home文件夹中建立自己的下载文件夹，比如Downloads，那么1-1中的SCP指令就可以这样写：
scp linux_user@linux_ip:/linux文件位置 home/Downloads
例如：
scp -r zj@192.168.1.199:/media/bak/myself/GD/Oracle_11g_11.2.0.1.0 /home/Downloads
备注：其实安装Openssh后，安装目录产生的home文件夹就等同于linux系统中的/home,只是在windows中换了一种方式而已！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be5e7b12de5abbd4ad106e0e0810e73a/" rel="bookmark">
			基于servlet的分页查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.页面 &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt; &lt;!-- 网页使用的语言 --&gt; &lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;用户信息管理系统&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href="${pageContext.request.contextPath}/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src="${pageContext.request.contextPath}/js/jquery-2.1.0.min.js"&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src="${pageContext.request.contextPath}/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;style&gt; td, th { text-align: center; } span { font-size: 15px; } #page { text-align: center; } .inp{ margin-bottom: 30px; margin-top: 40px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be5e7b12de5abbd4ad106e0e0810e73a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d1a90fabbfcd9888769b6c23114b17c/" rel="bookmark">
			Mac如何管理（添加,删除, 排序,移动）顶部菜单状态栏图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移除图标 Mac电脑中右上角菜单栏中会有很多图标，这些图标让菜单栏看上去很多乱，其实我们可以自定义这些菜单栏中的图标，比如添加、移动、排序、删除等，下面分享在Mac电脑中自定义菜单栏图标的操作步骤：
右上角的状态菜单上可以看到Mac的状态和一些系统应用
如果要重新排列状态菜单栏上的图标，按住Command键，然后拖动就可以，但是最右边的“通知中心”是不能被拖动的
如果要删除也是可以的，按住Command键把图标拖出菜单栏，等到鼠标下面出现删除图标的时候松开鼠标, 如果你有开启声音, 你会听到咻的一声, 表示图标被删除(有些第三方软件图标该方法可能不会被移除,你可以在该第三方软件的设置中找得类似 显示在菜单栏中的选项, 取消勾选即可)
如果拖动的时候下面显示的是禁止符号，那么该应用图标就是不可被删除的
排序图标 先按住 Command (⌘) 不放将你的鼠标移到要移动图标之上此时同时按下左键不放拖动你的图标到你喜欢的位置, 其他图标会向旁边移动为其腾出空间确定好位置后, 放开鼠标左键即完成了排序 添加图标 系统图标被删除那么要添加回来也很简单. 只不过不同系统图标添加的路径会有不同. 以添加电量图标为例, 先点击mac的顶部菜单栏中最左边的苹果图标,然后选择 系统偏好设置 -&gt; 节能, 出现如下图：
勾选如下图所示的在菜单栏中显示电池状态的选项, 此时菜单栏就会显示电池电量图标.。
同样的, 其他系统图标的操作路径如下: (以下的大提前路径都在系统偏好设置底下,故下面省略这个前缀)
声音,蓝牙, siri, 时间机器, 辅助功能: 这些功能都在系统偏好设置下的对应同名设置面板中
输入法: 键盘-&gt; 输入法-&gt;在菜单栏中显示输入法菜单
电池电量: 节能-&gt;电池-&gt;在菜单栏中显示电池状态
WiFi: 网络-&gt;wifi-&gt; 在菜单栏中显示wifi状态
用户与群组: 用户与群组-&gt;登录选项 -&gt; 将快速用户切换菜单显示为
时间: 日期与时间-&gt; 时钟 -&gt; 在菜单栏中显示日期与时间
显示器镜像选项: 显示-&gt; 显示器-&gt; 在菜单中显示镜像选项(可用时)
另外的一些系统图标 由于某些原因，系统有些功能图标是隐藏的。如果你感兴趣, 可以访问下面的文件夹。
要添加某个功能图标, 双击即可。
打开访达, 从菜单栏中选择前往-&gt; 前往文件 -&gt; 然后输入/System/Library/CoreServices/Menu Extras路径回车, 该系统文件夹列举了所有的集合, 可能很多你都看不懂, 不过你可以选择你看得懂以及需要的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6ae9e911efbb362c4e5b669490dd031/" rel="bookmark">
			K210学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k210学习笔记 1、初始化问题 如图卡在了例程的第一行代码
sensor表示对摄像头进行操作的代码
检查摄像头是否连接好
确认连接无误后还是报错，建议换个摄像头试试
2版本不支持问题 忘记截图了
报错为
ValueError:[MAIXPY]kpu: load error:2002, ERR_KMODEL_VERSION: onlysupport kmodel V3/V4 now
使用·例程人脸识别模型时
下载站中有两个地址的固件
而github上的地址是0x300000的代码
下载0x600000固件后，单纯讲代码中的0x300000全部改掉也还是无法运行
会出现如上报错
所以还是使用旧版固件配合代码无需修改地址，直接烧录可以成功使用
3使用SD卡 代码存进SD卡记得把.py结尾的文件改名为main.py
才会自动执行（不过好像没试过不命名为main会怎么样）
SD卡和IDE里都有程序时,优先执行IDE里的代码
使用神经网络 图片要准备至少50张
达到数量才会出现做标记的按键
记得用快捷键（标注保存翻页都有快捷键）
不需要用到鼠标！毕竟！50张以上的数目呢
最后成功后，直接把训练好之后网站生成的一大堆
代码+kmodel+json文件全部扔进SD卡里
无需烧录固件了
即插即用，very方便
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e9835acc45f305cb3dfacbc4deb84ef/" rel="bookmark">
			uniapp H5 跳转应用外页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在uniapp中页面路由分为以下几种：
navigateTo 保留当前页面 跳转到应用内某个页面navigateBack 关闭当前页面 返回上一页面redirectTo 关闭当前页面 跳转到应用内某个页面relaunch 关闭所有页面 打开应用内某个页面switchTab 跳转到底部tabbar页面 关闭非tabbar页面 当我们在开发中遇到跳转外部链接时，以上方式就不能满足了。今天在开发中就遇到了，在官方文档上看到了web-view，需要新建组件，然后在页面中引入在使用uni.navigateTo来实现页面跳转，感觉有点麻烦，就没采用。最终使用window.location.href来实现的。
需求是在H5中 循环列表绑定点击事件，分别跳转不同的外部链接，链接是后端提供的接口中有字段。接下来就看下代码：
&lt;view v-for="(item,index) in footLink" :key="item.id" class="footer-item" @click="link(item)"&gt; &lt;image :src="item.iconAddress" /&gt; &lt;/view&gt; &lt;script&gt; export default { data() { return { } }, methods:{ link(item){ let linkUrl = item.linkUrl; // #ifdef H5 window.location.href = linkUrl // #endif }, } }; &lt;/script&gt; 这样就可以实现了跳转外部链接了。
从app内跳转到浏览器 linkClick(){ setTimeout(function(){ plus.runtime.openURL('http://www.baidu.com'); },1000) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48543a4056f7eda5a0c87ea56012f360/" rel="bookmark">
			vue开发过程中完成对函数的封装和调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 export跟export default 有什么区别呢？
1、export与export default均可用于导出常量、函数、文件、模块等
2、你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用
3、在一个文件或模块中，export、import可以有多个，export default仅有一个
4、通过export方式导出，在导入时要加{ }，export default则不需要
通过export方式导出，在导入时要加{ }，export default则不需要。使用export default命令，为模块指定默认输出
在js文件中定义函数，利用export default暴露出去。再在需要使用的html文件中import该函数，后续使用。
一：新建api.js
let api={ set(){ console.log('set') }, get(){ console.log('get') }, post(){ console.log('post') } } export default api 二：在vue中引入
import api from ‘@/api.js’ //api.js的路径，这里是当前文件夹 三：在vue调用
created：function(){ api.get() } 第二种方法
一：新建一个login.js
export function (a,b){ } 二：在vue中调用
import {login} from '@/login.js' export default { methods: { login(a,b) } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56c185337a6975a75e702b1a4b571ede/" rel="bookmark">
			解决SpringBoot返回字符串乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在设置统一返回结构体时遇到了字符串乱码的问题，需要设置返回结构体的编码为utf-8,但是字符串需要特殊处理，新增全局配置如下
@Configuration public class MyMvcConfig implements WebMvcConfigurer { @Bean public HttpMessageConverter&lt;?&gt; responseBodyConverter() { StringHttpMessageConverter converter = new StringHttpMessageConverter(Charset.forName("UTF-8")); return converter; } @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { converters.add(responseBodyConverter()); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/072598dbd00f2daebc91247d0727fa85/" rel="bookmark">
			C&#43;&#43; vector中at的特殊用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、为什么在堆中声明vector二、堆中创建vector的一些操作总结 前言 对于STL容器大部分我们都直接在栈中声明，因为这样在语句块结束的时候，容器可以自动释放内存，但是有些情况下，不得以需要用new的方式创建容器，这时就有一些好玩的操作。
下面主要讲一下vector在堆中声明的用法。
一、为什么在堆中声明vector vector&lt;int&gt; s(3); vector&lt;vector&lt;int&gt;&gt; s(3, vector&lt;int&gt;(3)); 上面的代码片段是最常用的初始化方法，需要注意的是，我们初始化的元素个数是已知的，当元素个数未知的时候，需要动态分配内存。
vector&lt;int&gt; *s = new vecotr&lt;int&gt;(n); vector&lt;int&gt; s = *new vecotr&lt;int&gt;(n); 第二种初始化方法是比较好玩的一种方法，这种情况可以让堆中初始化的vector像对象一样操作。
二、堆中创建vector的一些操作 在栈中声明的vector是一个对象，可以直接使用 []下标运算符，在堆中创建的对象，返回的是一个指针，我们需要使用 -&gt; 调用对象的函数，所以不能直接使用下标运算符。
vector&lt;int&gt; *s1 = new vecotr&lt;int&gt;(n, 10); vector&lt;vector&lt;int&gt;&gt; *s2 = new vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n, 10)); 以上面初始化代码为例，指针指向的类型是new运算符后面的类型，只能使用at的方式获取vector对象中的数据。下面是使用的例子：
int a = s1-&gt;at(3); int b = s2-&gt;at(3)[3]; 总结 当然，vector实际上就是数组，数组实际上就是二级指针，完全可以用下面的方式代替vector，但是可能会丧失vector提供的函数功能，酌情使用吧。
int** s = new int*[10]; for(int i = 0; i &lt; 10; ++i){ s[i] = new int[10]; } for(int i = 0; i &lt; 10; ++i){ for(int j = 0; j &lt; 10; ++j){ s[i][j] = 10; } } cout &lt;&lt; s[1][1]; for(int i = 0; i &lt; 10; ++i){ delete [] s[i]; } delete [] s; 动态分配的内存用完记得释放！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4407ab380c20ae4171a106b2201d894/" rel="bookmark">
			记录：换路由器群晖 nas无法登录的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 昨天换路由器（tplink 1200M 换成 水星千兆的）
由于两种路由器默认都是192.168.0.xxx，所以我以为不需要先去dsm里修改网络设置，自动分配nas的ip。
问题：ip:5000无法登录
情况：更换路由器后，从路由器控制页上看是一切正常，但是nas lan ip，从原先的101换到了102，我以为只需要改一下ip:5000就可以了。
但是drive是正常同步的。
之后我一通搜索发现网上主要有三种方案：
路由器不在同一网段，换回原来路由器，登录dms更改固定ip，按新路由器设置好，再接新路由器。——但是我这俩是一样的呀！我想了一下，直接用quickconnect登录dms，在里面按照说法，改了一下ip，改成了102。之后我就懵逼了，再也找不到nas了。nas离线状态下，网线直接连接pc和nas，用synology assistant 搜索得到nas，且显示联机失败的情况下，用设置导向。——我第一次试了一下，导向显示nas ip 已经不是熟悉的192.168了，而是一个169.254（注意这个ip，确实和资料说得一样，和路由器不同，但是这才是关键），我当时一脸懵逼，因为我不太懂网关（我以为要按照路由wan口设置）和ip等等，我瞎改了一下，使得nas ip直接变成了192.168.1.102，我以为应该可以了，结果完全不行。重置nas网络设置reset，管理员等等，非常麻烦，而且害怕文件没了。——没去试 前两种在我尝试之后，并没有解决问题。而且第二种方法中还有很多的弯路，我就贴一下图，不浪费时间描述了
最后，解决方法：
nas不接路由器，pc无线接路由的情况下，进入计算机的网络，右击查看nas的ip，发现确实就是个169.254！！！
整了半天，无法登录dms。其实只要在计算机网络去看属性，但凡它连在网络结构里，属性中自然有它的设备网页。尝试点击，直接就进dms了！！！
登录dms，整不明白的都把网络编辑选择自动！！！
这一步其实可以不用，但是由于我不甘心让nas的lan ip就这么改了，因为我映射了好多网络文件夹和盘，感觉重新弄非常麻烦（其实想想它有名字，貌似不用改，不管了！！类似//nas/home），我尝试进入路由器管理，在ip与mac里把nas mac和101强行绑定了。
我害怕会不会又登录不了，赶紧在计算机网络nas属性里看了一下，设备ip和登录网页自动修改了。可以登录，我得寸进尺，再进入dms，编辑网络设置，把自动又改回了手动，把ip固定在101。
总结：
如果要换路由器，即使两台路由ip段是一样的，也会造成dms无法登录，需要设置的问题。——个人理解，可能是当nas脱离lan的时候，它自己会变回原有自带的ip，由于当初设置了手动分配，再连入的时候，并不能自动设置。（而且，我看了一下路由的dhcp，按照120分钟分配ip，我第一个接入新路由的是我的手机，分配了101，但是当120min过去了，也并没有根据设置重新把101给nas，我不确定是不能还是我已经把nas设置乱改了）所以建议，但凡要换路由器，不管是不是一个牌子，网段一不一样，换之前都进dms改成自动。找不到nas，别方，别冲上来按照网上方法狂改设置。先在计算机网络里看一下设备属性。。。。！！！！！！！要是再登录不了，再尝试修改。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18a8457afeb910a13d2b9ad41cf3db16/" rel="bookmark">
			Python量化初学者入门必备，如何入门Python量化交易？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 量化可以简单分为数据管理、策略分析和策略执行三个模块，数据是基础，策略分析是核心，其中策略自动化执行（算法交易）在国内由于政策限制实施起来比较麻烦。（文末送福利）
从Python的角度看，数据层往下分解，要学习的模块主要有Pandas、Numpy、tushare、pandas_datareader以及一些爬虫库等。策略层往下分解，要掌握的基础工具包括Pandas、matplotlib、scikit-learn、TA-lib、statsmodels等等。当然，在学习上述金融量化常用库前，系统的掌握Python编程基础是很有必要的。从策略的角度看，光会玩Python是远远不够的，必须有自己的策略思路和逻辑。
那么策略的灵感来自哪里？除了自身实践总结外，各种量化平台、论坛、博客和学术期刊可能会提供一定的借鉴参考。下面将围绕Python编程、数据源、量化平台、策略来源等方面分享相关的学习资源。
01 Python编程 1、搭建Python环境
（1）Anaconda ：
https://www.anaconda.com/
推荐使用。一直使用其自带的Jupyter Notebook来做策略分析和写公众号文章。
（2）Pycharm ：用的人也很多，但个人没用过。
2、入门学习 （1）廖雪峰官方网站：
https://www.liaoxuefeng.com/wiki/1016959663602400
（2）菜鸟教程：
https://www.runoob.com/python3/python3-basic-syntax.html
（3）GitHub项目：
https://github.com/goodchinas/pyquant
GitHub上的一个项目，notebook格式，从入门到numpy、pandas、matplot等各种库的降解和练习，非常适合新手入门。
3、高阶学习书籍 （1）Python for Finance，2014,Yves Hilpisch中文版：Python金融大数据分析，人民邮电出版社
（2）Mastering Python for Finance，2015，James Ma Weiming
（3）Personal Finance with Python，2018，Max Humber
（4）Python for Finance，2017，Yuxing Yan
（5）Derivatives Analytics with Python，2015，Yves Hilpisch
（6）QuantEcon Lectures，2019，Thomas J. Sargent and John Stachurski
（7）量化投资以Python为工具，2017，蔡立耑
（8）零起点Python大数据与量化交易，2017，何海群（9）量化交易之路用Python做股票量化分析，2017，阿布
02量化数据源 金融量化数据源主要有三种：一是大数据网站，通常都是收费的，一般只有日线级数据；二是专业金融数据公司，如通联，万德，收费价格高但比较稳定；三是开源数据模块库，如Tushare，pandas-datareader，ccxt数字货币等，github上还有很多不一一列举。
Python开源数据
（1）TuShare pro ：
中文财经数据接口包，有积分限制。
需注册获取token：
https://tushare.pro/register?reg=218422
（2）BaoStock ：
与tushare类似，主要提供国内股票行情数据、公司基本面和宏观数据
（3）Quandl :https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18a8457afeb910a13d2b9ad41cf3db16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/366aeec9c78cc99c602ebd7bcf0e0f94/" rel="bookmark">
			ubuntu22.04下Ethercat IGH DC同步实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.系统环境说明 主站系统：ubuntu22.04Igh版本：gitlab上的最新版本1.6.0，https://gitlab.com/etherlab.org/ethercat系统的实时内核：preempt-rt
该内核安装非常方便， 注册https://ubuntu.com/账号在个人账号的订阅下可以看到Token, 可以免费安装5台设备
https://ubuntu.com/pro/dashboard ua attach &lt;免费的TOEKN&gt; 确保你在使用至少 27.8 版本的 ubuntu-advantage-tools 软件包，可通过此命令查看当前版本： ua version 要在 Ubuntu 22.04 (Jammy Jellyfish) 中升级 ubuntu-advantage-tools 到 27.8，请运行命令：
sudo apt install ubuntu-advantage-tools=27.8~22.04.1 要启用测试版实时内核，可运行：
ua enable realtime-kernel --beta 需要验证实时性能，可以使用cyclitest,主要看max的值，经过14个小时时间，其最大值的延迟在230us左右，满足8ms为周期的控制
# 结果 sudo cyclictest -p 99 -S -i 8000 -m [sudo] lm 的密码： /dev/cpu_dma_latency set to 0us policy: fifo: loadavg: 10.26 9.47 9.38 7/1308 105547 T: 0 (91316) P:99 I:8000 C:6638053 Min: 2 Act: 73 Avg: 30 Max: 193 T: 1 (91317) P:99 I:8500 C:6247579 Min: 2 Act: 72 Avg: 27 Max: 166 T: 2 (91318) P:99 I:9000 C:5900491 Min: 3 Act: 74 Avg: 29 Max: 230 T: 3 (91319) P:99 I:9500 C:5589938 Min: 3 Act: 6 Avg: 28 Max: 155 # 压力：4核满负荷 lm@lm-X550JK:~$ stress-ng -c 4 --cpu-method fft --timerfd-freq 1000000 -t 24h stress-ng: info: [92633] setting to a 86400 second (1 day, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/366aeec9c78cc99c602ebd7bcf0e0f94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c244646566171d95224c3d0a4f2584d/" rel="bookmark">
			Could not resolve placeholder ‘jdbc.driver‘ in string value “${jdbc.driver}“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自:
Could not resolve placeholder &amp;#039;jdbc.driver&amp;#039; in string value &amp;quot;${jdbc.driver}&amp;quot;
下文讲述今天编译代码时，出现以下异常的处理方法分享，如下所示
这种异常一般都是配置文件编写错误导致的异常，我们只需修改配置文件，即可解决此异常
十二月 22, 2022 23:06:08 下午 org.apache.catalina.core.StandardContext listenerStart 严重: Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListener org.springframework.beans.factory.BeanDefinitionStoreException: Invalid bean definition with name 'dataSource' defined in file [D:\Test\target\classes\spring\applicationContext.xml]: Could not resolve placeholder 'jdbc.driver' in string value "${jdbc.driver}"; nested exception is java.lang.IllegalArgumentException: Could not resolve placeholder 'jdbc.driver' in string value "${jdbc.driver}" at org.springframework.beans.factory.config.PlaceholderConfigurerSupport.doProcessProperties(PlaceholderConfigurerSupport.java:211) at org.springframework.context.support.PropertySourcesPlaceholderConfigurer.processProperties(PropertySourcesPlaceholderConfigurer.java:177) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c244646566171d95224c3d0a4f2584d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f407556250482ce5baebff81299fc56c/" rel="bookmark">
			「设计模式」抽象工厂模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「设计模式」抽象工厂模式 文章目录 「设计模式」抽象工厂模式一、回顾简单工厂模式的优缺点工厂方法模式的优缺点 二、概念三、用途四、实现方式五、“开闭原则”的倾斜性六、三种工厂模式之间的关系七、总结参考资料 前面我们已经简单介绍了简单工厂模式和工厂方法模式，相信很多人对工厂模式（如果单独提到工厂模式，即包括简单工厂模式、工厂方法模式及本文即将介绍的抽象工厂模式）的思想都有了一定的理解。这里我们在简单回顾一下。
一、回顾 简单工厂模式的优缺点 优点
屏蔽产品的具体实现，调用者只关心产品的接口。实现简单 缺点
增加产品，需要修改工厂类，不符合开放-封闭原则工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则 工厂方法模式的优缺点 优点
继承了简单工厂模式的优点符合开放-封闭原则 缺点
增加产品，需要增加新的工厂类，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。 本文要介绍了抽象工厂模式，是在简单工厂模式和工厂方法模式的基础上衍生出的另外一种创建型设计模式。
二、概念 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。
抽象工厂模式提供了一种方式，可以将同一产品族的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。
产品族: 位于不同产品等级结构中,功能相关的产品组成的家族。如下面的例子，就有两个产品族
三、用途 抽象工厂模式和工厂方法模式一样，都符合开放-封闭原则。但是不同的是，工厂方法模式在增加一个具体产品的时候，都要增加对应的工厂。但是抽象工厂模式只有在新增一个类型的具体产品时才需要新增工厂。也就是说，工厂方法模式的一个工厂只能创建一个具体产品。而抽象工厂模式的一个工厂可以创建属于一类类型的多种具体产品。工厂创建产品的个数介于简单工厂模式和工厂方法模式之间。
在以下情况下可以使用抽象工厂模式：
一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。
系统中有多于一个的产品族，而每次只使用其中某一产品族。
属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。
系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。
四、实现方式 /** * 接口中修饰符： * Java 7 方法只能为抽象方法，默认为 public abstract * Java 8 增加：默认方法default；静态方法static（默认方法不强制重写，静态方法不会被实现类继承） * Java 9 增加：私有方法 * * 接口中不可以定义变量即只能定义常量，属性默认是public static final，且必须赋值 */ // 1.------------ 超级工厂，定义产品族 ------------ public interface IProductFactory { //生产手机 IPhoneProduct phoneProduct(); //生产路由器 IRouterProduct routerProduct(); } // 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f407556250482ce5baebff81299fc56c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0215b3346490017b3df120f12e81da67/" rel="bookmark">
			计算机网络参考模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
OSI七层参考模型
TCP/IP协议族的组成
数据封装过程​
PDU
设备与层的对应关系
OSI七层参考模型 应用层：人为的打开一个或多个程序
表示层：将人类输入的高级语言翻译成有电没电
话层会：管理计算机之间的通讯（开启或关闭会话）
传输层：把数据传输到对面的计算机 区分你系统上的程序 并且检测数据传输是否完整（传输层中有端口号用来区分你的程序名）
网络层：找路 根据IP地址去找路
数据链路层：根据mac地址 去判断是否我要找的计算机
物理层：转化成电流 TCP/IP协议族的组成 网络层协议：icmp：网络双向联通性检测 ping 检测两台计算机是否可以通信
ARP：将ip地址转换成mac地址 传输层：tcp 慢可靠
udp 快不可靠
应用层协议：http(网页) 超文本传输协议 端口号: 80 tcp https(网页) 超文本传输协议 端口号: 443 tcp 加密的http
ftp 文件共享协议 端口号：20 21 tcp TFTP 简单文件传输协议 端口号：69 udp 数据封装过程 PDU 传输层 tcp头部+上层数据 数据段
网络层 ip头部+tcp头部+上层数据 数据包 数据链路层 mac地址+ip头部+ tcp头部+上层数据+校验和 数据帧
物理层 比特流
设备与层的对应关系 应用——计算机
传输——防火墙
网络——路由器
数据——交换机
物理——网卡
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb3a12beb409851af62b089510e5379f/" rel="bookmark">
			DOM基础，classList属性提供的方法和属性，DOM中节点的操作，追加节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是DOM:
Document Object Modei :文档对象模型
2.DOM核心：document对象
3.DOM作用：
可以访问和操作xtml和HTML文档中的标签，标签的属性，节点的属性和方法
xtml:自己定义标签&lt;studentName&gt;&lt;/studentName&gt;
4.在DOM中将整个HTML文档看作一颗倒立的树(树状结构):一个HTML页面就是一个DOM对象，是一颗DOM HTML树
(1)DOM HTML数的根节点：HTML(根标签，只有一个)
(2)元素(Element)：HTML文档中的标签
(3)节点(node):文档中的内容
5.DOM树：浏览器的JavaScript引擎(谷歌的v8引擎)在解析页面时，采用树形结构来存放页面元素
DOM树中的节点的分类：
(1)标签节点：所有标签
(2)属性节点：标签的属性---内置属性，自定义属性
(3)文本节点：标签中的文本,换行符，空格等
(4)注释节点：&lt;!--注释内容--&gt;
6.节点的基本概念
(1)根节点：根节点是HTML，有且只有一个
(2)子节点：某个节点的下一级节点
(3)父节点：某个节点的上一级节点
(4)兄弟节点：拥有相同父节点的节点
通过document对象来操作HTML页面中的元素
1.getElenentByid('id属性值'):
通过标签的ID属性获取标签
2.getElenentsByName('name属性值')：
通过标签的name属性获取标签，返回值是NodeList(伪数组）
3.getElenentByTagName('标签名')：
通过标签名来获取标签，返回值的类型是HTMLCollcetion
4.getElenentsByClassName('class属性值')：
通过标签的class属性获取标签，返回值的类型是HTMLCollcetion
5. querySelector('#id值'):
返回一个指定id属性值的标签
querySelector('.class属性值')：
返回第一个指定class属性的标签
querySelector('标签名')：返回第一个指定标签名的标签
6.querySelectorAll('.class属性值')：
返回所有指定class属性值的标签，返回值类型NodeList
querySelectorAll('标签名')：
返回所有指定标签名的标签，返回值类型NodeList
获取操作的元素
document对象的属性
1.document.body：
返回对象的body元素，所有元素（标签）都可以得到
2.document.documentElement:
返回文档的HTML元素，包含head和body里面的标签
3.document.forms:
返回文档的form(表单)对象(是一个集合，length为form表单的数量)，只有一个表单时长度为1
Element对象的属性和方法:
在JavaScript代码中HTML的标签（Element）的属性和方法
(1)children:
用来获取某个元素的子元素
强调：HTMLCollcetion和NodeList区别
(1)HTMLCollcetion:通过document对象或Element对象调用
（2)NodeList对象：document对象调用调用getElementByName()方法在Chrome和FireFox浏览器返回的是NodeList对象。IE11返回的是HTMLCollcetion
(2)HTMLCollcetion对象用于元素操作
(3)Element对象用于节点操作
元素的属性和方法
(1)属性：
1.innerHTML:设置返回起始标签和结束标签之间的HTML（包括标签）
2.innerText:设置返回起始标签和结束标签之间的文本（不能解析标签---不识别标签）
3.textContent:设置或返回指定节点的内容(不识别console.log自带的换行)
(2)方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb3a12beb409851af62b089510e5379f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2d41f86a7b67795ba488767b720aad4/" rel="bookmark">
			eclipse添加插件的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在eclipse工具栏点击help-&gt;Eclipse Marketplace。
在这里插入图片描述
2.输入“coverage”搜索，点击install。
在这里插入图片描述
第二种：
1、在线安装插件
在Eclipse中点击Help-&gt;Install new software菜单，点击add
随便输入名称，url输入：http://update.eclemma.org/
勾选EclEmma，点击Next，接受协议，点击Finish，然后重启eclipse。
原文链接：https://blog.csdn.net/dongyuxu342719/article/details/90267343
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ccd9fbf5fce5d714cef270793e36db/" rel="bookmark">
			Floyd算法总结(C/C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一: Floyd算法分析二: 代码分析 一: Floyd算法分析 1. 问题介绍：
2. 问题分析：
a. 当我们需要处理多源最短路问题时候——Floyd算法
b. Floyd算法的原理其实就是基于动态规划的原理
简单理解 : Floyd算法其实就是类似于我们的背包问题，背包问题的过程就是最外层循环物品，然后内层依次循环空间大小，其原理就是当我们可以使用第一个物品时候的最优解，可以使用第一到第二个物品时候的最优解,…直到走到最后一层循我们得到的结果就是使用了1—n个物品后得到的最优解了
Flody算法核心：类似于背包问题，我们同样需要枚举所有的点，依次得到当我们只借用了第一个点后的最短路解，借用了第一个第二个点后的最短路解…直到得到借用了1—n个点后的最短路解。
//外层枚举所有的点代表, 当 k = t 时代表借用了 1 - t 个点可以作为中间点后得到的最优解结果 for(int k = 1; k &lt;= n; k ++ ){ for(int i = 1; i &lt;= n; i ++ ){ for(int j = 1; j &lt;= n; j++){ d[i][j] = min(d[i][j], d[i][k] + d[k][j] ); } } } c. Floyd事件复杂度: O(n * n * n)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71ccd9fbf5fce5d714cef270793e36db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d1baaf413e9ee8a9e23f0196a0b7280/" rel="bookmark">
			最短路算法总结(C/C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.单源——边权为正——Dijkstra()2.单源——边权为负——边数限制——Bellman-ford()3.单源——边权为负——Spfa()4.多源——Floyd() 1.单源——边权为正——Dijkstra() 朴素版：利用贪心算法不断选择最近点 —— 更新优化的点和其他点
时间复杂度 : O(nn)
优化版：利用贪心算法不断选择最近点 —— 更新优化的点相连的边
时间复杂度 : O(m logm)
Dijkstra详细说明+代码 链接
2.单源——边权为负——边数限制——Bellman-ford() 原理：外层循环边数限制 + 内层循环所有边 —— 相当于从源点开始不断松弛最优解
时间复杂度 : O(nm)
Bellman-ford详细说明+代码 链接
3.单源——边权为负——Spfa() 原理：
理解1. 优化了Bellman-ford算法，只对松弛过程中被优化的点再去入队列进行优化
理解2. 类似于Dijkstra算法，不同的是它每次选点不一定是最优解需要重复入队列，直到点与点之间无法再进行优化得到最优解
时间复杂度 : O(m) —— O(mn)
Spfa详细说明+代码 链接
4.多源——Floyd() 原理：
类似于背包问题： 外层枚举依次借用作为中间桥梁的点 + 内层循环任意两个点借用这中间桥梁点得到的最优解
时间复杂度 : O(nnn)
Floyd详细说明+代码 链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/454afa2492b54325e7f99e100f1d4cdf/" rel="bookmark">
			VsCode实用插件推荐，提高你的开发效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		辅助开发类： 1. Vetur VUE开发必备插件
1.语法高亮，包括 vue/html css/sass/scss/less/stylus js/ts
2.语义高亮，除了支持template模板以外，还支持大多数主流的前端开发脚本和插件
3.语法错误检查，包括 CSS/SCSS/LESS/Javascript/TypeScript
4.emmet 支持
5.支持调试
6.代码片段自动补全 包括 HTML/CSS/SCSS/LESS/JavaScript/TypeScript
2. Vue 3 Snippets 包含所有的 Vue.js 2 和 Vue.js 3 的 api 对应的代码片段
3. Prettier Formatter 代码格式化工具
1.可配置化
2.支持多种语言
3.集成多数的编辑器
4.简洁的配置项
4.Path Intellisense 路径补全，自动提示文件名
视觉提升类： 1.vscode-icons
VsCode 文件图标插件，区分文件夹、node_module、vue、html、JS等不同文件类型
2.Bracket Pair Colorizer
括号对色器，区分相对应的括号()，花括号{}、中括号[]等
3.Background vscode自定义背景图设置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/515a00ea2ce7e9493670787f40e5261c/" rel="bookmark">
			机器学习从零到入门 集成学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集成学习 Bagging与Boosting 一、一个小故事二、集成学习 - Ensemble Learning1、弱学习器与强学习器2、集成学习的具体步骤3、集成方法 - Ensemble methods3.1、Bagging及相关模型3.1.1、Bagging3.1.2、Random Forest 3.2、Boosting及相关模型3.2.1、Boosting3.2.2、Adaboost3.2.3、GBDT3.2.4、机器学习神器3.2.4.1、XGBoost3.2.4.2、lightGBM3.2.4.3、CatBoost 参考 一、一个小故事 在现代生活中，很多地方都涉及一个概念：冗余 (Redundancy)，它原本是一种贬义词，指的是某些东西(信息、语言、代码、结构、服务、软件、硬件等等)重复且多余。
然而在通信存储等领域，它则成了中性词，是指对某些东西进行人为增加重复的部分，比如对某样东西进行备份，从而增强其安全性。对于这个概念，其中一个应用比较广泛的地方是航天系统。
SpaceX是一家著名的太空探索技术公司，其中比较知名的有其生产的Dragon系列载人龙飞船。因为太空的环境安全标准比地球严格非常多，所以制造飞船的材料也很特殊和昂贵，除此之外，还需要功能强大的超级计算机安置在飞船内部供宇航员进行监测和操控，以便维持飞船的正常轨迹运行。
然而在太空环境中，某些影响因素会导致计算机出现一些错误，比较典型的有：太空粒子翻转 (SEU，Single-Event Upsets)，它是指在空间环境下存在着大量高能带电粒子，计算机中的电子元器件受到地球磁场、宇宙射线等照射，引起电位状态的跳变，“0"变成"1”，或者"1"变成"0"(太空探索早期人们已经注意到了这个问题)。
在地球表面，有磁场和大气层的保护，能够到达地面的高能粒子很少，一般来说对计算机的影响不大(当然除了人为制造或自然界的放射性物质，还有极低概率的宇宙粒子穿透地地球表面的大气层和磁场来到我们的生活区)，所以在计算机设计中，并不需要过多考虑这种特殊场景，常规的硬件纠错机制配合操作系统，足以应付这种偶然的误差。计算机对于错误若实在改不过来，蓝屏重启，可能也就复原了。
然而在太空环境下，单粒子翻转的概率会大得多，那么校验算法会极其困难，因为单粒子翻转的可能不止一位，那么如何解决该问题，提高可靠性呢？
飞船的计算机和我们使用的计算机可靠性要求是不一样的，我们使用的计算机可以死机蓝屏，大不了重启一下就可以了，但飞船本身的控制计算机是必须持续可靠运行的，一旦出了问题，肯定是致命的。
SpaceX设计了一套整体容错三重冗余计算机架构(an overall Fault tolerance triple redundant computer architecture)，即由多台计算机运行同一个软件，结果由多数表决系统处理产生一个单一的输出，正确的大多数计算结果会纠正和掩盖其他少数错误的故障。(某些领域使用N重冗余，结果计算方法类似，即多数表决)。虽然每台处理器都可能发生位翻转，但我们知道飞机上同时有两枚炸弹的概率是极低的。
某航天器在执行为期5天的航空任务中，单粒子翻转出现了161次之多，可见在外太空环境下，计算机计算结果的可靠性非常重要。
所以，与其花费巨大的人力物力制造一台几乎不受任何辐射粒子影响的先进超级计算机，不如带几台相对普通的超级计算机一起工作，无论是可靠性还是成本等其他方面，都比先进计算机要更好。
于是，借助这个思想，后面便引申出了机器学习算法中，集成学习(ensemble)的概念。
太空计算机为什么性能都这么低？(zhihu)
SINGLE EVENT UPSETS: HIGH ENERGY PARTICLES FROM OUTER SPACE FLIPPING BITS (hackaday)
Single-event_upset (wikipedia)
SpaceX_Dragon (wikipedia)
Triple_modular_redundancy (wikipedia)
二、集成学习 - Ensemble Learning 在数据挖掘等应用中，直接建立一个高性能的分学习器是很困难的，但是，如果能找到一系列性能较差的学习器(弱学习器)，并把它们集合起来，组合之后的效果可能高于性能较强的学习器(强学习器)。
“三个臭皮匠，胜过诸葛亮”便是对这种思想最好的解释。
1、弱学习器与强学习器 弱学习器 (Weak Learner)
强学习器 (Strong Learner)
弱学习器是指，分类正确率仅比随机猜测略高的学习算法，
2、集成学习的具体步骤 集成学习的具体步骤为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/515a00ea2ce7e9493670787f40e5261c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40c5c32641885a57957686fb8ed1be41/" rel="bookmark">
			python学习之基础语法条件语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 1条件语句1语法格式2缩进和代码块3空语句 2循环语句 1条件语句 1语法格式 2缩进和代码块 严格规范，禁止创造
3空语句 2循环语句 while 条件: 循环体 # for循环 # for 循环变量 in 可迭代对象: # 循环体 # 可迭代对象： # 特殊的变量~ 内部包含了很多其他的值 # # 例题: # 打印1-10 a = 1 for a in range(1,11): print(a) # 打印： 2 4 6 8 10 a = 2 for a in range(2,11,2): print(a) # 打印 10-1 a = 10 for a in range(10,0,-1): print(a) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3a3d8da5f92fdbbccc1aaba60a19e97/" rel="bookmark">
			sql 语句优化实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 sql 语句优化实战order by文件排序原理 group by优化limit 分页优化join优化in和exists优化count优化用union all代替union批量插入增量查询 sql 语句优化实战 order by # 为表employees创建联合索引 create index idx_name_age_position on employees(name,age,position) # using filesort Explain select * from employees where name='zs' order by position; 优化后：select * from employees where name='zs' order by age, position # 满足最左前缀法则，使用了索引树 Explain select * from employees where name='zs' order by age, position; # 不满足最左前缀法则，使用了文件排序 Explain select * from employees where name='zs' order by position, age; # 满足最左前缀法则，使用了索引树 Explain select * from employees where name='zs' and age=20 order by position age; # 和索引树排序方向不同，使用了文件排序 Explain select * from employees where name='zs' and age=20 order by age, position desc; # 范围查询（让索引name失效了），使用了文件排序 Explain select * from employees where name in ('zs','lise') order by age, position; # 范围查询，使用了文件排序 Explain select * from employees where name &gt; 'zs' order by name; # 该表共有3百万条数据，name &gt; 'zs'的共有250万条，所以就没有必要再去走索引树了，直接遍历即可 总结：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3a3d8da5f92fdbbccc1aaba60a19e97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2989a0e94c023e5833bfd7162b44b47f/" rel="bookmark">
			mysql字段及索引操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Mysql表结构操作-- 增加字段 设置字段类型为bigint(11)-- 修改字段类型bigint(11)(原类型)为varchar(200)-- 普通索引-- 唯一索引-- 唯一联合索引-- 删除索引--建立索引的原则 Mysql表结构操作 – 增加字段 设置字段类型为bigint(11) 给表结构新增一个字段
alter table 表名 add 字段名 bigint(11) DEFAULT NULL COMMENT '注释'; – 修改字段类型bigint(11)(原类型)为varchar(200) 修改表结构原字段的类型
alter table 表名 modify column 字段名 varchar(200) COMMENT '注释'; – 普通索引 加快查询速度
索引为什么可以提高查询效率
​ 索引本是一种数据结构 , 在MySQL的定义就是来高效获取数据的一种数据结构
因为索引的结构最大化的减少数据库的I/O次数,I/O的次数少了,查询的效率就高了
ALTER TABLE 表名 ADD index 索引名 (`字段名`) – 唯一索引 加快查询速度，并且可以限制列值的唯一性，允许为空
ALTER TABLE 表名 ADD UNIQUE (`字段名`) – 唯一联合索引 多列形成的唯一索引，这些列可以唯一确定一条表记录，可以为空
ALTER TABLE 表名 ADD UNIQUE INDEX 索引名 (`字段名`, `字段名`) – 删除索引 删除不需要的索引,索引过多会影响查询速度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2989a0e94c023e5833bfd7162b44b47f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a112f91231fa504c3c2ae23af9ded31/" rel="bookmark">
			数据结构——树状数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树状数组 **前言：**树状数组现在多用于解决单点修改，求前缀和工作，时间复杂度均为 O ( l o g n ) O(logn) O(logn)，空间复杂度为 O ( n ) O(n) O(n)。相比较于线段树，树状数组的作用就显得比较局限，但是它的优点就在于它的常数比较小。线段树在未优化的情况下空间复杂度为 O ( 2 n ) O(2n) O(2n)，有时候为了防治溢出往往要开长度为 4 n 4n 4n的数组。
树状数组基本思想 树状数组主要依赖于任何数都可以转化成 2 i 2^i 2i相加的形式，例如 7 = 2 2 + 2 1 + 2 0 7=2^2+2^1+2^0 7=22+21+20，并且如果按照指数从大到小进行区间划分，那么 [ 1 − 7 ] [1-7] [1−7]这个区间可以划分成 [ 1 − 4 ] , [ 5 − 6 ] , [ 7 , 7 ] [1-4],[5-6],[7,7] [1−4],[5−6],[7,7]这三个区间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a112f91231fa504c3c2ae23af9ded31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee9ec686738c07ecb3b3f5fa37a39ee7/" rel="bookmark">
			Oracle 19c 安装（Linux）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统基础配置 本章节所有操作使用root用户
su - root 关闭防火墙和SELINUX 关闭运行中的防火墙 #service iptables stop 关闭操作系统自启动 #chkconfig iptables off 检查关闭情况 # chkconfig --list iptables 关闭selinux：
编辑/etc/selinux/config 文件
# This file controls the state of SELinux on the system. # SELINUX= can take one of these three values: # enforcing - SELinux security policy is enforced. # permissive - SELinux prints warnings instead of enforcing. # disabled - SELinux is fully disabled. SELINUX=disabled # SELINUXTYPE= type of policy in use.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee9ec686738c07ecb3b3f5fa37a39ee7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03dca16431c4d7f38684423b4df0a906/" rel="bookmark">
			JVM学习(尚硅谷)之垃圾回收相关概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		System.gc()的理解：出发Full GC
只有System.gc()/Runtime.getRuntime().gc()时，只能提醒JVM进行GC，实际不一定马上进行GC操作，当调用System.runFinalization()之后，会强制调用失去引用的对象的finalize（）方法
注意下面中有代码块的情况的垃圾回收结果：
内存溢出与内存泄漏：
内存溢出（OOM）：
内存泄露（Memory Leak）：
内存泄漏的图示：
内存泄漏的例子：
STW：
并行（parallel）与并发（concurrent）：
垃圾回收的并行与并发：
安全点和安全区域
在特定位置停下来进行GC，停下来的位置叫做安全点
发生GC时，检查所有线程都跑到安全点停顿下来：主动轮询操作
安全区域;
引用：
强引用：à不回收
强引用特点：
可以直接访问目标对象强引用所指向的目标对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常也不会回收强引用所指对象强引用可能导致内存泄漏 软引用：à内存不足即回收
这里所说的二次回收是因为先把不可达的对象进行回收，再研究可达对象中的可回收部分。
特点：
当内存足够时，不会回收软引用所达对象，当内存不够时，会回收软引用的可达对象
软引用实现代码：
弱引用：à发现即回收
弱引用的使用及与软引用的区别：
虚引用：
终结器引用（了解）：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1909ba520f998dd7ae62a9ba34634446/" rel="bookmark">
			HTTP文件共享传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：独笔孤行
公众号：云实战
官网：​​http://anyamaze.com​​
前言
HTTP是超文本传输协议，通过http协议即可搭建网站，提供访问web，也可以实现文件的共享传输。实现文件传输，可直接使用httpd或SimpleHTTPServer服务。
一、安装httpd
执行安装httpd命令
yum install httpd 二、配置httpd
所有修改在/etc/httpd/conf/httpd.conf配置文件中
vi /etc/httpd/conf/httpd.conf 2.1 修改端口号
# Listen: Allows you to bind Apache to specific IP addresses and/or # ports, instead of the default. See also the &lt;VirtualHost&gt; # directive. # # Change this to Listen on specific IP addresses as shown below to # prevent Apache from glomming onto all bound IP addresses. # # Listen 12.34.56.78:80 Listen 80 # 根据实际情况修改 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1909ba520f998dd7ae62a9ba34634446/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be745ab5bd5b90df61748fd6fd1fbda/" rel="bookmark">
			海鸥优化算法（Seagull Optimization Algorithm，SOA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 算法思想2 算法步骤3 求解函数最值（Python实现）4 算法进阶直接改进SOA融合别的智能优化算法来改进SMASMA及其改进的应用 原论文： [1]Gaurav Dhiman, Vijay Kumar. Seagull optimization algorithm: Theory and its applications for large-scale industrial engineering problems. Knowledge-Based Systems. 2019(165), 169-196. 1 算法思想 借鉴生物行为：
海鸥的迁徙和攻击行为。海鸥根据季节更替进行迁徙，迁徙飞行时海鸥会避免相互碰撞；海鸥会攻击猎物，攻击时呈螺旋形的运动形态；在一个群体中，海鸥朝着最佳位置的方向前进。
2 算法步骤 初始化参数；初始化种群位置；计算适应度值并保留全局最优位置；迁徙，全局搜索：
抽象海鸥的迁徙行为主要有三步，第一要满足避免碰撞条件（这样可以确保种群多样性）；第二要计算最佳位置的方向；第三要根据该方向移动到新的位置。
第一，计算不与相邻海鸥碰撞的新位置 C s ( t ) C_s(t) Cs​(t)：
C s ( t ) = A × P s ( t ) A = f c − ( t × f c M a x i t e r a t i o n ) C_s(t)=A×P_s(t) \\ A = f_c-(t×\frac{f_c}{Max_{iteration}}) Cs​(t)=A×Ps​(t)A=fc​−(t×Maxiteration​fc​​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2be745ab5bd5b90df61748fd6fd1fbda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c78f43ce5dfda690c76e5c5e72ebd0b/" rel="bookmark">
			c/c&#43;&#43;下时间函数总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GMT：格林尼治标准时间，以英国格林尼治天文台上的本初子午线（精度为0的经线）为标准。
UTC：协调世界时间，基本与GMT时间相同，使用原子钟来计算，所以更加精确。
本地时间：UTC + 时区差。
UNIX时间戳: 自1970年1月1日0点到现在秒数。
夏令时：到夏季开始的时候将时钟调快一小时，夏季结束的时候再将时钟调慢一小时以恢复正常时间。夏令时能够使人们早睡早起，有利于节省电力资源。
1、time_t time(time_t * timer);
time()函数通过返回值或参数获得本机的当前日历时间（从1970年1月1日0时0分0秒到现在经过的秒数），time_t实际上是一个long long。linux下time_t是int，这样会引发2038年问题。
2、struct tm * gmtime(const time_t *timer);
struct tm *localtime(const time_t * timer);
上面两个函数将日历时间转换为tm结构体所表示的时间类型，其中gmtime()函数转化为世界标准时间（格林尼治时间），localtime()转化为本地时间（带时区的时间）。
tm结构体成员：
struct tm {
int tm_sec; /* 秒[0,59] */
int tm_min; /* 分[0,59] */
int tm_hour; /* 时[0,23] */
int tm_mday; /* 日[1,31] */
int tm_mon; /* 月[0,11]，其值+1为实际月份 */
int tm_year; /* 年，其值+1900为实际年份 */
int tm_wday; /* 星期[0,6]，其中0代表星期天，1代表星期一，以此类推，此成员可以忽略不填 */
int tm_yday; /* 从1月1日开始的天数[0,365]，此成员可以忽略不填*/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c78f43ce5dfda690c76e5c5e72ebd0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22bfc5961a418ed52fec266b2ae9ba8e/" rel="bookmark">
			android 约束布局关于chain链的运用的总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果就是通过链式水平排列，加了权重，同时设置控件的宽高比重
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;LinearLayout android:id="@+id/ll_left" android:layout_width="0dp" android:layout_height="200dp" android:background="@drawable/ic_bg_green" app:layout_constraintDimensionRatio="1:1" android:gravity="center" android:orientation="vertical" app:layout_constraintEnd_toStartOf="@+id/ll_middle" app:layout_constraintHorizontal_weight="2" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent"&gt; &lt;ImageView android:id="@+id/iv_cook" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/ic_smartcook" /&gt; &lt;TextView android:id="@+id/tv_cook_descrip" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:text="" android:textColor="@color/white" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/ll_middle" android:layout_width="0dp" android:layout_height="200dp" android:background="@drawable/ic_bg_blue" app:layout_constraintDimensionRatio="1:1" android:gravity="center" android:orientation="vertical" app:layout_constraintEnd_toStartOf="@+id/ll_setting" app:layout_constraintHorizontal_weight="2" app:layout_constraintStart_toEndOf="@+id/ll_left" app:layout_constraintTop_toTopOf="parent"&gt; &lt;ImageView android:id="@+id/iv_major_cook" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/ic_smartcook" /&gt; &lt;TextView android:id="@+id/tv_major_cook_descrip" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:text="" android:textColor="@color/white" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/ll_setting" android:layout_width="0dp" android:layout_height="200dp" android:layout_weight="1" android:background="@drawable/ic_bg_set" app:layout_constraintDimensionRatio="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22bfc5961a418ed52fec266b2ae9ba8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47cfe87f8ecd70dd0fad30941272b45b/" rel="bookmark">
			Web Speech API-语音合成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用场景 通过 TTS 引擎把文本转化成语音输出，web使用在网页文字转语音播放、页面阅读等功能上
依赖windows的TTS引擎
知识点 Web Speech API 使您能够将语音数据合并到 Web 应用程序中。 Web Speech API 有两个部分：SpeechSynthesis 语音合成（文本到语音 TTS）和 SpeechRecognition 语音识别（异步语音识别）。
API 包含以下两个部分：
-语音识别：通过 SpeechRecognition 接口进行访问，它提供了识别从音频输入（通常是设备默认的语音识别服务）中识别语音情景的能力。一般来说，你将使用该接口的构造函数来构造一个新的 SpeechRecognition 对象，该对象包含了一系列有效的对象处理函数来检测识别设备麦克风中的语音输入。SpeechGrammar 接口则表示了你应用中想要识别的特定文法。文法则通过 JSpeech Grammar Format (JSGF.) 来定义。
-语音合成：通过 SpeechSynthesis 接口进行访问，它提供了文字到语音（TTS）的能力，这使得程序能够读出它们的文字内容（通常使用设备默认的语音合成器）。不同的声音类类型通过 SpeechSynthesisVoice (en-US) 对象进行表示，不同部分的文字则由 SpeechSynthesisUtterance 对象来表示。你可以将它们传递给 SpeechSynthesis.speak() (en-US) 方法来产生语音。
语音合成 SpeechSynthesis 用于获取设备上关于可用的合成声音的信息，开始、暂停语音，或除此之外的其他命令 SpeechSynthesis.getVoices() 返回当前设备所有可用声音的 SpeechSynthesisVoice列表–异步方法SpeechSynthesis.onvoiceschanged 当由SpeechSynthesis.getVoices()方法返回SpeechSynthesisVoice列表改变时触发。SpeechSynthesis.speak()添加一个utterance 到语音谈话队列；在其他语音谈话播放完之后播放 SpeechSynthesisUtterance 一次发音请求,包含将由语音服务朗读的内容，以及如何朗读它（例如：语种、音高、音量），用于speak SpeechSynthesisUtterance.lang 语种&gt; SpeechSynthesisUtterance.voice 语音包&gt; SpeechSynthesisUtterance.volume 音量
SpeechSynthesisVoice 系统提供的一个声音。每个 SpeechSynthesisVoice 都有与之相关的发音服务，包括了语种、名称 和 URI 等信息。也就是getVoices()返回的数据对象 SpeechSynthesisVoice.lang&gt; SpeechSynthesisVoice.voiceURI
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47cfe87f8ecd70dd0fad30941272b45b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5708802f758728d4ff3ea1e0f8d29cf/" rel="bookmark">
			Python packing tools not found.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sudo apt-get install python3-pip 如果出错的话，
sudo apt-get update sudo apt-get install python3-pip 成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ebde58ee0256396cdd8c529cb7a9a93/" rel="bookmark">
			ORA-00933: SQL命令未正确结束 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.报错内容 Cause: java.sql.SQLSyntaxErrorException: ORA-00933: SQL 命令未正确结束
; bad SQL grammar []; nested exception is java.sql.SQLSyntaxErrorException: ORA-00933: SQL 命令未正确结束] with root cause
2.解决办法： 因为在xml里面的sql语句结尾使用了 “;” 。去掉“；”就行了
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/215/">«</a>
	<span class="pagination__item pagination__item--current">216/578</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/217/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>